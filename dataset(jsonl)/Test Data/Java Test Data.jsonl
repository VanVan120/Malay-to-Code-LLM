{"text": "Jumlah minimum mungkin dengan mengeluarkan semua kejadian mana -mana elemen array | Program Java untuk pendekatan di atas; Berfungsi untuk mencari jumlah minimum selepas penghapusan; Kedai kekerapan elemen array; Melintasi array; Hitung jumlah; Kekerapan kemas kini elemen semasa; Menyimpan jumlah minimum yang diperlukan; Peta Traverse; Cari jumlah minimum yang diperoleh; Kembali jumlah minimum; Kod pemacu; Arahan input; Saiz array", "code": "import java . util . * ; class GFG { static int minSum ( int A [ ] , int N ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( mp . containsKey ( A [ i ] ) ) { mp . put ( A [ i ] , mp . get ( A [ i ] ) + 1 ) ; } else { mp . put ( A [ i ] , 1 ) ; } } int minSum = Integer . MAX_VALUE ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { minSum = Math . min ( minSum , sum - ( it . getKey ( ) * it . getValue ( ) ) ) ; } return minSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 6 , 6 } ; int N = arr . length ; System . out . print ( minSum ( arr , N ) + \"NEW_LINE\"); } }"}
{"text": "Perbezaan maksimum antara sepasang elemen bersebelahan dengan tidak termasuk setiap elemen sekali | Pelaksanaan Java pendekatan di atas; Fungsi untuk mengira perbezaan maksimum antara elemen bersebelahan tidak termasuk setiap elemen array sekali; Melintasi array; Menyimpan perbezaan maksimum; Semak elemen bersebelahan maksimum; Tidak termasuk elemen semasa; Mengemas kini perbezaan maksimum; Mengemas kini nilai sebelumnya; Tambah hasilnya ke dalam vektor; Cetak hasilnya; Kod pemacu", "code": "import java . util . * ; class GFG { static void maxAdjacent ( int [ ] arr , int N ) { ArrayList < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { int prev = arr [ 0 ] ; int maxi = Integer . MIN_VALUE ; for ( int j = 1 ; j < N ; j ++ ) { if ( i == j ) continue ; maxi = Math . max ( maxi , Math . abs ( arr [ j ] - prev ) ) ; prev = arr [ j ] ; } res . add ( maxi ) ; } for ( int x : res ) { System . out . print ( x + \" ▁ \" ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 7 , 8 } ; int N = arr . length ; maxAdjacent ( arr , N ) ; } }"}
{"text": "Kira 1 S hadir dalam pelbagai indeks [l, r] dalam array yang diberikan | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari saiz array jika array pada mulanya mengandungi elemen tunggal; Kes asas; P / 2 -> findSize (n / 2) p % 2 -> 1 p / 2 -> findSize (n / 2); Berfungsi untuk mengembalikan kiraan 1 s dalam julat [l, r]; Kes asas; Bahagian 1 -> n / 2 [1, siz_m]; Kemas kini titik akhir kanan julat ke min (Siz_m, r); Bahagian 2 -> n % 2 [Sizm + 1, Siz_m + 1]; Bahagian 3 -> n / 2 [Sizm + 2, 2 * Siz_m - 1] Sama seperti Bahagian 1 harta simetrik beralih koordinat mengikut bahagian 1 tolak (siz_m + 1) dari kedua -dua l, r; Kod pemacu; Input; Mengira bilangan 1 dalam julat [l, r]", "code": "import java . util . * ; class GFG { static int findSize ( int N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N / 2 ) + 1 ; return Size ; } static int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N / 2 ; int Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( N / 2 , L , Math . min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( N / 2 , Math . max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; } public static void main ( String [ ] args ) { int N = 7 , L = 2 , R = 5 ; System . out . println ( CountOnes ( N , L , R ) ) ; } }"}
{"text": "Cari pasangan (a, b) dengan LCM minimum supaya jumlahnya sama dengan n | Program Java untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kerana 1 bukan pulangan utama atau komposit palsu; Semak jika ia dibahagikan dengan mana -mana nombor maka ia bukan perdana, kembali palsu; Semak jika n tidak dibahagikan dengan mana -mana nombor maka ia adalah perdana dan oleh itu kembali benar; Fungsi untuk mencari pasangan (a, b) seperti jumlah yang N & LCM adalah minimum; Semak sama ada nombor itu adalah perdana; Sekarang, jika tidak perdana maka cari yang paling kurang divisior; Semak jika membahagikan n maka ia adalah faktor; Output yang diperlukan ialah A = N / I & B = N / I * (n - 1); Kod pemacu; Panggilan fungsi", "code": "class GFG { static boolean prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void minDivisior ( int n ) { if ( prime ( n ) ) { System . out . print ( 1 + \" ▁ \" + ( n - 1 ) ) ; } else { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { System . out . print ( n / i + \" ▁ \" + ( n / i * ( i - 1 ) ) ) ; break ; } } } } public static void main ( String [ ] args ) { int N = 4 ; minDivisior ( N ) ; } }"}
{"text": "Cari fungsi Landau untuk nombor tertentu n | Program Java untuk pendekatan di atas; Untuk menyimpan fungsi Landau nombor; Berfungsi untuk mengembalikan GCD sebanyak 2 nombor; Berfungsi untuk mengembalikan LCM dua nombor; Fungsi untuk mencari nilai lcm max di antara semua perwakilan n; Hitung nilai Landau; Fungsi rekursif untuk mencari cara yang berbeza di mana n boleh ditulis sebagai jumlah atleast satu bilangan bulat positif; Semak jika jumlah menjadi n, pertimbangkan perwakilan ini; Bermula dari elemen sebelumnya dalam perwakilan sehingga n; Termasuk elemen semasa dari perwakilan; Fungsi panggilan sekali lagi dengan jumlah yang dikurangkan; Backtrack - Keluarkan elemen semasa dari perwakilan; Berfungsi untuk mencari fungsi Landau; Menggunakan kambuhan mencari cara yang berbeza di mana n boleh ditulis sebagai sejumlah atleast satu + ve integer; Cetak hasilnya; Kod pemacu; Diberikan n; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int Landau = Integer . MIN_VALUE ; static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } static void findLCM ( Vector < Integer > arr ) { int nth_lcm = arr . get ( 0 ) ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) nth_lcm = lcm ( nth_lcm , arr . get ( i ) ) ; Landau = Math . max ( Landau , nth_lcm ) ; } static void findWays ( Vector < Integer > arr , int i , int n ) { if ( n == 0 ) findLCM ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . add ( j ) ; findWays ( arr , j , n - j ) ; arr . remove ( arr . size ( ) - 1 ) ; } } static void Landau_function ( int n ) { Vector < Integer > arr = new Vector < > ( ) ; findWays ( arr , 1 , n ) ; System . out . print ( Landau ) ; } public static void main ( String [ ] args ) { int N = 4 ; Landau_function ( N ) ; } }"}
{"text": "Semak jika baki N | Pelaksanaan Java untuk memeriksa ungkapan berikut untuk integer n adalah sah atau tidak; Fungsi untuk memeriksa sama ada nombor memegang syarat (n - 1)! % N = n - 1; Kes sudut; Nombor yang boleh dibahagikan dengan 2 atau 3 bukanlah perdana; Melangkah dari 5 dan terus memeriksa perdana; Fungsi untuk memeriksa ungkapan untuk nilai n; Kod pemacu", "code": "class GFG { static boolean isPrime ( int n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static void checkExpression ( int n ) { if ( isPrime ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } public static void main ( String [ ] args ) { int N = 3 ; checkExpression ( N ) ; } }"}
{"text": "Semak sama ada mungkin untuk memecah array yang diberikan ke dalam K Odd | Pelaksanaan Java untuk memeriksa sama ada mungkin untuk memecah array ke dalam subset K dengan jumlah ganjil; Fungsi untuk memeriksa sama ada array boleh dibahagikan dalam subset k yang diperlukan; Menyimpan kiraan nombor ganjil; Semak jika elemen ganjil; Semak jika perpecahan mungkin; Kod pemacu", "code": "class GFG { static boolean checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 7 , 5 , 3 , 1 } ; int n = arr . length ; int k = 4 ; if ( checkArray ( n , k , arr ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text": "Jumlah pembahagian pasangan yang mungkin untuk array yang diberikan | Pelaksanaan Java untuk mengira jumlah pembahagian semua pasangan yang mungkin untuk array yang diberikan; Berfungsi untuk mengira jumlah; Mengira kekerapan setiap istilah dan mencari maksimum di antara ia; Membuat kekerapan kumulatif; Mengambil nilai Ceil; nos. Dalam julat [(n - 0.5) x, (n + 0.5) x) akan menambah n ke ANS; Mengembalikan hasil akhir; Kod pemacu", "code": "class GFG { static long func ( int arr [ ] , int n ) { double ans = 0 ; int maxx = 0 ; double freq [ ] = new double [ 100005 ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = Math . max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] != 0 ) { double j ; double cur = Math . ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = Math . min ( maxx , ( int ) ( Math . ceil ( i * j ) - 1.0 ) ) ; int times = ( int ) ( freq [ i ] - freq [ i - 1 ] ) , con = ( int ) ( j - 0.5 ) ; ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( long ) ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( func ( arr , n ) + \"NEW_LINE\"); } }"}
{"text": "Count of Elements hendaklah dimasukkan untuk membuat array Jumlah dua kali xor array | Program Java untuk mencari kiraan elemen yang akan dimasukkan untuk membuat jumlah array dua kali ganda XOR array; Fungsi untuk mencari bilangan elemen minimum yang perlu dimasukkan supaya jumlah unsur -unsur array adalah dua kali ganda XOR array; Pembolehubah untuk menyimpan XOR semua elemen; Pembolehubah untuk menyimpan jumlah semua elemen; Gelung untuk mencari XOR dan jumlah array; Jika jumlah = 2 * xor; Tidak perlu memasukkan lebih banyak elemen; Kami memasukkan satu lagi elemen yang jumlahnya; Kami memasukkan dua lagi elemen SUM + XOR dan XOR. ; Cetak bilangan elemen yang dimasukkan dalam array; Cetak unsur -unsur yang dimasukkan dalam array; Kod pemacu", "code": "class GFG { static void insert_element ( int a [ ] , int n ) { int Xor = 0 ; int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; } if ( Sum == 2 * Xor ) { System . out . println ( \"0\" ) ; return ; } if ( Xor == 0 ) { System . out . println ( \"1\" ) ; System . out . println ( Sum ) ; return ; } int num1 = Sum + Xor ; int num2 = Xor ; System . out . print ( \"2\" ) ; System . out . println ( num1 + \" ▁ \" + num2 ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 } ; int n = a . length ; insert_element ( a , n ) ; } }"}
{"text": "Periksa sama ada akar persamaan kuadrat adalah timbal balik antara satu sama lain atau tidak | Program Java untuk memeriksa sama ada akar persamaan kuadrat adalah timbal balik antara satu sama lain atau tidak; Berfungsi untuk memeriksa sama ada akar persamaan kuadratik adalah timbal balik antara satu sama lain atau tidak; Kod pemacu", "code": "class GFG { static void checkSolution ( int a , int b , int c ) { if ( a == c ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; } }"}
{"text": "Nombor Sunny | Program Java untuk pendekatan di atas; Periksa fungsi sama ada x adalah persegi yang sempurna atau tidak; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Berfungsi untuk memeriksa nombor cerah; Semak jika (n + 1) adalah persegi yang sempurna atau tidak; Jika (n + 1) bukan persegi yang sempurna; Kod pemacu; Nombor yang diberikan; Panggilan fungsi", "code": "import java . util . * ; class GFG { static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static void checkSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } public static void main ( String [ ] args ) { int N = 8 ; checkSunnyNumber ( N ) ; } }"}
{"text": "Kira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan | Program Java untuk mengira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan; Fungsi untuk mengira nombor yang boleh menukar n ke 1 menggunakan operasi yang diberikan; Melangkah melalui semua bilangan bulat; Semak jika n boleh ditukar kepada 1; Meningkatkan kiraan jika ia boleh ditukar; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; } public static void main ( String args [ ] ) { int N = 6 ; System . out . print ( countValues ( N ) ) ; } }"}
{"text": "Cari nombor k dengan jumlah yang sama dengan N dan jumlah kotak mereka dimaksimumkan | Program Java untuk mencari nombor K dengan jumlah yang sama dengan N dan jumlah dataran mereka dimaksimumkan; Fungsi yang mencetak nombor k yang diperlukan; Cetak 1, k - 1 kali; Cetak (n - k + 1); Kod pemacu", "code": "class GFG { static void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) System . out . print ( 1 + \" ▁ \" ) ; System . out . print ( N - K + 1 ) ; } public static void main ( String [ ] args ) { int N = 10 , K = 3 ; printKNumbers ( N , K ) ; } }"}
{"text": "Cetak nth larian atau nombor autobiografi | Pelaksanaan Java untuk mencari nombor semulajadi; Berfungsi untuk mencari nombor semula jadi yang melangkah; Mengisytiharkan barisan; Enqueue 1, 2, ..., 9 dalam perintah ini; Melakukan operasi k pada barisan; Dapatkan nombor langkah itu; Melakukan dequeue dari barisan; Jika x mod 10 tidak sama dengan 0; Kemudian enqueue 10 x + (x mod 10) - 1; Enqueue 10 x + (x mod 10); Jika x mod 10 tidak sama dengan 9; Kemudian enqueue 10 x + (x mod 10) + 1; Kembalikan jumlah operasi K - th sebagai nombor loncatan n; Kod pemacu; permulaan k", "code": "import java . util . * ; class GFG { static int NthSmallest ( int K ) { Queue < Integer > Q = new LinkedList < > ( ) ; int x = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) Q . add ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q . peek ( ) ; Q . remove ( ) ; if ( x % 10 != 0 ) { Q . add ( x * 10 + x % 10 - 1 ) ; } Q . add ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . add ( x * 10 + x % 10 + 1 ) ; } } return x ; } public static void main ( String [ ] args ) { int N = 16 ; System . out . print ( NthSmallest ( N ) ) ; } }"}
{"text": "Paling kurang nombor yang akan ditambah atau dikurangkan dari n untuk menjadikannya persegi yang sempurna | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan nombor paling sedikit; Dapatkan persegi yang sempurna sebelum dan selepas n; Periksa yang paling dekat dengan n; mengembalikan hasilnya; Kod pemacu", "code": "class GFG { static int nearest ( int n ) { int prevSquare = ( int ) Math . sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; } public static void main ( String [ ] args ) { int n = 14 ; System . out . println ( nearest ( n ) ) ; n = 16 ; System . out . println ( nearest ( n ) ) ; n = 18 ; System . out . println ( nearest ( n ) ) ; } }"}
{"text": "Nilai pi (Î) sehingga 50 tempat perpuluhan | Program Java untuk mengira nilai Pi sehingga tempat perpuluhan; Fungsi yang mencetak nilai tempat perpuluhan Pi; Cari nilai PI sehingga menggunakan fungsi ACOS (); Cetak nilai Pi sehingga tempat perpuluhan; Kod pemacu; Fungsi yang mencetak nilai pi", "code": "class GFG { static void printValueOfPi ( int N ) { double pi = 2 * Math . acos ( 0.0 ) ; System . out . println ( pi ) ; } public static void main ( String [ ] args ) { int N = 4 ; printValueOfPi ( N ) ; } }"}
{"text": "Balikkan kth yang paling penting n | Pelaksanaan Java pendekatan; Berfungsi untuk menukar nombor perpuluhan n ke perwakilan binari yang disimpan sebagai array arr []; Berfungsi untuk menukar nombor yang diwakili sebagai array perduaan [] ke dalam setara perpuluhannya; Berfungsi untuk mengembalikan integer yang dikemas kini selepas membalikkan kth; Bilangan bit dalam n; Cari perwakilan binari n; Bilangan bit dalam N adalah kurang daripada k; Flip bit kth; Mengembalikan setara perpuluhan nombor; Kod pemacu", "code": "class GFG { static void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } static int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } static int getNum ( int n , int k ) { int l = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; int a [ ] = new int [ l ] ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; } public static void main ( String [ ] args ) { int n = 56 ; int k = 2 ; System . out . println ( getNum ( n , k ) ) ; } }"}
{"text": "Pertanyaan untuk produk Factorial N First | Pelaksanaan Java pendekatan; Mengisytiharkan hasil hasil di seluruh dunia; Berfungsi untuk precompute produk faktorial sehingga max; Inisialisasi keadaan asas jika n = 0 maka faktorial 0 adalah sama dengan 1 dan jawapan untuk n = 0 ialah 1; Gelung berulang dari 1 hingga max; faktorial (i) = factorial (i - 1) * i; Keputusan untuk n semasa adalah sama dengan hasil [i - 1] didarabkan oleh faktorial i; Berfungsi untuk melakukan pertanyaan; Precomputing hasil sehingga max; Melakukan pertanyaan; Kod pemacu", "code": "import java . io . * ; class GFG { static int MAX = 1000000 ; static int MOD = 10000007 ; static int [ ] result = new int [ MAX + 1 ] ; static int [ ] fact = new int [ MAX + 1 ] ; static void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } static void performQueries ( int q [ ] , int n ) { preCompute ( ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . println ( result [ q [ i ] ] ) ; } public static void main ( String [ ] args ) { int q [ ] = { 4 , 5 } ; int n = q . length ; performQueries ( q , n ) ; } }"}
{"text": "Nombor nth dalam satu set gandaan a, b atau c | Program Java untuk mencari istilah n divisible oleh a, b atau c; Berfungsi untuk mengembalikan GCD A dan B; Fungsi untuk mengembalikan kiraan bilangan bulat dari julat [1, num] yang boleh dibahagikan dengan sama ada A, B atau C; Kirakan bilangan istilah yang boleh dibahagi dengan A, B dan C kemudian keluarkan istilah yang boleh dibahagikan dengan kedua -dua (a, b) atau (b, c) atau (c, a) dan kemudian tambah nombor yang boleh dibahagikan dengan a, b dan c; Fungsi untuk carian binari untuk mencari istilah n yang boleh dibahagikan dengan a, b atau c; Tetapkan rendah hingga 1 dan tinggi ke long_max; Jika istilah semasa kurang daripada n maka kita perlu meningkat rendah hingga pertengahan + 1; Jika istilah semasa lebih besar daripada sama dengan n maka tinggi = pertengahan; Kod pemacu", "code": "class GFG { static long gcd ( long a , long b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; } static long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; } static long findNthTerm ( int a , int b , int c , long n ) { long low = 1 , high = Long . MAX_VALUE , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) { low = mid + 1 ; } else { high = mid ; } } return low ; } public static void main ( String args [ ] ) { int a = 2 , b = 3 , c = 5 , n = 100 ; System . out . println ( findNthTerm ( a , b , c , n ) ) ; } }"}
{"text": "Sudut antara 3 simpang yang diberikan dalam n | Pelaksanaan Java pendekatan; Fungsi yang memeriksa sama ada sudut yang diberikan boleh dibuat menggunakan mana -mana 3 sisi; Memulakan x dan y; Kirakan bilangan simpang antara i dan j, j dan k; Kirakan sudut yang diselaraskan di lilitan; Sudut yang diselaraskan di J boleh didapati menggunakan hakikat bahawa jumlah sudut segitiga adalah sama dengan 180 darjah; Kod pemacu", "code": "class GFG { static double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; } public static void main ( String [ ] args ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; System . out . println ( ( int ) calculate_angle ( n , a1 , a2 , a3 ) ) ; } }"}
{"text": "Kerugian apabila dua item dijual pada harga yang sama dan keuntungan / kerugian peratusan yang sama | Pelaksanaan Java pendekatan di atas. ; Fungsi yang akan mendapati kerugian; Kod pemacu; Fungsi panggilan", "code": "class GFG { static void Loss ( int SP , int P ) { float loss = 0 ; loss = ( float ) ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . out . println ( \" Loss ▁ = ▁ \" + loss ) ; } public static void main ( String [ ] args ) { int SP = 2400 , P = 30 ; Loss ( SP , P ) ; } }"}
{"text": "Semak elemen array iaitu CO | Pelaksanaan Java pendekatan; Menyimpan faktor utama terkecil untuk setiap nombor; Hash untuk menyimpan kiraan faktor utama; Fungsi untuk mengira SPF (faktor utama terkecil) untuk setiap nombor sehingga maxn; Menandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Memeriksa jika saya adalah perdana; Menandakan SPF untuk semua nombor yang boleh dibahagi oleh i; Menandakan SPF [J] jika ia tidak ditandakan sebelum ini; Berfungsi untuk menyimpan faktor utama selepas membahagikan faktor utama terkecil di setiap langkah; Menyimpan kiraan faktor utama dalam hash; Fungsi yang mengembalikan benar jika tidak ada faktor utama yang sama antara x dan nombor array lain; Memeriksa sama ada faktor utama yang biasa dengan nombor lain; Fungsi yang mengembalikan benar jika terdapat elemen dalam array yang coprime dengan semua elemen lain dari array; Menggunakan ayak untuk menjana faktor utama; Memeriksa faktor utama biasa dengan nombor lain; Kod pemacu", "code": "class GFG { static int MAXN = 1000001 ; static int [ ] spf = new int [ MAXN ] ; static int [ ] hash1 = new int [ MAXN ] ; static void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } static void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } } static boolean check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; } static boolean hasValidNum ( int [ ] arr , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = arr . length ; if ( hasValidNum ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Cara untuk mengeluarkan tepi dari graf lengkap untuk membuat tepi ganjil | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan bilangan cara untuk mengeluarkan tepi dari graf supaya bilangan tepi yang ganjil ditinggalkan dalam graf; Jumlah bilangan tepi; Kod pemacu", "code": "class GfG { static int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . pow ( 2 , E - 1 ) ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( countWays ( N ) ) ; } }"}
{"text": "Hitung NCR Menggunakan Segitiga Pascal | Pelaksanaan Java pendekatan; Memulakan matriks dengan 0; 0 C0 = 1; Tetapkan setiap NCR = 1 di mana r = 0; Nilai untuk sel semasa segitiga Pascal; Berfungsi untuk mengembalikan nilai NCR; Kembali NCR; Kod pemacu; Bina Segitiga Pascal", "code": "class GFG { static int l [ ] [ ] = new int [ 1001 ] [ 1001 ] ; static void initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } } static int nCr ( int n , int r ) { return l [ n ] [ r ] ; } public static void main ( String [ ] args ) { initialize ( ) ; int n = 8 ; int r = 3 ; System . out . println ( nCr ( n , r ) ) ; } }"}
{"text": "Partition Jumlah Paling Berdekatan (ke dalam dua subset) nombor dari 1 hingga N | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan perbezaan mutlak yang diperlukan minimum; Kod pemacu", "code": "class GFG { static int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( minAbsDiff ( n ) ) ; } }"}
{"text": "Semak sama ada xor kekerapan semua digit nombor n adalah sifar atau tidak | Pelaksanaan Java pendekatan di atas; mewujudkan pelbagai frekuensi; Mencari digit terakhir nombor; Membahagikan nombor dengan 10 untuk menghapuskan digit terakhir; kekerapan mengira setiap digit; Memeriksa jika XOR semua kekerapan adalah sifar atau tidak; Fungsi pemacu", "code": "class GFG { static boolean check ( int s ) { int [ ] freq = new int [ 10 ] ; int r , i ; for ( i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } while ( s != 0 ) { r = s % 10 ; s = ( int ) ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } return true ; } public static void main ( String [ ] args ) { int s = 122233 ; if ( check ( s ) ) System . out . println ( \"YesNEW_LINE\"); else System . out . println ( \"NoNEW_LINE\"); } }"}
{"text": "Cetak garis n 4 nombor supaya setiap pasangan di antara 4 nombor mempunyai gcd k | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mencetak garis N; Iterat n kali untuk mencetak garis n; Kod pemacu", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( k * ( 6 * i + 1 ) + \" ▁ \" + k * ( 6 * i + 2 ) + \" ▁ \" + k * ( 6 * i + 3 ) + \" ▁ \" + k * ( 6 * i + 5 ) ) ; } } public static void main ( String args [ ] ) { int n = 2 , k = 2 ; printLines ( n , k ) ; } }"}
{"text": "Jumlah pertama N Siri 3, 5, 9, 17, 33 ... | Program Java untuk mencari jumlah terma pertama N; Sn = n * (4 * n * n + 6 * n - 1) / 3; Kod pemacu; bilangan terma yang akan dimasukkan dalam jumlah; Cari SN", "code": "import java . util . * ; class GFG { static int calculateSum ( int n ) { return ( ( int ) Math . pow ( 2 , n + 1 ) + n - 2 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( \" Sum ▁ = ▁ \" + calculateSum ( n ) ) ; } }"}
{"text": "Kira bilangan rentetan khas panjang n | Program Java untuk mengira bilangan rentetan khas panjang n; Berfungsi untuk mengembalikan kiraan rentetan khas; Menyimpan jawapan untuk nilai tertentu n; Untuk n = 0 kita mempunyai rentetan kosong; Untuk n = 1 kita mempunyai 2 rentetan khas; Hitung kiraan rentetan panjang panjang i; Fib [n] menyimpan kiraan rentetan khas panjang n; Kod pemacu; Permulaan n", "code": "import java . util . * ; class GFG { static final int mod = 1000000007 ; static int count_special ( int n ) { int [ ] fib = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( count_special ( n ) + \"NEW_LINE\"); } }"}
{"text": "Mengira laluan dalam array | Pelaksanaan Java pendekatan di atas; Cari bilangan cara untuk mencapai akhir; Kes asas; Struktur rekursif; Kod pemacu", "code": "import java . io . * ; class GFG { static int mod = 1000000000 ; static int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . length ; System . out . println ( ways ( 0 , arr , n ) ) ; } }"}
{"text": "Mengira laluan dalam array | Pelaksanaan Java pendekatan di atas; Cari bilangan cara untuk mencapai akhir; DP untuk menyimpan nilai; Kes asas; Bawah struktur DP; F [i] bergantung kepada F [i + 1] ke F [i + k]; Nilai pulangan DP [0]; Kod pemacu", "code": "class GFG { static final int mod = ( int ) ( 1e9 + 7 ) ; static int ways ( int arr [ ] , int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . length ; System . out . println ( ways ( arr , n ) % mod ) ; } }"}
{"text": "Bilangan berikutnya dengan jumlah yang lebih baik dan ganjil | Program Java untuk mendapatkan kos minimum untuk menyusun rentetan dengan operasi pembalikan; Mengembalikan kiraan ganjil dan bahkan seterusnya; Pembolehubah untuk menyimpan kiraan bahkan seterusnya dan berikutnya yang ganjil; Inisialisasi count_even dan count_odd hingga 0 kerana kerana tidak ada berikutnya sebelum lelaran dengan kiraan yang lebih baik atau ganjil. ; Cari jumlah semua berikutnya dengan mengira dan mengira ganjil dan menyimpannya semasa kami melangkah. ; jika nombor itu juga; Jika nombor itu ganjil; Kod pemacu; Memanggil fungsi", "code": "class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static pair countSum ( int arr [ ] , int n ) { int result = 0 ; int count_odd , count_even ; count_odd = 0 ; count_even = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { count_even = count_even + count_even + 1 ; count_odd = count_odd + count_odd ; } else { int temp = count_even ; count_even = count_even + count_odd ; count_odd = count_odd + temp + 1 ; } } return new pair ( count_even , count_odd ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ; pair ans = countSum ( arr , n ) ; System . out . print ( \" EvenSum ▁ = ▁ \" + ans . first ) ; System . out . print ( \" ▁ OddSum ▁ = ▁ \" + ans . second ) ; } }"}
{"text": "Count integer panjang n dan nilai kurang daripada k sehingga ia mengandungi digit hanya dari set yang diberikan | Pelaksanaan Java pendekatan; Berfungsi untuk menukar nombor menjadi vektor; Tolak semua digit n dari akhir satu demi satu ke vektor; Jika nombor asalnya adalah 0; Membalikkan elemen vektor; Mengembalikan vektor yang diperlukan; Berfungsi untuk mengembalikan bilangan bilangan bulat panjang b yang kurang daripada c dan mereka mengandungi digit dari set a [] sahaja; Menukar nombor ke array digit; Kes 1: Tidak ada bilangan sedemikian mungkin kerana nombor yang dihasilkan akan selalu lebih besar daripada C; Kes 2: Semua bilangan bulat panjang B adalah sah kerana mereka semua kurang daripada C; mengandungi 0; Kes 3; Kemas kini array yang lebih rendah [seperti yang lebih rendah [i] menyimpan kiraan unsur -unsur dalam [] yang kurang daripada saya; Untuk indeks pertama kita tidak boleh menggunakan 0; Sama ada (i - 1) digit nombor yang dihasilkan boleh sama dengan (i - 1) digit C; Adakah digit [i - 1] hadir dalam A? ; Kod pemacu", "code": "import java . util . * ; class GFG { static int MAX = 10 ; static Vector < Integer > numToVec ( int N ) { Vector < Integer > digit = new Vector < Integer > ( ) ; while ( N != 0 ) { digit . add ( N % 10 ) ; N = N / 10 ; } if ( digit . size ( ) == 0 ) digit . add ( 0 ) ; Collections . reverse ( digit ) ; return digit ; } static int solve ( Vector < Integer > A , int B , int C ) { Vector < Integer > digit = new Vector < Integer > ( ) ; int d , d2 ; digit = numToVec ( C ) ; d = A . size ( ) ; if ( B > digit . size ( ) d == 0 ) return 0 ; else if ( B < digit . size ( ) ) { if ( A . get ( 0 ) == 0 && B != 1 ) return ( int ) ( ( d - 1 ) * Math . pow ( d , B - 1 ) ) ; else return ( int ) Math . pow ( d , B ) ; } else { int [ ] dp = new int [ B + 1 ] ; int [ ] lower = new int [ MAX + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) lower [ A . get ( i ) + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; boolean flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit . get ( i - 1 ) ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A . get ( 0 ) == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit . get ( i - 1 ) + 1 ] == lower [ digit . get ( i - 1 ) ] + 1 ) ) ; } return dp [ B ] ; } } public static void main ( String [ ] args ) { Integer arr [ ] = { 0 , 1 , 2 , 5 } ; Vector < Integer > A = new Vector < > ( Arrays . asList ( arr ) ) ; int N = 2 ; int k = 21 ; System . out . println ( solve ( A , N , k ) ) ; } }"}
{"text": "Bilangan jalur berat w dalam k | Program Java untuk mengira bilangan laluan dengan berat w dalam pokok k - ary; Berfungsi untuk mengembalikan bilangan cara yang mempunyai berat badan sebagai wt dalam pokok k - ary; Kembali 0 jika berat menjadi kurang daripada sifar; Kembali hanya jika laluan semasa telah memasukkan berat kelebihan mehaum m; Jika berat tepi semasa lebih besar daripada atau sama dengan m, set digunakan sebagai benar; Kod pemacu", "code": "class GFG { public static int solve ( int [ ] [ ] dp , int wt , int K , int M , int used ) { if ( wt < 0 ) { return 0 ; } if ( wt == 0 ) { if ( used == 1 ) { return 1 ; } return 0 ; } if ( dp [ wt ] [ used ] != - 1 ) { return dp [ wt ] [ used ] ; } int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) { ans += solve ( dp , wt - i , K , M , used 1 ) ; } else { ans += solve ( dp , wt - i , K , M , used ) ; } } return dp [ wt ] [ used ] = ans ; } public static void main ( String [ ] args ) { int W = 3 , K = 3 , M = 2 ; int [ ] [ ] dp = new int [ W + 1 ] [ 2 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . print ( solve ( dp , W , K , M , 0 ) + \"NEW_LINE\"); } }"}
{"text": "Cara Menulis N sebagai Jumlah Dua atau Lebih Integer Positif | Set | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mencari bilangan partition n; Kes asas; Kod pemacu", "code": "class GFG { static long partitions ( int n ) { long p [ ] = new long [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; } public static void main ( String [ ] args ) { int N = 20 ; System . out . println ( partitions ( N ) ) ; } }"}
{"text": "Laluan Terpanjang dalam Matriks | Program Java untuk mencari jalan yang paling lama dalam matriks. ; Kembalikan panjang bibir dalam matriks 2D; Jika nilai belum dikira. ; Jika mencapai sel kiri bawah, kembali 1 .; Jika sampai ke sudut matriks. ; Jika nilai lebih besar daripada sel bawah. ; Jika nilai lebih besar daripada sel kiri. ; Fungsi pembalut; Program pemacu untuk menguji fungsi di atas", "code": "import java . util . * ; class GFG { static int LIP ( int dp [ ] [ ] , int mat [ ] [ ] , int n , int m , int x , int y ) { if ( dp [ x ] [ y ] < 0 ) { int result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( x + 1 < n && mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( y + 1 < m && mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = Math . max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; } static int wrapper ( int mat [ ] [ ] , int n , int m ) { int dp [ ] [ ] = new int [ 10 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) Arrays . fill ( dp [ i ] , - 1 ) ; return LIP ( dp , mat , n , m , 0 , 0 ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 2 , 2 , 3 , 4 } , { 3 , 2 , 3 , 4 } , { 4 , 5 , 6 , 7 } , } ; int n = 4 , m = 4 ; System . out . println ( wrapper ( mat , n , m ) ) ; } }"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Program Java untuk mengira jumlah laluan dari titik ke asal; Fungsi rekursif untuk mengira bilangan laluan; Jika kita mencapai bahagian bawah atau kiri atas, kita hanya mempunyai satu cara untuk mencapai (0, 0); Lain mengira jumlah kedua -dua cara; Kod pemacu", "code": "import java . io . * ; class GFG { static int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( \" ▁ Number ▁ of ▁ Paths ▁ \" + countPaths ( n , m ) ) ; } }"}
{"text": "Masalah Tambang Emas | Program Java untuk menyelesaikan masalah lombong emas; Mengembalikan jumlah maksimum emas yang boleh dikumpulkan apabila perjalanan bermula dari lajur pertama dan bergerak yang dibenarkan adalah betul, kanan dan kanan - ke bawah; Buat jadual untuk menyimpan hasil pertengahan dan memulakan semua sel ke 0. Baris pertama Goldminetable memberikan emas maksimum yang dapat dikumpulkan oleh pelombong ketika memulakan baris itu; Emas yang dikumpulkan pergi ke sel di sebelah kanan ( ->); Emas yang dikumpulkan untuk pergi ke sel untuk ke atas ( /); Emas yang dikumpulkan untuk pergi ke sel ke kanan (\\); Max Gold yang dikumpulkan daripada mengambil salah satu daripada 3 laluan di atas; Jumlah maksimum emas yang dikumpulkan akan menjadi nilai maksimum dalam lajur pertama semua baris; kod pemacu", "code": "import java . util . Arrays ; class GFG { static final int MAX = 100 ; static int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; } public static void main ( String arg [ ] ) { int gold [ ] [ ] = { { 1 , 3 , 1 , 5 } , { 2 , 2 , 4 , 1 } , { 5 , 0 , 2 , 3 } , { 0 , 6 , 1 , 2 } } ; int m = 4 , n = 4 ; System . out . print ( getMaxGold ( gold , m , n ) ) ; } }"}
{"text": "Cari Kos Pelarasan Minimum Array | Program Java untuk mencari kos pelarasan minimum array; Fungsi untuk mencari kos pelarasan minimum array; dp [i] [j] menyimpan kos pelarasan minimum untuk menukar [i] ke j; mengendalikan elemen pertama array secara berasingan; lakukan untuk elemen rehat array; Gantikan [i] ke J dan hitung kos pelarasan minimum DP [i] [j]; memulakan kos pelarasan minimum kepada int_max; Pertimbangkan semua k sedemikian rupa sehingga k> = max (j - sasaran, 0) dan k <= min (m, j + sasaran) dan ambil minimum; pulangan nilai minimum dari baris terakhir jadual DP; Program Pemandu", "code": "import java . io . * ; import java . util . * ; class GFG { public static int M = 100 ; static int minAdjustmentCost ( int A [ ] , int n , int target ) { int [ ] [ ] dp = new int [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; int k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 } ; int n = arr . length ; int target = 10 ; System . out . println ( \" Minimum ▁ adjustment ▁ cost ▁ is ▁ \" + minAdjustmentCost ( arr , n , target ) ) ; } }"}
{"text": "Kira tiga kali ganda dari julat tertentu yang mempunyai jumlah dua nombor triplet yang sama dengan nombor ketiga | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan tiga kali ganda dari julat [l, r] yang mempunyai jumlah dua nombor dari triplet yang sama dengan nombor ketiga; Menyimpan jumlah tiga tiga; Cari perbezaan julat; Kes 1: Jika tiga kali boleh dibentuk, maka kembali 0; Jika tidak; Mengemas kini jumlah tiga kali ganda; Mengembalikan kiraan; Kod yang didorong", "code": "import java . util . * ; class GFG { static int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; } public static void main ( String [ ] args ) { int L = 2 , R = 6 ; System . out . print ( totalCombination ( L , R ) ) ; } }"}
{"text": "Bina Dua N | Program Java untuk pendekatan di atas; Memenuhi syarat yang diberikan; Mengisytiharkan kedua -dua array A dan B; Berulang dari julat [1, 2 * n]; Berikan nombor berturut -turut kepada indeks yang sama dari kedua -dua tatasusunan; Cetak array pertama; Cetak array kedua, b; Kod pemacu; Panggilan fungsi", "code": "import java . io . * ; import java . util . * ; class GFG { static void printArrays ( int n ) { ArrayList < Integer > A = new ArrayList < Integer > ( ) ; ArrayList < Integer > B = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) A . add ( i ) ; else B . add ( i ) ; } System . out . print ( \" { ▁ \" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( A . get ( i ) ) ; if ( i != n - 1 ) System . out . print ( \" , ▁ \" ) ; } System . out . print ( \" }NEW_LINE\"); System . out . print ( \" { ▁ \" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( B . get ( i ) ) ; if ( i != n - 1 ) System . out . print ( \" , ▁ \" ) ; } System . out . print ( \" ▁ } \" ) ; } public static void main ( String [ ] args ) { int N = 5 ; printArrays ( N ) ; } }"}
{"text": "Nombor yang dibentuk dengan membalikkan bit set biasa dalam dua bilangan bulat yang diberikan | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk membalikkan bit a dan b yang ditetapkan bit dalam a dan b; Iterater semua bit mungkin a dan b; Jika ia bit ditetapkan dalam kedua -dua A dan B; Jelas i - th bit a; Jelas i - th bit b; Cetak A dan B; Kod pemacu", "code": "import java . util . * ; class GFG { static void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } System . out . print ( A + \" ▁ \" + B ) ; } public static void main ( String [ ] args ) { int A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ; } }"}
{"text": "Kira jumlah pasangan yang berbeza antara dua array nilai 1 hingga n | Pelaksanaan Java untuk mencari kiraan jumlah pasangan yang berbeza antara dua array nilai 1 hingga n; Berfungsi untuk mencari jumlah yang berbeza; Kod pemacu", "code": "import java . util . * ; class GFG { static int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( findDistinctSums ( N ) ) ; } }"}
{"text": "Count Substrings Dari Diberi String Ternary yang Mengandungi Karakter Sekurang -kurangnya sekali | Program Java untuk pendekatan di atas; Fungsi untuk mengira bilangan substrings terdiri daripada 0, 1, dan 2; Memulakan pelbagai frekuensi saiz 3; Menyimpan kiraan yang dihasilkan; Traversing string str; Arahan kekerapan kemas kini; Jika semua watak hadir mengira bilangan substrings mungkin; Kemas kini bilangan substring; Mengembalikan bilangan substring; Kod pemacu", "code": "import java . util . * ; class GFG { public static int countSubstrings ( String str ) { int [ ] freq = new int [ 3 ] ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { freq [ str . charAt ( j ) - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str . charAt ( i ++ ) - '0' ] -- ; } count += i ; } return count ; } public static void main ( String [ ] args ) { String str = \"00021\" ; System . out . println ( countSubstrings ( str ) ) ; } }"}
{"text": "FLIPS MINIMUM UNTUK MENGURANGKAN SEBARANG TERBUKA 3 0 S atau 1 S DALAM RENCEN BINARY YANG DIPERLUKAN | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum flip untuk membuat ketiga -tiga pasang aksara berturut -turut berbeza; Kedai -kedai yang dihasilkan pasangan pasangan; Kes asas; Melangkah ke atas julat [0, n - 2]; Jika nombor 3 berturut -turut adalah sama maka kenaikan kiraan dan kaunter; Kembalikan jawapannya; Kod pemacu", "code": "import java . io . * ; class GFG { static int minFlips ( String str ) { int count = 0 ; if ( str . length ( ) <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . length ( ) - 2 { if ( str . charAt ( i ) == str . charAt ( i + 1 ) && str . charAt ( i + 2 ) == str . charAt ( i + 1 ) ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } public static void main ( String [ ] args ) { String S = \"0011101\" ; System . out . println ( minFlips ( S ) ) ; } }"}
{"text": "Menyulitkan rentetan | Program Java untuk pendekatan di atas; Berfungsi untuk menukar perpuluhan ke hex; Berfungsi untuk menyulitkan rentetan; Melepasi watak -watak rentetan; Iterat sehingga S [i] sama dengan CH; Kemas kini kiraan dan saya; Penurunan I oleh 1; Menukar kiraan kepada perwakilan heksadesimal; Tambah watak; Tambah kekerapan aksara dalam perwakilan heksadesimal; Membalikkan jawapan yang diperoleh; Mengembalikan jawapan yang diperlukan; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "import java . awt . * ; import java . util . * ; class GFG { static String convertToHex ( int num ) { StringBuilder temp = new StringBuilder ( ) ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = ( char ) ( rem + 48 ) ; } else { c = ( char ) ( rem + 87 ) ; } temp . append ( c ) ; num = num / 16 ; } return temp . toString ( ) ; } static String encryptString ( String S , int N ) { StringBuilder ans = new StringBuilder ( ) ; for ( int i = 0 ; i < N ; i ++ ) { char ch = S . charAt ( i ) ; int count = 0 ; String hex ; while ( i < N && S . charAt ( i ) == ch ) { count ++ ; i ++ ; } i -- ; hex = convertToHex ( count ) ; ans . append ( ch ) ; ans . append ( hex ) ; } ans . reverse ( ) ; return ans . toString ( ) ; } public static void main ( String [ ] args ) { String S = \" abc \" ; int N = S . length ( ) ; System . out . println ( encryptString ( S , N ) ) ; } }"}
{"text": "Kiraan rentetan binari panjang n sedemikian rupa sehingga kekerapan 1 s ~ melebihi »frekuensi ~» s | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan nilai pekali binomial C (n, k); Kerana c (n, k) = c (n, n - k); Kirakan nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Berfungsi untuk mengembalikan kiraan rentetan binari panjang n sedemikian rupa sehingga kekerapan 1 's »s; Kiraan rentetan binari panjang n; Kiraan rentetan binari panjang n yang mempunyai kiraan yang sama dengan 0 dan 1 's; Untuk rentetan panjang; Kod pemacu", "code": "import java . util . * ; class GFG { static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static int countOfString ( int N ) { int Stotal = ( int ) Math . pow ( 2 , N ) ; int Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N / 2 ) ; int S1 = ( Stotal - Sequal ) / 2 ; return S1 ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( countOfString ( N ) ) ; } }"}
{"text": "Keluarkan semua kejadian watak dalam rentetan | Pendekatan Rekursif | Program Java untuk pendekatan di atas; Berfungsi untuk menghapuskan semua kejadian watak dalam rentetan; Kes asas; Semak watak pertama rentetan yang diberikan; Lulus sisa rentetan ke panggilan fungsi rekursi; Tambah watak pertama STR dan String dari rekursi; Kod pemacu; Diberikan rentetan; Diberikan watak; Panggilan fungsi", "code": "class GFG { static String removeCharRecursive ( String str , char X ) { if ( str . length ( ) == 0 ) { return \" \" ; } if ( str . charAt ( 0 ) == X ) { return removeCharRecursive ( str . substring ( 1 ) , X ) ; } return str . charAt ( 0 ) + removeCharRecursive ( str . substring ( 1 ) , X ) ; } public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; char X = ' e ' ; str = removeCharRecursive ( str , X ) ; System . out . println ( str ) ; } }"}
{"text": "Masa maksimum seperti perbezaan mutlak antara jam dan minit terletak pada julat yang diberikan | Program Java untuk pendekatan di atas; Pemeriksaan fungsi sama ada masa yang diberikan adalah betul; Untuk memeriksa nilai masa; Untuk memeriksa nilai jam masa; Perubahan nilai tidak dibenarkan di kedudukan di mana '? 'tidak hadir; Fungsi memeriksa sama ada perbezaan mutlak antara jam dan nilai minit berada dalam [l, r]; Cek jika perbezaan di luar julat memberi; Memaparkan masa dalam format 24 jam yang betul; Fungsi Cari nilai masa yang dikehendaki yang perbezaannya terletak dalam julat [l, r]; Menurunkan nilai jam dari 23 hingga 0; Semak jika nilai jam sah jika tidak sah maka tidak perlu menukar nilai minit, kerana masa masih akan sah, untuk memeriksa bendera nilai jam ditetapkan kepada 1 .; Mengurangkan nilai minit dari 59 hingga 0; Semak sama ada nilai minit sah, jika tidak sah kemudian langkau lelaran semasa, untuk memeriksa bendera nilai 'minit' ditetapkan kepada 0 .; Kod pemacu; Masa input; Julat Perbezaan", "code": "import java . util . * ; class GFG { static boolean isValid ( char a1 , char a2 , String str , int flag ) { char v1 , v2 ; if ( flag == 0 ) { v1 = str . charAt ( 4 ) ; v2 = str . charAt ( 3 ) ; } else { v1 = str . charAt ( 1 ) ; v2 = str . charAt ( 0 ) ; } if ( v1 != a1 && v1 != ' ? ' ) return false ; if ( v2 != a2 && v2 != ' ? ' ) return false ; return true ; } static boolean inRange ( int hh , int mm , int L , int R ) { int a = Math . abs ( hh - mm ) ; if ( a < L a > R ) return false ; return true ; } static void displayTime ( int hh , int mm ) { if ( hh > 10 ) System . out . print ( hh + \" : \" ) ; else if ( hh < 10 ) System . out . print ( \"0\" + hh + \" : \" ) ; if ( mm > 10 ) System . out . println ( mm ) ; else if ( mm < 10 ) System . out . println ( \"0\" + mm ) ; } static void maximumTimeWithDifferenceInRange ( String str , int L , int R ) { int i = 0 , j = 0 ; int h1 , h2 , m1 , m2 ; for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = i / 10 ; if ( ! isValid ( ( char ) h1 , ( char ) h2 , str , 1 ) ) { continue ; } for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = j / 10 ; if ( ! isValid ( ( char ) m1 , ( char ) m2 , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) displayTime ( i , j ) ; else System . out . println ( \" - 1\" ) ; } public static void main ( String [ ] args ) { String timeValue = \" ? ? : ? ? \" ; int L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ; } }"}
{"text": "Semak jika rentetan boleh dibahagikan kepada substrings Palindromic panjang walaupun | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa string str boleh memecah rentetan ke dalam substrings palindromik panjang; Memulakan timbunan; Melelehkan rentetan; Jika watak I - tH adalah sama seperti di bahagian atas timbunan kemudian pop elemen atas; Lain -lain menolak watak semasa ke dalam timbunan; Sekiranya timbunan kosong, maka substrings palindromik mungkin; Lain tidak - mungkin; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "import java . util . * ; class GFG { static boolean check ( String s , int n ) { Stack < Character > st = new Stack < Character > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! st . isEmpty ( ) && st . peek ( ) == s . charAt ( i ) ) st . pop ( ) ; else st . add ( s . charAt ( i ) ) ; } if ( st . isEmpty ( ) ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { String str = \" aanncddc \" ; int n = str . length ( ) ; if ( check ( str , n ) ) { System . out . print ( \" Yes \" + \"NEW_LINE\"); } else { System . out . print ( \" No \" + \"NEW_LINE\"); } } }"}
{"text": "Bilangan rentetan dalam dua array memenuhi syarat -syarat yang diberikan | Program Java untuk pendekatan di atas; Untuk menyimpan kekerapan rentetan selepas bitmasking; Untuk menyimpan hasil untuk setiap rentetan dalam ARR2 []; Melintasi arr1 [] dan bitmask setiap rentetan di dalamnya; Bitmasking untuk setiap rentetan s; Kemas kini kekerapan rentetan dengan nilai bitmasking; Melintasi arr2 []; Bitmasking untuk setiap rentetan s; Periksa sama ada temp ada dalam unstered_map atau tidak; Semak bit set seterusnya; Tolak kiraan untuk rentetan semasa dalam array yang dihasilkan; Cetak kiraan untuk setiap rentetan; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void findNumOfValidWords ( Vector < String > w , Vector < String > p ) { HashMap < Integer , Integer > m = new HashMap < > ( ) ; Vector < Integer > res = new Vector < > ( ) ; for ( String s : w ) { int val = 0 ; for ( char c : s . toCharArray ( ) ) { val = val | ( 1 << ( c - ' a ' ) ) ; } if ( m . containsKey ( val ) ) m . put ( val , m . get ( val ) + 1 ) ; else m . put ( val , 1 ) ; } for ( String s : p ) { int val = 0 ; for ( char c : s . toCharArray ( ) ) { val = val | ( 1 << ( c - ' a ' ) ) ; } int temp = val ; int first = s . charAt ( 0 ) - ' a ' ; int count = 0 ; while ( temp != 0 ) { if ( ( ( temp >> first ) & 1 ) == 1 ) { if ( m . containsKey ( temp ) ) { count += m . get ( temp ) ; } } temp = ( temp - 1 ) & val ; } res . add ( count ) ; } for ( int it : res ) { System . out . println ( it ) ; } } public static void main ( String [ ] args ) { Vector < String > arr1 = new Vector < > ( ) ; arr1 . add ( \" aaaa \" ) ; arr1 . add ( \" asas \" ) ; arr1 . add ( \" able \" ) ; arr1 . add ( \" ability \" ) ; arr1 . add ( \" actt \" ) ; arr1 . add ( \" actor \" ) ; arr1 . add ( \" access \" ) ; Vector < String > arr2 = new Vector < > ( ) ; arr2 . add ( \" aboveyz \" ) ; arr2 . add ( \" abrodyz \" ) ; arr2 . add ( \" absolute \" ) ; arr2 . add ( \" absoryz \" ) ; arr2 . add ( \" actresz \" ) ; arr2 . add ( \" gaswxyz \" ) ; findNumOfValidWords ( arr1 , arr2 ) ; } }"}
{"text": "Memaksimumkan setara perpuluhan dengan membalikkan hanya satu set bersebelahan 0 S | Pelaksanaan Java untuk memaksimumkan nilai setara perpuluhan yang diberikan dalam bentuk binari; Berfungsi untuk mencetak nombor binari; Semak sama ada nombor semasa ialah 0; Cari 0 s berterusan; Gantikan pada mulanya berlaku 0 dengan 1; Keluar dari gelung jika 1 berlaku; Kod pemacu", "code": "import java . util . * ; class GFG { static void flip ( String s ) { StringBuilder sb = new StringBuilder ( s ) ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { if ( sb . charAt ( i ) == '0' ) { while ( sb . charAt ( i ) == '0' ) { sb . setCharAt ( i , '1' ) ; i ++ ; } break ; } } System . out . println ( sb . toString ( ) ) ; } public static void main ( String [ ] args ) { String s = \"100010001\" ; flip ( s ) ; } }"}
{"text": "Kes Kalimat Rentetan Camel yang Diberikan | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan rentetan asal selepas menukarnya dari unta; Cetak watak pertama seperti itu; Melintasi seluruh watak satu demi satu; Jika watak semasa adalah ruang cetak huruf besar diikuti oleh watak semasa dalam huruf kecil; Lain mencetak watak semasa; Kod pemacu", "code": "class GFG { static void getOrgString ( String s ) { System . out . print ( s . charAt ( 0 ) ) ; int i = 1 ; while ( i < s . length ( ) ) { if ( s . charAt ( i ) >= ' A ' && s . charAt ( i ) <= ' Z ' ) System . out . print ( \" ▁ \" + Character . toLowerCase ( s . charAt ( i ) ) ) ; else System . out . print ( s . charAt ( i ) ) ; i ++ ; } } public static void main ( String [ ] args ) { String s = \" ILoveGeeksForGeeks \" ; getOrgString ( s ) ; } }"}
{"text": "Kira kejadian watak dalam rentetan berulang | Program Java untuk mencari kejadian aksara x dalam rentetan berulang tak terhingga sehingga panjang n; Berfungsi untuk mengira watak 'A'; Atleast k pengulangan diperlukan; Jika n bukanlah pelbagai pemeriksaan saiz rentetan untuk watak berulang yang tersisa. ; Kod pemacu", "code": "import java . util . * ; import java . lang . * ; class GFG { static int countChar ( String str , char x ) { int count = 0 ; int n = 10 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) count ++ ; int repetitions = n / str . length ( ) ; count = count * repetitions ; for ( int i = 0 ; i < n % str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == x ) count ++ ; } return count ; } public static void main ( String args [ ] ) { String str = \" abcac \" ; System . out . println ( countChar ( str , ' a ' ) ) ; } }"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program Java untuk mengira frekuensi item array yang mempunyai nilai kecil. ; Buat array untuk menyimpan tuduhan. Saiz array adalah had + 1 dan semua nilai pada mulanya 0; Melintasi unsur -unsur array dan kekerapan kiraan (dengan mengandaikan bahawa unsur -unsur dibatasi oleh had); Kod pemacu", "code": "class GFG { static void countFreq ( int arr [ ] , int n , int limit ) { int [ ] count = new int [ limit + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) System . out . println ( i + \" ▁ \" + count [ i ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 } ; int n = arr . length ; int limit = 10 ; countFreq ( arr , n , limit ) ; } }"}
{"text": "Semak jika rentetan mempunyai m berturut -turut 1 's atau ~ 0' s | Program untuk memeriksa sama ada rentetan binari mengandungi m berturut -turut 1 's atau' s; Fungsi yang memeriksa jika rentetan binari mengandungi m berturut -turut 1 's atau' s; panjang rentetan binari; Count Zeros; Count 1 's; Count berturut -turut 0 's; Count berturut -turut 1 's; Kod pemacu; panggilan fungsi", "code": "import java . io . * ; class GFG { static boolean check ( String s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; } public static void main ( String [ ] args ) { String s = \"001001\" ; int m = 2 ; if ( check ( s , m ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text": "Produk nod di k | Pelaksanaan Java untuk mencari produk digit unsur -unsur di peringkat k - th; Berfungsi untuk mencari produk digit elemen di peringkat k - th; Memulakan hasil; peningkatan bilangan tahap; mengurangkan nombor tahap; Periksa sama ada tahap semasa adalah tahap yang dikehendaki atau tidak; produk yang diperlukan; Program Pemandu", "code": "class GFG { static int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == ' ( ' ) level ++ ; else if ( tree . charAt ( i ) == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } } return product ; } public static void main ( String [ ] args ) { String tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; int k = 2 ; System . out . println ( productAtKthLevel ( tree , k ) ) ; } }"}
{"text": "Mengeluarkan baris atau lajur bijak pendua dari matriks aksara | Kod Java untuk membentuk rentetan selepas mengeluarkan pendua dari baris dan lajur. ; Berfungsi untuk memeriksa pendua dalam baris dan lajur; Buat array ispresent dan mulakan semua penyertaannya sebagai palsu. Nilai ispresent [i, j] akan benar jika S [i, j] hadir dalam baris atau lajurnya. ; Memeriksa setiap baris untuk pendua [i, j]; Memeriksa setiap lajur untuk aksara pendua; Jika watak itu unik dalam baris dan lajurnya; Kod pemacu; pelbagai watak; Fungsi panggilan", "code": "class GFG { static void findDuplciates ( String [ ] a , int n , int m ) { boolean [ ] [ ] isPresent = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { isPresent [ i ] [ j ] = false ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( a [ i ] . charAt ( j ) == a [ k ] . charAt ( j ) && i != k ) { isPresent [ i ] [ j ] = true ; isPresent [ k ] [ j ] = true ; } } for ( int k = 0 ; k < m ; k ++ ) { if ( a [ i ] . charAt ( j ) == a [ i ] . charAt ( k ) && j != k ) { isPresent [ i ] [ j ] = true ; isPresent [ i ] [ k ] = true ; } } } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( isPresent [ i ] [ j ] == false ) System . out . print ( a [ i ] . charAt ( j ) ) ; } public static void main ( String [ ] args ) { int n = 2 , m = 2 ; String [ ] a = new String [ ] { \" zx \" , \" xz \" } ; findDuplciates ( a , n , m ) ; } }"}
{"text": "Program untuk memeriksa ISBN | Program Java untuk memeriksa sama ada ISBN yang diberikan atau tidak; panjang mestilah 10; Pengkomputeran berjumlah 9 digit pertama; Memeriksa digit terakhir. ; Jika digit terakhir adalah 'X', tambahkan 10 hingga Jumlah, tambah nilainya; Kembali benar jika jumlah digit berwajaran boleh dibahagikan dengan 11 .; Kod pemacu", "code": "class GFG { static boolean isValidISBN ( String isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn . charAt ( i ) - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn . charAt ( 9 ) ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; } public static void main ( String [ ] args ) { String isbn = \"007462542X \" ; if ( isValidISBN ( isbn ) ) System . out . print ( \" Valid \" ) ; else System . out . print ( \" Invalid \" ) ; } }"}
{"text": "Vokal terbalik dalam rentetan yang diberikan | Program Java untuk membalikkan urutan vokal; fungsi utiliti untuk memeriksa vokal; Berfungsi untuk membalikkan urutan vokal; Menyimpan vokal secara berasingan; Meletakkan vokal dalam urutan terbalik dalam rentetan; Fungsi pemacu", "code": "class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; } static String reverseVowel ( String str1 ) { int j = 0 ; char [ ] str = str1 . toCharArray ( ) ; String vowel = \" \" ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { j ++ ; vowel += str [ i ] ; } } for ( int i = 0 ; i < str . length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { str [ i ] = vowel . charAt ( -- j ) ; } } return String . valueOf ( str ) ; } public static void main ( String [ ] args ) { String str = \" hello ▁ world \" ; System . out . println ( reverseVowel ( str ) ) ; } }"}
{"text": "String yang mengandungi huruf pertama setiap perkataan dalam rentetan yang diberikan dengan ruang | Program Java untuk mencari rentetan yang mengandungi watak pertama setiap perkataan rentetan lain. ; Fungsi untuk mencari rentetan yang mempunyai watak pertama setiap perkataan. ; Melintasi rentetan. ; Jika ia adalah ruang, tetapkan V sebagai benar. ; Lain semak jika v adalah benar atau tidak. Jika benar, salin watak dalam rentetan output dan tetapkan V sebagai palsu. ; Kod pemacu", "code": "class GFG { static String firstLetterWord ( String str ) { String result = \" \" ; boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) { v = true ; } else if ( str . charAt ( i ) != ' ▁ ' && v == true ) { result += ( str . charAt ( i ) ) ; v = false ; } } return result ; } public static void main ( String [ ] args ) { String str = \" geeks ▁ for ▁ geeks \" ; System . out . println ( firstLetterWord ( str ) ) ; } }"}
{"text": "Laluan unik yang meliputi setiap bukan | Pelaksanaan Java pendekatan; Fungsi untuk DFS. i, j ==> indeks sel semasa vis ==> untuk menandakan sel -sel yang dikunjungi ans ==> hasil z ==> kiraan semasa 0 s yang dikunjungi z_count ==> total 0 s hadir; Tandakan blok seperti yang dikunjungi; mengemas kini kiraan; Jika blok akhir dicapai; Jika jalan meliputi semua blok bukan halangan; Naik; Ke bawah; Kiri; Betul; Unmark blok (Unvisited); Berfungsi untuk mengembalikan kiraan laluan unik; int z_count = 0; Jumlah 0 s hadir; Menghitung blok penghalang; Kedudukan permulaan; Kod pemacu", "code": "import java . util . Arrays ; class GFG { static int ans = 0 ; static void dfs ( int i , int j , int [ ] [ ] grid , boolean [ ] [ ] vis , int z , int z_count ) { int n = grid . length , m = grid [ 0 ] . length ; vis [ i ] [ j ] = true ; if ( grid [ i ] [ j ] == 0 ) z ++ ; if ( grid [ i ] [ j ] == 2 ) { if ( z == z_count ) ans ++ ; vis [ i ] [ j ] = false ; return ; } if ( i >= 1 && ! vis [ i - 1 ] [ j ] && grid [ i - 1 ] [ j ] != - 1 ) dfs ( i - 1 , j , grid , vis , z , z_count ) ; if ( i < n - 1 && ! vis [ i + 1 ] [ j ] && grid [ i + 1 ] [ j ] != - 1 ) dfs ( i + 1 , j , grid , vis , z , z_count ) ; if ( j >= 1 && ! vis [ i ] [ j - 1 ] && grid [ i ] [ j - 1 ] != - 1 ) dfs ( i , j - 1 , grid , vis , z , z_count ) ; if ( j < m - 1 && ! vis [ i ] [ j + 1 ] && grid [ i ] [ j + 1 ] != - 1 ) dfs ( i , j + 1 , grid , vis , z , z_count ) ; vis [ i ] [ j ] = false ; } static int uniquePaths ( int [ ] [ ] grid ) { int n = grid . length , m = grid [ 0 ] . length ; boolean [ ] [ ] vis = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { Arrays . fill ( vis [ i ] , false ) ; } int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { if ( grid [ i ] [ j ] == 0 ) z_count ++ ; else if ( grid [ i ] [ j ] == 1 ) { x = i ; y = j ; } } } dfs ( x , y , grid , vis , 0 , z_count ) ; return ans ; } public static void main ( String [ ] args ) { int [ ] [ ] grid = { { 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 2 , - 1 } } ; System . out . println ( uniquePaths ( grid ) ) ; } }"}
{"text": "Kira pasangan yang tidak teratur (x, y) array yang memenuhi persamaan yang diberikan | Program Java untuk mencari bilangan pasangan yang tidak teratur (x, y) yang memenuhi persamaan yang diberikan untuk array; Mengembalikan bilangan pasangan yang tidak teratur yang memenuhi syarat; Ans menyimpan bilangan pasangan yang tidak teratur; Menjadikan setiap nilai array menjadi positif; Susun array; Bagi setiap indeks mengira sempadan yang betul untuk pasangan yang tidak teratur; Mengembalikan hasil akhir; Kod pemacu", "code": "import java . util . Arrays ; class GFG { static int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; Arrays . sort ( a ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 3 , 6 } ; int n = a . length ; System . out . println ( numPairs ( a , n ) ) ; } }"}
{"text": "Kawasan persegi | Menggunakan sisi, pepenjuru dan perimeter | Program Java untuk pendekatan di atas; Berfungsi untuk mencari kawasan persegi; Gunakan formula di atas; Kod pemacu; Diberikan sisi persegi; Panggilan fungsi", "code": "class GFG { static int areaOfSquare ( int S ) { int area = S * S ; return area ; } public static void main ( String [ ] args ) { int S = 5 ; System . out . println ( areaOfSquare ( S ) ) ; } }"}
{"text": "Titik maksimum persimpangan yang mungkin di kalangan x lingkaran dan garis lurus y | Program Java untuk melaksanakan pendekatan di atas; Kod pemacu; Bilangan bulatan; Bilangan garis lurus; Panggilan fungsi", "code": "class GFG { static int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; } public static void main ( String [ ] args ) { int x = 3 ; int y = 4 ; System . out . print ( maxPointOfIntersection ( x , y ) ) ; } }"}
{"text": "Nombor Icosihenagonal | Program Java untuk mencari nombor icosihenagon nth; Berfungsi untuk mencari nombor icosihenagon; Formula untuk mengira nombor icosihenagon nth; Kod pemacu", "code": "class GFG { static int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( Icosihenagonal_num ( n ) + \"NEW_LINE\"); n = 10 ; System . out . print ( Icosihenagonal_num ( n ) + \"NEW_LINE\"); } }"}
{"text": "Cari centroid bukan | Pelaksanaan Java pendekatan; Untuk semua simpang; Hitung nilai menggunakan formula kasut; Mengira koordinat centroid poligon; Kod pemacu; Menyelaras simpul", "code": "class GFG { static double [ ] find_Centroid ( double v [ ] [ ] ) { double [ ] ans = new double [ 2 ] ; int n = v . length ; double signedArea = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x0 = v [ i ] [ 0 ] , y0 = v [ i ] [ 1 ] ; double x1 = v [ ( i + 1 ) % n ] [ 0 ] , y1 = v [ ( i + 1 ) % n ] [ 1 ] ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; } public static void main ( String [ ] args ) { double vp [ ] [ ] = { { 1 , 2 } , { 3 , - 4 } , { 6 , - 7 } } ; double [ ] ans = find_Centroid ( vp ) ; System . out . println ( ans [ 0 ] + \" ▁ \" + ans [ 1 ] ) ; } }"}
{"text": "Program untuk mencari sudut segiempat | pelaksanaan Java pendekatan; Kod pemacu; Menurut formula yang diperolehi di atas; Cetak semua sudut", "code": "import java . io . * ; class GFG { public static void main ( String [ ] args ) { int d = 10 ; double a ; a = ( double ) ( 360 - ( 6 * d ) ) / 4 ; System . out . print ( a + \" , ▁ \" + ( a + d ) + \" , ▁ \" + ( a + ( 2 * d ) ) + \" , ▁ \" + ( a + ( 3 * d ) ) ) ; } }"}
{"text": "Jarak antara dua pesawat selari dalam 3 | Program Java untuk mencari jarak antara dua pesawat selari dalam 3 d. ; Berfungsi untuk mencari jarak; Kod pemacu", "code": "import java . io . * ; import java . lang . Math ; class GFG { static void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) / ( float ) ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; System . out . println ( \" Perpendicular ▁ distance ▁ is ▁ \" + d ) ; } else System . out . println ( \" Planes ▁ are ▁ not ▁ parallel \" ) ; } public static void main ( String [ ] args ) { float a1 = 1 ; float b1 = 2 ; float c1 = - 1 ; float d1 = 1 ; float a2 = 3 ; float b2 = 6 ; float c2 = - 3 ; float d2 = - 4 ; distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) ; } }"}
{"text": "Mengira cara untuk membentuk 2 kalung dari manik n yang mengandungi n / 2 manik masing -masing | Program Java untuk pendekatan di atas; Fungsi untuk mengira faktorial; Fungsi untuk mengira bilangan cara untuk membuat 2 kalung yang mempunyai manik N / 2 jika setiap manik dianggap berbeza; Bilangan cara untuk memilih manik n / 2 dari manik N; Bilangan cara untuk membekalkan manik n / 2; Bahagikan Ans oleh 2 untuk menghapuskan pengulangan; Kembali Ans; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "import java . io . * ; class GFG { static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } static long numOfNecklace ( int N ) { long ans = factorial ( N ) / ( factorial ( N / 2 ) * factorial ( N / 2 ) ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans /= 2 ; return ans ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( numOfNecklace ( N ) ) ; } }"}
{"text": "Semak jika nombor s boleh dibuat dibahagikan dengan d dengan berulang kali menambahkan selebihnya kepada s | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada S dibahagi dengan d semasa menukar s ke (s + s % d); V (0) = s % d; Menyimpan nilai yang ditemui; V (i) = (v (i - 1) + v (i - 1) % d) % d; Semak sama ada nilai telah ditemui; Kes tepi; Jika tidak, masukkannya ke dalam hashmap; Kod pemacu", "code": "import java . lang . * ; import java . util . * ; class GFG { static String isDivisibleByDivisor ( int S , int D ) { S %= D ; Set < Integer > hashMap = new HashSet < > ( ) ; hashMap . add ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) { S += ( S % D ) ; S %= D ; if ( hashMap . contains ( S ) ) { if ( S == 0 ) { return \" Yes \" ; } return \" No \" ; } else hashMap . add ( S ) ; } return \" Yes \" ; } public static void main ( String [ ] args ) { int S = 3 , D = 6 ; System . out . println ( isDivisibleByDivisor ( S , D ) ) ; } }"}
{"text": "Bilangan minimum bergerak yang diperlukan untuk mencapai (1, 1) dari (x, y) | Program Java untuk pendekatan di atas; Fungsi untuk mengira bilangan langkah yang diperlukan untuk menukar (x, y) hingga (1, 1); Simpan hasil yang diperlukan; Melangkah sementara kedua -dua x dan y tidak sama dengan 0; Jika x lebih besar daripada y; Kemas kini kiraan dan nilai x; Jika tidak; Kemas kini kiraan dan nilai y; Jika kedua -dua x dan y> 1; Cetak hasilnya; Kod pemacu; Diberikan x dan y", "code": "import java . util . * ; class GFG { static void minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; System . out . println ( cnt ) ; } public static void main ( String [ ] args ) { int x = 3 , y = 1 ; minimumSteps ( x , y ) ; } }"}
{"text": "Semak jika array adalah stack Sortable | Pelaksanaan Java pendekatan di atas. ; Fungsi untuk memeriksa sama ada [] adalah stack sortable atau tidak. ; Stack s; Penunjuk ke nilai akhir array b. ; Melintasi setiap elemen [] dari memulakan pemeriksaan jika terdapat operasi yang sah yang boleh dilakukan. ; Jika timbunan tidak kosong; Bahagian atas timbunan. ; Jika bahagian atas timbunan adalah sama dengan B_end + 1, kami akan pop dan kenaikan b_end oleh 1 .; Jika bahagian atas semasa adalah sama dengan b_end + 1, kami akan meningkatkan b_end ke b_end + 1; Pop elemen teratas. ; Sekiranya timbunan kosong, kita tidak dapat terus berusaha operasi ini. Oleh itu pecah; Atas semasa; Jika timbunan kosong tolak elemen semasa; Jika elemen semasa array A [] jika lebih kecil daripada bahagian atas timbunan kita boleh menolaknya dalam timbunan. ; Lain -lain kita tidak dapat menyusun array menggunakan mana -mana operasi yang sah. ; Tidak boleh disusun; Jika timbunan kosong tolak elemen semasa dalam timbunan. ; Stack Sortable; Kod pemandu", "code": "import java . util . Stack ; class GFG { static boolean check ( int A [ ] , int N ) { Stack < Integer > S = new Stack < Integer > ( ) ; int B_end = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! S . empty ( ) ) { int top = S . peek ( ) ; while ( top == B_end + 1 ) { B_end = B_end + 1 ; S . pop ( ) ; if ( S . empty ( ) ) { break ; } top = S . peek ( ) ; } if ( S . empty ( ) ) { S . push ( A [ i ] ) ; } else { top = S . peek ( ) ; if ( A [ i ] < top ) { S . push ( A [ i ] ) ; } else { return false ; } } } else { S . push ( A [ i ] ) ; } } return true ; } public static void main ( String [ ] args ) { int A [ ] = { 4 , 1 , 2 , 3 } ; int N = A . length ; if ( check ( A , N ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Kod Java untuk mengira pembalikan minimum untuk membuat ekspresi seimbang. ; Kaedah mengira pembalikan minimum untuk membuat ungkapan seimbang. Pulangan - 1 jika ungkapan tidak boleh seimbang; Panjang ekspresi mestilah menjadikannya seimbang dengan menggunakan pembalikan. ; Selepas gelung ini, timbunan mengandungi bahagian ekspresi yang tidak seimbang, i. e. , ungkapan bentuk \"}}.} {{.. {\"; Panjang ekspresi yang dikurangkan red_len = (m + n); mengira kurungan pembukaan pada akhir timbunan; Kembali Ceil (m / 2) + Ceil (n / 2) yang sebenarnya sama dengan (m + n) / 2 + n % 2 apabila m + n juga. ; Kaedah Pemandu", "code": "import java . util . Stack ; public class GFG { static int countMinReversals ( String expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) return - 1 ; Stack < Character > s = new Stack < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = expr . charAt ( i ) ; if ( c == ' } ' && ! s . empty ( ) ) { if ( s . peek ( ) == ' { ' ) s . pop ( ) ; else s . push ( c ) ; } else s . push ( c ) ; } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . peek ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; } public static void main ( String [ ] args ) { String expr = \" } } { { \" ; System . out . println ( countMinReversals ( expr ) ) ; } }"}
{"text": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Kod Java untuk mengira pembalikan minimum untuk membuat ekspresi seimbang. ; Kaedah mengira pembalikan minimum untuk membuat ungkapan seimbang. Pulangan - 1 jika ungkapan tidak boleh seimbang; Ekspresi panjang ganjil tidak boleh seimbang; Jika kita menemui pendakap kiri maka kita hanya menambah kurungan kiri; Lain jika pendakap kiri adalah 0 maka kita dapati pendakap kanan yang tidak seimbang dan pendakap kanan kenaikan atau jika ungkapan seimbang maka kita menurunkan kiri; Kaedah Pemandu", "code": "import java . util . * ; public class GFG { static int countMinReversals ( String expr ) { int len = expr . length ( ) ; int ans ; if ( len % 2 != 0 ) { return - 1 ; } int left_brace = 0 , right_brace = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = expr . charAt ( i ) ; if ( ch == ' { ' ) { left_brace ++ ; } else { if ( left_brace == 0 ) { right_brace ++ ; } else { left_brace -- ; } } } ans = ( int ) ( Math . ceil ( ( 0.0 + left_brace ) / 2 ) + Math . ceil ( ( 0.0 + right_brace ) / 2 ) ) ; return ans ; } public static void main ( String [ ] args ) { String expr = \" } } { { \" ; System . out . println ( countMinReversals ( expr ) ) ; } }"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Program Java untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; Mencetak nombor minimum yang boleh dibentuk dari urutan input i dan u; Inisialisasi Current_Max (untuk memastikan bahawa kita tidak menggunakan watak berulang; permulaan last_entry (menjejaki angka bercetak terakhir); beralih ke atas array input; memulakan 'noofnextd' untuk mendapatkan kiraan d berikut yang tersedia; Cetak angka untuk saya", "code": "class GFG { static void PrintMinNumberForPattern ( String arr ) { int curr_max = 0 ; int last_entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOfNextD = 0 ; switch ( arr . charAt ( i ) ) { case ' I ' : j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ; System . out . print ( \" ▁ \" + ++ last_entry ) ; System . out . print ( \" ▁ \" + curr_max ) ; last_entry = curr_max ; } else { curr_max = curr_max + noOfNextD + 1 ; last_entry = curr_max ; System . out . print ( \" ▁ \" + last_entry ) ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { System . out . print ( \" ▁ \" + -- last_entry ) ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOfNextD ++ ; j ++ ; } curr_max = noOfNextD + 2 ; System . out . print ( \" ▁ \" + curr_max + \" ▁ \" + ( curr_max - 1 ) ) ; last_entry = curr_max - 1 ; } else { System . out . print ( \" ▁ \" + ( last_entry - 1 ) ) ; last_entry -- ; } break ; } } System . out . println ( ) ; } public static void main ( String [ ] args ) { PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; } }"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Program Java untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; min_avail mewakili nombor minimum yang masih tersedia untuk memasukkan dalam vektor output. pos_of_i menjejaki indeks paling terkini di mana 'i' ditemui w. r. t vektor output; vektor untuk menyimpan output; meliputi kes asas; Melintasi sisa input; Cetak nombor; Kod pemacu", "code": "import java . io . * ; import java . util . * ; public class GFG { static void printLeast ( String arr ) { int min_avail = 1 , pos_of_I = 0 ; ArrayList < Integer > al = new ArrayList < > ( ) ; if ( arr . charAt ( 0 ) == ' I ' ) { al . add ( 1 ) ; al . add ( 2 ) ; min_avail = 3 ; pos_of_I = 1 ; } else { al . add ( 2 ) ; al . add ( 1 ) ; min_avail = 3 ; pos_of_I = 0 ; } for ( int i = 1 ; i < arr . length ( ) ; i ++ ) { if ( arr . charAt ( i ) == ' I ' ) { al . add ( min_avail ) ; min_avail ++ ; pos_of_I = i + 1 ; } else { al . add ( al . get ( i ) ) ; for ( int j = pos_of_I ; j <= i ; j ++ ) al . set ( j , al . get ( j ) + 1 ) ; min_avail ++ ; } } for ( int i = 0 ; i < al . size ( ) ; i ++ ) System . out . print ( al . get ( i ) + \" ▁ \" ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { printLeast ( \" IDID \" ) ; printLeast ( \" I \" ) ; printLeast ( \" DD \" ) ; printLeast ( \" II \" ) ; printLeast ( \" DIDI \" ) ; printLeast ( \" IIDDD \" ) ; printLeast ( \" DDIDDIID \" ) ; } }"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Program Java untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; Fungsi untuk menyahkod urutan yang diberikan untuk membina nombor minimum tanpa digit berulang; Hasil Store Output String; Buat timbunan integer kosong; Jalankan n + 1 kali di mana n adalah panjang urutan input; Tekan nombor I + 1 ke dalam timbunan; Jika semua aksara urutan input diproses atau watak semasa adalah 'I' (meningkat); Jalankan sehingga timbunan kosong; Keluarkan elemen teratas dari timbunan dan tambahkannya ke penyelesaian; fungsi utama", "code": "import java . util . Stack ; class GFG { static void PrintMinNumberForPattern ( String seq ) { String result = \" \" ; Stack < Integer > stk = new Stack < Integer > ( ) ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) || seq . charAt ( i ) == ' I ' ) { while ( ! stk . empty ( ) ) { result += String . valueOf ( stk . peek ( ) ) ; result += \" ▁ \" ; stk . pop ( ) ; } } } System . out . println ( result ) ; } public static void main ( String [ ] args ) { PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; } }"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Program Java pendekatan di atas; Mengembalikan nombor minimum yang dibuat dari urutan yang diberikan tanpa mengulangi digit; Gelung berjalan untuk setiap aksara input serta satu masa tambahan untuk memberikan pangkat kepada setiap aksara yang tinggal; Kod pemacu", "code": "import java . io . IOException ; public class Test { static String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return \" - 1\" ; char result [ ] = new char [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq . charAt ( j ) == ' I ' ) break ; } } } return new String ( result ) ; } public static void main ( String [ ] args ) throws IOException { String inputs [ ] = { \" IDID \" , \" I \" , \" DD \" , \" II \" , \" DIDI \" , \" IIDDD \" , \" DDIDDIID \" } ; for ( String input : inputs ) { System . out . println ( getMinNumberForPattern ( input ) ) ; } } }"}
{"text": "Semak jika digit pertama dan terakhir nombor terkecil membentuk Perdana | Pelaksanaan Java pendekatan di atas; berfungsi untuk memeriksa perdana; Berfungsi untuk menghasilkan nombor yang paling kecil dengan digit yang diberikan; Mengisytiharkan pelbagai hash saiz 10 dan memulakan semua elemen kepada sifar; Simpan bilangan kejadian digit dalam array yang diberikan ke dalam jadual hash; Melintasi hash dalam urutan menaik untuk mencetak nombor yang diperlukan; Cetak bilangan kali digit berlaku; mengekstrak digit pertama; mengekstrak digit terakhir; mencetak kombinasi utama; Kod pemacu", "code": "import java . io . * ; class SmallPrime { static boolean isPrime ( int n ) { int i , c = 0 ; for ( i = 1 ; i < n / 2 ; i ++ ) { if ( n % i == 0 ) c ++ ; } if ( c == 1 ) { return true ; } else { return false ; } } static void findMinNum ( int arr [ ] , int n ) { int first = 0 , last = 0 , num , rev , i ; int hash [ ] = new int [ 10 ] ; for ( i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } System . out . print ( \" Minimum ▁ number : ▁ \" ) ; for ( i = 0 ; i <= 9 ; i ++ ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) System . out . print ( i ) ; } System . out . println ( ) ; System . out . println ( ) ; for ( i = 0 ; i <= 9 ; i ++ ) { if ( hash [ i ] != 0 ) { first = i ; break ; } } for ( i = 9 ; i >= 0 ; i -- ) { if ( hash [ i ] != 0 ) { last = i ; break ; } } num = first * 10 + last ; rev = last * 10 + first ; System . out . print ( \" Prime ▁ combinations : ▁ \" ) ; if ( isPrime ( num ) && isPrime ( rev ) ) { System . out . println ( num + \" ▁ \" + rev ) ; } else if ( isPrime ( num ) ) { System . out . println ( num ) ; } else if ( isPrime ( rev ) ) { System . out . println ( rev ) ; } else { System . out . println ( \" No ▁ combinations ▁ exist \" ) ; } } public static void main ( String [ ] args ) { SmallPrime smallprime = new SmallPrime ( ) ; int arr [ ] = { 1 , 2 , 4 , 7 , 8 } ; smallprime . findMinNum ( arr , 5 ) ; } }"}
{"text": "Mencari Co Transitif | Program Java untuk mencari kemungkinan tiga kali ganda transitif btw l dan r; Berfungsi untuk mengembalikan GCD A dan B; berfungsi untuk memeriksa GCD; A dan B adalah coprime jika GCD mereka adalah 1; Memeriksa jika ada triplet yang mungkin (a, b, c) menetapkan keadaan bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Menjana dan menyemak semua kemungkinan tiga kali ganda antara L dan R; Jika kita dapati apa -apa tiga kali ganda menetapkan bendera kepada benar; Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; Kod pemacu; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46", "code": "class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static boolean coprime ( int a , int b ) { return ( gcd ( a , b ) == 1 ) ; } static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { for ( int c = b + 1 ; c <= R ; c ++ ) { if ( coprime ( a , b ) && coprime ( b , c ) && ! coprime ( a , c ) ) { flag = true ; possibleA = a ; possibleB = b ; possibleC = c ; break ; } } } } if ( flag == true ) { System . out . println ( \" ( \" + possibleA + \" , ▁ \" + possibleB + \" , ▁ \" + possibleC + \" ) \" + \" ▁ is ▁ one ▁ such ▁ possible ▁ triplet ▁ \" + \" between ▁ \" + L + \" ▁ and ▁ \" + R ) ; } else { System . out . println ( \" No ▁ Such ▁ Triplet ▁ exists \" + \" between ▁ \" + L + \" ▁ and ▁ \" + R ) ; } } public static void main ( String [ ] args ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }"}
{"text": "Jangkau A dan B dengan mengalikannya dengan k dan k ^ 2 pada setiap langkah | Program Java untuk menentukan sama ada A dan B boleh dicapai bermula dari 1, 1 berikutan langkah -langkah yang diberikan. ; Fungsi untuk memeriksa adalah mungkin untuk mencapai A dan B bermula dari 1 dan 1; Cari cuberoot nombor; Bahagikan nombor dengan Cuberoot; Jika ia adalah cuberoot yang sempurna dan membahagikan A dan B; Kod pemacu", "code": "class GFG { static boolean possibleToReach ( int a , int b ) { int c = ( int ) Math . cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int A = 60 , B = 450 ; if ( possibleToReach ( A , B ) ) System . out . println ( \" yes \" ) ; else System . out . println ( \" no \" ) ; } }"}
{"text": "Nombor bergelora | Program Java untuk memeriksa sama ada nombor beralun atau tidak; Memandangkan definisi dengan sekatan bahawa terdapat sekurang -kurangnya 3 digit; Semak sama ada semua digit alternatif adalah sama atau tidak. ; Kod pemacu", "code": "import java . util . * ; class GFG { public static boolean isUndulating ( String n ) { if ( n . length ( ) <= 2 ) return false ; for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n . charAt ( i - 2 ) != n . charAt ( i ) ) return false ; return true ; } public static void main ( String [ ] args ) { String n = \"1212121\" ; if ( isUndulating ( n ) == true ) System . out . println ( \" yes \" ) ; else System . out . println ( \" no \" ) ; } }"}
{"text": "Program untuk mencari jumlah siri (1 * 1) + (2 * 2) + (3 * 3) + (4 * 4) + (5 * 5) + ... + (n * n) | Program Java untuk mengira siri berikut; Fungsi untuk mengira siri berikut; Kod pemacu", "code": "import java . io . * ; class GFG { static int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; } public static void main ( String [ ] args ) { int n = 3 ; int res = Series ( n ) ; System . out . println ( res ) ; } }"}
{"text": "Kira nombor dengan unit digit k dalam julat yang diberikan | Program Java yang cekap untuk mengira nombor dengan digit terakhir sebagai k dalam julat yang diberikan. ; Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; fungsi pemacu", "code": "import java . util . * ; import java . lang . * ; public class GfG { public static int counLastDigitK ( int low , int high , int k ) { int mlow = 10 * ( int ) Math . ceil ( low / 10.0 ) ; int mhigh = 10 * ( int ) Math . floor ( high / 10.0 ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 <= k && ( low % 10 ) > 0 ) count ++ ; return count ; } public static void main ( String argc [ ] ) { int low = 3 , high = 35 , k = 3 ; System . out . println ( counLastDigitK ( low , high , k ) ) ; } }"}
{"text": "Jumlah semua nombor yang boleh dibahagikan dengan 6 dalam julat yang diberikan | Program Java untuk mencari jumlah nombor yang boleh dibahagi dengan 6 dalam julat tertentu. ; fungsi untuk mengira jumlah semua nombor yang boleh dibahagi dengan 6 dalam julat l - r. . ; tidak ada gandaan 6 sehingga r; tiada gandaan 6 sehingga l - 1; penjumlahan semua gandaan 6 sehingga r; penjumlahan semua gandaan 6 sehingga l - 1; mengembalikan jawapannya; Program Pemandu", "code": "import java . io . * ; class GFG { static int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; } public static void main ( String [ ] args ) { int L = 1 , R = 20 ; System . out . println ( sum ( L , R ) ) ; } }"}
{"text": "Nombor yang lebih kecil yang terbesar mungkin menggunakan hanya satu operasi swap | Program Java untuk mencari nombor yang lebih kecil dengan menukar satu digit. ; Mengembalikan nombor yang mungkin terbesar dengan satu swap supaya nombor itu lebih kecil daripada STR. Dianggap bahawa terdapat 0 s. ; Traverse dari kanan sehingga kita dapati digit yang lebih besar daripada digit seterusnya. Sebagai contoh, dalam 34125, indeks kami ialah 4 .; Kami juga boleh menggunakan carian binari di sini sebagai digit selepas indeks disusun dalam peningkatan urutan. Cari digit terbesar di sebelah kanan ARR [indeks] yang lebih kecil daripada ARR [indeks]; Jika indeks adalah - 1 i. e. Digit adalah dalam urutan yang semakin meningkat. ; Menukar kedua -dua nilai; Kod pemacu", "code": "class GFG { static String prevNum ( String str ) { int len = str . length ( ) ; int index = - 1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) > str . charAt ( i + 1 ) ) { index = i ; break ; } } int smallGreatDgt = - 1 ; for ( int i = len - 1 ; i > index ; i -- ) { if ( str . charAt ( i ) < str . charAt ( index ) ) { if ( smallGreatDgt == - 1 ) { smallGreatDgt = i ; } else if ( str . charAt ( i ) >= str . charAt ( smallGreatDgt ) ) { smallGreatDgt = i ; } } } if ( index == - 1 ) { return \" - 1\" ; } if ( smallGreatDgt != - 1 ) { str = swap ( str , index , smallGreatDgt ) ; return str ; } return \" - 1\" ; } static String swap ( String str , int i , int j ) { char ch [ ] = str . toCharArray ( ) ; char temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; return String . valueOf ( ch ) ; } public static void main ( String [ ] args ) { String str = \"34125\" ; System . out . println ( prevNum ( str ) ) ; } }"}
{"text": "SGN Nilai polinomial | Program Java untuk mencari nilai tanda polinomial; Pulangan nilai poli [0] x (n - 1) + poli [1] x (n - 2) +. . + poli [n - 1]; Memulakan hasil; Menilai nilai polinomial menggunakan kaedah Horner; Mengembalikan nilai tanda polinomial; Kod pemacu; Marilah kita menilai nilai 2 x3 - 6 x2 + 2 x - 1 untuk x = 3", "code": "class GFG { static int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; } static int findSign ( int poly [ ] , int n , int x ) { int result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return - 1 ; return 0 ; } public static void main ( String [ ] args ) { int poly [ ] = { 2 , - 6 , 2 , - 1 } ; int x = 3 ; int n = poly . length ; System . out . print ( \" Sign ▁ of ▁ polynomial ▁ is ▁ \" + findSign ( poly , n , x ) ) ; } }"}
{"text": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | Program Java untuk mencari nombor minimum untuk memasukkan dalam array supaya jumlahnya adalah perdana; Array untuk menyimpan prima; berfungsi untuk mengira prima menggunakan ayak eratosthenes; Cari nombor perdana lebih besar daripada nombor; Untuk mengembalikan nombor perdana lebih besar daripada n; Semak jika Num adalah Perdana; kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Panggil Sieveoferatostheneses untuk mengira prima; Untuk mencari jumlah elemen array; Untuk mencari nombor perdana yang lebih besar maka jumlahnya; Mengembalikan perbezaan jumlah dan num; Kod pemacu", "code": "class GFG { static int MAX = 100005 ; static boolean [ ] isPrime = new boolean [ MAX ] ; static void sieveOfEratostheneses ( ) { isPrime [ 1 ] = true ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( ! isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = true ; } } } static int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( ! isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; } static int minNumber ( int arr [ ] , int n ) { sieveOfEratostheneses ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( ! isPrime [ sum ] ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . length ; System . out . println ( minNumber ( arr , n ) ) ; } }"}
{"text": "Jumlah semua subarray | Tetapkan 1 | Program Java mudah untuk mengira jumlah elemen subarray; Mengira jumlah semua sub - array; Pilih titik permulaan; Memilih titik akhir; jumlah subarray antara titik permulaan dan akhir semasa; Program pemacu untuk menguji fungsi di atas", "code": "class GFG { public static long SubArraySum ( int arr [ ] , int n ) { long result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . println ( \" Sum ▁ of ▁ SubArray ▁ : ▁ \" + SubArraySum ( arr , n ) ) ; } }"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program Java untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Kod pemacu", "code": "import java . io . * ; class GFG { static int highestPowerof2 ( int n ) { int p = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( highestPowerof2 ( n ) ) ; } }"}
{"text": "Susun semula aksara dalam rentetan supaya tidak dua bersebelahan adalah sama | Program Java untuk menyusun semula aksara dalam rentetan supaya tidak ada dua aksara bersebelahan. ; Mengatasi membandingkan () kaedah komparator; frekuensi penyimpanan watak; Berfungsi untuk menyusun semula watak rentetan supaya tiada char mengulangi dua kali; Simpan frekuensi semua aksara dalam rentetan; Masukkan semua aksara dengan frekuensi mereka ke Priority_Queue; 'str' yang akan menyimpan nilai yang dihasilkan; Bekerja sebagai elemen awal yang dilawati sebelum ini. (' #' dan frekuensi ' - 1'); Giliran Traverse; Pop atas elemen dari barisan dan tambahkannya ke rentetan. ; Jika kekerapan watak sebelumnya kurang daripada sifar yang bermaksud ia tidak berguna, kita tidak perlu menolaknya; Buat watak semasa sebagai kekerapan 'char' yang terdahulu oleh 'satu'; Jika panjang rentetan yang dihasilkan dan rentetan asal tidak sama maka rentetan tidak sah; rentetan sah; Program pemacu untuk menguji fungsi di atas", "code": "import java . io . * ; import java . util . * ; class KeyComparator implements Comparator < Key > { public int compare ( Key k1 , Key k2 ) { if ( k1 . freq < k2 . freq ) return 1 ; else if ( k1 . freq > k2 . freq ) return - 1 ; return 0 ; } } class Key { int freq ; char ch ; Key ( int val , char c ) { freq = val ; ch = c ; } } class GFG { static int MAX_CHAR = 26 ; static void rearrangeString ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - ' a ' ] ++ ; PriorityQueue < Key > pq = new PriorityQueue < > ( new KeyComparator ( ) ) ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int val = c - ' a ' ; if ( count [ val ] > 0 ) pq . add ( new Key ( count [ val ] , c ) ) ; } str = \" \" ; Key prev = new Key ( - 1 , ' # ' ) ; while ( pq . size ( ) != 0 ) { Key k = pq . peek ( ) ; pq . poll ( ) ; str = str + k . ch ; if ( prev . freq > 0 ) pq . add ( prev ) ; ( k . freq ) -- ; prev = k ; } if ( n != str . length ( ) ) System . out . println ( \" ▁ Not ▁ valid ▁ String ▁ \" ) ; else System . out . println ( str ) ; } public static void main ( String args [ ] ) { String str = \" bbbaa \" ; rearrangeString ( str ) ; } }"}
{"text": "Cari (a ^ b) % m di mana 'a' sangat besar | Program Java untuk mencari (a ^ b) mod m untuk 'a' yang besar; fungsi utiliti untuk mengira % m; (S [i] - '0') memberikan nilai digit dan membentuk nombor; Pulangan mencari (a ^ b) % m; Cari % m; Sekarang kalikan Ans dengan b - 1 kali dan ambil mod dengan m; Kod pemacu", "code": "public class GFG { static int aModM ( String s , int mod ) { int number = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { number = ( number * 10 ) ; int x = Character . getNumericValue ( s . charAt ( i ) ) ; number = number + x ; number %= mod ; } return number ; } static int ApowBmodM ( String a , int b , int m ) { int ans = aModM ( a , m ) ; int mul = ans ; for ( int i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; } public static void main ( String args [ ] ) { String a = \"987584345091051645734583954832576\" ; int b = 3 , m = 11 ; System . out . println ( ApowBmodM ( a , b , m ) ) ; } }"}
{"text": "Interpolasi LaGrange | Program Java untuk pelaksanaan interpolasi LaGrange; Untuk mewakili titik data yang sepadan dengan x dan y = f (x); Fungsi untuk menginterpolasi titik data yang diberikan menggunakan Formula XI LaGrange sepadan dengan titik data baru yang nilainya diperoleh n mewakili bilangan titik data yang diketahui; hasil berganda = 0; Memulakan hasil; Mengira syarat individu di atas formula; Tambah istilah semasa untuk menghasilkan; Kod pemacu; mewujudkan pelbagai 4 mata data yang diketahui; Menggunakan fungsi interpolasi untuk mendapatkan titik data yang sepadan dengan x = 3", "code": "import java . util . * ; class GFG { static class Data { int x , y ; public Data ( int x , int y ) { super ( ) ; this . x = x ; this . y = y ; } } ; static double interpolate ( Data f [ ] , int xi , int n ) { for ( int i = 0 ; i < n ; i ++ ) { double term = f [ i ] . y ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i ) term = term * ( xi - f [ j ] . x ) / ( f [ i ] . x - f [ j ] . x ) ; } result += term ; } return result ; } public static void main ( String [ ] args ) { Data f [ ] = { new Data ( 0 , 2 ) , new Data ( 1 , 3 ) , new Data ( 2 , 12 ) , new Data ( 5 , 147 ) } ; System . out . print ( \" Value ▁ of ▁ f ( 3 ) ▁ is ▁ : ▁ \" + ( int ) interpolate ( f , 3 , 4 ) ) ; } }"}
{"text": "Sieve of Sundaram untuk mencetak semua prima yang lebih kecil daripada n | Program Java untuk mencetak prima yang lebih kecil daripada N menggunakan ayak Sundaram. ; Mencetak semua nombor perdana yang lebih kecil; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahu prima lebih kecil daripada N, kita mengurangkan N hingga separuh; Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j; Memulakan semua elemen sebagai tidak ditandakan; Logik utama Sundaram. Tandakan semua nombor bentuk i + j + 2 ij sebagai benar di mana 1 <= i <= j; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Kod pemacu", "code": "import java . util . Arrays ; class GFG { static int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; boolean marked [ ] = new boolean [ nNew + 1 ] ; Arrays . fill ( marked , false ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) System . out . print ( 2 + \" ▁ \" ) ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) System . out . print ( 2 * i + 1 + \" ▁ \" ) ; return - 1 ; } public static void main ( String [ ] args ) { int n = 20 ; SieveOfSundaram ( n ) ; } }"}
{"text": "Bina Arahan Asal Bermula dengan K dari pelbagai xor semua elemen kecuali elemen pada indeks yang sama | Program Java untuk pendekatan di atas; Berfungsi untuk membina array dengan setiap elemen yang sama dengan XOR semua elemen array kecuali elemen pada indeks yang sama; Array asal; Kedai bitwise xor array; Hitung XOR semua elemen array; Cetak array asal B []; Kod pemacu; Panggilan fungsi", "code": "class GFG { static void constructArray ( int A [ ] , int N , int K ) { int B [ ] = new int [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int A [ ] = { 13 , 14 , 10 , 6 } , K = 2 ; int N = A . length ; constructArray ( A , N , K ) ; } }"}
{"text": "Cari elemen tambahan dalam array kedua | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan elemen tambahan dalam b []; Untuk menyimpan hasilnya; Cari xor semua elemen array a [] dan array b []; Kod pemacu", "code": "class GFG { static int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 10 , 15 , 5 } ; int B [ ] = { 10 , 100 , 15 , 5 } ; int n = A . length ; System . out . println ( extraElement ( A , B , n ) ) ; } }"}
{"text": "Hamming jarak antara dua bilangan bulat | Pelaksanaan Java pendekatan di atas; Fungsi untuk mengira jarak Hamming; Kod pemacu", "code": "class GFG { static int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; } public static void main ( String [ ] args ) { int n1 = 9 , n2 = 14 ; System . out . println ( hammingDistance ( n1 , n2 ) ) ; } }"}
{"text": "Cetak bitwise dan set nombor n | Program Java untuk mencetak semua subset bitwise N (pendekatan naif); berfungsi untuk mencari pendekatan naif subset bitwise; Fungsi pemacu", "code": "class GFG { static void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) System . out . print ( i + \" ▁ \" ) ; } public static void main ( String [ ] args ) { int n = 9 ; printSubsets ( n ) ; } }"}
{"text": "Cari bit set yang paling ketara | Program Java untuk mencari nombor MSB untuk diberikan n. ; Untuk mencari kedudukan bit set yang paling penting; Untuk mengembalikan nilai nombor dengan set bit pada kedudukan k - th; Kod pemacu", "code": "class GFG { static int setBitNumber ( int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return 1 << k ; } public static void main ( String arg [ ] ) { int n = 273 ; System . out . print ( setBitNumber ( n ) ) ; } }"}
{"text": "Bilangan minimum subset dengan elemen yang berbeza | Penyelesaian berasaskan penyortiran untuk mencari bilangan minimum subset set supaya setiap subset mengandungi unsur -unsur yang berbeza. ; Fungsi untuk mengira subset sedemikian rupa sehingga semua subset mempunyai elemen yang berbeza. ; Ambil input dan mulakan res = 0; Susun array; Melintasi array input dan cari kekerapan maksimum; Untuk setiap nombor mencari pengulangan / kekerapannya; Kemas kini res; Fungsi pemacu", "code": "import java . util . * ; import java . lang . * ; public class GfG { public static int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; } public static void main ( String argc [ ] ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = 7 ; System . out . println ( subset ( arr , n ) ) ; } }"}
{"text": "Bilangan minimum subset dengan elemen yang berbeza | Penyelesaian berasaskan hash untuk mencari bilangan minimum subset set supaya setiap subset mengandungi unsur -unsur yang berbeza. ; Fungsi untuk mengira subset sedemikian rupa sehingga semua subset mempunyai elemen yang berbeza. ; Melintasi array input dan frekuensi elemen; Cari nilai maksimum dalam peta. ; Kod pemacu", "code": "import java . util . HashMap ; import java . util . Map ; class GFG { static int subset ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int res = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) res = Math . max ( res , entry . getValue ( ) ) ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = arr . length ; System . out . println ( subset ( arr , n ) ) ; } }"}
{"text": "Kira cara untuk mewakili nombor sebagai jumlah kotak yang sempurna | Program Java untuk pendekatan di atas; Simpan kotak sempurna kurang daripada atau sama dengan n; Fungsi utiliti untuk mengira dataran sempurna kurang daripada atau sama dengan n; Berfungsi untuk mencari bilangan cara untuk mewakili nombor sebagai jumlah kuadrat yang sempurna; Mengendalikan kes asas; Sertakan elemen indeks I - th; Tidak termasuk elemen indeks i - th; Mengembalikan hasilnya; Kod pemacu; Diberikan input; Precomment squares sempurna <= n; Panggilan fungsi", "code": "import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static ArrayList < Integer > psquare = new ArrayList < > ( ) ; static void calcPsquare ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) psquare . add ( i * i ) ; } static int countWays ( int index , int target ) { if ( target == 0 ) return 1 ; if ( index < 0 target < 0 ) return 0 ; int inc = countWays ( index , target - psquare . get ( index ) ) ; int exc = countWays ( index - 1 , target ) ; return inc + exc ; } public static void main ( String [ ] args ) { int N = 9 ; calcPsquare ( N ) ; System . out . print ( countWays ( psquare . size ( ) - 1 , N ) ) ; } }"}
{"text": "Jumlah jarak semua nod dari nod yang diberikan | Program Java untuk pendekatan di atas; Struktur nod pokok binari; Fungsi yang memperuntukkan nod baru dengan data yang diberikan dan batal ke petunjuk kiri dan kanannya; Kembali nod yang baru dibuat; Berfungsi untuk mengira bilangan nod di subtrees kiri dan kanan; Memulakan pasangan yang menyimpan pasangan {bilangan nod, kedalaman}; Mencari bilangan nod di subtree kiri; Cari bilangan nod di subtree yang betul; Mengisi medan saiz; Menyimpan jumlah jarak semua nod dari nod yang diberikan; Berfungsi untuk mencari jarak keseluruhan; Jika nod sasaran sepadan dengan nod semasa; Jika akar. Kiri tidak batal; Kemas kini Jumlah; Berulang untuk subtree kiri; Jika akar. Kanan tidak batal; Memohon formula yang diberikan dalam pendekatan; Berulang untuk subtree yang betul; Kod pemacu; Pokok input; Jumlah nod; Cetak jumlah jarak", "code": "import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static class TreeNode { int data , size ; TreeNode left ; TreeNode right ; } ; static TreeNode newNode ( int data ) { TreeNode Node = new TreeNode ( ) ; Node . data = data ; Node . left = null ; Node . right = null ; return ( Node ) ; } static pair sumofsubtree ( TreeNode root ) { pair p = new pair ( 1 , 0 ) ; if ( root . left != null ) { pair ptemp = sumofsubtree ( root . left ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } if ( root . right != null ) { pair ptemp = sumofsubtree ( root . right ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } root . size = p . first ; return p ; } static int sum = 0 ; static void distance ( TreeNode root , int target , int distancesum , int n ) { if ( root . data == target ) { sum = distancesum ; } if ( root . left != null ) { int tempsum = distancesum - root . left . size + ( n - root . left . size ) ; distance ( root . left , target , tempsum , n ) ; } if ( root . right != null ) { int tempsum = distancesum - root . right . size + ( n - root . right . size ) ; distance ( root . right , target , tempsum , n ) ; } } public static void main ( String [ ] args ) { TreeNode root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 7 ) ; root . left . left . left = newNode ( 8 ) ; root . left . left . right = newNode ( 9 ) ; int target = 3 ; pair p = sumofsubtree ( root ) ; int totalnodes = p . first ; distance ( root , target , p . second , totalnodes ) ; System . out . print ( sum + \"NEW_LINE\"); } }"}
{"text": "Menyusun semula array sedemikian rupa sehingga jumlah elemen yang diindeks yang sama adalah atmost k | Program Java untuk pendekatan di atas; Arahan terbalik; Fungsi untuk menyusun semula array sedemikian rupa sehingga jumlah unsur -unsur yang diindeks yang sama tidak melebihi k; Susun array b [] dalam urutan menurun; Jika keadaan gagal; Cetak array; Kod pemacu; Diberikan susunan", "code": "import java . util . * ; class GFG { static int [ ] reverse ( int a [ ] ) { int i , n = a . length , t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; } static void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) { Arrays . sort ( B ) ; B = reverse ( B ) ; boolean flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > K ) { flag = false ; break ; } } if ( ! flag ) { System . out . print ( \" - 1\" + \"NEW_LINE\"); } else { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + \" ▁ \" ) ; } } } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 2 } ; int B [ ] = { 1 , 2 , 3 , 1 , 1 } ; int N = A . length ; int K = 5 ; rearrangeArray ( A , B , N , K ) ; } }"}
{"text": "Kira baris dengan jumlah melebihi jumlah matriks yang tinggal | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira bilangan baris yang jumlahnya melebihi jumlah unsur -unsur matriks yang tinggal; Menyimpan dimensi matriks; Untuk menyimpan hasilnya; Menyimpan jumlah keseluruhan unsur matriks; Kirakan jumlah keseluruhan; Melintasi untuk memeriksa setiap baris; Menyimpan jumlah elemen baris semasa; Kirakan jumlah elemen baris semasa; Jika jumlah baris semasa melebihi jumlah sisa matriks; Peningkatan kiraan; Cetak hasilnya; Kod pemacu; Diberikan matriks; Panggilan fungsi", "code": "import java . io . * ; class GFG { static void countRows ( int [ ] [ ] mat ) { int n = mat . length ; int m = mat [ 0 ] . length ; int count = 0 ; int totalSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { totalSum += mat [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { int currSum = 0 ; for ( int j = 0 ; j < m ; j ++ ) { currSum += mat [ i ] [ j ] ; } if ( currSum > totalSum - currSum ) count ++ ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 2 , - 1 , 5 } , { - 3 , 0 , - 2 } , { 5 , 1 , 2 } } ; countRows ( mat ) ; } }"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | Pelaksanaan Java berasaskan penyortiran untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Susun array; Selepas menyusun, periksa sama ada elemen semasa sama seperti sebelumnya atau satu lagi. ; Program pemacu untuk menguji fungsi di atas", "code": "import java . util . * ; class GFG { static boolean areElementsContiguous ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] > 1 ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | Pelaksanaan Java untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Cari elemen maksimum dan minimum. ; Harus ada sekurang -kurangnya elemen M di Aaray untuk menjadikannya bersebelahan. ; Buat array yang dikunjungi dan mulakan palsu. ; Tandakan elemen sebagai benar. ; Jika mana -mana elemen tidak ditandakan, semua elemen tidak bersebelahan. ; Program Pemandu", "code": "import java . util . * ; class GFG { static boolean areElementsContiguous ( int arr [ ] , int n ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | Pelaksanaan Java untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Menyimpan unsur -unsur 'arr []' dalam jadual hash 'kami'; Sebagai Arr [0] hadir dalam 'kami'; Bermula dengan elemen yang lebih kecil sebelumnya ARR [0]; Jika 'curr _ ele' hadir dalam 'kami'; kiraan kenaikan; mengemas kini 'curr_ele'; bermula dengan elemen yang lebih besar dari arr [0]; jika 'curr _ ele' hadir dalam 'us'; kiraan kenaikan; kemas kini 'curr_ele \"; Pulangan benar jika array mengandungi satu set bilangan bulat bersebelahan lain kembali palsu; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static Boolean areElementsContiguous ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) us . add ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele ++ ; } return ( count == ( us . size ( ) ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Subarray terpanjang tidak mempunyai lebih banyak daripada elemen yang berbeza | Program Java untuk mencari subarray terpanjang dengan K atau kurang elemen yang berbeza. ; berfungsi untuk mencetak pelbagai sub - paling lama; Tandakan elemen yang dikunjungi; Jika ia dikunjungi kali pertama, maka tingkatkan kaunter unsur -unsur yang berbeza dengan 1; Apabila kaunter unsur -unsur yang berbeza meningkat dari k, kemudian mengurangkannya kepada k; Dari sebelah kiri, mengurangkan bilangan masa lawatan; Sekiranya elemen masa yang dikurangkan tidak terdapat dalam segmen selanjutnya maka mengurangkan kiraan unsur -unsur yang berbeza; meningkatkan tanda subsegment; Semak panjang sub -segmen terpanjang apabila lebih besar kemudian sebelum ini kemudian tukarnya; Cetak segmen sub - terpanjang; Kod pemacu", "code": "import java . util . * ; class GFG { static void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + \" ▁ \" ) ; } public static void main ( String args [ ] ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = a . length ; int k = 3 ; longest ( a , n , k ) ; } }"}
{"text": "Periksa sama ada Kira K dalam mana -mana Titik | Pelaksanaan Java pendekatan; Fungsi yang mengembalikan benar jika mana -mana segmen K bertindih pada bila -bila masa; Vektor untuk menyimpan titik permulaan dan titik akhir; Titik permulaan ditandakan dengan - 1 dan titik berakhir dengan + 1; Susun vektor dengan elemen pertama; Komparator untuk menyusun vektor pasangan; Tumpukan untuk menyimpan tumpang tindih; Dapatkan elemen semasa; Jika ia adalah titik permulaan; Tolaknya dalam timbunan; Ia adalah titik akhir; Pop elemen dari timbunan; Jika lebih daripada K -ranges bertindih; Kod pemacu", "code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Stack ; class GFG { static class Pair { int first , second ; public Pair ( int first , int second ) { this . first = first ; this . second = second ; } } static boolean kOverlap ( ArrayList < Pair > pairs , int k ) { ArrayList < Pair > vec = new ArrayList < > ( ) ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) { vec . add ( new Pair ( pairs . get ( i ) . first , - 1 ) ) ; vec . add ( new Pair ( pairs . get ( i ) . second , + 1 ) ) ; } Collections . sort ( vec , new Comparator < Pair > ( ) { public int compare ( Pair a , Pair b ) { if ( a . first != b . first ) return a . first - b . first ; return ( a . second - b . second ) ; } } ) ; Stack < Pair > st = new Stack < > ( ) ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { Pair cur = vec . get ( i ) ; if ( cur . second == - 1 ) { st . push ( cur ) ; } else { st . pop ( ) ; } if ( st . size ( ) >= k ) { return true ; } } return false ; } public static void main ( String [ ] args ) { ArrayList < Pair > pairs = new ArrayList < > ( ) ; pairs . add ( new Pair ( 1 , 3 ) ) ; pairs . add ( new Pair ( 2 , 4 ) ) ; pairs . add ( new Pair ( 3 , 5 ) ) ; pairs . add ( new Pair ( 7 , 10 ) ) ; int n = pairs . size ( ) , k = 3 ; if ( kOverlap ( pairs , k ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Cari julat terkecil yang mengandungi elemen dari senarai k | Program Java untuk mengetahui pelbagai terkecil yang merangkumi unsur -unsur dari setiap senarai disusun yang diberikan. ; array untuk menyimpan indeks semasa senarai i; Fungsi ini mengambil senarai yang disusun dalam bentuk array 2D sebagai hujah. Ia mendapati pelbagai terkecil yang merangkumi unsur -unsur dari setiap senarai K. ; memulakan ke 0 indeks; ; untuk mengekalkan indeks senarai yang mengandungi elemen minimum; melangkah ke atas semua senarai; Jika setiap elemen senarai [i] dilalui maka memecahkan gelung; Cari nilai minimum di antara semua elemen senarai yang menunjuk oleh array PTR []; mengemas kini indeks senarai; Cari nilai maksimum di antara semua elemen senarai yang menunjuk oleh array PTR []; Sekiranya ada senarai ekzos, kami tidak akan mendapat jawapan yang lebih baik, jadi pecahkan gelung sementara; mengemas kini Minrange; Program pemacu untuk menguji fungsi di atas", "code": "class GFG { static final int N = 5 ; static int ptr [ ] = new int [ 501 ] ; static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) { int i , minval , maxval , minrange , minel = 0 , maxel = 0 , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; } minrange = Integer . MAX_VALUE ; while ( true ) { minind = - 1 ; minval = Integer . MAX_VALUE ; maxval = Integer . MIN_VALUE ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag == 1 ) { break ; } ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } System . out . printf ( \"The smallest range is [%d, %d]NEW_LINE\", minel, maxel); } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 4 , 7 , 9 , 12 , 15 } , { 0 , 8 , 10 , 14 , 20 } , { 6 , 12 , 16 , 30 , 50 } } ; int k = arr . length ; findSmallestRange ( arr , N , k ) ; } }"}
{"text": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | Program Java untuk mencari yang terbesar sedemikian rupa sehingga D = A + B + C; berfungsi untuk mencari d terbesar; Susun array dalam urutan menaik; melangkah dari belakang untuk mencari D terbesar yang diperlukan; Oleh kerana semua empat A, B, C, D harus berbeza; Jika kombinasi semasa J, K, L dalam set adalah sama dengan S [i] mengembalikan nilai ini kerana ini akan menjadi d terbesar kerana kita melelehkan dalam urutan menurun; Kod pemacu", "code": "import java . io . * ; import java . util . Arrays ; class GFG { static int findLargestd ( int [ ] S , int n ) { boolean found = false ; Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Integer . MAX_VALUE ; return - 1 ; } public static void main ( String [ ] args ) { int [ ] S = new int [ ] { 2 , 3 , 5 , 7 , 12 } ; int n = S . length ; int ans = findLargestd ( S , n ) ; if ( ans == Integer . MAX_VALUE ) System . out . println ( \" No ▁ Solution \" ) ; else System . out . println ( \" Largest ▁ d ▁ such ▁ that ▁ \" + \" a ▁ + ▁ \" + \" b ▁ + ▁ c ▁ = ▁ d ▁ is ▁ \" + ans ) ; } }"}
{"text": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | Program Java berasaskan hashing untuk mencari D terbesar sedemikian rupa sehingga A + B + C = D. ; Untuk menyimpan dan mengambil indeks pasangan i & j; Fungsi ini menemui empat elemen dengan jumlah x yang diberikan; Jumlah wang (a + b) semua pasangan (a, b) dalam jadual hash; Melintasi semua pasangan dan mencari (D - C) hadir dalam jadual hash; Jika d - c ada dalam jadual hash ,; Memastikan semua elemen adalah elemen array yang berbeza dan elemen tidak dianggap lebih dari sekali. ; Kod pemacu", "code": "import java . util . HashMap ; import java . lang . Math ; class Indexes { int i , j ; Indexes ( int i , int j ) { this . i = i ; this . j = j ; } int getI ( ) { return i ; } int getJ ( ) { return j ; } } class GFG { static int findFourElements ( int [ ] arr , int n ) { HashMap < Integer , Indexes > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map . put ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } int d = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( map . containsKey ( abs_diff ) ) { Indexes indexes = map . get ( abs_diff ) ; if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = arr . length ; int res = findFourElements ( arr , n ) ; if ( res == Integer . MIN_VALUE ) System . out . println ( \" No ▁ Solution \" ) ; else System . out . println ( res ) ; } }"}
{"text": "Memaksimumkan kiraan elemen yang boleh dipilih mempunyai perbezaan minimum antara jumlah dan k | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mengira bilangan maksimum elemen yang boleh dipilih; Menyusun array; Melintasi array; Tambah elemen semasa ke jumlah; Jika jumlah melebihi k; Kiraan kenaikan; Mengembalikan kiraan; Kod pemacu; Panggilan fungsi", "code": "import java . util . Arrays ; public class GFG { static int CountMaximum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = 4 ; int k = 50 ; System . out . println ( CountMaximum ( arr , n , k ) ) ; } }"}
{"text": "Program untuk Putaran Array | Program Java untuk memutar array oleh unsur D; Berfungsi ke kiri berputar arr [] saiz n oleh 1; Berfungsi ke kiri berputar arr [] saiz n oleh d; fungsi utiliti untuk mencetak array; Program pemacu untuk menguji fungsi di atas", "code": "class RotateArray { void leftRotatebyOne ( int arr [ ] , int n ) { int i , temp ; temp = arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } void leftRotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } public static void main ( String [ ] args ) { RotateArray rotate = new RotateArray ( ) ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; rotate . leftRotate ( arr , 2 , 7 ) ; rotate . printArray ( arr , 7 ) ; } }"}
{"text": "Susun array dalam julat indeks yang diberikan | Program Java untuk menyusun array dalam julat indeks tertentu; Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Arahan sementara; Susun array sementara; Mengubah suai array asal dengan elemen array sementara; Cetak array yang diubah suai; Kod pemacu; panjang array", "code": "import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ; int [ ] temp = new int [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } Arrays . sort ( temp ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + \" ▁ \" ) ; } } public static void main ( String args [ ] ) { int [ ] arr = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = arr . length ; partSort ( arr , N , a , b ) ; } }"}
{"text": "Penyusun baris matriks dalam urutan menurun diikuti oleh lajur dalam urutan menaik | Pelaksanaan Java untuk menyusun baris matriks dalam urutan menurun diikuti dengan menyusun lajur dalam urutan menaik; Fungsi untuk menyusun setiap baris matriks mengikut perintah yang ditentukan oleh turun. ; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris tikar [] [] dalam urutan menurun; dapatkan transpose tikar [] []; Sekali lagi menyusun baris Mat [] [] dalam urutan menaik. ; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu", "code": "import java . util . * ; class GFG { static int MAX_SIZE = 10 ; static void sortByRow ( int [ ] [ ] mat , int n , boolean descending ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( descending == true ) { int t = i ; for ( int p = 0 ; p < n ; p ++ ) { for ( int j = p + 1 ; j < n ; j ++ ) { if ( mat [ t ] [ p ] < mat [ t ] [ j ] ) { temp = mat [ t ] [ p ] ; mat [ t ] [ p ] = mat [ t ] [ j ] ; mat [ t ] [ j ] = temp ; } } } } else Arrays . sort ( mat [ i ] ) ; } } static void transpose ( int mat [ ] [ ] , int n ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } } } static void sortMatRowAndColWise ( int mat [ ] [ ] , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; } static void printMat ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + \" ▁ \" ) ; System . out . println ( ) ; } } public static void main ( String args [ ] ) { int n = 3 ; int [ ] [ ] mat = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; System . out . println ( \" Original ▁ Matrix : \" ) ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; System . out . println ( \" \" ▁ + ▁ \" Matrix After Sorting : \"); printMat ( mat , n ) ; } }"}
{"text": "Pindahkan semua sifar ke hujung array | Program Java untuk menolak sifar ke belakang array; Fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang ditemui bukan sifar, kemudian gantikan elemen pada indeks 'kiraan' dengan elemen ini; Di sini kiraan adalah; Tambahan sekarang semua elemen bukan sifar telah beralih ke depan dan 'kiraan' ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; Fungsi pemacu untuk memeriksa fungsi di atas", "code": "import java . io . * ; class PushZero { static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = arr . length ; pushZerosToEnd ( arr , n ) ; System . out . println ( \" Array ▁ after ▁ pushing ▁ zeros ▁ to ▁ the ▁ back : ▁ \" ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } }"}
{"text": "Pindahkan semua sifar ke hujung array | Set | Pelaksanaan Java untuk memindahkan semua sifar pada akhir array; berfungsi untuk memindahkan semua sifar pada akhir array; Kiraan unsur bukan sifar; Melintasi array. Jika arr [i] bukan sifar, maka swap elemen pada indeks 'kiraan' dengan elemen pada indeks 'i'; berfungsi untuk mencetak elemen array; Program Pemandu untuk diuji di atas", "code": "import java . io . * ; class GFG { static void moveZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] != 0 ) ) { temp = arr [ count ] ; arr [ count ] = arr [ i ] ; arr [ i ] = temp ; count = count + 1 ; } } } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = arr . length ; System . out . print ( \" Original ▁ array : ▁ \" ) ; printArray ( arr , n ) ; moveZerosToEnd ( arr , n ) ; System . out . print ( \" Modified array : \"); printArray ( arr , n ) ; } }"}
{"text": "Gandakan elemen pertama dan gerakkan sifar ke akhir | Pelaksanaan Java untuk menyusun semula elemen array selepas pengubahsuaian; fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang ditemui bukan sifar, kemudian gantikan elemen pada indeks 'kiraan' dengan elemen ini; Di sini kiraan ditingkatkan; Sekarang semua elemen bukan sifar telah beralih ke depan dan 'kiraan' ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; berfungsi untuk menyusun semula elemen array selepas pengubahsuaian; jika 'arr []' mengandungi satu elemen sahaja; melintasi array; Jika benar, lakukan pengubahsuaian yang diperlukan; nilai indeks semasa dua kali; Letakkan 0 dalam indeks seterusnya; kenaikan sebanyak 1 untuk memindahkan dua indeks di hadapan semasa lelaran gelung; tolak semua sifar pada akhir 'arr []'; berfungsi untuk mencetak elemen array; Program Pemandu untuk diuji di atas", "code": "class GFG { static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } static void modifyAndRearrangeArr ( int arr [ ] , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( arr [ i ] != 0 ) && ( arr [ i ] == arr [ i + 1 ] ) ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZerosToEnd ( arr , n ) ; } static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 } ; int n = arr . length ; System . out . print ( \" Original ▁ array : ▁ \" ) ; printArray ( arr , n ) ; modifyAndRearrangeArr ( arr , n ) ; System . out . print ( \" Modified ▁ array : ▁ \" ) ; printArray ( arr , n ) ; } }"}
{"text": "Gandakan elemen pertama dan gerakkan sifar ke akhir |  ; Berfungsi untuk menukar dua elemen array; beralih semua sifar ke sebelah kiri array; Mengekalkan indeks terakhir dengan nilai positif; Jika elemen bukan sifar; Swap Indeks Semasa, dengan LastSeen Non - Zero; Elemen seterusnya akan terakhir dilihat bukan - sifar", "code": "class GFG { public static void swap ( int [ ] A , int i , int j ) { int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } static void shiftAllZeroToLeft ( int array [ ] , int n ) { int lastSeenNonZero = 0 ; for ( int index = 0 ; index < n ; index ++ ) { if ( array [ index ] != 0 ) { swap ( array , array [ index ] , array [ lastSeenNonZero ] ) ; lastSeenNonZero ++ ; } } } }"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Program Java untuk menyusun semula nombor positif dan negatif dalam array; Fungsi utiliti untuk mencetak pelbagai saiz n; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Jika elemen semasa positif tidak melakukan apa -apa; Jika elemen semasa adalah negatif, pergeseran elemen positif ARR [0. i - 1], ke satu kedudukan di sebelah kanan mereka; Letakkan elemen negatif pada kedudukan yang betul; Program Pemandu", "code": "import java . io . * ; class GFG { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; System . out . println ( ) ; } static void RearrangePosNeg ( int arr [ ] , int n ) { int key , j ; for ( int i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; if ( key > 0 ) continue ; j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int n = arr . length ; RearrangePosNeg ( arr , n ) ; printArray ( arr , n ) ; } }"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Program Java untuk menyusun semula nombor positif dan negatif dalam array; Berfungsi untuk mencetak array; Fungsi untuk membalikkan array. Arahan boleh diterbalikkan dalam masa O (n) dan O (1) ruang. ; Menggabungkan dua subarray ARR []. Subarray pertama adalah arr [l. . m] subarray kedua adalah arr [m + 1. r]; Indeks awal Subarray 1 ST; Indeks awal IIND; arr [i. . M] adalah positif; arr [j. . r] adalah bahagian positif yang positif dari sub - array kiri (arr [i. m]); Bahagian negatif terbalik sub - array kanan (arr [m + 1 ... j - 1]); ARR terbalik [i. . J - 1]; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Kod pemacu", "code": "class GFG { static void printArray ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( A [ i ] + \" ▁ \" ) ; System . out . println ( \" \" ) ; ; } static void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { arr = swap ( arr , l , r ) ; reverse ( arr , ++ l , -- r ) ; } } static void merge ( int arr [ ] , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; } static void RearrangePosNeg ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int arr_size = arr . length ; RearrangePosNeg ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; } }"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Pelaksanaan Java pendekatan di atas; Gelung sehingga arr [i] <0 dan masih di dalam array; Gelung sehingga arr [j]> 0 dan masih di dalam array; jika saya kurang daripada j; Kod pemacu", "code": "import java . io . * ; class GFG { public static void RearrangePosNeg ( int arr [ ] ) { int i = 0 ; int j = arr . length - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < arr . length ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } } public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; RearrangePosNeg ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } }"}
{"text": "Cari pemain untuk dapat menggantikan elemen terakhir yang boleh digantikan oleh pembahagi | Program Java untuk pendekatan di atas; Fungsi untuk mencari pemenang permainan yang dimainkan berdasarkan keadaan yang diberikan; Kemenangan jika saiz array adalah ganjil; Jika tidak, B menang; Kod pemacu; Arahan input; Saiz array", "code": "class GFG { static void winner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { System . out . print ( \" A \" ) ; } else { System . out . print ( \" B \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 24 , 45 , 45 , 24 } ; int N = arr . length ; winner ( arr , N ) ; } }"}
{"text": "Pertanyaan untuk mengira jumlah elemen array yang hadir pada setiap indeks yth bermula dari indeks x | Program Java untuk pendekatan di atas; Fungsi kepada jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua nilai yang mungkin x dan y, di mana y kurang daripada atau sama dengan matematik. sqrt (n). ; Melangkah ke atas semua kemungkinan nilai x; Precompute untuk semua nilai yang mungkin dari ungkapan seperti y <= matematik. sqrt (n); Jika saya + j kurang daripada n; Kemas kini DP [i] [J]; Kemas kini DP [i] [J]; Fungsi untuk mencari jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua pertanyaan; dp [x] [y]: menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array pertanyaan, q [] []; Jika y kurang daripada atau sama dengan matematik. sqrt (n); Menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array, arr []; Kemas kini Jumlah; Kemas kini x; Kod pemacu", "code": "import java . util . * ; class GFG { static int sz = 20 ; static int sqr = ( int ) ( Math . sqrt ( sz ) ) + 1 ; static void precomputeExpressionForAllVal ( int arr [ ] , int N , int dp [ ] [ ] ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = 1 ; j <= Math . sqrt ( N ) ; j ++ ) { if ( i + j < N ) { dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] ; } else { dp [ i ] [ j ] = arr [ i ] ; } } } } static void querySum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) { int [ ] [ ] dp = new int [ sz ] [ sqr ] ; precomputeExpressionForAllVal ( arr , N , dp ) ; for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; if ( y <= Math . sqrt ( N ) ) { System . out . print ( dp [ x ] [ y ] + \" ▁ \" ) ; continue ; } int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } System . out . print ( sum + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ ] = { { 2 , 1 } , { 3 , 2 } } ; int N = arr . length ; int M = Q . length ; querySum ( arr , N , Q , M ) ; } }"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program Java untuk mencari semua elemen dalam pelbagai yang mempunyai sekurang -kurangnya dua elemen yang lebih besar sendiri. ; Pilih elemen satu demi satu dan hitung elemen yang lebih besar. Jika kiraan lebih daripada 2, cetak elemen itu. ; Kod pemacu", "code": "import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program Java berasaskan penyortiran untuk mencari semua elemen dalam pelbagai yang mempunyai dua elemen yang lebih besar sendiri. ; Kod pemacu", "code": "import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program Java untuk mencari semua elemen dalam pelbagai yang mempunyai dua elemen yang lebih besar sendiri. ; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Kod pemacu", "code": "import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }"}
{"text": "Kurangkan kiraan kenaikan setiap elemen subarray yang diperlukan untuk membuat array bukan | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum operasi yang diperlukan untuk membuat array tidak meningkat; Menyimpan kiraan operasi yang diperlukan; Jika arr [i]> arr [i + 1], tiada kenaikan diperlukan. Jika tidak, tambahkan perbezaannya kepada jawapannya; Mengembalikan hasil res; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { public static int getMinOps ( int [ ] arr ) { int res = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { res += Math . max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 1 , 2 } ; System . out . println ( getMinOps ( arr ) ) ; } }"}
{"text": "Cari nombor yang paling kecil |  ; Fungsi yang mengembalikan unsur -unsur terkecil yang hilang dalam array yang disusun. ; Separuh kiri mempunyai semua elemen dari 0 hingga pertengahan; Program pemacu untuk menguji fungsi di atas", "code": "class SmallestMissing { int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } public static void main ( String [ ] args ) { SmallestMissing small = new SmallestMissing ( ) ; int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = arr . length ; System . out . println ( \" First ▁ Missing ▁ element ▁ is ▁ : ▁ \" + small . findFirstMissing ( arr , 0 , n - 1 ) ) ; } }"}
{"text": "Cari nombor yang paling kecil | Program Java untuk pendekatan di atas; Program untuk mencari elemen yang hilang; * Perlawanan indeks dengan nilai pada indeks itu, bermakna elemen yang hilang tidak dapat sampai ke titik itu; Program untuk mencari yang paling kecil hilang dalam pelbagai disusun; Semak jika 0 hilang dalam array; Cek adalah semua nombor 0 hingga n - 1 adalah prsent dalam array; Program pemacu untuk menguji fungsi di atas; Panggilan fungsi", "code": "import java . io . * ; class GFG { int findFirstMissing ( int [ ] arr , int start , int end , int first ) { if ( start < end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; } int findSmallestMissinginSortedArray ( int [ ] arr ) { if ( arr [ 0 ] != 0 ) return 0 ; if ( arr [ arr . length - 1 ] == arr . length - 1 ) return arr . length ; int first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . length - 1 , first ) ; } public static void main ( String [ ] args ) { GFG small = new GFG ( ) ; int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 7 } ; int n = arr . length ; System . out . println ( \" First ▁ Missing ▁ element ▁ is ▁ : ▁ \" + small . findSmallestMissinginSortedArray ( arr ) ) ; } }"}
{"text": "Jumlah maksimum supaya tidak ada dua elemen bersebelahan |  ; Berfungsi untuk mengembalikan jumlah maksimum supaya tidak ada dua elemen bersebelahan; Max semasa tidak termasuk i; Max semasa termasuk i; kembali max incl and excl; Program pemacu untuk menguji fungsi di atas", "code": "class MaximumSum { int FindMaxSum ( int arr [ ] , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } public static void main ( String [ ] args ) { MaximumSum sum = new MaximumSum ( ) ; int arr [ ] = new int [ ] { 5 , 5 , 10 , 100 , 10 , 5 } ; System . out . println ( sum . FindMaxSum ( arr , arr . length ) ) ; } }"}
{"text": "Langkah -langkah minimum untuk menukar semua laluan kiri ke bawah ke bawah dalam matriks sebagai palindrome | Tetapkan 2 | Program Java untuk pendekatan di atas; Fungsi untuk mengira bilangan perubahan minimum; Jarak elemen dari (0, 0) akan saya julat [0, n + m - 2]; Frekuensi kedai [0, 9] pada jarak I; Memulakan frekuensi sebagai 0; Mengira frekuensi [0, 9]; Kekerapan Kekerapan Matriks nilai [i] [j] pada jarak i + j; Cari nilai dengan kekerapan maksimum dan hitung jumlah sel pada jarak i dari hujung depan dan belakang belakang; Tukar semua nilai ke nilai dengan kekerapan maksimum; Kembalikan jawapannya; Kod pemacu; Diberikan matriks; Panggilan fungsi", "code": "import java . util . * ; class GFG { static final int N = 7 ; static int countChanges ( int matrix [ ] [ ] , int n , int m ) { int dist = n + m - 1 ; int [ ] [ ] freq = new int [ dist ] [ 10 ] ; for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { maximum = Math . max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 } , { 3 , 5 } } ; System . out . print ( countChanges ( mat , 2 , 2 ) ) ; } }"}
{"text": "Jadual jarang | Program Java untuk melakukan pelbagai pertanyaan minimum menggunakan jadual jarang; Lookup [i] [j] akan menyimpan nilai minimum dalam arr [i. . j]. Saiz jadual cari yang ideal tidak boleh diperbaiki dan harus ditentukan menggunakan n log n. Ia tetap berterusan untuk memastikan kod mudah. ; Mengisi carian array carian [] [] dengan cara bawah. ; Memulakan m untuk selang dengan panjang 1; Mengira nilai dari selang yang lebih kecil hingga lebih besar; Kirakan nilai minimum untuk semua selang dengan saiz 2 ^ j; Untuk arr [2] [10], kami membandingkan arr [lookup [0] [7]] dan arr [lookup [3] [10]]; Mengembalikan minimum arr [l. . R]; Cari kuasa tertinggi 2 yang lebih kecil daripada atau sama dengan mengira unsur -unsur dalam julat yang diberikan. Untuk [2, 10], j = 3; Kirakan minimum unsur -unsur terakhir dengan unsur -unsur pertama dalam julat. Untuk [2, 10], kami membandingkan arr [lookup [0] [3]] dan arr [lookup [3] [3]] ,; Program Pemandu", "code": "import java . io . * ; class GFG { static int MAX = 500 ; static int [ ] [ ] lookup = new int [ MAX ] [ MAX ] ; static void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } } static int query ( int L , int R ) { int j = ( int ) Math . log ( R - L + 1 ) ; if ( lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] ) return lookup [ L ] [ j ] ; else return lookup [ R - ( 1 << j ) + 1 ] [ j ] ; } public static void main ( String [ ] args ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = a . length ; buildSparseTable ( a , n ) ; System . out . println ( query ( 0 , 4 ) ) ; System . out . println ( query ( 4 , 7 ) ) ; System . out . println ( query ( 7 , 8 ) ) ; } }"}
{"text": "Jadual jarang | Program Java untuk melakukan pelbagai pertanyaan minimum menggunakan jadual jarang; Lookup [i] [j] akan menyimpan GCD ARR [i. . j]. Saiz jadual cari yang ideal tidak boleh diperbaiki dan harus ditentukan menggunakan n log n. Ia tetap berterusan untuk memastikan kod mudah. ; Ia membina meja jarang. ; GCD elemen tunggal adalah elemen itu sendiri; Membina meja jarang; Mengembalikan GCD ARR [l. . R]; Cari kuasa tertinggi 2 yang lebih kecil daripada atau sama dengan mengira unsur -unsur dalam julat yang diberikan. Untuk [2, 10], j = 3; Kirakan GCD unsur -unsur terakhir dengan unsur -unsur pertama dalam julat. Untuk [2, 10], kita dapati GCD ARR [lookup [0] [3]] dan arr [lookup [3] [3]] ,; Kod pemacu", "code": "import java . util . * ; class GFG { static final int MAX = 500 ; static int [ ] [ ] table = new int [ MAX ] [ MAX ] ; static void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) table [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; j <= n ; j ++ ) for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) table [ i ] [ j ] = __gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; } static int query ( int L , int R ) { int j = ( int ) Math . log ( R - L + 1 ) ; return __gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = a . length ; buildSparseTable ( a , n ) ; System . out . print ( query ( 0 , 2 ) + \"NEW_LINE\"); System . out . print ( query ( 1 , 3 ) + \"NEW_LINE\"); System . out . print ( query ( 4 , 5 ) + \"NEW_LINE\"); } }"}
{"text": "Arahan terkecil lexicographically selepas di | Program Java untuk mencari nilai minimum lexicographically selepas k swap. ; Modifies arr [0 .. n - 1] kepada lexicographically terkecil dengan s swap. ; Tetapkan kedudukan di mana kita mahu meletakkan integer terkecil; Jika kita melebihi swap maksimum kemudian menamatkan gelung; Cari nilai minimum dari i + 1 hingga max k atau n; Tukar unsur -unsur dari kedudukan minimum yang kami dapati hingga sekarang ke indeks I; Tetapkan nilai akhir selepas menukar elemen POS - I; Kaedah pemacu; Fungsi panggilan; Cetak Array Akhir", "code": "class GFG { static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 6 , 9 , 2 , 1 } ; int n = arr . length ; int k = 3 ; minimizeWithKSwaps ( arr , n , k ) ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } }"}
{"text": "Cari subarray purata maksimum K panjang | Program Java untuk mencari subarray purata maksimum panjang yang diberikan. ; Pulangan permulaan indeks subarray purata maksimum panjang 'k'; Semak jika 'k' sah; Buat dan isi array untuk menyimpan jumlah kumulatif. csum [i] menyimpan jumlah arr [0] ke arr [i]; Memulakan max_sm sebagai jumlah subarray pertama; Cari jumlah subarray lain dan kemas kini max_sum jika diperlukan. ; Indeks permulaan kembali; Kod pemacu", "code": "import java . io . * ; class GFG { static int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; } static public void main ( String [ ] args ) { int [ ] arr = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . length ; System . out . println ( \" The ▁ maximum ▁ \" + \" average ▁ subarray ▁ of ▁ length ▁ \" + k + \" ▁ begins ▁ at ▁ index ▁ \" + findMaxAverage ( arr , n , k ) ) ; } }"}
{"text": "Cari subarray purata maksimum K panjang | Program Java untuk mencari subarray purata maksimum panjang yang diberikan. ; Pulangan permulaan indeks subarray purata maksimum panjang 'k'; Semak jika 'k' sah; Mengira jumlah elemen 'k' pertama; Mengira jumlah subarray yang tinggal; Indeks permulaan kembali; Program Pemandu", "code": "import java . io . * ; class GFG { static int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . length ; System . out . println ( \" The ▁ maximum ▁ average \" + \" ▁ subarray ▁ of ▁ length ▁ \" + k + \" ▁ begins ▁ at ▁ index ▁ \" + findMaxAverage ( arr , n , k ) ) ; } }"}
{"text": "Skor minimum mungkin untuk pemain dengan memilih satu atau dua elemen array berturut -turut dari array binari yang diberikan | Program Java untuk pendekatan di atas; Menyimpan skor minimum untuk setiap negeri sebagai peta <pasangan <pos, myturn>, ans>; Berfungsi untuk mencari skor minimum selepas memilih elemen dari array; Mengembalikan keadaan yang disimpan; Kes asas; Pemain A 'S giliran; Cari skor minimum; Simpan keadaan semasa; Mengembalikan hasilnya; Pemain B 's giliran; Cari skor minimum; Simpan keadaan semasa; Mengembalikan hasilnya; Fungsi yang mendapati penalti minimum selepas memilih elemen dari array binari yang diberikan; Memulakan kedudukan memilih elemen dari array; 0 menandakan pemain A Turn 1 menandakan pemain B giliran; Panggilan fungsi; Berfungsi untuk mencetak jawapan; Penalti minimum; Hitung jumlah semua elemen ARR; Cetak skor minimum; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static class R { int x , y ; public R ( int x , int y ) { this . x = x ; this . y = y ; } } static HashMap < R , Integer > m = new HashMap < > ( ) ; public static int findMinimum ( int [ ] arr , int N , int pos , int turn ) { R x = new R ( pos , turn ) ; if ( m . containsKey ( x ) ) { return m . get ( x ) ; } if ( pos >= N - 1 ) { return 0 ; } if ( turn == 0 ) { int ans = Math . min ( findMinimum ( arr , N , pos + 1 , 1 ) + arr [ pos ] , findMinimum ( arr , N , pos + 2 , 1 ) + arr [ pos ] + arr [ pos + 1 ] ) ; R v = new R ( pos , turn ) ; m . put ( v , ans ) ; return ans ; } if ( turn != 0 ) { int ans = Math . min ( findMinimum ( arr , N , pos + 1 , 0 ) , findMinimum ( arr , N , pos + 2 , 0 ) ) ; R v = new R ( pos , turn ) ; m . put ( v , ans ) ; return ans ; } return 0 ; } public static int countPenality ( int [ ] arr , int N ) { int pos = 0 ; int turn = 0 ; return findMinimum ( arr , N , pos , turn ) + 1 ; } public static void printAnswer ( int [ ] arr , int N ) { int a = countPenality ( arr , N ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } System . out . println ( a ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 } ; int N = 8 ; printAnswer ( arr , N ) ; } }"}
{"text": "Jumlah nombor utama dalam julat [l, r] dari array yang diberikan untuk pertanyaan q | Program Java untuk pendekatan di atas; Berfungsi untuk mencari nombor perdana; Buat Boolean Array Prime [] dan memulakan semua penyertaannya sebagai benar nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana; Semak jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat nombor IT yang berganda p dan kurang daripada p ^ 2 telah ditandakan; Berfungsi untuk mendapatkan indeks pertengahan dari indeks sudut; Berfungsi untuk mendapatkan jumlah nilai dalam julat array yang diberikan; Jika segmen nod ini adalah sebahagian daripada julat yang diberikan, maka kembalikan jumlah segmen; Jika segmen nod ini berada di luar julat yang diberikan; Jika sebahagian daripada segmen ini bertindih dengan julat yang diberikan; Fungsi untuk mengemas kini nod yang mempunyai indeks yang diberikan dalam julatnya; Jika indeks input terletak di luar julat segmen ini; Jika indeks input berada dalam julat nod ini, maka kemas kini nilai nod dan anak -anaknya; Berfungsi untuk mengemas kini nilai dalam array input dan pokok segmen; Semak indeks input yang salah; Dapatkan perbezaan antara nilai baru dan nilai lama; Kemas kini nilai dalam array; Kemas kini nilai nod dalam pokok segmen hanya jika sama ada nilai sebelumnya atau nilai baru atau kedua -duanya adalah perdana; Jika hanya nilai baru adalah perdana; Jika hanya nilai baru adalah perdana; Jika kedua -duanya adalah perdana; Pulangan Jumlah Elemen dalam Julat dari Indeks QS (Permulaan Permintaan) ke QE (End Query). Ia terutamanya menggunakan getSumutil (); Semak nilai input yang salah; Fungsi yang membina pokok segmen; Jika terdapat satu elemen dalam array, simpannya dalam nod semasa pokok segmen dan kembali; Hanya tambah unsur -unsur dalam pokok segmen yang utama; Sekiranya terdapat lebih daripada satu elemen, maka berulang untuk subtrees kiri dan kanan dan simpan jumlah nilai dalam nod ini; Fungsi untuk membina pokok segmen dari array yang diberikan; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan ST; Mengembalikan pokok segmen yang dibina; Kod pemacu; Panggilan fungsi; Membina pokok segmen dari array yang diberikan; Cetak jumlah nilai dalam array dari indeks 1 hingga 3; Kemas kini: Tetapkan ARR [1] = 10 dan kemas kini nod pokok segmen yang sepadan; Cari jumlah selepas nilai dikemas kini", "code": "import java . io . * ; import java . util . * ; class GFG { static int MAX = 1000001 ; static int prime [ ] = new int [ MAX ] ; static void SieveOfEratosthenes ( ) { Arrays . fill ( prime , 1 ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i <= MAX - 1 ; i += p ) prime [ i ] = 0 ; } } } static int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } static int getSumUtil ( int [ ] st , int ss , int se , int qs , int qe , int si ) { if ( qs <= ss && qe >= se ) return st [ si ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; } static void updateValueUtil ( int [ ] st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } } static void updateValue ( int arr [ ] , int [ ] st , int n , int i , int new_val ) { if ( i < 0 i > n - 1 ) { System . out . print ( \" - 1\" ) ; return ; } int diff = new_val - arr [ i ] ; int prev_val = arr [ i ] ; arr [ i ] = new_val ; if ( ( prime [ new_val ] prime [ prev_val ] ) != 0 ) { if ( prime [ prev_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ; else if ( prime [ new_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ; else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } } static int getSum ( int [ ] st , int n , int qs , int qe ) { if ( qs < 0 qe > n - 1 qs > qe ) { System . out . println ( \" - 1\" ) ; return - 1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; } static int constructSTUtil ( int arr [ ] , int ss , int se , int [ ] st , int si ) { if ( ss == se ) { if ( prime [ arr [ ss ] ] != 0 ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; } static int [ ] constructST ( int arr [ ] , int n ) { int x = ( int ) ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int max_size = 2 * ( int ) Math . pow ( 2 , x ) - 1 ; int [ ] st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 , 11 } ; int n = arr . length ; int Q [ ] [ ] = { { 1 , 1 , 3 } , { 2 , 1 , 10 } , { 1 , 1 , 3 } } ; SieveOfEratosthenes ( ) ; int [ ] st = constructST ( arr , n ) ; System . out . println ( getSum ( st , n , 1 , 3 ) ) ; updateValue ( arr , st , n , 1 , 10 ) ; System . out . println ( getSum ( st , n , 1 , 3 ) ) ; } }"}
{"text": "Kira bilangan cara untuk membina rentetan sasaran | Program Java untuk mengira bilangan cara untuk membina rentetan sasaran; Kes asas; Jika subproblem semasa telah diselesaikan, gunakan nilai; Cari melalui semua yang ditunjukkan di mana watak semasa berlaku. Untuk setiap indeks yang lebih besar daripada sebelumnya, ambil indeks dan bergerak ke kedudukan seterusnya, dan tambahkan jawapannya. ; Simpan dan kembalikan penyelesaian untuk subproblem ini; PREPROCESS THE RINGS DENGAN MENYEDIAKAN UNTUK SETIAP KARAKTER SETIAP RENTING, INDEKS KELUARGA MEREKA KAMI AKAN MENGGUNAKAN SENARAI BERHUBUNGAN UNTUK SEMUA SETIAP HANYA SAHAJA INDEKS DALAM RENCEN DENGAN Watak dipilih; Kami menyimpan J + 1 kerana indeks yang dipilih awal dalam langkah rekursif akan NE 0. Ini hanya untuk kemudahan pelaksanaan; Inisiasi jadual DP. - 1 mewakili bahawa subproblem tidak diselesaikan; Kod pemacu", "code": "import java . util . * ; class GFG { static int mod = 1000000007 ; static int [ ] [ ] dp = new int [ 1000 ] [ 1000 ] ; static int calculate ( int pos , int prev , String s , Vector < Integer > index ) { if ( pos == s . length ( ) ) return 1 ; if ( dp [ pos ] [ prev ] != - 1 ) return dp [ pos ] [ prev ] ; int answer = 0 ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( index . get ( i ) . compareTo ( prev ) >= 0 ) { answer = ( answer % mod + calculate ( pos + 1 , index . get ( i ) , s , index ) % mod ) % mod ; } } return dp [ pos ] [ prev ] = answer ; } static int countWays ( Vector < String > a , String s ) { int n = a . size ( ) ; Vector < Integer > [ ] index = new Vector [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) index [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a . get ( i ) . length ( ) ; j ++ ) { index [ a . get ( i ) . charAt ( j ) - ' a ' ] . add ( j + 1 ) ; } } for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , 0 , s , index [ 0 ] ) ; } public static void main ( String [ ] args ) { Vector < String > A = new Vector < String > ( ) ; A . add ( \" adc \" ) ; A . add ( \" aec \" ) ; A . add ( \" erg \" ) ; String S = \" ac \" ; System . out . print ( countWays ( A , S ) ) ; } }"}
{"text": "Count of integer dari julat [0, n] yang jumlah digitnya adalah pelbagai k | Pelaksanaan Java pendekatan; Untuk menyimpan negeri -negeri DP; Berfungsi untuk mengembalikan kiraan nombor dari julat [0, n] yang jumlah digitnya adalah pelbagai k menggunakan dp bawah; Digit dalam indeks ini hanya boleh dari [0, num [idx]]; Digit dalam indeks ini boleh menjadi apa -apa dari [0, 9]; new_tight adalah nilai bendera untuk kedudukan seterusnya; Res tidak boleh menjadi negatif; Berfungsi untuk memproses rentetan ke vektor digit dari MSD ke LSD; Kod pemacu; Untuk nombor input besar n; Jumlah bilangan digit dalam n; Jadual DP Bersih; Proses rentetan ke vektor digit dari MSD ke LSD", "code": "import java . util . * ; class GFG { static final int MAX = 100005 ; static final int MOD = 1000000007 ; static int [ ] [ ] [ ] dp = new int [ MAX ] [ 101 ] [ 2 ] ; static int countNum ( int idx , int sum , int tight , Vector < Integer > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) return dp [ idx ] [ sum ] [ tight ] ; int res = 0 , limit ; if ( tight == 0 ) { limit = num . get ( idx ) ; } else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) { int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; } static Vector < Integer > process ( String s ) { Vector < Integer > num = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { num . add ( s . charAt ( i ) - '0' ) ; } return num ; } public static void main ( String [ ] args ) { String n = \"98765432109876543210\" ; int len = n . length ( ) ; int k = 58 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) { for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } Vector < Integer > num = process ( n ) ; System . out . print ( countNum ( 0 , 0 , 0 , num , len , k ) ) ; } }"}
{"text": "Bilangan berikutnya dengan jumlah yang lebih baik dan ganjil | Pelaksanaan Java untuk mencari bilangan berikutnya dengan jumlah yang lebih baik dan ganjil; Array untuk menyimpan kiraan walaupun seterusnya dan berikutnya yang ganjil; Inisialisasi counteven [0] dan countodd [0] hingga 0 kerana kerana tidak ada berikutnya sebelum lelaran dengan kiraan walaupun atau ganjil. ; Di sini Countodd [i] menandakan kiraan berikutnya yang ganjil sehingga i; jika nombor itu juga; Jika nombor itu ganjil; Kod pemacu", "code": "import java . util . * ; import java . lang . * ; class GFG { public static int [ ] countSum ( int arr [ ] , int n ) { int result = 0 ; int [ ] countODD = new int [ n + 1 ] ; int [ ] countEVEN = new int [ n + 1 ] ; countODD [ 0 ] = 0 ; countEVEN [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { countEVEN [ i ] = countEVEN [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; countODD [ i ] = countODD [ i - 1 ] + countODD [ i - 1 ] ; } else { countEVEN [ i ] = countEVEN [ i - 1 ] + countODD [ i - 1 ] ; countODD [ i ] = countODD [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; } } int [ ] ans = new int [ 2 ] ; ans [ 0 ] = countEVEN [ n ] ; ans [ 1 ] = countODD [ n ] ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 2 , 3 } ; int n = 4 ; int [ ] ans = countSum ( arr , n ) ; System . out . println ( \" EvenSum ▁ = ▁ \" + ans [ 0 ] ) ; System . out . println ( \" OddSum ▁ = ▁ \" + ans [ 1 ] ) ; } }"}
{"text": "Double Knapsack | Pengaturcaraan Dinamik | Pelaksanaan Java pendekatan di atas; Arahan 3D untuk menyimpan negeri -negeri DP; W1_R mewakili kapasiti selebihnya 1 stnapsack w2_r mewakili kapasiti selebihnya 2 nd knapsack I mewakili indeks array arr yang kami sedang kerjakan; Kes asas; Pembolehubah untuk menyimpan hasil tiga bahagian hubungan berulang; Simpan negeri dalam array 3d; Kod pemacu; Arahan input; Memulakan array dengan - 1; Bilangan elemen dalam array; Kapasiti knapsacks; Berfungsi untuk dipanggil", "code": "class GFG { static int maxN = 31 ; static int maxW = 31 ; static int dp [ ] [ ] [ ] = new int [ maxN ] [ maxW ] [ maxW ] ; static int maxWeight ( int arr [ ] , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = Math . max ( fill_none , Math . max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 2 , 3 } ; for ( int i = 0 ; i < maxN ; i ++ ) for ( int j = 0 ; j < maxW ; j ++ ) for ( int k = 0 ; k < maxW ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; int n = arr . length ; int w1 = 10 , w2 = 3 ; System . out . println ( maxWeight ( arr , n , w1 , w2 , 0 ) ) ; } }"}
{"text": "Jumlah bitwise dan semua submatrices | Program Java untuk mencari jumlah bit - bijak dan semua submatrik; Berfungsi untuk mencari awalan - kiraan untuk setiap baris dari kanan ke kiri; Berfungsi untuk mencari bilangan submatrik dengan semua 1 s; Array untuk menyimpan kiraan awalan yang diperlukan 1 s dari kanan ke kiri untuk array boolean; Pembolehubah untuk menyimpan jawapan terakhir; Untuk setiap indeks lajur, tentukan bilangan sub -matriks bermula dari indeks itu dan mempunyai semua 1 s; Stack untuk menyimpan unsur -unsur dan kiraan nombor yang mereka muncul bahagian pertama pasangan adalah nilai elemen yang dimasukkan bahagian kedua adalah mengira bilangan elemen yang ditolak sebelum dengan nilai yang lebih besar; pembolehubah untuk menyimpan bilangan submatrik dengan semua 1 s; Berfungsi untuk mencari jumlah bitwise - atau semua submatrices; matriks untuk menyimpan status ith bit setiap elemen matriks arr; Kod pemacu", "code": "import java . util . * ; class GFG { static int n = 3 ; static void findPrefixCount ( int p_arr [ ] [ ] , boolean set_bit [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( ! set_bit [ i ] [ j ] ) continue ; if ( j != n - 1 ) p_arr [ i ] [ j ] += p_arr [ i ] [ j + 1 ] ; p_arr [ i ] [ j ] += ( set_bit [ i ] [ j ] ) ? 1 : 0 ; } } } static class pair { int first , second ; pair ( ) { } pair ( int a , int b ) { first = a ; second = b ; } } static int matrixAllOne ( boolean set_bit [ ] [ ] ) { int p_arr [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) p_arr [ i ] [ j ] = 0 ; findPrefixCount ( p_arr , set_bit ) ; int ans = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int i = n - 1 ; Stack < pair > q = new Stack < pair > ( ) ; int to_sum = 0 ; while ( i >= 0 ) { int c = 0 ; while ( q . size ( ) != 0 && q . peek ( ) . first > p_arr [ i ] [ j ] ) { to_sum -= ( q . peek ( ) . second + 1 ) * ( q . peek ( ) . first - p_arr [ i ] [ j ] ) ; c += q . peek ( ) . second + 1 ; q . pop ( ) ; } to_sum += p_arr [ i ] [ j ] ; ans += to_sum ; q . push ( new pair ( p_arr [ i ] [ j ] , c ) ) ; i -- ; } } return ans ; } static int sumAndMatrix ( int arr [ ] [ ] ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { boolean set_bit [ ] [ ] = new boolean [ n ] [ n ] ; for ( int R = 0 ; R < n ; R ++ ) for ( int C = 0 ; C < n ; C ++ ) set_bit [ R ] [ C ] = ( ( arr [ R ] [ C ] & ( 1 << i ) ) != 0 ) ; sum += ( mul * matrixAllOne ( set_bit ) ) ; mul *= 2 ; } return sum ; } public static void main ( String args [ ] ) { int arr [ ] [ ] = { { 9 , 7 , 4 } , { 8 , 9 , 2 } , { 11 , 11 , 5 } } ; System . out . println ( sumAndMatrix ( arr ) ) ; } }"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pendekatan bawah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; Noofways [i] akan menyimpan kiraan untuk 3 nilai terakhir sebelum i. ; Gelung hingga \"n + 1\" untuk mengira nilai untuk \"n\"; bilangan cara jika larian pertama adalah 1; Bilangan cara jika larian pertama adalah 2 dan larian kedua ialah 1; Ingat 3 nilai terakhir; Kod pemacu", "code": "import java . io . * ; class GFG { static int CountWays ( int n ) { int noOfWays [ ] = new int [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ 3 - 1 ] + noOfWays [ 3 - 3 ] ; noOfWays [ 0 ] = noOfWays [ 1 ] ; noOfWays [ 1 ] = noOfWays [ 2 ] ; noOfWays [ 2 ] = noOfWays [ i ] ; } return noOfWays [ n ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n ) ) ; } }"}
{"text": "Laluan Perdana Lexicographically terbesar dari atas | Pelaksanaan Java pendekatan di atas; Carian pertama kedalaman; Kembali jika sel mengandungi nombor bukan perdana atau halangan, atau keluar dari matriks atau sudah melawat sel atau sudah menemui jalan terbesar leksikografi; Penandaan sel sudah dikunjungi; Menyimpan indeks laluan terbesar leksikografi; Jika sampai ke akhir matriks; Mengemas kini bilangan akhir langkah dalam laluan terbesar leksikografi; Bergerak pepenjuru (mencuba laluan terbesar leksikografi); Menggerakkan sel ke sel semasa; Bergerak sel ke sel semasa. ; Cetak jalan utama lexicographical terbesar; Untuk mengira bilangan langkah dalam laluan utama terbesar leksikografi; Untuk menyimpan indeks jalan utama terbesar lexicographical; Untuk menandakan jika sel sudah dilalui atau tidak; Melintasi DFS; Mencetak laluan utama terbesar lexicographical; Kembalikan bilangan jalan utama dalam matriks. ; Untuk setiap sel; Jika di barisan atas atau lajur paling kiri, tidak ada jalan di sana. ; Jika nombor bukan perdana; Mencari pemetaan matriks dengan mempertimbangkan nombor bukan perdana sebagai halangan dan nombor utama menjadi laluan yang sah. ; Ayak; Jika Perdana; Jika bukan Perdana; Kod pemacu", "code": "import java . util . * ; public class Main { static class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int MAX = 105 , q = 0 ; static int [ ] prime = new int [ MAX ] ; static void sieve ( ) { for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < MAX ; j += i ) prime [ j ] = 1 ; } } } static void dfs ( int i , int j , int k , int n , int m , int [ ] [ ] mappedMatrix , int [ ] [ ] mark , pair [ ] ans ) { if ( ( mappedMatrix [ i ] [ j ] == 0 ? true : false ) || ( i > n ? true : false ) || ( j > m ? true : false ) || ( mark [ i ] [ j ] != 0 ? true : false ) || ( q != 0 ? true : false ) ) return ; mark [ i ] [ j ] = 1 ; ans [ k ] = new pair ( i , j ) ; if ( i == n && j == m ) { ( q ) = k ; return ; } dfs ( i + 1 , j + 1 , k + 1 , n , m , mappedMatrix , mark , ans ) ; dfs ( i + 1 , j , k + 1 , n , m , mappedMatrix , mark , ans ) ; dfs ( i , j + 1 , k + 1 , n , m , mappedMatrix , mark , ans ) ; } static void lexicographicalPath ( int n , int m , int [ ] [ ] mappedMatrix ) { int q = 0 ; pair [ ] ans = new pair [ MAX ] ; int [ ] [ ] mark = new int [ MAX ] [ MAX ] ; dfs ( 1 , 1 , 1 , n , m , mappedMatrix , mark , ans ) ; int [ ] [ ] anss = { { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 3 , 3 } } ; for ( int i = 0 ; i < 4 ; i ++ ) System . out . println ( anss [ i ] [ 0 ] + \" ▁ \" + anss [ i ] [ 1 ] ) ; } static void countPrimePath ( int [ ] [ ] mappedMatrix , int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 1 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( i == 1 && j == 1 ) continue ; dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; if ( mappedMatrix [ i ] [ j ] == 0 ) dp [ i ] [ j ] = 0 ; } } System . out . println ( dp [ n ] [ m ] ) ; } static void preprocessMatrix ( int [ ] [ ] mappedMatrix , int [ ] [ ] a , int n , int m ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( prime [ a [ i ] [ j ] ] == 0 ) mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ; else mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; } } } public static void main ( String [ ] args ) { int n = 3 ; int m = 3 ; int [ ] [ ] a = { { 2 , 3 , 7 } , { 5 , 4 , 2 } , { 3 , 7 , 11 } } ; int [ ] [ ] mappedMatrix = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { mappedMatrix [ i ] [ j ] = 0 ; } } preprocessMatrix ( mappedMatrix , a , n , m ) ; countPrimePath ( mappedMatrix , n , m ) ; lexicographicalPath ( n , m , mappedMatrix ) ; } }"}
{"text": "Subset saiz maksimum dengan jumlah yang diberikan | Penyelesaian pengaturcaraan dinamik untuk masalah jumlah subset + nilai subset maksimal. ; Pulangan saiz subset bersaiz maksimum jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan. Ia kembali - 1 jika tidak ada subset dengan jumlah yang diberikan. ; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara bawah; Program pemacu untuk menguji fungsi di atas", "code": "class sumofSub { static int isSubsetSum ( int set [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ; int count [ ] [ ] = new int [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; } for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = - 1 ; } for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = Math . max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; } public static void main ( String args [ ] ) { int set [ ] = { 2 , 3 , 5 , 10 } ; int sum = 20 ; int n = set . length ; System . out . println ( isSubsetSum ( set , n , sum ) ) ; } }"}
{"text": "Cetak semua sub biasa terpanjang | Program Java untuk mencari semua LC dari dua rentetan dalam urutan yang disusun. ; panjang LCS; Matriks DP untuk menyimpan hasil sub panggilan untuk LCS; Fungsi berasaskan memoisasi yang mengembalikan LCS STR1 [i. . len1 - 1] dan str2 [j. . len2 - 1]; keadaan asas; Jika LCS telah dikira; Jika watak -watak yang sama pulangan sebelumnya + 1 lain max dua urutan selepas mengeluarkan i 'th »dan u' th char satu demi satu; Berfungsi untuk mencetak semua laluan sub - urutan panjang lcslen panjang; Jika currlcs sama dengan lcslen maka cetaknya; Jika kita selesai dengan semua watak kedua -dua rentetan; Di sini kita perlu mencetak semua sub -urutan secara lexicographically, bahawa mengapa kita mula dari 'a' ke 'z' jika watak ini hadir dalam kedua -dua mereka kemudian menambahnya dalam data [] dan bahagian yang sama; Selesai adalah bendera untuk memberitahu bahawa kami telah mencetak semua berikutnya yang sepadan dengan watak semasa; Jika watak CH hadir dalam STR1 maka periksa sama ada ia terdapat dalam STR2; Jika CH hadir dalam kedua -dua mereka dan baki panjang adalah sama dengan panjang LCS yang tinggal kemudian tambah CH dalam sub -sequenece; Jika kami mendapati LCS bermula dengan watak semasa. ; Fungsi ini mencetak semua LCS Str1 dan Str2 dalam urutan leksikografi. ; Cari panjang kedua -dua rentetan; Cari panjang LCS; Cetak semua LCS menggunakan data backtracking rekursif [] digunakan untuk menyimpan LCS individu. ; Kod pemacu", "code": "class GFG { static int MAX = 100 ; static int lcslen = 0 ; static int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; static int lcs ( String str1 , String str2 , int len1 , int len2 , int i , int j ) { int ret = dp [ i ] [ j ] ; if ( i == len1 j == len2 ) return ret = 0 ; if ( ret != - 1 ) return ret ; ret = 0 ; if ( str1 . charAt ( i ) == str2 . charAt ( j ) ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = Math . max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; } static void printAll ( String str1 , String str2 , int len1 , int len2 , char [ ] data , int indx1 , int indx2 , int currlcs ) { if ( currlcs == lcslen ) { data [ currlcs ] = ' \\0' ; System . out . println ( new String ( data ) ) ; return ; } if ( indx1 == len1 indx2 == len2 ) return ; for ( char ch = ' a ' ; ch <= ' z ' ; ch ++ ) { boolean done = false ; for ( int i = indx1 ; i < len1 ; i ++ ) { if ( ch == str1 . charAt ( i ) ) { for ( int j = indx2 ; j < len2 ; j ++ ) { if ( ch == str2 . charAt ( j ) && dp [ i ] [ j ] == lcslen - currlcs ) { data [ currlcs ] = ch ; printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) ; done = true ; break ; } } } if ( done ) break ; } } } static void prinlAllLCSSorted ( String str1 , String str2 ) { int len1 = str1 . length ( ) , len2 = str2 . length ( ) ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ; char [ ] data = new char [ MAX ] ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; } public static void main ( String [ ] args ) { String str1 = \" abcabcaa \" , str2 = \" acbacba \" ; prinlAllLCSSorted ( str1 , str2 ) ; } }"}
{"text": "Semak elemen majoriti dalam array yang disusun | Program untuk memeriksa elemen majoriti dalam pelbagai disusun; Dapatkan indeks terakhir mengikut N (walaupun atau ganjil); Cari kejadian pertama x dalam arr []; Semak jika X hadir dan hadir lebih daripada n / 2 kali; Fungsi pemacu untuk memeriksa fungsi di atas", "code": "import java . io . * ; class Majority { static boolean isMajority ( int arr [ ] , int n , int x ) { int i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? n / 2 : n / 2 + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = arr . length ; int x = 4 ; if ( isMajority ( arr , n , x ) == true ) System . out . println ( x + \" ▁ appears ▁ more ▁ than ▁ \" + n / 2 + \" ▁ times ▁ in ▁ arr [ ] \" ) ; else System . out . println ( x + \" ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ \" + n / 2 + \" ▁ times ▁ in ▁ arr [ ] \" ) ; } }"}
{"text": "Semak elemen majoriti dalam array yang disusun | Program Java untuk memeriksa elemen majoriti dalam array yang disusun; Jika x hadir dalam arr [rendah ... tinggi] maka mengembalikan indeks kejadian pertama x, jika tidak pulangan - 1; Semak jika ARR [MID] adalah kejadian pertama x. arr [pertengahan] adalah kejadian pertama jika x adalah salah satu daripada yang berikut adalah benar: (i) pertengahan == 0 dan arr [mid] = = x (ii) arr [pertengahan - 1] <x dan arr [mid] == x; Fungsi ini kembali benar jika x hadir lebih daripada n / 2 kali dalam arr [] saiz n; Cari indeks kejadian pertama x dalam arr []; Jika elemen tidak hadir sama sekali, kembali palsu; Semak jika elemen hadir lebih daripada n / 2 kali; Fungsi pemacu untuk memeriksa fungsi di atas", "code": "import java . io . * ; class Majority { static int _binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; } static boolean isMajority ( int arr [ ] , int n , int x ) { int i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == - 1 ) return false ; if ( ( ( i + n / 2 ) <= ( n - 1 ) ) && arr [ i + n / 2 ] == x ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = arr . length ; int x = 3 ; if ( isMajority ( arr , n , x ) == true ) System . out . println ( x + \" ▁ appears ▁ more ▁ than ▁ \" + n / 2 + \" ▁ times ▁ in ▁ arr [ ] \" ) ; else System . out . println ( x + \" ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ \" + n / 2 + \" ▁ times ▁ in ▁ arr [ ] \" ) ; } }"}
{"text": "Semak elemen majoriti dalam array yang disusun |  ; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = arr . length ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) System . out . printf ( \" % d ▁ appears ▁ more ▁ than ▁ % d ▁ \" + \" times ▁ in ▁ arr [ ] \" , x , n / 2 ) ; else System . out . printf ( \" % d ▁ does ▁ not ▁ appear ▁ more ▁ \" + \" than ▁ % d ▁ times ▁ in ▁ \" + \" arr [ ] \" , x , n / 2 ) ; } }"}
{"text": "Memotong batang | DP | Penyelesaian pengaturcaraan dinamik untuk masalah pemotongan rod; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Program pemacu untuk menguji fungsi di atas", "code": "class RodCutting { static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" + cutRod ( arr , size ) ) ; } }"}
{"text": "Ubah suai array ke array lain yang diberikan dengan menggantikan elemen array dengan jumlah array | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada arr [] boleh ditukar kepada sasaran [] dengan menggantikan mana -mana elemen dalam arr [] dengan jumlah arr []; Simpan elemen maksimum; Simpan indeks elemen maksimum; Melintasi sasaran array []; Jika elemen semasa lebih besar daripada maks; Jika elemen max adalah 1; Melintasi array, sasaran []; Jika indeks semasa tidak sama dengan indeks elemen maksimum; Kemas kini Max; Jika max kurang daripada atau sama dengan 0 ,; Mengemas kini elemen maksimum; Memanggil semula fungsi secara rekursif; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { public static boolean isPossible ( int [ ] target ) { int max = 0 ; int index = 0 ; for ( int i = 0 ; i < target . length ; i ++ ) { if ( max < target [ i ] ) { max = target [ i ] ; index = i ; } } if ( max == 1 ) return true ; for ( int i = 0 ; i < target . length ; i ++ ) { if ( i != index ) { max -= target [ i ] ; if ( max <= 0 ) return false ; } } target [ index ] = max ; return isPossible ( target ) ; } public static void main ( String [ ] args ) { int [ ] target = { 9 , 3 , 5 } ; boolean res = isPossible ( target ) ; if ( res ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text": "Jumlah semua produk koefisien binomial dua nombor sehingga k | Pelaksanaan Java pendekatan di atas; Fungsi mengembalikan NCR i. e. Pekali binomial; Memulakan res dengan 1; Kerana c (n, r) = c (n, n - r); Menilai ungkapan; Kod pemacu", "code": "import java . util . * ; class GFG { static int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 , k = 2 ; System . out . print ( nCr ( n + m , k ) ) ; } }"}
{"text": "Semak jika n boleh didapati dari 1 dengan mengulangi secara berulang dengan 10 atau 20 | Program Java untuk memeriksa sama ada n boleh diperolehi dari 1 dengan pendaraban berulang sebanyak 10 atau 20; Fungsi untuk memeriksa sama ada n boleh diperoleh atau tidak; Mengira dan mengeluarkan sifar trailing; Semak jika baki N adalah kuasa 2; Untuk memeriksa keadaan untuk prlong ya atau tidak; Kod pemacu", "code": "import java . util . * ; class GFG { static void Is_possible ( long N ) { long C = 0 ; long D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( Math . pow ( 2 , ( long ) ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ) == N ) { D = ( long ) ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ; if ( C >= D ) System . out . print ( \" YES \" ) ; else System . out . print ( \" NO \" ) ; } else System . out . print ( \" NO \" ) ; } public static void main ( String args [ ] ) { long N = 2000000000000L ; Is_possible ( N ) ; } }"}
{"text": "Nombor Poligonal Tengah | Program Java untuk mencari istilah n dalam siri ini; Fungsi untuk mencari istilah n - th dalam siri ini; Kod pemacu", "code": "class GFG { static void findNthTerm ( int n ) { System . out . println ( n * n - n + 1 ) ; } public static void main ( String [ ] args ) { int N = 4 ; findNthTerm ( N ) ; } }"}
{"text": "Anti | Program Java untuk pendekatan di atas; Fungsi berulang untuk membalikkan digit NUM; Mengembalikan nombor terbalik; Fungsi untuk mengira jumlah pembalikan semua pembahagi yang betul; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi Num; Jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Fungsi untuk memeriksa sama ada n adalah anti - sempurna atau tidak; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "class GFG { static int rev ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += rev ( i ) ; else result += ( rev ( i ) + rev ( num / i ) ) ; } } return ( result + 1 ) ; } static boolean isAntiPerfect ( int n ) { return divSum ( n ) == n ; } public static void main ( String [ ] args ) { int N = 244 ; if ( isAntiPerfect ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text": "Program untuk mencetak Siri 1, 3, 4, 8, 15, 27, 50 â € | Sehingga N Syarat | Pelaksanaan Java untuk mencetak istilah N siri yang tiga istilahnya diberikan; Berfungsi untuk mencetak siri; Menjana istilah ith dan mencetaknya; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void printSeries ( int n , int a , int b , int c ) { int d ; if ( n == 1 ) { System . out . print ( a + \" ▁ \" ) ; return ; } if ( n == 2 ) { System . out . print ( a + \" ▁ \" + b + \" ▁ \" ) ; return ; } System . out . print ( a + \" ▁ \" + b + \" ▁ \" + c + \" ▁ \" ) ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; System . out . print ( d + \" ▁ \" ) ; a = b ; b = c ; c = d ; } } public static void main ( String [ ] args ) { int N = 7 , a = 1 , b = 3 ; int c = 4 ; printSeries ( N , a , b , c ) ; } }"}
{"text": "Diameter pokok terindeks binari dengan nod n | Pelaksanaan Java pendekatan; Berfungsi untuk mencari diameter bit dengan n + 1 nod; L adalah saiz subtree sebelum subtree di mana n terletak; H ialah ketinggian subtree sebelum subtree di mana n terletak; Kes asas; Saiz subtree adalah kuasa 2; 3 kes seperti yang dijelaskan dalam pendekatan; Kod pemacu", "code": "class GFG { static int diameter ( int n ) { int L , H , templen ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( diameter ( n ) ) ; } }"}
{"text": "Cari eksponen yang lebih besar di antara dua eksponen | Pelaksanaan Java pendekatan; Fungsi untuk mencari sama ada A ^ B lebih besar atau c ^ d; Cari b * log (a); Cari d * log (c); Bandingkan kedua -dua nilai; Kod pemacu", "code": "class GFG { static void compareValues ( int a , int b , int c , int d ) { double log1 = Math . log10 ( a ) ; double num1 = log1 * b ; double log2 = Math . log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) System . out . println ( a + \" ^ \" + b ) ; else System . out . println ( c + \" ^ \" + d ) ; } public static void main ( String [ ] args ) { int a = 8 , b = 29 , c = 60 , d = 59 ; compareValues ( a , b , c , d ) ; } }"}
{"text": "Jumlah nombor perdana tanpa digit utama yang ganjil | Program Java untuk pendekatan di atas; Cari semua nombor utama; Simpan semua nombor utama; Berfungsi untuk memeriksa sama ada digit adalah perdana ganjil atau tidak; Berfungsi untuk mencari jumlah; Untuk menyimpan jawapan yang diperlukan; Dapatkan semua nombor utama; Melintasi semua nombor perdana; Kedai bendera 1 Jika nombor tidak mengandungi sebarang prima yang ganjil; Cari semua digit nombor; Jika nombor tidak mengandungi sebarang prima yang ganjil; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int MAX = 100005 ; static Vector < Integer > addPrimes ( ) { int n = MAX ; boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . add ( p ) ; return ans ; } static boolean is_prime ( int n ) { return ( n == 3 n == 5 n == 7 ) ; } static int find_Sum ( int n ) { int sum = 0 ; Vector < Integer > v = addPrimes ( ) ; for ( int i = 0 ; i < v . size ( ) && n > 0 ; i ++ ) { int flag = 1 ; int a = v . get ( i ) ; while ( a != 0 ) { int d = a % 10 ; a = a / 10 ; if ( is_prime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v . get ( i ) ; } } return sum ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( find_Sum ( n ) ) ; } }"}
{"text": "Kira bilangan prima dalam array jumlah awalan array yang diberikan | Pelaksanaan Java pendekatan; Mengembalikan elemen max; Berfungsi untuk mengembalikan kiraan prima dalam array yang diberikan; Cari nilai maksimum dalam array; Gunakan ayak untuk mencari semua nombor perdana kurang daripada atau sama dengan max_val Buat array boolean \"Perdana [0 ... N]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Baki bahagian Sieve; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cari semua prima di arr []; Berfungsi untuk menghasilkan array awalan; Isi array awalan; Kod pemacu; Arahan awalan arr []; Count of Prima dalam Array Awalan", "code": "import java . util . * ; class GFG { static int max_element ( int a [ ] ) { int m = a [ 0 ] ; for ( int i = 0 ; i < a . length ; i ++ ) m = Math . max ( a [ i ] , m ) ; return m ; } static int primeCount ( int arr [ ] , int n ) { int max_val = max_element ( arr ) ; boolean prime [ ] = new boolean [ max_val + 1 ] ; for ( int p = 0 ; p <= max_val ; p ++ ) prime [ p ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; } static int [ ] getPrefixArray ( int arr [ ] , int n , int pre [ ] ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } return pre ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 8 , 4 } ; int n = arr . length ; int pre [ ] = new int [ n ] ; pre = getPrefixArray ( arr , n , pre ) ; System . out . println ( primeCount ( pre , n ) ) ; } }"}
{"text": "Nilai minimum yang akan ditambah kepada x supaya sekurang -kurangnya y peratus daripada n | Pelaksanaan Java pendekatan; Fungsi untuk mengembalikan nilai yang diperlukan yang mesti ditambah kepada x supaya sekurang -kurangnya y peratus daripada n; Nilai yang diperlukan; Jika x sudah> = y peratus n; Kod pemacu", "code": "import java . lang . Math ; class GFG { static int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( int ) ( Math . ceil ( val ) - x ) ; } public static void main ( String [ ] args ) { int n = 10 , x = 2 , y = 40 ; System . out . println ( minValue ( n , x , y ) ) ; } }"}
{"text": "Semak jika n adalah faktorial utama | Program Java untuk memeriksa sama ada nombor yang diberikan adalah faktorial utama; Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah faktorial utama; Jika n tidak perdana maka kembali palsu; Hitung faktorial; Jika n adalah perdana faktorial; n bukanlah perdana faktorial; Kod pemacu", "code": "class GFG { static boolean isPrime ( long n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean isFactorialPrime ( long n ) { if ( ! isPrime ( n ) ) return false ; long fact = 1 ; int i = 1 ; while ( fact <= n + 1 ) { fact = fact * i ; if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; } return false ; } public static void main ( String args [ ] ) { int n = 23 ; if ( isFactorialPrime ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Susunan tempat duduk N Boys and Girls secara alternatif di sekitar meja bulat | Program Java untuk mencari bilangan cara di mana N Boys dan N Girls boleh duduk alternatif bunyi meja bulat. ; Kod pemacu; Dapatkan n; Cari FAC1 = (n - 1)! ; Cari FAC2 = N! ; Cari jumlah cara; Cetak jumlah cara", "code": "import java . io . * ; class GFG { public static void main ( String [ ] args ) { long n = 5 ; long fac1 = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) fac1 = fac1 * i ; long fac2 = fac1 * n ; long totalWays = fac1 * fac2 ; System . out . println ( totalWays ) ; } }"}
{"text": "Semak sama ada nombor yang diberikan adalah nombor Euclid atau tidak | Program Java untuk memeriksa nombor Euclid; Berfungsi untuk mendapatkan nombor perdana; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Simpan semua nombor utama ke vektor 'arr'; Berfungsi untuk memeriksa nombor untuk nombor Euclid; Masukkan nombor perdana seterusnya dan periksa sama ada produk + 1 = n memegang atau tidak; Kod pemacu; Dapatkan nombor utama; Dapatkan n; Semak jika n adalah nombor euclid; Dapatkan n; Periksa sama ada n adalah nombor euclid", "code": "import java . util . * ; class GFG { static final int MAX = 10000 ; static Vector < Integer > arr = new Vector < Integer > ( ) ; static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . add ( p ) ; } static boolean isEuclid ( long n ) { long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr . get ( i ) ; if ( product + 1 == n ) return true ; i ++ ; } return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; long n = 31 ; if ( isEuclid ( n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; n = 42 ; if ( isEuclid ( n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text": "Cube sempurna lebih besar daripada nombor tertentu | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mencari kiub sempurna seterusnya; Kod pemacu", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int nextPerfectCube ( int N ) { int nextN = ( int ) Math . floor ( Math . cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; } public static void main ( String args [ ] ) { int n = 35 ; System . out . print ( nextPerfectCube ( n ) ) ; } }"}
{"text": "Jumlah semua pembahagi utama nombor | Program Java untuk mencari jumlah pembahagi utama N; Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Berfungsi untuk mencari jumlah pembahagi utama N; Kembali jenis fungsi SQRT jika terapung; Kedua -dua faktor adalah sama; Kedua -dua faktor tidak sama (i dan n / i); Kod pemacu", "code": "class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static int SumOfPrimeDivisors ( int n ) { int sum = 0 ; int root_n = ( int ) Math . sqrt ( n ) ; for ( int i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i && isPrime ( i ) ) { sum += i ; } else { if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( n / i ) ) { sum += ( n / i ) ; } } } } return sum ; } public static void main ( String [ ] args ) { int n = 60 ; System . out . println ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" + SumOfPrimeDivisors ( n ) ) ; } }"}
{"text": "Kedudukan N di antara nombor yang diperbuat daripada 2, 3, 5 & 7 | Kedudukan program Java N di antara nombor yang diperbuat daripada 2, 3, 5 & 7; Jika nombor adalah 2 maka ia berada di kedudukan pos * 2 + 1; Jika nombor adalah 3 maka ia berada di kedudukan pos * 2 + 2; Jika nombor adalah 5 maka ia berada di kedudukan pos * 2 + 3; Jika nombor adalah 7 maka ia berada di kedudukan pos * 2 + 4; Kod pemacu", "code": "class GFG { static int findpos ( String n ) { int pos = 0 ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { switch ( n . charAt ( i ) ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; } public static void main ( String args [ ] ) { String n = \"777\" ; System . out . println ( findpos ( n ) ) ; } }"}
{"text": "Mencari Co Transitif | Program Java untuk mencari Triplet Perdana yang tidak transitif antara L dan R; Memeriksa jika ada triplet yang mungkin (a, b, c) menetapkan keadaan bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Kes 1: Kurang daripada 3 nombor antara L dan R; Kes 2: Lebih daripada 3 nombor antara L dan R; Triplet harus selalu menjadi bentuk (2 k, 2 k + 1, 2 k + 2); Kes 3.1: Tepat 3 nombor dalam julat bentuk (2 k, 2 k + 1, 2 k + 2); Kes 3.2: Tepat 3 nombor dalam julat bentuk (2 k - 1, 2 k, 2 k + 1); Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; Kod pemacu; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46", "code": "import java . io . * ; class GFG { static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 > 0 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ! ( L % 2 > 0 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { System . out . println ( \" ( \" + possibleA + \" , ▁ \" + possibleB + \" , ▁ \" + possibleC + \" ) \" + \" ▁ is ▁ one ▁ such ▁ possible \" + \" ▁ triplet ▁ between ▁ \" + L + \" ▁ and ▁ \" + R ) ; } else { System . out . println ( \" No ▁ Such ▁ Triplet \" + \" ▁ exists ▁ between ▁ \" + L + \" ▁ and ▁ \" + R ) ; } } public static void main ( String [ ] args ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }"}
{"text": "Count n digit nombor tidak mempunyai digit tertentu | Pelaksanaan Java kaedah di atas; Mencari bilangan nombor yang mungkin dengan digit N tidak termasuk digit tertentu; Memeriksa jika bilangan digit adalah sifar; Memeriksa jika bilangan digit adalah satu; Memeriksa jika bilangan digit adalah ganjil; Memanggil fungsi digitNumber dengan (digit - 1) / 2 digit; Memanggil fungsi digitnumber dengan n / 2 digit; Memanggil fungsi DigitNumber Memeriksa jika tidak termasuk digit adalah sifar atau bukan sifar; Fungsi pemacu untuk menjalankan program di atas; Memulakan pembolehubah", "code": "import java . lang . * ; class GFG { static final int mod = 1000000007 ; static int digitNumber ( long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 != 0 ) { int temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { int temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } } static int countExcluding ( int n , int d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; } public static void main ( String [ ] args ) { int d = 9 ; int n = 3 ; System . out . println ( countExcluding ( n , d ) ) ; } }"}
{"text": "Semak jika nombor yang diberikan adalah nombor emirp atau tidak | Program Java untuk memeriksa sama ada nombor yang diberikan adalah emirp atau tidak. ; Pulangan benar jika n adalah perdana. Lain palsu. ; Kes sudut; Semak dari 2 hingga n - 1; Fungsi akan memeriksa sama ada nombor adalah emirp atau tidak; Semak jika n adalah perdana; Cari terbalik n; Jika kedua -dua asal dan terbalik adalah perdana, maka ia adalah nombor emirp; Fungsi pemacu; Nombor input", "code": "import java . io . * ; class Emirp { public static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } public static boolean isEmirp ( int n ) { if ( isPrime ( n ) == false ) return false ; int rev = 0 ; while ( n != 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n /= 10 ; } return isPrime ( rev ) ; } public static void main ( String args [ ] ) throws IOException { int n = 13 ; if ( isEmirp ( n ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Program untuk menukar radian ke ijazah | Kod Java untuk menukar radian ke ijazah; Fungsi untuk penukaran; Kod pemacu", "code": "import java . io . * ; class GFG { static double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; } public static void main ( String [ ] args ) { double radian = 5.0 ; double degree = Convert ( radian ) ; System . out . println ( \" degree ▁ = ▁ \" + degree ) ; } }"}
{"text": "Cari jejak matriks yang dibentuk dengan menambah baris | Program Java untuk mencari jejak matriks yang dibentuk dengan menambah baris - utama dan lajur - urutan utama matriks yang sama; Kembali jumlah integer pertama A AP; Kembalikan jejak jumlah baris - matriks utama dan lajur - matriks utama; Mencari elemen ke dalam AP sekiranya matriks utama baris. ; Mencari jumlah integer pertama AP dalam kes matriks utama baris; Mencari elemen ke dalam AP sekiranya matriks utama baris; Mencari jumlah integer pertama AP dalam kes matriks utama lajur; Program yang didorong", "code": "import java . io . * ; public class GFG { static int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; } static int trace ( int n , int m ) { int an = 1 + ( n - 1 ) * ( m + 1 ) ; int rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; } static public void main ( String [ ] args ) { int N = 3 , M = 3 ; System . out . println ( trace ( N , M ) ) ; } }"}
{"text": "Maksimum kawasan yang paling kecil yang boleh diperoleh dengan tepat K yang diberikan segi empat tepat | Kod Java untuk maksimum kawasan yang paling kecil yang boleh mendapatkan dengan tepat K Cut dari segi empat tepat yang diberikan; Fungsi utiliti; untuk kes 1 st; untuk kes kedua; Hasil akhir cetak; Kod pemacu", "code": "class GFG { static void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) System . out . println ( \" Not ▁ possible \" ) ; else { int result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } System . out . println ( result ) ; } } public static void main ( String [ ] args ) { int n = 3 , m = 4 , k = 1 ; max_area ( n , m , k ) ; } }"}
{"text": "Program untuk mencari kawasan persegi | Program Java untuk mencari kawasan persegi; berfungsi untuk mencari kawasan; Kod pemacu", "code": "class GFG { static int area_fun ( int side ) { int area = side * side ; return area ; } public static void main ( String arg [ ] ) { int side = 4 ; int area = area_fun ( side ) ; System . out . println ( area ) ; } }"}
{"text": "Kira cara untuk menyatakan nombor sebagai jumlah nombor berturut -turut | Program Java untuk mengira bilangan cara untuk menyatakan n sebagai jumlah nombor berturut -turut. ; Kaedah utiliti untuk mengira bilangan cara di mana n boleh diwakili sebagai jumlah nombor berturut -turut; Kekangan pada nilai L memberi kita kerumitan masa sebagai O (n ^ 0.5); Kod pemacu untuk menguji fungsi di atas", "code": "public class SumConsecutiveNumber { static int countConsecutive ( int N ) { int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( double ) ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int N = 15 ; System . out . println ( countConsecutive ( N ) ) ; N = 10 ; System . out . println ( countConsecutive ( N ) ) ; } }"}
{"text": "Nombor Automorphic | Program Java untuk memeriksa sama ada nombor adalah authomorphic; Berfungsi untuk memeriksa nombor automorphic; Simpan dataran; Mula membandingkan digit; Kembali palsu, jika mana -mana digit dari n tidak sesuai dengan angka -angka yang terakhir; Mengurangkan N dan persegi; Kaedah Pemandu", "code": "class Test { static boolean isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( isAutomorphic ( N ) ? \" Automorphic \" : \" Not ▁ Automorphic \" ) ; } }"}
{"text": "Nombor dengan bilangan maksimum faktor utama | Program Java untuk mencari integer yang mempunyai jumlah maksimum faktor utama dalam nombor semulajadi n pertama; Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Nilai lalai boolean adalah palsu; Ayak eratosthenes; Menyimpan nombor perdana. ; Nombor penjanaan yang mempunyai faktor utama maksimum. ; Program Pemandu", "code": "import java . util . Vector ; public class GFG { static int maxPrimefactorNum ( int N ) { boolean arr [ ] = new boolean [ N + 5 ] ; for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( ! arr [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = true ; } } } Vector < Integer > prime = new Vector < > ( ) ; prime . add ( prime . size ( ) , 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( ! arr [ i ] ) { prime . add ( prime . size ( ) , i ) ; } } int i = 0 , ans = 1 ; while ( ans * prime . get ( i ) <= N && i < prime . size ( ) ) { ans *= prime . get ( i ) ; i ++ ; } return ans ; } public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program Java untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Semak bit set; Kemudian kita mengeluarkan semua tetapi bit atas oleh xor 'ing u »'» s dengan rentetan 1 's' u u u u u u u u u u u u u u u u u u u u u u. ; Kod pemacu", "code": "import java . io . * ; class GFG { static int highestPowerof2 ( int x ) { x |= x >> 1 ; x |= x >> 2 ; x |= x >> 4 ; x |= x >> 8 ; x |= x >> 16 ; return x ^ ( x >> 1 ) ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( highestPowerof2 ( n ) ) ; } }"}
{"text": "Jumlah semua pembahagi yang betul dari nombor semulajadi | Program Java untuk mencari jumlah semua pembahagi nombor semulajadi; Fungsi untuk mengira jumlah semua pembahagi yang betul Num -> diberi nombor semulajadi; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Program pemacu untuk menjalankan kes itu", "code": "import java . math . * ; class GFG { static int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } public static void main ( String [ ] args ) { int num = 36 ; System . out . println ( divSum ( num ) ) ; } }"}
{"text": "Cari akar persegi di bawah modulo p | Tetapkan 1 (apabila p dalam bentuk 4 * i + 3) | Program Java yang cekap untuk mencari akar persegi di bawah modulo p apabila p ialah 7, 11, 19, 23, 31, ... dan lain -lain. ; Fungsi utiliti untuk melakukan eksponensi modular. Ia kembali (x ^ y) % p. ; int res = 1; Inisialisasi hasil x = x % p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y >> 1; y = y / 2; Pulangan benar jika akar kuadrat n di bawah modulo p ada asumsi: p adalah bentuk 3 * i + 4 di mana i> = 1; Cuba \" + (n ^ ((p ~ ~ 1) / 4))\"; Cuba \" - (n '((p ~ ~ 1) / 4))\"; Sekiranya tiada dua kerja di atas, maka akar persegi tidak wujud; Program Pemandu untuk Menguji", "code": "public class GFG { static int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static void squareRoot ( int n , int p ) { if ( p % 4 != 3 ) { System . out . print ( \" Invalid ▁ Input \" ) ; return ; } n = n % p ; int x = power ( n , ( p + 1 ) / 4 , p ) ; if ( ( x * x ) % p == n ) { System . out . print ( \" Square ▁ root ▁ is ▁ \" + x ) ; return ; } x = p - x ; if ( ( x * x ) % p == n ) { System . out . print ( \" Square ▁ root ▁ is ▁ \" + x ) ; return ; } System . out . print ( \" Square ▁ root ▁ doesn ' t ▁ exist ▁ \" ) ; } static public void main ( String [ ] args ) { int p = 7 ; int n = 2 ; squareRoot ( n , p ) ; } }"}
{"text": "Ujian Primal | Tetapkan 3 (Millerâ € \"Rabin) | Program Java Miller - Rabin Primality Test; Fungsi Utiliti untuk Melakukan Eksponen Modular. palsu jika n adalah perdana. N-1 Komposit;", "code": "import java . io . * ; import java . math . * ; class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static boolean miillerTest ( int d , int n ) { int a = 2 + ( int ) ( Math . random ( ) % ( n - 4 ) ) ; int x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ; while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; } return false ; } static boolean isPrime ( int n , int k ) { if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ; int d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ; for ( int i = 0 ; i < k ; i ++ ) if ( ! miillerTest ( d , n ) ) return false ; return true ; } public static void main ( String args [ ] ) { int k = 4 ; System . out . println ( \" All ▁ primes ▁ smaller ▁ \" + \" than ▁ 100 : ▁ \" ) ; for ( int n = 1 ; n < 100 ; n ++ ) if ( isPrime ( n , k ) ) System . out . print ( n + \" ▁ \" ) ; } }"}
{"text": "Panjang paling lama berturut -turut 1 s dalam perwakilan binari | Program Java untuk mencari panjang 1 s paling lama berturut -turut dalam perwakilan binari nombor. ; Berfungsi untuk mencari panjang 1 s paling lama berturut -turut dalam perwakilan binari nombor; Memulakan hasil; Kira bilangan lelaran untuk mencapai x = 0 .; Operasi ini mengurangkan panjang setiap urutan 1 s dengan satu. ; Kod pemacu", "code": "class MaxConsecutiveOnes { private static int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; } public static void main ( String strings [ ] ) { System . out . println ( maxConsecutiveOnes ( 14 ) ) ; System . out . println ( maxConsecutiveOnes ( 222 ) ) ; } }"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program Java untuk menolak dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Pinjam mengandungi bit set biasa Y dan bit yang tidak tersembunyi x; Penolakan bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Meminjam dipindahkan oleh satu supaya menolaknya dari x memberikan jumlah yang diperlukan; Kod pemacu", "code": "import java . io . * ; class GFG { static int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; } public static void main ( String [ ] args ) { int x = 29 , y = 13 ; System . out . println ( \" x ▁ - ▁ y ▁ is ▁ \" + subtract ( x , y ) ) ; } }"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program Java untuk menolak dua nombor tanpa menggunakan pelaksanaan rekursif pengendali aritmetik. ; Program Pemandu", "code": "class GFG { static int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; } public static void main ( String [ ] args ) { int x = 29 , y = 13 ; System . out . printf ( \" x ▁ - ▁ y ▁ is ▁ % d \" , subtract ( x , y ) ) ; } }"}
{"text": "Kth nenek moyang semua nod dalam n | Pelaksanaan Java pendekatan di atas; Berfungsi untuk menambah kelebihan di dalam pokok; DFS untuk mencari nenek moyang Kth setiap nod; Menolak nod semasa dalam vektor; Melintasi jirannya; Jika n nenek moyang tidak dijumpai untuk nod semasa; Tambah nenek moyang KTH untuk nod; Berfungsi untuk mencari nenek moyang setiap nod; Membina pokok; Menyimpan semua ibu bapa nod; Simpan nenek moyang semua nod; Cetak nenek moyang; Kod pemacu; Diberikan n dan k; Diberi tepi pokok n - ary; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void addEdge ( Vector < Integer > v [ ] , int x , int y ) { v [ x ] . add ( y ) ; v [ y ] . add ( x ) ; } static void dfs ( Vector < Integer > tree [ ] , Vector < Integer > temp , int ancestor [ ] , int u , int parent , int k ) { temp . add ( u ) ; for ( int i : tree [ u ] ) { if ( i == parent ) continue ; dfs ( tree , temp , ancestor , i , u , k ) ; } temp . remove ( temp . size ( ) - 1 ) ; if ( temp . size ( ) < k ) { ancestor [ u ] = - 1 ; } else { ancestor [ u ] = temp . get ( temp . size ( ) - k ) ; } } static void KthAncestor ( int N , int K , int E , int edges [ ] [ ] ) { @ SuppressWarnings ( \" unchecked \" ) Vector < Integer > [ ] tree = new Vector [ N + 1 ] ; for ( int i = 0 ; i < tree . length ; i ++ ) tree [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } Vector < Integer > temp = new Vector < Integer > ( ) ; int [ ] ancestor = new int [ N + 1 ] ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ; for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( ancestor [ i ] + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int N = 9 ; int K = 2 ; int E = 8 ; int edges [ ] [ ] = { { 1 , 2 } , { 1 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 7 } , { 3 , 8 } , { 3 , 9 } } ; KthAncestor ( N , K , E , edges ) ; } }"}
{"text": "Pertanyaan untuk mengira elemen array lebih besar daripada atau sama dengan nombor tertentu dengan kemas kini | Program Java untuk pendekatan di atas; Berfungsi untuk membina pokok segmen; Semak kes asas; Cari titik pertengahan; Secara rekursif membina pokok segmen; Fungsi untuk menolak operasi pada pokok segmen; Berfungsi untuk mengemas kini pokok segmen; Tumpang tindih lengkap; Cari pertengahan; Melakukan operasi menolak pada pokok segmen; Mengemas kini pokok segmen secara rekursif; Berfungsi untuk memproses pertanyaan; Kes asas; Cari pertengahan; Melakukan operasi menolak pada pokok segmen; Secara rekursif mengira hasil pertanyaan; Mengembalikan hasilnya; Fungsi untuk mengira nombor yang lebih besar daripada pertanyaan yang diberikan; Susun array input; Buat pokok segmen saiz 4 * n; Membina pokok segmen; Melangkah ke atas pertanyaan; Kedai hasil dalam pelbagai; Mengemas kini unsur -unsur dalam julat yang diberikan; Cetak hasil pertanyaan; Kod pemacu; Panggilan fungsi", "code": "import java . io . * ; import java . util . * ; class GFG { static void build ( Vector < Integer > sum , Vector < Integer > a , int l , int r , int rt ) { if ( l == r ) { sum . set ( rt , a . get ( l - 1 ) ) ; return ; } int m = ( l + r ) >> 1 ; build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; } static void pushDown ( Vector < Integer > sum , Vector < Integer > add , int rt , int ln , int rn ) { if ( add . get ( rt ) != 0 ) { add . set ( rt << 1 , add . get ( rt ) ) ; add . set ( rt << 1 | 1 , add . get ( rt ) ) ; sum . set ( rt << 1 , sum . get ( rt << 1 ) + add . get ( rt ) * ln ) ; sum . set ( rt << 1 | 1 , sum . get ( rt << 1 1 ) + add . get ( rt ) * rn ) ; add . set ( rt , 0 ) ; } } static void update ( Vector < Integer > sum , Vector < Integer > add , int L , int R , int C , int l , int r , int rt ) { if ( L <= l && r <= R ) { sum . set ( rt , sum . get ( rt ) + C * ( r - l + 1 ) ) ; add . set ( rt , add . get ( rt ) + C ) ; return ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; if ( L <= m ) { update ( sum , add , L , R , C , l , m , rt << 1 ) ; } if ( R > m ) { update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; } } static int query ( Vector < Integer > sum , Vector < Integer > add , int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { return sum . get ( rt ) ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; int ans = 0 ; if ( L <= m ) { ans += query ( sum , add , L , R , l , m , rt << 1 ) ; } if ( R > m ) { ans += query ( sum , add , L , R , m + 1 , r , rt << 1 1 ) ; } return ans ; } static void sequenceMaintenance ( int n , int q , Vector < Integer > a , Vector < Integer > b , int m ) { Collections . sort ( a ) ; Vector < Integer > sum = new Vector < Integer > ( ) ; Vector < Integer > ad = new Vector < Integer > ( ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < ( n << 2 ) ; i ++ ) { sum . add ( 0 ) ; ad . add ( 0 ) ; } build ( sum , a , 1 , n , 1 ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = 1 , r = n , pos = - 1 ; while ( l <= r ) { m = ( l + r ) >> 1 ; if ( query ( sum , ad , m , m , 1 , n , 1 ) >= b . get ( i ) ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == - 1 ) { ans . add ( 0 ) ; } else { ans . add ( n - pos + 1 ) ; update ( sum , ad , pos , n , - m , 1 , n , 1 ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int N = 4 ; int Q = 3 ; int M = 1 ; Vector < Integer > arr = new Vector < Integer > ( ) ; arr . add ( 1 ) ; arr . add ( 2 ) ; arr . add ( 3 ) ; arr . add ( 4 ) ; Vector < Integer > query = new Vector < Integer > ( ) ; query . add ( 4 ) ; query . add ( 3 ) ; query . add ( 1 ) ; sequenceMaintenance ( N , Q , arr , query , M ) ; } }"}
{"text": "Kurangkan panjang array dengan berulang kali menggantikan co | Program Java untuk pendekatan di atas; Fungsi rekursif untuk mengembalikan GCD A dan B; Berfungsi untuk mencari panjang array akhir dengan menggantikan pasangan coprime dengan 1; Melangkah ke atas semua pasang elemen; Semak jika GCD adalah 1; Sekiranya tiada pasangan Coprime mendapati kembali palsu; Kod pemacu; Semak sama ada satu pasangan coprime wujud dalam array; Sekiranya tidak ada pasangan seperti itu", "code": "import java . util . * ; class GFG { static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static boolean hasCoprimePair ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( __gcd ( arr [ i ] , arr [ j ] ) ) == 1 ) { return true ; } } } return false ; } public static void main ( String [ ] args ) { int n = 3 ; int [ ] arr = { 6 , 9 , 15 } ; if ( hasCoprimePair ( arr , n ) ) { System . out . print ( 1 + \"NEW_LINE\"); } else { System . out . print ( n + \"NEW_LINE\"); } } }"}
{"text": "Mengira cara untuk berpecah n ke dalam tiga kali ganda membentuk segitiga | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan bilangan cara yang diperlukan; Semak jika A, B, C boleh membentuk segitiga; Mengembalikan bilangan cara; Kod pemacu", "code": "import java . io . * ; class GFG { static int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 0 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( Numberofways ( n ) ) ; } }"}
{"text": "Kira pasangan yang mempunyai setiap elemen yang sama dengan indeks yang lain dari array | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencetak kiraan pasangan; Melangkah ke atas semua elemen array; Kenaikan kiraan; Cetak hasilnya; Kod pemacu", "code": "import java . util . * ; class GFG { static void countPairs ( int N , int [ ] arr ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } System . out . println ( count / 2 ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 4 , 3 } ; int N = arr . length ; countPairs ( N , arr ) ; } }"}
{"text": "Cari panjang fibonacci terpanjang seperti berikutnya | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mengembalikan panjang maksimum fibonacci seterusnya; Simpan semua elemen array dalam jadual hash; Semak sehingga elemen FIB seterusnya dijumpai; Elemen seterusnya FIB Subseq; Program Pemandu", "code": "import java . util . * ; public class GFG { static int LongestFibSubseq ( int A [ ] , int n ) { TreeSet < Integer > S = new TreeSet < > ( ) ; for ( int t : A ) { S . add ( t ) ; } int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 3 ; while ( S . contains ( y ) && ( y != S . last ( ) ) ) { int z = x + y ; x = y ; y = z ; maxLen = Math . max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = A . length ; System . out . print ( LongestFibSubseq ( A , n ) ) ; } }"}
{"text": "Memaksimumkan kiraan elemen yang boleh dipilih mempunyai perbezaan minimum antara jumlah dan k | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mengira bilangan maksimum elemen yang boleh dipilih; Menyusun array; Melintasi array; Tambah elemen semasa ke jumlah; Jika jumlah melebihi k; Kiraan kenaikan; Mengembalikan kiraan; Kod pemacu; Panggilan fungsi", "code": "import java . util . Arrays ; public class GFG { static int CountMaximum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = 4 ; int k = 50 ; System . out . println ( CountMaximum ( arr , n , k ) ) ; } }"}
{"text": "Jenis maksimum gula -gula seseorang boleh makan jika hanya n / 2 daripadanya boleh dimakan | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan jenis gula -gula; Mengisytiharkan hashset untuk menyimpan gula -gula; Melintasi array yang diberikan dan memasukkan elemen ke dalam set; Mengembalikan hasilnya; Berfungsi untuk mencari bilangan maksimum jenis gula -gula yang boleh dimakan seseorang; Simpan bilangan gula -gula yang dibenarkan makan; Simpan bilangan jenis gula -gula; Mengembalikan hasilnya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "import java . util . * ; class GFG { public static int num_candyTypes ( int [ ] candies ) { Dictionary < Integer , Integer > s = new Hashtable < Integer , Integer > ( ) ; for ( int i = 0 ; i < candies . length ; i ++ ) { s . put ( candies [ i ] , 1 ) ; } return s . size ( ) ; } public static void distribute_candies ( int [ ] candies ) { int allowed = candies . length / 2 ; int types = num_candyTypes ( candies ) ; if ( types < allowed ) System . out . println ( types ) ; else System . out . println ( allowed ) ; } public static void main ( String [ ] args ) { int candies [ ] = { 4 , 4 , 5 , 5 , 3 , 3 } ; distribute_candies ( candies ) ; } }"}
{"text": "Panjang pepenjuru rombus menggunakan panjang sisi dan sudut puncak | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira panjang pepenjuru rombus menggunakan panjang sisi dan sudut puncak; Kod pemacu", "code": "class GFG { static double [ ] Length_Diagonals ( int a , double theta ) { double p = a * Math . sqrt ( 2 + ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; double q = a * Math . sqrt ( 2 - ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; return new double [ ] { p , q } ; } public static void main ( String [ ] args ) { int A = 6 ; double theta = 45 ; double [ ] ans = Length_Diagonals ( A , theta ) ; System . out . printf ( \" % .2f \" + \" ▁ \" + \" % .2f \" , ans [ 0 ] , ans [ 1 ] ) ; } }"}
{"text": "Kira bit set Even dan Odd dengan elemen array selepas xor dengan k | Program Java untuk mengira bit set selepas mengambil XOR dengan nombor k; Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Berfungsi untuk menyimpan pemboleh ubah yang walaupun dan ganjil; Simpan kiraan bit set walaupun dan ganjil; Kira set bit menggunakan dalam fungsi terbina; Count set - bit k; Jika y adalah ganjil, kiraan bit set walaupun dan ganjil akan ditukar; Lain ia akan tetap sama dengan array asal; Kod pemandu; Fungsi panggilan untuk mengira walaupun dan ganjil", "code": "class GFG { static int __builtin_popcount ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } static void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { System . out . println ( \" Even ▁ = ▁ \" + odd + \" , ▁ Odd ▁ = ▁ \" + even ) ; } else { System . out . println ( \" Even ▁ = ▁ \" + even + \" , ▁ Odd ▁ = ▁ \" + odd ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = arr . length ; countEvenOdd ( arr , n , K ) ; } }"}
{"text": "Bilangan cara untuk memilih pasangan yang mengandungi nombor yang lebih dan ganjil dari 1 hingga n | Pelaksanaan Java pendekatan di atas; Kod pemacu", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { public static void main ( String args [ ] ) { int N = 6 ; int Even = N / 2 ; int Odd = N - Even ; System . out . println ( Even * Odd ) ; } }"}
{"text": "Paling terpanjang dari pelbagai pasangan yang mempunyai elemen pertama yang semakin meningkat dan elemen kedua berkurangan. | Program Java untuk pendekatan di atas; Fungsi rekursif untuk mencari panjang pasang pasang terpanjang yang elemen pertama yang semakin meningkat dan kedua berkurangan; Kes asas; Tidak termasuk pasangan semasa dalam masa yang paling lama; Termasuk pasangan semasa dalam masa yang paling lama; Fungsi; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "class GFG { public static Integer longestSubSequence ( int [ ] [ ] A , int N , int ind , int lastf , int lasts ) { ind = ( ind > 0 ? ind : 0 ) ; lastf = ( lastf > 0 ? lastf : Integer . MIN_VALUE ) ; lasts = ( lasts > 0 ? lasts : Integer . MAX_VALUE ) ; if ( ind == N ) return 0 ; int ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) ; if ( A [ ind ] [ 0 ] > lastf && A [ ind ] [ 1 ] < lasts ) ans = Math . max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] [ 0 ] , A [ ind ] [ 1 ] ) + 1 ) ; return ans ; } public static int longestSubSequence ( int [ ] [ ] A , int N ) { return longestSubSequence ( A , N , 0 , 0 , 0 ) ; } public static void main ( String args [ ] ) { int [ ] [ ] A = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = A . length ; System . out . println ( longestSubSequence ( A , N ) ) ; } }"}
{"text": "Kira tiga dengan bitwise dan sama dengan sifar | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan tiga kali ganda yang bitwise dan 0.; Menyimpan kiraan triplet yang mempunyai bitwise dan sama dengan 0; Kedai frekuensi semua yang mungkin [i] & a [j]; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Melintasi array; Melelehkan peta; Jika bitwise dan triplet adalah sifar, kenaikan CNT; Kembalikan bilangan tiga kali ganda yang bitwise dan 0 .; Kod pemacu; Arahan input; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int countTriplets ( int [ ] A ) { int cnt = 0 ; HashMap < Integer , Integer > tuples = new HashMap < Integer , Integer > ( ) ; for ( int a : A ) for ( int b : A ) { if ( tuples . containsKey ( a & b ) ) tuples . put ( a & b , tuples . get ( a & b ) + 1 ) ; else tuples . put ( a & b , 1 ) ; } for ( int a : A ) for ( Map . Entry < Integer , Integer > t : tuples . entrySet ( ) ) if ( ( t . getKey ( ) & a ) == 0 ) cnt += t . getValue ( ) ; return cnt ; } public static void main ( String [ ] args ) { int [ ] A = { 2 , 1 , 3 } ; System . out . print ( countTriplets ( A ) ) ; } }"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pendekatan bawah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; Noofways [i] akan menyimpan kiraan untuk nilai i. 3 nilai tambahan adalah untuk menjaga kes jagung n = 0; Gelung hingga \"n + 1\" untuk mengira nilai untuk \"n\"; bilangan cara jika larian pertama adalah 1; Kod pemacu", "code": "import java . util . Arrays ; class GfG { static int CountWays ( int n ) { int noOfWays [ ] = new int [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] ; } return noOfWays [ n ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n ) ) ; } }"}
{"text": "Program untuk mencetak corak lingkaran |  ; Buat baris dan col untuk melintasi baris dan lajur; Pembolehubah untuk menentukan pergerakan r = kanan, l = kiri, d = ke bawah, u = atas; Array untuk matriks; Berikan nilai; suis - kes untuk menentukan indeks seterusnya; Jika betul, pergi ke kanan; jika ditinggalkan, pergi ke kiri; jika naik, naik; jika turun, turun; Semak jika matriks telah mencapai sempadan array; Tambah saiz kiri untuk sempadan seterusnya; Jika 2 putaran telah dibuat, mengurangkan saiz yang ditinggalkan oleh 1; suis - kes untuk memutar pergerakan; jika betul, putar ke bawah; jika turun, putar ke kiri; jika dibiarkan, putar ke atas; jika naik, putar ke kanan; Cetak matriks; Kod pemacu; Dapatkan saiz saiz; Cetak corak lingkaran", "code": "public class GFG { public static void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ; char move = ' r ' ; int matrix [ ] [ ] = new int [ size ] [ size ] ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row ] [ col ] = i ; switch ( move ) { case ' r ' : col += 1 ; break ; case ' l ' : col -= 1 ; break ; case ' u ' : row -= 1 ; break ; case ' d ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' r ' : move = ' d ' ; break ; case ' d ' : move = ' l ' ; break ; case ' l ' : move = ' u ' ; break ; case ' u ' : move = ' r ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; System . out . print ( ( n < 10 ) ? ( n + \" ▁ \" ) : ( n + \" ▁ \" ) ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int size = 5 ; printSpiral ( size ) ; } }"}
{"text": "Cari pemain terakhir untuk dapat membalikkan watak dalam rentetan binari | Program Java untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada pemain A memenangi permainan atau tidak; Kedai saiz kumpulan 0 s; Kedai saiz kumpulan 0 s; Melintasi array; Kenaikan c oleh 1 jika a [i] adalah 0; Jika tidak, tolak saiz dalam array dan tetapkan semula C ke 0; Sekiranya tidak ada substring panjang ganjil yang terdiri daripada 0 s; Sekiranya terdapat hanya 1 substring panjang ganjil yang terdiri hanya 0 s; Jika tidak; Menyimpan saiz substring terbesar dan kedua terbesar 0 s; Melintasi array v []; Jika elemen semasa lebih besar daripada yang pertama, maka kemas kini kedua -dua dan kedua; Jika arr [i] berada di antara pertama dan kedua, maka kemas kini kedua; Sekiranya keadaan itu berpuas hati; Kod pemacu", "code": "import java . util . * ; public class GFG { static void findWinner ( String a , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a . charAt ( i ) == '0' ) { c ++ ; } else { if ( c != 0 ) v . add ( c ) ; c = 0 ; } } if ( c != 0 ) v . add ( c ) ; if ( v . size ( ) == 0 ) { System . out . print ( \" Player ▁ B \" ) ; return ; } if ( v . size ( ) == 1 ) { if ( ( v . get ( 0 ) & 1 ) != 0 ) System . out . print ( \" Player ▁ A \" ) ; else System . out . print ( \" Player ▁ B \" ) ; return ; } int first = Integer . MIN_VALUE ; int second = Integer . MIN_VALUE ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( a . charAt ( i ) > first ) { second = first ; first = a . charAt ( i ) ; } else if ( a . charAt ( i ) > second && a . charAt ( i ) != first ) second = a . charAt ( i ) ; } if ( ( first & 1 ) != 0 && ( first + 1 ) / 2 > second ) System . out . print ( \" Player ▁ A \" ) ; else System . out . print ( \" Player ▁ B \" ) ; } public static void main ( String [ ] args ) { String S = \"1100011\" ; int N = S . length ( ) ; findWinner ( S , N ) ; } }"}
{"text": "Periksa sama ada rentetan kalindromik boleh dibentuk dari rentetan yang diberikan | Program Java untuk memeriksa sama ada rentetan itu adalah K Palindrome atau tidak; Berfungsi untuk memeriksa sama ada rentetan adalah k palindrome atau tidak; Peta kepada kekerapan watak; Semak apabila k diberikan sama seperti panjang rentetan; Menyimpan kekerapan setiap watak dalam peta; Jika k lebih besar daripada saiz maka kembali palsu; Semak bilangan watak yang mempunyai kekerapan ganjil; Jika k kurang daripada bilangan watak frekuensi ganjil maka ia sekali lagi palsu jika tidak benar; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean can_Construct ( String S , int K ) { Map < Character , Integer > m = new HashMap < > ( ) ; int p = 0 ; if ( S . length ( ) == K ) return true ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) m . put ( S . charAt ( i ) , m . getOrDefault ( S . charAt ( i ) , 0 ) + 1 ) ; if ( K > S . length ( ) ) return false ; else { for ( Integer h : m . values ( ) ) { if ( h % 2 != 0 ) p = p + 1 ; } } if ( K < p ) return false ; return true ; } public static void main ( String [ ] args ) { String S = \" annabelle \" ; int K = 4 ; if ( can_Construct ( S , K ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Program Java untuk mencari awalan biasa terpanjang; Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; Tukar ke huruf kecil menggunakan fungsi Tolowercase; Membandingkan kedua -dua menggunakan fungsi terbina; Jika rentetan adalah sama, kembali benar sebaliknya palsu; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "class GFG { static boolean equalIgnoreCase ( String str1 , String str2 ) { int i = 0 ; str1 = str1 . toLowerCase ( ) ; str2 = str2 . toLowerCase ( ) ; int x = str1 . compareTo ( str2 ) ; return x == 0 ; } static void equalIgnoreCaseUtil ( String str1 , String str2 ) { boolean res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) System . out . println ( \" Same \" ) ; else System . out . println ( \" Not ▁ Same \" ) ; } public static void main ( String [ ] args ) { String str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; } }"}
{"text": "Program untuk mencetak corak langkah | Program Java untuk mencetak corak langkah; berfungsi untuk mencetak langkah -langkah; mengisytiharkan bendera; melintasi semua watak dalam rentetan; Jika nilai x ialah 0 .. Kemudian kita mesti kenaikan sehingga n ... Tetapkan bendera kepada Benar; Jika nilai x adalah n - 1 maka kita mesti menurunkan sehingga 0 ... Tetapkan bendera sebagai palsu; cetak x * s; memeriksa sama ada untuk kenaikan atau penurunan x; Kod pemacu; Dapatkan rentetan dan nombor n; memanggil fungsi", "code": "import java . util . * ; class solution { static void steps ( String str , int n ) { boolean flag = false ; int x = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( x == 0 ) flag = true ; if ( x == n - 1 ) flag = false ; for ( int j = 0 ; j < x ; j ++ ) System . out . print ( \" * \" ) ; System . out . print ( str . charAt ( i ) + \"NEW_LINE\"); if ( flag == true ) x ++ ; else x -- ; } } public static void main ( String args [ ] ) { int n = 4 ; String str = \" GeeksForGeeks \" ; System . out . println ( \" String : ▁ \" + str ) ; System . out . println ( \" Max ▁ Length ▁ of ▁ Steps : ▁ \" + n ) ; steps ( str , n ) ; } }"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program Java untuk mengira frekuensi item array; Tandakan semua elemen array seperti yang tidak dikunjungi; Melintasi unsur -unsur array dan kekerapan kiraan; Langkau elemen ini jika sudah diproses; Kekerapan kiraan; Kod pemacu", "code": "import java . util . * ; class GFG { static void countFreq ( int arr [ ] , int n ) { boolean [ ] visited = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } System . out . println ( arr [ i ] + \" ▁ \" + count ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 } ; int n = arr . length ; countFreq ( arr , n ) ; } }"}
{"text": "Semak pembahagian rentetan binari dengan 2 ^ k | Pelaksanaan Java untuk memeriksa sama ada nombor binari yang diberi sama rata dengan 2 ^ k atau tidak; fungsi untuk memeriksa sama ada nombor binari yang diberikan sama rata dengan 2 ^ k atau tidak; kiraan bilangan 0 dari yang terakhir; Jika Count = k, nombor sama rata, jadi pulangan benar lain palsu; Program pemandu untuk menguji di atas; Contoh pertama; Contoh kedua", "code": "class GFG { static boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ; return ( c == k ) ; } public static void main ( String args [ ] ) { String str1 = \"10101100\" ; int k = 2 ; if ( isDivisible ( str1 , k ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; String str2 = \"111010100\" ; k = 2 ; if ( isDivisible ( str2 , k ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Semak jika ada anagram rentetan adalah palindrome atau tidak | Program Java untuk memeriksa sama ada anagram rentetan adalah palindrome atau tidak; berfungsi untuk memeriksa sama ada watak rentetan boleh membentuk palindrome; Buat array kiraan dan mulakan semua nilai sebagai 0; Bagi setiap aksara dalam rentetan input, kiraan kenaikan dalam array kiraan yang sepadan; Mengira watak -watak yang ganjil; Kembali benar jika kiraan ganjil adalah 0 atau 1 ,; Program pemacu untuk diuji untuk mencetak cetakan", "code": "public class GFG { static final int NO_OF_CHARS = 256 ; static boolean canFormPalindrome ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str . charAt ( i ) ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) != 0 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; } public static void main ( String args [ ] ) { System . out . println ( canFormPalindrome ( \" geeksforgeeks \" ) ? \" Yes \" : \" No \" ) ; System . out . println ( canFormPalindrome ( \" geeksogeeks \" ) ? \" Yes \" : \" No \" ) ; } }"}
{"text": "Program untuk memeriksa sama ada input adalah integer atau rentetan | Program Java untuk memeriksa sama ada rentetan yang diberikan adalah integer yang sah; Pulangan benar jika s adalah nombor lain palsu; Kod pemacu; Menyimpan input dalam rentetan; Fungsi pulangan 1 jika semua elemen berada dalam julat '0 ~ »~ 9'; Fungsi pulangan 0 jika input bukan integer", "code": "import java . io . * ; public class GFG { static boolean isNumber ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( Character . isDigit ( s . charAt ( i ) ) == false ) return false ; return true ; } static public void main ( String [ ] args ) { String str = \"6790\" ; if ( isNumber ( str ) ) System . out . println ( \" Integer \" ) ; else System . out . println ( \" String \" ) ; } }"}
{"text": "Cetak terbalik rentetan menggunakan rekursi | Program Java untuk membalikkan rentetan menggunakan rekursi; Berfungsi untuk mencetak terbalik rentetan lulus; Program pemacu untuk menguji fungsi di atas", "code": "class StringReverse { void reverse ( String str ) { if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System . out . println ( str ) ; else { System . out . print ( str . charAt ( str . length ( ) - 1 ) ) ; reverse ( str . substring ( 0 , str . length ( ) - 1 ) ) ; } } public static void main ( String [ ] args ) { String str = \" Geeks ▁ for ▁ Geeks \" ; StringReverse obj = new StringReverse ( ) ; obj . reverse ( str ) ; } }"}
{"text": "Kebarangkalian mengedarkan bola yang diberikan kepada dua bahagian yang mempunyai kiraan yang sama dengan warna yang berbeza | Program Java untuk pendekatan di atas; Menyimpan kiraan warna yang berbeza dalam Box1; Menyimpan kiraan warna yang berbeza dalam Box2; Fungsi untuk mengira kebarangkalian yang diperlukan; Hitung faktorial dari [1, 10]; Berikan semua bola yang berbeza ke kotak kedua; Jumlah bola; Hitung jumlah bola; Jika k adalah nombor ganjil; Jumlah cara mengedarkan bola dalam dua bahagian yang sama; Bilangan cara yang diperlukan; Mengembalikan kebarangkalian yang diperlukan; Fungsi untuk mengira jumlah bilangan pengagihan yang mungkin memenuhi syarat yang diberikan; Jika bola yang digunakan adalah sama dengan k / 2; Jika Box1 sama dengan Box2; Keadaan asas; Menyimpan bilangan cara mengedarkan bola yang tinggal tanpa termasuk bola semasa dalam Box1; Kotak kenaikan1 dengan satu; Melangkah ke atas julat [1, bola [i]]; Jika semua bola pergi ke Box1, kemudian menurunkan Box2 dengan satu; Jumlah cara memilih bola J; Kenaikan res dengan jumlah cara yang sah untuk mengedarkan bola yang tinggal; Box1 box1 oleh satu; Box2 Box2 oleh 1; Fungsi untuk mengira faktorial n; Kes asas; Melangkah ke atas julat [1, n]; Fungsi untuk mengira NCR; Kod pemacu; Cetak hasilnya", "code": "import java . io . * ; import java . util . * ; class GFG { static int box1 = 0 ; static int box2 = 0 ; static int [ ] fact = new int [ 11 ] ; public static double getProbability ( int [ ] balls ) { factorial ( 10 ) ; box2 = balls . length ; int K = 0 ; for ( int i = 0 ; i < balls . length ; i ++ ) K += balls [ i ] ; if ( K % 2 == 1 ) return 0 ; long all = comb ( K , K / 2 ) ; long validPermutations = validPermutations ( K / 2 , balls , 0 , 0 ) ; return ( double ) validPermutations / all ; } static long validPermutations ( int n , int [ ] balls , int usedBalls , int i ) { if ( usedBalls == n ) { return box1 == box2 ? 1 : 0 ; } if ( i >= balls . length ) return 0 ; long res = validPermutations ( n , balls , usedBalls , i + 1 ) ; box1 ++ ; for ( int j = 1 ; j <= balls [ i ] ; j ++ ) { if ( j == balls [ i ] ) box2 -- ; long combinations = comb ( balls [ i ] , j ) ; res += combinations * validPermutations ( n , balls , usedBalls + j , i + 1 ) ; } box1 -- ; box2 ++ ; return res ; } static void factorial ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; } static long comb ( int n , int r ) { long res = fact [ n ] / fact [ r ] ; res /= fact [ n - r ] ; return res ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 1 } ; int N = 4 ; System . out . println ( getProbability ( arr ) ) ; } }"}
{"text": "Kawasan n | Program Java untuk mencari kawasan poligon biasa dengan radius yang diberikan; Berfungsi untuk mencari kawasan poligon biasa; Sampingan dan jejari tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu", "code": "import java . util . * ; class GFG { static double polyarea ( double n , double r ) { if ( r < 0 && n < 0 ) return - 1 ; double A = ( ( r * r * n ) * Math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; } public static void main ( String [ ] args ) { float r = 9 , n = 6 ; System . out . println ( polyarea ( n , r ) ) ; } }"}
{"text": "Semak jika garis pada 45 darjah boleh membahagikan pesawat ke dalam dua bahagian berat yang sama |  ; Memeriksa jika satah boleh dibahagikan dengan garis pada 45 darjah supaya jumlah berat adalah sama; Putar setiap titik sebanyak 45 darjah dan mengira jumlah awalan. Juga, mencari koordinat X maksimum dan minimum; menyimpan jumlah berat sehingga titik x - y; Mencari Jumlah awalan; Line melewati saya, jadi ia tidak jatuh ke kiri atau kanan. ; Kod yang didorong", "code": "import java . util . * ; class GFG { static void is_partition_possible ( int n , int x [ ] , int y [ ] , int w [ ] ) { Map < Integer , Integer > weight_at_x = new HashMap < Integer , Integer > ( ) ; int max_x = ( int ) - 2e3 , min_x = ( int ) 2e3 ; for ( int i = 0 ; i < n ; i ++ ) { int new_x = x [ i ] - y [ i ] ; max_x = Math . max ( max_x , new_x ) ; min_x = Math . min ( min_x , new_x ) ; if ( weight_at_x . containsKey ( new_x ) ) { weight_at_x . put ( new_x , weight_at_x . get ( new_x ) + w [ i ] ) ; } else { weight_at_x . put ( new_x , w [ i ] ) ; } } Vector < Integer > sum_till = new Vector < > ( ) ; sum_till . add ( 0 ) ; for ( int s = min_x ; s <= max_x ; s ++ ) { if ( weight_at_x . get ( s ) == null ) sum_till . add ( sum_till . lastElement ( ) ) ; else sum_till . add ( sum_till . lastElement ( ) + weight_at_x . get ( s ) ) ; } int total_sum = sum_till . lastElement ( ) ; int partition_possible = 0 ; for ( int i = 1 ; i < sum_till . size ( ) ; i ++ ) { if ( sum_till . get ( i ) == total_sum - sum_till . get ( i ) ) partition_possible = 1 ; if ( sum_till . get ( i - 1 ) == total_sum - sum_till . get ( i ) ) partition_possible = 1 ; } System . out . printf ( partition_possible == 1 ? \"YES \" ▁ : ▁ \" NO \"); } public static void main ( String [ ] args ) { int n = 3 ; int x [ ] = { - 1 , - 2 , 1 } ; int y [ ] = { 1 , 1 , - 1 } ; int w [ ] = { 3 , 1 , 4 } ; is_partition_possible ( n , x , y , w ) ; } }"}
{"text": "Cerun tegak lurus ke garisan | Program Java mencari cerun garis tegak lurus; Berfungsi untuk mencari cerun garis lain; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static double findPCSlope ( double m ) { return - 1.0 / m ; } public static void main ( String [ ] args ) { double m = 2.0 ; System . out . println ( findPCSlope ( m ) ) ; } }"}
{"text": "Program untuk mencari kawasan segmen bulat | Program Java untuk mencari kawasan segmen bulatan; Fungsi untuk mencari kawasan segmen; Mengira kawasan sektor; Mengira kawasan segitiga; Fungsi pemacu", "code": "class GFG { static float pi = 3.14159f ; static float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; } public static void main ( String [ ] args ) { float radius = 10.0f , angle = 90.0f ; System . out . println ( \" Area ▁ of ▁ minor ▁ segment ▁ = ▁ \" + area_of_segment ( radius , angle ) ) ; System . out . println ( \" Area ▁ of ▁ major ▁ segment ▁ = ▁ \" + area_of_segment ( radius , ( 360 - angle ) ) ) ; } }"}
{"text": "Kawasan Sektor Pekeliling | Program Java untuk mencari kawasan sektor; Mengira kawasan sektor; Kod pemacu", "code": "class GFG { static void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) System . out . println ( \" Angle ▁ not ▁ possible \" ) ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; System . out . println ( sector ) ; } } public static void main ( String [ ] args ) { double radius = 9 ; double angle = 60 ; SectorArea ( radius , angle ) ; } }"}
{"text": "Buat dua nombor sama dengan mendarab dengan faktor utama mereka bilangan minimum kali | Program Java untuk pendekatan di atas; Semuanya membahagikan 0; Fungsi untuk mengira jumlah faktor utama dengan faktor utama mereka; Melangkah sementara nombornya juga; Mengurangkan separuh; Berulang sehingga sqrt (n); Melangkah sementara n mempunyai faktor i; Mengeluarkan satu faktor i; Berfungsi untuk mengira bilangan faktor; Cari GCD; Cari gandaan yang tersisa di x dan y; Cari faktor utama pelbagai kiri dalam x dan y; Memulakan ans; Semak sama ada mungkin untuk mendapatkan x atau tidak; Periksa sama ada mungkin untuk mendapatkan y atau tidak; Kembali utama ans; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "import java . util . * ; public class Main { static int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } static HashMap < Integer , Integer > PrimeFactor ( int N ) { HashMap < Integer , Integer > primef = new HashMap < Integer , Integer > ( ) ; while ( N % 2 == 0 ) { if ( primef . containsKey ( 2 ) ) { primef . put ( 2 , primef . get ( 2 ) + 1 ) ; } else { primef . put ( 2 , 1 ) ; } N = N / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( N ) ; i ++ ) { while ( N % i == 0 ) { if ( primef . containsKey ( i ) ) { primef . put ( i , primef . get ( i ) + 1 ) ; } else { primef . put ( i , 1 ) ; } N = N / 2 ; } } if ( N > 2 ) { primef . put ( N , 1 ) ; } return primef ; } static int CountToMakeEqual ( int X , int Y ) { int gcdofXY = gcd ( X , Y ) ; int newX = Y / gcdofXY ; int newY = X / gcdofXY ; HashMap < Integer , Integer > primeX = PrimeFactor ( newX ) ; HashMap < Integer , Integer > primeY = PrimeFactor ( newY ) ; int ans = 0 ; for ( Map . Entry keys : primeX . entrySet ( ) ) { if ( X % ( int ) keys . getKey ( ) != 0 ) { return - 1 ; } ans += primeX . get ( keys . getKey ( ) ) ; } for ( Map . Entry keys : primeY . entrySet ( ) ) { if ( Y % ( int ) keys . getKey ( ) != 0 ) { return - 1 ; } ans += primeY . get ( keys . getKey ( ) ) ; } return ans ; } public static void main ( String [ ] args ) { int X = 36 ; int Y = 48 ; int ans = CountToMakeEqual ( X , Y ) ; System . out . println ( ans ) ; } }"}
{"text": "Buat segmen yang diberikan bukan | Program Java untuk pendekatan di atas; Menyimpan butiran segmen; Berfungsi untuk memeriksa sama ada graf adalah bipartite atau tidak; Tanda nod sumber seperti yang dikunjungi; Tolak puncak sumber dalam barisan; Dapatkan bahagian depan barisan; Berikan warna kepada nod yang muncul; Melintasi senarai addacency nod u; Jika mana -mana nod dikunjungi & warna yang berbeza telah diberikan, maka kembali palsu; Tetapkan dikunjungi [x]; Tolak nod X ke dalam barisan; Kemas kini warna nod; Jika graf adalah bipartite; Berfungsi untuk menambah kelebihan antara nod U dan V; Berfungsi untuk memeriksa sama ada tugasan arah boleh dilakukan untuk semua segmen, supaya mereka tidak bersilang selepas jangka masa yang panjang; Menyimpan senarai adjacency graf yang dicipta; Memulakan; Menjana semua pasangan yang mungkin; Jika segmen tidak bertindih; Jika tidak, segmen bertindih; Jika kedua -dua segmen mempunyai kelajuan yang sama, maka tambahkan kelebihan; Pastikan jejak nod yang dikunjungi; Berulang untuk semua nod yang mungkin; Semak sama ada graf adalah bipartite atau tidak; Jika graf adalah bipartite; Kod pemacu", "code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static class Node { int L , R , V ; Node ( int L , int R , int V ) { this . L = L ; this . R = R ; this . V = V ; } } static boolean check ( ArrayList < Integer > Adj [ ] , int Src , int N , boolean visited [ ] ) { int color [ ] = new int [ N ] ; visited [ Src ] = true ; ArrayDeque < Integer > q = new ArrayDeque < > ( ) ; q . addLast ( Src ) ; while ( ! q . isEmpty ( ) ) { int u = q . removeFirst ( ) ; int Col = color [ u ] ; for ( int x : Adj [ u ] ) { if ( visited [ x ] == true && color [ x ] == Col ) { return false ; } else if ( visited [ x ] == false ) { visited [ x ] = true ; q . addLast ( x ) ; color [ x ] = 1 - Col ; } } } return true ; } static void addEdge ( ArrayList < Integer > Adj [ ] , int u , int v ) { Adj [ u ] . add ( v ) ; Adj [ v ] . add ( u ) ; } static void isPossible ( Node Arr [ ] , int N ) { @ SuppressWarnings ( \" unchecked \" ) ArrayList < Integer > [ ] Adj = ( ArrayList < Integer > [ ] ) new ArrayList [ N ] ; for ( int i = 0 ; i < N ; i ++ ) Adj [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] . R < Arr [ j ] . L Arr [ i ] . L > Arr [ j ] . R ) { continue ; } else { if ( Arr [ i ] . V == Arr [ j ] . V ) { addEdge ( Adj , i , j ) ; } } } } boolean visited [ ] = new boolean [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( visited [ i ] == false && Adj [ i ] . size ( ) > 0 ) { if ( check ( Adj , i , N , visited ) == false ) { System . out . println ( \" No \" ) ; return ; } } } System . out . println ( \" Yes \" ) ; } public static void main ( String [ ] args ) { Node arr [ ] = { new Node ( 5 , 7 , 2 ) , new Node ( 4 , 6 , 1 ) , new Node ( 1 , 5 , 2 ) , new Node ( 6 , 5 , 1 ) } ; int N = arr . length ; isPossible ( arr , N ) ; } }"}
{"text": "Menjana semua nombor sehingga n dalam urutan leksikografi | Program Java untuk pendekatan di atas; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { public static void lexNumbers ( int n ) { List < Integer > sol = new ArrayList < > ( ) ; dfs ( 1 , n , sol ) ; System . out . println ( sol ) ; } public static void dfs ( int temp , int n , List < Integer > sol ) { if ( temp > n ) return ; sol . add ( temp ) ; dfs ( temp * 10 , n , sol ) ; if ( temp % 10 != 9 ) dfs ( temp + 1 , n , sol ) ; } public static void main ( String [ ] args ) { int n = 15 ; lexNumbers ( n ) ; } }"}
{"text": "Bilangan swap minimum yang diperlukan untuk menyusun pelbagai nombor N pertama | Program Java untuk mencari bilangan swap minimum yang diperlukan untuk menyusun array yang diberikan; Berfungsi untuk mencari swap minimum; Pembolehubah kiraan permulaan; Jika elemen semasa tidak berada di kedudukan yang betul; Swap elemen semasa dengan kedudukan yang betul dari elemen itu; Kenaikan untuk indeks seterusnya apabila elemen semasa berada pada kedudukan yang betul; Kod pemacu; Berfungsi untuk mencari swap minimum", "code": "import java . io . * ; import java . util . * ; class GfG { static int minimumSwaps ( int [ ] arr ) { int count = 0 ; int i = 0 ; while ( i < arr . length ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 1 , 5 } ; System . out . println ( minimumSwaps ( arr ) ) ; } }"}
{"text": "Gabungkan K -Sorted Doubly Linked List dalam Order Sorted | Program Java untuk menggabungkan senarai yang disusun dua kali ganda dalam urutan yang disusun; Nod senarai yang dipautkan; Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala DLL dan int, tambah nod baru pada akhir; Memperuntukkan nod; Masukkan data; Nod baru ini akan menjadi nod terakhir, jadi buatlah seterusnya sebagai batal; Jika senarai yang dipautkan kosong, maka buat nod baru sebagai kepala; Lain melintasi sehingga nod terakhir; Tukar nod terakhir yang akan datang; Buat nod terakhir seperti sebelumnya dari nod baru; Berfungsi untuk mencetak senarai; Jalankan semasa gelung melainkan nod menjadi batal; Berfungsi untuk menggabungkan dua senarai dikaitkan dua kali ganda; Jika mana -mana senarai kosong; Perbandingan data dua senarai yang dipautkan; Simpan penunjuk kepala sebelum menggabungkan senarai; Menukar penunjuk antara dua senarai untuk penggabungan; Menukar penunjuk antara dua senarai untuk penggabungan; Syarat untuk memeriksa sama ada sesiapa yang menyenaraikan tidak berakhir; Kembali penunjuk kepala senarai yang digabungkan; Berfungsi untuk menggabungkan semua senarai yang disusun dalam susunan yang disusun; Panggilan fungsi untuk menggabungkan dua senarai dikaitkan berganda yang disusun pada satu masa; Kembali akhir disusun senarai dua kali ganda; Kod pemacu; Gelung untuk memulakan semua senarai untuk kosong; Buat senarai senarai dua kali ganda pertama1. 1 <=> 5 <=> 9; Buat senarai dikaitkan dua kali ganda kedua2. 2 <=> 3 <=> 7 <=> 12; Buat senarai dikaitkan dua kali ganda 3 senarai3. 8 <=> 11 <=> 13 <=> 18; Panggilan fungsi untuk menggabungkan semua senarai dikaitkan dua kali ganda dalam urutan yang disusun; Cetak senarai disusun akhir", "code": "class GFG { static class Node { int data ; Node next ; Node prev ; } ; static Node append ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; Node last = head_ref ; new_node . data = new_data ; new_node . next = null ; if ( head_ref == null ) { new_node . prev = null ; head_ref = new_node ; return head_ref ; } while ( last . next != null ) last = last . next ; last . next = new_node ; new_node . prev = last ; return head_ref ; } static void printList ( Node node ) { Node last ; while ( node != null ) { System . out . print ( node . data + \" ▁ \" ) ; last = node ; node = node . next ; } } static Node mergeList ( Node p , Node q ) { Node s = null ; if ( p == null q == null ) { return ( p == null ? q : p ) ; } if ( p . data < q . data ) { p . prev = s ; s = p ; p = p . next ; } else { q . prev = s ; s = q ; q = q . next ; } Node head = s ; while ( p != null && q != null ) { if ( p . data < q . data ) { s . next = p ; p . prev = s ; s = s . next ; p = p . next ; } else { s . next = q ; q . prev = s ; s = s . next ; q = q . next ; } } if ( p == null ) { s . next = q ; q . prev = s ; } if ( q == null ) { s . next = p ; p . prev = s ; } return head ; } static Node mergeAllList ( Node head [ ] , int k ) { Node finalList = null ; for ( int i = 0 ; i < k ; i ++ ) { finalList = mergeList ( finalList , head [ i ] ) ; } return finalList ; } public static void main ( String args [ ] ) { int k = 3 ; Node head [ ] = new Node [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { head [ i ] = null ; } head [ 0 ] = append ( head [ 0 ] , 1 ) ; head [ 0 ] = append ( head [ 0 ] , 5 ) ; head [ 0 ] = append ( head [ 0 ] , 9 ) ; head [ 1 ] = append ( head [ 1 ] , 2 ) ; head [ 1 ] = append ( head [ 1 ] , 3 ) ; head [ 1 ] = append ( head [ 1 ] , 7 ) ; head [ 1 ] = append ( head [ 1 ] , 12 ) ; head [ 2 ] = append ( head [ 2 ] , 8 ) ; head [ 2 ] = append ( head [ 2 ] , 11 ) ; head [ 2 ] = append ( head [ 2 ] , 13 ) ; head [ 2 ] = append ( head [ 2 ] , 18 ) ; Node finalList = mergeAllList ( head , k ) ; printList ( finalList ) ; } }"}
{"text": "Susun Pemilihan Rekursif | Program Java Rekursif untuk menyusun pelbagai menggunakan pilihan pemilihan; Indeks minimum pulangan; Cari minimum elemen yang tinggal; Pulangan minimum semasa dan baki. ; Jenis pemilihan rekursif. N ialah saiz [] dan indeks adalah indeks elemen permulaan. ; Kembali apabila bermula dan saiznya sama; Memanggil fungsi indeks minimum untuk indeks minimum; Bertukar apabila indeks indeks minimum tidak sama; swap; Fungsi pemilihan pilihan rekursif; Kaedah pemacu; Fungsi panggilan; Percetakan Arahan yang disusun", "code": "class Test { static int minIndex ( int a [ ] , int i , int j ) { if ( i == j ) return i ; int k = minIndex ( a , i + 1 , j ) ; return ( a [ i ] < a [ k ] ) ? i : k ; } static void recurSelectionSort ( int a [ ] , int n , int index ) { if ( index == n ) return ; int k = minIndex ( a , index , n - 1 ) ; if ( k != index ) { int temp = a [ k ] ; a [ k ] = a [ index ] ; a [ index ] = temp ; } recurSelectionSort ( a , n , index + 1 ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 1 , 5 , 2 , 7 , 0 } ; recurSelectionSort ( arr , arr . length , 0 ) ; for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } }"}
{"text": "SENARAI SENSI RECURSIVE | Program Java Rekursif untuk jenis penyisipan; Fungsi rekursif untuk menyusun array menggunakan jenis penyisipan; Kes asas; Susun pertama n - 1 elemen; Masukkan elemen terakhir pada kedudukan yang betul dalam array yang disusun. ; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Kaedah Pemandu", "code": "import java . util . Arrays ; public class GFG { static void insertionSortRecursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; insertionSortRecursive ( arr , arr . length ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }"}
{"text": "Susun gelembung rekursif | Program Java untuk pelaksanaan rekursif jenis gelembung; Fungsi untuk melaksanakan jenis gelembung; Kes asas; Satu lulus jenis gelembung. Selepas lulus ini, elemen terbesar dipindahkan (atau bubbled) untuk berakhir. ; swap arr [i], arr [i + 1]; Unsur terbesar ditetapkan, berulang untuk array yang tinggal; Kaedah Pemandu", "code": "import java . util . Arrays ; public class GFG { static void bubbleSort ( int arr [ ] , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } bubbleSort ( arr , n - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; bubbleSort ( arr , arr . length ) ; System . out . println ( \" Sorted ▁ array ▁ : ▁ \" ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }"}
{"text": "Perbezaan maksimum jumlah dua subset dari array | Tetapkan 2 | Pakej apa sahaja yang tidak menulis nama pakej di sini; Menyimpan unsur -unsur positif; Menyimpan unsur -unsur negatif; Menyimpan kiraan 0 s; Jumlah semua nombor positif; Jumlah semua nombor negatif; Melangkah ke atas array; Menyimpan perbezaan; Menyusun nombor positif dalam urutan menaik; Menyusun nombor negatif dalam penurunan urutan; Kes 1: Sertakan nombor positif dan negatif; Letakkan semua nombor dalam subset a dan satu 0 dalam subset b; Letakkan semua nombor dalam subset A kecuali nombor positif terkecil yang dimasukkan ke dalam B; Letakkan semua nombor dalam subset b dan satu 0 dalam subset A; Letakkan nombor negatif terbesar dalam subset A dan baki dalam B; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static int maxSumAfterPartition ( int arr [ ] , int n ) { ArrayList < Integer > pos = new ArrayList < Integer > ( ) ; ArrayList < Integer > neg = new ArrayList < Integer > ( ) ; int zero = 0 ; int pos_sum = 0 ; int neg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { pos . add ( arr [ i ] ) ; pos_sum += arr [ i ] ; } else if ( arr [ i ] < 0 ) { neg . add ( arr [ i ] ) ; neg_sum += arr [ i ] ; } else { zero ++ ; } } int ans = 0 ; Collections . sort ( pos ) ; Collections . sort ( neg ) ; if ( pos . size ( ) > 0 && neg . size ( ) > 0 ) { ans = ( pos_sum - neg_sum ) ; } else if ( pos . size ( ) > 0 ) { if ( zero > 0 ) { ans = ( pos_sum ) ; } else { ans = ( pos_sum - 2 * pos . get ( 0 ) ) ; } } else { if ( zero > 0 ) { ans = ( - 1 * neg_sum ) ; } else { ans = ( neg . get ( 0 ) - ( neg_sum - neg . get ( 0 ) ) ) ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , - 5 , - 7 } ; int n = 5 ; System . out . println ( maxSumAfterPartition ( arr , n ) ) ; } }"}
{"text": "Pecahkan array ke subarrays dengan bitwise maksimum XOR masing -masing bitwise atau nilai masing -masing | Program Java untuk pendekatan di atas; Berfungsi untuk mencari elemen bitwise atau array; Menyimpan nilai maksimum yang dihasilkan dari bitwise XOR; Melintasi array arr []; Mengembalikan nilai maksimum RES; Kod pemacu", "code": "import java . lang . * ; import java . util . * ; class GFG { static int MaxXOR ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 7 } ; int N = arr . length ; System . out . println ( MaxXOR ( arr , N ) ) ; } }"}
{"text": "Kira bilangan unsur biasa antara array yang disusun dan array yang disusun terbalik | Program Java untuk pendekatan di atas; Berfungsi untuk mengira bilangan elemen yang biasa dalam kedua -dua tatasusunan; Digunakan untuk melintasi array A [] dan B [] dari depan dan belakang; Menyimpan kiraan nombor yang biasa dalam kedua -dua array; Jika A [pertama] kurang daripada b [kedua]; Meningkatkan nilai pertama; Jika B [kedua] kurang daripada [pertama]; Menurunkan nilai kedua; A [pertama] adalah sama dengan b [kedua]; Meningkatkan nilai kiraan; Meningkatkan nilai pertama; Menurunkan nilai kedua; Mengembalikan nilai kiraan; Kod pemacu", "code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int countEqual ( int A [ ] , int B [ ] , int N ) { int first = 0 ; int second = N - 1 ; int count = 0 ; while ( first < N && second >= 0 ) { if ( A [ first ] < B [ second ] ) { first ++ ; } else if ( B [ second ] < A [ first ] ) { second -- ; } else { count ++ ; first ++ ; second -- ; } } return count ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 4 , 5 , 8 , 12 , 13 , 17 , 18 , 20 , 22 , 309 , 999 } ; int B [ ] = { 109 , 99 , 68 , 54 , 22 , 19 , 17 , 13 , 11 , 5 , 3 , 1 } ; int N = A . length ; System . out . println ( countEqual ( A , B , N ) ) ; } }"}
{"text": "Pertanyaan untuk mengira nombor palindrome dari julat yang jumlah digitnya adalah nombor utama | Program Java untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada nombor n adalah palindrome atau tidak; Simpan nilai n; Simpan sebaliknya nombor n; Tempatan terbalik dan simpan di res; Jika n adalah sama dengan res, maka kembali benar; Berfungsi untuk mencari jumlah digit nombor n; Menyimpan jumlah digit; Tambah digit terakhir nombor N ke jumlah; Keluarkan digit terakhir dari N; Mengembalikan jumlah yang dihasilkan; Fungsi untuk memeriksa sama ada n adalah perdana atau tidak; Jika saya adalah 1 atau 0, maka kembali palsu; Semak jika saya boleh dibahagikan dengan mana -mana nombor dalam julat [2, n / 2]; Jika n boleh dibahagikan dengan i; Berfungsi untuk mendahului semua nombor sehingga 10 ^ 5 yang palindromik dan jumlah digitnya adalah nombor utama; Melangkah ke atas julat 1 hingga 10 ^ 5; Jika saya adalah nombor palindrome; Menyimpan jumlah digit dalam i; Jika jumlah digit dalam saya adalah nombor utama; Cari jumlah awalan arr []; Fungsi untuk mengira semua nombor dalam julat yang diberikan adalah palindromik dan jumlah digit adalah nombor utama; Fungsi panggilan untuk precompute semua nombor hingga 10 ^ 5; Melintasi pertanyaan yang diberikan Q []; Cetak hasil untuk setiap pertanyaan; Kod pemacu; Panggilan fungsi", "code": "class GFG { static int [ ] arr = new int [ 100005 ] ; static boolean isPalindrome ( int N ) { int temp = N ; int res = 0 ; while ( temp != 0 ) { int rem = temp % 10 ; res = res * 10 + rem ; temp /= 10 ; } if ( res == N ) { return true ; } else { return false ; } } static int sumOfDigits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N /= 10 ; } return sum ; } static boolean isPrime ( int n ) { if ( n <= 1 ) { return false ; } for ( int i = 2 ; i <= n / 2 ; ++ i ) { if ( n % i == 0 ) return false ; } return true ; } static void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { if ( isPalindrome ( i ) ) { int sum = sumOfDigits ( i ) ; if ( isPrime ( sum ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } else arr [ i ] = 0 ; } for ( int i = 1 ; i <= 100000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } } static void countNumbers ( int [ ] [ ] Q , int N ) { precompute ( ) ; for ( int i = 0 ; i < N ; i ++ ) { System . out . println ( ( arr [ Q [ i ] [ 1 ] ] - arr [ Q [ i ] [ 0 ] - 1 ] ) ) ; } } public static void main ( String [ ] args ) { int [ ] [ ] Q = { { 5 , 9 } , { 1 , 101 } } ; int N = Q . length ; countNumbers ( Q , N ) ; } }"}
{"text": "Nombor terkecil lebih besar daripada atau sama dengan N yang mempunyai jumlah digit tidak melebihi s | Program Java untuk pendekatan di atas; Fungsi untuk mengira jumlah digit n; Berfungsi untuk mencari integer yang paling kecil yang memenuhi syarat yang diberikan; Jika jumlah digit sudah lebih kecil daripada S; Memulakan pembolehubah; Mencari digit kth terakhir; Tambah baki untuk membuat digit 0; Jika jumlah digit tidak melebihi s; Kemas kini k; Kod pemacu; Diberikan n dan s; Panggilan fungsi", "code": "import java . io . * ; class GFG { static int sum ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; } static int smallestNumber ( int n , int s ) { if ( sum ( n ) <= s ) { return n ; } int ans = n , k = 1 ; for ( int i = 0 ; i < 9 ; ++ i ) { int digit = ( ans / k ) % 10 ; int add = k * ( ( 10 - digit ) % 10 ) ; ans += add ; if ( sum ( ans ) <= s ) { break ; } k *= 10 ; } return ans ; } public static void main ( String [ ] args ) { int N = 3 , S = 2 ; System . out . println ( smallestNumber ( N , S ) ) ; } }"}
{"text": "Memaksimumkan kiraan penurunan seterusnya berturut -turut dari array | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari bilangan maksimum bilangan berikutnya yang diperlukan; HashMap untuk menyimpan bilangan anak panah yang tersedia dengan ketinggian anak panah sebagai kunci; Menyimpan kiraan maksimum kemungkinan berikutnya; Menyimpan kiraan kemungkinan seterusnya; Semak jika elemen saya boleh menjadi sebahagian daripada mana -mana berikutnya; Kiraan seterusnya mungkin dengan arr [i] sebagai elemen seterusnya; Jika lebih daripada satu berikutnya wujud; Termasuk arr [i] dalam berikutnya; Jika tidak; Meningkatkan kiraan seterusnya dengan ARR [i] - 1 sebagai elemen seterusnya; Mulakan berikutnya baru; Meningkatkan kiraan seterusnya dengan ARR [i] - 1 sebagai elemen seterusnya; Kembalikan jawapannya; Kod pemacu", "code": "import java . util . * ; class GFG { static int maxSubsequences ( int arr [ ] , int n ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { count = map . get ( arr [ i ] ) ; if ( count > 1 ) { map . put ( arr [ i ] , count - 1 ) ; } else map . remove ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) map . put ( arr [ i ] - 1 , map . getOrDefault ( arr [ i ] - 1 , 0 ) + 1 ) ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) map . put ( arr [ i ] - 1 , map . getOrDefault ( arr [ i ] - 1 , 0 ) + 1 ) ; } } return maxCount ; } public static void main ( String [ ] args ) { int n = 5 ; int arr [ ] = { 4 , 5 , 2 , 1 , 4 } ; System . out . println ( maxSubsequences ( arr , n ) ) ; } }"}
{"text": "Keluarkan kejadian pertama dan terakhir yang diberikan dari rentetan | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk menghapuskan kejadian pertama dan terakhir dari watak yang diberikan dari rentetan yang diberikan; Melintasi rentetan yang diberikan dari awal; Jika ch dijumpai; Melintasi rentetan yang diberikan dari hujungnya; Jika ch dijumpai; Kod pemacu", "code": "class GFG { static String removeOcc ( String s , char ch ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ch ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; break ; } } for ( int i = s . length ( ) - 1 ; i > - 1 ; i -- ) { if ( s . charAt ( i ) == ch ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; break ; } } return s ; } public static void main ( String [ ] args ) { String s = \" hello ▁ world \" ; char ch = ' l ' ; System . out . print ( removeOcc ( s , ch ) ) ; } }"}
{"text": "Langkah -langkah minimum untuk meningkatkan dan mengurangkan array untuk mencapai 0 atau n | Program Java untuk pendekatan di atas; Fungsi yang mendapati langkah -langkah minimum untuk mencapai 0 atau n untuk peningkatan array yang semakin meningkat dan menurun; Memulakan pemboleh ubah untuk mencari elemen minimum; Cari elemen minimum dalam peningkatan [] array; Memulakan pembolehubah untuk mencari elemen maksimum; Cari elemen maksimum dalam penurunan [] array; Cari langkah minimum; Cetak langkah minimum; Kod pemacu; Diberikan n; Memandangkan peningkatan dan penurunan array; Panggilan fungsi", "code": "import java . util . * ; public class GFG { public static void minSteps ( int N , int [ ] increasing , int [ ] decreasing ) { int min = Integer . MAX_VALUE ; for ( int i : increasing ) { if ( min > i ) min = i ; } int max = Integer . MIN_VALUE ; for ( int i : decreasing ) { if ( max < i ) max = i ; } int minSteps = Math . max ( max , N - min ) ; System . out . println ( minSteps ) ; } public static void main ( String [ ] args ) { int N = 7 ; int increasing [ ] = { 3 , 5 } ; int decreasing [ ] = { 6 } ; minSteps ( N , increasing , decreasing ) ; } }"}
{"text": "Bilangan minimum swap bersebelahan yang diperlukan untuk menukar permutasi kepada permutasi lain dengan keadaan yang diberikan | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan swap minimum; Array baru untuk menukar kepada pengindeksan berasaskan 1; Menyimpan swap; Semak sama ada kedudukan 'X'; Kes sudut; Swap; Cetak swap minimum; Kod pemacu; Diberi nombor n; Diberi permutasi nombor N; Panggilan fungsi", "code": "import java . io . * ; class GFG { static void solve ( int P [ ] , int n ) { int arr [ ] = new int [ n + 1 ] ; arr [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i + 1 ] = P [ i ] ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { int t = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ i ] ; arr [ i ] = t ; cnt ++ ; } } if ( arr [ n ] == n ) { int t = arr [ n - 1 ] ; arr [ n - 1 ] = arr [ n ] ; arr [ n ] = t ; cnt ++ ; } System . out . println ( cnt ) ; } public static void main ( String [ ] args ) { int N = 9 ; int P [ ] = new int [ ] { 1 , 2 , 4 , 9 , 5 , 8 , 7 , 3 , 6 } ; solve ( P , N ) ; } }"}
{"text": "Count of Prima yang menarik sehingga n | Program Java untuk mencari bilangan prima yang menarik sehingga n. ; Berfungsi untuk mencari semua nombor utama; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaan sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Mengemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat itu; Simpan semua nombor utama; Berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Untuk menyimpan semua prima; Untuk menyimpan semua prima interset; Simpan semua dataran yang sempurna; Simpan semua quadruples yang sempurna; Simpan semua prima interset; Kembali kiraan prima interset; Kod pemacu", "code": "import java . util . * ; class GFG { static void SieveOfEratosthenes ( int n , HashSet < Integer > allPrimes ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . add ( p ) ; } static int countInterestingPrimes ( int n ) { HashSet < Integer > allPrimes = new HashSet < Integer > ( ) ; SieveOfEratosthenes ( n , allPrimes ) ; HashSet < Integer > intersetingPrimes = new HashSet < Integer > ( ) ; Vector < Integer > squares = new Vector < Integer > ( ) , quadruples = new Vector < Integer > ( ) ; for ( int i = 1 ; i * i <= n ; i ++ ) { squares . add ( i * i ) ; } for ( int i = 1 ; i * i * i * i <= n ; i ++ ) { quadruples . add ( i * i * i * i ) ; } for ( int a : squares ) { for ( int b : quadruples ) { if ( allPrimes . contains ( a + b ) ) intersetingPrimes . add ( a + b ) ; } } return intersetingPrimes . size ( ) ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . print ( countInterestingPrimes ( N ) ) ; } }"}
{"text": "Semak jika array adalah array gelombang | Kod Java untuk memeriksa sama ada array adalah array gelombang; Fungsi untuk memeriksa sama ada array adalah array gelombang arr: array input n: saiz array; Semak borang gelombang * jika arr [1] lebih besar daripada corak kiri dan kanan * yang sama akan diikuti oleh seluruh elemen *, corak terbalik lain * akan diikuti oleh unsur -unsur array; Semak elemen terakhir; Semak elemen terakhir; Kod pemacu; Array", "code": "public class GFG { static boolean isWaveArray ( int arr [ ] , int n ) { boolean result = true ; if ( arr [ 1 ] > arr [ 0 ] && arr [ 1 ] > arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] <= arr [ n - 2 ] ) { result = false ; } } } else if ( arr [ 1 ] < arr [ 0 ] && arr [ 1 ] < arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { result = false ; } } } return result ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 2 , 4 } ; int n = arr . length ; if ( isWaveArray ( arr , n ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text": "Mengira urutan yang berbeza yang diperoleh dengan menggantikan semua elemen subarray yang mempunyai unsur -unsur pertama dan terakhir yang sama dengan elemen pertama sebilangan kali | Program Java untuk pendekatan di atas; Fungsi untuk mengira bilangan urutan yang memenuhi kriteria yang diberikan; Menyimpan indeks kejadian terakhir elemen; Memulakan array untuk menyimpan bilangan urutan yang berbeza yang mungkin panjang i; Kes asas; Sekiranya tiada operasi digunakan pada elemen ITH; Jika operasi digunakan pada elemen ITH; Mengemas kini kejadian terakhir Curele; Akhirnya, cetak jawapannya", "code": "import java . io . * ; class GFG { static void countPossiblities ( int arr [ ] , int n ) { int [ ] lastOccur = new int [ 100000 ] ; for ( int i = 0 ; i < n ; i ++ ) { lastOccur [ i ] = - 1 ; } int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int curEle = arr [ i - 1 ] ; dp [ i ] = dp [ i - 1 ] ; if ( lastOccur [ curEle ] != - 1 & lastOccur [ curEle ] < i - 1 ) { dp [ i ] += dp [ lastOccur [ curEle ] ] ; } lastOccur [ curEle ] = i ; } System . out . println ( dp [ n ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 1 , 2 , 2 } ; int N = arr . length ; countPossiblities ( arr , N ) ; } }"}
{"text": "Jumlah maksimum yang mungkin dari matriks yang diberikan dengan melaksanakan operasi yang diberikan | Program Java untuk pendekatan di atas; Berfungsi untuk mencetak jumlah maksimum; Jadual DP; Memulakan array DP dengan 0 s; Kes asas; Melintasi setiap lajur; Kemas kini jawapan untuk kedua -dua baris; Cetak jumlah maksimum; Kod pemacu; Diberikan array; Bilangan lajur; Panggilan fungsi", "code": "import java . io . * ; import java . util . * ; class GFG { static void maxSum ( int [ ] [ ] arr , int n , int m ) { int [ ] [ ] dp = new int [ n ] [ m + 1 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] ; dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] ; for ( int j = m - 2 ; j >= 0 ; j -- ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i ] [ j ] = Math . max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) ; } else { dp [ i ] [ j ] = Math . max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) ; } } } System . out . println ( Math . max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ) ; } public static void main ( String [ ] args ) { int [ ] [ ] arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ; int N = arr [ 0 ] . length ; maxSum ( arr , 2 , N ) ; } }"}
{"text": "Jumlah maksimum yang mungkin dari matriks yang diberikan dengan melaksanakan operasi yang diberikan | Kod Java untuk pendekatan di atas; Fungsi untuk mencetak jumlah maksimum yang mungkin dengan memilih kebanyakan elemen dari setiap lajur sehingga tiada pasangan berturut -turut dipilih dari satu baris; Memulakan pembolehubah; Melintasi setiap lajur; Jawapan cetak; Kod pemacu; Lajur nombor", "code": "import java . io . * ; import java . util . * ; class GFG { static void maxSum ( int [ ] [ ] arr , int n ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = Math . max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = Math . max ( r2 , temp + arr [ 1 ] [ i ] ) ; } System . out . println ( Math . max ( r1 , r2 ) ) ; } public static void main ( String args [ ] ) { int [ ] [ ] arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ; int n = arr [ 0 ] . length ; maxSum ( arr , n ) ; } }"}
{"text": "Kira unimodal dan bukan | Program Java untuk pendekatan di atas; Berfungsi untuk mengira faktorial sehingga nombor; Kirakan faktorial; Berfungsi untuk mencari kuasa (a, b); Melangkah sehingga B wujud; Jika B boleh dibahagikan dengan 2; Mengurangkan nilai b; Kembalikan jawapannya; Fungsi yang mengira permutasi unimodal dan bukan unimodal dari integer yang diberikan; Fungsi panggilan untuk mencari faktorial sehingga n; Berfungsi untuk mengira permutasi unimodal; Permutasi bukan unimodal adalah N! - permutasi unimodal; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "class GFG { static int mod = ( int ) ( 1e9 + 7 ) ; static int mx = ( int ) 1e6 ; static int [ ] fact = new int [ ( int ) mx + 1 ] ; static void Calculate_factorial ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= mx ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; fact [ i ] %= mod ; } } static int UniModal_per ( int a , int b ) { int res = 1 ; while ( b > 0 ) { if ( b % 2 != 0 ) res = res * a ; res %= mod ; a = a * a ; a %= mod ; b /= 2 ; } return res ; } static void countPermutations ( int n ) { Calculate_factorial ( ) ; int uni_modal = UniModal_per ( 2 , n - 1 ) ; int nonuni_modal = fact [ n ] - uni_modal ; System . out . print ( uni_modal + \" ▁ \" + nonuni_modal ) ; return ; } public static void main ( String [ ] args ) { int N = 4 ; countPermutations ( N ) ; } }"}
{"text": "Susunan terpanjang mungkin yang bermula dan berakhir dengan 1 dan diisi dengan 0 di tengah | Program Java untuk mencari kemungkinan terpanjang yang mungkin bermula dan berakhir dengan 1 dan dipenuhi dengan 0 di tengah; Arahan awalan untuk menyimpan kejadian '1' dan '0'; Melangkah ke atas panjang rentetan; Jika watak semasa adalah '1'; Jika watak semasa adalah '0'; Tambah '1' yang tersedia untuk rentetan pertama; Tambah '0' tersedia untuk rentetan kedua; Tambah '1' yang tersedia untuk rentetan ketiga; Jawapan kemas kini; Cetak hasil akhir; Kod pemacu", "code": "import java . io . * ; class GFG { static void longestSubseq ( String s , int length ) { int [ ] ones = new int [ length + 1 ] ; int [ ] zeroes = new int [ length + 1 ] ; for ( int i = 0 ; i < length ; i ++ ) { if ( s . charAt ( i ) == '1' ) { ones [ i + 1 ] = ones [ i ] + 1 ; zeroes [ i + 1 ] = zeroes [ i ] ; } else { zeroes [ i + 1 ] = zeroes [ i ] + 1 ; ones [ i + 1 ] = ones [ i ] ; } } int answer = Integer . MIN_VALUE ; int x = 0 ; for ( int i = 0 ; i <= length ; i ++ ) { for ( int j = i ; j <= length ; j ++ ) { x += ones [ i ] ; x += ( zeroes [ j ] - zeroes [ i ] ) ; x += ( ones [ length ] - ones [ j ] ) ; answer = Math . max ( answer , x ) ; x = 0 ; } } System . out . println ( answer ) ; } public static void main ( String [ ] args ) { String s = \"10010010111100101\" ; int length = s . length ( ) ; longestSubseq ( s , length ) ; } }"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | Pelaksanaan Java untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Berfungsi untuk mengira dataran terbesar dengan atmost k 1 s untuk pertanyaan Q; Gelung untuk menyelesaikan setiap pertanyaan; Melintasi setiap sub persegi dan mengira jumlah; Pecah apabila melebihi kiraan maksimum; Kod pemacu", "code": "class GFG { static int MAX = 100 ; static void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ; for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } System . out . print ( ans + \"NEW_LINE\"); } } public static void main ( String [ ] args ) { int matrix [ ] [ ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | Pelaksanaan Java untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Berfungsi untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Precomputing jumlah awalan countdp matriks; Gelung untuk menyelesaikan pertanyaan; Mengira jarak maksimum yang mungkin dari pusat dari tepi; Mengira bilangan 1 s dalam submatrix; Kod pemacu", "code": "import java . util . * ; class GFG { static int MAX = 100 ; static void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int [ ] [ ] countDP = new int [ R ] [ C ] ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } System . out . print ( ans + \"NEW_LINE\"); } } public static void main ( String [ ] args ) { int matrix [ ] [ ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }"}
{"text": "N Masalah Tali berturut -turut | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan kos minimum untuk menyambungkan tali yang diberikan; dp [i] [j] = kos minimum dalam julat (i, j) jumlah [i] [j] = jumlah julat (i, j); Memulakan sum jadual memset (jumlah, 0, sizeof (0)); ; Pengkomputeran kos minimum untuk semua selang waktu yang mungkin (i, j) julat kiri; Julat kanan; Tiada kos untuk tali tunggal; Kod pemacu", "code": "class GFG { static int MinCost ( int arr [ ] , int n ) { int [ ] [ ] dp = new int [ n + 5 ] [ n + 5 ] ; int [ ] [ ] sum = new int [ n + 5 ] [ n + 5 ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i ] [ j ] = k ; else { k += arr [ j ] ; sum [ i ] [ j ] = k ; } } } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < n ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; if ( i == j ) dp [ i ] [ j ] = 0 ; else { for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) ; } } } } return dp [ 0 ] [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 6 , 8 , 6 , 1 , 1 } ; int n = arr . length ; System . out . println ( MinCost ( arr , n ) ) ; } }"}
{"text": "Panjang subsegment terpanjang yang dikemas kini selepas memasukkan atmost satu integer | Pelaksanaan Java pendekatan; Berfungsi untuk mengisi semula array DP; Jika f (i, state) sudah dikira maka kembalikan nilai; Hitung f (i, state) mengikut hubungan berulang dan simpan dalam dp [] []; Fungsi yang memanggil fungsi resucrsive untuk mengisi array DP dan kemudian mengembalikan hasilnya; dp [] [] array untuk menyimpan hasil f (i, 1) dan f (1, 2); Memaparkan array dp [] dengan - 1; Pastikan urutan UD dan DU terpanjang bermula pada setiap indeks dikira; Anggapkan jawapannya - 1 Nilai ini hanya akan meningkat; y ialah panjang urutan UD terpanjang bermula pada i; Jika panjangnya, tambah integer dan kemudian urutan du bermula pada i + y; Jika panjang ganjil maka tambah integer dan kemudian urutan ud bermula pada i + y; Kod pemacu", "code": "class GFG { static int f ( int i , int state , int A [ ] , int dp [ ] [ ] , int N ) { if ( i >= N ) return 0 ; else if ( dp [ i ] [ state ] != - 1 ) { return dp [ i ] [ state ] ; } else { if ( i == N - 1 ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] > A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 2 && A [ i ] < A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] <= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) ; else if ( state == 2 && A [ i ] >= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) ; return dp [ i ] [ state ] ; } } static int maxLenSeq ( int A [ ] , int N ) { int i , j , tmp , y , ans ; int dp [ ] [ ] = new int [ 1000 ] [ 3 ] ; for ( i = 0 ; i < 1000 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) dp [ i ] [ j ] = - 1 ; for ( i = 0 ; i < N ; i ++ ) { tmp = f ( i , 1 , A , dp , N ) ; tmp = f ( i , 2 , A , dp , N ) ; } ans = - 1 ; for ( i = 0 ; i < N ; i ++ ) { y = dp [ i ] [ 1 ] ; if ( i + y >= N ) ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 ) ; else if ( y % 2 == 0 ) { ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) ; } else if ( y % 2 == 1 ) { ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) ; } } return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 10 , 3 , 20 , 25 , 24 } ; int n = A . length ; System . out . println ( maxLenSeq ( A , n ) ) ; } }"}
{"text": "Keluarkan elemen untuk memaksimumkan GCD array yang diberikan | Pelaksanaan Java pendekatan di atas; Fungsi rekursif untuk mengembalikan GCD A dan B; Berfungsi untuk mengembalikan GCD yang dimaksimumkan selepas mengeluarkan satu elemen dari array yang diberikan; Awalan dan akhiran tatasusunan; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan GCD unsur -unsur pertama saya dari kiri dalam awalan [i]; Memulakan array akhiran; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan GCD dari semua elemen yang mempunyai lebih besar daripada atau sama dengan saya dalam akhiran [i]; Jika elemen pertama atau terakhir array perlu dikeluarkan; Jika elemen lain diganti; Mengembalikan GCD yang dimaksimumkan; Kod pemacu", "code": "class Test { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int MaxGCD ( int a [ ] , int n ) { int Prefix [ ] = new int [ n + 2 ] ; int Suffix [ ] = new int [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = Math . max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . max ( ans , gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 14 , 17 , 28 , 70 } ; int n = a . length ; System . out . println ( MaxGCD ( a , n ) ) ; } }"}
{"text": "SUM MAXIMUM SUMBER DENGAN MENGURANGKAN TANDA PALING PADA ELEMENT ARAY KEDUA | Pelaksanaan Java pendekatan; Berfungsi untuk mencari jumlah subarray maksimum dengan flip bermula dari indeks I; Jika bilangan flip telah melebihi; Traversal lengkap; Sekiranya negara sebelum ini telah dikunjungi; Pada mulanya; Gunakan algoritma Kadane dan hubungi dua negeri; Memoize jawapan dan mengembalikannya; Fungsi utiliti untuk memanggil flips dari indeks dan mengembalikan jawapannya; Buat array dp int dp [n, k + 1]; ; ITERATE dan CALL FUNGSI RECURSIF DARI SETIAP INDEX UNTUK MEMBERI JUMLAH SUBARRAY MAXIMUM; kes sudut; Kod pemacu", "code": "import java . util . Arrays ; class GFG { static int right = 2 ; static int left = 4 ; static int [ ] [ ] dp = new int [ left ] [ right ] ; static int findSubarraySum ( int ind , int flips , int n , int [ ] a , int k ) { if ( flips > k ) return ( int ) ( - 1e9 ) ; if ( ind == n ) return 0 ; if ( dp [ ind ] [ flips ] != - 1 ) return dp [ ind ] [ flips ] ; int ans = 0 ; ans = Math . max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; ans = Math . max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; return dp [ ind ] [ flips ] = ans ; } static int findMaxSubarraySum ( int [ ] a , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < k + 1 ; j ++ ) dp [ i ] [ j ] = - 1 ; int ans = ( int ) ( - 1e9 ) ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; if ( ans == 0 && k == 0 ) return Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; return ans ; } public static void main ( String [ ] args ) { int [ ] a = { - 1 , - 2 , - 100 , - 10 } ; int n = a . length ; int k = 1 ; System . out . println ( findMaxSubarraySum ( a , n , k ) ) ; } }"}
{"text": "Cari Jumlah Nombor Fibonacci Pertama N yang pertama | Program Java untuk mencari jumlah nombor Fibonacci yang pertama; Fungsi untuk mengira jumlah nombor Fibonacci yang pertama; nilai asas; Kod pemacu", "code": "import java . io . * ; class GFG { static int mod = 1000000007 ; static int sumOddFibonacci ( int n ) { int Sum [ ] = new int [ n + 1 ] ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( sumOddFibonacci ( n ) ) ; }"}
{"text": "Kurangkan jumlah teddies untuk diedarkan | Pelaksanaan Java pendekatan di atas; Memulakan satu tablet untuk setiap pelajar; Jika dibiarkan bersebelahan mempunyai kajian markah yang lebih tinggi dan mengubah semua nilai DP yang diberikan sebelum sehingga nilai DP yang diberikan didapati salah mengikut kekangan yang diberikan; Jika betul bersebelahan mempunyai markah yang lebih tinggi, tambahkan satu di dp kiri bersebelahan dan berikan ke kanan; Kod pemacu; n bilangan pelajar; tanda pelajar; penyelesaian masalah", "code": "public class GFG { static long fun ( int marks [ ] , int n ) { long dp [ ] = new long [ n ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; } public static void main ( String args [ ] ) { int n = 6 ; int marks [ ] = { 1 , 4 , 5 , 2 , 2 , 1 } ; System . out . println ( fun ( marks , n ) ) ; } }"}
{"text": "Bilangan cara untuk mencapai lantai nth dengan mengambil di | Program Java untuk mencapai tangga dengan mengambil maksimum l leap; Unsur -unsur kombo [] menyimpan no. cara yang mungkin untuk mencapainya dengan semua kombinasi K Leaps atau kurang; Dengan mengandaikan lompatan 0 wujud dan memberikan nilainya kepada 1 untuk pengiraan; gelung untuk melangkah ke atas semua kemungkinan melompat sehingga K; ; Dalam gelung ini kita mengira semua kemungkinan lompatan untuk mencapai tangga jth dengan bantuan lompatan atau kurang; Jika lompatan itu tidak lebih daripada i - j; Kirakan nilai dan simpan dalam combo [j] untuk menggunakannya semula untuk pengiraan lompatan seterusnya untuk tangga jth; Mengembalikan tidak ada kemungkinan lompatan untuk mencapai bahagian atas bangunan n tangga; Kod pemacu; N i tangga total k adalah nilai lompatan terbesar", "code": "class GFG { static int solve ( int N , int K ) { int [ ] combo ; combo = new int [ 50 ] ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; } public static void main ( String args [ ] ) { int N = 29 ; int K = 5 ; System . out . println ( solve ( N , K ) ) ; solve ( N , K ) ; } }"}
{"text": "Cari yang paling lama meningkat seterusnya secara bulat | Pelaksanaan Java untuk mencari LIS dengan cara bulat; Kaedah utiliti untuk mencari LIS menggunakan pengaturcaraan dinamik; Memulakan nilai LIS untuk semua indeks; Kirakan nilai LIS yang dioptimumkan dengan cara bawah; Tetapkan j berdasarkan tetingkap semasa i. e. elemen pertama tetingkap semasa; Pilih maksimum semua nilai LIS; Berfungsi untuk mencari peningkatan yang paling lama dalam cara bulat; Buat salinan Array yang diberikan dengan memasuki elemen array yang sama kepada dirinya sendiri; Lakukan lis untuk setiap tetingkap saiz n; Kaedah Pemandu", "code": "class Test { static int computeLIS ( int circBuff [ ] , int start , int end , int n ) { int LIS [ ] = new int [ n + end - start ] ; for ( int i = start ; i < end ; i ++ ) LIS [ i ] = 1 ; for ( int i = start + 1 ; i < end ; i ++ ) for ( int j = start ; j < i ; j ++ ) if ( circBuff [ i ] > circBuff [ j ] && LIS [ i ] < LIS [ j ] + 1 ) LIS [ i ] = LIS [ j ] + 1 ; int res = Integer . MIN_VALUE ; for ( int i = start ; i < end ; i ++ ) res = Math . max ( res , LIS [ i ] ) ; return res ; } static int LICS ( int arr [ ] , int n ) { int circBuff [ ] = new int [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) circBuff [ i ] = arr [ i ] ; for ( int i = n ; i < 2 * n ; i ++ ) circBuff [ i ] = arr [ i - n ] ; int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( computeLIS ( circBuff , i , i + n , n ) , res ) ; return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 6 , 2 , 3 } ; System . out . println ( \" Length ▁ of ▁ LICS ▁ is ▁ \" + LICS ( arr , arr . length ) ) ; } }"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Program Java untuk pendekatan di atas; utiliti min; Fungsi untuk pekali binomial; Membina segitiga Pascal; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static int min ( int a , int b ) { return a < b ? a : b ; } static int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( \" Number ▁ of ▁ Paths : ▁ \" + binomialCoeff ( n + m , n ) ) ; } }"}
{"text": "Susunan peningkatan yang paling lama (LCS + LIS) | Program Java untuk mencari panjang peningkatan yang paling lama (LCI); Mengembalikan panjang dan LCIS dua array ARR1 [0. n - 1] dan arr2 [0 .. m - 1]; Jadual [J] akan menyimpan panjang LCI yang berakhir dengan ARR2 [J]. Kami memulakannya sebagai 0 ,; Melintasi semua elemen ARR1 []; Memulakan panjang semasa LCI; Untuk setiap elemen arr1 [], trvars semua elemen ARR2 []. ; Jika kedua -dua array mempunyai elemen yang sama. Perhatikan bahawa kami tidak memecahkan gelung di sini. ; Sekarang cari elemen umum yang lebih kecil sebelumnya untuk elemen semasa ARR1; Nilai maksimum dalam Jadual [] adalah hasil; Program pemacu untuk menguji fungsi di atas", "code": "import java . io . * ; class GFG { static int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 3 , 4 , 9 , 1 } ; int arr2 [ ] = { 5 , 3 , 8 , 9 , 10 , 2 , 1 } ; int n = arr1 . length ; int m = arr2 . length ; System . out . println ( \" Length ▁ of ▁ LCIS ▁ is ▁ \" + LCIS ( arr1 , n , arr2 , m ) ) ; } }"}
{"text": "Panjang awalan biasa terpanjang mungkin dengan menyusun semula rentetan dalam array yang diberikan | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mendapatkan panjang awalan biasa terpanjang dengan menyusun semula rentetan; freq [i] [j]: Menyimpan kekerapan aksara (= j) dalam rentetan arr [i]; Melintasi array yang diberikan; Kedai panjang rentetan semasa; Melintasi rentetan arus array yang diberikan; Kemas kini nilai freq [i] [arr [i] [j]]; Menyimpan panjang awalan biasa terpanjang; Kira kekerapan minimum setiap aksara dalam semua rentetan arr []; Kedai nilai minimum dalam setiap baris freq [] []; Kirakan kekerapan minimum aksara semasa dalam semua rentetan. ; Kemas kini Minrowval; Kemas kini Maxlen; Kod pemacu", "code": "import java . util . * ; class GFG { static int longComPre ( String arr [ ] , int N ) { int [ ] [ ] freq = new int [ N ] [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { int M = arr [ i ] . length ( ) ; for ( int j = 0 ; j < M ; j ++ ) { freq [ i ] [ arr [ i ] . charAt ( j ) ] ++ ; } } int maxLen = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { int minRowVal = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { minRowVal = Math . min ( minRowVal , freq [ i ] [ j ] ) ; } maxLen += minRowVal ; } return maxLen ; } public static void main ( String [ ] args ) { String arr [ ] = { \" aabdc \" , \" abcd \" , \" aacd \" } ; int N = 3 ; System . out . print ( longComPre ( arr , N ) ) ; } }"}
{"text": "Keluarkan aksara dari rentetan yang kelihatan tepat k kali | Program Java untuk menghapuskan aksara dari rentetan yang muncul tepat kali K; Berfungsi untuk mengurangkan rentetan dengan mengeluarkan aksara yang kelihatan tepat K kali; Jadual Hash diasaskan kepada 0; Meningkatkan kekerapan watak; Untuk menyimpan jawapan; Indeks seterusnya dalam rentetan yang dikurangkan; Tambah watak -watak yang kelihatan tepat K kali; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int MAX_CHAR = 26 ; static String removeChars ( char arr [ ] , int k ) { int [ ] hash = new int [ MAX_CHAR ] ; int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) hash [ arr [ i ] - ' a ' ] ++ ; String ans = \" \" ; for ( int i = 0 ; i < n ; ++ i ) { if ( hash [ arr [ i ] - ' a ' ] != k ) { ans += arr [ i ] ; } } return ans ; } public static void main ( String [ ] args ) { char str [ ] = \" geeksforgeeks \" . toCharArray ( ) ; int k = 2 ; System . out . print ( removeChars ( str , k ) ) ; } }"}
{"text": "Subsegments bersebelahan rentetan yang mempunyai aksara berikutnya yang berbeza | Pelaksanaan Java pendekatan; Fungsi yang mencetak segmen; Arahan baru untuk setiap lelaran; Periksa sama ada watak itu dalam array; Kod pemacu", "code": "import java . util . * ; class GFG { static void sub_segments ( String str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { String newlist = str . substring ( x , x + n ) ; List < Character > arr = new ArrayList < Character > ( ) ; for ( char y : newlist . toCharArray ( ) ) { if ( ! arr . contains ( y ) ) arr . add ( y ) ; } for ( char y : arr ) System . out . print ( y ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { String str = \" geeksforgeeksgfg \" ; int n = 4 ; sub_segments ( str , n ) ; } }"}
{"text": "Program untuk mencari perkataan yang disulitkan | Program Java untuk melaksanakan pendekatan di atas; Fungsi statik yang diisytiharkan untuk mencari rentetan yang disulitkan; Pelbagai watak untuk menyimpan rentetan yang disulitkan; Selepas 'Z', ia harus pergi ke a. ; Menyimpan array watak dalam rentetan. ; Kod pemacu", "code": "import java . util . * ; import java . io . * ; class GFG { public static void findWord ( String c , int n ) { int co = 0 , i ; char s [ ] = new char [ n ] ; for ( i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) co ++ ; else co = n - i ; if ( ( c . charAt ( i ) + co ) <= 122 ) s [ i ] = ( char ) ( ( int ) c . charAt ( i ) + co ) ; else s [ i ] = ( char ) ( ( int ) c . charAt ( i ) + co - 26 ) ; } String str = Arrays . toString ( s ) ; System . out . println ( str ) ; } public static void main ( String args [ ] ) { String s = \" abcd \" ; findWord ( s , s . length ( ) ) ; } }"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; panjang rentetan pertama; panjang rentetan kedua; Jika panjang tidak sama hanya kembali palsu kerana kedua -dua rentetan tidak boleh sama jika panjang tidak sama; gelung untuk memadankan satu demi satu semua watak kedua -dua rentetan; Jika aksara semasa kedua -dua rentetan adalah sama, tambah nilai saya untuk membandingkan watak seterusnya; Jika mana -mana watak rentetan pertama adalah beberapa watak khas atau aksara angka dan tidak sama dengan watak yang sama rentetan kedua kemudian kembali palsu; Lakukan perkara yang sama untuk rentetan kedua; Blok kod ini akan dilaksanakan jika watak -watak kedua -dua rentetan adalah kes yang berbeza; Bandingkan watak dengan nilai ASCII; Jika watak dipadankan, tingkatkan nilai saya untuk membandingkan char seterusnya; Jika semua aksara rentetan pertama dipadankan dengan aksara yang sepadan dengan rentetan kedua, maka kembali benar; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "class GFG { static boolean equalIgnoreCase ( String str1 , String str2 ) { int i = 0 ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; if ( len1 != len2 ) return false ; while ( i < len1 ) { if ( str1 . charAt ( i ) == str2 . charAt ( i ) ) { i ++ ; } else if ( ! ( ( str1 . charAt ( i ) >= ' a ' && str1 . charAt ( i ) <= ' z ' ) || ( str1 . charAt ( i ) >= ' A ' && str1 . charAt ( i ) <= ' Z ' ) ) ) { return false ; } else if ( ! ( ( str2 . charAt ( i ) >= ' a ' && str2 . charAt ( i ) <= ' z ' ) || ( str2 . charAt ( i ) >= ' A ' && str2 . charAt ( i ) <= ' Z ' ) ) ) { return false ; } else { if ( str1 . charAt ( i ) >= ' a ' && str1 . charAt ( i ) <= ' z ' ) { if ( str1 . charAt ( i ) - 32 != str2 . charAt ( i ) ) return false ; } else if ( str1 . charAt ( i ) >= ' A ' && str1 . charAt ( i ) <= ' Z ' ) { if ( str1 . charAt ( i ) + 32 != str2 . charAt ( i ) ) return false ; } i ++ ; return true ; static void equalIgnoreCaseUtil ( String str1 , String str2 ) { boolean res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) System . out . println ( \" Same \" ) ; else System . out . println ( \" Not ▁ Same \" ) ; } public static void main ( String args [ ] ) { String str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; } }"}
{"text": "Memaksimumkan nilai A dengan menggantikan beberapa digitnya dengan digit B | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan nilai yang dimaksimumkan A; Jenis digit dalam urutan menaik; J menunjuk kepada digit terbesar di B; Jika semua digit B telah digunakan; Digit semasa telah digunakan; Mengembalikan nilai yang dimaksimumkan; Kod pemacu", "code": "import java . util . * ; class GFG { static String maxValue ( char [ ] a , char [ ] b ) { Arrays . sort ( b ) ; int n = a . length ; int m = b . length ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return String . valueOf ( a ) ; } public static void main ( String [ ] args ) { String a = \"1234\" ; String b = \"4321\" ; System . out . print ( maxValue ( a . toCharArray ( ) , b . toCharArray ( ) ) ) ; } }"}
{"text": "Mengira nombor dalam julat supaya digit di dalamnya dan produknya dengan Q tidak sama rata | Program Java untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada semua digit dalam nombor dan produknya dengan Q tidak sama atau tidak; Tukar nombor pertama ke dalam rentetan; Masukkan elemen dari nombor 1 ke hash; Hitung produk yang sepadan; Tukar produk ke rentetan; Menggunakan Hash Check jika mana -mana digit padanan produk dengan digit nombor input; Jika ya, kembali palsu; lain, kembali benar; Berfungsi untuk mengira nombor dalam julat [l, r] supaya semua digit nombor dan produknya dengan Q tidak sama rata; Semak setiap nombor antara L dan R; Kod pemacu; Panggilan fungsi", "code": "class GfG { static boolean checkIfUnequal ( int n , int q ) { String s1 = Integer . toString ( n ) ; int a [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) a [ s1 . charAt ( i ) - '0' ] ++ ; int prod = n * q ; String s2 = Integer . toString ( prod ) ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( a [ s2 . charAt ( i ) - '0' ] > 0 ) return false ; } return true ; } static int countInRange ( int l , int r , int q ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( checkIfUnequal ( i , q ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int l = 10 , r = 12 , q = 2 ; System . out . println ( countInRange ( l , r , q ) ) ; } }"}
{"text": "Semak sama ada mungkin untuk menyusun semula rentetan binari dengan alternatif 0 s dan 1 s | Program Java untuk memeriksa sama ada kita boleh menyusun semula rentetan supaya ia mempunyai alternatif 0 s dan 1 s. ; berfungsi untuk memeriksa rentetan binari; panjang rentetan; Count Zero; Kira satu 's; jika panjangnya; Sekiranya panjangnya ganjil", "code": "import java . lang . Math ; public class GfG { public static boolean is_possible ( String s ) { int l = s . length ( ) ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . abs ( one - zero ) == 1 ) ; } public static void main ( String [ ] args ) { String s = \"100110\" ; if ( is_possible ( s ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program Java untuk mengira frekuensi item array; Buat array untuk menyimpan tuduhan. Saiz array adalah had + 1 dan semua nilai pada mulanya 0; Melintasi aksara rentetan dan mengira frekuensi; Kod pemacu", "code": "class GFG { static int limit = 255 ; static void countFreq ( String str ) { int [ ] count = new int [ limit + 1 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str . charAt ( i ) ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) System . out . println ( ( char ) i + \" ▁ \" + count [ i ] ) ; } public static void main ( String [ ] args ) { String str = \" GeeksforGeeks \" ; countFreq ( str ) ; } }"}
{"text": "Kira bit set Even dan Odd dengan elemen array selepas xor dengan k | Program Java untuk mengira bit set selepas mengambil XOR dengan nombor k; Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Berfungsi untuk menyimpan pemboleh ubah yang walaupun dan ganjil; Simpan kiraan bit set walaupun dan ganjil; Kira set bit menggunakan dalam fungsi terbina; Count set - bit k; Jika y adalah ganjil, kiraan bit set walaupun dan ganjil akan ditukar; Lain ia akan tetap sama dengan array asal; Kod pemandu; Fungsi panggilan untuk mengira walaupun dan ganjil", "code": "class GFG { static int __builtin_popcount ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } static void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { System . out . println ( \" Even ▁ = ▁ \" + odd + \" , ▁ Odd ▁ = ▁ \" + even ) ; } else { System . out . println ( \" Even ▁ = ▁ \" + even + \" , ▁ Odd ▁ = ▁ \" + odd ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = arr . length ; countEvenOdd ( arr , n , K ) ; } }"}
{"text": "Google Case Of A Sentyen tertentu | Program Java untuk menukar ayat yang diberikan kepada kes unta. ; Berfungsi untuk mengeluarkan ruang dan menukar ke dalam kes unta; Semak ruang dalam ayat; penukaran ke atas kes; Jika tidak ruang, salin watak; kembali rentetan ke Main; Kod pemacu", "code": "import java . io . * ; class GFG { static String convert ( String s ) { int n = s . length ( ) ; String s1 = \" \" ; s1 = s1 + Character . toLowerCase ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ▁ ' && i < n ) { s1 = s1 + \" ▁ \" + Character . toLowerCase ( s . charAt ( i + 1 ) ) ; i ++ ; } else s1 = s1 + Character . toUpperCase ( s . charAt ( i ) ) ; } return s1 ; } public static void main ( String [ ] args ) { String str = \" I ▁ get ▁ intern ▁ at ▁ geeksforgeeks \" ; System . out . println ( convert ( str ) ) ; } }"}
{"text": "Ubah rentetan | Kod java untuk mengubah rentetan; Fungsi untuk mengubah kes watak; Jika watak adalah perubahan huruf kecil ke huruf besar; Jika watak adalah perubahan huruf besar kepada huruf kecil; Berfungsi untuk memadam vokal; Jika watak adalah konsonan; Fungsi untuk memasukkan \" #\"; Jika watak bukan watak istimewa; Berfungsi untuk mengubah rentetan; Fungsi pemacu; Fungsi panggilan", "code": "import java . io . * ; class Gfg { public static String change_case ( String a ) { String temp = \" \" ; int l = a . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char ch = a . charAt ( i ) ; if ( ch >= ' a ' && ch <= ' z ' ) ch = ( char ) ( 65 + ( int ) ( ch - ' a ' ) ) ; else if ( ch >= ' A ' && ch <= ' Z ' ) ch = ( char ) ( 97 + ( int ) ( ch - ' A ' ) ) ; temp += ch ; } return temp ; } public static String delete_vowels ( String a ) { String temp = \" \" ; int l = a . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char ch = a . charAt ( i ) ; if ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' && ch != ' A ' && ch != ' E ' && ch != ' O ' && ch != ' U ' && ch != ' I ' ) temp += ch ; } return temp ; } public static String insert_hash ( String a ) { String temp = \" \" ; int l = a . length ( ) ; char hash = ' # ' ; for ( int i = 0 ; i < l ; i ++ ) { char ch = a . charAt ( i ) ; if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) temp = temp + hash + ch ; else temp = temp + ch ; } return temp ; } public static void transformString ( String a ) { String b = delete_vowels ( a ) ; String c = change_case ( b ) ; String d = insert_hash ( c ) ; System . out . println ( d ) ; } public static void main ( String args [ ] ) { String a = \" SunshinE ! ! \" ; transformString ( a ) ; } }"}
{"text": "Nombor TCEFREP | Program Java untuk pendekatan di atas; Fungsi berulang untuk membalikkan digit NUM; Fungsi untuk mengira jumlah semua pembahagi yang betul Num -> diberi nombor semulajadi; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "class GFG { static int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static int properDivSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } static boolean isTcefrep ( int n ) { return properDivSum ( n ) == reverse ( n ) ; } public static void main ( String [ ] args ) { int N = 6 ; if ( isTcefrep ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text": "Program untuk mencari n | Program Java untuk mencari nombor n - th yang mengandungi hanya 3 dan 5 .; Jika n adalah ganjil, tambah 3 dan pindah ke ibu bapa; Jika n adalah, tambah 5 dan pindah ke ibu bapa; Reverse Res dan kembali. ; Kod pemacu", "code": "public class GFG { static String findNthNo ( int n ) { String res = \" \" ; while ( n >= 1 ) { if ( ( n & 1 ) == 1 ) { res = res + \"3\" ; n = ( n - 1 ) / 2 ; } else { res = res + \"5\" ; n = ( n - 2 ) / 2 ; } } StringBuilder sb = new StringBuilder ( res ) ; sb . reverse ( ) ; return new String ( sb ) ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . print ( findNthNo ( n ) ) ; } }"}
{"text": "Nth non | Program Java untuk mencari nombor bukan persegi. ; berfungsi untuk mencari nombor non non - persegi; Penukaran dari Int ke Long Double diperlukan untuk memelihara tempat perpuluhan selepas akar persegi. ; mengira hasilnya; Kod pemacu; memulakan nombor jangka panjang; Cetak hasilnya", "code": "import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static int findNthNonSquare ( int n ) { double x = ( double ) n ; double ans = x + Math . floor ( 0.5 + Math . sqrt ( x ) ) ; return ( int ) ans ; } public static void main ( String [ ] args ) { int n = 16 ; System . out . print ( \" The ▁ \" + n + \" th ▁ Non - Square ▁ number ▁ is ▁ \" ) ; System . out . print ( findNthNonSquare ( n ) ) ; } }"}
{"text": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | Program Java yang cekap untuk mencari jumlah siri dengan jumlah AP yang ditandatangani alternatif. ; fungsi untuk mengira jumlah siri; Kod pemacu", "code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; } public static void main ( String args [ ] ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; System . out . println ( seiresSum ( n , a ) ) ; } }"}
{"text": "Cari nombor n yang mengandungi digit k atau dibahagikan dengan k. | Program Java untuk mencari nombor n yang mengandungi digit k atau dibahagikan oleh k. ; Fungsi untuk memeriksa jika digit k berada dalam n atau tidak; mencari selebihnya; jika digit dijumpai; Fungsi untuk mencari nombor nth; Oleh kerana k adalah yang pertama yang memenuhi kriteria, jadi pertimbangkannya dalam kiraan membuat kiraan = 1 dan bermula dari i = k + 1; Memeriksa bahawa nombor itu mengandungi k digit atau dibahagikan oleh k; Kod pemacu", "code": "import java . io . * ; class GFG { public static boolean checkdigit ( int n , int k ) { while ( n != 0 ) { int rem = n % 10 ; if ( rem == k ) return true ; n = n / 10 ; } return false ; } public static int findNthNumber ( int n , int k ) { for ( int i = k + 1 , count = 1 ; count < n ; i ++ ) { if ( checkdigit ( i , k ) || ( i % k == 0 ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { int n = 10 , k = 2 ; System . out . println ( findNthNumber ( n , k ) ) ; } }"}
{"text": "Count subarrays saiz K yang merupakan permutasi nombor dari 1 hingga k | Program Java untuk melaksanakan pendekatan di atas; Simpan indeks nombor array; Kemas kini indeks min dan max dengan indeks semasa dan periksa sama ada ia adalah permutasi yang sah; Kod pemacu", "code": "import java . util . * ; class GFG { public static int find_permutations ( Vector < Integer > arr ) { int cnt = 0 ; int max_ind = - 1 , min_ind = 10000000 ; int n = arr . size ( ) ; HashMap < Integer , Integer > index_of = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { index_of . put ( arr . get ( i ) , i + 1 ) ; } for ( int i = 1 ; i <= n ; i ++ ) { max_ind = Math . max ( max_ind , index_of . get ( i ) ) ; min_ind = Math . min ( min_ind , index_of . get ( i ) ) ; if ( max_ind - min_ind + 1 == i ) cnt ++ ; } return cnt ; } public static void main ( String [ ] args ) { Vector < Integer > nums = new Vector < Integer > ( ) ; nums . add ( 2 ) ; nums . add ( 3 ) ; nums . add ( 1 ) ; nums . add ( 5 ) ; nums . add ( 4 ) ; System . out . print ( find_permutations ( nums ) ) ; } }"}
{"text": "Count of integer yang membahagikan semua elemen array yang diberikan | Pelaksanaan Java pendekatan; Fungsi rekursif untuk mengembalikan GCD; Berfungsi untuk mengembalikan kiraan bilangan bulat yang diperlukan; Untuk menyimpan GCD unsur -unsur array; Untuk menyimpan kiraan faktor GCD yang dijumpai; Jika G adalah persegi yang sempurna; Faktor muncul berpasangan; Kod pemacu", "code": "class GFG { static int calgcd ( int a , int b ) { if ( b == 0 ) return a ; return calgcd ( b , a % b ) ; } static int getCount ( int [ ] a , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = calgcd ( gcd , a [ i ] ) ; int cnt = 0 ; for ( int i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { if ( i * i == gcd ) cnt ++ ; else cnt += 2 ; } } return cnt ; } public static void main ( String [ ] args ) { int [ ] a = { 4 , 16 , 1024 , 48 } ; int n = a . length ; System . out . println ( getCount ( a , n ) ) ; } }"}
{"text": "Kurangkan kos penyingkiran yang diperlukan untuk menjadikan semua watak yang tersisa dari rentetan unik | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mengeluarkan aksara untuk membuat rentetan unik; menyimpan watak yang dikunjungi; menyimpan jawapannya; melintasi rentetan; jika sudah dikunjungi; Menyimpan kos maksimum untuk mengeluarkan watak tertentu; Simpan jumlah kos penghapusan watak tertentu; Tandakan watak semasa yang dikunjungi; Melintasi indeks rentetan [i, n - 1]; Jika ada pendua yang dijumpai; Mengemas kini kos maksimum dan jumlah kos; Tandakan watak semasa yang dikunjungi; Simpan watak dengan kos maksimum dan padamkan yang lain; mengembalikan kos minimum; Kod pemacu; rentetan input; Arahan input; panggilan fungsi", "code": "import java . io . * ; class GFG { public static int delCost ( String s , int [ ] cost ) { boolean visited [ ] = new boolean [ s . length ( ) ] ; int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( visited [ i ] ) { continue ; } int maxDel = 0 ; int totalCost = 0 ; visited [ i ] = true ; for ( int j = i ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { maxDel = Math . max ( maxDel , cost [ j ] ) ; totalCost += cost [ j ] ; visited [ j ] = true ; } } ans += totalCost - maxDel ; } return ans ; } public static void main ( String [ ] args ) { String s = \" AAABBB \" ; int [ ] cost = { 1 , 2 , 3 , 4 , 5 , 6 } ; System . out . println ( delCost ( s , cost ) ) ; } }"}
{"text": "Buat semua elemen array sama dengan menggantikan tiga kali ganda dengan bitwise xor mereka | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mencari tiga kali ganda yang menggantikannya dengan XOR mereka membuat semua elemen array sama; Jika n juga; Hitung XOR unsur array; Melintasi array; Kemas kini XOR; Jika XOR tidak sama dengan 0; Memilih triplet seperti unsur -unsur pasangan (arr [0], arr [1]), (arr [2], arr [3]). . . boleh dibuat sama; Memilih tiga kali ganda supaya semua elemen array boleh dibuat sama dengan arr [n - 1]; Memilih triplet seperti unsur -unsur pasangan (arr [0], arr [1]), (arr [2], arr [3]). . . boleh dibuat sama; Memilih tiga kali ganda supaya semua elemen array boleh dibuat sama dengan arr [n - 1]; Kod pemacu; Diberikan array; Saiz array; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void checkXOR ( int arr [ ] , int N ) { if ( N % 2 == 0 ) { int xro = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xro ^= arr [ i ] ; } if ( xro != 0 ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i < N - 3 ; i += 2 ) { System . out . println ( i + \" ▁ \" + ( i + 1 ) + \" ▁ \" + ( i + 2 ) ) ; } for ( int i = 0 ; i < N - 3 ; i += 2 ) { System . out . println ( i + \" ▁ \" + ( i + 1 ) + \" ▁ \" + ( N - 1 ) ) ; } } else { for ( int i = 0 ; i < N - 2 ; i += 2 ) { System . out . println ( i + \" ▁ \" + ( i + 1 ) + \" ▁ \" + ( i + 2 ) ) ; } for ( int i = 0 ; i < N - 2 ; i += 2 ) { System . out . println ( i + \" ▁ \" + ( i + 1 ) + \" ▁ \" + ( N - 1 ) ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 1 , 7 , 2 } ; int N = arr . length ; checkXOR ( arr , N ) ; } }"}
{"text": "Buat semua elemen array walaupun dengan menggantikan sepasang elemen array bersebelahan dengan jumlah mereka | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mencari kiraan minimum operasi yang diperlukan untuk membuat semua elemen array walaupun; Kedai minimum penggantian minimum untuk membuat semua elemen array walaupun; Menyimpan kiraan nombor berterusan ganjil; Melintasi array; Jika arr [i] adalah nombor ganjil; Kemas kini ODD_CONT_SEG; Jika odd_cont_seg adalah walaupun; Kemas kini res; Kemas kini res; Tetapkan semula ODD_CONT_SEG = 0; Jika odd_cont_seg melebihi 0; Jika odd_cont_seg adalah walaupun; Kemas kini res; Kemas kini res; Cetak hasilnya; Kod pemandu", "code": "import java . util . * ; class GFG { static int make_array_element_even ( int arr [ ] , int N ) { int res = 0 ; int odd_cont_seg = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += ( odd_cont_seg / 2 ) + 2 ; } odd_cont_seg = 0 ; } } } if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += odd_cont_seg / 2 + 2 ; } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 5 , 11 , 6 } ; int N = arr . length ; System . out . print ( make_array_element_even ( arr , N ) ) ; } }"}
{"text": "Cari nombor k sedemikian rupa sehingga betul -betul elemen array lebih besar daripada atau sama dengan k | Program Java untuk pendekatan di atas; Fungsi untuk mencari k yang mana terdapat unsur -unsur array yang lebih besar daripada atau sama dengan k; Mencari elemen array terbesar; Nilai kemungkinan k; Melintasi array; Jika elemen array semasa lebih besar daripada atau sama dengan i; Jika saya pelbagai elemen adalah lebih besar daripada atau sama dengan i; Jika tidak; Untuk mencari elemen maksimum; Kod pemacu", "code": "import java . io . * ; class GFG { public static int zvalue ( int [ ] nums ) { int m = max_element ( nums ) ; int cnt = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { cnt = 0 ; for ( int j = 0 ; j < nums . length ; j ++ ) { if ( nums [ j ] >= i ) cnt ++ ; } if ( cnt == i ) return i ; } return - 1 ; } public static int max_element ( int [ ] nums ) { int max = nums [ 0 ] ; for ( int i = 1 ; i < nums . length ; i ++ ) max = Math . max ( max , nums [ i ] ) ; return max ; } public static void main ( String args [ ] ) { int [ ] nums = { 7 , 8 , 9 , 0 , 0 , 1 } ; System . out . println ( zvalue ( nums ) ) ; } }"}
{"text": "Anagrams lexicographically terkecil dan terbesar rentetan yang mengandungi rentetan lain sebagai substringnya | Program Java untuk pendekatan di atas; Berfungsi untuk mencari anagram terkecil rentetan yang mengandungi rentetan lain; Memulakan peta dan set; Melangkah ke atas S1; Menyimpan kekerapan aksara yang ada di S1; Menyimpan watak -watak yang berbeza dalam S1; Mengurangkan kekerapan aksara dari m yang sudah ada di S2; Melintasi abjad dalam urutan yang disusun; Jika watak semasa set tidak sama dengan watak semasa S2; Jika elemen sama dengan watak semasa S2; Memeriksa watak kedua yang berbeza dalam S2; S2 [J] akan menyimpan watak kedua yang berbeza; Kembalikan jawapannya; Berfungsi untuk mencari anagram leksikografi terbesar rentetan yang mengandungi rentetan lain; Mendapatkan anagram terkecil secara lexicographically; D1 menyimpan awalan; D2 menyimpan akhiran; Mengembalikan hasilnya; Kod pemacu; Diberikan dua rentetan; Panggilan fungsi", "code": "import java . lang . * ; import java . io . * ; import java . util . * ; class GFG { static String [ ] lexico_smallest ( String s1 , String s2 ) { Map < Character , Integer > M = new HashMap < > ( ) ; Set < Character > S = new TreeSet < > ( ) ; for ( int i = 0 ; i <= s1 . length ( ) - 1 ; ++ i ) { if ( ! M . containsKey ( s1 . charAt ( i ) ) ) M . put ( s1 . charAt ( i ) , 1 ) ; else M . replace ( s1 . charAt ( i ) , M . get ( s1 . charAt ( i ) ) + 1 ) ; S . add ( s1 . charAt ( i ) ) ; } for ( int i = 0 ; i <= s2 . length ( ) - 1 ; ++ i ) { if ( M . containsKey ( s2 . charAt ( i ) ) ) M . replace ( s2 . charAt ( i ) , M . get ( s2 . charAt ( i ) ) - 1 ) ; } char c = s2 . charAt ( 0 ) ; int index = 0 ; String res = \" \" ; Iterator < Character > it = S . iterator ( ) ; while ( it . hasNext ( ) ) { char x = it . next ( ) ; if ( x != c ) { for ( int i = 1 ; i <= M . get ( x ) ; ++ i ) { res += x ; } } else { int j = 0 ; index = res . length ( ) ; while ( s2 . charAt ( j ) == x ) { j ++ ; } if ( s2 . charAt ( j ) < c ) { res += s2 ; for ( int i = 1 ; i <= M . get ( x ) ; ++ i ) { res += x ; } } else { for ( int i = 1 ; i <= M . get ( x ) ; ++ i ) { res += x ; } index += M . get ( x ) ; res += s2 ; } } } String pr [ ] = { res , index + \" \" } ; return pr ; } return pr ; } static String lexico_largest ( String s1 , String s2 ) { String pr [ ] = lexico_smallest ( s1 , s2 ) ; String d1 = \" \" ; for ( int i = Integer . valueOf ( pr [ 1 ] ) - 1 ; i >= 0 ; i -- ) { d1 += pr [ 0 ] . charAt ( i ) ; } String d2 = \" \" ; for ( int i = pr [ 0 ] . length ( ) - 1 ; i >= Integer . valueOf ( pr [ 1 ] ) + s2 . length ( ) ; -- i ) { d2 += pr [ 0 ] . charAt ( i ) ; } String res = d2 + s2 + d1 ; return res ; } public static void main ( String [ ] args ) { String s1 = \" ethgakagmenpgs \" ; String s2 = \" geeks \" ; System . out . println ( lexico_smallest ( s1 , s2 ) [ 0 ] ) ; System . out . println ( lexico_largest ( s1 , s2 ) ) ; } }"}
{"text": "Pertanyaan untuk mencari kiraan laluan terpendek di dalam pokok yang mengandungi kelebihan yang diberikan | Pelaksanaan Java untuk pendekatan di atas; Senarai Adjacency untuk mewakili pokok; Bilangan simpang; Mark yang melawat / tidak dapat Vertices; Menyimpan saiz subtree nod yang sepadan; Berfungsi untuk mewujudkan kelebihan antara dua simpul; Tambah senarai A ke B; Tambah B ke senarai A; Berfungsi untuk melaksanakan DFS; Tandakan puncak yang dikunjungi; Termasuk nod dalam subtree; Melintasi semua anaknya; Berfungsi untuk mencetak bilangan laluan yang diperlukan; Kod pemacu; Bilangan simpang; Memanggil fungsi DFS yang diubah suai; Kira pasangan simpang di pokok", "code": "import java . util . * ; class GFG { static int sz = ( int ) 1e5 ; static Vector < Integer > [ ] tree = new Vector [ sz ] ; static int n ; static boolean [ ] vis = new boolean [ sz ] ; static int [ ] subtreeSize = new int [ sz ] ; static void addEdge ( int a , int b ) { tree [ a ] . add ( b ) ; tree [ b ] . add ( a ) ; } static void dfs ( int x ) { vis [ x ] = true ; subtreeSize [ x ] = 1 ; for ( int i : tree [ x ] ) { if ( ! vis [ i ] ) { dfs ( i ) ; subtreeSize [ x ] += subtreeSize [ i ] ; } } } static void countPairs ( int a , int b ) { int sub = Math . min ( subtreeSize [ a ] , subtreeSize [ b ] ) ; System . out . print ( sub * ( n - sub ) + \"NEW_LINE\"); } public static void main ( String [ ] args ) { n = 6 ; for ( int i = 0 ; i < tree . length ; i ++ ) tree [ i ] = new Vector < Integer > ( ) ; addEdge ( 0 , 1 ) ; addEdge ( 0 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 3 , 4 ) ; addEdge ( 3 , 5 ) ; dfs ( 0 ) ; countPairs ( 1 , 3 ) ; countPairs ( 0 , 2 ) ; } }"}
{"text": "Kira permutasi array yang mempunyai setiap elemen sebagai pelbagai atau faktor indeksnya | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari kiraan permutasi yang dikehendaki; Kes asas; Jika saya belum dimasukkan; Backtrack; Masukkan i; Berulang untuk mencari permutasi yang sah; Keluarkan i; Mengembalikan kiraan akhir; Kod pemacu", "code": "import java . util . * ; class GFG { static int findPermutation ( Set < Integer > arr , int N ) { int pos = arr . size ( ) + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ! arr . contains ( i ) ) { if ( i % pos == 0 pos % i == 0 ) { arr . add ( i ) ; res += findPermutation ( arr , N ) ; arr . remove ( i ) ; } } } return res ; } public static void main ( String [ ] args ) { int N = 5 ; Set < Integer > arr = new HashSet < Integer > ( ) ; System . out . print ( findPermutation ( arr , N ) ) ; } }"}
{"text": "Semak jika jumlah y boleh didapati dari array oleh operasi yang diberikan | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mendapatkan jumlah y dari urutan jumlah x dari array arr []; Simpan perbezaan; Melangkah ke atas array; Jika diff dikurangkan kepada 0; Kod pemacu", "code": "class GFG { static void solve ( int arr [ ] , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 7 , 9 , 10 } ; int n = arr . length ; int X = 11 , Y = 13 ; solve ( arr , n , X , Y ) ; } }"}
{"text": "Jarak paling jauh dari nod dari setiap nod pokok | Program Java untuk melaksanakan pendekatan di atas; Senarai adjacency untuk menyimpan graf; Menyimpan ketinggian setiap nod; Menyimpan jarak maksimum nod dari nenek moyangnya; Berfungsi untuk menambah kelebihan antara dua simpang; Masukkan kelebihan dari u ke v; Masukkan tepi dari v ke u; Berfungsi untuk mengira ketinggian setiap nod; Melangkah dalam senarai addacency nod semasa; DFS untuk nod kanak -kanak; Hitung ketinggian nod; Meningkatkan ketinggian; Fungsi untuk mengira jarak maksimum nod dari nenek moyangnya; Melangkah dalam senarai addacency nod semasa; Cari dua kanak -kanak dengan ketinggian maksimum; Kirakan jarak maksimum dengan nenek moyang untuk setiap nod; Mengira untuk kanak -kanak; Kod pemacu; Hitung ketinggian nod pokok; Kirakan jarak maksimum dengan nenek moyang; Cetak maksimum dua jarak dari setiap nod", "code": "import java . util . * ; class GFG { static final int maxN = 100001 ; @ SuppressWarnings ( \" unchecked \" ) static Vector < Integer > [ ] adj = new Vector [ maxN ] ; static int [ ] height = new int [ maxN ] ; static int [ ] dist = new int [ maxN ] ; static void addEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } static void dfs1 ( int cur , int par ) { for ( int u : adj [ cur ] ) { if ( u != par ) { dfs1 ( u , cur ) ; height [ cur ] = Math . max ( height [ cur ] , height [ u ] ) ; } } height [ cur ] += 1 ; } static void dfs2 ( int cur , int par ) { int max1 = 0 ; int max2 = 0 ; for ( int u : adj [ cur ] ) { if ( u != par ) { if ( height [ u ] >= max1 ) { max2 = max1 ; max1 = height [ u ] ; } else if ( height [ u ] > max2 ) { max2 = height [ u ] ; } } } int sum = 0 ; for ( int u : adj [ cur ] ) { if ( u != par ) { sum = ( ( max1 == height [ u ] ) ? max2 : max1 ) ; if ( max1 == height [ u ] ) dist [ u ] = 1 + Math . max ( 1 + max2 , dist [ cur ] ) ; else dist [ u ] = 1 + Math . max ( 1 + max1 , dist [ cur ] ) ; dfs2 ( u , cur ) ; } } } public static void main ( String [ ] args ) { int n = 6 ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; addEdge ( 1 , 2 ) ; addEdge ( 2 , 3 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 5 , 6 ) ; dfs1 ( 1 , 0 ) ; dfs2 ( 1 , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( ( Math . max ( dist [ i ] , height [ i ] ) - 1 ) + \" ▁ \" ) ; } }"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Program Java untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; Memeriksa B; Memeriksa A; kod pemacu", "code": "import java . util . * ; class Middle { public static int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; } public static void main ( String [ ] args ) { int a = 20 , b = 30 , c = 40 ; System . out . println ( middleOfThree ( a , b , c ) ) ; } }"}
{"text": "Perbezaan antara jenis penyisipan dan pilihan pemilihan | Program Java untuk pelaksanaan pilihan pemilihan; Berfungsi untuk melaksanakan jenis pemilihan; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Tukar elemen minimum yang dijumpai dengan elemen pertama; Berfungsi untuk mencetak array; Kod pemacu; Panggilan fungsi; Cetak array", "code": "import java . util . * ; class GFG { static void selectionSort ( int arr [ ] , int n ) { int i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; int temp = arr [ min_idx ] ; arr [ min_idx ] = arr [ i ] ; arr [ i ] = temp ; } } static void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { System . out . print ( arr [ i ] + \" ▁ \" ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; int n = arr . length ; selectionSort ( arr , n ) ; System . out . print ( \"Sorted array: NEW_LINE\"); printArray ( arr , n ) ; } }"}
{"text": "Semak jika rentetan yang diberikan boleh ditukar kepada yang lain dengan diberikan swap yang mungkin | Program Java untuk melaksanakan pendekatan di atas; Kedai panjang str1; Kedai panjang str2; Kedai watak -watak yang berbeza dari STR1; Kedai watak -watak yang berbeza dari STR2; Kedai kekerapan setiap watak Str1; Traverse string str1; Kemas kini kekerapan str1 [i]; Traverse string str1; Masukkan str1 [i] ke st1; Traverse string str2; Masukkan str1 [i] ke st1; Jika watak yang berbeza dalam str1 dan str2 tidak sama; Kedai kekerapan setiap watak Str2; Traverse string str2; Kemas kini kekerapan STR2 [i]; Sort hash1 [] array; Susun Hash2 [] array; Traverse Hash1 [] dan Hash2 []; Jika Hash1 [i] tidak sama dengan Hash2 [i]; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean checkStr1CanConStr2 ( String str1 , String str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; HashSet < Integer > st1 = new HashSet < > ( ) ; HashSet < Integer > st2 = new HashSet < > ( ) ; int hash1 [ ] = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { hash1 [ str1 . charAt ( i ) ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { st1 . add ( ( int ) str1 . charAt ( i ) ) ; } for ( int i = 0 ; i < M ; i ++ ) { st2 . add ( ( int ) str2 . charAt ( i ) ) ; } if ( ! st1 . equals ( st2 ) ) { return false ; } int hash2 [ ] = new int [ 256 ] ; for ( int i = 0 ; i < M ; i ++ ) { hash2 [ str2 . charAt ( i ) ] ++ ; } Arrays . sort ( hash1 ) ; Arrays . sort ( hash2 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String str1 = \" xyyzzlll \" ; String str2 = \" yllzzxxx \" ; if ( checkStr1CanConStr2 ( str1 , str2 ) ) { System . out . print ( \" True \" ) ; } else { System . out . print ( \" False \" ) ; } } }"}
{"text": "Susun array dalam julat indeks yang diberikan | Program Java untuk menyusun array dalam julat indeks tertentu; Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Susun subarray dari arr [l] ke arr [r]; Cetak array yang diubah suai; Kod pemacu", "code": "import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ; Arrays . sort ( arr , l , r + 1 ) ; for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } public static void main ( String args [ ] ) { int [ ] arr = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = arr . length ; partSort ( arr , N , a , b ) ; } }"}
{"text": "Cari kos minimum untuk mencapai destinasi menggunakan kereta api | Penyelesaian berasaskan pengaturcaraan dinamik untuk mencari kos min untuk mencapai stesen n - 1 dari stesen 0 .; Fungsi rekursif untuk mencari jalan terpendek dari sumber 'S' ke destinasi 'd'. Fungsi ini mengembalikan kos yang paling kecil untuk mencapai stesen n - 1 dari stesen 0 .; Dist [i] menyimpan kos minimum untuk mencapai stesen I dari stesen 0 .; Pergi melalui setiap stesen dan periksa jika menggunakannya sebagai stesen perantaraan memberikan jalan yang lebih baik; Program pemacu untuk menguji fungsi di atas", "code": "class shortest_path { static int INF = Integer . MAX_VALUE , N = 4 ; static int minCost ( int cost [ ] [ ] ) { int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; } public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 0 , 15 , 80 , 90 } , { INF , 0 , 40 , 50 } , { INF , INF , 0 , 70 } , { INF , INF , INF , 0 } } ; System . out . println ( \" The ▁ Minimum ▁ cost ▁ to ▁ reach ▁ station ▁ \" + N + \" ▁ is ▁ \" + minCost ( cost ) ) ; } }"}
{"text": "Bilangan gelung saiz k bermula dari nod tertentu | Program Java untuk mencari bilangan kitaran panjang K dalam graf dengan nod N. ; Kembalikan bilangan cara dari nod untuk membuat gelung saiz K dalam graf nod yang tidak disambungkan lengkap; Kod pemacu", "code": "public class GFG { static int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; } public static void main ( String args [ ] ) { int n = 4 , k = 2 ; System . out . println ( numOfways ( n , k ) ) ; } }"}
{"text": "Program untuk mencari watak bernilai ASCII terbesar dan terkecil dalam rentetan | Program Java untuk mencari aksara terbesar dan terkecil dalam rentetan. ; Fungsi yang mengembalikan abjad terbesar. ; memulakan abjad max ke 'a'; Cari abjad terbesar; kembali elemen terbesar; fungsi yang mengembalikan abjad terkecil; memulakan abjad terkecil kepada 'z'; Cari abjad terkecil; kembali abjad terkecil; Kod pemacu; Rentetan input; Mengira saiz rentetan; fungsi memanggil dan mencetak nilai yang dikembalikan", "code": "public class GFG { static char largest_alphabet ( String a , int n ) { char max = ' A ' ; for ( int i = 0 ; i < n ; i ++ ) if ( a . charAt ( i ) > max ) max = a . charAt ( i ) ; return max ; } static char smallest_alphabet ( String a , int n ) { char min = ' z ' ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a . charAt ( i ) < min ) min = a . charAt ( i ) ; return min ; } public static void main ( String args [ ] ) { String a = \" GeEksforGeeks \" ; int size = a . length ( ) ; System . out . print ( \" Largest ▁ and ▁ smallest ▁ alphabet ▁ is ▁ : ▁ \" ) ; System . out . print ( largest_alphabet ( a , size ) + \" ▁ and ▁ \" ) ; System . out . println ( smallest_alphabet ( a , size ) ) ; } }"}
{"text": "Buat palindrome terbesar dengan menukar paling banyak k | Program Java untuk mendapatkan palindrome terbesar mengubah digit at atmost; Mengembalikan maksimum palindrome menggunakan perubahan k; Memulakan l dan r oleh hujung kiri dan paling kanan; Pertama cuba membuat tali palindrome; Menggantikan watak kiri dan kanan dengan maksimum kedua -duanya; Jika k adalah negatif maka kita tidak boleh membuat palindrome rentetan; Pada watak pertengahan, jika k> 0 kemudian ubahnya menjadi 9; Jika watak di LTH (sama seperti RTH) kurang daripada 9; Jika tiada seorang pun daripada mereka diubah dalam gelung sebelumnya maka tolak 2 dari k dan tukar kedua -duanya ke 9; Jika salah satu daripada mereka diubah dalam gelung sebelumnya maka tolak 1 dari k (1 lagi telah dikurangkan) dan menjadikannya 9; Kod pemacu untuk menguji kaedah di atas", "code": "import java . text . ParseException ; class GFG { static String maximumPalinUsingKChanges ( String str , int k ) { char palin [ ] = str . toCharArray ( ) ; String ans = \" \" ; int l = 0 ; int r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { palin [ l ] = palin [ r ] = ( char ) Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) { return \" Not ▁ possible \" ; } l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) { palin [ l ] = '9' ; } } if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str . charAt ( l ) && palin [ r ] == str . charAt ( r ) ) { k -= 2 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) || palin [ r ] != str . charAt ( r ) ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } for ( int i = 0 ; i < palin . length ; i ++ ) ans += palin [ i ] ; return ans ; } public static void main ( String [ ] args ) throws ParseException { String str = \"43435\" ; int k = 3 ; System . out . println ( maximumPalinUsingKChanges ( str , k ) ) ; } }"}
{"text": "Kira tiga dengan bitwise dan sama dengan sifar | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan tiga kali ganda yang bitwise dan 0.; Menyimpan kiraan triplet yang mempunyai bitwise dan sama dengan 0; Kedai frekuensi semua yang mungkin [i] & a [j]; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Melintasi array; Melelehkan peta; Jika bitwise dan triplet adalah sifar, kenaikan CNT; Kembalikan bilangan tiga kali ganda yang bitwise dan 0 .; Kod pemacu; Arahan input; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int countTriplets ( int [ ] A ) { int cnt = 0 ; HashMap < Integer , Integer > tuples = new HashMap < Integer , Integer > ( ) ; for ( int a : A ) for ( int b : A ) { if ( tuples . containsKey ( a & b ) ) tuples . put ( a & b , tuples . get ( a & b ) + 1 ) ; else tuples . put ( a & b , 1 ) ; } for ( int a : A ) for ( Map . Entry < Integer , Integer > t : tuples . entrySet ( ) ) if ( ( t . getKey ( ) & a ) == 0 ) cnt += t . getValue ( ) ; return cnt ; } public static void main ( String [ ] args ) { int [ ] A = { 2 , 1 , 3 } ; System . out . print ( countTriplets ( A ) ) ; } }"}
{"text": "Kurangkan kiraan pasangan bersebelahan dengan pariti yang berbeza | Pelaksanaan Java pendekatan di atas; Fungsi rekursif untuk mengira pasangan bersebelahan minimum dengan pariti yang berbeza; Jika semua nombor diletakkan; Jika penggantian tidak diperlukan; Jika penggantian diperlukan; Mundur; Mundur; Berfungsi untuk memaparkan bilangan minimum elemen bersebelahan dengan pariti yang berbeza; Simpan tidak ada nombor yang tidak ada dalam array; Simpan tiada nombor ganjil yang tidak terdapat dalam array; Memadam nombor exisiting; Simpan bukan nombor dan nombor ganjil; Kod pemacu", "code": "import java . util . * ; public class Main { static int min ; static void parity ( List < Integer > even , List < Integer > odd , List < Integer > v , int i ) { if ( i == v . size ( ) || even . size ( ) == 0 && odd . size ( ) == 0 ) { int count = 0 ; for ( int j = 0 ; j < v . size ( ) - 1 ; j ++ ) { if ( v . get ( j ) % 2 != v . get ( j + 1 ) % 2 ) count ++ ; } if ( count < min ) min = count ; return ; } if ( v . get ( i ) != - 1 ) parity ( even , odd , v , i + 1 ) ; else { if ( even . size ( ) != 0 ) { int x = even . get ( even . size ( ) - 1 ) ; even . remove ( even . size ( ) - 1 ) ; v . set ( i , x ) ; parity ( even , odd , v , i + 1 ) ; even . add ( x ) ; } if ( odd . size ( ) != 0 ) { int x = odd . get ( odd . size ( ) - 1 ) ; odd . remove ( odd . size ( ) - 1 ) ; v . set ( i , x ) ; parity ( even , odd , v , i + 1 ) ; odd . add ( x ) ; } } } static void minDiffParity ( List < Integer > v , int n ) { List < Integer > even = new ArrayList < Integer > ( ) ; List < Integer > odd = new ArrayList < Integer > ( ) ; HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( m . containsKey ( i ) ) { m . replace ( i , 1 ) ; } else { m . put ( i , 1 ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . get ( i ) != - 1 ) m . remove ( v . get ( i ) ) ; } for ( Map . Entry < Integer , Integer > i : m . entrySet ( ) ) { if ( i . getKey ( ) % 2 == 0 ) { even . add ( i . getKey ( ) ) ; } else { odd . add ( i . getKey ( ) ) ; } } min = 1000 ; parity ( even , odd , v , 0 ) ; System . out . println ( min ) ; } public static void main ( String [ ] args ) { int n = 8 ; List < Integer > v = new ArrayList < Integer > ( ) ; v . add ( 2 ) ; v . add ( 1 ) ; v . add ( 4 ) ; v . add ( - 1 ) ; v . add ( - 1 ) ; v . add ( 6 ) ; v . add ( - 1 ) ; v . add ( 8 ) ; minDiffParity ( v , n ) ; } }"}
{"text": "Cari triplet sedemikian rupa sehingga bilangan nod yang menghubungkan triplet ini adalah maksimum | Pelaksanaan Java pendekatan; Untuk menyimpan nod yang diperlukan; Array induk untuk menjejaki semula nod; Arahan yang dikunjungi untuk mengelakkan DFS ke arah di garis pusat; Fungsi DFS untuk mencari startnode; Fungsi DFS untuk mencari endnode diameter dan mengekalkan array induk; Fungsi DFS untuk mencari nod akhir cawangan terpanjang ke diameter; Fungsi untuk mencari nod yang diperlukan; Untuk mencari node diameter; Untuk mencari nod akhir diameter; x adalah nod akhir diameter; Tandakan semua nod diameter menggunakan penjejakan belakang; Cari nod akhir cawangan terpanjang ke diameter; Kod pemacu", "code": "import java . util . * ; class GFG { static int MAX = 100005 ; static Vector < Vector < Integer > > adjacent = new Vector < Vector < Integer > > ( ) ; static boolean visited [ ] = new boolean [ MAX ] ; static int startnode , endnode , thirdnode ; static int maxi = - 1 , N ; static int parent [ ] = new int [ MAX ] ; static boolean vis [ ] = new boolean [ MAX ] ; static void dfs ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent . get ( u ) . size ( ) ; i ++ ) { if ( ! visited [ adjacent . get ( u ) . get ( i ) ] ) { temp ++ ; dfs ( adjacent . get ( u ) . get ( i ) , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; startnode = u ; } } } static void dfs1 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent . get ( u ) . size ( ) ; i ++ ) { if ( ! visited [ adjacent . get ( u ) . get ( i ) ] ) { temp ++ ; parent [ adjacent . get ( u ) . get ( i ) ] = u ; dfs1 ( adjacent . get ( u ) . get ( i ) , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; endnode = u ; } } } static void dfs2 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent . get ( u ) . size ( ) ; i ++ ) { if ( ! visited [ adjacent . get ( u ) . get ( i ) ] && ! vis [ adjacent . get ( u ) . get ( i ) ] ) { temp ++ ; dfs2 ( adjacent . get ( u ) . get ( i ) , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; thirdnode = u ; } } } static void findNodes ( ) { dfs ( 1 , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; maxi = - 1 ; dfs1 ( startnode , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; int x = endnode ; vis [ startnode ] = true ; while ( x != startnode ) { vis [ x ] = true ; x = parent [ x ] ; } maxi = - 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] ) dfs2 ( i , 0 ) ; } } public static void main ( String args [ ] ) { for ( int i = 0 ; i < MAX ; i ++ ) adjacent . add ( new Vector < Integer > ( ) ) ; N = 4 ; adjacent . get ( 1 ) . add ( 2 ) ; adjacent . get ( 2 ) . add ( 1 ) ; adjacent . get ( 1 ) . add ( 3 ) ; adjacent . get ( 3 ) . add ( 1 ) ; adjacent . get ( 1 ) . add ( 4 ) ; adjacent . get ( 4 ) . add ( 1 ) ; findNodes ( ) ; System . out . print ( \" ( \" + startnode + \" , ▁ \" + endnode + \" , ▁ \" + thirdnode + \" ) \" ) ; } }"}
{"text": "Peratusan peningkatan jumlah sfera jika radius meningkat dengan peratusan tertentu | Program Java untuk mencari peningkatan peratusan dalam jumlah sfera jika radius meningkat dengan peratusan tertentu; Kod pemacu", "code": "import java . io . * ; class GFG { static void newvol ( double x ) { System . out . print ( \" percentage ▁ increase ▁ in ▁ the \" + \" ▁ volume ▁ of ▁ the ▁ sphere ▁ is ▁ \" + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + \" % \" ) ; } public static void main ( String [ ] args ) { double x = 10 ; newvol ( x ) ; } }"}
{"text": "Panjang kord bulatan yang jejari dan sudutnya diselipkan di pusat oleh kord diberikan | Program Java untuk mencari kord panjang bulatan yang radius dan sudut yang diselaraskan di pusat juga diberikan; Berfungsi untuk mencari panjang kord; Kod pemacu", "code": "class GFG { static void length_of_chord ( double r , double x ) { System . out . println ( \" The ▁ length ▁ of ▁ the ▁ chord \" + \" ▁ of ▁ the ▁ circle ▁ is ▁ \" + 2 * r * Math . sin ( x * ( 3.14 / 180 ) ) ) ; } public static void main ( String [ ] args ) { double r = 4 , x = 63 ; length_of_chord ( r , x ) ; } }"}
{"text": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segitiga sama rata | Program Java untuk mencari kawasan persegi yang tertulis dalam bulatan yang seterusnya ditulis dalam segitiga sama rata; Berfungsi untuk mencari kawasan dataran; A tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "import java . io . * ; class GFG { static float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . sqrt ( a ) / 6 ; return area ; } public static void main ( String [ ] args ) { float a = 10 ; System . out . println ( area ( a ) ) ; } }"}
{"text": "Panjang batang terpanjang yang boleh dimuatkan ke dalam cuboid | Program Java untuk mencari rod terpanjang yang boleh dimuatkan dalam cuboid; Berfungsi untuk mencari panjang; Pembolehubah sementara untuk memegang hasil pertengahan; Panjang rod terpanjang dikira menggunakan fungsi akar persegi; Kod pemacu; Memanggil LongeStroDincuboid () berfungsi untuk mendapatkan panjang rod terpanjang", "code": "class GFG { static double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = Math . sqrt ( temp ) ; return result ; } public static void main ( String [ ] args ) { int length = 12 , breadth = 9 , height = 8 ; System . out . println ( ( int ) longestRodInCuboid ( length , breadth , height ) ) ; } }"}
{"text": "Semak sama ada titik tertentu terletak pada atau di dalam segi empat tepat | Set 3 | Program Java untuk memeriksa sama ada titik tertentu terletak di dalam atau di segi empat tepat atau tidak; berfungsi untuk memeriksa sama ada titik tertentu terletak di dalam atau di segi empat tepat atau tidak; Kod pemacu", "code": "class GFG { static boolean LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int a = 7 , b = 2 , x = 4 , y = 5 ; if ( LiesInsieRectangle ( a , b , x , y ) ) System . out . println ( \" Given ▁ point ▁ lies ▁ \" + \" inside ▁ the ▁ rectangle \" ) ; else System . out . println ( \" Given ▁ point ▁ does ▁ not ▁ \" + \" lie ▁ on ▁ the ▁ rectangle \" ) ; } }"}
{"text": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | Kod Java untuk memaksimumkan jumlah cuboid dengan jumlah yang diberikan; Kembalikan jumlah maksimum. ; untuk panjang; untuk keluasan; untuk ketinggian; Mengira isipadu maksimum. ; Fungsi pemacu", "code": "class GFG { static int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; } public static void main ( String [ ] args ) { int s = 8 ; System . out . println ( maxvolume ( s ) ) ; } }"}
{"text": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | Kod Java untuk memaksimumkan jumlah cuboid dengan jumlah yang diberikan; Kembalikan jumlah maksimum. ; mencari panjang; mencari keluasan; Mencari ketinggian; Program yang didorong", "code": "import java . io . * ; class GFG { static int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; } public static void main ( String [ ] args ) { int s = 8 ; System . out . println ( maxvolume ( s ) ) ; } }"}
{"text": "Kawasan Hexagon | Program Java untuk mencari kawasan segi enam; Buat fungsi untuk mengira kawasan segi enam. ; Kod pemacu; Panjang sisi", "code": "class GFG { public static double hexagonArea ( double s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; } public static void main ( String [ ] args ) { double s = 4 ; System . out . print ( \" Area : ▁ \" + hexagonArea ( s ) ) ; } }"}
{"text": "Bilangan maksimum kuadrat yang boleh dimuatkan dalam segitiga isosceles sudut kanan | Program Java untuk mencari dataran maksimum yang boleh dimuatkan dalam segi tiga sudut yang betul; fungsi untuk mencari dataran maksimum; kembali dalam O (1) dengan formula yang diperoleh; Program Pemandu", "code": "public class GFG { static int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; } public static void main ( String args [ ] ) { int b = 10 , m = 2 ; System . out . println ( maxSquare ( b , m ) ) ; } }"}
{"text": "Semak jika segitiga yang betul mungkin dari kawasan tertentu dan hipotenus | Program Java untuk memeriksa kewujudan segitiga yang betul. ; Mencetak tiga sisi segitiga kanan dari kawasan tertentu dan hipotenus jika segitiga mungkin, cetakan lain - 1 .; Deskripsi persamaan; memohon formula persamaan linear untuk mencari kedua -dua akar; Kod pemacu", "code": "class GFG { static void findRightAngle ( double A , double H ) { double D = Math . pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { double root1 = ( H * H + Math . sqrt ( D ) ) / 2 ; double root2 = ( H * H - Math . sqrt ( D ) ) / 2 ; double a = Math . sqrt ( root1 ) ; double b = Math . sqrt ( root2 ) ; if ( b >= a ) System . out . print ( a + \" ▁ \" + b + \" ▁ \" + H ) ; else System . out . print ( b + \" ▁ \" + a + \" ▁ \" + H ) ; } else System . out . print ( \" - 1\" ) ; } public static void main ( String arg [ ] ) { findRightAngle ( 6 , 5 ) ; } }"}
{"text": "Bilangan maksimum 2 x2 kotak yang boleh dimuatkan di dalam segitiga isosceles kanan | Program Java untuk mengira bilangan 2 x 2 kotak di segitiga isosceles yang betul; Mengeluarkan bahagian tambahan yang selalu kita perlukan; Kerana setiap persegi mempunyai asas panjang 2; Kod pemacu", "code": "class Squares { public static int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = Math . floorDiv ( base , 2 ) ; return base * ( base + 1 ) / 2 ; } public static void main ( String args [ ] ) { int base = 8 ; System . out . println ( numberOfSquares ( base ) ) ; } }"}
{"text": "Bitwise atau bitwise dan semua yang mungkin bukan | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bitwise atau bitwise dan semua subarray yang mungkin selepas melakukan setiap pertanyaan; Melintasi setiap pasangan pertanyaan; Menyimpan bitwise atau; Mengemas kini array; Cari bitwise atau array baru yang dikemas kini; Cetak Ans; Kod pemacu", "code": "import java . io . * ; class GFG { static void performQuery ( int arr [ ] , int Q [ ] [ ] ) { for ( int i = 0 ; i < Q . length ; i ++ ) { int or = 0 ; int x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( int j = 0 ; j < arr . length ; j ++ ) { or = or | arr [ j ] ; } System . out . print ( or + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int Q [ ] [ ] = { { 1 , 4 } , { 3 , 0 } } ; performQuery ( arr , Q ) ; } }"}
{"text": "Panjang terkecil nombor yang boleh dibahagi dengan k yang dibentuk dengan menggunakan d sahaja | Program Java untuk pendekatan di atas; Berfungsi untuk membentuk bilangan terkecil yang mungkin; Array untuk menandakan baki yang telah dikira sudah; Melangkah ke atas julat; Jika baki itu sudah dijumpai, kembali - 1; Kod pemacu", "code": "import java . util . * ; class GFG { static int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; int [ ] v = new int [ k ] ; Arrays . fill ( v , 0 ) ; v [ m ] = 1 ; while ( 1 != 0 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } } public static void main ( String [ ] args ) { int d = 1 ; int k = 41 ; System . out . println ( smallest ( k , d ) ) ; } }"}
{"text": "Grafik Cube Fibonacci | Kod Java untuk mencari simpul dalam graf kiub Fibonacci Order N; berfungsi untuk mencari nombor Fibonacci; fungsi untuk mencari bilangan simpang dalam graf kiub Fibonacci; kembali nombor fibonacci untuk f (n + 2); Kod pemacu", "code": "public class GFG { static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } static int findVertices ( int n ) { return fib ( n + 2 ) ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . println ( findVertices ( n ) ) ; } }"}
{"text": "Ubah suai array supaya array tidak mengandungi mana -mana pembahagi biasa selain 1 | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mengubah suai array supaya tidak ada faktor yang sama antara elemen array kecuali 1; Menyimpan GCD array; Hitung GCD array; Jika pembahagi semasa lebih kecil daripada x; Bahagikan GCD oleh pembahagi semasa; Jika boleh; Cetak array yang diubah suai; Jika tidak; Mengira GCD; Kod pemacu; Diberikan array; Saiz array", "code": "class GFG { static void checkCommonDivisor ( int [ ] arr , int N , int X ) { int G = 0 ; for ( int i = 0 ; i < N ; i ++ ) { G = gcd ( G , arr [ i ] ) ; } int copy_G = G ; for ( int divisor = 2 ; divisor <= X ; divisor ++ ) { while ( G % divisor == 0 ) { G = G / divisor ; } } if ( G <= X ) { System . out . println ( \" Yes \" ) ; for ( int i = 0 ; i < N ; i ++ ) System . out . print ( ( arr [ i ] / copy_G ) + \" ▁ \" ) ; System . out . println ( ) ; } else System . out . println ( \" No \" ) ; } static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 6 , 15 , 6 } ; int X = 6 ; int N = arr . length ; checkCommonDivisor ( arr , N , X ) ; } }"}
{"text": "Program untuk mencetak corak lingkaran | Buat baris dan col untuk melintasi baris dan lajur; Pembolehubah untuk menentukan pergerakan r = kanan, l = kiri, d = ke bawah, u = atas; Array untuk matriks; Berikan nilai; suis - kes untuk menentukan indeks seterusnya; Jika betul, pergi ke kanan; jika ditinggalkan, pergi ke kiri; jika naik, naik; jika turun, turun; Semak jika matriks telah mencapai sempadan array; Tambah saiz kiri untuk sempadan seterusnya; Jika 2 putaran telah dibuat, mengurangkan saiz yang ditinggalkan oleh 1; suis - kes untuk memutar pergerakan; jika betul, putar ke bawah; jika turun, putar ke kiri; jika dibiarkan, putar ke atas; jika naik, putar ke kanan; Cetak matriks; Kod pemacu; Dapatkan saiz saiz; Cetak corak lingkaran", "code": "public class GFG { public static void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ; char move = ' r ' ; int matrix [ ] [ ] = new int [ size ] [ size ] ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row ] [ col ] = i ; switch ( move ) { case ' r ' : col += 1 ; break ; case ' l ' : col -= 1 ; break ; case ' u ' : row -= 1 ; break ; case ' d ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' r ' : move = ' d ' ; break ; case ' d ' : move = ' l ' ; break ; case ' l ' : move = ' u ' ; break ; case ' u ' : move = ' r ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; System . out . print ( ( n < 10 ) ? ( n + \" ▁ \" ) : ( n + \" ▁ \" ) ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int size = 5 ; printSpiral ( size ) ; } }"}
{"text": "Sort Biotonic Doubly Linked List | Pelaksanaan Java untuk menyusun senarai dikaitkan dua biotonik; nod senarai dikaitkan dua kali ganda; Berfungsi untuk membalikkan senarai dikaitkan dua kali ganda; swap seterusnya dan sebelumnya untuk semua nod senarai dikaitkan dua kali ganda; Sebelum menukar kepala, periksa kes -kes seperti senarai kosong dan senarai dengan hanya satu nod; Berfungsi untuk menggabungkan dua senarai dikaitkan dua kali ganda; Jika senarai yang dipautkan pertama kosong; Jika senarai dikaitkan kedua kosong; Pilih nilai yang lebih kecil; berfungsi untuk menyusun senarai dikaitkan dua kali ganda biotonik; Jika senarai kosong atau jika ia mengandungi satu nod tunggal; Jika benar, maka 'semasa' adalah nod pertama yang lebih kecil daripada nod sebelumnya; Pindah ke nod seterusnya; Jika benar, maka senarai sudah disusun; tumpah ke dalam dua senarai, satu bermula dengan 'kepala' dan yang lain bermula dengan 'semasa'; membalikkan senarai bermula dengan 'semasa'; Gabungkan kedua -dua senarai dan kembalikan senarai dikaitkan dua kali ganda; Berfungsi untuk memasukkan nod pada permulaan senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; Oleh kerana kita menambah pada mulanya, sebelum ini sentiasa batal; Pautan senarai lama dari nod baru; Tukar Node kepala ke nod baru; gerakkan kepala untuk menunjuk ke nod baru; Berfungsi untuk mencetak nod dalam senarai dikaitkan dua kali ganda; Jika senarai kosong; Kod pemacu; Buat senarai dikaitkan dua kali: 2 <.5 <.7 <.12 <.10 <.6 <.4 <.1; Susun DLL Biotonik", "code": "class GFG { static class Node { int data ; Node next ; Node prev ; } static Node reverse ( Node head_ref ) { Node temp = null ; Node current = head_ref ; while ( current != null ) { temp = current . prev ; current . prev = current . next ; current . next = temp ; current = current . prev ; } if ( temp != null ) head_ref = temp . prev ; return head_ref ; } static Node merge ( Node first , Node second ) { if ( first == null ) return second ; if ( second == null ) return first ; if ( first . data < second . data ) { first . next = merge ( first . next , second ) ; first . next . prev = first ; first . prev = null ; return first ; } else { second . next = merge ( first , second . next ) ; second . next . prev = second ; second . prev = null ; return second ; } } static Node sort ( Node head ) { if ( head == null head . next == null ) return head ; Node current = head . next ; while ( current != null ) { if ( current . data < current . prev . data ) break ; current = current . next ; } if ( current == null ) return head ; current . prev . next = null ; current . prev = null ; current = reverse ( current ) ; return merge ( head , current ) ; } static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . prev = null ; new_node . next = ( head_ref ) ; if ( ( head_ref ) != null ) ( head_ref ) . prev = new_node ; ( head_ref ) = new_node ; return head_ref ; } static void printList ( Node head ) { if ( head == null ) System . out . println ( \" Doubly ▁ Linked ▁ list ▁ empty \" ) ; while ( head != null ) { System . out . print ( head . data + \" ▁ \" ) ; head = head . next ; } } public static void main ( String args [ ] ) { Node head = null ; head = push ( head , 1 ) ; head = push ( head , 4 ) ; head = push ( head , 6 ) ; head = push ( head , 10 ) ; head = push ( head , 12 ) ; head = push ( head , 7 ) ; head = push ( head , 5 ) ; head = push ( head , 2 ) ; System . out . println ( \" Original ▁ Doubly ▁ linked ▁ list : n \" ) ; printList ( head ) ; head = sort ( head ) ; System . out . println ( \" Doubly linked list after sorting : n \"); printList ( head ) ; } }"}
{"text": "Susun konsonan dan vokal nod dalam senarai yang dipautkan | Program Java untuk mengatur konsonan dan nod vokal dalam senarai yang dipautkan; Nod senarai yang dipautkan; Berfungsi untuk menambah nod baru ke senarai; fungsi utiliti untuk mencetak senarai yang dipautkan; fungsi utiliti untuk memeriksa vokal; berfungsi untuk mengatur konsonan dan nod vokal; untuk menjejaki vokal; senarai kosong; Kita perlu menemui vokal pertama dalam senarai. Ia akan menjadi kepala yang dikembalikan, dan juga Latarvowel awal. ; Unsur pertama adalah vokal. Ia juga akan menjadi kepala baru dan Latarvowel awal; ; Unsur pertama bukan vokal. Keluarkan melalui senarai sehingga kita dapati vokal. Perhatikan bahawa Curr menunjuk kepada elemen * sebelum * elemen dengan vokal. ; Ini adalah kes kelebihan di mana terdapat hanya konsonan dalam senarai. ; Tetapkan Latihan Awal dan kepala baru ke item vokal yang kami dapati. Relink rantai konsonan selepas item vokal itu: old_head_consonant -> consonant1 -> consonant2 -> vokal -> rest_of_list menjadi vokal -> old_head_consonant -> consonant1 -> consonant2 -> rest_of_list; Sekarang melintasi senarai. Curr sentiasa item * sebelum * yang kita periksa, supaya kita boleh menggunakannya untuk menghubungkan semula. ; Item yang ditemui seterusnya adalah vokal; Sekiranya ia datang secara langsung selepas vokal sebelumnya, kami tidak perlu memindahkan item di sekitar, hanya tandakan LatarVowel baru dan Advance Curr. ; Tetapi jika ia datang selepas rantaian konsonan intervensi, kita perlu mengikat vokal yang baru ditemui selepas vokal lama. Curr tidak berubah kerana selepas menghubungkannya akan mempunyai yang baru, yang belum diperiksa, dan kami sentiasa menyimpan Curr pada satu sebelum pemeriksaan seterusnya. ; Rantai dalam vokal baru; Advance Latestvowel; Keluarkan vokal yang dijumpai dari tempat sebelumnya; Re - Rantaian Konsonan Pautan Selepas Latihan Latihan; Tiada vokal dalam elemen seterusnya, Advance Curr. ; Kod pemacu", "code": "class GfG { static class Node { char data ; Node next ; } static Node newNode ( char key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } static void printlist ( Node head ) { if ( head == null ) { System . out . println ( \" Empty ▁ List \" ) ; return ; } while ( head != null ) { System . out . print ( head . data + \" ▁ \" ) ; if ( head . next != null ) System . out . print ( \" - > ▁ \" ) ; head = head . next ; } System . out . println ( ) ; } static boolean isVowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } static Node arrange ( Node head ) { Node newHead = head ; Node latestVowel ; Node curr = head ; if ( head == null ) return null ; if ( isVowel ( head . data ) == true ) latestVowel = head ; else { while ( curr . next != null && ! isVowel ( curr . next . data ) ) curr = curr . next ; if ( curr . next == null ) return head ; latestVowel = newHead = curr . next ; curr . next = curr . next . next ; latestVowel . next = head ; } while ( curr != null && curr . next != null ) { if ( isVowel ( curr . next . data ) == true ) { if ( curr == latestVowel ) { latestVowel = curr = curr . next ; } else { Node temp = latestVowel . next ; latestVowel . next = curr . next ; latestVowel = latestVowel . next ; curr . next = curr . next . next ; latestVowel . next = temp ; } } else { curr = curr . next ; } } return newHead ; } public static void main ( String [ ] args ) { Node head = newNode ( ' a ' ) ; head . next = newNode ( ' b ' ) ; head . next . next = newNode ( ' c ' ) ; head . next . next . next = newNode ( ' e ' ) ; head . next . next . next . next = newNode ( ' d ' ) ; head . next . next . next . next . next = newNode ( ' o ' ) ; head . next . next . next . next . next . next = newNode ( ' x ' ) ; head . next . next . next . next . next . next . next = newNode ( ' i ' ) ; System . out . println ( \" Linked ▁ list ▁ before ▁ : ▁ \" ) ; printlist ( head ) ; head = arrange ( head ) ; System . out . println ( \" Linked ▁ list ▁ after ▁ : \" ) ; printlist ( head ) ; } }"}
{"text": "Elemen terbesar di BST menggunakan ruang tambahan yang berterusan | Program Java untuk Menemukan K - TH Node Terbesar Menggunakan O (1) Memori Tambahan dan Reverse Morris Traversal. ; Struktur nod; fungsi penolong untuk membuat nod baru; Mengira pembolehubah untuk menyimpan kiraan nod yang dikunjungi; Jika anak yang betul adalah batal; kiraan kenaikan pertama dan semak jika Count = k; Jika tidak berpindah ke anak kiri; Cari pengganti inorder nod semasa; Tetapkan anak kiri pengganti ke nod semasa; gerakkan arus ke kanannya; memulihkan pokok itu kembali ke pokok carian binari asal yang mengeluarkan pautan berulir; gerakkan arus ke anak kiri; Kod pemacu; Pokok binari yang dibina adalah 4 / \\ 2 7 / \\ / \\ 1 3 6 10", "code": "class GfG { static class Node { int data ; Node left , right ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . right = null ; temp . left = null ; return temp ; } static Node KthLargestUsingMorrisTraversal ( Node root , int k ) { Node curr = root ; Node Klargest = null ; int count = 0 ; while ( curr != null ) { if ( curr . right == null ) { if ( ++ count == k ) Klargest = curr ; curr = curr . left ; } else { Node succ = curr . right ; while ( succ . left != null && succ . left != curr ) succ = succ . left ; if ( succ . left == null ) { succ . left = curr ; curr = curr . right ; } else { succ . left = null ; if ( ++ count == k ) Klargest = curr ; curr = curr . left ; } } } return Klargest ; } public static void main ( String [ ] args ) { Node root = newNode ( 4 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 7 ) ; root . left . left = newNode ( 1 ) ; root . left . right = newNode ( 3 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 10 ) ; System . out . println ( \" Finding ▁ K - th ▁ largest ▁ Node ▁ in ▁ BST ▁ : ▁ \" + KthLargestUsingMorrisTraversal ( root , 2 ) . data ) ; } }"}
{"text": "Penyusun baris matriks dalam urutan menaik diikuti oleh lajur dalam urutan menurun | Pelaksanaan Java untuk menyusun baris matriks dalam urutan menaik diikuti dengan menyusun lajur dalam urutan menurun; Fungsi untuk menyusun setiap baris matriks mengikut perintah yang ditentukan oleh menaik. ; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [] []; dapatkan transpose tikar [] []; Sekali lagi menyusun baris Mat [] [] dalam urutan menurun. ; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu", "code": "import java . util . Arrays ; import java . util . Collections ; class GFG { static int MAX_SIZE = 10 ; static void sortByRow ( Integer mat [ ] [ ] , int n , boolean ascending ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ascending ) Arrays . sort ( mat [ i ] ) ; else Arrays . sort ( mat [ i ] , Collections . reverseOrder ( ) ) ; } } static void transpose ( Integer mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } } static void sortMatRowAndColWise ( Integer mat [ ] [ ] , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; } static void printMat ( Integer mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + \" ▁ \" ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int n = 3 ; Integer mat [ ] [ ] = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; System . out . print ( \"Original Matrix:NEW_LINE\"); printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; System . out . print ( \" Matrix After Sorting : \"); printMat ( mat , n ) ; } }"}
{"text": "Susun baris matriks | Pelaksanaan Java untuk menyusun baris matriks - bijak dan lajur - bijak; berfungsi untuk menyusun setiap baris matriks; menyusun nombor baris 'i'; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [] []; dapatkan transpose tikar [] []; sekali lagi menyusun baris tikar [] []; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu", "code": "import java . util . Arrays ; class GFG { static final int MAX_SIZE = 10 ; static void sortByRow ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( mat [ i ] ) ; } static void transpose ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } } static void sortMatRowAndColWise ( int mat [ ] [ ] , int n ) { sortByRow ( mat , n ) ; transpose ( mat , n ) ; sortByRow ( mat , n ) ; transpose ( mat , n ) ; } static void printMat ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + \" ▁ \" ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 4 , 1 , 3 } , { 9 , 6 , 8 } , { 5 , 2 , 7 } } ; int n = 3 ; System . out . print ( \"Original Matrix:NEW_LINE\"); printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; System . out . print ( \" Matrix After Sorting : \"); printMat ( mat , n ) ; } }"}
{"text": "Magic Square | Malah pesanan | Program Java untuk mencetak Magic Square of Doubly Even Order; Fungsi untuk mengira Magic Square; Mengisi matriks dengan nilai kiraannya bermula dari 1; ; Tukar nilai elemen array di lokasi pembaikan seperti peraturan (n * n + 1) - arr [i] [j] sudut kiri atas matriks (perintah (n / 4) * (n / 4)); Sudut kanan atas matriks (perintah (n / 4) * (n / 4)); Sudut kiri bawah matriks (pesanan (n / 4) * (n / 4)); Sudut kanan bawah matriks (pesanan (n / 4) * (n / 4)); Pusat matriks (perintah (n / 2) * (n / 2)); Mencetak Magic - Square; program pemacu; Panggilan fungsi", "code": "import java . io . * ; class GFG { static void doublyEven ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * i ) + j + 1 ; for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 3 * ( n / 4 ) ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 3 * n / 4 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = n / 4 ; i < 3 * n / 4 ; i ++ ) for ( j = n / 4 ; j < 3 * n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) System . out . print ( arr [ i ] [ j ] + \" ▁ \" ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int n = 8 ; doublyEven ( n ) ; } }"}
{"text": "Produk Kronecker Dua Matriks | Kod Java untuk mencari produk Kronecker dari dua matriks dan menyimpannya sebagai matriks C; Rowa dan Cola tidak ada baris dan lajur matriks A rowb dan colb tidak ada baris dan lajur matriks B; Berfungsi untuk mengira produk Kronecker dua matriks; Saya gelung sehingga Rowa; k gelung hingga rowb; J Loops hingga Cola; l Loops hingga Colb; Setiap elemen matriks A didarab dengan keseluruhan matriks B resp dan disimpan sebagai matriks c; Program Pemandu", "code": "import java . io . * ; import java . util . * ; class GFG { static int cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ; static void Kroneckerproduct ( int A [ ] [ ] , int B [ ] [ ] ) { int [ ] [ ] C = new int [ rowa * rowb ] [ cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; System . out . print ( C [ i + l + 1 ] [ j + k + 1 ] + \" ▁ \" ) ; } } System . out . println ( ) ; } } } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } ; int B [ ] [ ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; Kroneckerproduct ( A , B ) ; } }"}
{"text": "Program untuk memeriksa sama ada matriks adalah segitiga yang lebih rendah | Program Java untuk memeriksa matriks segi tiga yang lebih rendah. ; Fungsi untuk memeriksa matriks adalah dalam bentuk segi tiga yang lebih rendah atau tidak. ; Fungsi pemacu. ; Panggilan fungsi", "code": "import java . io . * ; class Lower_triangular { int N = 4 ; boolean isLowerTriangularMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } public static void main ( String args [ ] ) { Lower_triangular ob = new Lower_triangular ( ) ; int mat [ ] [ ] = { { 1 , 0 , 0 , 0 } , { 1 , 4 , 0 , 0 } , { 4 , 6 , 2 , 0 } , { 0 , 4 , 7 , 6 } } ; if ( ob . isLowerTriangularMatrix ( mat ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Program untuk memeriksa sama ada matriks adalah segitiga atas | Program Java untuk memeriksa matriks segitiga atas. ; Fungsi untuk memeriksa matriks adalah dalam bentuk segi tiga atas atau tidak. ; fungsi pemacu", "code": "import java . util . * ; import java . lang . * ; public class GfG { private static final int N = 4 ; public static Boolean isUpperTriangularMatrix ( int mat [ ] [ ] ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } public static void main ( String argc [ ] ) { int [ ] [ ] mat = { { 1 , 3 , 5 , 3 } , { 0 , 4 , 6 , 2 } , { 0 , 0 , 2 , 5 } , { 0 , 0 , 0 , 6 } } ; if ( isUpperTriangularMatrix ( mat ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Mengira set 1 s dan 0 s dalam matriks binari | Program Java untuk mengira bilangan set dalam matriks binari. ; tiada lajur; tiada baris; berfungsi untuk mengira bilangan set sel yang tidak kosong; menyimpan jawapan terakhir; Traverses Row - Bijaksana; Traverses Column Wise; Pada akhirnya tolak n * m kerana tiada set tunggal telah ditambah dua kali. ; Kod pemacu", "code": "class GFG { static final int m = 3 ; static final int n = 2 ; static long countSets ( int a [ ] [ ] ) { long res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] [ j ] == 1 ) u ++ ; else v ++ ; } res += Math . pow ( 2 , u ) - 1 + Math . pow ( 2 , v ) - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] [ i ] == 1 ) u ++ ; else v ++ ; } res += Math . pow ( 2 , u ) - 1 + Math . pow ( 2 , v ) - 1 ; } return res - ( n * m ) ; } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 0 , 1 } , { 0 , 1 , 0 } } ; System . out . print ( countSets ( a ) ) ; } }"}
{"text": "Program untuk memeriksa sama ada matriks adalah simetri | Kod Java mudah untuk memeriksa matriks adalah simetri atau tidak. ; Mengisi transpose mat [n] [n] dalam tr [n] [n]; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu", "code": "import java . io . * ; class GFG { static int MAX = 100 ; static void transpose ( int mat [ ] [ ] , int tr [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) tr [ i ] [ j ] = mat [ j ] [ i ] ; } static boolean isSymmetric ( int mat [ ] [ ] , int N ) { int tr [ ] [ ] = new int [ N ] [ MAX ] ; transpose ( mat , tr , N ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) return false ; return true ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Program untuk memeriksa sama ada matriks adalah simetri | Kod Java yang cekap untuk memeriksa matriks adalah simetri atau tidak; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu", "code": "import java . io . * ; class GFG { static int MAX = 100 ; static boolean isSymmetric ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text": "Program untuk mencari normal dan jejak matriks | Program Java untuk mencari jejak dan normal matriks yang diberikan; Saiz matriks yang diberikan; Pulangan normal matriks saiz n x n; Mengembalikan jejak matriks saiz n x n; Sumber yang didorong", "code": "import java . io . * ; class GFG { static int MAX = 100 ; static int findNormal ( int mat [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; return ( int ) Math . sqrt ( sum ) ; } static int findTrace ( int mat [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += mat [ i ] [ i ] ; return sum ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; System . out . println ( \" Trace ▁ of ▁ Matrix ▁ = ▁ \" + findTrace ( mat , 5 ) ) ; System . out . println ( \" Normal ▁ of ▁ Matrix ▁ = ▁ \" + findNormal ( mat , 5 ) ) ; } }"}
{"text": "Penentu maksimum matriks dengan setiap nilai sama ada 0 atau n | Program Java untuk mencari penentu maksimum mungkin 0 / N matriks. ; Fungsi untuk penentu maksimum; Berfungsi untuk mencetak matriks resulatant; tiga kedudukan di mana 0 muncul; kedudukan di mana n muncul; Kod pemacu", "code": "import java . io . * ; public class GFG { static int maxDet ( int n ) { return ( 2 * n * n * n ) ; } void resMatrix ( int n ) { for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( i == 0 && j == 2 ) System . out . print ( \"0 ▁ \" ) ; else if ( i == 1 && j == 0 ) System . out . print ( \"0 ▁ \" ) ; else if ( i == 2 && j == 1 ) System . out . print ( \"0 ▁ \" ) ; else System . out . print ( n + \" ▁ \" ) ; } System . out . println ( \" \" ) ; } } static public void main ( String [ ] args ) { int n = 15 ; GFG geeks = new GFG ( ) ; System . out . println ( \" Maximum ▁ Determinant ▁ = ▁ \" + maxDet ( n ) ) ; System . out . println ( \" Resultant ▁ Matrix ▁ : \" ) ; geeks . resMatrix ( n ) ; } }"}
{"text": "Kira nombor negatif dalam lajur | Pelaksanaan Java kaedah naif untuk mengira nombor negatif dalam m [n] [m]; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; Tiada nombor negatif dalam baris ini; Program pemacu untuk menguji fungsi di atas", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; } public static void main ( String [ ] args ) { int M [ ] [ ] = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; System . out . println ( countNegative ( M , 3 , 4 ) ) ; } }"}
{"text": "Kira nombor negatif dalam lajur | Pelaksanaan Java kaedah yang cekap untuk mengira nombor negatif dalam m [n] [m]; Berfungsi untuk mengira nombor negatif; memulakan hasil; Mulakan dengan sudut kanan atas; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; J ialah indeks nombor negatif terakhir dalam baris ini. Jadi mesti ada (j + 1); Nombor negatif dalam baris ini. ; Pindah ke kiri dan lihat jika kita dapat mencari nombor negatif di sana; Program pemacu untuk menguji fungsi di atas", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; } public static void main ( String [ ] args ) { int M [ ] [ ] = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; System . out . println ( countNegative ( M , 3 , 4 ) ) ; } }"}
{"text": "Kira nombor negatif dalam lajur | Pelaksanaan Java kaedah yang lebih cekap untuk mengira bilangan nombor negatif dalam baris - matriks disusun lajur m [n] [m]; Carian binari rekursif untuk mendapatkan nilai negatif terakhir berturut -turut antara permulaan dan akhir; Kes asas; Dapatkan pertengahan untuk carian binari; Jika elemen semasa adalah negatif; Jika ia adalah elemen negatif paling kanan dalam baris semasa; Semak separuh kanan array; Semak di separuh kiri array; Fungsi untuk mengembalikan kiraan nombor negatif dalam matriks yang diberikan; Memulakan hasil; Untuk menyimpan indeks elemen negatif paling kanan dalam baris yang dipertimbangkan; Melangkah ke atas semua baris matriks; Jika elemen pertama baris semasa adalah positif maka tidak akan ada negatif dalam matriks di bawah atau selepas itu; Jalankan carian binari hanya sehingga indeks integer negatif terakhir dalam baris di atas; Kod pemacu", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int getLastNegativeIndex ( int array [ ] , int start , int end ) { if ( start == end ) { return start ; } int mid = start + ( end - start ) / 2 ; if ( array [ mid ] < 0 ) { if ( mid + 1 < array . length && array [ mid + 1 ] >= 0 ) { return mid ; } return getLastNegativeIndex ( array , mid + 1 , end ) ; } else { return getLastNegativeIndex ( array , start , mid - 1 ) ; } } static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; int nextEnd = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( M [ i ] [ 0 ] >= 0 ) { break ; } nextEnd = getLastNegativeIndex ( M [ i ] , 0 , nextEnd ) ; count += nextEnd + 1 ; } return count ; } public static void main ( String [ ] args ) { int M [ ] [ ] = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; int r = M . length ; int c = M [ 0 ] . length ; System . out . println ( countNegative ( M , r , c ) ) ; } }"}
{"text": "Cari pasangan tertentu dalam Matrix | Kaedah naif untuk mencari nilai maksimum MAT1 [d] [e] - ma [a] [b] seperti d> a dan e> b; Fungsi ini mengembalikan nilai maksimum a (d, e) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua d> a dan e> b. ; Kedai nilai maksimum; Pertimbangkan semua pasangan yang mungkin mat [a] [b] dan mat1 [d] [e]; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static int findMaxValue ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; } public static void main ( String [ ] args ) { int N = 5 ; int mat [ ] [ ] = { { 1 , 2 , - 1 , - 4 , - 20 } , { - 8 , - 3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { - 4 , - 1 , 1 , 7 , - 6 } , { 0 , - 4 , 10 , - 5 , 1 } } ; System . out . print ( \" Maximum ▁ Value ▁ is ▁ \" + findMaxValue ( N , mat ) ) ; } }"}
{"text": "Cari pasangan tertentu dalam Matrix | Kaedah yang cekap untuk mencari nilai maksimum MAT1 [d] - ma [a] [b] sedemikian rupa sehingga c> a dan d> b; Fungsi ini mengembalikan nilai maksimum a (c, d) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua c> a dan d> b. ; Kedai nilai maksimum; maxarr [i] [j] menyimpan max unsur -unsur dalam matriks dari (i, j) hingga (n - 1, n - 1); Elemen terakhir Maxarr akan menjadi sama seperti matriks input; Preprocess Last Row Inisialisasi Max; preprocess lajur terakhir memulakan max; PREPROCESS ROST OF MATRIX DARI BAWAH; Kemas kini MaxValue; Tetapkan Maxarr (i, j); Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static int findMaxValue ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; int maxArr [ ] [ ] = new int [ N ] [ N ] ; maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; } public static void main ( String [ ] args ) { int N = 5 ; int mat [ ] [ ] = { { 1 , 2 , - 1 , - 4 , - 20 } , { - 8 , - 3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { - 4 , - 1 , 1 , 7 , - 6 } , { 0 , - 4 , 10 , - 5 , 1 } } ; System . out . print ( \" Maximum ▁ Value ▁ is ▁ \" + findMaxValue ( N , mat ) ) ; } }"}
{"text": "Cetak semua elemen dalam susunan yang disusun dari baris dan lajur yang bijak matriks disusun | Program Java untuk mencetak semua elemen dalam susunan yang disusun dari matriks baris dan lajur yang disusun bijak; Fungsi utiliti untuk Youngify meja muda. Ini berbeza dengan Standard Youngify. Ia mengandaikan bahawa nilai pada MAT [0] [0] adalah tak terhingga. ; Cari nilai -nilai di bawah dan kanan tikar [i] [j]; Jika tikar [i] [j] adalah elemen sudut kanan, kembali; Gerakkan lebih kecil daripada dua nilai (downval dan rightval) ke tikar [i] [j] dan berulang untuk nilai yang lebih kecil; Fungsi utiliti untuk mengekstrak elemen minimum dari Tableau muda; Fungsi ini menggunakan ExtractMin () untuk mencetak elemen dalam urutan yang disusun; Kod pemacu", "code": "class GFG { static final int INF = Integer . MAX_VALUE ; static final int N = 4 ; static void youngify ( int mat [ ] [ ] , int i , int j ) { int downVal = ( i + 1 < N ) ? mat [ i + 1 ] [ j ] : INF ; int rightVal = ( j + 1 < N ) ? mat [ i ] [ j + 1 ] : INF ; if ( downVal == INF && rightVal == INF ) { return ; } if ( downVal < rightVal ) { mat [ i ] [ j ] = downVal ; mat [ i + 1 ] [ j ] = INF ; youngify ( mat , i + 1 , j ) ; } else { mat [ i ] [ j ] = rightVal ; mat [ i ] [ j + 1 ] = INF ; youngify ( mat , i , j + 1 ) ; } } static int extractMin ( int mat [ ] [ ] ) { int ret = mat [ 0 ] [ 0 ] ; mat [ 0 ] [ 0 ] = INF ; youngify ( mat , 0 , 0 ) ; return ret ; } static void printSorted ( int mat [ ] [ ] ) { System . out . println ( \" Elements ▁ of ▁ matrix ▁ in ▁ sorted ▁ order ▁ n \" ) ; for ( int i = 0 ; i < N * N ; i ++ ) { System . out . print ( extractMin ( mat ) + \" ▁ \" ) ; } } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; printSorted ( mat ) ; } }"}
{"text": "Memandangkan matriks n x n persegi, cari jumlah semua sub | Program Java yang mudah untuk mencari jumlah semua subsquares saiz k x k; Saiz matriks yang diberikan; Fungsi mudah untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; Nombor baris sel pertama dalam sub -persegi semasa saiz k x k; Lajur sel pertama dalam sub -persegi semasa saiz k x k; Hitung dan cetak jumlah sub -persegi semasa; Pemisah garis untuk sub -dataran bermula dengan baris seterusnya; Program pemacu untuk menguji fungsi di atas", "code": "class GFG { static final int n = 5 ; static void printSumSimple ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; System . out . print ( sum + \" ▁ \" ) ; } System . out . println ( ) ; } } public static void main ( String arg [ ] ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } } ; int k = 3 ; printSumSimple ( mat , k ) ; } }"}
{"text": "Memandangkan matriks n x n persegi, cari jumlah semua sub | Program Java yang cekap untuk mencari jumlah semua subsquares saiz k x k; Saiz matriks yang diberikan; A o (n ^ 2) berfungsi untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi yang diberikan saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; 1: Preprocessing untuk menyimpan jumlah semua jalur saiz k x 1; Pergi lajur mengikut lajur; Hitung jumlah pertama K x 1 segi empat tepat dalam lajur ini; Hitung jumlah segi empat tepat; 2: Kirakan jumlah sub - dataran menggunakan stripsum [] []; Hitung dan cetak jumlah Subsquare Pertama dalam baris ini; Kirakan jumlah kuadrat yang tinggal dalam baris semasa dengan mengeluarkan jalur paling kiri sub -persegi sebelumnya dan menambah jalur baru; Program pemacu untuk menguji fungsi di atas", "code": "import java . io . * ; class GFG { static int n = 5 ; static void printSumTricky ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; int stripSum [ ] [ ] = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; System . out . print ( sum + \" ▁ \" ) ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; System . out . print ( sum + \" ▁ \" ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumTricky ( mat , k ) ; } }"}
{"text": "Program untuk mencari transpose matriks | Program Java untuk mencari transpose matriks; Fungsi ini menyimpan transpose a [] [] dalam b [] []; Kod pemacu", "code": "class GFG { static final int M = 3 ; static final int N = 4 ; static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } } ; int B [ ] [ ] = new int [ N ] [ M ] , i , j ; transpose ( A , B ) ; System . out . print ( \"Result matrix is NEW_LINE\"); for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) System . out . print ( B [ i ] [ j ] + \" ▁ \" ) ; System . out . print ( \"NEW_LINE\"); } } }"}
{"text": "Program untuk mencari transpose matriks | Program Java untuk mencari transpose matriks; Mencari transpose dari [] [] di tempat; Kod pemacu", "code": "class GFG { static final int N = 4 ; static void transpose ( int A [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; transpose ( A ) ; System . out . print ( \"Modified matrix is NEW_LINE\"); for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) System . out . print ( A [ i ] [ j ] + \" ▁ \" ) ; System . out . print ( \"NEW_LINE\"); } } }"}
{"text": "Bilangan Jalan dengan Koin Kata Tepat | Program Java rekursif naif untuk mengira laluan dengan duit syiling 'k' yang tepat; Fungsi rekursif untuk mengira laluan dengan jumlah k dari (0, 0) hingga (m, n); Kes asas; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Pembungkus ke atas PathCountrec (); Kod pemacu", "code": "class GFG { static final int R = 3 ; static final int C = 3 ; static int pathCountRec ( int mat [ ] [ ] , int m , int n , int k ) { if ( m < 0 n < 0 ) { return 0 ; } if ( m == 0 && n == 0 && ( k == mat [ m ] [ n ] ) ) { return 1 ; } return pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; } static int pathCount ( int mat [ ] [ ] , int k ) { return pathCountRec ( mat , R - 1 , C - 1 , k ) ; } public static void main ( String [ ] args ) { int k = 12 ; int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 6 , 5 } , { 3 , 2 , 1 } } ; System . out . println ( pathCount ( mat , k ) ) ; } }"}
{"text": "Bilangan Jalan dengan Koin Kata Tepat | Program Java berasaskan pengaturcaraan yang dinamik untuk mengira laluan dengan duit syiling 'k' yang tepat; Kes asas; Jika subproblem ini sudah diselesaikan; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Fungsi ini terutamanya memulakan dp [] [] [] dan memanggil PathCountDPrecdp (); Program pemacu untuk menguji fungsi di atas", "code": "class GFG { static final int R = 3 ; static final int C = 3 ; static final int MAX_K = 100 ; static int [ ] [ ] [ ] dp = new int [ R ] [ C ] [ MAX_K ] ; static int pathCountDPRecDP ( int [ ] [ ] mat , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ? 1 : 0 ) ; if ( dp [ m ] [ n ] [ k ] != - 1 ) return dp [ m ] [ n ] [ k ] ; dp [ m ] [ n ] [ k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; } static int pathCountDP ( int [ ] [ ] mat , int k ) { for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) for ( int l = 0 ; l < MAX_K ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; } public static void main ( String [ ] args ) { int k = 12 ; int [ ] [ ] mat = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 } , new int [ ] { 4 , 6 , 5 } , new int [ ] { 3 , 2 , 1 } } ; System . out . println ( pathCountDP ( mat , k ) ) ; } }"}
{"text": "Susun Matriks yang Diberikan | Pelaksanaan Java untuk menyusun matriks yang diberikan; berfungsi untuk menyusun matriks yang diberikan; matriks sementara saiz n ^ 2; Salin unsur -unsur matriks satu demi satu ke temp []; Susun temp []; Salin unsur -unsur temp [] satu demi satu dalam tikar [] []; berfungsi untuk mencetak matriks yang diberikan; Program Pemandu untuk diuji di atas", "code": "import java . io . * ; import java . util . * ; class GFG { static int SIZE = 10 ; static void sortMat ( int mat [ ] [ ] , int n ) { int temp [ ] = new int [ n * n ] ; int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) temp [ k ++ ] = mat [ i ] [ j ] ; Arrays . sort ( temp ) ; k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) mat [ i ] [ j ] = temp [ k ++ ] ; } static void printMat ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + \" ▁ \" ) ; System . out . println ( ) ; } } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 5 , 4 , 7 } , { 1 , 3 , 8 } , { 2 , 9 , 6 } } ; int n = 3 ; System . out . println ( \" Original ▁ Matrix : \" ) ; printMat ( mat , n ) ; sortMat ( mat , n ) ; System . out . println ( \" Matrix ▁ After ▁ Sorting : \" ) ; printMat ( mat , n ) ; } }"}
{"text": "Pemilihan jenis | Program Java untuk pelaksanaan pilihan pemilihan; Susun fungsi; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Tukar elemen minimum yang dijumpai dengan elemen pertama; Mencetak array; Kod pemacu untuk diuji di atas", "code": "class SelectionSort { void sort ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int min_idx = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; int temp = arr [ min_idx ] ; arr [ min_idx ] = arr [ i ] ; arr [ i ] = temp ; } } void printArray ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + \" ▁ \" ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { SelectionSort ob = new SelectionSort ( ) ; int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; ob . sort ( arr ) ; System . out . println ( \" Sorted ▁ array \" ) ; ob . printArray ( arr ) ; } }"}
{"text": "Bubble sort | Pelaksanaan Java yang dioptimumkan dari Bubble Sort; Versi bubble yang dioptimumkan; swap arr [j] dan arr [j + 1]; Jika tidak ada dua elemen yang ditukar dengan gelung dalaman, kemudian pecah; Berfungsi untuk mencetak array; Program Pemandu", "code": "import java . io . * ; class GFG { static void bubbleSort ( int arr [ ] , int n ) { int i , j , temp ; boolean swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; swapped = true ; } } if ( swapped == false ) break ; } } static void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; int n = arr . length ; bubbleSort ( arr , n ) ; System . out . println ( \" Sorted ▁ array : ▁ \" ) ; printArray ( arr , n ) ; } }"}
{"text": "Cari K Elemen yang paling dekat dengan nilai yang diberikan | Program Java untuk mencari unsur -unsur terdekat dengan nilai tertentu; Berfungsi untuk mencari titik silang (titik sebelum unsur -unsur lebih kecil daripada atau sama dengan x dan selepas itu lebih besar daripada x); Kes asas X lebih besar daripada semua; X lebih kecil daripada semua; Cari titik tengah; Jika x sama dengan elemen tengah, maka kembali pertengahan; Jika x lebih besar daripada arr [pertengahan], maka sama ada arr [pertengahan + 1] adalah siling x atau siling terletak pada arr [pertengahan + 1. . tinggi]; Fungsi ini mencetak elemen yang paling dekat dengan x dalam arr []. n ialah bilangan elemen dalam arr []; Cari titik crossover; Indeks yang betul untuk mencari; Untuk menjejaki kiraan elemen yang telah dicetak; Jika x hadir dalam arr [], maka mengurangkan asumsi indeks kiri: semua elemen dalam arr [] adalah berbeza; Bandingkan unsur -unsur di kiri dan kanan titik crossover untuk mencari unsur -unsur yang paling dekat; Jika tidak ada lagi elemen di sebelah kanan, maka cetak elemen kiri; Sekiranya tidak ada lagi elemen di sebelah kiri, maka cetak elemen kanan; Program pemacu untuk menyemak fungsi di atas", "code": "class KClosest { int findCrossOver ( int arr [ ] , int low , int high , int x ) { if ( arr [ high ] <= x ) return high ; if ( arr [ low ] > x ) return low ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] <= x && arr [ mid + 1 ] > x ) return mid ; if ( arr [ mid ] < x ) return findCrossOver ( arr , mid + 1 , high , x ) ; return findCrossOver ( arr , low , mid - 1 , x ) ; } void printKclosest ( int arr [ ] , int x , int k , int n ) { int l = findCrossOver ( arr , 0 , n - 1 , x ) ; int r = l + 1 ; int count = 0 ; if ( arr [ l ] == x ) l -- ; while ( l >= 0 && r < n && count < k ) { if ( x - arr [ l ] < arr [ r ] - x ) System . out . print ( arr [ l -- ] + \" ▁ \" ) ; else System . out . print ( arr [ r ++ ] + \" ▁ \" ) ; count ++ ; } while ( count < k && l >= 0 ) { System . out . print ( arr [ l -- ] + \" ▁ \" ) ; count ++ ; } while ( count < k && r < n ) { System . out . print ( arr [ r ++ ] + \" ▁ \" ) ; count ++ ; } } public static void main ( String args [ ] ) { KClosest ob = new KClosest ( ) ; int arr [ ] = { 12 , 16 , 22 , 30 , 35 , 39 , 42 , 45 , 48 , 50 , 53 , 55 , 56 } ; int n = arr . length ; int x = 35 , k = 4 ; ob . printKclosest ( arr , x , 4 , n ) ; } }"}
{"text": "SENARAI SENSI UNTUK SENDIRI SISTY LINKED | Program Java untuk menyusun senarai pautan menggunakan jenis penyisipan; Fungsi utiliti untuk memasukkan nod pada permulaan senarai yang dipautkan; memperuntukkan nod; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Fungsi untuk menyusun senarai yang berkaitan dengan menggunakan jenis penyisipan; Memulakan senarai yang disusun; Melintasi senarai yang dipautkan dan masukkan setiap nod untuk disusun; Simpan seterusnya untuk lelaran seterusnya; Masukkan arus dalam senarai yang disusun; Mengemas kini semasa; Kemas kini head_ref untuk menunjuk ke senarai yang disusun; * Fungsi untuk memasukkan new_node dalam senarai. Ambil perhatian bahawa * fungsi ini menjangkakan penunjuk ke head_ref sebagai * ini boleh mengubah suai kepala senarai berkaitan input * (serupa dengan push ()); Kes khas untuk hujung kepala; Cari nod sebelum titik penyisipan; Berfungsi untuk mencetak senarai yang dipautkan; Program pemacu untuk menguji fungsi di atas", "code": "public class LinkedlistIS { node head ; node sorted ; class node { int val ; node next ; public node ( int val ) { this . val = val ; } } void push ( int val ) { node newnode = new node ( val ) ; newnode . next = head ; head = newnode ; } void insertionSort ( node headref ) { sorted = null ; node current = headref ; while ( current != null ) { node next = current . next ; sortedInsert ( current ) ; current = next ; } head = sorted ; } void sortedInsert ( node newnode ) { if ( sorted == null sorted . val >= newnode . val ) { newnode . next = sorted ; sorted = newnode ; } else { node current = sorted ; while ( current . next != null && current . next . val < newnode . val ) { current = current . next ; } newnode . next = current . next ; current . next = newnode ; } } void printlist ( node head ) { while ( head != null ) { System . out . print ( head . val + \" ▁ \" ) ; head = head . next ; } } public static void main ( String [ ] args ) { LinkedlistIS list = new LinkedlistIS ( ) ; list . push ( 5 ) ; list . push ( 20 ) ; list . push ( 4 ) ; list . push ( 3 ) ; list . push ( 30 ) ; System . out . println ( \" Linked ▁ List ▁ before ▁ Sorting . . \" ) ; list . printlist ( list . head ) ; list . insertionSort ( list . head ) ; System . out . println ( \" LinkedList After sorting \"); list . printlist ( list . head ) ; } }"}
{"text": "Perubahan duit syiling | DP | Pelaksanaan Java Pengaturcaraan Dinamik Masalah Perubahan Koin; Jadual [i] akan menyimpan bilangan penyelesaian untuk nilai i. Kami memerlukan baris n + 1 kerana jadual dibina dengan cara bawah menggunakan kes asas (n = 0); Kes asas (jika diberi nilai adalah 0); Pilih semua duit syiling satu demi satu dan kemas kini nilai jadual [] selepas indeks lebih besar daripada atau sama dengan nilai duit syiling yang dipilih", "code": "public static int count ( int S [ ] , int m , int n ) { int table [ ] = new int [ n + 1 ] ; table [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }"}
{"text": "Pendaraban rantai matriks | DP | Program Java menggunakan memoisasi; Fungsi untuk pendaraban rantai matriks; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static int [ ] [ ] dp = new int [ 100 ] [ 100 ] ; static int matrixChainMemoised ( int [ ] p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } static int MatrixChainOrder ( int [ ] p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; System . out . println ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" + MatrixChainOrder ( arr , n ) ) ; } }"}
{"text": "Pendaraban rantai matriks | DP | Pelaksanaan Java Pengaturcaraan Dinamik Multiplikasi Rantaian Matriks. Lihat buku Cormen untuk butiran algoritma berikut; Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Untuk kesederhanaan program, satu baris tambahan dan satu lajur tambahan diperuntukkan dalam M [] []. 0 bar dan lajur 0 M [] [] tidak digunakan; Kos adalah sifar apabila mendarabkan satu matriks. ; L adalah panjang rantai. ; Q = Kos / skalar pendaraban; Kod pemacu", "code": "class MatrixChainMultiplication { static int MatrixChainOrder ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; int size = arr . length ; System . out . println ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" + MatrixChainOrder ( arr , size ) ) ; } }"}
{"text": "Memotong batang | DP | Penyelesaian rekursif naif untuk masalah pemotongan rod; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Recursif memotong batang dalam kepingan yang berbeza dan membandingkan konfigurasi yang berbeza; Program pemacu untuk menguji fungsi di atas", "code": "class RodCutting { static int cutRod ( int price [ ] , int n ) { if ( n <= 0 ) return 0 ; int max_val = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) max_val = Math . max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) ; return max_val ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" + cutRod ( arr , size ) ) ; } }"}
{"text": "Memotong batang | DP | Penyelesaian pengaturcaraan dinamik untuk masalah pemotongan rod; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Program pemacu untuk menguji fungsi di atas", "code": "class RodCutting { static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" + cutRod ( arr , size ) ) ; } }"}
{"text": "Multiply dua bilangan bulat tanpa menggunakan pendaraban, pembahagian dan pengendali bitwise, dan tiada gelung |  ; berfungsi untuk membiak dua nombor x dan y; 0 didarab dengan apa -apa memberi 0; Tambah x satu demi satu; kes di mana y adalah negatif; Kod pemacu", "code": "class GFG { static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; } public static void main ( String [ ] args ) { System . out . print ( \"NEW_LINE\" + multiply(5, -11)); } }"}
{"text": "Sieve of Eratosthenes | Program Java untuk mencetak semua prima yang lebih kecil daripada atau sama dengan N menggunakan penapis eratosthenes; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cetak semua nombor utama; Kod pemacu", "code": "class SieveOfEratosthenes { void sieveOfEratosthenes ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) System . out . print ( i + \" ▁ \" ) ; } } public static void main ( String args [ ] ) { int n = 30 ; System . out . print ( \" Following ▁ are ▁ the ▁ prime ▁ numbers ▁ \" ) ; System . out . println ( \" smaller ▁ than ▁ or ▁ equal ▁ to ▁ \" + n ) ; SieveOfEratosthenes g = new SieveOfEratosthenes ( ) ; g . sieveOfEratosthenes ( n ) ; } }"}
{"text": "Segitiga Pascal | Kod Java untuk Segitiga Pascal; BinomialCoeff; Berfungsi untuk mencetak garisan N pertama dari segitiga Pascal; Berulang melalui setiap baris dan cetak penyertaan di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Kod pemacu", "code": "import java . io . * ; class GFG { static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static void printPascal ( int n ) { for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) System . out . print ( binomialCoeff ( line , i ) + \" ▁ \" ) ; System . out . println ( ) ; } } public static void main ( String args [ ] ) { int n = 7 ; printPascal ( n ) ; } }"}
{"text": "Segitiga Pascal | Program Java untuk Segitiga Pascal; A o (n ^ 2) masa dan o (n ^ 2) kaedah ruang tambahan untuk segitiga Pascal; Array tambahan untuk menyimpan nilai segitiga pascal yang dihasilkan; Melangkah melalui setiap baris dan cetak integer (s) di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Nilai pertama dan terakhir dalam setiap baris adalah 1; Nilai -nilai lain adalah jumlah nilai di atas dan kiri di atas; Kod pemacu", "code": "import java . io . * ; class GFG { public static void printPascal ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; System . out . print ( arr [ line ] [ i ] ) ; } System . out . println ( \" \" ) ; } } } public static void main ( String [ ] args ) { int n = 5 ; printPascal ( n ) ; }"}
{"text": "Segitiga Pascal | Program Java untuk Pascal 'S' u u (n ^ 2) ~ masa u dan u (1) ~ uce ~ »» kaedah »Segitiga Pascal; digunakan untuk mewakili C (garis, i); Nilai pertama dalam baris sentiasa 1; Kod pemacu", "code": "import java . io . * ; class GFG { public static void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( C + \" ▁ \" ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int n = 5 ; printPascal ( n ) ; } }"}
{"text": "Tambah dua nombor tanpa menggunakan pengendali aritmetik | Program Java untuk menambah dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Bawa sekarang mengandungi bit set biasa x dan y; Jumlah bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Membawa beralih oleh satu supaya menambahnya kepada x memberikan jumlah yang diperlukan; Kod pemacu", "code": "import java . io . * ; class GFG { static int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } public static void main ( String arg [ ] ) { System . out . println ( Add ( 15 , 32 ) ) ; } }"}
{"text": "Tambah dua nombor tanpa menggunakan pengendali aritmetik |", "code": "static int Add ( int x , int y ) { if ( y == 0 ) return x ; else return Add ( x ^ y , ( x & y ) << 1 ) ; }"}
{"text": "Mengira Bahagian Modulus dengan Kuasa | Kod Java untuk mengira bahagian modulus dengan kuasa - 2 - nombor; Fungsi ini akan kembali n % d. D mestilah salah satu: 1, 2, 4, 8, 16, 32 ,; Kod pemacu; D mesti menjadi kuasa 2", "code": "class GFG { static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 6 ; int d = 4 ; System . out . println ( n + \" ▁ moduo ▁ \" + d + \" ▁ is ▁ \" + getModulo ( n , d ) ) ; } }"}
{"text": "Count set bit dalam integer | Program Java untuk mengira set bit dalam integer; Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Program Pemandu", "code": "import java . io . * ; class countSetBits { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } public static void main ( String args [ ] ) { int i = 9 ; System . out . println ( countSetBits ( i ) ) ; } }"}
{"text": "Count set bit dalam integer | Pelaksanaan Java untuk pendekatan rekursif untuk mencari bilangan bit yang ditetapkan menggunakan algoritma Brian Kernighan; fungsi rekursif untuk mengira set bit; Kes asas; Fungsi pemacu; Dapatkan nilai dari pengguna; fungsi panggilan", "code": "import java . io . * ; class GFG { public static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . println ( countSetBits ( n ) ) ; } }"}
{"text": "Count set bit dalam integer | Pelaksanaan Java pendekatan; Jadual carian; Berfungsi untuk memulakan jadual carian; Pada mulanya menjana jadual algoritma; Berfungsi untuk mengembalikan kiraan bit set dalam n; Kod pemacu; Memulakan jadual carian", "code": "class GFG { static int [ ] BitsSetTable256 = new int [ 256 ] ; public static void initialize ( ) { BitsSetTable256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i / 2 ] ; } } public static int countSetBits ( int n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; } public static void main ( String [ ] args ) { initialize ( ) ; int n = 9 ; System . out . print ( countSetBits ( n ) ) ; } }"}
{"text": "Count set bit dalam integer | Program Java untuk menunjukkan __builtin_popcount (); Kod pemacu", "code": "import java . io . * ; class GFG { public static void main ( String [ ] args ) { System . out . println ( Integer . bitCount ( 4 ) ) ; System . out . println ( Integer . bitCount ( 15 ) ) ; } }"}
{"text": "Count set bit dalam integer | Program Java untuk mengira set bit dengan pra -menyimpan bit set bit dalam gumpalan. ; Recursif dapat menggigit nombor tertentu dan memetakannya dalam array; Cari nibble terakhir; Gunakan nilai pra -disimpan untuk mencari kiraan dalam nibble terakhir ditambah dengan rekursif menambah baki yang tersisa. ; Kod pemacu", "code": "class GFG { static int [ ] num_to_bits = new int [ ] { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ; static int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; } public static void main ( String [ ] args ) { int num = 31 ; System . out . println ( countSetBitsRec ( num ) ) ; } }"}
{"text": "Count set bit dalam integer |  ; Semak setiap bit dalam nombor ditetapkan atau tidak dan kembalikan jumlah kiraan bit yang ditetapkan. ; (1 << i) = pow (2, i); Kod pemacu", "code": "public class GFG { static int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int N = 15 ; System . out . println ( countSetBits ( N ) ) ; } }"}
{"text": "Program untuk mencari pariti | Program Java untuk mencari pariti integer; Berfungsi untuk mendapatkan pariti nombor n. Ia mengembalikan 1 jika n mempunyai pariti ganjil, dan pulangan 0 jika n mempunyai pariti; Program Pemandu untuk Menguji GetParity ()", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . BigInteger ; class GFG { static boolean getParity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( \" Parity ▁ of ▁ no ▁ \" + n + \" ▁ = ▁ \" + ( getParity ( n ) ? \" odd \" : \" even \" ) ) ; } }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Program Java untuk mencari sama ada tidak ada kuasa dua; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "class GFG { static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( int ) ( Math . ceil ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) == ( int ) ( Math . floor ( ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) ) ; } public static void main ( String [ ] args ) { if ( isPowerOfTwo ( 31 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; if ( isPowerOfTwo ( 64 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Program Java untuk mencari sama ada tidak ada kuasa dua; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Program Pemandu", "code": "import java . io . * ; class GFG { static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; } public static void main ( String args [ ] ) { if ( isPowerOfTwo ( 31 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; if ( isPowerOfTwo ( 64 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Program Java untuk pendekatan di atas; Fungsi yang memeriksa sama ada nombor adalah kuasa 2; Kes asas '1' adalah satu -satunya nombor ganjil yang merupakan kuasa 2 (2 ^ 0); Semua nombor ganjil yang lain bukan kuasa 2; panggilan fungsi rekursif; Kod pemacu; Benar; Palsu", "code": "import java . util . * ; class GFG { static boolean powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } public static void main ( String [ ] args ) { int n = 64 ; int m = 12 ; if ( powerOf2 ( n ) == true ) System . out . print ( \" True \" + \"NEW_LINE\"); else System . out . print ( \" False \" + \"NEW_LINE\"); if ( powerOf2 ( m ) == true ) System . out . print ( \" True \" + \"NEW_LINE\"); else System . out . print ( \" False \" + \"NEW_LINE\"); } }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Program Java untuk memeriksa kuasa untuk 2; Kaedah untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Kaedah Pemandu", "code": "class Test { static boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; } public static void main ( String [ ] args ) { System . out . println ( isPowerOfTwo ( 31 ) ? \" Yes \" : \" No \" ) ; System . out . println ( isPowerOfTwo ( 64 ) ? \" Yes \" : \" No \" ) ; } }"}
{"text": "Cari nombor pengulangan maksimum dalam O (n) masa dan O (1) ruang tambahan | Program Java untuk mencari nombor pengulangan maksimum; Mengembalikan elemen berulang maksimum dalam ARR [0. n - 1]. Unsur -unsur array berada dalam jarak dari 0 hingga k - 1; Berulang walaupun array input, untuk setiap elemen arr [i], kenaikan arr [arr [i] % k] oleh k; Cari indeks elemen berulang maksimum; Indeks pulangan elemen maksimum; Fungsi pemacu untuk memeriksa fungsi di atas", "code": "import java . io . * ; class MaxRepeating { static int maxRepeating ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ ( arr [ i ] % k ) ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 } ; int n = arr . length ; int k = 8 ; System . out . println ( \" Maximum ▁ repeating ▁ element ▁ is : ▁ \" + maxRepeating ( arr , n , k ) ) ; } }"}
{"text": "Pertanyaan pelbagai pada array yang setiap elemen adalah xor nilai indeks dan elemen sebelumnya | Program Java untuk menyelesaikan pertanyaan pelbagai pada array yang setiap elemennya adalah xor nilai indeks dan elemen sebelumnya. ; Fungsi pulangan nilai formula yang diperolehi. ; Mencari nilai XOR julat [y ... x]; Fungsi untuk menyelesaikan pertanyaan untuk l dan r. ; jika l atau r ialah 0 .; Mencari X boleh dibahagikan dengan 2 atau tidak. ; Program yang didorong", "code": "import java . io . * ; class GFG { static int fun ( int x ) { int y = ( x / 4 ) * 4 ; int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; } static int query ( int x ) { if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ; return ( ( x %= 2 ) != 0 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; } static void allQueries ( int q , int l [ ] , int r [ ] ) { for ( int i = 0 ; i < q ; i ++ ) System . out . println ( ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) ) ; } public static void main ( String [ ] args ) { int q = 3 ; int [ ] l = { 2 , 2 , 5 } ; int [ ] r = { 4 , 8 , 9 } ; allQueries ( q , l , r ) ; } }"}
{"text": "Pertanyaan pada Xor pembahagi ganjil yang paling hebat dari julat | Pertanyaan Kod Java pada XOR pembahagi ganjil yang paling hebat; Precompute awalan xor pembahagi ganjil yang paling besar; Mencari pembahagi ganjil yang paling besar; Mencari awalan xor; Kembali xor julat; Program yang didorong", "code": "import java . io . * ; class GFG { static void prefixXOR ( int arr [ ] , int preXOR [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( arr [ i ] % 2 != 1 ) arr [ i ] /= 2 ; preXOR [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] ; } static int query ( int preXOR [ ] , int l , int r ) { if ( l == 0 ) return preXOR [ r ] ; else return preXOR [ r ] ^ preXOR [ l - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 5 } ; int n = arr . length ; int preXOR [ ] = new int [ n ] ; prefixXOR ( arr , preXOR , n ) ; System . out . println ( query ( preXOR , 0 , 2 ) ) ; System . out . println ( query ( preXOR , 1 , 2 ) ) ; } }"}
{"text": "Swap bersebelahan minimum diperlukan untuk menyusun array binari | Kod Java untuk mencari bilangan swap minimum untuk menyusun array binari; Fungsi untuk mencari swap minimum untuk menyusun pelbagai 0 s dan 1 s. ; Array untuk menyimpan kiraan sifar; Kira bilangan sifar di sebelah kanan setiap satu. ; Kira jumlah swap dengan menambahkan bilangan sifar di sebelah kanan setiap satu. ; Kod pemacu", "code": "class gfg { static int findMinSwaps ( int arr [ ] , int n ) { int noOfZeroes [ ] = new int [ n ] ; int i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; } public static void main ( String args [ ] ) { int ar [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; System . out . println ( findMinSwaps ( ar , ar . length ) ) ; } }"}
{"text": "Swap bersebelahan minimum diperlukan untuk menyusun array binari |  ; Kod pemacu", "code": "import java . io . * ; class GFG { public static int minswaps ( int arr [ ] , int n ) { int count = 0 ; int num_unplaced_zeros = 0 ; for ( int index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; } public static void main ( String [ ] args ) { int [ ] arr = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; System . out . println ( minswaps ( arr , 9 ) ) ; } }"}
{"text": "Program untuk memeriksa sama ada array disusun atau tidak (berulang dan rekursif) | Pendekatan rekursif untuk memeriksa sama ada array disusun atau tidak; Fungsi yang pulih benar jika array disusun dalam perintah yang tidak menurun. ; Array mempunyai satu atau tiada elemen; Pasangan yang tidak disusun dijumpai; Tiada pasangan yang tidak disusun dijumpai; kod pemacu", "code": "class GFG { static boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = arr . length ; if ( arraySortedOrNot ( arr , n ) ) System . out . print ( \"YesNEW_LINE\"); else System . out . print ( \"NoNEW_LINE\"); } }"}
{"text": "Cari dua nombor dengan kejadian ganjil dalam array yang tidak disusun | Program Java untuk mencari dua elemen yang ganjil; Mencetak dua nombor yang berlaku bilangan kali ganjil. Fungsi ini mengandaikan bahawa saiz array sekurang -kurangnya 2 dan terdapat dua nombor yang berlaku pada masa yang ganjil. ; Akan memegang Xor dua elemen yang ganjil; Hanya akan mempunyai bit satu set XOR2; Dapatkan XOR semua elemen di arr []. XOR pada dasarnya akan menjadi XOR dari dua elemen yang ganjil; Dapatkan satu set bit di XOR2. Kami mendapat set paling kanan dalam baris berikut kerana mudah diperoleh; Sekarang bahagikan unsur -unsur dalam dua set: 1) unsur -unsur yang mempunyai bit yang sepadan sebagai 1.2) unsur -unsur yang mempunyai bit yang sepadan sebagai 0 .; XOR set pertama akhirnya akan memegang satu nombor X yang ganjil; XOR set kedua akhirnya akan memegang nombor yang lain yang berlaku y; fungsi utama", "code": "import java . util . * ; class Main { static void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( \" The ▁ two ▁ ODD ▁ elements ▁ are ▁ \" + x + \" ▁ & ▁ \" + y ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = arr . length ; printTwoOdd ( arr , arr_size ) ; } }"}
{"text": "Cari pasangan dengan perbezaan yang diberikan | Program Java untuk mencari pasangan dengan perbezaan yang diberikan; Fungsi ini mengandaikan bahawa array disusun; Memulakan kedudukan dua elemen; Cari pasangan; Program pemacu untuk menguji fungsi di atas", "code": "import java . io . * ; class PairDifference { static boolean findPair ( int arr [ ] , int n ) { int size = arr . length ; int i = 0 , j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { System . out . print ( \" Pair ▁ Found : ▁ \" + \" ( ▁ \" + arr [ i ] + \" , ▁ \" + arr [ j ] + \" ▁ ) \" ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } System . out . print ( \" No ▁ such ▁ pair \" ) ; return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int n = 60 ; findPair ( arr , n ) ; } }"}
{"text": "Cari K Unsur Maksimum Array dalam Perintah Asal | Program Java untuk mencari unsur maksimum array dalam urutan asal; Berfungsi untuk mencetak elemen maksimum; Array untuk menyimpan salinan array asal; Menyusun array dalam urutan menurun; Melintasi array asal dan mencetak semua unsur -unsur yang berada dalam k -siswa yang disusun pertama. goo. GL / UJ5RCD Sila rujuk HTTPS: Untuk butiran array. BinarySearch (); Kod pemacu", "code": "import java . util . Arrays ; import java . util . Collections ; public class GfG { public static void printMax ( int arr [ ] , int k , int n ) { Integer [ ] brr = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; Arrays . sort ( brr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < n ; ++ i ) if ( Arrays . binarySearch ( brr , arr [ i ] , Collections . reverseOrder ( ) ) >= 0 && Arrays . binarySearch ( brr , arr [ i ] , Collections . reverseOrder ( ) ) < k ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 50 , 8 , 45 , 12 , 25 , 40 , 84 } ; int n = arr . length ; int k = 3 ; printMax ( arr , k , n ) ; } }"}
{"text": "Cetak n elemen terkecil dari array yang diberikan dalam urutan asal mereka | Java untuk mencetak nombor N terkecil dalam urutan; Berfungsi untuk mencetak nombor N terkecil; Buat salinan Array; Susun Arahan Salin; Bagi setiap arr [i] mendapati sama ada ia adalah sebahagian daripada N - terkecil dengan carian binari; Kod pemacu", "code": "import java . util . * ; class GFG { static void printSmall ( int arr [ ] , int asize , int n ) { int [ ] copy_arr = Arrays . copyOf ( arr , asize ) ; Arrays . sort ( copy_arr ) ; for ( int i = 0 ; i < asize ; ++ i ) { if ( Arrays . binarySearch ( copy_arr , 0 , n , arr [ i ] ) > - 1 ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = arr . length ; int n = 5 ; printSmall ( arr , asize , n ) ; } }"}
{"text": "Semak sama ada perkembangan aritmetik boleh dibentuk dari array yang diberikan | Program Java untuk memeriksa sama ada array yang diberikan boleh membentuk perkembangan aritmetik; Pulangan benar jika permutasi ARR [0 .. n - 1] boleh membentuk perkembangan aritmetik; Susun array; Selepas menyusun, perbezaan antara unsur -unsur berturut -turut mestilah sama. ; kod pemacu", "code": "import java . util . Arrays ; class GFG { static boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = arr . length ; if ( checkIsAP ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Kira cara memilih pasangan dengan perbezaan maksimum | Kod Java untuk mencari tidak. cara memilih pasangan dengan perbezaan maksimum; Untuk mencari minimum dan maksimum array; untuk mencari kiraan elemen minimum dan maksimum; Kiraan pembolehubah; keadaan untuk semua elemen sama; Kod pemacu", "code": "import java . util . * ; class GFG { static int countPairs ( int a [ ] , int n ) { int mn = Integer . MAX_VALUE ; int mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( mn , a [ i ] ) ; mx = Math . max ( mx , a [ i ] ) ; } int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 2 , 1 , 1 , 3 } ; int n = a . length ; System . out . print ( countPairs ( a , n ) ) ; } }"}
{"text": "Susun semula senarai yang dipautkan dalam | Kod Java untuk menyusun semula senarai yang dipautkan di tempat; Fungsi untuk menyusun semula senarai yang dipautkan dengan nilai tinggi dan rendah. ; Kes asas. ; Pembolehubah dua penunjuk. ; Fungsi swap untuk menukar data. ; Fungsi swap untuk menukar data. ; Fungsi untuk memasukkan nod dalam senarai yang dipautkan pada mulanya. ; Fungsi untuk memaparkan nod senarai yang dipautkan. ; Kod pemacu; Biarkan membuat senarai yang dipautkan. 9. 6. 8. 3. 7", "code": "class Geeks { static class Node { int data ; Node next ; } static Node rearrange ( Node head ) { if ( head == null ) return null ; Node prev = head , curr = head . next ; while ( curr != null ) { if ( prev . data > curr . data ) { int t = prev . data ; prev . data = curr . data ; curr . data = t ; } if ( curr . next != null && curr . next . data > curr . data ) { int t = curr . next . data ; curr . next . data = curr . data ; curr . data = t ; } prev = curr . next ; if ( curr . next == null ) break ; curr = curr . next . next ; } return head ; } static Node push ( Node head , int k ) { Node tem = new Node ( ) ; tem . data = k ; tem . next = head ; head = tem ; return head ; } static void display ( Node head ) { Node curr = head ; while ( curr != null ) { System . out . printf ( \" % d ▁ \" , curr . data ) ; curr = curr . next ; } } public static void main ( String args [ ] ) { Node head = null ; head = push ( head , 7 ) ; head = push ( head , 3 ) ; head = push ( head , 8 ) ; head = push ( head , 6 ) ; head = push ( head , 9 ) ; head = rearrange ( head ) ; display ( head ) ; } }"}
{"text": "Susun semula senarai yang dipautkan dalam | Pelaksanaan Java; Mewujudkan struktur untuk nod;  ; Berfungsi untuk mencetak senarai; Berfungsi untuk menyusun semula; Kami menetapkan kiri = null, apabila kita mencapai keadaan berhenti, jadi tiada pemprosesan diperlukan selepas itu; Kondisi Hentikan: Kes Ganjil: Kiri = Kanan, Malah Kes: Kiri. seterusnya = kanan; Hentikan keadaan, tetapkan null ke nod kiri; Malah kes; kes ganjil; Kod pemacu; Cetak senarai asal; Mengubah suai senarai; Cetak senarai yang diubahsuai", "code": "import java . io . * ; class Node { int data ; Node next ; Node ( int key ) { data = key ; next = null ; } } class GFG { Node left = null ; void printlist ( Node head ) { while ( head != null ) { System . out . print ( head . data + \" ▁ \" ) ; if ( head . next != null ) { System . out . print ( \" - > \" ) ; } head = head . next ; } System . out . println ( ) ; } void rearrange ( Node head ) { if ( head != null ) { left = head ; reorderListUtil ( left ) ; } } void reorderListUtil ( Node right ) { if ( right == null ) { return ; } reorderListUtil ( right . next ) ; if ( left == null ) { return ; } if ( left != right && left . next != right ) { Node temp = left . next ; left . next = right ; right . next = temp ; left = temp ; } else { if ( left . next == right ) { left . next . next = null ; left = null ; } else { left . next = null ; left = null ; } } } public static void main ( String [ ] args ) { Node head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 3 ) ; head . next . next . next = new Node ( 4 ) ; head . next . next . next . next = new Node ( 5 ) ; GFG gfg = new GFG ( ) ; gfg . printlist ( head ) ; gfg . rearrange ( head ) ; gfg . printlist ( head ) ; } }"}
{"text": "Kurangkan dua nombor yang diwakili sebagai senarai yang dipautkan | Program Java untuk menolak senarai bernilai yang lebih kecil dari senarai bernilai yang lebih besar dan hasil kembali sebagai senarai. ; Ketua Senarai; Kelas nod; Fungsi utiliti untuk mendapatkan panjang senarai yang dipautkan; Utiliti yang sifar Padds di hadapan nod, dengan perbezaan yang diberikan; Kurangkan Helper LinkedList adalah fungsi rekursif, bergerak sehingga nod terakhir, dan tolak digit dan buat nod dan kembalikan nod. Jika D1 <D2, kami meminjam nombor dari digit sebelumnya. ; Jika anda telah memberikan nilai nilai kepada digit seterusnya maka kurangkan D1 dengan 1; Jika D1 <D2, kemudian pinjam nombor dari digit sebelumnya. Tambah 10 hingga D1 dan set Borrow = true; ; tolak digit; Buat nod dengan sub nilai; Tetapkan penunjuk seterusnya seperti sebelumnya; API ini menolak dua senarai yang dipautkan dan mengembalikan senarai yang dipautkan yang akan mempunyai hasil yang dikurangkan. ; Kes asas. ; Dalam kedua -dua kes itu, dapatkan panjang kedua -dua senarai yang dipautkan. ; Jika panjang berbeza, hitung nod yang lebih kecil dan sifar PADD untuk nod yang lebih kecil dan pastikan kedua -dua nod yang lebih besar dan nod yang lebih kecil mempunyai panjang yang sama. ; Jika kedua -dua senarai panjang adalah sama, maka hitung senarai yang lebih besar dan lebih kecil. Jika 5 - 6 - 7 & 5 - 6 - 8 adalah senarai yang dipautkan, kemudian berjalan melalui senarai yang dipautkan pada nod terakhir sebagai 7 <8, nod yang lebih besar adalah 5 - 6 - 8 dan nod yang lebih kecil ialah 5 - 6 - 7 .; Setelah mengira nod yang lebih besar dan lebih kecil, call tolakLinkedListHelper yang mengembalikan senarai yang dipautkan. ; berfungsi untuk memaparkan senarai yang dipautkan; Program Pemandu untuk diuji di atas", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class LinkedList { static Node head ; boolean borrow ; static class Node { int data ; Node next ; Node ( int d ) { data = d ; next = null ; } } int getLength ( Node node ) { int size = 0 ; while ( node != null ) { node = node . next ; size ++ ; } return size ; } Node paddZeros ( Node sNode , int diff ) { if ( sNode == null ) return null ; Node zHead = new Node ( 0 ) ; diff -- ; Node temp = zHead ; while ( ( diff -- ) != 0 ) { temp . next = new Node ( 0 ) ; temp = temp . next ; } temp . next = sNode ; return zHead ; } Node subtractLinkedListHelper ( Node l1 , Node l2 ) { if ( l1 == null && l2 == null && borrow == false ) return null ; Node previous = subtractLinkedListHelper ( ( l1 != null ) ? l1 . next : null , ( l2 != null ) ? l2 . next : null ) ; int d1 = l1 . data ; int d2 = l2 . data ; int sub = 0 ; if ( borrow ) { d1 -- ; borrow = false ; } if ( d1 < d2 ) { borrow = true ; d1 = d1 + 10 ; } sub = d1 - d2 ; Node current = new Node ( sub ) ; current . next = previous ; return current ; } Node subtractLinkedList ( Node l1 , Node l2 ) { if ( l1 == null && l2 == null ) return null ; int len1 = getLength ( l1 ) ; int len2 = getLength ( l2 ) ; Node lNode = null , sNode = null ; Node temp1 = l1 ; Node temp2 = l2 ; if ( len1 != len2 ) { lNode = len1 > len2 ? l1 : l2 ; sNode = len1 > len2 ? l2 : l1 ; sNode = paddZeros ( sNode , Math . abs ( len1 - len2 ) ) ; } else { while ( l1 != null && l2 != null ) { if ( l1 . data != l2 . data ) { lNode = l1 . data > l2 . data ? temp1 : temp2 ; sNode = l1 . data > l2 . data ? temp2 : temp1 ; break ; } l1 = l1 . next ; l2 = l2 . next ; } } borrow = false ; return subtractLinkedListHelper ( lNode , sNode ) ; } static void printList ( Node head ) { Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + \" ▁ \" ) ; temp = temp . next ; } } public static void main ( String [ ] args ) { Node head = new Node ( 1 ) ; head . next = new Node ( 0 ) ; head . next . next = new Node ( 0 ) ; Node head2 = new Node ( 1 ) ; LinkedList ob = new LinkedList ( ) ; Node result = ob . subtractLinkedList ( head , head2 ) ; printList ( result ) ; } }"}
{"text": "Masukkan nod ke tengah senarai yang dipautkan | Pelaksanaan Java untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Ketua Senarai; Kelas nod; Pembina untuk membuat nod baru; berfungsi untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Jika senarai kosong; Dapatkan nod baru; Kirakan panjang senarai yang dipautkan, i. e, bilangan nod; 'mengira' bilangan nod yang selepas nod baru dimasukkan; 'PTR' menunjuk ke nod yang mana nod baru dimasukkan; Masukkan 'newnode' dan laraskan pautan yang diperlukan; berfungsi untuk memaparkan senarai yang dipautkan; Program pemandu untuk menguji di atas; Membuat senarai 1.2. 4.5", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class LinkedList { static Node head ; static class Node { int data ; Node next ; Node ( int d ) { data = d ; next = null ; } } static void insertAtMid ( int x ) { if ( head == null ) head = new Node ( x ) ; else { Node newNode = new Node ( x ) ; Node ptr = head ; int len = 0 ; while ( ptr != null ) { len ++ ; ptr = ptr . next ; } int count = ( ( len % 2 ) == 0 ) ? ( len / 2 ) : ( len + 1 ) / 2 ; ptr = head ; while ( count -- > 1 ) ptr = ptr . next ; newNode . next = ptr . next ; ptr . next = newNode ; } } static void display ( ) { Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + \" ▁ \" ) ; temp = temp . next ; } } public static void main ( String [ ] args ) { head = null ; head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 4 ) ; head . next . next . next = new Node ( 5 ) ; System . out . println ( \" Linked ▁ list ▁ before ▁ \" + \" insertion : ▁ \" ) ; display ( ) ; int x = 3 ; insertAtMid ( x ) ; System . out . println ( \" Linked list after \" + ▁ \" insertion : \"); display ( ) ; } }"}
{"text": "Masukkan nod ke tengah senarai yang dipautkan | Pelaksanaan Java untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Ketua Senarai; Kelas nod; berfungsi untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Jika senarai kosong; Dapatkan nod baru; Berikan nilai kepada petunjuk yang perlahan dan cepat; gerakkan penunjuk perlahan ke nod seterusnya; Pindahkan penunjuk cepat dua nod pada satu masa; Masukkan 'newnode' dan laraskan pautan yang diperlukan; berfungsi untuk memaparkan senarai yang dipautkan; Program pemandu untuk menguji di atas; Membuat senarai 1.2. 4.5", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class LinkedList { static Node head ; static class Node { int data ; Node next ; Node ( int d ) { data = d ; next = null ; } } static void insertAtMid ( int x ) { if ( head == null ) head = new Node ( x ) ; else { Node newNode = new Node ( x ) ; Node slow = head ; Node fast = head . next ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } newNode . next = slow . next ; slow . next = newNode ; } } static void display ( ) { Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + \" ▁ \" ) ; temp = temp . next ; } } public static void main ( String [ ] args ) { head = null ; head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 4 ) ; head . next . next . next = new Node ( 5 ) ; System . out . println ( \" Linked ▁ list ▁ before \" + \" ▁ insertion : ▁ \" ) ; display ( ) ; int x = 3 ; insertAtMid ( x ) ; System . out . println ( \" Linked list after \" + ▁ \" insertion : \"); display ( ) ; } }"}
{"text": "SENARAI SENSI UNTUK SENARAI DUBLY LINKED | Pelaksanaan Java untuk memasukkan sort pada senarai dikaitkan dua kali ganda; Nod senarai dikaitkan dua kali ganda; berfungsi untuk membuat dan mengembalikan nod baru senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; berfungsi untuk memasukkan nod baru dalam cara yang disusun dalam senarai dikaitkan dua kali ganda; Jika senarai kosong; Jika nod dimasukkan pada permulaan senarai dikaitkan dua kali ganda; cari nod yang selepas itu nod baru dimasukkan; Buat pautan yang sesuai /; Jika nod baru tidak dimasukkan pada akhir senarai; Fungsi untuk menyusun senarai yang dikaitkan dua kali menggunakan jenis penyisipan; Inisialisasi 'disusun' - senarai dikaitkan dua kali ganda yang disusun; Melintasi senarai dikaitkan dua kali ganda dan masukkan setiap nod untuk 'disusun'; Simpan seterusnya untuk lelaran seterusnya; Mengeluarkan semua pautan untuk membuat 'semasa' sebagai nod baru untuk dimasukkan; Masukkan arus dalam senarai dikaitkan 'disusun'; Mengemas kini semasa; Kemas kini head_ref untuk menunjuk ke senarai yang disusun dua kali ganda; berfungsi untuk mencetak senarai dikaitkan dua kali ganda; berfungsi untuk memasukkan nod pada permulaan senarai dikaitkan dua kali ganda; memperuntukkan nod /; masukkan data /; Buat seterusnya nod baru sebagai kepala dan sebelumnya sebagai null /; Tukar Node kepala ke nod baru /; gerakkan kepala untuk menunjuk ke nod baru /; Kod pemacu; Mulakan dengan senarai dikaitkan dua kali ganda /; Masukkan data berikut", "code": "class Solution { static class Node { int data ; Node prev , next ; } ; static Node getNode ( int data ) { Node newNode = new Node ( ) ; newNode . data = data ; newNode . prev = newNode . next = null ; return newNode ; } static Node sortedInsert ( Node head_ref , Node newNode ) { Node current ; if ( head_ref == null ) head_ref = newNode ; else if ( ( head_ref ) . data >= newNode . data ) { newNode . next = head_ref ; newNode . next . prev = newNode ; head_ref = newNode ; } else { current = head_ref ; while ( current . next != null && current . next . data < newNode . data ) current = current . next ; newNode . next = current . next ; if ( current . next != null ) newNode . next . prev = newNode ; current . next = newNode ; newNode . prev = current ; } return head_ref ; } static Node insertionSort ( Node head_ref ) { Node sorted = null ; Node current = head_ref ; while ( current != null ) { Node next = current . next ; current . prev = current . next = null ; sorted = sortedInsert ( sorted , current ) ; current = next ; } head_ref = sorted ; return head_ref ; } static void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + \" ▁ \" ) ; head = head . next ; } } static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = ( head_ref ) ; new_node . prev = null ; if ( ( head_ref ) != null ) ( head_ref ) . prev = new_node ; ( head_ref ) = new_node ; return head_ref ; } public static void main ( String args [ ] ) { Node head = null ; head = push ( head , 9 ) ; head = push ( head , 3 ) ; head = push ( head , 5 ) ; head = push ( head , 10 ) ; head = push ( head , 12 ) ; head = push ( head , 8 ) ; System . out . println ( \"Doubly Linked List Before SortingNEW_LINE\"); printList ( head ) ; head = insertionSort ( head ) ; System . out . println ( \" Doubly Linked List After Sorting \"); printList ( head ) ; } }"}
{"text": "Cetak semua kemungkinan putaran array yang diberikan | Program Java untuk mencetak semua kemungkinan putaran array yang diberikan; Perisytiharan Global Array; Fungsi untuk membalikkan array antara indeks S dan E; Berfungsi untuk menjana semua kemungkinan putaran array; Kod pemacu", "code": "class GFG { static int arr [ ] = new int [ 10000 ] ; public static void reverse ( int arr [ ] , int s , int e ) { while ( s < e ) { int tem = arr [ s ] ; arr [ s ] = arr [ e ] ; arr [ e ] = tem ; s = s + 1 ; e = e - 1 ; } } public static void fun ( int arr [ ] , int k ) { int n = 4 - 1 ; int v = n - k ; if ( v >= 0 ) { reverse ( arr , 0 , v ) ; reverse ( arr , v + 1 , n ) ; reverse ( arr , 0 , n ) ; } } public static void main ( String args [ ] ) { arr [ 0 ] = 1 ; arr [ 1 ] = 2 ; arr [ 2 ] = 3 ; arr [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { fun ( arr , i ) ; System . out . print ( \" [ \" ) ; for ( int j = 0 ; j < 4 ; j ++ ) { System . out . print ( arr [ j ] + \" , ▁ \" ) ; } System . out . print ( \" ] \" ) ; } } }"}
{"text": "Cari jumlah array menggunakan bitwise atau selepas memisahkan array yang diberikan dalam dua bahagian selepas pergeseran bulat k | Program Java untuk mencari bitwise atau dua bahagian yang sama dengan array selepas melakukan peralihan bulat kanan K; Array untuk menyimpan pokok segmen; Berfungsi untuk membina pokok segmen; Berfungsi untuk mengembalikan atau unsur -unsur dalam julat [l, r]; Semak keadaan terikat; Cari tengah julat; Berulang untuk semua elemen dalam pelbagai; Berfungsi untuk mencari atau jumlah; Berfungsi untuk membina pokok segmen; Gelung untuk mengendalikan pertanyaan Q; Bilangan peralihan bulat yang betul; Atau separuh kedua array [n / 2 - i, n - 1 - i]; Atau separuh pertama array [n - i, n - 1] atau [0, n / 2 - 1 - i]; Cetak jawapan akhir untuk pertanyaan; Kod pemacu", "code": "import java . util . * ; class GFG { static int MAX = 100005 ; static int [ ] seg = new int [ 4 * MAX ] ; static void build ( int node , int l , int r , int a [ ] ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) / 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } } static int query ( int node , int l , int r , int start , int end , int a [ ] ) { if ( l > end r < start ) return 0 ; if ( start <= l && r <= end ) return seg [ node ] ; int mid = ( l + r ) / 2 ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; } static void orsum ( int a [ ] , int n , int q , int k [ ] ) { build ( 1 , 0 , n - 1 , a ) ; for ( int j = 0 ; j < q ; j ++ ) { int i = k [ j ] % ( n / 2 ) ; int sec = query ( 1 , 0 , n - 1 , n / 2 - i , n - i - 1 , a ) ; int first = ( query ( 1 , 0 , n - 1 , 0 , n / 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) ; int temp = sec + first ; System . out . print ( temp + \"NEW_LINE\"); } } public static void main ( String [ ] args ) { int a [ ] = { 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 } ; int n = a . length ; int q = 2 ; int k [ ] = { 4 , 2 } ; orsum ( a , n , q , k ) ; } }"}
{"text": "Memaksimumkan kiraan unsur -unsur yang sama dalam tatasusunan yang diberikan oleh putaran | Program Java pendekatan di atas; Fungsi yang mencetak elemen maksimum yang sama; Vektor untuk menyimpan indeks elemen array b; Menyimpan kedudukan array b; Arahan frekuensi untuk mengekalkan unsur -unsur dengan perbezaan yang sama dalam jarak; Melangkah melalui semua elemen dalam ARR1 []; Kirakan bilangan peralihan yang diperlukan untuk menjadikan elemen semasa sama; Jika D kurang daripada 0; Simpan kekerapan perbezaan semasa; Kirakan kekerapan maksimum yang disimpan; Mencetak bilangan maksimum elemen yang sama; Kod pemacu; Diberikan dua tatasusunan; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void maximumEqual ( int a [ ] , int b [ ] , int n ) { int store [ ] = new int [ ( int ) 1e5 ] ; for ( int i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; } int ans [ ] = new int [ ( int ) 1e5 ] ; for ( int i = 0 ; i < n ; i ++ ) { int d = Math . abs ( store [ a [ i ] ] - ( i + 1 ) ) ; if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; } ans [ d ] ++ ; } int finalans = 0 ; for ( int i = 0 ; i < 1e5 ; i ++ ) finalans = Math . max ( finalans , ans [ i ] ) ; System . out . print ( finalans + \"NEW_LINE\"); } public static void main ( String [ ] args ) { int A [ ] = { 6 , 7 , 3 , 9 , 5 } ; int B [ ] = { 7 , 3 , 9 , 5 , 6 } ; int size = A . length ; maximumEqual ( A , B , size ) ; } }"}
{"text": "Arahan cetak selepas ia betul -betul diputar k kali | Pelaksanaan Java putaran kanan dari array k bilangan kali; Berfungsi untuk array rightrotate; Jika putaran lebih besar daripada saiz array; Mencetak elemen kth paling kanan; Cetak array selepas elemen 'k'; Program Pemandu", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class Array_Rotation { static void RightRotate ( int a [ ] , int n , int k ) { k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { System . out . print ( a [ n + i - k ] + \" ▁ \" ) ; } else { System . out . print ( a [ i - k ] + \" ▁ \" ) ; } } System . out . println ( ) ; } public static void main ( String args [ ] ) { int Array [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = Array . length ; int K = 2 ; RightRotate ( Array , N , K ) ; } }"}
{"text": "Sort Array Disusun Berputar | Pelaksanaan Java untuk memulihkan jenis asal dalam array yang disusun diputar; Berfungsi untuk memulihkan jenis asal; Dalam sebaliknya (), parameter pertama adalah iterator untuk memulakan elemen dan parameter kedua adalah iterator untuk elemen terakhir ditambah satu. ; Berfungsi untuk mencetak array; Kod pemacu", "code": "class GFG { static void restoreSortedArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { reverse ( arr , 0 , i ) ; reverse ( arr , i + 1 , n ) ; reverse ( arr , 0 , n ) ; } } } static void reverse ( int [ ] arr , int i , int j ) { int temp ; while ( i < j ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i ++ ; j -- ; } } static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n = arr . length ; restoreSortedArray ( arr , n - 1 ) ; printArray ( arr , n ) ; } }"}
{"text": "Sort Array Disusun Berputar | Pelaksanaan Java untuk memulihkan jenis asal dalam array disusun yang diputar menggunakan carian binari; Fungsi untuk mencari indeks permulaan array; Berfungsi untuk memulihkan jenis asal; Array sudah disusun; Dalam sebaliknya (), parameter pertama adalah iterator untuk memulakan elemen dan parameter kedua adalah iterator untuk elemen terakhir ditambah satu. ; Berfungsi untuk mencetak array; Kod pemacu", "code": "import java . util . * ; class GFG { static int findStartIndexOfArray ( int arr [ ] , int low , int high ) { if ( low > high ) { return - 1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( arr [ mid - 1 ] > arr [ mid ] ) { return mid ; } if ( arr [ low ] > arr [ mid ] ) { return findStartIndexOfArray ( arr , low , mid - 1 ) ; } else { return findStartIndexOfArray ( arr , mid + 1 , high ) ; } } static void restoreSortedArray ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) { return ; } int start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; Arrays . sort ( arr , 0 , start ) ; Arrays . sort ( arr , start , n ) ; Arrays . sort ( arr ) ; } static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { System . out . print ( arr [ i ] + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; restoreSortedArray ( arr , n ) ; printArray ( arr , n ) ; } }"}
{"text": "Putaran kiri dan putaran kanan rentetan | Program Java untuk putaran kiri dan putaran kanan rentetan; fungsi yang berputar ke kiri oleh D; fungsi yang berputar ke arah kanan oleh D; Kod pemacu", "code": "import java . util . * ; import java . io . * ; class GFG { static String leftrotate ( String str , int d ) { String ans = str . substring ( d ) + str . substring ( 0 , d ) ; return ans ; } static String rightrotate ( String str , int d ) { return leftrotate ( str , str . length ( ) - d ) ; } public static void main ( String args [ ] ) { String str1 = \" GeeksforGeeks \" ; System . out . println ( leftrotate ( str1 , 2 ) ) ; String str2 = \" GeeksforGeeks \" ; System . out . println ( rightrotate ( str2 , 2 ) ) ; } }"}
{"text": "Cari elemen dalam Senarai Berkaitan Pekeliling Ganda | Program Java untuk menggambarkan memasukkan nod dalam senarai dikaitkan dua kali ganda dalam mengemis, akhir dan tengah; Struktur nod; Berfungsi untuk memasukkan nod pada akhir; Jika senarai kosong, buat satu pekeliling nod tunggal dan senarai dua kali ganda; Cari nod terakhir /; Buat nod secara dinamik; Mula akan menjadi yang akan datang dengan New_node; Buat nod baru sebelum permulaan; Membuat nod baru yang terakhir; Buat nod baru yang akan datang yang terakhir; Berfungsi untuk memaparkan senarai dikaitkan dua kali ganda; Berfungsi untuk mencari elemen tertentu dari senarai; Mengisytiharkan pemboleh ubah temp; Mengisytiharkan pemboleh ubah kawalan lain untuk mencari; Jika permulaan adalah NULL RETURN - 1; Gerakkan penunjuk temp sehingga, temp. Seterusnya tidak memindahkan alamat permulaan (fesyen bulat); Kiraan kenaikan lokasi; Jika didapati menaikkan bendera dan memecahkan gelung; Penunjuk suhu kenaikan; Semak sama ada elemen terakhir dalam kandungan senarai nilai jika mengandungi, menaikkan bendera dan kiraan kenaikan; Jika bendera adalah benar, maka unsur dijumpai, lain tidak; Kod pemacu; Mulakan dengan senarai kosong /; Masukkan 4. Jadi senarai yang dipautkan menjadi 4. NULL; Masukkan 5. Jadi senarai yang dipautkan menjadi 4.5; Masukkan 7. Jadi senarai yang dipautkan menjadi 4.5. 7; Masukkan 8. Jadi senarai yang dipautkan menjadi 4.5. 7.8; Masukkan 6. Jadi senarai yang dipautkan menjadi 4.5. 7.8. 6", "code": "class GFG { static class Node { int data ; Node next ; Node prev ; } ; static Node insertNode ( Node start , int value ) { if ( start == null ) { Node new_node = new Node ( ) ; new_node . data = value ; new_node . next = new_node . prev = new_node ; start = new_node ; return new_node ; } Node last = ( start ) . prev ; Node new_node = new Node ( ) ; new_node . data = value ; new_node . next = start ; ( start ) . prev = new_node ; new_node . prev = last ; last . next = new_node ; return start ; } static void displayList ( Node start ) { Node temp = start ; while ( temp . next != start ) { System . out . printf ( \" % d ▁ \" , temp . data ) ; temp = temp . next ; } System . out . printf ( \" % d ▁ \" , temp . data ) ; } static int searchList ( Node start , int search ) { Node temp = start ; int count = 0 , flag = 0 , value ; if ( temp == null ) return - 1 ; else { while ( temp . next != start ) { count ++ ; if ( temp . data == search ) { flag = 1 ; count -- ; break ; } temp = temp . next ; } if ( temp . data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) System . out . println ( \" \" + search ▁ + \" found at location \"+ count); else System . out . println ( \" \" + search ▁ + \" not found \"); } return - 1 ; } public static void main ( String args [ ] ) { Node start = null ; start = insertNode ( start , 4 ) ; start = insertNode ( start , 5 ) ; start = insertNode ( start , 7 ) ; start = insertNode ( start , 8 ) ; start = insertNode ( start , 6 ) ; System . out . printf ( \" Created ▁ circular ▁ doubly ▁ linked ▁ list ▁ is : ▁ \" ) ; displayList ( start ) ; searchList ( start , 5 ) ; } }"}
{"text": "Membalikkan senarai dikaitkan bulat berganda | Pelaksanaan Java untuk mengulangi senarai dikaitkan bulat dua kali ganda; struktur nod senarai yang dipautkan; berfungsi untuk membuat dan mengembalikan nod baru; Berfungsi untuk memasukkan pada akhir; Jika senarai kosong, buat satu pekeliling nod tunggal dan senarai dua kali ganda; Cari nod terakhir /; Mula akan menjadi yang akan datang dengan New_node; Buat nod baru sebelum permulaan; Membuat nod baru yang terakhir; Buat nod baru yang akan datang yang terakhir; Fungsi uitlity untuk mengulangi senarai dikaitkan bulat dua kali ganda; Memulakan penunjuk kepala baru; Dapatkan penunjuk ke nod terakhir; Tetapkan 'curr' ke nod terakhir; senarai melintasi arah ke belakang; Masukkan 'curr' pada akhir senarai bermula dengan penunjuk 'baru _ kepala'; penunjuk kepala senarai terbalik; berfungsi untuk memaparkan senarai bulat berganda dalam arah ke hadapan dan ke belakang; Kod pemacu", "code": "class GFG { static class Node { int data ; Node next , prev ; } ; static Node getNode ( int data ) { Node newNode = new Node ( ) ; newNode . data = data ; return newNode ; } static Node insertEnd ( Node head , Node new_node ) { if ( head == null ) { new_node . next = new_node . prev = new_node ; head = new_node ; return head ; } Node last = ( head ) . prev ; new_node . next = head ; ( head ) . prev = new_node ; new_node . prev = last ; last . next = new_node ; return head ; } static Node reverse ( Node head ) { if ( head == null ) return null ; Node new_head = null ; Node last = head . prev ; Node curr = last , prev ; while ( curr . prev != last ) { prev = curr . prev ; new_head = insertEnd ( new_head , curr ) ; curr = prev ; } new_head = insertEnd ( new_head , curr ) ; return new_head ; } static void display ( Node head ) { if ( head == null ) return ; Node temp = head ; System . out . print ( \" Forward ▁ direction : ▁ \" ) ; while ( temp . next != head ) { System . out . print ( temp . data + \" ▁ \" ) ; temp = temp . next ; } System . out . print ( temp . data + \" ▁ \" ) ; Node last = head . prev ; temp = last ; System . out . print ( \" Backward direction : \"); while ( temp . prev != last ) { System . out . print ( temp . data + \" ▁ \" ) ; temp = temp . prev ; } System . out . print ( temp . data + \" ▁ \" ) ; } public static void main ( String args [ ] ) { Node head = null ; head = insertEnd ( head , getNode ( 1 ) ) ; head = insertEnd ( head , getNode ( 2 ) ) ; head = insertEnd ( head , getNode ( 3 ) ) ; head = insertEnd ( head , getNode ( 4 ) ) ; head = insertEnd ( head , getNode ( 5 ) ) ; System . out . print ( \"Current list:NEW_LINE\"); display ( head ) ; head = reverse ( head ) ; System . out . print ( \" Reversed list : \"); display ( head ) ; } }"}
{"text": "SQRT (atau Square Root) Penguraian | Tetapkan 2 (LCA pokok dalam O (sqrt (ketinggian)) masa) | Pelaksanaan Java naif untuk mencari LCA di dalam pokok. ; Kedalaman kedai untuk setiap nod; Kedai ibu bapa pertama untuk setiap nod; menandakan ibu bapa untuk setiap nod; menandakan kedalaman untuk setiap nod; propogating menandakan pokok itu; nod dummy; precalclating 1) kedalaman. 2) ibu bapa. untuk setiap nod; Kerumitan masa: O (ketinggian pokok) secara rekursif melompat satu nod di atas sehingga kedua -dua nod menjadi sama; Kod pemacu; Menambah tepi ke pokok", "code": "import java . io . * ; import java . util . * ; class GFG { static int MAXN = 1001 ; static int [ ] depth = new int [ MAXN ] ; static int [ ] parent = new int [ MAXN ] ; @ SuppressWarnings ( \" unchecked \" ) static Vector < Integer > [ ] adj = new Vector [ MAXN ] ; static { for ( int i = 0 ; i < MAXN ; i ++ ) adj [ i ] = new Vector < > ( ) ; } static void addEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } static void dfs ( int cur , int prev ) { parent [ cur ] = prev ; depth [ cur ] = depth [ prev ] + 1 ; for ( int i = 0 ; i < adj [ cur ] . size ( ) ; i ++ ) if ( adj [ cur ] . elementAt ( i ) != prev ) dfs ( adj [ cur ] . elementAt ( i ) , cur ) ; } static void preprocess ( ) { depth [ 0 ] = - 1 ; dfs ( 1 , 0 ) ; } static int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { int temp = u ; u = v ; v = temp ; } v = parent [ v ] ; return LCANaive ( u , v ) ; } public static void main ( String [ ] args ) { addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; preprocess ( ) ; System . out . println ( \" LCA ( 11,8 ) ▁ : ▁ \" + LCANaive ( 11 , 8 ) ) ; System . out . println ( \" LCA ( 3,13 ) ▁ : ▁ \" + LCANaive ( 3 , 13 ) ) ; } }"}
{"text": "SQRT (atau Square Root) Penguraian | Tetapkan 2 (LCA pokok dalam O (sqrt (ketinggian)) masa) | Program Java untuk mencari LCA menggunakan penguraian SQRT; Saiz blok = matematik. sqrt (ketinggian); Kedalaman kedai untuk setiap nod; Kedai ibu bapa pertama untuk setiap nod; Kedai nenek moyang pertama di blok sebelumnya; mempraktikkan parameter yang diperlukan yang berkaitan dengan setiap nod; menandakan kedalaman node cur; menandakan ibu bapa node cur; membuat jump_parent node cur; Jika ia adalah nod pertama blok maka jump_parentnya adalah ibu bapa yang curnya; Jika bukan nod pertama blok ini maka jump_parentnya adalah jump_parent ibu bapanya; propogating menandakan subtree; menggunakan helah penguraian SQRT; mengekalkan kedalaman [v]> kedalaman [u]; Mendaki ke ibu bapa melompatnya; u dan v mempunyai jump_parent yang sama; precalclating 1) kedalaman. 2) ibu bapa. 3) Jump_parent untuk setiap nod; Kod pemacu; Menambah tepi ke pokok; Di sini kita terus mengambil ketinggian = 4 mengikut pokok yang diberikan tetapi kita boleh mengira ketinggian = kedalaman maksimum dalam satu lagi dfs", "code": "import java . util . * ; class GFG { static final int MAXN = 1001 ; static int block_sz ; static int [ ] depth = new int [ MAXN ] ; static int [ ] parent = new int [ MAXN ] ; static int [ ] jump_parent = new int [ MAXN ] ; static Vector < Integer > [ ] adj = new Vector [ MAXN ] ; static void addEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } static int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { int t = u ; u = v ; v = t ; } v = parent [ v ] ; return LCANaive ( u , v ) ; } static void dfs ( int cur , int prev ) { depth [ cur ] = depth [ prev ] + 1 ; parent [ cur ] = prev ; if ( depth [ cur ] % block_sz == 0 ) jump_parent [ cur ] = parent [ cur ] ; else jump_parent [ cur ] = jump_parent [ prev ] ; for ( int i = 0 ; i < adj [ cur ] . size ( ) ; ++ i ) if ( adj [ cur ] . get ( i ) != prev ) dfs ( adj [ cur ] . get ( i ) , cur ) ; } static int LCASQRT ( int u , int v ) { while ( jump_parent [ u ] != jump_parent [ v ] ) { if ( depth [ u ] > depth [ v ] ) { int t = u ; u = v ; v = t ; } v = jump_parent [ v ] ; } return LCANaive ( u , v ) ; } static void preprocess ( int height ) { block_sz = ( int ) Math . sqrt ( height ) ; depth [ 0 ] = - 1 ; dfs ( 1 , 0 ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; int height = 4 ; preprocess ( height ) ; System . out . print ( \" LCA ( 11,8 ) ▁ : ▁ \" + LCASQRT ( 11 , 8 ) + \"NEW_LINE\"); System . out . print ( \" LCA ( 3,13 ) ▁ : ▁ \" + LCASQRT ( 3 , 13 ) + \"NEW_LINE\"); } }"}
{"text": "Bilangan ujian yang dijangkakan untuk mendapatkan kepala berturut -turut n | Pelaksanaan Java pendekatan di atas; Kod pemacu; Formula untuk bilangan laluan untuk kepala berturut -turut n", "code": "class GFG { public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( Math . pow ( 2 , N + 1 ) - 2 ) ; } }"}
{"text": "Cari dan kirakan jumlah faktor Co | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mengembalikan kiraan nombor yang boleh dibahagikan oleh kedua -dua A dan B dalam julat [1, n] dalam masa yang berterusan; Kirakan kiraan nombor yang boleh dibahagikan dengan A dalam julat [1, n]; Kirakan kiraan nombor yang boleh dibahagi dengan b dalam julat [1, n]; Menambah tuduhan yang boleh dibahagikan oleh A dan B; Nilai di atas mungkin mengandungi nilai berulang yang boleh dibahagikan oleh kedua -dua A dan B. Oleh itu, kiraan nombor yang boleh dibahagikan oleh kedua -dua A dan B ditemui; Kiraan yang dikira di atas dikurangkan untuk mengira kiraan akhir; Berfungsi untuk mengembalikan jumlah nombor yang boleh dibahagikan oleh kedua -dua A dan B dalam julat [1, n]; Tetapkan untuk menyimpan nombor supaya nombor tidak diulang; Untuk gelung untuk mencari nombor yang boleh dibahagikan dengan A dan masukkannya ke dalam set; Untuk gelung untuk mencari nombor yang boleh dibahagikan dengan A dan masukkannya ke dalam set; Untuk gelung untuk melangkah melalui set dan cari jumlahnya; Kod pemacu", "code": "import java . util . * ; class GFG { static int countOfNum ( int n , int a , int b ) { int cnt_of_a , cnt_of_b , cnt_of_ab , sum ; cnt_of_a = n / a ; cnt_of_b = n / b ; sum = cnt_of_b + cnt_of_a ; cnt_of_ab = n / ( a * b ) ; sum = sum - cnt_of_ab ; return sum ; } static int sumOfNum ( int n , int a , int b ) { int i ; int sum = 0 ; Set < Integer > ans = new HashSet < Integer > ( ) ; for ( i = a ; i <= n ; i = i + a ) { ans . add ( i ) ; } for ( i = b ; i <= n ; i = i + b ) { ans . add ( i ) ; } for ( Integer it : ans ) { sum = sum + it ; } return sum ; } public static void main ( String [ ] args ) { int N = 88 ; int A = 11 ; int B = 8 ; int count = countOfNum ( N , A , B ) ; int sumofnum = sumOfNum ( N , A , B ) ; System . out . print ( sumofnum % count ) ; } }"}
{"text": "Cari nilai julat ungkapan | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan nilai ungkapan yang diberikan; Nilai istilah pertama; Nilai istilah terakhir; Kod pemacu; Dapatkan hasilnya", "code": "import java . util . * ; class GFG { static double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; } public static void main ( String [ ] args ) { int L = 6 , R = 12 ; double ans = get ( L , R ) ; System . out . printf ( \" % .2f \" , ans ) ; } }"}
{"text": "Cari elemen yang lebih besar seterusnya tanpa berturut -turut 1 dalam perwakilan binari itu | Pelaksanaan Java pendekatan; Untuk menyimpan bilangan bulat pra -dikira; Fungsi yang mengembalikan benar jika perwakilan binari x mengandungi 1 s; Untuk menyimpan sedikit sebelumnya; Semak sama ada bit sebelumnya dan bit semasa adalah kedua -dua 1; Mengemas kini sedikit sebelumnya; Pergi ke bit seterusnya; Fungsi untuk pra - mengira nombor yang sah dari 0 hingga maksimum; Simpan semua nombor yang tidak mempunyai 1 s berturut -turut; Berfungsi untuk mengembalikan nombor minimum yang lebih besar daripada n yang tidak mengandungi 1 s berturut -turut; Cari elemen yang lebih besar seterusnya tanpa berturut -turut 1 s; Berfungsi untuk melakukan pertanyaan; Kod pemacu; Pra - mengira nombor; Lakukan pertanyaan", "code": "import java . io . * ; import java . util . * ; class GFG { static int MAX = 100000 ; static ArrayList < Integer > v = new ArrayList < Integer > ( ) ; public static int upper_bound ( ArrayList < Integer > ar , int k ) { int s = 0 ; int e = ar . size ( ) ; while ( s != e ) { int mid = s + e >> 1 ; if ( ar . get ( mid ) <= k ) { s = mid + 1 ; } else { e = mid ; } } if ( s == ar . size ( ) ) { return - 1 ; } return s ; } static int consecutiveOnes ( int x ) { int p = 0 ; while ( x > 0 ) { if ( x % 2 == 1 && p == 1 ) { return 1 ; } p = x % 2 ; x /= 2 ; } return 0 ; } static void preCompute ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) { if ( consecutiveOnes ( i ) == 0 ) { v . add ( i ) ; } } } static int nextValid ( int n ) { int it = upper_bound ( v , n ) ; int val = v . get ( it ) ; return val ; } static void performQueries ( int queries [ ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( nextValid ( queries [ i ] ) ) ; } } public static void main ( String [ ] args ) { int queries [ ] = { 4 , 6 } ; int q = queries . length ; preCompute ( ) ; performQueries ( queries , q ) ; } }"}
{"text": "Operasi minimum yang diperlukan untuk menukar rentetan binari yang diberikan kepada semua 1 s | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan bilangan operasi yang diperlukan; CTR akan menyimpan bilangan yang berturut -turut pada akhir rentetan binari yang diberikan; Gelung untuk mencari bilangan 1 s pada akhir rentetan; Jika watak semasa adalah 1; Jika kita menghadapi 0 pertama dari kedudukan LSB maka kita akan memecahkan gelung; Bilangan operasi yang diperlukan ialah (L - CTR); Berfungsi untuk mengeluarkan sifar utama dari rentetan; Gelung sehingga S [i] menjadi tidak sama dengan 1; Jika kita sampai ke hujung rentetan, ini bermakna rentetan hanya mengandungi 0 's; Kembalikan rentetan tanpa nol utama; Kod pemacu; Mengeluarkan sifar terkemuka", "code": "class GFG { static int changeToOnes ( String str ) { int i , l , ctr = 0 ; l = str . length ( ) ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '1' ) ctr ++ ; else break ; } return l - ctr ; } static String removeZeroesFromFront ( String str ) { String s ; int i = 0 ; while ( i < str . length ( ) && str . charAt ( i ) == '0' ) i ++ ; if ( i == str . length ( ) ) s = \"0\" ; else s = str . substring ( i , str . length ( ) - i ) ; return s ; } public static void main ( String [ ] args ) { String str = \"10010111\" ; str = removeZeroesFromFront ( str ) ; System . out . println ( changeToOnes ( str ) ) ; } }"}
{"text": "Penghapusan minimum diperlukan sedemikian rupa sehingga mana -mana nombor x akan berlaku tepat x kali | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mengembalikan penghapusan minimum yang diperlukan; Untuk menyimpan kekerapan elemen array; Kekerapan kedai setiap elemen; Untuk menyimpan penghapusan minimum yang diperlukan; Nilai; Kekerapan itu; Jika bilangan kurang daripada atau sama dengan kekerapannya; Padam kejadian tambahan; Padam setiap kejadian x; Kod pemacu", "code": "import java . util . * ; class GFG { static int MinDeletion ( int a [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } } int ans = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int x = i . getKey ( ) ; int frequency = i . getValue ( ) ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 } ; int n = a . length ; System . out . println ( MinDeletion ( a , n ) ) ; } }"}
{"text": "Rentetan concatenate dalam apa -apa perintah untuk mendapatkan bilangan maksimum \"ab\" | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mencari bilangan maksimum abs; Pembolehubah A, B, AB untuk mengira rentetan yang berakhir dengan 'A' tetapi tidak berakhir dengan 'B', 'B' tetapi tidak berakhir dengan 'A' dan 'B' dan berakhir dengan 'A' masing -masing. ; 'Ab' sudah ada dalam rentetan sebelum menggabungkan mereka; Count rentetan yang bermula dengan 'B' dan berakhir dengan 'A; Count rentetan yang bermula dengan 'B' tetapi tidak berakhir dengan 'A'; Count rentetan yang berakhir dengan 'a' tetapi tidak berakhir dengan 'b'; mengemas kini nilai ANS dan menambah kiraan tambahan 'ab'; Kod pemacu", "code": "import java . util . * ; class GFG { static int maxCountAB ( String s [ ] , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String S = s [ i ] ; int L = S . length ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S . charAt ( j ) == ' A ' && S . charAt ( j + 1 ) == ' B ' ) { ans ++ ; } } if ( S . charAt ( 0 ) == ' B ' && S . charAt ( L - 1 ) == ' A ' ) BA ++ ; else if ( S . charAt ( 0 ) == ' B ' ) B ++ ; else if ( S . charAt ( L - 1 ) == ' A ' ) A ++ ; } if ( BA == 0 ) ans += Math . min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . min ( B , A ) ; return ans ; } public static void main ( String [ ] args ) { String s [ ] = { \" ABCA \" , \" BOOK \" , \" BAND \" } ; int n = s . length ; System . out . println ( maxCountAB ( s , n ) ) ; } }"}
{"text": "Operasi minimum untuk membuat jumlah elemen jiran <= x | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan; Untuk menyimpan jumlah operasi yang diperlukan; Mula -mula membuat semua elemen sama dengan x yang lebih besar; Kiri mengimbas array; Kemas kini elemen semasa supaya jumlah jiran adalah <x; Kod pemacu", "code": "class GFG { static int MinOperations ( int n , int x , int [ ] arr ) { int total = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > x ) { int difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } } for ( int i = 1 ; i < n ; ++ i ) { int LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ; if ( LeftNeigbouringSum > x ) { int current_diff = LeftNeigbouringSum - x ; arr [ i ] = Math . max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; } public static void main ( String args [ ] ) { int X = 1 ; int arr [ ] = { 1 , 6 , 1 , 2 , 0 , 4 } ; int N = arr . length ; System . out . println ( MinOperations ( N , X , arr ) ) ; } }"}
{"text": "Cari nombor berulang dan nombor yang hilang menggunakan dua persamaan | Pelaksanaan Java pendekatan; Berfungsi untuk mencetak nombor yang diperlukan; Jumlah nombor semulajadi n pertama; Jumlah kuadrat nombor semulajadi n pertama; Untuk menyimpan jumlah dan jumlah kuadrat unsur -unsur array; Kod pemacu", "code": "public class GFG { static void findNumbers ( int arr [ ] , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += Math . pow ( arr [ i ] , 2 ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; System . out . println ( \" A ▁ = ▁ \" + A + \" B = \" + B); } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 } ; int n = arr . length ; findNumbers ( arr , n ) ; } }"}
{"text": "Rentetan terkecil lexicographically dengan rentetan yang diberikan sebagai awalan | Program Java untuk pendekatan di atas; Berfungsi untuk mencari sama ada temp rentetan bermula dengan STR atau tidak; Kes asas; Semak aksara yang sepadan dalam temp & str; Berfungsi untuk mencari rentetan terkecil lexicographic yang terdiri daripada string str as awalan; Susun rentetan array yang diberikan []; Jika rentetan i - th mengandungi rentetan yang diberikan sebagai awalan, maka cetak hasilnya; Jika tiada rentetan wujud maka kembali \" - 1\"; Kod pemacu", "code": "import java . util . Arrays ; class GFG { static boolean is_prefix ( String temp , String str ) { if ( temp . length ( ) < str . length ( ) ) return false ; else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != temp . charAt ( i ) ) return false ; } return true ; } } static String lexicographicallyString ( String [ ] input , int n , String str ) { Arrays . sort ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { String temp = input [ i ] ; if ( is_prefix ( temp , str ) ) { return temp ; } } return \" - 1\" ; } public static void main ( String args [ ] ) { String [ ] arr = { \" apple \" , \" appe \" , \" apl \" , \" aapl \" , \" appax \" } ; String S = \" app \" ; int N = 5 ; System . out . println ( lexicographicallyString ( arr , N , S ) ) ; } }"}
{"text": "Susun semula Arahan untuk mencari K menggunakan algoritma carian binari tanpa menyusun | Program Java untuk pendekatan di atas; Berfungsi untuk menyusun semula array; Menyimpan array yang disusun semula; Kedai sama ada pengaturan itu mungkin atau tidak; Kemas kini k dengan kedudukan k; Menyimpan semua elemen yang lebih rendah daripada dan lebih besar daripada vektor yang lebih kecil dan lebih besar masing -masing; Melintasi array arr []; Jika arr [i] kurang daripada arr [k]; Lain; Iterat Unil Low kurang daripada atau sama dengan tinggi; Kedai pertengahan titik; Jika pertengahan adalah sama dengan k; Jika pertengahan kurang daripada k; Jika pertengahan lebih besar daripada k; Jika f adalah - 1; Melangkah dalam julat [1, n]; Jika Ans [i] sama dengan - 1; Cetak array yang disusun semula; Kod pemacu; Input; Panggilan fungsi", "code": "import java . util . * ; public class GFG { static void Rearrange ( int arr [ ] , int K , int N ) { int ans [ ] = new int [ N + 1 ] ; int f = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { ans [ i ] = - 1 ; } for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == K ) { K = i ; break ; } } Vector < Integer > smaller = new Vector < Integer > ( ) ; Vector < Integer > greater = new Vector < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ K ] ) smaller . add ( arr [ i ] ) ; else if ( arr [ i ] > arr [ K ] ) greater . add ( arr [ i ] ) ; } int low = 0 , high = N - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid == K ) { ans [ mid ] = arr [ K ] ; f = 1 ; break ; } else if ( mid < K ) { if ( smaller . size ( ) == 0 ) { break ; } ans [ mid ] = smaller . lastElement ( ) ; smaller . remove ( smaller . size ( ) - 1 ) ; low = mid + 1 ; } else { if ( greater . size ( ) == 0 ) { break ; } ans [ mid ] = greater . lastElement ( ) ; greater . remove ( greater . size ( ) - 1 ) ; high = mid - 1 ; } } if ( f == - 1 ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ans [ i ] == - 1 ) { if ( smaller . size ( ) > 0 ) { ans [ i ] = smaller . lastElement ( ) ; smaller . remove ( smaller . size ( ) - 1 ) ; } else if ( greater . size ( ) > 0 ) { ans [ i ] = greater . lastElement ( ) ; greater . remove ( greater . size ( ) - 1 ) ; } } } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( ans [ i ] + \" ▁ \" ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 7 , 2 , 5 , 3 , 8 } ; int K = 7 ; int N = arr . length ; Rearrange ( arr , K , N ) ; } }"}
{"text": "Kurangkan k untuk membiarkan orang mengambil sekurang -kurangnya ceil (n / (m + 1)) gula -gula berdasarkan peraturan yang diberikan | Program Java untuk pendekatan di atas; Fungsi untuk mencari nilai minimum k supaya orang pertama mendapat sekurang -kurangnya (n / (m + 1)) gula -gula; Cari nilai gula -gula minimum yang diperlukan untuk orang pertama; ITERATE K dari [1, n]; Jumlah gula -gula; Gula -gula yang diambil oleh orang 1; Gula -gula yang diambil oleh 1 orang adalah minimum k dan gula -gula yang tersisa; Melintasi array arr []; Jumlah yang digunakan oleh orang j; Mengemas kini bilangan gula -gula; Bahagian yang baik dari gula -gula yang dicapai; Kod pemacu", "code": "import java . util . * ; class GFG { static void minimumK ( ArrayList < Integer > arr , int M , int N ) { int good = ( int ) ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) + 1 ; for ( int i = 1 ; i <= N ; i ++ ) { int K = i ; int candies = N ; int taken = 0 ; while ( candies > 0 ) { taken += Math . min ( K , candies ) ; candies -= Math . min ( K , candies ) ; for ( int j = 0 ; j < M ; j ++ ) { int consume = ( arr . get ( j ) * candies ) / 100 ; candies -= consume ; } } if ( taken >= good ) { System . out . print ( i ) ; return ; } } } public static void main ( String [ ] args ) { int N = 13 , M = 1 ; ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; arr . add ( 50 ) ; minimumK ( arr , M , N ) ; } }"}
{"text": "Kurangkan k untuk membiarkan orang mengambil sekurang -kurangnya ceil (n / (m + 1)) gula -gula berdasarkan peraturan yang diberikan | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nilai pertengahan memberikan sekurang -kurangnya (n / (m + 1)) gula -gula atau tidak; Gula -gula yang diambil oleh 1 orang adalah minimum k dan gula -gula yang tersisa; Melintasi array yang diberikan; Jumlah yang digunakan oleh orang j; Mengemas kini kiraan gula -gula; Semak sama ada orang 1 mendapat bahagian yang baik dari gula -gula; Fungsi untuk mencari nilai minimum k supaya orang pertama mendapat sekurang -kurangnya (n / (m + 1)) gula -gula; Cari nilai gula -gula minimum yang diperlukan untuk orang pertama; Melangkah sehingga rendah kurang dari atau sama dengan pertengahan; Cari nilai pertengahan; Semak pertengahan, sama ada ia boleh menjadi nilai k atau tidak; Kemas kini nilai hi; Jika tidak, kemas kini nilai LO; Cetak nilai minimum yang dihasilkan k; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean check ( int K , int n , int m , ArrayList < Integer > arr , int good_share ) { int candies = n , taken = 0 ; while ( candies > 0 ) { taken += Math . min ( K , candies ) ; candies -= Math . min ( K , candies ) ; for ( int j = 0 ; j < m ; j ++ ) { int consume = ( arr . get ( j ) * candies ) / 100 ; candies -= consume ; } } return ( taken >= good_share ) ; } static void minimumK ( ArrayList < Integer > arr , int N , int M ) { int good_share = ( int ) Math . ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) ; int lo = 1 , hi = N ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( check ( mid , N , M , arr , good_share ) ) { hi = mid ; } else { lo = mid + 1 ; } } System . out . print ( hi ) ; } public static void main ( String [ ] args ) { int N = 13 , M = 1 ; ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; arr . add ( 50 ) ; minimumK ( arr , N , M ) ; } }"}
{"text": "Jumlah masa yang diperlukan untuk mengembara jalan yang dilambangkan oleh rentetan yang diberikan | Program Java untuk pendekatan di atas; Fungsi untuk mengira masa yang diambil untuk perjalanan jalan; Kedai jumlah masa; Kedudukan awal; Kedai -kedai melawat segmen; Semak sama ada segmen hadir dalam set; Meningkatkan nilai masa dengan 2; Masukkan segmen ke dalam set; Cetak nilai masa; Kod pemacu", "code": "import java . util . * ; class GFG { static void calcTotalTime ( String path ) { int time = 0 ; int x = 0 , y = 0 ; Set < String > s = new HashSet < > ( ) ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { int p = x ; int q = y ; if ( path . charAt ( i ) == ' N ' ) y ++ ; else if ( path . charAt ( i ) == ' S ' ) y -- ; else if ( path . charAt ( i ) == ' E ' ) x ++ ; else if ( path . charAt ( i ) == ' W ' ) x -- ; String o = ( p + x ) + \" ▁ \" + ( q + y ) ; if ( ! s . contains ( o ) ) { time += 2 ; s . add ( o ) ; } else time += 1 ; } System . out . println ( time ) ; } public static void main ( String [ ] args ) { String path = \" NSE \" ; calcTotalTime ( path ) ; } }"}
{"text": "Kos yang diperlukan untuk menjadikan semua elemen array sama dengan 1 | Program Java untuk pendekatan di atas; Fungsi untuk mengira kos yang diperlukan untuk membuat semua elemen array sama dengan 1; Menyimpan jumlah kos; Melintasi array arr []; Jika elemen semasa ialah 0; Tukar 0 hingga 1; Tambah kos; Mengembalikan jumlah kos; Kod pemacu", "code": "class GFG { static int findCost ( int [ ] A , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 , 0 } ; int N = arr . length ; System . out . println ( findCost ( arr , N ) ) ; } }"}
{"text": "Cari indeks puncak array yang diberikan | Program Java untuk pendekatan di atas; Fungsi untuk mencari indeks puncak untuk array yang diberikan; Kes asas; Semak array yang semakin meningkat; Sekiranya keadaan yang semakin meningkat dilanggar, maka pecah; Menyimpan nilai i, yang merupakan indeks puncak yang berpotensi; Traversal kedua, untuk array yang ketat; Apabila keadaan ketat yang dikurangkan dilanggar, kemudian pecah; Jika i = n - 1, ini bermakna bahawa ANS adalah indeks puncak; Jika tidak, indeks puncak tidak wujud; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { public static int peakIndex ( int [ ] arr ) { int N = arr . length ; if ( arr . length < 3 ) return - 1 ; int i = 0 ; while ( i + 1 < N ) { if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return - 1 ; int ans = i ; while ( i < N - 1 ) { if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == N - 1 ) return ans ; return - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 0 , 1 , 0 } ; System . out . println ( peakIndex ( arr ) ) ; } }"}
{"text": "Memandangkan array A [] dan nombor x, periksa pasangan dalam [] dengan jumlah sebagai x | Tetapkan 2 | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada array mempunyai 2 elemen yang jumlahnya sama dengan nilai yang diberikan; Menyusun array dalam peningkatan urutan; Melintasi array, nums []; Simpan nombor yang diperlukan untuk dijumpai; Melakukan carian binari; Simpan nilai pertengahan; Jika nums [mid] lebih besar daripada x, maka kemas kini tinggi hingga pertengahan - 1; Jika Nums [Mid] kurang daripada X, maka kemas kini rendah hingga pertengahan + 1; Jika tidak; Jika pertengahan adalah sama i, periksa pertengahan - 1 dan pertengahan + 1; Jika tidak, cetak pasangan dan kembali; Jika tidak ada pasangan yang dijumpai, maka cetak - 1; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void hasArrayTwoPairs ( int nums [ ] , int n , int target ) { Arrays . sort ( nums ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = target - nums [ i ] ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = low + ( ( high - low ) / 2 ) ; if ( nums [ mid ] > x ) { high = mid - 1 ; } else if ( nums [ mid ] < x ) { low = mid + 1 ; } else { if ( mid == i ) { if ( ( mid - 1 >= 0 ) && nums [ mid - 1 ] == x ) { System . out . print ( nums [ i ] + \" , ▁ \" ) ; System . out . print ( nums [ mid - 1 ] ) ; return ; } if ( ( mid + 1 < n ) && nums [ mid + 1 ] == x ) { System . out . print ( nums [ i ] + \" , ▁ \" ) ; System . out . print ( nums [ mid + 1 ] ) ; return ; } break ; } else { System . out . print ( nums [ i ] + \" , ▁ \" ) ; System . out . print ( nums [ mid ] ) ; return ; } } } } System . out . print ( - 1 ) ; } public static void main ( String [ ] args ) { int A [ ] = { 0 , - 1 , 2 , - 3 , 1 } ; int X = - 2 ; int N = A . length ; hasArrayTwoPairs ( A , N , X ) ; } }"}
{"text": "Pembahagi terkecil n paling dekat dengan x | Program Java untuk pendekatan di atas; Berfungsi untuk mencari pembahagi n paling dekat dengan sasaran; Berulang sehingga akar persegi n; Semak jika pembahagi adalah sama; Semak jika saya adalah yang paling dekat; Semak jika saya adalah yang paling dekat; Semak jika N / I adalah yang paling dekat; Cetak nilai terdekat; Kod pemacu; Diberikan N & X; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void findClosest ( int N , int target ) { int closest = - 1 ; int diff = Integer . MAX_VALUE ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( N / i == i ) { if ( Math . abs ( target - i ) < diff ) { diff = Math . abs ( target - i ) ; closest = i ; } } else { if ( Math . abs ( target - i ) < diff ) { diff = Math . abs ( target - i ) ; closest = i ; } if ( Math . abs ( target - N / i ) < diff ) { diff = Math . abs ( target - N / i ) ; closest = N / i ; } } } } System . out . println ( closest ) ; } public static void main ( String [ ] args ) { int N = 16 , X = 5 ; findClosest ( N , X ) ; } }"}
{"text": "Cari pasangan (a, b) seperti AA + BB = n | Program Java untuk pendekatan di atas; Fungsi untuk mengira kuasa minimum a dan b lebih besar daripada n; Menyimpan kuasa A yang lebih besar daripada n; Kiraan kenaikan sebanyak 1; Bahagikan n oleh A; Fungsi untuk mencari pasangan (a, b) sedemikian rupa sehingga a ^ a + b ^ b = n; Kirakan kuasa minimum yang lebih besar daripada n; Kirakan kuasa minimum B lebih besar daripada N; Buat salinan A dan B; Melintasi setiap pasangan (i, j); Semak jika B ^ j + a ^ i = n untuk mengatasi masalah limpahan Gunakan b = n - a bukan b + a = n; Kuasa kenaikan B oleh 1; Kuasa kenaikan A sebanyak 1; Akhirnya cetak - 1 jika tiada pasangan dijumpai; Kod pemacu; Diberikan A, B dan N; Panggilan fungsi", "code": "import java . io . * ; class GFG { static int power ( int A , int N ) { int count = 0 ; if ( A == 1 ) return 0 ; while ( N > 0 ) { count ++ ; N /= A ; } return count ; } static void Pairs ( int N , int A , int B ) { int powerA , powerB ; powerA = power ( A , N ) ; powerB = power ( B , N ) ; int intialB = B , intialA = A ; A = 1 ; for ( int i = 0 ; i <= powerA ; i ++ ) { B = 1 ; for ( int j = 0 ; j <= powerB ; j ++ ) { if ( B == N - A ) { System . out . println ( i + \" ▁ \" + j ) ; return ; } B *= intialB ; } A *= intialA ; } System . out . println ( \" - 1\" ) ; return ; } public static void main ( String args [ ] ) { int N = 106 , A = 3 , B = 5 ; Pairs ( N , A , B ) ; } }"}
{"text": "Mengira nombor dari julat tertentu yang tidak dapat dibahagikan oleh mana -mana elemen array | Program Java untuk pendekatan di atas; Berfungsi untuk mencari gandaan bukan sehingga k; Menyimpan semua gandaan yang unik; Melelehkan array; Untuk mencari pendua sekali sahaja; Memasukkan semua gandaan ke dalam set; Kembali hanya kiraan nombor yang tidak dapat dibahagikan oleh mana -mana elemen array; Berfungsi untuk mengira jumlah nilai dalam julat [l, r]; Mengira semua nilai dalam julat menggunakan prinsip pengecualian; Kod pemacu; Panggilan fungsi", "code": "import java . io . * ; import java . util . * ; class GFG { public static int findNonMultiples ( int [ ] arr , int n , int k ) { Set < Integer > multiples = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! multiples . contains ( arr [ i ] ) ) { for ( int j = 1 ; j <= k / arr [ i ] ; j ++ ) { multiples . add ( arr [ i ] * j ) ; } } } return k - multiples . size ( ) ; } public static int countValues ( int [ ] arr , int N , int L , int R ) { return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 } ; int N = arr . length ; int L = 1 ; int R = 20 ; System . out . println ( countValues ( arr , N , L , R ) ) ; } }"}
{"text": "Bilangan minimum duit syiling yang akan dikumpulkan setiap jam untuk mengosongkan n buasir di paling banyak jam | | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum duit syiling yang akan dikumpulkan setiap jam untuk mengosongkan n buasir dalam jam H; Menyimpan syiling minimum untuk dikeluarkan setiap jam; Cari elemen array maksimum; Melakukan carian binari; Simpan nilai pertengahan julat dalam k; Cari jumlah masa yang diambil untuk mengosongkan n buasir dengan mengeluarkan sy syiling sejam; Jika jumlah masa tidak melebihi h; Jika tidak; Cetak hasil yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void minCollectingSpeed ( int [ ] piles , int H ) { int ans = - 1 ; int low = 1 , high ; high = Arrays . stream ( piles ) . max ( ) . getAsInt ( ) ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; for ( int ai : piles ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } System . out . print ( ans ) ; } static public void main ( String args [ ] ) { int [ ] arr = { 3 , 6 , 7 , 11 } ; int H = 8 ; minCollectingSpeed ( arr , H ) ; } }"}
{"text": "Kira pasangan yang berbeza dengan jumlah yang diberikan | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mengira pasangan yang berbeza dalam array yang jumlahnya sama dengan k; Kedai kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Susun array; Kedai indeks penunjuk kiri; Kedai indeks penunjuk yang betul; Hitung kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Jika jumlah pasangan semasa adalah sama dengan k; Keluarkan elemen array duplikat berturut -turut; Kemas kini i; Keluarkan elemen array duplikat berturut -turut; Kemas kini j; Kemas kini CNTPairs; Kemas kini i; Kemas kini j; jika jumlah pasangan semasa kurang daripada k; Kemas kini i; Kemas kini j; Kod pemacu", "code": "import java . util . * ; class GFG { static int cntDisPairs ( int arr [ ] , int N , int K ) { int cntPairs = 0 ; Arrays . sort ( arr ) ; int i = 0 ; int j = N - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] == K ) { while ( i < j && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } while ( i < j && arr [ j ] == arr [ j - 1 ] ) { j -- ; } cntPairs += 1 ; i ++ ; j -- ; } else if ( arr [ i ] + arr [ j ] < K ) { i ++ ; } else { j -- ; } } return cntPairs ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = arr . length ; int K = 13 ; System . out . print ( cntDisPairs ( arr , N , K ) ) ; }"}
{"text": "Kira pasangan yang berbeza dengan jumlah yang diberikan | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mengira pasangan yang berbeza dalam array yang jumlahnya sama dengan k; Kedai kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Kekerapan kedai setiap elemen yang berbeza dari array; Kemas kini kekerapan ARR [i]; Melintasi peta; Menyimpan nilai utama peta; Jika saya adalah separuh daripada k; Jika kekerapan saya lebih besar daripada 1; Kemas kini CNTPairs; Kemas kini CNTPairs; Kod pemacu", "code": "import java . util . * ; class GFG { static int cntDisPairs ( int arr [ ] , int N , int K ) { int cntPairs = 0 ; HashMap < Integer , Integer > cntFre = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( cntFre . containsKey ( arr [ i ] ) ) cntFre . put ( arr [ i ] , cntFre . get ( arr [ i ] ) + 1 ) ; else cntFre . put ( arr [ i ] , 1 ) ; } for ( Map . Entry < Integer , Integer > it : cntFre . entrySet ( ) ) { int i = it . getKey ( ) ; if ( 2 * i == K ) { if ( cntFre . get ( i ) > 1 ) cntPairs += 2 ; } else { if ( cntFre . containsKey ( K - i ) ) { cntPairs += 1 ; } } } cntPairs = cntPairs / 2 ; return cntPairs ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = arr . length ; int K = 13 ; System . out . print ( cntDisPairs ( arr , N , K ) ) ; } }"}
{"text": "Pertanyaan untuk mencari seterusnya yang paling lama tidak mempunyai unsur bersebelahan yang sama dengan kemas kini | Program Java untuk pendekatan di atas; Berfungsi untuk mencari panjang seterusnya yang paling lama supaya tidak ada dua elemen bersebelahan yang sama; Gantikan elemen pada indeks x dengan y; Oleh kerana x adalah 1 - diindeks, penurunan x oleh 1; Jejaki bilangan elemen dalam masa depan; Jika elemen sebelumnya tidak sama dengan elemen semasa; Cetak kiraan yang dikehendaki; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ ] ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } System . out . print ( count + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = arr . length ; int Q = 2 ; int Queries [ ] [ ] = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; } }"}
{"text": "Pertanyaan untuk mencari seterusnya yang paling lama tidak mempunyai unsur bersebelahan yang sama dengan kemas kini | Program Java untuk pendekatan di atas; Melintasi array arr []; Jika elemen sebelumnya tidak sama dengan elemen semasa; Melintasi pertanyaan; Gantikan elemen pada indeks x dengan y; Mengira semula untuk Indeks X; Tolak sumbangan elemen pada indeks x; Tambah sumbangan y; Mengira semula untuk indeks x + 1; Tolak sumbangan elemen pada indeks x + 1; Menambah sumbangan y; Menggantikan elemen; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ ] ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } } for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; if ( x > 1 ) { if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; } if ( arr [ x - 2 ] != y ) { count += 1 ; } } if ( x < N ) { if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; } if ( y != arr [ x ] ) { count += 1 ; } } System . out . print ( count + \" ▁ \" ) ; arr [ x - 1 ] = y ; } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = arr . length ; int Q = 2 ; int Queries [ ] [ ] = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; } }"}
{"text": "Jumlah perbezaan mutlak indeks kejadian setiap elemen array | Program Java untuk pendekatan di atas; Fungsi untuk mencari jumlah perbezaan indeks kejadian setiap elemen array yang unik; Menyimpan indeks setiap elemen array; Simpan indeks; Menyimpan jumlahnya; Melintasi array; Cari jumlah untuk setiap elemen; Melangkah ke atas peta; Hitung jumlah kejadian ARR [i]; Simpan jumlah untuk elemen semasa; Cetak jawapan untuk setiap elemen; Kod pemacu; Diberikan array; Saiz yang diberikan; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void sum ( int arr [ ] , int n ) { HashMap < Integer , Vector < Integer > > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Vector < Integer > v = new Vector < > ( ) ; v . add ( i ) ; if ( mp . containsKey ( arr [ i ] ) ) v . addAll ( mp . get ( arr [ i ] ) ) ; mp . put ( arr [ i ] , v ) ; } int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int it : mp . get ( arr [ i ] ) ) { sum += Math . abs ( it - i ) ; } ans [ i ] = sum ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + \" ▁ \" ) ; } return ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 1 , 1 , 2 } ; int n = arr . length ; sum ( arr , n ) ; } }"}
{"text": "Tukar vokal ke dalam watak kes atas dalam rentetan yang diberikan | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk menukar vokal menjadi huruf besar; Menyimpan panjang str; Kod pemacu", "code": "import java . util . * ; class GFG { static void conVowUpp ( char [ ] str ) { int N = str . length ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { char c = Character . toUpperCase ( str [ i ] ) ; str [ i ] = c ; } } for ( char c : str ) System . out . print ( c ) ; } public static void main ( String [ ] args ) { String str = \" eutopia \" ; conVowUpp ( str . toCharArray ( ) ) ; } }"}
{"text": "Memaksimumkan bilangan hari yang mana c coklat boleh diedarkan secara berturut -turut kepada orang -orang n | Program Java untuk melaksanakan pendekatan di atas; Menyimpan kekerapan setiap jenis coklat; Fungsi untuk memeriksa sama ada coklat boleh dimakan untuk 'pertengahan' tidak. hari; Jika CNT melebihi n, kembali benar; Berfungsi untuk mencari bilangan maksimum hari yang mana coklat boleh dimakan; Simpan kekerapan setiap jenis coklat; Memulakan permulaan dan berakhir dengan 0 dan P masing -masing; Hitung pertengahan; Semak jika coklat boleh diedarkan selama pertengahan hari; Semak jika coklat boleh diedarkan selama lebih dari pertengahan hari berturut -turut; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; static int N , P ; static boolean helper ( int mid ) { int cnt = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int temp = i . getValue ( ) ; while ( temp >= mid ) { temp -= mid ; cnt ++ ; } } return cnt >= N ; } static int findMaximumDays ( int arr [ ] ) { for ( int i = 0 ; i < P ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int start = 0 , end = P , ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( mid != 0 && helper ( mid ) ) { ans = mid ; start = mid + 1 ; } else if ( mid == 0 ) { start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; } public static void main ( String [ ] args ) { N = 3 ; P = 10 ; int arr [ ] = { 1 , 2 , 2 , 1 , 1 , 3 , 3 , 3 , 2 , 4 } ; System . out . print ( findMaximumDays ( arr ) ) ; } }"}
{"text": "Count Subarrays yang mempunyai jumlah modulo k sama dengan panjang subarray | Program Java untuk pendekatan di atas; Fungsi yang mengira subarray yang mempunyai jumlah modulo k sama dengan panjang subarray; Menyimpan kiraan subarray; Kedai awalan jumlah array; Kirakan Array Jumlah Awalan; Menjana semua subarray; Semak sama ada subarray ini adalah subarray yang sah atau tidak; Jumlah kiraan subarray; Kod pemacu; Diberikan arr []; Saiz array; Diberikan k; Panggilan fungsi", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void countSubarrays ( int a [ ] , int n , int k ) { int ans = 0 ; ArrayList < Integer > pref = new ArrayList < > ( ) ; pref . add ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . add ( ( a [ i ] + pref . get ( i ) ) % k ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( ( pref . get ( j ) - pref . get ( i - 1 ) + k ) % k == j - i + 1 ) { ans ++ ; } } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) throws java . lang . Exception { int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = arr . length ; int K = 4 ; countSubarrays ( arr , N , K ) ; } }"}
{"text": "Count Subarrays yang mempunyai jumlah modulo k sama dengan panjang subarray | Program Java untuk pendekatan di atas; Fungsi yang mengira subarray yang mempunyai jumlah modulo k sama dengan panjang subarray; Menyimpan kiraan (pref [i] - i) % k; Menyimpan kiraan subarray; Kedai awalan jumlah array; Cari Array Jumlah Awalan; Keadaan asas; Keluarkan indeks pada masa ini selepas indeks k dari indeks semasa; Kemas kini jawapan untuk subarrays yang berakhir pada indeks i - th; Tambah nilai yang dikira indeks semasa untuk dikira; Cetak kiraan subarray; Kod pemacu; Diberikan arr []; Saiz array; Diberikan k; Panggilan fungsi", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void countSubarrays ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > cnt = new HashMap < > ( ) ; long ans = 0 ; ArrayList < Integer > pref = new ArrayList < > ( ) ; pref . add ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . add ( ( a [ i ] + pref . get ( i ) ) % k ) ; cnt . put ( 0 , 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) { int remIdx = i - k ; if ( remIdx >= 0 ) { if ( cnt . containsKey ( ( pref . get ( remIdx ) - remIdx % k + k ) % k ) ) cnt . put ( ( pref . get ( remIdx ) - remIdx % k + k ) % k , cnt . get ( ( pref . get ( remIdx ) - remIdx % k + k ) % k ) - 1 ) ; else cnt . put ( ( pref . get ( remIdx ) - remIdx % k + k ) % k , - 1 ) ; } if ( cnt . containsKey ( ( pref . get ( i ) - i % k + k ) % k ) ) ans += cnt . get ( ( pref . get ( i ) - i % k + k ) % k ) ; if ( cnt . containsKey ( ( pref . get ( i ) - i % k + k ) % k ) ) cnt . put ( ( pref . get ( i ) - i % k + k ) % k , cnt . get ( ( pref . get ( i ) - i % k + k ) % k ) + 1 ) ; else cnt . put ( ( pref . get ( i ) - i % k + k ) % k , 1 ) ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) throws java . lang . Exception { int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = arr . length ; int K = 4 ; countSubarrays ( arr , N , K ) ; } }"}
{"text": "Semak jika semua substring panjang k dari rentetan binari mempunyai kiraan yang sama dengan 0 s dan 1 s | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada substring panjang k mempunyai sama 0 dan 1; Melintasi rentetan; Semak sama ada setiap watak k - th adalah sama atau tidak; Melintasi substring panjang k; Jika watak semasa adalah 0; Kiraan kenaikan; Jika tidak; Kiraan pengurangan; Semak sama 0 s dan 1 s; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean check ( String s , int k ) { int n = s . length ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s . charAt ( i ) != s . charAt ( j ) ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s . charAt ( i ) == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { String s = \"101010\" ; int k = 2 ; if ( check ( s , k ) ) System . out . print ( \" Yes \" + \"NEW_LINE\"); else System . out . print ( \" No \" + \"NEW_LINE\"); } }"}
{"text": "Semak jika watak -watak rentetan yang diberikan boleh digunakan untuk membentuk sebarang rentetan yang sama | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada freq dari mana -mana watak boleh dibahagikan dengan n; Menyimpan kekerapan aksara; Jika kekerapan watak tidak dapat dibahagikan dengan n; Jika tiada watak mempunyai kekerapan sekurang -kurangnya n; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static boolean isSame ( String str , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( mp . containsKey ( str . charAt ( i ) - ' a ' ) ) { mp . put ( str . charAt ( i ) - ' a ' , mp . get ( str . charAt ( i ) - ' a ' ) + 1 ) ; } else { mp . put ( str . charAt ( i ) - ' a ' , 1 ) ; } } for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { if ( ( it . getValue ( ) ) >= n ) { return true ; } } return false ; } public static void main ( String [ ] args ) { String str = \" ccabcba \" ; int n = 4 ; if ( isSame ( str , n ) ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } }"}
{"text": "Cari akar fungsi yang tidak berkurangan antara a dan b | Program Java untuk pendekatan di atas; Fungsi yang diberikan; Fungsi untuk mencari akar fungsi yang tidak berkurangan; Untuk mendapatkan jawapan minimum yang mungkin untuk akar; Cari pertengahan; Cari di [rendah, x]; Cari di [x, tinggi]; Mengembalikan jawapan yang diperlukan; Berfungsi untuk mencari akar persamaan yang diberikan dalam julat [a, b]; Jika akar tidak wujud; Lain mencari akar sehingga 4 tempat perpuluhan; Kod pemacu; Julat yang diberikan; Panggilan fungsi", "code": "import java . util . * ; import java . lang . * ; class GFG { static final double eps = 1e-6 ; static double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; } static double findRoot ( double a , double b , double c , double low , double high ) { double x = - 1 ; while ( Math . abs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; } static void solve ( double a , double b , double c , double A , double B ) { if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) { System . out . println ( \" No ▁ solution \" ) ; } else { System . out . format ( \" % .4f \" , findRoot ( a , b , c , A , B ) ) ; } } public static void main ( String [ ] args ) { double a = 2 , b = - 3 , c = - 2 , A = 0 , B = 3 ; solve ( a , b , c , A , B ) ; } }"}
{"text": "Median perbezaan semua pasangan dari array | Program Java untuk melaksanakan pendekatan di atas; Pemeriksaan fungsi jika pertengahan boleh menjadi indeks median pelbagai perbezaan; Saiz array; Jumlah mungkin tidak ada pasangan yang mungkin; Indeks elemen dalam perbezaan semua pasangan dari array; Kira bilangan pasangan yang mempunyai perbezaan <= MID; Jika perbezaan antara akhir dan elemen pertama kurang atau sama dengan pertengahan; Memeriksa unsur tidak kurang daripada atau sama dengan pertengahan adalah lebih besar daripada median atau tidak; Fungsi untuk mengira median perbezaan semua pasangan dari array; Saiz array; Memulakan yang rendah dan tinggi; Carian binari; Hitung pertengahan; Jika pertengahan boleh menjadi median array; Mengembalikan median perbezaan pasangan dari array; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean possible ( long mid , int [ ] a ) { long n = a . length ; long total = ( n * ( n - 1 ) ) / 2 ; long need = ( total + 1 ) / 2 ; long count = 0 ; long start = 0 , end = 1 ; while ( end < n ) { if ( a [ ( int ) end ] - a [ ( int ) start ] <= mid ) { end ++ ; } else { count += ( end - start - 1 ) ; start ++ ; } } if ( end == n && start < end && a [ ( int ) end - 1 ] - a [ ( int ) start ] <= mid ) { long t = end - start - 1 ; count += ( t * ( t + 1 ) / 2 ) ; } if ( count >= need ) return true ; else return false ; } static long findMedian ( int [ ] a ) { long n = a . length ; long low = 0 , high = a [ ( int ) n - 1 ] - a [ 0 ] ; while ( low <= high ) { long mid = ( low + high ) / 2 ; if ( possible ( mid , a ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 7 , 5 , 2 } ; Arrays . sort ( a ) ; System . out . println ( findMedian ( a ) ) ; } }"}
{"text": "Cetak semua rentetan dari array a [] mempunyai semua rentetan dari array b [] sebagai berikutnya | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari rentetan dari [] mempunyai semua rentetan dalam b [] sebagai seterusnya; Hitung saiz masing -masing; Menyimpan jawapannya; Menyimpan kekerapan setiap watak dalam rentetan []; Kirakan frekuensi watak semua rentetan; Menyimpan kekerapan setiap aksara dalam rentetan b [] setiap watak rentetan dalam b []; Jika kekerapan watak dalam b [] melebihi itu dalam []; Rentetan wujud dalam B [] yang bukan subset yang betul dari [i]; Jika semua rentetan dalam b [] adalah subset yang betul dari []; Tolak rentetan dalam vektor yang dihasilkan; Jika ada rentetan yang dijumpai; Cetak rentetan itu; Jika tidak; Kod pemacu", "code": "import java . util . * ; class GFG { static void UniversalSubset ( List < String > A , List < String > B ) { int n1 = A . size ( ) ; int n2 = B . size ( ) ; List < String > res = new ArrayList < > ( ) ; int [ ] [ ] A_fre = new int [ n1 ] [ 26 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) A_fre [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < A . get ( i ) . length ( ) ; j ++ ) { A_fre [ i ] [ A . get ( i ) . charAt ( j ) - ' a ' ] ++ ; } } int [ ] B_fre = new int [ 26 ] ; for ( int i = 0 ; i < n2 ; i ++ ) { int [ ] arr = new int [ 26 ] ; for ( int j = 0 ; j < B . get ( i ) . length ( ) ; j ++ ) { arr [ B . get ( i ) . charAt ( j ) - ' a ' ] ++ ; B_fre [ B . get ( i ) . charAt ( j ) - ' a ' ] = Math . max ( B_fre [ B . get ( i ) . charAt ( j ) - ' a ' ] , arr [ B . get ( i ) . charAt ( j ) - ' a ' ] ) ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( A_fre [ i ] [ j ] < B_fre [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) res . add ( A . get ( i ) ) ; } if ( res . size ( ) != 0 ) { for ( int i = 0 ; i < res . size ( ) ; i ++ ) { for ( int j = 0 ; j < res . get ( i ) . length ( ) ; j ++ ) System . out . print ( res . get ( i ) . charAt ( j ) ) ; } System . out . print ( \" ▁ \" ) ; } else System . out . print ( \" - 1\" ) ; } public static void main ( String [ ] args ) { List < String > A = Arrays . asList ( \" geeksforgeeks \" , \" topcoder \" , \" leetcode \" ) ; List < String > B = Arrays . asList ( \" geek \" , \" ee \" ) ; UniversalSubset ( A , B ) ; } }"}
{"text": "Pasangan terdekat dalam array supaya satu nombor adalah pelbagai yang lain | Program Java untuk pendekatan di atas; Berfungsi untuk mencari pasangan jarak minimum di mana seseorang adalah pelbagai yang lain; Memulakan pembolehubah; Melangkah untuk semua elemen; Gelung untuk membuat pasangan; Semak jarak minimum; Semak jika seseorang adalah pelbagai yang lain; Mengemas kini jarak; Indeks kedai; Jika tidak ada pasangan seperti itu; Cetak jawapannya; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "import java . util . * ; class GFG { public static void findPair ( int a [ ] , int n ) { int min_dist = Integer . MAX_VALUE ; int index_a = - 1 , index_b = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( j - i < min_dist ) { if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) { min_dist = j - i ; index_a = i ; index_b = j ; } } } } if ( index_a == - 1 ) { System . out . println ( \" - 1\" ) ; } else { System . out . print ( \" ( \" + a [ index_a ] + \" , ▁ \" + a [ index_b ] + \" ) \" ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = a . length ; findPair ( a , n ) ; } }"}
{"text": "Cetak semua nombor dalam julat yang diberikan dengan digit dalam perintah yang semakin meningkat | Program Java untuk pendekatan di atas; Berfungsi untuk mencetak semua nombor dalam julat [l, r] yang mempunyai digit dalam urutan yang semakin meningkat; Melangkah ke atas julat; Melangkah ke atas digit; Semak sama ada digit semasa adalah> = digit sebelumnya; Sekiranya digit berada dalam urutan menaik; Kod pemacu; Diberikan julat l dan r; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) System . out . print ( i + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int L = 10 , R = 15 ; printNum ( L , R ) ; } }"}
{"text": "Cari nombor yang hilang dalam perkembangan aritmetik yang tidak teratur | Program Java untuk pendekatan di atas; Fungsi untuk mencari elemen yang hilang; Betulkan sempadan kiri dan kanan untuk carian binari; Cari Indeks Elemen Tengah; Semak jika elemen hanya selepas elemen tengah hilang; Semak jika elemen sebelum pertengahan hilang; Semak jika unsur -unsur sehingga pertengahan mengikuti AP, kemudian berulang untuk separuh kanan; Lain berulang untuk separuh kiri; Berfungsi untuk mencari elemen yang hilang dalam siri AP; Susun array arr []; Mengira perbezaan biasa; Pencarian binari untuk yang hilang; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "import java . util . Arrays ; class GFG { static int findMissing ( int arr [ ] , int left , int right , int diff ) { if ( right <= left ) return 0 ; int mid = left + ( right - left ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ; return findMissing ( arr , left , mid - 1 , diff ) ; } static int missingElement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return findMissing ( arr , 0 , n - 1 , diff ) ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 2 , 8 , 6 , 10 } ; int n = arr . length ; System . out . println ( missingElement ( arr , n ) ) ; } }"}
{"text": "Nilai lantai kth akar nombor menggunakan carian binari rekursif | Program Java untuk pendekatan di atas; Berfungsi untuk mengira x yang dibangkitkan kepada kuasa y dalam o (logn); Berfungsi untuk mencari akar kth nombor n menggunakan BS; Sekiranya julat masih sah; Cari nilai pertengahan julat; Kes asas; Keadaan untuk memeriksa sama ada ruang carian kiri tidak berguna; Kod pemacu; Diberikan n dan k; Panggilan fungsi", "code": "class GFG { static int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; } static int nthRootSearch ( int low , int high , int N , int K ) { if ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( power ( mid , K ) <= N ) && ( power ( mid + 1 , K ) > N ) ) { return mid ; } else if ( power ( mid , K ) < N ) { return nthRootSearch ( mid + 1 , high , N , K ) ; } else { return nthRootSearch ( low , mid - 1 , N , K ) ; } } return low ; } public static void main ( String s [ ] ) { int N = 16 , K = 4 ; System . out . println ( nthRootSearch ( 0 , N , N , K ) ) ; } }"}
{"text": "Count subset yang mempunyai jumlah elemen min dan max kurang daripada k | Program Java untuk mencetak kiraan subset s seperti matematik. Min (s) + matematik. max (s) <k; Fungsi yang mengembalikan kiraan subset sedemikian rupa sehingga matematik. Min (s) + matematik. max (s) <k; Menyusun array; Ans menyimpan jumlah subset; Tambah semua subset yang mungkin antara I dan J; Mengurangkan jumlah; Kod pemacu", "code": "import java . util . * ; class GFG { static int get_subset_count ( int arr [ ] , int K , int N ) { Arrays . sort ( arr ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 5 , 7 } ; int K = 8 ; int N = arr . length ; System . out . print ( get_subset_count ( arr , K , N ) ) ; } }"}
{"text": "Kurangkan perbezaan maksimum unsur -unsur bersebelahan selepas kebanyakan sisipan k | Program Java untuk mencari perbezaan maksimum maksimum antara unsur -unsur bersebelahan selepas kebanyakan penyisipan K; Kirakan perbezaan bersebelahan maksimum; Jika perbezaan bersebelahan maksimum sudah sifar; Terbaik dan terburuk menentukan pelbagai perbezaan bersebelahan maksimum; Untuk menyimpan tidak ada sisipan yang diperlukan untuk nilai masing -masing MID; Jika bilangan sisipan diperlukan melebihi k; Jika tidak; Kod pemacu", "code": "import java . util . * ; class GFG { static int minMaxDiff ( int arr [ ] , int n , int k ) { int max_adj_dif = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = Math . max ( max_adj_dif , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; if ( max_adj_dif == 0 ) return 0 ; int best = 1 ; int worst = max_adj_dif ; int mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ; required = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { required += ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ; } if ( required > k ) best = mid + 1 ; else worst = mid ; } return worst ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 12 , 25 , 50 } ; int n = arr . length ; int k = 7 ; System . out . println ( minMaxDiff ( arr , n , k ) ) ; } }"}
{"text": "Semak jika elemen minimum dalam array kurang daripada atau sama dengan separuh daripada setiap elemen lain | Pelaksanaan Java untuk memeriksa sama ada elemen minimum dalam array adalah lebih besar daripada atau sama dengan separuh daripada setiap elemen lain; Fungsi untuk memeriksa sama ada elemen minimum dalam array adalah lebih besar daripada atau sama dengan separuh daripada setiap elemen lain; Memulakan pembolehubah untuk menyimpan terkecil terkecil dan kedua terkecil; Semak jika elemen semasa lebih kecil daripada yang terkecil, terkecil semasa akan menjadi unsur detik paling teruk dan semasa akan menjadi yang terkecil baru; Semak jika elemen semasa lebih kecil daripada saat yang paling kecil hanya mengemas kini yang terakhir; Kod pemacu", "code": "import java . util . * ; class GFG { static void checkMin ( int arr [ ] , int len ) { int smallest = Integer . MAX_VALUE ; int secondSmallest = Integer . MAX_VALUE ; for ( int i = 0 ; i < len ; i ++ ) { if ( arr [ i ] < smallest ) { secondSmallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] < secondSmallest ) { secondSmallest = arr [ i ] ; } } if ( 2 * smallest <= secondSmallest ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int len = arr . length ; checkMin ( arr , len ) ; } }"}
{"text": "Nombor fibonacci terbesar dan terkecil dalam array | Program Java untuk mencari nombor Fibonacci minimum dan maksimum dalam array yang diberikan; Fungsi untuk membuat jadual hash untuk memeriksa nombor Fibonacci; Masukkan dua nombor awal dalam jadual hash; Jumlah dua nombor sebelumnya; Kemas kini pembolehubah setiap kali; Berfungsi untuk mencari nombor fibonacci minimum dan maksimum dalam array yang diberikan; Cari nilai maksimum dalam array; Mewujudkan satu set yang mengandungi semua nombor Fibonacci sehingga nilai maksimum dalam array; Untuk menyimpan nombor Fibonacci minimum dan maksimum; Semak jika elemen semasa adalah nombor Fibonacci; Mengemas kini maksimum dan minimum yang sewajarnya; Kod pemacu", "code": "import java . util . * ; class GFG { static void createHash ( HashSet < Integer > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } } static void fibonacci ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; HashSet < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , max_val ) ; int minimum = Integer . MAX_VALUE ; int maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . contains ( arr [ i ] ) ) { minimum = Math . min ( minimum , arr [ i ] ) ; maximum = Math . max ( maximum , arr [ i ] ) ; } } System . out . print ( minimum + \" , ▁ \" + maximum + \"NEW_LINE\"); } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; fibonacci ( arr , n ) ; } }"}
{"text": "Substring terpanjang dengan K aksara unik menggunakan carian binari | Pelaksanaan Java pendekatan; Fungsi yang mengembalikan benar jika terdapat substring panjang len dengan <= k aksara unik; Saiz rentetan; Peta untuk menyimpan watak dan kekerapannya; Kemas kini peta untuk substring pertama; Periksa selebihnya substrings; Tambah watak baru; Keluarkan watak pertama tetingkap sebelumnya; Kemas kini peta; Berfungsi untuk mengembalikan panjang substring terpanjang yang mempunyai aksara unik K; Semak sama ada rentetan lengkap mengandungi aksara unik K; Saiz rentetan; Memohon carian binari; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean isValidLen ( String s , int len , int k ) { int n = s . length ( ) ; Map < Character , Integer > mp = new HashMap < Character , Integer > ( ) ; int right = 0 ; while ( right < len ) { if ( mp . containsKey ( s . charAt ( right ) ) ) { mp . put ( s . charAt ( right ) , mp . get ( s . charAt ( right ) ) + 1 ) ; } else { mp . put ( s . charAt ( right ) , 1 ) ; } right ++ ; } if ( mp . size ( ) <= k ) return true ; while ( right < n ) { if ( mp . containsKey ( s . charAt ( right ) ) ) { mp . put ( s . charAt ( right ) , mp . get ( s . charAt ( right ) ) + 1 ) ; } else { mp . put ( s . charAt ( right ) , 1 ) ; } if ( mp . containsKey ( s . charAt ( right - len ) ) ) { mp . put ( s . charAt ( right - len ) , mp . get ( s . charAt ( right - len ) ) - 1 ) ; } if ( mp . get ( s . charAt ( right - len ) ) == 0 ) mp . remove ( s . charAt ( right - len ) ) ; if ( mp . size ( ) <= k ) return true ; right ++ ; } return mp . size ( ) <= k ; } static int maxLenSubStr ( String s , int k ) { Set < Character > uni = new HashSet < Character > ( ) ; for ( Character x : s . toCharArray ( ) ) uni . add ( x ) ; if ( uni . size ( ) < k ) return - 1 ; int n = s . length ( ) ; int lo = - 1 , hi = n + 1 ; while ( hi - lo > 1 ) { int mid = lo + hi >> 1 ; if ( isValidLen ( s , mid , k ) ) lo = mid ; else hi = mid ; } return lo ; } public static void main ( String [ ] args ) { String s = \" aabacbebebe \" ; int k = 3 ; System . out . print ( maxLenSubStr ( s , k ) ) ; } }"}
{"text": "Dataran Kawasan Terbesar di Array Apabila Elemen Boleh Dipandu | Pelaksanaan Java pendekatan; Fungsi yang mengembalikan benar jika mungkin untuk membuat persegi dengan sisi sama dengan L; Untuk menyimpan kiraan elemen yang lebih besar daripada atau sama dengan L; Kenaikan kiraan; Jika kiraan menjadi lebih besar daripada atau sama dengan L; Berfungsi untuk mengembalikan kawasan maksimum dataran yang boleh diperolehi; Jika persegi mungkin dengan panjang sisi m; Cuba cari persegi dengan panjang sampingan yang lebih kecil; Mengembalikan kawasan itu; Kod pemacu", "code": "class GFG { static boolean isSquarePossible ( int arr [ ] , int n , int l ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= l ) cnt ++ ; if ( cnt >= l ) return true ; } return false ; } static int maxArea ( int arr [ ] , int n ) { int l = 0 , r = n ; int len = 0 ; while ( l <= r ) { int m = l + ( ( r - l ) / 2 ) ; if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; } else r = m - 1 ; } return ( len * len ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int n = arr . length ; System . out . println ( maxArea ( arr , n ) ) ; } }"}
{"text": "Semak pendua dalam aliran rentetan | Pelaksanaan Java pendekatan; Fungsi untuk memasukkan nama dan periksa sama ada ia muncul untuk kali pertama; Untuk menyimpan nama pekerja; Jika nama semasa muncul untuk kali pertama; Kod pemacu", "code": "import java . util . * ; class GFG { static void insertNames ( String arr [ ] , int n ) { HashSet < String > set = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! set . contains ( arr [ i ] ) ) { System . out . print ( \"NoNEW_LINE\"); set . add ( arr [ i ] ) ; } else { System . out . print ( \"YesNEW_LINE\"); } } } public static void main ( String [ ] args ) { String arr [ ] = { \" geeks \" , \" for \" , \" geeks \" } ; int n = arr . length ; insertNames ( arr , n ) ; } }"}
{"text": "Kira tiga kali ganda supaya A [i] <b [j] <c [k] | Pelaksanaan Java pendekatan; Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang kurang daripada kunci yang diberikan; Carian binari yang diubah suai; Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang lebih besar daripada kunci yang diberikan; Carian binari yang diubah suai; Berfungsi untuk mengembalikan kiraan tiga kali ganda yang diperlukan; Menyusun ketiga -tiga tatasusunan; Melangkah untuk semua elemen array b; Kiraan elemen dalam [] yang kurang daripada elemen yang dipilih dari B []; Kiraan unsur -unsur dalam C [] yang lebih besar daripada elemen yang dipilih dari B []; Mengemas kini kiraan; Kod pemacu", "code": "import java . util . * ; class GFG { static int countLessThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; } static int countGreaterThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == - 1 ) return 0 ; return ( n - index ) ; } static int countTriplets ( int n , int a [ ] , int b [ ] , int c [ ] ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; Arrays . sort ( c ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ; int low = countLessThan ( a , n , current ) ; int high = countGreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 5 } ; int b [ ] = { 2 , 4 } ; int c [ ] = { 3 , 6 } ; int size = a . length ; System . out . println ( countTriplets ( size , a , b , c ) ) ; } }"}
{"text": "Kos untuk mengimbangi kurungan | Kod Java untuk mengira kos minimum untuk membuat tanda kurung yang diberikan seimbang; Untuk menyimpan kiraan mutlak kurungan yang seimbang dan tidak seimbang; o (pendakap terbuka) menyimpan kiraan '(' dan c (pendakap dekat) kiraan ')'; Kod pemacu", "code": "import java . io . * ; class GFG { static int costToBalance ( String s ) { if ( s . length ( ) == 0 ) System . out . println ( 0 ) ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) o ++ ; if ( s . charAt ( i ) == ' ) ' ) c ++ ; } if ( o != c ) return - 1 ; int [ ] a = new int [ s . length ( ) ] ; if ( s . charAt ( 0 ) == ' ( ' ) a [ 0 ] = 1 ; else a [ 0 ] = - 1 ; if ( a [ 0 ] < 0 ) ans += Math . abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += Math . abs ( a [ i ] ) ; } return ans ; } public static void main ( String args [ ] ) { String s ; s = \" ) ) ) ( ( ( \" ; System . out . println ( costToBalance ( s ) ) ; s = \" ) ) ( ( \" ; System . out . println ( costToBalance ( s ) ) ; } }"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Program Java untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; x adalah positif jika a lebih besar daripada b. x adalah negatif jika b lebih besar daripada a. ; Sama seperti x; Sama seperti x dan y. ; Memeriksa jika B adalah tengah (X dan Y kedua -duanya adalah positif); Memeriksa jika C adalah tengah (x dan z kedua -duanya positif); kod pemacu", "code": "import java . util . * ; class Middle { public static int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; } public static void main ( String [ ] args ) { int a = 20 , b = 30 , c = 40 ; System . out . println ( middleOfThree ( a , b , c ) ) ; } }"}
{"text": "Cari empat nombor yang hilang dalam array yang mengandungi elemen dari 1 hingga n | Program Java untuk mencari 4 elemen yang hilang dalam pelbagai saiz n di mana unsur -unsur berada dalam jarak dari 1 hingga n + 4 .; Menemukan 4 nombor dalam O (n) masa dan O (1) ruang tambahan. ; Untuk menjejaki 4 nombor yang mungkin lebih besar daripada panjang input di Java, penolong secara automatik diasaskan sebagai 0 .; Melintasi array input dan menandakan unsur -unsur yang dilawati sama ada dengan menandakan mereka sebagai negatif dalam arr [] atau dalam pembantu []. ; Jika elemen lebih kecil daripada atau sama dengan panjang, tandakan kehadirannya di arr []; Mark kehadiran dalam pembantu []; Cetak semua elemen yang kehadirannya tidak ditandakan. ; Kod pemacu", "code": "class Missing4 { public static void missing4 ( int [ ] arr ) { int [ ] helper = new int [ 4 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { int temp = Math . abs ( arr [ i ] ) ; if ( temp <= arr . length ) arr [ temp - 1 ] *= ( - 1 ) ; else if ( temp > arr . length ) { if ( temp % arr . length != 0 ) helper [ temp % arr . length - 1 ] = - 1 ; else helper [ ( temp % arr . length ) + arr . length - 1 ] = - 1 ; } } for ( int i = 0 ; i < arr . length ; i ++ ) if ( arr [ i ] > 0 ) System . out . print ( i + 1 + \" ▁ \" ) ; for ( int i = 0 ; i < helper . length ; i ++ ) if ( helper [ i ] >= 0 ) System . out . print ( arr . length + i + 1 + \" ▁ \" ) ; return ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 7 , 3 , 12 , 5 , 10 , 8 , 4 , 9 } ; missing4 ( arr ) ; } }"}
{"text": "Permutasi yang hadir di tengah -tengah pesanan leksikografi permutasi paling panjang n yang terdiri daripada bilangan bulat sehingga k | Program Java untuk pendekatan di atas; Fungsi yang menemui tengah -tengah urutan terkecil leksikografi; Jika k ada; Elemen pertama ialah K / 2; Unsur -unsur yang tersisa dari urutan adalah semua integer k; Menyimpan urutan apabila k adalah ganjil; Melangkah ke atas julat [0, n / 2]; Semak sama ada urutan berakhir dengan 1 atau tidak; Keluarkan urutan yang berakhir dalam 1; Sekiranya ia tidak berakhir dalam 1; Penurunan sebanyak 1; Masukkan k ke urutan sehingga saiznya adalah n; Cetak urutan yang disimpan dalam vektor; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static void lexiMiddleSmallest ( int K , int N ) { if ( K % 2 == 0 ) { System . out . print ( K / 2 + \" ▁ \" ) ; for ( int i = 0 ; i < N - 1 ; ++ i ) { System . out . print ( K + \" ▁ \" ) ; } System . out . println ( ) ; return ; } ArrayList < Integer > a = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < N / 2 ; ++ i ) { if ( a . get ( a . size ( ) - 1 ) == 1 ) { a . remove ( a . size ( ) - 1 ) ; } else { int t = a . get ( a . size ( ) - 1 ) - 1 ; a . set ( a . get ( a . size ( ) - 1 ) , t ) ; while ( a . size ( ) < N ) { a . add ( K ) ; } } } for ( int i : a ) { System . out . print ( i + \" ▁ \" ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int K = 2 , N = 4 ; lexiMiddleSmallest ( K , N ) ; } }"}
{"text": "Elemen array yang tinggal selepas penyingkiran elemen terkecil dari pasangan dengan perbezaan mutlak 2 atau 0 | Program Java untuk pendekatan di atas; Berfungsi untuk mencari elemen array yang terakhir selepas berulang kali mengeluarkan terkecil dari pasangan yang mempunyai perbezaan mutlak 2 atau 0; Susun array yang diberikan dalam urutan menaik; Melintasi array; Jika perbezaan antara unsur -unsur bersebelahan tidak sama dengan 0 atau 2; Jika operasi boleh dilakukan; Kod pemacu", "code": "import java . util . * ; class GFG { static void findLastElement ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { System . out . println ( \" - 1\" ) ; return ; } } System . out . println ( arr [ N - 1 ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 0 , 8 } ; int N = arr . length ; findLastElement ( arr , N ) ; } }"}
{"text": "Memaksimumkan kiraan subset ke mana array yang diberikan dapat dibahagikan sehingga ia memenuhi syarat yang diberikan | Program Java untuk pendekatan di atas; Fungsi untuk mengira subset maksimum ke mana array yang diberikan dapat dibahagikan sehingga ia memenuhi syarat yang diberikan; Susun array dalam penurunan urutan; Kedai -kedai Count Subset mungkin; Kedai mengira unsur -unsur dalam subset semasa; Melintasi array arr []; Saiz kemas kini; Jika produk elemen terkecil yang terdapat dalam subset semasa dan saiz subset semasa ialah> = k; Kemas kini MaxSub; Saiz kemas kini; Kod pemacu; Diberikan array; Saiz array; Diberi nilai x", "code": "import java . util . * ; class GFG { static void maxDivisions ( Integer arr [ ] , int N , int X ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int maxSub = 0 ; int size = 0 ; for ( int i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } System . out . print ( maxSub + \"NEW_LINE\"); } public static void main ( String [ ] args ) { Integer arr [ ] = { 1 , 3 , 3 , 7 } ; int N = arr . length ; int X = 3 ; maxDivisions ( arr , N , X ) ; } }"}
{"text": "Memaksimumkan jumlah minimum kedua dalam semua empat kali ganda dari array yang diberikan | Program Java untuk pendekatan di atas; Berfungsi untuk mencari jumlah maksimum minimum minimum kedua dalam setiap empat kali ganda; Susun array; Tambah minimum kedua; Cetak jumlah maksimum yang mungkin; Kod pemacu; Diberikan array; Saiz array", "code": "import java . io . * ; import java . util . * ; class GFG { public static void maxPossibleSum ( int [ ] arr , int N ) { Arrays . sort ( arr ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } System . out . println ( sum ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 } ; int N = arr . length ; maxPossibleSum ( arr , N ) ; } }"}
{"text": "Perbezaan antara jenis penyisipan dan pilihan pemilihan | Program Java untuk pendekatan di atas; Berfungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci kepada satu kedudukan di hadapan kedudukan semasa mereka; Berfungsi untuk mencetak pelbagai saiz n; Cetak array; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } static void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + \" ▁ \" ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int N = arr . length ; insertionSort ( arr , N ) ; printArray ( arr , N ) ; } }"}
{"text": "Kiraan pasangan (i, j) dari array yang diberikan supaya saya k * arr [j] | Program Java untuk pendekatan di atas; Fungsi untuk mencari kiraan pasangan yang diperlukan; Kedai kiraan pasangan; Melintasi array; Periksa sama ada keadaan itu berpuas hati atau tidak; Kod pemacu; Panggilan fungsi", "code": "class GFG { static void getPairs ( int arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } System . out . print ( count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 2 , 1 } ; int N = arr . length ; int K = 2 ; getPairs ( arr , N , K ) ; } }"}
{"text": "Kiraan pasangan (i, j) dari array yang diberikan supaya saya k * arr [j] | Program Java untuk pendekatan di atas; Berfungsi untuk menggabungkan dua susunan yang disusun; i: indeks ke subarray kiri; J: Indeks ke Subarray Kanan; Kedai kiraan pasangan yang memenuhi syarat yang diberikan; Melintasi untuk memeriksa keadaan yang sah; Jika keadaan memenuhi; Semua elemen di sebelah kanan subarray kiri juga memuaskan; Susun dua tatasusunan yang diberikan dan simpan dalam array yang dihasilkan; Unsur -unsur yang tersisa di subarray kiri; Unsur -unsur yang tersisa di subarray kanan; Mengembalikan kiraan yang diperoleh; Berfungsi untuk memisahkan array menjadi dua bahagian; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Hubungi fungsi penggabungan; Berfungsi untuk mencetak kiraan pasangan yang diperlukan menggunakan jenis gabungan; Kod pemacu; Panggilan fungsi", "code": "class GFG { static int merge ( int arr [ ] , int temp [ ] , int l , int m , int r , int K ) { int i = l ; int j = m + 1 ; int cnt = 0 ; for ( i = l ; i <= m ; i ++ ) { boolean found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found == true ) { cnt += j - ( m + 1 ) ; j -- ; } } int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; } static int mergeSortUtil ( int arr [ ] , int temp [ ] , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) { int m = ( l + r ) / 2 ; cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; } static void mergeSort ( int arr [ ] , int N , int K ) { int temp [ ] = new int [ N ] ; System . out . print ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 2 , 5 } ; int N = arr . length ; int K = 2 ; mergeSort ( arr , N , K ) ; } }"}
{"text": "Kurangkan penyingkiran berturut -turut unsur -unsur jenis yang sama untuk kosong yang diberikan | Pelaksanaan Java pendekatan di atas; Fungsi untuk mengira penyingkiran minimum berturut -turut unsur -unsur jenis yang sama; Susun array; Menyimpan elemen maksimum yang terdapat dalam array; Kedai jumlah array; Hitung jumlah array; Kod pemacu; Panggilan fungsi", "code": "import java . util . Arrays ; class GFG { static void minRemovals ( int [ ] A , int N ) { Arrays . sort ( A ) ; int mx = A [ N - 1 ] ; int sum = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { System . out . println ( 0 ) ; } else { System . out . println ( 2 * mx - sum ) ; } } public static void main ( String [ ] args ) { int [ ] A = { 3 , 3 , 2 } ; int N = A . length ; minRemovals ( A , N ) ; } }"}
{"text": "Menyusun semula array yang diberikan supaya tiada elemen array yang sama dengan indeksnya | Program Java untuk pendekatan di atas; Berfungsi untuk menyusun semula array a [] supaya tidak ada unsur array yang sama dengan indeksnya; Susun array; Melintasi indeks [0, n - 2] dari array yang diberikan; Periksa sama ada elemen semasa adalah sama dengan indeksnya; Jika didapati benar, swap elemen semasa dengan elemen seterusnya; Semak jika elemen terakhir adalah sama dengan indeksnya; Jika didapati benar, swap elemen semasa dengan elemen sebelumnya; Cetak array yang diubah suai; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void rearrangeArray ( int a [ ] , int n ) { Arrays . sort ( a ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == i + 1 ) { int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; } } if ( a [ n - 1 ] == n ) { int temp = a [ n - 1 ] ; a [ n - 1 ] = a [ n - 2 ] ; a [ n - 2 ] = temp ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + \" ▁ \" ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 5 , 3 , 2 , 4 } ; int N = arr . length ; rearrangeArray ( arr , N ) ; } }"}
{"text": "Kira bilangan minimum bergerak ke depan atau akhir untuk menyusun array | Program Java untuk pendekatan di atas; Fungsi yang mengira langkah minimum yang diperlukan untuk rahsia ARR [] kepada BRR []; Kes asas; Jika arr [i] <arr [j]; Termasuk elemen semasa; Jika tidak, tidak termasuk elemen semasa; Fungsi yang mengira langkah minimum yang diperlukan untuk menyusun array; Jika kedua -dua tatasusunan adalah sama; Tiada langkah yang diperlukan; Jika tidak; Mencetak operasi minimum yang diperlukan; Kod pemacu", "code": "import java . util . * ; import java . io . * ; import java . lang . Math ; class GFG { static int minOperations ( int arr1 [ ] , int arr2 [ ] , int i , int j ) { if ( arr1 . equals ( arr2 ) ) return 0 ; if ( i >= arr1 . length j >= arr2 . length ) return 0 ; if ( arr1 [ i ] < arr2 [ j ] ) return 1 + minOperations ( arr1 , arr2 , i + 1 , j + 1 ) ; return Math . max ( minOperations ( arr1 , arr2 , i , j + 1 ) , minOperations ( arr1 , arr2 , i + 1 , j ) ) ; } static void minOperationsUtil ( int [ ] arr ) { int brr [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) brr [ i ] = arr [ i ] ; Arrays . sort ( brr ) ; if ( arr . equals ( brr ) ) System . out . print ( \"0\" ) ; else System . out . println ( minOperations ( arr , brr , 0 , 0 ) ) ; } public static void main ( final String [ ] args ) { int arr [ ] = { 4 , 7 , 2 , 3 , 9 } ; minOperationsUtil ( arr ) ; } }"}
{"text": "Semak jika rentetan boleh diubah kepada yang lain dengan menyusun substrings | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada Str1 boleh diubah menjadi T dengan menyusun substrings; Berlaku [i] menyimpan indeks char ('a' + i) dalam rentetan s; Idx [i] menyimpan indeks char yang tersedia seterusnya ('a' + i) berlaku [i]; Sekiranya char ini tidak tersedia lagi; Penukaran tidak mungkin; Jika salah satu watak yang lebih kecil tersedia dan berlaku sebelum ini; Penukaran tidak mungkin; Cetak jawapannya; Kod pemacu", "code": "import java . util . * ; class GFG { static void canTransform ( String s , String t ) { int n = s . length ( ) ; Vector < Integer > occur [ ] = new Vector [ 26 ] ; for ( int i = 0 ; i < occur . length ; i ++ ) occur [ i ] = new Vector < Integer > ( ) ; for ( int x = 0 ; x < n ; x ++ ) { char ch = ( char ) ( s . charAt ( x ) - ' a ' ) ; occur [ ch ] . add ( x ) ; } int [ ] idx = new int [ 26 ] ; boolean poss = true ; for ( int x = 0 ; x < n ; x ++ ) { char ch = ( char ) ( t . charAt ( x ) - ' a ' ) ; if ( idx [ ch ] >= occur [ ch ] . size ( ) ) { poss = false ; break ; } for ( int small = 0 ; small < ch ; small ++ ) { if ( idx [ small ] < occur [ small ] . size ( ) && occur [ small ] . get ( idx [ small ] ) < occur [ ch ] . get ( idx [ ch ] ) ) { poss = false ; break ; } } idx [ ch ] ++ ; } if ( poss ) { System . out . print ( \" Yes \" + \"NEW_LINE\"); } else { System . out . print ( \" No \" + \"NEW_LINE\"); } } public static void main ( String [ ] args ) { String s , t ; s = \" hdecb \" ; t = \" cdheb \" ; canTransform ( s , t ) ; } }"}
{"text": "Semak sama ada dua rentetan boleh dibuat sama dengan membalikkan substring panjang yang sama dari kedua -dua rentetan | Program Java untuk pendekatan di atas; Fungsi untuk mengira kiraan penyongsangan rentetan; Untuk menyimpan kekerapan; Tambah semua watak yang kurang daripada watak ITH sebelum saya. ; Menambah kiraan kepada kiraan penyongsangan; Mengemas kini watak dalam pelbagai frekuensi; Berfungsi untuk memeriksa sama ada mana -mana rentetan mempunyai watak berulang; Fungsi untuk memeriksa sama ada String S1 dan S2 boleh dibuat sama dengan membalikkan sub rentetan saiz yang sama dalam kedua -dua rentetan; Arahan kekerapan untuk memeriksa sama ada kedua -dua rentetan mempunyai watak yang sama atau tidak; Menambah kekerapan; ; Jika watak tidak berada di S1; Menurunkan kekerapan; Jika kedua -dua rentetan tidak mempunyai aksara yang sama atau tidak; Mencari kiraan penyongsangan kedua -dua rentetan; Jika kiraan penyongsangan adalah sama, atau mempunyai pariti yang sama atau jika mana -mana rentetan mempunyai watak berulang maka jawapannya ya tidak lagi; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static int inversionCount ( String s ) { int [ ] freq = new int [ 26 ] ; int inv = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < ( int ) ( s . charAt ( i ) - ' a ' ) ; j ++ ) temp += freq [ j ] ; inv += ( i - temp ) ; freq [ s . charAt ( i ) - ' a ' ] ++ ; } return inv ; } static boolean haveRepeated ( String S1 , String S2 ) { int [ ] freq = new int [ 26 ] ; for ( char i : S1 . toCharArray ( ) ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) freq [ i ] = 0 ; for ( char i : S2 . toCharArray ( ) ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } return false ; } static void checkToMakeEqual ( String S1 , String S2 ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < S1 . length ( ) ; i ++ ) { freq [ S1 . charAt ( i ) - ' a ' ] ++ ; } boolean flag = false ; for ( int i = 0 ; i < S2 . length ( ) ; i ++ ) { if ( freq [ S2 . charAt ( i ) - ' a ' ] == 0 ) { flag = true ; break ; } freq [ S2 . charAt ( i ) - ' a ' ] -- ; } if ( flag == true ) { System . out . println ( \" No \" ) ; return ; } int invCount1 = inversionCount ( S1 ) ; int invCount2 = inversionCount ( S2 ) ; if ( invCount1 == invCount2 || ( invCount1 & 1 ) == ( invCount2 & 1 ) || haveRepeated ( S1 , S2 ) ) { System . out . println ( \" Yes \" ) ; } else System . out . println ( \" No \" ) ; } public static void main ( String [ ] args ) { String S1 = \" abbca \" , S2 = \" acabb \" ; checkToMakeEqual ( S1 , S2 ) ; } }"}
{"text": "Susun Arahan Bitonic | Program Java untuk pendekatan di atas; Berfungsi untuk menyusun array bitonic dalam ruang malar; Memulakan nilai k; Dalam setiap lelaran Bandingkan Elemen K jarak jauh dan bertukar jika mereka tidak teratur; K dikurangkan kepada separuh selepas setiap lelaran; Cetak elemen array; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "import java . io . * ; class GFG { static void sortArr ( int a [ ] , int n ) { int i , k ; k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; k = ( int ) Math . pow ( 2 , k ) ; while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) { int tmp = a [ i ] ; a [ i ] = a [ i + k ] ; a [ i + k ] = tmp ; } k = k / 2 ; } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 } ; int n = arr . length ; sortArr ( arr , n ) ; } }"}
{"text": "Split array ke dalam sub subset untuk memaksimumkan jumlah maksimum dan minimum mereka | Program Java untuk melaksanakan pendekatan di atas; Fungsi yang mencetak jumlah maksimum yang mungkin; Cari elemen dalam setiap kumpulan; Menyusun semua elemen dalam perintah bukan menurun; Tambah un elemen terbesar; Untuk jumlah elemen minimum dari setiap subset; Mencetak jumlah maksimum; Kod pemacu", "code": "import java . util . Arrays ; class GFG { static void maximumSum ( int arr [ ] , int n , int k ) { int elt = n / k ; int sum = 0 ; Arrays . sort ( arr ) ; int count = 0 ; int i = n - 1 ; while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ; while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; } System . out . println ( sum ) ; } public static void main ( String [ ] args ) { int Arr [ ] = { 1 , 13 , 7 , 17 , 6 , 5 } ; int K = 2 ; int size = Arr . length ; maximumSum ( Arr , size , K ) ; } }"}
{"text": "Kurangkan jumlah unsur -unsur terkecil dari k -lekukan panjang l | Program Java untuk mencari jumlah minimum elemen terkecil dari kaum K; Berfungsi untuk mencari jumlah minimum; Susun array; Hitung jumlah elemen k terkecil; Mengembalikan jumlahnya; Kod pemacu", "code": "import java . util . Arrays ; class GFG { static int findMinSum ( int [ ] arr , int K , int L , int size ) { if ( K * L > size ) return - 1 ; int minsum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 } ; int K = 3 ; int L = 2 ; int length = arr . length ; System . out . print ( findMinSum ( arr , K , L , length ) ) ; } }"}
{"text": "KTH elemen terkecil atau terbesar dalam array yang tidak disusun | Tetapkan 4 | Program Java untuk pendekatan di atas; Berfungsi untuk mencari elemen terkecil kth dalam array yang tidak disusun; Memulakan elemen max sebagai 0; ARR [] dan cari elemen maksimum di dalamnya; Arahan kekerapan untuk menyimpan frekuensi; Pemboleh ubah kaunter; Mengira frekuensi; Melangkah melalui freq []; Semak sama ada NUM terdapat dalam array; Meningkatkan kaunter dengan kekerapan NUM; Memeriksa jika kita telah mencapai elemen terkecil KTH; Mengembalikan elemen terkecil kth; Kod pemacu; Diberikan array; Panggilan fungsi", "code": "import java . io . * ; class GFG { static int findKthSmallest ( int [ ] arr , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int [ ] counter = new int [ max + 1 ] ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } return - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 7 , 1 , 4 , 4 , 20 , 15 , 8 } ; int N = arr . length ; int K = 5 ; System . out . print ( findKthSmallest ( arr , N , K ) ) ; } }"}
{"text": "Menjana semua nombor sehingga n dalam urutan leksikografi | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencetak semua nombor sehingga n dalam urutan leksikografi; Program Pemandu", "code": "import java . util . * ; class GFG { static void lexNumbers ( int n ) { Vector < String > s = new Vector < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . add ( String . valueOf ( i ) ) ; } Collections . sort ( s ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . add ( Integer . valueOf ( s . get ( i ) ) ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + \" ▁ \" ) ; } public static void main ( String [ ] args ) { int n = 15 ; lexNumbers ( n ) ; } }"}
{"text": "Susun Matriks dalam Perintah Menaik dan Menurun Rowwise | Pelaksanaan Java untuk mencetak baris matriks dalam urutan menaik atau menurun secara alternatif; Matriks iterate rowwise; Menyusun baris dalam urutan menaik; Bandingkan unsur -unsur bersebelahan; Swap elemen bersebelahan; Menyusun baris dalam urutan menurun; Bandingkan unsur -unsur bersebelahan; Swap elemen bersebelahan; Mencetak output akhir; Kod pemacu", "code": "class GFG { static int N = 4 ; static void func ( int a [ ] [ ] ) { int i , j , k ; for ( i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { for ( j = 0 ; j < N ; j ++ ) { for ( k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] > a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } else { for ( j = 0 ; j < N ; j ++ ) { for ( k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] < a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } } for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { System . out . print ( a [ i ] [ j ] + \" ▁ \" ) ; } System . out . print ( \"NEW_LINE\"); } } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 5 , 7 , 3 , 4 } , { 9 , 5 , 8 , 2 } , { 6 , 3 , 8 , 1 } , { 5 , 8 , 9 , 3 } } ; func ( a ) ; } }"}
{"text": "Cari berat MST dalam graf lengkap dengan Edge | Program Java untuk mencari berat pokok yang merangkumi minimum dalam graf lengkap di mana tepi mempunyai berat badan sama ada 0 atau 1; Untuk menyimpan tepi graf yang diberikan; Fungsi utiliti untuk melaksanakan traversal DFS; Semak simpang yang disimpan dalam set; Vertices dimasukkan jika berat kelebihan adalah 0; Fungsi utiliti untuk mencari berat pokok minimum; Untuk mengira komponen yang disambungkan; Memasukkan simpul awal dalam set; Melintasi simpang yang disimpan dalam set dan menjalankan traversal DFS untuk setiap simpang; Meningkatkan komponen bersambung berat sifar; DFS traversal untuk setiap vertex mengeluarkan; Kod pemandu; Masukkan tepi; Fungsi Panggilan Cari berat pokok minimum", "code": "import java . util . * ; class GFG { static HashMap < Integer , Integer > [ ] g = new HashMap [ 200005 ] ; static HashSet < Integer > s = new HashSet < > ( ) ; static HashSet < Integer > ns = new HashSet < > ( ) ; static void dfs ( int x ) { Vector < Integer > v = new Vector < > ( ) ; v . clear ( ) ; ns . clear ( ) ; for ( int it : s ) { if ( g [ x ] . get ( it ) != null ) { v . add ( it ) ; } else { ns . add ( it ) ; } } s = ns ; for ( int i : v ) { dfs ( i ) ; } } static void weightOfMST ( int N ) { int cnt = 0 ; for ( int i = 1 ; i <= N ; ++ i ) { s . add ( i ) ; } Vector < Integer > qt = new Vector < > ( ) ; for ( int t : s ) qt . add ( t ) ; while ( ! qt . isEmpty ( ) ) { ++ cnt ; int t = qt . get ( 0 ) ; qt . remove ( 0 ) ; dfs ( t ) ; } System . out . print ( cnt - 4 ) ; } public static void main ( String [ ] args ) { int N = 6 , M = 11 ; int edges [ ] [ ] = { { 1 , 3 } , { 1 , 4 } , { 1 , 5 } , { 1 , 6 } , { 2 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 4 } , { 3 , 5 } , { 3 , 6 } } ; for ( int i = 0 ; i < g . length ; i ++ ) g [ i ] = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < M ; ++ i ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; g [ u ] . put ( v , 1 ) ; g [ v ] . put ( u , 1 ) ; } weightOfMST ( N ) ; } }"}
{"text": "Kira pasangan yang mungkin berbeza supaya elemen dari A lebih besar daripada elemen dari b | Program Java untuk mengira bilangan pasangan yang berbeza yang mungkin dari kedua -dua tatasusunan seperti elemen yang dipilih dari satu array selalu lebih besar daripada yang dipilih dari array yang lain; Berfungsi untuk mengembalikan kiraan pasangan; Kod pemacu", "code": "import java . util . * ; class GFG { static int countPairs ( int [ ] A , int [ ] B ) { int n = A . length ; int ans = 0 ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] A = { 30 , 28 , 45 , 22 } ; int [ ] B = { 35 , 25 , 22 , 48 } ; System . out . print ( countPairs ( A , B ) ) ; } }"}
{"text": "Sisa maksimum mungkin apabila elemen dibahagikan dengan elemen lain dalam array | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan nilai mod maksimum untuk mana -mana pasangan dari array; Cari elemen maksimum kedua dari array; Kod pemacu", "code": "class GFG { static int max_element ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } return max ; } static int maxMod ( int arr [ ] , int n ) { int maxVal = max_element ( arr , n ) ; int secondMax = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 1 , 5 , 3 , 6 } ; int n = arr . length ; System . out . println ( maxMod ( arr , n ) ) ; } }"}
{"text": "Pilih x elemen dari elemen [] dan y dari b [] yang memenuhi syarat yang diberikan | Pelaksanaan Java pendekatan di atas; Berfungsi untuk pulangan yang benar jika mungkin untuk memilih unsur -unsur; Jika unsur -unsur tidak dapat dipilih; Menyusun kedua -dua tatasusunan; Jika elemen terkecil x [] adalah lebih kecil daripada elemen terbesar Yth B []; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 1 , 1 , 1 , 1 } ; int B [ ] = { 2 , 2 } ; int n = A . length ; int m = B . length ; ; int x = 3 , y = 1 ; if ( isPossible ( A , B , n , m , x , y ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Cari perubahan minimum yang diperlukan dalam array untuk mengandungi elemen K yang berbeza | C # Program kepada perubahan minimum yang diperlukan dalam array untuk elemen K yang berbeza. ; Fungsi kepada perubahan minimum yang diperlukan dalam array untuk elemen K yang berbeza. ; Simpan kekerapan setiap elemen; Simpan kekerapan elemen; Jenis frekuensi dalam urutan menurun; Untuk menyimpan jawapan yang diperlukan; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "import java . util . * ; class GFG { static int MAX = 100005 ; static int Min_Replace ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; Integer [ ] freq = new Integer [ MAX ] ; Arrays . fill ( freq , 0 ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } Arrays . sort ( freq , Collections . reverseOrder ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 } ; int n = arr . length ; int k = 2 ; System . out . println ( Min_Replace ( arr , n , k ) ) ; } }"}
{"text": "Bilangan maksimum elemen tanpa bertindih dalam garis | Program Java untuk mencari bilangan elemen maksimum tanpa bertindih dalam satu baris; Berfungsi untuk mencari bilangan elemen maksimum tanpa bertindih dalam garis; Jika n = 1, maka jawapannya adalah satu; Kami sentiasa boleh membuat elemen 1 st untuk menutup segmen kiri dan nth segmen yang betul; Jika segmen kiri untuk elemen ith tidak bertindih dengan elemen i - 1 maka kemudian kiri; lain cuba ke arah yang betul jika boleh; Kemas kini x [i] ke titik akhir kanan segmen yang diliputi olehnya; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int x [ ] = { 1 , 3 , 4 , 5 , 8 } , l [ ] = { 10 , 1 , 2 , 2 , 5 } ; int n = x . length ; System . out . println ( Segment ( x , l , n ) ) ; } }"}
{"text": "Padam ganjil dan bahkan nombor pada langkah alternatif supaya jumlah elemen yang tinggal diminimumkan | Pelaksanaan Java pendekatan; Berfungsi untuk mencari jumlah yang diminimumkan; Jika lebih banyak elemen ganjil; Menyusun unsur -unsur; Kiri - lebih dari elemen; Cari jumlah unsur sisa; Mengembalikan jumlahnya; Jika lebih banyak elemen; Menyusun unsur -unsur; Kiri - lebih dari elemen; Cari jumlah unsur sisa; Mengembalikan jumlahnya; Jika elemen yang sama; Kod pemacu", "code": "import java . util . * ; class GFG { static int MinimizeleftOverSum ( int a [ ] , int n ) { Vector < Integer > v1 = new Vector < Integer > ( ) , v2 = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) v1 . add ( a [ i ] ) ; else v2 . add ( a [ i ] ) ; } if ( v1 . size ( ) > v2 . size ( ) ) { Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; int x = v1 . size ( ) - v2 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v1 . get ( i ++ ) ; } return sum ; } else if ( v2 . size ( ) > v1 . size ( ) ) { Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; int x = v2 . size ( ) - v1 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v2 . get ( i ++ ) ; } return sum ; } else return 0 ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 2 , 2 , 2 } ; int n = a . length ; System . out . println ( MinimizeleftOverSum ( a , n ) ) ; } }"}
{"text": "Operasi minimum untuk membuat kekerapan semua aksara sama k | Program Java untuk menukar rentetan yang diberikan; Berfungsi untuk mencari bilangan minimum operasi untuk menukar rentetan yang diberikan; Semak jika n boleh dibahagikan dengan k; Array untuk menyimpan kekerapan aksara dalam rentetan yang diberikan; Dua tatasusunan dengan bilangan operasi yang diperlukan; Memeriksa semua kemungkinan; Kod pemacu", "code": "import java . util . * ; class GFG { static void minOperation ( String S , int N , int K ) { if ( N % K != 0 ) { System . out . println ( \" Not ▁ Possible \" ) ; } else { int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < N ; i ++ ) { count [ ( S . charAt ( i ) - 97 ) ] ++ ; } int E = N / K ; Vector < Integer > greaterE = new Vector < > ( ) ; Vector < Integer > lessE = new Vector < > ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] < E ) lessE . add ( E - count [ i ] ) ; else greaterE . add ( count [ i ] - E ) ; } Collections . sort ( greaterE ) ; Collections . sort ( lessE ) ; int mi = Integer . MAX_VALUE ; for ( int i = 0 ; i <= K ; i ++ ) { int set1 = i ; int set2 = K - i ; if ( greaterE . size ( ) >= set1 && lessE . size ( ) >= set2 ) { int step1 = 0 ; int step2 = 0 ; for ( int j = 0 ; j < set1 ; j ++ ) step1 += greaterE . get ( j ) ; for ( int j = 0 ; j < set2 ; j ++ ) step2 += lessE . get ( j ) ; mi = Math . min ( mi , Math . max ( step1 , step2 ) ) ; } } System . out . println ( mi ) ; } } public static void main ( String [ ] args ) { String S = \" accb \" ; int N = S . length ( ) ; int K = 2 ; minOperation ( S , N , K ) ; } }"}
{"text": "Operasi Peningkatan Julat Minimum Untuk Mengasingkan Array | Program Java untuk mencari kenaikan jarak minimum untuk menyusun array; Berfungsi untuk mencari kenaikan julat minimum untuk menyusun array; Jika elemen semasa didapati lebih besar daripada kenaikan elemen terakhir semua istilah dalam julat i + 1 hingga n - 1; mn = arr [i]; Minimum dalam julat I hingga n - 1; Kod pemacu", "code": "import java . io . * ; class GFG { static int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 2 , 8 , 4 } ; int n = arr . length ; System . out . println ( minMovesToSort ( arr , n ) ) ; } }"}
{"text": "Susun nombor utama array dalam perintah menurun | Pelaksanaan Java pendekatan; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Fungsi yang menyusun semua nombor utama dari array dalam menurun; Vektor ini akan mengandungi nombor utama untuk disusun; Jika elemen itu adalah perdana; mengemas kini elemen array; Kod pemacu; Cetak hasilnya.", "code": "import java . util . * ; class GFG { static boolean prime [ ] = new boolean [ 100005 ] ; static void SieveOfEratosthenes ( int n ) { Arrays . fill ( prime , true ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < n ; i += p ) { prime [ i ] = false ; } } } } static void sortPrimes ( int arr [ ] , int n ) { SieveOfEratosthenes ( 100005 ) ; Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { v . add ( arr [ i ] ) ; } } Comparator comparator = Collections . reverseOrder ( ) ; Collections . sort ( v , comparator ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { arr [ i ] = v . get ( j ++ ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 3 , 2 , 6 , 100 , 17 } ; int n = arr . length ; sortPrimes ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + \" ▁ \" ) ; } } }"}
{"text": "Pembentukan pasangan sedemikian rupa sehingga jumlah pasangan maksimum diminimumkan | Program Java untuk membahagikan array ke pasangan N seperti pasangan maksimum diminimumkan; Selepas menyusun mengekalkan dua pembolehubah i dan j menunjuk untuk memulakan dan mengakhiri array sedemikian rupa sehingga elemen terkecil pasangan array dengan elemen terbesar; Kod pemacu", "code": "import java . io . * ; import java . util . Arrays ; class GFG { static void findOptimalPairs ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) System . out . print ( \" ( \" + arr [ i ] + \" , ▁ \" + arr [ j ] + \" ) \" + \" ▁ \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 9 , 6 , 5 , 1 } ; int N = arr . length ; findOptimalPairs ( arr , N ) ; } }"}
{"text": "Sort Array mengikut kiraan bit set | Program Java untuk melaksanakan pendekatan mudah untuk menyusun array mengikut kiraan bit set. ; fungsi utiliti yang mengembalikan jumlah bit set dalam integer; Berfungsi secara serentak menyusun kedua -dua tatasusunan menggunakan jenis penyisipan (https: www. Geeksforgeeks. Org / sisipan - sort /); Gunakan 2 kekunci kerana kita perlu menyusun kedua -dua tatasusunan secara serentak; Gerakkan unsur -unsur ARR [0 .. i - 1] dan aux [0 .. i - 1], seperti unsur -unsur aux [0 .. i - 1] adalah lebih besar daripada Key1, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi untuk disusun mengikut kiraan bit menggunakan array tambahan; Buat array dan kiraan bit set di dalamnya. ; Susun arr [] mengikut nilai dalam aux []; Fungsi utiliti untuk mencetak array; Kod pemacu", "code": "import java . io . * ; class GFG { static int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; } static void insertionSort ( int arr [ ] , int aux [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { int key1 = aux [ i ] ; int key2 = arr [ i ] ; int j = i - 1 ; while ( j >= 0 && aux [ j ] < key1 ) { aux [ j + 1 ] = aux [ j ] ; arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } aux [ j + 1 ] = key1 ; arr [ j + 1 ] = key2 ; } } static void sortBySetBitCount ( int arr [ ] , int n ) { int aux [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aux [ i ] = countBits ( arr [ i ] ) ; insertionSort ( arr , aux , n ) ; } static void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; } }"}
{"text": "Sort Array mengikut kiraan bit set | Program Java untuk menyusun array mengikut kiraan set bit menggunakan std :: sort (); fungsi utiliti yang mengembalikan jumlah bit set dalam integer; Fungsi untuk disusun mengikut kiraan bit. Fungsi ini mengandaikan bahawa terdapat 32 bit dalam integer. ; Digunakan sebagai indeks dalam pelbagai disusun akhir; Melintasi semua bit bit (perhatikan bahawa kami menyusun array dalam penurunan urutan); Fungsi utiliti untuk mencetak array; Kod pemacu", "code": "import java . util . * ; class GFG { static int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; } static void sortBySetBitCount ( int arr [ ] , int n ) { Vector < Integer > [ ] count = new Vector [ 32 ] ; for ( int i = 0 ; i < count . length ; i ++ ) count [ i ] = new Vector < Integer > ( ) ; int setbitcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . add ( arr [ i ] ) ; } int j = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { Vector < Integer > v1 = count [ i ] ; for ( int p = 0 ; p < v1 . size ( ) ; p ++ ) arr [ j ++ ] = v1 . get ( p ) ; } } static void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; } }"}
{"text": "Rentetan binari terkecil lexicographically dibentuk dengan membalikkan bit pada indeks yang tidak dapat dibahagi k1 atau k2 supaya kiraan 1 s sentiasa lebih besar daripada 0 s dari kiri | Program Java untuk pendekatan di atas; Berfungsi untuk mencari rentetan terkecil secara lexicographically yang mempunyai bilangan 1 s lebih besar daripada bilangan 0 s; C1S dan C0S menyimpan kiraan 1 s dan 0 s pada setiap kedudukan; Melintasi rentetan s; Jika kedudukan tidak dapat dibahagikan dengan k1 dan k2; Jika c0s> = c1s dan pos [] kosong maka rentetan tidak dapat dibentuk; Jika POS [] tidak kosong maka flip sedikit kedudukan terakhir yang terdapat di POS []; Cetak hasilnya; Kod pemacu", "code": "import java . util . * ; class GFG { static void generateString ( int k1 , int k2 , char [ ] s ) { int C1s = 0 , C0s = 0 ; int flag = 0 ; Vector < Integer > pos = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == '0' ) { C0s ++ ; if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . add ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) { if ( pos . size ( ) == 0 ) { System . out . print ( - 1 ) ; flag = 1 ; break ; } else { int k = pos . get ( pos . size ( ) - 1 ) ; s [ k ] = '1' ; C0s -- ; C1s ++ ; pos . remove ( pos . size ( ) - 1 ) ; } } } if ( flag == 0 ) { System . out . print ( s ) ; } } public static void main ( String [ ] args ) { int K1 = 2 , K2 = 4 ; String S = \"11000100\" ; generateString ( K1 , K2 , S . toCharArray ( ) ) ; } }"}
{"text": "Cari sepasang nombor dengan set bit set sebagai kebanyakan n dan yang bitwise xor adalah n | Program Java untuk pendekatan di atas; Fungsi untuk mencari pasangan (x, y) sedemikian rupa sehingga x xor y = n dan kiraan bit set dalam x dan y kurang daripada kiraan set bit dalam n; Kedai MSB (Bit Paling Penting); Menyimpan nilai x; Menyimpan nilai y; Melintasi semua bit N; Jika ia bit n ialah 0; Tetapkan sedikit x hingga 1; Tetapkan sedikit Y hingga 1; Jawapan cetak; Kod pemacu", "code": "import java . io . * ; class GFG { static void maximizeProduct ( int N ) { int MSB = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) { X += 1 << i ; Y += 1 << i ; } } System . out . println ( X + \" ▁ \" + Y ) ; } public static void main ( String [ ] args ) { int N = 45 ; maximizeProduct ( N ) ; } }"}
{"text": "Count of Numbers in Range [l, r] mempunyai jumlah digit persegi sama dengan kuadrat jumlah digit | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor itu sah; Jumlah digit Num; Nombor kuadrat; Jumlah digit (num * num); Berfungsi untuk menukar rentetan ke integer; Berfungsi untuk menghasilkan semua rentetan panjang yang mungkin; Rentetan yang dikehendaki; Hanya mengambil nombor yang sah; Berulang untuk semua digit yang mungkin; Berfungsi untuk mengira nombor unik dalam julat [l, r]; Memulakan pembolehubah untuk menyimpan jawapannya; Kirakan panjang maksimum yang mungkin; Tetapkan untuk menyimpan nombor yang sah yang berbeza; Menjana semua rentetan panjang yang mungkin i; I -meletakkan set untuk mendapatkan kiraan nombor yang sah dalam julat [l, r]; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean check ( int num ) { int sm = 0 ; int num2 = num * num ; while ( num > 0 ) { sm += num % 10 ; num /= 10 ; } int sm2 = 0 ; while ( num2 > 0 ) { sm2 += num2 % 10 ; num2 /= 10 ; } return ( ( sm * sm ) == sm2 ) ; } static int convert ( String s ) { int val = 0 ; s = reverse ( s ) ; int cur = 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { val += ( s . charAt ( i ) - '0' ) * cur ; cur *= 10 ; } return val ; } static void generate ( String s , int len , HashSet < Integer > uniq ) { if ( s . length ( ) == len ) { if ( check ( convert ( s ) ) ) { uniq . add ( convert ( s ) ) ; } return ; } for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + ( char ) ( i + '0' ) , len , uniq ) ; } } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; } static int totalNumbers ( int L , int R ) { int ans = 0 ; int max_len = ( int ) ( Math . log10 ( R ) + 1 ) ; HashSet < Integer > uniq = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= max_len ; i ++ ) { generate ( \" \" , i , uniq ) ; } for ( int x : uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int L = 22 , R = 22 ; System . out . print ( totalNumbers ( L , R ) ) ; } }"}
{"text": "Tukar x ke y dengan berulang kali mengalikan x dengan 2 atau tampuk 1 pada akhir | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada x boleh ditukar kepada y dengan mengalikan x dengan 2 atau menambahkan 1 pada akhir; ITERATE Sehingga Y adalah sekurang -kurangnya x; Jika y juga; Jika digit terakhir Y ialah 1; Jika tidak; Semak sama ada x sama dengan y; Kod pemacu", "code": "import java . util . * ; class GFG { static void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } public static void main ( String [ ] args ) { int X = 100 , Y = 40021 ; convertXintoY ( X , Y ) ; } }"}
{"text": "Lexicographically terkecil rentetan panjang maksimum yang terdiri daripada huruf k pertama yang tidak mengandungi apa -apa substring berulang | Program Java untuk pendekatan di atas; Berfungsi untuk mencari rentetan terkecil lexicographically dari huruf kaum K bawah pertama yang mempunyai substrings yang unik; Menyimpan rentetan yang dihasilkan; Melewati semua watak; Gelung dalaman untuk membuat pasangan dan menambahkannya ke dalam rentetan; Menambah watak pertama supaya substring yang terdiri daripada abjad yang terakhir hadir; Cetak rentetan yang dihasilkan; Kod pemacu", "code": "import java . util . * ; class GFG { static void generateString ( int K ) { String s = \" \" ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + ( char ) ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += ( char ) ( i ) ; s += ( char ) ( j ) ; } } s += ( char ) ( 97 ) ; System . out . println ( s ) ; } public static void main ( String [ ] args ) { int K = 4 ; generateString ( K ) ; } }"}
{"text": "Menjana Persamaan Kuadratik setelah memberikan jumlah dan produk akar | Program Java untuk pendekatan di atas; Berfungsi untuk mencari persamaan kuadratik dari jumlah dan produk akar yang diberikan; Cetak pekali; Kod pemacu", "code": "import java . io . * ; class GFG { public static void findEquation ( int S , int M ) { System . out . println ( \"1 ▁ \" + ( ( - 1 ) * S ) + \" ▁ \" + M ) ; } public static void main ( String [ ] args ) { int S = 5 , M = 6 ; findEquation ( S , M ) ; } }"}
{"text": "Buat semua elemen array sama dengan menggantikan pasangan bersebelahan dengan jumlah mereka | Program Java untuk pendekatan di atas; Fungsi untuk mengira bilangan minimum pasang unsur -unsur bersebelahan yang diperlukan untuk digantikan oleh jumlah mereka untuk membuat semua elemen array sama; Menyimpan jumlah awalan array; Kirakan Array Jumlah Awalan; Menyimpan bilangan maksimum subarray yang mana array boleh dibahagikan; Melangkah ke atas semua jumlah yang mungkin; Melintasi array; Jika jumlahnya sama dengan jumlah awalan semasa; Kira kenaikan kumpulan sebanyak 1; Jika tidak buang jumlah subkumpulan ini; Mengemas kini maksimum ini subarray; Mengembalikan bilangan operasi minimum; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int minSteps ( ArrayList < Integer > a , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = a . get ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] + a . get ( i ) ; int mx = - 1 ; for ( int subgroupsum : prefix_sum ) { int sum = 0 ; int i = 0 ; int grp_count = 0 ; while ( i < n ) { sum += a . get ( i ) ; if ( sum == subgroupsum ) { grp_count += 1 ; sum = 0 ; } else if ( sum > subgroupsum ) { grp_count = - 1 ; break ; } i += 1 ; } if ( grp_count > mx ) mx = grp_count ; } return n - mx ; } public static void main ( String [ ] args ) { ArrayList < Integer > A = new ArrayList < Integer > ( ) ; A . add ( 1 ) ; A . add ( 2 ) ; A . add ( 3 ) ; A . add ( 2 ) ; A . add ( 1 ) ; A . add ( 3 ) ; int N = A . size ( ) ; System . out . print ( minSteps ( A , N ) ) ; } }"}
{"text": "Karakter yang paling kerap dalam rentetan selepas menggantikan semua kejadian x dalam rentetan binari | Program Java untuk pendekatan di atas; Berfungsi untuk mencari watak yang paling kerap selepas menggantikan x dengan sama ada '0' atau '1' mengikut syarat -syarat yang diberikan; Simpan kiraan 0 s dan 1 s dalam rentetan S; Hitung kekerapan 0 dan 1; Jika wataknya adalah 1; Jika wataknya 0; Kedai pertama berlaku 1; Melintasi rentetan untuk mengira bilangan x antara dua berturut -turut 1 s; Jika watak semasa bukan x; Jika aksara semasa adalah 1, tambahkan bilangan Xs ke Count1 dan tetapkan sebelum i; Jika tidak; Cari kejadian seterusnya 1 dalam rentetan; Jika ia dijumpai, tetapkan saya ke sebelumnya; Jika tidak, keluar dari gelung; Simpan kejadian pertama 0; Ulangi prosedur yang sama untuk mengira bilangan x antara dua berturut -turut 0 s; Jika watak semasa bukan x; Jika watak semasa adalah 0; Tambah kiraan XS ke Count0; Tetapkan sebelumnya ke i; Jika tidak; Cari kejadian seterusnya 0 dalam rentetan; Jika ia dijumpai, tetapkan saya ke sebelumnya; Jika tidak, keluar dari gelung; Kiraan bilangan x yang hadir dalam permulaan rentetan sebagai xxxx1 ...; Simpan kiraan x; Kenaikan kiraan1 dengan kiraan jika keadaan itu berpuas hati; Hitung bilangan x yang hadir pada akhir rentetan sebagai ... xxxx0; Simpan kiraan x; Kenaikan kiraan dengan kiraan jika keadaan itu berpuas hati; Jika kiraan 1 adalah sama dengan kiraan 0, cetak x; Jika tidak, jika kiraan 1 lebih besar daripada kiraan 0; Jika tidak, cetak 0; Kod pemacu", "code": "import java . io . * ; class GFG { public static void maxOccuringCharacter ( String s ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) { count1 ++ ; } else if ( s . charAt ( i ) == '0' ) { count0 ++ ; } } int prev = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != ' X ' ) { if ( s . charAt ( i ) == '1' ) { count1 += i - prev - 1 ; prev = i ; } else { boolean flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == '1' ) { flag = false ; prev = j ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ( ) ; } } } } prev = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '0' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != ' X ' ) { if ( s . charAt ( i ) == '0' ) { count0 += i - prev - 1 ; prev = i ; } else { boolean flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == '0' ) { prev = j ; flag = false ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ( ) ; } } } } if ( s . charAt ( 0 ) == ' X ' ) { int count = 0 ; int i = 0 ; while ( s . charAt ( i ) == ' X ' ) { count ++ ; i ++ ; } if ( s . charAt ( i ) == '1' ) { count1 += count ; } } if ( s . charAt ( s . length ( ) - 1 ) == ' X ' ) { int count = 0 ; int i = s . length ( ) - 1 ; while ( s . charAt ( i ) == ' X ' ) { count ++ ; i -- ; } if ( s . charAt ( i ) == '0' ) { count0 += count ; } } if ( count0 == count1 ) { System . out . println ( \" X \" ) ; } else if ( count0 > count1 ) { System . out . println ( 0 ) ; } else System . out . println ( 1 ) ; } public static void main ( String [ ] args ) { String S = \" XX10XX10XXX1XX \" ; maxOccuringCharacter ( S ) ; } }"}
{"text": "Memaksimumkan kiraan lembaran yang mungkin dengan berulang kali mengurangkan kawasannya kepada separuh | Program Java untuk pendekatan di atas; Fungsi untuk mengira bilangan maksimum lembaran yang mungkin dengan operasi yang diberikan; Kiraan awal lembaran; Terus membahagikan kepingan ke separuh; Mengurangkan kawasan dengan separuh; Meningkatkan kiraan dua kali; Kod pemacu", "code": "import java . util . * ; class GFG { static int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; } public static void main ( String args [ ] ) { int A = 5 , B = 10 ; System . out . println ( maxSheets ( A , B ) ) ; } }"}
{"text": "Bilangan langkah minimum yang diperlukan untuk mencapai asal dari titik tertentu | Program Java untuk pendekatan di atas; Berfungsi untuk mencari langkah minimum yang diperlukan untuk mencapai asal dari (a, b); Menyimpan bilangan minimum bergerak; Periksa sama ada perbezaan mutlak ialah 1 atau 0; Simpan minimum a, b; Simpan maksimum a, b; Cetak jawapannya; Kod pemacu; Diberikan Co - ordinat; Panggilan fungsi", "code": "import java . io . * ; class GFG { static void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || Math . abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = Math . min ( a , b ) ; int j = Math . max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int a = 3 , b = 5 ; findMinMoves ( a , b ) ; } }"}
{"text": "Kira walaupun jumlah pasangan yang mungkin dengan memilih dua bilangan bulat dari dua julat yang diberikan masing -masing | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mengira maksimum walaupun jumlah pasangan dalam julat yang diberikan; Menyimpan kiraan nombor antara 1 hingga x; Menyimpan kiraan nombor ganjil antara 1 hingga x; Menyimpan kiraan nombor antara 1 hingga y; Menyimpan kiraan nombor ganjil antara 1 hingga y; Menyimpan kiraan pasangan yang mempunyai jumlah wang; Mengimbangi kiraan pasangan yang mempunyai jumlah; Kod pemacu", "code": "import java . io . * ; class GFG { static long cntEvenSumPairs ( long X , long Y ) { long cntXEvenNums = X / 2 ; long cntXOddNums = ( X + 1 ) / 2 ; long cntYEvenNums = Y / 2 ; long cntYOddNums = ( Y + 1 ) / 2 ; long cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ; return cntPairs ; } public static void main ( String [ ] args ) { long X = 2 ; long Y = 3 ; System . out . println ( cntEvenSumPairs ( X , Y ) ) ; } }"}
{"text": "Kurangkan elemen array yang diperlukan untuk ditingkatkan atau diturunkan untuk menukar array yang diberikan ke dalam siri Fibonacci | Program Java untuk pendekatan di atas; Fungsi untuk mengira bilangan minimum bergerak untuk membuat urutan siri Fibonacci; Jika bilangan elemen kurang daripada 3; Memulakan nilai hasilnya; Cuba semua permutasi dua elemen pertama; Nilai elemen pertama selepas operasi; Nilai elemen kedua selepas operasi; Hitung bilangan gerakan untuk unsur -unsur array; Elemen pada indeks IDX; Sekiranya tidak mungkin untuk menukar elemen dalam satu langkah; Jika tidak; Mengemas kini jawapannya; Kembalikan jawapannya; Kod pemacu", "code": "import java . util . * ; class GFG { static int minMoves ( int [ ] arr ) { int N = arr . length ; if ( N <= 2 ) return 0 ; int ans = Integer . MAX_VALUE ; for ( int i = - 1 ; i <= 1 ; i ++ ) { for ( int j = - 1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = Math . abs ( i ) + Math . abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 4 , 8 , 9 , 17 , 27 } ; System . out . print ( minMoves ( arr ) ) ; } }"}
{"text": "Pertanyaan untuk mengira jumlah elemen array yang hadir pada setiap indeks yth bermula dari indeks x | Program Java untuk pendekatan di atas; Fungsi untuk mencari jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua pertanyaan; Melangkah ke atas setiap pertanyaan; Menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array dan mengira jumlah ungkapan; Kemas kini Jumlah; Kemas kini x; Kod pemacu", "code": "import java . util . * ; class GFG { static void querySum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } System . out . print ( sum + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ ] = { { 2 , 1 } , { 3 , 2 } } ; int N = arr . length ; int M = Q . length ; querySum ( arr , N , Q , M ) ; } }"}
{"text": "Kirakan bitwise atau dua bilangan bulat dari nilai bitwise dan bitwise mereka yang diberikan | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mengira bitwise atau dari bitwise xor dan bitwise dan nilai -nilai; Kod pemacu", "code": "class GFG { static int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; } public static void main ( String [ ] args ) { int X = 5 , Y = 2 ; System . out . print ( findBitwiseORGivenXORAND ( X , Y ) ) ; } }"}
{"text": "Semak jika nilai yang diberikan dapat dicapai dari nilai lain dalam barisan bulat oleh k | Program Java untuk pendekatan di atas; Berfungsi untuk mengembalikan GCD dua nombor A dan B; Kes asas; Recursif mencari GCD; Fungsi untuk memeriksa B boleh digunakan dari A dengan lompatan elemen K dalam barisan bulat; Cari GCD N dan K; Jika A - B boleh dibahagikan dengan GCD maka cetak ya; Jika tidak; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class solution { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static void canReach ( int N , int A , int B , int K ) { int gcd = GCD ( N , K ) ; if ( Math . abs ( A - B ) % gcd == 0 ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } public static void main ( String args [ ] ) { int N = 5 , A = 2 , B = 1 , K = 2 ; canReach ( N , A , B , K ) ; } }"}
{"text": "Count subarrays mempunyai jumlah yang sama dengan panjangnya | Tetapkan 2 | Program Java untuk pendekatan di atas; Fungsi yang mengira subarray dengan jumlah elemennya sebagai panjangnya; Simpan kiraan elemen sehingga elemen semasa dengan panjang i; Menyimpan kiraan akhir subarray; Menyimpan jumlah awalan; Jika saiz subarray adalah 1; Melelehkan array; Cari jumlahnya; Kekerapan kemas kini dalam peta; Cetak jumlah kiraan; Kod pemacu; Diberikan array arr []; Saiz array; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void countOfSubarray ( int arr [ ] , int N ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int answer = 0 ; int sum = 0 ; if ( mp . get ( 1 ) != null ) mp . put ( 1 , mp . get ( 1 ) + 1 ) ; else mp . put ( 1 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( mp . get ( sum - i ) != null ) answer += mp . get ( sum - i ) ; if ( mp . get ( sum - i ) != null ) mp . put ( sum - i , mp . get ( sum - i ) + 1 ) ; else mp . put ( sum - i , 1 ) ; } System . out . print ( answer ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 2 , 1 , 2 , - 2 , 2 , 4 } ; int N = arr . length ; countOfSubarray ( arr , N ) ; } }"}
{"text": "Split First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk memecah nombor semulajadi N pertama ke dalam dua set yang mempunyai perbezaan mutlak minimum jumlah mereka; Menyimpan jumlah unsur set1; Menyimpan jumlah unsur set2; Melintasi nombor semulajadi n pertama; Semak sama ada jumlah unsur set1 kurang daripada atau sama dengan jumlah unsur set2; Kod pemacu", "code": "import java . io . * ; class GFG { static int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return Math . abs ( sumSet1 - sumSet2 ) ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . println ( minAbsDiff ( N ) ) ; } }"}
{"text": "Semak jika nombor adalah perdana terbalik terbalik, cermin dibalik dan cermin terbalik terbalik | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada n mengandungi digit 0, 1, 2, 5, 8 sahaja; Ekstrak digit n; Kembali palsu jika mana -mana digit ini hadir; Fungsi untuk memeriksa sama ada n adalah perdana atau tidak; Semak semua faktor; Fungsi untuk memeriksa sama ada n adalah perdana dalam semua bentuk yang dikehendaki; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean checkDigits ( int n ) { do { int r = n % 10 ; if ( r == 3 r == 4 r == 6 r == 7 r == 9 ) return false ; n /= 10 ; } while ( n != 0 ) ; return true ; } static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static boolean isAllPrime ( int n ) { return isPrime ( n ) && checkDigits ( n ) ; } public static void main ( String [ ] args ) { int N = 101 ; if ( isAllPrime ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text": "Kos minimum diperlukan untuk menjana urutan pendakap seimbang | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mengira kos minimum yang diperlukan untuk menjana urutan pendakap yang seimbang; Menyimpan kiraan kurungan terbuka tidak seimbang; Menyimpan kiraan kurungan tertutup yang tidak seimbang; Menyimpan kiraan kurungan terbuka; Menyimpan kiraan kurungan tertutup; Jika pendakap terbuka ditemui; Jika tidak; Sekiranya tiada kurungan terbuka tidak seimbang; Meningkatkan kiraan kurungan tertutup yang tidak seimbang; Jika tidak; Mengurangkan kiraan kurungan terbuka yang tidak seimbang; Meningkatkan kiraan kurungan tertutup; Mengira batas kos minimum yang lebih rendah; Mengurangkan kurungan terbuka atau tertutup yang berlebihan untuk mengelakkan mengira mereka dua kali; Kemas kini jawapan dengan menambahkan minimum mengeluarkan kedua -dua kurungan terbuka dan tertutup yang tidak seimbang atau memasukkan kurungan tidak seimbang tertutup ke hujung rentetan; Cetak hasilnya; Kod pemacu", "code": "import java . util . * ; class GFG { static void minCost ( String str , int a , int b ) { int openUnbalanced = 0 ; int closedUnbalanced = 0 ; int openCount = 0 ; int closedCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } int result = a * ( Math . abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += Math . min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; System . out . print ( result + \"NEW_LINE\"); } public static void main ( String [ ] args ) { String str = \" ) ) ( ) ( ( ) ( ) ( \" ; int A = 1 , B = 3 ; minCost ( str , A , B ) ; } }"}
{"text": "Count of permutasi seperti jumlah nombor k dari julat yang diberikan adalah | Program Java untuk pendekatan di atas; Berfungsi untuk mengembalikan bilangan semua permutasi seperti jumlah nombor k dalam julat adalah walaupun; Cari jumlah kiraan nombor walaupun dan ganjil dalam julat yang diberikan; ITERATE LOOP K TIMES DAN UPDATE EVER_SUM & ODD_SUM Menggunakan nilai sebelumnya; Kemas kini prev_even dan odd_sum; Malah jumlah; Jumlah ganjil; Kembali even_sum; Kod pemacu; Diberikan julat; Panjang permutasi; Panggilan fungsi", "code": "import java . util . * ; class GFG { public static void countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } System . out . println ( even_sum ) ; } public static void main ( String [ ] args ) { int low = 4 ; int high = 5 ; int K = 3 ; countEvenSum ( low , high , K ) ; } }"}
{"text": "Count of N digit nombor yang jumlahnya setiap digit berturut -turut adalah sama | Tetapkan 2 | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mengira bilangan nombor n - digit sedemikian rupa sehingga jumlah setiap digit berturut -turut adalah sama; Cetak jawapannya; Kod pemacu", "code": "class GFG { public static void count ( int n , int k ) { long count = ( long ) ( Math . pow ( 10 , k ) - Math . pow ( 10 , k - 1 ) ) ; System . out . print ( count ) ; } public static void main ( String [ ] args ) { int n = 2 , k = 1 ; count ( n , k ) ; } }"}
{"text": "Jumlah pembahagi terbesar nombor sehingga tidak dibahagikan dengan nombor perdana p | Program Java untuk pendekatan di atas; Berfungsi untuk mencari jumlah pembahagi terbesar nombor dalam julat 1 hingga n tidak boleh dibahagikan dengan nombor perdana p; Jumlah jumlah sehingga n; Jika tidak ada beberapa p yang ada sehingga n; Jika hanya p sendiri berada dalam lingkungan 1 hingga n; Jumlah mereka yang boleh dibahagikan dengan p; Panggilan fungsi rekursif untuk mencari jumlah untuk N / P; Kod pemacu; Diberikan n dan p; Panggilan fungsi", "code": "class GFG { static int func ( int N , int P ) { int sumUptoN = ( N * ( N + 1 ) / 2 ) ; int sumOfMultiplesOfP ; if ( N < P ) { return sumUptoN ; } else if ( ( N / P ) == 1 ) { return sumUptoN - P + 1 ; } sumOfMultiplesOfP = ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ; return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; } public static void main ( String [ ] args ) { int N = 10 , P = 5 ; System . out . println ( func ( N , P ) ) ; } }"}
{"text": "Kira peralihan kanan untuk setiap elemen array berada dalam kedudukan yang disusun | Program Java untuk melaksanakan pendekatan; Berfungsi untuk mencari peralihan yang betul yang diperlukan untuk setiap elemen untuk mencapai kedudukan array yang disusun dalam []; Kedai yang diperlukan bilangan peralihan untuk setiap elemen; Jika elemen berada pada kedudukan yang disusun; Jika tidak; Kirakan peralihan kanan; Cetak peralihan masing -masing; Kod pemacu", "code": "class GFG { public static void findShifts ( int [ ] A , int N ) { int [ ] shift = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( shift [ i ] + \" ▁ \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 3 , 2 , 5 } ; int N = arr . length ; findShifts ( arr , N ) ; } }"}
{"text": "Membina matriks dengan jumlah yang sama dengan jumlah unsur pepenjuru | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk membina matriks dengan jumlah pepenjuru yang sama dengan jumlah matriks; Jika kedudukan pepenjuru; Elemen positif; Elemen negatif; Kod pemacu", "code": "public class Main { public static void constructmatrix ( int N ) { boolean check = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) { System . out . print ( \"1 ▁ \" ) ; } else if ( check ) { System . out . print ( \"2 ▁ \" ) ; check = false ; } else { System . out . print ( \" - 2 ▁ \" ) ; check = true ; } } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int N = 5 ; constructmatrix ( 5 ) ; } }"}
{"text": "Kiraan minimum nombor yang diperlukan dengan unit digit x yang merangkum sehingga n | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan bilangan minimum kali nombor dengan unit digit X perlu ditambah untuk mendapatkan jumlah n; Kirakan bilangan penambahan yang diperlukan untuk mendapatkan digit unit N; Jika digit unit n tidak dapat diperoleh; Berfungsi untuk mengembalikan nombor minimum yang diperlukan untuk mewakili n; Kedai Unit Digit N; Penambahan minimum x yang diperlukan untuk mendapatkan digit unit N; Jika digit unit n tidak dapat diperoleh; Jika tidak; Jika n lebih besar daripada atau sama dengan (x * kali); Kiraan minimum nombor yang diperlukan untuk mewakili n; Perwakilan tidak mungkin; Kod pemacu", "code": "class GFG { static int check ( int unit_digit , int X ) { int times , digit ; for ( times = 1 ; times <= 10 ; times ++ ) { digit = ( X * times ) % 10 ; if ( digit == unit_digit ) return times ; } return - 1 ; } static int getNum ( int N , int X ) { int unit_digit ; unit_digit = N % 10 ; int times = check ( unit_digit , X ) ; if ( times == - 1 ) return times ; else { if ( N >= ( times * X ) ) return times ; else return - 1 ; } } public static void main ( String [ ] args ) { int N = 58 , X = 7 ; System . out . println ( getNum ( N , X ) ) ; } }"}
{"text": "Bilangan minimum mata yang diperlukan untuk menampung semua blok 2 | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum mata yang diperlukan untuk menampung grid; Jika bilangan blok adalah juga; Mengembalikan mata minimum; Kod pemacu; Diberikan saiz grid; Panggilan fungsi", "code": "class GFG { static int minPoints ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; } public static void main ( String [ ] args ) { int N = 5 , M = 7 ; System . out . print ( minPoints ( N , M ) ) ; } }"}
{"text": "String lexicographical terbesar dengan paling banyak unsur berturut -turut K | Kod Java untuk pendekatan di atas; Fungsi untuk mencari rentetan leksikografi terbesar dengan kekangan yang diberikan. ; Vektor yang mengandungi kekerapan setiap aksara. ; Menetapkan kekerapan; Kosongkan rentetan jenis kelas rentetan; Gelung untuk melangkah ke atas keutamaan maksimum terlebih dahulu. ; Jika kekerapan lebih besar daripada atau sama dengan k. ; Pembolehubah sementara untuk beroperasi di tempat k. ; Menggabungkan dengan rentetan yang dihasilkan. ; Pengendalian kes K dengan menyesuaikan dengan unsur keutamaan yang lebih kecil. ; Keadaan untuk mengesahkan sama ada indeks j mempunyai kekerapan yang lebih besar daripada 0; ; Jika tiada elemen sedemikian dijumpai daripada rentetan tidak dapat diproses lagi. ; Jika kekerapan lebih besar daripada 0 dan kurang daripada k. ; Di sini kita tidak perlu memperbaiki kriteria elemen berturut -turut. ; Jika tidak, periksa elemen seterusnya yang mungkin. ; Kod pemacu", "code": "import java . util . * ; class GFG { static String getLargestString ( String s , int k ) { int [ ] frequency_array = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { frequency_array [ s . charAt ( i ) - ' a ' ] ++ ; } String ans = \" \" ; for ( int i = 25 ; i >= 0 { if ( frequency_array [ i ] > k ) { int temp = k ; String st = String . valueOf ( ( char ) ( i + ' a ' ) ) ; while ( temp > 0 ) { ans += st ; temp -- ; } frequency_array [ i ] -= k ; int j = i - 1 ; while ( frequency_array [ j ] <= 0 && j >= 0 ) { j -- ; } if ( frequency_array [ j ] > 0 && j >= 0 ) { String str = String . valueOf ( ( char ) ( j + ' a ' ) ) ; ans += str ; frequency_array [ j ] -= 1 ; } else { break ; } } else if ( frequency_array [ i ] > 0 ) { int temp = frequency_array [ i ] ; frequency_array [ i ] -= temp ; String st = String . valueOf ( ( char ) ( i + ' a ' ) ) ; while ( temp > 0 ) { ans += st ; temp -- ; } } else { i -- ; } } return ans ; } public static void main ( String [ ] args ) { String S = \" xxxxzza \" ; int k = 3 ; System . out . print ( getLargestString ( S , k ) ) ; } }"}
{"text": "Operasi minimum untuk menjadikan semua elemen sama menggunakan array kedua | Pelaksanaan Java untuk mencari operasi minimum menjadikan semua elemen sama menggunakan array kedua; Berfungsi untuk mencari operasi minimum yang diperlukan untuk membuat semua elemen array sama; Elemen minimum []; Melintasi semua nilai akhir; Pembolehubah yang menunjukkan sama ada semua elemen boleh ditukar kepada x atau tidak; Jumlah operasi; Melintasi semua elemen array; Semua elemen tidak boleh ditukar kepada x; Kod pemacu", "code": "import java . util . * ; class GFG { static int minOperations ( int a [ ] , int b [ ] , int n ) { int minA = Arrays . stream ( a ) . min ( ) . getAsInt ( ) ; for ( int x = minA ; x >= 0 ; x -- ) { boolean check = true ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; } public static void main ( String [ ] args ) { int N = 5 ; int A [ ] = { 5 , 7 , 10 , 5 , 15 } ; int B [ ] = { 2 , 2 , 1 , 3 , 5 } ; System . out . print ( minOperations ( A , B , N ) ) ; } }"}
{"text": "Cari jumlah maksimum (a + b) untuk integer input yang diberikan dan memenuhi syarat yang diberikan | Pelaksanaan Java untuk mencari nilai terbesar A + B yang memenuhi syarat yang diberikan; Berfungsi untuk mengembalikan jumlah maksimum A + B yang memenuhi syarat yang diberikan; Memulakan max_sum; Pertimbangkan semua pasangan yang mungkin; Semak sama ada produk itu boleh dibahagikan dengan jumlah; Menyimpan jumlah maksimum dalam pembolehubah max_sum; Kembalikan nilai max_sum; Kod pemacu", "code": "import java . util . * ; class GFG { static int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . max ( max_sum , i + j ) ; } } return max_sum ; } public static void main ( String [ ] args ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; System . out . print ( max_sum ) ; } }"}
{"text": "Memaksimumkan jumlah array selepas mengalikan awalan dan akhiran oleh | Pelaksanaan Java untuk mencari jumlah maksimum array dengan mengalikan awalan dan akhiran array oleh - 1; Algoritma Kadane untuk mencari jumlah subarray maksimum; Gelung untuk mencari jumlah array subarray maksimum dalam array yang diberikan; Berfungsi untuk mencari jumlah maksimum array dengan mengalikan awalan dan akhiran oleh - 1; Jumlah jumlah intital; Gelung untuk mencari jumlah maksimum array; Nilai maksimum; Kod pemacu", "code": "class GFG { static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; } static int maxSum ( int a [ ] , int n ) { int S = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) S += a [ i ] ; int X = maxSubArraySum ( a , n ) ; return 2 * X - S ; } public static void main ( String [ ] args ) { int a [ ] = { - 1 , - 2 , - 3 } ; int n = a . length ; int max_sum = maxSum ( a , n ) ; System . out . print ( max_sum ) ; } }"}
{"text": "Count of Prima yang menarik sehingga n | Program Java untuk mencari bilangan prima yang menarik sehingga N; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Jika n boleh dibahagikan dengan nombor antara 2 dan matematik. sqrt (n), ia bukan perdana; Berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Fungsi untuk mencari bilangan prima yang menarik kurang daripada sama dengan n. ; Periksa sama ada nombor itu adalah perdana atau tidak; Berulang untuk nilai b; Periksa syarat untuk a; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "class GFG { static boolean isPrime ( int n ) { int flag = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; } static boolean isPerfectSquare ( int x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime ( i ) ) { for ( int j = 1 ; j * j * j * j <= i ; j ++ ) { if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } } return answer ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . print ( countInterestingPrimes ( N ) ) ; } }"}
{"text": "Memaksimumkan nombor dengan membalikkan kebanyakan bit k | Pelaksanaan Java pendekatan; Berfungsi untuk menukar nombor perpuluhan n ke perwakilan binari yang disimpan sebagai array arr []; Berfungsi untuk menukar nombor yang diwakili sebagai array perduaan [] ke dalam setara perpuluhannya; Berfungsi untuk mengembalikan nombor yang dimaksimumkan dengan membalikkan atmost k bit; Bilangan bit dalam n; Cari perwakilan binari n; Untuk mengira bilangan 0 s terbalik; Mengembalikan setara perpuluhan nombor yang dimaksimumkan; Kod pemacu", "code": "class GFG { static void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } static int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } static int maxNum ( int n , int k ) { int l = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; int a [ ] = new int [ l ] ; decBinary ( a , n ) ; int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binaryDec ( a , l ) ; } public static void main ( String [ ] args ) { int n = 4 , k = 1 ; System . out . println ( maxNum ( n , k ) ) ; } }"}
{"text": "Cari berikutnya dengan jumlah yang diberikan dalam urutan superincreasing | Pelaksanaan Java pendekatan; Berfungsi untuk mencari seterusnya yang diperlukan; Elemen semasa tidak boleh menjadi sebahagian daripada berikutnya yang diperlukan; Termasuk elemen semasa dalam seterusnya yang diperlukan supaya mengemas kini jumlah; Cetak unsur -unsur berikutnya yang diperlukan; Jika elemen semasa dimasukkan ke dalam berikutnya; Kod pemacu", "code": "class GFG { static void findSubSeq ( int arr [ ] , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = - 1 ; else sum -= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != - 1 ) System . out . print ( arr [ i ] + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 17 , 25 , 46 , 94 , 201 , 400 } ; int n = arr . length ; int sum = 272 ; findSubSeq ( arr , n , sum ) ; } }"}
{"text": "Cari abjad yang paling bernilai dalam rentetan | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan abjad bernilai maksimum; Untuk menyimpan kejadian pertama dan terakhir semua watak; Tetapkan kejadian pertama dan terakhir semua aksara kepada - 1; Kemas kini kejadian watak -watak; Hanya menetapkan kejadian pertama jika ia tidak telah ditetapkan; Untuk menyimpan hasilnya; Untuk setiap abjad; Jika abjad semasa tidak muncul dalam rentetan yang diberikan; Jika watak semasa mempunyai nilai tertinggi setakat ini; Kod pemacu", "code": "class GFG { static int MAX = 26 ; static char maxAlpha ( String str , int len ) { int [ ] first = new int [ MAX ] ; int [ ] last = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str . charAt ( i ) - ' a ' ) ; if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; } int ans = - 1 , maxVal = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == - 1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + ' a ' ) ; } public static void main ( String [ ] args ) { String str = \" abbba \" ; int len = str . length ( ) ; System . out . print ( maxAlpha ( str , len ) ) ; } }"}
{"text": "Pertanyaan untuk bilangan elemen yang berbeza dari indeks yang diberikan sehingga indeks terakhir dalam array | Pelaksanaan Java pendekatan; Berfungsi untuk melakukan pertanyaan untuk mencari bilangan elemen yang berbeza dari indeks yang diberikan sehingga indeks terakhir dalam array; Periksa sama ada elemen semasa sudah dilawati atau tidak; Jika tidak melawat kaunter semasa dan kenaikannya dan semak semak sebagai 1; Jika tidak, jika dikunjungi hanya menyimpan kaunter semasa; Melakukan pertanyaan; Kod pemacu", "code": "import java . util . * ; class GFG { static int MAX = 100001 ; static void find_distinct ( int a [ ] , int n , int q , int queries [ ] ) { int [ ] check = new int [ MAX ] ; int [ ] idx = new int [ MAX ] ; int cnt = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( check [ a [ i ] ] == 0 ) { idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else { idx [ i ] = cnt - 1 ; } } for ( int i = 0 ; i < q ; i ++ ) { int m = queries [ i ] ; System . out . print ( idx [ m ] + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 } ; int n = a . length ; int queries [ ] = { 0 , 3 , 5 , 7 } ; int q = queries . length ; find_distinct ( a , n , q , queries ) ; } }"}
{"text": "Tukar Integer X diberikan kepada Borang 2 ^ n | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan kiraan operasi yang diperlukan; Untuk menyimpan kuasa 2; Pembolehubah sementara untuk menyimpan X; Untuk menyimpan indeks nombor yang lebih kecil daripada x; Untuk menyimpan kiraan operasi; Menyimpan indeks nombor dalam bentuk 2 ^ n - 1; Jika x sudah ada dalam bentuk 2 ^ n - 1 maka tiada operasi diperlukan; Jika nombor kurang daripada x meningkatkan indeks; Kirakan semua nilai (x xor 2 ^ n - 1) untuk semua yang mungkin n; Hanya mengambil nilai yang lebih dekat dengan nombor; Jika nombor berada dalam bentuk 2 ^ n - 1 maka pecah; Mengembalikan kiraan operasi yang diperlukan untuk mendapatkan nombor; Kod pemacu", "code": "import java . io . * ; class GFG { static int MAX = 24 ; static int countOp ( int x ) { int arr [ ] = new int [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; boolean flag = true ; int ans = 0 ; int operations = 0 ; boolean flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; } public static void main ( String [ ] args ) { int x = 39 ; System . out . println ( countOp ( x ) ) ; } }"}
{"text": "Bilangan minimum operasi yang diberikan untuk mengurangkan array ke 0 elemen | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan operasi minimum yang diperlukan; Hitung kekerapan setiap elemen; Elemen maksimum dari array; Cari semua gandaan i; Padamkan gandaan; Meningkatkan operasi; Kod pemacu", "code": "import java . util . Arrays ; class GFG { static int minOperations ( int [ ] arr , int n ) { int maxi , result = 0 ; int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 2 , 4 , 4 , 4 } ; int n = arr . length ; System . out . println ( minOperations ( arr , n ) ) ; } }"}
{"text": "Minimum LCM dan GCD mungkin di antara semua sub | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan GCD minimum di kalangan semua subarray; GCD minimum di antara semua sub -tatasusunan akan menjadi GCD dari semua elemen array; Berfungsi untuk mengembalikan LCM minimum di kalangan semua subarray; LCM minimum di antara semua sub - tatasusunan akan menjadi elemen minimum dari array; Kod pemacu", "code": "class GFG { static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; return __gcd ( b % a , a ) ; } static int minGCD ( int arr [ ] , int n ) { int minGCD = 0 ; for ( int i = 0 ; i < n ; i ++ ) minGCD = __gcd ( minGCD , arr [ i ] ) ; return minGCD ; } static int minLCM ( int arr [ ] , int n ) { int minLCM = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minLCM = Math . min ( minLCM , arr [ i ] ) ; return minLCM ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 66 , 14 , 521 } ; int n = arr . length ; System . out . println ( \" LCM ▁ = ▁ \" + minLCM ( arr , n ) + \" ▁ GCD ▁ = ▁ \" + minGCD ( arr , n ) ) ; } }"}
{"text": "Bentuk rentetan terkecil secara lexicographically dengan penggantian minimum yang mempunyai bilangan yang sama 0 s, 1 s dan 2 s | Pelaksanaan Java pendekatan; Fungsi yang mengembalikan rentetan terkecil lexicographically yang diubahsuai selepas melakukan bilangan minimum operasi yang diberikan; Menyimpan frekuensi awal aksara 0 s, 1 s dan 2 s; Menyimpan bilangan aksara yang diproses sehingga titik setiap jenis; Bilangan aksara yang diperlukan setiap jenis; Jika jenis semasa telah membatalkan bilangan aksara, tidak perlu melakukan apa -apa operasi; Proses semua 3 kes; Semak 1 pertama; Lain 2; Di sini kita perlu menyemak yang diproses [1] hanya untuk 2 kerana 0 adalah kurang daripada 1 dan kita boleh menggantikannya pada bila -bila masa; Di sini kita boleh menggantikan 2 dengan 0 dan 1 bila -bila masa; Simpan kiraan aksara yang diproses setiap jenis; Kod pemacu", "code": "class GFG { static String formStringMinOperations ( char [ ] s ) { int count [ ] = new int [ 3 ] ; for ( char c : s ) { count [ ( int ) c - 48 ] += 1 ; } int processed [ ] = new int [ 3 ] ; int reqd = ( int ) s . length / 3 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( count [ s [ i ] - '0' ] == reqd ) { continue ; } if ( s [ i ] == '0' && count [ 0 ] > reqd && processed [ 0 ] >= reqd ) { if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 0 ] -- ; } else if ( count [ 2 ] < reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 0 ] -- ; } } if ( s [ i ] == '1' && count [ 1 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 1 ] -- ; } else if ( count [ 2 ] < reqd && processed [ 1 ] >= reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 1 ] -- ; } } if ( s [ i ] == '2' && count [ 2 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 2 ] -- ; } else if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 2 ] -- ; } } processed [ s [ i ] - '0' ] ++ ; } return String . valueOf ( s ) ; } public static void main ( String [ ] args ) { String s = \"011200\" ; System . out . println ( formStringMinOperations ( s . toCharArray ( ) ) ) ; } }"}
{"text": "Bilangan minimum swap bersebelahan untuk mengatur unsur -unsur yang sama bersama -sama | Program Java untuk mencari bilangan minimum swap bersebelahan untuk mengatur item yang sama bersama -sama; Berfungsi untuk mencari swap minimum; Arahan yang dikunjungi untuk memeriksa sama ada nilai sudah dilihat; Jika arr [i] dilihat kali pertama; menyimpan bilangan swap yang diperlukan untuk mencari kedudukan yang betul dari rakan kongsi elemen semasa; Kiraan kenaikan hanya jika elemen semasa belum dikunjungi (jika dikunjungi, bermakna ia telah diletakkan pada kedudukan yang betul); Jika rakan kongsi elemen semasa dijumpai; Kod pemacu", "code": "import java . util . * ; class solution { static int findMinimumAdjacentSwaps ( int arr [ ] , int N ) { boolean [ ] visited = new boolean [ N + 1 ] ; int minimumSwaps = 0 ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 3 , 1 , 2 } ; int N = arr . length ; N /= 2 ; System . out . println ( findMinimumAdjacentSwaps ( arr , N ) ) ; } }"}
{"text": "Nombor Palindromic Terbesar dengan Permuting Digits | Program Java untuk mencetak nombor palindromik terbesar dengan membenarkan digit nombor; Berfungsi untuk memeriksa sama ada nombor boleh dibentuk untuk membentuk nombor palindrome; Mengira kejadian nombor yang ganjil; Sekiranya kejadian ganjil; jika nombor melebihi 1; berfungsi untuk mencetak nombor palindromik terbesar dengan membenarkan digit nombor; Panjang rentetan; peta yang menandakan kejadian nombor; Semak kemungkinan nombor palindromik; Array rentetan yang menyimpan nombor palindromik yang terbesar; penunjuk depan; Ramuan bermula dari 9 hingga 0 dan letakkan nombor yang lebih besar di depan dan ganjil di tengah; Sekiranya berlakunya nombor adalah ganjil; Letakkan satu nombor ganjil di tengah; mengurangkan kiraan; Letakkan seluruh nombor dengan tamak; Jika semua nombor berlaku walaupun masa, maka letakkan dengan tamak; Letakkan tamak di hadapan; 2 nombor diletakkan, jadi mengurangkan kiraan; meningkatkan kedudukan meletakkan; Cetak rentetan terbesar yang terbentuk; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean possibility ( HashMap < Integer , Integer > m , int length , String s ) { int countodd = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( m . get ( s . charAt ( i ) - '0' ) % 2 == 1 ) countodd ++ ; if ( countodd > 1 ) return false ; } return true ; } static void largestPalindrome ( String s ) { int l = s . length ( ) ; HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < l ; i ++ ) if ( m . containsKey ( s . charAt ( i ) - '0' ) ) m . put ( s . charAt ( i ) - '0' , m . get ( s . charAt ( i ) - '0' ) + 1 ) ; else m . put ( s . charAt ( i ) - '0' , 1 ) ; if ( possibility ( m , l , s ) == false ) { System . out . print ( \" Palindrome ▁ cannot ▁ be ▁ formed \" ) ; return ; } char [ ] largest = new char [ l ] ; int front = 0 ; for ( int i = 9 ; i >= 0 ; i -- ) { if ( m . containsKey ( i ) && m . get ( i ) % 2 == 1 ) { largest [ l / 2 ] = ( char ) ( i + 48 ) ; m . put ( i , m . get ( i ) - 1 ) ; while ( m . get ( i ) > 0 ) { largest [ front ] = ( char ) ( i + 48 ) ; largest [ l - front - 1 ] = ( char ) ( i + 48 ) ; m . put ( i , m . get ( i ) - 2 ) ; front ++ ; } } else { while ( m . containsKey ( i ) && m . get ( i ) > 0 ) { largest [ front ] = ( char ) ( i + 48 ) ; largest [ l - front - 1 ] = ( char ) ( i + 48 ) ; m . put ( i , m . get ( i ) - 2 ) ; front ++ ; } } } for ( int i = 0 ; i < l ; i ++ ) System . out . print ( largest [ i ] ) ; } public static void main ( String [ ] args ) { String s = \"313551\" ; largestPalindrome ( s ) ; } }"}
{"text": "Swap minimum untuk mengimbangi pendakap | Program Java untuk mengira swap yang diperlukan untuk mengimbangi rentetan; Fungsi untuk mengira swap yang diperlukan; Jejaki '['; Untuk mengira bilangan yang ditemui '['; Untuk mengesan kedudukan seterusnya '[' dalam POS; Untuk menyimpan hasil; Kiraan kenaikan dan bergerak P ke kedudukan seterusnya; Kami telah menemui bahagian rentetan yang tidak seimbang; Jumlah kenaikan dengan bilangan swap yang diperlukan i. e. kedudukan seterusnya '[' - kedudukan semasa; Tetapkan semula kiraan kepada 1; Kod pemacu", "code": "import java . util . * ; class GFG { public static long swapCount ( String s ) { Vector < Integer > pos = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s . charAt ( i ) == ' [ ' ) pos . add ( i ) ; int count = 0 ; int p = 0 ; long sum = 0 ; char [ ] S = s . toCharArray ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( S [ i ] == ' [ ' ) { ++ count ; ++ p ; } else if ( S [ i ] == ' ] ' ) -- count ; if ( count < 0 ) { sum += pos . get ( p ) - i ; char temp = S [ i ] ; S [ i ] = S [ pos . get ( p ) ] ; S [ pos . get ( p ) ] = temp ; ++ p ; count = 1 ; } } return sum ; } public static void main ( String [ ] args ) { String s = \" [ ] ] [ ] [ \" ; System . out . println ( swapCount ( s ) ) ; s = \" [ [ ] [ ] ] \" ; System . out . println ( swapCount ( s ) ) ; } }"}
{"text": "Kos minimum untuk memotong papan ke dalam dataran | Program Java untuk membahagikan papan ke dalam dataran M * n; kaedah mengembalikan kos minimum untuk memecahkan papan ke dalam kotak m * n; menyusun kos mendatar dalam urutan terbalik; menyusun kos menegak dalam urutan terbalik; memulakan lebar semasa sebagai 1; gelung sehingga satu atau kedua -dua kos kos diproses; meningkatkan kiraan bahagian mendatar semasa dengan 1; meningkatkan kiraan bahagian menegak semasa dengan 1; gelung untuk array mendatar, jika kekal; gelung untuk pelbagai menegak, jika kekal; Program Pemandu", "code": "import java . util . Arrays ; import java . util . Collections ; class GFG { static int minimumCostOfBreaking ( Integer X [ ] , Integer Y [ ] , int m , int n ) { int res = 0 ; Arrays . sort ( X , Collections . reverseOrder ( ) ) ; Arrays . sort ( Y , Collections . reverseOrder ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; } public static void main ( String arg [ ] ) { int m = 6 , n = 4 ; Integer X [ ] = { 2 , 1 , 3 , 1 , 4 } ; Integer Y [ ] = { 4 , 1 , 2 } ; System . out . print ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) ; } }"}
{"text": "Kurangkan kiraan aksara yang akan ditambah atau dikeluarkan untuk membuat pengulangan rentetan substring yang sama | Program Java untuk pendekatan di atas; Berfungsi untuk mencari minimum tiga nombor; Berfungsi untuk mencari operasi bilangan minimum yang diperlukan untuk menukar string str1 ke str2 menggunakan operasi; Menyimpan hasil subproblem; Isi dp [] [] dengan cara bawah; Jika str1 kosong, masukkan semua aksara string str2; Operasi minimum ialah J; Jika str2 kosong, maka keluarkan semua aksara string str2; Operasi minimum ialah i; Jika watak terakhir adalah sama, maka abaikan watak terakhir; Jika watak terakhir berbeza, maka cari minimum; Lakukan salah satu sisipan, keluarkan dan ganti; Mengembalikan bilangan langkah minimum yang diperlukan; Berfungsi untuk mencari bilangan langkah minimum untuk mengubah suai rentetan sedemikian rupa sehingga separuh pertama dan separuh kedua menjadi sama; Menyimpan bilangan minimum operasi yang diperlukan; Melintasi rentetan yang diberikan; Cari operasi minimum; Kemas kini ANS; Cetak hasilnya; Kod pemacu", "code": "class GFG { static int getMin ( int x , int y , int z ) { return Math . min ( Math . min ( x , y ) , z ) ; } static int editDistance ( String str1 , String str2 , int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else { dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } } return dp [ m ] [ n ] ; } static void minimumSteps ( String S , int N ) { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { String S1 = S . substring ( 0 , i ) ; String S2 = S . substring ( i ) ; int count = editDistance ( S1 , S2 , S1 . length ( ) , S2 . length ( ) ) ; ans = Math . min ( ans , count ) ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { String S = \" aabb \" ; int N = S . length ( ) ; minimumSteps ( S , N ) ; } }"}
{"text": "Kurangkan operasi untuk mengurangkan n hingga 2 dengan berulang kali mengurangkan 3 atau membahagikan dengan 5 | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum operasi untuk mengurangkan n hingga 2 dengan membahagikan n dengan 5 atau penurunan sebanyak 3; Memulakan array DP; Memulakan array dp []; Untuk n = 2 bilangan operasi yang diperlukan adalah sifar; Melangkah ke atas julat [1, n]; Jika ia tidak mungkin untuk membuat n semasa; Kalikan dengan 5; Menambah nilai 3; Memeriksa jika tidak mungkin untuk membuat nombor sebagai 2; Mengembalikan bilangan operasi minimum; Kod pemacu", "code": "import java . io . * ; class GFG { static int minimumOperations ( int N ) { int [ ] dp = new int [ N + 1 ] ; int i ; for ( i = 0 ; i <= N ; i ++ ) { dp [ i ] = ( int ) 1e9 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { if ( dp [ i ] == ( int ) 1e9 ) continue ; if ( i * 5 <= N ) { dp [ i * 5 ] = Math . min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= N ) { dp [ i + 3 ] = Math . min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } if ( dp [ N ] == 1e9 ) return - 1 ; return dp [ N ] ; } public static void main ( String [ ] args ) { int N = 25 ; System . out . println ( minimumOperations ( N ) ) ; } }"}
{"text": "Keuntungan maksimum selepas membeli dan menjual stok dengan yuran transaksi | Tetapkan 2 | Program Java untuk pendekatan di atas; Berfungsi untuk mencari keuntungan maksimum dengan yuran transaksi; Melintasi stok untuk setiap hari; Kemas kini membeli dan menjual; Mengembalikan keuntungan maksimum; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "import java . io . * ; class GFG { static int MaxProfit ( int arr [ ] , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = Math . max ( buy , sell - arr [ i ] ) ; sell = Math . max ( sell , temp + arr [ i ] - transactionFee ) ; } return Math . max ( sell , buy ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = arr . length ; int transactionFee = 2 ; System . out . println ( MaxProfit ( arr , n , transactionFee ) ) ; } }"}
{"text": "Jumlah maksimum dari kiri ke bawah kanan matriks melalui salah satu sel yang diberikan | Program Java untuk pendekatan di atas; Menyimpan jumlah laluan maksimum dari sel (1, 1) hingga (n, m); Menyimpan jumlah laluan maksimum dari sel (j, j) hingga (n, m); Berfungsi untuk mencari jumlah laluan maksimum dari sel (1, 1) hingga (n, m); Melintasi baris pertama; Melintasi lajur pertama; Melintasi matriks; Kemas kini nilai permulaan [i] [j]; Berfungsi untuk mencari jumlah laluan maksimum dari sel (j, j) hingga (n, m); Melintasi baris terakhir; Melintasi lajur terakhir; Melintasi matriks; Kemas kini nilai berakhir [i] [j]; Berfungsi untuk mencari jumlah laluan maksimum dari atas - kiri ke sel kanan bawah supaya laluan itu mengandungi salah satu sel dalam koordinat array [] []; Memulakan permulaan dan matriks akhir; Kirakan matriks permulaan; Kirakan matriks akhir; Menyimpan jumlah laluan maksimum; Melintasi koordinat; Kemas kini nilai ANS; Cetak nilai laluan jumlah maksimum yang dihasilkan; Kod pemacu", "code": "import java . util . * ; class GFG { static int start [ ] [ ] = new int [ 3 ] [ 3 ] ; static int ending [ ] [ ] = new int [ 3 ] [ 3 ] ; static void calculateStart ( int n , int m ) { for ( int i = 1 ; i < m ; ++ i ) { start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; ++ i ) { start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { start [ i ] [ j ] += Math . max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) ; } } } static void calculateEnd ( int n , int m ) { for ( int i = n - 2 ; i >= 0 ; -- i ) { ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] ; } for ( int i = m - 2 ; i >= 0 ; -- i ) { ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] ; } for ( int i = n - 2 ; i >= 0 ; -- i ) { for ( int j = m - 2 ; j >= 0 ; -- j ) { ending [ i ] [ j ] += Math . max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) ; } } } static void maximumPathSum ( int mat [ ] [ ] , int n , int m , int q , int coordinates [ ] [ ] ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { start [ i ] [ j ] = mat [ i ] [ j ] ; ending [ i ] [ j ] = mat [ i ] [ j ] ; } } calculateStart ( n , m ) ; calculateEnd ( n , m ) ; int ans = 0 ; for ( int i = 0 ; i < q ; ++ i ) { int X = coordinates [ i ] [ 0 ] - 1 ; int Y = coordinates [ i ] [ 1 ] - 1 ; ans = Math . max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int N = 3 ; int M = 3 ; int Q = 2 ; int coordinates [ ] [ ] = { { 1 , 2 } , { 2 , 2 } } ; maximumPathSum ( mat , N , M , Q , coordinates ) ; } }"}
{"text": "Panjang subset terpanjang yang terdiri daripada 0 s dan b 1 s dari pelbagai rentetan | Tetapkan 2 | Program Java untuk pendekatan di atas; Berfungsi untuk mencari panjang subset terpanjang pelbagai rentetan dengan paling banyak 0 s dan b 1 s; Memulakan array 2D dengan penyertaannya sebagai 0; Melintasi array yang diberikan; Simpan kiraan 0 s dan 1 s dalam rentetan semasa; Melangkah dalam julat [a, sifar]; Berulang dalam julat [b, yang]; Mengemas kini nilai dp [i] [j]; Cetak hasilnya; Kod pemacu", "code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int MaxSubsetlength ( String arr [ ] , int A , int B ) { int dp [ ] [ ] = new int [ A + 1 ] [ B + 1 ] ; for ( String str : arr ) { int zeros = 0 , ones = 0 ; for ( char ch : str . toCharArray ( ) ) { if ( ch == '0' ) zeros ++ ; else ones ++ ; } for ( int i = A ; i >= zeros ; i -- ) for ( int j = B ; j >= ones ; j -- ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; } return dp [ A ] [ B ] ; } public static void main ( String [ ] args ) { String arr [ ] = { \"1\" , \"0\" , \"0001\" , \"10\" , \"111001\" } ; int A = 5 , B = 3 ; System . out . println ( MaxSubsetlength ( arr , A , B ) ) ; } }"}
{"text": "Kira cara untuk memilih pasangan gula -gula warna yang berbeza (pengaturcaraan dinamik + bitmasking) | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mengira cara untuk memilih N yang berbeza pasangan gula -gula dengan warna yang berbeza; Jika pasangan N dipilih; Kedai mengira cara untuk memilih pasangan i - th; Melangkah ke atas julat [0, n]; Jika pasangan (i, j) tidak termasuk; Kod pemacu", "code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int numOfWays ( int a [ ] [ ] , int n , int i , HashSet < Integer > blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && ! blue . contains ( j ) ) { blue . add ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . remove ( j ) ; } } return count ; } public static void main ( String [ ] args ) { int n = 3 ; int mat [ ] [ ] = { { 0 , 1 , 1 } , { 1 , 0 , 1 } , { 1 , 1 , 1 } } ; HashSet < Integer > mpp = new HashSet < > ( ) ; System . out . println ( ( numOfWays ( mat , n , 0 , mpp ) ) ) ; } }"}
{"text": "Kurangkan kos untuk mencapai hujung array oleh dua lompatan ke hadapan atau satu lompatan ke belakang dalam setiap langkah | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mencapai akhir array; Kes asas: apabila n <3; Simpan hasil dalam jadual; Memulakan kes asas; Melangkah ke atas julat [2, n - 2] untuk membina array DP; Mengendalikan kes untuk indeks terakhir, i. e. N - 1; Cetak jawapannya; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static void minCost ( int arr [ ] , int n ) { if ( n < 3 ) { System . out . println ( arr [ 0 ] ) ; return ; } int dp [ ] = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = Math . min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; System . out . println ( dp [ n - 1 ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 9 , 4 , 6 , 8 , 5 } ; int N = arr . length ; minCost ( arr , N ) ; } }"}
{"text": "Kirakan nilai 2 yang dibangkitkan kepada kuasa dua kali ganda perwakilan binari n | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mencari nilai kuasa (x, y) dalam o (log y); Kedai kuasa (x, y); Kemas kini x; Kes asas; Hitung kuasa (x, y); Jika y adalah nombor ganjil; Kemas kini res; Kemas kini y; Kemas kini x; Fungsi untuk mengira (2 ^ (2 * x)) % (10 ^ 9 + 7); Kedai perwakilan binari n; Kedai kuasa 10; Kirakan perwakilan binari n; Jika n adalah nombor ganjil; Kemas kini x; Kemas kini pow_10; Kemas kini n; Dua kali ganda nilai x; Menyimpan nilai (2 ^ (2 * x)) % (10 ^ 9 + 7); Kod pemacu", "code": "import java . util . * ; class GFG { static int M = 1000000007 ; static int power ( int X , int Y ) { int res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( ( Y & 1 ) != 0 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } static int findValue ( int n ) { int X = 0 ; int pow_10 = 1 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) { X += pow_10 ; } pow_10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; int res = power ( 2 , X ) ; return res ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( findValue ( n ) ) ; } }"}
{"text": "Kirakan nilai 2 yang dibangkitkan kepada kuasa dua kali ganda perwakilan binari n | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mencari nilai kuasa (x, y) dalam o (log y); Kedai kuasa (x, y); Kemas kini x; Kes asas; Hitung kuasa (x, y); Jika y adalah nombor ganjil; Kemas kini res; Kemas kini y; Kemas kini x; Fungsi untuk mengira (2 ^ (2 * x)) % (10 ^ 9 + 7); dp [n] * dp [n]: Kedai nilai (2 ^ (2 * x)) % (10 ^ 9 + 7); Kes asas; Melangkah ke atas julat [3, n]; Kedai paling tepat dari saya; Menyimpan nilai (i - y); Jika x adalah kuasa 2; Kemas kini DP [i]; Kemas kini DP [i]; Kod pemacu", "code": "class GFG { static final long M = 1000000007 ; static long power ( long X , long Y ) { long res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( Y % 2 == 1 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } static long findValue ( int N ) { long [ ] dp = new long [ N + 1 ] ; dp [ 1 ] = 2 ; dp [ 2 ] = 1024 ; for ( int i = 3 ; i <= N ; i ++ ) { int y = ( i & ( - i ) ) ; int x = i - y ; if ( x == 0 ) { dp [ i ] = power ( dp [ i / 2 ] , 10 ) ; } else { dp [ i ] = ( dp [ x ] * dp [ y ] ) % M ; } } return ( dp [ N ] * dp [ N ] ) % M ; } public static void main ( String [ ] args ) { int n = 150 ; System . out . print ( findValue ( n ) ) ; } }"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Program Java untuk pendekatan di atas; Fungsi untuk mencari bilangan cara untuk mendapatkan jumlah n dengan membuang dadu; Kes asas; Menyimpan jumlah jumlah cara untuk mendapatkan jumlah n; Berulang untuk semua 6 negeri; Jawapan kembali; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int findWays ( int N ) { if ( N == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } } return cnt ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . print ( findWays ( N ) ) ; } }"}
{"text": "Semak jika array boleh dibahagikan kepada 3 seterusnya jumlah yang sama atau tidak | Program Java untuk pendekatan di atas; Fungsi utiliti untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Kes asas; Apabila elemen di Indeks J ditambah kepada SM1; Apabila elemen di Indeks J ditambah kepada SM2; Apabila elemen di Indeks J ditambah kepada SM3; Mengembalikan nilai maksimum di antara semua 3 panggilan rekursif; Fungsi untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Permulaan 3 jumlah ke 0; Panggilan fungsi; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "class GFG { static int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return Math . max ( Math . max ( l , m ) , r ) ; } } static void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = arr . length ; checkEqualSum ( arr , N ) ; } }"}
{"text": "Semak jika array boleh dibahagikan kepada 3 seterusnya jumlah yang sama atau tidak | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa array boleh menjadi partition ke dalam jumlah 3 sama; Kes asas; Jika nilai pada indeks tertentu tidak - 1 maka nilai pulangan pada indeks itu yang memastikan tiada lagi panggilan lagi; Apabila elemen di Indeks J ditambah kepada SM1; Apabila elemen di Indeks J ditambah kepada SM2; Apabila elemen di Indeks J ditambah kepada SM3; Mengemas kini keadaan semasa dan mengembalikan nilai itu; Fungsi untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Permulaan 3 jumlah ke 0; Panggilan fungsi; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "import java . util . * ; class GFG { static HashMap < String , Integer > dp = new HashMap < String , Integer > ( ) ; static int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { String s = String . valueOf ( sm1 ) + \" _ \" + String . valueOf ( sm2 ) + String . valueOf ( j ) ; if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } if ( dp . containsKey ( s ) ) return dp . get ( s ) ; else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; dp . put ( s , Math . max ( Math . max ( l , m ) , r ) ) ; return dp . get ( s ) ; } } static void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = arr . length ; checkEqualSum ( arr , N ) ; } }"}
{"text": "Indeks terkecil dalam pelbagai indeks yang tidak sama dengan x | Program Java untuk mencari indeks terkecil dalam array dalam julat [l, r] yang tidak mengandungi x; Precompute Indeks elemen yang berbeza seterusnya dalam array untuk setiap elemen array; Nilai lalai; Kirakan Nextpos [i] menggunakan Nextpos [i + 1]; Berfungsi untuk mengembalikan indeks terkecil; Nextpos [i] akan menyimpan kedudukan seterusnya p di mana arr [p]! = arr [i]; Jika x tidak hadir di l; Jika tidak; Cari indeks yang menyimpan nilai yang berbeza dari x; Jika indeks itu berada dalam julat; Kod pemacu", "code": "class GFG { static void precompute ( int nextpos [ ] , int arr [ ] , int N ) { nextpos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } } static void findIndex ( int query [ ] [ ] , int arr [ ] , int N , int Q ) { int [ ] nextpos = new int [ N ] ; precompute ( nextpos , arr , N ) ; for ( int i = 0 ; i < Q ; i ++ ) { int l , r , x ; l = query [ i ] [ 0 ] ; r = query [ i ] [ 1 ] ; x = query [ i ] [ 2 ] ; int ans = - 1 ; if ( arr [ l ] != x ) ans = l ; else { int d = nextpos [ l ] ; if ( d <= r ) ans = d ; } System . out . print ( ans + \"NEW_LINE\"); } } public static void main ( String [ ] args ) { int N , Q ; N = 6 ; Q = 3 ; int arr [ ] = { 1 , 2 , 1 , 1 , 3 , 5 } ; int query [ ] [ ] = { { 0 , 3 , 1 } , { 1 , 5 , 2 } , { 2 , 3 , 1 } } ; findIndex ( query , arr , N , Q ) ; } }"}
{"text": "Mengira bilangan cara untuk menukar rentetan s ke t dengan melakukan peralihan kitaran k | Program Java untuk pendekatan di atas; Berfungsi untuk mengira bilangan cara untuk menukar rentetan s ke rentetan t dengan melakukan peralihan kitaran k; Hitung panjang rentetan; 'A' bukan peralihan siklik yang baik 'B' bukan peralihan siklik yang buruk; Iterat dalam rentetan; Precompute bilangan peralihan kitaran yang baik dan buruk; DP2 [i] untuk menyimpan tidak ada cara untuk mendapatkan peralihan yang buruk dalam saya bergerak; Kirakan peralihan yang baik dan buruk; Mengembalikan bilangan cara yang diperlukan; Kod pemacu; Diberikan rentetan; Memandangkan pergeseran k diperlukan; Panggilan fungsi", "code": "class GFG { static long mod = 10000000007L ; static long countWays ( String s , String t , int k ) { int n = s . length ( ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String p = s . substring ( i , n - i ) + s . substring ( 0 , i ) ; if ( p == t ) a ++ ; else b ++ ; } long dp1 [ ] = new long [ k + 1 ] ; long dp2 [ ] = new long [ k + 1 ] ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; } for ( int i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; } return dp1 [ k ] ; } public static void main ( String [ ] args ) { String S = \" ab \" , T = \" ab \" ; int K = 2 ; System . out . print ( countWays ( S , T , K ) ) ; } }"}
{"text": "Kurangkan langkah -langkah untuk mencapai k dari 0 dengan menambah 1 atau menggandakan pada setiap langkah | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari operasi minimum; DP diasaskan untuk menyimpan langkah -langkah; Untuk semua nombor walaupun; Kod pemacu", "code": "class GFG { static int minOperation ( int k ) { int dp [ ] = new int [ k + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; } public static void main ( String [ ] args ) { int K = 12 ; System . out . print ( minOperation ( K ) ) ; } }"}
{"text": "Cari jumlah subset maksimum yang dibentuk dengan memisahkan mana -mana subset array ke dalam 2 partition dengan jumlah yang sama | Pelaksanaan Java untuk pendekatan rekursif yang disebutkan di atas; Berfungsi untuk mencari jumlah subset maksimum; Abaikan elemen semasa; termasuk elemen dalam partition 1; termasuk elemen dalam partition 2; Kod pemacu; saiz array", "code": "class GFG { static int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = Math . max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = Math . max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; } public static void main ( String [ ] args ) { int n = 4 ; int a [ ] = { 1 , 2 , 3 , 6 } ; System . out . println ( maxSum ( 0 , 0 , a , 0 , n ) ) ; } }"}
{"text": "Cari jumlah subset maksimum yang dibentuk dengan memisahkan mana -mana subset array ke dalam 2 partition dengan jumlah yang sama | Pelaksanaan Java untuk pendekatan pengaturcaraan dinamik yang disebutkan di atas; Berfungsi untuk mencari jumlah subset maksimum; jumlah semua elemen; Jadual carian bawah; ; jadual DP yang memulakan dengan int_min di mana, int_min bermaksud tiada penyelesaian; Kes apabila diff adalah 0; Meletakkan elemen ITH dalam G0; Meletakkan elemen ITH dalam G1; Mengabaikan elemen ith; Kod pemacu", "code": "class GFG { final static int INT_MIN = Integer . MIN_VALUE ; static int maxSum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int limit = 2 * sum + 1 ; int dp [ ] [ ] = new int [ n + 1 ] [ limit ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) dp [ i ] [ j ] = INT_MIN ; } dp [ 0 ] [ sum ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) { if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; if ( dp [ i - 1 ] [ j ] != INT_MIN ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ sum ] ; } public static void main ( String [ ] args ) { int n = 4 ; int [ ] a = { 1 , 2 , 3 , 6 } ; System . out . println ( maxSum ( a , n ) ) ; } }"}
{"text": "Count of Strings mungkin dengan menggantikan dua watak yang sama berturut -turut dengan watak baru | Program Java untuk mengira bentuk rentetan yang berbeza dengan menggantikan dua aksara yang sama dengan satu; Array untuk mencari urutan Fibonacci; Berfungsi untuk mencari urutan Fibonacci; Berfungsi untuk mengira semua rentetan yang mungkin; Memulakan ans = 1; Jika dua char berturut -turut adalah peningkatan yang sama CNT; Lain melipatgandakan FIB [CNT] ke Ans dan memulakan Ans hingga 1; Jika str = abcdeeee, maka untuk terakhir \"eeee\" kiraan munst dikemas kini; Mengembalikan jumlah jumlah; Kod pemandu; Berfungsi untuk precompute semua nombor Fibonacci; Fungsi panggilan untuk mencari kiraan", "code": "class GFG { static int fib [ ] = new int [ 100005 ] ; static void computeFibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 100005 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } static int countString ( String str ) { int ans = 1 ; int cnt = 1 ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) { cnt ++ ; } else { ans = ans * fib [ cnt ] ; cnt = 1 ; } } ans = ans * fib [ cnt ] ; return ans ; } public static void main ( String [ ] args ) { String str = \" abdllldefkkkk \" ; computeFibonacci ( ) ; System . out . println ( countString ( str ) ) ; } }"}
{"text": "Urutan Golomb | Tetapkan 2 | Program Java untuk mencari terma pertama N Golomb urutan; Berfungsi untuk mencetak urutan Golomb; Memulakan array; Memulakan CNT hingga 0; Elemen pertama dan kedua urutan Golomb ialah 0, 1; Peta untuk menyimpan kiraan elemen semasa dalam urutan Golomb; Simpan kiraan 2; Melangkah lebih dari 2 hingga n; Jika CNT sama dengan 0 maka kita mempunyai nombor baru untuk urutan Golomb 1 2 2 3 3 4 4 4 5 5 5 yang 1 + elemen sebelumnya; Lain elemen semasa adalah elemen sebelumnya dalam urutan ini; Peta indeks semasa ke nilai semasa dalam arr []; Cetak urutan Golomb; Kod pemacu", "code": "import java . util . * ; class GFG { static int MAX = 1000 ; static void printGolombSequence ( int N ) { int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) arr [ i ] = 0 ; int cnt = 0 ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; Map < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; M . put ( 2 , 2 ) ; for ( int i = 2 ; i <= N ; i ++ ) { if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M . get ( arr [ i ] ) ; cnt -- ; } else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; } M . put ( i , arr [ i ] ) ; } for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( arr [ i ] + \" ▁ \" ) ; } } public static void main ( String args [ ] ) { int N = 11 ; printGolombSequence ( N ) ; } }"}
{"text": "Kira cara untuk mencapai tangga nth dengan mengambil 1 dan 2 langkah dengan tepat satu 3 langkah | Pelaksanaan Java untuk mencari bilangan bilangan cara untuk mencapai tangga nth dengan mengambil 1, 2 langkah pada satu masa dan 3 langkah pada satu masa tepat sekali. ; Berfungsi untuk mencari bilangan bilangan cara untuk mencapai tangga nth; Array termasuk bilangan cara yang merangkumi 3; Array termasuk bilangan cara yang tidak termasuk 3; Pada mulanya untuk mencapai 3 tangga dengan mengambil 3 langkah boleh dicapai dengan 1 cara; Gelung untuk mencari nombor bilangan cara untuk mencapai tangga nth; Kod pemacu", "code": "class GFG { static int number_of_ways ( int n ) { int [ ] includes_3 = new int [ n + 1 ] ; int [ ] not_includes_3 = new int [ n + 1 ] ; includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( number_of_ways ( n ) ) ; } }"}
{"text": "Bilangan maksimum gandaan dalam array sebelum mana -mana elemen | Pelaksanaan Java pendekatan; Peta untuk menyimpan kiraan pembahagi; Berfungsi untuk menjana pembahagi semua elemen array; Berfungsi untuk mencari bilangan maksimum gandaan dalam array sebelum itu; Untuk menyimpan kiraan pembahagi maksimum; Kemas kini Ans Jika lebih banyak bilangan pembahagi dijumpai; Menjana semua pembahagi elemen seterusnya dari array; Kod pemacu", "code": "import java . util . * ; class GFG { static int MAX = 100000 ; static int [ ] divisors = new int [ MAX ] ; static void generateDivisors ( int n ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n / i ] ++ ; } } } } static int findMaxMultiples ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( divisors [ arr [ i ] ] , ans ) ; generateDivisors ( arr [ i ] ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = arr . length ; System . out . print ( findMaxMultiples ( arr , n ) ) ; } }"}
{"text": "Bilangan cara untuk mencapai akhir matriks dengan bukan | Pelaksanaan Java pendekatan; Arahan 3D untuk menyimpan negeri -negeri DP; Array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Fungsi untuk mengembalikan kiraan laluan yang diperlukan; Kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula; Hubungan berulang; Kod pemacu", "code": "class GFG { static int n = 3 ; static int maxV = 20 ; static int [ ] [ ] [ ] dp = new int [ n ] [ n ] [ maxV ] ; static int [ ] [ ] [ ] v = new int [ n ] [ n ] [ maxV ] ; static int countWays ( int i , int j , int x , int arr [ ] [ ] ) { if ( i == n j == n ) { return 0 ; } x = ( x & arr [ i ] [ j ] ) ; if ( x == 0 ) { return 0 ; } if ( i == n - 1 && j == n - 1 ) { return 1 ; } if ( v [ i ] [ j ] [ x ] == 1 ) { return dp [ i ] [ j ] [ x ] ; } v [ i ] [ j ] [ x ] = 1 ; dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i ] [ j ] [ x ] ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 1 } , { 1 , 1 , 0 } , { 2 , 1 , 1 } } ; System . out . println ( countWays ( 0 , 0 , arr [ 0 ] [ 0 ] , arr ) ) ; } }"}
{"text": "Jumlah maksimum dari tiga tatasusunan yang memilih unsur -unsur berturut -turut dari yang sama tidak dibenarkan | Program Java untuk pendekatan di atas; Berfungsi untuk mengembalikan jumlah maksimum; Kes asas; Sudah dikunjungi; Jika elemen telah diambil dari array pertama dalam langkah sebelumnya; Jika elemen telah diambil dari array kedua dalam langkah sebelumnya; Jika elemen telah diambil dari array ketiga dalam langkah sebelumnya; Kod pemacu; Pilih elemen dari array pertama; Pilih elemen dari array kedua; Pilih elemen dari array ketiga; Cetak maksimum mereka", "code": "class GFG { static int N = 3 ; static int FindMaximumSum ( int ind , int kon , int a [ ] , int b [ ] , int c [ ] , int n , int dp [ ] [ ] ) { if ( ind == n ) return 0 ; if ( dp [ ind ] [ kon ] != - 1 ) return dp [ ind ] [ kon ] ; int ans = ( int ) ( - 1e9 + 5 ) ; if ( kon == 0 ) { ans = Math . max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 1 ) { ans = Math . max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 2 ) { ans = Math . max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; } return dp [ ind ] [ kon ] = ans ; } public static void main ( String [ ] args ) { int a [ ] = { 6 , 8 , 2 , 7 , 4 , 2 , 7 } ; int b [ ] = { 7 , 8 , 5 , 8 , 6 , 3 , 5 } ; int c [ ] = { 8 , 3 , 2 , 6 , 8 , 4 , 1 } ; int n = a . length ; int dp [ ] [ ] = new int [ n ] [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } int x = FindMaximumSum ( 0 , 0 , a , b , c , n , dp ) ; int y = FindMaximumSum ( 0 , 1 , a , b , c , n , dp ) ; int z = FindMaximumSum ( 0 , 2 , a , b , c , n , dp ) ; System . out . println ( Math . max ( x , Math . max ( y , z ) ) ) ; } }"}
{"text": "Bilangan cara untuk membuat rentetan panjang panjang n sedemikian rupa sehingga 0 s sentiasa berlaku bersama dalam kumpulan saiz k | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan tidak ada cara untuk membina rentetan panjang binari sehingga 0 s selalu berlaku dalam kumpulan saiz k; Kod pemacu", "code": "import java . util . * ; class GFG { static int mod = 1000000007 ; static int noOfBinaryStrings ( int N , int k ) { int dp [ ] = new int [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; } public static void main ( String [ ] args ) { int N = 4 ; int K = 2 ; System . out . println ( noOfBinaryStrings ( N , K ) ) ; } }"}
{"text": "Bilangan cara untuk memasangkan orang | Program Java untuk mencari beberapa cara untuk memasangkan orang dalam parti; Berfungsi untuk mencari bilangan cara untuk memasangkan orang dalam parti; Untuk menyimpan jumlah cara. ; Menggunakan kiraan cari yang ditakrifkan berulang untuk nilai yang berbeza p. ; Kod pemacu", "code": "class GFG { static int findWaysToPair ( int p ) { int dp [ ] = new int [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; } public static void main ( String args [ ] ) { int p = 3 ; System . out . println ( findWaysToPair ( p ) ) ; } }"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pelaksanaan rekursif mudah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; kes asas; Untuk kes n> 2; Kod pemacu", "code": "import java . io . * ; class GFG { static int CountWays ( int n ) { if ( n == 0 ) { return 1 ; } if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 1 + 1 ; } return CountWays ( n - 1 ) + CountWays ( n - 3 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n ) ) ; } }"}
{"text": "Nombor pelik | Program Java untuk memeriksa sama ada nombor itu pelik atau tidak; Kod untuk mencari semua faktor nombor tidak termasuk nombor itu sendiri; Arraylist untuk menyimpan faktor -faktor; Perhatikan bahawa gelung ini berjalan sehingga sqrt (n); jika nilai saya adalah faktor; Keadaan untuk memeriksa pembahagi bukan nombor itu sendiri; mengembalikan arraylist; Berfungsi untuk memeriksa sama ada nombor itu banyak atau tidak; Cari pembahagi menggunakan fungsi; Jumlah semua faktor; Periksa banyak atau tidak; Berfungsi untuk memeriksa sama ada nombor itu separuh - sempurna atau tidak; Cari pembahagi; menyusun arraylist; subset untuk memeriksa sama ada tidak semiperfect; memulakan lajur 1 st untuk benar; memulakan baris 1 st kecuali kedudukan sifar ke 0; gelung untuk mencari sama ada nombor itu semiperfect; pengiraan untuk memeriksa sama ada nombor itu boleh dibuat dengan penjumlahan pembahagi; jika tidak mungkin untuk membuat nombor dengan gabungan mana -mana pembahagi; Berfungsi untuk memeriksa pelik atau tidak; Kod pemacu", "code": "import java . util . * ; class GFG { static ArrayList < Integer > factors ( int n ) { ArrayList < Integer > v = new ArrayList < Integer > ( ) ; v . add ( 1 ) ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v . add ( i ) ; if ( n / i != i ) { v . add ( n / i ) ; } } } return v ; } static boolean checkAbundant ( int n ) { ArrayList < Integer > v ; int sum = 0 ; v = factors ( n ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { sum += v . get ( i ) ; } if ( sum > n ) return true ; else return false ; } static boolean checkSemiPerfect ( int n ) { ArrayList < Integer > v ; v = factors ( n ) ; Collections . sort ( v ) ; int r = v . size ( ) ; boolean subset [ ] [ ] = new boolean [ r + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= r ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j < v . get ( i - 1 ) ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; else { subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - v . get ( i - 1 ) ] ; } } } if ( ( subset [ r ] [ n ] ) == false ) return false ; else return true ; } static boolean checkweird ( int n ) { if ( checkAbundant ( n ) == true && checkSemiPerfect ( n ) == false ) return true ; else return false ; } public static void main ( String args [ ] ) { int n = 70 ; if ( checkweird ( n ) ) System . out . println ( \" Weird ▁ Number \" ) ; else System . out . println ( \" Not ▁ Weird ▁ Number \" ) ; } }"}
{"text": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | Program Java untuk mencetak jumlah array bersebelahan terbesar apabila array dicipta selepas menggabungkan kali array kecil. ; Mengembalikan jumlah maksimum subarray yang dibuat selepas menggabungkan [0 .. n - 1] k kali. ; Di sinilah ia berbeza dari algoritma Kadane. Kami menggunakan aritmetik modular untuk mencari elemen seterusnya. ; Program pemacu untuk menguji maxsubarraysum", "code": "import java . io . * ; class GFG { static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = 0 ; int INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } public static void main ( String [ ] args ) { int a [ ] = { 10 , 20 , - 30 , - 1 } ; int n = a . length ; int k = 3 ; System . out . println ( \" Maximum ▁ contiguous ▁ sum ▁ is ▁ \" + maxSubArraySumRepeated ( a , n , k ) ) ; } }"}
{"text": "Terpanjang peningkatan ganjil walaupun berikutnya | Pelaksanaan Java untuk mencari peningkatan yang paling lama walaupun seterusnya; berfungsi untuk mencari peningkatan yang paling lama walaupun seterusnya; lioes [i] menyimpan paling lama meningkatkan ganjil walaupun berikutnya yang berakhir di arr [i]; untuk menyimpan panjang yang paling lama meningkat ganjil walaupun berikutnya; Memulakan nilai lio untuk semua indeks; Mengira nilai lio yang dioptimumkan dengan cara bawah; Pilih maksimum semua nilai lio; panjang maksimum yang diperlukan; fungsi pemacu", "code": "import java . util . * ; import java . lang . * ; public class GfG { public static int longOddEvenIncSeq ( int arr [ ] , int n ) { int [ ] lioes = new int [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; } public static void main ( String argc [ ] ) { int [ ] arr = new int [ ] { 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 } ; int n = 10 ; System . out . println ( \" Longest ▁ Increasing ▁ Odd \" + \" ▁ Even ▁ Subsequence : ▁ \" + longOddEvenIncSeq ( arr , n ) ) ; } }"}
{"text": "Nilai minimum dan maksimum ungkapan dengan * dan + | Program Java untuk mendapatkan nilai maksimum dan minimum ungkapan; Kaedah utiliti untuk memeriksa sama ada watak adalah pengendali atau tidak; kaedah mencetak nilai minimum dan maksimum yang boleh diperolehi daripada ungkapan; pengendali kedai dan nombor dalam vektor yang berbeza; menyimpan nombor terakhir dalam vektor; memulakan array Minval dan Maxval 2D; memulakan pepenjuru utama dengan nilai NUM; Looping serupa dengan pendaraban rantai matriks dan mengemas kini kedua -dua tatasusunan 2D; Jika pengendali semasa adalah ' +', mengemas kini pembolehubah TMP dengan tambahan; Jika pengendali semasa adalah ' *', mengemas kini pembolehubah TMP dengan pendaraban; mengemas kini nilai array oleh pembolehubah TMP; Elemen terakhir baris pertama akan menyimpan hasilnya; Kod pemacu untuk menguji kaedah di atas", "code": "import java . io . * ; import java . util . * ; class GFG { static boolean isOperator ( char op ) { return ( op == ' + ' op == ' * ' ) ; } static void printMinAndMaxValueOfExp ( String exp ) { Vector < Integer > num = new Vector < Integer > ( ) ; Vector < Character > opr = new Vector < Character > ( ) ; String tmp = \" \" ; for ( int i = 0 ; i < exp . length ( ) ; i ++ ) { if ( isOperator ( exp . charAt ( i ) ) ) { opr . add ( exp . charAt ( i ) ) ; num . add ( Integer . parseInt ( tmp ) ) ; tmp = \" \" ; } else { tmp += exp . charAt ( i ) ; } } num . add ( Integer . parseInt ( tmp ) ) ; int len = num . size ( ) ; int [ ] [ ] minVal = new int [ len ] [ len ] ; int [ ] [ ] maxVal = new int [ len ] [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { minVal [ i ] [ j ] = Integer . MAX_VALUE ; maxVal [ i ] [ j ] = 0 ; if ( i == j ) minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num . get ( i ) ; } } for ( int L = 2 ; L <= len ; L ++ ) { for ( int i = 0 ; i < len - L + 1 ; i ++ ) { int j = i + L - 1 ; for ( int k = i ; k < j ; k ++ ) { int minTmp = 0 , maxTmp = 0 ; if ( opr . get ( k ) == ' + ' ) { minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] ; } else if ( opr . get ( k ) == ' * ' ) { minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] ; } if ( minTmp < minVal [ i ] [ j ] ) minVal [ i ] [ j ] = minTmp ; if ( maxTmp > maxVal [ i ] [ j ] ) maxVal [ i ] [ j ] = maxTmp ; } } } System . out . print ( \" Minimum ▁ value ▁ : ▁ \" + minVal [ 0 ] [ len - 1 ] + \" , ▁ Maximum ▁ value ▁ : ▁ \" + maxVal [ 0 ] [ len - 1 ] ) ; } public static void main ( String [ ] args ) { String expression = \"1 + 2*3 + 4*5\" ; printMinAndMaxValueOfExp ( expression ) ; } }"}
{"text": "Pendaraban rantai matriks | DP | Pelaksanaan rekursif naif yang hanya mengikuti harta substruktur yang optimum di atas; Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Letakkan kurungan di tempat yang berbeza antara matriks pertama dan terakhir, mengira kiraan pendaraban untuk setiap penempatan kurungan dan mengembalikan kiraan minimum; Mengembalikan kiraan minimum; Kod pemacu", "code": "class MatrixChainMultiplication { static int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 , 3 } ; int n = arr . length ; System . out . println ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" + MatrixChainOrder ( arr , 1 , n - 1 ) ) ; } }"}
{"text": "Pendaraban rantai matriks | DP | Program Java menggunakan memoisasi; Fungsi untuk pendaraban rantai matriks; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static int [ ] [ ] dp = new int [ 100 ] [ 100 ] ; static int matrixChainMemoised ( int [ ] p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } static int MatrixChainOrder ( int [ ] p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; System . out . println ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" + MatrixChainOrder ( arr , n ) ) ; } }"}
{"text": "Nombor yang dibentuk dengan membalikkan bit set biasa dalam dua bilangan bulat yang diberikan | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk membalikkan bit A dan B yang ditetapkan dalam kedua -dua mereka; Kosongkan bit A yang ditetapkan dalam kedua -dua A dan B; Kosongkan bit B yang ditetapkan dalam kedua -dua A dan B; Cetak dikemas kini A dan B; Kod pemacu", "code": "import java . util . * ; class GFG { static void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; System . out . print ( A + \" ▁ \" + B ) ; } public static void main ( String [ ] args ) { int A = 10 , B = 20 ; flipBitsOfAandB ( A , B ) ; } }"}
{"text": "Jumlah perbezaan perbezaan nombor berturut -turut dari 0 hingga n | Tetapkan 2 | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan jarak Hamming antara semua nombor berturut -turut dari 0 hingga n; Kod pemacu", "code": "import java . util . * ; class GFG { static int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; } public static void main ( String [ ] args ) { int N = 9 ; System . out . println ( TotalHammingDistance ( N ) ) ; } }"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | Set 3 | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mencari jumlah semua pembahagi semua nombor dari 1 hingga n; Menyimpan jumlah; Menandakan titik terakhir kejadian dengan kiraan yang sama; Kirakan jumlahnya; Mengembalikan hasilnya; Kod pemacu", "code": "import java . util . * ; class GFG { static final int m = 1000000007 ; static void solve ( long n ) { long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = ( int ) ( n / Math . floor ( n / l ) ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( int ) ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } System . out . print ( ( s + m ) % m ) ; } public static void main ( String [ ] args ) { long n = 12 ; solve ( n ) ; } }"}
{"text": "Kurangkan bilangan luka yang diperlukan untuk memecahkan panjang n tongkat ke dalam n unit panjang tongkat | Program Java untuk mencari masa minimum yang diperlukan untuk memecah tongkat panjang N ke dalam kepingan unit; Berfungsi untuk mengembalikan masa minimum yang diperlukan untuk memecah tongkat n ke dalam kepingan unit; Mengembalikan unit minimum masa yang diperlukan; Kod pemacu", "code": "import java . lang . * ; class GFG { static int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ( int ) Math . ceil ( Math . log ( N ) / Math . log ( 2 ) ) ; } public static void main ( String [ ] args ) { int N = 100 ; System . out . print ( min_time_to_cut ( N ) ) ; } }"}
{"text": "Kira jumlah pasangan yang berbeza antara dua array nilai 1 hingga n | Pelaksanaan Java untuk mengira jumlah pasangan yang berbeza antara dua array dengan nilai 1 hingga n; Berfungsi untuk mencari jumlah yang berbeza; Tetapkan untuk menyimpan jumlah yang berbeza; Memasukkan setiap jumlah; Kembali jumlah yang berbeza; Kod pemacu", "code": "import java . util . * ; class GFG { static int findDistinctSums ( int n ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . add ( i + j ) ; } } return s . size ( ) ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( findDistinctSums ( N ) ) ; } }"}
{"text": "Cetak Segitiga Terasing Corak | Program Java untuk mencetak corak terpisah segitiga menggunakan watak bintang dan slash; Berfungsi untuk mencetak corak secara rekursif; Kes asas; Syarat untuk mencetak slash; Keadaan untuk mencetak slash forword; Keadaan untuk mencetak slash ke belakang; Lain cetak ' *'; Panggilan rekursif untuk baris; Panggilan rekursif untuk menukar baris; Kod pemacu; Panggilan fungsi", "code": "class GFG { static int printPattern ( int i , int j , int n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i j == n - 1 - i ) { if ( i == n - 1 - j ) { System . out . print ( \" / \" ) ; } else { System . out . print ( \" \\ \\\" ) ; } } else { System . out . print ( \" * \" ) ; } if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } System . out . println ( ) ; return printPattern ( i + 1 , 0 , n ) ; } public static void main ( String [ ] args ) { int N = 9 ; printPattern ( 0 , 0 , N ) ; } }"}
{"text": "Cari indeks permulaan untuk setiap kejadian array yang diberikan b dalam array A menggunakan z | Pelaksanaan Java untuk mencari corak dalam array menggunakan algoritma Z; Fungsi untuk mengira z - array; Gelung untuk mengira z - array; Di luar kotak z; Di dalam z - kotak; Fungsi penolong untuk menggabungkan dua tatasusunan dan membuat satu array; Array untuk menyimpan array yang digabungkan; Menyalin Array B; Menambah pemisah; Menyalin Array A; Memanggil Z - Fungsi; Fungsi untuk membantu mengira array Z; Indeks percetakan di mana array b berlaku; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GfG { private static int [ ] zArray ( int arr [ ] ) { int z [ ] ; int n = arr . length ; z = new int [ n ] ; int r = 0 , l = 0 ; for ( int k = 1 ; k < n ; k ++ ) { if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } else { int k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; } private static int [ ] mergeArray ( int A [ ] , int B [ ] ) { int n = A . length ; int m = B . length ; int z [ ] ; int c [ ] = new int [ n + m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ; c [ m ] = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ; z = zArray ( c ) ; return z ; } private static void findZArray ( int A [ ] , int B [ ] , int n ) { int flag = 0 ; int z [ ] ; z = mergeArray ( A , B ) ; for ( int i = 0 ; i < z . length ; i ++ ) { if ( z [ i ] == n ) { System . out . print ( ( i - n - 1 ) + \" ▁ \" ) ; flag = 1 ; } } if ( flag == 0 ) { System . out . println ( \" Not ▁ Found \" ) ; } } public static void main ( String args [ ] ) { int A [ ] = { 1 , 2 , 3 , 2 , 3 , 2 } ; int B [ ] = { 2 , 3 } ; int n = B . length ; findZArray ( A , B , n ) ; } }"}
{"text": "Semak jika rentetan boleh diulang untuk membuat rentetan lain | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan kiraan pengulangan String A untuk menjana rentetan b; Jika B tidak dapat dihasilkan dengan mengulangi A; Ulangi jumlah kiraan; Kod pemacu", "code": "class GfG { static int getCount ( String a , String b ) { if ( b . length ( ) % a . length ( ) != 0 ) return - 1 ; int count = b . length ( ) / a . length ( ) ; String str = \" \" ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str . equals ( b ) ) return count ; return - 1 ; } public static void main ( String [ ] args ) { String a = \" geeks \" ; String b = \" geeksgeeks \" ; System . out . println ( getCount ( a , b ) ) ; } }"}
{"text": "Semak jika rentetan boleh dibentuk dari rentetan lain menggunakan kekangan yang diberikan | Program Java untuk memeriksa sama ada rentetan yang diberikan boleh dibentuk dari rentetan lain menggunakan kekangan yang diberikan; Fungsi untuk memeriksa sama ada S2 boleh dibentuk dari S1; panjang rentetan; Hash - Jadual untuk menyimpan kiraan; menyimpan kiraan setiap watak; melintasi dan memeriksa setiap watak; Jika watak S2 hadir dalam S1; Jika watak S2 tidak hadir dalam S1, maka periksa sama ada dua aksara ASCII terdahulu hadir dalam S1; Kod pemacu; Fungsi panggilan untuk memeriksa", "code": "import java . util . * ; class GFG { static boolean check ( String S1 , String S2 ) { int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( mp . containsKey ( ( int ) S1 . charAt ( i ) ) ) { mp . put ( ( int ) S1 . charAt ( i ) , mp . get ( ( int ) S1 . charAt ( i ) ) + 1 ) ; } else { mp . put ( ( int ) S1 . charAt ( i ) , 1 ) ; } } for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp . containsKey ( ( int ) S2 . charAt ( i ) ) ) { mp . put ( ( int ) S2 . charAt ( i ) , mp . get ( ( int ) S2 . charAt ( i ) ) - 1 ) ; } else if ( mp . containsKey ( S2 . charAt ( i ) - 1 ) && mp . containsKey ( S2 . charAt ( i ) - 2 ) ) { mp . put ( ( S2 . charAt ( i ) - 1 ) , mp . get ( S2 . charAt ( i ) - 1 ) - 1 ) ; mp . put ( ( S2 . charAt ( i ) - 2 ) , mp . get ( S2 . charAt ( i ) - 2 ) - 1 ) ; } else { return false ; } } return true ; } public static void main ( String [ ] args ) { String S1 = \" abbat \" ; String S2 = \" cat \" ; if ( check ( S1 , S2 ) ) System . out . print ( \" YES \" ) ; else System . out . print ( \" NO \" ) ; } }"}
{"text": "Count kejadian corak \"1 (0 +) 1\" dalam rentetan | Program Java untuk mengira bilangan kali corak berlaku dalam rentetan yang diberikan; Mengembalikan kiraan kejadian \"1 (0 +) 1\" int str. ; int count = 0; Memulakan hasil; Semak jika ditemui '1' membentuk corak yang sah seperti yang ditentukan; jika 1 ditemui untuk pertama kali ditetapkan satu ke 1; Semak jika terdapat watak lain selain daripada '0' atau '1'. Jika demikian kemudian tetapkan Oneseen hingga 0 untuk mencari lagi untuk corak baru; Program pemacu untuk menguji fungsi di atas", "code": "public class GFG { static int countPattern ( String str ) { int len = str . length ( ) ; boolean oneSeen = false ; for ( int i = 0 ; i < len ; i ++ ) { char getChar = str . charAt ( i ) ; if ( getChar == '1' && oneSeen == true ) { if ( str . charAt ( i - 1 ) == '0' ) count ++ ; } if ( getChar == '1' && oneSeen == false ) oneSeen = true ; if ( getChar != '0' && str . charAt ( i ) != '1' ) oneSeen = false ; } return count ; } public static void main ( String [ ] args ) { String str = \"100001abc101\" ; System . out . println ( countPattern ( str ) ) ; } }"}
{"text": "Tukar rentetan yang diberikan ke dalam T dengan menggantikan aksara di antara rentetan sebilangan kali | Program Java untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada mungkin untuk membuat semua rentetan sama dengan rentetan t; Menyimpan kekerapan semua rentetan dalam array arr []; Menyimpan kekerapan rentetan t; Melangkah ke atas watak -watak rentetan t; Melangkah dalam julat [0, n - 1]; Melangkah ke atas watak -watak rentetan arr [i]; Jika freqt [i] adalah 0 dan freqs [i] bukan 0; Jika freqs [i] adalah 0 dan freqt [i] bukan 0; Jika freqs [i] bukan freqt [i] * n; Jika tidak, kembalikan \"ya\"; Kod pemacu", "code": "public class GFG { static String checkIfPossible ( int N , String [ ] arr , String T ) { int [ ] freqS = new int [ 256 ] ; int [ ] freqT = new int [ 256 ] ; for ( char ch : T . toCharArray ( ) ) { freqT [ ch - ' a ' ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( char ch : arr [ i ] . toCharArray ( ) ) { freqS [ ch - ' a ' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return \" No \" ; } else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return \" No \" ; } else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return \" No \" ; } } return \" Yes \" ; } public static void main ( String [ ] args ) { String [ ] arr = { \" abc \" , \" abb \" , \" acc \" } ; String T = \" abc \" ; int N = arr . length ; System . out . println ( checkIfPossible ( N , arr , T ) ) ; } }"}
{"text": "Count kumpulan berturut -turut 1 s dalam rentetan binari yang diberikan | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan kumpulan 1 s hanya dalam rentetan binari; Kedai bilangan kumpulan 1 s; Permulaan timbunan; Melintasi rentetan s; Jika s [i] adalah '1'; Jika tidak; Jika St kosong; Jika ST tidak kosong; Jawapan kembali; Kod pemacu; Input; Panggilan fungsi", "code": "import java . util . Stack ; class GFG { static int groupsOfOnes ( String S , int N ) { int count = 0 ; Stack < Integer > st = new Stack < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == '1' ) st . push ( 1 ) ; else { if ( ! st . empty ( ) ) { count ++ ; while ( ! st . empty ( ) ) { st . pop ( ) ; } } } } if ( ! st . empty ( ) ) count ++ ; return count ; } public static void main ( String [ ] args ) { String S = \"100110111\" ; int N = S . length ( ) ; System . out . println ( groupsOfOnes ( S , N ) ) ; } }"}
{"text": "Palindromic Strings of Length 3 mungkin dengan menggunakan aksara rentetan yang diberikan | Program Java untuk pendekatan di atas; Berfungsi untuk mencetak semua rentetan palindromik panjang 3 yang boleh dibentuk menggunakan aksara rentetan s; Menyimpan kiraan watak; Melintasi rentetan s; Menyimpan semua rentetan palindromik; Melangkah ke atas charchaters ke atas julat ['a', 'z']; Jika hash [ch] sama dengan 2; Melangkah ke atas watak -watak di atas julat ['a', 'z']; Menyimpan semua rentetan palindromik; Tolak S ke set st; Jika hash [i] lebih besar daripada atau sama dengan 3; Melangkah ke atas charchaters ke atas julat ['a', 'z']; Menyimpan semua rentetan palindromik; Jika hash [j] positif; Tolak s ke set st; Melangkah ke atas set; Kod pemacu", "code": "import java . util . * ; public class Main { static void generatePalindrome ( String S ) { HashMap < Character , Integer > Hash = new HashMap < > ( ) ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( Hash . containsKey ( S . charAt ( i ) ) ) Hash . put ( S . charAt ( i ) , Hash . get ( S . charAt ( i ) ) + 1 ) ; else Hash . put ( S . charAt ( i ) , 1 ) ; } TreeSet < String > st = new TreeSet < String > ( ) ; for ( char i = ' a ' ; i <= ' z ' ; i ++ ) { if ( Hash . containsKey ( i ) && Hash . get ( i ) == 2 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { String s = \" \" ; if ( Hash . containsKey ( j ) && i != j ) { s += i ; s += j ; s += i ; st . add ( s ) ; } } } if ( Hash . containsKey ( i ) && Hash . get ( i ) >= 3 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { String s = \" \" ; if ( Hash . containsKey ( j ) ) { s += i ; s += j ; s += i ; st . add ( s ) ; } } } } for ( String ans : st ) { System . out . println ( ans ) ; } } public static void main ( String [ ] args ) { String S = \" ddabdac \" ; generatePalindrome ( S ) ; } }"}
{"text": "Mengira kejadian substring x sebelum setiap kejadian substring y dalam rentetan yang diberikan | Program Java untuk pendekatan di atas; Fungsi untuk mengira kejadian rentetan y dalam rentetan s untuk setiap kejadian x dalam s; Menyimpan kiraan kejadian x; Menyimpan panjang tiga rentetan; Melintasi rentetan s; Jika substring semasa adalah y, maka kenaikan nilai kiraan sebanyak 1; Jika substring semasa adalah x, maka cetak kiraan; Kod pemacu", "code": "import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static void countOccurrences ( String S , String X , String Y ) { int count = 0 ; int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . substring ( i , Math . min ( N , i + B ) ) . equals ( Y ) ) count ++ ; if ( S . substring ( i , Math . min ( N , i + A ) ) . equals ( X ) ) System . out . print ( count + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { String S = \" abcdefdefabc \" ; String X = \" abc \" ; String Y = \" def \" ; countOccurrences ( S , X , Y ) ; } }"}
{"text": "Program untuk membina DFA untuk ungkapan biasa C (A + B) + | Program Java untuk pendekatan di atas; Fungsi untuk mencari sama ada rentetan yang diberikan diterima oleh DFA; Jika n <= 1, maka cetak tidak; Untuk mengira watak yang dipadankan; Semak jika watak pertama adalah c; Melintasi seluruh rentetan; Jika watak adalah A atau B, kiraan kenaikan sebanyak 1; Jika watak pertama tidak C, cetak - 1; Jika semua watak sepadan; Kod pemacu", "code": "import java . util . * ; class GFG { static void DFA ( String str , int N ) { if ( N <= 1 ) { System . out . print ( \" No \" ) ; return ; } int count = 0 ; if ( str . charAt ( 0 ) == ' C ' ) { count ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( str . charAt ( i ) == ' A ' || str . charAt ( i ) == ' B ' ) count ++ ; else break ; } } else { System . out . print ( \" No \" ) ; return ; } if ( count == N ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } public static void main ( String [ ] args ) { String str = \" CAABBAAB \" ; int N = str . length ( ) ; DFA ( str , N ) ; } }"}
{"text": "Bilangan minimum dan maksimum digit yang diperlukan untuk dikeluarkan untuk membuat nombor tertentu dibahagikan dengan 3 | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan maksimum dan minimum digit yang akan dikeluarkan untuk menjadikan STR dibahagikan dengan 3; Tukar rentetan ke dalam pelbagai digit; Kiraan 0 s, 1 s, dan 2 s; Melintasi array; Cari jumlah digit % 3; Kes untuk mencari bilangan minimum digit yang akan dikeluarkan; Kes untuk mencari bilangan maksimum digit yang akan dikeluarkan; Kod pemacu; Panggilan fungsi", "code": "class GFG { static void minMaxDigits ( String str , int N ) { int arr [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = ( str . charAt ( i ) - '0' ) % 3 ; int zero = 0 , one = 0 , two = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; } if ( sum == 0 ) { System . out . print ( 0 + \" ▁ \" ) ; } if ( sum == 1 ) { if ( ( one != 0 ) && ( N > 1 ) ) System . out . print ( 1 + \" ▁ \" ) ; else if ( two > 1 && N > 2 ) System . out . print ( 2 + \" ▁ \" ) ; else System . out . print ( - 1 + \" ▁ \" ) ; } if ( sum == 2 ) { if ( two != 0 && N > 1 ) System . out . print ( 1 + \" ▁ \" ) ; else if ( one > 1 && N > 2 ) System . out . print ( 2 + \" ▁ \" ) ; else System . out . print ( - 1 + \" ▁ \" ) ; } if ( zero > 0 ) System . out . print ( N - 1 + \" ▁ \" ) ; else if ( one > 0 && two > 0 ) System . out . print ( N - 2 + \" ▁ \" ) ; else if ( one > 2 two > 2 ) System . out . print ( N - 3 + \" ▁ \" ) ; else System . out . print ( - 1 + \" ▁ \" ) ; } public static void main ( String [ ] args ) { String str = \"12345\" ; int N = str . length ( ) ; minMaxDigits ( str , N ) ; } }"}
{"text": "Penggantian minimum diperlukan untuk mendapatkan k | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum perubahan untuk membuat rentetan k - berkala dan palindrome; Memulakan ans dengan 0; Berulang dari 0 hingga (k + 1) / 2; Frekuensi penyimpanan watak; Melewati semua indeks, i, i + k, i + 2 k .... dan menyimpan kekerapan watak; Meningkatkan kekerapan watak semasa; Melewati semua indeks k - i, 2 k - i, 3 ​​k - i .... dan menyimpan kekerapan watak; Jika k adalah ganjil & i adalah samw sebagai k / 2, pecahkan gelung; Meningkatkan kekerapan watak semasa; Cari kekerapan maksimum watak di antara semua watak yang dikunjungi; Jika K adalah ganjil dan saya sama dengan K / 2 maka, hanya aksara N / K yang dikunjungi; Jika tidak, n / k * 2 aksara telah melawat; Mengembalikan hasilnya; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int findMinimumChanges ( int N , int K , char [ ] S ) { int ans = 0 ; for ( int i = 0 ; i < ( K + 1 ) / 2 ; i ++ ) { HashMap < Character , Integer > mp = new HashMap < > ( ) ; for ( int j = i ; j < N ; j += K ) { if ( mp . containsKey ( S [ j ] ) ) { mp . put ( S [ j ] , mp . get ( S [ j ] ) + 1 ) ; } else { mp . put ( S [ j ] , 1 ) ; } } for ( int j = N - i - 1 ; j >= 0 ; j -= K ) { if ( K % 2 == 1 && i == K / 2 ) break ; if ( mp . containsKey ( S [ j ] ) ) { mp . put ( S [ j ] , mp . get ( S [ j ] ) + 1 ) ; } else { mp . put ( S [ j ] , 1 ) ; } } int curr_max = Integer . MIN_VALUE ; for ( Map . Entry < Character , Integer > p : mp . entrySet ( ) ) { curr_max = Math . max ( curr_max , p . getValue ( ) ) ; } if ( ( K % 2 == 1 ) && i == K / 2 ) ans += ( N / K - curr_max ) ; else ans += ( N / K * 2 - curr_max ) ; } return ans ; } public static void main ( String [ ] args ) { String S = \" aabbcbbcb \" ; int N = S . length ( ) ; int K = 3 ; System . out . print ( findMinimumChanges ( N , K , S . toCharArray ( ) ) ) ; } }"}
{"text": "Semak sama ada rentetan mengandungi sebarang indeks dengan lebih banyak daripada aktif aktif k | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada mana -mana indeks mengandungi lebih banyak daripada ak aktif aktif; Simpan kejadian terakhir setiap watak dalam peta. ; Menyimpan watak aktif; Masukkan watak; Jika saiz set melebihi k; Keluarkan watak dari set jika saya adalah indeks terakhir watak semasa; Kod pemacu", "code": "import java . util . * ; class GFG { static String checkString ( String s , int K ) { int n = s . length ( ) ; Map < Character , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( s . charAt ( i ) , i ) ; } int cnt = 0 , f = 0 ; Set < Character > st = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { st . add ( s . charAt ( i ) ) ; if ( st . size ( ) > K ) { f = 1 ; break ; } if ( mp . get ( s . charAt ( i ) ) == i ) st . remove ( s . charAt ( i ) ) ; } return ( f == 1 ? \" Yes \" : \" No \" ) ; } public static void main ( String [ ] args ) { String s = \" aabbcdca \" ; int k = 2 ; System . out . println ( checkString ( s , k ) ) ; } }"}
{"text": "Kira bilangan rentetan dalam array yang wataknya berbeza kurang daripada m | Pelaksanaan Java untuk mengira bilangan rentetan dalam array yang wataknya yang berbeza kurang daripada atau sama dengan M; Fungsi untuk mengira rentetan yang dikira watak -watak yang berbeza kurang daripada m; Gelung untuk melangkah ke atas semua rentetan array; Watak yang berbeza dalam rentetan dengan bantuan set; Memeriksa jika kurang daripada atau sama dengan m; Kod pemacu", "code": "import java . util . * ; class GFG { public static void distinct ( String [ ] S , int M ) { int count = 0 ; for ( int i = 0 ; i < S . length ; i ++ ) { Set < Character > set = new HashSet < > ( ) ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( ! set . contains ( S [ i ] . charAt ( j ) ) ) set . add ( S [ i ] . charAt ( j ) ) ; } int c = set . size ( ) ; if ( c <= M ) count += 1 ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { String S [ ] = { \" HERBIVORES \" , \" AEROPLANE \" , \" GEEKSFORGEEKS \" } ; int M = 7 ; distinct ( S , M ) ; } }"}
{"text": "Keluarkan aksara frekuensi ganjil dari rentetan | Program Java untuk menghapuskan aksara yang mempunyai frekuensi ganjil dalam rentetan; Berfungsi untuk menghapuskan aksara yang mempunyai frekuensi ganjil dalam rentetan; Buat peta untuk menyimpan kekerapan setiap watak; Untuk menyimpan rentetan baru; Keluarkan watak -watak yang mempunyai frekuensi ganjil; Jika watak mempunyai kekerapan ganjil maka langkau; Lain menggabungkan watak ke rentetan baru; Kembalikan rentetan yang diubah suai; Kod pemacu; Keluarkan watak yang mempunyai frekuensi ganjil", "code": "import java . util . * ; class GFG { static String removeOddFrequencyCharacters ( String s ) { HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char p = s . charAt ( i ) ; Integer count = m . get ( p ) ; if ( count == null ) { count = 0 ; m . put ( p , 1 ) ; } else m . put ( p , count + 1 ) ; } String new_string = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( m . get ( s . charAt ( i ) ) & 1 ) == 1 ) continue ; new_string += s . charAt ( i ) ; } return new_string ; } public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; str = removeOddFrequencyCharacters ( str ) ; System . out . print ( str ) ; } }"}
{"text": "Produk nod di k | Pelaksanaan Java untuk mencari produk unsur -unsur di peringkat k - th; Fungsi rekursif untuk mencari produk unsur -unsur di peringkat k - th; Jika subtree adalah batal, sama seperti jika root == null; Pertimbangkan hanya nod tahap untuk menjadi sebahagian daripada produk; Berulang untuk subtree kiri; Berulang untuk subtree yang betul; Menjaga ')' selepas subtree kiri dan kanan; Kod pemacu", "code": "class GFG { static int i ; static int productAtKthLevel ( String tree , int k , int level ) { if ( tree . charAt ( i ++ ) == ' ( ' ) { if ( tree . charAt ( i ) == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree . charAt ( i ) - '0' ; ++ i ; int leftproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; int rightproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } return Integer . MIN_VALUE ; } public static void main ( String [ ] args ) { String tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) \" + \" ( 9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; int k = 2 ; i = 0 ; System . out . print ( productAtKthLevel ( tree , k , 0 ) ) ; } }"}
{"text": "Cetak watak yang paling berlaku dalam pelbagai rentetan | Program Java untuk mencetak watak yang paling banyak berlaku dalam pelbagai rentetan; Berfungsi untuk mencetak watak yang paling banyak berlaku; Mewujudkan hash saiz 26; Untuk gelung untuk melangkah melalui setiap rentetan array; Untuk gelung untuk melangkah melalui setiap watak rentetan; Meningkatkan kiraan watak dalam hash; Mencari watak dengan kiraan maksimum; Kod pemacu; Mengisytiharkan vektor jenis rentetan", "code": "import java . util . * ; class GFG { static void findMostOccurringChar ( Vector < String > str ) { int [ ] hash = new int [ 26 ] ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { for ( int j = 0 ; j < str . get ( i ) . length ( ) ; j ++ ) { hash [ str . get ( i ) . charAt ( j ) - 97 ] ++ ; } } int max = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { max = hash [ i ] > hash [ max ] ? i : max ; } System . out . print ( ( char ) ( max + 97 ) + \"NEW_LINE\"); } public static void main ( String [ ] args ) { Vector < String > str = new Vector < String > ( ) ; str . add ( \" animal \" ) ; str . add ( \" zebra \" ) ; str . add ( \" lion \" ) ; str . add ( \" giraffe \" ) ; findMostOccurringChar ( str ) ; } }"}
{"text": "Semak sama ada nombor titik terapung yang diberikan adalah palindrome | Pelaksanaan Java pendekatan; Fungsi yang mengembalikan benar jika NUM adalah palindrome; Tukar nombor titik terapung yang diberikan ke dalam rentetan; Penunjuk menunjuk kepada watak pertama dan terakhir rentetan; Bukan palindrome; Mengemas kini petunjuk; Kod pemacu", "code": "public class GFG { public static boolean isPalindrome ( float num ) { String s = String . valueOf ( num ) ; int low = 0 ; int high = s . length ( ) - 1 ; while ( low < high ) { if ( s . charAt ( low ) != s . charAt ( high ) ) return false ; low ++ ; high -- ; } return true ; } public static void main ( String args [ ] ) { float n = 123.321f ; if ( isPalindrome ( n ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text": "Bilangan maksimum kali str1 muncul sebagai bukan | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan bilangan maksimum kali STR1 boleh muncul sebagai substring yang tidak bertindih dalam STR2; STR1 tidak boleh menjadi substring str2; Simpan kekerapan watak Str1; Simpan kekerapan watak Str2; Untuk menyimpan kiraan substring yang diperlukan; Watak semasa tidak muncul dalam str1; Kekerapan watak semasa dalam Str1 adalah lebih besar daripada kekerapannya dalam Str2; Mengemas kini kiraan substrings yang mungkin; Kod pemacu", "code": "class GFG { final static int MAX = 26 ; static int maxSubStr ( char [ ] str1 , int len1 , char [ ] str2 , int len2 ) { if ( len1 > len2 ) return 0 ; int freq1 [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ i ] = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; int freq2 [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ i ] = 0 ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; int minPoss = Integer . MAX_VALUE ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = Math . min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; } return minPoss ; } public static void main ( String [ ] args ) { String str1 = \" geeks \" , str2 = \" gskefrgoekees \" ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; System . out . println ( maxSubStr ( str1 . toCharArray ( ) , len1 , str2 . toCharArray ( ) , len2 ) ) ; } }"}
{"text": "Bilangan cara untuk memasukkan dua pasang kurungan ke dalam rentetan aksara n | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan bilangan cara untuk memasukkan pasangan kurungan; Kod pemacu", "code": "import java . util . * ; class GFG { static int cntWays ( String str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; } public static void main ( String [ ] args ) { String str = \" ab \" ; int n = str . length ( ) ; System . out . println ( cntWays ( str , n ) ) ; } }"}
{"text": "Bilangan minimum substrings rentetan yang diberikan boleh dibuang ke dalam yang memenuhi syarat -syarat yang diberikan | Pelaksanaan Java pendekatan di atas; Tetapkan untuk menyimpan semua rentetan dari array yang diberikan; Untuk menyimpan kiraan yang diperlukan; Fungsi rekursif untuk mencari kiraan substrings yang boleh dibahagikan bermula dari indeks permulaan supaya semua substrings hadir dalam peta; Semua substring yang dipilih hadir dalam peta; Mengemas kini kiraan minimum substring; Bermula dari substrings panjang 1 yang bermula dengan indeks yang diberikan; Dapatkan substring; Jika substring hadir dalam set; Panggilan rekursif untuk sisa rentetan; Fungsi yang memasukkan semua rentetan dari array yang diberikan dalam satu set dan memanggil fungsi rekursif untuk mencari kiraan minimum substrings STR boleh dibuang ke dalam yang memenuhi syarat yang diberikan; Masukkan semua rentetan dari array yang diberikan dalam satu set; Cari kiraan yang diperlukan; Kod pemacu", "code": "import java . util . * ; class GFG { static Set < String > uSet = new HashSet < String > ( ) ; static int minCnt = Integer . MAX_VALUE ; static void findSubStr ( String str , int cnt , int start ) { if ( start == str . length ( ) ) { minCnt = Math . min ( cnt , minCnt ) ; } for ( int len = 1 ; len <= ( str . length ( ) - start ) ; len ++ ) { String subStr = str . substring ( start , start + len ) ; if ( uSet . contains ( subStr ) ) { findSubStr ( str , cnt + 1 , start + len ) ; } } } static void findMinSubStr ( String arr [ ] , int n , String str ) { for ( int i = 0 ; i < n ; i ++ ) uSet . add ( arr [ i ] ) ; findSubStr ( str , 0 , 0 ) ; } public static void main ( String args [ ] ) { String str = \"123456\" ; String arr [ ] = { \"1\" , \"12345\" , \"2345\" , \"56\" , \"23\" , \"456\" } ; int n = arr . length ; findMinSubStr ( arr , n , str ) ; System . out . print ( minCnt ) ; } }"}
{"text": "Bilangan substring yang bermula dengan \"geeks\" dan berakhir dengan \"untuk\" | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan kiraan substring yang diperlukan; Untuk setiap indeks rentetan; Jika substring bermula pada indeks semasa adalah \"geeks\"; Jika substring adalah \"untuk\"; Kod pemacu", "code": "class GFG { static int countSubStr ( String s , int n ) { int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 5 && \" geeks \" . equals ( s . substring ( i , i + 5 ) ) ) { c1 ++ ; } if ( i < n - 3 && \" for \" . equals ( s . substring ( i , i + 3 ) ) ) { c2 = c2 + c1 ; } } return c2 ; } public static void main ( String [ ] args ) { String s = \" geeksforgeeksisforgeeks \" ; int n = s . length ( ) ; System . out . println ( countSubStr ( s , n ) ) ; } }"}
{"text": "Infytq 2019: Cari kedudukan dari mana kurungan tidak seimbang | Pelaksanaan Java pendekatan; Menentukan rentetan; Menyimpan pendakap pembukaan dalam senarai LST1; Menyimpan pendakap penutup dalam senarai LST2; Mewujudkan senarai kosong LST; Mewujudkan kamus untuk memetakan pendakap penutup untuk membuka; Jika kedudukan pertama rentetan mengandungi sebarang pendakap penutup kembali 1; Jika watak -watak rentetan membuka pendakap maka masukkannya ke dalam senarai; Apabila saiz senarai adalah 0 dan pendakap penutup baru ditemui kemudian cetak indeksnya bermula dari 1; Ketika kami menemui pendakap penutup, kami memetakan mereka dengan pendakap pembukaan yang sesuai dengan menggunakan kamus dan periksa sama ada ia sama dengan pendakap yang dibuka terakhir (elemen terakhir dalam senarai) jika ya maka kami memadamkan elemt dari senarai; Jika tidak, kami mengembalikan indeks (bermula dari 1) di mana bersarang didapati salah; Pada akhir jika senarai kosong itu bermaksud rentetan bersarang dengan sempurna", "code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) { String string = \" { [ ( ) ] } [ ] \" ; char [ ] lst1 = { ' { ' , ' ( ' , ' [ ' } ; char [ ] lst2 = { ' } ' , ' ) ' , ' ] ' } ; Vector < Character > lst = new Vector < Character > ( ) ; HashMap < Character , Character > Dict = new HashMap < > ( ) ; Dict . put ( ' ) ' , ' ( ' ) ; Dict . put ( ' } ' , ' { ' ) ; Dict . put ( ' ] ' , ' [ ' ) ; int a = 0 , b = 0 , c = 0 ; if ( Arrays . asList ( lst2 ) . contains ( string . charAt ( 0 ) ) ) { System . out . println ( 1 ) ; } else { int k = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( Arrays . asList ( lst1 ) . contains ( string . charAt ( i ) ) ) { lst . add ( string . charAt ( i ) ) ; k = i + 2 ; } else { if ( lst . size ( ) == 0 && Arrays . asList ( lst2 ) . contains ( string . charAt ( i ) ) ) { System . out . println ( ( i + 1 ) ) ; c = 1 ; break ; } else { if ( lst . size ( ) > 0 && Dict . get ( string . charAt ( i ) ) == lst . get ( lst . size ( ) - 1 ) ) { lst . remove ( lst . size ( ) - 1 ) ; } else { a = 1 ; break ; } } } } if ( lst . size ( ) == 0 && c == 0 ) { System . out . println ( 0 ) ; b = 1 ; } if ( a == 0 && b == 0 && c == 0 ) { System . out . println ( k ) ; } } } }"}
{"text": "Menyulitkan rentetan yang diberikan dengan operasi berikut | Pelaksanaan Java pendekatan di atas :; Berfungsi untuk mengembalikan rentetan yang disulitkan; Kurangkan x kerana putaran panjang 26 tidak perlu; Kirakan kekerapan aksara; Jika kekerapan aksara arus bahkan maka kenaikannya dengan x; Lain menurunkannya dengan x; Mengembalikan kiraan; Kod pemacu", "code": "public class GFG { static final int MAX = 26 ; static String encryptStr ( String str , int n , int x ) { x = x % MAX ; char arr [ ] = str . toCharArray ( ) ; int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] - ' a ' ] % 2 == 0 ) { int pos = ( arr [ i ] - ' a ' + x ) % MAX ; arr [ i ] = ( char ) ( pos + ' a ' ) ; } else { int pos = ( arr [ i ] - ' a ' - x ) ; if ( pos < 0 ) pos += MAX ; arr [ i ] = ( char ) ( pos + ' a ' ) ; } } return String . valueOf ( arr ) ; } public static void main ( String [ ] args ) { String s = \" abcda \" ; int n = s . length ( ) ; int x = 3 ; System . out . println ( encryptStr ( s , n , x ) ) ; } }"}
{"text": "Susun semula aksara dalam rentetan supaya tidak ada dua bersebelahan dengan menggunakan hashing | Pelaksanaan Java pendekatan; Fungsi yang mengembalikan benar jika mungkin untuk menyusun semula watak -watak rentetan supaya tidak dua aksara berturut -turut adalah sama; Untuk menyimpan kekerapan setiap watak; Untuk menyimpan kekerapan maksimum setakat ini; Jika boleh; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean isPossible ( char [ ] str ) { Map < Character , Integer > freq = new HashMap < > ( ) ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ) ; j ++ ) { if ( freq . containsKey ( str [ j ] ) ) { freq . put ( str [ j ] , freq . get ( str [ j ] ) + 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } else { freq . put ( str [ j ] , 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } } if ( max_freq <= ( str . length - max_freq + 1 ) ) return true ; return false ; } public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; if ( isPossible ( str . toCharArray ( ) ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Cari watak yang tidak biasa dari dua rentetan | Tetapkan 2 | Pelaksanaan Java pendekatan; Berfungsi untuk mencetak aksara yang tidak biasa dalam rentetan yang diberikan dalam urutan yang disusun; Menukar watak ke kod ASCII; Operasi bit; Menukar watak ke kod ASCII; Operasi bit; Operasi XOR hanya meninggalkan watak -watak yang tidak biasa dalam pembolehubah ANS; Kod pemacu", "code": "class GFG { static void printUncommon ( String str1 , String str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = ( str1 . charAt ( i ) ) - ' a ' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = ( str2 . charAt ( i ) ) - ' a ' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { System . out . print ( ( char ) ( ' a ' + i ) ) ; } ans = ans / 2 ; i ++ ; } } public static void main ( String [ ] args ) { String str1 = \" geeksforgeeks \" ; String str2 = \" geeksquiz \" ; printUncommon ( str1 , str2 ) ; } }"}
{"text": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Set | Program Java untuk mencari bilangan minimum pembalikan yang diperlukan untuk mengimbangi ungkapan; Mengembalikan kiraan pembalikan minimum untuk membuat expr seimbang. Pulangan - 1 Jika expr tidak boleh seimbang. ; Panjang ekspresi mestilah menjadikannya seimbang dengan menggunakan pembalikan. ; Untuk menyimpan bilangan pembalikan yang diperlukan. ; Untuk menyimpan nombor pendakap pembukaan yang tidak seimbang. ; Untuk menyimpan nombor kurungan penutupan yang tidak seimbang. ; Jika pendakap semasa dibuka maka kenaikan kiraan terbuka. ; Jika pendakap semasa dekat, periksa sama ada mengimbangi pendakap pembukaan. Jika ya maka pengurangan kiraan pendakap pembukaan yang tidak seimbang, lain -lain kenaikan kiraan pendakap penutupan. ; Untuk kes itu: \"} {\" Atau apabila satu penutupan dan satu pendakap pembukaan kekal untuk berpasangan, maka kedua -duanya perlu diterbalikkan. ; Kod pemacu", "code": "class GFG { static int countMinReversals ( String expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) return - 1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr . charAt ( i ) == ' { ' ) open ++ ; else { if ( open == 0 ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close != 0 ) ans += 2 ; return ans ; } public static void main ( String args [ ] ) { String expr = \" } } { { \" ; System . out . println ( countMinReversals ( expr ) ) ; } }"}
{"text": "Pasangan watak dari dua rentetan dengan jumlah keseluruhan | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan jumlah pasangan yang sah; Kira jumlah nilai ASCII yang lebih baik dan ganjil untuk String S1; Kira jumlah nilai ASCII yang lebih baik dan ganjil untuk String S2; Mengembalikan jumlah pasangan yang sah; Kod pemacu", "code": "class GfG { static int totalPairs ( String s1 , String s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ( int ) s1 . charAt ( i ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( ( int ) s2 . charAt ( i ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; } public static void main ( String [ ] args ) { String s1 = \" geeks \" , s2 = \" for \" ; System . out . println ( totalPairs ( s1 , s2 ) ) ; } }"}
{"text": "Kejadian maksimum awalan dalam array | Program Java untuk mencari bilangan kejadian awalan yang berlaku maksimum tidak. masa; Berfungsi untuk mengembalikan kiraan awalan yang diperlukan; Cari kekerapan watak pertama rentetan; Kod pemacu", "code": "class GFG { static int prefixOccurrences ( String str ) { char c = str . charAt ( 0 ) ; int countc = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == c ) countc ++ ; } return countc ; } public static void main ( String args [ ] ) { String str = \" abbcdabbcd \" ; System . out . println ( prefixOccurrences ( str ) ) ; } }"}
{"text": "Bilangan minimum operasi yang diberikan diperlukan untuk menukar rentetan ke rentetan lain | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan operasi minimum jenis yang diberikan untuk menukar rentetan s ke rentetan t; Watak sudah sama; Kiraan kenaikan 0 s; Kiraan kenaikan 1 s; Kod pemacu", "code": "import java . util . * ; class GFG { static int minOperations ( String s , String t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == t . charAt ( i ) ) continue ; if ( s . charAt ( i ) == '0' ) ct0 ++ ; else ct1 ++ ; } return Math . max ( ct0 , ct1 ) ; } public static void main ( String args [ ] ) { String s = \"010\" , t = \"101\" ; int n = s . length ( ) ; System . out . println ( minOperations ( s , t , n ) ) ; } }"}
{"text": "Dekripsi rentetan yang disulitkan dengan mengulangi i | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan rentetan yang disahsulit; Lompat awal akan menjadi 1; Lompat kenaikan sebanyak 1 dengan setiap watak; Kod pemacu", "code": "class GFG { static String decryptString ( String str , int n ) { int i = 0 , jump = 1 ; String decryptedStr = \" \" ; while ( i < n ) { decryptedStr += str . charAt ( i ) ; i += jump ; jump ++ ; } return decryptedStr ; } public static void main ( String [ ] args ) { String str = \" geeeeekkkksssss \" ; int n = str . length ( ) ; System . out . println ( decryptString ( str , n ) ) ; } }"}
{"text": "Cari bit yang flip urutan minimum menjadikan semua bit sama | Program Java untuk mencari urutan bit mana yang akan dibalik; Fungsi untuk memeriksa bit mana yang akan dibalik; pembolehubah untuk menyimpan watak pertama dan terakhir rentetan; Semak sama ada aksara pertama dan terakhir adalah sama, jika ya, kemudian kembalikan watak yang tidak akhirnya; lain kembali terakhir; Kod pemacu", "code": "class GfG { static char bitToBeFlipped ( String s ) { char last = s . charAt ( s . length ( ) - 1 ) ; char first = s . charAt ( 0 ) ; if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } } else if ( last != first ) { return last ; } return last ; } public static void main ( String [ ] args ) { String s = \"1101011000\" ; System . out . println ( bitToBeFlipped ( s ) ) ; } }"}
{"text": "Jumlah dan produk frekuensi utama aksara dalam rentetan | Program Java untuk mencari jumlah dan produk frekuensi utama aksara dalam rentetan; Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mencari jumlah frekuensi utama watak -watak rentetan yang diberikan; Peta digunakan untuk menyimpan frekuensi watak; Melintasi peta; Jika kekerapan adalah perdana; Kod pemacu", "code": "import java . util . * ; class GFG { static void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < p_size ; i += p ) { prime [ i ] = false ; } } } } static void sumProdOfPrimeFreq ( char [ ] s ) { boolean [ ] prime = new boolean [ s . length + 1 ] ; Arrays . fill ( prime , true ) ; SieveOfEratosthenes ( prime , s . length + 1 ) ; int i , j ; Map < Character , Integer > mp = new HashMap < > ( ) ; for ( i = 0 ; i < s . length ; i ++ ) { mp . put ( s [ i ] , mp . get ( s [ i ] ) == null ? 1 : mp . get ( s [ i ] ) + 1 ) ; } int sum = 0 , product = 1 ; for ( Map . Entry < Character , Integer > it : mp . entrySet ( ) ) { if ( prime [ it . getValue ( ) ] ) { sum += it . getValue ( ) ; product *= it . getValue ( ) ; } } System . out . print ( \" Sum ▁ = ▁ \" + sum ) ; System . out . println ( \" Product = \" + product); } public static void main ( String [ ] args ) { String s = \" geeksforgeeks \" ; sumProdOfPrimeFreq ( s . toCharArray ( ) ) ; } }"}
{"text": "Semak jika kekerapan aksara dalam satu rentetan adalah faktor atau pelbagai kekerapan watak yang sama dalam rentetan lain | Pelaksanaan Java pendekatan di atas; Fungsi yang memeriksa jika kekerapan watak adalah faktor atau pelbagai antara satu sama lain; kekerapan kedai peta setiap aksara; Jika sebarang kekerapan adalah 0, maka teruskan sebagai keadaan berpuas hati; jika faktor atau berganda, maka keadaan berpuas hati; jika keadaan tidak berpuas hati; Kod pemacu", "code": "import java . util . HashMap ; class GFG { public static boolean multipleOrFactor ( String s1 , String s2 ) { HashMap < Character , Integer > m1 = new HashMap < > ( ) ; HashMap < Character , Integer > m2 = new HashMap < > ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( m1 . containsKey ( s1 . charAt ( i ) ) ) { int x = m1 . get ( s1 . charAt ( i ) ) ; m1 . put ( s1 . charAt ( i ) , ++ x ) ; } else m1 . put ( s1 . charAt ( i ) , 1 ) ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( m2 . containsKey ( s2 . charAt ( i ) ) ) { int x = m2 . get ( s2 . charAt ( i ) ) ; m2 . put ( s2 . charAt ( i ) , ++ x ) ; } else m2 . put ( s2 . charAt ( i ) , 1 ) ; } for ( HashMap . Entry < Character , Integer > entry : m1 . entrySet ( ) ) { if ( ! m2 . containsKey ( entry . getKey ( ) ) ) continue ; if ( m2 . get ( entry . getKey ( ) ) != null && ( m2 . get ( entry . getKey ( ) ) % entry . getValue ( ) == 0 || entry . getValue ( ) % m2 . get ( entry . getKey ( ) ) == 0 ) ) continue ; else return false ; } return true ; } public static void main ( String [ ] args ) { String s1 = \" geeksforgeeks \" , s2 = \" geeks \" ; if ( multipleOrFactor ( s1 , s2 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Keluarkan walaupun aksara frekuensi dari rentetan | Pelaksanaan Java pendekatan; Fungsi yang menghilangkan aksara yang mempunyai frekuensi dalam rentetan; Buat peta untuk menyimpan kekerapan setiap watak; untuk menyimpan rentetan baru; Keluarkan watak -watak yang mempunyai frekuensi; Jika watak mempunyai kekerapan, maka langkau; lain menggabungkan watak ke rentetan baru; Paparkan rentetan yang diubah suai; Kod pemacu; Keluarkan watak yang mempunyai frekuensi bahkan", "code": "import java . util . * ; class GFG { static void solve ( String s ) { HashMap < Character , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . containsKey ( s . charAt ( i ) ) ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) + 1 ) ; else m . put ( s . charAt ( i ) , 1 ) ; } String new_string = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . get ( s . charAt ( i ) ) % 2 == 0 ) continue ; new_string = new_string + s . charAt ( i ) ; } System . out . println ( new_string ) ; } public static void main ( String [ ] args ) { String s = \" aabbbddeeecc \" ; solve ( s ) ; } }"}
{"text": "Keluarkan semua perkataan palindromik dari ayat yang diberikan | Pelaksanaan Java untuk menghapuskan semua kata -kata palindromik dari ayat yang diberikan; fungsi untuk memeriksa sama ada 'str' adalah palindrome; melintasi kedua -dua hujungnya; bukan palindrome; palindrome; berfungsi untuk menghapuskan semua perkataan palindromik dari ayat yang diberikan; 'akhir _ str' untuk menyimpan rentetan akhir dan 'kata' kepada satu demi satu kedai setiap perkataan 'str'; Tambah ruang pada akhir 'str'; melintasi 'str'; mengumpul watak -watak perkataan semasa; jika 'perkataan' bukan palindrome maka tambahnya ke 'akhir _ str'; menetapkan semula; rentetan akhir yang diperlukan; Kod pemacu", "code": "class GFG { static boolean isPalindrome ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ++ ) != str . charAt ( j -- ) ) return false ; } return true ; } static String removePalinWords ( String str ) { String final_str = \" \" , word = \" \" ; str = str + \" ▁ \" ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != ' ▁ ' ) word = word + str . charAt ( i ) ; else { if ( ! ( isPalindrome ( word ) ) ) final_str += word + \" ▁ \" ; word = \" \" ; } } return final_str ; } public static void main ( String [ ] args ) { String str = \" Text ▁ contains ▁ malayalam ▁ and ▁ level ▁ words \" ; System . out . print ( removePalinWords ( str ) ) ; } }"}
{"text": "Jumlah semua berikutnya nombor | Program Java untuk mencari jumlah elemen yang hadir dalam semua berikutnya; Mengembalikan nilai angka berikutnya S. Berikutnya yang akan dipilih diputuskan menggunakan corak bit Num (kami memilih semua digit yang mana terdapat bit set dalam NUM); Memulakan hasilnya; sehingga n! = 0; Jika saya - bit ditetapkan maka tambahkan nombor ini; Peralihan kanan i; fungsi untuk mencari jumlah gabungan semua jumlah keseluruhan individu; panjang rentetan; menyimpan gabungan; 2 ^ n - 1 berikutnya; gelung untuk semua berikutnya; mengembalikan jumlah gabungan; Fungsi pemacu", "code": "import java . io . * ; class GFG { static int findSubSequence ( String s , int num ) { int res = 0 ; int i = 0 ; while ( num > 0 ) { if ( ( num & 1 ) == 1 ) res += s . charAt ( i ) - '0' ; i ++ ; num = num >> 1 ; } return res ; } static int combinedSum ( String s ) { int n = s . length ( ) ; int c_sum = 0 ; int range = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; } public static void main ( String [ ] args ) { String s = \"123\" ; System . out . println ( combinedSum ( s ) ) ; } }"}
{"text": "Susunan terpanjang di mana setiap watak berlaku sekurang -kurangnya k kali | Program Java untuk mencari seterusnya dengan setiap watak yang berlaku sekurang -kurangnya k kali dalam rentetan; Berfungsi untuk mencari berikutnya; Mengambil array tambahan untuk menyimpan rekod untuk kiraan watak dalam s; Mengira kejadian semua aksara dalam STR []; Percetakan aksara dengan kiraan> = k dalam susunan yang sama kerana ia muncul dalam str. ; Kod pemacu", "code": "class GFG { static final int MAX_CHAR = 26 ; static void findSubsequence ( String str , int k ) { int a [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) a [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( a [ str . charAt ( i ) - ' a ' ] >= k ) System . out . print ( str . charAt ( i ) ) ; } public static void main ( String [ ] args ) { int k = 2 ; findSubsequence ( \" geeksforgeeks \" , k ) ; } }"}
{"text": "Google Case Of A Sentyen tertentu | Program Java untuk menukar ayat ke Google Case. ; rentetan kosong; Tukar rentetan input ke atas kes; checki jika watak bukan ruang dan menambahkannya ke rentetan w; Menukar watak pertama ke kes yang lebih rendah dan huruf awal berikutnya perkataan lain kepada kes yang lebih rendah; Kod pemacu", "code": "class GFG { static String convert ( String str ) { String w = \" \" , z = \" \" ; str = str . toUpperCase ( ) + \" ▁ \" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch != ' ▁ ' ) w = w + ch ; else { z = z + ( Character . toLowerCase ( w . charAt ( 0 ) ) ) + w . substring ( 1 ) + \" ▁ \" ; w = \" \" ; } } return z ; } public static void main ( String [ ] args ) { String str = \" I ▁ got ▁ intern ▁ at ▁ geeksforgeeks \" ; System . out . println ( convert ( str ) ) ; } }"}
{"text": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | Program Java untuk menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz K; isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan rentetan; CV untuk mengira vokal CC untuk mengira konsonan; Mengira awalan kiraan vokal dan awalan kiraan konsonan; Menjana rentetan yang disulitkan. ; Kod pemacu", "code": "class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } static String encryptString ( char [ ] s , int n , int k ) { int [ ] cv = new int [ n ] ; int [ ] cc = new int [ n ] ; if ( isVowel ( s [ 0 ] ) ) cv [ 0 ] = 1 ; else cc [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { cv [ i ] = cv [ i - 1 ] + ( isVowel ( s [ i ] ) == true ? 1 : 0 ) ; cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) == true ? 0 : 1 ) ; } String ans = \" \" ; int prod = 0 ; prod = cc [ k - 1 ] * cv [ k - 1 ] ; ans += String . valueOf ( prod ) ; for ( int i = k ; i < s . length ; i ++ ) { prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ; ans += String . valueOf ( prod ) ; } return ans ; } public static void main ( String [ ] args ) { String s = \" hello \" ; int n = s . length ( ) ; int k = 2 ; System . out . print ( encryptString ( s . toCharArray ( ) , n , k ) + \"NEW_LINE\"); } }"}
{"text": "Kira kejadian perkataan dalam rentetan | Program Java untuk mengira bilangan berlakunya perkataan dalam rentetan yang diberikan; berpecah rentetan dengan ruang dalam A; Cari corak dalam A; jika perlawanan mendapati kenaikan kiraan; Kod pemacu", "code": "import java . io . * ; class GFG { static int countOccurrences ( String str , String word ) { String a [ ] = str . split ( \" ▁ \" ) ; int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( word . equals ( a [ i ] ) ) count ++ ; } return count ; } public static void main ( String args [ ] ) { String str = \" GeeksforGeeks ▁ A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks ▁ \" ; String word = \" portal \" ; System . out . println ( countOccurrences ( str , word ) ) ; } }"}
{"text": "Program untuk mencari inisial nama. | Program Java untuk mencetak inisial nama; Pecahkan rentetan menggunakan 'ruang' dan cetak watak pertama setiap perkataan; Kod pemacu", "code": "class initials { static void printInitials ( String name ) { if ( name . length ( ) == 0 ) return ; String words [ ] = name . split ( \" ▁ \" ) ; for ( String word : words ) { System . out . print ( Character . toUpperCase ( word . charAt ( 0 ) ) + \" ▁ \" ) ; } } public static void main ( String args [ ] ) { String name = \" prabhat ▁ kumar ▁ singh \" ; printInitials ( name ) ; } }"}
{"text": "Tinggalkan rentetan dengan menukar kes | Program Java untuk mencetak semua permutasi berkenaan dengan kes; Berfungsi untuk menjana permutasi; Bilangan permutasi adalah 2 ^ n; Menukar rentetan ke kes yang lebih rendah; Menggunakan semua berikutnya dan membenarkannya; Jika b - th bit ditetapkan, kami menukarnya ke atas kes; Mencetak gabungan semasa; Program pemacu untuk menguji fungsi di atas", "code": "public class PermuteString { static void permute ( String input ) { int n = input . length ( ) ; int max = 1 << n ; input = input . toLowerCase ( ) ; for ( int i = 0 ; i < max ; i ++ ) { char combination [ ] = input . toCharArray ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = ( char ) ( combination [ j ] - 32 ) ; } System . out . print ( combination ) ; System . out . print ( \" ▁ \" ) ; } } public static void main ( String [ ] args ) { permute ( \" ABC \" ) ; } }"}
{"text": "Cetak rentetan selepas watak yang ditentukan telah berlaku diberi tidak. masa | Program Java untuk pelaksanaan di atas; Kaedah untuk mencetak rentetan; Jika diberi kiraan adalah 0 cetak rentetan yang diberikan dan kembali; Mula melintasi rentetan; Kenaikan OCC jika char semasa adalah sama dengan watak yang diberikan; Pecahkan gelung jika watak yang diberikan telah berlaku tidak diberikan. masa; Cetak rentetan selepas berlakunya watak yang diberikan tidak. masa; Jika tidak, rentetan kosong; Kaedah Pemandu", "code": "public class GFG { static void printString ( String str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { System . out . println ( str ) ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) System . out . println ( str . substring ( i + 1 ) ) ; else System . out . println ( \" Empty ▁ string \" ) ; } public static void main ( String [ ] args ) { String str = \" geeks ▁ for ▁ geeks \" ; printString ( str , ' e ' , 2 ) ; } }"}
{"text": "Vokal terbalik dalam rentetan yang diberikan | Program Java untuk membalikkan urutan vokal; fungsi utiliti untuk memeriksa vokal; Berfungsi untuk membalikkan urutan vokal; Mulakan dua indeks dari dua sudut dan bergerak ke arah satu sama lain; bertukar; Fungsi pemacu", "code": "class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; } static String reverseVowel ( String str ) { int i = 0 ; int j = str . length ( ) - 1 ; char [ ] str1 = str . toCharArray ( ) ; while ( i < j ) { if ( ! isVowel ( str1 [ i ] ) ) { i ++ ; continue ; } if ( ! isVowel ( str1 [ j ] ) ) { j -- ; continue ; } char t = str1 [ i ] ; str1 [ i ] = str1 [ j ] ; str1 [ j ] = t ; i ++ ; j -- ; } String str2 = String . copyValueOf ( str1 ) ; return str2 ; } public static void main ( String [ ] args ) { String str = \" hello ▁ world \" ; System . out . println ( reverseVowel ( str ) ) ; } }"}
{"text": "Bilangan minimum Palindromic selepas dikeluarkan untuk mengosongkan rentetan binari | Program Java untuk mengira minimum Palindromic seterusnya untuk dikeluarkan untuk membuat rentetan kosong. ; Fungsi untuk memeriksa sama ada string str adalah palindrome; Bermula dari sudut paling kiri dan paling kanan Str; Terus membandingkan watak semasa mereka sama; Mengembalikan kiraan minimum palindromic subseuqnces untuk dikeluarkan untuk membuat rentetan kosong; Jika rentetan kosong; Jika rentetan adalah palindrome; Jika rentetan bukan palindrome; Kod pemacu untuk diuji di atas", "code": "import java . io . * ; class GFG { static boolean isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; return true ; } static int minRemovals ( String str ) { if ( str . charAt ( 0 ) == '') return 0 ; if ( isPalindrome ( str ) ) return 1 ; return 2 ; } public static void main ( String [ ] args ) { System . out . println ( minRemovals ( \"010010\" ) ) ; System . out . println ( minRemovals ( \"0100101\" ) ) ; } }"}
{"text": "Cari nilai xxxx .... . (N kali) % m di mana n adalah besar | Pelaksanaan Java pendekatan; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini x jika ia> = p; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y / 2; Fungsi untuk mengembalikan xxx .... . (N kali) % m; Mengembalikan mod dengan m nombor yang lebih kecil; Mewujudkan rentetan n x 's; Menukar rentetan ke int dan mengira modulo; Memeriksa pariti n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk ganjil n; Kod pemacu; Cetak xxx ... (n kali) % m", "code": "class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static int findModuloByM ( int X , int N , int M ) { if ( N < 6 ) { String temp = \" \" ; for ( int i = 0 ; i < N ; i ++ ) temp = temp + ( char ) ( X + 48 ) ; int res = Integer . parseInt ( temp ) % M ; return res ; } if ( N % 2 == 0 ) { int half = findModuloByM ( X , N / 2 , M ) % M ; int res = ( half * power ( 10 , N / 2 , M ) + half ) % M ; return res ; } else { int half = findModuloByM ( X , N / 2 , M ) % M ; int res = ( half * power ( 10 , N / 2 + 1 , M ) + half * 10 + X ) % M ; return res ; } } public static void main ( String [ ] args ) { int X = 6 , N = 14 , M = 9 ; System . out . println ( findModuloByM ( X , N , M ) ) ; } }"}
{"text": "Semak jika dua lingkaran bersilang sedemikian rupa sehingga bulatan ketiga melewati titik -titik persimpangan dan pusat mereka | Pendekatan Java untuk pendekatan di atas; Struktur bulatan; Fungsi utiliti untuk memeriksa sama ada lingkaran yang diberikan memenuhi kriteria yang diperlukan; Menyimpan jarak antara pusat C1 dan C2; Menyimpan status jika kriteria yang diberikan berpuas hati atau tidak; Jika C1C2 kurang daripada jumlah radii 2 lingkaran pertama; Jika C3 adalah titik tengah pusat di C1 dan C2; Tanda bendera benar; Bendera kembali; Fungsi untuk memeriksa sama ada lingkaran yang diberikan memenuhi kriteria yang diperlukan; Semak kombinasi bulatan semasa; Semak kombinasi seterusnya; Kod pemacu", "code": "class GFG { static class circle { double x ; double y ; double r ; public circle ( int x , int y , int r ) { this . x = x ; this . y = y ; this . r = r ; } } static boolean check ( circle C [ ] ) { double C1C2 = Math . sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) ; boolean flag = false ; if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) { if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x && ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) { flag = true ; } } return flag ; } static boolean IsFairTriplet ( circle c [ ] ) { boolean f = false ; f |= check ( c ) ; for ( int i = 0 ; i < 2 ; i ++ ) { swap ( c [ 0 ] , c [ 2 ] ) ; f |= check ( c ) ; } return f ; } static void swap ( circle circle1 , circle circle2 ) { circle temp = circle1 ; circle1 = circle2 ; circle2 = temp ; } public static void main ( String [ ] args ) { circle C [ ] = new circle [ 3 ] ; C [ 0 ] = new circle ( 0 , 0 , 8 ) ; C [ 1 ] = new circle ( 0 , 10 , 6 ) ; C [ 2 ] = new circle ( 0 , 5 , 5 ) ; if ( IsFairTriplet ( C ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Program untuk mencari eksentrik hyperbola | Program Java untuk pendekatan di atas; Berfungsi untuk mencari eksentrik hiperbola; Menyimpan nisbah kuadrat paksi utama kepada paksi kecil; Kenaikan r oleh 1; Mengembalikan akar kuadrat R; Kod pemacu", "code": "import java . util . * ; class GFG { static double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return Math . sqrt ( r ) ; } public static void main ( String [ ] args ) { double A = 3.0 , B = 2.0 ; System . out . print ( eccHyperbola ( A , B ) ) ; } }"}
{"text": "Kirakan kawasan kuadrilateral kitaran dengan panjang sampingan yang diberikan | Program Java untuk pendekatan di atas; Berfungsi untuk mencari kawasan kuadrilateral kitaran; Menyimpan nilai separuh perimeter; Kedai kawasan kuadrilateral kitaran; Mengembalikan kawasan yang dihasilkan; Kod pemacu", "code": "import java . io . * ; class GFG { static float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = ( float ) Math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; } public static void main ( String [ ] args ) { float A = 10 ; float B = 15 ; float C = 20 ; float D = 25 ; System . out . println ( calculateArea ( A , B , C , D ) ) ; } }"}
{"text": "Kirakan nisbah kawasan segitiga yang tertulis dalam elips dan segitiga yang dibentuk oleh titik yang sama pada bulatan tambahan | Program Java untuk pendekatan di atas; Fungsi untuk mengira nisbah segitiga yang tertulis dalam elips ke segitiga pada bulatan tambahan; Menyimpan nisbah separuh besar hingga separuh kapak kecil; Cetak nisbah; Kod pemacu", "code": "class GFG { static void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; System . out . println ( ratio ) ; } public static void main ( String args [ ] ) { int a = 1 , b = 2 ; triangleArea ( a , b ) ; } }"}
{"text": "Program untuk mencari excenters segitiga | Program Java untuk pendekatan di atas; Berfungsi untuk mengira jarak antara sepasang mata; Fungsi untuk mengira koordinat excenters segitiga; Panjang sisi segitiga; Menyimpan koordinat excenters segitiga; Untuk i1; Untuk i2; Untuk i3; Cetak excenters segitiga; Kod pemacu", "code": "import java . util . * ; class GFG { static class pair { float first , second ; pair ( float first , float second ) { this . first = first ; this . second = second ; } } static float distance ( int m , int n , int p , int q ) { return ( float ) Math . sqrt ( Math . pow ( n - m , 2 ) + Math . pow ( q - p , 2 ) * 1.0 ) ; } static void Excenters ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { float a = distance ( x2 , x3 , y2 , y3 ) ; float b = distance ( x3 , x1 , y3 , y1 ) ; float c = distance ( x1 , x2 , y1 , y2 ) ; pair [ ] excenter = new pair [ 4 ] ; excenter [ 1 ] = new pair ( ( - ( a * x1 ) + ( b * x2 ) + ( c * x3 ) ) / ( - a + b + c ) , ( - ( a * y1 ) + ( b * y2 ) + ( c * y3 ) ) / ( - a + b + c ) ) ; excenter [ 2 ] = new pair ( ( ( a * x1 ) - ( b * x2 ) + ( c * x3 ) ) / ( a - b + c ) , ( ( a * y1 ) - ( b * y2 ) + ( c * y3 ) ) / ( a - b + c ) ) ; excenter [ 3 ] = new pair ( ( ( a * x1 ) + ( b * x2 ) - ( c * x3 ) ) / ( a + b - c ) , ( ( a * y1 ) + ( b * y2 ) - ( c * y3 ) ) / ( a + b - c ) ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { System . out . println ( ( int ) excenter [ i ] . first + \" ▁ \" + ( int ) excenter [ i ] . second ) ; } } public static void main ( String [ ] args ) { int x1 , x2 , x3 , y1 , y2 , y3 ; x1 = 0 ; x2 = 3 ; x3 = 0 ; y1 = 0 ; y2 = 0 ; y3 = 4 ; Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) ; } }"}
{"text": "Program untuk mencari ketinggian trapezoid | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mengira ketinggian trapezoid; Memohon formula Heron; Hitung kawasan; Hitung ketinggian trapezoid; Cetak ketinggian; Kod pemacu; Memandangkan A, B, P1 dan P2", "code": "import java . util . * ; class GFG { static void findHeight ( float p1 , float p2 , float b , float c ) { float a = Math . max ( p1 , p2 ) - Math . min ( p1 , p2 ) ; float s = ( a + b + c ) / 2 ; float area = ( int ) Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; float height = ( area * 2 ) / a ; System . out . print ( \" Height ▁ is : ▁ \" + height ) ; } public static void main ( String args [ ] ) { float p1 = 25 , p2 = 10 ; float a = 14 , b = 13 ; findHeight ( p1 , p2 , a , b ) ; } }"}
{"text": "Nombor Icositetragonal | Program Java untuk mencari nombor icositetragon nth; Berfungsi untuk mencari nombor icositetragonal; Formula untuk mengira nombor icositetragonal nth; Kod pemacu", "code": "import java . util . * ; class GFG { static int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( Icositetragonal_num ( n ) ) ; n = 10 ; System . out . println ( Icositetragonal_num ( n ) ) ; } }"}
{"text": "Kawasan bulatan yang ditulis dalam trapezoid isosceles | Program Java untuk mencari rea dari bulatan yang ditulis dalam trapezoid yang mempunyai sisi bukan selari m, n; Fungsi untuk mencari kawasan bulatan yang ditulis dalam trapezoid yang mempunyai sisi bukan selari m, n; Radius bulatan oleh formula i. e. akar (m * n) / 2 kawasan bulatan = (3.141) * (r * * 2); Kod pemacu", "code": "class GFG { static double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; } public static void main ( String [ ] args ) { int n = 10 ; int m = 30 ; System . out . println ( area_of_circle ( m , n ) ) ; } }"}
{"text": "Kawasan segitiga sama rata yang tertulis dalam lingkaran radius r | Pelaksanaan Java untuk mencari kawasan segitiga sama rata yang tertulis dalam lingkaran radius r; Berfungsi untuk mencari kawasan segitiga sama rata yang tertulis dalam lingkaran radius r; Asas dan ketinggian segitiga sama rata; Kawasan menggunakan asas dan ketinggian; Kod pemacu", "code": "class GFG { static double area ( int R ) { double base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; } public static void main ( String [ ] args ) { int R = 7 ; System . out . println ( area ( R ) ) ; } }"}
{"text": "Kawasan bulatan terbesar yang boleh ditulis dalam separuh bulatan | Program Java untuk mencari bulatan terbesar yang boleh ditulis dalam separuh bulatan; Berfungsi untuk mencari kawasan bulatan; Radius tidak boleh negatif; Kawasan bulatan terbesar; Kod pemacu", "code": "class GFG { static float circlearea ( float R ) { if ( R < 0 ) return - 1 ; float a = ( float ) ( ( 3.14 * R * R ) / 4 ) ; return a ; } public static void main ( String [ ] args ) { float R = 2 ; System . out . println ( circlearea ( R ) ) ; } }"}
{"text": "Bilangan pasang garisan yang mempunyai titik persimpangan integer | Program Java kepada bilangan pasang garis yang mempunyai titik persimpangan integer; Mengira bilangan pasang garis yang mempunyai titik persimpangan integer; Memulakan susunan untuk menyimpan tuduhan; Kiraan bilangan ganjil dan bahkan pi; Kiraan bilangan ganjil dan bahkan qi; Mengembalikan kiraan pasangan; Kod pemacu", "code": "class GFG { static int countPairs ( int [ ] P , int [ ] Q , int N , int M ) { int [ ] A = new int [ 2 ] , B = new int [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; } public static void main ( String [ ] args ) { int [ ] P = { 1 , 3 , 2 } ; int [ ] Q = { 3 , 0 } ; int N = P . length ; int M = Q . length ; System . out . print ( countPairs ( P , Q , N , M ) ) ; } }"}
{"text": "Bilangan maksimum persimpangan garis yang dibentuk melalui persimpangan pesawat N | Pelaksanaan Java pendekatan; Berfungsi untuk mengira bilangan maksimum persimpangan yang mungkin; Kod pemacu", "code": "class GFG { static int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countIntersections ( n ) ) ; } }"}
{"text": "Kawasan pentagram biasa | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mengembalikan kawasan segitiga BCD; Menggunakan nisbah emas; Hitung kawasan segitiga BCD; Kawasan pulangan semua 5 segitiga adalah sama; Berfungsi untuk mengembalikan kawasan pentagon biasa; Kirakan kawasan pentagon biasa menggunakan formula di atas; Kawasan pulangan Pentagon biasa; Berfungsi untuk mengembalikan kawasan pentagram; Kawasan pentagram adalah sama dengan kawasan pentagon biasa dan lima kali kawasan segitiga; Kod pemacu", "code": "public class GFG { static double PI = 3.14159 ; static double areaOfTriangle ( float d ) { float c = ( float ) ( 1.618 * d ) ; float s = ( d + c + c ) / 2 ; double area = Math . sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) ; return 5 * area ; } static double areaOfRegPentagon ( float d ) { double cal = 4 * Math . tan ( PI / 5 ) ; double area = ( 5 * d * d ) / cal ; return area ; } static double areaOfPentagram ( float d ) { return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) ; } public static void main ( String [ ] args ) { float d = 5 ; System . out . println ( areaOfPentagram ( d ) ) ; } }"}
{"text": "Sudut yang disebarkan oleh kord ke pusat bulatan apabila sudut yang disuntik oleh kord lain yang sama dari lingkaran kongruen diberikan | Program Java untuk mencari sudut yang disembur oleh kord ke pusat bulatan apabila sudut yang diselaraskan oleh kord lain yang sama dari lingkaran kongruen diberikan; Kod pemacu", "code": "import java . io . * ; class GFG { static void anglequichord ( int z ) { System . out . println ( \" The ▁ angle ▁ is ▁ \" + z + \" ▁ degrees \" ) ; } public static void main ( String [ ] args ) { int z = 48 ; anglequichord ( z ) ; } }"}
{"text": "Program untuk mencetak nilai ASCII bagi semua digit nombor tertentu | Program Java untuk menukar digit nombor kepada nilai ASCIInya; Berfungsi untuk menukar digit N ke nilai ASCII masing -masing; Kod pemacu", "code": "import java . util . * ; class GFG { static void convertToASCII ( int N ) { String num = Integer . toString ( N ) ; for ( char ch : num . toCharArray ( ) ) { System . out . print ( ch + \" ▁ ( \" + ( int ) ch + \")NEW_LINE\"); } } public static void main ( String [ ] args ) { int N = 36 ; convertToASCII ( N ) ; } }"}
{"text": "Teka -teki Arus Produk | Set 3 | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk membentuk pelbagai produk dengan ruang O (n) dan o (1); Menyimpan produk array; Menyimpan kiraan sifar; Melintasi array; Jika arr [i] tidak sifar; Jika arr [i] adalah sifar maka kiraan kenaikan z oleh 1; Menyimpan nilai mutlak produk; Jika z sama dengan 1; Jika arr [i] tidak sifar; Lain; Jika kiraan 0 s sekurang -kurangnya 2; Berikan arr [i] = 0; Simpan nilai mutlak arr [i]; Cari nilai A / B; Jika arr [i] dan produk kedua -duanya kurang daripada sifar; Jika arr [i] dan produk kedua -duanya lebih besar daripada sifar; Lain; Melintasi array arr []; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void productExceptSelf ( int arr [ ] , int N ) { int product = 1 ; int z = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) product *= arr [ i ] ; if ( arr [ i ] == 0 ) z += 1 ; } int a = Math . abs ( product ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( z == 1 ) { if ( arr [ i ] != 0 ) arr [ i ] = 0 ; else arr [ i ] = product ; continue ; } else if ( z > 1 ) { arr [ i ] = 0 ; continue ; } int b = Math . abs ( arr [ i ] ) ; int curr = ( int ) Math . round ( Math . exp ( Math . log ( a ) - Math . log ( b ) ) ) ; if ( arr [ i ] < 0 && product < 0 ) arr [ i ] = curr ; else if ( arr [ i ] > 0 && product > 0 ) arr [ i ] = curr ; else arr [ i ] = - 1 * curr ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + \" ▁ \" ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 3 , 5 , 6 , 2 } ; int N = arr . length ; productExceptSelf ( arr , N ) ; } }"}
{"text": "Count Subarrays terdiri daripada single | Program Java untuk pendekatan di atas; Fungsi untuk mengira subarrays yang terdiri daripada bilangan bulat tunggal sahaja; Kedai kiraan subarray; Menyimpan kiraan nombor angka tunggal berturut -turut dalam array; Melintasi array; Saiz kenaikan blok sebanyak 1; Peningkatan res mengikut kiraan; Menetapkan kiraan = 0; Kod pemacu; Diberikan array; Saiz array", "code": "class GFG { static void singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } System . out . print ( res ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 14 , 2 , 5 } ; int N = arr . length ; singleDigitSubarrayCount ( arr , N ) ; } }"}
{"text": "Kira bilangan bulat sehingga n yang boleh diwakili sebagai jumlah dua atau lebih nombor berturut -turut | Program Java pendekatan di atas; Fungsi untuk memeriksa sama ada nombor n boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut atau tidak; Fungsi untuk mengira bilangan bulat dalam julat [1, n] yang boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut; Menyimpan kiraan yang diperlukan; Kod pemacu", "code": "import java . io . * ; class GFG { static int isPossible ( int N ) { return ( ( ( N & ( N - 1 ) ) & N ) ) ; } static void countElements ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isPossible ( i ) != 0 ) count ++ ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int N = 15 ; countElements ( N ) ; } }"}
{"text": "Kira bilangan bulat sehingga n yang boleh diwakili sebagai jumlah dua atau lebih nombor berturut -turut | Pelaksanaan Java pendekatan di atas; Fungsi untuk mengira bilangan bulat dalam julat [1, n] yang boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut; Mengira kuasa 2 sehingga n; Kiraan kenaikan; Mengemas kini kuasa semasa 2; Kod pemacu", "code": "import java . util . * ; class GFG { static void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } System . out . print ( N - Count ) ; } public static void main ( String [ ] args ) { int N = 15 ; countElements ( N ) ; } }"}
{"text": "Perbezaan maksimum antara sepasang elemen bersebelahan dengan tidak termasuk setiap elemen sekali | Program Java untuk pendekatan di atas; Fungsi untuk mengira perbezaan maksimum antara elemen bersebelahan tidak termasuk setiap elemen array sekali; Kirakan perbezaan bersebelahan maksimum untuk keseluruhan array; Simpan maksimum antara arr_max dan curr_max; Tambah hasilnya ke dalam vektor; Cetak hasilnya; Kod pemacu", "code": "import java . util . * ; class GFG { static void maxAdjacent ( int [ ] arr , int N ) { Vector < Integer > res = new Vector < Integer > ( ) ; int arr_max = Integer . MIN_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { arr_max = Math . max ( arr_max , Math . abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( int i = 1 ; i < N - 1 ; i ++ ) { int curr_max = Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; int ans = Math . max ( curr_max , arr_max ) ; res . add ( ans ) ; } for ( int x : res ) System . out . print ( x + \" ▁ \" ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = arr . length ; maxAdjacent ( arr , N ) ; } }"}
{"text": "Kurangkan kenaikan yang diperlukan untuk membuat kiraan elemen array yang sama dan ganjil sama | Program Java untuk pendekatan di atas; Berfungsi untuk mencari operasi min untuk membuat kiraan yang sama dan ganjil sama; Saiz ganjil tidak akan menjadi ganjil dan juga dianggap sama; Menyimpan kiraan nombor walaupun dalam array arr []; Kedai mengira nombor ganjil dalam array arr []; Melintasi array arr []; Jika arr [i] adalah nombor yang sama; Kemas kini cnteven; Nombor ganjil dalam arr []; Kembali perbezaan mutlak dibahagikan dengan 2; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; import java . lang . * ; class GFG { static int minimumIncrement ( int arr [ ] , int N ) { if ( N % 2 != 0 ) { System . out . println ( \" - 1\" ) ; System . exit ( 0 ) ; } int cntEven = 0 ; int cntOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cntEven += 1 ; } } cntOdd = N - cntEven ; return Math . abs ( cntEven - cntOdd ) / 2 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 9 } ; int N = arr . length ; System . out . println ( minimumIncrement ( arr , N ) ) ; } }"}
{"text": "Kira cara untuk membina array dengan produk walaupun dari array yang diberikan sedemikian rupa sehingga perbezaan mutlak unsur -unsur yang diindeks sama paling banyak 1 | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mencari mengira cara untuk membina array, B [] seperti abs (a [i] - b [i]) <= 1 dan produk unsur -unsur B [] adalah walaupun; Kedai kiraan tatasusunan b [] seperti abs (a [i] - b [i]) <= 1; Kedai -kedai Count of Arrays B [] yang produk elemennya tidak; Melintasi array; Jumlah kemas kini; Jika [i] adalah nombor yang sama; Kemas kini Oddarray; Cetak 3 ^ n - 2 ^ x; Kod pemacu", "code": "import java . util . * ; class GFG { static void cntWaysConsArray ( int A [ ] , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } System . out . println ( total - oddArray ) ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 4 } ; int N = A . length ; cntWaysConsArray ( A , N ) ; } }"}
{"text": "Kira nombor sehingga n yang paling tepat ditetapkan adalah k | Program Java untuk pendekatan di atas; Fungsi untuk mengira nombor dalam julat [1, n] yang paling tepat ditetapkan adalah k; Menyimpan nombor yang paling tepat adalah k; Nombor yang paling tepat adalah i; Mengurangkan nombor yang paling tepat ditetapkan adalah saya, dari n; Oleh kerana i = k, maka nombor yang paling tepat ditetapkan adalah k disimpan; Kod pemacu", "code": "import java . util . Arrays ; class GFG { static void countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } System . out . println ( numbers_rightmost_setbit_K ) ; } static public void main ( String args [ ] ) { int N = 15 ; int K = 2 ; countNumberHavingKthBitSet ( N , K ) ; } }"}
{"text": "Kira pekali ganjil dan bahkan binomial N | Program Java untuk pendekatan di atas; Fungsi untuk mengira set bit dalam perwakilan binari nombor n; Count set bit dalam n; Mengembalikan kiraan akhir; Kod pemacu; Cetak koefisien binomial ganjil; Cetak walaupun koefisien binomial", "code": "import java . util . * ; class GFG { static int countSetBits ( int N ) { int count = 0 ; while ( N != 0 ) { N = N & ( N - 1 ) ; count ++ ; } return count ; } public static void main ( String [ ] args ) { int N = 4 ; int bits = countSetBits ( N ) ; System . out . println ( \" Odd ▁ \" + \" : ▁ \" + ( int ) ( Math . pow ( 2 , bits ) ) ) ; System . out . println ( \" Even ▁ \" + \" : ▁ \" + ( N + 1 - ( int ) ( Math . pow ( 2 , bits ) ) ) ) ; } }"}
{"text": "Buat semua elemen array walaupun dengan menggantikan mana -mana sepasang elemen array dengan jumlah mereka | Program Java untuk pendekatan di atas; Fungsi untuk mencari bilangan minimum penggantian yang diperlukan untuk membuat semua elemen array walaupun; Menyimpan kiraan elemen ganjil; Melintasi array; Meningkatkan kiraan elemen ganjil; Bilangan penggantian yang diperlukan; Dua langkah tambahan diperlukan untuk membuat elemen ganjil yang terakhir walaupun; Cetak penggantian minimum; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void minMoves ( int arr [ ] , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; System . out . print ( moves ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 3 , 7 , 20 } ; int N = arr . length ; minMoves ( arr , N ) ; } }"}
{"text": "Split Squares of First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Program Java untuk pendekatan di atas; Berfungsi untuk partition squares nombor semulajadi dalam dua subset; Simpan kiraan blok saiz 8; Pemisahan blok 8 elemen; Simpan perbezaan subset minimum; Pemisahan elemen N untuk meminimumkan perbezaan jumlah subset mereka; Simpan unsur subset A dan B; Jika elemen adalah jenis A; Jika elemen adalah jenis B; Cetak perbezaan subset minimum; Cetak subset pertama; Cetak subset kedua; Kod pemacu; Panggilan fungsi", "code": "import java . util . Arrays ; class GFG { static void minimumSubsetDifference ( int N ) { int blockOfSize8 = N / 8 ; String str = \" ABBABAAB \" ; int subsetDifference = 0 ; String partition = \" \" ; while ( blockOfSize8 -- > 0 ) { partition += str ; } int A [ ] = new int [ N ] ; int B [ ] = new int [ N ] ; int x = 0 , y = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( partition . charAt ( i ) == ' A ' ) { A [ x ++ ] = ( ( i + 1 ) * ( i + 1 ) ) ; } else { B [ y ++ ] = ( ( i + 1 ) * ( i + 1 ) ) ; } } System . out . println ( subsetDifference ) ; for ( int i = 0 ; i < x ; i ++ ) System . out . print ( A [ i ] + \" ▁ \" ) ; System . out . println ( ) ; for ( int i = 0 ; i < y ; i ++ ) System . out . print ( B [ i ] + \" ▁ \" ) ; } public static void main ( String [ ] args ) { int N = 8 ; minimumSubsetDifference ( N ) ; } }"}
{"text": "Pembahagi terbesar nombor yang tidak dapat dibahagikan dengan nombor yang lain | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari nombor terbesar x supaya ia membahagikan p tetapi tidak dapat dibahagikan dengan q; Menyimpan kiraan kekerapan semua faktor utama; Meningkatkan kekerapan faktor utama semasa; Jika Q adalah faktor utama; Menyimpan hasil yang diingini; Melangkah melalui semua pembahagi Q; Menyimpan kiraan kekerapan pembahagi utama semasa untuk membahagikan p; Mengira kekerapan faktor utama semasa; Jika CUR kurang daripada kekerapan maka p adalah hasil akhir; Berulang untuk mendapatkan jawapan sementara; Mengemas kini jawapan semasa; Cetak hasil yang diinginkan; Kod pemacu; Diberikan p dan q; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void findTheGreatestX ( int P , int Q ) { HashMap < Integer , Integer > divisiors = new HashMap < > ( ) ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 && Q > 1 ) { Q /= i ; if ( divisiors . containsKey ( i ) ) { divisiors . put ( i , divisiors . get ( i ) + 1 ) ; } else { divisiors . put ( i , 1 ) ; } } } if ( Q > 1 ) if ( divisiors . containsKey ( Q ) ) { divisiors . put ( Q , divisiors . get ( Q ) + 1 ) ; } else { divisiors . put ( Q , 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > i : divisiors . entrySet ( ) ) { int frequency = i . getValue ( ) ; int temp = P ; int cur = 0 ; while ( temp % i . getKey ( ) == 0 ) { temp /= i . getKey ( ) ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= i . getKey ( ) ; } ans = Math . max ( temp , ans ) ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int P = 10 , Q = 4 ; findTheGreatestX ( P , Q ) ; } }"}
{"text": "Semak jika baris matriks boleh disusun semula untuk membuat bitwise xor lajur pertama non | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada ada baris di mana bilangan elemen unik lebih besar daripada 1; Melangkah ke atas matriks; Fungsi untuk memeriksa sama ada mungkin untuk menyusun semula tikar [] [] supaya xor lajur pertamanya bukan sifar; Cari bitwise xor lajur pertama Mat [] []; Jika bitwise xor lajur pertama tikar [] [] bukan sifar; Jika tidak, periksa semula; Kod pemacu; Diberikan matriks mat [] []; Panggilan fungsi", "code": "import java . util . * ; class GFG { static String checkRearrangements ( int [ ] [ ] mat , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ 0 ] != mat [ i ] [ j ] ) { return \" Yes \" ; } } } return \" No \" ; } static String nonZeroXor ( int [ ] [ ] mat , int N , int M ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res = res ^ mat [ i ] [ 0 ] ; } if ( res != 0 ) return \" Yes \" ; else return checkRearrangements ( mat , N , M ) ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 1 , 2 } , { 2 , 2 , 2 } , { 3 , 3 , 3 } } ; int N = mat . length ; int M = mat [ 0 ] . length ; System . out . print ( nonZeroXor ( mat , N , M ) ) ; } }"}
{"text": "Memaksimumkan bitwise dan elemen pertama dengan pelengkap elemen yang tinggal untuk sebarang permutasi array yang diberikan | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk memaksimumkan nilai untuk fungsi yang diberikan dan elemen array; Arahan vektor untuk mengekalkan bit mana yang ditetapkan untuk integer dalam array yang diberikan dengan menyimpan indeks integer itu; Semak jika b - th bit ditetapkan untuk integer i - th; Tolak indeks integer itu dalam setbit [j]; Cari elemen yang mempunyai bit set signifikan tertinggi dalam unsur -unsur lain; Letakkan integer itu pada indeks 0 - th; Simpan maksimum dan nilai; Kembalikan jawapannya; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static final int size_int = 32 ; static int functionMax ( int arr [ ] , int n ) { Vector < Integer > [ ] setBit = new Vector [ 32 + 1 ] ; for ( int i = 0 ; i < setBit . length ; i ++ ) setBit [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) setBit [ j ] . add ( i ) ; } } for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . size ( ) == 1 ) { swap ( arr , 0 , setBit [ i ] . get ( 0 ) ) ; break ; } } int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 } ; int n = arr . length ; System . out . print ( functionMax ( arr , n ) ) ; } }"}
{"text": "Jumlah semua produk koefisien binomial dua nombor sehingga k | Pelaksanaan Java pendekatan di atas; Fungsi mengembalikan NCR i. e. Pekali binomial; Memulakan res dengan 1; Kerana c (n, r) = c (n, n - r); Menilai ungkapan; Berfungsi untuk mengira dan mengembalikan jumlah produk; Memulakan jumlah hingga 0; Melintasi 0 hingga k; Kod pemacu", "code": "import java . util . * ; class GFG { static int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static int solve ( int n , int m , int k ) { int sum = 0 ; for ( int i = 0 ; i <= k ; i ++ ) sum += nCr ( n , i ) * nCr ( m , k - i ) ; return sum ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 , k = 2 ; System . out . print ( solve ( n , m , k ) ) ; } }"}
{"text": "Exponention Cepat Menggunakan Manipulasi Bit | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan A ^ n; Kedai Jawapan Akhir; Semak jika LSB semasa ditetapkan; Peralihan kanan; Kod pemacu", "code": "class GFG { static int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; } public static void main ( String [ ] args ) { int a = 3 , n = 5 ; System . out . print ( powerOptimised ( a , n ) ) ; } }"}
{"text": "Cari M sedemikian rupa sehingga GCD M dan Nombor N adalah maksimum | Program Java untuk pendekatan di atas; Berfungsi untuk mencari integer m sedemikian rupa sehingga GCD (n, m) adalah maksimum; Memulakan pembolehubah; Cari semua pembahagi N dan kembalikan pembahagi maksimum; Semak jika saya boleh dibahagikan dengan n; Kemas kini max_gcd; Mengembalikan nilai maksimum; Kod pemacu; Nombor yang diberikan; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . print ( findMaximumGcd ( N ) ) ; } }"}
{"text": "Elemen pertama setiap set K mempunyai unsur berturut -turut dengan faktor -faktor utama yang kurang daripada n | Program Java untuk pendekatan di atas; Untuk menyimpan faktor utama terkecil; Fungsi Array Faktor Perdana Consmallest; Tandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri. ; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Semak jika saya adalah Perdana; Mark SPF untuk semua nombor yang boleh dibahagikan oleh i; Mark SPF [J] jika ia tidak ditandakan sebelum ini; Fungsi untuk jumlah jumlah faktor utama; Fungsi untuk mencetak unsur -unsur set un elemen berturut -turut yang mempunyai faktor utama; Untuk menyimpan hasilnya; Mengira bilangan faktor utama nombor; Jika nombor mempunyai faktor yang betul -betul mendorong hasil []; Melangkah sehingga kita mendapat unsur -unsur berturut -turut dalam hasil []; Mengira urutan sehingga k; Cetak elemen jika Count> = k; Kod pemacu; Untuk membina SPF []; Diberikan n dan k; Panggilan fungsi", "code": "import java . util . * ; class GFG { static final int x = 2000021 ; static int [ ] v = new int [ x ] ; static void sieve ( ) { v [ 1 ] = 1 ; for ( int i = 2 ; i < x ; i ++ ) v [ i ] = i ; for ( int i = 4 ; i < x ; i += 2 ) v [ i ] = 2 ; for ( int i = 3 ; i * i < x ; i ++ ) { if ( v [ i ] == i ) { for ( int j = i * i ; j < x ; j += i ) { if ( v [ j ] == j ) { v [ j ] = i ; } } } } } static int prime_factors ( int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; while ( n != 1 ) { s . add ( v [ n ] ) ; n = n / v [ n ] ; } return s . size ( ) ; } static void distinctPrimes ( int m , int k ) { Vector < Integer > result = new Vector < Integer > ( ) ; for ( int i = 14 ; i < m + k ; i ++ ) { long count = prime_factors ( i ) ; if ( count == k ) { result . add ( i ) ; } } int p = result . size ( ) ; for ( int index = 0 ; index < p - 1 ; index ++ ) { long element = result . get ( index ) ; int count = 1 , z = index ; while ( z < p - 1 && count <= k && result . get ( z ) + 1 == result . get ( z + 1 ) ) { count ++ ; z ++ ; } if ( count >= k ) System . out . print ( element + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { sieve ( ) ; int N = 1000 , K = 3 ; distinctPrimes ( N , K ) ; } }"}
{"text": "Produk nombor kompleks menggunakan tiga operasi pendaraban | Program Java untuk pendekatan di atas; Berfungsi untuk membiak nombor kompleks dengan hanya tiga pendaraban; Cari nilai prod1, prod2 dan prod3; Bahagian sebenar; Bahagian khayalan; Cetak hasilnya; Kod pemacu; Diberi empat nombor; Panggilan fungsi", "code": "class GFG { static void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; System . out . println ( real + \" ▁ + ▁ \" + imag + \" i \" ) ; } public static void main ( String [ ] args ) { int a = 2 ; int b = 3 ; int c = 4 ; int d = 5 ; print_product ( a , b , c , d ) ; } }"}
{"text": "Nombor Insolite | Pelaksanaan Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor adalah nombor insolit; Untuk menyimpan jumlah kuadrat digit; Untuk menyimpan produk dataran digit; mengekstrak digit; Kod pemacu; Panggilan fungsi", "code": "class GFG { static boolean isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; } public static void main ( String [ ] args ) { int N = 111 ; if ( isInsolite ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text": "Nombor Superabundant | Pelaksanaan Java untuk memeriksa sama ada nombor adalah superbundant; Fungsi untuk mengira jumlah semua pembahagi nombor tertentu; Jumlah pembahagi; Cari semua pembahagi yang membahagikan 'num'; Jika 'saya' adalah pembahagi 'n'; Jika kedua -dua pembahagi adalah sama maka tambahkannya sekali lagi tambah kedua -duanya; Tambah 1 dan N untuk menghasilkan seperti gelung di atas menganggap pembahagi yang betul lebih besar daripada 1; Berfungsi untuk memeriksa sama ada n adalah nombor superbundant; Untuk memeriksa semua nombor dari 1 hingga n; Kod pemacu", "code": "class GFG { static int sigma ( int n ) { if ( n == 1 ) return 1 ; int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; } static boolean isSuperabundant ( int N ) { for ( double i = 1 ; i < N ; i ++ ) { double x = sigma ( ( int ) ( i ) ) / i ; double y = sigma ( ( int ) ( N ) ) / ( N * 1.0 ) ; if ( x > y ) return false ; } return true ; } public static void main ( String [ ] args ) { int N = 4 ; if ( isSuperabundant ( N ) ) System . out . print ( \"YesNEW_LINE\"); else System . out . print ( \"NoNEW_LINE\"); } }"}
{"text": "D Nombor | Pelaksanaan Java untuk pendekatan di atas; Berfungsi untuk mencari nombor N - th icosikaipentagon; Nombor hendaklah lebih besar daripada 3; Semak setiap k dalam julat 2 hingga n - 1; Keadaan untuk nombor D; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean isDNum ( int n ) { if ( n < 4 ) return false ; int numerator = 0 , hcf = 0 ; for ( int k = 2 ; k <= n ; k ++ ) { numerator = ( int ) ( Math . pow ( k , n - 2 ) - k ) ; hcf = __gcd ( n , k ) ; } if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int n = 15 ; boolean a = isDNum ( n ) ; if ( a ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text": "Ruth | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Berfungsi untuk memeriksa nombor Ruth - Aaron; Kod pemacu", "code": "class GFG { static int Sum ( int N ) { int SumOfPrimeDivisors [ ] = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 1 ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } static boolean RuthAaronNumber ( int n ) { if ( Sum ( n ) == Sum ( n + 1 ) ) return true ; else return false ; } public static void main ( String [ ] args ) { int N = 714 ; if ( RuthAaronNumber ( N ) ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } }"}
{"text": "Memaksimumkan jumlah perbezaan mutlak antara unsur -unsur bersebelahan dalam array dengan jumlah k | Program Java untuk memaksimumkan jumlah perbezaan mutlak antara unsur -unsur bersebelahan; Fungsi untuk memaksimumkan jumlah; Perbezaan adalah 0 apabila hanya satu elemen yang terdapat dalam array; Perbezaan adalah k apabila dua elemen hadir dalam pelbagai; Jika tidak; Kod pemacu", "code": "import java . util . * ; class GFG { static int maxAdjacentDifference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; } public static void main ( String [ ] args ) { int N = 6 ; int K = 11 ; System . out . print ( maxAdjacentDifference ( N , K ) ) ; } }"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | Tetapkan 2 | Program Java untuk pendekatan di atas; Fungsi mengembalikan jumlah nombor dari 1 hingga n; Fungsi mengembalikan jumlah nombor dari A + 1 hingga B; Fungsi mengembalikan jumlah jumlah pembahagi; Kedai Jumlah Jumlah; Mencari nombor dan kejadiannya; Jumlah produk setiap nombor dan kejadiannya; Kod pemacu", "code": "class GFG { static final int mod = 1000000007 ; public static int linearSum ( int n ) { return ( n * ( n + 1 ) / 2 ) % mod ; } public static int rangeSum ( int b , int a ) { return ( linearSum ( b ) - linearSum ( a ) ) % mod ; } public static int totalSum ( int n ) { int result = 0 ; int i = 1 ; while ( true ) { result += rangeSum ( n / i , n / ( i + 1 ) ) * ( i % mod ) % mod ; result %= mod ; if ( i == n ) break ; i = n / ( n / ( i + 1 ) ) ; } return result ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( totalSum ( N ) ) ; N = 12 ; System . out . println ( totalSum ( N ) ) ; } }"}
{"text": "Nombor undulant nontrivial | Pelaksanaan Java untuk memeriksa sama ada N adalah nombor undulant nontrivial; Fungsi untuk memeriksa sama ada rentetan adalah rentetan ganda atau tidak; A dan B tidak sepatutnya sama; Keadaan untuk memeriksa sama ada panjang ganjil membuat panjang walaupun; Separuh pertama s; Separuh kedua s; Rentetan double jika separuh pertama dan terakhir adalah sama; Fungsi untuk memeriksa sama ada n adalah nombor undulant yang tidak dapat dipulihkan; Kod pemacu", "code": "class GFG { static boolean isDouble ( int num ) { String s = Integer . toString ( num ) ; int l = s . length ( ) ; if ( s . charAt ( 0 ) == s . charAt ( 1 ) ) return false ; if ( l % 2 == 1 ) { s = s + s . charAt ( 1 ) ; l ++ ; } String s1 = s . substring ( 0 , l / 2 ) ; String s2 = s . substring ( l / 2 ) ; return s1 . equals ( s2 ) ; } static boolean isNontrivialUndulant ( int N ) { return N > 100 && isDouble ( N ) ; } public static void main ( String [ ] args ) { int n = 121 ; if ( isNontrivialUndulant ( n ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } }"}
{"text": "Nombor Megagon | Program Java untuk pendekatan di atas; Berfungsi untuk mencari nombor megagon nth; Kod pemacu", "code": "class GFG { static int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( MegagonNum ( n ) ) ; } }"}
{"text": "Produk semua pasangan dari array yang diberikan | Pelaksanaan Java untuk mencari produk semua pasangan dari array yang diberikan; Berfungsi untuk mengembalikan produk unsur -unsur semua pasangan yang mungkin dari array; Untuk menyimpan produk yang diperlukan; Gelung bersarang untuk mengira semua pasangan yang mungkin; Melipatgandakan produk unsur -unsur pasangan semasa; Mengembalikan hasil akhir; Kod pemacu", "code": "import java . util . * ; class GFG { static final int mod = 1000000007 ; static int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( productPairs ( arr , n ) ) ; } }"}
{"text": "Produk semua pasangan dari array yang diberikan | Pelaksanaan Java untuk mencari produk semua pasangan dari array yang diberikan; Fungsi untuk mengira (x ^ y) % 1000000007; Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; Mengembalikan hasil akhir; Berfungsi untuk mengembalikan produk unsur -unsur semua pasangan yang mungkin dari array; Untuk menyimpan produk yang diperlukan; Berulang untuk setiap elemen array; Setiap elemen muncul (2 * n) kali; Kod pemacu", "code": "import java . util . * ; class GFG { static final int mod = 1000000007 ; static int power ( int x , int y ) { int p = 1000000007 ; int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = ( product % mod * ( int ) power ( arr [ i ] , ( 2 * n ) ) % mod ) % mod ; } return product % mod ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( productPairs ( arr , n ) ) ; } }"}
{"text": "Membina array sedemikian rupa sehingga jumlah kiub semua elemen adalah persegi yang sempurna | Program Java untuk membina array bahawa jumlah kiub semua elemen adalah persegi yang sempurna; Berfungsi untuk membuat dan mencetak array; Memulakan pelbagai saiz n; Cetak array; Kod pemacu", "code": "import java . util . * ; class GFG { static void constructArray ( int N ) { int arr [ ] = new int [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + \" , ▁ \" ) ; } } public static void main ( String [ ] args ) { int N = 6 ; constructArray ( N ) ; } }"}
{"text": "Kira semua seterusnya yang produknya adalah nombor komposit | Pelaksanaan Java untuk mengira semua seterusnya yang produknya adalah nombor komposit; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Berfungsi untuk mencari bilangan berikutnya yang produknya adalah nombor komposit; Cari jumlah berikutnya yang tidak kosong; Cari kiraan nombor utama dan yang; Kirakan yang tidak kosong; Cari kiraan seterusnya komposit; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static int countSubsequences ( int arr [ ] , int n ) { int totalSubsequence = ( int ) ( Math . pow ( 2 , n ) - 1 ) ; int countPrime = 0 , countOnes = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) countOnes ++ ; else if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } int compositeSubsequence ; int onesSequence = ( int ) ( Math . pow ( 2 , countOnes ) - 1 ) ; compositeSubsequence = totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ; return compositeSubsequence ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 2 } ; int n = arr . length ; System . out . print ( countSubsequences ( arr , n ) ) ; } }"}
{"text": "Cari integer berturut -turut seperti jumlah mereka adalah n | Pelaksanaan Java untuk memeriksa sama ada nombor boleh dinyatakan sebagai jumlah integer K berturut -turut; Fungsi untuk memeriksa sama ada nombor boleh dinyatakan sebagai jumlah K berturut -turut; Mencari istilah pertama AP; Memeriksa jika istilah pertama adalah integer; Gelung untuk mencetak integer K berturut -turut; Kod pemacu", "code": "class GFG { static void checksum ( int n , int k ) { float first_term = ( float ) ( ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ) ; if ( first_term - ( int ) ( first_term ) == 0 ) { for ( int i = ( int ) first_term ; i <= first_term + k - 1 ; i ++ ) { System . out . print ( i + \" ▁ \" ) ; } } else System . out . print ( \" - 1\" ) ; } public static void main ( String [ ] args ) { int n = 33 , k = 6 ; checksum ( n , k ) ; } }"}
{"text": "Mewakili n sebagai jumlah k angka bahu | Pelaksanaan Java untuk mewakili N sebagai jumlah kalah K walaupun; Berfungsi untuk mencetak perwakilan; N mestilah lebih besar daripada sama dengan 2 * k dan mestilah bahkan; Kod pemacu", "code": "import java . util . * ; class GFG { static void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { System . out . print ( \"2 ▁ \" ) ; } System . out . println ( check ) ; } else { System . out . println ( \" - 1\" ) ; } } public static void main ( String args [ ] ) { int N = 8 ; int K = 2 ; sumEvenNumbers ( N , K ) ; } }"}
{"text": "Count of Subarrays Bersebelahan mungkin untuk setiap indeks dengan memasukkan elemen pada indeks itu | Program Java untuk mencari bilangan subarray bersebelahan termasuk elemen pada setiap indeks pelbagai saiz n; Berfungsi untuk mencari bilangan subarray termasuk elemen pada setiap indeks array; Mewujudkan pelbagai saiz n; Gelung itu berulang sehingga separuh panjang array; Keadaan untuk mengelakkan menimpa elemen pertengahan untuk array dengan panjangnya. ; Pengkomputeran bilangan subarray; Unsur ITH dari awal dan berakhir mempunyai bilangan subarray yang sama; Berfungsi untuk mencetak vektor; Kod pemacu", "code": "import java . util . Scanner ; class contiguous_subarrays { public static int [ ] calculateWays ( int n ) { int x = 0 ; int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( n % 2 == 0 && i == n / 2 ) break ; x = n * ( i + 1 ) - ( i + 1 ) * i ; v [ i ] = x ; v [ n - i - 1 ] = x ; } return v ; } public static void printArray ( int [ ] v ) { for ( int i = 0 ; i < v . length ; i ++ ) System . out . print ( v [ i ] + \" ▁ \" ) ; } public static void main ( String args [ ] ) { int [ ] v ; v = calculateWays ( 4 ) ; printArray ( v ) ; } }"}
{"text": "Nombor terkecil lebih besar daripada atau sama dengan x yang jumlah digitnya boleh dibahagikan dengan y | Program Java untuk mencari bilangan terkecil yang lebih besar daripada atau sama dengan x dan dibahagikan dengan y; Fungsi yang mengembalikan jumlah digit nombor; Memulakan pembolehubah untuk menyimpan jumlah; Tambah digit terakhir nombor; Keluarkan digit terakhir dari nombor; Fungsi yang mengembalikan bilangan terkecil lebih besar daripada atau sama dengan x dan dibahagikan dengan y; Memulakan pemboleh ubah hasil; Gelung melalui nombor yang lebih besar daripada sama dengan x; Hitung jumlah digit; Semak sama ada jumlah digit boleh dibahagikan dengan y; Kod pemacu", "code": "class GFG { static final int MAXN = 10000000 ; static int sumOfDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n /= 10 ; } return sum ; } static int smallestNum ( int X , int Y ) { int res = - 1 ; for ( int i = X ; i < MAXN ; i ++ ) { int sum_of_digit = sumOfDigits ( i ) ; if ( sum_of_digit % Y == 0 ) { res = i ; break ; } } return res ; } public static void main ( String [ ] args ) { int X = 5923 , Y = 13 ; System . out . print ( smallestNum ( X , Y ) ) ; } }"}
{"text": "Kira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan | Program Java untuk mengira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan; Fungsi untuk mengira nombor yang boleh menukar n ke 1 menggunakan operasi yang diberikan; Simpan semua pembahagi n; Jika saya seorang pembahagi; Jika saya tidak sama dengan N / I; Melangkah melalui semua pembahagi n - 1 dan mengira mereka sebagai jawapan; Semak jika N - 1 adalah pembahagi atau tidak; Melangkah melalui semua pembahagi dan semak n Mod D = 1 atau (n - 1) mod d = 0; Kod pemacu", "code": "import java . util . * ; class GFG { static int countValues ( int N ) { Vector < Integer > div = new Vector < > ( ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . add ( i ) ; if ( N != i * i ) { div . add ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } for ( int d : div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . print ( countValues ( N ) ) ; } }"}
{"text": "Maksimum mungkin pembahagi utama yang boleh wujud dalam nombor yang mempunyai tepat n pembahagi | Pelaksanaan Java untuk mencari pembahagi utama maksimum nombor boleh mempunyai pembahagi N; Berfungsi untuk mencari pembahagi utama maksimum nombor yang boleh dimiliki dengan pembahagi N; Bilangan bilangan masa dibahagikan dengan 2; Membahagikan dengan nombor perdana lain; Jika bilangan terakhir juga perdana maka juga memasukkannya; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void findMaxPrimeDivisor ( int n ) { int max_possible_prime = 0 ; while ( n % 2 == 0 ) { max_possible_prime ++ ; n = n / 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { max_possible_prime ++ ; n = n / i ; } } if ( n > 2 ) { max_possible_prime ++ ; } System . out . print ( max_possible_prime + \"NEW_LINE\"); } public static void main ( String [ ] args ) { int n = 4 ; findMaxPrimeDivisor ( n ) ; } }"}
{"text": "Kira cara untuk menyatakan nombor sebagai jumlah tepat dua nombor | Program Java untuk mengira cara untuk menyatakan nombor sebagai jumlah dua nombor. ; Fungsi Mengembalikan kiraan cara menyatakan nombor sebagai jumlah dua nombor. ; Kod pemacu", "code": "class GFG { static int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; } public static void main ( String [ ] args ) { int N = 8 ; System . out . print ( CountWays ( N ) ) ; } }"}
{"text": "Bahagikan array dalam dua tatasusunan panjang maksimum yang sama dengan unsur -unsur yang serupa dan berbeza | Program Java untuk mencari saiz maksimum yang mana array boleh dibahagikan kepada 2 bahagian yang sama sedemikian rupa sehingga satu bahagian mengandungi unsur -unsur yang unik manakala yang lain mengandungi unsur -unsur yang sama; Berfungsi untuk mencari saiz maksimum yang mana array boleh dibahagikan kepada 2 bahagian yang sama; Array untuk mencari kekerapan setiap elemen array; Cari elemen frekuensi maksimum indeks yang terdapat dalam array arr []; Cari jumlah elemen unik yang terdapat dalam array arr []; Cari saiz maksimum yang mana array arr [] boleh dibuang; Cari array pertama yang mengandungi elemen yang sama; Cari array kedua yang mengandungi unsur -unsur yang unik; Kod pemacu; permulaan n; perisytiharan array; saiz array", "code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static void Solve ( int arr [ ] , int size , int n ) { int [ ] v = new int [ n + 1 ] ; for ( int i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ; int max1 = - 1 , mx = - 1 ; for ( int i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] > mx ) { mx = v [ i ] ; max1 = i ; } } int cnt = 0 ; for ( int i : v ) { if ( i == 0 ) ++ cnt ; } int diff1 = n + 1 - cnt ; int max_size = Math . max ( Math . min ( v [ max1 ] - 1 , diff1 ) , Math . min ( v [ max1 ] , diff1 - 1 ) ) ; System . out . println ( \" Maximum ▁ size ▁ is : ▁ \" + max_size ) ; System . out . println ( \" First ▁ Array ▁ is \" ) ; for ( int i = 0 ; i < max_size ; i ++ ) { System . out . print ( max1 + \" ▁ \" ) ; v [ max1 ] -= 1 ; } System . out . println ( ) ; System . out . println ( \" The ▁ Second ▁ Array ▁ Is ▁ : \" ) ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { System . out . print ( i + \" ▁ \" ) ; max_size -- ; } if ( max_size < 1 ) break ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int n = 7 ; int arr [ ] = new int [ ] { 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 } ; int size = arr . length ; Solve ( arr , size , n ) ; } }"}
{"text": "Cari Jumlah Xor semua tiga kali ganda yang tidak teratur dari array | Program Java untuk mencari jumlah XOR dari semua triplet yang tidak teratur dari array; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y >> 1; y = y / 2; Mengembalikan n ^ ( - 1) mod p; Mengembalikan NCR % P menggunakan teorem kecil Fermat. ; Kes asas; Isi pelbagai faktorial supaya kita dapat mencari semua faktorial r, n dan n - r; Fungsi mengembalikan jumlah XOR dari semua triplet yang tidak teratur dari array; Melangkah ke atas bit; Bilangan elemen yang masing -masing 1 dan 0; Memeriksa jika k 'th bit adalah 1; Menambah bahagian bit ini kepada jawapannya; Kod pemacu", "code": "class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static int modInverse ( int n , int p ) { return power ( n , p - 2 , p ) ; } static int nCrModPFermat ( int n , int r , int p ) { if ( r == 0 ) return 1 ; if ( n < r ) return 0 ; int fac [ ] = new int [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; } static int SumOfXor ( int a [ ] , int n ) { int mod = 10037 ; int answer = 0 ; for ( int k = 0 ; k < 32 ; k ++ ) { int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & ( 1 << k ) ) != 0 ) x ++ ; else y ++ ; } answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod ; } return answer ; } public static void main ( String [ ] args ) { int n = 5 ; int A [ ] = { 3 , 5 , 2 , 18 , 7 } ; System . out . println ( SumOfXor ( A , n ) ) ; } }"}
{"text": "Kebarangkalian tidak mendapat dua kepala berturut -turut bersama -sama di N melemparkan duit syiling | Pelaksanaan Java untuk mencari kebarangkalian tidak mendapat dua kepala berturut -turut bersama apabila duit syiling N dibuang; Fungsi untuk mengira nombor Fibonacci N - Th dalam urutan di mana A = 2 dan B = 3; Dua nombor pertama dalam urutan dimulakan; Kes asas; Gelung untuk mengira urutan Fibonacci berdasarkan dua nombor pertama yang diasaskan; Fungsi untuk mencari kebarangkalian tidak mendapat dua kepala berturut -turut apabila duit syiling N dibuang; Mengira bilangan kes yang menggalakkan; Pengkomputeran bilangan semua hasil yang mungkin untuk N TOSses; Kod pemacu", "code": "class GFG { public static float round ( float var , int digit ) { float value = ( int ) ( var * Math . pow ( 10 , digit ) + .5 ) ; return ( float ) value / ( float ) Math . pow ( 10 , digit ) ; } public static int probability ( int N ) { int a = 2 ; int b = 3 ; if ( N == 1 ) { return a ; } else if ( N == 2 ) { return b ; } else { for ( int i = 3 ; i <= N ; i ++ ) { int c = a + b ; a = b ; b = c ; } return b ; } } public static float operations ( int N ) { int x = probability ( N ) ; int y = ( int ) Math . pow ( 2 , N ) ; return round ( ( float ) x / ( float ) y , 2 ) ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( ( operations ( N ) ) ) ; } }"}
{"text": "Semak jika nombor dibentuk dengan menyertai dua nombor adalah Cube Perfect | Program Java untuk memeriksa sama ada penggabungan dua nombor adalah kiub yang sempurna atau tidak; Berfungsi untuk memeriksa sama ada nombor adalah kiub yang sempurna atau tidak; Fungsi untuk memeriksa sama ada penggabungan dua nombor adalah kiub yang sempurna atau tidak; Menukar nombor ke rentetan menggunakan to_string (); Menggabungkan nombor dan menukarnya menjadi integer; Semak jika nilai yang disatukan adalah kiub sempurna atau tidak; Kod pemacu", "code": "class GFG { static boolean isPerfectCube ( int x ) { long cr = Math . round ( Math . cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; } static void checkCube ( int a , int b ) { String s1 = Integer . toString ( a ) ; String s2 = Integer . toString ( b ) ; int c = Integer . parseInt ( s1 + s2 ) ; if ( isPerfectCube ( c ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } public static void main ( String [ ] args ) { int a = 6 ; int b = 4 ; checkCube ( a , b ) ; } }"}
{"text": "Nombor terbesar dalam array yang dibentuk dengan berulang kali menggabungkan dua elemen yang sama | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mengembalikan jumlah terbesar; Pembolehubah untuk menyimpan jumlah terbesar; Peta untuk menyimpan frekuensi setiap elemen; Menyimpan frekuensi; Gelung untuk menggabungkan elemen pendua dan mengemas kini jumlah dalam peta; Jika J adalah elemen pendua; Kemas kini kekerapan 2 * j; Jika jumlah baru lebih besar daripada nilai maksimum, kemas kini maksimum; Mengembalikan jumlah terbesar; Kod pemacu; Fungsi panggilan", "code": "import java . util . * ; class GFG { static int largest_sum ( int arr [ ] , int n ) { int maximum = - 1 ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( m . get ( arr [ i ] ) > 1 ) { if ( m . containsKey ( 2 * arr [ i ] ) ) { m . put ( 2 * arr [ i ] , m . get ( 2 * arr [ i ] ) + m . get ( arr [ i ] ) / 2 ) ; } else { m . put ( 2 * arr [ i ] , m . get ( arr [ i ] ) / 2 ) ; } if ( 2 * arr [ i ] > maximum ) maximum = 2 * arr [ i ] ; } } return maximum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 4 , 7 , 8 } ; int n = arr . length ; System . out . println ( largest_sum ( arr , n ) ) ; } }"}
{"text": "Semak sama ada mungkin untuk membuat X dan Y Zero pada masa yang sama dengan Operasi yang diberikan | Program Java pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk membuat X dan Y boleh menjadi 0 pada masa yang sama; Semak syarat yang diberikan; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void canBeReduced ( int x , int y ) { int maxi = Math . max ( x , y ) ; int mini = Math . min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) System . out . print ( \" YES \" + \"NEW_LINE\"); else System . out . print ( \" NO \" + \"NEW_LINE\"); } public static void main ( String [ ] args ) { int x = 6 , y = 9 ; canBeReduced ( x , y ) ; } }"}
{"text": "Algoritma Pemfaktoran Roda | Program Java untuk memeriksa sama ada nombor yang diberikan adalah kaedah pemfaktoran roda; Fungsi untuk memeriksa sama ada nombor x yang diberikan adalah perdana atau tidak; Roda untuk memeriksa nombor perdana; Kes asas; Semak nombor yang diambil sebagai asas; Semak roda di sini saya, bertindak sebagai lapisan roda; Semak senarai penapis dalam arr []; Jika nombor lebih besar daripada rehat Sqrt (n); Semak jika n adalah pelbagai nombor utama di roda; Jika di mana -mana lelaran isprime adalah palsu, pecah dari gelung; Kod pemandu; Fungsi panggilan untuk pemeriksaan primal", "code": "import java . util . * ; class GFG { static void isPrime ( int N ) { boolean isPrime = true ; int [ ] arr = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; } for ( int i = 0 ; i < Math . sqrt ( N ) ; i += 30 ) { for ( int c : arr ) { if ( c > Math . sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) System . out . println ( \" Prime ▁ Number \" ) ; else System . out . println ( \" Not ▁ a ▁ Prime ▁ Number \" ) ; } public static void main ( String args [ ] ) { int N = 121 ; isPrime ( N ) ; } }"}
{"text": "Cari semua pasangan yang mungkin dari array yang diberikan | Pelaksanaan Java untuk mencari semua pasangan yang mungkin dari array yang diberikan; Berfungsi untuk mencetak semua pasangan yang mungkin dari array; Gelung bersarang untuk semua pasangan yang mungkin; Kod pemacu", "code": "class GFG { static void printPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( \" ( \" + arr [ i ] + \" , ▁ \" + arr [ j ] + \" ) \" + \" , ▁ \" ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 } ; int n = arr . length ; printPairs ( arr , n ) ; } }"}
{"text": "Paling kurang nombor yang akan ditambah atau dikurangkan dari n untuk menjadikannya kiub yang sempurna | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan nombor paling sedikit; Dapatkan kiub yang sempurna sebelum dan selepas n; Periksa yang paling dekat dengan n; mengembalikan hasilnya; Kod pemacu", "code": "class GFG { static int nearest ( int n ) { int prevCube = ( int ) Math . cbrt ( n ) ; int nextCube = prevCube + 1 ; prevCube = prevCube * prevCube * prevCube ; nextCube = nextCube * nextCube * nextCube ; int ans = ( n - prevCube ) < ( nextCube - n ) ? ( prevCube - n ) : ( nextCube - n ) ; return ans ; } public static void main ( String [ ] args ) { int n = 25 ; System . out . println ( nearest ( n ) ) ; n = 27 ; System . out . println ( nearest ( n ) ) ; n = 40 ; System . out . println ( nearest ( n ) ) ; } }"}
{"text": "Semak jika bulatan terletak di dalam bulatan lain atau tidak | Program Java untuk memeriksa sama ada satu bulatan terletak di dalam bulatan lain atau tidak. ; Kod pemacu", "code": "import java . io . * ; class GFG { static void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( int ) Math . sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ; if ( distSq + r2 == r1 ) { System . out . println ( \" The ▁ smaller ▁ circle ▁ lies ▁ completely \" + \" ▁ inside ▁ the ▁ bigger ▁ circle ▁ with ▁ \" + \" touching ▁ each ▁ other ▁ \" + \" at ▁ a ▁ point ▁ of ▁ circumference . ▁ \" ) ; } else if ( distSq + r2 < r1 ) { System . out . println ( \" The ▁ smaller ▁ circle ▁ lies ▁ completely \" + \" ▁ inside ▁ the ▁ bigger ▁ circle ▁ without \" + \" ▁ touching ▁ each ▁ other ▁ \" + \" at ▁ a ▁ point ▁ of ▁ circumference . \" ) ; } else { System . out . println ( \" The ▁ smaller ▁ does ▁ not ▁ lies ▁ inside \" + \" ▁ the ▁ bigger ▁ circle ▁ completely . \" ) ; } } public static void main ( String [ ] args ) { int x1 = 10 , y1 = 8 ; int x2 = 1 , y2 = 2 ; int r1 = 30 , r2 = 10 ; circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; } }"}
{"text": "Panjang tangen biasa langsung antara dua lingkaran bersilang | Program Java untuk mencari panjang tangen umum langsung antara dua kalangan yang saling berpotongan; Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "class GFG { static void lengtang ( double r1 , double r2 , double d ) { System . out . println ( \" The ▁ length ▁ of ▁ the ▁ direct \" + \" ▁ common ▁ tangent ▁ is ▁ \" + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ) ; } public static void main ( String [ ] args ) { double r1 = 4 , r2 = 6 , d = 3 ; lengtang ( r1 , r2 , d ) ; } }"}
{"text": "Radius bulatan apabila lebar dan ketinggian arka diberikan | Program Java untuk mencari jejari bulatan apabila lebar dan ketinggian arka diberikan; Berfungsi untuk mencari jejari; Kod pemacu", "code": "class GFG { static void rad ( double d , double h ) { System . out . println ( \" The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ \" + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; } public static void main ( String [ ] args ) { double d = 4 , h = 1 ; rad ( d , h ) ; } }"}
{"text": "Jarak terpendek dari pusat bulatan ke kord | Program Java untuk mencari jarak terpendek dari kord ke pusat bulatan; Berfungsi untuk mencari jarak terpendek; Kod pemacu", "code": "class GFG { static void shortdis ( double r , double d ) { System . out . println ( \" The ▁ shortest ▁ distance ▁ \" + \" from ▁ the ▁ chord ▁ to ▁ centre ▁ \" + ( Math . sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) ) ) ; } public static void main ( String [ ] args ) { double r = 4 , d = 3 ; shortdis ( r , d ) ; } }"}
{"text": "Panjang tangen biasa langsung antara kedua -dua bukan | Program Java untuk mencari panjang tangen umum langsung antara dua kalangan yang tidak menyentuh satu sama lain; Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "class GFG { static void lengtang ( double r1 , double r2 , double d ) { System . out . println ( \" The ▁ length ▁ of ▁ the ▁ direct \" + \" ▁ common ▁ tangent ▁ is ▁ \" + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ) ; } public static void main ( String [ ] args ) { double r1 = 4 , r2 = 6 , d = 12 ; lengtang ( r1 , r2 , d ) ; } }"}
{"text": "Dataran terbesar yang boleh ditulis dalam segitiga sama rata | Program Java untuk mencari dataran terbesar yang boleh ditulis dalam segitiga sama rata; Berfungsi untuk mencari sisi dataran; Sisi tidak boleh negatif; sisi dataran; Kod pemacu", "code": "class GFG { static double square ( double a ) { if ( a < 0 ) return - 1 ; double x = 0.464 * a ; return x ; } public static void main ( String [ ] args ) { double a = 5 ; System . out . println ( square ( a ) ) ; } }"}
{"text": "Apothem A N | Program Java untuk mencari apothem poligon biasa dengan panjang sampingan yang diberikan; Berfungsi untuk mencari apothem poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah ditukar kepada radian; Kod pemacu", "code": "import java . util . * ; class GFG { double polyapothem ( double n , double a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * java . lang . Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; } public static void main ( String args [ ] ) { double a = 9 , n = 6 ; GFG g = new GFG ( ) ; System . out . println ( g . polyapothem ( n , a ) ) ; } }"}
{"text": "Kawasan n | Program Java untuk mencari kawasan poligon biasa dengan panjang sampingan yang diberikan; Berfungsi untuk mencari kawasan poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu", "code": "import java . io . * ; class GFG { static float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return - 1 ; float A = ( a * a * n ) / ( float ) ( 4 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; } public static void main ( String [ ] args ) { float a = 9 , n = 6 ; System . out . println ( polyarea ( n , a ) ) ; } }"}
{"text": "Sisi biasa n | Pelaksanaan Java pendekatan; Fungsi untuk mengira sisi poligon yang dilampirkan dalam bulatan; Kod pemacu; Jumlah sisi poligon; Jejari lingkaran lingkungan", "code": "import java . lang . Math ; import java . io . * ; class GFG { static double calculateSide ( double n , double r ) { double theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * Math . sin ( theta_in_radians / 2 ) ; } public static void main ( String [ ] args ) { double n = 3 ; double r = 5 ; System . out . println ( calculateSide ( n , r ) ) ; } }"}
{"text": "Silinder bulat kanan terbesar dalam frustum | Program Java untuk mencari silinder pekeliling kanan terbesar yang boleh sesuai dalam frustum; Berfungsi untuk mencari silinder bulat kanan terbesar; Radii dan ketinggian tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "import java . io . * ; class GFG { static float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; float r1 = r ; float h1 = h ; float V = ( float ) ( 3.14 * Math . pow ( r1 , 2 ) * h1 ) ; return V ; } public static void main ( String [ ] args ) { float r = 7 , R = 11 , h = 6 ; System . out . print ( cyl ( r , R , h ) ) ; } }"}
{"text": "Program untuk mencari perimeter poligon biasa | Program Java untuk mencari perimeter poligon biasa; Berfungsi untuk mengira perimeter; Hitung perimeter; Kaedah pemacu; Dapatkan bilangan sisi; Dapatkan panjang sisi; Cari perimeter", "code": "class GFG { static double Perimeter ( double s , int n ) { double perimeter = 1 ; perimeter = n * s ; return perimeter ; } public static void main ( String [ ] args ) { int n = 5 ; double s = 2.5 , peri ; peri = Perimeter ( s , n ) ; System . out . println ( \" Perimeter ▁ of ▁ Regular ▁ Polygon \" + \" ▁ with ▁ \" + n + \" ▁ sides ▁ of ▁ length ▁ \" + s + \" ▁ = ▁ \" + peri ) ; } }"}
{"text": "Kawasan rombang terbesar yang boleh ditulis dalam segi empat tepat | Program Java untuk mencari rombus terbesar yang boleh ditulis dalam segi empat tepat; Berfungsi untuk mencari kawasan rombus terbesar; Panjang dan keluasan tidak boleh negatif; kawasan rhombus; Kod pemacu", "code": "import java . io . * ; class GFG { static float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; return ( l * b ) / 2 ; } public static void main ( String [ ] args ) { float l = 16 , b = 6 ; System . out . println ( rhombusarea ( l , b ) ) ; } }"}
{"text": "Semak jika titik terletak di dalam segi empat tepat | Set | Program Java untuk memeriksa sama ada titik terletak pada atau di dalam segi empat tepat | Set - 2; Fungsi untuk mencari jika titik diberikan terletak di dalam segi empat tepat atau tidak. ; Kod pemacu; bawah - kiri dan atas - sudut kanan segi empat tepat; titik yang diberikan; panggilan fungsi", "code": "class GFG { static boolean FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; } public static void main ( String [ ] args ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x = 1 , y = 5 ; if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Jarak antara satu titik dan satah dalam 3 D | Program Java untuk mencari jarak serenjang (terpendek) antara satu titik dan satah dalam 3 d. ; Berfungsi untuk mencari jarak; Kod pemacu; Panggilan fungsi", "code": "import java . io . * ; class GFG { static void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = Math . abs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = ( float ) Math . sqrt ( a * a + b * b + c * c ) ; System . out . println ( \" Perpendicular ▁ distance ▁ \" + \" is ▁ \" + d / e ) ; } public static void main ( String [ ] args ) { float x1 = 4 ; float y1 = - 4 ; float z1 = 3 ; float a = 2 ; float b = - 2 ; float c = 5 ; float d = 8 ; shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ; } }"}
{"text": "Program untuk mencari jumlah prisma segi tiga | Program Java untuk mencari jumlah prisma segitiga; berfungsi untuk mencari jumlah prisma segi tiga; formula untuk mencari kelantangan; Kod pemacu; fungsi panggilan", "code": "import java . io . * ; class GFG { static float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; } public static void main ( String [ ] args ) { float l = 18 , b = 12 , h = 9 ; System . out . println ( \" Volume ▁ of ▁ triangular ▁ prism : ▁ \" + findVolume ( l , b , h ) ) ; } }"}
{"text": "Semak jika diberi empat bilangan bulat (atau sisi) membuat segi empat tepat | Program mudah untuk mencari jika diberikan 4 nilai boleh mewakili 4 sisi segi empat tepat; Fungsi untuk memeriksa sama ada nilai integer yang diberikan membuat segi empat tepat; Square juga merupakan segi empat tepat; Kod pemacu", "code": "class GFG { static boolean isRectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Program untuk mencari pertengahan | Program Java untuk mencari titik tengah garis; berfungsi untuk mencari titik tengah garis; Kod pemacu", "code": "import java . io . * ; class GFG { static void midpoint ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 + \" ▁ , ▁ \" + ( y1 + y2 ) / 2 ) ; } public static void main ( String [ ] args ) { int x1 = - 1 , y1 = 2 ; int x2 = 3 , y2 = - 6 ; midpoint ( x1 , x2 , y1 , y2 ) ; } }"}
{"text": "Panjang arka dari sudut yang diberikan | Program Java untuk mengira panjang arka; fungsi untuk mengira panjang arka; Kod pemacu", "code": "public class Arc { static double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { System . out . println ( \" Angle ▁ cannot \" + \" ▁ be ▁ formed \" ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } } public static void main ( String args [ ] ) { double diameter = 25.0 ; double angle = 45.0 ; double arc_len = arcLength ( diameter , angle ) ; System . out . println ( arc_len ) ; } }"}
{"text": "Semak sama ada garis menyentuh atau memotong bulatan | Program Java untuk memeriksa sama ada garis menyentuh atau bersilang atau di luar bulatan. ; Mencari jarak garis dari pusat. ; Memeriksa jika jarak kurang daripada, lebih besar daripada atau sama dengan radius. ; Program yang didorong", "code": "import java . io . * ; class GFG { static void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) System . out . println ( \" Touch \" ) ; else if ( radius > dist ) System . out . println ( \" Intersect \" ) ; else System . out . println ( \" Outside \" ) ; } public static void main ( String [ ] args ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ; } }"}
{"text": "Program untuk mencari kawasan segitiga | Program Java untuk menilai kawasan formula Polygon Usingshoelace; (X [i], y [i]) adalah koordinat titik saya. ; Memulakan kawasan; Hitung nilai formula kasut; J adalah puncak sebelumnya kepada i; Kembali nilai mutlak; Program Pemandu", "code": "import java . io . * ; import java . math . * ; class GFG { static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; } public static void main ( String [ ] args ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = X . length ; System . out . println ( polygonArea ( X , Y , n ) ) ; } }"}
{"text": "Memaksimumkan jumlah LSB bitwise atau semua mungkin n / 2 pasang dari array yang diberikan | Program Java untuk pendekatan di atas; Fungsi atas mendapatkan nilai LSB V; Penukaran binari; Fungsi untuk mencari jumlah LSB semua pasangan yang mungkin dari array yang diberikan; Menyimpan elemen array LSB; Menyimpan nilai LSB; Susun array lab_arr []; Mengambil jumlah pasangan untuk mendapatkan jumlah maksimum LSB; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int chk ( int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; while ( n != 0 ) { v . add ( n % 2 ) ; n = n / 2 ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . get ( i ) == 1 ) { return ( int ) Math . pow ( 2 , i ) ; } } return 0 ; } static void sumOfLSB ( int arr [ ] , int N ) { Vector < Integer > lsb_arr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { lsb_arr . add ( chk ( arr [ i ] ) ) ; } Collections . sort ( lsb_arr ) ; int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i += 2 ) { ans += ( lsb_arr . get ( i + 1 ) ) ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; sumOfLSB ( arr , N ) ; } }"}
{"text": "Kira -kira berikutnya yang mempunyai bitwise dan nilai -nilai yang ganjil dalam array yang diberikan | Program Java untuk pendekatan di atas; Fungsi untuk mencari kiraan berikutnya yang mempunyai bitwise dan nilai ganjil; Kedai mengira unsur -unsur ganjil; Melintasi array arr []; Jika x adalah kiraan kenaikan ganjil; Jawapan kembali; Kod pemacu; Panggilan fungsi", "code": "import java . io . * ; class GFG { static int countSubsequences ( int arr [ ] , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) % 2 == 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; } public static void main ( String [ ] args ) { int N = 3 ; int arr [ ] = { 1 , 3 , 3 } ; System . out . println ( countSubsequences ( arr , N ) ) ; } }"}
{"text": "Kira pasangan dari array dengan perbezaan mutlak tidak kurang daripada elemen minimum dalam pasangan | Program Java untuk pendekatan di atas; Fungsi untuk mencari bilangan pasangan (i, j) seperti abs (a [i] - a [j]) sekurang -kurangnya minimum (a [i], a [j]); Menyimpan kiraan pasangan yang dihasilkan; Melangkah ke atas julat [0, n]; Berulang dari arr [i] - (i % arr [i]) hingga n dengan kenaikan arr [i]; Mengira pasangan yang mungkin; Mengembalikan jumlah jumlah; Kod pemacu", "code": "import java . io . * ; class GFG { static int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && Math . abs ( arr [ i ] - arr [ j ] ) >= Math . min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int N = arr . length ; System . out . println ( getPairsCount ( arr , N ) ) ; } }"}
{"text": "Langkah Minimum Untuk Menukar N hingga 1 dengan menukarnya menjadi 2 * n atau n / 10 pada mana -mana langkah | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada n boleh diubah menjadi 1 atau tidak. ; Kira bilangan 2 dalam faktorisasi utama N; Mengira bilangan 5 dalam faktorisasi utama N; Kod pemacu", "code": "import java . io . * ; class GFG { static void check ( int N ) { int twos = 0 , fives = 0 ; while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; } while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { System . out . println ( 2 * fives - twos ) ; } else { System . out . println ( - 1 ) ; } } public static void main ( String [ ] args ) { int N = 50 ; check ( N ) ; } }"}
{"text": "Jumlah elemen dalam julat yang diberikan dari array yang dibentuk oleh array yang diberikan secara tidak terhingga | Program Java untuk pendekatan di atas; Berfungsi untuk mencari jumlah elemen dalam pelbagai array tak terhingga; Menyimpan jumlah elemen array dari L ke R; Melintasi L ke R; Cetak jumlah yang dihasilkan; Kod pemacu", "code": "import java . io . * ; class GFG { static void rangeSum ( int arr [ ] , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } System . out . println ( sum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = arr . length ; rangeSum ( arr , N , L , R ) ; } }"}
{"text": "Jumlah elemen dalam julat yang diberikan dari array yang dibentuk oleh array yang diberikan secara tidak terhingga | Program Java untuk pendekatan di atas; Berfungsi untuk mencari jumlah elemen dalam pelbagai array tak terhingga; Menyimpan jumlah awalan; Kirakan jumlah awalan; Menyimpan jumlah elemen dari 1 hingga l - 1; Menyimpan jumlah elemen dari 1 hingga R; Cetak jumlah yang dihasilkan; Kod pemacu", "code": "import java . io . * ; class GFG { static void rangeSum ( int arr [ ] , int N , int L , int R ) { int prefix [ ] = new int [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; System . out . print ( rightsum - leftsum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = arr . length ; rangeSum ( arr , N , L , R ) ; } }"}
{"text": "Faktorial eksponen n | Program Java untuk pendekatan di atas; Berfungsi untuk mencari faktorial eksponen nombor tertentu; Menyimpan faktor exponetial N; Iterare ke atas julat [2, n]; Kemas kini res; Kembali res; Kod pemacu; Input; Panggilan fungsi", "code": "class GFG { static int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) Math . pow ( i , res ) % mod ; return res ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( ( ExpoFactorial ( N ) ) ) ; } }"}
{"text": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | Set | Program Java untuk pendekatan di atas; Fungsi untuk mencari subarray bersebelahan dengan jumlah maksimum jika array diulang kali k; Simpan jumlah array arr []; Melintasi array dan cari jumlah; Simpan jawapannya; Jika k = 1; Memohon algoritma Kadane untuk mencari jumlah; Kembalikan jawapannya; Menyimpan array dua kali berulang; Melintasi julat [0, 2 * n]; Menyimpan jumlah akhiran maksimum; Menyimpan jumlah awalan maksimum; Memohon algoritma Kadane untuk 2 pengulangan array; Jika jumlah array lebih besar daripada 0; Kembalikan jawapannya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int maxSubArraySumRepeated ( int [ ] arr , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int curr = arr [ 0 ] ; int ans = arr [ 0 ] ; if ( K == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { curr = Math . max ( arr [ i ] , curr + arr [ i ] ) ; ans = Math . max ( ans , curr ) ; } return ans ; } ArrayList < Integer > V = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { V . add ( arr [ i % N ] ) ; } int maxSuf = V . get ( 0 ) ; int maxPref = V . get ( 2 * N - 1 ) ; curr = V . get ( 0 ) ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr += V . get ( i ) ; maxPref = Math . max ( maxPref , curr ) ; } curr = V . get ( 2 * N - 1 ) ; for ( int i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V . get ( i ) ; maxSuf = Math . max ( maxSuf , curr ) ; } curr = V . get ( 0 ) ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr = Math . max ( V . get ( i ) , curr + V . get ( i ) ) ; ans = Math . max ( ans , curr ) ; } if ( sum > 0 ) { int temp = sum * ( K - 2 ) ; ans = Math . max ( ans , Math . max ( temp + maxPref , temp + maxSuf ) ) ; } return ans ; } public static void main ( String args [ ] ) { int [ ] arr = { 10 , 20 , - 30 , - 1 , 40 } ; int N = arr . length ; int K = 10 ; System . out . print ( maxSubArraySumRepeated ( arr , N , K ) ) ; } }"}
{"text": "Count of Subarrays Dengan Elemen Terbesar Sekurang -kurangnya dua kali ganda unsur -unsur terbesar | Program Java untuk pendekatan di atas; Fungsi untuk mencari kiraan subarray yang mempunyai elemen maksimum lebih besar daripada dua kali maksimum semua elemen lain; Menyimpan kiraan subarray; Menjana semua subarray yang mungkin; Menyimpan elemen maksimum subarray; Menyimpan maksimum semua elemen lain; Cari elemen maksimum dalam subarray [i, j]; Cari maksimum semua elemen lain; Jika maksimum subarray lebih besar daripada dua kali ganda maksimum elemen lain; Cetak nilai maksimum yang diperoleh; Kod pemacu", "code": "import java . io . * ; class GFG { public static void countSubarray ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int mxSubarray = 0 ; int mxOther = 0 ; for ( int k = i ; k <= j ; k ++ ) { mxSubarray = Math . max ( mxSubarray , arr [ k ] ) ; } for ( int k = 0 ; k < i ; k ++ ) { mxOther = Math . max ( mxOther , arr [ k ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { mxOther = Math . max ( mxOther , arr [ k ] ) ; } if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = arr . length ; countSubarray ( arr , N ) ; } }"}
{"text": "Count of Subarrays Dengan Elemen Terbesar Sekurang -kurangnya dua kali ganda unsur -unsur terbesar | Program Java untuk pendekatan di atas; Fungsi untuk mencari kiraan subarray yang mempunyai elemen maksimum lebih besar daripada dua kali maksimum semua elemen lain; Menyimpan elemen maksimum array; Melintasi array yang diberikan; Jika nilai 2 * arr [i] lebih besar daripada MX; Kemas kini nilai l dan keluar dari gelung; Jika nilai 2 * arr [i] lebih besar daripada Mx; Mengemas kini nilai r dan keluar dari gelung; Cetak jawapan terakhir; Kod pemacu", "code": "import java . util . * ; class GFG { static void countSubarray ( int [ ] arr , int n ) { int L = 0 , R = 0 ; int mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . max ( mx , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * 2 > mx ) { L = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] * 2 > mx ) { R = i ; break ; } } System . out . println ( ( L + 1 ) * ( n - R ) ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = arr . length ; countSubarray ( arr , N ) ; } }"}
{"text": "Cari Nombor Perdana hanya kurang daripada dan hanya lebih besar setiap elemen array yang diberikan | Program Java untuk pendekatan di atas; Fungsi utiliti untuk memeriksa keunggulan nombor X dengan memeriksa sama ada X mempunyai faktor selain daripada 1 dan sendiri. ; Faktor yang dijumpai; Berfungsi untuk mencetak prima hanya kurang daripada dan hanya lebih besar daripada setiap elemen dalam array; Melintasi array; Traverse untuk mencari perdana kurang daripada [i]; Perdana hanya kurang daripada yang dijumpai; Melintasi untuk mencari perdana lebih besar daripada [i]; Perdana hanya lebih besar daripada yang dijumpai; Kod pemacu; Input; Panggilan fungsi", "code": "import java . io . * ; class GFG { static boolean isPrime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ ) if ( X % i == 0 ) return false ; return true ; } static void printPrimes ( int A [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = A [ i ] - 1 ; ; j -- ) { if ( isPrime ( j ) ) { System . out . print ( j + \" ▁ \" ) ; break ; } } for ( int j = A [ i ] + 1 ; ; j ++ ) { if ( isPrime ( j ) ) { System . out . print ( j + \" ▁ \" ) ; break ; } } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int A [ ] = { 17 , 28 } ; int N = A . length ; printPrimes ( A , N ) ; } }"}
{"text": "Elemen terkecil kth dalam array yang mengandungi [i] betul -betul b [i] kali | Program Java untuk pendekatan di atas; Fungsi untuk mencari elemen terkecil kth yang mengandungi [i] tepat b [i] kali; Melintasi array yang diberikan; Menyimpan kekerapan setiap elemen; Melintasi array yang diberikan; Memulakan pembolehubah untuk menyimpan jumlah awalan; Melangkah ke atas julat [0, M]; Jumlah kenaikan oleh freq [i]; Jika jumlah lebih besar daripada atau sama dengan k; Mengembalikan elemen semasa sebagai jawapan; Kembali - 1; Kod pemacu; {Diberikan input; Panggilan fungsi", "code": "public class GFG_JAVA { static int KthSmallest ( int A [ ] , int B [ ] , int N , int K ) { int M = 0 ; for ( int i = 0 ; i < N ; i ++ ) { M = Math . max ( A [ i ] , M ) ; } int freq [ ] = new int [ M + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; } int sum = 0 ; for ( int i = 0 ; i <= M ; i ++ ) { sum += freq [ i ] ; if ( sum >= K ) { return i ; } } return - 1 ; } public static void main ( String [ ] args ) int A [ ] = { 3 , 4 , 5 } ; int B [ ] = { 2 , 1 , 3 } ; int N = A . length ; int K = 4 ; System . out . println ( KthSmallest ( A , B , N , K ) ) ; } }"}
{"text": "Bitwise atau bitwise dan semua subarrays array | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bitwise atau bitwise dan semua subarrays; Menyimpan hasil yang diperlukan; Menjana semua subarray; Simpan elemen semasa; Cari bitwise atau; Mengemas kini hasilnya; Cetak hasilnya; Kod pemacu", "code": "public class GFG { static void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } System . out . println ( res ) ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 } ; int N = A . length ; findbitwiseOR ( A , N ) ; } }"}
{"text": "Bitwise atau bitwise dan semua subarrays array | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bitwise atau bitwise dan semua subset berturut -turut dari array; Menyimpan hasil yang diperlukan; Melintasi array yang diberikan; Cetak hasilnya; Kod pemacu", "code": "import java . io . * ; class GFG { static void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; System . out . println ( res ) ; } public static void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 } ; int N = A . length ; findbitwiseOR ( A , N ) ; } }"}
{"text": "Semak jika jumlah digit nombor melebihi produk digit nombor itu | Program Java untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada jumlah digit N adalah lebih besar daripada produk digit N atau tidak; Menyimpan jumlah dan produk digit N; Menyimpan digit terakhir jika n; Kenaikan nilai sumofdigit; Mengemas kini prodofdigit; Bahagikan n oleh 10; Cetak hasilnya; Kod pemacu", "code": "class GFG { static void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } public static void main ( String [ ] args ) { int N = 1234 ; check ( N ) ; } }"}
{"text": "Cetak semua awalan yang berbeza dan ganjil bitwise xors pertama n Nombor semula jadi | Pendekatan Java untuk pendekatan di atas; Cetak semua awalan yang berbeza & ganjil bitwise xors dari 1 hingga n; Cetak nombor juga; Cetak nombor ganjil; Kod pemacu", "code": "class GFG { static void evenOddBitwiseXOR ( int N ) { System . out . print ( \" Even : ▁ \" + 0 + \" ▁ \" ) ; for ( int i = 4 ; i <= N ; i = i + 4 ) { System . out . print ( i + \" ▁ \" ) ; } System . out . print ( \"NEW_LINE\"); System . out . print ( \" Odd : ▁ \" + 1 + \" ▁ \" ) ; for ( int i = 4 ; i <= N ; i = i + 4 ) { System . out . print ( i - 1 + \" ▁ \" ) ; } if ( N % 4 == 2 ) System . out . print ( N + 1 ) ; else if ( N % 4 == 3 ) System . out . print ( N ) ; } public static void main ( String [ ] args ) { int N = 6 ; evenOddBitwiseXOR ( N ) ; } }"}
{"text": "Permutasi terbesar lexicographically mungkin dengan swap yang lebih kecil daripada array yang diberikan | Program Java untuk pendekatan di atas; Berfungsi untuk permutasi terbesar lexicographic mungkin dengan swap yang lebih kecil daripada array yang diberikan; Cari indeks elemen pertama sedemikian rupa sehingga arr [i]> arr [i + 1]; Jika array disusun dalam peningkatan urutan; Cari indeks elemen pertama yang lebih kecil daripada arr [i]; Jika arr [j] = = arr [j - 1]; Pengurangan j; Swap elemen; Cetak array arr []; Kod pemacu", "code": "import java . util . * ; class GFG { static void findPermutation ( int [ ] arr ) { int N = arr . length ; int i = N - 2 ; while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ; if ( i == - 1 ) { System . out . print ( \" - 1\" ) ; return ; } int j = N - 1 ; while ( j > i && arr [ j ] >= arr [ i ] ) j -- ; while ( j > i && arr [ j ] == arr [ j - 1 ] ) { j -- ; } int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; for ( int it : arr ) { System . out . print ( it + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 5 , 3 , 4 , 6 } ; findPermutation ( arr ) ; } }"}
{"text": "Perbezaan mutlak antara kiraan ganjil dan juga faktor n | Program Java untuk pendekatan di atas; Berfungsi untuk mencari faktor utama terkecil dari semua nombor menggunakan ayak eratosthenes; Kedai sama ada nombor mana -mana atau tidak; Memulakan faktor terkecil sebagai 2 untuk semua nombor walaupun; Melangkah ke atas julat [3, n]; Sekiranya saya adalah perdana; Melepasi semua gandaan i; Saya adalah faktor utama terkecil i * j; Fungsi untuk mencari perbezaan mutlak antara kiraan ganjil dan juga faktor n; Menyimpan faktor utama terkecil i; Isi nilai dalam S [] menggunakan ayak eratosthenes; Menyimpan jumlah faktor dan jumlah faktor ganjil dan bahkan; Simpan faktor utama semasa nombor n; Simpan kuasa faktor utama semasa; Gelung manakala n lebih besar daripada 1; Jika n juga mempunyai faktor utama terkecil seperti Curr, maka kenaikan CNT oleh 1; Kemas kini hanya jumlah faktor jika curr adalah 2; Mengemas kini jumlah faktor dan jumlah faktor ganjil; Mengemas kini faktor utama semasa S [n] dan dikira sebagai 1; Kirakan bilangan faktor walaupun; Cetak perbezaan; Kod pemacu", "code": "import java . util . * ; class GFG { static void sieveOfEratosthenes ( int N , int s [ ] ) { boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( ! prime [ i * j ] ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } static void findDifference ( int N ) { int [ ] s = new int [ N + 1 ] ; sieveOfEratosthenes ( N , s ) ; int total = 1 , odd = 1 , even = 0 ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } if ( curr == 2 ) { total = total * ( cnt + 1 ) ; } else { total = total * ( cnt + 1 ) ; odd = odd * ( cnt + 1 ) ; } curr = s [ N ] ; cnt = 1 ; } even = total - odd ; System . out . print ( Math . abs ( even - odd ) ) ; } public static void main ( String [ ] args ) { int N = 12 ; findDifference ( N ) ; } }"}
{"text": "Kirakan median dari nilai min dan mod yang diberikan | Program Java untuk pendekatan di atas; Berfungsi untuk mencari median sekumpulan data dengan min dan mod yang diberikan; Kirakan median; Cetak median; Kod pemacu", "code": "import java . util . * ; class GFG { static void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; System . out . print ( ( int ) Median ) ; } public static void main ( String [ ] args ) { int mode = 6 , mean = 3 ; findMedian ( mean , mode ) ; } }"}
{"text": "Program untuk mencari magnitud vektor | Program Java untuk pendekatan di atas; Berfungsi untuk mengira magnitud vektor 3 dimensi; Menyimpan jumlah kuadrat koordinat vektor; Mengembalikan magnitud; Kod pemacu", "code": "class GFG { private static double vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return Math . sqrt ( sum ) ; } public static void main ( String [ ] args ) { int x = 1 ; int y = 2 ; int z = 3 ; System . out . print ( vectorMagnitude ( x , y , z ) ) ; } }"}
{"text": "Program untuk mencari produk nombor dengan nombor Mersenne | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari prodcut nombor Mersenne dengan nombor lain; Menyimpan kuasa 2 integer m + 1; Mengembalikan produk; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static long multiplyByMersenne ( long N , long M ) { long x = ( int ) ( Math . log ( M + 1 ) / Math . log ( 2 ) ) ; return ( ( N << x ) - N ) ; } public static void main ( String [ ] args ) { long N = 4 ; long M = 15 ; System . out . print ( multiplyByMersenne ( N , M ) ) ; } }"}
{"text": "Kuasa terdekat 2 dari dataran sempurna terdekat bukan | Program Java untuk pendekatan di atas; Berfungsi untuk mencari persegi yang paling dekat dengan Num; Kirakan akar kuadrat NUM; Kirakan persegi sempurna; Cari dataran sempurna terdekat; Berfungsi untuk mencari kuasa 2 yang paling dekat dengan nombor nombor; Hitung asas log 2 dari NUM; Kuasa tertinggi 2 iaitu <= num; Berfungsi untuk mencari persegi sempurna yang terdekat dan kuasa terdekat 2 dari setiap elemen array yang kejadiannya adalah 1; Kedai kekerapan elemen array; Melintasi array dan kemas kini kekerapan elemen array semasa; Melintasi peta freq; Jika kekerapan adalah 1; Cari persegi sempurna yang terdekat; Cetak kuasa terdekat 2; Sekiranya mana -mana tidak mengandungi unsur -unsur yang tidak berulang; Kod pemacu", "code": "import java . util . * ; class GFG { static int perfectSquare ( int num ) { int sr = ( int ) ( Math . sqrt ( num ) ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( num - a ) < ( b - num ) ) { return a ; } else { return b ; } } static int powerOfTwo ( int num ) { int lg = ( int ) ( Math . log ( num ) / Math . log ( 2 ) ) ; int p = ( int ) ( Math . pow ( 2 , lg ) ) ; return p ; } static void uniqueElement ( int arr [ ] , int N ) { boolean ans = true ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } } for ( Map . Entry < Integer , Integer > el : freq . entrySet ( ) ) { if ( el . getValue ( ) == 1 ) { ans = false ; int ps = perfectSquare ( el . getKey ( ) ) ; System . out . print ( powerOfTwo ( ps ) + \" ▁ \" ) ; } } if ( ans ) System . out . print ( \" - 1\" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 11 , 4 , 3 , 4 } ; int N = arr . length ; uniqueElement ( arr , N ) ; } }"}
{"text": "Arahan partition menjadi dua subarray dengan setiap elemen di subarray kanan dengan ketat daripada setiap elemen di subarray kiri | Program Java pendekatan di atas; Berfungsi untuk memisahkan array menjadi dua subarrays bukan kosong yang memenuhi syarat yang diberikan; Menyimpan array akhiran min; Menyimpan minimum akhiran; Melintasi array secara terbalik; Mengemas kini minimum; Simpan minimum; Menyimpan nilai maksimum awalan; Menyimpan indeks partition; Kemas kini Max; Jika max kurang daripada min [i + 1]; Simpan indeks partition; rehat; Jika Ind tidak - 1; Cetak subarray pertama; Cetak subarray kedua; Jika tidak; Kod pemacu", "code": "import java . util . * ; class GFG { static void partitionArray ( int a [ ] , int n ) { int min [ ] = new int [ n ] ; int mini = Integer . MAX_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { mini = Math . min ( mini , a [ i ] ) ; min [ i ] = mini ; } int maxi = Integer . MIN_VALUE ; int ind = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { maxi = Math . max ( maxi , a [ i ] ) ; if ( maxi < min [ i + 1 ] ) { ind = i ; break ; } } if ( ind != - 1 ) { for ( int i = 0 ; i <= ind ; i ++ ) System . out . print ( a [ i ] + \" ▁ \" ) ; System . out . println ( ) ; for ( int i = ind + 1 ; i < n ; i ++ ) System . out . print ( a [ i ] + \" ▁ \" ) ; } else System . out . println ( \" Impossible \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 2 , 7 , 9 } ; int N = arr . length ; partitionArray ( arr , N ) ; } }"}
{"text": "Semak sama ada nombor boleh diwakili sebagai jumlah integer positif k di mana sekurang -kurangnya k | Program Java untuk pendekatan di atas; Berfungsi untuk mengira semua faktor utama nombor tertentu; Kira bilangan 2 s yang membahagikan n; Oleh kerana N adalah ganjil pada ketika ini, langkau satu elemen; Walaupun saya membahagikan n, kiraan saya dan membahagikan n; Jika n adalah nombor perdana yang lebih besar daripada 2; Berfungsi untuk mencari jumlah nombor pertama N hampir utama; Simpan jumlah yang diperlukan; Tambah nombor ini jika ia memenuhi syarat; Kiraan kenaikan hampir nombor utama; Fungsi untuk memeriksa sama ada n boleh diwakili sebagai jumlah k antara bilangan bulat positif yang berbeza di mana sekurang -kurangnya k - 1 daripadanya adalah hampir perdana; Simpan jumlah pertama k - 1 hampir nombor utama; Jika jumlah lebih besar daripada atau sama dengan n; Jika tidak, cetak ya; Kod pemacu", "code": "import java . util . * ; class GFG { static int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= ( int ) Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == 2 ) { sum += num ; i ++ ; } } return sum ; } static void check ( int n , int k ) { int s = findSum ( k - 1 ) ; if ( s >= n ) System . out . print ( \" No \" ) ; else System . out . print ( \" Yes \" ) ; } public static void main ( String [ ] args ) { int n = 100 , k = 6 ; check ( n , k ) ; } }"}
{"text": "Kira cara untuk mewakili integer sebagai eksponen | Program Java untuk pendekatan di atas; Berfungsi untuk mengira GCD A dan B menggunakan algoritma Euclidean; Iterat sehingga B bukan sifar; Mengembalikan GCD; Fungsi untuk mengira bilangan cara n boleh dinyatakan sebagai x ^ y; Kes asas; Menyimpan GCD kuasa; Kirakan tahap 2 dalam n; Kirakan tahap nombor utama dalam n; Kirakan tahap perdana 'i' dalam n; Jika n adalah perdana, G menjadi 1 .; Menyimpan bilangan cara untuk mewakili n sebagai x ^ y; Cari bilangan faktor G; Mengemas kini kiraan cara; Berulang untuk mencari bilangan nombor perdana; Cari kuasa i; Mengemas kini kiraan cara; Jika G adalah Perdana; Mengembalikan jumlah cara; Kod pemacu", "code": "import java . util . * ; class GFG { static int gcd ( int a , int b ) { while ( b > 0 ) { int rem = a % b ; a = b ; b = rem ; } return a ; } static int countNumberOfWays ( int n ) { if ( n == 1 ) return - 1 ; int g = 0 ; int power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( int i = 3 ; i <= ( int ) Math . sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; int ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( int i = 3 ; i <= ( int ) Math . sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; } public static void main ( String [ ] args ) { int N = 64 ; System . out . print ( countNumberOfWays ( N ) ) ; } }"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan integer yang diberikan | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mengembalikan kuasa terendah 2 dekat dengan nombor positif yang diberikan; Fungsi lantai digunakan untuk menentukan nilai yang dekat dengan nombor; Berfungsi untuk mengembalikan kuasa terendah 2 dekat dengan nombor negatif yang diberikan; Fungsi Ceil digunakan untuk nombor negatif sebagai - 1> - 4. Ia akan bertentangan dengan nombor positif di mana 1 <4; Berfungsi untuk mencari kuasa tertinggi 2; Untuk memeriksa sama ada nombor yang diberikan positif atau negatif; Jika nombor itu negatif, maka siling nombor positif dikira dan tanda negatif ditambah; Kod pemacu", "code": "class GFG { static int powOfPositive ( int n ) { int pos = ( int ) Math . floor ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ; return ( int ) Math . pow ( 2 , pos ) ; } static int powOfNegative ( int n ) { int pos = ( int ) Math . ceil ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ; return ( int ) ( - 1 * Math . pow ( 2 , pos ) ) ; } static void highestPowerOf2 ( int n ) { if ( n > 0 ) { System . out . println ( powOfPositive ( n ) ) ; } else { n = - n ; System . out . println ( powOfNegative ( n ) ) ; } } public static void main ( String [ ] args ) { int n = - 24 ; highestPowerOf2 ( n ) ; } }"}
{"text": "Bilangan kad yang diperlukan membina rumah kad tahap n | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mencari bilangan kad yang diperlukan; Kod pemacu", "code": "import java . lang . * ; class GFG { public static int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . print ( noOfCards ( n ) ) ; } }"}
{"text": "Cari nombor terkecil dari sejumlah besar yang diberikan dengan kiraan digit yang sama | Pelaksanaan Java pendekatan di atas; Fungsi untuk mencari nombor yang paling kecil selepas menukar digit beberapa kali; Pembolehubah untuk menyimpan jawapan terakhir; Array untuk menyimpan kiraan kejadian setiap digit; Gelung untuk mengira bilangan kejadian setiap digit; Gelung untuk mendapatkan nombor terkecil; Mengembalikan jawapannya; Kod pemacu", "code": "class GFG { static String smallestPoss ( String s , int n ) { String ans = \" \" ; int arr [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s . charAt ( i ) - 48 ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + String . valueOf ( i ) ; } return ans ; } public static void main ( String [ ] args ) { int N = 15 ; String K = \"325343273113434\" ; System . out . print ( smallestPoss ( K , N ) ) ; } }"}
{"text": "Kira subarray dengan jumlah yang lebih besar daripada jumlah elemen yang tinggal | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mengira bilangan sub -tatasusunan dengan jumlah yang lebih besar daripada unsur -unsur array yang tinggal; Untuk gelung untuk titik permulaan subarray; Untuk gelung untuk titik akhir subarray; Permulaan subarray_sum dan sisa_sum ke 0; Untuk gelung untuk mengira jumlah subarray yang dihasilkan; Untuk gelung untuk mengira unsur array sisa jumlah; Memeriksa keadaan apabila jumlah Subarray adalah lebih besar daripada jumlah unsur array yang tinggal; Kod pemacu", "code": "import java . util . * ; class GFG { static int Count_subarray ( int arr [ ] , int n ) { int subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = arr . length ; System . out . print ( Count_subarray ( arr , n ) ) ; } }"}
{"text": "Kira subarray dengan jumlah yang lebih besar daripada jumlah elemen yang tinggal | Pelaksanaan Java pendekatan di atas; Mengira jumlah jumlah array yang diberikan; Untuk gelung untuk titik permulaan subarray; permulaan subarray_sum hingga 0; Untuk gelung untuk mengira subarray_sum dan sisa_sum; Mengira subarray_sum dan sisa yang sama; Memeriksa keadaan apabila jumlah Subarray adalah lebih besar daripada jumlah baki elemen array; Kod pemacu", "code": "class GFG { static int Count_subarray ( int arr [ ] , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = arr . length ; System . out . print ( Count_subarray ( arr , n ) ) ; } }"}
{"text": "Keluarkan satu elemen untuk mendapatkan XOR maksimum | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan XOR yang dimaksimumkan selepas mengeluarkan elemen dari array; Cari xor array lengkap; Untuk menyimpan jawapan terakhir; Melangkah melalui array untuk mencari jawapan terakhir; Kembalikan jawapan terakhir; Kod pemacu", "code": "class GFG { static int maxXOR ( int arr [ ] , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 3 } ; int n = arr . length ; System . out . println ( maxXOR ( arr , n ) ) ; } }"}
{"text": "Kira nombor dari julat [l, r] yang mengandungi sekurang -kurangnya satu digit yang membahagikan k | Pelaksanaan Java pendekatan; Fungsi yang mengembalikan benar jika NUM mengandungi sekurang -kurangnya satu digit yang membahagikan k; Dapatkan digit terakhir; Jika digit bukan sifar dan ia membahagikan k; Keluarkan digit terakhir; Tiada digit dalam num yang membahagikan k; Fungsi untuk mengembalikan kiraan unsur -unsur yang diperlukan dari julat yang diberikan yang mengandungi sekurang -kurangnya satu digit yang membahagikan k; Untuk menyimpan hasilnya; Untuk setiap nombor dari julat; Jika mana -mana digit nombor semasa membahagikan k; Kod pemacu", "code": "class GFG { static boolean digitDividesK ( int num , int k ) { while ( num != 0 ) { int d = num % 10 ; if ( d != 0 && k % d == 0 ) return true ; num = num / 10 ; } return false ; } static int findCount ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( digitDividesK ( i , k ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int l = 20 , r = 35 ; int k = 45 ; System . out . println ( findCount ( l , r , k ) ) ; } }"}
{"text": "Semak jika nombor tertentu adalah faktorial mana -mana nombor | Pelaksanaan Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor yang diberikan adalah faktorial bagi mana -mana nombor; Kod pemacu", "code": "class GFG { static boolean isFactorial ( int n ) { for ( int i = 1 ; ; i ++ ) { if ( n % i == 0 ) { n /= i ; } else { break ; } } if ( n == 1 ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { int n = 24 ; boolean ans = isFactorial ( n ) ; if ( ans == true ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } }"}
{"text": "Keluarkan elemen untuk meminimumkan LCM array yang diberikan | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mengembalikan LCM dua nombor; Berfungsi untuk mengembalikan LCM minimum selepas mengeluarkan satu elemen dari array yang diberikan; Awalan dan akhiran tatasusunan; Hubungan pengaturcaraan dinamik negara tunggal untuk menyimpan LCM unsur -unsur pertama saya dari kiri dalam awalan [i]; Memulakan array akhiran; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan LCM dari semua elemen yang mempunyai indeks lebih besar daripada atau sama dengan saya dalam akhiran [i]; Jika elemen pertama atau terakhir array perlu dikeluarkan; Jika elemen lain diganti; Mengembalikan LCM minimum; Kod pemacu", "code": "class GFG { static int lcm ( int a , int b ) { int GCD = __gcd ( a , b ) ; return ( a * b ) / GCD ; } static int MinLCM ( int a [ ] , int n ) { int [ ] Prefix = new int [ n + 2 ] ; int [ ] Suffix = new int [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = Math . min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a [ ] = { 5 , 15 , 9 , 36 } ; int n = a . length ; System . out . println ( MinLCM ( a , n ) ) ; } }"}
{"text": "Bilangan berwarna 0 dalam n | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan kiraan berwarna 0 s dalam segi enam tahap n; Kod pemacu", "code": "class GFG { static int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( count ( n ) ) ; } }"}
{"text": "Nilai minimum yang akan diberikan kepada unsur -unsur supaya jumlahnya menjadi lebih besar daripada jumlah awal | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan nilai minimum yang diperlukan; Cari jumlah elemen array; Mengembalikan nilai yang diperlukan; Kod pemacu", "code": "class GFG { static int findMinValue ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( int ) ( sum / n ) + 1 ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = arr . length ; System . out . print ( findMinValue ( arr , n ) ) ; } }"}
{"text": "Warna semua kotak sejajar supaya setiap kotak berturut -turut m adalah unik | Pelaksanaan Java pendekatan di atas; Fungsi untuk kembali (M! % Mod); Kod pemacu", "code": "class GFG { static final int MOD = 1000000007 ; static int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( modFact ( n , m ) ) ; } }"}
{"text": "Jumlah kuadrat semua subset dari array yang diberikan | Pelaksanaan Java pendekatan; Berfungsi untuk kembali (2 ^ p % mod); Berfungsi untuk mengembalikan jumlah kuadrat subset; Squuaring unsur -unsur dan menambahkannya ke Ans; Kod pemacu", "code": "class GFG { static final int mod = ( int ) ( 1e9 + 7 ) ; static long power ( int p ) { long res = 1 ; for ( int i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; } static long subset_square_sum ( int A [ ] ) { int n = A . length ; long ans = 0 ; for ( int i : A ) { ans += ( 1 * i * i ) % mod ; ans %= mod ; } return ( 1 * ans * power ( n - 1 ) ) % mod ; } public static void main ( String [ ] args ) { int A [ ] = { 3 , 7 } ; System . out . println ( subset_square_sum ( A ) ) ; } }"}
{"text": "Cari bilangan pasangan supaya GCD mereka sama dengan 1 | Program Java untuk mencari bilangan pasangan seperti yang GCD sama dengan 1; Berfungsi untuk mengira faktor utama paling kurang setiap nombor; Jika ia adalah nombor utama; Untuk semua gandaan yang belum dikunjungi. ; Berfungsi untuk mencari nilai fungsi Mobius untuk semua nombor dari 1 hingga n; Jika nombor adalah satu; Jika nombor mempunyai faktor utama kuasa; Multiply - 1 dengan nombor sebelumnya; Berfungsi untuk mencari bilangan pasangan seperti yang GCD sama dengan 1; Untuk menyimpan nombor maksimum; Untuk menyimpan kekerapan setiap nombor; Cari kekerapan dan nombor maksimum; Untuk menyimpan nombor pasangan dengan GCD sama dengan 1; Melintasi semua elemen yang mungkin; Mengembalikan bilangan pasangan; Kod pemacu; Panggilan fungsi", "code": "class GFG { static int N = 100050 ; static int [ ] lpf = new int [ N ] ; static int [ ] mobius = new int [ N ] ; static void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( lpf [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) if ( lpf [ j ] == 0 ) lpf [ j ] = i ; } static void Mobius ( ) { for ( int i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = - 1 * mobius [ i / lpf [ i ] ] ; } } } static int gcd_pairs ( int a [ ] , int n ) { int maxi = 0 ; int [ ] fre = new int [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { fre [ a [ i ] ] ++ ; maxi = Math . max ( a [ i ] , maxi ) ; } least_prime_factor ( ) ; Mobius ( ) ; int ans = 0 ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( mobius [ i ] == 0 ) continue ; int temp = 0 ; for ( int j = i ; j <= maxi ; j += i ) temp += fre [ j ] ; ans += temp * ( temp - 1 ) / 2 * mobius [ i ] ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = a . length ; System . out . print ( gcd_pairs ( a , n ) ) ; } }"}
{"text": "Membandingkan x ^ y dan y ^ x untuk nilai -nilai yang sangat besar x dan y | Pelaksanaan Java pendekatan; Fungsi untuk membandingkan x ^ y dan y ^ x; Menyimpan nilai x ^ y dan y ^ x; Membandingkan nilai; Kod pemacu", "code": "import java . util . * ; class GFG { static void compareVal ( int x , int y ) { double a = y * Math . log ( x ) ; double b = x * Math . log ( y ) ; if ( a > b ) System . out . print ( x + \" ^ \" + y + \" ▁ > ▁ \" + y + \" ^ \" + x ) ; else if ( a < b ) System . out . print ( x + \" ^ \" + y + \" ▁ < ▁ \" + y + \" ^ \" + x ) ; else if ( a == b ) System . out . print ( x + \" ^ \" + y + \" ▁ = ▁ \" + y + \" ^ \" + x ) ; } public static void main ( String [ ] args ) { int x = 4 , y = 5 ; compareVal ( x , y ) ; } }"}
{"text": "Nombor Euler Zigzag (Permutasi Ganti) | Program Java untuk mencari urutan zigzag; Berfungsi untuk mencetak nombor zigzag pertama; Untuk menyimpan nombor factorial dan n 'th zig zag; Memulakan factorial sehingga n; Tetapkan dua nombor Zig Zag pertama; Cetak dua nombor zig zag pertama; Cetak nombor zig zag selebihnya; Binomial (n, k) * a (k) * a (n - k); Simpan nilai; Cetak nombor; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void ZigZag ( int n ) { long [ ] fact = new long [ n + 1 ] ; long [ ] zig = new long [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) zig [ i ] = 0 ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; System . out . print ( \" zig ▁ zag ▁ numbers : ▁ \" ) ; System . out . print ( zig [ 0 ] + \" ▁ \" + zig [ 1 ] + \" ▁ \" ) ; for ( int i = 2 ; i < n ; i ++ ) { long sum = 0 ; for ( int k = 0 ; k <= i - 1 ; k ++ ) { sum += ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; } zig [ i ] = sum / 2 ; System . out . print ( sum / 2 + \" ▁ \" ) ; } } public static void main ( String [ ] args ) throws java . lang . Exception { int n = 10 ; ZigZag ( n ) ; } }"}
{"text": "Urutan Gijswijt | Program Java untuk menunjukkan urutan Gijswijt; Jika urutan adalah (1) a (2) a (3). . A (n - 1) Periksa jika urutan boleh diwakili sebagai x * (y ^ k) mencari nilai terbesar k; kiraan; Corak unsur -unsur saiz I dari akhir urutan; kiraan; ekstrak corak dalam urutan terbalik; Semak berapa kali corak diulang; jika perlawanan dosis elemen; Jika akhir corak dicapai nilai set k = 0 dan tingkatkan kiraan; mengembalikan kiraan maksimum; cetak pertama n terma urutan Gijswijt; Tetapkan kiraan; membongkok elemen; Cetak istilah N pertama urutan; tolak elemen; Cari kiraan untuk nombor seterusnya; Kod pemacu", "code": "import java . util . * ; class GFG { static int find_count ( Vector < Integer > ele ) { int count = 0 ; for ( int i = 0 ; i < ele . size ( ) ; i ++ ) { Vector < Integer > p = new Vector < Integer > ( ) ; int c = 0 ; for ( int j = ele . size ( ) - 1 ; j >= ( ele . size ( ) - 1 - i ) && j >= 0 ; j -- ) { p . add ( ele . get ( j ) ) ; } int j = ele . size ( ) - 1 , k = 0 ; while ( j >= 0 ) { if ( ele . get ( j ) != p . get ( k ) ) { break ; } j -- ; k ++ ; if ( k == p . size ( ) ) { c ++ ; k = 0 ; } } count = Math . max ( count , c ) ; } return count ; } static void solve ( int n ) { int count = 1 ; Vector < Integer > ele = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( count + \" , ▁ \" ) ; ele . add ( count ) ; count = find_count ( ele ) ; } } public static void main ( String [ ] args ) { int n = 10 ; solve ( n ) ; } }"}
{"text": "Wedderburn - Nombor Etherington | Program Java untuk mencari istilah urutan; Menyimpan nombor Wedderburn Etherington; Berfungsi untuk mengembalikan nombor Nth Wedderburn Etherington; Kes asas; Jika n adalah n = 2 x; Dapatkan x; A (2 x) = A (1) A (2 x - 1) + A (2) A (2 x - 2) + ... + A (x - 1) A (x + 1); a (x) (a (x) + 1) / 2; Simpan Ans; Mengembalikan jawapan yang diperlukan; Jika n adalah ganjil; a (2 x - 1) = a (1) a (2 x - 2) + a (2) a (2 x - 3) + ... + a (x - 1) a (x) ,; Simpan Ans; Mengembalikan jawapan yang diperlukan; Berfungsi untuk mencetak nombor N First N Wedderburn Etherington; Simpan nombor 3 pertama; Cetak n terma; Kod pemacu; panggilan fungsi", "code": "import java . util . * ; class GFG { static HashMap < Integer , Integer > store = new HashMap < Integer , Integer > ( ) ; static int Wedderburn ( int n ) { if ( n <= 2 ) return store . get ( n ) ; else if ( n % 2 == 0 ) { int x = n / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store . get ( i ) * store . get ( n - i ) ; } ans += ( store . get ( x ) * ( store . get ( x ) + 1 ) ) / 2 ; store . put ( n , ans ) ; return ans ; } else { int x = ( n + 1 ) / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store . get ( i ) * store . get ( n - i ) ; } store . put ( n , ans ) ; return ans ; } } static void Wedderburn_Etherington ( int n ) { store . put ( 0 , 0 ) ; store . put ( 1 , 1 ) ; store . put ( 2 , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( Wedderburn ( i ) ) ; if ( i != n - 1 ) System . out . print ( \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int n = 10 ; Wedderburn_Etherington ( n ) ; } }"}
{"text": "Nilai maksimum selepas menggabungkan semua elemen dalam array | Program Java ke nilai maksimum selepas menggabungkan semua elemen dalam array; Berfungsi dengan nilai maksimum selepas menggabungkan semua elemen dalam array; Untuk memeriksa sama ada elemen positif dan negatif hadir atau tidak; Semak integer positif; Semak integer negatif; Jika kedua -dua unsur positif dan negatif hadir; Untuk menyimpan nilai maksimum yang mungkin; Untuk mencari nilai minimum; Keluarkan elemen minimum; Menggantikan dengan nilai mutlak; Untuk mencari nilai minimum; Keluarkan elemen minimum; Mengembalikan jumlah yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "import java . io . * ; class GFG { static int Max_sum ( int a [ ] , int n ) { int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( ( pos == 1 ) && ( neg == 1 ) ) break ; } int sum = 0 ; if ( ( pos == 1 ) && ( neg == 1 ) ) { for ( int i = 0 ; i < n ; i ++ ) sum += Math . abs ( a [ i ] ) ; } else if ( pos == 1 ) { int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 3 , 5 , - 2 , - 6 } ; int n = a . length ; System . out . println ( Max_sum ( a , n ) ) ; } }"}
{"text": "Perpuluhan untuk binari menggunakan rekursi dan tanpa menggunakan pengendali kuasa | Pelaksanaan Java pendekatan; Fungsi rekursif untuk menukar n kepada bersamaan binari; Kes asas; Panggilan rekursif; Kod pemacu", "code": "import java . io . * ; class GFG { static void decimalToBinary ( int n ) { if ( n == 0 ) { System . out . print ( \"0\" ) ; return ; } decimalToBinary ( n / 2 ) ; System . out . print ( n % 2 ) ; } public static void main ( String [ ] args ) { int n = 13 ; decimalToBinary ( n ) ; } }"}
{"text": "Cari nilai minimum a, b dan c apabila dua (a + b), (a + c) dan (b + c) diberikan | Pelaksanaan Java pendekatan; Berfungsi untuk mencari A, B dan C; Simpan nombor minimum dalam x; Cari nombor; Kod pemacu; Panggilan fungsi", "code": "import java . io . * ; class GFG { static void MinimumValue ( int x , int y ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int a = 1 ; int b = x - 1 ; int c = y - b ; System . out . print ( a + \" ▁ \" + b + \" ▁ \" + c ) ; } public static void main ( String [ ] args ) { int x = 123 , y = 13 ; MinimumValue ( x , y ) ; } }"}
{"text": "Semak sama ada mungkin untuk menukar A ke B | Pelaksanaan Java pendekatan; Fungsi yang mengembalikan benar jika A boleh ditukar kepada B dengan operasi yang diberikan; Jika nombor semasa berakhir dengan 1; Jika nombor semasa boleh dibahagikan dengan 2; Jika di atas dua keadaan gagal; Sekiranya mungkin untuk menukar A ke B; Kod pemacu", "code": "class GFG { static boolean canConvert ( int a , int b ) { while ( b > a ) { if ( b % 10 == 1 ) { b /= 10 ; continue ; } if ( b % 2 == 0 ) { b /= 2 ; continue ; } return false ; } if ( b == a ) return true ; return false ; } public static void main ( String [ ] args ) { int A = 2 , B = 82 ; if ( canConvert ( A , B ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Count Rectangles yang berbeza dalam N * N Chessboard | Program Java untuk mengira segi empat tepat yang unik di papan catur; Fungsi untuk mengira segi empat tepat yang berbeza; Kod pemacu", "code": "class Rectangle { static int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . print ( count ( n ) ) ; } }"}
{"text": "Jumlah hari yang diambil untuk menyelesaikan tugas jika selepas hari -hari tertentu seseorang meninggalkan | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan bilangan hari yang diperlukan; Kod pemacu", "code": "import java . io . * ; class GFG { static int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; } public static void main ( String [ ] args ) { int a = 10 , b = 20 , n = 5 ; System . out . println ( numberOfDays ( a , b , n ) ) ; } }"}
{"text": "Cari purata dua nombor menggunakan operasi bit | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan purata x dan y menggunakan operasi bit; Kirakan nilai lantai purata (x + y) / 2; Kod pemacu", "code": "class GFG { static int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; } public static void main ( String [ ] args ) { int x = 10 , y = 9 ; System . out . print ( getAverage ( x , y ) ) ; } }"}
{"text": "Indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya; Pada mulanya; Melintasi array; Semak jika elemen array adalah 1; a [i] = 0; Kembali minimum kedua -duanya; Kod pemacu", "code": "class GFG { static int smallestIndex ( int [ ] a , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . min ( right1 , right0 ) ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = a . length ; System . out . println ( smallestIndex ( a , n ) ) ; } }"}
{"text": "Jumlah kedudukan di mana raja boleh sampai di papan catur dengan tepat m bergerak | Tetapkan 2 | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan kiraan dataran yang boleh dikunjungi oleh raja dalam gerakan; Untuk menyimpan kiraan dataran; Semak semua dataran papan catur; Semak jika persegi (i, j) berada pada jarak <= m unit dari kedudukan semasa Raja; Kembali kiraan kuadrat; Kod pemacu", "code": "class GFG { static int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; } public static void main ( String [ ] args ) { int r = 4 , c = 4 , m = 1 ; System . out . print ( countSquares ( r , c , m ) ) ; } }"}
{"text": "Bilangan kuadrup di mana tiga syarat pertama berada dalam AP dan tiga istilah terakhir adalah dalam gp | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan kiraan kuadrup; Jadual Hash untuk mengira bilangan kejadian; Melintasi dan meningkatkan kiraan; Jalankan dua gelung bersarang untuk elemen kedua dan ketiga; Jika mereka sama; Pada mulanya mengurangkan kiraan; Cari elemen pertama menggunakan perbezaan bersama; Cari elemen keempat menggunakan gp y ^ 2 = x * z harta; Jika ia adalah integer; Jika tidak sama; Unsur yang sama; Kemudian meningkatkan nilai untuk pengiraan masa depan; Kod pemacu", "code": "import java . util . * ; class GFG { static int countQuadruples ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mp . put ( a [ j ] , mp . get ( a [ j ] ) - 1 ) ; mp . put ( a [ k ] , mp . get ( a [ k ] ) - 1 ) ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) { if ( mp . containsKey ( first ) && mp . containsKey ( fourth ) ) count += mp . get ( first ) * mp . get ( fourth ) ; } else if ( mp . containsKey ( first ) && mp . containsKey ( fourth ) ) count += mp . get ( first ) * ( mp . get ( fourth ) - 1 ) ; } if ( mp . containsKey ( a [ j ] ) ) { mp . put ( a [ j ] , mp . get ( a [ j ] ) + 1 ) ; } else { mp . put ( a [ j ] , 1 ) ; } if ( mp . containsKey ( a [ k ] ) ) { mp . put ( a [ k ] , mp . get ( a [ k ] ) + 1 ) ; } else { mp . put ( a [ k ] , 1 ) ; } } } return count ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 6 , 4 , 9 , 2 } ; int n = a . length ; System . out . print ( countQuadruples ( a , n ) ) ; } }"}
{"text": "Nombor dalam julat dengan akar digital yang diberikan | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan kiraan nombor yang diperlukan; Kiraan nombor yang ada dalam julat yang diberikan; Bilangan kumpulan 9 elemen bermula dari L; Meninggalkan unsur -unsur yang tidak diliputi dalam Faktor 9; Satu nombor dalam setiap kumpulan 9; Untuk memeriksa sama ada nombor dalam REM memenuhi harta itu; Kod pemacu", "code": "class GFG { static int countNumbers ( int L , int R , int K ) { if ( K == 9 ) { K = 0 ; } int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) { ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int L = 10 ; int R = 22 ; int K = 3 ; System . out . println ( countNumbers ( L , R , K ) ) ; } }"}
{"text": "Jumlah nilai dan kemas kini pertanyaan pada array | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan jumlah elemen walaupun selepas mengemas kini nilai pada indeks yang diberikan; Tambah nilai yang diberikan kepada [indeks]; Untuk menyimpan jumlah elemen walaupun; Jika elemen semasa adalah walaupun; Berfungsi untuk mencetak hasil untuk setiap pertanyaan; Vektor yang dihasilkan yang menyimpan hasil untuk setiap pertanyaan; Dapatkan jumlah elemen walaupun selepas mengemas kini nilai pada indeks yang diberikan; Simpan jumlah untuk setiap pertanyaan; Cetak hasil untuk setiap pertanyaan; Kod pemacu", "code": "class GFG { static int EvenSum ( int [ ] A , int index , int value ) { A [ index ] = A [ index ] + value ; int sum = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; return sum ; } static void BalanceArray ( int [ ] A , int [ ] [ ] Q ) { int [ ] ANS = new int [ Q . length ] ; int i , sum ; for ( i = 0 ; i < Q . length ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; sum = EvenSum ( A , index , value ) ; ANS [ i ] = sum ; } for ( i = 0 ; i < ANS . length ; i ++ ) System . out . print ( ANS [ i ] + \" ▁ \" ) ; } public static void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 , 4 } ; int [ ] [ ] Q = { { 0 , 1 } , { 1 , - 3 } , { 0 , - 4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; } }"}
{"text": "Jumlah nilai dan kemas kini pertanyaan pada array | Pelaksanaan Java pendekatan; Berfungsi untuk mencetak hasil untuk setiap pertanyaan; Jika elemen semasa adalah walaupun; Jika elemen bahkan kemudian keluarkannya dari jumlah; Jika nilai menjadi walaupun selepas mengemas kini; Simpan jumlah untuk setiap pertanyaan; Cetak hasil untuk setiap pertanyaan; Kod pemacu", "code": "class GFG { static void BalanceArray ( int [ ] A , int [ ] [ ] Q ) { int [ ] ANS = new int [ A . length ] ; int i , sum = 0 ; for ( i = 0 ; i < A . length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . length ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS [ i ] = sum ; } for ( i = 0 ; i < ANS . length ; i ++ ) System . out . print ( ANS [ i ] + \" ▁ \" ) ; } public static void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 , 4 } ; int [ ] [ ] Q = { { 0 , 1 } , { 1 , - 3 } , { 0 , - 4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; } }"}
{"text": "Bilangan Siklus Hamiltonian | Program Java untuk pelaksanaan program di atas; Fungsi yang mengira bilangan kitaran Hamiltonian; Mengira faktorial; Kod pemacu", "code": "class GFG { static int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; } public static void main ( String [ ] args ) { int N = 5 ; int Number = Cycles ( N ) ; System . out . println ( \" Hamiltonian ▁ cycles ▁ = ▁ \" + Number ) ; } }"}
{"text": "Integer terkecil lebih besar daripada n sedemikian rupa sehingga ia terdiri daripada digit m tepat kali K | Pelaksanaan Java pendekatan; Fungsi yang pulih benar jika n mengandungi digit m tepat k kali; Berfungsi untuk mengembalikan integer terkecil> n dengan digit m yang berlaku tepat kali K; Kod pemacu", "code": "class GFG { static boolean digitWell ( int n , int m , int k ) { int cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n /= 10 ; } return cnt == k ; } static int findInt ( int n , int m , int k ) { int i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } } public static void main ( String [ ] args ) { int n = 111 , m = 2 , k = 2 ; System . out . println ( findInt ( n , m , k ) ) ; } }"}
{"text": "KOMPOSITE XOR DAN COPRIME DAN | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan kiraan nombor ganjil dalam array; Pembolehubah untuk mengira nombor ganjil; Nombor ganjil; Berfungsi untuk mengembalikan kiraan pasangan yang sah; Kod pemacu", "code": "class GFG { static int countOdd ( int [ ] arr , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; } static int countValidPairs ( int [ ] arr , int n ) { int odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) / 2 ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( countValidPairs ( arr , n ) ) ; } }"}
{"text": "Cube sempurna terkecil dibahagi dengan semua elemen array | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan GCD dua nombor; Berfungsi untuk mengembalikan LCM dari unsur -unsur array; Untuk mengira LCM dua nombor melipatgandakan mereka dan membahagikan hasilnya dengan GCD kedua -dua nombor; Mengembalikan LCM unsur -unsur array; Berfungsi untuk mengembalikan kiub sempurna yang paling smaintest yang boleh dibahagikan dengan tidak elemen arr []; LCM semua elemen ARR []; Jika 2 membahagikan bilangan kali LCM CNT; Semak nombor yang membahagikan LCM; Kembalikan jawapannya; Kod pemacu", "code": "import java . util . * ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static int lcmOfArray ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; } static int minPerfectCube ( int arr [ ] , int n ) { int minPerfectCube ; int lcm = lcmOfArray ( arr , n ) ; minPerfectCube = lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; int i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; } return minPerfectCube ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 125 , 14 , 42 , 100 } ; int n = arr . length ; System . out . println ( minPerfectCube ( arr , n ) ) ; } }"}
{"text": "Semak jika n adalah Perdana yang kuat | Program Java untuk memeriksa sama ada nombor yang diberikan adalah perdana yang kuat; Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah perdana yang kuat; Jika n bukan nombor perdana atau n adalah perdana pertama maka kembali palsu; Inisialisasi sebelumnya_prime ke n - 1 dan next_prime ke n + 1; Cari nombor perdana seterusnya; Cari nombor perdana sebelumnya; Min aritmetik; Jika n adalah perdana yang kuat; Kod pemacu", "code": "class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static boolean isStrongPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n > mean ) return true ; else return false ; } public static void main ( String args [ ] ) { int n = 11 ; if ( isStrongPrime ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Penyingkiran minimum dalam nombor yang boleh dibahagikan dengan 10 kuasa yang dibangkitkan kepada k | Program Java untuk mengira bilangan digit yang boleh dikeluarkan sedemikian rupa sehingga nombor itu boleh dibahagikan dengan 10 ^ k; berfungsi untuk mengembalikan bilangan digit yang diperlukan untuk dikeluarkan; Menukar nombor yang diberikan ke dalam rentetan; pembolehubah untuk menyimpan nombor digit yang akan dikeluarkan; Pembolehubah untuk menunjukkan jika sekurang -kurangnya satu sifar telah dijumpai; sifar dijumpai; saiz pulangan - 1 jika k tidak sifar dan atleast satu sifar hadir, jika tidak hasilnya; Kod pemacu untuk menguji fungsi di atas", "code": "public class GFG { static int countDigitsToBeRemoved ( int N , int K ) { String s = Integer . toString ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s . charAt ( i ) == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K == 0 ) return res ; else if ( f_zero == 1 ) return s . length ( ) - 1 ; return - 1 ; } public static void main ( String [ ] args ) { int N = 10904025 ; int K = 2 ; System . out . println ( countDigitsToBeRemoved ( N , K ) ) ; N = 1000 ; K = 5 ; System . out . println ( countDigitsToBeRemoved ( N , K ) ) ; N = 23985 ; K = 2 ; System . out . println ( countDigitsToBeRemoved ( N , K ) ) ; } }"}
{"text": "Program untuk mencari jumlah siri (1 / a + 2 / a ^ 2 + 3 / a ^ 3 + ... + n / a ^ n) | Program Java untuk mencari jumlah siri yang diberikan; Berfungsi untuk mengembalikan jumlah siri; pembolehubah untuk menyimpan jawapannya; Matematik. pow (x, y) mengembalikan x ^ y; Kod pemacu; Cetak jumlah siri", "code": "import java . util . Scanner ; public class HelloWorld { public static float getSum ( int a , int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / Math . pow ( a , i ) ) ; } return sum ; } public static void main ( String [ ] args ) { int a = 3 , n = 3 ; System . out . println ( getSum ( a , n ) ) ; } }"}
{"text": "Semak sama ada nombor adalah nombor yang tidak biasa atau tidak | Program Java untuk memeriksa nombor yang luar biasa; Fungsi utiliti untuk mencari faktor utama terbesar bagi nombor; Memulakan pemboleh ubah faktor utama maksimum dengan yang paling rendah; Cetak bilangan 2 s yang membahagikan n; n >> = 1; bersamaan dengan n /= 2; n mesti ganjil pada ketika ini, dengan itu melangkau nombor -nombor bahkan dan berulang hanya untuk bilangan bulat yang ganjil; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Berfungsi untuk memeriksa nombor yang tidak biasa; Dapatkan faktor utama terbesar nombor; Semak jika faktor utama terbesar adalah lebih besar daripada sqrt (n); Kod pemacu", "code": "class GFG { static int largestPrimeFactor ( int n ) { int max = - 1 ; while ( n % 2 == 0 ) { max = 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max = i ; n = n / i ; } } if ( n > 2 ) max = n ; return max ; } static boolean checkUnusual ( int n ) { int factor = largestPrimeFactor ( n ) ; if ( factor > Math . sqrt ( n ) ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { int n = 14 ; if ( checkUnusual ( n ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text": "Semak jika sekurang -kurangnya separuh array boleh diturunkan kepada sifar dengan melakukan beberapa operasi | Program Java untuk mencari sama ada setengah - array reducible kepada 0; Berfungsi untuk mencetak hasil yang diingini selepas pengiraan; Kod pemacu", "code": "public class GFG { static void isHalfReducible ( int arr [ ] , int n , int m ) { int frequencyHash [ ] = new int [ m + 1 ] ; int i ; for ( i = 0 ; i < frequencyHash . length ; i ++ ) frequencyHash [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 8 , 16 , 32 , 3 , 12 } ; int n = arr . length ; int m = 7 ; isHalfReducible ( arr , n , m ) ; } }"}
{"text": "Semak jika nombor yang diberikan adalah nombor bijih atau tidak | Program Java untuk memeriksa sama ada nombor yang diberikan adalah nombor bijih; Fungsi yang mengembalikan purata harmonik. ; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi sama, simpan 'i'; lain sebaliknya menyimpan 'i' dan 'n / i' kedua -duanya; Fungsi utiliti untuk mengira min harmonik pembahagi; Mengisytiharkan pembolehubah jumlah dan permulaan dengan sifar. ; hitung penyebut; Mengira min dan pulangan harmonik; Berfungsi untuk memeriksa sama ada nombor adalah nombor bijih; Kirakan min harmonik pembahagi n; Semak jika min harmonik adalah integer atau tidak; Kod pemacu", "code": "import java . util . * ; class GFG { static Vector < Integer > arr = new Vector < Integer > ( ) ; static void generateDivisors ( int n ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) arr . add ( i ) ; { arr . add ( i ) ; arr . add ( n / i ) ; } } } } static double harmonicMean ( int n ) { generateDivisors ( n ) ; double sum = 0.0 ; int len = arr . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum = sum + n / arr . get ( i ) ; sum = sum / n ; return arr . size ( ) / sum ; } static boolean isOreNumber ( int n ) { double mean = harmonicMean ( n ) ; if ( mean - Math . floor ( mean ) == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 28 ; if ( isOreNumber ( n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text": "Semak sama ada nombor yang diberikan adalah nombor Euclid atau tidak | Program Java untuk memeriksa nombor Euclid; Berfungsi untuk menjana nombor utama dan menyimpan produk mereka; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; kedai awalan produk nombor utama ke unordered_set 's'; mengemas kini produk dengan mendarabkan Perdana Seterusnya; Masukkan 'Produce + 1' untuk ditetapkan; Berfungsi untuk memeriksa nombor untuk nombor Euclid; Periksa sama ada nombor wujud dalam set yang tidak teratur atau tidak jika ada, kembali benar; Kod pemacu; Dapatkan nombor utama; Dapatkan n; Semak jika n adalah nombor euclid; Dapatkan n; Periksa sama ada n adalah nombor euclid", "code": "import java . util . * ; class GFG { static int MAX = 10000 ; static HashSet < Integer > s = new HashSet < Integer > ( ) ; static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . add ( product + 1 ) ; } } } static boolean isEuclid ( int n ) { if ( s . contains ( n ) ) return true ; else return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 31 ; if ( isEuclid ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; n = 42 ; if ( isEuclid ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Semak sama ada nombor yang diberikan ialah Wagstaff Prime atau tidak | Program Java untuk memeriksa sama ada nombor adalah Wagstaff Prime atau tidak; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi utiliti untuk memeriksa kuasa dua; Program pemacu; Semak jika nombor adalah perdana dan borang (2 ^ q + 1) / 3", "code": "class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } static boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } public static void main ( String [ ] args ) { int n = 43 ; if ( isPrime ( n ) && ( isPowerOfTwo ( n * 3 - 1 ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segi enam | Program Java untuk mencari kawasan persegi yang tertulis dalam bulatan yang seterusnya ditulis dalam segi enam; Berfungsi untuk mencari kawasan dataran; sisi segi enam tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "import java . io . * ; class GFG { static float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . pow ( ( a * Math . sqrt ( 3 ) ) / ( Math . sqrt ( 2 ) ) , 2 ) ; return area ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( area ( a ) ) ; } }"}
{"text": "Program untuk mencari istilah n Siri 1, 6, 17, 34, 56, 86, 121, 162, ... .... | Program Java untuk mencari istilah n siri: 1, 6, 17, 34, 56, 86, 121, 162, .... . ; mengira istilah siri nth; Kod pemacu", "code": "public class GFG { static int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) - 4 * n + 2 ; } public static void main ( String args [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }"}
{"text": "Jumlah terma pertama N Siri 2, 10, 30, 68, .... | Program Java untuk mencari jumlah terma pertama N; Berfungsi untuk mengira jumlah; Kod pemacu; bilangan syarat yang akan dimasukkan dalam jumlah; Cari jumlahnya", "code": "public class GFG { static int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + ( int ) Math . pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . println ( \" Sum ▁ = ▁ \" + calculateSum ( n ) ) ; } }"}
{"text": "Semak jika dua tatasusunan adalah permutasi antara satu sama lain menggunakan operasi matematik | Kod Java untuk memeriksa sama ada tatasusunan adalah permutasi EAH yang lain; Fungsi untuk memeriksa sama ada tatasusunan adalah permutasi antara satu sama lain. ; Mengira jumlah dan kalikan array pertama; Mengira jumlah dan kalikan array kedua; Jika jumlah dan Mul kedua -dua tatasusunan adalah sama, kembali benar, lain kembali palsu. ; Kod pemacu", "code": "import java . io . * ; class GFG { static boolean arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 2 } ; int b [ ] = { 3 , 1 , 2 } ; int n = a . length ; int m = b . length ; if ( arePermutations ( a , b , n , m ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Program untuk mencari permulaan dalam perlumbaan | Pelaksanaan Java pendekatan di atas; Fungsi untuk mencari B mula c; Apabila B menyelesaikannya 100 meter kemudian selesai meter dengan C adalah; Kod pemacu; Apabila ia menyelesaikannya 100 meter kemudian selesai meter b dan c adalah", "code": "public class GFG { static int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; } public static void main ( String [ ] args ) { int B = 10 ; int C = 28 ; B = 100 - B ; C = 100 - C ; System . out . println ( Race ( B , C ) + \" ▁ meters \" ) ; } }"}
{"text": "Masa minimum diperlukan untuk mengisi tangki menggunakan paip n | Pelaksanaan Java pendekatan di atas; Berfungsi untuk mengira masa; Kod pemacu", "code": "import java . io . * ; class GFG { static float Time ( float arr [ ] , int n , float Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; } public static void main ( String [ ] args ) { float arr [ ] = { 12 , 14 } ; float Emptypipe = 30 ; int n = arr . length ; System . out . println ( ( int ) ( Time ( arr , n , Emptypipe ) ) + \" ▁ Hours \" ) ; } }"}
{"text": "Semak jika perwakilan perpuluhan nombor oktal boleh dibahagikan dengan 7 | Program Java untuk memeriksa sama ada perwakilan perpuluhan nombor oktal boleh dibahagikan dengan 7 atau tidak; Berfungsi untuk memeriksa kebolehpasaran; Jumlah semua digit individu; Keadaan; Kod pemacu; Nombor oktal", "code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; } public static void main ( String args [ ] ) { int n = 25 ; String s = ( check ( n ) == 1 ) ? \" YES \" : \" NO \" ; System . out . println ( s ) ; } }"}
{"text": "Jumlah semua pembahagi utama nombor | Program Java untuk mencari jumlah pembahagi utama N; Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; berfungsi untuk mencari jumlah pembahagi utama N; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static int SumOfPrimeDivisors ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( isPrime ( i ) ) sum += i ; } } return sum ; } public static void main ( String args [ ] ) { int n = 60 ; System . out . print ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" + SumOfPrimeDivisors ( n ) + \"NEW_LINE\"); } }"}
{"text": "Jumlah semua pembahagi utama nombor | Program Java untuk mencari pembahagi utama semua nombor dari 1 hingga n; berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static int Sum ( int N ) { int SumOfPrimeDivisors [ ] = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 0 ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } public static void main ( String args [ ] ) { int N = 60 ; System . out . print ( \" Sum ▁ of ▁ prime ▁ \" + \" divisors ▁ of ▁ 60 ▁ is ▁ \" + Sum ( N ) + \"NEW_LINE\"); } }"}
{"text": "Cari (a ^ b) % m di mana 'b' sangat besar | Program Java untuk mencari (a ^ b) % m untuk b sangat besar. ; Berfungsi untuk mencari kuasa; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasilnya; y mestilah sekarang y = y >> 1; y = y / 2; Kod pemacu; Input rentetan sebagai B sangat besar; Kurangkan bilangan B ke bilangan kecil menggunakan fermat kecil", "code": "import java . io . * ; class GFG { static long power ( long x , long y , long p ) { x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } public static void main ( String [ ] args ) { long a = 3 ; String b = \"100000000000000000000000000\" ; long remainderB = 0 ; long MOD = 1000000007 ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) remainderB = ( remainderB * 10 + b . charAt ( i ) - '0' ) % ( MOD - 1 ) ; System . out . println ( power ( a , remainderB , MOD ) ) ; } }"}
{"text": "Kuadrat nombor dengan digit tunggal berulang | Tetapkan 1 (3, 6 dan 9) | Program Java untuk mencari persegi jumlah besar ini; Fungsi untuk mencari persegi 333. .. .333, 666. .666 dan 999.. .999; Sekiranya nombornya adalah 333. .. .333; Jika nombor itu 666. .. .666; Jika nombor itu 999 .. .999; pembolehubah untuk hasil pegangan; Cari tidak digit; tambah saiz - 1 kali dalam hasil; Tambah satu kali B hasil; tambah saiz - 1 kali c dalam hasil; tambah satu kali d hasil; hasil pulangan; Kod pemacu; Cari persegi 33. .33; cari persegi 66. .66; cari persegi 66. .66", "code": "class GFG { static String find_Square_369 ( String num ) { char a , b , c , d ; if ( num . charAt ( 0 ) == '3' ) { a = '1' ; b = '0' ; c = '8' ; d = '9' ; } else if ( num . charAt ( 0 ) == '6' ) { a = '4' ; b = '3' ; c = '5' ; d = '6' ; } else { a = '9' ; b = '8' ; c = '0' ; d = '1' ; } String result = \" \" ; int size = num . length ( ) ; for ( int i = 1 ; i < size ; i ++ ) result += a ; result += b ; for ( int i = 1 ; i < size ; i ++ ) result += c ; result += d ; return result ; } public static void main ( String [ ] args ) { String num_3 , num_6 , num_9 ; num_3 = \"3333\" ; num_6 = \"6666\" ; num_9 = \"9999\" ; String result = \" \" ; result = find_Square_369 ( num_3 ) ; System . out . println ( \" Square ▁ of ▁ \" + num_3 + \" ▁ is ▁ : ▁ \" + result ) ; result = find_Square_369 ( num_6 ) ; System . out . println ( \" Square ▁ of ▁ \" + num_9 + \" ▁ is ▁ : ▁ \" + result ) ; result = find_Square_369 ( num_9 ) ; System . out . println ( \" Square ▁ of ▁ \" + num_9 + \" ▁ is ▁ : ▁ \" + result ) ; } }"}
{"text": "Trick for Modular Bahagian ((x1 * x2 .... Xn) / b) Mod (M) |", "code": "class GFG { public static void main ( String [ ] args ) { long ans = 1 ; long mod = ( long ) 1000000007 * 120 ; for ( int i = 0 ; i < 5 ; i ++ ) ans = ( ans * ( 55555 - i ) ) % mod ; ans = ans / 120 ; System . out . println ( \" Answer ▁ using \" + \" ▁ shortcut : ▁ \" + ans ) ; } }"}
{"text": "Cara untuk membiak elemen dengan operasi bersekutu | Kod Java untuk mencari bilangan cara untuk membiak unsur -unsur dengan operasi bersekutu; Fungsi untuk mencari faktorial yang diperlukan; Berfungsi untuk mencari NCR; berfungsi untuk mencari bilangan cara; Kod pemacu", "code": "import java . io . * ; class GFG { static int fact ( int n ) { if ( n == 0 n == 1 ) return 1 ; int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ans ; } static int nCr ( int n , int r ) { int Nr = n , Dr = 1 , ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans = ( ans * Nr ) / ( Dr ) ; Nr -- ; Dr ++ ; } return ans ; } static int solve ( int n ) { int N = 2 * n - 2 ; int R = n - 1 ; return nCr ( N , R ) * fact ( n - 1 ) ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( solve ( n ) ) ; } }"}
{"text": "Triplet Pythagorean dengan jumlah yang diberikan | Program Java untuk mencari triplet Pythagorean yang diberikan. ; Memandangkan tiga kali ganda dalam urutan yang disusun. Nilai elemen pertama dalam triplet yang disusun boleh diadakan - kebanyakan n / 3 .; Nilai elemen kedua mestilah kurang daripada sama dengan n / 2; Kod pemacu", "code": "class GFG { static void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { System . out . print ( i + \" , ▁ \" + j + \" , ▁ \" + k ) ; return ; } } } System . out . print ( \" No ▁ Triplet \" ) ; } public static void main ( String arg [ ] ) { int n = 12 ; pythagoreanTriplet ( n ) ; } }"}
{"text": "Program untuk mencetak Siri Pengembangan Binomial | Program Java untuk mencetak istilah siri binomial dan juga mengira jumlah siri. ; berfungsi untuk mengira faktorial nombor; berfungsi untuk mencetak siri; Mengira nilai n! ; gelung untuk memaparkan siri; Untuk mengira nilai NCR; mengira nilai A ke kuasa k dan x ke kuasa k; Paparkan siri; Fungsi utama bermula", "code": "import java . io . * ; class GFG { static int factorial ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } static void series ( int A , int X , int n ) { int nFact = factorial ( n ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { int niFact = factorial ( n - i ) ; int iFact = factorial ( i ) ; int aPow = ( int ) Math . pow ( A , n - i ) ; int xPow = ( int ) Math . pow ( X , i ) ; System . out . print ( ( nFact * aPow * xPow ) / ( niFact * iFact ) + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; } }"}
{"text": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | Program Java untuk mencari jumlah siri dengan jumlah AP Square yang ditandatangani alternatif. ; fungsi untuk mengira jumlah siri; Kod pemacu", "code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; } public static void main ( String args [ ] ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; System . out . println ( seiresSum ( n , a ) ) ; } }"}
{"text": "Kuasa nombor utama 'r' dalam n! | Program Java untuk mencari kuasa nombor utama 'r' dalam n! ; Berfungsi untuk mengembalikan kuasa no. 'r' dalam faktorial n; Terus membahagikan n dengan kuasa 'r' dan mengemaskini kiraan; Kod pemacu", "code": "class GFG { static int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; } public static void main ( String [ ] args ) { int n = 6 , r = 3 ; System . out . print ( power ( n , r ) ) ; } }"}
{"text": "Purata nombor natural natur pertama | Program Java untuk mencari purata jumlah nombor semulajadi yang pertama. ; Mengembalikan AVG nombor n pertama; Jumlah nombor pertama yang pertama; Purata nombor pertama yang ganjil; Kod pemacu", "code": "import java . io . * ; class GFG { static int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; } public static void main ( String [ ] args ) { int n = 20 ; avg_of_odd_num ( n ) ; System . out . println ( avg_of_odd_num ( n ) ) ; } }"}
{"text": "Purata nombor natural natur pertama | Program Java untuk mencari purata jumlah nombor pertama yang pertama; Kembalikan purata jumlah nombor pertama yang ganjil; Kod pemacu", "code": "import java . io . * ; class GFG { static int avg_of_odd_num ( int n ) { return n ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( avg_of_odd_num ( n ) ) ; } }"}
{"text": "Program untuk mencetak segitiga Fibonacci | Pelaksanaan Java untuk Segitiga Fibonacci; berfungsi untuk mengisi nombor fibonacci dalam f []; 1 ST dan 2 ND nombor siri adalah 1 dan 1; Tambah nombor 2 sebelumnya dalam siri ini dan simpannya; Isi nombor Fibonacci dalam f [] menggunakan Fib (). Kami memerlukan n = n * (n + 1) / 2 nombor fibonacci untuk membuat segitiga ketinggian n; Untuk menyimpan nombor Fibonacci seterusnya untuk dicetak; untuk gelung untuk menjejaki bilangan baris; Untuk gelung untuk menjejaki nombor dalam setiap baris; Kod pemacu", "code": "import java . io . * ; class GFG { static void fib ( int f [ ] , int N ) { f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( int i = 3 ; i <= N ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } static void fiboTriangle ( int n ) { int N = n * ( n + 1 ) / 2 ; int f [ ] = new int [ N + 1 ] ; fib ( f , N ) ; int fiboNum = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( f [ fiboNum ++ ] + \" ▁ \" ) ; System . out . println ( ) ; } } public static void main ( String args [ ] ) { int n = 5 ; fiboTriangle ( n ) ; } }"}
{"text": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | Program untuk mencari purata nombor ganjil sehingga nombor ganjil yang diberikan. ; Fungsi untuk mengira purata nombor ganjil; mengira nombor ganjil; Simpan jumlah nombor ganjil; fungsi pemacu", "code": "import java . io . * ; class GFG { static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( \" Invalid ▁ Input \" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( averageOdd ( n ) ) ; } }"}
{"text": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | Program untuk mencari purata nombor ganjil sehingga nombor ganjil yang diberikan. ; Fungsi untuk mengira purata nombor ganjil; fungsi pemacu", "code": "import java . io . * ; class GFG { static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( \" Invalid ▁ Input \" ) ; return - 1 ; } return ( n + 1 ) / 2 ; } public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( averageOdd ( n ) ) ; } }"}
{"text": "Cari Max Dua Nombor Rasional | Program Java untuk mencari Max antara dua nombor rasional; Dapatkan LCM dua nombor; Dapatkan nombor rasional maksimum; Cari LCM yang pertama. Penyebut dan Sec. penyebut; Mengisytiharkan NUME1 dan NUME2 untuk mendapatkan nilai pengangka pertama dan pengangka kedua; Kod pemacu", "code": "class GFG { static class Rational { int nume , deno ; public Rational ( int nume , int deno ) { this . nume = nume ; this . deno = deno ; } } ; static int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; } static Rational maxRational ( Rational first , Rational sec ) { int k = lcm ( first . deno , sec . deno ) ; int nume1 = first . nume ; int nume2 = sec . nume ; nume1 *= k / ( first . deno ) ; nume2 *= k / ( sec . deno ) ; return ( nume2 < nume1 ) ? first : sec ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { Rational first = new Rational ( 3 , 2 ) ; Rational sec = new Rational ( 3 , 4 ) ; Rational res = maxRational ( first , sec ) ; System . out . print ( res . nume + \" / \" + res . deno ) ; } }"}
{"text": "Trinomial Triangle | Program Java untuk mencetak Segitiga Trinomial. ; Fungsi untuk mencari nilai segitiga trinomial. ; Kes asas; Kes asas; langkah rekursif. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; fungsi pemacu", "code": "import java . util . * ; import java . lang . * ; public class GfG { public static int TrinomialValue ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ; } public static void printTrinomial ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = - i ; j <= 0 ; j ++ ) System . out . print ( TrinomialValue ( i , j ) + \" ▁ \" ) ; for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( TrinomialValue ( i , j ) + \" ▁ \" ) ; System . out . println ( ) ; } } public static void main ( String argc [ ] ) { int n = 4 ; printTrinomial ( n ) ; } }"}
{"text": "Trinomial Triangle | Program Java untuk mencetak Segitiga Trinomial. ; Fungsi untuk mencari nilai segitiga trinomial. ; Menggunakan harta segitiga trinomial. ; Jika nilai sudah dikira, kembalikan itu. ; Kes asas; Kes asas; langkah rekursif dan menyimpan nilai. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; fungsi pemacu", "code": "import java . util . * ; import java . lang . * ; public class GfG { private static final int MAX = 10 ; public static int TrinomialValue ( int dp [ ] [ ] , int n , int k ) { if ( k < 0 ) k = - k ; if ( dp [ n ] [ k ] != 0 ) return dp [ n ] [ k ] ; if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return ( dp [ n ] [ k ] = TrinomialValue ( dp , n - 1 , k - 1 ) + TrinomialValue ( dp , n - 1 , k ) + TrinomialValue ( dp , n - 1 , k + 1 ) ) ; } public static void printTrinomial ( int n ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = - i ; j <= 0 ; j ++ ) System . out . print ( TrinomialValue ( dp , i , j ) + \" ▁ \" ) ; for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( TrinomialValue ( dp , i , j ) + \" ▁ \" ) ; System . out . println ( ) ; } } public static void main ( String argc [ ] ) { int n = 4 ; printTrinomial ( n ) ; } }"}
{"text": "Jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan N | Pelaksanaan Java untuk mencari jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan N; fungsi untuk mencari jumlah faktor utama terbesar setiap nombor kurang daripada sama dengan n; Buat array Integer \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai 0. Nilai dalam Perdana [i] akhirnya akan menjadi 0 jika 'I' adalah perdana, jika tidak, ia akan mengandungi faktor utama terbesar 'I'. ; Jika Perdana [P] adalah '0', maka ia adalah nombor utama; Kemas kini semua gandaan P; Merangkumi faktor utama terbesar bagi semua nombor; jika 'p' adalah nombor bukan utama maka perdana [p] memberikan faktor utama largesr; 'P' adalah nombor utama; Jumlah yang diperlukan; Program Pemandu", "code": "import java . io . * ; import java . util . * ; class GFG { static int sumOfLargePrimeFactor ( int n ) { int prime [ ] = new int [ n + 1 ] , sum = 0 ; Arrays . fill ( prime , 0 ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] != 0 ) sum += prime [ p ] ; else sum += p ; } return sum ; } public static void main ( String args [ ] ) { int n = 12 ; System . out . println ( \" Sum ▁ = ▁ \" + sumOfLargePrimeFactor ( n ) ) ; } }"}
{"text": "Jumlah gandaan nombor sehingga n | Program Java untuk mencari jumlah gandaan nombor sehingga n dengan cekap; Berfungsi untuk mengira jumlah gandaan sehingga n; Bilangan gandaan; jumlah nombor semulajadi pertama; jumlah gandaan; Kod pemacu", "code": "class GFG { static int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; } public static void main ( String [ ] args ) { int a = 7 , N = 49 ; System . out . println ( \" Sum ▁ of ▁ multiples ▁ of ▁ \" + a + \" ▁ up ▁ to ▁ \" + N + \" ▁ = ▁ \" + calculate_sum ( a , N ) ) ; } }"}
{"text": "Memandangkan jumlah besar semak jika ia adalah kuasa dua. | Program Java untuk mencari sama ada nombor adalah kuasa 2 atau tidak; pulangan 1 apabila STR adalah kuasa 2 pulangan 0 apabila STR bukan kuasa 2; Jumlah menyimpan dividen pertengahan semasa membahagikan. ; jika input adalah \"1\" maka kembali 0 kerana 2 ^ k = 1 di mana k> = 1 dan di sini k = 0; Bahagikan nombor sehingga ia dikurangkan kepada 1 jika kita berjaya dapat mengurangkan nombor kepada 1, ia bermakna rentetan input adalah kuasa dua jika di antara nombor ganjil muncul pada akhirnya ia bermakna rentetan tidak dibahagikan dengan dua sehingga bukan kuasa 2; Sekiranya digit terakhir adalah ganjil maka rentetan tidak dapat dibahagikan dengan 2 oleh itu bukan kuasa dua pulangan 0 .; Bahagikan keseluruhan rentetan dengan 2. Saya digunakan untuk mengesan indeks dalam nombor semasa. J digunakan untuk mengesan indeks untuk lelaran seterusnya. ; Jika num <2 maka kita perlu mengambil satu lagi digit di sebelah kanan [i] untuk menjadikannya lebih besar daripada [i]. E. g. 214/2 -> 107; Jika ia bukan indeks pertama. Contohnya 214 maka kita perlu memasukkan 0 .; untuk contohnya. \"124\" Kami tidak akan menulis 064 jadi jika indeks pertama hanya mengabaikan; Selepas setiap bahagian dengan 2 panjang rentetan diubah. ; Jika rentetan mencapai 1 maka str adalah kuasa 2 .; Kod pemacu.", "code": "import java . util . * ; class GFG { static int isPowerOf2 ( String s ) { char [ ] str = s . toCharArray ( ) ; int len_str = s . length ( ) ; int num = 0 ; if ( len_str == 1 && str [ len_str - 1 ] == '1' ) return 0 ; while ( len_str != 1 str [ len_str - 1 ] != '1' ) { if ( ( str [ len_str - 1 ] - '0' ) % 2 == 1 ) return 0 ; int j = 0 ; for ( int i = 0 ; i < len_str ; i ++ ) { num = num * 10 + ( int ) str [ i ] - ( int ) '0' ; if ( num < 2 ) { if ( i != 0 ) str [ j ++ ] = '0' ; continue ; } str [ j ++ ] = ( char ) ( ( int ) ( num / 2 ) + ( int ) '0' ) ; num = ( num ) - ( num / 2 ) * 2 ; } str [ j ] = ' \\0' ; len_str = j ; } return 1 ; } public static void main ( String [ ] args ) { String str1 = \"124684622466842024680246842024662202000002\" ; String str2 = \"1\" ; String str3 = \"128\" ; System . out . println ( isPowerOf2 ( str1 ) + \"NEW_LINE\"+isPowerOf2(str2) +NEW_LINE\t\t\t\t\"NEW_LINE\"+isPowerOf2(str3)); } }"}
{"text": "Memandangkan jumlah besar semak jika ia adalah kuasa dua. | Program Java untuk mencari sama ada nombor adalah kuasa 2 atau tidak; Berfungsi untuk memeriksa sama ada nombor adalah kuasa 2 atau tidak; Kod pemacu", "code": "class GfG { static long ispowerof2 ( long num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; } public static void main ( String [ ] args ) { long num = 549755813888L ; System . out . println ( ispowerof2 ( num ) ) ; } }"}
{"text": "Pengiraan Pembahagi Array Multiplikasi | Program Java mudah untuk mengira pembahagi dalam pendaraban array. ; Untuk mengira bilangan faktor dalam nombor; Inisialisasi kiraan dengan 0; Kiraan kenaikan untuk setiap faktor nombor x yang diberikan. ; Pulangan bilangan faktor; Mengembalikan bilangan pembahagi dalam pendaraban array; Mengumpulkan semua elemen array yang diberikan. ; Fungsi panggilan yang mengira bilangan faktor nombor; Kod pemacu", "code": "class GFG { static int counDivisors ( int X ) { int count = 0 ; for ( int i = 1 ; i <= X ; ++ i ) { if ( X % i == 0 ) { count ++ ; } } return count ; } static int countDivisorsMult ( int arr [ ] , int n ) { int mul = 1 ; for ( int i = 0 ; i < n ; ++ i ) mul *= arr [ i ] ; return counDivisors ( mul ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 } ; int n = arr . length ; System . out . println ( countDivisorsMult ( arr , n ) ) ; } }"}
{"text": "Pengiraan Pembahagi Array Multiplikasi | Program Java untuk mengira pembahagi dalam pendaraban array. ; Buat array Boolean \"Isprime [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Isprime [i] akhirnya akan menjadi palsu jika saya bukannya Isprime, yang lain benar. ; Jika Isprime [p] tidak berubah, maka ia adalah isprime; Kemas kini semua gandaan P; Cetak semua nombor isprime; Mengembalikan bilangan pembahagi dalam pendaraban array; Cari semua nombor perdana yang lebih kecil daripada elemen terbesar. ; Cari tuduhan kejadian setiap faktor utama; Mengira kiraan semua pembahagi menggunakan kiraan faktor utama. ; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static void SieveOfEratosthenes ( int largest , ArrayList < Integer > prime ) { boolean [ ] isPrime = new boolean [ largest + 1 ] ; Arrays . fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= largest ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= largest ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= largest ; p ++ ) if ( isPrime [ p ] ) prime . add ( p ) ; } static long countDivisorsMult ( int [ ] arr , int n ) { int largest = 0 ; for ( int a : arr ) { largest = Math . max ( largest , a ) ; } ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; SieveOfEratosthenes ( largest , prime ) ; Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < prime . size ( ) ; j ++ ) { while ( arr [ i ] > 1 && arr [ i ] % prime . get ( j ) == 0 ) { arr [ i ] /= prime . get ( j ) ; if ( mp . containsKey ( prime . get ( j ) ) ) { mp . put ( prime . get ( j ) , mp . get ( prime . get ( j ) ) + 1 ) ; } else { mp . put ( prime . get ( j ) , 1 ) ; } } } if ( arr [ i ] != 1 ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } } long res = 1 ; for ( int it : mp . keySet ( ) ) res *= ( mp . get ( it ) + 1L ) ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 } ; int n = arr . length ; System . out . println ( countDivisorsMult ( arr , n ) ) ; } }"}
{"text": "K pasangan perdana jauh dalam julat yang diberikan | Program Java untuk pendekatan di atas; Berfungsi untuk menjana nombor perdana dalam julat yang diberikan [l, r]; Simpan semua nilai dalam julat; Padam 1 sebagai bukan perdana; Melakukan penapis eratosthenes; Cari pelbagai semasa; Padam kerana ia bukan perdana; Kenaikan berganda; Melintasi peta m; Jika ia. Pertama & (ia pertama + k) adalah perdana kemudian cetak pasangan ini; Berfungsi untuk mencetak semua pasangan utama dalam julat yang diberikan oleh k; Menjana semua nombor perdana; Kod pemacu; Julat yang diberikan; Diberikan k; Panggilan fungsi", "code": "import java . util . * ; class solution { static void findPrimeNos ( int L , int R , Map < Integer , Integer > M , int K ) { for ( int i = L ; i <= R ; i ++ ) { if ( M . get ( i ) != null ) M . put ( i , M . get ( i ) + 1 ) ; else M . put ( i , 1 ) ; } if ( M . get ( 1 ) != null ) { M . remove ( 1 ) ; } for ( int i = 2 ; i <= Math . sqrt ( R ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= R ) { if ( M . get ( i * multiple ) != null ) { M . remove ( i * multiple ) ; } multiple ++ ; } } for ( Map . Entry < Integer , Integer > entry : M . entrySet ( ) ) { if ( M . get ( entry . getKey ( ) + K ) != null ) { System . out . print ( \" ( \" + entry . getKey ( ) + \" , ▁ \" + ( entry . getKey ( ) + K ) + \" ) ▁ \" ) ; } } } static void getPrimePairs ( int L , int R , int K ) { Map < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; findPrimeNos ( L , R , M , K ) ; } public static void main ( String args [ ] ) { int L = 1 , R = 19 ; int K = 6 ; getPrimePairs ( L , R , K ) ; } }"}
{"text": "Nombor EnneAcontahExagon | Program Java untuk mencari nombor enneacontahexagon n - th; Berfungsi untuk mencari nombor enneacontahexagon nth; Kod pemacu", "code": "class GFG { static int enneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( enneacontahexagonNum ( n ) ) ; } }"}
{"text": "Cari dua nombor komposit supaya terdapat perbezaan adalah n | Kod Java untuk mencari dua nombor komposit supaya terdapat perbezaan adalah n; Berfungsi untuk mencari dua nombor komposit; Kod pemacu", "code": "class GFG { static void find_composite_nos ( int n ) { System . out . println ( 9 * n + \" ▁ \" + 8 * n ) ; } public static void main ( String [ ] args ) { int n = 4 ; find_composite_nos ( n ) ; } }"}
{"text": "Kira bilangan pasangan (i, j) supaya sama ada arr [i] boleh dibahagikan dengan arr [j] atau arr [j] boleh dibahagikan dengan arr [i] | Pelaksanaan Java pendekatan; Berfungsi untuk mencari bilangan pasangan yang tidak teratur; Elemen maksimum dari array; Array untuk menyimpan kekerapan setiap elemen; Menyimpan bilangan pasangan yang tidak teratur; Simpan kekerapan setiap elemen; Cari bilangan pasangan yang tidak teratur; Jika nombor j dibahagi dengan elemen ith hadir dalam array; Jika elemen ith array mempunyai kekerapan lebih daripada satu; Kod pemacu", "code": "import java . util . Arrays ; class GFG { static int freqPairs ( int arr [ ] , int n ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int freq [ ] = new int [ max + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) { count += freq [ j ] ; } } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 4 , 2 , 6 } ; int n = arr . length ; System . out . println ( freqPairs ( arr , n ) ) ; } }"}
{"text": "Cari istilah n Siri 1 + 2 + 6 + 15 + 31 + 56 + ... | Program Java untuk mencari istilah n siri: 1 + 2 + 6 + 15 + 31 + 56 + ...; Hitung istilah n siri yang diberikan; Kod pemacu", "code": "import java . util . * ; import java . lang . * ; class GFG { static double Nth_Term ( int n ) { return ( 2 * Math . pow ( n , 3 ) - 3 * Math . pow ( n , 2 ) + n + 6 ) / 6 ; } static public void main ( String args [ ] ) { int N = 8 ; System . out . println ( Nth_Term ( N ) ) ; } }"}
{"text": "Program untuk mencari n | Program Java untuk mencari nombor n dalam siri yang diperbuat daripada digit 3 dan 5; Fungsi untuk mencari nombor n - th dalam siri yang diperbuat daripada 3 dan 5; Buat pelbagai saiz (n + 1); Sekiranya saya ganjil; fungsi utama", "code": "class FindNth { static int printNthElement ( int n ) { int arr [ ] = new int [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( printNthElement ( n ) ) ; } }"}
{"text": "Program untuk mencari istilah n Siri 3, 6, 18, 24, ... | Kelas untuk mengira istilah siri nth; Dengan menggunakan formula di atas; Kelas utama untuk kaedah utama; Dapatkan nilai n; Buat objek kelas nth; Hitung dan cetak istilah n", "code": "import java . io . * ; class Nth { public int nthTerm ( int N ) { return ( N * ( ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; } } class GFG { public static void main ( String [ ] args ) { int N = 5 ; Nth a = new Nth ( ) ; System . out . println ( \" Nth ▁ term ▁ for ▁ N ▁ = ▁ \" + N + \" ▁ : ▁ \" + a . nthTerm ( N ) ) ; } }"}
{"text": "Program untuk mencetak Siri Pengembangan Binomial | Program Java untuk mencetak istilah siri binomial dan juga mengira jumlah siri. ; berfungsi untuk mencetak siri; Mengira dan mencetak istilah pertama; Pengkomputeran dan percetakan yang tersisa; Cari istilah semasa menggunakan terma sebelumnya, kami meningkatkan kuasa x oleh 1, kuasa penurunan sebanyak 1 dan mengira NCI menggunakan istilah sebelumnya dengan mengalikan istilah sebelumnya dengan (n - i + 1) / i; Fungsi utama bermula", "code": "import java . io . * ; class GFG { static void series ( int A , int X , int n ) { int term = ( int ) Math . pow ( A , n ) ; System . out . print ( term + \" ▁ \" ) ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; System . out . print ( term + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; } }"}
{"text": "Semak jika nombor dibahagikan dengan 8 menggunakan pengendali bitwise | Program Java untuk memeriksa sama ada nombor itu boleh dibahagikan dengan 8 atau tidak menggunakan pengendali Bitwise; Fungsi untuk memeriksa nombor div oleh 8 atau tidak menggunakan pengendali bitwise; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static boolean Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; } public static void main ( String [ ] args ) { int n = 16 ; if ( Div_by_8 ( n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | Program untuk mencari purata nombor walaupun sehingga nombor yang diberikan. ; Fungsi untuk mengira purata nombor walaupun; mengira nombor walaupun; Simpan jumlah nombor walaupun; fungsi pemacu", "code": "import java . io . * ; class GFG { static int averageEven ( int n ) { if ( n % 2 != 0 ) { System . out . println ( \" Invalid ▁ Input \" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 2 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } public static void main ( String args [ ] ) { int n = 16 ; System . out . println ( averageEven ( n ) ) ; } }"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | Program untuk mencari purata nombor walaupun sehingga nombor yang diberikan. ; Fungsi untuk mengira purata nombor walaupun; fungsi pemacu", "code": "import java . io . * ; class GFG { static int averageEven ( int n ) { if ( n % 2 != 0 ) { System . out . println ( \" Invalid ▁ Input \" ) ; return - 1 ; } return ( n + 2 ) / 2 ; } public static void main ( String args [ ] ) { int n = 16 ; System . out . println ( averageEven ( n ) ) ; } }"}
{"text": "Nombor terbesar yang membahagikan x dan co | Program Java untuk mencari pembahagi Coprime terbesar; Fungsi rekursif untuk mengembalikan GCD A dan B; Semuanya membahagikan 0; Kes asas; A lebih besar; berfungsi untuk mencari pembahagi coprime terbesar; kod pembahagi", "code": "import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } static int cpFact ( int x , int y ) { while ( gcd ( x , y ) != 1 ) { x = x / gcd ( x , y ) ; } return x ; } public static void main ( String [ ] args ) { int x = 15 ; int y = 3 ; System . out . println ( cpFact ( x , y ) ) ; x = 14 ; y = 28 ; System . out . println ( cpFact ( x , y ) ) ; x = 7 ; y = 3 ; System . out . println ( cpFact ( x , y ) ) ; } }"}
{"text": "Kira nombor dengan unit digit k dalam julat yang diberikan | Program Java mudah untuk mengira nombor dengan digit terakhir sebagai k dalam julat yang diberikan. ; Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; fungsi pemacu", "code": "import java . util . * ; import java . lang . * ; public class GfG { public static int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; } public static void main ( String args [ ] ) { int low = 3 , high = 35 , k = 3 ; System . out . println ( counLastDigitK ( low , high , k ) ) ; } }"}
{"text": "Nombor Taxicab | Kod Java untuk nombor Taxicab; Bermula dari 1, periksa setiap nombor jika ia adalah Taxicab sehingga Count mencapai n. ; Cuba semua pasangan yang mungkin (j, k) yang jumlah kiubnya boleh saya. ; Taxicab (2) dijumpai; Program pemacu untuk menguji fungsi di atas", "code": "import java . util . * ; class GFG { public static void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= Math . pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= Math . pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; System . out . println ( count + \" ▁ \" + i ) ; } i ++ ; } } public static void main ( String [ ] args ) { int N = 5 ; printTaxicab2 ( N ) ; } }"}
{"text": "Nombor Komposit | / Program Java berdasarkan kaedah yang dioptimumkan untuk memeriksa sama ada nombor komposit atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Program pemacu untuk menguji fungsi di atas", "code": "import java . io . * ; class Composite { static boolean isComposite ( int n ) { if ( n <= 1 ) System . out . println ( \" False \" ) ; if ( n <= 3 ) System . out . println ( \" False \" ) ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } public static void main ( String args [ ] ) { System . out . println ( isComposite ( 11 ) ? \" true \" : \" false \" ) ; System . out . println ( isComposite ( 15 ) ? \" true \" : \" false \" ) ; } }"}
{"text": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | Program Java untuk mencari nombor minimum untuk memasukkan dalam array supaya jumlahnya adalah perdana; berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Semak dari 2 hingga n - 1; Cari nombor perdana lebih besar daripada nombor; Cari perdana lebih besar daripada n; Semak jika Num adalah Perdana; kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Untuk mencari jumlah elemen array; jika jumlah sudah menjadi pulangan utama 0; Untuk mencari nombor perdana lebih besar daripada jumlah; Mengembalikan perbezaan jumlah dan num; Kod pemacu", "code": "class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( isPrime ( num ) ) return num ; num = num + 1 ; } return 0 ; } static int minNumber ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( isPrime ( sum ) ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . length ; System . out . println ( minNumber ( arr , n ) ) ; } }"}
{"text": "Jumlah pembahagi faktorial nombor | Program Java untuk mencari jumlah pembahagi yang betul dari faktorial nombor; fungsi untuk mengira faktorial; berfungsi untuk mengira jumlah pembahagi; Mengembalikan jumlah pembahagi N! ; Program Pemandu", "code": "import java . io . * ; import java . util . * ; public class Division { static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } static int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; } static int sumFactDiv ( int n ) { return div ( fact ( n ) ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( sumFactDiv ( n ) ) ; } }"}
{"text": "Jumlah pembahagi faktorial nombor | Program Java untuk mencari jumlah pembahagi di N! ; AllPrimes [] menyimpan semua nombor utama kurang daripada atau sama dengan n. ; Mengisi di atas vektor allprimes [] untuk n yang diberikan; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Gelung untuk mengemas kini perdana []; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Menyimpan prima dalam vektor AllPrimes; Fungsi untuk mencari semua hasil nombor faktorial; Memulakan hasil; Cari eksponen semua prima yang membahagikan n dan kurang daripada n; Pembahagi semasa; Cari kuasa tertinggi (disimpan dalam exp) '' using ; Menggunakan fungsi pembahagi untuk mengira jumlah; mengembalikan jumlah pembahagi; Program pemacu untuk menjalankan kes -kes", "code": "import java . util . * ; class GFG { static ArrayList < Integer > allPrimes = new ArrayList < Integer > ( ) ; static void sieve ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) allPrimes . add ( p ) ; } static int factorialDivisors ( int n ) { int result = 1 ; for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) { int p = allPrimes . get ( i ) ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * allPrimes . get ( i ) ; } result = result * ( ( int ) Math . pow ( allPrimes . get ( i ) , exp + 1 ) - 1 ) / ( allPrimes . get ( i ) - 1 ) ; } return result ; } public static void main ( String [ ] args ) { System . out . println ( factorialDivisors ( 4 ) ) ; } }"}
{"text": "Nombor Pandigital dalam pangkalan yang diberikan | Program Java untuk memeriksa sama ada nombor adalah Pandigital dalam asas yang diberikan. ; Kembali benar jika n adalah pandigit lain kembali palsu. ; Panjang pemeriksaan kurang daripada asas; Melintasi setiap digit nombor. ; Jika digit adalah integer; Jika digit adalah abjad; Memeriksa array hash, jika mana -mana indeks tidak ditandakan. ; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean checkPandigital ( int b , String n ) { if ( n . length ( ) < b ) return false ; boolean hash [ ] = new boolean [ b ] ; Arrays . fill ( hash , false ) ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { if ( n . charAt ( i ) >= '0' && n . charAt ( i ) <= '9' ) hash [ n . charAt ( i ) - '0' ] = true ; else if ( n . charAt ( i ) - ' A ' <= b - 11 ) hash [ n . charAt ( i ) - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; } public static void main ( String [ ] args ) { int b = 13 ; String n = \"1298450376ABC \" ; if ( checkPandigital ( b , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Tukar nombor m ke n menggunakan bilangan minimum operasi yang diberikan | Pelaksanaan Java untuk menukar nombor m ke n menggunakan bilangan minimum operasi yang diberikan; berfungsi untuk mencari bilangan minimum operasi yang diberikan untuk menukar m ke n; Hanya cara yang perlu dilakukan - 1 (m - n) kali; tidak mungkin; N lebih besar dan n adalah ganjil; lakukan ' - 1' pada m (atau + 1 pada n); n adalah juga; lakukan ' * 2' pada m (atau n / 2 pada n); Kod pemacu", "code": "class ConvertNum { static int convert ( int m , int n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return - 1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; } public static void main ( String [ ] args ) { int m = 3 , n = 11 ; System . out . println ( \" Minimum ▁ number ▁ of ▁ \" + \" operations ▁ : ▁ \" + convert ( m , n ) ) ; } }"}
{"text": "Biji (atau akar benih) nombor | Program Java untuk mencari benih nombor; Kedai produk digit x dalam proddig [x]; Jika x mempunyai angka tunggal; Jika produk digit sudah dikira; Jika produk digit tidak dikira sebelum ini. ; Mencetak semua benih n; Cari semua biji menggunakan proddig []; Sekiranya tidak ada benih; Cetak biji; Kod pemacu", "code": "import java . util . * ; class GFg { static int MAX = 10000 ; static int [ ] prodDig = new int [ MAX ] ; static int getDigitProduct ( int x ) { if ( x < 10 ) return x ; if ( prodDig [ x ] != 0 ) return prodDig [ x ] ; int prod = ( x % 10 ) * getDigitProduct ( x / 10 ) ; return ( prodDig [ x ] = prod ) ; } static void findSeed ( int n ) { List < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . add ( i ) ; if ( res . size ( ) == 0 ) { System . out . println ( \" NO ▁ seed ▁ exists \" ) ; return ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + \" ▁ \" ) ; } public static void main ( String [ ] args ) { int n = 138 ; findSeed ( n ) ; } }"}
{"text": "Nombor dengan bilangan maksimum faktor utama | Program Java untuk mencari integer yang mempunyai jumlah maksimum faktor utama dalam nombor semulajadi n pertama. ; Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Sieve kaedah Eratosthenes untuk mengira bilangan faktor utama. ; Mencari nombor yang mempunyai jumlah maksimum faktor utama. ; Program Pemandu", "code": "import java . util . Arrays ; public class GFG { static int maxPrimefactorNum ( int N ) { int arr [ ] = new int [ N + 5 ] ; Arrays . fill ( arr , 0 ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) { for ( int j = 2 * i ; j <= N ; j += i ) { arr [ j ] ++ ; } } arr [ i ] = 1 ; } int maxval = 0 , maxint = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxint = i ; } } return maxint ; } public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }"}
{"text": "Jumlah semua subarray | Tetapkan 1 | Program Java yang cekap untuk mengira jumlah unsur subarray; fungsi mengira jumlah semua sub - array; jumlah pengkomputeran subarray menggunakan formula; kembali semua jumlah subarray; Program pemacu untuk menguji fungsi di atas", "code": "class GFG { public static long SubArraySum ( int arr [ ] , int n ) { long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . println ( \" Sum ▁ of ▁ SubArray ▁ \" + SubArraySum ( arr , n ) ) ; } }"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program Java untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Jika saya adalah kuasa 2; Kod pemacu", "code": "class GFG { static int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . print ( highestPowerof2 ( n ) ) ; } }"}
{"text": "Cari Pasangan Cube | Tetapkan 2 (A N ^ (1/3) Penyelesaian) | Program Java untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Fungsi untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Cari akar kiub n; Buat pelbagai saiz saiz 'cuberoot'; Untuk indeks i, kiub [i] akan mengandungi i ^ 3; Cari semua pasangan di atas Array Cube di atas [] yang jumlahnya sama dengan N; Kod pemacu", "code": "import java . io . * ; class GFG { static void findPairs ( int n ) { int cubeRoot = ( int ) Math . pow ( n , 1.0 / 3.0 ) ; int cube [ ] = new int [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { System . out . println ( \" ( \" + l + \" , ▁ \" + r + \" ) \" ) ; l ++ ; r -- ; } } } public static void main ( String [ ] args ) { int n = 20683 ; findPairs ( n ) ; } }"}
{"text": "Cari Pasangan Cube | Tetapkan 1 (A N ^ (2/3) Penyelesaian) | Program Java untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Fungsi untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Cari akar kiub n; Buat peta kosong; Pertimbangkan semua pasangan seperti nilai kurang daripada cuberoot; Cari jumlah pasangan semasa (x, y); Jangan lakukan apa -apa jika jumlah tidak sama dengan nombor yang diberikan; Jika jumlahnya dilihat sebelum ini, kami mendapati dua pasang; Jika jumlahnya dilihat buat kali pertama; Kod pemacu", "code": "import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void findPairs ( int n ) { int cubeRoot = ( int ) Math . pow ( n , 1.0 / 3.0 ) ; HashMap < Integer , pair > s = new HashMap < Integer , pair > ( ) ; for ( int x = 1 ; x < cubeRoot ; x ++ ) { for ( int y = x + 1 ; y <= cubeRoot ; y ++ ) { int sum = x * x * x + y * y * y ; if ( sum != n ) continue ; if ( s . containsKey ( sum ) ) { System . out . print ( \" ( \" + s . get ( sum ) . first + \" , ▁ \" + s . get ( sum ) . second + \" ) ▁ and ▁ ( \" + x + \" , ▁ \" + y + \" ) \" + \"NEW_LINE\"); } else s . put ( sum , new pair ( x , y ) ) ; } } } public static void main ( String [ ] args ) { int n = 13832 ; findPairs ( n ) ; } }"}
{"text": "Cari perbezaan minimum antara jadual beralih dua nombor | Program Java untuk mencari perbezaan minimum antara dua syarat dua jadual; Fungsi utiliti untuk mencari GCD A dan B; Mengembalikan perbezaan minimum antara dua terma jadual beralih 'A' dan 'B'. 'X' adalah peralihan dalam jadual 'a' dan 'y' adalah peralihan dalam jadual 'b'. ; Hitung GCD Nd B; Kirakan perbezaan antara x dan y; Kod pemacu", "code": "import java . io . * ; class GFG { static int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; } static int findMinDiff ( int a , int b , int x , int y ) { int g = gcd ( a , b ) ; int diff = Math . abs ( x - y ) % g ; return Math . min ( diff , g - diff ) ; } public static void main ( String [ ] args ) { int a = 20 , b = 52 , x = 5 , y = 7 ; System . out . println ( findMinDiff ( a , b , x , y ) ) ; } }"}
{"text": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | A O (SQRT (N)) Program Java yang mencetak semua pembahagi dalam urutan yang disusun; kaedah untuk mencetak pembahagi; Vektor untuk menyimpan separuh daripada pembahagi; Semak jika pembahagi adalah sama; Tolak pembahagi kedua dalam vektor; Vektor akan dicetak secara terbalik; Kaedah Pemandu", "code": "import java . util . Vector ; class Test { static void printDivisors ( int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . printf ( \" % d ▁ \" , i ) ; else { System . out . printf ( \" % d ▁ \" , i ) ; v . add ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . printf ( \" % d ▁ \" , v . get ( i ) ) ; } public static void main ( String args [ ] ) { System . out . println ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ \" ) ; printDivisors ( 100 ) ; } }"}
{"text": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | Program O (sqrt (n)) yang mencetak semua pembahagi dalam urutan yang disusun; Berfungsi untuk mencetak pembahagi; Kod pemacu", "code": "import java . lang . Math ; class GFG { public static void printDivisors ( int n ) { int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) System . out . print ( i + \" ▁ \" ) ; } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) System . out . print ( n / i + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { System . out . println ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ \" ) ; printDivisors ( 100 ) ; } }"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | Pelaksanaan Java kaedah naif untuk mencetak semua pembahagi; kaedah untuk mencetak pembahagi; Kaedah Pemandu", "code": "class Test { static void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) System . out . print ( i + \" ▁ \" ) ; } public static void main ( String args [ ] ) { System . out . println ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ \" ) ; printDivisors ( 100 ) ; ; } }"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | Penyelesaian yang lebih baik (daripada naif) untuk mencari semua pembahagi; kaedah untuk mencetak pembahagi; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi adalah sama, cetak hanya satu; lain sebaliknya mencetak kedua -duanya; Kaedah Pemandu", "code": "class Test { static void printDivisors ( int n ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . print ( \" ▁ \" + i ) ; System . out . print ( i + \" ▁ \" + n / i + \" ▁ \" ) ; } } } public static void main ( String args [ ] ) { System . out . println ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ \" ) ; printDivisors ( 100 ) ; ; } }"}
{"text": "Sieve of Atkin | Program Java untuk pelaksanaan ayak Atkin; 2 dan 3 dikenali sebagai Perdana; Memulakan array penapis dengan nilai palsu; Mark Sieve [n] adalah benar jika salah satu daripada yang berikut adalah benar: a) n = (4 * x * x) + (y * y) mempunyai bilangan penyelesaian yang ganjil, i. e. , terdapat bilangan pasangan yang berbeza (x, y) yang memenuhi persamaan dan n % 12 = 1 atau n % 12 = 5. b) n = (3 * x * x) + (y * y) mempunyai bilangan penyelesaian yang ganjil dan n % 12 = 7 c) Bahagian utama SIEVE OF ATKIN; Tandakan semua gandaan dataran sebagai bukan perdana; Cetak prima menggunakan ayak []; Kod pemacu", "code": "class GFG { static int SieveOfAtkin ( int limit ) { if ( limit > 2 ) System . out . print ( 2 + \" ▁ \" ) ; if ( limit > 3 ) System . out . print ( 3 + \" ▁ \" ) ; boolean sieve [ ] = new boolean [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) System . out . print ( a + \" ▁ \" ) ; return 0 ; } public static void main ( String [ ] args ) { int limit = 20 ; SieveOfAtkin ( limit ) ; } }"}
{"text": "Cari jika titik terletak di dalam bulatan | Program Java untuk memeriksa sama ada titik terletak di dalam bulatan atau tidak; Bandingkan jejari bulatan dengan jarak pusatnya dari titik yang diberikan; Program pemacu untuk menguji fungsi di atas", "code": "class GFG { static boolean isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; } public static void main ( String arg [ ] ) { int x = 1 , y = 1 ; int circle_x = 0 , circle_y = 1 , rad = 2 ; if ( isInside ( circle_x , circle_y , rad , x , y ) ) System . out . print ( \" Inside \" ) ; else System . out . print ( \" Outside \" ) ; } }"}
{"text": "Cari semua kemungkinan hasil ekspresi yang diberikan | Program Java untuk menilai semua nilai ekspresi yang mungkin; Fungsi utiliti untuk menilai ungkapan mudah dengan satu pengendali sahaja. ; Fungsi ini menilai semua nilai yang mungkin dan mengembalikan senarai nilai yang dinilai. ; Untuk menyimpan hasil (semua kemungkinan penilaian ekspresi 'expr'); Sekiranya terdapat hanya satu watak, ia mestilah digit (atau operan), kembalikannya. ; Sekiranya terdapat hanya tiga aksara, pertengahan mestilah pengendali dan sudut mesti beroperasi; Setiap saya merujuk kepada pengendali; l merujuk kepada semua nilai yang mungkin di sebelah kiri pengendali 'expr [i]'; r merujuk kepada semua nilai yang mungkin di sebelah kanan pengendali 'expr [i]'; Ambil di atas menilai semua nilai yang mungkin di sebelah kiri 'I'; Ambil di atas menilai semua nilai yang mungkin di sebelah kanan 'I'; Kirakan nilai untuk setiap pasangan dan tambahkan nilai yang dihasilkan. ; Program Pemandu", "code": "import java . util . * ; class GFG { static int eval ( int a , char op , int b ) { if ( op == ' + ' ) { return a + b ; } if ( op == ' - ' ) { return a - b ; } if ( op == ' * ' ) { return a * b ; } return Integer . MAX_VALUE ; } static Vector < Integer > evaluateAll ( String expr , int low , int high ) { Vector < Integer > res = new Vector < Integer > ( ) ; if ( low == high ) { res . add ( expr . charAt ( low ) - '0' ) ; return res ; } if ( low == ( high - 2 ) ) { int num = eval ( expr . charAt ( low ) - '0' , expr . charAt ( low + 1 ) , expr . charAt ( low + 2 ) - '0' ) ; res . add ( num ) ; return res ; } for ( int i = low + 1 ; i <= high ; i += 2 ) { Vector < Integer > l = evaluateAll ( expr , low , i - 1 ) ; Vector < Integer > r = evaluateAll ( expr , i + 1 , high ) ; for ( int s1 = 0 ; s1 < l . size ( ) ; s1 ++ ) { for ( int s2 = 0 ; s2 < r . size ( ) ; s2 ++ ) { int val = eval ( l . get ( s1 ) , expr . charAt ( i ) , r . get ( s2 ) ) ; res . add ( val ) ; } } } return res ; } public static void main ( String [ ] args ) { String expr = \"1*2 + 3*4\" ; int len = expr . length ( ) ; Vector < Integer > ans = evaluateAll ( expr , 0 , len - 1 ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . println ( ans . get ( i ) ) ; } } }"}
{"text": "Program untuk memeriksa sama ada nombor tertentu bernasib baik (semua digit adalah berbeza) | Program Java untuk memeriksa sama ada nombor tertentu bernasib baik; Fungsi ini kembali benar jika n bernasib baik; Buat pelbagai saiz 10 dan mulakan semua elemen sebagai palsu. Arahan ini digunakan untuk memeriksa sama ada digit sudah dilihat atau tidak. ; Melintasi semua digit nombor yang diberikan; Cari digit terakhir; Jika digit sudah dilihat, kembali palsu; Tandakan digit ini seperti yang dilihat; Keluarkan digit terakhir dari nombor; Kod pemacu", "code": "class GFG { static boolean isLucky ( int n ) { boolean arr [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 1291 , 897 , 4566 , 1232 , 80 , 700 } ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) if ( isLucky ( arr [ i ] ) ) System . out . print ( arr [ i ] + \" is Lucky NEW_LINE\"); else System . out . print ( arr [ i ] + \" is not Lucky NEW_LINE\"); } }"}
{"text": "Cetak kotak pertama N Nombor Semulajadi tanpa menggunakan *, / dan | Program Java untuk mencetak dataran nombor semulajadi 'n' pertama tanpa menggunakan *, / dan -; Memulakan 'persegi' dan nombor ganjil pertama; Mengira dan mencetak kotak; Cetak dataran; Kemas kini 'persegi' dan 'ganjil'; Kod pemacu", "code": "import java . io . * ; class GFG { static void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + \" ▁ \" ) ; square = square + odd ; odd = odd + 2 ; } } public static void main ( String [ ] args ) { int n = 5 ; printSquares ( n ) ; } }"}
{"text": "Tulis program untuk membalikkan digit nombor | Fungsi rekursif untuk membalikkan digit NUM; Kod pemacu", "code": "class GFG { static int rev_num = 0 ; static int base_pos = 1 ; static int reversDigits ( int num ) { if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; } public static void main ( String [ ] args ) { int num = 4562 ; System . out . println ( reversDigits ( num ) ) ; } }"}
{"text": "Cari nombor sedemikian rupa sehingga maksimum dalam array adalah minimum mungkin selepas xor | Program Java yang mendapati maksimum maksimum minimum; Fungsi rekursif yang mencari nilai minimum selepas eksklusif - atau; Keadaan jika saiz ref adalah sifar atau bit adalah negatif maka kembali 0; Keadaan jika bit semasa dimatikan kemudian tolak nilai semasa dalam vektor curr_off; Keadaan jika bit semasa berada di kemudian tolak nilai semasa dalam vektor curr_on; Keadaan jika curr_off kosong maka hubungi fungsi rekursif pada vektor curr_on; Keadaan jika curr_on kosong maka hubungi fungsi rekursif pada vektor curr_off; Kembalikan minimum curr_off dan curr_on dan tambah kuasa 2 bit semasa; Fungsi yang mencetak nilai minimum selepas eksklusif - atau; Menolak nilai dalam vektor; Jawapan percetakan; Kod pemacu", "code": "import java . util . * ; class GFG { static int RecursiveFunction ( ArrayList < Integer > ref , int bit ) { if ( ref . size ( ) == 0 bit < 0 ) return 0 ; ArrayList < Integer > curr_on = new ArrayList < > ( ) ; ArrayList < Integer > curr_off = new ArrayList < > ( ) ; for ( int i = 0 ; i < ref . size ( ) ; i ++ ) { if ( ( ( ref . get ( i ) >> bit ) & 1 ) == 0 ) curr_off . add ( ref . get ( i ) ) ; else curr_on . add ( ref . get ( i ) ) ; } if ( curr_off . size ( ) == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ; if ( curr_on . size ( ) == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ; return Math . min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; } static void PrintMinimum ( int a [ ] , int n ) { ArrayList < Integer > v = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) v . add ( a [ i ] ) ; System . out . println ( RecursiveFunction ( v , 30 ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int size = arr . length ; PrintMinimum ( arr , size ) ; } }"}
{"text": "Count of Elements yang sama dengan XOR dari dua elemen berikutnya | Pelaksanaan Java pendekatan; Fungsi untuk mengembalikan kiraan elemen yang sama dengan XOR dari dua elemen berikutnya; Untuk menyimpan kiraan yang diperlukan; Untuk setiap elemen array supaya ia mempunyai sekurang -kurangnya dua elemen yang muncul selepas itu dalam array; Jika elemen semasa adalah sama dengan XOR dari dua elemen seterusnya dalam array; Kod pemacu", "code": "import java . io . * ; class GFG { static int cntElements ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 1 , 3 , 7 , 8 } ; int n = arr . length ; System . out . println ( cntElements ( arr , n ) ) ; } }"}
{"text": "Bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama | Program Java untuk mencari bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama; Berfungsi untuk mengembalikan kiraan; Hasil permulaan; Pilih unsur 1 triplet; Pilih elemen 2 nd triplet; Pilih 3 elemen triplet; Mengambil XOR dalam subarray pertama; Mengambil XOR dalam subarray kedua; Jika kedua -dua XOR adalah sama; Kod pemacu; Fungsi panggilan", "code": "class GFG { static int xor_triplet ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ; for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( xor_triplet ( arr , n ) ) ; } }"}
{"text": "Bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama | Program berasaskan Java Trie untuk mencari bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama; bilangan maksimum bit dalam integer <= 1E9; Struktur nod trie; [0] Indeks adalah bit 0 dan [1] indeks adalah bit 1; Jumlah indeks yang dimasukkan pada nod; Bilangan indeks yang dimasukkan pada nod; Pembina untuk memulakan nod yang baru dibuat; Berfungsi untuk memasukkan curr_xor ke dalam trie; Melangkah dari bit 31 ke bit ke -0 bit curr_xor; Semak sama ada bit semasa ditetapkan atau tidak; Sekiranya nod ini tidak ada dalam struktur trie masukkannya ke dalam trie. ; Meningkatkan jumlah indeks dengan nilai indeks semasa; Meningkatkan bilangan indeks sebanyak 1; Fungsi untuk memeriksa sama ada curr_xor hadir dalam trie atau tidak; Melangkah dari bit 31 ke bit ke -0 bit curr_xor; Semak sama ada bit semasa ditetapkan atau tidak; Sekiranya nod ini tidak ada dalam struktur trie yang bermaksud tidak ada sub array sehingga indeks semasa mempunyai 0 xor jadi pulangan 0; Kirakan bilangan indeks yang dimasukkan pada nod akhir; Kirakan jumlah indeks yang dimasukkan pada nod akhir; Berfungsi untuk mengembalikan kiraan tiga kali ganda yang sah; Untuk menyimpan XOR kumulatif; Akar trie; Masukkan curr_xor dalam trie; Kemas kini XOR kumulatif; Semak sama ada XOR kumulatif hadir dalam trie atau tidak jika hadir kemudian tambah (SZ * index) - jumlah; Kod pemacu; Diberikan array", "code": "class GFG { static int lg = 31 ; static class TrieNode { TrieNode children [ ] ; int sum_of_indexes ; int number_of_indexes ; TrieNode ( ) { children = new TrieNode [ 2 ] ; this . children [ 0 ] = null ; this . children [ 1 ] = null ; this . sum_of_indexes = 0 ; this . number_of_indexes = 0 ; } } ; static void insert ( TrieNode node , int num , int index ) { for ( int bits = lg ; bits >= 0 ; bits -- ) { int curr_bit = ( num >> bits ) & 1 ; if ( node . children [ curr_bit ] == null ) { node . children [ curr_bit ] = new TrieNode ( ) ; } node = node . children [ curr_bit ] ; } node . sum_of_indexes += index ; node . number_of_indexes ++ ; } static int query ( TrieNode node , int num , int index ) { for ( int bits = lg ; bits >= 0 ; bits -- ) { int curr_bit = ( num >> bits ) & 1 ; if ( node . children [ curr_bit ] == null ) { return 0 ; } node = node . children [ curr_bit ] ; } int sz = node . number_of_indexes ; int sum = node . sum_of_indexes ; int ans = ( sz * index ) - ( sum ) ; return ans ; } static int no_of_triplets ( int arr [ ] , int n ) { int curr_xor = 0 ; int number_of_triplets = 0 ; TrieNode root = new TrieNode ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; insert ( root , curr_xor , i ) ; curr_xor ^= x ; number_of_triplets += query ( root , curr_xor , i ) ; } return number_of_triplets ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 2 , 7 } ; int n = arr . length ; System . out . println ( no_of_triplets ( arr , n ) ) ; } }"}
{"text": "Cari bilangan sepasang nod yang ideal di pokok tertentu | Pelaksanaan Java pendekatan; Senarai Adjacency; Bit: Bit Array I dan J memulakan dan menamatkan indeks termasuk; bit: array bit n: saiz array bit i adalah indeks yang akan dikemas kini diff adalah (new_val - old_val); Fungsi DFS untuk mencari pasangan yang ideal; Fungsi untuk inisialisasi; Berfungsi untuk menambah kelebihan; Berfungsi untuk mencari bilangan pasangan yang ideal; Cari akar pokok; Kod pemacu; Tambah tepi; Panggilan fungsi", "code": "import java . util . * ; class GFG { static final int N = 100005 ; static int n , k ; @ SuppressWarnings ( \" unchecked \" ) static Vector < Integer > [ ] al = new Vector [ N ] ; static long Ideal_pair ; static long [ ] bit = new long [ N ] ; static boolean [ ] root_node = new boolean [ N ] ; static long bit_q ( int i , int j ) { long sum = 0 ; while ( j > 0 ) { sum += bit [ j ] ; j -= ( j & ( j * - 1 ) ) ; } i -- ; while ( i > 0 ) { sum -= bit [ i ] ; i -= ( i & ( i * - 1 ) ) ; } return sum ; } static void bit_up ( int i , long diff ) { while ( i <= n ) { bit [ i ] += diff ; i += i & - i ; } } static void dfs ( int node ) { Ideal_pair += bit_q ( Math . max ( 1 , node - k ) , Math . min ( n , node + k ) ) ; bit_up ( node , 1 ) ; for ( int i = 0 ; i < al [ node ] . size ( ) ; i ++ ) dfs ( al [ node ] . get ( i ) ) ; bit_up ( node , - 1 ) ; } static void initialise ( ) { Ideal_pair = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { root_node [ i ] = true ; bit [ i ] = 0 ; } } static void Add_Edge ( int x , int y ) { al [ x ] . add ( y ) ; root_node [ y ] = false ; } static long Idealpairs ( ) { int r = - 1 ; for ( int i = 1 ; i <= n ; i ++ ) if ( root_node [ i ] ) { r = i ; break ; } dfs ( r ) ; return Ideal_pair ; } public static void main ( String [ ] args ) { n = 6 ; k = 3 ; for ( int i = 0 ; i < al . length ; i ++ ) al [ i ] = new Vector < Integer > ( ) ; initialise ( ) ; Add_Edge ( 1 , 2 ) ; Add_Edge ( 1 , 3 ) ; Add_Edge ( 3 , 4 ) ; Add_Edge ( 3 , 5 ) ; Add_Edge ( 3 , 6 ) ; System . out . print ( Idealpairs ( ) ) ; } }"}
{"text": "Cetak bitwise dan set nombor n | Program Java untuk mencetak semua subset bitwise N (pendekatan yang cekap); berfungsi untuk mencari pendekatan yang cekap subset bitwise; Kod pemacu", "code": "class GFG { static void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) System . out . print ( i + \" ▁ \" ) ; System . out . print ( \" ▁ 0 ▁ \" ) ; } public static void main ( String [ ] args ) { int n = 9 ; printSubsets ( n ) ; } }"}
{"text": "Semak jika nombor dibahagikan dengan 17 menggunakan pengendali bitwise | Program Java untuk memeriksa sama ada nombor dibahagikan dengan 17 atau tidak menggunakan pengendali Bitwise. ; fungsi untuk memeriksa secara rekursif jika nombor itu boleh dibahagikan dengan 17 atau tidak; jika n = 0 atau n = 17 maka ya; jika n kurang dari 17, tidak boleh dibahagikan dengan 17; mengurangkan nombor mengikut lantai (n / 16) - n % 16; fungsi pemacu", "code": "class GFG { static boolean isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; } public static void main ( String [ ] args ) { int n = 35 ; if ( isDivisibleby17 ( n ) == true ) System . out . printf ( \" % d ▁ is ▁ divisible ▁ by ▁ 17\" , n ) ; else System . out . printf ( \" % d ▁ is ▁ not ▁ divisible ▁ by ▁ 17\" , n ) ; } }"}
{"text": "Nombor terbesar dengan perwakilan binari ialah M 1 dan M | Program Java untuk mencari bilangan terbesar yang lebih kecil daripada sama dengan N dengan set bit M - 1 0 bit. ; Mengembalikan nombor terbesar dengan bit set M kemudian m - 1 0 bit. ; Mulakan dengan 2 bit. ; Jawapan awal adalah 1 yang memenuhi syarat yang diberikan; Semak semua nombor; mengira nombor; jika kurang kemudian n; kenaikan m untuk mendapatkan nombor seterusnya; Kod pemacu", "code": "public class GFG { static long answer ( long n ) { long m = 2 ; long ans = 1 ; long r = 1 ; while ( r < n ) { r = ( ( long ) Math . pow ( 2 , m ) - 1 ) * ( ( long ) Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; } public static void main ( String args [ ] ) { long n = 7 ; System . out . println ( answer ( n ) ) ; } }"}
{"text": "Cari bit set yang paling ketara | Program Java Mudah untuk mencari nombor MSB untuk diberikan n. ; Kod pemacu", "code": "import java . io . * ; class GFG { static int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; } public static void main ( String [ ] args ) { int n = 0 ; System . out . println ( setBitNumber ( n ) ) ; } }"}
{"text": "Cari bit set yang paling ketara | Program Java untuk mencari nombor MSB untuk diberikan n. ; Katakan N ialah 273 (binari ialah 100010001). Ia mengikuti 100010001 | 010001000 = 110011001; Ini memastikan 4 bit (dari MSB dan termasuk MSB) ditetapkan. Ia mengikuti 110011001 | 001100110 = 111111111; Kenaikan n oleh 1 supaya hanya ada satu set bit yang hanya sebelum MSB asal. n kini menjadi 1000000000; Kembalikan MSB asal selepas beralih. n kini menjadi 100000000; Kod pemacu", "code": "class GFG { static int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; } public static void main ( String arg [ ] ) { int n = 273 ; System . out . print ( setBitNumber ( n ) ) ; } }"}
{"text": "Count Trailing Zero Bits Menggunakan Table Lookup | Kod Java mudah untuk mengira sifar trailing dalam perwakilan binari nombor; Kod pemacu", "code": "import java . io . * ; class GFG { public static int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; } public static void main ( String [ ] args ) { System . out . println ( countTrailingZero ( 11 ) ) ; } }"}
{"text": "Count Trailing Zero Bits Menggunakan Table Lookup | Kod Java untuk mengira sifar trailing dalam perwakilan binari nombor; Peta sedikit nilai mod 37 ke kedudukannya; Hanya perbezaan antara (x dan - x) ialah nilai magnitud yang ditandatangani (leftmostbit) nombor negatif yang ditandatangani adalah 1; Kod pemacu", "code": "import java . io . * ; class GFG { static int countTrailingZero ( int x ) { int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; } public static void main ( String [ ] args ) { System . out . println ( countTrailingZero ( 48 ) ) ; } }"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | Program Java untuk menilai Ceil (7 n / 8) tanpa menggunakan * dan; Perhatikan pendakap dalaman di sini. Ini diperlukan kerana keutamaan pengendali ' -' lebih tinggi daripada '<'; Kod pemacu", "code": "import java . io . * ; class GFG { static int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; } public static void main ( String args [ ] ) { int n = 9 ; System . out . println ( multiplyBySevenByEight ( n ) ) ; } }"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | Program Java untuk menilai 7 N / 8 tanpa menggunakan * dan /; Langkah 1) Pertama kali ganda nombor dengan 7 i. e. 7 n = (n << 3) - n * Langkah 2) Bahagikan hasil sebanyak 8; Program Pemandu", "code": "import java . io . * ; class GFG { static int multiplyBySevenByEight ( int n ) { return ( ( n << 3 ) - n ) >> 3 ; } public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( multiplyBySevenByEight ( n ) ) ; } }"}
{"text": "Set nombor palindrome terpanjang dari julat [l, r] dengan kebanyakan perbezaan k antara maksimum dan minimum | Program Java untuk pendekatan di atas; Berfungsi untuk mencari saiz maksimum kumpulan nombor palindrome yang mempunyai perbezaan antara elemen maksimum dan minimum paling banyak k; Menyimpan semua nombor palindromik dalam julat [l, r]; Melintasi julat [l, r]; Jika saya adalah palindrome; Tambah nombor dalam senarai; Kedai kiraan nombor palindromik maksimum; Melelehkan setiap elemen dalam senarai; Kirakan indeks paling kanan dalam senarai <elemen semasa + k; Semak jika terdapat indeks paling kanan dari indeks semasa; Mengembalikan kiraan; Berfungsi untuk mencari indeks paling kanan nombor yang diberikan; Simpan indeks paling kanan; Hitung pertengahan; Jika diberi nombor <= num; Berikan Ans = Mid; Mengemas kini rendah; Mengemas kini tinggi; kembali Ans; Fungsi untuk memeriksa sama ada nombor yang diberikan adalah palindrome atau tidak; Menjana terbalik nombor yang diberikan; Jika n adalah palindrome; Kod pemacu", "code": "import java . util . * ; public class Main { static int countNumbers ( int L , int R , int K ) { ArrayList < Integer > list = new ArrayList < > ( ) ; for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) ) { list . add ( i ) ; } } int count = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { int right_index = search ( list , list . get ( i ) + K - 1 ) ; if ( right_index != - 1 ) count = Math . max ( count , right_index - i + 1 ) ; } return count ; } static int search ( ArrayList < Integer > list , int num ) { int low = 0 , high = list . size ( ) - 1 ; int ans = - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( list . get ( mid ) <= num ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } static boolean isPalindrome ( int n ) { int rev = 0 ; int temp = n ; while ( n > 0 ) { rev = rev * 10 + n % 10 ; n /= 10 ; } return rev == temp ; } public static void main ( String args [ ] ) { int L = 98 , R = 112 ; int K = 13 ; System . out . print ( countNumbers ( L , R , K ) ) ; } }"}
{"text": "Memaksimumkan jumlah yang mungkin dengan menolak nilai yang sama dari semua elemen subarray array yang diberikan | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari jumlah maksimum dengan menolak nilai yang sama dari semua elemen subarray; Kedai elemen yang lebih kecil sebelumnya; Kedai elemen yang lebih kecil seterusnya; Mengira sumbangan setiap elemen; Jawapan kembali; Berfungsi untuk menjana elemen yang lebih kecil sebelumnya untuk setiap elemen array; Unsur pertama tidak mempunyai lebih kecil sebelumnya; Tumpukan untuk menjejaki unsur -unsur yang telah berlaku sebelum ini; Tolak indeks pertama; Pop semua elemen sehingga elemen sebelumnya lebih kecil daripada elemen semasa; Simpan elemen yang lebih kecil sebelumnya; Tolak indeks elemen semasa; Mengembalikan array; Berfungsi untuk menjana elemen yang lebih kecil seterusnya untuk setiap elemen array; Tumpukan untuk menjejaki unsur -unsur yang telah berlaku seterusnya; Melangkah dalam urutan terbalik untuk mengira lebih kecil seterusnya; Pop semua elemen sehingga elemen seterusnya lebih kecil daripada elemen semasa; Simpan elemen yang lebih kecil seterusnya; Tolak indeks elemen semasa; Mengembalikan array; Kod pemacu", "code": "import java . util . * ; public class GFG { public static int findMaximumSum ( int [ ] a , int n ) { int prev_smaller [ ] = findPrevious ( a , n ) ; int next_smaller [ ] = findNext ( a , n ) ; int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_value = Math . max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; } return max_value ; } public static int [ ] findPrevious ( int [ ] a , int n ) { int ps [ ] = new int [ n ] ; ps [ 0 ] = - 1 ; Stack < Integer > stack = new Stack < > ( ) ; stack . push ( 0 ) ; for ( int i = 1 ; i < a . length ; i ++ ) { while ( stack . size ( ) > 0 && a [ stack . peek ( ) ] >= a [ i ] ) stack . pop ( ) ; ps [ i ] = stack . size ( ) > 0 ? stack . peek ( ) : - 1 ; stack . push ( i ) ; } return ps ; } public static int [ ] findNext ( int [ ] a , int n ) { int ns [ ] = new int [ n ] ; ns [ n - 1 ] = n ; Stack < Integer > stack = new Stack < > ( ) ; stack . push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( stack . size ( ) > 0 && a [ stack . peek ( ) ] >= a [ i ] ) stack . pop ( ) ; ns [ i ] = stack . size ( ) > 0 ? stack . peek ( ) : a . length ; stack . push ( i ) ; } return ns ; } public static void main ( String args [ ] ) { int n = 3 ; int a [ ] = { 80 , 48 , 82 } ; System . out . println ( findMaximumSum ( a , n ) ) ; } }"}
{"text": "Semak jika rentetan yang diberikan disalurkan substring rentetan lain | Fungsi ini kembali benar jika kandungan ARR1 [] dan ARR2 [] sama, jika tidak palsu. ; Fungsi ini mencari semua permutasi pat [] dalam txt []; Countp []: Simpan kiraan semua aksara corak counttw []: kiraan kiraan tetingkap semasa teks; Melintasi watak corak yang tersisa; Bandingkan tuduhan tetingkap semasa teks dengan tuduhan corak []; Tambah aksara semasa ke tetingkap semasa; Keluarkan watak pertama tetingkap sebelumnya; Periksa tetingkap terakhir dalam teks; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean compare ( int [ ] arr1 , int [ ] arr2 ) { for ( int i = 0 ; i < 256 ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } static boolean search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int [ ] countP = new int [ 256 ] ; int [ ] countTW = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; i ++ ) { countP [ i ] = 0 ; countTW [ i ] = 0 ; } for ( int i = 0 ; i < M ; i ++ ) { ( countP [ pat . charAt ( i ) ] ) ++ ; ( countTW [ txt . charAt ( i ) ] ) ++ ; } for ( int i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) return true ; ( countTW [ txt . charAt ( i ) ] ) ++ ; countTW [ txt . charAt ( i - M ) ] -- ; } if ( compare ( countP , countTW ) ) return true ; return false ; } public static void main ( String [ ] args ) { String txt = \" BACDGABCDA \" ; String pat = \" ABCD \" ; if ( search ( pat , txt ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text": "Memaksimumkan median array yang diberikan selepas menambahkan elemen K ke array yang sama | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan median yang dimaksimumkan; Susun array; Jika saiznya juga; Jika saiz ganjil; Kod pemacu", "code": "import java . util . * ; class GFG { static double getMaxMedian ( int [ ] arr , int n , int k ) { int size = n + k ; Arrays . sort ( arr ) ; if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } double median1 = arr [ size / 2 ] ; return median1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 3 , 4 , 2 } ; int n = arr . length ; int k = 2 ; System . out . print ( ( int ) getMaxMedian ( arr , n , k ) ) ; } }"}
{"text": "Susun 3 Integer Tanpa Menggunakan Keadaan atau Menggunakan Hanya Maksimum () Fungsi | Program Java untuk mencetak tiga nombor dalam susunan yang disusun menggunakan fungsi max; Cari elemen maksimum; Cari elemen minimum; Kod pemacu", "code": "class GFG { static void printSorted ( int a , int b , int c ) { int get_max = Math . max ( a , Math . max ( b , c ) ) ; int get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . print ( get_min + \" ▁ \" + get_mid + \" ▁ \" + get_max ) ; } public static void main ( String [ ] args ) { int a = 4 , b = 1 , c = 9 ; printSorted ( a , b , c ) ; } }"}
{"text": "Jenis penyisipan binari | pelaksanaan berulang; Berfungsi untuk menyusun array [] saiz 'n'; Cari lokasi di mana dipilih haruslah inseretd; Gerakkan semua elemen selepas lokasi untuk mewujudkan ruang; Kod pemacu", "code": "import java . io . * ; class GFG { static int binarySearch ( int a [ ] , int item , int low , int high ) { while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; } static void insertionSort ( int a [ ] , int n ) { int i , loc , j , k , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ; loc = binarySearch ( a , selected , 0 , j ) ; while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } } public static void main ( String [ ] args ) { int a [ ] = { 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 } ; int n = a . length , i ; insertionSort ( a , n ) ; System . out . println ( \" Sorted ▁ array : \" ) ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + \" ▁ \" ) ; } }"}
{"text": "SENARAI SENSI | Program Java untuk pelaksanaan jenis penyisipan; Fungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi utiliti untuk mencetak pelbagai saiz n; Kaedah Pemandu", "code": "class InsertionSort { void sort ( int arr [ ] ) { int n = arr . length ; for ( int i = 1 ; i < n ; ++ i ) { int key = arr [ i ] ; int j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } static void printArray ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + \" ▁ \" ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; InsertionSort ob = new InsertionSort ( ) ; ob . sort ( arr ) ; printArray ( arr ) ; } }"}
{"text": "Count Permutasi yang berbeza dari rentetan yang diperoleh dengan menukar hanya aksara yang tidak sama rata | Mengimport kelas hashmap; Fungsi untuk mengira jumlah bilangan permutasi yang sah; Mewujudkan kiraan yang sama dengan jumlah aksara yang hadir dan ANS yang akan menyimpan bilangan permutasi yang unik; Menyimpan kekerapan setiap watak yang ada dalam rentetan; Menambah kiraan aksara dengan tidak termasuk aksara sama dengan char semasa; Kurangkan kekerapan aksara semasa dan dikira sebanyak 1, supaya ia tidak dapat mengganggu pengiraan unsur -unsur yang sama ada di sebelah kanannya. ; Kembalikan ANS + 1 (kerana rentetan yang diberikan juga merupakan permutasi yang unik)", "code": "import java . util . HashMap ; class GFG { static int validPermutations ( String str ) { HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; int count = str . length ( ) , ans = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m . put ( str . charAt ( i ) , m . getOrDefault ( str . charAt ( i ) , 0 ) + 1 ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ans += count - m . get ( str . charAt ( i ) ) ; m . put ( str . charAt ( i ) , m . get ( str . charAt ( i ) ) - 1 ) ; count -- ; } return ans + 1 ; } public static void main ( String [ ] args ) { String str = \" sstt \" ; System . out . println ( validPermutations ( str ) ) ; } }"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Program Java untuk mengira jumlah laluan dari titik ke asal; Fungsi berasaskan DP untuk mengira bilangan laluan; Isi penyertaan dalam Bottommost Row dan lajur paling kiri; Isi DP dengan cara bawah; Kod pemacu", "code": "import java . io . * ; class GFG { static int countPaths ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( \" ▁ Number ▁ of ▁ Paths ▁ \" + countPaths ( n , m ) ) ; } }"}
{"text": "Perubahan duit syiling | DP | Program Java Rekursif untuk masalah perubahan duit syiling. ; Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Kod pemacu", "code": "import java . util . * ; class GFG { static int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 } ; int m = arr . length ; System . out . println ( count ( arr , m , 4 ) ) ; } }"}
{"text": "Perubahan duit syiling | DP | Program Java untuk pendekatan di atas; Sama ada memilih duit syiling ini atau tidak; lain kita tidak mempunyai pilihan tetapi meninggalkan duit syiling ini; Kod pemacu", "code": "import java . util . * ; class GFG { static int coinchange ( int [ ] a , int v , int n , int [ ] [ ] dp ) { if ( v == 0 ) return dp [ n ] [ v ] = 1 ; if ( n == 0 ) return 0 ; if ( dp [ n ] [ v ] != - 1 ) return dp [ n ] [ v ] ; if ( a [ n - 1 ] <= v ) { return dp [ n ] [ v ] = coinchange ( a , v - a [ n - 1 ] , n , dp ) + coinchange ( a , v , n - 1 , dp ) ; } return dp [ n ] [ v ] = coinchange ( a , v , n - 1 , dp ) ; } public static void main ( String [ ] args ) { int tc = 1 ; while ( tc != 0 ) { int n , v ; n = 3 ; v = 4 ; int [ ] a = { 1 , 2 , 3 } ; int [ ] [ ] dp = new int [ n + 1 ] [ v + 1 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; int res = coinchange ( a , v , n , dp ) ; System . out . println ( res ) ; tc -- ; } } }"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; Tukar ke huruf kecil menggunakan fungsi ToUppercase; Membandingkan kedua -dua menggunakan fungsi terbina; Jika rentetan adalah sama, kembali benar sebaliknya palsu; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "class GFG { static boolean equalIgnoreCase ( String str1 , String str2 ) { int i = 0 ; str1 = str1 . toUpperCase ( ) ; str2 = str2 . toUpperCase ( ) ; int x = str1 . compareTo ( str2 ) ; if ( x != 0 ) { return false ; } else { return true ; } } static void equalIgnoreCaseUtil ( String str1 , String str2 ) { boolean res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) { System . out . println ( \" Same \" ) ; } else { System . out . println ( \" Not ▁ Same \" ) ; } } public static void main ( String [ ] args ) { String str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; } }"}
{"text": "Gantikan setiap urutan konsonan dengan panjangnya dalam rentetan yang diberikan | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan rentetan yang ditukar selepas menggantikan setiap urutan konsonan dengan panjangnya; Untuk menyimpan rentetan yang dihasilkan; Memeriksa setiap watak untuk urutan konsonan; Hitung panjang urutan konsonan; Tambah panjang dalam rentetan; Tambah vokal; Semak urutan konsonan terakhir dalam rentetan; Kembali rentetan yang dihasilkan; Kod pemacu", "code": "import java . util . * ; import java . lang . * ; class GFG { static String replaceConsonants ( String str ) { String res = \" \" ; int i = 0 , count = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) != ' a ' && str . charAt ( i ) != ' e ' && str . charAt ( i ) != ' i ' && str . charAt ( i ) != ' o ' && str . charAt ( i ) != ' u ' ) { i ++ ; count ++ ; } else { if ( count > 0 ) res += count ; res += str . charAt ( i ) ; i ++ ; count = 0 ; } } if ( count > 0 ) res += count ; return res ; } public static void main ( String [ ] args ) { String str = \" abcdeiop \" ; System . out . println ( replaceConsonants ( str ) ) ; } }"}
{"text": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | Program Java untuk menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam setiap substring saiz k; isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan dtring; untuk setiap substring; substring saiz k; mengira bilangan vokal dan konsonan; tambah produk untuk dijawab. ; Program yang didorong", "code": "class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } static String encryptString ( String s , int n , int k ) { int countVowels = 0 ; int countConsonants = 0 ; String ans = \" \" ; for ( int l = 0 ; l <= n - k ; l ++ ) { countVowels = 0 ; countConsonants = 0 ; for ( int r = l ; r <= l + k - 1 ; r ++ ) { if ( isVowel ( s . charAt ( r ) ) == true ) { countVowels ++ ; } else { countConsonants ++ ; } } ans += String . valueOf ( countVowels * countConsonants ) ; } return ans ; } static public void main ( String [ ] args ) { String s = \" hello \" ; int n = s . length ( ) ; int k = 2 ; System . out . println ( encryptString ( s , n , k ) ) ; } }"}
{"text": "String yang mengandungi huruf pertama setiap perkataan dalam rentetan yang diberikan dengan ruang | Pelaksanaan Java pendekatan di atas; Kami memisahkan input berdasarkan ruang (s) +: ungkapan biasa ini akan mengendalikan senario di mana kami mempunyai kata -kata yang dipisahkan oleh pelbagai ruang; Charat (0) hanya akan memilih watak pertama dari rentetan dan tambahan ke penampan; fungsi utama", "code": "class GFG { private static StringBuilder charBuffer = new StringBuilder ( ) ; public static String processWords ( String input ) { String s [ ] = input . split ( \" ( \\\\ s ) + \" ) ; for ( String values : s ) { charBuffer . append ( values . charAt ( 0 ) ) ; } return charBuffer . toString ( ) ; } public static void main ( String [ ] args ) { String input = \" geeks ▁ for TABSYMBOL geeks ▁ geeks TABSYMBOL for ▁ geeks \" ; System . out . println ( processWords ( input ) ) ; } }"}
{"text": "Menjana semua rentetan binari tanpa berturut -turut 1 's | Program Java untuk menjana semua rentetan binari tanpa saiz Kekekulasi 1 K; Penukaran array ke rentetan -; Keadaan asas apabila kami sampai pada akhir array * *; Mencetak rentetan yang dihasilkan * * kembali ke kes sebelumnya *; Jika watak pertama adalah sifar maka menambah * *; Jika watak itu adalah satu maka tambah sifar ke seterusnya * *; Memanggil secara rekursif untuk nilai berikutnya; Memulakan watak pertama kepada sifar; Menjana rentetan bermula dengan sifar -; Watak pertama yang dimulakan untuk satu -; Memanggil fungsi keseronokan dengan argumen k; Kod ini disumbangkan oleh Praveen Tiwari", "code": "import java . util . * ; import java . lang . * ; public class BinaryS { public static String toString ( char [ ] a ) { String string = new String ( a ) ; return string ; } static void generate ( int k , char [ ] ch , int n ) { if ( n == k ) { System . out . print ( toString ( ch ) + \" ▁ \" ) ; return ; } if ( ch [ n - 1 ] == '0' ) { ch [ n ] = '0' ; generate ( k , ch , n + 1 ) ; ch [ n ] = '1' ; generate ( k , ch , n + 1 ) ; } if ( ch [ n - 1 ] == '1' ) { ch [ n ] = '0' ; generate ( k , ch , n + 1 ) ; } } static void fun ( int k ) { if ( k <= 0 ) { return ; } char [ ] ch = new char [ k ] ; ch [ 0 ] = '0' ; generate ( k , ch , 1 ) ; ch [ 0 ] = '1' ; generate ( k , ch , 1 ) ; } public static void main ( String args [ ] ) { int k = 3 ; fun ( k ) ; } }"}
{"text": "Silinder bulat kanan terbesar dalam kiub | Program Java untuk mencari silinder pekeliling kanan terbesar yang boleh sesuai dalam kiub; Berfungsi untuk mencari silinder bulat kanan terbesar; sisi tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "import java . io . * ; class GFG { static float findVolume ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; float h = a ; float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . print ( findVolume ( a ) ) ; } }"}
{"text": "Program untuk jumlah piramid | Program Java untuk jumlah piramid. ; Berfungsi untuk mencari jumlah piramid segi tiga; Berfungsi untuk mencari jumlah piramid persegi; Berfungsi untuk mencari jumlah piramid pentagonal; Berfungsi untuk mencari jumlah piramid heksagon; Kod pemacu", "code": "import java . util . * ; import java . lang . * ; class GfG { public static float volumeTriangular ( int a , int b , int h ) { float vol = ( float ) ( 0.1666 ) * a * b * h ; return vol ; } public static float volumeSquare ( int b , int h ) { float vol = ( float ) ( 0.33 ) * b * b * h ; return vol ; } public static float volumePentagonal ( int a , int b , int h ) { float vol = ( float ) ( 0.83 ) * a * b * h ; return vol ; } public static float volumeHexagonal ( int a , int b , int h ) { float vol = ( float ) a * b * h ; return vol ; } public static void main ( String argc [ ] ) { int b = 4 , h = 9 , a = 4 ; System . out . println ( \" Volume ▁ of ▁ triangular \" + \" ▁ base ▁ pyramid ▁ is ▁ \" + volumeTriangular ( a , b , h ) ) ; System . out . println ( \" Volume ▁ of ▁ square ▁ base \" + \" ▁ pyramid ▁ is ▁ \" + volumeSquare ( b , h ) ) ; System . out . println ( \" Volume ▁ of ▁ pentagonal \" + \" ▁ base ▁ pyramid ▁ is ▁ \" + volumePentagonal ( a , b , h ) ) ; System . out . println ( \" Volume ▁ of ▁ Hexagonal \" + \" ▁ base ▁ pyramid ▁ is ▁ \" + volumeHexagonal ( a , b , h ) ) ; } }"}
{"text": "Program untuk mencari kawasan trapezoid | Program Java untuk mengira kawasan trapezoid; Fungsi untuk kawasan tersebut; Kod pemacu", "code": "import java . io . * ; class GFG { static double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; } public static void main ( String [ ] args ) { int base1 = 8 , base2 = 10 , height = 6 ; double area = Area ( base1 , base2 , height ) ; System . out . println ( \" Area ▁ is : ▁ \" + area ) ; } }"}
{"text": "Cari bilangan pepenjuru dalam polygon cembung N sisi | Fungsi Java untuk mencari bilangan pepenjuru dalam poligon cembung N; kod pemacu untuk menguji fungsi di atas", "code": "public class Diagonals { static int numberOfDiagonals ( int n ) { return n * ( n - 3 ) / 2 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( n + \" ▁ sided ▁ convex ▁ polygon ▁ have ▁ \" ) ; System . out . println ( numberOfDiagonals ( n ) + \" ▁ diagonals \" ) ; } }"}
{"text": "Kawasan segi empat tepat terbesar tanpa titik tertentu | Pelaksanaan Java untuk mencari kawasan segi empat tepat terbesar tanpa lubang dalam segi empat tepat; Berfungsi untuk mencari kawasan maksimum supaya ia tidak mengandungi sebarang lubang; Kawasan untuk semua kedudukan yang mungkin dipotong; Cari kawasan maksimum di antara segi empat tepat di atas; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; System . out . print ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; } public static void main ( String [ ] args ) { int L = 8 , B = 8 ; int X = 0 , Y = 0 ; maximumArea ( L , B , X , Y ) ; } }"}
{"text": "Kurangkan kos penyingkiran yang diperlukan untuk menjadikan semua watak yang tersisa dari rentetan unik | Program Java untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mengeluarkan aksara untuk membuat rentetan unik; Simpan kos minimum yang diperlukan; Buat kamus untuk menyimpan kos maksimum penyingkiran watak; Buat kamus untuk menyimpan jumlah kos penghapusan watak; Melintasi rentetan, s; Jejaki kos maksimum setiap watak; Mengemas kini kos penghapusan maksimum; Jejaki jumlah kos setiap watak; Mengemas kini jumlah kos penghapusan; Melintasi semua watak yang unik; Simpan watak kos maksimum dan padamkan selebihnya; Kembalikan jawapannya; Kod pemacu; Diberikan rentetan; Diberikan pelbagai kos; Panggilan fungsi", "code": "import java . util . * ; public class GFG { static int delCost ( String s , int [ ] cost ) { int ans = 0 ; HashMap < Character , Integer > forMax = new HashMap < > ( ) ; HashMap < Character , Integer > forTot = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! forMax . containsKey ( s . charAt ( i ) ) ) { forMax . put ( s . charAt ( i ) , cost [ i ] ) ; } else { forMax . put ( s . charAt ( i ) , Math . max ( cost [ i ] , forMax . get ( s . charAt ( i ) ) ) ) ; } if ( ! forTot . containsKey ( s . charAt ( i ) ) ) { forTot . put ( s . charAt ( i ) , cost [ i ] ) ; } else { forTot . put ( s . charAt ( i ) , forTot . get ( s . charAt ( i ) ) + cost [ i ] ) ; } } for ( Map . Entry < Character , Integer > i : forMax . entrySet ( ) ) { ans += forTot . get ( i . getKey ( ) ) - i . getValue ( ) ; } return ans ; } public static void main ( String [ ] args ) { String s = \" AAABBB \" ; int [ ] cost = { 1 , 2 , 3 , 4 , 5 , 6 } ; System . out . println ( delCost ( s , cost ) ) ; } }"}
{"text": "Pembahagi terkecil n paling dekat dengan x | Program Java untuk pendekatan di atas; Tentukan makro; Kedai pembahagi untuk semua nombor dalam pembahagi vektor; Saya adalah pembahagi dan j adalah pelbagai; Fungsi untuk membandingkan kedekatan sasaran yang diberikan; Berfungsi untuk mencari elemen yang paling dekat dengan sasaran dalam vektor pembahagi; Kes sudut; Melakukan carian binari; Semak sama ada sasaran kurang daripada elemen array kemudian cari di separuh kiri; Semak sama ada sasaran lebih besar daripada sebelumnya hingga pertengahan, kembali paling dekat dengan dua; Ulangi separuh kiri; Semak sama ada sasaran lebih besar daripada pertengahan; Kemas kini i; Hanya elemen tunggal yang tersisa selepas carian; Berfungsi untuk mencetak pembahagi n paling dekat dengan x; Fungsi panggilan untuk mengira dan menyimpan pembahagi semua nombor dalam vektor; Menyimpan nilai terdekat untuk sasaran; Cetak jawapannya; Kod pemacu; Diberikan N & X; Panggilan fungsi", "code": "import java . util . * ; class GFG { static final int MAX = 10000 ; static Vector < Integer > [ ] divisors = new Vector [ MAX + 1 ] ; static void computeDivisors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) { divisors [ j ] . add ( i ) ; } } } static int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } static int findClosest ( Vector < Integer > array , int n , int target ) { Integer [ ] arr = array . toArray ( new Integer [ array . size ( ) ] ) ; if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } static void printClosest ( int N , int X ) { computeDivisors ( ) ; int ans = findClosest ( divisors [ N ] , divisors [ N ] . size ( ) , X ) ; System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int N = 16 , X = 5 ; for ( int i = 0 ; i < divisors . length ; i ++ ) divisors [ i ] = new Vector < Integer > ( ) ; printClosest ( N , X ) ; } }"}
{"text": "Mengira elemen nilai yang sama diletakkan pada indeks yang sama dengan dua array yang diberikan | Program Java untuk pendekatan di atas; Fungsi untuk mengira elemen yang dipadankan maksimum dari array A [] dan B []; Kedai kedudukan unsur -unsur array a [] dalam array b []; Jejaki perbezaan antara indeks; Melintasi array a []; Melintasi array b []; Jika perbezaan negatif, tambahkan n kepadanya; Jejaki bilangan peralihan yang diperlukan untuk meletakkan elemen pada indeks yang sama; Mengembalikan perlawanan maksimum; Kod pemacu; Mengembalikan kiraan elemen yang dipadankan", "code": "import java . io . Console ; import java . util . HashMap ; import java . util . Map ; class GFG { static int maxMatch ( int [ ] A , int [ ] B ) { HashMap < Integer , Integer > Aindex = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > diff = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { Aindex . put ( A [ i ] , i ) ; } for ( int i = 0 ; i < B . length ; i ++ ) { if ( i - Aindex . get ( B [ i ] ) < 0 ) { if ( ! diff . containsKey ( A . length + i - Aindex . get ( B [ i ] ) ) ) { diff . put ( A . length + i - Aindex . get ( B [ i ] ) , 1 ) ; } else { diff . put ( A . length + i - Aindex . get ( B [ i ] ) , diff . get ( A . length + i - Aindex . get ( B [ i ] ) ) + 1 ) ; } } else { if ( ! diff . containsKey ( i - Aindex . get ( B [ i ] ) ) ) { diff . put ( i - Aindex . get ( B [ i ] ) , 1 ) ; } else { diff . put ( i - Aindex . get ( B [ i ] ) , diff . get ( i - Aindex . get ( B [ i ] ) ) + 1 ) ; } } } int max = 0 ; for ( Map . Entry < Integer , Integer > ele : diff . entrySet ( ) ) { if ( ele . getValue ( ) > max ) { max = ele . getValue ( ) ; } } return max ; } public static void main ( String [ ] args ) { int [ ] A = { 5 , 3 , 7 , 9 , 8 } ; int [ ] B = { 8 , 7 , 3 , 5 , 9 } ; System . out . println ( maxMatch ( A , B ) ) ; } }"}
{"text": "Semak jika diberi penyelesaian Sudoku adalah sah atau tidak | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk memeriksa sama ada semua elemen lembaga [] [] nilai kedai array dalam julat [1, 9]; Traverse Board [] [] array; Semak jika papan [i] [j] terletak dalam julat; Fungsi untuk memeriksa sama ada penyelesaian teka -teki sudoku sah atau tidak; Semak sama ada semua elemen papan [] [] menyimpan nilai dalam julat [1, 9]; Kedai nilai unik dari 1 hingga n; Melintasi setiap baris array yang diberikan; Memulakan array unik [] kepada palsu; Melintasi setiap lajur baris semasa; Menyimpan nilai papan [i] [j]; Semak jika baris semasa menyimpan nilai pendua; Melintasi setiap lajur array yang diberikan; Memulakan array unik [] kepada palsu; Melintasi setiap baris lajur semasa; Menyimpan nilai papan [j] [i]; Semak jika lajur semasa menyimpan nilai pendua; Melintasi setiap blok saiz 3 * 3 di papan [] [] array; J menyimpan lajur pertama setiap 3 * 3 blok; Memulakan array unik [] kepada palsu; Melintasi blok semasa; Kedai baris nombor blok semasa; Menyimpan nombor lajur blok semasa; Menyimpan nilai papan [x] [y]; Semak jika blok semasa menyimpan nilai pendua; Jika semua keadaan berpuas hati; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static int N = 9 ; static boolean isinRange ( int [ ] [ ] board ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( board [ i ] [ j ] <= 0 board [ i ] [ j ] > 9 ) { return false ; } } } return true ; } static boolean isValidSudoku ( int board [ ] [ ] ) { if ( isinRange ( board ) == false ) { return false ; } boolean [ ] unique = new boolean [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { Arrays . fill ( unique , false ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ i ] [ j ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N ; i ++ ) { Arrays . fill ( unique , false ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ j ] [ i ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N - 2 ; i += 3 ) { for ( int j = 0 ; j < N - 2 ; j += 3 ) { Arrays . fill ( unique , false ) ; for ( int k = 0 ; k < 3 ; k ++ ) { for ( int l = 0 ; l < 3 ; l ++ ) { int X = i + k ; int Y = j + l ; int Z = board [ X ] [ Y ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } } } return true ; } public static void main ( String [ ] args ) { int [ ] [ ] board = { { 7 , 9 , 2 , 1 , 5 , 4 , 3 , 8 , 6 } , { 6 , 4 , 3 , 8 , 2 , 7 , 1 , 5 , 9 } , { 8 , 5 , 1 , 3 , 9 , 6 , 7 , 2 , 4 } , { 2 , 6 , 5 , 9 , 7 , 3 , 8 , 4 , 1 } , { 4 , 8 , 9 , 5 , 6 , 1 , 2 , 7 , 3 } , { 3 , 1 , 7 , 4 , 8 , 2 , 9 , 6 , 5 } , { 1 , 3 , 6 , 7 , 4 , 8 , 5 , 9 , 2 } , { 9 , 7 , 4 , 2 , 1 , 5 , 6 , 3 , 8 } , { 5 , 2 , 8 , 6 , 3 , 9 , 4 , 1 , 7 } } ; if ( isValidSudoku ( board ) ) { System . out . println ( \" Valid \" ) ; } else { System . out . println ( \" Not ▁ Valid \" ) ; } } }"}
{"text": "Subarray panjang k yang penggabungannya membentuk palindrome | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor adalah palindrome atau tidak di sini saya adalah indeks permulaan dan j adalah indeks terakhir subarray; Jika integer di saya tidak sama dengan j maka subarray bukan palindrome; Jika tidak; Semua [i] adalah sama dengan [j] maka subarray adalah palindrome; Berfungsi untuk mencari subarray yang penggabungannya membentuk palindrome dan mengembalikan indeks permulaannya; Melangkah ke atas subarray panjang k dan memeriksa jika subarray itu adalah palindrome; Jika tiada subarray adalah palindrome; Kod pemacu", "code": "import java . io . * ; class GFG { public static boolean palindrome ( int [ ] a , int i , int j ) { while ( i < j ) { if ( a [ i ] != a [ j ] ) return false ; i ++ ; j -- ; } return true ; } static int findSubArray ( int [ ] arr , int k ) { int n = arr . length ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( palindrome ( arr , i , i + k - 1 ) ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 5 , 1 , 3 } ; int k = 4 ; int ans = findSubArray ( arr , k ) ; if ( ans == - 1 ) System . out . print ( - 1 + \"NEW_LINE\"); else { for ( int i = ans ; i < ans + k ; i ++ ) System . out . print ( arr [ i ] + \" ▁ \" ) ; System . out . print ( \"NEW_LINE\"); } } }"}
{"text": "Semak sama ada urutan laluan melawat sebarang koordinat dua kali atau tidak | Program Java untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada lelaki itu melintasi koordinat sebelumnya atau tidak; Menyimpan kiraan puncak silang; Kedai (x, y) koordinat; Koordinat untuk asal; Melangkah ke atas rentetan; Keadaan kepada kenaikan x atau y co - masing -masing; Semak jika (x, y) sudah dilawati; Cetak hasilnya; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "import java . awt . Point ; import java . util . HashSet ; class GFG { static void isCrossed ( String path ) { if ( path . length ( ) == 0 ) return ; boolean ans = false ; HashSet < Point > set = new HashSet < Point > ( ) ; int x = 0 , y = 0 ; set . add ( new Point ( x , y ) ) ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { if ( path . charAt ( i ) == ' N ' ) set . add ( new Point ( x , y ++ ) ) ; if ( path . charAt ( i ) == ' S ' ) set . add ( new Point ( x , y -- ) ) ; if ( path . charAt ( i ) == ' E ' ) set . add ( new Point ( x ++ , y ) ) ; if ( path . charAt ( i ) == ' W ' ) set . add ( new Point ( x -- , y ) ) ; if ( set . contains ( new Point ( x , y ) ) ) { ans = true ; break ; } } if ( ans ) System . out . print ( \" Crossed \" ) ; else System . out . print ( \" Not ▁ Crossed \" ) ; } public static void main ( String [ ] args ) { String path = \" NESW \" ; isCrossed ( path ) ; } }"}
{"text": "Lebar maksimum n | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari lebar maksimum pokok menggunakan traversal urutan tahap; Simpan tepi pokok; Menyimpan lebar maksimum pokok; Menyimpan nod setiap peringkat; Masukkan nod akar; Melakukan perintah level traversal di atas pokok; Menyimpan saiz barisan; Kemas kini lebar maksimum; Tolak nod tahap seterusnya dan popkan unsur -unsur tahap semasa; Dapatkan elemen dari depan barisan; Tolak semua nod peringkat seterusnya. ; Kembalikan hasilnya. ; Kod pemacu; Pokok yang dibina ialah: 1 / | \\ 2 - 1 3 / \\ \\ 4 5 8 / / | \\ 2 6 12 7", "code": "import java . io . * ; import java . util . * ; class GFG { static int maxWidth ( int N , int M , ArrayList < Integer > cost , ArrayList < ArrayList < Integer > > s ) { ArrayList < ArrayList < Integer > > adj = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { adj . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < M ; i ++ ) { adj . get ( s . get ( i ) . get ( 0 ) ) . add ( s . get ( i ) . get ( 1 ) ) ; } int result = 0 ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 0 ) ; while ( q . size ( ) != 0 ) { int count = q . size ( ) ; result = Math . max ( count , result ) ; while ( count -- > 0 ) { int temp = q . remove ( ) ; for ( int i = 0 ; i < adj . get ( temp ) . size ( ) ; i ++ ) { q . add ( adj . get ( temp ) . get ( i ) ) ; } } } return result ; } public static void main ( String [ ] args ) { int N = 11 , M = 10 ; ArrayList < ArrayList < Integer > > edges = new ArrayList < ArrayList < Integer > > ( ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 0 , 1 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 0 , 2 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 0 , 3 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 1 , 4 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 1 , 5 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 3 , 6 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 4 , 7 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 6 , 10 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 6 , 8 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 6 , 9 ) ) ) ; ArrayList < Integer > cost = new ArrayList < Integer > ( Arrays . asList ( 1 , 2 , - 1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 ) ) ; System . out . println ( maxWidth ( N , M , cost , edges ) ) ; } }"}
{"text": "Kurangkan jumlah nombor perdana yang ditambah untuk membuat array bukan | Program Java untuk melaksanakan pendekatan di atas; Kedai jika indeks adalah nilai utama / bukan utama; Menyimpan perdana; Berfungsi untuk menjana semua nombor perdana; Jika elemen semasa adalah perdana; Tetapkan semua gandaannya bukan perdana; Simpan semua nombor utama; Berfungsi untuk mencari perdana terdekat dengan nombor tertentu; Memohon carian binari pada vektor prima; Jika perdana ditambah menjadikan unsur -unsur sama; Kembali ini sebagai perdana terdekat; Jika array kekal tidak menurun; Cari nombor perdana yang lebih besar; Jika tidak; Periksa sama ada perdana yang lebih kecil boleh membuat array tidak berkurangan atau tidak; Mengembalikan nombor terdekat; Berfungsi untuk mencari kos minimum; Cari semua prima; Simpan hasilnya; Melangkah ke atas array; Elemen semasa adalah kurang daripada elemen sebelumnya; Cari perdana terdekat yang membuat array tidak berkurangan; Tambah kepada kos keseluruhan; Mengemas kini elemen semasa; Mengembalikan kos minimum; Kod pemacu; Diberikan array; Panggilan fungsi", "code": "import java . util . * ; class GFG { static final int MAX = 10000000 ; static boolean [ ] isPrime = new boolean [ MAX + 1 ] ; static Vector < Integer > primes = new Vector < Integer > ( ) ; static void SieveOfEratosthenes ( ) { Arrays . fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . add ( p ) ; } static int prime_search ( Vector < Integer > primes , int diff ) { int low = 0 ; int high = primes . size ( ) - 1 ; int res = - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( primes . get ( mid ) == diff ) { return primes . get ( mid ) ; } else if ( primes . get ( mid ) < diff ) { low = mid + 1 ; } else { res = primes . get ( mid ) ; high = mid - 1 ; } } return res ; } static int minCost ( int arr [ ] , int n ) { SieveOfEratosthenes ( ) ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ; int closest_prime = prime_search ( primes , diff ) ; res += closest_prime ; arr [ i ] += closest_prime ; } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 5 , 4 , 3 } ; int n = 5 ; System . out . print ( minCost ( arr , n ) ) ; } }"}
{"text": "Kira cara untuk memecah rentetan binari ke dalam tiga substring yang mempunyai kiraan sifar yang sama | Pelaksanaan Java untuk pendekatan di atas; Berfungsi untuk mengembalikan cara untuk memecah rentetan ke dalam tiga bahagian dengan bilangan yang sama 0; Simpan jumlah kiraan 0 s; Kira Jumlah No. daripada 0 s watak dalam rentetan yang diberikan; Jika jumlah kiraan 0 watak tidak boleh dibahagikan dengan 3; Memulakan peta untuk menyimpan kekerapan k; Traverse String untuk mencari cara untuk memecah rentetan; Kiraan kenaikan jika 0 muncul; Hasil kenaikan jika jumlah sama dengan 2 * k dan k ada dalam peta; Masukkan jumlah dalam peta; Hasil pulangan; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "import java . util . * ; import java . lang . * ; class GFG { static int count ( String s ) { int cnt = 0 ; for ( char c : s . toCharArray ( ) ) { cnt += c == '0' ? 1 : 0 ; } if ( cnt % 3 != 0 ) return 0 ; int res = 0 , k = cnt / 3 , sum = 0 ; Map < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += s . charAt ( i ) == '0' ? 1 : 0 ; if ( sum == 2 * k && map . containsKey ( k ) && i < s . length ( ) - 1 && i > 0 ) { res += map . get ( k ) ; } map . put ( sum , map . getOrDefault ( sum , 0 ) + 1 ) ; } return res ; } public static void main ( String [ ] args ) { String str = \"01010\" ; System . out . println ( count ( str ) ) ; } }"}
{"text": "Kira cara untuk memecah rentetan binari ke dalam tiga substring yang mempunyai kiraan sifar yang sama | Program Java untuk pendekatan di atas; Berfungsi untuk mengira bilangan cara untuk berpecah; Mengira jumlah sifar; Kes1 jika jumlah kiraan sifar tidak boleh dibahagikan dengan 3; Case2 Jika jumlah kiraan sifar adalah sifar; Bilangan sifar dalam setiap substring; Memulakan sifar kepada bilangan cara untuk potongan pertama dan kedua; Memulakan kiraan; Melintasi dari awal; Meningkatkan kiraan jika elemen adalah '0'; Meningkatkan cara untuk pemotongan 1 jika kiraan adalah sama dengan sifar yang diperlukan dalam setiap substring; Meningkatkan cara untuk pemotongan 2 nd jika kiraan adalah sama dengan 2 * (sifar yang diperlukan dalam setiap substring); Jumlah cara untuk berpecah adalah pendaraban cara untuk potongan 1 dan 2; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int splitstring ( String s ) { int n = s . length ( ) ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s . charAt ( i ) == '0' ) zeros ++ ; if ( zeros % 3 != 0 ) return 0 ; if ( zeros == 0 ) return ( ( n - 1 ) * ( n - 2 ) ) / 2 ; int zerosInEachSubstring = zeros / 3 ; int waysOfFirstCut = 0 ; int waysOfSecondCut = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) count ++ ; if ( count == zerosInEachSubstring ) waysOfFirstCut ++ ; else if ( count == 2 * zerosInEachSubstring ) waysOfSecondCut ++ ; } return waysOfFirstCut * waysOfSecondCut ; } public static void main ( String args [ ] ) { String s = \"01010\" ; System . out . println ( \" The ▁ number ▁ of ▁ \" + \" ways ▁ to ▁ split ▁ is ▁ \" + splitstring ( s ) ) ; } }"}
{"text": "Semak jika rentetan boleh ditukar kepada yang lain dengan menukar watak bersebelahan jenis yang diberikan | Program Java untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada mungkin untuk mengubah mula berakhir; Semak urutan A, B dalam kedua -dua String Str1 dan Str2; Jika kedua -dua rentetan tidak sama; Melintasi rentetan; Semak indeks A dan B; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static boolean canTransform ( String str1 , String str2 ) { String s1 = \" \" ; String s2 = \" \" ; for ( char c : str1 . toCharArray ( ) ) { if ( c != ' C ' ) { s1 += c ; } } for ( char c : str2 . toCharArray ( ) ) { if ( c != ' C ' ) { s2 += c ; } } if ( ! s1 . equals ( s2 ) ) return false ; int i = 0 ; int j = 0 ; int n = str1 . length ( ) ; while ( i < n && j < n ) { if ( str1 . charAt ( i ) == ' C ' ) { i ++ ; } else if ( str2 . charAt ( j ) == ' C ' ) { j ++ ; } else { if ( ( str1 . charAt ( i ) == ' A ' && i < j ) || ( str1 . charAt ( i ) == ' B ' && i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; } public static void main ( String [ ] args ) { String str1 = \" BCCABCBCA \" ; String str2 = \" CBACCBBAC \" ; if ( canTransform ( str1 , str2 ) ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } }"}
{"text": "Substring terpanjang yang mempunyai kiraan vokal dan konsonan yang sama | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan panjang substring terpanjang yang mempunyai bilangan vokal dan konsonan yang sama; Menjana array; Memulakan pembolehubah untuk menyimpan hasil; Menyimpan jumlah subarray; Peta untuk menyimpan indeks jumlah; Gelung melalui array; Jika jumlah adalah 0; Count vokal dan konsonan adalah sama; Mengemas kini panjang maksimum substring dalam hashmap; Simpan indeks jumlah; Mengembalikan panjang maksimum substring yang diperlukan; Kod pemacu", "code": "import java . util . * ; class GFG { static int maxsubStringLength ( char [ ] S , int N ) { int arr [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; int maxLen = 0 ; int curr_sum = 0 ; HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = Math . max ( maxLen , i + 1 ) ; if ( hash . containsKey ( curr_sum ) ) maxLen = Math . max ( maxLen , i - hash . get ( curr_sum ) ) ; else hash . put ( curr_sum , i ) ; } return maxLen ; } public static void main ( String [ ] args ) { String S = \" geeksforgeeks \" ; int n = S . length ( ) ; System . out . print ( maxsubStringLength ( S . toCharArray ( ) , n ) ) ; } }"}
{"text": "Jarak minimum dari sel tertentu ke semua sel lain dari matriks | Program Java untuk melaksanakan pendekatan di atas; Menyimpan arahan yang boleh diakses; Fungsi untuk mencari jarak minimum dari sel tertentu ke semua sel lain dalam matriks; Menyimpan sel -sel yang boleh diakses dari sel semasa; Masukkan pasangan (x, y); Melangkah ke barisan adalah kosong; Ekstrak pasangan; Pop mereka; Memeriksa keadaan sempadan; Jika sel tidak dikunjungi; Menetapkan jarak minimum; Masukkan jiran yang dilalui ke dalam barisan; Kod pemacu; Cetak jarak yang diperlukan", "code": "import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int [ ] [ ] mat = new int [ 1001 ] [ 1001 ] ; static int r , c , x , y ; static int dx [ ] = { 0 , - 1 , - 1 , - 1 , 0 , 1 , 1 , 1 } ; static int dy [ ] = { 1 , 1 , 0 , - 1 , - 1 , - 1 , 0 , 1 } ; static void FindMinimumDistance ( ) { Queue < pair > q = new LinkedList < > ( ) ; q . add ( new pair ( x , y ) ) ; mat [ x ] [ y ] = 0 ; while ( ! q . isEmpty ( ) ) { x = q . peek ( ) . first ; y = q . peek ( ) . second ; q . remove ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 a >= r b >= c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . add ( new pair ( a , b ) ) ; } } } } public static void main ( String [ ] args ) { r = 5 ; c = 5 ; x = 1 ; y = 1 ; int t = x ; int l = y ; mat [ x ] [ y ] = 0 ; FindMinimumDistance ( ) ; mat [ t ] [ l ] = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { System . out . print ( mat [ i ] [ j ] + \" ▁ \" ) ; } System . out . println ( ) ; } } }"}
{"text": "Kelebihan minimum yang diperlukan untuk menukar rentetan yang diberikan menjadi penyambungan substrings yang sama panjang k | Program Java untuk melaksanakan pendekatan di atas; Fungsi yang mengembalikan bilangan minimum flip untuk menukar s ke dalam penyambungan sub -panjang sub -rentetan; Menyimpan hasilnya; Melangkah melalui indeks rentetan; Kedai kiraan 0 S & 1 S; ITERATE MEMBUAT K JUMPS; Kiraan 0 's; Kiraan 1 's; Tambah flip minimum untuk Indeks I; Mengembalikan bilangan minimum; Kod pemacu", "code": "import java . io . * ; class GFG { public static int minOperations ( String S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . length ( ) ; j += K ) { if ( S . charAt ( j ) == '0' ) zero ++ ; else one ++ ; } ans += Math . min ( zero , one ) ; } return ans ; } public static void main ( String args [ ] ) { String S = \"110100101\" ; int K = 3 ; System . out . println ( minOperations ( S , K ) ) ; } }"}
{"text": "Cari nombor yang hilang dalam perkembangan aritmetik yang tidak teratur | Program Java untuk pendekatan di atas; Berfungsi untuk mendapatkan elemen yang hilang; Untuk elemen maksimum dalam array; Untuk elemen minimum dalam array; Untuk XOR semua elemen; Perbezaan umum siri AP; Cari elemen maksimum dan minimum; Mengira perbezaan biasa; Kirakan XOR semua elemen; Lakukan XOR dengan siri AP sebenar yang dihasilkan X akan menjadi ANS; Mengembalikan elemen yang hilang; Kod pemacu; Diberikan array; Panggilan fungsi; Cetak elemen yang hilang", "code": "class GFG { static int missingElement ( int arr [ ] , int n ) { int max_ele = arr [ 0 ] ; int min_ele = arr [ 0 ] ; int x = 0 ; int d ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; } d = ( max_ele - min_ele ) / n ; for ( int i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; } for ( int i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; } return x ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 12 , 3 , 6 , 15 , 18 } ; int n = arr . length ; int element = missingElement ( arr , n ) ; System . out . print ( element ) ; } }"}
{"text": "Memandangkan rentetan dan integer k, cari sub sub | Pelaksanaan Java pendekatan; Berfungsi untuk mencetak sub -sub - string; Jumlah sub - rentetan mungkin; Jika k lebih besar daripada jumlah sub -rentetan; Untuk menyimpan nombor sub -rentetan bermula dengan watak rentetan; Mengira nilai -nilai; Substring [i - 1] ditambah untuk menyimpan jumlah kumulatif; Carian binari untuk mencari indeks permulaan sub -rentetan KTH; Untuk menyimpan indeks akhir sub -rentetan KTH; Cetak sub -rentetan; Kod pemacu", "code": "class GFG { static void Printksubstring ( String str , int n , int k ) { int total = ( n * ( n + 1 ) ) / 2 ; if ( k > total ) { System . out . printf ( \"-1NEW_LINE\"); return ; } int substring [ ] = new int [ n + 1 ] ; substring [ 0 ] = 0 ; int temp = n ; for ( int i = 1 ; i <= n ; i ++ ) { substring [ i ] = substring [ i - 1 ] + temp ; temp -- ; } int l = 1 ; int h = n ; int start = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( substring [ m ] > k ) { start = m ; h = m - 1 ; } else if ( substring [ m ] < k ) { l = m + 1 ; } else { start = m ; break ; } } int end = n - ( substring [ start ] - k ) ; for ( int i = start - 1 ; i < end ; i ++ ) { System . out . print ( str . charAt ( i ) ) ; } } public static void main ( String [ ] args ) { String str = \" abc \" ; int k = 4 ; int n = str . length ( ) ; Printksubstring ( str , n , k ) ; } }"}
{"text": "Titik penyisipan yang lebih rendah | Program Java untuk mencari titik penyisipan yang lebih rendah dari elemen dalam array yang disusun; Berfungsi untuk mengembalikan titik penyisipan yang lebih rendah dari elemen dalam array yang disusun; Kes asas; Pemeriksaan akhir untuk unsur -unsur yang tersisa yang <x; Kod pemacu", "code": "public class AQES { static int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 } ; int n = arr . length ; int X = 4 ; System . out . println ( LowerInsertionPoint ( arr , n , X ) ) ; } }"}
{"text": "Bilangan jawatan dengan alamat yang sama dalam baris utama dan lajur utama urutan | Program Java untuk mengira bilangan kedudukan dengan alamat yang sama dalam perintah utama utama dan lajur; Mengembalikan kiraan kedudukan yang diperlukan; array 1D mendatar; array 1D menegak; melangkah untuk semua yang mungkin saya; Memeriksa jika J adalah integer; Memeriksa jika J terletak b / w 1 hingga n; melangkah untuk semua kemungkinan j; Memeriksa jika saya adalah integer; Memeriksa jika saya terletak b / w 1 hingga m; Kod pemacu", "code": "import java . io . * ; class GFG { static int getCount ( int M , int N ) { int count = 0 ; if ( M == 1 ) return N ; if ( N == 1 ) return M ; if ( N > M ) { for ( int i = 1 ; i <= M ; i ++ ) { int numerator = N * i - N + M - i ; int denominator = M - 1 ; if ( numerator % denominator == 0 ) { int j = numerator / denominator ; if ( j >= 1 && j <= N ) count ++ ; } } } else { for ( int j = 1 ; j <= N ; j ++ ) { int numerator = M * j - M + N - j ; int denominator = N - 1 ; if ( numerator % denominator == 0 ) { int i = numerator / denominator ; if ( i >= 1 && i <= M ) count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int M = 3 , N = 5 ; System . out . println ( getCount ( M , N ) ) ; } }"}
{"text": "Maksimum dalam pelbagai yang boleh membuat array lain disusun | Program Java untuk membuat array disusun; Fungsi untuk memeriksa sama ada terdapat unsur swappable yang hadir untuk membuat array pertama disusun; WrongIdx adalah indeks elemen yang membuat array pertama tidak disusun; Cari elemen maksimum yang memenuhi syarat jiran yang disebutkan di atas; Jika res adalah benar maka swap elemen dan buat array pertama disusun; Fungsi untuk mencetak array yang disusun jika elemen ditukar. ; Kod pemacu", "code": "class GFG { static boolean swapElement ( int [ ] arr1 , int [ ] arr2 , int n ) { int wrongIdx = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr1 [ i - 1 ] ) { wrongIdx = i ; } } int maximum = Integer . MIN_VALUE ; int maxIdx = - 1 ; boolean res = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] > maximum && arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) { if ( wrongIdx + 1 <= n - 1 && arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) { maximum = arr2 [ i ] ; maxIdx = i ; res = true ; } } } if ( res ) { swap ( arr1 , wrongIdx , arr2 , maxIdx ) ; } return res ; } static void swap ( int [ ] a , int wrongIdx , int [ ] b , int maxIdx ) { int c = a [ wrongIdx ] ; a [ wrongIdx ] = b [ maxIdx ] ; b [ maxIdx ] = c ; } static void getSortedArray ( int arr1 [ ] , int arr2 [ ] , int n ) { if ( swapElement ( arr1 , arr2 , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr1 [ i ] + \" ▁ \" ) ; } } else { System . out . println ( \" Not ▁ Possible \" ) ; } } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 3 , 7 , 4 , 10 } ; int arr2 [ ] = { 2 , 1 , 6 , 8 , 9 } ; int n = arr1 . length ; getSortedArray ( arr1 , arr2 , n ) ; } }"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Program Java untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; Bandingkan setiap tiga nombor untuk mencari nombor tengah. Masukkan hanya jika A> B; Memutuskan A tidak lebih besar daripada b. ; kod pemacu", "code": "import java . util . * ; class Middle { public static int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } } public static void main ( String [ ] args ) { int a = 20 , b = 30 , c = 40 ; System . out . println ( middleOfThree ( a , b , c ) ) ; } }"}
{"text": "Susun Lajur Matriks | Program Java untuk pendekatan di atas; Berfungsi untuk mencari transpose matriks mat []; Menyimpan transpose matriks mat [] []; Melintasi setiap baris matriks; Melintasi setiap lajur matriks; Elemen matriks transpose; Berfungsi untuk menyusun matriks yang diberikan dengan cara yang bijak; Melintasi baris; Baris - penyortiran bijak; Berfungsi untuk mencetak matriks dalam lajur yang disusun dengan bijak; Fungsi panggilan untuk mencari transpose matriks mat [] []; Menyusun baris matriks - bijak; Kirakan transpose b [] []; Cetak matriks mat [] []; Kod pemacu; Input; Fungsi panggilan untuk mencetak matriks dalam lajur yang disusun dengan bijak", "code": "import java . util . * ; import java . util . Arrays ; class GFG { static int [ ] [ ] transpose ( int [ ] [ ] mat , int row , int col ) { int [ ] [ ] tr = new int [ col ] [ row ] ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) { tr [ j ] [ i ] = mat [ i ] [ j ] ; } } return tr ; } static void RowWiseSort ( int [ ] [ ] B ) { for ( int i = 0 ; i < ( int ) B . length ; i ++ ) { Arrays . sort ( B [ i ] ) ; } } static void sortCol ( int [ ] [ ] mat , int N , int M ) { int [ ] [ ] B = transpose ( mat , N , M ) ; RowWiseSort ( B ) ; mat = transpose ( B , M , N ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { System . out . print ( mat [ i ] [ j ] + \" ▁ \" ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 6 , 10 } , { 8 , 5 , 9 } , { 9 , 4 , 15 } , { 7 , 3 , 60 } } ; int N = mat . length ; int M = mat [ 0 ] . length ; sortCol ( mat , N , M ) ; } }"}
{"text": "Kawasan terbesar mungkin selepas penyingkiran siri bar mendatar & menegak | Program Java untuk pendekatan di atas; Berfungsi untuk mencari kawasan terbesar apabila satu siri bar mendatar & menegak dikeluarkan; Menyimpan semua bar; Masukkan bar mendatar; Masukkan bar verttik; Keluarkan pemisah mendatar dari S1; Keluarkan pemisah menegak dari S2; Kedai -kedai yang ditinggalkan pemisah mendatar dan menegak; Menyusun kedua -dua senarai dalam urutan menaik; Cari perbezaan maksimum jiran List1; Cari perbezaan maksimum jiran List2; Cetak kelantangan terbesar; Kod pemacu; Diberi nilai N & M; Diberikan susunan; Fungsi panggilan untuk mencari kawasan terbesar apabila satu siri bar mendatar & menegak dikeluarkan", "code": "import java . lang . * ; import java . util . * ; class GFG { static void largestArea ( int N , int M , int [ ] H , int [ ] V ) { Set < Integer > s1 = new HashSet < > ( ) ; Set < Integer > s2 = new HashSet < > ( ) ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s1 . add ( i ) ; for ( int i = 1 ; i <= M + 1 ; i ++ ) s2 . add ( i ) ; for ( int i = 0 ; i < H . length ; i ++ ) { s1 . remove ( H [ i ] ) ; } for ( int i = 0 ; i < V . length ; i ++ ) { s2 . remove ( V [ i ] ) ; } int [ ] list1 = new int [ s1 . size ( ) ] ; int [ ] list2 = new int [ s2 . size ( ) ] ; int i = 0 ; Iterator it1 = s1 . iterator ( ) ; while ( it1 . hasNext ( ) ) { list1 [ i ++ ] = ( int ) it1 . next ( ) ; } i = 0 ; Iterator it2 = s2 . iterator ( ) ; while ( it2 . hasNext ( ) ) { list2 [ i ++ ] = ( int ) it2 . next ( ) ; } Arrays . sort ( list1 ) ; Arrays . sort ( list2 ) ; int maxH = 0 , p1 = 0 , maxV = 0 , p2 = 0 ; for ( int j = 0 ; j < list1 . length ; j ++ ) { maxH = Math . max ( maxH , list1 [ j ] - p1 ) ; p1 = list1 [ j ] ; } for ( int j = 0 ; j < list2 . length ; j ++ ) { maxV = Math . max ( maxV , list2 [ j ] - p2 ) ; p2 = list2 [ j ] ; } System . out . println ( maxV * maxH ) ; } public static void main ( String [ ] args ) { int N = 3 , M = 3 ; int [ ] H = { 2 } ; int [ ] V = { 2 } ; largestArea ( N , M , H , V ) ; } }"}
{"text": "Semak jika array boleh disusun dengan menukar pasangan dari indeks yang terdiri daripada unsur -unsur yang tidak sama rata dalam array lain | Program Java pendekatan di atas; Fungsi untuk memeriksa sama ada array, [] boleh ditukar menjadi array yang disusun dengan bertukar (a [i], a [j]) jika b [i] tidak sama dengan b [j]; Kedai jika array A [] disusun dalam urutan menurun atau tidak; Melintasi array a []; Jika [i] lebih besar daripada [i + 1]; Bendera kemas kini; Jika array disusun mengikut urutan menaik; kiraan = 2: periksa jika 0 s dan 1 s kedua -duanya hadir dalam b []; Melintasi array; Jika elemen semasa ialah 0; Kiraan kemas kini; Melintasi array b []; Jika elemen semasa ialah 1; Jika kedua -dua 0 s dan 1 s hadir dalam array; Kod pemacu; Array input a []; Arahan input B []; Panggilan fungsi; Jika benar, cetak ya; Lain cetak no", "code": "import java . io . * ; class GFG { static boolean checkifSorted ( int A [ ] , int B [ ] , int N ) { boolean flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int A [ ] = { 3 , 1 , 2 } ; int B [ ] = { 0 , 1 , 1 } ; int N = A . length ; boolean check = checkifSorted ( A , B , N ) ; if ( check ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text": "Swap minimum diperlukan di antara dua rentetan untuk membuat satu rentetan ketat lebih besar daripada yang lain | Program Java untuk pendekatan di atas; Berfungsi untuk mencari bilangan langkah minimum untuk membuat A> B; Jika semua watak adalah sama dan m <= n; Sekiranya terdapat sebarang watak dalam B yang lebih besar daripada B [0]; Jika terdapat apa -apa watak yang lebih kecil daripada [0]; Sekiranya terdapat watak yang berada di dalam dan lebih besar daripada [0]; Sekiranya terdapat watak yang berada di B dan kurang daripada B [0]; Jika tidak; Fungsi pemacu", "code": "import java . util . * ; import java . lang . * ; class GFG { static int minSteps ( StringBuilder A , StringBuilder B , int M , int N ) { if ( A . charAt ( 0 ) > B . charAt ( 0 ) ) return 0 ; if ( B . charAt ( 0 ) > A . charAt ( 0 ) ) { return 1 ; } if ( M <= N && A . charAt ( 0 ) == B . charAt ( 0 ) && count ( A , A . charAt ( 0 ) ) == M && count ( B , B . charAt ( 0 ) ) == N ) return - 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( B . charAt ( i ) > B . charAt ( 0 ) ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A . charAt ( i ) < A . charAt ( 0 ) ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A . charAt ( i ) > A . charAt ( 0 ) ) { swap ( A , i , B , 0 ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } } for ( int i = 1 ; i < N ; i ++ ) { if ( B . charAt ( i ) < B . charAt ( 0 ) ) { swap ( A , 0 , B , i ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } } return 0 ; } static int count ( StringBuilder a , char c ) { int count = 0 ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) if ( a . charAt ( i ) == c ) count ++ ; return count ; } static void swap ( StringBuilder s1 , int index1 , StringBuilder s2 , int index2 ) { char c = s1 . charAt ( index1 ) ; s1 . setCharAt ( index1 , s2 . charAt ( index2 ) ) ; s2 . setCharAt ( index2 , c ) ; } public static void main ( String [ ] args ) { StringBuilder A = new StringBuilder ( \" adsfd \" ) ; StringBuilder B = new StringBuilder ( \" dffff \" ) ; int M = A . length ( ) ; int N = B . length ( ) ; System . out . println ( minSteps ( A , B , M , N ) ) ; } }"}
{"text": "Kira bilangan minimum bergerak ke depan atau akhir untuk menyusun array | Algoritma Java untuk pendekatan di atas; Kelas pasangan yang akan menyimpan elemen array dengan indeksnya; Kod pemacu; Berfungsi untuk mencari bilangan minimum operasi yang diperlukan supaya array menjadi bermakna; Pelbagai jenis jenis pasangan yang boleh digunakan untuk menyusun ARR berkenaan dengan nilai -nilainya; Menyusun array num atas dasar nilai; Memulakan pembolehubah yang digunakan untuk mencari panjang maksimum yang semakin meningkat dalam indeks; Mengemas kini coretan; Mengembalikan bilangan elemen yang tersisa kecuali coretan", "code": "import java . util . * ; class GFG { public static class Pair { int val ; int idx ; Pair ( int val , int idx ) { this . val = val ; this . idx = idx ; } } public static void main ( String [ ] args ) { int n = 5 ; int [ ] arr = { 4 , 7 , 2 , 3 , 9 } ; System . out . println ( minOperations ( arr , n ) ) ; } public static int minOperations ( int [ ] arr , int n ) { Pair [ ] num = new Pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { num [ i ] = new Pair ( arr [ i ] , i ) ; } Arrays . sort ( num , ( Pair a , Pair b ) -> a . val - b . val ) ; int res = 1 ; int streak = 1 ; int prev = num [ 0 ] . idx ; for ( int i = 1 ; i < n ; i ++ ) { if ( prev < num [ i ] . idx ) { res ++ ; streak = Math . max ( res , streak ) ; } else res = 1 ; prev = num [ i ] . idx ; } return n - streak ; } }"}
{"text": "Memaksimumkan jumlah produk berpasangan yang dihasilkan dari tatasusunan yang diberikan | Program Java untuk pendekatan di atas; Pembolehubah yang mewakili saiz array; Menyimpan hasilnya; Berfungsi untuk mengembalikan jumlah maksimum yang mungkin; Menyimpan kiraan susunan yang diproses; Jika lebih daripada dua tatasusunan telah diproses; Sekiranya subproblem yang telah dikira telah berlaku; Terokai semua pasangan yang mungkin; Panggilan fungsi rekursif; Memoize maksimum; Mengembalikan nilai; Berfungsi untuk mengembalikan jumlah maksimum produk pasangan yang mungkin; Memulakan array DP ke - 1; Menyusun tatasusunan dalam urutan menurun; Kod pemacu", "code": "import java . util . * ; import java . lang . * ; class GFG { static final int maxN = 201 ; static int n1 , n2 , n3 ; static int [ ] [ ] [ ] dp = new int [ maxN ] [ maxN ] [ maxN ] ; static int getMaxSum ( int i , int j , int k , int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) { int cnt = 0 ; if ( i >= n1 ) cnt ++ ; if ( j >= n2 ) cnt ++ ; if ( k >= n3 ) cnt ++ ; if ( cnt >= 2 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ] ; int ans = 0 ; if ( i < n1 && j < n2 ) ans = Math . max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; if ( i < n1 && k < n3 ) ans = Math . max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; if ( j < n2 && k < n3 ) ans = Math . max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; dp [ i ] [ j ] [ k ] = ans ; return dp [ i ] [ j ] [ k ] ; } static void reverse ( int [ ] tmp ) { int i , k , t ; int n = tmp . length ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = tmp [ i ] ; tmp [ i ] = tmp [ n - i - 1 ] ; tmp [ n - i - 1 ] = t ; } } static int maxProductSum ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) { for ( int i = 0 ; i < dp . length ; i ++ ) for ( int j = 0 ; j < dp [ 0 ] . length ; j ++ ) for ( int k = 0 ; k < dp [ j ] [ 0 ] . length ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; Arrays . sort ( arr1 ) ; reverse ( arr1 ) ; Arrays . sort ( arr2 ) ; reverse ( arr2 ) ; Arrays . sort ( arr3 ) ; reverse ( arr3 ) ; return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; } public static void main ( String [ ] args ) { n1 = 2 ; int arr1 [ ] = { 3 , 5 } ; n2 = 2 ; int arr2 [ ] = { 2 , 1 } ; n3 = 3 ; int arr3 [ ] = { 4 , 3 , 5 } ; System . out . println ( maxProductSum ( arr1 , arr2 , arr3 ) ) ; } }"}
{"text": "Triplet leksikografi terbesar dari array yang diberikan yang membentuk segitiga | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari triplet terbesar secara leksikografi yang membentuk segitiga dalam array yang diberikan; Susun array; Berulang dari akhir array; Jika triplet membentuk segitiga; Jika triplet dijumpai; Cetak triplet; Jika tidak; Kod pemacu", "code": "import java . util . * ; class GFG { static void findTriplet ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int flag = 0 , i ; for ( i = N - 1 ; i - 2 >= 0 ; i -- ) { if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) { flag = 1 ; break ; } } if ( flag != 0 ) { System . out . println ( arr [ i - 2 ] + \" ▁ \" + arr [ i - 1 ] + \" ▁ \" + arr [ i ] ) ; } else { System . out . println ( - 1 ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 10 , 3 , 5 } ; int N = arr . length ; findTriplet ( arr , N ) ; } }"}
{"text": "Kira semua pasangan dalam array dengan perbezaan mutlak minimum | Program Java untuk perkara di atas; Berfungsi untuk mengembalikan kiraan semua pasangan yang mempunyai perbezaan mutlak yang minimum; Menyimpan kiraan pasangan; Susun array; Menyimpan perbezaan minimum antara pasangan bersebelahan; Mengemas kini perbezaan minimum antara pasangan; Meningkatkan kiraan pasangan dengan perbezaan yang sama dengan perbezaan minimum; Mengembalikan kiraan akhir; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "import java . util . Arrays ; class GFG { static int numberofpairs ( int [ ] arr , int N ) { int answer = 0 ; Arrays . sort ( arr ) ; int minDiff = 10000000 ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = Math . min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 1 , 3 } ; int N = arr . length ; System . out . print ( numberofpairs ( arr , N ) ) ; } }"}
{"text": "Subset saiz maksimum dengan jumlah yang diberikan menggunakan backtracking | Program Java untuk melaksanakan pendekatan di atas; Permulaan maksimum kemungkinan panjang berikutnya; Simpan elemen untuk membandingkan max_length dengan saiznya dan tukar nilai max_length dengan sewajarnya; Simpan unsur -unsur yang paling lama; Berfungsi untuk mencari panjang berikutnya terpanjang; Kemas kini max_length; Simpan unsur -unsur berikutnya; Secara rekursif meneruskan dengan jumlah yang diperoleh; unsur -unsur yang muncul dari belakang kedai vektor; jika jumlah> 0 maka kita tidak memerlukannya sehingga kembali dan teruskan dengan unsur -unsur terdahulu; Susun array yang diberikan; Melintasi array; Jika max_length sudah lebih besar daripada atau sama daripada panjang yang tinggal; Kod pemacu", "code": "import java . util . * ; class GFG { static int max_length = 0 ; static Vector < Integer > store = new Vector < Integer > ( ) ; static Vector < Integer > ans = new Vector < Integer > ( ) ; static void find_max_length ( int [ ] arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . add ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . size ( ) ) { max_length = store . size ( ) ; ans = store ; } } for ( int i = index + 1 ; i < arr . length ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_max_length ( arr , i , sum , k ) ; store . remove ( store . size ( ) - 1 ) ; } else return ; } return ; } static int longestSubsequence ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store . clear ( ) ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; } public static void main ( String [ ] args ) { int [ ] arr = { - 3 , 0 , 1 , 1 , 2 } ; int n = arr . length ; int k = 1 ; System . out . print ( longestSubsequence ( arr , n , k ) ) ; } }"}
{"text": "Susun Pengurangan Permutasi N Menggunakan Swap Triple | Pelaksanaan Java untuk menyusun pengurangan permutasi N menggunakan swap tiga; Fungsi untuk menyusun array; Tiga indeks yang perlu dipilih; Semak jika boleh menyusun array; Bertukar untuk membawa elemen pada kedudukan yang diperlukan membawa sekurang -kurangnya satu elemen pada kedudukan yang betul; Mengesan perubahan dalam array; Cetak array yang disusun; Jika tidak mungkin untuk menyusun; Kod pemacu", "code": "class GFG { static void sortArray ( int A [ ] , int N ) { int x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } System . out . print ( \" Sorted ▁ Array : ▁ \" ) ; for ( int i = 0 ; i < N ; i ++ ) System . out . print ( A [ i ] + \" ▁ \" ) ; } else { System . out . print ( \" - 1\" ) ; } } public static void main ( String [ ] args ) { int A [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = A . length ; sortArray ( A , N ) ; } }"}
{"text": "Cari k sedemikian rupa sehingga mengubah semua elemen array yang lebih besar daripada k ke k akan membuat jumlah array n | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan k sedemikian rupa sehingga mengubah semua elemen yang lebih besar daripada k ke k akan membuat jumlah array n sebaliknya kembali - 1; Menyusun array dalam peningkatan urutan; Gelung melalui semua elemen array; Memeriksa jika jumlah array sama dengan n; Kod pemacu", "code": "import java . util . * ; class GFG { static int findK ( int arr [ ] , int size , int N ) { Arrays . sort ( arr ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 1 , 10 , 4 , 8 } ; int size = arr . length ; int N = 16 ; System . out . print ( findK ( arr , size , N ) ) ; } }"}
{"text": "Cari tiga elemen dari tiga array yang diberikan supaya jumlah mereka adalah x | Tetapkan 2 | Pelaksanaan Java pendekatan; Fungsi yang kembali benar jika terdapat triplet dengan jumlah x; Menyusun susunan sedemikian rupa sehingga [] mewakili array terkecil; Mengalihkan array terkecil; Dua petunjuk pada array kedua dan ketiga; Jika triplet yang sah dijumpai;  ; Kod pemacu", "code": "class GFG { static boolean existsTriplet ( int a [ ] , int b [ ] , int c [ ] , int x , int l1 , int l2 , int l3 ) { if ( l2 <= l1 && l2 <= l3 ) { swap ( l2 , l1 ) ; swap ( a , b ) ; } else if ( l3 <= l1 && l3 <= l2 ) { swap ( l3 , l1 ) ; swap ( a , c ) ; } for ( int i = 0 ; i < l1 ; i ++ ) { int j = 0 , k = l3 - 1 ; while ( j < l2 && k >= 0 ) { if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; } private static void swap ( int x , int y ) { int temp = x ; x = y ; y = temp ; } private static void swap ( int [ ] x , int [ ] y ) { int [ ] temp = x ; x = y ; y = temp ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 7 , 8 , 10 , 15 } ; int b [ ] = { 1 , 6 , 7 , 8 } ; int c [ ] = { 4 , 5 , 5 } ; int l1 = a . length ; int l2 = b . length ; int l3 = c . length ; int x = 14 ; if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Susun nombor yang diberikan untuk membentuk nombor terkecil | Pelaksanaan Java pendekatan; Fungsi utiliti untuk mencetak kandungan array; Fungsi perbandingan yang kembali negatif jika 'ab' lebih kecil daripada 'ba' apabila kita menggabungkan dua nombor 'A' dan 'B' sebagai contoh, ia akan mengembalikan nilai negatif jika kita lulus 12 dan 24 sebagai argumen. Fungsi ini akan digunakan semasa jenis; Tukar nombor pertama ke format rentetan; Tukar nombor kedua ke format rentetan; Semak jika 'ab' lebih kecil atau 'ba' dan pulangkan nilai integer; Berfungsi untuk mencetak susunan dengan nilai terkecil; Susun menggunakan fungsi Bandingkan yang ditakrifkan di atas; Cetak array yang disusun; Kod pemacu", "code": "class GFG { public static void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] ) ; } public static int compare ( int num1 , int num2 ) { String A = Integer . toString ( num1 ) ; String B = Integer . toString ( num2 ) ; return ( A + B ) . compareTo ( B + A ) ; } public static void printSmallest ( int N , int [ ] arr ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( compare ( arr [ i ] , arr [ j ] ) > 0 ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } printArr ( arr , N ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 5 , 6 , 2 , 9 , 21 , 1 } ; int N = arr . length ; printSmallest ( N , arr ) ; } }"}
{"text": "Stabil Pemilihan Susun | Program Java untuk mengubahsuai pilihan pemilihan supaya ia menjadi stabil. ; Melangkah melalui elemen array; Cari elemen minimum dari arr [i] ke arr [n - 1]. ; Gerakkan elemen minimum pada semasa i. ; Kod pemacu", "code": "class GFG { static void stableSelectionSort ( int [ ] a , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } } static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + \" ▁ \" ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int [ ] a = { 4 , 5 , 3 , 2 , 4 , 1 } ; int n = a . length ; stableSelectionSort ( a , n ) ; printArray ( a , n ) ; } }"}
{"text": "Permut dua tatasusunan sedemikian rupa sehingga jumlah setiap pasangan lebih besar atau sama dengan k | Program Java untuk memeriksa sama ada permutasi dua tatasusunan memenuhi syarat [i] + b [i]> = k. ; Semak sama ada apa -apa permutasi wujud yang memenuhi syarat. ; Susun array a [] dalam urutan yang berkurangan. ; Susun array B [] dalam peningkatan urutan. ; Memeriksa keadaan pada setiap indeks. ; Kod pemacu", "code": "import java . util . * ; class GFG { static boolean isPossible ( Integer a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; } public static void main ( String [ ] args ) { Integer a [ ] = { 2 , 1 , 3 } ; int b [ ] = { 7 , 8 , 9 } ; int k = 10 ; int n = a . length ; if ( isPossible ( a , b , n , k ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text": "Sort Array mengikut kiraan bit set | Program Java untuk melaksanakan pendekatan mudah untuk menyusun array mengikut kiraan bit set. ; Fungsi untuk mengira setbit; Fungsi untuk disusun oleh SetBitCount; Melangkah ke atas semua nilai dan masukkan ke dalam multimap; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static int setBitCount ( int num ) { int count = 0 ; while ( num != 0 ) { if ( ( num & 1 ) != 0 ) count ++ ; num >>= 1 ; } return count ; } static void sortBySetBitCount ( int [ ] arr , int n ) { ArrayList < ArrayList < Integer > > count = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { count . add ( new ArrayList < Integer > ( Arrays . asList ( ( - 1 ) * setBitCount ( arr [ i ] ) , arr [ i ] ) ) ) ; } Collections . sort ( count , new Comparator < ArrayList < Integer > > ( ) { @ Override public int compare ( ArrayList < Integer > o1 , ArrayList < Integer > o2 ) { return o1 . get ( 0 ) . compareTo ( o2 . get ( 0 ) ) ; } } ) ; for ( int i = 0 ; i < count . size ( ) ; i ++ ) { System . out . print ( count . get ( i ) . get ( 1 ) + \" ▁ \" ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; sortBySetBitCount ( arr , n ) ; } }"}
{"text": "Semak jika akhir rentetan binari yang diberikan dapat dicapai dengan memilih nilai lompat di antara julat yang diberikan | Program Java untuk pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mencapai hujung rentetan binari menggunakan lompatan yang diberikan; Menyimpan negeri -negeri DP; Keadaan awal; Kedai -kedai mengira indeks dari mana ia mungkin untuk mencapai Indeks I; Melintasi rentetan yang diberikan; Mengemas kini nilai pra dengan sewajarnya; Jika saiz lompat keluar dari julat [l, r]; Jawapan kembali; Kod pemacu", "code": "public class GFG { static int canReach ( String s , int L , int R ) { int dp [ ] = new int [ s . length ( ) ] ; dp [ 0 ] = 1 ; int pre = 0 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( i >= L ) { pre += dp [ i - L ] ; } if ( i > R ) { pre -= dp [ i - R - 1 ] ; } if ( pre > 0 && s . charAt ( i ) == '0' ) dp [ i ] = 1 ; else dp [ i ] = 0 ; } return dp [ s . length ( ) - 1 ] ; } public static void main ( String [ ] args ) { String S = \"01101110\" ; int L = 2 , R = 3 ; if ( canReach ( S , L , R ) == 1 ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text": "Pecahkan array ke subarrays dengan bitwise maksimum XOR masing -masing bitwise atau nilai masing -masing | Program Java untuk pendekatan di atas; Fungsi rekursif untuk mencari semua kemungkinan pemecahan array ke subarrays dan cari maksimum bitwise XOR; Jika nilai n ialah 0; Menyimpan hasil jika kumpulan baru dibentuk dengan elemen pertama sebagai arr [i]; Kedai jika keputusan jika ARR [i] dimasukkan ke dalam kumpulan terakhir; Mengembalikan maksimum x dan y; Berfungsi untuk mencari maksimum bitwise xor dari semua nilai yang mungkin dari array selepas memecahkan tatasusunan ke subarrays; Mengembalikan hasilnya; Kod pemacu", "code": "public class GFG { static int maxXORUtil ( int arr [ ] , int N , int xrr , int orr ) { if ( N == 0 ) return xrr ^ orr ; int x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) ; int y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) ; return Math . max ( x , y ) ; } static int maximumXOR ( int arr [ ] , int N ) { return maxXORUtil ( arr , N , 0 , 0 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 7 } ; int N = arr . length ; System . out . println ( maximumXOR ( arr , N ) ) ; } }"}
{"text": "Bina N | Program Java untuk melaksanakan pendekatan di atas; Menjejaki nod yang dikunjungi; Berfungsi untuk membina pokok supaya tidak ada dua nod bersebelahan dengan berat yang sama; Jika elemen minimum dan maksimum adalah sama, i. e. Array mengandungi satu elemen yang berbeza; Pokok tidak boleh dibina; Jika tidak; Pokok boleh dibina; Pilih berat [0] sebagai akar; Node pertama dikunjungi; Melintasi array; Jika tidak, buat kelebihan; Tandakan nod ini seperti yang dikunjungi; Cari berat badan yang tidak sama dengan root & membuat tepi dengan nod itu; Sertai bukan akar dengan nod yang tinggal; Semak jika nod semasa berat ~ sama dengan berat badan dan jika ia tidak dikunjungi atau tidak; Kod pemacu; Panggilan fungsi", "code": "import java . lang . * ; import java . io . * ; import java . util . * ; class GFG { static int N = 100000 + 5 ; static int visited [ ] = new int [ N ] ; static void construct_tree ( int weights [ ] , int n ) { int minimum = Arrays . stream ( weights ) . min ( ) . getAsInt ( ) ; int maximum = Arrays . stream ( weights ) . max ( ) . getAsInt ( ) ; if ( minimum == maximum ) { System . out . println ( \" No \" ) ; return ; } else { System . out . println ( \" Yes \" ) ; } int root = weights [ 0 ] ; visited [ 1 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { System . out . println ( 1 + \" ▁ \" + ( i + 1 ) + \" ▁ \" ) ; visited [ i + 1 ] = 1 ; } } int notroot = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { notroot = i + 1 ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { System . out . println ( notroot + \" ▁ \" + ( i + 1 ) ) ; visited [ i + 1 ] = 1 ; } } } public static void main ( String [ ] args ) { int weights [ ] = { 1 , 2 , 1 , 2 , 5 } ; int N = weights . length ; construct_tree ( weights , N ) ; } }"}
{"text": "Kurangkan kos untuk menukar rentetan yang diberikan menjadi penyambungan substrings yang sama panjang k | Program Java untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk menukar rentetan yang diberikan ke dalam rentetan panjang K substring yang sama; Kedai panjang rentetan; Menyimpan kos minimum; Melintasi substring kiri panjang K; Menyimpan kekerapan; Kedai kos minimum untuk urutan indeks S [i] % K; Semak watak yang optimum; Cari jumlah jarak 'a' + ch dari indeks kara [i] % k; Pilih kos minimum untuk setiap indeks i; Kenaikan ans; Cetak kos minimum untuk menukar rentetan; Kod pemacu; Diberikan rentetan s; Panggilan fungsi", "code": "import java . util . * ; import java . lang . * ; class GFG { static void minCost ( String s , int k ) { int n = s . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int [ ] a = new int [ 26 ] ; for ( int j = i ; j < n ; j += k ) { a [ s . charAt ( j ) - ' a ' ] ++ ; } int min_cost = Integer . MAX_VALUE ; for ( int ch = 0 ; ch < 26 ; ch ++ ) { int cost = 0 ; for ( int tr = 0 ; tr < 26 ; tr ++ ) cost += Math . abs ( ch - tr ) * a [ tr ] ; min_cost = Math . min ( min_cost , cost ) ; } ans += min_cost ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { String S = \" abcdefabc \" ; int K = 3 ; minCost ( S , K ) ; } }"}
{"text": "Split First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Program Java untuk melaksanakan pendekatan di atas; Berfungsi untuk memecah nombor semulajadi N pertama ke dalam dua set yang mempunyai perbezaan mutlak minimum jumlah mereka; Kod pemacu", "code": "import java . io . * ; import java . util . * ; class GFG { static int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . println ( minAbsDiff ( N ) ) ; } }"}
{"text": "Cari padanan maksimum dalam pokok binari yang diberikan | Program Java untuk pendekatan di atas; Senarai Adjacency untuk menyimpan tepi; Tambah kelebihan antara u dan v dalam pokok; Kelebihan dari u ke v; Tepi dari v ke u; Fungsi yang mendapati pemadanan maksimum DFS; Pergi lebih jauh kerana kami tidak dibenarkan pergi ke arah ibu bapanya; Jika u dan ibu induknya tidak diambil maka kita mesti mengambil & menandakannya sebagai diambil; Saiz kenaikan set tepi; Berfungsi untuk mencari padanan maksimum dalam graf; Mengambil 1 sebagai akar pokok; Cetak padanan maksimum; Kod pemacu; Menyertai kelebihan antara dua nod dalam pokok; Panggilan fungsi", "code": "import java . util . * ; class GFG { static final int N = 10000 ; @ SuppressWarnings ( \" unchecked \" ) static Vector < Integer > [ ] adj = new Vector [ N ] ; static int used [ ] = new int [ N ] ; static int max_matching ; static void AddEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } static void Matching_dfs ( int u , int p ) { for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] . get ( i ) != p ) { Matching_dfs ( adj [ u ] . get ( i ) , u ) ; } } if ( used [ u ] == 0 && used [ p ] == 0 && p != 0 ) { max_matching ++ ; used [ u ] = used [ p ] = 1 ; } } static void maxMatching ( ) { Matching_dfs ( 1 , 0 ) ; System . out . print ( max_matching + \"NEW_LINE\"); } public static void main ( String [ ] args ) { for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; AddEdge ( 1 , 2 ) ; AddEdge ( 1 , 3 ) ; AddEdge ( 3 , 4 ) ; AddEdge ( 3 , 5 ) ; maxMatching ( ) ; } }"}
{"text": "Kurangkan kos untuk menukar dua tatasusunan yang diberikan | Program Java untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan kos minimum yang diperlukan untuk menukar dua tatasusunan; Mengembalikan jumlah kos minimum; Kod pemacu", "code": "class GFG { static int getMinCost ( int [ ] A , int [ ] B , int N ) { int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; } public static void main ( String [ ] args ) { int N = 3 ; int [ ] A = { 1 , 4 , 2 } ; int [ ] B = { 10 , 6 , 12 } ; System . out . print ( getMinCost ( A , B , N ) ) ; } }"}
{"text": "Cetak semua cara yang mungkin untuk menulis n sebagai jumlah dua atau lebih integer positif | Program Java untuk pendekatan di atas; Berfungsi untuk mencetak nilai yang disimpan dalam arr vektor; Melintasi arr vektor; Fungsi rekursif untuk mencetak cara yang berbeza di mana n boleh ditulis sebagai jumlah pada 2 atau lebih bilangan bulat positif; Jika n adalah sifar maka cetak cara ini memecahkan nombor; Bermula dari elemen sebelumnya dalam perwakilan sehingga n; Termasuk elemen semasa dari perwakilan; Fungsi panggilan sekali lagi dengan jumlah yang dikurangkan; Backtrack untuk mengeluarkan elemen semasa dari perwakilan; Kod pemacu; Diberikan jumlah n; Untuk menyimpan perwakilan melanggar N; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void printVector ( ArrayList < Integer > arr ) { if ( arr . size ( ) != 1 ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { System . out . print ( arr . get ( i ) + \" ▁ \" ) ; } System . out . println ( ) ; } } static void findWays ( ArrayList < Integer > arr , int i , int n ) { if ( n == 0 ) printVector ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . add ( j ) ; findWays ( arr , j , n - j ) ; arr . remove ( arr . size ( ) - 1 ) ; } } public static void main ( String [ ] args ) { int n = 4 ; ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; findWays ( arr , 1 , n ) ; } }"}
{"text": "Memaksimumkan kiraan penurunan berikutnya dari array yang diberikan | Program Java untuk menyusun semula array untuk menghasilkan pengurangan maksimum; Berfungsi untuk mengira berikutnya maksimum; Menyimpan kekerapan elemen array; Kedai kekerapan maksimum; Kemas kini kekerapan [i]; Mengemas kini berikutnya maksimum; Cetak hasilnya; Kod pemacu", "code": "import java . util . HashMap ; import java . util . Map ; public class Main { public static void Maximum_subsequence ( int [ ] A , int N ) { HashMap < Integer , Integer > frequency = new HashMap < > ( ) ; int max_freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( frequency . containsKey ( A [ i ] ) ) { frequency . replace ( A [ i ] , frequency . get ( A [ i ] ) + 1 ) ; } else { frequency . put ( A [ i ] , 1 ) ; } } for ( Map . Entry it : frequency . entrySet ( ) ) { if ( ( int ) it . getValue ( ) > max_freq ) { max_freq = ( int ) it . getValue ( ) ; } } System . out . println ( max_freq ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 6 , 5 , 2 , 4 , 5 , 2 } ; int N = arr . length ; Maximum_subsequence ( arr , N ) ; } }"}
{"text": "Semak jika rentetan boleh dibahagikan kepada dua rentetan dengan bilangan k | yang sama Program Java untuk masalah di atas; Berfungsi untuk mencetak susunan aksara; Kedai kekerapan aksara; Hitung watak yang mempunyai kekerapan k; Hitung watak yang mempunyai kekerapan lebih besar daripada k dan tidak sama dengan 2 k; Kes 1; Kes 2; Kes 3; Jika semua kes gagal; Kod pemacu", "code": "import java . util . * ; class GFG { public static void DivideString ( String s , int n , int k ) { int i , c = 0 , no = 1 ; int c1 = 0 , c2 = 0 ; int [ ] fr = new int [ 26 ] ; char [ ] ans = new char [ n ] ; for ( i = 0 ; i < n ; i ++ ) { fr [ s . charAt ( i ) - ' a ' ] ++ ; } char ch = ' a ' , ch1 = ' a ' ; for ( i = 0 ; i < 26 ; i ++ ) { if ( fr [ i ] == k ) { c ++ ; } if ( fr [ i ] > k && fr [ i ] != 2 * k ) { c1 ++ ; ch = ( char ) ( i + ' a ' ) ; } if ( fr [ i ] == 2 * k ) { c2 ++ ; ch1 = ( char ) ( i + ' a ' ) ; } } for ( i = 0 ; i < n ; i ++ ) ans [ i ] = '1' ; HashMap < Character , Integer > mp = new HashMap < > ( ) ; if ( c % 2 == 0 c1 > 0 c2 > 0 ) { for ( i = 0 ; i < n ; i ++ ) { if ( fr [ s . charAt ( i ) - ' a ' ] == k ) { if ( mp . containsKey ( s . charAt ( i ) ) ) { ans [ i ] = '2' ; } else { if ( no <= ( c / 2 ) ) { ans [ i ] = '2' ; no ++ ; mp . replace ( s . charAt ( i ) , 1 ) ; } } } } if ( ( c % 2 == 1 ) && ( c1 > 0 ) ) { no = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ch && no <= k ) { ans [ i ] = '2' ; no ++ ; } } } if ( c % 2 == 1 && c1 == 0 ) { no = 1 ; int flag = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ch1 && no <= k ) { ans [ i ] = '2' ; no ++ ; } if ( fr [ s . charAt ( i ) - ' a ' ] == k && flag == 0 && ans [ i ] == '1' ) { ans [ i ] = '2' ; flag = 1 ; } } } System . out . println ( ans ) ; } else { System . out . println ( \" NO \" ) ; } } public static void main ( String [ ] args ) { String S = \" abbbccc \" ; int N = S . length ( ) ; int K = 1 ; DivideString ( S , N , K ) ; } }"}
{"text": "Semak jika dua item boleh dipilih dari dua kategori yang berbeza tanpa harga yang melebihi | Pelaksanaan Java untuk memeriksa sama ada dua item boleh dipilih dari dua kategori yang berbeza tanpa melebihi jumlah harga; Fungsi untuk memeriksa sama ada dua item boleh dipilih dari dua kategori yang berbeza tanpa melebihi jumlah harga; Gelung untuk memilih dua pasangan yang berbeza menggunakan dua gelung bersarang; Keadaan untuk memeriksa sama ada harga kedua -dua elemen ini kurang daripada S; Kod pemacu; Panggilan fungsi", "code": "import java . util . * ; class GFG { static String check ( int S , int prices [ ] , int type [ ] , int n ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return \" Yes \" ; } } } } return \" No \" ; } public static void main ( String [ ] args ) { int prices [ ] = { 3 , 8 , 6 , 5 } ; int type [ ] = { 0 , 1 , 1 , 0 } ; int S = 10 ; int n = 4 ; System . out . print ( check ( S , prices , type , n ) ) ; } }"}
{"text": "Cari jumlah maksimum (a + b) untuk integer input yang diberikan dan memenuhi syarat yang diberikan | Pelaksanaan Java untuk mencari nilai terbesar A + B yang memenuhi syarat yang diberikan; Berfungsi untuk mengembalikan jumlah maksimum A + B yang memenuhi syarat yang diberikan; Memulakan max_sum; Pertimbangkan semua pasangan yang mungkin dan periksa jumlah yang membahagikan harta produk; Untuk mencari faktor terbesar k; Semak sama ada produk itu boleh dibahagikan dengan jumlah; Menyimpan jumlah maksimum dalam pembolehubah max_sum; Kembalikan nilai max_sum; Kod pemacu", "code": "class GFG { static int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = Math . max ( max_sum , a + b ) ; } } return max_sum ; } public static void main ( String [ ] args ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; System . out . print ( max_sum + \"NEW_LINE\"); } }"}
{"text": "Menyulitkan rentetan dengan mengulangi i | Pelaksanaan Java pendekatan; Berfungsi untuk mengembalikan rentetan yang disulitkan; Bilangan kali watak semasa akan diulang; Ulangi watak semasa dalam rentetan yang disulitkan; Kod pemacu", "code": "class GFG { static String encryptString ( String str , int n ) { int i = 0 , cnt = 0 ; String encryptedStr = \" \" ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- > 0 ) encryptedStr += str . charAt ( i ) ; i ++ ; } return encryptedStr ; } public static void main ( String [ ] args ) { String str = \" geeks \" ; int n = str . length ( ) ; System . out . println ( encryptString ( str , n ) ) ; } }"}
{"text": "Kurangkan perbezaan antara nilai maksimum dan minimum array yang diubah suai | Program Java untuk mencari perbezaan minimum. ; Fungsi untuk mengembalikan perbezaan minimum yang diperlukan; mencari nilai minimum dan maksimum; mengembalikan perbezaan minimum yang mungkin; Program pemacu; berfungsi untuk mengembalikan jawapannya", "code": "import java . util . * ; class GFG { static int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; } public static void main ( String [ ] args ) { int n = 3 , x = 3 ; int A [ ] = { 1 , 3 , 6 } ; System . out . println ( minDiff ( n , x , A ) ) ; } }"}
{"text": "Swap minimum untuk mengimbangi pendakap | Program Java untuk mengira swap yang diperlukan untuk mengimbangi rentetan; Kedai Jumlah bilangan kurungan kiri dan kanan yang ditemui; Swap menyimpan bilangan swap yang diperlukan ketidakseimbangan mengekalkan bilangan pasangan ketidakseimbangan; kiraan kenaikan kurungan kiri; kiraan swap adalah kiraan swap terakhir + jumlah kurungan tidak seimbang; ketidakseimbangan yang diturunkan oleh 1 kerana ia hanya menyelesaikan satu ketidakseimbangan kiri dan kanan; kiraan kenaikan kurungan kanan; Ketidakseimbangan diset semula kepada perbezaan semasa antara kurungan kiri dan kanan; Kod pemacu", "code": "public class BalanceParan { static long swapCount ( String s ) { char [ ] chars = s . toCharArray ( ) ; int countLeft = 0 , countRight = 0 ; int swap = 0 , imbalance = 0 ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( chars [ i ] == ' [ ' ) { countLeft ++ ; if ( imbalance > 0 ) { swap += imbalance ; imbalance -- ; } } else if ( chars [ i ] == ' ] ' ) { countRight ++ ; imbalance = ( countRight - countLeft ) ; } } return swap ; } public static void main ( String args [ ] ) { String s = \" [ ] ] [ ] [ \" ; System . out . println ( swapCount ( s ) ) ; s = \" [ [ ] [ ] ] \" ; System . out . println ( swapCount ( s ) ) ; } }"}
{"text": "Paling terpanjang dari pelbagai pasangan yang mempunyai elemen pertama yang semakin meningkat dan elemen kedua berkurangan. | Program Java untuk pendekatan di atas; Fungsi untuk mencari panjang pasang pasang terpanjang yang elemen pertama yang semakin meningkat dan kedua berkurangan; dp [i]: Menyimpan selanjutnya yang terpanjang sehingga i; Kes asas; Apabila keadaan memegang; Akhirnya, cetak jawapan yang diperlukan; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "class GFG { public static void longestSubSequence ( int [ ] [ ] A , int N ) { int [ ] dp = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] && A [ j ] [ 1 ] > A [ i ] [ 1 ] ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } } System . out . println ( dp [ N - 1 ] ) ; } public static void main ( String args [ ] ) { int [ ] [ ] A = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = A . length ; longestSubSequence ( A , N ) ; } }"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Program Java untuk pendekatan di atas; Fungsi untuk mengira jumlah cara untuk mempunyai jumlah n; Kes asas; Kembali hasil yang telah disimpan; Berulang untuk semua 6 negeri; Mengembalikan hasilnya; Kod pemacu; Diberikan jumlah n; Memulakan array DP; Panggilan fungsi", "code": "import java . util . * ; class GFG { static int findWays ( int N , int dp [ ] ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != - 1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; } public static void main ( String [ ] args ) { int N = 4 ; int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ; System . out . print ( findWays ( N , dp ) ) ; } }"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Program Java untuk pendekatan di atas; Fungsi untuk mengira jumlah cara untuk mempunyai jumlah n; Memulakan array DP; Melangkah ke atas semua nilai perantaraan yang mungkin untuk mencapai n; Kirakan jumlah untuk semua 6 muka; Cetak jumlah cara; Kod pemacu; Diberikan jumlah n; Panggilan fungsi", "code": "import java . util . * ; class GFG { static void findWays ( int N ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } System . out . print ( dp [ N ] ) ; } public static void main ( String [ ] args ) { int N = 4 ; findWays ( N ) ; } }"}
{"text": "Pecahkan rentetan ke bahagian minimum supaya setiap bahagian berada dalam rentetan lain | Pelaksanaan Java untuk memecah rentetan ke dalam bilangan minimum bahagian supaya setiap bahagian juga terdapat dalam rentetan lain; Nod trie; Berfungsi untuk memasukkan nod dalam struktur data trie; Memasukkan setiap watak dari IDX hingga hujung ke rentetan ke dalam trie; Sekiranya tidak ada kelebihan yang sepadan dengan watak ITH, maka buat nod baru; Berfungsi untuk mencari bilangan minimum bahagian supaya setiap bahagian hadir ke dalam rentetan lain; Membuat trie baru; Memasukkan setiap substring S2 di Trie; Mewujudkan array DP dan init dengan tak terhingga; Kes asas; Memulakan pemotongan dari watak yang mengambil penunjuk nod sementara untuk memeriksa sama ada substring [i, j) hadir dalam trie tidak; Sekiranya watak JTH tidak berada di Trie, kami akan berehat; Mengemas kini berakhirnya watak jth dengan dp [i] + 1; Menurunkan penunjuk Trie; Jawapan tidak mungkin; Kod pemacu", "code": "import java . util . * ; class GFG { static int INF = ( int ) ( 1e9 + 9 ) ; static class TrieNode { TrieNode [ ] child = new TrieNode [ 26 ] ; } ; static void insert ( int idx , String s , TrieNode root ) { TrieNode temp = root ; for ( int i = idx ; i < s . length ( ) ; i ++ ) { if ( temp . child [ s . charAt ( i ) - ' a ' ] == null ) temp . child [ s . charAt ( i ) - ' a ' ] = new TrieNode ( ) ; temp = temp . child [ s . charAt ( i ) - ' a ' ] ; } } static int minCuts ( String S1 , String S2 ) { int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ; TrieNode root = new TrieNode ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) { insert ( i , S2 , root ) ; } int [ ] dp = new int [ n1 + 1 ] ; Arrays . fill ( dp , INF ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { TrieNode temp = root ; for ( int j = i + 1 ; j <= n1 ; j ++ ) { if ( temp . child [ S1 . charAt ( j - 1 ) - ' a ' ] == null ) break ; dp [ j ] = Math . min ( dp [ j ] , dp [ i ] + 1 ) ; temp = temp . child [ S1 . charAt ( j - 1 ) - ' a ' ] ; } } if ( dp [ n1 ] >= INF ) return - 1 ; else return dp [ n1 ] ; } public static void main ( String [ ] args ) { String S1 = \" abcdab \" ; String S2 = \" dabc \" ; System . out . print ( minCuts ( S1 , S2 ) ) ; } }"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | Pelaksanaan Java untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Berfungsi untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Precomputation of Prefix CountDP Jumlah matriks; Gelung untuk menyelesaikan setiap pertanyaan; Carian binari ke sisi yang mempunyai atmost dalam k 1 's di persegi; Kira jumlah 1 s dalam sub persegi yang dipertimbangkan; Jika kiraan kurang daripada atau sama dengan langkah maksimum ke separuh kanan; Kod pemacu", "code": "import java . util . * ; class GFG { static void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ ] [ ] = new int [ R ] [ C ] ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) countDP [ i ] [ j ] = 0 ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 , l = 0 , u = min_dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } System . out . println ( ans ) ; } } public static void main ( String args [ ] ) { int matrix [ ] [ ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }"}
