{"text": "Jumlah minimum mungkin dengan mengeluarkan semua kejadian mana -mana elemen array | Berfungsi untuk mencari jumlah minimum selepas penghapusan; Kedai kekerapan elemen array; Melintasi array; Hitung jumlah; Kekerapan kemas kini elemen semasa; Menyimpan jumlah minimum yang diperlukan; Peta Traverse; Cari jumlah minimum yang diperoleh; Kembali jumlah minimum; Arahan input; Saiz array", "code": "function minSum ( A , N ) { let mp = new Map ( ) ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; mp [ A [ i ] ] ++ ; if ( mp . has ( A [ i ] ) ) { mp . set ( A [ i ] , mp . get ( A [ i ] ) + 1 ) } else { mp . set ( A [ i ] , 1 ) } } let minSum = Number . MAX_SAFE_INTEGER ; for ( let it of mp ) { minSum = Math . min ( minSum , sum - ( it [ 0 ] * it [ 1 ] ) ) ; } return minSum ; } let arr = [ 4 , 5 , 6 , 6 ] ; let N = arr . length document . write ( minSum ( arr , N ) + \" \" ) ;"}
{"text": "Perbezaan maksimum antara sepasang elemen bersebelahan dengan tidak termasuk setiap elemen sekali | Fungsi untuk mengira perbezaan maksimum antara elemen bersebelahan tidak termasuk setiap elemen array sekali; Melintasi array; Menyimpan perbezaan maksimum; Semak elemen bersebelahan maksimum; Tidak termasuk elemen semasa; Mengemas kini perbezaan maksimum; Mengemas kini nilai sebelumnya; Tambah hasilnya ke dalam vektor; Cetak hasilnya; Kod pemacu", "code": "function maxAdjacent ( arr , N ) { var res = [ ] ; for ( var i = 1 ; i < N - 1 ; i ++ ) { var prev = arr [ 0 ] ; var maxi = Number . MIN_VALUE ; for ( var j = 1 ; j < N ; j ++ ) { if ( i == j ) continue ; maxi = Math . max ( maxi , Math . abs ( arr [ j ] - prev ) ) ; prev = arr [ j ] ; } res . push ( maxi ) ; } for ( var j = 0 ; j < res . length ; j ++ ) document . write ( res [ j ] + \" \" ) ; document . write ( \" \" ) ; } var arr = [ 1 , 3 , 4 , 7 , 8 ] ; var N = arr . length ; maxAdjacent ( arr , N ) ;"}
{"text": "Kira 1 S hadir dalam pelbagai indeks [l, r] dalam array yang diberikan | Berfungsi untuk mencari saiz array jika array pada mulanya mengandungi elemen tunggal; Kes asas; P / 2 -> findSize (n / 2) p % 2 -> 1 p / 2 -> findSize (n / 2); Berfungsi untuk mengembalikan kiraan 1 s dalam julat [l, r]; Kes asas; Bahagian 1 -> n / 2 [1, siz_m]; Kemas kini titik akhir kanan julat ke min (Siz_m, r); Bahagian 2 -> n % 2 [Sizm + 1, Siz_m + 1]; Bahagian 3 -> n / 2 [sizm + 2, 2 * siz_m - 1] Sama seperti bahagian 1 harta simetrik beralih koordinat mengikut bahagian 1 tolak (siz_m + 1) dari kedua -dua l, r; Input; Mengira bilangan 1 dalam julat [l, r]", "code": "function findSize ( N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; let Size = 2 * findSize ( parseInt ( N / 2 , 10 ) ) + 1 ; return Size ; } function CountOnes ( N , L , R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } let ret = 0 ; let M = parseInt ( N / 2 , 10 ) ; let Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( parseInt ( N / 2 , 10 ) , L , Math . min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( parseInt ( N / 2 , 10 ) , Math . max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; } let N = 7 , L = 2 , R = 5 ; document . write ( CountOnes ( N , L , R ) ) ;"}
{"text": "Cari pasangan (a, b) dengan LCM minimum supaya jumlahnya sama dengan n | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kerana 1 bukan pulangan utama atau komposit palsu; Semak jika ia dibahagikan dengan mana -mana nombor maka ia bukan perdana, kembali palsu; Semak jika n tidak dibahagikan dengan mana -mana nombor maka ia adalah perdana dan oleh itu kembali benar; Fungsi untuk mencari pasangan (a, b) seperti jumlah yang N & LCM adalah minimum; Semak sama ada nombor itu adalah perdana; Sekarang, jika tidak perdana maka cari yang paling kurang divisior; Semak jika membahagikan n maka ia adalah faktor; Output yang diperlukan ialah A = N / I & B = N / I * (n - 1); Kod pemacu; Panggilan fungsi", "code": "function prime ( n ) { if ( n == 1 ) return false ; for ( i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } function minDivisior ( n ) { if ( prime ( n ) ) { document . write ( 1 + \" \" + ( n - 1 ) ) ; } else { for ( i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { document . write ( n / i + \" \" + ( n / i * ( i - 1 ) ) ) ; break ; } } } } var N = 4 ; minDivisior ( N ) ;"}
{"text": "Cari fungsi Landau untuk nombor tertentu n | Untuk menyimpan fungsi Landau nombor; Berfungsi untuk mengembalikan GCD sebanyak 2 nombor; Berfungsi untuk mengembalikan LCM dua nombor; Fungsi untuk mencari nilai lcm max di antara semua perwakilan n; Hitung nilai Landau; Fungsi rekursif untuk mencari cara yang berbeza di mana n boleh ditulis sebagai jumlah atleast satu bilangan bulat positif; Semak jika jumlah menjadi n, pertimbangkan perwakilan ini; Bermula dari elemen sebelumnya dalam perwakilan sehingga n; Termasuk elemen semasa dari perwakilan; Fungsi panggilan sekali lagi dengan jumlah yang dikurangkan; Backtrack - Keluarkan elemen semasa dari perwakilan; Berfungsi untuk mencari fungsi Landau; Menggunakan kambuhan mencari cara yang berbeza di mana n boleh ditulis sebagai sejumlah atleast satu + ve integer; Cetak hasilnya; Diberikan n; Panggilan fungsi", "code": "var Landau = - 1000000000 ; function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function lcm ( a , b ) { return ( a * b ) / gcd ( a , b ) ; } function findLCM ( arr ) { var nth_lcm = arr [ 0 ] ; for ( var i = 1 ; i < arr . length ; i ++ ) nth_lcm = lcm ( nth_lcm , arr [ i ] ) ; Landau = Math . max ( Landau , nth_lcm ) ; } function findWays ( arr , i , n ) { if ( n == 0 ) findLCM ( arr ) ; for ( var j = i ; j <= n ; j ++ ) { arr . push ( j ) ; findWays ( arr , j , n - j ) ; arr . pop ( ) ; } } function Landau_function ( n ) { arr = [ ] ; findWays ( arr , 1 , n ) ; document . write ( Landau ) ; } var N = 4 ; Landau_function ( N ) ;"}
{"text": "Semak jika baki N | Fungsi untuk memeriksa sama ada nombor memegang syarat (n - 1)! % N = n - 1; Kes sudut; Nombor yang boleh dibahagikan dengan 2 atau 3 bukanlah perdana; Melangkah dari 5 dan terus memeriksa perdana; Fungsi untuk memeriksa ungkapan untuk nilai n; Kod pemacu", "code": "function isPrime ( n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function checkExpression ( n ) { if ( isPrime ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let N = 3 ; checkExpression ( N ) ;"}
{"text": "Semak sama ada mungkin untuk memecah array yang diberikan ke dalam K Odd | Fungsi untuk memeriksa sama ada array boleh dibahagikan dalam subset k yang diperlukan; Menyimpan kiraan nombor ganjil; Semak jika elemen ganjil; Semak jika perpecahan mungkin; Kod pemacu", "code": "function checkArray ( n , k , arr ) { var cnt = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; } var arr = [ 1 , 3 , 4 , 7 , 5 , 3 , 1 ] ; var n = arr . length ; var k = 4 ; if ( checkArray ( n , k , arr ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Jumlah pembahagian pasangan yang mungkin untuk array yang diberikan | Berfungsi untuk mengira jumlah; Mengira kekerapan setiap istilah dan mencari maksimum di antara ia; Membuat kekerapan kumulatif; Mengambil nilai Ceil; nos. Dalam julat [(n - 0.5) x, (n + 0.5) x) akan menambah n ke ANS; Mengembalikan hasil akhir; Kod pemacu", "code": "function func ( arr , n ) { let ans = 0 ; let maxx = 0 ; let freq = Array . from ( { length : 100005 } , ( _ , i ) => 0 ) ; let temp ; for ( let i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = Math . max ( maxx , temp ) ; } for ( let i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( let i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] != 0 ) { let j ; let cur = Math . ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { let val = Math . min ( maxx , ( Math . ceil ( i * j ) - 1.0 ) ) ; let times = ( freq [ i ] - freq [ i - 1 ] ) , con = ( j - 0.5 ) ; ans += times * con * ( freq [ val ] - freq [ cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ans ; } let arr = [ 1 , 2 , 3 ] ; let n = arr . length ; document . write ( func ( arr , n ) ) ;"}
{"text": "Count of Elements hendaklah dimasukkan untuk membuat array Jumlah dua kali xor array | Fungsi untuk mencari bilangan elemen minimum yang perlu dimasukkan supaya jumlah unsur -unsur array adalah dua kali ganda XOR array; Pembolehubah untuk menyimpan XOR semua elemen; Pembolehubah untuk menyimpan jumlah semua elemen; Gelung untuk mencari XOR dan jumlah array; Jika jumlah = 2 * xor; Tidak perlu memasukkan lebih banyak elemen; Kami memasukkan satu lagi elemen yang jumlahnya; Kami memasukkan dua lagi elemen SUM + XOR dan XOR. ; Cetak bilangan elemen yang dimasukkan dalam array; Cetak unsur -unsur yang dimasukkan dalam array; Kod pemacu", "code": "function insert_element ( a , n ) { let Xor = 0 ; let Sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; } if ( Sum == 2 * Xor ) { document . write ( \" \" + \" \" ) ; return ; } if ( Xor == 0 ) { document . write ( \" \" + \" \" ) ; document . write ( Sum + \" \" ) ; return ; } let num1 = Sum + Xor ; let num2 = Xor ; document . write ( \" \" + \" \" ) ; document . write ( num1 + \" \" + num2 + \" \" ) ; } let a = [ 1 , 2 , 3 ] ; let n = a . length ; insert_element ( a , n ) ;"}
{"text": "Periksa sama ada akar persamaan kuadrat adalah timbal balik antara satu sama lain atau tidak | Berfungsi untuk memeriksa sama ada akar persamaan kuadratik adalah timbal balik antara satu sama lain atau tidak; Kod pemacu", "code": "function checkSolution ( a , b , c ) { if ( a == c ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ;"}
{"text": "Nombor Sunny | Periksa fungsi sama ada x adalah persegi yang sempurna atau tidak; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Berfungsi untuk memeriksa nombor cerah; Semak jika (n + 1) adalah persegi yang sempurna atau tidak; Jika (n + 1) bukan persegi yang sempurna; Nombor yang diberikan; Panggilan fungsi", "code": "function isPerfectSquare ( x ) { var sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } function checkSunnyNumber ( N ) { if ( isPerfectSquare ( N + 1 ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } var N = 8 ; checkSunnyNumber ( N ) ;"}
{"text": "Kira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan | Fungsi untuk mengira nombor yang boleh menukar n ke 1 menggunakan operasi yang diberikan; Melangkah melalui semua bilangan bulat; Semak jika n boleh ditukar kepada 1; Meningkatkan kiraan jika ia boleh ditukar; Kod pemacu", "code": "function countValues ( n ) { let answer = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { let k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; } let N = 6 ; document . write ( countValues ( N ) ) ;"}
{"text": "Cari nombor k dengan jumlah yang sama dengan N dan jumlah kotak mereka dimaksimumkan | Fungsi yang mencetak nombor k yang diperlukan; Cetak 1, k - 1 kali; Cetak (n - k + 1);", "code": "function printKNumbers ( N , K ) { for ( let i = 0 ; i < K - 1 ; i ++ ) document . write ( 1 + \" \" ) ; document . write ( N - K + 1 ) ; } let N = 10 , K = 3 ; printKNumbers ( N , K ) ;"}
{"text": "Cetak nth larian atau nombor autobiografi | Berfungsi untuk mencari nombor semula jadi yang melangkah; Mengisytiharkan barisan; Enqueue 1, 2, ..., 9 dalam perintah ini; Melakukan operasi k pada barisan; Dapatkan nombor langkah itu; Melakukan dequeue dari barisan; Jika x mod 10 tidak sama dengan 0; Kemudian enqueue 10 x + (x mod 10) - 1; Enqueue 10 x + (x mod 10); Jika x mod 10 tidak sama dengan 9; Kemudian enqueue 10 x + (x mod 10) + 1; Kembalikan jumlah operasi K - th sebagai nombor loncatan n; permulaan k", "code": "function NthSmallest ( K ) { var Q = [ ] ; var x ; for ( var i = 1 ; i < 10 ; i ++ ) Q . push ( i ) ; for ( var i = 1 ; i <= K ; i ++ ) { x = Q [ 0 ] ; Q . shift ( ) ; if ( x % 10 != 0 ) { Q . push ( x * 10 + x % 10 - 1 ) ; } Q . push ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . push ( x * 10 + x % 10 + 1 ) ; } } return x ; } var N = 16 ; document . write ( NthSmallest ( N ) ) ;"}
{"text": "Paling kurang nombor yang akan ditambah atau dikurangkan dari n untuk menjadikannya persegi yang sempurna | Berfungsi untuk mengembalikan nombor paling sedikit; Dapatkan persegi yang sempurna sebelum dan selepas n; Periksa yang paling dekat dengan n; mengembalikan hasilnya; Kod pemacu", "code": "function nearest ( n ) { var prevSquare = parseInt ( Math . sqrt ( n ) ) ; var nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; if ( ( n - prevSquare ) < ( nextSquare - n ) ) { ans = parseInt ( ( prevSquare - n ) ) ; } else ans = parseInt ( ( nextSquare - n ) ) ; return ans ; } var n = 14 ; document . write ( nearest ( n ) + \" \" ) ; n = 16 ; document . write ( nearest ( n ) + \" \" ) ; n = 18 ; document . write ( nearest ( n ) + \" \" ) ;"}
{"text": "Nilai pi (Î) sehingga 50 tempat perpuluhan | Fungsi yang mencetak nilai tempat perpuluhan Pi; Cari nilai PI sehingga menggunakan fungsi ACOS (); Cetak nilai Pi sehingga tempat perpuluhan; Kod pemacu; Fungsi yang mencetak nilai pi", "code": "function printValueOfPi ( N ) { let pi = 2 * Math . acos ( 0.0 ) ; document . write ( pi . toFixed ( 4 ) ) ; } let N = 4 ; printValueOfPi ( N ) ;"}
{"text": "Balikkan kth yang paling penting n | Berfungsi untuk menukar nombor perpuluhan n ke perwakilan binari yang disimpan sebagai array arr []; Berfungsi untuk menukar nombor yang diwakili sebagai array perduaan [] ke dalam setara perpuluhannya; Berfungsi untuk mengembalikan integer yang dikemas kini selepas membalikkan kth; Bilangan bit dalam n; Cari perwakilan binari n; Bilangan bit dalam n adalah kurang daripada k; Flip bit kth; Mengembalikan setara perpuluhan nombor; Kod pemacu", "code": "function decBinary ( arr , n ) { let k = parseInt ( Math . log2 ( n ) , 10 ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n = parseInt ( n / 2 , 10 ) ; } } function binaryDec ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } function getNum ( n , k ) { let l = parseInt ( Math . log2 ( n ) , 10 ) + 1 ; let a = new Array ( l ) ; a . fill ( 0 ) ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; } let n = 56 , k = 2 ; document . write ( getNum ( n , k ) ) ;"}
{"text": "Pertanyaan untuk produk Factorial N First | Pelaksanaan JavaScript pendekatan; Mengisytiharkan hasil hasil di seluruh dunia; Berfungsi untuk precompute produk faktorial sehingga max; Inisialisasi keadaan asas jika n = 0 maka faktorial 0 adalah sama dengan 1 dan jawapan untuk n = 0 ialah 1; Gelung berulang dari 1 hingga max; faktorial (i) = factorial (i - 1) * i; Keputusan untuk n semasa adalah sama dengan hasil [i - 1] didarabkan oleh faktorial i; Berfungsi untuk melakukan pertanyaan; Precomputing hasil sehingga max; Melakukan pertanyaan; Kod pemacu", "code": "let MAX = 1000000 ; let MOD = 10000007 ; let result = new Array ( MAX + 1 ) ; result . fill ( 0 ) ; let fact = new Array ( MAX + 1 ) ; fact . fill ( 0 ) ; function preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( let i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } function performQueries ( q , n ) { preCompute ( ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( result [ q [ i ] ] + \" \" ) ; } let q = [ 4 , 5 ] ; let n = q . length ; performQueries ( q , n ) ;"}
{"text": "Nombor nth dalam satu set gandaan a, b atau c | Berfungsi untuk mengembalikan GCD A dan B; Fungsi untuk mengembalikan kiraan bilangan bulat dari julat [1, num] yang boleh dibahagikan dengan sama ada A, B atau C; Kirakan bilangan istilah yang boleh dibahagikan dengan A, B dan C kemudian keluarkan istilah yang boleh dibahagikan dengan kedua -dua (a, b) atau (b, c) atau (c, a) dan kemudian tambah nombor yang boleh dibahagikan dengan a, b dan c; Fungsi untuk carian binari untuk mencari istilah n yang boleh dibahagikan dengan a, b atau c; Tetapkan rendah hingga 1 dan tinggi ke long_max; Jika istilah semasa kurang daripada n maka kita perlu meningkat rendah hingga pertengahan + 1; Jika istilah semasa lebih besar daripada sama dengan n maka tinggi = pertengahan; Kod pemacu", "code": "function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function divTermCount ( a , b , c , num ) { return parseInt ( ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( ( ( a * b ) / gcd ( a , b ) ) * c ) / gcd ( ( ( a * b ) / gcd ( a , b ) ) , c ) ) ) ) ) ; } function findNthTerm ( a , b , c , n ) { var low = 1 , high = Number . MAX_SAFE_INTEGER , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; } var a = 2 , b = 3 , c = 5 , n = 100 ; document . write ( parseInt ( findNthTerm ( a , b , c , n ) ) ) ;"}
{"text": "Sudut antara 3 simpang yang diberikan dalam n | Fungsi yang memeriksa sama ada sudut yang diberikan boleh dibuat menggunakan mana -mana 3 sisi; Memulakan x dan y; Kirakan bilangan simpang antara i dan j, j dan k; Kirakan sudut yang diselaraskan di lilitan; Sudut yang diselaraskan di J boleh didapati menggunakan hakikat bahawa jumlah sudut segitiga adalah sama dengan 180 darjah; Kod pemacu", "code": "function calculate_angle ( n , i , j , k ) { var x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; var ang1 = ( 180 * x ) / n ; var ang2 = ( 180 * y ) / n ; var ans = 180 - ang1 - ang2 ; return ans ; } var n = 5 ; var a1 = 1 ; var a2 = 2 ; var a3 = 5 ; document . write ( parseInt ( calculate_angle ( n , a1 , a2 , a3 ) ) ) ;"}
{"text": "Kerugian apabila dua item dijual pada harga yang sama dan keuntungan / kerugian peratusan yang sama | Fungsi yang akan mendapati kerugian; Kod pemacu; Fungsi panggilan", "code": "function Loss ( SP , P ) { var loss = 0 ; loss = ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; document . write ( \" \" + loss . toFixed ( 3 ) ) ; } var SP = 2400 , P = 30 ; Loss ( SP , P ) ;"}
{"text": "Semak elemen array iaitu CO | Pelaksanaan JavaScript pendekatan; Menyimpan faktor utama terkecil untuk setiap nombor; Hash untuk menyimpan kiraan faktor utama; Fungsi untuk mengira SPF (faktor utama terkecil) untuk setiap nombor sehingga maxn; Menandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Memeriksa jika saya adalah perdana; Menandakan SPF untuk semua nombor yang boleh dibahagi oleh i; Menandakan SPF [J] jika ia tidak ditandakan sebelum ini; Berfungsi untuk menyimpan faktor utama selepas membahagikan faktor utama terkecil di setiap langkah; Menyimpan kiraan faktor utama dalam hash; Fungsi yang mengembalikan benar jika tidak ada faktor utama yang sama antara x dan nombor array lain; Memeriksa sama ada faktor utama yang biasa dengan nombor lain; Fungsi yang mengembalikan benar jika terdapat elemen dalam array yang coprime dengan semua elemen lain dari array; Menggunakan ayak untuk menjana faktor utama; Memeriksa faktor utama biasa dengan nombor lain; Kod pemacu", "code": "let MAXN = 1000001 ; let spf = new Array ( MAXN ) ; let hash1 = new Array ( MAXN ) ; function sieve ( ) { spf [ 1 ] = 1 ; for ( let i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( let i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( let i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( let j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } function getFactorization ( x ) { let temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } } function check ( x ) { let temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; } function hasValidNum ( arr , n ) { sieve ( ) ; for ( let i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; } let arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] ; let n = arr . length ; if ( hasValidNum ( arr , n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Cara untuk mengeluarkan tepi dari graf lengkap untuk membuat tepi ganjil | Berfungsi untuk mengembalikan bilangan cara untuk mengeluarkan tepi dari graf supaya bilangan tepi yang ganjil ditinggalkan dalam graf; Jumlah bilangan tepi; Kod pemacu", "code": "function countWays ( N ) { let E = parseInt ( ( N * ( N - 1 ) ) / 2 , 10 ) ; if ( N == 1 ) return 0 ; return Math . pow ( 2 , E - 1 ) ; } let N = 4 ; document . write ( countWays ( N ) ) ;"}
{"text": "Hitung NCR Menggunakan Segitiga Pascal | Memulakan matriks dengan 0; 0 C0 = 1; Tetapkan setiap NCR = 1 di mana r = 0; Nilai untuk sel semasa segitiga Pascal; Berfungsi untuk mengembalikan nilai NCR; Kembali NCR; Bina Segitiga Pascal", "code": "let l = new Array ( 1001 ) . fill ( 0 ) . map ( ( ) => new Array ( 1001 ) . fill ( 0 ) ) ; function initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( let j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } } function nCr ( n , r ) { return l [ n ] [ r ] ; } initialize ( ) ; let n = 8 ; let r = 3 ; document . write ( nCr ( n , r ) ) ;"}
{"text": "Partition Jumlah Paling Berdekatan (ke dalam dua subset) nombor dari 1 hingga N | Berfungsi untuk mengembalikan perbezaan mutlak yang diperlukan minimum; Kod pemacu", "code": "function minAbsDiff ( n ) { let mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; } let n = 5 ; document . write ( minAbsDiff ( n ) ) ;"}
{"text": "Semak sama ada xor kekerapan semua digit nombor n adalah sifar atau tidak | Pelaksanaan JavaScript pendekatan di atas; mewujudkan pelbagai frekuensi; Mencari digit terakhir nombor; Membahagikan nombor dengan 10 untuk menghapuskan digit terakhir; kekerapan mengira setiap digit; Memeriksa jika XOR semua kekerapan adalah sifar atau tidak; Fungsi pemacu", "code": "function check ( s ) { let freq = new Array ( 10 ) . fill ( 0 ) , r ; while ( s != 0 ) { r = s % 10 ; s = parseInt ( s / 10 ) ; freq [ r ] += 1 ; } let xor__ = 0 ; for ( let i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } } let s = 122233 ; if ( check ( s ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Cetak garis n 4 nombor supaya setiap pasangan di antara 4 nombor mempunyai gcd k | Berfungsi untuk garis prvar n; Melangkah ke garisan prvar n; Kod pemacu", "code": "function printLines ( n , k ) { for ( i = 0 ; i < n ; i ++ ) { document . write ( k * ( 6 * i + 1 ) + \" \" + k * ( 6 * i + 2 ) + \" \" + k * ( 6 * i + 3 ) + \" \" + k * ( 6 * i + 5 ) + \" \" ) ; } } var n = 2 , k = 2 ; printLines ( n , k ) ;"}
{"text": "Jumlah pertama N Siri 3, 5, 9, 17, 33 ... | Program skrip Java untuk mencari jumlah terma pertama n; Sn = n * (4 * n * n + 6 * n - 1) / 3; bilangan terma yang akan dimasukkan dalam jumlah; Cari SN", "code": "function calculateSum ( n ) { return ( Math . pow ( 2 , n + 1 ) + n - 2 ) ; } let n = 4 ; document . write ( \" \" + calculateSum ( n ) ) ;"}
{"text": "Kira bilangan rentetan khas panjang n | Program JavaScript untuk mengira bilangan rentetan khas panjang n; Berfungsi untuk mengembalikan kiraan rentetan khas; menyimpan jawapan untuk nilai tertentu n; Untuk n = 0 kita mempunyai rentetan kosong; Untuk n = 1 kita mempunyai 2 rentetan khas; Hitung kiraan rentetan panjang panjang i; Fib [n] menyimpan kiraan rentetan khas panjang n; permulaan n", "code": "var mod = 1000000007 ; function count_special ( n ) { var fib = [ ... Array ( n + 1 ) ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( var i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( ( fib [ i - 1 ] % mod ) + ( fib [ i - 2 ] % mod ) ) % mod ; } return fib [ n ] ; } var n = 3 ; document . write ( count_special ( n ) + \" \" ) ;"}
{"text": "Mengira laluan dalam array | Pelaksanaan JavaScript pendekatan di atas; Cari bilangan cara untuk mencapai akhir; Kes asas; Struktur rekursif; Kod pemacu", "code": "let mod = 1000000000 ; function ways ( i , arr , n ) { if ( i == n - 1 ) return 1 ; let sum = 0 ; for ( let j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; } let arr = [ 5 , 3 , 1 , 4 , 3 ] ; let n = arr . length ; document . write ( ways ( 0 , arr , n ) ) ;"}
{"text": "Mengira laluan dalam array | Pelaksanaan JavaScript pendekatan di atas; Cari bilangan cara untuk mencapai akhir; DP untuk menyimpan nilai; Kes asas; Bawah struktur DP; F [i] bergantung kepada F [i + 1] ke F [i + k]; Nilai pulangan DP [0]; Kod pemacu", "code": "let mod = ( 1e9 + 7 ) ; function ways ( arr , n ) { let dp = new Array ( n + 1 ) ; dp . fill ( 0 ) ; dp [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( let j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; } let arr = [ 5 , 3 , 1 , 4 , 3 ] ; let n = arr . length ; document . write ( ways ( arr , n ) % mod ) ;"}
{"text": "Bilangan berikutnya dengan jumlah yang lebih baik dan ganjil | Program Java untuk mendapatkan kos minimum untuk menyusun rentetan dengan operasi pembalikan; Mengembalikan kiraan ganjil dan bahkan seterusnya; Pembolehubah untuk menyimpan kiraan bahkan seterusnya dan berikutnya yang ganjil; Inisialisasi count_even dan count_odd hingga 0 kerana kerana tidak ada berikutnya sebelum lelaran dengan kiraan yang lebih baik atau ganjil. ; Cari jumlah semua berikutnya dengan mengira dan mengira ganjil dan menyimpannya semasa kami melangkah. ; jika nombor itu juga; Jika nombor itu ganjil; Kod pemacu; Memanggil fungsi", "code": "var first , second ; function pair ( first , second ) { this . first = first ; this . second = second ; } function countSum ( arr , n ) { var result = 0 ; var count_odd , count_even ; count_odd = 0 ; count_even = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { count_even = count_even + count_even + 1 ; count_odd = count_odd + count_odd ; } else { var temp = count_even ; count_even = count_even + count_odd ; count_odd = count_odd + temp + 1 ; } } return new pair ( count_even , count_odd ) ; } var arr = [ 1 , 2 , 2 , 3 ] ; var n = arr . length ; var ans = countSum ( arr , n ) ; document . write ( \" \" + ans . first ) ; document . write ( \" \" + ans . second ) ;"}
{"text": "Count integer panjang n dan nilai kurang daripada k sehingga ia mengandungi digit hanya dari set yang diberikan | Pelaksanaan JavaScript pendekatan; Berfungsi untuk menukar nombor menjadi vektor; Tolak semua digit n dari akhir satu demi satu ke vektor; Jika nombor asalnya adalah 0; Membalikkan elemen vektor; Mengembalikan vektor yang diperlukan; Berfungsi untuk mengembalikan bilangan bilangan bulat panjang b yang kurang daripada c dan mereka mengandungi digit dari set a [] sahaja; Menukar nombor ke array digit; Kes 1: Tidak ada bilangan sedemikian mungkin kerana nombor yang dihasilkan akan selalu lebih besar daripada C; Kes 2: Semua bilangan bulat panjang B adalah sah kerana mereka semua kurang daripada C; mengandungi 0; Kes 3; Kemas kini array yang lebih rendah [seperti yang lebih rendah [i] menyimpan kiraan unsur -unsur dalam [] yang kurang daripada saya; Untuk indeks pertama kita tidak boleh menggunakan 0; Sama ada (i - 1) digit nombor yang dihasilkan boleh sama dengan (i - 1) digit C; Adakah digit [i - 1] hadir dalam A? ; Kod pemacu", "code": "let MAX = 10 ; function numToVec ( N ) { let digit = [ ] ; while ( N != 0 ) { digit . push ( N % 10 ) ; N = Math . floor ( N / 10 ) ; } if ( digit . length == 0 ) digit . push ( 0 ) ; digit . reverse ( ) ; return digit ; } function solve ( A , B , C ) { let digit = [ ] ; let d , d2 ; digit = numToVec ( C ) ; d = A . length ; if ( B > digit . length d == 0 ) return 0 ; else if ( B < digit . length ) { if ( A [ 0 ] == 0 && B != 1 ) return Math . floor ( ( d - 1 ) * Math . pow ( d , B - 1 ) ) ; else return Math . floor ( Math . pow ( d , B ) ) ; } else { let dp = new Array ( B + 1 ) ; let lower = new Array ( MAX + 1 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = 0 ; } for ( let i = 0 ; i < lower . length ; i ++ ) { lower [ i ] = 0 ; } for ( let i = 0 ; i < d ; i ++ ) lower [ A [ i ] + 1 ] = 1 ; for ( let i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; let flag = true ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit [ i - 1 ] ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A [ 0 ] == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) ; } return dp [ B ] ; } } let arr = [ 0 , 1 , 2 , 5 ] ; let N = 2 ; let k = 21 ; document . write ( solve ( arr , N , k ) ) ;"}
{"text": "Bilangan jalur berat w dalam k | Berfungsi untuk mengembalikan bilangan cara yang mempunyai berat badan sebagai wt dalam pokok k - ary; Kembali 0 jika berat menjadi kurang daripada sifar; Kembali hanya jika laluan semasa telah memasukkan berat kelebihan mehaum m; Jika berat tepi semasa lebih besar daripada atau sama dengan m, set digunakan sebagai benar; Kod pemacu untuk menguji fungsi di atas", "code": "function solve ( dp , wt , K , M , used ) { if ( wt < 0 ) { return 0 ; } if ( wt == 0 ) { if ( used == 1 ) { return 1 ; } return 0 ; } if ( dp [ wt ] [ used ] != - 1 ) { return dp [ wt ] [ used ] ; } let ans = 0 ; for ( let i = 1 ; i <= K ; i ++ ) { if ( i >= M ) { ans += solve ( dp , wt - i , K , M , used 1 ) ; } else { ans += solve ( dp , wt - i , K , M , used ) ; } } return dp [ wt ] [ used ] = ans ; } let W = 3 , K = 3 , M = 2 ; let dp = new Array ( W + 1 ) ; for ( let i = 0 ; i < W + 1 ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } document . write ( solve ( dp , W , K , M , 0 ) + \" \" ) ;"}
{"text": "Cara Menulis N sebagai Jumlah Dua atau Lebih Integer Positif | Set | Berfungsi untuk mencari bilangan partition n; Kes asas; Kod pemacu", "code": "function partitions ( n ) { var p = Array ( n + 1 ) . fill ( 0 ) ; p [ 0 ] = 1 ; for ( i = 1 ; i <= n ; ++ i ) { var k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; } var N = 20 ; document . write ( partitions ( N ) ) ;"}
{"text": "Laluan Terpanjang dalam Matriks | Kembalikan panjang bibir dalam matriks 2D; Jika nilai belum dikira. ; Jika mencapai sel kiri bawah, kembali 1 .; Jika sampai ke sudut matriks. ; Jika nilai lebih besar daripada sel bawah. ; Jika nilai lebih besar daripada sel kiri. ; Fungsi pembalut; Kod pemacu", "code": "function LIP ( dp , mat , n , m , x , y ) { if ( dp [ x ] [ y ] < 0 ) { let result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( x + 1 < n && mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( y + 1 < m && mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = Math . max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; } function wrapper ( mat , n , m ) { let dp = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { dp [ i ] = new Array ( 10 ) ; for ( let j = 0 ; j < 10 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return LIP ( dp , mat , n , m , 0 , 0 ) ; } let mat = [ [ 1 , 2 , 3 , 4 ] , [ 2 , 2 , 3 , 4 ] , [ 3 , 2 , 3 , 4 ] , [ 4 , 5 , 6 , 7 ] , ] ; let n = 4 , m = 4 ; document . write ( wrapper ( mat , n , m ) ) ;"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Fungsi rekursif untuk mengira bilangan laluan; Jika kita mencapai bahagian bawah atau kiri atas, kita hanya mempunyai satu cara untuk mencapai (0, 0); Lain mengira jumlah kedua -dua cara; Kod pemacu", "code": "function countPaths ( n , m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; } let n = 3 , m = 2 ; document . write ( \" \" + countPaths ( n , m ) ) ;"}
{"text": "Masalah Tambang Emas | Program JavaScript untuk menyelesaikan masalah lombong emas; Mengembalikan jumlah maksimum emas yang boleh dikumpulkan apabila perjalanan bermula dari lajur pertama dan bergerak yang dibenarkan adalah betul, kanan dan kanan - ke bawah; Buat jadual untuk menyimpan hasil pertengahan dan memulakan semua sel ke 0. Baris pertama Goldminetable memberikan emas maksimum yang dapat dikumpulkan oleh pelombong ketika memulakan baris itu; Emas yang dikumpulkan pergi ke sel di sebelah kanan ( ->); Emas yang dikumpulkan untuk pergi ke sel untuk ke atas ( /); Emas yang dikumpulkan untuk pergi ke sel ke kanan (\\); Max Gold yang dikumpulkan daripada mengambil salah satu daripada 3 laluan di atas; Jumlah maksimum emas yang dikumpulkan akan menjadi nilai maksimum dalam lajur pertama semua baris; Kod pemacu", "code": "let MAX = 100 ; function getMaxGold ( gold , m , n ) { let goldTable = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { goldTable [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { goldTable [ i ] [ j ] = 0 ; } } for ( let col = n - 1 ; col >= 0 ; col -- ) { for ( let row = 0 ; row < m ; row ++ ) { let right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; let right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; let right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } let res = goldTable [ 0 ] [ 0 ] ; for ( let i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; } let gold = [ [ 1 , 3 , 1 , 5 ] , [ 2 , 2 , 4 , 1 ] , [ 5 , 0 , 2 , 3 ] , [ 0 , 6 , 1 , 2 ] ] ; let m = 4 , n = 4 ; document . write ( getMaxGold ( gold , m , n ) ) ;"}
{"text": "Cari Kos Pelarasan Minimum Array | Program JavaScript untuk mencari kos pelarasan minimum array; Fungsi untuk mencari kos pelarasan minimum array; dp [i] [j] menyimpan kos pelarasan minimum untuk menukar [i] ke j; mengendalikan elemen pertama array secara berasingan; lakukan untuk elemen rehat array; Gantikan [i] ke J dan hitung kos pelarasan minimum DP [i] [j]; memulakan kos pelarasan minimum kepada int_max; Pertimbangkan semua k sedemikian rupa sehingga k> = max (j - sasaran, 0) dan k <= min (m, j + sasaran) dan ambil minimum; pulangan nilai minimum dari baris terakhir jadual DP; Kod pemacu", "code": "let M = 100 ; function minAdjustmentCost ( A , n , target ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Number . MAX_VALUE ; let k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } let res = Number . MAX_VALUE ; for ( let j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; } let arr = [ 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ] ; let n = arr . length ; let target = 10 ; document . write ( \" \" + minAdjustmentCost ( arr , n , target ) ) ;"}
{"text": "Kira tiga kali ganda dari julat tertentu yang mempunyai jumlah dua nombor triplet yang sama dengan nombor ketiga | Berfungsi untuk mencari bilangan tiga kali ganda dari julat [l, r] yang mempunyai jumlah dua nombor dari triplet yang sama dengan nombor ketiga; Menyimpan jumlah tiga tiga; Cari perbezaan julat; Kes 1: Jika tiga kali boleh dibentuk, maka kembali 0; Jika tidak; Mengemas kini jumlah tiga kali ganda; Mengembalikan kiraan; Kod pemacu", "code": "function totalCombination ( L , R ) { let count = 0 ; let K = R - L ; if ( K < L ) return 0 ; let ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; } let L = 2 , R = 6 ; document . write ( totalCombination ( L , R ) ) ;"}
{"text": "Bina Dua N | Memenuhi syarat yang diberikan; Mengisytiharkan kedua -dua array A dan B; Berulang dari julat [1, 2 * n]; Berikan nombor berturut -turut kepada indeks yang sama dari kedua -dua tatasusunan; Cetak array pertama; Cetak array kedua, b; Kod pemacu; Panggilan fungsi", "code": "function printArrays ( n ) { let A = [ ] ; let B = [ ] ; for ( let i = 1 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) A . push ( i ) ; else B . push ( i ) ; } document . write ( \" \" ) ; for ( let i = 0 ; i < n ; i ++ ) { document . write ( A [ i ] ) ; if ( i != n - 1 ) document . write ( \" \" ) ; } document . write ( \" \" + \" \" ) ; document . write ( \" \" ) ; for ( let i = 0 ; i < n ; i ++ ) { document . write ( B [ i ] ) ; if ( i != n - 1 ) document . write ( \" \" ) ; } document . write ( \" \" ) ; } let N = 5 ; printArrays ( N ) ;"}
{"text": "Nombor yang dibentuk dengan membalikkan bit set biasa dalam dua bilangan bulat yang diberikan | Berfungsi untuk membalikkan bit a dan b yang ditetapkan bit dalam a dan b; Iterater semua bit mungkin a dan b; Jika ia bit ditetapkan dalam kedua -dua A dan B; Jelas i - th bit a; Jelas i - th bit b; Cetak A dan B; Kod pemacu", "code": "function flipBitsOfAandB ( A , B ) { for ( i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } document . write ( A + \" \" + B ) ; } var A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ;"}
{"text": "Kira jumlah pasangan yang berbeza antara dua array nilai 1 hingga n | Berfungsi untuk mencari jumlah yang berbeza; Kod pemacu", "code": "function findDistinctSums ( N ) { return ( 2 * N - 1 ) ; } let N = 3 ; document . write ( findDistinctSums ( N ) ) ;"}
{"text": "Count Substrings Dari Diberi String Ternary yang Mengandungi Karakter Sekurang -kurangnya sekali | Fungsi untuk mengira bilangan substrings terdiri daripada 0, 1, dan 2; Memulakan pelbagai frekuensi saiz 3; Menyimpan kiraan yang dihasilkan; Traversing string str; Arahan kekerapan kemas kini; Jika semua watak hadir mengira bilangan substrings mungkin; Kemas kini bilangan substring; Mengembalikan bilangan substring; Kod pemacu", "code": "function countSubstrings ( str ) { let freq = new Array ( 3 ) . fill ( 0 ) let count = 0 ; let i = 0 ; for ( let j = 0 ; j < str . length ; j ++ ) { freq [ str . charCodeAt ( j ) - ' ' . charCodeAt ( 0 ) ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str . charCodeAt ( i ++ ) - ' ' . charCodeAt ( 0 ) ] -- ; } count += i ; } return count ; } let str = \" \" ; let count = countSubstrings ( str ) ; document . write ( count ) ;"}
{"text": "FLIPS MINIMUM UNTUK MENGURANGKAN SEBARANG TERBUKA 3 0 S atau 1 S DALAM RENCEN BINARY YANG DIPERLUKAN | Berfungsi untuk mencari bilangan minimum flip untuk membuat ketiga -tiga pasang aksara berturut -turut berbeza; Kedai -kedai yang dihasilkan pasangan pasangan; Kes asas; Melangkah ke atas julat [0, n - 2]; Jika nombor 3 berturut -turut adalah sama maka kenaikan kiraan dan kaunter; Kembalikan jawapannya; Kod pemacu", "code": "function minFlips ( str ) { let count = 0 ; if ( str . length <= 2 ) { return 0 ; } for ( let i = 0 ; i < str . length - 2 ; ) { if ( str [ i ] == str [ i + 1 ] && str [ i + 2 ] == str [ i + 1 ] ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } let S = \" \" ; document . write ( minFlips ( S ) ) ;"}
{"text": "Menyulitkan rentetan | Berfungsi untuk menukar perpuluhan ke hex; Berfungsi untuk menyulitkan rentetan; Melepasi watak -watak rentetan; Iterat sehingga S [i] sama dengan CH; Kemas kini kiraan dan saya; Penurunan I oleh 1; Menukar kiraan kepada perwakilan heksadesimal; Tambah watak; Tambah kekerapan aksara dalam perwakilan heksadesimal; Membalikkan jawapan yang diperoleh; Mengembalikan jawapan yang diperlukan; Diberikan input; Panggilan fungsi", "code": "function convertToHex ( num ) { let temp = \" \" ; while ( num != 0 ) { let rem = num % 16 ; let c = 0 ; if ( rem < 10 ) { c = rem + 48 ; } else { c = rem + 87 ; } temp += String . fromCharCode ( c ) ; num = Math . floor ( num / 16 ) ; } return temp ; } function encryptString ( S , N ) { let ans = \" \" ; for ( let i = 0 ; i < N ; i ++ ) { let ch = S [ i ] ; let count = 0 ; let hex ; while ( i < N && S [ i ] == ch ) { count ++ ; i ++ ; } i -- ; hex = convertToHex ( count ) ; ans += ch ; ans += hex ; } ans = ans . split ( ' ' ) . reverse ( ) . join ( \" \" ) ; return ans ; } let S = \" \" ; let N = S . length ; document . write ( encryptString ( S , N ) ) ;"}
{"text": "Kiraan rentetan binari panjang n sedemikian rupa sehingga kekerapan 1 s ~ melebihi »frekuensi ~» s | Fungsi untuk mengira dan mengembalikan nilai pekali binomial C (n, k); Kerana c (n, k) = c (n, n - k); Kirakan nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Berfungsi untuk mengembalikan kiraan rentetan binari panjang n sedemikian rupa sehingga kekerapan 1 's »s; Kiraan rentetan binari panjang n; Kiraan rentetan binari panjang n yang mempunyai kiraan yang sama dengan 0 dan 1 's; Untuk rentetan panjang; Kod pemacu", "code": "function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } function countOfString ( N ) { let Stotal = Math . pow ( 2 , N ) ; let Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N / 2 ) ; let S1 = ( Stotal - Sequal ) / 2 ; return S1 ; } let N = 3 ; document . write ( countOfString ( N ) ) ;"}
{"text": "Keluarkan semua kejadian watak dalam rentetan | Pendekatan Rekursif | Berfungsi untuk menghapuskan semua kejadian watak dalam rentetan; Kes asas; Semak watak pertama rentetan yang diberikan; Lulus sisa rentetan ke panggilan fungsi rekursi; Tambah watak pertama STR dan String dari rekursi; Diberikan rentetan; Diberikan watak; Panggilan fungsi", "code": "function removeCharRecursive ( str , X ) { if ( str . length == 0 ) { return \" \" ; } if ( str . charAt ( 0 ) == X ) { return removeCharRecursive ( str . substring ( 1 ) , X ) ; } return str . charAt ( 0 ) + removeCharRecursive ( str . substring ( 1 ) , X ) ; } var str = \" \" ; var X = ' ' ; str = removeCharRecursive ( str , X ) ; document . write ( str ) ;"}
{"text": "Masa maksimum seperti perbezaan mutlak antara jam dan minit terletak pada julat yang diberikan | Pemeriksaan fungsi sama ada masa yang diberikan adalah betul; Untuk memeriksa nilai masa; Untuk memeriksa nilai jam masa; Perubahan nilai tidak dibenarkan di kedudukan di mana '? 'tidak hadir; Fungsi memeriksa sama ada perbezaan mutlak antara jam dan nilai minit berada dalam [l, r]; Cek jika perbezaan di luar julat memberi; Memaparkan masa dalam format 24 jam yang betul; Fungsi Cari nilai masa yang dikehendaki yang perbezaannya terletak dalam julat [l, r]; Menurunkan nilai jam dari 23 hingga 0; Semak jika nilai jam sah jika tidak sah maka tidak perlu menukar nilai minit, kerana masa masih akan sah, untuk memeriksa bendera nilai jam ditetapkan kepada 1 .; Mengurangkan nilai minit dari 59 hingga 0; Semak sama ada nilai minit sah, jika tidak sah kemudian langkau lelaran semasa, untuk memeriksa bendera nilai 'minit' ditetapkan kepada 0 .; Masa input; Julat Perbezaan", "code": "function isValid ( a1 , a2 , str , flag ) { let v1 , v2 ; if ( flag == 0 ) { v1 = str [ 4 ] ; v2 = str [ 3 ] ; } else { v1 = str [ 1 ] ; v2 = str [ 0 ] ; } if ( v1 != a1 && v1 != ' ' ) return false ; if ( v2 != a2 && v2 != ' ' ) return false ; return true ; } function inRange ( hh , mm , L , R ) { let a = Math . abs ( hh - mm ) ; if ( a < L a > R ) return false ; return true ; } function displayTime ( hh , mm ) { if ( hh > 10 ) document . write ( hh + \" \" ) ; else if ( hh < 10 ) document . write ( \" \" + hh + \" \" ) ; if ( mm > 10 ) document . write ( mm + \" \" ) ; else if ( mm < 10 ) document . write ( \" \" + mm + \" \" ) ; } function maximumTimeWithDifferenceInRange ( str , L , R ) { let i = 0 , j = 0 ; let h1 , h2 , m1 , m2 ; for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = Math . floor ( i / 10 ) ; if ( ! isValid ( String . fromCharCode ( h1 ) , String . fromCharCode ( h2 ) , str , 1 ) ) { continue ; } for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = Math . floor ( j / 10 ) ; if ( ! isValid ( String . fromCharCode ( m1 ) , String . fromCharCode ( m2 ) , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) displayTime ( i , j ) ; else document . write ( \" \" ) ; } let timeValue = \" \" ; let L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ;"}
{"text": "Semak jika rentetan boleh dibahagikan kepada substrings Palindromic panjang walaupun | Fungsi untuk memeriksa string str boleh memecah rentetan ke dalam substrings palindromik panjang; Memulakan timbunan; Melelehkan rentetan; Jika watak I - tH adalah sama seperti di bahagian atas timbunan kemudian pop elemen atas; Lain -lain menolak watak semasa ke dalam timbunan; Sekiranya timbunan kosong, maka substrings palindromik mungkin; Lain tidak - mungkin; Diberikan rentetan; Panggilan fungsi", "code": "function check ( s , n ) { var st = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( st . length != 0 && st [ st . length - 1 ] == s [ i ] ) st . pop ( ) ; else st . push ( s [ i ] ) ; } if ( st . length == 0 ) { return true ; } else { return false ; } } var str = \" \" ; var n = str . length ; if ( check ( str , n ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Bilangan rentetan dalam dua array memenuhi syarat -syarat yang diberikan | Program JavaScript untuk pendekatan di atas; Untuk menyimpan kekerapan rentetan selepas bitmasking; Untuk menyimpan hasil untuk setiap rentetan dalam ARR2 []; Melintasi arr1 [] dan bitmask setiap rentetan di dalamnya; Bitmasking untuk setiap rentetan s; Kemas kini kekerapan rentetan dengan nilai bitmasking; Melintasi arr2 []; Bitmasking untuk setiap rentetan s; Periksa sama ada temp ada dalam unstered_map atau tidak; Semak bit set seterusnya; Tolak kiraan untuk rentetan semasa dalam array yang dihasilkan; Cetak kiraan untuk setiap rentetan; Kod pemacu; Panggilan fungsi", "code": "function findNumOfValidWords ( w , p ) { var m = new Map ( ) ; var res = [ ] ; w . forEach ( s => { var val = 0 ; s . split ( ' ' ) . forEach ( c => { val = val | ( 1 << ( c . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ; } ) ; if ( m . has ( val ) ) m . set ( val , m . get ( val ) + 1 ) else m . set ( val , 1 ) } ) ; p . forEach ( s => { var val = 0 ; s . split ( ' ' ) . forEach ( c => { val = val | ( 1 << ( c . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ; } ) ; var temp = val ; var first = s [ 0 ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; var count = 0 ; while ( temp != 0 ) { if ( ( ( temp >> first ) & 1 ) == 1 ) { if ( m . has ( temp ) ) { count += m . get ( temp ) ; } } temp = ( temp - 1 ) & val ; } res . push ( count ) ; } ) ; res . forEach ( it => { document . write ( it + \" \" ) ; } ) ; } var arr1 = [ \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" ] ; var arr2 = [ \" \" , \" \" , \" \" , \" \" , \" \" , \" \" ] ; findNumOfValidWords ( arr1 , arr2 ) ;"}
{"text": "Memaksimumkan setara perpuluhan dengan membalikkan hanya satu set bersebelahan 0 S | Berfungsi untuk mencetak nombor binari; Semak sama ada nombor semasa ialah 0; Cari 0 s berterusan; Gantikan pada mulanya berlaku 0 dengan 1; Keluar dari gelung jika 1 berlaku; Kod pemacu", "code": "function flip ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) { while ( s [ i ] == ' ' ) { s [ i ] = ' ' ; i ++ ; } break ; } } return s . join ( \" \" ) ; } let s = \" \" ; document . write ( flip ( s . split ( ' ' ) ) ) ;"}
{"text": "Kes Kalimat Rentetan Camel yang Diberikan | Berfungsi untuk mengembalikan rentetan asal selepas menukarnya dari unta; Cetak watak pertama seperti itu; Melintasi seluruh watak satu demi satu; Jika watak semasa adalah ruang cetak huruf besar diikuti oleh watak semasa dalam huruf kecil; Lain mencetak watak semasa; Kod pemacu", "code": "function getOrgString ( s ) { document . write ( s [ 0 ] ) ; var i = 1 ; while ( i < s . length ) { if ( s [ i ] . charCodeAt ( 0 ) >= \" \" . charCodeAt ( 0 ) && s [ i ] . charCodeAt ( 0 ) <= \" \" . charCodeAt ( 0 ) ) document . write ( \" \" + s [ i ] . toLowerCase ( ) ) ; else document . write ( s [ i ] ) ; i ++ ; } } var s = \" \" ; getOrgString ( s ) ;"}
{"text": "Kira kejadian watak dalam rentetan berulang | Berfungsi untuk mengira watak 'A'; Atleast k pengulangan diperlukan; Jika n bukanlah pelbagai pemeriksaan saiz rentetan untuk watak berulang yang tersisa. ; Kod pemacu", "code": "function countChar ( str , x ) { let count = 0 ; let n = 10 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) count ++ ; let repetitions = n / str . length ; count = count * repetitions ; for ( let i = 0 ; i < n % str . length ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; } let str = \" \" ; document . write ( countChar ( str , ' ' ) ) ;"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program JavaScript untuk mengira frekuensi item array yang mempunyai nilai kecil. ; Buat array untuk menyimpan tuduhan. Saiz array adalah had + 1 dan semua nilai pada mulanya 0; Melintasi unsur -unsur array dan kekerapan kiraan (dengan mengandaikan bahawa unsur -unsur dibatasi oleh had); Kod pemacu", "code": "function countFreq ( arr , n , limit ) { let count = new Array ( limit + 1 ) ; count . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( let i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) document . write ( i + \" \" + count [ i ] + \" \" ) ; } let arr = [ 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 ] ; let n = arr . length ; let limit = 10 ; countFreq ( arr , n , limit ) ;"}
{"text": "Semak jika rentetan mempunyai m berturut -turut 1 's atau ~ 0' s | Fungsi yang memeriksa jika rentetan binari mengandungi m berturut -turut 1 's atau' s; panjang rentetan binari; Count Zeros; Count 1 's; Count berturut -turut 0 's; Count berturut -turut 1 's; Kod pemacu; panggilan fungsi", "code": "function check ( s , m ) { let l = s . length ; let c1 = 0 ; let c2 = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( s [ i ] == ' ' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; } let s = \" \" ; let m = 2 ; if ( check ( s , m ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Produk nod di k | Berfungsi untuk mencari produk digit elemen di peringkat k - th; Memulakan hasil; peningkatan bilangan tahap; mengurangkan nombor tahap; Periksa sama ada tahap semasa adalah tahap yang dikehendaki atau tidak; produk yang diperlukan; Kod pemacu", "code": "function productAtKthLevel ( tree , k ) { let level = - 1 ; let product = 1 ; let n = tree . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ' ) level ++ ; else if ( tree [ i ] == ' ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; } } return product ; } let tree = \" \" ; let k = 2 ; document . write ( productAtKthLevel ( tree , k ) ) ;"}
{"text": "Mengeluarkan baris atau lajur bijak pendua dari matriks aksara | Berfungsi untuk memeriksa pendua dalam baris dan lajur; Buat array ispresent dan mulakan semua penyertaannya sebagai palsu. Nilai ispresent [i, j] akan benar jika S [i, j] hadir dalam baris atau lajurnya. ; Memeriksa setiap baris untuk pendua [i, j]; Memeriksa setiap lajur untuk aksara pendua; Jika watak itu unik dalam baris dan lajurnya; Kod pemacu; pelbagai watak; Fungsi panggilan", "code": "function findDuplciates ( a , n , m ) { var isPresent = Array ( n ) . fill ( ) . map ( ( ) => Array ( m ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < m ; j ++ ) { isPresent [ i ] [ j ] = false ; } } for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < m ; j ++ ) { for ( var k = 0 ; k < n ; k ++ ) { if ( a [ i ] . charAt ( j ) == a [ k ] . charAt ( j ) && i != k ) { isPresent [ i ] [ j ] = true ; isPresent [ k ] [ j ] = true ; } } for ( k = 0 ; k < m ; k ++ ) { if ( a [ i ] . charAt ( j ) == a [ i ] . charAt ( k ) && j != k ) { isPresent [ i ] [ j ] = true ; isPresent [ i ] [ k ] = true ; } } } } for ( var i = 0 ; i < n ; i ++ ) for ( var j = 0 ; j < m ; j ++ ) if ( isPresent [ i ] [ j ] == false ) document . write ( a [ i ] . charAt ( j ) ) ; } var n = 2 , m = 2 ; var a = [ \" \" , \" \" ] ; findDuplciates ( a , n , m ) ;"}
{"text": "Program untuk memeriksa ISBN | Program JavaScript untuk memeriksa sama ada ISBN yang diberikan atau tidak. ; panjang mestilah 10; Pengkomputeran berjumlah 9 digit pertama; Memeriksa digit terakhir. ; Jika digit terakhir adalah 'x', tambahkan 10 hingga jumlah, tambah nilainya. ; Kembali benar jika jumlah digit berwajaran boleh dibahagikan dengan 11 .; Kod pemacu", "code": "function isValidISBN ( isbn ) { let n = isbn . length ; if ( n != 10 ) return false ; let sum = 0 ; for ( let i = 0 ; i < 9 ; i ++ ) { let digit = isbn [ i ] - ' ' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } let last = isbn [ 9 ] ; if ( last != ' ' && ( last < ' ' last > ' ' ) ) return false ; sum += ( ( last == ' ' ) ? 10 : ( last - ' ' ) ) ; return ( sum % 11 == 0 ) ; } let isbn = \" \" ; if ( isValidISBN ( isbn ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Vokal terbalik dalam rentetan yang diberikan | fungsi utiliti untuk memeriksa vokal; Berfungsi untuk membalikkan urutan vokal; Menyimpan vokal secara berasingan; Meletakkan vokal dalam urutan terbalik dalam rentetan; Kod pemacu", "code": "function isVowel ( c ) { return ( c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' ) ; } function reverseVowel ( str1 ) { let j = 0 ; let str = str1 . split ( ' ' ) ; let vowel = \" \" ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { j ++ ; vowel += str [ i ] ; } } for ( let i = 0 ; i < str . length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { str [ i ] = vowel [ -- j ] ; } } return str . join ( \" \" ) ; } let str = \" \" ; document . write ( reverseVowel ( str ) ) ;"}
{"text": "String yang mengandungi huruf pertama setiap perkataan dalam rentetan yang diberikan dengan ruang | Fungsi untuk mencari rentetan yang mempunyai watak pertama setiap perkataan. ; Melintasi rentetan. ; Jika ia adalah ruang, tetapkan V sebagai benar. ; Lain semak jika v adalah benar atau tidak. Jika benar, salin watak dalam rentetan output dan tetapkan V sebagai palsu. ; Kod pemacu", "code": "function firstLetterWord ( str ) { let result = \" \" ; let v = true ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ' ' ) { v = true ; } else if ( str [ i ] != ' ' && v == true ) { result += ( str [ i ] ) ; v = false ; } } return result ; } let str = \" \" ; document . write ( firstLetterWord ( str ) ) ;"}
{"text": "Laluan unik yang meliputi setiap bukan | Pelaksanaan JavaScript pendekatan; Fungsi untuk DFS. i, j ==> indeks sel semasa vis ==> untuk menandakan sel -sel yang dikunjungi ans ==> hasil z ==> kiraan semasa 0 s yang dikunjungi z_count ==> total 0 s hadir; Tandakan blok seperti yang dikunjungi; mengemas kini kiraan; Jika blok akhir dicapai; Jika jalan meliputi semua blok bukan halangan; Naik; Ke bawah; Kiri; Betul; Unmark blok (Unvisited); Berfungsi untuk mengembalikan kiraan laluan unik; biarkan z_count = 0; Jumlah 0 s hadir; Menghitung blok penghalang; Kedudukan permulaan; Kod pemacu", "code": "let ans = 0 ; function dfs ( i , j , grid , vis , z , z_count ) { let n = grid . length , m = grid [ 0 ] . length ; vis [ i ] [ j ] = true ; if ( grid [ i ] [ j ] == 0 ) z ++ ; if ( grid [ i ] [ j ] == 2 ) { if ( z == z_count ) ans ++ ; vis [ i ] [ j ] = false ; return ; } if ( i >= 1 && ! vis [ i - 1 ] [ j ] && grid [ i - 1 ] [ j ] != - 1 ) dfs ( i - 1 , j , grid , vis , z , z_count ) ; if ( i < n - 1 && ! vis [ i + 1 ] [ j ] && grid [ i + 1 ] [ j ] != - 1 ) dfs ( i + 1 , j , grid , vis , z , z_count ) ; if ( j >= 1 && ! vis [ i ] [ j - 1 ] && grid [ i ] [ j - 1 ] != - 1 ) dfs ( i , j - 1 , grid , vis , z , z_count ) ; if ( j < m - 1 && ! vis [ i ] [ j + 1 ] && grid [ i ] [ j + 1 ] != - 1 ) dfs ( i , j + 1 , grid , vis , z , z_count ) ; vis [ i ] [ j ] = false ; } function uniquePaths ( grid ) { let n = grid . length , m = grid [ 0 ] . length ; let vis = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { vis [ i ] = new Array ( m ) ; for ( let j = 0 ; j < m ; j ++ ) { vis [ i ] [ j ] = false ; } } let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; ++ i ) { for ( let j = 0 ; j < m ; ++ j ) { if ( grid [ i ] [ j ] == 0 ) z_count ++ ; else if ( grid [ i ] [ j ] == 1 ) { x = i ; y = j ; } } } dfs ( x , y , grid , vis , 0 , z_count ) ; return ans ; } let grid = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 2 , - 1 ] ] ; document . write ( uniquePaths ( grid ) ) ;"}
{"text": "Kira pasangan yang tidak teratur (x, y) array yang memenuhi persamaan yang diberikan | Mengembalikan bilangan pasangan yang tidak teratur yang memenuhi syarat; Ans menyimpan bilangan pasangan yang tidak teratur; Menjadikan setiap nilai array menjadi positif; Susun array; Bagi setiap indeks mengira sempadan yang betul untuk pasangan yang tidak teratur; Mengembalikan hasil akhir; Kod pemacu", "code": "function numPairs ( a , n ) { let ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; a . sort ( ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; } let a = [ 3 , 6 ] ; let n = a . length ; document . write ( numPairs ( a , n ) ) ;"}
{"text": "Kawasan persegi | Menggunakan sisi, pepenjuru dan perimeter | Berfungsi untuk mencari kawasan persegi; Gunakan formula di atas; Diberikan sisi persegi; Panggilan fungsi", "code": "function areaOfSquare ( S ) { let area = S * S ; return area ; } let S = 5 ; document . write ( areaOfSquare ( S ) ) ;"}
{"text": "Titik maksimum persimpangan yang mungkin di kalangan x lingkaran dan garis lurus y | Program JavaScript untuk melaksanakan pendekatan di atas; Bilangan bulatan; Bilangan garis lurus; Panggilan fungsi", "code": "function maxPointOfIntersection ( x , y ) { let k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; } let x = 3 ; let y = 4 ; document . write ( maxPointOfIntersection ( x , y ) ) ;"}
{"text": "Nombor Icosihenagonal | Berfungsi untuk mencari nombor icosihenagon; Formula untuk mengira nombor icosihenagon nth; Kod pemacu", "code": "function Icosihenagonal_num ( n ) { return ( 19 * n * n - 17 * n ) / 2 ; } let n = 3 ; document . write ( Icosihenagonal_num ( n ) + \" \" ) ; n = 10 ; document . write ( Icosihenagonal_num ( n ) ) ;"}
{"text": "Cari centroid bukan | Pelaksanaan JavaScript pendekatan; Untuk semua simpang; Hitung nilai menggunakan formula kasut; Mengira koordinat centroid poligon; Menyelaras simpul", "code": "function find_Centroid ( v ) { let ans = new Array ( 2 ) ; ans . fill ( 0 ) ; let n = v . length ; let signedArea = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let x0 = v [ i ] [ 0 ] , y0 = v [ i ] [ 1 ] ; let x1 = v [ ( i + 1 ) % n ] [ 0 ] , y1 = v [ ( i + 1 ) % n ] [ 1 ] ; let A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; } let vp = [ [ 1 , 2 ] , [ 3 , - 4 ] , [ 6 , - 7 ] ] ; let ans = find_Centroid ( vp ) ; document . write ( ans [ 0 ] . toFixed ( 11 ) + \" \" + ans [ 1 ] ) ;"}
{"text": "Program untuk mencari sudut segiempat | Kod pemacu; Menurut formula yang diperolehi di atas; Cetak semua sudut", "code": "var d = 10 ; var a ; a = parseInt ( ( 360 - ( 6 * d ) ) / 4 ) ; document . write ( a + \" \" + ( a + d ) + \" \" + ( a + ( 2 * d ) ) + \" \" + ( a + ( 3 * d ) ) ) ;"}
{"text": "Jarak antara dua pesawat selari dalam 3 | Berfungsi untuk mencari jarak; Kod pemacu", "code": "function distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) { let x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) / ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; document . write ( \" \" + d ) ; } else document . write ( \" \" ) ; } let a1 = 1 ; let b1 = 2 ; let c1 = - 1 ; let d1 = 1 ; let a2 = 3 ; let b2 = 6 ; let c2 = - 3 ; let d2 = - 4 ; distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) ;"}
{"text": "Mengira cara untuk membentuk 2 kalung dari manik n yang mengandungi n / 2 manik masing -masing | Fungsi untuk mengira faktorial; Fungsi untuk mengira bilangan cara untuk membuat 2 kalung yang mempunyai manik N / 2 jika setiap manik dianggap berbeza; Bilangan cara untuk memilih manik n / 2 dari manik N; Bilangan cara untuk membekalkan manik n / 2; Bahagikan Ans oleh 2 untuk menghapuskan pengulangan; Kembali Ans; Diberikan input; Panggilan fungsi", "code": "function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } function numOfNecklace ( N ) { var ans = factorial ( N ) / ( factorial ( N / 2 ) * factorial ( N / 2 ) ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans /= 2 ; return ans ; } var N = 4 ; document . write ( numOfNecklace ( N ) ) ;"}
{"text": "Semak jika nombor s boleh dibuat dibahagikan dengan d dengan berulang kali menambahkan selebihnya kepada s | Fungsi untuk memeriksa sama ada S dibahagi dengan d semasa menukar s ke (s + s % d); V (0) = s % d; Menyimpan nilai yang ditemui; V (i) = (v (i - 1) + v (i - 1) % d) % d; Semak sama ada nilai telah ditemui; Kes tepi; Jika tidak, masukkannya ke dalam hashmap; Kod pemacu", "code": "function isDivisibleByDivisor ( S , D ) { S %= D ; var hashMap = [ ] ; hashMap . push ( S ) ; for ( var i = 0 ; i <= D ; i ++ ) { S += S % D ; S %= D ; if ( hashMap . includes ( S ) ) { if ( S == 0 ) { return \" \" ; } return \" \" ; } else hashMap . push ( S ) ; } return \" \" ; } var S = 3 , D = 6 ; document . write ( isDivisibleByDivisor ( S , D ) ) ;"}
{"text": "Bilangan minimum bergerak yang diperlukan untuk mencapai (1, 1) dari (x, y) | Fungsi untuk mengira bilangan langkah yang diperlukan untuk menukar (x, y) hingga (1, 1); Simpan hasil yang diperlukan; Melangkah sementara kedua -dua x dan y tidak sama dengan 0; Jika x lebih besar daripada y; Kemas kini kiraan dan nilai x; Jika tidak; Kemas kini kiraan dan nilai y; Jika kedua -dua x dan y> 1; Cetak hasilnya; Diberikan x dan y", "code": "function minimumSteps ( x , y ) { var cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; document . write ( cnt ) ; } var x = 3 , y = 1 ; minimumSteps ( x , y ) ;"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Program JavaScript untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; min_avail mewakili nombor minimum yang masih tersedia untuk memasukkan dalam vektor output. pos_of_i menjejaki indeks paling terkini di mana 'i' ditemui w. r. t vektor output; vektor untuk menyimpan output; meliputi kes asas; Melintasi sisa input; Cetak nombor; Kod pemacu", "code": "function printLeast ( arr ) { let min_avail = 1 , pos_of_I = 0 ; let al = [ ] ; if ( arr [ 0 ] == ' ' ) { al . push ( 1 ) ; al . push ( 2 ) ; min_avail = 3 ; pos_of_I = 1 ; } else { al . push ( 2 ) ; al . push ( 1 ) ; min_avail = 3 ; pos_of_I = 0 ; } for ( let i = 1 ; i < arr . length ; i ++ ) { if ( arr [ i ] == ' ' ) { al . push ( min_avail ) ; min_avail ++ ; pos_of_I = i + 1 ; } else { al . push ( al [ i ] ) ; for ( let j = pos_of_I ; j <= i ; j ++ ) al [ j ] = al [ j ] + 1 ; min_avail ++ ; } } for ( let i = 0 ; i < al . length ; i ++ ) document . write ( al [ i ] + \" \" ) ; document . write ( \" \" ) ; } printLeast ( \" \" ) ; printLeast ( \" \" ) ; printLeast ( \" \" ) ; printLeast ( \" \" ) ; printLeast ( \" \" ) ; printLeast ( \" \" ) ; printLeast ( \" \" ) ;"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Fungsi untuk menyahkod urutan yang diberikan untuk membina nombor minimum tanpa digit berulang; Hasil Store Output String; Buat timbunan integer kosong; Jalankan n + 1 kali di mana n adalah panjang urutan input; Tekan nombor I + 1 ke dalam timbunan; Jika semua aksara urutan input diproses atau watak semasa adalah 'I' (meningkat); Jalankan sehingga timbunan kosong; Keluarkan elemen teratas dari timbunan dan tambahkannya ke penyelesaian; fungsi utama", "code": "function PrintMinNumberForPattern ( seq ) { let result = \" \" ; let stk = [ ] ; for ( let i = 0 ; i <= seq . length ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length seq [ i ] == ' ' ) { while ( stk . length != 0 ) { result += ( stk [ stk . length - 1 ] ) . toString ( ) ; result += \" \" ; stk . pop ( ) ; } } } document . write ( result + \" \" ) ; } PrintMinNumberForPattern ( \" \" ) ; PrintMinNumberForPattern ( \" \" ) ; PrintMinNumberForPattern ( \" \" ) ; PrintMinNumberForPattern ( \" \" ) ; PrintMinNumberForPattern ( \" \" ) ; PrintMinNumberForPattern ( \" \" ) ; PrintMinNumberForPattern ( \" \" ) ;"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Mengembalikan nombor minimum yang dibuat dari urutan yang diberikan tanpa mengulangi digit; Gelung berjalan untuk setiap aksara input serta satu masa tambahan untuk memberikan pangkat kepada setiap aksara yang tinggal; Kod pemacu", "code": "function getMinNumberForPattern ( seq ) { let n = seq . length ; if ( n >= 9 ) return \" \" ; let result = new Array ( n + 1 ) ; let count = 1 ; for ( let i = 0 ; i <= n ; i ++ ) { if ( i == n seq [ i ] == ' ' ) { for ( let j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = String . fromCharCode ( ' ' . charCodeAt ( ) + count ++ ) ; if ( j >= 0 && seq [ j ] == ' ' ) break ; } } } return result . join ( \" \" ) ; } let inputs = [ \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" ] ; for ( let input = 0 ; input < inputs . length ; input ++ ) { document . write ( getMinNumberForPattern ( inputs [ input ] ) + \" \" ) ; }"}
{"text": "Semak jika digit pertama dan terakhir nombor terkecil membentuk Perdana | berfungsi untuk memeriksa perdana; Berfungsi untuk menghasilkan nombor yang paling kecil dengan digit yang diberikan; Mengisytiharkan pelbagai hash saiz 10 dan memulakan semua elemen kepada sifar; Simpan bilangan kejadian digit dalam array yang diberikan ke dalam jadual hash; Melintasi hash dalam urutan menaik untuk mencetak nombor yang diperlukan; Cetak bilangan kali digit berlaku; mengekstrak digit pertama; mengekstrak digit terakhir; mencetak kombinasi utama; Kod pemacu", "code": "function isPrime ( n ) { var i , c = 0 ; for ( i = 1 ; i < n / 2 ; i ++ ) { if ( n % i == 0 ) c ++ ; } if ( c == 1 ) return 1 ; else return 0 ; } function findMinNum ( arr , n ) { var first = 0 , last = 0 , num , rev , i ; var hash = new Array ( 10 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } document . write ( \" \" ) ; for ( var i = 0 ; i <= 9 ; i ++ ) { for ( var j = 0 ; j < hash [ i ] ; j ++ ) document . write ( i ) ; } document . write ( \" \" ) ; for ( i = 0 ; i <= 9 ; i ++ ) { if ( hash [ i ] != 0 ) { first = i ; break ; } } for ( i = 9 ; i >= 0 ; i -- ) { if ( hash [ i ] != 0 ) { last = i ; break ; } } num = first * 10 + last ; rev = last * 10 + first ; document . write ( \" \" ) ; if ( isPrime ( num ) && isPrime ( rev ) ) document . write ( num + \" \" + rev ) ; else if ( isPrime ( num ) ) document . write ( num ) ; else if ( isPrime ( rev ) ) document . write ( rev ) ; else document . write ( \" \" ) ; } var arr = [ 1 , 2 , 4 , 7 , 8 ] ; findMinNum ( arr , 5 ) ;"}
{"text": "Mencari Co Transitif | Berfungsi untuk mengembalikan GCD A dan B; berfungsi untuk memeriksa GCD; A dan B adalah coprime jika GCD mereka adalah 1; Memeriksa jika ada triplet yang mungkin (a, b, c) menetapkan keadaan bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Menjana dan menyemak semua kemungkinan tiga kali ganda antara L dan R; Jika kita dapati apa -apa tiga kali ganda menetapkan bendera kepada benar; Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; Kod pemacu; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46", "code": "function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function coprime ( a , b ) { return ( gcd ( a , b ) == 1 ) ; } function possibleTripletInRange ( L , R ) { let flag = false ; let possibleA = 0 , possibleB = 0 , possibleC = 0 ; for ( let a = L ; a <= R ; a ++ ) { for ( let b = a + 1 ; b <= R ; b ++ ) { for ( let c = b + 1 ; c <= R ; c ++ ) { if ( coprime ( a , b ) && coprime ( b , c ) && ! coprime ( a , c ) ) { flag = true ; possibleA = a ; possibleB = b ; possibleC = c ; break ; } } } } if ( flag == true ) { document . write ( \" \" + possibleA + \" \" + possibleB + \" \" + possibleC + \" \" + \" \" + \" \" + L + \" \" + R + \" \" ) ; } else { document . write ( \" \" + \" \" + L + \" \" + R + \" \" ) ; } } let L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ;"}
{"text": "Jangkau A dan B dengan mengalikannya dengan k dan k ^ 2 pada setiap langkah | Fungsi untuk memeriksa adalah mungkin untuk mencapai A dan B bermula dari 1 dan 1; Cari cuberoot nombor; Bahagikan nombor dengan Cuberoot; Jika ia adalah cuberoot yang sempurna dan membahagikan A dan B; Kod pemacu", "code": "function possibleToReach ( a , b ) { let c = Math . cbrt ( a * b ) ; let re1 = a / c ; let re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; } let A = 60 , B = 450 ; if ( possibleToReach ( A , B ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Nombor bergelora | Program JavaScript untuk memeriksa sama ada nombor beralun atau tidak; Memandangkan definisi dengan sekatan bahawa terdapat sekurang -kurangnya 3 digit; Semak sama ada semua digit alternatif adalah sama atau tidak. ; Kod pemacu", "code": "function isUndulating ( n ) { if ( n . length <= 2 ) return false ; for ( let i = 2 ; i < n . length ; i ++ ) if ( n [ i - 2 ] != n [ i ] ) return false ; return true ; } let n = \" \" ; if ( isUndulating ( n ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Program untuk mencari jumlah siri (1 * 1) + (2 * 2) + (3 * 3) + (4 * 4) + (5 * 5) + ... + (n * n) | Fungsi untuk mengira siri berikut; Kod pemacu", "code": "function Series ( n ) { let i ; let sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; } let n = 3 ; let res = Series ( n ) ; document . write ( res ) ;"}
{"text": "Kira nombor dengan unit digit k dalam julat yang diberikan | Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; Fungsi pemacu", "code": "function counLastDigitK ( low , high , k ) { let mlow = 10 * ( Math . ceil ( low / 10.0 ) ) ; let mhigh = 10 * ( Math . floor ( high / 10.0 ) ) ; let count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 <= k && ( low % 10 ) > 0 ) count ++ ; return count ; } let low = 3 , high = 35 , k = 3 ; document . write ( counLastDigitK ( low , high , k ) ) ;"}
{"text": "Jumlah semua nombor yang boleh dibahagikan dengan 6 dalam julat yang diberikan | fungsi untuk mengira jumlah semua nombor yang boleh dibahagi dengan 6 dalam julat l - r. . ; tidak ada gandaan 6 sehingga r; tiada gandaan 6 sehingga l - 1; penjumlahan semua gandaan 6 sehingga r; penjumlahan semua gandaan 6 sehingga l - 1; mengembalikan jawapannya; Kod pemacu", "code": "function sum ( L , R ) { let p = Math . floor ( R / 6 ) ; let q = Math . floor ( ( L - 1 ) / 6 ) ; let sumR = Math . floor ( 3 * ( p * ( p + 1 ) ) ) ; let sumL = Math . floor ( ( q * ( q + 1 ) ) * 3 ) ; return sumR - sumL ; } let L = 1 , R = 20 ; document . write ( sum ( L , R ) ) ;"}
{"text": "Nombor yang lebih kecil yang terbesar mungkin menggunakan hanya satu operasi swap | Mengembalikan nombor yang mungkin terbesar dengan satu swap supaya nombor itu lebih kecil daripada STR. Dianggap bahawa terdapat 0 s. ; Traverse dari kanan sehingga kita dapati digit yang lebih besar daripada digit seterusnya. Sebagai contoh, dalam 34125, indeks kami ialah 4 .; Kami juga boleh menggunakan carian binari di sini sebagai digit selepas indeks disusun dalam peningkatan urutan. Cari digit terbesar di sebelah kanan ARR [indeks] yang lebih kecil daripada ARR [indeks]; Jika indeks adalah - 1 i. e. Digit adalah dalam urutan yang semakin meningkat. ; Menukar kedua -dua nilai; Kod pemacu", "code": "function prevNum ( str ) { let len = str . length ; let index = - 1 ; for ( let i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { index = i ; break ; } } let smallGreatDgt = - 1 ; for ( let i = len - 1 ; i > index ; i -- ) { if ( str [ i ] < str [ index ] ) { if ( smallGreatDgt == - 1 ) { smallGreatDgt = i ; } else if ( str [ i ] >= str [ smallGreatDgt ] ) { smallGreatDgt = i ; } } } if ( index == - 1 ) { return \" \" ; } if ( smallGreatDgt != - 1 ) { str = swap ( str , index , smallGreatDgt ) ; return str ; } return \" \" ; } function swap ( str , i , j ) { let ch = str . split ( ' ' ) ; let temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; return ch . join ( \" \" ) ; } let str = \" \" ; document . write ( prevNum ( str ) ) ;"}
{"text": "SGN Nilai polinomial | Pulangan nilai poli [0] x (n - 1) + poli [1] x (n - 2) +. . + poli [n - 1]; Memulakan hasil; Menilai nilai polinomial menggunakan kaedah Horner; Mengembalikan nilai tanda polinomial; Marilah kita menilai nilai 2 x3 - 6 x2 + 2 x - 1 untuk x = 3", "code": "function horner ( poly , n , x ) { var result = poly [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; } function findSign ( poly , n , x ) { var result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return - 1 ; return 0 ; } var poly = [ 2 , - 6 , 2 , - 1 ] ; var x = 3 ; var n = poly . length ; document . write ( \" \" + findSign ( poly , n , x ) ) ;"}
{"text": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | Program JavaScript untuk mencari nombor minimum untuk memasukkan dalam array supaya jumlahnya adalah perdana; Array untuk menyimpan prima; berfungsi untuk mengira prima menggunakan ayak eratosthenes; Cari nombor perdana lebih besar daripada nombor; Untuk mengembalikan nombor perdana lebih besar daripada n; Semak jika Num adalah Perdana; kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Panggil Sieveoferatostheneses untuk mengira prima; Untuk mencari jumlah elemen array; Untuk mencari nombor perdana yang lebih besar maka jumlahnya; Mengembalikan perbezaan jumlah dan num; Program Pemandu", "code": "let MAX = 100005 ; let isPrime = new Array ( MAX ) . fill ( 0 ) ; function sieveOfEratostheneses ( ) { isPrime [ 1 ] = true ; for ( let i = 2 ; i * i < MAX ; i ++ ) { if ( ! isPrime [ i ] ) { for ( let j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = true ; } } } function findPrime ( n ) { let num = n + 1 ; while ( num > 0 ) { if ( ! isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; } function minNumber ( arr , n ) { sieveOfEratostheneses ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( ! isPrime [ sum ] ) return 0 ; let num = findPrime ( sum ) ; return num - sum ; } let arr = [ 2 , 4 , 6 , 8 , 12 ] ; let n = arr . length ; document . write ( minNumber ( arr , n ) ) ;"}
{"text": "Jumlah semua subarray | Tetapkan 1 | Mengira jumlah semua sub - array; Pilih titik permulaan; Memilih titik akhir; jumlah subarray antara titik permulaan dan akhir semasa; program pemacu untuk menguji fungsi di atas", "code": "function SubArraySum ( arr , n ) { let result = 0 , temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( let j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; } let arr = [ 1 , 2 , 3 ] ; let n = arr . length ; document . write ( \" \" + SubArraySum ( arr , n ) + \" \" ) ;"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program JavaScript untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Kod pemacu", "code": "function highestPowerof2 ( n ) { let p = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; return Math . pow ( 2 , p ) ; } let n = 10 ; document . write ( highestPowerof2 ( n ) ) ;"}
{"text": "Cari (a ^ b) % m di mana 'a' sangat besar | Fungsi utiliti untuk mengira % m; (S [i] - '0') memberikan nilai digit dan membentuk nombor; Pulangan mencari (a ^ b) % m; Cari % m; Sekarang kalikan Ans dengan b - 1 kali dan ambil mod dengan m; Kod pemacu", "code": "function aModM ( s , mod ) { let number = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { number = ( number * 10 ) ; let x = ( s [ i ] - ' ' ) ; number = number + x ; number %= mod ; } return number ; } function ApowBmodM ( a , b , m ) { let ans = aModM ( a , m ) ; let mul = ans ; for ( let i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; } let a = \" \" ; let b = 3 , m = 11 ; document . write ( ApowBmodM ( a , b , m ) ) ;"}
{"text": "Interpolasi LaGrange | Untuk mewakili titik data yang sepadan dengan x dan y = f (x); Fungsi untuk menginterpolasi titik data yang diberikan menggunakan Formula XI LaGrange sepadan dengan titik data baru yang nilainya diperoleh n mewakili bilangan titik data yang diketahui; biarkan hasil = 0; Memulakan hasil; Mengira syarat individu di atas formula; Tambah istilah semasa untuk menghasilkan; mewujudkan pelbagai 4 mata data yang diketahui; Menggunakan fungsi interpolasi untuk mendapatkan titik data yang sepadan dengan x = 3", "code": "class Data { constructor ( x , y ) { this . x = x ; this . y = y ; } } function interpolate ( f , xi , n ) { for ( let i = 0 ; i < n ; i ++ ) { let term = f [ i ] . y ; for ( let j = 0 ; j < n ; j ++ ) { if ( j != i ) term = term * ( xi - f [ j ] . x ) / ( f [ i ] . x - f [ j ] . x ) ; } result += term ; } return result ; } let f = [ new Data ( 0 , 2 ) , new Data ( 1 , 3 ) , new Data ( 2 , 12 ) , new Data ( 5 , 147 ) ] ; document . write ( \" \" + interpolate ( f , 3 , 4 ) ) ;"}
{"text": "Sieve of Sundaram untuk mencetak semua prima yang lebih kecil daripada n | Mencetak semua nombor perdana yang lebih kecil; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahu prima lebih kecil daripada N, kita mengurangkan N hingga separuh; Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j; Memulakan semua elemen sebagai tidak ditandakan; Logik utama Sundaram. Tandakan semua nombor bentuk i + j + 2 ij sebagai benar di mana 1 <= i <= j; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Program Pemandu", "code": "function SieveOfSundaram ( n ) { let nNew = ( n - 1 ) / 2 ; let marked = [ ] ; for ( let i = 0 ; i < nNew + 1 ; i ++ ) marked [ i ] = false ; for ( let i = 1 ; i <= nNew ; i ++ ) for ( let j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) document . write ( 2 + \" \" ) ; for ( let i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) document . write ( 2 * i + 1 + \" \" ) ; return - 1 ; } let n = 20 ; SieveOfSundaram ( n ) ;"}
{"text": "Bina Arahan Asal Bermula dengan K dari pelbagai xor semua elemen kecuali elemen pada indeks yang sama | Berfungsi untuk membina array dengan setiap elemen yang sama dengan XOR semua elemen array kecuali elemen pada indeks yang sama; Array asal; Kedai bitwise xor array; Hitung XOR semua elemen array; Cetak array asal B []; Kod pemacu; Panggilan fungsi", "code": "function constructArray ( A , N , K ) { let B = new Array ( N ) ; let totalXOR = A [ 0 ] ^ K ; for ( let i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( let i = 0 ; i < N ; i ++ ) { document . write ( B [ i ] + \" \" ) ; } } let A = [ 13 , 14 , 10 , 6 ] , K = 2 ; let N = A . length ; constructArray ( A , N , K ) ;"}
{"text": "Cari elemen tambahan dalam array kedua | Berfungsi untuk mengembalikan elemen tambahan dalam b []; Untuk menyimpan hasilnya; Cari xor semua elemen array a [] dan array b []; Kod pemacu", "code": "function extraElement ( A , B , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( let i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; } let A = [ 10 , 15 , 5 ] ; let B = [ 10 , 100 , 15 , 5 ] ; let n = A . length ; document . write ( extraElement ( A , B , n ) ) ;"}
{"text": "Hamming jarak antara dua bilangan bulat | Fungsi untuk mengira jarak Hamming; Kod pemacu", "code": "function hammingDistance ( n1 , n2 ) { let x = n1 ^ n2 ; let setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; } let n1 = 9 , n2 = 14 ; document . write ( hammingDistance ( 9 , 14 ) ) ;"}
{"text": "Cetak bitwise dan set nombor n | berfungsi untuk mencari pendekatan yang cekap subset bitwise; Kod pemacu", "code": "function printSubsets ( n ) { for ( let i = n ; i > 0 ; i = ( i - 1 ) & n ) document . write ( i + \" \" ) ; document . write ( \" \" ) ; } let n = 9 ; printSubsets ( n ) ;"}
{"text": "Cari bit set yang paling ketara | Program JavaScript untuk mencari nombor MSB untuk diberikan n. ; Untuk mencari kedudukan bit set yang paling penting; Untuk mengembalikan nilai nombor dengan set bit pada kedudukan k - th; Kod pemacu", "code": "function setBitNumber ( n ) { let k = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; return 1 << k ; } let n = 273 ; document . write ( setBitNumber ( n ) ) ;"}
{"text": "Bilangan minimum subset dengan elemen yang berbeza | Fungsi untuk mengira subset sedemikian rupa sehingga semua subset mempunyai elemen yang berbeza. ; Ambil input dan mulakan res = 0; Susun array; Melintasi array input dan cari kekerapan maksimum; Untuk setiap nombor mencari pengulangan / kekerapannya; Kemas kini res; Kod pemacu", "code": "function subset ( ar , n ) { let res = 0 ; ar . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; } let arr = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] ; let n = 7 ; document . write ( subset ( arr , n ) ) ;"}
{"text": "Kira cara untuk mewakili nombor sebagai jumlah kotak yang sempurna | Simpan kotak sempurna kurang daripada atau sama dengan n; Fungsi utiliti untuk mengira dataran sempurna kurang daripada atau sama dengan n; Berfungsi untuk mencari bilangan cara untuk mewakili nombor sebagai jumlah kuadrat yang sempurna; Mengendalikan kes asas; Sertakan elemen indeks I - th; Tidak termasuk elemen indeks i - th; Mengembalikan hasilnya; Diberikan input; Precomment squares sempurna <= n; Panggilan fungsi", "code": "var psquare = [ ] function calcPsquare ( N ) { var i ; for ( i = 1 ; i * i <= N ; i ++ ) psquare . push ( i * i ) ; } function countWays ( index , target ) { if ( target == 0 ) return 1 ; if ( index < 0 target < 0 ) return 0 ; var inc = countWays ( index , target - psquare [ index ] ) ; var exc = countWays ( index - 1 , target ) ; return inc + exc ; } var N = 9 ; calcPsquare ( N ) ; document . write ( countWays ( psquare . length - 1 , N ) ) ;"}
{"text": "Jumlah jarak semua nod dari nod yang diberikan | Program JavaScript untuk pendekatan di atas; Struktur nod pokok binari; Fungsi yang memperuntukkan nod baru dengan data yang diberikan dan batal ke petunjuk kiri dan kanannya; Berfungsi untuk mengira bilangan nod di subtrees kiri dan kanan; Memulakan pasangan yang menyimpan pasangan {bilangan nod, kedalaman}; Mencari bilangan nod di subtree kiri; Cari bilangan nod di subtree yang betul; Mengisi medan saiz; Menyimpan jumlah jarak semua nod dari nod yang diberikan; Berfungsi untuk mencari jarak keseluruhan; Jika nod sasaran sepadan dengan nod semasa; Jika akar. Kiri tidak batal; Kemas kini Jumlah; Berulang untuk subtree kiri; Jika akar. Kanan tidak batal; Memohon formula yang diberikan dalam pendekatan; Berulang untuk subtree yang betul; Pokok input; Jumlah nod; Cetak jumlah jarak", "code": "class pair { constructor ( first , second ) { this . first = first ; this . second = second ; } } class Node { constructor ( data ) { this . data = data ; this . size = 0 ; this . left = this . right = null ; } } function sumofsubtree ( root ) { let p = new pair ( 1 , 0 ) ; if ( root . left != null ) { let ptemp = sumofsubtree ( root . left ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } if ( root . right != null ) { let ptemp = sumofsubtree ( root . right ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } root . size = p . first ; return p ; } let sum = 0 ; function distance ( root , target , distancesum , n ) { if ( root . data == target ) { sum = distancesum ; } if ( root . left != null ) { let tempsum = distancesum - root . left . size + ( n - root . left . size ) ; distance ( root . left , target , tempsum , n ) ; } if ( root . right != null ) { let tempsum = distancesum - root . right . size + ( n - root . right . size ) ; distance ( root . right , target , tempsum , n ) ; } } let root = new Node ( 1 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 3 ) ; root . left . left = new Node ( 4 ) ; root . left . right = new Node ( 5 ) ; root . right . left = new Node ( 6 ) ; root . right . right = new Node ( 7 ) ; root . left . left . left = new Node ( 8 ) ; root . left . left . right = new Node ( 9 ) ; let target = 3 ; let p = sumofsubtree ( root ) ; let totalnodes = p . first ; distance ( root , target , p . second , totalnodes ) ; document . write ( sum + \" \" ) ;"}
{"text": "Menyusun semula array sedemikian rupa sehingga jumlah elemen yang diindeks yang sama adalah atmost k | Arahan terbalik; Fungsi untuk menyusun semula array sedemikian rupa sehingga jumlah unsur -unsur yang diindeks yang sama tidak melebihi k; Susun array b [] dalam urutan menurun; Jika keadaan gagal; Prlet array; Diberikan susunan", "code": "function reverse ( a ) { let i , n = a . length , t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; } function rearrangeArray ( A , B , N , K ) { B . sort ( ) ; B = reverse ( B ) ; let flag = true ; for ( let i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > K ) { flag = false ; break ; } } if ( ! flag ) { document . write ( \" \" + \" \" ) ; } else { for ( let i = 0 ; i < N ; i ++ ) { document . write ( B [ i ] + \" \" ) ; } } } let A = [ 1 , 2 , 3 , 4 , 2 ] ; let B = [ 1 , 2 , 3 , 1 , 1 ] ; let N = A . length ; let K = 5 ; rearrangeArray ( A , B , N , K ) ;"}
{"text": "Kira baris dengan jumlah melebihi jumlah matriks yang tinggal | Program JavaScript untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira bilangan baris yang jumlahnya melebihi jumlah unsur -unsur matriks yang tinggal; Untuk menyimpan hasilnya; Menyimpan jumlah keseluruhan unsur matriks; Kirakan jumlah keseluruhan; Melintasi untuk memeriksa setiap baris; Menyimpan jumlah elemen baris semasa; Kirakan jumlah elemen baris semasa; Jika jumlah baris semasa melebihi jumlah sisa matriks; Peningkatan kiraan; Cetak hasilnya; Diberikan matriks; Panggilan fungsi", "code": "var N = 3 var M = 3 function countRows ( mat ) { var count = 0 ; var totalSum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < M ; j ++ ) { totalSum += mat [ i ] [ j ] ; } } for ( var i = 0 ; i < N ; i ++ ) { var currSum = 0 ; for ( var j = 0 ; j < M ; j ++ ) { currSum += mat [ i ] [ j ] ; } if ( currSum > totalSum - currSum ) count ++ ; } document . write ( count ) ; } var mat = [ [ 2 , - 1 , 5 ] , [ - 3 , 0 , - 2 ] , [ 5 , 1 , 2 ] ] ; countRows ( mat ) ;"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Susun array; Selepas menyusun, periksa sama ada elemen semasa sama seperti sebelumnya atau satu lagi. ; Program Pemandu", "code": "function areElementsContiguous ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] > 1 ) return false ; return true ; } let arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] ; let n = arr . length ; if ( areElementsContiguous ( arr , n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Cari elemen maksimum dan minimum. ; Harus ada sekurang -kurangnya elemen M di Aaray untuk menjadikannya bersebelahan. ; Buat array yang dikunjungi dan mulakan palsu. ; Tandakan elemen sebagai benar. ; Jika mana -mana elemen tidak ditandakan, semua elemen tidak bersebelahan. ; Program Pemandu", "code": "function areElementsContiguous ( arr , n ) { let max = Number . MIN_VALUE ; let min = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } let m = max - min + 1 ; if ( m > n ) return false ; let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( let i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; } let arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] ; let n = arr . length ; if ( areElementsContiguous ( arr , n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | Berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Menyimpan unsur -unsur 'arr []' dalam jadual hash 'kami'; sebagai Arr [0] hadir dalam 'kami'; Bermula dengan elemen yang lebih kecil sebelumnya ARR [0]; jika 'curr _ ele' hadir dalam 'kami'; kiraan kenaikan; mengemas kini 'curr_ele'; bermula dengan elemen yang lebih besar dari arr [0]; jika 'curr _ ele' hadir dalam 'us'; kiraan kenaikan; kemas kini 'curr_ele \"; pulangan benar jika array mengandungi satu set bilangan bulat bersebelahan lain kembali palsu; Program Pemandu untuk diuji di atas", "code": "function areElementsContiguous ( arr , n ) { var us = new Set ( ) ; for ( var i = 0 ; i < n ; i ++ ) us . add ( arr [ i ] ) ; var count = 1 ; var curr_ele = arr [ 0 ] - 1 ; while ( us . has ( curr_ele ) ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . has ( curr_ele ) ) { count ++ ; curr_ele ++ ; } return ( count == ( us . size ) ) ; } var arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] ; var n = arr . length ; if ( areElementsContiguous ( arr , n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Subarray terpanjang tidak mempunyai lebih banyak daripada elemen yang berbeza | berfungsi untuk mencetak pelbagai sub - paling lama; Tandakan elemen yang dikunjungi; Jika ia dikunjungi kali pertama, maka tingkatkan kaunter unsur -unsur yang berbeza dengan 1; Apabila kaunter unsur -unsur yang berbeza meningkat dari k, kemudian mengurangkannya kepada k; Dari sebelah kiri, mengurangkan bilangan masa lawatan; Sekiranya elemen masa yang dikurangkan tidak terdapat dalam segmen selanjutnya maka mengurangkan kiraan unsur -unsur yang berbeza; meningkatkan tanda subsegment; Semak panjang sub -segmen terpanjang apabila lebih besar kemudian sebelum ini kemudian tukarnya; Cetak segmen sub - terpanjang; program pemacu untuk menguji fungsi di atas", "code": "function longest ( a , n , k ) { var freq = Array ( 7 ) . fill ( 0 ) ; var start = 0 , end = 0 , now = 0 , l = 0 ; for ( var i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( var i = start ; i <= end ; i ++ ) document . write ( a [ i ] + \" \" ) ; } var a = [ 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 ] ; var n = a . length ; var k = 3 ; longest ( a , n , k ) ;"}
{"text": "Periksa sama ada Kira K dalam mana -mana Titik | Fungsi yang mengembalikan benar jika mana -mana segmen K bertindih pada bila -bila masa; Vektor untuk menyimpan titik permulaan dan titik akhir; Titik permulaan ditandakan dengan - 1 dan titik berakhir dengan + 1; Susun vektor dengan elemen pertama; Tumpukan untuk menyimpan tumpang tindih; Dapatkan elemen semasa; Jika ia adalah titik permulaan; Tolaknya dalam timbunan; Ia adalah titik akhir; Pop elemen dari timbunan; Jika lebih daripada K -ranges bertindih; Kod pemacu", "code": "function kOverlap ( pairs , k ) { var vec = [ ] ; for ( var i = 0 ; i < pairs . length ; i ++ ) { vec . push ( [ pairs [ i ] [ 0 ] , - 1 ] ) ; vec . push ( [ pairs [ i ] [ 1 ] , + 1 ] ) ; } vec . sort ( ( a , b ) => { if ( a [ 0 ] != b [ 0 ] ) return a [ 0 ] - b [ 0 ] return a [ 1 ] - b [ 1 ] } ) ; var st = [ ] ; for ( var i = 0 ; i < vec . length ; i ++ ) { var cur = vec [ i ] ; if ( cur [ 1 ] == - 1 ) { st . push ( cur ) ; } else { st . pop ( ) ; } if ( st . length >= k ) { return true ; } } return false ; } var pairs = [ ] ; pairs . push ( [ 1 , 3 ] ) ; pairs . push ( [ 2 , 4 ] ) ; pairs . push ( [ 3 , 5 ] ) ; pairs . push ( [ 7 , 10 ] ) ; var n = pairs . length , k = 3 ; if ( kOverlap ( pairs , k ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Cari julat terkecil yang mengandungi elemen dari senarai k | Program JavaScript untuk mengetahui julat terkecil yang merangkumi unsur -unsur dari setiap senarai disusun yang diberikan. ; array untuk menyimpan indeks semasa senarai i; Fungsi ini mengambil senarai yang disusun dalam bentuk array 2D sebagai hujah. Ia mendapati pelbagai terkecil yang merangkumi unsur -unsur dari setiap senarai K. ; memulakan ke 0 indeks; ; untuk mengekalkan indeks senarai yang mengandungi elemen minimum; melangkah ke atas semua senarai; Jika setiap elemen senarai [i] dilalui maka memecahkan gelung; Cari nilai minimum di antara semua elemen senarai yang menunjuk oleh array PTR []; mengemas kini indeks senarai; Cari nilai maksimum di antara semua elemen senarai yang menunjuk oleh array PTR []; Sekiranya ada senarai ekzos, kami tidak akan mendapat jawapan yang lebih baik, jadi pecahkan gelung sementara; mengemas kini Minrange; Program pemacu untuk menguji fungsi di atas", "code": "let N = 5 ; let ptr = new Array ( 501 ) ; function findSmallestRange ( arr , n , k ) { let i , minval , maxval , minrange , minel = 0 , maxel = 0 , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; } minrange = Number . MAX_VALUE ; while ( true ) { minind = - 1 ; minval = Number . MAX_VALUE ; maxval = Number . MIN_VALUE ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag == 1 ) { break ; } ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } document . write ( \" \" + minel + \" \" + maxel + \" \" ) ; } let arr = [ [ 4 , 7 , 9 , 12 , 15 ] , [ 0 , 8 , 10 , 14 , 20 ] , [ 6 , 12 , 16 , 30 , 50 ] ] let k = arr . length ; findSmallestRange ( arr , N , k ) ;"}
{"text": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | berfungsi untuk mencari d terbesar; Susun array dalam urutan menaik; melangkah dari belakang untuk mencari D terbesar yang diperlukan; Oleh kerana semua empat A, B, C, D harus berbeza; Jika gabungan semasa J, K, L dalam set adalah sama dengan S [i] mengembalikan nilai ini kerana ini akan menjadi dsince terbesar kita meleleh dalam urutan menurun; Kod pemacu", "code": "function findLargestd ( S , n ) { let found = false ; S . sort ( ) ; for ( let i = n - 1 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( let k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( let l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Number . MAX_VALUE ; return - 1 ; } let S = [ 2 , 3 , 5 , 7 , 12 ] ; let n = S . length ; let ans = findLargestd ( S , n ) ; if ( ans == Number . MAX_VALUE ) document . write ( \" \" ) ; else document . write ( \" \" + \" \" + ans ) ;"}
{"text": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | Untuk menyimpan dan mengambil indeks pasangan i & j; Fungsi ini menemui empat elemen dengan jumlah x yang diberikan; Jumlah wang (a + b) semua pasangan (a, b) dalam jadual hash; Melintasi semua pasangan dan mencari (D - C) hadir dalam jadual hash; Jika d - c ada dalam jadual hash ,; Memastikan semua elemen adalah elemen array yang berbeza dan elemen tidak dianggap lebih dari sekali. ; Kod pemacu", "code": "class Indexes { constructor ( i , j ) { this . i = i ; this . j = j ; } getI ( ) { return this . i ; } getJ ( ) { return this . j ; } } function findFourElements ( arr , n ) { let map = new Map ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { map . set ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } let d = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( map . has ( abs_diff ) ) { let indexes = map . get ( abs_diff ) ; if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; } let arr = [ 2 , 3 , 5 , 7 , 12 ] ; let n = arr . length ; let res = findFourElements ( arr , n ) ; if ( res == Number . MIN_VALUE ) document . write ( \" \" ) ; else document . write ( res ) ;"}
{"text": "Memaksimumkan kiraan elemen yang boleh dipilih mempunyai perbezaan minimum antara jumlah dan k | Berfungsi untuk mengira bilangan maksimum elemen yang boleh dipilih; Susun array; Melintasi array; Tambah elemen semasa ke jumlah; Jika jumlah melebihi k; Kiraan kenaikan; Mengembalikan kiraan;  ; Panggilan fungsi", "code": "function CountMaximum ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; let sum = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } let arr = [ 30 , 30 , 10 , 10 ] ; let n = arr . length ; let k = 50 ; document . write ( CountMaximum ( arr , n , k ) ) ;"}
{"text": "Program untuk Putaran Array | Berfungsi ke kiri berputar arr [] saiz n oleh 1; Berfungsi ke kiri berputar saiz n oleh d; fungsi utiliti untuk mencetak array; Program pemacu untuk menguji fungsi di atas", "code": "function leftRotatebyOne ( arr , n ) { var i , temp ; temp = arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } function leftRotate ( arr , d , n ) { for ( i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; } function printArray ( arr , n ) { for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + \" \" ) ; } var arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ; leftRotate ( arr , 2 , 7 ) ; printArray ( arr , 7 ) ;"}
{"text": "Susun array dalam julat indeks yang diberikan | Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Arahan sementara; Susun array sementara; Mengubah suai array asal dengan elemen array sementara; Cetak array yang diubah suai; Kod pemacu; panjang array", "code": "function partSort ( arr , N , a , b ) { let l = Math . min ( a , b ) ; let r = Math . max ( a , b ) ; let temp = new Array ( r - l + 1 ) ; temp . fill ( 0 ) ; let j = 0 ; for ( let i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } temp . sort ( function ( a , b ) { return a - b } ) ; j = 0 ; for ( let i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; } } let arr = [ 7 , 8 , 4 , 5 , 2 ] ; let a = 1 , b = 4 ; let N = arr . length ; partSort ( arr , N , a , b ) ;"}
{"text": "Penyusun baris matriks dalam urutan menurun diikuti oleh lajur dalam urutan menaik | Pelaksanaan JavaScript untuk menyusun baris matriks dalam urutan menurun diikuti dengan menyusun lajur dalam urutan menaik; Fungsi untuk menyusun setiap baris matriks mengikut perintah yang ditentukan oleh turun. ; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris tikar [] [] dalam urutan menurun; dapatkan transpose tikar [] []; Sekali lagi menyusun baris Mat [] [] dalam urutan menaik. ; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu", "code": "let MAX_SIZE = 10 ; function sortByRow ( mat , n , descending ) { let temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( descending == true ) { let t = i ; for ( let p = 0 ; p < n ; p ++ ) { for ( let j = p + 1 ; j < n ; j ++ ) { if ( mat [ t ] [ p ] < mat [ t ] [ j ] ) { temp = mat [ t ] [ p ] ; mat [ t ] [ p ] = mat [ t ] [ j ] ; mat [ t ] [ j ] = temp ; } } } } else mat [ i ] . sort ( function ( a , b ) { return a - b ; } ) ; } } function transpose ( mat , n ) { let temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } } } function sortMatRowAndColWise ( mat , n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; } function printMat ( mat , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) document . write ( mat [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; } } let n = 3 ; let mat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ] ; document . write ( \" \" ) ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; document . write ( \" \" + \" \" ) ; printMat ( mat , n ) ;"}
{"text": "Pindahkan semua sifar ke hujung array | Fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang ditemui bukan sifar, kemudian gantikan elemen pada indeks 'kiraan' dengan elemen ini; Di sini kiraan adalah; Tambahan sekarang semua elemen bukan sifar telah beralih ke depan dan 'kiraan' ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; Kod pemacu", "code": "function pushZerosToEnd ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } let arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] ; let n = arr . length ; pushZerosToEnd ( arr , n ) ; document . write ( \" \" ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + \" \" ) ;"}
{"text": "Pindahkan semua sifar ke hujung array | Set | berfungsi untuk memindahkan semua sifar pada akhir array; Kiraan unsur bukan sifar; Melintasi array. Jika arr [i] bukan sifar, maka swap elemen pada indeks 'kiraan' dengan elemen pada indeks 'i'; berfungsi untuk mencetak elemen array; Program Pemandu untuk diuji di atas", "code": "function moveZerosToEnd ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) { temp = arr [ count ] ; arr [ count ] = arr [ i ] ; arr [ i ] = temp ; count = count + 1 ; } } function printArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + \" \" ) ; } let arr = [ 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] ; let n = arr . length ; document . write ( \" \" ) ; printArray ( arr , n ) ; moveZerosToEnd ( arr , n ) ; document . write ( \" \" + \" \" ) ; printArray ( arr , n ) ;"}
{"text": "Gandakan elemen pertama dan gerakkan sifar ke akhir | fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang ditemui bukan sifar, kemudian gantikan elemen pada indeks 'kiraan' dengan elemen ini; Di sini kiraan ditingkatkan; Sekarang semua elemen bukan sifar telah beralih ke depan dan 'kiraan' ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; berfungsi untuk menyusun semula elemen array selepas pengubahsuaian; jika 'arr []' mengandungi satu elemen sahaja; melintasi array; Jika benar, lakukan pengubahsuaian yang diperlukan; nilai indeks semasa dua kali; Letakkan 0 dalam indeks seterusnya; kenaikan sebanyak 1 untuk memindahkan dua indeks di hadapan semasa lelaran gelung; tolak semua sifar pada akhir 'arr []'; berfungsi untuk mencetak elemen array; Program Pemandu untuk diuji di atas", "code": "function pushZerosToEnd ( arr , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } function modifyAndRearrangeArr ( arr , n ) { if ( n == 1 ) return ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] == arr [ i + 1 ] ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZerosToEnd ( arr , n ) ; } function printArray ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + \" \" ) ; } var arr = [ 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 ] ; var n = arr . length ; document . write ( \" \" ) ; printArray ( arr , n ) ; modifyAndRearrangeArr ( arr , n ) ; document . write ( \" \" ) ; document . write ( \" \" ) ; printArray ( arr , n ) ;"}
{"text": "Gandakan elemen pertama dan gerakkan sifar ke akhir | Berfungsi untuk menukar dua elemen array; beralih semua sifar ke sebelah kiri array; Mengekalkan indeks terakhir dengan nilai positif; Jika elemen bukan sifar; Swap Indeks Semasa, dengan LastSeen Non - Zero; Elemen seterusnya akan terakhir dilihat bukan - sifar", "code": "function swap ( A , i , j ) { let temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } function shiftAllZeroToLeft ( array , n ) { let lastSeenNonZero = 0 ; for ( let index = 0 ; index < n ; index ++ ) { if ( array [ index ] != 0 ) { swap ( array , array [ index ] , array [ lastSeenNonZero ] ) ; lastSeenNonZero ++ ; } } } }"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Fungsi utiliti untuk mencetak pelbagai saiz n; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Jika elemen semasa positif tidak melakukan apa -apa; Jika elemen semasa adalah negatif, pergeseran elemen positif ARR [0. i - 1], ke satu kedudukan di sebelah kanan mereka; Letakkan elemen negatif pada kedudukan yang betul; Kod pemacu", "code": "function printArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + \" \" ) ; document . write ( \" \" ) ; } function RearrangePosNeg ( arr , n ) { let key , j ; for ( let i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; if ( key > 0 ) continue ; j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } let arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] ; let n = arr . length ; RearrangePosNeg ( arr , n ) ; printArray ( arr , n ) ;"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Berfungsi untuk mencetak array; Fungsi untuk membalikkan array. Arahan boleh diterbalikkan dalam masa O (n) dan O (1) ruang. ; Menggabungkan dua subarray ARR []. Subarray pertama adalah arr [l. . m] subarray kedua adalah arr [m + 1. r]; Indeks awal Subarray 1 ST; Indeks awal IIND; arr [i. . M] adalah positif; arr [j. . r] adalah bahagian positif yang positif dari sub - array kiri (arr [i. m]); Bahagian negatif terbalik sub - array kanan (arr [m + 1 ... j - 1]); ARR terbalik [i. . J - 1]; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Kod pemacu", "code": "function printArray ( A , size ) { for ( let i = 0 ; i < size ; i ++ ) document . write ( A [ i ] + \" \" ) ; document . write ( \" \" ) ; } function reverse ( arr , l , r ) { if ( l < r ) { arr = swap ( arr , l , r ) ; reverse ( arr , ++ l , -- r ) ; } } function merge ( arr , l , m , r ) { let i = l ; let j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; } function RearrangePosNeg ( arr , l , r ) { if ( l < r ) { let m = l + Math . floor ( ( r - l ) / 2 ) ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } function swap ( arr , i , j ) { let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } let arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] ; let arr_size = arr . length ; RearrangePosNeg ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ;"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | pelaksanaan JavaScript pendekatan di atas; Gelung sehingga arr [i] <0 dan masih di dalam array; Gelung sehingga arr [j]> 0 dan masih di dalam array; jika saya kurang daripada j; Kod pemacu", "code": "function RearrangePosNeg ( arr ) { var i = 0 ; var j = arr . length - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < arr . length ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { var temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } } var arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] ; RearrangePosNeg ( arr ) ; for ( i = 0 ; i < arr . length ; i ++ ) document . write ( arr [ i ] + \" \" ) ;"}
{"text": "Cari pemain untuk dapat menggantikan elemen terakhir yang boleh digantikan oleh pembahagi | Fungsi untuk mencari pemenang permainan yang dimainkan berdasarkan keadaan yang diberikan; Kemenangan jika saiz array adalah ganjil; Jika tidak, B menang; Arahan input; Saiz array", "code": "function winner ( arr , N ) { if ( N % 2 === 1 ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } var arr = [ 24 , 45 , 45 , 24 ] ; var N = arr . length ; winner ( arr , N ) ;"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program JavaScript mudah untuk mencari semua elemen dalam array yang mempunyai sekurang -kurangnya dua elemen yang lebih besar sendiri. ; Pilih elemen satu demi satu dan hitung elemen yang lebih besar. Jika kiraan lebih daripada 2, cetak elemen itu. ; Kod pemacu", "code": "function findElements ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) document . write ( arr [ i ] + \" \" ) ; } } let arr = [ 2 , - 6 , 3 , 5 , 1 ] ; let n = arr . length ; findElements ( arr , n ) ;"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program JavaScript berasaskan Sorting untuk mencari semua elemen dalam array yang mempunyai dua elemen yang lebih besar sendiri. ; Kod pemacu", "code": "function findElements ( arr , n ) { arr . sort ( ) ; for ( let i = 0 ; i < n - 2 ; i ++ ) document . write ( arr [ i ] + \" \" ) ; } let arr = [ 2 , - 6 , 3 , 5 , 1 ] ; let n = arr . length ; findElements ( arr , n ) ;"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program JavaScript untuk mencari semua elemen dalam pelbagai yang mempunyai dua elemen yang lebih besar sendiri. ; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Kod pemacu", "code": "function findElements ( arr , n ) { let first = Number . MIN_VALUE ; let second = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) document . write ( arr [ i ] + \" \" ) ; } let arr = [ 2 , - 6 , 3 , 5 , 1 ] ; let n = arr . length ; findElements ( arr , n ) ;"}
{"text": "Kurangkan kiraan kenaikan setiap elemen subarray yang diperlukan untuk membuat array bukan | Berfungsi untuk mencari bilangan minimum operasi yang diperlukan untuk membuat array tidak meningkat; Menyimpan kiraan operasi yang diperlukan; Jika arr [i]> arr [i + 1], tiada kenaikan diperlukan. Jika tidak, tambahkan perbezaannya kepada jawapannya; Mengembalikan hasil res; Kod pemacu", "code": "function getMinOps ( arr ) { var res = 0 ; for ( i = 0 ; i < arr . length - 1 ; i ++ ) { res += Math . max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; } var arr = [ 1 , 3 , 4 , 1 , 2 ] ; document . write ( getMinOps ( arr ) ) ;"}
{"text": "Cari nombor yang paling kecil | Fungsi yang mengembalikan unsur -unsur terkecil yang hilang dalam array yang disusun. ; Separuh kiri mempunyai semua elemen dari 0 hingga pertengahan; Kod pemacu", "code": "function findFirstMissing ( array , start , end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } let arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 ] ; let n = arr . length ; document . write ( \" \" + findFirstMissing ( arr , 0 , n - 1 ) ) ;"}
{"text": "Cari nombor yang paling kecil | Program untuk mencari elemen yang hilang; * Perlawanan indeks dengan nilai pada indeks itu, bermakna elemen yang hilang tidak boleh sampai ke po; Program untuk mencari yang paling kecil hilang dalam pelbagai disusun; Semak jika 0 hilang dalam array; Cek adalah semua nombor 0 hingga n - 1 adalah prsent dalam array; Kod pemacu; Panggilan fungsi", "code": "function findFirstMissing ( arr , start , end , first ) { if ( start < end ) { let mid = ( start + end ) / 2 ; if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; } function findSmallestMissinginSortedArray ( arr ) { if ( arr [ 0 ] != 0 ) return 0 ; if ( arr [ arr . length - 1 ] == arr . length - 1 ) return arr . length ; let first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . length - 1 , first ) ; } let arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 7 ] ; let n = arr . length ; document . write ( \" \" + findSmallestMissinginSortedArray ( arr ) ) ;"}
{"text": "Jumlah maksimum supaya tidak ada dua elemen bersebelahan | Berfungsi untuk mengembalikan jumlah maksimum supaya tidak ada dua elemen bersebelahan; Max semasa tidak termasuk i; Max semasa termasuk i; Kembali max incl and excl; Kod pemacu", "code": "function FindMaxSum ( arr , n ) { let incl = arr [ 0 ] ; let excl = 0 ; let excl_new ; let i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } let arr = [ 5 , 5 , 10 , 100 , 10 , 5 ] ; document . write ( FindMaxSum ( arr , arr . length ) ) ;"}
{"text": "Langkah -langkah minimum untuk menukar semua laluan kiri ke bawah ke bawah dalam matriks sebagai palindrome | Tetapkan 2 | Program JavaScript untuk pendekatan di atas; Fungsi untuk mengira bilangan perubahan minimum; Jarak elemen dari (0, 0) akan saya julat [0, n + m - 2]; Frekuensi kedai [0, 9] pada jarak I; Memulakan frekuensi sebagai 0; Mengira frekuensi [0, 9]; Kekerapan Kekerapan Matriks nilai [i] [j] pada jarak i + j; Cari nilai dengan kekerapan maksimum dan hitung jumlah sel pada jarak i dari hujung depan dan belakang belakang; Tukar semua nilai ke nilai dengan kekerapan maksimum; Kembalikan jawapannya; Diberikan matriks; Panggilan fungsi", "code": "var N = 7 ; function countChanges ( matrix , n , m ) { var dist = n + m - 1 ; var freq = Array . from ( Array ( dist ) , ( ) => Array ( 10 ) ) ; for ( var i = 0 ; i < dist ; i ++ ) { for ( var j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } var min_changes_sum = 0 ; for ( var i = 0 ; i < parseInt ( dist / 2 ) ; i ++ ) { var maximum = 0 ; var total_values = 0 ; for ( var j = 0 ; j < 10 ; j ++ ) { maximum = Math . max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; } var mat = [ [ 1 , 2 ] , [ 3 , 5 ] ] ; document . write ( countChanges ( mat , 2 , 2 ) ) ;"}
{"text": "Jadual jarang | Program JavaScript untuk melakukan pelbagai pertanyaan minimum menggunakan jadual jarang; Lookup [i] [j] akan menyimpan nilai minimum dalam arr [i. . j]. Saiz jadual cari yang ideal tidak boleh diperbaiki dan harus ditentukan menggunakan n log n. Ia tetap berterusan untuk memastikan kod mudah. ; Mengisi carian array carian [] [] dengan cara bawah. ; Memulakan m untuk selang dengan panjang 1; Mengira nilai dari selang yang lebih kecil hingga lebih besar; Kirakan nilai minimum untuk semua selang dengan saiz 2 ^ j; Untuk arr [2] [10], kami membandingkan arr [lookup [0] [7]] dan arr [lookup [3] [10]]; Mengembalikan minimum arr [l. . R]; Cari kuasa tertinggi 2 yang lebih kecil daripada atau sama dengan mengira unsur -unsur dalam julat yang diberikan. Untuk [2, 10], j = 3; Kirakan minimum unsur -unsur terakhir dengan unsur -unsur pertama dalam julat. Untuk [2, 10], kami membandingkan arr [lookup [0] [3]] dan arr [lookup [3] [3]] ,; Program Pemandu", "code": "var MAX = 500 ; var lookup = Array . from ( Array ( MAX ) , ( ) => Array ( MAX ) ) ; function buildSparseTable ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ; for ( var j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( var i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } } function query ( L , R ) { var j = parseInt ( Math . log2 ( R - L + 1 ) ) ; if ( lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] ) return lookup [ L ] [ j ] ; else return lookup [ R - ( 1 << j ) + 1 ] [ j ] ; } var a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] ; var n = a . length ; buildSparseTable ( a , n ) ; document . write ( query ( 0 , 4 ) + \" \" ) ; document . write ( query ( 4 , 7 ) + \" \" ) ; document . write ( query ( 7 , 8 ) ) ;"}
{"text": "Arahan terkecil lexicographically selepas di | Modifies arr [0 .. n - 1] kepada lexicographically terkecil dengan s swap. ; Tetapkan kedudukan di mana kita mahu meletakkan integer terkecil; Jika kita melebihi swap maksimum kemudian menamatkan gelung; Cari nilai minimum dari i + 1 hingga max k atau n; Tukar unsur -unsur dari kedudukan minimum yang kami dapati hingga sekarang ke indeks I; Tetapkan nilai akhir selepas menukar elemen POS - I; Kaedah pemacu; Fungsi panggilan; Cetak Array Akhir", "code": "function minimizeWithKSwaps ( arr , n , k ) { for ( let i = 0 ; i < n - 1 && k > 0 ; ++ i ) { let pos = i ; for ( let j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } let temp ; for ( let j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } } let arr = [ 7 , 6 , 9 , 2 , 1 ] ; let n = arr . length ; let k = 3 ; minimizeWithKSwaps ( arr , n , k ) ; document . write ( \" \" ) ; for ( let i = 0 ; i < n ; ++ i ) document . write ( arr [ i ] + \" \" ) ;"}
{"text": "Cari subarray purata maksimum K panjang | Pulangan permulaan indeks subarray purata maksimum panjang 'k'; Semak jika 'k' sah; Buat dan isi array untuk menyimpan jumlah kumulatif. csum [i] menyimpan jumlah arr [0] ke arr [i]; Memulakan max_sm sebagai jumlah subarray pertama; Cari jumlah subarray lain dan kemas kini max_sum jika diperlukan. ; Indeks permulaan kembali; Kod pemacu", "code": "function findMaxAverage ( arr , n , k ) { if ( k > n ) return - 1 ; let csum = new Array ( n ) ; csum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; let max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( let i = k ; i < n ; i ++ ) { let curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; } let arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] ; let k = 4 ; let n = arr . length ; document . write ( \" \" + \" \" + k + \" \" + findMaxAverage ( arr , n , k ) ) ;"}
{"text": "Cari subarray purata maksimum K panjang | Pulangan permulaan indeks subarray purata maksimum panjang 'k'; Semak jika 'k' sah; Mengira jumlah elemen 'k' pertama; Mengira jumlah subarray yang tinggal; Indeks permulaan kembali; Program Pemandu", "code": "function findMaxAverage ( arr , n , k ) { if ( k > n ) return - 1 ; let sum = arr [ 0 ] ; for ( let i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; let max_sum = sum ; let max_end = k - 1 ; for ( let i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; } let arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] ; let k = 4 ; let n = arr . length ; document . write ( \" \" + \" \" + k + \" \" + findMaxAverage ( arr , n , k ) ) ;"}
{"text": "Skor minimum mungkin untuk pemain dengan memilih satu atau dua elemen array berturut -turut dari array binari yang diberikan | Menyimpan skor minimum untuk setiap negeri sebagai peta <pasangan <pos, myturn>, ans>; Berfungsi untuk mencari skor minimum selepas memilih elemen dari array; Mengembalikan keadaan yang disimpan; Kes asas; Pemain A 'S giliran; Cari skor minimum; Simpan keadaan semasa; Mengembalikan hasilnya; Pemain B 's giliran; Cari skor minimum; Simpan keadaan semasa; Mengembalikan hasilnya; Fungsi yang mendapati penalti minimum selepas memilih elemen dari array binari yang diberikan; Memulakan kedudukan memilih elemen dari array; 0 menandakan pemain A Turn 1 menandakan pemain B giliran; Panggilan fungsi; Berfungsi untuk mencetak jawapan; Penalti minimum; Hitung jumlah semua elemen ARR; Cetak skor minimum; Kod pemacu", "code": "let m = new Map ( ) ; function findMinimum ( arr , N , pos , turn ) { let x = [ pos , turn ] ; if ( m . has ( x ) ) { return m [ x ] ; } if ( pos >= N - 1 ) { return 0 ; } if ( turn == 0 ) { let ans = Math . min ( findMinimum ( arr , N , pos + 1 , 1 ) + arr [ pos ] , findMinimum ( arr , N , pos + 2 , 1 ) + arr [ pos ] + arr [ pos + 1 ] ) ; let v = [ pos , turn ] ; m [ v ] = ans ; return ans ; } if ( turn != 0 ) { let ans = Math . min ( findMinimum ( arr , N , pos + 1 , 0 ) , findMinimum ( arr , N , pos + 2 , 0 ) ) ; let v = [ pos , turn ] ; m [ v ] = ans ; return ans ; } return 0 ; } function countPenality ( arr , N ) { let pos = 0 ; let turn = 0 ; return findMinimum ( arr , N , pos , turn ) + 1 ; } function printAnswer ( arr , N ) { let a = countPenality ( arr , N ) ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } document . write ( a ) ; } let arr = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 ] ; let N = 8 ; printAnswer ( arr , N ) ;"}
{"text": "Jumlah nombor utama dalam julat [l, r] dari array yang diberikan untuk pertanyaan q | Program JavaScript untuk pendekatan di atas; Berfungsi untuk mencari nombor perdana; Buat Boolean Array Prime [] dan memulakan semua penyertaannya sebagai benar nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana; Semak jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat nombor IT yang berganda p dan kurang daripada p ^ 2 telah ditandakan; Berfungsi untuk mendapatkan indeks pertengahan dari indeks sudut; Berfungsi untuk mendapatkan jumlah nilai dalam julat array yang diberikan; Jika segmen nod ini adalah sebahagian daripada julat yang diberikan, maka kembalikan jumlah segmen; Jika segmen nod ini berada di luar julat yang diberikan; Jika sebahagian daripada segmen ini bertindih dengan julat yang diberikan; Fungsi untuk mengemas kini nod yang mempunyai indeks yang diberikan dalam julatnya; Jika indeks input terletak di luar julat segmen ini; Jika indeks input berada dalam julat nod ini, maka kemas kini nilai nod dan anak -anaknya; Berfungsi untuk mengemas kini nilai dalam array input dan pokok segmen; Semak indeks input yang salah; Dapatkan perbezaan antara nilai baru dan nilai lama; Kemas kini nilai dalam array; Kemas kini nilai nod dalam pokok segmen hanya jika sama ada nilai sebelumnya atau nilai baru atau kedua -duanya adalah perdana; Jika hanya nilai baru adalah perdana; Jika hanya nilai baru adalah perdana; Jika kedua -duanya adalah perdana; Pulangan Jumlah Elemen dalam Julat dari Indeks QS (Permulaan Permintaan) ke QE (End Query). Ia terutamanya menggunakan getSumutil (); Semak nilai input yang salah; Fungsi yang membina pokok segmen; Jika terdapat satu elemen dalam array, simpannya dalam nod semasa pokok segmen dan kembali; Hanya tambah unsur -unsur dalam pokok segmen yang utama; Sekiranya terdapat lebih daripada satu elemen, maka berulang untuk subtrees kiri dan kanan dan simpan jumlah nilai dalam nod ini; Fungsi untuk membina pokok segmen dari array yang diberikan; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan ST; Mengembalikan pokok segmen yang dibina; Kod pemacu; Panggilan fungsi; Membina pokok segmen dari array yang diberikan; Cetak jumlah nilai dalam array dari indeks 1 hingga 3; Kemas kini: Tetapkan ARR [1] = 10 dan kemas kini nod pokok segmen yang sepadan; Cari jumlah selepas nilai dikemas kini", "code": "let MAX = 1000001 ; let prime = new Array ( MAX ) ; function SieveOfEratosthenes ( ) { prime . fill ( 1 ) ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == 1 ) { for ( let i = p * p ; i <= MAX - 1 ; i += p ) prime [ i ] = 0 ; } } } function getMid ( s , e ) { return s + parseInt ( ( e - s ) / 2 , 10 ) ; } function getSumUtil ( st , ss , se , qs , qe , si ) { if ( qs <= ss && qe >= se ) return st [ si ] ; if ( se < qs ss > qe ) return 0 ; let mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; } function updateValueUtil ( st , ss , se , i , diff , si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { let mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } } function updateValue ( arr , st , n , i , new_val ) { if ( i < 0 i > n - 1 ) { document . write ( \" \" ) ; return ; } let diff = new_val - arr [ i ] ; let prev_val = arr [ i ] ; arr [ i ] = new_val ; if ( ( prime [ new_val ] prime [ prev_val ] ) != 0 ) { if ( prime [ prev_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ; else if ( prime [ new_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ; else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } } function getSum ( st , n , qs , qe ) { if ( qs < 0 qe > n - 1 qs > qe ) { document . write ( \" \" ) ; return - 1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; } function constructSTUtil ( arr , ss , se , st , si ) { if ( ss == se ) { if ( prime [ arr [ ss ] ] != 0 ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; } let mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; } function constructST ( arr , n ) { let x = parseInt ( ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) ) , 10 ) ; let max_size = 2 * Math . pow ( 2 , x ) - 1 ; let st = new Array ( max_size ) ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } let arr = [ 1 , 3 , 5 , 7 , 9 , 11 ] ; let n = arr . length ; let Q = [ [ 1 , 1 , 3 ] , [ 2 , 1 , 10 ] , [ 1 , 1 , 3 ] ] ; SieveOfEratosthenes ( ) ; let st = constructST ( arr , n ) ; document . write ( getSum ( st , n , 1 , 3 ) + \" \" ) ; updateValue ( arr , st , n , 1 , 10 ) ; document . write ( getSum ( st , n , 1 , 3 ) + \" \" ) ;"}
{"text": "Kira bilangan cara untuk membina rentetan sasaran | Program JavaScript untuk mengira bilangan cara untuk membina rentetan sasaran; Kes asas; Jika subproblem semasa telah diselesaikan, gunakan nilai; Cari melalui semua yang ditunjukkan di mana watak semasa berlaku. Untuk setiap indeks yang lebih besar daripada sebelumnya, ambil indeks dan bergerak ke kedudukan seterusnya, dan tambahkan jawapannya. ; Simpan dan kembalikan penyelesaian untuk subproblem ini; PREPROCESS THE RINGS DENGAN MENYEDIAKAN UNTUK SETIAP KARAKTER SETIAP RENTING, INDEKS KELUARGA MEREKA KAMI AKAN MENGGUNAKAN SENARAI BERHUBUNGAN UNTUK SEMUA SETIAP HANYA SAHAJA INDEKS DALAM RENCEN DENGAN Watak dipilih; Kami menyimpan J + 1 kerana indeks yang dipilih awal dalam langkah rekursif akan NE 0. Ini hanya untuk kemudahan pelaksanaan; Inisiasi jadual DP. - 1 mewakili bahawa subproblem tidak diselesaikan; Kod pemacu", "code": "let mod = 1000000007 ; let dp = new Array ( 1000 ) ; for ( let i = 0 ; i < 1000 ; i ++ ) { dp [ i ] = new Array ( 1000 ) ; } function calculate ( pos , prev , s , index ) { if ( pos == s . length ) return 1 ; if ( dp [ pos ] [ prev ] != - 1 ) return dp [ pos ] [ prev ] ; let answer = 5 ; for ( let i = 0 ; i < index . length ; i ++ ) { if ( ( String . fromCharCode ( index [ i ] ) ) . localeCompare ( prev ) > 1 ) { answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod ; } } dp [ pos ] [ prev ] = answer ; return dp [ pos ] [ prev ] ; } function countWays ( a , s ) { let n = a . length ; let index = [ ] ; for ( let i = 0 ; i < 26 ; i ++ ) index . push ( [ ] ) ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < a [ i ] . length ; j ++ ) { index [ a [ i ] [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] . push ( j + 1 ) ; } } for ( let i = 0 ; i < 1000 ; i ++ ) { for ( let j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , 0 , s , index [ 0 ] ) ; } let A = [ ] ; A . push ( \" \" ) ; A . push ( \" \" ) ; A . push ( \" \" ) ; let S = \" \" ; document . write ( countWays ( A , S ) ) ;"}
{"text": "Count of integer dari julat [0, n] yang jumlah digitnya adalah pelbagai k | Pelaksanaan JavaScript pendekatan; Untuk menyimpan negeri -negeri DP; Berfungsi untuk mengembalikan kiraan nombor dari julat [0, n] yang jumlah digitnya adalah pelbagai k menggunakan dp bawah; Digit dalam indeks ini hanya boleh dari [0, num [idx]]; Digit dalam indeks ini boleh menjadi apa -apa dari [0, 9]; new_tight adalah nilai bendera untuk kedudukan seterusnya; Res tidak boleh menjadi negatif; Berfungsi untuk memproses rentetan ke vektor digit dari MSD ke LSD; Untuk nombor input besar n; Jumlah bilangan digit dalam n; Proses rentetan ke vektor digit dari MSD ke LSD", "code": "var MAX = 100005 ; var MOD = 1000000007 ; var dp = Array . from ( Array ( MAX ) , ( ) => Array ( 101 ) ) ; for ( var i = 0 ; i < MAX ; i ++ ) for ( var j = 0 ; j < 101 ; j ++ ) dp [ i ] [ j ] = new Array ( 2 ) . fill ( - 1 ) ; function countNum ( idx , sum , tight , num , len , k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) return dp [ idx ] [ sum ] [ tight ] ; var res = 0 , limit ; if ( tight == 0 ) { limit = num [ idx ] ; } else { limit = 9 ; } for ( var i = 0 ; i <= limit ; i ++ ) { var new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; } function process ( s ) { var num = [ ] ; for ( var i = 0 ; i < s . length ; i ++ ) { num . push ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; } return num ; } var n = \" \" ; var len = n . length ; var k = 58 ; var num = process ( n ) ; document . write ( countNum ( 0 , 0 , 0 , num , len , k ) ) ;"}
{"text": "Bilangan berikutnya dengan jumlah yang lebih baik dan ganjil | Pelaksanaan JavaScript untuk mencari bilangan berikutnya dengan jumlah yang lebih baik dan ganjil; Array untuk menyimpan kiraan walaupun seterusnya dan berikutnya yang ganjil; Inisialisasi counteven [0] dan countodd [0] hingga 0 kerana kerana tidak ada berikutnya sebelum lelaran dengan kiraan walaupun atau ganjil. ; Di sini Countodd [i] menandakan kiraan berikutnya yang ganjil sehingga i; jika nombor itu juga; Jika nombor itu ganjil; Kod pemacu", "code": "function countSum ( arr , n ) { var countODD = Array ( n + 1 ) . fill ( 0 ) ; var countEVEN = Array ( n + 1 ) . fill ( 0 ) ; countODD [ 0 ] = 0 ; countEVEN [ 0 ] = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { countEVEN [ i ] = countEVEN [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; countODD [ i ] = countODD [ i - 1 ] + countODD [ i - 1 ] ; } else { countEVEN [ i ] = countEVEN [ i - 1 ] + countODD [ i - 1 ] ; countODD [ i ] = countODD [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; } } var ans = [ 0 , 0 ] ; ans [ 0 ] = countEVEN [ n ] ; ans [ 1 ] = countODD [ n ] ; return ans ; } var arr = [ 1 , 2 , 2 , 3 ] ; var n = 4 ; var ans = countSum ( arr , n ) ; document . write ( \" \" + ans [ 0 ] ) ; document . write ( \" \" + ans [ 1 ] ) ;"}
{"text": "Double Knapsack | Pengaturcaraan Dinamik | Pelaksanaan JavaScript pendekatan di atas; Arahan 3D untuk menyimpan negeri -negeri DP; W1_R mewakili kapasiti selebihnya 1 stnapsack w2_r mewakili kapasiti selebihnya 2 nd knapsack I mewakili indeks array arr yang kami sedang kerjakan; Kes asas; Pembolehubah untuk menyimpan hasil tiga bahagian hubungan berulang; Simpan negeri dalam array 3d; Arahan input; Bilangan elemen dalam array; Kapasiti knapsacks; Berfungsi untuk dipanggil", "code": "var maxN = 31 var maxW = 31 var dp = Array ( maxN ) ; for ( var i = 0 ; i < maxN ; i ++ ) { dp [ i ] = Array ( maxW ) ; for ( var j = 0 ; j < maxW ; j ++ ) { dp [ i ] [ j ] = Array ( maxW ) . fill ( - 1 ) ; } } function maxWeight ( arr , n , w1_r , w2_r , i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; var fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = Math . max ( fill_none , Math . max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; } var arr = [ 8 , 2 , 3 ] ; var n = arr . length ; var w1 = 10 , w2 = 3 ; document . write ( maxWeight ( arr , n , w1 , w2 , 0 ) ) ;"}
{"text": "Jumlah bitwise dan semua submatrices | Program JavaScript untuk mencari jumlah bit - bijak dan semua submatrik; Berfungsi untuk mencari awalan - kiraan untuk setiap baris dari kanan ke kiri; Berfungsi untuk mencari bilangan submatrik dengan semua 1 s; Array untuk menyimpan kiraan awalan yang diperlukan 1 s dari kanan ke kiri untuk array boolean; Pembolehubah untuk menyimpan jawapan terakhir; Untuk setiap indeks lajur, tentukan bilangan sub -matriks bermula dari indeks itu dan mempunyai semua 1 s; Stack untuk menyimpan unsur -unsur dan kiraan nombor yang mereka muncul bahagian pertama pasangan adalah nilai elemen yang dimasukkan bahagian kedua adalah mengira bilangan elemen yang ditolak sebelum dengan nilai yang lebih besar; pembolehubah untuk menyimpan bilangan submatrik dengan semua 1 s; Berfungsi untuk mencari jumlah bitwise - dan semua submatrices; matriks untuk menyimpan status ith bit setiap elemen matriks arr; Kod pemacu", "code": "var n = 3 ; function findPrefixCount ( p_arr , set_bit ) { for ( var i = 0 ; i < n ; i ++ ) { for ( var j = n - 1 ; j >= 0 ; j -- ) { if ( ! set_bit [ i ] [ j ] ) continue ; if ( j != n - 1 ) p_arr [ i ] [ j ] += p_arr [ i ] [ j + 1 ] ; p_arr [ i ] [ j ] += set_bit [ i ] [ j ] ; } } } function matrixAllOne ( set_bit ) { var p_arr = Array . from ( Array ( n ) , ( ) => Array ( n ) . fill ( 0 ) ) ; findPrefixCount ( p_arr , set_bit ) ; var ans = 0 ; for ( var j = 0 ; j < n ; j ++ ) { var i = n - 1 ; var q = [ ] ; var to_sum = 0 ; while ( i >= 0 ) { var c = 0 ; while ( q . length != 0 && q [ q . length - 1 ] [ 0 ] > p_arr [ i ] [ j ] ) { to_sum -= ( q [ q . length - 1 ] [ 1 ] + 1 ) * ( q [ q . length - 1 ] [ 0 ] - p_arr [ i ] [ j ] ) ; c += q [ q . length - 1 ] [ 1 ] + 1 ; q . pop ( ) ; } to_sum += p_arr [ i ] [ j ] ; ans += to_sum ; q . push ( [ p_arr [ i ] [ j ] , c ] ) ; i -- ; } } return ans ; } function sumAndMatrix ( arr ) { var sum = 0 ; var mul = 1 ; for ( var i = 0 ; i < 30 ; i ++ ) { var set_bit = Array . from ( Array ( n ) , ( ) => Array ( n ) ) ; for ( var R = 0 ; R < n ; R ++ ) for ( var C = 0 ; C < n ; C ++ ) set_bit [ R ] [ C ] = ( ( arr [ R ] [ C ] & ( 1 << i ) ) != 0 ) ; sum += ( mul * matrixAllOne ( set_bit ) ) ; mul *= 2 ; } return sum ; } var arr = [ [ 9 , 7 , 4 ] , [ 8 , 9 , 2 ] , [ 11 , 11 , 5 ] ] ; document . write ( sumAndMatrix ( arr ) ) ;"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pendekatan bawah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; Noofways [i] akan menyimpan kiraan untuk 3 nilai terakhir sebelum i. ; Gelung hingga \"n + 1\" untuk mengira nilai untuk \"n\"; bilangan cara jika larian pertama adalah 1; Bilangan cara jika larian pertama adalah 2 dan larian kedua ialah 1; Ingat 3 nilai terakhir; Kod pemacu", "code": "function CountWays ( n ) { var noOfWays = Array ( 3 ) . fill ( 0 ) ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( var i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ 3 - 1 ] + noOfWays [ 3 - 3 ] ; noOfWays [ 0 ] = noOfWays [ 1 ] ; noOfWays [ 1 ] = noOfWays [ 2 ] ; noOfWays [ 2 ] = noOfWays [ i ] ; } return noOfWays [ n ] ; } var n = 5 ; document . write ( CountWays ( n ) ) ;"}
{"text": "Laluan Perdana Lexicographically terbesar dari atas | Pelaksanaan JavaScript pendekatan di atas; Carian pertama kedalaman; Kembali jika sel mengandungi nombor bukan perdana atau halangan, atau keluar dari matriks atau sudah melawat sel atau sudah menemui jalan terbesar leksikografi; Penandaan sel sudah dikunjungi; Menyimpan indeks laluan terbesar leksikografi; Jika sampai ke akhir matriks; Mengemas kini bilangan akhir langkah dalam laluan terbesar leksikografi; Bergerak pepenjuru (mencuba laluan terbesar leksikografi); Menggerakkan sel ke sel semasa; Bergerak sel ke sel semasa. ; Cetak jalan utama lexicographical terbesar; Untuk menyimpan indeks jalan utama terbesar lexicographical; Untuk menandakan jika sel sudah dilalui atau tidak; Melintasi DFS; Mencetak laluan utama terbesar lexicographical; Kembalikan bilangan jalan utama dalam matriks. ; Untuk setiap sel; Jika di barisan atas atau lajur paling kiri, tidak ada jalan di sana. ; Jika nombor bukan perdana; Mencari pemetaan matriks dengan mempertimbangkan nombor bukan perdana sebagai halangan dan nombor utama menjadi laluan yang sah. ; Ayak; Jika Perdana; Jika bukan Perdana; Kod pemacu", "code": "let MAX = 105 , q = 0 ; let prime = new Array ( MAX ) ; function sieve ( ) { for ( let i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( let j = i * i ; j < MAX ; j += i ) prime [ j ] = 1 ; } } } function dfs ( i , j , k , n , m , mappedMatrix , mark , ans ) { if ( ( mappedMatrix [ i ] [ j ] == 0 ? true : false ) || ( i > n ? true : false ) || ( j > m ? true : false ) || ( mark [ i ] [ j ] != 0 ? true : false ) || ( q != 0 ? true : false ) ) return ; mark [ i ] [ j ] = 1 ; ans [ k ] [ 0 ] = i ; ans [ k ] [ 1 ] = j ; if ( i == n && j == m ) { q = k ; return ; } dfs ( i + 1 , j + 1 , k + 1 , n , m , mappedMatrix , mark , ans ) ; dfs ( i + 1 , j , k + 1 , n , m , mappedMatrix , mark , ans ) ; dfs ( i , j + 1 , k + 1 , n , m , mappedMatrix , mark , ans ) ; } function lexicographicalPath ( n , m , mappedMatrix ) { let ans = new Array ( MAX ) ; let mark = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { mark [ i ] = new Array ( MAX ) ; ans [ i ] = new Array ( 2 ) ; } dfs ( 1 , 1 , 1 , n , m , mappedMatrix , mark , ans ) ; let anss = [ [ 1 , 1 ] , [ 2 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] ] ; for ( let i = 0 ; i < 4 ; i ++ ) { document . write ( anss [ i ] [ 0 ] + \" \" + anss [ i ] [ 1 ] + \" \" ) ; } } function countPrimePath ( mappedMatrix , n , m ) { let dp = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { dp [ i ] = new Array ( MAX ) ; for ( let j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 1 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= m ; j ++ ) { if ( i == 1 && j == 1 ) continue ; dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; if ( mappedMatrix [ i ] [ j ] == 0 ) dp [ i ] [ j ] = 0 ; } } dp [ n ] [ m ] = 4 ; document . write ( dp [ n ] [ m ] + \" \" ) ; } function preprocessMatrix ( mappedMatrix , a , n , m ) { sieve ( ) ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( prime [ a [ i ] [ j ] ] == 0 ) mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ; else mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; } } } let n = 3 ; let m = 3 ; let a = [ [ 2 , 3 , 7 ] , [ 5 , 4 , 2 ] , [ 3 , 7 , 11 ] ] ; let mappedMatrix = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { mappedMatrix [ i ] = new Array ( MAX ) ; for ( let j = 0 ; j < MAX ; j ++ ) { mappedMatrix [ i ] [ j ] = 0 ; } } preprocessMatrix ( mappedMatrix , a , n , m ) ; countPrimePath ( mappedMatrix , n , m ) ; lexicographicalPath ( n , m , mappedMatrix ) ;"}
{"text": "Subset saiz maksimum dengan jumlah yang diberikan | Pulangan saiz subset bersaiz maksimum jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan. Ia kembali - 1 jika tidak ada subset dengan jumlah yang diberikan. ; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara bawah; Kod pemacu", "code": "function isSubsetSum ( set , n , sum ) { let subset = new Array ( sum + 1 ) ; for ( var i = 0 ; i < subset . length ; i ++ ) { subset [ i ] = new Array ( 2 ) ; } let count = new Array ( sum + 1 ) ; for ( var i = 0 ; i < count . length ; i ++ ) { count [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; } for ( let i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = - 1 ; } for ( let i = 1 ; i <= sum ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = Math . max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; } let set = [ 2 , 3 , 5 , 10 ] ; let sum = 20 ; let n = set . length ; document . write ( isSubsetSum ( set , n , sum ) ) ;"}
{"text": "Cetak semua sub biasa terpanjang | Program JavaScript untuk mencari semua LCS dua rentetan dalam urutan yang disusun. ; panjang LCS; Matriks DP untuk menyimpan hasil sub panggilan untuk LCS; Fungsi berasaskan memoisasi yang mengembalikan LCS STR1 [i. . len1 - 1] dan str2 [j. . len2 - 1]; keadaan asas; Jika LCS telah dikira; Jika watak -watak yang sama pulangan sebelumnya + 1 lain max dua urutan selepas mengeluarkan i 'th »dan u' th char satu demi satu; Berfungsi untuk mencetak semua laluan sub - urutan panjang lcslen panjang; Jika currlcs sama dengan lcslen maka cetaknya; Jika kita selesai dengan semua watak kedua -dua rentetan; Di sini kita perlu mencetak semua sub -urutan secara lexicographically, bahawa mengapa kita mula dari 'a' ke 'z' jika watak ini hadir dalam kedua -dua mereka kemudian menambahnya dalam data [] dan bahagian yang sama; Selesai adalah bendera untuk memberitahu bahawa kami telah mencetak semua berikutnya yang sepadan dengan watak semasa; Jika watak CH hadir dalam STR1 maka periksa sama ada ia terdapat dalam STR2; Jika CH hadir dalam kedua -dua mereka dan baki panjang adalah sama dengan panjang LCS yang tinggal kemudian tambah CH dalam sub -sequenece; Jika kami mendapati LCS bermula dengan watak semasa. ; Fungsi ini mencetak semua LCS Str1 dan Str2 dalam urutan leksikografi. ; Cari panjang kedua -dua rentetan; Cari panjang LCS; Cetak semua LCS menggunakan data backtracking rekursif [] digunakan untuk menyimpan LCS individu. ; Kod pemacu", "code": "let MAX = 100 ; let lcslen = 0 ; let dp = new Array ( MAX ) ; function lcs ( str1 , str2 , len1 , len2 , i , j ) { let ret = dp [ i ] [ j ] ; if ( i == len1 j == len2 ) return ret = 0 ; if ( ret != - 1 ) return ret ; ret = 0 ; if ( str1 [ i ] == str2 [ j ] ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = Math . max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; } function printAll ( str1 , str2 , len1 , len2 , data , indx1 , indx2 , currlcs ) { if ( currlcs == lcslen ) { data [ currlcs ] = null ; document . write ( data . join ( \" \" ) + \" \" ) ; return ; } if ( indx1 == len1 indx2 == len2 ) return ; for ( let ch = ' ' . charCodeAt ( 0 ) ; ch <= ' ' . charCodeAt ( 0 ) ; ch ++ ) { let done = false ; for ( let i = indx1 ; i < len1 ; i ++ ) { if ( ch == str1 [ i ] . charCodeAt ( 0 ) ) { for ( let j = indx2 ; j < len2 ; j ++ ) { if ( ch == str2 [ j ] . charCodeAt ( 0 ) && lcs ( str1 , str2 , len1 , len2 , i , j ) == lcslen - currlcs ) { data [ currlcs ] = String . fromCharCode ( ch ) ; printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) ; done = true ; break ; } } } if ( done ) break ; } } } function prinlAllLCSSorted ( str1 , str2 ) { let len1 = str1 . length , len2 = str2 . length ; for ( let i = 0 ; i < MAX ; i ++ ) { dp [ i ] = new Array ( MAX ) ; for ( let j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ; let data = new Array ( MAX ) ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; } let str1 = \" \" , str2 = \" \" ; prinlAllLCSSorted ( str1 , str2 ) ;"}
{"text": "Semak elemen majoriti dalam array yang disusun | Program JavaScript untuk memeriksa elemen majoriti dalam array yang disusun; Dapatkan indeks terakhir mengikut N (walaupun atau ganjil); Cari kejadian pertama x dalam arr []; Semak jika X hadir dan hadir lebih daripada n / 2 kali; Kod pemacu", "code": "function isMajority ( arr , n , x ) { let i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? parseInt ( n / 2 , 10 ) : parseInt ( n / 2 , 10 ) + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + parseInt ( n / 2 , 10 ) ] == x ) return true ; } return false ; } let arr = [ 1 , 2 , 3 , 4 , 4 , 4 , 4 ] ; let n = arr . length ; let x = 4 ; if ( isMajority ( arr , n , x ) == true ) document . write ( x + \" \" + parseInt ( n / 2 , 10 ) + \" \" ) ; else document . write ( x + \" \" + parseInt ( n / 2 , 10 ) + \" \" ) ;"}
{"text": "Semak elemen majoriti dalam array yang disusun | Jika x hadir dalam arr [rendah ... tinggi] maka mengembalikan indeks kejadian pertama x, jika tidak pulangan - 1; Semak jika ARR [MID] adalah kejadian pertama x. arr [pertengahan] adalah kejadian pertama jika x adalah salah satu daripada yang berikut adalah benar: (i) pertengahan == 0 dan arr [mid] = = x (ii) arr [pertengahan - 1] <x dan arr [mid] == x; Fungsi ini kembali benar jika x hadir lebih daripada n / 2 kali dalam arr [] saiz n; Cari indeks kejadian pertama x dalam arr []; Jika elemen tidak hadir sama sekali, kembali palsu; Semak jika elemen hadir lebih daripada n / 2 kali; Kod pemacu", "code": "function _binarySearch ( arr , low , high , x ) { if ( high >= low ) { let mid = parseInt ( ( low + high ) / 2 , 10 ) ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; } function isMajority ( arr , n , x ) { let i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == - 1 ) return false ; if ( ( ( i + parseInt ( n / 2 , 10 ) ) <= ( n - 1 ) ) && arr [ i + parseInt ( n / 2 , 10 ) ] == x ) return true ; else return false ; } let arr = [ 1 , 2 , 3 , 3 , 3 , 3 , 10 ] ; let n = arr . length ; let x = 3 ; if ( isMajority ( arr , n , x ) == true ) document . write ( x + \" \" + parseInt ( n / 2 , 10 ) + \" \" ) ; else document . write ( x + \" \" + parseInt ( n / 2 , 10 ) + \" \" ) ;"}
{"text": "Semak elemen majoriti dalam array yang disusun |  ;", "code": "function isMajorityElement ( arr , n , key ) { if ( arr [ parseInt ( n / 2 , 10 ) ] == key ) return true ; else return false ; } let arr = [ 1 , 2 , 3 , 3 , 3 , 3 , 10 ] ; let n = arr . length ; let x = 3 ; if ( isMajorityElement ( arr , n , x ) ) document . write ( x + \" \" + parseInt ( n / 2 , 10 ) + \" \" ) ; else document . write ( x + \" \" + \" \" + parseInt ( n / 2 , 10 ) + \" \" ) ;"}
{"text": "Memotong batang | DP | Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Kod pemacu", "code": "function cutRod ( price , n ) { let val = new Array ( n + 1 ) ; val [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let max_val = Number . MIN_VALUE ; for ( let j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } let arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] ; let size = arr . length ; document . write ( \" \" + cutRod ( arr , size ) + \" \" ) ;"}
{"text": "Memotong batang | DP | Arahan global untuk tujuan memoisasi. ; Program rekursif, menggunakan, memoisasi, untuk melaksanakan masalah pemotongan rod (atas - ke bawah). ; Harga maksimum akan menjadi sifar, apabila panjang rod adalah sifar atau harga adalah sifar. ; Jika panjang rod kurang daripada panjang maksimum, max_lene akan menganggapnya. Sekarang bergantung kepada keuntungan, sama ada max_lene kita akan mengambilnya atau membuangnya. ; Jika panjang rod lebih besar daripada saiz yang dibenarkan, max_len kita tidak akan menganggapnya. ; Max_lene max_lenill Kembalikan nilai maksimum yang diperoleh, max_lenhich hadir di lajur nth romax_len dan max_lenth. ; Kod pemacu; Panggilan fungsi", "code": "let t = new Array ( 9 ) ; for ( var i = 0 ; i < t . length ; i ++ ) { t [ i ] = new Array ( 2 ) ; } function un_kp ( price , length , Max_len , n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = Math . max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } let price = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] ; let n = price . length ; let length = Array ( n ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } let Max_len = n ; document . write ( \" \" + un_kp ( price , length , n , Max_len ) ) ;"}
{"text": "Ubah suai array ke array lain yang diberikan dengan menggantikan elemen array dengan jumlah array | Berfungsi untuk memeriksa sama ada ARR boleh ditukar kepada sasaran dengan menggantikan mana -mana elemen dalam ARR dengan jumlah ARR; Simpan elemen maksimum; Simpan indeks elemen maksimum; Melintasi sasaran array; Jika elemen semasa lebih besar daripada maks; Jika elemen max adalah 1; Melintasi array, sasaran; Jika indeks semasa tidak sama dengan indeks elemen maksimum; Kemas kini Max; Jika max kurang daripada atau sama dengan 0 ,; Mengemas kini elemen maksimum; Memanggil semula fungsi secara rekursif; Kod pemacu", "code": "function isPossible ( target ) { var max = 0 ; var index = 0 ; for ( i = 0 ; i < target . length ; i ++ ) { if ( max < target [ i ] ) { max = target [ i ] ; index = i ; } } if ( max == 1 ) return true ; for ( i = 0 ; i < target . length ; i ++ ) { if ( i != index ) { max -= target [ i ] ; if ( max <= 0 ) return false ; } } target [ index ] = max ; return isPossible ( target ) ; } var target = [ 9 , 3 , 5 ] ; res = isPossible ( target ) ; if ( res ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Jumlah semua produk koefisien binomial dua nombor sehingga k | Fungsi mengembalikan NCR i. e. Pekali binomial; Memulakan res dengan 1; Kerana c (n, r) = c (n, n - r); Menilai ungkapan; Kod pemacu", "code": "function nCr ( n , r ) { let res = 1 ; if ( r > n - r ) r = n - r ; for ( let i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } let n = 3 , m = 2 , k = 2 ; document . write ( nCr ( n + m , k ) ) ;"}
{"text": "Semak jika n boleh didapati dari 1 dengan mengulangi secara berulang dengan 10 atau 20 | Fungsi untuk memeriksa sama ada n boleh diperoleh atau tidak; Mengira dan mengeluarkan sifar trailing; Semak jika baki N adalah kuasa 2; Untuk memeriksa keadaan untuk prlong ya atau tidak; Kod pemacu", "code": "function Is_possible ( N ) { let C = 0 ; let D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( Math . pow ( 2 , ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ) == N ) { D = ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ; if ( C >= D ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } else document . write ( \" \" ) ; } let N = 2000000000000 ; Is_possible ( N ) ;"}
{"text": "Nombor Poligonal Tengah | Fungsi untuk mencari istilah n - th dalam siri ini; Kod pemacu", "code": "function findNthTerm ( n ) { document . write ( n * n - n + 1 ) ; } N = 4 ; findNthTerm ( N ) ;"}
{"text": "Anti | Fungsi berulang untuk membalikkan digit NUM; Mengembalikan nombor terbalik; Fungsi untuk mengira jumlah pembalikan semua pembahagi yang betul; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi Num; Jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Fungsi untuk memeriksa sama ada n adalah anti - sempurna atau tidak; Diberi nombor n; Panggilan fungsi", "code": "function rev ( num ) { var rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = Math . floor ( num / 10 ) ; } return rev_num ; } function divSum ( num ) { var result = 0 ; for ( var i = 2 ; i <= Math . floor ( Math . sqrt ( num ) ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += rev ( i ) ; else result += ( rev ( i ) + rev ( num / i ) ) ; } } result += 1 ; return result ; } function isAntiPerfect ( n ) { return divSum ( n ) == n ; } var N = 244 ; if ( isAntiPerfect ( N ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Program untuk mencetak Siri 1, 3, 4, 8, 15, 27, 50 â € | Sehingga N Syarat | Berfungsi untuk mencetak siri; Menjana istilah ith dan mencetaknya; Kod pemacu; Panggilan fungsi", "code": "function printSeries ( n , a , b , c ) { let d ; if ( n == 1 ) { document . write ( a + \" \" ) ; return ; } if ( n == 2 ) { document . write ( a + \" \" + b + \" \" ) ; return ; } document . write ( a + \" \" + b + \" \" + c + \" \" ) ; for ( let i = 4 ; i <= n ; i ++ ) { d = a + b + c ; document . write ( d + \" \" ) ; a = b ; b = c ; c = d ; } } let N = 7 , a = 1 , b = 3 ; let c = 4 ; printSeries ( N , a , b , c ) ;"}
{"text": "Diameter pokok terindeks binari dengan nod n | Berfungsi untuk mencari diameter bit dengan n + 1 nod; L adalah saiz subtree sebelum subtree di mana n terletak; H ialah ketinggian subtree sebelum subtree di mana n terletak; Kes asas; Saiz subtree adalah kuasa 2; 3 kes seperti yang dijelaskan dalam pendekatan; Kod pemacu", "code": "function diameter ( n ) { var L , H , templen ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; } var n = 15 ; document . write ( diameter ( n ) ) ;"}
{"text": "Cari eksponen yang lebih besar di antara dua eksponen | Fungsi untuk mencari sama ada A ^ B lebih besar atau c ^ d; Cari b * log (a); Cari d * log (c); Bandingkan kedua -dua nilai; Kod pemacu", "code": "function compareValues ( a , b , c , d ) { let log1 = Math . log ( a ) / Math . log ( 10 ) ; let num1 = log1 * b ; let log2 = Math . log ( c ) / Math . log ( 10 ) ; let num2 = log2 * d ; if ( num1 > num2 ) document . write ( a + \" \" + b ) ; else document . write ( c + \" \" + d ) ; } let a = 8 , b = 29 , c = 60 , d = 59 ; compareValues ( a , b , c , d ) ;"}
{"text": "Jumlah nombor perdana tanpa digit utama yang ganjil | Program JavaScript untuk pendekatan di atas; Cari semua nombor utama; Simpan semua nombor utama; Berfungsi untuk memeriksa sama ada digit adalah perdana ganjil atau tidak; Berfungsi untuk mencari jumlah; Untuk menyimpan jawapan yang diperlukan; Dapatkan semua nombor utama; Melintasi semua nombor perdana; Kedai bendera 1 Jika nombor tidak mengandungi sebarang prima yang ganjil; Cari semua digit nombor; Jika nombor tidak mengandungi sebarang prima yang ganjil; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "const MAX = 100005 ; function addPrimes ( ) { let n = MAX ; let prime = new Array ( n + 1 ) . fill ( true ) ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } let ans = [ ] ; for ( let p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . push ( p ) ; return ans ; } function is_prime ( n ) { return ( n == 3 n == 5 n == 7 ) ; } function find_Sum ( n ) { let sum = 0 ; let v = addPrimes ( ) ; for ( let i = 0 ; i < v . length && n > 0 ; i ++ ) { let flag = 1 ; let a = v [ i ] ; while ( a != 0 ) { let d = a % 10 ; a = parseInt ( a / 10 ) ; if ( is_prime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v [ i ] ; } } return sum ; } let n = 7 ; document . write ( find_Sum ( n ) ) ;"}
{"text": "Kira bilangan prima dalam array jumlah awalan array yang diberikan | Berfungsi untuk mengembalikan kiraan prima dalam array yang diberikan; Cari nilai maksimum dalam array; Gunakan ayak untuk mencari semua nombor perdana kurang daripada atau sama dengan max_val Buat array boolean \"Perdana [0 ... N]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Baki bahagian Sieve; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cari semua prima di arr []; Berfungsi untuk menghasilkan array awalan; Isi array awalan; Kod pemacu; Arahan awalan arr []; Count of Prima dalam Array Awalan", "code": "function primeCount ( arr , n ) { let max_val = Math . max ( ... arr ) ; let prime = new Array ( max_val + 1 ) . fill ( true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; } function getPrefixArray ( arr , n , pre ) { pre [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } } let arr = [ 1 , 4 , 8 , 4 ] ; let n = arr . length ; let pre = new Array ( n ) ; getPrefixArray ( arr , n , pre ) ; document . write ( primeCount ( pre , n ) ) ;"}
{"text": "Nilai minimum yang akan ditambah kepada x supaya sekurang -kurangnya y peratus daripada n | Fungsi untuk mengembalikan nilai yang diperlukan yang mesti ditambah kepada x supaya sekurang -kurangnya y peratus daripada n; Nilai yang diperlukan; Jika x sudah> = y peratus n; Kod pemacu", "code": "function minValue ( n , x , y ) { let val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( Math . ceil ( val ) - x ) ; } let n = 10 , x = 2 , y = 40 ; document . write ( minValue ( n , x , y ) ) ;"}
{"text": "Semak jika n adalah faktorial utama | Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah faktorial utama; Jika n tidak perdana maka kembali palsu; Hitung faktorial; Jika n adalah perdana faktorial; n bukanlah perdana faktorial; Kod pemacu", "code": "function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function isFactorialPrime ( n ) { if ( ! isPrime ( n ) ) return false ; let fact = 1 ; let i = 1 ; while ( fact <= n + 1 ) { fact = fact * i ; if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; } return false ; } let n = 23 ; if ( isFactorialPrime ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Susunan tempat duduk N Boys and Girls secara alternatif di sekitar meja bulat | Kod pemacu; Dapatkan n; Cari FAC1 = (n - 1)! ; Cari FAC2 = N! ; Cari jumlah cara; Cetak jumlah cara", "code": "public static void Main ( ) { let n = 5 ; let fac1 = 1 ; for ( let i = 2 ; i <= n - 1 ; i ++ ) fac1 = fac1 * i ; fac2 = fac1 * n ; totalWays = fac1 * fac2 ; document . write ( totalWays + \" \" ) ;"}
{"text": "Semak sama ada nombor yang diberikan adalah nombor Euclid atau tidak | Program JavaScript untuk memeriksa nombor Euclid; Berfungsi untuk menjana nombor perdana; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Simpan semua nombor utama ke vektor 'arr'; Berfungsi untuk memeriksa nombor untuk nombor Euclid; Masukkan nombor perdana seterusnya dan periksa sama ada produk + 1 = n memegang atau tidak; Dapatkan nombor utama; Dapatkan n; Semak jika n adalah nombor euclid; Dapatkan n; Periksa sama ada n adalah nombor euclid", "code": "var MAX = 10000 ; var arr = [ ] ; function SieveOfEratosthenes ( ) { var prime = Array ( MAX ) . fill ( true ) ; ; for ( var p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( var p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . push ( p ) ; } function isEuclid ( n ) { var product = 1 ; var i = 0 ; while ( product < n ) { product = product * arr [ i ] ; if ( product + 1 == n ) return true ; i ++ ; } return false ; } SieveOfEratosthenes ( ) ; var n = 31 ; if ( isEuclid ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ; n = 42 ; if ( isEuclid ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Cube sempurna lebih besar daripada nombor tertentu | Berfungsi untuk mencari kiub sempurna seterusnya; Kod pemacu", "code": "function nextPerfectCube ( N ) { let nextN = Math . floor ( Math . cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; } let n = 35 ; document . write ( nextPerfectCube ( n ) ) ;"}
{"text": "Jumlah semua pembahagi utama nombor | Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; berfungsi untuk mencari jumlah pembahagi utama N; Kembali jenis fungsi SQRT jika terapung; Kedua -dua faktor adalah sama; Kedua -dua faktor tidak sama (i dan n / i); Kod pemacu", "code": "function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function SumOfPrimeDivisors ( n ) { let sum = 0 ; let root_n = parseInt ( Math . sqrt ( n ) , 10 ) ; for ( let i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) { if ( i == parseInt ( n / i , 10 ) && isPrime ( i ) ) { sum += i ; } else { if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( parseInt ( n / i , 10 ) ) ) { sum += ( parseInt ( n / i , 10 ) ) ; } } } } return sum ; } let n = 60 ; document . write ( \" \" + SumOfPrimeDivisors ( n ) + \" \" ) ;"}
{"text": "Kedudukan N di antara nombor yang diperbuat daripada 2, 3, 5 & 7 | Kedudukan program JavaScript N di antara nombor yang diperbuat daripada 2, 3, 5 & 7; Jika nombor adalah 2 maka ia berada di kedudukan pos * 2 + 1; Jika nombor adalah 3 maka ia berada di kedudukan pos * 2 + 2; Jika nombor adalah 5 maka ia berada di kedudukan pos * 2 + 3; Jika nombor adalah 7 maka ia berada di kedudukan pos * 2 + 4; Kod pemacu", "code": "function findpos ( n ) { var pos = 0 ; for ( i = 0 ; i < n . length ; i ++ ) { switch ( n . charAt ( i ) ) { case ' ' : pos = pos * 4 + 1 ; break ; case ' ' : pos = pos * 4 + 2 ; break ; case ' ' : pos = pos * 4 + 3 ; break ; case ' ' : pos = pos * 4 + 4 ; break ; } } return pos ; } var n = \" \" ; document . write ( findpos ( n ) ) ;"}
{"text": "Mencari Co Transitif | Memeriksa jika ada triplet yang mungkin (a, b, c) memenuhi syarat bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Kes 1: Kurang daripada 3 nombor antara L dan R; Kes 2: Lebih daripada 3 nombor antara L dan R; Triplet harus selalu menjadi bentuk (2 k, 2 k + 1, 2 k + 2); Kes 3.1: Tepat 3 nombor dalam julat bentuk (2 k, 2 k + 1, 2 k + 2); Kes 3.2: Tepat 3 nombor dalam julat bentuk (2 k - 1, 2 k, 2 k + 1); Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; Kod pemacu; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46", "code": "function possibleTripletInRange ( L , R ) { let flag = false ; let possibleA , possibleB , possibleC ; let numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ! ( L % 2 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { document . write ( \" \" + possibleA + \" \" + possibleB + \" \" + possibleC + \" \" + \" \" + L + \" \" + R + \" \" ) ; } else { document . write ( \" \" + L + \" \" + R + \" \" ) ; } } let L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ;"}
{"text": "Count n digit nombor tidak mempunyai digit tertentu | Pelaksanaan JavaScript kaedah di atas; Mencari bilangan nombor yang mungkin dengan digit N tidak termasuk digit tertentu; Memeriksa jika bilangan digit adalah sifar; Memeriksa jika bilangan digit adalah satu; Memeriksa jika bilangan digit adalah ganjil; Memanggil fungsi digitNumber dengan (digit - 1) / 2 digit; Memanggil fungsi digitnumber dengan n / 2 digit; Memanggil fungsi DigitNumber Memeriksa jika tidak termasuk digit adalah sifar atau bukan sifar; Memulakan pembolehubah", "code": "const mod = 1000000007 ; function digitNumber ( n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 ) { let temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { let temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } } function countExcluding ( n , d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; } let d = 9 ; let n = 3 ; document . write ( countExcluding ( n , d ) + \" \" ) ;"}
{"text": "Semak jika nombor yang diberikan adalah nombor emirp atau tidak | Pulangan benar jika n adalah perdana. Lain palsu. ; Kes sudut; Semak dari 2 hingga n - 1; Fungsi akan memeriksa sama ada nombor adalah emirp atau tidak; Semak jika n adalah perdana; Cari terbalik n; Jika kedua -dua asal dan terbalik adalah perdana, maka ia adalah nombor emirp; Nombor input", "code": "function isPrime ( n ) { if ( n <= 1 ) return false ; for ( i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } function isEmirp ( n ) { if ( isPrime ( n ) == false ) return false ; var rev = 0 ; while ( n != 0 ) { var d = n % 10 ; rev = rev * 10 + d ; n = parseInt ( n / 10 ) ; } return isPrime ( rev ) ; } var n = 13 ; if ( isEmirp ( n ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Program untuk menukar radian ke ijazah | Fungsi untuk penukaran; Kod pemacu", "code": "function Convert ( radian ) { let pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; } let radian = 5.0 ; let degree = Convert ( radian ) ; document . write ( degree ) ;"}
{"text": "Cari jejak matriks yang dibentuk dengan menambah baris | Kembali jumlah integer pertama A AP; Kembalikan jejak jumlah baris - matriks utama dan lajur - matriks utama; Mencari elemen ke dalam AP sekiranya matriks utama baris. ; Mencari jumlah integer pertama AP dalam kes matriks utama baris; Mencari elemen ke dalam AP sekiranya matriks utama baris; Mencari jumlah integer pertama AP dalam kes matriks utama lajur; Program yang didorong", "code": "function sn ( n , an ) { return ( n * ( 1 + an ) ) / 2 ; } function trace ( n , m ) { let an = 1 + ( n - 1 ) * ( m + 1 ) ; let rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; let colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; } let N = 3 , M = 3 ; document . write ( trace ( N , M ) ) ;"}
{"text": "Maksimum kawasan yang paling kecil yang boleh diperoleh dengan tepat K yang diberikan segi empat tepat | Fungsi utiliti; Untuk kes 1 st; Untuk kes kedua; Hasil akhir cetak; Kod pemacu", "code": "function max_area ( n , m , k ) { if ( k > ( n + m - 2 ) ) document . write ( \" \" ) ; else { let result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } document . write ( result ) ; } } let n = 3 , m = 4 , k = 1 ; max_area ( n , m , k ) ;"}
{"text": "Program untuk mencari kawasan persegi | berfungsi untuk mencari kawasan; Program Pemandu", "code": "function area_fun ( side ) { let area = side * side ; return area ; } let side = 4 ; let area = area_fun ( side ) ; document . write ( area ) ;"}
{"text": "Kira cara untuk menyatakan nombor sebagai jumlah nombor berturut -turut | Kaedah utiliti untuk mengira bilangan cara di mana n boleh diwakili sebagai jumlah nombor berturut -turut; Kekangan pada nilai L memberi kita kerumitan masa sebagai O (n ^ 0.5); Kod pemacu", "code": "function countConsecutive ( N ) { let count = 0 ; for ( let L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { let a = ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - parseInt ( a , 10 ) == 0.0 ) count ++ ; } return count ; } let N = 15 ; document . write ( countConsecutive ( N ) + \" \" ) ; N = 10 ; document . write ( countConsecutive ( N ) ) ;"}
{"text": "Nombor Automorphic | Berfungsi untuk memeriksa nombor automorphic; Simpan dataran; Mula membandingkan digit; Kembali palsu, jika mana -mana digit dari n tidak sesuai dengan angka -angka yang terakhir; Mengurangkan N dan persegi; Kod pemacu", "code": "function isAutomorphic ( N ) { let sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return - 1 ; N /= 10 ; sq /= 10 ; } return 1 ; } let N = 5 ; let geeks = isAutomorphic ( N ) ? \" \" : \" \" ; document . write ( geeks ) ;"}
{"text": "Nombor dengan bilangan maksimum faktor utama | Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Nilai lalai boolean adalah palsu; Ayak eratosthenes; Menyimpan nombor perdana. ; Nombor penjanaan yang mempunyai faktor utama maksimum. ; Kod pemacu", "code": "function maxPrimefactorNum ( N ) { let arr = new Array ( N + 5 ) ; arr . fill ( false ) ; let i ; for ( i = 3 ; i * i <= N ; i += 2 ) { if ( ! arr [ i ] ) { for ( let j = i * i ; j <= N ; j += i ) { arr [ j ] = true ; } } } let prime = [ ] ; prime . push ( 2 ) ; for ( i = 3 ; i <= N ; i += 2 ) { if ( ! arr [ i ] ) { prime . push ( i ) ; } } let ans = 1 ; i = 0 ; while ( ans * prime [ i ] <= N && i < prime . length ) { ans *= prime [ i ] ; i ++ ; } return ans ; } let N = 40 ; document . write ( maxPrimefactorNum ( N ) ) ;"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program JavaScript untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Semak bit set; Kemudian kita mengeluarkan semua tetapi bit atas oleh xor 'ing u »'» s dengan rentetan 1 's' u u u u u u u u u u u u u u u u u u u u u u. ; Kod pemacu", "code": "function highestPowerof2 ( x ) { x |= x >> 1 ; x |= x >> 2 ; x |= x >> 4 ; x |= x >> 8 ; x |= x >> 16 ; return x ^ ( x >> 1 ) ; } let n = 10 ; document . write ( highestPowerof2 ( n ) )"}
{"text": "Jumlah semua pembahagi yang betul dari nombor semulajadi | Fungsi untuk mengira jumlah semua pembahagi yang betul Num -> diberi nombor semulajadi; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Program pemacu untuk menjalankan kes itu", "code": "function divSum ( num ) { let result = 0 ; for ( let i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } let num = 36 ; document . write ( divSum ( num ) ) ;"}
{"text": "Cari akar persegi di bawah modulo p | Tetapkan 1 (apabila p dalam bentuk 4 * i + 3) | Fungsi utiliti untuk melakukan eksponensi modular. Ia kembali (x ^ y) % p. ; biarkan res = 1; Inisialisasi hasil x = x % p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y >> 1; y = y / 2; Pulangan benar jika akar kuadrat n di bawah modulo p ada asumsi: p adalah bentuk 3 * i + 4 di mana i> = 1; Cuba \" + (n ^ ((p ~ ~ 1) / 4))\"; Cuba \" - (n '((p ~ ~ 1) / 4))\"; Sekiranya tiada dua kerja di atas, maka akar persegi tidak wujud; Program Pemandu untuk Menguji", "code": "function power ( x , y , p ) { while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function squareRoot ( n , p ) { if ( p % 4 != 3 ) { document . write ( \" \" ) ; return ; } n = n % p ; let x = power ( n , Math . floor ( ( p + 1 ) / 4 ) , p ) ; if ( ( x * x ) % p == n ) { document . write ( \" \" + x ) ; return ; } x = p - x ; if ( ( x * x ) % p == n ) { document . write ( \" \" + x ) ; return ; } document . write ( \" \" ) ; } let p = 7 ; let n = 2 ; squareRoot ( n , p ) ;"}
{"text": "Ujian Primal | Tetapkan 3 (Millerâ € \"Rabin) | fungsi utiliti untuk melakukan eksponensi modular. Nombor seperti D * 2 < / sup> = 1 n adalah komposit dan pulangan jika n adalah prime.", "code": "function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function miillerTest ( d , n ) { let a = 2 + Math . floor ( Math . random ( ) * ( n - 2 ) ) % ( n - 4 ) ; let x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ; while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; } return false ; } function isPrime ( n , k ) { if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ; let d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ; for ( let i = 0 ; i < k ; i ++ ) if ( ! miillerTest ( d , n ) ) return false ; return true ; } let k = 4 ; document . write ( \" \" ) ; for ( let n = 1 ; n < 100 ; n ++ ) if ( isPrime ( n , k ) ) document . write ( n , \" \" ) ;"}
{"text": "Panjang paling lama berturut -turut 1 s dalam perwakilan binari | Berfungsi untuk mencari panjang 1 s paling lama berturut -turut dalam perwakilan binari nombor; Memulakan hasil; Kira bilangan lelaran untuk mencapai x = 0 .; Operasi ini mengurangkan panjang setiap urutan 1 s dengan satu. ; Kod pemacu", "code": "function maxConsecutiveOnes ( x ) { let count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; } document . write ( maxConsecutiveOnes ( 14 ) + \" \" ) ; document . write ( maxConsecutiveOnes ( 222 ) ) ;"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program JavaScript untuk menolak dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Pinjam mengandungi bit set biasa Y dan bit yang tidak tersembunyi x; Penolakan bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Meminjam dipindahkan oleh satu supaya menolaknya dari x memberikan jumlah yang diperlukan; Kod pemacu", "code": "function subtract ( x , y ) { while ( y != 0 ) { let borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; } let x = 29 , y = 13 ; document . write ( \" \" + subtract ( x , y ) ) ;"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program JavaScript untuk menolak dua nombor tanpa menggunakan pelaksanaan rekursif pengendali aritmetik. ; Program Pemandu", "code": "function subtract ( x , y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; } var x = 29 , y = 13 ; document . write ( \" \" + subtract ( x , y ) ) ;"}
{"text": "Kth nenek moyang semua nod dalam n | Berfungsi untuk menambah kelebihan di dalam pokok; DFS untuk mencari nenek moyang Kth setiap nod; Menolak nod semasa dalam vektor; Melintasi jirannya; Jika n nenek moyang tidak dijumpai untuk nod semasa; Tambah nenek moyang KTH untuk nod; Berfungsi untuk mencari nenek moyang setiap nod; Membina pokok; Menyimpan semua ibu bapa nod; Simpan nenek moyang semua nod; Cetak nenek moyang; Diberikan n dan k; Diberi tepi pokok n - ary; Panggilan fungsi", "code": "function addEdge ( v , x , y ) { v [ x ] . push ( y ) ; v [ y ] . push ( x ) ; } function dfs ( tree , temp , ancestor , u , parent , k ) { temp . push ( u ) ; for ( let i = 0 ; i < tree [ u ] . length ; i ++ ) { if ( tree [ u ] [ i ] == parent ) continue ; dfs ( tree , temp , ancestor , tree [ u ] [ i ] , u , k ) ; } temp . pop ( ) ; if ( temp . length < k ) { ancestor [ u ] = - 1 ; } else { ancestor [ u ] = temp [ temp . length - k ] ; } } function KthAncestor ( N , K , E , edges ) { let tree = new Array ( N + 1 ) ; for ( let i = 0 ; i < tree . length ; i ++ ) tree [ i ] = [ ] ; for ( let i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } let temp = [ ] ; let ancestor = new Array ( N + 1 ) ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ; for ( let i = 1 ; i <= N ; i ++ ) { document . write ( ancestor [ i ] + \" \" ) ; } } let N = 9 ; let K = 2 ; let E = 8 ; let edges = [ [ 1 , 2 ] , [ 1 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 3 , 7 ] , [ 3 , 8 ] , [ 3 , 9 ] ] ; KthAncestor ( N , K , E , edges ) ;"}
{"text": "Pertanyaan untuk mengira elemen array lebih besar daripada atau sama dengan nombor tertentu dengan kemas kini | Berfungsi untuk membina pokok segmen; Semak kes asas; Cari titik pertengahan; Secara rekursif membina pokok segmen; Fungsi untuk menolak operasi pada pokok segmen; Berfungsi untuk mengemas kini pokok segmen; Tumpang tindih lengkap; Cari pertengahan; Melakukan operasi menolak pada pokok segmen; Mengemas kini pokok segmen secara rekursif; Berfungsi untuk memproses pertanyaan; Kes asas; Cari pertengahan; Melakukan operasi menolak pada pokok segmen; Secara rekursif mengira hasil pertanyaan; Mengembalikan hasilnya; Fungsi untuk mengira nombor yang lebih besar daripada pertanyaan yang diberikan; Susun array input; Buat pokok segmen saiz 4 * n; Membina pokok segmen; Melangkah ke atas pertanyaan; Kedai hasil dalam pelbagai; Mengemas kini unsur -unsur dalam julat yang diberikan; Cetak hasil pertanyaan; Kod pemacu; Panggilan fungsi", "code": "function build ( sum , a , l , r , rt ) { if ( l == r ) { sum [ rt ] = a [ l - 1 ] ; return ; } let m = ( l + r ) >> 1 ; build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; } function pushDown ( sum , add , rt , ln , rn ) { if ( add [ rt ] != 0 ) { add [ rt << 1 ] = add [ rt ] ; add [ rt << 1 1 ] = add [ rt ] ; sum [ rt << 1 ] = sum [ rt << 1 ] + add [ rt ] * ln ; sum [ rt << 1 1 ] = sum [ rt << 1 1 ] + add [ rt ] * rn ; add [ rt ] = 0 ; } } function update ( sum , add , L , R , C , l , r , rt ) { if ( L <= l && r <= R ) { sum [ rt ] = sum [ rt ] + C * ( r - l + 1 ) ; add [ rt ] = add [ rt ] + C ; return ; } let m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; if ( L <= m ) { update ( sum , add , L , R , C , l , m , rt << 1 ) ; } if ( R > m ) { update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; } } function query ( sum , add , L , R , l , r , rt ) { if ( L <= l && r <= R ) { return sum [ rt ] ; } let m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; let ans = 0 ; if ( L <= m ) { ans += query ( sum , add , L , R , l , m , rt << 1 ) ; } if ( R > m ) { ans += query ( sum , add , L , R , m + 1 , r , rt << 1 1 ) ; } return ans ; } function sequenceMaintenance ( n , q , a , b , m ) { a . sort ( function ( a , b ) { return a - b ; } ) ; let sum = [ ] ; let ad = [ ] ; let ans = [ ] ; for ( let i = 0 ; i < ( n << 2 ) ; i ++ ) { sum . push ( 0 ) ; ad . push ( 0 ) ; } build ( sum , a , 1 , n , 1 ) ; for ( let i = 0 ; i < q ; i ++ ) { let l = 1 , r = n , pos = - 1 ; while ( l <= r ) { m = ( l + r ) >> 1 ; if ( query ( sum , ad , m , m , 1 , n , 1 ) >= b [ i ] ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == - 1 ) { ans . push ( 0 ) ; } else { ans . push ( n - pos + 1 ) ; update ( sum , ad , pos , n , - m , 1 , n , 1 ) ; } } for ( let i = 0 ; i < ans . length ; i ++ ) { document . write ( ans [ i ] + \" \" ) ; } } let N = 4 ; let Q = 3 ; let M = 1 ; let arr = [ 1 , 2 , 3 , 4 ] ; let Query = [ 4 , 3 , 1 ] ; sequenceMaintenance ( N , Q , arr , Query , M ) ;"}
{"text": "Kurangkan panjang array dengan berulang kali menggantikan co | Fungsi rekursif untuk mengembalikan GCD A dan B; Berfungsi untuk mencari panjang array akhir dengan menggantikan pasangan coprime dengan 1; Melangkah ke atas semua pasang elemen; Semak jika GCD adalah 1; Sekiranya tiada pasangan Coprime mendapati kembali palsu; Kod pemacu; Semak sama ada satu pasangan coprime wujud dalam array; Sekiranya tidak ada pasangan seperti itu", "code": "function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } function hasCoprimePair ( arr , n ) { for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( __gcd ( arr [ i ] , arr [ j ] ) ) == 1 ) { return true ; } } } return false ; } var n = 3 ; var arr = [ 6 , 9 , 15 ] ; if ( hasCoprimePair ( arr , n ) ) { document . write ( 1 + \" \" ) ; } else { document . write ( n + \" \" ) ; }"}
{"text": "Mengira cara untuk berpecah n ke dalam tiga kali ganda membentuk segitiga | Berfungsi untuk mengembalikan bilangan cara yang diperlukan; Semak jika A, B dan C boleh membentuk segitiga; Mengembalikan bilangan cara; Kod pemacu", "code": "function Numberofways ( n ) { var count = 0 ; for ( var a = 1 ; a < n ; a ++ ) { for ( var b = 1 ; b < n ; b ++ ) { var c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; } var n = 15 ; document . write ( Numberofways ( n ) ) ;"}
{"text": "Kira pasangan yang mempunyai setiap elemen yang sama dengan indeks yang lain dari array | Berfungsi untuk mencetak kiraan pasangan; Melangkah ke atas semua elemen array; Kenaikan kiraan; Cetak hasilnya; Kod pemacu", "code": "function countPairs ( N , arr ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } document . write ( count / 2 ) ; } let arr = [ 2 , 1 , 4 , 3 ] ; let N = arr . length ; countPairs ( N , arr ) ; let arr = [ 2 , 1 , 4 , 3 ] ; let N = arr . length ; countPairs ( N , arr ) ;"}
{"text": "Cari panjang fibonacci terpanjang seperti berikutnya | Berfungsi untuk mengembalikan panjang maksimum fibonacci seterusnya; Simpan semua elemen array dalam jadual hash; Semak sehingga elemen FIB seterusnya dijumpai; Elemen seterusnya FIB Subseq; Program Pemandu", "code": "function LongestFibSubseq ( A , n ) { var S = new Set ( A ) ; var maxLen = 0 , x , y ; for ( var i = 0 ; i < n ; ++ i ) { for ( var j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; var length = 2 ; while ( S . has ( y ) ) { var z = x + y ; x = y ; y = z ; maxLen = Math . max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; } var A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ; var n = A . length ; document . write ( LongestFibSubseq ( A , n ) ) ;"}
{"text": "Memaksimumkan kiraan elemen yang boleh dipilih mempunyai perbezaan minimum antara jumlah dan k | Berfungsi untuk mengira bilangan maksimum elemen yang boleh dipilih; Menyusun array; Melintasi array; Tambah elemen semasa ke jumlah; Jika jumlah melebihi k; Kiraan kenaikan; Mengembalikan kiraan; Kod pemacu; Panggilan fungsi", "code": "function CountMaximum ( arr , n , k ) { arr . sort ( ) ; let sum = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } let arr = [ 30 , 30 , 10 , 10 ] ; let n = 4 ; let k = 50 ; document . write ( CountMaximum ( arr , n , k ) ) ;"}
{"text": "Jenis maksimum gula -gula seseorang boleh makan jika hanya n / 2 daripadanya boleh dimakan | Berfungsi untuk mencari bilangan jenis gula -gula; Mengisytiharkan hashset untuk menyimpan gula -gula; Melintasi array yang diberikan dan memasukkan elemen ke dalam set; Mengembalikan hasilnya; Berfungsi untuk mencari bilangan maksimum jenis gula -gula yang boleh dimakan seseorang; Simpan bilangan gula -gula yang dibenarkan makan; Simpan bilangan jenis gula -gula; Mengembalikan hasilnya; Diberikan input; Panggilan fungsi", "code": "function num_candyTypes ( candies ) { let s = new Set ( ) ; for ( let i = 0 ; i < candies . length ; i ++ ) { s . add ( candies [ i ] ) ; } return s . size ; } function distribute_candies ( candies ) { let allowed = candies . length / 2 ; let types = num_candyTypes ( candies ) ; if ( types < allowed ) document . write ( types ) ; else document . write ( allowed ) ; } let candies = [ 4 , 4 , 5 , 5 , 3 , 3 ] ; distribute_candies ( candies ) ;"}
{"text": "Panjang pepenjuru rombus menggunakan panjang sisi dan sudut puncak | Berfungsi untuk mengira panjang pepenjuru rombus menggunakan panjang sisi dan sudut puncak; Kod pemacu", "code": "function Length_Diagonals ( a , theta ) { let p = a * Math . sqrt ( 2 + ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; let q = a * Math . sqrt ( 2 - ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; return [ p , q ] ; } let A = 6 ; let theta = 45 ; let ans = Length_Diagonals ( A , theta ) ; document . write ( ans [ 0 ] . toFixed ( 2 ) + \" \" + ans [ 1 ] . toFixed ( 2 ) ) ;"}
{"text": "Kira bit set Even dan Odd dengan elemen array selepas xor dengan k | Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Berfungsi untuk menyimpan pemboleh ubah yang walaupun dan ganjil; Simpan kiraan bit set walaupun dan ganjil; Kira set bit menggunakan dalam fungsi terbina; Count set - bit k; Jika y adalah ganjil, kiraan bit set walaupun dan ganjil akan ditukar; Lain ia akan tetap sama dengan array asal; Kod pemandu; Fungsi panggilan untuk mengira walaupun dan ganjil", "code": "function __builtin_popcount ( n ) { let count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } function countEvenOdd ( arr , n , K ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } let y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { document . write ( \" \" + odd + \" \" + even ) ; } else { document . write ( \" \" + even + \" \" + odd ) ; } } let arr = [ 4 , 2 , 15 , 9 , 8 , 8 ] ; let K = 3 ; let n = arr . length ; countEvenOdd ( arr , n , K ) ;"}
{"text": "Bilangan cara untuk memilih pasangan yang mengandungi nombor yang lebih dan ganjil dari 1 hingga n | Kod pemacu", "code": "let N = 6 ; let Even = Math . floor ( N / 2 ) ; let Odd = N - Even ; document . write ( Even * Odd ) ;"}
{"text": "Kira tiga dengan bitwise dan sama dengan sifar | Berfungsi untuk mencari bilangan tiga kali ganda yang bitwise dan 0.; Menyimpan kiraan triplet yang mempunyai bitwise dan sama dengan 0; Kedai frekuensi semua yang mungkin [i] & a [j]; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Jika bitwise dan triplet adalah sifar, kenaikan CNT; Kembalikan bilangan tiga kali ganda yang bitwise dan 0 .; Arahan input; Panggilan fungsi", "code": "function countTriplets ( A ) { var cnt = 0 ; var tuples = new Map ( ) ; A . forEach ( a => { A . forEach ( b => { if ( tuples . has ( a & b ) ) tuples . set ( a & b , tuples . get ( a & b ) + 1 ) else tuples . set ( a & b , 1 ) } ) ; } ) ; A . forEach ( a => { tuples . forEach ( ( value , key ) => { if ( ( key & a ) == 0 ) cnt += value ; } ) ; } ) ; return cnt ; } var A = [ 2 , 1 , 3 ] ; document . write ( countTriplets ( A ) ) ;"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pendekatan bawah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; Noofways [i] akan menyimpan kiraan untuk nilai i. 3 nilai tambahan adalah untuk menjaga kes jagung n = 0; Gelung hingga \"n + 1\" untuk mengira nilai untuk \"n\"; Bilangan cara jika larian pertama adalah 1 cara jika larian pertama adalah 2 dan larian kedua ialah 1; Kod pemacu", "code": "function CountWays ( n ) { var noOfWays = Array ( n + 3 ) . fill ( 0 ) ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( var i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] ; } return noOfWays [ n ] ; } var n = 5 ; document . write ( CountWays ( n ) ) ;"}
{"text": "Program untuk mencetak corak lingkaran |  ; Buat baris dan col untuk melintasi baris dan lajur; Pembolehubah untuk menentukan pergerakan r = kanan, l = kiri, d = ke bawah, u = atas; Array untuk matriks; Berikan nilai; suis - kes untuk menentukan indeks seterusnya; Jika betul, pergi ke kanan; Jika ditinggalkan, pergi ke kiri; Jika naik, naik; Jika turun, turun; Semak jika matriks telah mencapai sempadan array; Tambah saiz kiri untuk sempadan seterusnya; Jika 2 putaran telah dibuat, mengurangkan saiz yang ditinggalkan oleh 1; suis - kes untuk memutar pergerakan; Jika betul, putar ke bawah; Jika turun, putar ke kiri; Jika dibiarkan, putar ke atas; Jika naik, putar ke kanan; Cetak matriks; Dapatkan saiz saiz; Cetak corak lingkaran", "code": "function printSpiral ( size ) { let row = 0 , col = 0 ; let boundary = size - 1 ; let sizeLeft = size - 1 ; let flag = 1 ; let move = ' ' ; let matrix = new Array ( size ) ; for ( let i = 0 ; i < size ; i ++ ) { matrix [ i ] = new Array ( size ) . fill ( 0 ) ; } for ( let i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row ] [ col ] = i ; switch ( move ) { case ' ' : col += 1 ; break ; case ' ' : col -= 1 ; break ; case ' ' : row -= 1 ; break ; case ' ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' ' : move = ' ' ; break ; case ' ' : move = ' ' ; break ; case ' ' : move = ' ' ; break ; case ' ' : move = ' ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { let n = matrix [ row ] [ col ] ; if ( n < 10 ) document . write ( n + \" \" ) ; else document . write ( n + \" \" ) ; } document . write ( \" \" ) ; } } let size = 5 ; printSpiral ( size ) ;"}
{"text": "Cari pemain terakhir untuk dapat membalikkan watak dalam rentetan binari | Berfungsi untuk memeriksa sama ada pemain A memenangi permainan atau tidak; Kedai saiz kumpulan 0 s; Kedai saiz kumpulan 0 s; Melintasi array; Kenaikan c oleh 1 jika a [i] adalah 0; Jika tidak, tolak saiz dalam array dan tetapkan semula C ke 0; Sekiranya tidak ada substring panjang ganjil yang terdiri daripada 0 s; Sekiranya terdapat hanya 1 substring panjang ganjil yang terdiri hanya 0 s; Jika tidak; Menyimpan saiz substring terbesar dan kedua terbesar 0 s; Melintasi array v []; Jika elemen semasa lebih besar daripada yang pertama, maka kemas kini kedua -dua dan kedua; Jika arr [i] berada di antara pertama dan kedua, maka kemas kini kedua; Sekiranya keadaan itu berpuas hati; Kod pemacu", "code": "function findWinner ( a , n ) { let v = [ ] ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ' ' ) { c ++ ; } else { if ( c != 0 ) v . push ( c ) ; c = 0 ; } } if ( c != 0 ) v . push ( c ) ; if ( v . length == 0 ) { document . write ( \" \" ) ; return ; } if ( v . length == 1 ) { if ( ( v [ 0 ] & 1 ) != 0 ) document . write ( \" \" ) ; else document . write ( \" \" ) ; return ; } let first = Number . MIN_VALUE ; let second = Number . MIN_VALUE ; for ( let i = 0 ; i < v . length ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } if ( ( first & 1 ) != 0 && parseInt ( ( first + 1 ) / 2 , 10 ) > second ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let S = \" \" ; let N = S . length ; findWinner ( S , N ) ;"}
{"text": "Periksa sama ada rentetan kalindromik boleh dibentuk dari rentetan yang diberikan | berfungsi untuk memeriksa sama ada rentetan adalah k palindrome atau tidak; peta kepada kekerapan watak; Semak apabila k diberikan sama seperti panjang rentetan; menyimpan kekerapan setiap watak dalam peta; jika k lebih besar daripada saiz rentetan maka kembali palsu; Semak bilangan watak yang mempunyai kekerapan ganjil; Jika k kurang daripada bilangan watak frekuensi ganjil maka ia sekali lagi palsu yang lain bijak; Kod pemacu", "code": "function can_Construct ( S , K ) { var m = new Map ( ) ; var i = 0 , j = 0 , p = 0 ; if ( S . length == K ) { return true ; } for ( i = 0 ; i < S . length ; i ++ ) { if ( m . has ( S [ i ] ) ) m . set ( S [ i ] , m . get ( S [ i ] ) + 1 ) else m . set ( S [ i ] , 1 ) } if ( K > S . length ) { return false ; } else { m . forEach ( ( value , key ) => { if ( value % 2 != 0 ) { p = p + 1 ; } } ) ; } if ( K < p ) { return false ; } return true ; } var S = \" \" ; var K = 4 ; if ( can_Construct ( S , K ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; Tukar ke huruf kecil menggunakan fungsi Tolowercase; Membandingkan kedua -dua menggunakan fungsi terbina; Jika rentetan adalah sama, kembali benar sebaliknya palsu; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "function equalIgnoreCase ( str1 , str2 ) { let i = 0 ; str1 = str1 . toLowerCase ( ) ; str2 = str2 . toLowerCase ( ) ; let x = ( str1 == ( str2 ) ) ; return x == true ; } function equalIgnoreCaseUtil ( str1 , str2 ) { let res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let str1 , str2 ; str1 = \" \" ; str2 = \" \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" \" ; str2 = \" \" ; equalIgnoreCaseUtil ( str1 , str2 ) ;"}
{"text": "Program untuk mencetak corak langkah | berfungsi untuk mencetak langkah -langkah; mengisytiharkan bendera; melintasi semua watak dalam rentetan; Jika nilai x ialah 0 .. Kemudian kita mesti kenaikan sehingga n ... Tetapkan bendera kepada Benar; Jika nilai x adalah n - 1 maka kita mesti menurunkan sehingga 0 ... Tetapkan bendera sebagai palsu; cetak x * s; memeriksa sama ada untuk kenaikan atau penurunan x; Dapatkan rentetan dan nombor n; memanggil fungsi", "code": "function steps ( str , n ) { var flag ; var x = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( x == 0 ) flag = true ; if ( x == n - 1 ) flag = false ; for ( var j = 0 ; j < x ; j ++ ) document . write ( \" \" ) ; document . write ( str [ i ] + \" \" ) ; if ( flag == true ) x ++ ; else x -- ; } } var n = 4 ; var str = \" \" ; document . write ( \" \" + str + \" \" ) ; document . write ( \" \" + n + \" \" ) ; steps ( str , n ) ;"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program JavaScript untuk mengira frekuensi item array; Tandakan semua elemen array seperti yang tidak dikunjungi; Melintasi unsur -unsur array dan kekerapan kiraan; Langkau elemen ini jika sudah diproses; Kekerapan kiraan; Kod pemacu", "code": "function countFreq ( arr , n ) { let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; let count = 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } document . write ( arr [ i ] + \" \" + count + \" \" ) ; } } let arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] ; let n = arr . length ; countFreq ( arr , n ) ;"}
{"text": "Semak pembahagian rentetan binari dengan 2 ^ k | Fungsi untuk memeriksa sama ada nombor binari yang diberikan sama rata dengan 2 ^ k atau tidak; Kiraan bilangan 0 dari yang terakhir; Jika Count = k, nombor sama rata, jadi pulangan benar lain palsu; Contoh pertama; Contoh kedua", "code": "function isDivisible ( str , k ) { let n = str . length ; let c = 0 ; for ( let i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == ' ' ) c ++ ; return ( c == k ) ; } let str1 = \" \" ; let k = 2 ; if ( isDivisible ( str1 , k ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" ) ; let str2 = \" \" ; k = 2 ; if ( isDivisible ( str2 , k ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Semak jika ada anagram rentetan adalah palindrome atau tidak | Program JavaScript untuk memeriksa sama ada anagram rentetan adalah palindrome atau tidak; berfungsi untuk memeriksa sama ada watak rentetan boleh membentuk palindrome; Buat array kiraan dan mulakan semua nilai sebagai 0; Bagi setiap aksara dalam rentetan input, kiraan kenaikan dalam array kiraan yang sepadan; Mengira watak -watak yang ganjil; Kembali benar jika kiraan ganjil adalah 0 atau 1 ,; Program pemacu untuk diuji untuk mencetak cetakan", "code": "let NO_OF_CHARS = 256 ; function canFormPalindrome ( str ) { let count = new Array ( NO_OF_CHARS ) ; count . fill ( 0 ) ; for ( let i = 0 ; i < str . length ; i ++ ) count [ str [ i ] . charCodeAt ( ) ] ++ ; let odd = 0 ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) != 0 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; } document . write ( canFormPalindrome ( \" \" ) ? \" \" + \" \" : \" \" + \" \" ) ; document . write ( canFormPalindrome ( \" \" ) ? \" \" : \" \" ) ;"}
{"text": "Program untuk memeriksa sama ada input adalah integer atau rentetan | Pulangan benar jika s adalah nombor lain palsu; Menyimpan input dalam rentetan; Fungsi pulangan 1 jika semua elemen berada dalam julat '0 ~ »~ 9'; Fungsi pulangan 0 jika input bukan integer", "code": "function isNumber ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) if ( s [ i ] < ' ' s [ i ] > ' ' ) return false ; return true ; } let str = \" \" ; if ( isNumber ( str ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Cetak terbalik rentetan menggunakan rekursi | Berfungsi untuk mencetak terbalik rentetan lulus; Program pemacu untuk menguji fungsi di atas", "code": "function reverse ( str , len ) { if ( len == str . length ) { return ; } reverse ( str , len + 1 ) ; document . write ( str [ len ] ) ; } let a = \" \" ; reverse ( a , 0 ) ;"}
{"text": "Kebarangkalian mengedarkan bola yang diberikan kepada dua bahagian yang mempunyai kiraan yang sama dengan warna yang berbeza | Menyimpan kiraan warna yang berbeza dalam Box1; Menyimpan kiraan warna yang berbeza dalam Box2; Fungsi untuk mengira kebarangkalian yang diperlukan; Hitung faktorial dari [1, 10]; Berikan semua bola yang berbeza ke kotak kedua; Jumlah bola; Hitung jumlah bola; Jika k adalah nombor ganjil; Jumlah cara mengedarkan bola dalam dua bahagian yang sama; Bilangan cara yang diperlukan; Mengembalikan kebarangkalian yang diperlukan; Fungsi untuk mengira jumlah bilangan pengagihan yang mungkin memenuhi syarat yang diberikan; Jika bola yang digunakan adalah sama dengan k / 2; Jika Box1 sama dengan Box2; Keadaan asas; Menyimpan bilangan cara mengedarkan bola yang tinggal tanpa termasuk bola semasa dalam Box1; Kotak kenaikan1 dengan satu; Melangkah ke atas julat [1, bola [i]]; Jika semua bola pergi ke Box1, kemudian menurunkan Box2 dengan satu; Jumlah cara memilih bola J; Kenaikan res dengan jumlah cara yang sah untuk mengedarkan bola yang tinggal; Box1 box1 oleh satu; Box2 Box2 oleh 1; Fungsi untuk mengira faktorial n; Kes asas; Melangkah ke atas julat [1, n]; Fungsi untuk mengira NCR; Kod pemacu; Cetak hasilnya", "code": "var box1 = 0 ; var box2 = 0 ; var fact = Array ( 11 ) ; function getProbability ( balls , M ) { factorial ( 10 ) ; box2 = M ; var K = 0 ; for ( var i = 0 ; i < M ; i ++ ) K += balls [ i ] ; if ( K % 2 == 1 ) return 0 ; var all = comb ( K , K / 2 ) ; var validPermutation = validPermutations ( K / 2 , balls , 0 , 0 , M ) ; return validPermutation / all ; } function validPermutations ( n , balls , usedBalls , i , M ) { if ( usedBalls == n ) { return box1 == box2 ? 1 : 0 ; } if ( i >= M ) return 0 ; var res = validPermutations ( n , balls , usedBalls , i + 1 , M ) ; box1 ++ ; for ( var j = 1 ; j <= balls [ i ] ; j ++ ) { if ( j == balls [ i ] ) box2 -- ; var combinations = comb ( balls [ i ] , j ) ; res += combinations * validPermutations ( n , balls , usedBalls + j , i + 1 , M ) ; } box1 -- ; box2 ++ ; return res ; } function factorial ( N ) { fact [ 0 ] = 1 ; for ( var i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; } function comb ( n , r ) { var res = fact [ n ] / fact [ r ] ; res /= fact [ n - r ] ; return res ; } var arr = [ 2 , 1 , 1 ] ; var N = 4 ; var M = arr . length ; document . write ( getProbability ( arr , M ) ) ;"}
{"text": "Kawasan n | Berfungsi untuk mencari kawasan poligon biasa; Sampingan dan jejari tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu", "code": "function polyarea ( n , r ) { if ( r < 0 && n < 0 ) return - 1 ; var A = ( ( r * r * n ) * Math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; } var r = 9 , n = 6 ; document . write ( polyarea ( n , r ) . toFixed ( 5 ) ) ;"}
{"text": "Semak jika garis pada 45 darjah boleh membahagikan pesawat ke dalam dua bahagian berat yang sama | Memeriksa jika satah boleh dibahagikan dengan garis pada 45 darjah supaya jumlah berat adalah sama; Putar setiap titik sebanyak 45 darjah dan mengira jumlah awalan. Juga, mencari koordinat X maksimum dan minimum; menyimpan jumlah berat sehingga titik x - y; Mencari Jumlah awalan; Line melewati saya, jadi ia tidak jatuh ke kiri atau kanan. ; Kod yang didorong", "code": "function is_partition_possible ( n , x , y , w ) { let weight_at_x = new Map ( ) ; let max_x = - 2e3 , min_x = 2e3 ; for ( let i = 0 ; i < n ; i ++ ) { let new_x = x [ i ] - y [ i ] ; max_x = Math . max ( max_x , new_x ) ; min_x = Math . min ( min_x , new_x ) ; if ( weight_at_x . has ( new_x ) ) { weight_at_x . set ( new_x , weight_at_x . get ( new_x ) + w [ i ] ) ; } else { weight_at_x . set ( new_x , w [ i ] ) ; } } let sum_till = [ ] ; sum_till . push ( 0 ) ; for ( let s = min_x ; s <= max_x ; s ++ ) { if ( weight_at_x . get ( s ) == null ) sum_till . push ( sum_till [ sum_till . length - 1 ] ) ; else sum_till . push ( sum_till [ sum_till . length - 1 ] + weight_at_x . get ( s ) ) ; } let total_sum = sum_till [ sum_till . length - 1 ] ; let partition_possible = 0 ; for ( let i = 1 ; i < sum_till . length ; i ++ ) { if ( sum_till [ i ] == total_sum - sum_till [ i ] ) partition_possible = 1 ; if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) partition_possible = 1 ; } document . write ( partition_possible == 1 ? \" \" : \" \" ) ; } let n = 3 ; let x = [ - 1 , - 2 , 1 ] ; let y = [ 1 , 1 , - 1 ] ; let w = [ 3 , 1 , 4 ] ; is_partition_possible ( n , x , y , w ) ;"}
{"text": "Cerun tegak lurus ke garisan | Berfungsi untuk mencari cerun garis lain; Kod pemacu", "code": "function findPCSlope ( m ) { return - 1.0 / m ; } let m = 2.0 ; document . write ( findPCSlope ( m ) ) ;"}
{"text": "Program untuk mencari kawasan segmen bulat | Program JavaScript untuk mencari kawasan segmen bulatan; Fungsi untuk mencari kawasan segmen; Mengira kawasan sektor; Mengira kawasan segitiga; Fungsi pemacu", "code": "let pi = 3.14159 ; function area_of_segment ( radius , angle ) { let area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; let area_of_triangle = 1 / 2 * ( radius * radius ) * Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; } let radius = 10.0 , angle = 90.0 ; document . write ( \" \" + area_of_segment ( radius , angle ) + \" \" ) ; document . write ( \" \" + area_of_segment ( radius , ( 360 - angle ) ) ) ;"}
{"text": "Kawasan Sektor Pekeliling | Program JavaScript untuk mencari kawasan sektor; Mengira kawasan sektor; Kod pemacu", "code": "function SectorArea ( radius , angle ) { if ( angle >= 360 ) document . write ( \" \" ) ; else { let sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; document . write ( sector ) ; } } let radius = 9 ; let angle = 60 ; SectorArea ( radius , angle ) ;"}
{"text": "Buat dua nombor sama dengan mendarab dengan faktor utama mereka bilangan minimum kali | Program JavaScript untuk pendekatan di atas; Semuanya membahagikan 0; Fungsi untuk mengira jumlah faktor utama dengan faktor utama mereka; Melangkah sementara nombornya juga; Mengurangkan separuh; Berulang sehingga sqrt (n); Melangkah sementara n mempunyai faktor i; Mengeluarkan satu faktor i; Berfungsi untuk mengira bilangan faktor; Cari GCD; Cari gandaan yang tersisa di x dan y; Cari faktor utama pelbagai kiri dalam x dan y; Memulakan ans; Semak sama ada mungkin untuk mendapatkan x atau tidak; Periksa sama ada mungkin untuk mendapatkan y atau tidak; kembali utama ans; Diberikan input; Panggilan fungsi", "code": "function gcd ( a , b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } function PrimeFactor ( N ) { let primef = new Map ( ) ; while ( N % 2 == 0 ) { if ( primef . has ( 2 ) ) { primef . set ( 2 , primef . get ( 2 ) + 1 ) ; } else { primef . set ( 2 , 1 ) ; } N = parseInt ( N / 2 , 10 ) ; } for ( let i = 3 ; i <= Math . sqrt ( N ) ; i ++ ) { while ( N % i == 0 ) { if ( primef . has ( i ) ) { primef . set ( i , primef . get ( i ) + 1 ) ; } else { primef . set ( i , 1 ) ; } N = parseInt ( N / 2 , 10 ) ; } } if ( N > 2 ) { primef [ N ] = 1 ; } return primef ; } function CountToMakeEqual ( X , Y ) { let gcdofXY = gcd ( X , Y ) ; let newX = parseInt ( Y / gcdofXY , 10 ) ; let newY = parseInt ( X / gcdofXY , 10 ) ; let primeX = PrimeFactor ( newX ) ; let primeY = PrimeFactor ( newY ) ; let ans = 0 ; primeX . forEach ( ( values , keys ) => { if ( X % keys != 0 ) { return - 1 ; } ans += primeX . get ( keys ) ; } ) ans += 1 ; primeY . forEach ( ( values , keys ) => { if ( Y % keys != 0 ) { return - 1 ; } ans += primeY . get ( keys ) ; } ) return ans ; } let X = 36 ; let Y = 48 ; let ans = CountToMakeEqual ( X , Y ) ; document . write ( ans ) ;"}
{"text": "Buat segmen yang diberikan bukan | Menyimpan butiran segmen; Berfungsi untuk memeriksa sama ada graf adalah bipartite atau tidak; Tanda nod sumber seperti yang dikunjungi; Tolak puncak sumber dalam barisan; Dapatkan bahagian depan barisan; Berikan warna kepada nod yang muncul; Melintasi senarai addacency nod u; Jika mana -mana nod dikunjungi & warna yang berbeza telah diberikan, maka kembali palsu; Tetapkan dikunjungi [x]; Tolak nod X ke dalam barisan; Kemas kini warna nod; Jika graf adalah bipartite; Berfungsi untuk menambah kelebihan antara nod U dan V; Berfungsi untuk memeriksa sama ada tugasan arah boleh dilakukan untuk semua segmen, supaya mereka tidak bersilang selepas jangka masa yang panjang; Menyimpan senarai adjacency graf yang dicipta; Memulakan; Menjana semua pasangan yang mungkin; Jika segmen tidak bertindih; Jika tidak, segmen bertindih; Jika kedua -dua segmen mempunyai kelajuan yang sama, maka tambahkan kelebihan; Pastikan jejak nod yang dikunjungi; Berulang untuk semua nod yang mungkin; Semak sama ada graf adalah bipartite atau tidak; Jika graf adalah bipartite; Kod pemacu", "code": "class Node { constructor ( L , R , V ) { this . L = L ; this . R = R ; this . V = V ; } } function check ( Adj , Src , N , visited ) { let color = new Array ( N ) ; visited [ Src ] = true ; let q = [ ] ; q . push ( Src ) ; while ( q . length != 0 ) { let u = q . shift ( ) ; let Col = color [ u ] ; for ( let x = 0 ; x < Adj [ u ] . length ; x ++ ) { if ( visited [ Adj [ u ] [ x ] ] == true && color [ Adj [ u ] [ x ] ] == Col ) { return false ; } else if ( visited [ Adj [ u ] [ x ] ] == false ) { visited [ Adj [ u ] [ x ] ] = true ; q . push ( Adj [ u ] [ x ] ) ; color [ Adj [ u ] [ x ] ] = 1 - Col ; } } } return true ; } function addEdge ( Adj , u , v ) { Adj [ u ] . push ( v ) ; Adj [ v ] . push ( u ) ; } function isPossible ( Arr , N ) { let Adj = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) Adj [ i ] = [ ] ; for ( let i = 0 ; i < N - 1 ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] . R < Arr [ j ] . L Arr [ i ] . L > Arr [ j ] . R ) { continue ; } else { if ( Arr [ i ] . V == Arr [ j ] . V ) { addEdge ( Adj , i , j ) ; } } } } let visited = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) visited [ i ] = false ; for ( let i = 0 ; i < N ; i ++ ) { if ( visited [ i ] == false && Adj [ i ] . length > 0 ) { if ( check ( Adj , i , N , visited ) == false ) { document . write ( \" \" ) ; return ; } } } document . write ( \" \" ) ; } let arr = [ new Node ( 5 , 7 , 2 ) , new Node ( 4 , 6 , 1 ) , new Node ( 1 , 5 , 2 ) , new Node ( 6 , 5 , 1 ) ] ; let N = arr . length ; isPossible ( arr , N ) ;"}
{"text": "Menjana semua nombor sehingga n dalam urutan leksikografi | Program JavaScript untuk pendekatan di atas; Kod pemacu", "code": "function lexNumbers ( n ) { var sol = [ ] ; dfs ( 1 , n , sol ) ; document . write ( \" \" + sol [ 0 ] ) ; for ( var i = 1 ; i < sol . length ; i ++ ) document . write ( \" \" + sol [ i ] ) ; document . write ( \" \" ) ; } function dfs ( temp , n , sol ) { if ( temp > n ) return ; sol . push ( temp ) ; dfs ( temp * 10 , n , sol ) ; if ( temp % 10 != 9 ) dfs ( temp + 1 , n , sol ) ; } var n = 15 ; lexNumbers ( n ) ;"}
{"text": "Bilangan swap minimum yang diperlukan untuk menyusun pelbagai nombor N pertama | Berfungsi untuk mencari swap minimum; Pembolehubah kiraan permulaan; Jika elemen semasa tidak berada di kedudukan yang betul; Swap elemen semasa dengan kedudukan yang betul dari elemen itu; Kenaikan untuk indeks seterusnya apabila elemen semasa berada pada kedudukan yang betul; Kod pemacu; Berfungsi untuk mencari swap minimum", "code": "function minimumSwaps ( arr ) { let count = 0 ; let i = 0 ; while ( i < arr . length ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { let temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; } let arr = [ 2 , 3 , 4 , 1 , 5 ] ; document . write ( minimumSwaps ( arr ) ) ;"}
{"text": "Gabungkan K -Sorted Doubly Linked List dalam Order Sorted | Program JavaScript untuk menggabungkan K -Sorted Diply Linked List dalam Pesanan Sorted Node Listed Node; Nod senarai yang dipautkan; Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala DLL dan int, tambah nod baru pada akhir; Memperuntukkan nod; Masukkan data; Nod baru ini akan menjadi nod terakhir, jadi buatlah seterusnya sebagai batal; Jika senarai yang dipautkan kosong, maka buat nod baru sebagai kepala; Lain melintasi sehingga nod terakhir; Tukar nod terakhir yang akan datang; Buat nod terakhir seperti sebelumnya dari nod baru; Berfungsi untuk mencetak senarai; Jalankan semasa gelung melainkan nod menjadi batal; Berfungsi untuk menggabungkan dua senarai dikaitkan dua kali ganda; Jika mana -mana senarai kosong; Perbandingan data dua senarai yang dipautkan; Simpan penunjuk kepala sebelum menggabungkan senarai; Menukar penunjuk antara dua senarai untuk penggabungan; Menukar penunjuk antara dua senarai untuk penggabungan; Syarat untuk memeriksa sama ada sesiapa yang menyenaraikan tidak berakhir; Kembali penunjuk kepala senarai yang digabungkan; Berfungsi untuk menggabungkan semua senarai yang disusun dalam susunan yang disusun; Panggilan fungsi untuk menggabungkan dua senarai dikaitkan berganda yang disusun pada satu masa; Kembali akhir disusun senarai dua kali ganda; Kod pemacu; Gelung untuk memulakan semua senarai untuk kosong; Buat senarai senarai dua kali ganda pertama1. 1 <=> 5 <=> 9; Buat senarai dikaitkan dua kali ganda kedua2. 2 <=> 3 <=> 7 <=> 12; Buat senarai dikaitkan dua kali ganda 3 senarai3. 8 <=> 11 <=> 13 <=> 18; Panggilan fungsi untuk menggabungkan semua senarai dikaitkan dua kali ganda dalam urutan yang disusun; Cetak senarai disusun akhir", "code": "class Node { constructor ( ) { this . data = 0 ; this . next = null ; this . prev = null ; } } class Node { constructor ( ) { this . data = 0 ; this . next = null ; this . prev = null ; } } function append ( head_ref , new_data ) { new_node = new Node ( ) ; last = head_ref ; new_node . data = new_data ; new_node . next = null ; if ( head_ref == null ) { new_node . prev = null ; head_ref = new_node ; return head_ref ; } while ( last . next != null ) last = last . next ; last . next = new_node ; new_node . prev = last ; return head_ref ; } function printList ( node ) { last ; while ( node != null ) { document . write ( node . data + \" \" ) ; last = node ; node = node . next ; } } function mergeList ( p , q ) { s = null ; if ( p == null q == null ) { return ( p == null ? q : p ) ; } if ( p . data < q . data ) { p . prev = s ; s = p ; p = p . next ; } else { q . prev = s ; s = q ; q = q . next ; } head = s ; while ( p != null && q != null ) { if ( p . data < q . data ) { s . next = p ; p . prev = s ; s = s . next ; p = p . next ; } else { s . next = q ; q . prev = s ; s = s . next ; q = q . next ; } } if ( p == null ) { s . next = q ; q . prev = s ; } if ( q == null ) { s . next = p ; p . prev = s ; } return head ; } function mergeAllList ( head , k ) { finalList = null ; for ( i = 0 ; i < k ; i ++ ) { finalList = mergeList ( finalList , head [ i ] ) ; } return finalList ; } var k = 3 ; head = Array ( k ) . fill ( null ) ; for ( i = 0 ; i < k ; i ++ ) { head [ i ] = null ; } head [ 0 ] = append ( head [ 0 ] , 1 ) ; head [ 0 ] = append ( head [ 0 ] , 5 ) ; head [ 0 ] = append ( head [ 0 ] , 9 ) ; head [ 1 ] = append ( head [ 1 ] , 2 ) ; head [ 1 ] = append ( head [ 1 ] , 3 ) ; head [ 1 ] = append ( head [ 1 ] , 7 ) ; head [ 1 ] = append ( head [ 1 ] , 12 ) ; head [ 2 ] = append ( head [ 2 ] , 8 ) ; head [ 2 ] = append ( head [ 2 ] , 11 ) ; head [ 2 ] = append ( head [ 2 ] , 13 ) ; head [ 2 ] = append ( head [ 2 ] , 18 ) ; finalList = mergeAllList ( head , k ) ; printList ( finalList ) ;"}
{"text": "SENARAI SENSI RECURSIVE | Fungsi rekursif untuk menyusun array menggunakan jenis penyisipan; Kes asas; Susun pertama n - 1 elemen; Masukkan elemen terakhir pada kedudukan yang betul dalam array yang disusun. ; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Kaedah Pemandu", "code": "function insertionSortRecursive ( arr , n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; let last = arr [ n - 1 ] ; let j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; } let arr = [ 12 , 11 , 13 , 5 , 6 ] ; insertionSortRecursive ( arr , arr . length ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; }"}
{"text": "Susun gelembung rekursif | Fungsi untuk melaksanakan jenis gelembung; Kes asas; Satu lulus jenis gelembung. Selepas lulus ini, elemen terbesar dipindahkan (atau bubbled) untuk berakhir. ; swap arr [i], arr [i + 1]; Unsur terbesar ditetapkan, berulang untuk array yang tinggal; Kod pemacu", "code": "function bubbleSort ( arr , n ) { if ( n == 1 ) return ; for ( var i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) { var temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } bubbleSort ( arr , n - 1 ) ; } var arr = [ 64 , 34 , 25 , 12 , 22 , 11 , 90 ] bubbleSort ( arr , arr . length ) ; document . write ( \" \" + \" \" ) ; for ( var i = 0 ; i < arr . length ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; }"}
{"text": "Perbezaan maksimum jumlah dua subset dari array | Tetapkan 2 | Program JavaScript untuk melaksanakan pendekatan di atas; Menyimpan unsur -unsur positif; Menyimpan unsur -unsur negatif; Menyimpan kiraan 0 s; Jumlah semua nombor positif; Jumlah semua nombor negatif; Melangkah ke atas array; Menyimpan perbezaan; Menyusun nombor positif dalam urutan menaik; Menyusun nombor negatif dalam penurunan urutan; Kes 1: Sertakan nombor positif dan negatif; Letakkan semua nombor dalam subset a dan satu 0 dalam subset b; Letakkan semua nombor dalam subset A kecuali nombor positif terkecil yang dimasukkan ke dalam B; Letakkan semua nombor dalam subset b dan satu 0 dalam subset A; Letakkan nombor negatif terbesar dalam subset A dan baki dalam B; Kod pemacu", "code": "function maxSumAfterPartition ( arr , n ) { let pos = [ ] ; let neg = [ ] ; let zero = 0 ; let pos_sum = 0 ; let neg_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { pos . push ( arr [ i ] ) ; pos_sum += arr [ i ] ; } else if ( arr [ i ] < 0 ) { neg . push ( arr [ i ] ) ; neg_sum += arr [ i ] ; } else { zero ++ ; } } let ans = 0 ; pos . sort ( function ( a , b ) { return a - b } ) neg . sort ( function ( a , b ) { return b - a } ) if ( pos . length > 0 && neg . length > 0 ) { ans = ( pos_sum - neg_sum ) ; } else if ( pos . length > 0 ) { if ( zero > 0 ) { ans = ( pos_sum ) ; } else { ans = ( pos_sum - 2 * pos [ 0 ] ) ; } } else { if ( zero > 0 ) { ans = ( - 1 * neg_sum ) ; } else { ans = ( neg [ 0 ] - ( neg_sum - neg [ 0 ] ) ) ; } } return ans ; } let arr = [ 1 , 2 , 3 , - 5 , - 7 ] ; let n = arr . length ; document . write ( maxSumAfterPartition ( arr , n ) ) ;"}
{"text": "Pecahkan array ke subarrays dengan bitwise maksimum XOR masing -masing bitwise atau nilai masing -masing | Berfungsi untuk mencari elemen bitwise atau array; Menyimpan nilai maksimum yang dihasilkan dari bitwise XOR; Melintasi array arr []; Mengembalikan nilai maksimum RES; Kod pemacu", "code": "function MaxXOR ( arr , N ) { var res = 0 ; for ( var i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; } var arr = [ 1 , 5 , 7 ] ; var N = arr . length ; document . write ( MaxXOR ( arr , N ) ) ;"}
{"text": "Kira bilangan unsur biasa antara array yang disusun dan array yang disusun terbalik | Berfungsi untuk mengira bilangan elemen yang biasa dalam kedua -dua tatasusunan; Digunakan untuk melintasi array A [] dan B [] dari depan dan belakang; Menyimpan kiraan nombor yang biasa dalam kedua -dua array; Jika A [pertama] kurang daripada b [kedua]; Meningkatkan nilai pertama; Jika B [kedua] kurang daripada [pertama]; Menurunkan nilai kedua; A [pertama] adalah sama dengan b [kedua]; Meningkatkan nilai kiraan; Meningkatkan nilai pertama; Menurunkan nilai kedua; Mengembalikan nilai kiraan; Kod pemacu", "code": "function countEqual ( A , B , N ) { let first = 0 ; let second = N - 1 ; let count = 0 ; while ( first < N && second >= 0 ) { if ( A [ first ] < B [ second ] ) { first ++ ; } else if ( B [ second ] < A [ first ] ) { second -- ; } else { count ++ ; first ++ ; second -- ; } } return count ; } let A = [ 2 , 4 , 5 , 8 , 12 , 13 , 17 , 18 , 20 , 22 , 309 , 999 ] ; let B = [ 109 , 99 , 68 , 54 , 22 , 19 , 17 , 13 , 11 , 5 , 3 , 1 ] ; let N = A . length ; document . write ( countEqual ( A , B , N ) ) ;"}
{"text": "Pertanyaan untuk mengira nombor palindrome dari julat yang jumlah digitnya adalah nombor utama | Program JavaScript untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada nombor n adalah palindrome atau tidak; Simpan nilai n; Simpan sebaliknya nombor n; Tempatan terbalik dan simpan di res; Jika n adalah sama dengan res, maka kembali benar; Berfungsi untuk mencari jumlah digit nombor n; Menyimpan jumlah digit; Tambah digit terakhir nombor N ke jumlah; Keluarkan digit terakhir dari N; Mengembalikan jumlah yang dihasilkan; Fungsi untuk memeriksa sama ada n adalah perdana atau tidak; Jika saya adalah 1 atau 0, maka kembali palsu; Semak jika saya boleh dibahagikan dengan mana -mana nombor dalam julat [2, n / 2]; Jika n boleh dibahagikan dengan i; Berfungsi untuk mendahului semua nombor sehingga 10 ^ 5 yang palindromik dan jumlah digitnya adalah nombor utama; Melangkah ke atas julat 1 hingga 10 ^ 5; Jika saya adalah nombor palindrome; Menyimpan jumlah digit dalam i; Jika jumlah digit dalam saya adalah nombor utama; Cari jumlah awalan arr []; Fungsi untuk mengira semua nombor dalam julat yang diberikan adalah palindromik dan jumlah digit adalah nombor utama; Fungsi panggilan untuk precompute semua nombor hingga 10 ^ 5; Melintasi pertanyaan yang diberikan Q []; Cetak hasil untuk setiap pertanyaan; Kod pemacu; Panggilan fungsi", "code": "let arr = [ ] ; for ( let m = 0 ; m < 100005 ; m ++ ) { arr [ m ] = 0 ; } function isPalindrome ( N ) { int temp = N ; let res = 0 ; while ( temp != 0 ) { let rem = temp % 10 ; res = res * 10 + rem ; temp = Math . floor ( temp / 10 ) ; } if ( res == N ) { return true ; } else { return false ; } } function sumOfDigits ( N ) { let sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N = Math . floor ( N / 10 ) ; } return sum ; } function isPrime ( n ) { if ( n <= 1 ) { return false ; } for ( let i = 2 ; i <= Math . floor ( n / 2 ) ; ++ i ) { if ( n % i == 0 ) return false ; } return true ; } function precompute ( ) { for ( let i = 1 ; i <= 100000 ; i ++ ) { if ( isPalindrome ( i ) ) { let sum = sumOfDigits ( i ) ; if ( isPrime ( sum ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } else arr [ i ] = 0 ; } for ( let i = 1 ; i <= 100000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } } function countNumbers ( Q , N ) { precompute ( ) ; for ( let i = 0 ; i < N ; i ++ ) { document . write ( ( arr [ Q [ i ] [ 1 ] ] - arr [ Q [ i ] [ 0 ] - 1 ] ) + \" \" ) ; } } let Q = [ [ 5 , 9 ] , [ 1 , 101 ] ] ; let N = Q . length ; countNumbers ( Q , N ) ;"}
{"text": "Nombor terkecil lebih besar daripada atau sama dengan N yang mempunyai jumlah digit tidak melebihi s | Fungsi untuk mengira jumlah digit n; Berfungsi untuk mencari integer yang paling kecil yang memenuhi syarat yang diberikan; Jika jumlah digit sudah lebih kecil daripada S; Memulakan pembolehubah; Mencari digit kth terakhir; Tambah baki untuk membuat digit 0; Jika jumlah digit tidak melebihi s; Kemas kini k; Diberikan n dan s; Panggilan fungsi", "code": "function sum ( n ) { var res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; } function smallestNumber ( n , s ) { if ( sum ( n ) <= s ) { return n ; } var ans = n , k = 1 ; for ( i = 0 ; i < 9 ; ++ i ) { var digit = ( ans / k ) % 10 ; var add = k * ( ( 10 - digit ) % 10 ) ; ans += add ; if ( sum ( ans ) <= s ) { break ; } k *= 10 ; } return ans ; } var N = 3 , S = 2 ; document . write ( smallestNumber ( N , S ) ) ;"}
{"text": "Memaksimumkan kiraan penurunan seterusnya berturut -turut dari array | Berfungsi untuk mencari bilangan maksimum bilangan berikutnya yang diperlukan; Kamus untuk menyimpan bilangan anak panah yang tersedia dengan ketinggian anak panah sebagai kunci; Menyimpan kiraan maksimum kemungkinan berikutnya; Menyimpan kiraan kemungkinan seterusnya; Semak jika elemen saya boleh menjadi sebahagian daripada mana -mana berikutnya; Kiraan seterusnya mungkin dengan arr [i] sebagai elemen seterusnya; Jika lebih daripada satu berikutnya wujud; Termasuk arr [i] dalam berikutnya; Jika tidak; Meningkatkan kiraan seterusnya dengan ARR [i] - 1 sebagai elemen seterusnya; Mulakan berikutnya baru; Meningkatkan kiraan seterusnya dengan ARR [i] - 1 sebagai elemen seterusnya; Kembalikan jawapannya; Kod pemacu", "code": "function maxSubsequences ( arr , n ) { let map = new Map ( ) ; let maxCount = 0 ; let count ; for ( let i = 0 ; i < n ; i ++ ) { if ( map . has ( arr [ i ] ) ) { count = map [ arr [ i ] ] ; if ( count > 1 ) { map . add ( arr [ i ] , count - 1 ) ; } else map . delete ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) if ( map . has ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . set ( arr [ i ] - 1 , 1 ) ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) if ( map . has ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . set ( arr [ i ] - 1 , 1 ) ; } } return maxCount ; } let n = 5 ; let arr = [ 4 , 5 , 2 , 1 , 4 ] ; document . write ( maxSubsequences ( arr , n ) ) ;"}
{"text": "Keluarkan kejadian pertama dan terakhir yang diberikan dari rentetan |  ; Melintasi rentetan yang diberikan dari awal; Jika ch dijumpai; Melintasi rentetan yang diberikan dari hujungnya; Jika ch dijumpai; Kod pemacu", "code": "Function to remove first and last occurrence of a given character from the given String * / function removeOcc ( s , ch ) { for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] === ch ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; break ; } } for ( var i = s . length - 1 ; i > - 1 ; i -- ) { if ( s [ i ] === ch ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; break ; } } return s ; } var s = \" \" ; var ch = \" \" ; document . write ( removeOcc ( s , ch ) ) ;"}
{"text": "Langkah -langkah minimum untuk meningkatkan dan mengurangkan array untuk mencapai 0 atau n | Fungsi yang mendapati langkah -langkah minimum untuk mencapai 0 atau n untuk peningkatan array yang semakin meningkat dan menurun; Memulakan pemboleh ubah untuk mencari elemen minimum; Cari elemen minimum dalam peningkatan [] array; Memulakan pembolehubah untuk mencari elemen maksimum; Cari elemen maksimum dalam penurunan [] array; Cari langkah minimum; Cetak langkah minimum; Diberikan n; Memandangkan peningkatan dan penurunan array; Cari panjang tatasusunan yang semakin meningkat dan berkurangan; Panggilan fungsi", "code": "function minSteps ( N , increasing , decreasing , m1 , m2 ) { var mini = 2147483647 ; var i ; for ( i = 0 ; i < m1 ; i ++ ) { if ( mini > increasing [ i ] ) mini = increasing [ i ] ; } var maxi = - 2147483648 ; for ( i = 0 ; i < m2 ; i ++ ) { if ( maxi < decreasing [ i ] ) maxi = decreasing [ i ] ; } var minSteps = Math . max ( maxi , N - mini ) ; document . write ( minSteps ) ; } var N = 7 ; var increasing = [ 3 , 5 ] ; var decreasing = [ 6 ] ; var m1 = increasing . length ; var m2 = decreasing . length ; minSteps ( N , increasing , decreasing , m1 , m2 ) ;"}
{"text": "Bilangan minimum swap bersebelahan yang diperlukan untuk menukar permutasi kepada permutasi lain dengan keadaan yang diberikan | Berfungsi untuk mencari bilangan swap minimum; Array baru untuk menukar kepada pengindeksan berasaskan 1; Menyimpan swap; Semak sama ada kedudukan 'X'; Kes sudut; Swap; Prlet swap minimum; Diberi nombor n; Diberi permutasi nombor N; Panggilan fungsi", "code": "function solve ( P , n ) { let arr = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; arr [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) arr [ i + 1 ] = P [ i ] ; let cnt = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { let t = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ i ] ; arr [ i ] = t ; cnt ++ ; } } if ( arr [ n ] == n ) { let t = arr [ n - 1 ] ; arr [ n - 1 ] = arr [ n ] ; arr [ n ] = t ; cnt ++ ; } document . write ( cnt ) ; } let N = 9 ; let P = [ 1 , 2 , 4 , 9 , 5 , 8 , 7 , 3 , 6 ] ; solve ( P , N ) ;"}
{"text": "Semak jika array adalah array gelombang | Fungsi untuk memeriksa sama ada array adalah array gelombang arr: array input n: saiz array; Semak borang gelombang * jika arr [1] lebih besar daripada corak kiri dan kanan * yang sama akan diikuti oleh seluruh elemen *, corak terbalik lain * akan diikuti oleh unsur -unsur array; Semak elemen terakhir; Semak elemen terakhir; Array", "code": "function isWaveArray ( arr , n ) { let result = true ; if ( arr [ 1 ] > arr [ 0 ] && arr [ 1 ] > arr [ 2 ] ) { for ( let i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] <= arr [ n - 2 ] ) { result = false ; } } } else if ( arr [ 1 ] < arr [ 0 ] && arr [ 1 ] < arr [ 2 ] ) { for ( let i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { result = false ; } } } return result ; } let arr = [ 1 , 3 , 2 , 4 ] ; let n = arr . length ; if ( isWaveArray ( arr , n ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Mengira urutan yang berbeza yang diperoleh dengan menggantikan semua elemen subarray yang mempunyai unsur -unsur pertama dan terakhir yang sama dengan elemen pertama sebilangan kali | Fungsi untuk mengira bilangan urutan yang memenuhi kriteria yang diberikan; Menyimpan indeks kejadian terakhir elemen; Memulakan array untuk menyimpan bilangan urutan yang berbeza yang mungkin panjang i; Kes asas; Sekiranya tiada operasi digunakan pada elemen ITH; Jika operasi digunakan pada elemen ITH; Mengemas kini kejadian terakhir Curele; Akhirnya, prlet jawapannya; Kod pemacu", "code": "function countPossiblities ( arr , n ) { let lastOccur = new Array ( 100000 ) ; for ( let i = 0 ; i < n ; i ++ ) { lastOccur [ i ] = - 1 ; } dp = new Array ( n + 1 ) ; dp [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { let curEle = arr [ i - 1 ] ; dp [ i ] = dp [ i - 1 ] ; if ( lastOccur [ curEle ] != - 1 & lastOccur [ curEle ] < i - 1 ) { dp [ i ] += dp [ lastOccur [ curEle ] ] ; } lastOccur [ curEle ] = i ; } document . write ( dp [ n ] + \" \" ) ; } let arr = [ 1 , 2 , 1 , 2 , 2 ] ; let N = arr . length ; countPossiblities ( arr , N ) ;"}
{"text": "Jumlah maksimum yang mungkin dari matriks yang diberikan dengan melaksanakan operasi yang diberikan | Berfungsi untuk mencetak jumlah maksimum; Jadual DP; Memulakan array DP dengan 0 s; Kes asas; Melintasi setiap lajur; Kemas kini jawapan untuk kedua -dua baris; Cetak jumlah maksimum; Diberikan array; Bilangan lajur; Panggilan fungsi", "code": "function maxSum ( arr , n , m ) { let dp = new Array ( n ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < 2 ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] ; dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] ; for ( let j = m - 2 ; j >= 0 ; j -- ) { for ( let i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i ] [ j ] = Math . max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) ; } else { dp [ i ] [ j ] = Math . max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) ; } } } document . write ( Math . max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ) ; } let arr = [ [ 1 , 50 , 21 , 5 ] , [ 2 , 10 , 10 , 5 ] ] ; let N = arr [ 0 ] . length ; maxSum ( arr , 2 , N ) ;"}
{"text": "Jumlah maksimum yang mungkin dari matriks yang diberikan dengan melaksanakan operasi yang diberikan | Fungsi untuk mencetak jumlah maksimum yang mungkin dengan memilih kebanyakan elemen dari setiap lajur sehingga tiada pasangan berturut -turut dipilih dari satu baris; Memulakan pembolehubah; Melintasi setiap lajur; Jawapan prvar; Kod pemacu; Lajur nombor", "code": "function maxSum ( arr , n ) { var r1 = 0 , r2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { var temp = r1 ; r1 = Math . max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = Math . max ( r2 , temp + arr [ 1 ] [ i ] ) ; } document . write ( Math . max ( r1 , r2 ) ) ; } var arr = [ [ 1 , 50 , 21 , 5 ] , [ 2 , 10 , 10 , 5 ] ] ; var n = arr [ 0 ] . length ; maxSum ( arr , n ) ;"}
{"text": "Kira unimodal dan bukan | Program JavaScript untuk pendekatan di atas; Berfungsi untuk mengira faktorial sehingga nombor; Kirakan faktorial; Berfungsi untuk mencari kuasa (a, b); Melangkah sehingga B wujud; Jika B boleh dibahagikan dengan 2; Mengurangkan nilai b; Kembalikan jawapannya; Fungsi yang mengira permutasi unimodal dan bukan unimodal dari integer yang diberikan; Fungsi panggilan untuk mencari faktorial sehingga n; Berfungsi untuk mengira permutasi unimodal; Permutasi bukan unimodal adalah N! - permutasi unimodal; Kod pemacu diberi nombor n; Panggilan fungsi", "code": "var mod = parseInt ( 1e9 + 7 ) ; var mx = 1000000 ; var fact = new Array ( mx + 1 ) . fill ( 0 ) ; function Calculate_factorial ( ) { fact [ 0 ] = 1 ; for ( var i = 1 ; i <= mx ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; fact [ i ] %= mod ; } } function UniModal_per ( a , b ) { var res = 1 ; while ( b > 0 ) { if ( b % 2 !== 0 ) res = res * a ; res %= mod ; a = a * a ; a %= mod ; b = parseInt ( b / 2 ) ; } return res ; } function countPermutations ( n ) { Calculate_factorial ( ) ; var uni_modal = UniModal_per ( 2 , n - 1 ) ; var nonuni_modal = fact [ n ] - uni_modal ; document . write ( uni_modal + \" \" + nonuni_modal ) ; return ; } var N = 4 ; countPermutations ( N ) ;"}
{"text": "Susunan terpanjang mungkin yang bermula dan berakhir dengan 1 dan diisi dengan 0 di tengah | Program JavaScript untuk mencari kemungkinan seterusnya yang paling lama yang bermula dan berakhir dengan 1 dan diisi dengan 0 di tengah; Arahan awalan untuk menyimpan kejadian '1' dan '0'; Melangkah ke atas panjang rentetan; Jika watak semasa adalah '1'; Jika watak semasa adalah '0'; Tambah '1' yang tersedia untuk rentetan pertama; Tambah '0' tersedia untuk rentetan kedua; Tambah '1' yang tersedia untuk rentetan ketiga; Jawapan kemas kini; Cetak hasil yang dibaca; Kod pemacu", "code": "function longestSubseq ( s , len ) { var ones = new Array ( len + 1 ) . fill ( 0 ) ; var zeroes = new Array ( len + 1 ) . fill ( 0 ) ; for ( var i = 0 ; i < len ; i ++ ) { if ( s [ i ] === \" \" ) { ones [ i + 1 ] = ones [ i ] + 1 ; zeroes [ i + 1 ] = zeroes [ i ] ; } else { zeroes [ i + 1 ] = zeroes [ i ] + 1 ; ones [ i + 1 ] = ones [ i ] ; } } var answer = - 2147483648 ; var x = 0 ; for ( var i = 0 ; i <= len ; i ++ ) { for ( var j = i ; j <= len ; j ++ ) { x += ones [ i ] ; x += zeroes [ j ] - zeroes [ i ] ; x += ones [ len ] - ones [ j ] ; answer = Math . max ( answer , x ) ; x = 0 ; } } document . write ( answer ) ; } var s = \" \" ; var len = s . length ; longestSubseq ( s , len ) ;"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | Pelaksanaan JavaScript untuk mencari dataran terbesar dalam matriks sehingga ia mengandungi atmost k 1 's; Berfungsi untuk mengira dataran terbesar dengan atmost k 1 s untuk pertanyaan Q; Gelung untuk menyelesaikan setiap pertanyaan; Melintasi setiap sub persegi dan mengira jumlah; Pecah apabila melebihi kiraan maksimum; Kod pemacu", "code": "var MAX = 100 ; function largestSquare ( matrix , R , C , q_i , q_j , K , Q ) { for ( var q = 0 ; q < Q ; q ++ ) { var i = q_i [ q ] ; var j = q_j [ q ] ; var min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; var ans = - 1 ; for ( var k = 0 ; k <= min_dist ; k ++ ) { var count = 0 ; for ( var row = i - k ; row <= i + k ; row ++ ) for ( var col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } document . write ( ans + \" \" ) ; } } var matrix = [ [ 1 , 0 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 0 ] ] ; var K = 9 , Q = 1 ; var q_i = [ 1 ] ; var q_j = [ 2 ] ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ;"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | Pelaksanaan JavaScript untuk mencari dataran terbesar dalam matriks sehingga ia mengandungi atmost k 1 's; Berfungsi untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Precomputing jumlah awalan countdp matriks; Gelung untuk menyelesaikan pertanyaan; Mengira jarak maksimum yang mungkin dari pusat dari tepi; Mengira bilangan 1 s dalam submatrix; Kod pemacu", "code": "let MAX = 100 ; function largestSquare ( matrix , R , C , q_i , q_j , K , Q ) { let countDP = new Array ( R ) ; for ( let i = 0 ; i < R ; i ++ ) { countDP [ i ] = new Array ( C ) ; for ( let j = 0 ; j < C ; j ++ ) countDP [ i ] [ j ] = 0 ; } countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( let i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( let j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( let i = 1 ; i < R ; i ++ ) for ( let j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( let q = 0 ; q < Q ; q ++ ) { let i = q_i [ q ] ; let j = q_j [ q ] ; let min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; let ans = - 1 ; for ( let k = 0 ; k <= min_dist ; k ++ ) { let x1 = i - k , x2 = i + k ; let y1 = j - k , y2 = j + k ; let count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } document . write ( ans + \" \" ) ; } } let matrix = [ [ 1 , 0 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 0 ] ] ; let K = 9 , Q = 1 ; let q_i = [ 1 ] ; let q_j = [ 2 ] ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ;"}
{"text": "N Masalah Tali berturut -turut | Berfungsi untuk mengembalikan kos minimum untuk menyambungkan tali yang diberikan; dp [i] [j] = kos minimum dalam julat (i, j) jumlah [i] [j] = jumlah julat (i, j); Memulakan sum jadual memset (jumlah, 0, sizeof (0)); ; Pengkomputeran kos minimum untuk semua selang waktu yang mungkin (i, j) julat kiri; Julat kanan; Tiada kos untuk tali tunggal; Kod pemacu", "code": "function MinCost ( arr , n ) { let dp = new Array ( n + 5 ) ; let sum = new Array ( n + 5 ) ; for ( let i = 0 ; i < n + 5 ; i ++ ) { dp [ i ] = [ ] ; sum [ i ] = [ ] ; for ( let j = 0 ; j < n + 5 ; j ++ ) { dp [ i ] . push ( 0 ) sum [ i ] . push ( 0 ) } } console . log ( dp ) for ( let i = 0 ; i < n ; i ++ ) { let k = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i ] [ j ] = k ; else { k += arr [ j ] ; sum [ i ] [ j ] = k ; } } } for ( let i = n - 1 ; i >= 0 ; i -- ) { for ( let j = i ; j < n ; j ++ ) { dp [ i ] [ j ] = Number . MAX_SAFE_INTEGER ; if ( i == j ) dp [ i ] [ j ] = 0 ; else { for ( let k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) ; } } } } return dp [ 0 ] [ n - 1 ] ; } let arr = [ 7 , 6 , 8 , 6 , 1 , 1 ] ; let n = arr . length ; document . write ( MinCost ( arr , n ) ) ;"}
{"text": "Panjang subsegment terpanjang yang dikemas kini selepas memasukkan atmost satu integer | Berfungsi untuk mengisi semula array DP; Jika f (i, state) sudah dikira maka kembalikan nilai; Hitung f (i, state) mengikut hubungan berulang dan simpan dalam dp [] []; Fungsi yang memanggil fungsi resucrsive untuk mengisi array DP dan kemudian mengembalikan hasilnya; dp [] [] array untuk menyimpan hasil f (i, 1) dan f (1, 2); Memaparkan array dp [] dengan - 1; Pastikan urutan UD dan DU terpanjang bermula pada setiap indeks dikira; Anggapkan jawapannya - 1 Nilai ini hanya akan meningkat; y ialah panjang urutan UD terpanjang bermula pada i; Jika panjangnya, tambah integer dan kemudian urutan du bermula pada i + y; Jika panjang ganjil maka tambah integer dan kemudian urutan ud bermula pada i + y; Kod pemacu", "code": "function f ( i , state , A , dp , N ) { if ( i >= N ) return 0 ; else if ( dp [ i ] [ state ] != - 1 ) { return dp [ i ] [ state ] ; } else { if ( i == N - 1 ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] > A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 2 && A [ i ] < A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] <= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) ; else if ( state == 2 && A [ i ] >= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) ; return dp [ i ] [ state ] ; } } function maxLenSeq ( A , N ) { let i , j , tmp , y , ans ; let dp = new Array ( 1000 ) ; for ( i = 0 ; i < 1000 ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( i = 0 ; i < N ; i ++ ) { tmp = f ( i , 1 , A , dp , N ) ; tmp = f ( i , 2 , A , dp , N ) ; } ans = - 1 ; for ( i = 0 ; i < N ; i ++ ) { y = dp [ i ] [ 1 ] ; if ( i + y >= N ) ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 ) ; else if ( y % 2 == 0 ) { ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) ; } else if ( y % 2 == 1 ) { ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) ; } } return ans ; } let A = [ 1 , 10 , 3 , 20 , 25 , 24 ] ; let n = A . length ; document . write ( maxLenSeq ( A , n ) ) ;"}
{"text": "Keluarkan elemen untuk memaksimumkan GCD array yang diberikan | Fungsi rekursif untuk mengembalikan GCD A dan B; Berfungsi untuk mengembalikan GCD yang dimaksimumkan selepas mengeluarkan satu elemen dari array yang diberikan; Awalan dan akhiran tatasusunan; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan GCD unsur -unsur pertama saya dari kiri dalam awalan [i]; Memulakan array akhiran; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan GCD dari semua elemen yang mempunyai lebih besar daripada atau sama dengan saya dalam akhiran [i]; Jika elemen pertama atau terakhir array perlu dikeluarkan; Jika elemen lain diganti; Mengembalikan GCD yang dimaksimumkan; Kod pemacu", "code": "function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } function MaxGCD ( a , n ) { let Prefix = new Array ( n + 2 ) ; let Suffix = new Array ( n + 2 ) ; Prefix [ 1 ] = a [ 0 ] ; for ( let i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( let i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } let ans = Math . max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( let i = 2 ; i < n ; i += 1 ) { ans = Math . max ( ans , gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } let a = [ 14 , 17 , 28 , 70 ] ; let n = a . length ; document . write ( MaxGCD ( a , n ) ) ;"}
{"text": "SUM MAXIMUM SUMBER DENGAN MENGURANGKAN TANDA PALING PADA ELEMENT ARAY KEDUA | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mencari jumlah subarray maksimum dengan flip bermula dari indeks I; Jika bilangan flip telah melebihi; Traversal lengkap; Sekiranya negara sebelum ini telah dikunjungi; Pada mulanya; Gunakan algoritma Kadane dan hubungi dua negeri; Memoize jawapan dan mengembalikannya; Fungsi utiliti untuk memanggil flips dari indeks dan mengembalikan jawapannya; Buat array dp int dp [n, k + 1]; ; ITERATE dan CALL FUNGSI RECURSIF DARI SETIAP INDEX UNTUK MEMBERI JUMLAH SUBARRAY MAXIMUM; kes sudut; Kod pemacu", "code": "let right = 2 ; let left = 4 ; let dp = new Array ( left ) ; function findSubarraySum ( ind , flips , n , a , k ) { if ( flips > k ) return ( - 1e9 ) ; if ( ind == n ) return 0 ; if ( dp [ ind ] [ flips ] != - 1 ) return dp [ ind ] [ flips ] ; let ans = 0 ; ans = Math . max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; ans = Math . max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; return dp [ ind ] [ flips ] = ans ; } function findMaxSubarraySum ( a , n , k ) { for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( k ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } let ans = ( - 1e9 ) ; for ( let i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; if ( ans == 0 && k == 0 ) { let max = Number . MIN_VALUE ; for ( let i = 0 ; i < a . length ; i ++ ) { max = Math . max ( max , a [ i ] ) ; } return max ; } return ans ; } let a = [ - 1 , - 2 , - 100 , - 10 ] ; let n = a . length ; let k = 1 ; document . write ( findMaxSubarraySum ( a , n , k ) ) ;"}
{"text": "Cari Jumlah Nombor Fibonacci Pertama N yang pertama | Program JavaScript untuk mencari jumlah nombor Fibonacci yang pertama; Fungsi untuk mengira jumlah nombor Fibonacci yang pertama; nilai asas; Kod pemacu", "code": "var mod = 1000000007 ; function sumOddFibonacci ( n ) { var Sum = Array ( n + 1 ) . fill ( 0 ) ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; } var n = 6 ; document . write ( sumOddFibonacci ( n ) ) ;"}
{"text": "Kurangkan jumlah teddies untuk diedarkan | Pelaksanaan JavaScript pendekatan di atas; Memulakan satu tablet untuk setiap pelajar; Jika dibiarkan bersebelahan mempunyai kajian markah yang lebih tinggi dan mengubah semua nilai DP yang diberikan sebelum sehingga nilai DP yang diberikan didapati salah mengikut kekangan yang diberikan; Jika betul bersebelahan mempunyai markah yang lebih tinggi, tambahkan satu di dp kiri bersebelahan dan berikan ke kanan; n bilangan pelajar; tanda pelajar; penyelesaian masalah", "code": "function fun ( marks , n ) { let dp = new Array ( n ) ; let temp ; for ( let i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; } let n = 6 ; let marks = [ 1 , 4 , 5 , 2 , 2 , 1 ] ; document . write ( fun ( marks , n ) ) ;"}
{"text": "Bilangan cara untuk mencapai lantai nth dengan mengambil di | Program JavaScript untuk mencapai tangga dengan mengambil maksimum l leap; Unsur -unsur kombo [] menyimpan no. cara yang mungkin untuk mencapainya dengan semua kombinasi K Leaps atau kurang; Dengan mengandaikan lompatan 0 wujud dan memberikan nilainya kepada 1 untuk pengiraan; gelung untuk melangkah ke atas semua kemungkinan melompat sehingga K; ; Dalam gelung ini kita mengira semua kemungkinan lompatan untuk mencapai tangga jth dengan bantuan lompatan atau kurang; Jika lompatan itu tidak lebih daripada i - j; Kirakan nilai dan simpan dalam combo [j] untuk menggunakannya semula untuk pengiraan lompatan seterusnya untuk tangga jth; Mengembalikan tidak ada kemungkinan lompatan untuk mencapai bahagian atas bangunan n tangga; N i tangga total k adalah nilai lompatan terbesar", "code": "function solve ( N , K ) { let combo = new Array ( 50 ) ; combo . fill ( 0 ) ; combo [ 0 ] = 1 ; for ( let i = 1 ; i <= K ; i ++ ) { for ( let j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; } let N = 29 ; let K = 5 ; document . write ( solve ( N , K ) ) ; solve ( N , K ) ;"}
{"text": "Cari yang paling lama meningkat seterusnya secara bulat | Kaedah utiliti untuk mencari LIS menggunakan pengaturcaraan dinamik; Memulakan nilai LIS untuk semua indeks; Kirakan nilai LIS yang dioptimumkan dengan cara bawah; Tetapkan j berdasarkan tetingkap semasa i. e. elemen pertama tetingkap semasa; Pilih maksimum semua nilai LIS; Berfungsi untuk mencari peningkatan yang paling lama dalam cara bulat; Buat salinan Array yang diberikan dengan memasuki elemen array yang sama kepada dirinya sendiri; Lakukan lis untuk setiap tetingkap saiz n; Kod pemacu", "code": "function computeLIS ( circBuff , start , end , n ) { let LIS = new Array ( n + end - start ) ; for ( let i = start ; i < end ; i ++ ) LIS [ i ] = 1 ; for ( let i = start + 1 ; i < end ; i ++ ) for ( let j = start ; j < i ; j ++ ) if ( circBuff [ i ] > circBuff [ j ] && LIS [ i ] < LIS [ j ] + 1 ) LIS [ i ] = LIS [ j ] + 1 ; let res = Number . MIN_VALUE ; for ( let i = start ; i < end ; i ++ ) res = Math . max ( res , LIS [ i ] ) ; return res ; } function LICS ( arr , n ) { let circBuff = new Array ( 2 * n ) ; for ( let i = 0 ; i < n ; i ++ ) circBuff [ i ] = arr [ i ] ; for ( let i = n ; i < 2 * n ; i ++ ) circBuff [ i ] = arr [ i - n ] ; let res = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( computeLIS ( circBuff , i , i + n , n ) , res ) ; return res ; } let arr = [ 1 , 4 , 6 , 2 , 3 ] ; document . write ( \" \" + LICS ( arr , arr . length ) ) ;"}
{"text": "Mengira laluan dari titik untuk mencapai asal | utiliti min; Fungsi untuk pekali binomial; Membina segitiga Pascal; Kod pemacu", "code": "function min ( a , b ) { return a < b ? a : b ; } function binomialCoeff ( n , k ) { var C = Array ( k + 1 ) . fill ( 0 ) ; C [ 0 ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } var n = 3 , m = 2 ; document . write ( \" \" + binomialCoeff ( n + m , n ) ) ;"}
{"text": "Susunan peningkatan yang paling lama (LCS + LIS) | Mengembalikan panjang dan LCIS dua array ARR1 [0. n - 1] dan arr2 [0 .. m - 1]; Jadual [J] akan menyimpan panjang LCI yang berakhir dengan ARR2 [J]. Kami memulakannya sebagai 0 ,; Melintasi semua elemen ARR1 []; Memulakan panjang semasa LCI; Untuk setiap elemen arr1 [], trvars semua elemen ARR2 []. ; Jika kedua -dua array mempunyai elemen yang sama. Perhatikan bahawa kami tidak memecahkan gelung di sini. ; Sekarang cari elemen umum yang lebih kecil sebelumnya untuk elemen semasa ARR1; Nilai maksimum dalam Jadual [] adalah hasil; Kod pemacu", "code": "function LCIS ( arr1 , n , arr2 , m ) { let table = [ ] ; for ( let j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let current = 0 ; for ( let j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } let result = 0 ; for ( let i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; } let arr1 = [ 3 , 4 , 9 , 1 ] ; let arr2 = [ 5 , 3 , 8 , 9 , 10 , 2 , 1 ] ; let n = arr1 . length ; let m = arr2 . length ; document . write ( \" \" + LCIS ( arr1 , n , arr2 , m ) ) ;"}
{"text": "Panjang awalan biasa terpanjang mungkin dengan menyusun semula rentetan dalam array yang diberikan | Berfungsi untuk mendapatkan panjang awalan biasa terpanjang dengan menyusun semula rentetan; freq [i] [j]: Menyimpan kekerapan aksara (= j) dalam rentetan arr [i]; Melintasi array yang diberikan; Kedai panjang rentetan semasa; Melintasi rentetan arus array yang diberikan; Kemas kini nilai freq [i] [arr [i] [j]]; Menyimpan panjang awalan biasa terpanjang; Kira kekerapan minimum setiap aksara dalam semua rentetan arr []; Kedai nilai minimum dalam setiap baris freq [] []; Kirakan kekerapan minimum aksara semasa dalam semua rentetan. ; Kemas kini Minrowval; Kemas kini Maxlen; Kod pemacu", "code": "function longComPre ( arr , N ) { let freq = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { freq [ i ] = new Array ( 256 ) ; for ( let j = 0 ; j < 256 ; j ++ ) { freq [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) { let M = arr [ i ] . length ; for ( let j = 0 ; j < M ; j ++ ) { freq [ i ] [ arr [ i ] [ j ] . charCodeAt ( 0 ) ] ++ ; } } let maxLen = 0 ; for ( let j = 0 ; j < 256 ; j ++ ) { let minRowVal = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { minRowVal = Math . min ( minRowVal , freq [ i ] [ j ] ) ; } maxLen += minRowVal ; } return maxLen ; } let arr = [ \" \" , \" \" , \" \" ] ; let N = 3 ; document . write ( longComPre ( arr , N ) ) ;"}
{"text": "Keluarkan aksara dari rentetan yang kelihatan tepat k kali | Program JavaScript untuk menghapuskan aksara dari rentetan yang muncul tepat kali K; Berfungsi untuk mengurangkan rentetan dengan mengeluarkan aksara yang kelihatan tepat K kali; Jadual Hash diasaskan kepada 0; Meningkatkan kekerapan watak; Untuk menyimpan jawapan; Indeks seterusnya dalam rentetan yang dikurangkan; Tambah watak -watak yang kelihatan tepat K kali; Kod pemacu; Panggilan fungsi", "code": "let MAX_CHAR = 26 ; function removeChars ( arr , k ) { let hash = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; let n = arr . length ; for ( let i = 0 ; i < n ; ++ i ) hash [ arr [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; let ans = \" \" ; for ( let i = 0 ; i < n ; ++ i ) { if ( hash [ arr [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] != k ) { ans += arr [ i ] ; } } return ans ; } let str = \" \" . split ( ' ' ) ; let k = 2 ; document . write ( removeChars ( str , k ) ) ;"}
{"text": "Subsegments bersebelahan rentetan yang mempunyai aksara berikutnya yang berbeza | Fungsi yang mencetak segmen; Arahan baru untuk setiap lelaran; Periksa sama ada watak itu dalam array; Kod pemacu", "code": "function sub_segments ( str , n ) { let l = str . length ; for ( let x = 0 ; x < l ; x += n ) { let newlist = str . substr ( x , n ) ; let arr = [ ] ; for ( let y of newlist ) { if ( ! arr . includes ( y ) ) arr . push ( y ) ; } for ( let y of arr ) document . write ( y ) ; document . write ( \" \" ) ; } } let str = \" \" ; let n = 4 ; sub_segments ( str , n ) ;"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; panjang rentetan pertama; panjang rentetan kedua; Jika panjang tidak sama hanya kembali palsu kerana kedua -dua rentetan tidak boleh sama jika panjang tidak sama; gelung untuk memadankan satu demi satu semua watak kedua -dua rentetan; Jika aksara semasa kedua -dua rentetan adalah sama, tambah nilai saya untuk membandingkan watak seterusnya; Jika mana -mana watak rentetan pertama adalah beberapa watak khas atau aksara angka dan tidak sama dengan watak yang sama rentetan kedua kemudian kembali palsu; Lakukan perkara yang sama untuk rentetan kedua; Blok kod ini akan dilaksanakan jika watak -watak kedua -dua rentetan adalah kes yang berbeza; Bandingkan watak dengan nilai ASCII; Jika watak dipadankan, tingkatkan nilai saya untuk membandingkan char seterusnya; Jika semua aksara rentetan pertama dipadankan dengan aksara yang sepadan dengan rentetan kedua, maka kembali benar; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "function equalIgnoreCase ( str1 , str2 ) { let i = 0 ; let len1 = str1 . length ; let len2 = str2 . length ; if ( len1 != len2 ) return false ; while ( i < len1 ) { if ( str1 [ i ] == str2 [ i ] ) { i ++ ; } else if ( ! ( ( str1 [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) || ( str1 [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) ) ) { return false ; } else if ( ! ( ( str2 [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str2 [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) || ( str2 [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str2 [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) ) ) { return false ; } else { if ( str1 [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) { if ( str1 [ i ] . charCodeAt ( ) - 32 != str2 [ i ] . charCodeAt ( ) ) return false ; } else if ( str1 [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) { if ( str1 [ i ] . charCodeAt ( ) + 32 != str2 [ i ] . charCodeAt ( ) ) return false ; } i ++ ; return true ; function equalIgnoreCaseUtil ( str1 , str2 ) { let res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ; } let str1 , str2 ; str1 = \" \" ; str2 = \" \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" \" ; str2 = \" \" ; equalIgnoreCaseUtil ( str1 , str2 ) ;"}
{"text": "Memaksimumkan nilai A dengan menggantikan beberapa digitnya dengan digit B | Berfungsi untuk mengembalikan nilai yang dimaksimumkan A; Jenis digit dalam urutan menaik; J menunjuk kepada digit terbesar di B; Jika semua digit B telah digunakan; Digit semasa telah digunakan; Mengembalikan nilai yang dimaksimumkan; Kod pemacu", "code": "function maxValue ( a , b ) { b . sort ( function ( x , y ) { return x - y ; } ) ; let n = a . length ; let m = b . length ; let j = m - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return ( a ) . join ( \" \" ) ; } let a = \" \" ; let b = \" \" ; document . write ( maxValue ( a . split ( \" \" ) , b . split ( \" \" ) ) ) ;"}
{"text": "Mengira nombor dalam julat supaya digit di dalamnya dan produknya dengan Q tidak sama rata | Berfungsi untuk memeriksa sama ada semua digit dalam nombor dan produknya dengan Q tidak sama atau tidak; Tukar nombor pertama ke dalam rentetan; Masukkan elemen dari nombor 1 ke hash; Hitung produk yang sepadan; Tukar produk ke rentetan; Menggunakan Hash Check jika mana -mana digit padanan produk dengan digit nombor input; Jika ya, kembali palsu; lain, kembali benar; Berfungsi untuk mengira nombor dalam julat [l, r] supaya semua digit nombor dan produknya dengan Q tidak sama rata; Semak setiap nombor antara L dan R; Kod pemacu; Panggilan fungsi", "code": "function checkIfUnequal ( n , q ) { let s1 = n . toString ( ) ; let a = new Array ( 26 ) ; for ( let i = 0 ; i < a . length ; i ++ ) { a [ i ] = 0 ; } for ( let i = 0 ; i < s1 . length ; i ++ ) a [ s1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; let prod = n * q ; let s2 = prod . toString ( ) ; for ( let i = 0 ; i < s2 . length ; i ++ ) { if ( a [ s2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] > 0 ) return false ; } return true ; } function countInRange ( l , r , q ) { let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( checkIfUnequal ( i , q ) ) count ++ ; } return count ; } let l = 10 , r = 12 , q = 2 ; document . write ( countInRange ( l , r , q ) ) ;"}
{"text": "Semak sama ada mungkin untuk menyusun semula rentetan binari dengan alternatif 0 s dan 1 s | berfungsi untuk memeriksa rentetan binari; panjang rentetan; Count Zero; Kira satu 's; jika panjangnya; Sekiranya panjangnya ganjil", "code": "function is_possible ( s ) { let l = s . length ; let one = 0 , zero = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( s [ i ] == ' ' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . abs ( one - zero ) == 1 ) ; } let s = \" \" ; if ( is_possible ( s ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program JavaScript untuk mengira frekuensi item array; Buat array untuk menyimpan tuduhan. Saiz array adalah had + 1 dan semua nilai pada mulanya 0; Melintasi aksara rentetan dan mengira frekuensi; Kod pemacu", "code": "let limit = 255 ; function countFreq ( str ) { let count = new Array ( limit + 1 ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < str . length ; i ++ ) count [ str [ i ] . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i <= limit ; i ++ ) { if ( count [ i ] > 0 ) document . write ( String . fromCharCode ( i ) + \" \" + count [ i ] + \" \" ) ; } } let str = \" \" ; countFreq ( str ) ;"}
{"text": "Kira bit set Even dan Odd dengan elemen array selepas xor dengan k | Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Berfungsi untuk menyimpan pemboleh ubah yang walaupun dan ganjil; Simpan kiraan bit set walaupun dan ganjil; Kira set bit menggunakan dalam fungsi terbina; Count set - bit k; Jika y adalah ganjil, kiraan bit set walaupun dan ganjil akan ditukar; Lain ia akan tetap sama dengan array asal; Kod pemandu; Fungsi panggilan untuk mengira walaupun dan ganjil", "code": "function __builtin_popcount ( n ) { let count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } function countEvenOdd ( arr , n , K ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } let y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { document . write ( \" \" + odd + \" \" + even ) ; } else { document . write ( \" \" + even + \" \" + odd ) ; } } let arr = [ 4 , 2 , 15 , 9 , 8 , 8 ] ; let K = 3 ; let n = arr . length ; countEvenOdd ( arr , n , K ) ;"}
{"text": "Google Case Of A Sentyen tertentu | Berfungsi untuk mengeluarkan ruang dan menukar ke dalam kes unta; Semak ruang dalam ayat; penukaran ke atas kes; Jika tidak ruang, salin watak; kembali rentetan ke Main; Kod pemacu", "code": "function convert ( s ) { var n = s . length ; var s1 = \" \" ; s1 = s1 + s . charAt ( 0 ) . toLowerCase ( ) ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ' && i < n ) { s1 = s1 + \" \" + s . charAt ( i + 1 ) . toLowerCase ( ) ; i ++ ; } else s1 = s1 + s . charAt ( i ) . toUpperCase ( ) ; } return s1 ; } var str = \" \" ; document . write ( convert ( str ) ) ;"}
{"text": "Nombor TCEFREP | Fungsi berulang untuk membalikkan digit NUM; Fungsi untuk mengira jumlah semua pembahagi yang betul Num -> diberi nombor semulajadi; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Diberi nombor n; Panggilan fungsi", "code": "function reverse ( num ) { let rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = parseInt ( num / 10 ) ; } return rev_num ; } function properDivSum ( num ) { let result = 0 ; for ( i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } function isTcefrep ( n ) { return properDivSum ( n ) == reverse ( n ) ; } let N = 6 ; if ( isTcefrep ( N ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Program untuk mencari n | Program JavaScript untuk mencari nombor n - th yang mengandungi hanya 3 dan 5 .; Jika n adalah ganjil, tambah 3 dan pindah ke ibu bapa; Jika n adalah, tambah 5 dan pindah ke ibu bapa; Reverse Res dan kembali. ; Kod pemacu", "code": "function reverseString ( str ) { return str . split ( \" \" ) . reverse ( ) . join ( \" \" ) ; } function findNthNo ( n ) { let res = \" \" ; while ( n >= 1 ) { if ( ( n & 1 ) == 1 ) { res = res + \" \" ; n = ( n - 1 ) / 2 ; } else { res = res + \" \" ; n = ( n - 2 ) / 2 ; } } sb = ( res ) ; sb = reverseString ( sb ) ; return ( sb ) ; } let n = 5 ; document . write ( findNthNo ( n ) ) ;"}
{"text": "Nth non | Berfungsi untuk mencari nombor non non - persegi; Penukaran dari var ke var var diperlukan untuk memelihara tempat perpuluhan selepas akar persegi. ; Mengira hasilnya; Memulakan nombor jangka panjang; Cetak hasilnya", "code": "function findNthNonSquare ( n ) { var x = n ; var ans = x + Math . floor ( 0.5 + Math . sqrt ( x ) ) ; return parseInt ( ans ) ; } var n = 16 ; document . write ( \" \" + n + \" \" ) ; document . write ( findNthNonSquare ( n ) ) ;"}
{"text": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | fungsi untuk mengira jumlah siri; Kod pemacu", "code": "function seiresSum ( n , a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; } let n = 2 ; a = [ 1 , 2 , 3 , 4 ] ; document . write ( seiresSum ( n , a ) ) ;"}
{"text": "Cari nombor n yang mengandungi digit k atau dibahagikan dengan k. | Fungsi untuk memeriksa jika digit k berada dalam n atau tidak; mencari selebihnya; jika digit dijumpai; Fungsi untuk mencari nombor nth; Oleh kerana k adalah yang pertama yang memenuhi kriteria, jadi pertimbangkannya dalam kiraan membuat kiraan = 1 dan bermula dari i = k + 1; Memeriksa bahawa nombor itu mengandungi k digit atau dibahagikan oleh k; Kod pemacu", "code": "function checkdigit ( n , k ) { while ( n != 0 ) { let rem = n % 10 ; if ( rem == k ) return true ; n = n / 10 ; } return false ; } function findNthNumber ( n , k ) { for ( let i = k + 1 , count = 1 ; count < n ; i ++ ) { if ( checkdigit ( i , k ) || ( i % k == 0 ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; } let n = 10 , k = 2 ; document . write ( findNthNumber ( n , k ) ) ;"}
{"text": "Count subarrays saiz K yang merupakan permutasi nombor dari 1 hingga k | Pelaksanaan JavaScript; Simpan indeks nombor array; Kemas kini indeks min dan max dengan indeks semasa dan periksa sama ada ia adalah permutasi yang sah; Kod pemacu", "code": "function find_permutations ( arr ) { var cnt = 0 ; var max_ind = - 1 , min_ind = 10000000 ; var n = arr . length ; var index_of = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { index_of . set ( arr [ i ] , i + 1 ) ; } for ( var i = 1 ; i <= n ; i ++ ) { max_ind = Math . max ( max_ind , index_of . get ( i ) ) ; min_ind = Math . min ( min_ind , index_of . get ( i ) ) ; if ( max_ind - min_ind + 1 == i ) cnt ++ ; } return cnt ; } var nums = [ ] ; nums . push ( 2 ) ; nums . push ( 3 ) ; nums . push ( 1 ) ; nums . push ( 5 ) ; nums . push ( 4 ) ; document . write ( find_permutations ( nums ) ) ;"}
{"text": "Count of integer yang membahagikan semua elemen array yang diberikan | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan kiraan bilangan bulat yang diperlukan; Untuk menyimpan GCD unsur -unsur array; Untuk menyimpan kiraan faktor GCD yang dijumpai; Jika G adalah persegi yang sempurna; Faktor muncul berpasangan; Kod pemacu", "code": "function calgcd ( a , b ) { if ( b == 0 ) return a ; return calgcd ( b , a % b ) ; } function getCount ( a , n ) { let gcd = 0 ; for ( let i = 0 ; i < n ; i ++ ) gcd = calgcd ( gcd , a [ i ] ) ; let cnt = 0 ; for ( let i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { if ( i * i == gcd ) cnt ++ ; else cnt += 2 ; } } return cnt ; } let a = [ 4 , 16 , 1024 , 48 ] ; let n = a . length ; document . write ( getCount ( a , n ) ) ;"}
{"text": "Kurangkan kos penyingkiran yang diperlukan untuk menjadikan semua watak yang tersisa dari rentetan unik | Berfungsi untuk mencari kos minimum untuk mengeluarkan aksara untuk membuat rentetan unik; menyimpan watak yang dikunjungi; menyimpan jawapannya; melintasi rentetan; jika sudah dikunjungi; Menyimpan kos maksimum untuk mengeluarkan watak tertentu; Simpan jumlah kos penghapusan watak tertentu; Tandakan watak semasa yang dikunjungi; Melintasi indeks rentetan [i, n - 1]; Jika ada pendua yang dijumpai; Mengemas kini kos maksimum dan jumlah kos; Tandakan watak semasa yang dikunjungi; Simpan watak dengan kos maksimum dan padamkan yang lain; mengembalikan kos minimum; rentetan input; Arahan input; panggilan fungsi", "code": "function delCost ( s , cost ) { var visited = Array ( s . length ) . fill ( false ) ; var ans = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( visited [ i ] ) { continue ; } var maxDel = 0 ; var totalCost = 0 ; visited [ i ] = true ; for ( j = i ; j < s . length ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { maxDel = Math . max ( maxDel , cost [ j ] ) ; totalCost += cost [ j ] ; visited [ j ] = true ; } } ans += totalCost - maxDel ; } return ans ; } var s = \" \" ; var cost = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; document . write ( delCost ( s , cost ) ) ;"}
{"text": "Buat semua elemen array sama dengan menggantikan tiga kali ganda dengan bitwise xor mereka | Fungsi untuk mencari tiga kali ganda yang menggantikannya dengan XOR mereka membuat semua elemen array sama; Jika n juga; Hitung XOR unsur array; Melintasi array; Kemas kini XOR; Jika XOR tidak sama dengan 0; Memilih triplet seperti unsur -unsur pasangan (arr [0], arr [1]), (arr [2], arr [3]). . . boleh dibuat sama; Memilih tiga kali ganda supaya semua elemen array boleh dibuat sama dengan arr [n - 1]; Memilih triplet seperti unsur -unsur pasangan (arr [0], arr [1]), (arr [2], arr [3]). . . boleh dibuat sama; Memilih tiga kali ganda supaya semua elemen array boleh dibuat sama dengan arr [n - 1]; Diberikan array; Saiz array; Panggilan fungsi", "code": "function checkXOR ( arr , N ) { if ( N % 2 == 0 ) { let xro = 0 ; for ( let i = 0 ; i < N ; i ++ ) { xro ^= arr [ i ] ; } if ( xro != 0 ) { document . write ( - 1 + \" \" ) ; return ; } for ( let i = 0 ; i < N - 3 ; i += 2 ) { document . write ( i + \" \" + ( i + 1 ) + \" \" + ( i + 2 ) + \" \" ) ; } for ( let i = 0 ; i < N - 3 ; i += 2 ) { document . write ( i + \" \" + ( i + 1 ) + \" \" + ( N - 1 ) + \" \" ) ; } } else { for ( let i = 0 ; i < N - 2 ; i += 2 ) { document . write ( i + \" \" + ( i + 1 ) + \" \" + ( i + 2 ) + \" \" ) ; } for ( let i = 0 ; i < N - 2 ; i += 2 ) { document . write ( i + \" \" + ( i + 1 ) + \" \" + ( N - 1 ) + \" \" ) ; } } } let arr = [ 4 , 2 , 1 , 7 , 2 ] ; let N = arr . length ; checkXOR ( arr , N ) ;"}
{"text": "Buat semua elemen array walaupun dengan menggantikan sepasang elemen array bersebelahan dengan jumlah mereka | Fungsi untuk mencari kiraan minimum operasi yang diperlukan untuk membuat semua elemen array walaupun; Kedai minimum penggantian minimum untuk membuat semua elemen array walaupun; Menyimpan kiraan nombor berterusan ganjil; Melintasi array; Jika arr [i] adalah nombor ganjil; Kemas kini ODD_CONT_SEG; Jika odd_cont_seg adalah walaupun; Kemas kini res; Kemas kini res; Tetapkan semula ODD_CONT_SEG = 0; Jika odd_cont_seg melebihi 0; Jika odd_cont_seg adalah walaupun; Kemas kini res; Kemas kini res; Cetak hasilnya; Kod pemacu", "code": "function make_array_element_even ( arr , N ) { let res = 0 ; let odd_cont_seg = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += ( odd_cont_seg / 2 ) + 2 ; } odd_cont_seg = 0 ; } } } if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += odd_cont_seg / 2 + 2 ; } } return res ; } let arr = [ 2 , 4 , 5 , 11 , 6 ] ; let N = arr . length ; document . write ( make_array_element_even ( arr , N ) ) ;"}
{"text": "Cari nombor k sedemikian rupa sehingga betul -betul elemen array lebih besar daripada atau sama dengan k | Fungsi untuk mencari k yang mana terdapat unsur -unsur array yang lebih besar daripada atau sama dengan k; Mencari elemen array terbesar; Nilai kemungkinan k; Melintasi array; Jika elemen array semasa lebih besar daripada atau sama dengan i; Jika saya pelbagai elemen adalah lebih besar daripada atau sama dengan i; Jika tidak; Untuk mencari elemen maksimum; Kod pemacu", "code": "function zvalue ( nums ) { var m = max_element ( nums ) ; var cnt = 0 ; for ( i = 0 ; i <= m ; i ++ ) { cnt = 0 ; for ( j = 0 ; j < nums . length ; j ++ ) { if ( nums [ j ] >= i ) cnt ++ ; } if ( cnt == i ) return i ; } return - 1 ; } function max_element ( nums ) { var max = nums [ 0 ] ; for ( i = 1 ; i < nums . length ; i ++ ) max = Math . max ( max , nums [ i ] ) ; return max ; } nums = [ 7 , 8 , 9 , 0 , 0 , 1 ] ; document . write ( zvalue ( nums ) ) ;"}
{"text": "Anagrams lexicographically terkecil dan terbesar rentetan yang mengandungi rentetan lain sebagai substringnya | Berfungsi untuk mencari anagram terkecil rentetan yang mengandungi rentetan lain; Memulakan peta dan set; Melangkah ke atas S1; Menyimpan kekerapan aksara yang ada di S1; Menyimpan watak -watak yang berbeza dalam S1; Mengurangkan kekerapan aksara dari m yang sudah ada di S2; Melintasi abjad dalam urutan yang disusun; Jika watak semasa set tidak sama dengan watak semasa S2; Jika elemen sama dengan watak semasa S2; Memeriksa watak kedua yang berbeza dalam S2; S2 [J] akan menyimpan watak kedua yang berbeza; Kembalikan jawapannya; Berfungsi untuk mencari anagram leksikografi terbesar rentetan yang mengandungi rentetan lain; Mendapatkan anagram terkecil secara lexicographically; D1 menyimpan awalan; D2 menyimpan akhiran; Mengembalikan hasilnya; Diberikan dua rentetan; Panggilan fungsi", "code": "function lexico_smallest ( s1 , s2 ) { let M = new Map ( ) ; let S = new Set ( ) ; let pr ; for ( let i = 0 ; i <= s1 . length - 1 ; ++ i ) { if ( M . has ( s1 [ i ] ) ) { M [ s1 [ i ] ] ++ ; } else { M [ s1 [ i ] ] = 1 ; } S . add ( s1 [ i ] ) ; } for ( let i = 0 ; i <= s2 . length - 1 ; ++ i ) { if ( M . has ( s2 [ i ] ) ) { M [ s2 [ i ] ] -- ; } else { M [ s2 [ i ] ] = - 1 ; } } let c = s2 [ 0 ] ; let index = 0 ; let res = \" \" ; S . forEach ( function ( x ) { if ( x != c ) { for ( let i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } } else { let j = 0 ; index = res . length ; while ( s2 [ j ] == x ) { j ++ ; } if ( s2 [ j ] < c ) { res += s2 ; for ( let i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } } else { for ( let i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } index += M [ x ] ; res += s2 ; } } } ) res = \" \" ; pr = [ res , index ] ; return pr ; } function lexico_largest ( s1 , s2 ) { let pr = lexico_smallest ( s1 , s2 ) ; let d1 = \" \" ; for ( let i = pr [ 1 ] - 1 ; i >= 0 ; i -- ) { d1 += pr [ 0 ] [ i ] ; } let d2 = \" \" ; for ( let i = pr [ 0 ] . length - 1 ; i >= pr [ 1 ] + s2 . length ; -- i ) { d2 += pr [ 0 ] [ i ] ; } let res = d2 + s2 + d1 ; return res ; } let s1 = \" \" ; let s2 = \" \" ; document . write ( lexico_smallest ( s1 , s2 ) [ 0 ] + \" \" ) ; document . write ( lexico_largest ( s1 , s2 ) ) ;"}
{"text": "Pertanyaan untuk mencari kiraan laluan terpendek di dalam pokok yang mengandungi kelebihan yang diberikan | Pelaksanaan JavaScript untuk pendekatan di atas; Senarai Adjacency untuk mewakili pokok; Bilangan simpang; Mark yang melawat / tidak dapat Vertices; Menyimpan saiz subtree nod yang sepadan; Berfungsi untuk mewujudkan kelebihan antara dua simpul; Tambah senarai A ke B; Tambah B ke senarai A; Berfungsi untuk melaksanakan DFS; Tandakan puncak yang dikunjungi; Termasuk nod dalam subtree; Melintasi semua anaknya; Berfungsi untuk mencetak bilangan laluan yang diperlukan; Bilangan simpang; Memanggil fungsi DFS yang diubah suai; Kira pasangan simpang di pokok", "code": "var sz = 100005 ; var tree = Array . from ( Array ( sz ) , ( ) => Array ( ) ) var n ; var vis = Array ( sz ) ; var subtreeSize = Array ( sz ) ; function addEdge ( a , b ) { tree [ a ] . push ( b ) ; tree [ b ] . push ( a ) ; } function dfs ( x ) { vis [ x ] = true ; subtreeSize [ x ] = 1 ; tree [ x ] . forEach ( i => { if ( ! vis [ i ] ) { dfs ( i ) ; subtreeSize [ x ] += subtreeSize [ i ] ; } } ) ; } function countPairs ( a , b ) { var sub = Math . min ( subtreeSize [ a ] , subtreeSize [ b ] ) ; document . write ( sub * ( n - sub ) + \" \" ) ; } n = 6 ; addEdge ( 0 , 1 ) ; addEdge ( 0 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 3 , 4 ) ; addEdge ( 3 , 5 ) ; dfs ( 0 ) ; countPairs ( 1 , 3 ) ; countPairs ( 0 , 2 ) ;"}
{"text": "Kira permutasi array yang mempunyai setiap elemen sebagai pelbagai atau faktor indeksnya | Berfungsi untuk mencari kiraan permutasi yang dikehendaki; Kes asas; Jika saya belum dimasukkan; Backtrack; Masukkan i; Berulang untuk mencari permutasi yang sah; Keluarkan i; Mengembalikan kiraan akhir; Kod pemacu", "code": "function findPermutation ( arr , N ) { var pos = arr . size + 1 ; if ( pos > N ) return 1 ; var res = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( ! arr . has ( i ) ) { if ( i % pos == 0 pos % i == 0 ) { arr . add ( i ) ; res += findPermutation ( arr , N ) ; arr . delete ( i ) ; } } } return res ; } var N = 5 ; var arr = new Set ( ) ; document . write ( findPermutation ( arr , N ) ) ;"}
{"text": "Semak jika jumlah y boleh didapati dari array oleh operasi yang diberikan | Fungsi untuk memeriksa sama ada mungkin untuk mendapatkan jumlah y dari urutan jumlah x dari array arr []; Simpan perbezaan; Melangkah ke atas array; Jika diff dikurangkan kepada 0; Kod pemacu", "code": "function solve ( arr , n , X , Y ) { var diff = Y - X ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } var arr = [ 1 , 2 , 7 , 9 , 10 ] ; var n = arr . length ; var X = 11 , Y = 13 ; solve ( arr , n , X , Y ) ;"}
{"text": "Jarak paling jauh dari nod dari setiap nod pokok | Program JavaScript untuk melaksanakan pendekatan di atas; Senarai adjacency untuk menyimpan graf; Menyimpan ketinggian setiap nod; Menyimpan jarak maksimum nod dari nenek moyangnya; Berfungsi untuk menambah kelebihan antara dua simpang; Masukkan kelebihan dari u ke v; Masukkan tepi dari v ke u; Berfungsi untuk mengira ketinggian setiap nod; Melangkah dalam senarai addacency nod semasa; DFS untuk nod kanak -kanak; Hitung ketinggian nod; Meningkatkan ketinggian; Fungsi untuk mengira jarak maksimum nod dari nenek moyangnya; Melangkah dalam senarai addacency nod semasa; Cari dua kanak -kanak dengan ketinggian maksimum; Kirakan jarak maksimum dengan nenek moyang untuk setiap nod; Mengira untuk kanak -kanak; Kod pemacu; Hitung ketinggian nod pokok; Kirakan jarak maksimum dengan nenek moyang; Cetak maksimum dua jarak dari setiap nod", "code": "let maxN = 100001 ; let adj = new Array ( maxN ) ; adj . fill ( 0 ) ; let height = new Array ( maxN ) ; height . fill ( 0 ) ; let dist = new Array ( maxN ) ; dist . fill ( 0 ) ; function addEdge ( u , v ) { adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; } function dfs1 ( cur , par ) { for ( let u = 0 ; u < adj [ cur ] . length ; u ++ ) { if ( adj [ cur ] [ u ] != par ) { dfs1 ( adj [ cur ] [ u ] , cur ) ; height [ cur ] = Math . max ( height [ cur ] , height [ adj [ cur ] [ u ] ] ) ; } } height [ cur ] += 1 ; } function dfs2 ( cur , par ) { let max1 = 0 ; let max2 = 0 ; for ( let u = 0 ; u < adj [ cur ] . length ; u ++ ) { if ( adj [ cur ] [ u ] != par ) { if ( height [ adj [ cur ] [ u ] ] >= max1 ) { max2 = max1 ; max1 = height [ adj [ cur ] [ u ] ] ; } else if ( height [ adj [ cur ] [ u ] ] > max2 ) { max2 = height [ adj [ cur ] [ u ] ] ; } } } let sum = 0 ; for ( let u = 0 ; u < adj [ cur ] . length ; u ++ ) { if ( adj [ cur ] [ u ] != par ) { sum = ( ( max1 == height [ adj [ cur ] [ u ] ] ) ? max2 : max1 ) ; if ( max1 == height [ adj [ cur ] [ u ] ] ) dist [ adj [ cur ] [ u ] ] = 1 + Math . max ( 1 + max2 , dist [ cur ] ) ; else dist [ adj [ cur ] [ u ] ] = 1 + Math . max ( 1 + max1 , dist [ cur ] ) ; dfs2 ( adj [ cur ] [ u ] , cur ) ; } } } let n = 6 ; for ( let i = 0 ; i < adj . length ; i ++ ) adj [ i ] = [ ] ; addEdge ( 1 , 2 ) ; addEdge ( 2 , 3 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 5 , 6 ) ; dfs1 ( 1 , 0 ) ; dfs2 ( 1 , 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) document . write ( ( Math . max ( dist [ i ] , height [ i ] ) - 1 ) + \" \" ) ;"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Program JavaScript untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; Memeriksa B; Memeriksa A; kod pemacu", "code": "function middleOfThree ( a , b , c ) { function middleOfThree ( $a , $b , $c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; } let a = 20 , b = 30 , c = 40 ; document . write ( middleOfThree ( a , b , c ) ) ;"}
{"text": "Perbezaan antara jenis penyisipan dan pilihan pemilihan | Berfungsi untuk melaksanakan jenis pemilihan; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Tukar elemen minimum yang dijumpai dengan elemen pertama; Berfungsi untuk mencetak array; Kod pemacu; Panggilan fungsi; Cetak array", "code": "function selectionSort ( arr , n ) { let i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; let temp = arr [ min_idx ] ; arr [ min_idx ] = arr [ i ] ; arr [ i ] = temp ; } } function printArray ( arr , size ) { let i ; for ( i = 0 ; i < size ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; } document . write ( \" \" ) ; } let arr = [ 64 , 25 , 12 , 22 , 11 ] ; let n = arr . length ; selectionSort ( arr , n ) ; document . write ( \" \" ) ; printArray ( arr , n ) ;"}
{"text": "Semak jika rentetan yang diberikan boleh ditukar kepada yang lain dengan diberikan swap yang mungkin | Program JavaScript untuk melaksanakan pendekatan di atas; Kedai panjang str1; Kedai panjang str2; Kedai watak -watak yang berbeza dari STR1; Kedai watak -watak yang berbeza dari STR2; Kedai kekerapan setiap watak Str1; Traverse string str1; Kemas kini kekerapan str1 [i]; Traverse string str1; Masukkan str1 [i] ke st1; Traverse string str2; Masukkan str1 [i] ke st1; Jika watak yang berbeza dalam str1 dan str2 tidak sama; Kedai kekerapan setiap watak Str2; Traverse string str2; Kemas kini kekerapan STR2 [i]; Sort hash1 [] array; Susun Hash2 [] array; Traverse Hash1 [] dan Hash2 []; Jika Hash1 [i] tidak sama dengan Hash2 [i]; Kod pemacu", "code": "function checkStr1CanConStr2 ( str1 , str2 ) { var N = str1 . length ; var M = str2 . length ; var st1 = new Set ( ) ; var st2 = new Set ( ) ; var hash1 = Array ( 256 ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { hash1 [ str1 [ i ] . charCodeAt ( 0 ) ] ++ ; } for ( var i = 0 ; i < N ; i ++ ) { st1 . add ( str1 [ i ] ) ; } for ( var i = 0 ; i < M ; i ++ ) { st2 . add ( str2 [ i ] ) ; } if ( st1 . size != st2 . size ) { return false ; } var hash2 = Array ( 256 ) . fill ( 0 ) ; for ( var i = 0 ; i < M ; i ++ ) { hash2 [ str2 [ i ] . charCodeAt ( 0 ) ] ++ ; } hash1 . sort ( ( a , b ) => a - b ) ; hash2 . sort ( ( a , b ) => a - b ) ; for ( var i = 0 ; i < 256 ; i ++ ) { if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; } var str1 = \" \" ; var str2 = \" \" ; if ( checkStr1CanConStr2 ( str1 , str2 ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Susun array dalam julat indeks yang diberikan | Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Susun subarray dari arr [l] ke arr [r]. sort (arr, l, r + 1); ; Prvar array yang diubah suai; Kod pemacu", "code": "function swap ( arr , xp , yp ) { var temp = arr [ xp ] ; arr [ xp ] = arr [ yp ] ; arr [ yp ] = temp ; } function partSort ( arr , N , a , b ) { var l = Math . min ( a , b ) ; var r = Math . max ( a , b ) ; var i , j ; for ( i = l ; i < r + 1 + 1 ; i ++ ) { for ( j = l ; j < r - i + 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( arr , j , j + 1 ) ; } } } for ( i = 0 ; i < N ; i ++ ) document . write ( arr [ i ] + \" \" ) ; } var arr = [ 7 , 8 , 4 , 5 , 2 ] ; var a = 1 , b = 4 ; var N = arr . length ; partSort ( arr , N , a , b ) ;"}
{"text": "Cari kos minimum untuk mencapai destinasi menggunakan kereta api | Penyelesaian berasaskan pengaturcaraan dinamik untuk mencari kos min untuk mencapai stesen n - 1 dari stesen 0 .; Fungsi rekursif untuk mencari jalan terpendek dari sumber 'S' ke destinasi 'd'. Fungsi ini mengembalikan kos yang paling kecil untuk mencapai stesen n - 1 dari stesen 0 .; Dist [i] menyimpan kos minimum untuk mencapai stesen I dari stesen 0 .; Pergi melalui setiap stesen dan periksa jika menggunakannya sebagai stesen perantaraan memberikan jalan yang lebih baik; Program pemacu untuk menguji fungsi di atas", "code": "let INF = Number . MAX_VALUE , N = 4 ; function minCost ( cost ) { let dist = new Array ( N ) ; dist . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; } let cost = [ [ 0 , 15 , 80 , 90 ] , [ INF , 0 , 40 , 50 ] , [ INF , INF , 0 , 70 ] , [ INF , INF , INF , 0 ] ] ; document . write ( \" \" + \" \" + N + \" \" + minCost ( cost ) ) ;"}
{"text": "Bilangan gelung saiz k bermula dari nod tertentu | Kembalikan bilangan cara dari nod untuk membuat gelung saiz K dalam graf nod yang tidak disambungkan lengkap; Kod pemacu", "code": "function numOfways ( n , k ) { let p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; } let n = 4 , k = 2 ; document . write ( numOfways ( n , k ) ) ;"}
{"text": "Program untuk mencari watak bernilai ASCII terbesar dan terkecil dalam rentetan | Fungsi yang mengembalikan abjad terbesar. ; memulakan abjad max ke 'a'; Cari abjad terbesar; kembali elemen terbesar; fungsi yang mengembalikan abjad terkecil; memulakan abjad terkecil kepada 'z'; Cari abjad terkecil; kembali abjad terkecil; Rentetan input; Mengira saiz rentetan; fungsi memanggil dan mencetak nilai yang dikembalikan", "code": "function largest_alphabet ( a , n ) { let max = ' ' ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] . charCodeAt ( ) > max . charCodeAt ( ) ) max = a [ i ] ; return max ; } function smallest_alphabet ( a , n ) { let min = ' ' ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] . charCodeAt ( ) < min . charCodeAt ( ) ) min = a [ i ] ; return min ; } let a = \" \" ; let size = a . length ; document . write ( \" \" ) ; document . write ( largest_alphabet ( a , size ) + \" \" ) ; document . write ( smallest_alphabet ( a , size ) ) ;"}
{"text": "Buat palindrome terbesar dengan menukar paling banyak k | Mengembalikan maksimum palindrome menggunakan perubahan k; Memulakan l dan r oleh hujung kiri dan paling kanan; Pertama cuba membuat tali palindrome; Menggantikan watak kiri dan kanan dengan maksimum kedua -duanya; Jika k adalah negatif maka kita tidak boleh membuat palindrome rentetan; Pada watak pertengahan, jika k> 0 kemudian ubahnya menjadi 9; Jika watak di LTH (sama seperti RTH) kurang daripada 9; Jika tiada seorang pun daripada mereka diubah dalam gelung sebelumnya maka tolak 2 dari k dan tukar kedua -duanya ke 9; Jika salah satu daripada mereka diubah dalam gelung sebelumnya maka tolak 1 dari k (1 lagi telah dikurangkan) dan menjadikannya 9; Kod pemacu untuk menguji kaedah di atas", "code": "function maximumPalinUsingKChanges ( str , k ) { let palin = str . split ( \" \" ) ; let ans = \" \" ; let l = 0 ; let r = str . length - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { palin [ l ] = palin [ r ] = String . fromCharCode ( Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) { return \" \" ; } l = 0 ; r = str . length - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) { palin [ l ] = ' ' ; } } if ( palin [ l ] < ' ' ) { if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ] == str [ r ] ) { k -= 2 ; palin [ l ] = palin [ r ] = ' ' ; } else if ( k >= 1 && ( palin [ l ] != str [ l ] palin [ r ] != str [ r ] ) ) { k -- ; palin [ l ] = palin [ r ] = ' ' ; } } l ++ ; r -- ; } for ( let i = 0 ; i < palin . length ; i ++ ) ans += palin [ i ] ; return ans ; } let str = \" \" ; let k = 3 ; document . write ( maximumPalinUsingKChanges ( str , k ) ) ;"}
{"text": "Kira tiga dengan bitwise dan sama dengan sifar | Berfungsi untuk mencari bilangan tiga kali ganda yang bitwise dan 0.; Menyimpan kiraan triplet yang mempunyai bitwise dan sama dengan 0; Kedai frekuensi semua yang mungkin [i] & a [j]; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Jika bitwise dan triplet adalah sifar, kenaikan CNT; Kembalikan bilangan tiga kali ganda yang bitwise dan 0 .; Arahan input; Panggilan fungsi", "code": "function countTriplets ( A ) { var cnt = 0 ; var tuples = new Map ( ) ; A . forEach ( a => { A . forEach ( b => { if ( tuples . has ( a & b ) ) tuples . set ( a & b , tuples . get ( a & b ) + 1 ) else tuples . set ( a & b , 1 ) } ) ; } ) ; A . forEach ( a => { tuples . forEach ( ( value , key ) => { if ( ( key & a ) == 0 ) cnt += value ; } ) ; } ) ; return cnt ; } var A = [ 2 , 1 , 3 ] ; document . write ( countTriplets ( A ) ) ;"}
{"text": "Kurangkan kiraan pasangan bersebelahan dengan pariti yang berbeza | Pelaksanaan JavaScript pendekatan di atas; Fungsi rekursif untuk mengira pasangan bersebelahan minimum dengan pariti yang berbeza; Jika semua nombor diletakkan; Jika penggantian tidak diperlukan; Jika penggantian diperlukan; mundur; mundur; Berfungsi untuk memaparkan bilangan minimum elemen bersebelahan dengan pariti yang berbeza; Simpan tidak ada nombor yang tidak ada dalam array; Simpan tiada nombor ganjil yang tidak terdapat dalam array; Memadam nombor exisiting; Simpan bukan nombor dan nombor ganjil; Kod pemacu", "code": "var min = 10000 ; function parity ( even , odd , v , i ) { if ( i == v . length even . length == 0 && odd . length == 0 ) { var count = 0 ; for ( var j = 0 ; j < v . length - 1 ; j ++ ) { if ( v [ j ] % 2 != v [ j + 1 ] % 2 ) count ++ ; } if ( count < min ) min = count ; return min ; } if ( v [ i ] != - 1 ) min = parity ( even , odd , v , i + 1 ) ; else { if ( even . length != 0 ) { var x = even . back ( ) ; even . pop ( ) ; v [ i ] = x ; min = parity ( even , odd , v , i + 1 ) ; even . push ( x ) ; } if ( odd . length != 0 ) { var x = odd [ odd . length - 1 ] ; odd . pop ( ) ; v [ i ] = x ; min = parity ( even , odd , v , i + 1 ) ; odd . push ( x ) ; } } return min ; } function minDiffParity ( v , n ) { var even = [ ] ; var odd = [ ] ; var m = new Map ( ) ; for ( var i = 1 ; i <= n ; i ++ ) m . set ( i , 1 ) ; for ( var i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] != - 1 ) m . delete ( v [ i ] ) ; } m . forEach ( ( value , key ) => { if ( i . first % 2 == 0 ) even . push ( key ) ; else odd . push ( key ) ; } ) ; min = parity ( even , odd , v , 0 ) ; document . write ( min ) ; } var n = 8 ; var v = [ 2 , 1 , 4 , - 1 , - 1 , 6 , - 1 , 8 ] ; minDiffParity ( v , n ) ;"}
{"text": "Cari triplet sedemikian rupa sehingga bilangan nod yang menghubungkan triplet ini adalah maksimum | Pelaksanaan JavaScript pendekatan; Untuk menyimpan nod yang diperlukan; Array induk untuk menjejaki semula nod; Arahan yang dikunjungi untuk mengelakkan DFS ke arah di garis pusat; Fungsi DFS untuk mencari startnode; Fungsi DFS untuk mencari endnode diameter dan mengekalkan array induk; Fungsi DFS untuk mencari nod akhir cawangan terpanjang ke diameter; Fungsi untuk mencari nod yang diperlukan; Untuk mencari node diameter; Untuk mencari nod akhir diameter; x adalah nod akhir diameter; Tandakan semua nod diameter menggunakan penjejakan belakang; Cari nod akhir cawangan terpanjang ke diameter; Kod pemacu", "code": "let MAX = 100005 ; let adjacent = [ ] ; let visited = new Array ( MAX ) ; let startnode , endnode , thirdnode ; let maxi = - 1 , N ; let parent = new Array ( MAX ) ; let vis = new Array ( MAX ) ; function dfs ( u , count ) { visited [ u ] = true ; let temp = 0 ; for ( let i = 0 ; i < adjacent [ u ] . length ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; startnode = u ; } } } function dfs1 ( u , count ) { visited [ u ] = true ; let temp = 0 ; for ( let i = 0 ; i < adjacent [ u ] . length ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; parent [ adjacent [ u ] [ i ] ] = u ; dfs1 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; endnode = u ; } } } function dfs2 ( u , count ) { visited [ u ] = true ; let temp = 0 ; for ( let i = 0 ; i < adjacent [ u ] . length ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] && ! vis [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs2 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; thirdnode = u ; } } } function findNodes ( ) { dfs ( 1 , 0 ) ; for ( let i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; maxi = - 1 ; dfs1 ( startnode , 0 ) ; for ( let i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; let x = endnode ; vis [ startnode ] = true ; while ( x != startnode ) { vis [ x ] = true ; x = parent [ x ] ; } maxi = - 1 ; for ( let i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] ) dfs2 ( i , 0 ) ; } } for ( let i = 0 ; i < MAX ; i ++ ) adjacent . push ( [ ] ) ; N = 4 ; adjacent [ 1 ] . push ( 2 ) ; adjacent [ 2 ] . push ( 1 ) ; adjacent [ 1 ] . push ( 3 ) ; adjacent [ 3 ] . push ( 1 ) ; adjacent [ 1 ] . push ( 4 ) ; adjacent [ 4 ] . push ( 1 ) ; findNodes ( ) ; document . write ( \" \" + startnode + \" \" + endnode + \" \" + thirdnode + \" \" ) ;"}
{"text": "Peratusan peningkatan jumlah sfera jika radius meningkat dengan peratusan tertentu | Program JavaScript untuk mencari kenaikan peratusan dalam jumlah sfera jika radius meningkat dengan peratusan tertentu; Kod pemacu", "code": "function newvol ( x ) { document . write ( \" \" + \" \" + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + \" \" ) ; } var x = 10 ; newvol ( x ) ;"}
{"text": "Panjang kord bulatan yang jejari dan sudutnya diselipkan di pusat oleh kord diberikan | Berfungsi untuk mencari panjang kord; Kod pemacu", "code": "function length_of_chord ( r , x ) { document . write ( \" \" + \" \" + 2 * r * Math . sin ( x * ( 3.14 / 180 ) ) + \" \" ) ; } let r = 4 , x = 63 ; length_of_chord ( r , x ) ;"}
{"text": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segitiga sama rata | Berfungsi untuk mencari kawasan dataran; A tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "function area ( a ) { if ( a < 0 ) return - 1 ; var area = Math . sqrt ( a ) / 6 ; return area ; } var a = 10 ; document . write ( area ( a ) . toFixed ( 6 ) ) ;"}
{"text": "Panjang batang terpanjang yang boleh dimuatkan ke dalam cuboid | Berfungsi untuk mencari panjang; Pembolehubah sementara untuk memegang hasil pertengahan; Panjang rod terpanjang dikira menggunakan fungsi akar persegi; Kod pemacu; Memanggil LongeStroDincuboid () berfungsi untuk mendapatkan panjang rod terpanjang", "code": "function longestRodInCuboid ( length , breadth , height ) { let result ; let temp ; temp = length * length + breadth * breadth + height * height ; result = Math . sqrt ( temp ) ; return result ; } let length = 12 , breadth = 9 , height = 8 ; document . write ( longestRodInCuboid ( length , breadth , height ) ) ;"}
{"text": "Semak sama ada titik tertentu terletak pada atau di dalam segi empat tepat | Set 3 | berfungsi untuk memeriksa sama ada titik tertentu terletak di dalam atau di segi empat tepat atau tidak; Kod pemacu", "code": "function LiesInsieRectangle ( a , b , x , y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; } let a = 7 , b = 2 , x = 4 , y = 5 ; if ( LiesInsieRectangle ( a , b , x , y ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | Kembalikan jumlah maksimum. ; untuk panjang; untuk keluasan; untuk ketinggian; Mengira isipadu maksimum. ; Kod pemacu", "code": "function maxvolume ( s ) { let maxvalue = 0 ; for ( let i = 1 ; i <= s - 2 ; i ++ ) { for ( let j = 1 ; j <= s - 1 ; j ++ ) { let k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; } let s = 8 ; document . write ( maxvolume ( s ) ) ;"}
{"text": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | Kembalikan jumlah maksimum. ; mencari panjang; mencari keluasan; Mencari ketinggian; Program yang didorong", "code": "function maxvolume ( s ) { let length = parseInt ( s / 3 ) ; s -= length ; let breadth = parseInt ( s / 2 ) ; let height = s - breadth ; return length * breadth * height ; } let s = 8 ; document . write ( maxvolume ( s ) ) ;"}
{"text": "Kawasan Hexagon | Fungsi untuk mengira kawasan segi enam. ; Panjang sisi", "code": "function hexagonArea ( s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; } let s = 4 ; document . write ( \" \" + hexagonArea ( s ) ) ;"}
{"text": "Bilangan maksimum kuadrat yang boleh dimuatkan dalam segitiga isosceles sudut kanan | fungsi untuk mencari dataran maksimum; kembali dalam O (1) dengan formula yang diperoleh; Program Pemandu", "code": "function maxSquare ( b , m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; a } let b = 10 , m = 2 ; document . write ( maxSquare ( b , m ) ) ;"}
{"text": "Semak jika segitiga yang betul mungkin dari kawasan tertentu dan hipotenus | Mencetak tiga sisi segitiga kanan dari kawasan tertentu dan hipotenus jika segitiga mungkin, cetakan lain - 1 .; Deskripsi persamaan; memohon formula persamaan linear untuk mencari kedua -dua akar; Kod pemacu", "code": "function findRightAngle ( A , H ) { let D = Math . pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { let root1 = ( H * H + Math . sqrt ( D ) ) / 2 ; let root2 = ( H * H - Math . sqrt ( D ) ) / 2 ; let a = Math . sqrt ( root1 ) ; let b = Math . sqrt ( root2 ) ; if ( b >= a ) document . write ( a + \" \" + b + \" \" + H + \" \" ) ; else document . write ( b + \" \" + a + \" \" + H + \" \" ) ; } else document . write ( \" \" ) ; } findRightAngle ( 6 , 5 ) ;"}
{"text": "Bilangan maksimum 2 x2 kotak yang boleh dimuatkan di dalam segitiga isosceles kanan | Program untuk mengira bilangan 2 x 2 kotak di segitiga isosceles yang betul; Mengeluarkan bahagian tambahan yang selalu kita perlukan; Kerana setiap persegi mempunyai asas panjang 2; Kod pemacu", "code": "function numberOfSquares ( base ) { base = ( base - 2 ) ; base = Math . floor ( base / 2 ) ; return base * ( base + 1 ) / 2 ; } let base = 8 ; document . write ( numberOfSquares ( base ) ) ;"}
{"text": "Bitwise atau bitwise dan semua yang mungkin bukan | Berfungsi untuk mencari bitwise atau bitwise dan semua subarray yang mungkin selepas melakukan setiap pertanyaan; Melintasi setiap pasangan pertanyaan; Menyimpan bitwise atau; Mengemas kini array; Cari bitwise atau array baru yang dikemas kini; Cetak Ans; Kod pemacu", "code": "function performQuery ( arr , Q ) { for ( let i = 0 ; i < Q . length ; i ++ ) { let or = 0 ; let x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( let j = 0 ; j < arr . length ; j ++ ) { or = or | arr [ j ] ; } document . write ( or + \" \" ) ; } } let arr = [ 1 , 2 , 3 ] ; let Q = [ [ 1 , 4 ] , [ 3 , 0 ] ] ; performQuery ( arr , Q ) ;"}
{"text": "Panjang terkecil nombor yang boleh dibahagi dengan k yang dibentuk dengan menggunakan d sahaja | Berfungsi untuk membentuk bilangan terkecil yang mungkin; Array untuk menandakan baki yang telah dikira sudah; Melangkah ke atas julat; Jika baki itu sudah dijumpai, kembali - 1; Kod pemacu", "code": "function smallest ( k , d ) { let cnt = 1 ; let m = d % k ; let v = new Array ( k ) . fill ( 0 ) ; v [ m ] = 1 ; while ( 1 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } return - 1 ; } let d = 1 ; let k = 41 ; document . write ( smallest ( k , d ) ) ;"}
{"text": "Grafik Cube Fibonacci | berfungsi untuk mencari nombor Fibonacci; fungsi untuk mencari bilangan simpang dalam graf kiub Fibonacci; kembali nombor fibonacci untuk f (n + 2); Program Pemandu", "code": "function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } function findVertices ( n ) { return fib ( n + 2 ) ; } var n = 3 ; document . write ( findVertices ( n ) ) ;"}
{"text": "Ubah suai array supaya array tidak mengandungi mana -mana pembahagi biasa selain 1 | Fungsi untuk memeriksa sama ada mungkin untuk mengubah suai array supaya tidak ada faktor yang sama antara elemen array kecuali 1; Menyimpan GCD array; Hitung GCD array; Jika pembahagi semasa lebih kecil daripada x; Bahagikan GCD oleh pembahagi semasa; Jika boleh; Prvar array yang diubah suai; Jika tidak; Mengira GCD; Diberikan array; Saiz array", "code": "function checkCommonDivisor ( arr , N , X ) { var G = 0 ; for ( i = 0 ; i < N ; i ++ ) { G = gcd ( G , arr [ i ] ) ; } var copy_G = G ; for ( divisor = 2 ; divisor <= X ; divisor ++ ) { while ( G % divisor == 0 ) { G = G / divisor ; } } if ( G <= X ) { document . write ( \" \" ) ; for ( i = 0 ; i < N ; i ++ ) document . write ( ( arr [ i ] / copy_G ) + \" \" ) ; document . write ( ) ; } else document . write ( \" \" ) ; } function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } var arr = [ 6 , 15 , 6 ] ; var X = 6 ; var N = arr . length ; checkCommonDivisor ( arr , N , X ) ;"}
{"text": "Program untuk mencetak corak lingkaran | Buat baris dan col untuk melintasi baris dan lajur; Pembolehubah untuk menentukan pergerakan r = kanan, l = kiri, d = ke bawah, u = atas; Array untuk matriks; Berikan nilai; suis - kes untuk menentukan indeks seterusnya; Jika betul, pergi ke kanan; Jika ditinggalkan, pergi ke kiri; Jika naik, naik; Jika turun, turun; Semak jika matriks telah mencapai sempadan array; Tambah saiz kiri untuk sempadan seterusnya; Jika 2 putaran telah dibuat, mengurangkan saiz yang ditinggalkan oleh 1; suis - kes untuk memutar pergerakan; Jika betul, putar ke bawah; Jika turun, putar ke kiri; Jika dibiarkan, putar ke atas; Jika naik, putar ke kanan; Cetak matriks; Dapatkan saiz saiz; Cetak corak lingkaran", "code": "function printSpiral ( size ) { let row = 0 , col = 0 ; let boundary = size - 1 ; let sizeLeft = size - 1 ; let flag = 1 ; let move = ' ' ; let matrix = new Array ( size ) ; for ( let i = 0 ; i < size ; i ++ ) { matrix [ i ] = new Array ( size ) . fill ( 0 ) ; } for ( let i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row ] [ col ] = i ; switch ( move ) { case ' ' : col += 1 ; break ; case ' ' : col -= 1 ; break ; case ' ' : row -= 1 ; break ; case ' ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' ' : move = ' ' ; break ; case ' ' : move = ' ' ; break ; case ' ' : move = ' ' ; break ; case ' ' : move = ' ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { let n = matrix [ row ] [ col ] ; if ( n < 10 ) document . write ( n + \" \" ) ; else document . write ( n + \" \" ) ; } document . write ( \" \" ) ; } } let size = 5 ; printSpiral ( size ) ;"}
{"text": "Sort Biotonic Doubly Linked List | nod senarai dikaitkan dua kali ganda; Berfungsi untuk membalikkan senarai dikaitkan dua kali ganda; swap seterusnya dan sebelumnya untuk semua nod senarai dikaitkan dua kali ganda; Sebelum menukar kepala, periksa kes -kes seperti senarai kosong dan senarai dengan hanya satu nod; Berfungsi untuk menggabungkan dua senarai dikaitkan dua kali ganda; Jika senarai yang dipautkan pertama kosong; Jika senarai dikaitkan kedua kosong; Pilih nilai yang lebih kecil; berfungsi untuk menyusun senarai dikaitkan dua kali ganda biotonik; Jika senarai kosong atau jika ia mengandungi satu nod tunggal; Jika benar, maka 'semasa' adalah nod pertama yang lebih kecil daripada nod sebelumnya; Pindah ke nod seterusnya; Jika benar, maka senarai sudah disusun; tumpah ke dalam dua senarai, satu bermula dengan 'kepala' dan yang lain bermula dengan 'semasa'; membalikkan senarai bermula dengan 'semasa'; Gabungkan kedua -dua senarai dan kembalikan senarai dikaitkan dua kali ganda; Berfungsi untuk memasukkan nod pada permulaan senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; Oleh kerana kita menambah pada mulanya, sebelum ini sentiasa batal; Pautan senarai lama dari nod baru; Tukar Node kepala ke nod baru; Gerakkan kepala ke Povar ke nod baru; Berfungsi untuk nod prvar dalam senarai dikaitkan dua kali ganda; Jika senarai kosong; Kod pemacu; Buat senarai dikaitkan dua kali: 2 <.5 <.7 <.12 <.10 <.6 <.4 <.1; Susun DLL Biotonik", "code": "class Node { constructor ( ) { this . data = 0 ; this . prev = null ; this . next = null ; } } function reverse ( head_ref ) { var temp = null ; var current = head_ref ; while ( current != null ) { temp = current . prev ; current . prev = current . next ; current . next = temp ; current = current . prev ; } if ( temp != null ) head_ref = temp . prev ; return head_ref ; } function merge ( first , second ) { if ( first == null ) return second ; if ( second == null ) return first ; if ( first . data < second . data ) { first . next = merge ( first . next , second ) ; first . next . prev = first ; first . prev = null ; return first ; } else { second . next = merge ( first , second . next ) ; second . next . prev = second ; second . prev = null ; return second ; } } function sort ( head ) { if ( head == null head . next == null ) return head ; var current = head . next ; while ( current != null ) { if ( current . data < current . prev . data ) break ; current = current . next ; } if ( current == null ) return head ; current . prev . next = null ; current . prev = null ; current = reverse ( current ) ; return merge ( head , current ) ; } function push ( head_ref , new_data ) { var new_node = new Node ( ) ; new_node . data = new_data ; new_node . prev = null ; new_node . next = ( head_ref ) ; if ( ( head_ref ) != null ) ( head_ref ) . prev = new_node ; ( head_ref ) = new_node ; return head_ref ; } function printList ( head ) { if ( head == null ) document . write ( \" \" ) ; while ( head != null ) { document . write ( head . data + \" \" ) ; head = head . next ; } } var head = null ; head = push ( head , 1 ) ; head = push ( head , 4 ) ; head = push ( head , 6 ) ; head = push ( head , 10 ) ; head = push ( head , 12 ) ; head = push ( head , 7 ) ; head = push ( head , 5 ) ; head = push ( head , 2 ) ; document . write ( \" \" ) ; printList ( head ) ; head = sort ( head ) ; document . write ( \" \" ) ; printList ( head ) ;"}
{"text": "Susun konsonan dan vokal nod dalam senarai yang dipautkan | Nod senarai yang dipautkan; Berfungsi untuk menambah nod baru ke senarai; fungsi utiliti untuk mencetak senarai yang dipautkan; fungsi utiliti untuk memeriksa vokal; berfungsi untuk mengatur konsonan dan nod vokal; untuk menjejaki vokal; senarai kosong; Kita perlu menemui vokal pertama dalam senarai. Ia akan menjadi kepala yang dikembalikan, dan juga Latarvowel awal. ; Unsur pertama adalah vokal. Ia juga akan menjadi kepala baru dan Latarvowel awal; ; Unsur pertama bukan vokal. Keluarkan melalui senarai sehingga kita dapati vokal. Perhatikan bahawa Curr menunjuk kepada elemen * sebelum * elemen dengan vokal. ; Ini adalah kes kelebihan di mana terdapat hanya konsonan dalam senarai. ; Tetapkan Latihan Awal dan kepala baru ke item vokal yang kami dapati. Relink rantai konsonan selepas item vokal itu: old_head_consonant -> consonant1 -> consonant2 -> vokal -> rest_of_list menjadi vokal -> old_head_consonant -> consonant1 -> consonant2 -> rest_of_list; Sekarang melintasi senarai. Curr sentiasa item * sebelum * yang kita periksa, supaya kita boleh menggunakannya untuk menghubungkan semula. ; Item yang ditemui seterusnya adalah vokal; Sekiranya ia datang secara langsung selepas vokal sebelumnya, kami tidak perlu memindahkan item di sekitar, hanya tandakan LatarVowel baru dan Advance Curr. ; Tetapi jika ia datang selepas rantaian konsonan intervensi, kita perlu mengikat vokal yang baru ditemui selepas vokal lama. Curr tidak berubah kerana selepas menghubungkannya akan mempunyai yang baru, yang belum diperiksa, dan kami sentiasa menyimpan Curr pada satu sebelum pemeriksaan seterusnya. ; Rantai dalam vokal baru; Advance Latestvowel; Keluarkan vokal yang dijumpai dari tempat sebelumnya; Re - Rantaian Konsonan Pautan Selepas Latihan Latihan; Tiada vokal dalam elemen seterusnya, Advance Curr. ; Kod pemacu", "code": "class Node { constructor ( key ) { this . data = key ; this . next = null ; } } function printlist ( head ) { if ( head == null ) { document . write ( \" \" ) ; return ; } while ( head != null ) { document . write ( head . data + \" \" ) ; if ( head . next != null ) document . write ( \" \" ) ; head = head . next ; } document . write ( \" \" ) ; } function isVowel ( x ) { return ( x == ' ' x == ' ' x == ' ' x == ' ' x == ' ' ) ; } function arrange ( head ) { let newHead = head ; let latestVowel ; let curr = head ; if ( head == null ) return null ; if ( isVowel ( head . data ) == true ) latestVowel = head ; else { while ( curr . next != null && ! isVowel ( curr . next . data ) ) curr = curr . next ; if ( curr . next == null ) return head ; latestVowel = newHead = curr . next ; curr . next = curr . next . next ; latestVowel . next = head ; } while ( curr != null && curr . next != null ) { if ( isVowel ( curr . next . data ) == true ) { if ( curr == latestVowel ) { latestVowel = curr = curr . next ; } else { let temp = latestVowel . next ; latestVowel . next = curr . next ; latestVowel = latestVowel . next ; curr . next = curr . next . next ; latestVowel . next = temp ; } } else { curr = curr . next ; } } return newHead ; } let head = new Node ( ' ' ) ; head . next = new Node ( ' ' ) ; head . next . next = new Node ( ' ' ) ; head . next . next . next = new Node ( ' ' ) ; head . next . next . next . next = new Node ( ' ' ) ; head . next . next . next . next . next = new Node ( ' ' ) ; head . next . next . next . next . next . next = new Node ( ' ' ) ; head . next . next . next . next . next . next . next = new Node ( ' ' ) ; document . write ( \" \" ) ; printlist ( head ) ; head = arrange ( head ) ; document . write ( \" \" ) ; printlist ( head ) ;"}
{"text": "Elemen terbesar di BST menggunakan ruang tambahan yang berterusan | Struktur nod; fungsi penolong untuk membuat nod baru; Mengira pembolehubah untuk menyimpan kiraan nod yang dikunjungi; Jika anak yang betul adalah batal; kiraan kenaikan pertama dan semak jika Count = k; Jika tidak berpindah ke anak kiri; Cari pengganti inorder nod semasa; Tetapkan anak kiri pengganti ke nod semasa; gerakkan arus ke kanannya; memulihkan pokok itu kembali ke pokok carian binari asal yang mengeluarkan pautan berulir; gerakkan arus ke anak kiri; Pokok binari yang dibina adalah 4 / \\ 2 7 / \\ / \\ 1 3 6 10", "code": "class Node { constructor ( ) { this . data = 0 ; this . left = null ; this . right = null ; } } function newNode ( data ) { var temp = new Node ( ) ; temp . data = data ; temp . right = null ; temp . left = null ; return temp ; } function KthLargestUsingMorrisTraversal ( root , k ) { var curr = root ; var Klargest = null ; var count = 0 ; while ( curr != null ) { if ( curr . right == null ) { if ( ++ count == k ) Klargest = curr ; curr = curr . left ; } else { var succ = curr . right ; while ( succ . left != null && succ . left != curr ) succ = succ . left ; if ( succ . left == null ) { succ . left = curr ; curr = curr . right ; } else { succ . left = null ; if ( ++ count == k ) Klargest = curr ; curr = curr . left ; } } } return Klargest ; } root = newNode ( 4 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 7 ) ; root . left . left = newNode ( 1 ) ; root . left . right = newNode ( 3 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 10 ) ; document . write ( \" \" + KthLargestUsingMorrisTraversal ( root , 2 ) . data ) ;"}
{"text": "Penyusun baris matriks dalam urutan menaik diikuti oleh lajur dalam urutan menurun | Pelaksanaan JavaScript untuk menyusun baris matriks dalam urutan menaik diikuti dengan menyusun lajur dalam urutan menurun; Fungsi untuk menyusun setiap baris matriks mengikut perintah yang ditentukan oleh menaik. ; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [] []; dapatkan transpose tikar [] []; Sekali lagi menyusun baris Mat [] [] dalam urutan menurun. ; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu", "code": "let MAX_SIZE = 10 ; function sortByRow ( mat , n , ascending ) { for ( let i = 0 ; i < n ; i ++ ) { if ( ascending ) mat [ i ] . sort ( function ( a , b ) { return a - b ; } ) ; else mat [ i ] . sort ( function ( a , b ) { return b - a ; } ) ; } } function transpose ( mat , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) { let temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } } function sortMatRowAndColWise ( mat , n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; } function printMat ( mat , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) document . write ( mat [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; } } let n = 3 ; let mat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ] ; document . write ( \" \" ) ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; document . write ( \" \" ) ; printMat ( mat , n ) ;"}
{"text": "Susun baris matriks | Pelaksanaan JavaScript untuk menyusun baris matriks - bijak dan lajur - bijak; berfungsi untuk menyusun setiap baris matriks; menyusun nombor baris 'i'; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [] []; dapatkan transpose tikar [] []; sekali lagi menyusun baris tikar [] []; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu", "code": "let MAX_SIZE = 10 ; function sortByRow ( mat , n ) { for ( let i = 0 ; i < n ; i ++ ) mat [ i ] . sort ( function ( a , b ) { return a - b ; } ) ; } function transpose ( mat , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) { let temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } } function sortMatRowAndColWise ( mat , n ) { sortByRow ( mat , n ) ; transpose ( mat , n ) ; sortByRow ( mat , n ) ; transpose ( mat , n ) ; } function printMat ( mat , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) document . write ( mat [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; } } let mat = [ [ 4 , 1 , 3 ] , [ 9 , 6 , 8 ] , [ 5 , 2 , 7 ] ] ; let n = 3 ; document . write ( \" \" ) ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; document . write ( \" \" ) ; printMat ( mat , n ) ;"}
{"text": "Magic Square | Malah pesanan | Fungsi untuk mengira Magic Square; Mengisi matriks dengan nilai kiraannya bermula dari 1; ; Tukar nilai elemen array pada lokasi pembaikan seperti peraturan (n * n + 1) - arr [i] [j] sudut kiri atas matriks (perintah (parseint (n / 4)) * (parseint (n / 4))); Sudut kanan atas matriks (perintah (parseint (n / 4)) * (parseint (n / 4))); Sudut kiri bawah matriks (perintah (parseint (n / 4)) * (parseint (n / 4))); Sudut kanan bawah matriks (perintah (parseint (n / 4)) * (parseint (n / 4))); Pusat matriks (perintah (n / 2) * (n / 2)); Mencetak Magic - Square; program pemacu; Panggilan fungsi", "code": "function doublyEven ( n ) { var arr = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; var i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * i ) + j + 1 ; for ( i = 0 ; i < parseInt ( n / 4 ) ; i ++ ) for ( j = 0 ; j < parseInt ( n / 4 ) ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < parseInt ( n / 4 ) ; i ++ ) for ( j = 3 * ( parseInt ( n / 4 ) ) ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * parseInt ( n / 4 ) ; i < n ; i ++ ) for ( j = 0 ; j < parseInt ( n / 4 ) ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * parseInt ( n / 4 ) ; i < n ; i ++ ) for ( j = 3 * parseInt ( n / 4 ) ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = parseInt ( n / 4 ) ; i < 3 * parseInt ( n / 4 ) ; i ++ ) for ( j = parseInt ( n / 4 ) ; j < 3 * parseInt ( n / 4 ) ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) document . write ( arr [ i ] [ j ] + \" \" ) ; document . write ( ' ' ) ; } } var n = 8 ; doublyEven ( n ) ;"}
{"text": "Produk Kronecker Dua Matriks | Rowa dan Cola tidak ada baris dan lajur matriks A rowb dan colb tidak ada baris dan lajur matriks B; Berfungsi untuk mengira produk Kronecker dua matriks; Saya gelung sehingga Rowa; k gelung hingga rowb; J Loops hingga Cola; l Loops hingga Colb; Setiap elemen matriks A didarab dengan keseluruhan matriks B resp dan disimpan sebagai matriks c; Kod pemacu", "code": "let cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ; function Kroneckerproduct ( A , B ) { let C = new Array ( rowa * rowb ) for ( let i = 0 ; i < ( rowa * rowb ) ; i ++ ) { C [ i ] = new Array ( cola * colb ) ; for ( let j = 0 ; j < ( cola * colb ) ; j ++ ) { C [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < rowa ; i ++ ) { for ( let k = 0 ; k < rowb ; k ++ ) { for ( let j = 0 ; j < cola ; j ++ ) { for ( let l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; document . write ( C [ i + l + 1 ] [ j + k + 1 ] + \" \" ) ; } } document . write ( \" \" ) ; } } } let A = [ [ 1 , 2 ] , [ 3 , 4 ] , [ 1 , 0 ] ] ; let B = [ [ 0 , 5 , 2 ] , [ 6 , 7 , 3 ] ] ; Kroneckerproduct ( A , B ) ;"}
{"text": "Program untuk memeriksa sama ada matriks adalah segitiga yang lebih rendah | Program skrip Java untuk memeriksa matriks segi tiga yang lebih rendah. ; Fungsi untuk memeriksa matriks adalah dalam bentuk segi tiga yang lebih rendah atau tidak. ; Fungsi pemacu. ; Panggilan fungsi", "code": "let N = 4 ; function isLowerTriangularMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } let mat = [ [ 1 , 0 , 0 , 0 ] , [ 1 , 4 , 0 , 0 ] , [ 4 , 6 , 2 , 0 ] , [ 0 , 4 , 7 , 6 ] ] ; if ( isLowerTriangularMatrix ( mat ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Program untuk memeriksa sama ada matriks adalah segitiga atas | Program Skrip Java untuk memeriksa matriks segitiga atas. ; Fungsi untuk memeriksa matriks adalah dalam bentuk segi tiga atas atau tidak. ; fungsi pemacu", "code": "let N = 4 ; function isUpperTriangularMatrix ( mat ) { for ( let i = 1 ; i < N ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } let mat = [ [ 1 , 3 , 5 , 3 ] , [ 0 , 4 , 6 , 2 ] , [ 0 , 0 , 2 , 5 ] , [ 0 , 0 , 0 , 6 ] ] ; if ( isUpperTriangularMatrix ( mat ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Mengira set 1 s dan 0 s dalam matriks binari | tiada lajur; tiada baris; berfungsi untuk mengira bilangan set sel yang tidak kosong; menyimpan jawapan terakhir; Traverses Row - Bijaksana; Traverses Column Wise; Pada akhirnya tolak n * m kerana tiada set tunggal telah ditambah dua kali. ; Kod pemacu", "code": "var m = 3 ; var n = 2 ; function countSets ( a ) { var res = 0 ; for ( i = 0 ; i < n ; i ++ ) { var u = 0 , v = 0 ; for ( j = 0 ; j < m ; j ++ ) { if ( a [ i ] [ j ] == 1 ) u ++ ; else v ++ ; } res += Math . pow ( 2 , u ) - 1 + Math . pow ( 2 , v ) - 1 ; } for ( i = 0 ; i < m ; i ++ ) { var u = 0 , v = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( a [ j ] [ i ] == 1 ) u ++ ; else v ++ ; } res += Math . pow ( 2 , u ) - 1 + Math . pow ( 2 , v ) - 1 ; } return res - ( n * m ) ; } var a = [ [ 1 , 0 , 1 ] , [ 0 , 1 , 0 ] ] ; document . write ( countSets ( a ) ) ;"}
{"text": "Program untuk memeriksa sama ada matriks adalah simetri | Kod JavaScript mudah untuk memeriksa matriks adalah simetri atau tidak. ; Mengisi transpose mat [n] [n] dalam tr [n] [n]; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu", "code": "let MAX = 100 ; function transpose ( mat , tr , N ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) tr [ i ] [ j ] = mat [ j ] [ i ] ; } function isSymmetric ( mat , N ) { let tr = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { tr [ i ] = new Array ( MAX ) ; } transpose ( mat , tr , N ) ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) return false ; return true ; } let mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 4 , 1 ] ] ; if ( isSymmetric ( mat , 3 ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Program untuk memeriksa sama ada matriks adalah simetri | Kod JavaScript yang cekap untuk memeriksa matriks adalah simetri atau tidak; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu", "code": "let MAX = 100 ; function isSymmetric ( mat , N ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; } let mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 4 , 1 ] ] ; if ( isSymmetric ( mat , 3 ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Program untuk mencari normal dan jejak matriks | Saiz matriks yang diberikan; Pulangan normal matriks saiz n x n; Mengembalikan jejak matriks saiz n x n; Kod pemacu", "code": "var MAX = 100 ; function findNormal ( mat , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; return parseInt ( Math . sqrt ( sum ) ) ; } function findTrace ( mat , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += mat [ i ] [ i ] ; return sum ; } var mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] ; document . write ( \" \" + findTrace ( mat , 5 ) + \" \" ) ; document . write ( \" \" + findNormal ( mat , 5 ) ) ;"}
{"text": "Penentu maksimum matriks dengan setiap nilai sama ada 0 atau n | Fungsi untuk penentu maksimum; Berfungsi untuk mencetak matriks resulatant; Tiga kedudukan di mana 0 muncul; Kedudukan di mana n muncul; Kod pemacu", "code": "function maxDet ( n ) { return ( 2 * n * n * n ) ; } function resMatrix ( n ) { for ( let i = 0 ; i < 3 ; i ++ ) { for ( let j = 0 ; j < 3 ; j ++ ) { if ( i == 0 && j == 2 ) document . write ( \" \" ) ; else if ( i == 1 && j == 0 ) document . write ( \" \" ) ; else if ( i == 2 && j == 1 ) document . write ( \" \" ) ; else document . write ( n + \" \" ) ; } document . write ( \" \" ) ; } } let n = 15 ; document . write ( \" \" + maxDet ( n ) + \" \" ) ; document . write ( \" \" ) ; resMatrix ( n ) ;"}
{"text": "Kira nombor negatif dalam lajur | Pelaksanaan JavaScript kaedah naif untuk mengira nombor negatif dalam m [n] [m]; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; Tiada nombor negatif dalam baris ini; Program pemacu untuk menguji fungsi di atas", "code": "function countNegative ( M , n , m ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; } let M = [ [ - 3 , - 2 , - 1 , 1 ] , [ - 2 , 2 , 3 , 4 ] , [ 4 , 5 , 7 , 8 ] ] ; document . write ( countNegative ( M , 3 , 4 ) ) ;"}
{"text": "Kira nombor negatif dalam lajur | Berfungsi untuk mengira nombor negatif; memulakan hasil; Mulakan dengan sudut kanan atas; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; J ialah indeks nombor negatif terakhir dalam baris ini. Jadi mesti ada (j + 1); Nombor negatif dalam baris ini. ; Pindah ke kiri dan lihat jika kita dapat mencari nombor negatif di sana;", "code": "function countNegative ( M , n , m ) { let count = 0 ; let i = 0 ; let j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; } ` let M = [ [ - 3 , - 2 , - 1 , 1 ] , [ - 2 , 2 , 3 , 4 ] , [ 4 , 5 , 7 , 8 ] ] ; document . write ( countNegative ( M , 3 , 4 ) ) ;"}
{"text": "Cari pasangan tertentu dalam Matrix | Fungsi ini mengembalikan nilai maksimum a (d, e) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua d> a dan e> b. ; Kedai nilai maksimum; Pertimbangkan semua pasangan yang mungkin mat [a] [b] dan mat1 [d] [e]; Kod pemacu", "code": "function findMaxValue ( N , mat ) { let maxValue = Number . MIN_VALUE ; for ( let a = 0 ; a < N - 1 ; a ++ ) for ( let b = 0 ; b < N - 1 ; b ++ ) for ( let d = a + 1 ; d < N ; d ++ ) for ( let e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; } let N = 5 ; let mat = [ [ 1 , 2 , - 1 , - 4 , - 20 ] , [ - 8 , - 3 , 4 , 2 , 1 ] , [ 3 , 8 , 6 , 1 , 3 ] , [ - 4 , - 1 , 1 , 7 , - 6 ] , [ 0 , - 4 , 10 , - 5 , 1 ] ] ; document . write ( \" \" + findMaxValue ( N , mat ) ) ;"}
{"text": "Cari pasangan tertentu dalam Matrix | Fungsi ini mengembalikan nilai maksimum a (c, d) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua c> a dan d> b. ; Kedai nilai maksimum; maxarr [i] [j] menyimpan max unsur -unsur dalam matriks dari (i, j) hingga (n - 1, n - 1); Elemen terakhir Maxarr akan menjadi sama seperti matriks input; Preprocess Last Row Inisialisasi Max; preprocess lajur terakhir memulakan max; PREPROCESS ROST OF MATRIX DARI BAWAH; Kemas kini MaxValue; Tetapkan Maxarr (i, j); Kod pemacu", "code": "function findMaxValue ( N , mat ) { let maxValue = Number . MIN_VALUE ; let maxArr = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { maxArr [ i ] = new Array ( N ) ; } maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; let maxv = mat [ N - 1 ] [ N - 1 ] ; for ( let j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( let i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; } for ( let i = N - 2 ; i >= 0 ; i -- ) { for ( let j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; } let N = 5 ; let mat = [ [ 1 , 2 , - 1 , - 4 , - 20 ] , [ - 8 , - 3 , 4 , 2 , 1 ] , [ 3 , 8 , 6 , 1 , 3 ] , [ - 4 , - 1 , 1 , 7 , - 6 ] , [ 0 , - 4 , 10 , - 5 , 1 ] ] ; document . write ( \" \" + findMaxValue ( N , mat ) ) ;"}
{"text": "Cetak semua elemen dalam susunan yang disusun dari baris dan lajur yang bijak matriks disusun | Program JavaScript untuk mencetak semua elemen dalam susunan yang disusun dari baris dan lajur yang disusun matriks; Fungsi utiliti untuk Youngify meja muda. Ini berbeza dengan Standard Youngify. Ia mengandaikan bahawa nilai pada MAT [0] [0] adalah tak terhingga. ; Cari nilai -nilai di bawah dan kanan tikar [i] [j]; Jika tikar [i] [j] adalah elemen sudut kanan, kembali; Gerakkan lebih kecil daripada dua nilai (downval dan rightval) ke tikar [i] [j] dan berulang untuk nilai yang lebih kecil; Fungsi utiliti untuk mengekstrak elemen minimum dari Tableau muda; Fungsi ini menggunakan ExtractMin () untuk mencetak elemen dalam urutan yang disusun", "code": "let INF = Number . MAX_VALUE ; let N = 4 ; function youngify ( mat , i , j ) { let downVal = ( i + 1 < N ) ? mat [ i + 1 ] [ j ] : INF ; let rightVal = ( j + 1 < N ) ? mat [ i ] [ j + 1 ] : INF ; if ( downVal == INF && rightVal == INF ) { return ; } if ( downVal < rightVal ) { mat [ i ] [ j ] = downVal ; mat [ i + 1 ] [ j ] = INF ; youngify ( mat , i + 1 , j ) ; } else { mat [ i ] [ j ] = rightVal ; mat [ i ] [ j + 1 ] = INF ; youngify ( mat , i , j + 1 ) ; } } function extractMin ( mat ) { let ret = mat [ 0 ] [ 0 ] ; mat [ 0 ] [ 0 ] = INF ; youngify ( mat , 0 , 0 ) ; return ret ; } function printSorted ( mat ) { document . write ( \" \" ) ; for ( let i = 0 ; i < N * N ; i ++ ) { document . write ( extractMin ( mat ) + \" \" ) ; } } let mat = [ [ 10 , 20 , 30 , 40 ] , [ 15 , 25 , 35 , 45 ] , [ 27 , 29 , 37 , 48 ] , [ 32 , 33 , 39 , 50 ] ] ; printSorted ( mat ) ;"}
{"text": "Memandangkan matriks n x n persegi, cari jumlah semua sub | saiz k x k saiz matriks yang diberikan; Fungsi mudah untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; Nombor baris sel pertama dalam sub -persegi semasa saiz k x k; Lajur sel pertama dalam sub -persegi semasa saiz k x k; Hitung dan cetak jumlah sub -persegi semasa; Pemisah garis untuk sub -dataran bermula dengan baris seterusnya; Program pemacu untuk menguji fungsi di atas", "code": "let n = 5 ; function printSumSimple ( mat , k ) { if ( k > n ) return ; for ( let i = 0 ; i < n - k + 1 ; i ++ ) { for ( let j = 0 ; j < n - k + 1 ; j ++ ) { let sum = 0 ; for ( let p = i ; p < k + i ; p ++ ) for ( let q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; document . write ( sum + \" \" ) ; } document . write ( \" \" ) ; } } let mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] let k = 3 ; printSumSimple ( mat , k ) ;"}
{"text": "Memandangkan matriks n x n persegi, cari jumlah semua sub | Saiz matriks yang diberikan; A o (n ^ 2) berfungsi untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi yang diberikan saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; 1: Preprocessing untuk menyimpan jumlah semua jalur saiz k x 1; Pergi lajur mengikut lajur; Hitung jumlah pertama K x 1 segi empat tepat dalam lajur ini; Hitung jumlah segi empat tepat; 2: Kirakan jumlah sub - dataran menggunakan stripsum [] []; Hitung dan cetak jumlah Subsquare Pertama dalam baris ini; Kirakan jumlah kuadrat yang tinggal dalam baris semasa dengan mengeluarkan jalur paling kiri sub -persegi sebelumnya dan menambah jalur baru; Kod pemacu", "code": "let n = 5 ; function printSumTricky ( mat , k ) { if ( k > n ) return ; let stripSum = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { stripSum [ i ] = new Array ( n ) ; } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { stripSum [ i ] [ j ] = 0 ; } } for ( let j = 0 ; j < n ; j ++ ) { let sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( let i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( let i = 0 ; i < n - k + 1 ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; document . write ( sum + \" \" ) ; for ( let j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; document . write ( sum + \" \" ) ; } document . write ( \" \" ) ; } } let mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] ; let k = 3 ; printSumTricky ( mat , k ) ;"}
{"text": "Program untuk mencari transpose matriks | Program JavaScript untuk mencari transpose matriks; Fungsi ini menyimpan transpose A in B; Kod pemacu", "code": "var M = 3 ; var N = 4 ; function transpose ( A , B ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] ] ; var B = Array ( N ) ; for ( i = 0 ; i < N ; i ++ ) B [ i ] = Array ( M ) . fill ( 0 ) ; transpose ( A , B ) ; document . write ( \" \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) document . write ( B [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; }"}
{"text": "Program untuk mencari transpose matriks | Program JavaScript untuk mencari transpose matriks; Mencari transpose tempat di - tempat; Kod pemacu", "code": "var N = 4 ; function transpose ( A ) { for ( i = 0 ; i < N ; i ++ ) for ( j = i + 1 ; j < N ; j ++ ) { var temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; transpose ( A ) ; document . write ( \" \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( A [ i ] [ j ] + \" \" ) ; document . write ( \" \\< \" ) ; }"}
{"text": "Bilangan Jalan dengan Koin Kata Tepat | Program JavaScript rekursif naif untuk mengira laluan dengan duit syiling 'k' tepat; Fungsi rekursif untuk mengira laluan dengan jumlah k dari (0, 0) hingga (m, n); Kes asas; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Pembungkus ke atas PathCountrec (); Kod pemacu", "code": "let R = 3 ; let C = 3 ; function pathCountRec ( mat , m , n , k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ) ; return pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; } function pathCount ( mat , k ) { return pathCountRec ( mat , R - 1 , C - 1 , k ) ; } let k = 12 ; let mat = [ [ 1 , 2 , 3 ] , [ 4 , 6 , 5 ] , [ 3 , 2 , 1 ] ] ; document . write ( pathCount ( mat , k ) ) ;"}
{"text": "Bilangan Jalan dengan Koin Kata Tepat | Program JavaScript berasaskan pengaturcaraan yang dinamik untuk mengira laluan dengan duit syiling 'k' tepat; Kes asas; Jika subproblem ini sudah diselesaikan; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Fungsi ini terutamanya memulakan DP dan memanggil PathCountDPrecdp (); Program pemacu untuk menguji fungsi di atas", "code": "var R = 3 ; var C = 3 ; var MAX_K = 100 ; var dp = Array ( R ) . fill ( ) . map ( ( ) => Array ( C ) . fill ( ) . map ( ( ) => Array ( MAX_K ) . fill ( 0 ) ) ) ; function pathCountDPRecDP ( mat , m , n , k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ? 1 : 0 ) ; if ( dp [ m ] [ n ] [ k ] != - 1 ) return dp [ m ] [ n ] [ k ] ; dp [ m ] [ n ] [ k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; } function pathCountDP ( mat , k ) { for ( i = 0 ; i < R ; i ++ ) for ( j = 0 ; j < C ; j ++ ) for ( l = 0 ; l < MAX_K ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; } var k = 12 ; var mat = [ [ 1 , 2 , 3 ] , [ 4 , 6 , 5 ] , [ 3 , 2 , 1 ] ] ; document . write ( pathCountDP ( mat , k ) ) ;"}
{"text": "Susun Matriks yang Diberikan | Pelaksanaan JavaScript untuk menyusun matriks yang diberikan; berfungsi untuk menyusun matriks yang diberikan; matriks sementara saiz n ^ 2; Salin unsur -unsur matriks satu demi satu ke temp []; Susun temp []; Salin unsur -unsur temp [] satu demi satu dalam tikar [] []; berfungsi untuk mencetak matriks yang diberikan; Program Pemandu untuk diuji di atas", "code": "let SIZE = 10 function sortMat ( mat , n ) { let temp = new Array ( n * n ) ; let k = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) temp [ k ++ ] = mat [ i ] [ j ] ; temp . sort ( ) ; k = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) mat [ i ] [ j ] = temp [ k ++ ] ; } function printMat ( mat , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) document . write ( mat [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; } } let mat = [ [ 5 , 4 , 7 ] , [ 1 , 3 , 8 ] , [ 2 , 9 , 6 ] ] ; let n = 3 ; document . write ( \" \" + \" \" ) ; printMat ( mat , n ) ; sortMat ( mat , n ) ; document . write ( \" \" ) ; document . write ( \" \" + \" \" ) ; printMat ( mat , n ) ;"}
{"text": "Cari K Elemen yang paling dekat dengan nilai yang diberikan | Fungsi untuk mencari titik silang (titik yang sebelum ini unsur -unsur aresmaller daripada atau sama dengan x dan selepas itu lebih besar daripada x); Kes asas X lebih besar daripada semua; X lebih kecil daripada semua; Cari titik tengah; Jika x sama dengan elemen tengah, maka kembali pertengahan; Jika x lebih besar daripada arr [pertengahan], maka sama ada arr [pertengahan + 1] adalah siling x atau siling terletak pada arr [pertengahan + 1. . tinggi]; Fungsi ini mencetak elemen yang paling dekat dengan x dalam arr []. n ialah bilangan elemen dalam arr []; Cari titik crossover; Indeks yang betul untuk mencari; Untuk menjejaki kiraan elemen yang telah dicetak; Jika x hadir dalam arr [], maka kurangkan indeks kiri. Asumsi: Semua elemen dalam ARR [] adalah berbeza; Bandingkan unsur -unsur di kiri dan kanan titik crossover untuk mencari unsur -unsur yang paling dekat; Jika tidak ada lagi elemen di sebelah kanan, maka cetak elemen kiri; Sekiranya tidak ada lagi elemen di sebelah kiri, maka cetak elemen kanan; Kod pemacu", "code": "function findCrossOver ( arr , low , high , x ) { if ( arr [ high ] <= x ) return high if ( arr [ low ] > x ) return low var mid = ( low + high ) / 2 if ( arr [ mid ] <= x && arr [ mid + 1 ] > x ) return mid if ( arr [ mid ] < x ) return findCrossOver ( arr , mid + 1 , high , x ) return findCrossOver ( arr , low , mid - 1 , x ) } function printKclosest ( arr , x , k , n ) { var l = findCrossOver ( arr , 0 , n - 1 , x ) var r = l + 1 var count = 0 if ( arr [ l ] == x ) l -= 1 while ( l >= 0 && r < n && count < k ) { if ( x - arr [ l ] < arr [ r ] - x ) { document . write ( arr [ l ] + \" \" ) l -= 1 } else { document . write ( arr [ r ] + \" \" ) r += 1 } count += 1 } while ( count < k && l >= 0 ) { print ( arr [ l ] ) l -= 1 count += 1 } while ( count < k && r < n ) { print ( arr [ r ] ) r += 1 count += 1 } } var arr = [ 12 , 16 , 22 , 30 , 35 , 39 , 42 , 45 , 48 , 50 , 53 , 55 , 56 ] var n = arr . length var x = 35 var k = 4 printKclosest ( arr , x , 4 , n )"}
{"text": "SENARAI SENSI UNTUK SENDIRI SISTY LINKED | Program JavaScript untuk menyusun senarai pautan menggunakan jenis penyisipan; Fungsi utiliti untuk memasukkan nod pada permulaan senarai yang dipautkan; memperuntukkan nod; Pautan senarai lama dari nod baru; Gerakkan kepala ke Povar ke nod baru; Fungsi untuk menyusun senarai yang berkaitan dengan menggunakan jenis penyisipan; Memulakan senarai yang disusun; Melintasi senarai yang dipautkan dan masukkan setiap nod untuk disusun; Simpan seterusnya untuk lelaran seterusnya; Masukkan arus dalam senarai yang disusun; Mengemas kini semasa; Kemas kini head_ref ke povar ke senarai yang disusun; * berfungsi untuk memasukkan new_node dalam nota bahawa fungsi ini menjangkakan penunjuk * ke head_ref kerana ini dapat mengubah suai kepala senarai yang dipautkan input * (serupa dengan push ()); Kes khas untuk hujung kepala; Cari nod sebelum povar penyisipan; Berfungsi ke senarai berkaitan PRVAR; Program pemacu untuk menguji fungsi di atas", "code": "var head = null ; var sorted = null ; class node { constructor ( val ) { this . val = val ; this . next = null ; } } function push ( val ) { var newnode = new node ( val ) ; newnode . next = head ; head = newnode ; } function insertionSort ( headref ) { var sorted = null ; var current = headref ; while ( current != null ) { var next = current . next ; sortedInsert ( current ) ; current = next ; } head = sorted ; } function sortedInsert ( newnode ) { if ( sorted == null sorted . val >= newnode . val ) { newnode . next = sorted ; sorted = newnode ; } else { var current = sorted ; while ( current . next != null && current . next . val < newnode . val ) { current = current . next ; } newnode . next = current . next ; current . next = newnode ; } } function printlist ( head ) { while ( head != null ) { document . write ( head . val + \" \" ) ; head = head . next ; } } push ( 5 ) ; push ( 20 ) ; push ( 4 ) ; push ( 3 ) ; push ( 30 ) ; document . write ( \" \" ) ; printlist ( head ) ; insertionSort ( head ) ; document . write ( \" \" ) ; printlist ( sorted ) ;"}
{"text": "Perubahan duit syiling | DP | Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Program pemacu untuk menguji fungsi di atas", "code": "function count ( S , m , n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } var arr = [ 1 , 2 , 3 ] ; var m = arr . length ; document . write ( count ( arr , m , 4 ) ) ;"}
{"text": "Perubahan duit syiling | DP | Pelaksanaan JavaScript Pengaturcaraan Dinamik Masalah Perubahan Koin; Jadual [i] akan menyimpan bilangan penyelesaian untuk nilai i. Kami memerlukan baris n + 1 kerana jadual dibina dengan cara bawah menggunakan kes asas (n = 0); Kes asas (jika diberi nilai adalah 0); Pilih semua syiling satu demi satu dan kemas kini nilai jadual [] selepas indeks lebih besar daripada atau sama dengan nilai duit syiling yang dipilih; Kod pemacu", "code": "function count ( S , m , n ) { let table = new Array ( n + 1 ) ; table . fill ( 0 ) ; table [ 0 ] = 1 ; for ( let i = 0 ; i < m ; i ++ ) for ( let j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; } let arr = [ 1 , 2 , 3 ] ; let m = arr . length ; let n = 4 ; document . write ( count ( arr , m , n ) ) ;"}
{"text": "Pendaraban rantai matriks | DP | Program JavaScript menggunakan memoisasi; Fungsi untuk pendaraban rantai matriks; Kod pemacu", "code": "let dp = new Array ( 100 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } function matrixChainMemoised ( p , i , j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = Number . MAX_VALUE ; for ( let k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } function MatrixChainOrder ( p , n ) { let i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; } let arr = [ 1 , 2 , 3 , 4 ] ; let n = arr . length ; for ( var i = 0 ; i < dp . length ; i ++ ) { for ( var j = 0 ; j < dp . length ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } document . write ( \" \" + MatrixChainOrder ( arr , n ) ) ;"}
{"text": "Pendaraban rantai matriks | DP | Pendaraban rantai matriks. Lihat buku Cormen untuk butiran matriks algoritma berikut AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Untuk kesederhanaan program, satu baris tambahan dan satu lajur tambahan diperuntukkan dalam m. Baris ke -0 dan lajur 0 tidak digunakan; Kos adalah sifar apabila mendarabkan satu matriks. ; L adalah panjang rantai. ; Q = Kos / skalar pendaraban; Kod pemacu", "code": "function MatrixChainOrder ( p , n ) { var m = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; var i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Number . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } var arr = [ 1 , 2 , 3 , 4 ] ; var size = arr . length ; document . write ( \" \" + MatrixChainOrder ( arr , size ) ) ;"}
{"text": "Memotong batang | DP | Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Recursif memotong batang dalam kepingan yang berbeza dan membandingkan konfigurasi yang berbeza; Kod pemacu", "code": "function cutRod ( price , n ) { if ( n <= 0 ) return 0 ; let max_val = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) max_val = Math . max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) ; return max_val ; } let arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] ; let size = arr . length ; document . write ( \" \" + cutRod ( arr , size ) ) ;"}
{"text": "Memotong batang | DP | Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Kod pemacu", "code": "function cutRod ( price , n ) { let val = new Array ( n + 1 ) ; val [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let max_val = Number . MIN_VALUE ; for ( let j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } let arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] ; let size = arr . length ; document . write ( \" \" + cutRod ( arr , size ) + \" \" ) ;"}
{"text": "Memotong batang | DP | Arahan global untuk tujuan memoisasi. ; Program rekursif, menggunakan, memoisasi, untuk melaksanakan masalah pemotongan rod (atas - ke bawah). ; Harga maksimum akan menjadi sifar, apabila panjang rod adalah sifar atau harga adalah sifar. ; Jika panjang rod kurang daripada panjang maksimum, max_lene akan menganggapnya. Sekarang bergantung kepada keuntungan, sama ada max_lene kita akan mengambilnya atau membuangnya. ; Jika panjang rod lebih besar daripada saiz yang dibenarkan, max_len kita tidak akan menganggapnya. ; Max_lene max_lenill Kembalikan nilai maksimum yang diperoleh, max_lenhich hadir di lajur nth romax_len dan max_lenth. ; Kod pemacu; Panggilan fungsi", "code": "let t = new Array ( 9 ) ; for ( var i = 0 ; i < t . length ; i ++ ) { t [ i ] = new Array ( 2 ) ; } function un_kp ( price , length , Max_len , n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = Math . max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } let price = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] ; let n = price . length ; let length = Array ( n ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } let Max_len = n ; document . write ( \" \" + un_kp ( price , length , n , Max_len ) ) ;"}
{"text": "Multiply dua bilangan bulat tanpa menggunakan pendaraban, pembahagian dan pengendali bitwise, dan tiada gelung | berfungsi untuk membiak dua nombor x dan y; 0 didarab dengan apa -apa memberi 0; Tambah x satu demi satu; kes di mana y adalah negatif; Kod pemacu", "code": "function multiply ( x , y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; } document . write ( multiply ( 5 , - 11 ) ) ;"}
{"text": "Sieve of Eratosthenes | Program JavaScript untuk mencetak semua prima yang lebih kecil daripada atau sama dengan N menggunakan ayak eratosthenes; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cetak semua nombor utama; Kod pemacu", "code": "function sieveOfEratosthenes ( n ) { prime = Array . from ( { length : n + 1 } , ( _ , i ) => true ) ; for ( p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) document . write ( i + \" \" ) ; } } var n = 30 ; document . write ( \" \" ) ; document . write ( \" \" + n + \" \" ) ; sieveOfEratosthenes ( n ) ;"}
{"text": "Segitiga Pascal | BinomialCoeff; Berfungsi untuk mencetak garisan N pertama dari segitiga Pascal; Berulang melalui setiap baris dan cetak penyertaan di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Kod pemacu", "code": "function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } function printPascal ( n ) { for ( let line = 0 ; line < n ; line ++ ) { for ( let i = 0 ; i <= line ; i ++ ) document . write ( binomialCoeff ( line , i ) + \" \" ) ; document . write ( \" \" ) ; } } let n = 7 ; printPascal ( n ) ;"}
{"text": "Segitiga Pascal | A o (n ^ 2) masa dan o (n ^ 2) kaedah ruang tambahan untuk segitiga Pascal; Array tambahan untuk menyimpan nilai segitiga pascal yang dihasilkan; Melangkah melalui setiap baris dan cetak integer (s) di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Nilai pertama dan terakhir dalam setiap baris adalah 1; Nilai -nilai lain adalah jumlah nilai di atas dan kiri di atas; Kod pemacu", "code": "function printPascal ( n ) { arr = a = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( line = 0 ; line < n ; line ++ ) { for ( i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; document . write ( arr [ line ] [ i ] ) ; } document . write ( \" \" ) ; } } var n = 5 ; printPascal ( n ) ;"}
{"text": "Segitiga Pascal | Program JavaScript untuk Pascal 's' u u (n ^ 2) ~ masa u dan u (1) ~ or ~ ruang »fungsa Pascal Pascal Pascal; digunakan untuk mewakili C (garis, i); Nilai pertama dalam baris sentiasa 1; Kod pemacu", "code": "function printPascal ( n ) { for ( line = 1 ; line <= n ; line ++ ) { var C = 1 ; for ( i = 1 ; i <= line ; i ++ ) { document . write ( C + \" \" ) ; C = C * ( line - i ) / i ; } document . write ( \" \" ) ; } } var n = 5 ; printPascal ( n ) ;"}
{"text": "Tambah dua nombor tanpa menggunakan pengendali aritmetik | Program JavaScript untuk menambah dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Bawa sekarang mengandungi bit set biasa x dan y; Jumlah bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Membawa beralih oleh satu supaya menambahnya kepada x memberikan jumlah yang diperlukan; kod pemacu", "code": "function Add ( x , y ) { while ( y != 0 ) { let carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } document . write ( Add ( 15 , 32 ) ) ;"}
{"text": "Tambah dua nombor tanpa menggunakan pengendali aritmetik |", "code": "function Add ( x , y ) { if ( y == 0 ) return x ; else return Add ( x ^ y , ( x & y ) << 1 ) ; }"}
{"text": "Mengira Bahagian Modulus dengan Kuasa | Fungsi ini akan kembali n % d. D mestilah salah satu: 1, 2, 4, 8, 16, 32, ...; Kod pemacu; D mesti menjadi kuasa 2", "code": "function getModulo ( n , d ) { return ( n & ( d - 1 ) ) ; } n = 6 ; d = 4 ; document . write ( n + \" \" + d + \" \" + getModulo ( n , d ) ) ;"}
{"text": "Count set bit dalam integer | Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Program untuk menguji fungsi countsetbits", "code": "function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } var i = 9 ; document . write ( countSetBits ( i ) ) ;"}
{"text": "Count set bit dalam integer | fungsi rekursif untuk mengira set bit; Kes asas; Dapatkan nilai dari pengguna; fungsi panggilan", "code": "function countSetBits ( n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; } var n = 9 ; document . write ( countSetBits ( n ) ) ;"}
{"text": "Count set bit dalam integer | Jadual carian; Berfungsi untuk memulakan jadual carian; Pada mulanya menjana jadual algoritma; Berfungsi untuk mengembalikan kiraan bit set dalam n; Memulakan jadual carian", "code": "var BitsSetTable256 = Array . from ( { length : 256 } , ( _ , i ) => 0 ) ; function initialize ( ) { BitsSetTable256 [ 0 ] = 0 ; for ( var i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ parseInt ( i / 2 ) ] ; } } function countSetBits ( n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; } initialize ( ) ; var n = 9 ; document . write ( countSetBits ( n ) ) ;"}
{"text": "Count set bit dalam integer | Kod pemacu", "code": "document . write ( ( 4 ) . toString ( 2 ) . split ( ' ' ) . filter ( x => x == ' ' ) . length + \" \" ) ; document . write ( ( 15 ) . toString ( 2 ) . split ( ' ' ) . filter ( x => x == ' ' ) . length ) ;"}
{"text": "Count set bit dalam integer | Program JavaScript untuk mengira set bit dengan pra -menyimpan bit set bit dalam gumpalan. ; Recursif dapat menggigit nombor tertentu dan memetakannya dalam array; Cari nibble terakhir; Gunakan nilai pra -disimpan untuk mencari kiraan dalam nibble terakhir ditambah dengan rekursif menambah baki yang tersisa. ; Kod pemacu", "code": "var num_to_bits = [ 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 ] ; function countSetBitsRec ( num ) { var nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; } var num = 31 ; document . write ( countSetBitsRec ( num ) ) ;"}
{"text": "Count set bit dalam integer | Semak setiap bit dalam nombor ditetapkan atau tidak dan kembalikan jumlah kiraan bit yang ditetapkan. ; (1 << i) = pow (2, i); Kod pemacu", "code": "function countSetBits ( N ) { var count = 0 ; for ( i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; } var N = 15 ; document . write ( countSetBits ( N ) ) ;"}
{"text": "Program untuk mencari pariti | Berfungsi untuk mendapatkan pariti nombor n. Ia mengembalikan 1 jika n mempunyai pariti ganjil, dan pulangan 0 jika n mempunyai pariti; Kod pemacu", "code": "function getParity ( n ) { var parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } var n = 7 ; document . write ( \" \" + n + \" \" + ( getParity ( n ) ? \" \" : \" \" ) ) ;"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "function isPowerOfTwo ( n ) { if ( n == 0 ) return false ; return parseInt ( ( Math . ceil ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) ) == parseInt ( ( Math . floor ( ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) ) ) ; } if ( isPowerOfTwo ( 31 ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ; if ( isPowerOfTwo ( 64 ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "function isPowerOfTwo ( n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; } isPowerOfTwo ( 31 ) ? document . write ( \" \" + \" \" ) : document . write ( \" \" + \" \" ) ; isPowerOfTwo ( 64 ) ? document . write ( \" \" ) : document . write ( \" \" ) ;"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Fungsi yang memeriksa sama ada nombor adalah kuasa 2; Kes asas '1' adalah satu -satunya nombor ganjil yang merupakan kuasa 2 (2 ^ 0); Semua nombor ganjil yang lain bukan kuasa 2; panggilan fungsi rekursif; Benar; Palsu", "code": "function powerOf2 ( n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } var n = 64 ; var m = 12 ; if ( powerOf2 ( n ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ; if ( powerOf2 ( m ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Kaedah untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Kaedah Pemandu", "code": "function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; } document . write ( isPowerOfTwo ( 31 ) ? \" \" : \" \" ) ; document . write ( \" \" + ( isPowerOfTwo ( 64 ) ? \" \" : \" \" ) ) ;"}
{"text": "Cari nombor pengulangan maksimum dalam O (n) masa dan O (1) ruang tambahan | Mengembalikan elemen berulang maksimum dalam ARR [0. n - 1]. Unsur -unsur array berada dalam jarak dari 0 hingga k - 1; Berulang walaupun array input, untuk setiap elemen arr [i], kenaikan arr [arr [i] % k] oleh k; Cari indeks elemen berulang maksimum; Indeks pulangan elemen maksimum; Program pemacu untuk menguji fungsi di atas", "code": "function maxRepeating ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; let max = arr [ 0 ] , result = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; } let arr = [ 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 ] ; let n = arr . length ; let k = 8 ; document . write ( \" \" + maxRepeating ( arr , n , k ) + \" \" ) ;"}
{"text": "Pertanyaan pelbagai pada array yang setiap elemen adalah xor nilai indeks dan elemen sebelumnya | Fungsi pulangan nilai formula yang diperolehi. ; Mencari nilai XOR julat [y ... x]; Fungsi untuk menyelesaikan pertanyaan untuk l dan r. ; jika l atau r ialah 0 .; Mencari X boleh dibahagikan dengan 2 atau tidak. ; Program yang didorong", "code": "function fun ( x ) { let y = parseInt ( x / 4 ) * 4 ; let ans = 0 ; for ( let i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; } function query ( x ) { if ( x == 0 ) return 0 ; let k = parseInt ( ( x + 1 ) / 2 ) ; return ( x %= 2 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; } function allQueries ( q , l , r ) { for ( let i = 0 ; i < q ; i ++ ) document . write ( ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) + \" \" ) ; } let q = 3 ; let l = [ 2 , 2 , 5 ] ; let r = [ 4 , 8 , 9 ] ; allQueries ( q , l , r ) ;"}
{"text": "Pertanyaan pada Xor pembahagi ganjil yang paling hebat dari julat | Precompute awalan xor pembahagi ganjil yang paling besar; Mencari pembahagi ganjil yang paling besar; Mencari awalan xor; Kembali xor julat; Kod pemacu", "code": "function prefixXOR ( arr , preXOR , n ) { for ( let i = 0 ; i < n ; i ++ ) { while ( arr [ i ] % 2 != 1 ) arr [ i ] = parseInt ( arr [ i ] / 2 ) ; preXOR [ i ] = arr [ i ] ; } for ( let i = 1 ; i < n ; i ++ ) preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] ; } function query ( preXOR , l , r ) { if ( l == 0 ) return preXOR [ r ] ; else return preXOR [ r ] ^ preXOR [ l - 1 ] ; } let arr = [ 3 , 4 , 5 ] ; let n = arr . length ; let preXOR = new Array ( n ) ; prefixXOR ( arr , preXOR , n ) ; document . write ( query ( preXOR , 0 , 2 ) + \" \" ) ; document . write ( query ( preXOR , 1 , 2 ) + \" \" ) ;"}
{"text": "Swap bersebelahan minimum diperlukan untuk menyusun array binari | Fungsi untuk mencari swap minimum untuk menyusun pelbagai 0 s dan 1 s. ; Array untuk menyimpan kiraan sifar; Kira bilangan sifar di sebelah kanan setiap satu. ; Kira jumlah swap dengan menambahkan bilangan sifar di sebelah kanan setiap satu. ; Kod pemacu", "code": "function findMinSwaps ( arr , n ) { let noOfZeroes = [ ] ; let i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; } let ar = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ; document . write ( findMinSwaps ( ar , ar . length ) ) ;"}
{"text": "Swap bersebelahan minimum diperlukan untuk menyusun array binari |  ; Kod pemacu", "code": "function minswaps ( arr , n ) { var count = 0 ; var num_unplaced_zeros = 0 ; for ( var index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; } var arr = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ; document . write ( minswaps ( arr , 9 ) ) ;"}
{"text": "Program untuk memeriksa sama ada array disusun atau tidak (berulang dan rekursif) | Fungsi yang pulih benar jika array disusun dalam perintah yang tidak menurun. ; Array mempunyai satu atau tiada elemen; Pasangan yang tidak disusun dijumpai; Tiada pasangan yang tidak disusun dijumpai; Kod pemacu", "code": "function arraySortedOrNot ( arr , n ) { if ( n == 0 n == 1 ) return true ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; } let arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] ; let n = arr . length ; if ( arraySortedOrNot ( arr , n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Cari dua nombor dengan kejadian ganjil dalam array yang tidak disusun | Mencetak dua nombor yang berlaku bilangan kali ganjil. Fungsi mengandaikan bahawa saiz array sekurang -kurangnya 2 dan terdapat dua nombor yang berlaku pada masa yang ganjil. ; Akan memegang Xor dua elemen yang ganjil; Hanya akan mempunyai bit satu set XOR2; Dapatkan xor semua elemen dalam arr []. XOR pada dasarnya akan menjadi XOR dari dua elemen yang ganjil; Dapatkan satu set bit di XOR2. Kami mendapat set paling kanan dalam baris berikut kerana ia dapat. ; Bahagikan unsur -unsur dalam dua set: 1) unsur -unsur yang mempunyai bit yang sepadan sebagai 1.2) unsur -unsur yang mempunyai bit yang sepadan sebagai 0 .; XOR set pertama akhirnya akan memegang satu nombor X yang ganjil; XOR set kedua akhirnya akan memegang nombor yang lain yang berlaku y; Kod pemacu", "code": "function printTwoOdd ( arr , size ) { let xor2 = arr [ 0 ] ; let set_bit_no ; let i ; int n = size - 2 ; let x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( \" \" + x + \" \" + y + \" \" ) ; } let arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] ; let arr_size = arr . length ; printTwoOdd ( arr , arr_size ) ;"}
{"text": "Cari dua nombor dengan kejadian ganjil dalam array yang tidak disusun | Mencetak dua nombor yang berlaku bilangan kali ganjil. Fungsi ini mengandaikan bahawa saiz array sekurang -kurangnya 2 dan terdapat dua nombor yang berlaku pada masa yang ganjil. ; Buat peta dan hitung kekerapan array * elemen menggunakan array. ; Melintasi peta dan periksa jika elemen kedua yang kekerapannya ganjil atau tidak. Kemudian ini adalah elemen yang ganjil. Ia jelas disebut dalam masalah bahawa hanya terdapat dua elemen yang ganjil sehingga ini akan mencetak kedua -dua elemen tersebut. ; Kod pemacu", "code": "function printTwoOdd ( arr , size ) { let m = new Map ( ) ; for ( let i = 0 ; i < size ; i ++ ) { if ( m . has ( arr [ i ] ) ) { m . set ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) } else { m . set ( arr [ i ] , 1 ) } } document . write ( \" \" ) ; let ar = [ ] for ( let x of m ) { if ( x [ 1 ] % 2 != 0 ) ar . push ( x [ 0 ] ) } document . write ( ` ${ ar . reverse ( ) } ` ) } let arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] ; let arr_size = arr . length ; printTwoOdd ( arr , arr_size ) ;"}
{"text": "Cari pasangan dengan perbezaan yang diberikan | Fungsi ini mengandaikan bahawa array disusun; Memulakan kedudukan dua elemen; Cari pasangan; Program pemacu untuk menguji fungsi di atas", "code": "function findPair ( arr , size , n ) { let i = 0 ; let j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { document . write ( \" \" + arr [ i ] + \" \" + arr [ j ] + \" \" ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } document . write ( \" \" ) ; return false ; } let arr = [ 1 , 8 , 30 , 40 , 100 ] ; let size = arr . length ; let n = 60 ; findPair ( arr , size , n ) ;"}
{"text": "Cari K Unsur Maksimum Array dalam Perintah Asal | Berfungsi untuk mencetak elemen maksimum; vektor untuk menyimpan salinan array asal; Menyusun vektor dalam urutan menurun. Sila rujuk pautan di bawah untuk butiran www. Geeksforgeeks. org / sort - c - stl / https :; Melintasi array asal dan mencetak semua unsur -unsur yang berada dalam k vektor yang disusun pertama. goo. GL / 44 RWGT Sila rujuk https: untuk butiran binary_search (); Kod pemacu", "code": "function printMax ( arr , k , n ) { var brr = arr . slice ( ) ; brr . sort ( ( a , b ) => b - a ) ; for ( var i = 0 ; i < n ; ++ i ) if ( brr . indexOf ( arr [ i ] ) < k ) document . write ( arr [ i ] + \" \" ) ; } var arr = [ 50 , 8 , 45 , 12 , 25 , 40 , 84 ] ; var n = arr . length ; var k = 3 ; printMax ( arr , k , n ) ;"}
{"text": "Cetak n elemen terkecil dari array yang diberikan dalam urutan asal mereka | Berfungsi untuk mencetak nombor N terkecil; Buat salinan Array; Susun Arahan Salin; Bagi setiap arr [i] mendapati sama ada ia adalah sebahagian daripada N - terkecil dengan carian binari; Program Pemandu", "code": "function printSmall ( arr , asize , n ) { let copy_arr = [ ... arr ] ; copy_arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < asize ; ++ i ) { if ( arr [ i ] < copy_arr [ n ] ) document . write ( arr [ i ] + \" \" ) ; } } let arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] ; let asize = arr . length ; let n = 5 ; printSmall ( arr , asize , n ) ;"}
{"text": "Semak sama ada perkembangan aritmetik boleh dibentuk dari array yang diberikan | Pulangan benar jika permutasi ARR [0 .. n - 1] boleh membentuk perkembangan aritmetik; Susun array; Selepas menyusun, perbezaan antara unsur -unsur berturut -turut mestilah sama. ; Program yang didorong", "code": "function checkIsAP ( arr , n ) { if ( n == 1 ) return true ; arr . sort ( ( a , b ) => a - b ) ; let d = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } let arr = [ 20 , 15 , 5 , 0 , 10 ] ; let n = arr . length ; ( checkIsAP ( arr , n ) ) ? ( document . write ( \" \" + \" \" ) ) : ( document . write ( \" \" + \" \" ) ) ;"}
{"text": "Semak sama ada perkembangan aritmetik boleh dibentuk dari array yang diberikan | Pulangan benar jika permutasi ARR [0 .. n - 1] boleh membentuk perkembangan aritmetik; Cari yang terkecil dan kemas kini kedua terkecil; Cari kedua terkecil; Semak sama ada elemen pendua yang dijumpai atau tidak; Jika pendua dijumpai kemudian kembali palsu; Cari perbezaan antara terkecil dan kedua terkecil; Seperti yang kita telah menggunakan terkecil terkecil dan kedua, jadi kita hanya perlu menyemak unsur -unsur n - 2; Program yang didorong", "code": "function checkIsAP ( arr , n ) { var hm = new Map ( ) ; var smallest = 1000000000 , second_smallest = 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < smallest ) { second_smallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] != smallest && arr [ i ] < second_smallest ) second_smallest = arr [ i ] ; if ( ! hm . has ( arr [ i ] ) ) { hm . set ( arr [ i ] , 1 ) ; } else return false ; } var diff = second_smallest - smallest ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( ! hm . has ( second_smallest ) ) return false ; second_smallest += diff ; } return true ; } var arr = [ 20 , 15 , 5 , 0 , 10 ] ; var n = arr . length ; ( checkIsAP ( arr , n ) ) ? ( document . write ( \" \" ) ) : ( document . write ( \" \" ) ) ;"}
{"text": "Kira cara memilih pasangan dengan perbezaan maksimum | Kod JavaScript untuk mencari tidak. cara memilih pasangan dengan perbezaan maksimum; Untuk mencari minimum dan maksimum array; untuk mencari kiraan elemen minimum dan maksimum; Kiraan pembolehubah; keadaan untuk semua elemen sama; Kod pemacu", "code": "function countPairs ( a , n ) { let mn = Number . MAX_VALUE ; let mx = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { mn = Math . min ( mn , a [ i ] ) ; mx = Math . max ( mx , a [ i ] ) ; } let c1 = 0 ; let c2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; } let a = [ 3 , 2 , 1 , 1 , 3 ] ; let n = a . length ; document . write ( countPairs ( a , n ) ) ;"}
{"text": "Susun semula senarai yang dipautkan dalam | Kod JavaScript untuk menyusun semula senarai yang dipautkan di tempat; Fungsi untuk menyusun semula senarai yang dipautkan dengan nilai tinggi dan rendah. ; Kes asas. ; Pembolehubah dua penunjuk. ; Fungsi swap untuk menukar data. ; Fungsi swap untuk menukar data. ; Fungsi untuk memasukkan nod dalam senarai yang dipautkan pada mulanya. ; Fungsi untuk memaparkan nod senarai yang dipautkan. ; Biarkan membuat senarai yang dipautkan. 9. 6. 8. 3. 7", "code": "class Node { constructor ( ) { this . data ; this . next = null ; } } function rearrange ( head ) { if ( head == null ) return null ; let prev = head , curr = head . next ; while ( curr != null ) { if ( prev . data > curr . data ) { let t = prev . data ; prev . data = curr . data ; curr . data = t ; } if ( curr . next != null && curr . next . data > curr . data ) { let t = curr . next . data ; curr . next . data = curr . data ; curr . data = t ; } prev = curr . next ; if ( curr . next == null ) break ; curr = curr . next . next ; } return head ; } function push ( head , k ) { let tem = new Node ( ) ; tem . data = k ; tem . next = head ; head = tem ; return head ; } function display ( head ) { let curr = head ; while ( curr != null ) { document . write ( curr . data + \" \" ) ; curr = curr . next ; } } let head = null ; head = push ( head , 7 ) ; head = push ( head , 3 ) ; head = push ( head , 8 ) ; head = push ( head , 6 ) ; head = push ( head , 9 ) ; head = rearrange ( head ) ; display ( head ) ;"}
{"text": "Susun semula senarai yang dipautkan dalam | Mewujudkan struktur untuk pelaksanaan JavaScript nod;  ; Berfungsi untuk mencetak senarai; Berfungsi untuk menyusun semula; Kami menetapkan kiri = null, apabila kita mencapai keadaan berhenti, jadi tiada pemprosesan diperlukan selepas itu; Kondisi Hentikan: Kes Ganjil: Kiri = Kanan, Malah Kes: Kiri. seterusnya = kanan; Hentikan keadaan, tetapkan null ke nod kiri; Malah kes; kes ganjil; Kod pemacu; Cetak senarai asal; Mengubah suai senarai; Cetak senarai yang diubahsuai", "code": "class Node { constructor ( val ) { this . data = val ; this . next = null ; } } var left = null ; function printlist ( head ) { while ( head != null ) { document . write ( head . data + \" \" ) ; if ( head . next != null ) { document . write ( \" \" ) ; } head = head . next ; } document . write ( \" \" ) ; } function rearrange ( head ) { if ( head != null ) { left = head ; reorderListUtil ( left ) ; } } function reorderListUtil ( right ) { if ( right == null ) { return ; } reorderListUtil ( right . next ) ; if ( left == null ) { return ; } if ( left != right && left . next != right ) { var temp = left . next ; left . next = right ; right . next = temp ; left = temp ; } else { if ( left . next == right ) { left . next . next = null ; left = null ; } else { left . next = null ; left = null ; } } } var head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 3 ) ; head . next . next . next = new Node ( 4 ) ; head . next . next . next . next = new Node ( 5 ) ; printlist ( head ) ; rearrange ( head ) ; printlist ( head ) ;"}
{"text": "Kurangkan dua nombor yang diwakili sebagai senarai yang dipautkan | Ketua Senarai; Kelas nod; Fungsi utiliti untuk mendapatkan panjang senarai yang dipautkan; Utiliti yang sifar Padds di hadapan nod, dengan perbezaan yang diberikan; Kurangkan Helper LinkedList adalah fungsi rekursif, bergerak sehingga nod terakhir, dan tolak digit dan buat nod dan kembalikan nod. Jika D1 <D2, * kami meminjam nombor dari digit sebelumnya. ; Jika anda telah memberikan nilai nilai kepada digit seterusnya maka kurangkan D1 dengan 1; Jika D1 <D2, kemudian pinjam nombor dari digit sebelumnya. Tambah 10 hingga D1 dan set Borrow = true; ; tolak digit; Buat nod dengan sub nilai; Tetapkan penunjuk seterusnya seperti sebelumnya; API ini menolak dua senarai yang dipautkan dan mengembalikan senarai yang dipautkan yang akan mempunyai hasil yang dikurangkan. ; Kes asas. ; Dalam kedua -dua kes itu, dapatkan panjang kedua -dua senarai yang dipautkan. ; Jika panjang berbeza, hitung nod yang lebih kecil dan sifar PADD untuk nod yang lebih kecil dan pastikan kedua -dua nod yang lebih besar dan nod yang lebih kecil mempunyai panjang yang sama. ; Jika kedua -dua senarai panjang adalah sama, maka hitung senarai yang lebih besar dan lebih kecil. Jika 5 - 6 - 7 & 5 - 6 - 8 adalah senarai yang dipautkan, kemudian berjalan melalui senarai yang dipautkan pada nod terakhir sebagai 7 <8, nod yang lebih besar adalah 5 - 6 - 8 dan nod yang lebih kecil ialah 5 - 6 - 7 .; Setelah mengira nod yang lebih besar dan lebih kecil, call tolakLinkedListHelper yang mengembalikan senarai yang dipautkan. ; berfungsi untuk memaparkan senarai yang dipautkan; Program Pemandu untuk diuji di atas", "code": "var head ; var borrow ; class Node { constructor ( d ) { this . data = d ; this . next = null ; } } function getLength ( node ) { var size = 0 ; while ( node != null ) { node = node . next ; size ++ ; } return size ; } function paddZeros ( sNode , diff ) { if ( sNode == null ) return null ; var zHead = new Node ( 0 ) ; diff -- ; var temp = zHead ; while ( ( diff -- ) != 0 ) { temp . next = new Node ( 0 ) ; temp = temp . next ; } temp . next = sNode ; return zHead ; } function subtractLinkedListHelper ( l1 , l2 ) { if ( l1 == null && l2 == null && borrow == false ) return null ; var previous = subtractLinkedListHelper ( ( l1 != null ) ? l1 . next : null , ( l2 != null ) ? l2 . next : null ) ; var d1 = l1 . data ; var d2 = l2 . data ; var sub = 0 ; if ( borrow ) { d1 -- ; borrow = false ; } if ( d1 < d2 ) { borrow = true ; d1 = d1 + 10 ; } sub = d1 - d2 ; var current = new Node ( sub ) ; current . next = previous ; return current ; } function subtractLinkedList ( l1 , l2 ) { if ( l1 == null && l2 == null ) return null ; var len1 = getLength ( l1 ) ; var len2 = getLength ( l2 ) ; var lNode = null , sNode = null ; var temp1 = l1 ; var temp2 = l2 ; if ( len1 != len2 ) { lNode = len1 > len2 ? l1 : l2 ; sNode = len1 > len2 ? l2 : l1 ; sNode = paddZeros ( sNode , Math . abs ( len1 - len2 ) ) ; } else { while ( l1 != null && l2 != null ) { if ( l1 . data != l2 . data ) { lNode = l1 . data > l2 . data ? temp1 : temp2 ; sNode = l1 . data > l2 . data ? temp2 : temp1 ; break ; } l1 = l1 . next ; l2 = l2 . next ; } } borrow = false ; return subtractLinkedListHelper ( lNode , sNode ) ; } function printList ( head ) { var temp = head ; while ( temp != null ) { document . write ( temp . data + \" \" ) ; temp = temp . next ; } } var head = new Node ( 1 ) ; head . next = new Node ( 0 ) ; head . next . next = new Node ( 0 ) ; var head2 = new Node ( 1 ) ; var result = subtractLinkedList ( head , head2 ) ; printList ( result ) ;"}
{"text": "Masukkan nod ke tengah senarai yang dipautkan | Ketua Senarai; Kelas nod; Pembina untuk membuat nod baru; berfungsi untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Jika senarai kosong; Dapatkan nod baru; Kirakan panjang senarai yang dipautkan, i. e, bilangan nod; 'mengira' bilangan nod yang selepas nod baru dimasukkan; 'PTR' menunjuk ke nod yang mana nod baru dimasukkan; Masukkan 'newnode' dan laraskan pautan yang diperlukan; berfungsi untuk memaparkan senarai yang dipautkan; Membuat senarai 1.2. 4.5", "code": "var head ; class Node { constructor ( d ) { this . data = d ; this . next = null ; } } function insertAtMid ( x ) { if ( head == null ) head = new Node ( x ) ; else { var newNode = new Node ( x ) ; var ptr = head ; var len = 0 ; while ( ptr != null ) { len ++ ; ptr = ptr . next ; } var count = ( ( len % 2 ) == 0 ) ? ( len / 2 ) : ( len + 1 ) / 2 ; ptr = head ; while ( count -- > 1 ) ptr = ptr . next ; newNode . next = ptr . next ; ptr . next = newNode ; } } function display ( ) { var temp = head ; while ( temp != null ) { document . write ( temp . data + \" \" ) ; temp = temp . next ; } } head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 4 ) ; head . next . next . next = new Node ( 5 ) ; document . write ( \" \" + \" \" ) ; display ( ) ; var x = 3 ; insertAtMid ( x ) ; document . write ( \" \" + \" \" ) ; display ( ) ;"}
{"text": "Masukkan nod ke tengah senarai yang dipautkan | Ketua Senarai; Kelas nod; berfungsi untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Jika senarai kosong; Dapatkan nod baru; Berikan nilai kepada petunjuk yang perlahan dan cepat; gerakkan penunjuk perlahan ke nod seterusnya; Pindahkan penunjuk cepat dua nod pada satu masa; Masukkan 'newnode' dan laraskan pautan yang diperlukan; berfungsi untuk memaparkan senarai yang dipautkan; Membuat senarai 1.2. 4.5", "code": "var head ; class Node { constructor ( val ) { this . data = val ; this . next = null ; } } function insertAtMid ( x ) { if ( head == null ) head = new Node ( x ) ; else { var newNode = new Node ( x ) ; var slow = head ; var fast = head . next ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } newNode . next = slow . next ; slow . next = newNode ; } } function display ( ) { var temp = head ; while ( temp != null ) { document . write ( temp . data + \" \" ) ; temp = temp . next ; } } head = null ; head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 4 ) ; head . next . next . next = new Node ( 5 ) ; document . write ( \" \" + \" \" ) ; display ( ) ; var x = 3 ; insertAtMid ( x ) ; document . write ( \" \" + \" \" ) ; display ( ) ;"}
{"text": "SENARAI SENSI UNTUK SENARAI DUBLY LINKED | Nod senarai dikaitkan dua kali ganda; berfungsi untuk membuat dan mengembalikan nod baru senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; berfungsi untuk memasukkan nod baru dalam cara yang disusun dalam senarai dikaitkan dua kali ganda; Jika senarai kosong; Jika nod dimasukkan pada permulaan senarai dikaitkan dua kali ganda; cari nod yang selepas itu nod baru dimasukkan; Buat pautan yang sesuai /; Jika nod baru tidak dimasukkan pada akhir senarai; Fungsi untuk menyusun senarai yang dikaitkan dua kali menggunakan jenis penyisipan; Inisialisasi 'disusun' - senarai dikaitkan dua kali ganda yang disusun; Melintasi senarai dikaitkan dua kali ganda dan masukkan setiap nod untuk 'disusun'; Simpan seterusnya untuk lelaran seterusnya; Mengeluarkan semua pautan untuk membuat 'semasa' sebagai nod baru untuk dimasukkan; Masukkan arus dalam senarai dikaitkan 'disusun'; Mengemas kini semasa; Kemas kini head_ref ke povar ke disusun senarai dua kali ganda; berfungsi untuk prvar senarai dikaitkan dua kali ganda; berfungsi untuk memasukkan nod pada permulaan senarai dikaitkan dua kali ganda; memperuntukkan nod /; masukkan data /; Buat seterusnya nod baru sebagai kepala dan sebelumnya sebagai null /; Tukar Node kepala ke nod baru /; gerakkan kepala ke Povar ke nod baru /; Mulakan dengan senarai dikaitkan dua kali ganda /; Masukkan data berikut", "code": "class Node { constructor ( val ) { this . data = val ; this . prev = null ; this . next = null ; } } function getNode ( data ) { var newNode = new Node ( ) ; newNode . data = data ; newNode . prev = newNode . next = null ; return newNode ; } function sortedInsert ( head_ref , newNode ) { var current ; if ( head_ref == null ) head_ref = newNode ; else if ( ( head_ref ) . data >= newNode . data ) { newNode . next = head_ref ; newNode . next . prev = newNode ; head_ref = newNode ; } else { current = head_ref ; while ( current . next != null && current . next . data < newNode . data ) current = current . next ; newNode . next = current . next ; if ( current . next != null ) newNode . next . prev = newNode ; current . next = newNode ; newNode . prev = current ; } return head_ref ; } function insertionSort ( head_ref ) { var sorted = null ; var current = head_ref ; while ( current != null ) { var next = current . next ; current . prev = current . next = null ; sorted = sortedInsert ( sorted , current ) ; current = next ; } head_ref = sorted ; return head_ref ; } function printList ( head ) { while ( head != null ) { document . write ( head . data + \" \" ) ; head = head . next ; } } function push ( head_ref , new_data ) { var new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = ( head_ref ) ; new_node . prev = null ; if ( ( head_ref ) != null ) ( head_ref ) . prev = new_node ; ( head_ref ) = new_node ; return head_ref ; } var head = null ; head = push ( head , 9 ) ; head = push ( head , 3 ) ; head = push ( head , 5 ) ; head = push ( head , 10 ) ; head = push ( head , 12 ) ; head = push ( head , 8 ) ; document . write ( \" \" ) ; printList ( head ) ; head = insertionSort ( head ) ; document . write ( \" \" ) ; printList ( head ) ;"}
{"text": "Cetak semua kemungkinan putaran array yang diberikan | Perisytiharan Global Array; Fungsi untuk membalikkan array antara indeks S dan E; Berfungsi untuk menjana semua kemungkinan putaran array; Kod pemacu", "code": "arr = Array . from ( { length : 10000 } , ( _ , i ) => 0 ) ; function reverse ( arr , s , e ) { while ( s < e ) { var tem = arr [ s ] ; arr [ s ] = arr [ e ] ; arr [ e ] = tem ; s = s + 1 ; e = e - 1 ; } } function fun ( arr , k ) { var n = 4 - 1 ; var v = n - k ; if ( v >= 0 ) { reverse ( arr , 0 , v ) ; reverse ( arr , v + 1 , n ) ; reverse ( arr , 0 , n ) ; } } arr [ 0 ] = 1 ; arr [ 1 ] = 2 ; arr [ 2 ] = 3 ; arr [ 3 ] = 4 ; for ( i = 0 ; i < 4 ; i ++ ) { fun ( arr , i ) ; document . write ( \" \" ) ; for ( j = 0 ; j < 4 ; j ++ ) { document . write ( arr [ j ] + \" \" ) ; } document . write ( \" \" ) ; }"}
{"text": "Cari jumlah array menggunakan bitwise atau selepas memisahkan array yang diberikan dalam dua bahagian selepas pergeseran bulat k | Program JavaScript untuk mencari bitwise atau dua bahagian yang sama dengan array selepas melakukan peralihan bulat kanan K; Array untuk menyimpan pokok segmen; Berfungsi untuk membina pokok segmen; Berfungsi untuk mengembalikan atau unsur -unsur dalam julat [l, r]; Semak keadaan terikat; Cari tengah julat; Berulang untuk semua elemen dalam pelbagai; Berfungsi untuk mencari atau jumlah; Berfungsi untuk membina pokok segmen; Gelung untuk mengendalikan pertanyaan Q; Bilangan peralihan bulat yang betul; Atau separuh kedua array [n / 2 - i, n - 1 - i]; Atau separuh pertama array [n - i, n - 1] atau [0, n / 2 - 1 - i]; Jawapan akhir prvar untuk pertanyaan; Kod pemacu", "code": "const MAX = 100005 ; var seg = Array ( 4 * MAX ) . fill ( 0 ) ; function build ( node , l , r , a ) { if ( l == r ) seg [ node ] = a [ l ] ; else { var mid = parseInt ( ( l + r ) / 2 ) ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } } function query ( node , l , r , start , end , a ) { if ( l > end r < start ) return 0 ; if ( start <= l && r <= end ) return seg [ node ] ; var mid = parseInt ( ( l + r ) / 2 ) ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; } function orsum ( a , n , q , k ) { build ( 1 , 0 , n - 1 , a ) ; for ( j = 0 ; j < q ; j ++ ) { var i = k [ j ] % ( n / 2 ) ; var sec = query ( 1 , 0 , n - 1 , n / 2 - i , n - i - 1 , a ) ; var first = ( query ( 1 , 0 , n - 1 , 0 , n / 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) ; var temp = sec + first ; document . write ( temp + \" \" ) ; } } var a = [ 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 ] ; var n = a . length ; var q = 2 ; var k = [ 4 , 2 ] ; orsum ( a , n , q , k ) ;"}
{"text": "Memaksimumkan kiraan unsur -unsur yang sama dalam tatasusunan yang diberikan oleh putaran | Fungsi yang prlet elemen maksimum yang sama; Vektor untuk menyimpan indeks elemen array b; Menyimpan kedudukan array b; Arahan frekuensi untuk mengekalkan unsur -unsur dengan perbezaan yang sama dalam jarak; Melangkah melalui semua elemen dalam ARR1 []; Kirakan bilangan peralihan yang diperlukan untuk menjadikan elemen semasa sama; Jika D kurang daripada 0; Simpan kekerapan perbezaan semasa; Kirakan kekerapan maksimum yang disimpan; Mencetak bilangan maksimum elemen yang sama; Diberikan dua tatasusunan; Panggilan fungsi", "code": "function maximumEqual ( a , b , n ) { let store = Array . from ( { length : 1e5 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; } let ans = Array . from ( { length : 1e5 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { let d = Math . abs ( store [ a [ i ] ] - ( i + 1 ) ) ; if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; } ans [ d ] ++ ; } let finalans = 0 ; for ( let i = 0 ; i < 1e5 ; i ++ ) finalans = Math . max ( finalans , ans [ i ] ) ; document . write ( finalans + \" \" ) ; } let A = [ 6 , 7 , 3 , 9 , 5 ] ; let B = [ 7 , 3 , 9 , 5 , 6 ] ; let size = A . length ; maximumEqual ( A , B , size ) ;"}
{"text": "Arahan cetak selepas ia betul -betul diputar k kali | Berfungsi untuk array rightrotate; Jika putaran lebih besar daripada saiz array; Mencetak elemen kth paling kanan; Cetak array selepas elemen 'k'; Kod pemacu", "code": "function RightRotate ( a , n , k ) { k = k % n ; for ( let i = 0 ; i < n ; i ++ ) { if ( i < k ) { document . write ( a [ n + i - k ] + \" \" ) ; } else { document . write ( ( a [ i - k ] ) + \" \" ) ; } } document . write ( \" \" ) ; } let Array = [ 1 , 2 , 3 , 4 , 5 ] ; let N = Array . length ; let K = 2 ; RightRotate ( Array , N , K ) ;"}
{"text": "Sort Array Disusun Berputar | Berfungsi untuk memulihkan jenis asal; Dalam sebaliknya (), parameter pertama adalah iterator untuk memulakan elemen dan parameter kedua adalah iterator untuk elemen terakhir ditambah satu. ; Berfungsi untuk mencetak array; Kod pemacu", "code": "function restoreSortedArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { reverse ( arr , 0 , i ) ; reverse ( arr , i + 1 , n ) ; reverse ( arr , 0 , n ) ; } } } function reverse ( arr , i , j ) { let temp ; while ( i < j ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i ++ ; j -- ; } } function printArray ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) document . write ( arr [ i ] + \" \" ) ; } let arr = [ 3 , 4 , 5 , 1 , 2 ] ; let n = arr . length ; restoreSortedArray ( arr , n - 1 ) ; printArray ( arr , n )"}
{"text": "Sort Array Disusun Berputar | Fungsi untuk mencari indeks permulaan array; Berfungsi untuk memulihkan jenis asal; Array sudah disusun; Dalam sebaliknya (), parameter pertama adalah iterator untuk memulakan elemen dan parameter kedua adalah iterator untuk elemen terakhir ditambah satu. ; Berfungsi untuk mencetak array; Kod pemacu", "code": "function findStartIndexOfArray ( arr , low , high ) { if ( low > high ) { return - 1 ; } if ( low == high ) { return low ; } let mid = low + parseInt ( ( high - low ) / 2 , 10 ) ; if ( arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( arr [ mid - 1 ] > arr [ mid ] ) { return mid ; } if ( arr [ low ] > arr [ mid ] ) { return findStartIndexOfArray ( arr , low , mid - 1 ) ; } else { return findStartIndexOfArray ( arr , mid + 1 , high ) ; } } function restoreSortedArray ( arr , n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) { return ; } let start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; arr . sort ( ) ; } function printArray ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; } } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let n = arr . length ; restoreSortedArray ( arr , n ) ; printArray ( arr , n ) ;"}
{"text": "Putaran kiri dan putaran kanan rentetan | Fungsi yang berputar ke kiri oleh D; Fungsi yang berputar ke arah kanan oleh D; Kod pemacu", "code": "function leftrotate ( str , d ) { var ans = str . substring ( d , str . length ) + str . substring ( 0 , d ) ; return ans ; } function rightrotate ( str , d ) { return leftrotate ( str , str . length - d ) ; } var str1 = \" \" ; document . write ( leftrotate ( str1 , 2 ) + \" \" ) ; var str2 = \" \" ; document . write ( rightrotate ( str2 , 2 ) + \" \" ) ;"}
{"text": "Cari elemen dalam Senarai Berkaitan Pekeliling Ganda | Struktur nod; Berfungsi untuk memasukkan nod pada akhir; Jika senarai kosong, buat satu pekeliling nod tunggal dan senarai dua kali ganda; Cari nod terakhir /; Buat nod secara dinamik; Mula akan menjadi yang akan datang dengan New_node; Buat nod baru sebelum permulaan; Membuat nod baru yang terakhir; Buat nod baru yang akan datang yang terakhir; Berfungsi untuk memaparkan senarai dikaitkan dua kali ganda; Berfungsi untuk mencari elemen tertentu dari senarai; Mengisytiharkan pemboleh ubah temp; Mengisytiharkan pemboleh ubah kawalan lain untuk mencari; Jika permulaan adalah NULL RETURN - 1; Gerakkan penunjuk temp sehingga, temp. Seterusnya tidak memindahkan alamat permulaan (fesyen bulat); Kiraan kenaikan lokasi; Jika didapati menaikkan bendera dan memecahkan gelung; Penunjuk suhu kenaikan; Semak sama ada elemen terakhir dalam kandungan senarai nilai jika mengandungi, menaikkan bendera dan kiraan kenaikan; Jika bendera adalah benar, maka unsur dijumpai, lain tidak; Mulakan dengan senarai kosong /; Masukkan 4. Jadi senarai yang dipautkan menjadi 4. NULL; Masukkan 5. Jadi senarai yang dipautkan menjadi 4.5; Masukkan 7. Jadi senarai yang dipautkan menjadi 4.5. 7; Masukkan 8. Jadi senarai yang dipautkan menjadi 4.5. 7.8; Masukkan 6. Jadi senarai yang dipautkan menjadi 4.5. 7.8. 6", "code": "class Node { constructor ( ) { this . data = 0 ; this . next = this . prev = null ; } } function insertNode ( start , value ) { if ( start == null ) { let new_node = new Node ( ) ; new_node . data = value ; new_node . next = new_node . prev = new_node ; start = new_node ; return new_node ; } let last = ( start ) . prev ; let new_node = new Node ( ) ; new_node . data = value ; new_node . next = start ; ( start ) . prev = new_node ; new_node . prev = last ; last . next = new_node ; return start ; } function displayList ( start ) { let temp = start ; while ( temp . next != start ) { document . write ( temp . data + \" \" ) ; temp = temp . next ; } document . write ( temp . data + \" \" ) ; } function searchList ( start , search ) { let temp = start ; let count = 0 , flag = 0 , value ; if ( temp == null ) return - 1 ; else { while ( temp . next != start ) { count ++ ; if ( temp . data == search ) { flag = 1 ; count -- ; break ; } temp = temp . next ; } if ( temp . data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) document . write ( \" \" + search + \" \" + count ) ; else document . write ( \" \" + search + \" \" ) ; } return - 1 ; } let start = null ; start = insertNode ( start , 4 ) ; start = insertNode ( start , 5 ) ; start = insertNode ( start , 7 ) ; start = insertNode ( start , 8 ) ; start = insertNode ( start , 6 ) ; document . write ( \" \" ) ; displayList ( start ) ; searchList ( start , 5 ) ;"}
{"text": "Membalikkan senarai dikaitkan bulat berganda | struktur nod senarai yang dipautkan; berfungsi untuk membuat dan mengembalikan nod baru; Berfungsi untuk memasukkan pada akhir; Jika senarai kosong, buat satu pekeliling nod tunggal dan senarai dua kali ganda; Cari nod terakhir /; Mula akan menjadi yang akan datang dengan New_node; Buat nod baru sebelum permulaan; Membuat nod baru yang terakhir; Buat nod baru yang akan datang yang terakhir; Fungsi uitlity untuk mengulangi senarai dikaitkan bulat dua kali ganda; Memulakan penunjuk kepala baru; Dapatkan penunjuk ke nod terakhir; Tetapkan 'curr' ke nod terakhir; senarai melintasi arah ke belakang; Masukkan 'curr' pada akhir senarai bermula dengan penunjuk 'baru _ kepala'; penunjuk kepala senarai terbalik; berfungsi untuk memaparkan senarai bulat berganda dalam arah ke hadapan dan ke belakang; Kod pemacu", "code": "class Node { constructor ( ) { this . data = 0 ; this . next = null ; this . prev = null ; } } function getNode ( data ) { var newNode = new Node ( ) ; newNode . data = data ; return newNode ; } function insertEnd ( head , new_node ) { if ( head == null ) { new_node . next = new_node . prev = new_node ; head = new_node ; return head ; } var last = head . prev ; new_node . next = head ; head . prev = new_node ; new_node . prev = last ; last . next = new_node ; return head ; } function reverse ( head ) { if ( head == null ) return null ; var new_head = null ; var last = head . prev ; var curr = last , prev ; while ( curr . prev != last ) { prev = curr . prev ; new_head = insertEnd ( new_head , curr ) ; curr = prev ; } new_head = insertEnd ( new_head , curr ) ; return new_head ; } function display ( head ) { if ( head == null ) return ; var temp = head ; document . write ( \" \" ) ; while ( temp . next != head ) { document . write ( temp . data + \" \" ) ; temp = temp . next ; } document . write ( temp . data + \" \" ) ; var last = head . prev ; temp = last ; document . write ( \" \" ) ; while ( temp . prev != last ) { document . write ( temp . data + \" \" ) ; temp = temp . prev ; } document . write ( temp . data + \" \" ) ; } var head = null ; head = insertEnd ( head , getNode ( 1 ) ) ; head = insertEnd ( head , getNode ( 2 ) ) ; head = insertEnd ( head , getNode ( 3 ) ) ; head = insertEnd ( head , getNode ( 4 ) ) ; head = insertEnd ( head , getNode ( 5 ) ) ; document . write ( \" \" ) ; display ( head ) ; head = reverse ( head ) ; document . write ( \" \" ) ; display ( head ) ;"}
{"text": "SQRT (atau Square Root) Penguraian | Tetapkan 2 (LCA pokok dalam O (sqrt (ketinggian)) masa) | Pelaksanaan Javascrit naif untuk mencari LCA di dalam pokok. ; Kedalaman kedai untuk setiap nod; Kedai ibu bapa pertama untuk setiap nod; Menandakan ibu bapa untuk setiap nod; Menandakan kedalaman untuk setiap nod; Propogating menandakan pokok itu; Nod dummy; Precalclating 1) kedalaman. 2) ibu bapa. untuk setiap nod; Kerumitan masa: O (ketinggian pokok) secara rekursif melompat satu nod di atas sehingga kedua -dua nod menjadi sama; Kod pemacu; Menambah tepi ke pokok", "code": "var MAXN = 1001 ; var depth = Array ( MAXN ) ; var parent = Array ( MAXN ) ; var adj = Array . from ( Array ( MAXN ) , ( ) => Array ( ) ) ; function addEdge ( u , v ) { adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; } function dfs ( cur , prev ) { parent [ cur ] = prev ; depth [ cur ] = depth [ prev ] + 1 ; for ( var i = 0 ; i < adj [ cur ] . length ; i ++ ) if ( adj [ cur ] [ i ] != prev ) dfs ( adj [ cur ] [ i ] , cur ) ; } function preprocess ( ) { depth [ 0 ] = - 1 ; dfs ( 1 , 0 ) ; } function LCANaive ( u , v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { var temp = u ; u = v ; v = temp ; } v = parent [ v ] ; return LCANaive ( u , v ) ; } for ( var i = 0 ; i < MAXN ; i ++ ) adj [ i ] = [ ] ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; preprocess ( ) ; document . write ( \" \" + LCANaive ( 11 , 8 ) + \" \" ) ; document . write ( \" \" + LCANaive ( 3 , 13 ) ) ;"}
{"text": "SQRT (atau Square Root) Penguraian | Tetapkan 2 (LCA pokok dalam O (sqrt (ketinggian)) masa) | Program JavaScript untuk mencari LCA menggunakan penguraian SQRT; Saiz blok = matematik. sqrt (ketinggian); Kedalaman kedai untuk setiap nod; Kedai ibu bapa pertama untuk setiap nod; Kedai nenek moyang pertama di blok sebelumnya; Mempraktikkan parameter yang diperlukan yang berkaitan dengan setiap nod; Menandakan kedalaman node cur; Menandakan ibu bapa node cur; Membuat jump_parent node cur; Jika ia adalah nod pertama blok maka jump_parentnya adalah ibu bapa yang curnya; Jika bukan nod pertama blok ini maka jump_parentnya adalah jump_parent ibu bapanya; Propogating menandakan subtree; Menggunakan helah penguraian SQRT; Mengekalkan kedalaman [v]> kedalaman [u]; Mendaki ke ibu bapa melompatnya; u dan v mempunyai jump_parent yang sama; Precalclating 1) kedalaman. 2) ibu bapa. 3) Jump_parent untuk setiap nod; Kod pemacu; Menambah tepi ke pokok; Di sini kita terus mengambil ketinggian = 4 mengikut pokok yang diberikan tetapi kita boleh mengira ketinggian = kedalaman maksimum dalam satu lagi dfs", "code": "let MAXN = 1001 ; let block_sz ; let depth = new Array ( MAXN ) ; let parent = new Array ( MAXN ) ; let jump_parent = new Array ( MAXN ) ; let adj = new Array ( MAXN ) ; function addEdge ( u , v ) { adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; } function LCANaive ( u , v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { let t = u ; u = v ; v = t ; } v = parent [ v ] ; return LCANaive ( u , v ) ; } function dfs ( cur , prev ) { depth [ cur ] = depth [ prev ] + 1 ; parent [ cur ] = prev ; if ( depth [ cur ] % block_sz == 0 ) jump_parent [ cur ] = parent [ cur ] ; else jump_parent [ cur ] = jump_parent [ prev ] ; for ( let i = 0 ; i < adj [ cur ] . length ; ++ i ) if ( adj [ cur ] [ i ] != prev ) dfs ( adj [ cur ] [ i ] , cur ) ; } function LCASQRT ( u , v ) { while ( jump_parent [ u ] != jump_parent [ v ] ) { if ( depth [ u ] > depth [ v ] ) { let t = u ; u = v ; v = t ; } v = jump_parent [ v ] ; } return LCANaive ( u , v ) ; } function preprocess ( height ) { block_sz = parseInt ( Math . sqrt ( height ) , 10 ) ; depth [ 0 ] = - 1 ; dfs ( 1 , 0 ) ; } for ( let i = 0 ; i < adj . length ; i ++ ) adj [ i ] = [ ] ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; let height = 4 ; preprocess ( height ) ; document . write ( \" \" + LCASQRT ( 11 , 8 ) + \" \" ) ; document . write ( \" \" + LCASQRT ( 3 , 13 ) + \" \" ) ;"}
{"text": "Bilangan ujian yang dijangkakan untuk mendapatkan kepala berturut -turut n | Kod pemacu; Formula untuk bilangan laluan untuk kepala berturut -turut n", "code": "let N = 3 ; document . write ( Math . pow ( 2 , N + 1 ) - 2 ) ;"}
{"text": "Cari dan kirakan jumlah faktor Co | Berfungsi untuk mengembalikan kiraan nombor yang boleh dibahagikan oleh kedua -dua A dan B dalam julat [1, n] dalam masa yang berterusan; Kirakan kiraan nombor yang boleh dibahagikan dengan A dalam julat [1, n]; Kirakan kiraan nombor yang boleh dibahagi dengan b dalam julat [1, n]; Menambah tuduhan yang boleh dibahagikan oleh A dan B; Nilai di atas mungkin mengandungi nilai berulang yang boleh dibahagikan oleh kedua -dua A dan B. Oleh itu, kiraan nombor yang boleh dibahagikan oleh kedua -dua A dan B ditemui; Kiraan yang dikira di atas dikurangkan untuk mengira kiraan akhir; Berfungsi untuk mengembalikan jumlah nombor yang boleh dibahagikan oleh kedua -dua A dan B dalam julat [1, n]; Tetapkan untuk menyimpan nombor supaya nombor tidak diulang; Untuk gelung untuk mencari nombor yang boleh dibahagikan dengan A dan masukkannya ke dalam set; Untuk gelung untuk mencari nombor yang boleh dibahagikan dengan A dan masukkannya ke dalam set; Untuk gelung untuk melangkah melalui set dan cari jumlahnya; Kod pemacu", "code": "function countOfNum ( n , a , b ) { let cnt_of_a , cnt_of_b , cnt_of_ab , sum ; cnt_of_a = Math . floor ( n / a ) ; cnt_of_b = Math . floor ( n / b ) ; sum = cnt_of_b + cnt_of_a ; cnt_of_ab = Math . floor ( n / ( a * b ) ) ; sum = sum - cnt_of_ab ; return sum ; } function sumOfNum ( n , a , b ) { let i ; let sum = 0 ; let ans = new Set ( ) ; for ( i = a ; i <= n ; i = i + a ) { ans . add ( i ) ; } for ( i = b ; i <= n ; i = i + b ) { ans . add ( i ) ; } for ( let it of ans . values ( ) ) { sum = sum + it ; } return sum ; } let N = 88 ; let A = 11 ; let B = 8 ; let count = countOfNum ( N , A , B ) ; let sumofnum = sumOfNum ( N , A , B ) ; document . write ( sumofnum % count ) ;"}
{"text": "Cari nilai julat ungkapan | Berfungsi untuk mengembalikan nilai ungkapan yang diberikan; Nilai istilah pertama; Nilai istilah terakhir; Kod pemacu; Dapatkan hasilnya", "code": "function get ( L , R ) { let x = 1.0 / L ; let y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; } let L = 6 , R = 12 ; let ans = get ( L , R ) ; document . write ( Math . round ( ans * 100 ) / 100 ) ;"}
{"text": "Cari elemen yang lebih besar seterusnya tanpa berturut -turut 1 dalam perwakilan binari itu | Pelaksanaan JavaScript pendekatan; Untuk menyimpan bilangan bulat pra -dikira; Fungsi yang mengembalikan benar jika perwakilan binari x mengandungi 1 s; Untuk menyimpan sedikit sebelumnya; Semak sama ada bit sebelumnya dan bit semasa adalah kedua -dua 1; Mengemas kini sedikit sebelumnya; Pergi ke bit seterusnya; Fungsi untuk pra - mengira nombor yang sah dari 0 hingga maksimum; Simpan semua nombor yang tidak mempunyai 1 s berturut -turut; Berfungsi untuk mengembalikan nombor minimum yang lebih besar daripada n yang tidak mengandungi 1 s berturut -turut; Cari elemen yang lebih besar seterusnya tanpa berturut -turut 1 s; Berfungsi untuk melakukan pertanyaan; Kod pemacu; Pra - mengira nombor; Lakukan pertanyaan", "code": "const MAX = 100000 ; let v = [ ] ; function upper_bound ( ar , k ) { let s = 0 ; let e = ar . length ; while ( s != e ) { let mid = s + e >> 1 ; if ( ar [ mid ] <= k ) { s = mid + 1 ; } else { e = mid ; } } if ( s == ar . length ) { return - 1 ; } return s ; } function consecutiveOnes ( x ) { let p = 0 ; while ( x > 0 ) { if ( x % 2 == 1 && p == 1 ) return true ; p = x % 2 ; x = parseInt ( x / 2 ) ; } return false ; } function preCompute ( ) { for ( let i = 0 ; i <= MAX ; i ++ ) { if ( ! consecutiveOnes ( i ) ) v . push ( i ) ; } } function nextValid ( n ) { let it = upper_bound ( v , n ) ; let val = v [ it ] ; return val ; } function performQueries ( queries , q ) { for ( let i = 0 ; i < q ; i ++ ) document . write ( nextValid ( queries [ i ] ) + \" \" ) ; } let queries = [ 4 , 6 ] ; let q = queries . length ; preCompute ( ) ; performQueries ( queries , q ) ;"}
{"text": "Operasi minimum yang diperlukan untuk menukar rentetan binari yang diberikan kepada semua 1 s | Berfungsi untuk mengembalikan bilangan operasi yang diperlukan; CTR akan menyimpan bilangan yang berturut -turut pada akhir rentetan binari yang diberikan; Gelung untuk mencari bilangan 1 s pada akhir rentetan; Jika watak semasa adalah 1; Jika kita menghadapi 0 pertama dari kedudukan LSB maka kita akan memecahkan gelung; Bilangan operasi yang diperlukan ialah (L - CTR); Berfungsi untuk mengeluarkan sifar utama dari rentetan; Gelung sehingga S [i] menjadi tidak sama dengan 1; Jika kita sampai ke hujung rentetan, ini bermakna rentetan hanya mengandungi 0 's; Kembalikan rentetan tanpa nol utama; Kod pemacu; Mengeluarkan sifar terkemuka", "code": "function changeToOnes ( str ) { var i , l , ctr = 0 ; l = str . length ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) ctr ++ ; else break ; } return l - ctr ; } function removeZeroesFromFront ( str ) { var s ; var i = 0 ; while ( i < str . length && str [ i ] == ' ' ) i ++ ; if ( i == str . length ) s = \" \" ; else s = str . substring ( i , str . length - i ) ; return s ; } var str = \" \" ; str = removeZeroesFromFront ( str ) ; document . write ( changeToOnes ( str ) ) ;"}
{"text": "Penghapusan minimum diperlukan sedemikian rupa sehingga mana -mana nombor x akan berlaku tepat x kali | Berfungsi untuk mengembalikan penghapusan minimum yang diperlukan; Untuk menyimpan kekerapan elemen array; Kekerapan kedai setiap elemen; Untuk menyimpan penghapusan minimum yang diperlukan; Nilai; Kekerapan itu; Jika bilangan kurang daripada atau sama dengan kekerapannya; Padam kejadian tambahan; Padam setiap kejadian x; Kod pemacu", "code": "function MinDeletion ( a , n ) { let map = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( map [ a [ i ] ] ) map [ a [ i ] ] ++ ; else map [ a [ i ] ] = 1 } let ans = 0 ; for ( var m in map ) { let x = m ; let frequency = map [ m ] ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } ; return ans ; } let a = [ 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 ] ; let n = a . length ; document . write ( MinDeletion ( a , n ) ) ;"}
{"text": "Rentetan concatenate dalam apa -apa perintah untuk mendapatkan bilangan maksimum \"ab\" | Berfungsi untuk mencari bilangan maksimum abs; Pembolehubah A, B, AB untuk mengira rentetan yang berakhir dengan 'A' tetapi tidak berakhir dengan 'B', 'B' tetapi tidak berakhir dengan 'A' dan 'B' dan berakhir dengan 'A' masing -masing. ; 'Ab' sudah ada dalam rentetan sebelum menggabungkan mereka; Count rentetan yang bermula dengan 'B' dan berakhir dengan 'A; Count rentetan yang bermula dengan 'B' tetapi tidak berakhir dengan 'A'; Count rentetan yang berakhir dengan 'a' tetapi tidak berakhir dengan 'b'; mengemas kini nilai ANS dan menambah kiraan tambahan 'ab'; Kod pemacu", "code": "function maxCountAB ( s , n ) { var A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var S = s [ i ] ; var L = S . length ; for ( var j = 0 ; j < L - 1 ; j ++ ) { if ( S [ j ] == ' ' && S [ j + 1 ] == ' ' ) { ans ++ ; } } if ( S [ 0 ] == ' ' && S [ L - 1 ] == ' ' ) BA ++ ; else if ( S [ 0 ] == ' ' ) B ++ ; else if ( S [ L - 1 ] == ' ' ) A ++ ; } if ( BA == 0 ) ans += Math . min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . min ( B , A ) ; return ans ; } var s = [ \" \" , \" \" , \" \" ] ; var n = s . length ; document . write ( maxCountAB ( s , n ) ) ;"}
{"text": "Operasi minimum untuk membuat jumlah elemen jiran <= x | Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan; Untuk menyimpan jumlah operasi yang diperlukan; Mula -mula membuat semua elemen sama dengan x yang lebih besar; Kiri mengimbas array; Kemas kini elemen semasa supaya jumlah jiran adalah <x; Kod pemacu", "code": "function MinOperations ( n , x , arr ) { let total = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > x ) { let difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } } for ( let i = 1 ; i < n ; ++ i ) { let LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ; if ( LeftNeigbouringSum > x ) { let current_diff = LeftNeigbouringSum - x ; arr [ i ] = Math . max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; } let X = 1 ; let arr = [ 1 , 6 , 1 , 2 , 0 , 4 ] ; let N = arr . length ; document . write ( MinOperations ( N , X , arr ) + \" \" ) ;"}
{"text": "Cari nombor berulang dan nombor yang hilang menggunakan dua persamaan | Berfungsi untuk mencetak nombor yang diperlukan; Jumlah nombor semulajadi n pertama; Jumlah kuadrat nombor semulajadi n pertama; Untuk menyimpan jumlah dan jumlah kuadrat unsur -unsur array; Kod pemacu", "code": "function findNumbers ( arr , n ) { sumN = ( n * ( n + 1 ) ) / 2 ; sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; let sum = 0 ; let sumSq = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += Math . pow ( arr [ i ] , 2 ) ; } B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; A = sum - sumN + B ; document . write ( \" \" + A , \" \" , B ) ; } let arr = [ 1 , 2 , 2 , 3 , 4 ] ; n = arr . length ; findNumbers ( arr , n ) ;"}
{"text": "Rentetan terkecil lexicographically dengan rentetan yang diberikan sebagai awalan | Berfungsi untuk mencari sama ada temp rentetan bermula dengan STR atau tidak; Kes asas; Semak aksara yang sepadan dalam temp & str; Berfungsi untuk mencari rentetan terkecil lexicographic yang terdiri daripada string str as awalan; Susun rentetan array yang diberikan []; Jika rentetan i - th mengandungi rentetan yang diberikan sebagai awalan, maka cetak hasilnya; Jika tiada rentetan wujud maka kembali \" - 1\"; Kod pemacu", "code": "function is_prefix ( temp , str ) { if ( temp . length < str . length ) return 0 ; else { for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] != temp [ i ] ) return 0 ; } return 1 ; } } function lexicographicallyString ( input , n , str ) { input = Array . from ( input ) . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let temp = input [ i ] ; if ( is_prefix ( temp , str ) ) { return temp ; } } return \" \" ; } let arr = [ \" \" , \" \" , \" \" , \" \" , \" \" ] ; let S = \" \" ; let N = 5 ; document . write ( lexicographicallyString ( arr , N , S ) ) ;"}
{"text": "Susun semula Arahan untuk mencari K menggunakan algoritma carian binari tanpa menyusun | Berfungsi untuk menyusun semula array; Menyimpan array yang disusun semula; Kedai sama ada pengaturan itu mungkin atau tidak; Kemas kini k dengan kedudukan k; Menyimpan semua elemen yang lebih rendah daripada dan lebih besar daripada vektor yang lebih kecil dan lebih besar masing -masing; Melintasi array arr []; Jika arr [i] kurang daripada arr [k]; Lain; Iterat Unil Low kurang daripada atau sama dengan tinggi; Kedai pertengahan titik; Jika pertengahan adalah sama dengan k; Jika pertengahan kurang daripada k; Jika pertengahan lebih besar daripada k; Jika f adalah - 1; Melangkah dalam julat [1, n]; Jika Ans [i] sama dengan - 1; Cetak array yang disusun semula; Input; Panggilan fungsi", "code": "function Rearrange ( arr , K , N ) { let ans = new Array ( N + 1 ) ; let f = - 1 ; for ( let i = 0 ; i < N ; i ++ ) { ans [ i ] = - 1 ; } for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == K ) { K = i ; break ; } } let smaller = [ ] ; let greater = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ K ] ) smaller . push ( arr [ i ] ) ; else if ( arr [ i ] > arr [ K ] ) greater . push ( arr [ i ] ) ; } let low = 0 , high = N - 1 ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( mid == K ) { ans [ mid ] = arr [ K ] ; f = 1 ; break ; } else if ( mid < K ) { if ( smaller . length == 0 ) { break ; } ans [ mid ] = smaller [ smaller . length - 1 ] ; smaller . pop ( ) ; low = mid + 1 ; } else { if ( greater . length == 0 ) { break ; } ans [ mid ] = greater [ greater . length - 1 ] ; greater . pop ( ) ; high = mid - 1 ; } } if ( f == - 1 ) { document . write ( - 1 ) ; return ; } for ( let i = 0 ; i < N ; i ++ ) { if ( ans [ i ] == - 1 ) { if ( smaller . length != 0 ) { ans [ i ] = smaller [ smaller . length - 1 ] ; smaller . pop ( ) ; } else if ( greater . length != 0 ) { ans [ i ] = greater [ greater . length - 1 ] ; greater . pop ; } } } for ( let i = 0 ; i < N ; i ++ ) document . write ( ans [ i ] + \" \" ) ; document . write ( \" \" ) } let arr = [ 10 , 7 , 2 , 5 , 3 , 8 ] ; let K = 7 ; let N = arr . length ; Rearrange ( arr , K , N ) ;"}
{"text": "Kurangkan k untuk membiarkan orang mengambil sekurang -kurangnya ceil (n / (m + 1)) gula -gula berdasarkan peraturan yang diberikan | Fungsi untuk mencari nilai minimum k supaya orang pertama mendapat sekurang -kurangnya (n / (m + 1)) gula -gula; Cari nilai gula -gula minimum yang diperlukan untuk orang pertama; ITERATE K dari [1, n]; Jumlah gula -gula; Gula -gula yang diambil oleh orang 1; Gula -gula yang diambil oleh 1 orang adalah minimum k dan gula -gula yang tersisa; Melintasi array arr []; Jumlah yang digunakan oleh orang j; Mengemas kini bilangan gula -gula; Bahagian yang baik dari gula -gula yang dicapai; Kod pemacu", "code": "function minimumK ( arr , M , N ) { let good = Math . floor ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) + 1 ; for ( let i = 1 ; i <= N ; i ++ ) { let K = i ; let candies = N ; let taken = 0 ; while ( candies > 0 ) { taken += Math . min ( K , candies ) ; candies -= Math . min ( K , candies ) ; for ( let j = 0 ; j < M ; j ++ ) { let consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } if ( taken >= good ) { document . write ( i ) ; return ; } } } let N = 13 , M = 1 ; let arr = new Array ( ) ; arr . push ( 50 ) ; minimumK ( arr , M , N ) ;"}
{"text": "Jumlah masa yang diperlukan untuk mengembara jalan yang dilambangkan oleh rentetan yang diberikan | Fungsi untuk mengira masa yang diambil untuk perjalanan jalan; Kedai jumlah masa; Kedudukan awal; Kedai -kedai melawat segmen; Semak sama ada segmen hadir dalam set; Meningkatkan nilai masa dengan 2; Masukkan segmen ke dalam set; Cetak nilai masa; Kod pemacu", "code": "function calcTotalTime ( path ) { var time = 0 ; var x = 0 , y = 0 ; var s = new Set ( ) ; for ( var i = 0 ; i < path . length ; i ++ ) { var p = x ; var q = y ; if ( path [ i ] == ' ' ) y ++ ; else if ( path [ i ] == ' ' ) y -- ; else if ( path [ i ] == ' ' ) x ++ ; else if ( path [ i ] == ' ' ) x -- ; if ( ! s . has ( [ p + x , q + y ] . toString ( ) ) ) { time += 2 ; s . add ( [ p + x , q + y ] . toString ( ) ) ; } else time += 1 ; } document . write ( time ) } var path = \" \" ; calcTotalTime ( path ) ;"}
{"text": "Kos yang diperlukan untuk menjadikan semua elemen array sama dengan 1 | Fungsi untuk mengira kos yang diperlukan untuk membuat semua elemen array sama dengan 1; Menyimpan jumlah kos; Melintasi array arr []; Jika elemen semasa ialah 0; Tukar 0 hingga 1; Tambah kos; Mengembalikan jumlah kos; Kod pemacu", "code": "function findCost ( A , N ) { var totalCost = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; } var arr = [ 1 , 0 , 1 , 0 , 1 , 0 ] var N = arr . length document . write ( findCost ( arr , N ) ) ;"}
{"text": "Cari indeks puncak array yang diberikan | Fungsi untuk mencari indeks puncak untuk array yang diberikan; Kes asas; Semak array yang semakin meningkat; Sekiranya keadaan yang semakin meningkat dilanggar, maka pecah; Menyimpan nilai i, yang merupakan indeks puncak yang berpotensi; Traversal kedua, untuk array yang ketat; Apabila keadaan ketat yang dikurangkan dilanggar, kemudian pecah; Jika i = n - 1, ini bermakna bahawa ANS adalah indeks puncak; Jika tidak, indeks puncak tidak wujud; Kod pemacu", "code": "function peakIndex ( arr ) { var N = arr . length ; if ( arr . length < 3 ) return - 1 ; var i = 0 ; while ( i + 1 < N ) { if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return - 1 ; var ans = i ; while ( i < N - 1 ) { if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == N - 1 ) return ans ; return - 1 ; } var arr = [ 0 , 1 , 0 ] ; document . write ( peakIndex ( arr ) ) ;"}
{"text": "Memandangkan array A [] dan nombor x, periksa pasangan dalam [] dengan jumlah sebagai x | Tetapkan 2 | Fungsi untuk memeriksa sama ada array mempunyai 2 elemen yang jumlahnya sama dengan nilai yang diberikan; Menyusun array dalam peningkatan urutan; Melintasi array, nums []; Simpan nombor yang diperlukan untuk dijumpai; Melakukan carian binari; Simpan nilai pertengahan; Jika nums [mid] lebih besar daripada x, maka kemas kini tinggi hingga pertengahan - 1; Jika Nums [Mid] kurang daripada X, maka kemas kini rendah hingga pertengahan + 1; Jika tidak; Jika pertengahan adalah sama i, periksa pertengahan - 1 dan pertengahan + 1; Jika tidak, cetak pasangan dan kembali; Jika tidak ada pasangan yang dijumpai, maka cetak - 1; Kod pemacu; Panggilan fungsi", "code": "function hasArrayTwoPairs ( nums , n , target ) { nums . sort ( ) ; var i ; for ( i = 0 ; i < n ; i ++ ) { var x = target - nums [ i ] ; var low = 0 , high = n - 1 ; while ( low <= high ) { var mid = low + ( Math . floor ( ( high - low ) / 2 ) ) ; if ( nums [ mid ] > x ) { high = mid - 1 ; } else if ( nums [ mid ] < x ) { low = mid + 1 ; } else { if ( mid == i ) { if ( ( mid - 1 >= 0 ) && nums [ mid - 1 ] == x ) { document . write ( nums [ i ] + \" \" ) ; document . write ( nums [ mid - 1 ] ) ; return ; } if ( ( mid + 1 < n ) && nums [ mid + 1 ] == x ) { document . write ( nums [ i ] + \" \" ) ; document . write ( nums [ mid + 1 ] ) ; return ; } break ; } else { document . write ( nums [ i ] + \" \" ) ; document . write ( nums [ mid ] ) ; return ; } } } } document . write ( - 1 ) ; } var A = [ 0 , - 1 , 2 , - 3 , 1 ] ; var X = - 2 ; var N = A . length ; hasArrayTwoPairs ( A , N , X ) ;"}
{"text": "Pembahagi terkecil n paling dekat dengan x | Berfungsi untuk mencari pembahagi n paling dekat dengan sasaran; Berulang sehingga akar persegi n; Semak jika pembahagi adalah sama; Semak jika saya adalah yang paling dekat; Semak jika saya adalah yang paling dekat; Semak jika N / I adalah yang paling dekat; Cetak nilai terdekat; Diberikan N & X; Panggilan fungsi", "code": "function findClosest ( N , target ) { let closest = - 1 ; let diff = Number . MAX_VALUE ; for ( let i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( N / i == i ) { if ( Math . abs ( target - i ) < diff ) { diff = Math . abs ( target - i ) ; closest = i ; } } else { if ( Math . abs ( target - i ) < diff ) { diff = Math . abs ( target - i ) ; closest = i ; } if ( Math . abs ( target - N / i ) < diff ) { diff = Math . abs ( target - N / i ) ; closest = N / i ; } } } } document . write ( closest ) ; } let N = 16 , X = 5 ; findClosest ( N , X ) ;"}
{"text": "Cari pasangan (a, b) seperti AA + BB = n | Fungsi untuk mengira kuasa minimum a dan b lebih besar daripada n; Menyimpan kuasa A yang lebih besar daripada n; Kiraan kenaikan sebanyak 1; Bahagikan n oleh A; Fungsi untuk mencari pasangan (a, b) sedemikian rupa sehingga a ^ a + b ^ b = n; Kirakan kuasa minimum yang lebih besar daripada n; Kirakan kuasa minimum B lebih besar daripada N; Buat salinan A dan B; Melintasi setiap pasangan (i, j); Semak jika B ^ j + a ^ i = n untuk mengatasi masalah limpahan Gunakan b = n - a bukan b + a = n; Kuasa kenaikan B oleh 1; Kuasa kenaikan A sebanyak 1; Akhirnya cetak - 1 jika tiada pasangan dijumpai; Diberikan A, B dan N; Panggilan fungsi", "code": "function power ( A , N ) { let count = 0 ; if ( A == 1 ) return 0 ; while ( N > 0 ) { count ++ ; N /= A ; } return count ; } function Pairs ( N , A , B ) { let powerA , powerB ; powerA = power ( A , N ) ; powerB = power ( B , N ) ; let letialB = B , letialA = A ; A = 1 ; for ( let i = 0 ; i <= powerA ; i ++ ) { B = 1 ; for ( let j = 0 ; j <= powerB ; j ++ ) { if ( B == N - A ) { document . write ( i + \" \" + j ) ; return ; } B *= letialB ; } A *= letialA ; } document . write ( \" \" ) ; return ; } let N = 106 , A = 3 , B = 5 ; Pairs ( N , A , B ) ;"}
{"text": "Mengira nombor dari julat tertentu yang tidak dapat dibahagikan oleh mana -mana elemen array | Berfungsi untuk mencari gandaan bukan sehingga k; Menyimpan semua gandaan yang unik; Melelehkan array; Untuk mencari pendua sekali sahaja; Memasukkan semua gandaan ke dalam set; Kembali hanya kiraan nombor yang tidak dapat dibahagikan oleh mana -mana elemen array; Berfungsi untuk mengira jumlah nilai dalam julat [l, r]; Mengira semua nilai dalam julat menggunakan prinsip pengecualian; Kod pemacu; Panggilan fungsi", "code": "function findNonMultiples ( arr , n , k ) { let multiples = new Set ( ) ; for ( let i = 0 ; i < n ; ++ i ) { if ( ! multiples . has ( arr [ i ] ) ) { for ( let j = 1 ; j <= k / arr [ i ] ; j ++ ) { multiples . add ( arr [ i ] * j ) ; } } } return k - multiples . size ; } function countValues ( arr , N , L , R ) { return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; } let arr = [ 2 , 3 , 4 , 5 , 6 ] ; let N = arr . length ; let L = 1 , R = 20 ; document . write ( countValues ( arr , N , L , R ) ) ;"}
{"text": "Bilangan minimum duit syiling yang akan dikumpulkan setiap jam untuk mengosongkan n buasir di paling banyak jam | | Berfungsi untuk mencari bilangan minimum duit syiling yang akan dikumpulkan setiap jam untuk mengosongkan n buasir dalam jam H; Menyimpan syiling minimum untuk dikeluarkan setiap jam; Cari elemen array maksimum; Melakukan carian binari; Simpan nilai pertengahan julat dalam k; Cari jumlah masa yang diambil untuk mengosongkan n buasir dengan mengeluarkan sy syiling sejam; Jika jumlah masa tidak melebihi h; Jika tidak; Cetak hasil yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "function minCollectingSpeed ( piles , H ) { var ans = - 1 ; var low = 1 , high ; high = piles . reduce ( ( a , b ) => Math . max ( a , b ) ) ; while ( low <= high ) { var K = low + parseInt ( ( high - low ) / 2 ) ; var time = 0 ; piles . forEach ( ai => { time += parseInt ( ( ai + K - 1 ) / K ) ; } ) ; if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } document . write ( ans ) ; } var arr = [ 3 , 6 , 7 , 11 ] ; var H = 8 ; minCollectingSpeed ( arr , H ) ;"}
{"text": "Kira pasangan yang berbeza dengan jumlah yang diberikan | Fungsi untuk mengira pasangan yang berbeza dalam array yang jumlahnya sama dengan k; Kedai kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Susun array; Kedai indeks penunjuk kiri; Kedai indeks penunjuk yang betul; Hitung kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Jika jumlah pasangan semasa adalah sama dengan k; Keluarkan elemen array duplikat berturut -turut; Kemas kini i; Keluarkan elemen array duplikat berturut -turut; Kemas kini j; Kemas kini CNTPairs; Kemas kini i; Kemas kini j; jika jumlah pasangan semasa kurang daripada k; Kemas kini i; Kemas kini j; Kod pemacu", "code": "function cntDisPairs ( arr , N , K ) { var cntPairs = 0 ; arr . sort ( ) ; var i = 0 ; var j = N - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] == K ) { while ( i < j && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } while ( i < j && arr [ j ] == arr [ j - 1 ] ) { j -- ; } cntPairs += 1 ; i ++ ; j -- ; } else if ( arr [ i ] + arr [ j ] < K ) { i ++ ; } else { j -- ; } } return cntPairs ; } var arr = [ 5 , 6 , 5 , 7 , 7 , 8 ] ; var N = arr . length ; var K = 13 ; document . write ( cntDisPairs ( arr , N , K ) ) ;"}
{"text": "Pertanyaan untuk mencari seterusnya yang paling lama tidak mempunyai unsur bersebelahan yang sama dengan kemas kini | Berfungsi untuk mencari panjang seterusnya yang paling lama supaya tidak ada dua elemen bersebelahan yang sama; Gantikan elemen pada indeks x dengan y; Oleh kerana x adalah 1 - diindeks, penurunan x oleh 1; Jejaki bilangan elemen dalam masa depan; Jika elemen sebelumnya tidak sama dengan elemen semasa; Cetak kiraan yang dikehendaki; Kod pemacu; Panggilan fungsi", "code": "function longestSubsequence ( N , Q , arr , Queries ) { for ( let i = 0 ; i < Q ; i ++ ) { let x = Queries [ i ] [ 0 ] ; let y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; let count = 1 ; for ( let j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } document . write ( count + \" \" ) ; } } let arr = [ 1 , 1 , 2 , 5 , 2 ] ; let N = arr . length ; let Q = 2 ; let Queries = [ [ 1 , 3 ] , [ 4 , 2 ] ] ; longestSubsequence ( N , Q , arr , Queries ) ;"}
{"text": "Pertanyaan untuk mencari seterusnya yang paling lama tidak mempunyai unsur bersebelahan yang sama dengan kemas kini | Program JavaScript untuk pendekatan di atas; Melintasi array arr; Jika elemen sebelumnya tidak sama dengan elemen semasa; Melintasi pertanyaan; Gantikan elemen pada indeks x dengan y; Mengira semula untuk Indeks X; Tolak sumbangan elemen pada indeks x; Tambah sumbangan y; Mengira semula untuk indeks x + 1; Tolak sumbangan elemen pada indeks x + 1; Menambah sumbangan y; Menggantikan elemen; Kod pemacu; Panggilan fungsi", "code": "function longestSubsequence ( N , Q , arr , Queries ) { var count = 1 ; for ( var i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } } for ( var i = 0 ; i < Q ; i ++ ) { var x = Queries [ i ] [ 0 ] ; var y = Queries [ i ] [ 1 ] ; if ( x > 1 ) { if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; } if ( arr [ x - 2 ] != y ) { count += 1 ; } } if ( x < N ) { if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; } if ( y != arr [ x ] ) { count += 1 ; } } document . write ( count + \" \" ) ; arr [ x - 1 ] = y ; } } var arr = [ 1 , 1 , 2 , 5 , 2 ] ; var N = arr . length ; var Q = 2 ; var Queries = [ [ 1 , 3 ] , [ 4 , 2 ] ] ; longestSubsequence ( N , Q , arr , Queries ) ;"}
{"text": "Jumlah perbezaan mutlak indeks kejadian setiap elemen array | Fungsi untuk mencari jumlah perbezaan indeks kejadian setiap elemen array yang unik; Menyimpan indeks setiap elemen array; Simpan indeks; Menyimpan jumlahnya; Melintasi array; Cari jumlah untuk setiap elemen; Melangkah ke atas peta; Hitung jumlah kejadian ARR [i]; Simpan jumlah untuk elemen semasa; Cetak jawapan untuk setiap elemen; Diberikan array; Saiz yang diberikan; Panggilan fungsi", "code": "function sum ( arr , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { var tmp = mp . get ( arr [ i ] ) ; tmp . push ( i ) ; mp . set ( arr [ i ] , tmp ) ; } else { mp . set ( arr [ i ] , [ i ] ) ; } } var ans = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { var sum = 0 ; mp . get ( arr [ i ] ) . forEach ( it => { sum += Math . abs ( it - i ) ; } ) ; ans [ i ] = sum ; } for ( var i = 0 ; i < n ; i ++ ) { document . write ( ans [ i ] + \" \" ) ; } return ; } var arr = [ 1 , 3 , 1 , 1 , 2 ] ; var n = arr . length ; sum ( arr , n ) ;"}
{"text": "Tukar vokal ke dalam watak kes atas dalam rentetan yang diberikan | Berfungsi untuk menukar vokal menjadi huruf besar; Menyimpan panjang str; Kod pemacu", "code": "function conVowUpp ( str ) { var N = str . length ; for ( var i = 0 ; i < N ; i ++ ) { if ( str [ i ] === \" \" str [ i ] === \" \" str [ i ] === \" \" str [ i ] === \" \" str [ i ] === \" \" ) { document . write ( str [ i ] . toUpperCase ( ) ) ; } else { document . write ( str [ i ] ) ; } } } var str = \" \" ; conVowUpp ( str ) ;"}
{"text": "Memaksimumkan bilangan hari yang mana c coklat boleh diedarkan secara berturut -turut kepada orang -orang n | Menyimpan kekerapan setiap jenis coklat; Fungsi untuk memeriksa sama ada coklat boleh dimakan untuk 'pertengahan' tidak. hari; Jika CNT melebihi n, kembali benar; Berfungsi untuk mencari bilangan maksimum hari yang mana coklat boleh dimakan; Simpan kekerapan setiap jenis coklat; Memulakan permulaan dan berakhir dengan 0 dan P masing -masing; Hitung pertengahan; Semak jika coklat boleh diedarkan selama pertengahan hari; Semak jika coklat boleh diedarkan selama lebih dari pertengahan hari berturut -turut; Kod pemacu; Panggilan fungsi", "code": "var mp = new Map ( ) ; var N , P ; function helper ( mid ) { var cnt = 0 ; mp . forEach ( ( value , ) => { var temp = value ; while ( temp >= mid ) { temp -= mid ; cnt ++ ; } } ) ; return cnt >= N ; } function findMaximumDays ( arr ) { for ( var i = 0 ; i < P ; i ++ ) { if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) ; } var start = 0 , end = P , ans = 0 ; while ( start <= end ) { var mid = start + parseInt ( ( end - start ) / 2 ) ; if ( mid != 0 && helper ( mid ) ) { ans = mid ; start = mid + 1 ; } else if ( mid == 0 ) { start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; } N = 3 , P = 10 ; var arr = [ 1 , 2 , 2 , 1 , 1 , 3 , 3 , 3 , 2 , 4 ] ; document . write ( findMaximumDays ( arr ) ) ;"}
{"text": "Count Subarrays yang mempunyai jumlah modulo k sama dengan panjang subarray | Fungsi yang mengira subarray yang mempunyai jumlah modulo k sama dengan panjang subarray; Menyimpan kiraan subarray; Kedai awalan jumlah array; Kirakan Array Jumlah Awalan; Menjana semua subarray; Semak sama ada subarray ini adalah subarray yang sah atau tidak; Jumlah kiraan subarray; Diberikan arr []; Saiz array; Diberikan k; Panggilan fungsi", "code": "function countSubarrays ( a , n , k ) { var ans = 0 ; var pref = [ ] ; pref . push ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) pref . push ( ( a [ i ] + pref [ i ] ) % k ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = i ; j <= n ; j ++ ) { if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) { ans ++ ; } } } document . write ( ans + ' ' ) ; } var arr = [ 2 , 3 , 5 , 3 , 1 , 5 ] ; var N = arr . length ; var K = 4 ; countSubarrays ( arr , N , K ) ;"}
{"text": "Semak jika semua substring panjang k dari rentetan binari mempunyai kiraan yang sama dengan 0 s dan 1 s | Fungsi untuk memeriksa sama ada substring panjang k mempunyai sama 0 dan 1; Melintasi rentetan; Semak sama ada setiap watak k - th adalah sama atau tidak; Melintasi substring panjang k; Jika watak semasa adalah 0; Kiraan kenaikan; Jika tidak; Kiraan pengurangan; Semak sama 0 s dan 1 s; Kod pemacu", "code": "function check ( s , k ) { let n = s . length ; for ( let i = 0 ; i < k ; i ++ ) { for ( let j = i ; j < n ; j += k ) { if ( s [ i ] != s [ j ] ) return false ; } } let c = 0 ; for ( let i = 0 ; i < k ; i ++ ) { if ( s [ i ] == ' ' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; } let s = \" \" ; let k = 2 ; if ( check ( s , k ) ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Semak jika watak -watak rentetan yang diberikan boleh digunakan untuk membentuk sebarang rentetan yang sama | Fungsi untuk memeriksa sama ada freq dari mana -mana watak boleh dibahagikan dengan n; Menyimpan kekerapan aksara; Jika kekerapan watak tidak dapat dibahagikan dengan n; Jika tiada watak mempunyai kekerapan sekurang -kurangnya n; Kod pemacu; Panggilan fungsi", "code": "function isSame ( str , n ) { var mp = { } ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( mp . hasOwnProperty ( str [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ) ) { mp [ str [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] = mp [ str [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] + 1 ; } else { mp [ str [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] = 1 ; } } for ( const [ key , value ] of Object . entries ( mp ) ) { if ( value >= n ) { return true ; } } return false ; } var str = \" \" ; var n = 4 ; if ( isSame ( str , n ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Cari akar fungsi yang tidak berkurangan antara a dan b | Program JavaScript untuk pendekatan di atas; Fungsi yang diberikan; Fungsi untuk mencari akar fungsi yang tidak berkurangan; Untuk mendapatkan jawapan minimum yang mungkin untuk akar; Cari pertengahan; Cari di [rendah, x]; Cari di [x, tinggi]; Mengembalikan jawapan yang diperlukan; Berfungsi untuk mencari akar persamaan yang diberikan dalam julat [a, b]; Jika akar tidak wujud; Lain mencari akar sehingga 4 tempat perpuluhan; Julat yang diberikan; Panggilan fungsi", "code": "let eps = 1e-6 ; function func ( a , b , c , x ) { return a * x * x + b * x + c ; } function findRoot ( a , b , c , low , high ) { let x = - 1 ; while ( Math . abs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; } function solve ( a , b , c , A , B ) { if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) { document . write ( \" \" ) ; } else { document . write ( findRoot ( a , b , c , A , B ) ) ; } } let a = 2 , b = - 3 , c = - 2 , A = 0 , B = 3 ; solve ( a , b , c , A , B ) ;"}
{"text": "Median perbezaan semua pasangan dari array | Pemeriksaan fungsi jika pertengahan boleh menjadi indeks median pelbagai perbezaan; Saiz array; Jumlah mungkin tidak ada pasangan yang mungkin; Indeks elemen dalam perbezaan semua pasangan dari array; Kira bilangan pasangan yang mempunyai perbezaan <= MID; Jika perbezaan antara akhir dan elemen pertama kurang atau sama dengan pertengahan; Memeriksa unsur tidak kurang daripada atau sama dengan pertengahan adalah lebih besar daripada median atau tidak; Fungsi untuk mengira median perbezaan semua pasangan dari array; Saiz array; Memulakan yang rendah dan tinggi; Carian binari; Hitung pertengahan; Jika pertengahan boleh menjadi median array; Mengembalikan median perbezaan pasangan dari array; Kod pemacu", "code": "function possible ( mid , a ) { let n = a . length ; let total = parseInt ( ( n * ( n - 1 ) ) / 2 ) ; let need = parseInt ( ( total + 1 ) / 2 ) ; let count = 0 ; let start = 0 , end = 1 ; while ( end < n ) { if ( a [ end ] - a [ start ] <= mid ) { end ++ ; } else { count += ( end - start - 1 ) ; start ++ ; } } if ( end == n && start < end && a [ end - 1 ] - a [ start ] <= mid ) { let t = end - start - 1 ; count += parseInt ( t * ( t + 1 ) / 2 ) ; } if ( count >= need ) return true ; else return false ; } function findMedian ( a ) { let n = a . length ; let low = 0 , high = a [ n - 1 ] - a [ 0 ] ; while ( low <= high ) { let mid = ( low + high ) / 2 ; if ( possible ( mid , a ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; } let a = [ 1 , 7 , 5 , 2 ] ; a . sort ( ) ; document . write ( findMedian ( a ) ) ;"}
{"text": "Cetak semua rentetan dari array a [] mempunyai semua rentetan dari array b [] sebagai berikutnya | Berfungsi untuk mencari rentetan dari [] mempunyai semua rentetan dalam b [] sebagai seterusnya; Hitung saiz masing -masing; Menyimpan jawapannya; Menyimpan kekerapan setiap watak dalam rentetan []; Kirakan frekuensi watak semua rentetan; Menyimpan kekerapan setiap aksara dalam rentetan b [] setiap watak rentetan dalam b []; Jika kekerapan watak dalam b [] melebihi itu dalam []; Rentetan wujud dalam B [] yang bukan subset yang betul dari [i]; Jika semua rentetan dalam b [] adalah subset yang betul dari []; Tolak rentetan dalam vektor yang dihasilkan; Jika ada rentetan yang dijumpai; Cetak rentetan itu; Jika tidak; Kod pemacu", "code": "function UniversalSubset ( A , B ) { var n1 = A . length ; var n2 = B . length ; var res = [ ] ; var A_fre = Array . from ( Array ( n1 ) , ( ) => Array ( 26 ) ) ; for ( var i = 0 ; i < n1 ; i ++ ) { for ( var j = 0 ; j < 26 ; j ++ ) A_fre [ i ] [ j ] = 0 ; } for ( var i = 0 ; i < n1 ; i ++ ) { for ( var j = 0 ; j < A [ i ] . length ; j ++ ) { A_fre [ i ] [ A [ i ] . charCodeAt ( j ) - ' ' . charCodeAt ( 0 ) ] ++ ; } } var B_fre = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < n2 ; i ++ ) { var arr = Array ( 26 ) . fill ( 0 ) ; for ( var j = 0 ; j < B [ i ] . length ; j ++ ) { arr [ B [ i ] . charCodeAt ( j ) - ' ' . charCodeAt ( 0 ) ] ++ ; B_fre [ B [ i ] . charCodeAt ( j ) - ' ' . charCodeAt ( 0 ) ] = Math . max ( B_fre [ B [ i ] . charCodeAt ( j ) - ' ' . charCodeAt ( 0 ) ] , arr [ B [ i ] . charCodeAt ( j ) - ' ' . charCodeAt ( 0 ) ] ) ; } } for ( var i = 0 ; i < n1 ; i ++ ) { var flag = 0 ; for ( var j = 0 ; j < 26 ; j ++ ) { if ( A_fre [ i ] [ j ] < B_fre [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) res . push ( A [ i ] ) ; } if ( res . length > 0 ) { for ( var i = 0 ; i < res . length ; i ++ ) { for ( var j = 0 ; j < res [ i ] . length ; j ++ ) document . write ( res [ i ] [ j ] ) ; } document . write ( \" \" ) ; } else document . write ( \" \" ) ; } var A = [ \" \" , \" \" , \" \" ] ; var B = [ \" \" , \" \" ] ; UniversalSubset ( A , B ) ;"}
{"text": "Pasangan terdekat dalam array supaya satu nombor adalah pelbagai yang lain | Berfungsi untuk mencari pasangan jarak minimum di mana seseorang adalah pelbagai yang lain; Memulakan pembolehubah; Melangkah untuk semua elemen; Gelung untuk membuat pasangan; Semak jarak minimum; Semak jika seseorang adalah pelbagai yang lain; Mengemas kini jarak; Indeks kedai; Jika tidak ada pasangan seperti itu; Cetak jawapannya; Diberikan array arr []; Panggilan fungsi", "code": "function findPair ( a , n ) { let min_dist = Number . MAX_VALUE ; let index_a = - 1 , index_b = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( j - i < min_dist ) { if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) { min_dist = j - i ; index_a = i ; index_b = j ; } } } } if ( index_a == - 1 ) { document . write ( \" \" ) ; } else { document . write ( \" \" + a [ index_a ] + \" \" + a [ index_b ] + \" \" ) ; } } let a = [ 2 , 3 , 4 , 5 , 6 ] ; let n = a . length ; findPair ( a , n ) ;"}
{"text": "Cetak semua nombor dalam julat yang diberikan dengan digit dalam perintah yang semakin meningkat | Berfungsi untuk mencetak semua nombor dalam julat [l, r] yang mempunyai digit dalam urutan yang semakin meningkat; Melangkah ke atas julat; Melangkah ke atas digit; Semak sama ada digit semasa adalah> = digit sebelumnya; Sekiranya digit berada dalam urutan menaik; Diberikan julat l dan r; Panggilan fungsi", "code": "function printNum ( L , R ) { for ( let i = L ; i <= R ; i ++ ) { let temp = i ; let c = 10 ; let flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) document . write ( i + \" \" ) ; } } let L = 10 , R = 15 ; printNum ( L , R ) ;"}
{"text": "Cari nombor yang hilang dalam perkembangan aritmetik yang tidak teratur | Fungsi untuk mencari elemen yang hilang; Betulkan sempadan kiri dan kanan untuk carian binari; Cari Indeks Elemen Tengah; Semak jika elemen hanya selepas elemen tengah hilang; Semak jika elemen sebelum pertengahan hilang; Semak jika unsur -unsur sehingga pertengahan mengikuti AP, kemudian berulang untuk separuh kanan; Lain berulang untuk separuh kiri; Berfungsi untuk mencari elemen yang hilang dalam siri AP; Susun array [] arr; Mengira perbezaan biasa; Pencarian binari untuk yang hilang; Diberikan array [] arr; Panggilan fungsi", "code": "function findMissing ( arr , left , right , diff ) { if ( right <= left ) return 0 ; let mid = left + parseInt ( ( right - left ) / 2 , 10 ) ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ; return findMissing ( arr , left , mid - 1 , diff ) ; } function missingElement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let diff = parseInt ( ( arr [ n - 1 ] - arr [ 0 ] ) / n , 10 ) ; return findMissing ( arr , 0 , n - 1 , diff ) ; } let arr = [ 2 , 8 , 6 , 10 ] ; let n = arr . length ; document . write ( missingElement ( arr , n ) ) ;"}
{"text": "Nilai lantai kth akar nombor menggunakan carian binari rekursif | Berfungsi untuk mengira x yang dibangkitkan kepada kuasa y dalam o (logn); Berfungsi untuk mencari akar kth nombor n menggunakan BS; Sekiranya julat masih sah; Cari nilai pertengahan julat; Kes asas; Keadaan untuk memeriksa sama ada ruang carian kiri tidak berguna; Diberikan n dan k; Panggilan fungsi", "code": "function power ( x , y ) { let temp ; if ( y == 0 ) return 1 ; temp = power ( x , Math . floor ( y / 2 ) ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; } function nthRootSearch ( low , high , N , K ) { if ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( ( power ( mid , K ) <= N ) && ( power ( mid + 1 , K ) > N ) ) { return mid ; } else if ( power ( mid , K ) < N ) { return nthRootSearch ( mid + 1 , high , N , K ) ; } else { return nthRootSearch ( low , mid - 1 , N , K ) ; } } return low ; } let N = 16 , K = 4 ; document . write ( nthRootSearch ( 0 , N , N , K ) ) ;"}
{"text": "Count subset yang mempunyai jumlah elemen min dan max kurang daripada k | Fungsi yang mengembalikan kiraan subset sedemikian rupa sehingga matematik. Min (s) + matematik. max (s) <k; Menyusun array; Ans menyimpan jumlah subset; Tambah semua subset yang mungkin antara I dan J; Mengurangkan jumlah; Kod pemacu", "code": "function get_subset_count ( arr , K , N ) { ( arr ) . sort ( function ( a , b ) { return a - b ; } ) ; let left , right ; left = 0 ; right = N - 1 ; let ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; } let arr = [ 2 , 4 , 5 , 7 ] ; let K = 8 ; let N = arr . length ; document . write ( get_subset_count ( arr , K , N ) ) ;"}
{"text": "Kurangkan perbezaan maksimum unsur -unsur bersebelahan selepas kebanyakan sisipan k | Program JavaScript untuk mencari minimum perbezaan maksimum antara unsur -unsur bersebelahan selepas kebanyakan penyisipan K; Kirakan perbezaan bersebelahan maksimum; Jika perbezaan bersebelahan maksimum sudah sifar; Terbaik dan terburuk menentukan pelbagai perbezaan bersebelahan maksimum; Untuk menyimpan tidak ada sisipan yang diperlukan untuk nilai masing -masing MID; Jika bilangan sisipan diperlukan melebihi k; Jika tidak; Kod pemacu", "code": "function minMaxDiff ( arr , n , k ) { var max_adj_dif = - 1000000000 ; for ( var i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = Math . max ( max_adj_dif , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; if ( max_adj_dif == 0 ) return 0 ; var best = 1 ; var worst = max_adj_dif ; var mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ; required = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { required += parseInt ( ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ) ; } if ( required > k ) best = mid + 1 ; else worst = mid ; } return worst ; } var arr = [ 3 , 12 , 25 , 50 ] ; var n = arr . length ; var k = 7 ; document . write ( minMaxDiff ( arr , n , k ) ) ;"}
{"text": "Semak jika elemen minimum dalam array kurang daripada atau sama dengan separuh daripada setiap elemen lain | Fungsi untuk memeriksa sama ada elemen minimum dalam array adalah lebih besar daripada atau sama dengan separuh daripada setiap elemen lain; Memulakan pembolehubah untuk menyimpan terkecil terkecil dan kedua terkecil; Semak jika elemen semasa lebih kecil daripada yang terkecil, terkecil semasa akan menjadi unsur detik paling teruk dan semasa akan menjadi yang terkecil baru; Semak jika elemen semasa lebih kecil daripada saat yang paling kecil hanya mengemas kini yang terakhir; Kod pemacu", "code": "function checkMin ( arr , len ) { var smallest = Number . INFINITY , secondSmallest = Number . INFINITY ; for ( var i = 0 ; i < len ; i ++ ) { if ( arr [ i ] < smallest ) { secondSmallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] < secondSmallest ) { secondSmallest = arr [ i ] ; } } if ( 2 * smallest <= secondSmallest ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } var arr = [ 2 , 3 , 4 , 5 ] ; var len = 4 ; checkMin ( arr , len ) ;"}
{"text": "Nombor fibonacci terbesar dan terkecil dalam array | Fungsi untuk membuat jadual hash untuk memeriksa nombor Fibonacci; Masukkan dua nombor awal dalam jadual hash; Jumlah dua nombor sebelumnya; Kemas kini pembolehubah setiap kali; Berfungsi untuk mencari nombor fibonacci minimum dan maksimum dalam array yang diberikan; Cari nilai maksimum dalam array; Mewujudkan satu set yang mengandungi semua nombor Fibonacci sehingga nilai maksimum dalam array; Untuk menyimpan nombor Fibonacci minimum dan maksimum; Semak jika elemen semasa adalah nombor Fibonacci; Mengemas kini maksimum dan minimum yang sewajarnya; Kod pemacu", "code": "function createHash ( hash , maxElement ) { let prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { let temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } } function fibonacci ( arr , n ) { let max_val = Math . max ( ... arr ) ; let hash = new Set ( ) ; createHash ( hash , max_val ) ; let minimum = Number . MAX_VALUE ; let maximum = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( hash . has ( arr [ i ] ) ) { minimum = Math . min ( minimum , arr [ i ] ) ; maximum = Math . max ( maximum , arr [ i ] ) ; } } document . write ( minimum + \" \" + maximum + \" \" ) ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ; let n = arr . length ; fibonacci ( arr , n ) ;"}
{"text": "Substring terpanjang dengan K aksara unik menggunakan carian binari | Fungsi yang mengembalikan benar jika terdapat substring panjang len dengan <= k aksara unik; Saiz rentetan; Peta untuk menyimpan watak dan kekerapannya; Kemas kini peta untuk substring pertama; Periksa selebihnya substrings; Tambah watak baru; Keluarkan watak pertama tetingkap sebelumnya; Kemas kini peta; Berfungsi untuk mengembalikan panjang substring terpanjang yang mempunyai aksara unik K; Semak sama ada rentetan lengkap mengandungi aksara unik K; Saiz rentetan; Memohon carian binari; Kod pemacu", "code": "function isValidLen ( s , len , k ) { var n = s . length ; var mp = new Map ( ) ; var right = 0 ; while ( right < len ) { if ( mp . has ( s [ right ] ) ) mp . set ( s [ right ] , mp . get ( s [ right ] ) + 1 ) else mp . set ( s [ right ] , 1 ) right ++ ; } if ( mp . size <= k ) return true ; while ( right < n ) { if ( mp . has ( s [ right ] ) ) mp . set ( s [ right ] , mp . get ( s [ right ] ) + 1 ) else mp . set ( s [ right ] , 1 ) if ( mp . has ( s [ right - len ] ) ) mp . set ( s [ right - len ] , mp . get ( s [ right - len ] ) - 1 ) if ( mp . has ( s [ right - len ] ) && mp . get ( s [ right - len ] ) == 0 ) mp . delete ( s [ right - len ] ) ; if ( mp . size <= k ) return true ; right ++ ; } return mp . size <= k ; } function maxLenSubStr ( s , k ) { var uni = new Set ( ) ; s . split ( ' ' ) . forEach ( x => { uni . add ( x ) ; } ) ; if ( uni . size < k ) return - 1 ; var n = s . length ; var lo = - 1 , hi = n + 1 ; while ( hi - lo > 1 ) { var mid = lo + hi >> 1 ; if ( isValidLen ( s , mid , k ) ) lo = mid ; else hi = mid ; } return lo ; } var s = \" \" ; var k = 3 ; document . write ( maxLenSubStr ( s , k ) ) ;"}
{"text": "Dataran Kawasan Terbesar di Array Apabila Elemen Boleh Dipandu | Fungsi yang mengembalikan benar jika mungkin untuk membuat persegi dengan sisi sama dengan L; Untuk menyimpan kiraan elemen yang lebih besar daripada atau sama dengan L; Kenaikan kiraan; Jika kiraan menjadi lebih besar daripada atau sama dengan L; Berfungsi untuk mengembalikan kawasan maksimum dataran yang boleh diperolehi; Jika persegi mungkin dengan panjang sisi m; Cuba cari persegi dengan panjang sampingan yang lebih kecil; Mengembalikan kawasan itu; Kod pemacu", "code": "function isSquarePossible ( arr , n , l ) { let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= l ) cnt ++ ; if ( cnt >= l ) return true ; } return false ; } function maxArea ( arr , n ) { let l = 0 , r = n ; let len = 0 ; while ( l <= r ) { let m = l + Math . floor ( ( r - l ) / 2 ) ; if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; } else r = m - 1 ; } return ( len * len ) ; } let arr = [ 1 , 3 , 4 , 5 , 5 ] ; let n = arr . length ; document . write ( maxArea ( arr , n ) ) ;"}
{"text": "Semak pendua dalam aliran rentetan | Fungsi untuk memasukkan nama dan periksa sama ada ia muncul untuk kali pertama; Untuk menyimpan nama pekerja; Jika nama semasa muncul untuk kali pertama; Kod pemacu", "code": "function insertNames ( arr , n ) { let set = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! set . has ( arr [ i ] ) ) { document . write ( \" \" + \" \" ) ; set . add ( arr [ i ] ) ; } else { document . write ( \" \" + \" \" ) ; } } } let arr = [ \" \" , \" \" , \" \" ] ; let n = arr . length ; insertNames ( arr , n ) ;"}
{"text": "Kira tiga kali ganda supaya A [i] <b [j] <c [k] | Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang kurang daripada kunci yang diberikan; Carian binari yang diubah suai; Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang lebih besar daripada kunci yang diberikan; Carian binari yang diubah suai; Berfungsi untuk mengembalikan kiraan tiga kali ganda yang diperlukan; Menyusun ketiga -tiga tatasusunan; Melangkah untuk semua elemen array b; Kiraan elemen dalam [] yang kurang daripada elemen yang dipilih dari B []; Kiraan unsur -unsur dalam C [] yang lebih besar daripada elemen yang dipilih dari B []; Mengemas kini kiraan; Kod pemacu", "code": "function countLessThan ( arr , n , key ) { let l = 0 , r = n - 1 ; let index = - 1 ; while ( l <= r ) { let m = Math . floor ( ( l + r ) / 2 ) ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; } function countGreaterThan ( arr , n , key ) { let l = 0 , r = n - 1 ; let index = - 1 ; while ( l <= r ) { let m = Math . floor ( ( l + r ) / 2 ) ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == - 1 ) return 0 ; return ( n - index ) ; } function countTriplets ( n , a , b , c ) { a . sort ( function ( e , f ) { return e - f ; } ) ; b . sort ( function ( e , f ) { return e - f ; } ) ; c . sort ( function ( e , f ) { return e - f ; } ) ; let count = 0 ; for ( let i = 0 ; i < n ; ++ i ) { let current = b [ i ] ; let low = countLessThan ( a , n , current ) ; let high = countGreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; } let a = [ 1 , 5 ] ; let b = [ 2 , 4 ] ; let c = [ 3 , 6 ] ; let size = a . length ; document . write ( countTriplets ( size , a , b , c ) ) ;"}
{"text": "Kos untuk mengimbangi kurungan | Kod JavaScript untuk mengira kos minimum untuk membuat kurungan yang diberikan seimbang; Untuk menyimpan kiraan mutlak kurungan yang seimbang dan tidak seimbang; o (pendakap terbuka) menyimpan kiraan '(' dan c (pendakap dekat) kiraan ')'; Kod pemacu", "code": "function costToBalance ( s ) { if ( s . length == 0 ) document . write ( 0 ) ; var ans = 0 ; var o = 0 , c = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) o ++ ; if ( s [ i ] == ' ' ) c ++ ; } if ( o != c ) return - 1 ; var a = new Array ( s . Length ) ; if ( s [ 0 ] == ' ' ) a [ 0 ] = 1 ; else a [ 0 ] = - 1 ; if ( a [ 0 ] < 0 ) ans += Math . abs ( a [ 0 ] ) ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += Math . abs ( a [ i ] ) ; } return ans ; } var s ; s = \" \" ; document . write ( costToBalance ( s ) + \" \" ) ; s = \" \" ; document . write ( costToBalance ( s ) + \" \" ) ;"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Berfungsi untuk mencari pertengahan tiga nombor; x adalah positif jika a lebih besar daripada b. x adalah negatif jika b lebih besar daripada a. ; Sama seperti x; Sama seperti x dan y. ; Memeriksa jika B adalah tengah (X dan Y kedua -duanya adalah positif); Memeriksa jika C adalah tengah (x dan z kedua -duanya positif); Kod pemacu", "code": "function middleOfThree ( a , b , c ) { let x = a - b ; let y = b - c ; let z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; } let a = 20 , b = 30 , c = 40 ; document . write ( middleOfThree ( a , b , c ) ) ;"}
{"text": "Cari empat nombor yang hilang dalam array yang mengandungi elemen dari 1 hingga n | Menemukan 4 nombor dalam O (n) masa dan O (1) ruang tambahan. ; Untuk menjejaki 4 nombor yang mungkin lebih besar daripada panjang input di Java, penolong secara automatik diasaskan sebagai 0 .; Melintasi array input dan menandakan unsur -unsur yang dilawati sama ada dengan menandakan mereka sebagai negatif dalam arr [] atau dalam pembantu []. ; Jika elemen lebih kecil daripada atau sama dengan panjang, tandakan kehadirannya di arr []; Mark kehadiran dalam pembantu []; Cetak semua elemen yang kehadirannya tidak ditandakan. ; Kod pemacu", "code": "function missing4 ( arr ) { let helper = [ ] ; for ( let i = 0 ; i < 4 ; i ++ ) { helper [ i ] = 0 ; } for ( let i = 0 ; i < arr . length ; i ++ ) { let temp = Math . abs ( arr [ i ] ) ; if ( temp <= arr . length ) arr [ temp - 1 ] = Math . floor ( arr [ temp - 1 ] * ( - 1 ) ) ; else if ( temp > arr . length ) { if ( temp % arr . length != 0 ) helper [ temp % arr . length - 1 ] = - 1 ; else helper [ ( temp % arr . length ) + arr . length - 1 ] = - 1 ; } } for ( let i = 0 ; i < arr . length ; i ++ ) if ( arr [ i ] > 0 ) document . write ( i + 1 + \" \" ) ; for ( let i = 0 ; i < helper . length ; i ++ ) if ( helper [ i ] >= 0 ) document . write ( arr . length + i + 1 + \" \" ) ; return ; } let arr = [ 1 , 7 , 3 , 12 , 5 , 10 , 8 , 4 , 9 ] ; missing4 ( arr ) ;"}
{"text": "Permutasi yang hadir di tengah -tengah pesanan leksikografi permutasi paling panjang n yang terdiri daripada bilangan bulat sehingga k | Fungsi yang menemui tengah -tengah urutan terkecil leksikografi; Jika k ada; Elemen pertama ialah K / 2; Unsur -unsur yang tersisa dari urutan adalah semua integer k; Menyimpan urutan apabila k adalah ganjil; Melangkah ke atas julat [0, n / 2]; Semak sama ada urutan berakhir dengan 1 atau tidak; Keluarkan urutan yang berakhir dalam 1; Sekiranya ia tidak berakhir dalam 1; Penurunan sebanyak 1; Masukkan k ke urutan sehingga saiznya adalah n; Cetak urutan yang disimpan dalam vektor; Kod pemacu", "code": "function lexiMiddleSmallest ( K , N ) { if ( K % 2 == 0 ) { document . write ( K / 2 + \" \" ) ; for ( let i = 0 ; i < N - 1 ; ++ i ) { document . write ( K + \" \" ) ; } document . write ( \" \" ) ; return ; } let a = [ ] ; for ( let i = 0 ; i < N / 2 ; ++ i ) { if ( a [ a . length - 1 ] == 1 ) { a . pop ( a . length - 1 ) ; } else { a [ a . length - 1 ] -= 1 ; while ( a . length < N ) { a . push ( K ) ; } } } for ( let i in a ) { document . write ( i + \" \" ) ; } document . write ( \" \" ) ; } let K = 2 , N = 4 ; lexiMiddleSmallest ( K , N ) ;"}
{"text": "Elemen array yang tinggal selepas penyingkiran elemen terkecil dari pasangan dengan perbezaan mutlak 2 atau 0 | Berfungsi untuk mencari elemen array yang terakhir selepas berulang kali mengeluarkan terkecil dari pasangan yang mempunyai perbezaan mutlak 2 atau 0; Susun array yang diberikan dalam urutan menaik; Melintasi array; Jika perbezaan antara unsur -unsur bersebelahan tidak sama dengan 0 atau 2; Jika operasi boleh dilakukan; Kod pemacu", "code": "function findLastElement ( arr , N ) { arr . sort ( ) ; let i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { document . write ( \" \" + \" \" ) ; return ; } } document . write ( arr [ N - 1 ] + \" \" ) ; } let arr = [ 2 , 4 , 6 , 8 , 0 , 8 ] ; let N = arr . length ; findLastElement ( arr , N ) ;"}
{"text": "Memaksimumkan kiraan subset ke mana array yang diberikan dapat dibahagikan sehingga ia memenuhi syarat yang diberikan | Fungsi untuk mengira subset maksimum ke mana array yang diberikan dapat dibahagikan sehingga ia memenuhi syarat yang diberikan; Susun array dalam penurunan urutan; Kedai -kedai Count Subset mungkin; Kedai mengira unsur -unsur dalam subset semasa; Melintasi array arr []; Saiz kemas kini; Jika produk elemen terkecil yang terdapat dalam subset semasa dan saiz subset semasa ialah> = k; Kemas kini MaxSub; Saiz kemas kini; Diberikan array; Saiz array; Diberi nilai x", "code": "function maxDivisions ( arr , N , X ) { arr . sort ( ) ; let maxSub = 0 ; let size = 0 ; for ( let i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } document . write ( maxSub + \" \" ) ; } let arr = [ 1 , 3 , 3 , 7 ] ; let N = arr . length ; let X = 3 ; maxDivisions ( arr , N , X ) ;"}
{"text": "Memaksimumkan jumlah minimum kedua dalam semua empat kali ganda dari array yang diberikan | Berfungsi untuk mencari jumlah maksimum minimum minimum kedua dalam setiap empat kali ganda; Susun array; Tambah minimum kedua; Prlet maksimum kemungkinan jumlah; Diberikan array; Saiz array", "code": "function maxPossibleSum ( arr , N ) { arr . sort ( ) ; let sum = 0 ; let j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } document . write ( sum ) ; } let arr = [ 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 ] ; let N = arr . length ; maxPossibleSum ( arr , N ) ;"}
{"text": "Perbezaan antara jenis penyisipan dan pilihan pemilihan | Berfungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci kepada satu kedudukan di hadapan kedudukan semasa mereka; Berfungsi untuk mencetak pelbagai saiz n; Cetak array; Kod pemacu; Panggilan fungsi", "code": "function insertionSort ( arr , n ) { let i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } function printArray ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; } document . write ( \" \" ) ; } let arr = [ 12 , 11 , 13 , 5 , 6 ] ; let N = arr . length ; insertionSort ( arr , N ) ; printArray ( arr , N ) ;"}
{"text": "Kiraan pasangan (i, j) dari array yang diberikan supaya saya k * arr [j] | Fungsi untuk mencari kiraan pasangan yang diperlukan; Kedai kiraan pasangan; Melintasi array; Periksa sama ada keadaan itu berpuas hati atau tidak; Kod pemacu; Panggilan fungsi", "code": "function getPairs ( arr , N , K ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } document . write ( count ) ; } let arr = [ 5 , 6 , 2 , 1 ] ; let N = arr . length ; let K = 2 ; getPairs ( arr , N , K ) ;"}
{"text": "Kiraan pasangan (i, j) dari array yang diberikan supaya saya k * arr [j] | Berfungsi untuk menggabungkan dua susunan yang disusun; i: indeks ke subarray kiri; J: Indeks ke Subarray Kanan; Kedai kiraan pasangan yang memenuhi syarat yang diberikan; Melintasi untuk memeriksa keadaan yang sah; Jika keadaan memenuhi; Semua elemen di sebelah kanan subarray kiri juga memuaskan; Susun dua tatasusunan yang diberikan dan simpan dalam array yang dihasilkan; Unsur -unsur yang tersisa di subarray kiri; Unsur -unsur yang tersisa di subarray kanan; Mengembalikan kiraan yang diperoleh; Berfungsi untuk memisahkan array menjadi dua bahagian; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Hubungi fungsi penggabungan; Berfungsi untuk mencetak kiraan pasangan yang diperlukan menggunakan jenis gabungan; Kod pemacu; Panggilan fungsi", "code": "function merge ( arr , temp , l , m , r , K ) { let i = l ; let j = m + 1 ; let cnt = 0 ; for ( i = l ; i <= m ; i ++ ) { let found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found == true ) { cnt += j - ( m + 1 ) ; j -- ; } } let k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; } function mergeSortUtil ( arr , temp , l , r , K ) { let cnt = 0 ; if ( l < r ) { let m = parseInt ( ( l + r ) / 2 , 10 ) ; cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; } function mergeSort ( arr , N , K ) { let temp = new Array ( N ) ; document . write ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) ; } let arr = [ 5 , 6 , 2 , 5 ] ; let N = arr . length ; let K = 2 ; mergeSort ( arr , N , K ) ;"}
{"text": "Kurangkan penyingkiran berturut -turut unsur -unsur jenis yang sama untuk kosong yang diberikan | Fungsi untuk mengira penyingkiran minimum berturut -turut unsur -unsur jenis yang sama; Susun array; Menyimpan elemen maksimum yang terdapat dalam array; Kedai jumlah array; Hitung jumlah array; Kod pemacu; Panggilan fungsi", "code": "function minRemovals ( A , N ) { A . sort ( ) ; let mx = A [ N - 1 ] ; let sum = 1 ; for ( let i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { document . write ( 0 ) ; } else { document . write ( 2 * mx - sum ) ; } } let A = [ 3 , 3 , 2 ] ; let N = A . length ; minRemovals ( A , N ) ;"}
{"text": "Menyusun semula array yang diberikan supaya tiada elemen array yang sama dengan indeksnya | Berfungsi untuk menyusun semula array a [] supaya tidak ada unsur array yang sama dengan indeksnya; Susun array; Melintasi indeks [0, n - 2] dari array yang diberikan; Periksa sama ada elemen semasa adalah sama dengan indeksnya; Jika didapati benar, swap elemen semasa dengan elemen seterusnya; Semak jika elemen terakhir adalah sama dengan indeksnya; Jika didapati benar, swap elemen semasa dengan elemen sebelumnya; Prlet array yang diubah suai; Kod pemacu; Panggilan fungsi", "code": "function rearrangeArray ( a , n ) { a . sort ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == i + 1 ) { let temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; } } if ( a [ n - 1 ] == n ) { let temp = a [ n - 1 ] ; a [ n - 1 ] = a [ n - 2 ] ; a [ n - 2 ] = temp ; } for ( let i = 0 ; i < n ; i ++ ) { document . write ( a [ i ] + \" \" ) ; } } let arr = [ 1 , 5 , 3 , 2 , 4 ] ; let N = arr . length ; rearrangeArray ( arr , N ) ;"}
{"text": "Kira bilangan minimum bergerak ke depan atau akhir untuk menyusun array | Fungsi yang mengira langkah minimum yang diperlukan untuk rahsia ARR [] kepada BRR []; Kes asas; Jika arr [i] <arr [j]; Termasuk elemen semasa; Jika tidak, tidak termasuk elemen semasa; Fungsi yang mengira langkah minimum yang diperlukan untuk menyusun array; Jika kedua -dua tatasusunan adalah sama; Tiada langkah yang diperlukan; Jika tidak; Mencetak operasi minimum yang diperlukan; Kod pemacu", "code": "function minOperations ( arr1 , arr2 , i , j , n ) { let f = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) f = 1 ; break ; } if ( f == 0 ) return 0 ; if ( i >= n j >= n ) return 0 ; if ( arr1 [ i ] < arr2 [ j ] ) return 1 + minOperations ( arr1 , arr2 , i + 1 , j + 1 , n ) ; return Math . max ( minOperations ( arr1 , arr2 , i , j + 1 , n ) , minOperations ( arr1 , arr2 , i + 1 , j , n ) ) ; } function minOperationsUtil ( arr , n ) { let brr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; brr . sort ( ) ; let f = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != brr [ i ] ) f = 1 ; break ; } if ( f == 1 ) document . write ( minOperations ( arr , brr , 0 , 0 , n ) ) ; else cout << \" \" ; } let arr = [ 4 , 7 , 2 , 3 , 9 ] ; let n = arr . length ; minOperationsUtil ( arr , n ) ;"}
{"text": "Semak jika rentetan boleh diubah kepada yang lain dengan menyusun substrings | Fungsi untuk memeriksa sama ada Str1 boleh diubah menjadi T dengan menyusun substrings; Berlaku [i] menyimpan indeks char ('a' + i) dalam rentetan s; Idx [i] menyimpan indeks char yang tersedia seterusnya ('a' + i) berlaku [i]; Sekiranya char ini tidak tersedia lagi; Penukaran tidak mungkin; Jika salah satu watak yang lebih kecil tersedia dan berlaku sebelum ini; Penukaran tidak mungkin; Cetak jawapannya; Kod pemacu", "code": "function canTransform ( s , t ) { var n = s . length ; var occur = Array . from ( Array ( 26 ) , ( ) => new Array ( ) ) ; for ( var x = 0 ; x < n ; x ++ ) { var ch = s [ x ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; occur [ ch ] . push ( x ) ; } var idx = Array ( 26 ) . fill ( 0 ) ; var poss = true ; for ( var x = 0 ; x < n ; x ++ ) { var ch = t [ x ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; if ( idx [ ch ] >= occur [ ch ] . length ) { poss = false ; break ; } for ( var small = 0 ; small < ch ; small ++ ) { if ( idx [ small ] < occur [ small ] . length && occur [ small ] [ idx [ small ] ] < occur [ ch ] [ idx [ ch ] ] ) { poss = false ; break ; } } idx [ ch ] ++ ; } if ( poss ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } var s , t ; s = \" \" ; t = \" \" ; canTransform ( s , t ) ;"}
{"text": "Semak sama ada dua rentetan boleh dibuat sama dengan membalikkan substring panjang yang sama dari kedua -dua rentetan | fungsi untuk mengira kiraan penyongsangan rentetan; Untuk menyimpan kekerapan; Tambah semua watak yang kurang daripada watak ITH sebelum saya. ; Menambah kiraan kepada kiraan penyongsangan; Mengemas kini watak dalam pelbagai frekuensi; Berfungsi untuk memeriksa sama ada mana -mana rentetan mempunyai watak berulang; Fungsi untuk memeriksa sama ada String S1 dan S2 boleh dibuat sama dengan membalikkan sub rentetan saiz yang sama dalam kedua -dua rentetan; Arahan kekerapan untuk memeriksa sama ada kedua -dua rentetan mempunyai watak yang sama atau tidak; Menambah kekerapan; ; Jika watak tidak berada di S1; Menurunkan kekerapan; Jika kedua -dua rentetan tidak mempunyai aksara yang sama atau tidak; Mencari kiraan penyongsangan kedua -dua rentetan; Jika kiraan penyongsangan adalah sama, atau mempunyai pariti yang sama atau jika mana -mana rentetan mempunyai watak berulang maka jawapannya ya tidak lagi; Kod pemacu", "code": "function inversionCount ( s ) { var freq = Array ( 26 ) . fill ( 0 ) ; var inv = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { var temp = 0 ; for ( var j = 0 ; j < String . fromCharCode ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; j ++ ) temp += freq [ j ] ; inv += ( i - temp ) ; freq [ s [ i ] - ' ' ] ++ ; } return inv ; } function haveRepeated ( S1 , S2 ) { var freq = Array ( 26 ) . fill ( 0 ) ; S1 . forEach ( i => { if ( freq [ i - ' ' ] > 0 ) return true ; freq [ i - ' ' ] ++ ; } ) ; for ( var i = 0 ; i < 26 ; i ++ ) freq [ i ] = 0 ; S2 . split ( ' ' ) . forEach ( i => { if ( freq [ i - ' ' ] > 0 ) return true ; freq [ i - ' ' ] ++ ; } ) ; return false ; } function checkToMakeEqual ( S1 , S2 ) { var freq = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < S1 . length ; i ++ ) { freq [ S1 [ i ] - ' ' ] ++ ; } var flag = 0 ; for ( var i = 0 ; i < S2 . length ; i ++ ) { if ( freq [ S2 [ i ] - ' ' ] == 0 ) { flag = true ; break ; } freq [ S2 [ i ] - ' ' ] -- ; } if ( flag == true ) { document . write ( \" \" ) ; return ; } var invCount1 = inversionCount ( S1 ) ; var invCount2 = inversionCount ( S2 ) ; if ( invCount1 == invCount2 || ( invCount1 & 1 ) == ( invCount2 & 1 ) || haveRepeated ( S1 , S2 ) ) { document . write ( \" \" ) ; } else document . write ( \" \" ) ; } var S1 = \" \" , S2 = \" \" ; checkToMakeEqual ( S1 , S2 ) ;"}
{"text": "Susun Arahan Bitonic | Berfungsi untuk menyusun array bitonic dalam ruang malar; Memulakan nilai k; Dalam setiap lelaran Bandingkan Elemen K jarak jauh dan bertukar jika mereka tidak teratur; K dikurangkan kepada separuh selepas setiap lelaran; Cetak elemen array; Diberikan array arr []; Panggilan fungsi", "code": "function sortArr ( a , n ) { let i , k ; k = parseInt ( Math . log ( n ) / Math . log ( 2 ) ) ; k = parseInt ( Math . pow ( 2 , k ) ) ; while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) { let tmp = a [ i ] ; a [ i ] = a [ i + k ] ; a [ i + k ] = tmp ; } k = k / 2 ; } for ( i = 0 ; i < n ; i ++ ) { document . write ( a [ i ] + \" \" ) ; } } let arr = [ 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 ] ; let n = arr . length ; sortArr ( arr , n ) ;"}
{"text": "Split array ke dalam sub subset untuk memaksimumkan jumlah maksimum dan minimum mereka | Fungsi yang memaparkan jumlah maksimum yang mungkin; Cari elemen dalam setiap kumpulan; Menyusun semua elemen dalam perintah bukan menurun; Tambah un elemen terbesar; Untuk jumlah elemen minimum dari setiap subset; Prleting jumlah maksimum; Kod pemacu", "code": "function maximumSum ( arr , n , k ) { let elt = ( n / k ) ; let sum = 0 ; arr . sort ( ( a , b ) => a - b ) ; let count = 0 ; let i = n - 1 ; while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ; while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; } document . write ( sum ) ; } let Arr = [ 1 , 13 , 7 , 17 , 6 , 5 ] ; let K = 2 ; let size = Arr . length ; maximumSum ( Arr , size , K ) ;"}
{"text": "Kurangkan jumlah unsur -unsur terkecil dari k -lekukan panjang l | Berfungsi untuk mencari jumlah minimum; Susun array; Hitung jumlah elemen k terkecil; Mengembalikan jumlahnya; Kod pemacu", "code": "function findMinSum ( arr , K , L , size ) { if ( K * L > size ) return - 1 ; let minsum = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; } let arr = [ 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 ] ; let K = 3 ; let L = 2 ; let length = arr . length ; document . write ( findMinSum ( arr , K , L , length ) ) ;"}
{"text": "KTH elemen terkecil atau terbesar dalam array yang tidak disusun | Tetapkan 4 | Berfungsi untuk mencari elemen terkecil kth dalam array yang tidak disusun; Memulakan elemen max sebagai 0; ARR [] dan cari elemen maksimum di dalamnya; Arahan kekerapan untuk menyimpan frekuensi; Pemboleh ubah kaunter; Mengira frekuensi; Melangkah melalui freq []; Semak sama ada NUM terdapat dalam array; Meningkatkan kaunter dengan kekerapan NUM; Memeriksa jika kita telah mencapai elemen terkecil KTH; Mengembalikan elemen terkecil kth; Diberikan array; Panggilan fungsi", "code": "function findKthSmallest ( arr , n , k ) { let max = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } let counter = Array . from ( { length : max + 1 } , ( _ , i ) => 0 ) ; let smallest = 0 ; for ( let i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( let num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } return - 1 ; } let arr = [ 7 , 1 , 4 , 4 , 20 , 15 , 8 ] ; let N = arr . length ; let K = 5 ; document . write ( findKthSmallest ( arr , N , K ) ) ;"}
{"text": "Menjana semua nombor sehingga n dalam urutan leksikografi | Berfungsi untuk mencetak semua nombor sehingga n dalam urutan leksikografi; Program Pemandu", "code": "function lexNumbers ( n ) { let s = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) { s . push ( i . toString ( ) ) ; } s . sort ( ) ; let ans = [ ] ; for ( let i = 0 ; i < n ; i ++ ) ans . push ( parseInt ( s [ i ] ) ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( ans [ i ] + \" \" ) ; } let n = 15 ; lexNumbers ( n ) ;"}
{"text": "Susun Matriks dalam Perintah Menaik dan Menurun Rowwise | Pelaksanaan JavaScript untuk mencetak baris matriks dalam urutan menaik atau menurun secara alternatif; Matriks iterate rowwise; Menyusun baris dalam urutan menaik; Bandingkan unsur -unsur bersebelahan; swap elemen bersebelahan; Menyusun baris dalam urutan menurun; Bandingkan unsur -unsur bersebelahan; swap elemen bersebelahan; Mencetak output akhir; Kod pemacu", "code": "let N = 4 ; function func ( a ) { for ( let i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { for ( let j = 0 ; j < N ; j ++ ) { for ( let k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] > a [ i ] [ k ] ) { let temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } else { for ( let j = 0 ; j < N ; j ++ ) { for ( let k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] < a [ i ] [ k ] ) { let temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { document . write ( \" \" + a [ i ] [ j ] ) ; } document . write ( \" \" ) ; } } let a = [ [ 5 , 7 , 3 , 4 ] , [ 9 , 5 , 8 , 2 ] , [ 6 , 3 , 8 , 1 ] , [ 5 , 8 , 9 , 3 ] ] ; func ( a ) ;"}
{"text": "Cari berat MST dalam graf lengkap dengan Edge | Untuk menyimpan tepi graf yang diberikan; Fungsi utiliti untuk melaksanakan traversal DFS; Semak simpang yang disimpan dalam set; Vertices dimasukkan jika berat kelebihan adalah 0; Fungsi utiliti untuk mencari berat pokok minimum; Untuk mengira komponen yang disambungkan; Memasukkan simpul awal dalam set; Melintasi simpang yang disimpan dalam set dan menjalankan traversal DFS untuk setiap simpang; Meningkatkan komponen bersambung berat sifar; DFS traversal untuk setiap vertex mengeluarkan; Kod pemandu; Masukkan tepi; Fungsi Panggilan Cari berat pokok minimum", "code": "let g = new Array ( 200005 ) ; for ( let i = 0 ; i < 200005 ; i ++ ) g [ i ] = new Map ( ) ; let s = new Set ( ) ; let ns = new Set ( ) ; function dfs ( x ) { let v = [ ] ; for ( let it of s . values ( ) ) { if ( g [ x ] . get ( it ) != null ) { v . push ( it ) ; } else { ns . add ( it ) ; } } s = ns ; for ( let i of v . values ( ) ) { dfs ( i ) ; } } function weightOfMST ( N ) { let cnt = 0 ; for ( let i = 1 ; i <= N ; ++ i ) { s . add ( i ) ; } let qt = [ ] for ( let t of s . values ( ) ) qt . push ( t ) ; while ( qt . length != 0 ) { ++ cnt ; let t = qt [ 0 ] ; qt . shift ( ) ; dfs ( t ) ; } document . write ( cnt - 4 ) ; } let N = 6 , M = 11 ; let edges = [ [ 1 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 1 , 6 ] , [ 2 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 3 , 4 ] , [ 3 , 5 ] , [ 3 , 6 ] ] ; for ( let i = 0 ; i < M ; ++ i ) { let u = edges [ i ] [ 0 ] ; let v = edges [ i ] [ 1 ] ; g [ u ] . set ( v , 1 ) ; g [ v ] . set ( u , 1 ) ; } weightOfMST ( N ) ;"}
{"text": "Kira pasangan yang mungkin berbeza supaya elemen dari A lebih besar daripada elemen dari b | Berfungsi untuk mengembalikan kiraan pasangan; Kod pemacu", "code": "function countPairs ( A , B ) { let n = A . length ; let ans = 0 ; A . sort ( ) ; B . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; } let A = [ 30 , 28 , 45 , 22 ] ; let B = [ 35 , 25 , 22 , 48 ] ; document . write ( countPairs ( A , B ) ) ;"}
{"text": "Sisa maksimum mungkin apabila elemen dibahagikan dengan elemen lain dalam array | Berfungsi untuk mengembalikan nilai mod maksimum untuk mana -mana pasangan dari array; Cari elemen maksimum kedua dari array; Kod pemacu", "code": "function maxMod ( arr , n ) { let maxVal = arr . sort ( ( a , b ) => b - a ) [ 0 ] let secondMax = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; } let arr = [ 2 , 4 , 1 , 5 , 3 , 6 ] ; let n = arr . length ; document . write ( maxMod ( arr , n ) ) ;"}
{"text": "Pilih x elemen dari elemen [] dan y dari b [] yang memenuhi syarat yang diberikan | Berfungsi untuk pulangan yang benar jika mungkin untuk memilih unsur -unsur; Jika unsur -unsur tidak dapat dipilih; Menyusun kedua -dua tatasusunan; Jika elemen terkecil X adalah lebih kecil daripada elemen terbesar Yth; Kod pemacu", "code": "function isPossible ( A , B , n , m , x , y ) { if ( x > n y > m ) return false ; A . sort ( ) ; B . sort ( ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; } var A = [ 1 , 1 , 1 , 1 , 1 ] ; var B = [ 2 , 2 ] ; var n = A . length ; var m = B . length ; ; var x = 3 , y = 1 ; if ( isPossible ( A , B , n , m , x , y ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Cari perubahan minimum yang diperlukan dalam array untuk mengandungi elemen K yang berbeza | Program JavaScript kepada perubahan minimum yang diperlukan dalam array untuk elemen K yang berbeza. ; Fungsi kepada perubahan minimum yang diperlukan dalam array untuk elemen K yang berbeza. ; Simpan kekerapan setiap elemen; Simpan kekerapan elemen; Jenis frekuensi dalam urutan menurun; Untuk menyimpan jawapan yang diperlukan; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "var MAX = 100005 ; function Min_Replace ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) var freq = Array ( MAX ) . fill ( 0 ) ; var p = 0 ; freq [ p ] = 1 ; for ( var i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } freq . sort ( ( a , b ) => b - a ) ; var ans = 0 ; for ( var i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; } var arr = [ 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 ] ; var n = arr . length ; var k = 2 ; document . write ( Min_Replace ( arr , n , k ) ) ;"}
{"text": "Bilangan maksimum elemen tanpa bertindih dalam garis | Berfungsi untuk mencari bilangan elemen maksimum tanpa bertindih dalam garis; Jika n = 1, maka jawapannya adalah satu; Kami sentiasa boleh membuat elemen 1 st untuk menutup segmen kiri dan nth segmen yang betul; Jika segmen kiri untuk elemen ith tidak bertindih dengan elemen i - 1 maka kemudian kiri; lain cuba ke arah yang betul jika boleh; Kemas kini x [i] ke endpolet kanan segmen yang diliputi olehnya; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "function Segment ( x , l , n ) { if ( n == 1 ) return 1 ; let ans = 2 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; } let x = [ 1 , 3 , 4 , 5 , 8 ] , l = [ 10 , 1 , 2 , 2 , 5 ] ; let n = x . length ; document . write ( Segment ( x , l , n ) ) ;"}
{"text": "Padam ganjil dan bahkan nombor pada langkah alternatif supaya jumlah elemen yang tinggal diminimumkan | Berfungsi untuk mencari jumlah yang diminimumkan; Jika lebih banyak elemen ganjil; Menyusun unsur -unsur; Kiri - lebih dari elemen; Cari jumlah unsur sisa; Mengembalikan jumlahnya; Jika lebih banyak elemen; Menyusun unsur -unsur; Kiri - lebih dari elemen; Cari jumlah unsur sisa; Mengembalikan jumlahnya; Jika elemen yang sama; Kod pemacu", "code": "function MinimizeleftOverSum ( a , n ) { var v1 = [ ] , v2 = [ ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) v1 . push ( a [ i ] ) ; else v2 . push ( a [ i ] ) ; } if ( v1 . length > v2 . length ) { v1 . sort ( ) ; v2 . sort ( ) ; var x = v1 . length - v2 . length - 1 ; var sum = 0 ; var i = 0 ; while ( i < x ) { sum += v1 [ i ++ ] ; } return sum ; } else if ( v2 . length > v1 . length ) { v1 . sort ( ) ; v2 . sort ( ) ; var x = v2 . length - v1 . length - 1 ; var sum = 0 ; var i = 0 ; while ( i < x ) { sum += v2 [ i ++ ] ; } return sum ; } else return 0 ; } var a = [ 2 , 2 , 2 , 2 ] ; var n = a . length ; document . write ( MinimizeleftOverSum ( a , n ) ) ;"}
{"text": "Operasi minimum untuk membuat kekerapan semua aksara sama k | Berfungsi untuk mencari bilangan minimum operasi untuk menukar rentetan yang diberikan; Semak jika n boleh dibahagikan dengan k; Array untuk menyimpan kekerapan aksara dalam rentetan yang diberikan; Dua tatasusunan dengan bilangan operasi yang diperlukan; Memeriksa semua kemungkinan; Kod pemacu", "code": "function minOperation ( S , N , K ) { if ( N % K ) { document . write ( \" \" ) ; return ; } var count = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { count [ S [ i ] . charCodeAt ( 0 ) - 97 ] ++ ; } var E = N / K ; var greaterE = [ ] ; var lessE = [ ] ; for ( var i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] < E ) lessE . push ( E - count [ i ] ) ; else greaterE . push ( count [ i ] - E ) ; } greaterE . sort ( ) ; lessE . sort ( ) ; var mi = 1000000000 ; for ( var i = 0 ; i <= K ; i ++ ) { var set1 = i ; var set2 = K - i ; if ( greaterE . length >= set1 && lessE . length >= set2 ) { var step1 = 0 ; var step2 = 0 ; for ( var j = 0 ; j < set1 ; j ++ ) step1 += greaterE [ j ] ; for ( var j = 0 ; j < set2 ; j ++ ) step2 += lessE [ j ] ; mi = Math . min ( mi , Math . max ( step1 , step2 ) ) ; } } document . write ( mi ) ; } var S = \" \" ; var N = S . length ; var K = 2 ; minOperation ( S , N , K ) ;"}
{"text": "Operasi Peningkatan Julat Minimum Untuk Mengasingkan Array | Berfungsi untuk mencari kenaikan julat minimum untuk menyusun array; Jika elemen semasa didapati lebih besar daripada kenaikan elemen terakhir semua istilah dalam julat i + 1 hingga n - 1; Minimum dalam julat I hingga n - 1; Kod pemacu", "code": "function minMovesToSort ( arr , n ) { var moves = 0 ; var i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; mn = arr [ i ] ; } return moves ; } var arr = [ 3 , 5 , 2 , 8 , 4 ] ; var n = arr . length ; document . write ( minMovesToSort ( arr , n ) ) ;"}
{"text": "Susun nombor utama array dalam perintah menurun | Pelaksanaan JavaScript pendekatan; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Fungsi yang menyusun semua nombor utama dari array dalam menurun; Vektor ini akan mengandungi nombor utama untuk disusun; Jika elemen itu adalah perdana; mengemas kini elemen array; Kod pemacu; Cetak hasilnya.", "code": "var prime = Array ( 100005 ) . fill ( true ) ; function SieveOfEratosthenes ( n ) { prime [ 1 ] = false ; for ( var p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( var i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } function sortPrimes ( arr , n ) { SieveOfEratosthenes ( 100005 ) ; var v = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) v . push ( arr [ i ] ) ; } v . sort ( ( a , b ) => b - a ) var j = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) arr [ i ] = v [ j ++ ] ; } } var arr = [ 4 , 3 , 2 , 6 , 100 , 17 ] ; var n = arr . length ; sortPrimes ( arr , n ) ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; }"}
{"text": "Pembentukan pasangan sedemikian rupa sehingga jumlah pasangan maksimum diminimumkan | / Program JavaScript untuk membahagikan array ke pasangan N seperti pasangan maksimum diminimumkan; Selepas menyusun mengekalkan dua pembolehubah i dan j menunjuk untuk memulakan dan mengakhiri array sedemikian rupa sehingga elemen terkecil pasangan array dengan elemen terbesar; Kod pemacu", "code": "function findOptimalPairs ( arr , N ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; for ( var i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) document . write ( \" \" + arr [ i ] + \" \" + arr [ j ] + \" \" + \" \" ) ; } var arr = [ 9 , 6 , 5 , 1 ] ; var N = arr . length ; findOptimalPairs ( arr , N ) ;"}
{"text": "Sort Array mengikut kiraan bit set | fungsi utiliti yang mengembalikan jumlah bit set dalam integer; Berfungsi secara serentak menyusun kedua -dua tatasusunan menggunakan jenis penyisipan (https: www. Geeksforgeeks. Org / sisipan - sort /); Gunakan 2 kekunci kerana kita perlu menyusun kedua -dua tatasusunan secara serentak; Gerakkan unsur -unsur ARR [0 .. i - 1] dan aux [0 .. i - 1], seperti unsur -unsur aux [0 .. i - 1] adalah lebih besar daripada Key1, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi untuk disusun mengikut kiraan bit menggunakan array tambahan; Buat array dan kiraan bit set di dalamnya. ; Susun arr [] mengikut nilai dalam aux []; Fungsi utiliti untuk mencetak array; Kod pemacu", "code": "function countBits ( a ) { let count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; } function insertionSort ( arr , aux , n ) { for ( let i = 1 ; i < n ; i ++ ) { let key1 = aux [ i ] ; let key2 = arr [ i ] ; let j = i - 1 ; while ( j >= 0 && aux [ j ] < key1 ) { aux [ j + 1 ] = aux [ j ] ; arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } aux [ j + 1 ] = key1 ; arr [ j + 1 ] = key2 ; } } function sortBySetBitCount ( arr , n ) { let aux = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) aux [ i ] = countBits ( arr [ i ] ) ; insertionSort ( arr , aux , n ) ; } function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + \" \" ) ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; let n = arr . length ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ;"}
{"text": "Sort Array mengikut kiraan bit set | fungsi utiliti yang mengembalikan jumlah bit set dalam integer; Fungsi untuk disusun mengikut kiraan bit. Fungsi ini mengandaikan bahawa terdapat 32 bit dalam integer. ; Digunakan sebagai indeks dalam pelbagai disusun akhir; Melintasi semua bit bit (perhatikan bahawa kami menyusun array dalam penurunan urutan); Fungsi utiliti untuk mencetak array; Kod pemacu", "code": "function countBits ( a ) { let count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; } function sortBySetBitCount ( arr , n ) { let count = new Array ( 32 ) ; for ( let i = 0 ; i < count . length ; i ++ ) count [ i ] = [ ] ; let setbitcount = 0 ; for ( let i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . push ( arr [ i ] ) ; } let j = 0 ; for ( let i = 31 ; i >= 0 ; i -- ) { let v1 = count [ i ] ; for ( let p = 0 ; p < v1 . length ; p ++ ) arr [ j ++ ] = v1 [ p ] ; } } function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + \" \" ) ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; let n = arr . length ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ;"}
{"text": "Rentetan binari terkecil lexicographically dibentuk dengan membalikkan bit pada indeks yang tidak dapat dibahagi k1 atau k2 supaya kiraan 1 s sentiasa lebih besar daripada 0 s dari kiri | Berfungsi untuk mencari rentetan terkecil secara lexicographically yang mempunyai bilangan 1 s lebih besar daripada bilangan 0 s; C1S dan C0S menyimpan kiraan 1 s dan 0 s pada setiap kedudukan; Melintasi rentetan s; Jika kedudukan tidak dapat dibahagikan dengan k1 dan k2; Jika c0s> = c1s dan pos [] kosong maka rentetan tidak dapat dibentuk; Jika POS [] tidak kosong maka flip sedikit kedudukan terakhir yang terdapat di POS []; Cetak hasilnya; Kod pemacu", "code": "function generateString ( k1 , k2 , s ) { let C1s = 0 , C0s = 0 ; let flag = 0 ; let pos = [ ] ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) { C0s ++ ; if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . push ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) { if ( pos . length == 0 ) { cout << - 1 ; flag = 1 ; break ; } else { let k = pos [ pos . length - 1 ] ; var ns = s . replace ( s [ k ] , ' ' ) ; C0s -- ; C1s ++ ; pos . pop ( ) ; } } } if ( flag == 0 ) { document . write ( ns ) ; } } let K1 = 2 , K2 = 4 ; let S = \" \" ; generateString ( K1 , K2 , S ) ;"}
{"text": "Cari sepasang nombor dengan set bit set sebagai kebanyakan n dan yang bitwise xor adalah n | Fungsi untuk mencari pasangan (x, y) sedemikian rupa sehingga x xor y = n dan kiraan bit set dalam x dan y kurang daripada kiraan set bit dalam n; Kedai MSB (Bit Paling Penting); Menyimpan nilai x; Menyimpan nilai y; Melintasi semua bit N; Jika ia bit n ialah 0; Tetapkan sedikit x hingga 1; Tetapkan sedikit Y hingga 1; Jawapan cetak; Kod pemacu", "code": "function maximizeProduct ( N ) { let MSB = Math . log2 ( N ) ; let X = 1 << MSB ; let Y = N - ( 1 << MSB ) ; for ( let i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } document . write ( X + \" \" + Y ) ; } let N = 45 ; maximizeProduct ( N ) ;"}
{"text": "Count of Numbers in Range [l, r] mempunyai jumlah digit persegi sama dengan kuadrat jumlah digit | Fungsi untuk memeriksa sama ada nombor itu sah; Jumlah digit Num; Nombor kuadrat; Jumlah digit (num * num); Berfungsi untuk menukar rentetan ke integer; Berfungsi untuk menghasilkan semua rentetan panjang yang mungkin; Rentetan yang dikehendaki; Hanya mengambil nombor yang sah; Berulang untuk semua digit yang mungkin; Berfungsi untuk mengira nombor unik dalam julat [l, r]; Memulakan pembolehubah untuk menyimpan jawapannya; Kirakan panjang maksimum yang mungkin; Tetapkan untuk menyimpan nombor yang sah yang berbeza; Menjana semua rentetan panjang yang mungkin i; I -meletakkan set untuk mendapatkan kiraan nombor yang sah dalam julat [l, r]; Kod pemacu", "code": "function check ( num ) { let sm = 0 ; let num2 = num * num ; while ( num ) { sm += num % 10 ; num = Math . floor ( num / 10 ) ; } let sm2 = 0 ; while ( num2 ) { sm2 += num2 % 10 ; num2 = Math . floor ( num2 / 10 ) ; } return sm * sm == sm2 ; } function convert ( s ) { let val = 0 ; s = s . split ( \" \" ) . reverse ( ) . join ( \" \" ) ; let cur = 1 ; for ( let i = 0 ; i < s . length ; i ++ ) { val += ( s [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ) * cur ; cur *= 10 ; } return val ; } function generate ( s , len , uniq ) { if ( s . length == len ) { if ( check ( convert ( s ) ) ) { uniq . add ( convert ( s ) ) ; } return ; } for ( let i = 0 ; i <= 3 ; i ++ ) { generate ( s + String . fromCharCode ( i + \" \" . charCodeAt ( 0 ) ) , len , uniq ) ; } } function totalNumbers ( L , R ) { let ans = 0 ; let max_len = Math . log10 ( R ) + 1 ; let uniq = new Set ( ) ; for ( let i = 1 ; i <= max_len ; i ++ ) { generate ( \" \" , i , uniq ) ; } for ( let x of uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; } let L = 22 , R = 22 ; document . write ( totalNumbers ( L , R ) ) ;"}
{"text": "Tukar x ke y dengan berulang kali mengalikan x dengan 2 atau tampuk 1 pada akhir | Fungsi untuk memeriksa sama ada x boleh ditukar kepada y dengan mengalikan x dengan 2 atau menambahkan 1 pada akhir; ITERATE Sehingga Y adalah sekurang -kurangnya x; Jika y juga; Jika digit terakhir Y ialah 1; Jika tidak; Semak sama ada x sama dengan y; Kod pemacu", "code": "function convertXintoY ( X , Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y = parseInt ( Y / 2 ) ; else if ( Y % 10 == 1 ) Y = parseInt ( Y /= 10 ) ; else break ; } if ( X == Y ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let X = 100 , Y = 40021 ; convertXintoY ( X , Y ) ;"}
{"text": "Lexicographically terkecil rentetan panjang maksimum yang terdiri daripada huruf k pertama yang tidak mengandungi apa -apa substring berulang | Berfungsi untuk mencari rentetan terkecil lexicographically dari huruf kaum K bawah pertama yang mempunyai substrings yang unik; Menyimpan rentetan yang dihasilkan; Melewati semua watak; Gelung dalaman untuk membuat pasangan dan menambahkannya ke dalam rentetan; Menambah watak pertama supaya substring yang terdiri daripada abjad yang terakhir hadir; Cetak rentetan yang dihasilkan; Kod pemacu", "code": "function generateString ( K ) { var s = \" \" ; for ( var i = 97 ; i < 97 + K ; i ++ ) { s = s + String . fromCharCode ( i ) ; for ( var j = i + 1 ; j < 97 + K ; j ++ ) { s += String . fromCharCode ( i ) ; s += String . fromCharCode ( j ) ; } } s += String . fromCharCode ( 97 ) ; document . write ( s ) ; } var K = 4 ; generateString ( K ) ;"}
{"text": "Menjana Persamaan Kuadratik setelah memberikan jumlah dan produk akar | Berfungsi untuk mencari persamaan kuadratik dari jumlah dan produk akar yang diberikan; Cetak pekali; Kod pemacu", "code": "function findEquation ( S , M ) { document . write ( \" \" + ( ( - 1 ) * S ) + \" \" + M ) ; } var S = 5 , M = 6 ; findEquation ( S , M ) ;"}
{"text": "Buat semua elemen array sama dengan menggantikan pasangan bersebelahan dengan jumlah mereka | Fungsi untuk mengira bilangan minimum pasang unsur -unsur bersebelahan yang diperlukan untuk digantikan oleh jumlah mereka untuk membuat semua elemen array sama; Menyimpan jumlah awalan array; Kirakan Array Jumlah Awalan; Menyimpan bilangan maksimum subarray yang mana array boleh dibahagikan; Melangkah ke atas semua jumlah yang mungkin; Melintasi array; Jika jumlahnya sama dengan jumlah awalan semasa; Kira kenaikan kumpulan sebanyak 1; Jika tidak buang jumlah subkumpulan ini; Mengemas kini maksimum ini subarray; Mengembalikan bilangan operasi minimum; Kod pemacu; Panggilan fungsi", "code": "function minSteps ( a , n ) { var prefix_sum = Array ( n ) . fill ( 0 ) ; prefix_sum [ 0 ] = a [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] + a [ i ] ; var mx = - 1 ; for ( var subgroupsum = 0 ; subgroupsum < prefix_sum . length ; subgroupsum ++ ) { var sum = 0 ; var i = 0 ; var grp_count = 0 ; while ( i < n ) { sum += a [ i ] ; if ( sum == prefix_sum [ subgroupsum ] ) { grp_count += 1 ; sum = 0 ; } else if ( sum > prefix_sum [ subgroupsum ] ) { grp_count = - 1 ; break ; } i += 1 ; } if ( grp_count > mx ) mx = grp_count ; } return n - mx ; } var A = [ 1 , 2 , 3 , 2 , 1 , 3 ] ; var N = A . length ; document . write ( minSteps ( A , N ) ) ;"}
{"text": "Karakter yang paling kerap dalam rentetan selepas menggantikan semua kejadian x dalam rentetan binari | Berfungsi untuk mencari watak yang paling kerap selepas menggantikan x dengan sama ada '0' atau '1' mengikut syarat -syarat yang diberikan; Simpan kiraan 0 s dan 1 s dalam rentetan S; Hitung kekerapan 0 dan 1; Jika wataknya adalah 1; Jika wataknya 0; Kedai pertama berlaku 1; Melintasi rentetan untuk mengira bilangan x antara dua berturut -turut 1 s; Jika watak semasa bukan x; Jika aksara semasa adalah 1, tambahkan bilangan Xs ke Count1 dan tetapkan sebelum i; Jika tidak; Cari kejadian seterusnya 1 dalam rentetan; Jika ia dijumpai, tetapkan saya ke sebelumnya; Jika tidak, keluar dari gelung; Simpan kejadian pertama 0; Ulangi prosedur yang sama untuk mengira bilangan x antara dua berturut -turut 0 s; Jika watak semasa bukan x; Jika watak semasa adalah 0; Tambah kiraan XS ke Count0; Tetapkan sebelumnya ke i; Jika tidak; Cari kejadian seterusnya 0 dalam rentetan; Jika ia dijumpai, tetapkan saya ke sebelumnya; Jika tidak, keluar dari gelung; Kiraan bilangan x yang hadir dalam permulaan rentetan sebagai xxxx1 ...; Simpan kiraan x; Kenaikan kiraan1 dengan kiraan jika keadaan itu berpuas hati; Hitung bilangan x yang hadir pada akhir rentetan sebagai ... xxxx0; Simpan kiraan x; Kenaikan kiraan dengan kiraan jika keadaan itu berpuas hati; Jika kiraan 1 adalah sama dengan kiraan 0, cetak x; Jika tidak, jika kiraan 1 lebih besar daripada kiraan 0; Jika tidak, cetak 0; Kod pemacu", "code": "function maxOccuringCharacter ( s ) { var count0 = 0 , count1 = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == ' ' ) { count1 ++ ; } else if ( s . charAt ( i ) == ' ' ) { count0 ++ ; } } var prev = - 1 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == ' ' ) { prev = i ; break ; } } for ( var i = prev + 1 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) != ' ' ) { if ( s . charAt ( i ) == ' ' ) { count1 += i - prev - 1 ; prev = i ; } else { flag = true ; for ( var j = i + 1 ; j < s . length ; j ++ ) { if ( s . charAt ( j ) == ' ' ) { flag = false ; prev = j ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ; } } } } prev = - 1 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == ' ' ) { prev = i ; break ; } } for ( var i = prev + 1 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) != ' ' ) { if ( s . charAt ( i ) == ' ' ) { count0 += i - prev - 1 ; prev = i ; } else { flag = true ; for ( var j = i + 1 ; j < s . length ; j ++ ) { if ( s . charAt ( j ) == ' ' ) { prev = j ; flag = false ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ; } } } } if ( s . charAt ( 0 ) == ' ' ) { var count = 0 ; var i = 0 ; while ( s . charAt ( i ) == ' ' ) { count ++ ; i ++ ; } if ( s . charAt ( i ) == ' ' ) { count1 += count ; } } if ( s . charAt ( s . length - 1 ) == ' ' ) { var count = 0 ; var i = s . length - 1 ; while ( s . charAt ( i ) == ' ' ) { count ++ ; i -- ; } if ( s . charAt ( i ) == ' ' ) { count0 += count ; } } if ( count0 == count1 ) { document . write ( \" \" ) ; } else if ( count0 > count1 ) { document . write ( 0 ) ; } else document . write ( 1 ) ; } var S = \" \" ; maxOccuringCharacter ( S ) ;"}
{"text": "Memaksimumkan kiraan lembaran yang mungkin dengan berulang kali mengurangkan kawasannya kepada separuh | Fungsi untuk mengira bilangan maksimum lembaran yang mungkin dengan operasi yang diberikan; Kiraan awal lembaran; Terus membahagikan kepingan ke separuh; Mengurangkan kawasan dengan separuh; Meningkatkan kiraan dua kali; Kod pemacu", "code": "function maxSheets ( A , B ) { let area = A * B ; let count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; } let A = 5 , B = 10 ; document . write ( maxSheets ( A , B ) ) ;"}
{"text": "Bilangan langkah minimum yang diperlukan untuk mencapai asal dari titik tertentu | Berfungsi untuk mencari langkah minimum yang diperlukan untuk mencapai asal dari (a, b); Menyimpan bilangan minimum bergerak; Periksa sama ada perbezaan mutlak ialah 1 atau 0; Simpan minimum a, b; Simpan maksimum a, b; Cetak jawapannya; Diberikan Co - ordinat; Panggilan fungsi", "code": "function findMinMoves ( a , b ) { let ans = 0 ; if ( a == b || Math . abs ( a - b ) == 1 ) { ans = a + b ; } else { let k = Math . min ( a , b ) ; let j = Math . max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } document . write ( ans ) ; } let a = 3 , b = 5 ; findMinMoves ( a , b ) ;"}
{"text": "Kira walaupun jumlah pasangan yang mungkin dengan memilih dua bilangan bulat dari dua julat yang diberikan masing -masing | Fungsi untuk mengira maksimum walaupun jumlah pasangan dalam julat yang diberikan; Menyimpan kiraan nombor antara 1 hingga x; Menyimpan kiraan nombor ganjil antara 1 hingga x; Menyimpan kiraan nombor antara 1 hingga y; Menyimpan kiraan nombor ganjil antara 1 hingga y; Menyimpan kiraan pasangan yang mempunyai jumlah wang; Mengimbangi kiraan pasangan yang mempunyai jumlah; Kod pemacu", "code": "function cntEvenSumPairs ( X , Y ) { var cntXEvenNums = parseInt ( X / 2 ) ; var cntXOddNums = parseInt ( ( X + 1 ) / 2 ) ; var cntYEvenNums = parseInt ( Y / 2 ) ; var cntYOddNums = parseInt ( ( Y + 1 ) / 2 ) ; var cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ; return cntPairs ; } var X = 2 ; var Y = 3 ; document . write ( cntEvenSumPairs ( X , Y ) ) ;"}
{"text": "Kurangkan elemen array yang diperlukan untuk ditingkatkan atau diturunkan untuk menukar array yang diberikan ke dalam siri Fibonacci | Fungsi untuk mengira bilangan minimum bergerak untuk membuat urutan siri Fibonacci; Jika bilangan elemen kurang daripada 3; Memulakan nilai hasilnya; Cuba semua permutasi dua elemen pertama; Nilai elemen pertama selepas operasi; Nilai elemen kedua selepas operasi; Hitung bilangan gerakan untuk unsur -unsur array; Elemen pada indeks IDX; Sekiranya tidak mungkin untuk menukar elemen dalam satu langkah; Jika tidak; Mengemas kini jawapannya; Kembalikan jawapannya; Kod pemacu", "code": "function minMoves ( arr ) { let N = arr . length ; if ( N <= 2 ) return 0 ; let ans = Number . MAX_VALUE ; for ( let i = - 1 ; i <= 1 ; i ++ ) { for ( let j = - 1 ; j <= 1 ; j ++ ) { let num1 = arr [ 0 ] + i ; let num2 = arr [ 1 ] + j ; let flag = 1 ; let moves = Math . abs ( i ) + Math . abs ( j ) ; for ( let idx = 2 ; idx < N ; idx ++ ) { let num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Number . MAX_VALUE ) return - 1 ; return ans ; } let arr = [ 4 , 8 , 9 , 17 , 27 ] ; document . write ( minMoves ( arr ) ) ;"}
{"text": "Pertanyaan untuk mengira jumlah elemen array yang hadir pada setiap indeks yth bermula dari indeks x | Fungsi untuk mencari jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua pertanyaan; Melangkah ke atas setiap pertanyaan; Menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array dan mengira jumlah ungkapan; Kemas kini Jumlah; Kemas kini x; Kod pemacu", "code": "function querySum ( arr , N , Q , M ) { for ( let i = 0 ; i < M ; i ++ ) { let x = Q [ i ] [ 0 ] ; let y = Q [ i ] [ 1 ] ; let sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } document . write ( sum + \" \" ) ; } } let arr = [ 1 , 2 , 7 , 5 , 4 ] ; let Q = [ [ 2 , 1 ] , [ 3 , 2 ] ] ; let N = arr . length ; let M = Q . length ; querySum ( arr , N , Q , M ) ;"}
{"text": "Kirakan bitwise atau dua bilangan bulat dari nilai bitwise dan bitwise mereka yang diberikan | Fungsi untuk mengira bitwise atau dari bitwise xor dan bitwise dan nilai -nilai; Kod pemacu", "code": "function findBitwiseORGivenXORAND ( X , Y ) { return X + Y ; } let X = 5 , Y = 2 ; document . write ( findBitwiseORGivenXORAND ( X , Y ) ) ;"}
{"text": "Semak jika nilai yang diberikan dapat dicapai dari nilai lain dalam barisan bulat oleh k | Berfungsi untuk mengembalikan GCD dua nombor A dan B; Kes asas; Recursif mencari GCD; Fungsi untuk memeriksa B boleh digunakan dari A dengan lompatan elemen K dalam barisan bulat; Cari GCD N dan K; Jika A - B boleh dibahagikan dengan GCD maka cetak ya; Jika tidak; Kod pemacu; Panggilan fungsi", "code": "function GCD ( a , b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } function canReach ( N , A , B , K ) { var gcd = GCD ( N , K ) ; if ( Math . abs ( A - B ) % gcd == 0 ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } var N = 5 , A = 2 , B = 1 , K = 2 ; canReach ( N , A , B , K ) ;"}
{"text": "Count subarrays mempunyai jumlah yang sama dengan panjangnya | Tetapkan 2 | Fungsi yang mengira subarray dengan jumlah elemennya sebagai panjangnya; Simpan kiraan elemen sehingga elemen semasa dengan panjang i; Menyimpan kiraan akhir subarray; Menyimpan jumlah awalan; Jika saiz subarray adalah 1; Melelehkan array; Cari jumlahnya; Kekerapan kemas kini dalam peta; Cetak jumlah kiraan; Diberikan array arr []; Saiz array; Panggilan fungsi", "code": "function countOfSubarray ( arr , N ) { var mp = new Map ( ) ; var answer = 0 ; var sum = 0 ; if ( ! mp . has ( 1 ) ) mp . set ( 1 , 1 ) else mp . set ( 1 , mp . get ( 1 ) + 1 ) for ( var i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; answer += mp . has ( sum - i ) ? mp . get ( sum - i ) : 0 ; if ( mp . has ( sum - i ) ) mp . set ( sum - i , mp . get ( sum - i ) + 1 ) else mp . set ( sum - i , 1 ) } document . write ( answer ) ; } var arr = [ 1 , 0 , 2 , 1 , 2 , - 2 , 2 , 4 ] ; var N = arr . length ; countOfSubarray ( arr , N ) ;"}
{"text": "Split First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Berfungsi untuk memecah nombor semulajadi N pertama ke dalam dua set yang mempunyai perbezaan mutlak minimum jumlah mereka; Menyimpan jumlah unsur set1; Menyimpan jumlah unsur set2; Melintasi nombor semulajadi n pertama; Semak sama ada jumlah unsur set1 kurang daripada atau sama dengan jumlah unsur set2; Kod pemacu", "code": "function minAbsDiff ( N ) { var sumSet1 = 0 ; var sumSet2 = 0 ; for ( i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return Math . abs ( sumSet1 - sumSet2 ) ; } var N = 6 ; document . write ( minAbsDiff ( N ) ) ;"}
{"text": "Semak jika nombor adalah perdana terbalik terbalik, cermin dibalik dan cermin terbalik terbalik | Fungsi untuk memeriksa sama ada n mengandungi digit 0, 1, 2, 5, 8 sahaja; Ekstrak digit n; Kembali palsu jika mana -mana digit ini hadir; Fungsi untuk memeriksa sama ada n adalah perdana atau tidak; Semak semua faktor; Fungsi untuk memeriksa sama ada n adalah perdana dalam semua bentuk yang dikehendaki; Kod pemacu", "code": "function checkDigits ( n ) { do { var r = n % 10 ; if ( r == 3 r == 4 r == 6 r == 7 r == 9 ) return false ; n = parseInt ( n / 10 ) ; } while ( n != 0 ) ; return true ; } function isPrime ( n ) { if ( n <= 1 ) return false ; for ( var i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } function isAllPrime ( n ) { return isPrime ( n ) && checkDigits ( n ) ; } var N = 101 ; if ( isAllPrime ( N ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Kos minimum diperlukan untuk menjana urutan pendakap seimbang | Fungsi untuk mengira kos minimum yang diperlukan untuk menjana urutan pendakap yang seimbang; Menyimpan kiraan kurungan terbuka tidak seimbang; Menyimpan kiraan kurungan tertutup yang tidak seimbang; Menyimpan kiraan kurungan terbuka; Menyimpan kiraan kurungan tertutup; Jika pendakap terbuka ditemui; Jika tidak; Sekiranya tiada kurungan terbuka tidak seimbang; Meningkatkan kiraan kurungan tertutup yang tidak seimbang; Jika tidak; Mengurangkan kiraan kurungan terbuka yang tidak seimbang; Meningkatkan kiraan kurungan tertutup; Mengira batas kos minimum yang lebih rendah; Mengurangkan kurungan terbuka atau tertutup yang berlebihan untuk mengelakkan mengira mereka dua kali; Kemas kini jawapan dengan menambahkan minimum mengeluarkan kedua -dua kurungan terbuka dan tertutup yang tidak seimbang atau memasukkan kurungan tidak seimbang tertutup ke hujung rentetan; Hasilnya; Kod pemacu", "code": "function minCost ( str , a , b ) { let openUnbalanced = 0 ; let closedUnbalanced = 0 ; let openCount = 0 ; let closedCount = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ' ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } let result = a * ( Math . abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += Math . min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; document . write ( result + \" \" ) ; } let str = \" \" ; let A = 1 , B = 3 ; minCost ( str , A , B ) ;"}
{"text": "Count of permutasi seperti jumlah nombor k dari julat yang diberikan adalah | Berfungsi untuk mengembalikan bilangan semua permutasi seperti jumlah nombor k dalam julat adalah walaupun; Cari jumlah kiraan nombor walaupun dan ganjil dalam julat yang diberikan; ITERATE LOOP K TIMES DAN UPDATE EVER_SUM & ODD_SUM Menggunakan nilai sebelumnya; Kemas kini prev_even dan odd_sum; Malah jumlah; Jumlah ganjil; Kembali even_sum; Diberikan julat; Panjang permutasi; Panggilan fungsi", "code": "function countEvenSum ( low , high , k ) { let even_count = high / 2 - ( low - 1 ) / 2 ; let odd_count = ( high + 1 ) / 2 - low / 2 ; let even_sum = 1 ; let odd_sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) { let prev_even = even_sum ; let prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } document . write ( even_sum ) ; } let low = 4 ; let high = 5 ; let K = 3 ; countEvenSum ( low , high , K ) ;"}
{"text": "Count of N digit nombor yang jumlahnya setiap digit berturut -turut adalah sama | Tetapkan 2 | Fungsi untuk mengira bilangan nombor n - digit sedemikian rupa sehingga jumlah setiap digit berturut -turut adalah sama; Cetak jawapannya; Kod pemacu", "code": "function count ( n , k ) { let count = Math . pow ( 10 , k ) - Math . pow ( 10 , k - 1 ) ; document . write ( count ) ; } let n = 2 , k = 1 ; count ( n , k ) ;"}
{"text": "Jumlah pembahagi terbesar nombor sehingga tidak dibahagikan dengan nombor perdana p | Berfungsi untuk mencari jumlah pembahagi terbesar nombor dalam julat 1 hingga n tidak boleh dibahagikan dengan nombor perdana p; Jumlah jumlah sehingga n; Jika tidak ada beberapa p yang ada sehingga n; Jika hanya p sendiri berada dalam lingkungan 1 hingga n; Jumlah mereka yang boleh dibahagikan dengan p; Panggilan fungsi rekursif untuk mencari jumlah untuk N / P; Diberikan n dan p; Panggilan fungsi", "code": "function func ( N , P ) { let sumUptoN = ( N * ( N + 1 ) / 2 ) ; let sumOfMultiplesOfP ; if ( N < P ) { return sumUptoN ; } else if ( ( N / P ) == 1 ) { return sumUptoN - P + 1 ; } sumOfMultiplesOfP = ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ; return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; } let N = 10 , P = 5 ; document . write ( func ( N , P ) ) ;"}
{"text": "Kira peralihan kanan untuk setiap elemen array berada dalam kedudukan yang disusun | Berfungsi untuk mencari peralihan yang betul yang diperlukan untuk setiap elemen untuk mencapai kedudukan array yang disusun dalam []; Kedai yang diperlukan bilangan peralihan untuk setiap elemen; Jika elemen berada pada kedudukan yang disusun; Jika tidak; Kirakan peralihan kanan; Prlet peralihan masing -masing; Kod pemacu", "code": "function findShifts ( A , N ) { let shift = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( let i = 0 ; i < N ; i ++ ) document . write ( shift [ i ] + \" \" ) ; } let arr = [ 1 , 4 , 3 , 2 , 5 ] ; let N = arr . length ; findShifts ( arr , N ) ;"}
{"text": "Membina matriks dengan jumlah yang sama dengan jumlah unsur pepenjuru | Berfungsi untuk membina matriks dengan jumlah pepenjuru yang sama dengan jumlah matriks; Jika kedudukan pepenjuru; Elemen positif; Elemen negatif; Kod pemacu", "code": "function constructmatrix ( N ) { let check = true ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( i == j ) { document . write ( \" \" ) ; } else if ( check ) { document . write ( \" \" ) ; check = false ; } else { document . write ( \" \" ) ; check = true ; } } document . write ( \" \" ) ; } } let N = 5 ; constructmatrix ( 5 ) ;"}
{"text": "Kiraan minimum nombor yang diperlukan dengan unit digit x yang merangkum sehingga n | Fungsi untuk mengira dan mengembalikan bilangan minimum kali nombor dengan unit digit X perlu ditambah untuk mendapatkan jumlah n; Kirakan bilangan penambahan yang diperlukan untuk mendapatkan digit unit N; Jika digit unit n tidak dapat diperoleh; Berfungsi untuk mengembalikan nombor minimum yang diperlukan untuk mewakili n; Kedai Unit Digit N; Penambahan minimum x yang diperlukan untuk mendapatkan digit unit N; Jika digit unit n tidak dapat diperoleh; Jika tidak; Jika n lebih besar daripada atau sama dengan (x * kali); Kiraan minimum nombor yang diperlukan untuk mewakili n; Perwakilan tidak mungkin; Kod pemacu", "code": "function check ( unit_digit , X ) { let times , digit ; for ( times = 1 ; times <= 10 ; times ++ ) { digit = ( X * times ) % 10 ; if ( digit == unit_digit ) return times ; } return - 1 ; } function getNum ( N , X ) { let unit_digit ; unit_digit = N % 10 ; let times = check ( unit_digit , X ) ; if ( times == - 1 ) return times ; else { if ( N >= ( times * X ) ) return times ; else return - 1 ; } } let N = 58 , X = 7 ; document . write ( getNum ( N , X ) ) ;"}
{"text": "Bilangan minimum mata yang diperlukan untuk menampung semua blok 2 | Berfungsi untuk mencari bilangan minimum polet yang diperlukan untuk menampung grid; Jika bilangan blok adalah juga; Mengembalikan polet minimum; Diberikan saiz grid; Panggilan fungsi", "code": "function minPolets ( n , m ) { let ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = Math . floor ( ( n * m ) / 2 ) + 1 ; } else { ans = Math . floor ( ( n * m ) / 2 ) ; } return ans ; } let N = 5 , M = 7 ; document . write ( minPolets ( N , M ) ) ;"}
{"text": "String lexicographical terbesar dengan paling banyak unsur berturut -turut K | Fungsi untuk mencari rentetan leksikografi terbesar dengan kekangan yang diberikan. ; Vektor yang mengandungi kekerapan setiap aksara. ; Menetapkan kekerapan; Kosongkan rentetan jenis kelas rentetan; Gelung untuk melangkah ke atas keutamaan maksimum terlebih dahulu. ; Jika kekerapan lebih besar daripada atau sama dengan k. ; Pembolehubah sementara untuk beroperasi di tempat k. ; Menggabungkan dengan rentetan yang dihasilkan. ; Pengendalian kes K dengan menyesuaikan dengan unsur keutamaan yang lebih kecil. ; Keadaan untuk mengesahkan sama ada indeks j mempunyai kekerapan yang lebih besar daripada 0; ; Jika tiada elemen sedemikian dijumpai daripada rentetan tidak dapat diproses lagi. ; Jika kekerapan lebih besar daripada 0 dan kurang daripada k. ; Di sini kita tidak perlu memperbaiki kriteria elemen berturut -turut. ; Jika tidak, periksa elemen seterusnya yang mungkin. ; Kod pemacu", "code": "function getLargestString ( s , k ) { let frequency_array = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { frequency_array [ i ] = 0 ; } for ( let i = 0 ; i < s . length ; i ++ ) { frequency_array [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } let ans = \" \" ; for ( let i = 25 ; i >= 0 ; ) { if ( frequency_array [ i ] > k ) { let temp = k ; let st = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; while ( temp > 0 ) { ans += st ; temp -- ; } frequency_array [ i ] -= k ; let j = i - 1 ; while ( frequency_array [ j ] <= 0 && j >= 0 ) { j -- ; } if ( frequency_array [ j ] > 0 && j >= 0 ) { let str = String . fromCharCode ( j + ' ' . charCodeAt ( 0 ) ) ; ans += str ; frequency_array [ j ] -= 1 ; } else { break ; } } else if ( frequency_array [ i ] > 0 ) { let temp = frequency_array [ i ] ; frequency_array [ i ] -= temp ; let st = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; while ( temp > 0 ) { ans += st ; temp -- ; } } else { i -- ; } } return ans ; } let S = \" \" ; let k = 3 ; document . write ( getLargestString ( S , k ) ) ;"}
{"text": "Operasi minimum untuk menjadikan semua elemen sama menggunakan array kedua | Berfungsi untuk mencari operasi minimum yang diperlukan untuk membuat semua elemen array sama; Elemen minimum a; Melintasi semua nilai akhir; Pembolehubah yang menunjukkan sama ada semua elemen boleh ditukar kepada x atau tidak; Jumlah operasi; Melintasi semua elemen array; Semua elemen tidak boleh ditukar kepada x; Kod pemacu", "code": "function minOperations ( a , b , n ) { var minA = Math . max . apply ( Math , a ) ; ; for ( x = minA ; x >= 0 ; x -- ) { var check = true ; var operations = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; } var N = 5 ; var A = [ 5 , 7 , 10 , 5 , 15 ] ; var B = [ 2 , 2 , 1 , 3 , 5 ] ; document . write ( minOperations ( A , B , N ) ) ;"}
{"text": "Cari jumlah maksimum (a + b) untuk integer input yang diberikan dan memenuhi syarat yang diberikan | Berfungsi untuk mengembalikan jumlah maksimum A + B yang memenuhi syarat yang diberikan; Memulakan max_sum; Pertimbangkan semua pasangan yang mungkin; Semak sama ada produk itu boleh dibahagikan dengan jumlah; Menyimpan jumlah maksimum dalam pembolehubah max_sum; Kembalikan nilai max_sum; Kod pemacu", "code": "function getLargestSum ( N ) { var max_sum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { for ( j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . max ( max_sum , i + j ) ; } } return max_sum ; } var N = 25 ; var max_sum = getLargestSum ( N ) ; document . write ( max_sum ) ;"}
{"text": "Memaksimumkan jumlah array selepas mengalikan awalan dan akhiran oleh | Algoritma Kadane untuk mencari jumlah subarray maksimum; Gelung untuk mencari jumlah array subarray maksimum dalam array yang diberikan; Berfungsi untuk mencari jumlah maksimum array dengan mengalikan awalan dan akhiran oleh - 1; Jumlah jumlah intital; Gelung untuk mencari jumlah maksimum array; Nilai maksimum; Kod pemacu", "code": "function maxSubArraySum ( a , size ) { var max_so_far = Number . MIN_VALUE , max_ending_here = 0 ; for ( i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; } function maxSum ( a , n ) { var S = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) S += a [ i ] ; var X = maxSubArraySum ( a , n ) ; return 2 * X - S ; } var a = [ - 1 , - 2 , - 3 ] ; var n = a . length ; var max_sum = maxSum ( a , n ) ; document . write ( max_sum ) ;"}
{"text": "Count of Prima yang menarik sehingga n | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Jika n boleh dibahagikan dengan nombor antara 2 dan matematik. sqrt (n), ia bukan perdana; Berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Fungsi untuk mencari bilangan prima yang menarik kurang daripada sama dengan n. ; Periksa sama ada nombor itu adalah perdana atau tidak; Berulang untuk nilai b; Periksa syarat untuk a; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "function isPrime ( n ) { let flag = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; } function isPerfectSquare ( x ) { let sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } function countInterestingPrimes ( n ) { let answer = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( isPrime ( i ) ) { for ( let j = 1 ; j * j * j * j <= i ; j ++ ) { if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } } return answer ; } let N = 10 ; document . write ( countInterestingPrimes ( N ) ) ;"}
{"text": "Memaksimumkan nombor dengan membalikkan kebanyakan bit k | Berfungsi untuk menukar nombor perpuluhan n ke perwakilan binari yang disimpan sebagai array arr []; Berfungsi untuk menukar nombor yang diwakili sebagai array perduaan [] ke dalam setara perpuluhannya; Berfungsi untuk mengembalikan nombor yang dimaksimumkan dengan membalikkan atmost k bit; Bilangan bit dalam n; Cari perwakilan binari n; Untuk mengira bilangan 0 s terbalik; Mengembalikan setara perpuluhan nombor yang dimaksimumkan; Kod pemacu", "code": "function decBinary ( arr , n ) { let k = Math . log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n = Math . floor ( n / 2 ) ; } } function binaryDec ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } function maxNum ( n , k ) { let l = Math . log2 ( n ) + 1 ; let a = new Array ( l ) . fill ( 0 ) ; decBinary ( a , n ) ; let cn = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binaryDec ( a , l ) ; } let n = 4 , k = 1 ; document . write ( maxNum ( n , k ) ) ;"}
{"text": "Cari berikutnya dengan jumlah yang diberikan dalam urutan superincreasing | Berfungsi untuk mencari seterusnya yang diperlukan; Elemen semasa tidak boleh menjadi sebahagian daripada berikutnya yang diperlukan; Termasuk elemen semasa dalam seterusnya yang diperlukan supaya mengemas kini jumlah; Prlet unsur -unsur berikutnya yang diperlukan; Jika elemen semasa dimasukkan ke dalam berikutnya; Kod pemacu", "code": "function findSubSeq ( arr , n , sum ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = - 1 ; else sum -= arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != - 1 ) document . write ( arr [ i ] + \" \" ) ; } } let arr = [ 17 , 25 , 46 , 94 , 201 , 400 ] ; let n = arr . length ; let sum = 272 ; findSubSeq ( arr , n , sum ) ;"}
{"text": "Cari abjad yang paling bernilai dalam rentetan | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan abjad bernilai maksimum; Untuk menyimpan kejadian pertama dan terakhir semua watak; Tetapkan kejadian pertama dan terakhir semua aksara kepada - 1; Kemas kini kejadian watak -watak; Hanya menetapkan kejadian pertama jika ia tidak telah ditetapkan; Untuk menyimpan hasilnya; Untuk setiap abjad; Jika abjad semasa tidak muncul dalam rentetan yang diberikan; Jika watak semasa mempunyai nilai tertinggi setakat ini; Kod pemacu", "code": "const MAX = 26 ; function maxAlpha ( str , len ) { var first = new Array ( MAX ) ; var last = new Array ( MAX ) ; for ( var i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( var i = 0 ; i < len ; i ++ ) { var index = str [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ; if ( first [ index ] === - 1 ) first [ index ] = i ; last [ index ] = i ; } var ans = - 1 , maxVal = - 1 ; for ( var i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] === - 1 ) continue ; if ( last [ i ] - first [ i ] > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return String . fromCharCode ( ans + \" \" . charCodeAt ( 0 ) ) ; } var str = \" \" ; var len = str . length ; document . write ( maxAlpha ( str , len ) ) ;"}
{"text": "Pertanyaan untuk bilangan elemen yang berbeza dari indeks yang diberikan sehingga indeks terakhir dalam array | Berfungsi untuk melakukan pertanyaan untuk mencari bilangan elemen yang berbeza dari indeks yang diberikan sehingga indeks terakhir dalam array; Periksa sama ada elemen semasa sudah dilawati atau tidak; Jika tidak melawat kaunter semasa dan kenaikannya dan semak semak sebagai 1; Jika tidak, jika dikunjungi hanya menyimpan kaunter semasa; Melakukan pertanyaan; Kod pemacu", "code": "function find_distinct ( a , n , q , queries ) { let MAX = 100001 ; let check = new Array ( MAX ) . fill ( 0 ) ; let idx = new Array ( MAX ) . fill ( 0 ) ; let cnt = 1 ; let i = n - 1 ; while ( i >= 0 ) { if ( check [ a [ i ] ] == 0 ) { idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else { idx [ i ] = cnt - 1 ; } i -- ; } for ( let i = 0 ; i < q ; i ++ ) { let m = queries [ i ] ; document . write ( idx [ m ] + \" \" ) ; } } let a = [ 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 ] ; let n = a . length ; let queries = [ 0 , 3 , 5 , 7 ] ; let q = queries . length ; find_distinct ( a , n , q , queries ) ;"}
{"text": "Tukar Integer X diberikan kepada Borang 2 ^ n | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan kiraan operasi yang diperlukan; Untuk menyimpan kuasa 2; Pembolehubah sementara untuk menyimpan X; Untuk menyimpan indeks nombor yang lebih kecil daripada x; Untuk menyimpan kiraan operasi; Menyimpan indeks nombor dalam bentuk 2 ^ n - 1; Jika x sudah ada dalam bentuk 2 ^ n - 1 maka tiada operasi diperlukan; Jika nombor kurang daripada x meningkatkan indeks; Kirakan semua nilai (x xor 2 ^ n - 1) untuk semua yang mungkin n; Hanya mengambil nilai yang lebih dekat dengan nombor; Jika nombor berada dalam bentuk 2 ^ n - 1 maka pecah; Mengembalikan kiraan operasi yang diperlukan untuk mendapatkan nombor; Kod pemacu", "code": "const MAX = 24 ; function countOp ( x ) { let arr = new Array ( MAX ) ; arr [ 0 ] = 1 ; for ( let i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; let temp = x ; let flag = true ; let ans ; let operations = 0 ; let flag2 = false ; for ( let i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( let i = 0 ; i < MAX ; i ++ ) { let take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; } let x = 39 ; document . write ( countOp ( x ) ) ;"}
{"text": "Bilangan minimum operasi yang diberikan untuk mengurangkan array ke 0 elemen | Berfungsi untuk mengembalikan operasi minimum yang diperlukan; Hitung kekerapan setiap elemen; Elemen maksimum dari array; Cari semua gandaan i; Padamkan gandaan; Meningkatkan operasi; Kod pemacu", "code": "function minOperations ( arr , n ) { let maxi , result = 0 ; let freq = new Array ( 1000001 ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { let x = arr [ i ] ; freq [ x ] ++ ; } maxi = Math . max ( ... arr ) ; for ( let i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( let j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; } let arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] ; let n = arr . length ; document . write ( minOperations ( arr , n ) ) ;"}
{"text": "Minimum LCM dan GCD mungkin di antara semua sub | Berfungsi untuk mengembalikan GCD minimum di kalangan semua subarray; GCD minimum di antara semua sub -tatasusunan akan menjadi GCD dari semua elemen array; Berfungsi untuk mengembalikan LCM minimum di kalangan semua subarray; LCM minimum di antara semua sub - tatasusunan akan menjadi elemen minimum dari array; Kod pemacu", "code": "function __gcd ( a , b ) { if ( a == 0 ) return b ; return __gcd ( b % a , a ) ; } function minGCD ( arr , n ) { var minGCD = 0 ; for ( i = 0 ; i < n ; i ++ ) minGCD = __gcd ( minGCD , arr [ i ] ) ; return minGCD ; } function minLCM ( arr , n ) { var minLCM = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minLCM = Math . min ( minLCM , arr [ i ] ) ; return minLCM ; } var arr = [ 2 , 66 , 14 , 521 ] ; var n = arr . length ; document . write ( \" \" + minLCM ( arr , n ) + \" \" + minGCD ( arr , n ) ) ;"}
{"text": "Bentuk rentetan terkecil secara lexicographically dengan penggantian minimum yang mempunyai bilangan yang sama 0 s, 1 s dan 2 s | Fungsi yang mengembalikan rentetan terkecil lexicographically yang diubahsuai selepas melakukan bilangan minimum operasi yang diberikan; Menyimpan frekuensi awal aksara 0 s, 1 s dan 2 s; Menyimpan bilangan aksara yang diproses sehingga titik setiap jenis; Bilangan aksara yang diperlukan setiap jenis; Jika jenis semasa telah membatalkan bilangan aksara, tidak perlu melakukan apa -apa operasi; Proses semua 3 kes; Semak 1 pertama; Lain 2; Di sini kita perlu menyemak yang diproses [1] hanya untuk 2 kerana 0 adalah kurang daripada 1 dan kita boleh menggantikannya pada bila -bila masa; Di sini kita boleh menggantikan 2 dengan 0 dan 1 bila -bila masa; Simpan kiraan aksara yang diproses setiap jenis; Kod pemacu", "code": "function formStringMinOperations ( s ) { var count = new Array ( 3 ) . fill ( 0 ) ; for ( const c of s ) { count += 1 ; } var processed = new Array ( 3 ) . fill ( 0 ) ; var reqd = parseInt ( s . length / 3 ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( count [ s [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] === reqd ) { continue ; } if ( s [ i ] === \" \" && count [ 0 ] > reqd && processed [ 0 ] >= reqd ) { if ( count [ 1 ] < reqd ) { s [ i ] = \" \" ; count [ 1 ] ++ ; count [ 0 ] -- ; } else if ( count [ 2 ] < reqd ) { s [ i ] = \" \" ; count [ 2 ] ++ ; count [ 0 ] -- ; } } if ( s [ i ] === \" \" && count [ 1 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = \" \" ; count [ 0 ] ++ ; count [ 1 ] -- ; } else if ( count [ 2 ] < reqd && processed [ 1 ] >= reqd ) { s [ i ] = \" \" ; count [ 2 ] ++ ; count [ 1 ] -- ; } } if ( s [ i ] === \" \" && count [ 2 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = \" \" ; count [ 0 ] ++ ; count [ 2 ] -- ; } else if ( count [ 1 ] < reqd ) { s [ i ] = \" \" ; count [ 1 ] ++ ; count [ 2 ] -- ; } } processed [ s [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] ++ ; } return s . join ( \" \" ) ; } var s = \" \" ; document . write ( formStringMinOperations ( s . split ( \" \" ) ) ) ;"}
{"text": "Bilangan minimum swap bersebelahan untuk mengatur unsur -unsur yang sama bersama -sama | Berfungsi untuk mencari swap minimum; Arahan yang dikunjungi untuk memeriksa sama ada nilai sudah dilihat; Jika arr [i] dilihat kali pertama; menyimpan bilangan swap yang diperlukan untuk mencari kedudukan yang betul dari rakan kongsi elemen semasa; Kiraan kenaikan hanya jika elemen semasa belum dikunjungi (jika dikunjungi, bermakna ia telah diletakkan pada kedudukan yang betul); Jika rakan kongsi elemen semasa dijumpai; kod pemacu", "code": "function findMinimumAdjacentSwaps ( arr , N ) { let visited = Array ( N + 1 ) . fill ( false ) ; let minimumSwaps = 0 ; for ( let i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; let count = 0 ; for ( let j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; } let arr = [ 1 , 2 , 3 , 3 , 1 , 2 ] ; let N = arr . length ; N = Math . floor ( N / 2 ) ; document . write ( findMinimumAdjacentSwaps ( arr , N ) ) ;"}
{"text": "Nombor Palindromic Terbesar dengan Permuting Digits | berfungsi untuk memeriksa sama ada nombor boleh dibentuk untuk membentuk nombor palindrome; Mengira kejadian nombor yang ganjil; Sekiranya kejadian ganjil; jika nombor melebihi 1; berfungsi untuk mencetak nombor palindromik terbesar dengan membenarkan digit nombor; panjang rentetan; peta yang menandakan kejadian nombor; Semak kemungkinan nombor palindromik; array rentetan yang menyimpan nombor palindromik yang terbesar; penunjuk depan; Ramuan bermula dari 9 hingga 0 dan letakkan nombor yang lebih besar di depan dan ganjil di tengah; Sekiranya berlakunya nombor adalah ganjil; Letakkan satu nombor ganjil di tengah; mengurangkan kiraan; Letakkan seluruh nombor dengan tamak; Jika semua nombor berlaku walaupun masa, maka letakkan dengan tamak; Letakkan tamak di hadapan; 2 nombor diletakkan, jadi mengurangkan kiraan; meningkatkan kedudukan meletakkan; Cetak rentetan terbesar yang terbentuk; kod pemacu", "code": "function possibility ( m , length , s ) { var countodd = 0 ; for ( var i = 0 ; i < length ; i ++ ) { if ( m . get ( s . charCodeAt ( i ) - 48 ) & 1 ) countodd ++ ; if ( countodd > 1 ) return false ; } return true ; } function largestPalindrome ( s ) { var l = s . length ; var m = new Map ( ) ; for ( var i = 0 ; i < l ; i ++ ) { if ( m . has ( s . charCodeAt ( i ) - 48 ) ) m . set ( s . charCodeAt ( i ) - 48 , m . get ( s . charCodeAt ( i ) - 48 ) + 1 ) ; else m . set ( s . charCodeAt ( i ) - 48 , 1 ) ; } if ( possibility ( m , l , s ) == false ) { document . write ( \" \" ) ; return ; } var largest = new Array ( l ) ; var front = 0 ; for ( var i = 9 ; i >= 0 ; i -- ) { if ( m . has ( i ) & 1 ) { largest [ Math . floor ( l / 2 ) ] = String . fromCharCode ( i + 48 ) ; m . set ( i , m . get ( i ) - 1 ) ; while ( m . get ( i ) > 0 ) { largest [ front ] = String . fromCharCode ( i + 48 ) ; largest [ l - front - 1 ] = String . fromCharCode ( i + 48 ) ; m . set ( i , m . get ( i ) - 2 ) ; front ++ ; } } else { while ( m . get ( i ) > 0 ) { largest [ front ] = String . fromCharCode ( i + 48 ) ; largest [ l - front - 1 ] = String . fromCharCode ( i + 48 ) ; m . set ( i , m . get ( i ) - 2 ) ; front ++ ; } } } for ( var i = 0 ; i < l ; i ++ ) document . write ( largest [ i ] ) ; } var s = \" \" ; largestPalindrome ( s ) ;"}
{"text": "Swap minimum untuk mengimbangi pendakap | Fungsi untuk mengira swap yang diperlukan; Jejaki '['; Untuk mengira bilangan yang ditemui '['; Untuk mengesan kedudukan seterusnya '[' dalam POS; Untuk menyimpan hasil; Kiraan kenaikan dan bergerak P ke kedudukan seterusnya; Kami telah menemui bahagian rentetan yang tidak seimbang; Jumlah kenaikan dengan bilangan swap yang diperlukan i. e. kedudukan seterusnya '[' - kedudukan semasa; Tetapkan semula kiraan kepada 1; Kod pemacu", "code": "function swapCount ( s ) { let pos = [ ] ; for ( let i = 0 ; i < s . length ; ++ i ) if ( s [ i ] == ' ' ) pos . push ( i ) ; let count = 0 ; let p = 0 ; let sum = 0 ; let S = s . split ( ' ' ) ; for ( let i = 0 ; i < s . length ; ++ i ) { if ( S [ i ] == ' ' ) { ++ count ; ++ p ; } else if ( S [ i ] == ' ' ) -- count ; if ( count < 0 ) { sum += pos [ p ] - i ; let temp = S [ i ] ; S [ i ] = S [ pos [ p ] ] ; S [ pos [ p ] ] = temp ; ++ p ; count = 1 ; } } return sum ; } let s = \" \" ; document . write ( swapCount ( s ) + \" \" ) ; s = \" \" ; document . write ( swapCount ( s ) ) ;"}
{"text": "Kos minimum untuk memotong papan ke dalam dataran | kaedah mengembalikan kos minimum untuk memecahkan papan ke dalam kotak m * n; menyusun kos mendatar dalam urutan terbalik; menyusun kos menegak dalam urutan terbalik; memulakan lebar semasa sebagai 1; gelung sehingga satu atau kedua -dua kos kos diproses; meningkatkan kiraan bahagian mendatar semasa dengan 1; meningkatkan kiraan bahagian menegak semasa dengan 1; gelung untuk array mendatar, jika kekal; gelung untuk pelbagai menegak, jika kekal; Kod pemacu", "code": "function minimumCostOfBreaking ( X , Y , m , n ) { let res = 0 ; X . sort ( ) ; X . reverse ( ) ; Y . sort ( ) ; Y . reverse ( ) ; let hzntl = 1 , vert = 1 ; let i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } let total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; } let m = 6 , n = 4 ; let X = [ 2 , 1 , 3 , 1 , 4 ] ; let Y = [ 4 , 1 , 2 ] ; document . write ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) ;"}
{"text": "Kurangkan kiraan aksara yang akan ditambah atau dikeluarkan untuk membuat pengulangan rentetan substring yang sama | Berfungsi untuk mencari minimum tiga nombor; Berfungsi untuk mencari operasi bilangan minimum yang diperlukan untuk menukar string str1 ke str2 menggunakan operasi; Menyimpan hasil subproblem; Isi dp [] [] dengan cara bawah; Jika str1 kosong, masukkan semua aksara string str2; Operasi minimum ialah J; Jika str2 kosong, maka keluarkan semua aksara string str2; Operasi minimum ialah i; Jika watak terakhir adalah sama, maka abaikan watak terakhir; Jika watak terakhir berbeza, maka cari minimum; Lakukan salah satu sisipan, keluarkan dan ganti; Mengembalikan bilangan langkah minimum yang diperlukan; Berfungsi untuk mencari bilangan langkah minimum untuk mengubah suai rentetan sedemikian rupa sehingga separuh pertama dan separuh kedua menjadi sama; Menyimpan bilangan minimum operasi yang diperlukan; Melintasi rentetan yang diberikan; Cari operasi minimum; Kemas kini ANS; Cetak hasilnya; Kod pemacu", "code": "function getMin ( x , y , z ) { return Math . min ( Math . min ( x , y ) , z ) ; } function editDistance ( str1 , str2 , m , n ) { let dp = new Array ( m + 1 ) . fill ( new Array ( n + 1 ) ) ; for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else { dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } } return dp [ m ] [ n ] ; } function minimumSteps ( S , N ) { let ans = Number . MAX_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { let S1 = S . substring ( 0 , i ) ; let S2 = S . substring ( i ) ; let count = editDistance ( S1 , S2 , S1 . length , S2 . length ) ; ans = Math . min ( ans , count ) ; } document . write ( ans - 1 ) ; } let S = \" \" ; let N = S . length ; minimumSteps ( S , N ) ;"}
{"text": "Kurangkan operasi untuk mengurangkan n hingga 2 dengan berulang kali mengurangkan 3 atau membahagikan dengan 5 | Berfungsi untuk mencari bilangan minimum operasi untuk mengurangkan n hingga 2 dengan membahagikan n dengan 5 atau penurunan sebanyak 3; Memulakan array DP; Memulakan array dp []; Untuk n = 2 bilangan operasi yang diperlukan adalah sifar; Melangkah ke atas julat [1, n]; Jika ia tidak mungkin untuk membuat n semasa; Kalikan dengan 5; Menambah nilai 3; Memeriksa jika tidak mungkin untuk membuat nombor sebagai 2; Mengembalikan bilangan operasi minimum; Kod pemacu", "code": "function minimumOperations ( N ) { let dp = new Array ( N + 1 ) ; let i ; for ( i = 0 ; i <= N ; i ++ ) { dp [ i ] = 1e9 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { if ( dp [ i ] == 1e9 ) continue ; if ( i * 5 <= N ) { dp [ i * 5 ] = Math . min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= N ) { dp [ i + 3 ] = Math . min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } if ( dp [ N ] == 1e9 ) return - 1 ; return dp [ N ] ; } let N = 25 ; document . write ( minimumOperations ( N ) ) ;"}
{"text": "Keuntungan maksimum selepas membeli dan menjual stok dengan yuran transaksi | Tetapkan 2 | Berfungsi untuk mencari keuntungan maksimum dengan yuran transaksi; Melintasi stok untuk setiap hari; Kemas kini membeli dan menjual; Mengembalikan keuntungan maksimum; Diberikan input; Panggilan fungsi", "code": "function MaxProfit ( arr , n , transactionFee ) { let buy = - arr [ 0 ] ; let sell = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let temp = buy ; buy = Math . max ( buy , sell - arr [ i ] ) ; sell = Math . max ( sell , temp + arr [ i ] - transactionFee ) ; } return Math . max ( sell , buy ) ; } let arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] ; let n = arr . length ; let transactionFee = 2 ; document . write ( MaxProfit ( arr , n , transactionFee ) ) ;"}
{"text": "Jumlah maksimum dari kiri ke bawah kanan matriks melalui salah satu sel yang diberikan | Menyimpan jumlah laluan maksimum dari sel (1, 1) hingga (n, m); Menyimpan jumlah laluan maksimum dari sel (j, j) hingga (n, m); Berfungsi untuk mencari jumlah laluan maksimum dari sel (1, 1) hingga (n, m); Melintasi baris pertama; Melintasi lajur pertama; Melintasi matriks; Kemas kini nilai permulaan [i] [j]; Berfungsi untuk mencari jumlah laluan maksimum dari sel (j, j) hingga (n, m); Melintasi baris terakhir; Melintasi lajur terakhir; Melintasi matriks; Kemas kini nilai berakhir [i] [j]; Berfungsi untuk mencari jumlah laluan maksimum dari atas - kiri ke sel kanan bawah supaya laluan itu mengandungi salah satu sel dalam koordinat array [] []; Memulakan permulaan dan matriks akhir; Kirakan matriks permulaan; Kirakan matriks akhir; Menyimpan jumlah laluan maksimum; Melintasi koordinat; Kemas kini nilai ANS; Cetak nilai laluan jumlah maksimum yang dihasilkan; Kod pemacu", "code": "var start = Array . from ( Array ( 3 ) , ( ) => Array ( 3 ) ) ; var ending = Array . from ( Array ( 3 ) , ( ) => Array ( 3 ) ) ; function calculateStart ( n , m ) { for ( var i = 1 ; i < m ; ++ i ) { start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] ; } for ( var i = 1 ; i < n ; ++ i ) { start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] ; } for ( var i = 1 ; i < n ; ++ i ) { for ( var j = 1 ; j < m ; ++ j ) { start [ i ] [ j ] += Math . max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) ; } } } function calculateEnd ( n , m ) { for ( var i = n - 2 ; i >= 0 ; -- i ) { ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] ; } for ( var i = m - 2 ; i >= 0 ; -- i ) { ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] ; } for ( var i = n - 2 ; i >= 0 ; -- i ) { for ( var j = m - 2 ; j >= 0 ; -- j ) { ending [ i ] [ j ] += Math . max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) ; } } } function maximumPathSum ( mat , n , m , q , coordinates ) { for ( var i = 0 ; i < n ; ++ i ) { for ( var j = 0 ; j < m ; ++ j ) { start [ i ] [ j ] = mat [ i ] [ j ] ; ending [ i ] [ j ] = mat [ i ] [ j ] ; } } calculateStart ( n , m ) ; calculateEnd ( n , m ) ; var ans = 0 ; for ( var i = 0 ; i < q ; ++ i ) { var X = coordinates [ i ] [ 0 ] - 1 ; var Y = coordinates [ i ] [ 1 ] - 1 ; ans = Math . max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) ; } document . write ( ans ) ; } var mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; var N = 3 ; var M = 3 ; var Q = 2 ; var coordinates = [ [ 1 , 2 ] , [ 2 , 2 ] ] ; maximumPathSum ( mat , N , M , Q , coordinates ) ;"}
{"text": "Panjang subset terpanjang yang terdiri daripada 0 s dan b 1 s dari pelbagai rentetan | Tetapkan 2 | Berfungsi untuk mencari panjang subset terpanjang pelbagai rentetan dengan paling banyak 0 s dan b 1 s; Memulakan array 2D dengan penyertaannya sebagai 0; Melintasi array yang diberikan; Simpan kiraan 0 s dan 1 s dalam rentetan semasa; Melangkah dalam julat [a, sifar]; Berulang dalam julat [b, yang]; Mengemas kini nilai dp [i] [j]; Cetak hasilnya; Kod pemacu", "code": "function MaxSubsetlength ( arr , A , B ) { var dp = Array . from ( Array ( A + 1 ) , ( ) => Array ( B + 1 ) . fill ( 0 ) ) ; arr . forEach ( str => { var zeros = [ ... str ] . filter ( x => x == ' ' ) . length ; var ones = [ ... str ] . filter ( x => x == ' ' ) . length ; for ( var i = A ; i >= zeros ; i -- ) for ( var j = B ; j >= ones ; j -- ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; } ) ; return dp [ A ] [ B ] ; } var arr = [ \" \" , \" \" , \" \" , \" \" , \" \" ] ; var A = 5 , B = 3 ; document . write ( MaxSubsetlength ( arr , A , B ) ) ;"}
{"text": "Kira cara untuk memilih pasangan gula -gula warna yang berbeza (pengaturcaraan dinamik + bitmasking) | Fungsi untuk mengira cara untuk memilih N yang berbeza pasangan gula -gula dengan warna yang berbeza; Jika pasangan N dipilih; Kedai mengira cara untuk memilih pasangan i - th; Melangkah ke atas julat [0, n]; Jika pasangan (i, j) tidak termasuk; Kod pemacu", "code": "function numOfWays ( a , n , i , blue ) { if ( i == n ) return 1 ; let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && ! blue . has ( j ) ) { blue . add ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . delete ( j ) ; } } return count ; } let n = 3 ; let mat = [ [ 0 , 1 , 1 ] , [ 1 , 0 , 1 ] , [ 1 , 1 , 1 ] ] ; let mpp = new Set ( ) ; document . write ( numOfWays ( mat , n , 0 , mpp ) ) ;"}
{"text": "Kurangkan kos untuk mencapai hujung array oleh dua lompatan ke hadapan atau satu lompatan ke belakang dalam setiap langkah | Berfungsi untuk mencari kos minimum untuk mencapai akhir array; Kes asas: apabila n <3; Simpan hasil dalam jadual; Memulakan kes asas; Melangkah ke atas julat [2, n - 2] untuk membina array DP; Mengendalikan kes untuk indeks terakhir, i. e. N - 1; Prlet jawapannya; Kod pemacu", "code": "function minCost ( arr , n ) { if ( n < 3 ) { document . write ( arr [ 0 ] ) ; return ; } let dp = [ ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( let i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = Math . min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; document . write ( dp [ n - 1 ] ) ; } let arr = [ 9 , 4 , 6 , 8 , 5 ] ; let N = arr . length ; minCost ( arr , N ) ;"}
{"text": "Kirakan nilai 2 yang dibangkitkan kepada kuasa dua kali ganda perwakilan binari n | Program JavaScript untuk melaksanakan pendekatan di atas; Fungsi untuk mencari nilai kuasa (x, y) dalam o (log y); Kedai kuasa (x, y); Kemas kini x; Kes asas; Hitung kuasa (x, y); Jika y adalah nombor ganjil; Kemas kini res; Kemas kini y; Kemas kini x; Fungsi untuk mengira (2 ^ (2 * x)) % (10 ^ 9 + 7); Kedai perwakilan binari n; Kedai kuasa 10; Kirakan perwakilan binari n; Jika n adalah nombor ganjil; Kemas kini x; Kemas kini pow_10; Kemas kini n; Dua kali ganda nilai x; Menyimpan nilai (2 ^ (2 * x)) % (10 ^ 9 + 7); Kod pemacu", "code": "M = 1000000007 ; function power ( X , Y ) { var res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( ( Y & 1 ) != 0 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } function findValue ( n ) { var X = 0 ; var pow_10 = 1 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) { X += pow_10 ; } pow_10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; var res = power ( 2 , X ) ; return res ; } var n = 2 ; document . write ( findValue ( n ) ) ;"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Fungsi untuk mencari bilangan cara untuk mendapatkan jumlah n dengan membuang dadu; Kes asas; Menyimpan jumlah jumlah cara untuk mendapatkan jumlah n; Berulang untuk semua 6 negeri; Jawapan kembali; Kod pemacu; Panggilan fungsi", "code": "function findWays ( N ) { if ( N == 0 ) { return 1 ; } var cnt = 0 ; for ( var i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } } return cnt ; } var N = 4 ; document . write ( findWays ( N ) ) ;"}
{"text": "Semak jika array boleh dibahagikan kepada 3 seterusnya jumlah yang sama atau tidak | Fungsi utiliti untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Kes asas; Apabila elemen di Indeks J ditambah kepada SM1; Apabila elemen di Indeks J ditambah kepada SM2; Apabila elemen di Indeks J ditambah kepada SM3; Mengembalikan nilai maksimum di antara semua 3 panggilan rekursif; Fungsi untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Permulaan 3 jumlah ke 0; Panggilan fungsi; Diberikan array arr []; Panggilan fungsi", "code": "function checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 , j ) { if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else { let l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; let m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; let r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return Math . max ( Math . max ( l , m ) , r ) ; } } function checkEqualSum ( arr , N ) { let sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } let arr = [ 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 ] ; let N = arr . length ; checkEqualSum ( arr , N ) ;"}
{"text": "Semak jika array boleh dibahagikan kepada 3 seterusnya jumlah yang sama atau tidak | Program JavaScript untuk pendekatan di atas; Fungsi untuk memeriksa array boleh menjadi partition ke dalam jumlah 3 sama; Kes asas; Jika nilai pada indeks tertentu tidak - 1 maka nilai pulangan pada indeks itu yang memastikan tiada lagi panggilan lagi; Apabila elemen di Indeks J ditambah kepada SM1; Apabila elemen di Indeks J ditambah kepada SM2; Apabila elemen di Indeks J ditambah kepada SM3; Mengemas kini keadaan semasa dan mengembalikan nilai itu; Fungsi untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Permulaan 3 jumlah ke 0; Panggilan fungsi; Diberikan array arr []; Panggilan fungsi", "code": "var dp = new Map ( ) ; function checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 , j ) { var s = ( sm1 . toString ( ) ) + \" \" + ( sm2 . toString ( ) ) + ( j . toString ( ) ) ; if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } if ( dp . has ( s ) ) return dp [ s ] ; else { var l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; var m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; var r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return dp [ s ] = Math . max ( Math . max ( l , m ) , r ) ; } } function checkEqualSum ( arr , N ) { var sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } var arr = [ 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 ] ; var N = arr . length ; checkEqualSum ( arr , N ) ;"}
{"text": "Indeks terkecil dalam pelbagai indeks yang tidak sama dengan x | Precompute Indeks elemen yang berbeza seterusnya dalam array untuk setiap elemen array; Nilai lalai; Kirakan Nextpos [i] menggunakan Nextpos [i + 1]; Berfungsi untuk mengembalikan indeks terkecil; Nextpos [i] akan menyimpan kedudukan seterusnya p di mana arr [p]! = arr [i]; Jika x tidak hadir di l; Jika tidak; Cari indeks yang menyimpan nilai yang berbeza dari x; Jika indeks itu berada dalam julat; Kod pemacu", "code": "function precompute ( nextpos , arr , N ) { nextpos [ N - 1 ] = N ; for ( var i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } } function findIndex ( query , arr , N , Q ) { var nextpos = Array ( N ) ; precompute ( nextpos , arr , N ) ; for ( var i = 0 ; i < Q ; i ++ ) { var l , r , x ; l = query [ i ] [ 0 ] ; r = query [ i ] [ 1 ] ; x = query [ i ] [ 2 ] ; var ans = - 1 ; if ( arr [ l ] != x ) ans = l ; else { var d = nextpos [ l ] ; if ( d <= r ) ans = d ; } document . write ( ans + \" \" ) ; } } var N , Q ; N = 6 ; Q = 3 ; var arr = [ 1 , 2 , 1 , 1 , 3 , 5 ] ; var query = [ [ 0 , 3 , 1 ] , [ 1 , 5 , 2 ] , [ 2 , 3 , 1 ] ] ; findIndex ( query , arr , N , Q ) ;"}
{"text": "Mengira bilangan cara untuk menukar rentetan s ke t dengan melakukan peralihan kitaran k | Program JavaScript untuk pendekatan di atas; Berfungsi untuk mengira bilangan cara untuk menukar rentetan s ke rentetan t dengan melakukan peralihan kitaran k; Hitung panjang rentetan; 'A' bukan peralihan siklik yang baik 'B' bukan peralihan siklik yang buruk; Iterat dalam rentetan; Precompute bilangan peralihan kitaran yang baik dan buruk; DP2 [i] untuk menyimpan tidak ada cara untuk mendapatkan peralihan yang buruk dalam saya bergerak; Kirakan peralihan yang baik dan buruk; Mengembalikan bilangan cara yang diperlukan; Diberikan rentetan; Memandangkan pergeseran k diperlukan; Panggilan fungsi", "code": "let mod = 10000000007 ; function countWays ( s , t , k ) { let n = s . length ; let a = 0 , b = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let p = s . substr ( i , n - i ) + s . substr ( 0 , i ) ; if ( p == t ) a ++ ; else b ++ ; } let dp1 = Array . from ( { length : k + 1 } , ( _ , i ) => 0 ) ; let dp2 = Array . from ( { length : k + 1 } , ( _ , i ) => 0 ) ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; } for ( let i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; } return dp1 [ k ] ; } let S = \" \" , T = \" \" ; let K = 2 ; document . write ( countWays ( S , T , K ) ) ;"}
{"text": "Kurangkan langkah -langkah untuk mencapai k dari 0 dengan menambah 1 atau menggandakan pada setiap langkah | Berfungsi untuk mencari operasi minimum; DP diasaskan untuk menyimpan langkah -langkah; Untuk semua nombor walaupun; Kod pemacu", "code": "function minOperation ( k ) { let dp = Array . from ( { length : k + 1 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; } let K = 12 ; document . write ( minOperation ( K ) ) ;"}
{"text": "Cari jumlah subset maksimum yang dibentuk dengan memisahkan mana -mana subset array ke dalam 2 partition dengan jumlah yang sama | Berfungsi untuk mencari jumlah subset maksimum; Abaikan elemen semasa; Termasuk elemen dalam partition 1; Termasuk elemen dalam partition 2; Saiz array", "code": "function maxSum ( p0 , p1 , a , pos , n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } var ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = Math . max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = Math . max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; } var n = 4 ; var a = [ 1 , 2 , 3 , 6 ] ; document . write ( maxSum ( 0 , 0 , a , 0 , n ) ) ;"}
{"text": "Cari jumlah subset maksimum yang dibentuk dengan memisahkan mana -mana subset array ke dalam 2 partition dengan jumlah yang sama | Berfungsi untuk mencari jumlah subset maksimum; jumlah semua elemen; Jadual carian bawah; ; Inisialisasi jadual DP dengan - 1000000000 di mana, - 1000000000 bermaksud tiada penyelesaian; Kes apabila diff adalah 0; Meletakkan elemen ITH dalam G0; Meletakkan elemen ITH dalam G1; Mengabaikan elemen ith; Kod pemacu", "code": "function maxSum ( a , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += a [ i ] ; var limit = 2 * sum + 1 ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( limit ) ) ; for ( var i = 0 ; i < n + 1 ; i ++ ) { for ( var j = 0 ; j < limit ; j ++ ) dp [ i ] [ j ] = - 1000000000 ; } dp [ 0 ] [ sum ] = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 0 ; j < limit ; j ++ ) { if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 ] [ j - a [ i - 1 ] ] != - 1000000000 ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 ] [ j + a [ i - 1 ] ] != - 1000000000 ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; if ( dp [ i - 1 ] [ j ] != - 1000000000 ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ sum ] ; } var n = 4 ; var a = [ 1 , 2 , 3 , 6 ] ; document . write ( maxSum ( a , n ) ) ;"}
{"text": "Count of Strings mungkin dengan menggantikan dua watak yang sama berturut -turut dengan watak baru | Array untuk mencari urutan Fibonacci; Berfungsi untuk mencari urutan Fibonacci; Berfungsi untuk mengira semua rentetan yang mungkin; Memulakan ans = 1; Jika dua char berturut -turut adalah peningkatan yang sama CNT; Lain melipatgandakan FIB [CNT] ke Ans dan memulakan Ans hingga 1; Jika str = abcdeeee, maka untuk terakhir \"eeee\" kiraan munst dikemas kini; Mengembalikan jumlah jumlah; Kod pemandu; Berfungsi untuk precompute semua nombor Fibonacci; Fungsi panggilan untuk mencari kiraan", "code": "fib = Array ( 100005 ) . fill ( 0 ) ; function computeFibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 1 ; for ( i = 2 ; i < 100005 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } function countString ( str ) { var ans = 1 ; var cnt = 1 ; for ( i = 1 ; i < str . length ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) { cnt ++ ; } else { ans = ans * fib [ cnt ] ; cnt = 1 ; } } ans = ans * fib [ cnt ] ; return ans ; } var str = \" \" ; computeFibonacci ( ) ; document . write ( countString ( str ) ) ;"}
{"text": "Urutan Golomb | Tetapkan 2 | Program JavaScript untuk mencari terma pertama N Golomb urutan; Berfungsi untuk mencetak urutan Golomb; Memulakan array; Memulakan CNT hingga 0; Elemen pertama dan kedua urutan Golomb ialah 0, 1; Peta untuk menyimpan kiraan elemen semasa dalam urutan Golomb; Simpan kiraan 2; Melangkah lebih dari 2 hingga n; Jika CNT sama dengan 0 maka kami mempunyai nombor baru untuk urutan Golomb yang 1 + elemen sebelumnya; Lain elemen semasa adalah elemen sebelumnya dalam urutan ini; Peta indeks semasa ke nilai semasa dalam arr []; Cetak urutan Golomb; Kod pemacu", "code": "var MAX = 100001 ; function printGolombSequence ( N ) { var arr = Array ( MAX ) ; var cnt = 0 ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; var M = new Map ( ) ; M . set ( 2 , 2 ) ; for ( var i = 2 ; i <= N ; i ++ ) { if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M . get ( arr [ i ] ) ; cnt -- ; } else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; } M . set ( i , arr [ i ] ) ; } for ( var i = 1 ; i <= N ; i ++ ) { document . write ( arr [ i ] + ' ' ) ; } } var N = 11 ; printGolombSequence ( N ) ;"}
{"text": "Kira cara untuk mencapai tangga nth dengan mengambil 1 dan 2 langkah dengan tepat satu 3 langkah | Berfungsi untuk mencari bilangan bilangan cara untuk mencapai tangga nth; Array termasuk bilangan cara yang merangkumi 3; Array termasuk bilangan cara yang tidak termasuk 3; Pada mulanya untuk mencapai 3 tangga dengan mengambil 3 langkah boleh dicapai dengan 1 cara; Gelung untuk mencari nombor bilangan cara untuk mencapai tangga nth; Kod pemacu", "code": "function number_of_ways ( n ) { let includes_3 = new Uint8Array ( n + 1 ) ; let not_includes_3 = new Uint8Array ( n + 1 ) ; includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ; for ( let i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; } let n = 7 ; document . write ( number_of_ways ( n ) ) ;"}
{"text": "Bilangan maksimum gandaan dalam array sebelum mana -mana elemen | Pelaksanaan JavaScript pendekatan; Peta untuk menyimpan kiraan pembahagi; Berfungsi untuk menjana pembahagi semua elemen array; Berfungsi untuk mencari bilangan maksimum gandaan dalam array sebelum itu; Untuk menyimpan kiraan pembahagi maksimum; Kemas kini Ans Jika lebih banyak bilangan pembahagi dijumpai; Menjana semua pembahagi elemen seterusnya dari array; Kod pemacu", "code": "const MAX = 100000 ; var divisors = new Array ( MAX ) . fill ( 0 ) ; function generateDivisors ( n ) { for ( var i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n / i ] ++ ; } } } } function findMaxMultiples ( arr , n ) { var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { ans = Math . max ( divisors [ arr [ i ] ] , ans ) ; generateDivisors ( arr [ i ] ) ; } return ans ; } var arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] ; var n = arr . length ; document . write ( findMaxMultiples ( arr , n ) ) ;"}
{"text": "Bilangan cara untuk mencapai akhir matriks dengan bukan | Pelaksanaan JavaScript pendekatan; Arahan 3D untuk menyimpan negeri -negeri DP; Array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Fungsi untuk mengembalikan kiraan laluan yang diperlukan; Kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula; Hubungan berulang; Kod pemacu", "code": "var n = 3 ; var maxV = 20 ; var dp = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( var j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = new Array ( maxV ) ; } } var v = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { v [ i ] = new Array ( n ) ; for ( var j = 0 ; j < n ; j ++ ) { v [ i ] [ j ] = new Array ( maxV ) ; } } function countWays ( i , j , x , arr ) { if ( i == n j == n ) return 0 ; x = ( x & arr [ i ] [ j ] ) ; if ( x == 0 ) return 0 ; if ( i == n - 1 && j == n - 1 ) return 1 ; if ( v [ i ] [ j ] [ x ] ) return dp [ i ] [ j ] [ x ] ; v [ i ] [ j ] [ x ] = 1 ; dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i ] [ j ] [ x ] ; } var arr = [ [ 1 , 2 , 1 ] , [ 1 , 1 , 0 ] , [ 2 , 1 , 1 ] ] ; document . write ( countWays ( 0 , 0 , arr [ 0 ] [ 0 ] , arr ) ) ;"}
{"text": "Jumlah maksimum dari tiga tatasusunan yang memilih unsur -unsur berturut -turut dari yang sama tidak dibenarkan | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan jumlah maksimum; Kes asas; Sudah dikunjungi; Jika elemen telah diambil dari array pertama dalam langkah sebelumnya; Jika elemen telah diambil dari array kedua dalam langkah sebelumnya; Jika elemen telah diambil dari array ketiga dalam langkah sebelumnya; Kod pemacu; Pilih elemen dari array pertama; Pilih elemen dari array kedua; Pilih elemen dari array ketiga; Cetak maksimum mereka", "code": "var N = 3 ; function FindMaximumSum ( ind , kon , a , b , c , n , dp ) { if ( ind == n ) return 0 ; if ( dp [ ind ] [ kon ] != - 1 ) return dp [ ind ] [ kon ] ; var ans = - 1000000005 ; if ( kon == 0 ) { ans = Math . max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 1 ) { ans = Math . max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 2 ) { ans = Math . max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; } return dp [ ind ] [ kon ] = ans ; } var a = [ 6 , 8 , 2 , 7 , 4 , 2 , 7 ] ; var b = [ 7 , 8 , 5 , 8 , 6 , 3 , 5 ] ; var c = [ 8 , 3 , 2 , 6 , 8 , 4 , 1 ] ; var n = a . length ; var dp = Array . from ( Array ( n ) , ( ) => Array ( n ) . fill ( - 1 ) ) ; var x = FindMaximumSum ( 0 , 0 , a , b , c , n , dp ) ; var y = FindMaximumSum ( 0 , 1 , a , b , c , n , dp ) ; var z = FindMaximumSum ( 0 , 2 , a , b , c , n , dp ) ; document . write ( Math . max ( x , Math . max ( y , z ) ) ) ;"}
{"text": "Bilangan cara untuk membuat rentetan panjang panjang n sedemikian rupa sehingga 0 s sentiasa berlaku bersama dalam kumpulan saiz k | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan tidak ada cara untuk membina rentetan panjang binari sehingga 0 s selalu berlaku dalam kumpulan saiz k; Kod pemacu", "code": "let mod = 1000000007 ; function noOfBinaryStrings ( N , k ) { let dp = new Array ( 100002 ) ; for ( let i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( let i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; } let N = 4 ; let K = 2 ; document . write ( noOfBinaryStrings ( N , K ) ) ;"}
{"text": "Bilangan cara untuk memasangkan orang | Berfungsi untuk mencari bilangan cara untuk memasangkan orang dalam parti; Untuk menyimpan jumlah cara. ; Menggunakan kiraan cari yang ditakrifkan berulang untuk nilai yang berbeza p. ; Kod pemacu", "code": "function findWaysToPair ( p ) { var dp = Array ( p + 1 ) ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( var i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; } var p = 3 ; document . write ( findWaysToPair ( p ) ) ;"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pelaksanaan rekursif mudah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; kes asas; Untuk kes n> 2; Kod pemacu", "code": "function CountWays ( n , flag ) { if ( n == 0 ) { return 1 ; } if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 1 + 1 ; } return CountWays ( n - 1 ) + CountWays ( n - 3 ) ; } let n = 5 ; document . write ( CountWays ( n , false ) ) ;"}
{"text": "Nombor pelik | Kod untuk mencari semua faktor nombor tidak termasuk nombor itu sendiri; vektor untuk menyimpan faktor -faktor; Perhatikan bahawa gelung ini berjalan sehingga sqrt (n); jika nilai saya adalah faktor; Keadaan untuk memeriksa pembahagi bukan nombor itu sendiri; mengembalikan vektor; Berfungsi untuk memeriksa sama ada nombor itu banyak atau tidak; Cari pembahagi menggunakan fungsi; Jumlah semua faktor; Periksa banyak atau tidak; Berfungsi untuk memeriksa sama ada nombor itu separuh - sempurna atau tidak; Cari pembahagi; menyusun vektor; subset untuk memeriksa sama ada tidak semiperfect; memulakan lajur 1 st untuk benar; memulakan baris 1 st kecuali kedudukan sifar ke 0; gelung untuk mencari sama ada nombor itu semiperfect; pengiraan untuk memeriksa sama ada nombor itu boleh dibuat dengan penjumlahan pembahagi; jika tidak mungkin untuk membuat nombor dengan gabungan mana -mana pembahagi; Berfungsi untuk memeriksa pelik atau tidak; Kod pemacu", "code": "function factors ( n ) { var v = [ ] ; v . push ( 1 ) ; for ( var i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v . push ( i ) ; if ( n / i != i ) { v . push ( n / i ) ; } } } return v ; } function checkAbundant ( n ) { var v = [ ] ; var sum = 0 ; v = factors ( n ) ; for ( var i = 0 ; i < v . length ; i ++ ) { sum += v [ i ] ; } if ( sum > n ) return true ; else return false ; } function checkSemiPerfect ( n ) { var v = [ ] ; v = factors ( n ) ; v . sort ( ) var r = v . length ; var subset = Array . from ( Array ( r + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 0 ; i <= r ; i ++ ) subset [ i ] [ 0 ] = true ; for ( var i = 1 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = false ; for ( var i = 1 ; i <= r ; i ++ ) { for ( var j = 1 ; j <= n ; j ++ ) { if ( j < v [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; else { subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - v [ i - 1 ] ] ; } } } if ( ( subset [ r ] [ n ] ) == 0 ) return false ; else return true ; } function checkweird ( n ) { if ( checkAbundant ( n ) == true && checkSemiPerfect ( n ) == false ) return true ; else return false ; } var n = 70 ; if ( checkweird ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | Mengembalikan jumlah maksimum subarray yang dibuat selepas menggabungkan [0 .. n - 1] k kali. ; Di sinilah ia berbeza dari algoritma Kadane. Kami menggunakan aritmetik modular untuk mencari elemen seterusnya. ; Kod pemacu", "code": "function maxSubArraySumRepeated ( a , n , k ) { let max_so_far = 0 ; let INT_MIN , max_ending_here = 0 ; for ( let i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } let a = [ 10 , 20 , - 30 , - 1 ] ; let n = a . length ; let k = 3 ; document . write ( \" \" + maxSubArraySumRepeated ( a , n , k ) ) ;"}
{"text": "Terpanjang peningkatan ganjil walaupun berikutnya | berfungsi untuk mencari peningkatan yang paling lama walaupun seterusnya; lioes [i] menyimpan paling lama meningkatkan ganjil walaupun berikutnya yang berakhir di arr [i]; untuk menyimpan panjang yang paling lama meningkat ganjil walaupun berikutnya; Memulakan nilai lio untuk semua indeks; Mengira nilai lio yang dioptimumkan dengan cara bawah; Pilih maksimum semua nilai lio; panjang maksimum yang diperlukan; Kod pemacu", "code": "function longOddEvenIncSeq ( arr , n ) { let lioes = [ ] ; let maxLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; } let arr = [ 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 ] ; let n = 10 ; document . write ( \" \" + \" \" + longOddEvenIncSeq ( arr , n ) ) ;"}
{"text": "Nilai minimum dan maksimum ungkapan dengan * dan + | Kaedah utiliti untuk memeriksa sama ada watak adalah pengendali atau tidak; kaedah mencetak nilai minimum dan maksimum yang boleh diperolehi daripada ungkapan; pengendali kedai dan nombor dalam vektor yang berbeza; menyimpan nombor terakhir dalam vektor; memulakan array Minval dan Maxval 2D; memulakan pepenjuru utama dengan nilai NUM; Looping serupa dengan pendaraban rantai matriks dan mengemas kini kedua -dua tatasusunan 2D; Jika pengendali semasa adalah ' +', mengemas kini pembolehubah TMP dengan tambahan; Jika pengendali semasa adalah ' *', mengemas kini pembolehubah TMP dengan pendaraban; mengemas kini nilai array oleh pembolehubah TMP; Elemen terakhir baris pertama akan menyimpan hasilnya; Kod pemacu untuk menguji kaedah di atas", "code": "function isOperator ( op ) { return ( op == ' ' op == ' ' ) ; } function printMinAndMaxValueOfExp ( exp ) { let num = [ ] ; let opr = [ ] ; let tmp = \" \" ; for ( let i = 0 ; i < exp . length ; i ++ ) { if ( isOperator ( exp [ i ] ) ) { opr . push ( exp [ i ] ) ; num . push ( parseInt ( tmp ) ) ; tmp = \" \" ; } else { tmp += exp [ i ] ; } } num . push ( parseInt ( tmp ) ) ; let len = num . length ; let minVal = new Array ( len ) ; let maxVal = new Array ( len ) ; for ( let i = 0 ; i < len ; i ++ ) { minVal [ i ] = new Array ( len ) ; maxVal [ i ] = new Array ( len ) ; for ( let j = 0 ; j < len ; j ++ ) { minVal [ i ] [ j ] = Number . MAX_VALUE ; maxVal [ i ] [ j ] = 0 ; if ( i == j ) minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num [ i ] ; } } for ( let L = 2 ; L <= len ; L ++ ) { for ( let i = 0 ; i < len - L + 1 ; i ++ ) { let j = i + L - 1 ; for ( let k = i ; k < j ; k ++ ) { let minTmp = 0 , maxTmp = 0 ; if ( opr [ k ] == ' ' ) { minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] ; } else if ( opr [ k ] == ' ' ) { minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] ; } if ( minTmp < minVal [ i ] [ j ] ) minVal [ i ] [ j ] = minTmp ; if ( maxTmp > maxVal [ i ] [ j ] ) maxVal [ i ] [ j ] = maxTmp ; } } } document . write ( \" \" + minVal [ 0 ] [ len - 1 ] + \" \" + maxVal [ 0 ] [ len - 1 ] ) ; } let expression = \" \" ; printMinAndMaxValueOfExp ( expression ) ;"}
{"text": "Pendaraban rantai matriks | DP | Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Letakkan kurungan di tempat yang berbeza antara matriks pertama dan terakhir, mengira kiraan pendaraban untuk setiap penempatan kurungan dan mengembalikan kiraan minimum; Mengembalikan kiraan minimum; Kod pemacu", "code": "function MatrixChainOrder ( p , i , j ) { if ( i == j ) return 0 ; var min = Number . MAX_VALUE ; var k = 0 ; for ( k = i ; k < j ; k ++ ) { var count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } var arr = [ 1 , 2 , 3 , 4 , 3 ] ; var n = arr . length ; document . write ( \" \" + MatrixChainOrder ( arr , 1 , n - 1 ) ) ;"}
{"text": "Pendaraban rantai matriks | DP | Program JavaScript menggunakan memoisasi; Fungsi untuk pendaraban rantai matriks; Kod pemacu", "code": "let dp = new Array ( 100 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } function matrixChainMemoised ( p , i , j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = Number . MAX_VALUE ; for ( let k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } function MatrixChainOrder ( p , n ) { let i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; } let arr = [ 1 , 2 , 3 , 4 ] ; let n = arr . length ; for ( var i = 0 ; i < dp . length ; i ++ ) { for ( var j = 0 ; j < dp . length ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } document . write ( \" \" + MatrixChainOrder ( arr , n ) ) ;"}
{"text": "Nombor yang dibentuk dengan membalikkan bit set biasa dalam dua bilangan bulat yang diberikan | Berfungsi untuk membalikkan bit A dan B yang ditetapkan dalam kedua -dua mereka; Kosongkan bit A yang ditetapkan dalam kedua -dua A dan B; Kosongkan bit B yang ditetapkan dalam kedua -dua A dan B; Cetak dikemas kini A dan B; Kod pemacu", "code": "function flipBitsOfAandB ( A , B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; document . write ( A + \" \" + B ) ; } var A = 10 , B = 20 ; flipBitsOfAandB ( A , B ) ;"}
{"text": "Jumlah perbezaan perbezaan nombor berturut -turut dari 0 hingga n | Tetapkan 2 | Fungsi untuk mengira dan mengembalikan jarak Hamming antara semua nombor berturut -turut dari 0 hingga n; Kod pemacu", "code": "function TotalHammingDistance ( n ) { let i = 1 , sum = 0 ; while ( Math . floor ( n / i ) > 0 ) { sum = sum + Math . floor ( n / i ) ; i = i * 2 ; } return sum ; } let N = 9 ; document . write ( TotalHammingDistance ( N ) ) ;"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | Set 3 | Pelaksanaan program JavaScript pendekatan; Fungsi untuk mencari jumlah semua pembahagi semua nombor dari 1 hingga n; Menyimpan jumlah; Menandakan polet terakhir kejadian dengan kiraan yang sama; Kirakan jumlahnya; Mengembalikan hasilnya; Kod pemacu", "code": "let m = 1000000007 ; function solve ( n ) { let s = 0 ; for ( let l = 1 ; l <= n ; ) { let r = ( n / Math . floor ( n / l ) ) ; let x = Math . floor ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; let y = Math . floor ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; let p = ( Math . floor ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } document . write ( ( s + m ) % m ) ; } let n = 12 ; solve ( n ) ;"}
{"text": "Kurangkan bilangan luka yang diperlukan untuk memecahkan panjang n tongkat ke dalam n unit panjang tongkat | Berfungsi untuk mengembalikan masa minimum yang diperlukan untuk memecah tongkat n ke dalam kepingan unit; Mengembalikan unit minimum masa yang diperlukan; Kod pemacu", "code": "function min_time_to_cut ( N ) { if ( N == 0 ) return 0 ; return Math . ceil ( Math . log ( N ) / Math . log ( 2 ) ) ; } let N = 100 ; document . write ( min_time_to_cut ( N ) ) ;"}
{"text": "Kira jumlah pasangan yang berbeza antara dua array nilai 1 hingga n | Berfungsi untuk mencari jumlah yang berbeza; Tetapkan untuk menyimpan jumlah yang berbeza; Memasukkan setiap jumlah; kembali jumlah yang berbeza; Kod pemacu", "code": "function findDistinctSums ( n ) { s = new Set ( ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = i ; j <= n ; j ++ ) { s . add ( i + j ) ; } } return s . size ; } var N = 3 ; document . write ( findDistinctSums ( N ) ) ;"}
{"text": "Cetak Segitiga Terasing Corak | Berfungsi untuk mencetak corak secara rekursif; Kes asas; Syarat untuk mencetak slash; Keadaan untuk mencetak slash forword; Keadaan untuk mencetak slash ke belakang; Lain cetak ' *'; Panggilan rekursif untuk baris; Panggilan rekursif untuk menukar baris; Kod pemacu; Panggilan fungsi", "code": "function printPattern ( i , j , n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i j == n - 1 - i ) { if ( i == n - 1 - j ) { document . write ( \" \" ) ; } else { document . write ( \" \\\\ \" ) ; } } else { document . write ( \" \" ) ; } if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } document . write ( \" \" ) ; return printPattern ( i + 1 , 0 , n ) ; } let N = 9 ; printPattern ( 0 , 0 , N ) ;"}
{"text": "Cari indeks permulaan untuk setiap kejadian array yang diberikan b dalam array A menggunakan z | Fungsi untuk mengira z - array; Gelung untuk mengira z - array; Di luar kotak z; Di dalam z - kotak; Fungsi penolong untuk menggabungkan dua tatasusunan dan membuat satu array; Array untuk menyimpan array yang digabungkan; Menyalin Array B; Menambah pemisah; Menyalin Array A; Memanggil Z - Fungsi; Fungsi untuk membantu mengira array Z; Indeks percetakan di mana array b berlaku; Kod pemacu", "code": "function zArray ( arr ) { let n = arr . length ; let z = new Array ( n ) ; let r = 0 , l = 0 ; for ( let k = 1 ; k < n ; k ++ ) { if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } else { let k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; } function mergeArray ( A , B ) { let n = A . length ; let m = B . length ; let z = new Array ( ) ; let c = new Array ( n + m + 1 ) ; for ( let i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ; c [ m ] = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ; z = zArray ( c ) ; return z ; } function findZArray ( A , B , n ) { let flag = 0 ; let z = [ ] ; z = mergeArray ( A , B ) ; for ( let i = 0 ; i < z . length ; i ++ ) { if ( z [ i ] == n ) { document . write ( ( i - n - 1 ) + \" \" ) ; flag = 1 ; } } if ( flag == 0 ) { document . write ( \" \" ) ; } } let A = [ 1 , 2 , 3 , 2 , 3 , 2 ] ; let B = [ 2 , 3 ] ; let n = B . length ; findZArray ( A , B , n ) ;"}
{"text": "Semak jika rentetan boleh diulang untuk membuat rentetan lain | Berfungsi untuk mengembalikan kiraan pengulangan String A untuk menjana rentetan b; Jika B tidak dapat dihasilkan dengan mengulangi A; Ulangi jumlah kiraan; Kod pemacu", "code": "function getCount ( a , b ) { if ( b . length % a . length != 0 ) return - 1 ; var count = parseInt ( b . length / a . length ) ; var str = \" \" ; for ( i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == ( b ) ) return count ; return - 1 ; } var a = \" \" ; var b = \" \" ; document . write ( getCount ( a , b ) ) ;"}
{"text": "Semak jika rentetan boleh dibentuk dari rentetan lain menggunakan kekangan yang diberikan | Fungsi untuk memeriksa sama ada S2 boleh dibentuk dari S1; Panjang rentetan; Hash - Jadual untuk menyimpan kiraan; Menyimpan kiraan setiap watak; Melintasi dan memeriksa setiap watak; Jika watak S2 hadir dalam S1; Jika watak S2 tidak hadir dalam S1, maka periksa sama ada dua aksara ASCII terdahulu hadir dalam S1; Kod pemacu; Fungsi panggilan untuk memeriksa", "code": "function check ( S1 , S2 ) { var n1 = S1 . length ; var n2 = S2 . length ; var mp = { } ; for ( var i = 0 ; i < n1 ; i ++ ) { if ( mp . hasOwnProperty ( S1 [ i ] ) ) { mp [ S1 [ i ] ] = mp [ S1 [ i ] ] + 1 ; } else { mp [ S1 [ i ] ] = 1 ; } } for ( var i = 0 ; i < n2 ; i ++ ) { if ( mp . hasOwnProperty ( S2 [ i ] ) ) { mp [ S2 [ i ] ] = mp [ S2 [ i ] ] - 1 ; } else if ( mp . hasOwnProperty ( String . fromCharCode ( S2 [ i ] . charCodeAt ( 0 ) - 1 ) ) && mp . hasOwnProperty ( String . fromCharCode ( S2 [ i ] . charCodeAt ( 0 ) - 2 ) ) ) { mp [ String . fromCharCode ( S2 [ i ] . charCodeAt ( 0 ) - 1 ) ] = mp [ String . fromCharCode ( S2 [ i ] . charCodeAt ( 0 ) - 1 ) ] - 1 ; mp [ String . fromCharCode ( S2 [ i ] . charCodeAt ( 0 ) - 2 ) ] = mp [ String . fromCharCode ( S2 [ i ] . charCodeAt ( 0 ) - 2 ) ] - 1 ; } else { return false ; } } return true ; } var S1 = \" \" ; var S2 = \" \" ; if ( check ( S1 , S2 ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Count kejadian corak \"1 (0 +) 1\" dalam rentetan | Mengembalikan kiraan kejadian \"1 (0 +) 1\" int str. ; biarkan Count = 0; Memulakan hasil; Semak jika ditemui '1' membentuk corak yang sah seperti yang ditentukan; jika 1 ditemui untuk pertama kali ditetapkan satu ke 1; Semak jika terdapat watak lain selain daripada '0' atau '1'. Jika demikian kemudian tetapkan Oneseen hingga 0 untuk mencari lagi untuk corak baru; Program pemacu untuk menguji fungsi di atas", "code": "function countPattern ( str ) { let len = str . length ; let oneSeen = false ; for ( let i = 0 ; i < len ; i ++ ) { let getChar = str [ i ] ; if ( getChar == ' ' && oneSeen == true ) { if ( str [ i - 1 ] == ' ' ) count ++ ; } if ( getChar == ' ' && oneSeen == false ) oneSeen = true ; if ( getChar != ' ' && str [ i ] != ' ' ) oneSeen = false ; } return count ; } let str = \" \" ; document . write ( countPattern ( str ) ) ;"}
{"text": "Tukar rentetan yang diberikan ke dalam T dengan menggantikan aksara di antara rentetan sebilangan kali | Berfungsi untuk memeriksa sama ada mungkin untuk membuat semua rentetan sama dengan rentetan t; Menyimpan kekerapan semua rentetan dalam array arr []; Menyimpan kekerapan rentetan t; Melangkah ke atas watak -watak rentetan t; Melangkah dalam julat [0, n - 1]; Melangkah ke atas watak -watak rentetan arr [i]; Jika freqt [i] adalah 0 dan freqs [i] bukan 0; Jika freqs [i] adalah 0 dan freqt [i] bukan 0; Jika freqs [i] bukan freqt [i] * n; Jika tidak, kembalikan \"ya\"; Kod pemacu", "code": "function checkIfPossible ( N , arr , T ) { let freqS = new Array ( 256 ) . fill ( 0 ) ; let freqT = new Array ( 256 ) . fill ( 0 ) ; for ( let ch of T ) { freqT [ ch . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let ch of arr [ i ] ) { freqS [ ch . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } } for ( let i = 0 ; i < 256 ; i ++ ) { if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return \" \" ; } else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return \" \" ; } else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return \" \" ; } } return \" \" ; } let arr = [ \" \" , \" \" , \" \" ] ; let T = \" \" ; let N = arr . length ; document . write ( checkIfPossible ( N , arr , T ) ) ;"}
{"text": "Count kumpulan berturut -turut 1 s dalam rentetan binari yang diberikan | Berfungsi untuk mencari bilangan kumpulan 1 s hanya dalam rentetan binari; Kedai bilangan kumpulan 1 s; Permulaan timbunan; Melintasi rentetan s; Jika s [i] adalah '1'; Jika tidak; Jika St kosong; Jika ST tidak kosong; Jawapan kembali; Input; Panggilan fungsi", "code": "function groupsOfOnes ( S , N ) { let count = 0 ; var st = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' ' ) st . push ( 1 ) ; else { if ( st . length != 0 ) { count ++ ; while ( st . length != 0 ) { st . pop ( ) ; } } } } if ( st . length != 0 ) count ++ ; return count ; } var S = \" \" ; let N = S . length ; document . write ( groupsOfOnes ( S , N ) ) ;"}
{"text": "Palindromic Strings of Length 3 mungkin dengan menggunakan aksara rentetan yang diberikan | Berfungsi untuk mencetak semua rentetan palindromik panjang 3 yang boleh dibentuk menggunakan aksara rentetan s; Menyimpan kiraan watak; Melintasi rentetan s; Menyimpan semua rentetan palindromik; Melangkah ke atas charchaters ke atas julat ['a', 'z']; Jika hash [ch] sama dengan 2; Melangkah ke atas watak -watak di atas julat ['a', 'z']; Menyimpan semua rentetan palindromik; Tolak S ke set st; Jika hash [i] lebih besar daripada atau sama dengan 3; Melangkah ke atas charchaters ke atas julat ['a', 'z']; Menyimpan semua rentetan palindromik; Jika hash [j] positif; Tolak s ke set st; Melangkah ke atas set; Kod pemacu", "code": "function generatePalindrome ( S ) { let Hash = new Map ( ) ; for ( let ch = 0 ; ch < S . length ; ch ++ ) { if ( ! Hash . has ( S [ ch ] ) ) Hash . set ( S [ ch ] , 1 ) ; else { Hash . set ( S [ ch ] , Hash . get ( S [ ch ] ) + 1 ) } } let st = new Set ( ) ; for ( let i = ' ' . charCodeAt ( 0 ) ; i <= ' ' . charCodeAt ( 0 ) ; i ++ ) { if ( Hash . get ( String . fromCharCode ( i ) ) == 2 ) { for ( let j = ' ' . charCodeAt ( 0 ) ; j <= ' ' . charCodeAt ( 0 ) ; j ++ ) { let s = \" \" ; if ( Hash . get ( String . fromCharCode ( j ) ) && i != j ) { s += String . fromCharCode ( i ) ; s += String . fromCharCode ( j ) ; s += String . fromCharCode ( i ) ; st . add ( s ) ; } } } if ( Hash . get ( String . fromCharCode ( i ) ) >= 3 ) { for ( let j = ' ' . charCodeAt ( 0 ) ; j <= ' ' . charCodeAt ( 0 ) ; j ++ ) { let s = \" \" ; if ( Hash . get ( String . fromCharCode ( j ) ) ) { s += String . fromCharCode ( i ) ; s += String . fromCharCode ( j ) ; s += String . fromCharCode ( i ) ; st . add ( s ) ; } } } } for ( let item of st . values ( ) ) { document . write ( item + \" \" ) } } let S = \" \" ; generatePalindrome ( S ) ;"}
{"text": "Mengira kejadian substring x sebelum setiap kejadian substring y dalam rentetan yang diberikan | Fungsi untuk mengira kejadian rentetan y dalam rentetan s untuk setiap kejadian x dalam s; Menyimpan kiraan kejadian x; Menyimpan panjang tiga rentetan; Melintasi rentetan s; Jika substring semasa adalah y, maka kenaikan nilai kiraan sebanyak 1; Jika substring semasa adalah x, maka cetak kiraan; Kod pemacu", "code": "function countOccurrences ( S , X , Y ) { let count = 0 ; let N = S . length , A = X . length ; let B = Y . length ; for ( let i = 0 ; i < N ; i ++ ) { if ( S . substr ( i , B ) == Y ) count ++ ; if ( S . substr ( i , A ) == X ) document . write ( count , \" \" ) ; } } let S = \" \" , X = \" \" , Y = \" \" ; countOccurrences ( S , X , Y ) ;"}
{"text": "Program untuk membina DFA untuk ungkapan biasa C (A + B) + | Fungsi untuk mencari sama ada rentetan yang diberikan diterima oleh DFA; Jika n <= 1, maka cetak tidak; Untuk mengira watak yang dipadankan; Semak jika watak pertama adalah c; Melintasi seluruh rentetan; Jika watak adalah A atau B, kiraan kenaikan sebanyak 1; Jika watak pertama tidak C, cetak - 1; Jika semua watak sepadan; Kod pemacu", "code": "function DFA ( str , N ) { if ( N <= 1 ) { document . write ( \" \" ) ; return ; } let count = 0 ; if ( str [ 0 ] == ' ' ) { count ++ ; for ( let i = 1 ; i < N ; i ++ ) { if ( str [ i ] == ' ' str [ i ] == ' ' ) count ++ ; else break ; } } else { document . write ( \" \" ) ; return ; } if ( count == N ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let str = \" \" ; let N = str . length ; DFA ( str , N ) ;"}
{"text": "Bilangan minimum dan maksimum digit yang diperlukan untuk dikeluarkan untuk membuat nombor tertentu dibahagikan dengan 3 | Berfungsi untuk mencari bilangan maksimum dan minimum digit yang akan dikeluarkan untuk menjadikan STR dibahagikan dengan 3; Tukar rentetan LETO pelbagai digit; Kiraan 0 s, 1 s, dan 2 s; Melintasi array; Cari jumlah digit % 3; Kes untuk mencari bilangan minimum digit yang akan dikeluarkan; Kes untuk mencari bilangan maksimum digit yang akan dikeluarkan; Kod pemacu; Panggilan fungsi", "code": "function minMaxDigits ( str , N ) { let arr = [ ] ; for ( let i = 0 ; i < N ; i ++ ) arr [ i ] = ( str [ i ] - ' ' ) % 3 ; let zero = 0 , one = 0 , two = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; } let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; } if ( sum == 0 ) { document . write ( 0 + \" \" ) ; } if ( sum == 1 ) { if ( ( one != 0 ) && ( N > 1 ) ) document . write ( 1 + \" \" ) ; else if ( two > 1 && N > 2 ) document . write ( 2 + \" \" ) ; else document . write ( - 1 + \" \" ) ; } if ( sum == 2 ) { if ( two != 0 && N > 1 ) document . write ( 1 + \" \" ) ; else if ( one > 1 && N > 2 ) document . write ( 2 + \" \" ) ; else document . write ( - 1 + \" \" ) ; } if ( zero > 0 ) document . write ( N - 1 + \" \" ) ; else if ( one > 0 && two > 0 ) document . write ( N - 2 + \" \" ) ; else if ( one > 2 two > 2 ) document . write ( N - 3 + \" \" ) ; else document . write ( - 1 + \" \" ) ; } let str = \" \" ; let N = str . length ; minMaxDigits ( str , N ) ;"}
{"text": "Penggantian minimum diperlukan untuk mendapatkan k | Berfungsi untuk mencari bilangan minimum perubahan untuk membuat rentetan k - berkala dan palindrome; Memulakan ans dengan 0; Berulang dari 0 hingga (k + 1) / 2; Frekuensi penyimpanan watak; Melewati semua indeks, i, i + k, i + 2 k .... dan menyimpan kekerapan watak; Meningkatkan kekerapan watak semasa; Melewati semua indeks k - i, 2 k - i, 3 ​​k - i .... dan menyimpan kekerapan watak; Jika k adalah ganjil & i adalah samw sebagai k / 2, pecahkan gelung; Meningkatkan kekerapan watak semasa; Cari kekerapan maksimum watak di antara semua watak yang dikunjungi; Jika K adalah ganjil dan saya sama dengan K / 2 maka, hanya aksara N / K yang dikunjungi; Jika tidak, n / k * 2 aksara telah melawat; Mengembalikan hasilnya; Kod pemacu; Panggilan fungsi", "code": "function findMinimumChanges ( N , K , S ) { var ans = 0 ; for ( var i = 0 ; i < parseInt ( ( K + 1 ) / 2 ) ; i ++ ) { var mp = new Map ( ) ; for ( var j = i ; j < N ; j += K ) { if ( mp . has ( S [ j ] ) ) { mp . set ( S [ j ] , mp . get ( S [ j ] ) + 1 ) ; } else { mp . set ( S [ j ] , 1 ) ; } } for ( var j = N - i - 1 ; j >= 0 ; j -= K ) { if ( ( K & 1 ) && i == parseInt ( K / 2 ) ) break ; if ( mp . has ( S [ j ] ) ) { mp . set ( S [ j ] , mp . get ( S [ j ] ) + 1 ) ; } else { mp . set ( S [ j ] , 1 ) ; } } var curr_max = - 1000000000 ; mp . forEach ( ( value , key ) => { curr_max = Math . max ( curr_max , value ) ; } ) ; if ( K & 1 && i == parseInt ( K / 2 ) ) ans += ( parseInt ( N / K ) - curr_max ) ; else ans += ( parseInt ( N / K ) * 2 - curr_max ) ; } return ans ; } var S = \" \" ; var N = S . length ; var K = 3 ; document . write ( findMinimumChanges ( N , K , S ) ) ;"}
{"text": "Semak sama ada rentetan mengandungi sebarang indeks dengan lebih banyak daripada aktif aktif k | Fungsi untuk memeriksa sama ada mana -mana indeks mengandungi lebih banyak daripada ak aktif aktif; Simpan kejadian terakhir setiap watak dalam peta. ; Menyimpan watak aktif; Masukkan watak; Jika saiz set melebihi k; Keluarkan watak dari set jika saya adalah indeks terakhir watak semasa; Kod pemacu", "code": "function checkString ( s , K ) { var n = s . length ; var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( mp . has ( s [ i ] ) ) { mp . set ( s [ i ] , mp . get ( s [ i ] ) + 1 ) ; } else mp . set ( s [ i ] , 1 ) ; } var cnt = 0 , f = 0 ; var st = new Set ( ) ; for ( var i = 0 ; i < n ; i ++ ) { st . add ( s [ i ] ) ; if ( st . size > K ) { f = 1 ; break ; } if ( mp . get ( s [ i ] ) == i ) st . delete ( s [ i ] ) ; } return ( f == 1 ? \" \" : \" \" ) ; } var s = \" \" ; var k = 2 ; document . write ( checkString ( s , k ) ) ;"}
{"text": "Kira bilangan rentetan dalam array yang wataknya berbeza kurang daripada m | Fungsi untuk mengira rentetan yang dikira watak -watak yang berbeza kurang daripada m; Gelung untuk melangkah ke atas semua rentetan array; Watak yang berbeza dalam rentetan dengan bantuan set; Memeriksa jika kurang daripada atau sama dengan m; Kod pemacu", "code": "function distinct ( S , M , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let set1 = new Set ( ) ; for ( let j = 0 ; j < S [ i ] . length ; j ++ ) { if ( ! set1 . has ( S [ i ] [ j ] ) ) set1 . add ( S [ i ] [ j ] ) ; } let c = set1 . size ; if ( c <= M ) count += 1 ; } document . write ( count ) ; } let S = [ \" \" , \" \" , \" \" ] ; let M = 7 ; let n = S . length ; distinct ( S , M , n ) ;"}
{"text": "Keluarkan aksara frekuensi ganjil dari rentetan | Berfungsi untuk menghapuskan aksara yang mempunyai frekuensi ganjil dalam rentetan; Buat peta untuk menyimpan kekerapan setiap watak; Untuk menyimpan rentetan baru; Keluarkan watak -watak yang mempunyai frekuensi ganjil; Jika watak mempunyai kekerapan ganjil maka langkau; Lain menggabungkan watak ke rentetan baru; Kembalikan rentetan yang diubah suai; Kod pemacu; Keluarkan watak yang mempunyai frekuensi ganjil", "code": "function removeOddFrequencyCharacters ( s ) { let m = new Map ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { let p = s [ i ] ; let count = m . get ( p ) ; if ( count == null ) { count = 0 ; m . set ( p , 1 ) ; } else m . set ( p , count + 1 ) ; } let new_string = \" \" ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( ( m . get ( s [ i ] ) & 1 ) == 1 ) continue ; new_string += s [ i ] ; } return new_string ; } let str = \" \" ; str = removeOddFrequencyCharacters ( str ) ; document . write ( str ) ;"}
{"text": "Produk nod di k | Pelaksanaan JavaScript untuk mencari produk unsur -unsur di peringkat k - th; Fungsi rekursif untuk mencari produk unsur -unsur di peringkat k - th; Jika subtree adalah batal, sama seperti jika root == null; Pertimbangkan hanya nod tahap untuk menjadi sebahagian daripada produk; Berulang untuk subtree kiri; Berulang untuk subtree yang betul; Menjaga ')' selepas subtree kiri dan kanan; Kod pemacu", "code": "var i ; function productAtKthLevel ( tree , k , level ) { if ( tree [ i ++ ] == ' ' ) { if ( tree [ i ] == ' ' ) return 1 ; var product = 1 ; if ( level == k ) product = tree [ i ] - ' ' ; ++ i ; var leftproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; var rightproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } return int . MinValue ; } var tree = \" \" ; var k = 2 ; i = 0 ; document . write ( productAtKthLevel ( tree , k , 0 ) ) ;"}
{"text": "Cetak watak yang paling berlaku dalam pelbagai rentetan | Berfungsi untuk mencetak watak yang paling banyak berlaku; Mewujudkan hash saiz 26; Untuk gelung untuk melangkah melalui setiap rentetan array; Untuk gelung untuk melangkah melalui setiap watak rentetan; Meningkatkan kiraan watak dalam hash; Mencari watak dengan kiraan maksimum; Mengisytiharkan vektor jenis rentetan", "code": "function findMostOccurringChar ( str ) { var hash = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < str . length ; i ++ ) { for ( var j = 0 ; j < str [ i ] . length ; j ++ ) { hash [ str [ i ] [ j ] ] ++ ; } } var max = 0 ; for ( var i = 0 ; i < 26 ; i ++ ) { max = hash [ i ] > hash [ max ] ? i : max ; } document . write ( String . fromCharCode ( max + 97 ) ) ; } var str = [ ] ; str . push ( \" \" ) ; str . push ( \" \" ) ; str . push ( \" \" ) ; str . push ( \" \" ) ; findMostOccurringChar ( str ) ;"}
{"text": "Semak sama ada nombor titik terapung yang diberikan adalah palindrome | Fungsi yang mengembalikan benar jika NUM adalah palindrome; Tukar nombor titik terapung yang diberikan ke dalam rentetan; Penunjuk menunjuk kepada watak pertama dan terakhir rentetan; Bukan palindrome; Mengemas kini petunjuk; Kod pemacu", "code": "function isPalindrome ( num ) { var s = num . toString ( ) ; var low = 0 ; var high = s . length - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; } var n = 123.321 ; if ( isPalindrome ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Bilangan maksimum kali str1 muncul sebagai bukan | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan bilangan maksimum kali STR1 boleh muncul sebagai substring yang tidak bertindih dalam STR2; STR1 tidak boleh menjadi substring str2; Simpan kekerapan watak Str1; Simpan kekerapan watak Str2; Untuk menyimpan kiraan substring yang diperlukan; Watak semasa tidak muncul dalam str1; Kekerapan watak semasa dalam Str1 adalah lebih besar daripada kekerapannya dalam Str2; Mengemas kini kiraan substrings yang mungkin; Kod pemacu", "code": "const MAX = 26 ; function maxSubStr ( str1 , len1 , str2 , len2 ) { if ( len1 > len2 ) return 0 ; let freq1 = new Array ( MAX ) . fill ( 0 ) ; for ( let i = 0 ; i < len1 ; i ++ ) freq1 [ str1 . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] ++ ; let freq2 = new Array ( MAX ) . fill ( 0 ) ; for ( let i = 0 ; i < len2 ; i ++ ) freq2 [ str2 . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] ++ ; let minPoss = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = Math . min ( minPoss , Math . floor ( freq2 [ i ] / freq1 [ i ] ) ) ; } return minPoss ; } let str1 = \" \" , str2 = \" \" ; let len1 = str1 . length ; let len2 = str2 . length ; document . write ( maxSubStr ( str1 , len1 , str2 , len2 ) ) ;"}
{"text": "Bilangan cara untuk memasukkan dua pasang kurungan ke dalam rentetan aksara n | Berfungsi untuk mengembalikan bilangan cara untuk memasukkan pasangan kurungan; Kod pemacu", "code": "function cntWays ( str , n ) { var x = n + 1 ; var ways = x * x * ( x * x - 1 ) / 12 ; return ways ; } var str = \" \" ; var n = str . length ; document . write ( cntWays ( str , n ) ) ;"}
{"text": "Bilangan minimum substrings rentetan yang diberikan boleh dibuang ke dalam yang memenuhi syarat -syarat yang diberikan | Tetapkan untuk menyimpan semua rentetan dari array yang diberikan; Untuk menyimpan kiraan yang diperlukan; Fungsi rekursif untuk mencari kiraan substrings yang boleh dibahagikan bermula dari indeks permulaan supaya semua substrings hadir dalam peta; Semua substring yang dipilih hadir dalam peta; Mengemas kini kiraan minimum substring; Bermula dari substrings panjang 1 yang bermula dengan indeks yang diberikan; Dapatkan substring; Jika substring hadir dalam set; Panggilan rekursif untuk sisa rentetan; Fungsi yang memasukkan semua rentetan dari array yang diberikan dalam satu set dan memanggil fungsi rekursif untuk mencari kiraan minimum substrings STR boleh dibuang ke dalam yang memenuhi syarat yang diberikan; Masukkan semua rentetan dari array yang diberikan dalam satu set; Cari kiraan yang diperlukan; Kod pemacu", "code": "var uSet = new Set ( ) ; var minCnt = 1000000000 ; function findSubStr ( str , cnt , start ) { if ( start == str . length ) { minCnt = Math . min ( cnt , minCnt ) ; } for ( var len = 1 ; len <= ( str . length - start ) ; len ++ ) { var subStr = str . substring ( start , start + len ) ; if ( uSet . has ( subStr ) ) { findSubStr ( str , cnt + 1 , start + len ) ; } } } function findMinSubStr ( arr , n , str ) { for ( var i = 0 ; i < n ; i ++ ) uSet . add ( arr [ i ] ) ; findSubStr ( str , 0 , 0 ) ; } var str = \" \" ; var arr = [ \" \" , \" \" , \" \" , \" \" , \" \" , \" \" ] ; var n = arr . length ; findMinSubStr ( arr , n , str ) ; document . write ( minCnt ) ;"}
{"text": "Bilangan substring yang bermula dengan \"geeks\" dan berakhir dengan \"untuk\" | Berfungsi untuk mengembalikan kiraan substring yang diperlukan; Untuk setiap indeks rentetan; Jika substring bermula pada indeks semasa adalah \"geeks\"; Jika substring adalah \"untuk\"; Kod pemacu", "code": "function countSubStr ( s , n ) { var c1 = 0 , c2 = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s . substring ( i , i + 5 ) == \" \" ) c1 ++ ; if ( s . substring ( i , i + 3 ) == \" \" ) c2 = c2 + c1 ; } return c2 ; } var s = \" \" ; var n = s . length ; document . write ( countSubStr ( s , n ) ) ;"}
{"text": "Infytq 2019: Cari kedudukan dari mana kurungan tidak seimbang | Menentukan rentetan; Menyimpan pendakap pembukaan dalam senarai LST1; Menyimpan pendakap penutup dalam senarai LST2; Mewujudkan senarai kosong LST; Mewujudkan kamus untuk memetakan pendakap penutup untuk membuka; Jika kedudukan pertama rentetan mengandungi sebarang pendakap penutup kembali 1; Jika watak -watak rentetan membuka pendakap maka masukkannya ke dalam senarai; Apabila saiz senarai adalah 0 dan pendakap penutup baru ditemui kemudian cetak indeksnya bermula dari 1; Ketika kami menemui pendakap penutup, kami memetakan mereka dengan pendakap pembukaan yang sesuai dengan menggunakan kamus dan periksa sama ada ia sama dengan pendakap yang dibuka terakhir (elemen terakhir dalam senarai) jika ya maka kami memadamkan elemt dari senarai; Jika tidak, kami mengembalikan indeks (bermula dari 1) di mana bersarang didapati salah; Pada akhir jika senarai kosong itu bermaksud rentetan bersarang dengan sempurna", "code": "let string = \" \" ; let lst1 = [ ' ' , ' ' , ' ' ] ; let lst2 = [ ' ' , ' ' , ' ' ] ; let lst = [ ] ; let Dict = { ' ' : ' ' , ' ' : ' ' , ' ' : ' ' } let a = 0 , b = 0 , c = 0 ; if ( string [ 0 ] in lst2 ) { document . write ( 1 + \" \" ) ; } else { for ( let i = 0 ; i < string . length ; i ++ ) { if ( string [ i ] in lst1 ) { lst . push ( string [ i ] ) ; k = i + 2 ; } else { if ( lst . lengt == 0 && ( string [ i ] in lst2 ) ) { document . write ( ( i + 1 ) + \" \" ) ; c = 1 ; break ; } else { if ( Dict [ string [ i ] ] == lst [ lst . length - 1 ] ) { lst . pop ( ) ; } else { break ; document . write ( ( i + 1 ) + \" \" ) ; a = 1 ; } } } } if ( lst . length == 0 && c == 0 ) { document . write ( 0 + \" \" ) ; b = 1 ; } if ( a == 0 && b == 0 && c == 0 ) { document . write ( k + \" \" ) ; } }"}
{"text": "Menyulitkan rentetan yang diberikan dengan operasi berikut | Pelaksanaan JavaScript pendekatan di atas :; Berfungsi untuk mengembalikan rentetan yang disulitkan; Kurangkan x kerana putaran panjang 26 tidak perlu; Kirakan kekerapan aksara; Jika kekerapan aksara arus bahkan maka kenaikannya dengan x; Lain menurunkannya dengan x; Mengembalikan kiraan; Kod pemacu", "code": "var MAX = 26 ; function encryptStr ( str , n , x ) { x = x % MAX ; var freq = Array ( MAX ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } for ( var i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] % 2 == 0 ) { var pos = ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + x ) % MAX ; str [ i ] = String . fromCharCode ( pos + ' ' . charCodeAt ( 0 ) ) ; } else { var pos = ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) - x ) ; if ( pos < 0 ) { pos += MAX ; } str [ i ] = String . fromCharCode ( pos + ' ' . charCodeAt ( 0 ) ) ; } } return str . join ( ' ' ) ; } var s = \" \" ; var n = s . length ; var x = 3 ; document . write ( encryptStr ( s . split ( ' ' ) , n , x ) ) ;"}
{"text": "Susun semula aksara dalam rentetan supaya tidak ada dua bersebelahan dengan menggunakan hashing | Fungsi yang mengembalikan benar jika mungkin untuk menyusun semula watak -watak rentetan supaya tidak dua aksara berturut -turut adalah sama; Untuk menyimpan kekerapan setiap watak; Untuk menyimpan kekerapan maksimum setakat ini; Jika boleh; Kod pemacu", "code": "function isPossible ( str ) { let freq = new Map ( ) ; let max_freq = 0 ; for ( let j = 0 ; j < ( str . length ) ; j ++ ) { if ( freq . has ( str [ j ] ) ) { freq . set ( str [ j ] , freq . get ( str [ j ] ) + 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } else { freq . set ( str [ j ] , 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } } if ( max_freq <= ( str . length - max_freq + 1 ) ) return true ; return false ; } let str = \" \" ; if ( isPossible ( str . split ( ' ' ) ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Cari watak yang tidak biasa dari dua rentetan | Tetapkan 2 | Berfungsi untuk mencetak aksara yang tidak biasa dalam rentetan yang diberikan dalam urutan yang disusun; Menukar watak ke kod ASCII; Operasi bit; Menukar watak ke kod ASCII; Operasi bit; Operasi XOR hanya meninggalkan watak -watak yang tidak biasa dalam pembolehubah ANS; Kod pemacu", "code": "function printUncommon ( str1 , str2 ) { var a1 = 0 , a2 = 0 ; for ( var i = 0 ; i < str1 . length ; i ++ ) { var ch = ( str1 [ i ] . charCodeAt ( 0 ) ) - ' ' . charCodeAt ( 0 ) ; a1 = a1 | ( 1 << ch ) ; } for ( var i = 0 ; i < str2 . length ; i ++ ) { var ch = ( str2 [ i ] . charCodeAt ( 0 ) ) - ' ' . charCodeAt ( 0 ) ; a2 = a2 | ( 1 << ch ) ; } var ans = a1 ^ a2 ; var i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { document . write ( String . fromCharCode ( ' ' . charCodeAt ( 0 ) + i ) ) ; } ans = parseInt ( ans / 2 ) ; i ++ ; } } var str1 = \" \" ; var str2 = \" \" ; printUncommon ( str1 , str2 ) ;"}
{"text": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Set | Mengembalikan kiraan pembalikan minimum untuk membuat expr seimbang. Pulangan - 1 Jika expr tidak boleh seimbang. ; Panjang ekspresi mestilah menjadikannya seimbang dengan menggunakan pembalikan. ; Untuk menyimpan bilangan pembalikan yang diperlukan. ; Untuk menyimpan nombor pendakap pembukaan yang tidak seimbang. ; Untuk menyimpan nombor kurungan penutupan yang tidak seimbang. ; Jika pendakap semasa dibuka maka kenaikan kiraan terbuka. ; Jika pendakap semasa dekat, periksa sama ada mengimbangi pendakap pembukaan. Jika ya maka pengurangan kiraan pendakap pembukaan yang tidak seimbang, lain -lain kenaikan kiraan pendakap penutupan. ; Untuk kes itu: \"} {\" Atau apabila satu penutupan dan satu pendakap pembukaan kekal untuk berpasangan, maka kedua -duanya perlu diterbalikkan. ; Kod pemacu", "code": "function countMinReversals ( expr ) { var len = expr . length ; if ( len % 2 ) return - 1 ; var ans = 0 ; var i ; var open = 0 ; var close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' ' ) open ++ ; else { if ( ! open ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close ) ans += 2 ; return ans ; } var expr = \" \" ; document . write ( countMinReversals ( expr ) ) ;"}
{"text": "Pasangan watak dari dua rentetan dengan jumlah keseluruhan | Berfungsi untuk mengembalikan jumlah pasangan yang sah; Kira jumlah nilai ASCII yang lebih baik dan ganjil untuk String S1; Kira jumlah nilai ASCII yang lebih baik dan ganjil untuk String S2; Mengembalikan jumlah pasangan yang sah; Kod pemacu", "code": "function totalPairs ( s1 , s2 ) { var a1 = 0 , b1 = 0 ; for ( var i = 0 ; i < s1 . length ; i ++ ) { if ( ( s1 [ i ] . charCodeAt ( 0 ) ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } var a2 = 0 , b2 = 0 ; for ( var i = 0 ; i < s2 . length ; i ++ ) { if ( ( s2 [ i ] . charCodeAt ( 0 ) ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; } var s1 = \" \" , s2 = \" \" ; document . write ( totalPairs ( s1 , s2 ) ) ;"}
{"text": "Kejadian maksimum awalan dalam array | Berfungsi untuk mengembalikan kiraan awalan yang diperlukan; Cari kekerapan watak pertama rentetan; Kod pemacu", "code": "function prefixOccurrences ( str ) { var c = str . charAt ( 0 ) ; var countc = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str . charAt ( i ) == c ) countc ++ ; } return countc ; } var str = \" \" ; document . write ( prefixOccurrences ( str ) ) ;"}
{"text": "Bilangan minimum operasi yang diberikan diperlukan untuk menukar rentetan ke rentetan lain | Berfungsi untuk mengembalikan operasi minimum jenis yang diberikan untuk menukar rentetan s ke rentetan t; Watak sudah sama; Kiraan kenaikan 0 s; Kiraan kenaikan 1 s; Kod pemacu", "code": "function minOperations ( s , t , n ) { var ct0 = 0 , ct1 = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] === t [ i ] ) continue ; if ( s [ i ] === \" \" ) ct0 ++ ; else ct1 ++ ; } return Math . max ( ct0 , ct1 ) ; } var s = \" \" , t = \" \" ; var n = s . length ; document . write ( minOperations ( s , t , n ) ) ;"}
{"text": "Dekripsi rentetan yang disulitkan dengan mengulangi i | Berfungsi untuk mengembalikan rentetan yang disahsulit; Lompat awal akan menjadi 1; Lompat kenaikan sebanyak 1 dengan setiap watak; Kod pemacu", "code": "function decryptString ( str , n ) { let i = 0 , jump = 1 ; let decryptedStr = \" \" ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; } let str = \" \" ; let n = str . length ; document . write ( decryptString ( str , n ) ) ;"}
{"text": "Cari bit yang flip urutan minimum menjadikan semua bit sama | Fungsi untuk memeriksa bit mana yang akan dibalik; pembolehubah untuk menyimpan watak pertama dan terakhir rentetan; Semak sama ada aksara pertama dan terakhir adalah sama, jika ya, kemudian kembalikan watak yang tidak akhirnya; lain kembali terakhir; Kod pemacu", "code": "function bitToBeFlipped ( s ) { let last = s [ s . length - 1 ] ; let first = s [ 0 ] ; if ( last == first ) { if ( last == ' ' ) { return ' ' ; } else { return ' ' ; } } else if ( last != first ) { return last ; } } let s = \" \" ; document . write ( bitToBeFlipped ( s ) , ' ' ) ;"}
{"text": "Jumlah dan produk frekuensi utama aksara dalam rentetan | Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mencari jumlah frekuensi utama watak -watak rentetan yang diberikan; Peta digunakan untuk menyimpan frekuensi watak; Melintasi peta; Jika kekerapan adalah perdana; Kod pemacu", "code": "function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } function sumProdOfPrimeFreq ( s ) { let prime = new Array ( s . length + 1 ) ; prime . fill ( true ) ; SieveOfEratosthenes ( prime , s . length + 1 ) ; let i , j ; let m = new Map ( ) ; for ( i = 0 ; i < s . length ; i ++ ) m . set ( s [ i ] , m . get ( s [ i ] ) == null ? 1 : m . get ( s [ i ] ) + 1 ) ; let sum = 0 , product = 1 ; for ( let it of m ) { console . log ( m ) if ( prime [ it [ 1 ] ] ) { sum += it [ 1 ] ; product *= it [ 1 ] ; } } document . write ( \" \" + sum ) ; document . write ( \" \" + product ) ; } let s = \" \" ; sumProdOfPrimeFreq ( s ) ;"}
{"text": "Semak jika kekerapan aksara dalam satu rentetan adalah faktor atau pelbagai kekerapan watak yang sama dalam rentetan lain | Fungsi yang memeriksa jika kekerapan watak adalah faktor atau pelbagai antara satu sama lain; kekerapan kedai peta setiap aksara; Jika sebarang kekerapan adalah 0, maka teruskan sebagai keadaan berpuas hati; jika faktor atau berganda, maka keadaan berpuas hati; jika keadaan tidak berpuas hati; Kod pemacu", "code": "function multipleOrFactor ( s1 , s2 ) { let m1 = new Map ( ) ; let m2 = new Map ( ) ; for ( let i = 0 ; i < s1 . length ; i ++ ) { if ( m1 [ s1 [ i ] ] ) m1 [ s1 [ i ] ] ++ ; else m1 [ s1 [ i ] ] = 1 } for ( let i = 0 ; i < s2 . length ; i ++ ) { if ( m2 [ s2 [ i ] ] ) m2 [ s2 [ i ] ] ++ ; else m2 [ s2 [ i ] ] = 1 } for ( var it in m1 ) { if ( ! ( m2 [ it ] ) ) continue ; if ( m2 [ it ] % m1 [ it ] == 0 m1 [ it ] % m2 [ it ] == 0 ) continue ; else return false ; } return true ; } let s1 = \" \" ; let s2 = \" \" ; multipleOrFactor ( s1 , s2 ) ? document . write ( \" \" ) : document . write ( \" \" ) ;"}
{"text": "Keluarkan walaupun aksara frekuensi dari rentetan | Fungsi yang menghilangkan aksara yang mempunyai frekuensi dalam rentetan; Buat peta untuk menyimpan kekerapan setiap watak; untuk menyimpan rentetan baru; Keluarkan watak -watak yang mempunyai frekuensi; Jika watak mempunyai kekerapan, maka langkau; lain menggabungkan watak ke rentetan baru; Paparkan rentetan yang diubah suai; Kod pemacu; Keluarkan watak yang mempunyai frekuensi bahkan", "code": "function solve ( s ) { let m = new Map ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( m . has ( s [ i ] ) ) m . set ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; else m . set ( s [ i ] , 1 ) ; } let new_string = \" \" ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( m . get ( s [ i ] ) % 2 == 0 ) continue ; new_string = new_string + s [ i ] ; } document . write ( new_string ) ; } let s = \" \" ; solve ( s ) ;"}
{"text": "Keluarkan semua perkataan palindromik dari ayat yang diberikan | fungsi untuk memeriksa sama ada 'str' adalah palindrome; melintasi kedua -dua hujungnya; bukan palindrome; palindrome; berfungsi untuk menghapuskan semua perkataan palindromik dari ayat yang diberikan; 'akhir _ str' untuk menyimpan rentetan akhir dan 'kata' kepada satu demi satu kedai setiap perkataan 'str'; Tambah ruang pada akhir 'str'; melintasi 'str'; mengumpul watak -watak perkataan semasa; jika 'perkataan' bukan palindrome maka tambahnya ke 'akhir _ str'; menetapkan semula; rentetan akhir yang diperlukan; Program Pemandu untuk diuji di atas", "code": "function isPalindrome ( str ) { var i = 0 , j = str . length - 1 ; while ( i < j ) if ( str [ i ++ ] != str [ j -- ] ) return false ; return true ; } function removePalinWords ( str ) { var final_str = \" \" , word = \" \" ; str = str + \" \" ; var n = str . length ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] != ' ' ) word = word + str [ i ] ; else { if ( ! ( isPalindrome ( word ) ) ) final_str += word + \" \" ; word = \" \" ; } } return final_str ; } var str = \" \" ; document . write ( removePalinWords ( str ) ) ;"}
{"text": "Jumlah semua berikutnya nombor | Mengembalikan nilai angka berikutnya S. Berikutnya yang akan dipilih diputuskan menggunakan corak bit Num (kami memilih semua digit yang mana terdapat bit set dalam NUM); Memulakan hasilnya; sehingga n! = 0; Jika saya - bit ditetapkan maka tambahkan nombor ini; Peralihan kanan i; fungsi untuk mencari jumlah gabungan semua jumlah keseluruhan individu; panjang rentetan; menyimpan gabungan; 2 ^ n - 1 berikutnya; gelung untuk semua berikutnya; mengembalikan jumlah gabungan; Fungsi pemacu", "code": "function findSubSequence ( s , num ) { let res = 0 ; let i = 0 ; while ( num > 0 ) { if ( ( num & 1 ) == 1 ) res += s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; i ++ ; num = num >> 1 ; } return res ; } function combinedSum ( s ) { let n = s . length ; let c_sum = 0 ; let range = ( 1 << n ) - 1 ; for ( let i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; } let s = \" \" ; document . write ( combinedSum ( s ) ) ;"}
{"text": "Susunan terpanjang di mana setiap watak berlaku sekurang -kurangnya k kali | Program JavaScript untuk mencari seterusnya dengan setiap watak yang berlaku sekurang -kurangnya k kali dalam rentetan s; Berfungsi untuk mencari berikutnya; Mengambil array tambahan untuk menyimpan rekod untuk kiraan watak dalam s; Mengira kejadian semua aksara dalam STR []; Percetakan aksara dengan kiraan> = k dalam susunan yang sama kerana ia muncul dalam str. ; Kod pemacu", "code": "var MAX_CHAR = 26 ; function findSubsequence ( str , k ) { var a = Array ( MAX_CHAR ) . fill ( 0 ) ; for ( var i = 0 ; i < str . length ; i ++ ) a [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < str . length ; i ++ ) if ( a [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] >= k ) document . write ( str [ i ] ) ; } var k = 2 ; findSubsequence ( \" \" , k ) ;"}
{"text": "Google Case Of A Sentyen tertentu | Program JavaScript untuk menukar ayat ke Google Case; rentetan kosong; Tukar rentetan input ke atas kes; checki jika watak bukan ruang dan menambahkannya ke rentetan w; Menukar watak pertama ke kes yang lebih rendah dan huruf awal berikutnya perkataan lain kepada kes yang lebih rendah; Kod pemacu", "code": "function convert ( str ) { var w = \" \" , z = \" \" ; str = str . toUpperCase ( ) + \" \" ; for ( i = 0 ; i < str . length ; i ++ ) { var ch = str [ i ] ; if ( ch != ' ' ) w = w + ch ; else { z = z + ( w [ 0 ] . toLowerCase ( ) ) + w . substring ( 1 ) + \" \" ; w = \" \" ; } } return z ; } var str = \" \" ; document . write ( convert ( str ) ) ;"}
{"text": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan rentetan; CV untuk mengira vokal CC untuk mengira konsonan; Mengira awalan kiraan vokal dan awalan kiraan konsonan; Menjana rentetan yang disulitkan. ; Kod pemacu", "code": "function isVowel ( c ) { return c === \" \" || c === \" \" || c === \" \" || c === \" \" || c === \" \" ; } function encryptString ( s , n , k ) { var cv = new Array ( n ) . fill ( 0 ) ; var cc = new Array ( n ) . fill ( 0 ) ; if ( isVowel ( s [ 0 ] ) ) cv [ 0 ] = 1 ; else cc [ 0 ] = 1 ; for ( var i = 1 ; i < n ; i ++ ) { cv [ i ] = cv [ i - 1 ] + ( isVowel ( s [ i ] ) === true ? 1 : 0 ) ; cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) === true ? 0 : 1 ) ; } var ans = \" \" ; var prod = 0 ; prod = cc [ k - 1 ] * cv [ k - 1 ] ; ans += prod ; for ( var i = k ; i < s . length ; i ++ ) { prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ; ans += prod ; } return ans ; } var s = \" \" ; var n = s . length ; var k = 2 ; document . write ( encryptString ( s . split ( \" \" ) , n , k ) + \" \" ) ;"}
{"text": "Kira kejadian perkataan dalam rentetan | Program JavaScript untuk mengira bilangan berlakunya perkataan dalam rentetan yang diberikan; berpecah rentetan dengan ruang dalam A; Cari corak dalam A; jika perlawanan mendapati kenaikan kiraan; Kod pemacu", "code": "function countOccurrences ( str , word ) { let a = str . split ( \" \" ) ; let count = 0 ; for ( let i = 0 ; i < a . length ; i ++ ) { if ( word == ( a [ i ] ) ) count ++ ; } return count ; } let str = \" \" ; let word = \" \" ; document . write ( countOccurrences ( str , word ) ) ;"}
{"text": "Tinggalkan rentetan dengan menukar kes | Berfungsi untuk menjana permutasi; Bilangan permutasi adalah 2 ^ n; Menukar rentetan ke kes yang lebih rendah; Menggunakan semua berikutnya dan membenarkannya; Jika b - th bit ditetapkan, kami menukarnya ke atas kes; Mencetak gabungan semasa; Program pemacu untuk menguji fungsi di atas", "code": "function permute ( input ) { var n = input . length ; var max = 1 << n ; input = input . toLowerCase ( ) ; for ( var i = 0 ; i < max ; i ++ ) { var combination = input . split ( ' ' ) ; for ( var j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = String . fromCharCode ( combination [ j ] . charCodeAt ( 0 ) - 32 ) ; } document . write ( combination . join ( ' ' ) ) ; document . write ( \" \" ) ; } } permute ( \" \" ) ;"}
{"text": "Cetak rentetan selepas watak yang ditentukan telah berlaku diberi tidak. masa | Kaedah untuk mencetak rentetan; Jika diberi kiraan adalah 0 cetak rentetan yang diberikan dan kembali; Mula melintasi rentetan; Kenaikan OCC jika char semasa adalah sama dengan watak yang diberikan; Pecahkan gelung jika watak yang diberikan telah berlaku tidak diberikan. masa; Cetak rentetan selepas berlakunya watak yang diberikan tidak. masa; Jika tidak, rentetan kosong; Kaedah Pemandu", "code": "function printString ( str , ch , count ) { var occ = 0 , i ; if ( count == 0 ) { document . write ( str ) ; return ; } for ( i = 0 ; i < str . length ; i ++ ) { if ( str . charAt ( i ) == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length - 1 ) document . write ( str . substring ( i + 1 ) ) ; else document . write ( \" \" ) ; } var str = \" \" ; printString ( str , ' ' , 2 ) ;"}
{"text": "Vokal terbalik dalam rentetan yang diberikan | fungsi utiliti untuk memeriksa vokal; Berfungsi untuk membalikkan urutan vokal; Mulakan dua indeks dari dua sudut dan bergerak ke arah satu sama lain; bertukar; Fungsi pemacu", "code": "function isVowel ( c ) { return ( c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' ) ; } function reverseVowel ( str ) { let i = 0 ; let j = str . length - 1 ; let str1 = str . split ( \" \" ) ; while ( i < j ) { if ( ! isVowel ( str1 [ i ] ) ) { i ++ ; continue ; } if ( ! isVowel ( str1 [ j ] ) ) { j -- ; continue ; } let t = str1 [ i ] ; str1 [ i ] = str1 [ j ] ; str1 [ j ] = t ; i ++ ; j -- ; } let str2 = ( str1 ) . join ( \" \" ) ; return str2 ; } let str = \" \" ; document . write ( reverseVowel ( str ) ) ;"}
{"text": "Bilangan minimum Palindromic selepas dikeluarkan untuk mengosongkan rentetan binari | Fungsi untuk memeriksa sama ada string str adalah palindrome; Bermula dari sudut paling kiri dan paling kanan Str; Terus membandingkan watak semasa mereka sama; Mengembalikan kiraan minimum palindromic subseuqnces untuk dikeluarkan untuk membuat rentetan kosong; Jika rentetan kosong; Jika rentetan adalah palindrome; Jika rentetan bukan palindrome; Kod pemacu", "code": "function isPalindrome ( str ) { let l = 0 ; let h = str . length - 1 ; while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return false ; return true ; } function minRemovals ( str ) { if ( str [ 0 ] == ' ' ) return 0 ; if ( isPalindrome ( str ) ) return 1 ; return 2 ; } document . write ( minRemovals ( \" \" ) + \" \" ) ; document . write ( minRemovals ( \" \" ) ) ;"}
{"text": "Cari nilai xxxx .... . (N kali) % m di mana n adalah besar | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini x jika ia> = p; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y / 2; Fungsi untuk mengembalikan xxx .... . (N kali) % m; Mengembalikan mod dengan m nombor yang lebih kecil; Mewujudkan rentetan n x 's; Menukar rentetan ke int dan mengira modulo; Memeriksa pariti n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk ganjil n; Kod pemacu; Cetak xxx ... (n kali) % m", "code": "function power ( x , y , p ) { var res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } function findModuloByM ( X , N , M ) { if ( N < 6 ) { var temp = \" \" ; for ( var i = 1 ; i < N ; i ++ ) { temp += String . fromCharCode ( 48 + X ) ; } var res = parseInt ( temp ) % M ; return res ; } if ( N % 2 == 0 ) { var half = findModuloByM ( X , N / 2 , M ) % M ; var res = ( half * power ( 10 , N / 2 , M ) + half ) % M ; return res ; } else { var half = findModuloByM ( X , N / 2 , M ) % M ; var res = ( half * power ( 10 , N / 2 + 1 , M ) + half * 10 + X ) % M ; return res ; } } var X = 6 , N = 14 , M = 9 ; document . write ( findModuloByM ( X , N , M ) ) ;"}
{"text": "Semak jika dua lingkaran bersilang sedemikian rupa sehingga bulatan ketiga melewati titik -titik persimpangan dan pusat mereka | Struktur bulatan; Fungsi utiliti untuk memeriksa sama ada lingkaran yang diberikan memenuhi kriteria yang diperlukan; Menyimpan jarak antara pusat C1 dan C2; Menyimpan status jika kriteria yang diberikan berpuas hati atau tidak; Jika C1C2 kurang daripada jumlah radii 2 lingkaran pertama; Jika C3 adalah titik tengah pusat di C1 dan C2; Tanda bendera benar; Bendera kembali; Fungsi untuk memeriksa sama ada lingkaran yang diberikan memenuhi kriteria yang diperlukan; Semak kombinasi bulatan semasa; Semak kombinasi seterusnya; Kod pemacu", "code": "class circle { constructor ( x , y , r ) { this . x = x ; this . y = y ; this . r = r ; } } function check ( C ) { let C1C2 = Math . sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) ; let flag = false ; if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) { if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x && ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) { flag = true ; } } return flag ; } function IsFairTriplet ( c ) { let f = false ; f |= check ( c ) ; for ( let i = 0 ; i < 2 ; i ++ ) { swap ( c [ 0 ] , c [ 2 ] ) ; f |= check ( c ) ; } return f ; } function swap ( circle1 , circle2 ) { let temp = circle1 ; circle1 = circle2 ; circle2 = temp ; } let C = new Array ( 3 ) ; C [ 0 ] = new circle ( 0 , 0 , 8 ) ; C [ 1 ] = new circle ( 0 , 10 , 6 ) ; C [ 2 ] = new circle ( 0 , 5 , 5 ) ; if ( IsFairTriplet ( C ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Program untuk mencari eksentrik hyperbola | Berfungsi untuk mencari eksentrik hiperbola; Menyimpan nisbah kuadrat paksi utama kepada paksi kecil; Kenaikan r oleh 1; Mengembalikan akar kuadrat R; Kod pemacu", "code": "function eccHyperbola ( A , B ) { let r = B * B / A * A ; r += 1 ; return Math . sqrt ( r ) ; } let A = 3.0 ; let B = 2.0 ; document . write ( eccHyperbola ( A , B ) ) ;"}
{"text": "Kirakan kawasan kuadrilateral kitaran dengan panjang sampingan yang diberikan | Berfungsi untuk mencari kawasan kuadrilateral kitaran; Menyimpan nilai separuh perimeter; Kedai kawasan kuadrilateral kitaran; Mengembalikan kawasan yang dihasilkan; Kod pemacu", "code": "function calculateArea ( A , B , C , D ) { let S = ( A + B + C + D ) / 2 let area = Math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) return area ; } let A = 10 ; let B = 15 ; let C = 20 ; let D = 25 ; document . write ( calculateArea ( A , B , C , D ) . toFixed ( 3 ) )"}
{"text": "Kirakan nisbah kawasan segitiga yang tertulis dalam elips dan segitiga yang dibentuk oleh titik yang sama pada bulatan tambahan | Fungsi untuk mengira nisbah segitiga yang tertulis dalam elips ke segitiga pada bulatan tambahan; Menyimpan nisbah separuh besar hingga separuh kapak kecil; Cetak nisbah; Kod pemacu", "code": "function triangleArea ( a , b ) { ratio = b / a document . write ( ratio ) } var a = 1 var b = 2 triangleArea ( a , b )"}
{"text": "Program untuk mencari excenters segitiga | Berfungsi untuk mengira jarak antara sepasang pos; Fungsi untuk mengira koordinat excenters segitiga; Panjang sisi segitiga; Menyimpan koordinat excenters segitiga; Untuk i1; Untuk i2; Untuk i3; Prvar excenters segitiga; Kod pemacu", "code": "function distance ( m , n , p , q ) { return Math . sqrt ( Math . pow ( n - m , 2 ) + Math . pow ( q - p , 2 ) * 1.0 ) ; } function Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) { var a = distance ( x2 , x3 , y2 , y3 ) ; var b = distance ( x3 , x1 , y3 , y1 ) ; var c = distance ( x1 , x2 , y1 , y2 ) ; var excenter = new Array ( 4 ) ; for ( var i = 0 ; i < 4 ; i ++ ) excenter [ i ] = new Array ( 2 ) ; excenter [ 1 ] [ 0 ] = ( - ( a * x1 ) + ( b * x2 ) + ( c * x3 ) ) / ( - a + b + c ) ; excenter [ 1 ] [ 1 ] = ( - ( a * y1 ) + ( b * y2 ) + ( c * y3 ) ) / ( - a + b + c ) ; excenter [ 2 ] [ 0 ] = ( ( a * x1 ) - ( b * x2 ) + ( c * x3 ) ) / ( a - b + c ) ; excenter [ 2 ] [ 1 ] = ( ( a * y1 ) - ( b * y2 ) + ( c * y3 ) ) / ( a - b + c ) ; excenter [ 3 ] [ 0 ] = ( ( a * x1 ) + ( b * x2 ) - ( c * x3 ) ) / ( a + b - c ) ; excenter [ 3 ] [ 1 ] = ( ( a * y1 ) + ( b * y2 ) - ( c * y3 ) ) / ( a + b - c ) ; for ( var i = 1 ; i <= 3 ; i ++ ) { document . write ( excenter [ i ] [ 0 ] + \" \" + excenter [ i ] [ 1 ] + \" \" ) ; } } var x1 , x2 , x3 , y1 , y2 , y3 ; x1 = 0 ; x2 = 3 ; x3 = 0 ; y1 = 0 ; y2 = 0 ; y3 = 4 ; Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) ;"}
{"text": "Nombor Icositetragonal | Berfungsi untuk mencari nombor icositetragonal; Formula untuk mengira nombor icositetragonal nth; Kod pemacu", "code": "function Icositetragonal_num ( n ) { return ( 22 * n * n - 20 * n ) / 2 ; } let n = 3 ; document . write ( Icositetragonal_num ( n ) + \" \" ) ; n = 10 ; document . write ( Icositetragonal_num ( n ) ) ;"}
{"text": "Kawasan bulatan yang ditulis dalam trapezoid isosceles | Fungsi untuk mencari kawasan bulatan yang ditulis dalam trapezoid yang mempunyai sisi bukan selari m, n; Radius bulatan oleh formula i. e. akar (m * n) / 2 kawasan bulatan = (3.141) * (r * * 2); Kod pemacu", "code": "function area_of_circle ( m , n ) { var square_of_radius = ( m * n ) / 4 ; var area = ( 3.141 * square_of_radius ) ; return area ; } var n = 10 ; var m = 30 ; document . write ( area_of_circle ( m , n ) ) ;"}
{"text": "Kawasan segitiga sama rata yang tertulis dalam lingkaran radius r | Berfungsi untuk mencari kawasan segitiga sama rata yang tertulis dalam lingkaran radius r; Asas dan ketinggian segitiga sama rata; Kawasan menggunakan asas dan ketinggian; Kod pemacu", "code": "function area ( R ) { var base = 1.732 * R ; var height = ( 1.5 ) * R ; var area = 0.5 * base * height ; return area ; } var R = 7 ; document . write ( area ( R ) ) ;"}
{"text": "Kawasan bulatan terbesar yang boleh ditulis dalam separuh bulatan | Berfungsi untuk mencari kawasan bulatan; Radius tidak boleh negatif; Kawasan bulatan terbesar; Kod pemacu", "code": "function circlearea ( R ) { if ( R < 0 ) return - 1 ; var a = 3.14 * R * R / 4 ; return a ; } var R = 2 ; document . write ( circlearea ( R ) ) ;"}
{"text": "Bilangan pasang garisan yang mempunyai titik persimpangan integer | Mengira bilangan pasang garis yang mempunyai titik persimpangan integer; Memulakan susunan untuk menyimpan tuduhan; Kiraan bilangan ganjil dan bahkan pi; Kiraan bilangan ganjil dan bahkan qi; Mengembalikan kiraan pasangan; Kod pemacu", "code": "function countPairs ( P , Q , N , M ) { var A = [ 0 , 0 ] , B = [ 0 , 0 ] ; for ( var i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( var i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; } var P = [ 1 , 3 , 2 ] , Q = [ 3 , 0 ] ; var N = P . length ; var M = Q . length ; document . write ( countPairs ( P , Q , N , M ) ) ;"}
{"text": "Bilangan maksimum persimpangan garis yang dibentuk melalui persimpangan pesawat N | Berfungsi untuk mengira bilangan maksimum persimpangan yang mungkin; Kod pemacu", "code": "function countIntersections ( n ) { return n * ( n - 1 ) / 2 ; } var n = 3 ; document . write ( countIntersections ( n ) ) ;"}
{"text": "Kawasan pentagram biasa | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan kawasan segitiga BCD; Menggunakan nisbah emas; Hitung kawasan segitiga BCD; Kawasan pulangan semua 5 segitiga adalah sama; Berfungsi untuk mengembalikan kawasan pentagon biasa; Kirakan kawasan pentagon biasa menggunakan formula di atas; Kawasan pulangan Pentagon biasa; Berfungsi untuk mengembalikan kawasan pentagram; Kawasan pentagram adalah sama dengan kawasan pentagon biasa dan lima kali kawasan segitiga; Kod pemacu", "code": "var PI = 3.14159 function areaOfTriangle ( d ) { var c = 1.618 * d ; var s = ( d + c + c ) / 2 ; var area = Math . sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) ; return 5 * area ; } function areaOfRegPentagon ( d ) { var cal = 4 * Math . tan ( PI / 5 ) ; var area = ( 5 * d * d ) / cal ; return area ; } function areaOfPentagram ( d ) { return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) ; } var d = 5 ; document . write ( areaOfPentagram ( d ) . toFixed ( 3 ) ) ;"}
{"text": "Sudut yang disebarkan oleh kord ke pusat bulatan apabila sudut yang disuntik oleh kord lain yang sama dari lingkaran kongruen diberikan | Program JavaScript untuk mencari sudut yang disembur oleh kord ke pusat bulatan apabila sudut yang diselaraskan oleh kord lain yang sama dari lingkaran kongruen diberikan; Kod pemacu", "code": "function anglequichord ( z ) { document . write ( \" \" + z + \" \" ) ; } var z = 48 ; anglequichord ( z ) ;"}
{"text": "Program untuk mencetak nilai ASCII bagi semua digit nombor tertentu | Berfungsi untuk menukar digit N ke nilai ASCII masing -masing; Kod pemacu", "code": "function convertToASCII ( N ) { let num = N . toString ( ) ; for ( let ch = 0 ; ch < num . length ; ch ++ ) { document . write ( num [ ch ] + \" \" + num [ ch ] . charCodeAt ( 0 ) + \" \" ) ; } } let N = 36 ; convertToASCII ( N ) ;"}
{"text": "Teka -teki Arus Produk | Set 3 | Berfungsi untuk membentuk pelbagai produk dengan ruang O (n) dan o (1); Menyimpan produk array; Menyimpan kiraan sifar; Melintasi array; Jika arr [i] tidak sifar; Jika arr [i] adalah sifar maka kiraan kenaikan z oleh 1; Menyimpan nilai mutlak produk; Jika z sama dengan 1; Jika arr [i] tidak sifar; Lain; Jika kiraan 0 s sekurang -kurangnya 2; Berikan arr [i] = 0; Simpan nilai mutlak arr [i]; Cari nilai A / B; Jika arr [i] dan produk kedua -duanya kurang daripada sifar; Jika arr [i] dan produk kedua -duanya lebih besar daripada sifar; Lain; Melintasi array arr []; Kod pemacu; Panggilan fungsi", "code": "function productExceptSelf ( arr , N ) { let product = 1 ; let z = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) product *= arr [ i ] ; if ( arr [ i ] == 0 ) z += 1 ; } let a = Math . abs ( product ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( z == 1 ) { if ( arr [ i ] != 0 ) arr [ i ] = 0 ; else arr [ i ] = product ; continue ; } else if ( z > 1 ) { arr [ i ] = 0 ; continue ; } let b = Math . abs ( arr [ i ] ) ; let curr = Math . round ( Math . exp ( Math . log ( a ) - Math . log ( b ) ) ) ; if ( arr [ i ] < 0 && product < 0 ) arr [ i ] = curr ; else if ( arr [ i ] > 0 && product > 0 ) arr [ i ] = curr ; else arr [ i ] = - 1 * curr ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; } } let arr = [ 10 , 3 , 5 , 6 , 2 ] ; let N = arr . length ; productExceptSelf ( arr , N ) ;"}
{"text": "Count Subarrays terdiri daripada single | Fungsi untuk mengira subarrays yang terdiri daripada bilangan bulat tunggal sahaja; Kedai kiraan subarray; Menyimpan kiraan nombor angka tunggal berturut -turut dalam array; Melintasi array; Saiz kenaikan blok sebanyak 1; Peningkatan res mengikut kiraan; Menetapkan kiraan = 0; Diberikan array; Saiz array", "code": "function singleDigitSubarrayCount ( arr , N ) { let res = 0 ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } document . write ( res ) ; } let arr = [ 0 , 1 , 14 , 2 , 5 ] ; let N = arr . length ; singleDigitSubarrayCount ( arr , N ) ;"}
{"text": "Kira bilangan bulat sehingga n yang boleh diwakili sebagai jumlah dua atau lebih nombor berturut -turut | Fungsi untuk memeriksa sama ada nombor n boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut atau tidak; Fungsi untuk mengira bilangan bulat dalam julat [1, n] yang boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut; Menyimpan kiraan yang diperlukan; Kod pemacu", "code": "function isPossible ( N ) { return ( ( ( N & ( N - 1 ) ) & N ) ) ; } function countElements ( N ) { var count = 0 ; for ( i = 1 ; i <= N ; i ++ ) { if ( isPossible ( i ) != 0 ) count ++ ; } document . write ( count ) ; } var N = 15 ; countElements ( N ) ;"}
{"text": "Kira bilangan bulat sehingga n yang boleh diwakili sebagai jumlah dua atau lebih nombor berturut -turut | Fungsi untuk mengira bilangan bulat dalam julat [1, n] yang boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut; Mengira kuasa 2 sehingga n; Kiraan kenaikan; Mengemas kini kuasa semasa 2; Kod pemacu", "code": "function countElements ( N ) { var Cur_Ele = 1 ; var Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } document . write ( N - Count ) ; } var N = 15 ; countElements ( N ) ;"}
{"text": "Perbezaan maksimum antara sepasang elemen bersebelahan dengan tidak termasuk setiap elemen sekali | Fungsi untuk mengira perbezaan maksimum antara elemen bersebelahan tidak termasuk setiap elemen array sekali; Kirakan perbezaan bersebelahan maksimum untuk keseluruhan array; Simpan maksimum antara arr_max dan curr_max; Tambah hasilnya ke dalam vektor; Cetak hasilnya; Kod pemacu", "code": "function maxAdjacent ( arr , N ) { let res = [ ] ; let arr_max = Number . MIN_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { arr_max = Math . max ( arr_max , Math . abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( let i = 1 ; i < N - 1 ; i ++ ) { let curr_max = Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; let ans = Math . max ( curr_max , arr_max ) ; res . push ( ans ) ; } document . write ( res . join ( \" \" ) ) ; } let arr = [ 1 , 3 , 4 , 7 , 8 ] ; let N = arr . length ; maxAdjacent ( arr , N ) ;"}
{"text": "Kurangkan kenaikan yang diperlukan untuk membuat kiraan elemen array yang sama dan ganjil sama | Berfungsi untuk mencari operasi min untuk membuat kiraan yang sama dan ganjil sama; Saiz ganjil tidak akan menjadi ganjil dan juga dianggap sama; Menyimpan kiraan nombor walaupun dalam array arr; Kedai mengira nombor ganjil dalam array arr; Melintasi array arr; Jika arr [i] adalah nombor yang sama; Kemas kini cnteven; Nombor ganjil dalam arr; Kembali perbezaan mutlak dibahagikan dengan 2; Kod pemacu; Panggilan fungsi", "code": "function minimumIncrement ( arr , N ) { if ( N % 2 != 0 ) { document . write ( \" \" ) ; System . exit ( 0 ) ; } var cntEven = 0 ; var cntOdd = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cntEven += 1 ; } } cntOdd = N - cntEven ; return Math . abs ( cntEven - cntOdd ) / 2 ; } var arr = [ 1 , 3 , 4 , 9 ] ; var N = arr . length ; document . write ( minimumIncrement ( arr , N ) ) ;"}
{"text": "Kira cara untuk membina array dengan produk walaupun dari array yang diberikan sedemikian rupa sehingga perbezaan mutlak unsur -unsur yang diindeks sama paling banyak 1 | Fungsi untuk mencari mengira cara untuk membina array, b seperti abs (a [i] - b [i]) <= 1 dan produk unsur -unsur B adalah walaupun; Kedai kiraan array b seperti abs (a [i] - b [i]) <= 1; Kedai -kedai Count of Arrays B yang produk elemennya tidak juga; Melintasi array; Jumlah kemas kini; Jika [i] adalah nombor yang sama; Kemas kini Oddarray; Cetak var 3 ^ n - 2 ^ x; Kod pemacu", "code": "function cntWaysConsArray ( A , N ) { var total = 1 ; var oddArray = 1 ; for ( i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } document . write ( total - oddArray ) ; } var A = [ 2 , 4 ] ; var N = A . length ; cntWaysConsArray ( A , N ) ;"}
{"text": "Kira nombor sehingga n yang paling tepat ditetapkan adalah k | Fungsi untuk mengira nombor dalam julat [1, n] yang paling tepat ditetapkan adalah k; Menyimpan nombor yang paling tepat adalah k; Nombor yang paling tepat adalah i; Mengurangkan nombor yang paling tepat ditetapkan adalah saya, dari n; Oleh kerana i = k, maka nombor yang paling tepat ditetapkan adalah k disimpan; Kod pemacu", "code": "function countNumberHavingKthBitSet ( N , K ) { let numbers_rightmost_setbit_K = 0 ; for ( let i = 1 ; i <= K ; i ++ ) { let numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } document . write ( numbers_rightmost_setbit_K ) ; } let N = 15 ; let K = 2 ; countNumberHavingKthBitSet ( N , K ) ;"}
{"text": "Kira pekali ganjil dan bahkan binomial N | Fungsi untuk mengira set bit dalam perwakilan binari nombor n; Count set bit dalam n; Mengembalikan kiraan akhir; Kod pemacu; Cetak koefisien binomial ganjil; Cetak walaupun koefisien binomial", "code": "function countSetBits ( N ) { let count = 0 ; while ( N != 0 ) { N = N & ( N - 1 ) ; count ++ ; } return count ; } let N = 4 ; let bits = countSetBits ( N ) ; document . write ( \" \" + \" \" + ( Math . pow ( 2 , bits ) ) + \" \" ) ; document . write ( \" \" + \" \" + ( N + 1 - ( Math . pow ( 2 , bits ) ) ) ) ;"}
{"text": "Buat semua elemen array walaupun dengan menggantikan mana -mana sepasang elemen array dengan jumlah mereka | Fungsi untuk mencari bilangan minimum penggantian yang diperlukan untuk membuat semua elemen array walaupun; Menyimpan kiraan elemen ganjil; Melintasi array; Meningkatkan kiraan elemen ganjil; Bilangan penggantian yang diperlukan; Dua langkah tambahan diperlukan untuk membuat elemen ganjil yang terakhir walaupun; Cetak penggantian minimum; Kod pemacu; Panggilan fungsi", "code": "function minMoves ( arr , N ) { var odd_element_cnt = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } var moves = Math . floor ( ( odd_element_cnt ) / 2 ) ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; document . write ( moves ) ; } var arr = [ 5 , 6 , 3 , 7 , 20 ] ; N = arr . length ; minMoves ( arr , N ) ;"}
{"text": "Split Squares of First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Berfungsi untuk partition squares nombor semulajadi dalam dua subset; Simpan kiraan blok saiz 8; Pemisahan blok 8 elemen; Simpan perbezaan subset minimum; Pemisahan elemen N untuk meminimumkan perbezaan jumlah subset mereka; Simpan unsur subset A dan B; Jika elemen adalah jenis A; Jika elemen adalah jenis B; Cetak perbezaan subset minimum; Cetak subset pertama; Cetak subset kedua; Kod pemacu; Panggilan fungsi", "code": "function minimumSubsetDifference ( N ) { let blockOfSize8 = N / 8 ; let str = \" \" ; let subsetDifference = 0 ; let partition = \" \" ; while ( blockOfSize8 -- > 0 ) { partition += str ; } let A = [ ] ; let B = [ ] ; let x = 0 , y = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( partition [ i ] == ' ' ) { A [ x ++ ] = ( ( i + 1 ) * ( i + 1 ) ) ; } else { B [ y ++ ] = ( ( i + 1 ) * ( i + 1 ) ) ; } } document . write ( subsetDifference + \" \" ) ; for ( let i = 0 ; i < x ; i ++ ) document . write ( A [ i ] + \" \" ) ; document . write ( \" \" ) ; for ( let i = 0 ; i < y ; i ++ ) document . write ( B [ i ] + \" \" ) ; } let N = 8 ; minimumSubsetDifference ( N ) ;"}
{"text": "Pembahagi terbesar nombor yang tidak dapat dibahagikan dengan nombor yang lain | Berfungsi untuk mencari nombor terbesar x supaya ia membahagikan p tetapi tidak dapat dibahagikan dengan q; Menyimpan kiraan kekerapan semua faktor utama; Meningkatkan kekerapan faktor utama semasa; Jika Q adalah faktor utama; Menyimpan hasil yang diingini; Melangkah melalui semua pembahagi Q; Menyimpan kiraan kekerapan pembahagi utama semasa untuk membahagikan p; Mengira kekerapan faktor utama semasa; Jika CUR kurang daripada kekerapan maka p adalah hasil akhir; Berulang untuk mendapatkan jawapan sementara; Mengemas kini jawapan semasa; Cetak hasil yang diinginkan; Diberikan p dan q; Panggilan fungsi", "code": "function findTheGreatestX ( P , Q ) { var divisiors = new Map ( ) ; for ( var i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 && Q > 1 ) { Q = parseInt ( Q / i ) ; if ( divisiors . has ( i ) ) divisiors . set ( i , divisiors . get ( i ) + 1 ) else divisiors . set ( i , 1 ) } } if ( Q > 1 ) if ( divisiors . has ( Q ) ) divisiors . set ( Q , divisiors . get ( Q ) + 1 ) else divisiors . set ( Q , 1 ) var ans = 0 ; divisiors . forEach ( ( value , key ) => { var frequency = value ; var temp = P ; var cur = 0 ; while ( temp % key == 0 ) { temp = parseInt ( temp / key ) ; cur ++ ; } if ( cur < frequency ) { ans = P ; } temp = P ; for ( var j = cur ; j >= frequency ; j -- ) { temp = parseInt ( temp / key ) ; } ans = Math . max ( temp , ans ) ; } ) ; document . write ( ans ) ; } var P = 10 , Q = 4 ; findTheGreatestX ( P , Q ) ;"}
{"text": "Semak jika baris matriks boleh disusun semula untuk membuat bitwise xor lajur pertama non | Fungsi untuk memeriksa sama ada ada baris di mana bilangan elemen unik lebih besar daripada 1; Melangkah ke atas matriks; Fungsi untuk memeriksa sama ada mungkin untuk menyusun semula tikar [] [] supaya xor lajur pertamanya bukan sifar; Cari bitwise xor lajur pertama Mat [] []; Jika bitwise xor lajur pertama tikar [] [] bukan sifar; Jika tidak, periksa semula; Diberikan matriks mat [] []; Panggilan fungsi", "code": "function checkRearrangements ( mat , N , M ) { for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ 0 ] != mat [ i ] [ j ] ) { return \" \" ; } } } return \" \" ; } function nonZeroXor ( mat , N , M ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { res = res ^ mat [ i ] [ 0 ] ; } if ( res != 0 ) return \" \" ; else return checkRearrangements ( mat , N , M ) ; } let mat = [ [ 1 , 1 , 2 ] , [ 2 , 2 , 2 ] , [ 3 , 3 , 3 ] ] ; let N = mat . length ; let M = mat [ 0 ] . length ; document . write ( nonZeroXor ( mat , N , M ) ) ;"}
{"text": "Memaksimumkan bitwise dan elemen pertama dengan pelengkap elemen yang tinggal untuk sebarang permutasi array yang diberikan | Program JavaScript untuk melaksanakan pendekatan di atas; Fungsi untuk memaksimumkan nilai untuk fungsi yang diberikan dan elemen array; Arahan vektor untuk mengekalkan bit mana yang ditetapkan untuk integer dalam array yang diberikan dengan menyimpan indeks integer itu; Semak jika b - th bit ditetapkan untuk integer i - th; Tolak indeks integer itu dalam setbit [j]; Cari elemen yang mempunyai bit set signifikan tertinggi dalam unsur -unsur lain; Letakkan integer itu pada indeks 0 - th; Simpan maksimum dan nilai; Kembalikan jawapannya; Kod pemacu; Panggilan fungsi", "code": "var size_int = 32 ; function functionMax ( arr , n ) { var setBit = Array . from ( Array ( 32 ) , ( ) => new Array ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < size_int ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) setBit [ j ] . push ( i ) ; } } for ( var i = size_int - 1 ; i >= 0 ; i -- ) { if ( setBit [ i ] . length == 1 ) { [ arr [ 0 ] , arr [ setBit [ i ] [ 0 ] ] ] = [ arr [ setBit [ i ] [ 0 ] ] , arr [ 0 ] ] ; break ; } } var maxAnd = arr [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; } var arr = [ 1 , 2 , 4 , 8 , 16 ] ; var n = arr . length ; document . write ( functionMax ( arr , n ) ) ;"}
{"text": "Jumlah semua produk koefisien binomial dua nombor sehingga k | Fungsi mengembalikan NCR i. e. Pekali binomial; Memulakan res dengan 1; Kerana c (n, r) = c (n, n - r); Menilai ungkapan; Berfungsi untuk mengira dan mengembalikan jumlah produk; Memulakan jumlah hingga 0; Melintasi 0 hingga k; Kod pemacu", "code": "function nCr ( n , r ) { let res = 1 ; if ( r > n - r ) r = n - r ; for ( let i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } function solve ( n , m , k ) { let sum = 0 ; for ( let i = 0 ; i <= k ; i ++ ) sum += nCr ( n , i ) * nCr ( m , k - i ) ; return sum ; } let n = 3 , m = 2 , k = 2 ; document . write ( solve ( n , m , k ) ) ;"}
{"text": "Exponention Cepat Menggunakan Manipulasi Bit | Berfungsi untuk mengembalikan A ^ n; Kedai Jawapan Akhir; Semak jika LSB semasa ditetapkan; Peralihan kanan; Kod pemacu", "code": "function powerOptimised ( a , n ) { let ans = 1 ; while ( n > 0 ) { let last_bit = ( n & 1 ) ; if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; } let a = 3 , n = 5 ; document . write ( powerOptimised ( a , n ) ) ;"}
{"text": "Cari M sedemikian rupa sehingga GCD M dan Nombor N adalah maksimum | Berfungsi untuk mencari integer m sedemikian rupa sehingga GCD (n, m) adalah maksimum; Memulakan pembolehubah; Cari semua pembahagi N dan kembalikan pembahagi maksimum; Semak jika saya boleh dibahagikan dengan n; Kemas kini max_gcd; Mengembalikan nilai maksimum; Nombor yang diberikan; Panggilan fungsi", "code": "function findMaximumGcd ( n ) { let max_gcd = 1 ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; } let N = 10 ; document . write ( findMaximumGcd ( N ) ) ;"}
{"text": "Elemen pertama setiap set K mempunyai unsur berturut -turut dengan faktor -faktor utama yang kurang daripada n | Program JavaScript untuk pendekatan di atas; Untuk menyimpan faktor utama terkecil; Fungsi membina pelbagai faktor utama terkecil; Tandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri. ; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Semak jika saya adalah Perdana; Mark SPF untuk semua nombor yang boleh dibahagikan oleh i; Mark SPF [J] jika ia tidak ditandakan sebelum ini; Fungsi untuk jumlah jumlah faktor utama; Fungsi untuk mencetak unsur -unsur set un elemen berturut -turut yang mempunyai faktor utama; Untuk menyimpan hasilnya; Mengira bilangan faktor utama nombor; Jika nombor mempunyai faktor yang betul -betul mendorong hasil []; Melangkah sehingga kita mendapat unsur -unsur berturut -turut dalam hasil []; Mengira urutan sehingga k; Cetak elemen jika Count> = k; Untuk membina SPF []; Diberikan n dan k; Panggilan fungsi", "code": "let x = 2000021 let v = new Array ( x ) ; function sieve ( ) { v [ 1 ] = 1 ; for ( let i = 2 ; i < x ; i ++ ) v [ i ] = i ; for ( let i = 4 ; i < x ; i += 2 ) v [ i ] = 2 ; for ( let i = 3 ; i * i < x ; i ++ ) { if ( v [ i ] == i ) { for ( let j = i * i ; j < x ; j += i ) { if ( v [ j ] == j ) { v [ j ] = i ; } } } } } function prime_factors ( n ) { let s = new Set ( ) ; while ( n != 1 ) { s . add ( v [ n ] ) ; n = n / v [ n ] ; } return s . size ; } function distinctPrimes ( m , k ) { let result = new Array ( ) ; for ( let i = 14 ; i < m + k ; i ++ ) { let count = prime_factors ( i ) ; if ( count == k ) { result . push ( i ) ; } } let p = result . length ; for ( let index = 0 ; index < p - 1 ; index ++ ) { let element = result [ index ] ; let count = 1 , z = index ; while ( z < p - 1 && count <= k && result [ z ] + 1 == result [ z + 1 ] ) { count ++ ; z ++ ; } if ( count >= k ) document . write ( element + ' ' ) ; } } sieve ( ) ; let N = 1000 , K = 3 ; distinctPrimes ( N , K ) ;"}
{"text": "Produk nombor kompleks menggunakan tiga operasi pendaraban | Berfungsi untuk membiak nombor kompleks dengan hanya tiga pendaraban; Cari nilai prod1, prod2 dan prod3; Bahagian sebenar; Bahagian khayalan; Cetak hasilnya; Kod pemacu; Diberi empat nombor; Panggilan fungsi", "code": "function print_product ( a , b , c , d ) { let prod1 = a * c ; let prod2 = b * d ; let prod3 = ( a + b ) * ( c + d ) ; let real = prod1 - prod2 ; let imag = prod3 - ( prod1 + prod2 ) ; document . write ( real + \" \" + imag + \" \" ) ; } let a , b , c , d ; a = 2 ; b = 3 ; c = 4 ; d = 5 ; print_product ( a , b , c , d ) ;"}
{"text": "Nombor Insolite | Fungsi untuk memeriksa sama ada nombor adalah nombor insolit; Untuk menyimpan jumlah kuadrat digit; Untuk menyimpan produk dataran digit; mengekstrak digit; Kod pemacu; Panggilan fungsi", "code": "function isInsolite ( n ) { let N = n ; let sum = 0 ; let product = 1 ; while ( n != 0 ) { let r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = parseInt ( n / 10 ) ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; } let N = 111 ; if ( isInsolite ( N ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Nombor Superabundant | Fungsi untuk mengira jumlah semua pembahagi nombor tertentu; Jumlah pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'n'; Jika kedua -dua pembahagi adalah sama maka tambahkannya sekali lagi tambah kedua -duanya; Tambah 1 dan N untuk menghasilkan seperti gelung di atas menganggap pembahagi yang betul lebih besar daripada 1; Berfungsi untuk memeriksa sama ada n adalah nombor superbundant; untuk memeriksa semua nombor dari 1 hingga n; Kod pemacu", "code": "function sigma ( n ) { if ( n == 1 ) return 1 ; var result = 0 ; for ( var i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; } function isSuperabundant ( N ) { for ( var i = 1 ; i < N ; i ++ ) { var x = sigma ( i ) / i ; var y = sigma ( N ) / ( N * 1.0 ) ; if ( x > y ) return false ; } return true ; } var N = 4 ; isSuperabundant ( N ) ? document . write ( \" \" ) : document . write ( \" \" ) ;"}
{"text": "D Nombor | Berfungsi untuk mencari nombor N - th icosikaipentagon; Nombor hendaklah lebih besar daripada 3; Semak setiap k dalam julat 2 hingga n - 1; Keadaan untuk nombor D; Kod pemacu", "code": "function isDNum ( n ) { if ( n < 4 ) return false ; let numerator = 0 , hcf = 0 ; for ( k = 2 ; k <= n ; k ++ ) { numerator = parseInt ( ( Math . pow ( k , n - 2 ) - k ) ) ; hcf = __gcd ( n , k ) ; } if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; } function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } let n = 15 ; let a = isDNum ( n ) ; if ( a ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Ruth | Berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Berfungsi untuk memeriksa nombor Ruth - Aaron; Kod pemacu", "code": "function Sum ( N ) { let SumOfPrimeDivisors = Array ( N + 1 ) . fill ( 0 ) ; for ( let i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 1 ) { for ( let j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } function RuthAaronNumber ( n ) { if ( Sum ( n ) == Sum ( n + 1 ) ) return true ; else return false ; } let N = 714 ; if ( RuthAaronNumber ( N ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Memaksimumkan jumlah perbezaan mutlak antara unsur -unsur bersebelahan dalam array dengan jumlah k | Fungsi untuk memaksimumkan jumlah; Perbezaan adalah 0 apabila hanya satu elemen yang terdapat dalam array; Perbezaan adalah k apabila dua elemen hadir dalam pelbagai; Jika tidak; Kod pemacu", "code": "function maxAdjacentDifference ( N , K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; } let N = 6 ; let K = 11 ; document . write ( maxAdjacentDifference ( N , K ) ) ;"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | Tetapkan 2 | Program JavaScript untuk pendekatan di atas; Fungsi mengembalikan jumlah nombor dari 1 hingga n; Fungsi mengembalikan jumlah nombor dari A + 1 hingga B; Fungsi mengembalikan jumlah jumlah pembahagi; Kedai Jumlah Jumlah; Mencari nombor dan kejadiannya; Jumlah produk setiap nombor dan kejadiannya; Kod pemacu", "code": "let mod = 1000000007 ; function linearSum ( n ) { return ( n * ( n + 1 ) / 2 ) % mod ; } function rangeSum ( b , a ) { return ( linearSum ( b ) - linearSum ( a ) ) % mod ; } function totalSum ( n ) { let result = 0 ; let i = 1 ; while ( true ) { result += rangeSum ( Math . floor ( n / i ) , Math . floor ( n / ( i + 1 ) ) ) * ( i % mod ) % mod ; result %= mod ; if ( i == n ) break ; i = Math . floor ( n / ( n / ( i + 1 ) ) ) ; } return result ; } let N = 4 ; document . write ( totalSum ( N ) + \" \" ) ; N = 12 ; document . write ( totalSum ( N ) ) ;"}
{"text": "Nombor undulant nontrivial | Fungsi untuk memeriksa sama ada rentetan adalah rentetan ganda atau tidak; A dan B tidak sepatutnya sama; Keadaan untuk memeriksa sama ada panjang ganjil membuat panjang walaupun; Separuh pertama s; Separuh kedua s; Rentetan double jika separuh pertama dan terakhir adalah sama; Fungsi untuk memeriksa sama ada n adalah nombor undulant yang tidak dapat dipulihkan; Kod pemacu", "code": "function isDouble ( num ) { let s = num . toString ( ) ; let l = s . length ; if ( s [ 0 ] == s . charAt [ 1 ] ) return false ; if ( l % 2 == 1 ) { s = s + s [ 1 ] ; l ++ ; } let s1 = s . substr ( 0 , l / 2 ) ; let s2 = s . substr ( l / 2 ) ; return ( s1 == s2 ) ; } function isNontrivialUndulant ( N ) { return N > 100 && isDouble ( N ) ; } let n = 121 ; if ( isNontrivialUndulant ( n ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Nombor Megagon | Berfungsi untuk mencari nombor megagon nth; Kod pemacu", "code": "function MegagonNum ( n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; } var n = 3 ; document . write ( MegagonNum ( n ) ) ;"}
{"text": "Produk semua pasangan dari array yang diberikan | Pelaksanaan JavaScript untuk mencari produk semua pasangan dari array yang diberikan; Berfungsi untuk mengembalikan produk unsur -unsur semua pasangan yang mungkin dari array; Untuk menyimpan produk yang diperlukan; Gelung bersarang untuk mengira semua pasangan yang mungkin; Melipatgandakan produk unsur -unsur pasangan semasa; Mengembalikan hasil akhir; Kod pemacu", "code": "mod = 1000000007 function productPairs ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; } let arr = [ 1 , 2 , 3 ] ; let n = arr . length ; document . write ( productPairs ( arr , n ) ) ;"}
{"text": "Produk semua pasangan dari array yang diberikan | Pelaksanaan JavaScript untuk mencari produk semua pasangan dari array yang diberikan; Fungsi untuk mengira (x ^ y) % 1000000007; Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; Mengembalikan hasil akhir; Berfungsi untuk mengembalikan produk unsur -unsur semua pasangan yang mungkin dari array; Untuk menyimpan produk yang diperlukan; Berulang untuk setiap elemen array; Setiap elemen muncul (2 * n) kali; Kod pemacu", "code": "let mod = 1000000007 ; function power ( x , y ) { let p = 1000000007 ; let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } function productPairs ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { product = ( product % mod * power ( arr [ i ] , ( 2 * n ) ) % mod ) % mod ; } return product % mod ; } let arr = [ 1 , 2 , 3 ] ; let n = arr . length ; document . write ( productPairs ( arr , n ) ) ;"}
{"text": "Membina array sedemikian rupa sehingga jumlah kiub semua elemen adalah persegi yang sempurna | Berfungsi untuk membuat dan mencetak array; memulakan pelbagai saiz n; Cetak array; Kod pemacu", "code": "function constructArray ( N ) { let arr = new Array ( N ) ; for ( let i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; } } let N = 6 ; constructArray ( N ) ;"}
{"text": "Kira semua seterusnya yang produknya adalah nombor komposit | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Berfungsi untuk mencari bilangan berikutnya yang produknya adalah nombor komposit; Cari jumlah berikutnya yang tidak kosong; Cari kiraan nombor utama dan yang; Kirakan yang tidak kosong; Cari kiraan seterusnya komposit; Kod pemacu", "code": "function isPrime ( n ) { if ( n <= 1 ) return false ; for ( var i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } function countSubsequences ( arr , n ) { var totalSubsequence = Math . pow ( 2 , n ) - 1 ; var countPrime = 0 , countOnes = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) countOnes ++ ; else if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } var compositeSubsequence ; var onesSequence = Math . pow ( 2 , countOnes ) - 1 ; compositeSubsequence = totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ; return compositeSubsequence ; } var arr = [ 2 , 1 , 2 ] ; var n = arr . length ; document . write ( countSubsequences ( arr , n ) ) ;"}
{"text": "Cari integer berturut -turut seperti jumlah mereka adalah n | Fungsi untuk memeriksa sama ada nombor boleh dinyatakan sebagai jumlah K berturut -turut; Mencari istilah pertama AP; Memeriksa jika istilah pertama adalah integer; Gelung ke prvar integer berturut -turut K; Kod pemacu", "code": "function checksum ( n , k ) { var first_term = ( ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ) ; if ( first_term - parseInt ( ( first_term ) ) == 0 ) { for ( i = parseInt ( first_term ) ; i <= first_term + k - 1 ; i ++ ) { document . write ( i + \" \" ) ; } } else document . write ( \" \" ) ; } var n = 33 , k = 6 ; checksum ( n , k ) ;"}
{"text": "Mewakili n sebagai jumlah k angka bahu | Berfungsi untuk memperlihatkan perwakilan; N mestilah lebih besar daripada sama dengan 2 * k dan mestilah bahkan; Kod pemacu", "code": "function sumEvenNumbers ( N , K ) { let check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( let i = 0 ; i < K - 1 ; i ++ ) { document . write ( \" \" ) ; } document . write ( check ) ; } else { document . write ( \" \" ) ; } } let N = 8 ; let K = 2 ; sumEvenNumbers ( N , K ) ;"}
{"text": "Count of Subarrays Bersebelahan mungkin untuk setiap indeks dengan memasukkan elemen pada indeks itu | Berfungsi untuk mencari bilangan subarray termasuk elemen pada setiap indeks array; Mewujudkan pelbagai saiz n; Gelung itu berulang sehingga separuh panjang array; Keadaan untuk mengelakkan menimpa elemen pertengahan untuk array dengan panjangnya. ; Pengkomputeran bilangan subarray; Unsur ITH dari awal dan berakhir mempunyai bilangan subarray yang sama; Berfungsi untuk prlet vektor; Kod pemacu", "code": "function calculateWays ( n ) { let x = 0 ; let v = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) v [ i ] = 0 ; for ( let i = 0 ; i < n / 2 ; i ++ ) { if ( n % 2 == 0 && i == n / 2 ) break ; x = n * ( i + 1 ) - ( i + 1 ) * i ; v [ i ] = x ; v [ n - i - 1 ] = x ; } return v ; } function prletArray ( v ) { for ( let i = 0 ; i < v . length ; i ++ ) document . write ( v [ i ] + \" \" ) ; } let v ; v = calculateWays ( 4 ) ; prletArray ( v ) ;"}
{"text": "Nombor terkecil lebih besar daripada atau sama dengan x yang jumlah digitnya boleh dibahagikan dengan y | Program JavaScript untuk mencari bilangan terkecil yang lebih besar daripada atau sama dengan x dan dibahagikan dengan y; Fungsi yang mengembalikan jumlah digit nombor; Memulakan pembolehubah untuk menyimpan jumlah; Tambah digit terakhir nombor; Keluarkan digit terakhir dari nombor; Fungsi yang mengembalikan bilangan terkecil lebih besar daripada atau sama dengan x dan dibahagikan dengan y; Memulakan pemboleh ubah hasil; Gelung melalui nombor yang lebih besar daripada sama dengan x; Hitung jumlah digit; Semak sama ada jumlah digit boleh dibahagikan dengan y; Kod pemacu", "code": "var MAXN = 10000000 ; function sumOfDigits ( n ) { var sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n = parseInt ( n / 10 ) ; } return sum ; } function smallestNum ( X , Y ) { var res = - 1 ; for ( i = X ; i < MAXN ; i ++ ) { var sum_of_digit = sumOfDigits ( i ) ; if ( sum_of_digit % Y == 0 ) { res = i ; break ; } } return res ; } var X = 5923 , Y = 13 ; document . write ( smallestNum ( X , Y ) ) ;"}
{"text": "Kira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan | Fungsi untuk mengira nombor yang boleh menukar n ke 1 menggunakan operasi yang diberikan; Simpan semua pembahagi n; Jika saya seorang pembahagi; Jika saya tidak sama dengan N / I; Melangkah melalui semua pembahagi n - 1 dan mengira mereka sebagai jawapan; Semak jika N - 1 adalah pembahagi atau tidak; Melangkah melalui semua pembahagi dan semak n Mod D = 1 atau (n - 1) mod d = 0; Kod pemacu", "code": "function countValues ( N ) { var div = [ ] ; for ( var i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . push ( i ) ; if ( N != i * i ) { div . push ( N / i ) ; } } } var answer = 0 ; for ( var i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } div . forEach ( d => { var K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } ) ; return answer ; } var N = 6 ; document . write ( countValues ( N ) ) ;"}
{"text": "Maksimum mungkin pembahagi utama yang boleh wujud dalam nombor yang mempunyai tepat n pembahagi | Berfungsi untuk mencari pembahagi utama maksimum nombor yang boleh dimiliki dengan pembahagi N; Bilangan bilangan masa dibahagikan dengan 2; Membahagikan dengan nombor perdana lain; Jika bilangan terakhir juga perdana maka juga memasukkannya; Kod pemacu; Panggilan fungsi", "code": "function findMaxPrimeDivisor ( n ) { let max_possible_prime = 0 ; while ( n % 2 == 0 ) { max_possible_prime ++ ; n = Math . floor ( n / 2 ) ; } for ( let i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { max_possible_prime ++ ; n = Math . floor ( n / i ) ; } } if ( n > 2 ) { max_possible_prime ++ ; } document . write ( max_possible_prime + \" \" ) ; } let n = 4 ; findMaxPrimeDivisor ( n ) ;"}
{"text": "Kira cara untuk menyatakan nombor sebagai jumlah tepat dua nombor | Fungsi Mengembalikan kiraan cara menyatakan nombor sebagai jumlah dua nombor. ; Kod pemacu", "code": "function CountWays ( n ) { let ans = Math . floor ( ( n - 1 ) / 2 ) ; return ans ; } let N = 8 ; document . write ( CountWays ( N ) ) ;"}
{"text": "Bahagikan array dalam dua tatasusunan panjang maksimum yang sama dengan unsur -unsur yang serupa dan berbeza | Berfungsi untuk mencari saiz maksimum yang mana array boleh dibahagikan kepada Leto 2 bahagian yang sama; Array untuk mencari kekerapan setiap elemen array; Cari elemen frekuensi maksimum indeks yang terdapat dalam array arr []; Cari jumlah elemen unik yang terdapat dalam array arr []; Cari saiz maksimum yang mana array arr [] boleh dibuang; Cari array pertama yang mengandungi elemen yang sama; Cari array kedua yang mengandungi unsur -unsur yang unik; permulaan n; perisytiharan array; saiz array", "code": "function Solve ( arr , size , n ) { let v = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ; let max1 = - 1 , mx = - 1 ; for ( let i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] > mx ) { mx = v [ i ] ; max1 = i ; } } let cnt = 0 ; for ( let i in v ) { if ( i == 0 ) ++ cnt ; } let diff1 = n + 1 - cnt ; let max_size = Math . max ( Math . min ( v [ max1 ] - 1 , diff1 ) , Math . min ( v [ max1 ] , diff1 - 1 ) ) ; document . write ( \" \" + max_size + \" \" ) ; document . write ( \" \" + \" \" ) ; for ( let i = 0 ; i < max_size ; i ++ ) { document . write ( max1 + \" \" ) ; v [ max1 ] -= 1 ; } document . write ( \" \" ) ; document . write ( \" \" + \" \" ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { document . write ( i + \" \" ) ; max_size -- ; } if ( max_size < 1 ) break ; } document . write ( \" \" ) ; } let n = 7 ; let arr = [ 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 ] ; let size = arr . length ; Solve ( arr , size , n ) ;"}
{"text": "Cari Jumlah Xor semua tiga kali ganda yang tidak teratur dari array | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y >> 1; y = y / 2; Mengembalikan n ^ ( - 1) mod p; Mengembalikan NCR % P menggunakan teorem kecil Fermat. ; Kes asas; Isi pelbagai faktorial supaya kita dapat mencari semua faktorial r, n dan n - r; Fungsi mengembalikan jumlah XOR dari semua triplet yang tidak teratur dari array; Melangkah ke atas bit; Bilangan elemen yang masing -masing 1 dan 0; Memeriksa jika k 'th bit adalah 1; Menambah bahagian bit ini kepada jawapannya; Kod pemacu", "code": "function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function modInverse ( n , p ) { return power ( n , p - 2 , p ) ; } function nCrModPFermat ( n , r , p ) { if ( r == 0 ) return 1 ; if ( n < r ) return 0 ; let fac = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; fac [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; } function SumOfXor ( a , n ) { let mod = 10037 ; let answer = 0 ; for ( let k = 0 ; k < 32 ; k ++ ) { let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & ( 1 << k ) ) != 0 ) x ++ ; else y ++ ; } answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod ; } return answer ; } let n = 5 ; let A = [ 3 , 5 , 2 , 18 , 7 ] ; document . write ( SumOfXor ( A , n ) ) ;"}
{"text": "Kebarangkalian tidak mendapat dua kepala berturut -turut bersama -sama di N melemparkan duit syiling | Pelaksanaan JavaScript untuk mencari kebarangkalian tidak mendapat dua kepala berturut -turut bersama apabila duit syiling N dibuang; Fungsi untuk mengira nombor Fibonacci N - Th dalam urutan di mana A = 2 dan B = 3; Dua nombor pertama dalam urutan dimulakan; Kes asas; Gelung untuk mengira urutan Fibonacci berdasarkan dua nombor pertama yang diasaskan; Fungsi untuk mencari kebarangkalian tidak mendapat dua kepala berturut -turut apabila duit syiling N dibuang; Mengira bilangan kes yang menggalakkan; Pengkomputeran bilangan semua hasil yang mungkin untuk N TOSses; Kod pemacu", "code": "function round ( vr , digit ) { var value = parseInt ( ( vr * Math . pow ( 10 , digit ) + .5 ) ) ; return value / Math . pow ( 10 , digit ) ; } function probability ( N ) { var a = 2 ; var b = 3 ; if ( N == 1 ) { return a ; } else if ( N == 2 ) { return b ; } else { for ( i = 3 ; i <= N ; i ++ ) { var c = a + b ; a = b ; b = c ; } return b ; } } function operations ( N ) { var x = probability ( N ) ; var y = parseInt ( Math . pow ( 2 , N ) ) ; return round ( x / y , 2 ) ; } var N = 10 ; document . write ( ( operations ( N ) ) ) ;"}
{"text": "Semak jika nombor dibentuk dengan menyertai dua nombor adalah Cube Perfect | Berfungsi untuk memeriksa sama ada nombor adalah kiub yang sempurna atau tidak; Fungsi untuk memeriksa sama ada penggabungan dua nombor adalah kiub yang sempurna atau tidak; Menukar nombor ke rentetan menggunakan to_string (); Menggabungkan nombor dan menukarnya menjadi integer; Semak jika nilai yang disatukan adalah kiub sempurna atau tidak; Kod pemacu", "code": "function isPerfectCube ( x ) { var cr = Math . round ( Math . cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; } function checkCube ( a , b ) { s1 = a . toString ( ) ; s2 = b . toString ( ) ; var c = parseInt ( s1 + s2 ) ; if ( isPerfectCube ( c ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } var a = 6 ; var b = 4 ; checkCube ( a , b ) ;"}
{"text": "Nombor terbesar dalam array yang dibentuk dengan berulang kali menggabungkan dua elemen yang sama | Berfungsi untuk mengembalikan jumlah terbesar; Pembolehubah untuk menyimpan jumlah terbesar; Peta untuk menyimpan frekuensi setiap elemen; Menyimpan frekuensi; Gelung untuk menggabungkan elemen pendua dan mengemas kini jumlah dalam peta; Jika J adalah elemen pendua; Kemas kini kekerapan 2 * j; Jika jumlah baru lebih besar daripada nilai maksimum, kemas kini maksimum; Mengembalikan jumlah terbesar; Kod pemacu; Fungsi panggilan", "code": "function largest_sum ( arr , n ) { let maximum = - 1 ; let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( m . has ( arr [ i ] ) ) { m . set ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . set ( arr [ i ] , 1 ) ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( m . get ( arr [ i ] ) > 1 ) { if ( m . has ( 2 * arr [ i ] ) ) { m . set ( 2 * arr [ i ] , m . get ( 2 * arr [ i ] ) + m . get ( arr [ i ] ) / 2 ) ; } else { m . set ( 2 * arr [ i ] , m . get ( arr [ i ] ) / 2 ) ; } if ( 2 * arr [ i ] > maximum ) maximum = 2 * arr [ i ] ; } } return maximum ; } let arr = [ 1 , 1 , 2 , 4 , 7 , 8 ] ; let n = arr . length ; document . write ( largest_sum ( arr , n ) ) ;"}
{"text": "Semak sama ada mungkin untuk membuat X dan Y Zero pada masa yang sama dengan Operasi yang diberikan | Fungsi untuk memeriksa sama ada mungkin untuk membuat X dan Y boleh menjadi 0 pada masa yang sama; Semak syarat yang diberikan; Kod pemacu; Panggilan fungsi", "code": "function canBeReduced ( x , y ) { var maxi = Math . max ( x , y ) ; var mini = Math . min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ; } var x = 6 , y = 9 ; canBeReduced ( x , y ) ;"}
{"text": "Algoritma Pemfaktoran Roda | Fungsi untuk memeriksa sama ada nombor x yang diberikan adalah perdana atau tidak; Roda untuk memeriksa nombor perdana; Kes asas; Semak nombor yang diambil sebagai asas; Semak roda di sini saya, bertindak sebagai lapisan roda; Semak senarai penapis dalam arr []; Jika nombor lebih besar daripada rehat Sqrt (n); Semak jika n adalah pelbagai nombor utama di roda; Jika di mana -mana lelaran isprime adalah palsu, pecah dari gelung; Kod pemandu; Fungsi panggilan untuk pemeriksaan primal", "code": "function isPrime ( N ) { let isPrime = true ; let arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; } for ( let i = 0 ; i < Math . sqrt ( N ) ; i += 30 ) { for ( let c of arr ) { if ( c > Math . sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let N = 121 ; isPrime ( N ) ;"}
{"text": "Cari semua pasangan yang mungkin dari array yang diberikan | Berfungsi untuk mencetak semua pasangan yang mungkin dari array; Gelung bersarang untuk semua pasangan yang mungkin; Kod pemacu", "code": "function printPairs ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { document . write ( \" \" + arr [ i ] + \" \" + arr [ j ] + \" \" + \" \" ) ; } } } var arr = [ 1 , 2 ] ; var n = arr . length ; printPairs ( arr , n ) ;"}
{"text": "Semak jika bulatan terletak di dalam bulatan lain atau tidak | Program JavaScript untuk memeriksa sama ada satu bulatan terletak di dalam bulatan lain atau tidak. ; Kod pemacu", "code": "function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { var distSq = parseInt ( Math . sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ) ; if ( distSq + r2 == r1 ) { document . write ( \" \" + \" \" + \" \" + \" \" ) ; } else if ( distSq + r2 < r1 ) { document . write ( \" \" + \" \" + \" \" + \" \" ) ; } else { document . write ( \" \" + \" \" ) ; } } var x1 = 10 , y1 = 8 ; var x2 = 1 , y2 = 2 ; var r1 = 30 , r2 = 10 ; circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ;"}
{"text": "Panjang tangen biasa langsung antara dua lingkaran bersilang | Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "function lengtang ( r1 , r2 , d ) { document . write ( \" \" + \" \" + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) . toFixed ( 5 ) ) ; } var r1 = 4 , r2 = 6 , d = 3 ; lengtang ( r1 , r2 , d ) ;"}
{"text": "Radius bulatan apabila lebar dan ketinggian arka diberikan | Berfungsi untuk mencari jejari; Kod pemacu", "code": "function rad ( d , h ) { document . write ( \" \" + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; } var d = 4 , h = 1 ; rad ( d , h ) ;"}
{"text": "Jarak terpendek dari pusat bulatan ke kord | Berfungsi untuk mencari jarak terpendek; Kod pemacu", "code": "function shortdis ( r , d ) { document . write ( \" \" + \" \" + Math . sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) + \" \" ) ; } let r = 4 , d = 3 ; shortdis ( r , d ) ;"}
{"text": "Panjang tangen biasa langsung antara kedua -dua bukan | Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "function lengtang ( r1 , r2 , d ) { document . write ( \" \" + Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ; } var r1 = 4 , r2 = 6 , d = 12 ; lengtang ( r1 , r2 , d ) ;"}
{"text": "Dataran terbesar yang boleh ditulis dalam segitiga sama rata | Berfungsi untuk mencari sisi dataran; Sisi tidak boleh negatif; sisi dataran; Kod pemacu", "code": "function square ( a ) { if ( a < 0 ) return - 1 ; var x = 0.464 * a ; return x ; } var a = 5 ; document . write ( square ( a ) . toFixed ( 2 ) ) ;"}
{"text": "Apothem A N | Berfungsi untuk mencari apothem poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah ditukar kepada radian; Kod pemacu", "code": "function polyapothem ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; } var a = 9 , n = 6 ; document . write ( polyapothem ( n , a ) . toFixed ( 5 ) ) ;"}
{"text": "Kawasan n | Berfungsi untuk mencari kawasan poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu", "code": "function polyarea ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; var A = ( a * a * n ) / ( 4 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; } var a = 9 , n = 6 ; document . write ( polyarea ( n , a ) . toFixed ( 5 ) ) ;"}
{"text": "Sisi biasa n | Fungsi untuk mengira sisi poligon yang dilampirkan dalam bulatan; Jumlah sisi poligon; Jejari lingkaran lingkungan", "code": "function calculateSide ( n , r ) { var theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * Math . sin ( theta_in_radians / 2 ) ; } var n = 3 ; var r = 5 ; document . write ( calculateSide ( n , r ) . toFixed ( 5 ) ) ;"}
{"text": "Silinder bulat kanan terbesar dalam frustum | Berfungsi untuk mencari silinder bulat kanan terbesar; Radii dan ketinggian tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "function cyl ( r , R , h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; var r1 = r ; var h1 = h ; var V = ( 3.14 * Math . pow ( r1 , 2 ) * h1 ) ; return V ; } var r = 7 , R = 11 , h = 6 ; document . write ( cyl ( r , R , h ) . toFixed ( 5 ) ) ;"}
{"text": "Program untuk mencari perimeter poligon biasa | Berfungsi untuk mengira perimeter; Hitung perimeter; Dapatkan bilangan sisi; Dapatkan panjang sisi; Cari perimeter", "code": "function Perimeter ( s , n ) { var perimeter = 1 ; perimeter = n * s ; return perimeter ; } var n = 5 ; var s = 2.5 , peri ; peri = Perimeter ( s , n ) ; document . write ( \" \" + \" \" + n + \" \" + s . toFixed ( 6 ) + \" \" + peri . toFixed ( 6 ) ) ;"}
{"text": "Kawasan rombang terbesar yang boleh ditulis dalam segi empat tepat | Berfungsi untuk mencari kawasan rombus terbesar; Panjang dan keluasan tidak boleh negatif; kawasan rhombus; Kod pemacu", "code": "function rhombusarea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; return ( l * b ) / 2 ; } var l = 16 , b = 6 ; document . write ( rhombusarea ( l , b ) ) ;"}
{"text": "Semak jika titik terletak di dalam segi empat tepat | Set | Fungsi untuk mencari jika titik diberikan terletak di dalam segi empat tepat atau tidak. ; bawah - kiri dan atas - sudut kanan segi empat tepat; titik yang diberikan; panggilan fungsi", "code": "function FindPoint ( x1 , y1 , x2 , y2 , x , y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; } let x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; let x = 1 , y = 5 ; if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Jarak antara satu titik dan satah dalam 3 D | Berfungsi untuk mencari jarak; kod pemacu; Panggilan fungsi", "code": "function shortest_distance ( x1 , y1 , z1 , a , b , c , d ) { d = Math . abs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; let e = Math . sqrt ( a * a + b * b + c * c ) ; document . write ( \" \" + ( d / e ) ) ; return ; } let x1 = 4 ; let y1 = - 4 ; let z1 = 3 ; let a = 2 ; let b = - 2 ; let c = 5 ; let d = 8 ; shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ;"}
{"text": "Program untuk mencari jumlah prisma segi tiga | berfungsi untuk mencari jumlah prisma segi tiga; formula untuk mencari kelantangan; Kod pemacu; fungsi panggilan", "code": "function findVolume ( l , b , h ) { let volume = ( l * b * h ) / 2 ; return volume ; } let l = 18 , b = 12 , h = 9 ; document . write ( \" \" + findVolume ( l , b , h ) ) ;"}
{"text": "Semak jika diberi empat bilangan bulat (atau sisi) membuat segi empat tepat | Fungsi untuk memeriksa sama ada nilai integer yang diberikan membuat segi empat tepat; Square juga merupakan segi empat tepat; Kod pemacu", "code": "function isRectangle ( a , b , c , d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } let a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Program untuk mencari pertengahan | berfungsi untuk mencari titik tengah garis; Kod pemacu", "code": "function midpoint ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + \" \" + ( y1 + y2 ) / 2 ) ; } let x1 = - 1 , y1 = 2 ; let x2 = 3 , y2 = - 6 ; midpoint ( x1 , x2 , y1 , y2 ) ;"}
{"text": "Panjang arka dari sudut yang diberikan | fungsi untuk mengira panjang arka; Kod pemacu", "code": "function arcLength ( diameter , angle ) { let pi = 22.0 / 7.0 ; let arc ; if ( angle >= 360 ) { document . write ( \" \" + \" \" ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } } let diameter = 25.0 ; let angle = 45.0 ; let arc_len = arcLength ( diameter , angle ) ; document . write ( arc_len ) ;"}
{"text": "Semak sama ada garis menyentuh atau memotong bulatan | Program JavaScript untuk memeriksa sama ada garis menyentuh atau bersilang atau di luar bulatan. ; Mencari jarak garis dari pusat. ; Memeriksa jika jarak kurang daripada, lebih besar daripada atau sama dengan radius. ; Kod pemacu", "code": "function checkCollision ( a , b , c , x , y , radius ) { let dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) document . write ( \" \" ) ; else if ( radius > dist ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let radius = 5 ; let x = 0 , y = 0 ; let a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ;"}
{"text": "Program untuk mencari kawasan segitiga | (X [i], y [i]) adalah koordinat titik saya. ; Memulakan kawasan; Hitung nilai formula kasut; j = i; J adalah puncak sebelumnya kepada i; Kembali nilai mutlak; Program pemacu untuk menguji fungsi di atas", "code": "function polygonArea ( X , Y , n ) { let area = 0.0 ; let j = n - 1 ; for ( let i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return Math . abs ( area / 2.0 ) ; } let X = [ 0 , 2 , 4 ] ; let Y = [ 1 , 3 , 7 ] ; let n = X . length ; document . write ( polygonArea ( X , Y , n ) ) ;"}
{"text": "Memaksimumkan jumlah LSB bitwise atau semua mungkin n / 2 pasang dari array yang diberikan | Fungsi atas mendapatkan nilai LSB V; Penukaran binari; Fungsi untuk mencari jumlah LSB semua pasangan yang mungkin dari array yang diberikan; Menyimpan elemen array LSB; Menyimpan nilai LSB; Susun array lab_arr []; Mengambil jumlah pasangan untuk mendapatkan jumlah maksimum LSB; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "const chk = ( n ) => { let v = [ ] ; while ( n != 0 ) { v . push ( n % 2 ) ; n = parseInt ( n / 2 ) ; } for ( let i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] == 1 ) { return Math . pow ( 2 , i ) ; } } return 0 ; } const sumOfLSB = ( arr , N ) => { let lsb_arr = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { lsb_arr . push ( chk ( arr [ i ] ) ) ; } lsb_arr . sort ( ( a , b ) => a - b ) let ans = 0 ; for ( let i = 0 ; i < N - 1 ; i += 2 ) { ans += ( lsb_arr [ i + 1 ] ) ; } document . write ( ans ) ; } let N = 5 ; let arr = [ 1 , 2 , 3 , 4 , 5 ] ; sumOfLSB ( arr , N ) ;"}
{"text": "Kira -kira berikutnya yang mempunyai bitwise dan nilai -nilai yang ganjil dalam array yang diberikan | Fungsi untuk mencari kiraan berikutnya yang mempunyai bitwise dan nilai ganjil; Kedai mengira unsur -unsur ganjil; Melintasi array arr []; Jika x adalah kiraan kenaikan ganjil; Jawapan kembali; Kod pemacu; Panggilan fungsi", "code": "function countSubsequences ( arr ) { let odd = 0 ; for ( let x = 0 ; x < arr . length ; x ++ ) { if ( arr [ x ] & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; } let arr = [ 1 , 3 , 3 ] ; document . write ( countSubsequences ( arr ) ) ;"}
{"text": "Kira pasangan dari array dengan perbezaan mutlak tidak kurang daripada elemen minimum dalam pasangan | Fungsi untuk mencari bilangan pasangan (i, j) seperti abs (a [i] - a [j]) sekurang -kurangnya minimum (a [i], a [j]); Menyimpan kiraan pasangan yang dihasilkan; Melangkah ke atas julat [0, n]; Berulang dari arr [i] - (i % arr [i]) hingga n dengan kenaikan arr [i]; Mengira pasangan yang mungkin; Mengembalikan jumlah jumlah; Kod pemacu", "code": "function getPairsCount ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && Math . abs ( arr [ i ] - arr [ j ] ) >= Math . min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; } let arr = [ 1 , 2 , 2 , 3 ] ; let N = arr . length ; document . write ( getPairsCount ( arr , N ) ) ;"}
{"text": "Langkah Minimum Untuk Menukar N hingga 1 dengan menukarnya menjadi 2 * n atau n / 10 pada mana -mana langkah | Fungsi untuk memeriksa sama ada n boleh diubah menjadi 1 atau tidak. ; Kira bilangan 2 dalam faktorisasi utama N; Mengira bilangan 5 dalam faktorisasi utama N; Kod pemacu", "code": "function check ( N ) { var twos = 0 , fives = 0 ; while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; } while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { document . write ( 2 * fives - twos ) ; } else { document . write ( - 1 ) ; } } var N = 50 ; check ( N ) ;"}
{"text": "Jumlah elemen dalam julat yang diberikan dari array yang dibentuk oleh array yang diberikan secara tidak terhingga | Berfungsi untuk mencari jumlah elemen dalam pelbagai array tak terhingga; Menyimpan jumlah elemen array dari L ke R; Melintasi L ke R; Cetak jumlah yang dihasilkan; Kod pemacu", "code": "function rangeSum ( arr , N , L , R ) { let sum = 0 ; for ( let i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } document . write ( sum ) ; } let arr = [ 5 , 2 , 6 , 9 ] ; let L = 10 , R = 13 ; let N = arr . length rangeSum ( arr , N , L , R ) ;"}
{"text": "Jumlah elemen dalam julat yang diberikan dari array yang dibentuk oleh array yang diberikan secara tidak terhingga | Berfungsi untuk mencari jumlah elemen dalam pelbagai array tak terhingga; Menyimpan jumlah awalan; Kirakan jumlah awalan; Menyimpan jumlah elemen dari 1 hingga l - 1; Menyimpan jumlah elemen dari 1 hingga R; Cetak jumlah yang dihasilkan; Kod pemacu", "code": "function rangeSum ( arr , N , L , R ) { let prefix = new Array ( N + 1 ) ; prefix [ 0 ] = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } let leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; let rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; document . write ( rightsum - leftsum ) ; } let arr = [ 5 , 2 , 6 , 9 ] ; let L = 10 , R = 13 ; let N = arr . length ; rangeSum ( arr , N , L , R ) ;"}
{"text": "Faktorial eksponen n | Berfungsi untuk mencari faktorial eksponen nombor tertentu; Menyimpan faktor exponetial N; Iterare ke atas julat [2, n]; Kemas kini res; Kembali res; Input; Panggilan fungsi", "code": "function ExpoFactorial ( N ) { let res = 1 ; let mod = 1000000007 ; for ( let i = 2 ; i < N + 1 ; i ++ ) res = Math . pow ( i , res ) % mod ; return res ; } let N = 4 ; document . write ( ( ExpoFactorial ( N ) ) ) ;"}
{"text": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | Set | Fungsi untuk mencari subarray bersebelahan dengan jumlah maksimum jika array diulang kali k; Simpan jumlah array arr []; Melintasi array dan cari jumlah; Simpan jawapannya; Jika k = 1; Memohon algoritma Kadane untuk mencari jumlah; Kembalikan jawapannya; Menyimpan array dua kali berulang; Melintasi julat [0, 2 * n]; Menyimpan jumlah akhiran maksimum; Menyimpan jumlah awalan maksimum; Memohon algoritma Kadane untuk 2 pengulangan array; Jika jumlah array lebih besar daripada 0; Kembalikan jawapannya; Diberikan input; Panggilan fungsi", "code": "function maxSubArraySumRepeated ( arr , N , K ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; let curr = arr [ 0 ] ; let ans = arr [ 0 ] ; if ( K == 1 ) { for ( let i = 1 ; i < N ; i ++ ) { curr = Math . max ( arr [ i ] , curr + arr [ i ] ) ; ans = Math . max ( ans , curr ) ; } return ans ; } let V = [ ] ; for ( let i = 0 ; i < 2 * N ; i ++ ) { V . push ( arr [ i % N ] ) ; } let maxSuf = V [ 0 ] ; let maxPref = V [ 2 * N - 1 ] ; curr = V [ 0 ] ; for ( let i = 1 ; i < 2 * N ; i ++ ) { curr += V [ i ] ; maxPref = Math . max ( maxPref , curr ) ; } curr = V [ 2 * N - 1 ] ; for ( let i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V [ i ] ; maxSuf = Math . max ( maxSuf , curr ) ; } curr = V [ 0 ] ; for ( let i = 1 ; i < 2 * N ; i ++ ) { curr = Math . max ( V [ i ] , curr + V [ i ] ) ; ans = Math . max ( ans , curr ) ; } if ( sum > 0 ) { let temp = sum * ( K - 2 ) ; ans = Math . max ( ans , Math . max ( temp + maxPref , temp + maxSuf ) ) ; } return ans ; } let arr = [ 10 , 20 , - 30 , - 1 , 40 ] ; let N = arr . length ; let K = 10 ; document . write ( maxSubArraySumRepeated ( arr , N , K ) ) ;"}
{"text": "Count of Subarrays Dengan Elemen Terbesar Sekurang -kurangnya dua kali ganda unsur -unsur terbesar | Fungsi untuk mencari kiraan subarray yang mempunyai elemen maksimum lebih besar daripada dua kali maksimum semua elemen lain; Menyimpan kiraan subarray; Menjana semua subarray yang mungkin; Menyimpan elemen maksimum subarray; Menyimpan maksimum semua elemen lain; Cari elemen maksimum dalam subarray [i, j]; Cari maksimum semua elemen lain; Jika maksimum subarray lebih besar daripada dua kali ganda maksimum elemen lain; Cetak nilai maksimum yang diperoleh; Kod pemacu", "code": "function countSubarray ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let mxSubarray = 0 ; let mxOther = 0 ; for ( let k = i ; k <= j ; k ++ ) { mxSubarray = Math . max ( mxSubarray , arr [ k ] ) ; } for ( let k = 0 ; k < i ; k ++ ) { mxOther = Math . max ( mxOther , arr [ k ] ) ; } for ( let k = j + 1 ; k < n ; k ++ ) { mxOther = Math . max ( mxOther , arr [ k ] ) ; } if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } } document . write ( count ) ; } let arr = [ 1 , 6 , 10 , 9 , 7 , 3 ] ; let N = arr . length ; countSubarray ( arr , N ) ;"}
{"text": "Count of Subarrays Dengan Elemen Terbesar Sekurang -kurangnya dua kali ganda unsur -unsur terbesar | Fungsi untuk mencari kiraan subarray yang mempunyai elemen maksimum lebih besar daripada dua kali maksimum semua elemen lain; Menyimpan elemen maksimum array; Melintasi array yang diberikan; Jika nilai 2 * arr [i] lebih besar daripada MX; Kemas kini nilai l dan keluar dari gelung; Jika nilai 2 * arr [i] lebih besar daripada Mx; Mengemas kini nilai r dan keluar dari gelung; Cetak jawapan terakhir; Kod pemacu", "code": "function countSubarray ( arr , n ) { var count = 0 , L = 0 , R = 0 ; var mx = Math . max . apply ( null , arr ) ; var i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * 2 > mx ) { L = i ; break ; } } for ( i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] * 2 > mx ) { R = i ; break ; } } document . write ( ( L + 1 ) * ( n - R ) ) ; } var arr = [ 1 , 6 , 10 , 9 , 7 , 3 ] var N = arr . length ; countSubarray ( arr , N ) ;"}
{"text": "Cari Nombor Perdana hanya kurang daripada dan hanya lebih besar setiap elemen array yang diberikan | Fungsi utiliti untuk memeriksa keunggulan nombor X dengan memeriksa sama ada X HAACCs apa -apa faktor selain daripada 1 dan sendiri. ; jika (x % i == 0) faktor yang dijumpai; Berfungsi untuk mencetak prima hanya kurang daripada dan hanya lebih besar daripada setiap elemen dalam array; Melintasi array; Traverse untuk mencari perdana kurang daripada [i]; Perdana hanya kurang daripada yang dijumpai; Melintasi untuk mencari perdana lebih besar daripada [i]; Perdana hanya lebih besar daripada yang dijumpai; Input; Panggilan fungsi", "code": "function isPrime ( X ) { for ( let i = 2 ; i * i <= X ; i ++ ) return false ; return true ; } function printPrimes ( A , N ) { for ( let i = 0 ; i < N ; i ++ ) { for ( let j = A [ i ] - 1 ; ; j -- ) { if ( isPrime ( j ) ) { document . write ( j + \" \" ) ; break ; } } for ( let j = A [ i ] + 1 ; ; j ++ ) { if ( isPrime ( j ) ) { document . write ( j + \" \" ) ; break ; } } document . write ( \" \" ) ; } } let A = [ 17 , 28 ] ; let N = A . length ; printPrimes ( A , N ) ;"}
{"text": "Elemen terkecil kth dalam array yang mengandungi [i] betul -betul b [i] kali | Fungsi untuk mencari elemen terkecil kth yang mengandungi [i] tepat b [i] kali; Melintasi array yang diberikan; Menyimpan kekerapan setiap elemen; Melintasi array yang diberikan; Memulakan pembolehubah untuk menyimpan jumlah awalan; Melangkah ke atas julat [0, M]; Jumlah kenaikan oleh freq [i]; Jika jumlah lebih besar daripada atau sama dengan k; Mengembalikan elemen semasa sebagai jawapan; Kembali - 1; Diberikan input; Panggilan fungsi", "code": "function KthSmallest ( A , B , N , K ) { let M = 0 ; for ( let i = 0 ; i < N ; i ++ ) { M = Math . max ( A [ i ] , M ) ; } let freq = Array . from ( { length : M + 1 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; } let sum = 0 ; for ( let i = 0 ; i <= M ; i ++ ) { sum += freq [ i ] ; if ( sum >= K ) { return i ; } } return - 1 ; } let A = [ 3 , 4 , 5 ] ; let B = [ 2 , 1 , 3 ] ; let N = A . length ; let K = 4 ; document . write ( KthSmallest ( A , B , N , K ) ) ;"}
{"text": "Bitwise atau bitwise dan semua subarrays array | Berfungsi untuk mencari bitwise atau bitwise dan semua subarrays; Menyimpan hasil yang diperlukan; Menjana semua subarray; Simpan elemen semasa; Cari bitwise atau; Mengemas kini hasilnya; Cetak hasilnya; Kod pemacu", "code": "function findbitwiseOR ( a , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( let j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } document . write ( res ) ; } let A = [ 1 , 2 , 3 ] ; let N = A . length ; findbitwiseOR ( A , N ) ;"}
{"text": "Bitwise atau bitwise dan semua subarrays array | Berfungsi untuk mencari bitwise atau bitwise dan semua subset berturut -turut dari array; Menyimpan hasil yang diperlukan; Melintasi array yang diberikan; Cetak hasilnya; Kod pemacu", "code": "function findbitwiseOR ( a , n ) { var res = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; document . write ( res ) ; } var A = [ 1 , 2 , 3 ] ; var N = A . length ; findbitwiseOR ( A , N ) ;"}
{"text": "Semak jika jumlah digit nombor melebihi produk digit nombor itu | Berfungsi untuk memeriksa sama ada jumlah digit N adalah lebih besar daripada produk digit N atau tidak; Menyimpan jumlah dan produk digit N; Menyimpan digit terakhir jika n; Kenaikan nilai sumofdigit; Mengemas kini prodofdigit; Bahagikan n oleh 10; Hasilnya; Kod pemacu", "code": "function check ( n ) { let sumOfDigit = 0 ; let prodOfDigit = 1 ; while ( n > 0 ) { let rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n = Math . floor ( n / 10 ) ; } if ( sumOfDigit > prodOfDigit ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let N = 1234 ; check ( N ) ;"}
{"text": "Cetak semua awalan yang berbeza dan ganjil bitwise xors pertama n Nombor semula jadi | Cetak semua awalan yang berbeza & ganjil bitwise xors dari 1 hingga n; Cetak nombor juga; Cetak nombor ganjil; Kod pemacu", "code": "function evenOddBitwiseXOR ( N ) { document . write ( \" \" + 0 + \" \" ) ; for ( let i = 4 ; i <= N ; i = i + 4 ) { document . write ( i + \" \" ) ; } document . write ( \" \" ) ; document . write ( \" \" + 1 + \" \" ) ; for ( let i = 4 ; i <= N ; i = i + 4 ) { document . write ( i - 1 + \" \" ) ; } if ( N % 4 == 2 ) document . write ( N + 1 ) ; else if ( N % 4 == 3 ) document . write ( N ) ; } let N = 6 ; evenOddBitwiseXOR ( N ) ;"}
{"text": "Permutasi terbesar lexicographically mungkin dengan swap yang lebih kecil daripada array yang diberikan | Berfungsi untuk permutasi terbesar lexicographic mungkin dengan swap yang lebih kecil daripada array yang diberikan; Cari indeks elemen pertama sedemikian rupa sehingga arr [i]> arr [i + 1]; Jika array disusun dalam peningkatan urutan; Cari indeks elemen pertama yang lebih kecil daripada arr [i]; Jika arr [j] = = arr [j - 1]; Pengurangan j; Swap elemen; Cetak array arr []; Kod pemacu", "code": "function findPermutation ( arr ) { let N = arr . length ; let i = N - 2 ; while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ; if ( i == - 1 ) { document . write ( \" \" ) ; return ; } let j = N - 1 ; while ( j > i && arr [ j ] >= arr [ i ] ) j -- ; while ( j > i && arr [ j ] == arr [ j - 1 ] ) { j -- ; } let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; for ( let it in arr ) { document . write ( arr [ it ] + \" \" ) ; } } let arr = [ 1 , 2 , 5 , 3 , 4 , 6 ] ; findPermutation ( arr ) ;"}
{"text": "Perbezaan mutlak antara kiraan ganjil dan juga faktor n | Berfungsi untuk mencari faktor utama terkecil dari semua nombor menggunakan ayak eratosthenes; Kedai sama ada nombor mana -mana atau tidak; Memulakan faktor terkecil sebagai 2 untuk semua nombor walaupun; Melangkah ke atas julat [3, n]; Sekiranya saya adalah perdana; Melepasi semua gandaan i; Saya adalah faktor utama terkecil i * j; Fungsi untuk mencari perbezaan mutlak antara kiraan ganjil dan juga faktor n; Menyimpan faktor utama terkecil i; Isi nilai dalam S [] menggunakan ayak eratosthenes; Menyimpan jumlah faktor dan jumlah faktor ganjil dan bahkan; Simpan faktor utama semasa nombor n; Simpan kuasa faktor utama semasa; Gelung manakala n lebih besar daripada 1; Jika n juga mempunyai faktor utama terkecil seperti Curr, maka kenaikan CNT oleh 1; Kemas kini hanya jumlah faktor jika curr adalah 2; Mengemas kini jumlah faktor dan jumlah faktor ganjil; Mengemas kini faktor utama semasa S [n] dan dikira sebagai 1; Kirakan bilangan faktor walaupun; Prlet perbezaan; Kod pemacu", "code": "function sieveOfEratosthenes ( N , s ) { let prime = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; for ( let i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( let i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( let j = i ; j * i <= N ; j += 2 ) { if ( ! prime [ i * j ] ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } function findDifference ( N ) { let s = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; sieveOfEratosthenes ( N , s ) ; let total = 1 , odd = 1 , even = 0 ; let curr = s [ N ] ; let cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } if ( curr == 2 ) { total = total * ( cnt + 1 ) ; } else { total = total * ( cnt + 1 ) ; odd = odd * ( cnt + 1 ) ; } curr = s [ N ] ; cnt = 1 ; } even = total - odd ; document . write ( Math . abs ( even - odd ) ) ; } let N = 12 ; findDifference ( N ) ;"}
{"text": "Kirakan median dari nilai min dan mod yang diberikan | Berfungsi untuk mencari median sekumpulan data dengan min dan mod yang diberikan; Kirakan median; Cetak median; Kod pemacu", "code": "function findMedian ( Mean , Mode ) { var Median = ( 2 * Mean + Mode ) / 3.0 ; document . write ( Median ) ; } var mode = 6 , mean = 3 ; findMedian ( mean , mode ) ;"}
{"text": "Program untuk mencari magnitud vektor | Berfungsi untuk mengira magnitud vektor 3 dimensi; Menyimpan jumlah kuadrat koordinat vektor; Mengembalikan magnitud; Kod pemacu", "code": "function vectorMagnitude ( x , y , z ) { var sum = x * x + y * y + z * z ; return Math . sqrt ( sum ) ; } var x = 1 ; var y = 2 ; var z = 3 ; document . write ( vectorMagnitude ( x , y , z ) ) ;"}
{"text": "Program untuk mencari produk nombor dengan nombor Mersenne | Berfungsi untuk mencari prodcut nombor Mersenne dengan nombor lain; Menyimpan kuasa 2 integer m + 1; Mengembalikan produk; Kod pemacu", "code": "function multiplyByMersenne ( N , M ) { let x = ( Math . log ( M + 1 ) / Math . log ( 2 ) ) ; return ( ( N << x ) - N ) ; } let N = 4 ; let M = 15 ; document . write ( multiplyByMersenne ( N , M ) ) ;"}
{"text": "Kuasa terdekat 2 dari dataran sempurna terdekat bukan | Berfungsi untuk mencari persegi yang paling dekat dengan Num; Kirakan akar kuadrat NUM; Kirakan persegi sempurna; Cari dataran sempurna terdekat; Berfungsi untuk mencari kuasa 2 yang paling dekat dengan nombor nombor; Hitung asas log 2 dari NUM; Kuasa tertinggi 2 iaitu <= num; Berfungsi untuk mencari persegi sempurna yang terdekat dan kuasa terdekat 2 dari setiap elemen array yang kejadiannya adalah 1; Kedai kekerapan elemen array; Melintasi array dan kemas kini kekerapan elemen array semasa; Melintasi peta freq; Jika kekerapan adalah 1; Cari persegi sempurna yang terdekat; Cetak kuasa terdekat 2; Sekiranya mana -mana tidak mengandungi unsur -unsur yang tidak berulang; Kod pemacu", "code": "function perfectSquare ( num ) { let sr = Math . floor ( Math . sqrt ( num ) ) ; let a = sr * sr ; let b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( num - a ) < ( b - num ) ) { return a ; } else { return b ; } } function powerOfTwo ( num ) { let lg = Math . floor ( Math . log2 ( num ) ) ; let p = Math . pow ( 2 , lg ) ; return p ; } function uniqueElement ( arr , N ) { let ans = true ; arr . reverse ( ) ; let freq = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) } else [ freq . set ( arr [ i ] , 1 ) ] } for ( let el of freq ) { if ( el [ 1 ] == 1 ) { ans = false ; let ps = perfectSquare ( el [ 0 ] ) ; document . write ( powerOfTwo ( ps ) + ' ' ) ; } } if ( ans ) document . write ( \" \" ) ; } let arr = [ 4 , 11 , 4 , 3 , 4 ] ; let N = arr . length ; uniqueElement ( arr , N ) ;"}
{"text": "Arahan partition menjadi dua subarray dengan setiap elemen di subarray kanan dengan ketat daripada setiap elemen di subarray kiri | Berfungsi untuk memisahkan array menjadi dua subarrays bukan kosong yang memenuhi syarat yang diberikan; Menyimpan array akhiran min; Menyimpan minimum akhiran; Melintasi array secara terbalik; Mengemas kini minimum; Simpan minimum; Menyimpan nilai maksimum awalan; Menyimpan indeks partition; Kemas kini Max; Jika max kurang daripada min [i + 1]; Simpan indeks partition; rehat; Jika Ind tidak - 1; Cetak subarray pertama; Cetak subarray kedua; Jika tidak; Kod pemacu", "code": "function partitionArray ( a , n ) { var min = Array ( n ) . fill ( 0 ) ; var mini = Number . MAX_VALUE ; for ( i = n - 1 ; i >= 0 ; i -- ) { mini = Math . min ( mini , a [ i ] ) ; min [ i ] = mini ; } var maxi = Number . MIN_VALUE ; var ind = - 1 ; for ( i = 0 ; i < n - 1 ; i ++ ) { maxi = Math . max ( maxi , a [ i ] ) ; if ( maxi < min [ i + 1 ] ) { ind = i ; break ; } } if ( ind != - 1 ) { for ( i = 0 ; i <= ind ; i ++ ) document . write ( a [ i ] + \" \" ) ; document . write ( \" \" ) ; for ( i = ind + 1 ; i < n ; i ++ ) document . write ( a [ i ] + \" \" ) ; } else document . write ( \" \" ) ; } var arr = [ 5 , 3 , 2 , 7 , 9 ] ; var N = arr . length ; partitionArray ( arr , N ) ;"}
{"text": "Semak sama ada nombor boleh diwakili sebagai jumlah integer positif k di mana sekurang -kurangnya k | Berfungsi untuk mengira semua faktor utama nombor tertentu; Kira bilangan 2 s yang membahagikan n; Oleh kerana N adalah ganjil pada ketika ini, langkau satu elemen; Walaupun saya membahagikan n, kiraan saya dan membahagikan n; Jika n adalah nombor perdana yang lebih besar daripada 2; Berfungsi untuk mencari jumlah nombor pertama N hampir utama; Simpan jumlah yang diperlukan; Tambah nombor ini jika ia memenuhi syarat; Kiraan kenaikan hampir nombor utama; Fungsi untuk memeriksa sama ada n boleh diwakili sebagai jumlah k antara bilangan bulat positif yang berbeza di mana sekurang -kurangnya k - 1 daripadanya adalah hampir perdana; Simpan jumlah pertama k - 1 hampir nombor utama; Jika jumlah lebih besar daripada atau sama dengan n; Jika tidak, prvar ya; Kod pemacu", "code": "function countPrimeFactors ( n ) { var count = 0 ; while ( n % 2 == 0 ) { n = parseInt ( n / 2 ) ; count ++ ; } for ( i = 3 ; i <= parseInt ( Math . sqrt ( n ) ) ; i = i + 2 ) { while ( n % i == 0 ) { n = parseInt ( n / i ) ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } function findSum ( n ) { var sum = 0 ; for ( i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == 2 ) { sum += num ; i ++ ; } } return sum ; } function check ( n , k ) { var s = findSum ( k - 1 ) ; if ( s >= n ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } var n = 100 , k = 6 ; check ( n , k ) ;"}
{"text": "Kira cara untuk mewakili integer sebagai eksponen | Berfungsi untuk mengira GCD A dan B menggunakan algoritma Euclidean; Iterat sehingga B bukan sifar; Mengembalikan GCD; Fungsi untuk mengira bilangan cara n boleh dinyatakan sebagai x ^ y; Kes asas; Menyimpan GCD kuasa; Kirakan tahap 2 dalam n; Kirakan tahap nombor utama dalam n; Kirakan tahap perdana 'i' dalam n; Jika n adalah perdana, G menjadi 1 .; Menyimpan bilangan cara untuk mewakili n sebagai x ^ y; Cari bilangan faktor G; Mengemas kini kiraan cara; Berulang untuk mencari bilangan nombor perdana; Cari kuasa i; Mengemas kini kiraan cara; Jika G adalah Perdana; Mengembalikan jumlah cara; Kod pemacu", "code": "function gcd ( a , b ) { while ( b > 0 ) { let rem = a % b ; a = b ; b = rem ; } return a ; } function countNumberOfWays ( n ) { if ( n == 1 ) return - 1 ; let g = 0 ; let power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; let ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( let i = 3 ; i <= Math . sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; } let N = 64 ; document . write ( countNumberOfWays ( N ) ) ;"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan integer yang diberikan | Berfungsi untuk mengembalikan kuasa terendah 2 dekat dengan nombor positif yang diberikan; Fungsi lantai digunakan untuk menentukan nilai yang dekat dengan nombor; Berfungsi untuk mengembalikan kuasa terendah 2 dekat dengan nombor negatif yang diberikan; Fungsi Ceil digunakan untuk nombor negatif sebagai - 1> - 4. Ia akan bertentangan dengan nombor positif di mana 1 <4; Berfungsi untuk mencari kuasa tertinggi 2; Untuk memeriksa sama ada nombor yang diberikan positif atau negatif; Jika nombor itu negatif, maka siling nombor positif dikira dan tanda negatif ditambah; Kod pemacu", "code": "function powOfPositive ( n ) { let pos = Math . floor ( Math . log2 ( n ) ) ; return Math . pow ( 2 , pos ) ; } function powOfNegative ( n ) { let pos = Math . ceil ( Math . log2 ( n ) ) ; return ( - 1 * Math . pow ( 2 , pos ) ) ; } function highestPowerOf2 ( n ) { if ( n > 0 ) { document . write ( powOfPositive ( n ) ) ; } else { n = - n ; document . write ( powOfNegative ( n ) ) ; } } let n = - 24 ; highestPowerOf2 ( n ) ;"}
{"text": "Bilangan kad yang diperlukan membina rumah kad tahap n | Berfungsi untuk mencari bilangan kad yang diperlukan; Kod pemacu", "code": "function noOfCards ( n ) { return parseInt ( n * ( 3 * n + 1 ) / 2 ) ; } var n = 3 ; document . write ( noOfCards ( n ) ) ;"}
{"text": "Cari nombor terkecil dari sejumlah besar yang diberikan dengan kiraan digit yang sama | Fungsi untuk mencari nombor yang paling kecil selepas menukar digit beberapa kali; Pembolehubah untuk menyimpan jawapan terakhir; Array untuk menyimpan kiraan kejadian setiap digit; Gelung untuk mengira bilangan kejadian setiap digit; Gelung untuk mendapatkan nombor terkecil; Mengembalikan jawapannya; Kod pemacu", "code": "function smallestPoss ( s , n ) { var ans = \" \" ; var arr = Array ( 10 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { arr [ s [ i ] . charCodeAt ( 0 ) - 48 ] ++ ; } for ( var i = 0 ; i < 10 ; i ++ ) { for ( var j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + i . toString ( ) ; } return ans ; } var N = 15 ; var K = \" \" ; document . write ( smallestPoss ( K , N ) ) ;"}
{"text": "Kira subarray dengan jumlah yang lebih besar daripada jumlah elemen yang tinggal | Berfungsi untuk mengira bilangan sub -tatasusunan dengan jumlah yang lebih besar daripada unsur -unsur array yang tinggal; Untuk gelung untuk titik permulaan subarray; Untuk gelung untuk titik akhir subarray; Permulaan subarray_sum dan sisa_sum hingga 0; Untuk gelung untuk mengira jumlah subarray yang dihasilkan; Untuk gelung untuk mengira unsur array sisa jumlah; Memeriksa keadaan apabila jumlah Subarray adalah lebih besar daripada jumlah unsur array yang tinggal; Kod pemacu", "code": "function Count_subarray ( arr , n ) { var subarray_sum , remaining_sum , count = 0 ; var i , j , k , l ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } var arr = [ 10 , 9 , 12 , 6 ] ; var n = arr . length ; document . write ( Count_subarray ( arr , n ) ) ;"}
{"text": "Kira subarray dengan jumlah yang lebih besar daripada jumlah elemen yang tinggal | pelaksanaan JavaScript pendekatan di atas; Mengira jumlah jumlah array yang diberikan; Untuk gelung untuk memulakan povar subarray; permulaan subarray_sum hingga 0; Untuk gelung untuk mengira subarray_sum dan sisa_sum; Mengira subarray_sum dan sisa yang sama; Memeriksa keadaan apabila jumlah Subarray adalah lebih besar daripada jumlah baki elemen array; Kod pemacu", "code": "function Count_subarray ( arr , n ) { var total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } var arr = [ 10 , 9 , 12 , 6 ] ; var n = arr . length ; document . write ( Count_subarray ( arr , n ) ) ;"}
{"text": "Keluarkan satu elemen untuk mendapatkan XOR maksimum | Berfungsi untuk mengembalikan XOR yang dimaksimumkan selepas mengeluarkan elemen dari array; Cari xor array lengkap; Untuk menyimpan jawapan terakhir; Melangkah melalui array untuk mencari jawapan terakhir; Kembalikan jawapan terakhir; Kod pemacu", "code": "function maxXOR ( arr , n ) { let xorArr = 0 ; for ( let i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; } let arr = [ 1 , 1 , 3 ] ; let n = arr . length ; document . write ( maxXOR ( arr , n ) ) ;"}
{"text": "Kira nombor dari julat [l, r] yang mengandungi sekurang -kurangnya satu digit yang membahagikan k | Fungsi yang mengembalikan benar jika NUM mengandungi sekurang -kurangnya satu digit yang membahagikan k; Dapatkan digit terakhir; Jika digit bukan sifar dan ia membahagikan k; Keluarkan digit terakhir; Tiada digit dalam num yang membahagikan k; Fungsi untuk mengembalikan kiraan unsur -unsur yang diperlukan dari julat yang diberikan yang mengandungi sekurang -kurangnya satu digit yang membahagikan k; Untuk menyimpan hasilnya; Untuk setiap nombor dari julat; Jika mana -mana digit nombor semasa membahagikan k; Kod pemacu", "code": "function digitDividesK ( num , k ) { while ( num ) { let d = num % 10 ; if ( d != 0 && k % d == 0 ) return true ; num = parseInt ( num / 10 ) ; } return false ; } function findCount ( l , r , k ) { let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( digitDividesK ( i , k ) ) count ++ ; } return count ; } let l = 20 , r = 35 ; let k = 45 ; document . write ( findCount ( l , r , k ) ) ;"}
{"text": "Semak jika nombor tertentu adalah faktorial mana -mana nombor | Fungsi untuk memeriksa sama ada nombor yang diberikan adalah faktorial bagi mana -mana nombor; Kod pemacu", "code": "function isFactorial ( n ) { for ( var i = 1 ; ; i ++ ) { if ( n % i == 0 ) { n = parseInt ( n / i ) ; } else { break ; } } if ( n == 1 ) { return true ; } else { return false ; } } var n = 24 ; var ans = isFactorial ( n ) ; if ( ans == 1 ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Keluarkan elemen untuk meminimumkan LCM array yang diberikan | Berfungsi untuk mengembalikan LCM dua nombor; Berfungsi untuk mengembalikan LCM minimum selepas mengeluarkan satu elemen dari array yang diberikan; Awalan dan akhiran tatasusunan; Hubungan pengaturcaraan dinamik negara tunggal untuk menyimpan LCM unsur -unsur pertama saya dari kiri dalam awalan [i]; Memulakan array akhiran; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan LCM dari semua elemen yang mempunyai indeks lebih besar daripada atau sama dengan saya dalam akhiran [i]; Jika elemen pertama atau terakhir array perlu dikeluarkan; Jika elemen lain diganti; Mengembalikan LCM minimum; Kod pemacu", "code": "function lcm ( a , b ) { let GCD = __gcd ( a , b ) ; return Math . floor ( ( a * b ) / GCD ) ; } function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } function MinLCM ( a , n ) { let Prefix = new Array ( n + 2 ) ; let Suffix = new Array ( n + 2 ) ; Prefix [ 1 ] = a [ 0 ] ; for ( let i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( let i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } let ans = Math . min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( let i = 2 ; i < n ; i += 1 ) { ans = Math . min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } let a = [ 5 , 15 , 9 , 36 ] ; let n = a . length ; document . write ( MinLCM ( a , n ) ) ;"}
{"text": "Bilangan berwarna 0 dalam n | Berfungsi untuk mengembalikan kiraan berwarna 0 s dalam segi enam tahap n; Kod pemacu", "code": "function count ( n ) { return parseInt ( n * ( 3 * n - 1 ) / 2 ) ; } var n = 3 ; document . write ( count ( n ) ) ;"}
{"text": "Nilai minimum yang akan diberikan kepada unsur -unsur supaya jumlahnya menjadi lebih besar daripada jumlah awal | Berfungsi untuk mengembalikan nilai minimum yang diperlukan; Cari jumlah elemen array; Mengembalikan nilai yang diperlukan; Kod pemacu", "code": "function findMinValue ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( parseInt ( sum / n ) + 1 ) ; } let arr = [ 4 , 2 , 1 , 10 , 6 ] ; let n = arr . length ; document . write ( findMinValue ( arr , n ) ) ;"}
{"text": "Warna semua kotak sejajar supaya setiap kotak berturut -turut m adalah unik | Pelaksanaan JavaScript pendekatan; Fungsi untuk kembali (M! % Mod); Kod pemacu", "code": "const MOD = 1000000007 ; function modFact ( n , m ) { let result = 1 ; for ( let i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } let n = 3 , m = 2 ; document . write ( modFact ( n , m ) ) ;"}
{"text": "Jumlah kuadrat semua subset dari array yang diberikan | Pelaksanaan JavaScript pendekatan; Berfungsi untuk kembali (2 ^ p % mod); Berfungsi untuk mengembalikan jumlah kuadrat subset; Squuaring unsur -unsur dan menambahkannya ke Ans; Kod pemacu", "code": "const mod = 1000000000 + 7 ; function power ( p ) { let res = 1 ; for ( let i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; } function subset_square_sum ( A ) { let n = A . length ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ans += ( A [ i ] * A [ i ] ) % mod ; ans %= mod ; } return ( ans * power ( n - 1 ) ) % mod ; } let A = [ 3 , 7 ] ; document . write ( subset_square_sum ( A ) ) ;"}
{"text": "Cari bilangan pasangan supaya GCD mereka sama dengan 1 | Program JavaScript untuk mencari bilangan pasangan seperti yang GCD sama dengan 1; Berfungsi untuk mengira faktor utama paling kurang setiap nombor; Jika ia adalah nombor utama; Untuk semua gandaan yang belum dikunjungi. ; Berfungsi untuk mencari nilai fungsi Mobius untuk semua nombor dari 1 hingga n; Jika nombor adalah satu; Jika nombor mempunyai faktor utama kuasa; Multiply - 1 dengan nombor sebelumnya; Berfungsi untuk mencari bilangan pasangan seperti yang GCD sama dengan 1; Untuk menyimpan nombor maksimum; Untuk menyimpan kekerapan setiap nombor; Cari kekerapan dan nombor maksimum; Untuk menyimpan nombor pasangan dengan GCD sama dengan 1; Melintasi semua elemen yang mungkin; Mengembalikan bilangan pasangan; Kod pemacu; Panggilan fungsi", "code": "var N = 100050 ; var lpf = Array ( N ) . fill ( 0 ) ; var mobius = Array ( N ) . fill ( 0 ) ; function least_prime_factor ( ) { for ( i = 2 ; i < N ; i ++ ) if ( lpf [ i ] == 0 ) for ( j = i ; j < N ; j += i ) if ( lpf [ j ] == 0 ) lpf [ j ] = i ; } function Mobius ( ) { for ( i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = - 1 * mobius [ i / lpf [ i ] ] ; } } } function gcd_pairs ( a , n ) { var maxi = 0 ; var fre = Array ( n + 1 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { fre [ a [ i ] ] ++ ; maxi = Math . max ( a [ i ] , maxi ) ; } least_prime_factor ( ) ; Mobius ( ) ; var ans = 0 ; for ( i = 1 ; i <= maxi ; i ++ ) { if ( mobius [ i ] == 0 ) continue ; var temp = 0 ; for ( j = i ; j <= maxi ; j += i ) temp = parseInt ( temp + fre [ j ] ) ; ans += parseInt ( temp * ( temp - 1 ) / 2 * mobius [ i ] ) ; } return ans ; } var a = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; var n = a . length ; document . write ( gcd_pairs ( a , n ) ) ;"}
{"text": "Membandingkan x ^ y dan y ^ x untuk nilai -nilai yang sangat besar x dan y | Fungsi untuk membandingkan x ^ y dan y ^ x; Menyimpan nilai x ^ y dan y ^ x; Membandingkan nilai; Kod pemacu", "code": "function compareVal ( x , y ) { let a = y * Math . log ( x ) ; let b = x * Math . log ( y ) ; if ( a > b ) document . write ( x + \" \" + y + \" \" + y + \" \" + x ) ; else if ( a < b ) document . write ( x + \" \" + y + \" \" + y + \" \" + x ) ; else if ( a == b ) document . write ( x + \" \" + y + \" \" + y + \" \" + x ) ; } let x = 4 , y = 5 ; compareVal ( x , y ) ;"}
{"text": "Nombor Euler Zigzag (Permutasi Ganti) | Berfungsi untuk mencetak nombor zigzag pertama; Untuk menyimpan nombor factorial dan n 'th zig zag; Memulakan factorial sehingga n; Tetapkan dua nombor Zig Zag pertama; Cetak dua nombor zig zag pertama; Cetak nombor zig zag selebihnya; Binomial (n, k) * a (k) * a (n - k); Simpan nilai; Cetak nombor; Kod pemacu; Panggilan fungsi", "code": "function ZigZag ( n ) { var fact = Array ( n + 1 ) . fill ( 0 ) ; var zig = Array ( n + 1 ) . fill ( 0 ) ; fact [ 0 ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; document . write ( \" \" ) ; document . write ( zig [ 0 ] + \" \" + zig [ 1 ] + \" \" ) ; for ( var i = 2 ; i < n ; i ++ ) { var sum = 0 ; for ( var k = 0 ; k <= i - 1 ; k ++ ) { sum += parseInt ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; } zig [ i ] = parseInt ( sum / 2 ) ; document . write ( parseInt ( sum / 2 ) + \" \" ) ; } } var n = 10 ; ZigZag ( n ) ;"}
{"text": "Urutan Gijswijt | Jika urutan adalah (1) a (2) a (3). . A (n - 1) Periksa jika urutan boleh diwakili sebagai x * (y ^ k) mencari nilai terbesar k; kiraan; Corak unsur -unsur saiz I dari akhir urutan; kiraan; ekstrak corak dalam urutan terbalik; Semak berapa kali corak diulang; jika perlawanan dosis elemen; Jika akhir corak dicapai nilai set k = 0 dan tingkatkan kiraan; mengembalikan kiraan maksimum; cetak pertama n terma urutan Gijswijt; Tetapkan kiraan; membongkok elemen; Cetak istilah N pertama urutan; tolak elemen; Cari kiraan untuk nombor seterusnya; Kod pemacu", "code": "function find_count ( ele ) { let count = 0 ; for ( let i = 0 ; i < ele . length ; i ++ ) { let p = [ ] ; let c = 0 ; for ( let j = ele . length - 1 ; j >= ( ele . length - 1 - i ) && j >= 0 ; j -- ) p . push ( ele [ j ] ) ; let j = ele . length - 1 , k = 0 ; while ( j >= 0 ) { if ( ele [ j ] != p [ k ] ) break ; j -- ; k ++ ; if ( k == p . length ) { c ++ ; k = 0 ; } } count = Math . max ( count , c ) ; } return count ; } function solve ( n ) { let count = 1 ; let ele = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { document . write ( count + \" \" ) ; ele . push ( count ) ; count = find_count ( ele ) ; } } let n = 10 ; solve ( n ) ;"}
{"text": "Wedderburn - Nombor Etherington | Menyimpan nombor Wedderburn Etherington; Berfungsi untuk mengembalikan nombor Nth Wedderburn Etherington; Kes asas; Jika n adalah n = 2 x; Dapatkan x; A (2 x) = A (1) A (2 x - 1) + A (2) A (2 x - 2) + ... + A (x - 1) A (x + 1); a (x) (a (x) + 1) / 2; Simpan Ans; Mengembalikan jawapan yang diperlukan; Jika n adalah ganjil; a (2 x - 1) = a (1) a (2 x - 2) + a (2) a (2 x - 3) + ... + a (x - 1) a (x) ,; Simpan Ans; Mengembalikan jawapan yang diperlukan; Berfungsi untuk mencetak nombor N First N Wedderburn Etherington; Simpan nombor 3 pertama; Cetak n terma; Kod pemacu; panggilan fungsi", "code": "var store = new Map ( ) ; function Wedderburn ( n ) { if ( n <= 2 ) return store [ n ] ; else if ( n % 2 == 0 ) { var x = parseInt ( n / 2 ) , ans = 0 ; for ( var i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } ans += ( store [ x ] * ( store [ x ] + 1 ) ) / 2 ; store [ n ] = ans ; return ans ; } else { var x = ( n + 1 ) / 2 , ans = 0 ; for ( var i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } store [ n ] = ans ; return ans ; } } function Wedderburn_Etherington ( n ) { store [ 0 ] = 0 ; store [ 1 ] = 1 ; store [ 2 ] = 1 ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( Wedderburn ( i ) ) ; if ( i != n - 1 ) document . write ( \" \" ) ; } } var n = 10 ; Wedderburn_Etherington ( n ) ;"}
{"text": "Nilai maksimum selepas menggabungkan semua elemen dalam array | Berfungsi dengan nilai maksimum selepas menggabungkan semua elemen dalam array; Untuk memeriksa sama ada elemen positif dan negatif hadir atau tidak; Semak integer positif; Semak integer negatif; Jika kedua -dua unsur positif dan negatif hadir; Untuk menyimpan nilai maksimum yang mungkin; Untuk mencari nilai minimum; Keluarkan elemen minimum; Menggantikan dengan nilai mutlak; Untuk mencari nilai minimum; Keluarkan elemen minimum; Mengembalikan jumlah yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "function Max_sum ( a , n ) { let pos = 0 , neg = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( pos == 1 && neg == 1 ) break ; } let sum = 0 ; if ( pos == 1 && neg == 1 ) { for ( let i = 0 ; i < n ; i ++ ) sum += Math . abs ( a [ i ] ) ; } else if ( pos == 1 ) { let mini = a [ 0 ] ; sum = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( let i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; let mini = a [ 0 ] ; sum = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; } let a = [ 1 , 3 , 5 , - 2 , - 6 ] ; let n = a . length ; document . write ( Max_sum ( a , n ) ) ;"}
{"text": "Perpuluhan untuk binari menggunakan rekursi dan tanpa menggunakan pengendali kuasa | Fungsi rekursif untuk menukar n kepada bersamaan binari; Kes asas; Panggilan rekursif; Kod pemacu", "code": "function decimalToBinary ( n ) { if ( n == 0 ) { document . write ( \" \" ) ; return ; } decimalToBinary ( parseInt ( n / 2 ) ) ; document . write ( n % 2 ) ; } var n = 13 ; decimalToBinary ( n ) ;"}
{"text": "Cari nilai minimum a, b dan c apabila dua (a + b), (a + c) dan (b + c) diberikan | Berfungsi untuk mencari A, B dan C; Simpan nombor minimum dalam x; Cari nombor; Kod pemacu; Panggilan fungsi", "code": "function MinimumValue ( x , y ) { if ( x > y ) { var temp = x ; x = y ; y = temp ; } var a = 1 ; var b = x - 1 ; var c = y - b ; document . write ( a + \" \" + b + \" \" + c ) ; } var x = 123 , y = 13 ; MinimumValue ( x , y ) ;"}
{"text": "Semak sama ada mungkin untuk menukar A ke B | Fungsi yang mengembalikan benar jika A boleh ditukar kepada B dengan operasi yang diberikan; Jika nombor semasa berakhir dengan 1; Jika nombor semasa boleh dibahagikan dengan 2; Jika di atas dua keadaan gagal; Sekiranya mungkin untuk menukar A ke B; Kod pemacu", "code": "function canConvert ( a , b ) { while ( b > a ) { if ( b % 10 == 1 ) { b = parseInt ( b / 10 ) ; continue ; } if ( b % 2 == 0 ) { b = parseInt ( b / 2 ) ; continue ; } return false ; } if ( b == a ) return true ; return false ; } let A = 2 , B = 82 ; if ( canConvert ( A , B ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Count Rectangles yang berbeza dalam N * N Chessboard | Fungsi untuk mengira segi empat tepat yang berbeza; Kod pemacu", "code": "function count ( N ) { var a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; } var n = 4 ; document . write ( count ( n ) ) ;"}
{"text": "Jumlah hari yang diambil untuk menyelesaikan tugas jika selepas hari -hari tertentu seseorang meninggalkan | Berfungsi untuk mengembalikan bilangan hari yang diperlukan; Kod pemacu", "code": "function numberOfDays ( a , b , n ) { var Days = b * ( n + a ) / ( a + b ) ; return Days ; } var a = 10 , b = 20 , n = 5 ; document . write ( numberOfDays ( a , b , n ) ) ;"}
{"text": "Cari purata dua nombor menggunakan operasi bit | Berfungsi untuk mengembalikan purata x dan y menggunakan operasi bit; Kirakan nilai lantai purata (x + y) / 2; Kod pemacu", "code": "function getAverage ( x , y ) { var avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; } var x = 10 , y = 9 ; document . write ( getAverage ( x , y ) ) ;"}
{"text": "Indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya | Berfungsi untuk mencari indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya; Pada mulanya; Melintasi array; Semak jika elemen array adalah 1; a [i] = 0; Kembali minimum kedua -duanya; Kod pemacu", "code": "function smallestIndex ( a , n ) { let right1 = 0 , right0 = 0 ; let i ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . min ( right1 , right0 ) ; } var a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] ; let n = a . length ; document . write ( smallestIndex ( a , n ) ) ;"}
{"text": "Jumlah kedudukan di mana raja boleh sampai di papan catur dengan tepat m bergerak | Tetapkan 2 | Berfungsi untuk mengembalikan kiraan dataran yang boleh dikunjungi oleh raja dalam gerakan; Untuk menyimpan kiraan dataran; Semak semua dataran papan catur; Semak jika persegi (i, j) berada pada jarak <= m unit dari kedudukan semasa Raja; Kembali kiraan kuadrat; Kod pemacu", "code": "function countSquares ( r , c , m ) { let squares = 0 ; for ( let i = 1 ; i <= 8 ; i ++ ) { for ( let j = 1 ; j <= 8 ; j ++ ) { if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; } let r = 4 , c = 4 , m = 1 ; document . write ( countSquares ( r , c , m ) ) ;"}
{"text": "Bilangan kuadrup di mana tiga syarat pertama berada dalam AP dan tiga istilah terakhir adalah dalam gp | Berfungsi untuk mengembalikan kiraan kuadrup; Jadual Hash untuk mengira bilangan kejadian; Melintasi dan meningkatkan kiraan; Jalankan dua gelung bersarang untuk elemen kedua dan ketiga; Jika mereka sama; Pada mulanya mengurangkan kiraan; Cari elemen pertama menggunakan perbezaan bersama; Cari elemen keempat menggunakan gp y ^ 2 = x * z harta; Jika ia adalah leteger; Jika tidak sama; Unsur yang sama; Kemudian meningkatkan nilai untuk pengiraan masa depan; Kod pemacu", "code": "function countQuadruples ( a , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( mp . has ( a [ i ] ) ) { mp . set ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . set ( a [ i ] , 1 ) ; } let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) { for ( let k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mp . set ( a [ j ] , mp . get ( a [ j ] ) - 1 ) ; mp . set ( a [ k ] , mp . get ( a [ k ] ) - 1 ) ; let first = a [ j ] - ( a [ k ] - a [ j ] ) ; let fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) { if ( mp . has ( first ) && mp . has ( fourth ) ) count += mp . get ( first ) * mp . get ( fourth ) ; } else if ( mp . has ( first ) && mp . has ( fourth ) ) count += mp . get ( first ) * ( mp . get ( fourth ) - 1 ) ; } if ( mp . has ( a [ j ] ) ) { mp . set ( a [ j ] , mp . get ( a [ j ] ) + 1 ) ; } else { mp . set ( a [ j ] , 1 ) ; } if ( mp . has ( a [ k ] ) ) { mp . set ( a [ k ] , mp . get ( a [ k ] ) + 1 ) ; } else { mp . set ( a [ k ] , 1 ) ; } } } return count ; } let a = [ 2 , 6 , 4 , 9 , 2 ] ; let n = a . length ; document . write ( countQuadruples ( a , n ) ) ;"}
{"text": "Nombor dalam julat dengan akar digital yang diberikan | Berfungsi untuk mengembalikan kiraan nombor yang diperlukan; Kiraan nombor yang ada dalam julat yang diberikan; Bilangan kumpulan 9 elemen bermula dari L; Meninggalkan unsur -unsur yang tidak diliputi dalam Faktor 9; Satu nombor dalam setiap kumpulan 9; Untuk memeriksa sama ada nombor dalam REM memenuhi harta itu; Kod pemacu", "code": "function countNumbers ( L , R , K ) { if ( K == 9 ) { K = 0 ; } var totalnumbers = R - L + 1 ; var factor9 = totalnumbers / 9 ; var rem = totalnumbers % 9 ; var ans = factor9 ; for ( var i = R ; i > R - rem ; i -- ) { var rem1 = i % 9 ; if ( rem1 == K ) { ans ++ ; } } return ans ; } var L = 10 ; var R = 22 ; var K = 3 ; document . write ( Math . round ( countNumbers ( L , R , K ) ) ) ;"}
{"text": "Jumlah nilai dan kemas kini pertanyaan pada array | Berfungsi untuk mengembalikan jumlah elemen walaupun selepas mengemas kini nilai pada indeks yang diberikan; Tambah nilai yang diberikan kepada [indeks]; Untuk menyimpan jumlah elemen walaupun; Jika elemen semasa adalah walaupun; Berfungsi untuk mencetak hasil untuk setiap pertanyaan; Vektor yang dihasilkan yang menyimpan hasil untuk setiap pertanyaan; Dapatkan jumlah elemen walaupun selepas mengemas kini nilai pada indeks yang diberikan; Simpan jumlah untuk setiap pertanyaan; Cetak hasil untuk setiap pertanyaan; Kod pemacu", "code": "function EvenSum ( A , index , value ) { A [ index ] = A [ index ] + value ; var sum = 0 ; for ( var i = 0 ; i < A . length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; return sum ; } function BalanceArray ( A , Q ) { var ANS = [ ] ; var i , sum ; for ( i = 0 ; i < Q . length ; i ++ ) { var index = Q [ i ] [ 0 ] ; var value = Q [ i ] [ 1 ] ; sum = EvenSum ( A , index , value ) ; ANS . push ( sum ) ; } for ( i = 0 ; i < ANS . length ; i ++ ) document . write ( ANS [ i ] + \" \" ) ; } var A = [ 1 , 2 , 3 , 4 ] ; var Q = [ [ 0 , 1 ] , [ 1 , - 3 ] , [ 0 , - 4 ] , [ 3 , 2 ] ] ; BalanceArray ( A , Q ) ;"}
{"text": "Jumlah nilai dan kemas kini pertanyaan pada array | Berfungsi untuk mencetak hasil untuk setiap pertanyaan; Jika elemen semasa adalah walaupun; Jika elemen bahkan kemudian keluarkannya dari jumlah; Jika nilai menjadi walaupun selepas mengemas kini; Simpan jumlah untuk setiap pertanyaan; Cetak hasil untuk setiap pertanyaan; Kod pemacu", "code": "function BalanceArray ( A , Q ) { var ANS = [ ] ; var i , sum = 0 ; for ( i = 0 ; i < A . length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . length ; i ++ ) { var index = Q [ i ] [ 0 ] ; var value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push ( sum ) ; } for ( i = 0 ; i < ANS . length ; i ++ ) document . write ( ANS [ i ] + \" \" ) ; } var A = [ 1 , 2 , 3 , 4 ] ; var Q = [ [ 0 , 1 ] , [ 1 , - 3 ] , [ 0 , - 4 ] , [ 3 , 2 ] ] ; BalanceArray ( A , Q ) ;"}
{"text": "Bilangan Siklus Hamiltonian | Fungsi yang mengira bilangan kitaran Hamiltonian; Mengira faktorial; Kod pemacu", "code": "function Cycles ( N ) { var fact = 1 , result = 0 ; result = N - 1 ; var i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; } var N = 5 ; var Number = Cycles ( N ) ; document . write ( \" \" + Number ) ;"}
{"text": "Integer terkecil lebih besar daripada n sedemikian rupa sehingga ia terdiri daripada digit m tepat kali K | Fungsi yang pulih benar jika n mengandungi digit m tepat k kali; Berfungsi untuk mengembalikan integer terkecil> n dengan digit m yang berlaku tepat kali K; Kod pemacu", "code": "function digitWell ( n , m , k ) { var cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n = Math . floor ( n / 10 ) ; } if ( cnt == k ) return true ; else return false ; } function findInt ( n , m , k ) { var i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } } var n = 111 , m = 2 , k = 2 ; document . write ( findInt ( n , m , k ) ) ;"}
{"text": "KOMPOSITE XOR DAN COPRIME DAN | Berfungsi untuk mengembalikan kiraan nombor ganjil dalam array; Pembolehubah untuk mengira nombor ganjil; Nombor ganjil; Berfungsi untuk mengembalikan kiraan pasangan yang sah; Kod pemacu", "code": "function countOdd ( arr , n ) { var odd = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; } function countValidPairs ( arr , n ) { var odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) / 2 ; } var arr = [ 1 , 2 , 3 , 4 , 5 ] ; var n = arr . length ; document . write ( countValidPairs ( arr , n ) ) ;"}
{"text": "Cube sempurna terkecil dibahagi dengan semua elemen array | Berfungsi untuk mengembalikan GCD dua nombor; Berfungsi untuk mengembalikan LCM semua elemen array; Untuk mengira LCM dua nombor melipatgandakan mereka dan membahagikan hasilnya dengan GCD kedua -dua nombor; Mengembalikan LCM unsur -unsur array; Berfungsi untuk mengembalikan kiub sempurna yang paling kecil yang boleh dibahagikan dengan semua elemen arr []; LCM semua elemen ARR []; Jika 2 membahagikan bilangan kali LCM CNT; Semak semua nombor yang membahagikan LCM; Kembalikan jawapannya; Kod pemacu", "code": "function gcd ( a , b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } function lcmOfArray ( arr , n ) { if ( n < 1 ) return 0 ; let lcm = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) lcm = parseInt ( ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ) ; return lcm ; } function minPerfectCube ( arr , n ) { let minPerfectCube ; let lcm = lcmOfArray ( arr , n ) ; minPerfectCube = lcm ; let cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm = parseInt ( lcm / 2 ) ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; let i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm = parseInt ( lcm / i ) ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; } return minPerfectCube ; } let arr = [ 10 , 125 , 14 , 42 , 100 ] ; let n = arr . length ; document . write ( minPerfectCube ( arr , n ) ) ;"}
{"text": "Semak jika n adalah Perdana yang kuat | Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah perdana yang kuat; Jika n bukan nombor perdana atau n adalah perdana pertama maka kembali palsu; Inisialisasi sebelumnya_prime ke n - 1 dan next_prime ke n + 1; Cari nombor perdana seterusnya; Cari nombor perdana sebelumnya; Min aritmetik; Jika n adalah perdana yang kuat; Kod pemacu", "code": "function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function isStrongPrime ( n ) { if ( ! isPrime ( n ) n == 2 ) return false ; let previous_prime = n - 1 ; let next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; let mean = parseInt ( ( previous_prime + next_prime ) / 2 ) ; if ( n > mean ) return true ; else return false ; } let n = 11 ; if ( isStrongPrime ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Penyingkiran minimum dalam nombor yang boleh dibahagikan dengan 10 kuasa yang dibangkitkan kepada k | Berfungsi untuk mengembalikan bilangan digit yang diperlukan untuk dikeluarkan; Menukar nombor yang diberikan ke dalam rentetan; pembolehubah untuk menyimpan nombor digit yang akan dikeluarkan; Pembolehubah untuk menunjukkan jika sekurang -kurangnya satu sifar telah dijumpai; sifar dijumpai; saiz pulangan - 1 jika k tidak sifar dan atleast satu sifar hadir, jika tidak hasilnya; Kod pemacu untuk menguji fungsi di atas", "code": "function countDigitsToBeRemoved ( N , K ) { var s = N . toString ( ) ; var res = 0 ; var f_zero = 0 ; for ( var i = s . length - 1 ; i >= 0 ; i -- ) { if ( K === 0 ) return res ; if ( s [ i ] === \" \" ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K === 0 ) return res ; else if ( f_zero === 1 ) return s . length - 1 ; return - 1 ; } var N = 10904025 ; var K = 2 ; document . write ( countDigitsToBeRemoved ( N , K ) + \" \" ) ; N = 1000 ; K = 5 ; document . write ( countDigitsToBeRemoved ( N , K ) + \" \" ) ; N = 23985 ; K = 2 ; document . write ( countDigitsToBeRemoved ( N , K ) + \" \" ) ;"}
{"text": "Program untuk mencari jumlah siri (1 / a + 2 / a ^ 2 + 3 / a ^ 3 + ... + n / a ^ n) | Berfungsi untuk mengembalikan jumlah siri; pembolehubah untuk menyimpan jawapannya; Matematik. pow (x, y) mengembalikan x ^ y; Kod pemacu; Prlet jumlah siri", "code": "function getSum ( a , n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { sum += ( i / Math . pow ( a , i ) ) ; } return sum ; } let a = 3 , n = 3 ; document . write ( getSum ( a , n ) . toFixed ( 7 ) ) ;"}
{"text": "Semak sama ada nombor adalah nombor yang tidak biasa atau tidak | Fungsi utiliti untuk mencari faktor utama terbesar bagi nombor; Memulakan pemboleh ubah faktor utama maksimum dengan yang paling rendah; Cetak bilangan 2 s yang membahagikan n; n >> = 1; bersamaan dengan n /= 2; n mesti ganjil pada ketika ini, dengan itu melangkau nombor -nombor bahkan dan berulang hanya untuk bilangan bulat yang ganjil; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Berfungsi untuk memeriksa nombor yang tidak biasa; Dapatkan faktor utama terbesar nombor; Semak jika faktor utama terbesar adalah lebih besar daripada sqrt (n); Kod pemacu", "code": "function largestPrimeFactor ( n ) { var max = - 1 ; while ( n % 2 == 0 ) { max = 2 ; } for ( var i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max = i ; n = n / i ; } } if ( n > 2 ) max = n ; return max ; } function checkUnusual ( n ) { var factor = largestPrimeFactor ( n ) ; if ( factor > Math . sqrt ( n ) ) { return true ; } else { return false ; } } var n = 14 ; if ( checkUnusual ( n ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Semak jika sekurang -kurangnya separuh array boleh diturunkan kepada sifar dengan melakukan beberapa operasi | Berfungsi untuk mencetak hasil yang diingini selepas pengiraan; Kod pemacu", "code": "function isHalfReducible ( arr , n , m ) { var frequencyHash = Array ( m + 1 ) . fill ( 0 ) ; var i ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } var arr = [ 8 , 16 , 32 , 3 , 12 ] ; var n = arr . length ; var m = 7 ; isHalfReducible ( arr , n , m ) ;"}
{"text": "Semak jika nombor yang diberikan adalah nombor bijih atau tidak | Program JavaScript untuk memeriksa sama ada nombor yang diberikan adalah nombor bijih; Fungsi yang mengembalikan min harmonik; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi sama, simpan 'i'; lain sebaliknya menyimpan 'i' dan 'n / i' kedua -duanya; Fungsi utiliti untuk mengira min harmonik pembahagi; Mengisytiharkan pembolehubah jumlah dan permulaan dengan sifar. ; hitung penyebut; Mengira min dan pulangan harmonik; Berfungsi untuk memeriksa sama ada nombor adalah nombor bijih; Kirakan min harmonik pembahagi n; Semak jika min harmonik adalah integer atau tidak; Kod pemacu", "code": "var arr = [ ] ; function generateDivisors ( n ) { for ( var i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) arr . push ( i ) ; { arr . push ( i ) ; arr . push ( n / i ) ; } } } } function harmonicMean ( n ) { generateDivisors ( n ) ; var sum = 0.0 ; var len = arr . length ; for ( var i = 0 ; i < len ; i ++ ) sum = sum + ( n / arr [ i ] ) ; sum = ( sum / n ) ; return ( arr . length / sum ) ; } function isOreNumber ( n ) { var mean = harmonicMean ( n ) ; if ( mean - parseInt ( mean ) == 0 ) return true ; else return false ; } var n = 28 ; if ( isOreNumber ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Semak sama ada nombor yang diberikan adalah nombor Euclid atau tidak | Program JavaScript untuk memeriksa nombor Euclid; Berfungsi untuk menjana nombor utama dan menyimpan produk mereka; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; kedai awalan produk nombor utama ke unordered_set 's'; mengemas kini produk dengan mendarabkan Perdana Seterusnya; Masukkan 'Produce + 1' untuk ditetapkan; Berfungsi untuk memeriksa nombor untuk nombor Euclid; Periksa sama ada nombor wujud dalam set yang tidak teratur atau tidak jika ada, kembali benar; Dapatkan nombor utama; Dapatkan n; Semak jika n adalah nombor euclid; Dapatkan n; Periksa sama ada n adalah nombor euclid", "code": "let MAX = 10000 ; let s = new Set ( ) ; function SieveOfEratosthenes ( ) { let prime = new Array ( MAX ) ; for ( let i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } let product = 1 ; for ( let p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . add ( product + 1 ) ; } } } function isEuclid ( n ) { if ( s . has ( n ) ) return true ; else return false ; } SieveOfEratosthenes ( ) ; let n = 31 ; if ( isEuclid ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ; n = 42 ; if ( isEuclid ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Semak sama ada nombor yang diberikan ialah Wagstaff Prime atau tidak | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi utiliti untuk memeriksa kuasa dua; Program pemacu; Semak jika nombor adalah perdana dan borang (2 ^ q + 1) / 3", "code": "function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } function isPowerOfTwo ( n ) { return ( n != 0 ) && ( ( n & ( n - 1 ) ) == 0 ) ; } var n = 43 ; if ( isPrime ( n ) && ( isPowerOfTwo ( n * 3 - 1 ) ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segi enam | Berfungsi untuk mencari kawasan dataran; sisi segi enam tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "function area ( a ) { if ( a < 0 ) return - 1 ; var area = Math . pow ( ( a * Math . sqrt ( 3 ) ) / ( Math . sqrt ( 2 ) ) , 2 ) ; return area ; } var a = 5 ; document . write ( area ( a ) . toFixed ( 5 ) ) ;"}
{"text": "Program untuk mencari istilah n Siri 1, 6, 17, 34, 56, 86, 121, 162, ... .... | mengira istilah siri nth; Kod pemacu", "code": "function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) - 4 * n + 2 ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;"}
{"text": "Jumlah terma pertama N Siri 2, 10, 30, 68, .... | Berfungsi untuk mengira jumlah; bilangan syarat yang akan dimasukkan dalam jumlah; Cari jumlahnya", "code": "function calculateSum ( n ) { return n * ( n + 1 ) / 2 + Math . pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; } let n = 3 ; document . write ( \" \" + calculateSum ( n ) ) ;"}
{"text": "Semak jika dua tatasusunan adalah permutasi antara satu sama lain menggunakan operasi matematik | Fungsi untuk memeriksa sama ada tatasusunan adalah permutasi antara satu sama lain. ; Mengira jumlah dan kalikan array pertama; Mengira jumlah dan kalikan array kedua; Jika jumlah dan Mul kedua -dua tatasusunan adalah sama, kembali benar, lain kembali palsu. ; Kod pemacu", "code": "function arePermutations ( a , b , n , m ) { let sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( let i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( let i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; } let a = [ 1 , 3 , 2 ] ; let b = [ 3 , 1 , 2 ] ; let n = a . length ; let m = b . length ; if ( arePermutations ( a , b , n , m ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Program untuk mencari permulaan dalam perlumbaan | Fungsi untuk mencari B mula c; Apabila B menyelesaikannya 100 meter kemudian selesai meter dengan C adalah; Kod pemacu; Apabila ia menyelesaikannya 100 meter kemudian selesai meter b dan c adalah", "code": "function Race ( B , C ) { var result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; } var B = 10 , C = 28 ; B = 100 - B ; C = 100 - C ; document . write ( Race ( B , C ) + \" \" ) ;"}
{"text": "Masa minimum diperlukan untuk mengisi tangki menggunakan paip n | Berfungsi untuk mengira masa; Kod pemacu", "code": "function Time ( arr , n , Emptypipe ) { var fill = 0 ; for ( var i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / Emptypipe ) ; return 1 / fill ; } var arr = [ 12 , 14 ] ; var Emptypipe = 30 ; var n = arr . length ; document . write ( Math . floor ( Time ( arr , n , Emptypipe ) ) + \" \" ) ;"}
{"text": "Semak jika perwakilan perpuluhan nombor oktal boleh dibahagikan dengan 7 | Berfungsi untuk memeriksa kebolehpasaran; Jumlah semua digit individu; Keadaan; Nombor oktal", "code": "function check ( n ) { let sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = Math . floor ( n / 10 ) ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; } let n = 25 ; ( check ( n ) == 1 ) ? document . write ( \" \" ) : document . write ( \" \" ) ;"}
{"text": "Jumlah semua pembahagi utama nombor | Program JavaScript untuk mencari jumlah pembahagi utama N; Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; berfungsi untuk mencari jumlah pembahagi utama N; Kod pemacu", "code": "let N = 1000005 ; function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function SumOfPrimeDivisors ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( isPrime ( i ) ) sum += i ; } } return sum ; } let n = 60 ; document . write ( \" \" + SumOfPrimeDivisors ( n ) ) ;"}
{"text": "Jumlah semua pembahagi utama nombor | berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Kod pemacu", "code": "function Sum ( N ) { let SumOfPrimeDivisors = new Array ( N + 1 ) ; for ( let i = 0 ; i < SumOfPrimeDivisors . length ; i ++ ) { SumOfPrimeDivisors [ i ] = 0 ; } for ( let i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 0 ) { for ( let j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } let N = 60 ; document . write ( \" \" + \" \" + Sum ( N ) + \" \" ) ;"}
{"text": "Kuadrat nombor dengan digit tunggal berulang | Tetapkan 1 (3, 6 dan 9) | Fungsi untuk mencari persegi 333. .. .333, 666. .666 dan 999.. .999; Sekiranya nombornya adalah 333. .. .333; Jika nombor itu 666. .. .666; Jika nombor itu 999 .. .999; pembolehubah untuk hasil pegangan; Cari tidak digit; tambah saiz - 1 kali dalam hasil; Tambah satu kali B hasil; tambah saiz - 1 kali c dalam hasil; tambah satu kali d hasil; hasil pulangan; Kod pemacu; Cari persegi 33. .33; cari persegi 66. .66; cari persegi 66. .66", "code": "function find_Square_369 ( num ) { let a , b , c , d ; if ( num [ 0 ] == ' ' ) { a = ' ' ; b = ' ' ; c = ' ' ; d = ' ' ; } else if ( num [ 0 ] == ' ' ) { a = ' ' ; b = ' ' ; c = ' ' ; d = ' ' ; } else { a = ' ' ; b = ' ' ; c = ' ' ; d = ' ' ; } let result = \" \" ; let size = num . length ; for ( let i = 1 ; i < size ; i ++ ) result += a ; result += b ; for ( let i = 1 ; i < size ; i ++ ) result += c ; result += d ; return result ; } let num_3 , num_6 , num_9 ; num_3 = \" \" ; num_6 = \" \" ; num_9 = \" \" ; let result = \" \" ; result = find_Square_369 ( num_3 ) ; document . write ( \" \" + num_3 + \" \" + result + \" \" ) ; result = find_Square_369 ( num_6 ) ; document . write ( \" \" + num_9 + \" \" + result + \" \" ) ; result = find_Square_369 ( num_9 ) ; document . write ( \" \" + num_9 + \" \" + result + \" \" ) ;"}
{"text": "Trick for Modular Bahagian ((x1 * x2 .... Xn) / b) Mod (M) |", "code": "var ans = 1 ; var mod = 1000000007 * 120 ; for ( var i = 0 ; i < 5 ; i ++ ) ans = ( ans * ( 55555 - i ) ) % mod ; ans = ans / 120 ; document . write ( \" \" + \" \" + ans ) ;"}
{"text": "Cara untuk membiak elemen dengan operasi bersekutu | Fungsi untuk mencari faktorial yang diperlukan; Berfungsi untuk mencari NCR; Berfungsi untuk mencari bilangan cara; Kod pemacu", "code": "function fact ( n ) { if ( n == 0 n == 1 ) return 1 ; let ans = 1 ; for ( let i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ans ; } function nCr ( n , r ) { let Nr = n , Dr = 1 , ans = 1 ; for ( let i = 1 ; i <= r ; i ++ ) { ans = parseInt ( ( ans * Nr ) / ( Dr ) , 10 ) ; Nr -- ; Dr ++ ; } return ans ; } function solve ( n ) { let N = 2 * n - 2 ; let R = n - 1 ; return nCr ( N , R ) * fact ( n - 1 ) ; } let n = 6 ; document . write ( solve ( n ) ) ;"}
{"text": "Triplet Pythagorean dengan jumlah yang diberikan | Program JavaScript untuk mencari triplet Pythagorean yang diberikan. ; Memandangkan tiga kali ganda dalam urutan yang disusun. Nilai elemen pertama dalam triplet yang disusun boleh diadakan - kebanyakan n / 3 .; Nilai elemen kedua mestilah kurang daripada sama dengan n / 2; Kod pemacu", "code": "function pythagoreanTriplet ( n ) { for ( let i = 1 ; i <= n / 3 ; i ++ ) { for ( let j = i + 1 ; j <= n / 2 ; j ++ ) { let k = n - i - j ; if ( i * i + j * j == k * k ) { document . write ( i + \" \" + j + \" \" + k ) ; return ; } } } document . write ( \" \" ) ; } let n = 12 ; pythagoreanTriplet ( n ) ;"}
{"text": "Program untuk mencetak Siri Pengembangan Binomial | berfungsi untuk mengira faktorial nombor; berfungsi untuk mempersembahkan siri; Mengira nilai n! ; gelung untuk memaparkan siri; Untuk mengira nilai NCR; mengira nilai A ke kuasa k dan x ke kuasa k; Paparkan siri; Kod pemacu", "code": "function factorial ( n ) { let f = 1 ; for ( let i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } function series ( A , X , n ) { let nFact = factorial ( n ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { let niFact = factorial ( n - i ) ; let iFact = factorial ( i ) ; let aPow = Math . pow ( A , n - i ) ; let xPow = Math . pow ( X , i ) ; document . write ( ( nFact * aPow * xPow ) / ( niFact * iFact ) + \" \" ) ; } } let A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ;"}
{"text": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | fungsi untuk mengira jumlah siri; Kod pemacu", "code": "function seiresSum ( n , a ) { let res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; } let n = 2 ; let a = [ 1 , 2 , 3 , 4 ] ; document . write ( seiresSum ( n , a ) ) ;"}
{"text": "Kuasa nombor utama 'r' dalam n! | Berfungsi untuk mengembalikan kuasa no. 'r' dalam faktorial n; Terus membahagikan n dengan kuasa 'r' dan mengemaskini kiraan; Kod pemacu", "code": "function power ( n , r ) { let count = 0 ; for ( let i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; } let n = 6 , r = 3 ; document . write ( power ( n , r ) ) ;"}
{"text": "Purata nombor natural natur pertama | Mengembalikan AVG nombor n pertama; Jumlah nombor pertama yang pertama; Purata nombor pertama yang ganjil; Kod pemacu", "code": "function avg_of_odd_num ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; } let n = 20 ; document . write ( avg_of_odd_num ( n ) ) ;"}
{"text": "Purata nombor natural natur pertama | Kembalikan purata jumlah nombor pertama yang ganjil; Kod pemacu", "code": "function avg_of_odd_num ( n ) { return n ; } var n = 8 ; document . write ( avg_of_odd_num ( n ) ) ;"}
{"text": "Program untuk mencetak segitiga Fibonacci | Berfungsi untuk mengisi nombor fibonacci dalam f []; 1 ST dan 2 ND nombor siri adalah 1 dan 1; Tambah nombor 2 sebelumnya dalam siri ini dan simpannya; Isi nombor Fibonacci dalam f [] menggunakan Fib (). Kami memerlukan n = n * (n + 1) / 2 nombor fibonacci untuk membuat segitiga ketinggian n; Untuk menyimpan nombor Fibonacci seterusnya untuk dicetak; untuk gelung untuk menjejaki bilangan baris; Untuk gelung untuk menjejaki nombor dalam setiap baris; Kod pemacu", "code": "function fib ( f , N ) { f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( var i = 3 ; i <= N ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } function fiboTriangle ( n ) { var N = ( n * ( n + 1 ) ) / 2 ; var f = [ ... Array ( N + 1 ) ] ; fib ( f , N ) ; var fiboNum = 1 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= i ; j ++ ) document . write ( f [ fiboNum ++ ] + \" \" ) ; document . write ( \" \" ) ; } } var n = 5 ; fiboTriangle ( n ) ;"}
{"text": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | Fungsi untuk mengira purata nombor ganjil; mengira nombor ganjil; Simpan jumlah nombor ganjil; fungsi pemacu", "code": "function averageOdd ( n ) { if ( n % 2 == 0 ) { document . write ( \" \" ) ; return - 1 ; } let sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } let n = 15 ; document . write ( averageOdd ( n ) ) ;"}
{"text": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | Fungsi untuk mengira purata nombor ganjil; fungsi pemacu", "code": "function averageOdd ( n ) { if ( n % 2 == 0 ) { document . write ( \" \" ) ; return - 1 ; } return ( n + 1 ) / 2 ; } let n = 15 ; document . write ( averageOdd ( n ) ) ;"}
{"text": "Cari Max Dua Nombor Rasional | Program JavaScript untuk mencari Max antara dua nombor rasional; Dapatkan LCM dua nombor; Dapatkan nombor rasional maksimum; Cari LCM yang pertama. Penyebut dan Sec. penyebut; Mengisytiharkan NUME1 dan NUME2 untuk mendapatkan nilai pengangka pertama dan pengangka kedua; Kod pemacu", "code": "class Rational { constructor ( nume , deno ) { this . nume = nume ; this . deno = deno ; } } function lcm ( a , b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; } function maxRational ( first , sec ) { let k = lcm ( first . deno , sec . deno ) ; let nume1 = first . nume ; let nume2 = sec . nume ; nume1 *= k / ( first . deno ) ; nume2 *= k / ( sec . deno ) ; return ( nume2 < nume1 ) ? first : sec ; } function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } let first = new Rational ( 3 , 2 ) ; let sec = new Rational ( 3 , 4 ) ; let res = maxRational ( first , sec ) ; document . write ( res . nume + \" \" + res . deno ) ;"}
{"text": "Trinomial Triangle | Fungsi untuk mencari nilai segitiga trinomial. ; Kes asas; Kes asas; langkah rekursif. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; Kod pemacu", "code": "function TrinomialValue ( n , k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ; } function printTrinomial ( n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = - i ; j <= 0 ; j ++ ) document . write ( TrinomialValue ( i , j ) + \" \" ) ; for ( let j = 1 ; j <= i ; j ++ ) document . write ( TrinomialValue ( i , j ) + \" \" ) ; document . write ( \" \" ) ; } } let n = 4 ; printTrinomial ( n ) ;"}
{"text": "Trinomial Triangle | Program JavaScript untuk mencetak segitiga trinomial. ; Fungsi untuk mencari nilai segitiga trinomial. ; Menggunakan harta segitiga trinomial. ; Jika nilai sudah dikira, kembalikan itu. ; Kes asas; Kes asas; langkah rekursif dan menyimpan nilai. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; Program yang didorong", "code": "var MAX = 10 function TrinomialValue ( dp , n , k ) { if ( k < 0 ) k = - k ; if ( dp [ n ] [ k ] != 0 ) return dp [ n ] [ k ] ; if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return ( dp [ n ] [ k ] = TrinomialValue ( dp , n - 1 , k - 1 ) + TrinomialValue ( dp , n - 1 , k ) + TrinomialValue ( dp , n - 1 , k + 1 ) ) ; } function printTrinomial ( n ) { var dp = Array . from ( Array ( MAX ) , ( ) => Array ( MAX ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = - i ; j <= 0 ; j ++ ) document . write ( TrinomialValue ( dp , i , j ) + \" \" ) ; for ( var j = 1 ; j <= i ; j ++ ) document . write ( TrinomialValue ( dp , i , j ) + \" \" ) ; document . write ( \" \" ) ; } } var n = 4 ; printTrinomial ( n ) ;"}
{"text": "Jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan N | fungsi untuk mencari jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan n; Buat array Integer \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai 0. Nilai dalam Perdana [i] akhirnya akan menjadi 0 jika 'I' adalah perdana, jika tidak, ia akan mengandungi faktor utama terbesar 'I'. ; Jika Perdana [P] adalah '0', maka ia adalah nombor utama; Kemas kini semua gandaan P; Merangkumi faktor utama terbesar bagi semua nombor; Jika 'p' adalah nombor bukan utama maka perdana [p] memberikan faktor utama largesr; 'P' adalah nombor utama; Jumlah yang diperlukan; Kod pemacu", "code": "function sumOfLargePrimeFactor ( n ) { let prime = new Array ( n + 1 ) ; let sum = 0 ; let max = n / 2 ; for ( let i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = 0 ; for ( let p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( let p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) sum += prime [ p ] ; else sum += p ; } return sum ; } let n = 12 ; document . write ( \" \" + sumOfLargePrimeFactor ( n ) ) ;"}
{"text": "Jumlah gandaan nombor sehingga n | Berfungsi untuk mengira jumlah gandaan sehingga n; Bilangan gandaan; Jumlah nombor semulajadi pertama; Jumlah gandaan; Kod pemacu", "code": "function calculate_sum ( a , N ) { m = N / a ; sum = m * ( m + 1 ) / 2 ; ans = a * sum ; return ans ; } let a = 7 ; let N = 49 ; document . write ( \" \" + a + \" \" + N + \" \" + calculate_sum ( a , N ) ) ;"}
{"text": "Memandangkan jumlah besar semak jika ia adalah kuasa dua. | Berfungsi untuk memeriksa sama ada nombor adalah kuasa 2 atau tidak; Kod pemacu", "code": "function ispowerof2 ( num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; } var num = 549755813888 ; document . write ( ispowerof2 ( num ) ) ;"}
{"text": "Pengiraan Pembahagi Array Multiplikasi | Untuk mengira bilangan faktor dalam nombor; Inisialisasi kiraan dengan 0; Kiraan kenaikan untuk setiap faktor nombor x yang diberikan. ; Pulangan bilangan faktor; Mengembalikan bilangan pembahagi dalam pendaraban array; Mengumpulkan semua elemen array yang diberikan. ; Fungsi panggilan yang mengira bilangan faktor nombor; fungsi pemacu", "code": "function counDivisors ( X ) { let count = 0 ; for ( let i = 1 ; i <= X ; ++ i ) { if ( X % i == 0 ) { count ++ ; } } return count ; } function countDivisorsMult ( arr , n ) { let mul = 1 ; for ( let i = 0 ; i < n ; ++ i ) mul *= arr [ i ] ; return counDivisors ( mul ) ; } let arr = [ 2 , 4 , 6 ] ; let n = arr . length ; document . write ( countDivisorsMult ( arr , n ) ) ;"}
{"text": "Pengiraan Pembahagi Array Multiplikasi | Program JavaScript untuk mengira pembahagi dalam pendaraban array. ; Buat array Boolean \"Isprime [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Isprime [i] akhirnya akan menjadi palsu jika saya bukannya Isprime, yang lain benar. ; Jika Isprime [p] tidak berubah, maka ia adalah isprime; Kemas kini semua gandaan P; Cetak semua nombor isprime; Mengembalikan bilangan pembahagi dalam pendaraban array; Cari semua nombor perdana yang lebih kecil daripada elemen terbesar. ; Cari tuduhan kejadian setiap faktor utama; Mengira kiraan semua pembahagi menggunakan kiraan faktor utama. ; Kod pemacu", "code": "function SieveOfEratosthenes ( largest , prime ) { var isPrime = Array ( largest + 1 ) . fill ( true ) ; var p , i ; for ( p = 2 ; p * p <= largest ; p ++ ) { if ( isPrime [ p ] == true ) { for ( i = p * 2 ; i <= largest ; i += p ) isPrime [ i ] = false ; } } for ( p = 2 ; p <= largest ; p ++ ) if ( isPrime [ p ] ) prime . push ( p ) ; } function countDivisorsMult ( arr , n ) { var largest = Math . max . apply ( null , arr ) ; var prime = [ ] ; SieveOfEratosthenes ( largest , prime ) ; var j ; var mp = new Map ( ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < prime . length ; j ++ ) { while ( arr [ i ] > 1 && arr [ i ] % prime [ j ] == 0 ) { arr [ i ] /= prime [ j ] ; if ( mp . has ( prime [ j ] ) ) mp . set ( prime [ j ] , mp . get ( prime [ j ] ) + 1 ) ; else mp . set ( prime [ j ] , 1 ) ; } } if ( arr [ i ] != 1 ) { if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; else mp . set ( arr [ i ] , 1 ) ; } } var res = 1 ; for ( const [ key , value ] of mp . entries ( ) ) { res *= ( value + 1 ) ; } return res ; } var arr = [ 2 , 4 , 6 ] ; var n = arr . length ; document . write ( countDivisorsMult ( arr , n ) ) ;"}
{"text": "K pasangan perdana jauh dalam julat yang diberikan | Berfungsi untuk menjana nombor perdana dalam julat yang diberikan [l, r]; Simpan semua nilai dalam julat; Padam 1 sebagai bukan perdana; Melakukan penapis eratosthenes; Cari pelbagai semasa; Padam kerana ia bukan perdana; Kenaikan berganda; Berfungsi untuk mencetak semua pasangan utama dalam julat yang diberikan oleh k; Menjana semua nombor perdana; Melintasi peta m; Jika ia. Pertama & (ia pertama + k) adalah perdana kemudian cetak pasangan ini; Julat yang diberikan; Diberikan k; Panggilan fungsi", "code": "function findPrimeNos ( L , R , M ) { for ( var i = L ; i <= R ; i ++ ) { if ( M . has ( i ) ) M . set ( i , M . get ( i ) + 1 ) else M . set ( i , 1 ) } if ( M . has ( 1 ) ) { M . delete ( 1 ) ; } for ( var i = 2 ; i <= parseInt ( Math . sqrt ( R ) ) ; i ++ ) { var multiple = 2 ; while ( ( i * multiple ) <= R ) { if ( M . has ( i * multiple ) ) { M . delete ( i * multiple ) ; } multiple ++ ; } } return M ; } function getPrimePairs ( L , R , K ) { var M = new Map ( ) ; M = findPrimeNos ( L , R , M ) ; M . forEach ( ( value , key ) => { if ( M . has ( key + K ) ) { document . write ( \" \" + key + \" \" + ( key + K ) + \" \" ) ; } } ) ; } var L = 1 , R = 19 ; var K = 6 ; getPrimePairs ( L , R , K ) ;"}
{"text": "Nombor EnneAcontahExagon | Berfungsi untuk mencari nombor enneacontahexagon nth; Kod pemacu", "code": "function EnneacontahexagonNum ( n ) { return ( 94 * n * n - 92 * n ) / 2 ; } let n = 3 ; document . write ( EnneacontahexagonNum ( n ) ) ;"}
{"text": "Cari dua nombor komposit supaya terdapat perbezaan adalah n | Berfungsi untuk mencari dua nombor komposit; Kod pemacu", "code": "function find_composite_nos ( n ) { document . write ( 9 * n + \" \" + 8 * n ) ; } var n = 4 ; find_composite_nos ( n ) ;"}
{"text": "Kira bilangan pasangan (i, j) supaya sama ada arr [i] boleh dibahagikan dengan arr [j] atau arr [j] boleh dibahagikan dengan arr [i] | Berfungsi untuk mencari bilangan pasangan yang tidak teratur; Elemen maksimum dari array; Array untuk menyimpan kekerapan setiap elemen; Menyimpan bilangan pasangan yang tidak teratur; Simpan kekerapan setiap elemen; Cari bilangan pasangan yang tidak teratur; Jika nombor j dibahagi dengan elemen ith hadir dalam array; Jika elemen ith array mempunyai kekerapan lebih daripada satu; Kod pemacu", "code": "function freqPairs ( arr , n ) { let max = Math . max ( ... arr ) ; let freq = new Array ( max + 1 ) . fill ( 0 ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) count += freq [ j ] ; } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; } let arr = [ 3 , 2 , 4 , 2 , 6 ] ; let n = arr . length ; document . write ( freqPairs ( arr , n ) ) ;"}
{"text": "Cari istilah n Siri 1 + 2 + 6 + 15 + 31 + 56 + ... | Hitung istilah n siri yang diberikan; Kod pemacu", "code": "function Nth_Term ( n ) { return ( 2 * Math . pow ( n , 3 ) - 3 * Math . pow ( n , 2 ) + n + 6 ) / 6 ; } let N = 8 ; document . write ( Nth_Term ( N ) ) ;"}
{"text": "Program untuk mencari n | Fungsi untuk mencari nombor n - th dalam siri yang diperbuat daripada 3 dan 5; Buat pelbagai saiz (n + 1); Sekiranya saya ganjil; fungsi utama", "code": "function prletNthElement ( n ) { let arr = Array ( n + 1 ) . fill ( 0 ) ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; } let n = 6 ; document . write ( prletNthElement ( n ) ) ;"}
{"text": "Program untuk mencari istilah n Siri 3, 6, 18, 24, ... | fungsi untuk mengira istilah siri nth; Dengan menggunakan formula di atas; Dapatkan nilai n; Hitung dan cetak istilah n", "code": "function nthTerm ( N ) { return parseInt ( N * ( parseInt ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; } let N = 5 ; document . write ( \" \" + N + \" \" + nthTerm ( N ) ) ;"}
{"text": "Program untuk mencetak Siri Pengembangan Binomial | berfungsi untuk mencetak siri; Mengira dan mencetak istilah pertama; Pengkomputeran dan percetakan yang tersisa; Cari istilah semasa menggunakan terma sebelumnya, kami meningkatkan kuasa x oleh 1, kuasa penurunan sebanyak 1 dan mengira NCI menggunakan istilah sebelumnya dengan mengalikan istilah sebelumnya dengan (n - i + 1) / i; Fungsi utama bermula", "code": "function series ( A , X , n ) { let term = Math . pow ( A , n ) ; document . write ( term + \" \" ) ; for ( let i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; document . write ( term + \" \" ) ; } } let A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ;"}
{"text": "Semak jika nombor dibahagikan dengan 8 menggunakan pengendali bitwise | Fungsi untuk memeriksa nombor div oleh 8 atau tidak menggunakan pengendali bitwise; Kod pemacu", "code": "function Div_by_8 ( n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; } var n = 16 ; if ( Div_by_8 ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | Fungsi untuk mengira purata nombor walaupun; mengira nombor walaupun; Simpan jumlah nombor walaupun; fungsi pemacu", "code": "function averageEven ( n ) { if ( n % 2 != 0 ) { document . write ( \" \" ) ; return - 1 ; } let sum = 0 , count = 0 ; while ( n >= 2 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } let n = 16 ; document . write ( averageEven ( n ) ) ;"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | Fungsi untuk mengira purata nombor walaupun; fungsi pemacu", "code": "function averageEven ( n ) { if ( n % 2 != 0 ) { document . write ( \" \" ) ; return - 1 ; } return ( n + 2 ) / 2 ; } let n = 16 ; document . write ( averageEven ( n ) ) ;"}
{"text": "Nombor terbesar yang membahagikan x dan co | Fungsi rekursif untuk mengembalikan GCD A dan B; Semuanya membahagikan 0; Kes asas; A lebih besar; berfungsi untuk mencari pembahagi coprime terbesar; Kod pemacu", "code": "function gcd ( a , b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } function cpFact ( x , y ) { while ( gcd ( x , y ) != 1 ) { x = x / gcd ( x , y ) ; } return x ; } let x = 15 ; let y = 3 ; document . write ( cpFact ( x , y ) + \" \" ) ; x = 14 ; y = 28 ; document . write ( cpFact ( x , y ) , \" \" ) ; x = 7 ; y = 3 ; document . write ( cpFact ( x , y ) ) ;"}
{"text": "Kira nombor dengan unit digit k dalam julat yang diberikan | Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; Kod pemacu", "code": "function counLastDigitK ( low , high , k ) { let count = 0 ; for ( let i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; } let low = 3 ; let high = 35 ; let k = 3 ; document . write ( counLastDigitK ( low , high , k ) ) ;"}
{"text": "Nombor Taxicab | Pelaksanaan JavaScript untuk mencetak nombor pertama N Taxicab (2) :; Bermula dari 1, periksa setiap nombor jika ia adalah Taxicab sehingga Count mencapai n. ; Cuba semua pasangan yang mungkin (j, k) yang jumlah kiubnya boleh saya. ; Taxicab (2) dijumpai; Kod pemacu", "code": "function printTaxicab2 ( N ) { let i = 1 ; count = 0 ; while ( count < N ) { let int_count = 0 ; for ( let j = 1 ; j <= Math . pow ( i , 1.0 / 3 ) ; j ++ ) for ( let k = j + 1 ; k <= Math . pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; document . write ( count + \" \" + i + \" \" ) ; } i ++ ; } } let N = 5 ; printTaxicab2 ( N ) ;"}
{"text": "Nombor Komposit | Program JavaScript berasaskan kaedah sekolah yang dioptimumkan untuk memeriksa sama ada nombor adalah komposit. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Program pemacu untuk menguji fungsi di atas", "code": "function isComposite ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } isComposite ( 11 ) ? document . write ( \" \" + \" \" ) : document . write ( \" \" + \" \" ) ; isComposite ( 15 ) ? document . write ( \" \" + \" \" ) : document . write ( \" \" + \" \" ) ;"}
{"text": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Semak dari 2 hingga n - 1; Cari nombor perdana lebih besar daripada nombor; Cari perdana lebih besar daripada n; Semak jika Num adalah Perdana; kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Untuk mencari jumlah elemen array; jika jumlah sudah menjadi pulangan utama 0; Untuk mencari nombor perdana lebih besar daripada jumlah; Mengembalikan perbezaan jumlah dan num; Kod pemacu", "code": "function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } function findPrime ( n ) { let num = n + 1 ; while ( num > 0 ) { if ( isPrime ( num ) ) return num ; num = num + 1 ; } return 0 ; } function minNumber ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( isPrime ( sum ) ) return 0 ; let num = findPrime ( sum ) ; return num - sum ; } let arr = [ 2 , 4 , 6 , 8 , 12 ] ; let n = arr . length ; document . write ( minNumber ( arr , n ) ) ;"}
{"text": "Jumlah pembahagi faktorial nombor | fungsi untuk mengira faktorial; berfungsi untuk mengira jumlah pembahagi; Mengembalikan jumlah pembahagi N! ; Kod pemacu", "code": "function fact ( n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } function div ( x ) { let ans = 0 ; for ( let i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; } function sumFactDiv ( n ) { return div ( fact ( n ) ) ; } let n = 4 ; document . write ( sumFactDiv ( n ) ) ;"}
{"text": "Jumlah pembahagi faktorial nombor | AllPrimes [] menyimpan semua nombor utama kurang daripada atau sama dengan n. ; Mengisi di atas vektor allprimes [] untuk n yang diberikan; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Gelung untuk mengemas kini perdana []; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Menyimpan prima dalam vektor AllPrimes; Fungsi untuk mencari semua hasil nombor faktorial; Buat ayak; Memulakan hasil; Cari eksponen semua prima yang membahagikan n dan kurang daripada n; Pembahagi semasa; Cari kuasa tertinggi (disimpan dalam exp) '' using ; Menggunakan fungsi pembahagi untuk mengira jumlah; Mengembalikan jumlah pembahagi; Kod pemacu", "code": "let allPrimes = [ ] ; function sieve ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . push ( p ) ; } function factorialDivisors ( n ) { sieve ( n ) ; let result = 1 ; for ( let i = 0 ; i < allPrimes . length ; i ++ ) { let p = allPrimes [ i ] ; let exp = 0 ; while ( p <= n ) { exp = exp + Math . floor ( n / p ) ; p = p * allPrimes [ i ] ; } result = Math . floor ( result * ( Math . pow ( allPrimes [ i ] , exp + 1 ) - 1 ) / ( allPrimes [ i ] - 1 ) ) ; } return result ; } document . write ( factorialDivisors ( 4 ) ) ;"}
{"text": "Nombor Pandigital dalam pangkalan yang diberikan | Kembali benar jika n adalah pandigit lain kembali palsu. ; Panjang pemeriksaan kurang daripada asas; Melintasi setiap digit nombor. ; Jika digit adalah integer; Jika digit adalah abjad; Memeriksa array hash, jika mana -mana indeks tidak ditandakan. ; Program Pemandu", "code": "function checkPandigital ( b , n ) { if ( n . length < b ) return 0 ; let hash = [ ] ; for ( let i = 0 ; i < b ; i ++ ) hash [ i ] = 0 ; for ( let i = 0 ; i < n . length ; i ++ ) { if ( n [ i ] >= ' ' && n [ i ] <= ' ' ) hash [ n [ i ] - ' ' ] = 1 ; else if ( n . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) <= b - 11 ) hash [ n . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) + 10 ] = 1 ; } for ( let i = 0 ; i < b ; i ++ ) if ( hash [ i ] == 0 ) return 0 ; return 1 ; } let b = 13 ; let n = \" \" ; if ( checkPandigital ( b , n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Tukar nombor m ke n menggunakan bilangan minimum operasi yang diberikan | berfungsi untuk mencari bilangan minimum operasi yang diberikan untuk menukar m ke n; Hanya cara yang perlu dilakukan - 1 (m - n) kali; tidak mungkin; N lebih besar dan n adalah ganjil; lakukan ' - 1' pada m (atau + 1 pada n); n adalah juga; lakukan ' * 2' pada m (atau n / 2 pada n); Kod pemacu", "code": "function convert ( m , n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return - 1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; } var m = 3 , n = 11 ; document . write ( \" \" + \" \" + convert ( m , n ) ) ;"}
{"text": "Biji (atau akar benih) nombor | Program JavaScript untuk mencari benih nombor; Kedai produk digit x dalam proddig [x]; Jika x mempunyai angka tunggal; Jika produk digit sudah dikira; Jika produk digit tidak dikira sebelum ini. ; Mencetak semua benih n; Cari semua biji menggunakan Proddig; Sekiranya tidak ada benih; Cetak biji; Kod pemacu", "code": "var MAX = 10000 ; var prodDig = Array . from ( { length : MAX } , ( _ , i ) => 0 ) ; function getDigitProduct ( x ) { if ( x < 10 ) return x ; if ( prodDig [ x ] != 0 ) return prodDig [ x ] ; var prod = ( x % 10 ) * getDigitProduct ( parseInt ( x / 10 ) ) ; return ( prodDig [ x ] = prod ) ; } function findSeed ( n ) { var res = [ ] ; for ( var i = 1 ; i <= parseInt ( n / 2 ) ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . push ( i ) ; if ( res . length == 0 ) { document . write ( \" \" ) ; return ; } for ( i = 0 ; i < res . length ; i ++ ) document . write ( res [ i ] + \" \" ) ; } var n = 138 ; findSeed ( n ) ;"}
{"text": "Nombor dengan bilangan maksimum faktor utama | Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Sieve kaedah Eratosthenes untuk mengira bilangan faktor utama. ; Mencari nombor yang mempunyai jumlah maksimum faktor utama. ; Program Pemandu", "code": "function maxPrimefactorNum ( N ) { var arr = Array . from ( { length : N + 5 } , ( _ , i ) => 0 ) ; for ( i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) { for ( j = 2 * i ; j <= N ; j += i ) { arr [ j ] ++ ; } } arr [ i ] = 1 ; } var maxval = 0 , maxvar = 1 ; for ( i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxvar = i ; } } return maxvar ; } var N = 40 ; document . write ( maxPrimefactorNum ( N ) ) ;"}
{"text": "Jumlah semua subarray | Tetapkan 1 | Fungsi mengira jumlah semua sub - array; Jumlah pengkomputeran subarray menggunakan formula; Kembali semua jumlah subarray; Kod pemacu", "code": "function SubArraySum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; } let arr = [ 1 , 2 , 3 ] ; let n = arr . length ; document . write ( \" \" + SubArraySum ( arr , n ) ) ;"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program JavaScript untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Jika saya adalah kuasa 2; Kod pemacu", "code": "function highestPowerof2 ( n ) { let res = 0 ; for ( let i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; } let n = 10 ; document . write ( highestPowerof2 ( n ) ) ;"}
{"text": "Cari Pasangan Cube | Tetapkan 2 (A N ^ (1/3) Penyelesaian) | Fungsi untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Cari akar kiub n; Buat pelbagai saiz saiz 'cuberoot'; Untuk indeks i, kiub [i] akan mengandungi i ^ 3; Cari semua pasangan di atas kubus array yang disusun di atas yang jumlahnya sama dengan n; Kod pemacu", "code": "function findPairs ( n ) { var cubeRoot = parseInt ( Math . pow ( n , 1.0 / 3.0 ) ) ; var cube = Array . from ( { length : cubeRoot + 1 } , ( _ , i ) => 0 ) ; for ( i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; var l = 1 ; var r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { document . write ( \" \" + l + \" \" + r + \" \" ) ; l ++ ; r -- ; } } } var n = 20683 ; findPairs ( n ) ;"}
{"text": "Cari perbezaan minimum antara jadual beralih dua nombor | Fungsi utiliti untuk mencari GCD A dan B; Mengembalikan perbezaan minimum antara dua terma jadual beralih 'A' dan 'B'. 'X' adalah peralihan dalam jadual 'a' dan 'y' adalah peralihan dalam jadual 'b'. ; Kirakan GCD A dan B; Kirakan perbezaan antara x dan y; Kod pemacu", "code": "function gcd ( a , b ) { while ( b != 0 ) { let t = b ; b = a % b ; a = t ; } return a ; } function findMinDiff ( a , b , x , y ) { let g = gcd ( a , b ) ; let diff = Math . abs ( x - y ) % g ; return Math . min ( diff , g - diff ) ; } let a = 20 , b = 52 , x = 5 , y = 7 ; document . write ( findMinDiff ( a , b , x , y ) ) ;"}
{"text": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | berfungsi untuk mencetak pembahagi; Vektor untuk menyimpan separuh daripada pembahagi; Semak jika pembahagi adalah sama; Tolak pembahagi kedua dalam vektor; Vektor akan dicetak secara terbalik; Kod pemacu", "code": "function printDivisors ( n ) { let v = [ ] ; let t = 0 ; for ( let i = 1 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i ) == i ) document . write ( i + \" \" ) ; else { document . write ( i + \" \" ) ; v [ t ++ ] = parseInt ( n / i ) ; } } } for ( let i = v . length - 1 ; i >= 0 ; i -- ) { document . write ( v [ i ] + \" \" ) ; } } document . write ( \" \" ) ; printDivisors ( 100 ) ;"}
{"text": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | berfungsi untuk mencetak pembahagi; Program pemacu untuk menguji fungsi di atas", "code": "function printDivisors ( n ) { for ( var i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) document . write ( i + \" \" ) ; } for ( var i = Math . sqrt ( n ) ; i >= 1 ; i -- ) { if ( n % i == 0 ) document . write ( \" \" + n / i ) ; } } document . write ( \" \" ) ; printDivisors ( 100 ) ;"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | berfungsi untuk mencetak pembahagi; Program pemacu untuk menguji fungsi di atas", "code": "function printDivisors ( n ) { for ( i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) document . write ( i + \" \" ) ; } document . write ( \" \" + \" \" ) ; printDivisors ( 100 ) ;"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | Berfungsi untuk mencetak pembahagi; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi adalah sama, cetak hanya satu; Jika tidak cetak kedua -duanya; Kod pemacu", "code": "function printDivisors ( n ) { for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i , 10 ) == i ) document . write ( i ) ; else document . write ( i + \" \" + parseInt ( n / i , 10 ) + \" \" ) ; } } } document . write ( \" \" ) ; printDivisors ( 100 ) ;"}
{"text": "Sieve of Atkin | Program JavaScript untuk pelaksanaan SIEVE OF ATKIN; 2 dan 3 dikenali sebagai Perdana; Memulakan array penapis dengan nilai palsu; Mark Sieve [n] adalah benar jika salah satu daripada yang berikut adalah benar: a) n = (4 * x * x) + (y * y) mempunyai bilangan penyelesaian yang ganjil, i. e. , terdapat bilangan pasangan yang berbeza (x, y) yang memenuhi persamaan dan n % 12 = 1 atau n % 12 = 5. b) n = (3 * x * x) + (y * y) mempunyai bilangan penyelesaian yang ganjil dan n % 12 = 7 c) Bahagian utama SIEVE OF ATKIN; Tandakan semua gandaan dataran sebagai bukan perdana; Cetak prima menggunakan ayak []; Kod pemacu", "code": "function SieveOfAtkin ( limit ) { if ( limit > 2 ) document . write ( 2 + \" \" ) ; if ( limit > 3 ) document . write ( 3 + \" \" ) ; let sieve = new Array ( ) sieve [ limit ] = 0 ; for ( let i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( let x = 1 ; x * x < limit ; x ++ ) { for ( let y = 1 ; y * y < limit ; y ++ ) { let n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] = true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( let r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( let a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) document . write ( a , \" \" ) ; } let limit = 20 ; SieveOfAtkin ( limit ) ;"}
{"text": "Cari jika titik terletak di dalam bulatan | Program JavaScript untuk memeriksa sama ada titik terletak di dalam bulatan atau tidak; Bandingkan jejari bulatan dengan jarak pusatnya dari titik yang diberikan; Kod pemacu", "code": "function isInside ( circle_x , circle_y , rad , x , y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; } var x = 1 ; var y = 1 ; var circle_x = 0 ; var circle_y = 1 ; var rad = 2 ; if ( isInside ( circle_x , circle_y , rad , x , y ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Cari semua kemungkinan hasil ekspresi yang diberikan | Fungsi utiliti untuk menilai ungkapan mudah dengan satu pengendali sahaja. ; Fungsi ini menilai semua nilai yang mungkin dan mengembalikan senarai nilai yang dinilai. ; Untuk menyimpan hasil (semua kemungkinan penilaian ekspresi 'expr'); Sekiranya terdapat hanya satu watak, ia mestilah digit (atau operan), kembalikannya. ; Sekiranya terdapat hanya tiga aksara, pertengahan mestilah pengendali dan sudut mesti beroperasi; Setiap saya merujuk kepada pengendali; l merujuk kepada semua nilai yang mungkin di sebelah kiri pengendali 'expr [i]'; r merujuk kepada semua nilai yang mungkin di sebelah kanan pengendali 'expr [i]'; Ambil di atas menilai semua nilai yang mungkin di sebelah kiri 'I'; Ambil di atas menilai semua nilai yang mungkin di sebelah kanan 'I'; Kirakan nilai untuk setiap pasangan dan tambahkan nilai yang dihasilkan. ; Program Pemandu", "code": "function eval ( a , op , b ) { if ( op == ' ' ) { return a + b ; } if ( op == ' ' ) { return a - b ; } if ( op == ' ' ) { return a * b ; } return Number . MAX_VALUE ; } function evaluateAll ( expr , low , high ) { let res = [ ] ; if ( low == high ) { res . push ( expr [ low ] - ' ' ) ; return res ; } if ( low == ( high - 2 ) ) { let num = eval ( expr [ low ] - ' ' , expr [ low + 1 ] , expr [ low + 2 ] - ' ' ) ; res . push ( num ) ; return res ; } for ( let i = low + 1 ; i <= high ; i += 2 ) { let l = evaluateAll ( expr , low , i - 1 ) ; let r = evaluateAll ( expr , i + 1 , high ) ; for ( let s1 = 0 ; s1 < l . length ; s1 ++ ) { for ( let s2 = 0 ; s2 < r . length ; s2 ++ ) { let val = eval ( l [ s1 ] , expr [ i ] , r [ s2 ] ) ; res . push ( val ) ; } } } return res ; } let expr = \" \" ; let len = expr . length ; let ans = evaluateAll ( expr , 0 , len - 1 ) ; for ( let i = 0 ; i < ans . length ; i ++ ) { document . write ( ans [ i ] + \" \" ) ; }"}
{"text": "Program untuk memeriksa sama ada nombor tertentu bernasib baik (semua digit adalah berbeza) | Fungsi ini kembali benar jika n bernasib baik; Buat pelbagai saiz 10 dan mulakan semua elemen sebagai palsu. Arahan ini digunakan untuk memeriksa sama ada digit sudah dilihat atau tidak. ; Melintasi semua digit nombor yang diberikan; Cari digit terakhir; Jika digit sudah dilihat, kembali palsu; Tandakan digit ini seperti yang dilihat; Keluarkan digit terakhir dari nombor; Program pemacu untuk menguji fungsi di atas.", "code": "function isLucky ( n ) { var arr = Array ( 10 ) . fill ( 0 ) ; for ( var i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { var digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = parseInt ( n / 10 ) ; } return true ; } var arr = [ 1291 , 897 , 4566 , 1232 , 80 , 700 ] var n = arr . length ; for ( var i = 0 ; i < n ; i ++ ) isLucky ( arr [ i ] ) ? document . write ( arr [ i ] + \" \" ) : document . write ( arr [ i ] + \" \" ) ;"}
{"text": "Cetak kotak pertama N Nombor Semulajadi tanpa menggunakan *, / dan | Program JavaScript untuk mencetak dataran pertama 'n' Nombor semulajadi menggunakan *, / dan -; Memulakan 'persegi' dan nombor ganjil pertama; Mengira dan mencetak kotak; Cetak dataran; Kemas kini 'persegi' dan 'ganjil'; Program pemacu untuk menguji fungsi di atas", "code": "function printSquares ( n ) { let square = 0 , odd = 1 ; for ( let x = 0 ; x < n ; x ++ ) { document . write ( square + \" \" ) ; square = square + odd ; odd = odd + 2 ; } } let n = 5 ; printSquares ( n ) ;"}
{"text": "Tulis program untuk membalikkan digit nombor | Fungsi rekursif untuk membalikkan digit NUM; Kod pemacu", "code": "var rev_num = 0 ; var base_pos = 1 ; function reversDigits ( num ) { if ( num > 0 ) { reversDigits ( Math . floor ( num / 10 ) ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; } let num = 4562 ; document . write ( \" \" + reversDigits ( num ) ) ;"}
{"text": "Cari nombor sedemikian rupa sehingga maksimum dalam array adalah minimum mungkin selepas xor | Fungsi rekursif yang mencari nilai minimum selepas eksklusif - atau; Keadaan jika saiz ref adalah sifar atau bit adalah negatif maka kembali 0; Keadaan jika bit semasa dimatikan kemudian tolak nilai semasa dalam vektor curr_off; Keadaan jika bit semasa berada di kemudian tolak nilai semasa dalam vektor curr_on; Keadaan jika curr_off kosong maka hubungi fungsi rekursif pada vektor curr_on; Keadaan jika curr_on kosong maka hubungi fungsi rekursif pada vektor curr_off; Kembalikan minimum curr_off dan curr_on dan tambah kuasa 2 bit semasa; Fungsi yang mencetak nilai minimum selepas eksklusif - atau; Menolak nilai dalam vektor; Jawapan percetakan; Kod pemacu", "code": "function RecursiveFunction ( ref , bit ) { if ( ref . length == 0 bit < 0 ) return 0 ; let curr_on = [ ] , curr_off = [ ] ; for ( let i = 0 ; i < ref . length ; i ++ ) { if ( ( ( ref [ i ] >> bit ) & 1 ) == 0 ) curr_off . push ( ref [ i ] ) ; else curr_on . push ( ref [ i ] ) ; } if ( curr_off . length == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ; if ( curr_on . length == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ; return Math . min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; } function PrintMinimum ( a , n ) { let v = [ ] ; for ( let i = 0 ; i < n ; i ++ ) v . push ( a [ i ] ) ; document . write ( RecursiveFunction ( v , 30 ) + \" \" ) ; } let arr = [ 3 , 2 , 1 ] ; let size = arr . length ; PrintMinimum ( arr , size ) ;"}
{"text": "Count of Elements yang sama dengan XOR dari dua elemen berikutnya | Fungsi untuk mengembalikan kiraan elemen yang sama dengan XOR dari dua elemen berikutnya; Untuk menyimpan kiraan yang diperlukan; Untuk setiap elemen array supaya ia mempunyai sekurang -kurangnya dua elemen yang muncul selepas itu dalam array; Jika elemen semasa adalah sama dengan XOR dari dua elemen seterusnya dalam array; Kod pemacu", "code": "function cntElements ( arr , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; } let arr = [ 4 , 2 , 1 , 3 , 7 , 8 ] ; let n = arr . length ; document . write ( cntElements ( arr , n ) ) ;"}
{"text": "Bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama | Berfungsi untuk mengembalikan kiraan; Hasil permulaan; Pilih unsur 1 triplet; Pilih elemen 2 nd triplet; Pilih 3 elemen triplet; Mengambil XOR dalam subarray pertama; Mengambil XOR dalam subarray kedua; Jika kedua -dua XOR adalah sama; Kod pemacu; Fungsi panggilan", "code": "function xor_triplet ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = j ; k < n ; k ++ ) { let xor1 = 0 , xor2 = 0 ; for ( let x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( let x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let n = arr . length ; document . write ( xor_triplet ( arr , n ) )"}
{"text": "Cari bilangan sepasang nod yang ideal di pokok tertentu | Pelaksanaan JavaScript pendekatan; Senarai Adjacency; Bit: Bit Array I dan J memulakan dan menamatkan indeks termasuk; bit: array bit n: saiz array bit i adalah indeks yang akan dikemas kini diff adalah (new_val - old_val); Fungsi DFS untuk mencari pasangan yang ideal; Fungsi untuk inisialisasi; Berfungsi untuk menambah kelebihan; Berfungsi untuk mencari bilangan pasangan yang ideal; Cari akar pokok; Kod pemacu; Tambah tepi; Panggilan fungsi", "code": "let N = 100005 ; let n , k ; let al = new Array ( N ) . fill ( 0 ) . map ( ( t ) => [ ] ) ; let Ideal_pair ; let bit = new Array ( N ) ; let root_node = new Array ( N ) ; function bit_q ( i , j ) { let sum = 0 ; while ( j > 0 ) { sum += bit [ j ] ; j -= ( j & ( j * - 1 ) ) ; } i -- ; while ( i > 0 ) { sum -= bit [ i ] ; i -= ( i & ( i * - 1 ) ) ; } return sum ; } function bit_up ( i , diff ) { while ( i <= n ) { bit [ i ] += diff ; i += i & - i ; } } function dfs ( node ) { Ideal_pair += bit_q ( Math . max ( 1 , node - k ) , Math . min ( n , node + k ) ) ; bit_up ( node , 1 ) ; for ( let i = 0 ; i < al [ node ] . length ; i ++ ) dfs ( al [ node ] [ i ] ) ; bit_up ( node , - 1 ) ; } function initialise ( ) { Ideal_pair = 0 ; for ( let i = 0 ; i <= n ; i ++ ) { root_node [ i ] = true ; bit [ i ] = 0 ; } } function Add_Edge ( x , y ) { al [ x ] . push ( y ) ; root_node [ y ] = false ; } function Idealpairs ( ) { let r = - 1 ; for ( let i = 1 ; i <= n ; i ++ ) if ( root_node [ i ] ) { r = i ; break ; } dfs ( r ) ; return Ideal_pair ; } n = 6 , k = 3 ; initialise ( ) ; Add_Edge ( 1 , 2 ) ; Add_Edge ( 1 , 3 ) ; Add_Edge ( 3 , 4 ) ; Add_Edge ( 3 , 5 ) ; Add_Edge ( 3 , 6 ) ; document . write ( Idealpairs ( ) ) ;"}
{"text": "Cetak bitwise dan set nombor n | Berfungsi untuk mencari pendekatan yang cekap subset bitwise; Kod pemacu", "code": "function printSubsets ( n ) { for ( let i = n ; i > 0 ; i = ( i - 1 ) & n ) document . write ( i + \" \" ) ; document . write ( \" \" + \" \" ) ; } let n = 9 ; printSubsets ( n ) ;"}
{"text": "Semak jika nombor dibahagikan dengan 17 menggunakan pengendali bitwise | fungsi untuk memeriksa secara rekursif jika nombor itu boleh dibahagikan dengan 17 atau tidak; jika n = 0 atau n = 17 maka ya; jika n kurang dari 17, tidak boleh dibahagikan dengan 17; mengurangkan nombor mengikut lantai (n / 16) - n % 16; kod pemacu untuk memeriksa fungsi di atas", "code": "function isDivisibleby17 ( n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( Math . floor ( n >> 4 ) - Math . floor ( n & 15 ) ) ; } let n = 35 ; if ( isDivisibleby17 ( n ) ) document . write ( n + \" \" ) ; else document . write ( n + \" \" ) ;"}
{"text": "Nombor terbesar dengan perwakilan binari ialah M 1 dan M | Mengembalikan nombor terbesar dengan bit set M kemudian m - 1 0 bit. ; Mulakan dengan 2 bit. ; Jawapan awal adalah 1 yang memenuhi syarat yang diberikan; Semak semua nombor; mengira nombor; jika kurang kemudian n; kenaikan m untuk mendapatkan nombor seterusnya; Kod pemacu", "code": "function answer ( n ) { let m = 2 ; let ans = 1 ; let r = 1 ; while ( r < n ) { r = ( Math . pow ( 2 , m ) - 1 ) * ( Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; } let n = 7 ; document . write ( answer ( n ) ) ;"}
{"text": "Cari bit set yang paling ketara | Program JavaScript untuk mencari nombor MSB untuk diberikan n. ; Kod pemacu", "code": "function setBitNumber ( n ) { if ( n == 0 ) return 0 ; let msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = $n / 2 ; msb ++ ; } return ( 1 << msb ) ; } let n = 0 ; document . write ( setBitNumber ( n ) ) ;"}
{"text": "Cari bit set yang paling ketara | Program JavaScript untuk mencari nombor MSB untuk diberikan n. ; Katakan N ialah 273 (binari ialah 100010001). Ia mengikuti 100010001 | 010001000 = 110011001; Ini memastikan 4 bit (dari MSB dan termasuk MSB) ditetapkan. Ia mengikuti 110011001 | 001100110 = 111111111; Kenaikan n oleh 1 supaya hanya ada satu set bit yang hanya sebelum MSB asal. n kini menjadi 1000000000; Kembalikan MSB asal selepas beralih. n kini menjadi 100000000; Kod pemacu", "code": "function setBitNumber ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; } let n = 273 ; document . write ( setBitNumber ( n ) ) ;"}
{"text": "Count Trailing Zero Bits Menggunakan Table Lookup | Kod JavaScript mudah untuk mengira sifar trailing dalam perwakilan binari nombor; Kod pemacu", "code": "function countTrailingZero ( x ) { let count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; } document . write ( countTrailingZero ( 11 ) ) ;"}
{"text": "Count Trailing Zero Bits Menggunakan Table Lookup | Kod JavaScript untuk mengira sifar trailing dalam perwakilan binari nombor; Peta sedikit nilai mod 37 ke kedudukannya; Hanya perbezaan antara (x dan - x) ialah nilai magnitud yang ditandatangani (leftmostbit) nombor negatif yang ditandatangani adalah 1; Kod pemacu", "code": "function countTrailingZero ( x ) { let lookup = [ 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] ; return lookup [ ( - x & x ) % 37 ] ; } document . write ( countTrailingZero ( 48 ) ) ;"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | Program JavaScript untuk menilai Ceil (7 n / 8) tanpa menggunakan * dan /; Perhatikan pendakap dalaman di sini. Ini diperlukan kerana keutamaan pengendali ' -' lebih tinggi daripada '<'; Program pemacu untuk menguji fungsi di atas", "code": "function multiplyBySevenByEight ( n ) { return ( n - ( n >> 3 ) ) ; } let n = 9 ; document . write ( multiplyBySevenByEight ( n ) ) ;"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | Program JavaScript untuk menilai 7 N / 8 tanpa menggunakan * dan /; Langkah 1) Pertama kali ganda nombor dengan 7 i. e. 7 n = (n << 3) - n * Langkah 2) Bahagikan hasil sebanyak 8; Kod pemacu", "code": "function multiplyBySevenByEight ( n ) { return ( ( n << 3 ) - n ) >> 3 ; } var n = 15 ; document . write ( multiplyBySevenByEight ( n ) ) ;"}
{"text": "Set nombor palindrome terpanjang dari julat [l, r] dengan kebanyakan perbezaan k antara maksimum dan minimum | Berfungsi untuk mencari indeks paling kanan nombor yang diberikan; Simpan indeks paling kanan; Hitung pertengahan; Jika diberi nombor <= num; Berikan Ans = Mid; Mengemas kini rendah; Mengemas kini tinggi; kembali Ans; Fungsi untuk memeriksa sama ada nombor yang diberikan adalah palindrome atau tidak; Menjana terbalik nombor yang diberikan; Jika n adalah palindrome; Berfungsi untuk mencari saiz maksimum kumpulan nombor palindrome yang mempunyai perbezaan antara elemen maksimum dan minimum paling banyak k; Menyimpan semua nombor palindromik dalam julat [l, r]; Melintasi julat [l, r]; Jika saya adalah palindrome; Tambah nombor dalam senarai; Kedai kiraan nombor palindromik maksimum; Melelehkan setiap elemen dalam senarai; Kirakan indeks paling kanan dalam senarai <elemen semasa + k; Semak jika terdapat indeks paling kanan dari indeks semasa; Mengembalikan kiraan; Kod pemacu", "code": "function search ( list , num ) { var low = 0 , high = list . length - 1 ; var ans = - 1 ; while ( low <= high ) { var mid = low + ( high - low ) / 2 ; if ( list [ mid ] <= num ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } function isPalindrome ( n ) { var rev = 0 ; var temp = n ; while ( n > 0 ) { rev = rev * 10 + n % 10 ; n = parseInt ( n / 10 ) ; } return rev == temp ; } function countNumbers ( L , R , K ) { var list = [ ] ; for ( var i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) ) { list . push ( i ) ; } } var count = 0 ; for ( var i = 0 ; i < list . length ; i ++ ) { var right_index = search ( list , list [ i ] + K - 1 ) ; if ( right_index != - 1 ) count = Math . max ( count , right_index - i + 1 ) ; } return count ; } var L = 98 , R = 112 ; var K = 13 ; document . write ( countNumbers ( L , R , K ) ) ;"}
{"text": "Memaksimumkan jumlah yang mungkin dengan menolak nilai yang sama dari semua elemen subarray array yang diberikan | Berfungsi untuk mencari jumlah maksimum dengan menolak nilai yang sama dari semua elemen subarray; Kedai elemen yang lebih kecil sebelumnya; Kedai elemen yang lebih kecil seterusnya; Mengira sumbangan setiap elemen; Jawapan kembali; Berfungsi untuk menjana elemen yang lebih kecil sebelumnya untuk setiap elemen array; Unsur pertama tidak mempunyai lebih kecil sebelumnya; Tumpukan untuk menjejaki unsur -unsur yang telah berlaku sebelum ini; Tolak indeks pertama; Pop semua elemen sehingga elemen sebelumnya lebih kecil daripada elemen semasa; Simpan elemen yang lebih kecil sebelumnya; Tolak indeks elemen semasa; Mengembalikan array; Berfungsi untuk menjana elemen yang lebih kecil seterusnya untuk setiap elemen array; Tumpukan untuk menjejaki unsur -unsur yang telah berlaku seterusnya; Melangkah dalam urutan terbalik untuk mengira lebih kecil seterusnya; Pop semua elemen sehingga elemen seterusnya lebih kecil daripada elemen semasa; Simpan elemen yang lebih kecil seterusnya; Tolak indeks elemen semasa; Mengembalikan array; Kod pemacu", "code": "function findMaximumSum ( a , n ) { var prev_smaller = findPrevious ( a , n ) ; var next_smaller = findNext ( a , n ) ; var max_value = 0 ; for ( var i = 0 ; i < n ; i ++ ) { max_value = Math . max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; } return max_value ; } function findPrevious ( a , n ) { var ps = Array ( n ) . fill ( 0 ) ; ps [ 0 ] = - 1 ; let stack = Array ( ) ; stack . push ( 0 ) ; for ( var i = 1 ; i < a . length ; i ++ ) { while ( stack . length > 0 && a [ stack [ stack . length - 1 ] ] >= a [ i ] ) stack . pop ( ) ; ps [ i ] = stack . length > 0 ? stack [ stack . length - 1 ] : - 1 ; stack . push ( i ) ; } return ps ; } function findNext ( a , n ) { var ns = Array ( n ) . fill ( 0 ) ; ns [ n - 1 ] = n ; var stack = Array ( ) ; stack . push ( n - 1 ) ; for ( var i = n - 2 ; i >= 0 ; i -- ) { while ( stack . length > 0 && a [ stack [ stack . length - 1 ] ] >= a [ i ] ) stack . pop ( ) ; ns [ i ] = stack . length > 0 ? stack [ stack . length - 1 ] : a . length ; stack . push ( i ) ; } return ns ; } var n = 3 ; var a = [ 80 , 48 , 82 ] ; document . write ( findMaximumSum ( a , n ) ) ;"}
{"text": "Semak jika rentetan yang diberikan disalurkan substring rentetan lain | Fungsi ini kembali benar jika kandungan ARR1 [] dan ARR2 [] sama, jika tidak palsu. ; Fungsi ini mencari semua permutasi pat [] dalam txt []; Countp []: Simpan kiraan semua aksara corak counttw []: kiraan kiraan tetingkap semasa teks; Melintasi watak corak yang tersisa; Bandingkan tuduhan tetingkap semasa teks dengan tuduhan corak []; Tambah aksara semasa ke tetingkap semasa; Keluarkan watak pertama tetingkap sebelumnya; Periksa tetingkap terakhir dalam teks; Kod pemacu", "code": "function compare ( arr1 , arr2 ) { for ( let i = 0 ; i < 256 ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let countP = new Array ( 256 ) ; let countTW = new Array ( 256 ) ; for ( let i = 0 ; i < 256 ; i ++ ) { countP [ i ] = 0 ; countTW [ i ] = 0 ; } for ( let i = 0 ; i < 256 ; i ++ ) { countP [ i ] = 0 ; countTW [ i ] = 0 ; } for ( let i = 0 ; i < M ; i ++ ) { ( countP [ pat [ i ] . charCodeAt ( 0 ) ] ) ++ ; ( countTW [ txt [ i ] . charCodeAt ( 0 ) ] ) ++ ; } for ( let i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) return true ; ( countTW [ txt [ i ] . charCodeAt ( 0 ) ] ) ++ ; countTW [ txt [ i - M ] . charCodeAt ( 0 ) ] -- ; } if ( compare ( countP , countTW ) ) return true ; return false ; } let txt = \" \" ; let pat = \" \" ; if ( search ( pat , txt ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Memaksimumkan median array yang diberikan selepas menambahkan elemen K ke array yang sama | Berfungsi untuk mengembalikan median yang dimaksimumkan; Susun array; Jika saiznya juga; Jika saiz ganjil; Kod pemacu", "code": "function getMaxMedian ( arr , n , k ) { let size = n + k ; arr . sort ( ( a , b ) => a - b ) ; if ( size % 2 == 0 ) { let median = ( arr [ Math . floor ( size / 2 ) - 1 ] + arr [ Math . floor ( size / 2 ) ] ) / 2 ; return median ; } let median = arr [ Math . floor ( size / 2 ) ] ; return median ; } let arr = [ 3 , 2 , 3 , 4 , 2 ] ; let n = arr . length ; let k = 2 ; document . write ( getMaxMedian ( arr , n , k ) ) ;"}
{"text": "Susun 3 Integer Tanpa Menggunakan Keadaan atau Menggunakan Hanya Maksimum () Fungsi | Program JavaScript untuk pendekatan di atas; Cari elemen maksimum; Cari elemen minimum; Kod pemacu", "code": "function printSorted ( a , b , c ) { let get_max = Math . max ( a , Math . max ( b , c ) ) ; let get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; let get_mid = ( a + b + c ) - ( get_max + get_min ) ; document . write ( get_min + \" \" + get_mid + \" \" + get_max ) ; } let a = 4 , b = 1 , c = 9 ; printSorted ( a , b , c ) ;"}
{"text": "Jenis penyisipan binari | pelaksanaan berulang; Berfungsi untuk menyusun array [] saiz 'n'; Cari lokasi di mana dipilih haruslah inseretd; Gerakkan semua elemen selepas lokasi untuk mewujudkan ruang; Kod pemacu", "code": "function binarySearch ( a , item , low , high ) { while ( low <= high ) { var mid = low + ( high - low ) / 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; } function insertionSort ( a , n ) { var i , loc , j , k , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ; loc = binarySearch ( a , selected , 0 , j ) ; while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } } var a = [ 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 ] ; var n = a . length , i ; insertionSort ( a , n ) ; document . write ( \" \" + \" \" ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + \" \" ) ;"}
{"text": "SENARAI SENSI | Berfungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi utiliti untuk mencetak pelbagai saiz n; Kod pemacu", "code": "function insertionSort ( arr , n ) { let i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } function printArray ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + \" \" ) ; document . write ( \" \" ) ; } let arr = [ 12 , 11 , 13 , 5 , 6 ] ; let n = arr . length ; insertionSort ( arr , n ) ; printArray ( arr , n ) ;"}
{"text": "Count Permutasi yang berbeza dari rentetan yang diperoleh dengan menukar hanya aksara yang tidak sama rata | Fungsi untuk mengira jumlah bilangan permutasi yang sah; Mewujudkan kiraan yang sama dengan jumlah aksara yang hadir dan ANS yang akan menyimpan bilangan permutasi yang unik; Menyimpan kekerapan setiap watak yang ada dalam rentetan; Menambah kiraan aksara dengan tidak termasuk aksara sama dengan char semasa; Kurangkan kekerapan aksara semasa dan dikira dengan 1, supaya ia tidak dapat mengganggu pengiraan unsur -unsur yang sama ada di sebelah kanannya. ; Kembali Ans + 1 (kerana rentetan yang diberikan juga merupakan permutasi yang unik); Kod pemacu", "code": "function validPermutations ( str ) { let m = new Map ( ) ; let count = str . length , ans = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( m . has ( str [ i ] ) ) { m . set ( str [ i ] , m . get ( str [ i ] ) + 1 ) ; } else { m . set ( str [ i ] , 1 ) ; } } for ( let i = 0 ; i < str . length ; i ++ ) { ans += count - m . get ( str [ i ] ) ; m . set ( str [ i ] , m . get ( str [ i ] ) - 1 ) ; count -- ; } return ans + 1 ; } let str = \" \" ; document . write ( validPermutations ( str ) ) ;"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Fungsi berasaskan DP untuk mengira bilangan laluan; Isi penyertaan dalam Bottommost Row dan lajur paling kiri; Isi DP dengan cara bawah; Kod pemacu", "code": "function countPaths ( n , m ) { var dp = Array ( n + 1 ) . fill ( 0 ) . map ( x => Array ( m + 1 ) . fill ( 0 ) ) ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; } var n = 3 , m = 2 ; document . write ( \" \" + countPaths ( n , m ) ) ;"}
{"text": "Perubahan duit syiling | DP | Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Program pemacu untuk menguji fungsi di atas", "code": "function count ( S , m , n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } var arr = [ 1 , 2 , 3 ] ; var m = arr . length ; document . write ( count ( arr , m , 4 ) ) ;"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; Tukar ke huruf kecil menggunakan fungsi ToUppercase; Membandingkan kedua -dua menggunakan fungsi terbina; Jika rentetan adalah sama, kembali benar sebaliknya palsu; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "function equalIgnoreCase ( str1 , str2 ) { let i = 0 ; str1 = str1 . toUpperCase ( ) ; str2 = str2 . toUpperCase ( ) ; let x = str1 == ( str2 ) ; if ( ! x ) { return false ; } else { return true ; } } function equalIgnoreCaseUtil ( str1 , str2 ) { let res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } let str1 , str2 ; str1 = \" \" ; str2 = \" \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" \" ; str2 = \" \" ; equalIgnoreCaseUtil ( str1 , str2 ) ;"}
{"text": "Gantikan setiap urutan konsonan dengan panjangnya dalam rentetan yang diberikan | Berfungsi untuk mengembalikan rentetan yang ditukar selepas menggantikan setiap urutan konsonan dengan panjangnya; Untuk menyimpan rentetan yang dihasilkan; Memeriksa setiap watak untuk urutan konsonan; Hitung panjang urutan konsonan; Tambah panjang dalam rentetan; Tambah vokal; Semak urutan konsonan terakhir dalam rentetan; Kembali rentetan yang dihasilkan; Kod pemacu", "code": "function replaceConsonants ( str ) { var res = \" \" ; var i = 0 , count = 0 ; while ( i < str . length ) { if ( str [ i ] !== \" \" && str [ i ] !== \" \" && str [ i ] !== \" \" && str [ i ] !== \" \" && str [ i ] !== \" \" ) { i ++ ; count ++ ; } else { if ( count > 0 ) res += count . toString ( ) ; res += str [ i ] ; i ++ ; count = 0 ; } } if ( count > 0 ) res += count . toString ( ) ; return res ; } var str = \" \" ; document . write ( replaceConsonants ( str ) ) ;"}
{"text": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan dtring; untuk setiap substring; substring saiz k; mengira bilangan vokal dan konsonan; tambah produk untuk dijawab. ; Program yang didorong", "code": "function isVowel ( c ) { return ( c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' ) ; } function encryptString ( s , n , k ) { var countVowels = 0 ; var countConsonants = 0 ; var ans = \" \" ; for ( var l = 0 ; l <= n - k ; l ++ ) { countVowels = 0 ; countConsonants = 0 ; for ( var r = l ; r <= l + k - 1 ; r ++ ) { if ( isVowel ( s [ r ] ) == true ) countVowels ++ ; else countConsonants ++ ; } ans += ( countVowels * countConsonants ) . toString ( ) ; } return ans ; } var s = \" \" ; var n = s . length ; var k = 2 ; document . write ( encryptString ( s , n , k ) ) ;"}
{"text": "String yang mengandungi huruf pertama setiap perkataan dalam rentetan yang diberikan dengan ruang | Pelaksanaan JavaScript pendekatan di atas; Kami memisahkan input berdasarkan ruang (s) +: ungkapan biasa ini akan mengendalikan senario di mana kami mempunyai kata -kata yang dipisahkan oleh pelbagai ruang; Charat (0) hanya akan memilih watak pertama dari rentetan dan tambahan ke penampan; Kod pemacu", "code": "var charBuffer = \" \" ; function processWords ( input ) { var s = input . split ( ' ' ) ; s . forEach ( element => { charBuffer += element [ 0 ] ; } ) ; return charBuffer ; } var input = \" \" ; document . write ( processWords ( input ) ) ;"}
{"text": "Menjana semua rentetan binari tanpa berturut -turut 1 's | Fungsi utiliti menjana semua rentetan tanpa berturut -turut 1 'sof saiz k; Cetak rentetan binari tanpa berturut -turut 1 's; Menamatkan rentetan binari; Jika watak sebelumnya adalah '1' maka kami hanya meletakkan 0 pada akhir rentetan contoh str = \"01\" maka rentetan baru menjadi \"010\"; Jika watak sebelumnya adalah '0' daripada kami meletakkan kedua -dua '1' dan '0' pada akhir rentetan contoh str = \"00\" kemudian rentetan baru \"001\" dan \"000\"; Fungsi menjana semua rentetan binari tanpa berturut -turut 1; Kes asas; Satu demi satu kedai setiap rentetan panjang binari k; Menjana semua rentetan binari bermula dengan '0'; Menjana semua rentetan binari bermula dengan '1'; Kod pemacu", "code": "function generateAllStringsUtil ( K , str , n ) { if ( n == K ) { str [ n ] = ' \\0 ' ; document . write ( str . join ( \" \" ) + \" \" ) ; return ; } if ( str [ n - 1 ] == ' ' ) { str [ n ] = ' ' ; generateAllStringsUtil ( K , str , n + 1 ) ; } if ( str [ n - 1 ] == ' ' ) { str [ n ] = ' ' ; generateAllStringsUtil ( K , str , n + 1 ) ; str [ n ] = ' ' ; generateAllStringsUtil ( K , str , n + 1 ) ; } } function generateAllStrings ( K ) { if ( K <= 0 ) return ; var str = new Array ( K ) ; str [ 0 ] = ' ' ; generateAllStringsUtil ( K , str , 1 ) ; str [ 0 ] = ' ' ; generateAllStringsUtil ( K , str , 1 ) ; } var K = 3 ; generateAllStrings ( K ) ;"}
{"text": "Silinder bulat kanan terbesar dalam kiub | Berfungsi untuk mencari silinder bulat kanan terbesar; sisi tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "function findVolume ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; var h = a ; var V = ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; } var a = 5 ; document . write ( findVolume ( a ) ) ;"}
{"text": "Program untuk jumlah piramid | Berfungsi untuk mencari jumlah piramid segi tiga; Berfungsi untuk mencari jumlah piramid persegi; Berfungsi untuk mencari jumlah piramid pentagonal; Berfungsi untuk mencari jumlah piramid heksagon; Kod pemacu", "code": "function volumeTriangular ( a , b , h ) { let vol = ( 0.1666 ) * a * b * h ; return vol ; } function volumeSquare ( b , h ) { let vol = ( 0.33 ) * b * b * h ; return vol ; } function volumePentagonal ( a , b , h ) { let vol = ( 0.83 ) * a * b * h ; return vol ; } function volumeHexagonal ( a , b , h ) { let vol = a * b * h ; return vol ; } let b = 4 , h = 9 , a = 4 ; document . write ( \" \" + \" \" + volumeTriangular ( a , b , h ) + \" \" ) ; document . write ( \" \" + \" \" + volumeSquare ( b , h ) + \" \" ) ; document . write ( \" \" + \" \" + volumePentagonal ( a , b , h ) + \" \" ) ; document . write ( \" \" + \" \" + volumeHexagonal ( a , b , h ) ) ;"}
{"text": "Program untuk mencari kawasan trapezoid | Fungsi untuk kawasan tersebut; Kod pemacu", "code": "function Area ( b1 , b2 , h ) { return ( ( b1 + b2 ) / 2 ) * h ; } let base1 = 8 , base2 = 10 , height = 6 ; let area = Area ( base1 , base2 , height ) ; document . write ( \" \" + area ) ;"}
{"text": "Cari bilangan pepenjuru dalam polygon cembung N sisi | Fungsi JavaScript untuk mencari bilangan pepenjuru dalam poligon cembung N; Kod pemacu", "code": "function numberOfDiagonals ( n ) { return n * ( n - 3 ) / 2 ; } var n = 5 ; document . write ( n + \" \" ) ; document . write ( numberOfDiagonals ( n ) + \" \" ) ;"}
{"text": "Kawasan segi empat tepat terbesar tanpa titik tertentu | Berfungsi untuk mencari kawasan maksimum supaya ia tidak mengandungi sebarang lubang; Kawasan untuk semua kedudukan yang mungkin dipotong; Cari kawasan maksimum di antara segi empat tepat di atas; Kod pemacu; Panggilan fungsi", "code": "function maximumArea ( l , b , x , y ) { var left = x * b ; var right = ( l - x - 1 ) * b ; var above = l * y ; var below = ( b - y - 1 ) * l ; document . write ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; } var L = 8 , B = 8 ; var X = 0 , Y = 0 ; maximumArea ( L , B , X , Y ) ;"}
{"text": "Kurangkan kos penyingkiran yang diperlukan untuk menjadikan semua watak yang tersisa dari rentetan unik | Berfungsi untuk mencari kos minimum untuk mengeluarkan aksara untuk membuat rentetan unik; Simpan kos minimum yang diperlukan; Buat kamus untuk menyimpan kos maksimum penyingkiran watak; Buat kamus untuk menyimpan jumlah kos penghapusan watak; Melintasi rentetan, s; Jejaki kos maksimum setiap watak; Mengemas kini kos penghapusan maksimum; Jejaki jumlah kos setiap watak; Mengemas kini jumlah kos penghapusan; Melintasi semua watak yang unik; Simpan watak kos maksimum dan padamkan selebihnya; Kembalikan jawapannya; Diberikan rentetan; Diberikan pelbagai kos; Panggilan fungsi", "code": "function delCost ( s , cost ) { var ans = 0 ; var forMax = new Map ( ) ; var forTot = new Map ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! forMax . has ( s [ i ] ) ) { forMax . set ( s [ i ] , cost [ i ] ) ; } else { forMax . set ( s [ i ] , Math . max ( forMax . get ( s [ i ] ) , cost [ i ] ) ) } if ( ! forTot . has ( s [ i ] ) ) { forTot . set ( s [ i ] , cost [ i ] ) ; } else { forTot . set ( s [ i ] , forTot . get ( s [ i ] ) + cost [ i ] ) } } forMax . forEach ( ( value , key ) => { ans += forTot . get ( key ) - value ; } ) ; return ans ; } var s = \" \" ; var cost = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; document . write ( delCost ( s , cost ) ) ;"}
{"text": "Pembahagi terkecil n paling dekat dengan x | Tentukan makro; Kedai pembahagi untuk semua nombor dalam pembahagi vektor; Saya adalah pembahagi dan j adalah pelbagai; Fungsi untuk membandingkan kedekatan sasaran yang diberikan; Berfungsi untuk mencari elemen yang paling dekat dengan sasaran dalam vektor pembahagi; Kes sudut; Melakukan carian binari; Semak sama ada sasaran kurang daripada elemen array kemudian cari di separuh kiri; Semak sama ada sasaran lebih besar daripada sebelumnya hingga pertengahan, kembali paling dekat dengan dua; Ulangi separuh kiri; Semak sama ada sasaran lebih besar daripada pertengahan; Kemas kini i; Hanya elemen tunggal yang tersisa selepas carian; Berfungsi untuk mencetak pembahagi n paling dekat dengan x; Fungsi panggilan untuk mengira dan menyimpan pembahagi semua nombor dalam vektor; Menyimpan nilai terdekat untuk sasaran; Cetak jawapannya; Diberikan N & X; Panggilan fungsi", "code": "let MAX = 10000 ; let divisors = new Array ( MAX + 1 ) ; function computeDivisors ( ) { for ( let i = 1 ; i <= MAX ; i ++ ) { for ( let j = i ; j <= MAX ; j += i ) { divisors [ j ] . push ( i ) ; } } } function getClosest ( val1 , val2 , target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } function findClosest ( arr , n , target ) { if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; let i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = Math . floor ( ( i + j ) / 2 ) ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } function printClosest ( N , X ) { computeDivisors ( ) ; let ans = findClosest ( divisors [ N ] , divisors [ N ] . length , X ) ; document . write ( ans ) ; } let N = 16 , X = 5 ; for ( let i = 0 ; i < divisors . length ; i ++ ) divisors [ i ] = [ ] ; printClosest ( N , X ) ;"}
{"text": "Mengira elemen nilai yang sama diletakkan pada indeks yang sama dengan dua array yang diberikan | Fungsi untuk mengira elemen yang dipadankan maksimum dari array A [] dan B []; Kedai kedudukan unsur -unsur array a [] dalam array b []; Jejaki perbezaan antara indeks; Melintasi array a []; Melintasi array b []; Jika perbezaan negatif, tambahkan n kepadanya; Jejaki bilangan peralihan yang diperlukan untuk meletakkan elemen pada indeks yang sama; Mengembalikan perlawanan maksimum; Kod pemacu; Mengembalikan kiraan elemen yang dipadankan", "code": "function maxMatch ( A , B ) { var Aindex = { } ; var diff = { } ; for ( var i = 0 ; i < A . length ; i ++ ) { Aindex [ A [ i ] ] = i ; } for ( var i = 0 ; i < B . length ; i ++ ) { if ( i - Aindex [ B [ i ] ] < 0 ) { if ( ! diff . hasOwnProperty ( A . length + i - Aindex [ B [ i ] ] ) ) { diff [ A . length + i - Aindex [ B [ i ] ] ] = 1 ; } else { diff [ A . length + i - Aindex [ B [ i ] ] ] += 1 ; } } else { if ( ! diff . hasOwnProperty ( i - Aindex [ B [ i ] ] ) ) { diff [ i - Aindex [ B [ i ] ] ] = 1 ; } else { diff [ i - Aindex [ B [ i ] ] ] += 1 ; } } } var max = 0 ; for ( const [ key , value ] of Object . entries ( diff ) ) { if ( value > max ) { max = value ; } } return max ; } var A = [ 5 , 3 , 7 , 9 , 8 ] ; var B = [ 8 , 7 , 3 , 5 , 9 ] ; document . write ( maxMatch ( A , B ) ) ;"}
{"text": "Semak jika diberi penyelesaian Sudoku adalah sah atau tidak | Program JavaScript untuk melaksanakan pendekatan di atas; Berfungsi untuk memeriksa sama ada semua elemen lembaga [] [] nilai kedai array dalam julat [1, 9]; Traverse Board [] [] array; Semak jika papan [i] [j] terletak dalam julat; Fungsi untuk memeriksa sama ada penyelesaian teka -teki sudoku sah atau tidak; Semak sama ada semua elemen papan [] [] menyimpan nilai dalam julat [1, 9]; Kedai nilai unik dari 1 hingga n; Melintasi setiap baris array yang diberikan; Memulakan array unik [] kepada palsu; Melintasi setiap lajur baris semasa; Menyimpan nilai papan [i] [j]; Semak jika baris semasa menyimpan nilai pendua; Melintasi setiap lajur array yang diberikan; Melintasi setiap baris lajur semasa; Menyimpan nilai papan [j] [i]; Semak jika lajur semasa menyimpan nilai pendua; Melintasi setiap blok saiz 3 * 3 di papan [] [] array; J menyimpan lajur pertama setiap 3 * 3 blok; Memulakan array unik [] kepada palsu; Melintasi blok semasa; Kedai baris nombor blok semasa; Menyimpan nombor lajur blok semasa; Menyimpan nilai papan [x] [y]; Semak jika blok semasa menyimpan nilai pendua; Jika semua keadaan berpuas hati; Kod pemacu", "code": "var N = 9 ; function isinRange ( board ) { for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < N ; j ++ ) { if ( board [ i ] [ j ] <= 0 board [ i ] [ j ] > 9 ) { return false ; } } } return true ; } function isValidSudoku ( board ) { if ( isinRange ( board ) == false ) { return false ; } var unique = Array ( N + 1 ) . fill ( false ) ; for ( var i = 0 ; i < N ; i ++ ) { unique = Array ( N + 1 ) . fill ( false ) ; unique = Array ( N + 1 ) . fill ( false ) ; for ( var j = 0 ; j < N ; j ++ ) { var Z = board [ i ] [ j ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( var i = 0 ; i < N ; i ++ ) { for ( var j = 0 ; j < N ; j ++ ) { var Z = board [ j ] [ i ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( var i = 0 ; i < N - 2 ; i += 3 ) { for ( var j = 0 ; j < N - 2 ; j += 3 ) { unique = Array ( N + 1 ) . fill ( false ) ; for ( var k = 0 ; k < 3 ; k ++ ) { for ( var l = 0 ; l < 3 ; l ++ ) { var X = i + k ; var Y = j + l ; var Z = board [ X ] [ Y ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } } } return true ; } var board = [ [ 7 , 9 , 2 , 1 , 5 , 4 , 3 , 8 , 6 ] , [ 6 , 4 , 3 , 8 , 2 , 7 , 1 , 5 , 9 ] , [ 8 , 5 , 1 , 3 , 9 , 6 , 7 , 2 , 4 ] , [ 2 , 6 , 5 , 9 , 7 , 3 , 8 , 4 , 1 ] , [ 4 , 8 , 9 , 5 , 6 , 1 , 2 , 7 , 3 ] , [ 3 , 1 , 7 , 4 , 8 , 2 , 9 , 6 , 5 ] , [ 1 , 3 , 6 , 7 , 4 , 8 , 5 , 9 , 2 ] , [ 9 , 7 , 4 , 2 , 1 , 5 , 6 , 3 , 8 ] , [ 5 , 2 , 8 , 6 , 3 , 9 , 4 , 1 , 7 ] ] ; if ( isValidSudoku ( board ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Subarray panjang k yang penggabungannya membentuk palindrome | Fungsi untuk memeriksa sama ada nombor adalah palindrome atau tidak di sini saya adalah indeks permulaan dan j adalah indeks terakhir subarray; Jika integer di saya tidak sama dengan j maka subarray bukan palindrome; Jika tidak; Semua [i] adalah sama dengan [j] maka subarray adalah palindrome; Berfungsi untuk mencari subarray yang penggabungannya membentuk palindrome dan mengembalikan indeks permulaannya; Melangkah ke atas subarray panjang k dan memeriksa jika subarray itu adalah palindrome; Jika tiada subarray adalah palindrome; Kod pemacu", "code": "function palindrome ( a , i , j ) { while ( i < j ) { if ( a [ i ] != a [ j ] ) return false ; i ++ ; j -- ; } return true ; } function findSubArray ( arr , k ) { let n = arr . length ; for ( let i = 0 ; i <= n - k ; i ++ ) { if ( palindrome ( arr , i , i + k - 1 ) ) return i ; } return - 1 ; } let arr = [ 2 , 3 , 5 , 1 , 3 ] ; let k = 4 ; let ans = findSubArray ( arr , k ) ; if ( ans == - 1 ) document . write ( - 1 + \" \" ) ; else { for ( let i = ans ; i < ans + k ; i ++ ) document . write ( arr [ i ] + \" \" ) ; document . write ( \" \" ) ; }"}
{"text": "Semak sama ada urutan laluan melawat sebarang koordinat dua kali atau tidak | Berfungsi untuk memeriksa sama ada lelaki itu melintasi koordinat sebelumnya atau tidak; Menyimpan kiraan puncak silang; Kedai (x, y) koordinat; Koordinat untuk asal; Melangkah ke atas rentetan; Keadaan kepada kenaikan x atau y co - masing -masing; Semak jika (x, y) sudah dilawati; Cetak hasilnya; Diberikan rentetan; Panggilan fungsi", "code": "function isCrossed ( path ) { if ( path . length == 0 ) return ; let ans = false ; let mySet = new Set ( ) ; let x = 0 , y = 0 ; mySet . add ( [ x , y ] ) ; for ( let i = 0 ; i < path . length ; i ++ ) { if ( path [ i ] == ' ' ) mySet . add ( [ x , y ++ ] ) ; if ( path [ i ] == ' ' ) mySet . add ( [ x , y -- ] ) ; if ( path [ i ] == ' ' ) mySet . add ( [ x ++ , y ] ) ; if ( path [ i ] == ' ' ) mySet . add ( [ x -- , y ] ) ; if ( ! mySet . has ( [ x , y ] ) ) { ans = true ; break ; } } if ( ans ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let path = \" \" ; isCrossed ( path ) ;"}
{"text": "Lebar maksimum n | Berfungsi untuk mencari lebar maksimum pokok menggunakan traversal urutan tahap; Simpan tepi pokok; Menyimpan lebar maksimum pokok; Menyimpan nod setiap peringkat; Masukkan nod akar; Melakukan perintah level traversal di atas pokok; Menyimpan saiz barisan; Kemas kini lebar maksimum; Tolak nod tahap seterusnya dan popkan unsur -unsur tahap semasa; Dapatkan elemen dari depan barisan; Tolak semua nod peringkat seterusnya. ; Kembalikan hasilnya. ; Kod pemacu; Pokok yang dibina ialah: 1 / | \\ 2 - 1 3 / \\ \\ 4 5 8 / / | \\ 2 6 12 7", "code": "function maxWidth ( N , M , cost , s ) { let adj = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { adj . push ( [ ] ) ; } for ( let i = 0 ; i < M ; i ++ ) { adj [ s [ i ] [ 0 ] ] . push ( s [ i ] [ 1 ] ) ; } let result = 0 ; let q = [ ] ; q . push ( 0 ) ; while ( q . length != 0 ) { let count = q . length ; result = Math . max ( count , result ) ; while ( count -- > 0 ) { let temp = q . shift ( ) ; for ( let i = 0 ; i < adj [ temp ] . length ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } } return result ; } let N = 11 , M = 10 ; let edges = [ ] ; edges . push ( [ 0 , 1 ] ) ; edges . push ( [ 0 , 2 ] ) ; edges . push ( [ 0 , 3 ] ) ; edges . push ( [ 1 , 4 ] ) ; edges . push ( [ 1 , 5 ] ) ; edges . push ( [ 3 , 6 ] ) ; edges . push ( [ 4 , 7 ] ) ; edges . push ( [ 6 , 10 ] ) ; edges . push ( [ 6 , 8 ] ) ; edges . push ( [ 6 , 9 ] ) ; let cost = [ 1 , 2 , - 1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 ] ; document . write ( maxWidth ( N , M , cost , edges ) ) ;"}
{"text": "Kurangkan jumlah nombor perdana yang ditambah untuk membuat array bukan | Program JavaScript untuk melaksanakan pendekatan di atas; Kedai jika indeks adalah nilai utama / bukan utama; Menyimpan perdana; Berfungsi untuk menjana semua nombor perdana; Jika elemen semasa adalah perdana; Tetapkan semua gandaannya bukan perdana; Simpan semua nombor utama; Berfungsi untuk mencari perdana terdekat dengan nombor tertentu; Memohon carian binari pada vektor prima; Jika perdana ditambah menjadikan unsur -unsur sama; Kembali ini sebagai perdana terdekat; Jika array kekal tidak menurun; Cari nombor perdana yang lebih besar; Jika tidak; Periksa sama ada perdana yang lebih kecil boleh membuat array tidak berkurangan atau tidak; Mengembalikan nombor terdekat; Berfungsi untuk mencari kos minimum; Cari semua prima; Simpan hasilnya; Melangkah ke atas array; Elemen semasa adalah kurang daripada elemen sebelumnya; Cari perdana terdekat yang membuat array tidak berkurangan; Tambah kepada kos keseluruhan; Mengemas kini elemen semasa; Mengembalikan kos minimum; Diberikan array; Panggilan fungsi", "code": "let MAX = 10000000 ; let isPrime = new Array ( MAX ) ; let primes = new Array ( ) ; function SieveOfEratosthenes ( ) { isPrime . fill ( true ) ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( let i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } for ( let p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . push ( p ) ; } function prime_search ( primes , diff ) { let low = 0 ; let high = primes . length - 1 ; let res = 0 ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( primes [ mid ] == diff ) { return primes [ mid ] ; } else if ( primes [ mid ] < diff ) { low = mid + 1 ; } else { res = primes [ mid ] ; high = mid - 1 ; } } return res ; } function minCost ( arr , n ) { SieveOfEratosthenes ( ) ; let res = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { let diff = arr [ i - 1 ] - arr [ i ] ; let closest_prime = prime_search ( primes , diff ) ; res += closest_prime ; arr [ i ] += closest_prime ; } } return res ; } let arr = [ 2 , 1 , 5 , 4 , 3 ] ; let n = 5 ; document . write ( minCost ( arr , n ) )"}
{"text": "Kira cara untuk memecah rentetan binari ke dalam tiga substring yang mempunyai kiraan sifar yang sama | Berfungsi untuk mengembalikan cara untuk memecah rentetan ke dalam tiga bahagian dengan bilangan yang sama 0; Simpan jumlah kiraan 0 s; Kira Jumlah No. daripada 0 s watak dalam rentetan yang diberikan; Jika jumlah kiraan 0 watak tidak boleh dibahagikan dengan 3; Memulakan MP untuk menyimpan kekerapan k; Traverse String untuk mencari cara untuk memecah rentetan; Kiraan kenaikan jika 0 muncul; Hasil kenaikan jika jumlah sama dengan 2 * k dan k ada dalam MP; Masukkan jumlah dalam MP; Hasil pulangan; Diberikan rentetan; Panggilan fungsi", "code": "function count ( s ) { var cnt = 0 ; s . split ( ' ' ) . forEach ( c => { cnt += ( c == ' ' ) ? 1 : 0 ; } ) ; if ( cnt % 3 != 0 ) return 0 ; var res = 0 , k = parseInt ( cnt / 3 ) , sum = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { sum += ( s [ i ] == ' ' ) ? 1 : 0 ; if ( sum == 2 * k && mp . has ( k ) && i < s . length - 1 && i > 0 ) { res += mp . get ( k ) ; } if ( mp . has ( sum ) ) mp . set ( sum , mp . get ( sum ) + 1 ) else mp . set ( sum , 1 ) ; } return res ; } var str = \" \" ; document . write ( count ( str ) ) ;"}
{"text": "Kira cara untuk memecah rentetan binari ke dalam tiga substring yang mempunyai kiraan sifar yang sama | Berfungsi untuk mengira bilangan cara untuk berpecah; Mengira jumlah sifar; Kes1 jika jumlah kiraan sifar tidak boleh dibahagikan dengan 3; Case2 Jika jumlah kiraan sifar adalah sifar; Bilangan sifar dalam setiap substring; Memulakan sifar kepada bilangan cara untuk potongan pertama dan kedua; Memulakan kiraan; Melintasi dari awal; Meningkatkan kiraan jika elemen adalah '0'; Meningkatkan cara untuk pemotongan 1 jika kiraan adalah sama dengan sifar yang diperlukan dalam setiap substring; Meningkatkan cara untuk pemotongan 2 nd jika kiraan adalah sama dengan 2 * (sifar yang diperlukan dalam setiap substring); Jumlah cara untuk berpecah adalah pendaraban cara untuk potongan 1 dan 2; Kod pemacu; Panggilan fungsi", "code": "function splitstring ( s ) { let n = s . length ; let zeros = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( s [ i ] == ' ' ) zeros ++ ; if ( zeros % 3 != 0 ) return 0 ; if ( zeros == 0 ) return parseInt ( ( ( n - 1 ) * ( n - 2 ) ) / 2 , 10 ) ; let zerosInEachSubstring = parseInt ( zeros / 3 , 10 ) ; let waysOfFirstCut = 0 ; let waysOfSecondCut = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) count ++ ; if ( count == zerosInEachSubstring ) waysOfFirstCut ++ ; else if ( count == 2 * zerosInEachSubstring ) waysOfSecondCut ++ ; } return waysOfFirstCut * waysOfSecondCut ; } let s = \" \" ; document . write ( \" \" + \" \" + splitstring ( s ) ) ;"}
{"text": "Semak jika rentetan boleh ditukar kepada yang lain dengan menukar watak bersebelahan jenis yang diberikan | Berfungsi untuk memeriksa sama ada mungkin untuk mengubah mula berakhir; Semak urutan A, B dalam kedua -dua String Str1 dan Str2; Jika kedua -dua rentetan tidak sama; Melintasi rentetan; Semak indeks A dan B; Kod pemacu; Panggilan fungsi", "code": "function canTransform ( str1 , str2 ) { var s1 = \" \" ; var s2 = \" \" ; for ( const c of str1 ) { if ( c !== \" \" ) { s1 += c ; } } for ( const c of str2 ) { if ( c !== \" \" ) { s2 += c ; } } if ( s1 !== s2 ) return false ; var i = 0 ; var j = 0 ; var n = str1 . length ; while ( i < n && j < n ) { if ( str1 [ i ] === \" \" ) { i ++ ; } else if ( str2 [ j ] === \" \" ) { j ++ ; } else { if ( ( str1 [ i ] === \" \" && i < j ) || ( str1 [ i ] === \" \" && i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; } var str1 = \" \" ; var str2 = \" \" ; if ( canTransform ( str1 . split ( \" \" ) , str2 . split ( \" \" ) ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Substring terpanjang yang mempunyai kiraan vokal dan konsonan yang sama | Berfungsi untuk mengembalikan panjang substring terpanjang yang mempunyai bilangan vokal dan konsonan yang sama; Menjana array; Memulakan pembolehubah untuk menyimpan hasil; Menyimpan jumlah subarray; Peta untuk menyimpan indeks jumlah; Gelung melalui array; Jika jumlah adalah 0; Count vokal dan konsonan adalah sama; Mengemas kini panjang maksimum substring dalam hashmap; Simpan indeks jumlah; Mengembalikan panjang maksimum substring yang diperlukan; Kod pemacu", "code": "function maxsubStringLength ( S , N ) { let arr = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; let maxLen = 0 ; let curr_sum = 0 ; let hash = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = Math . max ( maxLen , i + 1 ) ; if ( hash . has ( curr_sum ) ) maxLen = Math . max ( maxLen , i - hash . get ( curr_sum ) ) ; else hash . set ( curr_sum , i ) ; } return maxLen ; } let S = \" \" ; let n = S . length ; document . write ( maxsubStringLength ( S . split ( ' ' ) , n ) ) ;"}
{"text": "Jarak minimum dari sel tertentu ke semua sel lain dari matriks | Program JavaScript untuk melaksanakan pendekatan di atas; Menyimpan arahan yang boleh diakses; Fungsi untuk mencari jarak minimum dari sel tertentu ke semua sel lain dalam matriks; Menyimpan sel -sel yang boleh diakses dari sel semasa; Masukkan pasangan (x, y); Melangkah ke barisan adalah kosong; Ekstrak pasangan; Pop mereka; Memeriksa keadaan sempadan; Jika sel tidak dikunjungi; Menetapkan jarak minimum; Masukkan jiran yang dilalui ke dalam barisan; Kod pemacu; Cetak jarak yang diperlukan", "code": "let mat = new Array ( 1001 ) ; for ( let i = 0 ; i < 1001 ; i ++ ) { mat [ i ] = new Array ( 1001 ) ; for ( let j = 0 ; j < 1001 ; j ++ ) { mat [ i ] [ j ] = 0 ; } } let r , c , x , y ; let dx = [ 0 , - 1 , - 1 , - 1 , 0 , 1 , 1 , 1 ] ; let dy = [ 1 , 1 , 0 , - 1 , - 1 , - 1 , 0 , 1 ] ; function FindMinimumDistance ( ) { let q = [ ] ; q . push ( [ x , y ] ) ; mat [ x ] [ y ] = 0 ; while ( q . length > 0 ) { x = q [ 0 ] [ 0 ] ; y = q [ 0 ] [ 1 ] ; q . shift ( ) ; for ( let i = 0 ; i < 8 ; i ++ ) { let a = x + dx [ i ] ; let b = y + dy [ i ] ; if ( a < 0 a >= r b >= c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . push ( [ a , b ] ) ; } } } } r = 5 , c = 5 , x = 1 , y = 1 ; let t = x ; let l = y ; mat [ x ] [ y ] = 0 ; FindMinimumDistance ( ) ; mat [ t ] [ l ] = 0 ; for ( let i = 0 ; i < r ; i ++ ) { for ( let j = 0 ; j < c ; j ++ ) { document . write ( mat [ i ] [ j ] + \" \" ) ; } document . write ( \" \" ) ; }"}
{"text": "Kelebihan minimum yang diperlukan untuk menukar rentetan yang diberikan menjadi penyambungan substrings yang sama panjang k | Fungsi yang mengembalikan bilangan minimum flip untuk menukar s ke dalam penyambungan sub -panjang sub -rentetan; Menyimpan hasilnya; Melangkah melalui indeks rentetan; Kedai kiraan 0 S & 1 S; ITERATE MEMBUAT K JUMPS; Kiraan 0 's; Kiraan 1 's; Tambah flip minimum untuk Indeks I; Mengembalikan bilangan minimum; Kod pemacu", "code": "function minOperations ( S , K ) { var ans = 0 ; for ( var i = 0 ; i < K ; i ++ ) { var zero = 0 , one = 0 ; for ( var j = i ; j < S . length ; j += K ) { if ( S [ j ] === \" \" ) zero ++ ; else one ++ ; } ans += Math . min ( zero , one ) ; } return ans ; } var S = \" \" ; var K = 3 ; document . write ( minOperations ( S , K ) ) ;"}
{"text": "Cari nombor yang hilang dalam perkembangan aritmetik yang tidak teratur | Berfungsi untuk mendapatkan elemen yang hilang; Untuk elemen maksimum dalam array; Untuk elemen minimum dalam array; Untuk XOR semua elemen; Perbezaan umum siri AP; Cari elemen maksimum dan minimum; Mengira perbezaan biasa; Kirakan XOR semua elemen; Lakukan XOR dengan siri AP sebenar yang dihasilkan X akan menjadi ANS; Mengembalikan elemen yang hilang; Diberikan array; Panggilan fungsi; Cetak elemen yang hilang", "code": "function missingElement ( arr , n ) { let max_ele = arr [ 0 ] ; let min_ele = arr [ 0 ] ; let x = 0 ; let d ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; } d = parseInt ( ( max_ele - min_ele ) / n , 10 ) ; for ( let i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; } for ( let i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; } return x ; } let arr = [ 12 , 3 , 6 , 15 , 18 ] ; let n = arr . length ; let element = missingElement ( arr , n ) ; document . write ( element ) ;"}
{"text": "Memandangkan rentetan dan integer k, cari sub sub | Berfungsi untuk mencetak sub -sub - string; Jumlah sub - rentetan mungkin; Jika k lebih besar daripada jumlah sub -rentetan; Untuk menyimpan nombor sub -rentetan bermula dengan watak rentetan; Mengira nilai -nilai; Substring [i - 1] ditambah untuk menyimpan jumlah kumulatif; Carian binari untuk mencari indeks permulaan sub -rentetan KTH; Untuk menyimpan indeks akhir sub -rentetan KTH; Cetak sub -rentetan; Kod pemacu", "code": "function Printksubstring ( str , n , k ) { let total = parseInt ( ( n * ( n + 1 ) ) / 2 , 10 ) ; if ( k > total ) { document . write ( \" \" + \" \" ) ; return ; } let substring = new Array ( n + 1 ) ; substring [ 0 ] = 0 ; let temp = n ; for ( let i = 1 ; i <= n ; i ++ ) { substring [ i ] = substring [ i - 1 ] + temp ; temp -- ; } let l = 1 ; let h = n ; let start = 0 ; while ( l <= h ) { let m = parseInt ( ( l + h ) / 2 , 10 ) ; if ( substring [ m ] > k ) { start = m ; h = m - 1 ; } else if ( substring [ m ] < k ) { l = m + 1 ; } else { start = m ; break ; } } let end = n - ( substring [ start ] - k ) ; for ( let i = start - 1 ; i < end ; i ++ ) { document . write ( str [ i ] ) ; } } let str = \" \" ; let k = 4 ; let n = str . length ; Printksubstring ( str , n , k ) ;"}
{"text": "Titik penyisipan yang lebih rendah | Berfungsi untuk mengembalikan titik penyisipan yang lebih rendah dari elemen dalam array yang disusun; Kes asas; Pemeriksaan akhir untuk unsur -unsur yang tersisa yang <x; Kod pemacu", "code": "function LowerInsertionPoint ( arr , n , X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; let lowerPnt = 0 ; let i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; } let arr = [ 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 ] ; let n = arr . length ; let X = 4 ; document . write ( LowerInsertionPoint ( arr , n , X ) ) ;"}
{"text": "Bilangan jawatan dengan alamat yang sama dalam baris utama dan lajur utama urutan | Mengembalikan kiraan kedudukan yang diperlukan; array 1D mendatar; array 1D menegak; melangkah untuk semua yang mungkin saya; Memeriksa jika J adalah integer; Memeriksa jika J terletak b / w 1 hingga n; melangkah untuk semua kemungkinan j; Memeriksa jika saya adalah integer; Memeriksa jika saya terletak b / w 1 hingga m; Kod pemacu", "code": "function getCount ( M , N ) { let count = 0 ; if ( M == 1 ) return N ; if ( N == 1 ) return M ; if ( N > M ) { for ( let i = 1 ; i <= M ; i ++ ) { let numerator = N * i - N + M - i ; let denominator = M - 1 ; if ( numerator % denominator == 0 ) { let j = parseInt ( numerator / denominator , 10 ) ; if ( j >= 1 && j <= N ) count ++ ; } } } else { for ( let j = 1 ; j <= N ; j ++ ) { let numerator = M * j - M + N - j ; let denominator = N - 1 ; if ( numerator % denominator == 0 ) { let i = parseInt ( numerator / denominator , 10 ) ; if ( i >= 1 && i <= M ) count ++ ; } } } return count ; } let M = 3 , N = 5 ; document . write ( getCount ( M , N ) ) ;"}
{"text": "Maksimum dalam pelbagai yang boleh membuat array lain disusun | Fungsi untuk memeriksa sama ada terdapat unsur swappable yang hadir untuk membuat array pertama disusun; WrongIdx adalah indeks elemen yang membuat array pertama tidak disusun; Cari elemen maksimum yang memenuhi syarat jiran yang disebutkan di atas; Jika res adalah benar maka swap elemen dan buat array pertama disusun; Fungsi untuk mencetak array yang disusun jika elemen ditukar. ; Kod pemacu", "code": "function swapElement ( arr1 , arr2 , n ) { let wrongIdx = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr1 [ i - 1 ] ) { wrongIdx = i ; } } let maximum = Number . MIN_VALUE ; let maxIdx = - 1 ; let res = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] > maximum && arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) { if ( wrongIdx + 1 <= n - 1 && arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) { maximum = arr2 [ i ] ; maxIdx = i ; res = true ; } } } if ( res ) { swap ( arr1 , wrongIdx , arr2 , maxIdx ) ; } return res ; } function swap ( a , wrongIdx , b , maxIdx ) { let c = a [ wrongIdx ] ; a [ wrongIdx ] = b [ maxIdx ] ; b [ maxIdx ] = c ; } function getSortedArray ( arr1 , arr2 , n ) { if ( swapElement ( arr1 , arr2 , n ) ) { for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr1 [ i ] + \" \" ) ; } } else { document . write ( \" \" ) ; } } let arr1 = [ 1 , 3 , 7 , 4 , 10 ] ; let arr2 = [ 2 , 1 , 6 , 8 , 9 ] ; let n = arr1 . length ; getSortedArray ( arr1 , arr2 , n ) ;"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Berfungsi untuk mencari pertengahan tiga nombor; Bandingkan setiap tiga nombor untuk mencari nombor tengah. Masukkan hanya jika A> B; Memutuskan A tidak lebih besar daripada b. ; Kod pemacu", "code": "function middleOfThree ( a , b , c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } } let a = 20 , b = 30 , c = 40 ; document . write ( middleOfThree ( a , b , c ) ) ;"}
{"text": "Susun Lajur Matriks | Berfungsi untuk mencari transpose matriks mat []; Menyimpan transpose matriks mat [] []; Melintasi setiap baris matriks; Melintasi setiap lajur matriks; Elemen matriks transpose; Berfungsi untuk menyusun matriks yang diberikan dengan cara yang bijak; Melintasi baris; Baris - penyortiran bijak; Berfungsi untuk mencetak matriks dalam lajur yang disusun dengan bijak; Fungsi panggilan untuk mencari transpose matriks mat [] []; Menyusun baris matriks - bijak; Kirakan transpose b [] []; Cetak matriks mat [] []; Input; Fungsi panggilan untuk mencetak matriks dalam lajur yang disusun dengan bijak", "code": "function transpose ( mat , row , col ) { let tr = new Array ( col ) ; for ( let i = 0 ; i < col ; i ++ ) { tr [ i ] = new Array ( row ) ; } for ( let i = 0 ; i < row ; i ++ ) { for ( let j = 0 ; j < col ; j ++ ) { tr [ j ] [ i ] = mat [ i ] [ j ] ; } } return tr ; } function RowWiseSort ( B ) { for ( let i = 0 ; i < B . length ; i ++ ) { ( B [ i ] ) . sort ( function ( a , b ) { return a - b ; } ) ; } } function sortCol ( mat , n , M ) { let B = transpose ( mat , N , M ) ; RowWiseSort ( B ) ; mat = transpose ( B , M , N ) ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { document . write ( mat [ i ] [ j ] + \" \" ) ; } document . write ( \" \" ) ; } } let mat = [ [ 1 , 6 , 10 ] , [ 8 , 5 , 9 ] , [ 9 , 4 , 15 ] , [ 7 , 3 , 60 ] ] ; let N = mat . length ; let M = mat [ 0 ] . length ; sortCol ( mat , N , M ) ;"}
{"text": "Kawasan terbesar mungkin selepas penyingkiran siri bar mendatar & menegak | Berfungsi untuk mencari kawasan terbesar apabila satu siri bar mendatar & menegak dikeluarkan; Menyimpan semua bar; Masukkan bar mendatar; Masukkan bar verttik; Keluarkan pemisah mendatar dari S1; Keluarkan pemisah menegak dari S2; Kedai -kedai yang ditinggalkan pemisah mendatar dan menegak; Menyusun kedua -dua senarai dalam urutan menaik; Cari perbezaan maksimum jiran List1; Cari perbezaan maksimum jiran List2; Cetak kelantangan terbesar; Diberi nilai N & M; Diberikan susunan; Fungsi panggilan untuk mencari kawasan terbesar apabila satu siri bar mendatar & menegak dikeluarkan", "code": "function largestArea ( N , M , H , V , h , v ) { var s1 = new Set ( ) ; var s2 = new Set ( ) ; for ( var i = 1 ; i <= N + 1 ; i ++ ) s1 . add ( i ) ; for ( var i = 1 ; i <= M + 1 ; i ++ ) s2 . add ( i ) ; for ( var i = 0 ; i < h ; i ++ ) { s1 . delete ( H [ i ] ) ; } for ( var i = 0 ; i < v ; i ++ ) { s2 . delete ( V [ i ] ) ; } var list1 = Array ( s1 . size ) ; var list2 = Array ( s2 . size ) ; var i = 0 ; s1 . forEach ( element => { list1 [ i ++ ] = element ; } ) ; i = 0 ; s2 . forEach ( element => { list2 [ i ++ ] = element ; } ) ; list1 . sort ( ( a , b ) => a - b ) list2 . sort ( ( a , b ) => a - b ) var maxH = 0 , p1 = 0 , maxV = 0 , p2 = 0 ; for ( var j = 0 ; j < s1 . size ; j ++ ) { maxH = Math . max ( maxH , list1 [ j ] - p1 ) ; p1 = list1 [ j ] ; } for ( var j = 0 ; j < s2 . size ; j ++ ) { maxV = Math . max ( maxV , list2 [ j ] - p2 ) ; p2 = list2 [ j ] ; } document . write ( maxV * maxH ) ; } var N = 3 , M = 3 ; var H = [ 2 ] ; var V = [ 2 ] ; var h = H . length ; var v = V . length ; largestArea ( N , M , H , V , h , v ) ;"}
{"text": "Semak jika array boleh disusun dengan menukar pasangan dari indeks yang terdiri daripada unsur -unsur yang tidak sama rata dalam array lain | Fungsi untuk memeriksa sama ada array, A boleh ditukar menjadi array yang disusun dengan bertukar (a [i], a [j]) jika b [i] tidak sama dengan b [j]; Kedai jika Array A disusun mengikut urutan menurun atau tidak; Melintasi array A; Jika [i] lebih besar daripada [i + 1]; Bendera kemas kini; Jika array disusun mengikut urutan menaik; kiraan = 2: periksa jika 0 s dan 1 s kedua -duanya hadir dalam b; Melintasi array; Jika elemen semasa ialah 0; Kiraan kemas kini; Melintasi array b; Jika elemen semasa ialah 1; Jika kedua -dua 0 s dan 1 s hadir dalam array; Arahan input A; Arahan input b; Panggilan fungsi; Jika benar, cetak ya; Lain cetak no", "code": "function checkifSorted ( A , B , N ) { var flag = false ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } var count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; } var A = [ 3 , 1 , 2 ] ; var B = [ 0 , 1 , 1 ] ; var N = A . length ; var check = checkifSorted ( A , B , N ) ; if ( check ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Swap minimum diperlukan di antara dua rentetan untuk membuat satu rentetan ketat lebih besar daripada yang lain | Berfungsi untuk mencari bilangan langkah minimum untuk membuat A> B; Jika semua watak adalah sama dan m <= n; Sekiranya terdapat sebarang watak dalam B yang lebih besar daripada B [0]; Jika terdapat apa -apa watak yang lebih kecil daripada [0]; Sekiranya terdapat watak yang berada di dalam dan lebih besar daripada [0]; Sekiranya terdapat watak yang berada di B dan kurang daripada B [0]; Jika tidak; Fungsi pemacu", "code": "function minSteps ( A , B , M , N ) { if ( A [ 0 ] > B [ 0 ] ) return 0 ; if ( B [ 0 ] > A [ 0 ] ) { return 1 ; } if ( M <= N && A [ 0 ] == B [ 0 ] && count ( A , A [ 0 ] ) == M && count ( B , B [ 0 ] ) == N ) return - 1 ; for ( var i = 1 ; i < N ; i ++ ) { if ( B [ i ] > B [ 0 ] ) return 1 ; } for ( var i = 1 ; i < M ; i ++ ) { if ( A [ i ] < A [ 0 ] ) return 1 ; } for ( var i = 1 ; i < M ; i ++ ) { if ( A [ i ] > A [ 0 ] ) { swap ( A , i , B , 0 ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } } for ( var i = 1 ; i < N ; i ++ ) { if ( B [ i ] < B [ 0 ] ) { swap ( A , 0 , B , i ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } } return 0 ; } function count ( a , c ) { count = 0 ; for ( var i = 0 ; i < a . length ; i ++ ) if ( a [ i ] == c ) count ++ ; return count ; } function swap ( s1 , index1 , s2 , index2 ) { var c = s1 [ index1 ] ; s1 [ index1 ] = s2 [ index2 ] ; s2 [ index2 ] = c ; } var A = \" \" ; var B = \" \" ; var M = A . length ; var N = B . length ; document . write ( minSteps ( A , B , M , N ) ) ;"}
{"text": "Memaksimumkan jumlah produk berpasangan yang dihasilkan dari tatasusunan yang diberikan | Program JavaScript untuk melaksanakan pendekatan di atas; Pembolehubah yang mewakili saiz array; Menyimpan hasilnya; Berfungsi untuk mengembalikan jumlah maksimum yang mungkin; Menyimpan kiraan susunan yang diproses; Jika lebih daripada dua tatasusunan telah diproses; Sekiranya subproblem yang telah dikira telah berlaku; Terokai semua pasangan yang mungkin; Panggilan fungsi rekursif; Memoize maksimum; Mengembalikan nilai; Berfungsi untuk mengembalikan jumlah maksimum produk pasangan yang mungkin; Menyusun tatasusunan dalam urutan menurun; Kod pemacu", "code": "var maxN = 201 ; var n1 , n2 , n3 ; var dp = Array . from ( Array ( maxN ) , ( ) => Array ( maxN ) ) ; for ( var i = 0 ; i < maxN ; i ++ ) for ( var j = 0 ; j < maxN ; j ++ ) dp [ i ] [ j ] = new Array ( maxN ) . fill ( - 1 ) ; function getMaxSum ( i , j , k , arr1 , arr2 , arr3 ) { var cnt = 0 ; if ( i >= n1 ) cnt ++ ; if ( j >= n2 ) cnt ++ ; if ( k >= n3 ) cnt ++ ; if ( cnt >= 2 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ] ; var ans = 0 ; if ( i < n1 && j < n2 ) ans = Math . max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; if ( i < n1 && k < n3 ) ans = Math . max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; if ( j < n2 && k < n3 ) ans = Math . max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; dp [ i ] [ j ] [ k ] = ans ; return dp [ i ] [ j ] [ k ] ; } function maxProductSum ( arr1 , arr2 , arr3 ) { arr1 . sort ( ) ; arr1 . reverse ( ) ; arr2 . sort ( ) ; arr2 . reverse ( ) ; arr3 . sort ( ) ; arr3 . reverse ( ) ; return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; } n1 = 2 ; var arr1 = [ 3 , 5 ] ; n2 = 2 ; var arr2 = [ 2 , 1 ] ; n3 = 3 ; var arr3 = [ 4 , 3 , 5 ] ; document . write ( maxProductSum ( arr1 , arr2 , arr3 ) ) ;"}
{"text": "Triplet leksikografi terbesar dari array yang diberikan yang membentuk segitiga | Berfungsi untuk mencari triplet terbesar secara leksikografi yang membentuk segitiga dalam array yang diberikan; Susun array; Berulang dari akhir array; Jika triplet membentuk segitiga; Jika triplet dijumpai; Cetak triplet; Jika tidak; Kod pemacu", "code": "function findTriplet ( arr , N ) { arr . sort ( ( a , b ) => a - b ) ; var flag = 0 , i ; for ( i = N - 1 ; i - 2 >= 0 ; i -- ) { if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) { flag = 1 ; break ; } } if ( flag ) { document . write ( arr [ i - 2 ] + \" \" + arr [ i - 1 ] + \" \" + arr [ i ] + \" \" ) ; } else { document . write ( - 1 + \" \" ) ; } } var arr = [ 4 , 2 , 10 , 3 , 5 ] ; var N = arr . length ; findTriplet ( arr , N ) ;"}
{"text": "Kira semua pasangan dalam array dengan perbezaan mutlak minimum | Berfungsi untuk mengembalikan kiraan semua pasangan yang mempunyai perbezaan mutlak yang minimum; Menyimpan kiraan pasangan; Susun array; Menyimpan perbezaan minimum antara pasangan bersebelahan; Mengemas kini perbezaan minimum antara pasangan; Meningkatkan kiraan pasangan dengan perbezaan yang sama dengan perbezaan minimum; Mengembalikan kiraan akhir; Diberikan array arr []; Panggilan fungsi", "code": "function numberofpairs ( arr , N ) { let answer = 0 ; arr . sort ( ) ; let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i < N - 1 ; i ++ ) minDiff = Math . min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; } let arr = [ 4 , 2 , 1 , 3 ] ; let N = arr . length ; document . write ( numberofpairs ( arr , N ) ) ;"}
{"text": "Subset saiz maksimum dengan jumlah yang diberikan menggunakan backtracking | Permulaan maksimum kemungkinan panjang berikutnya; Simpan elemen untuk membandingkan max_length dengan saiznya dan tukar nilai max_length dengan sewajarnya; Simpan unsur -unsur yang paling lama; Berfungsi untuk mencari panjang berikutnya terpanjang; Kemas kini max_length; Simpan unsur -unsur berikutnya; Secara rekursif meneruskan dengan jumlah yang diperoleh; unsur -unsur yang muncul dari belakang kedai vektor; jika jumlah> 0 maka kita tidak memerlukannya sehingga kembali dan teruskan dengan unsur -unsur terdahulu; Susun array yang diberikan; Melintasi array; Jika max_length sudah lebih besar daripada atau sama daripada panjang yang tinggal; Kod pemacu", "code": "let max_length = 0 ; let store = [ ] ; let ans = [ ] ; function find_max_length ( arr , index , sum , k ) { sum = sum + arr [ index ] ; store . push ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . length ) { max_length = store . length ; ans = store ; } } for ( let i = index + 1 ; i < arr . length ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_max_length ( arr , i , sum , k ) ; store . pop ( ) ; } else return ; } return ; } function longestSubsequence ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store = [ ] ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; } let arr = [ - 3 , 0 , 1 , 1 , 2 ] ; let n = arr . length ; let k = 1 ; document . write ( longestSubsequence ( arr , n , k ) ) ;"}
{"text": "Susun Pengurangan Permutasi N Menggunakan Swap Triple | Fungsi untuk menyusun array; Tiga indeks yang perlu dipilih; Semak jika boleh menyusun array; Bertukar untuk membawa elemen pada kedudukan yang diperlukan membawa sekurang -kurangnya satu elemen pada kedudukan yang betul; Mengesan perubahan dalam array; Cetak array yang disusun; Jika tidak mungkin untuk menyusun; Kod pemacu", "code": "function sortArray ( A , N ) { let x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( let i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } document . write ( \" \" ) ; for ( let i = 0 ; i < N ; i ++ ) document . write ( A [ i ] + \" \" ) ; } else { document . write ( \" \" ) ; } } let A = [ 5 , 4 , 3 , 2 , 1 ] ; let N = A . length ; sortArray ( A , N ) ;"}
{"text": "Cari k sedemikian rupa sehingga mengubah semua elemen array yang lebih besar daripada k ke k akan membuat jumlah array n | Berfungsi untuk mengembalikan k sedemikian rupa sehingga mengubah semua elemen yang lebih besar daripada k ke k akan membuat jumlah array n sebaliknya kembali - 1; Menyusun array dalam peningkatan urutan; Gelung melalui semua elemen array; Memeriksa jika jumlah array sama dengan n; Kod pemacu", "code": "function findK ( arr , size , N ) { arr . sort ( function ( a , b ) { return a - b } ) ; let temp_sum = 0 ; for ( let i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return - 1 ; } let arr = [ 3 , 1 , 10 , 4 , 8 ] ; let size = arr . length ; let N = 16 ; document . write ( findK ( arr , size , N ) ) ;"}
{"text": "Cari tiga elemen dari tiga array yang diberikan supaya jumlah mereka adalah x | Tetapkan 2 | Fungsi yang kembali benar jika terdapat triplet dengan jumlah x; Menyusun susunan sedemikian rupa sehingga [] mewakili array terkecil; Mengalihkan array terkecil; Dua petunjuk pada array kedua dan ketiga; Jika triplet yang sah dijumpai; Kod pemacu", "code": "function existsTriplet ( a , b , c , x , l1 , l2 , l3 ) { if ( l2 <= l1 && l2 <= l3 ) { temp = l1 ; l1 = l2 ; l2 = temp ; temp = a ; a = b ; b = temp ; } else if ( l3 <= l1 && l3 <= l2 ) { temp = l1 ; l1 = l3 ; l3 = temp ; temp = a ; a = c ; c = temp ; } for ( var i = 0 ; i < l1 ; i ++ ) { var j = 0 , k = l3 - 1 ; while ( j < l2 && k >= 0 ) { if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; } var a = [ 2 , 7 , 8 , 10 , 15 ] ; var b = [ 1 , 6 , 7 , 8 ] ; var c = [ 4 , 5 , 5 ] ; var l1 = a . length ; var l2 = b . length ; var l3 = c . length ; var x = 14 ; if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Susun nombor yang diberikan untuk membentuk nombor terkecil | Fungsi utiliti untuk mencetak kandungan array; Fungsi perbandingan yang kembali benar jika 'ab' lebih kecil daripada 'ba' apabila kita menggabungkan dua nombor 'a' dan 'b' misalnya, ia akan kembali benar jika kita lulus 12 dan 24 sebagai argumen. Fungsi ini akan digunakan oleh fungsi sort (); Tukar nombor pertama ke format rentetan; Tukar nombor kedua ke format rentetan; Semak jika 'ab' lebih kecil atau 'ba' dan kembali nilai bool sejak pengendali perbandingan '<=' mengembalikan benar atau palsu; Berfungsi untuk mencetak susunan dengan nilai terkecil; Jika kita lulus nama fungsi perbandingan, ia akan menyusun array mengikut jenis fungsi Bandingkan menggunakan fungsi Bandingkan yang ditakrifkan di atas; Cetak array yang disusun; Kod pemacu", "code": "function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] ) ; } function compare ( num1 , num2 ) { let A = num1 . toString ( ) ; let B = num2 . toString ( ) ; return ( A + B ) . localeCompare ( B + A ) ; } function printSmallest ( N , arr ) { for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( compare ( arr [ i ] , arr [ j ] ) > 0 ) { let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } printArr ( arr , N ) ; } let arr = [ 5 , 6 , 2 , 9 , 21 , 1 ] ; let N = arr . length ; printSmallest ( N , arr ) ;"}
{"text": "Stabil Pemilihan Susun | Program JavaScript untuk mengubah suai pilihan pemilihan supaya ia menjadi stabil. ; Melangkah melalui elemen array; Cari elemen minimum dari arr [i] ke arr [n - 1]. ; Gerakkan elemen minimum pada semasa i. ; fungsi pemacu", "code": "function stableSelectionSort ( a , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { let min = i ; for ( let j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; let key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } } function prletArray ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + \" \" ) ; document . write ( \" \" ) ; } let a = [ 4 , 5 , 3 , 2 , 4 , 1 ] ; let n = a . length ; stableSelectionSort ( a , n ) ; prletArray ( a , n ) ;"}
{"text": "Permut dua tatasusunan sedemikian rupa sehingga jumlah setiap pasangan lebih besar atau sama dengan k | Semak sama ada apa -apa permutasi wujud yang memenuhi syarat. ; Susun array a [] dalam urutan yang berkurangan. ; Susun array B [] dalam peningkatan urutan. ; Memeriksa keadaan pada setiap indeks. ; Program yang didorong", "code": "function isPossible ( a , b , n , k ) { a . sort ( function ( a , b ) { return a - b } ) ; b . reverse ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; } let a = [ 2 , 1 , 3 ] ; let b = [ 7 , 8 , 9 ] ; let k = 10 ; let n = a . length ; if ( isPossible ( a , b , n , k ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Semak jika akhir rentetan binari yang diberikan dapat dicapai dengan memilih nilai lompat di antara julat yang diberikan | Fungsi untuk memeriksa sama ada mungkin untuk mencapai hujung rentetan binari menggunakan lompatan yang diberikan; Menyimpan negeri -negeri DP; Kedai -kedai mengira indeks dari mana ia mungkin untuk mencapai Indeks I; Melintasi rentetan yang diberikan; Mengemas kini nilai pra dengan sewajarnya; Jika saiz lompat keluar dari julat [l, r]; Jawapan kembali; Kod pemacu", "code": "const canReach = ( s , L , R ) => { let dp = new Array ( s . length ) . fill ( 1 ) ; let pre = 0 ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( i >= L ) { pre += dp [ i - L ] ; } if ( i > R ) { pre -= dp [ i - R - 1 ] ; } dp [ i ] = ( pre > 0 ) && ( s [ i ] == ' ' ) ; } return dp [ s . length - 1 ] ; } let S = \" \" ; let L = 2 , R = 3 ; if ( canReach ( S , L , R ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Pecahkan array ke subarrays dengan bitwise maksimum XOR masing -masing bitwise atau nilai masing -masing | Fungsi rekursif untuk mencari semua kemungkinan pemecahan array ke subarrays dan cari maksimum bitwise XOR; Jika nilai n ialah 0; Menyimpan hasil jika kumpulan baru dibentuk dengan elemen pertama sebagai arr [i]; Kedai jika keputusan jika ARR [i] dimasukkan ke dalam kumpulan terakhir; Mengembalikan maksimum x dan y; Berfungsi untuk mencari maksimum bitwise xor dari semua nilai yang mungkin dari array selepas memecahkan tatasusunan ke subarrays; Mengembalikan hasilnya; Kod pemacu", "code": "function maxXORUtil ( arr , N , xrr , orr ) { if ( N == 0 ) return xrr ^ orr ; let x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) ; let y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) ; return Math . max ( x , y ) ; } function maximumXOR ( arr , N ) { return maxXORUtil ( arr , N , 0 , 0 ) ; } let arr = [ 1 , 5 , 7 ] ; let N = arr . length ; document . write ( maximumXOR ( arr , N ) ) ;"}
{"text": "Bina N | Program JavaScript untuk melaksanakan pendekatan di atas; Menjejaki nod yang dikunjungi; Berfungsi untuk membina pokok supaya tidak ada dua nod bersebelahan dengan berat yang sama; Jika elemen minimum dan maksimum adalah sama, i. e. Array mengandungi satu elemen yang berbeza; Pokok tidak boleh dibina; Jika tidak; Pokok boleh dibina; Pilih berat [0] sebagai akar; Node pertama dikunjungi; Melintasi array; Jika tidak, buat kelebihan; Tandakan nod ini seperti yang dikunjungi; Cari berat badan yang tidak sama dengan root & membuat tepi dengan nod itu; Sertai bukan akar dengan nod yang tinggal; Semak jika nod semasa berat ~ sama dengan berat badan dan jika ia tidak dikunjungi atau tidak; Kod pemacu; Panggilan fungsi", "code": "let N = 100000 + 5 ; let visited = new Array ( N ) ; visited . fill ( 0 ) ; function construct_tree ( weights , n ) { let minimum = Number . MAX_VALUE ; let maximum = Number . MIN_VALUE ; for ( let i = 0 ; i < weights . length ; i ++ ) { minimum = Math . min ( minimum , weights [ i ] ) ; maximum = Math . max ( maximum , weights [ i ] ) ; } if ( minimum == maximum ) { document . write ( \" \" ) ; return ; } else { document . write ( \" \" + \" \" ) ; } let root = weights [ 0 ] ; visited [ 1 ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { document . write ( 1 + \" \" + ( i + 1 ) + \" \" ) ; visited [ i + 1 ] = 1 ; } } let notroot = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { notroot = i + 1 ; break ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { document . write ( notroot + \" \" + ( i + 1 ) + \" \" ) ; visited [ i + 1 ] = 1 ; } } } let weights = [ 1 , 2 , 1 , 2 , 5 ] ; let n = weights . length ; construct_tree ( weights , n ) ;"}
{"text": "Kurangkan kos untuk menukar rentetan yang diberikan menjadi penyambungan substrings yang sama panjang k | Berfungsi untuk mencari kos minimum untuk menukar rentetan yang diberikan ke dalam rentetan panjang K substring yang sama; Kedai panjang rentetan; Menyimpan kos minimum; Melintasi substring kiri panjang K; Menyimpan kekerapan; Kedai kos minimum untuk urutan indeks S [i] % K; Semak watak yang optimum; Cari jumlah jarak 'a' + ch dari indeks kara [i] % k; Pilih kos minimum untuk setiap indeks i; Kenaikan ans; Cetak kos minimum untuk menukar rentetan; Diberikan rentetan s; Panggilan fungsi", "code": "function minCost ( s , k ) { var n = s . length ; var ans = 0 ; for ( var i = 0 ; i < k ; i ++ ) { var a = new Array ( 26 ) . fill ( 0 ) ; for ( var j = i ; j < n ; j += k ) { a [ s [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } var min_cost = 1000000000 ; for ( var ch = 0 ; ch < 26 ; ch ++ ) { var cost = 0 ; for ( var tr = 0 ; tr < 26 ; tr ++ ) cost += Math . abs ( ch - tr ) * a [ tr ] ; min_cost = Math . min ( min_cost , cost ) ; } ans += min_cost ; } document . write ( ans ) ; } var S = \" \" ; var K = 3 ; minCost ( S , K ) ;"}
{"text": "Split First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Berfungsi untuk memecah nombor semulajadi N pertama ke dalam dua set yang mempunyai perbezaan mutlak minimum jumlah mereka; Kod pemacu", "code": "function minAbsDiff ( N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; } var N = 6 ; document . write ( minAbsDiff ( N ) ) ;"}
{"text": "Cari padanan maksimum dalam pokok binari yang diberikan | Program JavaScript untuk melaksanakan pendekatan di atas; Senarai Adjacency untuk menyimpan tepi; Tambah kelebihan antara u dan v dalam pokok; Kelebihan dari u ke v; Tepi dari v ke u; Fungsi yang mendapati pemadanan maksimum DFS; Pergi lebih jauh kerana kami tidak dibenarkan pergi ke arah ibu bapanya; Jika u dan ibu induknya tidak diambil maka kita mesti mengambil & menandakannya sebagai diambil; Saiz kenaikan set tepi; Berfungsi untuk mencari padanan maksimum dalam graf; Mengambil 1 sebagai akar pokok; Cetak padanan maksimum; Kod pemacu; Menyertai kelebihan antara dua nod dalam pokok; Panggilan fungsi", "code": "let N = 10000 ; let adj = new Array ( N ) ; let used = new Array ( N ) ; used . fill ( 0 ) ; let max_matching = 0 ; function AddEdge ( u , v ) { adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; } function Matching_dfs ( u , p ) { for ( let i = 0 ; i < adj [ u ] . length ; i ++ ) { if ( adj [ u ] [ i ] != p ) { Matching_dfs ( adj [ u ] [ i ] , u ) ; } } if ( used [ u ] == 0 && used [ p ] == 0 && p != 0 ) { max_matching ++ ; used [ u ] = used [ p ] = 1 ; } } function maxMatching ( ) { Matching_dfs ( 1 , 0 ) ; document . write ( max_matching + \" \" ) ; } for ( let i = 0 ; i < adj . length ; i ++ ) adj [ i ] = [ ] ; AddEdge ( 1 , 2 ) ; AddEdge ( 1 , 3 ) ; AddEdge ( 3 , 4 ) ; AddEdge ( 3 , 5 ) ; maxMatching ( ) ;"}
{"text": "Kurangkan kos untuk menukar dua tatasusunan yang diberikan | Fungsi untuk mengira dan mengembalikan kos minimum yang diperlukan untuk menukar dua tatasusunan; Mengembalikan jumlah kos minimum; Kod pemacu", "code": "function getMinCost ( A , B , N ) { let mini = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; } let N = 3 ; let A = [ 1 , 4 , 2 ] ; let B = [ 10 , 6 , 12 ] ; document . write ( getMinCost ( A , B , N ) ) ;"}
{"text": "Cetak semua cara yang mungkin untuk menulis n sebagai jumlah dua atau lebih integer positif | Berfungsi untuk mencetak nilai yang disimpan dalam arr vektor; Melintasi arr vektor; Fungsi rekursif untuk mencetak cara yang berbeza di mana n boleh ditulis sebagai jumlah pada 2 atau lebih bilangan bulat positif; Jika n adalah sifar maka cetak cara ini memecahkan nombor; Bermula dari elemen sebelumnya dalam perwakilan sehingga n; Termasuk elemen semasa dari perwakilan; Fungsi panggilan sekali lagi dengan jumlah yang dikurangkan; Backtrack untuk mengeluarkan elemen semasa dari perwakilan; Diberikan jumlah n; Untuk menyimpan perwakilan melanggar N; Panggilan fungsi", "code": "function printVector ( arr ) { if ( arr . length != 1 ) { for ( var i = 0 ; i < arr . length ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; } document . write ( \" \" ) ; } } function findWays ( arr , i , n ) { if ( n == 0 ) printVector ( arr ) ; for ( var j = i ; j <= n ; j ++ ) { arr . push ( j ) ; findWays ( arr , j , n - j ) ; arr . pop ( ) ; } } var n = 4 ; var arr = [ ] ; findWays ( arr , 1 , n ) ;"}
{"text": "Memaksimumkan kiraan penurunan berikutnya dari array yang diberikan | Berfungsi untuk mengira berikutnya maksimum; Menyimpan kekerapan elemen array; Kedai frekuensi maksimum; Kemas kini kekerapan [i]; Mengemas kini maksimum Max; Cetak kiraan; Kod pemacu", "code": "function Maximum_subsequence ( A , N ) { var frequency = new Map ( ) ; var max_freq = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( frequency . has ( A [ i ] ) ) frequency . set ( A [ i ] , frequency . get ( A [ i ] ) + 1 ) else frequency . set ( A [ i ] , 1 ) ; } frequency . forEach ( ( value , key ) => { if ( value > max_freq ) { max_freq = value ; } } ) ; document . write ( max_freq ) ; } var arr = [ 5 , 2 , 6 , 5 , 2 , 4 , 5 , 2 ] ; var N = arr . length ; Maximum_subsequence ( arr , N ) ;"}
{"text": "Semak jika rentetan boleh dibahagikan kepada dua rentetan dengan bilangan k | yang sama Berfungsi untuk mencetak susunan aksara; Kedai kekerapan aksara; Hitung watak yang mempunyai kekerapan k; Hitung watak yang mempunyai kekerapan lebih besar daripada k dan tidak sama dengan 2 k; Kes 1; Kes 2; Kes 3; Jika semua kes gagal; Kod pemacu", "code": "function DivideString ( s , n , k ) { var i , c = 0 , no = 1 ; var c1 = 0 , c2 = 0 ; var fr = new Array ( 26 ) . fill ( 0 ) ; var ans = [ ] ; for ( i = 0 ; i < n ; i ++ ) { fr [ s [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] ++ ; } var ch = \" \" , ch1 = \" \" ; for ( i = 0 ; i < 26 ; i ++ ) { if ( fr [ i ] === k ) { c ++ ; } if ( fr [ i ] > k && fr [ i ] !== 2 * k ) { c1 ++ ; ch = String . fromCharCode ( i + \" \" . charCodeAt ( 0 ) ) ; } if ( fr [ i ] === 2 * k ) { c2 ++ ; ch1 = String . fromCharCode ( i + \" \" . charCodeAt ( 0 ) ) ; } } for ( i = 0 ; i < n ; i ++ ) ans . push ( \" \" ) ; var mp = { } ; if ( c % 2 === 0 c1 > 0 c2 > 0 ) { for ( i = 0 ; i < n ; i ++ ) { if ( fr [ s [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] === k ) { if ( mp . hasOwnProperty ( s [ i ] ) ) { ans [ i ] = \" \" ; } else { if ( no <= parseInt ( c / 2 ) ) { ans [ i ] = \" \" ; no ++ ; mp [ s [ i ] ] = 1 ; } } } } if ( c % 2 === 1 && c1 > 0 ) { no = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] === ch && no <= k ) { ans [ i ] = \" \" ; no ++ ; } } } if ( c % 2 === 1 && c1 === 0 ) { no = 1 ; var flag = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] === ch1 && no <= k ) { ans [ i ] = \" \" ; no ++ ; } if ( fr [ s [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] === k && flag === 0 && ans [ i ] === \" \" ) { ans [ i ] = \" \" ; flag = 1 ; } } } document . write ( ans . join ( \" \" ) ) ; } else { document . write ( \" \" ) ; } } var S = \" \" ; var N = S . length ; var K = 1 ; DivideString ( S , N , K ) ;"}
{"text": "Semak jika dua item boleh dipilih dari dua kategori yang berbeza tanpa harga yang melebihi | Fungsi untuk memeriksa sama ada dua item boleh dipilih dari dua kategori yang berbeza tanpa melebihi jumlah harga; Gelung untuk memilih dua pasangan yang berbeza menggunakan dua gelung bersarang; Keadaan untuk memeriksa sama ada harga kedua -dua elemen ini kurang daripada S; Kod pemacu; Panggilan fungsi", "code": "function check ( S , prices , type , n ) { for ( let j = 0 ; j < n ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return \" \" ; } } } } return \" \" ; } let prices = [ 3 , 8 , 6 , 5 ] ; let type = [ 0 , 1 , 1 , 0 ] ; let S = 10 ; let n = 4 ; document . write ( check ( S , prices , type , n ) ) ;"}
{"text": "Cari jumlah maksimum (a + b) untuk integer input yang diberikan dan memenuhi syarat yang diberikan | Berfungsi untuk mengembalikan jumlah maksimum A + B yang memenuhi syarat yang diberikan; Memulakan max_sum; Pertimbangkan semua pasangan yang mungkin dan periksa jumlah yang membahagikan harta produk; Untuk mencari faktor terbesar k; Semak sama ada produk itu boleh dibahagikan dengan jumlah; Menyimpan jumlah maksimum dalam pembolehubah max_sum; Kembalikan nilai max_sum; Kod pemacu", "code": "function getLargestSum ( N ) { let max_sum = 0 ; for ( let i = 1 ; i * i <= N ; i ++ ) { for ( let j = i + 1 ; j * j <= N ; j ++ ) { let k = parseInt ( N / j , 10 ) ; let a = k * i ; let b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = Math . max ( max_sum , a + b ) ; } } return max_sum ; } let N = 25 ; let max_sum = getLargestSum ( N ) ; document . write ( max_sum + \" \" ) ;"}
{"text": "Menyulitkan rentetan dengan mengulangi i | Berfungsi untuk mengembalikan rentetan yang disulitkan; Bilangan kali watak semasa akan diulang; Ulangi watak semasa dalam rentetan yang disulitkan; Kod pemacu", "code": "function encryptString ( str , n ) { let i = 0 , cnt = 0 ; let encryptedStr = \" \" ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- > 0 ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; } let str = \" \" ; let n = str . length ; document . write ( encryptString ( str , n ) ) ;"}
{"text": "Kurangkan perbezaan antara nilai maksimum dan minimum array yang diubah suai | Fungsi untuk mengembalikan perbezaan minimum yang diperlukan; mencari nilai minimum dan maksimum; mengembalikan perbezaan minimum yang mungkin; Program pemacu; berfungsi untuk mengembalikan jawapannya", "code": "function minDiff ( n , x , A ) { var mn = A [ 0 ] , mx = A [ 0 ] ; for ( var i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; } var n = 3 , x = 3 ; var A = [ 1 , 3 , 6 ] ; document . write ( minDiff ( n , x , A ) ) ;"}
{"text": "Swap minimum untuk mengimbangi pendakap | Program JavaScript untuk mengira swap yang diperlukan untuk mengimbangi rentetan; menyimpan jumlah kurungan kiri dan kanan yang dihadapi; Swap menyimpan bilangan swap yang diperlukan ketidakseimbangan mengekalkan bilangan pasangan ketidakseimbangan; kiraan kenaikan kurungan kiri; kiraan swap adalah kiraan swap terakhir + jumlah kurungan tidak seimbang; ketidakseimbangan yang diturunkan oleh 1 kerana ia hanya menyelesaikan satu ketidakseimbangan kiri dan kanan; kiraan kenaikan kurungan kanan; Ketidakseimbangan diset semula kepada perbezaan semasa antara kurungan kiri dan kanan; Kod pemacu", "code": "function swapCount ( s ) { let chars = s . split ( ' ' ) ; let countLeft = 0 , countRight = 0 ; let swap = 0 , imbalance = 0 ; for ( let i = 0 ; i < chars . length ; i ++ ) { if ( chars [ i ] == ' ' ) { countLeft ++ ; if ( imbalance > 0 ) { swap += imbalance ; imbalance -- ; } } else if ( chars [ i ] == ' ' ) { countRight ++ ; imbalance = ( countRight - countLeft ) ; } } return swap ; } let s = \" \" ; document . write ( swapCount ( s ) + \" \" ) ; s = \" \" ; document . write ( swapCount ( s ) ) ;"}
{"text": "Paling terpanjang dari pelbagai pasangan yang mempunyai elemen pertama yang semakin meningkat dan elemen kedua berkurangan. | Fungsi untuk mencari panjang pasang pasang terpanjang yang elemen pertama yang semakin meningkat dan kedua berkurangan; dp [i]: Menyimpan selanjutnya yang terpanjang sehingga i; Kes asas; Apabila keadaan memegang; Akhirnya, cetak jawapan yang diperlukan; Diberikan input; Panggilan fungsi", "code": "function longestSubSequence ( A , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( let j = 0 ; j < i ; j ++ ) { if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] && A [ j ] [ 1 ] > A [ i ] [ 1 ] ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } } document . write ( dp [ N - 1 ] + \" \" ) ; } let A = [ [ 1 , 2 ] , [ 2 , 2 ] , [ 3 , 1 ] ] ; let N = A . length ; longestSubSequence ( A , N ) ;"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Fungsi untuk mengira jumlah cara untuk mempunyai jumlah n; Kes asas; Kembali hasil yang telah disimpan; Berulang untuk semua 6 negeri; Mengembalikan hasilnya; Diberikan jumlah n; Memulakan array DP; Panggilan fungsi", "code": "function findWays ( N , dp ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != - 1 ) { return dp [ N ] ; } let cnt = 0 ; for ( let i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; } let N = 4 ; let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ; document . write ( findWays ( N , dp ) ) ;"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Fungsi untuk mengira jumlah cara untuk mempunyai jumlah n; Memulakan array DP; Melangkah ke atas semua nilai perantaraan yang mungkin untuk mencapai n; Kirakan jumlah untuk semua 6 muka; Cetak jumlah cara; Diberikan jumlah n; Panggilan fungsi", "code": "function findWays ( N ) { let dp = new Array ( N + 1 ) ; dp [ 0 ] = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( let j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } document . write ( dp [ N ] ) ; } let N = 4 ; findWays ( N ) ;"}
{"text": "Pecahkan rentetan ke bahagian minimum supaya setiap bahagian berada dalam rentetan lain | Pelaksanaan JavaScript untuk memecah rentetan ke dalam bilangan minimum bahagian supaya setiap bahagian juga terdapat dalam rentetan lain; Nod trie; Berfungsi untuk memasukkan nod dalam struktur data trie; Memasukkan setiap watak dari IDX hingga hujung ke rentetan ke dalam trie; Sekiranya tidak ada kelebihan yang sepadan dengan watak ITH, maka buat nod baru; Berfungsi untuk mencari bilangan minimum bahagian supaya setiap bahagian hadir ke dalam rentetan lain; Membuat trie baru; Memasukkan setiap substring S2 di Trie; Mewujudkan array DP dan init dengan tak terhingga; Kes asas; Memulakan pemotongan dari watak yang mengambil penunjuk nod sementara untuk memeriksa sama ada substring [i, j) hadir dalam trie tidak; Sekiranya watak JTH tidak berada di Trie, kami akan berehat; Mengemas kini berakhirnya watak jth dengan dp [i] + 1; Menurunkan penunjuk Trie; Jawapan tidak mungkin; Kod pemacu", "code": "let INF = ( 1e9 + 9 ) ; class Node { constructor ( ) { } } function TrieNode ( ) { let temp = new Node ( ) ; temp . child = new Node ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { temp . child [ i ] = null ; } return temp ; } function insert ( idx , s , root ) { let temp = root ; for ( let i = idx ; i < s . length ; i ++ ) { if ( temp . child [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] == null ) temp . child [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] = new TrieNode ( ) ; temp = temp . child [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ; } } function minCuts ( S1 , S2 ) { let n1 = S1 . length ; let n2 = S2 . length ; let root = new TrieNode ( ) ; for ( let i = 0 ; i < n2 ; i ++ ) { insert ( i , S2 , root ) ; } let dp = new Array ( n1 + 1 ) ; dp . fill ( INF ) ; dp [ 0 ] = 0 ; for ( let i = 0 ; i < n1 ; i ++ ) { let temp = root ; for ( let j = i + 1 ; j <= n1 ; j ++ ) { if ( temp . child [ S1 [ j - 1 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] == null ) break ; dp [ j ] = Math . min ( dp [ j ] , dp [ i ] + 1 ) ; temp = temp . child [ S1 [ j - 1 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ; } } if ( dp [ n1 ] >= INF ) return - 1 ; else return dp [ n1 ] ; } let S1 = \" \" ; let S2 = \" \" ; document . write ( minCuts ( S1 , S2 ) ) ;"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | Berfungsi untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Precomputation of Prefix CountDP Jumlah matriks; Gelung untuk menyelesaikan setiap pertanyaan; Carian binari ke sisi yang mempunyai atmost dalam k 1 's di persegi; Kira jumlah 1 s dalam sub persegi yang dipertimbangkan; Jika kiraan kurang daripada atau sama dengan langkah maksimum ke separuh kanan; Kod pemacu", "code": "function largestSquare ( matrix , R , C , q_i , q_j , K , Q ) { let countDP = new Array ( R ) ; for ( let i = 0 ; i < R ; i ++ ) { countDP [ i ] = new Array ( C ) ; for ( let j = 0 ; j < C ; j ++ ) countDP [ i ] [ j ] = 0 ; } countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( let i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( let j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( let i = 1 ; i < R ; i ++ ) for ( let j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( let q = 0 ; q < Q ; q ++ ) { let i = q_i [ q ] ; let j = q_j [ q ] ; let min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; let ans = - 1 , l = 0 , u = min_dist ; while ( l <= u ) { let mid = Math . floor ( ( l + u ) / 2 ) ; let x1 = i - mid , x2 = i + mid ; let y1 = j - mid , y2 = j + mid ; let count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } document . write ( ans + \" \" ) ; } } let matrix = [ [ 1 , 0 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 0 ] ] ; let K = 9 , Q = 1 ; let q_i = [ 1 ] ; let q_j = [ 2 ] ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ;"}
