{"text":"Program to print ' N ' alphabet using the number pattern from 1 to n | C implementation of the approach ; Function to print the desired Alphabet N Pattern ; Declaring the values of Right , Left and Diagonal values ; Main Loop for the rows ; For the left Values ; Spaces for the diagonals ; Condition for the diagonals ; Spaces for the Right Values ; For the right values ; Driver Code ; Size of the Pattern ; Calling the function to print the desired Pattern","code":"#include <stdio.h> NEW_LINE void Alphabet_N_Pattern ( int N ) { int index , side_index , size ; int Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { printf ( \" % d \" , Left ++ ) ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) printf ( \" \u2581 \" ) ; if ( index != 0 && index != N - 1 ) printf ( \" % d \" , Diagonal ++ ) ; else printf ( \" \u2581 \" ) ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) printf ( \" \u2581 \" ) ; printf ( \" % d \" , Right ++ ) ; printf ( \" STRNEWLINE \" ) ; } } int main ( int argc , char * * argv ) { int Size = 6 ; Alphabet_N_Pattern ( Size ) ; }"}
{"text":"Permutation Coefficient | A Dynamic Programming based solution that uses table P [ ] [ ] to calculate the Permutation Coefficient ; Returns value of Permutation Coefficient P ( n , k ) ; Calculate value of Permutation Coefficient in bottom up manner ; Base Cases ; Calculate value using previosly stored values ; This step is important as P ( i , j ) = 0 for j > i ; Driver Code","code":"#include <bits\/stdc++.h> NEW_LINE int permutationCoeff ( int n , int k ) { int P [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= std : : min ( i , k ) ; j ++ ) { if ( j == 0 ) P [ i ] [ j ] = 1 ; else P [ i ] [ j ] = P [ i - 1 ] [ j ] + ( j * P [ i - 1 ] [ j - 1 ] ) ; P [ i ] [ j + 1 ] = 0 ; } } return P [ n ] [ k ] ; } int main ( ) { int n = 10 , k = 2 ; printf ( \" Value \u2581 of \u2581 P ( % d , \u2581 % d ) \u2581 is \u2581 % d \u2581 \" , n , k , permutationCoeff ( n , k ) ) ; return 0 ; }"}
{"text":"Permutation Coefficient | A O ( n ) solution that uses table fact [ ] to calculate the Permutation Coefficient ; Returns value of Permutation Coefficient P ( n , k ) ; base case ; Calculate value factorials up to n ; P ( n , k ) = n ! \/ ( n - k ) ! ; Driver Code","code":"#include <bits\/stdc++.h> NEW_LINE int permutationCoeff ( int n , int k ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] \/ fact [ n - k ] ; } int main ( ) { int n = 10 , k = 2 ; printf ( \" Value \u2581 of \u2581 P ( % d , \u2581 % d ) \u2581 is \u2581 % d \u2581 \" , n , k , permutationCoeff ( n , k ) ) ; return 0 ; }"}
{"text":"Dynamic Programming | A recursive solution for subset sum problem ; Returns true if there is a subset of set [ ] with sum equal to given sum ; Base Cases ; If last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following : ( a ) including the last element ( b ) excluding the last element ; Driver code","code":"#include <stdio.h> NEW_LINE bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) \/ sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( \" Found \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) ; else printf ( \" No \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) ; return 0 ; }"}
{"text":"Pell Number | Iterative Pell Number Series in C ; calculate nth pell number ; driver function","code":"#include <stdio.h> NEW_LINE int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c , i ; for ( i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; } int main ( ) { int n = 4 ; printf ( \" % d \" , pell ( n ) ) ; return 0 ; }"}
{"text":"Program for factorial of a number | C program to find factorial of given number ; function to find factorial of given number ; Driver Code","code":"#include < stdio . h NEW_LINE unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; printf ( \" Factorial \u2581 of \u2581 % d \u2581 is \u2581 % d \" , num , factorial ( num ) ) ; return 0 ; }"}
{"text":"Largest subarray with equal number of 0 s and 1 s | A simple program to find the largest subarray with equal number of 0 s and 1 s ; This function Prints the starting and ending indexes of the largest subarray with equal number of 0 s and 1 s . Also returns the size of such subarray . ; Pick a starting point as i ; Consider all subarrays starting from i ; If this is a 0 sum subarray , then compare it with maximum size subarray calculated so far ; Driver program to test above functions","code":"#include <stdio.h> NEW_LINE int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , startindex ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == -1 ) printf ( \" No \u2581 such \u2581 subarray \" ) ; else printf ( \" % d \u2581 to \u2581 % d \" , startindex , startindex + maxsize - 1 ) ; return maxsize ; } int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; findSubArray ( arr , size ) ; return 0 ; }"}
{"text":"Ternary Search | C program to illustrate iterative approach to ternary search ; Function to perform Ternary Search ; Find the mid1 and mid2 ; Check if key is present at any mid ; Since key is not present at mid , check in which region it is present then repeat the Search operation in that region ; The key lies in between l and mid1 ; The key lies in between mid2 and r ; The key lies in between mid1 and mid2 ; Key not found ; Driver code ; Get the array Sort the array if not sorted ; Starting index ; length of array ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result","code":"#include <stdio.h> NEW_LINE int ternarySearch ( int l , int r , int key , int ar [ ] ) { while ( r >= l ) { int mid1 = l + ( r - l ) \/ 3 ; int mid2 = r - ( r - l ) \/ 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) { l = mid2 + 1 ; } else { l = mid1 + 1 ; r = mid2 - 1 ; } } return -1 ; } int main ( ) { int l , r , p , key ; int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; l = 0 ; r = 9 ; key = 5 ; p = ternarySearch ( l , r , key , ar ) ; printf ( \" Index \u2581 of \u2581 % d \u2581 is \u2581 % d STRNEWLINE \" , key , p ) ; key = 50 ; p = ternarySearch ( l , r , key , ar ) ; printf ( \" Index \u2581 of \u2581 % d \u2581 is \u2581 % d \" , key , p ) ; }"}
{"text":"Find the minimum element in a sorted and rotated array | C program to find minimum element in a sorted and rotated array ; This condition is needed to handle the case when array is not rotated at all ; If there is only one element left ; Find mid ; Check if element ( mid + 1 ) is minimum element . Consider the cases like { 3 , 4 , 5 , 1 , 2 } ; Check if mid itself is minimum element ; Decide whether we need to go to left half or right half ; Driver program to test above functions","code":"#include <stdio.h> NEW_LINE int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) \/ 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; } int main ( ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( arr1 ) \/ sizeof ( arr1 [ 0 ] ) ; printf ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 % d STRNEWLINE \" , findMin ( arr1 , 0 , n1 - 1 ) ) ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( arr2 ) \/ sizeof ( arr2 [ 0 ] ) ; printf ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 % d STRNEWLINE \" , findMin ( arr2 , 0 , n2 - 1 ) ) ; int arr3 [ ] = { 1 } ; int n3 = sizeof ( arr3 ) \/ sizeof ( arr3 [ 0 ] ) ; printf ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 % d STRNEWLINE \" , findMin ( arr3 , 0 , n3 - 1 ) ) ; int arr4 [ ] = { 1 , 2 } ; int n4 = sizeof ( arr4 ) \/ sizeof ( arr4 [ 0 ] ) ; printf ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 % d STRNEWLINE \" , findMin ( arr4 , 0 , n4 - 1 ) ) ; int arr5 [ ] = { 2 , 1 } ; int n5 = sizeof ( arr5 ) \/ sizeof ( arr5 [ 0 ] ) ; printf ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 % d STRNEWLINE \" , findMin ( arr5 , 0 , n5 - 1 ) ) ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = sizeof ( arr6 ) \/ sizeof ( arr6 [ 0 ] ) ; printf ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 % d STRNEWLINE \" , findMin ( arr6 , 0 , n6 - 1 ) ) ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = sizeof ( arr7 ) \/ sizeof ( arr7 [ 0 ] ) ; printf ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 % d STRNEWLINE \" , findMin ( arr7 , 0 , n7 - 1 ) ) ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = sizeof ( arr8 ) \/ sizeof ( arr8 [ 0 ] ) ; printf ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 % d STRNEWLINE \" , findMin ( arr8 , 0 , n8 - 1 ) ) ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = sizeof ( arr9 ) \/ sizeof ( arr9 [ 0 ] ) ; printf ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 % d STRNEWLINE \" , findMin ( arr9 , 0 , n9 - 1 ) ) ; return 0 ; }"}
{"text":"Find the smallest and second smallest elements in an array | C program to find smallest and second smallest elements ; For INT_MAX ; There should be atleast two elements ; If current element is smaller than first then update both first and second ; If arr [ i ] is in between first and second then update second ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE void print2Smallest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { printf ( \" \u2581 Invalid \u2581 Input \u2581 \" ) ; return ; } first = second = INT_MAX ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MAX ) printf ( \" There \u2581 is \u2581 no \u2581 second \u2581 smallest \u2581 element STRNEWLINE \" ) ; else printf ( \" The \u2581 smallest \u2581 element \u2581 is \u2581 % d \u2581 and \u2581 second \u2581 \" \" Smallest \u2581 element \u2581 is \u2581 % d STRNEWLINE \" , first , second ) ; } int main ( ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; print2Smallest ( arr , n ) ; return 0 ; }"}
{"text":"Subset Sum Problem in O ( sum ) space | Returns true if there exists a subset with given sum in arr [ ] ; The value of subset [ i % 2 ] [ j ] will be true if there exists a subset of sum j in arr [ 0 , 1 , ... . , i - 1 ] ; A subset with sum 0 is always possible ; If there exists no element no sum is possible ; Driver code","code":"#include <stdio.h> NEW_LINE #include <stdbool.h> NEW_LINE bool isSubsetSum ( int arr [ ] , int n , int sum ) { bool subset [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; } int main ( ) { int arr [ ] = { 6 , 2 , 5 } ; int sum = 7 ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; if ( isSubsetSum ( arr , n , sum ) == true ) printf ( \" There \u2581 exists \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) ; else printf ( \" No \u2581 subset \u2581 exists \u2581 with \u2581 given \u2581 sum \" ) ; return 0 ; }"}
{"text":"Majority Element | Program for finding out majority element in an array ; Function to find the candidate for Majority ; Function to check if the candidate occurs more than n \/ 2 * times ; Function to print Majority Element ; Find the candidate for Majority ; Print the candidate if it is Majority ; Driver code ; Function call","code":"#include <stdio.h> NEW_LINE #define bool  int NEW_LINE int findCandidate ( int * , int ) ; bool isMajority ( int * , int , int ) ; int findCandidate ( int a [ ] , int size ) { int maj_index = 0 , count = 1 ; int i ; for ( i = 1 ; i < size ; i ++ ) { if ( a [ maj_index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj_index = i ; count = 1 ; } } return a [ maj_index ] ; } bool isMajority ( int a [ ] , int size , int cand ) { int i , count = 0 ; for ( i = 0 ; i < size ; i ++ ) if ( a [ i ] == cand ) count ++ ; if ( count > size \/ 2 ) return 1 ; else return 0 ; } void printMajority ( int a [ ] , int size ) { int cand = findCandidate ( a , size ) ; if ( isMajority ( a , size , cand ) ) printf ( \" \u2581 % d \u2581 \" , cand ) ; else printf ( \" No \u2581 Majority \u2581 Element \" ) ; } int main ( ) { int a [ ] = { 1 , 3 , 3 , 1 , 2 } ; int size = ( sizeof ( a ) ) \/ sizeof ( a [ 0 ] ) ; printMajority ( a , size ) ; getchar ( ) ; return 0 ; }"}
{"text":"Dynamic Programming | A Dynamic Programming solution for subset sum problem ; Returns true if there is a subset of set [ ] with sum equal to given sum ; The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i ; If sum is 0 , then answer is true ; If sum is not 0 and set is empty , then answer is false ; Fill the subset table in bottom up manner ; uncomment this code to print table ; Driver code","code":"#include <stdio.h> NEW_LINE bool isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( \" % 4d \" , subset [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } return subset [ n ] [ sum ] ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) \/ sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( \" Found \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) ; else printf ( \" No \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) ; return 0 ; }"}
{"text":"Program to find whether a given number is power of 2 |  ; Function to check if x is power of 2 ; First x in the below expression is for the case when x is 0 ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; isPowerOfTwo ( 64 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; return 0 ; }"}
{"text":"Smallest power of 2 greater than or equal to n | C program to find smallest power of 2 greater than or equal to n ; First n in the below condition is for the case where n is 0 ; Driver Code","code":"#include <stdio.h> NEW_LINE unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int main ( ) { unsigned int n = 0 ; printf ( \" % d \" , nextPowerOf2 ( n ) ) ; return 0 ; }"}
{"text":"Count ways to reach the nth stair using step 1 , 2 or 3 | A C program to count number of ways to reach n 't stair when ; A recursive function used by countWays ; Driver program to test above functions","code":"#include <stdio.h> NEW_LINE int countWays ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; } int main ( ) { int n = 4 ; printf ( \" % d \" , countWays ( n ) ) ; return 0 ; }"}
{"text":"Dynamic Programming | High | A naive recursive C program to find maximum tasks . ; Returns the maximum among the 2 numbers ; Returns maximum amount of task that can be done till day n ; If n is less than equal to 0 , then no solution exists ; Determines which task to choose on day n , then returns the maximum till that day ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE int max ( int x , int y ) { return ( x > y ? x : y ) ; } int maxTasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; } int main ( ) { int n = 5 ; int high [ ] = { 3 , 6 , 8 , 7 , 6 } ; int low [ ] = { 1 , 5 , 4 , 5 , 3 } ; printf ( \" % dn \" , maxTasks ( high , low , n ) ) ; return 0 ; }"}
{"text":"Count words in a given string | C program to count no of words from given input string . ; returns number of words in str ; word count ; Scan all characters one by one ; If next character is a separator , set the state as OUT ; If next character is not a word separator and state is OUT , then set the state as IN and increment word count ; Move to next character ; Driver program to tes above functions","code":"#include <stdio.h> NEW_LINE #define OUT \t0 NEW_LINE #define IN \t1 NEW_LINE unsigned countWords ( char * str ) { int state = OUT ; unsigned wc = 0 ; while ( * str ) { if ( * str == ' \u2581 ' * str == ' ' * str == ' TABSYMBOL ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ str ; } return wc ; } int main ( void ) { char str [ ] = \" One \u2581 two TABSYMBOL TABSYMBOL three STRNEWLINE TABSYMBOL four TABSYMBOL five \u2581 \" ; printf ( \" No \u2581 of \u2581 words \u2581 : \u2581 % u \" , countWords ( str ) ) ; return 0 ; }"}
{"text":"Dynamic Programming | High | A DP based C ++ program to find maximum tasks . ; Returns the maximum among the 2 numbers ; Returns maximum amount of task that can be done till day n ; An array task_dp that stores the maximum task done ; If n = 0 , no solution exists ; If n = 1 , high effort task on that day will be the solution ; Fill the entire array determining which task to choose on day i ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE int max ( int x , int y ) { return ( x > y ? x : y ) ; } int maxTasks ( int high [ ] , int low [ ] , int n ) { int task_dp [ n + 1 ] ; task_dp [ 0 ] = 0 ; task_dp [ 1 ] = high [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) task_dp [ i ] = max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; } int main ( ) { int n = 5 ; int high [ ] = { 3 , 6 , 8 , 7 , 6 } ; int low [ ] = { 1 , 5 , 4 , 5 , 3 } ; printf ( \" % d \" , maxTasks ( high , low , n ) ) ; return 0 ; }"}
{"text":"Partition problem | DP | A Dynamic Programming based C program to partition problem ; Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; Calculate sum of all elements ; initialize top row as true ; initialize leftmost column , except part [ 0 ] [ 0 ] , as 0 ; Fill the partition table in bottom up manner ; uncomment this part to print table ; Driver code ; Function call","code":"#include <stdio.h> NEW_LINE bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum \/ 2 + 1 ] [ n + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ; for ( i = 1 ; i <= sum \/ 2 ; i ++ ) part [ i ] [ 0 ] = false ; for ( i = 1 ; i <= sum \/ 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } } return part [ sum \/ 2 ] [ n ] ; } int main ( ) { int arr [ ] = { 3 , 1 , 1 , 2 , 2 , 1 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) printf ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) ; else printf ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 subsets \u2581 of \u2581 \" \" equal \u2581 sum \" ) ; getchar ( ) ; return 0 ; }"}
{"text":"DFA for Strings not ending with \" THE \" | C program to implement DFS that accepts all string that do not end with \" THE \" ; dfa tells the number associated with the present state ; This function is for the starting state ( zeroth ) of DFA ; On receiving ' T ' or ' t ' goto first state ( 1 ) ; This function is for the first state of DFA ; On receiving ' T ' or ' t ' goto first state ( 1 ) ; On receiving ' H ' or ' h ' goto second state ( 2 ) ; else goto starting state ( 0 ) ; This function is for the second state of DFA ; On receiving ' E ' or ' e ' goto third state ( 3 ) else goto starting state ( 0 ) ; This function is for the third state of DFA ; On receiving ' T ' or ' t ' goto first state ( 1 ) else goto starting state ( 0 ) ; store length of string ; driver code","code":"#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int dfa = 0 ; void start ( char c ) { if ( c == ' t ' c == ' T ' ) dfa = 1 ; } void state1 ( char c ) { if ( c == ' t ' c == ' T ' ) dfa = 1 ; else if ( c == ' h ' c == ' H ' ) dfa = 2 ; else dfa = 0 ; } void state2 ( char c ) { if ( c == ' e ' c == ' E ' ) dfa = 3 ; else if ( c == ' t ' c == ' T ' ) dfa = 1 ; else dfa = 0 ; } void state3 ( char c ) { if ( c == ' t ' c == ' T ' ) dfa = 1 ; else dfa = 0 ; } bool isAccepted ( char str [ ] ) { int len = strlen ( str ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; } int main ( ) { char str [ ] = \" forTHEgeeks \" ; if ( isAccepted ( str ) == true ) printf ( \" ACCEPTED STRNEWLINE \" ) ; else printf ( \" NOT \u2581 ACCEPTED STRNEWLINE \" ) ; return 0 ; }"}
{"text":"Program to find the sum of a Series 1 + 1 \/ 2 ^ 2 + 1 \/ 3 ^ 3 + \u00e2 \u20ac\u00a6 . . + 1 \/ n ^ n | C program to calculate the following series ; Function to calculate the following series ; Driver Code","code":"#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 \/ pow ( i , i ) ; sums += ser ; } return sums ; } int main ( ) { int n = 3 ; double res = Series ( n ) ; printf ( \" % .5f \" , res ) ; return 0 ; }"}
{"text":"Ternary Search | C program to illustrate recursive approach to ternary search ; Function to perform Ternary Search ; Find the mid1 and mid2 ; Check if key is present at any mid ; Since key is not present at mid , check in which region it is present then repeat the Search operation in that region ; The key lies in between l and mid1 ; The key lies in between mid2 and r ; The key lies in between mid1 and mid2 ; Key not found ; Driver code ; Get the array Sort the array if not sorted ; Starting index ; length of array ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result","code":"#include <stdio.h> NEW_LINE int ternarySearch ( int l , int r , int key , int ar [ ] ) { if ( r >= l ) { int mid1 = l + ( r - l ) \/ 3 ; int mid2 = r - ( r - l ) \/ 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) { return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else { return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } } return -1 ; } int main ( ) { int l , r , p , key ; int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; l = 0 ; r = 9 ; key = 5 ; p = ternarySearch ( l , r , key , ar ) ; printf ( \" Index \u2581 of \u2581 % d \u2581 is \u2581 % d STRNEWLINE \" , key , p ) ; key = 50 ; p = ternarySearch ( l , r , key , ar ) ; printf ( \" Index \u2581 of \u2581 % d \u2581 is \u2581 % d \" , key , p ) ; }"}
{"text":"Program for addition of two matrices |  ; This function adds A [ ] [ ] and B [ ] [ ] , and stores the result in C [ ] [ ] ; Driver code","code":"#include <stdio.h> NEW_LINE #define N  4 NEW_LINE void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; add ( A , B , C ) ; printf ( \" Result \u2581 matrix \u2581 is \u2581 STRNEWLINE \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) printf ( \" % d \u2581 \" , C [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } return 0 ; }"}
{"text":"Program for subtraction of matrices |  ; This function subtracts B [ ] [ ] from A [ ] [ ] , and stores the result in C [ ] [ ] ; To store result","code":"#include <stdio.h> NEW_LINE #define N  4 NEW_LINE void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; subtract ( A , B , C ) ; printf ( \" Result \u2581 matrix \u2581 is \u2581 STRNEWLINE \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) printf ( \" % d \u2581 \" , C [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } return 0 ; }"}
{"text":"Find a Fixed Point ( Value equal to index ) in a given array | C program to check fixed point in an array using linear search ; If no fixed point present then return - 1 ; Driver program to check above functions","code":"#include <stdio.h> NEW_LINE int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printf ( \" Fixed \u2581 Point \u2581 is \u2581 % d \" , linearSearch ( arr , n ) ) ; getchar ( ) ; return 0 ; }"}
{"text":"Find a Fixed Point ( Value equal to index ) in a given array | C program to check fixed point in an array using binary search ; low + ( high - low ) \/ 2 ; ; Return - 1 if there is no Fixed Point ; Driver program to check above functions","code":"#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) \/ 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return -1 ; } int main ( ) { int arr [ 10 ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printf ( \" Fixed \u2581 Point \u2581 is \u2581 % d \" , binarySearch ( arr , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text":"Linear Search | C code to linearly search x in arr [ ] . If x is present then return its location , otherwise return - 1 ; Driver code ; Function call","code":"#include <stdio.h> NEW_LINE int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; int result = search ( arr , n , x ) ; ( result == -1 ) ? printf ( \" Element \u2581 is \u2581 not \u2581 present \u2581 in \u2581 array \" ) : printf ( \" Element \u2581 is \u2581 present \u2581 at \u2581 index \u2581 % d \" , result ) ; return 0 ; }"}
{"text":"Counting Sort | C Program for counting sort ; The main function that sort the given string arr [ ] in alphabatical order ; The output character array that will have sorted arr ; Create a count array to store count of inidividul characters and initialize count array as 0 ; Store count of each character ; Change count [ i ] so that count [ i ] now contains actual position of this character in output array ; Build the output character array ; Copy the output array to arr , so that arr now contains sorted characters ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define RANGE  255 NEW_LINE void countSort ( char arr [ ] ) { char output [ strlen ( arr ) ] ; int count [ RANGE + 1 ] , i ; memset ( count , 0 , sizeof ( count ) ) ; for ( i = 0 ; arr [ i ] ; ++ i ) ++ count [ arr [ i ] ] ; for ( i = 1 ; i <= RANGE ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( i = 0 ; arr [ i ] ; ++ i ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( i = 0 ; arr [ i ] ; ++ i ) arr [ i ] = output [ i ] ; } int main ( ) { char arr [ ] = \" geeksforgeeks \" ; countSort ( arr ) ; printf ( \" Sorted \u2581 character \u2581 array \u2581 is \u2581 % sn \" , arr ) ; return 0 ; }"}
{"text":"Binomial Coefficient | DP | A Naive Recursive Implementation ; Returns value of Binomial Coefficient C ( n , k ) ; Base Cases ; Recur ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; } int main ( ) { int n = 5 , k = 2 ; printf ( \" Value \u2581 of \u2581 C ( % d , \u2581 % d ) \u2581 is \u2581 % d \u2581 \" , n , k , binomialCoeff ( n , k ) ) ; return 0 ; }"}
{"text":"How to print maximum number of A 's using given four keys | A recursive C program to print maximum number of A 's using  following four keys  ; A recursive function that returns the optimal length string for N keystrokes ; The optimal string length is N when N is smaller than 7 ; Initialize result ; TRY ALL POSSIBLE BREAK - POINTS For any keystroke N , we need to loop from N - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have Ctrl - A , Ctrl - C and then only Ctrl - V all the way . ; If the breakpoint is s at b 'th keystroke then  the optimal string would have length  (n-b-1)*screen[b-1]; ; Driver program ; for the rest of the array we will rely on the previous entries to compute new ones","code":"#include <stdio.h> NEW_LINE int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) printf ( \" Maximum \u2581 Number \u2581 of \u2581 A ' s \u2581 with \u2581 % d \u2581 keystrokes \u2581 is \u2581 % d STRNEWLINE \" , N , findoptimal ( N ) ) ; }"}
{"text":"How to print maximum number of A 's using given four keys | A Dynamic Programming based C program to find maximum number of A 's  that can be printed using four keys  ; this function returns the optimal length string for N keystrokes ; The optimal string length is N when N is smaller than 7 ; An array to store result of subproblems ; To pick a breakpoint ; Initializing the optimal lengths array for uptil 6 input strokes . ; Solve all subproblems in bottom manner ; Initialize length of optimal string for n keystrokes ; For any keystroke n , we need to loop from n - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have ctrl - a , ctrl - c and then only ctrl - v all the way . ; if the breakpoint is at b 'th keystroke then  the optimal string would have length  (n-b-1)*screen[b-1]; ; Driver program ; for the rest of the array we will rely on the previous entries to compute new ones","code":"#include <stdio.h> NEW_LINE int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) printf ( \" Maximum \u2581 Number \u2581 of \u2581 A ' s \u2581 with \u2581 % d \u2581 keystrokes \u2581 is \u2581 % d STRNEWLINE \" , N , findoptimal ( N ) ) ; }"}
{"text":"Write a program to calculate pow ( x , n ) |  ; Function to calculate x raised to the power y ; Program to test function power","code":"#include <stdio.h> NEW_LINE int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y \/ 2 ) * power ( x , y \/ 2 ) ; else return x * power ( x , y \/ 2 ) * power ( x , y \/ 2 ) ; } int main ( ) { int x = 2 ; unsigned int y = 3 ; printf ( \" % d \" , power ( x , y ) ) ; return 0 ; }"}
{"text":"Write a program to calculate pow ( x , n ) | Function to calculate x raised to the power y in O ( logn )","code":"int power ( int x , unsigned int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y \/ 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }"}
{"text":"Write a program to calculate pow ( x , n ) | Extended version of power function that can work for float x and negative y ; Program to test function power","code":"#include <stdio.h> NEW_LINE float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y \/ 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) \/ x ; } } int main ( ) { float x = 2 ; int y = -3 ; printf ( \" % f \" , power ( x , y ) ) ; return 0 ; }"}
{"text":"Babylonian method for square root |  ; Returns the square root of n . Note that the function ; We are using n itself as initial approximation This can definitely be improved ; e decides the accuracy level ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) \/ 2 ; y = n \/ x ; } return x ; } int main ( ) { int n = 50 ; printf ( \" Square \u2581 root \u2581 of \u2581 % d \u2581 is \u2581 % f \" , n , squareRoot ( n ) ) ; getchar ( ) ; }"}
{"text":"Average of a stream of numbers |  ; Returns the new average after including x ; Prints average of a stream of numbers ; Driver program to test above functions","code":"#include <stdio.h> NEW_LINE float getAvg ( int x ) { static int sum , n ; sum += x ; return ( ( ( float ) sum ) \/ ++ n ) ; } void streamAvg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( arr [ i ] ) ; printf ( \" Average \u2581 of \u2581 % d \u2581 numbers \u2581 is \u2581 % f \u2581 STRNEWLINE \" , i + 1 , avg ) ; } return ; } int main ( ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; streamAvg ( arr , n ) ; return 0 ; }"}
{"text":"Space and time efficient Binomial Coefficient | Program to calculate C ( n , k ) ; Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- -- * 1 ] ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; } int main ( ) { int n = 8 , k = 2 ; printf ( \" Value \u2581 of \u2581 C ( % d , \u2581 % d ) \u2581 is \u2581 % d \u2581 \" , n , k , binomialCoeff ( n , k ) ) ; return 0 ; }"}
{"text":"Efficient program to print all prime factors of a given number | Program to print all prime factors ; A function to print all prime factors of a given number n ; Print the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Driver program to test above function","code":"# include <stdio.h> NEW_LINE # include <math.h> NEW_LINE void primeFactors ( int n ) { while ( n % 2 == 0 ) { printf ( \" % d \u2581 \" , 2 ) ; n = n \/ 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { printf ( \" % d \u2581 \" , i ) ; n = n \/ i ; } } if ( n > 2 ) printf ( \" % d \u2581 \" , n ) ; } int main ( ) { int n = 315 ; primeFactors ( n ) ; return 0 ; }"}
{"text":"Print all possible combinations of r elements in a given array of size n | Program to print all combination of size r in an array of size n ; The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( ) ; A temporary array to store all combination one by one ; Print all combination using temprary array ' data [ ] ' ; arr [ ] -- -> Input Array data [ ] -- -> Temporary array to store current combination start & end -- -> Staring and Ending indexes in arr [ ] index -- -> Current index in data [ ] r -- -> Size of a combination to be printed ; Current combination is ready to be printed , print it ; replace index with all possible elements . The condition \" end - i + 1 \u2581 > = \u2581 r - index \" makes sure that including one element at index will make a combination with remaining elements at remaining positions ; Driver program to test above functions","code":"#include <stdio.h> NEW_LINE void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) ; void printCombination ( int arr [ ] , int n , int r ) { int data [ r ] ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; } void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) printf ( \" % d \u2581 \" , data [ j ] ) ; printf ( \" STRNEWLINE \" ) ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printCombination ( arr , n , r ) ; }"}
{"text":"Print all possible combinations of r elements in a given array of size n | Program to print all combination of size r in an array of size n ; The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( ) ; A temporary array to store all combination one by one ; Print all combination using temprary array ' data [ ] ' ; arr [ ] -- -> Input Array n -- -> Size of input array r -- -> Size of a combination to be printed index -- -> Current index in data [ ] data [ ] -- -> Temporary array to store current combination i -- -> index of current element in arr [ ] ; Current cobination is ready , print it ; When no more elements are there to put in data [ ] ; current is included , put next at next location ; current is excluded , replace it with next ( Note that i + 1 is passed , but index is not changed ) ; Driver program to test above functions","code":"#include <stdio.h> NEW_LINE void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) ; void printCombination ( int arr [ ] , int n , int r ) { int data [ r ] ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; } void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) printf ( \" % d \u2581 \" , data [ j ] ) ; printf ( \" STRNEWLINE \" ) ; return ; } if ( i >= n ) return ; data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ; combinationUtil ( arr , n , r , index , data , i + 1 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printCombination ( arr , n , r ) ; return 0 ; }"}
{"text":"Count all possible groups of size 2 or 3 that have sum as multiple of 3 | C Program to count all possible groups of size 2 or 3 that have sum as multiple of 3 ; Returns count of all possible groups that can be formed from elements of a [ ] . ; Create an array C [ 3 ] to store counts of elements with remainder 0 , 1 and 2. c [ i ] would store count of elements with remainder i ; To store the result ; Count elements with remainder 0 , 1 and 2 ; Case 3. a : Count groups of size 2 from 0 remainder elements ; Case 3. b : Count groups of size 2 with one element with 1 remainder and other with 2 remainder ; Case 4. a : Count groups of size 3 with all 0 remainder elements ; Case 4. b : Count groups of size 3 with all 1 remainder elements ; Case 4. c : Count groups of size 3 with all 2 remainder elements ; Case 4. c : Count groups of size 3 with different remainders ; Return total count stored in res ; Driver program to test above functions","code":"#include <stdio.h> NEW_LINE int findgroups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 } , i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) \/ 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) \/ 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) \/ 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; } int main ( ) { int arr [ ] = { 3 , 6 , 7 , 2 , 9 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printf ( \" Required \u2581 number \u2581 of \u2581 groups \u2581 are \u2581 % d STRNEWLINE \" , findgroups ( arr , n ) ) ; return 0 ; }"}
{"text":"Smallest power of 2 greater than or equal to n |  ; First n in the below condition is for the case where n is 0 ; Driver Code","code":"#include <stdio.h> NEW_LINE unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int main ( ) { unsigned int n = 0 ; printf ( \" % d \" , nextPowerOf2 ( n ) ) ; return 0 ; }"}
{"text":"Smallest power of 2 greater than or equal to n |  ; Driver Code","code":"#include <stdio.h> NEW_LINE unsigned int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } int main ( ) { unsigned int n = 5 ; printf ( \" % d \" , nextPowerOf2 ( n ) ) ; return 0 ; }"}
{"text":"Smallest power of 2 greater than or equal to n |  ; Finds next power of two for n . If n itself is a power of two then returns n ; Driver Code","code":"#include <stdio.h> NEW_LINE unsigned int nextPowerOf2 ( unsigned int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; } int main ( ) { unsigned int n = 5 ; printf ( \" % d \" , nextPowerOf2 ( n ) ) ; return 0 ; }"}
{"text":"Segregate 0 s and 1 s in an array | C program to sort a binary array in one pass ; Function to put all 0 s on left and all 1 s on right ; Initialize left and right indexes ; Increment left index while we see 0 at left ; Decrement right index while we see 1 at right ; If left is smaller than right then there is a 1 at left and a 0 at right . Exchange arr [ left ] and arr [ right ] ; driver program to test","code":"#include <stdio.h> NEW_LINE void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , arr_size ) ; printf ( \" Array \u2581 after \u2581 segregation \u2581 \" ) ; for ( i = 0 ; i < 6 ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; getchar ( ) ; return 0 ; }"}
{"text":"Given an array arr [ ] , find the maximum j | C program for the above approach ; For a given array arr [ ] , returns the maximum j a i such that arr [ j ] > arr [ i ] ; Driver program to test above functions","code":"#include <stdio.h> NEW_LINE int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = -1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; } int main ( ) { int arr [ ] = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; int maxDiff = maxIndexDiff ( arr , n ) ; printf ( \" % d \" , maxDiff ) ; getchar ( ) ; return 0 ; }"}
{"text":"Count ways to reach the nth stair using step 1 , 2 or 3 | Program to find n - th stair using step size 1 or 2 or 3. ; Returns count of ways to reach n - th stair using 1 or 2 or 3 steps . ; Driver code","code":"#include <stdio.h> NEW_LINE int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; } int main ( ) { int n = 4 ; printf ( \" % d STRNEWLINE \" , findStep ( n ) ) ; return 0 ; }"}
{"text":"Partition problem | DP | A recursive C program for partition problem ; A utility function that returns true if there is a subset of arr [ ] with sun equal to given sum ; Base Cases ; If last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element ; Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; Calculate sum of the elements in array ; If sum is odd , there cannot be two subsets with equal sum ; Find if there is subset with sum equal to half of total sum ; Driver code ; Function call","code":"#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE bool isSubsetSum ( int arr [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ; return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; } bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; return isSubsetSum ( arr , n , sum \/ 2 ) ; } int main ( ) { int arr [ ] = { 3 , 1 , 5 , 9 , 12 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) printf ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 subsets \u2581 \" \" of \u2581 equal \u2581 sum \" ) ; else printf ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 subsets \" \" \u2581 of \u2581 equal \u2581 sum \" ) ; return 0 ; }"}
{"text":"Find repeated character present first in a string | C program to find the first character that is repeated ; this is O ( N ^ 2 ) method ; Driver code","code":"#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int findRepeatFirstN2 ( char * s ) { int p = -1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; } int main ( ) { char str [ ] = \" geeksforgeeks \" ; int pos = findRepeatFirstN2 ( str ) ; if ( pos == -1 ) printf ( \" Not \u2581 found \" ) ; else printf ( \" % c \" , str [ pos ] ) ; return 0 ; }"}
{"text":"Reverse words in a given string | C program for above approach : ; temp is for word boundary ; STEP 1 of the above algorithm ; This condition is to make sure that the string start with valid character ( not space ) only ; STEP 2 of the above algorithm","code":"void reverseWords ( char * s ) { char * word_begin = NULL ; char * temp = s ; while ( * temp ) { if ( ( word_begin == NULL ) && ( * temp != ' \u2581 ' ) ) { word_begin = temp ; } if ( word_begin && ( ( * ( temp + 1 ) == ' \u2581 ' ) || ( * ( temp + 1 ) == ' \\0' ) ) ) { reverse ( word_begin , temp ) ; word_begin = NULL ; } temp ++ ; } reverse ( s , temp - 1 ) ; }"}
{"text":"Sum of all odd length palindromic numbers within the range [ L , R ] | C program to find the sum of all odd length palindromic numbers within the given range ; Function that returns true if the given number is a palindrome ; Here we are generating a new number ( reverse_num ) * by reversing the digits of original input number ; If the original input number ( num ) is equal to * to its reverse ( reverse_num ) then its palindrome * else it is not . ; Function that returns true if the given number is of odd length ; Function to return the sum of all odd length palindromic numbers within the given range ; if number is palindrome and of odd length ; Driver code","code":"#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE bool isPalindrome ( int num ) { int reverse_num = 0 , remainder , temp ; temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp \/= 10 ; } if ( reverse_num == num ) { return true ; } return false ; } bool isOddLength ( int num ) { int count = 0 ; while ( num > 0 ) { num \/= 10 ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; } long sumOfAllPalindrome ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; } int main ( ) { int L = 110 , R = 1130 ; printf ( \" % ld \" , sumOfAllPalindrome ( L , R ) ) ; }"}
{"text":"Subtract 1 without arithmetic operators | C code to subtract one from a given number ; Flip all the set bits until we find a 1 ; flip the rightmost 1 bit ; Driver program to test above functions","code":"#include <stdio.h> NEW_LINE int subtractOne ( int x ) { int m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } int main ( ) { printf ( \" % d \" , subtractOne ( 13 ) ) ; return 0 ; }"}
{"text":"Sum of the multiples of two numbers below N | C program for above approach ; Function to return the sum of all the integers below N which are multiples of either A or B ; If i is a multiple of a or b ; Driver Code","code":"#include <stdio.h> NEW_LINE int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; } int main ( ) { int n = 10 , a = 3 , b = 5 ; printf ( \" % d \" , findSum ( n , a , b ) ) ; return 0 ; }"}
{"text":"Pell Number | Pell Number Series using Recursion in C ; calculate nth pell number ; driver function","code":"#include <stdio.h> NEW_LINE int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; } int main ( ) { int n = 4 ; printf ( \" % d \" , pell ( n ) ) ; return 0 ; }"}
{"text":"Legendre 's formula (Given p and n, find the largest x such that p^x divides n!) | C program to find largest x such that p * x divides n ! ; Returns largest power of p that divides n ! ; Initialize result ; Calculate x = n \/ p + n \/ ( p ^ 2 ) + n \/ ( p ^ 3 ) + ... . ; Driver program","code":"#include <stdio.h> NEW_LINE int largestPower ( int n , int p ) { int x = 0 ; while ( n ) { n \/= p ; x += n ; } return x ; } int main ( ) { int n = 10 , p = 3 ; printf ( \" The \u2581 largest \u2581 power \u2581 of \u2581 % d \u2581 that \u2581 divides \u2581 % d ! \u2581 is \u2581 % d STRNEWLINE \" , p , n , largestPower ( n , p ) ) ; return 0 ; }"}
{"text":"Program for factorial of a number | C ++ program to find factorial of given number ; single line to find factorial ; Driver Code","code":"#include <stdio.h> NEW_LINE int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; printf ( \" Factorial \u2581 of \u2581 % d \u2581 is \u2581 % d \" , num , factorial ( num ) ) ; return 0 ; }"}
{"text":"Extract ' k ' bits from a given position in a number . | C program to extract k bits from a given position . ; Function to extract k bits from p position and returns the extracted value as integer ; Driver code","code":"#include <stdio.h> NEW_LINE int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; } int main ( ) { int number = 171 , k = 5 , p = 2 ; printf ( \" The \u2581 extracted \u2581 number \u2581 is \u2581 % d \" , bitExtracted ( number , k , p ) ) ; return 0 ; }"}
{"text":"Largest gap in an array | A C program to find largest gap between two elements in an array . ; function to solve the given problem ; Driver Code","code":"#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int solve ( int a [ ] , int n ) { int max1 = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , -4 , -10 , 22 } ; int size = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printf ( \" Largest \u2581 gap \u2581 is \u2581 : \u2581 % d \" , solve ( arr , size ) ) ; return 0 ; }"}
{"text":"Largest gap in an array | A C program to find largest gap between two elements in an array . ; function to solve the given problem ; finding maximum and minimum of an array ; Driver Code","code":"#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return abs ( min1 - max1 ) ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , 4 , -10 } ; int size = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printf ( \" Largest \u2581 gap \u2581 is \u2581 : \u2581 % d \" , solve ( arr , size ) ) ; return 0 ; }"}
