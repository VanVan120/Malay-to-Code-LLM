{"text":"Distance between two parallel Planes in 3 | C program to find the Distance between two parallel Planes in 3 D . ; Function to find distance ; Driver Code","code":"#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 \/ a2 == b1 \/ b2 && b1 \/ b2 == c1 \/ c2 ) { x1 = y1 = 0 ; z1 = - d1 \/ c1 ; d = fabs ( ( c2 * z1 + d2 ) ) \/ ( sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; printf ( \" Perpendicular \u2581 distance \u2581 is \u2581 % f STRNEWLINE \" , d ) ; } else printf ( \" Planes \u2581 are \u2581 not \u2581 parallel \" ) ; return ; } int main ( ) { float a1 = 1 ; float b1 = 2 ; float c1 = -1 ; float d1 = 1 ; float a2 = 3 ; float b2 = 6 ; float c2 = -3 ; float d2 = -4 ; distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) ; return 0 ; }"}
{"text":"Program to find the sum of a Series ( 1 * 1 ) + ( 2 * 2 ) + ( 3 * 3 ) + ( 4 * 4 ) + ( 5 * 5 ) + ... + ( n * n ) | C program to calculate the following series ; Function to calculate the following series ; Driver Code","code":"#include <stdio.h> NEW_LINE int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; } int main ( ) { int n = 3 ; int res = Series ( n ) ; printf ( \" % d \" , res ) ; }"}
{"text":"Check if array contains contiguous integers with duplicates allowed | Sorting based C ++ implementation to check whether the array contains a set of contiguous integers ; function to check whether the array contains a set of contiguous integers ; Sort the array ; After sorting , check if current element is either same as previous or is one more . ; Driver program to test above","code":"#include <bits\/stdc++.h> NEW_LINE using namespace std ; bool areElementsContiguous ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] > 1 ) return false ; return true ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; if ( areElementsContiguous ( arr , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text":"Program for array rotation | C program to rotate an array by d elements ; Function to left Rotate arr [ ] of size n by 1 ; Function to left rotate arr [ ] of size n by d ; utility function to print an array ; Driver program to test above functions","code":"#include <stdio.h> NEW_LINE void leftRotatebyOne ( int arr [ ] , int n ) ; void leftRotatebyOne ( int arr [ ] , int n ) { int temp = arr [ 0 ] , i ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } void leftRotate ( int arr [ ] , int d , int n ) { int i ; for ( i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; leftRotate ( arr , 2 , 7 ) ; printArray ( arr , 7 ) ; return 0 ; }"}
{"text":"Find the smallest missing number | C program to find the smallest elements missing in a sorted array . ; function that returns smallest elements missing in a sorted array . ; Left half has all elements from 0 to mid ; driver program to test above function","code":"#include <stdio.h> NEW_LINE int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) \/ 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } int main ( ) { int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printf ( \" Smallest \u2581 missing \u2581 element \u2581 is \u2581 % d \" , findFirstMissing ( arr , 0 , n - 1 ) ) ; return 0 ; }"}
{"text":"Maximum sum such that no two elements are adjacent |  ; Function to return max sum such that no two elements are adjacent ; current max excluding i ; current max including i ; return max of incl and excl ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE int FindMaxSum ( int arr [ ] , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } int main ( ) { int arr [ ] = { 5 , 5 , 10 , 100 , 10 , 5 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printf ( \" % d \u2581 n \" , FindMaxSum ( arr , n ) ) ; return 0 ; }"}
{"text":"Check for Majority Element in a sorted array | C Program to check for majority element in a sorted array ; get last index according to n ( even or odd ) ; search for first occurrence of x in arr [ ] ; check if x is present and is present more than n \/ 2 times ; Driver program to check above function","code":"# include <stdio.h> NEW_LINE # include <stdbool.h> NEW_LINE bool isMajority ( int arr [ ] , int n , int x ) { int i ; int last_index = n % 2 ? ( n \/ 2 + 1 ) : ( n \/ 2 ) ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n \/ 2 ] == x ) return 1 ; } return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; int x = 4 ; if ( isMajority ( arr , n , x ) ) printf ( \" % d \u2581 appears \u2581 more \u2581 than \u2581 % d \u2581 times \u2581 in \u2581 arr [ ] \" , x , n \/ 2 ) ; else printf ( \" % d \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 than \u2581 % d \u2581 times \u2581 in \u2581 arr [ ] \" , x , n \/ 2 ) ; return 0 ; }"}
{"text":"Check for Majority Element in a sorted array | C Program to check for majority element in a sorted array ; If x is present in arr [ low ... high ] then returns the index of first occurrence of x , otherwise returns - 1 ; Check if arr [ mid ] is the first occurrence of x . arr [ mid ] is first occurrence if x is one of the following is true : ( i ) mid == 0 and arr [ mid ] = = x ( ii ) arr [ mid - 1 ] < x and arr [ mid ] == x ; This function returns true if the x is present more than n \/ 2 times in arr [ ] of size n ; Find the index of first occurrence of x in arr [ ] ; If element is not present at all , return false ; check if the element is present more than n \/ 2 times ; Driver program to check above functions","code":"# include <stdio.h> NEW_LINE # include <stdbool.h> NEW_LINE int _binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) \/ 2 ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return -1 ; } bool isMajority ( int arr [ ] , int n , int x ) { int i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == -1 ) return false ; if ( ( ( i + n \/ 2 ) <= ( n - 1 ) ) && arr [ i + n \/ 2 ] == x ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; int x = 3 ; if ( isMajority ( arr , n , x ) ) printf ( \" % d \u2581 appears \u2581 more \u2581 than \u2581 % d \u2581 times \u2581 in \u2581 arr [ ] \" , x , n \/ 2 ) ; else printf ( \" % d \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 than \u2581 % d \u2581 times \u2581 in \u2581 arr [ ] \" , x , n \/ 2 ) ; return 0 ; }"}
{"text":"Check for Majority Element in a sorted array |  ;","code":"#include <stdio.h> NEW_LINE #include <stdbool.h> NEW_LINE bool isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n \/ 2 ] == key ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) printf ( \" % d \u2581 appears \u2581 more \u2581 than \u2581 % d \u2581 times \u2581 in \u2581 arr [ ] \" , x , n \/ 2 ) ; else printf ( \" % d \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 than \u2581 % d \u2581 times \u2581 in \u2581 \" \" arr [ ] \" , x , n \/ 2 ) ; return 0 ; }"}
{"text":"Cutting a Rod | DP | A Dynamic Programming solution for Rod cutting problem ; A utility function to get the maximum of two integers ; Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces ; Build the table val [ ] in bottom up manner and return the last entry from the table ; Driver program to test above functions","code":"#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int cutRod ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_val = INT_MIN ; for ( j = 0 ; j < i ; j ++ ) max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printf ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \u2581 % d \" , cutRod ( arr , size ) ) ; getchar ( ) ; return 0 ; }"}
{"text":"Cutting a Rod | DP | C program for above approach ; Global Array for the purpose of memoization . ; A recursive program , using , memoization , to implement the rod cutting problem ( Top - Down ) . ; The maximum price will be zero , when either the length of the rod is zero or price is zero . ; If the length of the rod is less than the maximum length , Max_lene will consider it . Now depending upon the profit , either Max_lene we will take it or discard it . ; If the length of the rod is greater than the permitted size , Max_len we will not consider it . ; Max_lene Max_lenill return the maximum value obtained , Max_lenhich is present at the nth roMax_len and Max_lenth column . ; Driver program to test above functions ; Function Call","code":"#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int t [ 9 ] [ 9 ] ; int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } int main ( ) { int price [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int n = sizeof ( price ) \/ sizeof ( price [ 0 ] ) ; int length [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } int Max_len = n ; printf ( \" Maximum \u2581 obtained \u2581 value \u2581 is \u2581 % d \u2581 STRNEWLINE \" , un_kp ( price , length , n , Max_len ) ) ; }"}
{"text":"Program to Convert Radian to Degree | C code to convert radian to degree ; Function for convertion ; Driver Code","code":"#include <stdio.h> NEW_LINE double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 \/ pi ) ) ; } int main ( ) { double radian = 5.0 ; double degree = Convert ( radian ) ; printf ( \" % .5lf \" , degree ) ; return 0 ; }"}
{"text":"Subtract two numbers without using arithmetic operators | C program to Subtract two numbers without using arithmetic operators ; Iterate till there is no carry ; borrow contains common set bits of y and unset bits of x ; Subtraction of bits of x and y where at least one of the bits is not set ; Borrow is shifted by one so that subtracting it from x gives the required sum ; Driver Code","code":"#include <stdio.h> NEW_LINE int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; } int main ( ) { int x = 29 , y = 13 ; printf ( \" x \u2581 - \u2581 y \u2581 is \u2581 % d \" , subtract ( x , y ) ) ; return 0 ; }"}
{"text":"Subtract two numbers without using arithmetic operators |  ; Driver program","code":"#include <stdio.h> NEW_LINE int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; } int main ( ) { int x = 29 , y = 13 ; printf ( \" x \u2581 - \u2581 y \u2581 is \u2581 % d \" , subtract ( x , y ) ) ; return 0 ; }"}
{"text":"Print reverse of a string using recursion | C program to reverse a string using recursion ; Function to print reverse of the passed string ; Driver program to test above function","code":"# include <stdio.h> NEW_LINE void reverse ( char * str ) { if ( * str ) { reverse ( str + 1 ) ; printf ( \" % c \" , * str ) ; } } int main ( ) { char a [ ] = \" Geeks \u2581 for \u2581 Geeks \" ; reverse ( a ) ; return 0 ; }"}
{"text":"Kronecker Product of two matrices | C code to find the Kronecker Product of two matrices and stores it as matrix C ; rowa and cola are no of rows and columns of matrix A rowb and colb are no of rows and columns of matrix B ; Function to computes the Kronecker Product of two matrices ; i loops till rowa ; k loops till rowb ; j loops till cola ; l loops till colb ; Each element of matrix A is multiplied by whole Matrix B resp and stored as Matrix C ; Driver Code","code":"#include <stdio.h> NEW_LINE const int cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ; void Kroneckerproduct ( int A [ ] [ cola ] , int B [ ] [ colb ] ) { int C [ rowa * rowb ] [ cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; printf ( \" % d TABSYMBOL \" , C [ i + l + 1 ] [ j + k + 1 ] ) ; } } printf ( \" STRNEWLINE \" ) ; } } } int main ( ) { int A [ 3 ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } , B [ 2 ] [ 3 ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; Kroneckerproduct ( A , B ) ; return 0 ; }"}
{"text":"Selection Sort | C program for implementation of selection sort ; swap function ; sort function ; One by one move boundary of unsorted subarray ; Find the minimum element in unsorted array ; Swap the found minimum element with the first element ; Function to print an array ; Driver program to test above functions","code":"#include <stdio.h> NEW_LINE void swap ( int * xp , int * yp ) { int temp = * xp ; * xp = * yp ; * yp = temp ; } void selectionSort ( int arr [ ] , int n ) { int i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; swap ( & arr [ min_idx ] , & arr [ i ] ) ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; selectionSort ( arr , n ) ; printf ( \" Sorted \u2581 array : \u2581 STRNEWLINE \" ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text":"Matrix Chain Multiplication | DP | See the Cormen book for details of the following algorithm ; Matrix Ai has dimension p [ i - 1 ] x p [ i ] for i = 1. . n ; For simplicity of the program , one extra row and one extra column are allocated in m [ ] [ ] . 0 th row and 0 th column of m [ ] [ ] are not used ; cost is zero when multiplying one matrix . ; L is chain length . ; q = cost \/ scalar multiplications ; Driver code","code":"#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int size = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printf ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 % d \u2581 \" , MatrixChainOrder ( arr , size ) ) ; getchar ( ) ; return 0 ; }"}
{"text":"Cutting a Rod | DP | C program for above approach ; Global Array for the purpose of memoization . ; A recursive program , using , memoization , to implement the rod cutting problem ( Top - Down ) . ; The maximum price will be zero , when either the length of the rod is zero or price is zero . ; If the length of the rod is less than the maximum length , Max_lene will consider it . Now depending upon the profit , either Max_lene we will take it or discard it . ; If the length of the rod is greater than the permitted size , Max_len we will not consider it . ; Max_lene Max_lenill return the maximum value obtained , Max_lenhich is present at the nth roMax_len and Max_lenth column . ; Driver program to test above functions ; Function Call","code":"#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int t [ 9 ] [ 9 ] ; int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } int main ( ) { int price [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int n = sizeof ( price ) \/ sizeof ( price [ 0 ] ) ; int length [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } int Max_len = n ; printf ( \" Maximum \u2581 obtained \u2581 value \u2581 is \u2581 % d \u2581 STRNEWLINE \" , un_kp ( price , length , n , Max_len ) ) ; }"}
{"text":"Multiply two integers without using multiplication , division and bitwise operators , and no loops |  ; function to multiply two numbers x and y ; 0 multiplied with anything gives 0 ; Add x one by one ; the case where y is negative ; Driver Code","code":"#include <stdio.h> NEW_LINE int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; } int main ( ) { printf ( \" % d \" , multiply ( 5 , -11 ) ) ; getchar ( ) ; return 0 ; }"}
{"text":"Pascal 's Triangle | A O ( n ^ 2 ) time and O ( n ^ 2 ) extra space method for Pascal 's Triangle ; An auxiliary array to store generated pscal triangle values ; Iterate through every line and print integer ( s ) in it ; Every line has number of integers equal to line number ; First and last values in every row are 1 ; Other values are sum of values just above and left of above ; Driver code","code":"void printPascal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; printf ( \" % d \u2581 \" , arr [ line ] [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }"}
{"text":"Pascal 's Triangle | C program for Pascals Triangle A O ( n ^ 2 ) time and O ( 1 ) extra space function for Pascal 's Triangle ; used to represent C ( line , i ) ; The first value in a line is always 1 ; Driver code","code":"void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { printf ( \" % d \u2581 \" , C ) ; C = C * ( line - i ) \/ i ; } printf ( \" STRNEWLINE \" ) ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }"}
{"text":"Add two numbers without using arithmetic operators | C Program to add two numbers without using arithmetic operator ; Iterate till there is no carry ; carry now contains common set bits of x and y ; Sum of bits of x and y where at least one of the bits is not set ; Carry is shifted by one so that adding it to x gives the required sum ; Driver Code","code":"#include <stdio.h> NEW_LINE int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } int main ( ) { printf ( \" % d \" , Add ( 15 , 32 ) ) ; return 0 ; }"}
{"text":"Add two numbers without using arithmetic operators |","code":"int Add ( int x , int y ) { if ( y == 0 ) return x ; else return Add ( x ^ y , ( x & y ) << 1 ) ; }"}
{"text":"Count set bits in an integer | C program to Count set bits in an integer ; Function to get no of set bits in binary representation of positive integer n ; Program to test function countSetBits","code":"#include <stdio.h> NEW_LINE unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } int main ( ) { int i = 9 ; printf ( \" % d \" , countSetBits ( i ) ) ; return 0 ; }"}
{"text":"Count set bits in an integer | C program to count set bits by pre - storing count set bits in nibbles . ; Recursively get nibble of a given number and map them in the array ; Find last nibble ; Use pre - stored values to find count in last nibble plus recursively add remaining nibbles . ; Driver code","code":"#include <stdio.h> NEW_LINE int num_to_bits [ 16 ] = { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ; unsigned int countSetBitsRec ( unsigned int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; } int main ( ) { int num = 31 ; printf ( \" % d STRNEWLINE \" , countSetBitsRec ( num ) ) ; }"}
{"text":"Count set bits in an integer |  ; Check each bit in a number is set or not and return the total count of the set bits . ; ( 1 << i ) = pow ( 2 , i ) ; Driver Code","code":"#include <stdio.h> NEW_LINE int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < sizeof ( int ) * 8 ; i ++ ) { if ( N & ( 1 << i ) ) count ++ ; } return count ; } int main ( ) { int N = 15 ; printf ( \" % d \" , countSetBits ( N ) ) ; return 0 ; }"}
{"text":"Program to find parity | C program to find parity of an integer ; Function to get parity of number n . It returns 1 if n has odd parity , and returns 0 if n has even parity ; Driver program to test getParity ( )","code":"# include <stdio.h> NEW_LINE # define bool  int NEW_LINE bool getParity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } int main ( ) { unsigned int n = 7 ; printf ( \" Parity \u2581 of \u2581 no \u2581 % d \u2581 = \u2581 % s \" , n , ( getParity ( n ) ? \" odd \" : \" even \" ) ) ; getchar ( ) ; return 0 ; }"}
{"text":"Program to find whether a no is power of two | C Program to find whether a no is power of two ; Function to check if x is power of 2 ; Driver program","code":"#include <stdio.h> NEW_LINE #include <stdbool.h> NEW_LINE #include <math.h> NEW_LINE bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; isPowerOfTwo ( 64 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; return 0 ; }"}
{"text":"Program to find whether a no is power of two |  ; Function to check if x is power of 2 ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE #include <stdbool.h> NEW_LINE bool isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n \/ 2 ; } return 1 ; } int main ( ) { isPowerOfTwo ( 31 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; isPowerOfTwo ( 64 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; return 0 ; }"}
{"text":"Program to find whether a no is power of two |  ; Function to check if x is power of 2 ; First x in the below expression is for the case when x is 0 ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; isPowerOfTwo ( 64 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; return 0 ; }"}
{"text":"Find the two numbers with odd occurrences in an unsorted array | Program to find the two odd occurring elements ; Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times . ; Will hold XOR of two odd occurring elements ; Will have only single set bit of xor2 ; Get the xor of all elements in arr [ ] . The xor will basically be xor of two odd occurring elements ; Get one set bit in the xor2 . We get rightmost set bit in the following line as it is easy to get ; Now divide elements in two sets : 1 ) The elements having the corresponding bit as 1. 2 ) The elements having the corresponding bit as 0. ; XOR of first set is finally going to hold one odd occurring number x ; XOR of second set is finally going to hold the other odd occurring number y ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } printf ( \" The two ODD elements are % d & % d \" , x , y ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printTwoOdd ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text":"Find a pair with the given difference | C program to find a pair with the given difference ; The function assumes that the array is sorted ; Initialize positions of two elements ; Search for a pair ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE bool findPair ( int arr [ ] , int size , int n ) { int i = 0 ; int j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { printf ( \" Pair \u2581 Found : \u2581 ( % d , \u2581 % d ) \" , arr [ i ] , arr [ j ] ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } printf ( \" No \u2581 such \u2581 pair \" ) ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int size = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; int n = 60 ; findPair ( arr , size , n ) ; return 0 ; }"}
{"text":"Matrix Chain Multiplication | DP | A naive recursive implementation that simply follows the above optimal substructure property ; Matrix Ai has dimension p [ i - 1 ] x p [ i ] for i = 1. . n ; place parenthesis at different places between first and last matrix , recursively calculate count of multiplications for each parenthesis placement and return the minimum count ; Return minimum count ; Driver code","code":"#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = INT_MAX ; int count ; for ( k = i ; k < j ; k ++ ) { count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 3 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printf ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 % d \u2581 \" , MatrixChainOrder ( arr , 1 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text":"Program to find the Perimeter of a Regular Polygon | C program to find the perimeter of a regular polygon ; Function to calculate the perimeter ; Calculate Perimeter ; driver code ; Get the number of sides ; Get the length of side ; find perimeter","code":"#include <stdio.h> NEW_LINE float Perimeter ( float s , int n ) { float perimeter = 1 ; perimeter = n * s ; return perimeter ; } int main ( ) { int n = 5 ; float s = 2.5 , peri ; peri = Perimeter ( s , n ) ; printf ( \" Perimeter \u2581 of \u2581 Regular \u2581 Polygon STRNEWLINE \" \" \u2581 with \u2581 % d \u2581 sides \u2581 of \u2581 length \u2581 % f \u2581 = \u2581 % f STRNEWLINE \" , n , s , peri ) ; return 0 ; }"}
{"text":"Distance between a point and a Plane in 3 D | C program to find the Perpendicular ( shortest ) distance between a point and a Plane in 3 D . ; Function to find distance ; Driver Code ; Function call","code":"#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = fabs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = sqrt ( a * a + b * b + c * c ) ; printf ( \" Perpendicular \u2581 distance \u2581 is \u2581 % f \" , d \/ e ) ; return ; } int main ( ) { float x1 = 4 ; float y1 = -4 ; float z1 = 3 ; float a = 2 ; float b = -2 ; float c = 5 ; float d = 8 ; shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ; }"}
{"text":"Average of odd numbers till a given odd number | Program to find average of odd numbers till a given odd number . ; Function to calculate the average of odd numbers ; driver function","code":"#include <stdio.h> NEW_LINE int averageOdd ( int n ) { if ( n % 2 == 0 ) { printf ( \" Invalid \u2581 Input \" ) ; return -1 ; } return ( n + 1 ) \/ 2 ; } int main ( ) { int n = 15 ; printf ( \" % d \" , averageOdd ( n ) ) ; return 0 ; }"}
{"text":"Trinomial Triangle | CPP Program to print trinomial triangle . ; Function to find the trinomial triangle value . ; Using property of trinomial triangle . ; If value already calculated , return that . ; base case ; base case ; recursive step and storing the value . ; Function to print Trinomial Triangle of height n . ; printing n rows . ; printing first half of triangle ; printing second half of triangle . ; Driven Program","code":"#include <bits\/stdc++.h> NEW_LINE #define MAX  10 NEW_LINE using namespace std ; int TrinomialValue ( int dp [ MAX ] [ MAX ] , int n , int k ) { if ( k < 0 ) k = - k ; if ( dp [ n ] [ k ] != 0 ) return dp [ n ] [ k ] ; if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return ( dp [ n ] [ k ] = TrinomialValue ( dp , n - 1 , k - 1 ) + TrinomialValue ( dp , n - 1 , k ) + TrinomialValue ( dp , n - 1 , k + 1 ) ) ; } void printTrinomial ( int n ) { int dp [ MAX ] [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = - i ; j <= 0 ; j ++ ) cout << TrinomialValue ( dp , i , j ) << \" \u2581 \" ; for ( int j = 1 ; j <= i ; j ++ ) cout << TrinomialValue ( dp , i , j ) << \" \u2581 \" ; cout << endl ; } } int main ( ) { int n = 4 ; printTrinomial ( n ) ; return 0 ; }"}
{"text":"Given a HUGE number check if it 's a power of two. | C program to find whether a number is power of 2 or not ; returns 1 when str is power of 2 return 0 when str is not a power of 2 ; sum stores the intermediate dividend while dividing . ; if the input is \"1\" then return 0 because 2 ^ k = 1 where k >= 1 and here k = 0 ; Divide the number until it gets reduced to 1 if we are successfully able to reduce the number to 1 it means input string is power of two if in between an odd number appears at the end it means string is not divisible by two hence not a power of 2. ; if the last digit is odd then string is not divisible by 2 hence not a power of two return 0. ; divide the whole string by 2. i is used to track index in current number . j is used to track index for next iteration . ; if num < 2 then we have to take another digit to the right of A [ i ] to make it bigger than A [ i ] . E . g . 214 \/ 2 -- > 107 ; if it 's not the first index. E.g 214  then we have to include 0. ; for eg . \"124\" we will not write 064 so if it is the first index just ignore ; After every division by 2 the length of string is changed . ; if the string reaches to 1 then the str is a power of 2. ; Driver code .","code":"#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int isPowerOf2 ( char * str ) { int len_str = strlen ( str ) ; int num = 0 ; if ( len_str == 1 && str [ len_str - 1 ] == '1' ) return 0 ; while ( len_str != 1 str [ len_str - 1 ] != '1' ) { if ( ( str [ len_str - 1 ] - '0' ) % 2 == 1 ) return 0 ; for ( int i = 0 , j = 0 ; i < len_str ; i ++ ) { num = num * 10 + str [ i ] - '0' ; if ( num < 2 ) { if ( i != 0 ) str [ j ++ ] = '0' ; continue ; } str [ j ++ ] = ( int ) ( num \/ 2 ) + '0' ; num = ( num ) - ( num \/ 2 ) * 2 ; } str [ j ] = ' \\0' ; len_str = j ; } return 1 ; } int main ( ) { char str1 [ ] = \"12468462246684202468024\" \"6842024662202000002\" ; char str2 [ ] = \"1\" ; char str3 [ ] = \"128\" ; printf ( \" % d % d % d \" , isPowerOf2 ( str1 ) , isPowerOf2 ( str2 ) , isPowerOf2 ( str3 ) ) ; return 0 ; }"}
{"text":"Average of even numbers till a given even number | Program to find average of even numbers till a given even number . ; Function to calculate the average of even numbers ; driver function","code":"#include <stdio.h> NEW_LINE int averageEven ( int n ) { if ( n % 2 != 0 ) { printf ( \" Invalid \u2581 Input \" ) ; return -1 ; } return ( n + 2 ) \/ 2 ; } int main ( ) { int n = 16 ; printf ( \" % d \" , averageEven ( n ) ) ; return 0 ; }"}
{"text":"Sum of divisors of factorial of a number | C program to find sum of proper divisor of factorial of a number ; function to calculate factorial ; function to calculate sum of divisor ; Returns sum of divisors of n ! ; driver program","code":"#include <stdio.h> NEW_LINE int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; } int sumFactDiv ( int n ) { return div ( fact ( n ) ) ; } int main ( ) { int n = 4 ; printf ( \" % d \" , sumFactDiv ( n ) ) ; }"}
{"text":"Find all divisors of a natural number | Set 2 | A O ( sqrt ( n ) ) program that prints all divisors in sorted order ; function to print the divisors ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void printDivisors ( int n ) { int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) printf ( \" % d \u2581 \" , i ) ; } if ( i - ( n \/ i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) printf ( \" % d \u2581 \" , n \/ i ) ; } } int main ( ) { printf ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 STRNEWLINE \" ) ; printDivisors ( 100 ) ; return 0 ; }"}
{"text":"Find all factors of a natural number | Set 1 | C implementation of Naive method to print all divisors ; function to print the divisors ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) printf ( \" % d \u2581 \" , i ) ; } int main ( ) { printf ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 STRNEWLINE \" ) ; printDivisors ( 100 ) ; return 0 ; }"}
{"text":"Find all factors of a natural number | Set 1 | A Better ( than Naive ) Solution to find all divisiors ; Function to print the divisors ; Note that this loop runs till square root ; If divisors are equal , print only one ; else Otherwise print both ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void printDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n \/ i == i ) printf ( \" % d \u2581 \" , i ) ; printf ( \" % d \u2581 % d \u2581 \" , i , n \/ i ) ; } } } int main ( ) { printf ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 STRNEWLINE \" ) ; printDivisors ( 100 ) ; return 0 ; }"}
{"text":"Write a program to reverse digits of a number | C program to reverse digits of a number ; Recursive function to reverse digits of num ; Driver program to test reversDigits","code":"#include <stdio.h> ; int reversDigits ( int num ) { static int rev_num = 0 ; static int base_pos = 1 ; if ( num > 0 ) { reversDigits ( num \/ 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; } int main ( ) { int num = 4562 ; printf ( \" Reverse \u2581 of \u2581 no . \u2581 is \u2581 % d \" , reversDigits ( num ) ) ; getchar ( ) ; return 0 ; }"}
{"text":"Calculate 7 n \/ 8 without using division and multiplication operators | C program to evaluate ceil ( 7 n \/ 8 ) without using * and \/ ; Note the inner bracket here . This is needed because precedence of ' - ' operator is higher than ' < < ' ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE int multiplyBySevenByEight ( unsigned int n ) { return ( n - ( n >> 3 ) ) ; } int main ( ) { unsigned int n = 9 ; printf ( \" % d \" , multiplyBySevenByEight ( n ) ) ; return 0 ; }"}
{"text":"Calculate 7 n \/ 8 without using division and multiplication operators | C program to evaluate 7 n \/ 8 without using * and \/ ; Step 1 ) First multiply number by 7 i . e . 7 n = ( n << 3 ) - n * Step 2 ) Divide result by 8 ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE int multiplyBySevenByEight ( unsigned int n ) { return ( ( n << 3 ) - n ) >> 3 ; } int main ( ) { unsigned int n = 15 ; printf ( \" % u \" , multiplyBySevenByEight ( n ) ) ; return 0 ; }"}
{"text":"Binary Insertion Sort | iterative implementation ; Function to sort an array a [ ] of size ' n ' ; find location where selected should be inseretd ; Move all elements after location to create space ; Driver Code","code":"#include <stdio.h> NEW_LINE int binarySearch ( int a [ ] , int item , int low , int high ) { while ( low <= high ) { int mid = low + ( high - low ) \/ 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; } void insertionSort ( int a [ ] , int n ) { int i , loc , j , k , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ; loc = binarySearch ( a , selected , 0 , j ) ; while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } } int main ( ) { int a [ ] = { 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 } ; int n = sizeof ( a ) \/ sizeof ( a [ 0 ] ) , i ; insertionSort ( a , n ) ; printf ( \" Sorted \u2581 array : \u2581 STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , a [ i ] ) ; return 0 ; }"}
{"text":"Insertion Sort | C program for insertion sort ; Function to sort an array using insertion sort ; Move elements of arr [ 0. . i - 1 ] , that are greater than key , to one position ahead of their current position ; A utility function to print an array of size n ; Driver program to test insertion sort","code":"#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int n = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; insertionSort ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text":"Coin Change | DP | Recursive C program for coin change problem . ; Returns the count of ways we can sum S [ 0. . . m - 1 ] coins to get sum n ; If n is 0 then there is 1 solution ( do not include any coin ) ; If n is less than 0 then no solution exists ; If there are no coins and n is greater than 0 , then no solution exist ; count is sum of solutions ( i ) including S [ m - 1 ] ( ii ) excluding S [ m - 1 ] ; Driver program to test above function","code":"#include <stdio.h> NEW_LINE int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } int main ( ) { int i , j ; int arr [ ] = { 1 , 2 , 3 } ; int m = sizeof ( arr ) \/ sizeof ( arr [ 0 ] ) ; printf ( \" % d \u2581 \" , count ( arr , m , 4 ) ) ; getchar ( ) ; return 0 ; }"}
{"text":"Program to find area of a Trapezoid | CPP program to calculate area of a trapezoid ; Function for the area ; Driver Code","code":"#include <stdio.h> NEW_LINE double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) \/ 2 ) * h ; } int main ( ) { int base1 = 8 , base2 = 10 , height = 6 ; double area = Area ( base1 , base2 , height ) ; printf ( \" Area \u2581 is : \u2581 % .1lf \" , area ) ; return 0 ; }"}
