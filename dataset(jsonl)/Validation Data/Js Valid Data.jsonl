{"text": "Program untuk menukar sentimeter ke piksel | Berfungsi untuk menukar sentimeter ke piksel; Kod pemacu", "code": "function Conversion ( centi ) { let pixels = ( 96 * centi ) / 2.54 ; document . write ( pixels ) ; return 0 ; } let centi = 15 ; Conversion ( centi )"}
{"text": "Elemen Arus KTH selepas penggantian elemen array oleh xor pasangan bersebelahan | Kaedah yang mengembalikan output yang sepadan dengan mengambil input yang diberikan. ; Jika keadaan ini berpuas hati, nilai m tidak sah; Semak sama ada indeks k adalah sah; Gelung untuk melaksanakan operasi M; Mewujudkan senarai sementara; Melintasi array; Mengira nilai XOR unsur -unsur bersebelahan; Menambah nilai ini ke senarai sementara; Kemas kini array asal; Mendapatkan nilai pada indeks k; Bilangan elemen; Diberikan array arr []; Panggilan fungsi", "code": "function xor_operations ( N , arr , M , K ) { if ( M < 0 M >= N ) return - 1 ; if ( K < 0 K >= N - M ) return - 1 ; for ( let p = 0 ; p < M ; p ++ ) { let temp = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { let value = arr [ i ] ^ arr [ i + 1 ] ; temp . push ( value ) ; arr [ i ] = temp [ i ] ; } } let ans = arr [ K ] ; return ans ; } let N = 5 ; let arr = [ 1 , 4 , 5 , 6 , 7 ] ; let M = 1 , K = 2 ; document . write ( xor_operations ( N , arr , M , K ) ) ;"}
{"text": "Semak jika n boleh dibahagikan kepada elemen K berturut -turut dengan jumlah yang sama dengan N | Fungsi untuk mencari unsur -unsur berturut -turut dengan jumlah yang sama dengan n; Melangkah ke atas [2, inf]; Simpan jumlahnya; Jika jumlah melebihi n maka pecahkan gelung; Perbezaan umum harus dibahagikan dengan bilangan istilah; Cetak nilai i & kembali; Cetak \" - 1\" jika tidak mungkin untuk memecahkan n; Diberikan n; Panggilan fungsi", "code": "function canBreakN ( n ) { for ( let i = 2 ; ; i ++ ) { let m = parseInt ( i * ( i + 1 ) / 2 , 10 ) ; if ( m > n ) break ; let k = n - m ; if ( k % i != 0 ) continue ; document . write ( i ) ; return ; } document . write ( \" \" ) ; } let N = 12 ; canBreakN ( N ) ;"}
{"text": "Pembahagi Coprime nombor | Fungsi yang mendapati sepasang pembahagi n yang diperlukan; Kami melangkah sehingga sqrt (n) kerana kita dapat mencari semua pembahagi n pada masa ini; Jika x adalah pembahagi n terus membahagikan selagi mungkin; Kami telah menemui pasangan yang diperlukan; Tidak ada sepasang pembahagi n yang dijumpai, oleh itu cetak - 1; Contoh Contoh 1; Contoh Contoh 2", "code": "function findCoprimePair ( N ) { for ( let x = 2 ; x <= Math . sqrt ( N ) ; x ++ ) { if ( N % x == 0 ) { while ( N % x == 0 ) { N = Math . floor ( N / x ) ; } if ( N > 1 ) { document . write ( x + \" \" + N + \" \" ) ; return ; } } } document . write ( - 1 + \" \" ) ; } let N = 45 ; findCoprimePair ( N ) ; N = 25 ; findCoprimePair ( N ) ;"}
{"text": "Nombor Sisa | Pelaksanaan JavaScript untuk pendekatan di atas; Array untuk menyimpan semua perdana kurang daripada dan sama dengan max. ; Fungsi untuk penapis Sundaram; Array Boolean; Tandakan semua nombor yang tidak menjana nombor perdana dengan 2 * i + 1; Oleh kerana 2 adalah nombor perdana; Cetak prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Fungsi yang pulih benar jika n adalah nombor yang membazir; Mengira digit dalam nombor asal; Kira semua digit dalam faktor utama N pdigit akan memegang nilai ini. ; Mengira kuasa p dalam n; Jika prima [i] adalah faktor utama ,; Mengira kuasa faktor utama; Tambah digitnya ke PDIGIT; Tambah digit kuasa faktor utama kepada pdigit. ; Jika n! = 1 maka satu faktor utama masih akan disimpulkan; Jika digit dalam faktor utama lebih daripada digit dalam nombor asal maka kembali benar. Lain kembali palsu. ; Berfungsi untuk mencetak nombor yang membazir sebelum n; Melepasi sehingga n dan periksa sama ada saya membazir atau tidak; Nombor Perdana Precompute sehingga 10 ^ 6; Panggilan fungsi", "code": "let MAX = 10000 ; let primes = [ ] ; function sieveSundaram ( ) { let marked = Array . from ( { length : MAX / 2 + 1 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i <= Math . floor ( ( Math . sqrt ( MAX ) - 1 ) / 2 ) ; i ++ ) { for ( let j = ( i * ( i + 1 ) ) << 1 ; j <= Math . floor ( MAX / 2 ) ; j = j + 2 * i + 1 ) { marked [ j ] = true ; } } primes . push ( 2 ) ; for ( let i = 1 ; i <= Math . floor ( MAX / 2 ) ; i ++ ) if ( marked [ i ] == false ) primes . push ( 2 * i + 1 ) ; } function isWasteful ( n ) { if ( n == 1 ) return false ; let original_no = n ; let sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = Math . floor ( original_no / 10 ) ; } let pDigit = 0 , count_exp = 0 , p = 0 ; for ( let i = 0 ; primes [ i ] <= Math . floor ( n / 2 ) ; i ++ ) { while ( n % primes [ i ] == 0 ) { p = primes [ i ] ; n = Math . floor ( n / p ) ; count_exp ++ ; } while ( p > 0 ) { pDigit ++ ; p = Math . floor ( p / 10 ) ; } while ( count_exp > 1 ) { pDigit ++ ; count_exp = Math . floor ( count_exp / 10 ) ; } } if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = Math . floor ( n / 10 ) ; } } return ( pDigit > sumDigits ) ; } function Solve ( N ) { for ( let i = 1 ; i < N ; i ++ ) { if ( isWasteful ( i ) ) { document . write ( i + \" \" ) ; } } } sieveSundaram ( ) ; let N = 10 ; Solve ( N ) ;"}
{"text": "Nombor Hexanacci | Berfungsi untuk mencetak nombor hexanacci nth; Kod pemacu", "code": "function printhexaRec ( n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 n == 5 ) return 0 ; else if ( n == 6 ) return 1 ; else return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) ; } function printhexa ( n ) { document . write ( printhexaRec ( n ) + \" \" ) ; } let n = 11 ; printhexa ( n ) ;"}
{"text": "Nombor Hexanacci | Berfungsi untuk mencetak istilah n nombor hexanacci; Memulakan lima nombor pertama untuk kes asas; Mengisytiharkan pemboleh ubah semasa; Gelung untuk menambah lima nombor sebelumnya untuk setiap nombor bermula dari 5 dan kemudian berikan pertama, kedua, kedua, keempat kelima hingga kedua, ketiga, keempat, kelima dan curr masing -masing; Kod pemacu", "code": "function printhexa ( n ) { if ( n < 0 ) return ; let first = 0 ; let second = 0 ; let third = 0 ; let fourth = 0 ; let fifth = 0 ; let sixth = 1 ; let curr = 0 ; if ( n < 6 ) document . write ( first ) ; else if ( n == 6 ) document . write ( sixth ) ; else { for ( let i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } document . write ( curr ) ; } let n = 11 ; printhexa ( n ) ;"}
{"text": "Cari nombor terkecil yang jumlah digitnya adalah n | Berfungsi untuk mencari nombor terkecil yang jumlah digit juga n; Kod pemacu", "code": "function smallestNumber ( N ) { document . write ( ( N % 9 + 1 ) * Math . pow ( 10 , parseInt ( N / 9 , 10 ) ) - 1 ) ; } let N = 10 ; smallestNumber ( N ) ;"}
{"text": "Kompositori Nombor | Program JavaScript untuk mencari kompositori nombor komposit; Fungsi untuk memeriksa sama ada nombor adalah komposit. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor tengah dalam gelung di bawah; Fungsi ini menyimpan semua nombor komposit kurang daripada n; Fungsi untuk mengira kompositori n; Multiply nombor komposit pertama N; Kod pemacu; Vektor untuk menyimpan semua komposit kurang daripada n", "code": "let compo = [ ] ; function isComposite ( n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; let i = 5 ; while ( i * i <= n ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; i = i + 6 ; } return false ; } function Compositorial_list ( n ) { let l = 0 ; for ( let i = 4 ; i < 1000000 ; i ++ ) { if ( l < n ) { if ( isComposite ( i ) ) { compo . push ( i ) ; l += 1 ; } } } } function calculateCompositorial ( n ) { let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) result = result * compo [ i ] ; return result ; } let n = 5 ; Compositorial_list ( n ) ; document . write ( calculateCompositorial ( n ) ) ;"}
{"text": "Kuasa yang berbeza dari nombor n supaya jumlahnya sama dengan k | Memulakan PowerArray dengan semua 0; Fungsi untuk mencari kuasa n yang menambah sehingga k; Memulakan kaunter; Melaksanakan gelung sementara sehingga k lebih besar daripada 0; Jika k % n == 1, maka array kuasa ditingkatkan dengan 1; Memeriksa jika ada kuasa yang berlaku lebih dari sekali; Untuk apa -apa nilai lain, jumlah kuasa tidak boleh ditambah sehingga k; Mencetak kuasa N yang merangkumi K; Kod pemacu", "code": "let b = new Array ( 50 ) ; b . fill ( 0 ) ; function PowerArray ( n , k ) { let count = 0 ; while ( k > 0 ) { if ( k % n == 0 ) { k = parseInt ( k / n , 10 ) ; count ++ ; } else if ( k % n == 1 ) { k -= 1 ; b [ count ] ++ ; if ( b [ count ] > 1 ) { document . write ( - 1 ) ; return 0 ; } } else { document . write ( - 1 ) ; return 0 ; } } for ( let i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] != 0 ) { document . write ( i + \" \" ) ; } } return Number . MIN_VALUE ; } let N = 3 ; let K = 40 ; PowerArray ( N , K ) ;"}
{"text": "Program untuk mencari nilai 1 ^ k + 2 ^ k + 3 ^ k + ... + n ^ k | Fungsi untuk mencari nilai 1 ^ K + 2 ^ K + 3 ^ K +. . + N ^ k; INISIISE SUM kepada 0; Cari nilai POW (i, 4) dan kemudian tambahkannya ke jumlah; Mengembalikan jumlahnya; Kod pemacu; Fungsi panggilan untuk mencari jumlah", "code": "function findSum ( N , k ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += Math . pow ( i , k ) ; } return sum ; } let N = 8 , k = 4 ; document . write ( findSum ( N , k ) ) ;"}
{"text": "Kira indeks dalam array yang memenuhi syarat yang diberikan | Berfungsi untuk mengembalikan kiraan indeks yang memenuhi syarat yang diberikan; Untuk menyimpan hasilnya; Untuk menyimpan maksimum semasa yang dimulakan ke 0 kerana hanya terdapat unsur -unsur positif dalam array; Saya adalah indeks yang sah; Mengemas kini maksimum setakat ini; Kenaikan kaunter; Kod pemacu", "code": "function countIndices ( arr , n ) { var cnt = 0 ; var max = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; } var arr = [ 1 , 2 , 3 , 4 ] ; var n = arr . length ; document . write ( countIndices ( arr , n ) ) ;"}
{"text": "Kekerapan maksimum modulo 2 i | Perwakilan binari digit; Berfungsi untuk mengembalikan kekerapan maksimum modulo S dengan kuasa 2; Simpan perwakilan binari; Tukar oktal ke binari; Keluarkan LSB; Sekiranya terdapat 1 dalam perwakilan binari; Cari bilangan sifar di antara dua 1 dalam perwakilan binari; Kod pemacu", "code": "bin = [ \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" ] ; function maxFreq ( s ) { var binary = \" \" ; for ( var i = 0 ; i < s . length ; i ++ ) { binary += bin [ s . charAt ( i ) - ' ' ] ; } binary = binary . substr ( 0 , binary . length - 1 ) ; var count = 1 , prev = - 1 , i , j = 0 ; for ( i = binary . length - 1 ; i >= 0 ; i -- , j ++ ) if ( binary . charAt ( i ) == ' ' ) { count = Math . max ( count , j - prev ) ; prev = j ; } return count ; } var octal = \" \" ; document . write ( maxFreq ( octal ) ) ;"}
{"text": "Cari semua nombor utama nombor digit yang diberikan | Pelaksanaan JavaScript pendekatan; Fungsi untuk penapis eratosthenes; Berfungsi untuk mencetak semua nombor utama dengan digit D; Julat untuk memeriksa bilangan bulat; Untuk setiap integer dalam julat; Jika integer semasa adalah perdana; Menjana prima", "code": "let sz = 100000 ; let isPrime = new Array ( sz + 1 ) ; isPrime . fill ( false ) ; function sieve ( ) { for ( let i = 0 ; i <= sz ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( let i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( let j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } } function findPrimesD ( d ) { let left = Math . pow ( 10 , d - 1 ) ; let right = Math . pow ( 10 , d ) - 1 ; for ( let i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { document . write ( i + \" \" ) ; } } } sieve ( ) ; let d = 1 ; findPrimesD ( d ) ;"}
{"text": "Cari bilangan sel dalam jadual mengandungi x | Fungsi untuk mencari bilangan sel dalam jadual mengandungi x; Kod pemacu; Panggilan fungsi", "code": "function Cells ( n , x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; var i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; } var n = 6 , x = 12 ; document . write ( Cells ( n , x ) ) ;"}
{"text": "Cari nilai maksimum nilai minimum array yang diubah suai | Berfungsi untuk mencari nilai maksimum nilai minimum array yang diubah suai; Untuk menyimpan nilai minimum array; Untuk menyimpan jumlah elemen array; Penyelesaian tidak mungkin; Zero adalah nilai yang mungkin; nilai minimum yang mungkin; nilai maksimum yang mungkin; untuk menyimpan jawapan yang diperlukan; Carian binari; Sekiranya pertengahan mungkin maka cuba tambah jawapan yang diperlukan; Jika pertengahan tidak mungkin maka penurunan jawapan yang diperlukan; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "function maxOfMin ( a , n , S ) { let mi = Number . MAX_VALUE ; let s1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = Math . min ( a [ i ] , mi ) ; } if ( s1 < S ) return - 1 ; if ( s1 == S ) return 0 ; let low = 0 ; let high = mi ; let ans = 0 ; while ( low <= high ) { let mid = parseInt ( ( low + high ) / 2 , 10 ) ; if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } let a = [ 10 , 10 , 10 , 10 , 10 ] ; let S = 10 ; let n = a . length ; document . write ( maxOfMin ( a , n , S ) ) ;"}
{"text": "Program untuk mencetak 'n' abjad menggunakan corak nombor dari 1 hingga n | Berfungsi untuk mencetak corak abjad n yang dikehendaki; Mengisytiharkan nilai -nilai hak, kiri dan pepenjuru; Gelung utama untuk baris; Untuk nilai kiri; Ruang untuk pepenjuru; Keadaan untuk pepenjuru; Ruang untuk nilai yang betul; Untuk nilai yang betul; Saiz corak; Memanggil fungsi untuk mencetak corak yang dikehendaki", "code": "function Alphabet_N_Pattern ( N ) { var index , side_index , size ; var Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { document . write ( Left ++ ) ; for ( side_index = 0 ; side_index < 2 * index ; side_index ++ ) document . write ( \" \" ) ; if ( index != 0 && index != N - 1 ) document . write ( Diagonal ++ ) ; else document . write ( \" \" ) ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) document . write ( \" \" ) ; document . write ( Right ++ ) ; document . write ( \" \" ) ; } } var Size = 6 ; Alphabet_N_Pattern ( Size ) ;"}
{"text": "Semak jika jumlah digit nombor n membahagikannya | Berfungsi untuk memeriksa sama ada jumlah digit nombor membahagikannya; Hitung jumlah semua digit N; Kod pemacu", "code": "function isSumDivides ( N ) { var temp = N ; var sum = 0 ; while ( temp > 0 ) { sum += temp % 10 ; temp = parseInt ( temp / 10 ) ; } if ( N % sum == 0 ) return 1 ; else return 0 ; } var N = 12 ; if ( isSumDivides ( N ) == 1 ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Jumlah nombor dari 1 hingga N yang boleh dibahagikan dengan 3 atau 4 | Berfungsi untuk mengira jumlah nombor yang boleh dibahagi dengan 3 atau 4; Kod pemacu", "code": "function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; } var N = 20 ; document . write ( sum ( 12 ) ) ;"}
{"text": "Seterusnya nombor yang lebih besar daripada n dengan betul -betul sedikit berbeza dalam perwakilan binari n | Berfungsi untuk mencari nombor seterusnya yang lebih besar daripada n dengan tepat satu yang berbeza dalam perwakilan binari n; Ia dijamin bahawa terdapat sedikit sifar dalam nombor; Jika bit beralih adalah sifar maka pecah; meningkatkan peralihan sedikit; meningkatkan kuasa 2; Tetapkan bit paling rendah nombor; Kod pemacu; Paparkan nombor seterusnya", "code": "function nextGreater ( N ) { var power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; } var N = 11 ; document . write ( \" \" + nextGreater ( N ) ) ;"}
{"text": "Mengira bilangan cara untuk menutup jarak | Tetapkan 2 | Berfungsi untuk mengembalikan kiraan jumlah cara untuk menutup jarak dengan 1, 2 dan 3 langkah; Keadaan asas; Untuk menyimpan tiga peringkat terakhir; Cari bilangan langkah yang diperlukan untuk mencapai jarak i; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "function countWays ( n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; let f0 = 1 , f1 = 1 , f2 = 2 ; let ans = 0 ; for ( let i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; } let n = 4 ; document . write ( countWays ( n ) ) ;"}
{"text": "Memaksimumkan jumlah dengan memilih unsur -unsur dari bahagian yang berbeza dari matriks | Program JavaScript untuk pendekatan di atas; Berfungsi untuk mencari nilai maksimum; Jadual DP; Isi DP secara bawah; Maksimum tiga bahagian; Maksimum bahagian pertama; Maksimum bahagian kedua; Maksimum bahagian ketiga; Jika kita memilih elemen dari Bahagian 1, kita tidak boleh mempunyai pemilihan dari bahagian yang sama di baris bersebelahan; Cetak jumlah maksimum; Kod pemacu", "code": "const n = 6 , m = 6 ; function maxSum ( arr ) { const dp = new Array ( n + 1 ) . fill ( 0 ) . map ( ( ) => new Array ( 3 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var m1 = 0 , m2 = 0 , m3 = 0 ; for ( var j = 0 ; j < m ; j ++ ) { if ( parseInt ( j / ( m / 3 ) ) == 0 ) { m1 = Math . max ( m1 , arr [ i ] [ j ] ) ; } else if ( parseInt ( j / ( m / 3 ) ) == 1 ) { m2 = Math . max ( m2 , arr [ i ] [ j ] ) ; } else if ( parseInt ( j / ( m / 3 ) ) == 2 ) { m3 = Math . max ( m3 , arr [ i ] [ j ] ) ; } } dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; dp [ i + 1 ] [ 2 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; } document . write ( parseInt ( Math . max ( Math . max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) + \" \" ) ; } arr = [ [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] ] ; maxSum ( arr ) ;"}
{"text": "Jumlah Bilangan Panjang Panjang Panjang Panjang | Berfungsi untuk mencari jumlah sub - urutan panjang palindromik - urutan; Array DP untuk menyimpan bilangan seterusnya Palindromic untuk 0 hingga I - 1 dan J + 1 hingga N - 1; Kami akan bermula dengan jarak terbesar antara i dan j; Untuk setiap len, kami menetapkan saya; Untuk ini saya akan dapati J kami; Kes asas; Jika watak -wataknya sama maka cari indeks terikat; Kami hanya mempunyai 1 cara yang hanya memilih watak -watak ini; Sekiranya watak tidak sama; Kurangkannya kerana kami telah mengira dua kali; Kami hanya mempunyai 1 urutan palindrome panjang 1; Jumlah cara yang lain adalah jumlah DP [i - 1] [i + 1], iaitu bilangan subindrome sub - urutan dari 1 hingga i - 1 + bilangan subindrome sub - urutan dari i + 1 hingga n - 1; Kod pemacu", "code": "function solve ( s ) { n = s . length ; let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( let len = n - 1 ; len >= 0 ; -- len ) { for ( let i = 0 ; i + len < n ; ++ i ) { let j = i + len ; if ( i == 0 && j == n - 1 ) { if ( s [ i ] == s [ j ] ) dp [ i ] [ j ] = 2 ; else if ( s [ i ] != s [ j ] ) dp [ i ] [ j ] = 1 ; } else { if ( s [ i ] == s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 < 0 j + 1 >= n ) { dp [ i ] [ j ] += 1 ; } } else if ( s [ i ] != s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 >= 0 && j + 1 <= n - 1 ) { dp [ i ] [ j ] -= dp [ i - 1 ] [ j + 1 ] ; } } } } } let ways = [ ] ; for ( let i = 0 ; i < n ; ++ i ) { if ( i == 0 i == n - 1 ) { ways . push ( 1 ) ; } else { let total = dp [ i - 1 ] [ i + 1 ] ; ways . push ( total ) ; } } for ( let i = 0 ; i < ways . length ; ++ i ) { document . write ( ways [ i ] + \" \" ) ; } } let s = \" \" . split ( \" \" ) ; solve ( s ) ;"}
{"text": "Cari bilangan anak ayam di kebun binatang pada hari ke hari | Berfungsi untuk mengembalikan bilangan anak ayam pada hari ke hari; Saiz DP [] harus sekurang -kurangnya 6 (pengindeksan berasaskan 1 (1); Setiap hari penduduk semasa akan menjadi tiga kali pada hari sebelumnya; Nilai yang dikira secara manual; Dari hari ke -8 dan seterusnya; Penduduk anak ayam berkurangan sebanyak 2/3 setiap hari. Untuk hari ke -8 pada [i - 6] i. Populasi hari ke -2 adalah 3 dan jadi 2 orang baru dilahirkan pada hari ke -6 dan sebagainya untuk hari -hari yang akan datang; Kod pemacu", "code": "function getChicks ( n ) { let size = Math . max ( n , 7 ) ; let dp = new Array ( size ) ; dp . fill ( 0 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i < 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; } dp [ 6 ] = 726 ; for ( let i = 8 ; i <= n ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] - ( 2 * parseInt ( dp [ i - 6 ] / 3 , 10 ) ) ) * 3 ; } return dp [ n ] ; } let n = 3 ; document . write ( getChicks ( n ) ) ;"}
{"text": "Cari bilangan anak ayam di kebun binatang pada hari ke hari | Berfungsi untuk mengembalikan bilangan anak ayam pada hari ke hari; Kod pemacu", "code": "function getChicks ( n ) { let chicks = Math . pow ( 3 , n - 1 ) ; return chicks ; } let n = 3 ; document . write ( getChicks ( n ) ) ;"}
{"text": "Cari langkah minimum yang diperlukan untuk mencapai akhir matriks | Tetapkan 2 | Pelaksanaan JavaScript pendekatan; Array 2d untuk menyimpan negeri -negeri DP; Array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Berfungsi untuk mengembalikan langkah minimum yang diperlukan; Kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula; Hubungan berulang; Kod pemacu", "code": "let n = 3 ; let dp = new Array ( n ) ; let v = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; v [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; v [ i ] [ j ] = 0 ; } } function minSteps ( i , j , arr ) { if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; } if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 9999999 ; for ( let k = Math . max ( 0 , arr [ i ] [ j ] + j - n + 1 ) ; k <= Math . min ( n - i - 1 , arr [ i ] [ j ] ) ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; } dp [ i ] [ j ] ++ ; return dp [ i ] [ j ] ; } let arr = [ [ 4 , 1 , 2 ] , [ 1 , 1 , 1 ] , [ 2 , 1 , 1 ] ] ; let ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) { document . write ( - 1 ) ; } else { document . write ( ans ) ; }"}
{"text": "Cari langkah minimum yang diperlukan untuk mencapai akhir matriks | Set | Program JavaScript untuk melaksanakan pendekatan di atas; Array 2d untuk menyimpan negeri -negeri DP; array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Berfungsi untuk mencari bilangan langkah minimum untuk mencapai akhir matriks; kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula. ; hubungan berulang; Kod pemacu", "code": "let n = 3 ; let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; } let v = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { v [ i ] = new Array ( n ) ; } function minSteps ( i , j , arr ) { if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; } if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 1 + Math . min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; return dp [ i ] [ j ] ; } let arr = [ [ 2 , 1 , 2 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ; let ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) { document . write ( - 1 ) ; } else { document . write ( ans ) ; }"}
{"text": "Treasure and Cities | Program berasaskan memoisasi untuk mencari harta maksimum yang boleh dikumpulkan. ; K ialah indeks semasa dan col adalah warna sebelumnya. ; jika (k == n) kes asas; Semak sama ada warna bandar ini sama dengan bandar yang dilawati sebelum ini; kembali maksimum kedua -dua pilihan; Kod pemacu", "code": "let MAX = 1001 ; let dp = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { dp [ i ] = new Array ( MAX ) ; for ( let j = 0 ; j < MAX ; j ++ ) dp [ i ] [ j ] = - 1 ; } function MaxProfit ( treasure , color , n , k , col , A , B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != - 1 ) return dp [ k ] [ col ] ; let sum = 0 ; if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; } let A = - 5 , B = 7 ; let treasure = [ 4 , 8 , 2 , 9 ] ; let color = [ 2 , 2 , 6 , 2 ] ; let n = color . length ; document . write ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) ;"}
{"text": "Nombor Tetranacci | Berfungsi untuk mencetak nombor tetranacci N - th; kes asas; Kod pemacu", "code": "function printTetra ( n ) { let dp = new Array ( n + 5 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( let i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; document . write ( dp [ n ] ) ; } let n = 10 ; printTetra ( n ) ;"}
{"text": "Jumlah maksimum dalam array bulat supaya tiada dua elemen bersebelahan | Fungsi untuk mengira jumlah dari kedudukan ke -0 ke (n - 2) kedudukan; Salin elemen array asal ke dp []; Cari elemen maksimum dalam array; Mulakan dari 2 nd hingga n - 1 th pos; melintasi semua pendekatan berpasangan bawah; DP - keadaan; Cari jumlah maksimum; mengembalikan maksimum; Berfungsi untuk mencari jumlah maksimum dari kedudukan 1 ke kedudukan n - 1 - th; Melintasi dari ketiga ke n - th pos; pendekatan bootom - up; keadaan DP; Cari jumlah maksimum; kembali max; Kod pemacu", "code": "function maxSum1 ( arr , n ) { let dp = new Array ( n ) ; let maxi = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( i = 2 ; i < n - 1 ; i ++ ) { for ( j = 0 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < dp [ j ] + arr [ i ] ) { dp [ i ] = dp [ j ] + arr [ i ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; } function maxSum2 ( arr , n ) { let dp = new Array ( n ) ; let maxi = 0 ; for ( i = 1 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( i = 3 ; i < n ; i ++ ) { for ( j = 1 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < arr [ i ] + dp [ j ] ) { dp [ i ] = arr [ i ] + dp [ j ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; } function findMaxSum ( arr , n ) { let t = Math . max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) ; return t ; } let arr = [ 1 , 2 , 3 , 1 ] ; let n = arr . length ; document . write ( findMaxSum ( arr , n ) ) ;"}
{"text": "Koefisien Permutasi | Pulangan nilai pekali permutasi p (n, k); Hitung nilai pekali permutasi dengan cara bawah; Kes asas; Hitung nilai menggunakan nilai yang disimpan sebelum ini; Langkah ini penting kerana p (i, j) = 0 untuk j> i; Kod pemacu", "code": "function permutationCoeff ( n , k ) { let P = new Array ( n + 2 ) ; for ( let i = 0 ; i < n + 2 ; i ++ ) { P [ i ] = new Array ( k + 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 ) P [ i ] [ j ] = 1 ; else P [ i ] [ j ] = P [ i - 1 ] [ j ] + ( j * P [ i - 1 ] [ j - 1 ] ) ; P [ i ] [ j + 1 ] = 0 ; } } return P [ n ] [ k ] ; } let n = 10 , k = 2 ; document . write ( \" \" + n + \" \" + k + \" \" + \" \" + permutationCoeff ( n , k ) ) ;"}
{"text": "Koefisien Permutasi | Pulangan nilai pekali permutasi p (n, k); Kes asas; Hitung faktorial nilai sehingga n; P (n, k) = n! / (n - k)! ; Kod pemacu", "code": "function permutationCoeff ( n , k ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return parseInt ( fact [ n ] / fact [ n - k ] , 10 ) ; } let n = 10 , k = 2 ; document . write ( \" \" + \" \" + n + \" \" + k + \" \" + permutationCoeff ( n , k ) ) ;"}
{"text": "Pengaturcaraan Dinamik | Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Kod pemacu", "code": "function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } let set = [ 3 , 34 , 4 , 12 , 5 , 2 ] ; let sum = 9 ; let n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Count of Cyclic Permutations yang mempunyai XOR dengan rentetan binari lain sebagai 0 | Pelaksanaan z - algoritma untuk corak corak masa linear; Berfungsi untuk mendapatkan kiraan permutasi kitaran B yang diberikan 0 apabila xored dengan a; Concatenate B dengan B; BARU B kini mengandungi semua permutasi kitaran Old B sebagai sub-string; corak concatenate dengan teks; Isi arus z yang digunakan dalam algoritma Z; Corak berlaku pada indeks i kerana nilai z sama dengan panjang corak; Kod pemacu", "code": "function compute_z ( s , z ) { var l = 0 , r = 0 ; var n = s . length ; for ( var i = 1 ; i <= n - 1 ; i ++ ) { if ( i > r ) { l = i ; r = i ; while ( r < n && s [ r - l ] === s [ r ] ) { r ++ ; } z [ i ] = r - l ; r -- ; } else { var k = i - l ; if ( z [ k ] < r - i + 1 ) { z [ i ] = z [ k ] ; } else { l = i ; while ( r < n && s [ r - l ] === s [ r ] ) { r ++ ; } z [ i ] = r - l ; r -- ; } } } } function countPermutation ( a , b ) { b = b + b ; b = b . substring ( 0 , b . length - 1 ) ; var ans = 0 ; var s = a + \" \" + b ; var n = s . length ; var z = new Array ( n ) . fill ( 0 ) ; compute_z ( s , z ) ; for ( var i = 1 ; i <= n - 1 ; i ++ ) { if ( z [ i ] === a . length ) { ans ++ ; } } return ans ; } var a = \" \" ; var b = \" \" ; document . write ( countPermutation ( a , b ) ) ;"}
{"text": "Lexicographically terkecil k | fungsi untuk terbalik; Berfungsi untuk mencari saiz ksatria terkecil secara lexicographically K; Panjang rentetan; Menyimpan berikutnya minimum; Melintasi rentetan s; Sekiranya timbunan kosong; Melangkah sehingga watak semasa kurang daripada watak di bahagian atas timbunan; Semak jika terdapat watak yang cukup untuk mendapatkan panjang k; Jika saiz timbunan adalah <k; Tolak watak semasa ke dalamnya; Menyimpan rentetan yang dihasilkan; Berulang sehingga timbunan kosong; Membalikkan rentetan; Cetak rentetan", "code": "function reverse ( input ) { a = input ; var l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { var temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return a ; } function smallestSubsequence ( S , K ) { var N = S . length ; answer = [ ] ; for ( var i = 0 ; i < N ; ++ i ) { if ( answer . length == 0 ) { answer . push ( S [ i ] ) ; } else { while ( ( answer . length != 0 ) && ( S [ i ] < answer [ answer . length - 1 ] ) && ( answer . length - 1 + N - i >= K ) ) { answer . pop ( ) ; } if ( answer . length == 0 answer . length < K ) { answer . push ( S [ i ] ) ; } } } var ret = [ ] ; while ( answer . length != 0 ) { ret += answer [ answer . length - 1 ] ; answer . pop ( ) ; } reverse ( ret ) ; document . write ( ret ) ; } var S = \" \" ; var K = 3 ; smallestSubsequence ( S , K ) ;"}
{"text": "Semak sama ada rentetan betul ke kiri pepenjuru atau tidak | Fungsi untuk memeriksa sama ada rentetan yang diberikan adalah betul untuk kiri pepenjuru atau tidak; Melangkah ke atas rentetan; Jika watak tidak sama dengan watak pertama maka kembali palsu; Diberikan string str; Panggilan fungsi", "code": "function is_rtol ( s ) { let tmp = ( Math . sqrt ( s . length ) ) - 1 ; let first = s [ tmp ] ; for ( let pos = tmp ; pos < s . length - 1 ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } } return true ; } let str = \" \" ; if ( is_rtol ( str ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Pecahkan rentetan yang diberikan ke dalam substrings panjang k dengan jumlah nilai ASCII yang sama | Fungsi untuk memeriksa rentetan; Semak sama ada rentetan boleh dibahagikan kepada substrings panjang K panjang sahaja; Kirakan jumlah substring pertama panjang k; Kirakan jumlah substrings yang tinggal; Semak sama ada jumlahnya sama dengan substring pertama; Oleh kerana semua jumlah tidak sama, kembali palsu; Semua jumlah adalah sama, kembali benar; Semua substrings tidak boleh bersaiz k; Kod pemacu", "code": "function check ( str , K ) { if ( str . length % K === 0 ) { var sum = 0 , i ; for ( i = 0 ; i < K ; i ++ ) { sum += str [ i ] . charCodeAt ( 0 ) ; } for ( var j = i ; j < str . length ; j += K ) { var s_comp = 0 ; for ( var p = j ; p < j + K ; p ++ ) s_comp += str [ p ] . charCodeAt ( 0 ) ; if ( s_comp !== sum ) return false ; } return true ; } return false ; } var K = 3 ; var str = \" \" ; if ( check ( str , K ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Memaksimumkan kiraan 0 s di kiri dan 1 s dalam substring kanan dengan memisahkan rentetan binari yang diberikan | Berfungsi untuk memaksimumkan jumlah kiraan sifar dan yang di dalam substring kiri dan kanan; Untuk menyimpan jumlahnya; Kira jumlah yang ada dalam string str; Untuk menyimpan kiraan sifar dan yang melintasi rentetan; Melepasi rentetan yang diberikan dan kemas kini jumlah maksimum; Mengemas kini jumlah maksimum; Diberikan rentetan binari; Panggilan fungsi", "code": "function maxSum ( str ) { var maximumSum = 0 ; var totalOnes = 0 ; str . split ( ' ' ) . forEach ( c => { if ( c == ' ' ) totalOnes ++ ; } ) ; var zero = 0 , ones = 0 ; for ( var i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == ' ' ) { zero ++ ; } else { ones ++ ; } maximumSum = Math . max ( maximumSum , zero + ( totalOnes - ones ) ) ; } return maximumSum ; } var str = \" \" ; document . write ( maxSum ( str ) ) ;"}
{"text": "Substring terpanjang supaya tidak ada tiga aksara berturut -turut yang sama | Berfungsi untuk mengembalikan panjang substring terpanjang sehingga tiada tiga aksara berturut -turut adalah sama; Jika panjang rentetan yang diberikan kurang daripada 3; Inisialisasi ANS sementara dan akhir hingga 2 kerana ini adalah panjang minimum substring apabila panjang rentetan yang diberikan lebih besar daripada 2; Melintasi rentetan dari watak ketiga ke yang terakhir; Jika tiada tiga aksara berturut -turut adalah sama maka kenaikan sementara sementara; Lain mengemas kini Ans akhir dan menetapkan semula kiraan sementara; Kod pemacu", "code": "function maxLenSubStr ( s ) { if ( s . length < 3 ) return s . length ; let temp = 2 ; let ans = 2 ; for ( let i = 2 ; i < s . length ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = Math . max ( temp , ans ) ; temp = 2 ; } } ans = Math . max ( temp , ans ) ; return ans ; } let s = \" \" ; document . write ( maxLenSubStr ( s ) ) ;"}
{"text": "Bilangan cara untuk mengeluarkan sub | Fungsi untuk mengembalikan bilangan cara mengeluarkan sub -rentetan dari S sedemikian rupa sehingga semua aksara yang tinggal adalah sama; Untuk menyimpan kiraan awalan dan akhiran; Gelung untuk mengira awalan; Gelung untuk mengira akhiran; Watak pertama dan terakhir rentetan adalah sama; Jika tidak; Kod pemacu", "code": "function no_of_ways ( s ) { let n = s . length ; let count_left = 0 , count_right = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( s [ i ] == s [ 0 ] ) { ++ count_left ; } else break ; } for ( let i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == s [ n - 1 ] ) { ++ count_right ; } else break ; } if ( s [ 0 ] == s [ n - 1 ] ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; } let s = \" \" ; document . write ( no_of_ways ( s ) ) ;"}
{"text": "Kira bilangan indeks seperti S [i] = s [i + 1]: pertanyaan pelbagai | Fungsi untuk membuat array awalan; Berfungsi untuk mengembalikan hasil pertanyaan; Kod pemacu; Pertanyaan 1; Pertanyaan 2", "code": "function preCompute ( n , s , pref ) { pref [ 0 ] = 0 ; for ( let i = 1 ; i < n ; i ++ ) { pref [ i ] = pref [ i - 1 ] ; if ( s [ i - 1 ] == s [ i ] ) pref [ i ] ++ ; } } function query ( pref , l , r ) { return pref [ r ] - pref [ l ] ; } let s = \" \" ; let n = s . length ; let pref = new Array ( n ) ; preCompute ( n , s , pref ) ; let l = 1 ; let r = 2 ; document . write ( query ( pref , l , r ) + \" \" ) ; l = 1 ; r = 5 ; document . write ( query ( pref , l , r ) + \" \" ) ;"}
{"text": "Cari arah dari rentetan yang diberikan | Berfungsi untuk mencari arah akhir; Sekiranya kiraan positif yang membayangkan hasilnya adalah arah arah jam; Sekiranya kiraan negatif yang membayangkan hasilnya adalah arah anti jam; Kod pemacu", "code": "function findDirection ( s ) { let count = 0 ; let d = \" \" ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ 0 ] == ' ' ) return null ; if ( s [ i ] == ' ' ) count -- ; else { if ( s [ i ] == ' ' ) count ++ ; } } if ( count > 0 ) { if ( count % 4 == 0 ) d = \" \" ; else if ( count % 4 == 1 ) d = \" \" ; else if ( count % 4 == 2 ) d = \" \" ; else if ( count % 4 == 3 ) d = \" \" ; } if ( count < 0 ) { if ( count % 4 == 0 ) d = \" \" ; else if ( count % 4 == - 1 ) d = \" \" ; else if ( count % 4 == - 2 ) d = \" \" ; else if ( count % 4 == - 3 ) d = \" \" ; } return d ; } let s = \" \" ; document . write ( findDirection ( s ) + \" \" ) ; s = \" \" ; document . write ( findDirection ( s ) ) ;"}
{"text": "Semak jika huruf kecil dan huruf besar berada dalam susunan yang sama | Fungsi untuk memeriksa sama ada kes itu mengikuti perintah yang sama; Melintasi rentetan; Simpan kedua -dua huruf kecil dan huruf besar dalam dua rentetan yang berbeza; transformasi lowerstr1 ke atas; Kod pemacu", "code": "function isCheck ( str ) { var len = str . length ; var lowerStr = \" \" , upperStr = \" \" ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] < ' ' ) upperStr = upperStr + str [ i ] ; else lowerStr = lowerStr + str [ i ] ; } lowerStr = lowerStr . toUpperCase ( ) ; console . log ( lowerStr ) ; return lowerStr === upperStr ; } var str = \" \" ; isCheck ( str ) ? document . write ( \" \" ) : document . write ( \" \" ) ;"}
{"text": "Gantikan setiap watak rentetan oleh watak yang nilai ASCII adalah k kali lebih daripada itu | Berfungsi untuk memindahkan watak rentetan; rentetan berubah; berulang untuk setiap aksara; Nilai ASCII; Simpan pendua; jika k - th ke depan watak melebihi 'z'; Cetak rentetan baru; Kod pemacu; panggilan fungsi", "code": "function encode ( s , k ) { let newS = \" \" ; for ( let i = 0 ; i < s . length ; ++ i ) { let val = s [ i ] . charCodeAt ( 0 ) ; let dup = k ; if ( val + k > 122 ) { k -= ( 122 - val ) ; k = k % 26 ; newS += String . fromCharCode ( 96 + k ) ; } else { newS += String . fromCharCode ( val + k ) ; } k = dup ; } document . write ( newS ) ; } let str = \" \" ; let k = 28 ; encode ( str , k ) ;"}
{"text": "Ubah suai rentetan dengan mengeluarkan vokal di antara dua konsonan | Fungsi untuk memeriksa sama ada watak x adalah vokal atau tidak; Mengembalikan rentetan yang dikemas kini yang dibentuk selepas mengeluarkan semua vokal sandwich dari rentetan yang diberikan; rentetan untuk menyimpan rentetan yang dikemas kini selepas mengeluarkan vokal yang diapit; melintasi rentetan dari kiri ke kanan; Sekiranya watak semasa adalah watak pertama atau terakhir rentetan itu, ini perlu dilampirkan kepada yang dikemas kini, kerana abjad sudut tanpa mengira ia menjadi vokal atau konsonan, tidak pernah 'diapit'; Semak sama ada watak semasa rentetan adalah vokal dan kedua -dua watak -watak terdahulu dan seterusnya adalah konsonan, jika demikian maka ini adalah vokal yang diapit, dengan itu diabaikan dan tidak dilampirkan pada rentetan yang dikemas kini; Jika watak ini bukan vokal yang diapit masuk ke rentetan yang dikemas kini; Kod pemacu; Keluarkan semua vokal sandwitched", "code": "function isVowel ( x ) { if ( x === \" \" x === \" \" x === \" \" x === \" \" x === \" \" ) return true ; else return false ; } function updateSandwichedVowels ( a ) { var n = a . length ; var updatedString = \" \" ; for ( var i = 0 ; i < n ; i ++ ) { if ( i === 0 i === n - 1 ) { updatedString += a [ i ] ; continue ; } if ( isVowel ( a [ i ] ) === true && isVowel ( a [ i - 1 ] ) === false && isVowel ( a [ i + 1 ] ) === false ) { continue ; } updatedString += a [ i ] ; } return updatedString ; } var str = \" \" ; var updatedString = updateSandwichedVowels ( str ) ; document . write ( updatedString ) ;"}
{"text": "Cetak semua laluan pokok binari dengan elemen maksimum dalam setiap laluan yang lebih besar daripada atau sama dengan k | Nod pokok binari; Fungsi utiliti untuk membuat nod baru; Fungsi rekursif untuk mencetak laluan yang elemen maksimumnya lebih besar daripada atau sama dengan k. ; Jika nilai nod semasa lebih besar daripada atau sama dengan k, maka semua subtrees berikutan nod tersebut akan dicetak, bendera = 1 menunjukkan untuk mencetak jalan yang diperlukan; Jika nod daun ditemui, maka jalan dicetak jika saiz vektor laluan lebih besar daripada 0; Tambah nod ke vektor jalan; Mengulangi subtrees kiri dan kanan; Backtracking untuk mengembalikan vektor dan mencetak jalan jika bendera adalah 1; Fungsi untuk memulakan pembolehubah dan panggil fungsi utiliti untuk mencetak laluan dengan nilai maksimum lebih besar daripada atau sama dengan k; Memulakan bendera; Ans digunakan untuk memeriksa keadaan kosong; Fungsi panggilan yang mencetak jalan; Sekiranya jalan tidak wujud; Kod pemacu; Membina pokok berikut: 10 / \\ 5 8 / \\ / \\ 29 2 1 98 / \\ 20 50", "code": "class Node { constructor ( ) { this . data = 0 ; this . left = null ; this . right = null ; } } ; var ans = 0 ; function newNode ( data ) { var newNode = new Node ( ) ; newNode . data = data ; newNode . left = newNode . right = null ; return ( newNode ) ; } function findPathUtil ( root , k , path , flag ) { if ( root == null ) return ; if ( root . data >= k ) flag = 1 ; if ( root . left == null && root . right == null ) { if ( flag == 1 ) { ans = 1 ; document . write ( \" \" ) ; for ( var i = 0 ; i < path . length ; i ++ ) { document . write ( path [ i ] + \" \" ) ; } document . write ( root . data + \" \" ) ; } return ; } path . push ( root . data ) ; findPathUtil ( root . left , k , path , flag ) ; findPathUtil ( root . right , k , path , flag ) ; path . pop ( ) ; } function findPath ( root , k ) { var flag = 0 ; ans = 0 ; var v = [ ] ; findPathUtil ( root , k , v , flag ) ; if ( ans == 0 ) document . write ( \" \" ) ; } var K = 25 ; var root = newNode ( 10 ) ; root . left = newNode ( 5 ) ; root . right = newNode ( 8 ) ; root . left . left = newNode ( 29 ) ; root . left . right = newNode ( 2 ) ; root . right . right = newNode ( 98 ) ; root . right . left = newNode ( 1 ) ; root . right . right . right = newNode ( 50 ) ; root . left . left . left = newNode ( 20 ) ; findPath ( root , K ) ;"}
{"text": "Nombor TrideCagonal | Berfungsi untuk mencari nombor tridekagonal; Formula untuk mengira nombor tridecagonal nth; Kod pemacu", "code": "function Tridecagonal_num ( n ) { return ( 11 * n * n - 9 * n ) / 2 ; } let n = 3 ; document . write ( Tridecagonal_num ( n ) + \" \" ) ; n = 10 ; document . write ( Tridecagonal_num ( n ) ) ;"}
{"text": "Bilangan bilangan bulat n digit dengan berat w | Berfungsi untuk mencari jumlah nombor yang mungkin dengan digit dan berat w; Apabila berat integer positif; Tolak berat dari 9; Apabila berat integer adalah negatif; Tambah berat badan kepada 10 untuk menjadikannya positif; Kod pemacu; bilangan digit dalam integer dan w sebagai berat; Cetak jumlah nombor yang mungkin dengan N digit dan berat w", "code": "function findNumbers ( n , w ) { let x = 0 , sum = 0 ; if ( w >= 0 && w <= 8 ) { x = 9 - w ; } else if ( w >= - 9 && w <= - 1 ) { x = 10 + w ; } sum = Math . pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; } let n , w ; n = 3 ; w = 4 ; document . write ( findNumbers ( n , w ) ) ;"}
{"text": "Ketinggian maksimum susunan segi tiga nilai array | Program JavaScript untuk mencari ketinggian maksimum susunan piramida nilai array; Hanya memeriksa sama ada tahap ith mungkin atau tidak jika mungkin maka kita mesti mempunyai atleast (i * (i + 1)) / 2 elemen dalam array; mengemas kini nilai hasil setiap kali; Jika tidak, kita telah melebihi nilai n; Kod pemacu", "code": "function MaximumHeight ( a , n ) { let result = 1 ; for ( i = 1 ; i <= n ; ++ i ) { let y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; } let arr = [ 40 , 100 , 20 , 30 ] ; let n = arr . length ; document . write ( MaximumHeight ( arr , n ) ) ;"}
{"text": "K | Program JavaScript untuk mencari elemen k - Th dalam urutan ganjil - walaupun. ; Masukkan semua nombor ganjil dari 1 hingga n. ; Masukkan semua nombor dari 1 hingga n. ; Kod pemacu", "code": "function findK ( n , k ) { let a = [ ] ; for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push ( i ) ; for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push ( i ) ; return ( a [ k - 1 ] ) ; } let n = 10 , k = 3 ; document . write ( findK ( n , k ) ) ;"}
{"text": "Satu fungsi baris untuk faktorial nombor | Program JavaScript untuk mencari faktorial nombor yang diberikan; Baris tunggal untuk mencari faktorial; Kod pemacu", "code": "function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } let num = 5 ; document . write ( \" \" , num , \" \" , factorial ( num ) ) ;"}
{"text": "Nombor Pell | Hitung nombor pell; Fungsi pemacu", "code": "function pell ( n ) { if ( n <= 2 ) return n ; let a = 1 ; let b = 2 ; let c ; for ( let i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; } let n = 4 ; document . write ( pell ( n ) ) ;"}
{"text": "Cara yang cekap untuk memeriksa sama ada N | Pulangan benar jika nombor fibonacci n - th adalah berganda dari 10 .; Kod pemacu", "code": "function isMultipleOf10 ( n ) { return ( n % 15 == 0 ) ; } let n = 30 ; if ( isMultipleOf10 ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Cari kesopanan nombor | Fungsi untuk mengira semua faktor utama ganjil nombor n; Menghapuskan semua faktor utama bilangan n; n mesti ganjil pada ketika ini, jadi berulang hanya untuk nombor ganjil sehingga sqrt (n); Jika saya membahagikan N, maka mula mengira pembahagi ganjil; Jika n yang ganjil masih kekal maka hitungnya; Kod pemacu", "code": "function countOddPrimeFactors ( n ) { let result = 1 ; while ( n % 2 == 0 ) n /= 2 ; for ( let i = 3 ; i * i <= n ; i += 2 ) { let divCount = 0 ; while ( n % i == 0 ) { n /= i ; ++ divCount ; } result *= divCount + 1 ; } if ( n > 2 ) result *= 2 ; return result ; } function politness ( n ) { return countOddPrimeFactors ( n ) - 1 ; } let n = 90 ; document . write ( \" \" + n + \" \" + politness ( n ) + \" \" ) ; n = 15 ; document . write ( \" \" + n + \" \" + politness ( n ) ) ;"}
{"text": "Perdana terdekat yang kurang daripada bilangan N | array untuk menyimpan semua prima kurang daripada 10 ^ 6; Fungsi utiliti penapis Sundaram; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x; Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j; menghapuskan indeks yang tidak menghasilkan prima; Oleh kerana 2 adalah nombor perdana; Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Carian binari yang diubah suai untuk mencari perdana terdekat kurang daripada n; Keadaan asas adalah, jika kita sampai di sudut kiri atau sudut kanan prima [] array kemudian kembali elemen sudut kerana sebelum atau selepas itu kita tidak mempunyai sebarang nombor utama dalam array prima; Sekarang jika N sendiri menjadi perdana jadi ia akan hadir dalam pelbagai prima dan di sini kita perlu mencari perdana terdekat yang kurang daripada n supaya kita akan mengembalikan prima [pertengahan - 1]; Sekarang jika prima [pertengahan] <n dan prima [pertengahan + 1]> n Itu bermakna kita sampai pada perdana terdekat; Program pemacu untuk menjalankan kes itu", "code": "var primes = [ ] ; var MAX = 1000000 ; function Sieve ( ) { let n = MAX ; let nNew = parseInt ( Math . sqrt ( n ) ) ; var marked = new Array ( n / 2 + 500 ) . fill ( 0 ) ; for ( let i = 1 ; i <= parseInt ( ( nNew - 1 ) / 2 ) ; i ++ ) for ( let j = ( i * ( i + 1 ) ) << 1 ; j <= parseInt ( n / 2 ) ; j = j + 2 * i + 1 ) marked [ j ] = 1 ; primes . push ( 2 ) ; for ( let i = 1 ; i <= parseInt ( n / 2 ) ; i ++ ) if ( marked [ i ] == 0 ) primes . push ( 2 * i + 1 ) ; } function binarySearch ( left , right , n ) { if ( left <= right ) { let mid = parseInt ( ( left + right ) / 2 ) ; if ( mid == 0 mid == primes . length - 1 ) return primes [ mid ] ; if ( primes [ mid ] == n ) return primes [ mid - 1 ] ; if ( primes [ mid ] < n && primes [ mid + 1 ] > n ) return primes [ mid ] ; if ( n < primes [ mid ] ) return binarySearch ( left , mid - 1 , n ) ; else return binarySearch ( mid + 1 , right , n ) ; } return 0 ; } Sieve ( ) ; let n = 17 ; document . write ( binarySearch ( 0 , primes . length - 1 , n ) ) ;"}
{"text": "Program untuk faktorial nombor | fungsi untuk mencari faktorial nombor yang diberikan; Kod pemacu", "code": "function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } let num = 5 ; document . write ( \" \" + num + \" \" + factorial ( num ) ) ;"}
{"text": "Matikan Bit Set Bit | Tetapkan 2 | Tidak menetapkan bit set yang paling kanan dan mengembalikan hasilnya; Kod pemacu", "code": "function FlipBits ( n ) { return n -= ( n & ( - n ) ) ; } let N = 12 ; document . write ( \" \" ) ; document . write ( \" \" + FlipBits ( N ) ) ;"}
{"text": "Nilai maksimum XOR di antara semua tiga kali ganda array | berfungsi untuk mengira nilai XOR maksimum untuk triplet; Set digunakan untuk mengelakkan pengulangan; Simpan semua kemungkinan nilai XOR yang unik; menyimpan nilai maksimum; Kod pemacu", "code": "function Maximum_xor_Triplet ( n , a ) { let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { s . add ( a [ i ] ^ a [ j ] ) ; } } let ans = 0 ; for ( let i of s . values ( ) ) { for ( let j = 0 ; j < n ; j ++ ) { ans = Math . max ( ans , i ^ a [ j ] ) ; } } document . write ( ans , \" \" ) ; } let a = [ 1 , 3 , 8 , 15 ] ; let n = a . length ; Maximum_xor_Triplet ( n , a ) ;"}
{"text": "Cari unsur -unsur yang hilang dari julat | Cetak semua elemen julat [rendah, tinggi] yang tidak hadir dalam arr [0 .. n - 1]; Buat pelbagai boolean saiz tinggi - rendah + 1, setiap indeks yang saya mewakili elemen (i + rendah) yang dijumpai atau tidak. ; Sekiranya elemen ARR berada dalam jarak rendah hingga tinggi maka tandakan indeks yang sepadan sebagai benar dalam array; Melintasi julat dan prlet semua elemen yang nilainya palsu; Program Pemandu", "code": "function prletMissing ( arr , low , high ) { let polets_of_range = Array ( high - low + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( low <= arr [ i ] && arr [ i ] <= high ) polets_of_range [ arr [ i ] - low ] = true ; } for ( let x = 0 ; x <= high - low ; x ++ ) { if ( polets_of_range [ x ] == false ) document . write ( ( low + x ) + \" \" ) ; } } let arr = [ 1 , 3 , 5 , 4 ] ; let low = 1 , high = 10 ; prletMissing ( arr , low , high ) ;"}
{"text": "K | Mengembalikan elemen k - yang hilang. Ia kembali - 1 jika tiada k adalah lebih daripada bilangan elemen yang hilang. ; Masukkan semua elemen urutan Givens B []. ; Melintasi urutan yang semakin meningkat dan menjejaki jumlah nombor yang hilang. ; program pemacu untuk menguji fungsi di atas", "code": "function find ( a , b , k , n1 , n2 ) { var s = new Set ( ) ; for ( var i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ; var missing = 0 ; for ( var i = 0 ; i < n1 ; i ++ ) { if ( ! s . has ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; } var a = [ 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 ] ; var b = [ 4 , 10 , 6 , 8 , 12 ] ; var n1 = a . length ; var n2 = b . length ; var k = 3 ; document . write ( find ( a , b , k , n1 , n2 ) ) ;"}
{"text": "Kurangkan langkah -langkah untuk membentuk rentetan s dari rentetan rawak panjang K menggunakan Panjang Tetap Panjang | Berfungsi untuk mencari bilangan minimum rentetan yang diperlukan untuk menjana rentetan asal; Menyimpan kekerapan setiap watak rentetan s; Melangkah ke atas julat [0, 25]; Menyimpan kekerapan setiap watak rentetan s; Mengira watak yang unik dalam s; Jika watak unik lebih besar maka n, maka kembali - 1; Jika tidak; Melakukan carian binari; Cari nilai pertengahan; Melangkah ke atas julat [0, 26]; Jika jumlah [i] lebih besar daripada 0; Mengemas kini julat; Cari rentetan yang dihasilkan; Menjana berikutnya; Jika panjang rentetan hasil kurang daripada N daripada menambah watak 'A'; Cetak rentetan; Kod pemacu", "code": "function findString ( S , N ) { let amounts = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { amounts [ i ] = 0 ; } for ( let i = 0 ; i < S . length ; i ++ ) { amounts [ S [ i ] . charCodeAt ( 0 ) - 97 ] ++ ; } let count = 0 ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) count ++ ; } if ( count > N ) { document . write ( \" \" ) ; } else { let ans = \" \" ; let high = 100001 ; let low = 0 ; let mid , total ; while ( high - low > 1 ) { total = 0 ; mid = Math . floor ( ( high + low ) / 2 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += Math . floor ( ( amounts [ i ] - 1 ) / mid + 1 ) ; } } if ( total <= N ) { high = mid ; } else { low = mid ; } } document . write ( high + \" \" ) ; total = 0 ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += Math . floor ( ( amounts [ i ] - 1 ) / high + 1 ) ; for ( let j = 0 ; j < Math . floor ( ( amounts [ i ] - 1 ) / high + 1 ) ; j ++ ) { ans += String . fromCharCode ( i + 97 ) ; } } } for ( let i = total ; i < N ; i ++ ) { ans += \" \" ; } ans = ans . split ( \" \" ) . reverse ( ) . join ( \" \" ) ; document . write ( ans ) ; } } let S = \" \" ; let K = 4 ; findString ( S , K ) ;"}
{"text": "Cari elemen berulang pertama dalam pelbagai integer | Fungsi ini mencetak elemen berulang pertama dalam arr []; Memulakan indeks elemen berulang pertama; Mewujudkan hashset kosong; Melintasi array input dari kanan ke kiri; Jika elemen sudah ada dalam hash set, kemas kini min; Lain tambah elemen ke hash set; Cetak hasilnya; Kod pemacu", "code": "function printFirstRepeating ( arr ) { let min = - 1 ; let set = new Set ( ) ; for ( let i = arr . length - 1 ; i >= 0 ; i -- ) { if ( set . has ( arr [ i ] ) ) min = i ; else set . add ( arr [ i ] ) ; } if ( min != - 1 ) document . write ( \" \" + arr [ min ] ) ; else document . write ( \" \" ) ; } let arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] ; printFirstRepeating ( arr ) ;"}
{"text": "Cari elemen berulang pertama dalam pelbagai integer | Fungsi ini mencetak elemen berulang pertama dalam ARR; Ini akan menetapkan k = 1, jika ada elemen berulang yang dijumpai; max = maksimum dari (semua elemen & n); Array A adalah untuk menyimpan 1 masa yang berlaku pada elemen yang diasaskan oleh 0; Simpan 1 dalam array b Jika elemen adalah pendua yang diasaskan oleh 0; Elemen pendua yang dijumpai; menyimpan 1 st kejadian arr [i]; Trace Array A & Cari Elemen Berulang dengan Min Index; Kod pemacu", "code": "function printFirstRepeating ( arr , n ) { var k = 0 ; var max = n ; for ( i = 0 ; i < n ; i ++ ) if ( max < arr [ i ] ) max = arr [ i ] ; var a = Array ( max + 1 ) . fill ( 0 ) ; var b = Array ( max + 1 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ arr [ i ] ] != 0 ) { b [ arr [ i ] ] = 1 ; k = 1 ; continue ; } else a [ arr [ i ] ] = i ; } if ( k == 0 ) document . write ( \" \" ) ; else { var min = max + 1 ; for ( i = 0 ; i < max + 1 ; i ++ ) if ( a [ i ] != 0 && min > a [ i ] && b [ i ] != 0 ) min = a [ i ] ; document . write ( arr [ min ] ) ; } document . write ( \" \" ) ; } var arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] ; var n = arr . length ; printFirstRepeating ( arr , n ) ;"}
{"text": "K | Mengembalikan elemen yang berbeza dalam arr. ; Semak jika elemen semasa hadir di tempat lain. ; Jika elemen adalah unik; Kod pemacu", "code": "function printKDistinct ( arr , n , k ) { var dist_count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; } var ar = [ 1 , 2 , 1 , 3 , 4 , 2 ] ; var n = ar . length ; var k = 2 ; document . write ( printKDistinct ( ar , n , k ) ) ;"}
{"text": "Count Subarrays mempunyai kiraan yang sama dengan 0 dan 1 S berasal | Fungsi untuk mengira subarray yang mempunyai kiraan yang sama dengan 0 s dan 1 s dengan semua 0 s dan semua 1 dikelompokkan bersama; Menyimpan kiraan; Memulakan CUR dengan elemen pertama; Jika elemen seterusnya adalah sama dengan elemen semasa; Kiraan kenaikan; Kemas kini curr; Melangkah ke atas kiraan array; Pertimbangkan minimum; Diberikan [] arr; Panggilan fungsi", "code": "function countSubarrays ( A , N ) { var res = 0 ; var curr = A [ 0 ] ; var cnt = [ ] ; cnt . fill ( 1 ) for ( var c = 1 ; c < N ; c ++ ) { if ( A == curr ) cnt [ cnt . length - 1 ] ++ ; else curr = A ; cnt . push ( 1 ) ; } for ( var i = 1 ; i < cnt . length ; i ++ ) { res += Math . min ( cnt [ i - 1 ] , cnt [ i ] ) ; } document . write ( res ) ; } var A = [ 1 , 1 , 0 , 0 , 1 , 0 ] ; var N = A . length ; countSubarrays ( A , N ) ;"}
{"text": "Semak jika pokok binari adalah walaupun | Nod pokok; Berfungsi untuk mengembalikan nod pokok baru; Berfungsi untuk memeriksa sama ada pokok itu - pokok ganjil; Menyimpan nod setiap peringkat; Simpan tahap semasa pokok binari; Melintasi sehingga barisan kosong; Menyimpan bilangan nod yang terdapat di peringkat semasa; Semak sama ada tahapnya atau ganjil; Tambah nod tahap seterusnya ke dalam barisan; Meningkatkan kiraan tahap; Membina pokok binari; Periksa sama ada pokok binari itu - pokok ganjil atau tidak", "code": "class Node { constructor ( data ) { this . left = null ; this . right = null ; this . val = data ; } } function newNode ( data ) { let temp = new Node ( data ) ; return temp ; } function isEvenOddBinaryTree ( root ) { if ( root == null ) return true ; let q = [ ] ; q . push ( root ) ; let level = 0 ; while ( q . length > 0 ) { let size = q . length ; for ( let i = 0 ; i < size ; i ++ ) { let node = q [ 0 ] ; q . shift ( ) ; if ( level % 2 == 0 ) { if ( node . val % 2 == 1 ) return false ; } else if ( level % 2 == 1 ) { if ( node . val % 2 == 0 ) return false ; } if ( node . left != null ) { q . push ( node . left ) ; } if ( node . right != null ) { q . push ( node . right ) ; } } level ++ ; } return true ; } let root = null ; root = newNode ( 2 ) ; root . left = newNode ( 3 ) ; root . right = newNode ( 9 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 10 ) ; root . right . right = newNode ( 6 ) ; if ( isEvenOddBinaryTree ( root ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Memaksimumkan jarak minimum antara pengulangan dari sebarang permutasi array yang diberikan | Program JavaScript untuk melaksanakan pendekatan di atas; Saiz array; Menyimpan kekerapan elemen array; Cari kekerapan tertinggi dalam array; Meningkatkan kiraan elemen maksimum; Sekiranya tiada pengulangan hadir; Cari jarak maksimum; Mengembalikan jarak maksimum; Kod pemacu", "code": "function findMaxLen ( a ) { var n = a . length ; var freq = Array ( n + 1 ) . fill ( 0 ) ; var i ; for ( i = 0 ; i < n ; ++ i ) { freq [ a [ i ] ] ++ ; } var maxFreqElement = - 2147483648 ; var maxFreqCount = 1 ; for ( i = 1 ; i <= n ; ++ i ) { if ( freq [ i ] > maxFreqElement ) { maxFreqElement = freq [ i ] ; maxFreqCount = 1 ; } else if ( freq [ i ] == maxFreqElement ) maxFreqCount ++ ; } var ans ; if ( maxFreqElement == 1 ) ans = 0 ; else { ans = ( ( n - maxFreqCount ) / ( maxFreqElement - 1 ) ) ; } return ans ; } var a = [ 1 , 2 , 1 , 2 ] ; document . write ( findMaxLen ( a ) ) ;"}
{"text": "Pertanyaan untuk menilai persamaan yang diberikan dalam julat [l, r] | Berfungsi untuk mendapatkan indeks pertengahan julat; Fungsi rekursif untuk mendapatkan jumlah nilai dalam julat yang diberikan dari array. Berikut adalah parameter untuk fungsi ini. st. Penunjuk ke nod pokok segmen. Indeks nod semasa dalam segmen pokok SS & SE. Memulakan dan mengakhiri indeks segmen yang diwakili oleh nod semasa, i. e. , St [nod] L & R. Memulakan dan mengakhiri indeks pertanyaan pelbagai; Jika segmen nod ini terletak sepenuhnya dalam julat yang diberikan; Pulangan maksimum dalam segmen; Jika segmen nod ini terletak di luar julat yang diberikan; Jika segmen nod ini terletak sebahagiannya dalam julat yang diberikan; Berfungsi untuk mengembalikan maksimum dalam julat dari [L, R]; Semak nilai input yang salah; Berfungsi untuk pokok consegment untuk subarray [ss. . se]; Untuk satu elemen; Jika tidak; Berulang untuk subtree kiri; Berulang untuk subtree yang betul; Berfungsi untuk pokok consegment dari array yang diberikan; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan; Mengembalikan pokok segmen yang dibina; Kod pemacu; Bina pokok segmen dari array yang diberikan", "code": "function getMid ( s , e ) { return ( s + Math . floor ( ( e - s ) / 2 ) ) ; } function MaxUtil ( st , ss , se , l , r , node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return - 1 ; let mid = getMid ( ss , se ) ; return Math . max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; } function getMax ( st , n , l , r ) { if ( l < 0 r > n - 1 l > r ) { document . write ( \" \" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; } function constructSTUtil ( arr , ss , se , st , si ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return arr [ ss ] ; } let mid = getMid ( ss , se ) ; st [ si ] = Math . max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; } function constructST ( arr , n ) { let x = ( Math . ceil ( Math . log ( n ) ) ) ; let max_size = 2 * Math . pow ( 2 , x ) - 1 ; let st = Array . from ( { length : max_size } , ( _ , i ) => 0 ) ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } let arr = [ 5 , 2 , 3 , 0 ] ; let n = arr . length ; let st = constructST ( arr , n ) ; let Q = [ [ 1 , 3 ] , [ 0 , 2 ] ] ; for ( let i = 0 ; i < Q . length ; i ++ ) { let max = getMax ( st , n , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; let ok = 0 ; for ( let j = 30 ; j >= 0 ; j -- ) { if ( ( max & ( 1 << j ) ) != 0 ) ok = 1 ; if ( ok <= 0 ) continue ; max |= ( 1 << j ) ; } document . write ( max + \" \" ) ; }"}
{"text": "Cari bilangan pasangan dalam array supaya XOR mereka adalah 0 | Fungsi untuk mengira kiraan; Menyusun senarai menggunakan fungsi terbina; Melintasi unsur -unsur; Kekerapan mengira setiap elemen; Menambah sumbangan kekerapan kepada jawapannya; Kod pemacu; Cetak kiraan", "code": "function calculate ( a , n ) { a . sort ( ) ; let count = 1 ; let answer = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + Math . floor ( ( count * ( count - 1 ) ) / 2 ) ; count = 1 ; } } answer = answer + Math . floor ( ( count * ( count - 1 ) ) / 2 ) ; return answer ; } let a = [ 1 , 2 , 1 , 2 , 4 ] ; let n = a . length ; document . write ( calculate ( a , n ) ) ;"}
{"text": "Cari bilangan pasangan dalam array supaya XOR mereka adalah 0 | Berfungsi untuk mengira jawapannya; Mencari maksimum array; Mewujudkan array frekuensi dengan nilai awal 0; Melintasi array; Kekerapan mengira; Melintasi pelbagai frekuensi; Mengira jawapan; Kod pemacu; Fungsi panggilan", "code": "function calculate ( a , n ) { let maximum = Math . max ( ... a ) ; let frequency = new Array ( maximum + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } let answer = 0 ; for ( let i = 0 ; i < maximum + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return parseInt ( answer / 2 ) ; } let a = [ 1 , 2 , 1 , 2 , 4 ] ; let n = a . length ; document . write ( calculate ( a , n ) ) ;"}
{"text": "Subarray terbesar dengan bilangan yang sama 0 s dan 1 s | Fungsi ini mencetak indeks permulaan dan akhir subarray terbesar dengan bilangan yang sama 0 s dan 1 s. Juga mengembalikan saiz subarray tersebut. ; Pilih titik permulaan seperti saya; Pertimbangkan semua subarrays bermula dari i; Jika ini adalah subarray 0 jumlah, maka bandingkan dengan subarray saiz maksimum yang dikira setakat ini; Program pemacu untuk menguji fungsi di atas", "code": "function findSubArray ( arr , n ) { let sum = 0 ; let maxsize = - 1 , startindex = 0 ; let endindex = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) document . write ( \" \" ) ; else document . write ( startindex + \" \" + endindex ) ; return maxsize ; } let arr = [ 1 , 0 , 0 , 1 , 0 , 1 , 1 ] ; let size = arr . length ; findSubArray ( arr , size ) ;"}
{"text": "Elemen maksimum dalam array yang disusun dan diputar | Berfungsi untuk mengembalikan elemen maksimum; Sekiranya terdapat hanya satu elemen yang tersisa; Cari pertengahan; Semak jika pertengahan mencapai 0, ia lebih besar daripada elemen seterusnya atau tidak; Periksa sama ada pertengahan sendiri adalah elemen maksimum; Tentukan sama ada kita perlu pergi ke separuh kiri atau separuh kanan; Kod pemacu", "code": "function findMax ( arr , low , high ) { if ( high == low ) return arr [ low ] ; let mid = low + ( high - low ) / 2 ; if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) { return arr [ mid ] ; } if ( mid < high && arr [ mid + 1 ] < arr [ mid ] && mid > 0 && arr [ mid ] > arr [ mid - 1 ] ) { return arr [ mid ] ; } if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } } let arr = [ 5 , 6 , 1 , 2 , 3 , 4 ] ; let n = arr . length ; document . write ( findMax ( arr , 0 , n - 1 ) ) ;"}
{"text": "Carian Ternary | Berfungsi untuk melakukan carian ternary; Cari Mid1 dan Mid2; Semak sama ada kunci hadir di mana -mana pertengahan; Oleh kerana kunci tidak hadir pada pertengahan, periksa di mana rantau ia hadir kemudian ulangi operasi carian di rantau itu; Kunci terletak di antara L dan MID1; Kunci terletak di antara Mid2 dan R; Kuncinya terletak di antara Mid1 dan Mid2; Kunci tidak dijumpai; Kod pemacu; Dapatkan array jenis array jika tidak disusun; Indeks permulaan; panjang array; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya", "code": "function ternarySearch ( l , r , key , ar ) { while ( r >= l ) { let mid1 = l + parseInt ( ( r - l ) / 3 , 10 ) ; let mid2 = r - parseInt ( ( r - l ) / 3 , 10 ) ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) { l = mid2 + 1 ; } else { l = mid1 + 1 ; r = mid2 - 1 ; } } return - 1 ; } let l , r , p , key ; let ar = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ; l = 0 ; r = 9 ; key = 5 ; p = ternarySearch ( l , r , key , ar ) ; document . write ( \" \" + key + \" \" + p + \" \" ) ; key = 50 ; p = ternarySearch ( l , r , key , ar ) ; document . write ( \" \" + key + \" \" + p ) ;"}
{"text": "Elemen Majoriti | Set | berfungsi untuk mencetak nombor majoriti; Kod pemacu", "code": "function majorityNumber ( arr , n ) { let ans = - 1 ; let freq = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) } else { freq . set ( arr [ i ] , 1 ) } if ( freq . get ( arr [ i ] ) > n / 2 ) ans = arr [ i ] ; } return ans ; } let a = [ 2 , 2 , 1 , 1 , 1 , 2 , 2 ] ; let n = a . length ; document . write ( majorityNumber ( a , n ) ) ;"}
{"text": "Cari elemen dalam array yang disusun dan diputar | Pulangan indeks kunci dalam arr [l. . h] jika kunci hadir, jika tidak pulangan - 1; Jika arr [l ... pertengahan] disusun; Oleh kerana subarray ini disusun, kita dapat dengan cepat memeriksa sama ada kunci terletak pada separuh atau separuh lagi; Jika kunci tidak terletak pada separuh pertama subarray, bahagikan separuh lagi ke dalam dua subarray, supaya kita dapat dengan cepat memeriksa jika kunci terletak pada separuh lain; Jika arr [l. . pertengahan] subarray pertama tidak disusun, maka arr [pertengahan ... h] mesti disusun subarray; Program Pemandu", "code": "function search ( arr , l , h , key ) { if ( l > h ) return - 1 ; let mid = Math . floor ( ( l + h ) / 2 ) ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } let arr = [ 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ] ; let n = arr . length ; let key = 6 ; let i = search ( arr , 0 , n - 1 , key ) ; if ( i != - 1 ) document . write ( \" \" + i + \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Cari elemen minimum dalam array yang disusun dan diputar | Program JavaScript untuk mencari elemen minimum dalam array yang disusun dan diputar; Keadaan ini diperlukan untuk mengendalikan kes apabila array tidak diputar sama sekali; Sekiranya terdapat hanya satu elemen yang tersisa; Cari pertengahan; Semak jika elemen (pertengahan + 1) adalah elemen minimum. Pertimbangkan kes seperti {3, 4, 5, 1, 2}; Semak jika Mid sendiri adalah elemen minimum; Tentukan sama ada kita perlu pergi ke separuh kiri atau kanan; Program Pemandu", "code": "function findMin ( arr , low , high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; } let arr1 = [ 5 , 6 , 1 , 2 , 3 , 4 ] ; let n1 = arr1 . length ; document . write ( \" \" + findMin ( arr1 , 0 , n1 - 1 ) + \" \" ) ; let arr2 = [ 1 , 2 , 3 , 4 ] ; let n2 = arr2 . length ; document . write ( \" \" + findMin ( arr2 , 0 , n2 - 1 ) + \" \" ) ; let arr3 = [ 1 ] ; let n3 = arr3 . length ; document . write ( \" \" + findMin ( arr3 , 0 , n3 - 1 ) + \" \" ) ; let arr4 = [ 1 , 2 ] ; let n4 = arr4 . length ; document . write ( \" \" + findMin ( arr4 , 0 , n4 - 1 ) + \" \" ) ; let arr5 = [ 2 , 1 ] ; let n5 = arr5 . length ; document . write ( \" \" + findMin ( arr5 , 0 , n5 - 1 ) + \" \" ) ; let arr6 = [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ] ; let n6 = arr6 . length ; document . write ( \" \" + findMin ( arr6 , 0 , n6 - 1 ) + \" \" ) ; let arr7 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ; let n7 = arr7 . length ; document . write ( \" \" + findMin ( arr7 , 0 , n7 - 1 ) + \" \" ) ; let arr8 = [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 ] ; let n8 = arr8 . length ; document . write ( \" \" + findMin ( arr8 , 0 , n8 - 1 ) + \" \" ) ; let arr9 = [ 3 , 4 , 5 , 1 , 2 ] ; let n9 = arr9 . length ; document . write ( \" \" + findMin ( arr9 , 0 , n9 - 1 ) + \" \" ) ;"}
{"text": "Cari elemen minimum dalam array yang disusun dan diputar | Berfungsi untuk mencari elemen minimum; Kod pemacu", "code": "function findMin ( arr , low , high ) { while ( low < high ) { let mid = Math . floor ( low + ( high - low ) / 2 ) ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; } var arr1 = [ 5 , 6 , 1 , 2 , 3 , 4 ] ; var n1 = arr1 . length ; document . write ( \" \" + findMin ( arr1 , 0 , n1 - 1 ) + \" \" ) ; var arr2 = [ 1 , 2 , 3 , 4 ] ; var n2 = arr2 . length ; document . write ( \" \" + findMin ( arr2 , 0 , n2 - 1 ) + \" \" ) ; var arr3 = [ 1 ] ; var n3 = arr3 . length ; document . write ( \" \" + findMin ( arr3 , 0 , n3 - 1 ) + \" \" ) ; var arr4 = [ 1 , 2 ] ; var n4 = arr4 . length ; document . write ( \" \" + findMin ( arr4 , 0 , n4 - 1 ) + \" \" ) ; var arr5 = [ 2 , 1 ] ; var n5 = arr5 . length ; document . write ( \" \" + findMin ( arr5 , 0 , n5 - 1 ) + \" \" ) ; var arr6 = [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ] ; var n6 = arr6 . length ; document . write ( \" \" + findMin ( arr6 , 0 , n6 - 1 ) + \" \" ) ; var arr7 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ; var n7 = arr7 . length ; document . write ( \" \" + findMin ( arr7 , 0 , n7 - 1 ) + \" \" ) ; var arr8 = [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 ] ; var n8 = arr8 . length ; document . write ( \" \" + findMin ( arr8 , 0 , n8 - 1 ) + \" \" ) ; var arr9 = [ 3 , 4 , 5 , 1 , 2 ] ; var n9 = arr9 . length ; document . write ( \" \" + findMin ( arr9 , 0 , n9 - 1 ) + \" \" ) ;"}
{"text": "Cari elemen terkecil terkecil dan kedua dalam array | Berfungsi untuk mencetak unsur -unsur terkecil terkecil pertama dan kedua; Harus ada dua elemen; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Program Pemandu", "code": "function print2Smallest ( arr , arr_size ) { let i , first , second ; if ( arr_size < 2 ) { document . write ( \" \" ) ; return ; } first = Number . MAX_VALUE ; second = Number . MAX_VALUE ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == Number . MAX_VALUE ) document . write ( \" \" ) ; else document . write ( \" \" + first + \" \" + \" \" + second + ' ' ) ; } let arr = [ 12 , 13 , 1 , 10 , 34 , 1 ] ; let n = arr . length ; print2Smallest ( arr , n ) ;"}
{"text": "Range LCM Queries | LCM pertanyaan pelbagai yang diberikan menggunakan pokok segmen; memperuntukkan ruang untuk pokok; mengisytiharkan array di seluruh dunia; Berfungsi untuk mengembalikan GCD A dan B; fungsi utiliti untuk mencari LCM; Fungsi untuk membina nod pokok segmen memulakan indeks permulaan subtree semasa. Permulaan dan akhir adalah indeks dalam arr [] yang global; Sekiranya terdapat hanya satu elemen dalam subarray semasa; membina segmen kiri dan kanan; membina ibu bapa; Berfungsi untuk membuat pertanyaan untuk pelbagai array) l, r). Node adalah indeks akar segmen semasa dalam pokok segmen (perhatikan bahawa indeks dalam pokok segmen bermula dengan 1F atau kesederhanaan). Mula dan akhir adalah indeks subarray yang dilindungi oleh akar segmen semasa. ; Sepenuhnya di luar segmen, kembali 1 tidak akan menjejaskan LCM; ; sepenuhnya di dalam segmen; sebahagiannya di dalam; fungsi pemacu untuk menyemak program di atas memulakan array; membina pokok segmen; Sekarang kita dapat menjawab setiap pertanyaan dengan cekap mencetak LCM (2, 5); Cetak LCM (5, 10); Cetak LCM (0, 10)", "code": "const MAX = 1000 var tree = new Array ( 4 * MAX ) ; var arr = new Array ( MAX ) ; function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function lcm ( a , b ) { return Math . floor ( a * b / gcd ( a , b ) ) ; } function build ( node , start , end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } let mid = Math . floor ( ( start + end ) / 2 ) ; build ( 2 * node , start , mid ) ; build ( 2 * node + 1 , mid + 1 , end ) ; let left_lcm = tree [ 2 * node ] ; let right_lcm = tree [ 2 * node + 1 ] ; tree [ node ] = lcm ( left_lcm , right_lcm ) ; } function query ( node , start , end , l , r ) { if ( end < l start > r ) return 1 ; if ( l <= start && r >= end ) return tree [ node ] ; let mid = Math . floor ( ( start + end ) / 2 ) ; let left_lcm = query ( 2 * node , start , mid , l , r ) ; let right_lcm = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return lcm ( left_lcm , right_lcm ) ; } arr [ 0 ] = 5 ; arr [ 1 ] = 7 ; arr [ 2 ] = 5 ; arr [ 3 ] = 2 ; arr [ 4 ] = 10 ; arr [ 5 ] = 12 ; arr [ 6 ] = 11 ; arr [ 7 ] = 17 ; arr [ 8 ] = 14 ; arr [ 9 ] = 1 ; arr [ 10 ] = 44 ; build ( 1 , 0 , 10 ) ; document . write ( query ( 1 , 0 , 10 , 2 , 5 ) + \" \" ) ; document . write ( query ( 1 , 0 , 10 , 5 , 10 ) + \" \" ) ; document . write ( query ( 1 , 0 , 10 , 0 , 10 ) + \" \" ) ;"}
{"text": "Kira penyahkodan mungkin urutan digit yang diberikan dengan aksara tersembunyi | Program JavaScript untuk pendekatan di atas; Semak watak pertama rentetan jika ' *' maka 9 cara; melintasi rentetan; Jika s [i] = = ' *' boleh ada 9 nilai yang mungkin *; Jika watak sebelumnya adalah 1 maka perkataan yang boleh dibentuk adalah k (11), l (12), m (13), n (14) o (15), p (16), q (17), r (18), s (19); Jika watak sebelumnya adalah 2 maka kata -kata yang boleh dibentuk ialah u (21), v (22), w (23), x (24) y (25), z (26); Jika digit sebelumnya * maka semua 15 2 - aksara digit boleh dibentuk; mengambil nilai dari langkah sebelumnya; Jika watak sebelumnya adalah 1 maka watak I - 1 dan watak itu boleh dikodkan dalam satu watak oleh itu, menambah DP [i - 1]. ; Jika watak sebelumnya adalah 2 dan watak ith kurang daripada 6 maka watak I - 1 dan watak ith boleh dikodkan dalam satu watak oleh itu, menambah DP [i - 1]. ; Jika watak sebelumnya * maka ia akan mengandungi 2 kes di atas; Kod pemacu", "code": "let M = 1000000007 ; function waysOfDecoding ( s ) { let dp = new Array ( s . length + 1 ) ; for ( let i = 0 ; i < s . length + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' ' ? 9 : s [ 0 ] == ' ' ? 0 : 1 ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != ' ' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' && s [ i ] <= ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= ' ' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ s . length ] ; } let s = \" \" ; document . write ( waysOfDecoding ( s ) ) ;"}
{"text": "Kira cara untuk memecah array ke dalam dua subset yang mempunyai perbezaan antara jumlah mereka sama dengan k | Fungsi untuk mengira bilangan cara untuk membahagikan array ke dalam dua subset dan sedemikian rupa sehingga perbezaan antara jumlah mereka adalah sama dengan perbezaan; Simpan jumlah set S1; Memulakan matriks int t [n + 1] [jumlah + 1]; ; Bilangan cara untuk mendapatkan jumlah menggunakan 0 elemen adalah 0; Bilangan cara untuk mendapatkan jumlah 0 menggunakan elemen i adalah 1; Melintasi array 2D; Jika nilai lebih besar daripada jumlah menyimpan nilai keadaan sebelumnya; Mengembalikan hasilnya; Diberikan input; Panggilan fungsi", "code": "function countSubset ( arr , n , diff ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum += diff ; sum = sum / 2 ; var t = new Array ( n + 1 ) ; for ( var i = 0 ; i < t . length ; i ++ ) { t [ i ] = new Array ( sum + 1 ) ; } for ( var i = 0 ; i < t . length ; i ++ ) { for ( var j = 0 ; j < t [ i ] . length ; j ++ ) { t [ i ] [ j ] = 0 ; } } for ( var j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( var i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; } var diff = 1 ; var n = 4 ; var arr = [ 1 , 1 , 2 , 3 ] ; document . write ( countSubset ( arr , n , diff ) ) ;"}
{"text": "Kebarangkalian bahawa jumlah semua nombor yang diperolehi membuang dadu n kali terletak di antara dua bilangan bulat yang diberikan | Program JavaScript pendekatan di atas; Fungsi untuk mengira kebarangkalian bahawa jumlah nombor pada n lontaran dadu terletak di antara a dan b; Kes asas; Tambah kebarangkalian untuk semua nombor antara A dan B; Kod pemacu; Cetak jawapannya", "code": "let dp = new Array ( 105 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < dp . length ; i ++ ) { for ( var j = 0 ; j < dp . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } } function find ( N , a , b ) { let probability = 0.0 ; for ( let i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = ( 1.0 / 6 ) ; for ( let i = 2 ; i <= N ; i ++ ) { for ( let j = i ; j <= 6 * i ; j ++ ) { for ( let k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } } for ( let sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; } let N = 4 , a = 13 , b = 17 ; let probability = find ( N , a , b ) ; document . write ( probability ) ;"}
{"text": "Jumlah maksimum dari pokok dengan tahap bersebelahan tidak dibenarkan | Kelas nod pokok untuk perwakilan pokok binari; Fungsi rekursif untuk mencari jumlah maksimum yang dikembalikan untuk nod akar dan cucunya; Mengembalikan jumlah maksimum dengan tahap bersebelahan tidak dibenarkan. Fungsi ini terutamanya menggunakan getSumalternate (); Kami mengira jumlah tahap alternatif bermula tahap pertama dan dari tahap kedua. Dan kembali maksimum dua nilai. ; Kod pemacu", "code": "class Node { constructor ( data ) { this . data = data ; this . left = this . right = null ; } } function getSumAlternate ( root ) { if ( root == null ) return 0 ; let sum = root . data ; if ( root . left != null ) { sum += getSum ( root . left . left ) ; sum += getSum ( root . left . right ) ; } if ( root . right != null ) { sum += getSum ( root . right . left ) ; sum += getSum ( root . right . right ) ; } return sum ; } function getSum ( root ) { if ( root == null ) return 0 ; return Math . max ( getSumAlternate ( root ) , ( getSumAlternate ( root . left ) + getSumAlternate ( root . right ) ) ) ; } let root = new Node ( 1 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 3 ) ; root . right . left = new Node ( 4 ) ; root . right . left . right = new Node ( 5 ) ; root . right . left . right . left = new Node ( 6 ) ; document . write ( getSum ( root ) ) ;"}
{"text": "Subset Jumlah Masalah di O (SUM) Ruang | Pulangan benar jika terdapat subset dengan jumlah yang diberikan dalam arr []; Nilai subset [i % 2] [j] akan benar jika terdapat subset jumlah J dalam arr [0, 1, .... , i - 1]; Subset dengan jumlah 0 selalu mungkin; Sekiranya tidak ada unsur tidak ada jumlah yang mungkin; Program Pemandu", "code": "function isSubsetSum ( arr , n , sum ) { let subset = new Array ( 2 ) ; for ( var i = 0 ; i < subset . length ; i ++ ) { subset [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; } let arr = [ 1 , 2 , 5 ] ; let sum = 7 ; let n = arr . length ; if ( isSubsetSum ( arr , n , sum ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text": "Sum maksimum equlibrium dalam array | Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Kod pemacu", "code": "function findMaxSum ( arr , n ) { var res = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { var prefix_sum = arr [ i ] ; for ( var j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; var suffix_sum = arr [ i ] ; for ( var j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; } var arr = [ - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 ] ; var n = arr . length ; document . write ( findMaxSum ( arr , n ) ) ;"}
{"text": "Sum maksimum equlibrium dalam array | Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Array to Store Prefix Sum. ; Array untuk menyimpan jumlah akhiran. ; Pembolehubah untuk menyimpan jumlah maksimum. ; Kirakan jumlah awalan. ; Kirakan jumlah akhiran dan bandingkan dengan jumlah awalan. Kemas kini Ans dengan sewajarnya. ; Kod pemacu", "code": "function findMaxSum ( arr , n ) { let preSum = new Array ( n ) ; preSum . fill ( 0 ) ; let suffSum = new Array ( n ) ; suffSum . fill ( 0 ) ; let ans = Number . MIN_VALUE ; preSum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; } let arr = [ - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 ] ; let n = arr . length ; document . write ( findMaxSum ( arr , n ) ) ;"}
{"text": "Elemen Majoriti | Berfungsi untuk mencari elemen majoriti dalam array; sentinel; Kemas kini MaxCount jika kiraan elemen semasa lebih besar; Jika MaxCount lebih besar daripada n / 2 mengembalikan elemen yang sepadan; Kod pemacu; Fungsi panggilan", "code": "function findMajority ( arr , n ) { let maxCount = 0 ; let index = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) document . write ( arr [ index ] ) ; else document . write ( \" \" ) ; } let arr = [ 1 , 1 , 2 , 1 , 3 , 5 , 1 ] ; let n = arr . length ; findMajority ( arr , n ) ;"}
{"text": "Elemen Majoriti | Berfungsi untuk mencari calon untuk majoriti; Berfungsi untuk memeriksa sama ada calon berlaku lebih daripada n / 2 kali; Berfungsi untuk mencetak elemen majoriti; Cari calon untuk majoriti; Cetak calon jika ia adalah majoriti; Kod pemacu; Panggilan fungsi", "code": "function findCandidate ( a , size ) { let maj_index = 0 , count = 1 ; let i ; for ( i = 1 ; i < size ; i ++ ) { if ( a [ maj_index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj_index = i ; count = 1 ; } } return a [ maj_index ] ; } function isMajority ( a , size , cand ) { let i , count = 0 ; for ( i = 0 ; i < size ; i ++ ) { if ( a [ i ] == cand ) count ++ ; } if ( count > parseInt ( size / 2 , 10 ) ) return true ; else return false ; } function printMajority ( a , size ) { let cand = findCandidate ( a , size ) ; if ( isMajority ( a , size , cand ) ) document . write ( \" \" + cand + \" \" ) ; else document . write ( \" \" ) ; } let a = [ 1 , 3 , 3 , 1 , 2 ] ; let size = a . length ; printMajority ( a , size ) ;"}
{"text": "Elemen Majoriti | Fungsi untuk mencari elemen majoriti dalam array ia kembali - 1 jika tidak ada unsur majoriti; Susun array dalam O (nlogn); Meningkatkan kiraan jika elemen yang sama berlaku sebaliknya mula mengira elemen baru; Menetapkan kiraan maksimum dan menyimpan elemen maksimum yang berlaku setakat ini jika kiraan maksimum menjadi lebih besar daripada n / 2 ia memecahkan penetapan bendera; Mengembalikan elemen maksimum yang berlaku jika tidak ada elemen sedemikian, pulangan - 1; Kod pemacu; Fungsi panggilan", "code": "function majorityElement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 1 , max_ele = - 1 , temp = arr [ 0 ] , ele = 0 , f = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > parseInt ( n / 2 , 10 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : - 1 ) ; } let arr = [ 1 , 1 , 2 , 1 , 3 , 5 , 1 ] ; let n = 7 ; document . write ( majorityElement ( arr , n ) ) ;"}
{"text": "Pengaturcaraan Dinamik | Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara bawah; Uncomment Kod ini untuk mencetak jadual; Kod pemacu", "code": "function isSubsetSum ( set , n , sum ) { let subset = new Array ( sum + 1 ) ; for ( let i = 0 ; i < sum + 1 ; i ++ ) { subset [ i ] = new Array ( sum + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { subset [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ; for ( let i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ; for ( let i = 1 ; i <= sum ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } } for ( int i = 0 ; i <= sum ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) System . out . println ( subset [ i ] [ j ] ) ; } return subset [ sum ] [ n ] ; } let set = [ 3 , 34 , 4 , 12 , 5 , 2 ] ; let sum = 9 ; let n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text": "Pengaturcaraan Dinamik | Semak jika boleh subset dengan jumlah yang diberikan adalah mungkin atau tidak; Sekiranya jumlahnya adalah sifar, ia bermakna kami mendapat jumlah yang diharapkan; Jika nilai tidak - 1 ia bermakna ia sudah memanggil fungsi dengan nilai yang sama. Ia akan menyelamatkan kami dari pengulangan. ; Jika nilai A [n - 1] lebih besar daripada jumlahnya. Kami memanggil nilai seterusnya; Di sini kita melakukan dua panggilan kerana kita tidak tahu apa -apa yang akan dipenuhi oleh kami. Kod pemacu", "code": "function subsetSum ( a , n , sum ) { if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ; if ( tab [ n - 1 ] [ sum ] != - 1 ) return tab [ n - 1 ] [ sum ] ; if ( a [ n - 1 ] > sum ) return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) ; else { return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) ; } } let tab = Array ( 2000 ) . fill ( ) . map ( ( ) => Array ( 2000 ) . fill ( - 1 ) ) ; let n = 5 ; let a = [ 1 , 5 , 3 , 7 , 4 ] ; let sum = 12 ; if ( subsetSum ( a , n , sum ) ) { document . write ( \" \" + \" \" ) ; } else { document . write ( \" \" + \" \" ) ; }"}
{"text": "Jumlah perbezaan bit untuk nombor dari 0 hingga n | Berfungsi untuk melaksanakan eksponensi cepat; Berfungsi untuk mengembalikan nilai untuk kuasa 2; Berfungsi untuk menukar n ke dalam binari; Untuk menyimpan perwakilan binari; Melepasi setiap digit n; Mengembalikan perwakilan binari; Berfungsi untuk mencari perbezaan bit; Dapatkan perwakilan binari; Jumlah bilangan perbezaan bit dari 0 hingga n; Melangkah ke atas setiap bit binari; Jika bit semasa adalah '1' kemudian tambahkan kiraan bit semasa; Nombor yang diberikan; Panggilan fungsi", "code": "function binpow ( a , b ) { let res = 1 ; while ( b ) { if ( b & 1 ) res = res * a ; a = a * a ; b = Math . floor ( b / 2 ) ; } return res ; } function find ( x ) { if ( x == 0 ) return 0 ; let p = Math . log2 ( x ) ; return binpow ( 2 , p + 1 ) - 1 ; } function getBinary ( n ) { let ans = \" \" ; while ( n ) { let dig = n % 2 ; ans += String ( dig ) ; n = Math . floor ( n / 2 ) ; } return ans ; } function totalCountDifference ( n ) { let ans = getBinary ( n ) ; let req = 0 ; for ( let i = 0 ; i < ans . length ; i ++ ) { if ( ans [ i ] == ' ' ) { req += find ( binpow ( 2 , i ) ) ; } } return req ; } let N = 5 ; document . write ( totalCountDifference ( N ) ) ;"}
{"text": "Cari panjang maksimum awalan | Berfungsi untuk mengembalikan panjang maksimum awalan yang diperlukan; Array untuk menyimpan kekerapan setiap elemen array; Melangkah untuk semua elemen; Kemas kini kekerapan elemen semasa i. e. v; Disusun nilai positif dari array Count; Jika awalan semasa memenuhi syarat yang diberikan; Mengembalikan panjang maksimum; Kod pemacu", "code": "function Maximum_Length ( a ) { let counts = new Array ( 11 ) ; counts . fill ( 0 ) ; let ans = 0 ; for ( let index = 0 ; index < a . length ; index ++ ) { counts [ a [ index ] ] += 1 ; let k = [ ] ; for ( let i = 0 ; i < counts . length ; i ++ ) { if ( counts [ i ] != 0 ) { k . push ( i ) ; } } k . sort ( function ( a , b ) { return a - b } ) ; if ( k . length == 1 || ( k [ 0 ] == k [ k . length - 2 ] && k [ k . length - 1 ] - k [ k . length - 2 ] == 1 ) || ( k [ 0 ] == 1 && k [ 1 ] == k [ k . length - 1 ] ) ) ans = index ; } return ( ans ) ; } let a = [ 1 , 1 , 1 , 2 , 2 , 2 ] ; document . write ( Maximum_Length ( a ) ) ;"}
{"text": "Pertanyaan dalam talian untuk GCD Array Selepas Membahagikan Operasi | Mengembalikan GCD selepas semua kemas kini dalam array; Fungsi untuk mengira GCD pertanyaan onine; menyimpan GCD elemen array awal; mengira GCD; melakukan pertanyaan dalam talian; Indeks adalah 1 berdasarkan; Bahagikan elemen array; mengira GCD semasa; Cetak GCD selepas setiap langkah; Kod pemacu", "code": "function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function print_gcd_online ( n , m , query , arr ) { let max_gcd = 0 ; let i = 0 ; for ( i = 0 ; i < n ; i ++ ) max_gcd = gcd ( max_gcd , arr [ i ] ) ; for ( i = 0 ; i < m ; i ++ ) { query [ i ] [ 0 ] -- ; arr [ query [ i ] [ 0 ] ] /= query [ i ] [ 1 ] ; max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) ; document . write ( max_gcd + \" \" ) ; } } let n = 3 ; let m = 3 ; let query = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { query [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { query [ i ] [ j ] = 0 ; } } let arr = [ 36 , 24 , 72 ] ; query [ 0 ] [ 0 ] = 1 ; query [ 0 ] [ 1 ] = 3 ; query [ 1 ] [ 0 ] = 3 ; query [ 1 ] [ 1 ] = 12 ; query [ 2 ] [ 0 ] = 2 ; query [ 2 ] [ 1 ] = 4 ; print_gcd_online ( n , m , query , arr ) ;"}
{"text": "Nombor dalam julat [l, r] supaya kiraan pembahagi mereka adalah kedua -duanya dan perdana | Pelaksanaan JavaScript pendekatan; Kedai sama ada nombor itu adalah perdana atau tidak; menyimpan kiraan nombor perdana kurang daripada atau sama dengan indeks; buat penapis; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaan sebagai benar. Nilai dalam perdana [i] akhirnya akan palsu jika 'i' bukanlah perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; menyimpan jumlah awalan bilangan prima kurang daripada atau sama dengan 'i'; buat penapis; 'l' dan 'r' adalah batas bawah dan atas julat; Dapatkan nilai kiraan; Paparkan kiraan", "code": "var MAX = 1000000 ; var prime = Array ( MAX + 1 ) . fill ( true ) ; var sum = Array ( MAX + 1 ) . fill ( 0 ) ; function SieveOfEratosthenes ( ) { prime [ 1 ] = false ; for ( var p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( var i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( var i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } } SieveOfEratosthenes ( ) ; var l = 3 , r = 9 ; var c = ( sum [ r ] - sum [ l - 1 ] ) ; document . write ( \" \" + c ) ;"}
{"text": "Kawasan bulatan yang ditulis dalam segi empat tepat yang tertulis dalam separuh bulatan | Berfungsi untuk mencari kawasan bulatan; Radius tidak boleh negatif; kawasan bulatan; Kod pemacu", "code": "function area ( r ) { if ( r < 0 ) return - 1 ; var area = ( 3.14 * Math . pow ( r / ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; } var a = 5 ; document . write ( area ( a ) . toFixed ( 6 ) ) ;"}
{"text": "Cari kiraan nombor hampir perdana dari 1 hingga n | Program JavaScript untuk mengira hampir nombor utama dari 1 hingga N; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Fungsi untuk mengira hampir nombor utama dari 1 hingga n; untuk menyimpan jawapan yang diperlukan; 6 adalah nombor hampir perdana pertama; untuk mengira faktor utama; Jika ia sempurna persegi; Sekiranya saya hampir nombor utama; Kod pemacu", "code": "let N = 100005 ; let prime = new Array ( N ) . fill ( true ) ; function SieveOfEratosthenes ( ) { prime [ 1 ] = false ; for ( let p = 2 ; p < Math . floor ( Math . sqrt ( N ) ) ; p ++ ) { if ( prime [ p ] == true ) for ( let i = 2 * p ; i < N ; i += p ) prime [ i ] = false ; } } function almostPrimes ( n ) { let ans = 0 ; for ( let i = 6 ; i < n + 1 ; i ++ ) { let c = 0 ; for ( let j = 2 ; i >= j * j ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) { if ( prime [ j ] ) c += 1 ; } else { if ( prime [ j ] ) c += 1 ; if ( prime [ ( i / j ) ] ) c += 1 ; } } } if ( c == 2 ) ans += 1 ; } return ans ; } SieveOfEratosthenes ( ) ; let n = 21 ; document . write ( almostPrimes ( n ) ) ;"}
{"text": "Bahagikan nombor menjadi dua bahagian supaya jumlah digit adalah maksimum | Mengembalikan jumlah digit X; Mengembalikan nombor terdekat kepada X dari segi 9. ; Kod pemacu", "code": "function sumOfDigitsSingle ( x ) { let ans = 0 ; while ( x ) { ans += x % 10 ; x = Math . floor ( x / 10 ) ; } return ans ; } function closest ( x ) { let ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; } function sumOfDigitsTwoParts ( N ) { let A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; } let N = 35 ; document . write ( sumOfDigitsTwoParts ( N ) ) ;"}
{"text": "Ujian Primal | Tetapkan 5 (menggunakan Lucas | berfungsi untuk memeriksa sama ada (2 ^ p - 1) adalah perdana atau tidak., Menjana nombor; nombor pertama siri; menghasilkan yang lain (p - 2) syarat -syarat siri.", "code": "function isPrime ( p ) { let checkNumber = Math . pow ( 2 , p ) - 1 ; let nextval = 4 % checkNumber ; for ( let i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; } let p = 7 ; let checkNumber = Math . pow ( 2 , p ) - 1 ; if ( isPrime ( p ) ) document . write ( checkNumber + \" \" ) ; else document . write ( checkNumber + \" \" ) ;"}
{"text": "Sophie Germain Prime | Fungsi untuk mengesan nombor perdana di sini kami telah menggunakan kaedah penapis https: www. Geeksforgeeks. org / sieve - of - eratosthenes / untuk mengesan nombor perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Kami telah membuat array sehingga 2 * n + 1 supaya kami dapat memeriksa nombor perdana sehingga itu dan menyimpulkan tentang Sophie Jerman Prime. ; Memeriksa setiap saya sama ada Sophie Jerman Perdana atau tidak. ; Kod pemacu", "code": "function sieve ( n , prime ) { for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } function printSophieGermanNumber ( n ) { let prime = new Array ( ) ; for ( let i = 0 ; i < ( 2 * n + 1 ) ; i ++ ) prime [ i ] = true ; sieve ( 2 * n + 1 , prime ) ; for ( let i = 2 ; i <= n ; ++ i ) { if ( prime [ i ] && prime [ 2 * i + 1 ] ) document . write ( i + \" \" ) ; } } let n = 25 ; printSophieGermanNumber ( n ) ;"}
{"text": "Interpolasi Bessel | Mengira anda disebut dalam formula; Mengira faktorial nombor n; Bilangan nilai yang diberikan; y digunakan untuk jadual perbezaan dengan y [0] digunakan untuk input; Mengira jadual perbezaan pusat; Memaparkan jadual perbezaan pusat; Nilai untuk interpolasi pada; Memulakan u dan jumlah; k ialah asalnya ialah F (0); Asal untuk ganjil; Asal untuk walaupun; Menyelesaikan menggunakan formula Bessel", "code": "function ucal ( u , n ) { if ( n == 0 ) return 1 ; var temp = u ; for ( var i = 1 ; i <= n / 2 ; i ++ ) temp = temp * ( u - i ) ; for ( var i = 1 ; i < n / 2 ; i ++ ) temp = temp * ( u + i ) ; return temp ; } function fact ( n ) { var f = 1 ; for ( var i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } var n = 6 ; var x = [ 25 , 26 , 27 , 28 , 29 , 30 ] ; var y = Array ( n ) . fill ( 0.0 ) . map ( x => Array ( n ) . fill ( 0.0 ) ) ; ; y [ 0 ] [ 0 ] = 4.000 ; y [ 1 ] [ 0 ] = 3.846 ; y [ 2 ] [ 0 ] = 3.704 ; y [ 3 ] [ 0 ] = 3.571 ; y [ 4 ] [ 0 ] = 3.448 ; y [ 5 ] [ 0 ] = 3.333 ; for ( var i = 1 ; i < n ; i ++ ) for ( var j = 0 ; j < n - i ; j ++ ) y [ j ] [ i ] = y [ j + 1 ] [ i - 1 ] - y [ j ] [ i - 1 ] ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n - i ; j ++ ) document . write ( y [ i ] [ j ] . toFixed ( 6 ) + \" \" ) ; document . write ( ' ' ) ; } var value = 27.4 ; var sum = ( y [ 2 ] [ 0 ] + y [ 3 ] [ 0 ] ) / 2 ; var k ; if ( ( n % 2 ) > 0 ) k = n / 2 ; else k = n / 2 - 1 ; var u = ( value - x [ k ] ) / ( x [ 1 ] - x [ 0 ] ) ; for ( var i = 1 ; i < n ; i ++ ) { if ( ( i % 2 ) > 0 ) sum = sum + ( ( u - 0.5 ) * ucal ( u , i - 1 ) * y [ k ] [ i ] ) / fact ( i ) ; else sum = sum + ( ucal ( u , i ) * ( y [ k ] [ i ] + y [ -- k ] [ i ] ) / ( fact ( i ) * 2 ) ) ; } document . write ( \" \" + value . toFixed ( 6 ) + \" \" + sum . toFixed ( 6 ) ) ;"}
{"text": "Cara yang cekap untuk memeriksa sama ada N | Program JavaScript yang mudah untuk memeriksa sama ada nombor Fibonacci N - Th adalah berbilang daripada 10 .; Pulangan benar jika nombor fibonacci n - th adalah berganda dari 10 .; Kod pemacu", "code": "function fibonacci ( n ) { let a = 0 ; let b = 1 ; let c ; if ( n <= 1 ) return n ; for ( let i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; } function isMultipleOf10 ( n ) { let f = fibonacci ( 30 ) ; return ( f % 10 == 0 ) ; } let n = 30 ; if ( isMultipleOf10 ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 | Fungsi yang memeriksa sama ada nombor adalah kuasa 2; Kes asas '1' adalah satu -satunya nombor ganjil yang merupakan kuasa 2 (2 ^ 0); Semua nombor ganjil yang lain bukan kuasa 2; panggilan fungsi rekursif; Benar; Palsu", "code": "function powerOf2 ( n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } var n = 64 ; var m = 12 ; if ( powerOf2 ( n ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ; if ( powerOf2 ( m ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 | Kaedah untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Kaedah Pemandu", "code": "function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; } document . write ( isPowerOfTwo ( 31 ) ? \" \" : \" \" ) ; document . write ( \" \" + ( isPowerOfTwo ( 64 ) ? \" \" : \" \" ) ) ;"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 | Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "function isPowerofTwo ( n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; } if ( isPowerofTwo ( 30 ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ; if ( isPowerofTwo ( 128 ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Kuasa terkecil 2 yang lebih besar daripada atau sama dengan jumlah unsur array | Berfungsi untuk mencari kuasa terdekat 2; Nombornya; Jika sudah menjadi kuasa 2; Cari kuasa seterusnya 2; Berfungsi untuk mencari memori yang digunakan; Jumlah array; Melintasi dan mencari jumlah array; Fungsi panggilan untuk mencari kuasa terdekat 2; Kod pemacu", "code": "function nextPowerOf2 ( n ) { let p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } function memoryUsed ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; let nearest = nextPowerOf2 ( sum ) ; return nearest ; } let arr = [ 1 , 2 , 3 , 2 ] ; let n = arr . length ; document . write ( memoryUsed ( arr , n ) ) ;"}
{"text": "Toggling k | Program JavaScript ke TOOGLE K - TH bit nombor; Kod pemacu", "code": "function toggleKthBit ( n , k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; } let n = 5 , k = 1 ; document . write ( toggleKthBit ( n , k ) ) ;"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Program JavaScript untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Pertama n dalam keadaan di bawah adalah untuk kes di mana n adalah 0; Kod pemacu", "code": "function nextPowerOf2 ( n ) { var count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } var n = 0 ; document . write ( nextPowerOf2 ( n ) ) ;"}
{"text": "Nombor kth dari set gandaan nombor A, B dan C | Berfungsi untuk mengembalikan GCD A dan B; Berfungsi untuk mengembalikan LCM A dan B; Berfungsi untuk mengembalikan elemen kth dari set yang diperlukan jika ia berganda A; Mula dan tamat untuk carian binari; Jika tiada jawapan yang dijumpai kembali - 1; Kemasukan dan pengecualian; Pelbagai harus lebih kecil; Pelbagai harus lebih besar; Berfungsi untuk mengembalikan elemen kth dari set yang diperlukan jika ia berbilang b; Mula dan tamat untuk carian binari; Jika tiada jawapan yang dijumpai kembali - 1; Kemasukan dan pengecualian; Pelbagai harus lebih kecil; Pelbagai harus lebih besar; Berfungsi untuk mengembalikan elemen kth dari set yang diperlukan jika ia berbilang C; Mula dan tamat untuk carian binari; Jika tiada jawapan yang dijumpai kembali - 1; Kemasukan dan pengecualian; Pelbagai harus lebih kecil; Pelbagai harus lebih besar; Berfungsi untuk mengembalikan elemen KTH dari set gandaan A, B dan C; Memohon carian binari pada gandaan A; Sekiranya elemen yang diperlukan bukanlah pelbagai A maka gandaan B dan C perlu diperiksa; Sekiranya elemen yang diperlukan bukanlah pelbagai atau pelbagai b maka gandaan C perlu diperiksa; Kod pemacu", "code": "function gcd ( A , B ) { if ( B === 0 ) return A ; return gcd ( B , A % B ) ; } function lcm ( A , B ) { return ( A * B ) / gcd ( A , B ) ; } function checkA ( A , B , C , K ) { var start = 1 ; var end = K ; var ans = - 1 ; while ( start <= end ) { var mid = parseInt ( ( start + end ) / 2 ) ; var value = A * mid ; var divA = mid - 1 ; var divB = parseInt ( value % B === 0 ? value / B - 1 : value / B ) ; var divC = parseInt ( value % C === 0 ? value / C - 1 : value / C ) ; var divAB = parseInt ( value % lcm ( A , B ) === 0 ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ) ; var divBC = parseInt ( value % lcm ( C , B ) === 0 ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ) ; var divAC = parseInt ( value % lcm ( A , C ) === 0 ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ) ; var divABC = parseInt ( value % lcm ( A , lcm ( B , C ) ) === 0 ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ) ; var elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem === K - 1 ) { ans = value ; break ; } else if ( elem > K - 1 ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } function checkB ( A , B , C , K ) { var start = 1 ; var end = K ; var ans = - 1 ; while ( start <= end ) { var mid = parseInt ( ( start + end ) / 2 ) ; var value = B * mid ; var divB = mid - 1 ; var divA = parseInt ( value % A === 0 ? value / A - 1 : value / A ) ; var divC = parseInt ( value % C === 0 ? value / C - 1 : value / C ) ; var divAB = parseInt ( value % lcm ( A , B ) === 0 ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ) ; var divBC = parseInt ( value % lcm ( C , B ) === 0 ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ) ; var divAC = parseInt ( value % lcm ( A , C ) === 0 ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ) ; var divABC = parseInt ( value % lcm ( A , lcm ( B , C ) ) === 0 ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ) ; var elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem === K - 1 ) { ans = value ; break ; } else if ( elem > K - 1 ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } function checkC ( A , B , C , K ) { var start = 1 ; var end = K ; var ans = - 1 ; while ( start <= end ) { var mid = parseInt ( ( start + end ) / 2 ) ; var value = C * mid ; var divC = mid - 1 ; var divB = parseInt ( value % B === 0 ? value / B - 1 : value / B ) ; var divA = parseInt ( value % A === 0 ? value / A - 1 : value / A ) ; var divAB = parseInt ( value % lcm ( A , B ) === 0 ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ) ; var divBC = parseInt ( value % lcm ( C , B ) === 0 ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ) ; var divAC = parseInt ( value % lcm ( A , C ) === 0 ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ) ; var divABC = parseInt ( value % lcm ( A , lcm ( B , C ) ) === 0 ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ) ; var elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem === K - 1 ) { ans = value ; break ; } else if ( elem > K - 1 ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } function findKthMultiple ( A , B , C , K ) { var res = checkA ( A , B , C , K ) ; console . log ( res ) ; if ( res === - 1 ) res = checkB ( A , B , C , K ) ; if ( res === - 1 ) res = checkC ( A , B , C , K ) ; return res ; } var A = 2 , B = 4 , C = 5 , K = 5 ; document . write ( findKthMultiple ( A , B , C , K ) ) ;"}
{"text": "Tambah elemen dalam mula menyusun array | Variasi Stalin Sort | Berfungsi untuk menyusun array; Iterator <Integer> index = arr. iterator (); ; Kod pemacu; Panggilan fungsi", "code": "function variationStalinsort ( arr ) { let j = 0 ; while ( true ) { let moved = 0 ; for ( let i = 0 ; i < ( arr . length - 1 - j ) ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { let index ; let temp ; index = arr [ i ] ; temp = arr [ i + 1 ] ; arr . splice ( i , 1 ) ; arr . splice ( i , 0 , temp ) ; arr [ i ] = temp ; arr . splice ( i + 1 , 1 ) ; arr . splice ( i + 1 , 0 , index ) arr [ i + 1 ] = index ; moved ++ ; } } j ++ ; if ( moved == 0 ) { break ; } } document . write ( \" \" + arr + \" \" ) ; } let arr = [ 2 , 1 , 4 , 3 , 6 , 5 , 8 , 7 , 10 , 9 ] ; let arr1 = [ ] ; for ( let i = 0 ; i < arr . length ; i ++ ) arr1 . push ( arr [ i ] ) ; variationStalinsort ( arr1 ) ;"}
{"text": "Susun array yang mengandungi nilai 1 hingga n dalam o (n) menggunakan jenis kitaran | Berfungsi untuk mencetak elemen array; Melintasi array; Berfungsi untuk menyusun array dalam O (n); Melintasi array; Jika elemen semasa berada pada kedudukan yang betul; Lain menukar elemen semasa dengan kedudukan yang betul; Swap nilai arr [i] dan arr [arr [i] - 1]; Kod pemacu; Fungsi panggilan untuk menyusun array; Fungsi panggilan untuk mencetak array", "code": "function printArray ( arr , N ) { for ( var i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + ' ' ) ; } } function sortArray ( arr , N ) { for ( var i = 0 ; i < N ; ) { if ( arr [ i ] == i + 1 ) { i ++ ; } else { var temp1 = arr [ i ] ; var temp2 = arr [ arr [ i ] - 1 ] ; arr [ i ] = temp2 ; arr [ temp1 - 1 ] = temp1 ; } } } var arr = [ 2 , 1 , 5 , 3 , 4 ] ; var N = arr . length ; sortArray ( arr , N ) ; printArray ( arr , N ) ;"}
{"text": "Jumlah maksimum nilai n item dalam 0 | Berfungsi untuk mencari nilai maksimum; keadaan asas; Unsur k telah dikurangkan kepada separuh daripada berat badan mereka; Jangan sertakan item; Jika berat item kurang daripada atau sama dengan berat yang tinggal maka masukkan item; Mengembalikan maksimum kedua -dua kes; Jika pengurangan berat badan kepada separuh mungkin; Langkau item; Sertakan item dengan berat penuh jika berat item kurang daripada berat badan yang tinggal; Sertakan item dengan separuh berat jika separuh berat item kurang daripada berat badan yang tinggal; Mengembalikan maksimum semua 3 kes; Kod pemacu", "code": "function maximum ( value , weight , weight1 , flag , K , index ) { if ( index >= value . length ) { return 0 ; } if ( flag == K ) { var skip = maximum ( value , weight , weight1 , flag , K , index + 1 ) ; var full = 0 ; if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 ) ; } return Math . max ( full , skip ) ; } else { var skip = maximum ( value , weight , weight1 , flag , K , index + 1 ) ; var full = 0 ; var half = 0 ; if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 ) ; } if ( weight [ index ] / 2 <= weight1 ) { half = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] / 2 , flag , K , index + 1 ) ; } return Math . max ( full , Math . max ( skip , half ) ) ; } } var value = [ 17 , 20 , 10 , 15 ] ; var weight = [ 4 , 2 , 7 , 5 ] ; var K = 1 ; var W = 4 ; document . write ( maximum ( value , weight , W , 0 , K , 0 ) ) ;"}
{"text": "D | Program JavaScript untuk mencari saiz set dominasi minimum pokok; Definisi nod pokok; Fungsi penolong yang memperuntukkan nod baru; Array DP untuk precompute dan menyimpan hasilnya; mindominatingsettion untuk mengembalikan saiz set dominasi minimum array; Kes asas; Menetapkan nilai wajib jika diperlukan; Semak sama ada jawapannya telah dikira; Jika ia adalah wajib untuk memilih nod; Pilih nod dan tetapkan anak -anaknya seperti yang dilindungi; Jika ia dilindungi; Sekiranya nod semasa tidak dilindungi atau tidak perlu dipilih secara paksa; Simpan hasilnya; Memulakan array DP; Membina pokok", "code": "let N = 1005 ; class Node { constructor ( data ) { this . left = null ; this . right = null ; this . data = data ; } } function newNode ( data ) { let node = new Node ( data ) ; return node ; } let dp = new Array ( N ) ; function minDominatingSet ( root , covered , compulsory ) { if ( root == null ) return 0 ; if ( root . left != null && root . right != null && covered > 0 ) compulsory = 1 ; if ( dp [ root . data ] [ covered ] [ compulsory ] != - 1 ) return dp [ root . data ] [ covered ] [ compulsory ] ; if ( compulsory > 0 ) { return dp [ root . data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; } if ( covered > 0 ) { return dp [ root . data ] [ covered ] [ compulsory ] = Math . min ( 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } let ans = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; if ( root . left != null ) { ans = Math . min ( ans , minDominatingSet ( root . left , 0 , 1 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } if ( root . right != null ) { ans = Math . min ( ans , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 1 ) ) ; } dp [ root . data ] [ covered ] [ compulsory ] = ans ; return dp [ root . data ] [ covered ] [ compulsory ] ; } for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( 5 ) ; for ( let j = 0 ; j < 5 ; j ++ ) { dp [ i ] [ j ] = new Array ( 5 ) ; for ( let l = 0 ; l < 5 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } let root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . left . left = newNode ( 3 ) ; root . left . right = newNode ( 4 ) ; root . left . left . left = newNode ( 5 ) ; root . left . left . left . left = newNode ( 6 ) ; root . left . left . left . right = newNode ( 7 ) ; root . left . left . left . right . right = newNode ( 10 ) ; root . left . left . left . left . left = newNode ( 8 ) ; root . left . left . left . left . right = newNode ( 9 ) ; document . write ( minDominatingSet ( root , 0 , 0 ) ) ;"}
{"text": "Bilangan subset dengan jumlah sifar |  ; pembolehubah untuk menyimpan negeri -negeri DP; Untuk mencari bilangan subset dengan jumlah yang sama dengan 0 kerana S boleh menjadi negatif, kami akan memaksimumkannya untuk menjadikannya positif; Kes asas; Mengembalikan nilai jika keadaan sudah diselesaikan; Jika Negeri tidak dikunjungi, maka teruskan; Hubungan berulang; Mengembalikan nilai; Fungsi pemacu", "code": "var maxSum = 100 var arrSize = 51 var dp = Array . from ( Array ( arrSize ) , ( ) => Array ( maxSum ) ) ; var visit = Array . from ( Array ( arrSize ) , ( ) => Array ( maxSum ) ) ; function SubsetCnt ( i , s , arr , n ) { if ( i == n ) { if ( s == 0 ) return 1 ; else return 0 ; } if ( visit [ i ] [ s + maxSum ] ) return dp [ i ] [ s + maxSum ] ; visit [ i ] [ s + maxSum ] = 1 ; dp [ i ] [ s + maxSum ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ; return dp [ i ] [ s + maxSum ] ; } var arr = [ 2 , 2 , 2 , - 4 , - 4 ] ; var n = arr . length ; document . write ( SubsetCnt ( 0 , 0 , arr , n ) ) ;"}
{"text": "Bilangan rentetan binari panjang n dengan k bit set bersebelahan | Program JavaScript untuk mencari bilangan rentetan bit panjang n dengan k bit set bersebelahan; Berfungsi untuk mencari bilangan rentetan bit panjang n dengan k bit set bersebelahan; Kes asas apabila kita membentuk rentetan panjang n; jika f (bit string) = k, hitung cara ini; Semak sama ada bit terakhir ditetapkan, jika ditetapkan maka hubungi indeks seterusnya dengan menambah kiraan bit bersebelahan lain, hubungi indeks seterusnya dengan nilai yang sama dari kiraan bit bersebelahan dan sama ada tetapkan bit pada indeks semasa atau biarkan ia tetap tidak tersembunyi; Tetapkan bit pada CurrentIndex; tidak jelas sedikit pada currentIndex; Kod pemacu; dp [i] [j] [k] mewakili rentetan panjang panjang i dengan f (bit string) = j dan bit terakhir sebagai k; memulakan DP; Jumlah cara = (cara dengan meletakkan bit 1 st 1 + cara dengan meletakkan bit 1 sebagai 0)", "code": "var MAX = 1000 ; function waysToKAdjacentSetBits ( dp , n , k , currentIndex , adjacentSetBits , lastBit ) { if ( currentIndex == n ) { if ( adjacentSetBits == k ) return 1 ; return 0 ; } if ( dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] != - 1 ) { return dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] ; } var noOfWays = 0 ; if ( lastBit == 1 ) { noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( ! lastBit ) { noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] = noOfWays ; return noOfWays ; } var n = 5 , k = 2 ; var dp = Array . from ( Array ( MAX ) , ( ) => Array ( MAX ) ) ; for ( var i = 0 ; i < MAX ; i ++ ) for ( var j = 0 ; j < MAX ; j ++ ) dp [ i ] [ j ] = new Array ( 2 ) . fill ( - 1 ) ; var totalWays = waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 0 ) ; document . write ( \" \" + totalWays + \" \" ) ;"}
{"text": "Nombor Tetranacci | Berfungsi untuk mencetak nombor tetranacci N - th; Memulakan empat nombor pertama untuk kes asas; mengisytiharkan pemboleh ubah semasa; Gelung untuk menambah empat nombor sebelumnya untuk setiap nombor bermula dari 4 dan kemudian berikan pertama, kedua, ketiga hingga kedua, ketiga, keempat dan curr masing -masing; Kod pemacu", "code": "function printTetra ( n ) { if ( n < 0 ) return ; var first = 0 , second = 1 ; var third = 1 , fourth = 2 ; var curr ; if ( n == 0 ) cout << first ; else if ( n == 1 n == 2 ) cout << second ; else if ( n == 3 ) cout << fourth ; else { for ( var i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } document . write ( curr ) ; } } var n = 10 ; printTetra ( n ) ;"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Fungsi rekursif yang digunakan oleh Countways; Kod pemacu", "code": "function countWays ( n ) { let res = new Array ( n + 2 ) ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( let i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; } let n = 4 ; document . write ( countWays ( n ) ) ;"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Fungsi rekursif yang digunakan oleh Countways; Mengisytiharkan tiga pembolehubah dan memegang cara untuk tiga tangga pertama; Pemboleh ubah keempat; Bermula dari 4 seperti yang telah dikira untuk 3 tangga; Kod pemacu", "code": "function countWays ( n ) { var a = 1 , b = 2 , c = 4 ; var d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( var i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; } var n = 4 ; document . write ( countWays ( n ) ) ;"}
{"text": "Subset Jumlah Masalah di O (SUM) Ruang |  ; Memulakan dengan 1 sebagai jumlah 0 selalu mungkin; gelung untuk melalui setiap elemen array elemen; untuk menukar nilai semua nilai jumlah yang mungkin kepada 1; jika jumlahnya mungkin kemudian kembali 1; Kod pemacu", "code": "function isPossible ( elements , sum ) { var dp = [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( var i = 0 ; i < elements . length ; i ++ ) { for ( var j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; } var elements = [ 6 , 2 , 5 ] ; var sum = 7 ; if ( isPossible ( elements , sum ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Pengaturcaraan Dinamik | Tinggi | Mengembalikan jumlah tugas maksimum yang boleh dilakukan sehingga hari n; Jika n kurang daripada sama dengan 0, maka tiada penyelesaian wujud; Menentukan tugas mana yang hendak dipilih pada hari n, kemudian mengembalikan maksimum sehingga hari itu; Kod pemacu", "code": "function maxTasks ( high , low , n ) { if ( n <= 0 ) return 0 ; return Math . max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; } let n = 5 ; let high = [ 3 , 6 , 8 , 7 , 6 ] ; let low = [ 1 , 5 , 4 , 5 , 3 ] ; document . write ( maxTasks ( high , low , n ) ) ; ;"}
{"text": "Koefisien binomial | DP | Berfungsi untuk mencari GCD dua nombor dalam O (log (min (a, b))); Kes asas; C (n, r) = c (n, n - r) kerumitan masa yang lebih baik untuk nilai r yang lebih rendah; Pelbagai elemen dari N - r + 1 hingga n; Untuk nombor dari 1 hingga r mencari arr [j] seperti gcd (i, arr [j])> 1; Jika GCD> 1, bahagikan kedua -duanya oleh GCD; Jika saya menjadi 1, tidak perlu mencari arr; Pas tunggal untuk membiak pengangka; Kod pemacu", "code": "function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } function nCr ( n , r ) { if ( r > n ) return 0 ; if ( r > n - r ) r = n - r ; mod = 1000000007 ; var arr = new Array ( r ) ; for ( var i = n - r + 1 ; i <= n ; i ++ ) { arr [ i + r - n - 1 ] = i ; } var ans = 1 ; for ( var k = 1 ; k < r + 1 ; k ++ ) { var j = 0 , i = k ; while ( j < arr . length ) { var x = gcd ( i , arr [ j ] ) ; if ( x > 1 ) { arr [ j ] /= x ; i /= x ; } if ( i == 1 ) break ; j += 1 ; } } arr . forEach ( function ( i ) { ans = ( ans * i ) % mod ; } ) ; return ans ; } var n = 5 , r = 2 ; document . write ( \" \" + n + \" \" + r + \" \" + nCr ( n , r ) + \" \" ) ;"}
{"text": "Watak kth selepas menggantikan setiap watak rentetan dengan kekerapannya tepat x kali | Program JavaScript untuk fungsi pendekatan di atas untuk mencari watak KTH selepas X hari; Pembolehubah untuk menyimpan kthchar; Melintasi rentetan; Menukar char ke int; Hitung watak; Jika k kurang daripada jumlah daripada ans = str [i]; Jawapan kembali; Diberikan input; Panggilan fungsi", "code": "function FindKthChar ( str , K , X ) { var ans = \" \" ; var sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { var digit = parseInt ( str [ i ] ) ; var range = parseInt ( Math . pow ( digit , X ) ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; } var str = \" \" ; var K = 9 ; var X = 3 ; var ans = FindKthChar ( str , K , X ) ; document . write ( ans ) ;"}
{"text": "Jumlah pasangan watak dari dua rentetan, dengan bilangan bit set yang sama dalam nilai ASCII mereka | Pelaksanaan JavaScript fungsi pendekatan untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Berfungsi untuk mengembalikan kiraan pasangan yang sah; Kekerapan kedai bilangan bit yang ditetapkan untuk S1; Kekerapan kedai bilangan bit yang ditetapkan untuk S2; Kirakan jumlah pasangan; Mengembalikan kiraan pasangan yang sah; Kod pemacu", "code": "function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } function totalPairs ( s1 , s2 ) { var count = 0 ; var arr1 = new Array ( 7 ) . fill ( 0 ) ; var arr2 = new Array ( 7 ) . fill ( 0 ) ; for ( let i = 0 ; i < s1 . length ; i ++ ) { set_bits = countSetBits ( s1 [ i ] . charCodeAt ( 0 ) ) ; arr1 [ set_bits ] += 1 ; } for ( let i = 0 ; i < s2 . length ; i ++ ) { set_bits = countSetBits ( s2 [ i ] . charCodeAt ( 0 ) ) ; arr2 [ set_bits ] += 1 ; } for ( let i = 1 ; i < 7 ; i ++ ) { count += arr1 [ i ] * arr2 [ i ] ; } return count ; } var s1 = \" \" ; var s2 = \" \" ; document . write ( totalPairs ( s1 , s2 ) ) ;"}
{"text": "Kira substrings yang bermula dengan aksara x dan berakhir dengan watak y | fungsi untuk mengira substrings bermula dengan aksara x dan berakhir dengan watak y; untuk menyimpan jumlah jumlah substring yang diperlukan; Untuk menyimpan kiraan watak 'x' sehingga titik rentetan 'str' telah dilalui setakat ini; Bentuk 'Str' yang tersisa ke kanan; jika benar, kenaikan 'kenaikan _ x'; jika benar mengumpul 'kiraan _ x' ke 'tot _ count'; kiraan yang diperlukan; Kod pemacu", "code": "function countSubstr ( str , n , x , y ) { var tot_count = 0 ; var count_x = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] === x ) count_x ++ ; if ( str [ i ] === y ) tot_count += count_x ; } return tot_count ; } var str = \" \" ; var n = str . length ; var x = \" \" , y = \" \" ; document . write ( \" \" + countSubstr ( str , n , x , y ) ) ;"}
{"text": "Kira perkataan dalam rentetan yang diberikan | Program JavaScript untuk mengira tiada perkataan dari rentetan input yang diberikan. ; mengembalikan bilangan perkataan dalam str; kiraan perkataan; Imbas semua watak satu demi satu; Jika watak seterusnya adalah pemisah, tetapkan keadaan sebagai keluar; Jika watak seterusnya bukan pemisah perkataan dan keadaan keluar, maka tetapkan keadaan seperti dalam dan kiraan kata kenaikan; Pindah ke watak seterusnya; Program pemacu untuk menguji fungsi di atas", "code": "var OUT = 0 ; var IN = 1 ; function countWords ( str ) { var state = OUT ; var wc = 0 ; var i = 0 ; while ( i < str . length ) { if ( str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; } var str = \" \" ; document . write ( \" \" + countWords ( str ) ) ;"}
{"text": "Nombor Enneadecagonal | Berfungsi untuk mengira nombor enneadecagonal; Formula untuk mencari nombor enneadecagonal nth; Kod pemacu", "code": "function nthEnneadecagonal ( n ) { return ( 17 * n * n - 15 * n ) / 2 ; } let n = 6 ; document . write ( n + \" \" ) ; document . write ( nthEnneadecagonal ( n ) ) ;"}
{"text": "Kawasan lingkaran yang dilampirkan dari persegi | Fungsi ticiity; Kod pemacu", "code": "function areacircumscribed ( a ) { return ( a * a * ( 3.1415 / 2 ) ) ; } let a = 6 ; document . write ( \" \" , areacircumscribed ( a ) ) ;"}
{"text": "Cari item n yang diedarkan dari item tak terhingga jenis tak terhingga berdasarkan syarat -syarat yang diberikan | Berfungsi untuk mencari jenis item yang diberikan mengikut peraturan yang diberikan; Menyimpan kiraan item yang diberikan pada setiap langkah; Melangkah untuk mencari hari ke hari yang diberikan diberikan; Cari bilangan hadiah yang diberikan pada hari adalah hari * (hari + 1) / 2; Melangkah ke atas jenis; Mengembalikan jenis yang dihasilkan; Kod pemacu", "code": "function itemType ( n ) { let count = 0 ; let day = 1 ; while ( count + day * ( day + 1 ) / 2 < n ) { count += day * ( day + 1 ) / 2 ; day ++ ; } for ( let type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) { return type ; } } } let N = 10 ; document . write ( itemType ( N ) ) ;"}
{"text": "Semak jika senarai yang dipautkan disusun (berulang dan rekursif) | Nod senarai yang dipautkan; fungsi untuk menyemak senarai yang dipautkan disusun mengikut urutan menurun atau tidak; Kes asas; Semak dua nod pertama dan semak semula rekursif. ; Kod pemacu", "code": "class Node { constructor ( ) { this . data = 0 ; this . next = null ; } } function isSortedDesc ( head ) { if ( head == null head . next == null ) return true ; return head . data > head . next . data && isSortedDesc ( head . next ) ; } function newNode ( data ) { var temp = new Node ( ) ; temp . next = null ; temp . data = data ; return temp ; } var head = newNode ( 7 ) ; head . next = newNode ( 5 ) ; head . next . next = newNode ( 4 ) ; head . next . next . next = newNode ( 3 ) ; if ( isSortedDesc ( head ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Panjang maksimum berturut -turut 1 s atau 0 s selepas membalikkan kebanyakan watak K | Berfungsi untuk mencari segmen berterusan maksimum aksara C selepas membalikkan kebanyakan aksara K; Menyimpan panjang maksimum; Menyimpan kiraan char 'c'; Permulaan tetingkap; Keluarkan tambahan 'c' dari kiri; Meningkatkan nilai kiri; Mengemas kini panjang maksimum aksara CH; Fungsi untuk mencari panjang maksimum 0 s atau 1 s dengan membalikkan kebanyakan aksara K pada rentetan; Cetak maksimum panjang maksimum 0 s atau 1 s; Kod pemacu", "code": "const maxLength = ( str , n , c , k ) => { let ans = - 1 ; let cnt = 0 ; let left = 0 ; for ( let right = 0 ; right < n ; right ++ ) { if ( str [ right ] == c ) { cnt ++ ; } while ( cnt > k ) { if ( str [ left ] == c ) { cnt -- ; } left ++ ; } ans = Math . max ( ans , right - left + 1 ) ; } return ans ; } const maxConsecutiveSegment = ( S , K ) => { let N = S . length ; return Math . max ( maxLength ( S , N , ' ' , K ) , maxLength ( S , N , ' ' , K ) ) ; } let S = \" \" ; let K = 1 ; document . write ( maxConsecutiveSegment ( S , K ) ) ;"}
{"text": "Kurangkan syiling yang diperlukan untuk mendapatkan semua nilai yang mungkin sehingga n | Fungsi untuk mencari kiraan minimum {1, 2, 5} syiling bernilai diperlukan untuk membuat perubahan semua nilai dalam julat [1, n]; Bilangan 5 duit syiling yang diperlukan; Bilangan 1 duit syiling yang diperlukan; Bilangan 2 syiling bernilai diperlukan; Kod pemacu", "code": "function find ( N ) { var T , F , O ; F = parseInt ( ( N - 4 ) / 5 ) ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = Math . floor ( ( N - 5 * F - O ) / 2 ) ; document . write ( \" \" + F + \" \" ) ; document . write ( \" \" + T + \" \" ) ; document . write ( \" \" + O + \" \" ) ; } var N = 8 ; find ( N ) ;"}
{"text": "Ganti '? 'Untuk menukar rentetan yang diberikan kepada rentetan binari dengan kiraan maksimum' 0 'dan \"10\" | Fungsi untuk memaksimumkan kiraan 0 dan 10 dengan menggantikan watak '? 'hingga' 0 'atau' 1 '; Melintasi rentetan yang diberikan; Sekiranya watak semasa '? '; Gantikan str [i] hingga '0'; Diberi rentetan", "code": "function findMaxOccurence ( str , N ) { for ( var i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' ' ) { str [ i ] = ' ' ; } } document . write ( str . join ( ' ' ) ) ; } var str = \" \" . split ( ' ' ) ; var N = str . length ; findMaxOccurence ( str , N ) ;"}
{"text": "Semak jika diberikan rentetan adalah substring rentetan yang dibentuk oleh penggabungan berulang z ke a | Pemeriksaan fungsi jika rentetan yang diberikan adalah sah atau tidak dan mencetak output; Pembolehubah bendera boolean untuk menandakan jika diberikan rentetan sah; Melintasi rentetan yang diberikan; Jika watak bersebelahan berbeza dengan 1; Jika watak 'A' diikuti oleh 4; Lain flip bendera dan pecahkan dari gelung; Output mengikut pemboleh ubah bendera; Diberikan rentetan; Panggilan fungsi", "code": "function checkInfinite ( s ) { var flag = 1 ; var N = s . length ; for ( var i = 0 ; i < N - 1 ; i ++ ) { if ( s [ i ] == String . fromCharCode ( ( s [ i + 1 ] . charCodeAt ( 0 ) ) + 1 ) ) { continue ; } else if ( s [ i ] == ' ' && s [ i + 1 ] == ' ' ) { continue ; } else { flag = 0 ; break ; } } if ( flag == 0 ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } var s = \" \" ; checkInfinite ( s ) ;"}
{"text": "Perubahan minimum dalam lorong yang diperlukan untuk menyeberang semua halangan | Berfungsi untuk mencari bilangan minimum perubahan lorong yang diperlukan; Sekiranya terdapat halangan, maka tambahkan nilai yang sangat besar; Tambah nilai minimum untuk memindahkan Forword dengan atau tanpa melintasi halangan; Mengembalikan nilai minimum dp [0], dp [1] dan dp [2]; Kod pemacu", "code": "function minChangeInLane ( barrier , n ) { let dp = [ 1 , 0 , 1 ] ; for ( let j = 0 ; j < n ; j ++ ) { let val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = 1e6 ; } for ( let i = 0 ; i < 3 ; i ++ ) { if ( val != i + 1 ) { dp [ i ] = Math . min ( dp [ i ] , Math . min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } } return Math . min ( dp [ 0 ] , Math . min ( dp [ 1 ] , dp [ 2 ] ) ) ; } let barrier = [ 0 , 1 , 2 , 3 , 0 ] ; let N = barrier . length ; document . write ( minChangeInLane ( barrier , N ) ) ;"}
{"text": "Pertanyaan untuk mengira kumpulan pelajar N yang mungkin mempunyai jumlah penilaian dalam julat yang diberikan | Fungsi untuk mengira bilangan cara untuk mendapatkan kumpulan jumlah yang diberikan; Arahan DP Inisiasi; Tandakan semua nilai baris 1 sebagai 1 sejak tikar [0] [i] adalah semua jumlah yang mungkin dalam baris pertama; Betulkan baris ith; Betulkan jumlahnya; Melewati semua nilai baris ith; Jika jumlah boleh diperolehi; Cari Jumlah awalan baris terakhir; Melintasi setiap pertanyaan; Tidak ada cara untuk membentuk kumpulan; Diberikan N Batch dan K pelajar; Diberikan penilaian; Diberikan pertanyaan; Panggilan fungsi", "code": "function numWays ( ratings , queries ) { var dp = Array . from ( Array ( n ) , ( ) => Array ( 10002 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < k ; i ++ ) dp [ 0 ] [ ratings [ 0 ] [ i ] ] += 1 ; for ( var i = 1 ; i < n ; i ++ ) { for ( var sum = 0 ; sum <= 10000 ; sum ++ ) { for ( var j = 0 ; j < k ; j ++ ) { if ( sum >= ratings [ i ] [ j ] ) dp [ i ] [ sum ] += dp [ i - 1 ] [ sum - ratings [ i ] [ j ] ] ; } } } for ( var sum = 1 ; sum <= 10000 ; sum ++ ) { dp [ n - 1 ] [ sum ] += dp [ n - 1 ] [ sum - 1 ] ; } for ( var q = 0 ; q < 2 ; q ++ ) { var a = queries [ q ] [ 0 ] ; var b = queries [ q ] [ 1 ] ; document . write ( dp [ n - 1 ] [ b ] - dp [ n - 1 ] [ a - 1 ] + \" \" ) ; } } var n = 2 ; var k = 3 ; var ratings = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ; var queries = [ [ 6 , 6 ] , [ 1 , 6 ] ] ; numWays ( ratings , queries ) ;"}
{"text": "Bilangan permutasi dengan inversions k | Tetapkan 2 | Berfungsi untuk mengira permutasi dengan penyongsangan k; Menyimpan bilangan permutasi dengan penyongsangan K; Jika n = 1 hanya 1 permutasi tanpa penyongsangan; Untuk k = 0 hanya 1 permutasi tanpa penyongsangan; Sebaliknya mengemas kini setiap keadaan DP mengikut hubungan reccurrance yang terbentuk; Cetak kiraan akhir; Diberikan n dan k; Panggilan fungsi", "code": "function numberOfPermWithKInversion ( N , K ) { let dp = new Array ( 2 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let mod = 1000000007 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) { dp [ i % 2 ] [ j ] = ( j == 0 ) ? 1 : 0 ; } else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( Math . max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ Math . max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } } document . write ( dp [ N % 2 ] [ K ] ) ; } let N = 3 , K = 2 ; numberOfPermWithKInversion ( N , K ) ;"}
{"text": "Treasure and Cities | K ialah indeks semasa dan col adalah warna sebelumnya. ; Kes asas; Semak sama ada warna bandar ini sama dengan bandar yang dilawati sebelum ini; kembali maksimum kedua -dua pilihan; Kod pemacu; Pada mulanya bermula dengan warna 0", "code": "function MaxProfit ( treasure , color , n , k , col , A , B ) { let sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; } let A = - 5 , B = 7 ; let treasure = [ 4 , 8 , 2 , 9 ] ; let color = [ 2 , 2 , 6 , 2 ] ; let n = color . length ; document . write ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) ;"}
{"text": "Nombor Tetranacci | Berfungsi untuk mengembalikan nombor tetranacci N; kes asas; kes asas; kes asas; berfungsi untuk mencetak nombor tetranacci nth; Kod pemacu", "code": "function printTetraRec ( n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return 1 ; if ( n == 3 ) return 2 ; else return printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ; } function printTetra ( n ) { document . write ( printTetraRec ( n ) + \" \" + \" \" ) ; } let n = 10 ; printTetra ( n ) ;"}
{"text": "Jumlah produk semua gabungan diambil (1 hingga n) pada satu masa | untuk menyimpan jumlah kombinasi; Jika kita telah mencapai kedalaman yang mencukupi; Cari produk gabungan; Tambah produk ke dalam jumlah; rekursi untuk menghasilkan gabungan yang berbeza; berfungsi untuk mencetak jumlah produk semua gabungan yang diambil 1 - n pada satu masa; mewujudkan array sementara untuk menyimpan kombinasi; gabungan panggilan dengan r = i untuk gabungan yang diambil saya pada satu masa; memaparkan jumlah; Kod pemacu; menyimpan nombor dari 1 - n dalam array; Memanggil AllCombination", "code": "let sum = 0 ; function Combination ( a , combi , n , r , depth , index ) { if ( index == r ) { let product = 1 ; for ( let i = 0 ; i < r ; i ++ ) product = product * combi [ i ] ; sum += product ; return ; } for ( let i = depth ; i < n ; i ++ ) { combi [ index ] = a [ i ] ; Combination ( a , combi , n , r , i + 1 , index + 1 ) ; } } function allCombination ( a , n ) { for ( let i = 1 ; i <= n ; i ++ ) { let combi = [ ] ; Combination ( a , combi , n , i , 0 , 0 ) ; document . write ( \" \" + i + \" \" + sum + \" \" ) ; sum = 0 ; } } let n = 5 ; let a = [ ] ; for ( let i = 0 ; i < n ; i ++ ) a [ i ] = i + 1 ; allCombination ( a , n ) ;"}
{"text": "Pengaturcaraan Dinamik | Tinggi | Mengembalikan maksimum di antara 2 nombor; Mengembalikan jumlah tugas maksimum yang boleh dilakukan sehingga hari n; Task_dp array yang menyimpan tugas maksimum yang dilakukan; Jika n = 0, tiada penyelesaian wujud; Jika n = 1, tugas usaha yang tinggi pada hari itu akan menjadi penyelesaian; Isi keseluruhan array menentukan tugas mana yang hendak dipilih pada hari I; Kod pemacu", "code": "function max ( x , y ) { return ( x > y ? x : y ) ; } function maxTasks ( high , low , n ) { var task_dp = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; task_dp [ 0 ] = 0 ; task_dp [ 1 ] = high [ 0 ] ; for ( i = 2 ; i <= n ; i ++ ) task_dp [ i ] = Math . max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; } var n = 5 ; var high = [ 3 , 6 , 8 , 7 , 6 ] ; var low = [ 1 , 5 , 4 , 5 , 3 ] ; document . write ( maxTasks ( high , low , n ) ) ;"}
{"text": "Koefisien Permutasi | A o (n) masa dan O (1) penyelesaian ruang tambahan untuk mengira pekali permutasi; Kirakan n * (n - 1) * (n - 2). ... (n - k + 1); Kod pemacu", "code": "function PermutationCoeff ( n , k ) { let P = 1 ; for ( let i = 0 ; i < k ; i ++ ) P *= ( n - i ) ; return P ; } let n = 10 , k = 2 ; document . write ( \" \" + n + \" \" + k + \" \" + PermutationCoeff ( n , k ) ) ;"}
{"text": "Masalah Partition | DP | Pulangan benar jika ARR boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah semua elemen; memulakan baris atas sebagai benar; memulakan lajur paling kiri, kecuali bahagian [0] [0], sebagai 0; Isi jadual partition dengan cara bawah; Uncomment Bahagian ini untuk mencetak jadual; Kod pemacu; Panggilan fungsi", "code": "function findPartition ( arr , n ) { var sum = 0 ; var i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; var part = Array ( parseInt ( sum / 2 ) + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ; for ( i = 1 ; i <= parseInt ( sum / 2 ) ; i ++ ) part [ i ] [ 0 ] = false ; for ( i = 1 ; i <= parseInt ( sum / 2 ) ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } } return part [ parseInt ( sum / 2 ) ] [ n ] ; } var arr = [ 3 , 1 , 1 , 2 , 2 , 1 ] ; var n = arr . length ; if ( findPartition ( arr , n ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Bilangan minimum tambahan x atau y aksara dari hujung ke depan yang diperlukan untuk mendapatkan rentetan yang diberikan | Fungsi untuk mencari operasi minimum yang diperlukan untuk mendapatkan rentetan yang diberikan selepas menambahkan aksara M atau N dari hujung ke hadapan rentetan dalam setiap operasi; Simpan rentetan asal; Menyimpan kiraan operasi; Melintasi rentetan; Potong huruf dari akhir; Masukkan huruf potong untuk permulaan; Kemas kini j; Semak sama ada rentetan adalah sama; Potong n huruf dari hujung; Masukkan huruf potong n untuk permulaan; Kemas kini j; Semak sama ada rentetan adalah sama; Mengemas kini giliran; Diberikan rentetan s; Panggilan fungsi", "code": "function minimumOperations ( orig_str , m , n ) { let orig = orig_str ; let turn = 1 ; let j = 1 ; for ( let i = 0 ; i < orig_str . length ; i ++ ) { let m_cut = orig_str . substring ( orig_str . length - m ) ; orig_str = orig_str . substring ( 0 , orig_str . length - m ) ; orig_str = m_cut + orig_str ; j = j + 1 ; if ( orig != orig_str ) { turn = turn + 1 ; let n_cut = orig_str . substring ( orig_str . length - n ) ; orig_str = orig_str . substring ( 0 , orig_str . length - n ) ; orig_str = n_cut + orig_str ; j = j + 1 ; } if ( orig == orig_str ) { break ; } turn = turn + 1 ; } document . write ( turn ) ; } let S = \" \" ; let X = 5 , Y = 3 ; minimumOperations ( S , X , Y ) ;"}
{"text": "Putaran minimum diperlukan untuk mendapatkan rentetan yang sama | Set | Cetakan kejadian txt [] dalam pat []; Buat LPS [] yang akan memegang nilai akhiran awalan terpanjang untuk corak; Pra -proses corak (hitung array LPS []); Indeks untuk txt [], indeks untuk pat []; Tidak sepadan selepas perlawanan J; Jangan sepadan dengan LPS [0 .. LPS [J - 1]] aksara, mereka akan sepadan pula; Mengisi LPS [] untuk corak yang diberikan Pat [0. M - 1]; Panjang akhiran awalan terpanjang sebelumnya; LPS [0] sentiasa 0; Gelung mengira LPS [i] untuk i = 1 hingga m - 1; (pat [i]! = pat [len]); Ini sukar. Pertimbangkan contohnya. AAACAAAA dan I = 7. Idea ini sama dengan langkah carian. ; Mengembalikan kiraan putaran untuk mendapatkan rentetan yang sama kembali; Bentuk rentetan tidak termasuk watak pertama dan menggabungkan rentetan pada akhir; Menukar rentetan ke array aksara; Gunakan algoritma carian KMP untuk mencarinya dalam masa O (n); Kod pemacu", "code": "function KMPSearch ( pat , txt ) { let M = pat . length ; let N = txt . length ; let lps = new Array ( M ) ; lps . fill ( 0 ) ; computeLPSArray ( pat , M , lps ) ; let i = 0 ; let j = 0 ; while ( i < N ) { if ( pat [ j ] == txt [ i ] ) { j ++ ; i ++ ; } if ( j == M ) { return i - j ; } else if ( i < N && pat [ j ] != txt [ i ] ) { if ( j != 0 ) j = lps [ j - 1 ] ; else i = i + 1 ; } } return 0 ; } function computeLPSArray ( pat , M , lps ) { let len = 0 ; lps [ 0 ] = 0 ; let i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } } function countRotations ( s ) { let s1 = s . substring ( 1 , s . length ) + s ; let pat = s . split ( ' ' ) ; let text = s1 . split ( ' ' ) ; return 1 + KMPSearch ( pat , text ) ; } let s1 = \" \" ; document . write ( countRotations ( s1 ) ) ;"}
{"text": "DFA untuk rentetan tidak berakhir dengan \"The\" | DFA memberitahu nombor yang berkaitan dengan keadaan sekarang; Fungsi ini adalah untuk keadaan permulaan (zeroth) DFA; Apabila menerima 'T' atau 'T' Goto State First (1); Fungsi ini adalah untuk keadaan pertama DFA; Apabila menerima 'T' atau 'T' Goto State First (1); Apabila menerima 'H' atau 'H' Goto kedua negeri (2); lain Goto State State (0); Fungsi ini adalah untuk keadaan kedua DFA; Apabila menerima 'E' atau 'E' Goto Negeri Ketiga (3) Lain Goto State State (0); Fungsi ini adalah untuk keadaan ketiga DFA; Apabila menerima 'T' atau 'T' Goto State First (1) Lain Goto State State (0); panjang simpan rentetan; Kod pemacu", "code": "let dfa = 0 ; function start ( c ) { if ( c == ' ' c == ' ' ) dfa = 1 ; } function state1 ( c ) { if ( c == ' ' c == ' ' ) dfa = 1 ; else if ( c == ' ' c == ' ' ) dfa = 2 ; else dfa = 0 ; } function state2 ( c ) { if ( c == ' ' c == ' ' ) dfa = 3 ; else dfa = 0 ; } function state3 ( c ) { if ( c == ' ' c == ' ' ) dfa = 1 ; else dfa = 0 ; } function isAccepted ( str ) { let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; } let str = \" \" . split ( ' ' ) ; if ( isAccepted ( str ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Semak jika satu rentetan boleh ditukar kepada yang lain | Pelaksanaan JavaScript pendekatan di atas. ; Fungsi untuk mencari dari algoritma set disjoint; Fungsi untuk kesatuan dari algoritma set disjoint; Fungsi untuk memeriksa sama ada satu rentetan boleh ditukar kepada yang lain. ; Semua watak diperiksa sama ada ia sama ada tidak diganti atau digantikan oleh watak yang sama menggunakan peta. ; Untuk memeriksa sama ada terdapat kitaran. Jika ya, maka mereka tidak boleh ditukar. Selain itu, mereka boleh ditukar. ; Fungsi untuk memulakan array induk untuk kesatuan dan mencari algoritma. ; Kod pemacu", "code": "var parent = new Array ( 26 ) . fill ( 0 ) ; function find ( x ) { if ( x !== parent [ x ] ) return ( parent [ x ] = find ( parent [ x ] ) ) ; return x ; } function join ( x , y ) { var px = find ( x ) ; var pz = find ( y ) ; if ( px !== pz ) { parent [ pz ] = px ; } } function convertible ( s1 , s2 ) { var mp = { } ; for ( var i = 0 ; i < s1 . length ; i ++ ) { if ( ! mp . hasOwnProperty ( s1 [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ) ) { mp [ s1 [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] = s2 [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ; } else { if ( mp [ s1 [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] !== s2 [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ) return false ; } } for ( const [ key , value ] of Object . entries ( mp ) ) { if ( key === value ) continue ; else { if ( find ( key ) == find ( value ) ) return false ; else join ( key , value ) ; } } return true ; } function initialize ( ) { for ( var i = 0 ; i < 26 ; i ++ ) { parent [ i ] = i ; } } var s1 , s2 ; s1 = \" \" ; s2 = \" \" ; initialize ( ) ; if ( convertible ( s1 , s2 ) ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text": "Cetak Watak yang mempunyai frekuensi utama dalam urutan kejadian | pelaksanaan JavaScript pendekatan; Berfungsi untuk membuat ayak untuk memeriksa fungsi prima untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mencetak aksara frekuensi utama mengikut urutan kejadian mereka; Berfungsi untuk membuat ayak untuk memeriksa prima; Untuk menyimpan kekerapan setiap watak rentetan; Memulakan semua elemen freq [] hingga 0; Kemas kini kekerapan setiap aksara; Traverse str -watak oleh watak; Jika kekerapan watak semasa adalah perdana; Kod pemacu", "code": "let SIZE = 26 ; function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } return prime ; } function printChar ( str , n ) { let prime = [ ] ; for ( let i = 0 ; i < n + 1 ; i ++ ) { prime . push ( true ) ; } prime = SieveOfEratosthenes ( prime , str . length + 1 ) ; let freq = [ ] ; for ( let i = 0 ; i < 26 ; i ++ ) { freq . push ( 0 ) ; } for ( let i = 0 ; i < n ; i ++ ) freq [ str . charCodeAt ( i ) - 97 ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { if ( prime [ freq [ str . charCodeAt ( i ) - 97 ] ] ) { document . write ( str [ i ] ) ; } } } let str = \" \" ; let n = str . length ; printChar ( str , n ) ;"}
{"text": "Cetak Watak yang mempunyai frekuensi utama dalam urutan kejadian | Berfungsi untuk memeriksa prima; Mengira kekerapan semua watak menggunakan fungsi kaunter; Melintasi rentetan; Kod pemacu; Lulus rentetan ke fungsi checkstring", "code": "function prime ( n ) { if ( n <= 1 ) return false ; let max_div = Math . floor ( Math . sqrt ( n ) ) ; for ( let i = 2 ; i < 1 + max_div ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } function checkString ( s ) { let freq = new Map ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( ! freq . has ( s [ i ] ) ) freq . set ( s [ i ] , 0 ) ; freq . set ( s [ i ] , freq . get ( s [ i ] ) + 1 ) ; } for ( let i = 0 ; i < s . length ; i ++ ) { if ( prime ( freq . get ( s [ i ] ) ) ) document . write ( s [ i ] ) ; } } let s = \" \" ; checkString ( s ) ;"}
{"text": "Cetak Watak yang mempunyai frekuensi walaupun dalam urutan kejadian | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mencetak aksara kekerapan walaupun dalam urutan kejadian mereka; Untuk menyimpan kekerapan setiap watak rentetan; Memulakan semua elemen freq [] hingga 0; Kemas kini kekerapan setiap aksara; Traverse str -watak oleh watak; Jika kekerapan watak semasa adalah walaupun; Kod pemacu", "code": "let SIZE = 26 ; function printChar ( str , n ) { let freq = new Array ( SIZE ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { freq [ str . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] ++ ; } for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] % 2 == 0 ) { document . write ( str [ i ] ) ; } } } let str = \" \" ; let n = str . length ; printChar ( str , n ) ;"}
{"text": "Bandingkan dua rentetan memandangkan hanya aksara alfanumerik | Berfungsi untuk memeriksa kesamaan alfanumerik kedua -dua rentetan; Perisytiharan Variabel; Panjang rentetan pertama; Panjang rentetan kedua; Untuk memeriksa setiap watak kedua -dua rentetan; Jika watak semasa rentetan pertama bukan watak alfanumerik, tingkatkan penunjuk I; Jika watak semasa rentetan kedua bukan watak alfanumerik, tingkatkan penunjuk j; Jika semua aksara alfanumerik kedua -dua rentetan adalah sama maka kembali benar; Jika mana -mana aksara alfanumerik kedua -dua rentetan tidak sama maka kembali palsu; Jika watak semasa dipadankan, tingkatkan kedua -dua petunjuk untuk memeriksa watak seterusnya; Jika tidak sama, maka kembali palsu; Berfungsi untuk mencetak sama atau tidak sama rata jika rentetan sama atau tidak; Semak kesamaan alfanumerik kedua -dua rentetan; Sekiranya kedua -duanya adalah sama dengan alfanumerik, cetak sama; sebaliknya mencetak tidak sama rata; Kod pemacu", "code": "function CompareAlphanumeric ( str1 , str2 ) { let i , j ; i = 0 ; j = 0 ; let len1 = str1 . length ; let len2 = str2 . length ; while ( i <= len1 && j <= len2 ) { while ( i < len1 && ( ! ( ( str1 [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) || ( str1 [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) || ( str1 [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) ) ) ) { i ++ ; } while ( j < len2 && ( ! ( ( str2 [ j ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str2 [ j ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) || ( str2 [ j ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str2 [ j ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) || ( str2 [ j ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str2 [ j ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) ) ) ) { j ++ ; } if ( i == len1 && j == len2 ) { return true ; } else if ( str1 [ i ] != str2 [ j ] ) { return false ; } else { i ++ ; j ++ ; } } return false ; } function CompareAlphanumericUtil ( str1 , str2 ) { let res ; res = CompareAlphanumeric ( str1 . split ( ' ' ) , str2 . split ( ' ' ) ) ; if ( res == true ) { document . write ( \" \" + \" \" ) ; } else { document . write ( \" \" ) ; } } let str1 , str2 ; str1 = \" \" ; str2 = \" \" ; CompareAlphanumericUtil ( str1 , str2 ) ; str1 = \" \" ; str2 = \" \" ; CompareAlphanumericUtil ( str1 , str2 ) ;"}
{"text": "Pertanyaan untuk mencetak watak yang berlaku bilangan maksimum kali dalam julat yang diberikan | Fungsi yang menjawab semua pertanyaan; Panjang rentetan; Bilangan pertanyaan; Arahan awalan; Melewati semua watak; Meningkatkan kiraan watak; Arahan anggaran untuk semua 26 aksara; Kemas kini array awalan; Jawab setiap pertanyaan; Julat; ITERATE untuk semua watak; Kali watak huruf kecil j berlaku sehingga indeks r - th; Tolak masa yang berlaku sehingga indeks (l - 1) th; Maksimum masa itu berlaku; Cetak jawapannya; Kod pemacu", "code": "function solveQueries ( str , query ) { let len = str . length ; let Q = query . length ; let pre = new Array ( len ) ; for ( let i = 0 ; i < len ; i ++ ) { pre [ i ] = new Array ( 26 ) ; for ( let j = 0 ; j < 26 ; j ++ ) { pre [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < len ; i ++ ) { pre [ i ] [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; if ( i > 0 ) { for ( let j = 0 ; j < 26 ; j ++ ) pre [ i ] [ j ] += pre [ i - 1 ] [ j ] ; } } for ( let i = 0 ; i < Q ; i ++ ) { let l = query [ i ] [ 0 ] ; let r = query [ i ] [ 1 ] ; let maxi = 0 ; let c = ' ' ; for ( let j = 0 ; j < 26 ; j ++ ) { let times = pre [ r ] [ j ] ; if ( l > 0 ) times -= pre [ l - 1 ] [ j ] ; if ( times > maxi ) { maxi = times ; c = String . fromCharCode ( ' ' . charCodeAt ( 0 ) + j ) ; } } document . write ( \" \" + ( i + 1 ) + \" \" + c + \" \" ) ; } } let str = \" \" ; let query = [ [ 0 , 1 ] , [ 1 , 6 ] , [ 5 , 6 ] ] ; solveQueries ( str , query ) ;"}
{"text": "Semak sama ada rentetan yang diberikan boleh dijana selepas menyatukan rentetan yang diberikan | Fungsi yang kembali benar jika pra adalah awalan str; Walaupun ada watak untuk dipadankan; Jika watak berbeza di mana -mana kedudukan; STR bermula dengan pra; Fungsi yang kembali benar jika Suff adalah akhiran str; Walaupun ada watak untuk dipadankan; Jika watak berbeza di mana -mana kedudukan; str berakhir dengan suff; Fungsi yang kembali benar jika str = a + b atau str = b + a; STR tidak boleh dihasilkan dengan menggabungkan A dan B; Jika str bermula dengan i. e. A adalah awalan str; Semak sama ada watak -watak yang lain adalah sama dengan b i. e. B adalah akhiran str; Jika str bermula dengan b i. e. B adalah awalan str; Semak sama ada watak -watak yang lain adalah sama dengan i. e. A adalah akhiran str; Kod pemacu", "code": "function startsWith ( str , pre ) { let strLen = str . length ; let preLen = pre . length ; let i = 0 , j = 0 ; while ( i < strLen && j < preLen ) { if ( str [ i ] != pre [ j ] ) return false ; i ++ ; j ++ ; } return true ; } function endsWith ( str , suff ) { let i = str . length - 1 ; let j = suff . length - 1 ; while ( i >= 0 && j >= 0 ) { if ( str [ i ] != suff [ j ] ) return false ; i -- ; j -- ; } return true ; } function checkString ( str , a , b ) { if ( str . length != a . length + b . length ) return false ; if ( startsWith ( str , a ) ) { if ( endsWith ( str , b ) ) return true ; } if ( startsWith ( str , b ) ) { if ( endsWith ( str , a ) ) return true ; } return false ; } let str = \" \" ; let a = \" \" ; let b = \" \" ; if ( checkString ( str , a , b ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Cetak Watak yang mempunyai frekuensi ganjil mengikut urutan kejadian | pelaksanaan JavaScript pendekatan; Berfungsi untuk mencetak aksara frekuensi ganjil mengikut urutan kejadian mereka; Untuk menyimpan kekerapan setiap watak rentetan; Memulakan semua elemen freq [] hingga 0; Kemas kini kekerapan setiap aksara; Traverse str -watak oleh watak; Jika kekerapan watak semasa adalah ganjil; Kod pemacu", "code": "let SIZE = 26 ; function printChar ( str , n ) { let freq = [ ] ; for ( let i = 0 ; i < SIZE ; i ++ ) { freq . push ( 0 ) ; } for ( let i = 0 ; i < n ; i ++ ) freq [ str . charCodeAt ( i ) - 97 ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str . charCodeAt ( i ) - 97 ] % 2 == 1 ) { document . write ( str [ i ] ) ; } } } let str = \" \" ; let n = str . length ; printChar ( str , n ) ;"}
{"text": "Bilangan minimum operasi untuk memindahkan semua aksara huruf besar sebelum semua aksara kes yang lebih rendah | Pelaksanaan JavaScript dari CHELDER CHELLETCELCASE; Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan; Untuk menyimpan indeks huruf besar terakhir dan watak huruf kecil pertama; Cari watak huruf besar terakhir; Cari watak huruf kecil pertama; Jika semua watak adalah huruf besar atau huruf kecil; Kiraan aksara huruf besar yang muncul selepas watak huruf kecil pertama; Count huruf kecil yang muncul sebelum watak huruf besar terakhir; Mengembalikan operasi minimum yang diperlukan; Kod pemacu", "code": "function isupper ( str ) { return str === str . toUpperCase ( ) ; } function minOperations ( str , n ) { var i , lastUpper = - 1 , firstLower = - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( isupper ( str [ i ] ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( islower ( str [ i ] ) ) { firstLower = i ; break ; } } if ( lastUpper === - 1 firstLower === - 1 ) return 0 ; var countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( isupper ( str [ i ] ) ) { countUpper ++ ; } } var countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( islower ( str [ i ] ) ) { countLower ++ ; } } return Math . min ( countLower , countUpper ) ; } var str = \" \" ; var n = str . length ; document . write ( minOperations ( str , n ) + \" \" ) ;"}
{"text": "Cari jumlah semua nombor pertunangan sehingga n | Berfungsi untuk mencari jumlah semua nombor pertunangan; Untuk menyimpan nombor pertunangan; Kirakan jumlah pembahagi nombor_1 1 sentiasa menjadi pembahagi; i = 2 kerana kita tidak mahu memasukkan 1 sebagai pembahagi. ; Jumlah semua nombor pertunangan sehingga n; Kod pemacu", "code": "function Betrothed_Sum ( n ) { let Set = [ ] ; for ( let number_1 = 1 ; number_1 < n ; number_1 ++ ) { let sum_divisor_1 = 1 ; let i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += parseInt ( number_1 / i ) ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { let number_2 = sum_divisor_1 - 1 ; let sum_divisor_2 = 1 ; let j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += parseInt ( number_2 / j ) ; } j = j + 1 ; } if ( ( sum_divisor_2 == number_1 + 1 ) && number_1 <= n && number_2 <= n ) { Set . push ( number_1 ) ; Set . push ( number_2 ) ; } } } let Summ = 0 ; for ( let i = 0 ; i < Set . length ; i ++ ) { if ( Set [ i ] <= n ) Summ += Set [ i ] ; } return Summ ; } let n = 78 ; document . write ( Betrothed_Sum ( n ) ) ;"}
{"text": "Kebarangkalian hujan pada hari n + 1 | | Fungsi untuk mencari kebarangkalian; kiraan 1; Cari kebarangkalian; Kod pemacu", "code": "function rainDayProbability ( a , n ) { let count = 0 , m ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; } let a = [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] ; let n = a . length ; document . write ( rainDayProbability ( a , n ) ) ;"}
{"text": "Program untuk mencari jumlah siri 1 + 1/2 ^ 2 + 1/3 ^ 3 + â € |. . + 1 / n ^ n | Fungsi untuk mengira siri berikut; Kod pemacu", "code": "function Series ( n ) { let sums = 0.0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { ser = 1 / Math . pow ( i , i ) ; sums += ser ; } return sums ; } let n = 3 ; let res = Math . round ( Series ( n ) * 100000 ) / 100000 ; document . write ( res ) ;"}
{"text": "Rentetan lexicographically terbesar yang terbentuk dalam langkah minimum dengan menggantikan watak -watak rentetan yang diberikan | Fungsi untuk mencetak lexicographically rentetan terbesar yang diperolehi dalam proses mendapatkan rentetan yang mengandungi pertama N Case Lower English Alphabtes; Simpan kekerapan setiap watak; Melintasi rentetan s; Menyimpan watak -watak yang tidak muncul dalam s; Menyimpan indeks watak terbesar dalam array V, yang perlu diganti; Melintasi rentetan, s; Jika kekerapan S [i] lebih besar daripada 1 atau ia berada di luar julat; Menurunkan kekerapannya dengan 1; UPDATE S [I]; Penurunan j oleh 1; Melintasi rentetan, s; Menurunkan kekerapannya dengan 1; UPDATE S [I]; Kenaikan l oleh 1; Pulangan s; Diberikan input; Panggilan fungsi", "code": "function lexicographicallyMaximum ( S , N ) { let M = new Map ( ) ; for ( let i = 0 ; i < N ; ++ i ) { if ( M . has ( S [ i ] ) ) M . set ( S [ i ] , M . get ( S [ i ] ) + 1 ) ; else M . set ( S [ i ] , 1 ) ; } let V = [ ] ; for ( let i = ' ' . charCodeAt ( ) ; i < ( ' ' . charCodeAt ( ) + Math . min ( N , 25 ) ) ; ++ i ) { if ( M . has ( String . fromCharCode ( i ) ) == false ) { V . push ( String . fromCharCode ( i ) ) ; } } let j = V . length - 1 ; for ( let i = 0 ; i < N ; ++ i ) { if ( S [ i ] . charCodeAt ( ) >= ( ' ' . charCodeAt ( ) + Math . min ( N , 25 ) ) || ( M . has ( S [ i ] ) && M . get ( S [ i ] ) > 1 ) ) { if ( V [ j ] . charCodeAt ( ) < S [ i ] . charCodeAt ( ) ) continue ; M . set ( S [ i ] , M . get ( S [ i ] ) - 1 ) ; S = S . substr ( 0 , i ) + V [ j ] + S . substr ( i + 1 ) ; j -- ; } if ( j < 0 ) break ; } let l = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S [ i ] . charCodeAt ( ) >= ( ' ' . charCodeAt ( ) + Math . min ( N , 25 ) ) || M . has ( S [ i ] ) && M . get ( S [ i ] ) > 1 ) { M . set ( S [ i ] , M . get ( S [ i ] ) - 1 ) ; S = S . substr ( 0 , i ) + V [ l ] + S . substr ( i + 1 ) ; l ++ ; } } return S ; } let S = \" \" ; let N = S . length ; document . write ( lexicographicallyMaximum ( S , N ) ) ;"}
{"text": "Semak jika mana -mana subarray boleh dibuat palindromic dengan menggantikan kurang daripada separuh elemennya | Fungsi utiliti untuk memeriksa sama ada subarray boleh menjadi palindromic dengan menggantikan kurang daripada separuh unsur yang ada di dalamnya; Kedai kekerapan elemen array; Melintasi array; Kekerapan kemas kini setiap elemen array; Iterator di atas peta; Jika kekerapan mana -mana elemen melebihi 1; Sekiranya tiada pengulangan dijumpai; Berfungsi untuk memeriksa dan mencetak jika mana -mana subarray boleh dibuat palindromic dengan menggantikan kurang daripada separuh elemennya; Diberikan array arr []; Saiz array; Panggilan fungsi", "code": "function isConsistingSubarrayUtil ( arr , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; ++ i ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } var ans = false ; mp . forEach ( ( value , key ) => { if ( value > 1 ) { ans = true ; } } ) ; if ( ans ) return true ; return false ; } function isConsistingSubarray ( arr , N ) { if ( isConsistingSubarrayUtil ( arr , N ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } var arr = [ 1 , 2 , 3 , 4 , 5 , 1 ] ; var N = arr . length ; isConsistingSubarray ( arr , N ) ;"}
{"text": "Nombor Fibonacci Komposit dari Arahan yang diberikan | Berfungsi untuk mencari semua nombor Fibonacci sehingga maks; Simpan semua nombor Fibonacci sehingga max; Kedai elemen sebelumnya dari urutan Fibonacci; Kedai elemen sebelumnya dari urutan Fibonacci; Masukkan prev ke hashmap; Masukkan semua nombor Fibonacci sehingga maks; Masukkan curr ke hashmap; Kedai -kedai Curr Into Temp; Kemas kini curr; UPDATE PREV; Berfungsi untuk mencari semua nombor komposit sehingga maks; Isprime [i]: Kedai jika saya adalah nombor utama atau tidak; Kirakan semua nombor perdana sehingga maksimum menggunakan penapis eratosthenes; Jika p adalah nombor utama; Tetapkan semua pelbagai p sebagai bukan perdana; Kemas kini isprime; Fungsi untuk mencari nombor yang merupakan nombor komposit dan fibonacci; Menyimpan elemen terbesar array; Melintasi array arr []; Kemas kini Max; isprim [i] periksa saya adalah nombor utama atau tidak; Menyimpan semua nombor Fibonacci; Melintasi array arr []; Elemen semasa bukan nombor komposit; Jika elemen semasa adalah nombor fibonacci dan komposit; Cetak elemen semasa; Kod pemacu", "code": "function createhashmap ( Max ) { var hashmap = new Set ( ) ; var curr = 1 ; var prev = 0 ; hashmap . add ( prev ) ; while ( curr <= Max ) { hashmap . add ( curr ) ; var temp = curr ; curr = curr + prev ; prev = temp ; } return hashmap ; } function SieveOfEratosthenes ( Max ) { var isPrime = Array ( Max + 1 ) . fill ( true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( var p = 2 ; p * p <= Max ; p ++ ) { if ( isPrime [ p ] ) { for ( var i = p * p ; i <= Max ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; } function cntFibonacciPrime ( arr , N ) { var Max = arr [ 0 ] ; for ( var i = 1 ; i < N ; i ++ ) { Max = Math . max ( Max , arr [ i ] ) ; } var isPrime = SieveOfEratosthenes ( Max ) ; var hashmap = createhashmap ( Max ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) continue ; if ( hashmap . has ( arr [ i ] ) && ! isPrime [ arr [ i ] ] ) { document . write ( arr [ i ] + \" \" ) ; } } } var arr = [ 13 , 55 , 7 , 3 , 5 , 21 , 233 , 144 , 89 ] ; var N = arr . length ; cntFibonacciPrime ( arr , N ) ;"}
{"text": "Kurangkan nombor yang diberikan untuk membentuk kunci oleh operasi yang diberikan | Berfungsi untuk mencari kunci nombor yang diberikan; Tukar integer ke rentetan; Melepasi rentetan num untuk mendapatkan hasilnya; Semak sama ada digit adalah atau ganjil; Berulang sehingga jumlah ganjil diperolehi dengan menambahkan digit berturut -turut; Semak jika jumlahnya menjadi ganjil; Tambah hasil dalam ANS; Berikan indeks digit ke rentetan NUM; Jika nombor itu ganjil; Berulang sehingga jumlah ganjil diperolehi dengan menambahkan digit berturut -turut; Semak sama ada jumlahnya menjadi walaupun; Tambah hasil dalam ANS; Berikan indeks digit ke numstring utama; Periksa sama ada semua digit dikunjungi atau tidak; Kod pemacu", "code": "function key ( N ) { let num = \" \" + N . toString ( ) ; let ans = 0 ; let j = 0 ; for ( j = 0 ; j < num . length ; j ++ ) { if ( ( num [ j ] . charCodeAt ( ) - 48 ) % 2 == 0 ) { let add = 0 ; let i ; for ( i = j ; j < num . length ; j ++ ) { add += num [ j ] . charCodeAt ( ) - 48 ; if ( add % 2 == 1 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { let digit = Math . floor ( Math . log10 ( add ) + 1 ) ; ans *= parseInt ( Math . pow ( 10 , digit ) , 10 ) ; ans += add ; } i = j ; } else { let add = 0 ; let i ; for ( i = j ; j < num . length ; j ++ ) { add += num [ j ] . charCodeAt ( ) - 48 ; if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { let digit = Math . floor ( Math . log10 ( add ) + 1 ) ; ans *= parseInt ( Math . pow ( 10 , digit ) , 10 ) ; ans += add ; } i = j ; } } if ( j + 1 >= num . length ) { return ans ; } else { return ans += num [ num . length - 1 ] . charCodeAt ( ) - 48 ; } } let N = 1667848271 ; document . write ( key ( N ) ) ;"}
{"text": "Sentinel Linear Search | Berfungsi untuk mencari x dalam array yang diberikan; Elemen terakhir array; Unsur yang akan dicari diletakkan pada indeks terakhir; Letakkan elemen terakhir kembali; Kod pemacu", "code": "function sentinelSearch ( arr , n , key ) { var last = arr [ n - 1 ] ; arr [ n - 1 ] = key ; var i = 0 ; while ( arr [ i ] != key ) i ++ ; arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) document . write ( key + \" \" + i ) ; else document . write ( \" \" ) ; } var arr = [ 10 , 20 , 180 , 30 , 60 , 50 , 110 , 100 , 70 ] ; var n = arr . length ; var key = 180 ; sentinelSearch ( arr , n , key ) ;"}
{"text": "Unsur pertengahan maksimum yang mungkin selepas memadam Elements Kepatnya | Fungsi untuk mengira nilai tengah maksimum yang mungkin dari array selepas memadam elemen K tepat; Memulakan jawapan sebagai - 1; Hitung pelbagai elemen yang boleh memberikan nilai tengah maksimum yang mungkin dari array kerana indeks nilai maksimum yang mungkin ditengah selepas memadam elemen k tepat dari array akan terletak di antara rendah dan tinggi; Cari elemen maksimum array dalam jarak rendah dan tinggi; Oleh kerana pengindeksan adalah 1 berasaskan jadi elemen semak pada indeks I - 1; Kembalikan nilai tengah maksimum yang mungkin dari array selepas memadam elemen K tepat dari array; Kod pemacu", "code": "function maximum_middle_value ( n , k , arr ) { let ans = - 1 ; let low = Math . floor ( ( n + 1 - k ) / 2 ) ; let high = Math . floor ( ( ( n + 1 - k ) / 2 ) + k ) ; for ( let i = low ; i <= high ; i ++ ) { ans = Math . max ( ans , arr [ i - 1 ] ) ; } return ans ; } let n = 5 , k = 2 ; let arr = [ 9 , 5 , 3 , 7 , 10 ] ; document . write ( maximum_middle_value ( n , k , arr ) + \" \" ) ; n = 9 ; k = 3 ; let arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] ; document . write ( maximum_middle_value ( n , k , arr1 ) + \" \" ) ;"}
{"text": "Carian Ternary | Berfungsi untuk melakukan carian ternary; Cari Mid1 dan Mid2; Semak sama ada kunci hadir di mana -mana pertengahan; Oleh kerana kunci tidak hadir pada pertengahan, periksa di mana rantau ia hadir kemudian ulangi operasi carian di rantau itu; Kunci terletak di antara L dan MID1; Kunci terletak di antara Mid2 dan R; Kuncinya terletak di antara Mid1 dan Mid2; Kunci tidak dijumpai; Dapatkan array jenis array jika tidak disusun; Indeks permulaan; panjang array; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya", "code": "function ternarySearch ( l , r , key , ar ) { if ( r >= l ) { let mid1 = l + parseInt ( ( r - l ) / 3 , 10 ) ; let mid2 = r - parseInt ( ( r - l ) / 3 , 10 ) ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) { return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else { return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } } return - 1 ; } let l , r , p , key ; let ar = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ; l = 0 ; r = 9 ; key = 5 ; p = ternarySearch ( l , r , key , ar ) ; document . write ( \" \" + key + \" \" + p + \" \" ) ; key = 50 ; p = ternarySearch ( l , r , key , ar ) ; document . write ( \" \" + key + \" \" + p ) ;"}
{"text": "Bilangan minimum mata yang akan dikeluarkan untuk mendapatkan mata yang tinggal di satu sisi paksi | Berfungsi untuk mencari bilangan minimum mata; Bilangan mata di sebelah kiri y - paksi. ; Bilangan mata di sebelah kanan paksi y. ; Bilangan mata di atas x - paksi. ; Bilangan mata di bawah x - paksi. ; Kod pemacu", "code": "function findmin ( p , n ) { let a = 0 , b = 0 , c = 0 , d = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( p [ i ] [ 0 ] <= 0 ) a ++ ; else if ( p [ i ] [ 0 ] >= 0 ) b ++ ; if ( p [ i ] [ 1 ] >= 0 ) c ++ ; else if ( p [ i ] [ 1 ] <= 0 ) d ++ ; } return Math . min ( Math . min ( a , b ) , Math . min ( c , d ) ) ; } let p = [ [ 1 , 1 ] , [ 2 , 2 ] , [ - 1 , - 1 ] , [ - 2 , 2 ] ] let n = p . length ; document . write ( findmin ( p , n ) ) ;"}
{"text": "Bilangan maksimum pengurangan pasangan yang mungkin pada triplet tertentu | Fungsi untuk mengira bilangan maksimum pengurangan pasangan yang mungkin pada triplet tertentu; Tukar mereka menjadi array; Kedai kiraan operasi; Susun array; Jika dua elemen array pertama berkurangan kepada 0; Memohon operasi; Kiraan kenaikan; Cetak kiraan maksimum; Diberikan triplet", "code": "function maxOps ( a , b , c ) { let arr = [ a , b , c ] ; let count = 0 ; while ( 1 ) { arr . sort ( ) ; if ( ! arr [ 0 ] && ! arr [ 1 ] ) break ; arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ; count += 1 ; } document . write ( count ) ; } let a = 4 , b = 3 , c = 2 ; maxOps ( a , b , c ) ;"}
{"text": "Kes | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan rentetan yang disusun; Untuk menyimpan frekuensi huruf kecil dan aksara huruf besar dalam rentetan yang diberikan; Jika watak semasa adalah huruf kecil maka kenaikan kekerapannya dalam array yang lebih rendah []; Lain kenaikan dalam array atas []; Petunjuk yang menunjuk pada huruf kecil terkecil dan watak -watak huruf kecil terkecil masing -masing dalam rentetan yang diberikan; Untuk setiap watak dalam rentetan yang diberikan; Jika watak semasa adalah huruf kecil kemudian gantikannya dengan watak kecil terkecil yang tersedia; Pengurangan kekerapan watak yang digunakan; Lain menggantikannya dengan watak huruf kecil terkecil yang ada; Pengurangan kekerapan watak yang digunakan; Kembalikan rentetan yang disusun; Kod pemacu", "code": "var MAX = 26 ; function getSortedString ( s , n ) { var lower = Array ( MAX ) . fill ( 0 ) ; var upper = Array ( MAX ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( ( s [ i ] ) == s [ i ] . toLowerCase ( ) ) lower [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; else if ( s [ i ] = s [ i ] . toUpperCase ( ) ) upper [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } var i = 0 , j = 0 ; while ( i < MAX && lower [ i ] == 0 ) i ++ ; while ( j < MAX && upper [ j ] == 0 ) j ++ ; for ( var k = 0 ; k < n ; k ++ ) { if ( s [ k ] == s [ k ] . toLowerCase ( ) ) { while ( lower [ i ] == 0 ) i ++ ; s [ k ] = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; lower [ i ] -- ; } else if ( s [ k ] == s [ k ] . toUpperCase ( ) ) { while ( upper [ j ] == 0 ) j ++ ; s [ k ] = String . fromCharCode ( j + ' ' . charCodeAt ( 0 ) ) ; upper [ j ] -- ; } } return s . join ( ' ' ) ; } var s = \" \" ; var n = s . length ; document . write ( getSortedString ( s . split ( ' ' ) , n ) ) ;"}
{"text": "Cetak watak dan frekuensi mereka mengikut urutan kejadian | Pelaksanaan JavaScript untuk mencetak watak dan kekerapannya dalam rangka kejadiannya; berfungsi untuk mencetak watak dan kekerapannya mengikut urutan kejadiannya; saiz rentetan 'str'; 'freq []' dilaksanakan sebagai jadual hash; mengumpul kekerapan setiap watak dalam 'str'; melintasi 'str' dari kiri ke kanan; Jika kekerapan watak str. Charat (i) tidak sama dengan 0; Cetak watak bersama kekerapannya; Kemas kini kekerapan STR. Charat (i) hingga 0 supaya watak yang sama tidak dicetak lagi; Program Pemandu untuk diuji di atas", "code": "let SIZE = 26 ; function printCharWithFreq ( str ) { let n = str . length ; let freq = new Array ( SIZE ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] != 0 ) { document . write ( str [ i ] ) ; document . write ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] + \" \" ) ; freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = 0 ; } } } let str = \" \" ; printCharWithFreq ( str ) ;"}
{"text": "Kata -kata terbalik dalam rentetan yang diberikan | Program JavaScript untuk membalikkan rentetan", "code": "var s = [ \" \" , \" \" , \" \" , \" \" , \" \" , \" \" ] ; var ans = \" \" ; for ( var i = 5 ; i >= 0 ; i -- ) { ans += s [ i ] + \" \" ; } document . write ( \" \" + \" \" ) ; document . write ( ans . slice ( 0 , ans . length - 1 ) ) ;"}
{"text": "Mengasingkan Perdana dan Bukan | Berfungsi untuk menjana nombor perdana menggunakan ayak eratosthenes; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Berfungsi untuk memisahkan prima dan bukan prima; Menjana semua prima sehingga 10 ^; Memulakan kiri dan kanan; Melintasi array; Peningkatan kiri manakala elemen array di sebelah kiri adalah perdana; Pengurangan betul manakala elemen array di sebelah kanan adalah bukan perdana; Jika kiri <kanan, kemudian swap arr [kiri] dan arr [kanan]; Swap arr [kiri] dan arr [kanan]; Cetak array terasing; Kod pemacu; Panggilan fungsi", "code": "function SieveOfEratosthenes ( prime , n ) { for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } function segregatePrimeNonPrime ( prime , arr , N ) { SieveOfEratosthenes ( prime , 10000000 ) ; let left = 0 , right = N - 1 ; while ( left < right ) { while ( prime [ arr [ left ] ] ) left ++ ; while ( ! prime [ arr [ right ] ] ) right -- ; if ( left < right ) { let temp = arr [ left ] ; arr [ left ] = arr [ right ] ; arr [ right ] = temp ; left ++ ; right -- ; } } for ( let i = 0 ; i < N ; i ++ ) document . write ( arr [ i ] + \" \" ) ; } let prime = Array . from ( { length : 10000001 } , ( _ , i ) => true ) ; let arr = [ 2 , 3 , 4 , 6 , 7 , 8 , 9 , 10 ] ; let N = arr . length ; segregatePrimeNonPrime ( prime , arr , N ) ;"}
{"text": "Hitung kedalaman pokok binari penuh dari preorder | berfungsi untuk mengembalikan maksimum ketinggian subtree kiri atau ketinggian subtree kanan; ketinggian calc subtree kiri (dalam preorder kiri subtree diproses sebelum kanan); ketinggian calc subtree kanan; Pembalut ke atas findDepThrec (); Program Pemandu", "code": "function findDepthRec ( tree , n , index ) { if ( index >= n tree [ index ] == ' ' ) return 0 ; index ++ ; let left = findDepthRec ( tree , n , index ) ; index ++ ; let right = findDepthRec ( tree , n , index ) ; return Math . max ( left , right ) + 1 ; } function findDepth ( tree , n ) { let index = 0 ; return ( findDepthRec ( tree , n , index ) ) ; } let tree = \" \" . split ( ' ' ) ; let n = tree . length ; document . write ( findDepth ( tree , n ) ) ;"}
{"text": "Nombor terbesar di BST yang kurang daripada atau sama dengan N | Struktur nod; Untuk membuat nod BST baru; Untuk memasukkan nod baru di BST; Jika pokok kosong kembali nod baru; Jika kunci kurang atau lebih besar maka nilai nod maka mengulangi pokok itu; Kembalikan penunjuk nod (tidak berubah); fungsi untuk mencari nilai maksimum kurang kemudian n; Kes asas; Jika nilai root lebih kecil, cuba subtree kanan; Jika kekunci Root lebih besar, nilai pulangan dari subtree kiri. ; Kod pemacu; Mencipta BST * 5 / \\ 2 12 / \\ / \\ 1 3 9 21 / \\ 19 25", "code": "class Node { constructor ( ) { this . key = 0 ; this . left = null , this . right = null ; } } function newNode ( item ) { var temp = new Node ( ) ; temp . key = item ; temp . left = null ; temp . right = null ; return temp ; } function insert ( node , key ) { if ( node == null ) return newNode ( key ) ; if ( key < node . key ) node . left = insert ( node . left , key ) ; else if ( key > node . key ) node . right = insert ( node . right , key ) ; return node ; } function findMaxforN ( root , N ) { if ( root == null ) return - 1 ; if ( root . key == N ) return N ; else if ( root . key < N ) { var k = findMaxforN ( root . right , N ) ; if ( k == - 1 ) return root . key ; else return k ; } else if ( root . key > N ) return findMaxforN ( root . left , N ) ; return - 1 ; } var N = 4 ; var root = null ; root = insert ( root , 25 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; document . write ( findMaxforN ( root , N ) ) ;"}
{"text": "Unsur maksimum antara dua nod BST | Program JavaScript untuk mencari elemen maksimum di jalan antara dua nod pokok carian binari. ; Buat dan kembalikan penunjuk nod baru. ; Masukkan nod baru dalam pokok carian binari. ; Kembalikan elemen maksimum antara nod dan nenek moyangnya. ; Melintasi jalan antara ansektor dan nod dan mencari elemen maksimum. ; Pulangan elemen maksimum di jalan antara dua nod yang diberikan BST. ; Mencari LCA Node X dan Node Y; Memeriksa jika kedua -dua nod terletak di sebelah kiri ibu bapa p. ; Memeriksa jika kedua -dua nod terletak di sebelah kanan ibu bapa p. ; Kembalikan maksimum elemen maksimum berlaku di jalan dari nenek moyang ke kedua -dua nod. ; Kod pemacu; Mewujudkan akar pokok carian binari; Memasukkan nod dalam pokok carian binari", "code": "class Node { constructor ( val ) { this . data = val ; this . left = null ; this . right = null ; } } function createNode ( x ) { var p = new Node ( ) ; p . data = x ; p . left = p . right = null ; return p ; } function insertNode ( root , x ) { var p = root , q = null ; while ( p != null ) { q = p ; if ( p . data < x ) p = p . right ; else p = p . left ; } if ( q == null ) p = createNode ( x ) ; else { if ( q . data < x ) q . right = createNode ( x ) ; else q . left = createNode ( x ) ; } } function maxelpath ( q , x ) { var p = q ; var mx = - 1 ; while ( p . data != x ) { if ( p . data > x ) { mx = Math . max ( mx , p . data ) ; p = p . left ; } else { mx = Math . max ( mx , p . data ) ; p = p . right ; } } return Math . max ( mx , x ) ; } function maximumElement ( root , x , y ) { var p = root ; while ( ( x < p . data && y < p . data ) || ( x > p . data && y > p . data ) ) { if ( x < p . data && y < p . data ) p = p . left ; else if ( x > p . data && y > p . data ) p = p . right ; } return Math . max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; } var arr = [ 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 ] ; var a = 1 , b = 10 ; var n = arr . length ; var root = createNode ( arr [ 0 ] ) ; for ( i = 1 ; i < n ; i ++ ) insertNode ( root , arr [ i ] ) ; document . write ( maximumElement ( root , a , b ) ) ;"}
{"text": "Pokok binari yang diulurkan | Penyisipan | Penyisipan program JavaScript dalam pokok carian binari berulir. ; Benar jika penunjuk kiri titik kepada pendahulunya dalam inorder traversal; Benar jika penunjuk kanan menunjuk kepada pengganti dalam Inorder Traversal; Masukkan nod dalam pokok berulir binari; Mencari nod dengan nilai yang diberikan; Ibu bapa kunci yang akan dimasukkan; Jika kunci sudah ada, kembali; Mengemas kini penunjuk induk; Bergerak di subtree kiri. ; Bergerak ke Subtree Kanan. ; Buat nod baru; Mengembalikan pengganti inorder menggunakan RTHREAD; Jika RTHREAD ditetapkan, kita dapat dengan cepat mencari; Lain kembali anak paling kiri dari subtree kanan; Mencetak pokok berulir; Mencapai nod paling kiri; Satu demi satu pengganti prvar; Program Pemandu", "code": "class Node { constructor ( ) { this . left = null , this . right = null ; this . info = 0 ; this . lthread = false ; this . rthread = false ; } } function insert ( root , ikey ) { var ptr = root ; var par = null ; while ( ptr != null ) { if ( ikey == ( ptr . info ) ) { document . write ( \" \" ) ; return root ; } par = ptr ; if ( ikey < ptr . info ) { if ( ptr . lthread == false ) ptr = ptr . left ; else break ; } else { if ( ptr . rthread == false ) ptr = ptr . right ; else break ; } } var tmp = new Node ( ) ; tmp . info = ikey ; tmp . lthread = true ; tmp . rthread = true ; if ( par == null ) { root = tmp ; tmp . left = null ; tmp . right = null ; } else if ( ikey < ( par . info ) ) { tmp . left = par . left ; tmp . right = par ; par . lthread = false ; par . left = tmp ; } else { tmp . left = par ; tmp . right = par . right ; par . rthread = false ; par . right = tmp ; } return root ; } function inorderSuccessor ( ptr ) { if ( ptr . rthread == true ) return ptr . right ; ptr = ptr . right ; while ( ptr . lthread == false ) ptr = ptr . left ; return ptr ; } function inorder ( root ) { if ( root == null ) document . write ( \" \" ) ; var ptr = root ; while ( ptr . lthread == false ) ptr = ptr . left ; while ( ptr != null ) { document . write ( ptr . info + \" \" ) ; ptr = inorderSuccessor ( ptr ) ; } } var root = null ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; inorder ( root ) ;"}
{"text": "Pohon Carian Binari Bertulung | Penghapusan |  ; Benar jika penunjuk kiri titik kepada pendahulunya dalam inorder traversal; Benar jika penunjuk yang betul menunjukkan kepada pendahuluan dalam inorder traversal", "code": "class Node { constructor ( ) { this . left = null , this . right = null ; this . info = 0 ; this . lthread = false ; this . rthread = false ; } }"}
{"text": "Semak simetri mendatar dan menegak dalam matriks binari | Program JavaScript untuk mencari jika matriks adalah simetri. ; Memulakan sebagai simetri mendatar dan menegak. ; Memeriksa simetri mendatar. Kami membandingkan baris pertama dengan baris terakhir, baris kedua dengan barisan terakhir kedua dan sebagainya. ; Memeriksa setiap sel lajur. ; Semak jika setiap sel adalah sama; Memeriksa simetri menegak. Kami membandingkan lajur pertama dengan lajur terakhir, xolumn kedua dengan lajur terakhir kedua dan sebagainya. ; Memeriksa setiap sel baris. ; Semak jika setiap sel adalah sama; Kod pemacu", "code": "function checkHV ( arr , N , M ) { let horizontal = true ; let vertical = true ; for ( let i = 0 , k = N - 1 ; i < parseInt ( N / 2 , 10 ) ; i ++ , k -- ) { for ( let j = 0 ; j < M ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } for ( let i = 0 , k = M - 1 ; i < parseInt ( M / 2 , 10 ) ; i ++ , k -- ) { for ( let j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } if ( ! horizontal && ! vertical ) document . write ( \" \" ) ; else if ( horizontal && ! vertical ) document . write ( \" \" ) ; else if ( vertical && ! horizontal ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let mat = [ [ 1 , 0 , 1 ] , [ 0 , 0 , 0 ] , [ 1 , 0 , 1 ] ] ; checkHV ( mat , 3 , 3 ) ;"}
{"text": "Gantikan setiap elemen matriks dengan maksimum GCD baris atau lajur | Program JavaScript untuk menggantikan setiap elemen dengan maksimum GCD baris atau lajur. ; mengembalikan pembahagi biasa dua nombor; Mencari GCD setiap baris dan lajur dan menggantikan dengan setiap elemen dengan maksimum GCD baris atau lajur. ; Mengira GCD setiap baris dan setiap lajur dalam O (Mn) dan simpan dalam tatasusunan. ; Menggantikan elemen matriks; Program Pemandu", "code": "let R = 3 ; let C = 4 ; function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } function replacematrix ( mat , n , m ) { let rgcd = new Array ( R ) ; rgcd . fill ( 0 ) ; let cgcd = new Array ( C ) ; cgcd . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) ; } } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = Math . max ( rgcd [ i ] , cgcd [ j ] ) ; } let m = [ [ 1 , 2 , 3 , 3 ] , [ 4 , 5 , 6 , 6 ] , [ 7 , 8 , 9 , 9 ] ] ; replacematrix ( m , R , C ) ; for ( let i = 0 ; i < R ; i ++ ) { for ( let j = 0 ; j < C ; j ++ ) document . write ( m [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; }"}
{"text": "Program untuk penambahan dua matriks | Program JavaScript untuk penambahan dua matriks; Fungsi ini menambah [] [] dan b [] [], dan menyimpan hasil dalam c [] []; Kod pemacu", "code": "let N = 4 ; function add ( A , B , C ) { let i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } let A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; let B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; let C = new Array ( N ) ; for ( let k = 0 ; k < N ; k ++ ) C [ k ] = new Array ( N ) ; let i , j ; add ( A , B , C ) ; document . write ( \" \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( C [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; }"}
{"text": "Program untuk pengurangan matriks | Program JavaScript untuk pengurangan matriks; Fungsi ini menolak B [] [] dari [] [], dan menyimpan hasil dalam C [] []; Kod pemacu", "code": "var N = 4 ; function subtract ( A , B , C ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var C = Array . from ( Array ( N ) , ( ) => Array ( N ) ) ; var i , j ; subtract ( A , B , C ) ; document . write ( \" \" + \" \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( C [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; }"}
{"text": "Cari titik tetap (nilai sama dengan indeks) dalam array yang diberikan | Program JavaScript untuk memeriksa titik tetap dalam array menggunakan carian linear; Jika tiada titik tetap hadir kemudian kembali - 1; Kod pemacu", "code": "function linearSearch ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; } let arr = [ - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 ] ; let n = arr . length ; document . write ( \" \" + linearSearch ( arr , n ) ) ;"}
{"text": "Cari titik tetap (nilai sama dengan indeks) dalam array yang diberikan | Program JavaScript untuk memeriksa titik tetap dalam array menggunakan carian binari; rendah + (tinggi - rendah) / 2; ; Kembali - 1 jika tiada titik tetap; Program Pemandu", "code": "function binarySearch ( arr , low , high ) { if ( high >= low ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; } let arr = [ - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 ] ; let n = arr . length ; document . write ( \" \" + binarySearch ( arr , 0 , n - 1 ) ) ;"}
{"text": "Jumlah maksimum triplet dalam array | Program JavaScript untuk mencari jumlah triplet maksimum; Memulakan jumlah dengan int_min; Kod pemacu", "code": "function maxTripletSum ( arr , n ) { let sum = - 1000000 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; } let arr = [ 1 , 0 , 8 , 6 , 4 , 2 ] ; let n = arr . length ; document . write ( maxTripletSum ( arr , n ) ) ;"}
{"text": "Jumlah maksimum triplet dalam array | Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya tiga elemen dalam ARR []. ; Susun array yang diberikan; Selepas menyusun array. Tambah tiga elemen terakhir dari array yang diberikan; Kod yang didorong", "code": "function maxTripletSum ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; } let arr = [ 1 , 0 , 8 , 6 , 4 , 2 ] ; let n = arr . length ; document . write ( maxTripletSum ( arr , n ) ) ;"}
{"text": "Jumlah maksimum triplet dalam array | Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya tiga elemen dalam ARR []. ; Memulakan elemen maksimum maksimum dan maksimum maksimum maksimum; Mengemas kini elemen maksimum maksimum dan ketiga; Mengemas kini elemen maksimum maksimum dan ketiga; Mengemas kini elemen maksimum ketiga; Kod yang didorong", "code": "function maxTripletSum ( arr , n ) { let maxA = Number . MIN_SAFE_INTEGER ; let maxB = Number . MIN_SAFE_INTEGER ; let maxC = Number . MIN_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; } let arr = [ 1 , 0 , 8 , 6 , 4 , 2 ] ; let n = arr . length ; document . write ( maxTripletSum ( arr , n ) ) ;"}
{"text": "Carian Linear | Kod JavaScript ke Linearly Cari x dalam ARR []. Jika x hadir kemudian kembalikan lokasi, jika tidak, pulangan - 1; Kod pemacu; Panggilan fungsi", "code": "function search ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; } let arr = [ 2 , 3 , 4 , 10 , 40 ] ; let x = 10 ; let n = arr . length ; let result = search ( arr , n , x ) ; ( result == - 1 ) ? document . write ( \" \" ) : document . write ( \" \" + result ) ;"}
{"text": "Carian Linear | Program JavaScript untuk carian linear; Jalankan gelung dari 0 ke kanan; Jika search_element ditemui dengan pembolehubah kiri; Jika search_element ditemui dengan pemboleh ubah yang betul; Jika elemen tidak dijumpai; Kod pemacu; Panggilan fungsi", "code": "function search ( arr , search_Element ) { let left = 0 ; let length = arr . length ; let right = length - 1 ; let position = - 1 ; for ( left = 0 ; left <= right ; ) { if ( arr [ left ] == search_Element ) { position = left ; document . write ( \" \" + ( position + 1 ) + \" \" + ( left + 1 ) + \" \" ) ; break ; } if ( arr [ right ] == search_Element ) { position = right ; document . write ( \" \" + ( position + 1 ) + \" \" + ( length - right ) + \" \" ) ; break ; } left ++ ; right -- ; } if ( position == - 1 ) document . write ( \" \" + left + \" \" ) ; } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let search_element = 5 ; search ( arr , search_element ) ;"}
{"text": "Mengira jenis | Fungsi utama yang menyusun rentetan yang diberikan [] dalam susunan abjad; Pelbagai watak output yang akan menyusun ARR; Buat array kiraan untuk menyimpan kiraan aksara inidividul dan memulakan array kiraan sebagai 0; menyimpan kiraan setiap watak; Tukar kiraan [i] supaya kiraan [i] kini mengandungi kedudukan sebenar watak ini dalam pelbagai output; Bina pelbagai watak output untuk menjadikannya stabil, kami beroperasi dalam urutan terbalik. ; Salin array output ke ARR, supaya ARR kini mengandungi aksara yang disusun; Kaedah Pemandu", "code": "function sort ( arr ) { var n = arr . length ; var output = Array . from ( { length : n } , ( _ , i ) => 0 ) ; var count = Array . from ( { length : 256 } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] . charCodeAt ( 0 ) ] ; for ( var i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( var i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] . charCodeAt ( 0 ) ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] . charCodeAt ( 0 ) ] ; } for ( var i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; return arr ; } var arr = [ ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' ] ; arr = sort ( arr ) ; document . write ( \" \" ) ; for ( var i = 0 ; i < arr . length ; ++ i ) document . write ( arr [ i ] ) ; cript"}
{"text": "Mengira jenis | Fungsi yang menyusun ARR []; berfungsi untuk mencetak array; Kod pemacu", "code": "function countSort ( arr ) { var max = Math . max . apply ( Math , arr ) ; var min = Math . min . apply ( Math , arr ) ; var range = max - min + 1 ; var count = Array . from ( { length : range } , ( _ , i ) => 0 ) ; var output = Array . from ( { length : arr . length } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < arr . length ; i ++ ) { count [ arr [ i ] - min ] ++ ; } for ( i = 1 ; i < count . length ; i ++ ) { count [ i ] += count [ i - 1 ] ; } for ( i = arr . length - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] - min ] - 1 ] = arr [ i ] ; count [ arr [ i ] - min ] -- ; } for ( i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = output [ i ] ; } } function printArray ( arr ) { for ( i = 0 ; i < arr . length ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; } document . write ( ' ' ) ; } var arr = [ - 5 , - 10 , 0 , - 3 , 8 , 5 , - 1 , 10 ] ; countSort ( arr ) ; printArray ( arr ) ;"}
{"text": "Koefisien binomial | DP | Pulangan nilai pekali binomial c (n, k); Kes asas; Berulang; Program pemacu untuk menguji fungsi di atas", "code": "function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; } var n = 5 , k = 2 ; document . write ( \" \" + n + \" \" + k + \" \" + binomialCoeff ( n , k ) ) ;"}
{"text": "Koefisien binomial | DP | Program JavaScript untuk Penyelesaian Pengaturcaraan Dinamik Dioptimumkan Ruang Koefisien Binomial; NC0 adalah 1; Kirakan baris seterusnya segitiga Pascal menggunakan baris sebelumnya; Kod pemacu", "code": "function binomialCoeff ( n , k ) { let C = new Array ( k + 1 ) ; C . fill ( 0 ) ; C [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } let n = 5 , k = 2 ; document . write ( \" \" + n + \" \" + k + \" \" + binomialCoeff ( n , k ) ) ;"}
{"text": "Masalah Partition | DP | Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah semua elemen; Permulaan array bahagian sebagai 0; Isi jadual partition dengan cara bawah; Unsur yang akan dimasukkan dalam jumlah tidak boleh lebih besar daripada jumlahnya; Semak jika jumlah - arr [i] boleh dibentuk dari subset menggunakan elemen sebelum indeks I; Kod pemacu; Panggilan fungsi", "code": "function findPartiion ( arr , n ) { let sum = 0 ; let i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; let part = new Array ( parseInt ( sum / 2 + 1 , 10 ) ) ; for ( i = 0 ; i <= parseInt ( sum / 2 , 10 ) ; i ++ ) { part [ i ] = false ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = parseInt ( sum / 2 , 10 ) ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ parseInt ( sum / 2 , 10 ) ] ; } let arr = [ 1 , 3 , 3 , 2 , 3 , 2 ] ; let n = arr . length ; if ( findPartiion ( arr , n ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text": "Pengaturcaraan Dinamik | Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Kod pemacu", "code": "function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } let set = [ 3 , 34 , 4 , 12 , 5 , 2 ] ; let sum = 9 ; let n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Pengaturcaraan Dinamik | Pulangan benar jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara Botton; Jadual Cetak; Kod pemacu", "code": "function isSubsetSum ( set , n , sum ) { let subset = new Array ( sum + 1 ) ; for ( let i = 0 ; i < sum + 1 ; i ++ ) { subset [ i ] = new Array ( sum + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { subset [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ; for ( let i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ; for ( let i = 1 ; i <= sum ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } } for ( int i = 0 ; i <= sum ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) System . out . println ( subset [ i ] [ j ] ) ; } return subset [ sum ] [ n ] ; } let set = [ 3 , 34 , 4 , 12 , 5 , 2 ] ; let sum = 9 ; let n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Fungsi rekursif yang mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7; Memulakan hasil; Cuba semua rehat yang mungkin - mata untuk mana -mana kekunci n, kita perlu gelung dari n - 3 kekunci kembali ke 1 keystroke untuk mencari breakpoint 'b' selepas itu kita akan mempunyai ctrl - a, ctrl - c dan kemudian hanya ctrl - v sepanjang jalan. ; Jika titik putus adalah s pada b 'th keystroke maka rentetan optimum akan mempunyai panjang (n-b-1)*skrin [b-1]; ; Kod pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "function findoptimal ( N ) { if ( N <= 6 ) return N ; let max = 0 ; let b ; for ( b = N - 3 ; b >= 1 ; b -- ) { let curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; } let N ; for ( N = 1 ; N <= 20 ; N ++ ) document . write ( \" \" + N + \" \" + findoptimal ( N ) + \" \" ) ;"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Fungsi ini mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7; Array untuk menyimpan hasil subproblem; Untuk memilih titik putus; Memulakan array panjang optimum untuk uptil 6 strok input; Selesaikan semua subproblem dengan cara bawah; Memulakan panjang rentetan optimum untuk ketukan n; Untuk mana -mana kekunci n, kita perlu gelung dari n - 3 ketukan kembali ke 1 keystroke untuk mencari breakpoint 'b' selepas itu kita akan mempunyai ctrl - a, ctrl - c dan kemudian hanya ctrl - v sepanjang jalan. ; Sekiranya titik putus berada di b 'th keystroke maka rentetan optimum akan mempunyai panjang (n-b-1)*skrin [b-1]; ; Kod pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "function findoptimal ( N ) { if ( N <= 6 ) return N ; let screen = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { screen [ i ] = 0 ; } let b ; let n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { let curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; } let N ; for ( N = 1 ; N <= 20 ; N ++ ) document . write ( \" \" + N + \" \" + findoptimal ( N ) + \" \" ) ;"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Fungsi ini mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7; Array untuk menyimpan hasil subproblem; Untuk memilih titik putus; Memulakan Arus Panjang Optimal untuk Uptil 6 Strok Input. ; Selesaikan semua subproblem dengan cara bawah; Untuk mana -mana kekunci n, kita perlu memilih antara: - 1. Menekan Ctrl - V sekali selepas menyalin A 'S oleh ~ - 3 »Keystrokes. ~ 2. ~ Pressing utrl - V »dua kali ~ selepas menyalin 's yang diperolehi oleh n - 4 ketukan. 3. Menekan Ctrl - V tiga kali selepas menyalin A 'S yang diperolehi oleh N -5 Keystrokes. ; Program pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "function findoptimal ( N ) { if ( N <= 6 ) return N ; let screen = [ ] ; let b ; let n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; } let N ; for ( N = 1 ; N <= 20 ; N ++ ) document . write ( \" \" + N + \" \" + findoptimal ( N ) + \" \" ) ;"}
{"text": "Tulis program untuk mengira POW (x, n) | Fungsi untuk mengira x yang dibangkitkan kepada kuasa y; Kod pemacu", "code": "function power ( x , y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , parseInt ( y / 2 , 10 ) ) * power ( x , parseInt ( y / 2 , 10 ) ) ; else return x * power ( x , parseInt ( y / 2 , 10 ) ) * power ( x , parseInt ( y / 2 , 10 ) ) ; } let x = 2 ; let y = 3 ; document . write ( power ( x , y ) ) ;"}
{"text": "Tulis program untuk mengira POW (x, n) | Berfungsi untuk mengira x yang dibangkitkan kepada kuasa y dalam o (logn)", "code": "function power ( x , y ) { var temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }"}
{"text": "Tulis program untuk mengira POW (x, n) | Kod JavaScript untuk fungsi kuasa lanjutan yang boleh berfungsi untuk var x dan negatif y; Kod pemacu", "code": "function power ( x , y ) { var temp ; if ( y == 0 ) return 1 ; temp = power ( x , parseInt ( y / 2 ) ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } } var x = 2 ; var y = - 3 ; document . write ( power ( x , y ) . toFixed ( 6 ) ) ;"}
{"text": "Tulis program untuk mengira POW (x, n) | Program JavaScript untuk pendekatan di atas; Jika x ^ 0 kembali 1; Jika kita perlu mencari 0 ^ y; Untuk semua kes lain; Kod pemacu", "code": "function power ( x , y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; } var x = 2 ; var y = 3 ; document . write ( power ( x , y ) ) ;"}
{"text": "Tulis program untuk mengira POW (x, n) | Program JavaScript untuk pendekatan di atas; Matematik. pow () adalah fungsi yang mengembalikan nombor terapung; Kod pemacu", "code": "function power ( x , y ) { return parseInt ( Math . pow ( x , y ) ) ; } let x = 2 ; let y = 3 ; document . write ( power ( x , y ) ) ;"}
{"text": "Kaedah Babylon untuk Root Square | Mengembalikan akar kuadrat n. Perhatikan bahawa fungsi itu; Kami menggunakan N sendiri sebagai penghampiran awal ini pasti dapat diperbaiki; E memutuskan tahap ketepatan; Program pemacu untuk menguji fungsi di atas", "code": "function squareRoot ( n ) { let x = n ; let y = 1 ; let e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } let n = 50 ; document . write ( \" \" + n + \" \" + squareRoot ( n ) . toFixed ( 6 ) ) ;"}
{"text": "Purata aliran nombor | Mengembalikan purata baru selepas termasuk x; Mencetak purata aliran nombor; Program pemacu untuk menguji fungsi di atas", "code": "function getAvg ( prev_avg , x , n ) { return ( prev_avg * n + x ) / ( n + 1 ) ; } function streamAvg ( arr , n ) { let avg = 0 ; for ( let i = 0 ; i < n ; i ++ ) { avg = getAvg ( avg , arr [ i ] , i ) ; document . write ( \" \" + ( i + 1 ) + \" \" + avg . toFixed ( 6 ) + \" \" ) ; } return ; } let arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; let n = arr . length ; streamAvg ( arr , n ) ;"}
{"text": "Purata aliran nombor | Program JavaScript untuk mengembalikan purata aliran nombor; Mengembalikan purata baru selepas termasuk x; Mencetak purata aliran nombor; Kod pemacu", "code": "var sum = 0 , n = 0 ; function getAvg ( x ) { sum += x ; n ++ ; return ( sum / n ) ; } function streamAvg ( arr , m ) { var avg = 0 ; for ( i = 0 ; i < m ; i ++ ) { avg = getAvg ( parseInt ( arr [ i ] ) ) ; document . write ( \" \" + ( i + 1 ) + \" \" + avg . toFixed ( 1 ) + \" \" ) ; } return ; } var arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; var m = arr . length ; streamAvg ( arr , m ) ;"}
{"text": "Koefisien Binomial Ruang dan Masa yang cekap | Pulangan nilai pekali binomial c (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Kod pemacu", "code": "function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } let n = 8 ; let k = 2 ; document . write ( \" \" + n + \" \" + k + \" \" + \" \" + \" \" + binomialCoeff ( n , k ) ) ;"}
{"text": "Program yang cekap untuk mencetak semua faktor utama nombor tertentu | Fungsi untuk mencetak semua faktor utama nombor n tertentu; Cetak bilangan 2 s yang membahagikan n; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, cetak saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Kod pemacu", "code": "function primeFactors ( n ) { while ( n % 2 == 0 ) { document . write ( 2 + \" \" ) ; n = Math . floor ( n / 2 ) ; } for ( let i = 3 ; i <= Math . floor ( Math . sqrt ( n ) ) ; i = i + 2 ) { while ( n % i == 0 ) { document . write ( i + \" \" ) ; n = Math . floor ( n / i ) ; } } if ( n > 2 ) document . write ( n + \" \" ) ; } let n = 315 ; primeFactors ( n ) ;"}
{"text": "Cetak semua kemungkinan kombinasi elemen R dalam pelbagai saiz n | Fungsi utama yang mencetak semua kombinasi saiz r dalam arr [] saiz n. Fungsi ini terutamanya menggunakan gabunganUtil (); Arahan sementara untuk menyimpan semua gabungan satu demi satu; Cetak semua kombinasi menggunakan data temprary array [] '; arr [] - -> data array input [] - -> array sementara untuk menyimpan kombinasi semasa & akhir - -> menatap dan mengakhiri indeks dalam arr [] indeks - -> indeks semasa dalam data [] r - -> saiz kombinasi yang akan dicetak; Gabungan semasa sudah siap dicetak, mencetaknya; Gantikan indeks dengan semua elemen yang mungkin. Keadaan \"Akhir - I + 1 = u r - indeks\" memastikan bahawa termasuk satu elemen di indeks akan membuat kombinasi dengan elemen yang tinggal pada kedudukan yang tinggal; Fungsi pemacu untuk memeriksa fungsi di atas", "code": "function printCombination ( arr , n , r ) { let data = new Array ( r ) ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; } function combinationUtil ( arr , data , start , end , index , r ) { if ( index == r ) { for ( let j = 0 ; j < r ; j ++ ) { document . write ( data [ j ] + \" \" ) ; } document . write ( \" \" ) } for ( let i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let r = 3 ; let n = arr . length ; printCombination ( arr , n , r ) ;"}
{"text": "Cetak semua kemungkinan kombinasi elemen R dalam pelbagai saiz n | Fungsi utama yang mencetak semua kombinasi saiz r dalam arr [] saiz n. Fungsi ini terutamanya menggunakan gabunganUtil (); Arahan sementara untuk menyimpan semua gabungan satu demi satu; Cetak semua kombinasi menggunakan data temprary array [] '; arr [] - -> data array input [] - -> array sementara untuk menyimpan kombinasi semasa & akhir - -> menatap dan mengakhiri indeks dalam arr [] indeks - -> indeks semasa dalam data [] r - -> saiz kombinasi yang akan dicetak; Gabungan semasa sudah siap dicetak, mencetaknya; Apabila tidak ada lagi elemen yang ada untuk dimasukkan ke dalam data []; Semasa dimasukkan, letakkan seterusnya di lokasi seterusnya; Semasa dikecualikan, gantikannya dengan seterusnya (perhatikan bahawa i + 1 diluluskan, tetapi indeks tidak berubah); Fungsi pemacu untuk memeriksa fungsi di atas", "code": "function printCombination ( arr , n , r ) { let data = new Array ( r ) ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; } function combinationUtil ( arr , n , r , index , data , i ) { if ( index == r ) { for ( let j = 0 ; j < r ; j ++ ) { document . write ( data [ j ] + \" \" ) ; } document . write ( \" \" ) ; return ; } if ( i >= n ) { return ; } data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ; combinationUtil ( arr , n , r , index , data , i + 1 ) ; } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let r = 3 ; let n = arr . length ; printCombination ( arr , n , r ) ;"}
{"text": "Kira semua kumpulan saiz 2 atau 3 yang mungkin mempunyai jumlah sebagai pelbagai 3 | Mengembalikan kiraan semua kumpulan yang mungkin boleh dibentuk dari unsur -unsur []. ; Buat array C [3] untuk menyimpan bilangan elemen dengan selebihnya 0, 1 dan 2. C [i] akan menyimpan kiraan elemen dengan selebihnya I; Untuk menyimpan hasilnya; Mengira elemen dengan selebihnya 0, 1 dan 2; Kes 3. A: Kumpulan Kumpulan Saiz 2 dari 0 elemen yang tinggal; Kes 3. B: Kumpulan Kumpulan Saiz 2 dengan satu elemen dengan 1 baki dan lain -lain dengan 2 selebihnya; Kes 4. A: Kumpulan Kumpulan Saiz 3 dengan semua 0 elemen yang tinggal; Kes 4. B: Kumpulan Kumpulan Saiz 3 dengan semua 1 elemen yang tinggal; Kes 4. C: Kumpulan Kumpulan Saiz 3 dengan semua 2 elemen yang tinggal; Kes 4. C: Kumpulan Kumpulan Saiz 3 dengan sisa yang berbeza; Mengembalikan jumlah jumlah yang disimpan dalam res; Kod pemacu", "code": "function findgroups ( arr , n ) { let c = [ 0 , 0 , 0 ] ; let i ; let res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * Math . floor ( ( c [ 0 ] - 2 ) ) / 6 ) ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * Math . floor ( ( c [ 1 ] - 2 ) ) / 6 ) ; res += ( Math . floor ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; } let arr = [ 3 , 6 , 7 , 2 , 9 ] ; let n = arr . length ; document . write ( \" \" + findgroups ( arr , n ) ) ;"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Program JavaScript untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Pertama n dalam keadaan di bawah adalah untuk kes di mana n adalah 0; Kod pemacu", "code": "function nextPowerOf2 ( n ) { var count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } var n = 0 ; document . write ( nextPowerOf2 ( n ) ) ;"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Program untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Kod pemacu", "code": "function nextPowerOf2 ( n ) { p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } n = 5 ; document . write ( nextPowerOf2 ( n ) ) ;"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Cari kuasa seterusnya dua untuk n. Jika n sendiri adalah kuasa dua maka pulangan n; Kod pemacu", "code": "function nextPowerOf2 ( n ) { n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n } n = 5 ; document . write ( nextPowerOf2 ( n ) ) ;"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | Berfungsi untuk memisahkan 0 s dan 1 s; Mengira tiada sifar dalam arr; Gelung mengisi ARR dengan 0 sehingga dikira; Gelung mengisi ruang yang tinggal dengan 1; Berfungsi untuk mencetak array terasing; Fungsi pemacu", "code": "function segregate0and1 ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count ++ ; } for ( let i = 0 ; i < count ; i ++ ) arr [ i ] = 0 ; for ( let i = count ; i < n ; i ++ ) arr [ i ] = 1 ; } function print ( arr , n ) { document . write ( \" \" ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + \" \" ) ; } let arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] ; let n = arr . length ; segregate0and1 ( arr , n ) ; print ( arr , n ) ;"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | Berfungsi untuk meletakkan semua 0 s di kiri dan semua 1 s di sebelah kanan; Memulakan indeks kiri dan kanan; Indeks Kiri Peningkatan semasa kita melihat 0 di sebelah kiri; Indeks kanan pengurangan semasa kita melihat 1 di sebelah kanan; Jika kiri lebih kecil daripada kanan maka terdapat 1 di sebelah kiri dan 0 di sebelah kanan. Pertukaran arr [kiri] dan arr [kanan]; Kod pemacu", "code": "function segregate0and1 ( arr , size ) { let left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } } let arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] ; let i , arr_size = arr . length ; segregate0and1 ( arr , arr_size ) ; document . write ( \" \" ) ; for ( i = 0 ; i < 6 ; i ++ ) document . write ( arr [ i ] + \" \" ) ;"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | Berfungsi untuk meletakkan semua 0 s di kiri dan semua 1 s di sebelah kanan; Kod pemacu", "code": "function segregate0and1 ( arr , size ) { let type0 = 0 ; let type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type1 ] = arr [ type1 ] + arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] - arr [ type0 ] ; arr [ type1 ] = arr [ type1 ] - arr [ type0 ] ; type1 -- ; } else type0 ++ ; } } let arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] ; let i , arr_size = arr . length ; segregate0and1 ( arr , arr_size ) ; document . write ( \" \" ) ; for ( i = 0 ; i < arr_size ; i ++ ) document . write ( arr [ i ] + \" \" ) ;"}
{"text": "Unsur -unsur bersebelahan yang berbeza dalam array | Program JavaScript untuk memeriksa sama ada kita boleh membuat jiran berbeza. ; peta yang digunakan untuk mengira kekerapan setiap elemen yang berlaku dalam array; Dalam gelung ini kita mengira kekerapan elemen melalui peta m. ; MX Simpan kekerapan elemen yang paling banyak berlaku dalam array. ; Dalam gelung ini kita mengira kekerapan maksimum dan simpannya dalam MX yang berubah -ubah. ; Dengan menukar kita boleh menyesuaikan array hanya apabila kekerapan elemen yang berlaku kebanyakannya kurang daripada atau sama dengan (n + 1) / 2. ; Program pemacu untuk menguji fungsi di atas", "code": "function distinctAdjacentElement ( a , n ) { let m = new Map ( ) ; for ( let i = 0 ; i < n ; ++ i ) { m [ a [ i ] ] ++ ; if ( m . has ( a [ i ] ) ) { m . set ( a [ i ] , m . get ( a [ i ] ) + 1 ) } else { m . set ( a [ i ] , 1 ) } } let mx = 0 ; for ( let i = 0 ; i < n ; ++ i ) if ( mx < m . get ( a [ i ] ) ) mx = m . get ( a [ i ] ) ; if ( mx > Math . floor ( ( n + 1 ) / 2 ) ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" ) ; } let a = [ 7 , 7 , 7 , 7 ] ; let n = a . length ; distinctAdjacentElement ( a , n ) ;"}
{"text": "Memandangkan array arr [], cari maksimum j | Untuk array arr [], mengembalikan maksimum J a i sedemikian rupa sehingga arr [j]> arr [i]; Kod pemacu", "code": "function maxIndexDiff ( arr , n ) { let maxDiff = - 1 ; let i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; } let arr = [ 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 ] ; let n = arr . length ; let maxDiff = maxIndexDiff ( arr , n ) ; document . write ( maxDiff ) ;"}
{"text": "Memandangkan array arr [], cari maksimum j | Untuk array yang diberikan [] arr, mengira maksimum j a i sedemikian rupa sehingga arr [j] arr [i]; Buat array MaxFromend; Kami menyimpan ini sebagai jawapan semasa dan mencari nombor yang lebih besar lagi ke sebelah kanan; Menjaga jejak perbezaan maksimum indeks", "code": "let v = [ 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 ] ; let n = v . length ; let maxFromEnd = new Array ( n + 1 ) ; for ( let i = 0 ; i < maxFromEnd . length ; i ++ ) maxFromEnd [ i ] = Number . MIN_VALUE ; for ( let i = v . length - 1 ; i >= 0 ; i -- ) { maxFromEnd [ i ] = Math . max ( maxFromEnd [ i + 1 ] , v [ i ] ) ; } let result = 0 ; for ( let i = 0 ; i < v . length ; i ++ ) { let low = i + 1 , high = v . length - 1 , ans = i ; while ( low <= high ) { let mid = parseInt ( ( low + high ) / 2 , 10 ) ; if ( v [ i ] <= maxFromEnd [ mid ] ) { ans = Math . max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } result = Math . max ( result , ans - i ) ; } document . write ( result ) ;"}
{"text": "Cetak elemen array yang berbeza | Program JavaScript untuk mencetak elemen yang disusun. ; Buat set menggunakan elemen array; Cetak kandungan set. ; Kod pemacu", "code": "function printRepeating ( arr , size ) { var s = new Set ( arr ) ; [ ... s ] . sort ( ( a , b ) => a - b ) . forEach ( x => { document . write ( x + \" \" ) } ) ; } var arr = [ 1 , 3 , 2 , 2 , 1 ] ; var n = arr . length ; printRepeating ( arr , n ) ;"}
{"text": "Swap minimum untuk membuat dua tatasusunan sama | Fungsi Mengembalikan bilangan swap minimum yang diperlukan untuk menyusun array kaedah ini diambil dari pos di bawah; Buat pelbagai pasangan di mana elemen pertama adalah elemen array dan elemen kedua adalah kedudukan elemen pertama; Susun array dengan nilai elemen array untuk mendapatkan kedudukan yang betul setiap elemen sebagai elemen kedua pasangan. ; Untuk menjejaki elemen yang dikunjungi. Memulakan semua elemen yang tidak dikunjungi atau palsu. ; Memulakan hasil; Elemen Array Traverse; sudah bertukar dan diperbetulkan atau sudah hadir di pos yang betul; Ketahui bilangan nod dalam kitaran ini dan tambah dalam ANS; Pindah ke Node Next; Kemas kini jawapan dengan menambahkan kitaran semasa. ; Hasil pulangan; Kaedah Mengembalikan bilangan swap minimum untuk membuat array B sama seperti array A; peta untuk menyimpan kedudukan elemen dalam Array B Kami pada dasarnya menyimpan elemen untuk indeks pemetaan. ; Kini kami menyimpan kedudukan array elemen dalam Array B .; Menghidupkan swap minimum untuk menyusun dalam array yang diubah suai b sebagai jawapan akhir; Kod pemacu", "code": "function minSwapsToSort ( arr , n ) { let arrPos = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { arrPos . push ( [ arr [ i ] , i ] ) ; } arrPos . sort ( function ( a , b ) { return a [ 0 ] - b [ 0 ] ; } ) ; let vis = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { vis [ i ] = false ; } let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( vis [ i ] arrPos [ i ] [ 1 ] == i ) continue ; let cycle_size = 0 ; let j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrPos [ j ] [ 1 ] ; cycle_size ++ ; } ans += ( cycle_size - 1 ) ; } return ans ; } function minSwapToMakeArraySame ( a , b , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { mp . set ( b [ i ] , i ) ; } for ( let i = 0 ; i < n ; i ++ ) b [ i ] = mp . get ( a [ i ] ) ; return minSwapsToSort ( b , n ) ; } let a = [ 3 , 6 , 4 , 8 ] ; let b = [ 4 , 6 , 8 , 3 ] ; let n = a . length ; document . write ( minSwapToMakeArraySame ( a , b , n ) ) ;"}
{"text": "K | Berfungsi untuk mencari elemen k - th yang hilang; interating melalui array; Semak jika saya - th dan (i + 1) - elemen tidak berturut -turut; Simpan perbezaan mereka; Semak perbezaan dan diberikan k; Jika dijumpai; Arahan input; K - elemen yang hilang dapat dijumpai dalam array; Fungsi panggilan untuk mencari elemen yang hilang", "code": "function missingK ( a , k , n ) { let difference = 0 , ans = 0 , count = k ; let flag = false ; for ( let i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return - 1 ; } let a = [ 1 , 5 , 11 , 19 ] ; let k = 11 ; let n = a . length ; let missing = missingK ( a , k , n ) ; document . write ( missing ) ;"}
{"text": "Alternatif ganjil dan juga nod dalam senarai yang berkaitan dengan tunggal | nod kelas; Fungsi utiliti untuk mencetak senarai yang dipautkan; Berfungsi untuk membuat newnode dalam senarai LinkedL; Berfungsi untuk memasukkan pada permulaan; Berfungsi untuk menyusun semula nod yang ganjil dan bahkan; Nilai ganjil dalam kedudukan walaupun menunjuk penunjuk ke nod semasa dalam timbunan ganjil; Malah nilai dalam kedudukan ganjil menambah penunjuk ke nod semasa dalam timbunan walaupun; Swap data di bahagian atas dua susunan; Kod pemacu", "code": "class Node { constructor ( ) { this . data = 0 ; this . next = null ; } } function printList ( node ) { while ( node != null ) { document . write ( node . data + \" \" ) ; node = node . next ; } document . write ( ) ; } function newNode ( key ) { var temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } function insertBeg ( head , val ) { var temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; } function rearrangeOddEven ( head ) { var odd = [ ] ; var even = [ ] ; var i = 1 ; while ( head != null ) { if ( head . data % 2 != 0 && i % 2 == 0 ) { odd . push ( head ) ; } else if ( head . data % 2 == 0 && i % 2 != 0 ) { even . push ( head ) ; } head = head . next ; i ++ ; } while ( odd . length > 0 && even . length > 0 ) { var k = odd [ odd . length - 1 ] . data ; odd [ odd . length - 1 ] . data = even [ even . length - 1 ] . data ; even [ even . length - 1 ] . data = k ; odd . pop ( ) ; even . pop ( ) ; } } var head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 1 ) ; document . write ( \" \" ) ; printList ( head ) ; rearrangeOddEven ( head ) ; document . write ( \" \" + \" \" ) ; printList ( head ) ;"}
{"text": "Alternatif ganjil dan juga nod dalam senarai yang berkaitan dengan tunggal | Struktur nod; Fungsi utiliti untuk mencetak senarai yang dipautkan; Berfungsi untuk membuat newnode dalam senarai LinkedL; Berfungsi untuk memasukkan pada permulaan; Berfungsi untuk menyusun semula nod yang ganjil dan bahkan; Langkah 1: Mengasingkan Node Even dan Odd Langkah 2: Split Odd dan juga menyenaraikan Langkah 3: Gabungkan senarai bahkan ke dalam senarai ganjil; Langkah 1: Mengasingkan ganjil dan juga nod; Sandaran penunjuk seterusnya temp; Jika temp adalah ganjil bergerak nod ke permulaan senarai; Pointer Temp Advance; Langkah 2 memecah senarai ke dalam ganjil dan bahkan; Tamatkan senarai ganjil (buat nod terakhir null); Langkah 3: Gabungkan bahkan senarai ke dalam ganjil; Walaupun kedua -dua senarai itu tidak habis sandaran sandaran seterusnya I dan J; PTR menunjuk kepada nod terkini yang ditambah; Advance I dan J Pointers; Senarai ganjil ekzos sebelum walaupun, tambahkan selebihnya senarai yang ganjil. ; Kes di mana senarai ekzos sebelum senarai ganjil ditangani secara automatik kerana kami menggabungkan senarai bahkan ke dalam senarai ganjil; Kod pemacu", "code": "class Node { constructor ( ) { this . data = 0 ; this . next = null ; } } function printList ( node ) { while ( node != null ) { document . write ( node . data + \" \" ) ; node = node . next ; } document . write ( \" \" ) ; } function newNode ( key ) { var temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } function insertBeg ( head , val ) { var temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; } function rearrange ( head ) { var even ; var temp , prev_temp ; var i , j , k , l , ptr = null ; temp = ( head ) . next ; prev_temp = head ; while ( temp != null ) { var x = temp . next ; if ( temp . data % 2 != 0 ) { prev_temp . next = x ; temp . next = ( head ) ; ( head ) = temp ; } else { prev_temp = temp ; } temp = x ; } temp = ( head ) . next ; prev_temp = ( head ) ; while ( temp != null && temp . data % 2 != 0 ) { prev_temp = temp ; temp = temp . next ; } even = temp ; prev_temp . next = null ; i = head ; j = even ; while ( j != null && i != null ) { k = i . next ; l = j . next ; i . next = j ; j . next = k ; ptr = j ; i = k ; j = l ; } if ( i == null ) { ptr . next = j ; } return head ; } var head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 1 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 10 ) ; document . write ( \" \" ) ; printList ( head ) ; document . write ( \" \" ) ; head = rearrange ( head ) ; printList ( head ) ;"}
{"text": "Putar semua elemen matriks kecuali kali pepenjuru k dengan 90 darjah dalam arah arah jam | Berfungsi untuk prlet matriks; Melangkah ke atas baris; Melangkah ke atas lajur; Cetak nilai; Berfungsi untuk melaksanakan pertukaran unsur matriks dengan cara mengikut arah jam; Menyimpan baris terakhir; Menyimpan lajur terakhir; Melakukan swap; Berfungsi untuk memutar unsur -unsur pepenjuru bukan matriks k dalam arah arah jam; Kemas kini K ke K % 4; Melangkah sehingga k positif; Melepasi setiap baris n / 2 - th; Melepasi setiap lajur dari i ke n - i - 1; Semak sama ada elemen di i, j bukan elemen pepenjuru; Melakukan pertukaran; Cetak matriks; Kod pemacu", "code": "function print ( mat ) { for ( let i = 0 ; i < mat . length ; i ++ ) { for ( let j = 0 ; j < mat [ 0 ] . length ; j ++ ) document . write ( mat [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; } } function performSwap ( mat , i , j ) { let N = mat . length ; let ei = N - 1 - i ; let ej = N - 1 - j ; let temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ ej ] [ i ] ; mat [ ej ] [ i ] = mat [ ei ] [ ej ] ; mat [ ei ] [ ej ] = mat [ j ] [ ei ] ; mat [ j ] [ ei ] = temp ; } function rotate ( mat , N , K ) { K = K % 4 ; while ( K -- > 0 ) { for ( let i = 0 ; i < N / 2 ; i ++ ) { for ( let j = i ; j < N - i - 1 ; j ++ ) { if ( i != j && ( i + j ) != N - 1 ) { performSwap ( mat , i , j ) ; } } } } print ( mat ) ; } let K = 5 ; let mat = [ [ 1 , 2 , 3 , 4 ] , [ 6 , 7 , 8 , 9 ] , [ 11 , 12 , 13 , 14 ] , [ 16 , 17 , 18 , 19 ] , ] ; let N = mat . length ; rotate ( mat , N , K ) ;"}
{"text": "Count of Elements yang Kuasa 2 dalam Subarray Julat tertentu untuk QQueries | Pelaksanaan JavaScript untuk mencari unsur -unsur yang merupakan kuasa dua; Awalan [i] akan menyimpan bilangan elemen yang merupakan kuasa dua hingga i (termasuk i). ; Berfungsi untuk mencari julat maksimum yang jumlahnya boleh dibahagikan dengan m. ; Kirakan jumlah awalan; Berfungsi untuk mengembalikan bilangan elemen yang merupakan kuasa dua dalam subarray; Kod pemacu", "code": "let MAX = 10000 ; let prefix = Array . from ( { length : MAX + 1 } , ( _ , i ) => 0 ) ; function isPowerOfTwo ( x ) { if ( x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ) return true ; return false ; } function computePrefix ( n , a ) { if ( isPowerOfTwo ( a [ 0 ] ) ) prefix [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] ; if ( isPowerOfTwo ( a [ i ] ) ) prefix [ i ] ++ ; } } function query ( L , R ) { if ( L == 0 ) return prefix [ R ] ; return prefix [ R ] - prefix [ L - 1 ] ; } let A = [ 3 , 8 , 5 , 2 , 5 , 10 ] ; let N = A . length ; computePrefix ( N , A ) ; document . write ( query ( 0 , 4 ) + \" \" ) ; document . write ( query ( 3 , 5 ) ) ;"}
{"text": "Count of Integral Coordinates yang terletak di dalam persegi | Berfungsi untuk mengira titik integral di dalam persegi; Kod pemacu", "code": "function countIntgralPoints ( x1 , y1 , x2 , y2 ) { document . write ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; } var x1 = 1 , y1 = 1 ; var x2 = 4 , y2 = 4 ; countIntgralPoints ( x1 , y1 , x2 , y2 ) ;"}
{"text": "Cari nombor seterusnya yang mempunyai digit yang berbeza dari nombor N | Berfungsi untuk mencari nombor digit yang berbeza; Gelung untuk mencari digit yang berbeza menggunakan array hash dan bilangan digit; Gelung untuk mencari digit yang paling ketara dari nombor seterusnya; Keadaan untuk memeriksa sama ada nombor itu mungkin dengan bilangan angka yang sama; Keadaan untuk memeriksa sama ada digit yang paling significant yang dikehendaki dijumpai; Gelung untuk mencari digit seterusnya minimum yang tidak hadir dalam nombor; Pengiraan nombor; Syarat untuk memeriksa sama ada nombor itu lebih besar daripada nombor yang diberikan; Kod pemacu", "code": "function findNextNumber ( n ) { let h = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; let i = 0 , msb = n , rem = 0 ; let next_num = - 1 , count = 0 ; while ( msb > 9 ) { rem = msb % 10 ; h [ rem ] = 1 ; msb = Math . floor ( msb / 10 ) ; count ++ ; } h [ msb ] = 1 ; count ++ ; for ( i = msb + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; break ; } } if ( next_num == - 1 ) { for ( i = 1 ; i < msb ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; count ++ ; break ; } } } if ( next_num > 0 ) { for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { msb = i ; break ; } } for ( i = 1 ; i < count ; i ++ ) { next_num = ( ( next_num * 10 ) + msb ) ; } if ( next_num > n ) document . write ( next_num + \" \" ) ; else document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } let n = 2019 ; findNextNumber ( n ) ;"}
{"text": "Cari triplet (a, b, c) supaya 3 * a + 5 * b + 7 * c sama dengan n | Berfungsi untuk mencari triplet (a, b, c) supaya 3 * a + 5 * b + 7 * c ialah n; Melangkah ke atas julat [0, N7]; Melangkah ke atas julat [0, N5]; Cari nilai a; Jika A lebih besar daripada atau sama dengan 0 dan dibahagikan dengan 3; Jika tidak, cetak - 1; Kod pemacu", "code": "function CalculateValues ( N ) { var A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { var A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { document . write ( \" \" + A / 3 + \" \" + B + \" \" + C ) ; return ; } } } document . write ( - 1 ) ; } var N = 19 ; CalculateValues ( 19 ) ;"}
{"text": "Kurangkan jumlah masa yang diambil oleh dua orang untuk melawat bandar -bandar sehingga tidak ada yang bertemu | Berfungsi untuk mencari masa minimum untuk melawat semua bandar sehingga kedua -dua orang tidak pernah bertemu; Memulakan jumlah sebagai 0; Cari elemen maksimum; Melintasi array; Jumlah kenaikan oleh arr [i]; Maksimum maksimum 2 * t dan jumlah; Kod pemacu; Panggilan fungsi", "code": "function minimumTime ( arr , n ) { var sum = 0 ; var T = Math . max ( ... arr ) ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } document . write ( Math . max ( 2 * T , sum ) ) ; } var arr = [ 2 , 8 , 3 ] ; var N = arr . length ; minimumTime ( arr , N ) ;"}
{"text": "Rentetan lexicographically terbesar mungkin dengan membalikkan substring yang mempunyai bilangan 1 s | Berfungsi untuk mencari rentetan maksimum lexicographically dengan membalikkan substrings yang mempunyai bilangan 1 s; Saiz saiz rentetan; Melintasi rentetan; Kira bilangan 1 s; Menyimpan indeks permulaan; Menyimpan indeks akhir; Kiraan kenaikan, apabila 1 ditemui; Melintasi rentetan yang tinggal; Membalikkan rentetan dari indeks permulaan dan akhir; Mencetak rentetan; Kod pemacu", "code": "function lexicographicallyMax ( s ) { var n = s . length ; for ( var i = 0 ; i < n ; i ++ ) { var count = 0 ; var beg = i ; var end = i ; if ( s [ i ] == ' ' ) count ++ ; for ( var j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] == ' ' ) count ++ ; if ( count % 2 == 0 && count != 0 ) { end = j ; break ; } } for ( var i = beg ; i < parseInt ( ( end + 1 ) / 2 ) ; i ++ ) { let temp = s [ i ] ; s [ i ] = s [ end - i + 1 ] ; s [ end - i + 1 ] = temp ; } } document . write ( s . join ( \" \" ) + \" \" ) ; } var S = \" \" . split ( ' ' ) ; lexicographicallyMax ( S ) ;"}
{"text": "Kira pasangan maksimum yang mungkin dari array yang mempunyai jumlah k | Fungsi untuk mengira bilangan maksimum pasangan dari array yang diberikan dengan jumlah k; Susun array dalam urutan yang semakin meningkat; Menyimpan hasil akhir; Memulakan penunjuk kiri dan kanan; TRAVERSE ARRAY Sehingga mula <end; Pengurangan hak oleh 1; Kenaikan ditinggalkan oleh 1; Hasil kenaikan dan poleter kiri oleh 1 dan penunjuk kanan penurunan sebanyak 1; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "function maxPairs ( nums , k ) { nums . sort ( ) ; let result = 0 ; let start = 0 , end = nums . length - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } document . write ( result ) ; } let arr = [ 1 , 2 , 3 , 4 ] ; let K = 5 ; maxPairs ( arr , K ) ;"}
{"text": "Kira pasangan maksimum yang mungkin dari array yang mempunyai jumlah k | Berfungsi untuk mencari bilangan maksimum pasangan dengan jumlah k sedemikian rupa sehingga elemen yang sama tidak dapat digunakan dua kali; Memulakan hashm; Simpan hasil akhir; Melangkah ke atas array nums []; Menurunkan kekerapannya dalam m dan kenaikan hasilnya dengan 1; Meningkatkan kekerapannya dengan 1 jika sudah ada dalam m. Jika tidak, tetapkan kekerapannya kepada 1; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "function maxPairs ( nums , k ) { var m = new Map ( ) ; var result = 0 ; nums . forEach ( i => { if ( m . has ( i ) && m . get ( i ) > 0 ) { m . set ( i , m . get ( i ) - 1 ) ; result ++ ; } else { if ( m . has ( k - i ) ) m . set ( k - i , m . get ( k - i ) + 1 ) else m . set ( k - i , 1 ) } } ) ; document . write ( result ) ; } var arr = [ 1 , 2 , 3 , 4 ] ; var K = 5 ; maxPairs ( arr , K ) ;"}
{"text": "Indeks cetak elemen array yang penyingkirannya menjadikan jumlah ganjil dan bahkan | Fungsi untuk mencari indeks unsur -unsur array yang penyingkirannya menjadikan jumlah elemen array yang ganjil dan juga diindeks sama; Kedai saiz array; Simpan awalan jumlah elemen array indeks ganjil; Simpan awalan jumlah elemen array indeks walaupun; Kemas kini walaupun [0]; Melintasi array yang diberikan; Mengemas kini ganjil [i]; Kemas kini walaupun [i]; Jika indeks semasa adalah nombor yang sama; Kemas kini walaupun [i]; Jika indeks semasa adalah nombor ganjil; Mengemas kini ganjil [i]; Semak sama ada sekurang -kurangnya satu indeks yang dijumpai atau tidak yang memenuhi syarat; Simpan indeks ganjil dengan mengeluarkan indeks 0 - TH; Simpan walaupun indeks jumlah dengan mengeluarkan indeks 0 - Th; Jika p dan q sama; Melintasi array arr; Jika saya adalah nombor yang sama; Kemas kini P dengan mengeluarkan elemen i - th; Kemas kini Q dengan mengeluarkan elemen I - th; Kemas kini Q dengan mengeluarkan elemen I - th; Kemas kini P dengan mengeluarkan elemen i - th; Jika nilai indeks ganjil jumlah sama dengan nilai indeks walaupun jumlah; Tetapkan pemboleh ubah mencari; Cetak indeks semasa; Jika tidak ada indeks yang dijumpai; Cetak tidak mungkin; Kod pemacu", "code": "function removeIndicesToMakeSumEqual ( arr ) { var N = arr . length ; var odd = Array ( N ) . fill ( 0 ) ; var even = Array ( N ) . fill ( 0 ) ; even [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < N ; i ++ ) { odd [ i ] = odd [ i - 1 ] ; even [ i ] = even [ i - 1 ] ; if ( i % 2 == 0 ) { even [ i ] += arr [ i ] ; } else { odd [ i ] += arr [ i ] ; } } var find = false ; var p = odd [ N - 1 ] ; var q = even [ N - 1 ] - arr [ 0 ] ; if ( p == q ) { document . write ( \" \" ) ; find = true ; } for ( i = 1 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else { q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; } if ( p == q ) { find = true ; document . write ( i + \" \" ) ; } } if ( ! find ) { document . write ( - 1 ) ; } } var arr = [ 4 , 1 , 6 , 2 ] ; removeIndicesToMakeSumEqual ( arr ) ;"}
{"text": "Penyingkiran minimum diperlukan untuk membuat bitonic array yang diberikan | Fungsi untuk coutnt elemen array minimum yang diperlukan untuk dikeluarkan untuk membuat bitonic array; Kiri [i]: menyimpan panjang lis sehingga indeks i - th; kanan [i]: menyimpan panjang penurunan seterusnya ke atas julat [i, n]; Kirakan panjang LIS sehingga indeks i - th; Melintasi array sehingga indeks i - th; Jika arr [j] kurang daripada arr [i]; Kemas kini kiri [i]; Kirakan panjang penurunan seterusnya ke atas julat [i, n]; Melintasi kanan [] array; Jika arr [i] lebih besar daripada arr [j]; Kemas kini betul [i]; Kedai panjang array bitonic terpanjang; Traverse kiri [] dan kanan [] array; Kemas kini Maxlen; Fungsi untuk mencetak penyingkiran minimum yang diperlukan untuk membuat bitonic array yang diberikan; Kod pemacu", "code": "function min_element_removal ( arr , N ) { var left = Array ( N ) . fill ( 1 ) ; var right = Array ( N ) . fill ( 1 ) ; for ( var i = 1 ; i < N ; i ++ ) { for ( var j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { left [ i ] = Math . max ( left [ i ] , left [ j ] + 1 ) ; } } } for ( var i = N - 2 ; i >= 0 ; i -- ) { for ( var j = N - 1 ; j > i ; j -- ) { if ( arr [ i ] > arr [ j ] ) { right [ i ] = Math . max ( right [ i ] , right [ j ] + 1 ) ; } } } var maxLen = 0 ; for ( var i = 1 ; i < N - 1 ; i ++ ) { maxLen = Math . max ( maxLen , left [ i ] + right [ i ] - 1 ) ; } document . write ( ( N - maxLen ) + \" \" ) ; } function makeBitonic ( arr , N ) { if ( N == 1 ) { document . write ( \" \" + \" \" ) ; return ; } if ( N == 2 ) { if ( arr [ 0 ] != arr [ 1 ] ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ; return ; } min_element_removal ( arr , N ) ; } var arr = [ 2 , 1 , 1 , 5 , 6 , 2 , 3 , 1 ] ; var N = arr . length ; makeBitonic ( arr , N ) ;"}
{"text": "Count Subarrays mempunyai kiraan yang sama dengan 0 dan 1 S berasal | Fungsi untuk mengira subarray yang mempunyai kiraan yang sama dengan 0 s dan 1 s dengan semua 0 s dan semua 1 dikelompokkan bersama; Menyimpan kiraan subarray; Jika elemen semasa berbeza daripada elemen array seterusnya; Kiraan kenaikan; Hitung kekerapan 1 s dan 0 s; Kiraan kenaikan; Prlet kiraan akhir; Kod pemacu; Panggilan fungsi", "code": "function countSubarrays ( A , N ) { let ans = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( let j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } document . write ( ans + \" \" ) ; } let A = [ 1 , 1 , 0 , 0 , 1 , 0 ] ; let N = A . length ; countSubarrays ( A , N ) ;"}
{"text": "Kiraan quadruples jenis yang diberikan dari array yang diberikan | Program JavaScript pendekatan di atas; lcount [i] [j]: menyimpan kiraan saya di sebelah kiri indeks j; rcount [i] [j]: menyimpan kiraan saya di kanan indeks j; Berfungsi untuk mengira unsur -unsur unik di kiri dan kanan mana -mana indeks; Cari elemen array maksimum; Kirakan jumlah awalan jumlah setiap nilai; Kirakan jumlah akhiran jumlah setiap nilai; Berfungsi untuk mengira kuadruples jenis yang diperlukan; Kod pemacu", "code": "let maxN = 2002 ; let lcount = new Array ( maxN ) ; let rcount = new Array ( maxN ) ; for ( let i = 0 ; i < maxN ; i ++ ) { lcount [ i ] = new Array ( maxN ) ; rcount [ i ] = new Array ( maxN ) ; for ( let j = 0 ; j < maxN ; j ++ ) { lcount [ i ] [ j ] = 0 ; rcount [ i ] [ j ] = 0 ; } } function fill_counts ( a , n ) { let i , j ; let maxA = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxA ) { maxA = a [ i ] ; } } for ( i = 0 ; i < n ; i ++ ) { lcount [ a [ i ] ] [ i ] = 1 ; rcount [ a [ i ] ] [ i ] = 1 ; } for ( i = 0 ; i <= maxA ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) { lcount [ i ] [ j ] = lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ; } for ( j = n - 2 ; j >= 0 ; j -- ) { rcount [ i ] [ j ] = rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ; } } } function countSubsequence ( a , n ) { let i , j ; fill_counts ( a , n ) ; let answer = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n - 1 ; j ++ ) { answer += lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ; } } return answer ; } let a = [ 1 , 2 , 3 , 2 , 1 , 3 , 2 ] ; document . write ( countSubsequence ( a , a . length ) ) ;"}
{"text": "Kurangkan rentetan dengan mengeluarkan kurungan paling luar dari setiap substring primitif | Fungsi untuk menghapuskan tanda kurung paling luar setiap substring primitif dari rentetan yang diberikan; Menyimpan rentetan yang dihasilkan; Menyimpan kiraan tanda kurung yang dibuka; Melintasi rentetan; Jika pembukaan kurungan ditemui dan kiraan mereka melebihi 0; Termasuk watak; Jika penutupan kurungan ditemui dan kiraannya kurang daripada mengira tanda kurung pembukaan; Termasuk watak; Kembali rentetan yang dihasilkan; Kod pemacu", "code": "function removeOuterParentheses ( S ) { let res = \" \" ; let count = 0 ; for ( let c = 0 ; c < S . length ; c ++ ) { if ( S . charAt ( c ) == ' ' && count ++ > 0 ) res += S . charAt ( c ) ; if ( S . charAt ( c ) == ' ' && count -- > 1 ) res += S . charAt ( c ) ; } return res ; } let S = \" \" ; document . write ( removeOuterParentheses ( S ) ) ;"}
{"text": "Panjang subarray terpanjang dengan peningkatan unsur -unsur bersebelahan | Berfungsi untuk mencari subarray terpanjang dengan unsur -unsur bersebelahan yang semakin meningkat; Menyimpan panjang subarray terpanjang yang diperlukan; Menyimpan panjang panjang subarray yang paling lama dari indeks ith; Jika unsur -unsur berturut -turut semakin meningkat dan berbeza dengan 1; Jika tidak; Kemas kini subarray terpanjang yang diperoleh setakat ini; Mengembalikan panjang yang diperoleh; Kod pemacu", "code": "function maxiConsecutiveSubarray ( arr , N ) { let maxi = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { let cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = Math . max ( maxi , cnt ) ; i = j ; } return maxi ; } let N = 11 ; let arr = [ 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 ] ; document . write ( maxiConsecutiveSubarray ( arr , N ) ) ;"}
{"text": "Panjang seterusnya terpanjang yang mempunyai jumlah digit setiap elemen sebagai nombor komposit | Pelaksanaan JavaScript pendekatan di atas; Berfungsi untuk menjana nombor perdana menggunakan ayak eratosthenes; Tetapkan 0 dan 1 sebagai bukan perdana; Jika p adalah perdana; Tetapkan semua gandaan p sebagai bukan perdana; Berfungsi untuk mencari jumlah digit nombor tertentu; Menyimpan jumlah digit; Ekstrak digit dan tambah kepada jumlah; Kembalikan jumlah digit; Berfungsi untuk mencari berikutnya yang paling lama dengan jumlah digit setiap elemen bersamaan dengan nombor komposit; Hitung jumlah digit elemen array semasa; Jika jumlah digit sama dengan 1; Jika jumlah digit adalah perdana; Kod pemacu; Panggilan fungsi", "code": "let N = 100005 ; function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } function digitSum ( number ) { let sum = 0 ; while ( number > 0 ) { sum += ( number % 10 ) ; number = Math . floor ( number / 10 ) ; } return sum ; } function longestCompositeDigitSumSubsequence ( arr , n ) { let count = 0 ; let prime = new Array ( N + 1 ) ; for ( let i = 0 ; i <= N ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , N ) ; for ( let i = 0 ; i < n ; i ++ ) { let res = digitSum ( arr [ i ] ) ; if ( res == 1 ) { continue ; } if ( prime [ res ] == false ) { count ++ ; } } document . write ( count ) ; } let arr = [ 13 , 55 , 7 , 3 , 5 , 1 , 10 , 21 , 233 , 144 , 89 ] ; let n = arr . length ; longestCompositeDigitSumSubsequence ( arr , n ) ;"}
{"text": "Jumlah nod yang seimbang dari pokok binari yang diberikan | Program JavaScript untuk pendekatan di atas; Struktur pokok binari; Berfungsi untuk membuat nod baru; Mengembalikan nod yang dibuat; Berfungsi untuk memasukkan nod di dalam pokok; Penyisipan kiri; Penyisipan kanan; Mengembalikan nod akar; Berfungsi untuk mencari jumlah node yang seimbang di dalam pokok; Kes asas; Cari jumlah subtree kiri; Cari jumlah yang betul; Keadaan node yang seimbang; Keadaan node yang seimbang; Mengembalikan jumlahnya; Berfungsi untuk membina pokok binari; Bentuk nod akar pokok; Masukkan nod ke dalam pokok; Buat nod baru; Masukkan nod; Kembalikan akar pokok; Berfungsi untuk mencari jumlah node yang seimbang; Membina pokok; Menyimpan jumlah node yang seimbang; Panggilan fungsi; Cetak jumlah yang diperlukan; Diberikan nod; Diberikan akar; Diberikan maklumat laluan nod dari akar; Diberikan nilai nod; Panggilan fungsi", "code": "let sum ; class Node { constructor ( data ) { this . left = null ; this . right = null ; this . data = data ; } } function newnode ( data ) { let temp = new Node ( data ) ; return temp ; } function insert ( s , i , N , root , temp ) { if ( i == N ) return temp ; if ( s [ i ] == ' ' ) root . left = insert ( s , i + 1 , N , root . left , temp ) ; else root . right = insert ( s , i + 1 , N , root . right , temp ) ; return root ; } function SBTUtil ( root ) { if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return root . data ; let left = SBTUtil ( root . left ) ; let right = SBTUtil ( root . right ) ; if ( root . left != null && root . right != null ) { if ( ( left % 2 == 0 && right % 2 != 0 ) || ( left % 2 != 0 && right % 2 == 0 ) ) { sum += root . data ; } } return left + right + root . data ; } function build_tree ( R , N , str , values ) { let root = newnode ( R ) ; let i ; for ( i = 0 ; i < N - 1 ; i ++ ) { let s = str [ i ] ; let x = values [ i ] ; let temp = newnode ( x ) ; root = insert ( s , 0 , s . length , root , temp ) ; } return root ; } function speciallyBalancedNodes ( R , N , str , values ) { let root = build_tree ( R , N , str , values ) ; sum = 0 ; SBTUtil ( root ) ; document . write ( sum + \" \" ) ; } let N = 7 ; let R = 12 ; let str = [ \" \" , \" \" , \" \" , \" \" , \" \" , \" \" ] ; let values = [ 17 , 16 , 4 , 9 , 2 , 3 ] ; speciallyBalancedNodes ( R , N , str , values ) ;"}
{"text": "Pasangan yang mempunyai semua pasangan lain yang terletak di antara minimum dan maksimumnya | Fungsi untuk mencari kedudukan pasangan yang meliputi setiap pasangan dalam array arr [] []; Menyimpan indeks pasangan yang dihasilkan; Untuk mengira kejadian; Berulang untuk memeriksa setiap pasangan; Tetapkan kiraan ke 0; Keadaan untuk diperiksa untuk bertindih pasangan; Jika pasangan itu dapat menutup semua pasangan lain maka simpan kedudukannya; Jika kedudukan tidak dijumpai; Jika tidak; Diberikan pelbagai pasangan; Panggilan fungsi", "code": "function position ( arr , N ) { let pos = - 1 ; let count ; for ( let i = 0 ; i < N ; i ++ ) { count = 0 ; for ( let j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == - 1 ) { document . write ( pos ) ; } else { document . write ( pos + 1 ) ; } } let arr = [ [ 3 , 3 ] , [ 1 , 3 ] , [ 2 , 2 ] , [ 2 , 3 ] , [ 1 , 2 ] ] ; let N = arr . length ; position ( arr , N ) ;"}
{"text": "Kurangkan kiraan operasi yang diberikan untuk membuat dua permutasi rentetan yang diberikan antara satu sama lain | Berfungsi untuk meminimumkan kiraan operasi untuk membuat permutasi Str1 dan Str2 antara satu sama lain; Simpan kekerapan setiap watak Str1; Simpan kekerapan setiap watak Str2; Melintasi freq1 [] dan freq2 []; Jika kekerapan watak dalam str1 lebih besar daripada str2; Jika tidak; Simpan jumlah Freq1 []; Simpan jumlah freq2 []; Kod pemacu", "code": "function ctMinEdits ( str1 , str2 ) { let N1 = str1 . length ; let N2 = str2 . length ; let freq1 = new Array ( 256 ) . fill ( 0 ) ; for ( let i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 [ i ] . charCodeAt ( ) ] ++ ; } let freq2 = new Array ( 256 ) . fill ( 0 ) ; for ( let i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 [ i ] . charCodeAt ( ) ] ++ ; } for ( let i = 0 ; i < 256 ; i ++ ) { if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; } else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } } let sum1 = 0 ; let sum2 = 0 ; for ( let i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return Math . max ( sum1 , sum2 ) ; } let str1 = \" \" ; let str2 = \" \" ; document . write ( ctMinEdits ( str1 . split ( ' ' ) , str2 . split ( ' ' ) ) ) ;"}
{"text": "Kiraan pasangan (i, j) dari arrays arr [] & brr [] sedemikian rupa sehingga arr [i] | Fungsi untuk mengira pasangan sedemikian rupa sehingga keadaan yang diberikan berpuas hati; Menyimpan jumlah elemen pada setiap indeks yang sepadan; Cari jumlah setiap indeks kedua -dua array; Kedai kekerapan setiap elemen yang terdapat di Sumarr; Memulakan bilangan pasangan; Tambah mungkin pasangan VAID; Pulangan bilangan pasangan; Diberikan array arr [] dan brr []; Saiz array yang diberikan; Fungsi panggilan", "code": "function CountPairs ( a , b , n ) { var C = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; } var freqCount = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( freqCount . has ( C [ i ] ) ) freqCount . set ( C [ i ] , freqCount . get ( C [ i ] ) + 1 ) else freqCount . set ( C [ i ] , 1 ) } var NoOfPairs = 0 ; freqCount . forEach ( ( value , key ) => { var y = value ; NoOfPairs = NoOfPairs + y * ( y - 1 ) / 2 ; } ) ; document . write ( NoOfPairs ) ; } var arr = [ 1 , 4 , 20 , 3 , 10 , 5 ] ; var brr = [ 9 , 6 , 1 , 7 , 11 , 6 ] ; var N = arr . length ; CountPairs ( arr , brr , N ) ;"}
{"text": "Perubahan dalam median array yang diberikan selepas memadam elemen yang diberikan | Berfungsi untuk mencari perubahan median selepas mengeluarkan elemen dari ARR2 []; Untuk menyimpan median; Jika n adalah ganjil; Jika n juga; Cari elemen semasa dalam ARR1; Padamkan elemen; Pengurangan n; Jika n adalah ganjil; Jika n juga; Cetak perbezaan median yang sepadan; Diberikan susunan; Panggilan fungsi", "code": "function medianChange ( arr1 , arr2 ) { let N = arr1 . length ; let median = [ ] ; if ( ( N & 1 ) ) median . push ( ( arr1 [ Math . floor ( N / 2 ) ] * 1 ) ) ; else median . push ( Math . floor ( ( arr1 [ Math . floor ( N / 2 ) ] + arr1 [ Math . floor ( ( N - 1 ) / 2 ) ] ) / 2 ) ) ; for ( let x = 0 ; x < arr2 . length ; x ++ ) { let it = arr1 . indexOf ( arr2 [ x ] ) ; arr1 . splice ( it , 1 ) ; N -- ; if ( ( N & 1 ) ) { median . push ( arr1 [ Math . floor ( N / 2 ) ] * 1 ) ; } else { median . push ( Math . floor ( ( arr1 [ Math . floor ( N / 2 ) ] + arr1 [ Math . floor ( ( N - 1 ) / 2 ) ] ) / 2 ) ) ; } } for ( let i = 0 ; i < median . length - 1 ; i ++ ) { document . write ( ( median [ i + 1 ] - median [ i ] ) + \" \" ) ; } } let arr1 = [ 2 , 4 , 6 , 8 , 10 ] ; let arr2 = [ 4 , 6 ] ; medianChange ( arr1 , arr2 )"}
{"text": "NFA untuk menerima rentetan yang mempunyai atleast satu watak yang berlaku dalam pelbagai 3 | Pembolehubah NFA yang menjejaki keadaan semasa urus niaga. ; Pemeriksaan ini untuk input tidak sah. ; Fungsi untuk keadaan Q2; Peralihan Negeri 'A' mengambil ke Q4, dan 'B' dan 'C' kekal pada Q2; Fungsi untuk keadaan Q3; Peralihan Negeri 'A' mengambil ke Q3, dan 'B' dan 'C' kekal pada Q4; Fungsi untuk keadaan Q4; Peralihan Negeri 'A' mengambil ke Q2, dan 'B' dan 'C' kekal pada Q3; Fungsi untuk negeri Q5; Peralihan negeri 'B' mengambil ke Q6, dan 'A' dan 'C' kekal pada Q5; Fungsi untuk keadaan Q6; Peralihan Negeri 'B' mengambil Q7, dan 'A' dan 'C' kekal pada Q7; Fungsi untuk negeri Q7; Peralihan Negeri 'B' mengambil ke Q5, dan 'A' dan 'C' kekal pada Q7; Fungsi untuk negeri Q8; Peralihan Negeri 'C' mengambil Q9, dan 'A' dan 'B' kekal pada Q8; Fungsi untuk Negeri Q9; Peralihan Negeri 'C' mengambil ke Q10, dan 'A' dan 'B' kekal pada Q9; Fungsi untuk keadaan Q10; Peralihan Negeri 'C' mengambil ke Q8, dan 'A' dan 'B' kekal pada Q10; Berfungsi untuk memeriksa 3 a; Berfungsi untuk memeriksa 3 b; Berfungsi untuk memeriksa 3 c 's; Kod pemacu; Sekiranya mana -mana negeri adalah benar, iaitu, sama ada bilangan bilangan atau jumlah atau jumlahnya adalah pelbagai tiga, maka rentetan itu diterima", "code": "let nfa = 1 ; let flag = 0 ; function state1 ( c ) { if ( c == ' ' ) nfa = 2 ; else if ( c == ' ' c == ' ' ) nfa = 1 ; else flag = 1 ; } function state2 ( c ) { if ( c == ' ' ) nfa = 3 ; else if ( c == ' ' c == ' ' ) nfa = 2 ; else flag = 1 ; } function state3 ( c ) { if ( c == ' ' ) nfa = 1 ; else if ( c == ' ' c == ' ' ) nfa = 3 ; else flag = 1 ; } function state4 ( c ) { if ( c == ' ' ) nfa = 5 ; else if ( c == ' ' c == ' ' ) nfa = 4 ; else flag = 1 ; } function state5 ( c ) { if ( c == ' ' ) nfa = 6 ; else if ( c == ' ' c == ' ' ) nfa = 5 ; else flag = 1 ; } function state6 ( c ) { if ( c == ' ' ) nfa = 4 ; else if ( c == ' ' c == ' ' ) nfa = 6 ; else flag = 1 ; } function state7 ( c ) { if ( c == ' ' ) nfa = 8 ; else if ( c == ' ' c == ' ' ) nfa = 7 ; else flag = 1 ; } function state8 ( c ) { if ( c == ' ' ) nfa = 9 ; else if ( c == ' ' c == ' ' ) nfa = 8 ; else flag = 1 ; } function state9 ( c ) { if ( c == ' ' ) nfa = 7 ; else if ( c == ' ' c == ' ' ) nfa = 9 ; else flag = 1 ; } function checkA ( s , x ) { for ( let i = 0 ; i < x ; i ++ ) { if ( nfa == 1 ) state1 ( s [ i ] ) ; else if ( nfa == 2 ) state2 ( s [ i ] ) ; else if ( nfa == 3 ) state3 ( s [ i ] ) ; } if ( nfa == 1 ) { return true ; } else { nfa = 4 ; } } function checkB ( s , x ) { for ( let i = 0 ; i < x ; i ++ ) { if ( nfa == 4 ) state4 ( s [ i ] ) ; else if ( nfa == 5 ) state5 ( s [ i ] ) ; else if ( nfa == 6 ) state6 ( s [ i ] ) ; } if ( nfa == 4 ) { return true ; } else { nfa = 7 ; } } function checkC ( s , x ) { for ( let i = 0 ; i < x ; i ++ ) { if ( nfa == 7 ) state7 ( s [ i ] ) ; else if ( nfa == 8 ) state8 ( s [ i ] ) ; else if ( nfa == 9 ) state9 ( s [ i ] ) ; } if ( nfa == 7 ) { return true ; } } let s = \" \" ; let x = 5 ; if ( checkA ( s , x ) || checkB ( s , x ) || checkC ( s , x ) ) { document . write ( \" \" ) ; } else { if ( flag == 0 ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } }"}
{"text": "Kiraan kedudukan sedemikian rupa sehingga semua elemen sebelum ia lebih besar | Fungsi untuk mengira kedudukan supaya semua elemen sebelum ia lebih besar; Count pada mulanya 1 untuk elemen pertama; Minimum awal; Melintasi array; Jika elemen semasa adalah minimum baru; Mengemas kini minimum; Kiraan kenaikan; Kod pemacu", "code": "function getPositionCount ( a , n ) { var count = 1 ; var min = a [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; } var a = [ 5 , 4 , 6 , 1 , 3 , 1 ] ; var n = a . length ; document . write ( getPositionCount ( a , n ) ) ;"}
{"text": "Panjang maksimum L sedemikian rupa sehingga jumlah semua subarray panjang L kurang daripada k | Berfungsi untuk mengembalikan jumlah maksimum dalam subarray saiz k; k mesti lebih besar; Kirakan jumlah tetingkap pertama saiz k; Kirakan jumlah tingkap yang tersisa dengan mengeluarkan elemen pertama tetingkap sebelumnya dan menambah elemen terakhir tetingkap semasa. ; Berfungsi untuk mengembalikan panjang jumlah subarray semua subarray panjang ini kurang daripada atau sama dengan k; Carian binari dari L ke R kerana semua elemen array adalah positif supaya jumlah subarray maksimum meningkat secara monotonik; Semak sama ada jumlah subarray lebih besar daripada k atau tidak; Mengemas kini panjang maksimum; Kod pemacu", "code": "function maxSum ( arr , n , k ) { if ( n < k ) { return - 1 ; } var res = 0 ; for ( i = 0 ; i < k ; i ++ ) res += arr [ i ] ; var curr_sum = res ; for ( i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; res = Math . max ( res , curr_sum ) ; } return res ; } function solve ( arr , n , k ) { var max_len = 0 , l = 0 , r = n , m ; while ( l <= r ) { m = parseInt ( ( l + r ) / 2 ) ; if ( maxSum ( arr , n , m ) > k ) r = m - 1 ; else { l = m + 1 ; max_len = m ; } } return max_len ; } var arr = [ 1 , 2 , 3 , 4 , 5 ] ; var n = arr . length ; var k = 10 ; document . write ( solve ( arr , n , k ) ) ;"}
{"text": "Count of triplets dalam array yang memenuhi syarat -syarat yang diberikan | Pelaksanaan JavaScript pendekatan; Semua penyelesaian yang mungkin dalam persamaan 1 / a + 1 / b + 1 / c = 1; Berfungsi untuk mencari tiga kali ganda; Menyimpan indeks unsur -unsur; Semak jika Y boleh bertindak sebagai elemen tengah triplet dengan penyelesaian yang diberikan 1 / a + 1 / b + 1 / c = 1; Carian binari untuk mencari bilangan nilai yang mungkin bagi elemen pertama; Carian binari untuk mencari bilangan nilai yang mungkin bagi elemen ketiga; Sumbangan kepada jawapannya ialah pendaraban nilai yang mungkin untuk elemen pertama dan ketiga; Kod pemacu", "code": "var MAX = 100001 var ROW = 10 var COl = 3 var indices = Array . from ( Array ( MAX ) , ( ) => new Array ( ) ) ; var test = [ [ 2 , 3 , 6 ] , [ 2 , 4 , 4 ] , [ 2 , 6 , 3 ] , [ 3 , 2 , 6 ] , [ 3 , 3 , 3 ] , [ 3 , 6 , 2 ] , [ 4 , 2 , 4 ] , [ 4 , 4 , 2 ] , [ 6 , 2 , 3 ] , [ 6 , 3 , 2 ] ] ; function find_triplet ( array , n ) { var answer = 0 ; for ( var i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . push ( i ) ; } for ( var i = 0 ; i < n ; i ++ ) { var y = array [ i ] ; for ( var j = 0 ; j < ROW ; j ++ ) { var s = test [ j ] [ 1 ] * y ; if ( s % test [ j ] [ 0 ] != 0 ) continue ; if ( s % test [ j ] [ 2 ] != 0 ) continue ; var x = s / test [ j ] [ 0 ] ; var z = s / test [ j ] [ 2 ] ; if ( x > MAX z > MAX ) continue ; var l = 0 ; var r = indices [ x ] . length - 1 ; var first = - 1 ; while ( l <= r ) { var m = ( l + r ) / 2 ; if ( indices [ x ] [ m ] < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . length - 1 ; var third = - 1 ; while ( l <= r ) { var m = ( l + r ) / 2 ; if ( indices [ z ] [ m ] > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != - 1 && third != - 1 ) { answer += ( first + 1 ) * ( indices [ z ] . length - third ) ; } } } return answer ; } var array = [ 2 , 4 , 5 , 6 , 7 ] ; var n = array . length ; document . write ( find_triplet ( array , n ) ) ;"}
{"text": "Unsur -unsur bersebelahan yang berbeza dalam array binari | Pelaksanaan JavaScript pendekatan di atas; Jika array hanya mempunyai satu elemen, kembali 1; Untuk elemen pertama bandingkan dengan hanya elemen seterusnya; Untuk unsur -unsur yang tersisa berbanding dengan kedua -dua elemen sebelumnya dan seterusnya; Untuk elemen terakhir bandingkan dengan hanya elemen sebelumnya; Kod pemacu", "code": "function distinct ( arr , n ) { let count = 0 ; if ( n == 1 ) return 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; } let arr = [ 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ; let n = arr . length ; document . write ( distinct ( arr , n ) ) ;"}
{"text": "Semak jika pelbagai pasangan boleh disusun dengan menukar pasangan dengan elemen pertama yang berbeza | Berfungsi untuk memeriksa sama ada array disusun atau tidak; Melintasi array arr []; Kembali benar; Fungsi untuk memeriksa sama ada mungkin untuk menyusun array w. r. t. elemen pertama; Menyimpan id elemen pertama; Melintasi array arr []; Jika arr [i]. Kedua tidak sama dengan kumpulan; Jika array disusun; Kod pemacu", "code": "function isSorted ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] > arr [ i - 1 ] [ 0 ] ) { return false ; } } return true ; } function isPossibleToSort ( arr , N ) { let group = arr [ 0 ] [ 1 ] ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 1 ] != group ) { return \" \" ; } } if ( isSorted ( arr , N ) ) { return \" \" ; } else { return \" \" ; } } let arr = [ [ 340000 , 2 ] , [ 15000 , 2 ] , [ 34000 , 2 ] , [ 10000 , 2 ] ] ; let N = arr . length ; document . write ( isPossibleToSort ( arr , N ) ) ;"}
{"text": "Cari skor alpha langkah -langkah yang diberikan (menggunakan BST) | Struktur nod; Berfungsi untuk mengira dan mengembalikan skor alpha perjalanan; Traverse kiri subtree; Kirakan skor alpha langkah semasa; Kemas kini skor Alpha perjalanan; Melintasi subtree kanan; Kembali; Berfungsi untuk membina BST dari array yang disusun [] arr; Masukkan akar; Membina subtree kiri; Membina subtree kanan; Pulangan akar; Kod pemacu; Susun array; Bina BST dari array yang disusun", "code": "class Node { constructor ( data ) { this . data = data ; this . left = null ; this . right = null ; } } var root = null ; function AlphaScore ( ) { root = null ; } var sum = 0 , total_sum = 0 ; var mod = 1000000007 ; function getAlphaScore ( node ) { if ( node . left != null ) getAlphaScore ( node . left ) ; sum = ( sum + node . data ) % mod ; total_sum = ( total_sum + sum ) % mod ; if ( node . right != null ) getAlphaScore ( node . right ) ; return total_sum ; } function constructBST ( arr , start , end , root ) { if ( start > end ) return null ; var mid = parseInt ( ( start + end ) / 2 ) ; if ( root == null ) root = new Node ( arr [ mid ] ) ; root . left = constructBST ( arr , start , mid - 1 , root . left ) ; root . right = constructBST ( arr , mid + 1 , end , root . right ) ; return root ; } var arr = [ 10 , 11 , 12 ] ; var length = arr . length ; arr . sort ( ) ; var root = null ; root = constructBST ( arr , 0 , length - 1 , root ) ; document . write ( getAlphaScore ( root ) ) ;"}
{"text": "Menyusun elemen array mengikut kekerapan dalam penurunan urutan | Fungsi yang mengembalikan indeks sehingga semua elemen array dikemas kini. ; Permulaan maxe = - 1; Cari elemen maksimum ARR []; Membuat frekuensi array freq []; Mengemas kini array frekuensi mengikut kejadian elemen dalam arr []; Permulaan CNT hingga 0; Melintasi freq []; Jika freq dari elemen lebih besar daripada 0 mengemas kini nilai ARR [] pada indeks CNT & kenaikan CNT; Kembali CNT; Fungsi yang mencetak array arr [] elemen dalam urutan yang disusun; Melintasi arr [] sehingga indeks cnt; Cari kekerapan elemen; Cari nilai di Indeks I; Melintasi kekerapan untuk mencetak nilai pada indeks I; Kod pemacu; Saiz array arr []; Fungsi panggilan untuk mendapatkan CNT; Susun arr [] dalam penurunan urutan; Fungsi yang mencetak elemen dalam penurunan urutan", "code": "function sortByFreq ( arr , n ) { var maxE = - 1 ; for ( var i = 0 ; i < n ; i ++ ) { maxE = Math . max ( maxE , arr [ i ] ) ; } var freq = new Array ( maxE + 1 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } var cnt = 0 ; for ( var i = 0 ; i <= maxE ; i ++ ) { if ( freq [ i ] > 0 ) { var value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } } return cnt ; } function printSortedArray ( arr , cnt ) { for ( var i = 0 ; i < cnt ; i ++ ) { var frequency = parseInt ( arr [ i ] / 100000 ) ; var value = 100000 - ( arr [ i ] % 100000 ) ; for ( var j = 0 ; j < frequency ; j ++ ) { document . write ( value + \" \" ) ; } } } var arr = [ 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 ] ; var n = arr . length ; var cnt = sortByFreq ( arr , n ) ; arr . sort ( ( a , b ) => b - a ) ; printSortedArray ( arr , cnt ) ;"}
{"text": "Semak jika N Rectangles kawasan yang sama boleh dibentuk dari (4 * n) integer | Berfungsi untuk memeriksa sama ada kita boleh membuat segi empat tepat kawasan yang sama; Susun array; Cari kawasan mana -mana segi empat tepat; Semak sama ada kita mempunyai dua sisi yang sama untuk setiap segi empat tepat dan kawasan setiap segi empat tepat yang terbentuk adalah sama; Kemas kini jawapan kepada palsu jika keadaan gagal; Jika boleh; Kod pemacu", "code": "function checkRectangles ( arr , n ) { let ans = true ; arr . sort ( ) ; var area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( let i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; } var arr = [ 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 ] ; var n = 2 ; if ( checkRectangles ( arr , n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Count of Elements yang tidak berada di kedudukan yang betul | Berfungsi untuk mengembalikan kiraan elemen yang tidak berada di kedudukan yang betul apabila disusun; Untuk menyimpan salinan array asal; Salin unsur -unsur array yang diberikan kepada array baru; Untuk menyimpan kiraan yang diperlukan; Susun array asal; Jika elemen semasa tidak berada di kedudukan yang betul; Kod pemacu", "code": "function cntElements ( arr , n ) { let copy_arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; let count = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; } let arr = [ 1 , 2 , 6 , 2 , 4 , 5 ] ; let n = arr . length ; document . write ( cntElements ( arr , n ) ) ;"}
{"text": "Cari k yang diperintahkan pasangan dalam array dengan perbezaan minimum d | Fungsi untuk mencari pasangan yang diperlukan; Harus ada elemen 2 * k; Untuk menyimpan pasangan; Susun array yang diberikan; Untuk setiap pasangan yang mungkin; Jika pasangan semasa adalah sah; Masukkannya leto vektor pasangan; Jika pasangan k tidak mungkin; Cetak pasangan; Kod pemacu", "code": "function findPairs ( arr , n , k , d ) { if ( n < 2 * k ) { document . write ( - 1 ) ; return ; } let pairs = [ ] ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < k ; i ++ ) { if ( arr [ n - k + i ] - arr [ i ] >= d ) { let p = [ arr [ i ] , arr [ n - k + i ] ] ; pairs . push ( p ) ; } } if ( pairs . length < k ) { document . write ( - 1 ) ; return ; } for ( let v of pairs ) { document . write ( \" \" + v [ 0 ] + \" \" + v [ 1 ] + \" \" + \" \" ) ; } } let arr = [ 4 , 6 , 10 , 23 , 14 , 7 , 2 , 20 , 9 ] ; let n = arr . length ; let k = 4 , d = 3 ; findPairs ( arr , n , k , d ) ;"}
{"text": "Kira pasangan dengan jumlah yang diberikan | Tetapkan 2 | Berfungsi untuk mengembalikan kiraan pasangan dari arr [] dengan jumlah yang diberikan; Untuk menyimpan kiraan pasangan; Susun array yang diberikan; Ambil dua petunjuk; Jika jumlahnya lebih besar; Jika jumlahnya lebih rendah; Jika jumlahnya sama; Cari kekerapan arr [i]; Cari kekerapan Arr [J]; Jika arr [i] dan arr [j] sama maka keluarkan nombor tambahan yang dikira; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "function pairs_count ( arr , n , sum ) { let ans = 0 ; arr . sort ( ) ; let i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { let x = arr [ i ] , xx = i ; while ( i < j && arr [ i ] == x ) i ++ ; let y = arr [ j ] , yy = j ; while ( j >= i && arr [ j ] == y ) j -- ; if ( x == y ) { let temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; } let arr = [ 1 , 5 , 7 , 5 , - 1 ] ; let n = arr . length ; let sum = 6 ; document . write ( pairs_count ( arr , n , sum ) ) ;"}
{"text": "Semak jika rentetan mengandungi huruf berturut -turut dan setiap huruf berlaku tepat sekali | Program JavaScript untuk melaksanakan pendekatan di atas; untuk semua watak rentetan; Cari nilai ASCII watak; Semak sama ada watak yang sah, jika tidak maka kembali palsu; Hitung jumlah semua nilai ASCII; Cari nilai ASCII minimum dari rentetan; Cari nilai ASCII maksimum dari rentetan; Untuk mendapatkan elemen sebelumnya nilai ASCII minimum; Ambil jumlah yang diharapkan dari persamaan di atas; Semak sama ada jumlah yang dijangkakan adalah sama dengan jumlah yang dikira atau tidak; Contoh 1 st; Contoh 2 nd", "code": "function check ( str ) { var min = Number . MAX_VALUE ; var max = Number . MIN_VALUE ; var sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { var ascii = parseInt ( str . charCodeAt ( i ) ) ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; var eSum = parseInt ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; } var str = \" \" ; if ( check ( str ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ; var str1 = \" \" ; if ( check ( str1 ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "K | Berfungsi untuk mencari jumlah minimum semua subarray; Masukkan semua elemen dalam satu set; Cari elemen maksimum dan minimum; Melintasi unsur minimum hingga maksimum; Semak sama ada \"Saya\" hilang; Semak sama ada kth hilang; Jika tiada elemen kth hilang; Kod pemacu", "code": "function findKth ( arr , n , k ) { var missing = new Set ( ) ; var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) missing . add ( arr [ i ] ) ; var maxm = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var minm = arr . reduce ( ( a , b ) => Math . min ( a , b ) ) ; for ( var i = minm + 1 ; i < maxm ; i ++ ) { if ( ! missing . has ( i ) ) count ++ ; if ( count == k ) return i ; } return - 1 ; } var arr = [ 2 , 10 , 9 , 4 ] ; var n = arr . length ; var k = 5 ; document . write ( findKth ( arr , n , k ) ) ;"}
{"text": "Susun senarai yang dipautkan yang mengandungi nilai dari 1 hingga n | Nod senarai pautan; Berfungsi untuk menyusun senarai yang dipautkan; Berfungsi untuk menambah nod pada permulaan senarai yang dipautkan; memperuntukkan nod; masukkan data; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Fungsi ini mencetak kandungan senarai yang dipautkan bermula dari nod yang diberikan; Kod pemacu; Senarai yang dipautkan yang dibina ialah: 3 -> 5 -> 4 -> 6 -> 1 -> 2", "code": "class Node { constructor ( ) { this . data = 0 ; this . next = null ; } } var start = null ; function sortList ( head ) { var startVal = 1 ; while ( head != null ) { head . data = startVal ; startVal ++ ; head = head . next ; } } function push ( head_ref , new_data ) { var new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; start = head_ref ; } function printList ( node ) { while ( node != null ) { document . write ( node . data + \" \" ) ; node = node . next ; } } start = null ; push ( start , 2 ) ; push ( start , 1 ) ; push ( start , 6 ) ; push ( start , 4 ) ; push ( start , 5 ) ; push ( start , 3 ) ; sortList ( start ) ; printList ( start ) ;"}
{"text": "Susun semula array untuk meminimumkan jumlah produk elemen pasangan berturut -turut | Program JavaScript untuk menyusun pelbagai seperti jumlah produk elemen alternatif adalah minimum. ; Buat Evenarr [] dan Oddarr []; Susun pelbagai utama dalam urutan menaik; Letakkan unsur -unsur di Oddarr [] dan evenarr [] seperti nilai yang dikehendaki. ; Susun everarr [] dalam urutan menurun; menggabungkan kedua -dua sub - array dan mengira jumlah minimum produk elemen alternatif; Program Pemandu", "code": "function minSum ( arr , n ) { let evenArr = [ ] ; let oddArr = [ ] ; arr . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i < Math . floor ( n / 2 ) ) { oddArr . push ( arr [ i ] ) ; } else { evenArr . push ( arr [ i ] ) ; } } evenArr . sort ( function ( a , b ) { return b - a ; } ) ; let i = 0 , sum = 0 ; for ( let j = 0 ; j < evenArr . length ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; arr [ i ++ ] = oddArr [ j ] ; sum += evenArr [ j ] * oddArr [ j ] ; } return sum ; } let arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] ; let n = arr . length ; document . write ( \" \" + minSum ( arr , n ) + \" \" ) ; document . write ( \" \" ) ; for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; }"}
{"text": "Masa minimum diperlukan untuk mencetak rentetan yang diberikan dari bekas bulat berdasarkan syarat yang diberikan | Berfungsi untuk mengira masa minimum untuk mencetak semua aksara dalam rentetan; Elemen semasa di mana penunjuk sedang menunjuk; Cari indeks elemen itu; Kirakan perbezaan mutlak antara indeks penunjuk dan indeks aksara sebagai jarak mengikut arah jam; Kurangkan masa mengikut arah jam dari 26 untuk mendapatkan masa anti -jam; Tambah minimum kedua -dua kali untuk jawapannya; Tambah satu unit masa untuk mencetak watak; Cetak jawapan terakhir; Diberikan input; Panggilan fungsi", "code": "funs minTime ( string word ) { int ans = 0 ; let curr = 0 ; for ( let i = 0 ; i < word . Length ; i ++ ) { int k = word [ i ] . charAt ( 0 ) - ' ' . charAt ( 0 ) ; let a = Math . abs ( curr - k ) ; let b = 26 - Math . abs ( curr - k ) ; ans += Math . min ( a , b ) ; ans ++ ; curr = word [ i ] . charAt ( 0 ) - ' ' . charAt ( 0 ) ; } document . write ( ans ) ; } let str = \" \" ; minTime ( str ) ;"}
{"text": "Pengurangan minimum atau pembahagian oleh pembahagi yang betul yang diperlukan untuk mengurangkan N hingga 1 | Fungsi untuk mencari bilangan langkah minimum yang diperlukan untuk mengurangkan n hingga 1; Menyimpan bilangan langkah yang diperlukan; Jika nilai n sama dengan 2 atau n adalah ganjil; Penurunan n oleh 1; Kenaikan CNT oleh 1; Jika n juga; Kemas kini n; Kenaikan CNT oleh 1; Mengembalikan bilangan langkah yang diperoleh; Kod pemacu", "code": "function reduceToOne ( N ) { let cnt = 0 ; while ( N != 1 ) { if ( N == 2 || ( N % 2 == 1 ) ) { N = N - 1 ; cnt ++ ; } else if ( N % 2 == 0 ) { N = Math . floor ( N / Math . floor ( N / 2 ) ) ; cnt ++ ; } } return cnt ; } let N = 35 ; document . write ( reduceToOne ( N ) ) ;"}
{"text": "Bilangan maksimum berlian yang boleh diperolehi dalam minit k | Berfungsi untuk mencari bilangan maksimum berlian yang boleh diperolehi dalam beberapa minit; Menyimpan semua elemen array; Tolak semua elemen ke barisan keutamaan; Menyimpan hasil yang diperlukan; Gelung manakala barisan tidak kosong dan k positif; Simpan elemen teratas dari PQ; Pop dari PQ; Tambahkannya kepada jawapannya; Bahagikannya dengan 2 dan tolaknya kembali ke PQ; Cetak jawapannya; Kod pemacu", "code": "function maxDiamonds ( A , N , K ) { let pq = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { pq . push ( A [ i ] ) ; } let ans = 0 ; pq . sort ( ( a , b ) => a - b ) while ( pq . length && K -- ) { pq . sort ( ( a , b ) => a - b ) let top = pq [ pq . length - 1 ] ; pq . pop ( ) ; ans += top ; top = Math . floor ( top / 2 ) ; pq . push ( top ) ; } document . write ( ans ) ; } let A = [ 2 , 1 , 7 , 4 , 2 ] ; let K = 3 ; let N = A . length ; maxDiamonds ( A , N , K ) ;"}
{"text": "Kurangkan kos kenaikan atau pengurangan seperti unsur -unsur yang diindeks yang sama menjadi pelbagai antara satu sama lain | Fungsi untuk mencari kos minimum untuk membuat [i] berbilang b [i] atau naib - sebaliknya untuk setiap elemen array; Menyimpan kos minimum; Melintasi array; Kes 1: Kemas kini [i]; Kes 2: Kemas kini B [i]; Tambah minimum dua kes di atas; Mengembalikan kos yang dihasilkan; Kod pemacu", "code": "function MinimumCost ( A , B , N ) { var totalCost = 0 ; for ( i = 0 ; i < N ; i ++ ) { var mod_A = B [ i ] % A [ i ] ; var totalCost_A = Math . min ( mod_A , A [ i ] - mod_A ) ; var mod_B = A [ i ] % B [ i ] ; var totalCost_B = Math . min ( mod_B , B [ i ] - mod_B ) ; totalCost += Math . min ( totalCost_A , totalCost_B ) ; } return totalCost ; } var A = [ 3 , 6 , 3 ] ; var B = [ 4 , 8 , 13 ] ; var N = A . length ; document . write ( MinimumCost ( A , B , N ) ) ;"}
{"text": "Nombor terbesar dibahagi dengan 50 yang boleh dibentuk dari satu set digit N yang terdiri daripada 0 s dan 7 s sahaja | Cetak nombor terbesar yang boleh dibahagikan dengan 50; Mengira nombor 0 s dan 7 s; Jika kiraan 7 boleh dibahagikan dengan 50; Jika kiraan 7 kurang daripada 5; Jika kiraan 7 tidak boleh dibahagikan dengan 50; Count kumpulan 5 di mana kiraan 7 s boleh dikumpulkan; Diberikan array; Saiz array", "code": "function printLargestDivisible ( arr , N ) { var i , count0 = 0 , count7 = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; else count7 ++ ; } if ( count7 % 50 == 0 ) { while ( count7 -- ) document . write ( 7 ) ; while ( count0 -- ) document . write ( 0 ) ; } else if ( count7 < 5 ) { if ( count0 == 0 ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } else { count7 = count7 - count7 % 5 ; while ( count7 -- ) document . write ( 7 ) ; while ( count0 -- ) document . write ( 0 ) ; } } var arr = [ 0 , 7 , 0 , 7 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 7 , 7 ] ; var N = arr . length ; printLargestDivisible ( arr , N ) ;"}
{"text": "Susun semula Arahan untuk memaksimumkan jumlah GCD unsur -unsur array dengan indeks masing -masing | Berfungsi untuk mencari jumlah maksimum GCD (arr [i], i) dengan menyusun semula array; Susun array dalam urutan menaik; Kedai maksimum jumlah GCD (arr [i], i) dengan menyusun semula elemen array; Menjana semua permutasi yang mungkin dari array; Kedai jumlah GCD (arr [i], i); Melintasi array; Kemas kini Jumlah; Kemas kini res; Kod pemacu", "code": "function findMaxValByRearrArr ( arr , N ) { arr . sort ( ) ; let res = 0 ; do { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += __gcd ( i + 1 , arr [ i ] ) ; } res = Math . max ( res , sum ) ; } while ( next_permutation ( arr ) ) ; return res ; } function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } function next_permutation ( p ) { for ( let a = p . length - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( let b = p . length - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { let t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; } let arr = [ 3 , 2 , 1 ] ; let N = arr . length ; document . write ( findMaxValByRearrArr ( arr , N ) ) ;"}
{"text": "Penyingkiran minimum diperlukan untuk membuat kekerapan setiap elemen array sama dengan nilainya | Fungsi untuk mencari kiraan minimum elemen yang diperlukan untuk dikeluarkan sedemikian rupa sehingga kekerapan arr [i] sama dengan arr [i]; Kedai kekerapan setiap elemen array; Melintasi array; Kemas kini kekerapan ARR [i]; Kedai kiraan minimum penyingkiran; Melintasi peta; Menyimpan nilai utama peta; Jika kekerapan saya kurang daripada saya; Mengemas kini cntminrem; Jika kekerapan saya lebih besar daripada saya; Mengemas kini cntminrem; Kod pemacu", "code": "function min_elements ( arr , N ) { var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } var cntMinRem = 0 ; mp . forEach ( ( value , key ) => { var i = key ; if ( mp . get ( i ) < i ) { cntMinRem += mp . get ( i ) ; } else if ( mp . get ( i ) > i ) { cntMinRem += ( mp . get ( i ) - i ) ; } } ) ; return cntMinRem ; } var arr = [ 2 , 4 , 1 , 4 , 2 ] ; var N = arr . length ; document . write ( min_elements ( arr , N ) ) ;"}
{"text": "Peningkatan minimum untuk membuat semua elemen array sama dengan jumlah yang sama dengan array yang diberikan selepas tepat satu penyingkiran | Fungsi untuk memeriksa sama ada pelbagai elemen yang sama dengan jumlah yang sama dengan array yang diberikan boleh diperoleh atau tidak; Kes asas; Kedai jumlah elemen array; Menyimpan elemen array kedua terbesar; Menyimpan elemen array terbesar; Melintasi array; Kemas kini SecMax; Kemas kini Max; Kemas kini SecMax; Kemas kini totalsum; Jika totalsum kurang daripada secmax * (n - 1)); Jika totalsum tidak boleh dibahagikan dengan (n - 1); Kod pemacu", "code": "function CheckAllarrayEqual ( arr , N ) { if ( N == 1 ) { return true ; } let totalSum = arr [ 0 ] ; let secMax = Number . MIN_VALUE ; let Max = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= Max ) { secMax = Max ; Max = arr [ i ] ; } else if ( arr [ i ] > secMax ) { secMax = arr [ i ] ; } totalSum += arr [ i ] ; } if ( ( secMax * ( N - 1 ) ) > totalSum ) { return false ; } if ( totalSum % ( N - 1 ) != 0 ) { return false ; } return true ; } let arr = [ 6 , 2 , 2 , 2 ] ; let N = arr . length ; if ( CheckAllarrayEqual ( arr , N ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Kira cara untuk membuat bitwise xor ganjil dan bahkan elemen diindeks sama dengan mengeluarkan elemen array | Berfungsi untuk mengira cara untuk membuat bitwise xor aneh dan bahkan elemen diindeks sama dengan mengeluarkan elemen array; Kedai xor unsur -unsur ganjil dan bahkan diindeks dari akhir; Kedai xor unsur -unsur ganjil dan bahkan diindeks dari awal; Menyimpan kiraan yang diperlukan; Melintasi array secara terbalik; Sekiranya saya ganjil; Sekiranya saya juga; Melintasi array; Sekiranya saya ganjil; Sekiranya saya juga; Mengeluarkan arr [i], kedai post_even xor unsur -unsur yang diindeks ganjil; Mengeluarkan arr [i], post_odd menyimpan xor walaupun elemen yang diindeks; Semak sama ada mereka sama; Jika saya ganjil, xor dengan curr_odd; Jika saya juga, xor dengan curr_even; Akhirnya cetak res; Diberikan array; Saiz yang diberikan; Panggilan fungsi", "code": "function Remove_one_element ( arr , n ) { let post_odd = 0 , post_even = 0 ; let curr_odd = 0 , curr_even = 0 ; let res = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 != 0 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; let X = curr_odd ^ post_even ; let Y = curr_even ^ post_odd ; if ( X == Y ) res ++ ; if ( i % 2 != 0 ) curr_odd ^= arr [ i ] ; else curr_even ^= arr [ i ] ; } document . write ( res ) ; } let arr = [ 1 , 0 , 1 , 0 , 1 ] ; let N = arr . length ; Remove_one_element ( arr , N ) ;"}
{"text": "Kira cara untuk membuat jumlah elemen ganjil dan bahkan diindeks sama dengan mengeluarkan elemen array | Fungsi untuk mengira indeks array yang penyingkirannya menjadikan jumlah unsur -unsur yang ganjil dan juga diindeks sama; Jika saiz array adalah 1; Jika saiz array adalah 2; Kedai -kedai jumlah unsur -unsur yang diindeks dari array yang diberikan; Kedai Jumlah unsur -unsur yang diindeks dari array yang diberikan; Melintasi array; Jika saya adalah nombor yang sama; Kemas kini Sumeven; Jika saya adalah nombor ganjil; Kemas kini Sumodd; Kedai Jumlah unsur -unsur array yang diindeks sehingga indeks i - th; Kedai Jumlah unsur array yang diindeks sehingga indeks i - th; Kedai -kedai mengira indeks yang penyingkirannya membuat jumlah unsur -unsur yang ganjil dan juga diindeks sama; Kedai -kedai jumlah unsur -unsur yang diindeks selepas mengeluarkan elemen i - th; Kedai Jumlah unsur -unsur yang diindeks selepas mengeluarkan elemen i - th; Melintasi array; Jika saya adalah nombor ganjil; Kemas kini Currodd; Kemas kini Newevensum; Kemas kini Newoddsum; Jika saya adalah nombor yang sama; Kemas kini Curreven; Kemas kini Newoddsum; Kemas kini Newevensum; Jika Newevensum sama dengan Newoddsum; Meningkatkan kiraan; Jika jumlah unsur -unsur yang diindeks dan ganjil - diindeks adalah sama dengan mengeluarkan elemen pertama; Meningkatkan kiraan; Jika panjang array adalah nombor ganjil; Jika jumlah unsur -unsur yang diindeks dan ganjil - diindeks adalah sama dengan mengeluarkan elemen terakhir; Meningkatkan kiraan; Jika panjang array adalah nombor yang sama; Jika jumlah unsur -unsur yang diindeks dan ganjil - diindeks adalah sama dengan mengeluarkan elemen terakhir; Meningkatkan kiraan; Kod pemacu", "code": "function cntIndexesToMakeBalance ( arr , n ) { if ( n == 1 ) { return 1 ; } if ( n == 2 ) return 0 ; let sumEven = 0 ; let sumOdd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { sumEven += arr [ i ] ; } else { sumOdd += arr [ i ] ; } } let currOdd = 0 ; let currEven = arr [ 0 ] ; let res = 0 ; let newEvenSum = 0 ; let newOddSum = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( i % 2 ) { currOdd += arr [ i ] ; newEvenSum = currEven + sumOdd - currOdd ; newOddSum = currOdd + sumEven - currEven - arr [ i ] ; } else { currEven += arr [ i ] ; newOddSum = currOdd + sumEven - currEven ; newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; } if ( newEvenSum == newOddSum ) { res ++ ; } } if ( sumOdd == sumEven - arr [ 0 ] ) { res ++ ; } if ( n % 2 == 1 ) { if ( sumOdd == sumEven - arr [ n - 1 ] ) { res ++ ; } } else { if ( sumEven == sumOdd - arr [ n - 1 ] ) { res ++ ; } } return res ; } let arr = [ 1 , 1 , 1 ] ; let n = arr . length ; document . write ( cntIndexesToMakeBalance ( arr , n ) ) ;"}
{"text": "Cari dua nombor dari jumlah dan xor mereka | Tetapkan 2 | Fungsi untuk mencari nilai a dan b yang jumlahnya adalah x dan xor adalah y; Memulakan dua nombor; Kes 1: x <y; Kes 2: x - y adalah ganjil; Kes 3: Jika kedua -dua jumlah dan XOR adalah sama; Kes 4: jika di atas kes gagal; Kemas kini nilai a; Semak jika nilai A & Y ialah 0; Jika benar, kemas kini b; Sebaliknya berikan - 1 hingga a, - 1 hingga b; Cetak nombor A dan B; Diberikan jumlah dan xor 2 nombor; Panggilan fungsi", "code": "function findNums ( X , Y ) { let A , B ; if ( X < Y ) { A = - 1 ; B = - 1 ; } else if ( Math . abs ( X - Y ) & 1 ) { A = - 1 ; B = - 1 ; } else if ( X == Y ) { A = 0 ; B = Y ; } else { A = ( X - Y ) / 2 ; if ( ( A & Y ) == 0 ) { B = ( A + Y ) ; } else { A = - 1 ; B = - 1 ; } } document . write ( A + \" \" + B ) ; } let X = 17 , Y = 13 ; findNums ( X , Y ) ;"}
{"text": "Pertanyaan untuk memeriksa sama ada kiraan peningkatan dan penurunan subarray adalah sama dalam julat yang diberikan | Fungsi untuk memeriksa sama ada julat yang diberikan mempunyai bilangan yang sama dan penurunan subarrays; Melintasi setiap pertanyaan; Untuk pengindeksan berasaskan 0; Keadaan untuk kiraan yang sama meningkatkan & menurunkan subarray; Kod pemacu", "code": "function checkCount ( A , Q , q ) { for ( let i = 0 ; i < q ; i ++ ) { let L = Q [ i ] [ 0 ] ; let R = Q [ i ] [ 1 ] ; L -- ; R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { document . write ( \" \" + \" \" ) ; } else { document . write ( \" \" + \" \" ) ; } } } let arr = [ 11 , 13 , 12 , 14 ] ; let Q = [ [ 1 , 4 ] , [ 2 , 4 ] ] ; let q = Q . length ; checkCount ( arr , Q , q ) ;"}
{"text": "Purata array yang dihasilkan oleh produk semua pasang array yang diberikan | Berfungsi untuk mencari min pasangan array arr; Menyimpan produk pasangan; Menjana semua pasangan yang tidak teratur; Menyimpan produk pasangan; Saiz PairArray; Simpan Jumlah PairArray; Menyimpan min PairArray; Cari min PairArray; Mengembalikan maksud yang dihasilkan; Diberikan array arr; Panggilan fungsi", "code": "function pairProductMean ( arr , N ) { var pairArray = [ ] ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { var pairProduct = arr [ i ] * arr [ j ] ; pairArray . push ( pairProduct ) ; } } var length = pairArray . length ; var sum = 0 ; for ( i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; var mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; } var arr = [ 1 , 2 , 4 , 8 ] ; var N = arr . length ; document . write ( pairProductMean ( arr , N ) . toFixed ( 2 ) ) ;"}
{"text": "Cari pemain yang terakhir untuk mengeluarkan apa -apa watak dari permulaan rentetan binari | Berfungsi untuk mencari pemain yang kehilangan permainan; Bergerak untuk pemain pertama; Bergerak untuk pemain kedua; Melangkah ke atas pelbagai rentetan; Semak sama ada watak pertama dan terakhir adalah sama; Semak jika rentetan bermula dan berakhir dengan aksara '0'; Jika pemain pertama mempunyai kurang bergerak; Diberikan pelbagai rentetan; Panggilan fungsi", "code": "function findPlayer ( str , n ) { let move_first = 0 ; let move_sec = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] [ 0 ] == str [ i ] [ str [ i ] . length - 1 ] ) { if ( str [ i ] [ 0 ] == 48 ) move_first ++ ; else move_sec ++ ; } } if ( move_first <= move_sec ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } let str = [ \" \" , \" \" ] ; let N = str [ 0 ] . length ; findPlayer ( str , N ) ;"}
{"text": "Bilangan terkecil melebihi n yang bit kth ditetapkan | Berfungsi untuk mencari nombor yang lebih besar daripada n yang bit kthnya ditetapkan; Berulang dari n + 1; Semak sama ada bit kth ditetapkan atau tidak; Kenaikan m untuk nombor seterusnya; Mengembalikan nilai minimum; Diberikan n dan k; Panggilan fungsi", "code": "function find_next ( n , k ) { let M = n + 1 ; while ( true ) { if ( ( M & ( 1 << k ) ) > 0 ) break ; M ++ ; } return M ; } let N = 15 , K = 2 ; document . write ( find_next ( N , K ) ) ;"}
{"text": "Lexicographically terbesar mungkin rentetan selepas penyingkiran Kara K | Program JavaScript untuk melaksanakan pendekatan di atas; Rentetan hasil akhir; Jika char semasa melebihi watak di bahagian atas timbunan; Keluarkan dari hujung rentetan; Kurangkan k untuk penyingkiran; Masukkan watak semasa; Lakukan penghapusan k yang tersisa dari akhir rentetan; Kembalikan rentetan; Kod pemacu", "code": "function largestString ( num , k ) { var ans = \" \" ; var str = num . split ( \" \" ) ; for ( const i of str ) { while ( ans . length > 0 && ans [ ans . length - 1 ] < i && k > 0 ) { ans = ans . substring ( 0 , ans . length - 1 ) ; k -- ; } ans += i ; } while ( ans . length > 0 && k -- > 0 ) { ans = ans . substring ( 0 , ans . length - 1 ) ; } return ans ; } var str = \" \" ; var k = 1 ; document . write ( largestString ( str , k ) + \" \" ) ;"}
{"text": "Panjang maksimum subarray yang terdiri daripada jenis elemen yang sama pada kedua -dua bahagian sub | Fungsi yang mendapati panjang maksimum sub -sub -yang mengandungi elemen yang sama pada kedua -dua bahagian sub -array; Untuk menyimpan kejadian berterusan unsur; Untuk menyimpan kejadian forkward berterusan; Untuk menyimpan kejadian mundur yang berterusan; Untuk menyimpan panjang maksimum; Cari panjang maksimum; Cetak hasilnya; Diberikan array; Saiz array; Panggilan fungsi", "code": "function maxLengthSubArray ( A , N ) { let forward = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let backward = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; } for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; } let ans = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = Math . max ( ans , Math . min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; } document . write ( ans ) ; } let arr = [ 1 , 2 , 3 , 4 , 4 , 4 , 6 , 6 , 6 , 9 ] ; let N = arr . length ; maxLengthSubArray ( arr , N ) ;"}
{"text": "Nombor digit terkecil divisible oleh semua angka utama yang mungkin | Berfungsi untuk mencari bilangan minimum n digit yang boleh dibahagikan oleh semua digit utama; Kod pemacu", "code": "function minNum ( n ) { if ( n < 3 ) document . write ( - 1 ) ; else document . write ( ( 210 * ( parseInt ( Math . pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ) ; } var n = 5 ; minNum ( n ) ;"}
{"text": "Nombor terkecil lebih besar daripada y dengan jumlah digit yang sama dengan x | Berfungsi untuk mengembalikan rentetan minimum panjang d yang mempunyai jumlah digit s; Mengembalikan rentetan panjang d; Ramuan meletakkan 9 pada akhirnya; Masukkan jumlah yang tersisa; Berfungsi untuk mencari nombor terkecil yang lebih besar daripada y yang jumlah digitnya adalah x; Tukar nombor y ke rentetan; Mengekalkan jumlah awalan digit; Melangkah ke atas Y dari belakang di mana k adalah panjang akhiran semasa; Kedai digit semasa; Meningkatkan digit semasa; Jumlah awalan semasa; Kembali Jawapan Jika baki jumlah boleh diperolehi dalam akhiran; Cari akhiran panjang k mempunyai jumlah digit x - r; Tambah watak semasa; Mengembalikan hasilnya; Diberi nombor dan jumlah; Panggilan fungsi", "code": "function helper ( d , s ) { let ans = [ ] ; for ( let i = 0 ; i < d ; i ++ ) { ans . push ( \" \" ) ; } for ( let i = d - 1 ; i >= 0 ; i -- ) { if ( s >= 9 ) { ans [ i ] = ' ' ; s -= 9 ; } else { let c = String . fromCharCode ( s + ' ' . charCodeAt ( 0 ) ) ; ans [ i ] = c ; s = 0 ; } } return ans . join ( \" \" ) ; } function findMin ( x , Y ) { let y = Y . toString ( ) ; let n = y . length ; let p = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { p . push ( 0 ) ; } for ( let i = 0 ; i < n ; i ++ ) { p [ i ] = y [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; if ( i > 0 ) { p [ i ] = p [ i ] + p [ i - 1 ] ; } } for ( let i = n - 1 , k = 0 ; ; i -- , k ++ ) { let d = 0 ; if ( i >= 0 ) { d = y [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; } for ( let j = d + 1 ; j <= 9 ; j ++ ) { let r = j ; if ( i > 0 ) { r += p [ i - 1 ] ; } if ( x - r >= 0 && x - r <= 9 * k ) { let suf = helper ( k , x - r ) ; let pre = \" \" ; if ( i > 0 ) pre = y . substring ( 0 , i ) ; let cur = String . fromCharCode ( j + ' ' . charCodeAt ( 0 ) ) ; pre += cur ; return pre + suf ; } } } } let x = 18 ; let y = 99 ; document . write ( findMin ( x , y ) ) ;"}
{"text": "Nombor terbesar yang terdiri daripada x dan y dengan kiraan x dibahagi dengan y dan y oleh x | Berfungsi untuk menjana dan mengembalikan nombor terbesar; Simpan yang lebih kecil di y; Simpan yang lebih besar dalam x; Kedai masing -masing; Jika n boleh dibahagikan dengan y; Tambah x, n kali ke jawapan; Mengurangkan n ke sifar; Mengurangkan n oleh x; Tambah y, x kali ke jawapan; Jika nombor boleh dibentuk; Jika tidak; Kod pemacu", "code": "function largestNumber ( n , X , Y ) { let maxm = Math . max ( X , Y ) ; Y = X + Y - maxm ; X = maxm ; let Xs = 0 ; let Ys = 0 ; while ( n > 0 ) { if ( n % Y == 0 ) { Xs += n ; n = 0 ; } else { n -= X ; Ys += X ; } } if ( n == 0 ) { while ( Xs -- > 0 ) document . write ( X ) ; while ( Ys -- > 0 ) document . write ( Y ) ; } else document . write ( \" \" ) ; } let n = 19 , X = 7 , Y = 5 ; largestNumber ( n , X , Y ) ;"}
{"text": "Flip minimum yang diperlukan untuk menjana substring berterusan 0 € ™ s dan 1 € ™ s | Pelaksanaan JavaScript pendekatan di atas; Melintasi rentetan input dan simpan kiraan 0; Melintasi rentetan input sekali lagi untuk mencari bilangan minimum flip; Kod pemacu", "code": "function minChanges ( str , N ) { var res ; var count0 = 0 , count1 = 0 ; str . split ( ' ' ) . forEach ( x => { count0 += ( x == ' ' ) ; } ) ; res = count0 ; str . split ( ' ' ) . forEach ( x => { count0 -= ( x == ' ' ) ; count1 += ( x == ' ' ) ; res = Math . min ( res , count1 + count0 ) ; } ) ; return res ; } var N = 9 ; var str = \" \" ; document . write ( minChanges ( str , N ) ) ;"}
{"text": "Kejadian yang hilang dari nombor dalam array sedemikian rupa sehingga perbezaan mutlak unsur -unsur bersebelahan adalah minimum | Berfungsi untuk mencari nombor yang hilang supaya perbezaan mutlak maksimum adalah minimum; Gelung untuk mencari elemen bersebelahan maksimum dan minimum kepada nombor yang hilang; Kod pemacu; Panggilan fungsi", "code": "function missingnumber ( n , arr ) { let mn = 10000 ; let mx = - 10000 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == - 1 && arr [ i - 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i - 1 ] ) ; mx = Math . max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i + 1 ] ) ; mx = Math . max ( mx , arr [ i + 1 ] ) ; } } let res = ( mx + mn ) / 2 ; return res ; } let n = 5 ; let arr = [ - 1 , 10 , - 1 , 12 , - 1 ] ; let res = missingnumber ( n , arr ) ; document . write ( res ) ;"}
{"text": "Memaksimumkan [panjang (x) / 2 ^ (xor (x, y))] dengan memilih substrings x dan y dari rentetan a dan b masing -masing | Berfungsi untuk mencari panjang substring biasa terpanjang rentetan x dan y; Lcsuff [i] [j] menyimpan panjang akhiran biasa substrings yang paling lama; Itearate atas rentetan a dan b; Jika baris pertama atau lajur; Jika padanan dijumpai; Jika tidak, jika padanan tidak dijumpai; Akhirnya, kembalikan nilai maksimum yang dihasilkan; Kod pemacu; Panggilan fungsi", "code": "function LCSubStr ( A , B , m , n ) { let LCSuff = Array ( m + 1 ) . fill ( Array ( n + 1 ) ) ; let result = 0 ; for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; if ( LCSuff [ i ] [ j ] > result ) { result = LCSuff [ i ] [ j ] ; } } else LCSuff [ i ] [ j ] = 0 ; } } result ++ ; return result ; } let A = \" \" ; let B = \" \" ; let M = A . length ; let N = B . length ; document . write ( LCSubStr ( A , B , M , N ) ) ;"}
{"text": "Kira cara untuk memecah array ke dalam sepasang subset dengan perbezaan antara jumlah mereka sama dengan k | Program JavaScript untuk pendekatan di atas; Untuk menyimpan negeri -negeri DP; Fungsi untuk mencari kiraan subset dengan jumlah yang diberikan; Kes asas; Jika subproblem yang telah dikira berlaku; Tetapkan negeri seperti diselesaikan; Hubungan berulang; Berfungsi untuk mengira cara untuk memecah array ke dalam sepasang subset dengan perbezaan k; Simpan jumlah keseluruhan elemen array; Melintasi array; Hitung jumlah elemen array; Simpan jumlah yang diperlukan; Cetak bilangan subset dengan jumlah yang sama dengan S1; Kod pemacu; Panggilan fungsi", "code": "var maxN = 20 ; var maxSum = 50 ; var minSum = 50 ; var base = 50 ; var dp = Array . from ( Array ( maxN ) , ( ) => Array ( maxSum + minSum ) ) ; var v = Array . from ( Array ( maxN ) , ( ) => Array ( maxSum + minSum ) ) ; function findCnt ( arr , i , required_sum , n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; } function countSubsets ( arr , K , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } var S1 = ( sum + K ) / 2 ; document . write ( findCnt ( arr , 0 , S1 , n ) ) ; } var arr = [ 1 , 1 , 2 , 3 ] ; var N = arr . length ; var K = 1 ; countSubsets ( arr , K , N ) ;"}
{"text": "Kebarangkalian bahawa jumlah semua nombor yang diperolehi membuang dadu n kali terletak di antara dua bilangan bulat yang diberikan | Program JavaScript untuk pendekatan di atas; Fungsi untuk mengira kebarangkalian bagi jumlah yang diberikan untuk menjadi sama dengan jumlah dalam n lontaran dadu; Kes asas; Kod pemacu; Kirakan kebarangkalian semua jumlah dari A hingga B; Cetak jawapannya", "code": "var dp = Array ( 105 ) . fill ( ) . map ( ( ) => Array ( 605 ) . fill ( 0.0 ) ) ; function find ( N , sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N ] [ sum ] > 0 ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( 1.0 / 6 ) ; else return 0 ; } for ( var i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; } var N = 4 , a = 13 , b = 17 ; var probability = 0.0 ; for ( sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; document . write ( probability . toFixed ( 6 ) ) ;"}
{"text": "Langkah minimum untuk mengurangkan n hingga 0 dengan operasi yang diberikan | Berfungsi untuk mencari nombor minimum ke langkah untuk mengurangkan n hingga 0; Kamus untuk menyimpan jumlah yang dipraktikkan; Kes -kes asas; Semak jika n tidak dalam DP maka hanya panggil fungsi untuk mengurangkan panggilan rekursif; Kembalikan jawapannya; Diberi nombor n; Panggilan fungsi", "code": "function count ( n ) { var dp = new Map ( ) ; dp . set ( 0 , 0 ) ; dp . set ( 1 , 1 ) ; if ( ! dp . has ( n ) ) dp . set ( n , 1 + Math . min ( n % 2 + count ( parseInt ( n / 2 ) ) , n % 3 + count ( parseInt ( n / 3 ) ) ) ) ; return dp . get ( n ) ; } var N = 6 ; document . write ( count ( N ) ) ;"}
{"text": "Pengiraan minimum kenaikan saiz K subarrays diperlukan untuk membentuk array yang diberikan | Berfungsi untuk mencari bilangan minimum operasi yang diperlukan untuk menukar semua pelbagai sifar supaya setiap elemen lebih besar daripada array yang diberikan; Mengisytiharkan pelbagai perbezaan saiz n; Bilangan operasi; Kemas kini pertama nilai D [i] dengan nilai sebelumnya; Indeks saya perlu ditingkatkan; Kita perlu melakukan operasi (b [i] - d [i]) lebih banyak; Meningkatkan julat saya ke i + k dengan keperluan; Semak jika i + k adalah indeks sah; Kod pemacu; Panggilan fungsi", "code": "function find_minimum_operations ( n , b , k ) { let d = new Array ( n + 1 ) ; d . fill ( 0 ) ; let i , operations = 0 , need ; for ( i = 0 ; i < n ; i ++ ) { if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; } if ( b [ i ] > d [ i ] ) { operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ; d [ i ] += need ; if ( i + k <= n ) { d [ i + k ] -= need ; } } } document . write ( operations ) ; } let n = 5 ; let b = [ 1 , 2 , 3 , 4 , 5 ] ; let k = 2 ; find_minimum_operations ( n , b , k ) ;"}
{"text": "Bilangan cara memotong matriks supaya atleast satu sel diisi dalam setiap bahagian | Berfungsi untuk mencari bilangan cara untuk memotong matriks ke bahagian k supaya setiap bahagian mempunyai atleast satu sel yang dipenuhi; Gelung untuk mencari awalan jumlah matriks yang diberikan; dp (r, c, 1) = 1 jika anggapan [r] lain 0; Gelung untuk melangkah ke atas jadual DP matriks yang diberikan; Semak jika boleh dipotong secara mendatar pada R1, sekurang -kurangnya satu epal dalam matriks (r, c) -> r1, c - 1; Semak jika kita boleh memotong secara menegak di C1, sekurang -kurangnya satu epal dalam matriks (r, c) -> r - 1, c1; Kod pemacu; Panggilan fungsi", "code": "function ways ( arr , K ) { let R = arr . length ; let C = arr [ 0 ] . length ; let preSum = new Array ( R ) ; for ( let i = 0 ; i < R ; i ++ ) { preSum [ i ] = new Array ( C ) ; for ( let j = 0 ; j < C ; j ++ ) { preSum [ i ] [ j ] = 0 ; } } for ( let r = R - 1 ; r >= 0 ; r -- ) { for ( let c = C - 1 ; c >= 0 ; c -- ) { preSum [ r ] = arr [ r ] ; if ( r + 1 < R ) preSum [ r ] += preSum [ r + 1 ] ; if ( c + 1 < C ) preSum [ r ] += preSum [ r ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r ] -= preSum [ r + 1 ] ; } } let dp = new Array ( K + 1 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( R ) ; for ( let j = 0 ; j < R ; j ++ ) { dp [ i ] [ j ] = new Array ( C ) ; for ( let k = 0 ; k < C ; k ++ ) { dp [ i ] [ j ] [ k ] = 0 ; } } } for ( let k = 1 ; k <= K ; k ++ ) { for ( let r = R - 1 ; r >= 0 ; r -- ) { for ( let c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k ] [ r ] = ( preSum [ r ] > 0 ) ? 1 : 0 ; } else { dp [ k ] [ r ] = 0 ; for ( let r1 = r + 1 ; r1 < R ; r1 ++ ) { if ( preSum [ r ] - preSum [ r1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] ; } for ( let c1 = c + 1 ; c1 < C ; c1 ++ ) { if ( preSum [ r ] - preSum [ r ] [ c1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] ; } } } } } return dp [ K ] [ 0 ] [ 0 ] ; } let arr = [ [ 1 , 0 , 0 ] , [ 1 , 1 , 1 ] , [ 0 , 0 , 0 ] ] ; let k = 3 ; document . write ( ways ( arr , k ) ) ;"}
{"text": "Produk semua subset saiz saiz k menggunakan unsur -unsur yang indeksnya membahagikan k sepenuhnya | Pelaksanaan JavaScript untuk pendekatan di atas; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang; Fungsi iteratif untuk mengira (NCR) % p dan simpan dalam f [n] [r]; Jika j> saya kemudian c (i, j) = 0; Jika IIS sama dengan j maka c (i, j) = 1; Fungsi mengira jawapan akhir; Memulakan ans; x adalah kiraan kejadian arr [i] dalam set yang berbeza sedemikian rupa sehingga indeks arr [i] dalam set tersebut membahagikan k sepenuhnya. ; Mencari kiraan arr [i] dengan meletakkannya di indeks yang membahagikan k sepenuhnya; Oleh teorem Fermat; Kod pemacu", "code": "let p = 1000000007 ; function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } function nCr ( n , p , f , m ) { for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) { if ( j > i ) { f [ i ] [ j ] = 0 ; } else if ( j == 0 j == i ) { f [ i ] [ j ] = 1 ; } else { f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } } } function ProductOfSubsets ( arr , n , m ) { let f = new Array ( n + 1 ) ; for ( var i = 0 ; i < f . length ; i ++ ) { f [ i ] = new Array ( 2 ) ; } nCr ( n , p - 1 , f , m ) ; arr . sort ( ) ; let ans = 1 ; for ( let i = 0 ; i < n ; i ++ ) { let x = 0 ; for ( let j = 1 ; j <= m ; j ++ ) { if ( m % j == 0 ) { x = ( x + ( f [ n - i - 1 ] [ m - j ] * f [ i ] [ j - 1 ] ) % ( p - 1 ) ) % ( p - 1 ) ; } } ans = ( ( ans * power ( arr [ i ] , x , p ) ) % p ) ; } document . write ( ans + \" \" ) ; } let arr = [ 4 , 5 , 7 , 9 , 3 ] ; let K = 4 ; let N = arr . length ; ProductOfSubsets ( arr , N , K ) ;"}
{"text": "Bilangan cara untuk menulis n sebagai jumlah k non | Fungsi untuk mengira bilangan cara untuk menulis n sebagai jumlah kaum non - negatif; Inisiasi dp [] [] array; Hanya 1 cara untuk memilih nilai dengan jumlah k; Jumlah permulaan; Mengira cara dari negeri -negeri sebelumnya; Mengemas kini jumlah; Mengembalikan kiraan akhir cara; Kod pemacu; Panggilan fungsi", "code": "function countWays ( n , m ) { var dp = Array . from ( Array ( m + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } var sum ; for ( var i = 2 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { sum = 0 ; for ( var k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 ] [ k ] ; } dp [ i ] [ j ] = sum ; } } return dp [ m ] [ n ] ; } var N = 2 , K = 3 ; document . write ( countWays ( N , K ) ) ;"}
{"text": "Bilangan cara untuk menulis n sebagai jumlah k non | Fungsi untuk mengira bilangan cara untuk menulis n sebagai jumlah kaum non - negatif; Inisiasi dp [] [] array; Isi dp [] [] dengan jumlah = m; Melelehkan dp [] [] untuk mengisi array dp [] []; Keadaan untuk lajur pertama; Lain mengisi dp [] [] dengan jumlah sehingga (i, j); Jika sampai ke akhir, maka kembalikan nilai; Mengemas kini pada indeks semasa; Kod pemacu; Panggilan fungsi", "code": "function countWays ( n , m ) { let dp = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( let i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } } for ( let i = 2 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( i == m && j == n ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } return Number . MIN_VALUE ; } let N = 2 , K = 3 ; document . write ( countWays ( N , K ) ) ;"}
{"text": "Susunan terpanjang sedemikian rupa sehingga setiap elemen dalam berikutnya dibentuk dengan mengalikan elemen sebelumnya dengan perdana | Berfungsi untuk prima pra -pra; Kaedah ayak untuk memeriksa sama ada perdana atau tidak; Gandaan; Pra -simpan semua prima; Berfungsi untuk mencari berikutnya terpanjang; Peta hash; Hubungi fungsi untuk menyimpan prima; Memulakan elemen terakhir dengan 1 kerana yang paling lama mungkin; Melangkah dari belakang dan cari yang paling lama; Dapatkan nombor; Inisialisasi DP [i] sebagai 1 sebagai elemen hanya akan saya dalam berikutnya. ; Melangkah dalam semua prima dan berlipat ganda untuk mendapatkan elemen seterusnya; Elemen seterusnya jika didarabkan dengannya; Jika melebihi elemen terakhir maka pecah; Jika nombor ada dalam array; Dapatkan unsur maksimum yang paling maksimum; Hash elemen; Cari yang paling lama; Kod pemacu", "code": "function SieveOfEratosthenes ( MAX , primes ) { let prime = new Array ( MAX + 1 ) . fill ( true ) ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( let i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) primes . push ( i ) ; } } function findLongest ( A , n ) { let mpp = new Map ( ) ; let primes = new Array ( ) ; SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; let dp = new Array ( n ) ; dp . fill ( 0 ) dp [ n - 1 ] = 1 ; mpp . set ( A [ n - 1 ] , n - 1 ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let num = A [ i ] ; dp [ i ] = 1 ; let maxi = 0 ; for ( let it of primes ) { let xx = num * it ; if ( xx > A [ n - 1 ] ) break ; else if ( mpp . get ( xx ) ) { dp [ i ] = Math . max ( dp [ i ] , 1 + dp [ mpp . get ( xx ) ] ) ; } } mpp . set ( A [ i ] , i ) ; } let ans = 1 ; for ( let i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , dp [ i ] ) ; } return ans ; } let a = [ 1 , 2 , 5 , 6 , 12 , 35 , 60 , 385 ] ; let n = a . length ; document . write ( findLongest ( a , n ) ) ;"}
{"text": "Bilangan rentetan binari panjang n dengan k bit set bersebelahan | Berfungsi untuk mencari bilangan rentetan bit panjang n dengan k bit set bersebelahan; Kes asas apabila kita membentuk rentetan panjang n; jika f (bit string) = k, hitung cara ini; Semak sama ada bit terakhir ditetapkan, jika ditetapkan maka hubungi indeks seterusnya dengan menambah kiraan bit bersebelahan lain, hubungi indeks seterusnya dengan nilai yang sama dari kiraan bit bersebelahan dan sama ada tetapkan bit pada indeks semasa atau biarkan ia tetap tidak tersembunyi; Tetapkan bit pada CurrentIndex; tidak jelas sedikit pada currentIndex; Kod pemacu; Jumlah cara = (cara dengan meletakkan bit 1 st 1 + cara dengan meletakkan bit 1 sebagai 0)", "code": "function waysToKAdjacentSetBits ( n , k , currentIndex , adjacentSetBits , lastBit ) { if ( currentIndex == n ) { if ( adjacentSetBits == k ) return 1 ; return 0 ; } let noOfWays = 0 ; if ( lastBit == 1 ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( ! lastBit ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } return noOfWays ; } let n = 5 , k = 2 ; let totalWays = waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ; document . write ( \" \" + totalWays ) ;"}
{"text": "Jumlah produk semua gabungan diambil (1 hingga n) pada satu masa | Cari array Jumlah Postfix; Ubah suai array supaya kita tidak perlu mengira produk yang diperoleh sebelum ini; Mencari jumlah semua gabungan yang diambil 1 hingga n pada satu masa; Jumlah yang diambil 1 pada masa hanya jumlah 1 - n; untuk jumlah produk untuk semua kombinasi; mencari array postfix; Jumlah produk yang diambil i + 1 pada satu masa; Ubah suai array untuk masalah bertindih; Kod pemandu; menyimpan nombor dari 1 hingga n; Memanggil AllCombination", "code": "function postfix ( a , n ) { for ( let i = n - 1 ; i > 0 ; i -- ) { a [ i - 1 ] = a [ i - 1 ] + a [ i ] ; } } function modify ( a , n ) { for ( let i = 1 ; i < n ; i ++ ) { a [ i - 1 ] = i * a [ i ] ; } } function allCombination ( a , n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { sum += i ; } document . write ( \" \" + sum + \" \" ) ; for ( let i = 1 ; i < n ; i ++ ) { postfix ( a , n - i + 1 ) ; sum = 0 ; for ( let j = 1 ; j <= n - i ; j ++ ) { sum += ( j * a [ j ] ) ; } document . write ( \" \" + ( i + 1 ) + \" \" + sum + \" \" ) ; modify ( a , n ) ; } } let n = 5 ; let a = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { a [ i ] = i + 1 ; } allCombination ( a , n ) ;"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Mengembalikan kiraan cara untuk mencapai tangga N - menggunakan 1 atau 2 atau 3 langkah. ; Kod pemacu", "code": "function findStep ( n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; } let n = 4 ; document . write ( findStep ( n ) ) ;"}
{"text": "Masalah Partition | DP | Fungsi utiliti yang kembali benar jika terdapat subset arr [] dengan matahari sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah elemen dalam array; Jika jumlahnya ganjil, tidak ada dua subset dengan jumlah yang sama; Cari jika terdapat subset dengan jumlah yang sama dengan separuh daripada jumlah keseluruhan; Kod pemacu; Panggilan fungsi", "code": "function isSubsetSum ( arr , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ; return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; } function findPartition ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; return isSubsetSum ( arr , n , Math . floor ( sum / 2 ) ) ; } let arr = [ 3 , 1 , 5 , 9 , 12 ] ; let n = arr . length ; if ( findPartition ( arr , n ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text": "Masalah Partition | DP | Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah semua elemen; Memulakan array bahagian sebagai 0; Isi jadual partition dengan cara bawah; Unsur yang akan dimasukkan dalam jumlah tidak boleh lebih besar daripada jumlahnya; Semak jika jumlah - arr [i] boleh dibentuk dari subset menggunakan elemen sebelum indeks I; Kod pemacu; Panggilan fungsi", "code": "function findPartiion ( arr , n ) { let sum = 0 ; let i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; let part = new Array ( parseInt ( sum / 2 + 1 , 10 ) ) ; for ( i = 0 ; i <= parseInt ( sum / 2 , 10 ) ; i ++ ) { part [ i ] = false ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = parseInt ( sum / 2 , 10 ) ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ parseInt ( sum / 2 , 10 ) ] ; } let arr = [ 1 , 3 , 3 , 2 , 3 , 2 ] ; let n = arr . length ; if ( findPartiion ( arr , n ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text": "Koefisien binomial | DP | Berfungsi untuk mencari pekali binomial; Mendapatkan penyongsangan modular untuk semua nombor dari 2 hingga R berkenaan dengan M di sini M = 1000000007; untuk 1 / (r!) Bahagian; untuk (n) * (n - 1) * (n - 2) * ... * (n - r + 1) bahagian; Kod pemacu", "code": "function binomialCoeff ( n , r ) { if ( r > n ) return 0 ; let m = 1000000007 ; let inv = new Array ( r + 1 ) . fill ( 0 ) ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( let i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - Math . floor ( m / i ) * inv [ m % i ] % m ; } let ans = 1 ; for ( let i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( let i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; } let n = 5 , r = 2 ; document . write ( \" \" + n + \" \" + r + \" \" + binomialCoeff ( n , r ) + \" \" ) ;"}
{"text": "Semak sama ada mungkin untuk mencapai (x, y) dari (1, 1) dengan langkah -langkah yang diberikan | Berfungsi untuk mencari GCD dua nombor; Kes asas; Berulang; Berfungsi untuk mencetak jawapan; GCD X dan Y; Jika GCD adalah kuasa 2; Diberikan x dan y; Panggilan fungsi", "code": "function gcd ( a , b ) { if ( a < b ) { let t = a ; a = b ; b = t ; } if ( a % b == 0 ) return b ; return gcd ( b , a % b ) ; } function printAnswer ( x , y ) { let val = gcd ( x , y ) ; if ( ( val & ( val - 1 ) ) == 0 ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let x = 4 ; let y = 7 ; printAnswer ( x , y ) ;"}
{"text": "Cari elemen dalam matriks yang dihasilkan oleh peraturan yang diberikan | Berfungsi untuk mengembalikan elemen dalam lajur RTH dan lajur CTH dari matriks yang diperlukan; Keadaan untuk separuh bawah matriks; Keadaan jika elemen berada di baris pertama; Memulakan elemen AP dalam baris R; Perbezaan umum AP dalam baris r; Kedudukan elemen untuk mencari di AP dalam baris r; Kod pemacu", "code": "function getElement ( N , r , c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } let a = ( r + 1 ) * parseInt ( Math . pow ( 2 , ( r - 2 ) ) ) ; let d = parseInt ( Math . pow ( 2 , ( r - 1 ) ) ) ; c = c - r ; let element = a + d * c ; return element ; } let N = 4 , R = 3 , C = 4 ; document . write ( getElement ( N , R , C ) ) ;"}
{"text": "Cari nombor terkecil yang dibentuk dengan memasukkan digit yang diberikan | Fungsi untuk memasukkan x dalam n dan mengembalikan rentetan nilai minimum; Pembolehubah untuk menyimpan panjang rentetan n; Pembolehubah untuk menunjukkan kedudukan di mana x mesti ditambah; Jika rentetan yang diberikan n mewakili nilai negatif; X mesti diletakkan pada indeks terakhir di mana lebih besar daripada n [i]; Untuk nombor positif, x mesti diletakkan pada indeks terakhir di mana ia lebih kecil daripada n [i]; Masukkan x pada kedudukan itu; Kembalikan rentetan; Diberikan input; Panggilan fungsi", "code": "function MinValue ( N , X ) { let len = N . length ; let position = len + 1 ; if ( N [ 0 ] == ' ' ) { for ( let i = len - 1 ; i >= 1 ; i -- ) { if ( ( N [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) < X ) { position = i ; } } } else { for ( let i = len - 1 ; i >= 0 ; i -- ) { if ( ( N [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) > X ) { position = i ; } } } const c = String . fromCharCode ( X + ' ' . charCodeAt ( 0 ) ) ; let str = N . slice ( 0 , position ) + c + N . slice ( position ) ; return str ; } let N = \" \" ; let X = 1 ; document . write ( MinValue ( N , X ) ) ;"}
{"text": "Semak jika perwakilan perpuluhan rentetan binari yang diberikan dapat dibahagikan dengan k atau tidak | Fungsi untuk memeriksa nombor binari yang boleh dibahagikan oleh k; Array Poweroftwo akan menyimpan pow (2, i) % k; Memulakan elemen pertama dalam array; Menyimpan setiap nilai pow (2, i) % k dalam array; Untuk menyimpan baki; Melangkah sehingga n; Jika bit semasa ialah 1; Mengemas kini REM; Jika benar -benar boleh dibahagikan; Jika tidak sepenuhnya dibahagi; Diberikan input; panjang rentetan s; Panggilan fungsi", "code": "function divisibleByk ( s , n , k ) { let poweroftwo = new Array ( n ) ; poweroftwo [ 0 ] = 1 % k ; for ( let i = 1 ; i < n ; i ++ ) { poweroftwo [ i ] = ( poweroftwo [ i - 1 ] * ( 2 % k ) ) % k ; } let rem = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ n - i - 1 ] == ' ' ) { rem += ( poweroftwo [ i ] ) ; rem %= k ; } } if ( rem == 0 ) { return \" \" ; } else return \" \" ; } let s = \" \" ; let k = 9 ; let n = s . length ; document . write ( divisibleByk ( s , n , k ) ) ;"}
{"text": "Pecahkan rentetan binari supaya kiraan 0 s dan 1 s dalam substring kiri dan kanan adalah maksimum | Berfungsi untuk mencari jumlah maksimum kiraan 0 s di substring kiri dan kiraan 1 s dalam substring kanan dengan memisahkan rentetan; Kedai mengira 1 s dalam rentetan binari; Melintasi rentetan binari; Jika watak semasa adalah '1'; Kemas kini cntone; Kedai kiraan 0 s; Kedai kiraan 1 s; Kedai maksimum jumlah kiraan 0 s dan 1 s dengan memisahkan rentetan; Melintasi rentetan binari; Jika watak semasa adalah '0'; Mengemas kini sifar; Jika watak semasa adalah '1'; Mengemas kini satu; Kemas kini res; Kod pemacu", "code": "function maxSumbySplittingstring ( str , N ) { var cntOne = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' ' ) { cntOne ++ ; } } var zero = 0 ; var one = 0 ; var res = 0 ; for ( var i = 0 ; i < N - 1 ; i ++ ) { if ( str [ i ] == ' ' ) { zero ++ ; } else { one ++ ; } res = Math . max ( res , zero + cntOne - one ) ; } return res ; } var str = \" \" ; var N = str . length ; document . write ( maxSumbySplittingstring ( str , N ) ) ;"}
{"text": "Mengira penyingkiran pasangan yang diperlukan untuk kosongkan semua berikutnya Parenthesis Balanced | Fungsi untuk mencari kiraan maksimum pasangan yang diperlukan untuk dikeluarkan supaya rentetan seterusnya tidak mengandungi sebarang kurungan yang sah; Kedai kiraan pasangan kurungan seimbang; Kedai -kedai mengira kurungan seimbang; Kedai mengira kurungan seimbang kecil; Kedai kiraan kurungan seimbang persegi; Melangkah ke atas aksara rentetan; Mengemas kini cntcurly; Kemas kini CNTSML; Kemas kini CNTSQR; Mengemas kini cntcurly; Kemas kini CNTPairs; Kemas kini CNTSML; Kemas kini CNTPairs; Kemas kini CNTSML; Kemas kini CNTPairs; Diberikan rentetan; Panggilan fungsi", "code": "function cntBalancedParenthesis ( s , N ) { var cntPairs = 0 ; var cntCurly = 0 ; var cntSml = 0 ; var cntSqr = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == ' ' ) { cntCurly ++ ; } else if ( s . charAt ( i ) == ' ' ) { cntSml ++ ; } else if ( s . charAt ( i ) == ' ' ) { cntSqr ++ ; } else if ( s . charAt ( i ) == ' ' && cntCurly > 0 ) { cntCurly -- ; cntPairs ++ ; } else if ( s . charAt ( i ) == ' ' && cntSml > 0 ) { cntSml -- ; cntPairs ++ ; } else if ( s . charAt ( i ) == ' ' && cntSqr > 0 ) { cntSqr -- ; cntPairs ++ ; } } document . write ( cntPairs ) ; } var s = \" \" ; var N = s . length ; cntBalancedParenthesis ( s , N ) ;"}
{"text": "Count of Strings yang tidak mengandungi persimpangan arka | Berfungsi untuk memeriksa sama ada terdapat persimpangan arka atau tidak; Melintasi rentetan s; Masukkan semua elemen dalam timbunan satu demi satu; Ekstrak elemen teratas; Pop keluar elemen teratas; Semak sama ada elemen atas adalah sama dengan elemen yang muncul; Jika tidak; Sekiranya timbunan kosong; Fungsi untuk memeriksa sama ada terdapat persimpangan arka atau tidak untuk pelbagai rentetan yang diberikan; Kedai kiraan rentetan tidak mempunyai persimpangan arka; Berulang melalui array; Panjang setiap rentetan; Panggilan fungsi; Cetak kiraan yang dikehendaki; Kod pemacu; Panggilan fungsi", "code": "function arcIntersection ( S , len ) { var stk = [ ] ; for ( var i = 0 ; i < len ; i ++ ) { stk . push ( S [ i ] ) ; if ( stk . length >= 2 ) { var temp = stk [ stk . length - 1 ] ; stk . pop ( ) ; if ( stk [ stk . length - 1 ] == temp ) { stk . pop ( ) ; } else { stk . push ( temp ) ; } } } if ( stk . length == 0 ) return 1 ; return 0 ; } function countString ( arr , N ) { var count = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var len = arr [ i ] . length ; count += arcIntersection ( arr [ i ] , len ) ; } document . write ( count + \" \" ) ; } var arr = [ \" \" , \" \" , \" \" ] ; var N = arr . length ; countString ( arr , N ) ;"}
{"text": "Semak jika perwakilan perpuluhan rentetan binari boleh dibahagikan dengan 9 atau tidak | Berfungsi untuk menukar rentetan binari ke dalam perwakilan oktal; Kedai perwakilan binari nilai perpuluhan [0 - 7]; Menyimpan nilai perpuluhan rentetan binari [0 - 7]; Kedai panjang s; Kemas kini s; Kemas kini s; Kemas kini n; Kedai perwakilan oktal rentetan binari; Melintasi rentetan binari; Kedai 3 aksara berturut -turut rentetan binari; Tambah perwakilan oktal temp; Fungsi untuk memeriksa sama ada rentetan binari boleh dibahagikan dengan 9 atau tidak; Kedai perwakilan oktal S; Kedai jumlah unsur yang hadir pada kedudukan ganjil OCT; Kedai jumlah unsur yang hadir pada kedudukan ganjil OCT; Kedai panjang OCT; Melintasi rentetan OCT; Mengemas kini oddsum; Melintasi rentetan OCT; Kemas kini Evensum; Kedai perwakilan oktal 9; Jika nilai mutlak (oddsum - evensum) boleh dibahagikan dengan Okt_9; Kod pemacu", "code": "function ConvertequivalentBase8 ( S ) { let mp = new Map ( ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; let N = S . length ; if ( N % 3 == 2 ) { S = \" \" + S ; } else if ( N % 3 == 1 ) { S = \" \" + S ; } N = S . length ; let oct = \" \" ; for ( let i = 0 ; i < N ; i += 3 ) { let temp = S . substring ( i , i + 3 ) ; oct += mp . get ( temp ) ; } return oct ; } function binString_div_9 ( S , N ) { let oct = \" \" ; oct = ConvertequivalentBase8 ( S ) ; let oddSum = 0 ; let evenSum = 0 ; let M = oct . length ; for ( let i = 0 ; i < M ; i += 2 ) oddSum += ( oct [ i ] - ' ' ) ; for ( let i = 1 ; i < M ; i += 2 ) { evenSum += ( oct [ i ] - ' ' ) ; } let Oct_9 = 11 ; if ( Math . abs ( oddSum - evenSum ) % Oct_9 == 0 ) { return \" \" ; } return \" \" ; } let S = \" \" ; let N = S . length ; document . write ( binString_div_9 ( S , N ) ) ;"}
{"text": "Kos minimum untuk mengeluarkan ruang antara aksara rentetan dengan menyusun semula aksara | Fungsi untuk mengira kos minimum; Menyimpan kos minimum; Menyimpan kiraan watak yang dijumpai; Menyimpan kiraan ruang kosong yang dijumpai; Menyimpan kiraan jumlah aksara; Jika kiraan aksara sama dengan 1; Melangkah ke atas rentetan; Pertimbangkan watak sebelumnya bersama -sama dengan watak semasa; Sekiranya tidak bersama sudah; Tambah kos untuk mengumpulkannya bersama -sama; Meningkatkan kiraan watak yang dijumpai; Jika tidak; Meningkatkan kiraan ruang yang dijumpai; Mengembalikan jumlah kos yang diperoleh; Kod pemacu", "code": "function min_cost ( S ) { let cost = 0 ; let F = 0 ; let B = 0 ; let count = 0 ; for ( let i in S ) if ( S [ i ] == ' ' ) count ++ ; let n = S . length - count ; if ( n == 1 ) return cost ; for ( let i in S ) { if ( S [ i ] != ' ' ) { if ( B != 0 ) { cost += Math . min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; } let S = \" \" ; document . write ( min_cost ( S . split ( ' ' ) ) ) ;"}
{"text": "Kurangkan kos untuk menggantikan semua vokal rentetan yang diberikan oleh vokal tunggal | Fungsi yang kembali benar jika watak yang diberikan adalah vokal; Berfungsi untuk mengembalikan kos minimum untuk menukar semua vokal rentetan kepada satu; ST || kiraan vokal masing -masing; Melangkah melalui rentetan; Jika vokal ditemui; Kirakan kos; Kembalikan matematik. kos minimum; Kod pemacu", "code": "function isVowel ( ch ) { if ( ch == ' ' ch == ' ' ch == ' ' ch == ' ' ch == ' ' ) return true ; else return false ; } function minCost ( S ) { var cA = 0 ; var cE = 0 ; var cI = 0 ; var cO = 0 ; var cU = 0 ; for ( var i = 0 ; i < S . length ; i ++ ) { if ( isVowel ( S [ i ] ) ) { cA += Math . abs ( S . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ) ; cE += Math . abs ( S . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ) ; cI += Math . abs ( S . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ) ; cO += Math . abs ( S . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ) ; cU += Math . abs ( S . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ) ; } } return Math . min ( Math . min ( Math . min ( Math . min ( cA , cE ) , cI ) , cO ) , cU ) ; } var S = \" \" ; document . write ( minCost ( S ) ) ;"}
{"text": "Menjana rentetan yang semua k | Berfungsi untuk mengembalikan rentetan yang diperlukan; Melepasi rentetan yang diberikan; Tambah watak pertama setiap substring panjang k; Pertimbangkan semua watak dari substring terakhir; Kod pemacu", "code": "function decode_String ( str , K ) { let ans = \" \" ; for ( let i = 0 ; i < str . length ; i += K ) ans += str [ i ] ; for ( let i = str . length - ( K - 1 ) ; i < str . length ; i ++ ) ans += str [ i ] ; document . write ( ans ) ; } let K = 3 ; let str = \" \" ; decode_String ( str , K ) ;"}
{"text": "Lexicographically terkecil k | Fungsi yang mencetak substring panjang K - panjang terkecil yang mengandungi bilangan vokal maksimum; ST || e panjang rentetan; Memulakan array jumlah awalan; Gelung melalui rentetan untuk membuat array Sum Prefix; ST || e 1 pada indeks jika ia adalah vokal; Jika tidak, St || E 0; Proses array awalan; Inisialisasi pembolehubah kepada ST || e kiraan maksimum vokal; Inisialisasi pembolehubah kepada ST || e substring dengan kiraan maksimum vokal; Gelung melalui array awalan; ST || e kiraan vokal semasa; Kemas kini hasil jika kiraan semasa lebih besar daripada kiraan maksimum; Kemas kini substring terkecil secara lexicographically jika kiraan semasa adalah sama dengan kiraan maksimum; Mengembalikan hasilnya; Program Pemandu", "code": "function maxVowelSubString ( str , K ) { var N = str . length ; var pref = Array ( N ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' ) pref [ i ] = 1 ; else pref [ i ] = 0 ; if ( i ) pref [ i ] += pref [ i - 1 ] ; } var maxCount = pref [ K - 1 ] ; var res = str . substring ( 0 , K ) ; for ( var i = K ; i < N ; i ++ ) { var currCount = pref [ i ] - pref [ i - K ] ; if ( currCount > maxCount ) { maxCount = currCount ; res = str . substring ( i - K + 1 , i - 1 ) ; } else if ( currCount == maxCount ) { var temp = str . substring ( i - K + 1 , i + 1 ) ; if ( temp < res ) res = temp ; } } return res ; } var str = \" \" ; var K = 3 ; document . write ( maxVowelSubString ( str , K ) ) ;"}
{"text": "Decode rentetan yang dikodkan dengan algoritma yang diberikan | Berfungsi untuk menyahkod dan mencetak rentetan asal; Untuk menyimpan rentetan yang dikodkan; Mendapatkan elemen pertengahan; Menyimpan elemen pertama rentetan pada kedudukan median; Jika panjangnya, kemudian simpan elemen kedua juga; K mewakili bilangan aksara yang telah disimpan dalam C []; Jika panjang rentetan ganjil; Jika ia juga; Cetak rentetan decoded; Kod pemacu", "code": "function decodeStr ( str , len ) { var c = Array ( len ) . fill ( \" \" ) ; var med , pos = 1 , k ; if ( len % 2 == 1 ) med = parseInt ( len / 2 ) ; else med = parseInt ( len / 2 ) - 1 ; c [ med ] = str [ 0 ] ; if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ; if ( len & 1 ) k = 1 ; else k = 2 ; for ( var i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ; if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ; else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; } for ( var i = 0 ; i < len ; i ++ ) { document . write ( c [ i ] ) ; } } var str = \" \" ; var len = str . length ; decodeStr ( str , len ) ;"}
{"text": "Mengira watak -watak yang berbeza dalam substring dengan julat yang diberikan untuk pertanyaan q | Program JavaScript untuk pendekatan naif; kaunter untuk mengira char yang berbeza; Array frekuensi memulakan untuk mengira aksara sebagai muncul dalam substring s [l: r]; Melangkah ke atas [L] ke S [r]; Meningkatkan kiraan S [i] watak dalam pelbagai frekuensi; jika kekerapan mana -mana watak adalah> 0 maka kenaikan kaunter; Kod pemacu", "code": "function findCount ( s , L , R ) { var distinct = 0 ; var frequency = Array ( 26 ) . fill ( 0 ) ; for ( var i = L ; i <= R ; i ++ ) { frequency [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } for ( var i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] > 0 ) distinct ++ ; } document . write ( distinct + \" \" ) ; } var s = \" \" ; var queries = 3 ; var Q = [ [ 0 , 10 ] , [ 15 , 18 ] , [ 12 , 20 ] ] ; for ( var i = 0 ; i < queries ; i ++ ) findCount ( s , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ;"}
{"text": "String yang diperoleh dengan membalikkan dan melengkapkan rentetan binari K kali | Berfungsi untuk melaksanakan operasi k pada rentetan dan mencari rentetan yang diubah suai; Bilangan operasi terbalik; Bilangan operasi pelengkap; Jika rev adalah pariti ganjil; Jika pelengkap adalah pariti ganjil; Melengkapi setiap kedudukan; Kembalikan rentetan yang diubah suai; Kod pemacu; Panggilan fungsi", "code": "function ReverseComplement ( s , n , k ) { var rev = parseInt ( ( k + 1 ) / 2 ) ; var complement = k - rev ; if ( rev % 2 ) { s = s . split ( ' ' ) . reverse ( ) . join ( ' ' ) ; } if ( complement % 2 ) { for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) s [ i ] = ' ' ; else s [ i ] = ' ' ; } } return s ; } var str = \" \" ; var k = 5 ; var n = str . length ; document . write ( ReverseComplement ( str , n , k ) ) ;"}
{"text": "Semak jika ada permutasi rentetan adalah rentetan kim yang berulang kali | Fungsi untuk memeriksa bahawa permutasi rentetan yang diberikan adalah rentetan mengulangi kali; Jika panjang rentetan tidak dapat dibahagikan dengan k; Pelbagai kekerapan; Pada mulanya kekerapan setiap watak ialah 0; Pengkomputeran kekerapan setiap aksara dalam rentetan; Gelung untuk memeriksa kekerapan setiap watak rentetan itu boleh dibahagikan dengan k; Kod pemacu", "code": "function repeatingString ( s , n , k ) { if ( n % k != 0 ) { return false ; } var frequency = new Array ( 123 ) ; for ( let i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] ] ++ ; } var repeat = n / k ; for ( let i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; } var s = \" \" ; var n = s . length ; var k = 3 ; if ( repeatingString ( s , n , k ) ) { console . log ( \" \" ) ; } else { console . log ( \" \" ) ; }"}
{"text": "Cari dua digit terakhir yang hilang dari nombor telefon yang diberikan | Berfungsi untuk mencari dua digit terakhir nombor dan mencetak nombor lengkap; Jumlah lapan digit nombor pertama; jika jumlah <10, maka dua digit adalah '0' dan nilai jumlah; Jika jumlah> 10, maka dua digit adalah nilai jumlah; Kod pemacu", "code": "function findPhoneNumber ( n ) { let temp = n ; let sum = 0 ; while ( temp != 0 ) { sum += temp % 10 ; temp = Math . floor ( temp / 10 ) ; } if ( sum < 10 ) document . write ( n + \" \" + sum ) ; else document . write ( n + \" \" + sum ) ; } let n = 98765432 ; findPhoneNumber ( n ) ;"}
{"text": "Bilangan cara untuk memecah nombor binari supaya setiap bahagian boleh dibahagikan dengan 2 | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan kiraan yang diperlukan; Jika pemisahan tidak mungkin; Untuk menyimpan kiraan sifar; Mengira bilangan sifar; Kembalikan jawapan terakhir; Kod pemacu", "code": "var maxN = 20 ; var maxM = 64 ; function cntSplits ( s ) { if ( s [ s . length - 1 ] == ' ' ) return 0 ; var c_zero = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) c_zero += ( s [ i ] == ' ' ) ; return Math . pow ( 2 , c_zero - 1 ) ; } var s = \" \" ; document . write ( cntSplits ( s ) ) ;"}
{"text": "Kira bilangan substrings rentetan yang terdiri daripada aksara yang sama | Berfungsi untuk mengembalikan bilangan substrings aksara yang sama; Saiz rentetan; Memulakan kiraan kepada 1; Memulakan kiri ke 0 dan kanan ke 1 untuk melintasi rentetan; Memeriksa jika aksara berturut -turut adalah sama dan kenaikan kiraan; Apabila kita menghadapi watak yang berbeza; Meningkatkan hasilnya; Untuk mengulangi keseluruhan proses set kiri sama dan mengira pembolehubah kepada 1; Simpan nilai akhir hasil; Kod pemacu", "code": "function findNumbers ( s ) { var n = s . length ; var count = 1 ; var result = 0 ; var left = 0 ; var right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) { count ++ ; } else { result += parseInt ( count * ( count + 1 ) / 2 ) ; left = right ; count = 1 ; } right ++ ; } result += parseInt ( count * ( count + 1 ) / 2 ) ; document . write ( result ) ; } var s = \" \" ; findNumbers ( s ) ;"}
{"text": "Program untuk menduplikasi vokal dalam rentetan | Berfungsi untuk memeriksa vokal; Berfungsi untuk mendapatkan rentetan yang dihasilkan dengan vokal yang diduplikasi; Satu lagi rentetan untuk menyimpan rentetan yang dihasilkan; Gelung untuk memeriksa setiap watak; Kod pemacu; Cetak rentetan asal; Cetak tali yang dihasilkan", "code": "function isVowel ( ch ) { ch = ch . toUpperCase ( ) ; return ( ch == ' ' ch == ' ' ch == ' ' ch == ' ' ch == ' ' ) ; } function duplicateVowels ( str ) { let t = str . length ; let res = \" \" ; for ( let i = 0 ; i < t ; i ++ ) { if ( isVowel ( str [ i ] ) ) res += str [ i ] ; res += str [ i ] ; } return res ; } let str = \" \" ; document . write ( \" \" + str + \" \" ) ; let res = duplicateVowels ( str ) ; document . write ( \" \" + res + \" \" ) ;"}
{"text": "Tukar rentetan ke integer menggunakan rekursi | Fungsi rekursif untuk menukar rentetan ke integer; Jika nombor yang diwakili sebagai rentetan hanya mengandungi satu digit, maka mengembalikan nilainya; Panggilan rekursif untuk sub -rentetan bermula pada watak kedua; Digit pertama nombor; Digit pertama didarab dengan kuasa yang sesuai 10 dan kemudian tambah hasil rekursif sebagai contoh, xy = ((x * 10) + y); Kod pemacu", "code": "function stringToInt ( str ) { if ( str . length == 1 ) return ( str [ 0 ] - ' ' ) ; var y = stringToInt ( str . substring ( 1 ) ) ; var x = str [ 0 ] - ' ' ; x = x * Math . pow ( 10 , str . Length - 1 ) + y ; return ( x ) ; } var str = \" \" . split ( ) document . write ( stringToInt ( str ) ) ;"}
{"text": "Susunan terpanjang dengan sekurang -kurangnya satu watak yang terdapat dalam setiap rentetan | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan panjang sub -urutan terpanjang dengan sekurang -kurangnya satu watak biasa dalam setiap rentetan; Kira [0] akan menyimpan bilangan rentetan yang mengandungi 'A', kiraan [1] akan menyimpan bilangan rentetan yang mengandungi 'B' dan sebagainya. . ; Untuk setiap rentetan; Arus hash untuk menetapkan watak mana yang ada dalam rentetan semasa; Jika watak semasa muncul dalam rentetan maka kemas kini kiraannya; Kod pemacu", "code": "var MAX = 26 ; function largestSubSeq ( arr , n ) { var count = Array ( MAX ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { var str = arr [ i ] ; var hash = Array ( MAX ) . fill ( 0 ) ; for ( var j = 0 ; j < str . length ; j ++ ) { hash [ str [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = true ; } for ( var j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } return count . reduce ( ( a , b ) => Math . max ( a , b ) ) ; } var arr = [ \" \" , \" \" , \" \" ] ; var n = arr . length ; document . write ( largestSubSeq ( arr , n ) ) ;"}
{"text": "Menjana nombor dengan operasi yang diberikan dan periksa sama ada Palindrome | Fungsi yang kembali benar jika STR adalah palindrome; Fungsi yang mengembalikan benar jika rentetan yang dihasilkan adalah palindrome; sub mengandungi n sebagai rentetan; Kirakan jumlah digit; Ulangi substring sehingga panjang rentetan yang dihasilkan <jumlah; Jika panjang rentetan yang dihasilkan melebihi jumlah maka ambil substring dari 0 hingga jumlah - 1; Jika rentetan yang dihasilkan adalah palindrome; Kod pemacu", "code": "function isPalindrome ( str ) { let len = str . length ; for ( let i = 0 ; i < len / 2 ; i ++ ) { if ( str [ i ] != str [ len - 1 - i ] ) return false ; } return true ; } function createStringAndCheckPalindrome ( N ) { let sub = \" \" + N , res_str = \" \" ; let sum = 0 ; while ( N > 0 ) { let digit = N % 10 ; sum += digit ; N = N / 10 ; } while ( res_str . length < sum ) res_str += sub ; if ( res_str . length > sum ) res_str = res_str . substring ( 0 , sum ) ; if ( isPalindrome ( res_str ) ) return true ; return false ; } let N = 10101 ; if ( createStringAndCheckPalindrome ( N ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Kurangkan panjang rentetan dengan mengeluarkan kejadian hanya satu aksara | Berfungsi untuk mencari panjang minimum; Hitung kekerapan setiap abjad; Cari huruf dengan kekerapan maksimum; Tolak kekerapan aksara dari panjang rentetan; Kod pemacu", "code": "function minimumLength ( s ) { var maxOcc = 0 , n = s . length ; var arr = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) arr [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; } var str = \" \" ; document . write ( minimumLength ( str ) ) ;"}
{"text": "Keluarkan semua aksara selain Alphabets dari String | berfungsi untuk mengeluarkan aksara dan mencetak rentetan baru; Mencari watak yang nilai ASCII jatuh di bawah julat ini; memadamkan fungsi untuk memadamkan watak; Kod pemacu", "code": "function removeSpecialCharacter ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] < ' ' s [ i ] > ' ' && s [ i ] < ' ' s [ i ] > ' ' ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; i -- ; } } document . write ( s ) ; } let s = \" \" ; removeSpecialCharacter ( s ) ;"}
{"text": "Keluarkan semua aksara selain Alphabets dari String | berfungsi untuk mengeluarkan aksara dan mencetak rentetan baru; Menyimpan hanya aksara yang sah; kod pemacu", "code": "function removeSpecialCharacter ( str ) { let s = str . split ( \" \" ) ; let j = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( ( s [ i ] >= ' ' && s [ i ] <= ' ' ) || ( s [ i ] >= ' ' && s [ i ] <= ' ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } document . write ( ( s ) . join ( \" \" ) . substring ( 0 , j ) ) ; } let s = \" \" ; removeSpecialCharacter ( s ) ;"}
{"text": "Cari watak berulang yang hadir terlebih dahulu dalam rentetan | Program JavaScript untuk mencari watak pertama yang diulang; Ini adalah kaedah O (n ^ 2); Kod pemacu", "code": "function findRepeatFirstN2 ( s ) { let p = - 1 , i , j ; for ( i = 0 ; i < s . length ; i ++ ) { for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; } let str = \" \" ; let pos = findRepeatFirstN2 ( str ) ; if ( pos == - 1 ) document . write ( \" \" ) ; else document . write ( str [ pos ] ) ;"}
{"text": "Cetak watak dan frekuensi mereka mengikut urutan kejadian | Pelaksanaan JavaScript untuk mencetak aksara dan frekuensi dalam rangka kejadiannya; Simpan semua watak dan frekuensi mereka dalam kamus; Cetak watak dan frekuensi mereka dalam susunan yang sama penampilan mereka; Cetak hanya jika watak ini tidak dicetak sebelum ini; Kod pemacu", "code": "function prCharWithFreq ( s ) { var d = new Map ( ) ; s . split ( ' ' ) . forEach ( element => { if ( d . has ( element ) ) { d . set ( element , d . get ( element ) + 1 ) ; } else d . set ( element , 1 ) ; } ) ; s . split ( ' ' ) . forEach ( element => { if ( d . has ( element ) && d . get ( element ) != 0 ) { document . write ( element + d . get ( element ) + \" \" ) ; d . set ( element , 0 ) ; } } ) ; } var s = \" \" ; prCharWithFreq ( s ) ;"}
{"text": "Kira bilangan rentetan (diperbuat daripada r, g dan b) menggunakan kombinasi yang diberikan | Berfungsi untuk mengira bilangan rentetan; Menyimpan faktorial nombor sehingga n untuk pengiraan selanjutnya; Cari nilai yang akan ditambah; Buat semua kemungkinan kombinasi R, B dan G untuk nilai yang tinggal; Kirakan permutasi setiap gabungan satu demi satu dan tambahkannya. ; Kembali Jumlah No. rentetan / permutasi; Kod pemandu", "code": "function possibleStrings ( n , r , b , g ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; let left = n - ( r + g + b ) ; let sum = 0 ; for ( let i = 0 ; i <= left ; i ++ ) { for ( let j = 0 ; j <= left - i ; j ++ ) { let k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; } let n = 4 , r = 2 ; let b = 0 , g = 1 ; document . write ( possibleStrings ( n , r , b , g ) ) ;"}
{"text": "Keluarkan bilangan minimum aksara supaya dua rentetan menjadi anagram | fungsi untuk mengira bilangan minimum aksara yang akan dikeluarkan untuk membuat dua rentetan anagram; Buat array hash untuk kedua -dua rentetan dan hitung kekerapan setiap aksara; Mengira kekerapan setiap aksara dalam rentetan pertama; Mengira kekerapan setiap aksara dalam rentetan kedua; TRAVERSE COUNT TRAVSE untuk mencari bilangan aksara yang akan dikeluarkan; Program pemacu untuk menjalankan kes itu", "code": "function remAnagram ( str1 , str2 ) { var count1 = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; var count2 = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < str1 . length ; i ++ ) count1 [ str1 . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( i = 0 ; i < str2 . length ; i ++ ) count2 [ str2 . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; var result = 0 ; for ( i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; } var str1 = \" \" , str2 = \" \" ; document . write ( remAnagram ( str1 , str2 ) ) ;"}
{"text": "Semak jika rentetan mempunyai semua aksara dengan kekerapan yang sama dengan satu variasi yang dibenarkan | Dengan mengandaikan hanya aksara kes yang lebih rendah; Untuk memeriksa rentetan S boleh ditukar kepada rentetan yang sah dengan mengeluarkan kurang daripada atau sama dengan satu aksara. ; Freq []: Menyimpan kekerapan setiap aksara rentetan; Cari watak pertama dengan kekerapan bukan sifar; Cari watak dengan kekerapan yang berbeza daripada Freq1. ; Jika kita mendapati kekerapan bukan sifar ketiga atau kiraan kedua -dua frekuensi menjadi lebih daripada 1, maka kembali palsu; } else jika kita mencari non -sifar non -sifar ketiga; Jika tuduhan kedua -dua frekuensi lebih daripada 1; Kembali benar jika kita sampai di sini; Kod pemacu", "code": "let CHARS = 26 ; function isValidString ( str ) { let freq = new Array ( CHARS ) ; for ( let i = 0 ; i < CHARS ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < str . length ; i ++ ) { freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } let i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } let j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) { count_freq1 ++ ; } else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( let k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) { count_freq1 ++ ; } if ( freq [ k ] == freq2 ) { count_freq2 ++ ; { return false ; } } if ( count_freq1 > 1 && count_freq2 > 1 ) { return false ; } } return true ; } let str = \" \" ; if ( isValidString ( str ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Semak jika rentetan mempunyai semua aksara dengan kekerapan yang sama dengan satu variasi yang dibenarkan | Untuk memeriksa rentetan S boleh ditukar kepada rentetan variasi; Run Loop Borang 0 hingga panjang rentetan; pengisytiharan pembolehubah; jika pertama adalah benar daripada kenaikan countofval1; jika kedua adalah benar daripada kenaikan countofval2; Kod pemacu", "code": "function checkForVariation ( str ) { if ( str == null str . length == 0 ) { return true ; } let map = new Map ( ) ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( ! map . has ( str [ i ] ) ) map . set ( str [ i ] , 0 ) ; map . set ( str [ i ] , map . get ( str [ i ] ) + 1 ) ; } let first = true , second = true ; let val1 = 0 , val2 = 0 ; let countOfVal1 = 0 , countOfVal2 = 0 ; for ( let [ key , value ] of map . entries ( ) ) { let i = value ; if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; } if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } } document . write ( checkForVariation ( \" \" ) ) ;"}
{"text": "Pasangan rentetan lengkap dalam dua set rentetan | Mengembalikan kiraan pasangan lengkap dari set [0 .. n - 1] dan set2 [0 .. m - 1]; Pertimbangkan semua pasangan kedua -dua rentetan; Buat penggabungan pasangan semasa; Mengira frekuensi semua aksara dalam rentetan yang disatukan. ; Jika kekerapan mana -mana watak tidak lebih besar daripada 0, maka pasangan ini tidak lengkap. ; Kod pemacu", "code": "function countCompletePairs ( set1 , set2 , n , m ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { let concat = set1 [ i ] + set2 [ j ] ; let frequency = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { frequency [ i ] = 0 ; } for ( let k = 0 ; k < concat . length ; k ++ ) { frequency [ concat [ k ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } let k ; for ( k = 0 ; k < 26 ; k ++ ) { if ( frequency [ k ] < 1 ) { break ; } } if ( k == 26 ) { result ++ ; } } } return result ; } let set1 = [ \" \" , \" \" , \" \" , \" \" ] ; let set2 = [ \" \" , \" \" , \" \" ] let n = set1 . length ; let m = set2 . length ; document . write ( countCompletePairs ( set1 , set2 , n , m ) ) ;"}
{"text": "Pasangan rentetan lengkap dalam dua set rentetan | Mengembalikan kiraan pasangan lengkap dari set [0 .. n - 1] dan set2 [0 .. m - 1]; con_s1 [i] akan menyimpan integer yang set bit mewakili kehadiran / ketiadaan aksara dalam rentetan set1 [i]. Begitu juga con_s2 [i] akan menyimpan integer yang set bit mewakili kehadiran / ketiadaan aksara dalam rentetan set2 [i]; Proses semua rentetan dalam set1 []; memulakan semua bit ke 0; Menetapkan Kod ASCII Char S [i] [J] hingga 1 dalam integer yang dimampatkan. ; Proses semua rentetan dalam SET2 []; memulakan semua bit ke 0; Menetapkan Kod ASCII Char S [i] [J] hingga 1 dalam integer yang dimampatkan. ; Menetapkan pembolehubah yang semua 26 (0 ... 25) bit ditetapkan kepada 1; Sekarang pertimbangkan setiap pasangan integer dalam con_s1 [] dan con_s2 [] dan periksa sama ada pasangan itu selesai. ; Jika semua bit ditetapkan, rentetan selesai! ; Kod pemacu", "code": "function countCompletePairs ( set1 , set2 , n , m ) { let result = 0 ; let con_s1 = new Array ( n ) ; let con_s2 = new Array ( m ) ; for ( let i = 0 ; i < n ; i ++ ) { con_s1 [ i ] = 0 ; for ( let j = 0 ; j < set1 [ i ] . length ; j ++ ) { con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ; } } for ( let i = 0 ; i < m ; i ++ ) { con_s2 [ i ] = 0 ; for ( let j = 0 ; j < set2 [ i ] . length ; j ++ ) { con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ; } } let complete = ( 1 << 26 ) - 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) { result ++ ; } } } return result ; } let set1 = [ \" \" , \" \" , \" \" , \" \" ] ; let set2 = [ \" \" , \" \" , \" \" ] let n = set1 . length ; let m = set2 . length ; document . write ( countCompletePairs ( set1 , set2 , n , m ) ) ;"}
{"text": "Cari semua rentetan yang sepadan dengan corak tertentu dalam kamus | Fungsi untuk mengekodkan rentetan yang diberikan; untuk setiap watak dalam rentetan yang diberikan; Sekiranya watak itu berlaku untuk kali pertama, berikan nombor unik seterusnya kepada char itu; tambah nombor yang berkaitan dengan watak semasa ke dalam rentetan output; Fungsi untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam corak dipetakan secara unik kepada watak dalam kamus; Len adalah panjang corak; encode rentetan; untuk setiap perkataan dalam pelbagai kamus; Jika saiz corak sama dengan saiz kata kamus semasa dan kedua -dua corak dan perkataan mempunyai hash yang sama, cetak perkataan; Kod pemacu", "code": "function encodeString ( str ) { let map = new Map ( ) ; let res = \" \" ; let i = 0 ; let ch ; for ( let j = 0 ; j < str . length ; j ++ ) { ch = str [ j ] ; if ( ! map . has ( ch ) ) map . set ( ch , i ++ ) ; res += map . get ( ch ) ; } return res ; } function findMatchedWords ( dict , pattern ) { let len = pattern . length ; let hash = encodeString ( pattern ) ; for ( let word = 0 ; word < dict . length ; word ++ ) { if ( dict [ word ] . length == len && encodeString ( dict [ word ] ) == ( hash ) ) document . write ( dict [ word ] + \" \" ) ; } } let dict = [ \" \" , \" \" , \" \" , \" \" ] ; let pattern = \" \" ; findMatchedWords ( dict , pattern ) ;"}
{"text": "Cari semua rentetan yang sepadan dengan corak tertentu dalam kamus | Program JavaScript untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam coraknya dipetakan secara unik kepada watak dalam kamus; Fungsi untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam corak dipetakan secara unik kepada watak dalam kamus; Len adalah panjang corak; Untuk setiap perkataan dalam kamus; Kod pemacu", "code": "function check ( pattern , word ) { if ( pattern . length != word . length ) return false ; let ch = new Array ( 128 ) ; for ( let i = 0 ; i < 128 ; i ++ ) { ch [ i ] = 0 ; } let Len = word . length ; for ( let i = 0 ; i < Len ; i ++ ) { if ( ch [ pattern [ i ] . charCodeAt ( 0 ) ] == 0 ) { ch [ pattern [ i ] . charCodeAt ( 0 ) ] = word [ i ] ; } else if ( ch [ pattern [ i ] . charCodeAt ( 0 ) ] != word [ i ] ) { return false ; } } return true ; } function findMatchedWords ( dict , pattern ) { let Len = pattern . length ; let result = \" \" ; for ( let word of dict . values ( ) ) { if ( check ( pattern , word ) ) { result = word + \" \" + result ; } } document . write ( result ) ; } let dict = new Set ( ) ; dict . add ( \" \" ) ; dict . add ( \" \" ) ; dict . add ( \" \" ) ; dict . add ( \" \" ) ; let pattern = \" \" ; findMatchedWords ( dict , pattern ) ;"}
{"text": "Kira perkataan dalam rentetan yang diberikan | Berfungsi untuk mengira jumlah perkataan dalam rentetan; Semak sama ada rentetan itu batal atau kosong kemudian kembali sifar; Menukar rentetan yang diberikan ke dalam array watak; Semak sama ada watak itu adalah huruf dan indeks array aksara tidak sama dengan akhir baris yang bermaksud, ia adalah perkataan dan set isword oleh benar; Semak sama ada watak itu bukan surat yang bermaksud terdapat ruang, maka kami menambah kata -kata dengan satu dan tetapkan isword dengan palsu; Semak perkataan terakhir ayat dan kenaikan kata WordCount oleh satu; Kembalikan jumlah perkataan dalam rentetan; Diberikan string str; Cetak hasilnya", "code": "function countWords ( str ) { if ( str == null str . length == 0 ) return 0 ; let wordCount = 0 ; let isWord = false ; let endOfLine = str . length - 1 ; let ch = str . split ( \" \" ) ; for ( let i = 0 ; i < ch . length ; i ++ ) { if ( isLetter ( ch [ i ] ) && i != endOfLine ) isWord = true ; else if ( ! isLetter ( ch [ i ] ) && isWord ) { wordCount ++ ; isWord = false ; } else if ( isLetter ( ch [ i ] ) && i == endOfLine ) wordCount ++ ; } return wordCount ; } function isLetter ( c ) { return c . toLowerCase ( ) != c . toUpperCase ( ) ; } let str = \" \" ; document . write ( \" \" + countWords ( str ) ) ;"}
{"text": "Kata -kata terbalik dalam rentetan yang diberikan | Membalikkan rentetan; Semak sama ada bilangan perkataan walaupun; Cari perkataan tengah; Bermula dari pertengahan mula menukar kata -kata di kedudukan jth dan kedudukan l - 1 - j; Semak sama ada bilangan perkataan adalah ganjil; Cari perkataan tengah; Bermula dari pertengahan mula menukar kata -kata di kedudukan jth dan kedudukan l - 1 - j; Mengembalikan kalimat terbalik; Kod pemacu", "code": "function RevString ( s , l ) { if ( l % 2 == 0 ) { let j = parseInt ( l / 2 , 10 ) ; while ( j <= l - 1 ) { let temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } else { let j = parseInt ( ( l / 2 ) , 10 ) + 1 ; while ( j <= l - 1 ) { let temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } let S = s [ 0 ] ; for ( let i = 1 ; i < 9 ; i ++ ) { S = S + \" \" + s [ i ] ; } return S ; } let s = \" \" \" \" ; let words = [ \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" ] ; document . write ( RevString ( words , 9 ) ) ;"}
{"text": "Laluan cetak dari akar ke semua nod dalam pokok binari yang lengkap | Berfungsi untuk mencetak laluan semua nod nth node mewakili sebagai node node node yang diberikan mewakili sebagai nod kiri dan kanan; Keadaan asas jika nilai nod kth lebih besar maka nod nth maka nod kth bermakna tidak sah sehingga kami tidak menyimpannya ke dalam res hanya kami hanya kembali; Menyimpan nod ke res; Cetak jalan dari akar ke nod; Simpan jalan kiri pokok supaya kiri kita akan pergi nod (kthNode * 2); Jalan kanan pokok dan untuk betul kita akan pergi nod (kthnode * 2 + 1); Berfungsi untuk mencetak laluan dari akar ke semua nod; Res adalah untuk menyimpan jalan dari akar ke nod partikulat; Cetak jalan dari akar ke semua nod. Hujah ketiga 1 kerana kita perlu mempertimbangkan nod akar adalah 1; Diberikan nod; Cetak jalan dari akar ke semua nod.", "code": "function printPath ( res , nThNode , kThNode ) { if ( kThNode > nThNode ) return ; res . push ( kThNode ) ; for ( var i = 0 ; i < res . length ; i ++ ) document . write ( res [ i ] + \" \" ) ; document . write ( \" \" ) ; printPath ( res , nThNode , kThNode * 2 ) ; printPath ( res , nThNode , kThNode * 2 + 1 ) ; res . pop ( ) } function printPathToCoverAllNodeUtil ( nThNode ) { var res = [ ] ; printPath ( res , nThNode , 1 ) ; } var nThNode = 7 ; printPathToCoverAllNodeUtil ( nThNode ) ;"}
{"text": "Array Range Queries Untuk Mencari Nombor Armstrong Maksimum dengan Kemas Kini | Fungsi utiliti untuk mendapatkan indeks pertengahan julat yang diberikan. ; Fungsi yang kembali benar jika num adalah armstrong lain kembali palsu; Fungsi rekursif untuk mendapatkan jumlah nilai dalam julat array yang diberikan. Berikut adalah parameter untuk fungsi ini. st. Penunjuk ke nod pokok segmen. Indeks nod semasa dalam pokok segmen. SS & SE. Memulakan dan mengakhiri indeks segmen yang diwakili oleh nod semasa, i. e. , St [nod] L & R. Memulakan dan mengakhiri indeks pertanyaan pelbagai; Jika segmen nod ini benar -benar sebahagian daripada julat yang diberikan, maka kembalikan segmen maksimum. ; Jika segmen nod ini tidak tergolong dalam julat yang diberikan; Jika segmen nod ini sebahagiannya adalah sebahagian daripada julat yang diberikan; Fungsi rekursif untuk mengemas kini nod yang telah diberikan indeks dalam julatnya. Berikut adalah parameter ST, SS dan SE adalah sama seperti yang ditakrifkan di atas indeks. Indeks elemen yang akan dikemas kini. ; nilai kemas kini dalam array dan dalam pokok segmen; Kembalikan max elemen dalam julat dari indeks l (pertanyaan permulaan) ke r (ujung pertanyaan). ; Semak nilai input yang salah; Fungsi rekursif yang membina pokok segmen untuk array [ss. . se]. Si adalah indeks nod semasa dalam segmen Tree St; Jika terdapat satu elemen dalam array, simpannya dalam nod semasa pokok segmen dan kembali; Sekiranya terdapat lebih daripada satu elemen, maka berulang untuk subtrees kiri dan kanan dan simpan nilai maksimum dalam nod ini; Fungsi ke pokok segmen Cona dari array yang diberikan. Fungsi ini memperuntukkan memori untuk pokok segmen. ; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan ST; Mengembalikan pokok segmen yang dibina; Kod pemacu; Membina pokok segmen dari array yang diberikan; Cetak maksimum nilai dalam array dari indeks 1 hingga 3; Kemas kini: Tetapkan ARR [1] = 153 dan kemas kini nod pokok segmen yang sepadan. ; Cari max selepas nilai dikemas kini", "code": "function getMid ( s , e ) { return s + Math . floor ( ( e - s ) / 2 ) ; } function isArmstrong ( x ) { let n = ( x ) . toString ( ) . length ; let sum1 = 0 ; let temp = x ; while ( temp > 0 ) { let digit = temp % 10 ; sum1 += Math . pow ( digit , n ) ; temp = Math . floor ( temp / 10 ) ; } if ( sum1 == x ) return true ; return false ; } function MaxUtil ( st , ss , se , l , r , node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return - 1 ; let mid = getMid ( ss , se ) ; return Math . max ( MaxUtil ( st , ss , mid , l , r , 2 * node ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 1 ) ) ; } function updateValue ( arr , st , ss , se , index , value , node ) { if ( index < ss index > se ) { document . write ( \" \" + \" \" ) ; return ; } if ( ss == se ) { arr [ index ] = value ; if ( isArmstrong ( value ) ) st [ node ] = value ; else st [ node ] = - 1 ; } else { let mid = getMid ( ss , se ) ; if ( index >= ss && index <= mid ) updateValue ( arr , st , ss , mid , index , value , 2 * node ) ; else updateValue ( arr , st , mid + 1 , se , index , value , 2 * node + 1 ) ; st [ node ] = Math . max ( st [ 2 * node + 1 ] , st [ 2 * node + 2 ] ) ; } return ; } function getMax ( st , n , l , r ) { if ( l < 0 r > n - 1 l > r ) { document . write ( \" \" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; } function constructSTUtil ( arr , ss , se , st , si ) { if ( ss == se ) { if ( isArmstrong ( arr [ ss ] ) ) st [ si ] = arr [ ss ] ; else st [ si ] = - 1 ; return st [ si ] ; } let mid = getMid ( ss , se ) ; st [ si ] = Math . max ( constructSTUtil ( arr , ss , mid , st , si * 2 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 1 ) ) ; return st [ si ] ; } function constructST ( arr , n ) { let x = ( Math . ceil ( Math . log ( n ) ) ) ; let max_size = 2 * Math . pow ( 2 , x ) - 1 ; let st = new Array ( max_size ) ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } let arr = [ 192 , 113 , 535 , 7 , 19 , 111 ] ; let n = arr . length ; let st = constructST ( arr , n ) ; document . write ( \" \" + \" \" + getMax ( st , n , 1 , 3 ) + \" \" ) ; updateValue ( arr , st , 0 , n - 1 , 1 , 153 , 0 ) ; document . write ( \" \" + \" \" + getMax ( st , n , 1 , 3 ) + \" \" ) ;"}
{"text": "Bilangan maksimum rantau di mana n non | Berfungsi untuk mencari bilangan maksimum kawasan di atas kapal terbang; Cetak bilangan maksimum kawasan; Kod pemacu", "code": "function maxRegions ( n ) { let num ; num = parseInt ( n * ( n + 1 ) / 2 ) + 1 ; document . write ( num ) ; } let n = 10 ; maxRegions ( n ) ;"}
{"text": "Semak sama ada teka -teki jigsaw boleh diselesaikan atau tidak | Berfungsi untuk memeriksa sama ada teka -teki jigsaw boleh diselesaikan atau tidak; Kes asas; Dengan meletakkan tab kosong sebagai rantai; Kod pemacu", "code": "function checkSolveable ( n , m ) { if ( n == 1 m == 1 ) document . write ( \" \" ) ; else if ( m == 2 && n == 2 ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } let n = 1 , m = 3 ; checkSolveable ( n , m ) ;"}
{"text": "Semak sama ada mungkin untuk mencapai (x, y) dari (1, 0) dengan langkah -langkah yang diberikan | Berfungsi untuk mencari GCD dua nombor A dan B; Kes asas; Recursif mencari GCD; Fungsi untuk memeriksa sama ada (x, y) boleh dicapai dari (1, 0) dari langkah yang diberikan; Jika GCD adalah 1, kemudian cetak \"Ya\"; Diberikan x dan y; Panggilan fungsi", "code": "function GCD ( a , b ) { if ( b == 0 ) return a ; else return GCD ( b , a % b ) ; } function check ( x , y ) { if ( GCD ( x , y ) == 1 ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } } let X = 2 , Y = 7 ; check ( X , Y ) ;"}
{"text": "Kebarangkalian fungsi ketat Euler dalam julat [l, r] untuk dibahagikan dengan m | Program JavaScript untuk melaksanakan pendekatan di atas; Seieve of erotosthenes untuk mengira semua prima; Jika Perdana; Tandakan semua gandaannya sebagai bukan perdana; Fungsi untuk mencari kebarangkalian fungsi ketat Euler dalam julat tertentu; Memulakan dua tatasusunan dengan nilai dari L ke R untuk Totient Euler; Pengindeksan dari 0; Jika nombor semasa adalah perdana; Memeriksa jika saya adalah faktor utama nombor dalam julat l ke r; Kemas kini semua nombor yang mempunyai faktor utama i; Jika nombor dalam julat mempunyai faktor utama> matematik. Sqrt (nombor); Hitung mereka yang boleh dibahagikan dengan m; Mengembalikan hasilnya; Kod pemacu", "code": "let size = 1000001 ; let prime = new Array ( size , 0 ) ; function seiveOfEratosthenes ( ) { prime [ 0 ] = 1 ; prime [ 1 ] = 0 ; for ( let i = 2 ; i * i < 1000001 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( let j = i * i ; j < 1000001 ; j += i ) { prime [ j ] = 1 ; } } } } function probabiltyEuler ( L , R , M ) { let arr = new Array ( size , 0 ) ; let eulerTotient = new Array ( size , 0 ) ; let count = 0 ; for ( let i = L ; i <= R ; i ++ ) { eulerTotient [ i - L ] = i ; arr [ i - L ] = i ; } for ( let i = 2 ; i < 1000001 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( let j = ( L / i ) * i ; j <= R ; j += i ) { if ( j - L >= 0 ) { eulerTotient [ j - L ] = eulerTotient [ j - L ] / i * ( i - 1 ) ; while ( arr [ j - L ] % i == 0 ) { arr [ j - L ] /= i ; } } } } } for ( let i = L ; i <= R ; i ++ ) { if ( arr [ i - L ] > 1 ) { eulerTotient [ i - L ] = ( eulerTotient [ i - L ] / arr [ i - L ] ) * ( arr [ i - L ] - 1 ) ; } } for ( let i = L ; i <= R ; i ++ ) { if ( ( eulerTotient [ i - L ] % M ) == 0 ) { count ++ ; } } count /= 2 ; return 1.0 * count / ( R + 1 - L ) ; } seiveOfEratosthenes ( ) ; let L = 1 ; let R = 7 ; let M = 3 ; document . write ( probabiltyEuler ( L , R , M ) . toFixed ( 7 ) ) ;"}
{"text": "Permainan pembahagi ganjil terbesar untuk memeriksa pemain mana yang menang | Berfungsi untuk mencari permainan divisior ganjil terbesar untuk memeriksa pemain mana yang menang; Semak jika n == 1 maka pemain 2 akan menang; Semak jika n == 2 atau n adalah ganjil; Manakala n lebih besar daripada k dan dibahagikan dengan 2 terus meningkatkan val; Gelung untuk mencari pembahagi ganjil yang paling hebat; Periksa sama ada n adalah kuasa 2; Semak sama ada CNT bukanlah pemain yang menang 1; Kod pemacu", "code": "function findWinner ( n , k ) { let cnt = 0 ; if ( n == 1 ) document . write ( \" \" ) ; else if ( ( n & 1 ) != 0 n == 2 ) document . write ( \" \" ) ; else { let tmp = n ; let val = 1 ; while ( tmp > k && tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( let i = 3 ; i <= Math . sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) document . write ( \" \" ) ; else if ( n / tmp == 2 && cnt == 1 ) document . write ( \" \" ) ; else document . write ( \" \" ) ; } } let n = 1 , k = 1 ; findWinner ( n , k ) ;"}
{"text": "Cari semua nombor sehingga N yang kedua -dua pentagonal dan heksagon | Berfungsi untuk nombor prvar sehingga kedua -dua pentagonal dan nombor heksagon; Kirakan nombor pentagonal saya; Semak sama ada nombor pentagonal PN adalah heksagon atau tidak; Kod pemacu", "code": "function pen_hex ( n ) { var pn = 1 ; for ( i = 1 ; i < n ; i ++ ) { pn = parseInt ( i * ( 3 * i - 1 ) / 2 ) ; if ( pn > n ) break ; var seqNum = ( 1 + Math . sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == parseInt ( seqNum ) ) document . write ( pn + \" \" ) ; } } var N = 1000000 ; pen_hex ( N ) ;"}
{"text": "Semak jika baris | Fungsi untuk memeriksa sama ada baris - perintah utama traversal matriks adalah palindrome; Gelung untuk memeriksa sama ada matriks adalah matriks adalah palindrome atau tidak; Kod pemacu", "code": "function isPal ( a , n , m ) { for ( let i = 0 ; i < n / 2 ; i ++ ) { for ( let j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; } let n = 3 , m = 3 ; let a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 4 ] , [ 3 , 2 , 1 ] ] ; if ( isPal ( a , n , m ) ) { document . write ( \" \" + \" \" ) ; } else { document . write ( \" \" + \" \" ) ; }"}
{"text": "Cari nombor terkecil yang jumlah digitnya adalah n | Berfungsi untuk mendapatkan jumlah digit; Berfungsi untuk mencari nombor terkecil yang jumlah digit juga n; Memeriksa jika nombor mempunyai jumlah digit = n; Kod pemacu", "code": "function getSum ( n ) { let sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = Math . floor ( n / 10 ) ; } return sum ; } function smallestNumber ( N ) { let i = 1 ; while ( 1 ) { if ( getSum ( i ) == N ) { document . write ( i ) ; break ; } i ++ ; } } let N = 10 ; smallestNumber ( N ) ;"}
{"text": "Nombor jarang | Fungsi berulang untuk membalikkan digit NUM; Fungsi untuk memeriksa sama ada N adalah persegi sempurna; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Fungsi untuk memeriksa sama ada n adalah nombor yang jarang berlaku; Cari terbalik n; Nombor harus bukan palindromic; Kod pemacu", "code": "function reversDigits ( num ) { let rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = parseInt ( num / 10 ) ; } return rev_num ; } function isPerfectSquare ( x ) { let sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } function isRare ( N ) { let reverseN = reversDigits ( N ) ; if ( reverseN == N ) return false ; return isPerfectSquare ( N + reverseN ) && isPerfectSquare ( N - reverseN ) ; } let n = 65 ; if ( isRare ( n ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text": "Kira nombor dari julat yang faktor utama hanya 2 dan 3 menggunakan tatasusunan | Tetapkan 2 | Fungsi yang akan mengira unsur -unsur dalam julat yang diberikan; Simpan kuasa semasa 2; Simpan kuasa semasa 3; Power23 [] akan menyimpan produk pasangan unsur -unsur Power2 dan Power3 yang <= r; Masukkan dalam Power23] [] hanya jika Mul <= r; Simpan jawapan yang diperlukan; Cetak hasilnya; Kod pemacu", "code": "function calc_ans ( l , r ) { var power2 = [ ] , power3 = [ ] ; var mul2 = 1 ; while ( mul2 <= r ) { power2 . push ( mul2 ) ; mul2 *= 2 ; } var mul3 = 1 ; while ( mul3 <= r ) { power3 . push ( mul3 ) ; mul3 *= 3 ; } var power23 = [ ] ; for ( var x = 0 ; x < power2 . length ; x ++ ) { for ( var y = 0 ; y < power3 . length ; y ++ ) { var mul = power2 [ x ] * power3 [ y ] ; if ( mul == 1 ) continue ; if ( mul <= r ) power23 . push ( mul ) ; } } var ans = 0 ; power23 . forEach ( x => { if ( x >= l && x <= r ) ans ++ ; } ) ; document . write ( ans ) ; } var l = 1 , r = 10 ; calc_ans ( l , r ) ;"}
{"text": "Count k panjangnya yang produknya juga | Fungsi untuk mengira NCR; Mengembalikan faktorial n; Fungsi untuk mencari bilangan Kekuatan panjang K yang produknya adalah bilangannya; mengira nombor ganjil dalam array; Kod pemacu", "code": "function nCr ( n , r ) { if ( r > n ) return 0 ; return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } function fact ( n ) { var res = 1 ; for ( var i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } function countSubsequences ( arr , n , k ) { var countOdd = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) countOdd ++ ; } var ans = nCr ( n , k ) - nCr ( countOdd , k ) ; return ans ; } var arr = [ 2 , 4 ] ; var K = 1 ; var N = arr . length ; document . write ( countSubsequences ( arr , N , K ) ) ;"}
{"text": "Cari bit yang paling ketara dari nombor x dalam asas y | Berfungsi untuk mencari digit pertama x dalam asas y; mengira bilangan digit x dalam asas y; Mencari digit pertama X dalam asas y; Kod pemacu", "code": "function first_digit ( x , y ) { var length = parseInt ( Math . log ( x ) / Math . log ( y ) ) + 1 ; var first_digit = parseInt ( x / Math . pow ( y , length - 1 ) ) ; document . write ( first_digit ) ; } var X = 55 , Y = 3 ; first_digit ( X , Y ) ;"}
{"text": "Nombor Curzon | Berfungsi untuk memeriksa sama ada nombor adalah nombor curzon atau tidak; Cari 2 ^ n + 1; Cari 2 * n + 1; Semak untuk pembahagian; Kod pemacu", "code": "function checkIfCurzonNumber ( N ) { var powerTerm , productTerm ; powerTerm = Math . pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) { document . write ( \" \" + \" \" ) ; } else { document . write ( \" \" ) ; } } var N = 5 ; checkIfCurzonNumber ( N ) ; N = 10 ; checkIfCurzonNumber ( N ) ;"}
{"text": "Kiraan minimum nombor yang diperlukan berakhir dengan 7 hingga jumlah sebagai nombor tertentu | Fungsi untuk mengembalikan kiraan nombor minimum yang berakhir dengan 7 yang diperlukan supaya jumlah nombor ini adalah n; Hasharr [i] akan menyimpan nombor minimum yang berakhir dengan 7 supaya ia merangkumi jumlah yang berakhir dengan Digit I; Ia sentiasa mungkin untuk menulis nombor> 69 untuk menulis sebagai nombor yang berakhir dengan 7; Jika nombor itu sama dengan jumlah nombor minimum yang berakhir dengan 7; Kod pemacu", "code": "function minCount ( n ) { let hasharr = [ 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 ] ; if ( n > 69 ) return hasharr [ n % 10 ] ; else { if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } } let n = 38 ; document . write ( minCount ( n ) ) ;"}
{"text": "Program untuk mencetak corak segitiga binari yang diubahsuai | Berfungsi untuk mencetak corak binari yang diubah suai; Gelung untuk melintasi baris; Gelung untuk melintasi nombor dalam setiap baris; Periksa sama ada J adalah 1 atau saya dalam cetakan kes 1; Lain cetak 0; Tukar kursor ke baris seterusnya selepas setiap baris; Kod pemacu; Panggilan fungsi", "code": "function modifiedBinaryPattern ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) document . write ( 1 ) ; else document . write ( 0 ) ; } document . write ( \" \" ) ; } } let n = 7 ; modifiedBinaryPattern ( n ) ;"}
{"text": "Cari bahagian sebenar dan khayalan nombor kompleks | Berfungsi untuk mencari bahagian sebenar dan khayalan nombor kompleks; panjang rentetan yang disimpan dalam pembolehubah L; pembolehubah untuk indeks pemisah; Menyimpan indeks ' +'; lain menyimpan indeks ' -'; Mencari bahagian sebenar nombor kompleks; Mencari bahagian khayalan nombor kompleks; Kod pemacu", "code": "function findRealAndImag ( s ) { let l = s . length - 1 ; let i ; if ( s . indexOf ( ' ' ) != - 1 ) { i = s . indexOf ( ' ' ) ; } else { i = s . indexOf ( ' ' ) ; } let real = s . substr ( 0 , i ) ; let imaginary = s . substr ( i + 1 , l - 2 ) ; document . write ( \" \" + real + \" \" ) ; document . write ( \" \" + imaginary ) ; } let s = \" \" ; findRealAndImag ( s ) ;"}
{"text": "Kuasa yang berbeza dari nombor n supaya jumlahnya sama dengan k | Berfungsi untuk mengembalikan kuasa tertinggi n tidak melebihi k; Gelung untuk mencari kuasa tertinggi kurang daripada k; Memulakan PowerArray dengan semua 0. ; Berfungsi untuk mencetak kuasa yang berbeza n yang menambah sehingga k; Mendapatkan kuasa tertinggi N sebelum k; Untuk memeriksa sama ada kuasa digunakan dua kali atau tidak; PRLET - 1 jika kuasa digunakan dua kali; Jika kuasa tidak dikunjungi, maka tandakan kuasa seperti yang dikunjungi; Menurunkan nilai k; Prleting kuasa n yang merangkumi k; Kod pemacu", "code": "function highestPower ( n , k ) { let i = 0 ; let a = Math . pow ( n , i ) ; while ( a <= k ) { i += 1 ; a = Math . pow ( n , i ) ; } return i - 1 ; } let b = Array . from ( { length : 50 } , ( _ , i ) => 0 ) ; function PowerArray ( n , k ) { while ( k > 0 ) { let t = highestPower ( n , k ) ; if ( b [ t ] > 0 ) { document . write ( - 1 ) ; return 0 ; } else b [ t ] = 1 ; k -= Math . pow ( n , t ) ; } for ( let i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] > 0 ) { document . write ( i + \" \" ) ; } } return 0 ; } let N = 3 ; let K = 40 ; PowerArray ( N , K ) ;"}
{"text": "Jumlah elemen dalam array yang mempunyai kekerapan komposit | Program JavaScript untuk mencari jumlah elemen dalam array yang mempunyai kekerapan komposit; Berfungsi untuk membuat ayak untuk memeriksa prima; Jika komposit [p] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada komposit; Berfungsi untuk mengembalikan jumlah elemen dalam array yang mempunyai kekerapan komposit; Peta digunakan untuk menyimpan frekuensi elemen; Untuk menyimpan jumlah; Melintasi peta menggunakan iterators; Kira bilangan elemen yang mempunyai frekuensi komposit; Kod pemacu; Panggilan fungsi", "code": "let N = 100005 function SieveOfEratosthenes ( composite ) { for ( let i = 0 ; i < N ; i ++ ) composite [ i ] = false ; for ( let p = 2 ; p * p < N ; p ++ ) { if ( ! composite [ p ] ) { for ( let i = p * 2 ; i < N ; i += p ) composite [ i ] = true ; } } } function sumOfElements ( arr , n ) { let composite = new Array ( N ) ; SieveOfEratosthenes ( composite ) ; let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( m . has ( arr [ i ] ) ) { m [ arr [ i ] ] = m [ arr [ i ] ] + 1 ; } else { m . set ( arr [ i ] , 1 ) ; } let sum = 0 ; m . forEach ( ( value , key ) => { if ( composite [ key ] ) { sum += value ; } } ) return sum ; } let arr = [ 1 , 2 , 1 , 1 , 1 , 3 , 3 , 2 , 4 ] ; let n = arr . length ; document . write ( sumOfElements ( arr , n ) ) ;"}
{"text": "Padam semua elemen kekerapan ganjil dari array | Fungsi yang menghilangkan unsur -unsur yang mempunyai frekuensi ganjil dalam array; Buat peta untuk menyimpan kekerapan setiap elemen; Keluarkan unsur -unsur yang mempunyai frekuensi ganjil; Jika elemen mempunyai kekerapan ganjil maka lompat; Kod pemacu; Panggilan fungsi", "code": "function remove ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( ( mp . has ( arr [ i ] ) && mp . get ( arr [ i ] ) % 2 == 1 ) ) continue ; document . write ( arr [ i ] + \" \" ) ; } } let arr = [ 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 ] ; let n = arr . length ; remove ( arr , n ) ;"}
{"text": "Memaksimumkan elemen pertama array supaya purata tetap tetap | Nilai maksimum elemen array pertama yang boleh dicapai; Pembolehubah untuk menyimpan jumlahnya; Gelung untuk mencari jumlah array; Nilai maksimum yang dikehendaki; Kod pemacu", "code": "function getmax ( arr , n , x ) { let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } document . write ( Math . min ( s , x ) ) ; } let arr = [ 1 , 2 , 3 , 4 ] ; let x = 5 ; let arr_size = arr . length ; getmax ( arr , arr_size , x ) ;"}
{"text": "Panjang minimum laluan terpendek segitiga | berfungsi untuk mendapatkan panjang minimum bahagian yang lebih pendek dari segitiga; melintasi setiap polet di atas kapal terbang; Jika jumlah polet lebih besar daripada yang sebelumnya, maksimum akan diganti; prlet panjang; memulakan bilangan polet; polet di kapal terbang", "code": "function shortestLength ( n , x , y ) { let answer = 0 ; let i = 0 ; while ( n != 0 && i < x . length ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } document . write ( \" \" + answer + \" \" ) ; document . write ( \" \" + \" \" + answer + \" \" + \" \" + answer + \" \" ) ; } let n = 4 ; let x = [ 1 , 4 , 2 , 1 ] ; let y = [ 4 , 1 , 1 , 2 ] ; shortestLength ( n , x , y ) ;"}
{"text": "Berpotongan segi empat tepat apabila bawah | Berfungsi untuk mencari persegi persegi persegi dua segi empat tepat. ; Memberikan titik kiri bawah persegi persegi persegi; Memberikan titik kanan persegi persegi persegi; Tiada persimpangan; Memberikan titik kiri atas persegi persegi persegi; Memberikan titik bawah persegi persegi persegi; bawah - kiri dan atas - sudut kanan segi empat tepat pertama; bawah - kiri dan atas - sudut kanan segi empat tepat pertama; Panggilan fungsi", "code": "function FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var x5 = Math . max ( x1 , x3 ) ; var y5 = Math . max ( y1 , y3 ) ; var x6 = Math . min ( x2 , x4 ) ; var y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { document . write ( \" \" ) ; return ; } document . write ( \" \" + x5 + \" \" + y5 + \" \" ) ; document . write ( \" \" + x6 + \" \" + y6 + \" \" ) ; var x7 = x5 ; var y7 = y6 ; document . write ( \" \" + x7 + \" \" + y7 + \" \" ) ; var x8 = x6 ; var y8 = y5 ; document . write ( \" \" + x8 + \" \" + y8 + \" \" ) ; } var x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; var x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ; FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ;"}
{"text": "Cari Sudut Rectangle Menggunakan Poin Mid | Struktur untuk mewakili titik co -ordinate; Fungsi ini menerima dua mata dan panjang sisi segi empat tepat dan mencetak titik 4 sudut segi empat tepat; Rectangle mendatar; segi empat tepat menegak; segi empat tepat; Hitung cerun sisi; Kirakan anjakan di sepanjang paksi; Kod pemacu", "code": "class Point { constructor ( a , b ) { this . x = a ; this . y = b ; } } function printCorners ( p , q , l ) { let a = new Point ( ) , b = new Point ( ) , c = new Point ( ) , d = new Point ( ) ; if ( p . x == q . x ) { a . x = ( p . x - ( l / 2.0 ) ) ; a . y = p . y ; d . x = ( p . x + ( l / 2.0 ) ) ; d . y = p . y ; b . x = ( q . x - ( l / 2.0 ) ) ; b . y = q . y ; c . x = ( q . x + ( l / 2.0 ) ) ; c . y = q . y ; } else if ( p . y == q . y ) { a . y = ( p . y - ( l / 2.0 ) ) ; a . x = p . x ; d . y = ( p . y + ( l / 2.0 ) ) ; d . x = p . x ; b . y = ( q . y - ( l / 2.0 ) ) ; b . x = q . x ; c . y = ( q . y + ( l / 2.0 ) ) ; c . x = q . x ; } else { let m = ( p . x - q . x ) / ( q . y - p . y ) ; let dx = ( ( l / Math . sqrt ( 1 + ( m * m ) ) ) * 0.5 ) ; let dy = m * dx ; a . x = p . x - dx ; a . y = p . y - dy ; d . x = p . x + dx ; d . y = p . y + dy ; b . x = q . x - dx ; b . y = q . y - dy ; c . x = q . x + dx ; c . y = q . y + dy ; } document . write ( a . x + \" \" + a . y + \" \" + b . x + \" \" + b . y + \" \" + c . x + \" \" + c . y + \" \" + d . x + \" \" + d . y + \" \" ) ; } let p1 = new Point ( 1 , 0 ) , q1 = new Point ( 1 , 2 ) ; printCorners ( p1 , q1 , 2 ) ; let p = new Point ( 1 , 1 ) , q = new Point ( - 1 , - 1 ) ; printCorners ( p , q , ( 2 * Math . sqrt ( 2 ) ) ) ;"}
{"text": "Kurangkan kos untuk mengubah suai array sedemikian rupa sehingga indeks mempunyai unsur -unsur dan sebaliknya | Berfungsi untuk mencari kos minimum untuk mengubah suai array mengikut kriteria yang diberikan; Mengira kedudukan yang salah dan juga unsur -unsur; Kiraan ganjil; Malah mengira; Kos menukar; Menurun kos selepas bertukar; Hanya pengurangan kos; Mengembalikan kos minimum dua kes; Kod pemacu", "code": "function minimumCost ( arr , N , X , Y ) { let even_count = 0 , odd_count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) && ( i % 2 == 0 ) ) { odd_count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) ) { even_count ++ ; } } let cost1 = X * Math . min ( odd_count , even_count ) ; let cost2 = Y * ( Math . max ( odd_count , even_count ) - Math . min ( odd_count , even_count ) ) ; let cost3 = ( odd_count + even_count ) * Y ; return Math . min ( cost1 + cost2 , cost3 ) ; } let arr = [ 5 , 3 , 7 , 2 , 1 ] , X = 10 , Y = 2 ; let N = arr . length ; document . write ( minimumCost ( arr , N , X , Y ) ) ;"}
{"text": "Produk minimum elemen maksimum dan minimum ke atas semua subarray yang mungkin | Berfungsi untuk mencari produk minimum minimum dan maksimum di antara semua subarray yang mungkin; Kedai produk minimum yang dihasilkan; Melintasi array yang diberikan []; Min produk dari dua sepasang elemen berturut -turut; Mengembalikan nilai yang dihasilkan; Kod pemacu", "code": "function findMinMax ( a ) { let min_val = 1000000000 ; for ( let i = 1 ; i < a . length ; ++ i ) { min_val = Math . min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; } let arr = [ 6 , 4 , 5 , 6 , 2 , 4 , 1 ] ; document . write ( findMinMax ( arr ) )"}
{"text": "Jumlah semua nod dengan nilai yang lebih kecil pada jarak k dari nod yang diberikan dalam BST | Struktur pokok; Pembina; Berfungsi untuk menambah nod ke jumlah di bawah nod sasaran; Kes asas; Jika nod jauh kth dicapai; Berulang untuk kiri dan subtrees kanan; Fungsi untuk mencari nod jauh dari nod sasaran, ia kembali - 1 jika nod sasaran tidak hadir di dalam pokok; Kes asas 1; Jika sasaran sama dengan akar. ; Berulang untuk subtree kiri; Pokok adalah BST jadi mengurangkan ruang carian; Semak jika nod sasaran ditemui di subtree kiri; Jika akar berada pada jarak k dari sasaran; Node kurang daripada sasaran akan hadir di sebelah kiri; Apabila nod tidak hadir di subtree kiri; Jika nod jauh kth dicapai; Node kurang daripada sasaran pada jarak k mungkin terdapat di pokok kiri; Jika sasaran tidak hadir di sebelah kiri atau di subtree kanan; Berfungsi untuk memasukkan nod dalam BST; Jika akar adalah batal; Masukkan data pada separuh kanan; Masukkan data di separuh kiri; Mengembalikan nod akar; Fungsi untuk mencari jumlah n nod jauh dari nod sasaran yang mempunyai nilai kurang daripada nod sasaran; Menyimpan jumlah nod yang mempunyai nilai <sasaran pada jarak k; Cetak jumlah yang dihasilkan; Kod pemacu; Buat pokok", "code": "let sum = 0 ; class TreeNode { constructor ( data = \" \" , left = null , right = null ) { this . data = data ; this . left = left ; this . right = right ; } } function kDistanceDownSum ( root , k ) { if ( root == null k < 0 ) { return } if ( k == 0 ) { sum += root . data ; return ; } kDistanceDownSum ( root . left , k - 1 ) ; kDistanceDownSum ( root . right , k - 1 ) ; } function kDistanceSum ( root , target , k ) { if ( root == null ) return - 1 ; if ( root . data == target ) { kDistanceDownSum ( root . left , k - 1 ) ; return 0 ; } let dl = - 1 ; if ( target < root . data ) { dl = kDistanceSum ( root . left , target , k ) ; } if ( dl != - 1 ) { if ( dl + 1 == k ) sum += root . data ; return - 1 ; } let dr = - 1 ; if ( target > root . data ) { dr = kDistanceSum ( root . right , target , k ) ; } if ( dr != - 1 ) { if ( dr + 1 == k ) sum += root . data ; else kDistanceDownSum ( root . left , k - dr - 2 ) ; return 1 + dr ; } return - 1 ; } function insertNode ( data , root ) { if ( root == null ) { let node = new TreeNode ( data ) ; return node ; } else if ( data > root . data ) { root . right = insertNode ( data , root . right ) ; } else if ( data <= root . data ) { root . left = insertNode ( data , root . left ) ; } return root ; } function findSum ( root , target , K ) { kDistanceSum ( root , target , K , sum ) ; document . write ( sum ) ; } let root = null ; let N = 11 ; let tree = [ 3 , 1 , 7 , 0 , 2 , 5 , 10 , 4 , 6 , 9 , 8 ] ; for ( let i = 0 ; i < N ; i ++ ) { root = insertNode ( tree [ i ] , root ) ; } let target = 7 ; let K = 2 ; findSum ( root , target , K ) ;"}
{"text": "Cari item n yang diedarkan dari item tak terhingga jenis tak terhingga berdasarkan syarat -syarat yang diberikan | Berfungsi untuk mencari jenis item yang diberikan mengikut peraturan yang diberikan; Menyimpan kiraan item yang diberikan pada setiap langkah; Melangkah ke hari dari 1; Melewati jenis item pada hari itu; Count item yang diberikan hendaklah melebihi n; Kod pemacu", "code": "function itemType ( n ) { let count = 0 ; for ( let day = 1 ; ; day ++ ) { for ( let type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } } let N = 10 ; document . write ( itemType ( N ) ) ;"}
{"text": "Cari jumlah semua elemen array yang sama dari dua kuasa berturut -turut 2 | Berfungsi untuk mencetak jumlah elemen array yang sama dari dua kuasa berturut -turut 2; Menyimpan jumlah yang dihasilkan dari unsur -unsur array; Melintasi array arr []; Menyimpan kuasa 2 daripada nombor arr [i]; Menyimpan nombor yang kuasa 2 dan lebih rendah daripada atau sama dengan arr [i]; Menyimpan nombor yang kuasa 2 dan lebih besar daripada atau sama dengan arr [i]; Jika arr [i] - Lesservalue adalah sama seperti besar - arr [i]; Kenaikan res oleh arr [i]; Mengembalikan jumlah yang dihasilkan; Kod pemacu", "code": "function FindSum ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let power = Math . floor ( Math . log2 ( arr [ i ] ) ) ; let LesserValue = Math . pow ( 2 , power ) ; let LargerValue = Math . pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; } let arr = [ 10 , 24 , 17 , 3 , 8 ] ; let N = arr . length ; document . write ( FindSum ( arr , N ) ) ;"}
{"text": "Cari orang yang akan selesai terakhir | Berfungsi untuk mencari orang yang akan selesai terakhir; Untuk menjejaki baris dan lajur yang mempunyai 1; Baris dan lajur yang ada; Bilangan minimum pilihan yang kita ada; Jika bilangan pilihan ganjil; P1 akan selesai terakhir; Jika tidak, P2 akan selesai terakhir; Diberi matriks", "code": "function findLast ( mat ) { let m = mat . length ; let n = mat [ 0 ] . length ; let rows = new Set ( ) ; let cols = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . add ( i ) ; cols . add ( j ) ; } } } let avRows = m - rows . size ; let avCols = n - cols . size ; let choices = Math . min ( avRows , avCols ) ; if ( choices & 1 ) document . write ( \" \" ) else document . write ( \" \" ) } let mat = [ [ 1 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 1 ] ] findLast ( mat ) ;"}
{"text": "Jumlah perpuluhan yang merupakan perwakilan binari nombor semulajadi n pertama | Program JavaScript untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari jumlah nombor semulajadi N pertama yang diwakili dalam perwakilan binari; Menyimpan jumlah yang dihasilkan; Melangkah sehingga nilai n lebih besar daripada 0; Jika n kurang daripada 2; Simpan kedudukan MSB N; Iterat dalam julat [1, x] dan tambahkan sumbangan nombor dari 1 hingga (2 ^ x - 1); Kemas kini nilai CUR dan tambah; Tambah cur ke ans; Simpan nombor yang tinggal; Tambah sumbangan oleh MSB dengan bilangan yang tinggal; Lelaran seterusnya akan diulangi untuk 2 ^ x - 1; Cetak hasilnya; Kod pemacu", "code": "let MOD = 1000000007 ; function sumOfBinaryNumbers ( n ) { let ans = 0 ; let one = 1 ; while ( true ) { if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; } let x = Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ; let cur = 0 ; let add = Math . floor ( Math . pow ( 2 , ( x - 1 ) ) ) ; for ( let i = 1 ; i <= x ; i ++ ) { cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; } ans = ( ans + cur ) % MOD ; let rem = n - Math . floor ( Math . pow ( 2 , x ) ) + 1 ; let p = Math . floor ( Math . pow ( 10 , x ) ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ; n = rem - 1 ; } document . write ( ans ) ; } let N = 3 ; sumOfBinaryNumbers ( N ) ;"}
{"text": "Nombor Fibonacci terdekat kepada N | Berfungsi untuk mencari nombor Fibonacci yang paling dekat dengan N; Kes asas; Memulakan syarat pertama & kedua siri Fibonacci; Simpan istilah ketiga; ITERATE Sehingga istilah ketiga kurang daripada atau sama dengan NUM; Kemas kini yang pertama; Kemas kini yang kedua; Mengemas kini yang ketiga; Simpan nombor Fibonacci yang mempunyai perbezaan yang lebih kecil dengan N; Cetak hasilnya; Kod pemacu", "code": "function nearestFibonacci ( num ) { if ( num == 0 ) { document . write ( 0 ) ; return ; } let first = 0 , second = 1 ; let third = first + second ; while ( third <= num ) { first = second ; second = third ; third = first + second ; } let ans = ( Math . abs ( third - num ) >= Math . abs ( second - num ) ) ? second : third ; document . write ( ans ) ; } let N = 17 ; nearestFibonacci ( N ) ;"}
{"text": "Permutasi nombor semulajadi n pertama yang diberikan array sebagai array maksimum awalan | Fungsi untuk memeriksa sama ada array awalan maksimum ANS [] sama dengan array arr []; Memulakan pembolehubah, maks; Melintasi array, ans []; Simpan nilai maksimum sehingga indeks i; Jika ia tidak sama dengan [i], maka kembali palsu; Sebaliknya kembali palsu; Berfungsi untuk mencari permutasi array yang array maksimum awalan yang sama dengan array yang diberikan []; Menyimpan permutasi yang diperlukan; Menyimpan indeks kejadian pertama unsur; Melintasi array a []; Jika A [i] tidak hadir di um, maka simpannya di um; Kemas kini Ans [i] ke [i]; Menyimpan nombor yang tidak disokong; Isi array, v []; Simpan indeks; Melintasi array, ans []; Isi V [J] di tempat -tempat di mana Ans [i] adalah 0; Semak sama ada array awalan maksimum permutasi semasa adalah sama dengan array yang diberikan []; Jika benar, cetak permutasi; Jika tidak, cetak - 1; Kod pemacu; Panggilan fungsi", "code": "function checkPermutation ( ans , a , n ) { let Max = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { Max = Math . max ( Max , ans [ i ] ) ; if ( Max != a [ i ] ) return false ; } return true ; } function findPermutation ( a , n ) { let ans = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { ans [ i ] = 0 ; } let um = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! um . has ( a [ i ] ) ) { ans [ i ] = a [ i ] ; um . set ( a [ i ] , i ) ; } } let v = [ ] ; let j = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( ! um . has ( i ) ) { v . push ( i ) ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 0 ) { ans [ i ] = v [ j ] ; j ++ ; } } if ( checkPermutation ( ans , a , n ) ) { for ( let i = 0 ; i < n ; i ++ ) { document . write ( ans [ i ] + \" \" ) ; } } else document . write ( \" \" ) ; } let arr = [ 1 , 3 , 4 , 5 , 5 ] ; let N = arr . length ; findPermutation ( arr , N ) ;"}
{"text": "Kira pasangan elemen yang sama mungkin dengan tidak termasuk setiap elemen array sekali | Fungsi untuk mengira bilangan pasangan yang diperlukan untuk setiap elemen array; Memulakan peta; Mengemas kini kekerapan setiap elemen; Menyimpan kiraan pasangan; Melintasi peta; Hitung bilangan cara untuk memilih pasangan yang terdiri daripada unsur yang sama sahaja; Melintasi array; Cetak kiraan untuk setiap elemen array; Diberikan array; Saiz array", "code": "function countEqualElementPairs ( arr , N ) { var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } var total = 0 ; mp . forEach ( ( value , key ) => { total += ( value * ( value - 1 ) ) / 2 ; } ) ; for ( var i = 0 ; i < N ; i ++ ) { document . write ( total - ( mp . get ( arr [ i ] ) - 1 ) + \" \" ) ; } } var arr = [ 1 , 1 , 2 , 1 , 2 ] ; var N = arr . length ; countEqualElementPairs ( arr , N ) ;"}
{"text": "Count of Octal Number sehingga digit N | Berfungsi untuk mengembalikan kiraan nombor oktal semulajadi sehingga digit; Gelung untuk berulang dari 1 hingga N dan mengira bilangan nombor oktal untuk setiap digit 'i' th. ; Kod pemacu", "code": "function count ( N ) { var sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { sum += 7 * Math . pow ( 8 , i - 1 ) ; } return sum ; } var N = 4 ; document . write ( count ( N ) ) ;"}
{"text": "Pembahagi Palindromic nombor | Fungsi untuk memeriksa adalah NUM adalah palindromic atau tidak; Tukar n ke string str; Memulakan dan mengakhiri indeks string str; Jika char di s dan e tidak sama maka kembali palsu; Berfungsi untuk mencari pembahagi palindromik; Untuk sakit pembahagi palindromik nombor n; Jika n boleh dibahagikan dengan i; Semak jika nombor adalah persegi yang sempurna; Periksa pembahagi adalah palindromic, kemudian simpannya; Semak jika pembahagi adalah palindrome; Semak jika N / pembahagi adalah palindromik atau tidak; Cetak semua pembahagi palindromik dalam urutan yang disusun; Kod pemacu; Fungsi panggilan untuk mencari semua pembahagi palindromik", "code": "function isPalindrome ( n ) { var str = ( n . toString ( ) ) ; var s = 0 , e = str . length - 1 ; while ( s < e ) { if ( str [ s ] != str [ e ] ) { return false ; } s ++ ; e -- ; } return true ; } function palindromicDivisors ( n ) { var PalindromDivisors = [ ] ; for ( var i = 1 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( isPalindrome ( i ) ) { PalindromDivisors . push ( i ) ; } } else { if ( isPalindrome ( i ) ) { PalindromDivisors . push ( i ) ; } if ( isPalindrome ( n / i ) ) { PalindromDivisors . push ( n / i ) ; } } } } PalindromDivisors . sort ( ( a , b ) => a - b ) for ( var i = 0 ; i < PalindromDivisors . length ; i ++ ) { document . write ( PalindromDivisors [ i ] + \" \" ) ; } } var n = 66 ; palindromicDivisors ( n ) ;"}
{"text": "Keluarkan nombor minimum dari array untuk mendapatkan minimum atau nilai | Berfungsi untuk mengembalikan penghapusan minimum untuk mendapatkan minimum atau; Untuk menyimpan elemen minimum; Cari elemen minimum dari array; Untuk menyimpan kekerapan elemen minimum; Cari kekerapan elemen minimum; Kembalikan jawapan terakhir; Kod pemacu", "code": "function findMinDel ( arr , n ) { var min_num = 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ; var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; } var arr = [ 3 , 3 , 2 ] ; var n = arr . length ; document . write ( findMinDel ( arr , n ) ) ;"}
{"text": "Bilangan subarray dengan GCD sama dengan 1 | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan kiraan yang diperlukan; Untuk menyimpan jawapan terakhir; Untuk menyimpan GCD bermula dari indeks 'i'; Gelung untuk mencari GCD setiap subarray dari arr [i] ke arr [i ... n - 1]; Kenaikan kiraan jika curr_gcd = 1; Kembalikan jawapan terakhir; Kod pemacu", "code": "function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } function cntSubArr ( arr , n ) { var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var curr_gcd = 0 ; for ( var j = i ; j < n ; j ++ ) { curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ; ans += ( curr_gcd == 1 ) ; } } return ans ; } var arr = [ 1 , 1 , 1 ] ; var n = arr . length ; document . write ( cntSubArr ( arr , n ) ) ;"}
{"text": "Program untuk mencetak nombor perdana dari 1 hingga n. | Berfungsi untuk mencetak nombor utama n pertama; Mengisytiharkan pembolehubah; Mesej paparan cetak; Melintasi setiap nombor dari 1 hingga n dengan bantuan untuk gelung; Langkau 0 dan 1 kerana mereka bukan Perdana atau Komposit; pembolehubah bendera untuk memberitahu jika saya adalah perdana atau tidak; Bendera = 1 bermakna saya adalah perdana dan bendera = 0 bermakna saya bukan perdana; Kod pemacu", "code": "function print_primes_till_N ( N ) { let i , j , flag ; document . write ( \" \" + N + \" \" ) ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) document . write ( i + \" \" ) ; } } let N = 100 ; print_primes_till_N ( N ) ;"}
{"text": "Memaksimumkan ungkapan (a dan x) * (b dan x) | Manipulasi Bit | Fungsi untuk mencari x mengikut syarat yang diberikan; Int boleh mempunyai 32 bit; Bit sementara; Kirakan sedikit x mengikut syarat -syarat yang diberikan di bawah adalah kesimpulan langsung dari ilustrasi yang telah kami ambil sebelumnya; Tambah sedikit x ke x; Kod pemacu", "code": "function findX ( A , B ) { var X = 0 ; var MAX = 32 ; for ( var bit = 0 ; bit < MAX ; bit ++ ) { var tempBit = 1 << bit ; var bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; } var A = 11 , B = 13 ; document . write ( findX ( A , B ) ) ;"}
{"text": "Bilangan subset yang min adalah maksimum | Berfungsi untuk mengembalikan kiraan subset dengan min maksimum; Nilai maksimum dari array; Untuk menyimpan bilangan elemen maksimum kali muncul dalam array; Mengembalikan kiraan subset yang sah; Kod pemacu", "code": "function cntSubSets ( arr , n ) { var maxVal = arr . reduce ( function ( a , b ) { return Math . max ( a , b ) ; } ) ; var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( Math . pow ( 2 , cnt ) - 1 ) ; } var arr = [ 1 , 2 , 1 , 2 ] var n = arr . length ; document . write ( cntSubSets ( arr , n ) ) ;"}
{"text": "Kebarangkalian bahawa pasangan rawak yang dipilih dari array (a [i], a [j]) mempunyai jumlah maksimum | Berfungsi untuk mengembalikan kebarangkalian mendapatkan jumlah pasangan maksimum apabila pasangan rawak dipilih dari array yang diberikan; Memulakan jumlah maksimum, kiraannya dan kiraan jumlah pasangan; Untuk setiap pasangan; Dapatkan jumlah pasangan semasa; Jika jumlahnya sama dengan jumlah maksimum semasa setakat ini; Kenaikan kiraannya; Jika jumlahnya lebih besar daripada maksimum semasa; Kemas kini maksimum semasa dan semula - memulakan kiraan kepada 1; Cari kebarangkalian yang diperlukan; Kod pemacu", "code": "function findProb ( arr , n ) { var maxSum = - 100000000 , maxCount = 0 , totalPairs = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { var sum = arr [ i ] + arr [ j ] ; if ( sum == maxSum ) { maxCount ++ ; } else if ( sum > maxSum ) { maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } } var prob = maxCount / totalPairs ; return prob ; } var arr = [ 1 , 1 , 1 , 2 , 2 , 2 ] var n = arr . length ; document . write ( findProb ( arr , n ) ) ;"}
{"text": "Kiraan maksimum pembahagi umum a dan b sedemikian rupa sehingga semua adalah co | Pelaksanaan JavaScript pendekatan; Fungsi untuk mengembalikan kiraan faktor umum a dan b supaya semua elemen adalah co - perdana antara satu sama lain; GCD A dan B; Termasuk 1 pada mulanya; Cari semua faktor utama GCD; Jika GCD adalah perdana; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "function GCD ( a , b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } function maxCommonFactors ( a , b ) { let gcd = GCD ( a , b ) ; let ans = 1 ; for ( let i = 2 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { ans ++ ; while ( gcd % i == 0 ) gcd = parseInt ( gcd / i ) ; } } if ( gcd != 1 ) ans ++ ; return ans ; } let a = 12 , b = 18 ; document . write ( maxCommonFactors ( a , b ) ) ;"}
{"text": "Cari nombor hari dalam tahun semasa untuk tarikh yang diberikan | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan bilangan hari tahun ini untuk tarikh yang diberikan; Ekstrak tahun, bulan dan hari dari rentetan tarikh; Sekiranya tahun semasa adalah tahun lompat dan tarikh yang diberikan adalah selepas 28 Februari maka ia mesti termasuk 29 Februari; Tambah hari pada bulan -bulan sebelumnya; Kod pemacu", "code": "var days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ; function dayOfYear ( date ) { var year = parseInt ( date . substring ( 0 , 4 ) ) ; var month = parseInt ( date . substring ( 5 , 6 ) ) ; var day = parseInt ( date . substring ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; } while ( month -- > 0 ) { day = day + days [ month - 1 ] ; } return day ; } var date = \" \" ; document . write ( dayOfYear ( date ) ) ;"}
{"text": "Cari bilangan sel dalam jadual mengandungi x | Fungsi untuk mencari bilangan sel dalam jadual mengandungi x; Kod pemacu; Panggilan fungsi", "code": "function Cells ( n , x ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && parseInt ( x / i ) <= n ) ans ++ ; return ans ; } let n = 6 , x = 12 ; document . write ( Cells ( n , x ) ) ;"}
{"text": "Kuasa terkecil 4 lebih besar daripada atau sama dengan N | Berfungsi untuk mengembalikan kuasa terkecil 4 lebih besar daripada atau sama dengan n; Jika n sendiri adalah kuasa 4 maka kembali n; Kod pemacu", "code": "function nextPowerOfFour ( n ) { let x = Math . floor ( Math . sqrt ( Math . sqrt ( n ) ) ) ; if ( Math . pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return Math . pow ( x , 4 ) ; } } let n = 122 ; document . write ( nextPowerOfFour ( n ) ) ;"}
{"text": "Operasi minimum yang diperlukan untuk menukar x ke y dengan mendarabkan x dengan co yang diberikan | Berfungsi untuk mengembalikan operasi minimum yang diperlukan; Tidak mungkin; Untuk menyimpan kuasa terbesar p yang membahagikan d; Sementara dibahagi oleh p; Untuk menyimpan kuasa terbesar Q yang membahagikan d; Manakala dibahagi oleh q; Jika d> 1; Kerana, d = p ^ a * q ^ b; Kod pemacu", "code": "function minOperations ( x , y , p , q ) { if ( y % x != 0 ) return - 1 var d = Math . floor ( y / x ) var a = 0 while ( d % p == 0 ) { d = Math . floor ( d / p ) a += 1 } var b = 0 while ( d % q == 0 ) { d = Math . floor ( d / q ) b += 1 } if ( d != 1 ) return - 1 return ( a + b ) } var x = 12 var y = 2592 var p = 2 var q = 3 document . write ( minOperations ( x , y , p , q ) )"}
{"text": "Bilangan kuadrup dengan GCD sama dengan k | Fungsi untuk mengira NC4; Kes asas untuk mengira NC4; Berfungsi untuk mengembalikan kiraan kuadrup yang diperlukan menggunakan pengecualian inklusi; Berkesan n; Melangkah lebih dari 2 hingga m; Bilangan pembahagi saya hingga m; Count menyimpan bilangan pembahagi utama yang berlaku tepat sekali; Untuk mengelakkan pengulangan pembahagi utama; Jika pengulangan pembahagi utama hadir mengabaikan nombor ini; Jika kiraan pembahagi utama ganjil tolaknya dari jawapan lain, tambah; Kod pemacu", "code": "function nCr ( n ) { if ( n < 4 ) return 0 ; let answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; answer = parseInt ( answer / 24 ) ; return answer ; } function countQuadruples ( N , K ) { let M = parseInt ( N / K ) ; let answer = nCr ( M ) ; for ( let i = 2 ; i < M ; i ++ ) { let j = i ; let temp2 = parseInt ( M / i ) ; let count = 0 ; let check = 0 ; let temp = j ; while ( j % 2 == 0 ) { count ++ ; j = parseInt ( j / 2 ) ; if ( count >= 2 ) break ; } if ( count >= 2 ) { check = 1 ; } for ( let k = 3 ; k <= Math . sqrt ( temp ) ; k += 2 ) { let cnt = 0 ; while ( j % k == 0 ) { cnt ++ ; j = parseInt ( j / k ) ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) { check = 1 ; break ; } else if ( cnt == 1 ) count ++ ; } if ( j > 2 ) { count ++ ; } if ( check ) continue ; else { if ( count % 2 == 1 ) { answer -= nCr ( temp2 ) ; } else { answer += nCr ( temp2 ) ; } } } return answer ; } let N = 10 , K = 2 ; document . write ( countQuadruples ( N , K ) ) ;"}
{"text": "Cari nombor yang ditambah kepada nisbah yang diberikan A: B, nisbah berubah kepada C: D | Berfungsi untuk mengembalikan nombor x yang diperlukan; Kod pemacu", "code": "function getX ( a , b , c , d ) { var X = ( b * c - a * d ) / ( d - c ) ; return X ; } var a = 2 , b = 3 , c = 4 , d = 5 ; document . write ( getX ( a , b , c , d ) ) ;"}
{"text": "Bilangan cara untuk mengatur perkataan sedemikian rupa sehingga tiada vokal berlaku bersama | Fungsi untuk memeriksa sama ada watak adalah vokal atau konsonen; Berfungsi untuk mengira faktorial nombor; Mengira tidak ada cara untuk mengatur vokal; Melelehkan peta dan mengira bilangan vokal dan mengira tiada cara untuk mengatur vokal; Mengira tidak ada cara untuk mengatur perkataan yang diberikan supaya semua vokal bersatu; Kira tidak ada cara untuk mengatur vokal; Untuk menyimpan penyebut pecahan; Count of Consonents; Kirakan bilangan cara untuk mengatur perkataan sedemikian rupa sehingga semua vokal bersatu; Untuk mengira jumlah permutasi; Untuk menyimpan panjang perkataan yang diberikan; Penyebut pecahan; Mengembalikan jumlah permutasi perkataan yang diberikan; Berfungsi untuk mengira bilangan permutasi supaya tiada vokal bersatu; Untuk menyimpan kekerapan watak; Mengira kekerapan semua aksara; Hitung jumlah permutasi; Hitung jumlah permutasi sedemikian rupa sehingga semua vokal bersatu; Tolak vwl_tgthr dari jumlah untuk mendapatkan hasilnya; Mengembalikan hasilnya; Kod pemacu", "code": "function isVowel ( ch ) { if ( ch == ' ' ch == ' ' ch == ' ' ch == ' ' ch == ' ' ) return true ; else return false ; } function fact ( n ) { if ( n < 2 ) { return 1 ; } return n * fact ( n - 1 ) ; } function only_vowels ( freq ) { let denom = 1 ; let cnt_vwl = 0 ; for ( let [ key , value ] of freq . entries ( ) ) { if ( isVowel ( key ) ) { denom *= fact ( value ) ; cnt_vwl += value ; } } return Math . floor ( fact ( cnt_vwl ) / denom ) ; } function all_vowels_together ( freq ) { let vow = only_vowels ( freq ) ; let denom = 1 ; let cnt_cnst = 0 ; for ( let [ key , value ] of freq . entries ( ) ) { if ( ! isVowel ( key ) ) { denom *= fact ( value ) ; cnt_cnst += value ; } } let ans = Math . floor ( fact ( cnt_cnst + 1 ) / denom ) ; return ( ans * vow ) ; } function total_permutations ( freq ) { let cnt = 0 ; let denom = 1 ; for ( let [ key , value ] of freq . entries ( ) ) { denom *= fact ( value ) ; cnt += value ; } return Math . floor ( fact ( cnt ) / denom ) ; } function no_vowels_together ( word ) { let freq = new Map ( ) ; for ( let i = 0 ; i < word . length ; i ++ ) { let ch = word [ i ] . toLowerCase ( ) ; if ( freq . has ( ch ) ) { freq . set ( ch , freq . get ( ch ) + 1 ) ; } else { freq . set ( ch , 1 ) ; } } let total = total_permutations ( freq ) ; let vwl_tgthr = all_vowels_together ( freq ) ; let res = total - vwl_tgthr ; return res ; } let word = \" \" ; let ans = no_vowels_together ( word ) ; document . write ( ans + \" \" ) ; word = \" \" ; ans = no_vowels_together ( word ) ; document . write ( ans + \" \" ) ; word = \" \" ; ans = no_vowels_together ( word ) ; document . write ( ans + \" \" ) ;"}
{"text": "Program untuk mencari bilangan lelaki pada mulanya | Berfungsi untuk mengembalikan bilangan lelaki pada mulanya; Kod pemacu", "code": "function numberOfMen ( D , m , d ) { var Men = ( m * ( D - d ) ) / d ; return Men ; } var D = 5 , m = 4 , d = 4 ; document . write ( numberOfMen ( D , m , d ) ) ;"}
{"text": "Kawasan segitiga yang dibentuk oleh paksi Co | Berfungsi untuk mencari kawasan; Kod pemacu", "code": "function area ( a , b , c ) { var d = Math . abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; } var a = - 2 , b = 4 , c = 3 ; document . write ( area ( a , b , c ) ) ;"}
{"text": "Jumlah dua nombor di mana satu nombor diwakili sebagai pelbagai digit | Berfungsi untuk mengembalikan vektor yang mengandungi jawapannya; ArrayList V adalah untuk menyimpan setiap digit SUM dan ArrayList ANS adalah untuk menyimpan jawapannya; Tidak dibawa pada mulanya; Mula gelung dari hujung dan ambil elemen satu demi satu; Indeks array dan nombor angka terakhir; Mengekalkan pembawa penjumlahan; Tolak nilai digit ke dalam array; Nilai k lebih besar kemudian 0; Tolak digit k satu demi satu dalam array; Juga mengekalkan pembawa dengan penjumlahan; Membalikkan unsur -unsur vektor v dan simpannya dalam vektor ans; Kod pemacu; Cetak jawapannya", "code": "function addToArrayForm ( A , K ) { let v = [ ] ; let ans = [ ] ; let rem = 0 ; let i = 0 ; for ( i = A . length - 1 ; i >= 0 ; i -- ) { let my = A [ i ] + K % 10 + rem ; if ( my > 9 ) { rem = 1 ; v . push ( my % 10 ) ; } else { v . push ( my ) ; rem = 0 ; } K = parseInt ( K / 10 , 10 ) ; } while ( K > 0 ) { let my = K % 10 + rem ; v . push ( my % 10 ) ; if ( parseInt ( my / 10 , 10 ) > 0 ) rem = 1 ; else rem = 0 ; K = parseInt ( K / 10 , 10 ) ; } if ( rem > 0 ) v . push ( rem ) ; for ( let j = v . length - 1 ; j >= 0 ; j -- ) ans . push ( v [ j ] ) ; return ans ; } let A = [ ] ; A . push ( 2 ) ; A . push ( 7 ) ; A . push ( 4 ) ; let K = 181 ; let ans = addToArrayForm ( A , K ) ; for ( let i = 0 ; i < ans . length ; i ++ ) document . write ( ans [ i ] ) ;"}
{"text": "Kirakan maksimum fungsi dengan cekap ke atas semua sub | Pelaksanaan JavaScript pendekatan di atas; Berfungsi untuk mengembalikan jumlah maksimum sub - array; Berfungsi untuk mengembalikan nilai maksimum fungsi f; Mengira Arrays B [] dan C []; Cari Sub Maksimum Sub - pelbagai tatasusunan dan mengambil maksimum di antara mereka; Kod pemacu", "code": "const MAX = 100005 ; function kadaneAlgorithm ( ar , n ) { let sum = 0 , maxSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; if ( sum < 0 ) sum = 0 ; maxSum = Math . max ( maxSum , sum ) ; } return maxSum ; } function maxFunction ( arr , n ) { let b = new Array ( MAX ) , c = new Array ( MAX ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( i & 1 ) { b [ i ] = Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; c [ i ] = - b [ i ] ; } else { c [ i ] = Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; b [ i ] = - c [ i ] ; } } let ans = kadaneAlgorithm ( b , n - 1 ) ; ans = Math . max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; return ans ; } let arr = [ 1 , 5 , 4 , 7 ] ; let n = arr . length ; document . write ( maxFunction ( arr , n ) ) ;"}
{"text": "Ketiga digit terakhir dalam 5 ^ n untuk diberikan n | Berfungsi untuk mencari elemen; jika n <3; Jika n juga kembali 6 jika n adalah pulangan ganjil 1; Kod pemacu", "code": "function findThirdDigit ( n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; } var n = 7 ; document . write ( findThirdDigit ( n ) ) ;"}
{"text": "Kebarangkalian memenangi perlawanan apabila kebarangkalian individu memukul sasaran yang diberikan | Berfungsi untuk mengembalikan kebarangkalian kemenangan; P dan Q menyimpan nilai pecahan A / B dan C / D; Untuk menyimpan kebarangkalian kemenangan A; Kod pemacu", "code": "function getProbability ( a , b , c , d ) { var p = a / b ; var q = c / d ; var ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; } var a = 1 , b = 2 , c = 10 , d = 11 ; document . write ( getProbability ( a , b , c , d ) . toFixed ( 5 ) ) ;"}
{"text": "Nombor palindromik terbesar dalam array | Fungsi untuk memeriksa sama ada n adalah palindrome; Cari pembahagi yang sesuai untuk mengekstrak digit terkemuka; Jika digit pertama dan terakhir tidak sama maka kembali palsu; Mengeluarkan digit terkemuka dan trailing dari nombor; Mengurangkan pembahagi dengan faktor 2 sebagai 2 digit dijatuhkan; Berfungsi untuk mencari nombor palindromik terbesar; Sekiranya palindrom lebih besar daripada semasa yang dijumpai; Mengembalikan nombor palindromik terbesar dari array; Kod pemacu; Cetak jawapan yang diperlukan", "code": "function isPalindrome ( n ) { var divisor = 1 ; while ( parseInt ( n / divisor ) >= 10 ) divisor *= 10 ; while ( n != 0 ) { var leading = parseInt ( n / divisor ) ; var trailing = n % 10 ; if ( leading != trailing ) return false ; n = parseInt ( ( n % divisor ) / 10 ) ; divisor = parseInt ( divisor / 100 ) ; } return true ; } function largestPalindrome ( A , n ) { var currentMax = - 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( A [ i ] > currentMax && isPalindrome ( A [ i ] ) ) currentMax = A [ i ] ; } return currentMax ; } var A = [ 1 , 232 , 54545 , 999991 ] ; var n = A . length ; document . write ( largestPalindrome ( A , n ) ) ;"}
{"text": "Kurangkan array ke satu elemen dengan operasi yang diberikan | Berfungsi untuk mengembalikan elemen akhir; Kod pemacu", "code": "function getFinalElement ( n ) { let finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; } let N = 12 ; document . write ( getFinalElement ( N ) ) ;"}
{"text": "Jumlah elemen dalam array yang mempunyai kekerapan utama | Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mengembalikan jumlah elemen dalam array yang mempunyai kekerapan utama; Peta digunakan untuk menyimpan frekuensi elemen; Melintasi peta menggunakan iterators; Mengira bilangan elemen yang mempunyai frekuensi utama; Kod pemacu", "code": "function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } function sumOfElements ( arr , n ) { let prime = new Array ( n + 1 ) ; prime . fill ( true ) SieveOfEratosthenes ( prime , n + 1 ) ; let i , j ; let m = new Map ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( m . has ( arr [ i ] ) ) m . set ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; else m . set ( arr [ i ] , 1 ) ; } let sum = 0 ; for ( let it of m ) { if ( prime [ it [ 1 ] ] ) { sum += ( it [ 0 ] ) ; } } return sum ; } let arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] ; let n = arr . length ; document . write ( sumOfElements ( arr , n ) ) ;"}
{"text": "Jumlah semua nombor palindromik panjang dalam julat [l, r] | Fungsi yang mengembalikan benar jika nombor yang diberikan adalah palindrome; Di sini kita menjana nombor baru (reverse_num) * dengan membalikkan digit nombor input asal; Jika nombor input asal (num) adalah sama dengan * ke belakangnya (reverse_num) maka palindrome * lain tidak. ; Fungsi yang mengembalikan benar jika nombor yang diberikan adalah panjang ganjil; Berfungsi untuk mengembalikan jumlah semua nombor palindromik panjang yang ganjil dalam julat yang diberikan; jika nombor adalah palindrome dan panjang ganjil; Kod pemacu", "code": "function isPalindrome ( num ) { let reverse_num = 0 , remainder , temp ; temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp = Math . floor ( temp / 10 ) ; } if ( reverse_num == num ) { return true ; } return false ; } function isOddLength ( num ) { let count = 0 ; while ( num > 0 ) { num = Math . floor ( num / 10 ) ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; } function sumOfAllPalindrome ( L , R ) { let sum = 0 ; if ( L <= R ) for ( let i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; } let L = 110 , R = 1130 ; document . write ( sumOfAllPalindrome ( L , R ) ) ;"}
{"text": "Bilangan cara untuk mengatur perkataan sedemikian rupa sehingga semua vokal berlaku bersama | Faktorial nombor; Mengira cara untuk mengatur konsonan; Abaikan vokal; Mengira cara untuk mengatur vokal; Fungsi untuk mengira jumlah no. cara; Mengira vokal dan konsonan; Jumlah tidak. cara; Kod pemacu", "code": "function fact ( n ) { let f = 1 ; for ( let i = 2 ; i <= n ; i ++ ) f = f * i ; return f ; } function waysOfConsonants ( size1 , freq ) { let ans = fact ( size1 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) continue ; else ans = Math . floor ( ans / fact ( freq [ i ] ) ) ; } return ans ; } function waysOfVowels ( size2 , freq ) { return Math . floor ( fact ( size2 ) / ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ) ; } function countWays ( str ) { let freq = new Array ( 200 ) ; for ( let i = 0 ; i < 200 ; i ++ ) freq [ i ] = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; let vowel = 0 , consonant = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] != ' ' && str [ i ] != ' ' && str [ i ] != ' ' && str [ i ] != ' ' && str [ i ] != ' ' ) consonant ++ ; else vowel ++ ; } return waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ; } let str = \" \" ; document . write ( countWays ( str ) ) ;"}
{"text": "Jumlah nombor Fibonacci dengan negatif alternatif | Mengira nilai nombor Fibonacci pertama dan menyimpan jumlah alternatif mereka; Memulakan hasil; Tambah istilah yang tinggal; Bahkan istilah; Untuk istilah ganjil; Mengembalikan jumlah bergantian; Dapatkan n; Cari jumlah bergantian", "code": "function calculateAlternateSum ( n ) { if ( n <= 0 ) return 0 ; var fibo = Array ( n + 1 ) . fill ( 0 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; var sum = Math . pow ( fibo [ 0 ] , 2 ) + Math . pow ( fibo [ 1 ] , 2 ) ; for ( i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; } var n = 8 ; document . write ( \" \" + n + \" \" + calculateAlternateSum ( n ) ) ;"}
{"text": "Cari istilah n Siri 1 2 2 4 4 4 4 8 8 8 8 8 8 8 8 ... | Fungsi yang akan mengembalikan istilah nth; Dapatkan n; Dapatkan nilai; Dapatkan n; Dapatkan nilai", "code": "function getValue ( n ) { let i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return parseInt ( k / 2 ) ; } let n = 9 ; document . write ( getValue ( n ) + \" \" ) ; n = 1025 ; document . write ( getValue ( n ) + \" \" ) ;"}
{"text": "Bina pelbagai frekuensi digit nilai yang diperoleh dari x ^ 1, x ^ 2, ... .... . , x ^ n | Fungsi yang melintasi digit dalam nombor dan mengubah suai jumlah kekerapan kekerapan; Array untuk menyimpan kiraan digit; Melintasi x ^ 1 hingga x ^ n; Untuk fungsi kuasa, kedua -dua parameternya akan dua kali ganda; Memanggil Countdigits berfungsi pada x ^ i; Mencetak kiraan digit 0 - 9; Kod pemacu", "code": "function countDigits ( val , arr ) { while ( val > 0 ) { let digit = val % 10 ; arr [ digit ] ++ ; val = Math . floor ( val / 10 ) ; } return ; } function countFrequency ( x , n ) { let freq_count = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { freq_count [ i ] = 0 ; } for ( let i = 1 ; i <= n ; i ++ ) { let val = Math . pow ( x , i ) ; countDigits ( val , freq_count ) ; } for ( let i = 0 ; i <= 9 ; i ++ ) { document . write ( freq_count [ i ] + \" \" ) ; } } let x = 15 , n = 3 ; countFrequency ( x , n ) ;"}
{"text": "Bilangan nilai b seperti a = b + (a ^ b) | berfungsi untuk mengembalikan bilangan penyelesaian; Semak setiap nilai yang mungkin; Kod pemacu", "code": "function countSolutions ( a ) { let count = 0 ; for ( let i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; } let a = 3 ; document . write ( countSolutions ( a ) ) ;"}
{"text": "Bilangan nilai b seperti a = b + (a ^ b) | Program JavaScript untuk mencari bilangan nilai b seperti A = B + (A ^ B); Berfungsi untuk mengembalikan bilangan penyelesaian; Kod pemacu", "code": "function bitCount ( n ) { let count = 0 ; while ( n != 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; } function countSolutions ( a ) { let count = bitCount ( a ) ; count = Math . pow ( 2 , count ) ; return count ; } let a = 3 ; document . write ( countSolutions ( a ) ) ;"}
{"text": "Jumlah kawasan semua persegi yang mungkin di dalam segi empat tepat | Fungsi untuk mengira jumlah kawasan semua dataran yang mungkin masuk ke dalam segi empat tepat; Persegi dengan saiz maksimum mungkin; Kirakan jumlah persegi saiz tertentu; mengira kawasan dataran dengan saiz tertentu; Jumlah kawasan; saiz kenaikan; Kod pemacu", "code": "function calculateAreaSum ( l , b ) { var size = 1 ; var maxSize = Math . min ( l , b ) ; var totalArea = 0 ; for ( var i = 1 ; i <= maxSize ; i ++ ) { var totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; var area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; } var l = 4 , b = 3 ; document . write ( calculateAreaSum ( l , b ) ) ;"}
{"text": "Hyperfactorial nombor | fungsi untuk mengira nilai hiperfakterial; memulakan val kepada 1; mengembalikan hiperfactoral nombor; Kod pemacu", "code": "function boost_hyperfactorial ( num ) { let val = 1 ; for ( let i = 1 ; i <= num ; i ++ ) { val = val * Math . pow ( i , i ) ; } return val ; } let num = 5 ; document . write ( boost_hyperfactorial ( num ) ) ;"}
{"text": "Hyperfactorial nombor | fungsi untuk mengira nilai hiperfakterial; memulakan val kepada 1; 1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . ; mengembalikan hiperfactoral nombor; Kod pemacu", "code": "function boost_hyperfactorial ( num ) { var val = 1 ; for ( var i = 1 ; i <= num ; i ++ ) { for ( var j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; } var num = 5 ; document . write ( boost_hyperfactorial ( num ) ) ;"}
{"text": "Kurangkan 1 tanpa pengendali aritmetik | Kod JavaScript untuk menolak satu daripada nombor tertentu; Flip semua bit set sehingga kita dapati 1; Flip paling tepat 1 bit; Program pemacu untuk menguji fungsi di atas", "code": "function subtractOne ( x ) { let m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } document . write ( subtractOne ( 13 ) ) ;"}
{"text": "Cari vektor min matriks | Program JavaScript untuk mencari vektor min matriks yang diberikan; Fungsi untuk mencari vektor min; Gelung untuk melintasi setiap lajur; Untuk mengira min setiap baris; untuk menyimpan jumlah elemen lajur; Kod pemacu", "code": "var rows = 3 ; var cols = 3 ; function meanVector ( mat ) { document . write ( \" \" ) ; for ( var i = 0 ; i < rows ; i ++ ) { var mean = 0.00 ; var sum = 0 ; for ( var j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; document . write ( mean + \" \" ) ; } document . write ( \" \" ) ; } var mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; meanVector ( mat ) ;"}
{"text": "Nombor Hoax | Fungsi untuk mencari faktor utama yang berbeza dari nombor n; N adalah ganjil pada ketika ini, kerana ia tidak lagi dibahagikan dengan 2. Oleh itu, kita boleh menguji hanya untuk nombor ganjil, sama ada faktor n; Semak jika saya adalah faktor utama; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Fungsi untuk mengira jumlah digit faktor utama yang berbeza dari nombor N dan jumlah digit nombor N dan bandingkan jumlah yang diperoleh; Faktor utama N sedang disimpan dalam vektor PF; Jika n adalah nombor perdana, ia tidak boleh menjadi nombor tipuan; Mencari jumlah digit faktor utama yang berbeza dari nombor n; Mencari jumlah digit dalam faktor utama semasa PF [i]. ; Mencari jumlah digit nombor n; Membandingkan dua jumlah yang dikira; Kaedah Pemandu", "code": "function primeFactors ( n ) { var res = [ ] ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = parseInt ( n / 2 ) ; res . push ( 2 ) ; } for ( var i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = parseInt ( n / i ) ; res . push ( i ) ; } } if ( n > 2 ) res . push ( n ) ; return res ; } function isHoax ( n ) { var pf = primeFactors ( n ) ; if ( pf [ 0 ] == n ) return false ; var all_pf_sum = 0 ; for ( var i = 0 ; i < pf . length ; i ++ ) { var pf_sum ; for ( pf_sum = 0 ; pf [ i ] > 0 ; pf_sum += pf [ i ] % 10 , pf [ i ] = parseInt ( pf [ i ] / 10 ) ) ; all_pf_sum += pf_sum ; } var sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n = parseInt ( n / 10 ) ) ; return sum_n == all_pf_sum ; } var n = 84 ; if ( isHoax ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Ujian Primal | Tetapkan 5 (Menggunakan Lucas | Fungsi untuk mengetahui terma pertama N (Memandangkan 4 sebagai istilah ke -0) Lucas - siri Lehmer., Istilah ke -0 siri adalah 4.", "code": "function LucasLehmer ( n ) { let current_val = 4 ; let series = [ ] ; series . push ( current_val ) ; for ( let i = 0 ; i < n ; i ++ ) { current_val = ( current_val * current_val ) - 2 ; series . push ( current_val ) ; } for ( let i = 0 ; i <= n ; i ++ ) { document . write ( \" \" + i + \" \" + series [ i ] + \" \" ) ; } } let n = 5 ; LucasLehmer ( n ) ;"}
{"text": "Modular multiplicative songsang dari 1 hingga n | Kaedah naif untuk mencari terbalik berbilang modular 'A' di bawah modulo 'Perdana; Kod pemacu", "code": "function modInverse ( a , prime ) { a = a % prime ; for ( let x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return - 1 ; } function printModIverses ( n , prime ) { for ( let i = 1 ; i <= n ; i ++ ) document . write ( modInverse ( i , prime ) + \" \" ) ; } let n = 10 ; let prime = 17 ; printModIverses ( n , prime ) ;"}
{"text": "Tukar ke nombor dengan digit sebagai 3 dan 8 sahaja | fungsi untuk operasi minimum; baki dan kiraan operasi; mengira digit tidak sama dengan 3 atau 8; fungsi pemacu", "code": "function minOp ( num ) { var rem ; var count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num = parseInt ( num / 10 ) ; } return count ; } var num = 234198 ; document . write ( \" \" + minOp ( num ) ) ;"}
{"text": "Integer terbesar yang mempunyai jumlah digit maksimum dalam julat dari 1 hingga n | Berfungsi untuk mengira jumlah digit nombor. ; Mengembalikan nombor maksimum dengan jumlah maksimum digit. ; Memulakan b sebagai 1 dan jumlah maksimum awal menjadi n; Berulang dari kanan ke kiri dalam digit; Walaupun meleleh ini adalah nombor dari kanan ke kiri; Memanggil fungsi untuk memeriksa sama ada jumlah CUR adalah lebih daripada ANS; Mengurangkan nombor ke satu unit kurang; Kod pemacu", "code": "function sumOfDigits ( a ) { var sum = 0 ; while ( a != 0 ) { sum += a % 10 ; a = parseInt ( a / 10 ) ; } return sum ; } function findMax ( x ) { var b = 1 , ans = x ; while ( x != 0 ) { var cur = ( x - 1 ) * b + ( b - 1 ) ; if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) || ( sumOfDigits ( cur ) == sumOfDigits ( ans ) && cur > ans ) ) ans = cur ; x = parseInt ( x / 10 ) ; b *= 10 ; } return ans ; } var n = 521 ; document . write ( findMax ( n ) ) ;"}
{"text": "Julat Interquartile (IQR) | Fungsi untuk memberi indeks median; Fungsi untuk mengira IQR; Indeks median keseluruhan data; Median separuh pertama; Median separuh kedua; Pengiraan IQR; Kod pemacu", "code": "function median ( a , l , r ) { var n = r - l + 1 ; n = parseInt ( ( n + 1 ) / 2 ) - 1 ; return parseInt ( n + l ) ; } function IQR ( a , n ) { a . sort ( ( a , b ) => a - b ) ; var mid_index = median ( a , 0 , n ) ; var Q1 = a [ median ( a , 0 , mid_index ) ] ; var Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] ; return ( Q3 - Q1 ) ; } var a = [ 1 , 19 , 7 , 6 , 5 , 9 , 12 , 27 , 18 , 2 , 15 ] ; var n = a . length ; document . write ( IQR ( a , n ) ) ;"}
{"text": "Nombor palindromik terbesar dalam array | fungsi untuk menyusun; Fungsi untuk memeriksa sama ada n adalah palindrome; Cari pembahagi yang sesuai untuk mengekstrak digit terkemuka; Jika digit pertama dan terakhir tidak sama maka kembali palsu; Mengeluarkan digit terkemuka dan trailing dari nombor; Mengurangkan pembahagi dengan faktor 2 sebagai 2 digit dijatuhkan; Berfungsi untuk mencari nombor palindromik terbesar; Susun array; Jika nombor adalah palindrome; Jika tiada nombor palindromik yang dijumpai; Cetak jawapan yang diperlukan", "code": "function ssort ( a , n ) { var i , j , min , temp ; for ( i = 0 ; i < n - 1 ; i ++ ) { min = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( a [ j ] < a [ min ] ) min = j ; temp = a [ i ] ; a [ i ] = a [ min ] ; a [ min ] = temp ; } } function isPalindrome ( n ) { var divisor = 1 ; while ( parseInt ( n / divisor ) >= 10 ) divisor *= 10 ; while ( n != 0 ) { var leading = parseInt ( n / divisor ) ; var trailing = n % 10 ; if ( leading != trailing ) return false ; n = parseInt ( ( n % divisor ) / 10 ) ; divisor = parseInt ( divisor / 100 ) ; } return true ; } function largestPalindrome ( A , n ) { ssort ( A , A . length ) ; for ( var i = n - 1 ; i >= 0 ; -- i ) { if ( isPalindrome ( A [ i ] ) ) return A [ i ] ; } return - 1 ; } var A = [ 1 , 232 , 54545 , 999991 ] ; var n = A . length ; document . write ( largestPalindrome ( A , n ) ) ;"}
{"text": "Jumlah gandaan dua nombor di bawah n | Berfungsi untuk mengembalikan jumlah semua bilangan bulat di bawah n yang merupakan gandaan sama ada A atau B; Jika saya adalah pelbagai A atau B; Kod pemacu", "code": "function findSum ( n , a , b ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; } let n = 10 ; let a = 3 ; let b = 5 ; document . write ( findSum ( n , a , b ) ) ;"}
{"text": "Kurangkan 1 tanpa pengendali aritmetik | Program pemacu untuk menguji fungsi di atas", "code": "function subtractOne ( x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } document . write ( ( subtractOne ( 13 ) ) ) ;"}
{"text": "Nombor Pell | Hitung nombor pell; Kod pemacu", "code": "function pell ( n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; } let n = 4 ; document . write ( pell ( n ) ) ;"}
{"text": "Mencari LCM lebih daripada dua (atau array) tanpa menggunakan GCD | Mengembalikan LCM ARR [0 .. n - 1]; Cari nilai maksimum dalam ARR []; Memulakan hasil; Cari semua faktor yang terdapat dalam dua atau lebih elemen array. var x = 2; Faktor semasa. ; Untuk menyimpan indeks semua elemen array yang boleh dibahagikan dengan x. ; Sekiranya terdapat 2 atau lebih elemen array yang boleh dibahagikan dengan x. ; Kurangkan semua elemen array yang boleh dibahagikan dengan x. ; Kemudian kalikan semua elemen array yang dikurangkan; Kod pemacu", "code": "function LCM ( arr , n ) { var max_num = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( max_num < arr [ i ] ) max_num = arr [ i ] ; var res = 1 ; while ( x <= max_num ) { var indexes = [ ] ; for ( var j = 0 ; j < n ; j ++ ) if ( arr [ j ] % x == 0 ) indexes . push ( j ) ; if ( indexes . length >= 2 ) { for ( var j = 0 ; j < indexes . length ; j ++ ) arr [ indexes [ j ] ] = arr [ indexes [ j ] ] / x ; res = res * x ; } else x ++ ; } for ( var i = 0 ; i < n ; i ++ ) res = res * arr [ i ] ; return res ; } var arr = [ 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 ] ; var n = arr . length ; document . write ( LCM ( arr , n ) + \" \" ) ;"}
{"text": "Cari kesopanan nombor | Berfungsi untuk mencari kesopanan; sqrt (2 * n) sebagai panjang maksimum akan apabila jumlahnya bermula dari 1 yang mengikuti persamaan n ^ 2 - n - (2 * jumlah) = 0; Kod pemacu", "code": "function politness ( n ) { let count = 0 ; for ( let i = 2 ; i <= Math . sqrt ( 2 * n ) ; i ++ ) { let a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a = Math . floor ( a / i ) ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a = Math . floor ( a / 2 ) ; if ( a > 0 ) { count ++ ; } } return count ; } let n = 90 ; document . write ( \" \" + n + \" \" + politness ( n ) + \" \" ) ; n = 15 ; document . write ( \" \" + n + \" \" + politness ( n ) ) ;"}
{"text": "Program untuk tekaan Goldbach (dua prima dengan jumlah yang diberikan) | Program JavaScript untuk melaksanakan tekaan Goldbach; Array untuk menyimpan semua perdana kurang daripada dan sama dengan 10 ^ 6; Fungsi utiliti untuk Sieve of Sundaram; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahukan prima yang lebih kecil daripada Max, kita mengurangkan max hingga separuh. Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 * i * j dari orang lain di mana 1 <= i <= j; Logik utama Sundaram. Tandakan semua nombor yang tidak menjana nombor perdana dengan melakukan 2 * i + 1; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Berfungsi untuk melakukan sangkaan Goldbach; Kembali jika nombor tidak atau kurang daripada 3; Semak hanya separuh daripada nombor; Cari perbezaan dengan menolak perdana semasa dari n; Cari jika perbezaannya juga merupakan nombor utama; Menyatakan sebagai jumlah prima; Mencari semua nombor perdana sebelum had; Nombor Ekspres sebagai Jumlah Dua Prima", "code": "let MAX = 10000 ; let primes = new Array ( ) ; function sieveSundaram ( ) { let marked = new Array ( parseInt ( MAX / 2 ) + 100 ) . fill ( false ) ; for ( let i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( let j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push ( 2 ) ; for ( let i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push ( 2 * i + 1 ) ; } function findPrimes ( n ) { if ( n <= 2 n % 2 != 0 ) { document . write ( \" \" ) ; return ; } for ( let i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { let diff = n - primes [ i ] ; if ( primes . includes ( diff ) ) { document . write ( primes [ i ] + \" \" + diff + \" \" + n + \" \" ) ; return ; } } } sieveSundaram ( ) ; findPrimes ( 4 ) ; findPrimes ( 38 ) ; findPrimes ( 100 ) ;"}
{"text": "K | Fungsi untuk menjana faktor utama nombor n dan mengembalikan faktor utama; Cari bilangan 2 yang membahagikan k; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, simpan saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes di mana n adalah nombor perdana yang lebih besar daripada 2; Kod pemacu", "code": "function kPrimeFactor ( n , k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return - 1 ; } let n = 12 , k = 3 ; document . write ( kPrimeFactor ( n , k ) + \" \" ) ; n = 14 ; k = 3 ; document . write ( kPrimeFactor ( n , k ) ) ;"}
{"text": "K | Program JavaScript untuk mencari faktor utama menggunakan SIEVE OF ERATOSTHENES. Program ini adalah cekap apabila kita mempunyai pelbagai nombor. ; Menggunakan Sieveoferatosthenes untuk mencari faktor utama terkecil semua nombor. Sebagai contoh, jika max adalah 10, s [2] = s [4] = s [6] = s [10] = 2 s [3] = s [9] = 3 s [5] = 5 s [7] = 7; Buat array Boolean \"Perdana [0.. Max]\" dan memulakan semua penyertaan di dalamnya sebagai palsu. ; Memulakan faktor terkecil sama dengan 2 untuk semua nombor walaupun; Untuk nombor ganjil kurang kemudian sama dengan n; S (i) untuk perdana adalah nombor itu sendiri; Untuk semua gandaan nombor perdana semasa; Saya adalah faktor utama terkecil untuk nombor \"i * j\". ; Berfungsi untuk menjana faktor utama dan mengembalikan faktor utama. S [i] menyimpan faktor utama i. ; Terus membahagikan n dengan faktor utama walaupun sama ada n tidak 1 atau kiraan faktor utama bukan k. ; Untuk menjejaki kiraan faktor utama; Bahagikan N untuk mencari faktor utama seterusnya; S [i] akan menyimpan faktor utama i.", "code": "var MAX = 10001 ; function sieveOfEratosthenes ( s ) { prime = Array . from ( { length : MAX + 1 } , ( _ , i ) => false ) ; for ( i = 2 ; i <= MAX ; i += 2 ) s [ i ] = 2 ; for ( i = 3 ; i <= MAX ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( j = i ; j * i <= MAX ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } function kPrimeFactor ( n , k , s ) { while ( n > 1 ) { if ( k == 1 ) return s [ n ] ; k -- ; n /= s [ n ] ; } return - 1 ; } var s = Array . from ( { length : MAX + 1 } , ( _ , i ) => 0 ) ; sieveOfEratosthenes ( s ) ; var n = 12 , k = 3 ; document . write ( kPrimeFactor ( n , k , s ) + \" \" ) ; n = 14 ; k = 3 ; document . write ( kPrimeFactor ( n , k , s ) ) ;"}
{"text": "Cari jumlah pembahagi semua pembahagi nombor semulajadi | Mengembalikan jumlah pembahagi semua pembahagi N; Mengira kuasa faktor utama dan menyimpannya dalam MP MP []. ; Jika n adalah nombor perdana; Untuk setiap faktor utama, mengira (p ^ (a + 1) - 1) / (p - 1) dan menambahnya untuk menjawab. ; Kod pemacu", "code": "function sumDivisorsOfDivisors ( n ) { let mp = new Map ( ) ; for ( let j = 2 ; j <= Math . sqrt ( n ) ; j ++ ) { let count = 0 ; while ( n % j == 0 ) { n = Math . floor ( n / j ) ; count ++ ; } if ( count != 0 ) mp . set ( j , count ) ; } if ( n != 1 ) mp . set ( n , 1 ) ; let ans = 1 ; for ( let [ key , value ] of mp . entries ( ) ) { let pw = 1 ; let sum = 0 ; for ( let i = value + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw = key ; } ans *= sum ; } return ans ; } let n = 10 ; document . write ( sumDivisorsOfDivisors ( n ) ) ;"}
{"text": "Perdana terdekat yang kurang daripada bilangan N | Berfungsi untuk mengembalikan nombor perdana terdekat; Semua nombor utama adalah ganjil kecuali dua; Ia hanya akan dilaksanakan apabila n adalah 3; Kod pemacu", "code": "function prime ( n ) { if ( n & 1 ) n -= 2 ; else n -- ; let i , j ; for ( i = n ; i >= 2 ; i -= 2 ) { if ( i % 2 == 0 ) continue ; for ( j = 3 ; j <= Math . sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) break ; } if ( j > Math . sqrt ( i ) ) return i ; } return 2 ; } let n = 17 ; document . write ( prime ( n ) ) ;"}
{"text": "Cari urutan berulang dalam pecahan | Fungsi ini mengembalikan urutan berulang pecahan. Jika mengulangi urutan tidak keluar, maka mengembalikan rentetan kosong; Memulakan hasil; Buat peta untuk menyimpan yang sudah dilihat sisa. Sisa digunakan sebagai kunci dan kedudukannya dalam hasil disimpan sebagai nilai. Perhatikan bahawa kita memerlukan kedudukan untuk kes -kes seperti 1/6. Dalam kes ini, urutan berulang tidak bermula dari sisa pertama. ; Cari sisa pertama; Terus mencari baki sehingga sama ada baki menjadi 0 atau mengulangi; Simpan selebihnya ini; Kain baki dengan 10; Tambah REM / DENR untuk menghasilkan; Baki kemas kini; Program Pemandu", "code": "function fractionToDecimal ( numr , denr ) { let res = \" \" ; let mp = new Map ( ) ; mp . clear ( ) ; let rem = numr % denr ; while ( ( rem != 0 ) && ( ! mp . has ( rem ) ) ) { mp . set ( rem , res . length ) ; rem = rem * 10 ; let res_part = Math . floor ( rem / denr ) ; res += res_part . toString ( ) ; rem = rem % denr ; } if ( rem == 0 ) return \" \" ; else if ( mp . has ( rem ) ) return res . substr ( mp . get ( rem ) ) ; return \" \" ; } let numr = 50 , denr = 22 ; let res = fractionToDecimal ( numr , denr ) ; if ( res == \" \" ) document . write ( \" \" ) ; else document . write ( \" \" + res ) ;"}
{"text": "NOMBOR NOMBOR YANG MEMILIKI 0 A DENGIT | Pulangan 1 jika x mempunyai 0, lain 0; Melintasi semua digit X untuk memeriksa sama ada ia mempunyai 0 .; Jika digit semasa adalah 0, kembali benar; Mengembalikan kiraan nombor dari 1 hingga n dengan 0 sebagai digit; Memulakan kiraan nombor yang mempunyai 0 sebagai digit; Melintasi semua nombor dan untuk setiap nombor cek jika ia mempunyai 0 .; Program Pemandu", "code": "function has0 ( x ) { while ( x ) { if ( x % 10 == 0 ) return 1 ; x = Math . floor ( x / 10 ) ; } return 0 ; } function getCount ( n ) { let count = 0 ; for ( let i = 1 ; i <= n ; i ++ ) count += has0 ( i ) ; return count ; } let n = 107 ; document . write ( \" \" + \" \" + n + \" \" + getCount ( n ) ) ;"}
{"text": "Kriteria Euler (periksa jika akar persegi di bawah modulo p wujud) | Pulangan benar jika akar persegi n di bawah modulo p wujud; Satu demi satu periksa semua nombor dari 2 hingga p - 1; Kod pemacu", "code": "function squareRootExists ( n , p ) { n = n % p ; for ( let x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; } let p = 7 ; let n = 2 ; if ( squareRootExists ( n , p ) === true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Formula Legendre (diberikan p dan n, cari x terbesar sedemikian rupa sehingga p^x membahagikan n!) | Mengembalikan kuasa terbesar P yang membahagikan N! ; Memulakan hasil; Kirakan x = n / p + n / (p ^ 2) + n / (p ^ 3) + .... ; Kod pemacu", "code": "function largestPower ( n , p ) { let x = 0 ; while ( n ) { n = parseInt ( n / p ) ; x += n ; } return Math . floor ( x ) ; } let n = 10 ; let p = 3 ; document . write ( \" \" + p ) ; document . write ( \" \" + n + \" \" ) ; document . write ( largestPower ( n , p ) ) ;"}
{"text": "Program untuk faktorial nombor | Program JavaScript untuk mencari faktorial nombor yang diberikan; Baris tunggal untuk mencari faktorial; Kod pemacu", "code": "function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } var num = 5 ; document . write ( \" \" + num + \" \" + factorial ( num ) ) ;"}
{"text": "Semua tentang manipulasi bit | Berfungsi untuk mendapatkan bit pada kedudukan ITH; Kembali benar jika bit ditetapkan. Sebaliknya kembali palsu", "code": "function getBit ( num , i ) { return ( ( num & ( 1 << i ) ) != 0 ) ; }"}
{"text": "Semua tentang manipulasi bit | Berfungsi untuk membersihkan sedikit nombor n; Buat topeng untuk bit ith tidak teratur; Kembalikan nilai kemas kini", "code": "function clearBit ( num , i ) { let mask = ~ ( 1 << i ) ; return num & mask ; }"}
{"text": "Jumlah bitwise dan setiap elemen array dengan unsur -unsur array lain | Berfungsi untuk mengira dan jumlah untuk setiap elemen array; Mengisytiharkan pelbagai saiz 32 untuk menyimpan kiraan setiap bit; Melintasi array arr2 [] dan simpan kiraan sedikit dalam array kekerapan; Kedudukan bit semasa; Walaupun NUM lebih besar daripada 0; Memeriksa jika bit ith ditetapkan atau tidak; Kenaikan kiraan sedikit demi satu; Meningkatkan kedudukan bit oleh satu; Kanan beralih num oleh satu; Melintasi Arr2 []; Simpan nilai bit ith; Jumlah jumlah yang diperlukan; Melintasi julat [0, 31]; Cek jika bit semasa ditetapkan; Kenaikan jumlah bitwise dengan kekerapan [bit_position] * value_at_that_bit; ; Shift kanan dengan satu; Shift kiri vale_at_that_bit oleh satu; Cetak jumlah yang diperolehi untuk nombor ith di arr1 []; Diberikan arr1 []; Diberikan arr2 []; Saiz arr1 []; Saiz arr2 []; Panggilan fungsi", "code": "function Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) { let frequency = new Array ( 32 ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { let bit_position = 0 ; let num = arr1 [ i ] ; while ( num ) { if ( num & 1 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( let i = 0 ; i < M ; i ++ ) { let num = arr2 [ i ] ; let value_at_that_bit = 1 ; let bitwise_AND_sum = 0 ; for ( let bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( num & 1 ) { bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } document . write ( bitwise_AND_sum + ' ' ) ; } return ; } let arr1 = [ 1 , 2 , 3 ] ; let arr2 = [ 1 , 2 , 3 ] ; let N = arr1 . length ; let M = arr2 . length Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) ;"}
{"text": "Matikan Bit Set Bit | Tetapkan 2 | Tidak menetapkan bit set yang paling kanan dan mengembalikan hasilnya; Memeriksa sama ada kedudukan bit ditetapkan atau tidak; Jika kedudukan bit ditemui, kami flip sedikit ini dengan nombor dan nombor yang diberikan dengan set kedudukan bit; Kod pemacu", "code": "function FlipBits ( n ) { for ( let bit = 0 ; bit < 32 ; bit ++ ) { if ( ( ( n >> bit ) & 1 ) > 0 ) { n = n ^ ( 1 << bit ) ; break ; } } document . write ( \" \" ) ; document . write ( \" \" + n ) ; } let N = 12 ; FlipBits ( N ) ;"}
{"text": "Bitwise dan semua nombor ganjil dari 1 hingga n | Berfungsi untuk mengembalikan bitwise dan semua bilangan bulat ganjil dari julat [1, n]; Memulakan hasil kepada 1; Bermula dari 3, bitwise dan semua bilangan bulat ganjil kurang daripada atau sama dengan n; Kod pemacu", "code": "function bitwiseAndOdd ( n ) { var result = 1 ; for ( var i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } var n = 10 ; document . write ( bitwiseAndOdd ( n ) ) ;"}
{"text": "Bitwise dan semua nombor ganjil dari 1 hingga n | Berfungsi untuk mengembalikan bitwise dan semua bilangan bulat ganjil dari julat [1, n]; Kod pemacu", "code": "function bitwiseAndOdd ( n ) { return 1 ; } var n = 10 ; document . write ( bitwiseAndOdd ( n ) ) ;"}
{"text": "Bit sebenar bit nombor yang diberikan | berfungsi untuk membalikkan bit nombor; melintasi bit 'n' dari kanan; Bitwise kiri Shift 'Rev' oleh 1; jika bit semasa ialah '1'; Bitwise kanan shift 'n' oleh 1; nombor yang diperlukan; Kod pemacu", "code": "function reverseBits ( n ) { let rev = 0 ; while ( n > 0 ) { rev <<= 1 ; if ( ( n & 1 ) == 1 ) rev ^= 1 ; n >>= 1 ; } return rev ; } let n = 11 ; document . write ( reverseBits ( n ) ) ;"}
{"text": "Cara untuk memecah array ke dalam dua kumpulan nilai XOR yang sama | Kembalikan jumlah cara untuk memecah array ke dalam dua kumpulan supaya setiap kumpulan mempunyai nilai XOR yang sama. ; Kita boleh berpecah hanya jika XOR adalah 0. Oleh kerana XOR semua adalah 0, kita boleh mempertimbangkan semua subset sebagai satu kumpulan. ; Program Pemandu", "code": "function countgroup ( a , n ) { var xs = 0 ; for ( var i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; } var a = [ 1 , 2 , 3 ] ; var n = a . length ; document . write ( countgroup ( a , n ) + \" \" ) ;"}
{"text": "Ekstrak 'k' bit dari kedudukan tertentu dalam nombor. | Berfungsi untuk mengekstrak k bit dari kedudukan p dan mengembalikan nilai yang diekstrak sebagai integer; Kod pemacu", "code": "function bitExtracted ( number , k , p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; } let number = 171 , k = 5 , p = 2 ; document . write ( \" \" , bitExtracted ( number , k , p ) ) ;"}
{"text": "Memaksimumkan nombor nombor yang tidak ditandatangani dengan menukar bit di kedudukan yang melampau. | Program JavaScript untuk mencari nombor maksimum dengan menukar bit yang melampau. ; Melintasi bit dari kedua -dua ekstrem; Mendapatkan bit i - th dan j - th; Menukar bit jika lebih rendah penting adalah lebih besar daripada bit yang lebih tinggi dan dengan sewajarnya mengubah suai nombor; Kod pemacu", "code": "function findMax ( num ) { let num_copy = num ; let j = 4 * 8 - 1 ; let i = 0 ; while ( i < j ) { let m = ( num_copy >> i ) & 1 ; let n = ( num_copy >> j ) & 1 ; if ( m > n ) { let x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; } let num = 4 ; document . write ( findMax ( num ) ) ;"}
{"text": "Periksa dengan cekap sama ada n adalah pelbagai 4 atau tidak | kaedah untuk memeriksa sama ada 'n' adalah pelbagai 4 atau tidak; jika benar, maka 'n' adalah pelbagai 4; lain 'n' bukanlah pelbagai 4; Kaedah Pemandu", "code": "function isAMultipleOf4 ( n ) { if ( ( n & 3 ) == 0 ) return true ; return false ; } let n = 16 ; document . write ( isAMultipleOf4 ( n ) ? \" \" : \" \" ) ;"}
{"text": "Kirakan persegi nombor tanpa menggunakan *, / dan pow () | Penyelesaian mudah untuk mengira persegi tanpa menggunakan * dan pow (); mengendalikan input negatif; Memulakan hasil; Tambah n ke res n - 1 kali; Kod pemacu", "code": "function square ( n ) { if ( n < 0 ) n = - n ; let res = n ; for ( let i = 1 ; i < n ; i ++ ) res += n ; return res ; } for ( let n = 1 ; n <= 5 ; n ++ ) document . write ( \" \" + n + \" \" + square ( n ) + \" \" ) ;"}
{"text": "Cari titik yang terletak di dalam Kuadrat yang tepat K yang diberikan | Pelaksanaan JavaScript pendekatan; Program pemacu untuk menguji fungsi di atas", "code": "function PointInKSquares ( n , a , k ) { a . sort ( ) ; return a [ n - k ] ; } let k = 2 ; let a = [ 1 , 2 , 3 , 4 ] ; let n = a . length ; let x = PointInKSquares ( n , a , k ) ; document . write ( \" \" + x + \" \" + x + \" \" ) ;"}
{"text": "Bilangan N digit Nombor Langkah | Penyelesaian Dioptimumkan Ruang | fungsi yang mengira jawapannya; DP [J] Kedai kiraan saya angka melangkah angka yang berakhir dengan digit j. ; Untuk menyimpan hasil panjang i - 1 sebelum mengemas kini dp [j] untuk panjang i. ; Jika n adalah 1 maka jawapannya akan menjadi 10 .; Memulakan nilai untuk mengira digit sama dengan 1 .; Mengira nilai untuk mengira digit lebih daripada 1 .; Jika angka berakhir adalah 0; Jika angka berakhir adalah 9; Untuk digit lain. ; menyimpan jawapan terakhir; program pemacu untuk menguji fungsi di atas", "code": "function answer ( n ) { var dp = Array ( 10 ) ; var prev = Array ( 10 ) ; if ( n == 1 ) return 10 ; for ( var j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ; for ( var i = 2 ; i <= n ; i ++ ) { for ( var j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( var j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ; else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ; else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } } var sum = 0 ; for ( var j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; } var n = 2 ; document . write ( answer ( n ) ) ;"}
{"text": "Perubahan minimum diperlukan untuk membuat urutan Catalan | Pelaksanaan JavaScript pendekatan; Untuk menyimpan nombor N First N; Berfungsi untuk mencari nombor N Catalan pertama; Memulakan dua nilai pertama dalam jadual; Isi penyertaan di Catalan [] menggunakan formula rekursif; Berfungsi untuk mengembalikan perubahan minimum yang diperlukan; Cari nombor N Catalan pertama; A dan B adalah dua nombor urutan Catalan pertama; tolak unsur -unsur Catalan pertama n untuk ditetapkan; Jika elemen Catalan hadir dalam array kemudian keluarkannya dari set; Kembalikan bilangan elemen dalam set; Kod pemacu", "code": "var MAX = 100000 var catalan = Array ( MAX ) ; function catalanDP ( n ) { catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( var i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( var j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } function CatalanSequence ( arr , n ) { catalanDP ( n ) ; var s = [ ] ; var a = 1 , b = 1 ; var c ; s . push ( a ) ; if ( n >= 2 ) s . push ( b ) ; for ( var i = 2 ; i < n ; i ++ ) { s . push ( catalan [ i ] ) ; } s . sort ( ( a , b ) => b - a ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s . includes ( arr [ i ] ) ) { s . pop ( arr [ i ] ) ; } } return s . length ; } var arr = [ 1 , 1 , 2 , 5 , 41 ] ; var n = arr . length ; document . write ( CatalanSequence ( arr , n ) ) ;"}
{"text": "Jumlah semua nombor komposit dari indeks ganjil array yang diberikan | Berfungsi untuk memeriksa nombor komposit; Periksa sama ada faktor lebih besar daripada 2; Semak sama ada nombor itu komposit atau tidak; Berfungsi untuk mencetak jumlah semua nombor komposit dalam array; Berulang untuk indeks ganjil dalam array; Semak sama ada nombor itu komposit kemudian tambahkannya ke jumlah; mengembalikan jumlahnya; Kod pemacu", "code": "function composite ( n ) { let flag = 0 ; let c = 0 ; for ( let j = 1 ; j <= n ; j ++ ) { if ( n % j == 0 ) { c += 1 ; } } if ( c >= 3 ) flag = 1 ; return flag ; } function odd_indices ( arr , n ) { let sum = 0 ; for ( let k = 0 ; k < n ; k += 2 ) { let check = composite ( arr [ k ] ) ; if ( check == 1 ) sum += arr [ k ] ; } document . write ( sum + \" \" ) ; } let arr = [ 13 , 5 , 8 , 16 , 25 ] ; let n = arr . length odd_indices ( arr , n ) ;"}
{"text": "Pertanyaan pada kiraan mata terletak di dalam bulatan | Pengkomputeran X ^ 2 + y ^ 2 untuk setiap titik yang diberikan dan menyusunnya. ; Kembali kiraan mata terletak di dalam atau pada lilitan bulatan menggunakan carian binari pada p [0. n - 1]; Program pemacu untuk menguji fungsi di atas; Kirakan jarak semua mata dan simpan jarak yang disusun supaya pertanyaan dapat berfungsi dalam O (logn) menggunakan carian binari. ; Cetak nombor mata dalam lingkaran radius 3 .; Cetak nombor mata dalam lingkaran radius 32.", "code": "function preprocess ( p , x , y , n ) { for ( let i = 0 ; i < n ; i ++ ) p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; p . sort ( function ( a , b ) { return a - b ; } ) ; } function query ( p , n , rad ) { let start = 0 , end = n - 1 ; while ( ( end - start ) > 1 ) { let mid = Math . floor ( ( start + end ) / 2 ) ; let tp = Math . sqrt ( p [ mid ] ) ; if ( tp > ( rad * 1.0 ) ) end = mid - 1 ; else start = mid ; } let tp1 = Math . sqrt ( p [ start ] ) ; let tp2 = Math . sqrt ( p [ end ] ) ; if ( tp1 > ( rad * 1.0 ) ) return 0 ; else if ( tp2 <= ( rad * 1.0 ) ) return end + 1 ; else return start + 1 ; } let x = [ 1 , 2 , 3 , - 1 , 4 ] ; let y = [ 1 , 2 , 3 , - 1 , 4 ] ; let n = x . length ; let p = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { p [ i ] = 0 ; } preprocess ( p , x , y , n ) ; document . write ( query ( p , n , 3 ) + \" \" ) ; document . write ( query ( p , n , 32 ) + \" \" ) ;"}
{"text": "Count bilangan panjang n mempunyai nombor perdana pada indeks ganjil dan nombor ganjil pada indeks walaupun | berfungsi untuk mencari jumlah cara; Tiada indeks ganjil dalam nombor n - digit; Tidak ada indeks dalam nombor n - digit; Tidak ada cara untuk mengatur digit nombor utama dalam indeks ganjil; Tidak ada cara untuk mengatur digit nombor ganjil dalam indeks walaupun; mengembalikan jumlah cara; kod pemacu", "code": "function find_Numb_ways ( n ) { var odd_indices = n / 2 ; var even_indices = ( n / 2 ) + ( n % 2 ) ; var arr_odd = Math . pow ( 4 , odd_indices ) ; var arr_even = Math . pow ( 5 , even_indices ) ; return arr_odd * arr_even ; } var n = 4 ; document . write ( find_Numb_ways ( n ) ) ;"}
{"text": "Semak jika array yang diberikan disusun secara lingkaran atau tidak | Berfungsi untuk memeriksa sama ada array disusun secara rohani atau tidak; Kedai memulakan indeks array; Kedai akhir indeks array; Jika arr [mula] lebih besar daripada arr [end]; Kemas kini Mula; Jika arr [end] lebih besar daripada arr [start]; Akhir kemas kini; Kod pemacu; Panggilan fungsi", "code": "function isSpiralSorted ( arr , n ) { let start = 0 ; let end = n - 1 ; while ( start < end ) { if ( arr [ start ] > arr [ end ] ) { return false ; } start ++ ; if ( arr [ end ] > arr [ start ] ) { return false ; } end -- ; } return true ; } let arr = [ 1 , 10 , 14 , 20 , 18 , 12 , 5 ] ; let N = arr . length ; if ( isSpiralSorted ( arr , N ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Cetak semua rentetan dari array yang diberikan yang boleh ditaip menggunakan kekunci dari satu baris papan kekunci QWERTY | Berfungsi untuk mencetak semua rentetan yang boleh ditaip menggunakan kunci satu baris dalam papan kekunci QWERTY; Kedai baris nombor semua watak yang mungkin dari rentetan; Melintasi array; Jika rentetan semasa bukan rentetan kosong; Menetapkan benar / palsu jika rentetan boleh ditaip menggunakan kunci satu baris atau tidak; Kedai baris nombor watak pertama rentetan semasa; Kedai panjang perkataan; Melintasi rentetan semasa; Jika watak semasa tidak boleh ditaip menggunakan kekunci rownum sahaja; Bendera kemas kini; Jika rentetan semasa boleh ditaip menggunakan kekunci dari rownum sahaja; Cetak rentetan; Kod pemacu", "code": "function findWordsSameRow ( arr ) { var mp = { } ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 3 ; mp [ \" \" ] = 3 ; mp [ \" \" ] = 3 ; mp [ \" \" ] = 3 ; mp [ \" \" ] = 3 ; mp [ \" \" ] = 3 ; mp [ \" \" ] = 3 ; for ( const word of arr ) { if ( word . length !== 0 ) { var flag = true ; var rowNum = mp [ word [ 0 ] . toLowerCase ( ) ] ; var M = word . length ; for ( var i = 1 ; i < M ; i ++ ) { if ( mp [ word [ i ] . toLowerCase ( ) ] !== rowNum ) { flag = false ; break ; } } if ( flag ) { document . write ( word + \" \" ) ; } } } } var words = [ \" \" , \" \" , \" \" , \" \" ] ; findWordsSameRow ( words ) ;"}
{"text": "Kiraan quadruples jenis yang diberikan dari array yang diberikan | Fungsi untuk mencari kiraan jenis berikutnya; Menyimpan kiraan quadruples; Menjana semua kemungkinan kombinasi quadruples; Semak jika elemen 1 ST sama dengan elemen 3 RD; Semak jika elemen 2 ND adalah sama dengan elemen ke -4; Kod pemacu", "code": "function countSubsequece ( a , n ) { let i , j , k , l ; let answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; } let a = [ 1 , 2 , 3 , 2 , 1 , 3 , 2 ] ; document . write ( countSubsequece ( a , 7 ) ) ;"}
{"text": "Watak terkecil dalam rentetan yang mempunyai jumlah minimum jarak antara pengulangan berturut -turut | Berfungsi untuk mencari pengulangan Acter dengan jarak minimum; Menyimpan indeks pertama dan terakhir; Inisialisasi dengan - 1; Dapatkan nilai kejadian terakhir dan pertama; Mengemas kini indeks pertama; Mengemas kini indeks terakhir; Memulakan min; Dapatkan minimum; Nilai tidak boleh sama; Mengemas kini jarak minimum; kembali Ans; Kod pemacu; Panggilan fungsi", "code": "function minDistChar ( s ) { let n = s . length ; let first = new Array ( 26 ) ; let last = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( let i = 0 ; i < n ; i ++ ) { if ( first [ s [ i ] - ' ' ] == - 1 ) { first [ s [ i ] - ' ' ] = i ; } last [ s [ i ] - ' ' ] = i ; } let min = 100000 ; var ans = ' ' ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( last [ i ] == first [ i ] ) continue ; if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = String . fromCharCode ( i + 97 ) ; } } return ans ; } str = \" \" ; document . write ( minDistChar ( str ) ) ;"}
{"text": "Langkah -langkah minimum yang diperlukan untuk mencapai akhir matriks | Tetapkan 2 | Pelaksanaan JavaScript pendekatan; Berfungsi untuk mengembalikan langkah minimum yang diperlukan untuk mencapai akhir matriks; Array untuk menentukan sama ada sel telah dikunjungi sebelum ini; Giliran untuk BFS; Memulakan giliran; Untuk menyimpan kedalaman carian; Algoritma BFS; Saiz giliran semasa; Atas - kebanyakan elemen barisan; Untuk menyimpan indeks sel untuk kesederhanaan; Kes asas; Jika kita mencapai (n - 1, n - 1); Menandakan sel yang dikunjungi; Menolak sel -sel bersebelahan dalam barisan yang boleh dikunjungi dari sel semasa; Kod pemacu", "code": "var n = 3 ; function minSteps ( arr ) { var v = Array . from ( Array ( n ) , ( ) => Array ( n ) . fill ( 0 ) ) ; var q = [ ] ; q . push ( [ 0 , 0 ] ) ; var depth = 0 ; while ( q . length != 0 ) { var x = q . length ; while ( x -- ) { var y = q [ 0 ] ; var i = y [ 0 ] , j = y [ 1 ] ; q . shift ( ) ; if ( v [ i ] [ j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i ] [ j ] = 1 ; if ( i + arr [ i ] [ j ] < n ) q . push ( [ i + arr [ i ] [ j ] , j ] ) ; if ( j + arr [ i ] [ j ] < n ) q . push ( [ i , j + arr [ i ] [ j ] ] ) ; } depth ++ ; } return - 1 ; } var arr = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ; document . write ( minSteps ( arr ) ) ;"}
{"text": "Jurang terbesar dalam array | fungsi untuk menyelesaikan masalah yang diberikan; Kod pemacu", "code": "function solve ( a , n ) { let max1 = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; } let arr = [ - 1 , 2 , 3 , - 4 , - 10 , 22 ] ; let size = arr . length ; document . write ( \" \" + solve ( arr , size ) ) ;"}
{"text": "Jurang terbesar dalam array | fungsi untuk menyelesaikan masalah yang diberikan; mencari maksimum dan minimum array; Kod pemacu", "code": "function solve ( a , n ) { let min1 = a [ 0 ] ; let max1 = a [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . abs ( min1 - max1 ) ; } let arr = [ - 1 , 2 , 3 , 4 , - 10 ] ; let size = arr . length ; document . write ( \" \" + solve ( arr , size ) ) ;"}
{"text": "Cetak rentetan terbalik selepas mengeluarkan vokal | Fungsi untuk menggantikan rentetan; memulakan rentetan panjang n; Melintasi semua aksara rentetan; Berikan nilai kepada rentetan r dari indeks terakhir rentetan s; jika S [i] adalah konsonan maka cetak r [i]; Fungsi pemacu", "code": "function replaceOriginal ( s , n ) { var r = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' ) { document . write ( r [ i ] ) ; } } document . write ( \" \" ) ; } var s = \" \" ; var n = s . length ; replaceOriginal ( s , n ) ;"}
{"text": "Semak jika rentetan boleh dibuat sama dengan rentetan lain dengan menukar atau penggantian aksara | Fungsi untuk mencari jika rentetan yang diberikan adalah sama atau tidak; Keadaan asas; Kedai kekerapan aksara string str1 dan str2; Traverse Strings str1 & str2 dan frekuensi kedai dalam [] dan b []; Semak sama ada kedua -dua rentetan mempunyai aksara yang sama atau tidak; Jika watak hadir dalam satu rentetan dan tidak dalam rentetan lain, kembali palsu; Susun array A [] dan B []; Periksa Array A dan B mengandungi kekerapan yang sama atau tidak; Jika frekuensi tidak sama selepas menyusun; Pada ketika ini, Str1 boleh ditukar kepada Str2; Kod pemacu", "code": "function sameStrings ( str1 , str2 ) { var N = str1 . length ; var M = str2 . length ; if ( N !== M ) { return false ; } var a = new Array ( 256 ) . fill ( 0 ) ; var b = new Array ( 256 ) . fill ( 0 ) ; for ( var j = 0 ; j < N ; j ++ ) { a [ str1 [ j ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] ++ ; b [ str2 [ j ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] ++ ; } var i = 0 ; while ( i < 256 ) { if ( ( a [ i ] === 0 && b [ i ] === 0 ) || ( a [ i ] !== 0 && b [ i ] !== 0 ) ) { i ++ ; } else { return false ; } } a . sort ( ( x , y ) => x - y ) ; b . sort ( ( x , y ) => x - y ) ; for ( var j = 0 ; j < 256 ; j ++ ) { if ( a [ j ] !== b [ j ] ) return false ; } return true ; } var S1 = \" \" , S2 = \" \" ; if ( sameStrings ( S1 , S2 ) ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text": "Kurangkan tiga nombor dengan menurunkan pasangan | Berfungsi untuk mencari operasi nombor minimum; Masukkan tiga nombor dalam array; Susun array; Kes 2; Kes 1; Diberikan a, b, c; Panggilan fungsi", "code": "function solution ( A , B , C ) { let arr = Array . from ( { length : 3 } , ( _ , i ) => 0 ) ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; arr . sort ( ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; } let A = 8 , B = 1 , C = 5 ; document . write ( solution ( A , B , C ) ) ;"}
{"text": "Cari elemen dalam array yang disusun dan diputar dengan pendua | Berfungsi untuk mengembalikan indeks kunci dalam arr [l. . h] jika kunci hadir sebaliknya kembali - 1; Kes yang rumit, hanya kemas kini kiri dan kanan; Jika arr [l ... pertengahan] disusun; Oleh kerana subarray ini disusun, kita dapat dengan cepat memeriksa sama ada kunci terletak pada mana -mana bahagian; Jika kunci tidak terletak pada separuh pertama subarray maka bahagikan separuh lagi ke dalam dua subarray sehingga kita dapat dengan cepat memeriksa apakah kunci terletak pada separuh lagi; Jika arr [l. . pertengahan] subarray pertama tidak disusun kemudian arr [pertengahan ... h] mesti disusun subarray; Kod pemacu", "code": "function search ( arr , l , h , key ) { if ( l > h ) return - 1 ; let mid = parseInt ( ( l + h ) / 2 , 10 ) ; if ( arr [ mid ] == key ) return mid ; if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { ++ l ; -- h ; return search ( arr , l , h , key ) } if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } let arr = [ 3 , 3 , 1 , 2 , 3 , 3 ] ; let n = arr . length ; let key = 3 ; document . write ( search ( arr , 0 , n - 1 , key ) ) ;"}
{"text": "Kes | Berfungsi untuk mengembalikan rentetan yang disusun; Vektor untuk menyimpan huruf kecil dan huruf besar; Menyusun kedua -dua vektor; Jika watak semasa adalah huruf kecil kemudian pilih watak huruf kecil dari senarai yang disusun; Lain memilih watak huruf besar; Kembalikan rentetan yang disusun; Kod pemacu", "code": "function getSortedString ( s , n ) { var v1 = [ ] ; var v2 = [ ] ; var i = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] . charCodeAt ( 0 ) > \" \" . charCodeAt ( 0 ) && s [ i ] . charCodeAt ( 0 ) <= \" \" . charCodeAt ( 0 ) ) v1 . push ( s [ i ] ) ; if ( s [ i ] . charCodeAt ( 0 ) > \" \" . charCodeAt ( 0 ) && s [ i ] . charCodeAt ( 0 ) <= \" \" . charCodeAt ( 0 ) ) v2 . push ( s [ i ] ) ; } console . log ( v1 ) ; v1 . sort ( ) ; v2 . sort ( ) ; var j = 0 ; i = 0 ; for ( var k = 0 ; k < n ; k ++ ) { if ( s [ k ] . charCodeAt ( 0 ) > \" \" . charCodeAt ( 0 ) && s [ k ] . charCodeAt ( 0 ) <= \" \" . charCodeAt ( 0 ) ) { s [ k ] = v1 [ i ] ; ++ i ; } else if ( s [ k ] . charCodeAt ( 0 ) > \" \" . charCodeAt ( 0 ) && s [ k ] . charCodeAt ( 0 ) <= \" \" . charCodeAt ( 0 ) ) { s [ k ] = v2 [ j ] ; ++ j ; } } return s . join ( \" \" ) ; } var s = \" \" ; var n = s . length ; document . write ( getSortedString ( s . split ( \" \" ) , n ) ) ;"}
{"text": "Semak jika rentetan mengandungi huruf berturut -turut dan setiap huruf berlaku tepat sekali | Berfungsi untuk memeriksa sama ada keadaan memegang; Dapatkan panjang rentetan; Susun rentetan yang diberikan; ITERATE untuk setiap indeks dan periksa keadaan; Jika tidak berturut -turut; Contoh 1 st; Contoh 2 nd", "code": "function check ( s ) { let l = s . length ; s . sort ( ) ; for ( let i = 1 ; i < l ; i ++ ) { if ( ( s [ i ] . charCodeAt ( ) - s [ i - 1 ] . charCodeAt ( ) ) != 1 ) return false ; } return true ; } let str = \" \" ; if ( check ( str . split ( ' ' ) ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ; let str1 = \" \" ; if ( check ( str1 . split ( ' ' ) ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text": "Subset terkecil dengan jumlah yang lebih besar daripada semua elemen lain | Fungsi untuk mencari elemen minimum yang diperlukan. ; mengira separuh daripada jumlah array; Susun array dalam urutan menurun. ; jumlah semasa lebih besar daripada jumlah; Kod pemacu", "code": "function minElements ( arr , n ) { let halfSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = parseInt ( halfSum / 2 , 10 ) ; arr . sort ( function ( a , b ) { return a - b } ) ; arr . reverse ( ) ; let res = 0 , curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; } let arr = [ 3 , 1 , 7 , 1 ] ; let n = arr . length ; document . write ( minElements ( arr , n ) ) ;"}
{"text": "Peningkatan dan penurunan minimum oleh k setiap elemen pasangan yang diperlukan untuk membuat semua elemen array sama | Berfungsi untuk memeriksa sama ada mungkin untuk membuat semua elemen array sama atau tidak; Menyimpan jumlah array; Melintasi array; Jika jumlahnya boleh dibahagikan dengan n; Jika tidak, tidak mungkin untuk membuat semua elemen array sama; Diberikan array; Saiz array", "code": "function arrayElementEqual ( arr , N ) { var sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum % N == 0 ) { document . write ( \" \" ) ; } else { document . write ( \" \" + \" \" ) ; } } var arr = [ 1 , 5 , 6 , 4 ] ; var N = arr . length ; arrayElementEqual ( arr , N ) ;"}
{"text": "Susun semula Arahan untuk memaksimumkan jumlah GCD unsur -unsur array dengan indeks masing -masing | Berfungsi untuk mencari jumlah maksimum GCD (arr [i], i) dengan menyusun semula array; Kedai maksimum jumlah GCD (arr [i], i) dengan menyusun semula elemen array; Kemas kini res; Kod pemacu", "code": "function findMaxValByRearrArr ( arr , N ) { let res = 0 ; res = parseInt ( ( N * ( N + 1 ) ) / 2 , 10 ) ; return res ; } let arr = [ 3 , 2 , 1 ] ; let N = arr . length ; document . write ( findMaxValByRearrArr ( arr , N ) ) ;"}
{"text": "Poligon dengan sisi maksimum yang boleh ditulis dalam N | Berfungsi untuk mencari poligon maksimum yang boleh ditulis; Kes asas; Kembali n / 2 jika n adalah sebaliknya, kembali - 1; Diberikan n; Panggilan fungsi", "code": "function MaximumSides ( n ) { if ( n < 4 ) return - 1 ; return n % 2 == 0 ? n / 2 : - 1 ; } let N = 8 ; document . write ( MaximumSides ( N ) ) ;"}
{"text": "Purata array yang dihasilkan oleh produk semua pasang array yang diberikan | Fungsi untuk mencari min pasangan array arr []; Memulakan array jumlah akhiran; Membina array Jumlah Akhiran; Saiz pairproductarray; Kedai Jumlah PairProductArray; Simpan min; Cari min PairProductArray; Mengembalikan maksud yang dihasilkan; Diberikan array arr []; Panggilan fungsi", "code": "function pairProductMean ( arr , N ) { var suffixSumArray = Array ( N ) ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ; for ( var i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; } var length = ( N * ( N - 1 ) ) / 2 ; var res = 0 ; for ( var i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; } var mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; } var arr = [ 1 , 2 , 4 , 8 ] ; var N = arr . length ; document . write ( pairProductMean ( arr , N ) . toFixed ( 2 ) ) ;"}
{"text": "Kurangkan kiraan laluan unik dari kiri atas ke kanan bawah matriks dengan meletakkan k 1 s | Berfungsi untuk mengembalikan nilai pekali binomial C (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Berfungsi untuk mencari kiraan minimum laluan dari kiri ke bawah ke bawah kanan dengan meletakkan k 1 s dalam matriks; Mengira cara tanpa 1 s; Mengira laluan dari titik permulaan ke titik pertengahan; Mengira laluan dari titik pertengahan ke titik akhir; Kod pemacu", "code": "function ncr ( n , k ) { var res = 1 ; if ( k > n - k ) k = n - k ; for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } function countPath ( N , M , K ) { var answer ; if ( K >= 2 ) answer = 0 ; else if ( K == 0 ) answer = ncr ( N + M - 2 , N - 1 ) ; else { answer = ncr ( N + M - 2 , N - 1 ) ; var X = ( N - 1 ) / 2 + ( M - 1 ) / 2 ; var Y = ( N - 1 ) / 2 ; var midCount = ncr ( X , Y ) ; X = ( ( N - 1 ) - ( N - 1 ) / 2 ) + ( ( M - 1 ) - ( M - 1 ) / 2 ) ; Y = ( ( N - 1 ) - ( N - 1 ) / 2 ) ; midCount *= ncr ( X , Y ) ; answer -= midCount ; } return answer ; } var N = 3 ; var M = 3 ; var K = 1 ; document . write ( countPath ( N , M , K ) ) ;"}
{"text": "Bilangan maksimum operasi yang diperlukan supaya tiada pasangan dari tumpang tindih matriks | Berfungsi untuk mencari kiraan maksimum operasi; Inisialisasi kiraan oleh 0; Melangkah ke atas pasangan yang tinggal; Semak jika operasi pertama terpakai; Semak jika operasi 2 ND terpakai; Jika tidak; Mengembalikan kiraan operasi; Kod pemacu", "code": "function find_max ( v , n ) { let count = 0 ; if ( n >= 2 ) count = 2 ; else count = 1 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( v [ i - 1 ] [ 0 ] < ( v [ i ] [ 0 ] - v [ i ] [ 1 ] ) ) count ++ ; else if ( v [ i + 1 ] [ 0 ] > ( v [ i ] [ 0 ] + v [ i ] [ 1 ] ) ) { count ++ ; v [ i ] [ 0 ] = v [ i ] [ 0 ] + v [ i ] [ 1 ] ; } else continue ; } return count ; } let n = 3 ; let v = [ [ 10 , 20 ] , [ 15 , 10 ] , [ 20 , 16 ] ] ; document . write ( find_max ( v , n ) ) ;"}
{"text": "Count substrings yang dibentuk menggunakan set aksara yang diberikan sahaja | Fungsi untuk mencari bilangan substring yang boleh dibentuk menggunakan aksara yang diberikan; Array Boolean untuk menyimpan watak -watak yang tersedia; Tandakan indeks semua aksara yang tersedia sebagai 1; Memulakan lastpos sebagai - 1; Inisialisasi ANS dengan jumlah tidak mungkin substrings yang mungkin; Melintasi rentetan dari kiri ke kanan; Jika watak semasa tidak hadir dalam B; Tolak jumlah substrings yang mungkin; Kemas kini nilai LastPOS ke indeks semasa; Cetak jawapan terakhir; Diberikan rentetan; Diberikan pelbagai watak; Panggilan fungsi", "code": "function numberofsubstrings ( str , k , charArray ) { var N = str . length ; var available = [ 26 ] ; for ( var i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - ' ' ] = 1 ; } var lastPos = - 1 ; var ans = ( N * ( N + 1 ) ) / 2 ; for ( var i = 0 ; i < N ; i ++ ) { if ( available [ str . charAt ( i ) - ' ' ] == 0 ) { ans -= ( ( i - lastPos ) * ( N - i ) ) ; lastPos = i ; } } document . write ( ans ) ; } var str = \" \" ; var k = 2 ; var charArray = [ ' ' , ' ' ] ; numberofsubstrings ( str , k , charArray ) ;"}
{"text": "Kos minimum untuk mencapai titik n dari 0 dengan dua operasi yang berbeza dibenarkan | Berfungsi untuk mengembalikan kos minimum untuk mencapai tujuan; Memulakan kos kepada 0; pergi ke belakang sehingga kita mencapai kedudukan awal; Jika 2 * x melompat lebih baik daripada x + 1; Jika lompat x + 1 lebih baik; kos pulangan; Kod pemacu", "code": "function minCost ( N , P , Q ) { var cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { var temp = parseInt ( N / 2 ) ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N = parseInt ( N / 2 ) ; } } return cost ; } var N = 9 , P = 5 , Q = 1 ; document . write ( minCost ( N , P , Q ) ) ;"}
{"text": "Bilangan cara untuk mencapai pada node permulaan selepas perjalanan melalui tepi K dalam graf lengkap | Fungsi untuk mencari bilangan cara untuk mencapai dari nod 1 hingga 1 sekali lagi, selepas bergerak tepat K tepi; Memulakan array dp [], di mana dp [i] menyimpan bilangan cara untuk mencapai nod; Memulakan array DP dengan 0; Kes asas; Berulang untuk bilangan tepi bergerak; Jumlah akan menyimpan beberapa cara untuk mencapai semua nod; Berulang untuk setiap keadaan yang mungkin untuk langkah semasa; Kemas kini nilai array DP selepas perjalanan setiap kelebihan; Prlet DP [0] sebagai jawapannya; Diberikan input; Panggilan fungsi", "code": "function numberOfWays ( n , k ) { let dp = Array ( 1000 ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 1 ; for ( let i = 1 ; i <= k ; i ++ ) { let numWays = 0 ; for ( let j = 0 ; j < n ; j ++ ) { numWays += dp [ j ] ; } for ( let j = 0 ; j < n ; j ++ ) { dp [ j ] = numWays - dp [ j ] ; } } document . write ( dp [ 0 ] ) ; } let N = 5 ; let K = 3 ; numberOfWays ( N , K ) ;"}
{"text": "Kira penyahkodan mungkin urutan digit yang diberikan dengan aksara tersembunyi | Program JavaScript untuk pendekatan di atas; Jika s [i] = = ' *' boleh ada 9 nilai yang mungkin *; Jika watak sebelumnya adalah 1 maka perkataan yang boleh dibentuk adalah k (11), l (12), m (13), n (14) o (15), p (16), q (17), r (18), s (19); Jika watak sebelumnya adalah 2 maka kata -kata yang boleh dibentuk ialah u (21), v (22), w (23), x (24) y (25), z (26); Jika digit sebelumnya * maka semua 15 2 - aksara digit boleh dibentuk; Jika s [i]! = ' *'; Menambah pertama di kedua jika s [i - 1] = 1; Menambah pertama dalam kedua jika s [i - 1] = = 2 dan s [i] <= '6'; jika s [i - 1] == ' *' Kesatuan di atas 2 kes perlu dilakukan; Kod pemacu", "code": "let M = 1000000007 ; function waysOfDecoding ( s ) { let first = 1 , second = s [ 0 ] == ' ' ? 9 : s [ 0 ] == ' ' ? 0 : 1 ; for ( let i = 1 ; i < s . length ; i ++ ) { let temp = second ; if ( s [ i ] == ' ' ) { second = 9 * second ; if ( s [ i - 1 ] == ' ' ) second = ( second + 9 * first ) % M ; else if ( s [ i - 1 ] == ' ' ) second = ( second + 6 * first ) % M ; else if ( s [ i - 1 ] == ' ' ) second = ( second + 15 * first ) % M ; } else { second = s [ i ] != ' ' ? second : 0 ; if ( s [ i - 1 ] == ' ' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == ' ' && s [ i ] <= ' ' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == ' ' ) second = ( second + ( s [ i ] <= ' ' ? 2 : 1 ) * first ) % M ; } first = temp ; } return second ; } let s = \" \" ; document . write ( waysOfDecoding ( s ) ) ;"}
{"text": "Kos minimum membeli sekurang -kurangnya x coklat | Fungsi untuk mengira kos minimum membeli coklat paling kurang x; Kes asas; Sertakan kotak i - th; Kecualikan kotak i - th; Mengembalikan minimum dua kes di atas; Diberikan array dan nilai x; Simpan saiz array; Cetak jawapannya", "code": "function findMinCost ( arr , X , n , i = 0 ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return Number . MAX_SAFE_INTEGER ; let inc = findMinCost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) ; if ( inc != Number . MAX_SAFE_INTEGER ) inc += arr [ i ] [ 1 ] ; let exc = findMinCost ( arr , X , n , i + 1 ) ; return Math . min ( inc , exc ) ; } let arr = [ [ 4 , 3 ] , [ 3 , 2 ] , [ 2 , 4 ] , [ 1 , 3 ] , [ 4 , 2 ] ] ; let X = 7 ; let n = arr . length ; let ans = findMinCost ( arr , X , n ) ; if ( ans != Number . MAX_SAFE_INTEGER ) document . write ( ans ) else document . write ( - 1 )"}
{"text": "Kebarangkalian bahawa jumlah semua nombor yang diperolehi membuang dadu n kali terletak di antara dua bilangan bulat yang diberikan | Fungsi untuk mengira kebarangkalian bagi jumlah yang diberikan untuk menjadi sama dengan jumlah dalam n lontaran dadu; Kes asas; Kod pemacu; Cetak jawapannya", "code": "function find ( N , sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } let s = 0 ; for ( let i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; } let N = 4 , a = 13 , b = 17 ; let probability = 0.0 ; for ( let sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; document . write ( probability . toFixed ( 6 ) ) ;"}
{"text": "Langkah minimum untuk mengurangkan n hingga 0 dengan operasi yang diberikan | Berfungsi untuk mencari nombor minimum ke langkah untuk mengurangkan n hingga 0; Kes asas; Panggilan rekursif untuk mengira langkah minimum yang diperlukan; Kembalikan jawapannya; Diberi nombor n; Panggilan fungsi", "code": "function minDays ( n ) { if ( n < 1 ) return n ; var cnt = 1 + Math . min ( n % 2 + minDays ( parseInt ( n / 2 ) ) , n % 3 + minDays ( parseInt ( n / 3 ) ) ) ; return cnt ; } var N = 6 ; document . write ( minDays ( N ) ) ;"}
