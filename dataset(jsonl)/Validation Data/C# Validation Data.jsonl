{"text": "Program untuk menukar sentimeter ke piksel | C # Program untuk menukar sentimeter ke piksel; Berfungsi untuk menukar sentimeter ke piksel; Kod pemacu", "code": "using System ; class GFG { static double Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; Console . WriteLine ( pixels ) ; return 0 ; } public static void Main ( ) { double centi = 15 ; Conversion ( centi ) ; } }"}
{"text": "Elemen Arus KTH selepas penggantian elemen array oleh xor pasangan bersebelahan | C # Program untuk pendekatan di atas; Kaedah yang mengembalikan output yang sepadan dengan mengambil input yang diberikan. ; Jika keadaan ini berpuas hati, nilai m tidak sah; Semak sama ada indeks k adalah sah; Gelung untuk melaksanakan operasi M; Mewujudkan senarai sementara; Melintasi array; Mengira nilai XOR unsur -unsur bersebelahan; Menambah nilai ini ke senarai sementara; Kemas kini array asal; Mendapatkan nilai pada indeks k; Kod pemacu; Bilangan elemen; Diberikan array [] arr; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int xor_operations ( int N , int [ ] arr , int M , int K ) { if ( M < 0 M >= N ) return - 1 ; if ( K < 0 K >= N - M ) return - 1 ; for ( int p = 0 ; p < M ; p ++ ) { List < int > temp = new List < int > ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . Add ( value ) ; arr [ i ] = temp [ i ] ; } } int ans = arr [ K ] ; return ans ; } public static void Main ( String [ ] args ) { int N = 5 ; int [ ] arr = { 1 , 4 , 5 , 6 , 7 } ; int M = 1 , K = 2 ; Console . Write ( xor_operations ( N , arr , M , K ) ) ; } }"}
{"text": "Semak jika n boleh dibahagikan kepada elemen K berturut -turut dengan jumlah yang sama dengan N | C # Program untuk pendekatan di atas; Fungsi untuk mencari unsur -unsur berturut -turut dengan jumlah yang sama dengan n; Melangkah ke atas [2, inf]; Simpan jumlahnya; Jika jumlah melebihi n maka pecahkan gelung; Perbezaan umum harus dibahagikan dengan bilangan istilah; Cetak nilai i & kembali; Cetak \" - 1\" jika tidak mungkin untuk memecahkan n; Kod pemacu; Diberikan n; Panggilan fungsi", "code": "using System ; class GFG { public static void canBreakN ( long n ) { for ( long i = 2 ; ; i ++ ) { long m = i * ( i + 1 ) / 2 ; if ( m > n ) break ; long k = n - m ; if ( k % i != 0 ) continue ; Console . Write ( i ) ; return ; } Console . Write ( \" - 1\" ) ; } public static void Main ( string [ ] args ) { long N = 12 ; canBreakN ( N ) ; } }"}
{"text": "Pembahagi Coprime nombor | C # Program untuk mencari dua pembahagi coprime nombor tertentu supaya kedua -duanya lebih besar daripada 1; Fungsi yang mendapati sepasang pembahagi n yang diperlukan; Kami melangkah sehingga sqrt (n) kerana kita dapat mencari semua pembahagi n pada masa ini; Jika x adalah pembahagi n terus membahagikan selagi mungkin; Kami telah menemui pasangan yang diperlukan; Tidak ada sepasang pembahagi n yang dijumpai, oleh itu cetak - 1; Kod pemacu; Contoh Contoh 1; Contoh Contoh 2", "code": "using System ; class GFG { public static void findCoprimePair ( int N ) { for ( int x = 2 ; x <= Math . Sqrt ( N ) ; x ++ ) { if ( N % x == 0 ) { while ( N % x == 0 ) { N /= x ; } if ( N > 1 ) { Console . WriteLine ( x + \" ▁ \" + N ) ; return ; } } } Console . WriteLine ( - 1 ) ; } public static void Main ( String [ ] args ) { int N = 45 ; findCoprimePair ( N ) ; N = 25 ; findCoprimePair ( N ) ; } }"}
{"text": "Nombor Sisa | C # Program untuk pendekatan di atas; Array untuk menyimpan semua perdana kurang daripada dan sama dengan max. ; Fungsi untuk penapis Sundaram; Array Boolean; Tandakan semua nombor yang tidak menjana nombor perdana dengan 2 * i + 1; Oleh kerana 2 adalah nombor perdana; Cetak prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Fungsi yang pulih benar jika n adalah nombor yang membazir; Mengira digit dalam nombor asal; Kira semua digit dalam faktor utama N pdigit akan memegang nilai ini. ; Mengira kuasa p dalam n; Jika prima [i] adalah faktor utama ,; Mengira kuasa faktor utama; Tambah digitnya ke PDIGIT; Tambah digit kuasa faktor utama kepada pdigit. ; Jika n! = 1 maka satu faktor utama masih akan disimpulkan; Jika digit dalam faktor utama lebih daripada digit dalam nombor asal maka kembali benar. Lain kembali palsu. ; Berfungsi untuk mencetak nombor yang membazir sebelum n; Melepasi sehingga n dan periksa sama ada saya membazir atau tidak; Kod pemacu; Nombor Perdana Precompute sehingga 10 ^ 6; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int MAX = 10000 ; static List < int > primes = new List < int > ( ) ; static void sieveSundaram ( ) { bool [ ] marked = new bool [ MAX / 2 + 1 ] ; for ( int i = 1 ; i <= ( Math . Sqrt ( MAX ) - 1 ) / 2 ; i ++ ) { for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) { marked [ j ] = true ; } } primes . Add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . Add ( 2 * i + 1 ) ; } static bool isWasteful ( int n ) { if ( n == 1 ) return false ; int original_no = n ; int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = original_no / 10 ; } int pDigit = 0 , count_exp = 0 , p = 0 ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { while ( n % primes [ i ] == 0 ) { p = primes [ i ] ; n = n / p ; count_exp ++ ; } while ( p > 0 ) { pDigit ++ ; p = p / 10 ; } while ( count_exp > 1 ) { pDigit ++ ; count_exp = count_exp / 10 ; } } if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = n / 10 ; } } return ( pDigit > sumDigits ) ; } static void Solve ( int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( isWasteful ( i ) ) { Console . Write ( i + \" ▁ \" ) ; } } } public static void Main ( String [ ] args ) { sieveSundaram ( ) ; int N = 10 ; Solve ( N ) ; } }"}
{"text": "Nombor Hexanacci | C # program rekursif mudah untuk mencetak nombor hexanacci n. ; Berfungsi untuk mencetak nombor hexanacci nth; Kod pemacu", "code": "using System ; class GFG { static int printhexaRec ( int n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 n == 5 ) return 0 ; else if ( n == 6 ) return 1 ; else return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) ; } static void printhexa ( int n ) { Console . Write ( printhexaRec ( n ) + \" STRNEWLINE \" ) ; } public static void Main ( ) { int n = 11 ; printhexa ( n ) ; } }"}
{"text": "Nombor Hexanacci | C # pelaksanaan untuk mencetak istilah nth hexanacci. ; Berfungsi untuk mencetak istilah n nombor hexanacci; Memulakan lima nombor pertama untuk kes asas; Mengisytiharkan pemboleh ubah semasa; Gelung untuk menambah lima nombor sebelumnya untuk setiap nombor bermula dari 5 dan kemudian berikan pertama, kedua, kedua, keempat kelima hingga kedua, ketiga, keempat, kelima dan curr masing -masing; Kod pemacu", "code": "using System ; class GFG { static void printhexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) Console . WriteLine ( first ) ; else if ( n == 6 ) Console . WriteLine ( sixth ) ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } Console . WriteLine ( curr ) ; } public static void Main ( String [ ] args ) { int n = 11 ; printhexa ( n ) ; } }"}
{"text": "Cari nombor terkecil yang jumlah digitnya adalah n | C # Program untuk mencari nombor terkecil yang jumlah digit juga n; Berfungsi untuk mencari nombor terkecil yang jumlah digit juga n; Kod pemacu", "code": "using System ; class GFG { static void smallestNumber ( int N ) { Console . WriteLine ( ( N % 9 + 1 ) * Math . Pow ( 10 , ( N / 9 ) ) - 1 ) ; } public static void Main ( ) { int N = 10 ; smallestNumber ( N ) ; } }"}
{"text": "Kompositori Nombor | C # Program untuk mencari kompositori nombor komposit; Fungsi untuk memeriksa sama ada nombor adalah komposit. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor tengah dalam gelung di bawah; Fungsi ini menyimpan semua nombor komposit kurang daripada n; Fungsi untuk mengira kompositori n; Multiply nombor komposit pertama N; Kod pemacu; Senaraikan untuk menyimpan semua komposit kurang daripada n", "code": "using System ; using System . Collections . Generic ; class GFG { static List < int > compo = new List < int > ( ) ; static bool isComposite ( int n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; int i = 5 ; while ( i * i <= n ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; i = i + 6 ; } return false ; } static void Compositorial_list ( int n ) { int l = 0 ; for ( int i = 4 ; i < 1000000 ; i ++ ) { if ( l < n ) { if ( isComposite ( i ) ) { compo . Add ( i ) ; l += 1 ; } } } } static int calculateCompositorial ( int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result = result * compo [ i ] ; return result ; } public static void Main ( String [ ] args ) { int n = 5 ; Compositorial_list ( n ) ; Console . Write ( ( calculateCompositorial ( n ) ) ) ; } }"}
{"text": "Kuasa yang berbeza dari nombor n supaya jumlahnya sama dengan k | C # Pelaksanaan untuk mengetahui kuasa N yang menambah sehingga K; Memulakan PowerArray dengan semua 0; Fungsi untuk mencari kuasa n yang menambah sehingga k; Memulakan kaunter; Melaksanakan gelung sementara sehingga k lebih besar daripada 0; Jika k % n == 1, maka array kuasa ditingkatkan dengan 1; Memeriksa jika ada kuasa yang berlaku lebih dari sekali; Untuk apa -apa nilai lain, jumlah kuasa tidak boleh ditambah sehingga k; Mencetak kuasa N yang merangkumi K; Kod pemacu", "code": "using System ; class GFG { static int [ ] b = new int [ 50 ] ; static int PowerArray ( int n , int k ) { int count = 0 ; while ( k > 0 ) { if ( k % n == 0 ) { k /= n ; count ++ ; } else if ( k % n == 1 ) { k -= 1 ; b [ count ] ++ ; if ( b [ count ] > 1 ) { Console . Write ( - 1 ) ; return 0 ; } } else { Console . Write ( - 1 ) ; return 0 ; } } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] != 0 ) { Console . Write ( i + \" , ▁ \" ) ; } } return int . MinValue ; } public static void Main ( String [ ] args ) { int N = 3 ; int K = 40 ; PowerArray ( N , K ) ; } }"}
{"text": "Program untuk mencari nilai 1 ^ k + 2 ^ k + 3 ^ k + ... + n ^ k | C # Program untuk mencari nilai 1 ^ K + 2 ^ K + 3 ^ K +. . + N ^ k; Fungsi untuk mencari nilai 1 ^ K + 2 ^ K + 3 ^ K +. . + N ^ k; INISIISE SUM kepada 0; Cari nilai POW (i, 4) dan kemudian tambahkannya ke jumlah; Mengembalikan jumlahnya; Kod pemacu; Fungsi panggilan untuk mencari jumlah", "code": "using System ; public class GFG { static int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) Math . Pow ( i , k ) ; } return sum ; } public static void Main ( string [ ] args ) { int N = 8 , k = 4 ; Console . WriteLine ( findSum ( N , k ) ) ; } }"}
{"text": "Kira indeks dalam array yang memenuhi syarat yang diberikan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan indeks yang memenuhi syarat yang diberikan; Untuk menyimpan hasilnya; Untuk menyimpan maksimum semasa yang dimulakan ke 0 kerana hanya terdapat unsur -unsur positif dalam array; Saya adalah indeks yang sah; Mengemas kini maksimum setakat ini; Kenaikan kaunter; Kod pemacu", "code": "using System ; class GFG { static int countIndices ( int [ ] arr , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . Length ; Console . WriteLine ( countIndices ( arr , n ) ) ; } }"}
{"text": "Kekerapan maksimum modulo 2 i | C # pelaksanaan pendekatan; Perwakilan binari digit; Berfungsi untuk mengembalikan kekerapan maksimum modulo S dengan kuasa 2; Simpan perwakilan binari; Tukar oktal ke binari; Keluarkan LSB; Sekiranya terdapat 1 dalam perwakilan binari; Cari bilangan sifar di antara dua 1 dalam perwakilan binari; Kod pemacu", "code": "using System ; class GFG { static String [ ] bin = { \"000\" , \"001\" , \"010\" , \"011\" , \"100\" , \"101\" , \"110\" , \"111\" } ; static int maxFreq ( String s ) { String binary = \" \" ; for ( int K = 0 ; K < s . Length ; K ++ ) { binary += bin [ s [ K ] - '0' ] ; } binary = binary . Substring ( 0 , binary . Length - 1 ) ; int count = 1 , prev = - 1 , i , j = 0 ; for ( i = binary . Length - 1 ; i >= 0 ; i -- , j ++ ) if ( binary [ i ] == '1' ) { count = Math . Max ( count , j - prev ) ; prev = j ; } return count ; } public static void Main ( String [ ] args ) { String octal = \"13\" ; Console . WriteLine ( maxFreq ( octal ) ) ; } }"}
{"text": "Cari semua nombor utama nombor digit yang diberikan | C # pelaksanaan pendekatan; Fungsi untuk penapis eratosthenes; Berfungsi untuk mencetak semua nombor utama dengan digit D; Julat untuk memeriksa bilangan bulat; Untuk setiap integer dalam julat; Jika integer semasa adalah perdana; Kod pemacu; Menjana prima", "code": "using System ; class GFG { static int sz = 100000 ; static bool [ ] isPrime = new bool [ sz + 1 ] ; static void sieve ( ) { for ( int i = 0 ; i <= sz ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } } static void findPrimesD ( int d ) { int left = ( int ) Math . Pow ( 10 , d - 1 ) ; int right = ( int ) Math . Pow ( 10 , d ) - 1 ; for ( int i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { Console . Write ( i + \" ▁ \" ) ; } } } static public void Main ( ) { sieve ( ) ; int d = 1 ; findPrimesD ( d ) ; } }"}
{"text": "Cari bilangan sel dalam jadual mengandungi x | C # Program untuk mencari bilangan sel dalam jadual mengandungi x; Fungsi untuk mencari bilangan sel dalam jadual mengandungi x; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { public static int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; } static public void Main ( ) { int n = 6 , x = 12 ; Console . WriteLine ( Cells ( n , x ) ) ; } }"}
{"text": "Cari nilai maksimum nilai minimum array yang diubah suai | C # Program untuk mencari nilai maksimum nilai minimum array yang diubah suai; Berfungsi untuk mencari nilai maksimum nilai minimum array yang diubah suai; Untuk menyimpan nilai minimum array; Untuk menyimpan jumlah elemen array; Penyelesaian tidak mungkin; Zero adalah nilai yang mungkin; nilai minimum yang mungkin; nilai maksimum yang mungkin; untuk menyimpan jawapan yang diperlukan; Carian binari; Sekiranya pertengahan mungkin maka cuba tambah jawapan yang diperlukan; Jika pertengahan tidak mungkin maka penurunan jawapan yang diperlukan; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int maxOfMin ( int [ ] a , int n , int S ) { int mi = int . MaxValue ; int s1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = Math . Min ( a [ i ] , mi ) ; } if ( s1 < S ) return - 1 ; if ( s1 == S ) return 0 ; int low = 0 ; int high = mi ; int ans = 0 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } public static void Main ( ) { int [ ] a = { 10 , 10 , 10 , 10 , 10 } ; int S = 10 ; int n = a . Length ; Console . WriteLine ( maxOfMin ( a , n , S ) ) ; } }"}
{"text": "Program untuk mencetak 'n' abjad menggunakan corak nombor dari 1 hingga n | C # pelaksanaan pendekatan; Berfungsi untuk mencetak corak abjad n yang dikehendaki; Mengisytiharkan nilai -nilai hak, kiri dan pepenjuru; Gelung utama untuk baris; Untuk nilai kiri; Ruang untuk pepenjuru; Keadaan untuk pepenjuru; Ruang untuk nilai yang betul; Untuk nilai yang betul; Kod pemacu; Saiz corak; Memanggil fungsi untuk mencetak corak yang dikehendaki", "code": "using System ; class GFG { public static void Alphabet_N_Pattern ( int N ) { int index , side_index ; int Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { Console . Write ( Left ++ ) ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) Console . Write ( \" ▁ \" ) ; if ( index != 0 && index != N - 1 ) Console . Write ( Diagonal ++ ) ; else Console . Write ( \" ▁ \" ) ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) Console . Write ( \" ▁ \" ) ; Console . Write ( Right ++ ) ; Console . Write ( \" STRNEWLINE \" ) ; } } static void Main ( ) { int Size = 6 ; Alphabet_N_Pattern ( Size ) ; } }"}
{"text": "Semak jika jumlah digit nombor n membahagikannya | C # Program untuk memeriksa sama ada jumlah digit nombor membahagikannya; Berfungsi untuk memeriksa sama ada jumlah digit nombor membahagikannya; Hitung jumlah semua digit N; Kod pemacu", "code": "using System ; class GFG { public int isSumDivides ( int N ) { int temp = N , sum = 0 ; while ( temp > 0 ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; } public static void Main ( ) { GFG g = new GFG ( ) ; int N = 12 ; if ( g . isSumDivides ( N ) > 0 ) Console . WriteLine ( \" YES \" ) ; else Console . WriteLine ( \" NO \" ) ; } }"}
{"text": "Jumlah nombor dari 1 hingga N yang boleh dibahagikan dengan 3 atau 4 | C # Program untuk mencari jumlah nombor dari 1 hingga N yang boleh dibahagikan dengan 3 atau 4; Berfungsi untuk mengira jumlah nombor yang boleh dibahagi dengan 3 atau 4; Kod pemacu", "code": "using System ; class GFG { static int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; } public static void Main ( ) { int N = 20 ; Console . WriteLine ( sum ( 12 ) ) ; } }"}
{"text": "Seterusnya nombor yang lebih besar daripada n dengan betul -betul sedikit berbeza dalam perwakilan binari n | C # Program untuk mencari nombor yang lebih besar daripada N dengan betul -betul sedikit berbeza dalam perwakilan binari N; Berfungsi untuk mencari nombor seterusnya yang lebih besar daripada n dengan tepat satu yang berbeza dalam perwakilan binari n; Ia dijamin bahawa terdapat sedikit sifar dalam nombor; Jika bit beralih adalah sifar maka pecah; meningkatkan peralihan sedikit; meningkatkan kuasa 2; Tetapkan bit paling rendah nombor; Kod pemacu; Paparkan nombor seterusnya", "code": "using System ; class GFG { static int nextGreater ( int N ) { int power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; } public static void Main ( ) { int N = 11 ; Console . WriteLine ( \" The ▁ next ▁ number ▁ is ▁ = ▁ \" + nextGreater ( N ) ) ; } }"}
{"text": "Mengira bilangan cara untuk menutup jarak | Tetapkan 2 | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan jumlah cara untuk menutup jarak dengan 1, 2 dan 3 langkah; Keadaan asas; Untuk menyimpan tiga peringkat terakhir; Cari bilangan langkah yang diperlukan untuk mencapai jarak i; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 ; int ans = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; } public static void Main ( String [ ] args ) { int n = 4 ; Console . WriteLine ( countWays ( n ) ) ; } }"}
{"text": "Memaksimumkan jumlah dengan memilih unsur -unsur dari bahagian yang berbeza dari matriks | C # Program untuk pendekatan di atas; Berfungsi untuk mencari nilai maksimum; Jadual DP; Isi DP secara bawah; Maksimum tiga bahagian; Maksimum bahagian pertama; Maksimum bahagian kedua; Maksimum bahagian ketiga; Jika kita memilih elemen dari Bahagian 1, kita tidak boleh mempunyai pemilihan dari bahagian yang sama di baris bersebelahan; Cetak jumlah maksimum; Kod pemacu", "code": "using System ; class GFG { static int n = 6 , m = 6 ; static void maxSum ( long [ , ] arr ) { long [ , ] dp = new long [ n + 1 , 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { long m1 = 0 , m2 = 0 , m3 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( j / ( m / 3 ) ) == 0 ) { m1 = Math . Max ( m1 , arr [ i , j ] ) ; } else if ( ( j / ( m / 3 ) ) == 1 ) { m2 = Math . Max ( m2 , arr [ i , j ] ) ; } else if ( ( j / ( m / 3 ) ) == 2 ) { m3 = Math . Max ( m3 , arr [ i , j ] ) ; } } dp [ i + 1 , 0 ] = Math . Max ( dp [ i , 1 ] , dp [ i , 2 ] ) + m1 ; dp [ i + 1 , 1 ] = Math . Max ( dp [ i , 0 ] , dp [ i , 2 ] ) + m2 ; dp [ i + 1 , 2 ] = Math . Max ( dp [ i , 1 ] , dp [ i , 0 ] ) + m3 ; } Console . Write ( Math . Max ( Math . Max ( dp [ n , 0 ] , dp [ n , 1 ] ) , dp [ n , 2 ] ) + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { long [ , ] arr = { { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } } ; maxSum ( arr ) ; } }"}
{"text": "Jumlah Bilangan Panjang Panjang Panjang Panjang | C # pelaksanaan pendekatan di atas; Berfungsi untuk mencari jumlah sub - urutan panjang palindromik - urutan; Array DP untuk menyimpan bilangan seterusnya Palindromic untuk 0 hingga I - 1 dan J + 1 hingga N - 1; Kami akan bermula dengan jarak terbesar antara i dan j; Untuk setiap len, kami menetapkan saya; Untuk ini saya akan dapati J kami; Kes asas; Jika watak -wataknya sama maka cari indeks terikat; Kami hanya mempunyai 1 cara yang hanya memilih watak -watak ini; Sekiranya watak tidak sama; Kurangkannya kerana kami telah mengira dua kali; Kami hanya mempunyai 1 urutan palindrome panjang 1; Jumlah cara yang lain adalah jumlah DP [i - 1] [i + 1], iaitu bilangan subindrome sub - urutan dari 1 hingga i - 1 + bilangan subindrome sub - urutan dari i + 1 hingga n - 1; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void solve ( char [ ] s ) { int n = s . Length ; int [ , ] dp = new int [ n , n ] ; for ( int len = n - 1 ; len >= 0 ; -- len ) { for ( int i = 0 ; i + len < n ; ++ i ) { int j = i + len ; if ( i == 0 && j == n - 1 ) { if ( s [ i ] == s [ j ] ) dp [ i , j ] = 2 ; else if ( s [ i ] != s [ j ] ) dp [ i , j ] = 1 ; } else { if ( s [ i ] == s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i , j ] += dp [ i - 1 , j ] ; } if ( j + 1 <= n - 1 ) { dp [ i , j ] += dp [ i , j + 1 ] ; } if ( i - 1 < 0 j + 1 >= n ) { dp [ i , j ] += 1 ; } } else if ( s [ i ] != s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i , j ] += dp [ i - 1 , j ] ; } if ( j + 1 <= n - 1 ) { dp [ i , j ] += dp [ i , j + 1 ] ; } if ( i - 1 >= 0 && j + 1 <= n - 1 ) { dp [ i , j ] -= dp [ i - 1 , j + 1 ] ; } } } } } List < int > ways = new List < int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( i == 0 i == n - 1 ) { ways . Add ( 1 ) ; } else { int total = dp [ i - 1 , i + 1 ] ; ways . Add ( total ) ; } } for ( int i = 0 ; i < ways . Capacity ; ++ i ) { Console . Write ( ways [ i ] + \" ▁ \" ) ; } } public static void Main ( ) { char [ ] s = \" xyxyx \" . ToCharArray ( ) ; solve ( s ) ; } }"}
{"text": "Cari bilangan anak ayam di kebun binatang pada hari ke hari | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan anak ayam pada hari ke hari; Saiz DP [] harus sekurang -kurangnya 6 (pengindeksan berasaskan 1 (1); Setiap hari penduduk semasa akan menjadi tiga kali pada hari sebelumnya; Nilai yang dikira secara manual; Dari hari ke -8 dan seterusnya; Penduduk anak ayam berkurangan sebanyak 2/3 setiap hari. Untuk hari ke -8 pada [i - 6] i. Populasi hari ke -2 adalah 3 dan jadi 2 orang baru dilahirkan pada hari ke -6 dan sebagainya untuk hari -hari yang akan datang; Kod pemacu", "code": "using System ; class GFG { static long getChicks ( int n ) { int size = Math . Max ( n , 7 ) ; long [ ] dp = new long [ size ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; } dp [ 6 ] = 726 ; for ( int i = 8 ; i <= n ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] / 3 ) ) * 3 ; } return dp [ n ] ; } static public void Main ( ) { int n = 3 ; Console . WriteLine ( getChicks ( n ) ) ; } }"}
{"text": "Cari bilangan anak ayam di kebun binatang pada hari ke hari | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan anak ayam pada hari ke hari; Kod pemacu", "code": "using System ; class GFG { static int getChicks ( int n ) { int chicks = ( int ) Math . Pow ( 3 , n - 1 ) ; return chicks ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( getChicks ( n ) ) ; } }"}
{"text": "Cari langkah minimum yang diperlukan untuk mencapai akhir matriks | Tetapkan 2 | C # pelaksanaan pendekatan; Array 2d untuk menyimpan negeri -negeri DP; Array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Berfungsi untuk mengembalikan langkah minimum yang diperlukan; Kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula; Hubungan berulang; Kod pemacu", "code": "using System ; class GFG { static int n = 3 ; static int [ , ] dp = new int [ n , n ] ; static int [ , ] v = new int [ n , n ] ; static int minSteps ( int i , int j , int [ , ] arr ) { if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; } if ( v [ i , j ] == 1 ) { return dp [ i , j ] ; } v [ i , j ] = 1 ; dp [ i , j ] = 9999999 ; for ( int k = Math . Max ( 0 , arr [ i , j ] + j - n + 1 ) ; k <= Math . Min ( n - i - 1 , arr [ i , j ] ) ; k ++ ) { dp [ i , j ] = Math . Min ( dp [ i , j ] , minSteps ( i + k , j + arr [ i , j ] - k , arr ) ) ; } dp [ i , j ] ++ ; return dp [ i , j ] ; } static public void Main ( ) { int [ , ] arr = { { 4 , 1 , 2 } , { 1 , 1 , 1 } , { 2 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) { Console . WriteLine ( - 1 ) ; } else { Console . WriteLine ( ans ) ; } } }"}
{"text": "Cari langkah minimum yang diperlukan untuk mencapai akhir matriks | Set | C # Program untuk melaksanakan pendekatan di atas; Array 2d untuk menyimpan negeri -negeri DP; array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Berfungsi untuk mencari bilangan langkah minimum untuk mencapai akhir matriks; kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula. ; hubungan berulang; Kod pemacu", "code": "using System ; class GFG { static int n = 3 ; static int [ , ] dp = new int [ n , n ] ; static int [ , ] v = new int [ n , n ] ; static int minSteps ( int i , int j , int [ , ] arr ) { if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; } if ( v [ i , j ] == 1 ) { return dp [ i , j ] ; } v [ i , j ] = 1 ; dp [ i , j ] = 1 + Math . Min ( minSteps ( i + arr [ i , j ] , j , arr ) , minSteps ( i , j + arr [ i , j ] , arr ) ) ; return dp [ i , j ] ; } static public void Main ( ) { int [ , ] arr = { { 2 , 1 , 2 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) { Console . WriteLine ( - 1 ) ; } else { Console . WriteLine ( ans ) ; } } }"}
{"text": "Treasure and Cities | Program berasaskan memoisasi untuk mencari harta maksimum yang boleh dikumpulkan. ; K ialah indeks semasa dan col adalah warna sebelumnya. ; jika (k == n) kes asas; Semak sama ada warna bandar ini sama dengan bandar yang dilawati sebelum ini; kembali maksimum kedua -dua pilihan; Kod pemacu", "code": "using System ; class GFG { static int MAX = 1001 ; static int [ , ] dp = new int [ MAX , MAX ] ; static int MaxProfit ( int [ ] treasure , int [ ] color , int n , int k , int col , int A , int B ) { return dp [ k , col ] = 0 ; if ( dp [ k , col ] != - 1 ) return dp [ k , col ] ; int sum = 0 ; if ( col == color [ k ] ) sum += Math . Max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . Max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k , col ] = sum ; } public static void Main ( String [ ] args ) { int A = - 5 , B = 7 ; int [ ] treasure = { 4 , 8 , 2 , 9 } ; int [ ] color = { 2 , 2 , 6 , 2 } ; int n = color . Length ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) dp [ i , j ] = - 1 ; Console . Write ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) ; } }"}
{"text": "Nombor Tetranacci | Program C # berasaskan DP untuk mencetak nombor Tetranacci Nth; Berfungsi untuk mencetak nombor tetranacci N - th; kes asas; Kod pemacu", "code": "class GFG { static void printTetra ( int n ) { int [ ] dp = new int [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; System . Console . WriteLine ( dp [ n ] ) ; } static void Main ( ) { int n = 10 ; printTetra ( n ) ; } }"}
{"text": "Jumlah maksimum dalam array bulat supaya tiada dua elemen bersebelahan | C # Program untuk mencari jumlah maksimum dalam array bulat supaya tiada unsur bersebelahan dalam jumlah. ; Fungsi untuk mengira jumlah dari kedudukan ke -0 ke (n - 2) kedudukan; Salin elemen array asal ke dp []; Cari elemen maksimum dalam array; Mulakan dari 2 nd hingga n - 1 th pos; melintasi semua pendekatan berpasangan bawah; DP - keadaan; Cari jumlah maksimum; mengembalikan maksimum; Berfungsi untuk mencari jumlah maksimum dari kedudukan 1 ke kedudukan n - 1 - th; Melintasi dari ketiga ke n - th pos; pendekatan bootom - up; keadaan DP; Cari jumlah maksimum; kembali max; Kod pemacu", "code": "using System ; class GFG { static int maxSum1 ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; int maxi = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( int i = 2 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < dp [ j ] + arr [ i ] ) { dp [ i ] = dp [ j ] + arr [ i ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; } static int maxSum2 ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; int maxi = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( int i = 3 ; i < n ; i ++ ) { for ( int j = 1 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < arr [ i ] + dp [ j ] ) { dp [ i ] = arr [ i ] + dp [ j ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; } static int findMaxSum ( int [ ] arr , int n ) { int t = Math . Max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) ; return t ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 1 } ; int n = arr . Length ; Console . WriteLine ( findMaxSum ( arr , n ) ) ; } }"}
{"text": "Koefisien Permutasi | C # kod untuk penyelesaian berasaskan pengaturcaraan dinamik yang menggunakan Jadual P [] [] untuk mengira pekali permutasi; Pulangan nilai pekali permutasi p (n, k); Hitung nilai pekali permutasi dengan cara bawah; Kes asas; Hitung nilai menggunakan nilai yang disimpan sebelum ini; Langkah ini penting kerana p (i, j) = 0 untuk j> i; Kod pemacu", "code": "using System ; class GFG { static int permutationCoeff ( int n , int k ) { int [ , ] P = new int [ n + 2 , k + 2 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 ) P [ i , j ] = 1 ; else P [ i , j ] = P [ i - 1 , j ] + ( j * P [ i - 1 , j - 1 ] ) ; P [ i , j + 1 ] = 0 ; } } return P [ n , k ] ; } public static void Main ( ) { int n = 10 , k = 2 ; Console . WriteLine ( \" Value ▁ of ▁ P ( ▁ \" + n + \" , \" + k + \" ) \" + \" ▁ is ▁ \" + permutationCoeff ( n , k ) ) ; } }"}
{"text": "Koefisien Permutasi | Penyelesaian O (n) yang menggunakan fakta jadual [] untuk mengira pekali permutasi; Pulangan nilai pekali permutasi p (n, k); Kes asas; Hitung faktorial nilai sehingga n; P (n, k) = n! / (n - k)! ; Kod pemacu", "code": "using System ; public class GFG { static int permutationCoeff ( int n , int k ) { int [ ] fact = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; } static public void Main ( ) { int n = 10 , k = 2 ; Console . WriteLine ( \" Value ▁ of \" + \" ▁ P ( ▁ \" + n + \" , ▁ \" + k + \" ) ▁ is ▁ \" + permutationCoeff ( n , k ) ) ; } }"}
{"text": "Pengaturcaraan Dinamik | Penyelesaian rekursif untuk masalah jumlah subset; Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Kod pemacu", "code": "using System ; class GFG { static bool isSubsetSum ( int [ ] set , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } public static void Main ( ) { int [ ] set = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = set . Length ; if ( isSubsetSum ( set , n , sum ) == true ) Console . WriteLine ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) ; else Console . WriteLine ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) ; } }"}
{"text": "Count of Cyclic Permutations yang mempunyai XOR dengan rentetan binari lain sebagai 0 | C # Program untuk mencari bitwise xor antara rentetan binari a dan semua permutasi kitaran rentetan binari b; Pelaksanaan z - algoritma untuk corak corak masa linear; Berfungsi untuk mendapatkan kiraan permutasi kitaran B yang diberikan 0 apabila xored dengan a; Concatenate B dengan B; BARU B kini mengandungi semua permutasi kitaran Old B sebagai sub-string; corak concatenate dengan teks; Isi arus z yang digunakan dalam algoritma Z; Corak berlaku pada indeks i kerana nilai z sama dengan panjang corak; Kod pemacu", "code": "using System ; class GFG { public static void compute_z ( string s , int [ ] z ) { int l = 0 , r = 0 ; int n = s . Length ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( i > r ) { l = i ; r = i ; while ( r < n && s [ r - l ] == s [ r ] ) { r ++ ; } z [ i ] = r - l ; r -- ; } else { int k = i - l ; if ( z [ k ] < r - i + 1 ) { z [ i ] = z [ k ] ; } else { l = i ; while ( r < n && s [ r - l ] == s [ r ] ) { r ++ ; } z [ i ] = r - l ; r -- ; } } } } public static int countPermutation ( string a , string b ) { b = b + b ; b = b . Substring ( 0 , b . Length - 1 ) ; int ans = 0 ; string s = a + \" $ \" + b ; int n = s . Length ; int [ ] z = new int [ n ] ; compute_z ( s , z ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( z [ i ] == a . Length ) { ans ++ ; } } return ans ; } public static void Main ( string [ ] args ) { string a = \"101\" ; string b = \"101\" ; Console . WriteLine ( countPermutation ( a , b ) ) ; } }"}
{"text": "Lexicographically terkecil k | C # Program untuk pendekatan di atas; Berfungsi untuk mencari saiz ksatria terkecil secara lexicographically K; Panjang rentetan; Menyimpan berikutnya minimum; Melintasi rentetan s; Sekiranya timbunan kosong; Melangkah sehingga watak semasa kurang daripada watak di bahagian atas timbunan; Semak jika terdapat watak yang cukup untuk mendapatkan panjang k; Jika saiz timbunan adalah <k; Tolak watak semasa ke dalamnya; Menyimpan rentetan yang dihasilkan; Berulang sehingga timbunan kosong; Membalikkan rentetan; Cetak rentetan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; public class GFG { static void smallestSubsequence ( char [ ] S , int K ) { int N = S . Length ; Stack < char > answer = new Stack < char > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( answer . Count == 0 ) { answer . Push ( S [ i ] ) ; } else { while ( ( answer . Count != 0 ) && ( S [ i ] < answer . Peek ( ) ) && ( answer . Count - 1 + N - i >= K ) ) { answer . Pop ( ) ; } if ( answer . Count == 0 answer . Count < K ) { answer . Push ( S [ i ] ) ; } } } String ret = \" \" ; while ( answer . Count != 0 ) { ret += ( answer . Peek ( ) ) ; answer . Pop ( ) ; } ret = reverse ( ret ) ; Console . Write ( ret ) ; } static String reverse ( String input ) { char [ ] a = input . ToCharArray ( ) ; int l , r = a . Length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . Join ( \" \" , a ) ; } public static void Main ( String [ ] args ) { String S = \" aabdaabc \" ; int K = 3 ; smallestSubsequence ( S . ToCharArray ( ) , K ) ; } }"}
{"text": "Semak sama ada rentetan betul ke kiri pepenjuru atau tidak | C # Program untuk memeriksa sama ada rentetan yang diberikan adalah betul untuk kiri pepenjuru atau tidak; Fungsi untuk memeriksa sama ada rentetan yang diberikan adalah betul untuk kiri pepenjuru atau tidak; Melangkah ke atas rentetan; Jika watak tidak sama dengan watak pertama maka kembali palsu; Kod pemacu; Diberikan string str; Panggilan fungsi", "code": "using System ; class GFG { public static bool is_rtol ( String s ) { int tmp = ( int ) ( Math . Sqrt ( s . Length ) ) - 1 ; char first = s [ tmp ] ; for ( int pos = tmp ; pos < s . Length - 1 ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } } return true ; } public static void Main ( String [ ] args ) { String str = \" abcxabxcaxbcxabc \" ; if ( is_rtol ( str ) ) { Console . Write ( \" Yes \" ) ; } else { Console . Write ( \" No \" ) ; } } }"}
{"text": "Pecahkan rentetan yang diberikan ke dalam substrings panjang k dengan jumlah nilai ASCII yang sama | C # Program untuk memeriksa sama ada rentetan yang diberikan boleh dibahagikan kepada substring saiz K yang mempunyai jumlah nilai ASCII yang sama. ; Fungsi untuk memeriksa rentetan; Semak sama ada rentetan boleh dibahagikan kepada substrings panjang K panjang sahaja; Kirakan jumlah substring pertama panjang k; Kirakan jumlah substrings yang tinggal; Semak sama ada jumlahnya sama dengan substring pertama; Oleh kerana semua jumlah tidak sama, kembali palsu; Semua jumlah adalah sama, kembali benar; Semua substrings tidak boleh bersaiz k; Kod pemacu", "code": "using System ; class GFG { static bool check ( string str , int K ) { if ( str . Length % K == 0 ) { int sum = 0 , i ; for ( i = 0 ; i < K ; i ++ ) { sum += str [ i ] ; } for ( int j = i ; j < str . Length ; j += K ) { int s_comp = 0 ; for ( int p = j ; p < j + K ; p ++ ) s_comp += str [ p ] ; if ( s_comp != sum ) return false ; } return true ; } return false ; } public static void Main ( string [ ] args ) { int K = 3 ; string str = \" abdcbbdba \" ; if ( check ( str , K ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Memaksimumkan kiraan 0 s di kiri dan 1 s dalam substring kanan dengan memisahkan rentetan binari yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk memaksimumkan jumlah kiraan sifar dan yang di dalam substring kiri dan kanan; Untuk menyimpan jumlahnya; Kira jumlah yang ada dalam string str; Untuk menyimpan kiraan sifar dan yang melintasi rentetan; Melepasi rentetan yang diberikan dan kemas kini jumlah maksimum; Mengemas kini jumlah maksimum; Kod pemacu; Diberikan rentetan binari; Panggilan fungsi", "code": "using System ; class GFG { static int maxSum ( string str ) { int maximumSum = 0 ; int totalOnes = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '1' ) { totalOnes ++ ; } } int zero = 0 , ones = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '0' ) { zero ++ ; } else { ones ++ ; } maximumSum = Math . Max ( maximumSum , zero + ( totalOnes - ones ) ) ; } return maximumSum ; } public static void Main ( string [ ] args ) { string str = \"011101\" ; Console . Write ( maxSum ( str ) ) ; } }"}
{"text": "Substring terpanjang supaya tidak ada tiga aksara berturut -turut yang sama | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan panjang substring terpanjang sehingga tiada tiga aksara berturut -turut adalah sama; Jika panjang rentetan yang diberikan kurang daripada 3; Inisialisasi ANS sementara dan akhir hingga 2 kerana ini adalah panjang minimum substring apabila panjang rentetan yang diberikan lebih besar daripada 2; Melintasi rentetan dari watak ketiga ke yang terakhir; Jika tiada tiga aksara berturut -turut adalah sama maka kenaikan sementara sementara; Lain mengemas kini Ans akhir dan menetapkan semula kiraan sementara; Kod pemacu", "code": "using System ; class GFG { static int maxLenSubStr ( String s ) { if ( s . Length < 3 ) return s . Length ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . Length ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = Math . Max ( temp , ans ) ; temp = 2 ; } } ans = Math . Max ( temp , ans ) ; return ans ; } static public void Main ( ) { String s = \" baaabbabbb \" ; Console . Write ( maxLenSubStr ( s ) ) ; } }"}
{"text": "Bilangan cara untuk mengeluarkan sub | C # Program untuk mengira bilangan cara mengeluarkan substring dari rentetan supaya semua watak yang tinggal adalah sama; Fungsi untuk mengembalikan bilangan cara mengeluarkan sub -rentetan dari S sedemikian rupa sehingga semua aksara yang tinggal adalah sama; Untuk menyimpan kiraan awalan dan akhiran; Gelung untuk mengira awalan; Gelung untuk mengira akhiran; Watak pertama dan terakhir rentetan adalah sama; Jika tidak; Kod pemacu", "code": "using System ; class GFG { static int no_of_ways ( string s ) { int n = s . Length ; int count_left = 0 , count_right = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == s [ 0 ] ) { ++ count_left ; } else break ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == s [ n - 1 ] ) { ++ count_right ; } else break ; } if ( s [ 0 ] == s [ n - 1 ] ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; } public static void Main ( ) { string s = \" geeksforgeeks \" ; Console . WriteLine ( no_of_ways ( s ) ) ; } }"}
{"text": "Kira bilangan indeks seperti S [i] = s [i + 1]: pertanyaan pelbagai | C # Program untuk mencari substring dengan; Fungsi untuk membuat array awalan; Berfungsi untuk mengembalikan hasil pertanyaan; Kod pemacu; Pertanyaan 1; Pertanyaan 2", "code": "using System ; class GFG { static void preCompute ( int n , string s , int [ ] pref ) { pref [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { pref [ i ] = pref [ i - 1 ] ; if ( s [ i - 1 ] == s [ i ] ) pref [ i ] ++ ; } } static int query ( int [ ] pref , int l , int r ) { return pref [ r ] - pref [ l ] ; } public static void Main ( ) { string s = \" ggggggg \" ; int n = s . Length ; int [ ] pref = new int [ n ] ; preCompute ( n , s , pref ) ; int l = 1 ; int r = 2 ; Console . WriteLine ( query ( pref , l , r ) ) ; l = 1 ; r = 5 ; Console . WriteLine ( query ( pref , l , r ) ) ; } }"}
{"text": "Cari arah dari rentetan yang diberikan | C # pelaksanaan pendekatan di atas; Berfungsi untuk mencari arah akhir; Sekiranya kiraan positif yang membayangkan hasilnya adalah arah arah jam; Sekiranya kiraan negatif yang membayangkan hasilnya adalah arah anti jam; Kod pemacu", "code": "using System ; class GFG { static String findDirection ( String s ) { int count = 0 ; String d = \" \" ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ 0 ] == ' STRNEWLINE ' ) return null ; if ( s [ i ] == ' L ' ) count -- ; else { if ( s [ i ] == ' R ' ) count ++ ; } } if ( count > 0 ) { if ( count % 4 == 0 ) d = \" N \" ; else if ( count % 4 == 1 ) d = \" E \" ; else if ( count % 4 == 2 ) d = \" S \" ; else if ( count % 4 == 3 ) d = \" W \" ; } if ( count < 0 ) { if ( count % 4 == 0 ) d = \" N \" ; else if ( count % 4 == - 1 ) d = \" W \" ; else if ( count % 4 == - 2 ) d = \" S \" ; else if ( count % 4 == - 3 ) d = \" E \" ; } return d ; } public static void Main ( ) { String s = \" LLRLRRL \" ; Console . WriteLine ( findDirection ( s ) ) ; s = \" LL \" ; Console . WriteLine ( findDirection ( s ) ) ; } }"}
{"text": "Semak jika huruf kecil dan huruf besar berada dalam susunan yang sama | C # Program untuk memeriksa sama ada huruf kecil dan huruf besar berada dalam urutan yang sama; Fungsi untuk memeriksa sama ada kes itu mengikuti perintah yang sama; Melintasi rentetan; Simpan kedua -dua huruf kecil dan huruf besar dalam dua rentetan yang berbeza; transformasi lowerstr1 ke atas; Kod pemacu", "code": "using System ; class GFG { static bool isCheck ( string str ) { int len = str . Length ; string lowerStr = \" \" , upperStr = \" \" ; char [ ] str1 = str . ToCharArray ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ( int ) ( str1 [ i ] ) >= 65 && ( int ) str1 [ i ] <= 91 ) upperStr = upperStr + str1 [ i ] ; else lowerStr = lowerStr + str1 [ i ] ; } String transformStr = lowerStr . ToUpper ( ) ; return ( transformStr . Equals ( upperStr ) ) ; } public static void Main ( String [ ] args ) { String str = \" geeGkEEsKS \" ; if ( isCheck ( str ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Gantikan setiap watak rentetan oleh watak yang nilai ASCII adalah k kali lebih daripada itu | C # Program untuk memindahkan setiap watak K kali ke hadapan dalam rentetan yang diberikan; Berfungsi untuk memindahkan watak rentetan; rentetan berubah; berulang untuk setiap aksara; Nilai ASCII; Simpan pendua; jika k - th ke depan watak melebihi 'z'; Cetak rentetan baru; Kod pemacu; panggilan fungsi", "code": "using System ; public class GFG { static void encode ( String s , int k ) { String newS = \" \" ; for ( int i = 0 ; i < s . Length ; ++ i ) { int val = s [ i ] ; int dup = k ; if ( val + k > 122 ) { k -= ( 122 - val ) ; k = k % 26 ; newS += ( char ) ( 96 + k ) ; } else { newS += ( char ) ( 96 + k ) ; } k = dup ; } Console . Write ( newS ) ; } public static void Main ( ) { String str = \" abc \" ; int k = 28 ; encode ( str , k ) ; } }"}
{"text": "Ubah suai rentetan dengan mengeluarkan vokal di antara dua konsonan | C # Program untuk mengeluarkan semua vokal di antara dua konsonan dari rentetan; Fungsi untuk memeriksa sama ada watak x adalah vokal atau tidak; Mengembalikan rentetan yang dikemas kini yang dibentuk selepas mengeluarkan semua vokal sandwich dari rentetan yang diberikan; rentetan untuk menyimpan rentetan yang dikemas kini selepas mengeluarkan vokal yang diapit; melintasi rentetan dari kiri ke kanan; Sekiranya watak semasa adalah watak pertama atau terakhir rentetan itu, ini perlu dilampirkan kepada yang dikemas kini, kerana abjad sudut tanpa mengira ia menjadi vokal atau konsonan, tidak pernah 'diapit'; Semak sama ada watak semasa rentetan adalah vokal dan kedua -dua watak -watak terdahulu dan seterusnya adalah konsonan, jika demikian maka ini adalah vokal yang diapit, dengan itu diabaikan dan tidak dilampirkan pada rentetan yang dikemas kini; Jika watak ini bukan vokal yang diapit masuk ke rentetan yang dikemas kini; Kod pemacu; Keluarkan semua vokal sandwitched", "code": "using System ; class GFG { static bool isVowel ( char x ) { if ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) return true ; else return false ; } static String updateSandwichedVowels ( String a ) { int n = a . Length ; String updatedString = \" \" ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 i == n - 1 ) { updatedString += a [ i ] ; continue ; } if ( ( isVowel ( a [ i ] ) ) == true && isVowel ( a [ i - 1 ] ) == false && isVowel ( a [ i + 1 ] ) == false ) { continue ; } updatedString += a [ i ] ; } return updatedString ; } public static void Main ( ) { String str = \" geeksforgeeks \" ; String updatedString = updateSandwichedVowels ( str ) ; Console . WriteLine ( updatedString ) ; }"}
{"text": "Cetak semua laluan pokok binari dengan elemen maksimum dalam setiap laluan yang lebih besar daripada atau sama dengan k | C # Program untuk mencetak laluan dengan elemen maksimum di jalan yang lebih besar daripada k; Nod pokok binari; Fungsi utiliti untuk membuat nod baru; Fungsi rekursif untuk mencetak laluan yang elemen maksimumnya lebih besar daripada atau sama dengan k. ; Jika nilai nod semasa lebih besar daripada atau sama dengan k, maka semua subtrees berikutan nod tersebut akan dicetak, bendera = 1 menunjukkan untuk mencetak jalan yang diperlukan; Jika nod daun ditemui, maka jalan dicetak jika saiz vektor laluan lebih besar daripada 0; Tambah nod ke vektor jalan; Mengulangi subtrees kiri dan kanan; Backtracking untuk mengembalikan vektor dan mencetak jalan jika bendera adalah 1; Fungsi untuk memulakan pembolehubah dan panggil fungsi utiliti untuk mencetak laluan dengan nilai maksimum lebih besar daripada atau sama dengan k; Memulakan bendera; Ans digunakan untuk memeriksa keadaan kosong; Fungsi panggilan yang mencetak jalan; Sekiranya jalan tidak wujud; Kod pemacu; Membina pokok berikut: 10 / \\ 5 8 / \\ / \\ 29 2 1 98 / \\ 20 50", "code": "using System ; using System . Collections . Generic ; class GFG { class Node { public int data ; public Node left , right ; } ; static int ans ; static Node newNode ( int data ) { Node newNode = new Node ( ) ; newNode . data = data ; newNode . left = newNode . right = null ; return ( newNode ) ; } static void findPathUtil ( Node root , int k , List < int > path , int flag ) { if ( root == null ) return ; if ( root . data >= k ) flag = 1 ; if ( root . left == null && root . right == null ) { if ( flag == 1 ) { ans = 1 ; Console . Write ( \" ( \" ) ; for ( int i = 0 ; i < path . Count ; i ++ ) { Console . Write ( path [ i ] + \" , ▁ \" ) ; } Console . Write ( root . data + \" ) , ▁ \" ) ; } return ; } path . Add ( root . data ) ; findPathUtil ( root . left , k , path , flag ) ; findPathUtil ( root . right , k , path , flag ) ; path . RemoveAt ( path . Count - 1 ) ; } static void findPath ( Node root , int k ) { int flag = 0 ; ans = 0 ; List < int > v = new List < int > ( ) ; findPathUtil ( root , k , v , flag ) ; if ( ans == 0 ) Console . Write ( \" - 1\" ) ; } public static void Main ( String [ ] args ) { int K = 25 ; Node root = newNode ( 10 ) ; root . left = newNode ( 5 ) ; root . right = newNode ( 8 ) ; root . left . left = newNode ( 29 ) ; root . left . right = newNode ( 2 ) ; root . right . right = newNode ( 98 ) ; root . right . left = newNode ( 1 ) ; root . right . right . right = newNode ( 50 ) ; root . left . left . left = newNode ( 20 ) ; findPath ( root , K ) ; } }"}
{"text": "Nombor TrideCagonal | C # Program untuk mencari nombor tridecagonal N; Berfungsi untuk mencari nombor tridecagonal n; Formula untuk mengira nombor tridecagonal nth; Kod pemacu", "code": "using System ; class GFG { static int Tridecagonal_num ( int n ) { return ( 11 * n * n - 9 * n ) / 2 ; } public static void Main ( String [ ] args ) { int n = 3 ; Console . Write ( Tridecagonal_num ( n ) + \" STRNEWLINE \" ) ; n = 10 ; Console . Write ( Tridecagonal_num ( n ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Semak jika pokok binari yang diberikan adalah timbunan | C # Program untuk memeriksa jika pokok binari adalah timbunan maksimum atau tidak; Struktur nod pokok; Untuk menambah nod baru; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; public class GFG { public class Node { public int data ; public Node left ; public Node right ; } ; static Node newNode ( int k ) { Node node = new Node ( ) ; node . data = k ; node . right = node . left = null ; return node ; } static bool isHeap ( Node root ) { Queue < Node > q = new Queue < Node > ( ) ; q . Enqueue ( root ) ; bool nullish = false ; while ( q . Count != 0 ) { Node temp = q . Peek ( ) ; q . Dequeue ( ) ; if ( temp . left != null ) { if ( nullish temp . left . data >= temp . data ) { return false ; } q . Enqueue ( temp . left ) ; } else { nullish = true ; } if ( temp . right != null ) { if ( nullish temp . right . data >= temp . data ) { return false ; } q . Enqueue ( temp . right ) ; } else { nullish = true ; } } return true ; } public static void Main ( String [ ] args ) { Node root = null ; root = newNode ( 10 ) ; root . left = newNode ( 9 ) ; root . right = newNode ( 8 ) ; root . left . left = newNode ( 7 ) ; root . left . right = newNode ( 6 ) ; root . right . left = newNode ( 5 ) ; root . right . right = newNode ( 4 ) ; root . left . left . left = newNode ( 3 ) ; root . left . left . right = newNode ( 2 ) ; root . left . right . left = newNode ( 1 ) ; if ( isHeap ( root ) ) Console . Write ( \" Given ▁ binary ▁ tree ▁ is ▁ a ▁ Heap STRNEWLINE \" ) ; else Console . Write ( \" Given ▁ binary ▁ tree ▁ is ▁ not ▁ a ▁ Heap STRNEWLINE \" ) ; } }"}
{"text": "Bilangan bilangan bulat n digit dengan berat w | C # Program untuk mencari jumlah nombor yang mungkin dengan N digit dan berat w; Berfungsi untuk mencari jumlah nombor yang mungkin dengan digit dan berat w; Apabila berat integer positif; Tolak berat dari 9; Apabila berat integer adalah negatif; Tambah berat badan kepada 10 untuk menjadikannya positif; Kod pemacu; bilangan digit dalam integer dan w sebagai berat; Cetak jumlah nombor yang mungkin dengan N digit dan berat w", "code": "using System ; class GFG { static int findNumbers ( int n , int w ) { int x = 0 , sum = 0 ; if ( w >= 0 && w <= 8 ) { x = 9 - w ; } else if ( w >= - 9 && w <= - 1 ) { x = 10 + w ; } sum = ( int ) Math . Pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; } static public void Main ( ) { int n , w ; n = 3 ; w = 4 ; Console . WriteLine ( findNumbers ( n , w ) ) ; } }"}
{"text": "Ketinggian maksimum susunan segi tiga nilai array | C # Program untuk mencari ketinggian maksimum susunan piramida nilai array; Hanya memeriksa sama ada tahap ith mungkin atau tidak jika mungkin maka kita mesti mempunyai atleast (i * (i + 1)) / 2 elemen dalam array; mengemas kini nilai hasil setiap kali; Jika tidak, kita telah melebihi nilai n; Kod pemacu", "code": "using System ; class GFG { static int MaximumHeight ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; } static public void Main ( ) { int [ ] arr = { 40 , 100 , 20 , 30 } ; int n = arr . Length ; Console . WriteLine ( MaximumHeight ( arr , n ) ) ; } }"}
{"text": "K | C # Program untuk mencari elemen k - Th dalam urutan ganjil - walaupun. ; Masukkan semua nombor ganjil dari 1 hingga n. ; Masukkan semua nombor dari 1 hingga n. ; Kod pemacu", "code": "using System ; using System . Collections ; class GFG { static int findK ( int n , int k ) { ArrayList a = new ArrayList ( n ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . Add ( i ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . Add ( i ) ; return ( int ) ( a [ k - 1 ] ) ; } static void Main ( ) { int n = 10 , k = 3 ; Console . WriteLine ( findK ( n , k ) ) ; } }"}
{"text": "Satu fungsi baris untuk faktorial nombor | C # Program untuk mencari faktorial nombor yang diberikan; Fungsi untuk mengira faktorial; Baris tunggal untuk mencari faktorial", "code": "using System ; class GFG { static int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } public static void Main ( ) { int num = 5 ; Console . WriteLine ( \" Factorial ▁ of ▁ \" + num + \" ▁ is ▁ \" + factorial ( num ) ) ; } }"}
{"text": "Nombor Pell | Siri nombor Pell Iterative di C #; Hitung nombor pell; Fungsi pemacu", "code": "using System ; class PellNumber { public static int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c ; for ( int i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; } public static void Main ( ) { int n = 4 ; Console . Write ( pell ( n ) ) ; } }"}
{"text": "Cara yang cekap untuk memeriksa sama ada N | Program C # mudah untuk memeriksa sama ada nombor Fibonacci N - Th adalah pelbagai daripada 10 .; Pulangan benar jika nombor fibonacci n - th adalah berganda dari 10 .; fungsi utama", "code": "using System ; class GFG { static bool isMultipleOf10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; } public static void Main ( ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Cari kesopanan nombor | C # Program untuk mencari kesopanan nombor. ; Fungsi untuk mengira semua faktor utama ganjil nombor n; Menghapuskan semua faktor utama bilangan n; n mesti ganjil pada ketika ini, jadi berulang hanya untuk nombor ganjil sehingga sqrt (n); Jika saya membahagikan N, maka mula mengira pembahagi ganjil; Jika n yang ganjil masih kekal maka hitungnya; Kod pemacu", "code": "using System ; public class GFG { static int countOddPrimeFactors ( int n ) { int result = 1 ; while ( n % 2 == 0 ) n /= 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { int divCount = 0 ; while ( n % i == 0 ) { n /= i ; ++ divCount ; } result *= divCount + 1 ; } if ( n > 2 ) result *= 2 ; return result ; } static int politness ( int n ) { return countOddPrimeFactors ( n ) - 1 ; } public static void Main ( ) { int n = 90 ; Console . WriteLine ( \" Politness ▁ of ▁ \" + n + \" ▁ = ▁ \" + politness ( n ) ) ; n = 15 ; Console . WriteLine ( \" Politness ▁ of ▁ \" + n + \" ▁ = ▁ \" + politness ( n ) ) ; } }"}
{"text": "Perdana terdekat yang kurang daripada bilangan N | C # Program untuk mencari perdana terdekat kepada n. ; array untuk menyimpan semua prima kurang daripada 10 ^ 6; Fungsi utiliti penapis Sundaram; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x; Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j; menghapuskan indeks yang tidak menghasilkan prima; Oleh kerana 2 adalah nombor perdana; Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Carian binari yang diubah suai untuk mencari perdana terdekat kurang daripada n; Keadaan asas adalah, jika kita sampai di sudut kiri atau sudut kanan prima [] array kemudian kembali elemen sudut kerana sebelum atau selepas itu kita tidak mempunyai sebarang nombor utama dalam array prima; Sekarang jika N sendiri menjadi perdana jadi ia akan hadir dalam pelbagai prima dan di sini kita perlu mencari perdana terdekat yang kurang daripada n supaya kita akan mengembalikan prima [pertengahan - 1]; Sekarang jika prima [pertengahan] <n dan prima [pertengahan + 1]> n Itu bermakna kita sampai pada perdana terdekat; Kod pemacu", "code": "using System ; using System . Collections ; class GFG { static int MAX = 1000000 ; static ArrayList primes = new ArrayList ( ) ; static void Sieve ( ) { int n = MAX ; int nNew = ( int ) Math . Sqrt ( n ) ; int [ ] marked = new int [ n / 2 + 500 ] ; for ( int i = 1 ; i <= ( nNew - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= n / 2 ; j = j + 2 * i + 1 ) marked [ j ] = 1 ; primes . Add ( 2 ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( marked [ i ] == 0 ) primes . Add ( 2 * i + 1 ) ; } static int binarySearch ( int left , int right , int n ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( mid == 0 mid == primes . Count - 1 ) return ( int ) primes [ mid ] ; if ( ( int ) primes [ mid ] == n ) return ( int ) primes [ mid - 1 ] ; if ( ( int ) primes [ mid ] < n && ( int ) primes [ mid + 1 ] > n ) return ( int ) primes [ mid ] ; if ( n < ( int ) primes [ mid ] ) return binarySearch ( left , mid - 1 , n ) ; else return binarySearch ( mid + 1 , right , n ) ; } return 0 ; } static void Main ( ) { Sieve ( ) ; int n = 17 ; Console . WriteLine ( binarySearch ( 0 , primes . Count - 1 , n ) ) ; } }"}
{"text": "Program untuk faktorial nombor | C # Program untuk mencari faktorial nombor yang diberikan; kaedah untuk mencari faktorial nombor yang diberikan; Kaedah Pemandu", "code": "using System ; class Test { static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } public static void Main ( ) { int num = 5 ; Console . WriteLine ( \" Factorial ▁ of ▁ \" + num + \" ▁ is ▁ \" + factorial ( 5 ) ) ; } }"}
{"text": "Matikan Bit Set Bit | Tetapkan 2 | C # Program untuk menyegarkan bit set paling kanan; Tidak menetapkan bit set yang paling kanan dan mengembalikan hasilnya; Kod pemacu", "code": "using System ; class GFG { static int FlipBits ( int n ) { return n -= ( n & ( - n ) ) ; } public static void Main ( String [ ] args ) { int N = 12 ; Console . Write ( \" The ▁ number ▁ after \" + \" unsetting ▁ the ▁ \" ) ; Console . Write ( \" rightmost ▁ set ▁ bit : ▁ \" + FlipBits ( N ) ) ; } }"}
{"text": "Nilai maksimum XOR di antara semua tiga kali ganda array | C # pelaksanaan pendekatan; berfungsi untuk mengira nilai XOR maksimum untuk triplet; Set digunakan untuk mengelakkan pengulangan; Simpan semua kemungkinan nilai XOR yang unik; menyimpan nilai maksimum; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void Maximum_xor_Triplet ( int n , int [ ] a ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { s . Add ( a [ i ] ^ a [ j ] ) ; } } int ans = 0 ; foreach ( int i in s ) { for ( int j = 0 ; j < n ; j ++ ) { ans = Math . Max ( ans , i ^ a [ j ] ) ; } } Console . WriteLine ( ans ) ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 3 , 8 , 15 } ; int n = a . Length ; Maximum_xor_Triplet ( n , a ) ; } }"}
{"text": "Cari unsur -unsur yang hilang dari julat | Program Java berasaskan penyortiran untuk mencari unsur -unsur yang hilang dari array; Cetak semua elemen julat [rendah, tinggi] yang tidak hadir dalam arr [0 .. n - 1]; Lakukan pencarian binari untuk 'rendah' ​​dalam array yang disusun dan cari indeks elemen pertama yang sama sama dengan atau lebih besar daripada rendah. ; Mulakan dari indeks yang dijumpai dan cari secara linear setiap elemen julat x selepas indeks ini di arr []; Jika x tidak matematik dengan elemen semasa mencetaknya; Jika x sepadan, pindah ke elemen seterusnya dalam arr []; Bergerak ke elemen seterusnya dalam julat [rendah, tinggi]; Elemen pelbagai cetak thar lebih besar daripada elemen terakhir array yang disusun. ; Fungsi utiliti untuk mencari indeks ceil elemen yang diberikan; Kod pemacu", "code": "using System ; class GFG { static void printMissing ( int [ ] ar , int low , int high ) { Array . Sort ( ar ) ; int index = ceilindex ( ar , low , 0 , ar . Length - 1 ) ; int x = low ; while ( index < ar . Length && x <= high ) { if ( ar [ index ] != x ) { Console . Write ( x + \" ▁ \" ) ; } else index ++ ; x ++ ; } while ( x <= high ) { Console . Write ( x + \" ▁ \" ) ; x ++ ; } } static int ceilindex ( int [ ] ar , int val , int low , int high ) { if ( val < ar [ 0 ] ) return 0 ; if ( val > ar [ ar . Length - 1 ] ) return ar . Length ; int mid = ( low + high ) / 2 ; if ( ar [ mid ] == val ) return mid ; if ( ar [ mid ] < val ) { if ( mid + 1 < high && ar [ mid + 1 ] >= val ) return mid + 1 ; return ceilindex ( ar , val , mid + 1 , high ) ; } else { if ( mid - 1 >= low && ar [ mid - 1 ] < val ) return mid ; return ceilindex ( ar , val , low , mid - 1 ) ; } } static public void Main ( ) { int [ ] arr = { 1 , 3 , 5 , 4 } ; int low = 1 , high = 10 ; printMissing ( arr , low , high ) ; } }"}
{"text": "Cari unsur -unsur yang hilang dari julat | Program C # berasaskan array untuk mencari elemen yang hilang dari array; Cetak semua elemen julat [rendah, tinggi] yang tidak hadir dalam arr [0 .. n - 1]; Buat pelbagai boolean saiz tinggi - rendah + 1, setiap indeks yang saya mewakili elemen (i + rendah) yang dijumpai atau tidak. ; Sekiranya elemen ARR berada dalam jarak rendah hingga tinggi maka tandakan indeks yang sepadan sebagai benar dalam array; Melintasi julat dan mencetak semua elemen yang nilainya palsu; Kod pemacu", "code": "using System ; class GFG { static void printMissing ( int [ ] arr , int n , int low , int high ) { bool [ ] points_of_range = new bool [ high - low + 1 ] ; for ( int i = 0 ; i < high - low + 1 ; i ++ ) points_of_range [ i ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( low <= arr [ i ] && arr [ i ] <= high ) points_of_range [ arr [ i ] - low ] = true ; } for ( int x = 0 ; x <= high - low ; x ++ ) { if ( points_of_range [ x ] == false ) Console . Write ( \" { 0 } ▁ \" , low + x ) ; } } public static void Main ( ) { int [ ] arr = { 1 , 3 , 5 , 4 } ; int n = arr . Length ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; } }"}
{"text": "Cari unsur -unsur yang hilang dari julat | Program C # berasaskan hashing untuk mencari unsur -unsur yang hilang dari array; Cetak semua elemen julat [rendah, tinggi] yang tidak hadir dalam arr [0 .. n - 1]; Masukkan semua elemen ARR [] dalam set; Melintasi julat cetak semua elemen yang hilang; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void printMissing ( int [ ] arr , int n , int low , int high ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . Add ( arr [ i ] ) ; } for ( int x = low ; x <= high ; x ++ ) if ( ! s . Contains ( x ) ) Console . Write ( x + \" ▁ \" ) ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 5 , 4 } ; int n = arr . Length ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; } }"}
{"text": "K | C # Program untuk mencari elemen yang hilang dalam urutan yang diberikan; Mengembalikan elemen k - yang hilang. Ia kembali - 1 jika tiada k adalah lebih daripada bilangan elemen yang hilang. ; Masukkan semua elemen urutan Givens B []. ; Melintasi urutan yang semakin meningkat dan menjejaki jumlah nombor yang hilang. ; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int find ( int [ ] a , int [ ] b , int k , int n1 , int n2 ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) s . Add ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ! s . Contains ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; } public static void Main ( String [ ] args ) { int [ ] a = { 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 } ; int [ ] b = { 4 , 10 , 6 , 8 , 12 } ; int n1 = a . Length ; int n2 = b . Length ; int k = 3 ; Console . WriteLine ( find ( a , b , k , n1 , n2 ) ) ; } }"}
{"text": "Kurangkan langkah -langkah untuk membentuk rentetan s dari rentetan rawak panjang K menggunakan Panjang Tetap Panjang | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum rentetan yang diperlukan untuk menjana rentetan asal; Menyimpan kekerapan setiap watak rentetan s; Melangkah ke atas julat [0, 25]; Menyimpan kekerapan setiap watak rentetan s; Mengira watak yang unik dalam s; Jika watak unik lebih besar maka n, maka kembali - 1; Jika tidak; Melakukan carian binari; Cari nilai pertengahan; Melangkah ke atas julat [0, 26]; Jika jumlah [i] lebih besar daripada 0; Mengemas kini julat; Cari rentetan yang dihasilkan; Menjana berikutnya; Jika panjang rentetan hasil kurang daripada N daripada menambah watak 'A'; Cetak rentetan; Kod pemacu", "code": "using System ; class GFG { static void findString ( string S , int N ) { int [ ] amounts = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { amounts [ i ] = 0 ; } for ( int i = 0 ; i < S . Length ; i ++ ) { amounts [ ( int ) ( S [ i ] - 97 ) ] ++ ; } int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) count ++ ; } if ( count > N ) { Console . Write ( \" - 1\" ) ; } else { string ans = \" \" ; int high = 100001 ; int low = 0 ; int mid , total ; while ( ( high - low ) > 1 ) { total = 0 ; mid = ( high + low ) / 2 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) / mid + 1 ; } } if ( total <= N ) { high = mid ; } else { low = mid ; } } Console . Write ( high + \" ▁ \" ) ; total = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) / high + 1 ; for ( int j = 0 ; j < ( ( amounts [ i ] - 1 ) / high + 1 ) ; j ++ ) { ans += ( char ) ( i + 97 ) ; } } } for ( int i = total ; i < N ; i ++ ) { ans += ' a ' ; } string reverse = \" \" ; int Len = ans . Length - 1 ; while ( Len >= 0 ) { reverse = reverse + ans [ Len ] ; Len -- ; } Console . Write ( reverse ) ; } } public static void Main ( ) { string S = \" toffee \" ; int K = 4 ; findString ( S , K ) ; } }"}
{"text": "Cari elemen berulang pertama dalam pelbagai integer | C # Program untuk mencari elemen berulang pertama di arr []; Fungsi ini mencetak elemen berulang pertama dalam arr []; Memulakan indeks elemen berulang pertama; Mewujudkan hashset kosong; Melintasi array input dari kanan ke kiri; Jika elemen sudah ada dalam hash set, kemas kini min; Lain tambah elemen ke hash set; Cetak hasilnya; Kaedah pemacu untuk menguji kaedah di atas", "code": "using System ; using System . Collections . Generic ; public class GFG { public static void printFirstRepeating ( int [ ] arr ) { int min = - 1 ; HashSet < int > set = new HashSet < int > ( ) ; for ( int i = arr . Length - 1 ; i >= 0 ; i -- ) { if ( set . Contains ( arr [ i ] ) ) { min = i ; } else { set . Add ( arr [ i ] ) ; } } if ( min != - 1 ) { Console . WriteLine ( \" The ▁ first ▁ repeating ▁ element ▁ is ▁ \" + arr [ min ] ) ; } else { Console . WriteLine ( \" There ▁ are ▁ no ▁ repeating ▁ elements \" ) ; } } public static void Main ( string [ ] args ) { int [ ] arr = new int [ ] { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; printFirstRepeating ( arr ) ; } }"}
{"text": "Cari elemen berulang pertama dalam pelbagai integer | C # Program untuk mencari elemen berulang pertama di arr []; Fungsi ini mencetak elemen berulang pertama dalam arr []; Ini akan menetapkan k = 1, jika ada elemen berulang yang dijumpai; max = maksimum dari (semua elemen & n); Array A adalah untuk menyimpan 1 masa yang berlaku pada elemen yang diasaskan oleh 0; Simpan 1 dalam array b Jika elemen adalah pendua yang diasaskan oleh 0; Elemen pendua yang dijumpai; menyimpan 1 st kejadian arr [i]; Trace Array A & Cari Elemen Berulang dengan Min Index; Kod pemacu", "code": "using System ; class GFG { static void printFirstRepeating ( int [ ] arr , int n ) { int k = 0 ; int max = n ; for ( int i = 0 ; i < n ; i ++ ) if ( max < arr [ i ] ) max = arr [ i ] ; int [ ] a = new int [ max + 1 ] ; int [ ] b = new int [ max + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ arr [ i ] ] != 0 ) { b [ arr [ i ] ] = 1 ; k = 1 ; continue ; } else a [ arr [ i ] ] = i ; } if ( k == 0 ) Console . WriteLine ( \" No ▁ repeating ▁ element ▁ found \" ) ; else { int min = max + 1 ; for ( int i = 0 ; i < max + 1 ; i ++ ) if ( ( a [ i ] != 0 ) && min > a [ i ] && ( b [ i ] != 0 ) ) min = a [ i ] ; Console . Write ( arr [ min ] ) ; } Console . WriteLine ( ) ; } static void Main ( ) { int [ ] arr = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = arr . Length ; printFirstRepeating ( arr , n ) ; } }"}
{"text": "K | C # Program untuk mencetak elemen yang berbeza dalam array yang diberikan; Mengembalikan elemen yang berbeza dalam arr; Semak jika elemen semasa hadir di tempat lain. ; Jika elemen adalah unik; Kod pemacu", "code": "using System ; class GFG { static int printKDistinct ( int [ ] arr , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; } public static void Main ( ) { int [ ] ar = { 1 , 2 , 1 , 3 , 4 , 2 } ; int n = ar . Length ; int k = 2 ; Console . Write ( printKDistinct ( ar , n , k ) ) ; } }"}
{"text": "Count Subarrays mempunyai kiraan yang sama dengan 0 dan 1 S berasal | C # Program untuk pendekatan di atas; Fungsi untuk mengira subarray yang mempunyai kiraan yang sama dengan 0 s dan 1 s dengan semua 0 s dan semua 1 dikelompokkan bersama; Menyimpan kiraan; Memulakan CUR dengan elemen pertama; Jika elemen seterusnya adalah sama dengan elemen semasa; Kiraan kenaikan; Kemas kini curr; Melangkah ke atas kiraan array; Pertimbangkan minimum; Kod pemacu; Diberikan [] arr; Panggilan fungsi", "code": "using System ; class GFG { static void countSubarrays ( int [ ] A ) { int res = 0 ; int curr = A [ 0 ] ; int [ ] cnt = new int [ A . Length ] ; cnt [ 0 ] = 1 ; for ( int c = 1 ; c < A . Length ; c ++ ) { if ( A == curr ) cnt ++ ; else curr = A ; cnt = 1 ; } for ( int i = 1 ; i < cnt . Length ; i ++ ) { res += Math . Min ( cnt [ i - 1 ] , cnt [ i ] ) ; } Console . WriteLine ( res - 1 ) ; } public static void Main ( String [ ] args ) { int [ ] A = { 1 , 1 , 0 , 0 , 1 , 0 } ; countSubarrays ( A ) ; } }"}
{"text": "Semak jika pokok binari adalah walaupun | C # Program untuk pendekatan di atas; Nod pokok; Berfungsi untuk mengembalikan nod pokok baru; Berfungsi untuk memeriksa sama ada pokok itu - pokok ganjil; Menyimpan nod setiap peringkat; Simpan tahap semasa pokok binari; Melintasi sehingga barisan kosong; Menyimpan bilangan nod yang terdapat di peringkat semasa; Semak sama ada tahapnya atau ganjil; Tambah nod tahap seterusnya ke dalam barisan; Meningkatkan kiraan tahap; Kod pemacu; Membina pokok binari; Periksa sama ada pokok binari itu - pokok ganjil atau tidak", "code": "using System ; using System . Collections . Generic ; class GfG { class Node { public int val ; public Node left , right ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . val = data ; temp . left = null ; temp . right = null ; return temp ; } static bool isEvenOddBinaryTree ( Node root ) { if ( root == null ) return true ; Queue < Node > q = new Queue < Node > ( ) ; q . Enqueue ( root ) ; int level = 0 ; while ( q . Count != 0 ) { int size = q . Count ; for ( int i = 0 ; i < size ; i ++ ) { Node node = q . Dequeue ( ) ; if ( level % 2 == 0 ) { if ( node . val % 2 == 1 ) return false ; } else if ( level % 2 == 1 ) { if ( node . val % 2 == 0 ) return false ; } if ( node . left != null ) { q . Enqueue ( node . left ) ; } if ( node . right != null ) { q . Enqueue ( node . right ) ; } } level ++ ; } return true ; } public static void Main ( String [ ] args ) { Node root = null ; root = newNode ( 2 ) ; root . left = newNode ( 3 ) ; root . right = newNode ( 9 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 10 ) ; root . right . right = newNode ( 6 ) ; if ( isEvenOddBinaryTree ( root ) ) { Console . WriteLine ( \" YES \" ) ; } else { Console . WriteLine ( \" NO \" ) ; } } }"}
{"text": "Memaksimumkan jarak minimum antara pengulangan dari sebarang permutasi array yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Menyimpan kekerapan elemen array; Cari kekerapan tertinggi dalam array; Meningkatkan kiraan elemen maksimum; Sekiranya tiada pengulangan hadir; Cari jarak maksimum; Mengembalikan jarak maksimum; Kod pemacu", "code": "using System ; class GFG { static int findMaxLen ( int [ ] a , int n ) { int [ ] freq = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) { freq [ a [ i ] ] ++ ; } int maxFreqElement = int . MinValue ; int maxFreqCount = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( freq [ i ] > maxFreqElement ) { maxFreqElement = freq [ i ] ; maxFreqCount = 1 ; } else if ( freq [ i ] == maxFreqElement ) maxFreqCount ++ ; } int ans ; if ( maxFreqElement == 1 ) ans = 0 ; else { ans = ( ( n - maxFreqCount ) / ( maxFreqElement - 1 ) ) ; } return ans ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 2 , 1 , 2 } ; int n = a . Length ; Console . Write ( findMaxLen ( a , n ) ) ; } }"}
{"text": "Pertanyaan untuk menilai persamaan yang diberikan dalam julat [l, r] | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mendapatkan indeks pertengahan julat; Fungsi rekursif untuk mendapatkan jumlah nilai dalam julat yang diberikan dari array. Berikut adalah parameter untuk fungsi ini: st -> penunjuk ke nod pokok segmen -> indeks nod semasa dalam segmen pokok SS & SE -> Memulakan dan menamatkan indeks segmen yang diwakili oleh nod semasa, i. e. , St [nod] L & R -> Memulakan dan menamatkan indeks pertanyaan pelbagai; Jika segmen nod ini terletak sepenuhnya dalam julat yang diberikan; Pulangan maksimum dalam segmen; Jika segmen nod ini terletak di luar julat yang diberikan; Jika segmen nod ini terletak sebahagiannya dalam julat yang diberikan; Berfungsi untuk mengembalikan maksimum dalam julat dari [L, R]; Semak nilai input yang salah; Berfungsi untuk pokok consegment untuk subarray [ss. . se]; Untuk satu elemen; Jika tidak; Berulang untuk subtree kiri; Berulang untuk subtree yang betul; Berfungsi untuk pokok consegment dari array yang diberikan; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan; Mengembalikan pokok segmen yang dibina; Kod pemacu; Bina pokok segmen dari array yang diberikan", "code": "using System ; class GFG { static int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } static int MaxUtil ( int [ ] st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return - 1 ; int mid = getMid ( ss , se ) ; return Math . Max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; } static int getMax ( int [ ] st , int n , int l , int r ) { if ( l < 0 r > n - 1 l > r ) { Console . Write ( \" Invalid ▁ Input \" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; } static int constructSTUtil ( int [ ] arr , int ss , int se , int [ ] st , int si ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return arr [ ss ] ; } int mid = getMid ( ss , se ) ; st [ si ] = Math . Max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; } static int [ ] constructST ( int [ ] arr , int n ) { int x = ( int ) ( Math . Ceiling ( Math . Log ( n ) ) ) ; int max_size = 2 * ( int ) Math . Pow ( 2 , x ) - 1 ; int [ ] st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 2 , 3 , 0 } ; int n = arr . Length ; int [ ] st = constructST ( arr , n ) ; int [ , ] Q = { { 1 , 3 } , { 0 , 2 } } ; for ( int i = 0 ; i < Q . GetLength ( 0 ) ; i ++ ) { int max = getMax ( st , n , Q [ i , 0 ] , Q [ i , 1 ] ) ; int ok = 0 ; for ( int j = 30 ; j >= 0 ; j -- ) { if ( ( max & ( 1 << j ) ) != 0 ) ok = 1 ; if ( ok <= 0 ) continue ; max |= ( 1 << j ) ; } Console . Write ( max + \" ▁ \" ) ; } } }"}
{"text": "Cari bilangan pasangan dalam array supaya XOR mereka adalah 0 | C # Program untuk mencari bilangan pasangan dalam array sedemikian rupa sehingga XOR mereka adalah 0; Fungsi untuk mengira kiraan; Menyusun senarai menggunakan fungsi terbina; Melintasi unsur -unsur; Kekerapan mengira setiap elemen; Menambah sumbangan kekerapan kepada jawapannya; Kod pemacu; Cetak kiraan", "code": "using System ; class GFG { static int calculate ( int [ ] a , int n ) { Array . Sort ( a ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 1 , 2 , 4 } ; int n = a . Length ; Console . WriteLine ( calculate ( a , n ) ) ; } }"}
{"text": "Cari bilangan pasangan dalam array supaya XOR mereka adalah 0 | C # Program untuk mencari bilangan pasangan dalam array sedemikian rupa sehingga XOR mereka adalah 0; Berfungsi untuk mengira jawapannya; Mencari maksimum array; Mewujudkan array frekuensi dengan nilai awal 0; Melintasi array; Kekerapan mengira; Melintasi pelbagai frekuensi; Mengira jawapan; Kod pemacu; Fungsi panggilan", "code": "using System ; using System . Linq ; class GFG { static int calculate ( int [ ] a , int n ) { int maximum = a . Max ( ) ; int [ ] frequency = new int [ maximum + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 2 , 1 , 2 , 4 } ; int n = a . Length ; Console . WriteLine ( calculate ( a , n ) ) ; } }"}
{"text": "Subarray terbesar dengan bilangan yang sama 0 s dan 1 s | Program mudah untuk mencari subarray terbesar dengan bilangan yang sama 0 s dan 1 s; Fungsi ini mencetak indeks permulaan dan akhir subarray terbesar dengan bilangan yang sama 0 s dan 1 s. Juga mengembalikan saiz subarray tersebut. ; Pilih titik permulaan seperti saya; Pertimbangkan semua subarrays bermula dari i; Jika ini adalah subarray 0 jumlah, maka bandingkan dengan subarray saiz maksimum yang dikira setakat ini; Program Pemandu", "code": "using System ; class GFG { static int findSubArray ( int [ ] arr , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) Console . WriteLine ( \" No ▁ such ▁ subarray \" ) ; else Console . WriteLine ( startindex + \" ▁ to ▁ \" + endindex ) ; return maxsize ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = arr . Length ; findSubArray ( arr , size ) ; } }"}
{"text": "Elemen maksimum dalam array yang disusun dan diputar | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan elemen maksimum; Sekiranya terdapat hanya satu elemen yang tersisa; Cari pertengahan; Semak jika pertengahan mencapai 0, ia lebih besar daripada elemen seterusnya atau tidak; Periksa sama ada pertengahan sendiri adalah elemen maksimum; Tentukan sama ada kita perlu pergi ke separuh kiri atau separuh kanan; Kod pemacu", "code": "using System ; class GFG { static int findMax ( int [ ] arr , int low , int high ) { if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) return arr [ mid ] ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] && mid > 0 && arr [ mid ] > arr [ mid - 1 ] ) { return arr [ mid ] ; } if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } } public static void Main ( ) { int [ ] arr = { 6 , 5 , 1 , 2 , 3 , 4 } ; int n = arr . Length ; Console . WriteLine ( findMax ( arr , 0 , n - 1 ) ) ; } }"}
{"text": "Carian Ternary | C # Program untuk menggambarkan pendekatan berulang untuk carian ternary; Berfungsi untuk melakukan carian ternary; Cari Mid1 dan Mid2; Semak sama ada kunci hadir di mana -mana pertengahan; Oleh kerana kunci tidak hadir pada pertengahan, periksa di mana rantau ia hadir kemudian ulangi operasi carian di rantau itu; Kunci terletak di antara L dan MID1; Kunci terletak di antara Mid2 dan R; Kuncinya terletak di antara Mid1 dan Mid2; Kunci tidak dijumpai; Kod pemacu; Dapatkan array jenis array jika tidak disusun; Indeks permulaan; panjang array; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya", "code": "using System ; public class GFG { static int ternarySearch ( int l , int r , int key , int [ ] ar ) { while ( r >= l ) { int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) { l = mid2 + 1 ; } else { l = mid1 + 1 ; r = mid2 - 1 ; } } return - 1 ; } public static void Main ( String [ ] args ) { int l , r , p , key ; int [ ] ar = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; l = 0 ; r = 9 ; key = 5 ; p = ternarySearch ( l , r , key , ar ) ; Console . WriteLine ( \" Index ▁ of ▁ \" + key + \" ▁ is ▁ \" + p ) ; key = 50 ; p = ternarySearch ( l , r , key , ar ) ; Console . WriteLine ( \" Index ▁ of ▁ \" + key + \" ▁ is ▁ \" + p ) ; } }"}
{"text": "Elemen Majoriti | Set | C # pelaksanaan pendekatan; berfungsi untuk mencetak nombor majoriti; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int majorityNumber ( int [ ] arr , int n ) { int ans = - 1 ; Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] ) ) { freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1 ; } else { freq . Add ( arr [ i ] , 1 ) ; } if ( freq [ arr [ i ] ] > n / 2 ) ans = arr [ i ] ; } return ans ; } public static void Main ( String [ ] args ) { int [ ] a = { 2 , 2 , 1 , 1 , 1 , 2 , 2 } ; int n = a . Length ; Console . WriteLine ( majorityNumber ( a , n ) ) ; } }"}
{"text": "Cari elemen dalam array yang disusun dan diputar | C # Program untuk mencari elemen dalam array yang disusun dan diputar menggunakan lulus tunggal carian binari; Pulangan indeks kunci dalam arr [l. . h] jika kunci hadir, jika tidak pulangan - 1; Jika arr [l ... pertengahan] disusun; Oleh kerana subarray ini disusun, kita dapat dengan cepat memeriksa sama ada kunci terletak pada separuh atau separuh lagi; Jika kunci tidak terletak pada separuh pertama subarray, bahagikan separuh lagi ke dalam dua subarray, supaya kita dapat dengan cepat memeriksa jika kunci terletak pada separuh lain; Jika arr [l. . pertengahan] tidak disusun, maka arr [pertengahan ... r] mesti disusun; fungsi utama", "code": "using System ; class GFG { static int search ( int [ ] arr , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } public static void Main ( ) { int [ ] arr = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = arr . Length ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != - 1 ) Console . WriteLine ( \" Index : ▁ \" + i ) ; else Console . WriteLine ( \" Key ▁ not ▁ found \" ) ; } }"}
{"text": "Cari elemen minimum dalam array yang disusun dan diputar | C # Program untuk mencari elemen minimum dalam array yang disusun dan diputar; Keadaan ini diperlukan untuk mengendalikan kes apabila array tidak diputar sama sekali; Sekiranya terdapat hanya satu elemen yang tersisa; Cari pertengahan (rendah + tinggi) / 2; Semak jika elemen (pertengahan + 1) adalah elemen minimum. Pertimbangkan kes seperti {3, 4, 5, 1, 2}; Semak jika Mid sendiri adalah elemen minimum; Tentukan sama ada kita perlu pergi ke separuh kiri atau kanan; Program Pemandu", "code": "using System ; class Minimum { static int findMin ( int [ ] arr , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; } public static void Main ( ) { int [ ] arr1 = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = arr1 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr1 , 0 , n1 - 1 ) ) ; int [ ] arr2 = { 1 , 2 , 3 , 4 } ; int n2 = arr2 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr2 , 0 , n2 - 1 ) ) ; int [ ] arr3 = { 1 } ; int n3 = arr3 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr3 , 0 , n3 - 1 ) ) ; int [ ] arr4 = { 1 , 2 } ; int n4 = arr4 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr4 , 0 , n4 - 1 ) ) ; int [ ] arr5 = { 2 , 1 } ; int n5 = arr5 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr5 , 0 , n5 - 1 ) ) ; int [ ] arr6 = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = arr6 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr6 , 0 , n1 - 1 ) ) ; int [ ] arr7 = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = arr7 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr7 , 0 , n7 - 1 ) ) ; int [ ] arr8 = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = arr8 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr8 , 0 , n8 - 1 ) ) ; int [ ] arr9 = { 3 , 4 , 5 , 1 , 2 } ; int n9 = arr9 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr9 , 0 , n9 - 1 ) ) ; } }"}
{"text": "Cari elemen minimum dalam array yang disusun dan diputar | C # Program untuk mencari elemen minimum dalam array yang disusun dan diputar elemen pendua. ; Berfungsi untuk mencari elemen minimum; Kod pemacu", "code": "using System ; class GFG { public static int findMin ( int [ ] arr , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; } public static void Main ( String [ ] args ) { int [ ] arr1 = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = arr1 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr1 , 0 , n1 - 1 ) ) ; int [ ] arr2 = { 1 , 2 , 3 , 4 } ; int n2 = arr2 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr2 , 0 , n2 - 1 ) ) ; int [ ] arr3 = { 1 } ; int n3 = arr3 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr3 , 0 , n3 - 1 ) ) ; int [ ] arr4 = { 1 , 2 } ; int n4 = arr4 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr4 , 0 , n4 - 1 ) ) ; int [ ] arr5 = { 2 , 1 } ; int n5 = arr5 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr5 , 0 , n5 - 1 ) ) ; int [ ] arr6 = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = arr6 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr6 , 0 , n6 - 1 ) ) ; int [ ] arr7 = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = arr7 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr7 , 0 , n7 - 1 ) ) ; int [ ] arr8 = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = arr8 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr8 , 0 , n8 - 1 ) ) ; int [ ] arr9 = { 3 , 4 , 5 , 1 , 2 } ; int n9 = arr9 . Length ; Console . WriteLine ( \" The ▁ minimum ▁ element ▁ is ▁ \" + findMin ( arr9 , 0 , n9 - 1 ) ) ; } }"}
{"text": "K | C # Program untuk mencari perbezaan mutlak antara dua elemen; Mengembalikan bilangan pasangan dengan perbezaan mutlak kurang daripada atau sama dengan pertengahan; Upper Bound Returns Pointer ke kedudukan nombor seterusnya yang lebih tinggi daripada [i] + pertengahan dalam [i. . n - 1]. Kami tolak (Ub + I + 1) dari kedudukan ini untuk dikira; mengembalikan terikat atas; Pulangan k - perbezaan mutlak; Susun array; Perbezaan mutlak minimum; Perbezaan mutlak maksimum; Adakah pencarian binari untuk perbezaan mutlak; Kod pemacu", "code": "using System ; class GFG { static int countPairs ( int [ ] a , int n , int mid ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ub = upperbound ( a , n , a [ i ] + mid ) ; res += ( ub - ( i - 1 ) ) ; } return res ; } static int upperbound ( int [ ] a , int n , int value ) { int low = 0 ; int high = n ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( value >= a [ mid ] ) low = mid + 1 ; else high = mid ; } return low ; } static int kthDiff ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; int low = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i <= n - 2 ; ++ i ) low = Math . Min ( low , a [ i + 1 ] - a [ i ] ) ; int high = a [ n - 1 ] - a [ 0 ] ; while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( countPairs ( a , n , mid ) < k ) low = mid + 1 ; else high = mid ; } return low ; } public static void Main ( String [ ] args ) { int k = 3 ; int [ ] a = { 1 , 2 , 3 , 4 } ; int n = a . Length ; Console . WriteLine ( kthDiff ( a , n , k ) ) ; } }"}
{"text": "Cari elemen terkecil terkecil dan kedua dalam array | C # Program untuk mencari elemen terkecil terkecil dan kedua; Berfungsi untuk mencetak unsur -unsur terkecil terkecil pertama dan kedua; Harus ada dua elemen; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static void print2Smallest ( int [ ] arr ) { int first , second , arr_size = arr . Length ; if ( arr_size < 2 ) { Console . Write ( \" ▁ Invalid ▁ Input ▁ \" ) ; return ; } first = second = int . MaxValue ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == int . MaxValue ) Console . Write ( \" There ▁ is ▁ no ▁ second \" + \" smallest ▁ element \" ) ; else Console . Write ( \" The ▁ smallest ▁ element ▁ is ▁ \" + first + \" ▁ and ▁ second ▁ Smallest \" + \" ▁ element ▁ is ▁ \" + second ) ; } public static void Main ( ) { int [ ] arr = { 12 , 13 , 1 , 10 , 34 , 1 } ; print2Smallest ( arr ) ; } }"}
{"text": "Range LCM Queries | LCM pertanyaan pelbagai yang diberikan menggunakan pokok segmen; memperuntukkan ruang untuk pokok; mengisytiharkan array di seluruh dunia; Berfungsi untuk mengembalikan GCD A dan B; fungsi utiliti untuk mencari LCM; Fungsi untuk membina nod pokok segmen memulakan indeks permulaan subtree semasa. Permulaan dan akhir adalah indeks dalam [] arr yang global; Sekiranya terdapat hanya satu elemen dalam subarray semasa; membina segmen kiri dan kanan; membina ibu bapa; Berfungsi untuk membuat pertanyaan untuk pelbagai array) l, r). Node adalah indeks akar segmen semasa dalam pokok segmen (perhatikan bahawa indeks dalam pokok segmen bermula dengan 1 untuk kesederhanaan). Mula dan akhir adalah indeks subarray yang dilindungi oleh akar segmen semasa. ; Sepenuhnya di luar segmen, kembali 1 tidak akan menjejaskan LCM; ; sepenuhnya di dalam segmen; sebahagiannya di dalam; Kod pemacu; memulakan array; membina pokok segmen; Sekarang kita dapat menjawab setiap pertanyaan dengan cekap mencetak LCM (2, 5); Cetak LCM (5, 10); Cetak LCM (0, 10)", "code": "using System ; using System . Collections . Generic ; class GFG { static readonly int MAX = 1000 ; static int [ ] tree = new int [ 4 * MAX ] ; static int [ ] arr = new int [ MAX ] ; static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return a * b / gcd ( a , b ) ; } static void build ( int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) / 2 ; build ( 2 * node , start , mid ) ; build ( 2 * node + 1 , mid + 1 , end ) ; int left_lcm = tree [ 2 * node ] ; int right_lcm = tree [ 2 * node + 1 ] ; tree [ node ] = lcm ( left_lcm , right_lcm ) ; } static int query ( int node , int start , int end , int l , int r ) { if ( end < l start > r ) { return 1 ; } if ( l <= start && r >= end ) { return tree [ node ] ; } int mid = ( start + end ) / 2 ; int left_lcm = query ( 2 * node , start , mid , l , r ) ; int right_lcm = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return lcm ( left_lcm , right_lcm ) ; } public static void Main ( String [ ] args ) { arr [ 0 ] = 5 ; arr [ 1 ] = 7 ; arr [ 2 ] = 5 ; arr [ 3 ] = 2 ; arr [ 4 ] = 10 ; arr [ 5 ] = 12 ; arr [ 6 ] = 11 ; arr [ 7 ] = 17 ; arr [ 8 ] = 14 ; arr [ 9 ] = 1 ; arr [ 10 ] = 44 ; build ( 1 , 0 , 10 ) ; Console . WriteLine ( query ( 1 , 0 , 10 , 2 , 5 ) ) ; Console . WriteLine ( query ( 1 , 0 , 10 , 5 , 10 ) ) ; Console . WriteLine ( query ( 1 , 0 , 10 , 0 , 10 ) ) ; } }"}
{"text": "Kira penyahkodan mungkin urutan digit yang diberikan dengan aksara tersembunyi | C # Program untuk pendekatan di atas; Semak watak pertama rentetan jika ' *' maka 9 cara; Melintasi rentetan; Jika s [i] = = ' *' boleh ada 9 nilai yang mungkin *; Jika watak sebelumnya adalah 1 maka perkataan yang boleh dibentuk adalah k (11), l (12), m (13), n (14) o (15), p (16), q (17), r (18), s (19); Jika watak sebelumnya adalah 2 maka kata -kata yang boleh dibentuk ialah u (21), v (22), w (23), x (24) y (25), z (26); Jika digit sebelumnya * maka semua 15 2 - aksara digit boleh dibentuk; Mengambil nilai dari langkah sebelumnya; Jika watak sebelumnya adalah 1 maka watak I - 1 dan watak itu boleh dikodkan dalam satu watak oleh itu, menambah DP [i - 1]. ; Jika watak sebelumnya adalah 2 dan watak ith kurang daripada 6 maka watak I - 1 dan watak ith boleh dikodkan dalam satu watak oleh itu, menambah DP [i - 1]. ; Jika watak sebelumnya * maka ia akan mengandungi 2 kes di atas; Kod pemacu", "code": "using System ; class GFG { static int M = 1000000007 ; static int waysOfDecoding ( String s ) { long [ ] dp = new long [ s . Length + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' * ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != '0' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return ( int ) dp [ s . Length ] ; } public static void Main ( ) { String s = \"12\" ; Console . WriteLine ( waysOfDecoding ( s ) ) ; } }"}
{"text": "Kira cara untuk memecah array ke dalam dua subset yang mempunyai perbezaan antara jumlah mereka sama dengan k | C # Program untuk pendekatan di atas; Berfungsi untuk mengira bilangan cara untuk membahagikan array ke dalam dua subset dan sedemikian rupa sehingga perbezaan antara jumlah mereka adalah sama dengan perbezaan; Simpan jumlah set S1; Memulakan matriks; Bilangan cara untuk mendapatkan jumlah menggunakan 0 elemen adalah 0; Bilangan cara untuk mendapatkan jumlah 0 menggunakan elemen i adalah 1; Melintasi array 2D; Jika nilai lebih besar daripada jumlah menyimpan nilai keadaan sebelumnya; Mengembalikan hasilnya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; public class GFG { static int countSubset ( int [ ] arr , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int [ , ] t = new int [ n + 1 , sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 , j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i , j ] = t [ i - 1 , j ] ; else { t [ i , j ] = t [ i - 1 , j ] + t [ i - 1 , j - arr [ i - 1 ] ] ; } } } return t [ n , sum ] ; } public static void Main ( string [ ] args ) { int diff = 1 , n = 4 ; int [ ] arr = { 1 , 1 , 2 , 3 } ; Console . Write ( countSubset ( arr , n , diff ) ) ; } }"}
{"text": "Kebarangkalian bahawa jumlah semua nombor yang diperolehi membuang dadu n kali terletak di antara dua bilangan bulat yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mengira kebarangkalian bahawa jumlah nombor pada n lontaran dadu terletak di antara a dan b; Kes asas; Tambah kebarangkalian untuk semua nombor antara A dan B; Kod pemacu; Cetak jawapannya", "code": "using System ; public class GFG { static float [ , ] dp = new float [ 105 , 605 ] ; static float find ( int N , int a , int b ) { float probability = 0.0f ; for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 , i ] = ( float ) ( 1.0 / 6 ) ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i , j ] = dp [ i , j ] + dp [ i - 1 , j - k ] / 6 ; } } } for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N , sum ] ; return probability ; } public static void Main ( String [ ] args ) { int N = 4 , a = 13 , b = 17 ; float probability = find ( N , a , b ) ; Console . Write ( \" { 0 : F6 } \" , probability ) ; } }"}
{"text": "Jumlah maksimum dari pokok dengan tahap bersebelahan tidak dibenarkan | C # kod untuk jumlah maksimum dengan tahap bersebelahan tidak dibenarkan; Kelas nod pokok untuk perwakilan pokok binari; Fungsi rekursif untuk mencari jumlah maksimum yang dikembalikan untuk nod akar dan cucunya; Mengembalikan jumlah maksimum dengan tahap bersebelahan tidak dibenarkan. Fungsi ini terutamanya menggunakan getSumalternate (); Kami mengira jumlah tahap alternatif bermula tahap pertama dan dari tahap kedua. Dan kembali maksimum dua nilai. ; Kod pemacu", "code": "using System ; class GFG { public class Node { public int data ; public Node left , right ; public Node ( int item ) { data = item ; left = right = null ; } } public static int getSumAlternate ( Node root ) { if ( root == null ) return 0 ; int sum = root . data ; if ( root . left != null ) { sum += getSum ( root . left . left ) ; sum += getSum ( root . left . right ) ; } if ( root . right != null ) { sum += getSum ( root . right . left ) ; sum += getSum ( root . right . right ) ; } return sum ; } public static int getSum ( Node root ) { if ( root == null ) return 0 ; return Math . Max ( getSumAlternate ( root ) , ( getSumAlternate ( root . left ) + getSumAlternate ( root . right ) ) ) ; } public static void Main ( ) { Node root = new Node ( 1 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 3 ) ; root . right . left = new Node ( 4 ) ; root . right . left . right = new Node ( 5 ) ; root . right . left . right . left = new Node ( 6 ) ; Console . WriteLine ( getSum ( root ) ) ; } }"}
{"text": "Subset Jumlah Masalah di O (SUM) Ruang | C # Program untuk mendapatkan subset dengan A dengan jumlah yang disediakan oleh pengguna; Pulangan benar jika terdapat subset dengan jumlah yang diberikan dalam arr []; Nilai subset [i % 2] [j] akan benar jika terdapat subset jumlah J dalam arr [0, 1, .... , i - 1]; Subset dengan jumlah 0 selalu mungkin; Sekiranya tidak ada unsur tidak ada jumlah yang mungkin; Kod pemacu", "code": "using System ; public class Subset_sum { static bool isSubsetSum ( int [ ] arr , int n , int sum ) { bool [ , ] subset = new bool [ 2 , sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 , j ] = true ; else if ( i == 0 ) subset [ i % 2 , j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 , j ] = subset [ ( i + 1 ) % 2 , j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 , j ] ; else subset [ i % 2 , j ] = subset [ ( i + 1 ) % 2 , j ] ; } } return subset [ n % 2 , sum ] ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 5 } ; int sum = 7 ; int n = arr . Length ; if ( isSubsetSum ( arr , n , sum ) == true ) Console . WriteLine ( \" There ▁ exists ▁ a ▁ subset ▁ with \" + \" given ▁ sum \" ) ; else Console . WriteLine ( \" No ▁ subset ▁ exists ▁ with \" + \" given ▁ sum \" ) ; } }"}
{"text": "Sum maksimum equlibrium dalam array | C # Program untuk mencari jumlah keseimbangan maksimum. ; Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Kod pemacu", "code": "using System ; class GFG { static int findMaxSum ( int [ ] arr , int n ) { int res = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . Max ( res , prefix_sum ) ; } return res ; } public static void Main ( ) { int [ ] arr = { - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 } ; int n = arr . Length ; Console . WriteLine ( findMaxSum ( arr , n ) ) ; } }"}
{"text": "Sum maksimum equlibrium dalam array | C # Program untuk mencari jumlah keseimbangan maksimum. ; Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Array to Store Prefix Sum. ; Array untuk menyimpan jumlah akhiran. ; Pembolehubah untuk menyimpan jumlah maksimum. ; Kirakan jumlah awalan. ; Kirakan jumlah akhiran dan bandingkan dengan jumlah awalan. Kemas kini Ans dengan sewajarnya. ; Kod pemacu", "code": "using System ; public class GFG { static int findMaxSum ( int [ ] arr , int n ) { int [ ] preSum = new int [ n ] ; int [ ] suffSum = new int [ n ] ; int ans = int . MinValue ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . Max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . Max ( ans , preSum [ i ] ) ; } return ans ; } static public void Main ( ) { int [ ] arr = { - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 } ; int n = arr . Length ; Console . WriteLine ( findMaxSum ( arr , n ) ) ; } }"}
{"text": "Sum maksimum equlibrium dalam array | C # Program untuk mencari jumlah keseimbangan maksimum. ; Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Kod pemacu", "code": "using System . Linq ; using System ; class GFG { static int Add ( int x , int y ) { return x + y ; } static int findMaxSum ( int [ ] arr , int n ) { int sum = arr . Aggregate ( func : Add ) ; int prefix_sum = 0 , res = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { prefix_sum += arr [ i ] ; if ( prefix_sum == sum ) res = Math . Max ( res , prefix_sum ) ; sum -= arr [ i ] ; } return res ; } public static void Main ( ) { int [ ] arr = { - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 } ; int n = arr . Length ; Console . Write ( findMaxSum ( arr , n ) ) ; } }"}
{"text": "Elemen Majoriti | C # Program untuk mencari elemen majoriti dalam array; Berfungsi untuk mencari elemen majoriti dalam array; sentinel; Kemas kini MaxCount jika kiraan elemen semasa lebih besar; Jika MaxCount lebih besar daripada n / 2 mengembalikan elemen yang sepadan; Kod pemacu; Fungsi panggilan", "code": "using System ; public class GFG { static void findMajority ( int [ ] arr , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) Console . WriteLine ( arr [ index ] ) ; else Console . WriteLine ( \" No ▁ Majority ▁ Element \" ) ; } static public void Main ( ) { int [ ] arr = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = arr . Length ; findMajority ( arr , n ) ; } }"}
{"text": "Elemen Majoriti | C # Program untuk menunjukkan operasi sisipan dalam pokok carian binari. ; Fungsi utiliti untuk membuat nod BST baru; Fungsi utiliti untuk memasukkan nod baru dengan kunci yang diberikan dalam BST; Jika pokok itu kosong, kembalikan nod baru; Jika tidak, mengulangi pokok itu; Cari kiraan maksimum; Kembalikan penunjuk nod (tidak berubah); Fungsi utiliti untuk melakukan traversal inorder BST; Kod pemacu; Panggilan fungsi", "code": "using System ; public class Node { public int key ; public int c = 0 ; public Node left , right ; } class GFG { static int ma = 0 ; static Node newNode ( int item ) { Node temp = new Node ( ) ; temp . key = item ; temp . c = 1 ; temp . left = temp . right = null ; return temp ; } static Node insert ( Node node , int key ) { if ( node == null ) { if ( ma == 0 ) ma = 1 ; return newNode ( key ) ; } if ( key < node . key ) node . left = insert ( node . left , key ) ; else if ( key > node . key ) node . right = insert ( node . right , key ) ; else node . c ++ ; ma = Math . Max ( ma , node . c ) ; return node ; } static void inorder ( Node root , int s ) { if ( root != null ) { inorder ( root . left , s ) ; if ( root . c > ( s / 2 ) ) Console . WriteLine ( root . key + \" STRNEWLINE \" ) ; inorder ( root . right , s ) ; } } static public void Main ( ) { int [ ] a = { 1 , 3 , 3 , 3 , 2 } ; int size = a . Length ; Node root = null ; for ( int i = 0 ; i < size ; i ++ ) { root = insert ( root , a [ i ] ) ; } if ( ma > ( size / 2 ) ) inorder ( root , size ) ; else Console . WriteLine ( \" No ▁ majority ▁ element STRNEWLINE \" ) ; } }"}
{"text": "Elemen Majoriti | C # Program untuk mencari elemen majoriti dalam array; Berfungsi untuk mencari calon untuk majoriti; Berfungsi untuk memeriksa sama ada calon berlaku lebih daripada n / 2 kali; Berfungsi untuk mencetak elemen majoriti; Cari calon untuk majoriti; Cetak calon jika ia adalah majoriti; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int findCandidate ( int [ ] a , int size ) { int maj_index = 0 , count = 1 ; int i ; for ( i = 1 ; i < size ; i ++ ) { if ( a [ maj_index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj_index = i ; count = 1 ; } } return a [ maj_index ] ; } static bool isMajority ( int [ ] a , int size , int cand ) { int i , count = 0 ; for ( i = 0 ; i < size ; i ++ ) { if ( a [ i ] == cand ) count ++ ; } if ( count > size / 2 ) return true ; else return false ; } static void printMajority ( int [ ] a , int size ) { int cand = findCandidate ( a , size ) ; if ( isMajority ( a , size , cand ) ) Console . Write ( \" ▁ \" + cand + \" ▁ \" ) ; else Console . Write ( \" No ▁ Majority ▁ Element \" ) ; } public static void Main ( ) { int [ ] a = { 1 , 3 , 3 , 1 , 2 } ; int size = a . Length ; printMajority ( a , size ) ; } }"}
{"text": "Elemen Majoriti | C # Program untuk mencari elemen majoriti dalam array; Kod pemacu; Fungsi panggilan", "code": "using System ; using System . Collections . Generic ; class GFG { private static void findMajority ( int [ ] arr ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( map . ContainsKey ( arr [ i ] ) ) { int count = map [ arr [ i ] ] + 1 ; if ( count > arr . Length / 2 ) { Console . WriteLine ( \" Majority ▁ found ▁ : - ▁ \" + arr [ i ] ) ; return ; } else { map [ arr [ i ] ] = count ; } } else { map [ arr [ i ] ] = 1 ; } } Console . WriteLine ( \" ▁ No ▁ Majority ▁ element \" ) ; } public static void Main ( string [ ] args ) { int [ ] a = new int [ ] { 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 } ; findMajority ( a ) ; } }"}
{"text": "Elemen Majoriti | C # Program untuk mencari elemen majoriti dalam array; Fungsi untuk mencari elemen majoriti dalam array ia kembali - 1 jika tidak ada unsur majoriti; Susun array dalam O (nlogn); Meningkatkan kiraan jika elemen yang sama berlaku sebaliknya mula mengira elemen baru; Menetapkan kiraan maksimum dan menyimpan elemen maksimum yang berlaku setakat ini jika kiraan maksimum menjadi lebih besar daripada n / 2 ia memecahkan penetapan bendera; Mengembalikan elemen maksimum yang berlaku jika tidak ada elemen sedemikian, pulangan - 1; Kod pemacu; Fungsi panggilan", "code": "using System ; class GFG { public static int majorityElement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int count = 1 , max_ele = - 1 , temp = arr [ 0 ] , ele = 0 , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > ( n / 2 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : - 1 ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = 7 ; Console . WriteLine ( majorityElement ( arr , n ) ) ; } }"}
{"text": "Pengaturcaraan Dinamik | Penyelesaian pengaturcaraan dinamik untuk masalah jumlah subset; Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara bawah; Kod pemacu", "code": "using System ; class GFG { static bool isSubsetSum ( int [ ] set , int n , int sum ) { bool [ , ] subset = new bool [ sum + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ 0 , i ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ i , 0 ] = false ; for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i , j ] = subset [ i , j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i , j ] = subset [ i , j ] || subset [ i - set [ j - 1 ] , j - 1 ] ; } } return subset [ sum , n ] ; } public static void Main ( ) { int [ ] set = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = set . Length ; if ( isSubsetSum ( set , n , sum ) == true ) Console . WriteLine ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) ; else Console . WriteLine ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) ; } }"}
{"text": "Pengaturcaraan Dinamik | C # Program untuk pendekatan di atas; Semak jika boleh subset dengan jumlah yang diberikan adalah mungkin atau tidak; Menyimpan nilai - 1 ke matriks; Sekiranya jumlahnya adalah sifar, ia bermakna kami mendapat jumlah yang diharapkan; Jika nilai tidak - 1 ia bermakna ia sudah memanggil fungsi dengan nilai yang sama. Ia akan menyelamatkan kami dari pengulangan. ; Jika nilai A [n - 1] lebih besar daripada jumlahnya. Kami memanggil nilai seterusnya; Di sini kita melakukan dua panggilan kerana kita tidak tahu apa -apa yang akan dipenuhi oleh kami. Kod pemacu", "code": "using System ; class GFG { static int subsetSum ( int [ ] a , int n , int sum ) { int [ , ] tab = new int [ n + 1 , sum + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { tab [ i , j ] = - 1 ; } } if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ; if ( tab [ n - 1 , sum ] != - 1 ) return tab [ n - 1 , sum ] ; if ( a [ n - 1 ] > sum ) return tab [ n - 1 , sum ] = subsetSum ( a , n - 1 , sum ) ; else { if ( subsetSum ( a , n - 1 , sum ) != 0 || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) != 0 ) { return tab [ n - 1 , sum ] = 1 ; } else return tab [ n - 1 , sum ] = 0 ; } } public static void Main ( String [ ] args ) { int n = 5 ; int [ ] a = { 1 , 5 , 3 , 7 , 4 } ; int sum = 12 ; if ( subsetSum ( a , n , sum ) != 0 ) { Console . Write ( \" YES STRNEWLINE \" ) ; } else Console . Write ( \" NO STRNEWLINE \" ) ; } }"}
{"text": "Jumlah perbezaan bit untuk nombor dari 0 hingga n | C # Program untuk pendekatan di atas; Berfungsi untuk melaksanakan eksponensi cepat; Berfungsi untuk mengembalikan nilai untuk kuasa 2; Berfungsi untuk menukar n ke dalam binari; Untuk menyimpan perwakilan binari; Melepasi setiap digit n; Mengembalikan perwakilan binari; Berfungsi untuk mencari perbezaan bit; Dapatkan perwakilan binari; Jumlah bilangan perbezaan bit dari 0 hingga n; Melangkah ke atas setiap bit binari; Jika bit semasa adalah '1' kemudian tambahkan kiraan bit semasa; Kod pemacu; Nombor yang diberikan; Panggilan fungsi", "code": "using System ; class GFG { static int binpow ( int a , int b ) { int res = 1 ; while ( b > 0 ) { if ( b % 2 == 1 ) res = res * a ; a = a * a ; b /= 2 ; } return res ; } static int find ( int x ) { if ( x == 0 ) return 0 ; int p = ( int ) ( Math . Log ( x ) / Math . Log ( 2 ) ) ; return binpow ( 2 , p + 1 ) - 1 ; } static String getBinary ( int n ) { String ans = \" \" ; while ( n > 0 ) { int dig = n % 2 ; ans += dig ; n /= 2 ; } return ans ; } static int totalCountDifference ( int n ) { string ans = getBinary ( n ) ; int req = 0 ; for ( int i = 0 ; i < ans . Length ; i ++ ) { if ( ans [ i ] == '1' ) { req += find ( binpow ( 2 , i ) ) ; } } return req ; } public static void Main ( ) { int n = 5 ; Console . Write ( totalCountDifference ( n ) ) ; } }"}
{"text": "Cari panjang maksimum awalan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan panjang maksimum awalan yang diperlukan; Array untuk menyimpan kekerapan setiap elemen array; Melangkah untuk semua elemen; Kemas kini kekerapan elemen semasa i. e. v; Disusun nilai positif dari array Count; Jika awalan semasa memenuhi syarat yang diberikan; Mengembalikan panjang maksimum; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int Maximum_Length ( List < int > a ) { int [ ] counts = new int [ 11 ] ; int ans = 0 ; for ( int index = 0 ; index < a . Count ; index ++ ) { counts [ a [ index ] ] += 1 ; List < int > k = new List < int > ( ) ; foreach ( int i in counts ) if ( i != 0 ) k . Add ( i ) ; k . Sort ( ) ; if ( k . Count == 1 || ( k [ 0 ] == k [ k . Count - 2 ] && k [ k . Count - 1 ] - k [ k . Count - 2 ] == 1 ) || ( k [ 0 ] == 1 && k [ 1 ] == k [ k . Count - 1 ] ) ) ans = index ; } return ans + 1 ; } static void Main ( ) { List < int > a = new List < int > ( new int [ ] { 1 , 1 , 1 , 2 , 2 , 2 } ) ; Console . Write ( Maximum_Length ( a ) ) ; } }"}
{"text": "Pertanyaan dalam talian untuk GCD Array Selepas Membahagikan Operasi | C # pelaksanaan pendekatan; Mengembalikan GCD selepas semua kemas kini dalam array; Fungsi untuk mengira GCD pertanyaan onine; menyimpan GCD elemen array awal; mengira GCD; melakukan pertanyaan dalam talian; Indeks adalah 1 berdasarkan; Bahagikan elemen array; mengira GCD semasa; Cetak GCD selepas setiap langkah; Kod pemacu", "code": "using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void print_gcd_online ( int n , int m , int [ , ] query , int [ ] arr ) { int max_gcd = 0 ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) max_gcd = gcd ( max_gcd , arr [ i ] ) ; for ( i = 0 ; i < m ; i ++ ) { query [ i , 0 ] -- ; arr [ query [ i , 0 ] ] /= query [ i , 1 ] ; max_gcd = gcd ( arr [ query [ i , 0 ] ] , max_gcd ) ; Console . WriteLine ( max_gcd ) ; } } public static void Main ( ) { int n = 3 ; int m = 3 ; int [ , ] query = new int [ m , 2 ] ; int [ ] arr = new int [ ] { 36 , 24 , 72 } ; query [ 0 , 0 ] = 1 ; query [ 0 , 1 ] = 3 ; query [ 1 , 0 ] = 3 ; query [ 1 , 1 ] = 12 ; query [ 2 , 0 ] = 2 ; query [ 2 , 1 ] = 4 ; print_gcd_online ( n , m , query , arr ) ; } }"}
{"text": "Nombor dalam julat [l, r] supaya kiraan pembahagi mereka adalah kedua -duanya dan perdana | C # pelaksanaan pendekatan; Kedai sama ada nombor itu adalah perdana atau tidak; menyimpan kiraan nombor perdana kurang daripada atau sama dengan indeks; buat penapis; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaan sebagai benar. Nilai dalam perdana [i] akhirnya akan palsu jika 'i' bukanlah perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; menyimpan jumlah awalan bilangan prima kurang daripada atau sama dengan 'i'; Kod pemacu; buat penapis; 'l' dan 'r' adalah batas bawah dan atas julat; Dapatkan nilai kiraan; Paparkan kiraan", "code": "using System ; class GFG { static int MAX = 1000000 ; static bool [ ] prime = new bool [ MAX + 1 ] ; static int [ ] sum = new int [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= MAX ; i ++ ) sum [ i ] = 0 ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( int i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } } public static void Main ( ) { SieveOfEratosthenes ( ) ; int l = 3 , r = 9 ; int c = ( sum [ r ] - sum [ l - 1 ] ) ; Console . WriteLine ( \" Count : ▁ \" + c ) ; } }"}
{"text": "Kawasan bulatan yang ditulis dalam segi empat tepat yang tertulis dalam separuh bulatan | C # Program untuk mencari kawasan bulatan yang ditulis dalam segi empat tepat yang seterusnya ditulis dalam separuh bulatan; Berfungsi untuk mencari kawasan bulatan; Radius tidak boleh negatif; kawasan bulatan; Kod pemacu", "code": "using System ; class GFG { static float area ( float r ) { if ( r < 0 ) return - 1 ; float area = ( float ) ( 3.14 * Math . Pow ( r / ( 2 * Math . Sqrt ( 2 ) ) , 2 ) ) ; return area ; } static public void Main ( String [ ] args ) { float a = 5 ; Console . WriteLine ( area ( a ) ) ; } }"}
{"text": "Cari kiraan nombor hampir perdana dari 1 hingga n | C # Program untuk mengira hampir nombor perdana dari 1 hingga n; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Fungsi untuk mengira hampir nombor utama dari 1 hingga n; untuk menyimpan jawapan yang diperlukan; 6 adalah nombor hampir perdana pertama; untuk mengira faktor utama; Jika ia sempurna persegi; Sekiranya saya hampir nombor utama; Kod pemacu", "code": "using System ; class GFG { static int N = 100005 ; static bool [ ] prime = new bool [ N ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < N ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < N ; i += p ) prime [ i ] = false ; } } } static int almostPrimes ( int n ) { int ans = 0 ; for ( int i = 6 ; i <= n ; i ++ ) { int c = 0 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) { if ( prime [ j ] ) c ++ ; } else { if ( prime [ j ] ) c ++ ; if ( prime [ i / j ] ) c ++ ; } } } if ( c == 2 ) ans ++ ; } return ans ; } public static void Main ( ) { SieveOfEratosthenes ( ) ; int n = 21 ; Console . WriteLine ( almostPrimes ( n ) ) ; } }"}
{"text": "Bahagikan nombor menjadi dua bahagian supaya jumlah digit adalah maksimum | C # Pelaksanaan pendekatan di atas mengembalikan jumlah digit x; Mengembalikan jumlah digit X; Mengembalikan nombor terdekat kepada X dari segi 9. ; Kod pemacu", "code": "using System ; class GFG { static int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x != 0 ) { ans += x % 10 ; x /= 10 ; } return ans ; } static int closest ( int x ) { int ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; } static int sumOfDigitsTwoParts ( int N ) { int A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; } public static void Main ( ) { int N = 35 ; Console . Write ( sumOfDigitsTwoParts ( N ) ) ; } }"}
{"text": "Ujian Primal | Tetapkan 5 (menggunakan Program Lucas | C # untuk memeriksa primal menggunakan siri lucas - lehmer.; Berfungsi untuk memeriksa sama ada (2 ^ p - 1) adalah perdana atau tidak.", "code": "using System ; class GFG { static bool isPrime ( int p ) { double checkNumber = Math . Pow ( 2 , p ) - 1 ; double nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; } static void Main ( ) { int p = 7 ; double checkNumber = Math . Pow ( 2 , p ) - 1 ; if ( isPrime ( p ) ) Console . WriteLine ( ( int ) checkNumber + \" ▁ is ▁ Prime . \" ) ; else Console . WriteLine ( ( int ) checkNumber + \" ▁ is ▁ not ▁ Prime . \" ) ; } }"}
{"text": "Sophie Germain Prime | C # Program untuk mencetak semua nombor utama Sophie Jerman sehingga n. ; Fungsi untuk mengesan nombor perdana di sini kami telah menggunakan kaedah penapis https: www. Geeksforgeeks. org / sieve - of - eratosthenes / untuk mengesan nombor perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Kami telah membuat array sehingga 2 * n + 1 supaya kami dapat memeriksa nombor perdana sehingga itu dan menyimpulkan tentang Sophie Jerman Prime. ; Memeriksa setiap saya sama ada Sophie Jerman Perdana atau tidak. ; Kod pemacu", "code": "using System ; class GFG { static void sieve ( int n , bool [ ] prime ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < n ; i += p ) prime [ i ] = false ; } } } static void printSophieGermanNumber ( int n ) { bool [ ] prime = new bool [ 2 * n + 1 ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) { prime [ i ] = true ; } sieve ( 2 * n + 1 , prime ) ; for ( int i = 2 ; i < n ; ++ i ) { if ( prime [ i ] && prime [ 2 * i + 1 ] ) Console . Write ( i + \" ▁ \" ) ; } } static void Main ( ) { int n = 25 ; printSophieGermanNumber ( n ) ; } }"}
{"text": "Interpolasi Bessel | C # Program untuk interpolasi menggunakan interpolasi Bessel; mengira anda disebut dalam formula; mengira faktorial nombor n; Kod pemacu; Bilangan nilai yang diberikan; y [,] digunakan untuk jadual perbezaan dengan y [, 0] digunakan untuk input; Mengira jadual perbezaan pusat; Memaparkan jadual perbezaan pusat; nilai untuk interpolasi pada; Memulakan u dan jumlah; k ialah asalnya ialah F (0); jika ((n % 2)> 0) asal untuk ganjil; k = n / 2 - 1; Asal untuk walaupun; Menyelesaikan menggunakan formula Bessel", "code": "class GFG { static double ucal ( double u , int n ) { if ( n == 0 ) return 1 ; double temp = u ; for ( int i = 1 ; i <= n / 2 ; i ++ ) temp = temp * ( u - i ) ; for ( int i = 1 ; i < n / 2 ; i ++ ) temp = temp * ( u + i ) ; return temp ; } static int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } public static void Main ( ) { int n = 6 ; double [ ] x = { 25 , 26 , 27 , 28 , 29 , 30 } ; double [ , ] y = new double [ n , n ] ; y [ 0 , 0 ] = 4.000 ; y [ 1 , 0 ] = 3.846 ; y [ 2 , 0 ] = 3.704 ; y [ 3 , 0 ] = 3.571 ; y [ 4 , 0 ] = 3.448 ; y [ 5 , 0 ] = 3.333 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < n - i ; j ++ ) y [ j , i ] = y [ j + 1 , i - 1 ] - y [ j , i - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) System . Console . Write ( y [ i , j ] + \" TABSYMBOL \" ) ; System . Console . WriteLine ( \" \" ) ; } double value = 27.4 ; double sum = ( y [ 2 , 0 ] + y [ 3 , 0 ] ) / 2 ; int k ; k = n / 2 ; else double u = ( value - x [ k ] ) / ( x [ 1 ] - x [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( i % 2 ) > 0 ) sum = sum + ( ( u - 0.5 ) * ucal ( u , i - 1 ) * y [ k , i ] ) / fact ( i ) ; else sum = sum + ( ucal ( u , i ) * ( y [ k , i ] + y [ -- k , i ] ) / ( fact ( i ) * 2 ) ) ; } System . Console . WriteLine ( \" Value ▁ at ▁ \" + value + \" ▁ is ▁ \" + System . Math . Round ( sum , 5 ) ) ; } }"}
{"text": "Cara yang cekap untuk memeriksa sama ada N | Program C # mudah untuk memeriksa sama ada nombor Fibonacci N - Th adalah pelbagai daripada 10 .; Pulangan benar jika nombor fibonacci n - th adalah berganda dari 10 .; fungsi utama", "code": "using System ; class GFG { static int fibonacci ( int n ) { int a = 0 ; int b = 1 ; int c = 0 ; if ( n <= 1 ) return n ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; } static bool isMultipleOf10 ( int n ) { int f = fibonacci ( 30 ) ; return ( f % 10 == 0 ) ; } public static void Main ( ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 | C # Program untuk pendekatan di atas; Fungsi yang memeriksa sama ada nombor adalah kuasa 2; Kes asas '1' adalah satu -satunya nombor ganjil yang merupakan kuasa 2 (2 ^ 0); Semua nombor ganjil yang lain bukan kuasa 2; Panggilan fungsi rekursif; Kod pemacu; Benar; Palsu", "code": "using System ; class GFG { static bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } static void Main ( ) { int n = 64 ; int m = 12 ; if ( powerOf2 ( n ) ) { Console . Write ( \" True \" + \" STRNEWLINE \" ) ; } else { Console . Write ( \" False \" + \" STRNEWLINE \" ) ; } if ( powerOf2 ( m ) ) { Console . Write ( \" True \" ) ; } else { Console . Write ( \" False \" ) ; } } }"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 | C # Program untuk memeriksa kuasa untuk 2; Kaedah untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Kaedah Pemandu", "code": "using System ; class GFG { static bool isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; } public static void Main ( ) { Console . WriteLine ( isPowerOfTwo ( 31 ) ? \" Yes \" : \" No \" ) ; Console . WriteLine ( isPowerOfTwo ( 64 ) ? \" Yes \" : \" No \" ) ; } }"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 | C # Program pendekatan di atas; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "using System ; public class GFG { static bool isPowerofTwo ( int n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; } public static void Main ( String [ ] args ) { if ( isPowerofTwo ( 30 ) == true ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; if ( isPowerofTwo ( 128 ) == true ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Kuasa terkecil 2 yang lebih besar daripada atau sama dengan jumlah unsur array | C # pelaksanaan pendekatan di atas; Berfungsi untuk mencari kuasa terdekat 2; Nombornya; Jika sudah menjadi kuasa 2; Cari kuasa seterusnya 2; Berfungsi untuk mencari memori yang digunakan; Jumlah array; Melintasi dan mencari jumlah array; Fungsi panggilan untuk mencari kuasa terdekat 2; Kod pemacu", "code": "using System ; class GFG { static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } static int memoryUsed ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int nearest = nextPowerOf2 ( sum ) ; return nearest ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 2 } ; int n = arr . Length ; Console . WriteLine ( memoryUsed ( arr , n ) ) ; } }"}
{"text": "Toggling k | C # Program ke TOOGLE K - TH BIT dari nombor; fungsi utama", "code": "using System ; class GFG { static int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; } public static void Main ( ) { int n = 5 , k = 1 ; Console . WriteLine ( toggleKthBit ( n , k ) ) ; } }"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | C # Program untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Pertama n dalam keadaan di bawah adalah untuk kes di mana n adalah 0; Kod pemacu", "code": "using System ; class GFG { static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } public static void Main ( ) { int n = 0 ; Console . WriteLine ( nextPowerOf2 ( n ) ) ; } }"}
{"text": "Nombor kth dari set gandaan nombor A, B dan C | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan GCD A dan B; Berfungsi untuk mengembalikan LCM A dan B; Berfungsi untuk mengembalikan elemen kth dari set yang diperlukan jika ia berganda A; Mula dan tamat untuk carian binari; Jika tiada jawapan yang dijumpai kembali - 1; Kemasukan dan pengecualian; Pelbagai harus lebih kecil; Pelbagai harus lebih besar; Berfungsi untuk mengembalikan elemen kth dari set yang diperlukan jika ia berbilang b; Mula dan tamat untuk carian binari; Jika tiada jawapan yang dijumpai kembali - 1; Kemasukan dan pengecualian; Pelbagai harus lebih kecil; Pelbagai harus lebih besar; Berfungsi untuk mengembalikan elemen kth dari set yang diperlukan jika ia berbilang C; Mula dan tamat untuk carian binari; Jika tiada jawapan yang dijumpai kembali - 1; Kemasukan dan pengecualian; Pelbagai harus lebih kecil; Pelbagai harus lebih besar; Berfungsi untuk mengembalikan elemen KTH dari set gandaan A, B dan C; Memohon carian binari pada gandaan A; Sekiranya elemen yang diperlukan bukanlah pelbagai A maka gandaan B dan C perlu diperiksa; Sekiranya elemen yang diperlukan bukanlah pelbagai atau pelbagai b maka gandaan C perlu diperiksa; Kod pemacu", "code": "using System ; class GFG { static int gcd ( int A , int B ) { if ( B == 0 ) return A ; return gcd ( B , A % B ) ; } static int lcm ( int A , int B ) { return ( A * B ) / gcd ( A , B ) ; } static int checkA ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = A * mid ; int divA = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } static int checkB ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = B * mid ; int divB = mid - 1 ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } static int checkC ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = C * mid ; int divC = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } static int findKthMultiple ( int A , int B , int C , int K ) { int res = checkA ( A , B , C , K ) ; if ( res == - 1 ) res = checkB ( A , B , C , K ) ; if ( res == - 1 ) res = checkC ( A , B , C , K ) ; return res ; } public static void Main ( String [ ] args ) { int A = 2 , B = 4 , C = 5 , K = 5 ; Console . WriteLine ( findKthMultiple ( A , B , C , K ) ) ; } }"}
{"text": "Tambah elemen dalam mula menyusun array | Variasi Stalin Sort | C # pelaksanaan untuk menyusun array dengan menggunakan variasi jenis Stalin; Berfungsi untuk menyusun array; Iterator <Integer> index = arr. iterator (); ; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; using System . Linq ; class GFG { static void variationStalinsort ( List < int > arr ) { int j = 0 ; while ( true ) { int moved = 0 ; for ( int i = 0 ; i < ( arr . Count - 1 - j ) ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { int index ; int temp ; index = arr [ i ] ; temp = arr [ i + 1 ] ; arr . Remove ( index ) ; arr . Insert ( i , temp ) ; arr . Remove ( temp ) ; arr . Insert ( i + 1 , index ) ; moved ++ ; } } j ++ ; if ( moved == 0 ) { break ; } } foreach ( int i in arr ) Console . Write ( i + \" ▁ \" ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 2 , 1 , 4 , 3 , 6 , 5 , 8 , 7 , 10 , 9 } ; List < int > arr1 = new List < int > ( ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) arr1 . Add ( arr [ i ] ) ; variationStalinsort ( arr1 ) ; } }"}
{"text": "Susun array yang mengandungi nilai 1 hingga n dalam o (n) menggunakan jenis kitaran | C # Program untuk pendekatan di atas; Berfungsi untuk mencetak elemen array; Melintasi array; Berfungsi untuk menyusun array dalam O (n); Melintasi array; Jika elemen semasa berada pada kedudukan yang betul; Lain menukar elemen semasa dengan kedudukan yang betul; Swap nilai arr [i] dan arr [arr [i] - 1]; Kod pemacu; Fungsi panggilan untuk menyusun array; Fungsi panggilan untuk mencetak array", "code": "using System ; class GFG { public static void printArray ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } } public static void sortArray ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; ) { if ( arr [ i ] == i + 1 ) { i ++ ; } else { int temp1 = arr [ i ] ; int temp2 = arr [ arr [ i ] - 1 ] ; arr [ i ] = temp2 ; arr [ temp1 - 1 ] = temp1 ; } } } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 5 , 3 , 4 } ; int N = arr . Length ; sortArray ( arr , N ) ; printArray ( arr , N ) ; } }"}
{"text": "Jumlah maksimum nilai n item dalam 0 | C # pelaksanaan untuk pendekatan di atas; Berfungsi untuk mencari nilai maksimum; keadaan asas; Unsur k telah dikurangkan kepada separuh daripada berat badan mereka; Jangan sertakan item; Jika berat item kurang daripada atau sama dengan berat yang tinggal maka masukkan item; Mengembalikan maksimum kedua -dua kes; Jika pengurangan berat badan kepada separuh mungkin; Langkau item; Sertakan item dengan berat penuh jika berat item kurang daripada berat badan yang tinggal; Sertakan item dengan separuh berat jika separuh berat item kurang daripada berat badan yang tinggal; Mengembalikan maksimum semua 3 kes; Kod pemacu", "code": "using System ; public class GFG { static int maximum ( int [ ] value , int [ ] weight , int weight1 , int flag , int K , int index ) { if ( index >= value . Length ) { return 0 ; } if ( flag == K ) { int skip = maximum ( value , weight , weight1 , flag , K , index + 1 ) ; int full = 0 ; if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 ) ; } return Math . Max ( full , skip ) ; } else { int skip = maximum ( value , weight , weight1 , flag , K , index + 1 ) ; int full = 0 ; int half = 0 ; if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 ) ; } if ( weight [ index ] / 2 <= weight1 ) { half = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] / 2 , flag , K , index + 1 ) ; } return Math . Max ( full , Math . Max ( skip , half ) ) ; } } public static void Main ( String [ ] args ) { int [ ] value = { 17 , 20 , 10 , 15 } ; int [ ] weight = { 4 , 2 , 7 , 5 } ; int K = 1 ; int W = 4 ; Console . WriteLine ( maximum ( value , weight , W , 0 , K , 0 ) ) ; } }"}
{"text": "D | C # Program untuk mencari saiz set dominasi minimum pokok; Definisi nod pokok; Fungsi penolong yang memperuntukkan nod baru; Array DP untuk precompute dan menyimpan hasilnya; mindominatingsettion untuk mengembalikan saiz set dominasi minimum array; Kes asas; Menetapkan nilai wajib jika diperlukan; Semak sama ada jawapannya telah dikira; Jika ia adalah wajib untuk memilih nod; Pilih nod dan tetapkan anak -anaknya seperti yang dilindungi; Jika ia dilindungi; Sekiranya nod semasa tidak dilindungi atau tidak perlu dipilih secara paksa; Simpan hasilnya; Kod pemacu; Memulakan array DP; Membina pokok", "code": "using System ; class GFG { static readonly int N = 1005 ; public class Node { public int data ; public Node left , right ; } ; public static Node newNode ( int data ) { Node node = new Node ( ) ; node . data = data ; node . left = node . right = null ; return node ; } static int [ , , ] dp = new int [ N , 5 , 5 ] ; static int minDominatingSet ( Node root , int covered , int compulsory ) { if ( root == null ) return 0 ; if ( root . left != null && root . right != null && covered > 0 ) compulsory = 1 ; if ( dp [ root . data , covered , compulsory ] != - 1 ) return dp [ root . data , covered , compulsory ] ; if ( compulsory > 0 ) { return dp [ root . data , covered , compulsory ] = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; } if ( covered > 0 ) { return dp [ root . data , covered , compulsory ] = Math . Min ( 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } int ans = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; if ( root . left != null ) { ans = Math . Min ( ans , minDominatingSet ( root . left , 0 , 1 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } if ( root . right != null ) { ans = Math . Min ( ans , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 1 ) ) ; } return dp [ root . data , covered , compulsory ] = ans ; } public static void Main ( String [ ] args ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < 5 ; j ++ ) { for ( int l = 0 ; l < 5 ; l ++ ) dp [ i , j , l ] = - 1 ; } } Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . left . left = newNode ( 3 ) ; root . left . right = newNode ( 4 ) ; root . left . left . left = newNode ( 5 ) ; root . left . left . left . left = newNode ( 6 ) ; root . left . left . left . right = newNode ( 7 ) ; root . left . left . left . right . right = newNode ( 10 ) ; root . left . left . left . left . left = newNode ( 8 ) ; root . left . left . left . left . right = newNode ( 9 ) ; Console . Write ( minDominatingSet root , 0 , 0 ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Bilangan subset dengan jumlah sifar | C # pelaksanaan pendekatan di atas; pembolehubah untuk menyimpan negeri -negeri DP; Untuk mencari bilangan subset dengan jumlah yang sama dengan 0 kerana S boleh menjadi negatif, kami akan memaksimumkannya untuk menjadikannya positif; Kes asas; Mengembalikan nilai jika keadaan sudah diselesaikan; Jika Negeri tidak dikunjungi, maka teruskan; Hubungan berulang; Mengembalikan nilai; Kod pemacu", "code": "using System ; class GFG { static int maxSum = 100 ; static int arrSize = 51 ; static int [ , ] dp = new int [ arrSize , maxSum ] ; static bool [ , ] visit = new bool [ arrSize , maxSum ] ; static int SubsetCnt ( int i , int s , int [ ] arr , int n ) { if ( i == n ) { if ( s == 0 ) { return 1 ; } else { return 0 ; } } if ( visit [ i , s + arrSize ] ) { return dp [ i , s + arrSize ] ; } visit [ i , s + arrSize ] = true ; dp [ i , s + arrSize ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ; return dp [ i , s + arrSize ] ; } public static void Main ( ) { int [ ] arr = { 2 , 2 , 2 , - 4 , - 4 } ; int n = arr . Length ; Console . WriteLine ( SubsetCnt ( 0 , 0 , arr , n ) ) ; } }"}
{"text": "Bilangan rentetan binari panjang n dengan k bit set bersebelahan | C # Program untuk mencari bilangan rentetan bit panjang n dengan k bit set bersebelahan; Berfungsi untuk mencari bilangan rentetan bit panjang n dengan k bit set bersebelahan; Kes asas apabila kita membentuk rentetan panjang n; jika f (bit string) = k, hitung cara ini; Semak sama ada bit terakhir ditetapkan, jika ditetapkan maka hubungi indeks seterusnya dengan menambah kiraan bit bersebelahan lain, hubungi indeks seterusnya dengan nilai yang sama dari kiraan bit bersebelahan dan sama ada tetapkan bit pada indeks semasa atau biarkan ia tetap tidak tersembunyi; Tetapkan bit pada CurrentIndex; tidak jelas sedikit pada currentIndex; Kod pemacu; dp [i, j, k] mewakili rentetan panjang panjang i dengan f (bit string) = j dan bit terakhir sebagai k; memulakan DP; Jumlah cara = (cara dengan meletakkan bit 1 st 1 + cara dengan meletakkan bit 1 sebagai 0)", "code": "using System ; class GFG { static readonly int MAX = 1000 ; static int waysToKAdjacentSetBits ( int [ , , ] dp , int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) { if ( currentIndex == n ) { if ( adjacentSetBits == k ) return 1 ; return 0 ; } if ( dp [ currentIndex , adjacentSetBits , lastBit ] != - 1 ) { return dp [ currentIndex , adjacentSetBits , lastBit ] ; } int noOfWays = 0 ; if ( lastBit == 1 ) { noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( lastBit == 0 ) { noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } dp [ currentIndex , adjacentSetBits , lastBit ] = noOfWays ; return noOfWays ; } public static void Main ( String [ ] args ) { int n = 5 , k = 2 ; int [ , , ] dp = new int [ MAX , MAX , 2 ] ; for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) for ( int k1 = 0 ; k1 < 2 ; k1 ++ ) dp [ i , j , k1 ] = - 1 ; int totalWays = waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 0 ) ; Console . Write ( \" Number ▁ of ▁ ways ▁ = ▁ \" + totalWays + \" STRNEWLINE \" ) ; } }"}
{"text": "Nombor Tetranacci | Ruang yang dioptimumkan berdasarkan program C # untuk mencetak nombor Tetranacci Nth; Berfungsi untuk mencetak nombor tetranacci N - th; Memulakan empat nombor pertama untuk kes asas; mengisytiharkan pemboleh ubah semasa; Gelung untuk menambah empat nombor sebelumnya untuk setiap nombor bermula dari 4 dan kemudian berikan pertama, kedua, ketiga hingga kedua, ketiga, keempat dan curr masing -masing; Kod pemacu", "code": "using System ; class GFG { static void printTetra ( int n ) { if ( n < 0 ) return ; int first = 0 , second = 1 ; int third = 1 , fourth = 2 ; int curr = 0 ; if ( n == 0 ) Console . Write ( first ) ; else if ( n == 1 n == 2 ) Console . Write ( second ) ; else if ( n == 3 ) Console . Write ( fourth ) ; else { for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } Console . Write ( curr ) ; } } static public void Main ( ) { int n = 10 ; printTetra ( n ) ; } }"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Program untuk mencari tangga n - menggunakan saiz langkah 1 atau 2 atau 3 .; Fungsi rekursif yang digunakan oleh Countways; Fungsi pemacu", "code": "using System ; public class GfG { public static int countWays ( int n ) { int [ ] res = new int [ n + 2 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( countWays ( n ) ) ; } }"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Program C # untuk mengira beberapa cara untuk mencapai tangga nth ketika; Fungsi rekursif yang digunakan oleh Countways; Mengisytiharkan tiga pembolehubah dan memegang cara untuk tiga tangga pertama; Pemboleh ubah keempat; Bermula dari 4 seperti yang telah dikira untuk 3 tangga; Kod pemacu", "code": "using System ; class GFG { static int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; } public static void Main ( String [ ] args ) { int n = 4 ; Console . Write ( countWays ( n ) ) ; } }"}
{"text": "Subset Jumlah Masalah di O (SUM) Ruang |  ; Memulakan dengan 1 sebagai jumlah 0 selalu mungkin; gelung untuk melalui setiap elemen array elemen; untuk menukar nilai semua nilai jumlah yang mungkin kepada 1; jika jumlahnya mungkin kemudian kembali 1; Kod pemacu", "code": "using System ; class GFG { static Boolean isPossible ( int [ ] elements , int sum ) { int [ ] dp = new int [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < elements . Length ; i ++ ) { for ( int j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; } public static void Main ( String [ ] args ) { int [ ] elements = { 6 , 2 , 5 } ; int sum = 7 ; if ( isPossible ( elements , sum ) ) Console . Write ( \" YES \" ) ; else Console . Write ( \" NO \" ) ; } }"}
{"text": "Pengaturcaraan Dinamik | Tinggi | Program C # rekursif naif untuk mencari tugas maksimum. ; Mengembalikan jumlah tugas maksimum yang boleh dilakukan sehingga hari n; Jika n kurang daripada sama dengan 0, maka tiada penyelesaian wujud; Menentukan tugas mana yang hendak dipilih pada hari n, kemudian mengembalikan maksimum sehingga hari itu; Kod pemacu", "code": "using System ; class GFG { static int maxTasks ( int [ ] high , int [ ] low , int n ) { if ( n <= 0 ) return 0 ; return Math . Max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; } public static void Main ( ) { int n = 5 ; int [ ] high = { 3 , 6 , 8 , 7 , 6 } ; int [ ] low = { 1 , 5 , 4 , 5 , 3 } ; Console . Write ( maxTasks ( high , low , n ) ) ; } }"}
{"text": "Koefisien binomial | DP |  ; Berfungsi untuk mencari GCD dua nombor dalam O (log (min (a, b))); Kes asas; C (n, r) = c (n, n - r) kerumitan masa yang lebih baik untuk nilai r yang lebih rendah; Pelbagai elemen dari N - r + 1 hingga n; Untuk nombor dari 1 hingga r mencari arr [j] seperti gcd (i, arr [j])> 1; Jika GCD> 1, bahagikan kedua -duanya oleh GCD; Jika saya menjadi 1, tidak perlu mencari arr; Pas tunggal untuk membiak pengangka; Kod pemacu", "code": "using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int nCr ( int n , int r ) { if ( r > n ) return 0 ; if ( r > n - r ) r = n - r ; int mod = 1000000007 ; int [ ] arr = new int [ r ] ; for ( int i = n - r + 1 ; i <= n ; i ++ ) { arr [ i + r - n - 1 ] = i ; } long ans = 1 ; for ( int k = 1 ; k < r + 1 ; k ++ ) { int j = 0 , i = k ; while ( j < arr . Length ) { int x = gcd ( i , arr [ j ] ) ; if ( x > 1 ) { arr [ j ] /= x ; i /= x ; } if ( i == 1 ) break ; j += 1 ; } } foreach ( int i in arr ) ans = ( ans * i ) % mod ; return ( int ) ans ; } static public void Main ( ) { int n = 5 , r = 2 ; Console . WriteLine ( \" Value ▁ of ▁ C ( \" + n + \" , ▁ \" + r + \" ) ▁ is ▁ \" + nCr ( n , r ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Watak kth selepas menggantikan setiap watak rentetan dengan kekerapannya tepat x kali | C # Program untuk pendekatan di atas; Fungsi untuk mencari watak kth selepas x hari; Pembolehubah untuk menyimpan kthchar; Melintasi rentetan; Menukar char ke int; Hitung watak; Jika k kurang daripada jumlah daripada ans = str [i]; Jawapan kembali; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static char FindKthChar ( string str , int K , int X ) { char ans = ' ▁ ' ; int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { int digit = ( int ) str [ i ] - 48 ; int range = ( int ) Math . Pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; } public static void Main ( ) { string str = \"123\" ; int K = 9 ; int X = 3 ; char ans = FindKthChar ( str , K , X ) ; Console . Write ( ans ) ; } }"}
{"text": "Jumlah pasangan watak dari dua rentetan, dengan bilangan bit set yang sama dalam nilai ASCII mereka | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan pasangan yang sah; Kekerapan kedai bilangan bit yang ditetapkan untuk S1; Kekerapan kedai bilangan bit yang ditetapkan untuk S2; Kirakan jumlah pasangan; Mengembalikan kiraan pasangan yang sah; Kod pemacu", "code": "using System ; using System . Linq ; class GFG { static int totalPairs ( string s1 , string s2 ) { int count = 0 ; int [ ] arr1 = new int [ 7 ] ; int [ ] arr2 = new int [ 7 ] ; for ( int i = 0 ; i < s1 . Length ; i ++ ) { int set_bits = Convert . ToString ( ( int ) s1 [ i ] , 2 ) . Count ( c => c == '1' ) ; arr1 [ set_bits ] ++ ; } for ( int i = 0 ; i < s2 . Length ; i ++ ) { int set_bits = Convert . ToString ( ( int ) s2 [ i ] , 2 ) . Count ( c => c == '1' ) ; arr2 [ set_bits ] ++ ; } for ( int i = 1 ; i <= 6 ; i ++ ) count += ( arr1 [ i ] * arr2 [ i ] ) ; return count ; } static void Main ( ) { string s1 = \" geeks \" ; string s2 = \" forgeeks \" ; Console . WriteLine ( totalPairs ( s1 , s2 ) ) ; } }"}
{"text": "Kira substrings yang bermula dengan aksara x dan berakhir dengan watak y | C # Pelaksanaan untuk mengira substrings bermula dengan aksara x dan berakhir dengan aksara y; fungsi untuk mengira substrings bermula dengan aksara x dan berakhir dengan watak y; untuk menyimpan jumlah jumlah substring yang diperlukan; Untuk menyimpan kiraan watak 'x' sehingga titik rentetan 'str' telah dilalui setakat ini; Bentuk 'Str' yang tersisa ke kanan; jika benar, kenaikan 'kenaikan _ x'; jika benar mengumpul 'kiraan _ x' ke 'tot _ count'; kiraan yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int countSubstr ( string str , int n , char x , char y ) { int tot_count = 0 ; int count_x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) count_x ++ ; if ( str [ i ] == y ) tot_count += count_x ; } return tot_count ; } public static void Main ( ) { string str = \" abbcaceghcak \" ; int n = str . Length ; char x = ' a ' , y = ' c ' ; Console . Write ( \" Count ▁ = ▁ \" + countSubstr ( str , n , x , y ) ) ; } }"}
{"text": "Kira perkataan dalam rentetan yang diberikan | C # Program untuk mengira tiada kata -kata dari rentetan input yang diberikan. ; mengembalikan bilangan perkataan dalam str; kiraan perkataan; Imbas semua watak satu demi satu; Jika watak seterusnya adalah pemisah, tetapkan keadaan sebagai keluar; Jika watak seterusnya bukan pemisah perkataan dan keadaan keluar, maka tetapkan keadaan seperti dalam dan kiraan kata kenaikan; Pindah ke watak seterusnya; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static int OUT = 0 ; static int IN = 1 ; static int countWords ( String str ) { int state = OUT ; int wc = 0 ; int i = 0 ; while ( i < str . Length ) { if ( str [ i ] == ' ▁ ' str [ i ] == ' STRNEWLINE ' str [ i ] == ' TABSYMBOL ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; } public static void Main ( ) { String str = \" One ▁ two TABSYMBOL three STRNEWLINE ▁ four TABSYMBOL five ▁ \" ; Console . WriteLine ( \" No ▁ of ▁ words ▁ : ▁ \" + countWords ( str ) ) ; } }"}
{"text": "Nombor Enneadecagonal | C # Program untuk mencari nombor enneadecagonal nth; Berfungsi untuk mengira nombor enneadecagonal; Formula untuk mencari nombor enneadecagonal nth; Kod pemacu", "code": "using System ; class GFG { static int nthEnneadecagonal ( int n ) { return ( 17 * n * n - 15 * n ) / 2 ; } static public void Main ( ) { int n = 6 ; Console . Write ( n + \" th ▁ Enneadecagonal ▁ number ▁ : \" ) ; Console . WriteLine ( nthEnneadecagonal ( n ) ) ; } }"}
{"text": "Kawasan lingkaran yang dilampirkan dari persegi | C # Program untuk mencari kawasan bulatan yang dilampirkan; Fungsi ticiity; Kod pemacu", "code": "using System ; class GFG { public static double PI = 3.14159265 ; static float areacircumscribed ( float a ) { return ( a * a * ( float ) ( PI / 2 ) ) ; } public static void Main ( ) { float a = 6 ; Console . Write ( \" ▁ Area ▁ of ▁ an ▁ circumscribed \" + \" ▁ circle ▁ is ▁ : ▁ { 0 } \" , Math . Round ( areacircumscribed ( a ) , 2 ) ) ; } }"}
{"text": "Cari item n yang diedarkan dari item tak terhingga jenis tak terhingga berdasarkan syarat -syarat yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari jenis item yang diberikan mengikut peraturan yang diberikan; Menyimpan kiraan item yang diberikan pada setiap langkah; Melangkah untuk mencari hari ke hari yang diberikan diberikan; Cari bilangan hadiah yang diberikan pada hari adalah hari * (hari + 1) / 2; Melangkah ke atas jenis; Mengembalikan jenis yang dihasilkan; Kod pemacu", "code": "using System ; class GFG { static int itemType ( int n ) { int count = 0 ; int day = 1 ; while ( count + day * ( day + 1 ) / 2 < n ) { count += day * ( day + 1 ) / 2 ; day ++ ; } for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) { return type ; } } return 0 ; } public static void Main ( String [ ] args ) { int N = 10 ; Console . Write ( itemType ( N ) ) ; } }"}
{"text": "Semak jika senarai yang dipautkan disusun (berulang dan rekursif) | C # Program untuk menyemak senarai Linked disusun mengikut urutan menurun atau tidak; Nod senarai yang dipautkan; fungsi untuk menyemak senarai yang dipautkan disusun mengikut urutan menurun atau tidak; Kes asas; Melintasi senarai sehingga nod terakhir dan kembali palsu jika nod lebih kecil daripada atau sama dengan yang seterusnya. ; Kod pemacu", "code": "using System ; class GFG { public class Node { public int data ; public Node next ; } ; static bool isSortedDesc ( Node head ) { if ( head == null ) return true ; if ( head == null ) return true ; for ( Node t = head ; t . next != null ; t = t . next ) if ( t . data <= t . next . data ) return false ; return true ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . next = null ; temp . data = data ; return temp ; } public static void Main ( String [ ] args ) { Node head = newNode ( 7 ) ; head . next = newNode ( 5 ) ; head . next . next = newNode ( 4 ) ; head . next . next . next = newNode ( 3 ) ; if ( isSortedDesc ( head ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Panjang maksimum berturut -turut 1 s atau 0 s selepas membalikkan kebanyakan watak K | C # Program untuk pendekatan di atas; Berfungsi untuk mencari segmen berterusan maksimum aksara C selepas membalikkan kebanyakan aksara K; Menyimpan panjang maksimum; Menyimpan kiraan char 'c'; Permulaan tetingkap; Keluarkan tambahan 'c' dari kiri; Meningkatkan nilai kiri; Mengemas kini panjang maksimum aksara CH; Fungsi untuk mencari panjang maksimum 0 s atau 1 s dengan membalikkan kebanyakan aksara K pada rentetan; Cetak maksimum panjang maksimum 0 s atau 1 s; Kod pemacu", "code": "using System ; public class GFG { static int maxLength ( String str , int n , char c , int k ) { int ans = - 1 ; int cnt = 0 ; int left = 0 ; for ( int right = 0 ; right < n ; right ++ ) { if ( str [ right ] == c ) { cnt ++ ; } while ( cnt > k ) { if ( str [ left ] == c ) { cnt -- ; } left ++ ; } ans = Math . Max ( ans , right - left + 1 ) ; } return ans ; } static int maxConsecutiveSegment ( String S , int K ) { int N = S . Length ; return Math . Max ( maxLength ( S , N , '0' , K ) , maxLength ( S , N , '1' , K ) ) ; } public static void Main ( ) { String S = \"1001\" ; int K = 1 ; Console . WriteLine ( maxConsecutiveSegment ( S , K ) ) ; } }"}
{"text": "Kurangkan syiling yang diperlukan untuk mendapatkan semua nilai yang mungkin sehingga n | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mencari kiraan minimum {1, 2, 5} syiling bernilai diperlukan untuk membuat perubahan semua nilai dalam julat [1, n]; Bilangan 5 duit syiling yang diperlukan; Bilangan 1 duit syiling yang diperlukan; Bilangan 2 syiling bernilai diperlukan; Kod pemacu", "code": "using System ; public class GFG { static void find ( int N ) { int T , F , O ; F = ( int ) ( ( N - 4 ) / 5 ) ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = ( int ) Math . Floor ( ( double ) ( N - 5 * F - O ) / 2 ) ; Console . WriteLine ( \" Count ▁ of ▁ 5 ▁ valueds ▁ coins : ▁ \" + F ) ; Console . WriteLine ( \" Count ▁ of ▁ 2 ▁ valueds ▁ coins : ▁ \" + T ) ; Console . WriteLine ( \" Count ▁ of ▁ 1 ▁ valueds ▁ coins : ▁ \" + O ) ; } public static void Main ( String [ ] args ) { int N = 8 ; find ( N ) ; } }"}
{"text": "Ganti '? 'Untuk menukar rentetan yang diberikan kepada rentetan binari dengan kiraan maksimum' 0 'dan \"10\" | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk memaksimumkan kiraan 0 dan 10 dengan menggantikan watak '? 'hingga' 0 'atau' 1 '; Melintasi rentetan yang diberikan; Sekiranya watak semasa '? '; Gantikan str [i] hingga '0'; Kod pemacu; Diberi rentetan", "code": "using System ; class GFG { static void findMaxOccurence ( char [ ] str , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' ? ' ) { str [ i ] = '0' ; } } Console . Write ( str ) ; } public static void Main ( String [ ] args ) { String str = \"10?0?11\" ; int N = str . Length ; findMaxOccurence ( str . ToCharArray ( ) , N ) ; } }"}
{"text": "Semak jika diberikan rentetan adalah substring rentetan yang dibentuk oleh penggabungan berulang z ke a | C # Program untuk pendekatan di atas; Pemeriksaan fungsi jika rentetan yang diberikan adalah sah atau tidak dan mencetak output; Pembolehubah bendera boolean untuk menandakan jika diberikan rentetan sah; Melintasi rentetan yang diberikan; Jika watak bersebelahan berbeza dengan 1; Jika watak 'A' diikuti oleh 4; Lain flip bendera dan pecahkan dari gelung; Output mengikut pemboleh ubah bendera; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "using System ; class GFG { public static void checkInfinite ( String s ) { bool flag = true ; int N = s . Length ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( s [ i ] == ( char ) ( ( int ) ( s [ i + 1 ] ) + 1 ) ) { continue ; } else if ( s [ i ] == ' a ' && s [ i + 1 ] == ' z ' ) { continue ; } else { flag = false ; break ; } } if ( ! flag ) Console . Write ( \" NO \" ) ; else Console . Write ( \" YES \" ) ; } public static void Main ( String [ ] args ) { String s = \" ecbaz \" ; checkInfinite ( s ) ; } }"}
{"text": "Perubahan minimum dalam lorong yang diperlukan untuk menyeberang semua halangan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum perubahan lorong yang diperlukan; Sekiranya terdapat halangan, maka tambahkan nilai yang sangat besar; Tambah nilai minimum untuk memindahkan Forword dengan atau tanpa melintasi halangan; Mengembalikan nilai minimum dp [0], dp [1] dan dp [2]; Kod pemacu", "code": "using System ; public class GFG { static int minChangeInLane ( int [ ] barrier , int n ) { int [ ] dp = { 1 , 0 , 1 } ; for ( int j = 0 ; j < n ; j ++ ) { int val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = ( int ) 1e6 ; } for ( int i = 0 ; i < 3 ; i ++ ) { if ( val != i + 1 ) { dp [ i ] = Math . Min ( dp [ i ] , Math . Min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } } return Math . Min ( dp [ 0 ] , Math . Min ( dp [ 1 ] , dp [ 2 ] ) ) ; } static public void Main ( ) { int [ ] barrier = { 0 , 1 , 2 , 3 , 0 } ; int N = barrier . Length ; Console . Write ( minChangeInLane ( barrier , N ) ) ; } }"}
{"text": "Pertanyaan untuk mengira kumpulan pelajar N yang mungkin mempunyai jumlah penilaian dalam julat yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan cara untuk mendapatkan kumpulan jumlah yang diberikan; Arahan DP Inisiasi; Tandakan semua nilai baris 1 sebagai 1 sejak tikar [0, i] adalah semua jumlah yang mungkin dalam baris pertama; Betulkan baris ith; Betulkan jumlahnya; Melewati semua nilai baris ith; Jika jumlah boleh diperolehi; Cari Jumlah awalan baris terakhir; Melintasi setiap pertanyaan; Tidak ada cara untuk membentuk kumpulan; Kod pemacu; Diberikan N Batch dan K pelajar; Diberikan penilaian; Diberikan pertanyaan; Panggilan fungsi", "code": "using System ; class GFG { public static void numWays ( int [ , ] ratings , int [ , ] queries , int n , int k ) { int [ , ] dp = new int [ n , 10000 + 2 ] ; for ( int i = 0 ; i < k ; i ++ ) dp [ 0 , ratings [ 0 , i ] ] += 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int sum = 0 ; sum <= 10000 ; sum ++ ) { for ( int j = 0 ; j < k ; j ++ ) { if ( sum >= ratings [ i , j ] ) dp [ i , sum ] += dp [ i - 1 , sum - ratings [ i , j ] ] ; } } } for ( int sum = 1 ; sum <= 10000 ; sum ++ ) { dp [ n - 1 , sum ] += dp [ n - 1 , sum - 1 ] ; } for ( int q = 0 ; q < queries . GetLength ( 0 ) ; q ++ ) { int a = queries [ q , 0 ] ; int b = queries [ q , 1 ] ; Console . Write ( dp [ n - 1 , b ] - dp [ n - 1 , a - 1 ] + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int N = 2 , K = 3 ; int [ , ] ratings = { { 1 , 2 , 3 } , { 4 , 5 , 6 } } ; int [ , ] queries = { { 6 , 6 } , { 1 , 6 } } ; numWays ( ratings , queries , N , K ) ; } }"}
{"text": "Bilangan permutasi dengan inversions k | Tetapkan 2 | C # Program untuk pendekatan di atas; Berfungsi untuk mengira permutasi dengan penyongsangan k; Menyimpan bilangan permutasi dengan penyongsangan K; Jika n = 1 hanya 1 permutasi tanpa penyongsangan; Untuk k = 0 hanya 1 permutasi tanpa penyongsangan; Sebaliknya mengemas kini setiap keadaan DP mengikut hubungan reccurrance yang terbentuk; Cetak kiraan akhir; Kod pemacu; Diberikan n dan k; Panggilan fungsi", "code": "using System ; class GFG { static void numberOfPermWithKInversion ( int N , int K ) { int [ , ] dp = new int [ 2 , K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) { dp [ i % 2 , j ] = ( j == 0 ) ? 1 : 0 ; } else if ( j == 0 ) dp [ i % 2 , j ] = 1 ; else dp [ i % 2 , j ] = ( dp [ i % 2 , j - 1 ] % mod + ( dp [ 1 - i % 2 , j ] - ( ( Math . Max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 , Math . Max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } } Console . WriteLine ( dp [ N % 2 , K ] ) ; } public static void Main ( ) { int N = 3 , K = 2 ; numberOfPermWithKInversion ( N , K ) ; } }"}
{"text": "Laluan Jumlah Maksimum dalam Matriks | Tiada baris dan lajur; Mengisytiharkan matriks maksimum 100 baris dan 100 lajur; Variabel yang dikunjungi digunakan untuk menjejaki semua DP Variable Posisi yang dikunjungi digunakan untuk menyimpan jumlah maksimum sehingga kedudukan semasa; Untuk menyimpan jumlah semasa; Untuk kemas kini berterusan jumlah maksimum yang diperlukan; Berfungsi untuk memasukkan matriks saiz n * m; Fungsi untuk mengira jumlah maksimum jalan; Memeriksa keadaan sempadan; Memeriksa sama ada atau tidak (i, j) dikunjungi; Menandakan (i, j) dikunjungi; Memeriksa sama ada kedudukan tidak melawat baris terakhir atau lajur terakhir.  Membuat panggilan rekursif untuk semua langkah yang mungkin dari sel semasa dan kemudian menambah maksimum yang dikembalikan oleh panggilan dan mengemas kini. ; Memeriksa sama ada kedudukan telah mencapai baris terakhir; Jika kedudukan berada di lajur terakhir; Mengemas kini jumlah maksimum sehingga kedudukan semasa dalam DP; Mengembalikan nilai maksimum yang dikemas kini; Kod pemacu; Memanggil fungsi yang dilaksanakan", "code": "using System ; class GFG { static readonly int N = 100 ; static int n , m ; static int [ , ] a = new int [ N , N ] ; static int [ , ] dp = new int [ N , N ] ; static int [ , ] visited = new int [ N , N ] ; static int current_sum = 0 ; static int total_sum = 0 ; static void inputMatrix ( ) { n = 3 ; m = 3 ; a [ 0 , 0 ] = 500 ; a [ 0 , 1 ] = 100 ; a [ 0 , 2 ] = 230 ; a [ 1 , 0 ] = 1000 ; a [ 1 , 1 ] = 300 ; a [ 1 , 2 ] = 100 ; a [ 2 , 0 ] = 200 ; a [ 2 , 1 ] = 1000 ; a [ 2 , 2 ] = 200 ; } static int maximum_sum_path ( int i , int j ) { if ( i == n - 1 && j == m - 1 ) return a [ i , j ] ; if ( visited [ i , j ] != 0 ) return dp [ i , j ] ; visited [ i , j ] = 1 ; int total_sum = 0 ; if ( i < n - 1 & j < m - 1 ) { int current_sum = Math . Max ( maximum_sum_path ( i , j + 1 ) , Math . Max ( maximum_sum_path ( i + 1 , j + 1 ) , maximum_sum_path ( i + 1 , j ) ) ) ; total_sum = a [ i , j ] + current_sum ; } else if ( i == n - 1 ) total_sum = a [ i , j ] + maximum_sum_path ( i , j + 1 ) ; else total_sum = a [ i , j ] + maximum_sum_path ( i + 1 , j ) ; dp [ i , j ] = total_sum ; return total_sum ; } public static void Main ( String [ ] args ) { inputMatrix ( ) ; int maximum_sum = maximum_sum_path ( 0 , 0 ) ; Console . WriteLine ( maximum_sum ) ; } }"}
{"text": "Treasure and Cities | K ialah indeks semasa dan col adalah warna sebelumnya. ; Kes asas; Semak sama ada warna bandar ini sama dengan bandar yang dilawati sebelum ini; kembali maksimum kedua -dua pilihan; Kod pemacu; Pada mulanya bermula dengan warna 0", "code": "using System ; class GFG { static int MaxProfit ( int [ ] treasure , int [ ] color , int n , int k , int col , int A , int B ) { int sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += Math . Max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . Max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; } public static void Main ( String [ ] args ) { int A = - 5 , B = 7 ; int [ ] treasure = { 4 , 8 , 2 , 9 } ; int [ ] color = { 2 , 2 , 6 , 2 } ; int n = color . Length ; Console . Write ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) ; } }"}
{"text": "Nombor Tetranacci | Program C # rekursif mudah untuk mencetak nombor Tetranacci Nth. ; Berfungsi untuk mengembalikan nombor tetranacci N; kes asas; kes asas; kes asas; berfungsi untuk mencetak nombor tetranacci nth; Kod pemacu", "code": "class GFG { static int printTetraRec ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return 1 ; if ( n == 3 ) return 2 ; else return printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ; } static void printTetra ( int n ) { System . Console . WriteLine ( printTetraRec ( n ) + \" ▁ \" ) ; } static void Main ( ) { int n = 10 ; printTetra ( n ) ; } }"}
{"text": "Jumlah produk semua gabungan diambil (1 hingga n) pada satu masa | Program untuk mencari SOP semua gabungan yang diambil (1 hingga n) pada satu masa menggunakan kekerasan; untuk menyimpan jumlah kombinasi; Jika kita telah mencapai kedalaman yang mencukupi; Cari produk gabungan; Tambah produk ke dalam jumlah; rekursi untuk menghasilkan gabungan yang berbeza; berfungsi untuk mencetak jumlah produk semua gabungan yang diambil 1 - n pada satu masa; mewujudkan array sementara untuk menyimpan kombinasi; gabungan panggilan dengan r = i untuk gabungan yang diambil saya pada satu masa; memaparkan jumlah; Kod pemacu; menyimpan nombor dari 1 - n dalam array; Memanggil AllCombination", "code": "using System ; class GFG { static int sum = 0 ; static void Combination ( int [ ] a , int [ ] combi , int n , int r , int depth , int index ) { if ( index == r ) { int product = 1 ; for ( int i = 0 ; i < r ; i ++ ) product = product * combi [ i ] ; sum += product ; return ; } for ( int i = depth ; i < n ; i ++ ) { combi [ index ] = a [ i ] ; Combination ( a , combi , n , r , i + 1 , index + 1 ) ; } } static void allCombination ( int [ ] a , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int [ ] combi = new int [ i ] ; Combination ( a , combi , n , i , 0 , 0 ) ; Console . Write ( \" f ( \" + i + \" ) ▁ - - > ▁ \" + sum + \" STRNEWLINE \" ) ; sum = 0 ; } } static void Main ( ) { int n = 5 ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = i + 1 ; allCombination ( a , n ) ; } }"}
{"text": "Pengaturcaraan Dinamik | Tinggi | Program C # berasaskan DP untuk mencari tugas maksimum. ; Mengembalikan maksimum di antara 2 nombor; Mengembalikan jumlah tugas maksimum yang boleh dilakukan sehingga hari n; Task_dp array yang menyimpan tugas maksimum yang dilakukan; Jika n = 0, tiada penyelesaian wujud; Jika n = 1, tugas usaha yang tinggi pada hari itu akan menjadi penyelesaian; Isi keseluruhan array menentukan tugas mana yang hendak dipilih pada hari I; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static int max ( int x , int y ) { return ( x > y ? x : y ) ; } static int maxTasks ( int [ ] high , int [ ] low , int n ) { int [ ] task_dp = new int [ n + 1 ] ; task_dp [ 0 ] = 0 ; task_dp [ 1 ] = high [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) task_dp [ i ] = max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; } static void Main ( ) { int n = 5 ; int [ ] high = { 3 , 6 , 8 , 7 , 6 } ; int [ ] low = { 1 , 5 , 4 , 5 , 3 } ; Console . WriteLine ( maxTasks ( high , low , n ) ) ; } }"}
{"text": "Koefisien Permutasi | A o (n) masa dan O (1) penyelesaian ruang tambahan untuk mengira pekali permutasi; Kirakan N! dan (n - k)! ; Kod pemacu", "code": "using System ; class GFG { static int PermutationCoeff ( int n , int k ) { int Fn = 1 , Fk = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { Fn *= i ; if ( i == n - k ) Fk = Fn ; } int coeff = Fn / Fk ; return coeff ; } public static void Main ( ) { int n = 10 , k = 2 ; Console . WriteLine ( \" Value ▁ of ▁ P ( ▁ \" + n + \" , \" + k + \" ) ▁ is ▁ \" + PermutationCoeff ( n , k ) ) ; } }"}
{"text": "Masalah Partition | DP | Program C # berasaskan pengaturcaraan yang dinamik untuk masalah partition; Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah semua elemen; memulakan baris atas sebagai benar; memulakan lajur paling kiri, kecuali bahagian [0] [0], sebagai 0; Isi jadual partition dengan cara bawah; Uncomment Bahagian ini untuk mencetak jadual untuk (i = 0; i <= sum / 2; i ++) {untuk (j = 0; j <= n; j ++) printf (\" % 4d\", bahagian [i] [j]); printf (\"\\ n\"); }; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static bool findPartition ( int [ ] arr , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool [ , ] part = new bool [ sum / 2 + 1 , n + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 , i ] = true ; for ( i = 1 ; i <= sum / 2 ; i ++ ) part [ i , 0 ] = false ; for ( i = 1 ; i <= sum / 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i , j ] = part [ i , j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i , j ] = part [ i , j - 1 ] || part [ i - arr [ j - 1 ] , j - 1 ] ; } } return part [ sum / 2 , n ] ; } public static void Main ( ) { int [ ] arr = { 3 , 1 , 1 , 2 , 2 , 1 } ; int n = arr . Length ; if ( findPartition ( arr , n ) == true ) Console . Write ( \" Can ▁ be ▁ divided \" + \" ▁ into ▁ two ▁ subsets ▁ of \" + \" ▁ equal ▁ sum \" ) ; else Console . Write ( \" Can ▁ not ▁ be ▁ \" + \" divided ▁ into ▁ two ▁ subsets \" + \" ▁ of ▁ equal ▁ sum \" ) ; } }"}
{"text": "Bilangan minimum tambahan x atau y aksara dari hujung ke depan yang diperlukan untuk mendapatkan rentetan yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mencari operasi minimum yang diperlukan untuk mendapatkan rentetan yang diberikan selepas menambahkan aksara M atau N dari hujung ke hadapan rentetan dalam setiap operasi; Simpan rentetan asal; Menyimpan kiraan operasi; Melintasi rentetan; Potong huruf dari akhir; Masukkan huruf potong untuk permulaan; Kemas kini j; Semak sama ada rentetan adalah sama; Potong n huruf dari hujung; Masukkan huruf potong n untuk permulaan; Kemas kini j; Semak sama ada rentetan adalah sama; Mengemas kini giliran; Kod pemacu; Diberikan rentetan s; Panggilan fungsi", "code": "using System ; class GFG { static void minimumOperations ( string orig_str , int m , int n ) { string orig = orig_str ; int turn = 1 ; int j = 1 ; for ( int i = 0 ; i < orig_str . Length ; i ++ ) { string m_cut = orig_str . Substring ( orig_str . Length - m ) ; orig_str = orig_str . Substring ( 0 , orig_str . Length - m ) ; orig_str = m_cut + orig_str ; j = j + 1 ; if ( ! orig . Equals ( orig_str ) ) { turn = turn + 1 ; String n_cut = orig_str . Substring ( orig_str . Length - n ) ; orig_str = orig_str . Substring ( 0 , orig_str . Length - n ) ; orig_str = n_cut + orig_str ; j = j + 1 ; } if ( orig . Equals ( orig_str ) ) { break ; } turn = turn + 1 ; } Console . WriteLine ( turn ) ; } public static void Main ( ) { string S = \" GeeksforGeeks \" ; int X = 5 , Y = 3 ; minimumOperations ( S , X , Y ) ; } }"}
{"text": "Putaran minimum diperlukan untuk mendapatkan rentetan yang sama | Set | C # pelaksanaan pendekatan di atas; Cetakan kejadian txt [] dalam pat []; Buat LPS [] yang akan memegang nilai akhiran awalan terpanjang untuk corak; Pra -proses corak (hitung array LPS []); Indeks untuk txt [], indeks untuk pat []; Tidak sepadan selepas perlawanan J; Jangan sepadan dengan LPS [0 .. LPS [J - 1]] aksara, mereka akan sepadan pula; Mengisi LPS [] untuk corak yang diberikan Pat [0. M - 1]; Panjang akhiran awalan terpanjang sebelumnya; LPS [0] sentiasa 0; Gelung mengira LPS [i] untuk i = 1 hingga m - 1; (pat [i]! = pat [len]); Ini sukar. Pertimbangkan contohnya. AAACAAAA dan I = 7. Idea ini sama dengan langkah carian. ; Mengembalikan kiraan putaran untuk mendapatkan rentetan yang sama kembali; Bentuk rentetan tidak termasuk watak pertama dan menggabungkan rentetan pada akhir; Menukar rentetan ke array aksara; Gunakan algoritma carian KMP untuk mencarinya dalam masa O (n); Kod pemacu", "code": "using System ; class GFG { static int KMPSearch ( char [ ] pat , char [ ] txt ) { int M = pat . Length ; int N = txt . Length ; int [ ] lps = new int [ M ] ; computeLPSArray ( pat , M , lps ) ; int i = 0 ; int j = 0 ; while ( i < N ) { if ( pat [ j ] == txt [ i ] ) { j ++ ; i ++ ; } if ( j == M ) { return i - j ; } else if ( i < N && pat [ j ] != txt [ i ] ) { if ( j != 0 ) j = lps [ j - 1 ] ; else i = i + 1 ; } } return 0 ; } static void computeLPSArray ( char [ ] pat , int M , int [ ] lps ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } } static int countRotations ( string s ) { string s1 = s . Substring ( 1 , s . Length - 1 ) + s ; char [ ] pat = s . ToCharArray ( ) ; char [ ] text = s1 . ToCharArray ( ) ; return 1 + KMPSearch ( pat , text ) ; } public static void Main ( params string [ ] args ) { string s1 = \" geeks \" ; Console . Write ( countRotations ( s1 ) ) ; } }"}
{"text": "DFA untuk rentetan tidak berakhir dengan \"The\" | C # Program untuk melaksanakan DFS yang menerima semua rentetan yang tidak berakhir dengan \"The\"; DFA memberitahu nombor yang berkaitan dengan keadaan sekarang; Fungsi ini adalah untuk keadaan permulaan (zeroth) DFA; Apabila menerima 'T' atau 'T' Goto State First (1); Fungsi ini adalah untuk keadaan pertama DFA; Apabila menerima 'T' atau 'T' Goto State First (1); Apabila menerima 'H' atau 'H' Goto kedua negeri (2); lain Goto State State (0); Fungsi ini adalah untuk keadaan kedua DFA; Apabila menerima 'E' atau 'E' Goto Negeri Ketiga (3) Lain Goto State State (0); Fungsi ini adalah untuk keadaan ketiga DFA; Apabila menerima 'T' atau 'T' Goto State First (1) Lain Goto State State (0); panjang simpan rentetan; Kod pemacu", "code": "using System ; class GFG { static int dfa = 0 ; static void start ( char c ) { if ( c == ' t ' c == ' T ' ) dfa = 1 ; } static void state1 ( char c ) { if ( c == ' t ' c == ' T ' ) dfa = 1 ; else if ( c == ' h ' c == ' H ' ) dfa = 2 ; else dfa = 0 ; } static void state2 ( char c ) { if ( c == ' e ' c == ' E ' ) dfa = 3 ; else dfa = 0 ; } static void state3 ( char c ) { if ( c == ' t ' c == ' T ' ) dfa = 1 ; else dfa = 0 ; } static bool isAccepted ( char [ ] str ) { int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; } static public void Main ( ) { char [ ] str = \" forTHEgeeks \" . ToCharArray ( ) ; if ( isAccepted ( str ) == true ) Console . WriteLine ( \" ACCEPTED STRNEWLINE \" ) ; else Console . WriteLine ( \" NOT ▁ ACCEPTED STRNEWLINE \" ) ; } }"}
{"text": "Semak jika satu rentetan boleh ditukar kepada yang lain | C # Pelaksanaan pendekatan di atas. ; Fungsi untuk mencari dari algoritma set disjoint; Fungsi untuk kesatuan dari algoritma set disjoint; Fungsi untuk memeriksa sama ada satu rentetan boleh ditukar kepada yang lain. ; Semua watak diperiksa sama ada ia sama ada tidak diganti atau digantikan oleh watak yang sama menggunakan peta. ; Untuk memeriksa sama ada terdapat kitaran. Jika ya, maka mereka tidak boleh ditukar. Selain itu, mereka boleh ditukar. ; Fungsi untuk memulakan array induk untuk kesatuan dan mencari algoritma. ; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int [ ] parent = new int [ 26 ] ; static int find ( int x ) { if ( x != parent [ x ] ) return parent [ x ] = find ( parent [ x ] ) ; return x ; } static void join ( int x , int y ) { int px = find ( x ) ; int pz = find ( y ) ; if ( px != pz ) { parent [ pz ] = px ; } } static bool convertible ( String s1 , String s2 ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < s1 . Length ; i ++ ) { if ( ! mp . ContainsKey ( s1 [ i ] - ' a ' ) ) { mp . Add ( s1 [ i ] - ' a ' , s2 [ i ] - ' a ' ) ; } else { if ( mp [ s1 [ i ] - ' a ' ] != s2 [ i ] - ' a ' ) return false ; } } foreach ( KeyValuePair < int , int > it in mp ) { if ( it . Key == it . Value ) continue ; else { if ( find ( it . Key ) == find ( it . Value ) ) return false ; else join ( it . Key , it . Value ) ; } } return true ; } static void initialize ( ) { for ( int i = 0 ; i < 26 ; i ++ ) { parent [ i ] = i ; } } public static void Main ( String [ ] args ) { String s1 , s2 ; s1 = \" abbcaa \" ; s2 = \" bccdbb \" ; initialize ( ) ; if ( convertible ( s1 , s2 ) ) Console . Write ( \" Yes \" + \" STRNEWLINE \" ) ; else Console . Write ( \" No \" + \" STRNEWLINE \" ) ; } }"}
{"text": "Cetak Watak yang mempunyai frekuensi utama dalam urutan kejadian | C # pelaksanaan pendekatan; Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mencetak aksara frekuensi utama mengikut urutan kejadian mereka; Berfungsi untuk membuat ayak untuk memeriksa prima; Untuk menyimpan kekerapan setiap watak rentetan; Memulakan semua elemen freq [] hingga 0; Kemas kini kekerapan setiap aksara; Traverse str -watak oleh watak; Jika kekerapan watak semasa adalah perdana; Kod pemacu", "code": "using System ; class GFG { static int SIZE = 26 ; static void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < p_size ; i += p ) prime [ i ] = false ; } } } static void printChar ( string str , int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , str . Length + 1 ) ; int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) freq [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ freq [ str [ i ] - ' a ' ] ] ) { Console . Write ( str [ i ] ) ; } } } public static void Main ( String [ ] args ) { String str = \" geeksforgeeks \" ; int n = str . Length ; printChar ( str , n ) ; } }"}
{"text": "Cetak Watak yang mempunyai frekuensi utama dalam urutan kejadian | C # kod untuk pendekatan di atas; Berfungsi untuk memeriksa prima; Mengira kekerapan semua watak menggunakan fungsi kaunter; Melintasi rentetan; Kod pemacu; Lulus rentetan ke fungsi checkstring", "code": "using System ; using System . Collections . Generic ; class GFG { static bool prime ( int n ) { if ( n <= 1 ) return false ; int max_div = ( int ) Math . Floor ( Math . Sqrt ( n ) ) ; for ( int i = 2 ; i < 1 + max_div ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void checkString ( string s ) { Dictionary < char , int > freq = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ! freq . ContainsKey ( s [ i ] ) ) freq [ s [ i ] ] = 0 ; freq [ s [ i ] ] += 1 ; } for ( int i = 0 ; i < s . Length ; i ++ ) { if ( prime ( freq [ s [ i ] ] ) ) Console . Write ( s [ i ] ) ; } } public static void Main ( ) { string s = \" geeksforgeeks \" ; checkString ( s ) ; } }"}
{"text": "Cetak Watak yang mempunyai frekuensi walaupun dalam urutan kejadian | C # pelaksanaan pendekatan; Berfungsi untuk mencetak aksara kekerapan walaupun dalam urutan kejadian mereka; Untuk menyimpan kekerapan setiap watak rentetan; Kemas kini kekerapan setiap aksara; Traverse str -watak oleh watak; Jika kekerapan watak semasa adalah walaupun; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int SIZE = 26 ; static void printChar ( String str , int n ) { int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { Console . Write ( str [ i ] ) ; } } } public static void Main ( String [ ] args ) { String str = \" geeksforgeeks \" ; int n = str . Length ; printChar ( str , n ) ; } }"}
{"text": "Bandingkan dua rentetan memandangkan hanya aksara alfanumerik | C # pelaksanaan pendekatan; Berfungsi untuk memeriksa kesamaan alfanumerik kedua -dua rentetan; Perisytiharan Variabel; Panjang rentetan pertama; Panjang rentetan kedua; Untuk memeriksa setiap watak kedua -dua rentetan; Jika watak semasa rentetan pertama bukan watak alfanumerik, tingkatkan penunjuk I; Jika watak semasa rentetan kedua bukan watak alfanumerik, tingkatkan penunjuk j; Jika semua aksara alfanumerik kedua -dua rentetan adalah sama maka kembali benar; Jika mana -mana aksara alfanumerik kedua -dua rentetan tidak sama maka kembali palsu; Jika watak semasa dipadankan, tingkatkan kedua -dua petunjuk untuk memeriksa watak seterusnya; Jika tidak sama, maka kembali palsu; Berfungsi untuk mencetak sama atau tidak sama rata jika rentetan sama atau tidak; Semak kesamaan alfanumerik kedua -dua rentetan; Sekiranya kedua -duanya adalah sama dengan alfanumerik, cetak sama; sebaliknya mencetak tidak sama rata; Kod pemacu", "code": "using System ; class GFG { static bool CompareAlphanumeric ( char [ ] str1 , char [ ] str2 ) { int i , j ; i = 0 ; j = 0 ; int len1 = str1 . Length ; int len2 = str2 . Length ; while ( i <= len1 && j <= len2 ) { while ( i < len1 && ( ! ( ( str1 [ i ] >= ' a ' && str1 [ i ] <= ' z ' ) || ( str1 [ i ] >= ' A ' && str1 [ i ] <= ' Z ' ) || ( str1 [ i ] >= '0' && str1 [ i ] <= '9' ) ) ) ) { i ++ ; } while ( j < len2 && ( ! ( ( str2 [ j ] >= ' a ' && str2 [ j ] <= ' z ' ) || ( str2 [ j ] >= ' A ' && str2 [ j ] <= ' Z ' ) || ( str2 [ j ] >= '0' && str2 [ j ] <= '9' ) ) ) ) { j ++ ; } if ( i == len1 && j == len2 ) { return true ; } else if ( str1 [ i ] != str2 [ j ] ) { return false ; } else { i ++ ; j ++ ; } } return false ; } static void CompareAlphanumericUtil ( string str1 , string str2 ) { bool res ; res = CompareAlphanumeric ( str1 . ToCharArray ( ) , str2 . ToCharArray ( ) ) ; if ( res == true ) { Console . WriteLine ( \" Equal \" ) ; } else { Console . WriteLine ( \" Unequal \" ) ; } } public static void Main ( ) { string str1 , str2 ; str1 = \" Ram , ▁ Shyam \" ; str2 = \" ▁ Ram ▁ - ▁ Shyam . \" ; CompareAlphanumericUtil ( str1 , str2 ) ; str1 = \" abc123\" ; str2 = \"123abc \" ; CompareAlphanumericUtil ( str1 , str2 ) ; } }"}
{"text": "Pertanyaan untuk mencetak watak yang berlaku bilangan maksimum kali dalam julat yang diberikan | C # Program untuk mencari jumlah penambahan semua subset yang mungkin. ; Fungsi yang menjawab semua pertanyaan; Panjang rentetan; Bilangan pertanyaan; Arahan awalan; Melewati semua watak; Meningkatkan kiraan watak; Arahan anggaran untuk semua 26 aksara; Kemas kini array awalan; Jawab setiap pertanyaan; Julat; ITERATE untuk semua watak; Kali watak huruf kecil j berlaku sehingga indeks r - th; Tolak masa yang berlaku sehingga indeks (l - 1) th; Maksimum masa itu berlaku; Cetak jawapannya; Kod pemacu", "code": "using System ; class GFG { static void solveQueries ( String str , int [ , ] query ) { int len = str . Length ; int Q = query . GetLength ( 0 ) ; int [ , ] pre = new int [ len , 26 ] ; for ( int i = 0 ; i < len ; i ++ ) { pre [ i , str [ i ] - ' a ' ] ++ ; if ( i > 0 ) { for ( int j = 0 ; j < 26 ; j ++ ) pre [ i , j ] += pre [ i - 1 , j ] ; } } for ( int i = 0 ; i < Q ; i ++ ) { int l = query [ i , 0 ] ; int r = query [ i , 1 ] ; int maxi = 0 ; char c = ' a ' ; for ( int j = 0 ; j < 26 ; j ++ ) { int times = pre [ r , j ] ; if ( l > 0 ) times -= pre [ l - 1 , j ] ; if ( times > maxi ) { maxi = times ; c = ( char ) ( ' a ' + j ) ; } } Console . WriteLine ( \" Query \" + ( i + 1 ) + \" : ▁ \" + c ) ; } } public static void Main ( String [ ] args ) { String str = \" striver \" ; int [ , ] query = { { 0 , 1 } , { 1 , 6 } , { 5 , 6 } } ; solveQueries ( str , query ) ; } }"}
{"text": "Semak sama ada rentetan yang diberikan boleh dijana selepas menyatukan rentetan yang diberikan | C # pelaksanaan pendekatan; Fungsi yang kembali benar jika pra adalah awalan str; Walaupun ada watak untuk dipadankan; Jika watak berbeza di mana -mana kedudukan; STR bermula dengan pra; Fungsi yang kembali benar jika Suff adalah akhiran str; Walaupun ada watak untuk dipadankan; Jika watak berbeza di mana -mana kedudukan; str berakhir dengan suff; Fungsi yang kembali benar jika str = a + b atau str = b + a; STR tidak boleh dihasilkan dengan menggabungkan A dan B; Jika str bermula dengan i. e. A adalah awalan str; Semak sama ada watak -watak yang lain adalah sama dengan b i. e. B adalah akhiran str; Jika str bermula dengan b i. e. B adalah awalan str; Semak sama ada watak -watak yang lain adalah sama dengan i. e. A adalah akhiran str; Kod pemacu", "code": "using System ; class GFG { static Boolean startsWith ( String str , String pre ) { int strLen = str . Length ; int preLen = pre . Length ; int i = 0 , j = 0 ; while ( i < strLen && j < preLen ) { if ( str [ i ] != pre [ j ] ) return false ; i ++ ; j ++ ; } return true ; } static Boolean endsWith ( String str , String suff ) { int i = str . Length - 1 ; int j = suff . Length - 1 ; while ( i >= 0 && j >= 0 ) { if ( str [ i ] != suff [ j ] ) return false ; i -- ; j -- ; } return true ; } static Boolean checkString ( String str , String a , String b ) { if ( str . Length != a . Length + b . Length ) return false ; if ( startsWith ( str , a ) ) { if ( endsWith ( str , b ) ) return true ; } if ( startsWith ( str , b ) ) { if ( endsWith ( str , a ) ) return true ; } return false ; } public static void Main ( String [ ] args ) { String str = \" GeeksforGeeks \" ; String a = \" Geeksfo \" ; String b = \" rGeeks \" ; if ( checkString ( str , a , b ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Cetak Watak yang mempunyai frekuensi ganjil mengikut urutan kejadian | C # pelaksanaan pendekatan; Berfungsi untuk mencetak aksara frekuensi ganjil mengikut urutan kejadian mereka; Untuk menyimpan kekerapan setiap watak rentetan; Kemas kini kekerapan setiap aksara; Traverse str -watak oleh watak; Jika kekerapan watak semasa adalah ganjil; Kod pemacu", "code": "using System ; class GFG { public static void printChar ( String str , int n ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 1 ) { Console . Write ( str [ i ] ) ; } } } public static void Main ( String [ ] args ) { String str = \" geeksforgeeks \" ; int n = str . Length ; printChar ( str , n ) ; } }"}
{"text": "Bilangan minimum operasi untuk memindahkan semua aksara huruf besar sebelum semua aksara kes yang lebih rendah | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan; Untuk menyimpan indeks huruf besar terakhir dan watak huruf kecil pertama; Cari watak huruf besar terakhir; Cari watak huruf kecil pertama; Jika semua watak adalah huruf besar atau huruf kecil; Kiraan aksara huruf besar yang muncul selepas watak huruf kecil pertama; Count huruf kecil yang muncul sebelum watak huruf besar terakhir; Mengembalikan operasi minimum yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int minOperations ( string str , int n ) { int i , lastUpper = - 1 , firstLower = - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( Char . IsUpper ( str [ i ] ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( Char . IsLower ( str [ i ] ) ) { firstLower = i ; break ; } } if ( lastUpper == - 1 firstLower == - 1 ) return 0 ; int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( Char . IsUpper ( str [ i ] ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( Char . IsLower ( str [ i ] ) ) { countLower ++ ; } } return Math . Min ( countLower , countUpper ) ; } public static void Main ( ) { string str = \" geEksFOrGEekS \" ; int n = str . Length ; Console . WriteLine ( minOperations ( str , n ) ) ; } }"}
{"text": "Cari jumlah semua nombor pertunangan sehingga n | C # Program untuk mencari jumlah semua nombor pertunangan sehingga n; Berfungsi untuk mencari jumlah semua nombor pertunangan; Untuk menyimpan nombor pertunangan; Kirakan jumlah pembahagi nombor_1 1 sentiasa menjadi pembahagi; i = 2 kerana kita tidak mahu memasukkan 1 sebagai pembahagi.  ; Jumlah semua nombor pertunangan sehingga n; Kod pemacu", "code": "using System ; using System . Collections ; class GFG { public static int Betrothed_Sum ( int n ) { ArrayList set = new ArrayList ( ) ; for ( int number_1 = 1 ; number_1 < n ; number_1 ++ ) { int sum_divisor_1 = 1 ; int i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += number_1 / i ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { int number_2 = sum_divisor_1 - 1 ; int sum_divisor_2 = 1 ; int j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += number_2 / j ; } j = j + 1 ; } if ( sum_divisor_2 == number_1 + 1 && number_1 <= n && number_2 <= n ) { set . Add ( number_1 ) ; set . Add ( number_2 ) ; } } } int Summ = 0 ; for ( int i = 0 ; i < set . Count ; i ++ ) { if ( ( int ) set [ i ] <= n ) Summ += ( int ) set [ i ] ; } return Summ ; } static public void Main ( ) { int n = 78 ; Console . WriteLine ( Betrothed_Sum ( n ) ) ; } }"}
{"text": "Kebarangkalian hujan pada hari n + 1 | | C # kod untuk mencari kebarangkalian hujan pada hari n + 1 - hari apabila data hari sebelumnya diberikan; Fungsi untuk mencari kebarangkalian; kiraan 1; Cari kebarangkalian; Kod pemacu", "code": "using System ; class GFG { static float rainDayProbability ( int [ ] a , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; } public static void Main ( ) { int [ ] a = { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = a . Length ; Console . WriteLine ( rainDayProbability ( a , n ) ) ; } }"}
{"text": "Program untuk mencari jumlah siri 1 + 1/2 ^ 2 + 1/3 ^ 3 + â € |. . + 1 / n ^ n | C # Program untuk mengira siri berikut; Fungsi untuk mengira siri berikut; Kod pemacu", "code": "using System ; class Maths { static double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / Math . Pow ( i , i ) ; sums += ser ; } return sums ; } public static void Main ( ) { int n = 3 ; double res = Series ( n ) ; res = Math . Round ( res * 100000.0 ) / 100000.0 ; Console . Write ( res ) ; } }"}
{"text": "Rentetan lexicographically terbesar yang terbentuk dalam langkah minimum dengan menggantikan watak -watak rentetan yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencetak secara lexicographically rentetan terbesar yang diperolehi dalam proses mendapatkan rentetan yang mengandungi pertama N Lower Case English Alphabtes; Simpan kekerapan setiap watak; Melintasi rentetan s; Menyimpan watak -watak yang tidak muncul dalam s; Menyimpan indeks watak terbesar dalam array V, yang perlu diganti; Melintasi rentetan, s; Jika kekerapan S [i] lebih besar daripada 1 atau ia berada di luar julat; Menurunkan kekerapannya dengan 1; UPDATE S [I]; Penurunan j oleh 1; Melintasi rentetan, s; Menurunkan kekerapannya dengan 1; UPDATE S [I]; Kenaikan l oleh 1; Pulangan s; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static string lexicographicallyMaximum ( string S , int N ) { Dictionary < char , int > M = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( M . ContainsKey ( S [ i ] ) ) M [ S [ i ] ] ++ ; else M . Add ( S [ i ] , 1 ) ; } List < char > V = new List < char > ( ) ; for ( char i = ' a ' ; i < ( char ) ( ' a ' + Math . Min ( N , 25 ) ) ; ++ i ) { if ( M . ContainsKey ( i ) == false ) { V . Add ( i ) ; } } int j = V . Count - 1 ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] >= ( ' a ' + Math . Min ( N , 25 ) ) || ( M . ContainsKey ( S [ i ] ) && M [ S [ i ] ] > 1 ) ) { if ( V [ j ] < S [ i ] ) continue ; M [ S [ i ] ] -- ; S = S . Substring ( 0 , i ) + V [ j ] + S . Substring ( i + 1 ) ; j -- ; } if ( j < 0 ) break ; } int l = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S [ i ] >= ( ' a ' + Math . Min ( N , 25 ) ) || M . ContainsKey ( S [ i ] ) && M [ S [ i ] ] > 1 ) { M [ S [ i ] ] -- ; S = S . Substring ( 0 , i ) + V [ l ] + S . Substring ( i + 1 ) ; l ++ ; } } return S ; } public static void Main ( ) { string S = \" abccefghh \" ; int N = S . Length ; Console . Write ( lexicographicallyMaximum ( S , N ) ) ; } }"}
{"text": "Semak jika mana -mana subarray boleh dibuat palindromic dengan menggantikan kurang daripada separuh elemennya | C # Program untuk pendekatan di atas; Fungsi utiliti untuk memeriksa sama ada subarray boleh menjadi palindromic dengan menggantikan kurang daripada separuh unsur yang ada di dalamnya; Kedai kekerapan elemen array; Melintasi array; Kekerapan kemas kini setiap elemen array; Iterator di atas peta; Jika kekerapan mana -mana elemen melebihi 1; Sekiranya tiada pengulangan dijumpai; Berfungsi untuk memeriksa dan mencetak jika mana -mana subarray boleh dibuat palindromic dengan menggantikan kurang daripada separuh elemennya; Kod pemacu; Diberikan array arr []; Saiz array; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; using System . Linq ; class GFG { static bool isConsistingSubarrayUtil ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . ContainsKey ( arr [ i ] ) == true ) mp [ arr [ i ] ] += 1 ; else mp [ arr [ i ] ] = 1 ; } var val = mp . Keys . ToList ( ) ; foreach ( var key in val ) { if ( mp [ key ] > 1 ) { return true ; } } return false ; } static void isConsistingSubarray ( int [ ] arr , int N ) { if ( isConsistingSubarrayUtil ( arr , N ) ) { Console . Write ( \" Yes \" ) ; } else { Console . Write ( \" No \" ) ; } } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 1 } ; int N = arr . Length ; isConsistingSubarray ( arr , N ) ; } }"}
{"text": "Nombor Fibonacci Komposit dari Arahan yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari semua nombor Fibonacci sehingga maks; Simpan semua nombor Fibonacci sehingga max; Kedai elemen sebelumnya dari urutan Fibonacci; Kedai elemen sebelumnya dari urutan Fibonacci; Masukkan prev ke hashmap; Masukkan semua nombor Fibonacci sehingga maks; Masukkan curr ke hashmap; Kedai -kedai Curr Into Temp; Kemas kini curr; UPDATE PREV; Berfungsi untuk mencari semua nombor komposit sehingga maks; Isprime [i]: Kedai jika saya adalah nombor utama atau tidak; Kirakan semua nombor perdana sehingga maksimum menggunakan penapis eratosthenes; Jika p adalah nombor utama; Tetapkan semua pelbagai p sebagai bukan perdana; Kemas kini isprime; Fungsi untuk mencari nombor yang merupakan nombor komposit dan fibonacci; Menyimpan elemen terbesar array; Melintasi array [] arr; Kemas kini Max; isprim [i] periksa saya adalah nombor utama atau tidak; Menyimpan semua nombor Fibonacci; Melintasi array [] arr; Elemen semasa bukan nombor komposit; Jika elemen semasa adalah nombor fibonacci dan komposit; Cetak elemen semasa; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static bool [ ] isPrime ; static HashSet < int > createhashmap ( int Max ) { HashSet < int > hashmap = new HashSet < int > ( ) ; int curr = 1 ; int prev = 0 ; hashmap . Add ( prev ) ; while ( curr < Max ) { hashmap . Add ( curr ) ; int temp = curr ; curr = curr + prev ; prev = temp ; } return hashmap ; } static void SieveOfEratosthenes ( int Max ) { isPrime = new bool [ Max ] ; for ( int i = 0 ; i < Max ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= Max ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= Max ; i += p ) { isPrime [ i ] = false ; } } } } static void cntFibonacciPrime ( int [ ] arr , int N ) { int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { Max = Math . Max ( Max , arr [ i ] ) ; } SieveOfEratosthenes ( Max ) ; HashSet < int > hashmap = createhashmap ( Max ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) continue ; if ( ( hashmap . Contains ( arr [ i ] ) ) && ! isPrime [ arr [ i ] ] ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } } } public static void Main ( String [ ] args ) { int [ ] arr = { 13 , 55 , 7 , 3 , 5 , 21 , 233 , 144 , 89 } ; int N = arr . Length ; cntFibonacciPrime ( arr , N ) ; } }"}
{"text": "Kurangkan nombor yang diberikan untuk membentuk kunci oleh operasi yang diberikan | C # Program pendekatan di atas; Berfungsi untuk mencari kunci nombor yang diberikan; Tukar integer ke rentetan; Melepasi rentetan num untuk mendapatkan hasilnya; Semak sama ada digit adalah atau ganjil; Berulang sehingga jumlah ganjil diperolehi dengan menambahkan digit berturut -turut; Semak jika jumlahnya menjadi ganjil; Tambah hasil dalam ANS; Berikan indeks digit ke rentetan NUM; Jika nombor itu ganjil; Berulang sehingga jumlah ganjil diperolehi dengan menambahkan digit berturut -turut; Semak sama ada jumlahnya menjadi walaupun; Tambah hasil dalam ANS; Berikan indeks digit ke numstring utama; Periksa sama ada semua digit dikunjungi atau tidak; Kod pemacu", "code": "using System ; class GFG { static int key ( int N ) { String num = \" \" + N ; int ans = 0 ; int j = 0 ; for ( j = 0 ; j < num . Length ; j ++ ) { if ( ( num [ j ] - 48 ) % 2 == 0 ) { int add = 0 ; int i ; for ( i = j ; j < num . Length ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 1 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) Math . Floor ( Math . Log10 ( add ) + 1 ) ; ans *= ( int ) ( Math . Pow ( 10 , digit ) ) ; ans += add ; } i = j ; } else { int add = 0 ; int i ; for ( i = j ; j < num . Length ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) Math . Floor ( Math . Log10 ( add ) + 1 ) ; ans *= ( int ) ( Math . Pow ( 10 , digit ) ) ; ans += add ; } i = j ; } } if ( j + 1 >= num . Length ) { return ans ; } else { return ans += num [ num . Length - 1 ] - 48 ; } } public static void Main ( String [ ] args ) { int N = 1667848271 ; Console . Write ( key ( N ) ) ; } }"}
{"text": "Sentinel Linear Search | C # pelaksanaan pendekatan; Berfungsi untuk mencari x dalam array yang diberikan; Elemen terakhir array; Unsur yang akan dicari diletakkan pada indeks terakhir; Letakkan elemen terakhir kembali; Kod pemacu", "code": "using System ; class GFG { static void sentinelSearch ( int [ ] arr , int n , int key ) { int last = arr [ n - 1 ] ; arr [ n - 1 ] = key ; int i = 0 ; while ( arr [ i ] != key ) i ++ ; arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) Console . WriteLine ( key + \" ▁ is ▁ present \" + \" ▁ at ▁ index ▁ \" + i ) ; else Console . WriteLine ( \" Element ▁ Not ▁ found \" ) ; } public static void Main ( ) { int [ ] arr = { 10 , 20 , 180 , 30 , 60 , 50 , 110 , 100 , 70 } ; int n = arr . Length ; int key = 180 ; sentinelSearch ( arr , n , key ) ; } }"}
{"text": "Unsur pertengahan maksimum yang mungkin selepas memadam Elements Kepatnya | C # pelaksanaan pendekatan; Fungsi untuk mengira nilai tengah maksimum yang mungkin dari array selepas memadam elemen K tepat; Memulakan jawapan sebagai - 1; Hitung pelbagai elemen yang boleh memberikan nilai tengah maksimum yang mungkin dari array kerana indeks nilai maksimum yang mungkin ditengah selepas memadam elemen k tepat dari array akan terletak di antara rendah dan tinggi; Cari elemen maksimum array dalam jarak rendah dan tinggi; Oleh kerana pengindeksan adalah 1 berasaskan jadi elemen semak pada indeks I - 1; Kembalikan nilai tengah maksimum yang mungkin dari array selepas memadam elemen K tepat dari array; Kod pemacu", "code": "using System ; class GFG { static int maximum_middle_value ( int n , int k , int [ ] arr ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = Math . Max ( ans , arr [ i - 1 ] ) ; } return ans ; } static public void Main ( ) { int n = 5 , k = 2 ; int [ ] arr = { 9 , 5 , 3 , 7 , 10 } ; Console . WriteLine ( maximum_middle_value ( n , k , arr ) ) ; n = 9 ; k = 3 ; int [ ] arr1 = { 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 } ; Console . WriteLine ( maximum_middle_value ( n , k , arr1 ) ) ; } }"}
{"text": "Carian Ternary | Program CSHARP untuk menggambarkan pendekatan rekursif untuk carian ternary; Berfungsi untuk melakukan carian ternary; Cari Mid1 dan Mid2; Semak sama ada kunci hadir di mana -mana pertengahan; Oleh kerana kunci tidak hadir pada pertengahan, periksa di mana rantau ia hadir kemudian ulangi operasi carian di rantau itu; Kunci terletak di antara L dan MID1; Kunci terletak di antara Mid2 dan R; Kuncinya terletak di antara Mid1 dan Mid2; Kunci tidak dijumpai; Kod pemacu; Dapatkan array jenis array jika tidak disusun; Indeks permulaan; panjang array; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya", "code": "using System ; class GFG { static int ternarySearch ( int l , int r , int key , int [ ] ar ) { if ( r >= l ) { int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) { return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else { return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } } return - 1 ; } public static void Main ( ) { int l , r , p , key ; int [ ] ar = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; l = 0 ; r = 9 ; key = 5 ; p = ternarySearch ( l , r , key , ar ) ; Console . WriteLine ( \" Index ▁ of ▁ \" + key + \" ▁ is ▁ \" + p ) ; key = 50 ; p = ternarySearch ( l , r , key , ar ) ; Console . WriteLine ( \" Index ▁ of ▁ \" + key + \" ▁ is ▁ \" + p ) ; } }"}
{"text": "Bilangan minimum mata yang akan dikeluarkan untuk mendapatkan mata yang tinggal di satu sisi paksi | C # Program untuk mencari mata minimum untuk dipindahkan supaya semua mata berada di sisi yang sama. ; Struktur untuk menyimpan koordinat satu titik. ; Berfungsi untuk mencari bilangan minimum mata; Bilangan mata di sebelah kiri y - paksi. ; Bilangan mata di sebelah kanan paksi y. ; Bilangan mata di atas x - paksi. ; Bilangan mata di bawah x - paksi. ; Kod pemacu", "code": "using System ; class GFG { public class Point { public int x , y ; public Point ( int x , int y ) { this . x = x ; this . y = y ; } } ; static int findmin ( Point [ ] p , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return Math . Min ( Math . Min ( a , b ) , Math . Min ( c , d ) ) ; } public static void Main ( String [ ] args ) { Point [ ] p = { new Point ( 1 , 1 ) , new Point ( 2 , 2 ) , new Point ( - 1 , - 1 ) , new Point ( - 2 , 2 ) } ; int n = p . Length ; Console . WriteLine ( findmin ( p , n ) ) ; } }"}
{"text": "Bilangan maksimum pengurangan pasangan yang mungkin pada triplet tertentu | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan maksimum pengurangan pasangan yang mungkin pada triplet tertentu; Tukar mereka menjadi array; Kedai kiraan operasi; Susun array; Jika dua elemen array pertama berkurangan kepada 0; Memohon operasi; Kiraan kenaikan; Cetak kiraan maksimum; Kod pemacu; Diberikan triplet", "code": "using System ; class GFG { static void maxOps ( int a , int b , int c ) { int [ ] arr = { a , b , c } ; int count = 0 ; while ( 1 != 0 ) { Array . Sort ( arr ) ; if ( arr [ 0 ] == 0 && arr [ 1 ] == 0 ) break ; arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ; count += 1 ; } Console . WriteLine ( count ) ; } public static void Main ( String [ ] args ) { int a = 4 , b = 3 , c = 2 ; maxOps ( a , b , c ) ; } }"}
{"text": "Kes | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang disusun; Untuk menyimpan frekuensi huruf kecil dan aksara huruf besar dalam rentetan yang diberikan; Jika watak semasa adalah huruf kecil maka kenaikan kekerapannya dalam array yang lebih rendah []; Lain kenaikan dalam array atas []; Petunjuk yang menunjuk pada huruf kecil terkecil dan watak -watak huruf kecil terkecil masing -masing dalam rentetan yang diberikan; Untuk setiap watak dalam rentetan yang diberikan; Jika watak semasa adalah huruf kecil kemudian gantikannya dengan watak kecil terkecil yang tersedia; Pengurangan kekerapan watak yang digunakan; Lain menggantikannya dengan watak huruf kecil terkecil yang ada; Pengurangan kekerapan watak yang digunakan; Kembalikan rentetan yang disusun; Kod pemacu", "code": "using System ; class GFG { static int MAX = 26 ; static string getSortedString ( char [ ] s , int n ) { int [ ] lower = new int [ MAX ] ; int [ ] upper = new int [ MAX ] ; int i = 0 , j = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( char . IsLower ( s [ i ] ) ) lower [ s [ i ] - ' a ' ] ++ ; else if ( char . IsUpper ( s [ i ] ) ) upper [ s [ i ] - ' A ' ] ++ ; } i = 0 ; while ( i < MAX && lower [ i ] == 0 ) i ++ ; while ( j < MAX && upper [ j ] == 0 ) j ++ ; for ( int k = 0 ; k < n ; k ++ ) { if ( char . IsLower ( s [ k ] ) ) { while ( lower [ i ] == 0 ) i ++ ; s [ k ] = ( char ) ( i + ' a ' ) ; lower [ i ] -- ; } else if ( char . IsUpper ( s [ k ] ) ) { while ( upper [ j ] == 0 ) j ++ ; s [ k ] = ( char ) ( j + ' A ' ) ; upper [ j ] -- ; } } return String . Join ( \" \" , s ) ; } public static void Main ( String [ ] args ) { String s = \" gEeksfOrgEEkS \" ; int n = s . Length ; Console . WriteLine ( getSortedString ( s . ToCharArray ( ) , n ) ) ; } }"}
{"text": "Cetak watak dan frekuensi mereka mengikut urutan kejadian | C # pelaksanaan untuk mencetak watak dan kekerapannya mengikut urutan kejadiannya; berfungsi untuk mencetak watak dan kekerapannya mengikut urutan kejadiannya; saiz rentetan 'str'; 'freq []' dilaksanakan sebagai jadual hash; mengumpul kekerapan setiap watak dalam 'str'; melintasi 'str' dari kiri ke kanan; Jika kekerapan watak str. Charat (i) tidak sama dengan 0; Cetak watak bersama kekerapannya; Kemas kini kekerapan STR. Charat (i) hingga 0 supaya watak yang sama tidak dicetak lagi; Program Pemandu untuk diuji di atas", "code": "using System ; class GFG { static int SIZE = 26 ; static void printCharWithFreq ( String str ) { int n = str . Length ; int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] != 0 ) { Console . Write ( str [ i ] ) ; Console . Write ( freq [ str [ i ] - ' a ' ] + \" ▁ \" ) ; freq [ str [ i ] - ' a ' ] = 0 ; } } } public static void Main ( ) { String str = \" geeksforgeeks \" ; printCharWithFreq ( str ) ; } }"}
{"text": "Kata -kata terbalik dalam rentetan yang diberikan | C # Program untuk membalikkan rentetan s = input ()", "code": "using System ; public class ReverseWords { public static void Main ( ) { string [ ] s = \" i ▁ like ▁ this ▁ program ▁ very ▁ much \" . Split ( ' ▁ ' ) ; string ans = \" \" ; for ( int i = s . Length - 1 ; i >= 0 ; i -- ) { ans += s [ i ] + \" ▁ \" ; } Console . Write ( \" Reversed ▁ String : STRNEWLINE \" ) ; Console . Write ( ans . Substring ( 0 , ans . Length - 1 ) ) ; } }"}
{"text": "Mengasingkan Perdana dan Bukan | C # Program untuk pendekatan di atas; Berfungsi untuk menjana nombor perdana menggunakan ayak eratosthenes; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Berfungsi untuk memisahkan prima dan bukan prima; Menjana semua prima sehingga 10 ^; Memulakan kiri dan kanan; Melintasi array; Peningkatan kiri manakala elemen array di sebelah kiri adalah perdana; Pengurangan betul manakala elemen array di sebelah kanan adalah bukan perdana; Jika kiri <kanan, kemudian swap arr [kiri] dan arr [kanan]; Swap arr [kiri] dan arr [kanan]; Cetak array terasing; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { public static void SieveOfEratosthenes ( bool [ ] prime , int n ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } public static void segregatePrimeNonPrime ( bool [ ] prime , int [ ] arr , int N ) { SieveOfEratosthenes ( prime , 10000000 ) ; int left = 0 , right = N - 1 ; while ( left < right ) { while ( prime [ arr [ left ] ] ) left ++ ; while ( ! prime [ arr [ right ] ] ) right -- ; if ( left < right ) { int temp = arr [ left ] ; arr [ left ] = arr [ right ] ; arr [ right ] = temp ; left ++ ; right -- ; } } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } public static void Main ( String [ ] args ) { bool [ ] prime = new bool [ 10000001 ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) prime [ i ] = true ; int [ ] arr = { 2 , 3 , 4 , 6 , 7 , 8 , 9 , 10 } ; int N = arr . Length ; segregatePrimeNonPrime ( prime , arr , N ) ; } }"}
{"text": "Hitung kedalaman pokok binari penuh dari preorder | C # Program untuk mencari ketinggian pokok binari penuh menggunakan preorder; berfungsi untuk mengembalikan maksimum ketinggian subtree kiri atau ketinggian subtree kanan; ketinggian calc subtree kiri (dalam preorder kiri subtree diproses sebelum kanan); ketinggian calc subtree kanan; Pembalut ke atas findDepThrec (); Program Pemandu", "code": "using System ; class GFG { static int findDepthRec ( char [ ] tree , int n , int index ) { if ( index >= n tree [ index ] == ' l ' ) return 0 ; index ++ ; int left = findDepthRec ( tree , n , index ) ; index ++ ; int right = findDepthRec ( tree , n , index ) ; return Math . Max ( left , right ) + 1 ; } static int findDepth ( char [ ] tree , int n ) { int index = 0 ; return ( findDepthRec ( tree , n , index ) ) ; } static public void Main ( ) { char [ ] tree = \" nlnnlll \" . ToCharArray ( ) ; int n = tree . Length ; Console . WriteLine ( findDepth ( tree , n ) ) ; } }"}
{"text": "Nombor terbesar di BST yang kurang daripada atau sama dengan N | C # kod untuk mencari nilai terbesar yang lebih kecil daripada atau sama dengan n; Struktur nod; Untuk membuat nod BST baru; Untuk memasukkan nod baru di BST; Jika pokok kosong kembali nod baru; Jika kunci kurang atau lebih besar maka nilai nod maka mengulangi pokok itu; Kembalikan penunjuk nod (tidak berubah); fungsi untuk mencari nilai maksimum kurang kemudian n; Kes asas; Jika nilai root lebih kecil, cuba subtree kanan; Jika kekunci Root lebih besar, nilai pulangan dari subtree kiri. ; Kod pemacu; Mencipta BST 5 / \\ 2 12 / \\ / \\ 1 3 9 21 / \\ 19 25", "code": "using System ; class GFG { class Node { public int key ; public Node left , right ; } static Node newNode ( int item ) { Node temp = new Node ( ) ; temp . key = item ; temp . left = null ; temp . right = null ; return temp ; } static Node insert ( Node node , int key ) { if ( node == null ) return newNode ( key ) ; if ( key < node . key ) node . left = insert ( node . left , key ) ; else if ( key > node . key ) node . right = insert ( node . right , key ) ; return node ; } static int findMaxforN ( Node root , int N ) { if ( root == null ) return - 1 ; if ( root . key == N ) return N ; else if ( root . key < N ) { int k = findMaxforN ( root . right , N ) ; if ( k == - 1 ) return root . key ; else return k ; } else if ( root . key > N ) return findMaxforN ( root . left , N ) ; return - 1 ; } public static void Main ( String [ ] args ) { int N = 4 ; Node root = null ; root = insert ( root , 25 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; Console . WriteLine ( findMaxforN ( root , N ) ) ; } }"}
{"text": "Unsur maksimum antara dua nod BST | C # Program untuk mencari elemen maksimum di jalan antara dua nod pokok carian binari. ; Buat dan kembalikan penunjuk nod baru. ; Masukkan nod baru dalam pokok carian binari. ; Kembalikan elemen maksimum antara nod dan nenek moyangnya. ; Melintasi jalan antara ansektor dan nod dan mencari elemen maksimum. ; Pulangan elemen maksimum di jalan antara dua nod yang diberikan BST. ; Mencari LCA Node X dan Node Y; Memeriksa jika kedua -dua nod terletak di sebelah kiri ibu bapa p. ; Memeriksa jika kedua -dua nod terletak di sebelah kanan ibu bapa p. ; Kembalikan maksimum elemen maksimum berlaku di jalan dari nenek moyang ke kedua -dua nod. ; Kod pemacu; Mewujudkan akar pokok carian binari; Memasukkan nod dalam pokok carian binari", "code": "public class Solution { public class Node { public Node left , right ; public int data ; } public static Node createNode ( int x ) { Node p = new Node ( ) ; p . data = x ; p . left = p . right = null ; return p ; } public static void insertNode ( Node root , int x ) { Node p = root , q = null ; while ( p != null ) { q = p ; if ( p . data < x ) { p = p . right ; } else { p = p . left ; } } if ( q == null ) { p = createNode ( x ) ; } else { if ( q . data < x ) { q . right = createNode ( x ) ; } else { q . left = createNode ( x ) ; } } } public static int maxelpath ( Node q , int x ) { Node p = q ; int mx = - 1 ; while ( p . data != x ) { if ( p . data > x ) { mx = Math . Max ( mx , p . data ) ; p = p . left ; } else { mx = Math . Max ( mx , p . data ) ; p = p . right ; } } return Math . Max ( mx , x ) ; } public static int maximumElement ( Node root , int x , int y ) { Node p = root ; while ( ( x < p . data && y < p . data ) || ( x > p . data && y > p . data ) ) { if ( x < p . data && y < p . data ) { p = p . left ; } else if ( x > p . data && y > p . data ) { p = p . right ; } } return Math . Max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; } public static void Main ( string [ ] args ) { int [ ] arr = new int [ ] { 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 } ; int a = 1 , b = 10 ; int n = arr . Length ; Node root = createNode ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { insertNode ( root , arr [ i ] ) ; } Console . WriteLine ( maximumElement ( root , a , b ) ) ; } }"}
{"text": "Pokok binari yang diulurkan | Penyisipan | C # Penyisipan program dalam pokok carian binari berulir. ; Benar jika penunjuk kiri titik kepada pendahulunya dalam inorder traversal; Benar jika penunjuk kanan menunjuk kepada pengganti dalam Inorder Traversal; Masukkan nod dalam pokok berulir binari; Mencari nod dengan nilai yang diberikan; Ibu bapa kunci yang akan dimasukkan; Jika kunci sudah ada, kembali; Mengemas kini penunjuk induk; Bergerak di subtree kiri. ; Bergerak ke Subtree Kanan. ; Buat nod baru; Mengembalikan pengganti inorder menggunakan RTHREAD; Jika RTHREAD ditetapkan, kita dapat dengan cepat mencari; Lain kembali anak paling kiri dari subtree kanan; Mencetak pokok berulir; Mencapai nod paling kiri; Satu demi satu pengganti cetak; Program Pemandu", "code": "public class solution { public class Node { public Node left , right ; public int info ; public bool lthread ; public bool rthread ; } public static Node insert ( Node root , int ikey ) { Node ptr = root ; Node par = null ; while ( ptr != null ) { if ( ikey == ( ptr . info ) ) { Console . Write ( \" Duplicate ▁ Key ▁ ! STRNEWLINE \" ) ; return root ; } par = ptr ; if ( ikey < ptr . info ) { if ( ptr . lthread == false ) { ptr = ptr . left ; } else { break ; } } else { if ( ptr . rthread == false ) { ptr = ptr . right ; } else { break ; } } } Node tmp = new Node ( ) ; tmp . info = ikey ; tmp . lthread = true ; tmp . rthread = true ; if ( par == null ) { root = tmp ; tmp . left = null ; tmp . right = null ; } else if ( ikey < ( par . info ) ) { tmp . left = par . left ; tmp . right = par ; par . lthread = false ; par . left = tmp ; } else { tmp . left = par ; tmp . right = par . right ; par . rthread = false ; par . right = tmp ; } return root ; } public static Node inorderSuccessor ( Node ptr ) { if ( ptr . rthread == true ) { return ptr . right ; } ptr = ptr . right ; while ( ptr . lthread == false ) { ptr = ptr . left ; } return ptr ; } public static void inorder ( Node root ) { if ( root == null ) { Console . Write ( \" Tree ▁ is ▁ empty \" ) ; } Node ptr = root ; while ( ptr . lthread == false ) { ptr = ptr . left ; } while ( ptr != null ) { Console . Write ( \" { 0 : D } ▁ \" , ptr . info ) ; ptr = inorderSuccessor ( ptr ) ; } } public static void Main ( string [ ] args ) { Node root = null ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; inorder ( root ) ; } }"}
{"text": "Pohon Carian Binari Bertulung | Penghapusan |  ; Benar jika penunjuk kiri titik kepada pendahulunya dalam inorder traversal; Benar jika penunjuk yang betul menunjukkan kepada pendahuluan dalam inorder traversal", "code": "public class Node { public Node left , right ; public int info ; public bool lthread ; public bool rthread ; } ;"}
{"text": "Pohon Carian Binari Bertulung | Penghapusan | Lengkapkan program C # untuk menunjukkan penghapusan dalam BST berulir; Benar jika penunjuk kiri titik kepada pendahulunya dalam inorder traversal; Benar jika penunjuk yang betul menunjuk kepada pendahulunya dalam traversal inorder; Masukkan nod dalam pokok berulir binari; Mencari nod dengan nilai yang diberikan; Ibu bapa kunci yang akan dimasukkan; Jika kunci sudah ada, kembali; Mengemas kini penunjuk induk; Bergerak di subtree kiri. ; Bergerak ke Subtree Kanan. ; Buat nod baru; Mengembalikan pengganti inorder menggunakan kanak -kanak kiri dan kanan (digunakan dalam penghapusan); Mengembalikan pengganti inorder menggunakan RTHREAD (digunakan dalam inorder); Jika RTHREAD ditetapkan, kita dapat dengan cepat mencari; Lain kembali anak paling kiri dari subtree kanan; Mencetak pokok berulir; Mencapai nod paling kiri; Satu demi satu pengganti cetak; Di sini 'par' adalah penunjuk kepada nod induk dan 'ptr' adalah penunjuk kepada nod semasa. ; Jika nod dipadam adalah akar; Jika nod dipadam adalah tersisa daripada ibu bapanya; Di sini 'par' adalah penunjuk kepada nod induk dan 'ptr' adalah penunjuk kepada nod semasa. ; Inisialisasi nod kanak -kanak yang akan dipadam telah meninggalkan anak. ; Node untuk dipadam mempunyai anak yang betul. ; Node yang akan dipadam adalah nod akar. ; Node dibiarkan anak ibu bapanya. ; Cari pengganti dan pendahulu; Jika PTR telah meninggalkan subtree. ; Jika PTR mempunyai subtree yang betul. ; Di sini 'par' adalah penunjuk kepada nod induk dan 'ptr' adalah penunjuk kepada nod semasa. ; Cari pengganti inorder dan ibu bapanya. ; Cari anak paling kiri pengganti; Menghapus kunci dari BST berulir dengan akar yang diberikan dan mengembalikan akar baru BST. ; Inisialisasi ibu bapa sebagai nod null dan ptrent sebagai akar. ; Tetapkan benar jika kunci dijumpai; Kunci carian di BST: Cari nod dan ibu bapanya. ; Dua kanak -kanak; Hanya anak kiri; Hanya anak yang betul; Tiada anak; Kod pemacu", "code": "using System ; class GFG { public class Node { public Node left , right ; public int info ; public bool lthread ; public bool rthread ; } ; static Node insert ( Node root , int ikey ) { Node ptr = root ; Node par = null ; while ( ptr != null ) { if ( ikey == ( ptr . info ) ) { Console . Write ( \" Duplicate ▁ Key ▁ ! STRNEWLINE \" ) ; return root ; } par = ptr ; if ( ikey < ptr . info ) { if ( ptr . lthread == false ) ptr = ptr . left ; else break ; } else { if ( ptr . rthread == false ) ptr = ptr . right ; else break ; } } Node tmp = new Node ( ) ; tmp . info = ikey ; tmp . lthread = true ; tmp . rthread = true ; if ( par == null ) { root = tmp ; tmp . left = null ; tmp . right = null ; } else if ( ikey < ( par . info ) ) { tmp . left = par . left ; tmp . right = par ; par . lthread = false ; par . left = tmp ; } else { tmp . left = par ; tmp . right = par . right ; par . rthread = false ; par . right = tmp ; } return root ; } static Node inSucc ( Node ptr ) { if ( ptr . rthread == true ) return ptr . right ; ptr = ptr . right ; while ( ptr . lthread == false ) ptr = ptr . left ; return ptr ; } static Node inorderSuccessor ( Node ptr ) { if ( ptr . rthread == true ) return ptr . right ; ptr = ptr . right ; while ( ptr . lthread == false ) ptr = ptr . left ; return ptr ; } static void inorder ( Node root ) { if ( root == null ) Console . Write ( \" Tree ▁ is ▁ empty \" ) ; Node ptr = root ; while ( ptr . lthread == false ) ptr = ptr . left ; while ( ptr != null ) { Console . Write ( \" { 0 } ▁ \" , ptr . info ) ; ptr = inorderSuccessor ( ptr ) ; } } static Node inPred ( Node ptr ) { if ( ptr . lthread == true ) return ptr . left ; ptr = ptr . left ; while ( ptr . rthread == false ) ptr = ptr . right ; return ptr ; } static Node caseA ( Node root , Node par , Node ptr ) { if ( par == null ) root = null ; else if ( ptr == par . left ) { par . lthread = true ; par . left = ptr . left ; } else { par . rthread = true ; par . right = ptr . right ; } return root ; } static Node caseB ( Node root , Node par , Node ptr ) { Node child ; if ( ptr . lthread == false ) child = ptr . left ; else child = ptr . right ; if ( par == null ) root = child ; else if ( ptr == par . left ) par . left = child ; else par . right = child ; Node s = inSucc ( ptr ) ; Node p = inPred ( ptr ) ; if ( ptr . lthread == false ) p . right = s ; else { if ( ptr . rthread == false ) s . left = p ; } return root ; } static Node caseC ( Node root , Node par , Node ptr ) { Node parsucc = ptr ; Node succ = ptr . right ; while ( succ . lthread == false ) { parsucc = succ ; succ = succ . left ; } ptr . info = succ . info ; if ( succ . lthread == true && succ . rthread == true ) root = caseA ( root , parsucc , succ ) ; else root = caseB ( root , parsucc , succ ) ; return root ; } static Node delThreadedBST ( Node root , int dkey ) { Node par = null , ptr = root ; int found = 0 ; while ( ptr != null ) { if ( dkey == ptr . info ) { found = 1 ; break ; } par = ptr ; if ( dkey < ptr . info ) { if ( ptr . lthread == false ) ptr = ptr . left ; else break ; } else { if ( ptr . rthread == false ) ptr = ptr . right ; else break ; } } if ( found == 0 ) Console . Write ( \" dkey ▁ not ▁ present ▁ in ▁ tree STRNEWLINE \" ) ; else if ( ptr . lthread == false && ptr . rthread == false ) root = caseC ( root , par , ptr ) ; else if ( ptr . lthread == false ) root = caseB ( root , par , ptr ) ; else if ( ptr . rthread == false ) root = caseB ( root , par , ptr ) ; else root = caseA ( root , par , ptr ) ; return root ; } public static void Main ( String [ ] args ) { Node root = null ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; root = delThreadedBST ( root , 20 ) ; inorder ( root ) ; } }"}
{"text": "Semak simetri mendatar dan menegak dalam matriks binari | C # Program untuk mencari jika matriks adalah simetri. ; Memulakan sebagai simetri mendatar dan menegak. ; Memeriksa simetri mendatar. Kami membandingkan baris pertama dengan baris terakhir, baris kedua dengan barisan terakhir kedua dan sebagainya. ; Memeriksa setiap sel lajur. ; Semak jika setiap sel adalah sama; Memeriksa simetri menegak. Kami membandingkan lajur pertama dengan lajur terakhir, xolumn kedua dengan lajur terakhir kedua dan sebagainya. ; Memeriksa setiap sel baris. ; Semak jika setiap sel adalah sama; Kod pemacu", "code": "using System ; public class GFG { static void checkHV ( int [ , ] arr , int N , int M ) { bool horizontal = true ; bool vertical = true ; for ( int i = 0 , k = N - 1 ; i < N / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i , j ] != arr [ k , j ] ) { horizontal = false ; break ; } } } for ( int i = 0 , k = M - 1 ; i < M / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i , j ] != arr [ k , j ] ) { horizontal = false ; break ; } } } if ( ! horizontal && ! vertical ) Console . WriteLine ( \" NO \" ) ; else if ( horizontal && ! vertical ) Console . WriteLine ( \" HORIZONTAL \" ) ; else if ( vertical && ! horizontal ) Console . WriteLine ( \" VERTICAL \" ) ; else Console . WriteLine ( \" BOTH \" ) ; } static public void Main ( ) { int [ , ] mat = { { 1 , 0 , 1 } , { 0 , 0 , 0 } , { 1 , 0 , 1 } } ; checkHV ( mat , 3 , 3 ) ; } }"}
{"text": "Gantikan setiap elemen matriks dengan maksimum GCD baris atau lajur | C # Program untuk menggantikan setiap elemen dengan maksimum GCD baris atau lajur. ; mengembalikan pembahagi biasa dua nombor; Mencari GCD setiap baris dan lajur dan menggantikan dengan setiap elemen dengan maksimum GCD baris atau lajur. ; Mengira GCD setiap baris dan setiap lajur dalam O (Mn) dan simpan dalam tatasusunan. ; Menggantikan elemen matriks; Program Pemandu", "code": "using System ; class GFG { static int R = 3 ; static int C = 4 ; static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static void replacematrix ( int [ , ] mat , int n , int m ) { int [ ] rgcd = new int [ R ] ; int [ ] cgcd = new int [ C ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i , j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i , j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i , j ] = Math . Max ( rgcd [ i ] , cgcd [ j ] ) ; } static public void Main ( ) { int [ , ] m = { { 1 , 2 , 3 , 3 } , { 4 , 5 , 6 , 6 } , { 7 , 8 , 9 , 9 } , } ; replacematrix ( m , R , C ) ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) Console . Write ( m [ i , j ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } } }"}
{"text": "Program untuk penambahan dua matriks | C # Program untuk penambahan dua matriks; Fungsi ini menambah [] [] dan b [] [], dan menyimpan hasil dalam c [] []; Kod pemacu", "code": "using System ; class GFG { static int N = 4 ; static void add ( int [ , ] A , int [ , ] B , int [ , ] C ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i , j ] = A [ i , j ] + B [ i , j ] ; } public static void Main ( ) { int [ , ] A = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int [ , ] B = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int [ , ] C = new int [ N , N ] ; int i , j ; add ( A , B , C ) ; Console . WriteLine ( \" Result ▁ matrix ▁ is ▁ \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) Console . Write ( C [ i , j ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } } }"}
{"text": "Program untuk pengurangan matriks | C # Program untuk pengurangan matriks; Fungsi ini menolak B [] [] dari [] [], dan menyimpan hasil dalam C [] []; Kod pemacu", "code": "using System ; class GFG { static int N = 4 ; public static void subtract ( int [ ] [ ] A , int [ ] [ ] B , int [ , ] C ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { C [ i , j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } } } public static void Main ( string [ ] args ) { int [ ] [ ] A = new int [ ] [ ] { new int [ ] { 1 , 1 , 1 , 1 } , new int [ ] { 2 , 2 , 2 , 2 } , new int [ ] { 3 , 3 , 3 , 3 } , new int [ ] { 4 , 4 , 4 , 4 } } ; int [ ] [ ] B = new int [ ] [ ] { new int [ ] { 1 , 1 , 1 , 1 } , new int [ ] { 2 , 2 , 2 , 2 } , new int [ ] { 3 , 3 , 3 , 3 } , new int [ ] { 4 , 4 , 4 , 4 } } ; int [ , ] C = new int [ N , N ] ; int i , j ; subtract ( A , B , C ) ; Console . Write ( \" Result ▁ matrix ▁ is ▁ STRNEWLINE \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { Console . Write ( C [ i , j ] + \" ▁ \" ) ; } Console . Write ( \" STRNEWLINE \" ) ; } } }"}
{"text": "Cari titik tetap (nilai sama dengan indeks) dalam array yang diberikan | C # Program untuk memeriksa titik tetap dalam array menggunakan carian linear; Jika tiada titik tetap hadir kemudian kembali - 1; Kod pemacu", "code": "using System ; class GFG { static int linearSearch ( int [ ] arr , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = arr . Length ; Console . Write ( \" Fixed ▁ Point ▁ is ▁ \" + linearSearch ( arr , n ) ) ; } }"}
{"text": "Cari titik tetap (nilai sama dengan indeks) dalam array yang diberikan | C # Program untuk memeriksa titik tetap dalam array menggunakan carian binari; rendah + (tinggi - rendah) / 2; ; Kembali - 1 jika tiada titik tetap; Kod pemacu", "code": "using System ; class GFG { static int binarySearch ( int [ ] arr , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = arr . Length ; Console . Write ( \" Fixed ▁ Point ▁ is ▁ \" + binarySearch ( arr , 0 , n - 1 ) ) ; } }"}
{"text": "Jumlah maksimum triplet dalam array | C # kod untuk mencari jumlah triplet maksimum; Memulakan jumlah dengan int_min; Kod yang didorong", "code": "using System ; class GFG { static int maxTripletSum ( int [ ] arr , int n ) { int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = arr . Length ; Console . WriteLine ( maxTripletSum ( arr , n ) ) ; } }"}
{"text": "Jumlah maksimum triplet dalam array | C # kod untuk mencari jumlah triplet maksimum; Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya tiga elemen dalam ARR []. ; Susun array yang diberikan; Selepas menyusun array. Tambah tiga elemen terakhir dari array yang diberikan; Kod yang didorong", "code": "using System ; class GFG { static int maxTripletSum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = arr . Length ; Console . WriteLine ( maxTripletSum ( arr , n ) ) ; } }"}
{"text": "Jumlah maksimum triplet dalam array | C # kod untuk mencari jumlah triplet maksimum; Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya tiga elemen dalam ARR []. ; Memulakan elemen maksimum maksimum dan maksimum maksimum maksimum; Mengemas kini elemen maksimum maksimum dan ketiga; Mengemas kini elemen maksimum maksimum dan ketiga; Mengemas kini elemen maksimum ketiga; Kod yang didorong", "code": "using System ; class GFG { static int maxTripletSum ( int [ ] arr , int n ) { int maxA = - 100000000 , maxB = - 100000000 ; int maxC = - 100000000 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = arr . Length ; Console . WriteLine ( maxTripletSum ( arr , n ) ) ; } }"}
{"text": "Carian Linear | C # kod ke linearly cari x dalam arr []. Jika x hadir kemudian kembalikan lokasi, jika tidak, pulangan - 1; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { public static int search ( int [ ] arr , int x ) { int n = arr . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int result = search ( arr , x ) ; if ( result == - 1 ) Console . WriteLine ( \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ) ; else Console . WriteLine ( \" Element ▁ is ▁ present ▁ at ▁ index ▁ \" + result ) ; } }"}
{"text": "Carian Linear | C # Program untuk carian linear; Jalankan gelung dari 0 ke kanan; Jika search_element ditemui dengan pembolehubah kiri; Jika search_element ditemui dengan pemboleh ubah yang betul; jika elemen tidak dijumpai; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { public static void search ( int [ ] arr , int search_Element ) { int left = 0 ; int length = arr . Length ; int right = length - 1 ; int position = - 1 ; for ( left = 0 ; left <= right ; ) { if ( arr [ left ] == search_Element ) { position = left ; Console . WriteLine ( \" Element ▁ found ▁ in ▁ Array ▁ at ▁ \" + ( position + 1 ) + \" ▁ Position ▁ with ▁ \" + ( left + 1 ) + \" ▁ Attempt \" ) ; break ; } if ( arr [ right ] == search_Element ) { position = right ; Console . WriteLine ( \" Element ▁ found ▁ in ▁ Array ▁ at ▁ \" + ( position + 1 ) + \" ▁ Position ▁ with ▁ \" + ( length - right ) + \" ▁ Attempt \" ) ; break ; } left ++ ; right -- ; } if ( position == - 1 ) Console . WriteLine ( \" Not ▁ found ▁ in ▁ Array ▁ with ▁ \" + left + \" ▁ Attempt \" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int search_element = 5 ; search ( arr , search_element ) ; } }"}
{"text": "Mengira jenis | C # Pelaksanaan jenis pengiraan; Fungsi utama yang menyusun rentetan yang diberikan [] dalam susunan abjad; Pelbagai watak output yang akan menyusun ARR; Buat array kiraan untuk menyimpan kiraan aksara inidividul dan memulakan array kiraan sebagai 0; menyimpan kiraan setiap watak; Tukar kiraan [i] supaya kiraan [i] kini mengandungi kedudukan sebenar watak ini dalam pelbagai output; Bina pelbagai watak output untuk menjadikannya stabil, kami beroperasi dalam urutan terbalik. ; Salin array output ke ARR, supaya ARR kini mengandungi aksara yang disusun; Kaedah Pemandu", "code": "using System ; class GFG { static void countsort ( char [ ] arr ) { int n = arr . Length ; char [ ] output = new char [ n ] ; int [ ] count = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; ++ i ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; for ( int i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( int i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; } public static void Main ( ) { char [ ] arr = { ' g ' , ' e ' , ' e ' , ' k ' , ' s ' , ' f ' , ' o ' , ' r ' , ' g ' , ' e ' , ' e ' , ' k ' , ' s ' } ; countsort ( arr ) ; Console . Write ( \" Sorted ▁ character ▁ array ▁ is ▁ \" ) ; for ( int i = 0 ; i < arr . Length ; ++ i ) Console . Write ( arr [ i ] ) ; } }"}
{"text": "Mengira jenis | Jenis pengiraan yang mengambil nombor negatif juga; Fungsi yang menyusun ARR []; berfungsi untuk mencetak array; Kod pemacu", "code": "using System ; using System . Collections . Generic ; using System . Linq ; class GFG { static void countSort ( int [ ] arr ) { int max = arr . Max ( ) ; int min = arr . Min ( ) ; int range = max - min + 1 ; int [ ] count = new int [ range ] ; int [ ] output = new int [ arr . Length ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) { count [ arr [ i ] - min ] ++ ; } for ( int i = 1 ; i < count . Length ; i ++ ) { count [ i ] += count [ i - 1 ] ; } for ( int i = arr . Length - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] - min ] - 1 ] = arr [ i ] ; count [ arr [ i ] - min ] -- ; } for ( int i = 0 ; i < arr . Length ; i ++ ) { arr [ i ] = output [ i ] ; } } static void printArray ( int [ ] arr ) { for ( int i = 0 ; i < arr . Length ; i ++ ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } Console . WriteLine ( \" \" ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { - 5 , - 10 , 0 , - 3 , 8 , 5 , - 1 , 10 } ; countSort ( arr ) ; printArray ( arr ) ; } }"}
{"text": "Koefisien binomial | DP | C # Kod untuk Pengaturcaraan Dinamik | Tetapkan 9 (pekali binomial); Pulangan nilai pekali binomial c (n, k); Kes asas; Berulang; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; } public static void Main ( ) { int n = 5 , k = 2 ; Console . Write ( \" Value ▁ of ▁ C ( \" + n + \" , \" + k + \" ) ▁ is ▁ \" + binomialCoeff ( n , k ) ) ; } }"}
{"text": "Koefisien binomial | DP | C # Kod untuk Pengaturcaraan Dinamik | Tetapkan 9 (pekali binomial); NC0 adalah 1; Kirakan baris seterusnya segitiga Pascal menggunakan baris sebelumnya; Kod pemacu", "code": "using System ; class GFG { static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } public static void Main ( ) { int n = 5 , k = 2 ; Console . WriteLine ( \" Value ▁ of ▁ C ( \" + n + \" ▁ \" + k + \" ) ▁ is ▁ \" + binomialCoeff ( n , k ) ) ; } }"}
{"text": "Koefisien binomial | DP | C # Program untuk pendekatan di atas; Berfungsi untuk mencari pekali binomial; Mendapatkan penyongsangan modular untuk semua nombor dari 2 hingga R berkenaan dengan M di sini M = 1000000007; untuk 1 / (r!) Bahagian; untuk (n) * (n - 1) * (n - 2) * ... * (n - r + 1) bahagian; Kod pemacu", "code": "using System ; public class GFG { static int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long m = 1000000007 ; long [ ] inv = new long [ r + 1 ] ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ ( int ) ( m % i ) ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( int ) ( ( ( ans % m ) * ( inv [ i ] % m ) ) % m ) ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( int ) ( ( ( ans % m ) * ( i % m ) ) % m ) ; } return ans ; } public static void Main ( String [ ] args ) { int n = 5 , r = 2 ; Console . Write ( \" Value ▁ of ▁ C ( \" + n + \" , ▁ \" + r + \" ) ▁ is ▁ \" + binomialCoeff ( n , r ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Masalah Partition | DP | Program C # berasaskan pengaturcaraan dinamik untuk masalah partition; Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah semua elemen; Permulaan array bahagian sebagai 0; Isi jadual partition dengan cara bawah; Unsur yang akan dimasukkan dalam jumlah tidak boleh lebih besar daripada jumlahnya; Semak jika jumlah - arr [i] boleh dibentuk dari subset menggunakan elemen sebelum indeks I; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static bool findPartiion ( int [ ] arr , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool [ ] part = new bool [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = false ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ sum / 2 ] ; } static void Main ( ) { int [ ] arr = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = 6 ; if ( findPartiion ( arr , n ) == true ) Console . WriteLine ( \" Can ▁ be ▁ divided ▁ into ▁ two ▁ \" + \" subsets ▁ of ▁ equal ▁ sum \" ) ; else Console . WriteLine ( \" Can ▁ not ▁ be ▁ divided ▁ into ▁ \" + \" two ▁ subsets ▁ of ▁ equal ▁ sum \" ) ; } }"}
{"text": "Pengaturcaraan Dinamik | Penyelesaian rekursif untuk masalah jumlah subset; Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Kod pemacu", "code": "using System ; class GFG { static bool isSubsetSum ( int [ ] set , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } public static void Main ( ) { int [ ] set = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = set . Length ; if ( isSubsetSum ( set , n , sum ) == true ) Console . WriteLine ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) ; else Console . WriteLine ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) ; } }"}
{"text": "Pengaturcaraan Dinamik | Penyelesaian pengaturcaraan dinamik untuk masalah jumlah subset; Pulangan benar jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara bawah; Kod pemacu", "code": "using System ; class GFG { static bool isSubsetSum ( int [ ] set , int n , int sum ) { bool [ , ] subset = new bool [ sum + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ 0 , i ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ i , 0 ] = false ; for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i , j ] = subset [ i , j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i , j ] = subset [ i , j ] || subset [ i - set [ j - 1 ] , j - 1 ] ; } } return subset [ sum , n ] ; } public static void Main ( ) { int [ ] set = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = set . Length ; if ( isSubsetSum ( set , n , sum ) == true ) Console . WriteLine ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) ; else Console . WriteLine ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) ; } }"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Program C # rekursif untuk mencetak bilangan maksimum A menggunakan empat kunci berikut; Fungsi rekursif yang mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7; Memulakan hasil; Cuba semua rehat yang mungkin - mata untuk mana -mana kekunci n, kita perlu gelung dari n - 3 kekunci kembali ke 1 keystroke untuk mencari breakpoint 'b' selepas itu kita akan mempunyai ctrl - a, ctrl - c dan kemudian hanya ctrl - v sepanjang jalan. ; Jika titik putus adalah s pada b 'th keystroke maka rentetan optimum akan mempunyai panjang (n-b-1)*skrin [b-1]; ; Kod pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "using System ; class GFG { static int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; } static void Main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) Console . WriteLine ( \" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ \" + N + \" ▁ keystrokes ▁ is ▁ \" + findoptimal ( N ) ) ; } }"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Program C # berasaskan pengaturcaraan yang dinamik untuk mencari bilangan maksimum yang boleh dicetak menggunakan empat kunci; Fungsi ini mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7; Array untuk menyimpan hasil subproblem; Untuk memilih titik putus; Memulakan array panjang optimum untuk uptil 6 strok input; Selesaikan semua subproblem dengan cara bawah; Memulakan panjang rentetan optimum untuk ketukan n; Untuk mana -mana kekunci n, kita perlu gelung dari n - 3 ketukan kembali ke 1 keystroke untuk mencari breakpoint 'b' selepas itu kita akan mempunyai ctrl - a, ctrl - c dan kemudian hanya ctrl - v sepanjang jalan. ; Sekiranya titik putus berada di b 'th keystroke maka rentetan optimum akan mempunyai panjang (n-b-1)*skrin [b-1]; ; Program pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "using System ; public class GFG { static int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; } public static void Main ( String [ ] args ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) Console . WriteLine ( \" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ { 0 } ▁ keystrokes ▁ is ▁ { 1 } STRNEWLINE \" , N , findoptimal ( N ) ) ; } }"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Program C # berasaskan pengaturcaraan yang dinamik untuk mencari bilangan maksimum yang boleh dicetak menggunakan empat kunci; Fungsi ini mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7; Array untuk menyimpan hasil subproblem; Memulakan Arus Panjang Optimal untuk Uptil 6 Strok Input. ; Selesaikan semua subproblem dengan cara bawah; Untuk mana -mana kekunci n, kita perlu memilih antara: - 1. Menekan Ctrl - V sekali selepas menyalin A 'S oleh ~ - 3 »Keystrokes. ~ 2. Tekan ~ Ctrl - V ~ Dua kali ~ Selepas menyalin 'S yang diperolehi oleh N - 4 Keystrokes. 3. Menekan Ctrl - V tiga kali selepas menyalin A 'S yang diperolehi oleh N -5 Keystrokes. ; Kod pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "using System ; class GFG { static int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . Max ( 2 * screen [ n - 4 ] , Math . Max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; } public static void Main ( String [ ] args ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) Console . Write ( \" Maximum ▁ Number ▁ of ▁ A ' s ▁ with \" + \" ▁ { 0 } ▁ keystrokes ▁ is ▁ { 1 } STRNEWLINE \" , N , findoptimal ( N ) ) ; } }"}
{"text": "Tulis program untuk mengira POW (x, n) |  ; Fungsi untuk mengira x yang dibangkitkan kepada kuasa y; Program untuk menguji kuasa fungsi", "code": "using System ; public class GFG { static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } public static void Main ( ) { int x = 2 ; int y = 3 ; Console . Write ( power ( x , y ) ) ; } }"}
{"text": "Tulis program untuk mengira POW (x, n) | Berfungsi untuk mengira x yang dibangkitkan kepada kuasa y dalam o (logn)", "code": "static int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }"}
{"text": "Tulis program untuk mengira POW (x, n) | C # kod untuk fungsi kuasa lanjutan yang boleh berfungsi untuk float x dan negatif y; Program untuk menguji kuasa fungsi", "code": "using System ; public class GFG { static float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } } public static void Main ( ) { float x = 2 ; int y = - 3 ; Console . Write ( power ( x , y ) ) ; } }"}
{"text": "Tulis program untuk mengira POW (x, n) | C # Program untuk pendekatan di atas; Jika x ^ 0 kembali 1; Jika kita perlu mencari 0 ^ y; Untuk semua kes lain; Kod pemacu", "code": "using System ; class GFG { public static int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; } public static void Main ( String [ ] args ) { int x = 2 ; int y = 3 ; Console . WriteLine ( power ( x , y ) ) ; } }"}
{"text": "Tulis program untuk mengira POW (x, n) | C # Program untuk pendekatan di atas; Matematik. pow () adalah fungsi yang mengembalikan nombor terapung; Kod pemacu", "code": "using System ; public class GFG { public static int power ( int x , int y ) { return ( int ) Math . Pow ( x , y ) ; } static public void Main ( ) { int x = 2 ; int y = 3 ; Console . WriteLine ( power ( x , y ) ) ; } }"}
{"text": "Kaedah Babylon untuk Root Square | C # porgram untuk kaedah Babilonia akar persegi; Mengembalikan akar kuadrat n. Perhatikan bahawa fungsi itu; Kami menggunakan N sendiri sebagai penghampiran awal ini pasti dapat diperbaiki; E memutuskan tahap ketepatan; Kod pemacu", "code": "using System ; class GFG { static float squareRoot ( float n ) { float x = n ; float y = 1 ; double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } public static void Main ( ) { int n = 50 ; Console . Write ( \" Square ▁ root ▁ of ▁ \" + n + \" ▁ is ▁ \" + squareRoot ( n ) ) ; } }"}
{"text": "Purata aliran nombor | C # Program untuk mencari purata aliran nombor; Mengembalikan purata baru selepas termasuk x; Mencetak purata aliran nombor; Kod pemacu", "code": "using System ; class GFG { static float getAvg ( float prev_avg , float x , int n ) { return ( prev_avg * n + x ) / ( n + 1 ) ; } static void streamAvg ( float [ ] arr , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( avg , arr [ i ] , i ) ; Console . WriteLine ( \" Average ▁ of ▁ { 0 } ▁ \" + \" numbers ▁ is ▁ { 1 } \" , i + 1 , avg ) ; } return ; } public static void Main ( String [ ] args ) { float [ ] arr = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . Length ; streamAvg ( arr , n ) ; } }"}
{"text": "Purata aliran nombor |  ; Mengembalikan purata baru selepas termasuk x; Mencetak purata aliran nombor; Kod pemacu", "code": "using System ; class GFG { static int sum , n ; static float getAvg ( int x ) { sum += x ; return ( ( ( float ) sum ) / ++ n ) ; } static void streamAvg ( float [ ] arr , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( ( int ) arr [ i ] ) ; Console . WriteLine ( \" Average ▁ of ▁ { 0 } ▁ numbers ▁ \" + \" is ▁ { 1 } \" , ( i + 1 ) , avg ) ; } return ; } static int Main ( ) { float [ ] arr = new float [ ] { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . Length ; streamAvg ( arr , n ) ; return 0 ; } }"}
{"text": "Koefisien Binomial Ruang dan Masa yang cekap | C # Program untuk mengira C (n, k); Pulangan nilai pekali binomial c (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Kod pemacu", "code": "using System ; class BinomialCoefficient { static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static void Main ( ) { int n = 8 ; int k = 2 ; Console . Write ( \" Value ▁ of ▁ C ( \" + n + \" , ▁ \" + k + \" ) ▁ \" + \" is \" + \" ▁ \" + binomialCoeff ( n , k ) ) ; } }"}
{"text": "Program yang cekap untuk mencetak semua faktor utama nombor tertentu | C # Program untuk mencetak semua faktor utama; Fungsi untuk mencetak semua faktor utama nombor n tertentu; Cetak bilangan 2 s yang membahagikan n; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, cetak saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes whien n adalah nombor perdana yang lebih besar daripada 2; Kod pemacu", "code": "using System ; namespace prime { public class GFG { public static void primeFactors ( int n ) { while ( n % 2 == 0 ) { Console . Write ( 2 + \" ▁ \" ) ; n /= 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { Console . Write ( i + \" ▁ \" ) ; n /= i ; } } if ( n > 2 ) Console . Write ( n ) ; } public static void Main ( ) { int n = 315 ; primeFactors ( n ) ; } } }"}
{"text": "Cetak semua kemungkinan kombinasi elemen R dalam pelbagai saiz n | C # Program untuk mencetak semua gabungan saiz R dalam pelbagai saiz n; Fungsi utama yang mencetak semua kombinasi saiz r dalam arr [] saiz n. Fungsi ini terutamanya menggunakan gabunganUtil (); Arahan sementara untuk menyimpan semua gabungan satu demi satu; Cetak semua kombinasi menggunakan data temprary array [] '; arr [] - -> data array input [] - -> array sementara untuk menyimpan kombinasi semasa & akhir - -> menatap dan mengakhiri indeks dalam arr [] indeks - -> indeks semasa dalam data [] r - -> saiz kombinasi yang akan dicetak; Gabungan semasa sudah siap dicetak, mencetaknya; Gantikan indeks dengan semua elemen yang mungkin. Keadaan \"Akhir - I + 1 = u r - indeks\" memastikan bahawa termasuk satu elemen di indeks akan membuat kombinasi dengan elemen yang tinggal pada kedudukan yang tinggal; Kod pemacu", "code": "using System ; class GFG { static void printCombination ( int [ ] arr , int n , int r ) { int [ ] data = new int [ r ] ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; } static void combinationUtil ( int [ ] arr , int [ ] data , int start , int end , int index , int r ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) Console . Write ( data [ j ] + \" ▁ \" ) ; Console . WriteLine ( \" \" ) ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . Length ; printCombination ( arr , n , r ) ; } }"}
{"text": "Cetak semua kemungkinan kombinasi elemen R dalam pelbagai saiz n | C # Program untuk mencetak semua gabungan saiz R dalam pelbagai saiz n; Fungsi utama yang mencetak semua kombinasi saiz r dalam arr [] saiz n. Fungsi ini terutamanya menggunakan gabunganUtil (); Arahan sementara untuk menyimpan semua gabungan satu demi satu; Cetak semua kombinasi menggunakan data temprary array [] '; arr [] - -> data array input [] - -> array sementara untuk menyimpan kombinasi semasa & akhir - -> menatap dan mengakhiri indeks dalam arr [] indeks - -> indeks semasa dalam data [] r - -> saiz kombinasi yang akan dicetak; Gabungan semasa sudah siap dicetak, mencetaknya; Apabila tidak ada lagi elemen yang ada untuk dimasukkan ke dalam data []; Semasa dimasukkan, letakkan seterusnya di lokasi seterusnya; Semasa dikecualikan, gantikannya dengan seterusnya (perhatikan bahawa i + 1 diluluskan, tetapi indeks tidak berubah); Kod pemacu", "code": "using System ; class GFG { static void printCombination ( int [ ] arr , int n , int r ) { int [ ] data = new int [ r ] ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; } static void combinationUtil ( int [ ] arr , int n , int r , int index , int [ ] data , int i ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) Console . Write ( data [ j ] + \" ▁ \" ) ; Console . WriteLine ( \" \" ) ; return ; } if ( i >= n ) return ; data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ; combinationUtil ( arr , n , r , index , data , i + 1 ) ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . Length ; printCombination ( arr , n , r ) ; } }"}
{"text": "Kira semua kumpulan saiz 2 atau 3 yang mungkin mempunyai jumlah sebagai pelbagai 3 | C # Program untuk mengira semua kumpulan yang mungkin saiz 2 atau 3 yang mempunyai jumlah sebagai pelbagai daripada 3; Mengembalikan kiraan semua kumpulan yang mungkin boleh dibentuk dari unsur -unsur []. ; Buat array C [3] untuk menyimpan bilangan elemen dengan selebihnya 0, 1 dan 2. C [i] akan menyimpan kiraan elemen dengan selebihnya I; Untuk menyimpan hasilnya; Mengira elemen dengan selebihnya 0, 1 dan 2; Kes 3. A: Kumpulan Kumpulan Saiz 2 dari 0 elemen yang tinggal; Kes 3. B: Kumpulan Kumpulan Saiz 2 dengan satu elemen dengan 1 baki dan lain -lain dengan 2 selebihnya; Kes 4. A: Kumpulan Kumpulan Saiz 3 dengan semua 0 elemen yang tinggal; Kes 4. B: Kumpulan Kumpulan Saiz 3 dengan semua 1 elemen yang tinggal; Kes 4. C: Kumpulan Kumpulan Saiz 3 dengan semua 2 elemen yang tinggal; Kes 4. C: Kumpulan Kumpulan Saiz 3 dengan sisa yang berbeza; Mengembalikan jumlah jumlah yang disimpan dalam res; Kod pemacu", "code": "using System ; class FindGroups { int findgroups ( int [ ] arr , int n ) { int [ ] c = new int [ ] { 0 , 0 , 0 } ; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; } public static void Main ( ) { FindGroups groups = new FindGroups ( ) ; int [ ] arr = { 3 , 6 , 7 , 2 , 9 } ; int n = arr . Length ; Console . Write ( \" Required ▁ number ▁ of ▁ groups ▁ are ▁ \" + groups . findgroups ( arr , n ) ) ; } }"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | C # Program untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Pertama n dalam keadaan di bawah adalah untuk kes di mana n adalah 0; Kod pemacu", "code": "using System ; class GFG { static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } public static void Main ( ) { int n = 0 ; Console . WriteLine ( nextPowerOf2 ( n ) ) ; } }"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | C # Program untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Kod pemacu", "code": "using System ; class GFG { static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; } public static void Main ( ) { int n = 5 ; Console . Write ( nextPowerOf2 ( n ) ) ; } }"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | C # Program untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Cari kuasa seterusnya dua untuk n. Jika n sendiri adalah kuasa dua maka pulangan n; Kod pemacu", "code": "using System ; class GFG { static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( nextPowerOf2 ( n ) ) ; } }"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | C # kod untuk memisahkan 0 s dan 1 s dalam array; berfungsi untuk memisahkan 0 s dan 1 s; mengira tiada sifar dalam arr; Gelung mengisi ARR dengan 0 sehingga dikira; gelung mengisi ruang yang tinggal dengan 1; berfungsi untuk mencetak array terasing; fungsi pemacu", "code": "using System ; class GFG { static void segregate0and1 ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count ++ ; } for ( int i = 0 ; i < count ; i ++ ) arr [ i ] = 0 ; for ( int i = count ; i < n ; i ++ ) arr [ i ] = 1 ; } static void print ( int [ ] arr , int n ) { Console . WriteLine ( \" Array ▁ after ▁ segregation ▁ is ▁ \" ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } public static void Main ( ) { int [ ] arr = new int [ ] { 0 , 1 , 0 , 1 , 1 , 1 } ; int n = arr . Length ; segregate0and1 ( arr , n ) ; print ( arr , n ) ; } }"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | C # Program untuk menyusun array binari dalam satu pas; Berfungsi untuk meletakkan semua 0 s di kiri dan semua 1 s di sebelah kanan; Memulakan indeks kiri dan kanan; Indeks Kiri Peningkatan semasa kita melihat 0 di sebelah kiri; Indeks kanan pengurangan semasa kita melihat 1 di sebelah kanan; Jika kiri lebih kecil daripada kanan maka terdapat 1 di sebelah kiri dan 0 di sebelah kanan. Pertukaran arr [kiri] dan arr [kanan]; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class Segregate { void segregate0and1 ( int [ ] arr , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } } public static void Main ( ) { Segregate seg = new Segregate ( ) ; int [ ] arr = new int [ ] { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = arr . Length ; seg . segregate0and1 ( arr , arr_size ) ; Console . WriteLine ( \" Array ▁ after ▁ segregation ▁ is ▁ \" ) ; for ( i = 0 ; i < 6 ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } }"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | C # kod untuk mengasingkan 0 dan 1; Kaedah untuk pemisahan 0 dan 1 diberikan array input; Kod pemacu", "code": "using System ; class GFG { static void segregate0and1 ( int [ ] arr ) { int type0 = 0 ; int type1 = arr . Length - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type1 ] = arr [ type1 ] + arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] - arr [ type0 ] ; arr [ type1 ] = arr [ type1 ] - arr [ type0 ] ; type1 -- ; } else { type0 ++ ; } } } public static void Main ( string [ ] args ) { int [ ] array = new int [ ] { 0 , 1 , 0 , 1 , 1 , 1 } ; segregate0and1 ( array ) ; Console . Write ( \" Array ▁ after ▁ segregation ▁ is ▁ \" ) ; foreach ( int a in array ) { Console . Write ( a + \" ▁ \" ) ; } } }"}
{"text": "Unsur -unsur bersebelahan yang berbeza dalam array | C # Program untuk memeriksa sama ada kita boleh membuat jiran berbeza. ; peta yang digunakan untuk mengira kekerapan setiap elemen yang berlaku dalam array; Dalam gelung ini kita mengira kekerapan elemen melalui peta m. ; MX Simpan kekerapan elemen yang paling banyak berlaku dalam array. ; Dalam gelung ini kita mengira kekerapan maksimum dan simpannya dalam MX yang berubah -ubah. ; Dengan menukar kita boleh menyesuaikan array hanya apabila kekerapan elemen yang berlaku kebanyakannya kurang daripada atau sama dengan (n + 1) / 2. ; Kaedah utama", "code": "using System ; using System . Collections . Generic ; class GFG { public static void distinctAdjacentElement ( int [ ] a , int n ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( m . ContainsKey ( a [ i ] ) ) { int x = m [ a [ i ] ] + 1 ; m [ a [ i ] ] = x ; } else { m [ a [ i ] ] = 1 ; } } int mx = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( mx < m [ a [ i ] ] ) { mx = m [ a [ i ] ] ; } } if ( mx > ( n + 1 ) / 2 ) { Console . WriteLine ( \" NO \" ) ; } else { Console . WriteLine ( \" YES \" ) ; } } public static void Main ( string [ ] args ) { int [ ] a = new int [ ] { 7 , 7 , 7 , 7 } ; int n = 4 ; distinctAdjacentElement ( a , n ) ; } }"}
{"text": "Memandangkan array arr [], cari maksimum j | C # program untuk mencari maksimum j a saya seperti arr [j]> arr [i]; Untuk array yang diberikan [], mengembalikan maksimum j - i sedemikian rupa sehingga arr [j]> arr [i]; Program Pemandu", "code": "using System ; class GFG { static int maxIndexDiff ( int [ ] arr , int n ) { int maxDiff = - 1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; } public static void Main ( ) { int [ ] arr = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = arr . Length ; int maxDiff = maxIndexDiff ( arr , n ) ; Console . Write ( maxDiff ) ; } }"}
{"text": "Memandangkan array arr [], cari maksimum j | Untuk array yang diberikan [] arr, mengira maksimum j a i sedemikian rupa sehingga arr [j] arr [i]; Buat array MaxFromend; Kami menyimpan ini sebagai jawapan semasa dan mencari nombor yang lebih besar lagi ke sebelah kanan; Menjaga jejak perbezaan maksimum indeks", "code": "using System ; class GFG { public static void Main ( String [ ] args ) { int [ ] v = { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int n = v . Length ; int [ ] maxFromEnd = new int [ n + 1 ] ; for ( int i = 0 ; i < maxFromEnd . Length ; i ++ ) maxFromEnd [ i ] = int . MinValue ; for ( int i = v . Length - 1 ; i >= 0 ; i -- ) { maxFromEnd [ i ] = Math . Max ( maxFromEnd [ i + 1 ] , v [ i ] ) ; } int result = 0 ; for ( int i = 0 ; i < v . Length ; i ++ ) { int low = i + 1 , high = v . Length - 1 , ans = i ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( v [ i ] <= maxFromEnd [ mid ] ) { ans = Math . Max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } result = Math . Max ( result , ans - i ) ; } Console . Write ( result + \" STRNEWLINE \" ) ; } }"}
{"text": "Memandangkan array arr [], cari maksimum j | C # Pelaksanaan pendekatan hashMap; Fungsi untuk mencari perbezaan indeks maksimum; Initilaise unordered_map; Berulang dari 0 hingga n - 1; Sort arr; Berulang dari 0 hingga n - 1; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; public class GFG { static int maxIndexDiff ( List < int > arr , int n ) { Dictionary < int , List < int > > hashmap = new Dictionary < int , List < int > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hashmap . ContainsKey ( arr [ i ] ) ) { hashmap [ arr [ i ] ] . Add ( i ) ; } else { hashmap . Add ( arr [ i ] , new List < int > ( ) ) ; hashmap [ arr [ i ] ] . Add ( i ) ; } } arr . Sort ( ) ; int maxDiff = - 1 ; int temp = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( temp > hashmap [ arr [ i ] ] [ 0 ] ) { temp = hashmap [ arr [ i ] ] [ 0 ] ; } maxDiff = Math . Max ( maxDiff , hashmap [ arr [ i ] ] [ hashmap [ arr [ i ] ] . Count - 1 ] - temp ) ; } return maxDiff ; } static public void Main ( ) { int n = 9 ; List < int > arr = new List < int > ( ) ; arr . Add ( 34 ) ; arr . Add ( 8 ) ; arr . Add ( 10 ) ; arr . Add ( 3 ) ; arr . Add ( 2 ) ; arr . Add ( 80 ) ; arr . Add ( 30 ) ; arr . Add ( 33 ) ; arr . Add ( 1 ) ; int ans = maxIndexDiff ( arr , n ) ; Console . WriteLine ( \" The ▁ maxIndexDiff ▁ is ▁ : ▁ \" + ans ) ; } }"}
{"text": "Cetak elemen array yang berbeza | C # Program untuk mencetak elemen yang disusun. ; Buat set menggunakan elemen array; Cetak kandungan set. ; Kod pemacu", "code": "using System ; using System . Collections . Generic ; using System . Linq ; class GFG { static void printRepeating ( int [ ] arr , int size ) { SortedSet < int > s = new SortedSet < int > ( arr ) ; foreach ( var n in s ) { Console . Write ( n + \" ▁ \" ) ; } } public static void Main ( ) { int [ ] arr = { 1 , 3 , 2 , 2 , 1 } ; int n = arr . Length ; printRepeating ( arr , n ) ; } }"}
{"text": "Swap minimum untuk membuat dua tatasusunan sama | C # Program untuk membuat array yang sama dengan yang lain menggunakan bilangan swap minimum; Fungsi Mengembalikan bilangan swap minimum yang diperlukan untuk menyusun array kaedah ini diambil dari bawah pasca www. Geeksforgeeks. org / minimum - nombor - swap - diperlukan - sort - array / https :; Buat pelbagai pasangan di mana elemen pertama adalah elemen array dan elemen kedua adalah kedudukan elemen pertama; Susun array dengan nilai elemen array untuk mendapatkan kedudukan yang betul setiap elemen sebagai elemen kedua pasangan. ; Untuk menjejaki elemen yang dikunjungi. Memulakan semua elemen yang tidak dikunjungi atau palsu. ; Memulakan hasil; Elemen Array Traverse; sudah bertukar dan diperbetulkan atau sudah hadir di pos yang betul; Ketahui bilangan nod dalam kitaran ini dan tambah dalam ANS; Pindah ke Node Next; Kemas kini jawapan dengan menambahkan kitaran semasa. ; Hasil pulangan; Kaedah Mengembalikan bilangan swap minimum untuk membuat array B sama seperti array A; peta untuk menyimpan kedudukan elemen dalam Array B Kami pada dasarnya menyimpan elemen untuk indeks pemetaan. ; Kini kami menyimpan kedudukan array elemen dalam Array B .; Menghidupkan swap minimum untuk menyusun dalam array yang diubah suai b sebagai jawapan akhir; Kod pemacu", "code": "using System ; using System . Collections . Generic ; using System . Linq ; public class GFG { static int minSwapsToSort ( int [ ] arr , int n ) { List < List < int > > arrPos = new List < List < int > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arrPos . Add ( new List < int > ( ) { arr [ i ] , i } ) ; } arrPos = arrPos . OrderBy ( x => x [ 0 ] ) . ToList ( ) ; bool [ ] vis = new bool [ n ] ; Array . Fill ( vis , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] arrPos [ i ] [ 1 ] == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrPos [ j ] [ 1 ] ; cycle_size ++ ; } ans += ( cycle_size - 1 ) ; } return ans ; } static int minSwapToMakeArraySame ( int [ ] a , int [ ] b , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . Add ( b [ i ] , i ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = mp [ a [ i ] ] ; } return minSwapsToSort ( b , n ) ; } static public void Main ( ) { int [ ] a = { 3 , 6 , 4 , 8 } ; int [ ] b = { 4 , 6 , 8 , 3 } ; int n = a . Length ; Console . WriteLine ( minSwapToMakeArraySame ( a , b , n ) ) ; } }"}
{"text": "K | C # Program untuk memeriksa walaupun atau ganjil; Berfungsi untuk mencari elemen k - th yang hilang; interating melalui array; Semak jika saya - th dan (i + 1) - elemen tidak berturut -turut; Simpan perbezaan mereka; Semak perbezaan dan diberikan k; jika dijumpai; Kod pemacu; Arahan input; K - elemen yang hilang dapat dijumpai dalam array; fungsi panggilan untuk mencari elemen yang hilang", "code": "using System ; using System . Collections . Generic ; class GFG { static int missingK ( int [ ] a , int k , int n ) { int difference = 0 , ans = 0 , count = k ; bool flag = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return - 1 ; } public static void Main ( ) { int [ ] a = { 1 , 5 , 11 , 19 } ; int k = 11 ; int n = a . Length ; int missing = missingK ( a , k , n ) ; Console . Write ( missing ) ; } }"}
{"text": "K | C # Program untuk pendekatan di atas; Berfungsi untuk mencari nombor kth yang hilang; Sekiranya jumlah jumlah nombor yang hilang adalah sama dengan k kita boleh melangkah ke belakang untuk nombor yang hilang pertama dan itu akan menjadi jawapannya. ; Untuk mengoptimumkan lagi, kita periksa sama ada elemen sebelumnya yang hilang. Eg: 4,5,6,7,8] u u u obs obs u u u u u u u u u u. »~ Carian ~ tetingkap» dan u (LOGN) ~ masa Kompleksiti ~ f f f fely 'akan' telah o (n). ; Lain kita kembali arr [pertengahan] - 1 .; Di sini kita menyempitkan tetingkap carian dengan sewajarnya. ; Sekiranya had atas adalah - ia bermakna set nombor yang hilang ialah 1, 2 ,. . , k dan oleh itu kita terus kembali k. ; Lain kita dapati jumlah sisa nombor yang kita 'd kemudian tambahkan ke arr [u] dan dapatkan nombor kth yang hilang. ; Kembali arr [u] + k; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int missingK ( int [ ] arr , int k ) { int n = arr . Length ; int l = 0 , u = n - 1 , mid ; while ( l <= u ) { mid = ( l + u ) / 2 ; int numbers_less_than_mid = arr [ mid ] - ( mid + 1 ) ; if ( numbers_less_than_mid == k ) { if ( mid > 0 && ( arr [ mid - 1 ] - ( mid ) ) == k ) { u = mid - 1 ; continue ; } return arr [ mid ] - 1 ; } if ( numbers_less_than_mid < k ) { l = mid + 1 ; } else if ( k < numbers_less_than_mid ) { u = mid - 1 ; } } if ( u < 0 ) return k ; int less = arr [ u ] - ( u + 1 ) ; k -= less ; return arr [ u ] + k ; } static void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 7 , 11 } ; int k = 5 ; Console . WriteLine ( \" Missing ▁ kth ▁ number ▁ = ▁ \" + missingK ( arr , k ) ) ; } }"}
{"text": "Alternatif ganjil dan juga nod dalam senarai yang berkaitan dengan tunggal | C # Program untuk menyusun semula nod sebagai alternatif ganjil walaupun nod dalam senarai yang dikaitkan secara tunggal; nod kelas; Fungsi utiliti untuk mencetak senarai yang dipautkan; Berfungsi untuk membuat newnode dalam senarai LinkedL; Berfungsi untuk memasukkan pada permulaan; Berfungsi untuk menyusun semula nod yang ganjil dan bahkan; Nilai ganjil dalam kedudukan walaupun menunjuk penunjuk ke nod semasa dalam timbunan ganjil; Malah nilai dalam kedudukan ganjil menambah penunjuk ke nod semasa dalam timbunan walaupun; Swap data di bahagian atas dua susunan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public class Node { public int data ; public Node next ; } static void printList ( Node node ) { while ( node != null ) { Console . Write ( node . data + \" ▁ \" ) ; node = node . next ; } Console . WriteLine ( ) ; } static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } static Node insertBeg ( Node head , int val ) { Node temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; } static void rearrangeOddEven ( Node head ) { Stack < Node > odd = new Stack < Node > ( ) ; Stack < Node > even = new Stack < Node > ( ) ; int i = 1 ; while ( head != null ) { if ( head . data % 2 != 0 && i % 2 == 0 ) { odd . Push ( head ) ; } else if ( head . data % 2 == 0 && i % 2 != 0 ) { even . Push ( head ) ; } head = head . next ; i ++ ; } while ( odd . Count > 0 && even . Count > 0 ) { int k = odd . Peek ( ) . data ; odd . Peek ( ) . data = even . Peek ( ) . data ; even . Peek ( ) . data = k ; odd . Pop ( ) ; even . Pop ( ) ; } } public static void Main ( String [ ] args ) { Node head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 1 ) ; Console . WriteLine ( \" Linked ▁ List : \" ) ; printList ( head ) ; rearrangeOddEven ( head ) ; Console . WriteLine ( \" Linked ▁ List ▁ after ▁ \" + \" Rearranging : \" ) ; printList ( head ) ; } }"}
{"text": "Alternatif ganjil dan juga nod dalam senarai yang berkaitan dengan tunggal | C # Program untuk menyusun semula nod sebagai alternatif ganjil walaupun nod dalam senarai yang dikaitkan secara tunggal; Struktur nod; Fungsi utiliti untuk mencetak senarai yang dipautkan; Berfungsi untuk membuat newnode dalam senarai LinkedL; Berfungsi untuk memasukkan pada permulaan; Berfungsi untuk menyusun semula nod yang ganjil dan bahkan; Langkah 1: Mengasingkan Node Even dan Odd Langkah 2: Split Odd dan juga menyenaraikan Langkah 3: Gabungkan senarai bahkan ke dalam senarai ganjil; Langkah 1: Mengasingkan ganjil dan juga nod; Sandaran penunjuk seterusnya temp; Jika temp adalah ganjil bergerak nod ke permulaan senarai; Pointer Temp Advance; Langkah 2 memecah senarai ke dalam ganjil dan bahkan; Tamatkan senarai ganjil (buat nod terakhir null); Langkah 3: Gabungkan bahkan senarai ke dalam ganjil; Walaupun kedua -dua senarai itu tidak habis sandaran sandaran seterusnya I dan J; PTR menunjuk kepada nod terkini yang ditambah; Advance I dan J Pointers; Senarai ganjil ekzos sebelum walaupun, tambahkan selebihnya senarai yang ganjil. ; Kes di mana senarai ekzos sebelum senarai ganjil ditangani secara automatik kerana kami menggabungkan senarai bahkan ke dalam senarai ganjil; Kod pemacu", "code": "using System ; class GFG { public class Node { public int data ; public Node next ; } ; static void printList ( Node node ) { while ( node != null ) { Console . Write ( node . data + \" ▁ \" ) ; node = node . next ; } Console . WriteLine ( ) ; } static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } static Node insertBeg ( Node head , int val ) { Node temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; } static Node rearrange ( Node head ) { Node even ; Node temp , prev_temp ; Node i , j , k , l , ptr = null ; temp = ( head ) . next ; prev_temp = head ; while ( temp != null ) { Node x = temp . next ; if ( temp . data % 2 != 0 ) { prev_temp . next = x ; temp . next = ( head ) ; ( head ) = temp ; } else { prev_temp = temp ; } temp = x ; } temp = ( head ) . next ; prev_temp = ( head ) ; while ( temp != null && temp . data % 2 != 0 ) { prev_temp = temp ; temp = temp . next ; } even = temp ; prev_temp . next = null ; i = head ; j = even ; while ( j != null && i != null ) { k = i . next ; l = j . next ; i . next = j ; j . next = k ; ptr = j ; i = k ; j = l ; } if ( i == null ) { ptr . next = j ; } return head ; } public static void Main ( String [ ] args ) { Node head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 1 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 10 ) ; Console . WriteLine ( \" Linked ▁ List : \" ) ; printList ( head ) ; Console . WriteLine ( \" Rearranged ▁ List \" ) ; head = rearrange ( head ) ; printList ( head ) ; } }"}
{"text": "Putar semua elemen matriks kecuali kali pepenjuru k dengan 90 darjah dalam arah arah jam | C # Program untuk pendekatan di atas; Berfungsi untuk mencetak matriks; Melangkah ke atas baris; Melangkah ke atas lajur; Cetak nilai; Berfungsi untuk melaksanakan pertukaran unsur matriks dengan cara mengikut arah jam; Menyimpan baris terakhir; Menyimpan lajur terakhir; Melakukan swap; Berfungsi untuk memutar unsur -unsur pepenjuru bukan matriks k dalam arah arah jam; Kemas kini K ke K % 4; Melangkah sehingga k positif; Melepasi setiap baris n / 2 - th; Melepasi setiap lajur dari i ke n - i - 1; Semak sama ada elemen di i, j bukan elemen pepenjuru; Melakukan pertukaran; Cetak matriks; Kod pemacu", "code": "using System ; public class GFG { static void print ( int [ , ] mat ) { for ( int i = 0 ; i < mat . GetLength ( 0 ) ; i ++ ) { for ( int j = 0 ; j < mat . GetLength ( 1 ) ; j ++ ) Console . Write ( mat [ i , j ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } } static void performSwap ( int [ , ] mat , int i , int j ) { int N = mat . GetLength ( 0 ) ; int ei = N - 1 - i ; int ej = N - 1 - j ; int temp = mat [ i , j ] ; mat [ i , j ] = mat [ ej , i ] ; mat [ ej , i ] = mat [ ei , ej ] ; mat [ ei , ej ] = mat [ j , ei ] ; mat [ j , ei ] = temp ; } static void rotate ( int [ , ] mat , int N , int K ) { K = K % 4 ; while ( K -- > 0 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { for ( int j = i ; j < N - i - 1 ; j ++ ) { if ( i != j && ( i + j ) != N - 1 ) { performSwap ( mat , i , j ) ; } } } } print ( mat ) ; } public static void Main ( string [ ] args ) { int K = 5 ; int [ , ] mat = { { 1 , 2 , 3 , 4 } , { 6 , 7 , 8 , 9 } , { 11 , 12 , 13 , 14 } , { 16 , 17 , 18 , 19 } , } ; int N = mat . GetLength ( 0 ) ; rotate ( mat , N , K ) ; } }"}
{"text": "Putaran minimum diperlukan untuk mendapatkan rentetan yang sama | C # Program untuk menentukan bilangan putaran minimum yang diperlukan untuk menghasilkan rentetan yang sama. ; Mengembalikan kiraan putaran untuk mendapatkan kembali rentetan yang sama. ; TMP adalah rentetan yang disatukan. ; Substring dari I Indeks saiz rentetan asal. ; Jika substring sepadan dengan rentetan asal maka kami akan keluar dari gelung. ; Kaedah Pemandu", "code": "using System ; class GFG { static int findRotations ( String str ) { String tmp = str + str ; int n = str . Length ; for ( int i = 1 ; i <= n ; i ++ ) { String substring = tmp . Substring ( i , str . Length ) ; if ( str == substring ) return i ; } return n ; } public static void Main ( ) { String str = \" abc \" ; Console . Write ( findRotations ( str ) ) ; } }"}
{"text": "Count of Elements yang Kuasa 2 dalam Subarray Julat tertentu untuk QQueries | C # pelaksanaan untuk mencari unsur -unsur yang merupakan kuasa dua; Awalan [i] akan menyimpan bilangan elemen yang merupakan kuasa dua hingga i (termasuk i). ; Berfungsi untuk mencari julat maksimum yang jumlahnya boleh dibahagikan dengan m. ; Kirakan jumlah awalan; Berfungsi untuk mengembalikan bilangan elemen yang merupakan kuasa dua dalam subarray; Kod pemacu", "code": "using System ; class GFG { static int MAX = 10000 ; static int [ ] prefix = new int [ MAX + 1 ] ; static bool isPowerOfTwo ( int x ) { if ( x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ) return true ; return false ; } static void computePrefix ( int n , int [ ] a ) { if ( isPowerOfTwo ( a [ 0 ] ) ) prefix [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] ; if ( isPowerOfTwo ( a [ i ] ) ) prefix [ i ] ++ ; } } static int query ( int L , int R ) { if ( L == 0 ) return prefix [ R ] ; return prefix [ R ] - prefix [ L - 1 ] ; } public static void Main ( ) { int [ ] A = { 3 , 8 , 5 , 2 , 5 , 10 } ; int N = A . Length ; computePrefix ( N , A ) ; Console . WriteLine ( query ( 0 , 4 ) ) ; Console . WriteLine ( query ( 3 , 5 ) ) ; } }"}
{"text": "Count of Integral Coordinates yang terletak di dalam persegi | C # Program untuk pendekatan di atas; Berfungsi untuk mengira titik integral di dalam persegi; Kod pemacu", "code": "using System ; class GFG { static void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { Console . WriteLine ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; } static void Main ( ) { int x1 = 1 , y1 = 1 ; int x2 = 4 , y2 = 4 ; countIntgralPoints ( x1 , y1 , x2 , y2 ) ; } }"}
{"text": "Cari nombor seterusnya yang mempunyai digit yang berbeza dari nombor N | C # Pelaksanaan untuk mencari nombor digit yang berbeza; Berfungsi untuk mencari nombor digit yang berbeza; Gelung untuk mencari digit yang berbeza menggunakan array hash dan bilangan digit; Gelung untuk mencari digit yang paling ketara dari nombor seterusnya; Keadaan untuk memeriksa sama ada nombor itu mungkin dengan bilangan angka yang sama; Keadaan untuk memeriksa sama ada digit yang paling significant yang dikehendaki dijumpai; Gelung untuk mencari digit seterusnya minimum yang tidak hadir dalam nombor; Pengiraan nombor; Syarat untuk memeriksa sama ada nombor itu lebih besar daripada nombor yang diberikan; Kod pemacu", "code": "using System ; class GFG { static void findNextNumber ( int n ) { int [ ] h = new int [ 10 ] ; int i = 0 , msb = n , rem = 0 ; int next_num = - 1 , count = 0 ; while ( msb > 9 ) { rem = msb % 10 ; h [ rem ] = 1 ; msb /= 10 ; count ++ ; } h [ msb ] = 1 ; count ++ ; for ( i = msb + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; break ; } } if ( next_num == - 1 ) { for ( i = 1 ; i < msb ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; count ++ ; break ; } } } if ( next_num > 0 ) { for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { msb = i ; break ; } } for ( i = 1 ; i < count ; i ++ ) { next_num = ( ( next_num * 10 ) + msb ) ; } if ( next_num > n ) Console . WriteLine ( next_num ) ; else Console . WriteLine ( \" Not ▁ Possible \" ) ; } else { Console . WriteLine ( \" Not ▁ Possible \" ) ; } } public static void Main ( string [ ] args ) { int n = 2019 ; findNextNumber ( n ) ; } }"}
{"text": "Cari triplet (a, b, c) supaya 3 * a + 5 * b + 7 * c sama dengan n | C # Program untuk pendekatan di atas; Berfungsi untuk mencari triplet (a, b, c) supaya 3 * a + 5 * b + 7 * c ialah n; Melangkah ke atas julat [0, N7]; Melangkah ke atas julat [0, N5]; Cari nilai a; Jika A lebih besar daripada atau sama dengan 0 dan dibahagikan dengan 3; Jika tidak, cetak - 1; Kod pemacu", "code": "using System ; class GFG { static void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { Console . Write ( \" A ▁ = ▁ \" + A / 3 + \" , ▁ B ▁ = ▁ \" + B + \" , ▁ C ▁ = ▁ \" + C ) ; return ; } } } Console . WriteLine ( - 1 ) ; } static public void Main ( ) { int N = 19 ; CalculateValues ( 19 ) ; } }"}
{"text": "Kurangkan jumlah masa yang diambil oleh dua orang untuk melawat bandar -bandar sehingga tidak ada yang bertemu | C # Program untuk pendekatan di atas; Berfungsi untuk mencari masa minimum untuk melawat semua bandar sehingga kedua -dua orang tidak pernah bertemu; Memulakan jumlah sebagai 0; Cari elemen maksimum; Melintasi array; Jumlah kenaikan oleh arr [i]; Cetak maksimum 2 * t dan jumlah; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Linq ; class GFG { static void minimumTime ( int [ ] arr , int n ) { int sum = 0 ; int T = arr . Min ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } Console . WriteLine ( Math . Max ( 2 * T , sum ) ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 8 , 3 } ; int N = arr . Length ; minimumTime ( arr , N ) ; } }"}
{"text": "Rentetan lexicographically terbesar mungkin dengan membalikkan substring yang mempunyai bilangan 1 s | C # Program untuk pendekatan di atas; Berfungsi untuk mencari rentetan maksimum lexicographically dengan membalikkan substrings yang mempunyai bilangan 1 s; Saiz saiz rentetan; Melintasi rentetan; Kira bilangan 1 s; Menyimpan indeks permulaan; Menyimpan indeks akhir; Kiraan kenaikan, apabila 1 ditemui; Melintasi rentetan yang tinggal; Membalikkan rentetan dari indeks permulaan dan akhir; Mencetak rentetan; Kod pemacu", "code": "using System ; using System . Text ; class GFG { static void lexicographicallyMax ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; int beg = i ; int end = i ; if ( s [ i ] == '1' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] == '1' ) count ++ ; if ( count % 2 == 0 && count != 0 ) { end = j ; break ; } } s = reverse ( s , beg , end + 1 ) ; } Console . WriteLine ( s ) ; } static String reverse ( String s , int beg , int end ) { StringBuilder x = new StringBuilder ( \" \" ) ; for ( int i = 0 ; i < beg ; i ++ ) x . Append ( s [ i ] ) ; for ( int i = end - 1 ; i >= beg ; i -- ) x . Append ( s [ i ] ) ; for ( int i = end ; i < s . Length ; i ++ ) x . Append ( s [ i ] ) ; return x . ToString ( ) ; } public static void Main ( String [ ] args ) { String S = \"0101\" ; lexicographicallyMax ( S ) ; } }"}
{"text": "Kira pasangan maksimum yang mungkin dari array yang mempunyai jumlah k | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan maksimum pasangan dari array yang diberikan dengan jumlah k; Susun array dalam urutan yang semakin meningkat; Menyimpan hasil akhir; Memulakan penunjuk kiri dan kanan; TRAVERSE ARRAY Sehingga mula <end; Pengurangan hak oleh 1; Kenaikan ditinggalkan oleh 1; Hasil kenaikan dan penunjuk kiri oleh 1 dan penunjuk kanan penurunan dengan 1; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { public static void maxPairs ( int [ ] nums , int k ) { Array . Sort ( nums ) ; int result = 0 ; int start = 0 , end = nums . Length - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } Console . Write ( result ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int K = 5 ; maxPairs ( arr , K ) ; } }"}
{"text": "Kira pasangan maksimum yang mungkin dari array yang mempunyai jumlah k | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan maksimum pasangan dengan jumlah k sedemikian rupa sehingga elemen yang sama tidak dapat digunakan dua kali; Memulakan hashmap; Simpan hasil yang dibaca; Melangkah ke atas array nums []; Menurunkan kekerapannya dalam peta dan kenaikan hasilnya dengan 1; Meningkatkan kekerapannya dengan 1 jika sudah ada dalam peta. Jika tidak, tetapkan kekerapannya kepada 1; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { public static void maxPairs ( int [ ] nums , int k ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int result = 0 ; foreach ( int i in nums ) { if ( map . ContainsKey ( i ) && map [ i ] > 0 ) { map [ i ] = map [ i ] - 1 ; result ++ ; } else { if ( ! map . ContainsKey ( k - i ) ) map . Add ( k - i , 1 ) ; else map [ i ] = map [ i ] + 1 ; } } Console . WriteLine ( result ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int K = 5 ; maxPairs ( arr , K ) ; } }"}
{"text": "Indeks cetak elemen array yang penyingkirannya menjadikan jumlah ganjil dan bahkan | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mencari indeks unsur -unsur array yang penyingkirannya menjadikan jumlah elemen array yang ganjil dan juga diindeks sama; Kedai saiz array; Simpan awalan jumlah elemen array indeks ganjil; Simpan awalan jumlah elemen array indeks walaupun; Kemas kini walaupun [0]; Melintasi array yang diberikan; Mengemas kini ganjil [i]; Kemas kini walaupun [i]; Jika indeks semasa adalah nombor yang sama; Kemas kini walaupun [i]; Jika indeks semasa adalah nombor ganjil; Mengemas kini ganjil [i]; Semak sama ada sekurang -kurangnya satu indeks yang dijumpai atau tidak yang memenuhi syarat; Simpan indeks ganjil dengan mengeluarkan indeks 0 - TH; Simpan walaupun indeks jumlah dengan mengeluarkan indeks 0 - Th; Jika p dan q sama; Melintasi array arr []; Jika saya adalah nombor yang sama; Kemas kini P dengan mengeluarkan elemen i - th; Kemas kini Q dengan mengeluarkan elemen I - th; Kemas kini Q dengan mengeluarkan elemen I - th; Kemas kini P dengan mengeluarkan elemen i - th; Jika nilai indeks ganjil jumlah sama dengan nilai indeks walaupun jumlah; Tetapkan pemboleh ubah mencari; Cetak indeks semasa; Jika tidak ada indeks yang dijumpai; Cetak tidak mungkin; Kod pemacu", "code": "using System ; class GFG { static void removeIndicesToMakeSumEqual ( int [ ] arr ) { int N = arr . Length ; int [ ] odd = new int [ N ] ; int [ ] even = new int [ N ] ; even [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { odd [ i ] = odd [ i - 1 ] ; even [ i ] = even [ i - 1 ] ; if ( i % 2 == 0 ) { even [ i ] += arr [ i ] ; } else { odd [ i ] += arr [ i ] ; } } bool find = false ; int p = odd [ N - 1 ] ; int q = even [ N - 1 ] - arr [ 0 ] ; if ( p == q ) { Console . Write ( \"0 ▁ \" ) ; find = true ; } for ( int i = 1 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else { q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; } if ( p == q ) { find = true ; Console . Write ( i + \" ▁ \" ) ; } } if ( ! find ) { Console . Write ( - 1 ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 1 , 6 , 2 } ; removeIndicesToMakeSumEqual ( arr ) ; } }"}
{"text": "Penyingkiran minimum diperlukan untuk membuat bitonic array yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk coutnt elemen array minimum yang diperlukan untuk dikeluarkan untuk membuat bitonic array; Kiri [i]: menyimpan panjang lis sehingga indeks i - th; kanan [i]: menyimpan panjang penurunan seterusnya ke atas julat [i, n]; Kirakan panjang LIS sehingga indeks i - th; Melintasi array sehingga indeks i - th; Jika arr [j] kurang daripada arr [i]; Kemas kini kiri [i]; Kirakan panjang penurunan seterusnya ke atas julat [i, n]; Melintasi kanan [] array; Jika arr [i] lebih besar daripada arr [j]; Kemas kini betul [i]; Kedai panjang array bitonic terpanjang; Traverse kiri [] dan kanan [] array; Kemas kini Maxlen; Fungsi untuk mencetak penyingkiran minimum yang diperlukan untuk membuat bitonic array yang diberikan; Kod pemacu", "code": "using System ; class GFG { static void min_element_removal ( int [ ] arr , int N ) { int [ ] left = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) left [ i ] = 1 ; int [ ] right = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) right [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { left [ i ] = Math . Max ( left [ i ] , left [ j ] + 1 ) ; } } } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j > i ; j -- ) { if ( arr [ i ] > arr [ j ] ) { right [ i ] = Math . Max ( right [ i ] , right [ j ] + 1 ) ; } } } int maxLen = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { maxLen = Math . Max ( maxLen , left [ i ] + right [ i ] - 1 ) ; } Console . WriteLine ( N - maxLen ) ; } static void makeBitonic ( int [ ] arr , int N ) { if ( N == 1 ) { Console . WriteLine ( \"0\" ) ; return ; } if ( N == 2 ) { if ( arr [ 0 ] != arr [ 1 ] ) Console . WriteLine ( \"0\" ) ; else Console . WriteLine ( \"1\" ) ; return ; } min_element_removal ( arr , N ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 1 , 5 , 6 , 2 , 3 , 1 } ; int N = arr . Length ; makeBitonic ( arr , N ) ; } }"}
{"text": "Count Subarrays mempunyai kiraan yang sama dengan 0 dan 1 S berasal | C # Program untuk pendekatan di atas; Fungsi untuk mengira subarray yang mempunyai kiraan yang sama dengan 0 s dan 1 s dengan semua 0 s dan semua 1 dikelompokkan bersama; Menyimpan kiraan subarray; Jika elemen semasa berbeza daripada elemen array seterusnya; Kiraan kenaikan; Hitung kekerapan 1 s dan 0 s; Kiraan kenaikan; Cetak kiraan akhir; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void countSubarrays ( int [ ] A , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } Console . Write ( ans + \" STRNEWLINE \" ) ; } public static void Main ( ) { int [ ] A = { 1 , 1 , 0 , 0 , 1 , 0 } ; int N = A . Length ; countSubarrays ( A , N ) ; } }"}
{"text": "Kiraan quadruples jenis yang diberikan dari array yang diberikan | C # Program pendekatan di atas; lcount [i, j]: menyimpan kiraan saya di sebelah kiri indeks j; rcount [i, j]: menyimpan kiraan saya di kanan indeks j; Berfungsi untuk mengira unsur -unsur unik di kiri dan kanan mana -mana indeks; Cari elemen array maksimum; Kirakan jumlah awalan jumlah setiap nilai; Kirakan jumlah akhiran jumlah setiap nilai; Berfungsi untuk mengira kuadruples jenis yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int maxN = 2002 ; static int [ , ] lcount = new int [ maxN , maxN ] ; static int [ , ] rcount = new int [ maxN , maxN ] ; static void fill_counts ( int [ ] a , int n ) { int i , j ; int maxA = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxA ) { maxA = a [ i ] ; } } for ( i = 0 ; i < n ; i ++ ) { lcount [ a [ i ] , i ] = 1 ; rcount [ a [ i ] , i ] = 1 ; } for ( i = 0 ; i <= maxA ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) { lcount [ i , j ] = lcount [ i , j - 1 ] + lcount [ i , j ] ; } for ( j = n - 2 ; j >= 0 ; j -- ) { rcount [ i , j ] = rcount [ i , j + 1 ] + rcount [ i , j ] ; } } } static int countSubsequence ( int [ ] a , int n ) { int i , j ; fill_counts ( a , n ) ; int answer = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n - 1 ; j ++ ) { answer += lcount [ a [ j ] , i - 1 ] * rcount [ a [ i ] , j + 1 ] ; } } return answer ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; Console . Write ( countSubsequence ( a , a . Length ) ) ; } }"}
{"text": "Kurangkan rentetan dengan mengeluarkan kurungan paling luar dari setiap substring primitif | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk menghapuskan tanda kurung paling luar setiap substring primitif dari rentetan yang diberikan; Menyimpan rentetan yang dihasilkan; Menyimpan kiraan tanda kurung yang dibuka; Melintasi rentetan; Jika pembukaan kurungan ditemui dan kiraan mereka melebihi 0; Termasuk watak; Jika penutupan kurungan ditemui dan kiraannya kurang daripada mengira tanda kurung pembukaan; Termasuk watak; Kembali rentetan yang dihasilkan; Kod pemacu", "code": "using System ; class GFG { static string removeOuterParentheses ( string S ) { string res = \" \" ; int count = 0 ; for ( int c = 0 ; c < S . Length ; c ++ ) { if ( S == ' ( ' && count ++ > 0 ) res += S ; if ( S == ' ) ' && count -- > 1 ) res += S ; } return res ; } public static void Main ( ) { string S = \" ( ( ) ( ) ) ( ( ) ) ( ) \" ; Console . Write ( removeOuterParentheses ( S ) ) ; } }"}
{"text": "Panjang subarray terpanjang dengan peningkatan unsur -unsur bersebelahan | C # pelaksanaan untuk pendekatan di atas; Berfungsi untuk mencari subarray terpanjang dengan unsur -unsur bersebelahan yang semakin meningkat; Menyimpan panjang subarray terpanjang yang diperlukan; Menyimpan panjang panjang subarray yang paling lama dari indeks ith; Jika unsur -unsur berturut -turut semakin meningkat dan berbeza dengan 1; Jika tidak; Kemas kini subarray terpanjang yang diperoleh setakat ini; Mengembalikan panjang yang diperoleh; Kod pemacu", "code": "using System ; class GFG { public static int maxiConsecutiveSubarray ( int [ ] arr , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = Math . Max ( maxi , cnt ) ; i = j ; } return maxi ; } public static void Main ( String [ ] args ) { int N = 11 ; int [ ] arr = { 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 } ; Console . WriteLine ( maxiConsecutiveSubarray ( arr , N ) ) ; } }"}
{"text": "Panjang seterusnya terpanjang yang mempunyai jumlah digit setiap elemen sebagai nombor komposit | C # pelaksanaan pendekatan di atas; Berfungsi untuk menjana nombor perdana menggunakan ayak eratosthenes; Tetapkan 0 dan 1 sebagai bukan perdana; Jika p adalah perdana; Tetapkan semua gandaan p sebagai bukan perdana; Berfungsi untuk mencari jumlah digit nombor tertentu; Menyimpan jumlah digit; Ekstrak digit dan tambah kepada jumlah; Kembalikan jumlah digit; Berfungsi untuk mencari berikutnya yang paling lama dengan jumlah digit setiap elemen bersamaan dengan nombor komposit; Hitung jumlah digit elemen array semasa; Jika jumlah digit sama dengan 1; Jika jumlah digit adalah perdana; Kod pemacu; Panggilan fungsi", "code": "using System . Collections . Generic ; using System ; class GFG { static int N = 100005 ; static void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } static int digitSum ( int number ) { int sum = 0 ; while ( number > 0 ) { sum += ( number % 10 ) ; number /= 10 ; } return sum ; } static void longestCompositeDigitSumSubsequence ( int [ ] arr , int n ) { int count = 0 ; bool [ ] prime = new bool [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { int res = digitSum ( arr [ i ] ) ; if ( res == 1 ) { continue ; } if ( prime [ res ] == false ) { count ++ ; } } Console . WriteLine ( count ) ; } public static void Main ( ) { int [ ] arr = { 13 , 55 , 7 , 3 , 5 , 1 , 10 , 21 , 233 , 144 , 89 } ; int n = arr . Length ; longestCompositeDigitSumSubsequence ( arr , n ) ; } }"}
{"text": "Jumlah nod yang seimbang dari pokok binari yang diberikan | C # Program untuk pendekatan di atas; Struktur pokok binari; Berfungsi untuk membuat nod baru; Mengembalikan nod yang dibuat; Berfungsi untuk memasukkan nod di dalam pokok; Penyisipan kiri; Penyisipan kanan; Mengembalikan nod akar; Berfungsi untuk mencari jumlah node yang seimbang di dalam pokok; Kes asas; Cari jumlah subtree kiri; Cari jumlah yang betul; Keadaan node yang seimbang; Keadaan node yang seimbang; Mengembalikan jumlahnya; Berfungsi untuk membina pokok binari; Bentuk nod akar pokok; Masukkan nod ke dalam pokok; Buat nod baru; Masukkan nod; Kembalikan akar pokok; Berfungsi untuk mencari jumlah node yang seimbang; Membina pokok; Menyimpan jumlah node yang seimbang; Panggilan fungsi; Cetak jumlah yang diperlukan; Kod pemacu; Diberikan nod; Diberikan akar; Diberikan maklumat laluan nod dari akar; Diberikan nilai nod; Panggilan fungsi", "code": "using System ; class GFG { static int sum ; class Node { public int data ; public Node left , right ; } ; static Node newnode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = null ; temp . right = null ; return temp ; } static Node insert ( String s , int i , int N , Node root , Node temp ) { if ( i == N ) return temp ; if ( s [ i ] == ' L ' ) root . left = insert ( s , i + 1 , N , root . left , temp ) ; else root . right = insert ( s , i + 1 , N , root . right , temp ) ; return root ; } static int SBTUtil ( Node root ) { if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return root . data ; int left = SBTUtil ( root . left ) ; int right = SBTUtil ( root . right ) ; if ( root . left != null && root . right != null ) { if ( ( left % 2 == 0 && right % 2 != 0 ) || ( left % 2 != 0 && right % 2 == 0 ) ) { sum += root . data ; } } return left + right + root . data ; } static Node build_tree ( int R , int N , String [ ] str , int [ ] values ) { Node root = newnode ( R ) ; int i ; for ( i = 0 ; i < N - 1 ; i ++ ) { String s = str [ i ] ; int x = values [ i ] ; Node temp = newnode ( x ) ; root = insert ( s , 0 , s . Length , root , temp ) ; } return root ; } static void speciallyBalancedNodes ( int R , int N , String [ ] str , int [ ] values ) { Node root = build_tree ( R , N , str , values ) ; sum = 0 ; SBTUtil ( root ) ; Console . Write ( sum + \" ▁ \" ) ; } public static void Main ( String [ ] args ) { int N = 7 ; int R = 12 ; String [ ] str = { \" L \" , \" R \" , \" RL \" , \" RR \" , \" RLL \" , \" RLR \" } ; int [ ] values = { 17 , 16 , 4 , 9 , 2 , 3 } ; speciallyBalancedNodes ( R , N , str , values ) ; } }"}
{"text": "Pasangan yang mempunyai semua pasangan lain yang terletak di antara minimum dan maksimumnya | C # Program untuk pendekatan di atas; Fungsi untuk mencari kedudukan pasangan yang meliputi setiap pasangan dalam array arr [] []; Menyimpan indeks pasangan yang dihasilkan; Untuk mengira kejadian; Berulang untuk memeriksa setiap pasangan; Tetapkan kiraan ke 0; Keadaan untuk diperiksa untuk bertindih pasangan; Jika pasangan itu dapat menutup semua pasangan lain maka simpan kedudukannya; Jika kedudukan tidak dijumpai; Jika tidak; Kod pemacu; Memberi pelbagai pasangan; Panggilan fungsi", "code": "using System ; class GFG { static void position ( int [ , ] arr , int N ) { int pos = - 1 ; int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i , 0 ] <= arr [ j , 0 ] && arr [ i , 1 ] >= arr [ j , 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == - 1 ) { Console . Write ( pos ) ; } else { Console . Write ( pos + 1 ) ; } } public static void Main ( ) { int [ , ] arr = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = arr . GetLength ( 0 ) ; position ( arr , N ) ; } }"}
{"text": "Pasangan yang mempunyai semua pasangan lain yang terletak di antara minimum dan maksimumnya | C # Program untuk pendekatan di atas; Fungsi untuk mencari kedudukan pasangan yang meliputi setiap pasangan dalam array [,] arr; Kedudukan untuk menyimpan indeks; Menyimpan nilai kedua maksimum; Menyimpan nilai pertama minimum; Melangkah ke atas pelbagai pasangan; Kemas kini maksimum yang betul; Kemas kini minimum kiri; Melangkah ke atas pelbagai pasangan; Jika ada pasangan yang ada dengan nilai {kiri, kanan} kemudian simpannya; Cetak jawapannya; Kod pemacu; Diberikan pelbagai pasangan; Panggilan fungsi", "code": "using System ; class GFG { static void position ( int [ , ] arr , int N ) { int pos = - 1 ; int right = int . MinValue ; int left = int . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i , 1 ] > right ) { right = arr [ i , 1 ] ; } if ( arr [ i , 0 ] < left ) { left = arr [ i , 0 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i , 0 ] == left && arr [ i , 1 ] == right ) { pos = i + 1 ; } } Console . Write ( pos + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { int [ , ] arr = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = arr . GetLength ( 0 ) ; position ( arr , N ) ; } }"}
{"text": "Kurangkan kiraan operasi yang diberikan untuk membuat dua permutasi rentetan yang diberikan antara satu sama lain | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk meminimumkan kiraan operasi untuk membuat permutasi Str1 dan Str2 antara satu sama lain; Simpan kekerapan setiap watak Str1; Simpan kekerapan setiap watak Str2; Melintasi freq1 [] dan freq2 []; Jika kekerapan watak dalam str1 lebih besar daripada str2; Jika tidak; Simpan jumlah Freq1 []; Simpan jumlah freq2 []; Kod pemacu", "code": "using System ; class GFG { static int ctMinEdits ( string str1 , string str2 ) { int N1 = str1 . Length ; int N2 = str2 . Length ; int [ ] freq1 = new int [ 256 ] ; freq1 [ 0 ] = str1 [ 0 ] ; for ( int i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 [ i ] ] ++ ; } int [ ] freq2 = new int [ 256 ] ; freq2 [ 0 ] = str2 [ 0 ] ; for ( int i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 [ i ] ] ++ ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; } else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } } int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return Math . Max ( sum1 , sum2 ) ; } public static void Main ( ) { string str1 = \" geeksforgeeks \" ; string str2 = \" geeksforcoder \" ; Console . WriteLine ( ctMinEdits ( str1 , str2 ) ) ; } }"}
{"text": "Kiraan pasangan (i, j) dari arrays arr [] & brr [] sedemikian rupa sehingga arr [i] | C # Program untuk pendekatan di atas; Fungsi untuk mencari nombor minimum yang diperlukan untuk ditambah supaya jumlah digit tidak melebihi k; Menyimpan jumlah elemen pada setiap indeks yang sepadan; Cari jumlah setiap indeks kedua -dua array; Kedai kekerapan setiap elemen yang terdapat dalam peta Sumarr <int, int> freqcount; ; Memulakan bilangan pasangan; Tambah mungkin pasangan VAID; Pulangan bilangan pasangan; Kod pemacu; Diberikan array [] arr dan brr []; Saiz array yang diberikan; Fungsi panggilan", "code": "using System ; using System . Collections . Generic ; class GFG { static void CountPairs ( int [ ] a , int [ ] b , int n ) { int [ ] C = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; } Dictionary < int , int > freqCount = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! freqCount . ContainsKey ( C [ i ] ) ) freqCount . Add ( C [ i ] , 1 ) ; else freqCount [ C [ i ] ] = freqCount [ C [ i ] ] + 1 ; } int NoOfPairs = 0 ; foreach ( KeyValuePair < int , int > x in freqCount ) { int y = x . Value ; NoOfPairs = NoOfPairs + y * ( y - 1 ) / 2 ; } Console . WriteLine ( NoOfPairs ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 4 , 20 , 3 , 10 , 5 } ; int [ ] brr = { 9 , 6 , 1 , 7 , 11 , 6 } ; int N = arr . Length ; CountPairs ( arr , brr , N ) ; } }"}
{"text": "Perubahan dalam median array yang diberikan selepas memadam elemen yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari perubahan median selepas mengeluarkan elemen dari ARR2 []; Untuk menyimpan median; Jika n adalah ganjil; Jika n juga; Cari elemen semasa dalam ARR1; Padamkan elemen; Pengurangan n; Jika n adalah ganjil; Jika n juga; Cetak perbezaan median yang sepadan; Kod pemacu; Diberikan susunan; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void medianChange ( List < int > arr1 , List < int > arr2 ) { int N = arr1 . Count ; List < double > median = new List < double > ( ) ; if ( ( N & 1 ) != 0 ) { median . Add ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . Add ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } foreach ( int x in arr2 ) { int it = arr1 . IndexOf ( x ) ; arr1 . RemoveAt ( it ) ; N -- ; if ( ( N & 1 ) != 0 ) { median . Add ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . Add ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } } for ( int i = 0 ; i < median . Count - 1 ; i ++ ) { Console . Write ( median [ i + 1 ] - median [ i ] + \" ▁ \" ) ; } } static void Main ( ) { List < int > arr1 = new List < int > ( new int [ ] { 2 , 4 , 6 , 8 , 10 } ) ; List < int > arr2 = new List < int > ( new int [ ] { 4 , 6 } ) ; medianChange ( arr1 , arr2 ) ; } }"}
{"text": "NFA untuk menerima rentetan yang mempunyai atleast satu watak yang berlaku dalam pelbagai 3 | C # pelaksanaan pendekatan di atas; Pembolehubah NFA yang menjejaki keadaan semasa urus niaga. ; Pemeriksaan ini untuk input tidak sah. ; Fungsi untuk keadaan Q2; Peralihan Negeri 'A' mengambil ke Q4, dan 'B' dan 'C' kekal pada Q2; Fungsi untuk keadaan Q3; Peralihan Negeri 'A' mengambil ke Q3, dan 'B' dan 'C' kekal pada Q4; Fungsi untuk keadaan Q4; Peralihan Negeri 'A' mengambil ke Q2, dan 'B' dan 'C' kekal pada Q3; Fungsi untuk negeri Q5; Peralihan negeri 'B' mengambil ke Q6, dan 'A' dan 'C' kekal pada Q5; Fungsi untuk keadaan Q6; Peralihan Negeri 'B' mengambil Q7, dan 'A' dan 'C' kekal pada Q7; Fungsi untuk negeri Q7; Peralihan Negeri 'B' mengambil ke Q5, dan 'A' dan 'C' kekal pada Q7; Fungsi untuk negeri Q8; Peralihan Negeri 'C' mengambil Q9, dan 'A' dan 'B' kekal pada Q8; Fungsi untuk Negeri Q9; Peralihan Negeri 'C' mengambil ke Q10, dan 'A' dan 'B' kekal pada Q9; Fungsi untuk keadaan Q10; Peralihan Negeri 'C' mengambil ke Q8, dan 'A' dan 'B' kekal pada Q10; Berfungsi untuk memeriksa 3 a; Berfungsi untuk memeriksa 3 b; Berfungsi untuk memeriksa 3 c 's; Kod pemacu; Sekiranya mana -mana negeri adalah benar, iaitu, sama ada bilangan bilangan atau jumlah atau jumlahnya adalah pelbagai tiga, maka rentetan itu diterima", "code": "using System ; class GFG { static int nfa = 1 ; static int flag = 0 ; static void state1 ( char c ) { if ( c == ' a ' ) nfa = 2 ; else if ( c == ' b ' c == ' c ' ) nfa = 1 ; else flag = 1 ; } static void state2 ( char c ) { if ( c == ' a ' ) nfa = 3 ; else if ( c == ' b ' c == ' c ' ) nfa = 2 ; else flag = 1 ; } static void state3 ( char c ) { if ( c == ' a ' ) nfa = 1 ; else if ( c == ' b ' c == ' c ' ) nfa = 3 ; else flag = 1 ; } static void state4 ( char c ) { if ( c == ' b ' ) nfa = 5 ; else if ( c == ' a ' c == ' c ' ) nfa = 4 ; else flag = 1 ; } static void state5 ( char c ) { if ( c == ' b ' ) nfa = 6 ; else if ( c == ' a ' c == ' c ' ) nfa = 5 ; else flag = 1 ; } static void state6 ( char c ) { if ( c == ' b ' ) nfa = 4 ; else if ( c == ' a ' c == ' c ' ) nfa = 6 ; else flag = 1 ; } static void state7 ( char c ) { if ( c == ' c ' ) nfa = 8 ; else if ( c == ' b ' c == ' a ' ) nfa = 7 ; else flag = 1 ; } static void state8 ( char c ) { if ( c == ' c ' ) nfa = 9 ; else if ( c == ' b ' c == ' a ' ) nfa = 8 ; else flag = 1 ; } static void state9 ( char c ) { if ( c == ' c ' ) nfa = 7 ; else if ( c == ' b ' c == ' a ' ) nfa = 9 ; else flag = 1 ; } static bool checkA ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 1 ) state1 ( s [ i ] ) ; else if ( nfa == 2 ) state2 ( s [ i ] ) ; else if ( nfa == 3 ) state3 ( s [ i ] ) ; } if ( nfa == 1 ) { return true ; } else { nfa = 4 ; } return false ; } static bool checkB ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 4 ) state4 ( s [ i ] ) ; else if ( nfa == 5 ) state5 ( s [ i ] ) ; else if ( nfa == 6 ) state6 ( s [ i ] ) ; } if ( nfa == 4 ) { return true ; } else { nfa = 7 ; } return false ; } static bool checkC ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 7 ) state7 ( s [ i ] ) ; else if ( nfa == 8 ) state8 ( s [ i ] ) ; else if ( nfa == 9 ) state9 ( s [ i ] ) ; } if ( nfa == 7 ) { return true ; } return false ; } public static void Main ( String [ ] args ) { String s = \" bbbca \" ; int x = 5 ; if ( checkA ( s , x ) || checkB ( s , x ) || checkC ( s , x ) ) { Console . WriteLine ( \" ACCEPTED \" ) ; } else { if ( flag == 0 ) { Console . WriteLine ( \" NOT ▁ ACCEPTED \" ) ; } else { Console . WriteLine ( \" INPUT ▁ OUT ▁ OF ▁ DICTIONARY . \" ) ; } } } }"}
{"text": "Kiraan kedudukan sedemikian rupa sehingga semua elemen sebelum ia lebih besar | C # Program untuk mengira kedudukan sedemikian rupa sehingga semua elemen sebelum ia lebih besar; Fungsi untuk mengira kedudukan supaya semua elemen sebelum ia lebih besar; Count pada mulanya 1 untuk elemen pertama; Minimum awal; Melintasi array; Jika elemen semasa adalah minimum baru; Mengemas kini minimum; Kiraan kenaikan; Kod pemacu", "code": "using System ; class GFG { static int getPositionCount ( int [ ] a , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; } public static void Main ( ) { int [ ] a = { 5 , 4 , 6 , 1 , 3 , 1 } ; int n = a . Length ; Console . WriteLine ( getPositionCount ( a , n ) ) ; } }"}
{"text": "Panjang maksimum L sedemikian rupa sehingga jumlah semua subarray panjang L kurang daripada k | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan jumlah maksimum dalam subarray saiz k; k mesti lebih besar; Kirakan jumlah tetingkap pertama saiz k; Kirakan jumlah tingkap yang tersisa dengan mengeluarkan elemen pertama tetingkap sebelumnya dan menambah elemen terakhir tetingkap semasa. ; Berfungsi untuk mengembalikan panjang jumlah subarray semua subarray panjang ini kurang daripada atau sama dengan k; Carian binari dari L ke R kerana semua elemen array adalah positif supaya jumlah subarray maksimum meningkat secara monotonik; Semak sama ada jumlah subarray lebih besar daripada k atau tidak; Mengemas kini panjang maksimum; Kod pemacu", "code": "using System ; class GFG { static int maxSum ( int [ ] arr , int n , int k ) { if ( n < k ) { return - 1 ; } int res = 0 ; for ( int i = 0 ; i < k ; i ++ ) res += arr [ i ] ; int curr_sum = res ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; res = Math . Max ( res , curr_sum ) ; } return res ; } static int solve ( int [ ] arr , int n , int k ) { int max_len = 0 , l = 0 , r = n , m ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( maxSum ( arr , n , m ) > k ) r = m - 1 ; else { l = m + 1 ; max_len = m ; } } return max_len ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . Length ; int k = 10 ; Console . WriteLine ( solve ( arr , n , k ) ) ; } }"}
{"text": "Count of triplets dalam array yang memenuhi syarat -syarat yang diberikan | C # pelaksanaan pendekatan; Semua penyelesaian yang mungkin dalam persamaan 1 / a + 1 / b + 1 / c = 1; Berfungsi untuk mencari tiga kali ganda; Menyimpan indeks unsur -unsur; Semak jika Y boleh bertindak sebagai elemen tengah triplet dengan penyelesaian yang diberikan 1 / a + 1 / b + 1 / c = 1; Carian binari untuk mencari bilangan nilai yang mungkin bagi elemen pertama; Carian binari untuk mencari bilangan nilai yang mungkin bagi elemen ketiga; Sumbangan kepada jawapannya ialah pendaraban nilai yang mungkin untuk elemen pertama dan ketiga; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int MAX = 100001 ; static int ROW = 10 ; static int COl = 3 ; static List < int > [ ] indices = new List < int > [ MAX ] ; static int [ , ] test = { { 2 , 3 , 6 } , { 2 , 4 , 4 } , { 2 , 6 , 3 } , { 3 , 2 , 6 } , { 3 , 3 , 3 } , { 3 , 6 , 2 } , { 4 , 2 , 4 } , { 4 , 4 , 2 } , { 6 , 2 , 3 } , { 6 , 3 , 2 } } ; static int find_triplet ( int [ ] array , int n ) { int answer = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { indices [ i ] = new List < int > ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . Add ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int y = array [ i ] ; for ( int j = 0 ; j < ROW ; j ++ ) { int s = test [ j , 1 ] * y ; if ( s % test [ j , 0 ] != 0 ) continue ; if ( s % test [ j , 2 ] != 0 ) continue ; int x = s / test [ j , 0 ] ; int z = s / test [ j , 2 ] ; if ( x > MAX z > MAX ) continue ; int l = 0 ; int r = indices [ x ] . Count - 1 ; int first = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ x ] [ m ] < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . Count - 1 ; int third = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ z ] [ m ] > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != - 1 && third != - 1 ) { answer += ( first + 1 ) * ( indices [ z ] . Count - third ) ; } } } return answer ; } public static void Main ( String [ ] args ) { int [ ] array = { 2 , 4 , 5 , 6 , 7 } ; int n = array . Length ; Console . WriteLine ( find_triplet ( array , n ) ) ; } }"}
{"text": "Unsur -unsur bersebelahan yang berbeza dalam array binari | C # pelaksanaan pendekatan di atas; Jika array hanya mempunyai satu elemen, kembali 1; Untuk elemen pertama bandingkan dengan hanya elemen seterusnya; Untuk unsur -unsur yang tersisa berbanding dengan kedua -dua elemen sebelumnya dan seterusnya; Untuk elemen terakhir bandingkan dengan hanya elemen sebelumnya; Kod pemacu", "code": "using System ; class GFG { static int distinct ( int [ ] arr , int n ) { int count = 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; } public static void Main ( String [ ] args ) { int [ ] arr = { 0 , 0 , 0 , 0 , 0 , 1 , 0 } ; int n = arr . Length ; Console . WriteLine ( distinct ( arr , n ) ) ; } }"}
{"text": "Semak jika pelbagai pasangan boleh disusun dengan menukar pasangan dengan elemen pertama yang berbeza | C # Program untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada array disusun atau tidak; Melintasi array arr []; Kembali benar; Fungsi untuk memeriksa sama ada mungkin untuk menyusun array w. r. t. elemen pertama; Menyimpan id elemen pertama; Melintasi array arr []; Jika arr [i]. Kedua tidak sama dengan kumpulan; Jika array disusun; Kod pemacu", "code": "using System ; class GFG { static bool isSorted ( int [ , ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i , 0 ] > arr [ i - 1 , 0 ] ) { return false ; } } return true ; } static string isPossibleToSort ( int [ , ] arr , int N ) { int group = arr [ 0 , 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i , 1 ] != group ) { return \" Yes \" ; } } if ( isSorted ( arr , N ) ) { return \" Yes \" ; } else { return \" No \" ; } } public static void Main ( ) { int [ , ] arr = { { 340000 , 2 } , { 45000 , 1 } , { 30000 , 2 } , { 50000 , 4 } } ; int N = arr . GetLength ( 0 ) ; Console . WriteLine ( isPossibleToSort ( arr , N ) ) ; } }"}
{"text": "Cari skor alpha langkah -langkah yang diberikan (menggunakan BST) | C # Program untuk melaksanakan pendekatan di atas; Struktur nod; Berfungsi untuk mengira dan mengembalikan skor alpha perjalanan; Traverse kiri subtree; Kirakan skor alpha langkah semasa; Kemas kini skor Alpha perjalanan; Melintasi subtree kanan; Kembali; Berfungsi untuk membina BST dari array yang disusun [] arr; Masukkan akar; Membina subtree kiri; Membina subtree kanan; Pulangan akar; Kod pemacu; Susun array; Bina BST dari array yang disusun", "code": "using System ; class Node { public Node left , right ; public int data ; public Node ( int data ) { this . data = data ; left = null ; right = null ; } } class AlphaScore { Node root ; AlphaScore ( ) { root = null ; } static long sum = 0 , total_sum = 0 ; static long mod = 1000000007 ; static long getAlphaScore ( Node node ) { if ( node . left != null ) getAlphaScore ( node . left ) ; sum = ( sum + node . data ) % mod ; total_sum = ( total_sum + sum ) % mod ; if ( node . right != null ) getAlphaScore ( node . right ) ; return total_sum ; } static Node constructBST ( int [ ] arr , int start , int end , Node root ) { if ( start > end ) return null ; int mid = ( start + end ) / 2 ; if ( root == null ) root = new Node ( arr [ mid ] ) ; root . left = constructBST ( arr , start , mid - 1 , root . left ) ; root . right = constructBST ( arr , mid + 1 , end , root . right ) ; return root ; } public static void Main ( String [ ] args ) { int [ ] arr = { 10 , 11 , 12 } ; int length = arr . Length ; Array . Sort ( arr ) ; Node root = null ; root = constructBST ( arr , 0 , length - 1 , root ) ; Console . WriteLine ( getAlphaScore ( root ) ) ; } }"}
{"text": "Menyusun elemen array mengikut kekerapan dalam penurunan urutan | C # Program untuk menyusun array dalam penurunan urutan kekerapan mereka; Fungsi yang mengembalikan indeks sehingga semua elemen array dikemas kini. ; Permulaan maxe = - 1; Cari elemen maksimum ARR []; Membuat frekuensi array freq []; Mengemas kini array frekuensi mengikut kejadian elemen dalam arr []; Permulaan CNT hingga 0; Melintasi freq []; Jika freq dari elemen lebih besar daripada 0 mengemas kini nilai ARR [] pada indeks CNT & kenaikan CNT; Kembali CNT; Fungsi yang mencetak array arr [] elemen dalam urutan yang disusun; Melintasi arr [] sehingga indeks cnt; Cari kekerapan elemen; Cari nilai di Indeks I; Melintasi kekerapan untuk mencetak nilai pada indeks I; Kod pemacu; Saiz array arr []; Fungsi panggilan untuk mendapatkan CNT; Susun arr [] dalam penurunan urutan; Fungsi yang mencetak elemen dalam penurunan urutan", "code": "using System ; class GFG { static int sortByFreq ( int [ ] arr , int n ) { int maxE = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { maxE = Math . Max ( maxE , arr [ i ] ) ; } int [ ] freq = new int [ maxE + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i <= maxE ; i ++ ) { if ( freq [ i ] > 0 ) { int value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } } return cnt ; } static void printSortedArray ( int [ ] arr , int cnt ) { for ( int i = 0 ; i < cnt ; i ++ ) { int frequency = arr [ i ] / 100000 ; int value = 100000 - ( arr [ i ] % 100000 ) ; for ( int j = 0 ; j < frequency ; j ++ ) { Console . Write ( value + \" ▁ \" ) ; } } } public static void Main ( ) { int [ ] arr = { 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 } ; int n = arr . Length ; int cnt = sortByFreq ( arr , n ) ; Array . Sort ( arr ) ; Array . Reverse ( arr ) ; printSortedArray ( arr , cnt ) ; } }"}
{"text": "Semak jika N Rectangles kawasan yang sama boleh dibentuk dari (4 * n) integer | C # pelaksanaan pendekatan; Berfungsi untuk memeriksa sama ada kita boleh membuat segi empat tepat kawasan yang sama; Susun array; Cari kawasan mana -mana segi empat tepat; Semak sama ada kita mempunyai dua sisi yang sama untuk setiap segi empat tepat dan kawasan setiap segi empat tepat yang terbentuk adalah sama; Kemas kini jawapan kepada palsu jika keadaan gagal; Jika boleh; Kod pemacu", "code": "using System ; class GFG { static bool checkRectangles ( int [ ] arr , int n ) { bool ans = true ; Array . Sort ( arr ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 } ; int n = 2 ; if ( checkRectangles ( arr , n ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Count of Elements yang tidak berada di kedudukan yang betul | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan elemen yang tidak berada di kedudukan yang betul apabila disusun; Untuk menyimpan salinan array asal; Salin unsur -unsur array yang diberikan kepada array baru; Untuk menyimpan kiraan yang diperlukan; Susun array asal; Jika elemen semasa tidak berada di kedudukan yang betul; Kod pemacu", "code": "using System ; class GFG { static int cntElements ( int [ ] arr , int n ) { int [ ] copy_arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 6 , 2 , 4 , 5 } ; int n = arr . Length ; Console . WriteLine ( cntElements ( arr , n ) ) ; } }"}
{"text": "Cari k yang diperintahkan pasangan dalam array dengan perbezaan minimum d | C # pelaksanaan pendekatan; Fungsi untuk mencari pasangan yang diperlukan; Harus ada elemen 2 * k; Untuk menyimpan pasangan; Susun array yang diberikan; Untuk setiap pasangan yang mungkin; Jika pasangan semasa adalah sah; Masukkannya ke dalam vektor pasangan; Jika pasangan k tidak mungkin; Cetak pasangan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void findPairs ( int [ ] arr , int n , int k , int d ) { if ( n < 2 * k ) { Console . Write ( - 1 ) ; return ; } List < pair > pairs = new List < pair > ( ) ; Array . Sort ( arr ) ; for ( int i = 0 ; i < k ; i ++ ) { if ( arr [ n - k + i ] - arr [ i ] >= d ) { pair p = new pair ( arr [ i ] , arr [ n - k + i ] ) ; pairs . Add ( p ) ; } } if ( pairs . Count < k ) { Console . Write ( - 1 ) ; return ; } foreach ( pair v in pairs ) { Console . WriteLine ( \" ( \" + v . first + \" , ▁ \" + v . second + \" ) \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 6 , 10 , 23 , 14 , 7 , 2 , 20 , 9 } ; int n = arr . Length ; int k = 4 , d = 3 ; findPairs ( arr , n , k , d ) ; } }"}
{"text": "Kira pasangan dengan jumlah yang diberikan | Tetapkan 2 | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan pasangan dari arr [] dengan jumlah yang diberikan; Untuk menyimpan kiraan pasangan; Susun array yang diberikan; Ambil dua petunjuk; Jika jumlahnya lebih besar; Jika jumlahnya lebih rendah; Jika jumlahnya sama; Cari kekerapan arr [i]; Cari kekerapan Arr [J]; Jika arr [i] dan arr [j] sama maka keluarkan nombor tambahan yang dikira; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int pairs_count ( int [ ] arr , int n , int sum ) { int ans = 0 ; Array . Sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( ( i < j ) && ( arr [ i ] == x ) ) i ++ ; int y = arr [ j ] , yy = j ; while ( ( j >= i ) && ( arr [ j ] == y ) ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 5 , 7 , 5 , - 1 } ; int n = arr . Length ; int sum = 6 ; Console . WriteLine ( pairs_count ( arr , n , sum ) ) ; } }"}
{"text": "Semak jika rentetan mengandungi huruf berturut -turut dan setiap huruf berlaku tepat sekali | C # Program untuk melaksanakan pendekatan di atas; untuk semua watak rentetan; Cari nilai ASCII watak; Semak sama ada watak yang sah, jika tidak maka kembali palsu; Hitung jumlah semua nilai ASCII; Cari nilai ASCII minimum dari rentetan; Cari nilai ASCII maksimum dari rentetan; Untuk mendapatkan elemen sebelumnya nilai ASCII minimum; Ambil jumlah yang diharapkan dari persamaan di atas; Semak sama ada jumlah yang dijangkakan adalah sama dengan jumlah yang dikira atau tidak; Kod pemacu; Contoh 1 st; Contoh 2 nd", "code": "using System ; class GFG { static bool check ( string str ) { int min = Int32 . MaxValue ; int max = Int32 . MinValue ; int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { int ascii = ( int ) str [ i ] ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; } static void Main ( ) { string str = \" dcef \" ; if ( check ( str ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; string str1 = \" xyza \" ; if ( check ( str1 ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "K | C # pelaksanaan pendekatan di atas; Berfungsi untuk mencari jumlah minimum semua subarray; Masukkan semua elemen dalam satu set; Cari elemen maksimum dan minimum; Melintasi unsur minimum hingga maksimum; Semak sama ada \"Saya\" hilang; Semak sama ada kth hilang; Jika tiada elemen kth hilang; Kod pemacu", "code": "using System ; using System . Linq ; using System . Collections . Generic ; class GFG { static int findKth ( int [ ] arr , int n , int k ) { HashSet < int > missing = new HashSet < int > ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { missing . Add ( arr [ i ] ) ; } int maxm = arr . Max ( ) ; int minm = arr . Min ( ) ; for ( int i = minm + 1 ; i < maxm ; i ++ ) { if ( ! missing . Contains ( i ) ) { count ++ ; } if ( count == k ) { return i ; } } return - 1 ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 10 , 9 , 4 } ; int n = arr . Length ; int k = 5 ; Console . WriteLine ( findKth ( arr , n , k ) ) ; } }"}
{"text": "Susun senarai yang dipautkan yang mengandungi nilai dari 1 hingga n | C # Program untuk menyusun senarai berkaitan yang mengandungi nilai dari 1 hingga n; Nod senarai pautan; Berfungsi untuk menyusun senarai yang dipautkan; Berfungsi untuk menambah nod pada permulaan senarai yang dipautkan; memperuntukkan nod; masukkan data; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Fungsi ini mencetak kandungan senarai yang dipautkan bermula dari nod yang diberikan; Kod pemacu; Senarai yang dipautkan yang dibina ialah: 3 -> 5 -> 4 -> 6 -> 1 -> 2", "code": "using System ; class GFG { public class Node { public int data ; public Node next ; } ; static Node start ; static void sortList ( Node head ) { int startVal = 1 ; while ( head != null ) { head . data = startVal ; startVal ++ ; head = head . next ; } } static void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; start = head_ref ; } static void printList ( Node node ) { while ( node != null ) { Console . Write ( node . data + \" ▁ \" ) ; node = node . next ; } } public static void Main ( String [ ] args ) { start = null ; push ( start , 2 ) ; push ( start , 1 ) ; push ( start , 6 ) ; push ( start , 4 ) ; push ( start , 5 ) ; push ( start , 3 ) ; sortList ( start ) ; printList ( start ) ; } }"}
{"text": "Semak jika senarai yang dipautkan disusun (berulang dan rekursif) | C # Program untuk menyemak semula senarai Linked disusun dalam urutan menurun atau tidak; Nod senarai yang dipautkan; fungsi untuk menyemak senarai yang dipautkan disusun mengikut urutan menurun atau tidak; Kes asas; Semak dua nod pertama dan semak semula rekursif. ; Kod pemacu", "code": "using System ; class GfG { public class Node { public int data ; public Node next ; } static bool isSortedDesc ( Node head ) { if ( head == null head . next == null ) return true ; return ( head . data > head . next . data && isSortedDesc ( head . next ) ) ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . next = null ; temp . data = data ; return temp ; } public static void Main ( String [ ] args ) { Node head = newNode ( 7 ) ; head . next = newNode ( 5 ) ; head . next . next = newNode ( 4 ) ; head . next . next . next = newNode ( 3 ) ; if ( isSortedDesc ( head ) == true ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Susun semula array untuk meminimumkan jumlah produk elemen pasangan berturut -turut | Program untuk menyusun array sedemikian rupa sehingga jumlah produk elemen alternatif adalah minimum. ; Buat Evenarr [] dan Oddarr []; Susun pelbagai utama dalam urutan menaik; Letakkan unsur -unsur di Oddarr [] dan evenarr [] seperti nilai yang dikehendaki. ; Susun everarr [] dalam urutan menurun; menggabungkan kedua -dua sub - array dan mengira jumlah minimum produk elemen alternatif; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int minSum ( int [ ] arr , int n ) { List < int > evenArr = new List < int > ( ) ; List < int > oddArr = new List < int > ( ) ; int i ; Array . Sort ( arr ) ; for ( i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) { oddArr . Add ( arr [ i ] ) ; } else { evenArr . Add ( arr [ i ] ) ; } } evenArr . Sort ( ) ; evenArr . Reverse ( ) ; int k = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . Count ; j ++ ) { arr [ k ++ ] = evenArr [ j ] ; arr [ k ++ ] = oddArr [ j ] ; sum += evenArr [ j ] * oddArr [ j ] ; } return sum ; } public static void Main ( ) { int [ ] arr = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = arr . Length ; Console . WriteLine ( \" Minimum ▁ required ▁ sum ▁ = ▁ \" + minSum ( arr , n ) ) ; Console . WriteLine ( \" Sorted ▁ array ▁ in ▁ \" + \" required ▁ format ▁ : ▁ \" ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } } }"}
{"text": "Masa minimum diperlukan untuk mencetak rentetan yang diberikan dari bekas bulat berdasarkan syarat yang diberikan | C # pelaksanaan untuk pendekatan di atas; Berfungsi untuk mengira masa minimum untuk mencetak semua aksara dalam rentetan; Elemen semasa di mana penunjuk sedang menunjuk; Cari indeks elemen itu; Kirakan perbezaan mutlak antara indeks penunjuk dan indeks aksara sebagai jarak mengikut arah jam; Kurangkan masa mengikut arah jam dari 26 untuk mendapatkan masa anti -jam; Tambah minimum kedua -dua kali untuk jawapannya; Tambah satu unit masa untuk mencetak watak; Cetak jawapan terakhir; Kod pemacu; Diberikan perkataan rentetan; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void minTime ( string word ) { int ans = 0 ; int curr = 0 ; for ( int i = 0 ; i < word . Length ; i ++ ) { int k = ( int ) word [ i ] - 97 ; int a = Math . Abs ( curr - k ) ; int b = 26 - Math . Abs ( curr - k ) ; ans += Math . Min ( a , b ) ; ans ++ ; curr = ( int ) word [ i ] - 97 ; } Console . Write ( ans ) ; } public static void Main ( ) { string str = \" zjpc \" ; minTime ( str ) ; } }"}
{"text": "Pengurangan minimum atau pembahagian oleh pembahagi yang betul yang diperlukan untuk mengurangkan N hingga 1 | C # Program untuk pendekatan di atas; Fungsi untuk mencari bilangan langkah minimum yang diperlukan untuk mengurangkan n hingga 1; Menyimpan bilangan langkah yang diperlukan; Jika nilai n sama dengan 2 atau n adalah ganjil; Penurunan n oleh 1; Kenaikan CNT oleh 1; Jika n juga; Kemas kini n; Kenaikan CNT oleh 1; Mengembalikan bilangan langkah yang diperoleh; Kod pemacu", "code": "using System ; class GFG { static int reduceToOne ( long N ) { int cnt = 0 ; while ( N != 1 ) { if ( N == 2 || ( N % 2 == 1 ) ) { N = N - 1 ; cnt ++ ; } else if ( N % 2 == 0 ) { N = N / ( N / 2 ) ; cnt ++ ; } } return cnt ; } public static void Main ( ) { long N = 35 ; Console . WriteLine ( reduceToOne ( N ) ) ; } }"}
{"text": "Bilangan maksimum berlian yang boleh diperolehi dalam minit k | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan maksimum berlian yang boleh diperolehi dalam beberapa minit; Menyimpan semua elemen array; Tolak semua elemen ke barisan keutamaan; Menyimpan hasil yang diperlukan; Gelung manakala barisan tidak kosong dan k positif; Simpan elemen teratas dari PQ; Pop dari PQ; Tambahkannya kepada jawapannya; Bahagikannya dengan 2 dan tolaknya kembali ke PQ; Cetak jawapannya; Kod pemacu", "code": "using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static void maxDiamonds ( int [ ] A , int N , int K ) { var pq = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { pq . Add ( A [ i ] ) ; } int ans = 0 ; while ( pq . Count != 0 && K -- > 0 ) { pq . Sort ( ) ; int top = pq [ pq . Count - 1 ] ; pq . RemoveAt ( pq . Count - 1 ) ; ans += top ; top = top / 2 ; pq . Add ( top ) ; } Console . WriteLine ( ans ) ; } public static void Main ( string [ ] args ) { int [ ] A = { 2 , 1 , 7 , 4 , 2 } ; int K = 3 ; int N = A . Length ; maxDiamonds ( A , N , K ) ; } }"}
{"text": "Kurangkan kos kenaikan atau pengurangan seperti unsur -unsur yang diindeks yang sama menjadi pelbagai antara satu sama lain | C # Program untuk pendekatan di atas; Fungsi untuk mencari kos minimum untuk membuat [i] berbilang b [i] atau naib - sebaliknya untuk setiap elemen array; Menyimpan kos minimum; Melintasi array; Kes 1: Kemas kini [i]; Kes 2: Kemas kini B [i]; Tambah minimum dua kes di atas; Mengembalikan kos yang dihasilkan; Kod pemacu", "code": "using System ; class GFG { static int MinimumCost ( int [ ] A , int [ ] B , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int mod_A = B [ i ] % A [ i ] ; int totalCost_A = Math . Min ( mod_A , A [ i ] - mod_A ) ; int mod_B = A [ i ] % B [ i ] ; int totalCost_B = Math . Min ( mod_B , B [ i ] - mod_B ) ; totalCost += Math . Min ( totalCost_A , totalCost_B ) ; } return totalCost ; } public static void Main ( ) { int [ ] A = { 3 , 6 , 3 } ; int [ ] B = { 4 , 8 , 13 } ; int N = A . Length ; Console . Write ( MinimumCost ( A , B , N ) ) ; } }"}
{"text": "Nombor terbesar dibahagi dengan 50 yang boleh dibentuk dari satu set digit N yang terdiri daripada 0 s dan 7 s sahaja | C # Program pendekatan di atas; Cetak nombor terbesar yang boleh dibahagikan dengan 50; Mengira nombor 0 s dan 7 s; Jika kiraan 7 boleh dibahagikan dengan 50; Jika kiraan 7 kurang daripada 5; Jika kiraan 7 tidak boleh dibahagikan dengan 50; Count kumpulan 5 di mana kiraan 7 s boleh dikumpulkan; Kod pemacu; Diberikan array; Saiz array", "code": "using System ; public class GFG { static void printLargestDivisible ( int [ ] arr , int N ) { int i , count0 = 0 , count7 = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; else count7 ++ ; } if ( count7 % 50 == 0 ) { while ( count7 != 0 ) { Console . Write ( 7 ) ; count7 -= 1 ; } while ( count0 != 0 ) { Console . Write ( 0 ) ; count0 -= 1 ; } } else if ( count7 < 5 ) { if ( count0 == 0 ) Console . Write ( \" No \" ) ; else Console . Write ( \"0\" ) ; } else { count7 = count7 - count7 % 5 ; while ( count7 != 0 ) { Console . Write ( 7 ) ; count7 -= 1 ; } while ( count0 != 0 ) { Console . Write ( 0 ) ; count0 -= 1 ; } } } public static void Main ( String [ ] args ) { int [ ] arr = { 0 , 7 , 0 , 7 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 7 , 7 } ; int N = arr . Length ; printLargestDivisible ( arr , N ) ; } }"}
{"text": "Susun semula Arahan untuk memaksimumkan jumlah GCD unsur -unsur array dengan indeks masing -masing | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari jumlah maksimum GCD (arr [i], i) dengan menyusun semula array; Susun array dalam urutan menaik; Kedai maksimum jumlah GCD (arr [i], i) dengan menyusun semula elemen array; Menjana semua permutasi yang mungkin dari array; Kedai jumlah GCD (arr [i], i); Melintasi array; Kemas kini Jumlah; Kemas kini res; Kod pemacu", "code": "using System ; class GFG { static int findMaxValByRearrArr ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int res = 0 ; do { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += __gcd ( i + 1 , arr [ i ] ) ; } res = Math . Max ( res , sum ) ; } while ( next_permutation ( arr ) ) ; return res ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static bool next_permutation ( int [ ] p ) { for ( int a = p . Length - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( int b = p . Length - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { int t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . Length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 1 } ; int N = arr . Length ; Console . Write ( findMaxValByRearrArr ( arr , N ) ) ; } }"}
{"text": "Penyingkiran minimum diperlukan untuk membuat kekerapan setiap elemen array sama dengan nilainya | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mencari kiraan minimum elemen yang diperlukan untuk dikeluarkan sedemikian rupa sehingga kekerapan arr [i] sama dengan arr [i]; Kedai kekerapan setiap elemen array; Melintasi array; Kemas kini kekerapan ARR [i]; Kedai kiraan minimum penyingkiran; Melintasi peta; Menyimpan nilai utama peta; Jika kekerapan saya kurang daripada saya; Mengemas kini cntminrem; Jika kekerapan saya lebih besar daripada saya; Mengemas kini cntminrem; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int min_elements ( int [ ] arr , int N ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] ++ ; } else { mp [ arr [ i ] ] = 1 ; } } int cntMinRem = 0 ; foreach ( KeyValuePair < int , int > it in mp ) { int i = it . Key ; if ( mp [ i ] < i ) { cntMinRem += mp [ i ] ; } else if ( mp [ i ] > i ) { cntMinRem += ( mp [ i ] - i ) ; } } return cntMinRem ; } static void Main ( ) { int [ ] arr = { 2 , 4 , 1 , 4 , 2 } ; int N = arr . Length ; Console . Write ( min_elements ( arr , N ) ) ; } }"}
{"text": "Peningkatan minimum untuk membuat semua elemen array sama dengan jumlah yang sama dengan array yang diberikan selepas tepat satu penyingkiran | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada pelbagai elemen yang sama dengan jumlah yang sama dengan array yang diberikan boleh diperoleh atau tidak; Kes asas; Kedai jumlah elemen array; Menyimpan elemen array kedua terbesar; Menyimpan elemen array terbesar; Melintasi array; Kemas kini SecMax; Kemas kini Max; Kemas kini SecMax; Kemas kini totalsum; Jika totalsum kurang daripada secmax * (n - 1)); Jika totalsum tidak boleh dibahagikan dengan (n - 1); Kod pemacu", "code": "using System ; class GFG { static bool CheckAllarrayEqual ( int [ ] arr , int N ) { if ( N == 1 ) { return true ; } int totalSum = arr [ 0 ] ; int secMax = Int32 . MinValue ; int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= Max ) { secMax = Max ; Max = arr [ i ] ; } else if ( arr [ i ] > secMax ) { secMax = arr [ i ] ; } totalSum += arr [ i ] ; } if ( ( secMax * ( N - 1 ) ) > totalSum ) { return false ; } if ( totalSum % ( N - 1 ) != 0 ) { return false ; } return true ; } public static void Main ( ) { int [ ] arr = { 6 , 2 , 2 , 2 } ; int N = arr . Length ; if ( CheckAllarrayEqual ( arr , N ) ) { Console . Write ( \" YES \" ) ; } else { Console . Write ( \" NO \" ) ; } } }"}
{"text": "Kira cara untuk membuat bitwise xor ganjil dan bahkan elemen diindeks sama dengan mengeluarkan elemen array | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira cara untuk membuat bitwise xor aneh dan bahkan elemen diindeks sama dengan mengeluarkan elemen array; Kedai xor unsur -unsur ganjil dan bahkan diindeks dari akhir; Kedai xor unsur -unsur ganjil dan bahkan diindeks dari awal; Menyimpan kiraan yang diperlukan; Melintasi array secara terbalik; Sekiranya saya ganjil; Sekiranya saya juga; Melintasi array; Sekiranya saya ganjil; Sekiranya saya juga; Mengeluarkan arr [i], kedai post_even xor unsur -unsur yang diindeks ganjil; Mengeluarkan arr [i], post_odd menyimpan xor walaupun elemen yang diindeks; Semak sama ada mereka sama; Jika saya ganjil, xor dengan curr_odd; Jika saya juga, xor dengan curr_even; Akhirnya cetak res; Kod pemacu; Diberikan array; Saiz yang diberikan; Panggilan fungsi", "code": "using System ; class GFG { static void Remove_one_element ( int [ ] arr , int n ) { int post_odd = 0 , post_even = 0 ; int curr_odd = 0 , curr_even = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 != 0 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; int X = curr_odd ^ post_even ; int Y = curr_even ^ post_odd ; if ( X == Y ) res ++ ; if ( i % 2 != 0 ) curr_odd ^= arr [ i ] ; else curr_even ^= arr [ i ] ; } Console . WriteLine ( res ) ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 } ; int N = arr . Length ; Remove_one_element ( arr , N ) ; } }"}
{"text": "Kira cara untuk membuat jumlah elemen ganjil dan bahkan diindeks sama dengan mengeluarkan elemen array | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira indeks array yang penyingkirannya menjadikan jumlah unsur -unsur yang ganjil dan juga diindeks sama; Jika saiz array adalah 1; Jika saiz array adalah 2; Kedai -kedai jumlah unsur -unsur yang diindeks dari array yang diberikan; Kedai Jumlah unsur -unsur yang diindeks dari array yang diberikan; Melintasi array; Jika saya adalah nombor yang sama; Kemas kini Sumeven; Jika saya adalah nombor ganjil; Kemas kini Sumodd; Kedai Jumlah unsur -unsur array yang diindeks sehingga indeks i - th; Kedai Jumlah unsur array yang diindeks sehingga indeks i - th; Kedai -kedai mengira indeks yang penyingkirannya membuat jumlah unsur -unsur yang ganjil dan juga diindeks sama; Kedai -kedai jumlah unsur -unsur yang diindeks selepas mengeluarkan elemen i - th; Kedai Jumlah unsur -unsur yang diindeks selepas mengeluarkan elemen i - th; Melintasi array; Jika saya adalah nombor ganjil; Kemas kini Currodd; Kemas kini Newevensum; Kemas kini Newoddsum; Jika saya adalah nombor yang sama; Kemas kini Curreven; Kemas kini Newoddsum; Kemas kini Newevensum; Jika Newevensum sama dengan Newoddsum; Meningkatkan kiraan; Jika jumlah unsur -unsur yang diindeks dan ganjil - diindeks adalah sama dengan mengeluarkan elemen pertama; Meningkatkan kiraan; Jika panjang array adalah nombor ganjil; Jika jumlah unsur -unsur yang diindeks dan ganjil - diindeks adalah sama dengan mengeluarkan elemen terakhir; Meningkatkan kiraan; Jika panjang array adalah nombor yang sama; Jika jumlah unsur -unsur yang diindeks dan ganjil - diindeks adalah sama dengan mengeluarkan elemen terakhir; Meningkatkan kiraan; Kod pemandu", "code": "using System ; class GFG { static int cntIndexesToMakeBalance ( int [ ] arr , int n ) { if ( n == 1 ) { return 1 ; } if ( n == 2 ) return 0 ; int sumEven = 0 ; int sumOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { sumEven += arr [ i ] ; } else { sumOdd += arr [ i ] ; } } int currOdd = 0 ; int currEven = arr [ 0 ] ; int res = 0 ; int newEvenSum = 0 ; int newOddSum = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( i % 2 != 0 ) { currOdd += arr [ i ] ; newEvenSum = currEven + sumOdd - currOdd ; newOddSum = currOdd + sumEven - currEven - arr [ i ] ; } else { currEven += arr [ i ] ; newOddSum = currOdd + sumEven - currEven ; newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; } if ( newEvenSum == newOddSum ) { res ++ ; } } if ( sumOdd == sumEven - arr [ 0 ] ) { res ++ ; } if ( n % 2 == 1 ) { if ( sumOdd == sumEven - arr [ n - 1 ] ) { res ++ ; } } else { if ( sumEven == sumOdd - arr [ n - 1 ] ) { res ++ ; } } return res ; } public static void Main ( ) { int [ ] arr = { 1 , 1 , 1 } ; int n = arr . Length ; Console . WriteLine ( cntIndexesToMakeBalance ( arr , n ) ) ; } }"}
{"text": "Cari dua nombor dari jumlah dan xor mereka | Tetapkan 2 | C # Program untuk pendekatan di atas; Fungsi untuk mencari nilai a dan b yang jumlahnya adalah x dan xor adalah y; Memulakan dua nombor; Kes 1: x <y; Kes 2: x - y adalah ganjil; Kes 3: Jika kedua -dua jumlah dan XOR adalah sama; Kes 4: jika di atas kes gagal; Kemas kini nilai a; Semak jika nilai A & Y ialah 0; Jika benar, kemas kini b; Sebaliknya berikan - 1 hingga a, - 1 hingga b; Cetak nombor A dan B; Kod pemacu; Diberikan jumlah dan xor 2 nombor; Panggilan fungsi", "code": "using System ; class GFG { static void findNums ( int X , int Y ) { int A , B ; if ( X < Y ) { A = - 1 ; B = - 1 ; } else if ( ( ( Math . Abs ( X - Y ) ) & 1 ) != 0 ) { A = - 1 ; B = - 1 ; } else if ( X == Y ) { A = 0 ; B = Y ; } else { A = ( X - Y ) / 2 ; if ( ( A & Y ) == 0 ) { B = ( A + Y ) ; } else { A = - 1 ; B = - 1 ; } } Console . Write ( A + \" ▁ \" + B ) ; } public static void Main ( String [ ] args ) { int X = 17 , Y = 13 ; findNums ( X , Y ) ; } }"}
{"text": "Pertanyaan untuk memeriksa sama ada kiraan peningkatan dan penurunan subarray adalah sama dalam julat yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada julat yang diberikan mempunyai bilangan yang sama dan penurunan subarrays; Melintasi setiap pertanyaan; Untuk pengindeksan berasaskan 0; Keadaan untuk kiraan yang sama meningkatkan & menurunkan subarray; Kod pemacu", "code": "using System ; class GFG { static void checkCount ( int [ ] A , int [ , ] Q , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i , 0 ] ; int R = Q [ i , 1 ] ; L -- ; R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { Console . WriteLine ( \" Yes \" ) ; } else { Console . WriteLine ( \" No \" ) ; } } } public static void Main ( ) { int [ ] arr = { 11 , 13 , 12 , 14 } ; int [ , ] Q = { { 1 , 4 } , { 2 , 4 } } ; int q = Q . GetLength ( 0 ) ; checkCount ( arr , Q , q ) ; } }"}
{"text": "Purata array yang dihasilkan oleh produk semua pasang array yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mencari min pasangan pasangan array [] arr; Menyimpan produk pasangan; Menjana semua pasangan yang tidak teratur; Menyimpan produk pasangan; Saiz PairArray; Simpan Jumlah PairArray; Menyimpan min PairArray []; Cari min PairArray []; Mengembalikan maksud yang dihasilkan; Kod pemacu; Diberikan array [] arr; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static double pairProductMean ( int [ ] arr , int N ) { List < int > pairArray = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . Add ( pairProduct ) ; } } int length = pairArray . Count ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 8 } ; int N = arr . Length ; Console . WriteLine ( \" { 0 : F2 } \" , pairProductMean ( arr , N ) ) ; } }"}
{"text": "Cari pemain yang terakhir untuk mengeluarkan apa -apa watak dari permulaan rentetan binari | C # Program untuk pendekatan di atas; Berfungsi untuk mencari pemain yang kehilangan permainan; Bergerak untuk pemain pertama; Bergerak untuk pemain kedua; Melangkah ke atas pelbagai rentetan; Semak sama ada watak pertama dan terakhir adalah sama; Semak jika rentetan bermula dan berakhir dengan aksara '0'; Jika pemain pertama mempunyai kurang bergerak; Kod pemacu; Diberikan pelbagai rentetan; Panggilan fungsi", "code": "using System ; class GFG { static void findPlayer ( string [ ] str , int n ) { int move_first = 0 ; int move_sec = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] [ 0 ] == str [ i ] [ str [ i ] . Length - 1 ] ) { if ( ( str [ i ] [ 0 ] ) == 48 ) move_first ++ ; else move_sec ++ ; } } if ( move_first <= move_sec ) { Console . Write ( \" Player ▁ 2 ▁ wins \" ) ; } else { Console . Write ( \" Player ▁ 1 ▁ wins \" ) ; } } public static void Main ( ) { string [ ] str = { \"010\" , \"101\" } ; int N = str . Length ; findPlayer ( str , N ) ; } }"}
{"text": "Bilangan terkecil melebihi n yang bit kth ditetapkan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari nombor yang lebih besar daripada n yang bit kthnya ditetapkan; Berulang dari n + 1; Semak sama ada bit kth ditetapkan atau tidak; Kenaikan m untuk nombor seterusnya; Mengembalikan nilai minimum; Kod pemacu; Diberikan n dan k; Panggilan fungsi", "code": "using System ; class GFG { static int find_next ( int n , int k ) { int M = n + 1 ; while ( true ) { if ( ( M & ( 1L << k ) ) > 0 ) break ; M ++ ; } return M ; } public static void Main ( String [ ] args ) { int N = 15 , K = 2 ; Console . Write ( find_next ( N , K ) ) ; } }"}
{"text": "Bilangan terkecil melebihi n yang bit kth ditetapkan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari nombor yang lebih besar daripada n yang bit kthnya ditetapkan; Menyimpan nombor yang dihasilkan; Jika bit kth tidak ditetapkan; Cur akan menjadi jumlah semua kuasa 2 <k; Jika bit semasa ditetapkan; Tambah kuasa kth 2 hingga n dan tolak semua kuasa 2 kurang daripada k yang ditetapkan; Jika bit kth ditetapkan; Kedudukan bit pertama yang pertama; Jumlah bit yang ditetapkan; Tambah kuasa kth 2 hingga n dan tolak semua kuasa 2 kurang daripada k yang ditetapkan; Jika kth bit menjadi tidak tersendiri maka tetapkannya lagi; Mengembalikan nombor yang dihasilkan; Kod pemacu; Cetak Ans", "code": "using System ; class GFG { static int find_next ( int n , int k ) { int ans = 0 ; if ( ( n & ( 1L << k ) ) == 0 ) { int cur = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( ( n & ( 1L << i ) ) > 0 ) cur += ( int ) 1L << i ; } ans = ( int ) ( n - cur + ( 1L << k ) ) ; } else { int first_unset_bit = - 1 , cur = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( n & ( 1L << i ) ) == 0 ) { first_unset_bit = i ; break ; } else cur += ( int ) ( 1L << i ) ; } ans = ( int ) ( n - cur + ( 1L << first_unset_bit ) ) ; if ( ( ans & ( 1L << k ) ) == 0 ) ans += ( int ) ( 1L << k ) ; } return ans ; } public static void Main ( String [ ] args ) { int N = 15 , K = 2 ; Console . Write ( find_next ( N , K ) ) ; } }"}
{"text": "Lexicographically terbesar mungkin rentetan selepas penyingkiran Kara K | C # Program untuk melaksanakan pendekatan di atas; Rentetan hasil akhir; Jika char semasa melebihi watak di bahagian atas timbunan; Keluarkan dari hujung rentetan; Kurangkan k untuk penyingkiran; Masukkan watak semasa; Lakukan penghapusan k yang tersisa dari akhir rentetan; Kembalikan rentetan; Kod pemacu", "code": "using System ; class GFG { static String largestString ( String num , int k ) { String ans = \" \" ; foreach ( char i in num . ToCharArray ( ) ) { while ( ans . Length > 0 && ans [ ans . Length - 1 ] < i && k > 0 ) { ans = ans . Substring ( 0 , ans . Length - 1 ) ; k -- ; } ans += i ; } while ( ans . Length > 0 && k -- > 0 ) { ans = ans . Substring ( 0 , ans . Length - 1 ) ; } return ans ; } public static void Main ( String [ ] args ) { String str = \" zyxedcba \" ; int k = 1 ; Console . Write ( largestString ( str , k ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Panjang maksimum subarray yang terdiri daripada jenis elemen yang sama pada kedua -dua bahagian sub | C # Program untuk pendekatan di atas; Fungsi yang mendapati panjang maksimum sub -sub -yang mengandungi elemen yang sama pada kedua -dua bahagian sub -array; Untuk menyimpan kejadian berterusan unsur; Untuk menyimpan kejadian forkward berterusan; Untuk menyimpan kejadian mundur yang berterusan; Untuk menyimpan panjang maksimum; Cari panjang maksimum; Cetak hasilnya; Kod pemacu; Diberikan array; Saiz array; Panggilan fungsi", "code": "using System ; class GFG { static void maxLengthSubArray ( int [ ] A , int N ) { int [ ] forward = new int [ N ] ; int [ ] backward = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; } int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = Math . Max ( ans , Math . Min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; } Console . WriteLine ( ans ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 4 , 4 , 6 , 6 , 6 , 9 } ; int N = arr . Length ; maxLengthSubArray ( arr , N ) ; } }"}
{"text": "Nombor digit terkecil divisible oleh semua angka utama yang mungkin | C # pelaksanaan pendekatan di atas; Berfungsi untuk mencari bilangan minimum n digit yang boleh dibahagikan oleh semua digit utama; Kod pemacu", "code": "using System ; class GFG { static void minNum ( int n ) { if ( n < 3 ) Console . WriteLine ( - 1 ) ; else Console . WriteLine ( 210 * ( ( int ) ( Math . Pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; } public static void Main ( String [ ] args ) { int n = 5 ; minNum ( n ) ; } }"}
{"text": "Nombor terkecil lebih besar daripada y dengan jumlah digit yang sama dengan x | C # Program untuk pendekatan di atas; Berfungsi untuk mengembalikan rentetan minimum panjang d yang mempunyai jumlah digit s; Mengembalikan rentetan panjang d; Ramuan meletakkan 9 pada akhirnya; Masukkan jumlah yang tersisa; Berfungsi untuk mencari nombor terkecil yang lebih besar daripada y yang jumlah digitnya adalah x; Tukar nombor y ke rentetan; Mengekalkan jumlah awalan digit; Melangkah ke atas Y dari belakang di mana k adalah panjang akhiran semasa; Kedai digit semasa; Meningkatkan digit semasa; Jumlah awalan semasa; Kembali Jawapan Jika baki jumlah boleh diperolehi dalam akhiran; Cari akhiran panjang k mempunyai jumlah digit x - r; Tambah watak semasa; Mengembalikan hasilnya; Kod pemacu; Diberi nombor dan jumlah; Panggilan fungsi", "code": "using System ; using System . Text ; using System . Collections ; class GFG { static string helper ( int d , int s ) { StringBuilder ans = new StringBuilder ( ) ; for ( int i = 0 ; i < d ; i ++ ) { ans . Append ( \"0\" ) ; } for ( int i = d - 1 ; i >= 0 ; i -- ) { if ( s >= 9 ) { ans [ i ] = '9' ; s -= 9 ; } else { char c = ( char ) ( s + ( int ) '0' ) ; ans [ i ] = c ; s = 0 ; } } return ans . ToString ( ) ; } static string findMin ( int x , int Y ) { string y = Y . ToString ( ) ; int n = y . Length ; ArrayList p = new ArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { p . Add ( 0 ) ; } for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = ( int ) ( ( int ) y [ i ] - ( int ) '0' ) ; if ( i > 0 ) { p [ i ] = ( int ) p [ i ] + ( int ) p [ i - 1 ] ; } } for ( int i = n - 1 , k = 0 ; ; i -- , k ++ ) { int d = 0 ; if ( i >= 0 ) { d = ( int ) y [ i ] - ( int ) '0' ; } for ( int j = d + 1 ; j <= 9 ; j ++ ) { int r = j ; if ( i > 0 ) { r += ( int ) p [ i - 1 ] ; } if ( x - r >= 0 && x - r <= 9 * k ) { string suf = helper ( k , x - r ) ; string pre = \" \" ; if ( i > 0 ) pre = y . Substring ( 0 , i ) ; char cur = ( char ) ( j + ( int ) '0' ) ; pre += cur ; return pre + suf ; } } } } public static void Main ( string [ ] arg ) { int x = 18 ; int y = 99 ; Console . Write ( findMin ( x , y ) ) ; } }"}
{"text": "Nombor terbesar yang terdiri daripada x dan y dengan kiraan x dibahagi dengan y dan y oleh x | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk menjana dan mengembalikan nombor terbesar; Simpan yang lebih kecil di y; Simpan yang lebih besar dalam x; Kedai masing -masing; Jika n boleh dibahagikan dengan y; Tambah x, n kali ke jawapan; Mengurangkan n ke sifar; Mengurangkan n oleh x; Tambah y, x kali ke jawapan; Jika nombor boleh dibentuk; Jika tidak; Kod pemacu", "code": "using System ; class GFG { public static void largestNumber ( int n , int X , int Y ) { int maxm = Math . Max ( X , Y ) ; Y = X + Y - maxm ; X = maxm ; int Xs = 0 ; int Ys = 0 ; while ( n > 0 ) { if ( n % Y == 0 ) { Xs += n ; n = 0 ; } else { n -= X ; Ys += X ; } } if ( n == 0 ) { while ( Xs -- > 0 ) Console . Write ( X ) ; while ( Ys -- > 0 ) Console . Write ( Y ) ; } else Console . Write ( \" - 1\" ) ; } public static void Main ( String [ ] args ) { int n = 19 , X = 7 , Y = 5 ; largestNumber ( n , X , Y ) ; } }"}
{"text": "Flip minimum yang diperlukan untuk menjana substring berterusan 0 € ™ s dan 1 € ™ s | C # pelaksanaan pendekatan di atas; Melintasi rentetan input dan simpan kiraan 0; Melintasi rentetan input sekali lagi untuk mencari bilangan minimum flip; Kod pemacu", "code": "using System ; class GFG { static int minChanges ( String str , int N ) { int res ; int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '0' ) count0 ++ ; } res = count0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '0' ) count0 -- ; if ( str [ i ] == '1' ) count1 ++ ; res = Math . Min ( res , count1 + count0 ) ; } return res ; } public static void Main ( ) { int N = 9 ; String str = \"000101001\" ; Console . Write ( minChanges ( str , N ) ) ; } }"}
{"text": "Kejadian yang hilang dari nombor dalam array sedemikian rupa sehingga perbezaan mutlak unsur -unsur bersebelahan adalah minimum | C # Pelaksanaan nombor yang hilang sedemikian rupa sehingga perbezaan mutlak maksimum antara elemen bersebelahan adalah minimum; Berfungsi untuk mencari nombor yang hilang supaya perbezaan mutlak maksimum adalah minimum; Gelung untuk mencari elemen bersebelahan maksimum dan minimum kepada nombor yang hilang; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int missingnumber ( int n , int [ ] arr ) { int mn = Int32 . MaxValue , mx = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == - 1 && arr [ i - 1 ] != - 1 ) { mn = Math . Min ( mn , arr [ i - 1 ] ) ; mx = Math . Max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { mn = Math . Min ( mn , arr [ i + 1 ] ) ; mx = Math . Max ( mx , arr [ i + 1 ] ) ; } } int res = ( mx + mn ) / 2 ; return res ; } public static void Main ( ) { int n = 5 ; int [ ] arr = new int [ ] { - 1 , 10 , - 1 , 12 , - 1 } ; int res = missingnumber ( n , arr ) ; Console . WriteLine ( res ) ; } }"}
{"text": "Memaksimumkan [panjang (x) / 2 ^ (xor (x, y))] dengan memilih substrings x dan y dari rentetan a dan b masing -masing | C # Program untuk pendekatan di atas; Berfungsi untuk mencari panjang substring biasa terpanjang rentetan x dan y; Lcsuff [i] [j] menyimpan panjang akhiran biasa yang paling lama; Itearate atas rentetan a dan b; Jika baris pertama atau lajur; Jika padanan dijumpai; Jika tidak, jika padanan tidak dijumpai; Akhirnya, kembalikan nilai maksimum yang dihasilkan; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int lcsubtr ( char [ ] a , char [ ] b , int length1 , int length2 ) { int [ , ] dp = new int [ length1 + 1 , length2 + 1 ] ; int max = 0 ; for ( int i = 0 ; i <= length1 ; ++ i ) { for ( int j = 0 ; j <= length2 ; ++ j ) { if ( i == 0 j == 0 ) { dp [ i , j ] = 0 ; } else if ( a [ i - 1 ] == b [ j - 1 ] ) { dp [ i , j ] = dp [ i - 1 , j - 1 ] + 1 ; max = Math . Max ( dp [ i , j ] , max ) ; } else { dp [ i , j ] = 0 ; } } } return max ; } public static void Main ( ) { string m = \"0110\" ; string n = \"1101\" ; char [ ] m1 = m . ToCharArray ( ) ; char [ ] m2 = n . ToCharArray ( ) ; Console . Write ( lcsubtr ( m1 , m2 , m1 . Length , m2 . Length ) ) ; } }"}
{"text": "Kira cara untuk memecah array ke dalam sepasang subset dengan perbezaan antara jumlah mereka sama dengan k | C # Program untuk pendekatan di atas; Untuk menyimpan negeri -negeri DP; Fungsi untuk mencari kiraan subset dengan jumlah yang diberikan; Kes asas; Jika subproblem yang telah dikira berlaku; Tetapkan negeri seperti diselesaikan; Hubungan berulang; Berfungsi untuk mengira cara untuk memecah array ke dalam sepasang subset dengan perbezaan k; Simpan jumlah keseluruhan elemen array; Melintasi array; Hitung jumlah elemen array; Simpan jumlah yang diperlukan; Cetak bilangan subset dengan jumlah yang sama dengan S1; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int maxN = 20 ; static int maxSum = 50 ; static int minSum = 50 ; static int Base = 50 ; static int [ , ] dp = new int [ maxN , maxSum + minSum ] ; static bool [ , ] v = new bool [ maxN , maxSum + minSum ] ; static int findCnt ( int [ ] arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i , required_sum + Base ] ) return dp [ i , required_sum + Base ] ; v [ i , required_sum + Base ] = true ; dp [ i , required_sum + Base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i , required_sum + Base ] ; } static void countSubsets ( int [ ] arr , int K , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int S1 = ( sum + K ) / 2 ; Console . Write ( findCnt ( arr , 0 , S1 , n ) ) ; } static void Main ( ) { int [ ] arr = { 1 , 1 , 2 , 3 } ; int N = arr . Length ; int K = 1 ; countSubsets ( arr , K , N ) ; } }"}
{"text": "Kebarangkalian bahawa jumlah semua nombor yang diperolehi membuang dadu n kali terletak di antara dua bilangan bulat yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mengira kebarangkalian bagi jumlah yang diberikan untuk menjadi sama dengan jumlah dalam n lontaran dadu; Kes asas; Kod pemacu; Kirakan kebarangkalian semua jumlah dari A hingga B; Cetak jawapannya", "code": "using System ; using System . Collections . Generic ; public class GFG { static float [ , ] dp = new float [ 105 , 605 ] ; static float find ( int N , int sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N , sum ] > 0 ) return dp [ N , sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( float ) ( 1.0 / 6 ) ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N , sum ] = dp [ N , sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N , sum ] ; } public static void Main ( String [ ] args ) { int N = 4 , a = 13 , b = 17 ; float probability = 0.0f ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; Console . Write ( \" { 0 : F6 } \" , probability ) ; } }"}
{"text": "Langkah minimum untuk mengurangkan n hingga 0 dengan operasi yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari nombor minimum ke langkah untuk mengurangkan n hingga 0; Kamus untuk menyimpan jumlah yang dipraktikkan; Kes -kes asas; Semak jika n tidak dalam DP maka hanya panggil fungsi untuk mengurangkan panggilan rekursif; Kembalikan jawapannya; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; public class GFG { static int count ( int n ) { Dictionary < int , int > dp = new Dictionary < int , int > ( ) ; dp . Add ( 0 , 0 ) ; dp . Add ( 1 , 1 ) ; if ( ! dp . ContainsKey ( n ) ) dp . Add ( n , 1 + Math . Min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ) ; return dp [ n ] ; } public static void Main ( String [ ] args ) { int N = 6 ; Console . WriteLine ( String . Join ( \" \" , ( count ( N ) ) ) ) ; } }"}
{"text": "Pengiraan minimum kenaikan saiz K subarrays diperlukan untuk membentuk array yang diberikan | C # pelaksanaan untuk mencari bilangan minimum operasi yang diperlukan untuk menukar pelbagai sifar supaya setiap elemen lebih besar daripada array yang diberikan; Berfungsi untuk mencari bilangan minimum operasi yang diperlukan untuk menukar semua pelbagai sifar supaya setiap elemen lebih besar daripada array yang diberikan; Mengisytiharkan pelbagai perbezaan saiz n; Bilangan operasi; Kemas kini pertama nilai D [i] dengan nilai sebelumnya; Indeks saya perlu ditingkatkan; Kita perlu melakukan operasi (b [i] - d [i]) lebih banyak; Meningkatkan julat saya ke i + k dengan keperluan; Semak jika i + k adalah indeks sah; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void find_minimum_operations ( int n , int [ ] b , int k ) { int [ ] d = new int [ n + 1 ] ; int i , operations = 0 , need ; for ( i = 0 ; i < n ; i ++ ) { if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; } if ( b [ i ] > d [ i ] ) { operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ; d [ i ] += need ; if ( i + k <= n ) { d [ i + k ] -= need ; } } } Console . Write ( operations ) ; } public static void Main ( string [ ] args ) { int n = 5 ; int [ ] b = { 1 , 2 , 3 , 4 , 5 } ; int k = 2 ; find_minimum_operations ( n , b , k ) ; } }"}
{"text": "Bilangan cara memotong matriks supaya atleast satu sel diisi dalam setiap bahagian | C # pelaksanaan untuk mencari bilangan cara untuk memotong matriks ke dalam bahagian -bahagian k sehingga setiap bahagian mempunyai atleast satu sel yang dipenuhi; Berfungsi untuk mencari bilangan cara untuk memotong matriks ke bahagian k supaya setiap bahagian mempunyai atleast satu sel yang dipenuhi; Gelung untuk mencari awalan jumlah matriks yang diberikan; dp (r, c, 1) = 1 jika anggapan [r] lain 0; Gelung untuk melangkah ke atas jadual DP matriks yang diberikan; Semak jika boleh dipotong secara mendatar pada R1, sekurang -kurangnya satu epal dalam matriks (r, c) -> r1, c - 1; Semak jika kita boleh memotong secara menegak di C1, sekurang -kurangnya satu epal dalam matriks (r, c) -> r - 1, c1; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int ways ( int [ , ] arr , int K ) { int R = arr . GetLength ( 0 ) ; int C = arr . GetLength ( 1 ) ; int [ , ] preSum = new int [ R , C ] ; for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { preSum [ r , c ] = arr [ r , c ] ; if ( r + 1 < R ) preSum [ r , c ] += preSum [ r + 1 , c ] ; if ( c + 1 < C ) preSum [ r , c ] += preSum [ r , c + 1 ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r , c ] -= preSum [ r + 1 , c + 1 ] ; } } int [ , , ] dp = new int [ K + 1 , R , C ] ; for ( int k = 1 ; k <= K ; k ++ ) { for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k , r , c ] = ( preSum [ r , c ] > 0 ) ? 1 : 0 ; } else { dp [ k , r , c ] = 0 ; for ( int r1 = r + 1 ; r1 < R ; r1 ++ ) { if ( preSum [ r , c ] - preSum [ r1 , c ] > 0 ) dp [ k , r , c ] += dp [ k - 1 , r1 , c ] ; } for ( int c1 = c + 1 ; c1 < C ; c1 ++ ) { if ( preSum [ r , c ] - preSum [ r , c1 ] > 0 ) dp [ k , r , c ] += dp [ k - 1 , r , c1 ] ; } } } } } return dp [ K , 0 , 0 ] ; } public static void Main ( string [ ] args ) { int [ , ] arr = { { 1 , 0 , 0 } , { 1 , 1 , 1 } , { 0 , 0 , 0 } } ; int k = 3 ; Console . WriteLine ( ways ( arr , k ) ) ; } }"}
{"text": "Produk semua subset saiz saiz k menggunakan unsur -unsur yang indeksnya membahagikan k sepenuhnya | C # pelaksanaan pendekatan di atas; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang; Fungsi iteratif untuk mengira (NCR) % p dan simpan dalam f [n, r]; Jika j> saya kemudian c (i, j) = 0; Jika IIS sama dengan j maka c (i, j) = 1; Fungsi mengira jawapan akhir; Memulakan ans; x adalah kiraan kejadian arr [i] dalam set yang berbeza sedemikian rupa sehingga indeks arr [i] dalam set tersebut membahagikan k sepenuhnya. ; Mencari kiraan arr [i] dengan meletakkannya di indeks yang membahagikan k sepenuhnya; Oleh teorem Fermat; Kod pemacu", "code": "using System ; class GFG { static int p = 1000000007 ; static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static void nCr ( int n , int p , int [ , ] f , int m ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( j > i ) { f [ i , j ] = 0 ; } else if ( j == 0 j == i ) { f [ i , j ] = 1 ; } else { f [ i , j ] = ( f [ i - 1 , j ] + f [ i - 1 , j - 1 ] ) % p ; } } } } static void ProductOfSubsets ( int [ ] arr , int n , int m ) { int [ , ] f = new int [ n + 1 , 100 ] ; nCr ( n , p - 1 , f , m ) ; Array . Sort ( arr ) ; long ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int x = 0 ; for ( int j = 1 ; j <= m ; j ++ ) { if ( m % j == 0 ) { x = ( x + ( f [ n - i - 1 , m - j ] * f [ i , j - 1 ] ) % ( p - 1 ) ) % ( p - 1 ) ; } } ans = ( ( ans * power ( arr [ i ] , x , p ) ) % p ) ; } Console . Write ( ans + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 5 , 7 , 9 , 3 } ; int K = 4 ; int N = arr . Length ; ProductOfSubsets ( arr , N , K ) ; } }"}
{"text": "Bilangan cara untuk menulis n sebagai jumlah k non | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan cara untuk menulis n sebagai jumlah kaum non - negatif; Permulaan [,] array dp; Hanya 1 cara untuk memilih nilai dengan jumlah k; Jumlah permulaan; Mengira cara dari negeri -negeri sebelumnya; Mengemas kini jumlah; Kembalikan cara yang dibaca semula; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int countWays ( int n , int m ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 , i ] = 1 ; } int sum ; for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { sum = 0 ; for ( int k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 , k ] ; } dp [ i , j ] = sum ; } } return dp [ m , n ] ; } public static void Main ( String [ ] args ) { int N = 2 , K = 3 ; Console . Write ( countWays ( N , K ) ) ; } }"}
{"text": "Bilangan cara untuk menulis n sebagai jumlah k non | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan cara untuk menulis n sebagai jumlah kaum non - negatif; Inisiasi dp [] [] array; Isi dp [] [] dengan jumlah = m; Melelehkan dp [] [] untuk mengisi array dp [] []; Keadaan untuk lajur pertama; Lain mengisi dp [] [] dengan jumlah sehingga (i, j); Jika sampai ke akhir, maka kembalikan nilai; Mengemas kini pada indeks semasa; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int countWays ( int n , int m ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 , i ] = 1 ; if ( i != 0 ) { dp [ 1 , i ] += dp [ 1 , i - 1 ] ; } } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i , j ] = dp [ i - 1 , j ] ; } else { dp [ i , j ] = dp [ i - 1 , j ] ; if ( i == m && j == n ) { return dp [ i , j ] ; } dp [ i , j ] += dp [ i , j - 1 ] ; } } } return Int32 . MinValue ; } public static void Main ( ) { int N = 2 , K = 3 ; Console . Write ( countWays ( N , K ) ) ; } }"}
{"text": "Susunan terpanjang sedemikian rupa sehingga setiap elemen dalam berikutnya dibentuk dengan mengalikan elemen sebelumnya dengan perdana | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk prima pra -pra; Kaedah ayak untuk memeriksa sama ada perdana atau tidak; Gandaan; Pra -simpan semua prima; Berfungsi untuk mencari berikutnya; Peta hash; Hubungi fungsi untuk menyimpan prima; Memulakan elemen terakhir dengan 1 kerana itu adalah yang mungkin; Melangkah dari belakang dan cari usus; Dapatkan nombor; Inisialisasi DP [i] sebagai 1 sebagai elemen hanya akan saya dalam berikutnya. ; Melangkah dalam semua prima dan berlipat ganda untuk mendapatkan elemen seterusnya; Elemen seterusnya jika didarabkan dengannya; Jika melebihi elemen terakhir maka pecah; Jika nombor ada dalam array; Dapatkan unsur maksimum yang paling maksimum; Hash elemen; Cari Utahan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public static void SieveOfEratosthenes ( int MAX , List < int > primes ) { Boolean [ ] prime = new Boolean [ MAX + 1 ] ; for ( int i = 0 ; i < MAX + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) primes . Add ( i ) ; } } public static int findLongest ( int [ ] A , int n ) { Dictionary < int , int > mpp = new Dictionary < int , int > ( ) ; List < int > primes = new List < int > ( ) ; SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; mpp . Add ( A [ n - 1 ] , n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int num = A [ i ] ; dp [ i ] = 1 ; foreach ( int it in primes ) { int xx = num * it ; if ( xx > A [ n - 1 ] ) break ; else if ( mpp . ContainsKey ( xx ) && mpp [ xx ] != 0 ) { dp [ i ] = Math . Max ( dp [ i ] , 1 + dp [ mpp [ xx ] ] ) ; } } if ( mpp . ContainsKey ( A [ i ] ) ) mpp [ A [ i ] ] = i ; else mpp . Add ( A [ i ] , i ) ; } int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . Max ( ans , dp [ i ] ) ; return ans ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 2 , 5 , 6 , 12 , 35 , 60 , 385 } ; int n = a . Length ; Console . WriteLine ( findLongest ( a , n ) ) ; } }"}
{"text": "Bilangan rentetan binari panjang n dengan k bit set bersebelahan | C # Program untuk mencari bilangan rentetan bit panjang n dengan k bit set bersebelahan; Berfungsi untuk mencari bilangan rentetan bit panjang n dengan k bit set bersebelahan; Kes asas apabila kita membentuk rentetan panjang n; jika f (bit string) = k, hitung cara ini; Semak sama ada bit terakhir ditetapkan, jika ditetapkan maka hubungi indeks seterusnya dengan menambah kiraan bit bersebelahan lain, hubungi indeks seterusnya dengan nilai yang sama dari kiraan bit bersebelahan dan sama ada tetapkan bit pada indeks semasa atau biarkan ia tetap tidak tersembunyi; Tetapkan bit pada CurrentIndex; tidak jelas sedikit pada currentIndex; Kod pemacu; Jumlah cara = (cara dengan meletakkan bit 1 st 1 + cara dengan meletakkan bit 1 sebagai 0)", "code": "using System ; class GFG { static int waysToKAdjacentSetBits ( int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) { if ( currentIndex == n ) { if ( adjacentSetBits == k ) return 1 ; return 0 ; } int noOfWays = 0 ; if ( lastBit == 1 ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( lastBit != 1 ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } return noOfWays ; } public static void Main ( ) { int n = 5 , k = 2 ; int totalWays = waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ; Console . WriteLine ( \" Number ▁ of ▁ ways ▁ = ▁ \" + totalWays ) ; } }"}
{"text": "Jumlah produk semua gabungan diambil (1 hingga n) pada satu masa | C # Program untuk mencari jumlah semua kombinasi Takne (1 hingga N) pada satu masa menggunakan pengaturcaraan dinamik; Cari array Jumlah Postfix; Ubah suai array supaya kita tidak perlu mengira produk yang diperoleh sebelum ini; Mencari jumlah semua gabungan yang diambil 1 hingga n pada satu masa; Jumlah yang diambil 1 pada masa hanya jumlah 1 - n; untuk jumlah produk untuk semua kombinasi; mencari array postfix; Jumlah produk yang diambil i + 1 pada satu masa; Ubah suai array untuk masalah bertindih; Kod pemandu; menyimpan nombor dari 1 hingga n; Memanggil AllCombination", "code": "using System ; class GFG { static void postfix ( int [ ] a , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) { a [ i - 1 ] = a [ i - 1 ] + a [ i ] ; } } static void modify ( int [ ] a , int n ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i - 1 ] = i * a [ i ] ; } } static void allCombination ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i ; } Console . WriteLine ( \" f ( 1 ) ▁ - - > ▁ \" + sum ) ; for ( int i = 1 ; i < n ; i ++ ) { postfix ( a , n - i + 1 ) ; sum = 0 ; for ( int j = 1 ; j <= n - i ; j ++ ) { sum += ( j * a [ j ] ) ; } Console . WriteLine ( \" f ( \" + ( i + 1 ) + \" ) ▁ - - > ▁ \" + sum ) ; modify ( a , n ) ; } } public static void Main ( String [ ] args ) { int n = 5 ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = i + 1 ; } allCombination ( a , n ) ; } }"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Program untuk mencari tangga n - menggunakan saiz langkah 1 atau 2 atau 3 .; Mengembalikan kiraan cara untuk mencapai tangga N - menggunakan 1 atau 2 atau 3 langkah. ; Fungsi pemacu", "code": "using System ; public class GfG { public static int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( findStep ( n ) ) ; } }"}
{"text": "Masalah Partition | DP | Penyelesaian C # rekursif untuk masalah partition; Fungsi utiliti yang kembali benar jika terdapat subset arr [] dengan matahari sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah elemen dalam array; Jika jumlahnya ganjil, tidak ada dua subset dengan jumlah yang sama; Cari jika terdapat subset dengan jumlah yang sama dengan separuh daripada jumlah keseluruhan; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static bool isSubsetSum ( int [ ] arr , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ; return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; } static bool findPartition ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; return isSubsetSum ( arr , n , sum / 2 ) ; } public static void Main ( ) { int [ ] arr = { 3 , 1 , 5 , 9 , 12 } ; int n = arr . Length ; if ( findPartition ( arr , n ) == true ) Console . Write ( \" Can ▁ be ▁ divided ▁ into ▁ two ▁ \" + \" subsets ▁ of ▁ equal ▁ sum \" ) ; else Console . Write ( \" Can ▁ not ▁ be ▁ divided ▁ into ▁ \" + \" two ▁ subsets ▁ of ▁ equal ▁ sum \" ) ; } }"}
{"text": "Masalah Partition | DP | Program C # berasaskan pengaturcaraan dinamik untuk masalah partition; Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah semua elemen; Memulakan array bahagian sebagai 0; Isi jadual partition dengan cara bawah; Unsur yang akan dimasukkan dalam jumlah tidak boleh lebih besar daripada jumlahnya; Semak jika jumlah - arr [i] boleh dibentuk dari subset menggunakan elemen sebelum indeks I; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static bool findPartiion ( int [ ] arr , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool [ ] part = new bool [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = false ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ sum / 2 ] ; } static void Main ( ) { int [ ] arr = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = 6 ; if ( findPartiion ( arr , n ) == true ) Console . WriteLine ( \" Can ▁ be ▁ divided ▁ into ▁ two ▁ \" + \" subsets ▁ of ▁ equal ▁ sum \" ) ; else Console . WriteLine ( \" Can ▁ not ▁ be ▁ divided ▁ into ▁ \" + \" two ▁ subsets ▁ of ▁ equal ▁ sum \" ) ; } }"}
{"text": "Koefisien binomial | DP | C # Program untuk pendekatan di atas; Berfungsi untuk mencari pekali binomial; Mendapatkan penyongsangan modular untuk semua nombor dari 2 hingga R berkenaan dengan M di sini M = 1000000007; untuk 1 / (r!) Bahagian; untuk (n) * (n - 1) * (n - 2) * ... * (n - r + 1) bahagian; Kod pemacu", "code": "using System ; public class GFG { static int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long m = 1000000007 ; long [ ] inv = new long [ r + 1 ] ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ ( int ) ( m % i ) ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( int ) ( ( ( ans % m ) * ( inv [ i ] % m ) ) % m ) ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( int ) ( ( ( ans % m ) * ( i % m ) ) % m ) ; } return ans ; } public static void Main ( String [ ] args ) { int n = 5 , r = 2 ; Console . Write ( \" Value ▁ of ▁ C ( \" + n + \" , ▁ \" + r + \" ) ▁ is ▁ \" + binomialCoeff ( n , r ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Semak sama ada mungkin untuk mencapai (x, y) dari (1, 1) dengan langkah -langkah yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari GCD dua nombor; Kes asas; Berulang; Berfungsi untuk mencetak jawapan; GCD X dan Y; Jika GCD adalah kuasa 2; Kod pemacu; Diberikan x dan y; Panggilan fungsi", "code": "using System ; class GFG { public static int gcd ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a % b == 0 ) return b ; return gcd ( b , a % b ) ; } static void printAnswer ( int x , int y ) { int val = gcd ( x , y ) ; if ( ( val & ( val - 1 ) ) == 0 ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } public static void Main ( ) { int x = 4 ; int y = 7 ; printAnswer ( x , y ) ; } }"}
{"text": "Cari elemen dalam matriks yang dihasilkan oleh peraturan yang diberikan | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan elemen dalam lajur RTH dan lajur CTH dari matriks yang diperlukan; Keadaan untuk separuh bawah matriks; Keadaan jika elemen berada di baris pertama; Memulakan elemen AP dalam baris R; Perbezaan umum AP dalam baris r; Kedudukan elemen untuk mencari di AP dalam baris r; Kod pemacu", "code": "using System ; class GFG { static int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * ( int ) ( Math . Pow ( 2 , ( r - 2 ) ) ) ; int d = ( int ) ( Math . Pow ( 2 , ( r - 1 ) ) ) ; c = c - r ; int element = a + d * c ; return element ; } public static void Main ( String [ ] args ) { int N = 4 , R = 3 , C = 4 ; Console . WriteLine ( getElement ( N , R , C ) ) ; } }"}
{"text": "Cari nombor terkecil yang dibentuk dengan memasukkan digit yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk memasukkan x dalam n dan mengembalikan rentetan nilai minimum; Pembolehubah untuk menyimpan panjang rentetan n; Pembolehubah untuk menunjukkan kedudukan di mana x mesti ditambah; Jika rentetan yang diberikan n mewakili nilai negatif; X mesti diletakkan pada indeks terakhir di mana lebih besar daripada n [i]; Untuk nombor positif, x mesti diletakkan pada indeks terakhir di mana ia lebih kecil daripada n [i]; Masukkan x pada kedudukan itu; return rentetan; Kod pemacu; diberikan input; panggilan fungsi", "code": "using System ; class GFG { static String MinValue ( string number , int x ) { int length = number . Length ; int position = length + 1 ; if ( number [ 0 ] == ' - ' ) { for ( int i = number . Length - 1 ; i >= 1 ; -- i ) { if ( ( number [ i ] - 48 ) < x ) { position = i ; } } } else { for ( int i = number . Length - 1 ; i >= 0 ; -- i ) { if ( ( number [ i ] - 48 ) > x ) { position = i ; } } } number = number . Substring ( 0 , position ) + x + number . Substring ( position , number . Length ) ; return number . ToString ( ) ; } public static void Main ( ) { string number = \"89\" ; int x = 1 ; Console . WriteLine ( MinValue ( number , x ) ) ; } }"}
{"text": "Semak jika perwakilan perpuluhan rentetan binari yang diberikan dapat dibahagikan dengan k atau tidak | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa nombor binari yang boleh dibahagikan oleh k; Array Poweroftwo akan menyimpan pow (2, i) % k; Memulakan elemen pertama dalam array; Menyimpan setiap nilai pow (2, i) % k dalam array; Untuk menyimpan baki; Melangkah sehingga n; Jika bit semasa ialah 1; Mengemas kini REM; Jika benar -benar boleh dibahagikan; Jika tidak sepenuhnya dibahagi; Kod pemacu; Diberikan input; panjang rentetan s; Panggilan fungsi", "code": "using System ; class GFG { public static String divisibleByk ( String s , int n , int k ) { int [ ] poweroftwo = new int [ n ] ; poweroftwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) { poweroftwo [ i ] = ( poweroftwo [ i - 1 ] * ( 2 % k ) ) % k ; } int rem = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ n - i - 1 ] == '1' ) { rem += ( poweroftwo [ i ] ) ; rem %= k ; } } if ( rem == 0 ) { return \" Yes \" ; } else return \" No \" ; } public static void Main ( String [ ] args ) { String s = \"1010001\" ; int k = 9 ; int n = s . Length ; Console . Write ( divisibleByk ( s , n , k ) ) ; } }"}
{"text": "Pecahkan rentetan binari supaya kiraan 0 s dan 1 s dalam substring kiri dan kanan adalah maksimum | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari jumlah maksimum kiraan 0 s di substring kiri dan kiraan 1 s dalam substring kanan dengan memisahkan rentetan; Kedai mengira 1 s dalam rentetan binari; Melintasi rentetan binari; Jika watak semasa adalah '1'; Kemas kini cntone; Kedai kiraan 0 s; Kedai kiraan 1 s; Kedai maksimum jumlah kiraan 0 s dan 1 s dengan memisahkan rentetan; Melintasi rentetan binari; Jika watak semasa adalah '0'; Mengemas kini sifar; Jika watak semasa adalah '1'; Mengemas kini satu; Kemas kini res; Kod pemacu", "code": "using System ; public class GFG { static int maxSumbySplittingString ( String str , int N ) { int cntOne = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '1' ) { cntOne ++ ; } } int zero = 0 ; int one = 0 ; int res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( str [ i ] == '0' ) { zero ++ ; } else { one ++ ; } res = Math . Max ( res , zero + cntOne - one ) ; } return res ; } public static void Main ( String [ ] args ) { String str = \"00111\" ; int N = str . Length ; Console . Write ( maxSumbySplittingString ( str , N ) ) ; } }"}
{"text": "Mengira penyingkiran pasangan yang diperlukan untuk kosongkan semua berikutnya Parenthesis Balanced | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mencari kiraan maksimum pasangan yang diperlukan untuk dikeluarkan supaya rentetan seterusnya tidak mengandungi sebarang kurungan yang sah; Kedai kiraan pasangan kurungan seimbang; Kedai -kedai mengira kurungan seimbang; Kedai mengira kurungan seimbang kecil; Kedai kiraan kurungan seimbang persegi; Melangkah ke atas aksara rentetan; Mengemas kini cntcurly; Kemas kini CNTSML; Kemas kini CNTSQR; Mengemas kini cntcurly; Kemas kini CNTPairs; Kemas kini CNTSML; Kemas kini CNTPairs; Kemas kini CNTSML; Kemas kini CNTPairs; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "using System ; class GFG { static void cntBalancedParenthesis ( String s , int N ) { int cntPairs = 0 ; int cntCurly = 0 ; int cntSml = 0 ; int cntSqr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' { ' ) { cntCurly ++ ; } else if ( s [ i ] == ' ( ' ) { cntSml ++ ; } else if ( s [ i ] == ' [ ' ) { cntSqr ++ ; } else if ( s [ i ] == ' } ' && cntCurly > 0 ) { cntCurly -- ; cntPairs ++ ; } else if ( s [ i ] == ' ) ' && cntSml > 0 ) { cntSml -- ; cntPairs ++ ; } else if ( s [ i ] == ' ] ' && cntSqr > 0 ) { cntSqr -- ; cntPairs ++ ; } } Console . WriteLine ( cntPairs ) ; } static public void Main ( ) { String s = \" { ( } ) \" ; int N = s . Length ; cntBalancedParenthesis ( s , N ) ; } }"}
{"text": "Count of Strings yang tidak mengandungi persimpangan arka | C # Program untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada terdapat persimpangan arka atau tidak; Melintasi rentetan s; Masukkan semua elemen dalam timbunan satu demi satu; Ekstrak elemen teratas; Pop keluar elemen teratas; Semak sama ada elemen atas adalah sama dengan elemen yang muncul; Jika tidak; Sekiranya timbunan kosong; Fungsi untuk memeriksa sama ada terdapat persimpangan arka atau tidak untuk pelbagai rentetan yang diberikan; Kedai kiraan rentetan tidak mempunyai persimpangan arka; Berulang melalui array; Panjang setiap rentetan; Panggilan fungsi; Cetak kiraan yang dikehendaki; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int arcIntersection ( String S , int len ) { Stack < char > stk = new Stack < char > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { stk . Push ( S [ i ] ) ; if ( stk . Count >= 2 ) { char temp = stk . Peek ( ) ; stk . Pop ( ) ; if ( stk . Peek ( ) == temp ) { stk . Pop ( ) ; } else { stk . Push ( temp ) ; } } } if ( stk . Count == 0 ) return 1 ; return 0 ; } static void countString ( String [ ] arr , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int len = arr [ i ] . Length ; count += arcIntersection ( arr [ i ] , len ) ; } Console . Write ( count + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { String [ ] arr = { \"0101\" , \"0011\" , \"0110\" } ; int N = arr . Length ; countString ( arr , N ) ; } }"}
{"text": "Semak jika perwakilan perpuluhan rentetan binari boleh dibahagikan dengan 9 atau tidak | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk menukar rentetan binari ke dalam perwakilan oktal; Kedai perwakilan binari nilai perpuluhan [0 - 7]; Menyimpan nilai perpuluhan rentetan binari [0 - 7]; Kedai panjang s; Kemas kini s; Kemas kini s; Kemas kini n; Kedai perwakilan oktal rentetan binari; Melintasi rentetan binari; Kedai 3 aksara berturut -turut rentetan binari; Tambah perwakilan oktal temp; Fungsi untuk memeriksa sama ada rentetan binari boleh dibahagikan dengan 9 atau tidak; Kedai perwakilan oktal S; Kedai jumlah unsur yang hadir pada kedudukan ganjil OCT; Kedai jumlah unsur yang hadir pada kedudukan ganjil OCT; Kedai panjang OCT; Melintasi rentetan OCT; Mengemas kini oddsum; Melintasi rentetan OCT; Kemas kini Evensum; Kedai perwakilan oktal 9; Jika nilai mutlak (oddsum - evensum) boleh dibahagikan dengan Okt_9; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static String ConvertequivalentBase8 ( String S ) { Dictionary < String , char > mp = new Dictionary < String , char > ( ) ; mp . Add ( \"000\" , '0' ) ; mp . Add ( \"001\" , '1' ) ; mp . Add ( \"010\" , '2' ) ; mp . Add ( \"011\" , '3' ) ; mp . Add ( \"100\" , '4' ) ; mp . Add ( \"101\" , '5' ) ; mp . Add ( \"110\" , '6' ) ; mp . Add ( \"111\" , '7' ) ; int N = S . Length ; if ( N % 3 == 2 ) { S = \"0\" + S ; } else if ( N % 3 == 1 ) { S = \"00\" + S ; } N = S . Length ; String oct = \" \" ; for ( int i = 0 ; i < N ; i += 3 ) { String temp = S . Substring ( 0 , N ) ; if ( mp . ContainsKey ( temp ) ) oct += mp [ temp ] ; } return oct ; } static String binString_div_9 ( String S , int N ) { String oct = \" \" ; oct = ConvertequivalentBase8 ( S ) ; int oddSum = 0 ; int evenSum = 0 ; int M = oct . Length ; for ( int i = 0 ; i < M ; i += 2 ) oddSum += ( oct [ i ] - '0' ) ; for ( int i = 1 ; i < M ; i += 2 ) { evenSum += ( oct [ i ] - '0' ) ; } int Oct_9 = 11 ; if ( Math . Abs ( oddSum - evenSum ) % Oct_9 == 0 ) { return \" Yes \" ; } return \" No \" ; } public static void Main ( String [ ] args ) { String S = \"1010001\" ; int N = S . Length ; Console . WriteLine ( binString_div_9 ( S , N ) ) ; } }"}
{"text": "Kos minimum untuk mengeluarkan ruang antara aksara rentetan dengan menyusun semula aksara | C # Program untuk mengumpulkan watak -watak rentetan dalam kos minimum; Fungsi untuk mengira kos minimum; Menyimpan kos minimum; Menyimpan kiraan watak yang dijumpai; Menyimpan kiraan ruang kosong yang dijumpai; Menyimpan kiraan jumlah aksara; Jika kiraan aksara sama dengan 1; Melangkah ke atas rentetan; Pertimbangkan watak sebelumnya bersama -sama dengan watak semasa; Sekiranya tidak bersama sudah; Tambah kos untuk mengumpulkannya bersama -sama; Meningkatkan kiraan watak yang dijumpai; Jika tidak; Meningkatkan kiraan ruang yang dijumpai; Mengembalikan jumlah kos yang diperoleh; Kod pemacu", "code": "using System ; class GFG { static int min_cost ( String S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; foreach ( char c in S . ToCharArray ( ) ) if ( c == ' ▁ ' ) count ++ ; int n = S . Length - count ; if ( n == 1 ) return cost ; foreach ( char inn in S . ToCharArray ( ) ) { if ( inn != ' ▁ ' ) { if ( B != 0 ) { cost += Math . Min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; } public static void Main ( String [ ] args ) { String S = \" ▁ @ TABSYMBOL $ \" ; Console . WriteLine ( min_cost ( S ) ) ; } }"}
{"text": "Kurangkan kos untuk menggantikan semua vokal rentetan yang diberikan oleh vokal tunggal | C # Program untuk pendekatan di atas; Fungsi yang kembali benar jika watak yang diberikan adalah vokal; Berfungsi untuk mengembalikan kos minimum untuk menukar semua vokal rentetan kepada satu; Kedai mengira vokal masing -masing; Melangkah melalui rentetan; Jika vokal ditemui; Kirakan kos; Mengembalikan kos minimum; Kod pemacu", "code": "using System ; class GFG { static bool isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; else return false ; } static int minCost ( String S ) { int cA = 0 ; int cE = 0 ; int cI = 0 ; int cO = 0 ; int cU = 0 ; for ( int i = 0 ; i < S . Length ; i ++ ) { if ( isVowel ( S [ i ] ) ) { cA += Math . Abs ( S [ i ] - ' a ' ) ; cE += Math . Abs ( S [ i ] - ' e ' ) ; cI += Math . Abs ( S [ i ] - ' i ' ) ; cO += Math . Abs ( S [ i ] - ' o ' ) ; cU += Math . Abs ( S [ i ] - ' u ' ) ; } } return Math . Min ( Math . Min ( Math . Min ( Math . Min ( cA , cE ) , cI ) , cO ) , cU ) ; } public static void Main ( String [ ] args ) { String S = \" geeksforgeeks \" ; Console . WriteLine ( minCost ( S ) ) ; } }"}
{"text": "Menjana rentetan yang semua k | C # program untuk menghasilkan rentetan yang substrings panjang k concatenates untuk membentuk rentetan yang diberikan; Berfungsi untuk mengembalikan rentetan yang diperlukan; Melepasi rentetan yang diberikan; Tambah watak pertama setiap substring panjang k; Pertimbangkan semua watak dari substring terakhir; Kod pemacu", "code": "using System ; class GFG { public static void decode_String ( String str , int K ) { String ans = \" \" ; for ( int i = 0 ; i < str . Length ; i += K ) ans += str [ i ] ; for ( int i = str . Length - ( K - 1 ) ; i < str . Length ; i ++ ) ans += str [ i ] ; Console . WriteLine ( ans ) ; } public static void Main ( String [ ] args ) { int K = 3 ; String str = \" abcbcscsesesesd \" ; decode_String ( str , K ) ; } }"}
{"text": "Lexicographically terkecil k | C # Program untuk mencari substring panjang k - panjang terkecil yang mengandungi bilangan vokal maksimum; Fungsi yang mencetak substring panjang K - panjang terkecil yang mengandungi bilangan vokal maksimum; Simpan panjang rentetan; Memulakan array jumlah awalan; Gelung melalui rentetan untuk membuat array Sum Prefix; Simpan 1 pada indeks jika ia adalah vokal; Jika tidak, simpan 0; Proses array awalan; Memulakan pembolehubah untuk menyimpan kiraan maksimum vokal; Memulakan pembolehubah untuk menyimpan substring dengan kiraan maksimum vokal; Gelung melalui array awalan; Simpan kiraan vokal semasa; Kemas kini hasil jika kiraan semasa lebih besar daripada kiraan maksimum; Kemas kini substring terkecil secara lexicographically jika kiraan semasa adalah sama dengan kiraan maksimum; Mengembalikan hasilnya; Kod pemacu", "code": "using System ; class GFG { static string maxVowelSubString ( string str , int K ) { int N = str . Length ; int [ ] pref = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) pref [ i ] = 1 ; else pref [ i ] = 0 ; if ( i != 0 ) pref [ i ] += pref [ i - 1 ] ; } int maxCount = pref [ K - 1 ] ; string res = str . Substring ( 0 , K ) ; for ( int i = K ; i < N ; i ++ ) { int currCount = pref [ i ] - pref [ i - K ] ; if ( currCount > maxCount ) { maxCount = currCount ; res = str . Substring ( i - K + 1 , K ) ; } else if ( currCount == maxCount ) { string temp = str . Substring ( i - K + 1 , K ) ; if ( string . Compare ( temp , res ) == - 1 ) res = temp ; } } return res ; } public static void Main ( ) { string str = \" ceebbaceeffo \" ; int K = 3 ; Console . Write ( maxVowelSubString ( str , K ) ) ; } }"}
{"text": "Decode rentetan yang dikodkan dengan algoritma yang diberikan | C # pelaksanaan pendekatan; Berfungsi untuk menyahkod dan mencetak rentetan asal; Untuk menyimpan rentetan yang dikodkan; Mendapatkan elemen pertengahan; Menyimpan elemen pertama rentetan pada kedudukan median; Jika panjangnya, kemudian simpan elemen kedua juga; K mewakili bilangan aksara yang telah disimpan dalam C []; Jika panjang rentetan ganjil; Jika ia juga; Cetak rentetan decoded; Kod pemacu", "code": "using System ; class GFG { static void decodeStr ( String str , int len ) { char [ ] c = new char [ len ] ; int med , pos = 1 , k ; if ( len % 2 == 1 ) med = len / 2 ; else med = len / 2 - 1 ; c [ med ] = str [ 0 ] ; if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ; if ( len % 2 == 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ; if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ; else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; } for ( int i = 0 ; i < len ; i ++ ) Console . Write ( c [ i ] ) ; } public static void Main ( String [ ] args ) { String str = \" ofrsgkeeeekgs \" ; int len = str . Length ; decodeStr ( str , len ) ; } }"}
{"text": "Mengira watak -watak yang berbeza dalam substring dengan julat yang diberikan untuk pertanyaan q | C # Program untuk pendekatan naif; Kaunter untuk mengira char yang berbeza; Array frekuensi memulakan untuk mengira aksara sebagai muncul dalam substring s [l: r]; Melangkah ke atas [L] ke S [r]; Meningkatkan kiraan S [i] watak dalam pelbagai frekuensi; Jika kekerapan mana -mana watak adalah> 0 maka kenaikan kaunter; Kod pemacu", "code": "using System ; class GFG { static void findCount ( String s , int L , int R ) { int distinct = 0 ; int [ ] frequency = new int [ 26 ] ; for ( int i = L ; i <= R ; i ++ ) { frequency [ s [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] > 0 ) distinct ++ ; } Console . Write ( distinct + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { String s = \" geeksforgeeksisa \" + \" computerscienceportal \" ; int queries = 3 ; int [ , ] Q = { { 0 , 10 } , { 15 , 18 } , { 12 , 20 } } ; for ( int i = 0 ; i < queries ; i ++ ) findCount ( s , Q [ i , 0 ] , Q [ i , 1 ] ) ; } }"}
{"text": "String yang diperoleh dengan membalikkan dan melengkapkan rentetan binari K kali | C # Program untuk melaksanakan operasi K pada rentetan dan cari rentetan yang diubah suai; Berfungsi untuk melaksanakan operasi k pada rentetan dan mencari rentetan yang diubah suai; Bilangan operasi terbalik; Bilangan operasi pelengkap; Jika rev adalah pariti ganjil; Jika pelengkap adalah pariti ganjil; Melengkapi setiap kedudukan; Kembalikan rentetan yang diubah suai; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static string ReverseComplement ( char [ ] s , int n , int k ) { int rev = ( k + 1 ) / 2 ; int complement = k - rev ; if ( rev % 2 == 1 ) s = reverse ( s ) ; if ( complement % 2 == 1 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) s [ i ] = '1' ; else s [ i ] = '0' ; } } return ( new string ( s ) ) ; } static char [ ] reverse ( char [ ] a ) { int i , n = a . Length ; char t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; } public static void Main ( ) { string str = \"10011\" ; int k = 5 ; int n = str . Length ; Console . Write ( ReverseComplement ( str . ToCharArray ( ) , n , k ) ) ; } }"}
{"text": "Semak jika ada permutasi rentetan adalah rentetan kim yang berulang kali | C # Pelaksanaan untuk memeriksa bahawa permutasi rentetan yang diberikan adalah K kali berulang rentetan; Fungsi untuk memeriksa bahawa permutasi rentetan yang diberikan adalah rentetan mengulangi kali; Jika panjang rentetan tidak dapat dibahagikan dengan k; Pelbagai kekerapan; Pada mulanya kekerapan setiap watak ialah 0; Pengkomputeran kekerapan setiap aksara dalam rentetan; Gelung untuk memeriksa kekerapan setiap watak rentetan itu boleh dibahagikan dengan k; Kod pemacu", "code": "using System ; class GFG { static bool repeatingString ( String s , int n , int k ) { if ( n % k != 0 ) { return false ; } int [ ] frequency = new int [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] ] ++ ; } int repeat = n / k ; for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; } public static void Main ( String [ ] args ) { String s = \" abcdcba \" ; int n = s . Length ; int k = 3 ; if ( repeatingString ( s , n , k ) ) { Console . Write ( \" Yes \" + \" STRNEWLINE \" ) ; } else { Console . Write ( \" No \" + \" STRNEWLINE \" ) ; } } }"}
{"text": "Cari dua digit terakhir yang hilang dari nombor telefon yang diberikan | C # pelaksanaan pendekatan; Berfungsi untuk mencari dua digit terakhir nombor dan mencetak nombor lengkap; Jumlah lapan digit nombor pertama; jika jumlah <10, maka dua digit adalah '0' dan nilai jumlah; Jika jumlah> 10, maka dua digit adalah nilai jumlah; Kod pemacu", "code": "using System ; class GFG { static void findPhoneNumber ( int n ) { int temp = n ; int sum = 0 ; while ( temp != 0 ) { sum += temp % 10 ; temp = temp / 10 ; } if ( sum < 10 ) Console . Write ( n + \"0\" + sum ) ; else Console . Write ( n + \" \" + sum ) ; } static public void Main ( ) { int n = 98765432 ; findPhoneNumber ( n ) ; } }"}
{"text": "Bilangan cara untuk memecah nombor binari supaya setiap bahagian boleh dibahagikan dengan 2 | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan yang diperlukan; Jika pemisahan tidak mungkin; Untuk menyimpan kiraan sifar; Mengira bilangan sifar; Kembalikan jawapan terakhir; Kod pemacu", "code": "using System ; class GFG { static int maxN = 20 ; static int maxM = 64 ; static int cntSplits ( String s ) { if ( s [ s . Length - 1 ] == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) c_zero += ( s [ i ] == '0' ) ? 1 : 0 ; return ( int ) Math . Pow ( 2 , c_zero - 1 ) ; } public static void Main ( String [ ] args ) { String s = \"10010\" ; Console . WriteLine ( cntSplits ( s ) ) ; } }"}
{"text": "Kira bilangan substrings rentetan yang terdiri daripada aksara yang sama | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan substrings aksara yang sama; Saiz rentetan; Memulakan kiraan kepada 1; Memulakan kiri ke 0 dan kanan ke 1 untuk melintasi rentetan; Memeriksa jika aksara berturut -turut adalah sama dan kenaikan kiraan; Apabila kita menghadapi watak yang berbeza; Meningkatkan hasilnya; Untuk mengulangi keseluruhan proses set kiri sama dan mengira pembolehubah kepada 1; Simpan nilai akhir hasil; Kod pemacu", "code": "using System ; class GFG { static void findNumbers ( String s ) { int n = s . Length ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) count ++ ; else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; Console . WriteLine ( result ) ; } public static void Main ( String [ ] args ) { String s = \" bbbcbb \" ; findNumbers ( s ) ; } }"}
{"text": "Program untuk menduplikasi vokal dalam rentetan | C # Program untuk mencetak rentetan dengan vokal pendua; Berfungsi untuk memeriksa vokal; Berfungsi untuk mendapatkan rentetan yang dihasilkan dengan vokal yang diduplikasi; Satu lagi rentetan untuk menyimpan rentetan yang dihasilkan; Gelung untuk memeriksa setiap watak; Kod pemacu; Cetak rentetan asal; Cetak tali yang dihasilkan", "code": "using System ; class GFG { static bool isVowel ( char ch ) { ch = char . ToUpper ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; } static String duplicateVowels ( String str ) { int t = str . Length ; String res = \" \" ; for ( int i = 0 ; i < t ; i ++ ) { if ( isVowel ( str [ i ] ) ) res += str [ i ] ; res += str [ i ] ; } return res ; } public static void Main ( String [ ] args ) { String str = \" helloworld \" ; Console . WriteLine ( \" Original ▁ String : ▁ \" + str ) ; String res = duplicateVowels ( str ) ; Console . WriteLine ( \" String ▁ with ▁ Vowels ▁ duplicated : ▁ \" + res ) ; } }"}
{"text": "Tukar rentetan ke integer menggunakan rekursi | C # pelaksanaan pendekatan; Fungsi rekursif untuk menukar rentetan ke integer; Jika nombor yang diwakili sebagai rentetan hanya mengandungi satu digit, maka mengembalikan nilainya; Panggilan rekursif untuk sub -rentetan bermula pada watak kedua; Digit pertama nombor; Digit pertama didarab dengan kuasa yang sesuai 10 dan kemudian tambah hasil rekursif sebagai contoh, xy = ((x * 10) + y); Kod pemacu", "code": "using System ; class GFG { static int stringToInt ( String str ) { if ( str . Length == 1 ) return ( str [ 0 ] - '0' ) ; double y = stringToInt ( str . Substring ( 1 ) ) ; double x = str [ 0 ] - '0' ; x = x * Math . Pow ( 10 , str . Length - 1 ) + y ; return ( int ) ( x ) ; } public static void Main ( String [ ] args ) { String str = \"1235\" ; Console . Write ( stringToInt ( str ) ) ; } }"}
{"text": "Susunan terpanjang dengan sekurang -kurangnya satu watak yang terdapat dalam setiap rentetan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan panjang sub -urutan terpanjang dengan sekurang -kurangnya satu watak biasa dalam setiap rentetan; Kira [0] akan menyimpan bilangan rentetan yang mengandungi 'A', kiraan [1] akan menyimpan bilangan rentetan yang mengandungi 'B' dan sebagainya. . ; Untuk setiap rentetan; Arus hash untuk menetapkan watak mana yang ada dalam rentetan semasa; Jika watak semasa muncul dalam rentetan maka kemas kini kiraannya; Kod pemacu", "code": "using System ; class GFG { static int MAX = 26 ; static int largestSubSeq ( string [ ] arr , int n ) { int [ ] count = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { string str = arr [ i ] ; bool [ ] hash = new bool [ MAX ] ; for ( int j = 0 ; j < str . Length ; j ++ ) { hash [ str [ j ] - ' a ' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } int max = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( max < count [ i ] ) max = count [ i ] ; } return max ; } public static void Main ( ) { string [ ] arr = { \" ab \" , \" bc \" , \" de \" } ; int n = arr . Length ; Console . WriteLine ( largestSubSeq ( arr , n ) ) ; } }"}
{"text": "Menjana nombor dengan operasi yang diberikan dan periksa sama ada Palindrome | C # pelaksanaan pendekatan; Fungsi yang kembali benar jika STR adalah palindrome; Fungsi yang mengembalikan benar jika rentetan yang dihasilkan adalah palindrome; sub mengandungi n sebagai rentetan; Kirakan jumlah digit; Ulangi substring sehingga panjang rentetan yang dihasilkan <jumlah; Jika panjang rentetan yang dihasilkan melebihi jumlah maka ambil substring dari 0 hingga jumlah - 1; Jika rentetan yang dihasilkan adalah palindrome; Kod pemacu", "code": "using System ; class GFG { static bool isPalindrome ( string str ) { int len = str . Length ; for ( int i = 0 ; i < len / 2 ; i ++ ) { if ( str [ i ] != str [ len - 1 - i ] ) return false ; } return true ; } static bool createStringAndCheckPalindrome ( int N ) { string sub = \" \" + N , res_str = \" \" ; int sum = 0 ; while ( N > 0 ) { int digit = N % 10 ; sum += digit ; N = N / 10 ; } while ( res_str . Length < sum ) res_str += sub ; if ( res_str . Length > sum ) res_str = res_str . Substring ( 0 , sum ) ; if ( isPalindrome ( res_str ) ) return true ; return false ; } public static void Main ( ) { int N = 10101 ; if ( createStringAndCheckPalindrome ( N ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Kurangkan panjang rentetan dengan mengeluarkan kejadian hanya satu aksara | C # Program untuk meminimumkan panjang rentetan dengan mengeluarkan kejadian hanya satu aksara; Berfungsi untuk mencari panjang minimum; Hitung kekerapan setiap abjad; Cari huruf dengan kekerapan maksimum; Tolak kekerapan aksara dari panjang rentetan; Kod pemacu", "code": "using System ; class GFG { static int minimumLength ( String s ) { int maxOcc = 0 , n = s . Length ; int [ ] arr = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; } public static void Main ( String [ ] args ) { String str = \" afddewqd \" ; Console . WriteLine ( minimumLength ( str ) ) ; } }"}
{"text": "Keluarkan semua aksara selain Alphabets dari String | C # Program untuk menghapuskan semua watak yang lain kemudian Alphabets; berfungsi untuk mengeluarkan aksara dan mencetak rentetan baru; Mencari watak yang nilai ASCII jatuh di bawah julat ini; memadamkan fungsi untuk memadamkan watak; Kod pemacu", "code": "using System ; class GFG { static void removeSpecialCharacter ( string s ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] < ' A ' s [ i ] > ' Z ' && s [ i ] < ' a ' s [ i ] > ' z ' ) { s = s . Remove ( i , 1 ) ; i -- ; } } Console . Write ( s ) ; } public static void Main ( ) { string s = \" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? \" ; removeSpecialCharacter ( s ) ; } }"}
{"text": "Keluarkan semua aksara selain Alphabets dari String | C # Program untuk menghapuskan semua watak yang lain kemudian Alphabets; berfungsi untuk mengeluarkan aksara dan mencetak rentetan baru; Menyimpan hanya aksara yang sah; kod pemacu", "code": "using System ; public class GFG { static void removeSpecialCharacter ( String str ) { char [ ] s = str . ToCharArray ( ) ; int j = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } Console . WriteLine ( String . Join ( \" \" , s ) . Substring ( 0 , j ) ) ; } public static void Main ( ) { String s = \" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? \" ; removeSpecialCharacter ( s ) ; } }"}
{"text": "Cari watak berulang yang hadir terlebih dahulu dalam rentetan | C # Program untuk mencari watak pertama yang diulang; Ini adalah kaedah O (n ^ 2); Kod pemacu", "code": "using System ; class GFG { static int findRepeatFirstN2 ( string s ) { int p = - 1 , i , j ; for ( i = 0 ; i < s . Length ; i ++ ) { for ( j = i + 1 ; j < s . Length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; } static public void Main ( ) { string str = \" geeksforgeeks \" ; int pos = findRepeatFirstN2 ( str ) ; if ( pos == - 1 ) Console . WriteLine ( \" Not ▁ found \" ) ; else Console . WriteLine ( str [ pos ] ) ; } }"}
{"text": "Cetak watak dan frekuensi mereka mengikut urutan kejadian | C # pelaksanaan untuk mencetak aksara dan frekuensi dalam rangka kejadiannya; Simpan semua watak dan frekuensi mereka dalam kamus; Cetak watak dan frekuensi mereka dalam susunan yang sama penampilan mereka; Cetak hanya jika watak ini tidak dicetak sebelum ini; Kod pemacu", "code": "using System ; using System . Collections ; using System . Collections . Generic ; class GFG { public static void prCharWithFreq ( string s ) { Dictionary < char , int > d = new Dictionary < char , int > ( ) ; foreach ( char i in s ) { if ( d . ContainsKey ( i ) ) { d [ i ] ++ ; } else { d [ i ] = 1 ; } } foreach ( char i in s ) { if ( d [ i ] != 0 ) { Console . Write ( i + d [ i ] . ToString ( ) + \" ▁ \" ) ; d [ i ] = 0 ; } } } public static void Main ( string [ ] args ) { string s = \" geeksforgeeks \" ; prCharWithFreq ( s ) ; } }"}
{"text": "Kira bilangan rentetan (diperbuat daripada r, g dan b) menggunakan kombinasi yang diberikan | C # Program untuk mengira bilangan rentetan yang mungkin dengan aksara N. ; Berfungsi untuk mengira bilangan rentetan; Menyimpan faktorial nombor sehingga n untuk pengiraan selanjutnya; Cari nilai yang akan ditambah; Buat semua kemungkinan kombinasi R, B dan G untuk nilai yang tinggal; Kirakan permutasi setiap gabungan satu demi satu dan tambahkannya. ; Kembali Jumlah No. rentetan / permutasi; Kod pemandu", "code": "using System ; class GFG { static int possibleStrings ( int n , int r , int b , int g ) { int [ ] fact = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; } public static void Main ( ) { int n = 4 , r = 2 ; int b = 0 , g = 1 ; Console . WriteLine ( possibleStrings ( n , r , b , g ) ) ; } }"}
{"text": "Keluarkan bilangan minimum aksara supaya dua rentetan menjadi anagram | C # Program untuk mencari bilangan minimum aksara yang akan dikeluarkan untuk membuat dua rentetan anagram. ; fungsi untuk mengira bilangan minimum aksara yang akan dikeluarkan untuk membuat dua rentetan anagram; Buat array hash untuk kedua -dua rentetan dan hitung kekerapan setiap aksara; Mengira kekerapan setiap aksara dalam rentetan pertama; Mengira kekerapan setiap aksara dalam rentetan kedua; TRAVERSE COUNT TRAVSE untuk mencari bilangan aksara yang akan dikeluarkan; Kod pemacu", "code": "using System ; class GFG { static int remAnagram ( string str1 , string str2 ) { int [ ] count1 = new int [ 26 ] ; int [ ] count2 = new int [ 26 ] ; for ( int i = 0 ; i < str1 . Length ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . Length ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . Abs ( count1 [ i ] - count2 [ i ] ) ; return result ; } public static void Main ( ) { string str1 = \" bcadeh \" , str2 = \" hea \" ; Console . Write ( remAnagram ( str1 , str2 ) ) ; } }"}
{"text": "Semak jika rentetan mempunyai semua aksara dengan kekerapan yang sama dengan satu variasi yang dibenarkan | C # Program untuk memeriksa sama ada rentetan boleh dibuat sah dengan mengeluarkan paling banyak 1 aksara. ; Dengan mengandaikan hanya aksara kes yang lebih rendah; Untuk memeriksa rentetan S boleh ditukar kepada rentetan yang sah dengan mengeluarkan kurang daripada atau sama dengan satu aksara. ; Freq []: Menyimpan kekerapan setiap aksara rentetan; Cari watak pertama dengan kekerapan bukan sifar; Cari watak dengan kekerapan yang berbeza daripada Freq1. ; Jika kita mendapati kekerapan bukan sifar ketiga atau kiraan kedua -dua frekuensi menjadi lebih daripada 1, maka kembali palsu; } else jika kita mencari non -sifar non -sifar ketiga; Jika tuduhan kedua -dua frekuensi lebih daripada 1; Kembali benar jika kita sampai di sini; Kod pemacu", "code": "using System ; public class GFG { static int CHARS = 26 ; static bool isValidString ( String str ) { int [ ] freq = new int [ CHARS ] ; int i = 0 ; for ( i = 0 ; i < str . Length ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } int freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) { count_freq1 ++ ; } else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) { count_freq1 ++ ; } if ( freq [ k ] == freq2 ) { count_freq2 ++ ; { return false ; } } if ( count_freq1 > 1 && count_freq2 > 1 ) { return false ; } } return true ; } public static void Main ( ) { String str = \" abcbc \" ; if ( isValidString ( str ) ) { Console . WriteLine ( \" YES \" ) ; } else { Console . WriteLine ( \" NO \" ) ; } } }"}
{"text": "Semak jika rentetan mempunyai semua aksara dengan kekerapan yang sama dengan satu variasi yang dibenarkan | C # Program untuk memeriksa sama ada rentetan boleh dibuat sah dengan mengeluarkan paling banyak 1 aksara menggunakan hashMap. ; Untuk memeriksa rentetan S boleh ditukar kepada rentetan variasi; Run Loop Borang 0 hingga panjang rentetan; pengisytiharan pembolehubah; jika pertama adalah benar daripada kenaikan countofval1; jika kedua adalah benar daripada kenaikan countofval2; Kod pemacu", "code": "using System ; using System . Collections . Generic ; public class AllCharsWithSameFrequencyWithOneVarAllowed { public static bool checkForVariation ( String str ) { if ( str == null str . Length != 0 ) { return true ; } Dictionary < char , int > map = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( map . ContainsKey ( str [ i ] ) ) map [ str [ i ] ] = map [ str [ i ] ] + 1 ; else map . Add ( str [ i ] , 1 ) ; } bool first = true , second = true ; int val1 = 0 , val2 = 0 ; int countOfVal1 = 0 , countOfVal2 = 0 ; foreach ( KeyValuePair < char , int > itr in map ) { int i = itr . Key ; if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; } if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } } public static void Main ( String [ ] args ) { Console . WriteLine ( checkForVariation ( \" abcbc \" ) ) ; } }"}
{"text": "Pasangan rentetan lengkap dalam dua set rentetan | C # Pelaksanaan untuk mencari pasangan rentetan lengkap. ; Mengembalikan kiraan pasangan lengkap dari set [0 .. n - 1] dan set2 [0 .. m - 1]; Pertimbangkan semua pasangan kedua -dua rentetan; Buat penggabungan pasangan semasa; Mengira frekuensi semua aksara dalam rentetan yang disatukan. ; Jika kekerapan mana -mana watak tidak lebih besar daripada 0, maka pasangan ini tidak lengkap. ; Kod pemacu", "code": "using System ; class GFG { static int countCompletePairs ( string [ ] set1 , string [ ] set2 , int n , int m ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { string concat = set1 [ i ] + set2 [ j ] ; int [ ] frequency = new int [ 26 ] ; for ( int k = 0 ; k < concat . Length ; k ++ ) { frequency [ concat [ k ] - ' a ' ] ++ ; } int l ; for ( l = 0 ; l < 26 ; l ++ ) { if ( frequency [ l ] < 1 ) { break ; } } if ( l == 26 ) { result ++ ; } } } return result ; } static public void Main ( ) { string [ ] set1 = { \" abcdefgh \" , \" geeksforgeeks \" , \" lmnopqrst \" , \" abc \" } ; string [ ] set2 = { \" ijklmnopqrstuvwxyz \" , \" abcdefghijklmnopqrstuvwxyz \" , \" defghijklmnopqrstuvwxyz \" } ; int n = set1 . Length ; int m = set2 . Length ; Console . Write ( countCompletePairs ( set1 , set2 , n , m ) ) ; } }"}
{"text": "Pasangan rentetan lengkap dalam dua set rentetan | C # Program untuk mencari kiraan pasangan lengkap; Mengembalikan kiraan pasangan lengkap dari set [0 .. n - 1] dan set2 [0 .. m - 1]; con_s1 [i] akan menyimpan integer yang set bit mewakili kehadiran / ketiadaan aksara dalam rentetan set1 [i]. Begitu juga con_s2 [i] akan menyimpan integer yang set bit mewakili kehadiran / ketiadaan aksara dalam rentetan set2 [i]; Proses semua rentetan dalam set1 []; memulakan semua bit ke 0; Menetapkan Kod ASCII Char S [i] [J] hingga 1 dalam integer yang dimampatkan. ; Proses semua rentetan dalam SET2 []; memulakan semua bit ke 0; Menetapkan Kod ASCII Char S [i] [J] hingga 1 dalam integer yang dimampatkan. ; Menetapkan pembolehubah yang semua 26 (0 ... 25) bit ditetapkan kepada 1; Sekarang pertimbangkan setiap pasangan integer dalam con_s1 [] dan con_s2 [] dan periksa sama ada pasangan itu selesai. ; Jika semua bit ditetapkan, rentetan selesai! ; Kod pemacu", "code": "using System ; class GFG { static int countCompletePairs ( String [ ] set1 , String [ ] set2 , int n , int m ) { int result = 0 ; int [ ] con_s1 = new int [ n ] ; int [ ] con_s2 = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { con_s1 [ i ] = 0 ; for ( int j = 0 ; j < set1 [ i ] . Length ; j ++ ) { con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] [ j ] - ' a ' ) ) ; } } for ( int i = 0 ; i < m ; i ++ ) { con_s2 [ i ] = 0 ; for ( int j = 0 ; j < set2 [ i ] . Length ; j ++ ) { con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] [ j ] - ' a ' ) ) ; } } long complete = ( 1 << 26 ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) { result ++ ; } } } return result ; } public static void Main ( String [ ] args ) { String [ ] set1 = { \" abcdefgh \" , \" geeksforgeeks \" , \" lmnopqrst \" , \" abc \" } ; String [ ] set2 = { \" ijklmnopqrstuvwxyz \" , \" abcdefghijklmnopqrstuvwxyz \" , \" defghijklmnopqrstuvwxyz \" } ; int n = set1 . Length ; int m = set2 . Length ; Console . WriteLine ( countCompletePairs ( set1 , set2 , n , m ) ) ; } }"}
{"text": "Cari semua rentetan yang sepadan dengan corak tertentu dalam kamus | C # Program untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam corak dipetakan secara unik kepada watak dalam kamus; Fungsi untuk mengekodkan rentetan yang diberikan; untuk setiap watak dalam rentetan yang diberikan; Sekiranya watak itu berlaku untuk kali pertama, berikan nombor unik seterusnya kepada char itu; tambah nombor yang berkaitan dengan watak semasa ke dalam rentetan output; Berfungsi untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam corak dipetakan secara unik kepada watak dalam kamus; Len adalah panjang corak; encode rentetan; untuk setiap perkataan dalam pelbagai kamus; Jika saiz corak sama dengan saiz kata kamus semasa dan kedua -dua corak dan perkataan mempunyai hash yang sama, cetak perkataan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; public class GFG { static String encodeString ( String str ) { Dictionary < char , int > map = new Dictionary < char , int > ( ) ; String res = \" \" ; int i = 0 ; char ch ; for ( int j = 0 ; j < str . Length ; j ++ ) { ch = str [ j ] ; if ( ! map . ContainsKey ( ch ) ) map . Add ( ch , i ++ ) ; res += map [ ch ] ; } return res ; } static void findMatchedWords ( String [ ] dict , String pattern ) { int len = pattern . Length ; String hash = encodeString ( pattern ) ; foreach ( String word in dict ) { if ( word . Length == len && encodeString ( word ) . Equals ( hash ) ) Console . Write ( word + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { String [ ] dict = { \" abb \" , \" abc \" , \" xyz \" , \" xyy \" } ; String pattern = \" foo \" ; findMatchedWords ( dict , pattern ) ; } }"}
{"text": "Cari semua rentetan yang sepadan dengan corak tertentu dalam kamus | C # Program untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam corak dipetakan secara unik kepada watak dalam kamus; Berfungsi untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam corak dipetakan secara unik kepada watak dalam kamus; Len adalah panjang corak; Untuk setiap perkataan dalam kamus; Kod pemacu", "code": "using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static bool check ( string pattern , string word ) { if ( pattern . Length != word . Length ) return false ; int [ ] ch = new int [ 128 ] ; int Len = word . Length ; for ( int i = 0 ; i < Len ; i ++ ) { if ( ch [ ( int ) pattern [ i ] ] == 0 ) { ch [ ( int ) pattern [ i ] ] = word [ i ] ; } else if ( ch [ ( int ) pattern [ i ] ] != word [ i ] ) { return false ; } } return true ; } static void findMatchedWords ( HashSet < string > dict , string pattern ) { int Len = pattern . Length ; string result = \" ▁ \" ; foreach ( string word in dict ) { if ( check ( pattern , word ) ) { result = word + \" ▁ \" + result ; } } Console . Write ( result ) ; } static void Main ( ) { HashSet < string > dict = new HashSet < string > ( new string [ ] { \" abb \" , \" abc \" , \" xyz \" , \" xyy \" } ) ; string pattern = \" foo \" ; findMatchedWords ( dict , pattern ) ; } }"}
{"text": "Kira perkataan dalam rentetan yang diberikan | C # Program untuk mengira jumlah perkataan dalam rentetan; Berfungsi untuk mengira jumlah perkataan dalam rentetan; Semak sama ada rentetan itu batal atau kosong kemudian kembali sifar; Menukar rentetan yang diberikan ke dalam array watak; Semak sama ada watak itu adalah huruf dan indeks array aksara tidak sama dengan akhir baris yang bermaksud, ia adalah perkataan dan set isword oleh benar; Semak sama ada watak itu bukan surat yang bermaksud terdapat ruang, maka kami menambah kata -kata dengan satu dan tetapkan isword dengan palsu; Semak perkataan terakhir ayat dan kenaikan kata WordCount oleh satu; Kembalikan jumlah perkataan dalam rentetan; Kod pemacu; Diberikan string str; Cetak hasilnya", "code": "using System ; public class GFG { static int countWords ( String str ) { if ( str == null ) { return 0 ; } int wordCount = 0 ; bool isWord = false ; int endOfLine = str . Length - 1 ; char [ ] ch = str . ToCharArray ( ) ; for ( int i = 0 ; i < ch . Length ; i ++ ) { if ( Char . IsLetter ( ch [ i ] ) && i != endOfLine ) { isWord = true ; } else if ( ! Char . IsLetter ( ch [ i ] ) && isWord ) { wordCount ++ ; isWord = false ; } else if ( Char . IsLetter ( ch [ i ] ) && i == endOfLine ) { wordCount ++ ; } } return wordCount ; } static public void Main ( ) { string str = \" One ▁ two TABSYMBOL three STRNEWLINE ▁ four TABSYMBOL five ▁ \" ; Console . WriteLine ( \" No ▁ of ▁ words ▁ : ▁ \" + countWords ( str ) ) ; } }"}
{"text": "Kata -kata terbalik dalam rentetan yang diberikan | C # kod untuk membalikkan rentetan; Membalikkan rentetan; Semak sama ada bilangan perkataan walaupun; Cari perkataan tengah; Bermula dari pertengahan mula menukar kata -kata di kedudukan jth dan kedudukan l - 1 - j; Semak sama ada bilangan perkataan adalah ganjil; Cari perkataan tengah; Bermula dari pertengahan mula menukar kata -kata di kedudukan jth dan kedudukan l - 1 - j; Mengembalikan kalimat terbalik; Kod pemacu", "code": "using System ; class GFG { public static String [ ] RevString ( String [ ] s , int l ) { if ( l % 2 == 0 ) { int j = l / 2 ; while ( j <= l - 1 ) { String temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } else { int j = ( l / 2 ) + 1 ; while ( j <= l - 1 ) { String temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } return s ; } public static void Main ( String [ ] args ) { String s = \" getting ▁ good ▁ at ▁ coding ▁ \" + \" needs ▁ a ▁ lot ▁ of ▁ practice \" ; String [ ] words = s . Split ( \" \\\\ s \" ) ; words = RevString ( words , words . Length ) ; s = String . Join ( \" ▁ \" , words ) ; Console . WriteLine ( s ) ; } }"}
{"text": "Laluan cetak dari akar ke semua nod dalam pokok binari yang lengkap | C # Program untuk mencetak jalan dari akar ke semua nod dalam pokok binari yang lengkap. ; Berfungsi untuk mencetak laluan semua nod nth node mewakili sebagai node node node yang diberikan mewakili sebagai nod kiri dan kanan; Keadaan asas jika nilai nod kth lebih besar maka nod nth maka nod kth bermakna tidak sah sehingga kami tidak menyimpannya ke dalam res hanya kami hanya kembali; Menyimpan nod ke res; Cetak jalan dari akar ke nod; Simpan jalan kiri pokok supaya kiri kita akan pergi nod (kthNode * 2); Jalan kanan pokok dan untuk betul kita akan pergi nod (kthnode * 2 + 1); Berfungsi untuk mencetak laluan dari akar ke semua nod; Res adalah untuk menyimpan jalan dari akar ke nod partikulat; Cetak jalan dari akar ke semua nod. Hujah ketiga 1 kerana kita perlu mempertimbangkan nod akar adalah 1; Kod pemacu; Diberikan nod; Cetak jalan dari akar ke semua nod.", "code": "using System ; using System . Collections . Generic ; class GFG { static void printPath ( List < int > res , int nThNode , int kThNode ) { if ( kThNode > nThNode ) return ; res . Add ( kThNode ) ; for ( int i = 0 ; i < res . Count ; i ++ ) Console . Write ( res [ i ] + \" ▁ \" ) ; Console . Write ( \" STRNEWLINE \" ) ; printPath ( res , nThNode , kThNode * 2 ) ; printPath ( res , nThNode , kThNode * 2 + 1 ) ; res . RemoveAt ( res . Count - 1 ) ; } static void printPathToCoverAllNodeUtil ( int nThNode ) { List < int > res = new List < int > ( ) ; printPath ( res , nThNode , 1 ) ; } public static void Main ( String [ ] args ) { int nThNode = 7 ; printPathToCoverAllNodeUtil ( nThNode ) ; } }"}
{"text": "Array Range Queries Untuk Mencari Nombor Armstrong Maksimum dengan Kemas Kini | C # kod untuk melaksanakan pendekatan di atas; Fungsi utiliti untuk mendapatkan indeks pertengahan julat yang diberikan. ; Fungsi yang kembali benar jika num adalah armstrong lain kembali palsu; Fungsi rekursif untuk mendapatkan jumlah nilai dalam julat array yang diberikan. Berikut adalah parameter untuk fungsi ini. st. Penunjuk ke nod pokok segmen. Indeks nod semasa dalam pokok segmen. SS & SE. Memulakan dan mengakhiri indeks segmen yang diwakili oleh nod semasa, i. e. , St [nod] L & R. Memulakan dan mengakhiri indeks pertanyaan pelbagai; Jika segmen nod ini benar -benar sebahagian daripada julat yang diberikan, maka kembalikan segmen maksimum. ; Jika segmen nod ini tidak tergolong dalam julat yang diberikan; Jika segmen nod ini sebahagiannya adalah sebahagian daripada julat yang diberikan; Fungsi rekursif untuk mengemas kini nod yang telah diberikan indeks dalam julatnya. Berikut adalah parameter ST, SS dan SE adalah sama seperti yang ditakrifkan di atas indeks. Indeks elemen yang akan dikemas kini. ; nilai kemas kini dalam array dan dalam pokok segmen; Kembalikan max elemen dalam julat dari indeks l (pertanyaan permulaan) ke r (ujung pertanyaan). ; Semak nilai input yang salah; Fungsi rekursif yang membina pokok segmen untuk array [ss. . se]. Si adalah indeks nod semasa dalam segmen Tree St; Jika terdapat satu elemen dalam array, simpannya dalam nod semasa pokok segmen dan kembali; Sekiranya terdapat lebih daripada satu elemen, maka berulang untuk subtrees kiri dan kanan dan simpan nilai maksimum dalam nod ini; Fungsi ke pokok segmen Cona dari array yang diberikan. Fungsi ini memperuntukkan memori untuk pokok segmen. ; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan ST; Mengembalikan pokok segmen yang dibina; Kod pemacu; Membina pokok segmen dari array yang diberikan; Cetak maksimum nilai dalam array dari indeks 1 hingga 3; Kemas kini: Tetapkan ARR [1] = 153 dan kemas kini nod pokok segmen yang sepadan. ; Cari max selepas nilai dikemas kini", "code": "using System ; class GFG { static int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } static bool isArmstrong ( int x ) { int n = String . Join ( \" \" , x ) . Length ; int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += ( int ) Math . Pow ( digit , n ) ; temp /= 10 ; } if ( sum1 == x ) return true ; return false ; } static int MaxUtil ( int [ ] st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return - 1 ; int mid = getMid ( ss , se ) ; return Math . Max ( MaxUtil ( st , ss , mid , l , r , 2 * node ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 1 ) ) ; } static void updateValue ( int [ ] arr , int [ ] st , int ss , int se , int index , int value , int node ) { if ( index < ss index > se ) { Console . Write ( \" Invalid ▁ Input \" + \" STRNEWLINE \" ) ; return ; } if ( ss == se ) { arr [ index ] = value ; if ( isArmstrong ( value ) ) st [ node ] = value ; else st [ node ] = - 1 ; } else { int mid = getMid ( ss , se ) ; if ( index >= ss && index <= mid ) updateValue ( arr , st , ss , mid , index , value , 2 * node ) ; else updateValue ( arr , st , mid + 1 , se , index , value , 2 * node + 1 ) ; st [ node ] = Math . Max ( st [ 2 * node + 1 ] , st [ 2 * node + 2 ] ) ; } return ; } static int getMax ( int [ ] st , int n , int l , int r ) { if ( l < 0 r > n - 1 l > r ) { Console . Write ( \" Invalid ▁ Input \" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; } static int constructSTUtil ( int [ ] arr , int ss , int se , int [ ] st , int si ) { if ( ss == se ) { if ( isArmstrong ( arr [ ss ] ) ) st [ si ] = arr [ ss ] ; else st [ si ] = - 1 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = Math . Max ( constructSTUtil ( arr , ss , mid , st , si * 2 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 1 ) ) ; return st [ si ] ; } static int [ ] constructST ( int [ ] arr , int n ) { int x = ( int ) ( Math . Ceiling ( Math . Log ( n ) ) ) ; int max_size = 2 * ( int ) Math . Pow ( 2 , x ) - 1 ; int [ ] st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } public static void Main ( String [ ] args ) { int [ ] arr = { 192 , 113 , 535 , 7 , 19 , 111 } ; int n = arr . Length ; int [ ] st = constructST ( arr , n ) ; Console . Write ( \" Maximum ▁ armstrong ▁ \" + \" number ▁ in ▁ given ▁ range ▁ = ▁ \" + getMax ( st , n , 1 , 3 ) + \" STRNEWLINE \" ) ; updateValue ( arr , st , 0 , n - 1 , 1 , 153 , 0 ) ; Console . Write ( \" Updated ▁ Maximum ▁ armstrong ▁ \" + \" number ▁ in ▁ given ▁ range ▁ = ▁ \" + getMax ( st , n , 1 , 3 ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Bilangan maksimum rantau di mana n non | C # Program untuk melaksanakan masalah di atas; Berfungsi untuk mencari bilangan maksimum kawasan di atas kapal terbang; Cetak bilangan maksimum kawasan; Kod pemacu", "code": "using System ; class GFG { static void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; Console . WriteLine ( num ) ; } public static void Main ( String [ ] args ) { int n = 10 ; maxRegions ( n ) ; } }"}
{"text": "Semak sama ada teka -teki jigsaw boleh diselesaikan atau tidak | C # Program untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada teka -teki jigsaw boleh diselesaikan atau tidak; Kes asas; Dengan meletakkan tab kosong sebagai rantai; Kod pemacu", "code": "using System ; class GFG { static void checkSolveable ( int n , int m ) { if ( n == 1 m == 1 ) Console . WriteLine ( \" YES \" ) ; else if ( m == 2 && n == 2 ) Console . WriteLine ( \" YES \" ) ; else Console . WriteLine ( \" NO \" ) ; } public static void Main ( ) { int n = 1 , m = 3 ; checkSolveable ( n , m ) ; } }"}
{"text": "Semak sama ada mungkin untuk mencapai (x, y) dari (1, 0) dengan langkah -langkah yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari GCD dua nombor A dan B; Kes asas; Recursif mencari GCD; Fungsi untuk memeriksa sama ada (x, y) boleh dicapai dari (1, 0) dari langkah yang diberikan; Jika GCD adalah 1, kemudian cetak \"Ya\"; Kod pemacu; Diberikan x dan y; Panggilan fungsi", "code": "using System ; class GFG { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; else return GCD ( b , a % b ) ; } static void check ( int x , int y ) { if ( GCD ( x , y ) == 1 ) { Console . WriteLine ( \" Yes \" ) ; } else { Console . WriteLine ( \" No \" ) ; } } public static void Main ( ) { int X = 2 , Y = 7 ; check ( X , Y ) ; } }"}
{"text": "Kebarangkalian fungsi ketat Euler dalam julat [l, r] untuk dibahagikan dengan m | C # Program untuk melaksanakan pendekatan di atas; Seieve of erotosthenes untuk mengira semua prima; Jika Perdana; Tandakan semua gandaannya sebagai bukan perdana; Fungsi untuk mencari kebarangkalian fungsi ketat Euler dalam julat tertentu; Memulakan dua tatasusunan dengan nilai dari L ke R untuk Totient Euler; Pengindeksan dari 0; Jika nombor semasa adalah perdana; Memeriksa jika saya adalah faktor utama nombor dalam julat l ke r; Kemas kini semua nombor yang mempunyai faktor utama i; Jika nombor dalam julat mempunyai faktor utama> matematik. Sqrt (nombor); Hitung mereka yang boleh dibahagikan dengan m; Mengembalikan hasilnya; Kod pemacu", "code": "using System ; class GFG { static readonly int size = 1000001 ; static void seiveOfEratosthenes ( int [ ] prime ) { prime [ 0 ] = 1 ; prime [ 1 ] = 0 ; for ( int i = 2 ; i * i < 1000001 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < 1000001 ; j += i ) { prime [ j ] = 1 ; } } } } static float probabiltyEuler ( int [ ] prime , int L , int R , int M ) { int [ ] arr = new int [ size ] ; int [ ] eulerTotient = new int [ size ] ; int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { eulerTotient [ i - L ] = i ; arr [ i - L ] = i ; } for ( int i = 2 ; i < 1000001 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = ( L / i ) * i ; j <= R ; j += i ) { if ( j - L >= 0 ) { eulerTotient [ j - L ] = eulerTotient [ j - L ] / i * ( i - 1 ) ; while ( arr [ j - L ] % i == 0 ) { arr [ j - L ] /= i ; } } } } } for ( int i = L ; i <= R ; i ++ ) { if ( arr [ i - L ] > 1 ) { eulerTotient [ i - L ] = ( eulerTotient [ i - L ] / arr [ i - L ] ) * ( arr [ i - L ] - 1 ) ; } } for ( int i = L ; i <= R ; i ++ ) { if ( ( eulerTotient [ i - L ] % M ) == 0 ) { count ++ ; } } return ( float ) ( 1.0 * count / ( R + 1 - L ) ) ; } public static void Main ( String [ ] args ) { int [ ] prime = new int [ size ] ; seiveOfEratosthenes ( prime ) ; int L = 1 , R = 7 , M = 3 ; Console . Write ( probabiltyEuler ( prime , L , R , M ) ) ; } }"}
{"text": "Permainan pembahagi ganjil terbesar untuk memeriksa pemain mana yang menang | C # Pelaksanaan untuk mencari permainan divisior ganjil terbesar untuk memeriksa pemain mana yang menang; Berfungsi untuk mencari permainan divisior ganjil terbesar untuk memeriksa pemain mana yang menang; Semak jika n == 1 maka pemain 2 akan menang; Semak jika n == 2 atau n adalah ganjil; Manakala n lebih besar daripada k dan dibahagikan dengan 2 terus meningkatkan val; Gelung untuk mencari pembahagi ganjil yang paling hebat; Periksa sama ada n adalah kuasa 2; Semak sama ada CNT bukanlah pemain yang menang 1; Kod pemacu", "code": "using System ; class GFG { public static void findWinner ( int n , int k ) { int cnt = 0 ; if ( n == 1 ) Console . Write ( \" No \" ) ; else if ( ( n & 1 ) != 0 n == 2 ) Console . Write ( \" Yes \" ) ; else { int tmp = n ; int val = 1 ; while ( tmp > k && tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) Console . Write ( \" No \" ) ; else if ( n / tmp == 2 && cnt == 1 ) Console . Write ( \" No \" ) ; else Console . Write ( \" Yes \" ) ; } } public static void Main ( string [ ] args ) { int n = 1 , k = 1 ; findWinner ( n , k ) ; } }"}
{"text": "Cari semua nombor sehingga N yang kedua -dua pentagonal dan heksagon | C # Program pendekatan di atas; Berfungsi untuk mencetak nombor sehingga kedua -dua pentagonal dan nombor heksagon; Kirakan nombor pentagonal saya; Semak sama ada nombor pentagonal PN adalah heksagon atau tidak; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void pen_hex ( long n ) { long pn = 1 ; for ( long i = 1 ; ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; double seqNum = ( 1 + Math . Sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == ( long ) ( seqNum ) ) { Console . Write ( pn + \" , ▁ \" ) ; } } } public static void Main ( string [ ] args ) { long N = 1000000 ; pen_hex ( N ) ; } }"}
{"text": "Semak jika baris | C # Pelaksanaan untuk memeriksa sama ada baris - Perintah utama traversal matriks adalah palindrome atau tidak; Fungsi untuk memeriksa sama ada baris - perintah utama traversal matriks adalah palindrome; Gelung untuk memeriksa sama ada matriks adalah matriks adalah palindrome atau tidak; Kod pemacu", "code": "using System ; class GFG { static bool isPal ( int [ , ] a , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i , j ] != a [ n - 1 - i , m - 1 - j ] ) return false ; } } return true ; } public static void Main ( String [ ] args ) { int n = 3 , m = 3 ; int [ , ] a = { { 1 , 2 , 3 } , { 4 , 5 , 4 } , { 3 , 2 , 1 } } ; if ( isPal ( a , n , m ) ) { Console . Write ( \" YES \" + \" STRNEWLINE \" ) ; } else { Console . Write ( \" NO \" + \" STRNEWLINE \" ) ; } } }"}
{"text": "Cari nombor terkecil yang jumlah digitnya adalah n | C # Program untuk mencari nombor terkecil yang jumlah digit juga n; Berfungsi untuk mendapatkan jumlah digit; Berfungsi untuk mencari nombor terkecil yang jumlah digit juga n; Memeriksa jika nombor mempunyai jumlah digit = n; Kod pemacu", "code": "using System ; class GFG { static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } static void smallestNumber ( int N ) { int i = 1 ; while ( 1 != 0 ) { if ( getSum ( i ) == N ) { Console . Write ( i ) ; break ; } i ++ ; } } public static void Main ( String [ ] args ) { int N = 10 ; smallestNumber ( N ) ; } }"}
{"text": "Nombor jarang | C # Pelaksanaan untuk memeriksa sama ada N adalah nombor yang jarang berlaku; Fungsi berulang untuk membalikkan digit NUM; Fungsi untuk memeriksa sama ada N adalah persegi sempurna; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Fungsi untuk memeriksa sama ada n adalah nombor yang jarang berlaku; Cari terbalik n; Nombor harus bukan palindromic; Kod pemacu", "code": "using System ; class GFG { static int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static bool isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; } static bool isRare ( int N ) { int reverseN = reversDigits ( N ) ; if ( reverseN == N ) return false ; return isPerfectSquare ( N + reverseN ) && isPerfectSquare ( N - reverseN ) ; } public static void Main ( String [ ] args ) { int n = 65 ; if ( isRare ( n ) ) { Console . WriteLine ( \" Yes \" ) ; } else { Console . WriteLine ( \" No \" ) ; } } }"}
{"text": "Kira nombor dari julat yang faktor utama hanya 2 dan 3 menggunakan tatasusunan | Tetapkan 2 | C # Program untuk mengira unsur -unsur dalam julat [l, r] yang faktor utama hanya 2 dan 3 .; Fungsi yang akan mengira unsur -unsur dalam julat yang diberikan; Simpan kuasa semasa 2; Simpan kuasa semasa 3; Power23 [] akan menyimpan produk pasangan unsur -unsur Power2 dan Power3 yang <= r; Masukkan dalam Power23,] hanya jika Mul <= r; Simpan jawapan yang diperlukan; Cetak hasilnya; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void calc_ans ( int l , int r ) { List < int > power2 = new List < int > ( ) , power3 = new List < int > ( ) ; int mul2 = 1 ; while ( mul2 <= r ) { power2 . Add ( mul2 ) ; mul2 *= 2 ; } int mul3 = 1 ; while ( mul3 <= r ) { power3 . Add ( mul3 ) ; mul3 *= 3 ; } List < int > power23 = new List < int > ( ) ; for ( int x = 0 ; x < power2 . Count ; x ++ ) { for ( int y = 0 ; y < power3 . Count ; y ++ ) { int mul = power2 [ x ] * power3 [ y ] ; if ( mul == 1 ) continue ; if ( mul <= r ) power23 . Add ( mul ) ; } } int ans = 0 ; foreach ( int x in power23 ) { if ( x >= l && x <= r ) ans ++ ; } Console . Write ( ans + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { int l = 1 , r = 10 ; calc_ans ( l , r ) ; } }"}
{"text": "Count k panjangnya yang produknya juga | C # Pelaksanaan untuk mengira panjang K panjangnya yang produknya juga; Fungsi untuk mengira NCR; Mengembalikan faktorial n; Fungsi untuk mencari bilangan Kekuatan panjang K yang produknya adalah bilangannya; Mengira nombor ganjil dalam array; Kod pemacu", "code": "using System ; class GFG { static int nCr ( int n , int r ) { if ( r > n ) return 0 ; return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int countSubsequences ( int [ ] arr , int n , int k ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) countOdd ++ ; } int ans = nCr ( n , k ) - nCr ( countOdd , k ) ; return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 4 } ; int K = 1 ; int N = arr . Length ; Console . WriteLine ( countSubsequences ( arr , N , K ) ) ; } }"}
{"text": "Cari bit yang paling ketara dari nombor x dalam asas y | C # Program untuk mencari digit pertama X dalam asas y; Berfungsi untuk mencari digit pertama x dalam asas y; mengira bilangan digit x dalam asas y; Mencari digit pertama X dalam asas y; Kod pemacu", "code": "using System ; class GFG { static void first_digit ( int x , int y ) { int length = ( int ) ( Math . Log ( x ) / Math . Log ( y ) + 1 ) ; int first_digit = ( int ) ( x / Math . Pow ( y , length - 1 ) ) ; Console . Write ( first_digit ) ; } public static void Main ( ) { int X = 55 , Y = 3 ; first_digit ( X , Y ) ; } }"}
{"text": "Nombor Curzon | C # pelaksanaan pendekatan; Berfungsi untuk memeriksa sama ada nombor adalah nombor curzon atau tidak; Cari 2 ^ n + 1; Cari 2 * n + 1; Semak untuk pembahagian; Kod pemacu", "code": "using System ; class GFG { static void checkIfCurzonNumber ( long N ) { double powerTerm , productTerm ; powerTerm = Math . Pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } static public void Main ( ) { long N = 5 ; checkIfCurzonNumber ( N ) ; N = 10 ; checkIfCurzonNumber ( N ) ; } }"}
{"text": "Kiraan minimum nombor yang diperlukan berakhir dengan 7 hingga jumlah sebagai nombor tertentu | C # pelaksanaan pendekatan di atas; Fungsi untuk mengembalikan kiraan nombor minimum yang berakhir dengan 7 yang diperlukan supaya jumlah nombor ini adalah n; Hasharr [i] akan menyimpan nombor minimum yang berakhir dengan 7 supaya ia merangkumi jumlah yang berakhir dengan Digit I; Ia sentiasa mungkin untuk menulis nombor> 69 untuk menulis sebagai nombor yang berakhir dengan 7; Jika nombor itu sama dengan jumlah nombor minimum yang berakhir dengan 7; Kod pemacu", "code": "using System ; class GFG { static int minCount ( int n ) { int [ ] hasharr = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % 10 ] ; else { if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } } public static void Main ( String [ ] args ) { int n = 38 ; Console . WriteLine ( minCount ( n ) ) ; } }"}
{"text": "Program untuk mencetak corak segitiga binari yang diubahsuai | C # pelaksanaan untuk mencetak corak segi tiga binari yang diubah suai; Berfungsi untuk mencetak corak binari yang diubah suai; Gelung untuk melintasi baris; Gelung untuk melintasi nombor dalam setiap baris; Periksa sama ada J adalah 1 atau saya dalam cetakan kes 1; Lain cetak 0; Tukar kursor ke baris seterusnya selepas setiap baris; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void modifiedBinaryPattern ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) Console . Write ( 1 ) ; else Console . Write ( 0 ) ; } Console . WriteLine ( ) ; } } public static void Main ( ) { int n = 7 ; modifiedBinaryPattern ( n ) ; } }"}
{"text": "Cari bahagian sebenar dan khayalan nombor kompleks | C # Program untuk mencari bahagian sebenar dan khayalan nombor kompleks; Berfungsi untuk mencari bahagian sebenar dan khayalan nombor kompleks; panjang rentetan yang disimpan dalam pembolehubah L; pembolehubah untuk indeks pemisah; Menyimpan indeks ' +'; lain menyimpan indeks ' -'; Mencari bahagian sebenar nombor kompleks; Mencari bahagian khayalan nombor kompleks; Kod pemacu", "code": "using System ; class GFG { static void findRealAndImag ( String s ) { int l = s . Length ; int i ; if ( s . IndexOf ( ' + ' ) != - 1 ) { i = s . IndexOf ( ' + ' ) ; } else { i = s . IndexOf ( ' - ' ) ; } String real = s . Substring ( 0 , i ) ; String imaginary = s . Substring ( i + 1 , l - i - 2 ) ; Console . WriteLine ( \" Real ▁ part : ▁ \" + real ) ; Console . WriteLine ( \" Imaginary ▁ part : ▁ \" + imaginary ) ; } public static void Main ( String [ ] args ) { String s = \"3 + 4i \" ; findRealAndImag ( s ) ; } }"}
{"text": "Kuasa yang berbeza dari nombor n supaya jumlahnya sama dengan k | C # pelaksanaan untuk mencari kuasa yang berbeza N yang menambah sehingga k; Berfungsi untuk mengembalikan kuasa tertinggi n tidak melebihi k; Gelung untuk mencari kuasa tertinggi kurang daripada k; Memulakan PowerArray dengan semua 0. ; Berfungsi untuk mencetak kuasa yang berbeza n yang menambah sehingga k; Mendapatkan kuasa tertinggi N sebelum k; Untuk memeriksa sama ada kuasa digunakan dua kali atau tidak; Cetak - 1 jika kuasa digunakan dua kali; Jika kuasa tidak dikunjungi, maka tandakan kuasa seperti yang dikunjungi; Menurunkan nilai k; Mencetak kuasa N yang merangkumi K; Kod pemacu", "code": "using System ; public class GFG { static int highestPower ( int n , int k ) { int i = 0 ; int a = ( int ) Math . Pow ( n , i ) ; while ( a <= k ) { i += 1 ; a = ( int ) Math . Pow ( n , i ) ; } return i - 1 ; } static int [ ] b = new int [ 50 ] ; static int PowerArray ( int n , int k ) { while ( k > 0 ) { int t = highestPower ( n , k ) ; if ( b [ t ] > 0 ) { Console . Write ( - 1 ) ; return 0 ; } else b [ t ] = 1 ; k -= ( int ) Math . Pow ( n , t ) ; } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] > 0 ) { Console . Write ( i + \" , ▁ \" ) ; } } return 0 ; } public static void Main ( String [ ] args ) { int N = 3 ; int K = 40 ; PowerArray ( N , K ) ; } }"}
{"text": "Jumlah elemen dalam array yang mempunyai kekerapan komposit | C # Program untuk mencari jumlah elemen dalam array yang mempunyai kekerapan komposit; Berfungsi untuk membuat ayak untuk memeriksa prima; Jika komposit [p] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada komposit; Berfungsi untuk mengembalikan jumlah elemen dalam array yang mempunyai kekerapan komposit; Peta digunakan untuk menyimpan frekuensi elemen; Untuk menyimpan jumlah; Melintasi peta menggunakan iterators; Kira bilangan elemen yang mempunyai frekuensi komposit; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static readonly int N = 10005 ; static void SieveOfEratosthenes ( List < Boolean > composite ) { for ( int i = 0 ; i < N ; i ++ ) { composite . Insert ( i , false ) ; } for ( int p = 2 ; p * p < N ; p ++ ) { if ( ! composite [ p ] ) { for ( int i = p * 2 ; i < N ; i += p ) { composite . Insert ( i , true ) ; } } } } static int sumOfElements ( int [ ] arr , int n ) { List < Boolean > composite = new List < Boolean > ( ) ; for ( int i = 0 ; i < N ; i ++ ) composite . Add ( false ) ; SieveOfEratosthenes ( composite ) ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } int sum = 0 ; foreach ( KeyValuePair < int , int > it in mp ) { if ( composite [ it . Value ] ) { sum += ( it . Key ) ; } } return sum ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 1 , 1 , 1 , 3 , 3 , 2 , 4 } ; int n = arr . Length ; Console . Write ( sumOfElements ( arr , n ) ) ; } }"}
{"text": "Padam semua elemen kekerapan ganjil dari array | C # Program untuk menghilangkan semua elemen frekuensi ganjil dari array; Fungsi yang menghilangkan unsur -unsur yang mempunyai frekuensi ganjil dalam array; Buat peta untuk menyimpan kekerapan setiap elemen; Keluarkan unsur -unsur yang mempunyai frekuensi ganjil; Jika elemen mempunyai kekerapan ganjil maka lompat; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void remove ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( mp . ContainsKey ( arr [ i ] ) && mp [ arr [ i ] ] % 2 == 1 ) ) continue ; Console . Write ( arr [ i ] + \" , ▁ \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 } ; int n = arr . Length ; remove ( arr , n ) ; } }"}
{"text": "Memaksimumkan elemen pertama array supaya purata tetap tetap | C # Pelaksanaan untuk memaksimumkan elemen pertama array supaya purata array tetap tetap; Nilai maksimum elemen array pertama yang boleh dicapai; Pembolehubah untuk menyimpan jumlahnya; Gelung untuk mencari jumlah array; Nilai maksimum yang dikehendaki; Kod pemacu", "code": "using System ; class GFG { static void getmax ( int [ ] arr , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } Console . WriteLine ( Math . Min ( s , x ) ) ; } static void Main ( ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 4 } ; int x = 5 ; int arr_size = arr . Length ; getmax ( arr , arr_size , x ) ; } }"}
{"text": "Panjang minimum laluan terpendek segitiga | C # Program untuk menggambarkan masalah di atas; berfungsi untuk mendapatkan panjang minimum bahagian yang lebih pendek dari segitiga; melintasi setiap mata di atas kapal terbang; Jika jumlah mata lebih besar daripada yang sebelumnya, maksimum akan diganti; Cetak panjang; Kod pemacu; memulakan bilangan mata; mata di kapal terbang", "code": "using System ; class GFG { static void shortestLength ( int n , int [ ] x , int [ ] y ) { int answer = 0 ; int i = 0 ; while ( n != 0 && i < x . Length ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } Console . WriteLine ( \" Length ▁ - > ▁ \" + answer ) ; Console . WriteLine ( \" Path ▁ - > ▁ \" + \" ( ▁ 1 , ▁ \" + answer + \" ▁ ) \" + \" and ▁ ( ▁ \" + answer + \" , ▁ 1 ▁ ) \" ) ; } static public void Main ( ) { int n = 4 ; int [ ] x = new int [ ] { 1 , 4 , 2 , 1 } ; int [ ] y = new int [ ] { 4 , 1 , 1 , 2 } ; shortestLength ( n , x , y ) ; } }"}
{"text": "Berpotongan segi empat tepat apabila bawah | C # Program untuk mencari persegi persegi persegi dua segi empat tepat. ; berfungsi untuk mencari persegi persegi persegi dua segi empat tepat. ; memberikan titik kiri bawah persegi persegi persegi; memberikan titik kanan persegi persegi persegi; tiada persimpangan; memberikan titik kiri atas persegi persegi persegi; memberikan titik bawah persegi persegi persegi; Kod pemacu; bawah - kiri dan atas - sudut kanan segi empat tepat pertama; bawah - kiri dan atas - sudut kanan segi empat tepat pertama; panggilan fungsi", "code": "using System ; class GFG { static void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . Max ( x1 , x3 ) ; int y5 = Math . Max ( y1 , y3 ) ; int x6 = Math . Min ( x2 , x4 ) ; int y6 = Math . Min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { Console . WriteLine ( \" No ▁ intersection \" ) ; return ; } Console . Write ( \" ( \" + x5 + \" , ▁ \" + y5 + \" ) ▁ \" ) ; Console . Write ( \" ( \" + x6 + \" , ▁ \" + y6 + \" ) ▁ \" ) ; int x7 = x5 ; int y7 = y6 ; Console . Write ( \" ( \" + x7 + \" , ▁ \" + y7 + \" ) ▁ \" ) ; int x8 = x6 ; int y8 = y5 ; Console . Write ( \" ( \" + x8 + \" , ▁ \" + y8 + \" ) ▁ \" ) ; } public static void Main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ; FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; } }"}
{"text": "Cari Sudut Rectangle Menggunakan Poin Mid | C # Program untuk mencari titik sudut segi empat tepat menggunakan panjang dan titik tengah yang diberikan. ; Struktur untuk mewakili titik co -ordinate; Fungsi ini menerima dua mata dan panjang sisi segi empat tepat dan mencetak titik 4 sudut segi empat tepat; Rectangle mendatar; segi empat tepat menegak; segi empat tepat; Hitung cerun sisi; Kirakan anjakan di sepanjang paksi; Kod pemacu", "code": "using System ; class GFG { public class Point { public float x , y ; public Point ( ) { x = y = 0 ; } public Point ( float a , float b ) { x = a ; y = b ; } } ; static void printCorners ( Point p , Point q , float l ) { Point a = new Point ( ) , b = new Point ( ) , c = new Point ( ) , d = new Point ( ) ; if ( p . x == q . x ) { a . x = ( float ) ( p . x - ( l / 2.0 ) ) ; a . y = p . y ; d . x = ( float ) ( p . x + ( l / 2.0 ) ) ; d . y = p . y ; b . x = ( float ) ( q . x - ( l / 2.0 ) ) ; b . y = q . y ; c . x = ( float ) ( q . x + ( l / 2.0 ) ) ; c . y = q . y ; } else if ( p . y == q . y ) { a . y = ( float ) ( p . y - ( l / 2.0 ) ) ; a . x = p . x ; d . y = ( float ) ( p . y + ( l / 2.0 ) ) ; d . x = p . x ; b . y = ( float ) ( q . y - ( l / 2.0 ) ) ; b . x = q . x ; c . y = ( float ) ( q . y + ( l / 2.0 ) ) ; c . x = q . x ; } else { float m = ( p . x - q . x ) / ( q . y - p . y ) ; float dx = ( float ) ( ( l / Math . Sqrt ( 1 + ( m * m ) ) ) * 0.5 ) ; float dy = m * dx ; a . x = p . x - dx ; a . y = p . y - dy ; d . x = p . x + dx ; d . y = p . y + dy ; b . x = q . x - dx ; b . y = q . y - dy ; c . x = q . x + dx ; c . y = q . y + dy ; } Console . Write ( ( int ) a . x + \" , ▁ \" + ( int ) a . y + \" ▁ STRNEWLINE \" + ( int ) b . x + \" , ▁ \" + ( int ) b . y + \" STRNEWLINE \" + ( int ) c . x + \" , ▁ \" + ( int ) c . y + \" ▁ STRNEWLINE \" + ( int ) d . x + \" , ▁ \" + ( int ) d . y + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { Point p1 = new Point ( 1 , 0 ) , q1 = new Point ( 1 , 2 ) ; printCorners ( p1 , q1 , 2 ) ; Point p = new Point ( 1 , 1 ) , q = new Point ( - 1 , - 1 ) ; printCorners ( p , q , ( float ) ( 2 * Math . Sqrt ( 2 ) ) ) ; } }"}
{"text": "Kurangkan kos untuk mengubah suai array sedemikian rupa sehingga indeks mempunyai unsur -unsur dan sebaliknya | C # Program untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mengubah suai array mengikut kriteria yang diberikan; Mengira kedudukan yang salah dan juga unsur -unsur; Kiraan ganjil; Malah mengira; Kos menukar; Menurun kos selepas bertukar; Hanya pengurangan kos; Mengembalikan kos minimum dua kes; Kod pemacu", "code": "using System ; public class GFG { public static int minimumCost ( int [ ] arr , int N , int X , int Y ) { int even_count = 0 , odd_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) > 0 && ( i % 2 == 0 ) ) { odd_count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) > 0 ) { even_count ++ ; } } int cost1 = X * Math . Min ( odd_count , even_count ) ; int cost2 = Y * ( Math . Max ( odd_count , even_count ) - Math . Min ( odd_count , even_count ) ) ; int cost3 = ( odd_count + even_count ) * Y ; return Math . Min ( cost1 + cost2 , cost3 ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 5 , 3 , 7 , 2 , 1 } ; int X = 10 , Y = 2 ; int N = arr . Length ; Console . WriteLine ( minimumCost ( arr , N , X , Y ) ) ; } }"}
{"text": "Produk minimum elemen maksimum dan minimum ke atas semua subarray yang mungkin | C # Program untuk pendekatan di atas; Berfungsi untuk mencari produk minimum minimum dan maksimum di antara semua subarray yang mungkin; Kedai produk minimum yang dihasilkan; Melintasi array yang diberikan []; Min produk dari dua sepasang elemen berturut -turut; Mengembalikan nilai yang dihasilkan; Kod pemacu", "code": "using System ; public class GFG { static int findMinMax ( int [ ] a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . Length ; ++ i ) { min_val = Math . Min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; } public static void Main ( string [ ] args ) { int [ ] arr = { 6 , 4 , 5 , 6 , 2 , 4 , 1 } ; Console . WriteLine ( findMinMax ( arr ) ) ; } }"}
{"text": "Jumlah semua nod dengan nilai yang lebih kecil pada jarak k dari nod yang diberikan dalam BST | C # Program untuk pendekatan di atas; Struktur pokok; Pembina; Berfungsi untuk menambah nod ke jumlah di bawah nod sasaran; Kes asas; Jika nod jauh kth dicapai; Berulang untuk kiri dan subtrees kanan; Fungsi untuk mencari nod jauh dari nod sasaran, ia kembali - 1 jika nod sasaran tidak hadir di dalam pokok; Kes asas 1; Jika sasaran sama dengan akar. ; Berulang untuk subtree kiri; Pokok adalah BST jadi mengurangkan ruang carian; Semak jika nod sasaran ditemui di subtree kiri; Jika akar berada pada jarak k dari sasaran; Node kurang daripada sasaran akan hadir di sebelah kiri; Apabila nod tidak hadir di subtree kiri; Jika nod jauh kth dicapai; Node kurang daripada sasaran pada jarak k mungkin terdapat di pokok kiri; Jika sasaran tidak hadir di sebelah kiri atau di subtree kanan; Berfungsi untuk memasukkan nod dalam BST; Jika akar adalah batal; Masukkan data pada separuh kanan; Masukkan data di separuh kiri; Mengembalikan nod akar; Fungsi untuk mencari jumlah n nod jauh dari nod sasaran yang mempunyai nilai kurang daripada nod sasaran; Menyimpan jumlah nod yang mempunyai nilai <sasaran pada jarak k; Cetak jumlah yang dihasilkan; Kod pemacu; Buat pokok", "code": "using System ; public class GFG { static int sum ; public class TreeNode { public int data ; public TreeNode left ; public TreeNode right ; public TreeNode ( int data ) { this . data = data ; this . left = null ; this . right = null ; } } ; static void kDistanceDownSum ( TreeNode root , int k ) { if ( root == null k < 0 ) return ; if ( k == 0 ) { sum += root . data ; return ; } kDistanceDownSum ( root . left , k - 1 ) ; kDistanceDownSum ( root . right , k - 1 ) ; } static int kDistanceSum ( TreeNode root , int target , int k ) { if ( root == null ) return - 1 ; if ( root . data == target ) { kDistanceDownSum ( root . left , k - 1 ) ; return 0 ; } int dl = - 1 ; if ( target < root . data ) { dl = kDistanceSum ( root . left , target , k ) ; } if ( dl != - 1 ) { if ( dl + 1 == k ) sum += root . data ; return - 1 ; } int dr = - 1 ; if ( target > root . data ) { dr = kDistanceSum ( root . right , target , k ) ; } if ( dr != - 1 ) { if ( dr + 1 == k ) sum += root . data ; else kDistanceDownSum ( root . left , k - dr - 2 ) ; return 1 + dr ; } return - 1 ; } static TreeNode insertNode ( int data , TreeNode root ) { if ( root == null ) { TreeNode node = new TreeNode ( data ) ; return node ; } else if ( data > root . data ) { root . right = insertNode ( data , root . right ) ; } else if ( data <= root . data ) { root . left = insertNode ( data , root . left ) ; } return root ; } static void findSum ( TreeNode root , int target , int K ) { sum = 0 ; kDistanceSum ( root , target , K ) ; Console . Write ( sum ) ; } public static void Main ( String [ ] args ) { TreeNode root = null ; int N = 11 ; int [ ] tree = { 3 , 1 , 7 , 0 , 2 , 5 , 10 , 4 , 6 , 9 , 8 } ; for ( int i = 0 ; i < N ; i ++ ) { root = insertNode ( tree [ i ] , root ) ; } int target = 7 ; int K = 2 ; findSum ( root , target , K ) ; } }"}
{"text": "Cari item n yang diedarkan dari item tak terhingga jenis tak terhingga berdasarkan syarat -syarat yang diberikan | C # kod untuk pendekatan di atas; Berfungsi untuk mencari jenis item yang diberikan mengikut peraturan yang diberikan; Menyimpan kiraan item yang diberikan pada setiap langkah; Melangkah ke hari dari 1; Melewati jenis item pada hari itu; Count item yang diberikan hendaklah melebihi n; Kod pemacu", "code": "using System ; public class GFG { static int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } } static public void Main ( ) { int N = 10 ; Console . WriteLine ( itemType ( N ) ) ; } }"}
{"text": "Cari jumlah semua elemen array yang sama dari dua kuasa berturut -turut 2 | C # Program untuk pendekatan di atas; Berfungsi untuk mencetak jumlah elemen array yang sama dari dua kuasa berturut -turut 2; Menyimpan jumlah yang dihasilkan dari unsur -unsur array; Melintasi array arr []; Menyimpan kuasa 2 daripada nombor arr [i]; Menyimpan nombor yang kuasa 2 dan lebih rendah daripada atau sama dengan arr [i]; Menyimpan nombor yang kuasa 2 dan lebih besar daripada atau sama dengan arr [i]; Jika arr [i] - Lesservalue adalah sama seperti besar - arr [i]; Kenaikan res oleh arr [i]; Mengembalikan jumlah yang dihasilkan; Kod pemacu", "code": "using System ; class GFG { static int FindSum ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int power = ( int ) ( Math . Log ( arr [ i ] ) / Math . Log ( 2 ) ) ; int LesserValue = ( int ) Math . Pow ( 2 , power ) ; int LargerValue = ( int ) Math . Pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; } public static void Main ( ) { int [ ] arr = { 10 , 24 , 17 , 3 , 8 } ; int N = arr . Length ; Console . WriteLine ( FindSum ( arr , N ) ) ; } }"}
{"text": "Cari orang yang akan selesai terakhir | C # Program untuk pendekatan di atas; Berfungsi untuk mencari orang yang akan selesai terakhir; Untuk menjejaki baris dan lajur yang mempunyai 1; Baris dan lajur yang ada; Bilangan minimum pilihan yang kita ada; Jika bilangan pilihan ganjil; P1 akan selesai terakhir; Jika tidak, P2 akan selesai terakhir; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void findLast ( int [ , ] mat ) { int m = 3 ; int n = 3 ; HashSet < int > rows = new HashSet < int > ( ) ; HashSet < int > cols = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( mat [ i , j ] > 0 ) ) { rows . Add ( i ) ; cols . Add ( j ) ; } } } int avRows = m - rows . Count ; int avCols = n - cols . Count ; int choices = Math . Min ( avRows , avCols ) ; if ( ( choices & 1 ) != 0 ) Console . WriteLine ( \" P1\" ) ; else Console . WriteLine ( \" P2\" ) ; } static public void Main ( ) { int [ , ] mat = { { 1 , 0 , 0 } , { 0 , 0 , 0 } , { 0 , 0 , 1 } } ; findLast ( mat ) ; } }"}
{"text": "Jumlah perpuluhan yang merupakan perwakilan binari nombor semulajadi n pertama | C # Program untuk pendekatan di atas; Berfungsi untuk mencari jumlah nombor semulajadi N pertama yang diwakili dalam perwakilan binari; Menyimpan jumlah yang dihasilkan; Melangkah sehingga nilai n lebih besar daripada 0; Jika n kurang daripada 2; Simpan kedudukan MSB N; Iterat dalam julat [1, x] dan tambahkan sumbangan nombor dari 1 hingga (2 ^ x - 1); Kemas kini nilai CUR dan tambah; Tambah cur ke ans; Simpan nombor yang tinggal; Tambah sumbangan oleh MSB dengan bilangan yang tinggal; Lelaran seterusnya akan diulangi untuk 2 ^ x - 1; Cetak hasilnya; Kod pemacu", "code": "using System ; class GFG { const int MOD = 1000000007 ; static void sumOfBinaryNumbers ( int n ) { int ans = 0 ; int one = 1 ; while ( true ) { if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; } int x = ( int ) Math . Log ( n , 2 ) ; int cur = 0 ; int add = ( one << ( x - 1 ) ) ; for ( int i = 1 ; i <= x ; i ++ ) { cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; } ans = ( ans + cur ) % MOD ; int rem = n - ( one << x ) + 1 ; int p = ( int ) Math . Pow ( 10 , x ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ; n = rem - 1 ; } Console . WriteLine ( ans ) ; } public static void Main ( ) { int N = 3 ; sumOfBinaryNumbers ( N ) ; } }"}
{"text": "Nombor Fibonacci terdekat kepada N | C # Program untuk pendekatan di atas; Berfungsi untuk mencari nombor Fibonacci yang paling dekat dengan N; Kes asas; Memulakan syarat pertama & kedua siri Fibonacci; Simpan istilah ketiga; ITERATE Sehingga istilah ketiga kurang daripada atau sama dengan NUM; Kemas kini yang pertama; Kemas kini yang kedua; Mengemas kini yang ketiga; Simpan nombor Fibonacci yang mempunyai perbezaan yang lebih kecil dengan N; Cetak hasilnya; Kod pemacu", "code": "using System ; class GFG { static void nearestFibonacci ( int num ) { if ( num == 0 ) { Console . Write ( 0 ) ; return ; } int first = 0 , second = 1 ; int third = first + second ; while ( third <= num ) { first = second ; second = third ; third = first + second ; } int ans = ( Math . Abs ( third - num ) >= Math . Abs ( second - num ) ) ? second : third ; Console . Write ( ans ) ; } public static void Main ( string [ ] args ) { int N = 17 ; nearestFibonacci ( N ) ; } }"}
{"text": "Permutasi nombor semulajadi n pertama yang diberikan array sebagai array maksimum awalan | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada array awalan maksimum ANS [] sama dengan array arr []; Memulakan pembolehubah, maks; Melintasi array, ans []; Simpan nilai maksimum sehingga indeks i; Jika ia tidak sama dengan [i], maka kembali palsu; Sebaliknya kembali palsu; Berfungsi untuk mencari permutasi array yang array maksimum awalan yang sama dengan array yang diberikan []; Menyimpan permutasi yang diperlukan; Menyimpan indeks kejadian pertama unsur; Melintasi array a []; Jika A [i] tidak hadir di um, maka simpannya di um; Kemas kini Ans [i] ke [i]; Menyimpan nombor yang tidak disokong; Isi array, v []; Simpan indeks; Melintasi array, ans []; Isi V [J] di tempat -tempat di mana Ans [i] adalah 0; Semak sama ada array awalan maksimum permutasi semasa adalah sama dengan array yang diberikan []; Jika benar, cetak permutasi; Jika tidak, cetak - 1; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static bool checkPermutation ( int [ ] ans , int [ ] a , int n ) { int Max = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { Max = Math . Max ( Max , ans [ i ] ) ; if ( Max != a [ i ] ) return false ; } return true ; } static void findPermutation ( int [ ] a , int n ) { int [ ] ans = new int [ n ] ; Dictionary < int , int > um = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! um . ContainsKey ( a [ i ] ) ) { ans [ i ] = a [ i ] ; um [ a [ i ] ] = i ; } } List < int > v = new List < int > ( ) ; int j = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! um . ContainsKey ( i ) ) { v . Add ( i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 0 ) { ans [ i ] = v [ j ] ; j ++ ; } } if ( checkPermutation ( ans , a , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ans [ i ] + \" ▁ \" ) ; } } else Console . Write ( \" - 1\" ) ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 4 , 5 , 5 } ; int N = arr . Length ; findPermutation ( arr , N ) ; } }"}
{"text": "Kira pasangan elemen yang sama mungkin dengan tidak termasuk setiap elemen array sekali | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan pasangan yang diperlukan untuk setiap elemen array; Memulakan peta; Mengemas kini kekerapan setiap elemen; Menyimpan kiraan pasangan; Melintasi peta; Hitung bilangan cara untuk memilih pasangan yang terdiri daripada unsur yang sama sahaja; Melintasi array; Cetak kiraan untuk setiap elemen array; Kod pemacu; Diberikan array; Saiz array", "code": "using System ; using System . Collections . Generic ; class GFG { static void countEqualElementPairs ( int [ ] arr , int N ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! map . ContainsKey ( arr [ i ] ) ) map [ arr [ i ] ] = 1 ; else map [ arr [ i ] ] ++ ; } int total = 0 ; foreach ( KeyValuePair < int , int > e in map ) { total += ( e . Value * ( e . Value - 1 ) ) / 2 ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( total - ( map [ arr [ i ] ] - 1 ) + \" ▁ \" ) ; } } public static void Main ( ) { int [ ] arr = { 1 , 1 , 2 , 1 , 2 } ; int N = 5 ; countEqualElementPairs ( arr , N ) ; } }"}
{"text": "Count of Octal Number sehingga digit N | C # Program untuk mencari kiraan nombor oktal semulajadi sehingga digit; Berfungsi untuk mengembalikan kiraan nombor oktal semulajadi sehingga digit; Gelung untuk berulang dari 1 hingga N dan mengira bilangan nombor oktal untuk setiap digit 'i' th. ; Kod pemacu", "code": "using System ; class GFG { static int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) ( 7 * Math . Pow ( 8 , i - 1 ) ) ; } return sum ; } public static void Main ( ) { int N = 4 ; Console . WriteLine ( count ( N ) ) ; } }"}
{"text": "Pembahagi Palindromic nombor | C # Program untuk mencari semua pembahagi palindromik nombor; Fungsi untuk memeriksa adalah NUM adalah palindromic atau tidak; Tukar n ke string str; Memulakan dan mengakhiri indeks string str; Jika char di s dan e tidak sama maka kembali palsu; Berfungsi untuk mencari pembahagi palindromik; Untuk sakit pembahagi palindromik nombor n; Jika n boleh dibahagikan dengan i; Semak jika nombor adalah persegi yang sempurna; Periksa pembahagi adalah palindromic, kemudian simpannya; Semak jika pembahagi adalah palindrome; Semak jika N / pembahagi adalah palindromik atau tidak; Cetak semua pembahagi palindromik dalam urutan yang disusun; Kod pemacu; Fungsi panggilan untuk mencari semua pembahagi palindromik", "code": "using System ; using System . Collections . Generic ; class GFG { static bool isPalindrome ( int n ) { String str = String . Join ( \" \" , n ) ; int s = 0 , e = str . Length - 1 ; while ( s < e ) { if ( str [ s ] != str [ e ] ) { return false ; } s ++ ; e -- ; } return true ; } static void palindromicDivisors ( int n ) { List < int > PalindromDivisors = new List < int > ( ) ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( isPalindrome ( i ) ) { PalindromDivisors . Add ( i ) ; } } else { if ( isPalindrome ( i ) ) { PalindromDivisors . Add ( i ) ; } if ( isPalindrome ( n / i ) ) { PalindromDivisors . Add ( n / i ) ; } } } } PalindromDivisors . Sort ( ) ; for ( int i = 0 ; i < PalindromDivisors . Count ; i ++ ) { Console . Write ( PalindromDivisors [ i ] + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int n = 66 ; palindromicDivisors ( n ) ; } }"}
{"text": "Keluarkan nombor minimum dari array untuk mendapatkan minimum atau nilai | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan penghapusan minimum untuk mendapatkan minimum atau; Untuk menyimpan elemen minimum; Cari elemen minimum dari array; Untuk menyimpan kekerapan elemen minimum; Cari kekerapan elemen minimum; Kembalikan jawapan yang dibaca; Kod pemacu", "code": "using System ; class GFG { static int findMinDel ( int [ ] arr , int n ) { int min_num = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) min_num = Math . Min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 3 , 2 } ; int n = arr . Length ; Console . Write ( findMinDel ( arr , n ) ) ; } }"}
{"text": "Bilangan subarray dengan GCD sama dengan 1 | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan yang diperlukan; Untuk menyimpan jawapan terakhir; Untuk menyimpan GCD bermula dari indeks 'i'; Gelung untuk mencari GCD setiap subarray dari arr [i] ke arr [i ... n - 1]; Kenaikan kiraan jika curr_gcd = 1; Kembalikan jawapan terakhir; Kod pemacu", "code": "using System ; class GFG { static int cntSubArr ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_gcd = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ; ans += ( curr_gcd == 1 ) ? 1 : 0 ; } } return ans ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 1 } ; int n = arr . Length ; Console . WriteLine ( cntSubArr ( arr , n ) ) ; } }"}
{"text": "Program untuk mencetak nombor perdana dari 1 hingga n. | C # Program untuk memaparkan nombor utama N Perdana; Berfungsi untuk mencetak nombor utama n pertama; Mengisytiharkan pembolehubah; Mesej paparan cetak; Melintasi setiap nombor dari 1 hingga n dengan bantuan untuk gelung; Langkau 0 dan 1 kerana mereka bukan Perdana atau Komposit; pembolehubah bendera untuk memberitahu jika saya adalah perdana atau tidak; Bendera = 1 bermakna saya adalah perdana dan bendera = 0 bermakna saya bukan perdana; Kod pemacu", "code": "using System ; class GFG { static void print_primes_till_N ( int N ) { int i , j , flag ; Console . Write ( \" Prime ▁ numbers ▁ between ▁ 1 ▁ and ▁ \" + N + \" ▁ are : STRNEWLINE \" ) ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) Console . Write ( i + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int N = 100 ; print_primes_till_N ( N ) ; } }"}
{"text": "Memaksimumkan ungkapan (a dan x) * (b dan x) | Manipulasi Bit | C # pelaksanaan pendekatan; Fungsi untuk mencari x mengikut syarat yang diberikan; Int boleh mempunyai 32 bit; Bit sementara; Kirakan sedikit x mengikut syarat -syarat yang diberikan di bawah adalah kesimpulan langsung dari ilustrasi yang telah kami ambil sebelumnya; Tambah sedikit x ke x; Kod pemacu", "code": "using System ; class GFG { static int MAX = 32 ; static int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; } public static void Main ( String [ ] args ) { int A = 11 , B = 13 ; Console . WriteLine ( findX ( A , B ) ) ; } }"}
{"text": "Bilangan subset yang min adalah maksimum | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan subset dengan min maksimum; Nilai maksimum dari array; Untuk menyimpan bilangan elemen maksimum kali muncul dalam array; Mengembalikan kiraan subset yang sah; Kod pemacu", "code": "using System ; using System . Linq ; class GFG { static int cntSubSets ( int [ ] arr , int n ) { int maxVal = arr . Max ( ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( int ) ( Math . Pow ( 2 , cnt ) - 1 ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 1 , 2 } ; int n = arr . Length ; Console . WriteLine ( cntSubSets ( arr , n ) ) ; } }"}
{"text": "Kebarangkalian bahawa pasangan rawak yang dipilih dari array (a [i], a [j]) mempunyai jumlah maksimum | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan kebarangkalian mendapatkan jumlah pasangan maksimum apabila pasangan rawak dipilih dari array yang diberikan; Memulakan jumlah maksimum, kiraannya dan kiraan jumlah pasangan; Untuk setiap pasangan; Dapatkan jumlah pasangan semasa; Jika jumlahnya sama dengan jumlah maksimum semasa setakat ini; Kenaikan kiraannya; Jika jumlahnya lebih besar daripada maksimum semasa; Kemas kini maksimum semasa dan semula - memulakan kiraan kepada 1; Cari kebarangkalian yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static float findProb ( int [ ] arr , int n ) { long maxSum = int . MinValue , maxCount = 0 , totalPairs = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( sum == maxSum ) { maxCount ++ ; } else if ( sum > maxSum ) { maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } } float prob = ( float ) maxCount / ( float ) totalPairs ; return prob ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = arr . Length ; Console . WriteLine ( findProb ( arr , n ) ) ; } }"}
{"text": "Kiraan maksimum pembahagi umum a dan b sedemikian rupa sehingga semua adalah co | C # pelaksanaan pendekatan di atas; Fungsi untuk mengembalikan kiraan faktor umum a dan b supaya semua elemen adalah co - perdana antara satu sama lain; GCD A dan B; Termasuk 1 pada mulanya; Cari semua faktor utama GCD; Jika GCD adalah perdana; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int maxCommonFactors ( int a , int b ) { int __gcd = gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= __gcd ; i ++ ) { if ( __gcd % i == 0 ) { ans ++ ; while ( __gcd % i == 0 ) __gcd /= i ; } } if ( __gcd != 1 ) ans ++ ; return ans ; } public static void Main ( String [ ] args ) { int a = 12 , b = 18 ; Console . WriteLine ( maxCommonFactors ( a , b ) ) ; } }"}
{"text": "Cari nombor hari dalam tahun semasa untuk tarikh yang diberikan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan hari tahun ini untuk tarikh yang diberikan; Ekstrak tahun, bulan dan hari dari rentetan tarikh; Sekiranya tahun semasa adalah tahun lompat dan tarikh yang diberikan adalah selepas 28 Februari maka ia mesti termasuk 29 Februari; Tambah hari pada bulan -bulan sebelumnya; Kod pemacu", "code": "using System ; class GFG { static int [ ] days = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; static int dayOfYear ( string date ) { int year = Int32 . Parse ( date . Substring ( 0 , 4 ) ) ; int month = Int32 . Parse ( date . Substring ( 5 , 2 ) ) ; int day = Int32 . Parse ( date . Substring ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; } while ( -- month > 0 ) { day = day + days [ month - 1 ] ; } return day ; } public static void Main ( ) { String date = \"2019-01-09\" ; Console . WriteLine ( dayOfYear ( date ) ) ; } }"}
{"text": "Cari bilangan sel dalam jadual mengandungi x | C # Program untuk mencari bilangan sel dalam jadual mengandungi x; Fungsi untuk mencari bilangan sel dalam jadual mengandungi x; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; } public static void Main ( ) { int n = 6 , x = 12 ; Console . WriteLine ( Cells ( n , x ) ) ; } }"}
{"text": "Kuasa terkecil 4 lebih besar daripada atau sama dengan N | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan kuasa terkecil 4 lebih besar daripada atau sama dengan n; Jika n sendiri adalah kuasa 4 maka kembali n; Kod pemacu", "code": "using System ; class GFG { static int nextPowerOfFour ( int n ) { int x = ( int ) Math . Floor ( Math . Sqrt ( Math . Sqrt ( n ) ) ) ; if ( Math . Pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return ( int ) Math . Pow ( x , 4 ) ; } } public static void Main ( ) { int n = 122 ; Console . WriteLine ( nextPowerOfFour ( n ) ) ; } }"}
{"text": "Operasi minimum yang diperlukan untuk menukar x ke y dengan mendarabkan x dengan co yang diberikan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan operasi minimum yang diperlukan; Tidak mungkin; Untuk menyimpan kuasa terbesar p yang membahagikan d; Sementara dibahagi oleh p; Untuk menyimpan kuasa terbesar Q yang membahagikan d; Manakala dibahagi oleh q; Jika d> 1; Kerana, d = p ^ a * q ^ b; Kod pemacu", "code": "using System ; class GFG { static int minOperations ( int x , int y , int p , int q ) { if ( y % x != 0 ) return - 1 ; int d = y / x ; int a = 0 ; while ( d % p == 0 ) { d /= p ; a ++ ; } int b = 0 ; while ( d % q == 0 ) { d /= q ; b ++ ; } if ( d != 1 ) return - 1 ; return ( a + b ) ; } public static void Main ( ) { int x = 12 , y = 2592 , p = 2 , q = 3 ; Console . Write ( minOperations ( x , y , p , q ) ) ; } }"}
{"text": "Bilangan kuadrup dengan GCD sama dengan k | C # pelaksanaan pendekatan; Fungsi untuk mengira NC4; Kes asas untuk mengira NC4; Berfungsi untuk mengembalikan kiraan kuadrup yang diperlukan menggunakan pengecualian inklusi; Berkesan n; Melangkah lebih dari 2 hingga m; Bilangan pembahagi saya hingga m; Count menyimpan bilangan pembahagi utama yang berlaku tepat sekali; Untuk mengelakkan pengulangan pembahagi utama; Jika pengulangan pembahagi utama hadir mengabaikan nombor ini; Jika kiraan pembahagi utama ganjil tolaknya dari jawapan lain, tambah; Kod pemacu", "code": "using System ; class GFG { static int nCr ( int n ) { if ( n < 4 ) return 0 ; int answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; answer /= 24 ; return answer ; } static int countQuadruples ( int N , int K ) { int M = N / K ; int answer = nCr ( M ) ; for ( int i = 2 ; i < M ; i ++ ) { int j = i ; int temp2 = M / i ; int count = 0 ; int check = 0 ; int temp = j ; while ( j % 2 == 0 ) { count ++ ; j /= 2 ; if ( count >= 2 ) break ; } if ( count >= 2 ) { check = 1 ; } for ( int k = 3 ; k <= Math . Sqrt ( temp ) ; k += 2 ) { int cnt = 0 ; while ( j % k == 0 ) { cnt ++ ; j /= k ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) { check = 1 ; break ; } else if ( cnt == 1 ) count ++ ; } if ( j > 2 ) { count ++ ; } if ( check == 1 ) continue ; else { if ( count % 2 == 1 ) { answer -= nCr ( temp2 ) ; } else { answer += nCr ( temp2 ) ; } } } return answer ; } public static void Main ( String [ ] args ) { int N = 10 , K = 2 ; Console . WriteLine ( countQuadruples ( N , K ) ) ; } }"}
{"text": "Cari nombor yang ditambah kepada nisbah yang diberikan A: B, nisbah berubah kepada C: D | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan nombor x yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; } static public void Main ( ) { int a = 2 , b = 3 , c = 4 , d = 5 ; Console . Write ( getX ( a , b , c , d ) ) ; } }"}
{"text": "Bilangan cara untuk mengatur perkataan sedemikian rupa sehingga tiada vokal berlaku bersama | C # kod untuk pendekatan di atas; Fungsi untuk memeriksa sama ada watak adalah vokal atau konsonen; Berfungsi untuk mengira faktorial nombor; Mengira tidak ada cara untuk mengatur vokal; Melelehkan peta dan mengira bilangan vokal dan mengira tiada cara untuk mengatur vokal; Mengira tidak ada cara untuk mengatur perkataan yang diberikan supaya semua vokal bersatu; Kira tidak ada cara untuk mengatur vokal; Untuk menyimpan penyebut pecahan; Count of Consonents; Kirakan bilangan cara untuk mengatur perkataan sedemikian rupa sehingga semua vokal bersatu; Untuk mengira jumlah permutasi; Untuk menyimpan panjang perkataan yang diberikan; Penyebut pecahan; Mengembalikan jumlah permutasi perkataan yang diberikan; Berfungsi untuk mengira bilangan permutasi supaya tiada vokal bersatu; Untuk menyimpan kekerapan watak; Mengira kekerapan semua aksara; Hitung jumlah permutasi; Hitung jumlah permutasi sedemikian rupa sehingga semua vokal bersatu; Tolak vwl_tgthr dari jumlah untuk mendapatkan hasilnya; Mengembalikan hasilnya; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static bool isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; else return false ; } static long fact ( long n ) { if ( n < 2 ) { return 1 ; } return n * fact ( n - 1 ) ; } static long only_vowels ( Dictionary < char , int > freq ) { long denom = 1 ; long cnt_vwl = 0 ; foreach ( KeyValuePair < char , int > itr in freq ) { if ( isVowel ( itr . Key ) ) { denom *= fact ( itr . Value ) ; cnt_vwl += itr . Value ; } } return fact ( cnt_vwl ) / denom ; } static long all_vowels_together ( Dictionary < char , int > freq ) { long vow = only_vowels ( freq ) ; long denom = 1 ; long cnt_cnst = 0 ; foreach ( KeyValuePair < char , int > itr in freq ) { if ( ! isVowel ( itr . Key ) ) { denom *= fact ( itr . Value ) ; cnt_cnst += itr . Value ; } } long ans = fact ( cnt_cnst + 1 ) / denom ; return ( ans * vow ) ; } static long total_permutations ( Dictionary < char , int > freq ) { long cnt = 0 ; long denom = 1 ; foreach ( KeyValuePair < char , int > itr in freq ) { denom *= fact ( itr . Value ) ; cnt += itr . Value ; } return fact ( cnt ) / denom ; } static long no_vowels_together ( string word ) { Dictionary < char , int > freq = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < word . Length ; i ++ ) { char ch = Char . ToLower ( word [ i ] ) ; if ( freq . ContainsKey ( ch ) ) { freq [ ch ] ++ ; } else { freq [ ch ] = 1 ; } } long total = total_permutations ( freq ) ; long vwl_tgthr = all_vowels_together ( freq ) ; long res = total - vwl_tgthr ; return res ; } static void Main ( ) { string word = \" allahabad \" ; long ans = no_vowels_together ( word ) ; Console . WriteLine ( ans ) ; word = \" geeksforgeeks \" ; ans = no_vowels_together ( word ) ; Console . WriteLine ( ans ) ; word = \" abcd \" ; ans = no_vowels_together ( word ) ; Console . WriteLine ( ans ) ; } }"}
{"text": "Program untuk mencari bilangan lelaki pada mulanya | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan lelaki pada mulanya; Kod pemacu", "code": "using System ; class GFG { static int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; } public static void Main ( ) { int D = 5 , m = 4 , d = 4 ; Console . WriteLine ( numberOfMen ( D , m , d ) ) ; } }"}
{"text": "Kawasan segitiga yang dibentuk oleh paksi Co | C # Kawasan Program Segitiga yang dibentuk oleh paksi Co - ordinat dan garis lurus yang diberikan; Berfungsi untuk mencari kawasan; Kod pemacu", "code": "using System ; class GFG { static double area ( double a , double b , double c ) { double d = Math . Abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; } static public void Main ( ) { double a = - 2 , b = 4 , c = 3 ; Console . WriteLine ( area ( a , b , c ) ) ; } }"}
{"text": "Jumlah dua nombor di mana satu nombor diwakili sebagai pelbagai digit | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan vektor yang mengandungi jawapannya; ArrayList V adalah untuk menyimpan setiap digit SUM dan ArrayList ANS adalah untuk menyimpan jawapannya; Tidak dibawa pada mulanya; Mula gelung dari hujung dan ambil elemen satu demi satu; Indeks array dan nombor angka terakhir; Mengekalkan pembawa penjumlahan; Tolak nilai digit ke dalam array; Nilai k lebih besar kemudian 0; Tolak digit k satu demi satu dalam array; Juga mengekalkan pembawa dengan penjumlahan; Membalikkan unsur -unsur vektor v dan simpannya dalam vektor ans; Kod pemacu; Cetak jawapannya", "code": "using System ; using System . Collections ; class GFG { static ArrayList addToArrayForm ( ArrayList A , int K ) { ArrayList v = new ArrayList ( ) ; ArrayList ans = new ArrayList ( ) ; int rem = 0 ; int i = 0 ; for ( i = A . Count - 1 ; i >= 0 ; i -- ) { int my = ( int ) A [ i ] + K % 10 + rem ; if ( my > 9 ) { rem = 1 ; v . Add ( my % 10 ) ; } else { v . Add ( my ) ; rem = 0 ; } K = K / 10 ; } while ( K > 0 ) { int my = K % 10 + rem ; v . Add ( my % 10 ) ; if ( my / 10 > 0 ) rem = 1 ; else rem = 0 ; K = K / 10 ; } if ( rem > 0 ) v . Add ( rem ) ; for ( int j = v . Count - 1 ; j >= 0 ; j -- ) ans . Add ( ( int ) v [ j ] ) ; return ans ; } static void Main ( ) { ArrayList A = new ArrayList ( ) ; A . Add ( 2 ) ; A . Add ( 7 ) ; A . Add ( 4 ) ; int K = 181 ; ArrayList ans = addToArrayForm ( A , K ) ; for ( int i = 0 ; i < ans . Count ; i ++ ) Console . Write ( ( int ) ans [ i ] ) ; } }"}
{"text": "Kirakan maksimum fungsi dengan cekap ke atas semua sub | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan jumlah maksimum sub - array; Berfungsi untuk mengembalikan nilai maksimum fungsi f; Mengira Arrays B [] dan C []; Cari Sub Maksimum Sub - pelbagai tatasusunan dan mengambil maksimum di antara mereka; Kod pemacu", "code": "using System ; class GFG { static int MAX = 100005 ; static int kadaneAlgorithm ( int [ ] ar , int n ) { int sum = 0 , maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; if ( sum < 0 ) sum = 0 ; maxSum = Math . Max ( maxSum , sum ) ; } return maxSum ; } static int maxFunction ( int [ ] arr , int n ) { int [ ] b = new int [ MAX ] ; int [ ] c = new int [ MAX ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 1 ) { b [ i ] = Math . Abs ( arr [ i + 1 ] - arr [ i ] ) ; c [ i ] = - b [ i ] ; } else { c [ i ] = Math . Abs ( arr [ i + 1 ] - arr [ i ] ) ; b [ i ] = - c [ i ] ; } } int ans = kadaneAlgorithm ( b , n - 1 ) ; ans = Math . Max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 5 , 4 , 7 } ; int n = arr . Length ; Console . WriteLine ( maxFunction ( arr , n ) ) ; } }"}
{"text": "Ketiga digit terakhir dalam 5 ^ n untuk diberikan n | C # pelaksanaan pendekatan di atas; Berfungsi untuk mencari elemen; jika n <3; Jika n juga kembali 6 jika n adalah pulangan ganjil 1; Kod pemacu", "code": "using System ; class GFG { static int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return ( n & 1 ) > 0 ? 1 : 6 ; } static void Main ( ) { int n = 7 ; Console . WriteLine ( findThirdDigit ( n ) ) ; } }"}
{"text": "Kebarangkalian memenangi perlawanan apabila kebarangkalian individu memukul sasaran yang diberikan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kebarangkalian kemenangan; P dan Q menyimpan nilai pecahan A / B dan C / D; Untuk menyimpan kebarangkalian kemenangan A; Kod pemacu", "code": "using System ; class GFG { public static double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; } public static void Main ( string [ ] args ) { int a = 1 , b = 2 , c = 10 , d = 11 ; Console . Write ( \" { 0 : F5 } \" , getProbability ( a , b , c , d ) ) ; } }"}
{"text": "Nombor palindromik terbesar dalam array | C # pelaksanaan pendekatan di atas; Fungsi untuk memeriksa sama ada n adalah palindrome; Cari pembahagi yang sesuai untuk mengekstrak digit terkemuka; Jika digit pertama dan terakhir tidak sama maka kembali palsu; Mengeluarkan digit terkemuka dan trailing dari nombor; Mengurangkan pembahagi dengan faktor 2 sebagai 2 digit dijatuhkan; Berfungsi untuk mencari nombor palindromik terbesar; Sekiranya palindrom lebih besar daripada semasa yang dijumpai; Mengembalikan nombor palindromik terbesar dari array; Program pemacu; Cetak jawapan yang diperlukan", "code": "using System ; class GFG { static bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } static int largestPalindrome ( int [ ] A , int n ) { int currentMax = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > currentMax && isPalindrome ( A [ i ] ) ) currentMax = A [ i ] ; } return currentMax ; } public static void Main ( ) { int [ ] A = { 1 , 232 , 54545 , 999991 } ; int n = A . Length ; Console . WriteLine ( largestPalindrome ( A , n ) ) ; } }"}
{"text": "Kurangkan array ke satu elemen dengan operasi yang diberikan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan elemen akhir; Kod pemacu", "code": "using System ; public class GFG { public static long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; } static public void Main ( ) { int N = 12 ; Console . WriteLine ( getFinalElement ( N ) ) ; } }"}
{"text": "Jumlah elemen dalam array yang mempunyai kekerapan utama | C # Program untuk mencari jumlah elemen dalam array yang mempunyai kekerapan utama; Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mengembalikan jumlah elemen dalam array yang mempunyai kekerapan utama; Peta digunakan untuk menyimpan frekuensi elemen; Melintasi peta; Mengira bilangan elemen yang mempunyai frekuensi utama; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } static int sumOfElements ( int [ ] arr , int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , n + 1 ) ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . ContainsKey ( arr [ i ] ) ) { var val = m [ arr [ i ] ] ; m . Remove ( arr [ i ] ) ; m . Add ( arr [ i ] , val + 1 ) ; } else { m . Add ( arr [ i ] , 1 ) ; } } int sum = 0 ; foreach ( KeyValuePair < int , int > entry in m ) { int key = entry . Key ; int value = entry . Value ; if ( prime [ value ] ) { sum += ( key ) ; } } return sum ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 4 , 6 , 5 , 4 , 6 } ; int n = arr . Length ; Console . WriteLine ( sumOfElements ( arr , n ) ) ; } }"}
{"text": "Jumlah semua nombor palindromik panjang dalam julat [l, r] | C # Program untuk mencari jumlah semua nombor palindromik panjang yang ganjil dalam julat yang diberikan; Fungsi yang mengembalikan benar jika nombor yang diberikan adalah palindrome; Di sini kita menjana nombor baru (reverse_num) * dengan membalikkan digit nombor input asal; Jika nombor input asal (num) adalah sama dengan * ke belakangnya (reverse_num) maka palindrome * lain tidak. ; Fungsi yang mengembalikan benar jika nombor yang diberikan adalah panjang ganjil; Berfungsi untuk mengembalikan jumlah semua nombor palindromik panjang yang ganjil dalam julat yang diberikan; jika nombor adalah palindrome dan panjang ganjil; Kod pemacu", "code": "using System ; public class GFG { static bool isPalindrome ( int num ) { int reverse_num = 0 , remainder , temp ; temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp /= 10 ; } if ( reverse_num == num ) { return true ; } return false ; } static bool isOddLength ( int num ) { int count = 0 ; while ( num > 0 ) { num /= 10 ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; } static long sumOfAllPalindrome ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; } public static void Main ( String [ ] args ) { int L = 110 , R = 1130 ; Console . WriteLine ( sumOfAllPalindrome ( L , R ) ) ; } }"}
{"text": "Bilangan cara untuk mengatur perkataan sedemikian rupa sehingga semua vokal berlaku bersama | C # Program untuk mengira no. cara untuk mengatur perkataan yang mempunyai vokal bersama; Faktorial nombor; Mengira cara untuk mengatur konsonan; Abaikan vokal; Mengira cara untuk mengatur vokal; Fungsi untuk mengira jumlah no. cara; Mengira vokal dan konsonan; Jumlah tidak. cara; Kod pemacu", "code": "using System . Collections . Generic ; using System ; class GFG { static int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f = f * i ; return f ; } static int waysOfConsonants ( int size1 , int [ ] freq ) { int ans = fact ( size1 ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) continue ; else ans = ans / fact ( freq [ i ] ) ; } return ans ; } static int waysOfVowels ( int size2 , int [ ] freq ) { return fact ( size2 ) / ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ; } static int countWays ( string str ) { int [ ] freq = new int [ 200 ] ; for ( int i = 0 ; i < 200 ; i ++ ) freq [ i ] = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] != ' a ' && str [ i ] != ' e ' && str [ i ] != ' i ' && str [ i ] != ' o ' && str [ i ] != ' u ' ) consonant ++ ; else vowel ++ ; } return waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ; } public static void Main ( ) { string str = \" geeksforgeeks \" ; Console . WriteLine ( countWays ( str ) ) ; } }"}
{"text": "Jumlah nombor Fibonacci dengan negatif alternatif | C # Program untuk mencari jumlah alternatif nombor Fibonacci; Mengira nilai nombor Fibonacci pertama dan menyimpan jumlah alternatif mereka; Memulakan hasil; Tambah istilah yang tinggal; Bahkan istilah; Untuk istilah ganjil; Mengembalikan jumlah bergantian; Kod pemacu; Dapatkan n; Cari jumlah bergantian", "code": "using System ; class GFG { static double calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; double sum = Math . Pow ( fibo [ 0 ] , 2 ) + Math . Pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; } public static void Main ( ) { int n = 8 ; Console . WriteLine ( \" Alternating ▁ Fibonacci ▁ Sum ▁ upto ▁ \" + n + \" ▁ terms : ▁ \" + calculateAlternateSum ( n ) ) ; } }"}
{"text": "Cari istilah n Siri 1 2 2 4 4 4 4 8 8 8 8 8 8 8 8 ... | C # Program untuk mencari istilah n; Fungsi yang akan mengembalikan istilah nth; Kod pemacu; Dapatkan n; Dapatkan nilai; Dapatkan n; Dapatkan nilai", "code": "using System ; class GFG { static int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; } public static void Main ( ) { int n = 9 ; Console . WriteLine ( getValue ( n ) ) ; n = 1025 ; Console . WriteLine ( getValue ( n ) ) ; } }"}
{"text": "Bina pelbagai frekuensi digit nilai yang diperoleh dari x ^ 1, x ^ 2, ... .... . , x ^ n | C # pelaksanaan pendekatan di atas; Fungsi yang melintasi digit dalam nombor dan mengubah suai jumlah kekerapan kekerapan; Array untuk menyimpan kiraan digit; Melintasi x ^ 1 hingga x ^ n; Untuk fungsi kuasa, kedua -dua parameternya akan dua kali ganda; Memanggil Countdigits berfungsi pada x ^ i; Mencetak kiraan digit 0 - 9; Kod pemacu", "code": "using System ; class GFG { static void countDigits ( double val , long [ ] arr ) { while ( ( long ) val > 0 ) { long digit = ( long ) val % 10 ; arr [ ( int ) digit ] ++ ; val = ( long ) val / 10 ; } return ; } static void countFrequency ( int x , int n ) { long [ ] freq_count = new long [ 10 ] ; for ( int i = 1 ; i <= n ; i ++ ) { double val = Math . Pow ( ( double ) x , ( double ) i ) ; countDigits ( val , freq_count ) ; } for ( int i = 0 ; i <= 9 ; i ++ ) { Console . Write ( freq_count [ i ] + \" ▁ \" ) ; } } public static void Main ( ) { int x = 15 , n = 3 ; countFrequency ( x , n ) ; } }"}
{"text": "Bilangan nilai b seperti a = b + (a ^ b) | C # Program untuk mencari bilangan nilai b sedemikian rupa sehingga a = b + (a ^ b); berfungsi untuk mengembalikan bilangan penyelesaian; Semak setiap nilai yang mungkin; Kod pemacu", "code": "using System ; class GFG { static int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; } public static void Main ( ) { int a = 3 ; Console . WriteLine ( countSolutions ( a ) ) ; } }"}
{"text": "Bilangan nilai b seperti a = b + (a ^ b) | C # Program untuk mencari bilangan nilai b sedemikian rupa sehingga a = b + (a ^ b); berfungsi untuk mengembalikan bilangan penyelesaian; Kod pemacu", "code": "class GFG { static int countSolutions ( int a ) { int count = bitCount ( a ) ; count = ( int ) System . Math . Pow ( 2 , count ) ; return count ; } static int bitCount ( int n ) { int count = 0 ; while ( n != 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; } public static void Main ( ) { int a = 3 ; System . Console . WriteLine ( countSolutions ( a ) ) ; } }"}
{"text": "Jumlah kawasan semua persegi yang mungkin di dalam segi empat tepat | C # Program untuk mengira jumlah kawasan semua dataran yang mungkin masuk ke dalam segi empat tepat; Fungsi untuk mengira jumlah kawasan semua dataran yang mungkin masuk ke dalam segi empat tepat; Persegi dengan saiz maksimum mungkin; Kirakan jumlah persegi saiz tertentu; mengira kawasan dataran dengan saiz tertentu; Jumlah kawasan; saiz kenaikan; Kod pemacu", "code": "using System ; class GFG { static int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . Min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; } public static void Main ( ) { int l = 4 , b = 3 ; Console . Write ( calculateAreaSum ( l , b ) ) ; } }"}
{"text": "Hyperfactorial nombor | C # Program untuk mencari hyperfactorial nombor; fungsi untuk mengira nilai hiperfakterial; memulakan val kepada 1; mengembalikan hiperfactoral nombor; Kod pemacu", "code": "using System ; class GFG { static long boost_hyperfactorial ( long num ) { long val = 1 ; for ( long i = 1 ; i <= num ; i ++ ) { val = val * ( long ) Math . Pow ( i , i ) ; } return val ; } public static void Main ( ) { int num = 5 ; Console . WriteLine ( boost_hyperfactorial ( num ) ) ; } }"}
{"text": "Hyperfactorial nombor | C # Program untuk mencari hyperfactorial nombor menggunakan perpustakaan rangsangan; fungsi untuk mengira nilai hiperfakterial; memulakan val kepada 1; 1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . ; mengembalikan hiperfactoral nombor; Kod pemacu", "code": "using System ; class GFG { static int boost_hyperfactorial ( int num ) { int val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; } public static void Main ( ) { int num = 5 ; Console . WriteLine ( boost_hyperfactorial ( num ) ) ; } }"}
{"text": "Kurangkan 1 tanpa pengendali aritmetik | C # kod untuk menolak satu dari nombor tertentu; Flip semua bit set sehingga kita dapati 1; Flip paling tepat 1 bit; Kod pemacu", "code": "using System ; class GFG { static int subtractOne ( int x ) { int m = 1 ; while ( ! ( ( x & m ) > 0 ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } public static void Main ( ) { Console . WriteLine ( subtractOne ( 13 ) ) ; } }"}
{"text": "Cari vektor min matriks | C # Program untuk mencari vektor min matriks yang diberikan; Fungsi untuk mencari vektor min; gelung untuk melintasi setiap lajur; untuk mengira min setiap baris; untuk menyimpan jumlah elemen lajur; Kod pemacu", "code": "using System ; class GFG { static int rows = 3 ; static int cols = 3 ; static void meanVector ( int [ , ] mat ) { Console . Write ( \" [ ▁ \" ) ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j , i ] ; mean = sum / rows ; Console . Write ( ( int ) mean + \" ▁ \" ) ; } Console . Write ( \" ] \" ) ; } public static void Main ( ) { int [ , ] mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; meanVector ( mat ) ; } }"}
{"text": "Nombor Hoax | C # kod untuk memeriksa sama ada nombor adalah nombor tipuan atau tidak. ; Fungsi untuk mencari faktor utama yang berbeza dari nombor n; N adalah ganjil pada ketika ini, kerana ia tidak lagi dibahagikan dengan 2. Oleh itu, kita boleh menguji hanya untuk nombor ganjil, sama ada faktor n; Semak jika saya adalah faktor utama; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Fungsi untuk mengira jumlah digit faktor utama yang berbeza dari nombor N dan jumlah digit nombor N dan bandingkan jumlah yang diperoleh; Faktor utama N sedang disimpan dalam vektor PF; Jika n adalah nombor perdana, ia tidak boleh menjadi nombor tipuan; Mencari jumlah digit faktor utama yang berbeza dari nombor n; Mencari jumlah digit dalam faktor utama semasa PF [i]. ; Mencari jumlah digit nombor n; Membandingkan dua jumlah yang dikira; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static List < int > primeFactors ( int n ) { List < int > res = new List < int > ( ) ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = n / 2 ; res . Add ( 2 ) ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; res . Add ( i ) ; } } if ( n > 2 ) res . Add ( n ) ; return res ; } static bool isHoax ( int n ) { List < int > pf = primeFactors ( n ) ; if ( pf [ 0 ] == n ) return false ; int all_pf_sum = 0 ; for ( int i = 0 ; i < pf . Count ; i ++ ) { int pf_sum ; for ( pf_sum = 0 ; pf [ i ] > 0 ; pf_sum += pf [ i ] % 10 , pf [ i ] /= 10 ) ; all_pf_sum += pf_sum ; } int sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n /= 10 ) ; return sum_n == all_pf_sum ; } public static void Main ( ) { int n = 84 ; if ( isHoax ( n ) ) Console . Write ( \" A ▁ Hoax ▁ Number STRNEWLINE \" ) ; else Console . Write ( \" Not ▁ a ▁ Hoax ▁ Number STRNEWLINE \" ) ; } }"}
{"text": "Ujian Primal | Tetapkan 5 (Menggunakan Program Lucas | C # untuk mengetahui siri Lucas - Lehmer.; Fungsi untuk mengetahui terma pertama N (Memandang 4 sebagai istilah ke -0) Lucas - Lehmer Seri", "code": "using System ; using System . Collections . Generic ; class GFG { static void LucasLehmer ( int n ) { long current_val = 4 ; List < long > series = new List < long > ( ) ; series . Add ( current_val ) ; for ( int i = 0 ; i < n ; i ++ ) { current_val = current_val * current_val - 2 ; series . Add ( current_val ) ; } for ( int i = 0 ; i <= n ; i ++ ) Console . WriteLine ( \" Term ▁ \" + i + \" : ▁ \" + series [ i ] ) ; } static void Main ( ) { int n = 5 ; LucasLehmer ( n ) ; } }"}
{"text": "Modular multiplicative songsang dari 1 hingga n | C # Program untuk mencari songsang modular semua nombor dari 1 hingga n menggunakan kaedah naif; Kaedah naif untuk mencari terbalik berbilang modular 'A' di bawah modulo 'Perdana; Program Pemandu", "code": "using System ; class GFG { static int modInverse ( int a , int prime ) { a = a % prime ; for ( int x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return - 1 ; } static void printModIverses ( int n , int prime ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( modInverse ( i , prime ) + \" ▁ \" ) ; } public static void Main ( ) { int n = 10 , prime = 17 ; printModIverses ( n , prime ) ; } }"}
{"text": "Tukar ke nombor dengan digit sebagai 3 dan 8 sahaja | C # untuk mencari operasi min yang diperlukan untuk menukar menjadi nombor yang menawan; fungsi untuk operasi minimum; baki dan kiraan operasi; mengira digit tidak sama dengan 3 atau 8; Kod pemacu", "code": "using System ; class GFG { static int minOp ( int num ) { int rem ; int count = 0 ; while ( num > 0 ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; } public static void Main ( ) { int num = 234198 ; Console . WriteLine ( \" Minimum ▁ Operations ▁ = \" + minOp ( num ) ) ; } }"}
{"text": "Integer terbesar yang mempunyai jumlah digit maksimum dalam julat dari 1 hingga n | C # Program untuk mencari nombor dengan jumlah digit maksimum. ; berfungsi untuk mengira jumlah digit nombor. ; Mengembalikan nombor maksimum dengan jumlah maksimum digit. ; memulakan b sebagai 1 dan jumlah maksimum awal menjadi n; berulang dari kanan ke kiri dalam digit; Walaupun meleleh ini adalah nombor dari kanan ke kiri; memanggil fungsi untuk memeriksa sama ada jumlah CUR adalah lebih daripada ANS; mengurangkan nombor ke satu unit kurang; Program Pemandu", "code": "using System ; class GFG { static int sumOfDigits ( int a ) { int sum = 0 ; while ( a != 0 ) { sum += a % 10 ; a /= 10 ; } return sum ; } static int findMax ( int x ) { int b = 1 , ans = x ; while ( x != 0 ) { int cur = ( x - 1 ) * b + ( b - 1 ) ; if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) || ( sumOfDigits ( cur ) == sumOfDigits ( ans ) && cur > ans ) ) ans = cur ; x /= 10 ; b *= 10 ; } return ans ; } public static void Main ( ) { int n = 521 ; Console . WriteLine ( findMax ( n ) ) ; } }"}
{"text": "Julat Interquartile (IQR) | C # Program untuk mencari IQR set data; Fungsi untuk memberi indeks median; Fungsi untuk mengira IQR; Indeks median keseluruhan data; Median separuh pertama; Median separuh kedua; Pengiraan IQR; Kod pemacu", "code": "using System ; class GFG { static int median ( int [ ] a , int l , int r ) { int n = r - l + 1 ; n = ( n + 1 ) / 2 - 1 ; return n + l ; } static int IQR ( int [ ] a , int n ) { Array . Sort ( a ) ; int mid_index = median ( a , 0 , n ) ; int Q1 = a [ median ( a , 0 , mid_index ) ] ; int Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] ; return ( Q3 - Q1 ) ; } public static void Main ( ) { int [ ] a = { 1 , 19 , 7 , 6 , 5 , 9 , 12 , 27 , 18 , 2 , 15 } ; int n = a . Length ; Console . WriteLine ( IQR ( a , n ) ) ; } }"}
{"text": "Nombor palindromik terbesar dalam array | C # pelaksanaan pendekatan di atas; Fungsi untuk memeriksa sama ada n adalah palindrome; Cari pembahagi yang sesuai untuk mengekstrak digit terkemuka; Jika digit pertama dan terakhir tidak sama maka kembali palsu; Mengeluarkan digit terkemuka dan trailing dari nombor; Mengurangkan pembahagi dengan faktor 2 sebagai 2 digit dijatuhkan; Berfungsi untuk mencari nombor palindromik terbesar; Susun array; Jika nombor adalah palindrome; Jika tiada nombor palindromik yang dijumpai; Program pemacu; Cetak jawapan yang diperlukan", "code": "using System ; class GFG { static bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } static int largestPalindrome ( int [ ] A , int n ) { Array . Sort ( A ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( isPalindrome ( A [ i ] ) ) return A [ i ] ; } return - 1 ; } public static void Main ( ) { int [ ] A = { 1 , 232 , 54545 , 999991 } ; int n = A . Length ; Console . WriteLine ( largestPalindrome ( A , n ) ) ; } }"}
{"text": "Jumlah gandaan dua nombor di bawah n | C # Program untuk mencari jumlah semua bilangan bulat di bawah n yang merupakan gandaan sama ada A atau B; Berfungsi untuk mengembalikan jumlah semua bilangan bulat di bawah n yang merupakan gandaan sama ada A atau B; Jika saya adalah pelbagai A atau B; Kod pemacu", "code": "using System ; class GFG { static int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; } static void Main ( ) { int n = 10 , a = 3 , b = 5 ; Console . WriteLine ( findSum ( n , a , b ) ) ; } }"}
{"text": "Kurangkan 1 tanpa pengendali aritmetik | Kod pemacu", "code": "using System ; class GFG { static int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } public static void Main ( String [ ] args ) { Console . Write ( \" { 0 } \" , subtractOne ( 13 ) ) ; } }"}
{"text": "Nombor Pell | Siri nombor Pell menggunakan rekursi dalam C #; Kirakan nombor pell; Fungsi pemacu", "code": "using System ; class PellNumber { public static int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; } public static void Main ( ) { int n = 4 ; Console . Write ( pell ( n ) ) ; } }"}
{"text": "Mencari LCM lebih daripada dua (atau array) tanpa menggunakan GCD | C # Program untuk mencari LCM array tanpa menggunakan GCD. ; Mengembalikan LCM ARR [0 .. n - 1]; Cari nilai maksimum dalam ARR []; Memulakan hasil; Cari semua faktor yang terdapat dalam dua atau lebih elemen array. int x = 2; Faktor semasa. ; Untuk menyimpan indeks semua elemen array yang boleh dibahagikan dengan x. ; Sekiranya terdapat 2 atau lebih elemen array yang boleh dibahagikan dengan x. ; Kurangkan semua elemen array yang boleh dibahagikan dengan x. ; Kemudian kalikan semua elemen array yang dikurangkan; Kod pemacu", "code": "using System ; using System . Collections ; class GFG { static long LCM ( int [ ] arr , int n ) { int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_num < arr [ i ] ) { max_num = arr [ i ] ; } } long res = 1 ; while ( x <= max_num ) { ArrayList indexes = new ArrayList ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % x == 0 ) { indexes . Add ( j ) ; } } if ( indexes . Count >= 2 ) { for ( int j = 0 ; j < indexes . Count ; j ++ ) { arr [ ( int ) indexes [ j ] ] = arr [ ( int ) indexes [ j ] ] / x ; } res = res * x ; } else { x ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { res = res * arr [ i ] ; } return res ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 } ; int n = arr . Length ; Console . WriteLine ( LCM ( arr , n ) ) ; } }"}
{"text": "Cari kesopanan nombor | C # Program untuk pendekatan di atas; Berfungsi untuk mencari kesopanan; sqrt (2 * n) sebagai panjang maksimum akan apabila jumlahnya bermula dari 1 yang mengikuti persamaan n ^ 2 - n - (2 * jumlah) = 0; Kod pemacu", "code": "using System ; public class GFG { static int politness ( int n ) { int count = 0 ; for ( int i = 2 ; i <= Math . Sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; } public static void Main ( String [ ] args ) { int n = 90 ; Console . WriteLine ( \" Politness ▁ of ▁ \" + n + \" ▁ = ▁ \" + politness ( n ) ) ; n = 15 ; Console . WriteLine ( \" Politness ▁ of ▁ \" + n + \" ▁ = ▁ \" + politness ( n ) ) ; } }"}
{"text": "Program untuk tekaan Goldbach (dua prima dengan jumlah yang diberikan) | C # Program untuk melaksanakan tekaan Goldbach; Array untuk menyimpan semua perdana kurang daripada dan sama dengan 10 ^ 6; Fungsi utiliti untuk Sieve of Sundaram; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahu prima yang lebih kecil daripada max, kita mengurangkan max hingga separuh array ini digunakan untuk memisahkan nombor bentuk i + j + 2 * i * j dari orang lain di mana 1 <= i <= j; Logik utama Sundaram. Tandakan semua nombor yang tidak menjana nombor perdana dengan melakukan 2 * i + 1; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Berfungsi untuk melakukan sangkaan Goldbach; Kembali jika nombor tidak atau kurang daripada 3; Semak hanya separuh daripada nombor; Cari perbezaan dengan menolak perdana semasa dari n; Cari jika perbezaannya juga merupakan nombor utama; Menyatakan sebagai jumlah prima; Kod pemacu; Mencari semua nombor perdana sebelum had; Nombor Ekspres sebagai Jumlah Dua Prima", "code": "using System ; using System . Collections . Generic ; class GFG { static int MAX = 10000 ; static List < int > primes = new List < int > ( ) ; static void sieveSundaram ( ) { Boolean [ ] marked = new Boolean [ MAX / 2 + 100 ] ; for ( int i = 1 ; i <= ( Math . Sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . Add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . Add ( 2 * i + 1 ) ; } static void findPrimes ( int n ) { if ( n <= 2 n % 2 != 0 ) { Console . WriteLine ( \" Invalid ▁ Input ▁ \" ) ; return ; } for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { int diff = n - primes [ i ] ; if ( primes . Contains ( diff ) ) { Console . WriteLine ( primes [ i ] + \" ▁ + ▁ \" + diff + \" ▁ = ▁ \" + n ) ; return ; } } } public static void Main ( String [ ] args ) { sieveSundaram ( ) ; findPrimes ( 4 ) ; findPrimes ( 38 ) ; findPrimes ( 100 ) ; } }"}
{"text": "K | C # Program untuk mencetak faktor utama kth. ; Fungsi untuk menjana faktor utama nombor n dan mengembalikan faktor utama; Cari bilangan 2 yang membahagikan k; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, simpan saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes di mana n adalah nombor perdana yang lebih besar daripada 2; Program Pemandu", "code": "using System ; class GFG { static int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return - 1 ; } public static void Main ( ) { int n = 12 , k = 3 ; Console . WriteLine ( kPrimeFactor ( n , k ) ) ; n = 14 ; k = 3 ; Console . WriteLine ( kPrimeFactor ( n , k ) ) ; } }"}
{"text": "K | C # Program untuk mencari faktor utama K - menggunakan SIEVE OF ERATOSTHENES. Program ini adalah cekap apabila kami mempunyai pelbagai nombor dan kami; Menggunakan Sieveoferatosthenes untuk mencari faktor utama terkecil semua nombor. Sebagai contoh, jika max adalah 10, s [2] = s [4] = s [6] = s [10] = 2 s [3] = s [9] = 3 s [5] = 5 s [7] = 7; Buat array Boolean \"Perdana [0.. Max]\" dan memulakan semua penyertaan di dalamnya sebagai palsu. ; Memulakan faktor terkecil sama dengan 2 untuk semua nombor walaupun; Untuk nombor ganjil kurang kemudian sama dengan n; S (i) untuk perdana adalah nombor itu sendiri; Untuk semua gandaan nombor perdana semasa; Saya adalah faktor utama terkecil untuk nombor \"i * j\". ; Berfungsi untuk menjana faktor utama dan mengembalikan faktor utama. S [i] menyimpan faktor utama i. ; Terus membahagikan n dengan faktor utama walaupun sama ada n tidak 1 atau kiraan faktor utama bukan k. ; Untuk menjejaki kiraan faktor utama; Bahagikan N untuk mencari faktor utama seterusnya; Kod pemacu; S [i] akan menyimpan faktor utama i.", "code": "using System ; class GFG { static int MAX = 10001 ; static void sieveOfEratosthenes ( int [ ] s ) { bool [ ] prime = new bool [ MAX + 1 ] ; for ( int i = 2 ; i <= MAX ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= MAX ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= MAX ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } static int kPrimeFactor ( int n , int k , int [ ] s ) { while ( n > 1 ) { if ( k == 1 ) return s [ n ] ; k -- ; n /= s [ n ] ; } return - 1 ; } static void Main ( ) { int [ ] s = new int [ MAX + 1 ] ; sieveOfEratosthenes ( s ) ; int n = 12 , k = 3 ; Console . WriteLine ( kPrimeFactor ( n , k , s ) ) ; n = 14 ; k = 3 ; Console . WriteLine ( kPrimeFactor ( n , k , s ) ) ; } }"}
{"text": "Cari jumlah pembahagi semua pembahagi nombor semulajadi | C # Program untuk mencari jumlah pembahagi semua pembahagi nombor semulajadi. ; Mengembalikan jumlah pembahagi semua pembahagi N; Mengira kuasa faktor utama dan menyimpannya dalam MP MP []. ; Jika n adalah nombor perdana; Untuk setiap faktor utama, mengira (p ^ (a + 1) - 1) / (p - 1) dan menambahnya untuk menjawab. ; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public static int sumDivisorsOfDivisors ( int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int j = 2 ; j <= Math . Sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count != 0 ) mp . Add ( j , count ) ; } if ( n != 1 ) mp . Add ( n , 1 ) ; int ans = 1 ; foreach ( KeyValuePair < int , int > entry in mp ) { int pw = 1 ; int sum = 0 ; for ( int i = entry . Value + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw = entry . Key ; } ans *= sum ; } return ans ; } public static void Main ( String [ ] args ) { int n = 10 ; Console . WriteLine ( sumDivisorsOfDivisors ( n ) ) ; } }"}
{"text": "Perdana terdekat yang kurang daripada bilangan N | C # Program untuk pendekatan di atas; Berfungsi untuk mengembalikan nombor perdana terdekat; Semua nombor utama adalah ganjil kecuali dua; Ia hanya akan dilaksanakan apabila n adalah 3; Kod pemacu", "code": "using System ; class GFG { static int prime ( int n ) { if ( n % 2 != 0 ) n -= 2 ; else n -- ; int i , j ; for ( i = n ; i >= 2 ; i -= 2 ) { if ( i % 2 == 0 ) continue ; for ( j = 3 ; j <= Math . Sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) break ; } if ( j > Math . Sqrt ( i ) ) return i ; } return 2 ; } public static void Main ( ) { int n = 17 ; Console . Write ( prime ( n ) ) ; } }"}
{"text": "Cari urutan berulang dalam pecahan | C # Program untuk mencari urutan berulang dalam pecahan; Fungsi ini mengembalikan urutan berulang pecahan. Jika mengulangi urutan tidak keluar, maka mengembalikan rentetan kosong; Memulakan hasil; Buat peta untuk menyimpan yang sudah dilihat sisa. Sisa digunakan sebagai kunci dan kedudukannya dalam hasil disimpan sebagai nilai. Perhatikan bahawa kita memerlukan kedudukan untuk kes -kes seperti 1/6. Dalam kes ini, urutan berulang tidak bermula dari sisa pertama. ; Cari sisa pertama; Terus mencari baki sehingga sama ada baki menjadi 0 atau mengulangi; Simpan selebihnya ini; Kain baki dengan 10; Tambah REM / DENR untuk menghasilkan; Baki kemas kini; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static string fractionToDecimal ( int numr , int denr ) { string res = \" \" ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int rem = numr % denr ; while ( ( rem != 0 ) && ( ! mp . ContainsValue ( rem ) ) ) { mp [ rem ] = res . Length ; rem = rem * 10 ; int res_part = rem / denr ; res += res_part . ToString ( ) ; rem = rem % denr ; } if ( rem == 0 ) return \" \" ; else if ( mp . ContainsKey ( rem ) ) return res . Substring ( mp [ rem ] ) ; return \" \" ; } public static void Main ( string [ ] args ) { int numr = 50 , denr = 22 ; string res = fractionToDecimal ( numr , denr ) ; if ( res == \" \" ) Console . Write ( \" No ▁ recurring ▁ sequence \" ) ; else Console . Write ( \" Recurring ▁ sequence ▁ is ▁ \" + res ) ; } }"}
{"text": "NOMBOR NOMBOR YANG MEMILIKI 0 A DENGIT | C # Program untuk mengira nombor dari 1 hingga n dengan 0 sebagai digit; Pulangan 1 jika x mempunyai 0, lain 0; Melintasi semua digit X untuk memeriksa sama ada ia mempunyai 0 .; Jika digit semasa adalah 0, kembali benar; Mengembalikan kiraan nombor dari 1 hingga n dengan 0 sebagai digit; Memulakan kiraan nombor yang mempunyai 0 sebagai digit; Melintasi semua nombor dan untuk setiap nombor cek jika ia mempunyai 0 .; Kod pemacu", "code": "using System ; class GFG { static int has0 ( int x ) { while ( x != 0 ) { if ( x % 10 == 0 ) return 1 ; x /= 10 ; } return 0 ; } static int getCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) count += has0 ( i ) ; return count ; } public static void Main ( ) { int n = 107 ; Console . WriteLine ( \" Count ▁ of ▁ numbers ▁ from ▁ 1\" + \" ▁ to ▁ \" + n + \" ▁ is ▁ \" + getCount ( n ) ) ; } }"}
{"text": "Kriteria Euler (periksa jika akar persegi di bawah modulo p wujud) | Program C # mudah untuk memeriksa sama ada akar persegi nombor di bawah modulo p wujud atau tidak; Pulangan benar jika akar persegi n di bawah modulo p wujud; Satu demi satu periksa semua nombor dari 2 hingga p - 1; Kod pemacu", "code": "using System ; class GFG { static bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; } public static void Main ( ) { int p = 7 ; int n = 2 ; if ( squareRootExists ( n , p ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Formula Legendre (diberikan p dan n, cari x terbesar sedemikian rupa sehingga p^x membahagikan n!) | C # Program untuk mencari x terbesar sedemikian rupa sehingga p * x membahagikan n! ; Fungsi yang mengembalikan kuasa terbesar p yang membahagikan N! ; Memulakan hasil; Kirakan x = n / p + n / (p ^ 2) + n / (p ^ 3) + .... ; Kod pemacu", "code": "using System ; public class GFG { static int Largestpower ( int n , int p ) { int ans = 0 ; while ( n > 0 ) { n /= p ; ans += n ; } return ans ; } public static void Main ( ) { int n = 10 ; int p = 3 ; Console . Write ( \" ▁ The ▁ largest ▁ power ▁ of ▁ \" + p + \" ▁ that ▁ divides ▁ \" + n + \" ! ▁ is ▁ \" + Largestpower ( n , p ) ) ; } }"}
{"text": "Program untuk faktorial nombor | C # Program untuk mencari faktorial nombor yang diberikan; Baris tunggal untuk mencari faktorial; Kod pemacu", "code": "using System ; class Factorial { int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } public static void Main ( ) { Factorial obj = new Factorial ( ) ; int num = 5 ; Console . WriteLine ( \" Factorial ▁ of ▁ \" + num + \" ▁ is ▁ \" + obj . factorial ( num ) ) ; } }"}
{"text": "Semua tentang manipulasi bit | Berfungsi untuk mendapatkan bit pada kedudukan ITH; Kembali benar jika bit ditetapkan. Sebaliknya kembali palsu", "code": "static bool getBit ( int num , int i ) { return ( ( num & ( 1 << i ) ) != 0 ) ; }"}
{"text": "Semua tentang manipulasi bit | Berfungsi untuk membersihkan sedikit nombor n; Buat topeng untuk bit ith tidak teratur; Kembalikan nilai kemas kini", "code": "static int clearBit ( int num , int i ) { int mask = ~ ( 1 << i ) ; return num & mask ; }"}
{"text": "Jumlah bitwise dan setiap elemen array dengan unsur -unsur array lain | C # Program untuk pendekatan di atas; Kod pemacu; Diberikan arr1 []; Diberikan arr2 []; Saiz arr1 []; Saiz arr2 []; Panggilan fungsi; Berfungsi untuk mengira dan jumlah untuk setiap elemen array; Mengisytiharkan pelbagai saiz 32 untuk menyimpan kiraan setiap bit; Melintasi array arr2 [] dan simpan kiraan sedikit dalam array kekerapan; Kedudukan bit semasa; Walaupun NUM lebih besar daripada 0; Memeriksa jika bit ith ditetapkan atau tidak; Kenaikan kiraan sedikit demi satu; Meningkatkan kedudukan bit oleh satu; Kanan beralih num oleh satu; Melintasi Arr2 []; Simpan nilai bit ith; Jumlah jumlah yang diperlukan; Melintasi julat [0, 31]; Cek jika bit semasa ditetapkan; Kenaikan jumlah bitwise dengan kekerapan [bit_position] * value_at_that_bit; ; Shift kanan dengan satu; Shift kiri vale_at_that_bit oleh satu; Cetak jumlah yang diperoleh untuk nombor ith di arr1 []", "code": "using System ; class GFG { static public void Main ( ) { int [ ] arr1 = { 1 , 2 , 3 } ; int [ ] arr2 = { 1 , 2 , 3 } ; int N = arr1 . Length ; int M = arr2 . Length ; Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) ; } static void Bitwise_AND_sum_i ( int [ ] arr1 , int [ ] arr2 , int M , int N ) { int [ ] frequency = new int [ 32 ] ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num != 0 ) { if ( ( num & 1 ) != 0 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_AND_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( ( num & 1 ) != 0 ) { bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } Console . Write ( bitwise_AND_sum + \" ▁ \" ) ; } } }"}
{"text": "Matikan Bit Set Bit | Tetapkan 2 | C # Program untuk menyegarkan bit set paling kanan; Tidak menetapkan bit set yang paling kanan dan mengembalikan hasilnya; Memeriksa sama ada kedudukan bit ditetapkan atau tidak; Jika kedudukan bit ditemui, kami flip sedikit ini dengan nombor dan nombor yang diberikan dengan set kedudukan bit; Kod pemacu", "code": "using System ; class GFG { static void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) % 2 > 0 ) { n = n ^ ( 1 << bit ) ; break ; } } Console . Write ( \" The ▁ number ▁ after ▁ unsetting ▁ the ▁ \" ) ; Console . Write ( \" rightmost ▁ set ▁ bit ▁ \" + n ) ; } static void Main ( ) { int N = 12 ; FlipBits ( N ) ; } }"}
{"text": "Bitwise dan semua nombor ganjil dari 1 hingga n | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bitwise dan semua bilangan bulat ganjil dari julat [1, n]; Memulakan hasil kepada 1; Bermula dari 3, bitwise dan semua bilangan bulat ganjil kurang daripada atau sama dengan n; Kod pemacu", "code": "using System ; class GFG { static int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( bitwiseAndOdd ( n ) ) ; } }"}
{"text": "Bitwise dan semua nombor ganjil dari 1 hingga n | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bitwise dan semua bilangan bulat ganjil dari julat [1, n]; Kod pemacu", "code": "using System ; class GFG { static int bitwiseAndOdd ( int n ) { return 1 ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( bitwiseAndOdd ( n ) ) ; } }"}
{"text": "Bit sebenar bit nombor yang diberikan | C # pelaksanaan untuk membalikkan bit nombor; berfungsi untuk membalikkan bit nombor; melintasi bit 'n' dari kanan; Bitwise kiri Shift 'Rev' oleh 1; jika bit semasa ialah '1'; Bitwise kanan shift 'n' oleh 1; nombor yang diperlukan; Kod pemacu", "code": "using System ; class GFG { public static int reverseBits ( int n ) { int rev = 0 ; while ( n > 0 ) { rev <<= 1 ; if ( ( int ) ( n & 1 ) == 1 ) rev ^= 1 ; n >>= 1 ; } return rev ; } public static void Main ( ) { int n = 11 ; Console . WriteLine ( reverseBits ( n ) ) ; } }"}
{"text": "Cara untuk memecah array ke dalam dua kumpulan nilai XOR yang sama | C # Program untuk mengira bilangan cara untuk memecah array ke dalam dua kumpulan supaya setiap kumpulan mempunyai nilai XOR yang sama; Kembalikan jumlah cara untuk memecah array ke dalam dua kumpulan supaya setiap kumpulan mempunyai nilai XOR yang sama. ; Kita boleh berpecah hanya jika XOR adalah 0. Oleh kerana XOR semua adalah 0, kita boleh mempertimbangkan semua subset sebagai satu kumpulan. ; Program Pemandu", "code": "using System ; class GFG { static int countgroup ( int [ ] a , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 3 } ; int n = a . Length ; Console . WriteLine ( countgroup ( a , n ) ) ; } }"}
{"text": "Ekstrak 'k' bit dari kedudukan tertentu dalam nombor. | C # Program untuk mengekstrak k bit dari kedudukan tertentu. ; Berfungsi untuk mengekstrak k bit dari kedudukan p dan mengembalikan nilai yang diekstrak sebagai integer; Kod pemacu", "code": "using System ; class GFG { static int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; } public static void Main ( ) { int number = 171 , k = 5 , p = 2 ; Console . WriteLine ( \" The ▁ extracted ▁ number ▁ is ▁ \" + bitExtracted ( number , k , p ) ) ; } }"}
{"text": "Memaksimumkan nombor nombor yang tidak ditandatangani dengan menukar bit di kedudukan yang melampau. | C # Program untuk mencari nombor maksimum dengan menukar bit melampau. ; Melintasi bit dari kedua -dua ekstrem; Mendapatkan bit i - th dan j - th; Menukar bit jika lebih rendah penting adalah lebih besar daripada bit yang lebih tinggi dan dengan sewajarnya mengubah suai nombor; Kod pemacu", "code": "using System ; public class GFG { static int findMax ( int num ) { byte size_of_int = 4 ; int num_copy = num ; int j = size_of_int * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; } static public void Main ( ) { int num = 4 ; Console . Write ( findMax ( num ) ) ; } }"}
{"text": "Periksa dengan cekap sama ada n adalah pelbagai 4 atau tidak | C # pelaksanaan untuk memeriksa dengan cekap sama ada n adalah pelbagai 4 atau tidak; kaedah untuk memeriksa sama ada 'n' adalah pelbagai 4 atau tidak; jika benar, maka 'n' adalah pelbagai 4; lain 'n' bukanlah pelbagai 4; Kaedah Pemandu", "code": "using System ; class GFG { static bool isAMultipleOf4 ( int n ) { if ( ( n & 3 ) == 0 ) return true ; return false ; } public static void Main ( ) { int n = 16 ; Console . WriteLine ( isAMultipleOf4 ( n ) ? \" Yes \" : \" No \" ) ; } }"}
{"text": "Kirakan persegi nombor tanpa menggunakan *, / dan pow () | C # penyelesaian mudah untuk mengira persegi tanpa menggunakan * dan pow (); mengendalikan input negatif; Memulakan hasil; Tambah n ke res n - 1 kali; Kod pemacu", "code": "using System ; class GFG { public static int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; } public static void Main ( ) { for ( int n = 1 ; n <= 5 ; n ++ ) Console . WriteLine ( \" n ▁ = ▁ \" + n + \" , ▁ n ^ 2 ▁ = ▁ \" + square ( n ) ) ; } }"}
{"text": "Cari titik yang terletak di dalam Kuadrat yang tepat K yang diberikan | C # pelaksanaan pendekatan; Kod pemacu", "code": "using System ; class GFG { static int PointInKSquares ( int n , int [ ] a , int k ) { Array . Sort ( a ) ; return a [ n - k ] ; } public static void Main ( String [ ] args ) { int k = 2 ; int [ ] a = { 1 , 2 , 3 , 4 } ; int n = a . Length ; int x = PointInKSquares ( n , a , k ) ; Console . WriteLine ( \" ( \" + x + \" , ▁ \" + x + \" ) \" ) ; } }"}
{"text": "Bilangan N digit Nombor Langkah | Penyelesaian Dioptimumkan Ruang | C # Program untuk mengira bilangan nombor loncatan n digit. ; fungsi yang mengira jawapannya; DP [J] Kedai kiraan saya angka melangkah angka yang berakhir dengan digit j. ; Untuk menyimpan hasil panjang i - 1 sebelum mengemas kini dp [j] untuk panjang i. ; Jika n adalah 1 maka jawapannya akan menjadi 10 .; Memulakan nilai untuk mengira digit sama dengan 1 .; Mengira nilai untuk mengira digit lebih daripada 1 .; Jika angka berakhir adalah 0; Jika angka berakhir adalah 9; Untuk digit lain. ; menyimpan jawapan terakhir; Kod pemacu", "code": "using System ; class GFG { static long answer ( int n ) { int [ ] dp = new int [ 10 ] ; int [ ] prev = new int [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ; else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ; else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; } static void Main ( ) { int n = 2 ; Console . WriteLine ( answer ( n ) ) ; } }"}
{"text": "Perubahan minimum diperlukan untuk membuat urutan Catalan | C # pelaksanaan pendekatan; Untuk menyimpan nombor N First N; Berfungsi untuk mencari nombor N Catalan pertama; Memulakan dua nilai pertama dalam jadual; Penyertaan filong dalam Catalan [] menggunakan formula rekursif; Berfungsi untuk mengembalikan perubahan minimum yang diperlukan; Cari nombor N Catalan pertama; A dan B adalah dua nombor urutan Catalan pertama; Masukkan unsur -unsur Catalan pertama untuk ditetapkan; Jika elemen Catalan hadir dalam array kemudian keluarkannya dari set; Kembalikan bilangan elemen dalam set; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG1 { static int MAX = 100000 ; static long [ ] catalan = new long [ MAX ] ; static void catalanDP ( long n ) { catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } } static int CatalanSequence ( int [ ] arr , int n ) { catalanDP ( n ) ; HashSet < int > s = new HashSet < int > ( ) ; int a = 1 , b = 1 ; s . Add ( a ) ; if ( n >= 2 ) { s . Add ( b ) ; } for ( int i = 2 ; i < n ; i ++ ) { s . Add ( ( int ) catalan [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s . Contains ( arr [ i ] ) ) { s . Remove ( arr [ i ] ) ; } } return s . Count ; } public static void Main ( ) { int [ ] arr = { 1 , 1 , 2 , 5 , 41 } ; int n = arr . Length ; Console . WriteLine ( CatalanSequence ( arr , n ) ) ; } }"}
{"text": "Jumlah semua nombor komposit dari indeks ganjil array yang diberikan | C # pelaksanaan untuk mencari jumlah semua nombor komposit dari indeks ganjil array yang diberikan; Berfungsi untuk memeriksa nombor komposit; Periksa sama ada faktor lebih besar daripada 2; Semak sama ada nombor itu komposit atau tidak; Berfungsi untuk mencetak jumlah semua nombor komposit dalam array; Berulang untuk indeks ganjil dalam array; Semak sama ada nombor itu komposit kemudian tambahkannya ke jumlah; mengembalikan jumlahnya; Kod pemacu", "code": "using System ; class GFG { static int composite ( int n ) { int flag = 0 ; int c = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( n % j == 0 ) { c += 1 ; } } if ( c >= 3 ) flag = 1 ; return flag ; } static void odd_indices ( int [ ] arr , int n ) { int sum = 0 ; for ( int k = 0 ; k < n ; k += 2 ) { int check = composite ( arr [ k ] ) ; if ( check == 1 ) sum += arr [ k ] ; } Console . Write ( sum + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 13 , 5 , 8 , 16 , 25 } ; int n = arr . Length ; odd_indices ( arr , n ) ; } }"}
{"text": "Pertanyaan pada kiraan mata terletak di dalam bulatan | C # kod untuk pertanyaan pada kiraan mata terletak di dalam bulatan; Pengkomputeran X ^ 2 + y ^ 2 untuk setiap titik yang diberikan dan menyusunnya. ; Kembali kiraan mata terletak di dalam atau pada lilitan bulatan menggunakan carian binari pada p [0. n - 1]; Program pemacu untuk menguji fungsi di atas; Kirakan jarak semua mata dan simpan jarak yang disusun supaya pertanyaan dapat berfungsi dalam O (logn) menggunakan carian binari. ; Cetak nombor mata dalam lingkaran radius 3 .; Cetak nombor mata dalam lingkaran radius 32.", "code": "using System ; class GFG { public static void preprocess ( int [ ] p , int [ ] x , int [ ] y , int n ) { for ( int i = 0 ; i < n ; i ++ ) p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Array . Sort ( p ) ; } public static int query ( int [ ] p , int n , int rad ) { int start = 0 , end = n - 1 ; while ( ( end - start ) > 1 ) { int mid = ( start + end ) / 2 ; double tp = Math . Sqrt ( p [ mid ] ) ; if ( tp > ( rad * 1.0 ) ) end = mid - 1 ; else start = mid ; } double tp1 = Math . Sqrt ( p [ start ] ) ; double tp2 = Math . Sqrt ( p [ end ] ) ; if ( tp1 > ( rad * 1.0 ) ) return 0 ; else if ( tp2 <= ( rad * 1.0 ) ) return end + 1 ; else return start + 1 ; } public static void Main ( ) { int [ ] x = { 1 , 2 , 3 , - 1 , 4 } ; int [ ] y = { 1 , 2 , 3 , - 1 , 4 } ; int n = x . Length ; int [ ] p = new int [ n ] ; preprocess ( p , x , y , n ) ; Console . WriteLine ( query ( p , n , 3 ) ) ; Console . WriteLine ( query ( p , n , 32 ) ) ; } }"}
{"text": "Count bilangan panjang n mempunyai nombor perdana pada indeks ganjil dan nombor ganjil pada indeks walaupun | C # Program untuk mengira bilangan panjang n mempunyai nombor perdana pada indeks ganjil dan nombor ganjil pada indeks walaupun; berfungsi untuk mencari jumlah cara; Tiada indeks ganjil dalam nombor n - digit; Tidak ada indeks dalam nombor n - digit; Tidak ada cara untuk mengatur digit nombor utama dalam indeks ganjil; Tidak ada cara untuk mengatur digit nombor ganjil dalam indeks walaupun; mengembalikan jumlah cara; kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int find_Numb_ways ( int n ) { int odd_indices = n / 2 ; int even_indices = ( n / 2 ) + ( n % 2 ) ; int arr_odd = ( int ) Math . Pow ( 4 , odd_indices ) ; int arr_even = ( int ) Math . Pow ( 5 , even_indices ) ; return arr_odd * arr_even ; } public static void Main ( ) { int n = 4 ; Console . Write ( find_Numb_ways ( n ) ) ; } }"}
{"text": "Semak jika array yang diberikan disusun secara lingkaran atau tidak | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk memeriksa sama ada array disusun secara rohani atau tidak; Kedai memulakan indeks array; Kedai akhir indeks array; Jika arr [mula] lebih besar daripada arr [end]; Kemas kini Mula; Jika arr [end] lebih besar daripada arr [start]; Akhir kemas kini; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static bool isSpiralSorted ( int [ ] arr , int n ) { int start = 0 ; int end = n - 1 ; while ( start < end ) { if ( arr [ start ] > arr [ end ] ) { return false ; } start ++ ; if ( arr [ end ] > arr [ start ] ) { return false ; } end -- ; } return true ; } static void Main ( ) { int [ ] arr = { 1 , 10 , 14 , 20 , 18 , 12 , 5 } ; int N = arr . Length ; if ( isSpiralSorted ( arr , N ) ) Console . WriteLine ( \" YES \" ) ; else Console . WriteLine ( \" NO \" ) ; } }"}
{"text": "Cetak semua rentetan dari array yang diberikan yang boleh ditaip menggunakan kekunci dari satu baris papan kekunci QWERTY | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencetak semua rentetan yang boleh ditaip menggunakan kunci satu baris dalam papan kekunci QWERTY; Kedai baris nombor semua watak yang mungkin dari rentetan; Melintasi array; Jika rentetan semasa bukan rentetan kosong; Menetapkan benar / palsu jika rentetan boleh ditaip menggunakan kunci satu baris atau tidak; Kedai baris nombor watak pertama rentetan semasa; Kedai panjang perkataan; Melintasi rentetan semasa; Jika watak semasa tidak boleh ditaip menggunakan kekunci rownum sahaja; Bendera kemas kini; Jika rentetan semasa boleh ditaip menggunakan kekunci dari rownum sahaja; Cetak rentetan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void findWordsSameRow ( List < string > arr ) { Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; mp . Add ( ' q ' , 1 ) ; mp . Add ( ' w ' , 1 ) ; mp . Add ( ' e ' , 1 ) ; mp . Add ( ' r ' , 1 ) ; mp . Add ( ' t ' , 1 ) ; mp . Add ( ' y ' , 1 ) ; mp . Add ( ' u ' , 1 ) ; mp . Add ( ' i ' , 1 ) ; mp . Add ( ' o ' , 1 ) ; mp . Add ( ' p ' , 1 ) ; mp . Add ( ' a ' , 2 ) ; mp . Add ( ' s ' , 2 ) ; mp . Add ( ' d ' , 2 ) ; mp . Add ( ' f ' , 2 ) ; mp . Add ( ' g ' , 2 ) ; mp . Add ( ' h ' , 2 ) ; mp . Add ( ' j ' , 2 ) ; mp . Add ( ' k ' , 2 ) ; mp . Add ( ' l ' , 2 ) ; mp . Add ( ' z ' , 3 ) ; mp . Add ( ' x ' , 3 ) ; mp . Add ( ' c ' , 3 ) ; mp . Add ( ' v ' , 3 ) ; mp . Add ( ' b ' , 3 ) ; mp . Add ( ' n ' , 3 ) ; mp . Add ( ' m ' , 3 ) ; foreach ( string word in arr ) { if ( word . Length != 0 ) { bool flag = true ; int rowNum = mp [ char . ToLower ( word [ 0 ] ) ] ; int M = word . Length ; for ( int i = 1 ; i < M ; i ++ ) { if ( mp [ Char . ToLower ( word [ i ] ) ] != rowNum ) { flag = false ; break ; } } if ( flag ) { Console . Write ( word + \" ▁ \" ) ; } } } } public static void Main ( String [ ] args ) { List < string > words = new List < string > ( new string [ ] { \" Yeti \" , \" Had \" , \" GFG \" , \" comment \" } ) ; findWordsSameRow ( words ) ; } }"}
{"text": "Kiraan quadruples jenis yang diberikan dari array yang diberikan | C # Program pendekatan di atas; Fungsi untuk mencari kiraan jenis berikutnya; Menyimpan kiraan quadruples; Menjana semua kemungkinan kombinasi quadruples; Semak jika elemen 1 ST sama dengan elemen 3 RD; Semak jika elemen 2 ND adalah sama dengan elemen ke -4; Kod pemacu", "code": "using System ; class GFG { static int countSubsequece ( int [ ] a , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; Console . WriteLine ( countSubsequece ( a , 7 ) ) ; } }"}
{"text": "Watak terkecil dalam rentetan yang mempunyai jumlah minimum jarak antara pengulangan berturut -turut | C # Program untuk pendekatan di atas; Berfungsi untuk mencari watak berulang dengan jarak minimum; Menyimpan indeks pertama dan terakhir; Inisialisasi dengan - 1; Dapatkan nilai kejadian terakhir dan pertama; Mengemas kini indeks pertama; Mengemas kini indeks terakhir; Memulakan min; Dapatkan minimum; Nilai tidak boleh sama; Mengemas kini jarak minimum; kembali Ans; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static char minDistChar ( char [ ] s ) { int n = s . Length ; int [ ] first = new int [ 26 ] ; int [ ] last = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( first [ s [ i ] - ' a ' ] == - 1 ) { first [ s [ i ] - ' a ' ] = i ; } last [ s [ i ] - ' a ' ] = i ; } int min = int . MaxValue ; char ans = '1' ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( last [ i ] == first [ i ] ) continue ; if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = ( char ) ( i + ' a ' ) ; } } return ans ; } public static void Main ( string [ ] args ) { String str = \" geeksforgeeks \" ; Console . Write ( minDistChar ( str . ToCharArray ( ) ) ) ; } }"}
{"text": "Langkah -langkah minimum yang diperlukan untuk mencapai akhir matriks | Tetapkan 2 | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan langkah minimum yang diperlukan untuk mencapai akhir matriks; Array untuk menentukan sama ada sel telah dikunjungi sebelum ini; Giliran untuk BFS; Memulakan giliran; Untuk menyimpan kedalaman carian; Algoritma BFS; Saiz giliran semasa; Atas - kebanyakan elemen barisan; Untuk menyimpan indeks sel untuk kesederhanaan; Kes asas; Jika kita mencapai (n - 1, n - 1); Menandakan sel yang dikunjungi; Menolak sel -sel bersebelahan dalam barisan yang boleh dikunjungi dari sel semasa; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int n = 3 ; public class Pair { public int first , second ; public Pair ( int a , int b ) { first = a ; second = b ; } } static int minSteps ( int [ , ] arr ) { Boolean [ , ] v = new Boolean [ n , n ] ; Queue < Pair > q = new Queue < Pair > ( ) ; q . Enqueue ( new Pair ( 0 , 0 ) ) ; int depth = 0 ; while ( q . Count != 0 ) { int x = q . Count ; while ( x -- > 0 ) { Pair y = q . Peek ( ) ; int i = y . first , j = y . second ; q . Dequeue ( ) ; if ( v [ i , j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i , j ] = true ; if ( i + arr [ i , j ] < n ) q . Enqueue ( new Pair ( i + arr [ i , j ] , j ) ) ; if ( j + arr [ i , j ] < n ) q . Enqueue ( new Pair ( i , j + arr [ i , j ] ) ) ; } depth ++ ; } return - 1 ; } public static void Main ( ) { int [ , ] arr = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; Console . WriteLine ( minSteps ( arr ) ) ; } }"}
{"text": "Jurang terbesar dalam array | Program C # untuk mencari jurang terbesar antara dua elemen dalam array. ; fungsi untuk menyelesaikan masalah yang diberikan; Kod pemacu", "code": "using System ; class GFG { static int solve ( int [ ] a , int n ) { int max1 = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . Abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . Abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; } static public void Main ( ) { int [ ] arr = { - 1 , 2 , 3 , - 4 , - 10 , 22 } ; int size = arr . Length ; Console . WriteLine ( \" Largest ▁ gap ▁ is ▁ : ▁ \" + solve ( arr , size ) ) ; } }"}
{"text": "Jurang terbesar dalam array | Program C # untuk mencari jurang terbesar antara dua elemen dalam array. ; fungsi untuk menyelesaikan masalah yang diberikan; mencari maksimum dan minimum array; Kod pemacu", "code": "using System ; class GFG { static int solve ( int [ ] a , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . Abs ( min1 - max1 ) ; } public static void Main ( ) { int [ ] arr = { - 1 , 2 , 3 , 4 , - 10 } ; int size = arr . Length ; Console . WriteLine ( \" Largest ▁ gap ▁ is ▁ : ▁ \" + solve ( arr , size ) ) ; } }"}
{"text": "Cetak rentetan terbalik selepas mengeluarkan vokal | C # Program untuk mengeluarkan aksara dari rentetan terbalik di mana vokal hadir dalam rentetan asal; Fungsi untuk menggantikan rentetan; memulakan rentetan panjang n; Melintasi semua aksara rentetan; Berikan nilai kepada rentetan r dari indeks terakhir rentetan s; jika S [i] adalah konsonan maka cetak r [i]; Kod pemacu", "code": "using System ; class GFG { static void replaceOriginal ( String s , int n ) { char [ ] r = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != ' a ' && s [ i ] != ' e ' && s [ i ] != ' i ' && s [ i ] != ' o ' && s [ i ] != ' u ' ) { Console . Write ( r [ i ] ) ; } } Console . WriteLine ( \" \" ) ; } public static void Main ( String [ ] args ) { String s = \" geeksforgeeks \" ; int n = s . Length ; replaceOriginal ( s , n ) ; } }"}
{"text": "Semak jika rentetan boleh dibuat sama dengan rentetan lain dengan menukar atau penggantian aksara | C # Program untuk pendekatan di atas; Fungsi untuk mencari jika rentetan yang diberikan adalah sama atau tidak; Keadaan asas; Kedai kekerapan aksara string str1 dan str2; Traverse Strings str1 & str2 dan frekuensi kedai dalam [] dan b []; Semak sama ada kedua -dua rentetan mempunyai aksara yang sama atau tidak; Jika watak hadir dalam satu rentetan dan tidak dalam rentetan lain, kembali palsu; Susun array A [] dan B []; Periksa Array A dan B mengandungi kekerapan yang sama atau tidak; Jika frekuensi tidak sama selepas menyusun; Pada ketika ini, Str1 boleh ditukar kepada Str2; Kod pemacu", "code": "using System ; class GFG { static bool sameStrings ( string str1 , string str2 ) { int N = str1 . Length ; int M = str2 . Length ; if ( N != M ) { return false ; } int [ ] a = new int [ 256 ] ; int [ ] b = new int [ 256 ] ; for ( int j = 0 ; j < N ; j ++ ) { a [ str1 [ j ] - ' a ' ] ++ ; b [ str2 [ j ] - ' a ' ] ++ ; } int i = 0 ; while ( i < 256 ) { if ( ( a [ i ] == 0 && b [ i ] == 0 ) || ( a [ i ] != 0 && b [ i ] != 0 ) ) { i ++ ; } else { return false ; } } Array . Sort ( a ) ; Array . Sort ( b ) ; for ( int j = 0 ; j < 256 ; j ++ ) { if ( a [ j ] != b [ j ] ) return false ; } return true ; } static public void Main ( ) { string S1 = \" cabbba \" , S2 = \" abbccc \" ; if ( sameStrings ( S1 , S2 ) ) Console . Write ( \" YES \" + \" STRNEWLINE \" ) ; else Console . Write ( \" ▁ NO \" + \" STRNEWLINE \" ) ; } }"}
{"text": "Kurangkan tiga nombor dengan menurunkan pasangan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari operasi nombor minimum; Masukkan tiga nombor dalam array; Susun array; Kes 2; Kes 1; Kod pemacu; Diberikan a, b, c; Panggilan fungsi", "code": "using System ; class GFG { public static int solution ( int A , int B , int C ) { int [ ] arr = new int [ 3 ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; Array . Sort ( arr ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; } public static void Main ( String [ ] args ) { int A = 8 , B = 1 , C = 5 ; Console . WriteLine ( solution ( A , B , C ) ) ; } }"}
{"text": "Cari elemen dalam array yang disusun dan diputar dengan pendua | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan indeks kunci dalam arr [l. . h] jika kunci hadir sebaliknya kembali - 1; Kes yang rumit, hanya kemas kini kiri dan kanan; Jika arr [l ... pertengahan] disusun; Oleh kerana subarray ini disusun, kita dapat dengan cepat memeriksa sama ada kunci terletak pada mana -mana bahagian; Jika kunci tidak terletak pada separuh pertama subarray maka bahagikan separuh lagi ke dalam dua subarray sehingga kita dapat dengan cepat memeriksa apakah kunci terletak pada separuh lagi; Jika arr [l. . pertengahan] subarray pertama tidak disusun kemudian arr [pertengahan ... h] mesti disusun subarray; Kod pemacu", "code": "using System ; class GFG { static int search ( int [ ] arr , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { ++ l ; -- h ; return search ( arr , l , h , key ) } if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } public static void Main ( ) { int [ ] arr = { 3 , 3 , 1 , 2 , 3 , 3 } ; int n = arr . Length ; int key = 3 ; Console . WriteLine ( search ( arr , 0 , n - 1 , key ) ) ; } }"}
{"text": "Kes | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang disusun; Vektor untuk menyimpan huruf kecil dan huruf besar; Menyusun kedua -dua vektor; Jika watak semasa adalah huruf kecil kemudian pilih watak huruf kecil dari senarai yang disusun; Lain memilih watak huruf besar; Kembalikan rentetan yang disusun; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public static String getSortedString ( char [ ] s , int n ) { List < char > v1 = new List < char > ( ) ; List < char > v2 = new List < char > ( ) ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] > ' a ' && s [ i ] <= ' z ' ) v1 . Add ( s [ i ] ) ; if ( s [ i ] > ' A ' && s [ i ] <= ' z ' ) v2 . Add ( s [ i ] ) ; } v1 . Sort ( ) ; v2 . Sort ( ) ; int j = 0 ; i = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( s [ k ] > ' a ' && s [ k ] <= ' z ' ) { s [ k ] = v1 [ i ] ; ++ i ; } else if ( s [ k ] > ' A ' && s [ k ] <= ' Z ' ) { s [ k ] = v2 [ j ] ; ++ j ; } } return String . Join ( \" \" , s ) ; } public static void Main ( String [ ] args ) { String s = \" gEeksfOrgEEkS \" ; int n = s . Length ; Console . WriteLine ( getSortedString ( s . ToCharArray ( ) , n ) ) ; } }"}
{"text": "Semak jika rentetan mengandungi huruf berturut -turut dan setiap huruf berlaku tepat sekali | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk memeriksa sama ada keadaan memegang; Dapatkan panjang rentetan; Susun rentetan yang diberikan; ITERATE untuk setiap indeks dan periksa keadaan; Jika tidak berturut -turut; Kod pemacu; Contoh 1 st; Contoh 2 nd", "code": "using System ; using System . Collections ; class GfG { static bool check ( char [ ] s ) { int l = s . Length ; Array . Sort ( s ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; } public static void Main ( ) { string str = \" dcef \" ; if ( check ( str . ToCharArray ( ) ) == true ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; String str1 = \" xyza \" ; if ( check ( str1 . ToCharArray ( ) ) == true ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Subset terkecil dengan jumlah yang lebih besar daripada semua elemen lain | C # kod untuk mencari bilangan elemen minimum supaya jumlahnya lebih besar daripada jumlah elemen array. ; Fungsi untuk mencari elemen minimum yang diperlukan; Mengira separuh daripada jumlah array; Susun array dalam urutan menaik dan mula melintasi array dari jenis menaik dalam urutan menurun. ; Jumlah semasa lebih besar daripada jumlah; Kod pemacu", "code": "using System ; class GFG { static int minElements ( int [ ] arr , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; Array . Sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; } public static void Main ( ) { int [ ] arr = { 3 , 1 , 7 , 1 } ; int n = arr . Length ; Console . WriteLine ( minElements ( arr , n ) ) ; } }"}
{"text": "Peningkatan dan penurunan minimum oleh k setiap elemen pasangan yang diperlukan untuk membuat semua elemen array sama | C # Program untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada mungkin untuk membuat semua elemen array sama atau tidak; Menyimpan jumlah array; Melintasi array; Jika jumlahnya boleh dibahagikan dengan n; Jika tidak, tidak mungkin untuk membuat semua elemen array sama; Kod pemacu; Diberikan array; Saiz array", "code": "using System ; using System . Collections . Generic ; public class GFG { static void arrayElementEqual ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum % N == 0 ) { Console . WriteLine ( \" Yes \" ) ; } else { Console . Write ( \" No \" + \" STRNEWLINE \" ) ; } } static public void Main ( ) { int [ ] arr = { 1 , 5 , 6 , 4 } ; int N = arr . Length ; arrayElementEqual ( arr , N ) ; } }"}
{"text": "Susun semula Arahan untuk memaksimumkan jumlah GCD unsur -unsur array dengan indeks masing -masing | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari jumlah maksimum GCD (arr [i], i) dengan menyusun semula array; Kedai maksimum jumlah GCD (arr [i], i) dengan menyusun semula elemen array; Kemas kini res; Kod pemacu", "code": "using System ; class GFG { static int findMaxValByRearrArr ( int [ ] arr , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 1 } ; int N = arr . Length ; Console . Write ( findMaxValByRearrArr ( arr , N ) ) ; } }"}
{"text": "Poligon dengan sisi maksimum yang boleh ditulis dalam N | C # Program untuk pendekatan di atas; Berfungsi untuk mencari poligon maksimum yang boleh ditulis; Kes asas; Kembali n / 2 jika n adalah sebaliknya, kembali - 1; Kod pemacu; Diberikan n; Panggilan fungsi", "code": "using System ; class GFG { static int MaximumSides ( int n ) { if ( n < 4 ) return - 1 ; return n % 2 == 0 ? n / 2 : - 1 ; } public static void Main ( String [ ] args ) { int N = 8 ; Console . Write ( MaximumSides ( N ) ) ; } }"}
{"text": "Purata array yang dihasilkan oleh produk semua pasang array yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mencari min pasangan array arr []; Memulakan array jumlah akhiran; Membina array Jumlah Akhiran; Saiz pairproductarray; Kedai Jumlah PairProductArray; Simpan min; Cari min PairProductArray; Mengembalikan maksud yang dihasilkan; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "using System ; class GFG { static double pairProductMean ( int [ ] arr , int N ) { int [ ] suffixSumArray = new int [ N ] ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; } int length = ( N * ( N - 1 ) ) / 2 ; double res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; } double mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 4 , 8 } ; int N = arr . Length ; Console . WriteLine ( string . Format ( \" { 0:0.00 } \" , pairProductMean ( arr , N ) ) ) ; } }"}
{"text": "Kurangkan kiraan laluan unik dari kiri atas ke kanan bawah matriks dengan meletakkan k 1 s | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan nilai pekali binomial C (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Berfungsi untuk mencari kiraan minimum laluan dari kiri ke bawah ke bawah kanan dengan meletakkan k 1 s dalam matriks; Mengira cara tanpa 1 s; Mengira laluan dari titik permulaan ke titik pertengahan; Mengira laluan dari titik pertengahan ke titik akhir; Kod pemacu", "code": "using System ; class GFG { static int ncr ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static int countPath ( int N , int M , int K ) { int answer ; if ( K >= 2 ) answer = 0 ; else if ( K == 0 ) answer = ncr ( N + M - 2 , N - 1 ) ; else { answer = ncr ( N + M - 2 , N - 1 ) ; int X = ( N - 1 ) / 2 + ( M - 1 ) / 2 ; int Y = ( N - 1 ) / 2 ; int midCount = ncr ( X , Y ) ; X = ( ( N - 1 ) - ( N - 1 ) / 2 ) + ( ( M - 1 ) - ( M - 1 ) / 2 ) ; Y = ( ( N - 1 ) - ( N - 1 ) / 2 ) ; midCount *= ncr ( X , Y ) ; answer -= midCount ; } return answer ; } public static void Main ( String [ ] args ) { int N = 3 ; int M = 3 ; int K = 1 ; Console . Write ( countPath ( N , M , K ) ) ; } }"}
{"text": "Bilangan maksimum operasi yang diperlukan supaya tiada pasangan dari tumpang tindih matriks | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari kiraan maksimum operasi; Inisialisasi kiraan oleh 0; Melangkah ke atas pasangan yang tinggal; Semak jika operasi pertama terpakai; Semak jika operasi 2 ND terpakai; Jika tidak; Mengembalikan kiraan operasi; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int find_max ( List < pair > v , int n ) { int count = 0 ; if ( n >= 2 ) count = 2 ; else count = 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( v [ i - 1 ] . first < ( v [ i ] . first - v [ i ] . second ) ) count ++ ; else if ( v [ i + 1 ] . first > ( v [ i ] . first + v [ i ] . second ) ) { count ++ ; v [ i ] . first = v [ i ] . first + v [ i ] . second ; } else continue ; } return count ; } public static void Main ( String [ ] args ) { int n = 3 ; List < pair > v = new List < pair > ( ) ; v . Add ( new pair ( 10 , 20 ) ) ; v . Add ( new pair ( 15 , 10 ) ) ; v . Add ( new pair ( 20 , 16 ) ) ; Console . Write ( find_max ( v , n ) ) ; } }"}
{"text": "Count substrings yang dibentuk menggunakan set aksara yang diberikan sahaja | C # Program untuk pendekatan di atas; Fungsi untuk mencari bilangan substring yang boleh dibentuk menggunakan aksara yang diberikan; Array Boolean untuk menyimpan watak -watak yang tersedia; Tandakan indeks semua aksara yang tersedia sebagai 1; Memulakan lastpos sebagai - 1; Inisialisasi ANS dengan jumlah tidak mungkin substrings yang mungkin; Melintasi rentetan dari kiri ke kanan; Jika watak semasa tidak hadir dalam B; Tolak jumlah substrings yang mungkin; Kemas kini nilai LastPOS ke indeks semasa; Cetak jawapan terakhir; Kod pemacu; Diberikan rentetan; Diberikan pelbagai watak; Panggilan fungsi", "code": "using System ; class GFG { public static void numberofsubstrings ( String str , int k , char [ ] charArray ) { int N = str . Length ; int [ ] available = new int [ 26 ] ; for ( int i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - ' a ' ] = 1 ; } int lastPos = - 1 ; int ans = ( N * ( N + 1 ) ) / 2 ; for ( int i = 0 ; i < N ; i ++ ) { if ( available [ str [ i ] - ' a ' ] == 0 ) { ans -= ( ( i - lastPos ) * ( N - i ) ) ; lastPos = i ; } } Console . WriteLine ( ans ) ; } public static void Main ( String [ ] args ) { String str = \" abcb \" ; int k = 2 ; char [ ] charArray = { ' a ' , ' b ' } ; numberofsubstrings ( str , k , charArray ) ; } }"}
{"text": "Kos minimum untuk mencapai titik n dari 0 dengan dua operasi yang berbeza dibenarkan | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan kos minimum untuk mencapai tujuan; Memulakan kos kepada 0; pergi ke belakang sehingga kita mencapai kedudukan awal; Jika 2 * x melompat lebih baik daripada x + 1; Jika lompat x + 1 lebih baik; kos pulangan; Kod pemacu", "code": "class GFG { static int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( ( N & 1 ) > 0 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; } static void Main ( ) { int N = 9 , P = 5 , Q = 1 ; System . Console . WriteLine ( minCost ( N , P , Q ) ) ; } }"}
{"text": "Bilangan cara untuk mencapai pada node permulaan selepas perjalanan melalui tepi K dalam graf lengkap | C # Program untuk pendekatan di atas; Fungsi untuk mencari bilangan cara untuk mencapai dari nod 1 hingga 1 sekali lagi, selepas bergerak tepat K tepi; Memulakan array dp [], di mana dp [i] menyimpan bilangan cara untuk mencapai nod; Memulakan array DP dengan 0; Kes asas; Berulang untuk bilangan tepi bergerak; Jumlah akan menyimpan beberapa cara untuk mencapai semua nod; Berulang untuk setiap keadaan yang mungkin untuk langkah semasa; Kemas kini nilai array DP selepas perjalanan setiap kelebihan; Cetak dp [0] sebagai jawapannya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; class GFG { static void numberOfWays ( int n , int k ) { int [ ] dp = new int [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { int numWays = 0 ; for ( int j = 0 ; j < n ; j ++ ) { numWays += dp [ j ] ; } for ( int j = 0 ; j < n ; j ++ ) { dp [ j ] = numWays - dp [ j ] ; } } Console . Write ( dp [ 0 ] ) ; } static public void Main ( ) { int N = 5 , K = 3 ; numberOfWays ( N , K ) ; } }"}
{"text": "Kira penyahkodan mungkin urutan digit yang diberikan dengan aksara tersembunyi | C # Program untuk pendekatan di atas; Jika s [i] = = ' *' boleh ada 9 nilai yang mungkin *; Jika watak sebelumnya adalah 1 maka perkataan yang boleh dibentuk adalah k (11), l (12), m (13), n (14) o (15), p (16), q (17), r (18), s (19); Jika watak sebelumnya adalah 2 maka kata -kata yang boleh dibentuk ialah u (21), v (22), w (23), x (24) y (25), z (26); Jika digit sebelumnya * maka semua 15 2 - aksara digit boleh dibentuk; Jika s [i]! = ' *'; Menambah pertama di kedua jika s [i - 1] = 1; Menambah pertama dalam kedua jika s [i - 1] = = 2 dan s [i] <= '6'; jika s [i - 1] == ' *' Kesatuan di atas 2 kes perlu dilakukan; Kod pemacu", "code": "using System ; class GFG { static int M = 1000000007 ; static int waysOfDecoding ( string s ) { long first = 1 , second = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . Length ; i ++ ) { long temp = second ; if ( s [ i ] == ' * ' ) { second = 9 * second ; if ( s [ i - 1 ] == '1' ) second = ( second + 9 * first ) % M ; else if ( s [ i - 1 ] == '2' ) second = ( second + 6 * first ) % M ; else if ( s [ i - 1 ] == ' * ' ) second = ( second + 15 * first ) % M ; } else { second = s [ i ] != '0' ? second : 0 ; if ( s [ i - 1 ] == '1' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == ' * ' ) second = ( second + ( s [ i ] <= '6' ? 2 : 1 ) * first ) % M ; } first = temp ; } return ( int ) second ; } static public void Main ( ) { string s = \" * \" ; Console . WriteLine ( waysOfDecoding ( s ) ) ; } }"}
{"text": "Kos minimum membeli sekurang -kurangnya x coklat | C # Program untuk pendekatan di atas; Fungsi untuk mengira kos minimum membeli coklat paling kurang x; Kes asas; Sertakan kotak i - th; Kecualikan kotak i - th; Mengembalikan minimum dua kes di atas; Kod pemacu; Diberikan array dan nilai x; Simpan saiz array; Cetak jawapannya", "code": "using System ; class GFG { static int findMinCost ( int [ , ] arr , int X , int n , int i = 0 ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return Int32 . MaxValue ; int inc = findMinCost ( arr , X - arr [ i , 0 ] , n , i + 1 ) ; if ( inc != Int32 . MaxValue ) inc += arr [ i , 1 ] ; int exc = findMinCost ( arr , X , n , i + 1 ) ; return Math . Min ( inc , exc ) ; } public static void Main ( ) { int [ , ] arr = { { 4 , 3 } , { 3 , 2 } , { 2 , 4 } , { 1 , 3 } , { 4 , 2 } } ; int X = 7 ; int n = arr . GetLength ( 0 ) ; int ans = findMinCost ( arr , X , n ) ; if ( ans != Int32 . MaxValue ) Console . Write ( ans ) ; else Console . Write ( - 1 ) ; } }"}
{"text": "Kebarangkalian bahawa jumlah semua nombor yang diperolehi membuang dadu n kali terletak di antara dua bilangan bulat yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mengira kebarangkalian bagi jumlah yang diberikan untuk menjadi sama dengan jumlah dalam n lontaran dadu; Kes asas; Kod pemacu; Cetak jawapannya", "code": "using System ; class GFG { static double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; } static void Main ( ) { int N = 4 , a = 13 , b = 17 ; double probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; Console . WriteLine ( Math . Round ( probability , 6 ) ) ; } }"}
{"text": "Langkah minimum untuk mengurangkan n hingga 0 dengan operasi yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari nombor minimum ke langkah untuk mengurangkan n hingga 0; Kes asas; Panggilan rekursif untuk mengira langkah minimum yang diperlukan; Kembalikan jawapannya; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "using System ; class GFG { static int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + Math . Min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; } public static void Main ( String [ ] args ) { int N = 6 ; Console . Write ( minDays ( N ) ) ; } }"}
