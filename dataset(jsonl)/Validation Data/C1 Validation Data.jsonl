{"text": "C pelaksanaan pendekatan", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencetak corak abjad n yang dikehendaki", "code": "void Alphabet_N_Pattern ( int N ) { int index , side_index , size ;"}
{"text": "Mengisytiharkan nilai hak, kiri dan pepenjuru", "code": "int Right = 1 , Left = 1 , Diagonal = 2 ;"}
{"text": "Gelung utama untuk baris", "code": "for ( index = 0 ; index < N ; index ++ ) {"}
{"text": "Untuk nilai kiri", "code": "printf ( \" % d \" , Left ++ ) ;"}
{"text": "Ruang untuk pepenjuru", "code": "for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) printf ( \" ▁ \" ) ;"}
{"text": "Keadaan untuk pepenjuru", "code": "if ( index != 0 && index != N - 1 ) printf ( \" % d \" , Diagonal ++ ) ; else printf ( \" ▁ \" ) ;"}
{"text": "Ruang untuk nilai yang betul", "code": "for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) printf ( \" ▁ \" ) ;"}
{"text": "Untuk nilai yang betul", "code": "printf ( \" % d \" , Right ++ ) ; printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( int argc , char * * argv ) {"}
{"text": "Saiz corak", "code": "int Size = 6 ;"}
{"text": "Memanggil fungsi untuk mencetak corak yang dikehendaki", "code": "Alphabet_N_Pattern ( Size ) ; }"}
{"text": "Penyelesaian berasaskan pengaturcaraan dinamik yang menggunakan Jadual P [] [] untuk mengira pekali permutasi", "code": "#include <bits/stdc++.h>"}
{"text": "Mengembalikan nilai pekali permutasi p (n, k)", "code": "int permutationCoeff ( int n , int k ) { int P [ n + 1 ] [ k + 1 ] ;"}
{"text": "Kirakan nilai pekali permutasi dengan cara bawah", "code": "for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= std : : min ( i , k ) ; j ++ ) {"}
{"text": "Kes asas", "code": "if ( j == 0 ) P [ i ] [ j ] = 1 ;"}
{"text": "Hitung nilai menggunakan nilai yang disimpan sebelum ini", "code": "else P [ i ] [ j ] = P [ i - 1 ] [ j ] + ( j * P [ i - 1 ] [ j - 1 ] ) ;"}
{"text": "Langkah ini penting kerana p (i, j) = 0 untuk j> i", "code": "P [ i ] [ j + 1 ] = 0 ; } } return P [ n ] [ k ] ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 10 , k = 2 ; printf ( \" Value ▁ of ▁ P ( % d , ▁ % d ) ▁ is ▁ % d ▁ \" , n , k , permutationCoeff ( n , k ) ) ; return 0 ; }"}
{"text": "Penyelesaian O (n) yang menggunakan fakta jadual [] untuk mengira pekali permutasi", "code": "#include <bits/stdc++.h>"}
{"text": "Mengembalikan nilai pekali permutasi p (n, k)", "code": "int permutationCoeff ( int n , int k ) { int fact [ n + 1 ] ;"}
{"text": "Kes asas", "code": "fact [ 0 ] = 1 ;"}
{"text": "Hitung Faktorial Nilai Sehingga N", "code": "for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ;"}
{"text": "P (n, k) = n! / (n - k)!", "code": "return fact [ n ] / fact [ n - k ] ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 10 , k = 2 ; printf ( \" Value ▁ of ▁ P ( % d , ▁ % d ) ▁ is ▁ % d ▁ \" , n , k , permutationCoeff ( n , k ) ) ; return 0 ; }"}
{"text": "Penyelesaian rekursif untuk masalah jumlah subset", "code": "#include <stdio.h>"}
{"text": "Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan", "code": "bool isSubsetSum ( int set [ ] , int n , int sum ) {"}
{"text": "Kes asas", "code": "if ( sum == 0 ) return true ; if ( n == 0 ) return false ;"}
{"text": "Sekiranya elemen terakhir lebih besar daripada jumlah, maka abaikannya", "code": "if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ;"}
{"text": "Selain itu, periksa sama ada jumlahnya boleh diperolehi oleh mana -mana yang berikut: (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir", "code": "return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) ; else printf ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) ; return 0 ; }"}
{"text": "Siri nombor pell iterative di c", "code": "#include <stdio.h>"}
{"text": "hitung nombor pell nth", "code": "int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c , i ; for ( i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }"}
{"text": "fungsi pemacu", "code": "int main ( ) { int n = 4 ; printf ( \" % d \" , pell ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari faktorial nombor tertentu", "code": "#include < stdio . h"}
{"text": "berfungsi untuk mencari faktorial nombor yang diberikan", "code": "unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int num = 5 ; printf ( \" Factorial ▁ of ▁ % d ▁ is ▁ % d \" , num , factorial ( num ) ) ; return 0 ; }"}
{"text": "Program mudah untuk mencari subarray terbesar dengan jumlah yang sama 0 s dan 1 s", "code": "#include <stdio.h>"}
{"text": "Fungsi ini mencetak indeks permulaan dan akhir subarray terbesar dengan bilangan yang sama 0 s dan 1 s. Juga mengembalikan saiz subarray tersebut.", "code": "int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , startindex ;"}
{"text": "Pilih titik permulaan seperti saya", "code": "for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ;"}
{"text": "Pertimbangkan semua subarray bermula dari i", "code": "for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ;"}
{"text": "Sekiranya ini adalah subarray 0 jumlah, maka bandingkan dengan subarray saiz maksimum yang dikira setakat ini", "code": "if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == -1 ) printf ( \" No ▁ such ▁ subarray \" ) ; else printf ( \" % d ▁ to ▁ % d \" , startindex , startindex + maxsize - 1 ) ; return maxsize ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSubArray ( arr , size ) ; return 0 ; }"}
{"text": "Program c untuk menggambarkan pendekatan berulang untuk carian ternary", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk melakukan carian ternary", "code": "int ternarySearch ( int l , int r , int key , int ar [ ] ) { while ( r >= l ) {"}
{"text": "Cari Mid1 dan Mid2", "code": "int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ;"}
{"text": "Periksa sama ada kunci hadir di mana -mana pertengahan", "code": "if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; }"}
{"text": "Oleh kerana kunci tidak hadir pada pertengahan, periksa di mana rantau ia hadir kemudian ulangi operasi carian di rantau itu", "code": "if ( key < ar [ mid1 ] ) {"}
{"text": "Kunci terletak di antara l dan pertengahan1", "code": "r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) {"}
{"text": "Kunci terletak di antara pertengahan 2 dan r", "code": "l = mid2 + 1 ; } else {"}
{"text": "Kunci terletak di antara pertengahan1 dan pertengahan2", "code": "l = mid1 + 1 ; r = mid2 - 1 ; } }"}
{"text": "Kunci tidak dijumpai", "code": "return -1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int l , r , p , key ;"}
{"text": "Dapatkan array menyusun array jika tidak disusun", "code": "int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ;"}
{"text": "Indeks permulaan", "code": "l = 0 ;"}
{"text": "panjang array", "code": "r = 9 ;"}
{"text": "Kunci untuk dicari dalam pelbagai", "code": "key = 5 ;"}
{"text": "Cari kunci menggunakan ternarysearch", "code": "p = ternarySearch ( l , r , key , ar ) ;"}
{"text": "Cetak hasilnya", "code": "printf ( \" Index ▁ of ▁ % d ▁ is ▁ % d STRNEWLINE \" , key , p ) ;"}
{"text": "Kunci untuk dicari dalam pelbagai", "code": "key = 50 ;"}
{"text": "Cari kunci menggunakan ternarysearch", "code": "p = ternarySearch ( l , r , key , ar ) ;"}
{"text": "Cetak hasilnya", "code": "printf ( \" Index ▁ of ▁ % d ▁ is ▁ % d \" , key , p ) ; }"}
{"text": "Program C untuk mencari elemen minimum dalam array yang disusun dan diputar", "code": "#include <stdio.h> NEW_LINE int findMin ( int arr [ ] , int low , int high ) {"}
{"text": "Keadaan ini diperlukan untuk mengendalikan kes apabila array tidak diputar sama sekali", "code": "if ( high < low ) return arr [ 0 ] ;"}
{"text": "Sekiranya hanya ada satu elemen yang tersisa", "code": "if ( high == low ) return arr [ low ] ;"}
{"text": "Cari pertengahan", "code": "int mid = low + ( high - low ) / 2 ;"}
{"text": "Semak jika elemen (pertengahan + 1) adalah elemen minimum. Pertimbangkan kes seperti {3, 4, 5, 1, 2}", "code": "if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ;"}
{"text": "Periksa sama ada pertengahan itu adalah elemen minimum", "code": "if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ;"}
{"text": "Tentukan sama ada kita perlu pergi ke separuh kiri atau kanan", "code": "if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; printf ( \" The ▁ minimum ▁ element ▁ is ▁ % d STRNEWLINE \" , findMin ( arr1 , 0 , n1 - 1 ) ) ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printf ( \" The ▁ minimum ▁ element ▁ is ▁ % d STRNEWLINE \" , findMin ( arr2 , 0 , n2 - 1 ) ) ; int arr3 [ ] = { 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; printf ( \" The ▁ minimum ▁ element ▁ is ▁ % d STRNEWLINE \" , findMin ( arr3 , 0 , n3 - 1 ) ) ; int arr4 [ ] = { 1 , 2 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; printf ( \" The ▁ minimum ▁ element ▁ is ▁ % d STRNEWLINE \" , findMin ( arr4 , 0 , n4 - 1 ) ) ; int arr5 [ ] = { 2 , 1 } ; int n5 = sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ; printf ( \" The ▁ minimum ▁ element ▁ is ▁ % d STRNEWLINE \" , findMin ( arr5 , 0 , n5 - 1 ) ) ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ; printf ( \" The ▁ minimum ▁ element ▁ is ▁ % d STRNEWLINE \" , findMin ( arr6 , 0 , n6 - 1 ) ) ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = sizeof ( arr7 ) / sizeof ( arr7 [ 0 ] ) ; printf ( \" The ▁ minimum ▁ element ▁ is ▁ % d STRNEWLINE \" , findMin ( arr7 , 0 , n7 - 1 ) ) ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = sizeof ( arr8 ) / sizeof ( arr8 [ 0 ] ) ; printf ( \" The ▁ minimum ▁ element ▁ is ▁ % d STRNEWLINE \" , findMin ( arr8 , 0 , n8 - 1 ) ) ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = sizeof ( arr9 ) / sizeof ( arr9 [ 0 ] ) ; printf ( \" The ▁ minimum ▁ element ▁ is ▁ % d STRNEWLINE \" , findMin ( arr9 , 0 , n9 - 1 ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari elemen terkecil terkecil dan kedua", "code": "#include <stdio.h> NEW_LINE #include <limits.h>"}
{"text": "Untuk int_max", "code": "void print2Smallest ( int arr [ ] , int arr_size ) { int i , first , second ;"}
{"text": "Harus ada dua elemen", "code": "if ( arr_size < 2 ) { printf ( \" ▁ Invalid ▁ Input ▁ \" ) ; return ; } first = second = INT_MAX ; for ( i = 0 ; i < arr_size ; i ++ ) {"}
{"text": "Sekiranya elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -dua dan kedua", "code": "if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; }"}
{"text": "Sekiranya Arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua", "code": "else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MAX ) printf ( \" There ▁ is ▁ no ▁ second ▁ smallest ▁ element STRNEWLINE \" ) ; else printf ( \" The ▁ smallest ▁ element ▁ is ▁ % d ▁ and ▁ second ▁ \" \" Smallest ▁ element ▁ is ▁ % d STRNEWLINE \" , first , second ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2Smallest ( arr , n ) ; return 0 ; }"}
{"text": "Pulangan benar jika terdapat subset dengan jumlah yang diberikan dalam arr []", "code": "#include <stdio.h> NEW_LINE #include <stdbool.h> NEW_LINE bool isSubsetSum ( int arr [ ] , int n , int sum ) {"}
{"text": "Nilai subset [i % 2] [j] akan benar jika terdapat subset jumlah J dalam arr [0, 1, .... , i - 1]", "code": "bool subset [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) {"}
{"text": "Subset dengan jumlah 0 selalu mungkin", "code": "if ( j == 0 ) subset [ i % 2 ] [ j ] = true ;"}
{"text": "Sekiranya tidak ada unsur tidak ada jumlah yang mungkin", "code": "else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 6 , 2 , 5 } ; int sum = 7 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSubsetSum ( arr , n , sum ) == true ) printf ( \" There ▁ exists ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) ; else printf ( \" No ▁ subset ▁ exists ▁ with ▁ given ▁ sum \" ) ; return 0 ; }"}
{"text": "Program untuk mencari elemen majoriti dalam pelbagai", "code": "#include <stdio.h> NEW_LINE #define bool  int NEW_LINE int findCandidate ( int * , int ) ; bool isMajority ( int * , int , int ) ;"}
{"text": "Berfungsi untuk mencari calon untuk majoriti", "code": "int findCandidate ( int a [ ] , int size ) { int maj_index = 0 , count = 1 ; int i ; for ( i = 1 ; i < size ; i ++ ) { if ( a [ maj_index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj_index = i ; count = 1 ; } } return a [ maj_index ] ; }"}
{"text": "Berfungsi untuk memeriksa sama ada calon berlaku lebih daripada n / 2 * kali", "code": "bool isMajority ( int a [ ] , int size , int cand ) { int i , count = 0 ; for ( i = 0 ; i < size ; i ++ ) if ( a [ i ] == cand ) count ++ ; if ( count > size / 2 ) return 1 ; else return 0 ; }"}
{"text": "Berfungsi untuk mencetak elemen majoriti", "code": "void printMajority ( int a [ ] , int size ) {"}
{"text": "Cari calon untuk majoriti", "code": "int cand = findCandidate ( a , size ) ;"}
{"text": "Cetak calon jika ia adalah majoriti", "code": "if ( isMajority ( a , size , cand ) ) printf ( \" ▁ % d ▁ \" , cand ) ; else printf ( \" No ▁ Majority ▁ Element \" ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int a [ ] = { 1 , 3 , 3 , 1 , 2 } ; int size = ( sizeof ( a ) ) / sizeof ( a [ 0 ] ) ;"}
{"text": "Panggilan fungsi", "code": "printMajority ( a , size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Penyelesaian pengaturcaraan dinamik untuk masalah jumlah subset", "code": "#include <stdio.h>"}
{"text": "Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan", "code": "bool isSubsetSum ( int set [ ] , int n , int sum ) {"}
{"text": "Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i", "code": "bool subset [ n + 1 ] [ sum + 1 ] ;"}
{"text": "Sekiranya jumlahnya 0, maka jawapannya benar", "code": "for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ;"}
{"text": "Sekiranya jumlahnya tidak 0 dan ditetapkan kosong, maka jawapannya palsu", "code": "for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ;"}
{"text": "Isi jadual subset dengan cara bawah", "code": "for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } }"}
{"text": "Uncomment Kod ini untuk mencetak jadual", "code": "for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( \" % 4d \" , subset [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } return subset [ n ] [ sum ] ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) ; else printf ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) ; return 0 ; }"}
{"text": "Berfungsi untuk memeriksa sama ada x adalah kuasa 2", "code": "bool isPowerOfTwo ( int x ) {"}
{"text": "X pertama dalam ungkapan di bawah adalah untuk kes apabila x adalah 0", "code": "return x && ( ! ( x & ( x - 1 ) ) ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { isPowerOfTwo ( 31 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; isPowerOfTwo ( 64 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Program c untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n", "code": "#include <stdio.h> NEW_LINE unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ;"}
{"text": "Pertama n dalam keadaan di bawah adalah untuk kes di mana n ialah 0", "code": "if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { unsigned int n = 0 ; printf ( \" % d \" , nextPowerOf2 ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk mengira bilangan cara untuk mencapai tangga ketika", "code": "#include <stdio.h>"}
{"text": "Fungsi rekursif yang digunakan oleh Countways", "code": "int countWays ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 4 ; printf ( \" % d \" , countWays ( n ) ) ; return 0 ; }"}
{"text": "Program C Rekursif Naive untuk mencari tugas maksimum.", "code": "#include <stdio.h>"}
{"text": "Mengembalikan maksimum antara 2 nombor", "code": "int max ( int x , int y ) { return ( x > y ? x : y ) ; }"}
{"text": "Mengembalikan jumlah tugas maksimum yang boleh dilakukan sehingga hari n", "code": "int maxTasks ( int high [ ] , int low [ ] , int n ) {"}
{"text": "Sekiranya n kurang daripada 0, maka tiada penyelesaian wujud", "code": "if ( n <= 0 ) return 0 ;"}
{"text": "Menentukan tugas mana yang hendak dipilih pada hari n, kemudian mengembalikan maksimum hingga hari itu", "code": "return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 5 ; int high [ ] = { 3 , 6 , 8 , 7 , 6 } ; int low [ ] = { 1 , 5 , 4 , 5 , 3 } ; printf ( \" % dn \" , maxTasks ( high , low , n ) ) ; return 0 ; }"}
{"text": "Program C untuk mengira tiada kata -kata dari rentetan input yang diberikan.", "code": "#include <stdio.h> NEW_LINE #define OUT0 NEW_LINE #define IN1"}
{"text": "Mengembalikan bilangan perkataan dalam str", "code": "unsigned countWords ( char * str ) { int state = OUT ;"}
{"text": "kiraan perkataan", "code": "unsigned wc = 0 ;"}
{"text": "Imbas semua watak satu persatu", "code": "while ( * str ) {"}
{"text": "Sekiranya watak seterusnya adalah pemisah, tetapkan keadaan sebagai keluar", "code": "if ( * str == ' ▁ ' * str == ' ' * str == ' TABSYMBOL ' ) state = OUT ;"}
{"text": "Sekiranya watak seterusnya bukan pemisah kata dan keadaan keluar, maka tetapkan keadaan seperti dalam dan kenaikan perkataan", "code": "else if ( state == OUT ) { state = IN ; ++ wc ; }"}
{"text": "Pindah ke watak seterusnya", "code": "++ str ; } return wc ; }"}
{"text": "Program Pemandu ke TES di atas fungsi", "code": "int main ( void ) { char str [ ] = \" One ▁ twothree STRNEWLINE four TABSYMBOL five ▁ \" ; printf ( \" No ▁ of ▁ words ▁ : ▁ % u \" , countWords ( str ) ) ; return 0 ; }"}
{"text": "Program C ++ berasaskan DP untuk mencari tugas maksimum.", "code": "#include <stdio.h>"}
{"text": "Mengembalikan maksimum antara 2 nombor", "code": "int max ( int x , int y ) { return ( x > y ? x : y ) ; }"}
{"text": "Mengembalikan jumlah tugas maksimum yang boleh dilakukan sehingga hari n", "code": "int maxTasks ( int high [ ] , int low [ ] , int n ) {"}
{"text": "Task_dp array yang menyimpan tugas maksimum yang dilakukan", "code": "int task_dp [ n + 1 ] ;"}
{"text": "Jika n = 0, tiada penyelesaian wujud", "code": "task_dp [ 0 ] = 0 ;"}
{"text": "Sekiranya n = 1, tugas usaha yang tinggi pada hari itu akan menjadi penyelesaiannya", "code": "task_dp [ 1 ] = high [ 0 ] ;"}
{"text": "Isi keseluruhan array menentukan tugas mana yang hendak dipilih pada hari i", "code": "for ( int i = 2 ; i <= n ; i ++ ) task_dp [ i ] = max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 5 ; int high [ ] = { 3 , 6 , 8 , 7 , 6 } ; int low [ ] = { 1 , 5 , 4 , 5 , 3 } ; printf ( \" % d \" , maxTasks ( high , low , n ) ) ; return 0 ; }"}
{"text": "Program c berasaskan pengaturcaraan dinamik untuk masalah partition", "code": "#include <stdio.h>"}
{"text": "Pulangan benar jika arr [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu", "code": "bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ;"}
{"text": "Kirakan jumlah semua elemen", "code": "for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] [ n + 1 ] ;"}
{"text": "memulakan baris atas sebagai benar", "code": "for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ;"}
{"text": "Mulakan lajur paling kiri, kecuali bahagian [0] [0], sebagai 0", "code": "for ( i = 1 ; i <= sum / 2 ; i ++ ) part [ i ] [ 0 ] = false ;"}
{"text": "Isi jadual partition dengan cara bawah", "code": "for ( i = 1 ; i <= sum / 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } }"}
{"text": "Uncomment Bahagian ini untuk mencetak jadual", "code": "return part [ sum / 2 ] [ n ] ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 3 , 1 , 1 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Panggilan fungsi", "code": "if ( findPartiion ( arr , n ) == true ) printf ( \" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ sum \" ) ; else printf ( \" Can ▁ not ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ \" \" equal ▁ sum \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program C untuk melaksanakan DFS yang menerima semua rentetan yang tidak berakhir dengan \"The\"", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "DFA memberitahu nombor yang berkaitan dengan keadaan sekarang", "code": "int dfa = 0 ;"}
{"text": "Fungsi ini adalah untuk keadaan permulaan (zeroth) DFA", "code": "void start ( char c ) {"}
{"text": "Apabila menerima negeri pertama 't' atau 't' goto (1)", "code": "if ( c == ' t ' c == ' T ' ) dfa = 1 ; }"}
{"text": "Fungsi ini adalah untuk keadaan pertama DFA", "code": "void state1 ( char c ) {"}
{"text": "Apabila menerima negeri pertama 't' atau 't' goto (1)", "code": "if ( c == ' t ' c == ' T ' ) dfa = 1 ;"}
{"text": "Apabila menerima 'H' atau 'H' Goto Negeri Kedua (2)", "code": "else if ( c == ' h ' c == ' H ' ) dfa = 2 ;"}
{"text": "lain Goto bermula negeri (0)", "code": "else dfa = 0 ; }"}
{"text": "Fungsi ini adalah untuk keadaan kedua DFA", "code": "void state2 ( char c ) {"}
{"text": "Apabila menerima 'E' atau 'E' Goto Negeri Ketiga (3) Lain Goto bermula Negeri (0)", "code": "if ( c == ' e ' c == ' E ' ) dfa = 3 ; else if ( c == ' t ' c == ' T ' ) dfa = 1 ; else dfa = 0 ; }"}
{"text": "Fungsi ini adalah untuk keadaan ketiga DFA", "code": "void state3 ( char c ) {"}
{"text": "Apabila menerima 'T' atau 'T' Goto State First (1) Lain Goto State State (0)", "code": "if ( c == ' t ' c == ' T ' ) dfa = 1 ; else dfa = 0 ; } bool isAccepted ( char str [ ] ) {"}
{"text": "Panjang rentetan", "code": "int len = strlen ( str ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; }"}
{"text": "kod pemacu", "code": "int main ( ) { char str [ ] = \" forTHEgeeks \" ; if ( isAccepted ( str ) == true ) printf ( \" ACCEPTED STRNEWLINE \" ) ; else printf ( \" NOT ▁ ACCEPTED STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Program c untuk mengira siri berikut", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Berfungsi untuk mengira siri berikut", "code": "double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / pow ( i , i ) ; sums += ser ; } return sums ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 3 ; double res = Series ( n ) ; printf ( \" % .5f \" , res ) ; return 0 ; }"}
{"text": "Program c untuk menggambarkan pendekatan rekursif untuk carian ternary", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk melakukan carian ternary", "code": "int ternarySearch ( int l , int r , int key , int ar [ ] ) { if ( r >= l ) {"}
{"text": "Cari Mid1 dan Mid2", "code": "int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ;"}
{"text": "Periksa sama ada kunci hadir di mana -mana pertengahan", "code": "if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; }"}
{"text": "Oleh kerana kunci tidak hadir pada pertengahan, periksa di mana rantau ia hadir kemudian ulangi operasi carian di rantau itu", "code": "if ( key < ar [ mid1 ] ) {"}
{"text": "Kunci terletak di antara l dan pertengahan1", "code": "return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) {"}
{"text": "Kunci terletak di antara pertengahan 2 dan r", "code": "return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else {"}
{"text": "Kunci terletak di antara pertengahan1 dan pertengahan2", "code": "return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } }"}
{"text": "Kunci tidak dijumpai", "code": "return -1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int l , r , p , key ;"}
{"text": "Dapatkan array menyusun array jika tidak disusun", "code": "int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ;"}
{"text": "Indeks permulaan", "code": "l = 0 ;"}
{"text": "panjang array", "code": "r = 9 ;"}
{"text": "Kunci untuk dicari dalam pelbagai", "code": "key = 5 ;"}
{"text": "Cari kunci menggunakan ternarysearch", "code": "p = ternarySearch ( l , r , key , ar ) ;"}
{"text": "Cetak hasilnya", "code": "printf ( \" Index ▁ of ▁ % d ▁ is ▁ % d STRNEWLINE \" , key , p ) ;"}
{"text": "Kunci untuk dicari dalam pelbagai", "code": "key = 50 ;"}
{"text": "Cari kunci menggunakan ternarysearch", "code": "p = ternarySearch ( l , r , key , ar ) ;"}
{"text": "Cetak hasilnya", "code": "printf ( \" Index ▁ of ▁ % d ▁ is ▁ % d \" , key , p ) ; }"}
{"text": "Fungsi ini menambah [] [] dan b [] [], dan menyimpan hasil dalam c [] []", "code": "void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; add ( A , B , C ) ; printf ( \" Result ▁ matrix ▁ is ▁ STRNEWLINE \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) printf ( \" % d ▁ \" , C [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "Fungsi ini menolak B [] [] dari [] [], dan menyimpan hasil dalam C [] []", "code": "void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }"}
{"text": "Untuk menyimpan hasil", "code": "int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; subtract ( A , B , C ) ; printf ( \" Result ▁ matrix ▁ is ▁ STRNEWLINE \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) printf ( \" % d ▁ \" , C [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "Program c untuk memeriksa titik tetap dalam array menggunakan carian linear", "code": "#include <stdio.h> NEW_LINE int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; }"}
{"text": "Sekiranya tiada titik tetap hadir maka kembali - 1", "code": "return -1 ; }"}
{"text": "Program pemacu untuk menyemak fungsi di atas", "code": "int main ( ) { int arr [ ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Fixed ▁ Point ▁ is ▁ % d \" , linearSearch ( arr , n ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk memeriksa titik tetap dalam array menggunakan carian binari", "code": "#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ;"}
{"text": "rendah + (tinggi - rendah) / 2;", "code": "if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; }"}
{"text": "Kembali - 1 jika tidak ada titik tetap", "code": "return -1 ; }"}
{"text": "Program pemacu untuk menyemak fungsi di atas", "code": "int main ( ) { int arr [ 10 ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Fixed ▁ Point ▁ is ▁ % d \" , binarySearch ( arr , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "C Kod untuk mencari linearly x dalam arr []. Sekiranya X hadir kemudian kembalikan lokasinya, jika tidak, kembali - 1", "code": "#include <stdio.h> NEW_LINE int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return -1 ; }"}
{"text": "Kod pemacu", "code": "int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Panggilan fungsi", "code": "int result = search ( arr , n , x ) ; ( result == -1 ) ? printf ( \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ) : printf ( \" Element ▁ is ▁ present ▁ at ▁ index ▁ % d \" , result ) ; return 0 ; }"}
{"text": "Program c untuk mengira jenis", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define RANGE  255"}
{"text": "Fungsi utama yang menyusun rentetan yang diberikan [] dalam urutan abjad", "code": "void countSort ( char arr [ ] ) {"}
{"text": "Array watak output yang akan disusun arr", "code": "char output [ strlen ( arr ) ] ;"}
{"text": "Buat array kiraan untuk menyimpan kiraan aksara inidividul dan mulakan array kiraan sebagai 0", "code": "int count [ RANGE + 1 ] , i ; memset ( count , 0 , sizeof ( count ) ) ;"}
{"text": "Simpan kiraan setiap watak", "code": "for ( i = 0 ; arr [ i ] ; ++ i ) ++ count [ arr [ i ] ] ;"}
{"text": "Tukar kiraan [i] supaya kiraan [i] kini mengandungi kedudukan sebenar watak ini dalam array output", "code": "for ( i = 1 ; i <= RANGE ; ++ i ) count [ i ] += count [ i - 1 ] ;"}
{"text": "Bina pelbagai watak output", "code": "for ( i = 0 ; arr [ i ] ; ++ i ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; }"}
{"text": "Salin array output ke arr, supaya arr kini mengandungi aksara yang disusun", "code": "for ( i = 0 ; arr [ i ] ; ++ i ) arr [ i ] = output [ i ] ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char arr [ ] = \" geeksforgeeks \" ; countSort ( arr ) ; printf ( \" Sorted ▁ character ▁ array ▁ is ▁ % sn \" , arr ) ; return 0 ; }"}
{"text": "Pelaksanaan rekursif naif", "code": "#include <stdio.h>"}
{"text": "Mengembalikan nilai pekali binomial C (N, K)", "code": "int binomialCoeff ( int n , int k ) {"}
{"text": "Kes asas", "code": "if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ;"}
{"text": "Berulang", "code": "return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 5 , k = 2 ; printf ( \" Value ▁ of ▁ C ( % d , ▁ % d ) ▁ is ▁ % d ▁ \" , n , k , binomialCoeff ( n , k ) ) ; return 0 ; }"}
{"text": "Program C Rekursif untuk mencetak bilangan maksimum A menggunakan empat kunci berikut", "code": "#include <stdio.h>"}
{"text": "Fungsi rekursif yang mengembalikan rentetan panjang optimum untuk ketukan n", "code": "int findoptimal ( int N ) {"}
{"text": "Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7", "code": "if ( N <= 6 ) return N ;"}
{"text": "Memulakan hasil", "code": "int max = 0 ;"}
{"text": "Cuba semua rehat yang mungkin - mata untuk mana -mana kekunci n, kita perlu gelung dari n - 3 kekunci kembali ke 1 keystroke untuk mencari breakpoint 'b' selepas itu kita akan mempunyai ctrl - a, ctrl - c dan kemudian hanya ctrl - v sepanjang jalan.", "code": "int b ; for ( b = N - 3 ; b >= 1 ; b -- ) {"}
{"text": "Jika titik putus adalah s pada b 'th keystroke maka rentetan optimum akan mempunyai panjang (n-b-1)*skrin [b-1];", "code": "int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }"}
{"text": "Program Pemandu", "code": "int main ( ) { int N ;"}
{"text": "Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "for ( N = 1 ; N <= 20 ; N ++ ) printf ( \" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ % d ▁ keystrokes ▁ is ▁ % d STRNEWLINE \" , N , findoptimal ( N ) ) ; }"}
{"text": "Program c berasaskan pengaturcaraan yang dinamik untuk mencari bilangan maksimum yang boleh dicetak menggunakan empat kunci", "code": "#include <stdio.h>"}
{"text": "Fungsi ini mengembalikan rentetan panjang optimum untuk ketukan n", "code": "int findoptimal ( int N ) {"}
{"text": "Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7", "code": "if ( N <= 6 ) return N ;"}
{"text": "Arahan untuk menyimpan hasil subproblem", "code": "int screen [ N ] ;"}
{"text": "Untuk memilih titik putus", "code": "int b ;"}
{"text": "Memulakan Arus Panjang Optimal untuk Uptil 6 Strok Input.", "code": "int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ;"}
{"text": "Selesaikan semua subproblem dengan cara bawah", "code": "for ( n = 7 ; n <= N ; n ++ ) {"}
{"text": "Memulakan panjang rentetan optimum untuk ketukan n", "code": "screen [ n - 1 ] = 0 ;"}
{"text": "Untuk mana -mana kekunci n, kita perlu gelung dari n - 3 ketukan kembali ke 1 keystroke untuk mencari breakpoint 'b' selepas itu kita akan mempunyai ctrl - a, ctrl - c dan kemudian hanya ctrl - v sepanjang jalan.", "code": "for ( b = n - 3 ; b >= 1 ; b -- ) {"}
{"text": "Sekiranya titik putus berada di b 'th keystroke maka rentetan optimum akan mempunyai panjang (n-b-1)*skrin [b-1];", "code": "int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }"}
{"text": "Program Pemandu", "code": "int main ( ) { int N ;"}
{"text": "Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "for ( N = 1 ; N <= 20 ; N ++ ) printf ( \" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ % d ▁ keystrokes ▁ is ▁ % d STRNEWLINE \" , N , findoptimal ( N ) ) ; }"}
{"text": "Berfungsi untuk mengira x yang dibangkitkan kepada kuasa y", "code": "int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; }"}
{"text": "Program untuk menguji kuasa fungsi", "code": "int main ( ) { int x = 2 ; unsigned int y = 3 ; printf ( \" % d \" , power ( x , y ) ) ; return 0 ; }"}
{"text": "Berfungsi untuk mengira x yang dibangkitkan kepada kuasa y dalam o (logn)", "code": "int power ( int x , unsigned int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }"}
{"text": "Fungsi kuasa versi lanjutan yang boleh berfungsi untuk float x dan negatif y", "code": "#include <stdio.h> NEW_LINE float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }"}
{"text": "Program untuk menguji kuasa fungsi", "code": "int main ( ) { float x = 2 ; int y = -3 ; printf ( \" % f \" , power ( x , y ) ) ; return 0 ; }"}
{"text": "Mengembalikan akar kuadrat n. Perhatikan bahawa fungsi", "code": "float squareRoot ( float n ) {"}
{"text": "Kami menggunakan N sendiri sebagai penghampiran awal ini pasti dapat diperbaiki", "code": "float x = n ; float y = 1 ; float e = 0.000001 ;"}
{"text": "e memutuskan tahap ketepatan", "code": "while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 50 ; printf ( \" Square ▁ root ▁ of ▁ % d ▁ is ▁ % f \" , n , squareRoot ( n ) ) ; getchar ( ) ; }"}
{"text": "Mengembalikan purata baru selepas termasuk x", "code": "float getAvg ( int x ) { static int sum , n ; sum += x ; return ( ( ( float ) sum ) / ++ n ) ; }"}
{"text": "Mencetak purata aliran nombor", "code": "void streamAvg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( arr [ i ] ) ; printf ( \" Average ▁ of ▁ % d ▁ numbers ▁ is ▁ % f ▁ STRNEWLINE \" , i + 1 , avg ) ; } return ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; streamAvg ( arr , n ) ; return 0 ; }"}
{"text": "Program untuk mengira c (n, k)", "code": "#include <stdio.h>"}
{"text": "Mengembalikan nilai pekali binomial C (N, K)", "code": "int binomialCoeff ( int n , int k ) { int res = 1 ;"}
{"text": "Oleh kerana c (n, k) = c (n, n - k)", "code": "if ( k > n - k ) k = n - k ;"}
{"text": "Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]", "code": "for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 8 , k = 2 ; printf ( \" Value ▁ of ▁ C ( % d , ▁ % d ) ▁ is ▁ % d ▁ \" , n , k , binomialCoeff ( n , k ) ) ; return 0 ; }"}
{"text": "Program untuk mencetak semua faktor utama", "code": "# include <stdio.h> NEW_LINE # include <math.h>"}
{"text": "Fungsi untuk mencetak semua faktor utama nombor n tertentu", "code": "void primeFactors ( int n ) {"}
{"text": "Cetak bilangan 2 s yang membahagikan n", "code": "while ( n % 2 == 0 ) { printf ( \" % d ▁ \" , 2 ) ; n = n / 2 ; }"}
{"text": "n mesti ganjil pada ketika ini. Oleh itu, kita boleh melangkau satu elemen (nota i = i + 2)", "code": "for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) {"}
{"text": "Walaupun saya membahagikan n, cetak saya dan bahagikan n", "code": "while ( n % i == 0 ) { printf ( \" % d ▁ \" , i ) ; n = n / i ; } }"}
{"text": "Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor perdana lebih besar daripada 2", "code": "if ( n > 2 ) printf ( \" % d ▁ \" , n ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 315 ; primeFactors ( n ) ; return 0 ; }"}
{"text": "Program untuk mencetak semua gabungan saiz r dalam pelbagai saiz n", "code": "#include <stdio.h> NEW_LINE void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) ;"}
{"text": "Fungsi utama yang mencetak semua kombinasi saiz r dalam arr [] saiz n. Fungsi ini terutamanya menggunakan gabunganutil ()", "code": "void printCombination ( int arr [ ] , int n , int r ) {"}
{"text": "Arahan sementara untuk menyimpan semua gabungan satu persatu", "code": "int data [ r ] ;"}
{"text": "Cetak semua gabungan menggunakan data temprary array [] ''", "code": "combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; }"}
{"text": "arr [] - -> data array input [] - -> array sementara untuk menyimpan kombinasi semasa & akhir gabungan - -> menatap dan mengakhiri indeks dalam indeks arr [] - -> indeks semasa dalam data [] r - -> saiz kombinasi yang akan dicetak", "code": "void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) {"}
{"text": "Gabungan semasa sudah siap dicetak, mencetaknya", "code": "if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) printf ( \" % d ▁ \" , data [ j ] ) ; printf ( \" STRNEWLINE \" ) ; return ; }"}
{"text": "Gantikan indeks dengan semua elemen yang mungkin. Keadaan \"Akhir - I + 1 = u r - indeks\" memastikan bahawa termasuk satu elemen di indeks akan membuat gabungan dengan elemen yang tinggal di kedudukan yang tinggal", "code": "for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printCombination ( arr , n , r ) ; }"}
{"text": "Program untuk mencetak semua gabungan saiz r dalam pelbagai saiz n", "code": "#include <stdio.h> NEW_LINE void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) ;"}
{"text": "Fungsi utama yang mencetak semua kombinasi saiz r dalam arr [] saiz n. Fungsi ini terutamanya menggunakan gabunganutil ()", "code": "void printCombination ( int arr [ ] , int n , int r ) {"}
{"text": "Arahan sementara untuk menyimpan semua gabungan satu persatu", "code": "int data [ r ] ;"}
{"text": "Cetak semua gabungan menggunakan data temprary array [] ''", "code": "combinationUtil ( arr , n , r , 0 , data , 0 ) ; }"}
{"text": "arr [] - -> array input n - -> saiz array input r - -> saiz gabungan untuk dicetak indeks - -> indeks semasa dalam data [] data [] - -> array sementara untuk menyimpan gabungan semasa i - -> indeks elemen semasa dalam arr []", "code": "void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) {"}
{"text": "Perabot semasa sudah siap, cetaknya", "code": "if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) printf ( \" % d ▁ \" , data [ j ] ) ; printf ( \" STRNEWLINE \" ) ; return ; }"}
{"text": "Apabila tidak ada lagi elemen yang ada untuk dimasukkan ke dalam data []", "code": "if ( i >= n ) return ;"}
{"text": "Semasa dimasukkan, letakkan seterusnya di lokasi seterusnya", "code": "data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ;"}
{"text": "Semasa dikecualikan, ganti dengan seterusnya (perhatikan bahawa i + 1 diluluskan, tetapi indeks tidak berubah)", "code": "combinationUtil ( arr , n , r , index , data , i + 1 ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printCombination ( arr , n , r ) ; return 0 ; }"}
{"text": "Program c untuk mengira semua kumpulan saiz 2 atau 3 yang mungkin mempunyai jumlah sebanyak 3", "code": "#include <stdio.h>"}
{"text": "Mengembalikan kiraan semua kumpulan yang mungkin boleh dibentuk dari unsur -unsur [].", "code": "int findgroups ( int arr [ ] , int n ) {"}
{"text": "Buat array c [3] untuk menyimpan bilangan elemen dengan selebihnya 0, 1 dan 2. C [i] akan menyimpan kiraan elemen dengan selebihnya i", "code": "int c [ 3 ] = { 0 } , i ;"}
{"text": "Untuk menyimpan hasilnya", "code": "int res = 0 ;"}
{"text": "Kira elemen dengan selebihnya 0, 1 dan 2", "code": "for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ;"}
{"text": "Kes 3.", "code": "res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;"}
{"text": "Kes 3. B: Kumpulan Kumpulan Saiz 2 dengan satu elemen dengan 1 baki dan lain -lain dengan 2 selebihnya", "code": "res += c [ 1 ] * c [ 2 ] ;"}
{"text": "Kes 4.", "code": "res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ;"}
{"text": "Kes 4. B: Kumpulan Kumpulan Saiz 3 dengan semua 1 elemen yang tinggal", "code": "res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ;"}
{"text": "Kes 4. C: Kumpulan Kumpulan Saiz 3 dengan semua 2 elemen selebihnya", "code": "res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ;"}
{"text": "Kes 4.", "code": "res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;"}
{"text": "Kembalikan jumlah kiraan yang disimpan di res", "code": "return res ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 3 , 6 , 7 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Required ▁ number ▁ of ▁ groups ▁ are ▁ % d STRNEWLINE \" , findgroups ( arr , n ) ) ; return 0 ; }"}
{"text": "Pertama n dalam keadaan di bawah adalah untuk kes di mana n ialah 0", "code": "if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { unsigned int n = 0 ; printf ( \" % d \" , nextPowerOf2 ( n ) ) ; return 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { unsigned int n = 5 ; printf ( \" % d \" , nextPowerOf2 ( n ) ) ; return 0 ; }"}
{"text": "Cari kuasa seterusnya dua untuk n. Jika n sendiri adalah kuasa dua maka kembali n", "code": "unsigned int nextPowerOf2 ( unsigned int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { unsigned int n = 5 ; printf ( \" % d \" , nextPowerOf2 ( n ) ) ; return 0 ; }"}
{"text": "Program C untuk menyusun array binari dalam satu pas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk meletakkan semua 0 s di kiri dan semua 1 s di sebelah kanan", "code": "void segregate0and1 ( int arr [ ] , int size ) {"}
{"text": "Memulakan indeks kiri dan kanan", "code": "int left = 0 , right = size - 1 ; while ( left < right ) {"}
{"text": "Indeks kiri kenaikan semasa kita melihat 0 di sebelah kiri", "code": "while ( arr [ left ] == 0 && left < right ) left ++ ;"}
{"text": "Indeks penurunan betul sementara kita melihat 1 di sebelah kanan", "code": "while ( arr [ right ] == 1 && left < right ) right -- ;"}
{"text": "Jika kiri lebih kecil daripada kanan maka terdapat 1 di sebelah kiri dan 0 di sebelah kanan. Pertukaran arr [kiri] dan arr [kanan]", "code": "if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }"}
{"text": "Program Pemandu untuk Menguji", "code": "int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , arr_size ) ; printf ( \" Array ▁ after ▁ segregation ▁ \" ) ; for ( i = 0 ; i < 6 ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Untuk array yang diberikan [], mengembalikan maksimum J a i seperti arr [j]> arr [i]", "code": "int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = -1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int maxDiff = maxIndexDiff ( arr , n ) ; printf ( \" % d \" , maxDiff ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program untuk mencari tangga N - menggunakan saiz langkah 1 atau 2 atau 3.", "code": "#include <stdio.h>"}
{"text": "Mengembalikan kiraan cara untuk mencapai tangga N - menggunakan 1 atau 2 atau 3 langkah.", "code": "int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 4 ; printf ( \" % d STRNEWLINE \" , findStep ( n ) ) ; return 0 ; }"}
{"text": "Program C Rekursif untuk masalah partition", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h>"}
{"text": "Fungsi utiliti yang kembali benar jika terdapat subset arr [] dengan matahari sama dengan jumlah yang diberikan", "code": "bool isSubsetSum ( int arr [ ] , int n , int sum ) {"}
{"text": "Kes asas", "code": "if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ;"}
{"text": "Sekiranya elemen terakhir lebih besar daripada jumlah, maka abaikannya", "code": "if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ;"}
{"text": "Selain itu, periksa sama ada jumlahnya boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir", "code": "return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; }"}
{"text": "Pulangan benar jika arr [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu", "code": "bool findPartiion ( int arr [ ] , int n ) {"}
{"text": "Hitung jumlah elemen dalam pelbagai", "code": "int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;"}
{"text": "Sekiranya jumlahnya ganjil, tidak ada dua subset dengan jumlah yang sama", "code": "if ( sum % 2 != 0 ) return false ;"}
{"text": "Cari jika terdapat subset dengan jumlah yang sama dengan separuh daripada jumlah keseluruhan", "code": "return isSubsetSum ( arr , n , sum / 2 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 3 , 1 , 5 , 9 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Panggilan fungsi", "code": "if ( findPartiion ( arr , n ) == true ) printf ( \" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ \" \" of ▁ equal ▁ sum \" ) ; else printf ( \" Can ▁ not ▁ be ▁ divided ▁ into ▁ two ▁ subsets \" \" ▁ of ▁ equal ▁ sum \" ) ; return 0 ; }"}
{"text": "Program c untuk mencari watak pertama yang diulang", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int findRepeatFirstN2 ( char * s ) {"}
{"text": "ini adalah kaedah O (n ^ 2)", "code": "int p = -1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { char str [ ] = \" geeksforgeeks \" ; int pos = findRepeatFirstN2 ( str ) ; if ( pos == -1 ) printf ( \" Not ▁ found \" ) ; else printf ( \" % c \" , str [ pos ] ) ; return 0 ; }"}
{"text": "Program C untuk pendekatan di atas:", "code": "void reverseWords ( char * s ) { char * word_begin = NULL ;"}
{"text": "temp adalah untuk sempadan perkataan", "code": "char * temp = s ;"}
{"text": "Langkah 1 dari algoritma di atas", "code": "while ( * temp ) {"}
{"text": "Keadaan ini adalah untuk memastikan bahawa rentetan bermula dengan watak yang sah (bukan ruang) sahaja", "code": "if ( ( word_begin == NULL ) && ( * temp != ' ▁ ' ) ) { word_begin = temp ; } if ( word_begin && ( ( * ( temp + 1 ) == ' ▁ ' ) || ( * ( temp + 1 ) == ' \\0' ) ) ) { reverse ( word_begin , temp ) ; word_begin = NULL ; } temp ++ ; }"}
{"text": "Langkah 2 algoritma di atas", "code": "reverse ( s , temp - 1 ) ; }"}
{"text": "Program C Untuk mencari jumlah semua nombor palindromik panjang yang ganjil dalam julat yang diberikan", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h>"}
{"text": "Fungsi yang dikembalikan jika nombor yang diberikan adalah palindrome", "code": "bool isPalindrome ( int num ) { int reverse_num = 0 , remainder , temp ;"}
{"text": "Di sini kita menjana nombor baru (reverse_num) * dengan membalikkan digit nombor input asal", "code": "temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp /= 10 ; }"}
{"text": "Jika nombor input asal (num) adalah sama dengan * ke belakangnya (reverse_num) maka palindrome * lain tidak.", "code": "if ( reverse_num == num ) { return true ; } return false ; }"}
{"text": "Fungsi yang dikembalikan jika nombor yang diberikan adalah panjang ganjil", "code": "bool isOddLength ( int num ) { int count = 0 ; while ( num > 0 ) { num /= 10 ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; }"}
{"text": "Berfungsi untuk mengembalikan jumlah semua nombor palindromik panjang yang ganjil dalam julat yang diberikan", "code": "long sumOfAllPalindrome ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) {"}
{"text": "Sekiranya nombor adalah palindrome dan panjang ganjil", "code": "if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int L = 110 , R = 1130 ; printf ( \" % ld \" , sumOfAllPalindrome ( L , R ) ) ; }"}
{"text": "Code C untuk menolak satu dari nombor tertentu", "code": "#include <stdio.h> NEW_LINE int subtractOne ( int x ) { int m = 1 ;"}
{"text": "Flip semua bit set sehingga kita dapati 1", "code": "while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; }"}
{"text": "Flip paling tepat 1 bit", "code": "x = x ^ m ; return x ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { printf ( \" % d \" , subtractOne ( 13 ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengembalikan jumlah semua bilangan bulat di bawah n yang merupakan gandaan sama ada a atau b", "code": "int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ )"}
{"text": "Sekiranya saya adalah pelbagai a atau b", "code": "if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 10 , a = 3 , b = 5 ; printf ( \" % d \" , findSum ( n , a , b ) ) ; return 0 ; }"}
{"text": "Siri nombor Pell menggunakan rekursi dalam c", "code": "#include <stdio.h>"}
{"text": "hitung nombor pell nth", "code": "int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }"}
{"text": "fungsi pemacu", "code": "int main ( ) { int n = 4 ; printf ( \" % d \" , pell ( n ) ) ; return 0 ; }"}
{"text": "C Program untuk mencari x terbesar sedemikian rupa sehingga p * x membahagikan n!", "code": "#include <stdio.h>"}
{"text": "Mengembalikan kuasa terbesar P yang membahagikan N!", "code": "int largestPower ( int n , int p ) {"}
{"text": "Memulakan hasil", "code": "int x = 0 ;"}
{"text": "Kirakan x = n / p + n / (p ^ 2) + n / (p ^ 3) + ....", "code": "while ( n ) { n /= p ; x += n ; } return x ; }"}
{"text": "Program Pemandu", "code": "int main ( ) { int n = 10 , p = 3 ; printf ( \" The ▁ largest ▁ power ▁ of ▁ % d ▁ that ▁ divides ▁ % d ! ▁ is ▁ % d STRNEWLINE \" , p , n , largestPower ( n , p ) ) ; return 0 ; }"}
{"text": "Program c ++ untuk mencari faktorial nombor tertentu", "code": "#include <stdio.h> NEW_LINE int factorial ( int n ) {"}
{"text": "Baris tunggal untuk mencari faktorial", "code": "return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int num = 5 ; printf ( \" Factorial ▁ of ▁ % d ▁ is ▁ % d \" , num , factorial ( num ) ) ; return 0 ; }"}
{"text": "Program C untuk mengekstrak k bit dari kedudukan tertentu.", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengekstrak k bit dari kedudukan p dan mengembalikan nilai yang diekstrak sebagai integer", "code": "int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int number = 171 , k = 5 , p = 2 ; printf ( \" The ▁ extracted ▁ number ▁ is ▁ % d \" , bitExtracted ( number , k , p ) ) ; return 0 ; }"}
{"text": "Program C untuk mencari jurang terbesar antara dua elemen dalam array.", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "berfungsi untuk menyelesaikan masalah yang diberikan", "code": "int solve ( int a [ ] , int n ) { int max1 = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { -1 , 2 , 3 , -4 , -10 , 22 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Largest ▁ gap ▁ is ▁ : ▁ % d \" , solve ( arr , size ) ) ; return 0 ; }"}
{"text": "Program C untuk mencari jurang terbesar antara dua elemen dalam array.", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "berfungsi untuk menyelesaikan masalah yang diberikan", "code": "int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ;"}
{"text": "Mencari maksimum dan minimum pelbagai", "code": "for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return abs ( min1 - max1 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { -1 , 2 , 3 , 4 , -10 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Largest ▁ gap ▁ is ▁ : ▁ % d \" , solve ( arr , size ) ) ; return 0 ; }"}
