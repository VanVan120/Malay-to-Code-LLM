{"text": "Program untuk menukar sentimeter ke piksel | Berfungsi untuk menukar sentimeter ke piksel; Kod pemacu", "code": "< ? php function Conversion ( $ centi ) { $ pixels = ( 96 * $ centi ) / 2.54 ; echo ( $ pixels . \" \" ) ; } $ centi = 15 ; Conversion ( $ centi ) ; ? >"}
{"text": "Cari nilai maksimum nilai minimum array yang diubah suai | Berfungsi untuk mencari nilai maksimum nilai minimum array yang diubah suai; Untuk menyimpan nilai minimum array; Untuk menyimpan jumlah elemen array; Penyelesaian tidak mungkin; Zero adalah nilai yang mungkin; nilai minimum yang mungkin; nilai maksimum yang mungkin; untuk menyimpan jawapan yang diperlukan; Carian binari; Sekiranya pertengahan mungkin maka cuba tambah jawapan yang diperlukan; Jika pertengahan tidak mungkin maka penurunan jawapan yang diperlukan; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "< ? php function maxOfMin ( $ a , $ n , $ S ) { $ mi = PHP_INT_MAX ; $ s1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ s1 += $ a [ $ i ] ; $ mi = min ( $ a [ $ i ] , $ mi ) ; } if ( $ s1 < $ S ) return -1 ; if ( $ s1 == $ S ) return 0 ; $ low = 0 ; $ high = $ mi ; $ ans ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( $ s1 - ( $ mid * $ n ) >= $ S ) { $ ans = $ mid ; $ low = $ mid + 1 ; } else $ high = $ mid - 1 ; } return $ ans ; } $ a = array ( 10 , 10 , 10 , 10 , 10 ) ; $ S = 10 ; $ n = sizeof ( $ a ) ; echo maxOfMin ( $ a , $ n , $ S ) ; ? >"}
{"text": "Program untuk mencetak 'n' abjad menggunakan corak nombor dari 1 hingga n | Berfungsi untuk mencetak corak abjad n yang dikehendaki; Mengisytiharkan nilai -nilai hak, kiri dan pepenjuru; Gelung utama untuk baris; Untuk nilai kiri; Ruang untuk pepenjuru; Keadaan untuk pepenjuru; Ruang untuk nilai yang betul; Untuk nilai yang betul; Saiz corak; Memanggil fungsi untuk mencetak corak yang dikehendaki", "code": "< ? php function Alphabet_N_Pattern ( $ N ) { $ index ; $ side_index ; $ size ; $ Right = 1 ; $ Left = 1 ; $ Diagonal = 2 ; for ( $ index = 0 ; $ index < $ N ; $ index ++ ) { echo $ Left ++ ; for ( $ side_index = 0 ; $ side_index < 2 * ( $ index ) ; $ side_index ++ ) echo \" ▁ \" ; if ( $ index != 0 && $ index != $ N - 1 ) echo $ Diagonal ++ ; else echo \" ▁ \" ; for ( $ side_index = 0 ; $ side_index < 2 * ( $ N - $ index - 1 ) ; $ side_index ++ ) echo \" ▁ \" ; echo $ Right ++ ; echo \" STRNEWLINE \" ; } } $ Size = 6 ; Alphabet_N_Pattern ( $ Size ) ; ? >"}
{"text": "Semak jika jumlah digit nombor n membahagikannya | Berfungsi untuk memeriksa sama ada jumlah digit nombor membahagikannya; Hitung jumlah semua digit N; Kod pemacu", "code": "< ? php function isSumDivides ( $ N ) { $ temp = $ N ; $ sum = 0 ; while ( $ temp ) { $ sum += $ temp % 10 ; $ temp = ( int ) $ temp / 10 ; } if ( $ N % $ sum == 0 ) return 1 ; else return 0 ; } $ N = 12 ; if ( isSumDivides ( $ N ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Jumlah nombor dari 1 hingga N yang boleh dibahagikan dengan 3 atau 4 | Berfungsi untuk mengira jumlah nombor yang boleh dibahagi dengan 3 atau 4; Kod pemacu", "code": "< ? php function sum ( $ N ) { $ S1 ; $ S2 ; $ S3 ; $ S1 = ( ( $ N / 3 ) ) * ( 2 * 3 + ( $ N / 3 - 1 ) * 3 ) / 2 ; $ S2 = ( ( $ N / 4 ) ) * ( 2 * 4 + ( $ N / 4 - 1 ) * 4 ) / 2 ; $ S3 = ( ( $ N / 12 ) ) * ( 2 * 12 + ( $ N / 12 - 1 ) * 12 ) / 2 ; return $ S1 + $ S2 - $ S3 ; } $ N = 20 ; echo sum ( 12 ) ; ? >"}
{"text": "Seterusnya nombor yang lebih besar daripada n dengan betul -betul sedikit berbeza dalam perwakilan binari n | Berfungsi untuk mencari nombor seterusnya yang lebih besar daripada n dengan tepat satu yang berbeza dalam perwakilan binari n; Ia dijamin bahawa terdapat sedikit sifar dalam nombor; Jika bit beralih adalah sifar maka pecah; meningkatkan peralihan sedikit; meningkatkan kuasa 2; Tetapkan bit paling rendah nombor; Kod pemacu; Paparkan nombor seterusnya", "code": "< ? php function nextGreater ( $ N ) { $ power_of_2 = 1 ; $ shift_count = 0 ; while ( true ) { if ( ( ( $ N >> $ shift_count ) & 1 ) % 2 == 0 ) break ; $ shift_count ++ ; $ power_of_2 = $ power_of_2 * 2 ; } return ( $ N + $ power_of_2 ) ; } $ N = 11 ; echo \" The ▁ next ▁ number ▁ is ▁ = ▁ \" , nextGreater ( $ N ) ; ? >"}
{"text": "Nombor Tetranacci | Berfungsi untuk mencetak nombor tetranacci N - th; kes asas; Kod pemacu", "code": "< ? php function printTetra ( $ n ) { $ dp = array_fill ( 0 , $ n + 5 , 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = $ dp [ 2 ] = 1 ; $ dp [ 3 ] = 2 ; for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] + $ dp [ $ i - 3 ] + $ dp [ $ i - 4 ] ; echo $ dp [ $ n ] ; } $ n = 10 ; printTetra ( $ n ) ; ? >"}
{"text": "Jumlah maksimum dalam array bulat supaya tiada dua elemen bersebelahan | Fungsi untuk mengira jumlah dari kedudukan ke -0 ke (n - 2) kedudukan; Salin elemen array asal ke dp []; Cari elemen maksimum dalam array; Mulakan dari 2 nd hingga n - 1 th pos; melintasi semua pendekatan berpasangan bawah; DP - keadaan; Cari jumlah maksimum; mengembalikan maksimum; Berfungsi untuk mencari jumlah maksimum dari kedudukan 1 ke kedudukan n - 1 - th; Melintasi dari ketiga ke n - th pos; pendekatan bootom - up; keadaan DP; Cari jumlah maksimum; kembali max; Kod pemacu", "code": "< ? php function maxSum1 ( $ arr , $ n ) { $ dp [ $ n ] = array ( ) ; $ maxi = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ dp [ $ i ] = $ arr [ $ i ] ; if ( $ maxi < $ arr [ $ i ] ) $ maxi = $ arr [ $ i ] ; } for ( $ i = 2 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i - 1 ; $ j ++ ) { if ( $ dp [ $ i ] < $ dp [ $ j ] + $ arr [ $ i ] ) { $ dp [ $ i ] = $ dp [ $ j ] + $ arr [ $ i ] ; if ( $ maxi < $ dp [ $ i ] ) $ maxi = $ dp [ $ i ] ; } } } return $ maxi ; } function maxSum2 ( $ arr , $ n ) { $ dp [ $ n ] = array ( ) ; $ maxi = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ dp [ $ i ] = $ arr [ $ i ] ; if ( $ maxi < $ arr [ $ i ] ) $ maxi = $ arr [ $ i ] ; } for ( $ i = 3 ; $ i < $ n ; $ i ++ ) { for ( $ j = 1 ; $ j < $ i - 1 ; $ j ++ ) { if ( $ dp [ $ i ] < $ arr [ $ i ] + $ dp [ $ j ] ) { $ dp [ $ i ] = $ arr [ $ i ] + $ dp [ $ j ] ; if ( $ maxi < $ dp [ $ i ] ) $ maxi = $ dp [ $ i ] ; } } } return $ maxi ; } function findMaxSum ( $ arr , $ n ) { return max ( maxSum1 ( $ arr , $ n ) , maxSum2 ( $ arr , $ n ) ) ; } $ arr = array ( 1 , 2 , 3 , 1 ) ; $ n = sizeof ( $ arr ) ; echo findMaxSum ( $ arr , $ n ) ; ? >"}
{"text": "Koefisien Permutasi | Pulangan nilai pekali permutasi p (n, k); Hitung nilai pekali permutasi dengan cara bawah; Kes asas; Hitung nilai menggunakan nilai yang disimpan sebelum ini; Langkah ini penting kerana p (i, j) = 0 untuk j> i; Kod pemacu", "code": "< ? php function permutationCoeff ( $ n , $ k ) { $ P = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ k ) ; $ j ++ ) { if ( $ j == 0 ) $ P [ $ i ] [ $ j ] = 1 ; else $ P [ $ i ] [ $ j ] = $ P [ $ i - 1 ] [ $ j ] + ( $ j * $ P [ $ i - 1 ] [ $ j - 1 ] ) ; $ P [ $ i ] [ $ j + 1 ] = 0 ; } } return $ P [ $ n ] [ $ k ] ; } $ n = 10 ; $ k = 2 ; echo \" Value ▁ of ▁ P ( \" , $ n , \" ▁ , \" , $ k , \" ) ▁ is ▁ \" , permutationCoeff ( $ n , $ k ) ; ? >"}
{"text": "Koefisien Permutasi | Pulangan nilai pekali permutasi p (n, k); Kes asas; Hitung faktorial nilai sehingga n; P (n, k) = n! / (n - k)! ; Kod pemacu", "code": "< ? php function permutationCoeff ( $ n , $ k ) { $ fact = array ( ) ; $ fact [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ fact [ $ i ] = $ i * $ fact [ $ i - 1 ] ; return $ fact [ $ n ] / $ fact [ $ n - $ k ] ; } $ n = 10 ; $ k = 2 ; echo \" Value ▁ of ▁ P ( \" , $ n , \" ▁ \" , $ k , \" ) ▁ is ▁ \" , permutationCoeff ( $ n , $ k ) ; ? >"}
{"text": "Pengaturcaraan Dinamik | Pulangan benar jika terdapat subset set dengan matahari sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Kod pemacu", "code": "< ? php function isSubsetSum ( $ set , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ set [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ set , $ n - 1 , $ sum ) ; return isSubsetSum ( $ set , $ n - 1 , $ sum ) || isSubsetSum ( $ set , $ n - 1 , $ sum - $ set [ $ n - 1 ] ) ; } $ set = array ( 3 , 34 , 4 , 12 , 5 , 2 ) ; $ sum = 9 ; $ n = 6 ; if ( isSubsetSum ( $ set , $ n , $ sum ) == true ) echo \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ; else echo \" No ▁ subset ▁ with ▁ given ▁ sum \" ; ? >"}
{"text": "Bilangan cara untuk mengeluarkan sub | Fungsi untuk mengembalikan bilangan cara mengeluarkan sub -rentetan dari $ s supaya semua watak yang tinggal adalah sama; Untuk menyimpan kiraan awalan dan akhiran; Gelung untuk mengira awalan; Gelung untuk mengira akhiran; Watak pertama dan terakhir rentetan adalah sama; Jika tidak; Kod pemacu", "code": "< ? php function no_of_ways ( $ s ) { $ n = strlen ( $ s ) ; $ count_left = 0 ; $ count_right = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ s [ $ i ] == $ s [ 0 ] ) { ++ $ count_left ; } else break ; } for ( $ i = $ n - 1 ; $ i >= 0 ; -- $ i ) { if ( $ s [ $ i ] == $ s [ $ n - 1 ] ) { ++ $ count_right ; } else break ; } if ( $ s [ 0 ] == $ s [ $ n - 1 ] ) return ( ( $ count_left + 1 ) * ( $ count_right + 1 ) ) ; else return ( $ count_left + $ count_right + 1 ) ; } $ s = \" geeksforgeeks \" ; echo no_of_ways ( $ s ) ; ? >"}
{"text": "Kira bilangan indeks seperti S [i] = s [i + 1]: pertanyaan pelbagai | Fungsi untuk membuat array awalan; Berfungsi untuk mengembalikan hasil pertanyaan; Kod pemacu; Pertanyaan 1; Pertanyaan 2", "code": "< ? php function preCompute ( $ n , $ s , & $ pref ) { $ pref [ 0 ] = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ pref [ $ i ] = $ pref [ $ i - 1 ] ; if ( $ s [ $ i - 1 ] == $ s [ $ i ] ) $ pref [ $ i ] ++ ; } } function query ( & $ pref , $ l , $ r ) { return $ pref [ $ r ] - $ pref [ $ l ] ; } $ s = \" ggggggg \" ; $ n = strlen ( $ s ) ; $ pref = array_fill ( 0 , $ n , NULL ) ; preCompute ( $ n , $ s , $ pref ) ; $ l = 1 ; $ r = 2 ; echo query ( $ pref , $ l , $ r ) . \" STRNEWLINE \" ; $ l = 1 ; $ r = 5 ; echo query ( $ pref , $ l , $ r ) . \" STRNEWLINE \" ; ? >"}
{"text": "Cari arah dari rentetan yang diberikan | Berfungsi untuk mencari arah akhir; Sekiranya kiraan positif yang membayangkan hasilnya adalah arah arah jam; Sekiranya kiraan negatif yang membayangkan hasilnya adalah arah anti jam; Kod pemacu", "code": "< ? php function findDirection ( $ s ) { $ count = 0 ; $ d = \" \" ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ 0 ] == ' ' ) return null ; if ( $ s [ $ i ] == ' L ' ) $ count -= 1 ; else { if ( $ s [ $ i ] == ' R ' ) $ count += 1 ; } } if ( $ count > 0 ) { if ( $ count % 4 == 0 ) $ d = \" N \" ; else if ( $ count % 4 == 1 ) $ d = \" E \" ; else if ( $ count % 4 == 2 ) $ d = \" S \" ; else if ( $ count % 4 == 3 ) $ d = \" W \" ; } if ( $ count < 0 ) { if ( $ count % 4 == 0 ) $ d = \" N \" ; else if ( $ count % 4 == -1 ) $ d = \" W \" ; else if ( $ count % 4 == -2 ) $ d = \" S \" ; else if ( $ count % 4 == -3 ) $ d = \" E \" ; } return $ d ; } $ s = \" LLRLRRL \" ; echo findDirection ( $ s ) . \" STRNEWLINE \" ; $ s = \" LL \" ; echo findDirection ( $ s ) . \" STRNEWLINE \" ; ? >"}
{"text": "Gantikan setiap watak rentetan oleh watak yang nilai ASCII adalah k kali lebih daripada itu | Berfungsi untuk memindahkan watak rentetan; rentetan berubah; berulang untuk setiap aksara; Nilai ASCII; Simpan pendua; jika k - th ke depan watak melebihi 'z'; Cetak rentetan baru; Kod pemacu; panggilan fungsi", "code": "< ? php function encode ( $ s , $ k ) { $ newS = \" \" ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; ++ $ i ) { $ val = ord ( $ s [ $ i ] ) ; $ dup = $ k ; if ( $ val + $ k > 122 ) { $ k -= ( 122 - $ val ) ; $ k = $ k % 26 ; $ newS = $ newS . chr ( 96 + $ k ) ; } else $ newS = $ newS . chr ( $ val + $ k ) ; $ k = $ dup ; } echo $ newS ; } $ str = \" abc \" ; $ k = 28 ; encode ( $ str , $ k ) ; ? >"}
{"text": "Ubah suai rentetan dengan mengeluarkan vokal di antara dua konsonan | Fungsi untuk memeriksa sama ada watak x adalah vokal atau tidak; Mengembalikan rentetan yang dikemas kini yang dibentuk selepas mengeluarkan semua vokal sandwich dari rentetan yang diberikan; rentetan untuk menyimpan rentetan yang dikemas kini selepas mengeluarkan vokal yang diapit; melintasi rentetan dari kiri ke kanan; Sekiranya watak semasa adalah watak pertama atau terakhir rentetan itu, ini perlu dilampirkan kepada yang dikemas kini, kerana abjad sudut tanpa mengira ia menjadi vokal atau konsonan, tidak pernah 'diapit'; Semak sama ada watak semasa rentetan adalah vokal dan kedua -dua watak -watak terdahulu dan seterusnya adalah konsonan, jika demikian maka ini adalah vokal yang diapit, dengan itu diabaikan dan tidak dilampirkan pada rentetan yang dikemas kini; Jika watak ini bukan vokal yang diapit masuk ke rentetan yang dikemas kini; Kod pemacu; Keluarkan semua vokal sandwitched", "code": "< ? php function isVowel ( $ x ) { if ( $ x == ' a ' $ x == ' e ' $ x == ' i ' $ x == ' o ' $ x == ' u ' ) return true ; else return false ; } function updateSandwichedVowels ( $ a ) { $ n = strlen ( $ a ) ; $ updatedString = \" \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ! $ i $ i == $ n - 1 ) { $ updatedString . = $ a [ $ i ] ; continue ; } if ( isVowel ( $ a [ $ i ] ) && ! isVowel ( $ a [ $ i - 1 ] ) && ! isVowel ( $ a [ $ i + 1 ] ) ) { continue ; } $ updatedString . = $ a [ $ i ] ; } return $ updatedString ; } $ str = \" geeksforgeeks \" ; $ updatedString = updateSandwichedVowels ( $ str ) ; echo $ updatedString ; ? >"}
{"text": "Bilangan bilangan bulat n digit dengan berat w | Berfungsi untuk mencari jumlah nombor yang mungkin dengan digit dan berat w; Apabila berat integer positif; Tolak berat dari 9; Apabila berat integer adalah negatif; Tambah berat badan kepada 10 untuk menjadikannya positif; bilangan digit dalam integer dan w sebagai berat; Cetak jumlah nombor yang mungkin dengan N digit dan berat w", "code": "< ? php function findNumbers ( $ n , $ w ) { $ x = 0 ; $ sum = 0 ; if ( $ w >= 0 && $ w <= 8 ) { $ x = 9 - $ w ; } else if ( $ w >= -9 && $ w <= -1 ) { $ x = 10 + $ w ; } $ sum = pow ( 10 , $ n - 2 ) ; $ sum = ( $ x * $ sum ) ; return $ sum ; } $ n = 3 ; $ w = 4 ; echo findNumbers ( $ n , $ w ) ;"}
{"text": "Ketinggian maksimum susunan segi tiga nilai array | Program PHP untuk mencari ketinggian maksimum susunan piramida nilai array; Hanya memeriksa sama ada tahap ith mungkin atau tidak jika mungkin maka kita mesti mempunyai atleast (i * (i + 1)) / 2 elemen dalam array; mengemas kini nilai hasil setiap kali; Jika tidak, kita telah melebihi nilai n; Kod pemacu", "code": "< ? php function MaximumHeight ( $ a , $ n ) { $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ y = ( $ i * ( $ i + 1 ) ) / 2 ; if ( $ y < $ n ) $ result = $ i ; else break ; } return $ result ; } $ arr = array ( 40 , 100 , 20 , 30 ) ; $ n = count ( $ arr ) ; echo MaximumHeight ( $ arr , $ n ) ; ? >"}
{"text": "K | Program PHP untuk mencari elemen k - Th dalam urutan ganjil - walaupun. ; Masukkan semua nombor ganjil dari 1 hingga n. ; Masukkan semua nombor dari 1 hingga n. ; Kod pemacu", "code": "< ? php function findK ( $ n , $ k ) { $ a ; $ index = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ i % 2 == 1 ) $ a [ $ index ++ ] = $ i ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ i % 2 == 0 ) $ a [ $ index ++ ] = $ i ; return ( $ a [ $ k - 1 ] ) ; } $ n = 10 ; $ k = 3 ; echo findK ( $ n , $ k ) ; ? >"}
{"text": "Satu fungsi baris untuk faktorial nombor | Program PHP untuk mencari faktorial nombor tertentu; Baris tunggal untuk mencari faktorial; Kod pemacu", "code": "< ? php function factorial ( $ n ) { return ( $ n == 1 $ n == 0 ) ? 1 : $ n * factorial ( $ n - 1 ) ; } $ num = 5 ; echo \" Factorial ▁ of ▁ \" , $ num , \" ▁ is ▁ \" , factorial ( $ num ) ; ? >"}
{"text": "Nombor Pell | Hitung nombor pell; Kod pemacu", "code": "< ? php function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; $ a = 1 ; $ b = 2 ; $ c ; $ i ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ c = 2 * $ b + $ a ; $ a = $ b ; $ b = $ c ; } return $ b ; } $ n = 4 ; echo ( pell ( $ n ) ) ; ? >"}
{"text": "Cara yang cekap untuk memeriksa sama ada N | Pulangan benar jika nombor fibonacci n - th adalah berganda dari 10 .; Kod pemacu", "code": "< ? php function isMultipleOf10 ( $ n ) { return ( $ n % 15 == 0 ) ; } $ n = 30 ; if ( isMultipleOf10 ( $ n ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Cari kesopanan nombor | Fungsi untuk mengira semua faktor utama ganjil nombor n; Menghapuskan semua faktor utama bilangan n; n mesti ganjil pada ketika ini, jadi berulang hanya untuk nombor ganjil sehingga sqrt (n); Jika saya membahagikan N, maka mula mengira pembahagi ganjil; Jika n yang ganjil masih kekal maka hitungnya; Kod pemacu", "code": "< ? php function countOddPrimeFactors ( $ n ) { $ result = 1 ; while ( $ n % 2 == 0 ) $ n /= 2 ; for ( $ i = 3 ; $ i * $ i <= $ n ; $ i += 2 ) { $ divCount = 0 ; while ( $ n % $ i == 0 ) { $ n /= $ i ; ++ $ divCount ; } $ result *= $ divCount + 1 ; } if ( $ n > 2 ) $ result *= 2 ; return $ result ; } function politness ( $ n ) { return countOddPrimeFactors ( $ n ) - 1 ; } $ n = 90 ; echo \" Politness ▁ of ▁ \" , $ n , \" ▁ = ▁ \" , politness ( $ n ) , \" STRNEWLINE \" ; $ n = 15 ; echo \" Politness ▁ of ▁ \" , $ n , \" ▁ = ▁ \" , politness ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Perdana terdekat yang kurang daripada bilangan N | Program PHP untuk mencari perdana terdekat kepada n. ; array untuk menyimpan semua prima kurang daripada 10 ^ 6; Fungsi utiliti penapis Sundaram; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x; Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j; menghapuskan indeks yang tidak menghasilkan prima; Oleh kerana 2 adalah nombor perdana; Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Carian binari yang diubah suai untuk mencari perdana terdekat kurang daripada n; Keadaan asas adalah, jika kita sampai di sudut kiri atau sudut kanan prima [] array kemudian kembali elemen sudut kerana sebelum atau selepas itu kita tidak mempunyai sebarang nombor utama dalam array prima; Sekarang jika N sendiri menjadi perdana jadi ia akan hadir dalam pelbagai prima dan di sini kita perlu mencari perdana terdekat yang kurang daripada n supaya kita akan mengembalikan prima [pertengahan - 1]; Sekarang jika prima [pertengahan] <n dan prima [pertengahan + 1]> n itu bermakna kita sampai pada perdana terdekat; Kod pemacu", "code": "< ? php $ MAX = 10000 ; $ primes = array ( ) ; function Sieve ( ) { global $ MAX , $ primes ; $ n = $ MAX ; $ nNew = ( int ) ( sqrt ( $ n ) ) ; $ marked = array_fill ( 0 , ( int ) ( $ n / 2 + 500 ) , 0 ) ; for ( $ i = 1 ; $ i <= ( $ nNew - 1 ) / 2 ; $ i ++ ) for ( $ j = ( $ i * ( $ i + 1 ) ) << 1 ; $ j <= $ n / 2 ; $ j = $ j + 2 * $ i + 1 ) $ marked [ $ j ] = 1 ; array_push ( $ primes , 2 ) ; for ( $ i = 1 ; $ i <= $ n / 2 ; $ i ++ ) if ( $ marked [ $ i ] == 0 ) array_push ( $ primes , 2 * $ i + 1 ) ; } function binarySearch ( $ left , $ right , $ n ) { global $ primes ; if ( $ left <= $ right ) { $ mid = ( int ) ( ( $ left + $ right ) / 2 ) ; if ( $ mid == 0 || $ mid == count ( $ primes ) - 1 ) return $ primes [ $ mid ] ; if ( $ primes [ $ mid ] == $ n ) return $ primes [ $ mid - 1 ] ; if ( $ primes [ $ mid ] < $ n && $ primes [ $ mid + 1 ] > $ n ) return $ primes [ $ mid ] ; if ( $ n < $ primes [ $ mid ] ) return binarySearch ( $ left , $ mid - 1 , $ n ) ; else return binarySearch ( $ mid + 1 , $ right , $ n ) ; } return 0 ; } Sieve ( ) ; $ n = 17 ; echo binarySearch ( 0 , count ( $ primes ) - 1 , $ n ) ; ? >"}
{"text": "Program untuk faktorial nombor | fungsi untuk mencari faktorial nombor yang diberikan; Kod pemacu", "code": "< ? php function factorial ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * factorial ( $ n - 1 ) ; } $ num = 5 ; echo \" Factorial ▁ of ▁ \" , $ num , \" ▁ is ▁ \" , factorial ( $ num ) ; ? >"}
{"text": "K | Mengembalikan elemen yang berbeza dalam arr. ; Semak jika elemen semasa hadir di tempat lain. ; Jika elemen adalah unik; Kod pemacu", "code": "< ? php function printKDistinct ( $ arr , $ n , $ k ) { $ dist_count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ i != $ j && $ arr [ $ j ] == $ arr [ $ i ] ) break ; if ( $ j == $ n ) $ dist_count ++ ; if ( $ dist_count == $ k ) return $ arr [ $ i ] ; } return -1 ; } $ ar = array ( 1 , 2 , 1 , 3 , 4 , 2 ) ; $ n = sizeof ( $ ar ) / sizeof ( $ ar [ 0 ] ) ; $ k = 2 ; echo printKDistinct ( $ ar , $ n , $ k ) ; ? >"}
{"text": "Cari bilangan pasangan dalam array supaya XOR mereka adalah 0 | Fungsi untuk mengira kiraan; Menyusun senarai menggunakan fungsi terbina; Melintasi unsur -unsur; Kekerapan mengira setiap elemen; Menambah sumbangan kekerapan kepada jawapannya; Kod pemacu; Cetak kiraan", "code": "< ? php function calculate ( $ a , $ n ) { sort ( $ a ) ; $ count = 1 ; $ answer = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ a [ $ i - 1 ] ) { $ count += 1 ; } else { $ answer = $ answer + ( $ count * ( $ count - 1 ) ) / 2 ; $ count = 1 ; } } $ answer = $ answer + ( $ count * ( $ count - 1 ) ) / 2 ; return $ answer ; } $ a = array ( 1 , 2 , 1 , 2 , 4 ) ; $ n = count ( $ a ) ; echo calculate ( $ a , $ n ) ; ? >"}
{"text": "Cari bilangan pasangan dalam array supaya XOR mereka adalah 0 | Berfungsi untuk mengira jawapannya; Mencari maksimum array; Mewujudkan array frekuensi dengan nilai awal 0; Melintasi array; Kekerapan mengira; Melintasi pelbagai frekuensi; Mengira jawapan; Kod pemacu; Fungsi panggilan", "code": "< ? php function calculate ( $ a , $ n ) { $ maximum = max ( $ a ) ; $ frequency = array_fill ( 0 , $ maximum + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ frequency [ $ a [ $ i ] ] += 1 ; } $ answer = 0 ; for ( $ i = 0 ; $ i < ( $ maximum ) + 1 ; $ i ++ ) { $ answer = $ answer + $ frequency [ $ i ] * ( $ frequency [ $ i ] - 1 ) ; } return $ answer / 2 ; } $ a = array ( 1 , 2 , 1 , 2 , 4 ) ; $ n = count ( $ a ) ; echo ( calculate ( $ a , $ n ) ) ; ? >"}
{"text": "Subarray terbesar dengan bilangan yang sama 0 s dan 1 s | Fungsi ini mencetak indeks permulaan dan akhir subarray terbesar dengan bilangan yang sama 0 s dan 1 s. Juga mengembalikan saiz subarray tersebut. ; Pilih titik permulaan seperti saya; Pertimbangkan semua subarrays bermula dari i; Jika ini adalah subarray 0 jumlah, maka bandingkan dengan subarray saiz maksimum yang dikira setakat ini; Kod pemacu", "code": "< ? php function findSubArray ( & $ arr , $ n ) { $ sum = 0 ; $ maxsize = -1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ sum = ( $ arr [ $ i ] == 0 ) ? -1 : 1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { ( $ arr [ $ j ] == 0 ) ? ( $ sum += -1 ) : ( $ sum += 1 ) ; if ( $ sum == 0 && $ maxsize < $ j - $ i + 1 ) { $ maxsize = $ j - $ i + 1 ; $ startindex = $ i ; } } } if ( $ maxsize == -1 ) echo \" No ▁ such ▁ subarray \" ; else echo $ startindex . \" ▁ to ▁ \" . ( $ startindex + $ maxsize - 1 ) ; return $ maxsize ; } $ arr = array ( 1 , 0 , 0 , 1 , 0 , 1 , 1 ) ; $ size = sizeof ( $ arr ) ; findSubArray ( $ arr , $ size ) ; ? >"}
{"text": "Elemen maksimum dalam array yang disusun dan diputar | Berfungsi untuk mengembalikan elemen maksimum; Keadaan ini adalah untuk kes apabila array tidak diputar sama sekali; Cari pertengahan; Semak jika pertengahan mencapai 0, ia lebih besar daripada elemen seterusnya atau tidak; Periksa sama ada pertengahan sendiri adalah elemen maksimum; Tentukan sama ada kita perlu pergi ke separuh kiri atau separuh kanan; Kod pemacu", "code": "< ? php function findMax ( $ arr , $ low , $ high ) { if ( $ high <= $ low ) return $ arr [ $ low ] ; $ mid = $ low + ( $ high - $ low ) / 2 ; if ( $ mid == 0 && $ arr [ $ mid ] > $ arr [ $ mid - 1 ] ) return $ arr [ 0 ] ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] && $ mid > 0 && $ arr [ $ mid ] > $ arr [ $ mid - 1 ] ) { return $ arr [ $ mid ] ; } if ( $ arr [ $ low ] > $ arr [ $ mid ] ) { return findMax ( $ arr , $ low , $ mid - 1 ) ; } else { return findMax ( $ arr , $ mid + 1 , $ high ) ; } } $ arr = array ( 5 , 6 , 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo findMax ( $ arr , 0 , $ n - 1 ) ;"}
{"text": "Cari elemen dalam array yang disusun dan diputar | Pulangan indeks kunci dalam arr [l. . h] jika kunci hadir, jika tidak pulangan - 1; Jika arr [l ... pertengahan] disusun; Oleh kerana subarray ini disusun, kita dapat dengan cepat memeriksa sama ada kunci terletak pada separuh atau separuh lagi; Jika kunci tidak terletak pada separuh pertama subarray, bahagikan separuh lagi ke dalam dua subarray, supaya kita dapat dengan cepat memeriksa jika kunci terletak pada separuh lain; Jika arr [l. . pertengahan] tidak disusun, maka arr [pertengahan ... r] mesti disusun; Kod pemacu", "code": "< ? php function search ( $ arr , $ l , $ h , $ key ) { if ( $ l > $ h ) return -1 ; $ mid = ( $ l + $ h ) / 2 ; if ( $ arr [ $ mid ] == $ key ) return $ mid ; if ( $ arr [ $ l ] <= $ arr [ $ mid ] ) { if ( $ key >= $ arr [ $ l ] && $ key <= $ arr [ $ mid ] ) return search ( $ arr , $ l , $ mid - 1 , $ key ) ; return search ( $ arr , $ mid + 1 , $ h , $ key ) ; } if ( $ key >= $ arr [ $ mid ] && $ key <= $ arr [ $ h ] ) return search ( $ arr , $ mid + 1 , $ h , $ key ) ; return search ( $ arr , $ l , $ mid - 1 , $ key ) ; } $ arr = array ( 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; $ key = 6 ; $ i = search ( $ arr , 0 , $ n - 1 , $ key ) ; if ( $ i != -1 ) echo \" Index : ▁ \" , floor ( $ i ) , \" ▁ STRNEWLINE \" ; else echo \" Key ▁ not ▁ found \" ; ? >"}
{"text": "Cari elemen minimum dalam array yang disusun dan diputar | Program PHP untuk mencari elemen minimum dalam array yang disusun dan diputar; Keadaan ini diperlukan untuk mengendalikan kes apabila array tidak diputar sama sekali; Sekiranya terdapat hanya satu elemen yang tersisa; Cari pertengahan; Semak jika elemen (pertengahan + 1) adalah elemen minimum. Pertimbangkan kes seperti (3, 4, 5, 1, 2); Semak jika Mid sendiri adalah elemen minimum; Tentukan sama ada kita perlu pergi ke separuh kiri atau kanan; Kod pemacu", "code": "< ? php function findMin ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return $ arr [ 0 ] ; if ( $ high == $ low ) return $ arr [ $ low ] ; $ mid = $ low + ( $ high - $ low ) / 2 ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return $ arr [ $ mid + 1 ] ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return $ arr [ $ mid ] ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return findMin ( $ arr , $ low , $ mid - 1 ) ; return findMin ( $ arr , $ mid + 1 , $ high ) ; } $ arr1 = array ( 5 , 6 , 1 , 2 , 3 , 4 ) ; $ n1 = sizeof ( $ arr1 ) ; echo \" The ▁ minimum ▁ element ▁ is ▁ \" . findMin ( $ arr1 , 0 , $ n1 - 1 ) . \" STRNEWLINE \" ; $ arr2 = array ( 1 , 2 , 3 , 4 ) ; $ n2 = sizeof ( $ arr2 ) ; echo \" The ▁ minimum ▁ element ▁ is ▁ \" . findMin ( $ arr2 , 0 , $ n2 - 1 ) . \" STRNEWLINE \" ; $ arr3 = array ( 1 ) ; $ n3 = sizeof ( $ arr3 ) ; echo \" The ▁ minimum ▁ element ▁ is ▁ \" . findMin ( $ arr3 , 0 , $ n3 - 1 ) . \" STRNEWLINE \" ; $ arr4 = array ( 1 , 2 ) ; $ n4 = sizeof ( $ arr4 ) ; echo \" The ▁ minimum ▁ element ▁ is ▁ \" . findMin ( $ arr4 , 0 , $ n4 - 1 ) . \" STRNEWLINE \" ; $ arr5 = array ( 2 , 1 ) ; $ n5 = sizeof ( $ arr5 ) ; echo \" The ▁ minimum ▁ element ▁ is ▁ \" . findMin ( $ arr5 , 0 , $ n5 - 1 ) . \" STRNEWLINE \" ; $ arr6 = array ( 5 , 6 , 7 , 1 , 2 , 3 , 4 ) ; $ n6 = sizeof ( $ arr6 ) ; echo \" The ▁ minimum ▁ element ▁ is ▁ \" . findMin ( $ arr6 , 0 , $ n6 - 1 ) . \" STRNEWLINE \" ; $ arr7 = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ; $ n7 = sizeof ( $ arr7 ) ; echo \" The ▁ minimum ▁ element ▁ is ▁ \" . findMin ( $ arr7 , 0 , $ n7 - 1 ) . \" STRNEWLINE \" ; $ arr8 = array ( 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 ) ; $ n8 = sizeof ( $ arr8 ) ; echo \" The ▁ minimum ▁ element ▁ is ▁ \" . findMin ( $ arr8 , 0 , $ n8 - 1 ) . \" STRNEWLINE \" ; $ arr9 = array ( 3 , 4 , 5 , 1 , 2 ) ; $ n9 = sizeof ( $ arr9 ) ; echo \" The ▁ minimum ▁ element ▁ is ▁ \" . findMin ( $ arr9 , 0 , $ n9 - 1 ) . \" STRNEWLINE \" ; ? >"}
{"text": "Cari elemen terkecil terkecil dan kedua dalam array | Berfungsi untuk mencetak unsur -unsur terkecil terkecil pertama dan kedua; Harus ada dua elemen; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Kod pemacu", "code": "< ? php function print2Smallest ( $ arr , $ arr_size ) { $ INT_MAX = 2147483647 ; if ( $ arr_size < 2 ) { echo ( \" ▁ Invalid ▁ Input ▁ \" ) ; return ; } $ first = $ second = $ INT_MAX ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { if ( $ arr [ $ i ] < $ first ) { $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] < $ second && $ arr [ $ i ] != $ first ) $ second = $ arr [ $ i ] ; } if ( $ second == $ INT_MAX ) echo ( \" There ▁ is ▁ no ▁ second ▁ smallest ▁ element STRNEWLINE \" ) ; else echo \" The ▁ smallest ▁ element ▁ is ▁ \" , $ first , \" ▁ and ▁ second ▁ Smallest ▁ element ▁ is ▁ \" , $ second ; } $ arr = array ( 12 , 13 , 1 , 10 , 34 , 1 ) ; $ n = count ( $ arr ) ; print2Smallest ( $ arr , $ n ) ? >"}
{"text": "Subset Jumlah Masalah di O (SUM) Ruang | Pulangan benar jika terdapat subset dengan jumlah yang diberikan dalam arr []; Nilai subset [i % 2] [j] akan benar jika terdapat subset jumlah J dalam arr [0, 1, .... , i - 1]; Subset dengan jumlah 0 selalu mungkin; Sekiranya tidak ada unsur tidak ada jumlah yang mungkin; Kod pemacu", "code": "< ? php function isSubsetSum ( $ arr , $ n , $ sum ) { $ subset [ 2 ] [ $ sum + 1 ] = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ sum ; $ j ++ ) { if ( $ j == 0 ) $ subset [ $ i % 2 ] [ $ j ] = true ; else if ( $ i == 0 ) $ subset [ $ i % 2 ] [ $ j ] = false ; else if ( $ arr [ $ i - 1 ] <= $ j ) $ subset [ $ i % 2 ] [ $ j ] = $ subset [ ( $ i + 1 ) % 2 ] [ $ j - $ arr [ $ i - 1 ] ] || $ subset [ ( $ i + 1 ) % 2 ] [ $ j ] ; else $ subset [ $ i % 2 ] [ $ j ] = $ subset [ ( $ i + 1 ) % 2 ] [ $ j ] ; } } return $ subset [ $ n % 2 ] [ $ sum ] ; } $ arr = array ( 6 , 2 , 5 ) ; $ sum = 7 ; $ n = sizeof ( $ arr ) ; if ( isSubsetSum ( $ arr , $ n , $ sum ) == true ) echo ( \" There ▁ exists ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) ; else echo ( \" No ▁ subset ▁ exists ▁ with ▁ given ▁ sum \" ) ; ? >"}
{"text": "Sum maksimum equlibrium dalam array | Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Kod pemacu", "code": "< ? php function findMaxSum ( $ arr , $ n ) { $ res = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ prefix_sum = $ arr [ $ i ] ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ prefix_sum += $ arr [ $ j ] ; $ suffix_sum = $ arr [ $ i ] ; for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) $ suffix_sum += $ arr [ $ j ] ; if ( $ prefix_sum == $ suffix_sum ) $ res = max ( $ res , $ prefix_sum ) ; } return $ res ; } $ arr = array ( -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 ) ; $ n = count ( $ arr ) ; echo findMaxSum ( $ arr , $ n ) ; ? >"}
{"text": "Sum maksimum equlibrium dalam array | Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Array to Store Prefix Sum. ; Array untuk menyimpan jumlah akhiran. ; Pembolehubah untuk menyimpan jumlah maksimum. ; Kirakan jumlah awalan. ; Kirakan jumlah akhiran dan bandingkan dengan jumlah awalan. Kemas kini Ans dengan sewajarnya. ; Kod pemacu", "code": "< ? php function findMaxSum ( $ arr , $ n ) { $ preSum [ $ n ] = array ( ) ; $ suffSum [ $ n ] = array ( ) ; $ ans = PHP_INT_MIN ; $ preSum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ preSum [ $ i ] = $ preSum [ $ i - 1 ] + $ arr [ $ i ] ; $ suffSum [ $ n - 1 ] = $ arr [ $ n - 1 ] ; if ( $ preSum [ $ n - 1 ] == $ suffSum [ $ n - 1 ] ) $ ans = max ( $ ans , $ preSum [ $ n - 1 ] ) ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ suffSum [ $ i ] = $ suffSum [ $ i + 1 ] + $ arr [ $ i ] ; if ( $ suffSum [ $ i ] == $ preSum [ $ i ] ) $ ans = max ( $ ans , $ preSum [ $ i ] ) ; } return $ ans ; } $ arr = array ( -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 ) ; $ n = sizeof ( $ arr ) ; echo findMaxSum ( $ arr , $ n ) ;"}
{"text": "Elemen Majoriti | Berfungsi untuk mencari elemen majoriti dalam array; sentinel; Kemas kini MaxCount jika kiraan elemen semasa lebih besar; Jika MaxCount lebih besar daripada n / 2 mengembalikan elemen yang sepadan; Kod pemacu; Fungsi panggilan", "code": "< ? php function findMajority ( $ arr , $ n ) { $ maxCount = 0 ; $ index = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ count ++ ; } if ( $ count > $ maxCount ) { $ maxCount = $ count ; $ index = $ i ; } } if ( $ maxCount > $ n / 2 ) echo $ arr [ $ index ] . \" STRNEWLINE \" ; else echo \" No ▁ Majority ▁ Element \" . \" STRNEWLINE \" ; } $ arr = array ( 1 , 1 , 2 , 1 , 3 , 5 , 1 ) ; $ n = sizeof ( $ arr ) ; findMajority ( $ arr , $ n ) ;"}
{"text": "Elemen Majoriti | Berfungsi untuk mencari calon untuk majoriti; Berfungsi untuk memeriksa sama ada calon berlaku lebih daripada n / 2 kali; Berfungsi untuk mencetak elemen majoriti; Cari calon untuk majoriti; Cetak calon jika ia adalah majoriti; Kod pemacu; Fungsi panggilan", "code": "< ? php function findCandidate ( $ a , $ size ) { $ maj_index = 0 ; $ count = 1 ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) { if ( $ a [ $ maj_index ] == $ a [ $ i ] ) $ count ++ ; else $ count -- ; if ( $ count == 0 ) { $ maj_index = $ i ; $ count = 1 ; } } return $ a [ $ maj_index ] ; } function isMajority ( $ a , $ size , $ cand ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) if ( $ a [ $ i ] == $ cand ) $ count ++ ; if ( $ count > $ size / 2 ) return 1 ; else return 0 ; } function printMajority ( $ a , $ size ) { $ cand = findCandidate ( $ a , $ size ) ; if ( isMajority ( $ a , $ size , $ cand ) ) echo \" ▁ \" , $ cand , \" ▁ \" ; else echo \" No ▁ Majority ▁ Element \" ; } $ a = array ( 1 , 3 , 3 , 1 , 2 ) ; $ size = sizeof ( $ a ) ; printMajority ( $ a , $ size ) ; ? >"}
{"text": "Pengaturcaraan Dinamik | Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara bawah; Uncomment Kod ini untuk mencetak jadual; Kod pemacu", "code": "< ? php function isSubsetSum ( $ set , $ n , $ sum ) { $ subset = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ subset [ $ i ] [ 0 ] = true ; for ( $ i = 1 ; $ i <= $ sum ; $ i ++ ) $ subset [ 0 ] [ $ i ] = false ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ sum ; $ j ++ ) { if ( $ j < $ set [ $ i - 1 ] ) $ subset [ $ i ] [ $ j ] = $ subset [ $ i - 1 ] [ $ j ] ; if ( $ j >= $ set [ $ i - 1 ] ) $ subset [ $ i ] [ $ j ] = $ subset [ $ i - 1 ] [ $ j ] || $ subset [ $ i - 1 ] [ $ j - $ set [ $ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( \" % 4d \" , subset [ i ] [ j ] ) ; printf ( \" n \" ) ; } return $ subset [ $ n ] [ $ sum ] ; } $ set = array ( 3 , 34 , 4 , 12 , 5 , 2 ) ; $ sum = 9 ; $ n = count ( $ set ) ; if ( isSubsetSum ( $ set , $ n , $ sum ) == true ) echo \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ; else echo \" No ▁ subset ▁ with ▁ given ▁ sum \" ; ? >"}
{"text": "Pertanyaan dalam talian untuk GCD Array Selepas Membahagikan Operasi | Pelaksanaan PHP pendekatan mengembalikan GCD selepas semua kemas kini dalam array; Fungsi untuk mengira GCD pertanyaan onine; menyimpan GCD elemen array awal; mengira GCD; melakukan pertanyaan dalam talian; Indeks adalah 1 berdasarkan; Bahagikan elemen array; mengira GCD semasa; Cetak GCD selepas setiap langkah; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function print_gcd_online ( $ n , $ m , $ query , $ arr ) { $ max_gcd = 0 ; $ i = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ max_gcd = gcd ( $ max_gcd , $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ query [ $ i ] [ 0 ] -- ; $ arr [ $ query [ $ i ] [ 0 ] ] /= $ query [ $ i ] [ 1 ] ; $ max_gcd = gcd ( $ arr [ $ query [ $ i ] [ 0 ] ] , $ max_gcd ) ; echo ( $ max_gcd ) , \" STRNEWLINE \" ; } } $ n = 3 ; $ m = 3 ; $ query ; $ arr = array ( 36 , 24 , 72 ) ; $ query [ 0 ] [ 0 ] = 1 ; $ query [ 0 ] [ 1 ] = 3 ; $ query [ 1 ] [ 0 ] = 3 ; $ query [ 1 ] [ 1 ] = 12 ; $ query [ 2 ] [ 0 ] = 2 ; $ query [ 2 ] [ 1 ] = 4 ; print_gcd_online ( $ n , $ m , $ query , $ arr ) ; ? >"}
{"text": "Nombor dalam julat [l, r] supaya kiraan pembahagi mereka adalah kedua -duanya dan perdana | Pelaksanaan PHP pendekatan; Kedai sama ada nombor itu adalah perdana atau tidak; menyimpan kiraan nombor perdana kurang daripada atau sama dengan indeks; buat penapis; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaan sebagai benar. Nilai dalam perdana [i] akhirnya akan palsu jika 'i' bukanlah perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; menyimpan jumlah awalan bilangan prima kurang daripada atau sama dengan 'i'; buat penapis; 'l' dan 'r' adalah batas bawah dan atas julat; Dapatkan nilai kiraan; Paparkan kiraan", "code": "< ? php $ MAX = 100000 ; $ prime = array_fill ( 0 , $ MAX + 1 , true ) ; $ sum = array_fill ( 0 , $ MAX + 1 , 0 ) ; function SieveOfEratosthenes ( ) { global $ MAX , $ sum , $ prime ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ MAX ; $ p ++ ) { if ( $ prime [ $ p ] ) { for ( $ i = $ p * 2 ; $ i <= $ MAX ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ i = 1 ; $ i <= $ MAX ; $ i ++ ) { if ( $ prime [ $ i ] == true ) $ sum [ $ i ] = 1 ; $ sum [ $ i ] += $ sum [ $ i - 1 ] ; } } SieveOfEratosthenes ( ) ; $ l = 3 ; $ r = 9 ; $ c = ( $ sum [ $ r ] - $ sum [ $ l - 1 ] ) ; echo \" Count : \" ▁ . ▁ $ c ▁ . ▁ \" \" ? >"}
{"text": "Kawasan bulatan yang ditulis dalam segi empat tepat yang tertulis dalam separuh bulatan | Berfungsi untuk mencari kawasan bulatan; Radius tidak boleh negatif; kawasan bulatan; Kod pemacu", "code": "< ? php function area ( $ r ) { if ( $ r < 0 ) return -1 ; $ area = 3.14 * pow ( $ r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return $ area ; } $ a = 5 ; echo area ( $ a ) ;"}
{"text": "Cari kiraan nombor hampir perdana dari 1 hingga n | Program PHP untuk mengira hampir nombor utama dari 1 hingga N; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Fungsi untuk mengira hampir nombor utama dari 1 hingga n; untuk menyimpan jawapan yang diperlukan; 6 adalah nombor hampir perdana pertama; untuk mengira faktor utama; Jika ia sempurna persegi; Sekiranya saya hampir nombor utama; Kod pemacu", "code": "< ? php $ N = 100005 ; $ prime = array_fill ( 0 , $ N , true ) ; function SieveOfEratosthenes ( ) { global $ N , $ prime ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p < ( int ) ( sqrt ( $ N ) ) ; $ p ++ ) { if ( $ prime [ $ p ] == true ) for ( $ i = 2 * $ p ; $ i < $ N ; $ i += $ p ) $ prime [ $ i ] = false ; } } function almostPrimes ( $ n ) { global $ prime ; $ ans = 0 ; for ( $ i = 6 ; $ i < $ n + 1 ; $ i ++ ) { $ c = 0 ; for ( $ j = 2 ; $ i >= $ j * $ j ; $ j ++ ) { if ( $ i % $ j == 0 ) { if ( $ j * $ j == $ i ) { if ( $ prime [ $ j ] ) $ c += 1 ; } else { if ( $ prime [ $ j ] ) $ c += 1 ; if ( $ prime [ ( $ i / $ j ) ] ) $ c += 1 ; } } } if ( $ c == 2 ) $ ans += 1 ; } return $ ans ; } SieveOfEratosthenes ( ) ; $ n = 21 ; print ( almostPrimes ( $ n ) ) ; ? >"}
{"text": "Bahagikan nombor menjadi dua bahagian supaya jumlah digit adalah maksimum | Mengembalikan jumlah digit X; Mengembalikan nombor terdekat kepada X dari segi 9. ; Kod pemacu", "code": "< ? php function sumOfDigitsSingle ( $ x ) { $ ans = 0 ; while ( $ x ) { $ ans += $ x % 10 ; $ x /= 10 ; } return $ ans ; } function closest ( $ x ) { $ ans = 0 ; while ( $ ans * 10 + 9 <= $ x ) $ ans = $ ans * 10 + 9 ; return $ ans ; } function sumOfDigitsTwoParts ( $ N ) { $ A = closest ( $ N ) ; return sumOfDigitsSingle ( $ A ) + sumOfDigitsSingle ( $ N - $ A ) ; } $ N = 35 ; echo sumOfDigitsTwoParts ( $ N ) ; ? >"}
{"text": "Ujian Primal | Tetapkan 5 (menggunakan Lucas | berfungsi untuk memeriksa sama ada / (2 ^ p - 1) adalah perdana atau tidak., Menjana nombor, nombor pertama siri; menghasilkan yang lain (p - 2) syarat siri.", "code": "< ? php function isPrime ( $ p ) { $ checkNumber = pow ( 2 , $ p ) - 1 ; $ nextval = 4 % $ checkNumber ; for ( $ i = 1 ; $ i < $ p - 1 ; $ i ++ ) $ nextval = ( $ nextval * $ nextval - 2 ) % $ checkNumber ; return ( $ nextval == 0 ) ; } $ p = 7 ; $ checkNumber = pow ( 2 , $ p ) - 1 ; if ( isPrime ( $ p ) ) echo $ checkNumber , \" ▁ is ▁ Prime . \" ; else echo $ checkNumber , \" ▁ is ▁ not ▁ Prime . \" ; ? >"}
{"text": "Sophie Germain Prime | Fungsi untuk mengesan nombor perdana di sini kami telah menggunakan kaedah penapis https: www. Geeksforgeeks. org / sieve - of - eratosthenes / untuk mengesan nombor perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Kami telah membuat array sehingga 2 * n + 1 supaya kami dapat memeriksa nombor perdana sehingga itu dan menyimpulkan tentang Sophie Jerman Prime. ; Memeriksa setiap saya sama ada Sophie Jerman Perdana atau tidak. ; Kod pemacu", "code": "< ? php function sieve ( $ n , & $ prime ) { for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } } function printSophieGermanNumber ( $ n ) { $ prime = array ( ) ; for ( $ i = 0 ; $ i < ( 2 * $ n + 1 ) ; $ i ++ ) $ prime [ $ i ] = true ; sieve ( 2 * $ n + 1 , $ prime ) ; for ( $ i = 2 ; $ i <= $ n ; ++ $ i ) { if ( $ prime [ $ i ] && $ prime [ 2 * $ i + 1 ] ) echo ( $ i . \" ▁ \" ) ; } } $ n = 25 ; printSophieGermanNumber ( $ n ) ; ? >"}
{"text": "Interpolasi Bessel | mengira anda disebut dalam formula; mengira faktorial nombor n; Bilangan nilai yang diberikan; y [] [] digunakan untuk jadual perbezaan dengan y [] [0] digunakan untuk input; Mengira jadual perbezaan pusat; Memaparkan jadual perbezaan pusat; nilai untuk interpolasi pada; Memulakan u dan jumlah; k ialah asalnya ialah F (0); jika ($ n % 2) asal untuk ganjil; $ k = $ n / 2 - 1; Asal untuk walaupun; Menyelesaikan menggunakan formula Bessel", "code": "< ? php function ucal ( $ u , $ n ) { if ( $ n == 0 ) return 1 ; $ temp = $ u ; for ( $ i = 1 ; $ i <= ( int ) ( $ n / 2 ) ; $ i ++ ) $ temp = $ temp * ( $ u - $ i ) ; for ( $ i = 1 ; $ i < ( int ) ( $ n / 2 ) ; $ i ++ ) $ temp = $ temp * ( $ u + $ i ) ; return $ temp ; } function fact ( $ n ) { $ f = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ f *= $ i ; return $ f ; } $ n = 6 ; $ x = array ( 25 , 26 , 27 , 28 , 29 , 30 ) ; $ y ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ y [ $ i ] [ $ j ] = 0.0 ; $ y [ 0 ] [ 0 ] = 4.000 ; $ y [ 1 ] [ 0 ] = 3.846 ; $ y [ 2 ] [ 0 ] = 3.704 ; $ y [ 3 ] [ 0 ] = 3.571 ; $ y [ 4 ] [ 0 ] = 3.448 ; $ y [ 5 ] [ 0 ] = 3.333 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n - $ i ; $ j ++ ) $ y [ $ j ] [ $ i ] = $ y [ $ j + 1 ] [ $ i - 1 ] - $ y [ $ j ] [ $ i - 1 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - $ i ; $ j ++ ) echo str_pad ( $ y [ $ i ] [ $ j ] , 4 ) . \" TABSYMBOL \" ; echo \" STRNEWLINE \" ; } $ value = 27.4 ; $ sum = ( $ y [ 2 ] [ 0 ] + $ y [ 3 ] [ 0 ] ) / 2 ; $ k ; $ k = $ n / 2 ; else $ u = ( $ value - $ x [ $ k ] ) / ( $ x [ 1 ] - $ x [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 ) $ sum = $ sum + ( ( $ u - 0.5 ) * ucal ( $ u , $ i - 1 ) * $ y [ $ k ] [ $ i ] ) / fact ( $ i ) ; else $ sum = $ sum + ( ucal ( $ u , $ i ) * ( $ y [ $ k ] [ $ i ] + $ y [ -- $ k ] [ $ i ] ) / ( fact ( $ i ) * 2 ) ) ; } echo \" Value ▁ at ▁ \" . $ value . \" ▁ is ▁ \" . $ sum . \" STRNEWLINE \" ; ? >"}
{"text": "Cara yang cekap untuk memeriksa sama ada N | Program PHP yang mudah untuk memeriksa sama ada nombor Fibonacci N - Th adalah pelbagai daripada 10 .; Pulangan benar jika nombor fibonacci n - th adalah berganda dari 10 .; Kod pemacu", "code": "< ? php function fibonacci ( $ n ) { $ a = 0 ; $ b = 1 ; $ c ; if ( $ n <= 1 ) return $ n ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ c = $ a + $ b ; $ a = $ b ; $ b = $ c ; } return $ c ; } function isMultipleOf10 ( $ n ) { $ f = fibonacci ( 30 ) ; return ( $ f % 10 == 0 ) ; } $ n = 30 ; if ( isMultipleOf10 ( $ n ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 | Fungsi untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Kod pemacu", "code": "< ? php function isPowerOfTwo ( $ x ) { return $ x && ( ! ( $ x & ( $ x - 1 ) ) ) ; } if ( isPowerOfTwo ( 31 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; if ( isPowerOfTwo ( 64 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Kuasa terkecil 2 yang lebih besar daripada atau sama dengan jumlah unsur array | Berfungsi untuk mencari kuasa terdekat 2; Nombornya; Jika sudah menjadi kuasa 2; Cari kuasa seterusnya 2; Berfungsi untuk mencari memori yang digunakan; Jumlah array; Melintasi dan mencari jumlah array; Fungsi panggilan untuk mencari kuasa terdekat 2; Kod pemacu", "code": "< ? php function nextPowerOf2 ( $ n ) { $ p = 1 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ p < $ n ) $ p <<= 1 ; return $ p ; } function memoryUsed ( & $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; $ nearest = nextPowerOf2 ( $ sum ) ; return $ nearest ; } $ arr = array ( 1 , 2 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; echo ( memoryUsed ( $ arr , $ n ) ) ; ? >"}
{"text": "Toggling k | Program PHP untuk bertukar -tukar k - th bit n; Kod pemacu", "code": "< ? php function toggleKthBit ( $ n , $ k ) { return ( $ n ^ ( 1 << ( $ k - 1 ) ) ) ; } $ n = 5 ; $ k = 1 ; echo toggleKthBit ( $ n , $ k ) ; ? >"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Program PHP untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Pertama n dalam keadaan di bawah adalah untuk kes di mana n adalah 0; Kod pemacu", "code": "< ? php function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; } $ n = 0 ; echo ( nextPowerOf2 ( $ n ) ) ; ? >"}
{"text": "Nombor Tetranacci | Berfungsi untuk mencetak nombor tetranacci N - th; Memulakan empat nombor pertama untuk kes asas; mengisytiharkan pemboleh ubah semasa; Gelung untuk menambah empat nombor sebelumnya untuk setiap nombor bermula dari 4 dan kemudian berikan pertama, kedua, ketiga hingga kedua, ketiga, keempat dan curr masing -masing; Kod pemacu", "code": "< ? php function printTetra ( $ n ) { if ( $ n < 0 ) return ; $ first = 0 ; $ second = 1 ; $ third = 1 ; $ fourth = 2 ; $ curr ; if ( $ n == 0 ) echo $ first ; else if ( $ n == 1 $ n == 2 ) echo $ second ; else if ( $ n == 3 ) echo $ fourth ; else { for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) { $ curr = $ first + $ second + $ third + $ fourth ; $ first = $ second ; $ second = $ third ; $ third = $ fourth ; $ fourth = $ curr ; } echo $ curr ; } } $ n = 10 ; printTetra ( $ n ) ; ? >"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Fungsi rekursif yang digunakan oleh Countways; Kod pemacu", "code": "< ? php function countWays ( $ n ) { $ res [ 0 ] = 1 ; $ res [ 1 ] = 1 ; $ res [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ res [ $ i ] = $ res [ $ i - 1 ] + $ res [ $ i - 2 ] + $ res [ $ i - 3 ] ; return $ res [ $ n ] ; } $ n = 4 ; echo countWays ( $ n ) ; ? >"}
{"text": "Pengaturcaraan Dinamik | Tinggi | Mengembalikan jumlah tugas maksimum yang boleh dilakukan sehingga hari n; Jika n kurang daripada sama dengan 0, maka tiada penyelesaian wujud; Menentukan tugas mana yang hendak dipilih pada hari n, kemudian mengembalikan maksimum sehingga hari itu; Kod pemacu", "code": "< ? php function maxTasks ( $ high , $ low , $ n ) { if ( $ n <= 0 ) return 0 ; return max ( $ high [ $ n - 1 ] + maxTasks ( $ high , $ low , ( $ n - 2 ) ) , $ low [ $ n - 1 ] + maxTasks ( $ high , $ low , ( $ n - 1 ) ) ) ; } $ n = 5 ; $ high = array ( 3 , 6 , 8 , 7 , 6 ) ; $ low = array ( 1 , 5 , 4 , 5 , 3 ) ; print ( maxTasks ( $ high , $ low , $ n ) ) ; ? >"}
{"text": "Kira substrings yang bermula dengan aksara x dan berakhir dengan watak y | fungsi untuk mengira substrings bermula dengan aksara x dan berakhir dengan watak y; untuk menyimpan jumlah jumlah substring yang diperlukan; Untuk menyimpan kiraan watak 'x' sehingga titik rentetan 'str' telah dilalui setakat ini; Bentuk 'Str' yang tersisa ke kanan; jika benar, kenaikan 'kenaikan _ x'; jika benar mengumpul 'kiraan _ x' ke 'tot _ count'; kiraan yang diperlukan; Kod pemacu", "code": "< ? php function countSubstr ( $ str , $ n , $ x , $ y ) { $ tot_count = 0 ; $ count_x = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ x ) $ count_x ++ ; if ( $ str [ $ i ] == $ y ) $ tot_count += $ count_x ; } return $ tot_count ; } $ str = \" abbcaceghcak \" ; $ n = strlen ( $ str ) ; $ x = ' a ' ; $ y = ' c ' ; echo \" Count = \""}
{"text": "Kira perkataan dalam rentetan yang diberikan | Program PHP untuk mengira tiada kata -kata dari rentetan input yang diberikan; mengembalikan bilangan perkataan dalam str; kiraan perkataan; Imbas semua watak satu demi satu; Jika watak seterusnya adalah pemisah, tetapkan keadaan sebagai keluar; Jika watak seterusnya bukan pemisah perkataan dan keadaan keluar, maka tetapkan keadaan seperti dalam dan kiraan kata kenaikan; Pindah ke watak seterusnya; Kod pemacu", "code": "< ? php $ OUT = 0 ; $ IN = 1 ; function countWords ( $ str ) { global $ OUT , $ IN ; $ state = $ OUT ; $ wc = 0 ; $ i = 0 ; while ( $ i < strlen ( $ str ) ) { if ( $ str [ $ i ] == \" ▁ \" $ str [ $ i ] == \" STRNEWLINE \" $ str [ $ i ] == \" TABSYMBOL \" ) $ state = $ OUT ; else if ( $ state == $ OUT ) { $ state = $ IN ; ++ $ wc ; } ++ $ i ; } return $ wc ; } $ str = \" One ▁ two TABSYMBOL TABSYMBOL three STRNEWLINE ▁ four TABSYMBOL five ▁ \" ; echo \" No ▁ of ▁ words ▁ : ▁ \" . countWords ( $ str ) ; ? >"}
{"text": "Nombor Enneadecagonal | Berfungsi untuk mengira nombor enneadecagonal; Formula untuk mencari nombor enneadecagonal nth; Kod pemacu", "code": "< ? php function nthEnneadecagonal ( $ n ) { return ( 17 * $ n * $ n - 15 * $ n ) / 2 ; } $ n = 6 ; echo $ n , \" th ▁ Enneadecagonal ▁ number ▁ : \" , nthEnneadecagonal ( $ n ) ; ? >"}
{"text": "Kawasan lingkaran yang dilampirkan dari persegi | Program PHP untuk mencari kawasan bulatan yang dilampirkan; fungsi mengembalikan kawasan; Kod pemacu", "code": "< ? php $ PI = 3.14159265 ; function areacircumscribed ( $ a ) { global $ PI ; return ( $ a * $ a * ( $ PI / 2 ) ) ; } $ a = 6 ; echo \" ▁ Area ▁ of ▁ an ▁ circumscribed ▁ circle ▁ is ▁ : ▁ \" , areacircumscribed ( $ a ) ; ? >"}
{"text": "Nombor Tetranacci | Berfungsi untuk mengembalikan nombor tetranacci N; kes asas; kes asas; kes asas; berfungsi untuk mencetak nombor tetranacci nth; Kod pemacu", "code": "< ? php function printTetraRec ( $ n ) { if ( $ n == 0 ) return 0 ; if ( $ n == 1 $ n == 2 ) return 1 ; if ( $ n == 3 ) return 2 ; else return printTetraRec ( $ n - 1 ) + printTetraRec ( $ n - 2 ) + printTetraRec ( $ n - 3 ) + printTetraRec ( $ n - 4 ) ; } function printTetra ( $ n ) { echo printTetraRec ( $ n ) . \" \" ; } $ n = 10 ; printTetra ( $ n ) ; ? >"}
{"text": "Pengaturcaraan Dinamik | Tinggi | Program PHP berasaskan DP untuk mencari tugas maksimum. Mengembalikan maksimum di antara 2 nombor; Mengembalikan maksimum di antara 2 nombor; Mengembalikan jumlah tugas maksimum yang boleh dilakukan sehingga hari n; Task_dp array yang menyimpan tugas maksimum yang dilakukan; Jika n = 0, tiada penyelesaian wujud; Jika n = 1, tugas usaha yang tinggi pada hari itu akan menjadi penyelesaian; Isi keseluruhan array menentukan tugas mana yang hendak dipilih pada hari I; Kod pemacu", "code": "< ? php function max1 ( $ x , $ y ) { return ( $ x > $ y ? $ x : $ y ) ; } return ( $ x > $ y ? $ x : $ y ) ; } function maxTasks ( $ high , $ low , $ n ) { $ task_dp = array ( $ n + 1 ) ; $ task_dp [ 0 ] = 0 ; $ task_dp [ 1 ] = $ high [ 0 ] ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ task_dp [ $ i ] = max ( $ high [ $ i - 1 ] + $ task_dp [ $ i - 2 ] , $ low [ $ i - 1 ] + $ task_dp [ $ i - 1 ] ) ; return $ task_dp [ $ n ] ; } { $ n = 5 ; $ high = array ( 3 , 6 , 8 , 7 , 6 ) ; $ low = array ( 1 , 5 , 4 , 5 , 3 ) ; echo ( maxTasks ( $ high , $ low , $ n ) ) ; }"}
{"text": "Koefisien Permutasi | A o (n) masa dan O (1) penyelesaian PHP ruang tambahan untuk mengira pekali permutasi; Kirakan N! dan (n - k)! ; Kod pemacu", "code": "< ? php function PermutationCoeff ( $ n , $ k ) { $ Fn = 1 ; $ Fk ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ Fn *= $ i ; if ( $ i == $ n - $ k ) $ Fk = $ Fn ; } $ coeff = $ Fn / $ Fk ; return $ coeff ; } $ n = 10 ; $ k = 2 ; echo \" Value ▁ of ▁ P ( \" , $ n , \" , ▁ \" , $ k , \" ) STRNEWLINE TABSYMBOL TABSYMBOL is ▁ \" , PermutationCoeff ( $ n , $ k ) ; ? >"}
{"text": "DFA untuk rentetan tidak berakhir dengan \"The\" | DFA memberitahu nombor yang berkaitan dengan keadaan sekarang; Fungsi ini adalah untuk keadaan permulaan (zeroth) DFA; Apabila menerima 'T' atau 'T' Goto State First (1); Fungsi ini adalah untuk keadaan pertama DFA; Apabila menerima 'T' atau 'T' Goto State First (1); Apabila menerima 'H' atau 'H' Goto kedua negeri (2); lain Goto State State (0); Fungsi ini adalah untuk keadaan kedua DFA; Apabila menerima 'E' atau 'E' Goto Negeri Ketiga (3) Lain Goto State State (0); Fungsi ini adalah untuk keadaan ketiga DFA; Apabila menerima 'T' atau 'T' Goto State First (1) Lain Goto State State (0); panjang simpan rentetan; Kod pemacu", "code": "< ? php $ dfa = 0 ; function start ( $ c ) { global $ dfa ; if ( $ c == ' t ' $ c == ' T ' ) $ dfa = 1 ; } function state1 ( $ c ) { global $ dfa ; if ( $ c == ' t ' $ c == ' T ' ) $ dfa = 1 ; else if ( $ c == ' h ' $ c == ' H ' ) $ dfa = 2 ; else $ dfa = 0 ; } function state2 ( $ c ) { global $ dfa ; if ( $ c == ' e ' $ c == ' E ' ) $ dfa = 3 ; else $ dfa = 0 ; } function state3 ( $ c ) { global $ dfa ; if ( $ c == ' t ' $ c == ' T ' ) $ dfa = 1 ; else $ dfa = 0 ; } function isAccepted ( $ str ) { global $ dfa ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ dfa == 0 ) start ( $ str [ $ i ] ) ; else if ( $ dfa == 1 ) state1 ( $ str [ $ i ] ) ; else if ( $ dfa == 2 ) state2 ( $ str [ $ i ] ) ; else state3 ( $ str [ $ i ] ) ; } return ( $ dfa != 3 ) ; } $ str = \" forTHEgeeks \" ; if ( isAccepted ( $ str ) == true ) echo \" ACCEPTED STRNEWLINE \" ; else echo \" NOT ▁ ACCEPTED STRNEWLINE \" ; ? >"}
{"text": "Semak sama ada rentetan yang diberikan boleh dijana selepas menyatukan rentetan yang diberikan | Fungsi yang kembali benar jika pra adalah awalan str; Walaupun ada watak untuk dipadankan; Jika watak berbeza di mana -mana kedudukan; STR bermula dengan pra; Fungsi yang kembali benar jika Suff adalah akhiran str; Walaupun ada watak untuk dipadankan; Aksara i $ f berbeza di mana -mana kedudukan; str berakhir dengan suff; Fungsi yang kembali benar jika str = a + b atau str = b + a; STR tidak boleh dihasilkan dengan menggabungkan A dan B; Jika str bermula dengan i. e. A adalah awalan str; Semak sama ada watak -watak yang lain adalah sama dengan b i. e. B adalah akhiran str; Jika str bermula dengan b i. e. B adalah awalan str; Semak sama ada watak -watak yang lain adalah sama dengan i. e. A adalah akhiran str; Kod pemacu", "code": "< ? php function startsWith ( $ str , $ pre ) { $ strLen = strlen ( $ str ) ; $ preLen = strlen ( $ pre ) ; $ i = 0 ; $ j = 0 ; while ( $ i < $ strLen && $ j < $ preLen ) { if ( $ str [ $ i ] != $ pre [ $ j ] ) return false ; $ i ++ ; $ j ++ ; } return true ; } function endsWith ( $ str , $ suff ) { $ i = strlen ( $ str ) - 0 ; $ j = strlen ( $ suff ) - 0 ; while ( $ i >= 0 && $ j >= 0 ) { if ( $ str [ $ i ] != $ suff [ $ j ] ) return false ; $ i -- ; $ j -- ; } return true ; } function checkString ( $ str , $ a , $ b ) { if ( strlen ( $ str ) != strlen ( $ a ) + strlen ( $ b ) ) return false ; if ( startsWith ( $ str , $ a ) ) { if ( endsWith ( $ str , $ b ) ) return true ; } if ( startsWith ( $ str , $ b ) ) { if ( endsWith ( $ str , $ a ) ) return true ; } return false ; } $ str = \" GeeksforGeeks \" ; $ a = \" Geeksfo \" ; $ b = \" rGeeks \" ; if ( checkString ( $ str , $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Bilangan minimum operasi untuk memindahkan semua aksara huruf besar sebelum semua aksara kes yang lebih rendah | Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan; Untuk menyimpan indeks huruf besar terakhir dan watak huruf kecil pertama; Cari watak huruf besar terakhir; Cari watak huruf kecil pertama; Jika semua watak adalah huruf besar atau huruf kecil; Kiraan aksara huruf besar yang muncul selepas watak huruf kecil pertama; Count huruf kecil yang muncul sebelum watak huruf besar terakhir; Mengembalikan operasi minimum yang diperlukan; Kod pemacu", "code": "< ? php function minOperations ( $ str , $ n ) { $ i ; $ lastUpper = -1 ; $ firstLower = -1 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( ctype_upper ( $ str [ $ i ] ) ) { $ lastUpper = $ i ; break ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ctype_lower ( $ str [ $ i ] ) ) { $ firstLower = $ i ; break ; } } if ( $ lastUpper == -1 $ firstLower == -1 ) return 0 ; $ countUpper = 0 ; for ( $ i = $ firstLower ; $ i < $ n ; $ i ++ ) { if ( ctype_upper ( $ str [ $ i ] ) ) { $ countUpper ++ ; } } $ countLower = 0 ; for ( $ i = 0 ; $ i < $ lastUpper ; $ i ++ ) { if ( ctype_lower ( $ str [ $ i ] ) ) { $ countLower ++ ; } } return min ( $ countLower , $ countUpper ) ; } { $ str = \" geEksFOrGEekS \" ; $ n = strlen ( $ str ) ; echo ( minOperations ( $ str , $ n ) ) ; } ? >"}
{"text": "Kebarangkalian hujan pada hari n + 1 | | Fungsi untuk mencari kebarangkalian; kiraan 1; Cari kebarangkalian; Kod pemacu", "code": "< ? php function rainDayProbability ( $ a , $ n ) { $ count = 0 ; $ m ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 1 ) $ count ++ ; } $ m = $ count / $ n ; return $ m ; } $ a = array ( 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ) ; $ n = count ( $ a ) ; echo rainDayProbability ( $ a , $ n ) ; ? >"}
{"text": "Program untuk mencari jumlah siri 1 + 1/2 ^ 2 + 1/3 ^ 3 + â € |. . + 1 / n ^ n | Fungsi untuk mengira siri berikut; Kod pemacu", "code": "< ? php function Series ( $ n ) { $ i ; $ sums = 0.0 ; $ ser ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ ser = 1 / pow ( $ i , $ i ) ; $ sums += $ ser ; } return $ sums ; } $ n = 3 ; $ res = Series ( $ n ) ; echo $ res ; ? >"}
{"text": "Carian Ternary | Berfungsi untuk melakukan carian ternary; Cari Mid1 dan Mid2; Semak sama ada kunci hadir di mana -mana pertengahan; Oleh kerana kunci tidak hadir pada pertengahan, periksa di mana rantau ia hadir kemudian ulangi operasi carian di rantau itu; Kunci terletak di antara L dan MID1; Kunci terletak di antara Mid2 dan R; Kuncinya terletak di antara Mid1 dan Mid2; Kunci tidak dijumpai; Dapatkan array jenis array jika tidak disusun; Indeks permulaan; panjang array; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya", "code": "< ? php function ternarySearch ( $ l , $ r , $ key , $ ar ) { if ( $ r >= $ l ) { $ mid1 = ( int ) ( $ l + ( $ r - $ l ) / 3 ) ; $ mid2 = ( int ) ( $ r - ( $ r - $ l ) / 3 ) ; if ( $ ar [ $ mid1 ] == $ key ) { return $ mid1 ; } if ( $ ar [ $ mid2 ] == $ key ) { return $ mid2 ; } if ( $ key < $ ar [ $ mid1 ] ) { return ternarySearch ( $ l , $ mid1 - 1 , $ key , $ ar ) ; } else if ( $ key > $ ar [ $ mid2 ] ) { return ternarySearch ( $ mid2 + 1 , $ r , $ key , $ ar ) ; } else { return ternarySearch ( $ mid1 + 1 , $ mid2 - 1 , $ key , $ ar ) ; } } return -1 ; } $ ar = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; $ l = 0 ; $ r = 9 ; $ key = 5 ; $ p = ternarySearch ( $ l , $ r , $ key , $ ar ) ; echo \" Index ▁ of ▁ \" , $ key , \" ▁ is ▁ \" , ( int ) $ p , \" STRNEWLINE \" ; $ key = 50 ; $ p = ternarySearch ( $ l , $ r , $ key , $ ar ) ; echo \" Index ▁ of ▁ \" , $ key , \" ▁ is ▁ \" , ( int ) $ p , \" STRNEWLINE \" ; ? >"}
{"text": "Cetak watak dan frekuensi mereka mengikut urutan kejadian | Pelaksanaan PHP untuk mencetak watak dan kekerapannya mengikut urutan kejadiannya; berfungsi untuk mencetak watak dan kekerapannya mengikut urutan kejadiannya; saiz rentetan 'str'; 'freq []' dilaksanakan sebagai jadual hash; mengumpul kekerapan setiap watak dalam 'str'; melintasi 'str' dari kiri ke kanan; jika kekerapan watak str [i] tidak sama dengan 0; Cetak watak bersama kekerapannya; Kemas kini kekerapan STR [i] hingga 0 supaya watak yang sama tidak dicetak lagi; Kod pemacu", "code": "< ? php $ SIZE = 26 ; function printCharWithFreq ( $ str ) { global $ SIZE ; $ n = strlen ( $ str ) ; $ freq = array_fill ( 0 , $ SIZE , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] != 0 ) { echo $ str [ $ i ] . $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] . \" \" ; $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] = 0 ; } } } $ str = \" geeksforgeeks \" ; printCharWithFreq ( $ str ) ; ? >"}
{"text": "Semak simetri mendatar dan menegak dalam matriks binari | Program PHP untuk mencari jika matriks adalah simetri. ; Memulakan sebagai simetri mendatar dan menegak. ; Memeriksa simetri mendatar. Kami membandingkan baris pertama dengan baris terakhir, baris kedua dengan barisan terakhir kedua dan sebagainya. ; Memeriksa setiap sel lajur. ; Semak jika setiap sel adalah sama; Memeriksa simetri menegak. Kami membandingkan lajur pertama dengan lajur terakhir, xolumn kedua dengan lajur terakhir kedua dan sebagainya. ; Memeriksa setiap sel baris. ; Semak jika setiap sel adalah sama; Kod pemacu", "code": "< ? php function checkHV ( $ arr , $ N , $ M ) { $ horizontal = true ; $ vertical = true ; for ( $ i = 0 , $ k = $ N - 1 ; $ i < $ N / 2 ; $ i ++ , $ k -- ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { if ( $ arr [ $ i ] [ $ j ] != $ arr [ $ k ] [ $ j ] ) { $ horizontal = false ; break ; } } } for ( $ i = 0 , $ k = $ M - 1 ; $ i < $ M / 2 ; $ i ++ , $ k -- ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ arr [ $ i ] [ $ j ] != $ arr [ $ k ] [ $ j ] ) { $ horizontal = false ; break ; } } } if ( ! $ horizontal && ! $ vertical ) echo \" NO STRNEWLINE \" ; else if ( $ horizontal && ! $ vertical ) cout << \" HORIZONTAL STRNEWLINE \" ; else if ( $ vertical && ! $ horizontal ) echo \" VERTICAL STRNEWLINE \" ; else echo \" BOTH STRNEWLINE \" ; } $ mat = array ( array ( 1 , 0 , 1 ) , array ( 0 , 0 , 0 ) , array ( 1 , 0 , 1 ) ) ; checkHV ( $ mat , 3 , 3 ) ; ? >"}
{"text": "Program untuk penambahan dua matriks | Program PHP untuk penambahan dua matriks; Fungsi ini menambah [] [] dan b [] [], dan menyimpan hasil dalam c [] []; Kod pemacu", "code": "< ? php $ N = 4 ; function add ( & $ A , & $ B , & $ C ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ C [ $ i ] [ $ j ] = $ A [ $ i ] [ $ j ] + $ B [ $ i ] [ $ j ] ; } $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ B = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ N = 4 ; add ( $ A , $ B , $ C ) ; echo \" Result ▁ matrix ▁ is ▁ STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { echo $ C [ $ i ] [ $ j ] ; echo \" ▁ \" ; } echo \" STRNEWLINE \" ; } ? >"}
{"text": "Program untuk pengurangan matriks | Fungsi ini menolak B [] [] dari [] [], dan menyimpan hasil dalam C [] []; Kod pemacu", "code": "< ? php function subtract ( & $ A , & $ B , & $ C ) { $ N = 4 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ C [ $ i ] [ $ j ] = $ A [ $ i ] [ $ j ] - $ B [ $ i ] [ $ j ] ; } $ N = 4 ; $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ B = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; subtract ( $ A , $ B , $ C ) ; echo \" Result ▁ matrix ▁ is ▁ STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { echo $ C [ $ i ] [ $ j ] ; echo \" ▁ \" ; } echo \" STRNEWLINE \" ; } ? >"}
{"text": "Cari titik tetap (nilai sama dengan indeks) dalam array yang diberikan | Program PHP untuk memeriksa titik tetap dalam array menggunakan carian linear; Jika tiada titik tetap hadir kemudian kembali - 1; Kod pemacu", "code": "< ? php function linearSearch ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ i ) return $ i ; } return -1 ; } $ arr = array ( -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 ) ; $ n = count ( $ arr ) ; echo \" Fixed ▁ Point ▁ is ▁ \" . linearSearch ( $ arr , $ n ) ; ? >"}
{"text": "Cari titik tetap (nilai sama dengan indeks) dalam array yang diberikan | Program PHP untuk memeriksa PO tetap dalam array menggunakan carian binari; rendah + (tinggi - rendah) / 2; ; Kembali - 1 jika tidak ada po tetap; Kod pemacu", "code": "< ? php function binarySearch ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = ( int ) ( ( $ low + $ high ) / 2 ) ; if ( $ mid == $ arr [ $ mid ] ) return $ mid ; if ( $ mid > $ arr [ $ mid ] ) return binarySearch ( $ arr , ( $ mid + 1 ) , $ high ) ; else return binarySearch ( $ arr , $ low , ( $ mid - 1 ) ) ; } return -1 ; } $ arr = array ( -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 ) ; $ n = count ( $ arr ) ; echo \" Fixed ▁ Point ▁ is : ▁ \" . binarySearch ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text": "Jumlah maksimum triplet dalam array | Kod PHP untuk mencari jumlah triplet maksimum; Memulakan jumlah dengan int_min; Kod pemacu", "code": "< ? php function maxTripletSum ( $ arr , $ n ) { $ sum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ sum < $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] ) $ sum = $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] ; return $ sum ; } $ arr = array ( 1 , 0 , 8 , 6 , 4 , 2 ) ; $ n = count ( $ arr ) ; echo maxTripletSum ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah maksimum triplet dalam array | Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya tiga elemen dalam ARR []. ; Susun array yang diberikan; Selepas menyusun array. Tambah tiga elemen terakhir dari array yang diberikan; Kod pemacu", "code": "< ? php function maxTripletSum ( $ arr , $ n ) { sort ( $ arr ) ; return $ arr [ $ n - 1 ] + $ arr [ $ n - 2 ] + $ arr [ $ n - 3 ] ; } $ arr = array ( 1 , 0 , 8 , 6 , 4 , 2 ) ; $ n = count ( $ arr ) ; echo maxTripletSum ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah maksimum triplet dalam array | Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya tiga elemen dalam ARR []. ; Memulakan elemen maksimum maksimum dan maksimum maksimum maksimum; Mengemas kini elemen maksimum maksimum dan ketiga; Mengemas kini elemen maksimum maksimum dan ketiga; Mengemas kini elemen maksimum ketiga; Kod yang didorong", "code": "< ? php function maxTripletSum ( $ arr , $ n ) { $ maxA = PHP_INT_MIN ; $ maxB = PHP_INT_MIN ; $ maxC = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ maxA ) { $ maxC = $ maxB ; $ maxB = $ maxA ; $ maxA = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ maxB ) { $ maxC = $ maxB ; $ maxB = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ maxC ) $ maxC = $ arr [ $ i ] ; } return ( $ maxA + $ maxB + $ maxC ) ; } $ arr = array ( 1 , 0 , 8 , 6 , 4 , 2 ) ; $ n = count ( $ arr ) ; echo maxTripletSum ( $ arr , $ n ) ; ? >"}
{"text": "Carian Linear | Kod PHP untuk carian linear x dalam arr []. Jika x hadir kemudian kembalikan lokasi, jika tidak, pulangan - 1; Kod pemacu; Panggilan fungsi", "code": "< ? php function search ( $ arr , $ x ) { $ n = sizeof ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; } return -1 ; } $ arr = array ( 2 , 3 , 4 , 10 , 40 ) ; $ x = 10 ; $ result = search ( $ arr , $ x ) ; if ( $ result == -1 ) echo \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ; else echo \" Element ▁ is ▁ present ▁ at ▁ index ▁ \" , $ result ; ? >"}
{"text": "Mengira jenis | Program PHP untuk mengira jenis; Fungsi utama yang menyusun rentetan yang diberikan [] dalam urutan abjad; Pelbagai watak output yang akan menyusun ARR; Buat array kiraan untuk menyimpan kiraan aksara inidividul dan memulakan array kiraan sebagai 0; Menyimpan kiraan setiap watak; Tukar kiraan [i] supaya kiraan [i] kini mengandungi kedudukan sebenar watak ini dalam pelbagai output; Bina pelbagai watak output untuk menjadikannya stabil, kami beroperasi dalam urutan terbalik. ; Salin array output ke ARR, supaya ARR kini mengandungi aksara yang disusun; Kod pemacu", "code": "< ? php $ RANGE = 255 ; function countSort ( $ arr ) { global $ RANGE ; $ output = array ( strlen ( $ arr ) ) ; $ len = strlen ( $ arr ) ; $ count = array_fill ( 0 , $ RANGE + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) ++ $ count [ ord ( $ arr [ $ i ] ) ] ; for ( $ i = 1 ; $ i <= $ RANGE ; ++ $ i ) $ count [ $ i ] += $ count [ $ i - 1 ] ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { $ output [ $ count [ ord ( $ arr [ $ i ] ) ] - 1 ] = $ arr [ $ i ] ; -- $ count [ ord ( $ arr [ $ i ] ) ] ; } for ( $ i = 0 ; $ i < $ len ; ++ $ i ) $ arr [ $ i ] = $ output [ $ i ] ; return $ arr ; } $ arr = \" geeksforgeeks \" ; $ arr = countSort ( $ arr ) ; echo \" Sorted ▁ character ▁ array ▁ is ▁ \" . $ arr ; ? >"}
{"text": "Koefisien binomial | DP | Pulangan nilai pekali binomial c (n, k); Kes asas; Berulang; Kod pemacu", "code": "< ? php function binomialCoeff ( $ n , $ k ) { if ( $ k > $ n ) return 0 ; if ( $ k == 0 $ k == $ n ) return 1 ; return binomialCoeff ( $ n - 1 , $ k - 1 ) + binomialCoeff ( $ n - 1 , $ k ) ; } $ n = 5 ; $ k = 2 ; echo \" Value ▁ of ▁ C \" , \" ( \" , $ n , $ k , \" ) ▁ is ▁ \" , binomialCoeff ( $ n , $ k ) ; ? >"}
{"text": "Koefisien binomial | DP | Program PHP untuk Penyelesaian Pengaturcaraan Dinamik Dioptimumkan Ruang Koefisien Binomial; NC0 adalah 1; Kirakan baris seterusnya segitiga Pascal menggunakan baris sebelumnya; Kod pemacu", "code": "< ? php function binomialCoeff ( $ n , $ k ) { $ C = array_fill ( 0 , $ k + 1 , 0 ) ; $ C [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ k ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C [ $ k ] ; } $ n = 5 ; $ k = 2 ; echo \" Value ▁ of ▁ C [ $ n , ▁ $ k ] ▁ is ▁ \" . binomialCoeff ( $ n , $ k ) ; ? >"}
{"text": "Pengaturcaraan Dinamik | Pulangan benar jika terdapat subset set dengan matahari sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Kod pemacu", "code": "< ? php function isSubsetSum ( $ set , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ set [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ set , $ n - 1 , $ sum ) ; return isSubsetSum ( $ set , $ n - 1 , $ sum ) || isSubsetSum ( $ set , $ n - 1 , $ sum - $ set [ $ n - 1 ] ) ; } $ set = array ( 3 , 34 , 4 , 12 , 5 , 2 ) ; $ sum = 9 ; $ n = 6 ; if ( isSubsetSum ( $ set , $ n , $ sum ) == true ) echo \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ; else echo \" No ▁ subset ▁ with ▁ given ▁ sum \" ; ? >"}
{"text": "Pengaturcaraan Dinamik | Pulangan benar jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara Botton; Jadual Cetak; Kod pemacu", "code": "< ? php function isSubsetSum ( $ set , $ n , $ sum ) { $ subset = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ subset [ $ i ] [ 0 ] = true ; for ( $ i = 1 ; $ i <= $ sum ; $ i ++ ) $ subset [ 0 ] [ $ i ] = false ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ sum ; $ j ++ ) { if ( $ j < $ set [ $ i - 1 ] ) $ subset [ $ i ] [ $ j ] = $ subset [ $ i - 1 ] [ $ j ] ; if ( $ j >= $ set [ $ i - 1 ] ) $ subset [ $ i ] [ $ j ] = $ subset [ $ i - 1 ] [ $ j ] || $ subset [ $ i - 1 ] [ $ j - $ set [ $ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( \" % 4d \" , subset [ i ] [ j ] ) ; printf ( \" n \" ) ; } return $ subset [ $ n ] [ $ sum ] ; } $ set = array ( 3 , 34 , 4 , 12 , 5 , 2 ) ; $ sum = 9 ; $ n = count ( $ set ) ; if ( isSubsetSum ( $ set , $ n , $ sum ) == true ) echo \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ; else echo \" No ▁ subset ▁ with ▁ given ▁ sum \" ; ? >"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Fungsi rekursif yang mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7; Memulakan hasil; Cuba semua rehat yang mungkin - mata untuk mana -mana kekunci n, kita perlu gelung dari n - 3 kekunci kembali ke 1 keystroke untuk mencari breakpoint 'b' selepas itu kita akan mempunyai ctrl - a, ctrl - c dan kemudian hanya ctrl - v sepanjang jalan. ; Jika titik putus adalah s pada b 'th keystroke maka rentetan optimum akan mempunyai panjang (n-b-1)*skrin [b-1]; ; Kod pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "< ? php function findoptimal ( $ N ) { if ( $ N <= 6 ) return $ N ; $ max = 0 ; $ b ; for ( $ b = $ N - 3 ; $ b >= 1 ; $ b -= 1 ) { $ curr = ( $ N - $ b - 1 ) * findoptimal ( $ b ) ; if ( $ curr > $ max ) $ max = $ curr ; } return $ max ; } $ N ; for ( $ N = 1 ; $ N <= 20 ; $ N += 1 ) echo ( \" Maximum ▁ Number ▁ of ▁ A ' s ▁ with \" . $ N . \" keystrokes ▁ is ▁ \" . findoptimal ( $ N ) . \" STRNEWLINE \" ) ; ? >"}
{"text": "Tulis program untuk mengira POW (x, n) | Fungsi untuk mengira x yang dibangkitkan kepada kuasa y; Kod pemacu", "code": "< ? php function power ( $ x , $ y ) { if ( $ y == 0 ) return 1 ; else if ( $ y % 2 == 0 ) return power ( $ x , ( int ) $ y / 2 ) * power ( $ x , ( int ) $ y / 2 ) ; else return $ x * power ( $ x , ( int ) $ y / 2 ) * power ( $ x , ( int ) $ y / 2 ) ; } $ x = 2 ; $ y = 3 ; echo power ( $ x , $ y ) ; ? >"}
{"text": "Tulis program untuk mengira POW (x, n) | Versi fungsi kuasa yang dilanjutkan yang boleh berfungsi untuk Float X dan negatif y; Kod pemacu", "code": "< ? php function power ( $ x , $ y ) { $ temp ; if ( $ y == 0 ) return 1 ; $ temp = power ( $ x , $ y / 2 ) ; if ( $ y % 2 == 0 ) return $ temp * $ temp ; else { if ( $ y > 0 ) return $ x * $ temp * $ temp ; else return ( $ temp * $ temp ) / $ x ; } } $ x = 2 ; $ y = -3 ; echo power ( $ x , $ y ) ; ? >"}
{"text": "Kaedah Babylon untuk Root Square | Mengembalikan akar kuadrat n. Perhatikan bahawa fungsi itu; Kami menggunakan N sendiri sebagai penghampiran awal ini pasti dapat diperbaiki; E memutuskan tahap ketepatan; Kod pemacu", "code": "< ? php function squareRoot ( $ n ) { $ x = $ n ; $ y = 1 ; $ e = 0.000001 ; while ( $ x - $ y > $ e ) { $ x = ( $ x + $ y ) / 2 ; $ y = $ n / $ x ; } return $ x ; } { $ n = 50 ; echo \" Square ▁ root ▁ of ▁ $ n ▁ is ▁ \" , squareRoot ( $ n ) ; } ? >"}
{"text": "Purata aliran nombor | Mengembalikan purata baru selepas termasuk x; Mencetak purata aliran nombor; Kod pemacu", "code": "< ? php function getAvg ( $ prev_avg , $ x , $ n ) { return ( $ prev_avg * $ n + $ x ) / ( $ n + 1 ) ; } function streamAvg ( $ arr , $ n ) { $ avg = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ avg = getAvg ( $ avg , $ arr [ $ i ] , $ i ) ; echo \" Average ▁ of ▁ \" , $ i + 1 , \" numbers ▁ is ▁ \" , $ avg , \" STRNEWLINE \" ; } return ; } $ arr = array ( 10 , 20 , 30 , 40 , 50 , 60 ) ; $ n = sizeof ( $ arr ) ; streamAvg ( $ arr , $ n ) ; ? >"}
{"text": "Purata aliran nombor | Mengembalikan purata baru selepas termasuk x; Mencetak purata aliran nombor; Kod pemacu", "code": "< ? php function getAvg ( $ x ) { static $ sum ; static $ n ; $ sum += $ x ; return ( ( ( float ) $ sum ) / ++ $ n ) ; } function streamAvg ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ avg = getAvg ( $ arr [ $ i ] ) ; echo \" Average ▁ of ▁ \" . ( $ i + 1 ) . \" ▁ numbers ▁ is ▁ \" . $ avg . \" ▁ STRNEWLINE \" ; } return ; } $ arr = array ( 10 , 20 , 30 , 40 , 50 , 60 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; streamAvg ( $ arr , $ n ) ; ? >"}
{"text": "Koefisien Binomial Ruang dan Masa yang cekap | Pulangan nilai pekali binomial c (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Kod pemacu", "code": "< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; } $ n = 8 ; $ k = 2 ; echo \" ▁ Value ▁ of ▁ C ▁ ( $ n , ▁ $ k ) ▁ is ▁ \" , binomialCoeff ( $ n , $ k ) ; ? >"}
{"text": "Program yang cekap untuk mencetak semua faktor utama nombor tertentu | berfungsi untuk mencetak semua faktor utama nombor n tertentu; Cetak bilangan 2 s yang membahagikan n; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, cetak saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Kod pemacu", "code": "< ? php function primeFactors ( $ n ) { while ( $ n % 2 == 0 ) { echo 2 , \" ▁ \" ; $ n = $ n / 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { while ( $ n % $ i == 0 ) { echo $ i , \" \" ; $ n = $ n / $ i ; } } if ( $ n > 2 ) echo $ n , \" ▁ \" ; } $ n = 315 ; primeFactors ( $ n ) ; ? >"}
{"text": "Cetak semua kemungkinan kombinasi elemen R dalam pelbagai saiz n | Fungsi utama yang mencetak semua kombinasi saiz r dalam arr [] saiz n. Fungsi ini terutamanya menggunakan gabunganUtil (); Arahan sementara untuk menyimpan semua gabungan satu demi satu; Cetak semua kombinasi menggunakan data temprary array [] '; arr [] - -> data array input [] - -> array sementara untuk menyimpan kombinasi semasa & akhir - -> menatap dan mengakhiri indeks dalam arr [] indeks - -> indeks semasa dalam data [] r - -> saiz kombinasi yang akan dicetak; Gabungan semasa sudah siap dicetak, mencetaknya; Gantikan indeks dengan semua elemen yang mungkin. Keadaan \"Akhir - I + 1 = u r - indeks\" memastikan bahawa termasuk satu elemen di indeks akan membuat kombinasi dengan elemen yang tinggal pada kedudukan yang tinggal; Kod pemacu", "code": "< ? php function printCombination ( $ arr , $ n , $ r ) { $ data = array ( ) ; combinationUtil ( $ arr , $ data , 0 , $ n - 1 , 0 , $ r ) ; } function combinationUtil ( $ arr , $ data , $ start , $ end , $ index , $ r ) { if ( $ index == $ r ) { for ( $ j = 0 ; $ j < $ r ; $ j ++ ) echo $ data [ $ j ] ; echo \" STRNEWLINE \" ; return ; } for ( $ i = $ start ; $ i <= $ end && $ end - $ i + 1 >= $ r - $ index ; $ i ++ ) { $ data [ $ index ] = $ arr [ $ i ] ; combinationUtil ( $ arr , $ data , $ i + 1 , $ end , $ index + 1 , $ r ) ; } } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ r = 3 ; $ n = sizeof ( $ arr ) ; printCombination ( $ arr , $ n , $ r ) ; ? >"}
{"text": "Cetak semua kemungkinan kombinasi elemen R dalam pelbagai saiz n | Fungsi utama yang mencetak semua kombinasi saiz r dalam arr [] saiz n. Fungsi ini terutamanya menggunakan gabunganUtil (); Arahan sementara untuk menyimpan semua gabungan satu demi satu; Cetak semua kombinasi menggunakan data temprary array [] '; arr [] - -> array input n - -> saiz array input r - -> saiz gabungan untuk dicetak indeks - -> indeks semasa dalam data [] data [] - -> array sementara untuk menyimpan kombinasi semasa i - -> indeks elemen semasa dalam arr []; Perbadanan semasa sudah siap, cetaknya; Apabila tidak ada lagi elemen yang ada untuk dimasukkan ke dalam data []; Semasa dimasukkan, letakkan seterusnya di lokasi seterusnya; Semasa dikecualikan, gantikannya dengan seterusnya (perhatikan bahawa i + 1 diluluskan, tetapi indeks tidak berubah); Kod pemacu", "code": "< ? php function printCombination ( $ arr , $ n , $ r ) { $ data = Array ( ) ; combinationUtil ( $ arr , $ n , $ r , 0 , $ data , 0 ) ; } function combinationUtil ( $ arr , $ n , $ r , $ index , $ data , $ i ) { if ( $ index == $ r ) { for ( $ j = 0 ; $ j < $ r ; $ j ++ ) echo $ data [ $ j ] , \" ▁ \" ; echo \" STRNEWLINE \" ; return ; } if ( $ i >= $ n ) return ; $ data [ $ index ] = $ arr [ $ i ] ; combinationUtil ( $ arr , $ n , $ r , $ index + 1 , $ data , $ i + 1 ) ; combinationUtil ( $ arr , $ n , $ r , $ index , $ data , $ i + 1 ) ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ r = 3 ; $ n = sizeof ( $ arr ) ; printCombination ( $ arr , $ n , $ r ) ; ? >"}
{"text": "Kira semua kumpulan saiz 2 atau 3 yang mungkin mempunyai jumlah sebagai pelbagai 3 | Mengembalikan kiraan semua kumpulan yang mungkin boleh dibentuk dari unsur -unsur []. ; Buat array C [3] untuk menyimpan bilangan elemen dengan selebihnya 0, 1 dan 2. C [i] akan menyimpan kiraan elemen dengan selebihnya I; Untuk menyimpan hasilnya; Mengira elemen dengan selebihnya 0, 1 dan 2; Kes 3. A: Kumpulan Kumpulan Saiz 2 dari 0 elemen yang tinggal; Kes 3. B: Kumpulan Kumpulan Saiz 2 dengan satu elemen dengan 1 baki dan lain -lain dengan 2 selebihnya; Kes 4. A: Kumpulan Kumpulan Saiz 3 dengan semua 0 elemen yang tinggal; Kes 4. B: Kumpulan Kumpulan Saiz 3 dengan semua 1 elemen yang tinggal; Kes 4. C: Kumpulan Kumpulan Saiz 3 dengan semua 2 elemen yang tinggal; Kes 4. C: Kumpulan Kumpulan Saiz 3 dengan sisa yang berbeza; Mengembalikan jumlah jumlah yang disimpan dalam res; Kod pemacu", "code": "< ? php function findgroups ( $ arr , $ n ) { $ c = array ( 0 , 0 , 0 ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ c [ $ arr [ $ i ] % 3 ] += 1 ; $ res += ( ( $ c [ 0 ] * ( $ c [ 0 ] - 1 ) ) >> 1 ) ; $ res += $ c [ 1 ] * $ c [ 2 ] ; $ res += ( $ c [ 0 ] * ( $ c [ 0 ] - 1 ) * ( $ c [ 0 ] - 2 ) ) / 6 ; $ res += ( $ c [ 1 ] * ( $ c [ 1 ] - 1 ) * ( $ c [ 1 ] - 2 ) ) / 6 ; $ res += ( ( $ c [ 2 ] * ( $ c [ 2 ] - 1 ) * ( $ c [ 2 ] - 2 ) ) / 6 ) ; $ res += $ c [ 0 ] * $ c [ 1 ] * $ c [ 2 ] ; return $ res ; } $ arr = array ( 3 , 6 , 7 , 2 , 9 ) ; $ n = count ( $ arr ) ; echo \" Required ▁ number ▁ of ▁ groups ▁ are ▁ \" . ( int ) ( findgroups ( $ arr , $ n ) ) ; ? >"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Program PHP untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Pertama n dalam keadaan di bawah adalah untuk kes di mana n adalah 0; Kod pemacu", "code": "< ? php function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; } $ n = 0 ; echo ( nextPowerOf2 ( $ n ) ) ; ? >"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Program untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Kod pemacu", "code": "< ? php function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; } $ n = 5 ; echo ( nextPowerOf2 ( $ n ) ) ; ? >"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Cari kuasa seterusnya dua untuk n. Jika n sendiri adalah kuasa dua maka pulangan n; Kod pemacu", "code": "< ? php function nextPowerOf2 ( $ n ) { $ n -- ; $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; $ n ++ ; return $ n ; } $ n = 5 ; echo nextPowerOf2 ( $ n ) ; ? >"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | Berfungsi untuk memisahkan 0 s dan 1 s; Mengira tiada sifar dalam arr; Gelung mengisi ARR dengan 0 sehingga dikira; Gelung mengisi ruang yang tinggal dengan 1; Berfungsi untuk mencetak array terasing; Kod pemacu", "code": "< ? php function segregate0and1 ( & $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == 0 ) $ count ++ ; } for ( $ i = 0 ; $ i < $ count ; $ i ++ ) $ arr [ $ i ] = 0 ; for ( $ i = $ count ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = 1 ; } function toprint ( & $ arr , $ n ) { echo ( \" Array ▁ after ▁ segregation ▁ is ▁ \" ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ $ i ] . \" ▁ \" ) ; } $ arr = array ( 0 , 1 , 0 , 1 , 1 , 1 ) ; $ n = sizeof ( $ arr ) ; segregate0and1 ( $ arr , $ n ) ; toprint ( $ arr , $ n ) ; ? >"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | Berfungsi untuk meletakkan semua 0 s di kiri dan semua 1 s di sebelah kanan; Memulakan indeks kiri dan kanan; Indeks Kiri Peningkatan semasa kita melihat 0 di sebelah kiri; Indeks kanan pengurangan semasa kita melihat 1 di sebelah kanan; Jika kiri lebih kecil daripada kanan maka terdapat 1 di sebelah kiri dan 0 di sebelah kanan. Pertukaran arr [kiri] dan arr [kanan]; Kod pemacu", "code": "< ? php function segregate0and1 ( & $ arr , $ size ) { $ left = 0 ; $ right = $ size - 1 ; while ( $ left < $ right ) { while ( $ arr [ $ left ] == 0 && $ left < $ right ) $ left ++ ; while ( $ arr [ $ right ] == 1 && $ left < $ right ) $ right -- ; if ( $ left < $ right ) { $ arr [ $ left ] = 0 ; $ arr [ $ right ] = 1 ; $ left ++ ; $ right -- ; } } } $ arr = array ( 0 , 1 , 0 , 1 , 1 , 1 ) ; $ arr_size = sizeof ( $ arr ) ; segregate0and1 ( $ arr , $ arr_size ) ; printf ( \" Array ▁ after ▁ segregation ▁ is ▁ \" ) ; for ( $ i = 0 ; $ i < 6 ; $ i ++ ) echo ( $ arr [ $ i ] . \" ▁ \" ) ; ? >"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | Berfungsi untuk meletakkan semua 0 s di kiri dan semua 1 s di sebelah kanan; Kod pemacu", "code": "< ? php function segregate0and1 ( & $ arr , $ size ) { $ type0 = 0 ; $ type1 = $ size - 1 ; while ( $ type0 < $ type1 ) { if ( $ arr [ $ type0 ] == 1 ) { $ temp = $ arr [ $ type0 ] ; $ arr [ $ type0 ] = $ arr [ $ type1 ] ; $ arr [ $ type1 ] = $ temp ; $ type1 -- ; } else $ type0 ++ ; } } $ arr = array ( 0 , 1 , 0 , 1 , 1 , 1 ) ; $ arr_size = sizeof ( $ arr ) ; segregate0and1 ( $ arr , $ arr_size ) ; echo ( \" Array ▁ after ▁ segregation ▁ is ▁ \" ) ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) echo ( $ arr [ $ i ] . \" ▁ \" ) ; ? >"}
{"text": "Memandangkan array arr [], cari maksimum j | Untuk array arr [], mengembalikan maksimum J a i sedemikian rupa sehingga arr [j]> arr [i]; Kod pemacu", "code": "< ? php function maxIndexDiff ( $ arr , $ n ) { $ maxDiff = -1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { for ( $ j = $ n - 1 ; $ j > $ i ; -- $ j ) { if ( $ arr [ $ j ] > $ arr [ $ i ] && $ maxDiff < ( $ j - $ i ) ) $ maxDiff = $ j - $ i ; } } return $ maxDiff ; } $ arr = array ( 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 ) ; $ n = count ( $ arr ) ; $ maxDiff = maxIndexDiff ( $ arr , $ n ) ; echo $ maxDiff ; ? >"}
{"text": "K | Berfungsi untuk mencari elemen k - th yang hilang; interating melalui array; Semak jika saya - th dan (i + 1) - elemen tidak berturut -turut; Simpan perbezaan mereka; Semak perbezaan dan diberikan k; jika dijumpai; Arahan input; K - elemen yang hilang dapat dijumpai dalam array; fungsi panggilan untuk mencari elemen yang hilang", "code": "< ? php function missingK ( & $ a , $ k , $ n ) { $ difference = 0 ; $ ans = 0 ; $ count = $ k ; $ flag = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ difference = 0 ; if ( ( $ a [ $ i ] + 1 ) != $ a [ $ i + 1 ] ) { $ difference += ( $ a [ $ i + 1 ] - $ a [ $ i ] ) - 1 ; if ( $ difference >= $ count ) { $ ans = $ a [ $ i ] + $ count ; $ flag = 1 ; break ; } else $ count -= $ difference ; } } if ( $ flag ) return $ ans ; else return -1 ; } $ a = array ( 1 , 5 , 11 , 19 ) ; $ k = 11 ; $ n = count ( $ a ) ; $ missing = missingK ( $ a , $ k , $ n ) ; echo $ missing ; ? >"}
{"text": "Putaran minimum diperlukan untuk mendapatkan rentetan yang sama | Mengembalikan kiraan putaran untuk mendapatkan kembali rentetan yang sama. ; TMP adalah rentetan yang disatukan. ; Substring dari I Indeks saiz rentetan asal. ; Jika substring sepadan dengan rentetan asal maka kami akan keluar dari gelung. ; Kod pemacu", "code": "< ? php function findRotations ( $ str ) { $ tmp = ( $ str + $ str ) ; $ n = strlen ( $ str ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ substring = $ tmp . substr ( $ i , strlen ( $ str ) ) ; if ( $ str == $ substring ) return $ i ; } return $ n ; } $ str = \" abc \" ; echo findRotations ( $ str ) , \" STRNEWLINE \" ; ? >"}
{"text": "K | Berfungsi untuk mencari jumlah minimum semua subarray; Masukkan semua elemen dalam satu set; Cari elemen maksimum dan minimum; Melintasi unsur minimum hingga maksimum; Semak sama ada \"Saya\" hilang; Semak sama ada kth hilang; Jika tiada elemen kth hilang; Kod pemacu", "code": "< ? php function findKth ( $ arr , $ n , $ k ) { $ missing = array ( ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) array_push ( $ missing , $ arr [ $ i ] ) ; $ missing = array_unique ( $ missing ) ; $ maxm = max ( $ arr ) ; $ minm = min ( $ arr ) ; for ( $ i = $ minm + 1 ; $ i < $ maxm ; $ i ++ ) { if ( ! in_array ( $ i , $ missing , false ) ) $ count += 1 ; if ( $ count == $ k ) return $ i ; } return -1 ; } $ arr = array ( 2 , 10 , 9 , 4 ) ; $ n = sizeof ( $ arr ) ; $ k = 5 ; echo findKth ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Bilangan rentetan binari panjang n dengan k bit set bersebelahan | Berfungsi untuk mencari bilangan rentetan bit panjang n dengan k bit set bersebelahan; Kes asas apabila kita membentuk rentetan panjang n; jika f (bit string) = k, hitung cara ini; Semak sama ada bit terakhir ditetapkan, jika ditetapkan maka hubungi indeks seterusnya dengan menambah kiraan bit bersebelahan lain, hubungi indeks seterusnya dengan nilai yang sama dari kiraan bit bersebelahan dan sama ada tetapkan bit pada indeks semasa atau biarkan ia tetap tidak tersembunyi; Tetapkan bit pada CurrentIndex; tidak jelas sedikit pada currentIndex; Kod pemacu; Jumlah cara = (cara dengan meletakkan bit 1 st 1 + cara dengan meletakkan bit 1 sebagai 0)", "code": "< ? php function waysToKAdjacentSetBits ( $ n , $ k , $ currentIndex , $ adjacentSetBits , $ lastBit ) { if ( $ currentIndex == $ n ) { if ( $ adjacentSetBits == $ k ) return 1 ; return 0 ; } $ noOfWays = 0 ; if ( $ lastBit == 1 ) { $ noOfWays += waysToKAdjacentSetBits ( $ n , $ k , $ currentIndex + 1 , $ adjacentSetBits + 1 , 1 ) ; $ noOfWays += waysToKAdjacentSetBits ( $ n , $ k , $ currentIndex + 1 , $ adjacentSetBits , 0 ) ; } else if ( ! $ lastBit ) { $ noOfWays += waysToKAdjacentSetBits ( $ n , $ k , $ currentIndex + 1 , $ adjacentSetBits , 1 ) ; $ noOfWays += waysToKAdjacentSetBits ( $ n , $ k , $ currentIndex + 1 , $ adjacentSetBits , 0 ) ; } return $ noOfWays ; } $ n = 5 ; $ k = 2 ; $ totalWays = waysToKAdjacentSetBits ( $ n , $ k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( $ n , $ k , 1 , 0 , 0 ) ; echo \" Number ▁ of ▁ ways ▁ = ▁ \" , $ totalWays , \" STRNEWLINE \" ; ? >"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Mengembalikan kiraan cara untuk mencapai tangga N - menggunakan 1 atau 2 atau 3 langkah. ; Kod pemacu", "code": "< ? php function findStep ( $ n ) { if ( $ n == 1 $ n == 0 ) return 1 ; else if ( $ n == 2 ) return 2 ; else return findStep ( $ n - 3 ) + findStep ( $ n - 2 ) + findStep ( $ n - 1 ) ; } $ n = 4 ; echo findStep ( $ n ) ; ? >"}
{"text": "Masalah Partition | DP | Fungsi utiliti yang kembali benar jika terdapat subset arr [] dengan matahari sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah elemen dalam array; Jika jumlahnya ganjil, tidak ada dua subset dengan jumlah yang sama; Cari jika terdapat subset dengan jumlah yang sama dengan separuh daripada jumlah keseluruhan; Kod pemacu; Panggilan fungsi", "code": "< ? php function isSubsetSum ( $ arr , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 && $ sum != 0 ) return false ; if ( $ arr [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ arr , $ n - 1 , $ sum ) ; return isSubsetSum ( $ arr , $ n - 1 , $ sum ) || isSubsetSum ( $ arr , $ n - 1 , $ sum - $ arr [ $ n - 1 ] ) ; } function findPartiion ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; if ( $ sum % 2 != 0 ) return false ; return isSubsetSum ( $ arr , $ n , $ sum / 2 ) ; } $ arr = array ( 3 , 1 , 5 , 9 , 12 ) ; $ n = count ( $ arr ) ; if ( findPartiion ( $ arr , $ n ) == true ) echo \" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ sum \" ; else echo \" Can ▁ not ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ sum \" ; ? >"}
{"text": "Cari watak berulang yang hadir terlebih dahulu dalam rentetan | Program PHP untuk mencari watak pertama yang diulang; Ini adalah kaedah O (n ^ 2); Kod pemacu", "code": "< ? php function findRepeatFirstN2 ( $ s ) { $ p = -1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { for ( $ j = ( $ i + 1 ) ; $ j < strlen ( $ s ) ; $ j ++ ) { if ( $ s [ $ i ] == $ s [ $ j ] ) { $ p = $ i ; break ; } } if ( $ p != -1 ) break ; } return $ p ; } $ str = \" geeksforgeeks \" ; $ pos = findRepeatFirstN2 ( $ str ) ; if ( $ pos == -1 ) echo ( \" Not ▁ found \" ) ; else echo ( $ str [ $ pos ] ) ; ? >"}
{"text": "Kira bilangan rentetan (diperbuat daripada r, g dan b) menggunakan kombinasi yang diberikan | Berfungsi untuk mengira bilangan rentetan; Menyimpan faktorial nombor sehingga n untuk pengiraan selanjutnya; Cari nilai yang akan ditambah; Buat semua kemungkinan kombinasi R, B dan G untuk nilai yang tinggal; Kirakan permutasi setiap gabungan satu demi satu dan tambahkannya. ; Kembali Jumlah No. rentetan / permutasi; Kod pemacu", "code": "< ? php function possibleStrings ( $ n , $ r , $ b , $ g ) { $ fact [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ fact [ $ i ] = $ fact [ $ i - 1 ] * $ i ; $ left = $ n - ( $ r + $ g + $ b ) ; $ sum = 0 ; for ( $ i = 0 ; $ i <= $ left ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ left - $ i ; $ j ++ ) { $ k = $ left - ( $ i + $ j ) ; $ sum = $ sum + $ fact [ $ n ] / ( $ fact [ $ i + $ r ] * $ fact [ $ j + $ b ] * $ fact [ $ k + $ g ] ) ; } } return $ sum ; } $ n = 4 ; $ r = 2 ; $ b = 0 ; $ g = 1 ; echo possibleStrings ( $ n , $ r , $ b , $ g ) ; ? >"}
{"text": "Keluarkan bilangan minimum aksara supaya dua rentetan menjadi anagram | fungsi untuk mengira bilangan minimum aksara yang akan dikeluarkan untuk membuat dua rentetan anagram; Buat array hash untuk kedua -dua rentetan dan hitung kekerapan setiap aksara; Mengira kekerapan setiap aksara dalam rentetan pertama; Mengira kekerapan setiap aksara dalam rentetan kedua; TRAVERSE COUNT TRAVSE untuk mencari bilangan aksara yang akan dikeluarkan; Kod pemacu", "code": "< ? php function remAnagram ( $ str1 , $ str2 ) { $ count1 = array ( 26 ) ; $ count2 = array ( 26 ) ; for ( $ i = 0 ; $ i < strlen ( $ str1 ) ; $ i ++ ) $ count1 [ $ str1 [ $ i ] - ' a ' ] ++ ; for ( $ i = 0 ; $ i < strlen ( $ str2 ) ; $ i ++ ) $ count2 [ $ str2 [ $ i ] - ' a ' ] ++ ; $ result = 0 ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ result += abs ( $ count1 [ $ i ] - $ count2 [ $ i ] ) ; return $ result ; } { $ str1 = \" bcadeh \" ; $ str2 = \" hea \" ; echo ( remAnagram ( $ str1 , $ str2 ) ) ; }"}
{"text": "Laluan cetak dari akar ke semua nod dalam pokok binari yang lengkap | Berfungsi untuk mencetak laluan semua nod nth node mewakili sebagai node node node yang diberikan mewakili sebagai nod kiri dan kanan; Keadaan asas jika nilai nod kth lebih besar maka nod nth maka nod kth bermakna tidak sah sehingga kami tidak menyimpannya ke dalam res hanya kami hanya kembali; Menyimpan nod ke res; Cetak jalan dari akar ke nod; Simpan jalan kiri pokok supaya kiri kita akan pergi nod (kthNode * 2); Jalan kanan pokok dan untuk betul kita akan pergi nod (kthnode * 2 + 1); Berfungsi untuk mencetak laluan dari akar ke semua nod; Res adalah untuk menyimpan jalan dari akar ke nod partikulat; Cetak jalan dari akar ke semua nod. Hujah ketiga 1 kerana kita perlu mempertimbangkan nod akar adalah 1; Diberikan nod; Cetak jalan dari akar ke semua nod.", "code": "< ? php function printPath ( $ res , $ nThNode , $ kThNode ) { if ( $ kThNode > $ nThNode ) return ; array_push ( $ res , $ kThNode ) ; for ( $ i = 0 ; $ i < count ( $ res ) ; $ i ++ ) echo $ res [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; printPath ( $ res , $ nThNode , $ kThNode * 2 ) ; printPath ( $ res , $ nThNode , $ kThNode * 2 + 1 ) ; } function printPathToCoverAllNodeUtil ( $ nThNode ) { $ res = array ( ) ; printPath ( $ res , $ nThNode , 1 ) ; } $ nThNode = 7 ; printPathToCoverAllNodeUtil ( $ nThNode ) ; ? >"}
{"text": "Panjang minimum laluan terpendek segitiga | berfungsi untuk mendapatkan panjang minimum bahagian yang lebih pendek dari segitiga; melintasi setiap mata di atas kapal terbang; Jika jumlah mata lebih besar daripada yang sebelumnya, maksimum akan diganti; Cetak panjang; memulakan bilangan mata; mata di kapal terbang", "code": "< ? php function shortestLength ( $ n , & $ x , & $ y ) { $ answer = 0 ; $ i = 0 ; while ( $ n -- ) { if ( $ x [ $ i ] + $ y [ $ i ] > $ answer ) $ answer = $ x [ $ i ] + $ y [ $ i ] ; $ i ++ ; } echo \" Length ▁ - > ▁ \" . $ answer . \" STRNEWLINE \" ; echo \" Path ▁ - > ▁ \" . \" ( 1 , \" ▁ . $ answer ▁ . \" ) \" . STRNEWLINE TABSYMBOL TABSYMBOL \" and ( \" ▁ . $ answer ▁ . ▁ \" , 1 ) \" ; } $ n = 4 ; $ x = array ( 1 , 4 , 2 , 1 ) ; $ y = array ( 4 , 1 , 1 , 2 ) ; shortestLength ( $ n , $ x , $ y ) ; ? >"}
{"text": "Berpotongan segi empat tepat apabila bawah | berfungsi untuk mencari persegi persegi persegi dua segi empat tepat. ; memberikan titik kiri bawah persegi persegi persegi; memberikan titik kanan persegi persegi persegi; tiada persimpangan; memberikan titik kiri atas persegi persegi persegi; memberikan titik bawah persegi persegi persegi; bawah - kiri dan atas - sudut kanan segi empat tepat pertama; bawah - kiri dan atas - sudut kanan segi empat tepat pertama; panggilan fungsi", "code": "< ? php function FindPoints ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) { $ x5 = max ( $ x1 , $ x3 ) ; $ y5 = max ( $ y1 , $ y3 ) ; $ x6 = min ( $ x2 , $ x4 ) ; $ y6 = min ( $ y2 , $ y4 ) ; if ( $ x5 > $ x6 $ y5 > $ y6 ) { echo \" No ▁ intersection \" ; return ; } echo \" ( \" . $ x5 . \" , \" ▁ . ▁ $ y5 ▁ . ▁ \" ) \" ; echo \" ( \" . $ x6 . \" , \" ▁ . ▁ $ y6 ▁ . ▁ \" ) \" ; $ x7 = $ x5 ; $ y7 = $ y6 ; echo \" ( \" . $ x7 . \" , \" ▁ . ▁ $ y7 ▁ . ▁ \" ) \" ; $ x8 = $ x6 ; $ y8 = $ y5 ; echo \" ( \" . $ x8 . \" , \" ▁ . ▁ $ y8 ▁ . ▁ \" ) \" ; } $ x1 = 0 ; $ y1 = 0 ; $ x2 = 10 ; $ y2 = 8 ; $ x3 = 2 ; $ y3 = 3 ; $ x4 = 7 ; $ y4 = 9 ; FindPoints ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) ; ? >"}
{"text": "Kawasan segitiga yang dibentuk oleh paksi Co | Berfungsi untuk mencari kawasan; Kod pemacu", "code": "< ? php function area ( $ a , $ b , $ c ) { $ d = abs ( ( $ c * $ c ) / ( 2 * $ a * $ b ) ) ; return $ d ; } $ a = -2 ; $ b = 4 ; $ c = 3 ; echo area ( $ a , $ b , $ c ) ; ? >"}
{"text": "Jumlah dua nombor di mana satu nombor diwakili sebagai pelbagai digit | Berfungsi untuk mengembalikan vektor yang mengandungi jawapannya; Vektor V adalah untuk menyimpan setiap digit jumlah dan vektor ANS adalah untuk menyimpan jawapannya; Tidak dibawa pada mulanya; Mula gelung dari hujung dan ambil elemen satu demi satu; Indeks array dan nombor angka terakhir; Mengekalkan pembawa penjumlahan; Tolak nilai digit ke dalam array; Nilai k lebih besar kemudian 0; Tolak digit k satu demi satu dalam array; Juga mengekalkan pembawa dengan penjumlahan; Membalikkan unsur -unsur vektor v dan simpannya dalam vektor ans; Kod pemacu; Cetak jawapannya", "code": "< ? php function addToArrayForm ( $ A , $ K ) { $ v = array ( ) ; $ ans = array ( ) ; $ rem = 0 ; $ i = 0 ; for ( $ i = count ( $ A ) - 1 ; $ i >= 0 ; $ i -- ) { $ my = $ A [ $ i ] + $ K % 10 + $ rem ; if ( $ my > 9 ) { $ rem = 1 ; array_push ( $ v , $ my % 10 ) ; } else { array_push ( $ v , $ my ) ; $ rem = 0 ; } $ K = floor ( $ K / 10 ) ; } while ( $ K > 0 ) { $ my = $ K % 10 + $ rem ; array_push ( $ v , $ my % 10 ) ; if ( $ my / 10 > 0 ) $ rem = 1 ; else $ rem = 0 ; $ K = floor ( $ K / 10 ) ; } if ( $ rem > 0 ) array_push ( $ v , $ rem ) ; for ( $ i = count ( $ v ) - 1 ; $ i >= 0 ; $ i -- ) array_push ( $ ans , $ v [ $ i ] ) ; return $ ans ; } $ A = array ( 2 , 7 , 4 ) ; $ K = 181 ; $ ans = addToArrayForm ( $ A , $ K ) ; for ( $ i = 0 ; $ i < count ( $ ans ) ; $ i ++ ) echo $ ans [ $ i ] ; ? >"}
{"text": "Ketiga digit terakhir dalam 5 ^ n untuk diberikan n | Berfungsi untuk mencari elemen; jika n <3; Jika n juga kembali 6 jika n adalah pulangan ganjil 1; Kod pemacu", "code": "< ? php function findThirdDigit ( $ n ) { if ( $ n < 3 ) return 0 ; return $ n & 1 ? 1 : 6 ; } $ n = 7 ; echo findThirdDigit ( $ n ) ; ? >"}
{"text": "Kebarangkalian memenangi perlawanan apabila kebarangkalian individu memukul sasaran yang diberikan | Berfungsi untuk mengembalikan kebarangkalian kemenangan; P dan Q menyimpan nilai pecahan A / B dan C / D; Untuk menyimpan kebarangkalian kemenangan A; Kod pemacu", "code": "< ? php function getProbability ( $ a , $ b , $ c , $ d ) { $ p = $ a / $ b ; $ q = $ c / $ d ; $ ans = $ p * ( 1 / ( 1 - ( 1 - $ q ) * ( 1 - $ p ) ) ) ; return round ( $ ans , 6 ) ; } $ a = 1 ; $ b = 2 ; $ c = 10 ; $ d = 11 ; echo getProbability ( $ a , $ b , $ c , $ d ) ; ? >"}
{"text": "Nombor palindromik terbesar dalam array | Fungsi untuk memeriksa sama ada n adalah palindrome; Cari pembahagi yang sesuai untuk mengekstrak digit terkemuka; Jika digit pertama dan terakhir tidak sama maka kembali palsu; Mengeluarkan digit terkemuka dan trailing dari nombor; Mengurangkan pembahagi dengan faktor 2 sebagai 2 digit dijatuhkan; Berfungsi untuk mencari nombor palindromik terbesar; Sekiranya palindrom lebih besar daripada semasa yang dijumpai; Mengembalikan nombor palindromik terbesar dari array; Kod pemacu; Cetak jawapan yang diperlukan", "code": "< ? php function isPalindrome ( $ n ) { $ divisor = 1 ; while ( ( int ) ( $ n / $ divisor ) >= 10 ) $ divisor *= 10 ; while ( $ n != 0 ) { $ leading = ( int ) ( $ n / $ divisor ) ; $ trailing = $ n % 10 ; if ( $ leading != $ trailing ) return false ; $ n = ( $ n % $ divisor ) / 10 ; $ divisor = $ divisor / 100 ; } return true ; } function largestPalindrome ( $ A , $ n ) { $ currentMax = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ A [ $ i ] > $ currentMax && isPalindrome ( $ A [ $ i ] ) ) $ currentMax = $ A [ $ i ] ; } return $ currentMax ; } $ A = array ( 1 , 232 , 54545 , 999991 ) ; $ n = sizeof ( $ A ) ; echo ( largestPalindrome ( $ A , $ n ) ) ; ? >"}
{"text": "Kurangkan array ke satu elemen dengan operasi yang diberikan | Berfungsi untuk mengembalikan elemen akhir; Kod pemacu", "code": "< ? php function getFinalElement ( $ n ) { $ finalNum = 0 ; for ( $ finalNum = 2 ; ( $ finalNum * 2 ) <= $ n ; $ finalNum *= 2 ) ; return $ finalNum ; } $ N = 12 ; echo getFinalElement ( $ N ) ; ? >"}
{"text": "Jumlah semua nombor palindromik panjang dalam julat [l, r] | Fungsi yang mengembalikan benar jika nombor yang diberikan adalah palindrome; Di sini kita menjana nombor baru (reverse_num) dengan membalikkan digit nombor input asal; Jika nombor input asal (NUM) adalah sama dengan terbalik (reverse_num) maka palindrome yang lain tidak. ; Fungsi yang mengembalikan benar jika nombor yang diberikan adalah panjang ganjil; Berfungsi untuk mengembalikan jumlah semua nombor palindromik panjang yang ganjil dalam julat yang diberikan; jika nombor adalah palindrome dan panjang ganjil; Kod pemacu", "code": "< ? php function isPalindrome ( $ num ) { $ reverse_num = 0 ; $ remainder ; $ temp ; $ temp = $ num ; while ( $ temp != 0 ) { $ remainder = $ temp % 10 ; $ reverse_num = $ reverse_num * 10 + $ remainder ; $ temp = ( int ) ( $ temp / 10 ) ; } if ( $ reverse_num == $ num ) { return true ; } return false ; } function isOddLength ( $ num ) { $ count = 0 ; while ( $ num > 0 ) { $ num = ( int ) ( $ num / 10 ) ; $ count ++ ; } if ( $ count % 2 != 0 ) { return true ; } return false ; } function sumOfAllPalindrome ( $ L , $ R ) { $ sum = 0 ; if ( $ L <= $ R ) for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { if ( isPalindrome ( $ i ) && isOddLength ( $ i ) ) { $ sum += $ i ; } } return $ sum ; } $ L = 110 ; $ R = 1130 ; echo sumOfAllPalindrome ( $ L , $ R ) ; ? >"}
{"text": "Jumlah nombor Fibonacci dengan negatif alternatif | Mengira nilai nombor Fibonacci pertama dan menyimpan jumlah alternatif mereka; Memulakan hasil; Tambah istilah yang tinggal; Bahkan istilah; Untuk istilah ganjil; Mengembalikan jumlah bergantian; Dapatkan n; Cari jumlah bergantian", "code": "< ? php function calculateAlternateSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo = array ( ) ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = pow ( $ fibo [ 0 ] , 2 ) + pow ( $ fibo [ 1 ] , 2 ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; if ( $ i % 2 == 0 ) $ sum -= $ fibo [ $ i ] ; else $ sum += $ fibo [ $ i ] ; } return $ sum ; } $ n = 8 ; echo ( \" Alternating ▁ Fibonacci ▁ Sum ▁ upto ▁ \" ) ; echo $ n ; echo \" ▁ terms : ▁ \" ; echo ( calculateAlternateSum ( $ n ) ) ; ? >"}
{"text": "Cari istilah n Siri 1 2 2 4 4 4 4 8 8 8 8 8 8 8 8 ... | Fungsi yang akan mengembalikan istilah nth; Dapatkan n; Dapatkan nilai; Dapatkan n; Dapatkan nilai", "code": "< ? php function getValue ( $ n ) { $ i = 0 ; $ k = 1 ; while ( $ i < $ n ) { $ i = $ i + $ k ; $ k = $ k * 2 ; } return ( int ) $ k / 2 ; } $ n = 9 ; echo getValue ( $ n ) , \" STRNEWLINE \" ; $ n = 1025 ; echo getValue ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Bina pelbagai frekuensi digit nilai yang diperoleh dari x ^ 1, x ^ 2, ... .... . , x ^ n | Fungsi yang melintasi digit dalam nombor dan mengubah suai jumlah kekerapan kekerapan; Array untuk menyimpan kiraan digit; Melintasi x ^ 1 hingga x ^ n; Untuk fungsi kuasa, kedua -dua parameternya akan dua kali ganda; Memanggil Countdigits berfungsi pada x ^ i; Mencetak kiraan digit 0 - 9; Kod pemacu", "code": "< ? php function countDigits ( $ val , & $ arr ) { while ( $ val > 0 ) { $ digit = $ val % 10 ; $ arr [ ( int ) ( $ digit ) ] += 1 ; $ val = ( int ) ( $ val / 10 ) ; } return ; } function countFrequency ( $ x , $ n ) { $ freq_count = array_fill ( 0 , 10 , 0 ) ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) { $ val = pow ( $ x , $ i ) ; countDigits ( $ val , $ freq_count ) ; } for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { echo $ freq_count [ $ i ] . \" \" ; } } $ x = 15 ; $ n = 3 ; countFrequency ( $ x , $ n ) ? >"}
{"text": "Bilangan nilai b seperti a = b + (a ^ b) | berfungsi untuk mengembalikan bilangan penyelesaian; Semak setiap nilai yang mungkin; Kod pemacu", "code": "< ? php function countSolutions ( $ a ) { $ count = 0 ; for ( $ i = 0 ; $ i <= $ a ; $ i ++ ) { if ( $ a == ( $ i + ( $ a ^ $ i ) ) ) $ count ++ ; } return $ count ; } $ a = 3 ; echo countSolutions ( $ a ) ; ? >"}
{"text": "Bilangan nilai b seperti a = b + (a ^ b) | berfungsi untuk mengembalikan bilangan penyelesaian; Kod pemacu", "code": "< ? php function countSolutions ( $ a ) { $ count = bitCount ( $ a ) ; $ count = ( int ) pow ( 2 , $ count ) ; return $ count ; } function bitCount ( $ n ) { $ count = 0 ; while ( $ n != 0 ) { $ count ++ ; $ n &= ( $ n - 1 ) ; } return $ count ; } $ a = 3 ; echo ( countSolutions ( $ a ) ) ; ? >"}
{"text": "Jumlah kawasan semua persegi yang mungkin di dalam segi empat tepat | Fungsi untuk mengira jumlah kawasan semua dataran yang mungkin masuk ke dalam segi empat tepat; Persegi dengan saiz maksimum mungkin; Kirakan jumlah persegi saiz tertentu; mengira kawasan dataran dengan saiz tertentu; Jumlah kawasan; saiz kenaikan; Kod pemacu", "code": "< ? php function calculateAreaSum ( $ l , $ b ) { $ size = 1 ; $ maxSize = min ( $ l , $ b ) ; $ totalArea = 0 ; for ( $ i = 1 ; $ i <= $ maxSize ; $ i ++ ) { $ totalSquares = ( $ l - $ size + 1 ) * ( $ b - $ size + 1 ) ; $ area = $ totalSquares * $ size * $ size ; $ totalArea += $ area ; $ size ++ ; } return $ totalArea ; } $ l = 4 ; $ b = 3 ; echo calculateAreaSum ( $ l , $ b ) ; ? >"}
{"text": "Hyperfactorial nombor | fungsi untuk mengira nilai hiperfakterial; memulakan val kepada 1; mengembalikan hiperfactoral nombor; Kod pemacu", "code": "< ? php function boost_hyperfactorial ( $ num ) { $ val = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { $ val = $ val * pow ( $ i , $ i ) ; } return $ val ; } $ num = 5 ; echo boost_hyperfactorial ( $ num ) ; ? >"}
{"text": "Hyperfactorial nombor | fungsi untuk mengira nilai hiperfakterial; memulakan val kepada 1; 1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . ; mengembalikan hiperfactoral nombor; Kod pemacu", "code": "< ? php function boost_hyperfactorial ( $ num ) { $ val = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ val *= $ i ; } } return $ val ; } $ num = 5 ; echo boost_hyperfactorial ( $ num ) ; ? >"}
{"text": "Kurangkan 1 tanpa pengendali aritmetik | Kod PHP untuk menolak satu daripada nombor tertentu; Flip semua bit set sehingga kita dapati 1; Flip paling tepat 1 bit; Kod pemacu", "code": "< ? php function subtractOne ( $ x ) { $ m = 1 ; while ( ! ( $ x & $ m ) ) { $ x = $ x ^ $ m ; $ m <<= 1 ; } $ x = $ x ^ $ m ; return $ x ; } echo subtractOne ( 13 ) ; ? >"}
{"text": "Cari vektor min matriks | Program PHP untuk mencari vektor min matriks yang diberikan; Fungsi untuk mencari vektor min; gelung untuk melintasi setiap lajur; untuk mengira min setiap baris; untuk menyimpan jumlah elemen lajur; Kod pemacu", "code": "< ? php $ rows = 3 ; $ cols = 3 ; function meanVector ( $ mat ) { global $ rows , $ cols ; echo \" [ ▁ \" ; for ( $ i = 0 ; $ i < $ rows ; $ i ++ ) { $ mean = 0.00 ; $ sum = 0 ; for ( $ j = 0 ; $ j < $ cols ; $ j ++ ) $ sum += $ mat [ $ j ] [ $ i ] ; $ mean = $ sum / $ rows ; echo $ mean , \" \" ; ▁ } ▁ echo ▁ \" ] \" } $ mat = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; meanVector ( $ mat ) ; ? >"}
{"text": "Nombor Hoax | Fungsi untuk mencari faktor utama yang berbeza dari nombor n; N adalah ganjil pada ketika ini, kerana ia tidak lagi dibahagikan dengan 2. Oleh itu, kita boleh menguji hanya untuk nombor ganjil, sama ada faktor n; Semak jika saya adalah faktor utama; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Fungsi untuk mengira jumlah digit faktor utama yang berbeza dari nombor N dan jumlah digit nombor N dan bandingkan jumlah yang diperoleh; Faktor utama N sedang disimpan dalam vektor PF; Jika n adalah nombor perdana, ia tidak boleh menjadi nombor tipuan; Mencari jumlah digit faktor utama yang berbeza dari nombor n; Mencari jumlah digit dalam faktor utama semasa PF [i]. ; Mencari jumlah digit nombor n; Membandingkan dua jumlah yang dikira; Kod pemacu", "code": "< ? php function primeFactors ( $ n ) { $ res = array ( ) ; if ( $ n % 2 == 0 ) { while ( $ n % 2 == 0 ) $ n = ( int ) $ n / 2 ; array_push ( $ res , 2 ) ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { while ( $ n % $ i == 0 ) $ n = ( int ) $ n / $ i ; array_push ( $ res , $ i ) ; } } if ( $ n > 2 ) array_push ( $ res , $ n ) ; return $ res ; } function isHoax ( $ n ) { $ pf = primeFactors ( $ n ) ; if ( $ pf [ 0 ] == $ n ) return false ; $ all_pf_sum = 0 ; for ( $ i = 0 ; $ i < count ( $ pf ) ; $ i ++ ) { $ pf_sum ; for ( $ pf_sum = 0 ; $ pf [ $ i ] > 0 ; $ pf_sum += $ pf [ $ i ] % 10 , $ pf [ $ i ] /= 10 ) ; $ all_pf_sum += $ pf_sum ; } for ( $ sum_n = 0 ; $ n > 0 ; $ sum_n += $ n % 10 , $ n /= 10 ) ; return $ sum_n == $ all_pf_sum ; } $ n = 84 ; if ( isHoax ( $ n ) ) echo ( \" A ▁ Hoax ▁ Number STRNEWLINE \" ) ; else echo ( \" Not ▁ a ▁ Hoax ▁ Number STRNEWLINE \" ) ; ? >"}
{"text": "Modular multiplicative songsang dari 1 hingga n | Kaedah naif untuk mencari terbalik berbilang modular 'A' di bawah modulo 'Perdana; Program Pemandu", "code": "< ? php function modInverse ( int $ a , int $ prime ) { $ a = $ a % $ prime ; for ( $ x = 1 ; $ x < $ prime ; $ x ++ ) if ( ( $ a * $ x ) % $ prime == 1 ) return $ x ; return -1 ; } function printModIverses ( $ n , $ prime ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo modInverse ( $ i , $ prime ) , \" ▁ \" ; } $ n = 10 ; $ prime = 17 ; printModIverses ( $ n , $ prime ) ; ? >"}
{"text": "Tukar ke nombor dengan digit sebagai 3 dan 8 sahaja | fungsi untuk operasi minimum; baki dan kiraan operasi; mengira digit tidak sama dengan 3 atau 8; Kod pemacu", "code": "< ? php function minOp ( $ num ) { $ count = 0 ; while ( $ num ) { $ rem = intval ( $ num % 10 ) ; if ( ! ( $ rem == 3 $ rem == 8 ) ) $ count ++ ; $ num = intval ( $ num / 10 ) ; } return $ count ; } $ num = 234198 ; echo \" Minimum ▁ Operations ▁ = ▁ \" . minOp ( $ num ) ; ? >"}
{"text": "Integer terbesar yang mempunyai jumlah digit maksimum dalam julat dari 1 hingga n | berfungsi untuk mengira jumlah digit nombor. ; Mengembalikan nombor maksimum dengan jumlah maksimum digit. ; memulakan b sebagai 1 dan jumlah maksimum awal menjadi n; berulang dari kanan ke kiri dalam digit; Walaupun meleleh ini adalah nombor dari kanan ke kiri; memanggil fungsi untuk memeriksa sama ada jumlah CUR adalah lebih daripada ANS; mengurangkan nombor ke satu unit kurang; Kod pemacu", "code": "< ? php function sumOfDigits ( $ a ) { $ sum = 0 ; while ( $ a ) { $ sum += $ a % 10 ; $ a = ( int ) $ a / 10 ; } return $ sum ; } function findMax ( $ x ) { $ b = 1 ; $ ans = $ x ; while ( $ x ) { $ cur = ( $ x - 1 ) * $ b + ( $ b - 1 ) ; if ( sumOfDigits ( $ cur ) > sumOfDigits ( $ ans ) || ( sumOfDigits ( $ cur ) == sumOfDigits ( $ ans ) && $ cur > $ ans ) ) $ ans = $ cur ; $ x = ( int ) $ x / 10 ; $ b *= 10 ; } return $ ans ; } $ n = 521 ; echo findMax ( $ n ) ; ? >"}
{"text": "Julat Interquartile (IQR) | Fungsi untuk memberi indeks median; Fungsi untuk mengira IQR; Indeks median keseluruhan data; Median separuh pertama; Median separuh kedua; Pengiraan IQR; Fungsi pemacu", "code": "< ? php function median ( $ a , $ l , $ r ) { $ n = $ r - $ l + 1 ; $ n = ( int ) ( ( $ n + 1 ) / 2 ) - 1 ; return $ n + $ l ; } function IQR ( $ a , $ n ) { sort ( $ a ) ; $ mid_index = median ( $ a , 0 , $ n ) ; $ Q1 = $ a [ median ( $ a , 0 , $ mid_index ) ] ; $ Q3 = $ a [ $ mid_index + median ( $ a , $ mid_index + 1 , $ n ) ] ; return ( $ Q3 - $ Q1 ) ; } $ a = array ( 1 , 19 , 7 , 6 , 5 , 9 , 12 , 27 , 18 , 2 , 15 ) ; $ n = count ( $ a ) ; echo IQR ( $ a , $ n ) ; ? >"}
{"text": "Nombor palindromik terbesar dalam array | Fungsi untuk memeriksa sama ada n adalah palindrome; Cari pembahagi yang sesuai untuk mengekstrak digit terkemuka; Jika digit pertama dan terakhir tidak sama maka kembali palsu; Mengeluarkan digit terkemuka dan trailing dari nombor; Mengurangkan pembahagi dengan faktor 2 sebagai 2 digit dijatuhkan; Berfungsi untuk mencari nombor palindromik terbesar; Susun array; Jika nombor adalah palindrome; Jika tiada nombor palindromik yang dijumpai; Kod pemacu; Cetak jawapan yang diperlukan", "code": "< ? php function isPalindrome ( $ n ) { $ divisor = 1 ; while ( ( int ) ( $ n / $ divisor ) >= 10 ) $ divisor *= 10 ; while ( $ n != 0 ) { $ leading = ( int ) ( $ n / $ divisor ) ; $ trailing = $ n % 10 ; if ( $ leading != $ trailing ) return false ; $ n = ( int ) ( ( $ n % $ divisor ) / 10 ) ; $ divisor = ( int ) ( $ divisor / 100 ) ; } return true ; } function largestPalindrome ( $ A , $ n ) { sort ( $ A ) ; for ( $ i = $ n - 1 ; $ i >= 0 ; -- $ i ) { if ( isPalindrome ( $ A [ $ i ] ) ) return $ A [ $ i ] ; } return -1 ; } $ A = array ( 1 , 232 , 54545 , 999991 ) ; $ n = sizeof ( $ A ) ; echo largestPalindrome ( $ A , $ n ) ; ? >"}
{"text": "Jumlah gandaan dua nombor di bawah n | Berfungsi untuk mengembalikan jumlah semua bilangan bulat di bawah n yang merupakan gandaan sama ada A atau B; Jika saya adalah pelbagai A atau B; Kod pemacu", "code": "< ? php function findSum ( $ n , $ a , $ b ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ i % $ a == 0 $ i % $ b == 0 ) $ sum += $ i ; return $ sum ; } $ n = 10 ; $ a = 3 ; $ b = 5 ; echo findSum ( $ n , $ a , $ b ) ; ? >"}
{"text": "Kurangkan 1 tanpa pengendali aritmetik | Kod pemacu", "code": "< ? php function subtractOne ( $ x ) { return ( ( $ x << 1 ) + ( ~ $ x ) ) ; } print ( subtractOne ( 13 ) ) ; ? >"}
{"text": "Nombor Pell | Hitung nombor pell; Kod pemacu", "code": "< ? php function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; return 2 * pell ( $ n - 1 ) + pell ( $ n - 2 ) ; } $ n = 4 ; echo ( pell ( $ n ) ) ; ? >"}
{"text": "Mencari LCM lebih daripada dua (atau array) tanpa menggunakan GCD | Mengembalikan LCM ARR [0 .. n - 1]; Cari nilai maksimum dalam ARR []; Memulakan hasil; Cari semua faktor yang terdapat dalam dua atau lebih elemen array. $ x = 2; Faktor semasa. ; Untuk menyimpan indeks semua elemen array yang boleh dibahagikan dengan x. ; Sekiranya terdapat 2 atau lebih elemen array yang boleh dibahagikan dengan x. ; Kurangkan semua elemen array yang boleh dibahagikan dengan x. ; Kemudian kalikan semua elemen array yang dikurangkan; Kod pemacu", "code": "< ? php function LCM ( $ arr , $ n ) { $ max_num = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max_num < $ arr [ $ i ] ) $ max_num = $ arr [ $ i ] ; $ res = 1 ; while ( $ x <= $ max_num ) { $ indexes = array ( ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ j ] % $ x == 0 ) array_push ( $ indexes , $ j ) ; if ( count ( $ indexes ) >= 2 ) { for ( $ j = 0 ; $ j < count ( $ indexes ) ; $ j ++ ) $ arr [ $ indexes [ $ j ] ] = ( int ) ( $ arr [ $ indexes [ $ j ] ] / $ x ) ; $ res = $ res * $ x ; } else $ x ++ ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = $ res * $ arr [ $ i ] ; return $ res ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 ) ; $ n = count ( $ arr ) ; echo LCM ( $ arr , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk tekaan Goldbach (dua prima dengan jumlah yang diberikan) | Program PHP untuk melaksanakan sangkaan Goldbach; Array untuk menyimpan semua perdana kurang daripada dan sama dengan 10 ^ 6; Fungsi utiliti untuk Sieve of Sundaram; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahukan prima yang lebih kecil daripada Max, kita mengurangkan max hingga separuh. Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 * i * j dari orang lain di mana 1 <= i <= j; Logik utama Sundaram. Tandakan semua nombor yang tidak menjana nombor perdana dengan melakukan 2 * i + 1; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Berfungsi untuk melakukan sangkaan Goldbach; Kembali jika nombor tidak atau kurang daripada 3; Semak hanya separuh daripada nombor; Cari perbezaan dengan menolak perdana semasa dari n; Cari jika perbezaannya juga merupakan nombor utama; Menyatakan sebagai jumlah prima; Mencari semua nombor perdana sebelum had; Nombor Ekspres sebagai Jumlah Dua Prima", "code": "< ? php $ MAX = 10000 ; $ primes = array ( ) ; function sieveSundaram ( ) { global $ MAX , $ primes ; $ marked = array_fill ( 0 , ( int ) ( $ MAX / 2 ) + 100 , false ) ; for ( $ i = 1 ; $ i <= ( sqrt ( $ MAX ) - 1 ) / 2 ; $ i ++ ) for ( $ j = ( $ i * ( $ i + 1 ) ) << 1 ; $ j <= $ MAX / 2 ; $ j = $ j + 2 * $ i + 1 ) $ marked [ $ j ] = true ; array_push ( $ primes , 2 ) ; for ( $ i = 1 ; $ i <= $ MAX / 2 ; $ i ++ ) if ( $ marked [ $ i ] == false ) array_push ( $ primes , 2 * $ i + 1 ) ; } function findPrimes ( $ n ) { global $ MAX , $ primes ; if ( $ n <= 2 $ n % 2 != 0 ) { print ( \" Invalid ▁ Input ▁ STRNEWLINE \" ) ; return ; } for ( $ i = 0 ; $ primes [ $ i ] <= $ n / 2 ; $ i ++ ) { $ diff = $ n - $ primes [ $ i ] ; if ( in_array ( $ diff , $ primes ) ) { print ( $ primes [ $ i ] . \" + \" ▁ . ▁ $ diff ▁ . ▁ \" = \" ▁ . ▁ $ n ▁ . ▁ \" \" return ; } } } sieveSundaram ( ) ; findPrimes ( 4 ) ; findPrimes ( 38 ) ; findPrimes ( 100 ) ; ? >"}
{"text": "K | Fungsi untuk menjana faktor utama nombor n dan mengembalikan faktor utama; Cari bilangan 2 yang membahagikan k; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, simpan saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes di mana n adalah nombor perdana yang lebih besar daripada 2; Kod pemacu", "code": "< ? php function kPrimeFactor ( $ n , $ k ) { while ( $ n % 2 == 0 ) { $ k -- ; $ n = $ n / 2 ; if ( $ k == 0 ) return 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { while ( $ n % $ i == 0 ) { if ( $ k == 1 ) return $ i ; $ k -- ; $ n = $ n / $ i ; } } if ( $ n > 2 && $ k == 1 ) return $ n ; return -1 ; } { $ n = 12 ; $ k = 3 ; echo kPrimeFactor ( $ n , $ k ) , \" STRNEWLINE \" ; $ n = 14 ; $ k = 3 ; echo kPrimeFactor ( $ n , $ k ) ; return 0 ; } ? >"}
{"text": "K | Program PHP untuk mencari faktor utama menggunakan penapis eratosthenes. Program ini adalah cekap apabila kita mempunyai pelbagai nombor. ; Menggunakan Sieveoferatosthenes untuk mencari faktor utama terkecil semua nombor. Sebagai contoh, jika max adalah 10, s [2] = s [4] = s [6] = s [10] = 2 s [3] = s [9] = 3 s [5] = 5 s [7] = 7; Buat array Boolean \"Perdana [0.. Max]\" dan memulakan semua penyertaan di dalamnya sebagai palsu. ; Memulakan faktor terkecil sama dengan 2 untuk semua nombor walaupun; Untuk nombor ganjil kurang kemudian sama dengan n; S (i) untuk perdana adalah nombor itu sendiri; Untuk semua gandaan nombor perdana semasa; Saya adalah faktor utama terkecil untuk nombor \"i * j\". ; Berfungsi untuk menjana faktor utama dan mengembalikan faktor utama. S [i] menyimpan faktor utama i. ; Terus membahagikan n dengan faktor utama walaupun sama ada n tidak 1 atau kiraan faktor utama bukan k. ; Untuk menjejaki kiraan faktor utama; Bahagikan N untuk mencari faktor utama seterusnya; S [i] akan menyimpan faktor utama i.", "code": "< ? php $ MAX = 10001 ; function sieveOfEratosthenes ( & $ s ) { global $ MAX ; $ prime = array_fill ( 0 , $ MAX + 1 , false ) ; for ( $ i = 2 ; $ i <= $ MAX ; $ i += 2 ) $ s [ $ i ] = 2 ; for ( $ i = 3 ; $ i <= $ MAX ; $ i += 2 ) { if ( $ prime [ $ i ] == false ) { $ s [ $ i ] = $ i ; for ( $ j = $ i ; $ j * $ i <= $ MAX ; $ j += 2 ) { if ( $ prime [ $ i * $ j ] == false ) { $ prime [ $ i * $ j ] = true ; $ s [ $ i * $ j ] = $ i ; } } } } } function kPrimeFactor ( $ n , $ k , $ s ) { while ( $ n > 1 ) { if ( $ k == 1 ) return $ s [ $ n ] ; $ k -- ; $ n = ( int ) ( $ n / $ s [ $ n ] ) ; } return -1 ; } $ s = array_fill ( 0 , $ MAX + 1 , -1 ) ; sieveOfEratosthenes ( $ s ) ; $ n = 12 ; $ k = 3 ; print ( kPrimeFactor ( $ n , $ k , $ s ) . \" \" ) ; $ n = 14 ; $ k = 3 ; print ( kPrimeFactor ( $ n , $ k , $ s ) ) ; ? >"}
{"text": "Kriteria Euler (periksa jika akar persegi di bawah modulo p wujud) | Pulangan benar jika akar persegi n di bawah modulo p wujud; Satu demi satu periksa semua nombor dari 2 hingga p - 1; Kod pemacu", "code": "< ? php function squareRootExists ( $ n , $ p ) { $ n = $ n % $ p ; for ( $ x = 2 ; $ x < $ p ; $ x ++ ) if ( ( $ x * $ x ) % $ p == $ n ) return true ; return false ; } $ p = 7 ; $ n = 2 ; if ( squareRootExists ( $ n , $ p ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Formula Legendre (diberikan p dan n, cari x terbesar sedemikian rupa sehingga p^x membahagikan n!) | Mengembalikan kuasa terbesar P yang membahagikan N! ; Memulakan hasil; Kirakan x = n / p + n / (p ^ 2) + n / (p ^ 3) + .... ; Kod pemacu", "code": "< ? php function largestPower ( $ n , $ p ) { $ x = 0 ; while ( $ n ) { $ n = ( int ) $ n / $ p ; $ x += $ n ; } return floor ( $ x ) ; } $ n = 10 ; $ p = 3 ; echo \" The ▁ largest ▁ power ▁ of ▁ \" , $ p ; echo \" ▁ that ▁ divides ▁ \" , $ n , \" ! ▁ is ▁ \" ; echo largestPower ( $ n , $ p ) ; ? >"}
{"text": "Program untuk faktorial nombor | Program PHP untuk mencari faktorial nombor tertentu; Baris tunggal untuk mencari faktorial; Kod pemacu", "code": "< ? php function factorial ( $ n ) { return ( $ n == 1 $ n == 0 ) ? 1 : $ n * factorial ( $ n - 1 ) ; } $ num = 5 ; echo \" Factorial ▁ of ▁ \" , $ num , \" ▁ is ▁ \" , factorial ( $ num ) ; ? >"}
{"text": "Bit sebenar bit nombor yang diberikan | berfungsi untuk membalikkan bit nombor; melintasi bit 'n' dari kanan; Bitwise kiri Shift 'Rev' oleh 1; jika bit semasa ialah '1'; Bitwise kanan shift 'n' oleh 1; nombor yang diperlukan; Kod pemacu", "code": "< ? php function reverseBits ( $ n ) { $ rev = 0 ; while ( $ n > 0 ) { $ rev <<= 1 ; if ( $ n & 1 == 1 ) $ rev ^= 1 ; $ n >>= 1 ; } return $ rev ; } $ n = 11 ; echo reverseBits ( $ n ) ; ? >"}
{"text": "Cara untuk memecah array ke dalam dua kumpulan nilai XOR yang sama | Kembalikan jumlah cara untuk memecah array ke dalam dua kumpulan sehingga setiap nilai XOR yang sama. ; Kita boleh berpecah hanya jika XOR adalah 0. Oleh kerana XOR semua adalah 0, kita boleh mempertimbangkan semua subset sebagai satu kumpulan. ; Kod pemacu", "code": "< ? php function countgroup ( $ a , $ n ) { $ xs = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ xs = $ xs ^ $ a [ $ i ] ; if ( $ xs == 0 ) return ( 1 << ( $ n - 1 ) ) - 1 ; return 0 ; } $ a = array ( 1 , 2 , 3 ) ; $ n = count ( $ a ) ; echo countgroup ( $ a , $ n ) ; ? >"}
{"text": "Ekstrak 'k' bit dari kedudukan tertentu dalam nombor. | Berfungsi untuk mengekstrak k bit dari kedudukan p dan mengembalikan nilai yang diekstrak sebagai integer; Kod pemacu", "code": "< ? php function bitExtracted ( $ number , $ k , $ p ) { return ( ( ( 1 << $ k ) - 1 ) & ( $ number >> ( $ p - 1 ) ) ) ; } $ number = 171 ; $ k = 5 ; $ p = 2 ; echo \" The ▁ extracted ▁ number ▁ is ▁ \" , bitExtracted ( $ number , $ k , $ p ) ; ? >"}
{"text": "Periksa dengan cekap sama ada n adalah pelbagai 4 atau tidak | fungsi untuk memeriksa sama ada 'n' adalah pelbagai 4 atau tidak; jika benar, maka 'n' adalah pelbagai 4; lain 'n' bukanlah pelbagai 4; Kod pemacu", "code": "< ? php function isAMultipleOf4 ( $ n ) { if ( ( $ n & 3 ) == 0 ) return \" Yes \" ; return \" No \" ; } $ n = 16 ; echo isAMultipleOf4 ( $ n ) ; ? >"}
{"text": "Kirakan persegi nombor tanpa menggunakan *, / dan pow () | Pelaksanaan PHP untuk mengira persegi tanpa menggunakan * dan pow (); mengendalikan input negatif; Memulakan hasil; Tambah n ke res n - 1 kali; Kod pemacu", "code": "< ? php function square ( $ n ) { if ( $ n < 0 ) $ n = - $ n ; $ res = $ n ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ res += $ n ; return $ res ; } for ( $ n = 1 ; $ n <= 5 ; $ n ++ ) echo \" n = \" , ▁ $ n , ▁ \" , \" , ▁ \" n ^ 2 = \" , square ( $ n ) , \" STRNEWLINE ▁ \" ; ? >"}
{"text": "Cari titik yang terletak di dalam Kuadrat yang tepat K yang diberikan | Pelaksanaan PHP pendekatan; Kod pemacu", "code": "< ? php function PointInKSquares ( $ n , $ a , $ k ) { sort ( $ a ) ; return $ a [ $ n - $ k ] ; } $ k = 2 ; $ a = array ( 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ a ) ; $ x = PointInKSquares ( $ n , $ a , $ k ) ; echo \" ( \" . $ x . \" , \" ▁ . ▁ $ x ▁ . ▁ \" ) \" ; ? >"}
{"text": "Bilangan N digit Nombor Langkah | Penyelesaian Dioptimumkan Ruang | fungsi yang mengira jawapannya; DP [J] Kedai kiraan saya angka melangkah angka yang berakhir dengan digit j. ; Untuk menyimpan hasil panjang i - 1 sebelum mengemas kini dp [j] untuk panjang i. ; Jika n adalah 1 maka jawapannya akan menjadi 10 .; Memulakan nilai untuk mengira digit sama dengan 1 .; Mengira nilai untuk mengira digit lebih daripada 1 .; Jika angka berakhir adalah 0; Jika angka berakhir adalah 9; Untuk digit lain. ; menyimpan jawapan terakhir; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function answer ( $ n ) { $ dp = array_fill ( 0 , 10 , 0 ) ; $ prev = array_fill ( 0 , 10 , 0 ) ; ; if ( $ n == 1 ) return 10 ; for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) $ dp [ $ j ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) { $ prev [ $ j ] = $ dp [ $ j ] ; } for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) { if ( $ j == 0 ) $ dp [ $ j ] = $ prev [ $ j + 1 ] ; else if ( $ j == 9 ) $ dp [ $ j ] = $ prev [ $ j - 1 ] ; else $ dp [ $ j ] = $ prev [ $ j - 1 ] + $ prev [ $ j + 1 ] ; } } $ sum = 0 ; for ( $ j = 1 ; $ j <= 9 ; $ j ++ ) $ sum += $ dp [ $ j ] ; return $ sum ; } $ n = 2 ; echo answer ( $ n ) ; ? >"}
{"text": "Perubahan minimum diperlukan untuk membuat urutan Catalan | Pelaksanaan PHP pendekatan; Untuk menyimpan nombor N First N; Berfungsi untuk mencari nombor N Catalan pertama; Memulakan dua nilai pertama dalam jadual; Penyertaan filong dalam Catalan [] menggunakan formula rekursif; Berfungsi untuk mengembalikan perubahan minimum yang diperlukan; Cari nombor N Catalan pertama; A dan B adalah dua nombor urutan Catalan pertama; Masukkan unsur -unsur Catalan pertama untuk ditetapkan; Jika elemen Catalan hadir dalam array kemudian keluarkannya dari set; Kembalikan bilangan elemen dalam set; Kod pemacu", "code": "< ? php $ MAX = 1000 ; $ catalan = array_fill ( 0 , $ MAX , 0 ) ; function catalanDP ( $ n ) { global $ catalan ; $ catalan [ 0 ] = $ catalan [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ catalan [ $ i ] = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { $ catalan [ $ i ] += $ catalan [ $ j ] * $ catalan [ $ i - $ j - 1 ] ; } } } function CatalanSequence ( $ arr , $ n ) { global $ catalan ; catalanDP ( $ n ) ; $ s = array ( ) ; $ a = $ b = 1 ; array_push ( $ s , $ a ) ; if ( $ n >= 2 ) { array_push ( $ s , $ b ) ; } for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { array_push ( $ s , $ catalan [ $ i ] ) ; } $ s = array_unique ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( in_array ( $ arr [ $ i ] , $ s ) ) { unset ( $ s [ array_search ( $ arr [ $ i ] , $ s ) ] ) ; } } return count ( $ s ) ; } $ arr = array ( 1 , 1 , 2 , 5 , 41 ) ; $ n = count ( $ arr ) ; print ( CatalanSequence ( $ arr , $ n ) ) ; ? >"}
{"text": "Jurang terbesar dalam array | fungsi untuk menyelesaikan masalah yang diberikan; Kod pemacu", "code": "< ? php function solve ( $ a , $ n ) { $ max1 = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( abs ( $ a [ $ i ] - $ a [ $ j ] ) > $ max1 ) { $ max1 = abs ( $ a [ $ i ] - $ a [ $ j ] ) ; } } } return $ max1 ; } $ arr = array ( -1 , 2 , 3 , -4 , -10 , 22 ) ; $ size = count ( $ arr ) ; echo \" Largest ▁ gap ▁ is ▁ : ▁ \" , solve ( $ arr , $ size ) ; ? >"}
{"text": "Jurang terbesar dalam array | fungsi untuk menyelesaikan masalah yang diberikan; mencari maksimum dan minimum array; Kod pemacu", "code": "< ? php function solve ( $ a , $ n ) { $ min1 = $ a [ 0 ] ; $ max1 = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ max1 ) $ max1 = $ a [ $ i ] ; if ( $ a [ $ i ] < $ min1 ) $ min1 = $ a [ $ i ] ; } return abs ( $ min1 - $ max1 ) ; } $ arr = array ( -1 , 2 , 3 , 4 , -10 ) ; $ size = count ( $ arr ) ; echo \" Largest ▁ gap ▁ is ▁ : ▁ \" , solve ( $ arr , $ size ) ; ? >"}
{"text": "Subset terkecil dengan jumlah yang lebih besar daripada semua elemen lain | Fungsi untuk mencari elemen minimum yang diperlukan. ; mengira separuh daripada jumlah array; Susun array dalam urutan menurun. ; jumlah semasa lebih besar daripada jumlah; Kod pemacu", "code": "< ? php function minElements ( $ arr , $ n ) { $ halfSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ halfSum = $ halfSum + $ arr [ $ i ] ; $ halfSum = $ halfSum / 2 ; rsort ( $ arr ) ; $ res = 0 ; $ curr_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum += $ arr [ $ i ] ; $ res ++ ; if ( $ curr_sum > $ halfSum ) return $ res ; } return $ res ; } $ arr = array ( 3 , 1 , 7 , 1 ) ; $ n = sizeof ( $ arr ) ; echo minElements ( $ arr , $ n ) ; ? >"}
{"text": "Kos minimum untuk mencapai titik n dari 0 dengan dua operasi yang berbeza dibenarkan | Berfungsi untuk mengembalikan kos minimum untuk mencapai tujuan; Memulakan kos kepada 0; pergi ke belakang sehingga kita mencapai kedudukan awal; Jika 2 * x melompat lebih baik daripada x + 1; Jika lompat x + 1 lebih baik; kos pulangan; Kod pemacu", "code": "< ? php function minCost ( $ N , $ P , $ Q ) { $ cost = 0 ; while ( $ N > 0 ) { if ( $ N & 1 ) { $ cost += $ P ; $ N -- ; } else { $ temp = $ N / 2 ; if ( $ temp * $ P > $ Q ) $ cost += $ Q ; else $ cost += $ P * $ temp ; $ N /= 2 ; } } return $ cost ; } $ N = 9 ; $ P = 5 ; $ Q = 1 ; echo minCost ( $ N , $ P , $ Q ) ; ? >"}
