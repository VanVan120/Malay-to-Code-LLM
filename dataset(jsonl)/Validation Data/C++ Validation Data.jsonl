{"text": "Program untuk menukar sentimeter ke piksel | C ++ program untuk menukar sentimeter ke piksel; Berfungsi untuk menukar sentimeter ke piksel; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; cout << fixed << setprecision ( 2 ) << pixels ; } int main ( ) { double centi = 15 ; Conversion ( centi ) ; return 0 ; }"}
{"text": "Elemen Arus KTH selepas penggantian elemen array oleh xor pasangan bersebelahan | Program C ++ untuk pendekatan di atas; Kaedah yang mengembalikan output yang sepadan dengan mengambil input yang diberikan. ; Jika keadaan ini berpuas hati, nilai m tidak sah; Semak sama ada indeks k adalah sah; Gelung untuk melaksanakan operasi M; Mewujudkan senarai sementara; Melintasi array; Mengira nilai XOR unsur -unsur bersebelahan; Menambah nilai ini ke senarai sementara; Kemas kini array asal; Mendapatkan nilai pada indeks k; Kod pemacu; Bilangan elemen; Diberikan array arr []; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int xor_operations ( int N , int arr [ ] , int M , int K ) { if ( M < 0 or M > = N ) return -1 ; if ( K < 0 or K > = N - M ) return -1 ; for ( int p = 0 ; p < M ; p ++ ) { vector < int > temp ; for ( int i = 0 ; i < N ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . push_back ( value ) ; arr [ i ] = temp [ i ] ; } } int ans = arr [ K ] ; return ans ; } int main ( ) { int N = 5 ; int arr [ ] = { 1 , 4 , 5 , 6 , 7 } ; int M = 1 , K = 2 ; cout << xor_operations ( N , arr , M , K ) ; return 0 ; }"}
{"text": "Semak jika n boleh dibahagikan kepada elemen K berturut -turut dengan jumlah yang sama dengan N | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari unsur -unsur berturut -turut dengan jumlah yang sama dengan n; Melangkah ke atas [2, inf]; Simpan jumlahnya; Jika jumlah melebihi n maka pecahkan gelung; Perbezaan umum harus dibahagikan dengan bilangan istilah; Cetak nilai i & kembali; Cetak \" - 1\" jika tidak mungkin untuk memecahkan n; Kod pemacu; Diberikan n; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void canBreakN ( long long n ) { for ( long long i = 2 ; ; i ++ ) { long long m = i * ( i + 1 ) / 2 ; if ( m > n ) break ; long long k = n - m ; if ( k % i ) continue ; cout << i << endl ; return ; } cout << \" - 1\" ; } int main ( ) { long long N = 12 ; canBreakN ( N ) ; return 0 ; }"}
{"text": "Pembahagi Coprime nombor | Program C ++ untuk mencari dua pembahagi coprime nombor tertentu supaya kedua -duanya lebih besar daripada 1; Fungsi yang mendapati sepasang pembahagi n yang diperlukan; Kami melangkah sehingga sqrt (n) kerana kita dapat mencari semua pembahagi n pada masa ini; Jika x adalah pembahagi n terus membahagikan selagi mungkin; Kami telah menemui pasangan yang diperlukan; Tidak ada sepasang pembahagi n yang dijumpai, oleh itu cetak - 1; Kod pemacu; Contoh Contoh 1; Contoh Contoh 2", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCoprimePair ( int N ) { for ( int x = 2 ; x <= sqrt ( N ) ; x ++ ) { if ( N % x == 0 ) { while ( N % x == 0 ) { N /= x ; } if ( N > 1 ) { cout << x << \" ▁ \" << N << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { int N = 45 ; findCoprimePair ( N ) ; N = 25 ; findCoprimePair ( N ) ; return 0 ; }"}
{"text": "Nombor Sisa | Program C ++ untuk pendekatan di atas; Array untuk menyimpan semua perdana kurang daripada dan sama dengan max. ; Fungsi untuk penapis Sundaram; Array Boolean; Tandakan semua nombor yang tidak menjana nombor perdana dengan 2 * i + 1; Oleh kerana 2 adalah nombor perdana; Cetak prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Fungsi yang pulih benar jika n adalah nombor yang membazir; Mengira digit dalam nombor asal; Kira semua digit dalam faktor utama N pdigit akan memegang nilai ini. ; Mengira kuasa p dalam n; Jika prima [i] adalah faktor utama ,; Mengira kuasa faktor utama; Tambah digitnya ke PDIGIT; Tambah digit kuasa faktor utama kepada pdigit. ; Jika n! = 1 maka satu faktor utama masih akan disimpulkan; Jika digit dalam faktor utama lebih daripada digit dalam nombor asal maka kembali benar. Lain kembali palsu. ; Berfungsi untuk mencetak nombor yang membazir sebelum n; Melepasi sehingga n dan periksa sama ada saya membazir atau tidak; Kod pemacu; Nombor Perdana Precompute sehingga 10 ^ 6; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; vector < int > primes ; void sieveSundaram ( ) { bool marked [ MAX / 2 + 1 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) { for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) { marked [ j ] = true ; } } primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; } bool isWasteful ( int n ) { if ( n == 1 ) return false ; int original_no = n ; int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = original_no / 10 ; } int pDigit = 0 , count_exp = 0 , p ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { while ( n % primes [ i ] == 0 ) { p = primes [ i ] ; n = n / p ; count_exp ++ ; } while ( p > 0 ) { pDigit ++ ; p = p / 10 ; } while ( count_exp > 1 ) { pDigit ++ ; count_exp = count_exp / 10 ; } } if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = n / 10 ; } } return ( pDigit > sumDigits ) ; } void Solve ( int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( isWasteful ( i ) ) { cout << i << \" ▁ \" ; } } } int main ( ) { sieveSundaram ( ) ; int N = 10 ; Solve ( N ) ; return 0 ; }"}
{"text": "Nombor Hexanacci | C ++ program rekursif mudah untuk mencetak nombor hexanacci nth. ; Berfungsi untuk mencetak nombor hexanacci nth; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int printhexaRec ( int n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 n == 5 ) return 0 ; else if ( n == 6 ) return 1 ; else return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) ; } int printhexa ( int n ) { cout << printhexaRec ( n ) << endl ; } int main ( ) { privatenthexa ( n ) ; }"}
{"text": "Nombor Hexanacci | C ++ pelaksanaan untuk mencetak istilah nth hexanacci nombor. ; Berfungsi untuk mencetak istilah n nombor hexanacci; Memulakan lima nombor pertama untuk kes asas; Mengisytiharkan pemboleh ubah semasa; Gelung untuk menambah lima nombor sebelumnya untuk setiap nombor bermula dari 5 dan kemudian berikan pertama, kedua, kedua, keempat kelima hingga kedua, ketiga, keempat, kelima dan curr masing -masing; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printhexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) cout << first << endl ; else if ( n == 6 ) cout << sixth << endl ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } cout << curr << endl ; } int main ( ) { int n = 11 ; printhexa ( n ) ; return 0 ; }"}
{"text": "Cari nombor terkecil yang jumlah digitnya adalah n | Program C ++ untuk mencari nombor terkecil yang jumlah digitnya juga n; Berfungsi untuk mencari nombor terkecil yang jumlah digit juga n; Kod pemacu", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void smallestNumber ( int N ) { cout << ( N % 9 + 1 ) * pow ( 10 , ( N / 9 ) ) - 1 ; } int main ( ) { int N = 10 ; smallestNumber ( N ) ; return 0 ; }"}
{"text": "Kompositori Nombor | Program C ++ untuk mencari kompositori nombor komposit; Fungsi untuk memeriksa sama ada nombor adalah komposit. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor tengah dalam gelung di bawah; Fungsi ini menyimpan semua nombor komposit kurang daripada n; Fungsi untuk mengira kompositori n; Multiply nombor komposit pertama N; Kod pemacu; Vektor untuk menyimpan semua komposit kurang daripada n", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > compo ; bool isComposite ( int n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 or n % 3 == 0 ) return true ; int i = 5 ; while ( i * i <= n ) { if ( n % i == 0 or n % ( i + 2 ) == 0 ) return true ; i = i + 6 ; } return false ; } void Compositorial_list ( int n ) { int l = 0 ; for ( int i = 4 ; i < 1000000 ; i ++ ) { if ( l < n ) { if ( isComposite ( i ) ) { compo . push_back ( i ) ; l += 1 ; } } } } int calculateCompositorial ( int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result = result * compo [ i ] ; return result ; } int main ( ) { int n = 5 ; Compositorial_list ( n ) ; cout << ( calculateCompositorial ( n ) ) ; return 0 ; }"}
{"text": "Kuasa yang berbeza dari nombor n supaya jumlahnya sama dengan k | C ++ pelaksanaan untuk mengetahui kuasa N yang menambah sehingga K; Memulakan PowerArray dengan semua 0; Fungsi untuk mencari kuasa n yang menambah sehingga k; Memulakan kaunter; Melaksanakan gelung sementara sehingga k lebih besar daripada 0; Jika k % n == 1, maka array kuasa ditingkatkan dengan 1; Memeriksa jika ada kuasa yang berlaku lebih dari sekali; Untuk apa -apa nilai lain, jumlah kuasa tidak boleh ditambah sehingga k; Mencetak kuasa N yang merangkumi K; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int b [ 50 ] = { 0 } ; int PowerArray ( int n , int k ) { int count = 0 ; while ( k ) { if ( k % n == 0 ) { k /= n ; count ++ ; } else if ( k % n == 1 ) { k -= 1 ; b [ count ] ++ ; if ( b [ count ] > 1 ) { cout << -1 ; return 0 ; } } else { cout << -1 ; return 0 ; } } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] ) { cout << i << \" , ▁ \" ; } } } int main ( ) { int N = 3 ; int K = 40 ; PowerArray ( N , K ) ; return 0 ; }"}
{"text": "Program untuk mencari nilai 1 ^ k + 2 ^ k + 3 ^ k + ... + n ^ k | C ++ Program untuk mencari nilai 1 ^ K + 2 ^ K + 3 ^ K +. . + N ^ k; Fungsi untuk mencari nilai 1 ^ K + 2 ^ K + 3 ^ K +. . + N ^ k; INISIISE SUM kepada 0; Cari nilai POW (i, 4) dan kemudian tambahkannya ke jumlah; Mengembalikan jumlahnya; Kod pemacu; Fungsi panggilan untuk mencari jumlah", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += pow ( i , k ) ; } return sum ; } int main ( ) { int N = 8 , k = 4 ; cout << findSum ( N , k ) << endl ; return 0 ; }"}
{"text": "Kira indeks dalam array yang memenuhi syarat yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan indeks yang memenuhi syarat yang diberikan; Untuk menyimpan hasilnya; Untuk menyimpan maksimum semasa yang dimulakan ke 0 kerana hanya terdapat unsur -unsur positif dalam array; Saya adalah indeks yang sah; Mengemas kini maksimum setakat ini; Kenaikan kaunter; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIndices ( int arr [ ] , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << countIndices ( arr , n ) ; return 0 ; }"}
{"text": "Kekerapan maksimum modulo 2 i | C ++ pelaksanaan pendekatan; Perwakilan binari digit; Berfungsi untuk mengembalikan kekerapan maksimum modulo S dengan kuasa 2; Simpan perwakilan binari; Tukar oktal ke binari; Keluarkan LSB; Sekiranya terdapat 1 dalam perwakilan binari; Cari bilangan sifar di antara dua 1 dalam perwakilan binari; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const string bin [ ] = { \"000\" , \"001\" , \"010\" , \"011\" , \"100\" , \"101\" , \"110\" , \"111\" } ; int maxFreq ( string s ) { string binary = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { binary += bin [ s [ i ] - '0' ] ; } binary = binary . substr ( 0 , binary . length ( ) - 1 ) ; int count = 1 , prev = -1 , i , j = 0 ; for ( i = binary . length ( ) - 1 ; i >= 0 ; i -- , j ++ ) if ( binary [ i ] == '1' ) { count = max ( count , j - prev ) ; prev = j ; } return count ; } int main ( ) { string octal = \"13\" ; cout << maxFreq ( octal ) ; return 0 ; }"}
{"text": "Cari semua nombor utama nombor digit yang diberikan | C ++ pelaksanaan pendekatan; Fungsi untuk penapis eratosthenes; Berfungsi untuk mencetak semua nombor utama dengan digit D; Julat untuk memeriksa bilangan bulat; Untuk setiap integer dalam julat; Jika integer semasa adalah perdana; Kod pemacu; Menjana prima", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sz = 1e5 ; bool isPrime [ sz + 1 ] ; void sieve ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } } void findPrimesD ( int d ) { int left = pow ( 10 , d - 1 ) ; int right = pow ( 10 , d ) - 1 ; for ( int i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { cout << i << \" ▁ \" ; } } } int main ( ) { sieve ( ) ; int d = 1 ; findPrimesD ( d ) ; return 0 ; }"}
{"text": "Cari bilangan sel dalam jadual mengandungi x | Program C ++ untuk mencari bilangan sel dalam jadual mengandungi x; Fungsi untuk mencari bilangan sel dalam jadual mengandungi x; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; } int main ( ) { int n = 6 , x = 12 ; cout << ( Cells ( n , x ) ) ; return 0 ; }"}
{"text": "Cari nilai maksimum nilai minimum array yang diubah suai | Program CPP untuk mencari nilai maksimum nilai minimum array yang diubah suai; Berfungsi untuk mencari nilai maksimum nilai minimum array yang diubah suai; Untuk menyimpan nilai minimum array; Untuk menyimpan jumlah elemen array; Penyelesaian tidak mungkin; Zero adalah nilai yang mungkin; nilai minimum yang mungkin; nilai maksimum yang mungkin; untuk menyimpan jawapan yang diperlukan; Carian binari; Sekiranya pertengahan mungkin maka cuba tambah jawapan yang diperlukan; Jika pertengahan tidak mungkin maka penurunan jawapan yang diperlukan; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxOfMin ( int a [ ] , int n , int S ) { int mi = INT_MAX ; int s1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = min ( a [ i ] , mi ) ; } if ( s1 < S ) return -1 ; if ( s1 == S ) return 0 ; int low = 0 ; int high = mi ; int ans ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } int main ( ) { int a [ ] = { 10 , 10 , 10 , 10 , 10 } ; int S = 10 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxOfMin ( a , n , S ) ; return 0 ; }"}
{"text": "Program untuk mencetak 'n' abjad menggunakan corak nombor dari 1 hingga n | C ++ pelaksanaan pendekatan; Berfungsi untuk mencetak corak abjad n yang dikehendaki; Mengisytiharkan nilai -nilai hak, kiri dan pepenjuru; Gelung utama untuk baris; Untuk nilai kiri; Ruang untuk pepenjuru; Keadaan untuk pepenjuru; Ruang untuk nilai yang betul; Untuk nilai yang betul; Kod pemacu; Saiz corak; Memanggil fungsi untuk mencetak corak yang dikehendaki", "code": "#include <iostream> NEW_LINE using namespace std ; void Alphabet_N_Pattern ( int N ) { int index , side_index , size ; int Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { cout << Left ++ ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) cout << \" ▁ \" ; if ( index != 0 && index != N - 1 ) cout << Diagonal ++ ; else cout << \" ▁ \" ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) cout << \" ▁ \" ; cout << Right ++ ; cout << endl ; } } int main ( int argc , char * * argv ) { int Size = 6 ; Alphabet_N_Pattern ( Size ) ; }"}
{"text": "Semak jika jumlah digit nombor n membahagikannya | Program C ++ untuk memeriksa sama ada jumlah digit nombor membahagikannya; Berfungsi untuk memeriksa sama ada jumlah digit nombor membahagikannya; Hitung jumlah semua digit N; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int isSumDivides ( int N ) { int temp = N ; int sum = 0 ; while ( temp ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; } int main ( ) { int N = 12 ; if ( isSumDivides ( N ) ) cout << \" YES \" ; else cout << \" NO \" ; return 0 ; }"}
{"text": "Jumlah nombor dari 1 hingga N yang boleh dibahagikan dengan 3 atau 4 | Program C ++ untuk mencari jumlah nombor dari 1 hingga N yang boleh dibahagikan dengan 3 atau 4; Berfungsi untuk mengira jumlah nombor yang boleh dibahagi dengan 3 atau 4; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; } int main ( ) { int N = 20 ; cout << sum ( 12 ) ; return 0 ; }"}
{"text": "Seterusnya nombor yang lebih besar daripada n dengan betul -betul sedikit berbeza dalam perwakilan binari n | Program CPP untuk mencari nombor yang lebih besar daripada N dengan betul -betul sedikit berbeza dalam perwakilan binari N; Berfungsi untuk mencari nombor seterusnya yang lebih besar daripada n dengan tepat satu yang berbeza dalam perwakilan binari n; Ia dijamin bahawa terdapat sedikit sifar dalam nombor; Jika bit beralih adalah sifar maka pecah; meningkatkan peralihan sedikit; meningkatkan kuasa 2; Tetapkan bit paling rendah nombor; Kod pemacu; Paparkan nombor seterusnya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long nextGreater ( long long N ) { long long power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; } int main ( ) { long long N = 11 ; cout << \" The ▁ next ▁ number ▁ is ▁ = ▁ \" << nextGreater ( N ) ; return 0 ; }"}
{"text": "Mengira bilangan cara untuk menutup jarak | Tetapkan 2 | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan jumlah cara untuk menutup jarak dengan 1, 2 dan 3 langkah; Keadaan asas; Untuk menyimpan tiga peringkat terakhir; Cari bilangan langkah yang diperlukan untuk mencapai jarak i; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 , ans ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; } int main ( ) { int n = 4 ; cout << countWays ( n ) ; return 0 ; }"}
{"text": "Memaksimumkan jumlah dengan memilih unsur -unsur dari bahagian yang berbeza dari matriks | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari nilai maksimum; Jadual DP; Isi DP secara bawah; Maksimum tiga bahagian; Maksimum bahagian pertama; Maksimum bahagian kedua; Maksimum bahagian ketiga; Jika kita memilih elemen dari Bahagian 1, kita tidak boleh mempunyai pemilihan dari bahagian yang sama di baris bersebelahan; Cetak jumlah maksimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int n = 6 , m = 6 ; void maxSum ( long arr [ n ] [ m ] ) { long dp [ n + 1 ] [ 3 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { long m1 = 0 , m2 = 0 , m3 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( j / ( m / 3 ) ) == 0 ) { m1 = max ( m1 , arr [ i ] [ j ] ) ; } else if ( ( j / ( m / 3 ) ) == 1 ) { m2 = max ( m2 , arr [ i ] [ j ] ) ; } else if ( ( j / ( m / 3 ) ) == 2 ) { m3 = max ( m3 , arr [ i ] [ j ] ) ; } } dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; } cout << max ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) << ' ' ; } int main ( ) { long arr [ n ] [ m ] = { { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } } ; maxSum ( arr ) ; return 0 ; }"}
{"text": "Jumlah Bilangan Panjang Panjang Panjang Panjang | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari jumlah sub - urutan panjang palindromik - urutan; Array DP untuk menyimpan bilangan seterusnya Palindromic untuk 0 hingga I - 1 dan J + 1 hingga N - 1; Kami akan bermula dengan jarak terbesar antara i dan j; Untuk setiap len, kami menetapkan saya; Untuk ini saya akan dapati J kami; Kes asas; Jika watak -wataknya sama maka cari indeks terikat; Kami hanya mempunyai 1 cara yang hanya memilih watak -watak ini; Sekiranya watak tidak sama; Kurangkannya kerana kami telah mengira dua kali; Kami hanya mempunyai 1 urutan palindrome panjang 1; Jumlah cara yang lain adalah jumlah DP [i - 1] [i + 1], iaitu bilangan subindrome sub - urutan dari 1 hingga i - 1 + bilangan subindrome sub - urutan dari i + 1 hingga n - 1; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( string & s ) { int n = s . length ( ) ; int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof dp ) ; for ( int len = n - 1 ; len >= 0 ; -- len ) { for ( int i = 0 ; i + len < n ; ++ i ) { int j = i + len ; if ( i == 0 and j == n - 1 ) { if ( s [ i ] == s [ j ] ) dp [ i ] [ j ] = 2 ; else if ( s [ i ] != s [ j ] ) dp [ i ] [ j ] = 1 ; } else { if ( s [ i ] == s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 < 0 or j + 1 >= n ) { dp [ i ] [ j ] += 1 ; } } else if ( s [ i ] != s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 >= 0 and j + 1 <= n - 1 ) { dp [ i ] [ j ] -= dp [ i - 1 ] [ j + 1 ] ; } } } } } vector < int > ways ; for ( int i = 0 ; i < n ; ++ i ) { if ( i == 0 or i == n - 1 ) { ways . push_back ( 1 ) ; } else { int total = dp [ i - 1 ] [ i + 1 ] ; ways . push_back ( total ) ; } } for ( int i = 0 ; i < ways . size ( ) ; ++ i ) { cout << ways [ i ] << \" ▁ \" ; } } int main ( ) { string s = \" xyxyx \" ; solve ( s ) ; return 0 ; }"}
{"text": "Cari bilangan anak ayam di kebun binatang pada hari ke hari | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan anak ayam pada hari ke hari; Saiz DP [] harus sekurang -kurangnya 6 (pengindeksan berasaskan 1 (1); Setiap hari penduduk semasa akan menjadi tiga kali pada hari sebelumnya; Nilai yang dikira secara manual; Dari hari ke -8 dan seterusnya; Penduduk anak ayam berkurangan sebanyak 2/3 setiap hari. Untuk hari ke -8 pada [i - 6] i. Populasi hari ke -2 adalah 3 dan jadi 2 orang baru dilahirkan pada hari ke -6 dan sebagainya untuk hari -hari yang akan datang; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll getChicks ( int n ) { int size = max ( n , 7 ) ; ll dp [ size ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; } dp [ 7 ] = 726 ; for ( int i = 8 ; i <= n ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] / 3 ) ) * 3 ; } return dp [ n ] ; } int main ( ) { int n = 3 ; cout << getChicks ( n ) ; return 0 ; }"}
{"text": "Cari bilangan anak ayam di kebun binatang pada hari ke hari | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan anak ayam pada hari ke hari; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll getChicks ( int n ) { ll chicks = ( ll ) pow ( 3 , n - 1 ) ; return chicks ; } int main ( ) { int n = 3 ; cout << getChicks ( n ) ; return 0 ; }"}
{"text": "Cari langkah minimum yang diperlukan untuk mencapai akhir matriks | Tetapkan 2 | C ++ pelaksanaan pendekatan; Array 2d untuk menyimpan negeri -negeri DP; Array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Berfungsi untuk mengembalikan langkah minimum yang diperlukan; Kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula; Hubungan berulang; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE using namespace std ; int dp [ n ] [ n ] ; int v [ n ] [ n ] ; int minSteps ( int i , int j , int arr [ ] [ n ] ) { if ( i == n - 1 and j == n - 1 ) return 0 ; if ( i > n - 1 j > n - 1 ) return 9999999 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 9999999 ; for ( int k = max ( 0 , arr [ i ] [ j ] + j - n + 1 ) ; k <= min ( n - i - 1 , arr [ i ] [ j ] ) ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; } dp [ i ] [ j ] ++ ; return dp [ i ] [ j ] ; } int main ( ) { int arr [ n ] [ n ] = { { 4 , 1 , 2 } , { 1 , 1 , 1 } , { 2 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) cout << -1 ; else cout << ans ; return 0 ; }"}
{"text": "Cari langkah minimum yang diperlukan untuk mencapai akhir matriks | Set | Program C ++ untuk melaksanakan pendekatan di atas; Array 2d untuk menyimpan negeri -negeri DP; array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Berfungsi untuk mencari bilangan langkah minimum untuk mencapai akhir matriks; kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula. ; hubungan berulang; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE using namespace std ; int dp [ n ] [ n ] ; int v [ n ] [ n ] ; int minSteps ( int i , int j , int arr [ ] [ n ] ) { if ( i == n - 1 and j == n - 1 ) return 0 ; if ( i > n - 1 j > n - 1 ) return 9999999 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 1 + min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; return dp [ i ] [ j ] ; } int main ( ) { int arr [ n ] [ n ] = { { 2 , 1 , 2 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) cout << -1 ; else cout << ans ; return 0 ; }"}
{"text": "Treasure and Cities | Program berasaskan memoisasi untuk mencari harta maksimum yang boleh dikumpulkan. ; K ialah indeks semasa dan col adalah warna sebelumnya. ; jika (k == n) kes asas; jika (col == color [k]) periksa jika warna bandar ini sama dengan bandar yang dilawati sebelum ini; kembali maksimum kedua -dua pilihan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1001 ; int dp [ MAX ] [ MAX ] ; int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != -1 ) return dp [ k ] [ col ] ; int sum = 0 ; sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; } int main ( ) { int A = -5 , B = 7 ; int treasure [ ] = { 4 , 8 , 2 , 9 } ; int color [ ] = { 2 , 2 , 6 , 2 } ; int n = sizeof ( color ) / sizeof ( color [ 0 ] ) ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ; return 0 ; }"}
{"text": "Nombor Tetranacci | Program CPP berasaskan DP untuk mencetak nombor Tetranacci Nth; Berfungsi untuk mencetak nombor tetranacci N - th; kes asas; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int printTetra ( int n ) { int dp [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; cout << dp [ n ] ; } int main ( ) { int n = 10 ; printTetra ( n ) ; return 0 ; }"}
{"text": "Jumlah maksimum dalam array bulat supaya tiada dua elemen bersebelahan | Program CPP untuk mencari jumlah maksimum dalam pelbagai bulat supaya tiada unsur bersebelahan dengan jumlah. ; Fungsi untuk mengira jumlah dari kedudukan ke -0 ke (n - 2) kedudukan; Salin elemen array asal ke dp []; Cari elemen maksimum dalam array; Mulakan dari 2 nd hingga n - 1 th pos; melintasi semua pendekatan berpasangan bawah; DP - keadaan; Cari jumlah maksimum; mengembalikan maksimum; Berfungsi untuk mencari jumlah maksimum dari kedudukan 1 ke kedudukan n - 1 - th; Melintasi dari ketiga ke n - th pos; pendekatan bootom - up; keadaan DP; Cari jumlah maksimum; kembali max; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum1 ( int arr [ ] , int n ) { int dp [ n ] ; int maxi = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( int i = 2 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < dp [ j ] + arr [ i ] ) { dp [ i ] = dp [ j ] + arr [ i ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; } int maxSum2 ( int arr [ ] , int n ) { int dp [ n ] ; int maxi = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( int i = 3 ; i < n ; i ++ ) { for ( int j = 1 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < arr [ i ] + dp [ j ] ) { dp [ i ] = arr [ i ] + dp [ j ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; } int findMaxSum ( int arr [ ] , int n ) { return max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }"}
{"text": "Koefisien Permutasi | Penyelesaian O (n) yang menggunakan fakta jadual [] untuk mengira pekali permutasi; Pulangan nilai pekali permutasi p (n, k); Kes asas; Hitung faktorial nilai sehingga n; P (n, k) = n! / (n - k)! ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int permutationCoeff ( int n , int k ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; } int main ( ) { int n = 10 , k = 2 ; cout << \" Value ▁ of ▁ P ( \" << n << \" , ▁ \" << k << \" ) ▁ is ▁ \" << permutationCoeff ( n , k ) ; return 0 ; }"}
{"text": "Pengaturcaraan Dinamik | Penyelesaian rekursif untuk masalah jumlah subset; Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut: (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) cout << \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ; else cout << \" No ▁ subset ▁ with ▁ given ▁ sum \" ; return 0 ; }"}
{"text": "Count of Cyclic Permutations yang mempunyai XOR dengan rentetan binari lain sebagai 0 | Program C ++ untuk mencari bitwise xor antara rentetan binari a dan semua permutasi kitaran rentetan binari b; Pelaksanaan z - algoritma untuk corak corak masa linear; Berfungsi untuk mendapatkan kiraan permutasi kitaran B yang diberikan 0 apabila xored dengan a; Concatenate B dengan B; BARU B kini mengandungi semua permutasi kitaran Old B sebagai sub-string; corak concatenate dengan teks; Isi arus z yang digunakan dalam algoritma Z; Corak berlaku pada indeks i kerana nilai z sama dengan panjang corak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void compute_z ( string s , int z [ ] ) { int l = 0 , r = 0 ; int n = s . length ( ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( i > r ) { l = i , r = i ; while ( r < n && s [ r - l ] == s [ r ] ) r ++ ; z [ i ] = r - l ; r -- ; } else { int k = i - l ; if ( z [ k ] < r - i + 1 ) { z [ i ] = z [ k ] ; } else { l = i ; while ( r < n && s [ r - l ] == s [ r ] ) r ++ ; z [ i ] = r - l ; r -- ; } } } } int countPermutation ( string a , string b ) { b = b + b ; b = b . substr ( 0 , b . size ( ) - 1 ) ; int ans = 0 ; string s = a + \" $ \" + b ; int n = s . length ( ) ; int z [ n ] ; compute_z ( s , z ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( z [ i ] == a . length ( ) ) ans ++ ; } return ans ; } int main ( ) { string a = \"101\" ; string b = \"101\" ; cout << countPermutation ( a , b ) << endl ; return 0 ; }"}
{"text": "Lexicographically terkecil k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari saiz ksatria terkecil secara lexicographically K; Panjang rentetan; Menyimpan berikutnya minimum; Melintasi rentetan s; Sekiranya timbunan kosong; Melangkah sehingga watak semasa kurang daripada watak di bahagian atas timbunan; Semak jika terdapat watak yang cukup untuk mendapatkan panjang k; Jika saiz timbunan adalah <k; Tolak watak semasa ke dalamnya; Menyimpan rentetan yang dihasilkan; Berulang sehingga timbunan kosong; Membalikkan rentetan; Cetak rentetan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallestSubsequence ( string & S , int K ) { int N = S . size ( ) ; stack < char > answer ; for ( int i = 0 ; i < N ; ++ i ) { if ( answer . empty ( ) ) { answer . push ( S [ i ] ) ; } else { while ( ( ! answer . empty ( ) ) && ( S [ i ] < answer . top ( ) ) && ( answer . size ( ) - 1 + N - i >= K ) ) { answer . pop ( ) ; } if ( answer . empty ( ) || answer . size ( ) < K ) { answer . push ( S [ i ] ) ; } } } string ret ; while ( ! answer . empty ( ) ) { ret . push_back ( answer . top ( ) ) ; answer . pop ( ) ; } reverse ( ret . begin ( ) , ret . end ( ) ) ; cout << ret ; } int main ( ) { string S = \" aabdaabc \" ; int K = 3 ; smallestSubsequence ( S , K ) ; return 0 ; }"}
{"text": "Semak sama ada rentetan betul ke kiri pepenjuru atau tidak | Program C ++ untuk memeriksa sama ada rentetan yang diberikan adalah betul untuk kiri pepenjuru atau tidak; Fungsi untuk memeriksa sama ada rentetan yang diberikan adalah betul untuk kiri pepenjuru atau tidak; Melangkah ke atas rentetan; Jika watak tidak sama dengan watak pertama maka kembali palsu; Kod pemacu; Diberikan string str; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int is_rtol ( string s ) { int tmp = sqrt ( s . length ( ) ) - 1 ; char first = s [ tmp ] ; for ( int pos = tmp ; pos < s . length ( ) - 1 ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } } return true ; } int main ( ) { string str = \" abcxabxcaxbcxabc \" ; if ( is_rtol ( str ) ) { cout << \" Yes \" << endl ; } else { cout << \" No \" << endl ; } return 0 ; }"}
{"text": "Pecahkan rentetan yang diberikan ke dalam substrings panjang k dengan jumlah nilai ASCII yang sama | Program C ++ untuk memeriksa sama ada rentetan yang diberikan boleh dibahagikan kepada substring saiz K yang mempunyai jumlah nilai ASCII yang sama. ; Fungsi untuk memeriksa rentetan; Semak sama ada rentetan boleh dibahagikan kepada substrings panjang K panjang sahaja; Kirakan jumlah substring pertama panjang k; Kirakan jumlah substrings yang tinggal; Semak sama ada jumlahnya sama dengan substring pertama; Oleh kerana semua jumlah tidak sama, kembali palsu; Semua jumlah adalah sama, kembali benar; Semua substrings tidak boleh bersaiz k; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string str , int K ) { if ( str . size ( ) % K == 0 ) { int sum = 0 , i ; for ( i = 0 ; i < K ; i ++ ) { sum += str [ i ] ; } for ( int j = i ; j < str . size ( ) ; j += K ) { int s_comp = 0 ; for ( int p = j ; p < j + K ; p ++ ) s_comp += str [ p ] ; if ( s_comp != sum ) return false ; } return true ; } return false ; } int main ( ) { int K = 3 ; string str = \" abdcbbdba \" ; if ( check ( str , K ) ) cout << \" YES \" << endl ; else cout << \" NO \" << endl ; }"}
{"text": "Memaksimumkan kiraan 0 s di kiri dan 1 s dalam substring kanan dengan memisahkan rentetan binari yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk memaksimumkan jumlah kiraan sifar dan yang di dalam substring kiri dan kanan; Untuk menyimpan jumlahnya; Kira jumlah yang ada dalam string str; Untuk menyimpan kiraan sifar dan yang melintasi rentetan; Melepasi rentetan yang diberikan dan kemas kini jumlah maksimum; Mengemas kini jumlah maksimum; Kod pemacu; Diberikan rentetan binari; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( string & str ) { int maximumSum = 0 ; int totalOnes ; totalOnes = count ( str . begin ( ) , str . end ( ) , '1' ) ; int zero = 0 , ones = 0 ; for ( int i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == '0' ) { zero ++ ; } else { ones ++ ; } maximumSum = max ( maximumSum , zero + ( totalOnes - ones ) ) ; } return maximumSum ; } int main ( ) { string str = \"011101\" ; cout << maxSum ( str ) ; return 0 ; }"}
{"text": "Substring terpanjang supaya tidak ada tiga aksara berturut -turut yang sama | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan panjang substring terpanjang sehingga tiada tiga aksara berturut -turut adalah sama; Jika panjang rentetan yang diberikan kurang daripada 3; Inisialisasi ANS sementara dan akhir hingga 2 kerana ini adalah panjang minimum substring apabila panjang rentetan yang diberikan lebih besar daripada 2; Melintasi rentetan dari watak ketiga ke yang terakhir; Jika tiada tiga aksara berturut -turut adalah sama maka kenaikan sementara sementara; Lain mengemas kini Ans akhir dan menetapkan semula kiraan sementara; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLenSubStr ( string & s ) { if ( s . length ( ) < 3 ) return s . length ( ) ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = max ( temp , ans ) ; temp = 2 ; } } ans = max ( temp , ans ) ; return ans ; } int main ( ) { string s = \" baaabbabbb \" ; cout << maxLenSubStr ( s ) ; return 0 ; }"}
{"text": "Bilangan cara untuk mengeluarkan sub | Program C ++ untuk mengira bilangan cara untuk mengeluarkan substring dari rentetan supaya semua aksara yang tinggal adalah sama; Fungsi untuk mengembalikan bilangan cara mengeluarkan sub -rentetan dari S sedemikian rupa sehingga semua aksara yang tinggal adalah sama; Untuk menyimpan kiraan awalan dan akhiran; Gelung untuk mengira awalan; Gelung untuk mengira akhiran; Watak pertama dan terakhir rentetan adalah sama; Jika tidak; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int no_of_ways ( string s ) { int n = s . length ( ) ; int count_left = 0 , count_right = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == s [ 0 ] ) { ++ count_left ; } else break ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == s [ n - 1 ] ) { ++ count_right ; } else break ; } if ( s [ 0 ] == s [ n - 1 ] ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; } int main ( ) { string s = \" geeksforgeeks \" ; cout << no_of_ways ( s ) ; return 0 ; }"}
{"text": "Kira bilangan indeks seperti S [i] = s [i + 1]: pertanyaan pelbagai | Program C ++ untuk mencari substring dengan; Fungsi untuk membuat array awalan; Berfungsi untuk mengembalikan hasil pertanyaan; Kod pemacu; Pertanyaan 1; Pertanyaan 2", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void preCompute ( int n , string s , int pref [ ] ) { pref [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { pref [ i ] = pref [ i - 1 ] ; if ( s [ i - 1 ] == s [ i ] ) pref [ i ] ++ ; } } int query ( int pref [ ] , int l , int r ) { return pref [ r ] - pref [ l ] ; } int main ( ) { string s = \" ggggggg \" ; int n = s . length ( ) ; int pref [ n ] ; preCompute ( n , s , pref ) ; int l = 1 ; int r = 2 ; cout << query ( pref , l , r ) << endl ; l = 1 ; r = 5 ; cout << query ( pref , l , r ) << endl ; return 0 ; }"}
{"text": "Cari arah dari rentetan yang diberikan | Pelaksanaan CPP pendekatan di atas; Berfungsi untuk mencari arah akhir; Sekiranya kiraan positif yang membayangkan hasilnya adalah arah arah jam; Sekiranya kiraan negatif yang membayangkan hasilnya adalah arah anti jam; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string findDirection ( string s ) { int count = 0 ; string d = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ 0 ] == ' ' ) return NULL ; if ( s [ i ] == ' L ' ) count -- ; else { if ( s [ i ] == ' R ' ) count ++ ; } } if ( count > 0 ) { if ( count % 4 == 0 ) d = \" N \" ; else if ( count % 4 == 1 ) d = \" E \" ; else if ( count % 4 == 2 ) d = \" S \" ; else if ( count % 4 == 3 ) d = \" W \" ; } if ( count < 0 ) { if ( count % 4 == 0 ) d = \" N \" ; else if ( count % 4 == -1 ) d = \" W \" ; else if ( count % 4 == -2 ) d = \" S \" ; else if ( count % 4 == -3 ) d = \" E \" ; } return d ; } int main ( ) { string s = \" LLRLRRL \" ; cout << ( findDirection ( s ) ) << endl ; s = \" LL \" ; cout << ( findDirection ( s ) ) << endl ; }"}
{"text": "Semak jika huruf kecil dan huruf besar berada dalam susunan yang sama | Program C ++ untuk memeriksa sama ada huruf kecil dan huruf besar berada dalam urutan yang sama; Fungsi untuk memeriksa sama ada kes itu mengikuti perintah yang sama; Melintasi rentetan; Simpan kedua -dua huruf kecil dan huruf besar dalam dua rentetan yang berbeza; menggunakan fungsi transform () dan :: toupper di STL; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCheck ( string str ) { int len = str . length ( ) ; string lowerStr = \" \" , upperStr = \" \" ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] >= 65 && str [ i ] <= 91 ) upperStr = upperStr + str [ i ] ; else lowerStr = lowerStr + str [ i ] ; } transform ( lowerStr . begin ( ) , lowerStr . end ( ) , lowerStr . begin ( ) , :: toupper ) ; return lowerStr == upperStr ; } int main ( ) { string str = \" geeGkEEsKS \" ; isCheck ( str ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }"}
{"text": "Gantikan setiap watak rentetan oleh watak yang nilai ASCII adalah k kali lebih daripada itu | Program CPP untuk memindahkan setiap watak K kali ke hadapan dalam rentetan yang diberikan; Berfungsi untuk memindahkan watak rentetan; rentetan berubah; berulang untuk setiap aksara; Nilai ASCII; Simpan pendua; jika k - th ke depan watak melebihi 'z'; Cetak rentetan baru; kod pemacu; panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void encode ( string s , int k ) { string newS ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { int val = int ( s [ i ] ) ; int dup = k ; if ( val + k > 122 ) { k -= ( 122 - val ) ; k = k % 26 ; newS += char ( 96 + k ) ; } else newS += char ( val + k ) ; k = dup ; } cout << newS ; } int main ( ) { string str = \" abc \" ; int k = 28 ; encode ( str , k ) ; return 0 ; }"}
{"text": "Ubah suai rentetan dengan mengeluarkan vokal di antara dua konsonan | Program C ++ untuk menghapuskan semua vokal di antara dua konsonan dari rentetan; Fungsi untuk memeriksa sama ada watak x adalah vokal atau tidak; Mengembalikan rentetan yang dikemas kini yang dibentuk selepas mengeluarkan semua vokal sandwich dari rentetan yang diberikan; rentetan untuk menyimpan rentetan yang dikemas kini selepas mengeluarkan vokal yang diapit; melintasi rentetan dari kiri ke kanan; Sekiranya watak semasa adalah watak pertama atau terakhir rentetan itu, ini perlu dilampirkan kepada yang dikemas kini, kerana abjad sudut tanpa mengira ia menjadi vokal atau konsonan, tidak pernah 'diapit'; Semak sama ada watak semasa rentetan adalah vokal dan kedua -dua watak -watak terdahulu dan seterusnya adalah konsonan, jika demikian maka ini adalah vokal yang diapit, dengan itu diabaikan dan tidak dilampirkan pada rentetan yang dikemas kini; Jika watak ini bukan vokal yang diapit masuk ke rentetan yang dikemas kini; Kod pemacu; Keluarkan semua vokal sandwitched", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char x ) { if ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) return true ; else return false ; } string updateSandwichedVowels ( string a ) { int n = a . length ( ) ; string updatedString = \" \" ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! i i == n - 1 ) { updatedString += a [ i ] ; continue ; } if ( isVowel ( a [ i ] ) && ! isVowel ( a [ i - 1 ] ) && ! isVowel ( a [ i + 1 ] ) ) { continue ; } updatedString += a [ i ] ; } return updatedString ; } int main ( ) { string str = \" geeksforgeeks \" ; string updatedString = updateSandwichedVowels ( str ) ; cout << updatedString ; return 0 ; }"}
{"text": "Cetak semua laluan pokok binari dengan elemen maksimum dalam setiap laluan yang lebih besar daripada atau sama dengan k | Program C ++ untuk mencetak laluan dengan elemen maksimum di jalan yang lebih besar daripada k; Nod pokok binari; Fungsi utiliti untuk membuat nod baru; Fungsi rekursif untuk mencetak laluan yang elemen maksimumnya lebih besar daripada atau sama dengan k. ; Jika nilai nod semasa lebih besar daripada atau sama dengan k, maka semua subtrees berikutan nod tersebut akan dicetak, bendera = 1 menunjukkan untuk mencetak jalan yang diperlukan; Jika nod daun ditemui, maka jalan dicetak jika saiz vektor laluan lebih besar daripada 0; Tambah nod ke vektor jalan; Mengulangi subtrees kiri dan kanan; Backtracking untuk mengembalikan vektor dan mencetak jalan jika bendera adalah 1; Fungsi untuk memulakan pembolehubah dan panggil fungsi utiliti untuk mencetak laluan dengan nilai maksimum lebih besar daripada atau sama dengan k; Memulakan bendera; Ans digunakan untuk memeriksa keadaan kosong; Fungsi panggilan yang mencetak jalan; Sekiranya jalan tidak wujud; Kod pemacu; Membina pokok berikut: 10 / \\ 5 8 / \\ / \\ 29 2 1 98 / \\ 20 50", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * newNode = new Node ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return ( newNode ) ; } void findPathUtil ( Node * root , int k , vector < int > path , int flag , int & ans ) { if ( root == NULL ) return ; if ( root -> data >= k ) flag = 1 ; if ( root -> left == NULL && root -> right == NULL ) { if ( flag == 1 ) { ans = 1 ; cout << \" ( \" ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { cout << path [ i ] << \" , ▁ \" ; } cout << root -> data << \" ) , ▁ \" ; } return ; } path . push_back ( root -> data ) ; findPathUtil ( root -> left , k , path , flag , ans ) ; findPathUtil ( root -> right , k , path , flag , ans ) ; path . pop_back ( ) ; } void findPath ( Node * root , int k ) { int flag = 0 ; int ans = 0 ; vector < int > v ; findPathUtil ( root , k , v , flag , ans ) ; if ( ans == 0 ) cout << \" - 1\" ; } int main ( void ) { int K = 25 ; struct Node * root = newNode ( 10 ) ; root -> left = newNode ( 5 ) ; root -> right = newNode ( 8 ) ; root -> left -> left = newNode ( 29 ) ; root -> left -> right = newNode ( 2 ) ; root -> right -> right = newNode ( 98 ) ; root -> right -> left = newNode ( 1 ) ; root -> right -> right -> right = newNode ( 50 ) ; root -> left -> left -> left = newNode ( 20 ) ; findPath ( root , K ) ; return 0 ; }"}
{"text": "Nombor TrideCagonal | Program C ++ untuk mencari nombor tridecagonal N; Berfungsi untuk mencari nombor tridekagonal; Formula untuk mengira nombor tridecagonal nth; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Tridecagonal_num ( int n ) { return ( 11 * n * n - 9 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Tridecagonal_num ( n ) << endl ; n = 10 ; cout << Tridecagonal_num ( n ) << endl ; return 0 ; }"}
{"text": "Semak jika pokok binari yang diberikan adalah timbunan | Program C ++ untuk memeriksa jika pokok binari adalah timbunan maksimum atau tidak; Struktur nod pokok; Untuk menambah nod baru; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int k ) { struct Node * node = new Node ; node -> data = k ; node -> right = node -> left = NULL ; return node ; } bool isHeap ( Node * root ) { queue < Node * > q ; q . push ( root ) ; bool nullish = false ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left ) { if ( nullish temp -> left -> data > = temp -> data ) { return false ; } q . push ( temp -> left ) ; } else { nullish = true ; } if ( temp -> right ) { if ( nullish temp -> right -> data > = temp -> data ) { return false ; } q . push ( temp -> right ) ; } else { nullish = true ; } } return true ; } int main ( ) { struct Node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( 9 ) ; root -> right = newNode ( 8 ) ; root -> left -> left = newNode ( 7 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 4 ) ; root -> left -> left -> left = newNode ( 3 ) ; root -> left -> left -> right = newNode ( 2 ) ; root -> left -> right -> left = newNode ( 1 ) ; if ( isHeap ( root ) ) cout << \" Given ▁ binary ▁ tree ▁ is ▁ a ▁ Heap STRNEWLINE \" ; else cout << \" Given ▁ binary ▁ tree ▁ is ▁ not ▁ a ▁ Heap STRNEWLINE \" ; return 0 ; }"}
{"text": "Bilangan bilangan bulat n digit dengan berat w | Program CPP untuk mencari jumlah nombor yang mungkin dengan digit dan berat w; Berfungsi untuk mencari jumlah nombor yang mungkin dengan digit dan berat w; Apabila berat integer positif; Tolak berat dari 9; Apabila berat integer adalah negatif; Tambah berat badan kepada 10 untuk menjadikannya positif; Kod pemacu; bilangan digit dalam integer dan w sebagai berat; Cetak jumlah nombor yang mungkin dengan N digit dan berat w", "code": "#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; int findNumbers ( int n , int w ) { int x = 0 , sum = 0 ; if ( w >= 0 && w <= 8 ) { x = 9 - w ; } else if ( w >= -9 && w <= -1 ) { x = 10 + w ; } sum = pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; } int main ( ) { int n , w ; n = 3 , w = 4 ; cout << findNumbers ( n , w ) ; ; return 0 ; }"}
{"text": "Ketinggian maksimum susunan segi tiga nilai array | Program C ++ untuk mencari ketinggian maksimum susunan piramida nilai array; Hanya memeriksa sama ada tahap ith mungkin atau tidak jika mungkin maka kita mesti mempunyai atleast (i * (i + 1)) / 2 elemen dalam array; mengemas kini nilai hasil setiap kali; Jika tidak, kita telah melebihi nilai n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaximumHeight ( int a [ ] , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { long long y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; } int main ( ) { int arr [ ] = { 40 , 100 , 20 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MaximumHeight ( arr , n ) ; return 0 ; }"}
{"text": "K | Program CPP untuk mencari elemen k - Th dalam urutan ganjil - walaupun. ; Masukkan semua nombor ganjil dari 1 hingga n. ; Masukkan semua nombor dari 1 hingga n. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findK ( int n , int k ) { vector < long > a ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push_back ( i ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push_back ( i ) ; return ( a [ k - 1 ] ) ; } int main ( ) { long n = 10 , k = 3 ; cout << findK ( n , k ) << endl ; return 0 ; }"}
{"text": "Satu fungsi baris untuk faktorial nombor | Program C ++ untuk mencari faktorial nombor yang diberikan; Baris tunggal untuk mencari faktorial; Kod pemacu", "code": "#include <iostream> NEW_LINE int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; printf ( \" Factorial ▁ of ▁ % d ▁ is ▁ % d \" , num , factorial ( num ) ) ; return 0 ; }"}
{"text": "Nombor Pell | Siri nombor Pell Iterative dalam C ++; Hitung nombor pell; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c , i ; for ( i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; } int main ( ) { int n = 4 ; cout << pell ( n ) ; return 0 ; }"}
{"text": "Cara yang cekap untuk memeriksa sama ada N | Program C ++ yang mudah untuk memeriksa sama ada nombor N - TH Fibonacci adalah pelbagai daripada 10 .; Pulangan benar jika nombor fibonacci n - th adalah berganda dari 10 .; fungsi utama", "code": "#include <bits/stdc++.h> NEW_LINE bool isMultipleOf10 ( int n ) { return ( n % 15 == 0 ) ; } int main ( ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) printf ( \" Yes STRNEWLINE \" ) ; else printf ( \" No STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Cari kesopanan nombor | C + program untuk mencari kesopanan nombor; Fungsi untuk mengira semua faktor utama ganjil nombor n; Menghapuskan semua faktor utama bilangan n; n mesti ganjil pada ketika ini, jadi berulang hanya untuk nombor ganjil sehingga sqrt (n); Jika saya membahagikan N, maka mula mengira pembahagi ganjil; Jika n yang ganjil masih kekal maka hitungnya; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; int countOddPrimeFactors ( int n ) { int result = 1 ; while ( n % 2 == 0 ) n /= 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { int divCount = 0 ; while ( n % i == 0 ) { n /= i ; ++ divCount ; } result *= divCount + 1 ; } if ( n > 2 ) result *= 2 ; return result ; } int politness ( int n ) { return countOddPrimeFactors ( n ) - 1 ; } int main ( ) { int n = 90 ; cout << \" Politness ▁ of ▁ \" << n << \" ▁ = ▁ \" << politness ( n ) << \" STRNEWLINE \" ; n = 15 ; cout << \" Politness ▁ of ▁ \" << n << \" ▁ = ▁ \" << politness ( n ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Perdana terdekat yang kurang daripada bilangan N | Program C ++ untuk mencari perdana terdekat kepada n. ; array untuk menyimpan semua prima kurang daripada 10 ^ 6; Fungsi utiliti penapis Sundaram; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x; Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j; menghapuskan indeks yang tidak menghasilkan prima; Oleh kerana 2 adalah nombor perdana; Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Carian binari yang diubah suai untuk mencari perdana terdekat kurang daripada n; Keadaan asas adalah, jika kita sampai di sudut kiri atau sudut kanan prima [] array kemudian kembali elemen sudut kerana sebelum atau selepas itu kita tidak mempunyai sebarang nombor utama dalam array prima; Sekarang jika N sendiri menjadi perdana jadi ia akan hadir dalam pelbagai prima dan di sini kita perlu mencari perdana terdekat yang kurang daripada n supaya kita akan mengembalikan prima [pertengahan - 1]; Sekarang jika prima [pertengahan] <n dan prima [pertengahan + 1]> n Itu bermakna kita sampai pada perdana terdekat; Program pemacu untuk menjalankan kes itu", "code": "#include <bits/stdc++.h> NEW_LINE #define MAX  1000000 NEW_LINE using namespace std ; vector < int > primes ; void Sieve ( ) { int n = MAX ; int nNew = sqrt ( n ) ; int marked [ n / 2 + 500 ] = { 0 } ; for ( int i = 1 ; i <= ( nNew - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= n / 2 ; j = j + 2 * i + 1 ) marked [ j ] = 1 ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( marked [ i ] == 0 ) primes . push_back ( 2 * i + 1 ) ; } int binarySearch ( int left , int right , int n ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( mid == 0 || mid == primes . size ( ) - 1 ) return primes [ mid ] ; if ( primes [ mid ] == n ) return primes [ mid - 1 ] ; if ( primes [ mid ] < n && primes [ mid + 1 ] > n ) return primes [ mid ] ; if ( n < primes [ mid ] ) return binarySearch ( left , mid - 1 , n ) ; else return binarySearch ( mid + 1 , right , n ) ; } return 0 ; } int main ( ) { Sieve ( ) ; int n = 17 ; cout << binarySearch ( 0 , primes . size ( ) - 1 , n ) ; return 0 ; }"}
{"text": "Program untuk faktorial nombor | Program C ++ untuk mencari faktorial nombor yang diberikan; fungsi untuk mencari faktorial nombor yang diberikan; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; cout << \" Factorial ▁ of ▁ \" << num << \" ▁ is ▁ \" << factorial ( num ) << endl ; return 0 ; }"}
{"text": "Matikan Bit Set Bit | Tetapkan 2 | Program C ++ untuk menyegarkan bit set paling kanan; Tidak menetapkan bit set yang paling kanan dan mengembalikan hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int FlipBits ( unsigned int n ) { return n -= ( n & ( - n ) ) ; } int main ( ) { int N = 12 ; cout << \" The ▁ number ▁ after ▁ unsetting ▁ the \" ; cout << \" ▁ rightmost ▁ set ▁ bit : ▁ \" << FlipBits ( N ) ; return 0 ; }"}
{"text": "Nilai maksimum XOR di antara semua tiga kali ganda array | C ++ pelaksanaan pendekatan; berfungsi untuk mengira nilai XOR maksimum untuk triplet; Set digunakan untuk mengelakkan pengulangan; Simpan semua kemungkinan nilai XOR yang unik; menyimpan nilai maksimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Maximum_xor_Triplet ( int n , int a [ ] ) { set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { s . insert ( a [ i ] ^ a [ j ] ) ; } } int ans = 0 ; for ( auto i : s ) { for ( int j = 0 ; j < n ; j ++ ) { ans = max ( ans , i ^ a [ j ] ) ; } } cout << ans << \" STRNEWLINE \" ; } int main ( ) { int a [ ] = { 1 , 3 , 8 , 15 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; Maximum_xor_Triplet ( n , a ) ; return 0 ; }"}
{"text": "Cari unsur -unsur yang hilang dari julat | Program C ++ berasaskan penyortiran untuk mencari elemen yang hilang dari array; Cetak semua elemen julat [rendah, tinggi] yang tidak hadir dalam arr [0 .. n - 1]; Lakukan pencarian binari untuk 'rendah' ​​dalam array yang disusun dan cari indeks elemen pertama yang sama sama dengan atau lebih besar daripada rendah. ; Mulakan dari indeks yang dijumpai dan cari secara linear setiap elemen julat x selepas indeks ini di arr []; Jika x tidak matematik dengan elemen semasa mencetaknya; Jika x sepadan, pindah ke elemen seterusnya dalam arr []; Bergerak ke elemen seterusnya dalam julat [rendah, tinggi]; Elemen pelbagai cetak thar lebih besar daripada elemen terakhir array yang disusun. ; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { sort ( arr , arr + n ) ; int * ptr = lower_bound ( arr , arr + n , low ) ; int index = ptr - arr ; int i = index , x = low ; while ( i < n && x <= high ) { if ( arr [ i ] != x ) cout << x << \" ▁ \" ; else i ++ ; x ++ ; } while ( x <= high ) cout << x ++ << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }"}
{"text": "Cari unsur -unsur yang hilang dari julat | Program C ++ berasaskan array untuk mencari unsur -unsur yang hilang dari array; Cetak semua elemen julat [rendah, tinggi] yang tidak hadir dalam arr [0 .. n - 1]; Buat pelbagai boolean saiz tinggi - rendah + 1, setiap indeks yang saya mewakili elemen (i + rendah) yang dijumpai atau tidak. ; Sekiranya elemen ARR berada dalam jarak rendah hingga tinggi maka tandakan indeks yang sepadan sebagai benar dalam array; Melintasi julat dan mencetak semua elemen yang nilainya palsu; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { bool points_of_range [ high - low + 1 ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) { if ( low <= arr [ i ] && arr [ i ] <= high ) points_of_range [ arr [ i ] - low ] = true ; } for ( int x = 0 ; x <= high - low ; x ++ ) { if ( points_of_range [ x ] == false ) cout << low + x << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }"}
{"text": "Cari unsur -unsur yang hilang dari julat | Program C ++ berasaskan hashing untuk mencari unsur -unsur yang hilang dari array; Cetak semua elemen julat [rendah, tinggi] yang tidak hadir dalam arr [0 .. n - 1]; Masukkan semua elemen ARR [] dalam set; Melintasi julat cetak semua elemen yang hilang; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; for ( int x = low ; x <= high ; x ++ ) if ( s . find ( x ) == s . end ( ) ) cout << x << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }"}
{"text": "K | Program C ++ untuk mencari elemen K - Th yang hilang dalam urutan yang diberikan; Mengembalikan elemen k - yang hilang. Ia kembali - 1 jika tiada k adalah lebih daripada bilangan elemen yang hilang. ; Masukkan semua elemen urutan Givens B []. ; Melintasi urutan yang semakin meningkat dan menjejaki jumlah nombor yang hilang. ; program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { unordered_set < int > s ; for ( int i = 0 ; i < n2 ; i ++ ) s . insert ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return -1 ; } int main ( ) { int a [ ] = { 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 } ; int b [ ] = { 4 , 10 , 6 , 8 , 12 } ; int n1 = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int n2 = sizeof ( b ) / sizeof ( b [ 0 ] ) ; int k = 3 ; cout << find ( a , b , k , n1 , n2 ) ; return 0 ; }"}
{"text": "Kurangkan langkah -langkah untuk membentuk rentetan s dari rentetan rawak panjang K menggunakan Panjang Tetap Panjang | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum rentetan yang diperlukan untuk menjana rentetan asal; Menyimpan kekerapan setiap watak rentetan s; Melangkah ke atas julat [0, 25]; Menyimpan kekerapan setiap watak rentetan s; Mengira watak yang unik dalam s; Jika watak unik lebih besar maka n, maka kembali - 1; Jika tidak; Melakukan carian binari; Cari nilai pertengahan; Melangkah ke atas julat [0, 26]; Jika jumlah [i] lebih besar daripada 0; Mengemas kini julat; Cari rentetan yang dihasilkan; Menjana berikutnya; Jika panjang rentetan hasil kurang daripada N daripada menambah watak 'A'; Cetak rentetan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findString ( string S , int N ) { int amounts [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { amounts [ i ] = 0 ; } for ( int i = 0 ; i < S . length ( ) ; i ++ ) { amounts [ int ( S [ i ] ) - 97 ] ++ ; } int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) count ++ ; } if ( count > N ) { cout << \" - 1\" ; } else { string ans = \" \" ; int high = 100001 ; int low = 0 ; int mid , total ; while ( ( high - low ) > 1 ) { total = 0 ; mid = ( high + low ) / 2 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) / mid + 1 ; } } if ( total <= N ) { high = mid ; } else { low = mid ; } } cout << high << \" ▁ \" ; total = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) / high + 1 ; for ( int j = 0 ; j < ( ( amounts [ i ] - 1 ) / high + 1 ) ; j ++ ) { ans += char ( i + 97 ) ; } } } for ( int i = total ; i < N ; i ++ ) { ans += ' a ' ; } reverse ( ans . begin ( ) , ans . end ( ) ) ; cout << ans ; } } int main ( ) { string S = \" toffee \" ; int K = 4 ; findString ( S , K ) ; return 0 ; }"}
{"text": "Cari elemen berulang pertama dalam pelbagai integer | Program C ++ untuk mencari elemen berulang pertama dalam ARR []; Fungsi ini mencetak elemen berulang pertama dalam arr []; Memulakan indeks elemen berulang pertama; Mewujudkan hashset kosong; Melintasi array input dari kanan ke kiri; Jika elemen sudah ada dalam hash set, kemas kini min; Lain tambah elemen ke hash set; Cetak hasilnya; Kaedah pemacu untuk menguji kaedah di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFirstRepeating ( int arr [ ] , int n ) { int min = -1 ; set < int > myset ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( myset . find ( arr [ i ] ) != myset . end ( ) ) min = i ; else myset . insert ( arr [ i ] ) ; } if ( min != -1 ) cout << \" The ▁ first ▁ repeating ▁ element ▁ is ▁ \" << arr [ min ] ; else cout << \" There ▁ are ▁ no ▁ repeating ▁ elements \" ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printFirstRepeating ( arr , n ) ; }"}
{"text": "Cari elemen berulang pertama dalam pelbagai integer | Program C ++ untuk mencari elemen berulang pertama dalam ARR []; Fungsi ini mencetak elemen berulang pertama dalam arr []; Ini akan menetapkan k = 1, jika ada elemen berulang yang dijumpai; max = maksimum dari (semua elemen & n); Array A adalah untuk menyimpan 1 masa yang berlaku pada elemen yang diasaskan oleh 0; Simpan 1 dalam array b Jika elemen adalah pendua yang diasaskan oleh 0; Elemen pendua yang dijumpai; menyimpan 1 st kejadian arr [i]; Trace Array A & Cari Elemen Berulang dengan Min Index; Kaedah pemacu untuk menguji kaedah di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFirstRepeating ( int arr [ ] , int n ) { int k = 0 ; int max = n ; for ( int i = 0 ; i < n ; i ++ ) if ( max < arr [ i ] ) max = arr [ i ] ; int a [ max + 1 ] = { } ; int b [ max + 1 ] = { } ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ arr [ i ] ] ) { b [ arr [ i ] ] = 1 ; k = 1 ; continue ; } else a [ arr [ i ] ] = i ; } if ( k == 0 ) cout << \" No ▁ repeating ▁ element ▁ found \" << endl ; else { int min = max + 1 ; for ( int i = 0 ; i < max + 1 ; i ++ ) if ( a [ i ] && min > a [ i ] && b [ i ] ) min = a [ i ] ; cout << arr [ min ] ; } cout << endl ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printFirstRepeating ( arr , n ) ; }"}
{"text": "K | Program C ++ untuk mencetak elemen yang berbeza dalam array yang diberikan; Mengembalikan elemen yang berbeza dalam arr. ; Semak jika elemen semasa hadir di tempat lain. ; Jika elemen adalah unik; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return -1 ; } int main ( ) { int ar [ ] = { 1 , 2 , 1 , 3 , 4 , 2 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; int k = 2 ; cout << printKDistinct ( ar , n , k ) ; return 0 ; }"}
{"text": "Count Subarrays mempunyai kiraan yang sama dengan 0 dan 1 S berasal | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira subarray yang mempunyai kiraan yang sama dengan 0 s dan 1 s dengan semua 0 s dan semua 1 dikelompokkan bersama; Menyimpan kiraan; Memulakan CUR dengan elemen pertama; Jika elemen seterusnya adalah sama dengan elemen semasa; Kiraan kenaikan; Kemas kini curr; Melangkah ke atas kiraan array; Pertimbangkan minimum; Kod pemacu; Diberikan arr []; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubarrays ( int A [ ] , int N ) { int res = 0 ; int curr = A [ 0 ] ; vector < int > cnt = { 1 } ; for ( int c = 1 ; c < N ; c ++ ) { if ( A == curr ) cnt [ cnt . size ( ) - 1 ] ++ ; else curr = A ; cnt . push_back ( 1 ) ; } for ( int i = 1 ; i < cnt . size ( ) ; i ++ ) { res += min ( cnt [ i - 1 ] , cnt [ i ] ) ; } cout << ( res - 1 ) ; } int main ( ) { int A [ ] = { 1 , 1 , 0 , 0 , 1 , 0 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; countSubarrays ( A , N ) ; return 0 ; }"}
{"text": "Semak jika pokok binari adalah walaupun | Program C ++ untuk pendekatan di atas; Nod pokok; Berfungsi untuk mengembalikan nod pokok baru; Berfungsi untuk memeriksa sama ada pokok itu - pokok ganjil; Menyimpan nod setiap peringkat; Simpan tahap semasa pokok binari; Melintasi sehingga barisan kosong; Menyimpan bilangan nod yang terdapat di peringkat semasa; Semak sama ada tahapnya atau ganjil; Tambah nod tahap seterusnya ke dalam barisan; Meningkatkan kiraan tahap; Kod pemacu; Membina pokok binari; Periksa sama ada pokok binari itu - pokok ganjil atau tidak", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int val ; Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * temp = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; temp -> val = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } bool isEvenOddBinaryTree ( Node * root ) { if ( root == NULL ) return true ; queue < Node * > q ; q . push ( root ) ; int level = 0 ; while ( ! q . empty ( ) ) { int size = q . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Node * node = q . front ( ) ; if ( level % 2 == 0 ) { if ( node -> val % 2 == 1 ) return false ; } else if ( level % 2 == 1 ) { if ( node -> val % 2 == 0 ) return true ; } if ( node -> left != NULL ) { q . push ( node -> left ) ; } if ( node -> right != NULL ) { q . push ( node -> right ) ; } } level ++ ; } return true ; } int main ( ) { Node * root = NULL ; root = newNode ( 2 ) ; root -> left = newNode ( 3 ) ; root -> right = newNode ( 9 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 10 ) ; root -> right -> right = newNode ( 6 ) ; if ( isEvenOddBinaryTree ( root ) ) cout << \" YES \" ; else cout << \" NO \" ; }"}
{"text": "Memaksimumkan jarak minimum antara pengulangan dari sebarang permutasi array yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Saiz array; Menyimpan kekerapan elemen array; Cari kekerapan tertinggi dalam array; Meningkatkan kiraan elemen maksimum; Sekiranya tiada pengulangan hadir; Cari jarak maksimum; Mengembalikan jarak maksimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxLen ( vector < int > & a ) { int n = a . size ( ) ; int freq [ n + 1 ] ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < n ; ++ i ) { freq [ a [ i ] ] ++ ; } int maxFreqElement = INT_MIN ; int maxFreqCount = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( freq [ i ] > maxFreqElement ) { maxFreqElement = freq [ i ] ; maxFreqCount = 1 ; } else if ( freq [ i ] == maxFreqElement ) maxFreqCount ++ ; } int ans ; if ( maxFreqElement == 1 ) ans = 0 ; else { ans = ( ( n - maxFreqCount ) / ( maxFreqElement - 1 ) ) ; } return ans ; } int main ( ) { vector < int > a = { 1 , 2 , 1 , 2 } ; cout << findMaxLen ( a ) << endl ; }"}
{"text": "Pertanyaan untuk menilai persamaan yang diberikan dalam julat [l, r] | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mendapatkan indeks pertengahan julat; Fungsi rekursif untuk mendapatkan jumlah nilai dalam julat yang diberikan dari array. Berikut adalah parameter untuk fungsi ini. ST -> Pointer ke Segmen Tree Node -> Indeks nod semasa dalam segmen pokok SS & SE -> Memulakan dan mengakhiri indeks segmen yang diwakili oleh nod semasa, i. e. , St [nod] L & R -> Memulakan dan menamatkan indeks pertanyaan pelbagai; Jika segmen nod ini terletak sepenuhnya dalam julat yang diberikan; Pulangan maksimum dalam segmen; Jika segmen nod ini terletak di luar julat yang diberikan; Jika segmen nod ini terletak sebahagiannya dalam julat yang diberikan; Berfungsi untuk mengembalikan maksimum dalam julat dari [L, R]; Semak nilai input yang salah; Fungsi untuk membina pokok segmen untuk subarray [ss. . se]; Untuk satu elemen; Jika tidak; Berulang untuk subtree kiri; Berulang untuk subtree yang betul; Fungsi untuk membina pokok segmen dari array yang diberikan; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan; Mengembalikan pokok segmen yang dibina; Kod pemacu; Bina pokok segmen dari array yang diberikan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } int MaxUtil ( int * st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return -1 ; int mid = getMid ( ss , se ) ; return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; } int getMax ( int * st , int n , int l , int r ) { if ( l < 0 r > n - 1 l > r ) { printf ( \" Invalid ▁ Input \" ) ; return -1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; } int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return arr [ ss ] ; } int mid = getMid ( ss , se ) ; st [ si ] = max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; } int * constructST ( int arr [ ] , int n ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * st = constructST ( arr , n ) ; vector < vector < int > > Q = { { 1 , 3 } , { 0 , 2 } } ; for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { int max = getMax ( st , n , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; int ok = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { if ( ( max & ( 1 << i ) ) != 0 ) ok = 1 ; if ( ! ok ) continue ; max |= ( 1 << i ) ; } cout << max << \" ▁ \" ; } return 0 ; }"}
{"text": "Cari bilangan pasangan dalam array supaya XOR mereka adalah 0 | Program C ++ untuk mencari bilangan pasangan dalam array supaya XOR mereka adalah 0; Fungsi untuk mengira kiraan; Menyusun senarai menggunakan fungsi terbina; Melintasi unsur -unsur; Kekerapan mengira setiap elemen; Menambah sumbangan kekerapan kepada jawapannya; Kod pemacu; Cetak kiraan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int a [ ] , int n ) { sort ( a , a + n ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << calculate ( a , n ) ; return 0 ; }"}
{"text": "Cari bilangan pasangan dalam array supaya XOR mereka adalah 0 | Program C ++ untuk mencari bilangan pasangan dalam array supaya XOR mereka adalah 0; Berfungsi untuk mengira jawapannya; Mencari maksimum array; Mewujudkan array frekuensi dengan nilai awal 0; Melintasi array; Kekerapan mengira; Melintasi pelbagai frekuensi; Mengira jawapan; Kod pemacu; Fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int a [ ] , int n ) { int * maximum = max_element ( a , a + n ) ; int frequency [ * maximum + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( * maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << ( calculate ( a , n ) ) ; }"}
{"text": "Subarray terbesar dengan bilangan yang sama 0 s dan 1 s | Program C ++ mudah untuk mencari subarray terbesar dengan bilangan yang sama 0 s dan 1 s; Fungsi ini mencetak indeks permulaan dan akhir subarray terbesar dengan bilangan yang sama 0 s dan 1 s. Juga mengembalikan saiz subarray tersebut. ; Pilih titik permulaan seperti saya; Pertimbangkan semua subarrays bermula dari i; Jika ini adalah subarray 0 jumlah, maka bandingkan dengan subarray saiz maksimum yang dikira setakat ini; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , startindex ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == -1 ) cout << \" No ▁ such ▁ subarray \" ; else cout << startindex << \" ▁ to ▁ \" << startindex + maxsize - 1 ; return maxsize ; } int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSubArray ( arr , size ) ; return 0 ; }"}
{"text": "Elemen maksimum dalam array yang disusun dan diputar |  ; Berfungsi untuk mengembalikan elemen maksimum; Sekiranya terdapat hanya satu elemen yang tersisa; Cari pertengahan; Semak jika pertengahan mencapai 0, ia lebih besar daripada elemen seterusnya atau tidak; Periksa sama ada pertengahan sendiri adalah elemen maksimum; Tentukan sama ada kita perlu pergi ke separuh kiri atau separuh kanan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMax ( int arr [ ] , int low , int high ) { if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) { return arr [ mid ] ; } if ( mid < high && arr [ mid + 1 ] < arr [ mid ] && mid > 0 && arr [ mid ] > arr [ mid - 1 ] ) { return arr [ mid ] ; } if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } } int main ( ) { int arr [ ] = { 6 , 5 , 4 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMax ( arr , 0 , n - 1 ) ; return 0 ; }"}
{"text": "Carian Ternary | Program C ++ untuk menggambarkan pendekatan berulang untuk carian ternary; Berfungsi untuk melakukan carian ternary; Cari Mid1 dan Mid2; Semak sama ada kunci hadir di mana -mana pertengahan; Oleh kerana kunci tidak hadir pada pertengahan, periksa di mana rantau ia hadir kemudian ulangi operasi carian di rantau itu; Kunci terletak di antara L dan MID1; Kunci terletak di antara Mid2 dan R; Kuncinya terletak di antara Mid1 dan Mid2; Kunci tidak dijumpai; Kod pemacu; Dapatkan array jenis array jika tidak disusun; Indeks permulaan; panjang array; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya", "code": "#include <iostream> NEW_LINE using namespace std ; int ternarySearch ( int l , int r , int key , int ar [ ] ) { while ( r >= l ) { int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) { l = mid2 + 1 ; } else { l = mid1 + 1 ; r = mid2 - 1 ; } } return -1 ; } int main ( ) { int l , r , p , key ; int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; l = 0 ; r = 9 ; key = 5 ; p = ternarySearch ( l , r , key , ar ) ; cout << \" Index ▁ of ▁ \" << key << \" ▁ is ▁ \" << p << endl ; key = 50 ; p = ternarySearch ( l , r , key , ar ) ; cout << \" Index ▁ of ▁ \" << key << \" ▁ is ▁ \" << p ; }"}
{"text": "Elemen Majoriti | Set |  ; berfungsi untuk mencetak nombor majoriti; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE int majorityNumber ( int arr [ ] , int n ) { int ans = -1 ; unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; if ( freq [ arr [ i ] ] > n / 2 ) ans = arr [ i ] ; } return ans ; } int main ( ) { int a [ ] = { 2 , 2 , 1 , 1 , 1 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << majorityNumber ( a , n ) ; return 0 ; }"}
{"text": "Cari elemen dalam array yang disusun dan diputar | Cari elemen dalam array yang disusun dan diputar menggunakan lulus tunggal carian binari; Pulangan indeks kunci dalam arr [l. . h] jika kunci hadir, jika tidak pulangan - 1; Jika arr [l ... pertengahan] disusun; Oleh kerana subarray ini disusun, kita dapat dengan cepat memeriksa sama ada kunci terletak pada separuh atau separuh lagi; Jika kunci tidak terletak pada separuh pertama subarray, bahagikan separuh lagi ke dalam dua subarray, supaya kita dapat dengan cepat memeriksa jika kunci terletak pada separuh lain; Jika arr [l. . pertengahan] subarray pertama tidak disusun, maka arr [pertengahan ... h] mesti disusun subarray; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != -1 ) cout << \" Index : ▁ \" << i << endl ; else cout << \" Key ▁ not ▁ found \" ; }"}
{"text": "Cari elemen minimum dalam array yang disusun dan diputar | Program C ++ untuk mencari elemen minimum dalam array yang disusun dan diputar; Keadaan ini diperlukan untuk mengendalikan kes apabila array tidak diputar sama sekali; Sekiranya terdapat hanya satu elemen yang tersisa; Cari pertengahan; Semak jika elemen (pertengahan + 1) adalah elemen minimum. Pertimbangkan kes seperti {3, 4, 5, 1, 2}; Semak jika Mid sendiri adalah elemen minimum; Tentukan sama ada kita perlu pergi ke separuh kiri atau kanan; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; } int main ( ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr1 , 0 , n1 - 1 ) << endl ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr2 , 0 , n2 - 1 ) << endl ; int arr3 [ ] = { 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr3 , 0 , n3 - 1 ) << endl ; int arr4 [ ] = { 1 , 2 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr4 , 0 , n4 - 1 ) << endl ; int arr5 [ ] = { 2 , 1 } ; int n5 = sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr5 , 0 , n5 - 1 ) << endl ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr6 , 0 , n6 - 1 ) << endl ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = sizeof ( arr7 ) / sizeof ( arr7 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr7 , 0 , n7 - 1 ) << endl ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = sizeof ( arr8 ) / sizeof ( arr8 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr8 , 0 , n8 - 1 ) << endl ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = sizeof ( arr9 ) / sizeof ( arr9 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr9 , 0 , n9 - 1 ) << endl ; return 0 ; }"}
{"text": "Cari elemen minimum dalam array yang disusun dan diputar | Program C ++ untuk mencari elemen minimum dalam array yang disusun dan diputar elemen pendua. ; Berfungsi untuk mencari elemen minimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; } int main ( ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr1 , 0 , n1 - 1 ) << endl ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr2 , 0 , n2 - 1 ) << endl ; int arr3 [ ] = { 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr3 , 0 , n3 - 1 ) << endl ; int arr4 [ ] = { 1 , 2 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr4 , 0 , n4 - 1 ) << endl ; int arr5 [ ] = { 2 , 1 } ; int n5 = sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr5 , 0 , n5 - 1 ) << endl ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr6 , 0 , n6 - 1 ) << endl ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = sizeof ( arr7 ) / sizeof ( arr7 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr7 , 0 , n7 - 1 ) << endl ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = sizeof ( arr8 ) / sizeof ( arr8 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr8 , 0 , n8 - 1 ) << endl ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = sizeof ( arr9 ) / sizeof ( arr9 [ 0 ] ) ; cout << \" The ▁ minimum ▁ element ▁ is ▁ \" << findMin ( arr9 , 0 , n9 - 1 ) << endl ; return 0 ; }"}
{"text": "K | Program C ++ untuk mencari perbezaan mutlak antara dua elemen; Mengembalikan bilangan pasangan dengan perbezaan mutlak kurang daripada atau sama dengan pertengahan. ; Upper Bound Returns Pointer ke kedudukan nombor seterusnya yang lebih tinggi daripada [i] + pertengahan dalam [i. . n - 1]. Kami tolak (a + i + 1) dari kedudukan ini untuk dikira; Pulangan k - perbezaan mutlak; Susun array; Perbezaan mutlak minimum; Perbezaan mutlak maksimum; Adakah pencarian binari untuk perbezaan mutlak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int * a , int n , int mid ) { int res = 0 ; for ( int i = 0 ; i < n ; ++ i ) res += upper_bound ( a + i , a + n , a [ i ] + mid ) - ( a + i + 1 ) ; return res ; } int kthDiff ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; int low = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i <= n - 2 ; ++ i ) low = min ( low , a [ i + 1 ] - a [ i ] ) ; int high = a [ n - 1 ] - a [ 0 ] ; while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( countPairs ( a , n , mid ) < k ) low = mid + 1 ; else high = mid ; } return low ; } int main ( ) { int k = 3 ; int a [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << kthDiff ( a , n , k ) ; return 0 ; }"}
{"text": "Cari elemen terkecil terkecil dan kedua dalam array | Program C ++ untuk mencari elemen terkecil terkecil dan kedua; Untuk int_max; Harus ada dua elemen; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void print2Smallest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { cout << \" ▁ Invalid ▁ Input ▁ \" ; return ; } first = second = INT_MAX ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MAX ) cout << \" There ▁ is ▁ no ▁ second ▁ smallest ▁ element STRNEWLINE \" ; else cout << \" The ▁ smallest ▁ element ▁ is ▁ \" << first << \" ▁ and ▁ second ▁ \" \" Smallest ▁ element ▁ is ▁ \" << second << endl ; } int main ( ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2Smallest ( arr , n ) ; return 0 ; }"}
{"text": "Range LCM Queries | LCM pertanyaan pelbagai yang diberikan menggunakan pokok segmen; memperuntukkan ruang untuk pokok; mengisytiharkan array di seluruh dunia; Berfungsi untuk mengembalikan GCD A dan B; fungsi utiliti untuk mencari LCM; Fungsi untuk membina nod pokok segmen memulakan indeks permulaan subtree semasa. Permulaan dan akhir adalah indeks dalam arr [] yang global; Sekiranya terdapat hanya satu elemen dalam subarray semasa; membina segmen kiri dan kanan; membina ibu bapa; Berfungsi untuk membuat pertanyaan untuk pelbagai array) l, r). Node adalah indeks akar segmen semasa dalam pokok segmen (perhatikan bahawa indeks dalam pokok segmen bermula dengan 1F atau kesederhanaan). Mula dan akhir adalah indeks subarray yang dilindungi oleh akar segmen semasa. ; Sepenuhnya di luar segmen, kembali 1 tidak akan menjejaskan LCM; ; sepenuhnya di dalam segmen; sebahagiannya di dalam; fungsi pemacu untuk memeriksa program di atas; memulakan array; membina pokok segmen; Sekarang kita dapat menjawab setiap pertanyaan dengan cekap mencetak LCM (2, 5); Cetak LCM (5, 10); Cetak LCM (0, 10)", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE int tree [ 4 * MAX ] ; int arr [ MAX ] ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int lcm ( int a , int b ) { return a * b / gcd ( a , b ) ; } void build ( int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) / 2 ; build ( 2 * node , start , mid ) ; build ( 2 * node + 1 , mid + 1 , end ) ; int left_lcm = tree [ 2 * node ] ; int right_lcm = tree [ 2 * node + 1 ] ; tree [ node ] = lcm ( left_lcm , right_lcm ) ; } int query ( int node , int start , int end , int l , int r ) { if ( end < l start > r ) return 1 ; if ( l <= start && r >= end ) return tree [ node ] ; int mid = ( start + end ) / 2 ; int left_lcm = query ( 2 * node , start , mid , l , r ) ; int right_lcm = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return lcm ( left_lcm , right_lcm ) ; } int main ( ) { arr [ 0 ] = 5 ; arr [ 1 ] = 7 ; arr [ 2 ] = 5 ; arr [ 3 ] = 2 ; arr [ 4 ] = 10 ; arr [ 5 ] = 12 ; arr [ 6 ] = 11 ; arr [ 7 ] = 17 ; arr [ 8 ] = 14 ; arr [ 9 ] = 1 ; arr [ 10 ] = 44 ; build ( 1 , 0 , 10 ) ; cout << query ( 1 , 0 , 10 , 2 , 5 ) << endl ; cout << query ( 1 , 0 , 10 , 5 , 10 ) << endl ; cout << query ( 1 , 0 , 10 , 0 , 10 ) << endl ; return 0 ; }"}
{"text": "Kira penyahkodan mungkin urutan digit yang diberikan dengan aksara tersembunyi |  ; Semak watak pertama rentetan jika ' *' maka 9 cara; melintasi rentetan; Jika s [i] = = ' *' boleh ada 9 nilai yang mungkin *; Jika watak sebelumnya adalah 1 maka perkataan yang boleh dibentuk adalah k (11), l (12), m (13), n (14) o (15), p (16), q (17), r (18), s (19); Jika watak sebelumnya adalah 2 maka kata -kata yang boleh dibentuk ialah u (21), v (22), w (23), x (24) y (25), z (26); Jika digit sebelumnya * maka semua 15 2 - aksara digit boleh dibentuk; mengambil nilai dari langkah sebelumnya; Jika watak sebelumnya adalah 1 maka watak I - 1 dan watak itu boleh dikodkan dalam satu watak oleh itu, menambah DP [i - 1]. ; Jika watak sebelumnya adalah 2 dan watak ith kurang daripada 6 maka watak I - 1 dan watak ith boleh dikodkan dalam satu watak oleh itu, menambah DP [i - 1]. ; Jika watak sebelumnya * maka ia akan mengandungi 2 kes di atas; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int M = 1000000007 ; int waysOfDecoding ( string s ) { vector < int > dp ( ( int ) s . size ( ) + 1 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == ' * ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != '0' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ ( int ) s . size ( ) ] ; } int main ( ) { string s = \"12\" ; cout << waysOfDecoding ( s ) ; return 0 ; }"}
{"text": "Kira cara untuk memecah array ke dalam dua subset yang mempunyai perbezaan antara jumlah mereka sama dengan k | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan cara untuk membahagikan array ke dalam dua subset dan sedemikian rupa sehingga perbezaan antara jumlah mereka adalah sama dengan perbezaan; Simpan jumlah set S1; Memulakan matriks; Bilangan cara untuk mendapatkan jumlah menggunakan 0 elemen adalah 0; Bilangan cara untuk mendapatkan jumlah 0 menggunakan elemen i adalah 1; Melintasi array 2D; Jika nilai lebih besar daripada jumlah menyimpan nilai keadaan sebelumnya; Mengembalikan hasilnya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubset ( int arr [ ] , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int t [ n + 1 ] [ sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; } int main ( ) { int diff = 1 , n = 4 ; int arr [ ] = { 1 , 1 , 2 , 3 } ; cout << countSubset ( arr , n , diff ) ; }"}
{"text": "Kebarangkalian bahawa jumlah semua nombor yang diperolehi membuang dadu n kali terletak di antara dua bilangan bulat yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira kebarangkalian bahawa jumlah nombor pada n lontaran dadu terletak di antara a dan b; Kes asas; Tambah kebarangkalian untuk semua nombor antara A dan B; Kod pemacu; Cetak jawapannya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float dp [ 105 ] [ 605 ] ; float find ( int N , int a , int b ) { float probability = 0.0 ; for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = 1.0 / 6 ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } } for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; float probability = find ( N , a , b ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }"}
{"text": "Jumlah maksimum dari pokok dengan tahap bersebelahan tidak dibenarkan | C ++ kod untuk jumlah maksimum dengan tahap bersebelahan tidak dibenarkan; Kelas nod pokok untuk perwakilan pokok binari; Fungsi rekursif untuk mencari jumlah maksimum yang dikembalikan untuk nod akar dan cucunya; Mengembalikan jumlah maksimum dengan tahap bersebelahan tidak dibenarkan -> Fungsi ini terutamanya menggunakan getSumalternate (); Kami mengira jumlah tahap alternatif bermula tahap pertama dan dari tahap kedua -> dan pulangan maksimum dua nilai ->; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; Node ( int item ) { data = item ; } } ; int getSum ( Node * root ) ; int getSumAlternate ( Node * root ) { if ( root == NULL ) return 0 ; int sum = root -> data ; if ( root -> left != NULL ) { sum += getSum ( root -> left -> left ) ; sum += getSum ( root -> left -> right ) ; } if ( root -> right != NULL ) { sum += getSum ( root -> right -> left ) ; sum += getSum ( root -> right -> right ) ; } return sum ; } int getSum ( Node * root ) { if ( root == NULL ) return 0 ; return max ( getSumAlternate ( root ) , ( getSumAlternate ( root -> left ) + getSumAlternate ( root -> right ) ) ) ; } int main ( ) { Node * root = new Node ( 1 ) ; root -> left = new Node ( 2 ) ; root -> right = new Node ( 3 ) ; root -> right -> left = new Node ( 4 ) ; root -> right -> left -> right = new Node ( 5 ) ; root -> right -> left -> right -> left = new Node ( 6 ) ; cout << ( getSum ( root ) ) ; return 0 ; }"}
{"text": "Subset Jumlah Masalah di O (SUM) Ruang | Pulangan benar jika terdapat subset dengan jumlah yang diberikan dalam arr []; Pulangan benar jika terdapat subset dengan jumlah yang diberikan dalam arr []; Nilai subset [i % 2] [j] akan benar jika terdapat subset jumlah J dalam arr [0, 1, .... , i - 1]; Subset dengan jumlah 0 selalu mungkin; Sekiranya tidak ada unsur tidak ada jumlah yang mungkin; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; bool isSubsetSum ( int arr [ ] , int n , int sum ) { bool subset [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; } int main ( ) { int arr [ ] = { 6 , 2 , 5 } ; int sum = 7 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSubsetSum ( arr , n , sum ) == true ) cout << \" There ▁ exists ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ; else cout << \" No ▁ subset ▁ exists ▁ with ▁ given ▁ sum \" ; return 0 ; }"}
{"text": "Sum maksimum equlibrium dalam array | Program CPP untuk mencari jumlah keseimbangan maksimum. ; Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = max ( res , prefix_sum ) ; } return res ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }"}
{"text": "Sum maksimum equlibrium dalam array | Program CPP untuk mencari jumlah keseimbangan maksimum. ; Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Array to Store Prefix Sum. ; Array untuk menyimpan jumlah akhiran. ; Pembolehubah untuk menyimpan jumlah maksimum. ; Kirakan jumlah awalan. ; Kirakan jumlah akhiran dan bandingkan dengan jumlah awalan. Kemas kini Ans dengan sewajarnya. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int preSum [ n ] ; int suffSum [ n ] ; int ans = INT_MIN ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = max ( ans , preSum [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }"}
{"text": "Sum maksimum equlibrium dalam array | Program CPP untuk mencari jumlah keseimbangan maksimum. ; Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int sum = accumulate ( arr , arr + n , 0 ) ; int prefix_sum = 0 , res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { prefix_sum += arr [ i ] ; if ( prefix_sum == sum ) res = max ( res , prefix_sum ) ; sum -= arr [ i ] ; } return res ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }"}
{"text": "Elemen Majoriti | Program C ++ untuk mencari elemen majoriti dalam array; Berfungsi untuk mencari elemen majoriti dalam array; sentinel; Kemas kini MaxCount jika kiraan elemen semasa lebih besar; Jika MaxCount lebih besar daripada n / 2 mengembalikan elemen yang sepadan; Kod pemacu; Fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) cout << arr [ index ] << endl ; else cout << \" No ▁ Majority ▁ Element \" << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMajority ( arr , n ) ; return 0 ; }"}
{"text": "Elemen Majoriti | Program C ++ untuk menunjukkan operasi sisipan dalam pokok carian binari. ; Fungsi utiliti untuk membuat nod BST baru; Fungsi utiliti untuk memasukkan nod baru dengan kunci yang diberikan dalam BST; Jika pokok itu kosong, kembalikan nod baru; Jika tidak, mengulangi pokok itu; Cari kiraan maksimum; Kembalikan penunjuk nod (tidak berubah); Fungsi utiliti untuk melakukan traversal inorder BST; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int key ; int c = 0 ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> c = 1 ; temp -> left = temp -> right = NULL ; return temp ; } struct node * insert ( struct node * node , int key , int & ma ) { if ( node == NULL ) { if ( ma == 0 ) ma = 1 ; return newNode ( key ) ; } if ( key < node -> key ) node -> left = insert ( node -> left , key , ma ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key , ma ) ; else node -> c ++ ; ma = max ( ma , node -> c ) ; return node ; } void inorder ( struct node * root , int s ) { if ( root != NULL ) { inorder ( root -> left , s ) ; if ( root -> c > ( s / 2 ) ) printf ( \" % d ▁ STRNEWLINE \" , root -> key ) ; inorder ( root -> right , s ) ; } } int main ( ) { int a [ ] = { 1 , 3 , 3 , 3 , 2 } ; int size = ( sizeof ( a ) ) / sizeof ( a [ 0 ] ) ; struct node * root = NULL ; int ma = 0 ; for ( int i = 0 ; i < size ; i ++ ) { root = insert ( root , a [ i ] , ma ) ; } if ( ma > ( size / 2 ) ) inorder ( root , size ) ; else cout << \" No ▁ majority ▁ element STRNEWLINE \" ; return 0 ; }"}
{"text": "Elemen Majoriti | Program C ++ untuk mencari elemen majoriti dalam array; Berfungsi untuk mencari calon untuk majoriti; Berfungsi untuk memeriksa sama ada calon berlaku lebih daripada n / 2 kali; Berfungsi untuk mencetak elemen majoriti; Cari calon untuk majoriti; Cetak calon jika ia adalah majoriti; Kod pemacu; Fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCandidate ( int a [ ] , int size ) { int maj_index = 0 , count = 1 ; for ( int i = 1 ; i < size ; i ++ ) { if ( a [ maj_index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj_index = i ; count = 1 ; } } return a [ maj_index ] ; } bool isMajority ( int a [ ] , int size , int cand ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( a [ i ] == cand ) count ++ ; if ( count > size / 2 ) return 1 ; else return 0 ; } void printMajority ( int a [ ] , int size ) { int cand = findCandidate ( a , size ) ; if ( isMajority ( a , size , cand ) ) cout << \" ▁ \" << cand << \" ▁ \" ; else cout << \" No ▁ Majority ▁ Element \" ; } int main ( ) { int a [ ] = { 1 , 3 , 3 , 1 , 2 } ; int size = ( sizeof ( a ) ) / sizeof ( a [ 0 ] ) ; printMajority ( a , size ) ; return 0 ; }"}
{"text": "Elemen Majoriti | Program C ++ untuk mencari elemen majoriti dalam array; Kod pemacu; Fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMajority ( int arr [ ] , int size ) { unordered_map < int , int > m ; for ( int i = 0 ; i < size ; i ++ ) m [ arr [ i ] ] ++ ; int count = 0 ; for ( auto i : m ) { if ( i . second > size / 2 ) { count = 1 ; cout << \" Majority ▁ found ▁ : - ▁ \" << i . first << endl ; break ; } } if ( count == 0 ) cout << \" No ▁ Majority ▁ element \" << endl ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMajority ( arr , n ) ; return 0 ; }"}
{"text": "Elemen Majoriti | Program C ++ untuk mencari elemen majoriti dalam array; Fungsi untuk mencari elemen majoriti dalam array ia kembali - 1 jika tidak ada unsur majoriti; Susun array dalam O (nlogn); Meningkatkan kiraan jika elemen yang sama berlaku sebaliknya mula mengira elemen baru; menetapkan kiraan maksimum dan menyimpan elemen maksimum yang berlaku setakat ini jika kiraan maksimum menjadi lebih besar daripada n / 2 ia memecahkan penetapan bendera; Mengembalikan elemen maksimum yang berlaku jika tidak ada elemen sedemikian, pulangan - 1; Kod pemacu; Fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int majorityElement ( int * arr , int n ) { sort ( arr , arr + n ) ; int count = 1 , max_ele = -1 , temp = arr [ 0 ] , ele , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > ( n / 2 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : -1 ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << majorityElement ( arr , n ) ; return 0 ; }"}
{"text": "Pengaturcaraan Dinamik | Penyelesaian pengaturcaraan dinamik untuk masalah jumlah subset; Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara bawah; Uncomment Kod ini untuk mencetak jadual; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; bool isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( \" % 4d \" , subset [ i ] [ j ] ) ; cout << \" STRNEWLINE \" ; } return subset [ n ] [ sum ] ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) cout << \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ; else cout << \" No ▁ subset ▁ with ▁ given ▁ sum \" ; return 0 ; }"}
{"text": "Pengaturcaraan Dinamik | Program CPP untuk pendekatan di atas; Mengambil matriks secara global; Semak jika boleh subset dengan jumlah yang diberikan adalah mungkin atau tidak; Sekiranya jumlahnya adalah sifar, ia bermakna kami mendapat jumlah yang diharapkan; Jika nilai tidak - 1 ia bermakna ia sudah memanggil fungsi dengan nilai yang sama. Ia akan menyelamatkan kami dari pengulangan. ; Jika nilai A [n - 1] lebih besar daripada jumlahnya. Kami memanggil nilai seterusnya; Di sini kita melakukan dua panggilan kerana kita tidak tahu apa -apa yang akan dipenuhi oleh kami. Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int tab [ 2000 ] [ 2000 ] ; int subsetSum ( int a [ ] , int n , int sum ) { if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ; if ( tab [ n - 1 ] [ sum ] != -1 ) return tab [ n - 1 ] [ sum ] ; if ( a [ n - 1 ] > sum ) return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) ; else { return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) ; } } int main ( ) { memset ( tab , -1 , sizeof ( tab ) ) ; int n = 5 ; int a [ ] = { 1 , 5 , 3 , 7 , 4 } ; int sum = 12 ; if ( subsetSum ( a , n , sum ) ) { cout << \" YES \" << endl ; } else cout << \" NO \" << endl ; }"}
{"text": "Jumlah perbezaan bit untuk nombor dari 0 hingga n | Program C ++ untuk pendekatan di atas; Berfungsi untuk melaksanakan eksponensi cepat; Berfungsi untuk mengembalikan nilai untuk kuasa 2; Berfungsi untuk menukar n ke dalam binari; Untuk menyimpan perwakilan binari; Melepasi setiap digit n; Mengembalikan perwakilan binari; Berfungsi untuk mencari perbezaan bit; Dapatkan perwakilan binari; Jumlah bilangan perbezaan bit dari 0 hingga n; Melangkah ke atas setiap bit binari; Jika bit semasa adalah '1' kemudian tambahkan kiraan bit semasa; Kod pemacu; Nombor yang diberikan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int binpow ( int a , int b ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = res * a ; a = a * a ; b /= 2 ; } return res ; } int find ( int x ) { if ( x == 0 ) return 0 ; int p = log2 ( x ) ; return binpow ( 2 , p + 1 ) - 1 ; } string getBinary ( int n ) { string ans = \" \" ; while ( n ) { int dig = n % 2 ; ans += to_string ( dig ) ; n /= 2 ; } return ans ; } int totalCountDifference ( int n ) { string ans = getBinary ( n ) ; int req = 0 ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { if ( ans [ i ] == '1' ) { req += find ( binpow ( 2 , i ) ) ; } } return req ; } int main ( ) { int N = 5 ; cout << totalCountDifference ( N ) ; return 0 ; }"}
{"text": "Cari panjang maksimum awalan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan panjang maksimum awalan yang diperlukan; Array untuk menyimpan kekerapan setiap elemen array; Melangkah untuk semua elemen; Kemas kini kekerapan elemen semasa i. e. v; Disusun nilai positif dari array Count; Jika awalan semasa memenuhi syarat yang diberikan; Mengembalikan panjang maksimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Maximum_Length ( vector < int > a ) { int counts [ 11 ] = { 0 } ; int ans = 0 ; for ( int index = 0 ; index < a . size ( ) ; index ++ ) { counts [ a [ index ] ] += 1 ; vector < int > k ; for ( auto i : counts ) if ( i != 0 ) k . push_back ( i ) ; sort ( k . begin ( ) , k . end ( ) ) ; if ( k . size ( ) == 1 || ( k [ 0 ] == k [ k . size ( ) - 2 ] && k . back ( ) - k [ k . size ( ) - 2 ] == 1 ) || ( k [ 0 ] == 1 and k [ 1 ] == k . back ( ) ) ) ans = index ; } return ans + 1 ; } int main ( ) { vector < int > a = { 1 , 1 , 1 , 2 , 2 , 2 } ; cout << ( Maximum_Length ( a ) ) ; }"}
{"text": "Pertanyaan dalam talian untuk GCD Array Selepas Membahagikan Operasi | C ++ pelaksanaan pendekatan; Fungsi untuk mengira GCD pertanyaan onine; menyimpan GCD elemen array awal; mengira GCD; melakukan pertanyaan dalam talian; Indeks adalah 1 berdasarkan; Bahagikan elemen array; mengira GCD semasa; Cetak GCD selepas setiap langkah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_gcd_online ( int n , int m , int query [ ] [ 2 ] , int arr [ ] ) { int max_gcd = 0 ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) max_gcd = __gcd ( max_gcd , arr [ i ] ) ; for ( i = 0 ; i < m ; i ++ ) { query [ i ] [ 0 ] -- ; arr [ query [ i ] [ 0 ] ] /= query [ i ] [ 1 ] ; max_gcd = __gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) ; cout << max_gcd << endl ; } } int main ( ) { int n = 3 ; int m = 3 ; int query [ m ] [ 2 ] ; int arr [ ] = { 36 , 24 , 72 } ; query [ 0 ] [ 0 ] = 1 ; query [ 0 ] [ 1 ] = 3 ; query [ 1 ] [ 0 ] = 3 ; query [ 1 ] [ 1 ] = 12 ; query [ 2 ] [ 0 ] = 2 ; query [ 2 ] [ 1 ] = 4 ; print_gcd_online ( n , m , query , arr ) ; return 0 ; }"}
{"text": "Nombor dalam julat [l, r] supaya kiraan pembahagi mereka adalah kedua -duanya dan perdana | C ++ pelaksanaan pendekatan; Kedai sama ada nombor itu adalah perdana atau tidak; menyimpan kiraan nombor perdana kurang daripada atau sama dengan indeks; buat penapis; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaan sebagai benar. Nilai dalam perdana [i] akhirnya akan palsu jika 'i' bukanlah perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; menyimpan jumlah awalan bilangan prima kurang daripada atau sama dengan 'i'; Kod pemacu; buat penapis; 'l' dan 'r' adalah batas bawah dan atas julat; Dapatkan nilai kiraan; Paparkan kiraan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE bool prime [ MAX + 1 ] ; int sum [ MAX + 1 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; memset ( sum , 0 , sizeof ( sum ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( int i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } } int main ( ) { SieveOfEratosthenes ( ) ; int l = 3 , r = 9 ; int c = ( sum [ r ] - sum [ l - 1 ] ) ; cout << \" Count : ▁ \" << c << endl ; return 0 ; }"}
{"text": "Kawasan bulatan yang ditulis dalam segi empat tepat yang tertulis dalam separuh bulatan | Program C ++ untuk mencari kawasan bulatan yang ditulis dalam segi empat tepat yang seterusnya ditulis dalam separuh bulatan; Berfungsi untuk mencari kawasan bulatan; Radius tidak boleh negatif; kawasan bulatan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float area ( float r ) { if ( r < 0 ) return -1 ; float area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return area ; } int main ( ) { float a = 5 ; cout << area ( a ) << endl ; return 0 ; }"}
{"text": "Cari kiraan nombor hampir perdana dari 1 hingga n | Program CPP untuk mengira hampir nombor utama dari 1 hingga N; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Fungsi untuk mengira hampir nombor utama dari 1 hingga n; untuk menyimpan jawapan yang diperlukan; 6 adalah nombor hampir perdana pertama; untuk mengira faktor utama; Jika ia sempurna persegi; Sekiranya saya hampir nombor utama; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE bool prime [ N ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < N ; i += p ) prime [ i ] = false ; } } } int almostPrimes ( int n ) { int ans = 0 ; for ( int i = 6 ; i <= n ; i ++ ) { int c = 0 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) { if ( prime [ j ] ) c ++ ; } else { if ( prime [ j ] ) c ++ ; if ( prime [ i / j ] ) c ++ ; } } } if ( c == 2 ) ans ++ ; } return ans ; } int main ( ) { SieveOfEratosthenes ( ) ; int n = 21 ; cout << almostPrimes ( n ) ; return 0 ; }"}
{"text": "Bahagikan nombor menjadi dua bahagian supaya jumlah digit adalah maksimum | C ++ pelaksanaan pendekatan di atas; Mengembalikan jumlah digit X; Mengembalikan nombor terdekat kepada X dari segi 9. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x ) { ans += x % 10 ; x /= 10 ; } return ans ; } int closest ( int x ) { int ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; } int sumOfDigitsTwoParts ( int N ) { int A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; } int main ( ) { int N = 35 ; cout << sumOfDigitsTwoParts ( N ) ; return 0 ; }"}
{"text": "Ujian Primal | Tetapkan 5 (menggunakan program LUCAS | CPP untuk memeriksa primal menggunakan siri lucas - lehmer., Berfungsi untuk memeriksa sama ada (2 ^ p - 1) adalah perdana atau tidak.", "code": "#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; bool isPrime ( int p ) { long long checkNumber = pow ( 2 , p ) - 1 ; long long nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; } int main ( ) { int p = 7 ; long long checkNumber = pow ( 2 , p ) - 1 ; if ( isPrime ( p ) ) cout << checkNumber << \" ▁ is ▁ Prime . \" ; else cout << checkNumber << \" ▁ is ▁ not ▁ Prime . \" ; return 0 ; }"}
{"text": "Sophie Germain Prime | Program CPP untuk mencetak semua nombor perdana Sophie Jerman sehingga n. ; Fungsi untuk mengesan nombor perdana di sini kami telah menggunakan kaedah penapis https: www. Geeksforgeeks. org / sieve - of - eratosthenes / untuk mengesan nombor perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Kami telah membuat array sehingga 2 * n + 1 supaya kami dapat memeriksa nombor perdana sehingga itu dan menyimpulkan tentang Sophie Jerman Prime. ; Memeriksa setiap saya sama ada Sophie Jerman Perdana atau tidak. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sieve ( int n , bool prime [ ] ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } void printSophieGermanNumber ( int n ) { bool prime [ 2 * n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; sieve ( 2 * n + 1 , prime ) ; for ( int i = 2 ; i <= n ; ++ i ) { if ( prime [ i ] && prime [ 2 * i + 1 ] ) cout << i << \" ▁ \" ; } } int main ( ) { int n = 25 ; printSophieGermanNumber ( n ) ; return 0 ; }"}
{"text": "Interpolasi Bessel | Program CPP untuk interpolasi menggunakan interpolasi Bessel; mengira anda disebut dalam formula; mengira faktorial nombor n; Kod pemacu; Bilangan nilai yang diberikan; y [] [] digunakan untuk jadual perbezaan dengan y [] [0] digunakan untuk input; Mengira jadual perbezaan pusat; Memaparkan jadual perbezaan pusat; nilai untuk interpolasi pada; Memulakan u dan jumlah; k ialah asalnya ialah F (0); jika (n % 2) asal untuk ganjil; k = n / 2 - 1; Asal untuk walaupun; Menyelesaikan menggunakan formula Bessel", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float ucal ( float u , int n ) { if ( n == 0 ) return 1 ; float temp = u ; for ( int i = 1 ; i <= n / 2 ; i ++ ) temp = temp * ( u - i ) ; for ( int i = 1 ; i < n / 2 ; i ++ ) temp = temp * ( u + i ) ; return temp ; } int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } int main ( ) { int n = 6 ; float x [ ] = { 25 , 26 , 27 , 28 , 29 , 30 } ; float y [ n ] [ n ] ; y [ 0 ] [ 0 ] = 4.000 ; y [ 1 ] [ 0 ] = 3.846 ; y [ 2 ] [ 0 ] = 3.704 ; y [ 3 ] [ 0 ] = 3.571 ; y [ 4 ] [ 0 ] = 3.448 ; y [ 5 ] [ 0 ] = 3.333 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < n - i ; j ++ ) y [ j ] [ i ] = y [ j + 1 ] [ i - 1 ] - y [ j ] [ i - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) cout << setw ( 4 ) << y [ i ] [ j ] << \" TABSYMBOL \" ; cout << endl ; } float value = 27.4 ; float sum = ( y [ 2 ] [ 0 ] + y [ 3 ] [ 0 ] ) / 2 ; int k ; k = n / 2 ; else float u = ( value - x [ k ] ) / ( x [ 1 ] - x [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( i % 2 ) sum = sum + ( ( u - 0.5 ) * ucal ( u , i - 1 ) * y [ k ] [ i ] ) / fact ( i ) ; else sum = sum + ( ucal ( u , i ) * ( y [ k ] [ i ] + y [ -- k ] [ i ] ) / ( fact ( i ) * 2 ) ) ; } cout << \" Value ▁ at ▁ \" << value << \" ▁ is ▁ \" << sum << endl ; return 0 ; }"}
{"text": "Cara yang cekap untuk memeriksa sama ada N | Program C ++ yang mudah untuk memeriksa sama ada nombor N - TH Fibonacci adalah pelbagai daripada 10 .; Pulangan benar jika nombor fibonacci n - th adalah berganda dari 10 .; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE int fibonacci ( int n ) { int a = 0 , b = 1 , c ; if ( n <= 1 ) return n ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; } bool isMultipleOf10 ( int n ) { int f = fibonacci ( 30 ) ; return ( f % 10 == 0 ) ; } int main ( ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) printf ( \" Yes STRNEWLINE \" ) ; else printf ( \" No STRNEWLINE \" ) ; }"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 | Program C ++ untuk pendekatan di atas; Fungsi yang memeriksa sama ada nombor adalah kuasa 2; Kes asas '1' adalah satu -satunya nombor ganjil yang merupakan kuasa 2 (2 ^ 0); Semua nombor ganjil yang lain bukan kuasa 2; panggilan fungsi rekursif; Kod pemacu; Benar; Palsu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } int main ( ) { int n = 64 ; int m = 12 ; if ( powerOf2 ( n ) == 1 ) cout << \" True \" << endl ; else cout << \" False \" << endl ; if ( powerOf2 ( m ) == 1 ) cout << \" True \" << endl ; else cout << \" False \" << endl ; }"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 |  ; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define bool  int NEW_LINE bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; isPowerOfTwo ( 64 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; return 0 ; }"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 |  ; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; bool isPowerofTwo ( long long n ) { if ( n == 0 ) return 0 ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return 1 ; return 0 ; } int main ( ) { isPowerofTwo ( 30 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; isPowerofTwo ( 128 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; return 0 ; }"}
{"text": "Kuasa terkecil 2 yang lebih besar daripada atau sama dengan jumlah unsur array | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari kuasa terdekat 2; Nombornya; Jika sudah menjadi kuasa 2; Cari kuasa seterusnya 2; Berfungsi untuk mencari memori yang digunakan; Jumlah array; Melintasi dan mencari jumlah array; Fungsi panggilan untuk mencari kuasa terdekat 2; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } int memoryUsed ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int nearest = nextPowerOf2 ( sum ) ; return nearest ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << memoryUsed ( arr , n ) ; return 0 ; }"}
{"text": "Toggling k | Program CPP untuk bertukar -tukar k - th bit n; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; } int main ( ) { int n = 5 , k = 1 ; cout << toggleKthBit ( n , k ) ; return 0 ; }"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Program C ++ untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Pertama n dalam keadaan di bawah adalah untuk kes di mana n adalah 0; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int main ( ) { unsigned int n = 0 ; cout << nextPowerOf2 ( n ) ; return 0 ; }"}
{"text": "Nombor kth dari set gandaan nombor A, B dan C | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan GCD A dan B; Berfungsi untuk mengembalikan LCM A dan B; Berfungsi untuk mengembalikan elemen kth dari set yang diperlukan jika ia berganda A; Mula dan tamat untuk carian binari; Jika tiada jawapan yang dijumpai kembali - 1; Kemasukan dan pengecualian; Pelbagai harus lebih kecil; Pelbagai harus lebih besar; Berfungsi untuk mengembalikan elemen kth dari set yang diperlukan jika ia berbilang b; Mula dan tamat untuk carian binari; Jika tiada jawapan yang dijumpai kembali - 1; Kemasukan dan pengecualian; Pelbagai harus lebih kecil; Pelbagai harus lebih besar; Berfungsi untuk mengembalikan elemen kth dari set yang diperlukan jika ia berbilang C; Mula dan tamat untuk carian binari; Jika tiada jawapan yang dijumpai kembali - 1; Kemasukan dan pengecualian; Pelbagai harus lebih kecil; Pelbagai harus lebih besar; Berfungsi untuk mengembalikan elemen KTH dari set gandaan A, B dan C; Memohon carian binari pada gandaan A; Sekiranya elemen yang diperlukan bukanlah pelbagai A maka gandaan B dan C perlu diperiksa; Sekiranya elemen yang diperlukan bukanlah pelbagai atau pelbagai b maka gandaan C perlu diperiksa; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; int gcd ( int A , int B ) { if ( B == 0 ) return A ; return gcd ( B , A % B ) ; } int lcm ( int A , int B ) { return ( A * B ) / gcd ( A , B ) ; } int checkA ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = A * mid ; int divA = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } int checkB ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = B * mid ; int divB = mid - 1 ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } int checkC ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = C * mid ; int divC = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } int findKthMultiple ( int A , int B , int C , int K ) { int res = checkA ( A , B , C , K ) ; if ( res == -1 ) res = checkB ( A , B , C , K ) ; if ( res == -1 ) res = checkC ( A , B , C , K ) ; return res ; } int main ( ) { int A = 2 , B = 4 , C = 5 , K = 5 ; cout << findKthMultiple ( A , B , C , K ) ; return 0 ; }"}
{"text": "Tambah elemen dalam mula menyusun array | Variasi Stalin Sort | C ++ pelaksanaan untuk menyusun array dengan menggunakan variasi jenis Stalin; Berfungsi untuk menyusun array; Iterator <Integer> index = arr. iterator (); ; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void variationStalinsort ( vector < int > arr ) { int j = 0 ; while ( true ) { int moved = 0 ; for ( int i = 0 ; i < ( arr . size ( ) - 1 - j ) ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { vector < int > :: iterator index ; int temp ; index = arr . begin ( ) + i + 1 ; temp = arr [ i + 1 ] ; arr . erase ( index ) ; arr . insert ( arr . begin ( ) + moved , temp ) ; moved ++ ; } } j ++ ; if ( moved == 0 ) { break ; } } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { cout << arr [ i ] << \" , ▁ \" ; } } int main ( ) { vector < int > arr = { 2 , 1 , 4 , 3 , 6 , 5 , 8 , 7 , 10 , 9 } ; variationStalinsort ( arr ) ; }"}
{"text": "Susun array yang mengandungi nilai 1 hingga n dalam o (n) menggunakan jenis kitaran | Program C ++ untuk pendekatan di atas; Berfungsi untuk menukar dua nilai A & B; Berfungsi untuk mencetak elemen array; Melintasi array; Berfungsi untuk menyusun array dalam O (n); Melintasi array; Jika elemen semasa berada pada kedudukan yang betul; Lain menukar elemen semasa dengan kedudukan yang betul; Kod pemacu; Fungsi panggilan untuk menyusun array; Fungsi panggilan untuk mencetak array", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << ' ▁ ' ; } } void sortArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; ) { if ( arr [ i ] == i + 1 ) { i ++ ; } else { swap ( & arr [ i ] , & arr [ arr [ i ] - 1 ] ) ; } } } int main ( ) { int arr [ ] = { 2 , 1 , 5 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArray ( arr , N ) ; printArray ( arr , N ) ; return 0 ; }"}
{"text": "Jumlah maksimum nilai n item dalam 0 | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari nilai maksimum; keadaan asas; Unsur k telah dikurangkan kepada separuh daripada berat badan mereka; Jangan sertakan item; Jika berat item kurang daripada atau sama dengan berat yang tinggal maka masukkan item; Mengembalikan maksimum kedua -dua kes; Jika pengurangan berat badan kepada separuh mungkin; Langkau item; Sertakan item dengan berat penuh jika berat item kurang daripada berat badan yang tinggal; Sertakan item dengan separuh berat jika separuh berat item kurang daripada berat badan yang tinggal; Mengembalikan maksimum semua 3 kes; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximum ( int value [ ] , int weight [ ] , int weight1 , int flag , int K , int index , int val_len ) { if ( index >= val_len ) { return 0 ; } if ( flag == K ) { int skip = maximum ( value , weight , weight1 , flag , K , index + 1 , val_len ) ; int full = 0 ; if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 , val_len ) ; } return max ( full , skip ) ; } else { int skip = maximum ( value , weight , weight1 , flag , K , index + 1 , val_len ) ; int full = 0 ; int half = 0 ; if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 , val_len ) ; } if ( weight [ index ] / 2 <= weight1 ) { half = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] / 2 , flag , K , index + 1 , val_len ) ; } return max ( full , max ( skip , half ) ) ; } } int main ( ) { int value [ ] = { 17 , 20 , 10 , 15 } ; int weight [ ] = { 4 , 2 , 7 , 5 } ; int K = 1 ; int W = 4 ; int val_len = sizeof ( value ) / sizeof ( value [ 0 ] ) ; cout << ( maximum ( value , weight , W , 0 , K , 0 , val_len ) ) ; return 0 ; }"}
{"text": "D | Program C ++ untuk mencari saiz set dominasi minimum pokok; Definisi nod pokok; Fungsi penolong yang memperuntukkan nod baru; Array DP untuk precompute dan menyimpan hasilnya; mindominatingsettion untuk mengembalikan saiz set dominasi minimum array; Kes asas; Menetapkan nilai wajib jika diperlukan; Semak sama ada jawapannya telah dikira; Jika ia adalah wajib untuk memilih nod; Pilih nod dan tetapkan anak -anaknya seperti yang dilindungi; Jika ia dilindungi; Sekiranya nod semasa tidak dilindungi atau tidak perlu dipilih secara paksa; Simpan hasilnya; Kod pemacu; memulakan array DP; Membina pokok", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1005 NEW_LINE struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ( ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } int dp [ N ] [ 5 ] [ 5 ] ; int minDominatingSet ( Node * root , int covered , int compulsory ) { if ( ! root ) return 0 ; if ( ! root -> left and ! root -> right and ! covered ) compulsory = true ; if ( dp [ root -> data ] [ covered ] [ compulsory ] != -1 ) return dp [ root -> data ] [ covered ] [ compulsory ] ; if ( compulsory ) { return dp [ root -> data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) ; } if ( covered ) { return dp [ root -> data ] [ covered ] [ compulsory ] = min ( 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) , minDominatingSet ( root -> left , 0 , 0 ) + minDominatingSet ( root -> right , 0 , 0 ) ) ; } int ans = 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) ; if ( root -> left ) { ans = min ( ans , minDominatingSet ( root -> left , 0 , 1 ) + minDominatingSet ( root -> right , 0 , 0 ) ) ; } if ( root -> right ) { ans = min ( ans , minDominatingSet ( root -> left , 0 , 0 ) + minDominatingSet ( root -> right , 0 , 1 ) ) ; } return dp [ root -> data ] [ covered ] [ compulsory ] = ans ; } signed main ( ) { memset ( dp , -1 , sizeof ( dp ) ) ; Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> left -> left -> left = newNode ( 5 ) ; root -> left -> left -> left -> left = newNode ( 6 ) ; root -> left -> left -> left -> right = newNode ( 7 ) ; root -> left -> left -> left -> right -> right = newNode ( 10 ) ; root -> left -> left -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> left -> left -> right = newNode ( 9 ) ; cout << minDominatingSet ( root , 0 , 0 ) << endl ; return 0 ; }"}
{"text": "Bilangan subset dengan jumlah sifar |  ; pembolehubah untuk menyimpan negeri -negeri DP; Untuk mencari bilangan subset dengan jumlah yang sama dengan 0 kerana S boleh menjadi negatif, kami akan memaksimumkannya untuk menjadikannya positif; Kes asas; Mengembalikan nilai jika keadaan sudah diselesaikan; Jika Negeri tidak dikunjungi, maka teruskan; Hubungan berulang; Mengembalikan nilai; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define maxSum  100 NEW_LINE #define arrSize  51 NEW_LINE using namespace std ; int dp [ arrSize ] [ maxSum ] ; bool visit [ arrSize ] [ maxSum ] ; int SubsetCnt ( int i , int s , int arr [ ] , int n ) { if ( i == n ) { if ( s == 0 ) return 1 ; else return 0 ; } if ( visit [ i ] [ s + maxSum ] ) return dp [ i ] [ s + maxSum ] ; visit [ i ] [ s + maxSum ] = 1 ; dp [ i ] [ s + maxSum ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ; return dp [ i ] [ s + maxSum ] ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 , -4 , -4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << SubsetCnt ( 0 , 0 , arr , n ) ; }"}
{"text": "Bilangan rentetan binari panjang n dengan k bit set bersebelahan | Program C ++ untuk mencari bilangan rentetan bit panjang n dengan b bit set bersebelahan; Berfungsi untuk mencari bilangan rentetan bit panjang n dengan k bit set bersebelahan; Kes asas apabila kita membentuk rentetan panjang n; jika f (bit string) = k, hitung cara ini; Semak sama ada bit terakhir ditetapkan, jika ditetapkan maka hubungi indeks seterusnya dengan menambah kiraan bit bersebelahan lain, hubungi indeks seterusnya dengan nilai yang sama dari kiraan bit bersebelahan dan sama ada tetapkan bit pada indeks semasa atau biarkan ia tetap tidak tersembunyi; Tetapkan bit pada CurrentIndex; tidak jelas sedikit pada currentIndex; Kod pemacu; dp [i] [j] [k] mewakili rentetan panjang panjang i dengan f (bit string) = j dan bit terakhir sebagai k; inisialisasi DP; Jumlah cara = (cara dengan meletakkan bit 1 st 1 + cara dengan meletakkan bit 1 sebagai 0)", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE int waysToKAdjacentSetBits ( int dp [ ] [ MAX ] [ 2 ] , int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) { if ( currentIndex == n ) { if ( adjacentSetBits == k ) return 1 ; return 0 ; } if ( dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] != -1 ) { return dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] ; } int noOfWays = 0 ; if ( lastBit == 1 ) { noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( ! lastBit ) { noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] = noOfWays ; return noOfWays ; } int main ( ) { int n = 5 , k = 2 ; int dp [ MAX ] [ MAX ] [ 2 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; int totalWays = waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 0 ) ; cout << \" Number ▁ of ▁ ways ▁ = ▁ \" << totalWays << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Nombor Tetranacci | Program CPP berasaskan ruang untuk mencetak nombor Tetranacci Nth; Berfungsi untuk mencetak nombor tetranacci N - th; Memulakan empat nombor pertama untuk kes asas; mengisytiharkan pemboleh ubah semasa; Gelung untuk menambah empat nombor sebelumnya untuk setiap nombor bermula dari 4 dan kemudian berikan pertama, kedua, ketiga hingga kedua, ketiga, keempat dan curr masing -masing; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; void printTetra ( int n ) { if ( n < 0 ) return ; int first = 0 , second = 1 ; int third = 1 , fourth = 2 ; int curr ; if ( n == 0 ) cout << first ; else if ( n == 1 n == 2 ) cout << second ; else if ( n == 3 ) cout << fourth ; else { for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } cout << curr ; } } int main ( ) { int n = 10 ; printTetra ( n ) ; return 0 ; }"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Program C ++ untuk mengira bilangan cara untuk mencapai n 't tangga ketika; Fungsi rekursif yang digunakan oleh Countways; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; int countWays ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; } int main ( ) { int n = 4 ; cout << countWays ( n ) ; return 0 ; }"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Program C ++ untuk mengira bilangan cara untuk mencapai tangga nth ketika; Fungsi rekursif yang digunakan oleh Countways; Mengisytiharkan tiga pembolehubah dan memegang cara untuk tiga tangga pertama; pemboleh ubah keempat; Bermula dari 4 seperti yang telah dikira untuk 3 tangga; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; } int main ( ) { int n = 4 ; cout << countWays ( n ) ; return 0 ; }"}
{"text": "Subset Jumlah Masalah di O (SUM) Ruang |  ; Memulakan dengan 1 sebagai jumlah 0 selalu mungkin; Gelung untuk melalui setiap elemen array elemen; Untuk menukar nilai semua nilai jumlah yang mungkin kepada 1; Jika jumlahnya mungkin kemudian kembali 1; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; bool isPossible ( int elements [ ] , int sum , int n ) { int dp [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; } int main ( ) { int elements [ ] = { 6 , 2 , 5 } ; int n = sizeof ( elements ) / sizeof ( elements [ 0 ] ) ; int sum = 7 ; if ( isPossible ( elements , sum , n ) ) cout << ( \" YES \" ) ; else cout << ( \" NO \" ) ; return 0 ; }"}
{"text": "Pengaturcaraan Dinamik | Tinggi | Program C ++ rekursif naif untuk mencari tugas maksimum. ; Mengembalikan maksimum di antara 2 nombor; Mengembalikan jumlah tugas maksimum yang boleh dilakukan sehingga hari n; Jika n kurang daripada sama dengan 0, maka tiada penyelesaian wujud; Menentukan tugas mana yang hendak dipilih pada hari n, kemudian mengembalikan maksimum sehingga hari itu; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int max ( int x , int y ) { return ( x > y ? x : y ) ; } int maxTasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; } int main ( ) { int n = 5 ; int high [ ] = { 3 , 6 , 8 , 7 , 6 } ; int low [ ] = { 1 , 5 , 4 , 5 , 3 } ; cout << maxTasks ( high , low , n ) ; return 0 ; }"}
{"text": "Koefisien binomial | DP | Program C ++ untuk mencari GCD dua nombor dalam O (log (min (a, b))); berfungsi untuk mencari GCD dua nombor dalam O (log (min (a, b))); Kes asas; C (n, r) = c (n, n - r); pelbagai elemen dari N - r + 1 hingga n; untuk nombor dari 1 hingga r mencari arr [j], seperti gcd (i, arr [j])> 1; jika GCD> 1, bahagikan kedua -duanya oleh GCD; Jika saya menjadi 1, tidak perlu mencari arr; Pas tunggal untuk membiak pengangka; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int nCr ( int n , int r ) { if ( r > n ) return 0 ; if ( r > n - r ) r = n - r ; int mod = 1000000007 ; int arr [ r ] ; for ( int i = n - r + 1 ; i <= n ; i ++ ) { arr [ i + r - n - 1 ] = i ; } long int ans = 1 ; for ( int k = 1 ; k < r + 1 ; k ++ ) { int j = 0 , i = k ; while ( j < r ) { int x = gcd ( i , arr [ j ] ) ; if ( x > 1 ) { arr [ j ] /= x ; i /= x ; } if ( i == 1 ) break ; j += 1 ; } } for ( int i : arr ) ans = ( ans * i ) % mod ; return ( int ) ans ; } int main ( ) { int n = 5 , r = 2 ; cout << \" Value ▁ of ▁ C ( \" << n << \" , ▁ \" << r << \" ) ▁ is ▁ \" << nCr ( n , r ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Watak kth selepas menggantikan setiap watak rentetan dengan kekerapannya tepat x kali | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari watak kth selepas x hari; Pembolehubah untuk menyimpan kthchar; Melintasi rentetan; Menukar char ke int; Hitung watak; Jika k kurang daripada jumlah daripada ans = str [i]; Jawapan kembali; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; char FindKthChar ( string str , long long K , int X ) { char ans ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int digit = str [ i ] - '0' ; int range = pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; } int main ( ) { string str = \"123\" ; long long K = 9 ; int X = 3 ; char ans = FindKthChar ( str , K , X ) ; cout << ans << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Jumlah pasangan watak dari dua rentetan, dengan bilangan bit set yang sama dalam nilai ASCII mereka | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan pasangan yang sah; Kekerapan kedai bilangan bit yang ditetapkan untuk S1; Kekerapan kedai bilangan bit yang ditetapkan untuk S2; Kirakan jumlah pasangan; Mengembalikan kiraan pasangan yang sah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalPairs ( string s1 , string s2 ) { int count = 0 ; int arr1 [ 7 ] , arr2 [ 7 ] ; for ( int i = 1 ; i <= 6 ; i ++ ) { arr1 [ i ] = 0 ; arr2 [ i ] = 0 ; } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { int set_bits = __builtin_popcount ( ( int ) s1 [ i ] ) ; arr1 [ set_bits ] ++ ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { int set_bits = __builtin_popcount ( ( int ) s2 [ i ] ) ; arr2 [ set_bits ] ++ ; } for ( int i = 1 ; i <= 6 ; i ++ ) count += ( arr1 [ i ] * arr2 [ i ] ) ; return count ; } int main ( ) { string s1 = \" geeks \" ; string s2 = \" forgeeks \" ; cout << totalPairs ( s1 , s2 ) ; return 0 ; }"}
{"text": "Kira substrings yang bermula dengan aksara x dan berakhir dengan watak y | C ++ pelaksanaan untuk mengira substrings bermula dengan aksara x dan berakhir dengan aksara y; fungsi untuk mengira substrings bermula dengan aksara x dan berakhir dengan watak y; untuk menyimpan jumlah jumlah substring yang diperlukan; Untuk menyimpan kiraan watak 'x' sehingga titik rentetan 'str' telah dilalui setakat ini; Bentuk 'Str' yang tersisa ke kanan; jika benar, kenaikan 'kenaikan _ x'; jika benar mengumpul 'kiraan _ x' ke 'tot _ count'; kiraan yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstr ( string str , int n , char x , char y ) { int tot_count = 0 ; int count_x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) count_x ++ ; if ( str [ i ] == y ) tot_count += count_x ; } return tot_count ; } int main ( ) { string str = \" abbcaceghcak \" ; int n = str . size ( ) ; char x = ' a ' , y = ' c ' ; cout << \" Count ▁ = ▁ \" << countSubstr ( str , n , x , y ) ; return 0 ; }"}
{"text": "Kira perkataan dalam rentetan yang diberikan | Program C ++ untuk mengira tiada perkataan dari rentetan input yang diberikan. ; mengembalikan bilangan perkataan dalam str; kiraan perkataan; Imbas semua watak satu demi satu; Jika watak seterusnya adalah pemisah, tetapkan keadaan sebagai keluar; Jika watak seterusnya bukan pemisah perkataan dan keadaan keluar, maka tetapkan keadaan seperti dalam dan kiraan kata kenaikan; Pindah ke watak seterusnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define OUT  0 NEW_LINE #define IN  1 NEW_LINE unsigned countWords ( char * str ) { int state = OUT ; unsigned wc = 0 ; while ( * str ) { if ( * str == ' ▁ ' * str == ' ' * str == ' TABSYMBOL ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ str ; } return wc ; } int main ( void ) { char str [ ] = \" One ▁ two TABSYMBOL three STRNEWLINE ▁ four TABSYMBOL five ▁ \" ; cout << \" No ▁ of ▁ words ▁ : ▁ \" << countWords ( str ) ; return 0 ; }"}
{"text": "Nombor Enneadecagonal | Program C ++ untuk mencari nombor enneadecagonal nth; Berfungsi untuk mengira nombor enneadecagonal; Formula untuk mencari nombor enneadecagonal nth; Kod pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthEnneadecagonal ( long int n ) { return ( 17 * n * n - 15 * n ) / 2 ; } int main ( ) { long int n = 6 ; cout << n << \" th ▁ Enneadecagonal ▁ number ▁ : \" << nthEnneadecagonal ( n ) ; return 0 ; }"}
{"text": "Kawasan lingkaran yang dilampirkan dari persegi | Program C ++ untuk mencari kawasan bulatan yang dilampirkan; Fungsi ticiity; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float areacircumscribed ( float a ) { return ( a * a * ( PI / 2 ) ) ; } int main ( ) { float a = 6 ; printf ( \" ▁ Area ▁ of ▁ an ▁ circumscribed ▁ circle ▁ is ▁ : ▁ % .2f ▁ \" , areacircumscribed ( a ) ) ; return 0 ; }"}
{"text": "Cari item n yang diedarkan dari item tak terhingga jenis tak terhingga berdasarkan syarat -syarat yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jenis item yang diberikan mengikut peraturan yang diberikan; Menyimpan kiraan item yang diberikan pada setiap langkah; Melangkah untuk mencari hari ke hari yang diberikan diberikan; Cari bilangan hadiah yang diberikan pada hari adalah hari * (hari + 1) / 2; Melangkah ke atas jenis; Mengembalikan jenis yang dihasilkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int itemType ( int n ) { int count = 0 ; int day = 1 ; while ( count + day * ( day + 1 ) / 2 < n ) { count += day * ( day + 1 ) / 2 ; day ++ ; } for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) { return type ; } } } int main ( ) { int N = 10 ; cout << itemType ( N ) ; return 0 ; }"}
{"text": "Semak jika senarai yang dipautkan disusun (berulang dan rekursif) | Program C ++ untuk menyemak senarai Linked disusun mengikut urutan menurun atau tidak; Nod senarai yang dipautkan; fungsi untuk menyemak senarai yang dipautkan disusun mengikut urutan menurun atau tidak; Melintasi senarai sehingga nod terakhir dan kembali palsu jika nod lebih kecil daripada atau sama dengan yang seterusnya. ; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isSortedDesc ( struct Node * head ) { if ( head == NULL ) return true ; for ( Node * t = head ; t -> next != NULL ; t = t -> next ) if ( t -> data <= t -> next -> data ) return false ; return true ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> next = NULL ; temp -> data = data ; } int main ( ) { struct Node * head = newNode ( 7 ) ; head -> next = newNode ( 5 ) ; head -> next -> next = newNode ( 4 ) ; head -> next -> next -> next = newNode ( 3 ) ; isSortedDesc ( head ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }"}
{"text": "Panjang maksimum berturut -turut 1 s atau 0 s selepas membalikkan kebanyakan watak K | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari segmen berterusan maksimum aksara C selepas membalikkan kebanyakan aksara K; Menyimpan panjang maksimum; Menyimpan kiraan char 'c'; Permulaan tetingkap; Keluarkan tambahan 'c' dari kiri; Meningkatkan nilai kiri; Mengemas kini panjang maksimum aksara CH; Fungsi untuk mencari panjang maksimum 0 s atau 1 s dengan membalikkan kebanyakan aksara K pada rentetan; Cetak maksimum panjang maksimum 0 s atau 1 s; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLength ( string str , int n , char c , int k ) { int ans = -1 ; int cnt = 0 ; int left = 0 ; for ( int right = 0 ; right < n ; right ++ ) { if ( str [ right ] == c ) { cnt ++ ; } while ( cnt > k ) { if ( str [ left ] == c ) { cnt -- ; } left ++ ; } ans = max ( ans , right - left + 1 ) ; } return ans ; } int maxConsecutiveSegment ( string S , int K ) { int N = S . length ( ) ; return max ( maxLength ( S , N , '0' , K ) , maxLength ( S , N , '1' , K ) ) ; } int main ( ) { string S = \"1001\" ; int K = 1 ; cout << maxConsecutiveSegment ( S , K ) ; return 0 ; }"}
{"text": "Kurangkan syiling yang diperlukan untuk mendapatkan semua nilai yang mungkin sehingga n | Fungsi untuk mencari kiraan minimum {1, 2, 5} syiling bernilai diperlukan untuk membuat perubahan semua nilai dalam julat [1, n]; Bilangan 5 duit syiling yang diperlukan; Bilangan 1 duit syiling yang diperlukan; Bilangan 2 syiling bernilai diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void find ( int N ) { int T , F , O ; F = int ( ( N - 4 ) / 5 ) ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = floor ( ( N - 5 * F - O ) / 2 ) ; cout << \" Count ▁ of ▁ 5 ▁ valueds ▁ coins : ▁ \" << F << endl ; cout << \" Count ▁ of ▁ 2 ▁ valueds ▁ coins : ▁ \" << T << endl ; cout << \" Count ▁ of ▁ 1 ▁ valueds ▁ coins : ▁ \" << O << endl ; } int main ( ) { int N = 8 ; find ( N ) ; return 0 ; }"}
{"text": "Ganti '? 'Untuk menukar rentetan yang diberikan kepada rentetan binari dengan kiraan maksimum' 0 'dan \"10\" | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memaksimumkan kiraan 0 dan 10 dengan menggantikan watak '? 'hingga' 0 'atau' 1 '; Melintasi rentetan yang diberikan; Sekiranya watak semasa '? '; Gantikan str [i] hingga '0'; Kod pemacu; Diberi rentetan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxOccurence ( string str , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' ? ' ) { str [ i ] = '0' ; } } cout << str << endl ; } int main ( ) { string str = \"10?0?11\" ; int N = str . length ( ) ; findMaxOccurence ( str , N ) ; return 0 ; }"}
{"text": "Semak jika diberikan rentetan adalah substring rentetan yang dibentuk oleh penggabungan berulang z ke a | Program C ++ untuk pendekatan di atas; Pemeriksaan fungsi jika rentetan yang diberikan adalah sah atau tidak dan mencetak output; Pembolehubah bendera boolean untuk menandakan jika diberikan rentetan sah; Melintasi rentetan yang diberikan; Jika watak bersebelahan berbeza dengan 1; Jika watak 'A' diikuti oleh 4; Lain flip bendera dan pecahkan dari gelung; Output mengikut pemboleh ubah bendera; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; void checkInfinite ( string s ) { bool flag = 1 ; int N = s . length ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( s [ i ] == char ( int ( s [ i + 1 ] ) + 1 ) ) { continue ; } else if ( s [ i ] == ' a ' && s [ i + 1 ] == ' z ' ) { continue ; } else { flag = 0 ; break ; } } if ( flag == 0 ) cout << \" NO \" ; else cout << \" YES \" ; } int main ( ) { string s = \" ecbaz \" ; checkInfinite ( s ) ; return 0 ; }"}
{"text": "Perubahan minimum dalam lorong yang diperlukan untuk menyeberang semua halangan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum perubahan lorong yang diperlukan; Sekiranya terdapat halangan, maka tambahkan nilai yang sangat besar; Tambah nilai minimum untuk memindahkan Forword dengan atau tanpa melintasi halangan; Mengembalikan nilai minimum dp [0], dp [1] dan dp [2]; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minChangeInLane ( int barrier [ ] , int n ) { int dp [ ] = { 1 , 0 , 1 } ; for ( int j = 0 ; j < n ; j ++ ) { int val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = 1e6 ; } for ( int i = 0 ; i < 3 ; i ++ ) { if ( val != i + 1 ) { dp [ i ] = min ( dp [ i ] , min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } } return min ( dp [ 0 ] , min ( dp [ 1 ] , dp [ 2 ] ) ) ; } int main ( ) { int barrier [ ] = { 0 , 1 , 2 , 3 , 0 } ; int N = sizeof ( barrier ) / sizeof ( barrier [ 0 ] ) ; cout << minChangeInLane ( barrier , N ) ; return 0 ; }"}
{"text": "Pertanyaan untuk mengira kumpulan pelajar N yang mungkin mempunyai jumlah penilaian dalam julat yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan cara untuk mendapatkan kumpulan jumlah yang diberikan; Arahan DP Inisiasi; Tandakan semua nilai baris 1 sebagai 1 sejak tikar [0] [i] adalah semua jumlah yang mungkin dalam baris pertama; Betulkan baris ith; Betulkan jumlahnya; Melewati semua nilai baris ith; Jika jumlah boleh diperolehi; Cari Jumlah awalan baris terakhir; Melintasi setiap pertanyaan; Tidak ada cara untuk membentuk kumpulan; Kod pemacu; Diberikan N Batch dan K pelajar; Diberikan penilaian; Diberikan pertanyaan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void numWays ( int ratings [ n ] [ k ] , int queries [ ] [ 2 ] ) { int dp [ n ] [ 10000 + 2 ] ; for ( int i = 0 ; i < k ; i ++ ) dp [ 0 ] [ ratings [ 0 ] [ i ] ] += 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int sum = 0 ; sum <= 10000 ; sum ++ ) { for ( int j = 0 ; j < k ; j ++ ) { if ( sum >= ratings [ i ] [ j ] ) dp [ i ] [ sum ] += dp [ i - 1 ] [ sum - ratings [ i ] [ j ] ] ; } } } for ( int sum = 1 ; sum <= 10000 ; sum ++ ) { dp [ n - 1 ] [ sum ] += dp [ n - 1 ] [ sum - 1 ] ; } for ( int q = 0 ; q < 2 ; q ++ ) { int a = queries [ q ] [ 0 ] ; int b = queries [ q ] [ 1 ] ; cout << dp [ n - 1 ] [ b ] - dp [ n - 1 ] [ a - 1 ] << \" ▁ \" ; } } int main ( ) { #define n  2 NEW_LINE #define k  3 NEW_LINE int ratings [ n ] [ k ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } } ; int queries [ ] [ 2 ] = { { 6 , 6 } , { 1 , 6 } } ; numWays ( ratings , queries ) ; return 0 ; }"}
{"text": "Bilangan permutasi dengan inversions k | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira permutasi dengan penyongsangan k; Menyimpan bilangan permutasi dengan penyongsangan K; Jika n = 1 hanya 1 permutasi tanpa penyongsangan; Untuk k = 0 hanya 1 permutasi tanpa penyongsangan; Sebaliknya mengemas kini setiap keadaan DP mengikut hubungan reccurrance yang terbentuk; Cetak kiraan akhir; Kod pemacu; Diberikan n dan k; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfPermWithKInversion ( int N , int K ) { int dp [ 2 ] [ K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) dp [ i % 2 ] [ j ] = ( j == 0 ) ; else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; ; } } cout << dp [ N % 2 ] [ K ] ; } int main ( ) { int N = 3 , K = 2 ; numberOfPermWithKInversion ( N , K ) ; return 0 ; }"}
{"text": "Laluan Jumlah Maksimum dalam Matriks | Tiada baris dan lajur; Mengisytiharkan matriks maksimum 100 baris dan 100 lajur; Variabel yang dikunjungi digunakan untuk menjejaki semua DP Variable Posisi yang dikunjungi digunakan untuk menyimpan jumlah maksimum sehingga kedudukan semasa; Untuk menyimpan jumlah semasa; Untuk kemas kini berterusan jumlah maksimum yang diperlukan; Berfungsi untuk memasukkan matriks saiz n * m; Fungsi untuk mengira jumlah maksimum jalan; Memeriksa keadaan sempadan; Memeriksa sama ada atau tidak (i, j) dikunjungi; Menandakan (i, j) dikunjungi; Memeriksa sama ada kedudukan tidak melawat baris terakhir atau lajur terakhir.  Membuat panggilan rekursif untuk semua langkah yang mungkin dari sel semasa dan kemudian menambah maksimum yang dikembalikan oleh panggilan dan mengemas kini. ; Memeriksa sama ada kedudukan telah mencapai baris terakhir; Jika kedudukan berada di lajur terakhir; Mengembalikan nilai maksimum yang dikemas kini; Kod pemacu; Memanggil fungsi yang dilaksanakan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100 NEW_LINE int n , m ; int a [ N ] [ N ] ; vector < vector < int > > dp ( N , vector < int > ( N ) ) , visited ( N , vector < int > ( N ) ) ; int current_sum = 0 ; int total_sum = 0 ; void inputMatrix ( ) { n = 3 ; m = 3 ; a [ 0 ] [ 0 ] = 500 ; a [ 0 ] [ 1 ] = 100 ; a [ 0 ] [ 2 ] = 230 ; a [ 1 ] [ 0 ] = 1000 ; a [ 1 ] [ 1 ] = 300 ; a [ 1 ] [ 2 ] = 100 ; a [ 2 ] [ 0 ] = 200 ; a [ 2 ] [ 1 ] = 1000 ; a [ 2 ] [ 2 ] = 200 ; } int maximum_sum_path ( int i , int j ) { if ( i == n - 1 && j == m - 1 ) return a [ i ] [ j ] ; if ( visited [ i ] [ j ] ) return dp [ i ] [ j ] ; visited [ i ] [ j ] = 1 ; int & total_sum = dp [ i ] [ j ] ; if ( i < n - 1 & j < m - 1 ) { int current_sum = max ( maximum_sum_path ( i , j + 1 ) , max ( maximum_sum_path ( i + 1 , j + 1 ) , maximum_sum_path ( i + 1 , j ) ) ) ; total_sum = a [ i ] [ j ] + current_sum ; } else if ( i == n - 1 ) total_sum = a [ i ] [ j ] + maximum_sum_path ( i , j + 1 ) ; else total_sum = a [ i ] [ j ] + maximum_sum_path ( i + 1 , j ) ; return dp [ i ] [ j ] = total_sum ; } int main ( ) { inputMatrix ( ) ; int maximum_sum = maximum_sum_path ( 0 , 0 ) ; cout << maximum_sum ; return 0 ; }"}
{"text": "Treasure and Cities | K ialah indeks semasa dan col adalah warna sebelumnya. ; Kes asas; Semak sama ada warna bandar ini sama dengan bandar yang dilawati sebelum ini; kembali maksimum kedua -dua pilihan; Kod pemacu; Pada mulanya bermula dengan warna 0", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { int sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; } int main ( ) { int A = -5 , B = 7 ; int treasure [ ] = { 4 , 8 , 2 , 9 } ; int color [ ] = { 2 , 2 , 6 , 2 } ; int n = sizeof ( color ) / sizeof ( color [ 0 ] ) ; cout << MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ; return 0 ; }"}
{"text": "Nombor Tetranacci | Program CPP rekursif mudah untuk mencetak nombor Tetranacci Nth. ; Berfungsi untuk mengembalikan nombor tetranacci N; kes asas; kes asas; kes asas; berfungsi untuk mencetak nombor tetranacci nth; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int printTetraRec ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return 1 ; if ( n == 3 ) return 2 ; else return printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ; } void printTetra ( int n ) { cout << printTetraRec ( n ) << \" ▁ \" ; } int main ( ) { int n = 10 ; printTetra ( n ) ; return 0 ; }"}
{"text": "Jumlah produk semua gabungan diambil (1 hingga n) pada satu masa | Program untuk mencari SOP semua gabungan yang diambil (1 hingga n) pada satu masa menggunakan kekerasan; untuk menyimpan jumlah kombinasi; Jika kita telah mencapai kedalaman yang mencukupi; Cari produk gabungan; Tambah produk ke dalam jumlah; rekursi untuk menghasilkan gabungan yang berbeza; berfungsi untuk mencetak jumlah produk semua gabungan yang diambil 1 - n pada satu masa; mewujudkan array sementara untuk menyimpan kombinasi; gabungan panggilan dengan r = i untuk gabungan yang diambil saya pada satu masa; memaparkan jumlah; Kod pemandu; menyimpan nombor dari 1 - n dalam array; Memanggil AllCombination", "code": "#include <iostream> NEW_LINE using namespace std ; int sum = 0 ; void Combination ( int a [ ] , int combi [ ] , int n , int r , int depth , int index ) { if ( index == r ) { int product = 1 ; for ( int i = 0 ; i < r ; i ++ ) product = product * combi [ i ] ; sum += product ; return ; } for ( int i = depth ; i < n ; i ++ ) { combi [ index ] = a [ i ] ; Combination ( a , combi , n , r , i + 1 , index + 1 ) ; } } void allCombination ( int a [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int * combi = new int [ i ] ; Combination ( a , combi , n , i , 0 , 0 ) ; cout << \" f ( \" << i << \" ) ▁ - - > ▁ \" << sum << \" STRNEWLINE \" ; sum = 0 ; free ( combi ) ; } } int main ( ) { int n = 5 ; int * a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = i + 1 ; allCombination ( a , n ) ; return 0 ; }"}
{"text": "Pengaturcaraan Dinamik | Tinggi | Program C ++ berasaskan DP untuk mencari tugas maksimum. ; Mengembalikan maksimum di antara 2 nombor; Mengembalikan jumlah tugas maksimum yang boleh dilakukan sehingga hari n; Task_dp array yang menyimpan tugas maksimum yang dilakukan; Jika n = 0, tiada penyelesaian wujud; Jika n = 1, tugas usaha yang tinggi pada hari itu akan menjadi penyelesaian; Isi keseluruhan array menentukan tugas mana yang hendak dipilih pada hari I; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; int max ( int x , int y ) { return ( x > y ? x : y ) ; } int maxTasks ( int high [ ] , int low [ ] , int n ) { int task_dp [ n + 1 ] ; task_dp [ 0 ] = 0 ; task_dp [ 1 ] = high [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) task_dp [ i ] = max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; } int main ( ) { int n = 5 ; int high [ ] = { 3 , 6 , 8 , 7 , 6 } ; int low [ ] = { 1 , 5 , 4 , 5 , 3 } ; cout << maxTasks ( high , low , n ) ; return 0 ; }"}
{"text": "Koefisien Permutasi | A o (n) masa dan O (1) penyelesaian ruang tambahan untuk mengira pekali permutasi; Kirakan n * (n - 1) * (n - 2). ... (n - k + 1); Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int PermutationCoeff ( int n , int k ) { int P = 1 ; for ( int i = 0 ; i < k ; i ++ ) P *= ( n - i ) ; return P ; } int main ( ) { int n = 10 , k = 2 ; cout << \" Value ▁ of ▁ P ( \" << n << \" , ▁ \" << k << \" ) ▁ is ▁ \" << PermutationCoeff ( n , k ) ; return 0 ; }"}
{"text": "Masalah Partition | DP | Program C ++ berasaskan pengaturcaraan yang dinamik untuk masalah partition; Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah semua elemen; memulakan baris atas sebagai benar; memulakan lajur paling kiri, kecuali bahagian [0] [0], sebagai 0; Isi jadual partition dengan cara bawah; Uncomment Bahagian ini untuk mencetak jadual; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] [ n + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ; for ( i = 1 ; i <= sum / 2 ; i ++ ) part [ i ] [ 0 ] = false ; for ( i = 1 ; i <= sum / 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } } return part [ sum / 2 ] [ n ] ; } int main ( ) { int arr [ ] = { 3 , 1 , 1 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << \" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ \" \" sum \" ; else cout << \" Can ▁ not ▁ be ▁ divided ▁ into \" << \" ▁ two ▁ subsets ▁ of ▁ equal ▁ sum \" ; return 0 ; }"}
{"text": "Bilangan minimum tambahan x atau y aksara dari hujung ke depan yang diperlukan untuk mendapatkan rentetan yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari operasi minimum yang diperlukan untuk mendapatkan rentetan yang diberikan selepas menambahkan aksara M atau N dari hujung ke hadapan rentetan dalam setiap operasi; Simpan rentetan asal; Menyimpan kiraan operasi; Melintasi rentetan; Potong huruf dari akhir; Masukkan huruf potong untuk permulaan; Kemas kini j; Semak sama ada rentetan adalah sama; Potong n huruf dari hujung; Masukkan huruf potong n untuk permulaan; Kemas kini j; Semak sama ada rentetan adalah sama; Mengemas kini giliran; Kod pemacu; Diberikan rentetan s; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; int minimumOperations ( string orig_str , int m , int n ) { string orig = orig_str ; int turn = 1 ; int j = 1 ; for ( auto i : orig_str ) { string m_cut = orig_str . substr ( orig_str . length ( ) - m ) ; orig_str . erase ( orig_str . length ( ) - m ) ; orig_str = m_cut + orig_str ; j = j + 1 ; if ( orig != orig_str ) { turn = turn + 1 ; string n_cut = orig_str . substr ( orig_str . length ( ) - n ) ; orig_str . erase ( orig_str . length ( ) - n ) ; orig_str = n_cut + orig_str ; j = j + 1 ; } if ( orig == orig_str ) { break ; } turn = turn + 1 ; } cout << turn ; } int main ( ) { string S = \" GeeksforGeeks \" ; int X = 5 , Y = 3 ; minimumOperations ( S , X , Y ) ; return 0 ; }"}
{"text": "Putaran minimum diperlukan untuk mendapatkan rentetan yang sama | Set | C ++ pelaksanaan pendekatan di atas; Cetakan kejadian txt [] dalam pat []; Buat LPS [] yang akan memegang nilai akhiran awalan terpanjang untuk corak; Pra -proses corak (hitung array LPS []); Indeks untuk txt [], indeks untuk pat []; Tidak sepadan selepas perlawanan J; Jangan sepadan dengan LPS [0 .. LPS [J - 1]] aksara, mereka akan sepadan pula; Mengisi LPS [] untuk corak yang diberikan Pat [0. M - 1]; Panjang akhiran awalan terpanjang sebelumnya; LPS [0] sentiasa 0; Gelung mengira LPS [i] untuk i = 1 hingga m - 1; (pat [i]! = pat [len]); Ini sukar. Pertimbangkan contohnya. AAACAAAA dan I = 7. Idea ini sama dengan langkah carian. ; Mengembalikan kiraan putaran untuk mendapatkan rentetan yang sama kembali; Bentuk rentetan tidak termasuk watak pertama dan menggabungkan rentetan pada akhir; Menukar rentetan ke array aksara; Gunakan algoritma carian KMP untuk mencarinya dalam masa O (n); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void computeLPSArray ( char * pat , int M , int * lps ) ; int KMPSearch ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int lps [ M ] ; computeLPSArray ( pat , M , lps ) ; int i = 0 ; int j = 0 ; while ( i < N ) { if ( pat [ j ] == txt [ i ] ) { j ++ ; i ++ ; } if ( j == M ) { return i - j ; j = lps [ j - 1 ] ; } else if ( i < N && pat [ j ] != txt [ i ] ) { if ( j != 0 ) j = lps [ j - 1 ] ; else i = i + 1 ; } } } void computeLPSArray ( char * pat , int M , int * lps ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } } int countRotations ( string s ) { string s1 = s . substr ( 1 , s . size ( ) - 1 ) + s ; char pat [ s . length ( ) ] , text [ s1 . length ( ) ] ; strcpy ( pat , s . c_str ( ) ) ; strcpy ( text , s1 . c_str ( ) ) ; return 1 + KMPSearch ( pat , text ) ; } int main ( ) { string s1 = \" geeks \" ; cout << countRotations ( s1 ) ; return 0 ; }"}
{"text": "DFA untuk rentetan tidak berakhir dengan \"The\" | Program C ++ untuk melaksanakan DFS yang menerima semua rentetan yang tidak berakhir dengan \"The\"; DFA memberitahu nombor yang berkaitan dengan keadaan sekarang; Fungsi ini adalah untuk keadaan permulaan (zeroth) DFA; Apabila menerima 'T' atau 'T' Goto State First (1); Fungsi ini adalah untuk keadaan pertama DFA; Apabila menerima 'T' atau 'T' Goto State First (1); Apabila menerima 'H' atau 'H' Goto kedua negeri (2); Lain Goto State State (0); Fungsi ini adalah untuk keadaan kedua DFA; Apabila menerima 'E' atau 'E' Goto Negeri Ketiga (3) Lain Goto State State (0); Fungsi ini adalah untuk keadaan ketiga DFA; Apabila menerima 'T' atau 'T' Goto State First (1) Lain Goto State State (0); Panjang simpan rentetan; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int dfa = 0 ; void start ( char c ) { if ( c == ' t ' c == ' T ' ) dfa = 1 ; } void state1 ( char c ) { if ( c == ' t ' c == ' T ' ) dfa = 1 ; else if ( c == ' h ' c == ' H ' ) dfa = 2 ; else dfa = 0 ; } void state2 ( char c ) { if ( c == ' e ' c == ' E ' ) dfa = 3 ; else if ( c == ' t ' c == ' T ' ) dfa = 1 ; else dfa = 0 ; } void state3 ( char c ) { if ( c == ' t ' c == ' T ' ) dfa = 1 ; else dfa = 0 ; } bool isAccepted ( string str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; } int main ( ) { string str = \" forTHEgeeks \" ; if ( isAccepted ( str ) == true ) cout << \" ACCEPTED STRNEWLINE \" ; else cout << \" NOT ▁ ACCEPTED STRNEWLINE \" ; return 0 ; }"}
{"text": "Semak jika satu rentetan boleh ditukar kepada yang lain | C ++ pelaksanaan pendekatan di atas. ; Fungsi untuk mencari dari algoritma set disjoint; Fungsi untuk kesatuan dari algoritma set disjoint; Fungsi untuk memeriksa sama ada satu rentetan boleh ditukar kepada yang lain. ; Semua watak diperiksa sama ada ia sama ada tidak diganti atau digantikan oleh watak yang sama menggunakan peta. ; Untuk memeriksa sama ada terdapat kitaran. Jika ya, maka mereka tidak boleh ditukar. Selain itu, mereka boleh ditukar. ; Fungsi untuk memulakan array induk untuk kesatuan dan mencari algoritma. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int parent [ 26 ] ; int find ( int x ) { if ( x != parent [ x ] ) return parent [ x ] = find ( parent [ x ] ) ; return x ; } void join ( int x , int y ) { int px = find ( x ) ; int pz = find ( y ) ; if ( px != pz ) { parent [ pz ] = px ; } } bool convertible ( string s1 , string s2 ) { map < int , int > mp ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( mp . find ( s1 [ i ] - ' a ' ) == mp . end ( ) ) { mp [ s1 [ i ] - ' a ' ] = s2 [ i ] - ' a ' ; } else { if ( mp [ s1 [ i ] - ' a ' ] != s2 [ i ] - ' a ' ) return false ; } } for ( auto it : mp ) { if ( it . first == it . second ) continue ; else { if ( find ( it . first ) == find ( it . second ) ) return false ; else join ( it . first , it . second ) ; } } return true ; } void initialize ( ) { for ( int i = 0 ; i < 26 ; i ++ ) { parent [ i ] = i ; } } int main ( ) { string s1 , s2 ; s1 = \" abbcaa \" ; s2 = \" bccdbb \" ; initialize ( ) ; if ( convertible ( s1 , s2 ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }"}
{"text": "Cetak Watak yang mempunyai frekuensi utama dalam urutan kejadian | C ++ pelaksanaan pendekatan; Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mencetak aksara frekuensi utama mengikut urutan kejadian mereka; Berfungsi untuk membuat ayak untuk memeriksa prima; Untuk menyimpan kekerapan setiap watak rentetan; Memulakan semua elemen freq [] hingga 0; Kemas kini kekerapan setiap aksara; Traverse str -watak oleh watak; Jika kekerapan watak semasa adalah perdana; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } void printChar ( string str , int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , str . length ( ) + 1 ) ; int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ freq [ str [ i ] - ' a ' ] ] ) { cout << str [ i ] ; } } } int main ( ) { string str = \" geeksforgeeks \" ; int n = str . length ( ) ; printChar ( str , n ) ; return 0 ; }"}
{"text": "Cetak Watak yang mempunyai frekuensi walaupun dalam urutan kejadian | C ++ pelaksanaan pendekatan; Berfungsi untuk mencetak aksara kekerapan walaupun dalam urutan kejadian mereka; Untuk menyimpan kekerapan setiap watak rentetan; Memulakan semua elemen freq [] hingga 0; Kemas kini kekerapan setiap aksara; Traverse str -watak oleh watak; Jika kekerapan watak semasa adalah walaupun; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE void printChar ( string str , int n ) { int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { cout << str [ i ] ; } } } int main ( ) { string str = \" geeksforgeeks \" ; int n = str . length ( ) ; printChar ( str , n ) ; return 0 ; }"}
{"text": "Bandingkan dua rentetan memandangkan hanya aksara alfanumerik | Berfungsi untuk memeriksa kesamaan alfanumerik kedua -dua rentetan; Perisytiharan Variabel; Panjang rentetan pertama; Panjang rentetan kedua; Untuk memeriksa setiap watak kedua -dua rentetan; Jika watak semasa rentetan pertama bukan watak alfanumerik, tingkatkan penunjuk I; Jika watak semasa rentetan kedua bukan watak alfanumerik, tingkatkan penunjuk j; Jika semua aksara alfanumerik kedua -dua rentetan adalah sama maka kembali benar; Jika mana -mana aksara alfanumerik kedua -dua rentetan tidak sama maka kembali palsu; Jika watak semasa dipadankan, tingkatkan kedua -dua petunjuk untuk memeriksa watak seterusnya; Jika tidak sama, maka kembali palsu; Berfungsi untuk mencetak sama atau tidak sama rata jika rentetan sama atau tidak; Semak kesamaan alfanumerik kedua -dua rentetan; Sekiranya kedua -duanya adalah sama dengan alfanumerik, cetak sama; sebaliknya mencetak tidak sama rata; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; bool CompareAlphanumeric ( string & str1 , string & str2 ) { int i , j ; i = 0 ; j = 0 ; int len1 = str1 . size ( ) ; int len2 = str2 . size ( ) ; while ( i <= len1 && j <= len2 ) { while ( i < len1 && ( ! ( ( str1 [ i ] >= ' a ' && str1 [ i ] <= ' z ' ) || ( str1 [ i ] >= ' A ' && str1 [ i ] <= ' Z ' ) || ( str1 [ i ] >= '0' && str1 [ i ] <= '9' ) ) ) ) { i ++ ; } while ( j < len2 && ( ! ( ( str2 [ j ] >= ' a ' && str2 [ j ] <= ' z ' ) || ( str2 [ j ] >= ' A ' && str2 [ j ] <= ' Z ' ) || ( str2 [ j ] >= '0' && str2 [ j ] <= '9' ) ) ) ) { j ++ ; } if ( i == len1 && j == len2 ) return true ; else if ( str1 [ i ] != str2 [ j ] ) return false ; else { i ++ ; j ++ ; } } return false ; } void CompareAlphanumericUtil ( string str1 , string str2 ) { bool res ; res = CompareAlphanumeric ( str1 , str2 ) ; if ( res == true ) cout << \" Equal \" << endl ; else cout << \" Unequal \" << endl ; } int main ( ) { string str1 , str2 ; str1 = \" Ram , ▁ Shyam \" ; str2 = \" ▁ Ram ▁ - ▁ Shyam . \" ; CompareAlphanumericUtil ( str1 , str2 ) ; str1 = \" abc123\" ; str2 = \"123abc \" ; CompareAlphanumericUtil ( str1 , str2 ) ; return 0 ; }"}
{"text": "Pertanyaan untuk mencetak watak yang berlaku bilangan maksimum kali dalam julat yang diberikan | Program C ++ untuk mencari jumlah penambahan semua subset yang mungkin. ; Fungsi yang menjawab semua pertanyaan; Panjang rentetan; Bilangan pertanyaan; Arahan awalan; Melewati semua watak; Meningkatkan kiraan watak; Arahan anggaran untuk semua 26 aksara; Kemas kini array awalan; Jawab setiap pertanyaan; Julat; ITERATE untuk semua watak; Kali watak huruf kecil j berlaku sehingga indeks r - th; Tolak masa yang berlaku sehingga indeks (l - 1) th; Maksimum masa itu berlaku; Cetak jawapannya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void solveQueries ( string str , vector < vector < int > > & query ) { int len = str . size ( ) ; int Q = query . size ( ) ; int pre [ len ] [ 26 ] ; memset ( pre , 0 , sizeof pre ) ; for ( int i = 0 ; i < len ; i ++ ) { pre [ i ] [ str [ i ] - ' a ' ] ++ ; if ( i ) { for ( int j = 0 ; j < 26 ; j ++ ) pre [ i ] [ j ] += pre [ i - 1 ] [ j ] ; } } for ( int i = 0 ; i < Q ; i ++ ) { int l = query [ i ] [ 0 ] ; int r = query [ i ] [ 1 ] ; int maxi = 0 ; char c = ' a ' ; for ( int j = 0 ; j < 26 ; j ++ ) { int times = pre [ r ] [ j ] ; if ( l ) times -= pre [ l - 1 ] [ j ] ; if ( times > maxi ) { maxi = times ; c = char ( ' a ' + j ) ; } } cout << \" Query ▁ \" << i + 1 << \" : ▁ \" << c << endl ; } } int main ( ) { string str = \" striver \" ; vector < vector < int > > query ; query . push_back ( { 0 , 1 } ) ; query . push_back ( { 1 , 6 } ) ; query . push_back ( { 5 , 6 } ) ; solveQueries ( str , query ) ; }"}
{"text": "Semak sama ada rentetan yang diberikan boleh dijana selepas menyatukan rentetan yang diberikan | C ++ pelaksanaan pendekatan; Fungsi yang kembali benar jika pra adalah awalan str; Walaupun ada watak untuk dipadankan; Jika watak berbeza di mana -mana kedudukan; STR bermula dengan pra; Fungsi yang kembali benar jika Suff adalah akhiran str; Walaupun ada watak untuk dipadankan; Jika watak berbeza di mana -mana kedudukan; str berakhir dengan suff; Fungsi yang kembali benar jika str = a + b atau str = b + a; STR tidak boleh dihasilkan dengan menggabungkan A dan B; Jika str bermula dengan i. e. A adalah awalan str; Semak sama ada watak -watak yang lain adalah sama dengan b i. e. B adalah akhiran str; Jika str bermula dengan b i. e. B adalah awalan str; Semak sama ada watak -watak yang lain adalah sama dengan i. e. A adalah akhiran str; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool startsWith ( string str , string pre ) { int strLen = str . length ( ) ; int preLen = pre . length ( ) ; int i = 0 , j = 0 ; while ( i < strLen && j < preLen ) { if ( str [ i ] != pre [ j ] ) return false ; i ++ ; j ++ ; } return true ; } bool endsWith ( string str , string suff ) { int i = str . length ( ) - 0 ; int j = suff . length ( ) - 0 ; while ( i >= 0 && j >= 0 ) { if ( str [ i ] != suff [ j ] ) return false ; i -- ; j -- ; } return true ; } bool checkString ( string str , string a , string b ) { if ( str . length ( ) != a . length ( ) + b . length ( ) ) return false ; if ( startsWith ( str , a ) ) { if ( endsWith ( str , b ) ) return true ; } if ( startsWith ( str , b ) ) { if ( endsWith ( str , a ) ) return true ; } return false ; } int main ( ) { string str = \" GeeksforGeeks \" ; string a = \" Geeksfo \" ; string b = \" rGeeks \" ; if ( checkString ( str , a , b ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Cetak Watak yang mempunyai frekuensi ganjil mengikut urutan kejadian | C ++ pelaksanaan pendekatan; Berfungsi untuk mencetak aksara frekuensi ganjil mengikut urutan kejadian mereka; Untuk menyimpan kekerapan setiap watak rentetan; Memulakan semua elemen freq [] hingga 0; Kemas kini kekerapan setiap aksara; Traverse str -watak oleh watak; Jika kekerapan watak semasa adalah ganjil; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE void printChar ( string str , int n ) { int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 1 ) { cout << str [ i ] ; } } } int main ( ) { string str = \" geeksforgeeks \" ; int n = str . length ( ) ; printChar ( str , n ) ; return 0 ; }"}
{"text": "Bilangan minimum operasi untuk memindahkan semua aksara huruf besar sebelum semua aksara kes yang lebih rendah | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan; Untuk menyimpan indeks huruf besar terakhir dan watak huruf kecil pertama; Cari watak huruf besar terakhir; Cari watak huruf kecil pertama; Jika semua watak adalah huruf besar atau huruf kecil; Kiraan aksara huruf besar yang muncul selepas watak huruf kecil pertama; Count huruf kecil yang muncul sebelum watak huruf besar terakhir; Mengembalikan operasi minimum yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string str , int n ) { int i , lastUpper = -1 , firstLower = -1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( isupper ( str [ i ] ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( islower ( str [ i ] ) ) { firstLower = i ; break ; } } if ( lastUpper == -1 firstLower == -1 ) return 0 ; int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( isupper ( str [ i ] ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( islower ( str [ i ] ) ) { countLower ++ ; } } return min ( countLower , countUpper ) ; } int main ( ) { string str = \" geEksFOrGEekS \" ; int n = str . length ( ) ; cout << minOperations ( str , n ) << endl ; }"}
{"text": "Cari jumlah semua nombor pertunangan sehingga n | Program C ++ untuk mencari jumlah semua nombor pertunangan sehingga n; Berfungsi untuk mencari jumlah semua nombor pertunangan; Untuk menyimpan nombor pertunangan; Kirakan jumlah pembahagi nombor_1 1 sentiasa menjadi pembahagi; i = 2 kerana kita tidak mahu memasukkan 1 sebagai pembahagi. ; Jumlah semua nombor pertunangan sehingga n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Betrothed_Sum ( int n ) { vector < int > Set ; for ( int number_1 = 1 ; number_1 < n ; number_1 ++ ) { int sum_divisor_1 = 1 ; int i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += number_1 / i ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { int number_2 = sum_divisor_1 - 1 ; int sum_divisor_2 = 1 ; int j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += number_2 / j ; } j = j + 1 ; } if ( sum_divisor_2 == number_1 + 1 and number_1 <= n && number_2 <= n ) { Set . push_back ( number_1 ) ; Set . push_back ( number_2 ) ; } } } int Summ = 0 ; for ( auto i : Set ) { if ( i <= n ) Summ += i ; } return Summ ; } int main ( ) { int n = 78 ; cout << Betrothed_Sum ( n ) ; return 0 ; }"}
{"text": "Kebarangkalian hujan pada hari n + 1 | | C ++ kod untuk mencari kebarangkalian hujan pada hari n + 1 - pada hari sebelumnya data diberikan; Fungsi untuk mencari kebarangkalian; kiraan 1; Cari kebarangkalian; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; } int main ( ) { int a [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << rainDayProbability ( a , n ) ; return 0 ; }"}
{"text": "Program untuk mencari jumlah siri 1 + 1/2 ^ 2 + 1/3 ^ 3 + â € |. . + 1 / n ^ n | Program C ++ untuk mengira siri berikut; Fungsi untuk mengira siri berikut; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / pow ( i , i ) ; sums += ser ; } return sums ; } int main ( ) { int n = 3 ; double res = Series ( n ) ; cout << res ; return 0 ; }"}
{"text": "Rentetan lexicographically terbesar yang terbentuk dalam langkah minimum dengan menggantikan watak -watak rentetan yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencetak secara lexicographically rentetan terbesar yang diperolehi dalam proses mendapatkan rentetan yang mengandungi pertama N Lower Case English Alphabtes; Simpan kekerapan setiap watak; Melintasi rentetan s; Menyimpan watak -watak yang tidak muncul dalam s; Menyimpan indeks watak terbesar dalam array V, yang perlu diganti; Melintasi rentetan, s; Jika kekerapan S [i] lebih besar daripada 1 atau ia berada di luar julat; Menurunkan kekerapannya dengan 1; UPDATE S [I]; Penurunan j oleh 1; Melintasi rentetan, s; Menurunkan kekerapannya dengan 1; UPDATE S [I]; kenaikan l oleh 1; Pulangan s; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string lexicographicallyMaximum ( string S , int N ) { unordered_map < char , int > M ; for ( int i = 0 ; i < N ; ++ i ) { M [ S [ i ] ] ++ ; } vector < char > V ; for ( char i = ' a ' ; i < ( char ) ( ' a ' + min ( N , 25 ) ) ; ++ i ) { if ( M [ i ] == 0 ) { V . push_back ( i ) ; } } int j = V . size ( ) - 1 ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] >= ( ' a ' + min ( N , 25 ) ) M [ S [ i ] ] > 1 ) { if ( V [ j ] < S [ i ] ) continue ; M [ S [ i ] ] -- ; S [ i ] = V [ j ] ; j -- ; } if ( j < 0 ) break ; } int l = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S [ i ] >= ( ' a ' + min ( N , 25 ) ) M [ S [ i ] ] > 1 ) { M [ S [ i ] ] -- ; S [ i ] = V [ l ] ; l ++ ; } } return S ; } int main ( ) { string S = \" abccefghh \" ; int N = S . length ( ) ; cout << lexicographicallyMaximum ( S , N ) ; return 0 ; }"}
{"text": "Semak jika mana -mana subarray boleh dibuat palindromic dengan menggantikan kurang daripada separuh elemennya | Program C ++ untuk pendekatan di atas; Fungsi utiliti untuk memeriksa sama ada subarray boleh menjadi palindromic dengan menggantikan kurang daripada separuh unsur yang ada di dalamnya; Kedai kekerapan elemen array; Melintasi array; Kekerapan kemas kini setiap elemen array; Iterator di atas peta; Jika kekerapan mana -mana elemen melebihi 1; Sekiranya tiada pengulangan dijumpai; Berfungsi untuk memeriksa dan mencetak jika mana -mana subarray boleh dibuat palindromic dengan menggantikan kurang daripada separuh elemennya; Kod pemacu; Diberikan array arr []; Saiz array; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isConsistingSubarrayUtil ( int arr [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ arr [ i ] ] ++ ; } map < int , int > :: iterator it ; for ( it = mp . begin ( ) ; it != mp . end ( ) ; ++ it ) { if ( it -> second > 1 ) { return true ; } } return false ; } void isConsistingSubarray ( int arr [ ] , int N ) { if ( isConsistingSubarrayUtil ( arr , N ) ) { cout << \" Yes \" << endl ; } else { cout << \" No \" << endl ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isConsistingSubarray ( arr , N ) ; return 0 ; }"}
{"text": "Nombor Fibonacci Komposit dari Arahan yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari semua nombor Fibonacci sehingga maks; Simpan semua nombor Fibonacci sehingga max; Kedai elemen sebelumnya dari urutan Fibonacci; Kedai elemen sebelumnya dari urutan Fibonacci; Masukkan prev ke hashmap; Masukkan semua nombor Fibonacci sehingga maks; Masukkan curr ke hashmap; Kedai -kedai Curr Into Temp; Kemas kini curr; UPDATE PREV; Berfungsi untuk mencari semua nombor komposit sehingga maks; Isprime [i]: Kedai jika saya adalah nombor utama atau tidak; Kirakan semua nombor perdana sehingga maksimum menggunakan penapis eratosthenes; Jika p adalah nombor utama; Tetapkan semua pelbagai p sebagai bukan perdana; Kemas kini isprime; Fungsi untuk mencari nombor yang merupakan nombor komposit dan fibonacci; Menyimpan elemen terbesar array; Melintasi array arr []; Kemas kini Max; isprim [i] periksa saya adalah nombor utama atau tidak; Menyimpan semua nombor Fibonacci; Melintasi array arr []; Elemen semasa bukan nombor komposit; Jika elemen semasa adalah nombor fibonacci dan komposit; Cetak elemen semasa; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; set < int > createhashmap ( int Max ) { set < int > hashmap ; int curr = 1 ; int prev = 0 ; hashmap . insert ( prev ) ; while ( curr <= Max ) { hashmap . insert ( curr ) ; int temp = curr ; curr = curr + prev ; prev = temp ; } return hashmap ; } vector < bool > SieveOfEratosthenes ( int Max ) { vector < bool > isPrime ( Max , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= Max ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= Max ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; } int cntFibonacciPrime ( int arr [ ] , int N ) { int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { Max = max ( Max , arr [ i ] ) ; } vector < bool > isPrime = SieveOfEratosthenes ( Max ) ; set < int > hashmap = createhashmap ( Max ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) continue ; if ( ( hashmap . count ( arr [ i ] ) ) && ! isPrime [ arr [ i ] ] ) { cout << arr [ i ] << \" ▁ \" ; } } } int main ( ) { int arr [ ] = { 13 , 55 , 7 , 3 , 5 , 21 , 233 , 144 , 89 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cntFibonacciPrime ( arr , N ) ; return 0 ; }"}
{"text": "Kurangkan nombor yang diberikan untuk membentuk kunci oleh operasi yang diberikan | C ++ program pendekatan di atas; Berfungsi untuk mencari kunci nombor yang diberikan; Tukar integer ke rentetan; Melepasi rentetan num untuk mendapatkan hasilnya; Semak sama ada digit adalah atau ganjil; Berulang sehingga jumlah ganjil diperolehi dengan menambahkan digit berturut -turut; Semak jika jumlahnya menjadi ganjil; Tambah hasil dalam ANS; Berikan indeks digit ke rentetan NUM; Jika nombor itu ganjil; Berulang sehingga jumlah ganjil diperolehi dengan menambahkan digit berturut -turut; Semak sama ada jumlahnya menjadi walaupun; Tambah hasil dalam ANS; Berikan indeks digit ke numstring utama; Periksa sama ada semua digit dikunjungi atau tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int key ( int N ) { string num = \" \" + to_string ( N ) ; int ans = 0 ; int j = 0 ; for ( j = 0 ; j < num . length ( ) ; j ++ ) { if ( ( num [ j ] - 48 ) % 2 == 0 ) { int add = 0 ; int i ; for ( i = j ; j < num . length ( ) ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 1 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) floor ( log10 ( add ) + 1 ) ; ans *= ( pow ( 10 , digit ) ) ; ans += add ; } i = j ; } else { int add = 0 ; int i ; for ( i = j ; j < num . length ( ) ; j ++ ) { add += num [ j ] - 48 ; if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) floor ( log10 ( add ) + 1 ) ; ans *= ( pow ( 10 , digit ) ) ; ans += add ; } i = j ; } } if ( j + 1 >= num . length ( ) ) { return ans ; } else { return ans += num [ num . length ( ) - 1 ] - 48 ; } } int main ( ) { int N = 1667848271 ; cout << key ( N ) ; return 0 ; }"}
{"text": "Sentinel Linear Search | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari x dalam array yang diberikan; Elemen terakhir array; Unsur yang akan dicari diletakkan pada indeks terakhir; Letakkan elemen terakhir kembali; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; void sentinelSearch ( int arr [ ] , int n , int key ) { int last = arr [ n - 1 ] ; arr [ n - 1 ] = key ; int i = 0 ; while ( arr [ i ] != key ) i ++ ; arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) cout << key << \" ▁ is ▁ present ▁ at ▁ index ▁ \" << i ; else cout << \" Element ▁ Not ▁ found \" ; } int main ( ) { int arr [ ] = { 10 , 20 , 180 , 30 , 60 , 50 , 110 , 100 , 70 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 180 ; sentinelSearch ( arr , n , key ) ; return 0 ; }"}
{"text": "Unsur pertengahan maksimum yang mungkin selepas memadam Elements Kepatnya | C ++ pelaksanaan pendekatan; Fungsi untuk mengira nilai tengah maksimum yang mungkin dari array selepas memadam elemen K tepat; Memulakan jawapan sebagai - 1; Hitung pelbagai elemen yang boleh memberikan nilai tengah maksimum yang mungkin dari array kerana indeks nilai maksimum yang mungkin ditengah selepas memadam elemen k tepat dari array akan terletak di antara rendah dan tinggi; Cari elemen maksimum array dalam jarak rendah dan tinggi; Oleh kerana pengindeksan adalah 1 berasaskan jadi elemen semak pada indeks I - 1; Kembalikan nilai tengah maksimum yang mungkin dari array selepas memadam elemen K tepat dari array; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximum_middle_value ( int n , int k , int arr [ ] ) { int ans = -1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = max ( ans , arr [ i - 1 ] ) ; } return ans ; } int main ( ) { int n = 5 , k = 2 ; int arr [ ] = { 9 , 5 , 3 , 7 , 10 } ; cout << maximum_middle_value ( n , k , arr ) << endl ; n = 9 ; k = 3 ; int arr1 [ ] = { 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 } ; cout << maximum_middle_value ( n , k , arr1 ) << endl ; return 0 ; }"}
{"text": "Carian Ternary | Program C ++ untuk menggambarkan pendekatan rekursif untuk carian ternary; Berfungsi untuk melakukan carian ternary; Cari Mid1 dan Mid2; Semak sama ada kunci hadir di mana -mana pertengahan; Oleh kerana kunci tidak hadir pada pertengahan, periksa di mana rantau ia hadir kemudian ulangi operasi carian di rantau itu; Kunci terletak di antara L dan MID1; Kunci terletak di antara Mid2 dan R; Kuncinya terletak di antara Mid1 dan Mid2; Kunci tidak dijumpai; Kod pemacu; Dapatkan array jenis array jika tidak disusun; Indeks permulaan; panjang array; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int ternarySearch ( int l , int r , int key , int ar [ ] ) { if ( r >= l ) { int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) { return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else { return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } } return -1 ; } int main ( ) { int l , r , p , key ; int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; l = 0 ; r = 9 ; key = 5 ; p = ternarySearch ( l , r , key , ar ) ; cout << \" Index ▁ of ▁ \" << key << \" ▁ is ▁ \" << p << endl ; key = 50 ; p = ternarySearch ( l , r , key , ar ) ; cout << \" Index ▁ of ▁ \" << key << \" ▁ is ▁ \" << p << endl ; }"}
{"text": "Bilangan minimum mata yang akan dikeluarkan untuk mendapatkan mata yang tinggal di satu sisi paksi | Program CPP untuk mencari mata minimum untuk dipindahkan supaya semua mata berada di sisi yang sama. ; Struktur untuk menyimpan koordinat satu titik. ; Berfungsi untuk mencari bilangan minimum mata; Bilangan mata di sebelah kiri y - paksi. ; Bilangan mata di sebelah kanan paksi y. ; Bilangan mata di atas x - paksi. ; Bilangan mata di bawah x - paksi. ; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long ll ; struct Point { int x , y ; } ; int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return min ( { a , b , c , d } ) ; } int main ( ) { Point p [ ] = { { 1 , 1 } , { 2 , 2 } , { -1 , -1 } , { -2 , 2 } } ; int n = sizeof ( p ) / sizeof ( p [ 0 ] ) ; cout << findmin ( p , n ) ; return 0 ; }"}
{"text": "Bilangan maksimum pengurangan pasangan yang mungkin pada triplet tertentu | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan maksimum pengurangan pasangan yang mungkin pada triplet tertentu; Tukar mereka menjadi array; Kedai kiraan operasi; Susun array; Jika dua elemen array pertama berkurangan kepada 0; Memohon operasi; Kiraan kenaikan; Cetak kiraan maksimum; Kod pemacu; Diberikan triplet", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxOps ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; int count = 0 ; while ( 1 ) { sort ( arr , arr + 3 ) ; if ( ! arr [ 0 ] && ! arr [ 1 ] ) break ; arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ; count += 1 ; } cout << count ; } int main ( ) { int a = 4 , b = 3 , c = 2 ; maxOps ( a , b , c ) ; return 0 ; }"}
{"text": "Kes | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang disusun; Untuk menyimpan frekuensi huruf kecil dan aksara huruf besar dalam rentetan yang diberikan; Jika watak semasa adalah huruf kecil maka kenaikan kekerapannya dalam array yang lebih rendah []; Lain kenaikan dalam array atas []; Petunjuk yang menunjuk pada huruf kecil terkecil dan watak -watak huruf kecil terkecil masing -masing dalam rentetan yang diberikan; Untuk setiap watak dalam rentetan yang diberikan; Jika watak semasa adalah huruf kecil kemudian gantikannya dengan watak kecil terkecil yang tersedia; Pengurangan kekerapan watak yang digunakan; Lain menggantikannya dengan watak huruf kecil terkecil yang ada; Pengurangan kekerapan watak yang digunakan; Kembalikan rentetan yang disusun; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE string getSortedString ( string s , int n ) { int lower [ MAX ] = { 0 } ; int upper [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( islower ( s [ i ] ) ) lower [ s [ i ] - ' a ' ] ++ ; else if ( isupper ( s [ i ] ) ) upper [ s [ i ] - ' A ' ] ++ ; } int i = 0 , j = 0 ; while ( i < MAX && lower [ i ] == 0 ) i ++ ; while ( j < MAX && upper [ j ] == 0 ) j ++ ; for ( int k = 0 ; k < n ; k ++ ) { if ( islower ( s [ k ] ) ) { while ( lower [ i ] == 0 ) i ++ ; s [ k ] = ( char ) ( i + ' a ' ) ; lower [ i ] -- ; } else if ( isupper ( s [ k ] ) ) { while ( upper [ j ] == 0 ) j ++ ; s [ k ] = ( char ) ( j + ' A ' ) ; upper [ j ] -- ; } } return s ; } int main ( ) { string s = \" gEeksfOrgEEkS \" ; int n = s . length ( ) ; cout << getSortedString ( s , n ) ; return 0 ; }"}
{"text": "Cetak watak dan frekuensi mereka mengikut urutan kejadian | C ++ pelaksanaan untuk mencetak watak dan kekerapannya mengikut urutan kejadiannya; berfungsi untuk mencetak watak dan kekerapannya mengikut urutan kejadiannya; saiz rentetan 'str'; 'freq []' dilaksanakan sebagai jadual hash; memulakan semua elemen freq [] hingga 0; mengumpul kekerapan setiap watak dalam 'str'; melintasi 'str' dari kiri ke kanan; jika kekerapan watak str [i] tidak sama dengan 0; Cetak watak bersama kekerapannya; Kemas kini kekerapan STR [i] hingga 0 supaya watak yang sama tidak dicetak lagi; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE void printCharWithFreq ( string str ) { int n = str . size ( ) ; int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] != 0 ) { cout << str [ i ] << freq [ str [ i ] - ' a ' ] << \" ▁ \" ; freq [ str [ i ] - ' a ' ] = 0 ; } } } int main ( ) { string str = \" geeksforgeeks \" ; printCharWithFreq ( str ) ; return 0 ; }"}
{"text": "Kata -kata terbalik dalam rentetan yang diberikan | Program c ++ untuk membalikkan rentetan s = input ()", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { string s [ ] = { \" i \" , \" like \" , \" this \" , \" program \" , \" very \" , \" much \" } ; string ans = \" \" ; for ( int i = 5 ; i >= 0 ; i -- ) { ans += s [ i ] + \" ▁ \" ; } cout << ( \" Reversed ▁ String : \" ) << endl ; cout << ( ans . substr ( 0 , ans . length ( ) - 1 ) ) << endl ; return 0 ; }"}
{"text": "Mengasingkan Perdana dan Bukan | Program C ++ untuk pendekatan di atas; Berfungsi untuk menjana nombor perdana menggunakan ayak eratosthenes; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Berfungsi untuk memisahkan prima dan bukan prima; Menjana semua prima sehingga 10 ^ 7; Memulakan kiri dan kanan; Melintasi array; Peningkatan kiri manakala elemen array di sebelah kiri adalah perdana; Pengurangan betul manakala elemen array di sebelah kanan adalah bukan perdana; Jika kiri <kanan, kemudian swap arr [kiri] dan arr [kanan]; Swap arr [kiri] dan arr [kanan]; Cetak array terasing; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; bool prime [ 10000001 ] ; void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } void segregatePrimeNonPrime ( int arr [ ] , int N ) { SieveOfEratosthenes ( 10000000 ) ; int left = 0 , right = N - 1 ; while ( left < right ) { while ( prime [ arr [ left ] ] ) left ++ ; while ( ! prime [ arr [ right ] ] ) right -- ; if ( left < right ) { swap ( & arr [ left ] , & arr [ right ] ) ; left ++ ; right -- ; } } for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 6 , 7 , 8 , 9 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregatePrimeNonPrime ( arr , N ) ; return 0 ; }"}
{"text": "Hitung kedalaman pokok binari penuh dari preorder | Program C ++ untuk mencari ketinggian pokok binari penuh menggunakan preorder; berfungsi untuk mengembalikan maksimum ketinggian subtree kiri atau ketinggian subtree kanan; ketinggian calc subtree kiri (dalam preorder kiri subtree diproses sebelum kanan); ketinggian calc subtree kanan; Pembalut ke atas findDepThrec (); Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDepthRec ( char tree [ ] , int n , int & index ) { if ( index >= n tree [ index ] == ' l ' ) return 0 ; index ++ ; int left = findDepthRec ( tree , n , index ) ; index ++ ; int right = findDepthRec ( tree , n , index ) ; return max ( left , right ) + 1 ; } int findDepth ( char tree [ ] , int n ) { int index = 0 ; findDepthRec ( tree , n , index ) ; } int main ( ) { char tree [ ] = \" nlnnlll \" ; int n = strlen ( tree ) ; cout << findDepth ( tree , n ) << endl ; return 0 ; }"}
{"text": "Nombor terbesar di BST yang kurang daripada atau sama dengan N | C ++ kod untuk mencari nilai terbesar yang lebih kecil daripada atau sama dengan n; Struktur nod; Untuk membuat nod BST baru; Untuk memasukkan nod baru di BST; Jika pokok kosong kembali nod baru; Jika kunci kurang atau lebih besar maka nilai nod maka mengulangi pokok itu; Kembalikan penunjuk nod (tidak berubah); fungsi untuk mencari nilai maksimum kurang kemudian n; Kes asas; Jika nilai root lebih kecil, cuba subtree kanan; Jika kekunci Root lebih besar, nilai pulangan dari subtree kiri. ; Kod pemacu; Mencipta BST 5 / \\ 2 12 / \\ / \\ 1 3 9 21 / \\ 19 25", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; return node ; } int findMaxforN ( Node * root , int N ) { if ( root == NULL ) return -1 ; if ( root -> key == N ) return N ; else if ( root -> key < N ) { int k = findMaxforN ( root -> right , N ) ; if ( k == -1 ) return root -> key ; else return k ; } else if ( root -> key > N ) return findMaxforN ( root -> left , N ) ; } int main ( ) { int N = 4 ; Node * root = insert ( root , 25 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; printf ( \" % d \" , findMaxforN ( root , N ) ) ; return 0 ; }"}
{"text": "Nombor terbesar di BST yang kurang daripada atau sama dengan N | C ++ kod untuk mencari nilai terbesar yang lebih kecil daripada atau sama dengan n; Untuk membuat nod BST baru; Untuk memasukkan nod baru di BST; Jika pokok kosong kembali nod baru; Jika kunci kurang atau lebih besar maka nilai nod maka mengulangi pokok itu; Kembalikan penunjuk nod (tidak berubah); fungsi untuk mencari nilai maksimum kurang kemudian n; Mulakan dari akar dan terus mencari lebih besar; Jika akar lebih kecil pergi ke sebelah kanan; Jika akar lebih besar pergi ke sebelah kiri; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; return node ; } void findMaxforN ( Node * root , int N ) { while ( root != NULL && root -> right != NULL ) { if ( N > root -> key && N >= root -> right -> key ) root = root -> right ; else if ( N < root -> key ) root = root -> left ; else break ; } if ( root == NULL root -> key > N ) cout << -1 ; else cout << root -> key ; } int main ( ) { int N = 50 ; Node * root = insert ( root , 5 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; findMaxforN ( root , N ) ; return 0 ; }"}
{"text": "Unsur maksimum antara dua nod BST | Program C ++ untuk mencari elemen maksimum di jalan antara dua nod pokok carian binari. ; Buat dan kembalikan penunjuk nod baru. ; Masukkan nod baru dalam pokok carian binari. ; Kembalikan elemen maksimum antara nod dan nenek moyangnya. ; Melintasi jalan antara ansektor dan nod dan mencari elemen maksimum. ; Pulangan elemen maksimum di jalan antara dua nod yang diberikan BST. ; Mencari LCA Node X dan Node Y; Memeriksa jika kedua -dua nod terletak di sebelah kiri ibu bapa p. ; Memeriksa jika kedua -dua nod terletak di sebelah kanan ibu bapa p. ; Kembalikan maksimum elemen maksimum berlaku di jalan dari nenek moyang ke kedua -dua nod. ; Kod pemacu; Mewujudkan akar pokok carian binari; Memasukkan nod dalam pokok carian binari", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int data ; } ; Node * createNode ( int x ) { Node * p = new Node ; p -> data = x ; p -> left = p -> right = NULL ; return p ; } void insertNode ( struct Node * root , int x ) { Node * p = root , * q = NULL ; while ( p != NULL ) { q = p ; if ( p -> data < x ) p = p -> right ; else p = p -> left ; } if ( q == NULL ) p = createNode ( x ) ; else { if ( q -> data < x ) q -> right = createNode ( x ) ; else q -> left = createNode ( x ) ; } } int maxelpath ( Node * q , int x ) { Node * p = q ; int mx = INT_MIN ; while ( p -> data != x ) { if ( p -> data > x ) { mx = max ( mx , p -> data ) ; p = p -> left ; } else { mx = max ( mx , p -> data ) ; p = p -> right ; } } return max ( mx , x ) ; } int maximumElement ( struct Node * root , int x , int y ) { Node * p = root ; while ( ( x < p -> data && y < p -> data ) || ( x > p -> data && y > p -> data ) ) { if ( x < p -> data && y < p -> data ) p = p -> left ; else if ( x > p -> data && y > p -> data ) p = p -> right ; } return max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; } int main ( ) { int arr [ ] = { 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 } ; int a = 1 , b = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; struct Node * root = createNode ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) insertNode ( root , arr [ i ] ) ; cout << maximumElement ( root , a , b ) << endl ; return 0 ; }"}
{"text": "Pokok binari yang diulurkan | Penyisipan | Penyisipan dalam pokok carian binari berulir. ; Benar jika penunjuk kiri titik kepada pendahulunya dalam inorder traversal; Benar jika penunjuk kanan menunjuk kepada pengganti dalam Inorder Traversal; Masukkan nod dalam pokok berulir binari; Mencari nod dengan nilai yang diberikan; Ibu bapa kunci yang akan dimasukkan; Jika kunci sudah ada, kembali; Mengemas kini penunjuk induk; Bergerak di subtree kiri. ; Bergerak ke Subtree Kanan. ; Buat nod baru; Mengembalikan pengganti inorder menggunakan RTHREAD; Jika RTHREAD ditetapkan, kita dapat dengan cepat mencari; Lain kembali anak paling kiri dari subtree kanan; Mencetak pokok berulir; Mencapai nod paling kiri; Satu demi satu pengganti cetak; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int info ; bool lthread ; bool rthread ; } ; struct Node * insert ( struct Node * root , int ikey ) { Node * ptr = root ; Node * par = NULL ; while ( ptr != NULL ) { if ( ikey == ( ptr -> info ) ) { printf ( \" Duplicate ▁ Key ▁ ! STRNEWLINE \" ) ; return root ; } par = ptr ; if ( ikey < ptr -> info ) { if ( ptr -> lthread == false ) ptr = ptr -> left ; else break ; } else { if ( ptr -> rthread == false ) ptr = ptr -> right ; else break ; } } Node * tmp = new Node ; tmp -> info = ikey ; tmp -> lthread = true ; tmp -> rthread = true ; if ( par == NULL ) { root = tmp ; tmp -> left = NULL ; tmp -> right = NULL ; } else if ( ikey < ( par -> info ) ) { tmp -> left = par -> left ; tmp -> right = par ; par -> lthread = false ; par -> left = tmp ; } else { tmp -> left = par ; tmp -> right = par -> right ; par -> rthread = false ; par -> right = tmp ; } return root ; } struct Node * inorderSuccessor ( struct Node * ptr ) { if ( ptr -> rthread == true ) return ptr -> right ; ptr = ptr -> right ; while ( ptr -> lthread == false ) ptr = ptr -> left ; return ptr ; } void inorder ( struct Node * root ) { if ( root == NULL ) printf ( \" Tree ▁ is ▁ empty \" ) ; struct Node * ptr = root ; while ( ptr -> lthread == false ) ptr = ptr -> left ; while ( ptr != NULL ) { printf ( \" % d ▁ \" , ptr -> info ) ; ptr = inorderSuccessor ( ptr ) ; } } int main ( ) { struct Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; inorder ( root ) ; return 0 ; }"}
{"text": "Pohon Carian Binari Bertulung | Penghapusan |  ; Benar jika penunjuk kiri titik kepada pendahulunya dalam inorder traversal; Benar jika penunjuk yang betul menunjukkan kepada pendahuluan dalam inorder traversal", "code": "struct Node { struct Node * left , * right ; int info ; bool lthread ; bool rthread ; } ;"}
{"text": "Pohon Carian Binari Bertulung | Penghapusan | Di sini 'par' adalah penunjuk kepada nod induk dan 'ptr' adalah penunjuk kepada nod semasa. ; Jika nod dipadam adalah akar; Sekiranya nod dihapuskan adalah tersisa dari ibu bapanya", "code": "struct Node * caseA ( struct Node * root , struct Node * par , struct Node * ptr ) { if ( par == NULL ) root = NULL ; else if ( ptr == par -> left ) { par -> lthread = true ; par -> left = ptr -> left ; } else { par -> rthread = true ; par -> right = ptr -> right ; } free ( ptr ) ; return root ; }"}
{"text": "Pohon Carian Binari Bertulung | Penghapusan | Di sini 'par' adalah penunjuk kepada nod induk dan 'ptr' adalah penunjuk kepada nod semasa. ; Inisialisasi nod kanak -kanak yang akan dipadam telah meninggalkan anak. ; Node untuk dipadam mempunyai anak yang betul. ; Node yang akan dipadam adalah nod akar. ; Node dibiarkan anak ibu bapanya. ; Cari pengganti dan pendahulu; Jika PTR telah meninggalkan subtree. ; Jika PTR mempunyai subtree yang betul.", "code": "struct Node * caseB ( struct Node * root , struct Node * par , struct Node * ptr ) { struct Node * child ; if ( ptr -> lthread == false ) child = ptr -> left ; else child = ptr -> right ; if ( par == NULL ) root = child ; else if ( ptr == par -> left ) par -> left = child ; else par -> right = child ; Node * s = inSucc ( ptr ) ; Node * p = inPred ( ptr ) ; if ( ptr -> lthread == false ) p -> right = s ; else { if ( ptr -> rthread == false ) s -> left = p ; } free ( ptr ) ; return root ; }"}
{"text": "Pohon Carian Binari Bertulung | Penghapusan | Lengkapkan program C ++ untuk menunjukkan penghapusan dalam BST berulir; Benar jika penunjuk kiri titik kepada pendahulunya dalam inorder traversal; Benar jika penunjuk yang betul menunjuk kepada pendahulunya dalam traversal inorder; Masukkan nod dalam pokok berulir binari; Mencari nod dengan nilai yang diberikan; Ibu bapa kunci yang akan dimasukkan; Jika kunci sudah ada, kembali; Mengemas kini penunjuk induk; Bergerak di subtree kiri. ; Bergerak ke Subtree Kanan. ; Buat nod baru; Mengembalikan pengganti inorder menggunakan kanak -kanak kiri dan kanan (digunakan dalam penghapusan); Mengembalikan pengganti inorder menggunakan RTHREAD (digunakan dalam inorder); Jika RTHREAD ditetapkan, kita dapat dengan cepat mencari; Lain kembali anak paling kiri dari subtree kanan; Mencetak pokok berulir; Mencapai nod paling kiri; Satu demi satu pengganti cetak; Di sini 'par' adalah penunjuk kepada nod induk dan 'ptr' adalah penunjuk kepada nod semasa. ; Jika nod dipadam adalah akar; Jika nod dipadam adalah tersisa daripada ibu bapanya; Di sini 'par' adalah penunjuk kepada nod induk dan 'ptr' adalah penunjuk kepada nod semasa. ; Inisialisasi nod kanak -kanak yang akan dipadam telah meninggalkan anak. ; Node untuk dipadam mempunyai anak yang betul. ; Node yang akan dipadam adalah nod akar. ; Node dibiarkan anak ibu bapanya. ; Cari pengganti dan pendahulu; Jika PTR telah meninggalkan subtree. ; Jika PTR mempunyai subtree yang betul. ; Di sini 'par' adalah penunjuk kepada nod induk dan 'ptr' adalah penunjuk kepada nod semasa. ; Cari pengganti inorder dan ibu bapanya. ; Cari anak paling kiri pengganti; Menghapus kunci dari BST berulir dengan akar yang diberikan dan mengembalikan akar baru BST. ; Inisialisasi ibu bapa sebagai nod null dan ptrent sebagai akar. ; Tetapkan benar jika kunci dijumpai; Kunci carian di BST: Cari nod dan ibu bapanya. ; Dua kanak -kanak; Hanya anak kiri; Hanya anak yang betul; Tiada anak; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int info ; bool lthread ; bool rthread ; } ; struct Node * insert ( struct Node * root , int ikey ) { Node * ptr = root ; Node * par = NULL ; while ( ptr != NULL ) { if ( ikey == ( ptr -> info ) ) { printf ( \" Duplicate ▁ Key ▁ ! STRNEWLINE \" ) ; return root ; } par = ptr ; if ( ikey < ptr -> info ) { if ( ptr -> lthread == false ) ptr = ptr -> left ; else break ; } else { if ( ptr -> rthread == false ) ptr = ptr -> right ; else break ; } } Node * tmp = new Node ; tmp -> info = ikey ; tmp -> lthread = true ; tmp -> rthread = true ; if ( par == NULL ) { root = tmp ; tmp -> left = NULL ; tmp -> right = NULL ; } else if ( ikey < ( par -> info ) ) { tmp -> left = par -> left ; tmp -> right = par ; par -> lthread = false ; par -> left = tmp ; } else { tmp -> left = par ; tmp -> right = par -> right ; par -> rthread = false ; par -> right = tmp ; } return root ; } struct Node * inSucc ( struct Node * ptr ) { if ( ptr -> rthread == true ) return ptr -> right ; ptr = ptr -> right ; while ( ptr -> lthread == false ) ptr = ptr -> left ; return ptr ; } struct Node * inorderSuccessor ( struct Node * ptr ) { if ( ptr -> rthread == true ) return ptr -> right ; ptr = ptr -> right ; while ( ptr -> lthread == false ) ptr = ptr -> left ; return ptr ; } void inorder ( struct Node * root ) { if ( root == NULL ) printf ( \" Tree ▁ is ▁ empty \" ) ; struct Node * ptr = root ; while ( ptr -> lthread == false ) ptr = ptr -> left ; while ( ptr != NULL ) { printf ( \" % d ▁ \" , ptr -> info ) ; ptr = inorderSuccessor ( ptr ) ; } } struct Node * inPred ( struct Node * ptr ) { if ( ptr -> lthread == true ) return ptr -> left ; ptr = ptr -> left ; while ( ptr -> rthread == false ) ptr = ptr -> right ; return ptr ; } struct Node * caseA ( struct Node * root , struct Node * par , struct Node * ptr ) { if ( par == NULL ) root = NULL ; else if ( ptr == par -> left ) { par -> lthread = true ; par -> left = ptr -> left ; } else { par -> rthread = true ; par -> right = ptr -> right ; } free ( ptr ) ; return root ; } struct Node * caseB ( struct Node * root , struct Node * par , struct Node * ptr ) { struct Node * child ; if ( ptr -> lthread == false ) child = ptr -> left ; else child = ptr -> right ; if ( par == NULL ) root = child ; else if ( ptr == par -> left ) par -> left = child ; else par -> right = child ; Node * s = inSucc ( ptr ) ; Node * p = inPred ( ptr ) ; if ( ptr -> lthread == false ) p -> right = s ; else { if ( ptr -> rthread == false ) s -> left = p ; } free ( ptr ) ; return root ; } struct Node * caseC ( struct Node * root , struct Node * par , struct Node * ptr ) { struct Node * parsucc = ptr ; struct Node * succ = ptr -> right ; while ( succ -> lthread == false ) { parsucc = succ ; succ = succ -> left ; } ptr -> info = succ -> info ; if ( succ -> lthread == true && succ -> rthread == true ) root = caseA ( root , parsucc , succ ) ; else root = caseB ( root , parsucc , succ ) ; return root ; } struct Node * delThreadedBST ( struct Node * root , int dkey ) { struct Node * par = NULL , * ptr = root ; int found = 0 ; while ( ptr != NULL ) { if ( dkey == ptr -> info ) { found = 1 ; break ; } par = ptr ; if ( dkey < ptr -> info ) { if ( ptr -> lthread == false ) ptr = ptr -> left ; else break ; } else { if ( ptr -> rthread == false ) ptr = ptr -> right ; else break ; } } if ( found == 0 ) printf ( \" dkey ▁ not ▁ present ▁ in ▁ tree STRNEWLINE \" ) ; else if ( ptr -> lthread == false && ptr -> rthread == false ) root = caseC ( root , par , ptr ) ; else if ( ptr -> lthread == false ) root = caseB ( root , par , ptr ) ; else if ( ptr -> rthread == false ) root = caseB ( root , par , ptr ) ; else root = caseA ( root , par , ptr ) ; return root ; } int main ( ) { struct Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; root = delThreadedBST ( root , 20 ) ; inorder ( root ) ; return 0 ; }"}
{"text": "Semak simetri mendatar dan menegak dalam matriks binari | Program C ++ untuk mencari jika matriks adalah simetri. ; Memulakan sebagai simetri mendatar dan menegak. ; Memeriksa simetri mendatar. Kami membandingkan baris pertama dengan baris terakhir, baris kedua dengan barisan terakhir kedua dan sebagainya. ; Memeriksa setiap sel lajur. ; Semak jika setiap sel adalah sama; Memeriksa simetri menegak. Kami membandingkan lajur pertama dengan lajur terakhir, xolumn kedua dengan lajur terakhir kedua dan sebagainya. ; Memeriksa setiap sel baris. ; Semak jika setiap sel adalah sama; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE #define MAX  1000 NEW_LINE using namespace std ; void checkHV ( int arr [ ] [ MAX ] , int N , int M ) { bool horizontal = true , vertical = true ; for ( int i = 0 , k = N - 1 ; i < N / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } for ( int i = 0 , k = M - 1 ; i < M / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { vertical = false ; break ; } } } if ( ! horizontal && ! vertical ) cout << \" NO STRNEWLINE \" ; else if ( horizontal && ! vertical ) cout << \" HORIZONTAL STRNEWLINE \" ; else if ( vertical && ! horizontal ) cout << \" VERTICAL STRNEWLINE \" ; else cout << \" BOTH STRNEWLINE \" ; } int main ( ) { int mat [ MAX ] [ MAX ] = { { 1 , 0 , 1 } , { 0 , 0 , 0 } , { 1 , 0 , 1 } } ; checkHV ( mat , 3 , 3 ) ; return 0 ; }"}
{"text": "Gantikan setiap elemen matriks dengan maksimum GCD baris atau lajur | Program C ++ untuk menggantikan setiap elemen dengan maksimum GCD baris atau lajur. ; mengembalikan pembahagi biasa dua nombor; Mencari GCD setiap baris dan lajur dan menggantikan dengan setiap elemen dengan maksimum GCD baris atau lajur. ; Mengira GCD setiap baris dan setiap lajur dalam O (Mn) dan simpan dalam tatasusunan. ; Menggantikan elemen matriks; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  4 NEW_LINE int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void replacematrix ( int mat [ R ] [ C ] , int n , int m ) { int rgcd [ R ] = { 0 } , cgcd [ C ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = max ( rgcd [ i ] , cgcd [ j ] ) ; } int main ( ) { int m [ R ] [ C ] = { 1 , 2 , 3 , 3 , 4 , 5 , 6 , 6 , 7 , 8 , 9 , 9 , } ; replacematrix ( m , R , C ) ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) cout << m [ i ] [ j ] << \" ▁ \" ; cout << endl ; } return 0 ; }"}
{"text": "Program untuk penambahan dua matriks | Program C ++ untuk penambahan dua matriks; Fungsi ini menambah [] [] dan b [] [], dan menyimpan hasil dalam c [] []; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; add ( A , B , C ) ; cout << \" Result ▁ matrix ▁ is ▁ \" << endl ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) cout << C [ i ] [ j ] << \" ▁ \" ; cout << endl ; } return 0 ; }"}
{"text": "Program untuk pengurangan matriks | Program C ++ untuk pengurangan matriks; Fungsi ini menolak B [] [] dari [] [], dan menyimpan hasil dalam C [] []; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; subtract ( A , B , C ) ; cout << \" Result ▁ matrix ▁ is ▁ \" << endl ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) cout << C [ i ] [ j ] << \" ▁ \" ; cout << endl ; } return 0 ; }"}
{"text": "Cari titik tetap (nilai sama dengan indeks) dalam array yang diberikan | Program C ++ untuk memeriksa titik tetap dalam array menggunakan carian linear; Jika tiada titik tetap hadir kemudian kembali - 1; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Fixed ▁ Point ▁ is ▁ \" << linearSearch ( arr , n ) ; return 0 ; }"}
{"text": "Cari titik tetap (nilai sama dengan indeks) dalam array yang diberikan | Program C ++ untuk memeriksa titik tetap dalam array menggunakan carian binari; rendah + (tinggi - rendah) / 2; ; Kembali - 1 jika tiada titik tetap; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return -1 ; } int main ( ) { int arr [ 10 ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Fixed ▁ Point ▁ is ▁ \" << binarySearch ( arr , 0 , n - 1 ) ; return 0 ; }"}
{"text": "Jumlah maksimum triplet dalam array | C ++ kod untuk mencari jumlah triplet maksimum; Memulakan jumlah dengan int_min; Kod yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { int sum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }"}
{"text": "Jumlah maksimum triplet dalam array | C ++ kod untuk mencari jumlah triplet maksimum; Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya tiga elemen dalam ARR []. ; Susun array yang diberikan; Selepas menyusun array. Tambah tiga elemen terakhir dari array yang diberikan; Kod yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }"}
{"text": "Jumlah maksimum triplet dalam array | C ++ kod untuk mencari jumlah triplet maksimum; Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya tiga elemen dalam ARR []. ; Memulakan elemen maksimum maksimum dan maksimum maksimum maksimum; Mengemas kini elemen maksimum maksimum dan ketiga; Mengemas kini elemen maksimum maksimum dan ketiga; Mengemas kini elemen maksimum ketiga; Kod yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { int maxA = INT_MIN , maxB = INT_MIN , maxC = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }"}
{"text": "Carian Linear | C ++ kod ke linear cari x dalam arr []. Jika x hadir kemudian kembalikan lokasi, jika tidak, pulangan - 1; Kod pemacu; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int result = search ( arr , n , x ) ; ( result == -1 ) ? cout << \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" : cout << \" Element ▁ is ▁ present ▁ at ▁ index ▁ \" << result ; return 0 ; }"}
{"text": "Carian Linear | Program C ++ untuk carian linear; Jalankan gelung dari 0 ke kanan; Jika search_element ditemui dengan pembolehubah kiri; Jika search_element ditemui dengan pemboleh ubah yang betul; Jika elemen tidak dijumpai; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void search ( vector < int > arr , int search_Element ) { int left = 0 ; int length = arr . size ( ) ; int position = -1 ; int right = length - 1 ; for ( left = 0 ; left <= right ; ) { if ( arr [ left ] == search_Element ) { position = left ; cout << \" Element ▁ found ▁ in ▁ Array ▁ at ▁ \" << position + 1 << \" ▁ Position ▁ with ▁ \" << left + 1 << \" ▁ Attempt \" ; break ; } if ( arr [ right ] == search_Element ) { position = right ; cout << \" Element ▁ found ▁ in ▁ Array ▁ at ▁ \" << position + 1 << \" ▁ Position ▁ with ▁ \" << length - right << \" ▁ Attempt \" ; break ; } left ++ ; right -- ; } if ( position == -1 ) cout << \" Not ▁ found ▁ in ▁ Array ▁ with ▁ \" << left << \" ▁ Attempt \" ; } int main ( ) { vector < int > arr { 1 , 2 , 3 , 4 , 5 } ; int search_element = 5 ; search ( arr , search_element ) ; }"}
{"text": "Mengira jenis | Program C ++ untuk mengira jenis; Fungsi utama yang menyusun rentetan yang diberikan [] dalam susunan abjad; Pelbagai watak output yang akan menyusun ARR; Buat array kiraan untuk menyimpan kiraan aksara individu dan memulakan array kiraan sebagai 0; Menyimpan kiraan setiap watak; Tukar kiraan [i] supaya kiraan [i] kini mengandungi kedudukan sebenar watak ini dalam pelbagai output; Membina array watak output; Salin array output ke ARR, supaya ARR kini mengandungi aksara yang disusun; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; #define RANGE  255 NEW_LINE void countSort ( char arr [ ] ) { char output [ strlen ( arr ) ] ; int count [ RANGE + 1 ] , i ; memset ( count , 0 , sizeof ( count ) ) ; for ( i = 0 ; arr [ i ] ; ++ i ) ++ count [ arr [ i ] ] ; for ( i = 1 ; i <= RANGE ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( i = 0 ; arr [ i ] ; ++ i ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( i = 0 ; arr [ i ] ; ++ i ) arr [ i ] = output [ i ] ; } int main ( ) { char arr [ ] = \" geeksforgeeks \" ; countSort ( arr ) ; cout << \" Sorted ▁ character ▁ array ▁ is ▁ \" << arr ; return 0 ; }"}
{"text": "Mengira jenis | Jenis pengiraan yang mengambil nombor negatif juga; Fungsi yang menyusun ARR []; berfungsi untuk mencetak array; Kod pemacu", "code": "#include <algorithm> NEW_LINE #include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void countSort ( vector < int > & arr ) { int max = * max_element ( arr . begin ( ) , arr . end ( ) ) ; int min = * min_element ( arr . begin ( ) , arr . end ( ) ) ; int range = max - min + 1 ; vector < int > count ( range ) , output ( arr . size ( ) ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) count [ arr [ i ] - min ] ++ ; for ( int i = 1 ; i < count . size ( ) ; i ++ ) count [ i ] += count [ i - 1 ] ; for ( int i = arr . size ( ) - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] - min ] - 1 ] = arr [ i ] ; count [ arr [ i ] - min ] -- ; } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) arr [ i ] = output [ i ] ; } void printArray ( vector < int > & arr ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) cout << arr [ i ] << \" ▁ \" ; cout << \" STRNEWLINE \" ; } int main ( ) { vector < int > arr = { -5 , -10 , 0 , -3 , 8 , 5 , -1 , 10 } ; countSort ( arr ) ; printArray ( arr ) ; return 0 ; }"}
{"text": "Koefisien binomial | DP | Pelaksanaan C ++ rekursif naif; Pulangan nilai pekali binomial c (n, k); Kes asas; Berulang; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; } int main ( ) { int n = 5 , k = 2 ; cout << \" Value ▁ of ▁ C ( \" << n << \" , ▁ \" << k << \" ) ▁ is ▁ \" << binomialCoeff ( n , k ) ; return 0 ; }"}
{"text": "Koefisien binomial | DP | Program C ++ untuk Penyelesaian Pengaturcaraan Dinamik Dioptimumkan Ruang Koefisien Binomial; NC0 adalah 1; Kirakan baris seterusnya segitiga Pascal menggunakan baris sebelumnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int main ( ) { int n = 5 , k = 2 ; printf ( \" Value ▁ of ▁ C ( % d , ▁ % d ) ▁ is ▁ % d ▁ \" , n , k , binomialCoeff ( n , k ) ) ; return 0 ; }"}
{"text": "Koefisien binomial | DP | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari pekali binomial; Mendapatkan penyongsangan modular untuk semua nombor dari 2 hingga R berkenaan dengan M di sini M = 1000000007; untuk 1 / (r!) Bahagian; untuk (n) * (n - 1) * (n - 2) * ... * (n - r + 1) bahagian; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long long int m = 1000000007 ; long long int inv [ r + 1 ] = { 0 } ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ m % i ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; } int main ( ) { int n = 5 , r = 2 ; cout << \" Value ▁ of ▁ C ( \" << n << \" , ▁ \" << r << \" ) ▁ is ▁ \" << binomialCoeff ( n , r ) << endl ; return 0 ; }"}
{"text": "Masalah Partition | DP | Program C ++ berasaskan pengaturcaraan yang dinamik untuk masalah partition; Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah semua elemen; Permulaan array bahagian sebagai 0; Isi jadual partition dengan cara bawah; Unsur yang akan dimasukkan dalam jumlah tidak boleh lebih besar daripada jumlahnya; Semak jika jumlah - arr [i] boleh dibentuk dari subset menggunakan elemen sebelum indeks I; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == 1 j == arr [ i ] ) part [ j ] = 1 ; } } return part [ sum / 2 ] ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << \" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ \" \" sum \" ; else cout << \" Can ▁ not ▁ be ▁ divided ▁ into \" << \" ▁ two ▁ subsets ▁ of ▁ equal ▁ sum \" ; return 0 ; }"}
{"text": "Pengaturcaraan Dinamik | Penyelesaian rekursif untuk masalah jumlah subset; Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut: (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Kod pemacu", "code": "#include <stdio.h> NEW_LINE bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) ; else printf ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) ; return 0 ; }"}
{"text": "Pengaturcaraan Dinamik | Penyelesaian pengaturcaraan dinamik untuk masalah jumlah subset; Pulangan benar jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara Botton; Jadual Cetak; Kod pemacu", "code": "#include <stdio.h> NEW_LINE bool isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( \" % 4d \" , subset [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } return subset [ n ] [ sum ] ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) ; else printf ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) ; return 0 ; }"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Program C ++ rekursif untuk mencetak bilangan maksimum A menggunakan empat kunci berikut; Fungsi rekursif yang mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7; Memulakan hasil; Cuba semua rehat yang mungkin - mata untuk mana -mana kekunci n, kita perlu gelung dari n - 3 kekunci kembali ke 1 keystroke untuk mencari breakpoint 'b' selepas itu kita akan mempunyai ctrl - a, ctrl - c dan kemudian hanya ctrl - v sepanjang jalan. ; Jika titik putus adalah s pada b 'th keystroke maka rentetan optimum akan mempunyai panjang (n-b-1)*skrin [b-1]; ; Program pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) cout << \" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ \" << N << \" ▁ keystrokes ▁ is ▁ \" << findoptimal ( N ) << endl ; }"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Program C berasaskan pengaturcaraan yang dinamik untuk mencari bilangan maksimum A yang boleh dicetak menggunakan empat kunci; Fungsi ini mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7; Array untuk menyimpan hasil subproblem; Untuk memilih titik putus; Memulakan Arus Panjang Optimal untuk Uptil 6 Strok Input. ; Selesaikan semua subproblem dengan cara bawah; Memulakan panjang rentetan optimum untuk ketukan n; Untuk mana -mana kekunci n, kita perlu gelung dari n - 3 ketukan kembali ke 1 keystroke untuk mencari breakpoint 'b' selepas itu kita akan mempunyai ctrl - a, ctrl - c dan kemudian hanya ctrl - v sepanjang jalan. ; Sekiranya titik putus berada di b 'th keystroke maka rentetan optimum akan mempunyai panjang (n-b-1)*skrin [b-1]; ; Program pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "#include <iostream> NEW_LINE using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) cout << \" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ \" << N << \" ▁ keystrokes ▁ is ▁ \" << findoptimal ( N ) << endl ; }"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Program C ++ berasaskan pengaturcaraan yang dinamik untuk mencari bilangan maksimum yang boleh dicetak menggunakan empat kunci; Fungsi ini mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7; Array untuk menyimpan hasil subproblem; Untuk memilih titik putus; Memulakan Arus Panjang Optimal untuk Uptil 6 Strok Input. ; Selesaikan semua subproblem dengan cara bawah; Untuk mana -mana kekunci n, kita perlu memilih antara: - 1. Menekan Ctrl - V sekali selepas menyalin A 'yang diperolehi oleh ~ 3. ~ 2. Tekan ~ Ctrl - V ~ Dua kali ~ Selepas menyalin 'S yang diperolehi oleh N - 4 Keystrokes. 3. Menekan Ctrl - V tiga kali selepas menyalin A 'S yang diperolehi oleh N -5 Keystrokes. ; Program pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) printf ( \" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ % d ▁ keystrokes ▁ is ▁ % d STRNEWLINE \" , N , findoptimal ( N ) ) ; }"}
{"text": "Tulis program untuk mengira POW (x, n) | Program C ++ untuk mengira POW (x, n); Fungsi untuk mengira x yang dibangkitkan kepada kuasa y; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; class gfg { public : int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } } ; int main ( ) { gfg g ; int x = 2 ; unsigned int y = 3 ; cout << g . power ( x , y ) ; return 0 ; }"}
{"text": "Tulis program untuk mengira POW (x, n) | Berfungsi untuk mengira x yang dibangkitkan kepada kuasa y dalam o (logn)", "code": "int power ( int x , unsigned int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }"}
{"text": "Tulis program untuk mengira POW (x, n) | Versi fungsi kuasa yang dilanjutkan yang boleh berfungsi untuk Float X dan negatif y; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } } int main ( ) { float x = 2 ; int y = -3 ; cout << power ( x , y ) ; return 0 ; }"}
{"text": "Tulis program untuk mengira POW (x, n) | Program C ++ untuk pendekatan di atas; Jika x ^ 0 kembali 1; Jika kita perlu mencari 0 ^ y; Untuk semua kes lain; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; } int main ( ) { int x = 2 ; int y = 3 ; cout << ( power ( x , y ) ) ; }"}
{"text": "Tulis program untuk mengira POW (x, n) | Program C ++ untuk pendekatan di atas; jenis pulangan fungsi POW () adalah dua kali ganda; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y ) { return ( int ) pow ( x , y ) ; } int main ( ) { int x = 2 ; int y = 3 ; cout << ( power ( x , y ) ) ; }"}
{"text": "Kaedah Babylon untuk Root Square |  ; Mengembalikan akar kuadrat n. Perhatikan bahawa fungsi itu; Kami menggunakan N sendiri sebagai penghampiran awal ini pasti dapat diperbaiki; E memutuskan tahap ketepatan; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; class gfg { public : float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } } ; int main ( ) { gfg g ; int n = 50 ; cout << \" Square ▁ root ▁ of ▁ \" << n << \" ▁ is ▁ \" << g . squareRoot ( n ) ; getchar ( ) ; }"}
{"text": "Purata aliran nombor |  ; Mengembalikan purata baru selepas termasuk x; Mencetak purata aliran nombor; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE float getAvg ( float prev_avg , int x , int n ) { return ( prev_avg * n + x ) / ( n + 1 ) ; } void streamAvg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( avg , arr [ i ] , i ) ; printf ( \" Average ▁ of ▁ % d ▁ numbers ▁ is ▁ % f ▁ STRNEWLINE \" , i + 1 , avg ) ; } return ; } int main ( ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; streamAvg ( arr , n ) ; return 0 ; }"}
{"text": "Purata aliran nombor |  ; Mengembalikan purata baru selepas termasuk x; Mencetak purata aliran nombor; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float getAvg ( int x ) { static int sum , n ; sum += x ; return ( ( ( float ) sum ) / ++ n ) ; } void streamAvg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( arr [ i ] ) ; cout << \" Average ▁ of ▁ \" << i + 1 << \" ▁ numbers ▁ is ▁ \" << fixed << setprecision ( 1 ) << avg << endl ; } return ; } int main ( ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; streamAvg ( arr , n ) ; return 0 ; }"}
{"text": "Koefisien Binomial Ruang dan Masa yang cekap | Program untuk mengira c (n, k); Pulangan nilai pekali binomial c (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int main ( ) { int n = 8 , k = 2 ; cout << \" Value ▁ of ▁ C ( \" << n << \" , ▁ \" << k << \" ) ▁ is ▁ \" << binomialCoeff ( n , k ) ; return 0 ; }"}
{"text": "Program yang cekap untuk mencetak semua faktor utama nombor tertentu | Program C ++ untuk mencetak semua faktor utama; Fungsi untuk mencetak semua faktor utama nombor n tertentu; Cetak bilangan 2 s yang membahagikan n; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, cetak saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void primeFactors ( int n ) { while ( n % 2 == 0 ) { cout << 2 << \" ▁ \" ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { cout << i << \" ▁ \" ; n = n / i ; } } if ( n > 2 ) cout << n << \" ▁ \" ; } int main ( ) { int n = 315 ; primeFactors ( n ) ; return 0 ; }"}
{"text": "Cetak semua kemungkinan kombinasi elemen R dalam pelbagai saiz n | Program C ++ untuk mencetak semua gabungan saiz R dalam pelbagai saiz N; Fungsi utama yang mencetak semua kombinasi saiz r dalam arr [] saiz n. Fungsi ini terutamanya menggunakan gabunganUtil (); Arahan sementara untuk menyimpan semua gabungan satu demi satu; Cetak semua kombinasi menggunakan data temprary array [] '; arr [] - -> data array input [] - -> array sementara untuk menyimpan kombinasi semasa & akhir - -> menatap dan mengakhiri indeks dalam arr [] indeks - -> indeks semasa dalam data [] r - -> saiz kombinasi yang akan dicetak; Gabungan semasa sudah siap dicetak, mencetaknya; Gantikan indeks dengan semua elemen yang mungkin. Keadaan \"Akhir - I + 1 = u r - indeks\" memastikan bahawa termasuk satu elemen di indeks akan membuat kombinasi dengan elemen yang tinggal pada kedudukan yang tinggal; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) ; void printCombination ( int arr [ ] , int n , int r ) { int data [ r ] ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; } void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) cout << data [ j ] << \" ▁ \" ; cout << endl ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printCombination ( arr , n , r ) ; }"}
{"text": "Cetak semua kemungkinan kombinasi elemen R dalam pelbagai saiz n | Program C ++ untuk mencetak semua gabungan saiz R dalam pelbagai saiz N; Fungsi utama yang mencetak semua kombinasi saiz r dalam arr [] saiz n. Fungsi ini terutamanya menggunakan gabunganUtil (); Arahan sementara untuk menyimpan semua gabungan satu demi satu; Cetak semua kombinasi menggunakan data temprary array [] '; arr [] - -> array input n - -> saiz array input r - -> saiz gabungan untuk dicetak indeks - -> indeks semasa dalam data [] data [] - -> array sementara untuk menyimpan kombinasi semasa i - -> indeks elemen semasa dalam arr []; Gabungan semasa sudah siap, cetaknya; Apabila tidak ada lagi elemen yang ada untuk dimasukkan ke dalam data []; Semasa dimasukkan, letakkan seterusnya di lokasi seterusnya; Semasa dikecualikan, gantikannya dengan seterusnya (perhatikan bahawa i + 1 diluluskan, tetapi indeks tidak berubah); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) ; void printCombination ( int arr [ ] , int n , int r ) { int data [ r ] ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; } void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) cout << data [ j ] << \" ▁ \" ; cout << endl ; return ; } if ( i >= n ) return ; data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ; combinationUtil ( arr , n , r , index , data , i + 1 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printCombination ( arr , n , r ) ; return 0 ; }"}
{"text": "Kira semua kumpulan saiz 2 atau 3 yang mungkin mempunyai jumlah sebagai pelbagai 3 | Program C ++ untuk mengira semua kumpulan saiz 2 atau 3 yang mempunyai jumlah yang mempunyai pelbagai daripada 3; Mengembalikan kiraan semua kumpulan yang mungkin boleh dibentuk dari unsur -unsur []. ; Buat array C [3] untuk menyimpan bilangan elemen dengan selebihnya 0, 1 dan 2. C [i] akan menyimpan kiraan elemen dengan selebihnya I; Untuk menyimpan hasilnya; Mengira elemen dengan selebihnya 0, 1 dan 2; Kes 3. A: Kumpulan Kumpulan Saiz 2 dari 0 elemen yang tinggal; Kes 3. B: Kumpulan Kumpulan Saiz 2 dengan satu elemen dengan 1 baki dan lain -lain dengan 2 selebihnya; Kes 4. A: Kumpulan Kumpulan Saiz 3 dengan semua 0 elemen yang tinggal; Kes 4. B: Kumpulan Kumpulan Saiz 3 dengan semua 1 elemen yang tinggal; Kes 4. C: Kumpulan Kumpulan Saiz 3 dengan semua 2 elemen yang tinggal; Kes 4. C: Kumpulan Kumpulan Saiz 3 dengan sisa yang berbeza; Mengembalikan jumlah jumlah yang disimpan dalam res; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findgroups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 } , i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; } int main ( ) { int arr [ ] = { 3 , 6 , 7 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Required ▁ number ▁ of ▁ groups ▁ are ▁ \" << findgroups ( arr , n ) << endl ; return 0 ; }"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Program C ++ untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Pertama n dalam keadaan di bawah adalah untuk kes di mana n adalah 0; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int main ( ) { unsigned int n = 0 ; cout << nextPowerOf2 ( n ) ; return 0 ; }"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Program C ++ untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } int main ( ) { unsigned int n = 5 ; cout << nextPowerOf2 ( n ) ; return 0 ; }"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Program C ++ untuk mencari kuasa seterusnya dua untuk n. Jika n sendiri adalah kuasa dua maka pulangan n; Cari kuasa seterusnya dua untuk n. Jika n sendiri adalah kuasa dua maka pulangan n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; } int main ( ) { unsigned int n = 5 ; cout << nextPowerOf2 ( n ) ; return 0 ; }"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | C ++ kod untuk memisahkan 0 s dan 1 s dalam array; Berfungsi untuk memisahkan 0 s dan 1 s; Mengira tiada sifar dalam arr; Gelung mengisi ARR dengan 0 sehingga dikira; Gelung mengisi ruang yang tinggal dengan 1; Berfungsi untuk mencetak array terasing; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregate0and1 ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count ++ ; } for ( int i = 0 ; i < count ; i ++ ) arr [ i ] = 0 ; for ( int i = count ; i < n ; i ++ ) arr [ i ] = 1 ; } void print ( int arr [ ] , int n ) { cout << \" Array ▁ after ▁ segregation ▁ is ▁ \" ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , n ) ; print ( arr , n ) ; return 0 ; }"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | Program C ++ untuk menyusun array binari dalam satu pas; Berfungsi untuk meletakkan semua 0 s di kiri dan semua 1 s di sebelah kanan; Memulakan indeks kiri dan kanan; Indeks Kiri Peningkatan semasa kita melihat 0 di sebelah kiri; Indeks kanan pengurangan semasa kita melihat 1 di sebelah kanan; Jika kiri lebih kecil daripada kanan maka terdapat 1 di sebelah kiri dan 0 di sebelah kanan. Pertukaran arr [kiri] dan arr [kanan]; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , arr_size ) ; cout << \" Array ▁ after ▁ segregation ▁ \" ; for ( i = 0 ; i < 6 ; i ++ ) cout << arr [ i ] << \" ▁ \" ; return 0 ; }"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | Program C ++ untuk menyusun array binari dalam satu pas; Berfungsi untuk meletakkan semua 0 s di kiri dan semua 1 s di sebelah kanan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregate0and1 ( int arr [ ] , int size ) { int type0 = 0 ; int type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else type0 ++ ; } } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , arr_size ) ; cout << \" Array ▁ after ▁ segregation ▁ is ▁ \" ; for ( i = 0 ; i < arr_size ; i ++ ) cout << arr [ i ] << \" ▁ \" ; return 0 ; }"}
{"text": "Unsur -unsur bersebelahan yang berbeza dalam array | Program C ++ untuk memeriksa sama ada kita boleh membuat jiran berbeza. ; peta yang digunakan untuk mengira kekerapan setiap elemen yang berlaku dalam array; Dalam gelung ini kita mengira kekerapan elemen melalui peta m. ; MX Simpan kekerapan elemen yang paling banyak berlaku dalam array. ; Dalam gelung ini kita mengira kekerapan maksimum dan simpannya dalam MX yang berubah -ubah. ; Dengan menukar kita boleh menyesuaikan array hanya apabila kekerapan elemen yang berlaku kebanyakannya kurang daripada atau sama dengan (n + 1) / 2. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void distinctAdjacentElement ( int a [ ] , int n ) { map < int , int > m ; for ( int i = 0 ; i < n ; ++ i ) m [ a [ i ] ] ++ ; int mx = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( mx < m [ a [ i ] ] ) mx = m [ a [ i ] ] ; if ( mx > ( n + 1 ) / 2 ) cout << \" NO \" << endl ; else cout << \" YES \" << endl ; } int main ( ) { int a [ ] = { 7 , 7 , 7 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; distinctAdjacentElement ( a , n ) ; return 0 ; }"}
{"text": "Memandangkan array arr [], cari maksimum j | Program CPP untuk pendekatan di atas; Untuk array arr [], mengembalikan maksimum J a i sedemikian rupa sehingga arr [j]> arr [i]; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = -1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; } int main ( ) { int arr [ ] = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int maxDiff = maxIndexDiff ( arr , n ) ; cout << \" STRNEWLINE \" << maxDiff ; return 0 ; }"}
{"text": "Memandangkan array arr [], cari maksimum j | Untuk array arr [], mengira maksimum j a saya sedemikian rupa sehingga arr [j] arr [i]; Buat array MaxFromend; Kami menyimpan ini sebagai jawapan semasa dan mencari nombor yang lebih besar lagi ke sebelah kanan; Menjaga jejak perbezaan maksimum indeks", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { vector < long long int > v { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int n = v . size ( ) ; vector < long long int > maxFromEnd ( n + 1 , INT_MIN ) ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { maxFromEnd [ i ] = max ( maxFromEnd [ i + 1 ] , v [ i ] ) ; } int result = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int low = i + 1 , high = v . size ( ) - 1 , ans = i ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( v [ i ] <= maxFromEnd [ mid ] ) { ans = max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } result = max ( result , ans - i ) ; } cout << result << endl ; }"}
{"text": "Memandangkan array arr [], cari maksimum j | C ++ pelaksanaan pendekatan hashmap; Fungsi untuk mencari perbezaan indeks maksimum; Initilaise unordered_map; Berulang dari 0 hingga n - 1; Sort arr; Berulang dari 0 hingga n - 1; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxIndexDiff ( vector < int > & arr , int n ) { unordered_map < int , vector < int > > hashmap ; for ( int i = 0 ; i < n ; i ++ ) { hashmap [ arr [ i ] ] . push_back ( i ) ; } sort ( arr . begin ( ) , arr . end ( ) ) ; int maxDiff = INT_MIN ; int temp = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( temp > hashmap [ arr [ i ] ] [ 0 ] ) { temp = hashmap [ arr [ i ] ] [ 0 ] ; } maxDiff = max ( maxDiff , hashmap [ arr [ i ] ] [ hashmap [ arr [ i ] ] . size ( ) - 1 ] - temp ) ; } return maxDiff ; } int main ( ) { int n = 9 ; vector < int > arr { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int ans = maxIndexDiff ( arr , n ) ; cout << \" The ▁ maxIndexDiff ▁ is ▁ : ▁ \" << ans << endl ; return 1 ; }"}
{"text": "Cetak elemen array yang berbeza | Program CPP untuk mencetak unsur -unsur yang berbeza. ; Buat set menggunakan elemen array; Cetak kandungan set. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRepeating ( int arr [ ] , int size ) { set < int > s ( arr , arr + size ) ; for ( auto x : s ) cout << x << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , n ) ; return 0 ; }"}
{"text": "Swap minimum untuk membuat dua tatasusunan sama | Program C ++ untuk membuat array yang sama dengan yang lain menggunakan bilangan swap minimum; Fungsi Mengembalikan bilangan swap minimum yang diperlukan untuk menyusun array kaedah ini diambil dari bawah pasca www. Geeksforgeeks. org / minimum - nombor - swap - diperlukan - sort - array / https :; Buat pelbagai pasangan di mana elemen pertama adalah elemen array dan elemen kedua adalah kedudukan elemen pertama; Susun array dengan nilai elemen array untuk mendapatkan kedudukan yang betul setiap elemen sebagai elemen kedua pasangan. ; Untuk menjejaki elemen yang dikunjungi. Memulakan semua elemen yang tidak dikunjungi atau palsu. ; Memulakan hasil; Elemen Array Traverse; sudah bertukar dan diperbetulkan atau sudah hadir di pos yang betul; Ketahui bilangan nod dalam kitaran ini dan tambah dalam ANS; Pindah ke Node Next; Kemas kini jawapan dengan menambahkan kitaran semasa. ; Hasil pulangan; Kaedah Mengembalikan bilangan swap minimum untuk membuat array B sama seperti array A; peta untuk menyimpan kedudukan elemen dalam Array B Kami pada dasarnya menyimpan elemen untuk indeks pemetaan. ; Kini kami menyimpan kedudukan array elemen dalam Array B .; Menghidupkan swap minimum untuk menyusun dalam array yang diubah suai b sebagai jawapan akhir; Kod pemacu untuk menguji kaedah di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSwapsToSort ( int arr [ ] , int n ) { pair < int , int > arrPos [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arrPos [ i ] . first = arr [ i ] ; arrPos [ i ] . second = i ; } sort ( arrPos , arrPos + n ) ; vector < bool > vis ( n , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] arrPos [ i ] . second == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = 1 ; j = arrPos [ j ] . second ; cycle_size ++ ; } ans += ( cycle_size - 1 ) ; } return ans ; } int minSwapToMakeArraySame ( int a [ ] , int b [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ b [ i ] ] = i ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = mp [ a [ i ] ] ; return minSwapsToSort ( b , n ) ; } int main ( ) { int a [ ] = { 3 , 6 , 4 , 8 } ; int b [ ] = { 4 , 6 , 8 , 3 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << minSwapToMakeArraySame ( a , b , n ) ; return 0 ; }"}
{"text": "K |  ; Berfungsi untuk mencari elemen k - th yang hilang; interating melalui array; Semak jika saya - th dan (i + 1) - elemen tidak berturut -turut; Simpan perbezaan mereka; Semak perbezaan dan diberikan k; jika dijumpai; Kod pemacu; Arahan input; K - elemen yang hilang dapat dijumpai dalam array; fungsi panggilan untuk mencari elemen yang hilang", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingK ( int a [ ] , int k , int n ) { int difference = 0 , ans = 0 , count = k ; bool flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = 1 ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return -1 ; } int main ( ) { int a [ ] = { 1 , 5 , 11 , 19 } ; int k = 11 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int missing = missingK ( a , k , n ) ; cout << missing << endl ; return 0 ; }"}
{"text": "K | Program CPP untuk pendekatan di atas; Berfungsi untuk mencari nombor kth yang hilang; Sekiranya jumlah jumlah nombor yang hilang adalah sama dengan k kita boleh melangkah ke belakang untuk nombor yang hilang pertama dan itu akan menjadi jawapannya. ; Untuk mengoptimumkan lagi, kita periksa sama ada elemen sebelumnya yang hilang. Eg: 4,5,6,7,8] u u u obs obs u u u u u u u u u u. »~ Carian ~ tetingkap» dan u (LOGN) ~ masa Kompleksiti ~ f f f fely 'akan' telah o (n). ; Lain kita kembali arr [pertengahan] - 1 .; Di sini kita menyempitkan tetingkap carian dengan sewajarnya. ; Sekiranya had atas adalah - ia bermakna set nombor yang hilang ialah 1, 2 ,. . , k dan oleh itu kita terus kembali k. ; Lain kita dapati jumlah sisa nombor yang kita 'd kemudian tambahkan ke arr [u] dan dapatkan nombor kth yang hilang. ; Kembali arr [u] + k; Kod pemacu; Panggilan fungsi", "code": "#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; int missingK ( vector < int > & arr , int k ) { int n = arr . size ( ) ; int l = 0 , u = n - 1 , mid ; while ( l <= u ) { mid = ( l + u ) / 2 ; int numbers_less_than_mid = arr [ mid ] - ( mid + 1 ) ; if ( numbers_less_than_mid == k ) { if ( mid > 0 && ( arr [ mid - 1 ] - ( mid ) ) == k ) { u = mid - 1 ; continue ; } return arr [ mid ] - 1 ; } if ( numbers_less_than_mid < k ) { l = mid + 1 ; } else if ( k < numbers_less_than_mid ) { u = mid - 1 ; } } if ( u < 0 ) return k ; int less = arr [ u ] - ( u + 1 ) ; k -= less ; return arr [ u ] + k ; } int main ( ) { vector < int > arr = { 2 , 3 , 4 , 7 , 11 } ; int k = 5 ; cout << \" Missing ▁ kth ▁ number ▁ = ▁ \" << missingK ( arr , k ) << endl ; return 0 ; }"}
{"text": "Alternatif ganjil dan juga nod dalam senarai yang berkaitan dengan tunggal | Program CPP untuk menyusun semula nod sebagai alternatif ganjil walaupun nod dalam senarai yang berkaitan dengan tunggal; Struktur nod; Fungsi utiliti untuk mencetak senarai yang dipautkan; Berfungsi untuk membuat newnode dalam senarai LinkedL; Berfungsi untuk memasukkan pada permulaan; Berfungsi untuk menyusun semula nod yang ganjil dan bahkan; Nilai ganjil dalam kedudukan walaupun menunjuk penunjuk ke nod semasa dalam timbunan ganjil; Malah nilai dalam kedudukan ganjil menambah penunjuk ke nod semasa dalam timbunan walaupun; Swap data di bahagian atas dua susunan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void printList ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << \" ▁ \" ; node = node -> next ; } cout << endl ; } Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } Node * insertBeg ( Node * head , int val ) { Node * temp = newNode ( val ) ; temp -> next = head ; head = temp ; return head ; } void rearrangeOddEven ( Node * head ) { stack < Node * > odd ; stack < Node * > even ; int i = 1 ; while ( head != nullptr ) { if ( head -> data % 2 != 0 && i % 2 == 0 ) { odd . push ( head ) ; } else if ( head -> data % 2 == 0 && i % 2 != 0 ) { even . push ( head ) ; } head = head -> next ; i ++ ; } while ( ! odd . empty ( ) && ! even . empty ( ) ) { swap ( odd . top ( ) -> data , even . top ( ) -> data ) ; odd . pop ( ) ; even . pop ( ) ; } } int main ( ) { Node * head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 1 ) ; cout << \" Linked ▁ List : \" << endl ; printList ( head ) ; rearrangeOddEven ( head ) ; cout << \" Linked ▁ List ▁ after ▁ \" << \" Rearranging : \" << endl ; printList ( head ) ; return 0 ; }"}
{"text": "Alternatif ganjil dan juga nod dalam senarai yang berkaitan dengan tunggal | Program CPP untuk menyusun semula nod sebagai alternatif ganjil walaupun nod dalam senarai yang berkaitan dengan tunggal; Struktur nod; Fungsi utiliti untuk mencetak senarai yang dipautkan; Berfungsi untuk membuat newnode dalam senarai LinkedL; Berfungsi untuk memasukkan pada permulaan; Berfungsi untuk menyusun semula nod yang ganjil dan bahkan; Langkah 1: Mengasingkan Node Even dan Odd Langkah 2: Split Odd dan juga menyenaraikan Langkah 3: Gabungkan senarai bahkan ke dalam senarai ganjil; Langkah 1: Mengasingkan ganjil dan juga nod; Sandaran penunjuk seterusnya temp; Jika temp adalah ganjil bergerak nod ke permulaan senarai; Pointer Temp Advance; Langkah 2 memecah senarai ke dalam ganjil dan bahkan; Tamatkan senarai ganjil (buat nod terakhir null); Langkah 3: Gabungkan bahkan senarai ke dalam ganjil; Walaupun kedua -dua senarai itu tidak habis sandaran sandaran seterusnya I dan J; PTR menunjuk kepada nod terkini yang ditambah; Advance I dan J Pointers; Senarai ganjil ekzos sebelum walaupun, tambahkan selebihnya senarai yang ganjil. ; Kes di mana senarai ekzos sebelum senarai ganjil ditangani secara automatik kerana kami menggabungkan senarai bahkan ke dalam senarai ganjil; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void printList ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << \" ▁ \" ; node = node -> next ; } cout << endl ; } Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } Node * insertBeg ( Node * head , int val ) { Node * temp = newNode ( val ) ; temp -> next = head ; head = temp ; return head ; } void rearrange ( Node * * head ) { Node * even ; Node * temp , * prev_temp ; Node * i , * j , * k , * l , * ptr ; temp = ( * head ) -> next ; prev_temp = * head ; while ( temp != nullptr ) { Node * x = temp -> next ; if ( temp -> data % 2 != 0 ) { prev_temp -> next = x ; temp -> next = ( * head ) ; ( * head ) = temp ; } else { prev_temp = temp ; } temp = x ; } temp = ( * head ) -> next ; prev_temp = ( * head ) ; while ( temp != nullptr && temp -> data % 2 != 0 ) { prev_temp = temp ; temp = temp -> next ; } even = temp ; prev_temp -> next = nullptr ; i = * head ; j = even ; while ( j != nullptr && i != nullptr ) { k = i -> next ; l = j -> next ; i -> next = j ; j -> next = k ; ptr = j ; i = k ; j = l ; } if ( i == nullptr ) { ptr -> next = j ; } } int main ( ) { Node * head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 1 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 10 ) ; cout << \" Linked ▁ List : \" << endl ; printList ( head ) ; cout << \" Rearranged ▁ List \" << endl ; rearrange ( & head ) ; printList ( head ) ; }"}
{"text": "Putar semua elemen matriks kecuali kali pepenjuru k dengan 90 darjah dalam arah arah jam | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencetak matriks; Melangkah ke atas baris; Melangkah ke atas lajur; Cetak nilai; Berfungsi untuk melaksanakan pertukaran unsur matriks dengan cara mengikut arah jam; Menyimpan baris terakhir; Menyimpan lajur terakhir; Melakukan swap; Berfungsi untuk memutar unsur -unsur pepenjuru bukan matriks k dalam arah arah jam; Kemas kini K ke K % 4; Melangkah sehingga k positif; Melepasi setiap baris n / 2 - th; Melepasi setiap lajur dari i ke n - i - 1; Semak sama ada elemen di i, j bukan elemen pepenjuru; Melakukan pertukaran; Cetak matriks; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void print ( vector < vector < int > > & mat ) { for ( int i = 0 ; i < mat . size ( ) ; i ++ ) { for ( int j = 0 ; j < mat [ 0 ] . size ( ) ; j ++ ) cout << setw ( 3 ) << mat [ i ] [ j ] ; cout << \" STRNEWLINE \" ; } } void performSwap ( vector < vector < int > > & mat , int i , int j ) { int N = mat . size ( ) ; int ei = N - 1 - i ; int ej = N - 1 - j ; int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ ej ] [ i ] ; mat [ ej ] [ i ] = mat [ ei ] [ ej ] ; mat [ ei ] [ ej ] = mat [ j ] [ ei ] ; mat [ j ] [ ei ] = temp ; } void rotate ( vector < vector < int > > & mat , int N , int K ) { K = K % 4 ; while ( K -- ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { for ( int j = i ; j < N - i - 1 ; j ++ ) { if ( i != j && ( i + j ) != N - 1 ) { performSwap ( mat , i , j ) ; } } } } print ( mat ) ; } int main ( ) { int K = 5 ; vector < vector < int > > mat = { { 1 , 2 , 3 , 4 } , { 6 , 7 , 8 , 9 } , { 11 , 12 , 13 , 14 } , { 16 , 17 , 18 , 19 } , } ; int N = mat . size ( ) ; rotate ( mat , N , K ) ; return 0 ; }"}
{"text": "Putaran minimum diperlukan untuk mendapatkan rentetan yang sama | Program C ++ untuk menentukan bilangan putaran minimum yang diperlukan untuk menghasilkan rentetan yang sama. ; Mengembalikan kiraan putaran untuk mendapatkan kembali rentetan yang sama. ; TMP adalah rentetan yang disatukan. ; Substring dari I Indeks saiz rentetan asal. ; Jika substring sepadan dengan rentetan asal maka kami akan keluar dari gelung. ; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int findRotations ( string str ) { string tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { string substring = tmp . substr ( i , str . size ( ) ) ; if ( str == substring ) return i ; } return n ; } int main ( ) { string str = \" abc \" ; cout << findRotations ( str ) << endl ; return 0 ; }"}
{"text": "Count of Elements yang Kuasa 2 dalam Subarray Julat tertentu untuk QQueries | C ++ pelaksanaan untuk mencari unsur -unsur yang merupakan kuasa dua; Awalan [i] akan menyimpan bilangan elemen yang merupakan kuasa dua hingga i (termasuk i). ; Berfungsi untuk mencari julat maksimum yang jumlahnya boleh dibahagikan dengan m. ; Kirakan jumlah awalan; Berfungsi untuk mengembalikan bilangan elemen yang merupakan kuasa dua dalam subarray; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; int prefix [ MAX + 1 ] ; bool isPowerOfTwo ( int x ) { if ( x && ( ! ( x & ( x - 1 ) ) ) ) return true ; return false ; } void computePrefix ( int n , int a [ ] ) { if ( isPowerOfTwo ( a [ 0 ] ) ) prefix [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] ; if ( isPowerOfTwo ( a [ i ] ) ) prefix [ i ] ++ ; } } int query ( int L , int R ) { return prefix [ R ] - prefix [ L - 1 ] ; } int main ( ) { int A [ ] = { 3 , 8 , 5 , 2 , 5 , 10 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int Q = 2 ; computePrefix ( N , A ) ; cout << query ( 0 , 4 ) << \" STRNEWLINE \" ; cout << query ( 3 , 5 ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Count of Integral Coordinates yang terletak di dalam persegi | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira titik integral di dalam persegi; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { cout << ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ; } int main ( ) { int x1 = 1 , y1 = 1 ; int x2 = 4 , y2 = 4 ; countIntgralPoints ( x1 , y1 , x2 , y2 ) ; return 0 ; }"}
{"text": "Cari nombor seterusnya yang mempunyai digit yang berbeza dari nombor N | C ++ pelaksanaan untuk mencari nombor digit yang berbeza; Berfungsi untuk mencari nombor digit yang berbeza; Gelung untuk mencari digit yang berbeza menggunakan array hash dan bilangan digit; Gelung untuk mencari digit yang paling ketara dari nombor seterusnya; Keadaan untuk memeriksa sama ada nombor itu mungkin dengan bilangan angka yang sama; Keadaan untuk memeriksa sama ada digit yang paling significant yang dikehendaki dijumpai; Gelung untuk mencari digit seterusnya minimum yang tidak hadir dalam nombor; Pengiraan nombor; Syarat untuk memeriksa sama ada nombor itu lebih besar daripada nombor yang diberikan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNextNumber ( int n ) { int h [ 10 ] = { 0 } ; int i = 0 , msb = n , rem = 0 ; int next_num = -1 , count = 0 ; while ( msb > 9 ) { rem = msb % 10 ; h [ rem ] = 1 ; msb /= 10 ; count ++ ; } h [ msb ] = 1 ; count ++ ; for ( i = msb + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; break ; } } if ( next_num == -1 ) { for ( i = 1 ; i < msb ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; count ++ ; break ; } } } if ( next_num > 0 ) { for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { msb = i ; break ; } } for ( i = 1 ; i < count ; i ++ ) { next_num = ( ( next_num * 10 ) + msb ) ; } if ( next_num > n ) cout << next_num << \" STRNEWLINE \" ; else cout << \" Not ▁ Possible ▁ STRNEWLINE \" ; } else { cout << \" Not ▁ Possible ▁ STRNEWLINE \" ; } } int main ( ) { int n = 2019 ; findNextNumber ( n ) ; return 0 ; }"}
{"text": "Cari triplet (a, b, c) supaya 3 * a + 5 * b + 7 * c sama dengan n | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari triplet (a, b, c) supaya 3 * a + 5 * b + 7 * c ialah n; Melangkah ke atas julat [0, N7]; Melangkah ke atas julat [0, N5]; Cari nilai a; Jika A lebih besar daripada atau sama dengan 0 dan dibahagikan dengan 3; Jika tidak, cetak - 1; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { int A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { cout << \" A ▁ = ▁ \" << A / 3 << \" , ▁ B ▁ = ▁ \" << B << \" , ▁ C ▁ = ▁ \" << C << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { int N = 19 ; CalculateValues ( 19 ) ; return 0 ; }"}
{"text": "Kurangkan jumlah masa yang diambil oleh dua orang untuk melawat bandar -bandar sehingga tidak ada yang bertemu | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari masa minimum untuk melawat semua bandar sehingga kedua -dua orang tidak pernah bertemu; Memulakan jumlah sebagai 0; Cari elemen maksimum; Melintasi array; Jumlah kenaikan oleh arr [i]; Cetak maksimum 2 * t dan jumlah; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumTime ( int * arr , int n ) { int sum = 0 ; int T = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } cout << max ( 2 * T , sum ) ; } int main ( ) { int arr [ ] = { 2 , 8 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumTime ( arr , N ) ; return 0 ; }"}
{"text": "Rentetan lexicographically terbesar mungkin dengan membalikkan substring yang mempunyai bilangan 1 s | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari rentetan maksimum lexicographically dengan membalikkan substrings yang mempunyai bilangan 1 s; Saiz saiz rentetan; Melintasi rentetan; Kira bilangan 1 s; Menyimpan indeks permulaan; Menyimpan indeks akhir; Kiraan kenaikan, apabila 1 ditemui; Melintasi rentetan yang tinggal; Membalikkan rentetan dari indeks permulaan dan akhir; Mencetak rentetan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexicographicallyMax ( string s ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; int beg = i ; int end = i ; if ( s [ i ] == '1' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] == '1' ) count ++ ; if ( count % 2 == 0 && count != 0 ) { end = j ; break ; } } reverse ( s . begin ( ) + beg , s . begin ( ) + end + 1 ) ; } cout << s << \" STRNEWLINE \" ; } int main ( ) { string S = \"0101\" ; lexicographicallyMax ( S ) ; return 0 ; }"}
{"text": "Kira pasangan maksimum yang mungkin dari array yang mempunyai jumlah k | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan maksimum pasangan dari array yang diberikan dengan jumlah k; Susun array dalam urutan yang semakin meningkat; Menyimpan hasil akhir; Memulakan penunjuk kiri dan kanan; TRAVERSE ARRAY Sehingga mula <end; Pengurangan hak oleh 1; Kenaikan ditinggalkan oleh 1; Hasil kenaikan dan penunjuk kiri oleh 1 dan penunjuk kanan penurunan dengan 1; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxPairs ( int nums [ ] , int n , int k ) { sort ( nums , nums + n ) ; int result = 0 ; int start = 0 , end = n - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } cout << result << endl ; ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; maxPairs ( arr , n , K ) ; return 0 ; }"}
{"text": "Kira pasangan maksimum yang mungkin dari array yang mempunyai jumlah k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan maksimum pasangan dengan jumlah k sedemikian rupa sehingga elemen yang sama tidak dapat digunakan dua kali; Memulakan hashm; Simpan hasil akhir; Melangkah ke atas array nums []; Menurunkan kekerapannya dalam m dan kenaikan hasilnya dengan 1; Meningkatkan kekerapannya dengan 1 jika sudah ada dalam m. Jika tidak, tetapkan kekerapannya kepada 1; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; void maxPairs ( vector < int > nums , int k ) { map < int , int > m ; int result = 0 ; for ( auto i : nums ) { if ( m . find ( i ) != m . end ( ) && m [ i ] > 0 ) { m [ i ] = m [ i ] - 1 ; result ++ ; } else { m [ k - i ] = m [ k - i ] + 1 ; } } cout << result ; } int main ( ) { vector < int > arr = { 1 , 2 , 3 , 4 } ; int K = 5 ; maxPairs ( arr , K ) ; }"}
{"text": "Indeks cetak elemen array yang penyingkirannya menjadikan jumlah ganjil dan bahkan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari indeks unsur -unsur array yang penyingkirannya menjadikan jumlah elemen array yang ganjil dan juga diindeks sama; Kedai saiz array; Simpan awalan jumlah elemen array indeks ganjil; Simpan awalan jumlah elemen array indeks walaupun; Kemas kini walaupun [0]; Melintasi array yang diberikan; Mengemas kini ganjil [i]; Kemas kini walaupun [i]; Jika indeks semasa adalah nombor yang sama; Kemas kini walaupun [i]; Jika indeks semasa adalah nombor ganjil; Mengemas kini ganjil [i]; Semak sama ada sekurang -kurangnya satu indeks yang dijumpai atau tidak yang memenuhi syarat; Simpan indeks ganjil dengan mengeluarkan indeks 0 - TH; Simpan walaupun indeks jumlah dengan mengeluarkan indeks 0 - Th; Jika p dan q sama; Melintasi array arr []; Jika saya adalah nombor yang sama; Kemas kini P dengan mengeluarkan elemen i - th; Kemas kini Q dengan mengeluarkan elemen I - th; Kemas kini Q dengan mengeluarkan elemen I - th; Kemas kini P dengan mengeluarkan elemen i - th; Jika nilai indeks ganjil jumlah sama dengan nilai indeks walaupun jumlah; Tetapkan pemboleh ubah mencari; Cetak indeks semasa; Jika tidak ada indeks yang dijumpai; Cetak tidak mungkin; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeIndicesToMakeSumEqual ( vector < int > & arr ) { int N = arr . size ( ) ; vector < int > odd ( N , 0 ) ; vector < int > even ( N , 0 ) ; even [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { odd [ i ] = odd [ i - 1 ] ; even [ i ] = even [ i - 1 ] ; if ( i % 2 == 0 ) { even [ i ] += arr [ i ] ; } else { odd [ i ] += arr [ i ] ; } } bool find = 0 ; int p = odd [ N - 1 ] ; int q = even [ N - 1 ] - arr [ 0 ] ; if ( p == q ) { cout << \"0 ▁ \" ; find = 1 ; } for ( int i = 1 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else { q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; } if ( p == q ) { find = 1 ; cout << i << \" ▁ \" ; } } if ( ! find ) { cout << -1 ; } } int main ( ) { vector < int > arr = { 4 , 1 , 6 , 2 } ; removeIndicesToMakeSumEqual ( arr ) ; return 0 ; }"}
{"text": "Penyingkiran minimum diperlukan untuk membuat bitonic array yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk coutnt elemen array minimum yang diperlukan untuk dikeluarkan untuk membuat bitonic array; Kiri [i]: menyimpan panjang lis sehingga indeks i - th; kanan [i]: menyimpan panjang penurunan seterusnya ke atas julat [i, n]; Kirakan panjang LIS sehingga indeks i - th; Melintasi array sehingga indeks i - th; Jika arr [j] kurang daripada arr [i]; Kemas kini kiri [i]; Kirakan panjang penurunan seterusnya ke atas julat [i, n]; Melintasi kanan [] array; Jika arr [i] lebih besar daripada arr [j]; Kemas kini betul [i]; Kedai panjang array bitonic terpanjang; Traverse kiri [] dan kanan [] array; Kemas kini Maxlen; Fungsi untuk mencetak penyingkiran minimum yang diperlukan untuk membuat bitonic array yang diberikan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void min_element_removal ( int arr [ ] , int N ) { vector < int > left ( N , 1 ) ; vector < int > right ( N , 1 ) ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { left [ i ] = max ( left [ i ] , left [ j ] + 1 ) ; } } } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j > i ; j -- ) { if ( arr [ i ] > arr [ j ] ) { right [ i ] = max ( right [ i ] , right [ j ] + 1 ) ; } } } int maxLen = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { maxLen = max ( maxLen , left [ i ] + right [ i ] - 1 ) ; } cout << ( N - maxLen ) << \" STRNEWLINE \" ; } void makeBitonic ( int arr [ ] , int N ) { if ( N == 1 ) { cout << \"0\" << endl ; return ; } if ( N == 2 ) { if ( arr [ 0 ] != arr [ 1 ] ) cout << \"0\" << endl ; else cout << \"1\" << endl ; return ; } min_element_removal ( arr , N ) ; } int main ( ) { int arr [ ] = { 2 , 1 , 1 , 5 , 6 , 2 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; makeBitonic ( arr , N ) ; return 0 ; }"}
{"text": "Count Subarrays mempunyai kiraan yang sama dengan 0 dan 1 S berasal | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira subarray yang mempunyai kiraan yang sama dengan 0 s dan 1 s dengan semua 0 s dan semua 1 dikelompokkan bersama; Menyimpan kiraan subarray; Jika elemen semasa berbeza daripada elemen array seterusnya; Kiraan kenaikan; Hitung kekerapan 1 s dan 0 s; Kiraan kenaikan; Cetak kiraan akhir; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubarrays ( int A [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } cout << ans << \" STRNEWLINE \" ; } int main ( ) { int A [ ] = { 1 , 1 , 0 , 0 , 1 , 0 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; countSubarrays ( A , N ) ; return 0 ; }"}
{"text": "Kiraan quadruples jenis yang diberikan dari array yang diberikan | C ++ program pendekatan di atas; lcount [i] [j]: menyimpan kiraan saya di sebelah kiri indeks j; rcount [i] [j]: menyimpan kiraan saya di kanan indeks j; Berfungsi untuk mengira unsur -unsur unik di kiri dan kanan mana -mana indeks; Cari elemen array maksimum; Kirakan jumlah awalan jumlah setiap nilai; Kirakan jumlah akhiran jumlah setiap nilai; Berfungsi untuk mengira kuadruples jenis yang diperlukan; Kod pemacu", "code": "#include <cstring> NEW_LINE #include <iostream> NEW_LINE using namespace std ; const int maxN = 2002 ; int lcount [ maxN ] [ maxN ] ; int rcount [ maxN ] [ maxN ] ; void fill_counts ( int a [ ] , int n ) { int i , j ; int maxA = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxA ) { maxA = a [ i ] ; } } memset ( lcount , 0 , sizeof ( lcount ) ) ; memset ( rcount , 0 , sizeof ( rcount ) ) ; for ( i = 0 ; i < n ; i ++ ) { lcount [ a [ i ] ] [ i ] = 1 ; rcount [ a [ i ] ] [ i ] = 1 ; } for ( i = 0 ; i <= maxA ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { lcount [ i ] [ j ] = lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ; } for ( j = n - 2 ; j >= 0 ; j -- ) { rcount [ i ] [ j ] = rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ; } } } int countSubsequence ( int a [ ] , int n ) { int i , j ; fill_counts ( a , n ) ; int answer = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n - 1 ; j ++ ) { answer += lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ; } } return answer ; } int main ( ) { int a [ 7 ] = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; cout << countSubsequence ( a , 7 ) ; return 0 ; }"}
{"text": "Kurangkan rentetan dengan mengeluarkan kurungan paling luar dari setiap substring primitif | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk menghapuskan tanda kurung paling luar setiap substring primitif dari rentetan yang diberikan; Menyimpan rentetan yang dihasilkan; Menyimpan kiraan tanda kurung yang dibuka; Melintasi rentetan; Jika pembukaan kurungan ditemui dan kiraan mereka melebihi 0; Termasuk watak; Jika penutupan kurungan ditemui dan kiraannya kurang daripada mengira tanda kurung pembukaan; Termasuk watak; Kembali rentetan yang dihasilkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeOuterParentheses ( string S ) { string res ; int count = 0 ; for ( char c : S ) { if ( c == ' ( ' && count ++ > 0 ) res += c ; if ( c == ' ) ' && count -- > 1 ) res += c ; } return res ; } int main ( ) { string S = \" ( ( ) ( ) ) ( ( ) ) ( ) \" ; cout << removeOuterParentheses ( S ) ; }"}
{"text": "Panjang subarray terpanjang dengan peningkatan unsur -unsur bersebelahan | C ++ pelaksanaan untuk pendekatan di atas; Berfungsi untuk mencari subarray terpanjang dengan unsur -unsur bersebelahan yang semakin meningkat; Menyimpan panjang subarray terpanjang yang diperlukan; Menyimpan panjang panjang subarray yang paling lama dari indeks ith; Jika unsur -unsur berturut -turut semakin meningkat dan berbeza dengan 1; Jika tidak; Kemas kini subarray terpanjang yang diperoleh setakat ini; Mengembalikan panjang yang diperoleh; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxiConsecutiveSubarray ( int arr [ ] , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = max ( maxi , cnt ) ; i = j ; } return maxi ; } int main ( ) { int N = 11 ; int arr [ ] = { 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 } ; cout << maxiConsecutiveSubarray ( arr , N ) ; return 0 ; }"}
{"text": "Panjang seterusnya terpanjang yang mempunyai jumlah digit setiap elemen sebagai nombor komposit | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk menjana nombor perdana menggunakan ayak eratosthenes; Tetapkan 0 dan 1 sebagai bukan perdana; Jika p adalah perdana; Tetapkan semua gandaan p sebagai bukan perdana; Berfungsi untuk mencari jumlah digit nombor tertentu; Menyimpan jumlah digit; Ekstrak digit dan tambah kepada jumlah; Kembalikan jumlah digit; Berfungsi untuk mencari berikutnya yang paling lama dengan jumlah digit setiap elemen bersamaan dengan nombor komposit; Hitung jumlah digit elemen array semasa; Jika jumlah digit sama dengan 1; Jika jumlah digit adalah perdana; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } int digitSum ( int number ) { int sum = 0 ; while ( number > 0 ) { sum += ( number % 10 ) ; number /= 10 ; } return sum ; } void longestCompositeDigitSumSubsequence ( int arr [ ] , int n ) { int count = 0 ; bool prime [ N + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { int res = digitSum ( arr [ i ] ) ; if ( res == 1 ) { continue ; } if ( ! prime [ res ] ) { count ++ ; } } cout << count << endl ; } int main ( ) { int arr [ ] = { 13 , 55 , 7 , 3 , 5 , 1 , 10 , 21 , 233 , 144 , 89 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; longestCompositeDigitSumSubsequence ( arr , n ) ; return 0 ; }"}
{"text": "Jumlah nod yang seimbang dari pokok binari yang diberikan | Program C ++ untuk pendekatan di atas; Struktur pokok binari; Berfungsi untuk membuat nod baru; Mengembalikan nod yang dibuat; Berfungsi untuk memasukkan nod di dalam pokok; Penyisipan kiri; Penyisipan kanan; Mengembalikan nod akar; Berfungsi untuk mencari jumlah node yang seimbang di dalam pokok; Kes asas; Cari jumlah subtree kiri; Cari jumlah yang betul; Keadaan node yang seimbang; Keadaan node yang seimbang; Mengembalikan jumlahnya; Berfungsi untuk membina pokok binari; Bentuk nod akar pokok; Masukkan nod ke dalam pokok; Buat nod baru; Masukkan nod; Kembalikan akar pokok; Berfungsi untuk mencari jumlah node yang seimbang; Membina pokok; Menyimpan jumlah node yang seimbang; Panggilan fungsi; Cetak jumlah yang diperlukan; Kod pemacu; Diberikan nod; Diberikan akar; Diberikan maklumat laluan nod dari akar; Diberikan nilai nod; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newnode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } Node * insert ( string s , int i , int N , Node * root , Node * temp ) { if ( i == N ) return temp ; if ( s [ i ] == ' L ' ) root -> left = insert ( s , i + 1 , N , root -> left , temp ) ; else root -> right = insert ( s , i + 1 , N , root -> right , temp ) ; return root ; } int SBTUtil ( Node * root , int & sum ) { if ( root == NULL ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return root -> data ; int left = SBTUtil ( root -> left , sum ) ; int right = SBTUtil ( root -> right , sum ) ; if ( root -> left && root -> right ) { if ( ( left % 2 == 0 && right % 2 != 0 ) || ( left % 2 != 0 && right % 2 == 0 ) ) { sum += root -> data ; } } return left + right + root -> data ; } Node * build_tree ( int R , int N , string str [ ] , int values [ ] ) { Node * root = newnode ( R ) ; int i ; for ( i = 0 ; i < N - 1 ; i ++ ) { string s = str [ i ] ; int x = values [ i ] ; Node * temp = newnode ( x ) ; root = insert ( s , 0 , s . size ( ) , root , temp ) ; } return root ; } void speciallyBalancedNodes ( int R , int N , string str [ ] , int values [ ] ) { Node * root = build_tree ( R , N , str , values ) ; int sum = 0 ; SBTUtil ( root , sum ) ; cout << sum << \" ▁ \" ; } int main ( ) { int N = 7 ; int R = 12 ; string str [ N - 1 ] = { \" L \" , \" R \" , \" RL \" , \" RR \" , \" RLL \" , \" RLR \" } ; int values [ N - 1 ] = { 17 , 16 , 4 , 9 , 2 , 3 } ; speciallyBalancedNodes ( R , N , str , values ) ; return 0 ; }"}
{"text": "Pasangan yang mempunyai semua pasangan lain yang terletak di antara minimum dan maksimumnya | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari kedudukan pasangan yang meliputi setiap pasangan dalam array arr [] []; Menyimpan indeks pasangan yang dihasilkan; Untuk mengira kejadian; Berulang untuk memeriksa setiap pasangan; Tetapkan kiraan ke 0; Keadaan untuk diperiksa untuk bertindih pasangan; Jika pasangan itu dapat menutup semua pasangan lain maka simpan kedudukannya; Jika kedudukan tidak dijumpai; Jika tidak; Kod pemacu; Diberikan pelbagai pasangan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) { int pos = -1 ; int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == -1 ) { cout << pos ; } else { cout << pos + 1 ; } } int main ( ) { int arr [ ] [ 2 ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; position ( arr , N ) ; }"}
{"text": "Pasangan yang mempunyai semua pasangan lain yang terletak di antara minimum dan maksimumnya | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari kedudukan pasangan yang meliputi setiap pasangan dalam array arr [] []; Kedudukan untuk menyimpan indeks; Menyimpan nilai kedua maksimum; Menyimpan nilai pertama minimum; Melangkah ke atas pelbagai pasangan; Kemas kini maksimum yang betul; Kemas kini minimum kiri; Melangkah ke atas pelbagai pasangan; Jika ada pasangan yang ada dengan nilai {kiri, kanan} kemudian simpannya; Cetak jawapannya; Kod pemacu; Diberikan pelbagai pasangan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) { int pos = -1 ; int right = INT_MIN ; int left = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ 1 ] > right ) { right = arr [ i ] [ 1 ] ; } if ( arr [ i ] [ 0 ] < left ) { left = arr [ i ] [ 0 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] == left && arr [ i ] [ 1 ] == right ) { pos = i + 1 ; } } cout << pos << endl ; } int main ( ) { int arr [ ] [ 2 ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; position ( arr , N ) ; }"}
{"text": "Kurangkan kiraan operasi yang diberikan untuk membuat dua permutasi rentetan yang diberikan antara satu sama lain | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk meminimumkan kiraan operasi untuk membuat permutasi Str1 dan Str2 antara satu sama lain; Simpan kekerapan setiap watak Str1; Simpan kekerapan setiap watak Str2; Melintasi freq1 [] dan freq2 []; Jika kekerapan watak dalam str1 lebih besar daripada str2; Jika tidak; Simpan jumlah Freq1 []; Simpan jumlah freq2 []; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int ctMinEdits ( string str1 , string str2 ) { int N1 = str1 . length ( ) ; int N2 = str2 . length ( ) ; int freq1 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 [ i ] ] ++ ; } int freq2 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 [ i ] ] ++ ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; } else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } } int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return max ( sum1 , sum2 ) ; } int main ( ) { string str1 = \" geeksforgeeks \" ; string str2 = \" geeksforcoder \" ; cout << ctMinEdits ( str1 , str2 ) ; }"}
{"text": "Kiraan pasangan (i, j) dari arrays arr [] & brr [] sedemikian rupa sehingga arr [i] | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira pasangan sedemikian rupa sehingga keadaan yang diberikan berpuas hati; Menyimpan jumlah elemen pada setiap indeks yang sepadan; Cari jumlah setiap indeks kedua -dua array; Kedai kekerapan setiap elemen yang terdapat di Sumarr; Memulakan bilangan pasangan; Tambah mungkin pasangan VAID; Pulangan bilangan pasangan; Kod pemacu; Diberikan array arr [] dan brr []; Saiz array yang diberikan; Fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountPairs ( int * a , int * b , int n ) { int C [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; } map < int , int > freqCount ; for ( int i = 0 ; i < n ; i ++ ) { freqCount [ C [ i ] ] ++ ; } int NoOfPairs = 0 ; for ( auto x : freqCount ) { int y = x . second ; NoOfPairs = NoOfPairs + y * ( y - 1 ) / 2 ; } cout << NoOfPairs ; } int main ( ) { int arr [ ] = { 1 , 4 , 20 , 3 , 10 , 5 } ; int brr [ ] = { 9 , 6 , 1 , 7 , 11 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; CountPairs ( arr , brr , N ) ; return 0 ; }"}
{"text": "Perubahan dalam median array yang diberikan selepas memadam elemen yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari perubahan median selepas mengeluarkan elemen dari ARR2 []; Untuk menyimpan median; Jika n adalah ganjil; Jika n juga; Cari elemen semasa dalam ARR1; Padamkan elemen; Pengurangan n; Jika n adalah ganjil; Jika n juga; Cetak perbezaan median yang sepadan; Kod yang didorong; Diberikan susunan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void medianChange ( vector < int > & arr1 , vector < int > & arr2 ) { int N = arr1 . size ( ) ; vector < float > median ; if ( N & 1 ) { median . push_back ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } for ( auto & x : arr2 ) { auto it = find ( arr1 . begin ( ) , arr1 . end ( ) , x ) ; arr1 . erase ( it ) ; N -- ; if ( N & 1 ) { median . push_back ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } } for ( int i = 0 ; i < median . size ( ) - 1 ; i ++ ) { cout << median [ i + 1 ] - median [ i ] << ' ▁ ' ; } } int main ( ) { vector < int > arr1 = { 2 , 4 , 6 , 8 , 10 } ; vector < int > arr2 = { 4 , 6 } ; medianChange ( arr1 , arr2 ) ; return 0 ; }"}
{"text": "NFA untuk menerima rentetan yang mempunyai atleast satu watak yang berlaku dalam pelbagai 3 | C ++ pelaksanaan pendekatan di atas; Pembolehubah NFA yang menjejaki keadaan semasa urus niaga. ; Pemeriksaan ini untuk input tidak sah. ; Fungsi untuk keadaan Q2; Peralihan Negeri 'A' mengambil ke Q4, dan 'B' dan 'C' kekal pada Q2; Fungsi untuk keadaan Q3; Peralihan Negeri 'A' mengambil ke Q3, dan 'B' dan 'C' kekal pada Q4; Fungsi untuk keadaan Q4; Peralihan Negeri 'A' mengambil ke Q2, dan 'B' dan 'C' kekal pada Q3; Fungsi untuk negeri Q5; Peralihan negeri 'B' mengambil ke Q6, dan 'A' dan 'C' kekal pada Q5; Fungsi untuk keadaan Q6; Peralihan Negeri 'B' mengambil Q7, dan 'A' dan 'C' kekal pada Q7; Fungsi untuk negeri Q7; Peralihan Negeri 'B' mengambil ke Q5, dan 'A' dan 'C' kekal pada Q7; Fungsi untuk negeri Q8; Peralihan Negeri 'C' mengambil Q9, dan 'A' dan 'B' kekal pada Q8; Fungsi untuk Negeri Q9; Peralihan Negeri 'C' mengambil ke Q10, dan 'A' dan 'B' kekal pada Q9; Fungsi untuk keadaan Q10; Peralihan Negeri 'C' mengambil ke Q8, dan 'A' dan 'B' kekal pada Q10; Berfungsi untuk memeriksa 3 a; Berfungsi untuk memeriksa 3 b; Berfungsi untuk memeriksa 3 c 's; Kod pemacu; Sekiranya mana -mana negeri adalah benar, iaitu, sama ada bilangan bilangan atau jumlah atau jumlahnya adalah pelbagai tiga, maka rentetan itu diterima", "code": "#include <bits/stdc++.h> NEW_LINE int nfa = 1 ; int flag = 0 ; using namespace std ; void state1 ( char c ) { if ( c == ' a ' ) nfa = 2 ; else if ( c == ' b ' c == ' c ' ) nfa = 1 ; else flag = 1 ; } void state2 ( char c ) { if ( c == ' a ' ) nfa = 3 ; else if ( c == ' b ' c == ' c ' ) nfa = 2 ; else flag = 1 ; } void state3 ( char c ) { if ( c == ' a ' ) nfa = 1 ; else if ( c == ' b ' c == ' c ' ) nfa = 3 ; else flag = 1 ; } void state4 ( char c ) { if ( c == ' b ' ) nfa = 5 ; else if ( c == ' a ' c == ' c ' ) nfa = 4 ; else flag = 1 ; } void state5 ( char c ) { if ( c == ' b ' ) nfa = 6 ; else if ( c == ' a ' c == ' c ' ) nfa = 5 ; else flag = 1 ; } void state6 ( char c ) { if ( c == ' b ' ) nfa = 4 ; else if ( c == ' a ' c == ' c ' ) nfa = 6 ; else flag = 1 ; } void state7 ( char c ) { if ( c == ' c ' ) nfa = 8 ; else if ( c == ' b ' c == ' a ' ) nfa = 7 ; else flag = 1 ; } void state8 ( char c ) { if ( c == ' c ' ) nfa = 9 ; else if ( c == ' b ' c == ' a ' ) nfa = 8 ; else flag = 1 ; } void state9 ( char c ) { if ( c == ' c ' ) nfa = 7 ; else if ( c == ' b ' c == ' a ' ) nfa = 9 ; else flag = 1 ; } bool checkA ( string s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 1 ) state1 ( s [ i ] ) ; else if ( nfa == 2 ) state2 ( s [ i ] ) ; else if ( nfa == 3 ) state3 ( s [ i ] ) ; } if ( nfa == 1 ) { return true ; } else { nfa = 4 ; } } bool checkB ( string s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 4 ) state4 ( s [ i ] ) ; else if ( nfa == 5 ) state5 ( s [ i ] ) ; else if ( nfa == 6 ) state6 ( s [ i ] ) ; } if ( nfa == 4 ) { return true ; } else { nfa = 7 ; } } bool checkC ( string s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 7 ) state7 ( s [ i ] ) ; else if ( nfa == 8 ) state8 ( s [ i ] ) ; else if ( nfa == 9 ) state9 ( s [ i ] ) ; } if ( nfa == 7 ) { return true ; } } int main ( ) { string s = \" bbbca \" ; int x = 5 ; if ( checkA ( s , x ) || checkB ( s , x ) || checkC ( s , x ) ) { cout << \" ACCEPTED \" ; } else { if ( flag == 0 ) { cout << \" NOT ▁ ACCEPTED \" ; return 0 ; } else { cout << \" INPUT ▁ OUT ▁ OF ▁ DICTIONARY . \" ; return 0 ; } } }"}
{"text": "Kiraan kedudukan sedemikian rupa sehingga semua elemen sebelum ia lebih besar | Program C ++ untuk mengira kedudukan sedemikian rupa sehingga semua elemen sebelum ia lebih besar; Fungsi untuk mengira kedudukan supaya semua elemen sebelum ia lebih besar; Count pada mulanya 1 untuk elemen pertama; Minimum awal; Melintasi array; Jika elemen semasa adalah minimum baru; Mengemas kini minimum; Kiraan kenaikan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPositionCount ( int a [ ] , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; } int main ( ) { int a [ ] = { 5 , 4 , 6 , 1 , 3 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getPositionCount ( a , n ) ; return 0 ; }"}
{"text": "Panjang maksimum L sedemikian rupa sehingga jumlah semua subarray panjang L kurang daripada k | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan jumlah maksimum dalam subarray saiz k; k mesti lebih besar; Kirakan jumlah tetingkap pertama saiz k; Kirakan jumlah tingkap yang tersisa dengan mengeluarkan elemen pertama tetingkap sebelumnya dan menambah elemen terakhir tetingkap semasa. ; Berfungsi untuk mengembalikan panjang jumlah subarray semua subarray panjang ini kurang daripada atau sama dengan k; Carian binari dari L ke R kerana semua elemen array adalah positif supaya jumlah subarray maksimum meningkat secara monotonik; Semak sama ada jumlah subarray lebih besar daripada k atau tidak; Mengemas kini panjang maksimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n , int k ) { if ( n < k ) { return -1 ; } int res = 0 ; for ( int i = 0 ; i < k ; i ++ ) res += arr [ i ] ; int curr_sum = res ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; res = max ( res , curr_sum ) ; } return res ; } int solve ( int arr [ ] , int n , int k ) { int max_len = 0 , l = 0 , r = n , m ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( maxSum ( arr , n , m ) > k ) r = m - 1 ; else { l = m + 1 ; max_len = m ; } } return max_len ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 10 ; cout << solve ( arr , n , k ) ; return 0 ; }"}
{"text": "Count of triplets dalam array yang memenuhi syarat -syarat yang diberikan | C ++ pelaksanaan pendekatan; Semua penyelesaian yang mungkin dalam persamaan 1 / a + 1 / b + 1 / c = 1; Berfungsi untuk mencari tiga kali ganda; Menyimpan indeks unsur -unsur; Semak jika Y boleh bertindak sebagai elemen tengah triplet dengan penyelesaian yang diberikan 1 / a + 1 / b + 1 / c = 1; Carian binari untuk mencari bilangan nilai yang mungkin bagi elemen pertama; Carian binari untuk mencari bilangan nilai yang mungkin bagi elemen ketiga; Sumbangan kepada jawapannya ialah pendaraban nilai yang mungkin untuk elemen pertama dan ketiga; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE #define MAX  100001 NEW_LINE #define ROW  10 NEW_LINE #define COl  3 NEW_LINE vector < int > indices [ MAX ] ; int test [ ROW ] [ COl ] = { { 2 , 3 , 6 } , { 2 , 4 , 4 } , { 2 , 6 , 3 } , { 3 , 2 , 6 } , { 3 , 3 , 3 } , { 3 , 6 , 2 } , { 4 , 2 , 4 } , { 4 , 4 , 2 } , { 6 , 2 , 3 } , { 6 , 3 , 2 } } ; int find_triplet ( int array [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . push_back ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int y = array [ i ] ; for ( int j = 0 ; j < ROW ; j ++ ) { int s = test [ j ] [ 1 ] * y ; if ( s % test [ j ] [ 0 ] != 0 ) continue ; if ( s % test [ j ] [ 2 ] != 0 ) continue ; int x = s / test [ j ] [ 0 ] ; ll z = s / test [ j ] [ 2 ] ; if ( x > MAX z > MAX ) continue ; int l = 0 ; int r = indices [ x ] . size ( ) - 1 ; int first = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ x ] [ m ] < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . size ( ) - 1 ; int third = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ z ] [ m ] > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != -1 && third != -1 ) { answer += ( first + 1 ) * ( indices [ z ] . size ( ) - third ) ; } } } return answer ; } int main ( ) { int array [ ] = { 2 , 4 , 5 , 6 , 7 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << find_triplet ( array , n ) ; return 0 ; }"}
{"text": "Unsur -unsur bersebelahan yang berbeza dalam array binari | C ++ pelaksanaan pendekatan di atas; Jika array hanya mempunyai satu elemen, kembali 1; Untuk elemen pertama bandingkan dengan hanya elemen seterusnya; Untuk unsur -unsur yang tersisa berbanding dengan kedua -dua elemen sebelumnya dan seterusnya; Untuk elemen terakhir bandingkan dengan hanya elemen sebelumnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinct ( int arr [ ] , int n ) { int count = 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << distinct ( arr , n ) ; return 0 ; }"}
{"text": "Semak jika pelbagai pasangan boleh disusun dengan menukar pasangan dengan elemen pertama yang berbeza | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada array disusun atau tidak; Melintasi array arr []; Kembali benar; Fungsi untuk memeriksa sama ada mungkin untuk menyusun array w. r. t. elemen pertama; Menyimpan id elemen pertama; Melintasi array arr []; Jika arr [i]. Kedua tidak sama dengan kumpulan; Jika array disusun; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSorted ( pair < int , int > * arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] . first > arr [ i - 1 ] . first ) { return false ; } } return true ; } string isPossibleToSort ( pair < int , int > * arr , int N ) { int group = arr [ 0 ] . second ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] . second != group ) { return \" Yes \" ; } } if ( isSorted ( arr , N ) ) { return \" Yes \" ; } else { return \" No \" ; } } int main ( ) { pair < int , int > arr [ ] = { { 340000 , 2 } , { 45000 , 1 } , { 30000 , 2 } , { 50000 , 4 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << isPossibleToSort ( arr , N ) ; return 0 ; }"}
{"text": "Cari skor alpha langkah -langkah yang diberikan (menggunakan BST) | Program C ++ untuk melaksanakan pendekatan di atas; Struktur nod; Berfungsi untuk mengira dan mengembalikan skor alpha perjalanan; Traverse kiri subtree; Kirakan skor alpha langkah semasa; Kemas kini skor Alpha perjalanan; Melintasi subtree kanan; Kembali; Berfungsi untuk membina BST dari array array yang disusun []; Masukkan akar; Membina subtree kiri; Membina subtree kanan; Pulangan akar; Kod pemacu; Susun array; Bina BST dari array yang disusun", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; static long sum = 0 , total_sum = 0 ; static long mod = 1000000007 ; struct Node { Node * left , * right ; int data ; Node ( int x ) { data = x ; left = NULL ; right = NULL ; } } ; long getAlphaScore ( Node * node ) { if ( node -> left != NULL ) getAlphaScore ( node -> left ) ; sum = ( sum + node -> data ) % mod ; total_sum = ( total_sum + sum ) % mod ; if ( node -> right != NULL ) getAlphaScore ( node -> right ) ; return total_sum ; } Node * constructBST ( int arr [ ] , int start , int end , Node * root ) { if ( start > end ) return NULL ; int mid = ( start + end ) / 2 ; if ( root == NULL ) root = new Node ( arr [ mid ] ) ; root -> left = constructBST ( arr , start , mid - 1 , root -> left ) ; root -> right = constructBST ( arr , mid + 1 , end , root -> right ) ; return root ; } int main ( ) { int arr [ ] = { 10 , 11 , 12 } ; int length = 3 ; sort ( arr , arr + length ) ; Node * root = NULL ; root = constructBST ( arr , 0 , length - 1 , root ) ; cout << ( getAlphaScore ( root ) ) ; }"}
{"text": "Menyusun elemen array mengikut kekerapan dalam penurunan urutan | Program C ++ untuk menyusun array dalam penurunan urutan kekerapan mereka; Fungsi yang mengembalikan indeks sehingga semua elemen array dikemas kini. ; Permulaan maxe = - 1; Cari elemen maksimum ARR []; Membuat frekuensi array freq []; Mengemas kini array frekuensi mengikut kejadian elemen dalam arr []; Permulaan CNT hingga 0; Melintasi freq []; Jika freq dari elemen lebih besar daripada 0 mengemas kini nilai ARR [] pada indeks CNT & kenaikan CNT; Kembali CNT; Fungsi yang mencetak array arr [] elemen dalam urutan yang disusun; Melintasi arr [] sehingga indeks cnt; Cari kekerapan elemen; Cari nilai di Indeks I; Melintasi kekerapan untuk mencetak nilai pada indeks I; Kod pemacu; Saiz array arr []; Fungsi panggilan untuk mendapatkan CNT; Susun arr [] dalam penurunan urutan; Fungsi yang mencetak elemen dalam penurunan urutan", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; int sortByFreq ( int * arr , int n ) { int maxE = -1 ; for ( int i = 0 ; i < n ; i ++ ) { maxE = max ( maxE , arr [ i ] ) ; } int freq [ maxE + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i <= maxE ; i ++ ) { if ( freq [ i ] > 0 ) { int value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } } return cnt ; } void printSortedArray ( int * arr , int cnt ) { for ( int i = 0 ; i < cnt ; i ++ ) { int frequency = arr [ i ] / 100000 ; int value = 100000 - ( arr [ i ] % 100000 ) ; for ( int j = 0 ; j < frequency ; j ++ ) { cout << value << ' ▁ ' ; } } } int main ( ) { int arr [ ] = { 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int cnt = sortByFreq ( arr , n ) ; sort ( arr , arr + cnt , greater < int > ( ) ) ; printSortedArray ( arr , cnt ) ; return 0 ; }"}
{"text": "Semak jika N Rectangles kawasan yang sama boleh dibentuk dari (4 * n) integer | C ++ pelaksanaan pendekatan; Berfungsi untuk memeriksa sama ada kita boleh membuat segi empat tepat kawasan yang sama; Susun array; Cari kawasan mana -mana segi empat tepat; Semak sama ada kita mempunyai dua sisi yang sama untuk setiap segi empat tepat dan kawasan setiap segi empat tepat yang terbentuk adalah sama; Kemas kini jawapan kepada palsu jika keadaan gagal; Jika boleh; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkRectangles ( int * arr , int n ) { bool ans = true ; sort ( arr , arr + 4 * n ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 } ; int n = 2 ; if ( checkRectangles ( arr , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Count of Elements yang tidak berada di kedudukan yang betul | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan elemen yang tidak berada di kedudukan yang betul apabila disusun; Untuk menyimpan salinan array asal; Salin unsur -unsur array yang diberikan kepada array baru; Untuk menyimpan kiraan yang diperlukan; Susun array asal; Jika elemen semasa tidak berada di kedudukan yang betul; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntElements ( int arr [ ] , int n ) { int copy_arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 6 , 2 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntElements ( arr , n ) ; return 0 ; }"}
{"text": "Cari k yang diperintahkan pasangan dalam array dengan perbezaan minimum d | C ++ pelaksanaan pendekatan; Fungsi untuk mencari pasangan yang diperlukan; Harus ada elemen 2 * k; Untuk menyimpan pasangan; Susun array yang diberikan; Untuk setiap pasangan yang mungkin; Jika pasangan semasa adalah sah; Masukkannya ke dalam vektor pasangan; Jika pasangan k tidak mungkin; Cetak pasangan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int arr [ ] , int n , int k , int d ) { if ( n < 2 * k ) { cout << -1 ; return ; } vector < pair < int , int > > pairs ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < k ; i ++ ) { if ( arr [ n - k + i ] - arr [ i ] >= d ) { pair < int , int > p = make_pair ( arr [ i ] , arr [ n - k + i ] ) ; pairs . push_back ( p ) ; } } if ( pairs . size ( ) < k ) { cout << -1 ; return ; } for ( auto v : pairs ) { cout << \" ( \" << v . first << \" , ▁ \" << v . second << \" ) \" << endl ; } } int main ( ) { int arr [ ] = { 4 , 6 , 10 , 23 , 14 , 7 , 2 , 20 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 , d = 3 ; findPairs ( arr , n , k , d ) ; return 0 ; }"}
{"text": "Kira pasangan dengan jumlah yang diberikan | Tetapkan 2 | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan pasangan dari arr [] dengan jumlah yang diberikan; Untuk menyimpan kiraan pasangan; Susun array yang diberikan; Ambil dua petunjuk; Jika jumlahnya lebih besar; Jika jumlahnya lebih rendah; Jika jumlahnya sama; Cari kekerapan arr [i]; Cari kekerapan Arr [J]; Jika arr [i] dan arr [j] sama maka keluarkan nombor tambahan yang dikira; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int pairs_count ( int arr [ ] , int n , int sum ) { int ans = 0 ; sort ( arr , arr + n ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( i < j and arr [ i ] == x ) i ++ ; int y = arr [ j ] , yy = j ; while ( j >= i and arr [ j ] == y ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 , 5 , -1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 6 ; cout << pairs_count ( arr , n , sum ) ; return 0 ; }"}
{"text": "Semak jika rentetan mengandungi huruf berturut -turut dan setiap huruf berlaku tepat sekali | Program C ++ untuk melaksanakan pendekatan di atas; Untuk semua watak rentetan; Cari nilai ASCII watak; Semak sama ada watak yang sah, jika tidak maka kembali palsu; Hitung jumlah semua nilai ASCII; Cari nilai ASCII minimum dari rentetan; Cari nilai ASCII maksimum dari rentetan; Untuk mendapatkan elemen sebelumnya nilai ASCII minimum; Ambil jumlah yang diharapkan dari persamaan di atas; Semak sama ada jumlah yang dijangkakan adalah sama dengan jumlah yang dikira atau tidak; Kod pemacu; Contoh 1 st; Contoh 2 nd", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string str ) { int min = INT_MAX ; int max = - INT_MAX ; int sum = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { int ascii = str [ i ] ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; } int main ( ) { string str = \" dcef \" ; if ( check ( str ) ) cout << ( \" Yes \" ) ; else cout << ( \" No \" ) ; string str1 = \" xyza \" ; if ( check ( str1 ) ) cout << ( \" Yes \" else cout << ( \" No \" }"}
{"text": "K | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari jumlah minimum semua subarray; Masukkan semua elemen dalam satu set; Cari elemen maksimum dan minimum; Melintasi unsur minimum hingga maksimum; Semak sama ada \"Saya\" hilang; Semak sama ada kth hilang; Jika tiada elemen kth hilang; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findKth ( int arr [ ] , int n , int k ) { unordered_set < int > missing ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) missing . insert ( arr [ i ] ) ; int maxm = * max_element ( arr , arr + n ) ; int minm = * min_element ( arr , arr + n ) ; for ( int i = minm + 1 ; i < maxm ; i ++ ) { if ( missing . find ( i ) == missing . end ( ) ) count ++ ; if ( count == k ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { 2 , 10 , 9 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; cout << findKth ( arr , n , k ) ; return 0 ; }"}
{"text": "Susun senarai yang dipautkan yang mengandungi nilai dari 1 hingga n | Program C ++ untuk menyusun senarai berkaitan yang mengandungi nilai dari 1 hingga n; Nod senarai yang dipautkan; Berfungsi untuk menyusun senarai yang dipautkan; Berfungsi untuk menambah nod pada permulaan senarai yang dipautkan; memperuntukkan nod; masukkan data; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Fungsi ini mencetak kandungan senarai yang dipautkan bermula dari nod yang diberikan; Program pemacu untuk menguji fungsi di atas; Senarai yang dipautkan yang dibina ialah: 3 -> 5 -> 4 -> 6 -> 1 -> 2", "code": "#include <iostream> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool sortList ( struct Node * head ) { int startVal = 1 ; while ( head != NULL ) { head -> data = startVal ; startVal ++ ; head = head -> next ; } } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << \" ▁ \" ; node = node -> next ; } } int main ( ) { struct Node * start = NULL ; push ( & start , 2 ) ; push ( & start , 1 ) ; push ( & start , 6 ) ; push ( & start , 4 ) ; push ( & start , 5 ) ; push ( & start , 3 ) ; sortList ( start ) ; printList ( start ) ; return 0 ; }"}
{"text": "Semak jika senarai yang dipautkan disusun (berulang dan rekursif) | Program C ++ untuk menyemak senarai yang dipautkan secara rekursif disusun mengikut urutan menurun atau tidak; Nod senarai yang dipautkan; fungsi untuk menyemak senarai yang dipautkan disusun mengikut urutan menurun atau tidak; Kes asas; Semak dua nod pertama dan semak semula rekursif. ; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isSortedDesc ( struct Node * head ) { if ( head == NULL head -> next == NULL ) return true ; return ( head -> data > head -> next -> data && isSortedDesc ( head -> next ) ) ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> next = NULL ; temp -> data = data ; } int main ( ) { struct Node * head = newNode ( 7 ) ; head -> next = newNode ( 5 ) ; head -> next -> next = newNode ( 4 ) ; head -> next -> next -> next = newNode ( 3 ) ; isSortedDesc ( head ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }"}
{"text": "Susun semula array untuk meminimumkan jumlah produk elemen pasangan berturut -turut | Program C ++ untuk menyusun array sedemikian rupa sehingga jumlah produk elemen alternatif adalah minimum. ; Buat Evenarr [] dan Oddarr []; Susun pelbagai utama dalam urutan menaik; Letakkan unsur -unsur di Oddarr [] dan evenarr [] seperti nilai yang dikehendaki. ; Susun everarr [] dalam urutan menurun; menggabungkan kedua -dua sub - array dan mengira jumlah minimum produk elemen alternatif; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSum ( int arr [ ] , int n ) { vector < int > evenArr ; vector < int > oddArr ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) oddArr . push_back ( arr [ i ] ) ; else evenArr . push_back ( arr [ i ] ) ; } sort ( evenArr . begin ( ) , evenArr . end ( ) , greater < int > ( ) ) ; int i = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; arr [ i ++ ] = oddArr [ j ] ; sum += evenArr [ j ] * oddArr [ j ] ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Minimum ▁ required ▁ sum ▁ = ▁ \" << minSum ( arr , n ) ; cout << \" Sorted array in required format : \" ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; return 0 ; }"}
{"text": "Masa minimum diperlukan untuk mencetak rentetan yang diberikan dari bekas bulat berdasarkan syarat yang diberikan | C ++ pelaksanaan untuk pendekatan di atas; Berfungsi untuk mengira masa minimum untuk mencetak semua aksara dalam rentetan; Elemen semasa di mana penunjuk sedang menunjuk; Cari indeks elemen itu; Kirakan perbezaan mutlak antara indeks penunjuk dan indeks aksara sebagai jarak mengikut arah jam; Kurangkan masa mengikut arah jam dari 26 untuk mendapatkan masa anti -jam; Tambah minimum kedua -dua kali untuk jawapannya; Tambah satu unit masa untuk mencetak watak; Cetak jawapan terakhir; Kod pemacu; Diberikan perkataan rentetan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minTime ( string word ) { int ans = 0 ; int curr = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { int k = word [ i ] - ' a ' ; int a = abs ( curr - k ) ; int b = 26 - abs ( curr - k ) ; ans += min ( a , b ) ; ans ++ ; curr = word [ i ] - ' a ' ; } cout << ans ; } int main ( ) { string str = \" zjpc \" ; minTime ( str ) ; return 0 ; }"}
{"text": "Pengurangan minimum atau pembahagian oleh pembahagi yang betul yang diperlukan untuk mengurangkan N hingga 1 | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari bilangan langkah minimum yang diperlukan untuk mengurangkan n hingga 1; Menyimpan bilangan langkah yang diperlukan; Jika nilai n sama dengan 2 atau n adalah ganjil; Penurunan n oleh 1; Kenaikan CNT oleh 1; Jika n juga; Kemas kini n; Kenaikan CNT oleh 1; Mengembalikan bilangan langkah yang diperoleh; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int reduceToOne ( long long int N ) { int cnt = 0 ; while ( N != 1 ) { if ( N == 2 or ( N % 2 == 1 ) ) { N = N - 1 ; cnt ++ ; } else if ( N % 2 == 0 ) { N = N / ( N / 2 ) ; cnt ++ ; } } return cnt ; } int main ( ) { long long int N = 35 ; cout << reduceToOne ( N ) ; return 0 ; }"}
{"text": "Bilangan maksimum berlian yang boleh diperolehi dalam minit k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan maksimum berlian yang boleh diperolehi dalam beberapa minit; Menyimpan semua elemen array; Tolak semua elemen ke barisan keutamaan; Menyimpan hasil yang diperlukan; Gelung manakala barisan tidak kosong dan k positif; Simpan elemen teratas dari PQ; Pop dari PQ; Tambahkannya kepada jawapannya; Bahagikannya dengan 2 dan tolaknya kembali ke PQ; Cetak jawapannya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxDiamonds ( int A [ ] , int N , int K ) { priority_queue < int > pq ; for ( int i = 0 ; i < N ; i ++ ) { pq . push ( A [ i ] ) ; } int ans = 0 ; while ( ! pq . empty ( ) && K -- ) { int top = pq . top ( ) ; pq . pop ( ) ; ans += top ; top = top / 2 ; pq . push ( top ) ; } cout << ans ; } int main ( ) { int A [ ] = { 2 , 1 , 7 , 4 , 2 } ; int K = 3 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maxDiamonds ( A , N , K ) ; return 0 ; }"}
{"text": "Kurangkan kos kenaikan atau pengurangan seperti unsur -unsur yang diindeks yang sama menjadi pelbagai antara satu sama lain | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari kos minimum untuk membuat [i] berbilang b [i] atau naib - sebaliknya untuk setiap elemen array; Menyimpan kos minimum; Melintasi array; Kes 1: Kemas kini [i]; Kes 2: Kemas kini B [i]; Tambah minimum dua kes di atas; Mengembalikan kos yang dihasilkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumCost ( int A [ ] , int B [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int mod_A = B [ i ] % A [ i ] ; int totalCost_A = min ( mod_A , A [ i ] - mod_A ) ; int mod_B = A [ i ] % B [ i ] ; int totalCost_B = min ( mod_B , B [ i ] - mod_B ) ; totalCost += min ( totalCost_A , totalCost_B ) ; } return totalCost ; } int main ( ) { int A [ ] = { 3 , 6 , 3 } ; int B [ ] = { 4 , 8 , 13 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << MinimumCost ( A , B , N ) ; return 0 ; }"}
{"text": "Nombor terbesar dibahagi dengan 50 yang boleh dibentuk dari satu set digit N yang terdiri daripada 0 s dan 7 s sahaja | Program C ++ untuk pendekatan di atas; Cetak nombor terbesar yang boleh dibahagikan dengan 50; Mengira nombor 0 s dan 7 s; Jika kiraan 7 boleh dibahagikan dengan 50; Jika kiraan 7 kurang daripada 5; Jika kiraan 7 tidak boleh dibahagikan dengan 50; Count kumpulan 5 di mana kiraan 7 s boleh dikumpulkan; Kod pemacu; Diberikan array; Saiz array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLargestDivisible ( int arr [ ] , int N ) { int i , count0 = 0 , count7 = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; else count7 ++ ; } if ( count7 % 50 == 0 ) { while ( count7 -- ) cout << 7 ; while ( count0 -- ) cout << 0 ; } else if ( count7 < 5 ) { if ( count0 == 0 ) cout << \" No \" ; else cout << \"0\" ; } else { count7 = count7 - count7 % 5 ; while ( count7 -- ) cout << 7 ; while ( count0 -- ) cout << 0 ; } } int main ( ) { int arr [ ] = { 0 , 7 , 0 , 7 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 7 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printLargestDivisible ( arr , N ) ; return 0 ; }"}
{"text": "Susun semula Arahan untuk memaksimumkan jumlah GCD unsur -unsur array dengan indeks masing -masing | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari jumlah maksimum GCD (arr [i], i) dengan menyusun semula array; Susun array dalam urutan menaik; Kedai maksimum jumlah GCD (arr [i], i) dengan menyusun semula elemen array; Menjana semua permutasi yang mungkin dari array; Kedai jumlah GCD (arr [i], i); Melintasi array; Kemas kini Jumlah; Kemas kini res; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxValByRearrArr ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int res = 0 ; do { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += __gcd ( i + 1 , arr [ i ] ) ; } res = max ( res , sum ) ; } while ( next_permutation ( arr , arr + N ) ) ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxValByRearrArr ( arr , N ) ; return 0 ; }"}
{"text": "Penyingkiran minimum diperlukan untuk membuat kekerapan setiap elemen array sama dengan nilainya | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari kiraan minimum elemen yang diperlukan untuk dikeluarkan sedemikian rupa sehingga kekerapan arr [i] sama dengan arr [i]; Kedai kekerapan setiap elemen array; Melintasi array; Kemas kini kekerapan ARR [i]; Kedai kiraan minimum penyingkiran; Melintasi peta; Menyimpan nilai utama peta; Jika kekerapan saya kurang daripada saya; Mengemas kini cntminrem; Jika kekerapan saya lebih besar daripada saya; Mengemas kini cntminrem; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_elements ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } int cntMinRem = 0 ; for ( auto it : mp ) { int i = it . first ; if ( mp [ i ] < i ) { cntMinRem += mp [ i ] ; } else if ( mp [ i ] > i ) { cntMinRem += ( mp [ i ] - i ) ; } } return cntMinRem ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 4 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min_elements ( arr , N ) ; return 0 ; }"}
{"text": "Peningkatan minimum untuk membuat semua elemen array sama dengan jumlah yang sama dengan array yang diberikan selepas tepat satu penyingkiran | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada pelbagai elemen yang sama dengan jumlah yang sama dengan array yang diberikan boleh diperoleh atau tidak; Kes asas; Kedai jumlah elemen array; Menyimpan elemen array kedua terbesar; Menyimpan elemen array terbesar; Melintasi array; Kemas kini SecMax; Kemas kini Max; Kemas kini SecMax; Kemas kini totalsum; Jika totalsum kurang daripada secmax * (n - 1)); Jika totalsum tidak boleh dibahagikan dengan (n - 1); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool CheckAllarrayEqual ( int arr [ ] , int N ) { if ( N == 1 ) { return true ; } int totalSum = arr [ 0 ] ; int secMax = INT_MIN ; int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= Max ) { secMax = Max ; Max = arr [ i ] ; } else if ( arr [ i ] > secMax ) { secMax = arr [ i ] ; } totalSum += arr [ i ] ; } if ( ( secMax * ( N - 1 ) ) > totalSum ) { return false ; } if ( totalSum % ( N - 1 ) ) { return false ; } return true ; } int main ( ) { int arr [ ] = { 6 , 2 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( CheckAllarrayEqual ( arr , N ) ) { cout << \" YES \" ; } else { cout << \" NO \" ; } }"}
{"text": "Kira cara untuk membuat bitwise xor ganjil dan bahkan elemen diindeks sama dengan mengeluarkan elemen array | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira cara untuk membuat bitwise xor aneh dan bahkan elemen diindeks sama dengan mengeluarkan elemen array; Kedai xor unsur -unsur ganjil dan bahkan diindeks dari akhir; Kedai xor unsur -unsur ganjil dan bahkan diindeks dari awal; Menyimpan kiraan yang diperlukan; Melintasi array secara terbalik; Sekiranya saya ganjil; Sekiranya saya juga; Melintasi array; Sekiranya saya ganjil; Sekiranya saya juga; Mengeluarkan arr [i], kedai post_even xor unsur -unsur yang diindeks ganjil; Mengeluarkan arr [i], post_odd menyimpan xor walaupun elemen yang diindeks; Semak sama ada mereka sama; Jika saya ganjil, xor dengan curr_odd; Jika saya juga, xor dengan curr_even; Akhirnya cetak res; Kod pemacu; Diberikan array; Saiz yang diberikan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Remove_one_element ( int arr [ ] , int n ) { int post_odd = 0 , post_even = 0 ; int curr_odd = 0 , curr_even = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; int X = curr_odd ^ post_even ; int Y = curr_even ^ post_odd ; if ( X == Y ) res ++ ; if ( i % 2 ) curr_odd ^= arr [ i ] ; else curr_even ^= arr [ i ] ; } cout << res << endl ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Remove_one_element ( arr , N ) ; return 0 ; }"}
{"text": "Kira cara untuk membuat jumlah elemen ganjil dan bahkan diindeks sama dengan mengeluarkan elemen array | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira indeks array yang penyingkirannya menjadikan jumlah unsur -unsur yang ganjil dan juga diindeks sama; Jika saiz array adalah 1; Jika saiz array adalah 2; Kedai -kedai jumlah unsur -unsur yang diindeks dari array yang diberikan; Kedai Jumlah unsur -unsur yang diindeks dari array yang diberikan; Melintasi array; Jika saya adalah nombor yang sama; Kemas kini Sumeven; Jika saya adalah nombor ganjil; Kemas kini Sumodd; Kedai Jumlah unsur -unsur array yang diindeks sehingga indeks i - th; Kedai Jumlah unsur array yang diindeks sehingga indeks i - th; Kedai -kedai mengira indeks yang penyingkirannya membuat jumlah unsur -unsur yang ganjil dan juga diindeks sama; Kedai -kedai jumlah unsur -unsur yang diindeks selepas mengeluarkan elemen i - th; Kedai Jumlah unsur -unsur yang diindeks selepas mengeluarkan elemen i - th; Melintasi array; Jika saya adalah nombor ganjil; Kemas kini Currodd; Kemas kini Newevensum; Kemas kini Newoddsum; Jika saya adalah nombor yang sama; Kemas kini Curreven; Kemas kini Newoddsum; Kemas kini Newevensum; Jika Newevensum sama dengan Newoddsum; Meningkatkan kiraan; Jika jumlah unsur -unsur yang diindeks dan ganjil - diindeks adalah sama dengan mengeluarkan elemen pertama; Meningkatkan kiraan; Jika panjang array adalah nombor ganjil; Jika jumlah unsur -unsur yang diindeks dan ganjil - diindeks adalah sama dengan mengeluarkan elemen terakhir; Meningkatkan kiraan; Jika panjang array adalah nombor yang sama; Jika jumlah unsur -unsur yang diindeks dan ganjil - diindeks adalah sama dengan mengeluarkan elemen terakhir; Meningkatkan kiraan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntIndexesToMakeBalance ( int arr [ ] , int n ) { if ( n == 1 ) { return 1 ; } if ( n == 2 ) return 0 ; int sumEven = 0 ; int sumOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { sumEven += arr [ i ] ; } else { sumOdd += arr [ i ] ; } } int currOdd = 0 ; int currEven = arr [ 0 ] ; int res = 0 ; int newEvenSum = 0 ; int newOddSum = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( i % 2 ) { currOdd += arr [ i ] ; newEvenSum = currEven + sumOdd - currOdd ; newOddSum = currOdd + sumEven - currEven - arr [ i ] ; } else { currEven += arr [ i ] ; newOddSum = currOdd + sumEven - currEven ; newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; } if ( newEvenSum == newOddSum ) { res ++ ; } } if ( sumOdd == sumEven - arr [ 0 ] ) { res ++ ; } if ( n % 2 == 1 ) { if ( sumOdd == sumEven - arr [ n - 1 ] ) { res ++ ; } } else { if ( sumEven == sumOdd - arr [ n - 1 ] ) { res ++ ; } } return res ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntIndexesToMakeBalance ( arr , n ) ; return 0 ; }"}
{"text": "Cari dua nombor dari jumlah dan xor mereka | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari nilai a dan b yang jumlahnya adalah x dan xor adalah y; Memulakan dua nombor; Kes 1: x <y; Kes 2: x - y adalah ganjil; Kes 3: Jika kedua -dua jumlah dan XOR adalah sama; Kes 4: jika di atas kes gagal; Kemas kini nilai a; Semak jika nilai A & Y ialah 0; Jika benar, kemas kini b; Sebaliknya berikan - 1 hingga a, - 1 hingga b; Cetak nombor A dan B; Kod pemacu; Diberikan jumlah dan xor 2 nombor; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNums ( int X , int Y ) { int A , B ; if ( X < Y ) { A = -1 ; B = -1 ; } else if ( abs ( X - Y ) & 1 ) { A = -1 ; B = -1 ; } else if ( X == Y ) { A = 0 ; B = Y ; } else { A = ( X - Y ) / 2 ; if ( ( A & Y ) == 0 ) { B = ( A + Y ) ; } else { A = -1 ; B = -1 ; } } cout << A << \" ▁ \" << B ; } int main ( ) { int X = 17 , Y = 13 ; findNums ( X , Y ) ; return 0 ; }"}
{"text": "Pertanyaan untuk memeriksa sama ada kiraan peningkatan dan penurunan subarray adalah sama dalam julat yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada julat yang diberikan mempunyai bilangan yang sama dan penurunan subarrays; Melintasi setiap pertanyaan; Untuk pengindeksan berasaskan 0; Keadaan untuk kiraan yang sama meningkatkan & menurunkan subarray; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkCount ( int A [ ] , int Q [ ] [ 2 ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i ] [ 0 ] ; int R = Q [ i ] [ 1 ] ; L -- , R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { cout << \" Yes STRNEWLINE \" ; } else { cout << \" No STRNEWLINE \" ; } } } int main ( ) { int arr [ ] = { 11 , 13 , 12 , 14 } ; int Q [ ] [ 2 ] = { { 1 , 4 } , { 2 , 4 } } ; int q = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; checkCount ( arr , Q , q ) ; return 0 ; }"}
{"text": "Purata array yang dihasilkan oleh produk semua pasang array yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari min pasangan array arr []; Menyimpan produk pasangan; Menjana semua pasangan yang tidak teratur; Menyimpan produk pasangan; Saiz PairArray; Simpan Jumlah PairArray; Menyimpan min PairArray []; Cari min PairArray []; Mengembalikan maksud yang dihasilkan; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float pairProductMean ( int arr [ ] , int N ) { vector < int > pairArray ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . push_back ( pairProduct ) ; } } int length = pairArray . size ( ) ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << fixed << setprecision ( 2 ) << pairProductMean ( arr , N ) ; return 0 ; }"}
{"text": "Cari pemain yang terakhir untuk mengeluarkan apa -apa watak dari permulaan rentetan binari | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari pemain yang kehilangan permainan; Bergerak untuk pemain pertama; Bergerak untuk pemain kedua; Melangkah ke atas pelbagai rentetan; Semak sama ada watak pertama dan terakhir adalah sama; Semak jika rentetan bermula dan berakhir dengan aksara '0'; Jika pemain pertama mempunyai kurang bergerak; Kod pemacu; Diberikan pelbagai rentetan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPlayer ( string str [ ] , int n ) { int move_first = 0 ; int move_sec = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] [ 0 ] == str [ i ] [ str [ i ] . length ( ) - 1 ] ) { if ( str [ i ] [ 0 ] == 48 ) move_first ++ ; else move_sec ++ ; } } if ( move_first <= move_sec ) { cout << \" Player ▁ 2 ▁ wins \" ; } else { cout << \" Player ▁ 1 ▁ wins \" ; } } int main ( ) { string str [ ] = { \"010\" , \"101\" } ; int N = sizeof ( str ) / sizeof ( str [ 0 ] ) ; findPlayer ( str , N ) ; return 0 ; }"}
{"text": "Bilangan terkecil melebihi n yang bit kth ditetapkan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari nombor yang lebih besar daripada n yang bit kthnya ditetapkan; Berulang dari n + 1; Semak sama ada bit kth ditetapkan atau tidak; Kenaikan m untuk nombor seterusnya; Mengembalikan nilai minimum; Kod pemacu; Diberikan n dan k; Panggilan fungsi", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; int find_next ( int n , int k ) { int M = n + 1 ; while ( 1 ) { if ( M & ( 1ll << k ) ) break ; M ++ ; } return M ; } int main ( ) { int N = 15 , K = 2 ; cout << find_next ( N , K ) ; return 0 ; }"}
{"text": "Bilangan terkecil melebihi n yang bit kth ditetapkan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari nombor yang lebih besar daripada n yang bit kthnya ditetapkan; Menyimpan nombor yang dihasilkan; Jika bit kth tidak ditetapkan; Cur akan menjadi jumlah semua kuasa 2 <k; Jika bit semasa ditetapkan; Tambah kuasa kth 2 hingga n dan tolak semua kuasa 2 kurang daripada k yang ditetapkan; Jika bit kth ditetapkan; Kedudukan bit pertama yang pertama; Jumlah bit yang ditetapkan; Tambah kuasa kth 2 hingga n dan tolak semua kuasa 2 kurang daripada k yang ditetapkan; Jika kth bit menjadi tidak tersendiri maka tetapkannya lagi; Mengembalikan nombor yang dihasilkan; Kod pemacu; Cetak Ans", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; int find_next ( int n , int k ) { int ans = 0 ; if ( ( n & ( 1ll << k ) ) == 0 ) { int cur = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( n & ( 1ll << i ) ) cur += 1ll << i ; } ans = n - cur + ( 1ll << k ) ; } else { int first_unset_bit = -1 , cur = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( n & ( 1ll << i ) ) == 0 ) { first_unset_bit = i ; break ; } else cur += ( 1ll << i ) ; } ans = n - cur + ( 1ll << first_unset_bit ) ; if ( ( ans & ( 1ll << k ) ) == 0 ) ans += ( 1ll << k ) ; } return ans ; } int main ( ) { int N = 15 , K = 2 ; cout << find_next ( N , K ) ; return 0 ; }"}
{"text": "Lexicographically terbesar mungkin rentetan selepas penyingkiran Kara K | Program C ++ untuk melaksanakan pendekatan di atas; rentetan hasil akhir; Jika char semasa melebihi watak di bahagian atas timbunan; Keluarkan dari hujung rentetan; Kurangkan k untuk penyingkiran; Masukkan watak semasa; Lakukan penghapusan k yang tersisa dari akhir rentetan; Kembalikan rentetan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string largestString ( string num , int k ) { string ans = \" \" ; for ( auto i : num ) { while ( ans . length ( ) && ans . back ( ) < i && k > 0 ) { ans . pop_back ( ) ; k -- ; } ans . push_back ( i ) ; } while ( ans . length ( ) and k -- ) { ans . pop_back ( ) ; } return ans ; } int main ( ) { string str = \" zyxedcba \" ; int k = 1 ; cout << largestString ( str , k ) << endl ; }"}
{"text": "Panjang maksimum subarray yang terdiri daripada jenis elemen yang sama pada kedua -dua bahagian sub | Program C ++ untuk pendekatan di atas; Fungsi yang mendapati panjang maksimum sub -sub -yang mengandungi elemen yang sama pada kedua -dua bahagian sub -array; Untuk menyimpan kejadian berterusan unsur; Untuk menyimpan kejadian ke hadapan yang berterusan; Untuk menyimpan kejadian mundur yang berterusan; Untuk menyimpan panjang maksimum; Cari panjang maksimum; Cetak hasilnya; Kod pemacu; Diberikan array; Saiz array; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxLengthSubArray ( int A [ ] , int N ) { int forward [ N ] , backward [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; } int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = max ( ans , min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; } cout << ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 6 , 6 , 6 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxLengthSubArray ( arr , N ) ; return 0 ; }"}
{"text": "Nombor digit terkecil divisible oleh semua angka utama yang mungkin | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari bilangan minimum n digit yang boleh dibahagikan oleh semua digit utama; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minNum ( int n ) { if ( n < 3 ) cout << -1 ; else cout << ( 210 * ( ( int ) ( pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; } int main ( ) { int n = 5 ; minNum ( n ) ; return 0 ; }"}
{"text": "Nombor terkecil lebih besar daripada y dengan jumlah digit yang sama dengan x | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengembalikan rentetan minimum panjang d yang mempunyai jumlah digit s; Mengembalikan rentetan panjang d; Ramuan meletakkan 9 pada akhirnya; Masukkan jumlah yang tersisa; Berfungsi untuk mencari nombor terkecil yang lebih besar daripada y yang jumlah digitnya adalah x; Tukar nombor y ke rentetan; Mengekalkan jumlah awalan digit; Melangkah ke atas Y dari belakang di mana k adalah panjang akhiran semasa; Kedai digit semasa; Meningkatkan digit semasa; Jumlah awalan semasa; Kembali Jawapan Jika baki jumlah boleh diperolehi dalam akhiran; Cari akhiran panjang k mempunyai jumlah digit x - r; Tambah watak semasa; Mengembalikan hasilnya; Kod pemacu; Diberi nombor dan jumlah; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string helper ( int d , int s ) { string ans ( d , '0' ) ; for ( int i = d - 1 ; i >= 0 ; i -- ) { if ( s >= 9 ) { ans [ i ] = '9' ; s -= 9 ; } else { char c = ( char ) s + '0' ; ans [ i ] = c ; s = 0 ; } } return ans ; } string findMin ( int x , int Y ) { string y = to_string ( Y ) ; int n = y . size ( ) ; vector < int > p ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = y [ i ] - '0' ; if ( i > 0 ) p [ i ] += p [ i - 1 ] ; } for ( int i = n - 1 , k = 0 ; ; i -- , k ++ ) { int d = 0 ; if ( i >= 0 ) d = y [ i ] - '0' ; for ( int j = d + 1 ; j <= 9 ; j ++ ) { int r = ( i > 0 ) * p [ i - 1 ] + j ; if ( x - r >= 0 and x - r <= 9 * k ) { string suf = helper ( k , x - r ) ; string pre = \" \" ; if ( i > 0 ) pre = y . substr ( 0 , i ) ; char cur = ( char ) j + '0' ; pre += cur ; return pre + suf ; } } } } int main ( ) { int x = 18 ; int y = 99 ; cout << findMin ( x , y ) << endl ; return 0 ; }"}
{"text": "Nombor terbesar yang terdiri daripada x dan y dengan kiraan x dibahagi dengan y dan y oleh x | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk menjana dan mengembalikan nombor terbesar; Simpan yang lebih kecil di y; Simpan yang lebih besar dalam x; Kedai masing -masing; Jika n boleh dibahagikan dengan y; Tambah x, n kali ke jawapan; Mengurangkan n ke sifar; Mengurangkan n oleh x; Tambah y, x kali ke jawapan; Jika nombor boleh dibentuk; Jika tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void largestNumber ( int n , int X , int Y ) { int maxm = max ( X , Y ) ; Y = X + Y - maxm ; X = maxm ; int Xs = 0 ; int Ys = 0 ; while ( n > 0 ) { if ( n % Y == 0 ) { Xs += n ; n = 0 ; } else { n -= X ; Ys += X ; } } if ( n == 0 ) { while ( Xs -- > 0 ) cout << X ; while ( Ys -- > 0 ) cout << Y ; } else cout << \" - 1\" ; } int main ( ) { int n = 19 , X = 7 , Y = 5 ; largestNumber ( n , X , Y ) ; return 0 ; }"}
{"text": "Flip minimum yang diperlukan untuk menjana substring berterusan 0 € ™ s dan 1 € ™ s | C ++ pelaksanaan pendekatan di atas; Melintasi rentetan input dan simpan kiraan 0; Melintasi rentetan input sekali lagi untuk mencari bilangan minimum flip; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minChanges ( string str , int N ) { int res ; int count0 = 0 , count1 = 0 ; for ( char x : str ) { count0 += ( x == '0' ) ; } res = count0 ; for ( char x : str ) { count0 -= ( x == '0' ) ; count1 += ( x == '1' ) ; res = min ( res , count1 + count0 ) ; } return res ; } int main ( ) { int N = 9 ; string str = \"000101001\" ; cout << minChanges ( str , N ) ; return 0 ; }"}
{"text": "Kejadian yang hilang dari nombor dalam array sedemikian rupa sehingga perbezaan mutlak unsur -unsur bersebelahan adalah minimum | C ++ pelaksanaan nombor yang hilang sedemikian rupa sehingga perbezaan mutlak maksimum antara elemen bersebelahan adalah minimum; Berfungsi untuk mencari nombor yang hilang supaya perbezaan mutlak maksimum adalah minimum; Gelung untuk mencari elemen bersebelahan maksimum dan minimum kepada nombor yang hilang; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingnumber ( int n , int arr [ ] ) { int mn = INT_MAX , mx = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == -1 && arr [ i - 1 ] != -1 ) { mn = min ( mn , arr [ i - 1 ] ) ; mx = max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == -1 && arr [ i + 1 ] != -1 ) { mn = min ( mn , arr [ i + 1 ] ) ; mx = max ( mx , arr [ i + 1 ] ) ; } } long long int res = ( mx + mn ) / 2 ; return res ; } int main ( ) { int n = 5 ; int arr [ 5 ] = { -1 , 10 , -1 , 12 , -1 } ; int ans = 0 ; int res = missingnumber ( n , arr ) ; cout << res ; return 0 ; }"}
{"text": "Memaksimumkan [panjang (x) / 2 ^ (xor (x, y))] dengan memilih substrings x dan y dari rentetan a dan b masing -masing | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari panjang substring biasa terpanjang rentetan x dan y; Lcsuff [i] [j] menyimpan panjang akhiran biasa substrings yang paling lama; Itearate atas rentetan a dan b; Jika baris pertama atau lajur; Jika padanan dijumpai; Jika tidak, jika padanan tidak dijumpai; Akhirnya, kembalikan nilai maksimum yang dihasilkan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int LCSubStr ( char * A , char * B , int m , int n ) { int LCSuff [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( A [ i - 1 ] == B [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = max ( result , LCSuff [ i ] [ j ] ) ; } else LCSuff [ i ] [ j ] = 0 ; } } return result ; } int main ( ) { char A [ ] = \"0110\" ; char B [ ] = \"1101\" ; int M = strlen ( A ) ; int N = strlen ( B ) ; cout << LCSubStr ( A , B , M , N ) ; return 0 ; }"}
{"text": "Kira cara untuk memecah array ke dalam sepasang subset dengan perbezaan antara jumlah mereka sama dengan k | Program C ++ untuk pendekatan di atas; Untuk menyimpan negeri -negeri DP; Fungsi untuk mencari kiraan subset dengan jumlah yang diberikan; Kes asas; Jika subproblem yang telah dikira berlaku; Tetapkan negeri seperti diselesaikan; Hubungan berulang; Berfungsi untuk mengira cara untuk memecah array ke dalam sepasang subset dengan perbezaan k; Simpan jumlah keseluruhan elemen array; Melintasi array; Hitung jumlah elemen array; Simpan jumlah yang diperlukan; Cetak bilangan subset dengan jumlah yang sama dengan S1; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxSum  50 NEW_LINE #define minSum  50 NEW_LINE #define base  50 NEW_LINE int dp [ maxN ] [ maxSum + minSum ] ; bool v [ maxN ] [ maxSum + minSum ] ; int findCnt ( int * arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; } void countSubsets ( int * arr , int K , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int S1 = ( sum + K ) / 2 ; cout << findCnt ( arr , 0 , S1 , n ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int K = 1 ; countSubsets ( arr , K , N ) ; return 0 ; }"}
{"text": "Kebarangkalian bahawa jumlah semua nombor yang diperolehi membuang dadu n kali terletak di antara dua bilangan bulat yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira kebarangkalian bagi jumlah yang diberikan untuk menjadi sama dengan jumlah dalam n lontaran dadu; Kes asas; Kod pemacu; Kirakan kebarangkalian semua jumlah dari A hingga B; Cetak jawapannya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float dp [ 105 ] [ 605 ] ; float find ( int N , int sum ) { if ( dp [ N ] [ sum ] ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; float probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }"}
{"text": "Langkah minimum untuk mengurangkan n hingga 0 dengan operasi yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari nombor minimum ke langkah untuk mengurangkan n hingga 0; Kamus untuk menyimpan jumlah yang dipraktikkan; Kes -kes asas; Semak jika n tidak dalam DP maka hanya panggil fungsi untuk mengurangkan panggilan rekursif; Kembalikan jawapannya; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { map < int , int > dp ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; if ( ( dp . find ( n ) == dp . end ( ) ) ) dp [ n ] = 1 + min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ; return dp [ n ] ; } int main ( ) { int N = 6 ; cout << count ( N ) ; }"}
{"text": "Pengiraan minimum kenaikan saiz K subarrays diperlukan untuk membentuk array yang diberikan | C ++ pelaksanaan untuk mencari bilangan minimum operasi yang diperlukan untuk menukar pelbagai sifar supaya setiap elemen lebih besar daripada array yang diberikan; Berfungsi untuk mencari bilangan minimum operasi yang diperlukan untuk menukar semua pelbagai sifar supaya setiap elemen lebih besar daripada array yang diberikan; Mengisytiharkan pelbagai perbezaan saiz n; Bilangan operasi; Kemas kini pertama nilai D [i] dengan nilai sebelumnya; Indeks saya perlu ditingkatkan; Kita perlu melakukan operasi (b [i] - d [i]) lebih banyak; Meningkatkan julat saya ke i + k dengan keperluan; Semak jika i + k adalah indeks sah; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_minimum_operations ( int n , int b [ ] , int k ) { int d [ n + 1 ] = { 0 } ; int operations = 0 , need ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; } if ( b [ i ] > d [ i ] ) { operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ; d [ i ] += need ; if ( i + k <= n ) { d [ i + k ] -= need ; } } } cout << operations << endl ; } int main ( ) { int n = 5 ; int b [ ] = { 1 , 2 , 3 , 4 , 5 } ; int k = 2 ; find_minimum_operations ( n , b , k ) ; return 0 ; }"}
{"text": "Bilangan cara memotong matriks supaya atleast satu sel diisi dalam setiap bahagian | Pelaksanaan CPP untuk mencari bilangan cara untuk memotong matriks ke dalam bahagian K sehingga setiap bahagian mempunyai atleast satu sel yang dipenuhi; Berfungsi untuk mencari bilangan cara untuk memotong matriks ke bahagian k supaya setiap bahagian mempunyai atleast satu sel yang dipenuhi; Gelung untuk mencari awalan jumlah matriks yang diberikan; dp (r, c, 1) = 1 jika anggapan [r] lain 0; Gelung untuk melangkah ke atas jadual DP matriks yang diberikan; Semak jika boleh dipotong secara mendatar pada R1, sekurang -kurangnya satu epal dalam matriks (r, c) -> r1, c - 1; Semak jika kita boleh memotong secara menegak di C1, sekurang -kurangnya satu epal dalam matriks (r, c) -> r - 1, c1; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int ways ( vector < vector < int > > & arr , int K ) { int R = arr . size ( ) ; int C = arr [ 0 ] . size ( ) ; int preSum [ R ] [ C ] ; for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { preSum [ r ] = arr [ r ] ; if ( r + 1 < R ) preSum [ r ] += preSum [ r + 1 ] ; if ( c + 1 < C ) preSum [ r ] += preSum [ r ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r ] -= preSum [ r + 1 ] ; } } int dp [ K + 1 ] [ R ] [ C ] ; for ( int k = 1 ; k <= K ; k ++ ) { for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k ] [ r ] = ( preSum [ r ] > 0 ) ? 1 : 0 ; } else { dp [ k ] [ r ] = 0 ; for ( int r1 = r + 1 ; r1 < R ; r1 ++ ) { if ( preSum [ r ] - preSum [ r1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] ; } for ( int c1 = c + 1 ; c1 < C ; c1 ++ ) { if ( preSum [ r ] - preSum [ r ] [ c1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] ; } } } } } return dp [ K ] [ 0 ] [ 0 ] ; } int main ( ) { vector < vector < int > > arr = { { 1 , 0 , 0 } , { 1 , 1 , 1 } , { 0 , 0 , 0 } } ; int k = 3 ; cout << ways ( arr , k ) << endl ; return 0 ; }"}
{"text": "Produk semua subset saiz saiz k menggunakan unsur -unsur yang indeksnya membahagikan k sepenuhnya | C ++ pelaksanaan pendekatan di atas; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang; Fungsi iteratif untuk mengira (NCR) % p dan simpan dalam f [n] [r]; Jika j> saya kemudian c (i, j) = 0; Jika IIS sama dengan j maka c (i, j) = 1; Fungsi mengira jawapan akhir; Memulakan ans; x adalah kiraan kejadian arr [i] dalam set yang berbeza sedemikian rupa sehingga indeks arr [i] dalam set tersebut membahagikan k sepenuhnya. ; Mencari kiraan arr [i] dengan meletakkannya di indeks yang membahagikan k sepenuhnya; Oleh teorem Fermat; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int p = 1000000007 ; long long int power ( long long int x , long long int y , long long int p ) { long long int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } void nCr ( long long int n , long long int p , int f [ ] [ 100 ] , int m ) { for ( long long int i = 0 ; i <= n ; i ++ ) { for ( long long int j = 0 ; j <= m ; j ++ ) { if ( j > i ) { f [ i ] [ j ] = 0 ; } else if ( j == 0 j == i ) { f [ i ] [ j ] = 1 ; } else { f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } } } void ProductOfSubsets ( int arr [ ] , int n , int m ) { int f [ n + 1 ] [ 100 ] ; nCr ( n , p - 1 , f , m ) ; sort ( arr , arr + n ) ; long long int ans = 1 ; for ( long long int i = 0 ; i < n ; i ++ ) { long long int x = 0 ; for ( long long int j = 1 ; j <= m ; j ++ ) { if ( m % j == 0 ) { x = ( x + ( f [ n - i - 1 ] [ m - j ] * f [ i ] [ j - 1 ] ) % ( p - 1 ) ) % ( p - 1 ) ; } } ans = ( ( ans * power ( arr [ i ] , x , p ) ) % p ) ; } cout << ans << endl ; } int main ( ) { int arr [ ] = { 4 , 5 , 7 , 9 , 3 } ; int K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ProductOfSubsets ( arr , N , K ) ; return 0 ; }"}
{"text": "Bilangan cara untuk menulis n sebagai jumlah k non | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan cara untuk menulis n sebagai jumlah kaum non - negatif; Inisiasi dp [] [] array; Hanya 1 cara untuk memilih nilai dengan jumlah k; Jumlah permulaan; Mengira cara dari negeri -negeri sebelumnya; Mengemas kini jumlah; Mengembalikan kiraan akhir cara; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } int sum ; for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { sum = 0 ; for ( int k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 ] [ k ] ; } dp [ i ] [ j ] = sum ; } } return dp [ m ] [ n ] ; } int main ( ) { int N = 2 , K = 3 ; cout << countWays ( N , K ) ; return 0 ; }"}
{"text": "Bilangan cara untuk menulis n sebagai jumlah k non | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan cara untuk menulis n sebagai jumlah kaum non - negatif; Inisiasi dp [] [] array; Isi dp [] [] dengan jumlah = m; Melelehkan dp [] [] untuk mengisi array dp [] []; Keadaan untuk lajur pertama; Lain mengisi dp [] [] dengan jumlah sehingga (i, j); Jika sampai ke akhir, maka kembalikan nilai; Mengemas kini pada indeks semasa; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( i == m && j == n ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } } int main ( ) { int N = 2 , K = 3 ; cout << countWays ( N , K ) ; return 0 ; }"}
{"text": "Susunan terpanjang sedemikian rupa sehingga setiap elemen dalam berikutnya dibentuk dengan mengalikan elemen sebelumnya dengan perdana | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk prima pra -pra; Kaedah ayak untuk memeriksa sama ada perdana atau tidak; Gandaan; Pra -simpan semua prima; Berfungsi untuk mencari berikutnya terpanjang; Peta hash; Hubungi fungsi untuk menyimpan prima; Memulakan elemen terakhir dengan 1 kerana yang paling lama mungkin; Melangkah dari belakang dan cari yang paling lama; Dapatkan nombor; Inisialisasi DP [i] sebagai 1 sebagai elemen hanya akan saya dalam berikutnya. ; Melangkah dalam semua prima dan berlipat ganda untuk mendapatkan elemen seterusnya; Elemen seterusnya jika didarabkan dengannya; Jika melebihi elemen terakhir maka pecah; Jika nombor ada dalam array; Dapatkan unsur maksimum yang paling maksimum; Hash elemen; Cari yang paling lama; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int MAX , vector < int > & primes ) { bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( long long p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( long long i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( long long i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) primes . push_back ( i ) ; } } int findLongest ( int A [ ] , int n ) { unordered_map < int , int > mpp ; vector < int > primes ; SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; int dp [ n ] ; memset ( dp , 0 , sizeof dp ) ; dp [ n - 1 ] = 1 ; mpp [ A [ n - 1 ] ] = n - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int num = A [ i ] ; dp [ i ] = 1 ; int maxi = 0 ; for ( auto it : primes ) { int xx = num * it ; if ( xx > A [ n - 1 ] ) break ; else if ( mpp [ xx ] != 0 ) { dp [ i ] = max ( dp [ i ] , 1 + dp [ mpp [ xx ] ] ) ; } } mpp [ A [ i ] ] = i ; } int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , dp [ i ] ) ; } return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 5 , 6 , 12 , 35 , 60 , 385 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findLongest ( a , n ) ; }"}
{"text": "Bilangan rentetan binari panjang n dengan k bit set bersebelahan | Program C ++ untuk mencari bilangan rentetan bit panjang n dengan b bit set bersebelahan; Berfungsi untuk mencari bilangan rentetan bit panjang n dengan k bit set bersebelahan; Kes asas apabila kita membentuk rentetan panjang n; jika f (bit string) = k, hitung cara ini; Semak sama ada bit terakhir ditetapkan, jika ditetapkan maka hubungi indeks seterusnya dengan menambah kiraan bit bersebelahan lain, hubungi indeks seterusnya dengan nilai yang sama dari kiraan bit bersebelahan dan sama ada tetapkan bit pada indeks semasa atau biarkan ia tetap tidak tersembunyi; Tetapkan bit pada CurrentIndex; tidak jelas sedikit pada currentIndex; Kod pemacu; Jumlah cara = (cara dengan meletakkan bit 1 st 1 + cara dengan meletakkan bit 1 sebagai 0)", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int waysToKAdjacentSetBits ( int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) { if ( currentIndex == n ) { if ( adjacentSetBits == k ) return 1 ; return 0 ; } int noOfWays = 0 ; if ( lastBit == 1 ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( ! lastBit ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } return noOfWays ; } int main ( ) { int n = 5 , k = 2 ; int totalWays = waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ; cout << \" Number ▁ of ▁ ways ▁ = ▁ \" << totalWays << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Jumlah produk semua gabungan diambil (1 hingga n) pada satu masa | Program CPP untuk mencari jumlah semua kombinasi Takne (1 hingga N) pada satu masa menggunakan pengaturcaraan dinamik; Cari array Jumlah Postfix; Ubah suai array supaya kita tidak perlu mengira produk yang diperoleh sebelum ini; Mencari jumlah semua gabungan yang diambil 1 hingga n pada satu masa; Jumlah yang diambil 1 pada masa hanya jumlah 1 - n; untuk jumlah produk untuk semua kombinasi; mencari array postfix; Jumlah produk yang diambil i + 1 pada satu masa; Ubah suai array untuk masalah bertindih; Kod pemandu; menyimpan nombor dari 1 hingga n; Memanggil AllCombination", "code": "#include <iostream> NEW_LINE using namespace std ; void postfix ( int a [ ] , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) a [ i - 1 ] = a [ i - 1 ] + a [ i ] ; } void modify ( int a [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) a [ i - 1 ] = i * a [ i ] ; } void allCombination ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i ; cout << \" f ( 1 ) ▁ - - > ▁ \" << sum << \" STRNEWLINE \" ; for ( int i = 1 ; i < n ; i ++ ) { postfix ( a , n - i + 1 ) ; sum = 0 ; for ( int j = 1 ; j <= n - i ; j ++ ) { sum += ( j * a [ j ] ) ; } cout << \" f ( \" << i + 1 << \" ) ▁ - - > ▁ \" << sum << \" STRNEWLINE \" ; modify ( a , n ) ; } } int main ( ) { int n = 5 ; int * a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = i + 1 ; allCombination ( a , n ) ; return 0 ; }"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Program C ++ untuk mencari tangga N - menggunakan saiz langkah 1 atau 2 atau 3 .; Mengembalikan kiraan cara untuk mencapai tangga N - menggunakan 1 atau 2 atau 3 langkah. ; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; class GFG { public : int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; } } ; int main ( ) { GFG g ; int n = 4 ; cout << g . findStep ( n ) ; return 0 ; }"}
{"text": "Masalah Partition | DP | Program C ++ rekursif untuk masalah partition; Fungsi utiliti yang kembali benar jika terdapat subset arr [] dengan matahari sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah elemen dalam array; Jika jumlahnya ganjil, tidak ada dua subset dengan jumlah yang sama; Cari jika terdapat subset dengan jumlah yang sama dengan separuh daripada jumlah keseluruhan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSubsetSum ( int arr [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ; return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; } bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; return isSubsetSum ( arr , n , sum / 2 ) ; } int main ( ) { int arr [ ] = { 3 , 1 , 5 , 9 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << \" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ \" \" of ▁ equal ▁ sum \" ; else cout << \" Can ▁ not ▁ be ▁ divided ▁ into ▁ two ▁ subsets \" \" ▁ of ▁ equal ▁ sum \" ; return 0 ; }"}
{"text": "Masalah Partition | DP | Program C ++ berasaskan pengaturcaraan yang dinamik untuk masalah partition; Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah semua elemen; Memulakan array bahagian sebagai 0; Isi jadual partition dengan cara bawah; Unsur yang akan dimasukkan dalam jumlah tidak boleh lebih besar daripada jumlahnya; j -) {semak jika jumlah - arr [i] boleh dibentuk dari subset menggunakan unsur -unsur sebelum indeks i; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; if ( part [ j - arr [ i ] ] == 1 j == arr [ i ] ) part [ j ] = 1 ; } } return part [ sum / 2 ] ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << \" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ \" \" sum \" ; else cout << \" Can ▁ not ▁ be ▁ divided ▁ into \" << \" ▁ two ▁ subsets ▁ of ▁ equal ▁ sum \" ; return 0 ; }"}
{"text": "Koefisien binomial | DP | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari pekali binomial; Mendapatkan penyongsangan modular untuk semua nombor dari 2 hingga R berkenaan dengan M di sini M = 1000000007; untuk 1 / (r!) Bahagian; untuk (n) * (n - 1) * (n - 2) * ... * (n - r + 1) bahagian; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long long int m = 1000000007 ; long long int inv [ r + 1 ] = { 0 } ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ m % i ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; } int main ( ) { int n = 5 , r = 2 ; cout << \" Value ▁ of ▁ C ( \" << n << \" , ▁ \" << r << \" ) ▁ is ▁ \" << binomialCoeff ( n , r ) << endl ; return 0 ; }"}
{"text": "Semak sama ada mungkin untuk mencapai (x, y) dari (1, 1) dengan langkah -langkah yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari GCD dua nombor; Kes asas; Berulang; Berfungsi untuk mencetak jawapan; GCD X dan Y; Jika GCD adalah kuasa 2; Kod pemacu; Diberikan x dan y; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a % b == 0 ) return b ; return gcd ( b , a % b ) ; } void printAnswer ( int x , int y ) { int val = gcd ( x , y ) ; if ( ( val & ( val - 1 ) ) == 0 ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int x = 4 ; int y = 7 ; printAnswer ( x , y ) ; return 0 ; }"}
{"text": "Cari elemen dalam matriks yang dihasilkan oleh peraturan yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan elemen dalam lajur RTH dan lajur CTH dari matriks yang diperlukan; Keadaan untuk separuh bawah matriks; Keadaan jika elemen berada di baris pertama; Memulakan elemen AP dalam baris R; Perbezaan umum AP dalam baris r; Kedudukan elemen untuk mencari di AP dalam baris r; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * pow ( 2 , r - 2 ) ; int d = pow ( 2 , r - 1 ) ; c = c - r ; int element = a + d * c ; return element ; } int main ( ) { int N = 4 , R = 3 , C = 4 ; cout << getElement ( N , R , C ) ; return 0 ; }"}
{"text": "Cari nombor terkecil yang dibentuk dengan memasukkan digit yang diberikan | C ++ pelaksanaan pendekatan di atas; Fungsi untuk memasukkan x dalam n dan mengembalikan rentetan nilai minimum; Pembolehubah untuk menyimpan panjang rentetan n; Pembolehubah untuk menunjukkan kedudukan di mana x mesti ditambah; Jika rentetan yang diberikan n mewakili nilai negatif; X mesti diletakkan pada indeks terakhir di mana lebih besar daripada n [i]; Untuk nombor positif, x mesti diletakkan pada indeks terakhir di mana ia lebih kecil daripada n [i]; Masukkan x pada kedudukan itu; Kembalikan rentetan; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string MinValue ( string N , int X ) { int len = N . size ( ) ; int position = len + 1 ; if ( N [ 0 ] == ' - ' ) { for ( int i = len - 1 ; i >= 1 ; i -- ) { if ( ( N [ i ] - '0' ) < X ) { position = i ; } } } else { for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( ( N [ i ] - '0' ) > X ) { position = i ; } } } N . insert ( N . begin ( ) + position , X + '0' ) ; return N ; } int main ( ) { string N = \"89\" ; int X = 1 ; cout << MinValue ( N , X ) << \" STRNEWLINE \" ; }"}
{"text": "Semak jika perwakilan perpuluhan rentetan binari yang diberikan dapat dibahagikan dengan k atau tidak | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa nombor binari yang boleh dibahagikan oleh k; Array Poweroftwo akan menyimpan pow (2, i) % k; Memulakan elemen pertama dalam array; Menyimpan setiap nilai pow (2, i) % k dalam array; Untuk menyimpan baki; Melangkah sehingga n; Jika bit semasa ialah 1; Mengemas kini REM; Jika benar -benar boleh dibahagikan; Jika tidak sepenuhnya dibahagi; Kod pemacu; Diberikan input; panjang rentetan s; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string divisibleByk ( string s , int n , int k ) { int poweroftwo [ n ] ; poweroftwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) { poweroftwo [ i ] = ( poweroftwo [ i - 1 ] * ( 2 % k ) ) % k ; } int rem = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ n - i - 1 ] == '1' ) { rem += ( poweroftwo [ i ] ) ; rem %= k ; } } if ( rem == 0 ) { return \" Yes \" ; } else return \" No \" ; } int main ( ) { string s = \"1010001\" ; int k = 9 ; int n = s . length ( ) ; cout << divisibleByk ( s , n , k ) ; return 0 ; }"}
{"text": "Pecahkan rentetan binari supaya kiraan 0 s dan 1 s dalam substring kiri dan kanan adalah maksimum | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari jumlah maksimum kiraan 0 s di substring kiri dan kiraan 1 s dalam substring kanan dengan memisahkan rentetan; Kedai mengira 1 s dalam rentetan binari; Melintasi rentetan binari; Jika watak semasa adalah '1'; Kemas kini cntone; Kedai kiraan 0 s; Kedai kiraan 1 s; Kedai maksimum jumlah kiraan 0 s dan 1 s dengan memisahkan rentetan; Melintasi rentetan binari; Jika watak semasa adalah '0'; Mengemas kini sifar; Jika watak semasa adalah '1'; Mengemas kini satu; Kemas kini res; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumbySplittingstring ( string str , int N ) { int cntOne = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '1' ) { cntOne ++ ; } } int zero = 0 ; int one = 0 ; int res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( str [ i ] == '0' ) { zero ++ ; } else { one ++ ; } res = max ( res , zero + cntOne - one ) ; } return res ; } int main ( ) { string str = \"00111\" ; int N = str . length ( ) ; cout << maxSumbySplittingstring ( str , N ) ; return 0 ; }"}
{"text": "Mengira penyingkiran pasangan yang diperlukan untuk kosongkan semua berikutnya Parenthesis Balanced | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari kiraan maksimum pasangan yang diperlukan untuk dikeluarkan supaya rentetan seterusnya tidak mengandungi sebarang kurungan yang sah; Kedai kiraan pasangan kurungan seimbang; Kedai -kedai mengira kurungan seimbang; Kedai mengira kurungan seimbang kecil; Kedai kiraan kurungan seimbang persegi; Melangkah ke atas aksara rentetan; Mengemas kini cntcurly; Kemas kini CNTSML; Kemas kini CNTSQR; Mengemas kini cntcurly; Kemas kini CNTPairs; Kemas kini CNTSML; Kemas kini CNTPairs; Kemas kini CNTSML; Kemas kini CNTPairs; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; void cntBalancedParenthesis ( string s , int N ) { int cntPairs = 0 ; int cntCurly = 0 ; int cntSml = 0 ; int cntSqr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' { ' ) { cntCurly ++ ; } else if ( s [ i ] == ' ( ' ) { cntSml ++ ; } else if ( s [ i ] == ' [ ' ) { cntSqr ++ ; } else if ( s [ i ] == ' } ' && cntCurly > 0 ) { cntCurly -- ; cntPairs ++ ; } else if ( s [ i ] == ' ) ' && cntSml > 0 ) { cntSml -- ; cntPairs ++ ; } else if ( s [ i ] == ' ] ' && cntSqr > 0 ) { cntSqr -- ; cntPairs ++ ; } } cout << cntPairs ; } int main ( ) { string s = \" { ( } ) \" ; int N = s . length ( ) ; cntBalancedParenthesis ( s , N ) ; return 0 ; }"}
{"text": "Count of Strings yang tidak mengandungi persimpangan arka | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada terdapat persimpangan arka atau tidak; Melintasi rentetan s; Masukkan semua elemen dalam timbunan satu demi satu; Ekstrak elemen teratas; Pop keluar elemen teratas; Semak sama ada elemen atas adalah sama dengan elemen yang muncul; Jika tidak; Sekiranya timbunan kosong; Fungsi untuk memeriksa sama ada terdapat persimpangan arka atau tidak untuk pelbagai rentetan yang diberikan; Kedai kiraan rentetan tidak mempunyai persimpangan arka; Berulang melalui array; Panjang setiap rentetan; Panggilan fungsi; Cetak kiraan yang dikehendaki; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int arcIntersection ( string S , int len ) { stack < char > stk ; for ( int i = 0 ; i < len ; i ++ ) { stk . push ( S [ i ] ) ; if ( stk . size ( ) >= 2 ) { char temp = stk . top ( ) ; stk . pop ( ) ; if ( stk . top ( ) == temp ) { stk . pop ( ) ; } else { stk . push ( temp ) ; } } } if ( stk . empty ( ) ) return 1 ; return 0 ; } void countString ( string arr [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int len = arr [ i ] . length ( ) ; count += arcIntersection ( arr [ i ] , len ) ; } cout << count << endl ; } int main ( ) { string arr [ ] = { \"0101\" , \"0011\" , \"0110\" } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countString ( arr , N ) ; return 0 ; }"}
{"text": "Semak jika perwakilan perpuluhan rentetan binari boleh dibahagikan dengan 9 atau tidak | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk menukar rentetan binari ke dalam perwakilan oktal; Kedai perwakilan binari nilai perpuluhan [0 - 7]; Menyimpan nilai perpuluhan rentetan binari [0 - 7]; Kedai panjang s; Kemas kini s; Kemas kini s; Kemas kini n; Kedai perwakilan oktal rentetan binari; Melintasi rentetan binari; Kedai 3 aksara berturut -turut rentetan binari; Tambah perwakilan oktal temp; Fungsi untuk memeriksa sama ada rentetan binari boleh dibahagikan dengan 9 atau tidak; Kedai perwakilan oktal S; Kedai jumlah unsur yang hadir pada kedudukan ganjil OCT; Kedai jumlah unsur yang hadir pada kedudukan ganjil OCT; Kedai panjang OCT; Melintasi rentetan OCT; Mengemas kini oddsum; Melintasi rentetan OCT; Kemas kini Evensum; Kedai perwakilan cotal 9; Jika nilai mutlak (oddsum - evensum) boleh dibahagikan dengan Okt_9; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string ConvertequivalentBase8 ( string S ) { map < string , char > mp ; mp [ \"000\" ] = '0' ; mp [ \"001\" ] = '1' ; mp [ \"010\" ] = '2' ; mp [ \"011\" ] = '3' ; mp [ \"100\" ] = '4' ; mp [ \"101\" ] = '5' ; mp [ \"110\" ] = '6' ; mp [ \"111\" ] = '7' ; int N = S . length ( ) ; if ( N % 3 == 2 ) { S = \"0\" + S ; } else if ( N % 3 == 1 ) { S = \"00\" + S ; } N = S . length ( ) ; string oct ; for ( int i = 0 ; i < N ; i += 3 ) { string temp = S . substr ( i , 3 ) ; oct . push_back ( mp [ temp ] ) ; } return oct ; } string binString_div_9 ( string S , int N ) { string oct ; oct = ConvertequivalentBase8 ( S ) ; int oddSum = 0 ; int evenSum = 0 ; int M = oct . length ( ) ; for ( int i = 0 ; i < M ; i += 2 ) { oddSum += int ( oct [ i ] - '0' ) ; } for ( int i = 1 ; i < M ; i += 2 ) { evenSum += int ( oct [ i ] - '0' ) ; } int Oct_9 = 11 ; if ( abs ( oddSum - evenSum ) % Oct_9 == 0 ) { return \" Yes \" ; } return \" No \" ; } int main ( ) { string S = \"1010001\" ; int N = S . length ( ) ; cout << binString_div_9 ( S , N ) ; }"}
{"text": "Kos minimum untuk mengeluarkan ruang antara aksara rentetan dengan menyusun semula aksara | Program C ++ untuk mengumpulkan watak -watak rentetan dalam kos minimum; Fungsi untuk mengira kos minimum; Menyimpan kos minimum; Menyimpan kiraan watak yang dijumpai; Menyimpan kiraan ruang kosong yang dijumpai; Menyimpan kiraan jumlah aksara; Jika kiraan aksara sama dengan 1; Melangkah ke atas rentetan; Pertimbangkan watak sebelumnya bersama -sama dengan watak semasa; Sekiranya tidak bersama sudah; Tambah kos untuk mengumpulkannya bersama -sama; Meningkatkan kiraan watak yang dijumpai; Jika tidak; Meningkatkan kiraan ruang yang dijumpai; Mengembalikan jumlah kos yang diperoleh; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_cost ( string S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; for ( char c : S ) if ( c == ' ▁ ' ) count ++ ; int n = S . size ( ) - count ; if ( n == 1 ) return cost ; for ( char in : S ) { if ( in != ' ▁ ' ) { if ( B != 0 ) { cost += min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; } int main ( ) { string S = \" ▁ @ TABSYMBOL $ \" ; cout << min_cost ( S ) ; return 0 ; }"}
{"text": "Kurangkan kos untuk menggantikan semua vokal rentetan yang diberikan oleh vokal tunggal | Program C ++ untuk pendekatan di atas; Fungsi yang kembali benar jika watak yang diberikan adalah vokal; Berfungsi untuk mengembalikan kos minimum untuk menukar semua vokal rentetan kepada satu; Kedai mengira vokal masing -masing; Melangkah melalui rentetan; Jika vokal ditemui; Kirakan kos; Mengembalikan kos minimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) return true ; else return false ; } int minCost ( string S ) { int cA = 0 ; int cE = 0 ; int cI = 0 ; int cO = 0 ; int cU = 0 ; for ( int i = 0 ; i < S . size ( ) ; i ++ ) { if ( isVowel ( S [ i ] ) ) { cA += abs ( S [ i ] - ' a ' ) ; cE += abs ( S [ i ] - ' e ' ) ; cI += abs ( S [ i ] - ' i ' ) ; cO += abs ( S [ i ] - ' o ' ) ; cU += abs ( S [ i ] - ' u ' ) ; } } return min ( min ( min ( min ( cA , cE ) , cI ) , cO ) , cU ) ; } int main ( ) { string S = \" geeksforgeeks \" ; cout << minCost ( S ) << endl ; return 0 ; }"}
{"text": "Menjana rentetan yang semua k | Program C ++ untuk menghasilkan rentetan yang substrings panjang k concatenates untuk membentuk rentetan yang diberikan; Berfungsi untuk mengembalikan rentetan yang diperlukan; Melepasi rentetan yang diberikan; Tambah watak pertama setiap substring panjang k; Pertimbangkan semua watak dari substring terakhir; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void decode_String ( string str , int K ) { string ans = \" \" ; for ( int i = 0 ; i < str . size ( ) ; i += K ) ans += str [ i ] ; for ( int i = str . size ( ) - ( K - 1 ) ; i < str . size ( ) ; i ++ ) ans += str [ i ] ; cout << ans << endl ; } int main ( ) { int K = 3 ; string str = \" abcbcscsesesesd \" ; decode_String ( str , K ) ; }"}
{"text": "Lexicographically terkecil k | Program C ++ untuk mencari substring panjang K - panjang terkecil yang mengandungi bilangan vokal maksimum; Fungsi yang mencetak substring panjang K - panjang terkecil yang mengandungi bilangan vokal maksimum; Simpan panjang rentetan; Memulakan array jumlah awalan; Gelung melalui rentetan untuk membuat array Sum Prefix; Simpan 1 pada indeks jika ia adalah vokal; Jika tidak, simpan 0; Proses array awalan; Memulakan pembolehubah untuk menyimpan kiraan maksimum vokal; Memulakan pembolehubah untuk menyimpan substring dengan kiraan maksimum vokal; Gelung melalui array awalan; Simpan kiraan vokal semasa; Kemas kini hasil jika kiraan semasa lebih besar daripada kiraan maksimum; Kemas kini substring terkecil secara lexicographically jika kiraan semasa adalah sama dengan kiraan maksimum; Mengembalikan hasilnya; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string maxVowelSubString ( string str , int K ) { int N = str . length ( ) ; int pref [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) pref [ i ] = 1 ; else pref [ i ] = 0 ; if ( i ) pref [ i ] += pref [ i - 1 ] ; } int maxCount = pref [ K - 1 ] ; string res = str . substr ( 0 , K ) ; for ( int i = K ; i < N ; i ++ ) { int currCount = pref [ i ] - pref [ i - K ] ; if ( currCount > maxCount ) { maxCount = currCount ; res = str . substr ( i - K + 1 , K ) ; } else if ( currCount == maxCount ) { string temp = str . substr ( i - K + 1 , K ) ; if ( temp < res ) res = temp ; } } return res ; } int main ( ) { string str = \" ceebbaceeffo \" ; int K = 3 ; cout << maxVowelSubString ( str , K ) ; return 0 ; }"}
{"text": "Decode rentetan yang dikodkan dengan algoritma yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk menyahkod dan mencetak rentetan asal; Untuk menyimpan rentetan yang dikodkan; Mendapatkan elemen pertengahan; Menyimpan elemen pertama rentetan pada kedudukan median; Jika panjangnya, kemudian simpan elemen kedua juga; K mewakili bilangan aksara yang telah disimpan dalam C []; Jika panjang rentetan ganjil; Jika ia juga; Cetak rentetan decoded; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void decodeStr ( string str , int len ) { char c [ len ] = \" \" ; int med , pos = 1 , k ; if ( len % 2 == 1 ) med = len / 2 ; else med = len / 2 - 1 ; c [ med ] = str [ 0 ] ; if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ; if ( len & 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ; if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ; else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; } for ( int i = 0 ; i < len ; i ++ ) cout << c [ i ] ; } int main ( ) { string str = \" ofrsgkeeeekgs \" ; int len = str . length ( ) ; decodeStr ( str , len ) ; return 0 ; }"}
{"text": "Mengira watak -watak yang berbeza dalam substring dengan julat yang diberikan untuk pertanyaan q | Program C ++ untuk pendekatan naif; kaunter untuk mengira char yang berbeza; Array frekuensi memulakan untuk mengira aksara sebagai muncul dalam substring s [l: r]; Melangkah ke atas [L] ke S [r]; Meningkatkan kiraan S [i] watak dalam pelbagai frekuensi; jika kekerapan mana -mana watak adalah> 0 maka kenaikan kaunter; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCount ( string s , int L , int R ) { int distinct = 0 ; int frequency [ 26 ] = { } ; for ( int i = L ; i <= R ; i ++ ) { frequency [ s [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] > 0 ) distinct ++ ; } cout << distinct << endl ; } int main ( ) { string s = \" geeksforgeeksisacomputerscienceportal \" ; int queries = 3 ; int Q [ queries ] [ 2 ] = { { 0 , 10 } , { 15 , 18 } , { 12 , 20 } } ; for ( int i = 0 ; i < queries ; i ++ ) findCount ( s , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; return 0 ; }"}
{"text": "String yang diperoleh dengan membalikkan dan melengkapkan rentetan binari K kali | Program C ++ untuk melaksanakan operasi K pada rentetan dan cari rentetan yang diubah suai; Berfungsi untuk melaksanakan operasi k pada rentetan dan mencari rentetan yang diubah suai; Bilangan operasi terbalik; Bilangan operasi pelengkap; Jika rev adalah pariti ganjil; Jika pelengkap adalah pariti ganjil; Melengkapi setiap kedudukan; Kembalikan rentetan yang diubah suai; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string ReverseComplement ( string s , int n , int k ) { int rev = ( k + 1 ) / 2 ; int complement = k - rev ; if ( rev % 2 ) reverse ( s . begin ( ) , s . end ( ) ) ; if ( complement % 2 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) s [ i ] = '1' ; else s [ i ] = '0' ; } } return s ; } int main ( ) { string str = \"10011\" ; int k = 5 ; int n = str . size ( ) ; cout << ReverseComplement ( str , n , k ) ; return 0 ; }"}
{"text": "Semak jika ada permutasi rentetan adalah rentetan kim yang berulang kali | C ++ pelaksanaan untuk memastikan bahawa permutasi rentetan yang diberikan adalah rentetan kim yang berulang kali; Fungsi untuk memeriksa bahawa permutasi rentetan yang diberikan adalah rentetan mengulangi kali; Jika panjang rentetan tidak dapat dibahagikan dengan k; Pelbagai kekerapan; Pada mulanya kekerapan setiap watak ialah 0; Pengkomputeran kekerapan setiap aksara dalam rentetan; Gelung untuk memeriksa kekerapan setiap watak rentetan itu boleh dibahagikan dengan k; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool repeatingString ( string s , int n , int k ) { if ( n % k != 0 ) { return false ; } int frequency [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] ] ++ ; } int repeat = n / k ; for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; } int main ( ) { string s = \" abcdcba \" ; int n = s . size ( ) ; int k = 3 ; if ( repeatingString ( s , n , k ) ) { cout << \" Yes \" << endl ; } else { cout << \" No \" << endl ; } return 0 ; }"}
{"text": "Cari dua digit terakhir yang hilang dari nombor telefon yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari dua digit terakhir nombor dan mencetak nombor lengkap; Jumlah lapan digit nombor pertama; jika jumlah <10, maka dua digit adalah '0' dan nilai jumlah; Jika jumlah> 10, maka dua digit adalah nilai jumlah; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; void findPhoneNumber ( int n ) { int temp = n ; int sum ; while ( temp != 0 ) { sum += temp % 10 ; temp = temp / 10 ; } if ( sum < 10 ) cout << n << \"0\" << sum ; else cout << n << sum ; } int main ( ) { long int n = 98765432 ; findPhoneNumber ( n ) ; return 0 ; }"}
{"text": "Bilangan cara untuk memecah nombor binari supaya setiap bahagian boleh dibahagikan dengan 2 | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan yang diperlukan; Jika pemisahan tidak mungkin; Untuk menyimpan kiraan sifar; Mengira bilangan sifar; Kembalikan jawapan terakhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxM  64 NEW_LINE int cntSplits ( string s ) { if ( s [ s . size ( ) - 1 ] == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) c_zero += ( s [ i ] == '0' ) ; return ( int ) pow ( 2 , c_zero - 1 ) ; } int main ( ) { string s = \"10010\" ; cout << cntSplits ( s ) ; return 0 ; }"}
{"text": "Kira bilangan substrings rentetan yang terdiri daripada aksara yang sama | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan bilangan substrings aksara yang sama; Saiz rentetan; Memulakan kiraan kepada 1; Memulakan kiri ke 0 dan kanan ke 1 untuk melintasi rentetan; Memeriksa jika aksara berturut -turut adalah sama dan kenaikan kiraan; Apabila kita menghadapi watak yang berbeza; Meningkatkan hasilnya; Untuk mengulangi keseluruhan proses set kiri sama dan mengira pembolehubah kepada 1; Simpan nilai akhir hasil; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( string s ) { if ( s . empty ( ) ) return 0 ; int n = s . size ( ) ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) { count ++ ; } else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; cout << result << endl ; } int main ( ) { string s = \" bbbcbb \" ; findNumbers ( s ) ; }"}
{"text": "Program untuk menduplikasi vokal dalam rentetan | Program C ++ untuk mencetak rentetan dengan vokal pendua; Berfungsi untuk memeriksa vokal; Berfungsi untuk mendapatkan rentetan yang dihasilkan dengan vokal yang diduplikasi; Satu lagi rentetan untuk menyimpan rentetan yang dihasilkan; Gelung untuk memeriksa setiap watak; Kod pemacu; Cetak rentetan asal; Cetak tali yang dihasilkan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { ch = toupper ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; } string duplicateVowels ( string str ) { int t = str . length ( ) ; string res = \" \" ; for ( int i = 0 ; i < t ; i ++ ) { if ( isVowel ( str [ i ] ) ) { res += str [ i ] ; } res += str [ i ] ; } return res ; } int main ( ) { string str = \" helloworld \" ; cout << \" Original ▁ String : ▁ \" << str << endl ; string res = duplicateVowels ( str ) ; cout << \" String ▁ with ▁ Vowels ▁ duplicated : ▁ \" << res << endl ; }"}
{"text": "Tukar rentetan ke integer menggunakan rekursi | C ++ pelaksanaan pendekatan; Fungsi rekursif untuk menukar rentetan ke integer; Jika nombor yang diwakili sebagai rentetan hanya mengandungi satu digit, maka mengembalikan nilainya; Panggilan rekursif untuk sub -rentetan bermula pada watak kedua; Digit pertama nombor; Digit pertama didarab dengan kuasa yang sesuai 10 dan kemudian tambah hasil rekursif sebagai contoh, xy = ((x * 10) + y); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int stringToInt ( string str ) { if ( str . length ( ) == 1 ) return ( str [ 0 ] - '0' ) ; double y = stringToInt ( str . substr ( 1 ) ) ; double x = str [ 0 ] - '0' ; x = x * pow ( 10 , str . length ( ) - 1 ) + y ; return int ( x ) ; } int main ( ) { string str = \"1235\" ; cout << ( stringToInt ( str ) ) << endl ; }"}
{"text": "Susunan terpanjang dengan sekurang -kurangnya satu watak yang terdapat dalam setiap rentetan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan panjang sub -urutan terpanjang dengan sekurang -kurangnya satu watak biasa dalam setiap rentetan; Kira [0] akan menyimpan bilangan rentetan yang mengandungi 'A', kiraan [1] akan menyimpan bilangan rentetan yang mengandungi 'B' dan sebagainya. . ; Untuk setiap rentetan; Arus hash untuk menetapkan watak mana yang ada dalam rentetan semasa; Jika watak semasa muncul dalam rentetan maka kemas kini kiraannya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE int largestSubSeq ( string arr [ ] , int n ) { int count [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { string str = arr [ i ] ; bool hash [ MAX ] = { 0 } ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str [ j ] - ' a ' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } return * ( max_element ( count , count + MAX ) ) ; } int main ( ) { string arr [ ] = { \" ab \" , \" bc \" , \" de \" } ; int n = sizeof ( arr ) / sizeof ( string ) ; cout << largestSubSeq ( arr , n ) ; return 0 ; }"}
{"text": "Menjana nombor dengan operasi yang diberikan dan periksa sama ada Palindrome | Pelaksanaan CPP pendekatan; Fungsi yang kembali benar jika STR adalah palindrome; Fungsi yang mengembalikan benar jika rentetan yang dihasilkan adalah palindrome; sub mengandungi n sebagai rentetan; Kirakan jumlah digit; Ulangi substring sehingga panjang rentetan yang dihasilkan <jumlah; Jika panjang rentetan yang dihasilkan melebihi jumlah maka ambil substring dari 0 hingga jumlah - 1; Jika rentetan yang dihasilkan adalah palindrome; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len / 2 ; i ++ ) { if ( str [ i ] != str [ len - 1 - i ] ) return false ; } return true ; } bool createStringAndCheckPalindrome ( int N ) { ostringstream out ; out << N ; string result = out . str ( ) ; string sub = \" \" + result , res_str = \" \" ; int sum = 0 ; while ( N > 0 ) { int digit = N % 10 ; sum += digit ; N = N / 10 ; } while ( res_str . length ( ) < sum ) res_str += sub ; if ( res_str . length ( ) > sum ) res_str = res_str . substr ( 0 , sum ) ; if ( isPalindrome ( res_str ) ) return true ; return false ; } int main ( ) { int N = 10101 ; if ( createStringAndCheckPalindrome ( N ) ) cout << ( \" Yes \" ) ; else cout << ( \" No \" ) ; }"}
{"text": "Kurangkan panjang rentetan dengan mengeluarkan kejadian hanya satu aksara | Program C ++ untuk meminimumkan panjang rentetan dengan mengeluarkan kejadian hanya satu aksara; Berfungsi untuk mencari panjang minimum; Hitung kekerapan setiap abjad; Cari huruf dengan kekerapan maksimum; Tolak kekerapan aksara dari panjang rentetan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumLength ( string s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) arr [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; } int main ( ) { string str = \" afddewqd \" ; cout << minimumLength ( str ) ; return 0 ; }"}
{"text": "Keluarkan semua aksara selain Alphabets dari String | Program CPP untuk menghapuskan semua watak yang lain kemudian Alphabets; berfungsi untuk mengeluarkan aksara dan mencetak rentetan baru; Mencari watak yang nilai ASCII jatuh di bawah julat ini; memadamkan fungsi untuk memadamkan watak; kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeSpecialCharacter ( string s ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] < ' A ' s [ i ] > ' Z ' && s [ i ] < ' a ' s [ i ] > ' z ' ) { s . erase ( i , 1 ) ; i -- ; } } cout << s ; } int main ( ) { string s = \" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? \" ; removeSpecialCharacter ( s ) ; return 0 ; }"}
{"text": "Keluarkan semua aksara selain Alphabets dari String | Program CPP untuk menghapuskan semua watak yang lain kemudian Alphabets; berfungsi untuk mengeluarkan aksara dan mencetak rentetan baru; Menyimpan hanya aksara yang sah; kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeSpecialCharacter ( string s ) { int j = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } cout << s . substr ( 0 , j ) ; } int main ( ) { string s = \" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? \" ; removeSpecialCharacter ( s ) ; return 0 ; }"}
{"text": "Cari watak berulang yang hadir terlebih dahulu dalam rentetan | Program C ++ untuk mencari watak pertama yang diulang; Ini adalah kaedah O (n ^ 2); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; int findRepeatFirstN2 ( char * s ) { int p = -1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; } int main ( ) { char str [ ] = \" geeksforgeeks \" ; int pos = findRepeatFirstN2 ( str ) ; if ( pos == -1 ) cout << \" Not ▁ found \" ; else cout << str [ pos ] ; return 0 ; }"}
{"text": "Cetak watak dan frekuensi mereka mengikut urutan kejadian | C ++ pelaksanaan untuk mencetak aksara dan frekuensi mengikut kejadiannya; Simpan semua watak dan frekuensi mereka dalam kamus; Cetak watak dan frekuensi mereka dalam susunan yang sama penampilan mereka; Cetak hanya jika watak ini tidak dicetak sebelum ini; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void prCharWithFreq ( string s ) { unordered_map < char , int > d ; for ( char i : s ) { d [ i ] ++ ; } for ( char i : s ) { if ( d [ i ] != 0 ) { cout << i << d [ i ] << \" ▁ \" ; d [ i ] = 0 ; } } } int main ( ) { string s = \" geeksforgeeks \" ; prCharWithFreq ( s ) ; }"}
{"text": "Kira bilangan rentetan (diperbuat daripada r, g dan b) menggunakan kombinasi yang diberikan | Program C ++ untuk mengira bilangan rentetan yang mungkin dengan aksara N. ; Berfungsi untuk mengira bilangan rentetan; Menyimpan faktorial nombor sehingga n untuk pengiraan selanjutnya; Cari nilai yang akan ditambah; Buat semua kemungkinan kombinasi R, B dan G untuk nilai yang tinggal; Kirakan permutasi setiap gabungan satu demi satu dan tambahkannya. ; Kembali Jumlah No. rentetan / permutasi; Kod pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int possibleStrings ( int n , int r , int b , int g ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; } int main ( ) { int n = 4 , r = 2 ; int b = 0 , g = 1 ; cout << possibleStrings ( n , r , b , g ) ; return 0 ; }"}
{"text": "Keluarkan bilangan minimum aksara supaya dua rentetan menjadi anagram | Program C ++ untuk mencari bilangan minimum aksara yang akan dikeluarkan untuk membuat dua rentetan anagram. ; fungsi untuk mengira bilangan minimum aksara yang akan dikeluarkan untuk membuat dua rentetan anagram; Buat array hash untuk kedua -dua rentetan dan hitung kekerapan setiap aksara; Mengira kekerapan setiap aksara dalam rentetan pertama; Mengira kekerapan setiap aksara dalam rentetan kedua; TRAVERSE COUNT TRAVSE untuk mencari bilangan aksara yang akan dikeluarkan; Program pemacu untuk menjalankan kes itu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int CHARS = 26 ; int remAnagram ( string str1 , string str2 ) { int count1 [ CHARS ] = { 0 } , count2 [ CHARS ] = { 0 } ; for ( int i = 0 ; str1 [ i ] != ' \\0' ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; str2 [ i ] != ' \\0' ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ) ; return result ; } int main ( ) { string str1 = \" bcadeh \" , str2 = \" hea \" ; cout << remAnagram ( str1 , str2 ) ; return 0 ; }"}
{"text": "Semak jika rentetan mempunyai semua aksara dengan kekerapan yang sama dengan satu variasi yang dibenarkan | Program C ++ untuk memeriksa sama ada rentetan boleh dibuat sah dengan mengeluarkan paling banyak 1 aksara. ; Dengan mengandaikan hanya aksara kes yang lebih rendah; Untuk memeriksa rentetan S boleh ditukar kepada rentetan yang sah dengan mengeluarkan kurang daripada atau sama dengan satu aksara. ; Freq []: Menyimpan kekerapan setiap aksara rentetan; Cari watak pertama dengan kekerapan bukan sifar; Cari watak dengan kekerapan yang berbeza daripada Freq1. ; Jika kita mendapati kekerapan bukan sifar ketiga atau kiraan kedua -dua frekuensi menjadi lebih daripada 1, maka kembali palsu; lain jika kita mencari non -nol nol ketiga; Jika tuduhan kedua -dua frekuensi lebih daripada 1; Kembali benar jika kita sampai di sini; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int CHARS = 26 ; bool isValidString ( string str ) { int freq [ CHARS ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) count_freq1 ++ ; else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) count_freq1 ++ ; if ( freq [ k ] == freq2 ) count_freq2 ++ ; return false ; } if ( count_freq1 > 1 && count_freq2 > 1 ) return false ; } return true ; } int main ( ) { char str [ ] = \" abcbc \" ; if ( isValidString ( str ) ) cout << \" YES \" << endl ; else cout << \" NO \" << endl ; return 0 ; }"}
{"text": "Semak jika rentetan mempunyai semua aksara dengan kekerapan yang sama dengan satu variasi yang dibenarkan | Program C ++ untuk memeriksa sama ada rentetan boleh dibuat sah dengan mengeluarkan paling banyak 1 aksara menggunakan hashMap. ; Untuk memeriksa rentetan S boleh ditukar kepada rentetan variasi; Run Loop Borang 0 hingga panjang rentetan; pengisytiharan pembolehubah; jika pertama adalah benar daripada kenaikan countofval1; jika kedua adalah benar daripada kenaikan countofval2; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkForVariation ( string str ) { if ( str . empty ( ) || str . length ( ) != 0 ) { return true ; } map < char , int > mapp ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mapp [ str [ i ] ] ++ ; } bool first = true , second = true ; int val1 = 0 , val2 = 0 ; int countOfVal1 = 0 , countOfVal2 = 0 ; map < char , int > :: iterator itr ; for ( itr = mapp . begin ( ) ; itr != mapp . end ( ) ; ++ itr ) { int i = itr -> first ; if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; } if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } } int main ( ) { if ( checkForVariation ( \" abcbcvf \" ) ) cout << \" true \" << endl ; else cout << \" false \" << endl ; return 0 ; }"}
{"text": "Pasangan rentetan lengkap dalam dua set rentetan | C ++ pelaksanaan untuk mencari pasangan rentetan lengkap. ; Mengembalikan kiraan pasangan lengkap dari set [0 .. n - 1] dan set2 [0 .. m - 1]; Pertimbangkan semua pasangan kedua -dua rentetan; Buat penggabungan pasangan semasa; Mengira frekuensi semua aksara dalam rentetan yang disatukan. ; Jika kekerapan mana -mana watak tidak lebih besar daripada 0, maka pasangan ini tidak lengkap. ; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { string concat = set1 [ i ] + set2 [ j ] ; int frequency [ 26 ] = { 0 } ; for ( int k = 0 ; k < concat . length ( ) ; k ++ ) frequency [ concat [ k ] - ' a ' ] ++ ; int i ; for ( i = 0 ; i < 26 ; i ++ ) if ( frequency [ i ] < 1 ) break ; if ( i == 26 ) result ++ ; } } return result ; } int main ( ) { string set1 [ ] = { \" abcdefgh \" , \" geeksforgeeks \" , \" lmnopqrst \" , \" abc \" } ; string set2 [ ] = { \" ijklmnopqrstuvwxyz \" , \" abcdefghijklmnopqrstuvwxyz \" , \" defghijklmnopqrstuvwxyz \" } ; int n = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int m = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; cout << countCompletePairs ( set1 , set2 , n , m ) ; return 0 ; }"}
{"text": "Pasangan rentetan lengkap dalam dua set rentetan | Program C ++ untuk mencari kiraan pasangan lengkap; Mengembalikan kiraan pasangan lengkap dari set [0 .. n - 1] dan set2 [0 .. m - 1]; con_s1 [i] akan menyimpan integer yang set bit mewakili kehadiran / ketiadaan aksara dalam rentetan set1 [i]. Begitu juga con_s2 [i] akan menyimpan integer yang set bit mewakili kehadiran / ketiadaan aksara dalam rentetan set2 [i]; Proses semua rentetan dalam set1 []; memulakan semua bit ke 0; Menetapkan Kod ASCII Char S [i] [J] hingga 1 dalam integer yang dimampatkan. ; Proses semua rentetan dalam SET2 []; memulakan semua bit ke 0; Menetapkan Kod ASCII Char S [i] [J] hingga 1 dalam integer yang dimampatkan. ; Menetapkan pembolehubah yang semua 26 (0 ... 25) bit ditetapkan kepada 1; Sekarang pertimbangkan setiap pasangan integer dalam con_s1 [] dan con_s2 [] dan periksa sama ada pasangan itu selesai. ; Jika semua bit ditetapkan, rentetan selesai! ; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) { int result = 0 ; int con_s1 [ n ] , con_s2 [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { con_s1 [ i ] = 0 ; for ( int j = 0 ; j < set1 [ i ] . length ( ) ; j ++ ) { con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] [ j ] - ' a ' ) ) ; } } for ( int i = 0 ; i < m ; i ++ ) { con_s2 [ i ] = 0 ; for ( int j = 0 ; j < set2 [ i ] . length ( ) ; j ++ ) { con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] [ j ] - ' a ' ) ) ; } } long long complete = ( 1 << 26 ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) result ++ ; } } return result ; } int main ( ) { string set1 [ ] = { \" abcdefgh \" , \" geeksforgeeks \" , \" lmnopqrst \" , \" abc \" } ; string set2 [ ] = { \" ijklmnopqrstuvwxyz \" , \" abcdefghijklmnopqrstuvwxyz \" , \" defghijklmnopqrstuvwxyz \" } ; int n = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int m = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; cout << countCompletePairs ( set1 , set2 , n , m ) ; return 0 ; }"}
{"text": "Cari semua rentetan yang sepadan dengan corak tertentu dalam kamus | Program C ++ untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam corak dipetakan secara unik kepada watak dalam kamus; Fungsi untuk mengekodkan rentetan yang diberikan; untuk setiap watak dalam rentetan yang diberikan; Sekiranya watak itu berlaku untuk kali pertama, berikan nombor unik seterusnya kepada char itu; tambah nombor yang berkaitan dengan watak semasa ke dalam rentetan output; Berfungsi untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam corak dipetakan secara unik kepada watak dalam kamus; Len adalah panjang corak; Encode rentetan; untuk setiap perkataan dalam kamus; Jika saiz corak sama dengan saiz kata kamus semasa dan kedua -dua corak dan perkataan mempunyai hash yang sama, cetak perkataan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string encodeString ( string str ) { unordered_map < char , int > map ; string res = \" \" ; int i = 0 ; for ( char ch : str ) { if ( map . find ( ch ) == map . end ( ) ) map [ ch ] = i ++ ; res += to_string ( map [ ch ] ) ; } return res ; } void findMatchedWords ( unordered_set < string > dict , string pattern ) { int len = pattern . length ( ) ; string hash = encodeString ( pattern ) ; for ( string word : dict ) { if ( word . length ( ) == len && encodeString ( word ) == hash ) cout << word << \" ▁ \" ; } } int main ( ) { unordered_set < string > dict = { \" abb \" , \" abc \" , \" xyz \" , \" xyy \" } ; string pattern = \" foo \" ; findMatchedWords ( dict , pattern ) ; return 0 ; }"}
{"text": "Cari semua rentetan yang sepadan dengan corak tertentu dalam kamus | Program C ++ untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam corak dipetakan secara unik kepada watak dalam kamus; Berfungsi untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam corak dipetakan secara unik kepada watak dalam kamus; Len adalah panjang corak; untuk setiap perkataan dalam kamus; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string pattern , string word ) { if ( pattern . length ( ) != word . length ( ) ) return false ; char ch [ 128 ] = { 0 } ; int len = word . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ch [ pattern [ i ] ] == 0 ) ch [ pattern [ i ] ] = word [ i ] ; else if ( ch [ pattern [ i ] ] != word [ i ] ) return false ; } return true ; } void findMatchedWords ( unordered_set < string > dict , string pattern ) { int len = pattern . length ( ) ; for ( string word : dict ) { if ( check ( pattern , word ) ) cout << word << \" ▁ \" ; } } int main ( ) { unordered_set < string > dict = { \" abb \" , \" abc \" , \" xyz \" , \" xyy \" } ; string pattern = \" foo \" ; findMatchedWords ( dict , pattern ) ; return 0 ; }"}
{"text": "Kata -kata terbalik dalam rentetan yang diberikan | Program C ++ untuk pendekatan di atas :; Temp adalah untuk sempadan perkataan; Langkah 1 algoritma di atas; Keadaan ini adalah untuk memastikan bahawa rentetan bermula dengan watak yang sah (bukan ruang) sahaja; Langkah 2 algoritma di atas", "code": "void reverseWords ( char * s ) { char * word_begin = NULL ; char * temp = s ; while ( * temp ) { if ( ( word_begin == NULL ) && ( * temp != ' ▁ ' ) ) { word_begin = temp ; } if ( word_begin && ( ( * ( temp + 1 ) == ' ▁ ' ) || ( * ( temp + 1 ) == ' \\0' ) ) ) { reverse ( word_begin , temp ) ; word_begin = NULL ; } temp ++ ; } reverse ( s , temp - 1 ) ; }"}
{"text": "Kata -kata terbalik dalam rentetan yang diberikan | C ++ kod untuk membalikkan rentetan; Membalikkan rentetan; Semak sama ada bilangan perkataan walaupun; Cari perkataan tengah; Bermula dari pertengahan mula menukar kata -kata di kedudukan jth dan kedudukan l - 1 - j; Semak sama ada bilangan perkataan adalah ganjil; Cari perkataan tengah; Bermula dari pertengahan mula menukar kata -kata di kedudukan jth dan kedudukan l - 1 - j; Mengembalikan kalimat terbalik; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string RevString ( string s [ ] , int l ) { if ( l % 2 == 0 ) { int j = l / 2 ; while ( j <= l - 1 ) { string temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } else { int j = ( l / 2 ) + 1 ; while ( j <= l - 1 ) { string temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } string S = s [ 0 ] ; for ( int i = 1 ; i < 9 ; i ++ ) { S = S + \" ▁ \" + s [ i ] ; } return S ; } int main ( ) { string s = \" getting ▁ good ▁ at ▁ coding ▁ \" \" needs ▁ a ▁ lot ▁ of ▁ practice \" ; string words [ ] = { \" getting \" , \" good \" , \" at \" , \" coding \" , \" needs \" , \" a \" , \" lot \" , \" of \" , \" practice \" } ; cout << RevString ( words , 9 ) << endl ; return 0 ; }"}
{"text": "Laluan cetak dari akar ke semua nod dalam pokok binari yang lengkap | Program C ++ untuk mencetak jalan dari akar ke semua nod dalam pokok binari yang lengkap. ; Berfungsi untuk mencetak laluan semua nod nth node mewakili sebagai node node node yang diberikan mewakili sebagai nod kiri dan kanan; Keadaan asas jika nilai nod kth lebih besar maka nod nth maka nod kth bermakna tidak sah sehingga kami tidak menyimpannya ke dalam res hanya kami hanya kembali; Menyimpan nod ke res; Cetak jalan dari akar ke nod; Simpan jalan kiri pokok supaya kiri kita akan pergi nod (kthNode * 2); Jalan kanan pokok dan untuk betul kita akan pergi nod (kthnode * 2 + 1); Berfungsi untuk mencetak laluan dari akar ke semua nod; Res adalah untuk menyimpan jalan dari akar ke nod partikulat; Cetak jalan dari akar ke semua nod. Hujah ketiga 1 kerana kita perlu mempertimbangkan nod akar adalah 1; Kod pemacu; Diberikan nod; Cetak jalan dari akar ke semua nod.", "code": "#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void printPath ( vector < int > res , int nThNode , int kThNode ) { if ( kThNode > nThNode ) return ; res . push_back ( kThNode ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << \" ▁ \" ; cout << \" STRNEWLINE \" ; printPath ( res , nThNode , kThNode * 2 ) ; printPath ( res , nThNode , kThNode * 2 + 1 ) ; } void printPathToCoverAllNodeUtil ( int nThNode ) { vector < int > res ; printPath ( res , nThNode , 1 ) ; } int main ( ) { int nThNode = 7 ; printPathToCoverAllNodeUtil ( nThNode ) ; return 0 ; }"}
{"text": "Array Range Queries Untuk Mencari Nombor Armstrong Maksimum dengan Kemas Kini | C ++ kod untuk melaksanakan pendekatan di atas; Fungsi utiliti untuk mendapatkan indeks pertengahan julat yang diberikan. ; Fungsi yang kembali benar jika num adalah armstrong lain kembali palsu; Fungsi rekursif untuk mendapatkan jumlah nilai dalam julat array yang diberikan. Berikut adalah parameter untuk fungsi ini. ST -> Pointer ke Segmen Tree Node -> Indeks nod semasa dalam pokok segmen. SS & SE -> Memulakan dan mengakhiri indeks segmen yang diwakili oleh nod semasa, i. e. , St [nod] L & R -> Memulakan dan menamatkan indeks pertanyaan pelbagai; Jika segmen nod ini benar -benar sebahagian daripada julat yang diberikan, maka kembalikan segmen maksimum. ; Jika segmen nod ini tidak tergolong dalam julat yang diberikan; Jika segmen nod ini sebahagiannya adalah sebahagian daripada julat yang diberikan; Fungsi rekursif untuk mengemas kini nod yang telah diberikan indeks dalam julatnya. Berikut adalah parameter ST, SS dan SE adalah sama seperti yang ditakrifkan di atas indeks -> indeks elemen yang akan dikemas kini. ; nilai kemas kini dalam array dan dalam pokok segmen; Kembalikan max elemen dalam julat dari indeks l (pertanyaan permulaan) ke r (ujung pertanyaan). ; Semak nilai input yang salah; Fungsi rekursif yang membina pokok segmen untuk array [ss. . se]. Si adalah indeks nod semasa dalam segmen Tree St; Jika terdapat satu elemen dalam array, simpannya dalam nod semasa pokok segmen dan kembali; Sekiranya terdapat lebih daripada satu elemen, maka berulang untuk subtrees kiri dan kanan dan simpan nilai maksimum dalam nod ini; Fungsi untuk membina pokok segmen dari array yang diberikan. Fungsi ini memperuntukkan memori untuk pokok segmen. ; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan ST; Mengembalikan pokok segmen yang dibina; Kod pemacu; Membina pokok segmen dari array yang diberikan; Cetak maksimum nilai dalam array dari indeks 1 hingga 3; Kemas kini: Tetapkan ARR [1] = 153 dan kemas kini nod pokok segmen yang sepadan. ; Cari max selepas nilai dikemas kini", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } bool isArmstrong ( int x ) { int n = to_string ( x ) . size ( ) ; int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += pow ( digit , n ) ; temp /= 10 ; } if ( sum1 == x ) return true ; return false ; } int MaxUtil ( int * st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return -1 ; int mid = getMid ( ss , se ) ; return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; } void updateValue ( int arr [ ] , int * st , int ss , int se , int index , int value , int node ) { if ( index < ss index > se ) { cout << \" Invalid ▁ Input \" << endl ; return ; } if ( ss == se ) { arr [ index ] = value ; if ( isArmstrong ( value ) ) st [ node ] = value ; else st [ node ] = -1 ; } else { int mid = getMid ( ss , se ) ; if ( index >= ss && index <= mid ) updateValue ( arr , st , ss , mid , index , value , 2 * node + 1 ) ; else updateValue ( arr , st , mid + 1 , se , index , value , 2 * node + 2 ) ; st [ node ] = max ( st [ 2 * node + 1 ] , st [ 2 * node + 2 ] ) ; } return ; } int getMax ( int * st , int n , int l , int r ) { if ( l < 0 r > n - 1 l > r ) { printf ( \" Invalid ▁ Input \" ) ; return -1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; } int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si ) { if ( ss == se ) { if ( isArmstrong ( arr [ ss ] ) ) st [ si ] = arr [ ss ] ; else st [ si ] = -1 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; } int * constructST ( int arr [ ] , int n ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } int main ( ) { int arr [ ] = { 192 , 113 , 535 , 7 , 19 , 111 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * st = constructST ( arr , n ) ; cout << \" Maximum ▁ armstrong ▁ \" << \" number ▁ in ▁ given ▁ range ▁ = ▁ \" << getMax ( st , n , 1 , 3 ) << endl ; updateValue ( arr , st , 0 , n - 1 , 1 , 153 , 0 ) ; cout << \" Updated ▁ Maximum ▁ armstrong ▁ \" << \" number ▁ in ▁ given ▁ range ▁ = ▁ \" << getMax ( st , n , 1 , 3 ) << endl ; return 0 ; }"}
{"text": "Bilangan maksimum rantau di mana n non | Program C ++ untuk melaksanakan masalah di atas; Berfungsi untuk mencari bilangan maksimum kawasan di atas kapal terbang; Cetak bilangan maksimum kawasan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; cout << num ; } int main ( ) { int n = 10 ; maxRegions ( n ) ; return 0 ; }"}
{"text": "Semak sama ada teka -teki jigsaw boleh diselesaikan atau tidak | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada teka -teki jigsaw boleh diselesaikan atau tidak; Kes asas; Dengan meletakkan tab kosong sebagai rantai; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkSolveable ( int n , int m ) { if ( n == 1 or m == 1 ) cout << \" YES \" ; else if ( m == 2 and n == 2 ) cout << \" YES \" ; else cout << \" NO \" ; } int main ( ) { int n = 1 , m = 3 ; checkSolveable ( n , m ) ; }"}
{"text": "Semak sama ada mungkin untuk mencapai (x, y) dari (1, 0) dengan langkah -langkah yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari GCD dua nombor A dan B; Kes asas; Recursif mencari GCD; Fungsi untuk memeriksa sama ada (x, y) boleh dicapai dari (1, 0) dari langkah yang diberikan; Jika GCD adalah 1, kemudian cetak \"Ya\"; Kod pemacu; Diberikan x dan y; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; int GCD ( int a , int b ) { if ( b == 0 ) return a ; else return GCD ( b , a % b ) ; } void check ( int x , int y ) { if ( GCD ( x , y ) == 1 ) { cout << \" Yes \" ; } else { cout << \" No \" ; } } int main ( ) { int X = 2 , Y = 7 ; check ( X , Y ) ; return 0 ; }"}
{"text": "Kebarangkalian fungsi ketat Euler dalam julat [l, r] untuk dibahagikan dengan m | Program C ++ untuk melaksanakan pendekatan di atas; Seieve of erotosthenes untuk mengira semua prima; Jika Perdana; Tandakan semua gandaannya sebagai bukan perdana; Fungsi untuk mencari kebarangkalian fungsi ketat Euler dalam julat tertentu; Memulakan dua tatasusunan dengan nilai dari L ke R untuk Totient Euler; Pengindeksan dari 0; Jika nombor semasa adalah perdana; Memeriksa jika saya adalah faktor utama nombor dalam julat l ke r; Kemas kini semua nombor yang mempunyai faktor utama i; Jika nombor dalam julat mempunyai faktor utama> sqrt (nombor); Hitung mereka yang boleh dibahagikan dengan m; Mengembalikan hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define size  1000001 NEW_LINE void seiveOfEratosthenes ( int * prime ) { prime [ 0 ] = 1 , prime [ 1 ] = 0 ; for ( int i = 2 ; i * i < 1000001 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < 1000001 ; j += i ) { prime [ j ] = 1 ; } } } } float probabiltyEuler ( int * prime , int L , int R , int M ) { int * arr = new int [ size ] { 0 } ; int * eulerTotient = new int [ size ] { 0 } ; int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { eulerTotient [ i - L ] = i ; arr [ i - L ] = i ; } for ( int i = 2 ; i < 1000001 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = ( L / i ) * i ; j <= R ; j += i ) { if ( j - L >= 0 ) { eulerTotient [ j - L ] = eulerTotient [ j - L ] / i * ( i - 1 ) ; while ( arr [ j - L ] % i == 0 ) { arr [ j - L ] /= i ; } } } } } for ( int i = L ; i <= R ; i ++ ) { if ( arr [ i - L ] > 1 ) { eulerTotient [ i - L ] = ( eulerTotient [ i - L ] / arr [ i - L ] ) * ( arr [ i - L ] - 1 ) ; } } for ( int i = L ; i <= R ; i ++ ) { if ( ( eulerTotient [ i - L ] % M ) == 0 ) { count ++ ; } } return ( 1.0 * count / ( R + 1 - L ) ) ; } int main ( ) { int * prime = new int [ size ] { 0 } ; seiveOfEratosthenes ( prime ) ; int L = 1 , R = 7 , M = 3 ; cout << probabiltyEuler ( prime , L , R , M ) ; return 0 ; }"}
{"text": "Permainan pembahagi ganjil terbesar untuk memeriksa pemain mana yang menang | C ++ pelaksanaan untuk mencari permainan pembahagi ganjil terbesar untuk memeriksa pemain mana yang menang; Berfungsi untuk mencari permainan pembahagi ganjil terbesar untuk memeriksa pemain mana yang menang; Semak jika n == 1 maka pemain 2 akan menang; Semak jika n == 2 atau n adalah ganjil; Manakala n lebih besar daripada k dan dibahagikan dengan 2 terus meningkatkan val; Gelung untuk mencari pembahagi ganjil yang paling hebat; Periksa sama ada n adalah kuasa 2; Semak sama ada CNT bukanlah pemain yang menang 1; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWinner ( int n , int k ) { int cnt = 0 ; if ( n == 1 ) cout << \" No \" << endl ; else if ( ( n & 1 ) or n == 2 ) cout << \" Yes \" << endl ; else { int tmp = n ; int val = 1 ; while ( tmp > k and tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( int i = 3 ; i <= sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) cout << \" No \" << endl ; else if ( n / tmp == 2 and cnt == 1 ) cout << \" No \" << endl ; else cout << \" Yes \" << endl ; } } int main ( ) { long long n = 1 , k = 1 ; findWinner ( n , k ) ; return 0 ; }"}
{"text": "Cari semua nombor sehingga N yang kedua -dua pentagonal dan heksagon | C ++ program pendekatan di atas; Berfungsi untuk mencetak nombor sehingga kedua -dua pentagonal dan nombor heksagon; Kirakan nombor pentagonal saya; Semak sama ada nombor pentagonal PN adalah heksagon atau tidak; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void pen_hex ( long long n ) { long long pn = 1 ; for ( long long int i = 1 ; ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; long double seqNum = ( 1 + sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == long ( seqNum ) ) cout << pn << \" , ▁ \" ; } } int main ( ) { long long int N = 1000000 ; pen_hex ( N ) ; return 0 ; }"}
{"text": "Semak jika baris | C ++ pelaksanaan untuk memeriksa sama ada baris - perintah utama traversal matriks adalah palindrome atau tidak; Fungsi untuk memeriksa sama ada baris - perintah utama traversal matriks adalah palindrome; Gelung untuk memeriksa sama ada matriks adalah matriks adalah palindrome atau tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPal ( int a [ 3 ] [ 3 ] , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; } int main ( ) { int n = 3 , m = 3 ; int a [ 3 ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 4 } , { 3 , 2 , 1 } } ; if ( isPal ( a , n , m ) ) { cout << \" YES \" << endl ; } else { cout << \" NO \" << endl ; } }"}
{"text": "Cari nombor terkecil yang jumlah digitnya adalah n | Program C ++ untuk mencari nombor terkecil yang jumlah digitnya juga n; Berfungsi untuk mendapatkan jumlah digit; Berfungsi untuk mencari nombor terkecil yang jumlah digit juga n; Memeriksa jika nombor mempunyai jumlah digit = n; Kod pemacu", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } void smallestNumber ( int N ) { int i = 1 ; while ( 1 ) { if ( getSum ( i ) == N ) { cout << i ; break ; } i ++ ; } } int main ( ) { int N = 10 ; smallestNumber ( N ) ; return 0 ; }"}
{"text": "Nombor jarang | Pelaksanaan C ++ untuk memeriksa sama ada N adalah nombor yang jarang berlaku; Fungsi berulang untuk membalikkan digit NUM; Fungsi untuk memeriksa sama ada N adalah persegi sempurna; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Fungsi untuk memeriksa sama ada n adalah nombor yang jarang berlaku; Cari terbalik n; Nombor harus bukan palindromic; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } bool isRare ( int N ) { int reverseN = reversDigits ( N ) ; if ( reverseN == N ) return false ; return isPerfectSquare ( N + reverseN ) && isPerfectSquare ( N - reverseN ) ; } int main ( ) { int n = 65 ; if ( isRare ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Kira nombor dari julat yang faktor utama hanya 2 dan 3 menggunakan tatasusunan | Tetapkan 2 | Program C ++ untuk mengira unsur -unsur dalam julat [l, r] yang faktor utama hanya 2 dan 3; Fungsi yang akan mengira unsur -unsur dalam julat yang diberikan; Simpan kuasa semasa 2; Simpan kuasa semasa 3; Power23 [] akan menyimpan produk pasangan unsur -unsur Power2 dan Power3 yang <= r; Masukkan dalam Power23] [] hanya jika Mul <= r; Simpan jawapan yang diperlukan; Cetak hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE void calc_ans ( ll l , ll r ) { vector < ll > power2 , power3 ; ll mul2 = 1 ; while ( mul2 <= r ) { power2 . push_back ( mul2 ) ; mul2 *= 2 ; } ll mul3 = 1 ; while ( mul3 <= r ) { power3 . push_back ( mul3 ) ; mul3 *= 3 ; } vector < ll > power23 ; for ( int x = 0 ; x < power2 . size ( ) ; x ++ ) { for ( int y = 0 ; y < power3 . size ( ) ; y ++ ) { ll mul = power2 [ x ] * power3 [ y ] ; if ( mul == 1 ) continue ; if ( mul <= r ) power23 . push_back ( mul ) ; } } ll ans = 0 ; for ( ll x : power23 ) { if ( x >= l && x <= r ) ans ++ ; } cout << ans << endl ; } int main ( ) { ll l = 1 , r = 10 ; calc_ans ( l , r ) ; return 0 ; }"}
{"text": "Count k panjangnya yang produknya juga | C ++ pelaksanaan untuk mengira panjang K panjangnya yang produknya juga; Fungsi untuk mengira NCR; Mengembalikan faktorial n; Fungsi untuk mencari bilangan Kekuatan panjang K yang produknya adalah bilangannya; mengira nombor ganjil dalam array; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) ; int nCr ( int n , int r ) { if ( r > n ) return 0 ; return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int countSubsequences ( int arr [ ] , int n , int k ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) countOdd ++ ; } int ans = nCr ( n , k ) - nCr ( countOdd , k ) ; return ans ; } int main ( ) { int arr [ ] = { 2 , 4 } ; int K = 1 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubsequences ( arr , N , K ) ; return 0 ; }"}
{"text": "Cari bit yang paling ketara dari nombor x dalam asas y | Program C ++ untuk mencari digit pertama X dalam asas y; Berfungsi untuk mencari digit pertama x dalam asas y; mengira bilangan digit x dalam asas y; Mencari digit pertama X dalam asas y; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void first_digit ( int x , int y ) { int length = log ( x ) / log ( y ) + 1 ; int first_digit = x / pow ( y , length - 1 ) ; cout << first_digit ; } int main ( ) { int X = 55 , Y = 3 ; first_digit ( X , Y ) ; return 0 ; }"}
{"text": "Nombor Curzon | C ++ pelaksanaan pendekatan; Berfungsi untuk memeriksa sama ada nombor adalah nombor curzon atau tidak; Cari 2 ^ n + 1; Cari 2 * n + 1; Semak untuk pembahagian; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkIfCurzonNumber ( int N ) { long int powerTerm , productTerm ; powerTerm = pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) cout << \" Yes STRNEWLINE \" ; else cout << \" No STRNEWLINE \" ; } int main ( ) { long int N = 5 ; checkIfCurzonNumber ( N ) ; N = 10 ; checkIfCurzonNumber ( N ) ; return 0 ; }"}
{"text": "Kiraan minimum nombor yang diperlukan berakhir dengan 7 hingga jumlah sebagai nombor tertentu | C ++ pelaksanaan pendekatan; Fungsi untuk mengembalikan kiraan nombor minimum yang berakhir dengan 7 yang diperlukan supaya jumlah nombor ini adalah n; Hasharr [i] akan menyimpan nombor minimum yang berakhir dengan 7 supaya ia merangkumi jumlah yang berakhir dengan Digit I; Ia sentiasa mungkin untuk menulis nombor> 69 untuk menulis sebagai nombor yang berakhir dengan 7; Jika nombor itu sama dengan jumlah nombor minimum yang berakhir dengan 7; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int TEN = 10 ; int minCount ( int n ) { int hasharr [ TEN ] = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % TEN ] ; else { if ( n >= hasharr [ n % TEN ] * 7 ) return ( hasharr [ n % TEN ] ) ; else return -1 ; } } int main ( ) { int n = 38 ; cout << minCount ( n ) ; return 0 ; }"}
{"text": "Program untuk mencetak corak segitiga binari yang diubahsuai | C ++ pelaksanaan untuk mencetak corak segi tiga binari yang diubah suai; Berfungsi untuk mencetak corak binari yang diubah suai; Gelung untuk melintasi baris; Gelung untuk melintasi nombor dalam setiap baris; Periksa sama ada J adalah 1 atau saya dalam cetakan kes 1; Lain cetak 0; Tukar kursor ke baris seterusnya selepas setiap baris; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void modifiedBinaryPattern ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) cout << 1 ; else cout << 0 ; } cout << endl ; } } int main ( ) { int n = 7 ; modifiedBinaryPattern ( n ) ; }"}
{"text": "Cari bahagian sebenar dan khayalan nombor kompleks | Program C ++ untuk mencari bahagian sebenar dan khayalan nombor kompleks; Berfungsi untuk mencari bahagian sebenar dan khayalan nombor kompleks; panjang rentetan yang disimpan dalam pembolehubah L; pembolehubah untuk indeks pemisah; Menyimpan indeks ' +'; lain menyimpan indeks ' -'; Mencari bahagian sebenar nombor kompleks; Mencari bahagian khayalan nombor kompleks; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findRealAndImag ( string s ) { int l = s . length ( ) ; int i ; if ( s . find ( ' + ' ) < l ) { i = s . find ( ' + ' ) ; } else { i = s . find ( ' - ' ) ; } string real = s . substr ( 0 , i ) ; string imaginary = s . substr ( i + 1 , l - i - 2 ) ; cout << \" Real ▁ part : ▁ \" << real << \" STRNEWLINE \" ; cout << \" Imaginary ▁ part : ▁ \" << imaginary << \" STRNEWLINE \" ; } int main ( ) { string s = \"3 + 4i \" ; findRealAndImag ( s ) ; return 0 ; }"}
{"text": "Kuasa yang berbeza dari nombor n supaya jumlahnya sama dengan k | C ++ pelaksanaan untuk mencari kuasa yang berbeza N yang menambah sehingga K; Berfungsi untuk mengembalikan kuasa tertinggi n tidak melebihi k; Gelung untuk mencari kuasa tertinggi kurang daripada k; Memulakan PowerArray dengan semua 0. ; Berfungsi untuk mencetak kuasa yang berbeza n yang menambah sehingga k; Mendapatkan kuasa tertinggi N sebelum k; Untuk memeriksa sama ada kuasa digunakan dua kali atau tidak; Cetak - 1 jika kuasa digunakan dua kali; Jika kuasa tidak dikunjungi, maka tandakan kuasa seperti yang dikunjungi; Menurunkan nilai k; Mencetak kuasa N yang merangkumi K; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPower ( int n , int k ) { int i = 0 ; int a = pow ( n , i ) ; while ( a <= k ) { i += 1 ; a = pow ( n , i ) ; } return i - 1 ; } int b [ 50 ] = { 0 } ; int PowerArray ( int n , int k ) { while ( k ) { int t = highestPower ( n , k ) ; if ( b [ t ] ) { cout << -1 ; return 0 ; } else b [ t ] = 1 ; k -= pow ( n , t ) ; } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] ) { cout << i << \" , ▁ \" ; } } } int main ( ) { int N = 3 ; int K = 40 ; PowerArray ( N , K ) ; return 0 ; }"}
{"text": "Jumlah elemen dalam array yang mempunyai kekerapan komposit | Program C ++ untuk mencari jumlah elemen dalam array yang mempunyai kekerapan komposit; Berfungsi untuk membuat ayak untuk memeriksa prima; Jika komposit [p] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada komposit; Berfungsi untuk mengembalikan jumlah elemen dalam array yang mempunyai kekerapan komposit; Peta digunakan untuk menyimpan frekuensi elemen; Untuk menyimpan jumlah; Melintasi peta menggunakan iterators; Kira bilangan elemen yang mempunyai frekuensi komposit; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE void SieveOfEratosthenes ( vector < bool > & composite ) { for ( int i = 0 ; i < N ; i ++ ) composite [ i ] = false ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( ! composite [ p ] ) { for ( int i = p * 2 ; i < N ; i += p ) composite [ i ] = true ; } } } int sumOfElements ( int arr [ ] , int n ) { vector < bool > composite ( N ) ; SieveOfEratosthenes ( composite ) ; unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int sum = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( composite [ it -> second ] ) { sum += ( it -> first ) ; } } return sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 1 , 1 , 3 , 3 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumOfElements ( arr , n ) ; return 0 ; }"}
{"text": "Padam semua elemen kekerapan ganjil dari array | Program C ++ untuk menghilangkan semua elemen frekuensi ganjil dari array; Fungsi yang menghilangkan unsur -unsur yang mempunyai frekuensi ganjil dalam array; Buat peta untuk menyimpan kekerapan setiap elemen; Keluarkan unsur -unsur yang mempunyai frekuensi ganjil; Jika elemen mempunyai kekerapan ganjil maka lompat; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void remove ( int arr [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( m [ arr [ i ] ] & 1 ) ) continue ; cout << arr [ i ] << \" , ▁ \" ; } } int main ( ) { int arr [ ] = { 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; remove ( arr , n ) ; return 0 ; }"}
{"text": "Memaksimumkan elemen pertama array supaya purata tetap tetap | C ++ pelaksanaan untuk memaksimumkan elemen pertama array supaya purata array tetap tetap; Nilai maksimum elemen array pertama yang boleh dicapai; Pembolehubah untuk menyimpan jumlahnya; Gelung untuk mencari jumlah array; Nilai maksimum yang dikehendaki; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } cout << min ( s , x ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int x = 5 ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getmax ( arr , arr_size , x ) ; return 0 ; }"}
{"text": "Panjang minimum laluan terpendek segitiga | Program C ++ untuk menggambarkan masalah di atas; berfungsi untuk mendapatkan panjang minimum bahagian yang lebih pendek dari segitiga; melintasi setiap mata di atas kapal terbang; Jika jumlah mata lebih besar daripada yang sebelumnya, maksimum akan diganti; Cetak panjang; Kod pemacu; memulakan bilangan mata; mata di kapal terbang", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ; int i = 0 ; while ( n -- ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } cout << \" Length ▁ - > ▁ \" << answer << endl ; cout << \" Path ▁ - > ▁ \" << \" ( ▁ 1 , ▁ \" << answer << \" ▁ ) \" << \" and ▁ ( ▁ \" << answer << \" , ▁ 1 ▁ ) \" ; } int main ( ) { int n = 4 ; int x [ n ] = { 1 , 4 , 2 , 1 } ; int y [ n ] = { 4 , 1 , 1 , 2 } ; shortestLength ( n , x , y ) ; return 0 ; }"}
{"text": "Berpotongan segi empat tepat apabila bawah | Program CPP untuk mencari persegi persegi persegi dua segi empat tepat. ; berfungsi untuk mencari persegi persegi persegi dua segi empat tepat. ; memberikan titik kiri bawah persegi persegi persegi; memberikan titik kanan persegi persegi persegi; tiada persimpangan; memberikan titik kiri atas persegi persegi persegi; memberikan titik bawah persegi persegi persegi; Kod pemacu; bawah - kiri dan atas - sudut kanan segi empat tepat pertama; bawah - kiri dan atas - sudut kanan segi empat tepat pertama; panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = max ( x1 , x3 ) ; int y5 = max ( y1 , y3 ) ; int x6 = min ( x2 , x4 ) ; int y6 = min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { cout << \" No ▁ intersection \" ; return ; } cout << \" ( \" << x5 << \" , ▁ \" << y5 << \" ) ▁ \" ; cout << \" ( \" << x6 << \" , ▁ \" << y6 << \" ) ▁ \" ; int x7 = x5 ; int y7 = y6 ; cout << \" ( \" << x7 << \" , ▁ \" << y7 << \" ) ▁ \" ; int x8 = x6 ; int y8 = y5 ; cout << \" ( \" << x8 << \" , ▁ \" << y8 << \" ) ▁ \" ; } int main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ; FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; return 0 ; }"}
{"text": "Cari Sudut Rectangle Menggunakan Poin Mid | Program C ++ untuk mencari titik sudut segi empat tepat menggunakan panjang dan titik tengah yang diberikan. ; Struktur untuk mewakili titik co -ordinate; Fungsi ini menerima dua mata dan panjang sisi segi empat tepat dan mencetak titik 4 sudut segi empat tepat; Rectangle mendatar; segi empat tepat menegak; segi empat tepat; Hitung cerun sisi; Kirakan anjakan di sepanjang paksi; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Point { float x , y ; Point ( ) { x = y = 0 ; } Point ( float a , float b ) { x = a , y = b ; } } ; void printCorners ( Point p , Point q , float l ) { Point a , b , c , d ; if ( p . x == q . x ) { a . x = p . x - ( l / 2.0 ) ; a . y = p . y ; d . x = p . x + ( l / 2.0 ) ; d . y = p . y ; b . x = q . x - ( l / 2.0 ) ; b . y = q . y ; c . x = q . x + ( l / 2.0 ) ; c . y = q . y ; } else if ( p . y == q . y ) { a . y = p . y - ( l / 2.0 ) ; a . x = p . x ; d . y = p . y + ( l / 2.0 ) ; d . x = p . x ; b . y = q . y - ( l / 2.0 ) ; b . x = q . x ; c . y = q . y + ( l / 2.0 ) ; c . x = q . x ; } else { float m = ( p . x - q . x ) / float ( q . y - p . y ) ; float dx = ( l / sqrt ( 1 + ( m * m ) ) ) * 0.5 ; float dy = m * dx ; a . x = p . x - dx ; a . y = p . y - dy ; d . x = p . x + dx ; d . y = p . y + dy ; b . x = q . x - dx ; b . y = q . y - dy ; c . x = q . x + dx ; c . y = q . y + dy ; } cout << a . x << \" , ▁ \" << a . y << \" ▁ n \" << b . x << \" , ▁ \" << b . y << \" n \" ; << c . x << \" , ▁ \" << c . y << \" ▁ n \" << d . x << \" , ▁ \" << d . y << \" nn \" ; } int main ( ) { Point p1 ( 1 , 0 ) , q1 ( 1 , 2 ) ; printCorners ( p1 , q1 , 2 ) ; Point p ( 1 , 1 ) , q ( -1 , -1 ) ; printCorners ( p , q , 2 * sqrt ( 2 ) ) ; return 0 ; }"}
{"text": "Kurangkan kos untuk mengubah suai array sedemikian rupa sehingga indeks mempunyai unsur -unsur dan sebaliknya | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mengubah suai array mengikut kriteria yang diberikan; Mengira kedudukan yang salah dan juga unsur -unsur; Kiraan ganjil; Malah mengira; Kos menukar; Menurun kos selepas bertukar; Hanya pengurangan kos; Mengembalikan kos minimum dua kes; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumCost ( int arr [ ] , int N , int X , int Y ) { int even_count = 0 , odd_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) && ( i % 2 == 0 ) ) { odd_count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) ) { even_count ++ ; } } int cost1 = X * min ( odd_count , even_count ) ; int cost2 = Y * ( max ( odd_count , even_count ) - min ( odd_count , even_count ) ) ; int cost3 = ( odd_count + even_count ) * Y ; return min ( cost1 + cost2 , cost3 ) ; } int main ( ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 } , X = 10 , Y = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumCost ( arr , N , X , Y ) ; return 0 ; }"}
{"text": "Produk minimum elemen maksimum dan minimum ke atas semua subarray yang mungkin | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari produk minimum minimum dan maksimum di antara semua subarray yang mungkin; Kedai produk minimum yang dihasilkan; Melintasi array yang diberikan []; Min produk dari dua sepasang elemen berturut -turut; Mengembalikan nilai yang dihasilkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinMax ( vector < int > & a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . size ( ) ; ++ i ) { min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; } int main ( ) { vector < int > arr = { 6 , 4 , 5 , 6 , 2 , 4 , 1 } ; cout << findMinMax ( arr ) ; return 0 ; }"}
{"text": "Jumlah semua nod dengan nilai yang lebih kecil pada jarak k dari nod yang diberikan dalam BST | Program C ++ untuk pendekatan di atas; Struktur pokok; Pembina; Berfungsi untuk menambah nod ke jumlah di bawah nod sasaran; Kes asas; Jika nod jauh kth dicapai; Berulang untuk kiri dan subtrees kanan; Fungsi untuk mencari nod jauh dari nod sasaran, ia kembali - 1 jika nod sasaran tidak hadir di dalam pokok; Kes asas 1; Jika sasaran sama dengan akar. ; Berulang untuk subtree kiri; Pokok adalah BST jadi mengurangkan ruang carian; Semak jika nod sasaran ditemui di subtree kiri; Jika akar berada pada jarak k dari sasaran; Node kurang daripada sasaran akan hadir di sebelah kiri; Apabila nod tidak hadir di subtree kiri; Jika nod jauh kth dicapai; Node kurang daripada sasaran pada jarak k mungkin terdapat di pokok kiri; Jika sasaran tidak hadir di sebelah kiri atau di subtree kanan; Berfungsi untuk memasukkan nod dalam BST; Jika akar adalah batal; Masukkan data pada separuh kanan; Masukkan data di separuh kiri; Mengembalikan nod akar; Fungsi untuk mencari jumlah n nod jauh dari nod sasaran yang mempunyai nilai kurang daripada nod sasaran; Menyimpan jumlah nod yang mempunyai nilai <sasaran pada jarak k; Cetak jumlah yang dihasilkan; Kod pemacu; Buat pokok", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct TreeNode { int data ; TreeNode * left ; TreeNode * right ; TreeNode ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; } } ; void kDistanceDownSum ( TreeNode * root , int k , int & sum ) { if ( root == NULL k < 0 ) return ; if ( k == 0 ) { sum += root -> data ; return ; } kDistanceDownSum ( root -> left , k - 1 , sum ) ; kDistanceDownSum ( root -> right , k - 1 , sum ) ; } int kDistanceSum ( TreeNode * root , int target , int k , int & sum ) { if ( root == NULL ) return -1 ; if ( root -> data == target ) { kDistanceDownSum ( root -> left , k - 1 , sum ) ; return 0 ; } int dl = -1 ; if ( target < root -> data ) { dl = kDistanceSum ( root -> left , target , k , sum ) ; } if ( dl != -1 ) { if ( dl + 1 == k ) sum += root -> data ; return -1 ; } int dr = -1 ; if ( target > root -> data ) { dr = kDistanceSum ( root -> right , target , k , sum ) ; } if ( dr != -1 ) { if ( dr + 1 == k ) sum += root -> data ; else kDistanceDownSum ( root -> left , k - dr - 2 , sum ) ; return 1 + dr ; } return -1 ; } TreeNode * insertNode ( int data , TreeNode * root ) { if ( root == NULL ) { TreeNode * node = new TreeNode ( data ) ; return node ; } else if ( data > root -> data ) { root -> right = insertNode ( data , root -> right ) ; } else if ( data <= root -> data ) { root -> left = insertNode ( data , root -> left ) ; } return root ; } void findSum ( TreeNode * root , int target , int K ) { int sum = 0 ; kDistanceSum ( root , target , K , sum ) ; cout << sum ; } int main ( ) { TreeNode * root = NULL ; int N = 11 ; int tree [ ] = { 3 , 1 , 7 , 0 , 2 , 5 , 10 , 4 , 6 , 9 , 8 } ; for ( int i = 0 ; i < N ; i ++ ) { root = insertNode ( tree [ i ] , root ) ; } int target = 7 ; int K = 2 ; findSum ( root , target , K ) ; return 0 ; }"}
{"text": "Cari item n yang diedarkan dari item tak terhingga jenis tak terhingga berdasarkan syarat -syarat yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jenis item yang diberikan mengikut peraturan yang diberikan; Menyimpan kiraan item yang diberikan pada setiap langkah; Melangkah ke hari dari 1; Melewati jenis item pada hari itu; Count item yang diberikan hendaklah melebihi n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } } int main ( ) { int N = 10 ; cout << itemType ( N ) ; return 0 ; }"}
{"text": "Cari jumlah semua elemen array yang sama dari dua kuasa berturut -turut 2 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencetak jumlah elemen array yang sama dari dua kuasa berturut -turut 2; Menyimpan jumlah yang dihasilkan dari unsur -unsur array; Melintasi array arr []; Menyimpan kuasa 2 daripada nombor arr [i]; Menyimpan nombor yang kuasa 2 dan lebih rendah daripada atau sama dengan arr [i]; Menyimpan nombor yang kuasa 2 dan lebih besar daripada atau sama dengan arr [i]; Jika arr [i] - Lesservalue adalah sama seperti besar - arr [i]; Kenaikan res oleh arr [i]; Mengembalikan jumlah yang dihasilkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int FindSum ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int power = log2 ( arr [ i ] ) ; int LesserValue = pow ( 2 , power ) ; int LargerValue = pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; } int main ( ) { int arr [ ] = { 10 , 24 , 17 , 3 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << FindSum ( arr , N ) ; return 0 ; }"}
{"text": "Cari orang yang akan selesai terakhir | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari orang yang akan selesai terakhir; Untuk menjejaki baris dan lajur yang mempunyai 1; Baris dan lajur yang ada; Bilangan minimum pilihan yang kita ada; Jika bilangan pilihan ganjil; P1 akan selesai terakhir; Jika tidak, P2 akan selesai terakhir; Diberi matriks", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLast ( int mat [ ] [ 3 ] ) { int m = 3 ; int n = 3 ; set < int > rows ; set < int > cols ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . insert ( i ) ; cols . insert ( j ) ; } } } int avRows = m - rows . size ( ) ; int avCols = n - cols . size ( ) ; int choices = min ( avRows , avCols ) ; if ( choices & 1 ) cout << \" P1\" ; else cout << \" P2\" ; } int main ( ) { int mat [ ] [ 3 ] = { { 1 , 0 , 0 } , { 0 , 0 , 0 } , { 0 , 0 , 1 } } ; findLast ( mat ) ; }"}
{"text": "Jumlah perpuluhan yang merupakan perwakilan binari nombor semulajadi n pertama | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jumlah nombor semulajadi N pertama yang diwakili dalam perwakilan binari; Menyimpan jumlah yang dihasilkan; Melangkah sehingga nilai n lebih besar daripada 0; Jika n kurang daripada 2; Simpan kedudukan MSB N; Iterat dalam julat [1, x] dan tambahkan sumbangan nombor dari 1 hingga (2 ^ x - 1); Kemas kini nilai CUR dan tambah; Tambah cur ke ans; Simpan nombor yang tinggal; Tambah sumbangan oleh MSB dengan bilangan yang tinggal; Lelaran seterusnya akan diulangi untuk 2 ^ x - 1; Cetak hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = 1e9 + 7 ; void sumOfBinaryNumbers ( int n ) { int ans = 0 ; int one = 1 ; while ( 1 ) { if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; } int x = log2 ( n ) ; int cur = 0 ; int add = ( one << ( x - 1 ) ) ; for ( int i = 1 ; i <= x ; i ++ ) { cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; } ans = ( ans + cur ) % MOD ; int rem = n - ( one << x ) + 1 ; int p = pow ( 10 , x ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ; n = rem - 1 ; } cout << ans ; } int main ( ) { int N = 3 ; sumOfBinaryNumbers ( N ) ; return 0 ; }"}
{"text": "Nombor Fibonacci terdekat kepada N | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari nombor Fibonacci yang paling dekat dengan N; Kes asas; Memulakan syarat pertama & kedua siri Fibonacci; Simpan istilah ketiga; ITERATE Sehingga istilah ketiga kurang daripada atau sama dengan NUM; Kemas kini yang pertama; Kemas kini yang kedua; Mengemas kini yang ketiga; Simpan nombor Fibonacci yang mempunyai perbezaan yang lebih kecil dengan N; Cetak hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void nearestFibonacci ( int num ) { if ( num == 0 ) { cout << 0 ; return ; } int first = 0 , second = 1 ; int third = first + second ; while ( third <= num ) { first = second ; second = third ; third = first + second ; } int ans = ( abs ( third - num ) >= abs ( second - num ) ) ? second : third ; cout << ans ; } int main ( ) { int N = 17 ; nearestFibonacci ( N ) ; return 0 ; }"}
{"text": "Permutasi nombor semulajadi n pertama yang diberikan array sebagai array maksimum awalan | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada array awalan maksimum ANS [] sama dengan array arr []; Memulakan pembolehubah, maks; Melintasi array, ans []; Simpan nilai maksimum sehingga indeks i; Jika ia tidak sama dengan [i], maka kembali palsu; Sebaliknya kembali palsu; Berfungsi untuk mencari permutasi array yang array maksimum awalan yang sama dengan array yang diberikan []; Menyimpan permutasi yang diperlukan; Menyimpan indeks kejadian pertama unsur; Melintasi array a []; Jika A [i] tidak hadir di um, maka simpannya di um; Kemas kini Ans [i] ke [i]; Menyimpan nombor yang tidak disokong; Isi array, v []; Simpan indeks; Melintasi array, ans []; Isi V [J] di tempat -tempat di mana Ans [i] adalah 0; Semak sama ada array awalan maksimum permutasi semasa adalah sama dengan array yang diberikan []; Jika benar, cetak permutasi; Jika tidak, cetak - 1; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPermutation ( int ans [ ] , int a [ ] , int n ) { int Max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { Max = max ( Max , ans [ i ] ) ; if ( Max != a [ i ] ) return false ; } return true ; } void findPermutation ( int a [ ] , int n ) { int ans [ n ] = { 0 } ; unordered_map < int , int > um ; for ( int i = 0 ; i < n ; i ++ ) { if ( um . find ( a [ i ] ) == um . end ( ) ) { ans [ i ] = a [ i ] ; um [ a [ i ] ] = i ; } } vector < int > v ; int j = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( um . find ( i ) == um . end ( ) ) { v . push_back ( i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 0 ) { ans [ i ] = v [ j ] ; j ++ ; } } if ( checkPermutation ( ans , a , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << \" ▁ \" ; } } else cout << \" - 1\" ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findPermutation ( arr , N ) ; return 0 ; }"}
{"text": "Kira pasangan elemen yang sama mungkin dengan tidak termasuk setiap elemen array sekali | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan pasangan yang diperlukan untuk setiap elemen array; Memulakan peta; Mengemas kini kekerapan setiap elemen; Menyimpan kiraan pasangan; Melintasi peta; Hitung bilangan cara untuk memilih pasangan yang terdiri daripada unsur yang sama sahaja; Melintasi array; Cetak kiraan untuk setiap elemen array; Kod pemacu; Diberikan array; Saiz array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEqualElementPairs ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] += 1 ; } int total = 0 ; for ( auto i : mp ) { total += ( i . second * ( i . second - 1 ) ) / 2 ; } for ( int i = 0 ; i < N ; i ++ ) { cout << total - ( mp [ arr [ i ] ] - 1 ) << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEqualElementPairs ( arr , N ) ; }"}
{"text": "Count of Octal Number sehingga digit N | Program C ++ untuk mencari kiraan nombor oktal semulajadi sehingga digit; Berfungsi untuk mengembalikan kiraan nombor oktal semulajadi sehingga digit; Gelung untuk berulang dari 1 hingga N dan mengira bilangan nombor oktal untuk setiap digit 'i' th. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * pow ( 8 , i - 1 ) ; } return sum ; } int main ( ) { int N = 4 ; cout << count ( N ) ; return 0 ; }"}
{"text": "Pembahagi Palindromic nombor | Program C ++ untuk mencari semua pembahagi palindromik nombor; Fungsi untuk memeriksa adalah NUM adalah palindromic atau tidak; Tukar n ke string str; Memulakan dan mengakhiri indeks string str; Jika char di s dan e tidak sama maka kembali palsu; Berfungsi untuk mencari pembahagi palindromik; Untuk sakit pembahagi palindromik nombor n; Jika n boleh dibahagikan dengan i; Semak jika nombor adalah persegi yang sempurna; Periksa pembahagi adalah palindromic, kemudian simpannya; Semak jika pembahagi adalah palindrome; Semak jika N / pembahagi adalah palindromik atau tidak; Cetak semua pembahagi palindromik dalam urutan yang disusun; Kod pemacu; Fungsi panggilan untuk mencari semua pembahagi palindromik", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; bool isPalindrome ( int n ) { string str = to_string ( n ) ; int s = 0 , e = str . length ( ) - 1 ; while ( s < e ) { if ( str [ s ] != str [ e ] ) { return false ; } s ++ ; e -- ; } return true ; } void palindromicDivisors ( int n ) { vector < int > PalindromDivisors ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( isPalindrome ( i ) ) { PalindromDivisors . push_back ( i ) ; } } else { if ( isPalindrome ( i ) ) { PalindromDivisors . push_back ( i ) ; } if ( isPalindrome ( n / i ) ) { PalindromDivisors . push_back ( n / i ) ; } } } } sort ( PalindromDivisors . begin ( ) , PalindromDivisors . end ( ) ) ; for ( int i = 0 ; i < PalindromDivisors . size ( ) ; i ++ ) { cout << PalindromDivisors [ i ] << \" ▁ \" ; } } int main ( ) { int n = 66 ; palindromicDivisors ( n ) ; }"}
{"text": "Keluarkan nombor minimum dari array untuk mendapatkan minimum atau nilai | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan penghapusan minimum untuk mendapatkan minimum atau; Untuk menyimpan elemen minimum; Cari elemen minimum dari array; Untuk menyimpan kekerapan elemen minimum; Cari kekerapan elemen minimum; Kembalikan jawapan terakhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDel ( int * arr , int n ) { int min_num = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) min_num = min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; } int main ( ) { int arr [ ] = { 3 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMinDel ( arr , n ) ; return 0 ; }"}
{"text": "Bilangan subarray dengan GCD sama dengan 1 | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan yang diperlukan; Untuk menyimpan jawapan terakhir; Untuk menyimpan GCD bermula dari indeks 'i'; Gelung untuk mencari GCD setiap subarray dari arr [i] ke arr [i ... n - 1]; Kenaikan kiraan jika curr_gcd = 1; Kembalikan jawapan terakhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubArr ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_gcd = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ; ans += ( curr_gcd == 1 ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntSubArr ( arr , n ) ; return 0 ; }"}
{"text": "Program untuk mencetak nombor perdana dari 1 hingga n. | Program C ++ untuk memaparkan nombor utama N Perdana; Berfungsi untuk mencetak nombor utama n pertama; Mengisytiharkan pembolehubah; Mesej paparan cetak; Melintasi setiap nombor dari 1 hingga n dengan bantuan untuk gelung; Langkau 0 dan 1 kerana mereka bukan Perdana atau Komposit; pembolehubah bendera untuk memberitahu jika saya adalah perdana atau tidak; Bendera = 1 bermakna saya adalah perdana dan bendera = 0 bermakna saya bukan perdana; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_primes_till_N ( int N ) { int i , j , flag ; cout << \" Prime numbers between 1 and \" << N < < \" ▁ are : STRNEWLINE \" ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) cout << i << \" ▁ \" ; } } int main ( ) { int N = 100 ; print_primes_till_N ( N ) ; return 0 ; }"}
{"text": "Memaksimumkan ungkapan (a dan x) * (b dan x) | Manipulasi Bit | C ++ pelaksanaan pendekatan; Fungsi untuk mencari x mengikut syarat yang diberikan; Int boleh mempunyai 32 bit; Bit sementara; Kirakan sedikit x mengikut syarat -syarat yang diberikan di bawah adalah kesimpulan langsung dari ilustrasi yang telah kami ambil sebelumnya; Tambah sedikit x ke x; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  32 NEW_LINE int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; } int main ( ) { int A = 11 , B = 13 ; cout << findX ( A , B ) ; return 0 ; }"}
{"text": "Bilangan subset yang min adalah maksimum | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan subset dengan min maksimum; Nilai maksimum dari array; Untuk menyimpan bilangan elemen maksimum kali muncul dalam array; Mengembalikan kiraan subset yang sah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubSets ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( pow ( 2 , cnt ) - 1 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntSubSets ( arr , n ) ; return 0 ; }"}
{"text": "Kebarangkalian bahawa pasangan rawak yang dipilih dari array (a [i], a [j]) mempunyai jumlah maksimum | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kebarangkalian mendapatkan jumlah pasangan maksimum apabila pasangan rawak dipilih dari array yang diberikan; Memulakan jumlah maksimum, kiraannya dan kiraan jumlah pasangan; Untuk setiap pasangan; Dapatkan jumlah pasangan semasa; Jika jumlahnya sama dengan jumlah maksimum semasa setakat ini; Kenaikan kiraannya; Jika jumlahnya lebih besar daripada maksimum semasa; Kemas kini maksimum semasa dan semula - memulakan kiraan kepada 1; Cari kebarangkalian yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float findProb ( int arr [ ] , int n ) { long maxSum = INT_MIN , maxCount = 0 , totalPairs = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( sum == maxSum ) { maxCount ++ ; } else if ( sum > maxSum ) { maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } } float prob = ( float ) maxCount / ( float ) totalPairs ; return prob ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findProb ( arr , n ) ; return 0 ; }"}
{"text": "Kiraan maksimum pembahagi umum a dan b sedemikian rupa sehingga semua adalah co | C ++ pelaksanaan pendekatan; Fungsi untuk mengembalikan kiraan faktor umum a dan b supaya semua elemen adalah co - perdana antara satu sama lain; GCD A dan B; Termasuk 1 pada mulanya; Cari semua faktor utama GCD; Jika GCD adalah perdana; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCommonFactors ( int a , int b ) { int gcd = __gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { ans ++ ; while ( gcd % i == 0 ) gcd /= i ; } } if ( gcd != 1 ) ans ++ ; return ans ; } int main ( ) { int a = 12 , b = 18 ; cout << maxCommonFactors ( a , b ) ; return 0 ; }"}
{"text": "Cari nombor hari dalam tahun semasa untuk tarikh yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan hari tahun ini untuk tarikh yang diberikan; Ekstrak tahun, bulan dan hari dari rentetan tarikh; Sekiranya tahun semasa adalah tahun lompat dan tarikh yang diberikan adalah selepas 28 Februari maka ia mesti termasuk 29 Februari; Tambah hari pada bulan -bulan sebelumnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int days [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int dayOfYear ( string date ) { int year = stoi ( date . substr ( 0 , 4 ) ) ; int month = stoi ( date . substr ( 5 , 2 ) ) ; int day = stoi ( date . substr ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; } while ( month -- > 0 ) { day = day + days [ month - 1 ] ; } return day ; } int main ( ) { string date = \"2019-01-09\" ; cout << dayOfYear ( date ) ; return 0 ; }"}
{"text": "Cari bilangan sel dalam jadual mengandungi x | Program CPP untuk mencari bilangan sel dalam jadual mengandungi x; Fungsi untuk mencari bilangan sel dalam jadual mengandungi x; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; } int main ( ) { int n = 6 , x = 12 ; cout << Cells ( n , x ) ; return 0 ; }"}
{"text": "Kuasa terkecil 4 lebih besar daripada atau sama dengan N | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan kuasa terkecil 4 lebih besar daripada atau sama dengan n; Jika n sendiri adalah kuasa 4 maka kembali n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nextPowerOfFour ( int n ) { int x = floor ( sqrt ( sqrt ( n ) ) ) ; if ( pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return pow ( x , 4 ) ; } } int main ( ) { int n = 122 ; cout << nextPowerOfFour ( n ) ; return 0 ; }"}
{"text": "Operasi minimum yang diperlukan untuk menukar x ke y dengan mendarabkan x dengan co yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan operasi minimum yang diperlukan; Tidak mungkin; Untuk menyimpan kuasa terbesar p yang membahagikan d; Sementara dibahagi oleh p; Untuk menyimpan kuasa terbesar Q yang membahagikan d; Manakala dibahagi oleh q; Jika d> 1; Kerana, d = p ^ a * q ^ b; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int x , int y , int p , int q ) { if ( y % x != 0 ) return -1 ; int d = y / x ; int a = 0 ; while ( d % p == 0 ) { d /= p ; a ++ ; } int b = 0 ; while ( d % q == 0 ) { d /= q ; b ++ ; } if ( d != 1 ) return -1 ; return ( a + b ) ; } int main ( ) { int x = 12 , y = 2592 , p = 2 , q = 3 ; cout << minOperations ( x , y , p , q ) ; return 0 ; }"}
{"text": "Bilangan kuadrup dengan GCD sama dengan k | C ++ pelaksanaan pendekatan; Fungsi untuk mengira NC4; Kes asas untuk mengira NC4; Berfungsi untuk mengembalikan kiraan kuadrup yang diperlukan menggunakan pengecualian inklusi; Berkesan n; Melangkah lebih dari 2 hingga m; Bilangan pembahagi saya hingga m; Count menyimpan bilangan pembahagi utama yang berlaku tepat sekali; Untuk mengelakkan pengulangan pembahagi utama; Jika pengulangan pembahagi utama hadir mengabaikan nombor ini; Jika kiraan pembahagi utama ganjil tolaknya dari jawapan lain, tambah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCr ( int n ) { if ( n < 4 ) return 0 ; int answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; answer /= 24 ; return answer ; } int countQuadruples ( int N , int K ) { int M = N / K ; int answer = nCr ( M ) ; for ( int i = 2 ; i < M ; i ++ ) { int j = i ; int temp2 = M / i ; int count = 0 ; int check = 0 ; int temp = j ; while ( j % 2 == 0 ) { count ++ ; j /= 2 ; if ( count >= 2 ) break ; } if ( count >= 2 ) { check = 1 ; } for ( int k = 3 ; k <= sqrt ( temp ) ; k += 2 ) { int cnt = 0 ; while ( j % k == 0 ) { cnt ++ ; j /= k ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) { check = 1 ; break ; } else if ( cnt == 1 ) count ++ ; } if ( j > 2 ) { count ++ ; } if ( check ) continue ; else { if ( count % 2 == 1 ) { answer -= nCr ( temp2 ) ; } else { answer += nCr ( temp2 ) ; } } } return answer ; } int main ( ) { int N = 10 , K = 2 ; cout << countQuadruples ( N , K ) ; return 0 ; }"}
{"text": "Cari nombor yang ditambah kepada nisbah yang diberikan A: B, nisbah berubah kepada C: D | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nombor x yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; } int main ( ) { int a = 2 , b = 3 , c = 4 , d = 5 ; cout << getX ( a , b , c , d ) ; return 0 ; }"}
{"text": "Bilangan cara untuk mengatur perkataan sedemikian rupa sehingga tiada vokal berlaku bersama | C ++ kod untuk pendekatan di atas; Fungsi untuk memeriksa sama ada watak adalah vokal atau konsonen; Berfungsi untuk mengira faktorial nombor; Mengira tidak ada cara untuk mengatur vokal; Melelehkan peta dan mengira bilangan vokal dan mengira tiada cara untuk mengatur vokal; mengira tidak ada cara untuk mengatur perkataan yang diberikan supaya semua vokal bersatu; Kira tidak ada cara untuk mengatur vokal; untuk menyimpan penyebut pecahan; Count of Consonents; Kirakan bilangan cara untuk mengatur perkataan sedemikian rupa sehingga semua vokal bersatu; Untuk mengira jumlah permutasi; Untuk menyimpan panjang perkataan yang diberikan; penyebut pecahan; mengembalikan jumlah permutasi perkataan yang diberikan; Berfungsi untuk mengira bilangan permutasi supaya tiada vokal bersatu; untuk menyimpan kekerapan watak; Mengira kekerapan semua aksara; Hitung jumlah permutasi; Hitung jumlah permutasi sedemikian rupa sehingga semua vokal bersatu; substrat vwl_tgthr dari total untuk mendapatkan hasilnya; mengembalikan hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; bool isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; else return false ; } ll fact ( ll n ) { if ( n < 2 ) return 1 ; return n * fact ( n - 1 ) ; } ll only_vowels ( map < char , int > & freq ) { ll denom = 1 ; ll cnt_vwl = 0 ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { if ( isVowel ( itr -> first ) ) { denom *= fact ( itr -> second ) ; cnt_vwl += itr -> second ; } } return fact ( cnt_vwl ) / denom ; } ll all_vowels_together ( map < char , int > & freq ) { ll vow = only_vowels ( freq ) ; ll denom = 1 ; ll cnt_cnst = 0 ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { if ( ! isVowel ( itr -> first ) ) { denom *= fact ( itr -> second ) ; cnt_cnst += itr -> second ; } } ll ans = fact ( cnt_cnst + 1 ) / denom ; return ( ans * vow ) ; } ll total_permutations ( map < char , int > & freq ) { ll cnt = 0 ; ll denom = 1 ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { denom *= fact ( itr -> second ) ; cnt += itr -> second ; } return fact ( cnt ) / denom ; } ll no_vowels_together ( string & word ) { map < char , int > freq ; for ( int i = 0 ; i < word . size ( ) ; i ++ ) { char ch = tolower ( word [ i ] ) ; freq [ ch ] ++ ; } ll total = total_permutations ( freq ) ; ll vwl_tgthr = all_vowels_together ( freq ) ; ll res = total - vwl_tgthr ; return res ; } int main ( ) { string word = \" allahabad \" ; ll ans = no_vowels_together ( word ) ; cout << ans << endl ; word = \" geeksforgeeks \" ; ans = no_vowels_together ( word ) ; cout << ans << endl ; word = \" abcd \" ; ans = no_vowels_together ( word ) ; cout << ans << endl ; return 0 ; }"}
{"text": "Program untuk mencari bilangan lelaki pada mulanya | C ++ pelaksanaan pendekatan di atas. ; Berfungsi untuk mengembalikan bilangan lelaki pada mulanya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; } int main ( ) { int D = 5 , m = 4 , d = 4 ; cout << numberOfMen ( D , m , d ) ; return 0 ; }"}
{"text": "Kawasan segitiga yang dibentuk oleh paksi Co | Kawasan program C ++ yang dibentuk oleh paksi Co - ordinat dan garis lurus yang diberikan; Berfungsi untuk mencari kawasan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double area ( double a , double b , double c ) { double d = fabs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; } int main ( ) { double a = -2 , b = 4 , c = 3 ; cout << area ( a , b , c ) ; return 0 ; }"}
{"text": "Jumlah dua nombor di mana satu nombor diwakili sebagai pelbagai digit | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan vektor yang mengandungi jawapannya; Vektor V adalah untuk menyimpan setiap digit jumlah dan vektor ANS adalah untuk menyimpan jawapannya; Tidak dibawa pada mulanya; Mula gelung dari hujung dan ambil elemen satu demi satu; Indeks array dan nombor angka terakhir; Mengekalkan pembawa penjumlahan; Tolak nilai digit ke dalam array; Nilai k lebih besar kemudian 0; Tolak digit k satu demi satu dalam array; Juga mengekalkan pembawa dengan penjumlahan; Membalikkan unsur -unsur vektor v dan simpannya dalam vektor ans; Kod pemacu; Cetak jawapannya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > addToArrayForm ( vector < int > & A , int K ) { vector < int > v , ans ; int rem = 0 ; int i = 0 ; for ( i = A . size ( ) - 1 ; i >= 0 ; i -- ) { int my = A [ i ] + K % 10 + rem ; if ( my > 9 ) { rem = 1 ; v . push_back ( my % 10 ) ; } else { v . push_back ( my ) ; rem = 0 ; } K = K / 10 ; } while ( K > 0 ) { int my = K % 10 + rem ; v . push_back ( my % 10 ) ; if ( my / 10 > 0 ) rem = 1 ; else rem = 0 ; K = K / 10 ; } if ( rem > 0 ) v . push_back ( rem ) ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) ans . push_back ( v [ i ] ) ; return ans ; } int main ( ) { vector < int > A { 2 , 7 , 4 } ; int K = 181 ; vector < int > ans = addToArrayForm ( A , K ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] ; return 0 ; }"}
{"text": "Kirakan maksimum fungsi dengan cekap ke atas semua sub | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan jumlah maksimum sub - array; Berfungsi untuk mengembalikan nilai maksimum fungsi f; Mengira Arrays B [] dan C []; Cari Sub Maksimum Sub - pelbagai tatasusunan dan mengambil maksimum di antara mereka; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define MAX  100005 NEW_LINE using namespace std ; int kadaneAlgorithm ( const int * ar , int n ) { int sum = 0 , maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; if ( sum < 0 ) sum = 0 ; maxSum = max ( maxSum , sum ) ; } return maxSum ; } int maxFunction ( const int * arr , int n ) { int b [ MAX ] , c [ MAX ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i & 1 ) { b [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) ; c [ i ] = - b [ i ] ; } else { c [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) ; b [ i ] = - c [ i ] ; } } int ans = kadaneAlgorithm ( b , n - 1 ) ; ans = max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 5 , 4 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxFunction ( arr , n ) ; return 0 ; }"}
{"text": "Ketiga digit terakhir dalam 5 ^ n untuk diberikan n | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari elemen; jika n <3; Jika n juga kembali 6 jika n adalah pulangan ganjil 1; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; } int main ( ) { int n = 7 ; cout << findThirdDigit ( n ) ; return 0 ; }"}
{"text": "Kebarangkalian memenangi perlawanan apabila kebarangkalian individu memukul sasaran yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kebarangkalian kemenangan; P dan Q menyimpan nilai pecahan A / B dan C / D; Untuk menyimpan kebarangkalian kemenangan A; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; } int main ( ) { int a = 1 , b = 2 , c = 10 , d = 11 ; cout << getProbability ( a , b , c , d ) ; return 0 ; }"}
{"text": "Nombor palindromik terbesar dalam array | C ++ pelaksanaan pendekatan di atas; Fungsi untuk memeriksa sama ada n adalah palindrome; Cari pembahagi yang sesuai untuk mengekstrak digit terkemuka; Jika digit pertama dan terakhir tidak sama maka kembali palsu; Mengeluarkan digit terkemuka dan trailing dari nombor; Mengurangkan pembahagi dengan faktor 2 sebagai 2 digit dijatuhkan; Berfungsi untuk mencari nombor palindromik terbesar; Sekiranya palindrom lebih besar daripada semasa yang dijumpai; Mengembalikan nombor palindromik terbesar dari array; Program pemacu; Cetak jawapan yang diperlukan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } int largestPalindrome ( int A [ ] , int n ) { int currentMax = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > currentMax && isPalindrome ( A [ i ] ) ) currentMax = A [ i ] ; } return currentMax ; } int main ( ) { int A [ ] = { 1 , 232 , 54545 , 999991 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << largestPalindrome ( A , n ) ; return 0 ; }"}
{"text": "Kurangkan array ke satu elemen dengan operasi yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan elemen akhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; } int main ( ) { int N = 12 ; cout << getFinalElement ( N ) ; return 0 ; }"}
{"text": "Jumlah elemen dalam array yang mempunyai kekerapan utama | Program C ++ untuk mencari jumlah elemen dalam array yang mempunyai kekerapan utama; Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mengembalikan jumlah elemen dalam array yang mempunyai kekerapan utama; Peta digunakan untuk menyimpan frekuensi elemen; Melintasi peta menggunakan iterators; Mengira bilangan elemen yang mempunyai frekuensi utama; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } int sumOfElements ( int arr [ ] , int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , n + 1 ) ; int i , j ; unordered_map < int , int > m ; for ( i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int sum = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( prime [ it -> second ] ) { sum += ( it -> first ) ; } } return sum ; } int main ( ) { int arr [ ] = { 5 , 4 , 6 , 5 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumOfElements ( arr , n ) ; return 0 ; }"}
{"text": "Jumlah semua nombor palindromik panjang dalam julat [l, r] | Program C ++ untuk mencari jumlah semua nombor palindromik panjang yang ganjil dalam julat yang diberikan; Fungsi yang mengembalikan benar jika nombor yang diberikan adalah palindrome; Di sini kita menjana nombor baru (reverse_num) * dengan membalikkan digit nombor input asal; Jika nombor input asal (num) adalah sama dengan * ke belakangnya (reverse_num) maka palindrome * lain tidak. ; Fungsi yang mengembalikan benar jika nombor yang diberikan adalah panjang ganjil; Berfungsi untuk mengembalikan jumlah semua nombor palindromik panjang yang ganjil dalam julat yang diberikan; jika nombor adalah palindrome dan panjang ganjil; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( int num ) { int reverse_num = 0 , remainder , temp ; temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp /= 10 ; } if ( reverse_num == num ) { return true ; } return false ; } bool isOddLength ( int num ) { int count = 0 ; while ( num > 0 ) { num /= 10 ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; } long sumOfAllPalindrome ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; } int main ( ) { int L = 110 , R = 1130 ; cout << \" ▁ \" << sumOfAllPalindrome ( L , R ) << endl ; }"}
{"text": "Bilangan cara untuk mengatur perkataan sedemikian rupa sehingga semua vokal berlaku bersama | Program C ++ untuk mengira no. cara untuk mengatur perkataan yang mempunyai vokal bersama; Faktorial nombor; mengira cara untuk mengatur konsonan; Abaikan vokal; mengira cara untuk mengatur vokal; Fungsi untuk mengira jumlah no. cara; Mengira vokal dan konsonan; Jumlah tidak. cara; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll fact ( int n ) { ll f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f = f * i ; return f ; } ll waysOfConsonants ( int size1 , int freq [ ] ) { ll ans = fact ( size1 ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) continue ; else ans = ans / fact ( freq [ i ] ) ; } return ans ; } ll waysOfVowels ( int size2 , int freq [ ] ) { return fact ( size2 ) / ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ; } ll countWays ( string str ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != ' a ' && str [ i ] != ' e ' && str [ i ] != ' i ' && str [ i ] != ' o ' && str [ i ] != ' u ' ) consonant ++ ; else vowel ++ ; } return waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ; } int main ( ) { string str = \" geeksforgeeks \" ; cout << countWays ( str ) << endl ; return 0 ; }"}
{"text": "Jumlah nombor Fibonacci dengan negatif alternatif | Program C ++ untuk mencari jumlah alternatif nombor Fibonacci; Mengira nilai nombor Fibonacci pertama dan menyimpan jumlah alternatif mereka; Memulakan hasil; Tambah istilah yang tinggal; Bahkan istilah; Untuk istilah ganjil; Mengembalikan jumlah bergantian; Program pemacu untuk menguji fungsi di atas; Dapatkan n; Cari jumlah bergantian", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; } int main ( ) { int n = 8 ; cout << \" Alternating ▁ Fibonacci ▁ Sum ▁ upto ▁ \" << n << \" ▁ terms : ▁ \" << calculateAlternateSum ( n ) << endl ; return 0 ; }"}
{"text": "Cari istilah n Siri 1 2 2 4 4 4 4 8 8 8 8 8 8 8 8 ... | Program CPP untuk mencari istilah n; Fungsi yang akan mengembalikan istilah nth; Kod pemacu; Dapatkan n; Dapatkan nilai; Dapatkan n; Dapatkan nilai", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; } int main ( void ) { int n = 9 ; cout << getValue ( n ) << endl ; n = 1025 ; cout << getValue ( n ) << endl ; }"}
{"text": "Bina pelbagai frekuensi digit nilai yang diperoleh dari x ^ 1, x ^ 2, ... .... . , x ^ n | Pelaksanaan CPP pendekatan di atas; Fungsi yang melintasi digit dalam nombor dan mengubah suai jumlah kekerapan kekerapan; Array untuk menyimpan kiraan digit; Melintasi x ^ 1 hingga x ^ n; Untuk fungsi kuasa, kedua -dua parameternya akan dua kali ganda; Memanggil Countdigits berfungsi pada x ^ i; Mencetak kiraan digit 0 - 9; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countDigits ( double val , long arr [ ] ) { while ( ( long ) val > 0 ) { long digit = ( long ) val % 10 ; arr [ ( int ) digit ] ++ ; val = ( long ) val / 10 ; } return ; } void countFrequency ( int x , int n ) { long freq_count [ 10 ] = { 0 } ; for ( int i = 1 ; i <= n ; i ++ ) { double val = pow ( ( double ) x , ( double ) i ) ; countDigits ( val , freq_count ) ; } for ( int i = 0 ; i <= 9 ; i ++ ) { cout << freq_count [ i ] << \" ▁ \" ; } } int main ( ) { int x = 15 , n = 3 ; countFrequency ( x , n ) ; }"}
{"text": "Bilangan nilai b seperti a = b + (a ^ b) | Program C ++ untuk mencari bilangan nilai b seperti A = B + (A ^ B); berfungsi untuk mengembalikan bilangan penyelesaian; Semak setiap nilai yang mungkin; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; } int main ( ) { int a = 3 ; cout << countSolutions ( a ) ; }"}
{"text": "Bilangan nilai b seperti a = b + (a ^ b) | Program C ++ untuk mencari bilangan nilai b seperti A = B + (A ^ B); berfungsi untuk mengembalikan bilangan penyelesaian; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSolutions ( int a ) { int count = __builtin_popcount ( a ) ; count = pow ( 2 , count ) ; return count ; } int main ( ) { int a = 3 ; cout << countSolutions ( a ) ; }"}
{"text": "Jumlah kawasan semua persegi yang mungkin di dalam segi empat tepat | Program CPP untuk mengira jumlah kawasan semua dataran yang mungkin terdapat di dalam segi empat tepat; Fungsi untuk mengira jumlah kawasan semua dataran yang mungkin masuk ke dalam segi empat tepat; Persegi dengan saiz maksimum mungkin; Kirakan jumlah persegi saiz tertentu; mengira kawasan dataran dengan saiz tertentu; Jumlah kawasan; saiz kenaikan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; } int main ( ) { int l = 4 , b = 3 ; cout << calculateAreaSum ( l , b ) ; return 0 ; }"}
{"text": "Hyperfactorial nombor | / C ++ program untuk mencari hyperfactorial nombor; fungsi untuk mengira nilai hiperfakterial; memulakan val kepada 1; mengembalikan hiperfactoral nombor; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE ll boost_hyperfactorial ( ll num ) { ll val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { val = val * pow ( i , i ) ; } return val ; } int main ( ) { int num = 5 ; cout << boost_hyperfactorial ( num ) ; return 0 ; }"}
{"text": "Hyperfactorial nombor | Program C ++ untuk mencari hyperfactorial nombor menggunakan perpustakaan rangsangan; fungsi untuk mengira nilai hiperfakterial; memulakan val kepada 1; 1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . ; mengembalikan hiperfactoral nombor; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #include <boost/multiprecision/cpp_int.hpp> NEW_LINE using namespace boost :: multiprecision ; using namespace std ; int1024_t boost_hyperfactorial ( int num ) { int1024_t val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; } int main ( ) { int num = 5 ; cout << boost_hyperfactorial ( num ) ; return 0 ; }"}
{"text": "Kurangkan 1 tanpa pengendali aritmetik | C ++ kod untuk menolak satu daripada nombor tertentu; Flip semua bit set sehingga kita dapati 1; Flip paling tepat 1 bit; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int subtractOne ( int x ) { int m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } int main ( ) { cout << subtractOne ( 13 ) << endl ; return 0 ; }"}
{"text": "Cari vektor min matriks | Program C ++ untuk mencari vektor min matriks yang diberikan; Fungsi untuk mencari vektor min; gelung untuk melintasi setiap lajur; untuk mengira min setiap baris; untuk menyimpan jumlah elemen lajur; Kod pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define rows  3 NEW_LINE #define cols  3 NEW_LINE void meanVector ( int mat [ rows ] [ cols ] ) { cout << \" [ ▁ \" ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; cout << mean << \" ▁ \" ; } cout << \" ] \" ; } int main ( ) { int mat [ rows ] [ cols ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; meanVector ( mat ) ; return 0 ; }"}
{"text": "Nombor Hoax | Kod CPP untuk memeriksa sama ada nombor adalah nombor tipuan atau tidak. ; Fungsi untuk mencari faktor utama yang berbeza dari nombor n; N adalah ganjil pada ketika ini, kerana ia tidak lagi dibahagikan dengan 2. Oleh itu, kita boleh menguji hanya untuk nombor ganjil, sama ada faktor n; Semak jika saya adalah faktor utama; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Fungsi untuk mengira jumlah digit faktor utama yang berbeza dari nombor N dan jumlah digit nombor N dan bandingkan jumlah yang diperoleh; Faktor utama N sedang disimpan dalam vektor PF; Jika n adalah nombor perdana, ia tidak boleh menjadi nombor tipuan; Mencari jumlah digit faktor utama yang berbeza dari nombor n; Mencari jumlah digit dalam faktor utama semasa PF [i]. ; Mencari jumlah digit nombor n; Membandingkan dua jumlah yang dikira; Kaedah Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > primeFactors ( int n ) { vector < int > res ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = n / 2 ; res . push_back ( 2 ) ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; res . push_back ( i ) ; } } if ( n > 2 ) res . push_back ( n ) ; return res ; } bool isHoax ( int n ) { vector < int > pf = primeFactors ( n ) ; if ( pf [ 0 ] == n ) return false ; int all_pf_sum = 0 ; for ( int i = 0 ; i < pf . size ( ) ; i ++ ) { int pf_sum ; for ( pf_sum = 0 ; pf [ i ] > 0 ; pf_sum += pf [ i ] % 10 , pf [ i ] /= 10 ) ; all_pf_sum += pf_sum ; } int sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n /= 10 ) ; return sum_n == all_pf_sum ; } int main ( ) { int n = 84 ; if ( isHoax ( n ) ) cout << \" A ▁ Hoax ▁ Number STRNEWLINE \" ; else cout << \" Not ▁ a ▁ Hoax ▁ Number STRNEWLINE \" ; return 0 ; }"}
{"text": "Ujian Primal | Tetapkan 5 (menggunakan program Lucas | C ++ untuk mengetahui siri Lucas - Lehmer.; Fungsi untuk mengetahui istilah pertama N (mempertimbangkan 4 sebagai istilah ke -0) Lucas - Lehmer Series;", "code": "#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void LucasLehmer ( int n ) { unsigned long long current_val = 4 ; vector < unsigned long long > series ; series . push_back ( current_val ) ; for ( int i = 0 ; i < n ; i ++ ) { current_val = current_val * current_val - 2 ; series . push_back ( current_val ) ; } for ( int i = 0 ; i <= n ; i ++ ) cout << \" Term ▁ \" << i << \" : ▁ \" << series [ i ] << endl ; } int main ( ) { int n = 5 ; LucasLehmer ( n ) ; return 0 ; }"}
{"text": "Modular multiplicative songsang dari 1 hingga n | Program C ++ untuk mencari songsang modular semua nombor dari 1 hingga n menggunakan kaedah naif; Kaedah naif untuk mencari terbalik berbilang modular 'A' di bawah modulo 'Perdana; Program Pemandu", "code": "#include <iostream> NEW_LINE using namespace std ; int modInverse ( int a , int prime ) { a = a % prime ; for ( int x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return -1 ; } void printModIverses ( int n , int prime ) { for ( int i = 1 ; i <= n ; i ++ ) cout << modInverse ( i , prime ) << \" ▁ \" ; } int main ( ) { int n = 10 , prime = 17 ; printModIverses ( n , prime ) ; return 0 ; }"}
{"text": "Tukar ke nombor dengan digit sebagai 3 dan 8 sahaja | CPP untuk mencari operasi min yang diperlukan untuk menukar ke nombor yang menawan; fungsi untuk operasi minimum; baki dan kiraan operasi; mengira digit tidak sama dengan 3 atau 8; fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOp ( long long int num ) { int rem ; int count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; } int main ( ) { long long int num = 234198 ; cout << \" Minimum ▁ Operations ▁ = \" << minOp ( num ) ; return 0 ; }"}
{"text": "Integer terbesar yang mempunyai jumlah digit maksimum dalam julat dari 1 hingga n | Program CPP untuk mencari nombor dengan jumlah digit maksimum. ; berfungsi untuk mengira jumlah digit nombor. ; Mengembalikan nombor maksimum dengan jumlah maksimum digit. ; memulakan b sebagai 1 dan jumlah maksimum awal menjadi n; berulang dari kanan ke kiri dalam digit; Walaupun meleleh ini adalah nombor dari kanan ke kiri; memanggil fungsi untuk memeriksa sama ada jumlah CUR adalah lebih daripada ANS; mengurangkan nombor ke satu unit kurang; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigits ( int a ) { int sum = 0 ; while ( a ) { sum += a % 10 ; a /= 10 ; } return sum ; } int findMax ( int x ) { int b = 1 , ans = x ; while ( x ) { int cur = ( x - 1 ) * b + ( b - 1 ) ; if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) || ( sumOfDigits ( cur ) == sumOfDigits ( ans ) && cur > ans ) ) ans = cur ; x /= 10 ; b *= 10 ; } return ans ; } int main ( ) { int n = 521 ; cout << findMax ( n ) ; return 0 ; }"}
{"text": "Julat Interquartile (IQR) | Program CPP untuk mencari IQR set data; Fungsi untuk memberi indeks median; Fungsi untuk mengira IQR; Indeks median keseluruhan data; Median separuh pertama; Median separuh kedua; Pengiraan IQR; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int median ( int * a , int l , int r ) { int n = r - l + 1 ; n = ( n + 1 ) / 2 - 1 ; return n + l ; } int IQR ( int * a , int n ) { sort ( a , a + n ) ; int mid_index = median ( a , 0 , n ) ; int Q1 = a [ median ( a , 0 , mid_index ) ] ; int Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] ; return ( Q3 - Q1 ) ; } int main ( ) { int a [ ] = { 1 , 19 , 7 , 6 , 5 , 9 , 12 , 27 , 18 , 2 , 15 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << IQR ( a , n ) ; return 0 ; }"}
{"text": "Nombor palindromik terbesar dalam array | C ++ pelaksanaan pendekatan di atas; Fungsi untuk memeriksa sama ada n adalah palindrome; Cari pembahagi yang sesuai untuk mengekstrak digit terkemuka; Jika digit pertama dan terakhir tidak sama maka kembali palsu; Mengeluarkan digit terkemuka dan trailing dari nombor; Mengurangkan pembahagi dengan faktor 2 sebagai 2 digit dijatuhkan; Berfungsi untuk mencari nombor palindromik terbesar; Susun array; Jika nombor adalah palindrome; Jika tiada nombor palindromik yang dijumpai; Program pemacu; Cetak jawapan yang diperlukan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } int largestPalindrome ( int A [ ] , int n ) { sort ( A , A + n ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( isPalindrome ( A [ i ] ) ) return A [ i ] ; } return -1 ; } int main ( ) { int A [ ] = { 1 , 232 , 54545 , 999991 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << largestPalindrome ( A , n ) ; return 0 ; }"}
{"text": "Jumlah gandaan dua nombor di bawah n | Program C ++ untuk mencari jumlah semua bilangan bulat di bawah n yang merupakan gandaan sama ada A atau B; Berfungsi untuk mengembalikan jumlah semua bilangan bulat di bawah n yang merupakan gandaan sama ada A atau B; Jika saya adalah pelbagai A atau B; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; } int main ( ) { int n = 10 , a = 3 , b = 5 ; cout << findSum ( n , a , b ) ; return 0 ; }"}
{"text": "Kurangkan 1 tanpa pengendali aritmetik | Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } int main ( ) { printf ( \" % d \" , subtractOne ( 13 ) ) ; return 0 ; }"}
{"text": "Nombor Pell | Siri nombor Pell menggunakan rekursi dalam C ++; Hitung nombor pell; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; } int main ( ) { int n = 4 ; cout << \" ▁ \" << pell ( n ) ; return 0 ; }"}
{"text": "Mencari LCM lebih daripada dua (atau array) tanpa menggunakan GCD | Program C ++ untuk mencari LCM array tanpa menggunakan GCD. ; Mengembalikan LCM ARR [0 .. n - 1]; Cari nilai maksimum dalam ARR []; Memulakan hasil; Cari semua faktor yang terdapat dalam dua atau lebih elemen array. int x = 2; Faktor semasa. ; Untuk menyimpan indeks semua elemen array yang boleh dibahagikan dengan x. ; Sekiranya terdapat 2 atau lebih elemen array yang boleh dibahagikan dengan x. ; Kurangkan semua elemen array yang boleh dibahagikan dengan x. ; Kemudian kalikan semua elemen array yang dikurangkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long long int LCM ( int arr [ ] , int n ) { int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( max_num < arr [ i ] ) max_num = arr [ i ] ; unsigned long long int res = 1 ; while ( x <= max_num ) { vector < int > indexes ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] % x == 0 ) indexes . push_back ( j ) ; if ( indexes . size ( ) >= 2 ) { for ( int j = 0 ; j < indexes . size ( ) ; j ++ ) arr [ indexes [ j ] ] = arr [ indexes [ j ] ] / x ; res = res * x ; } else x ++ ; } for ( int i = 0 ; i < n ; i ++ ) res = res * arr [ i ] ; return res ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << LCM ( arr , n ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Cari kesopanan nombor | Program CPP untuk pendekatan di atas; Berfungsi untuk mencari kesopanan; sqrt (2 * n) sebagai panjang maksimum akan apabila jumlahnya bermula dari 1 yang mengikuti persamaan n ^ 2 - n - (2 * jumlah) = 0; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int politness ( int n ) { int count = 0 ; for ( int i = 2 ; i <= sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; } int main ( ) { int n = 90 ; cout << \" Politness ▁ of ▁ \" << n << \" ▁ = ▁ \" << politness ( n ) << \" STRNEWLINE \" ; n = 15 ; cout << \" Politness ▁ of ▁ \" << n << \" ▁ = ▁ \" << politness ( n ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Program untuk tekaan Goldbach (dua prima dengan jumlah yang diberikan) | C ++ Program untuk melaksanakan tekaan Goldbach; Array untuk menyimpan semua perdana kurang daripada dan sama dengan 10 ^ 6; Fungsi utiliti untuk Sieve of Sundaram; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahu prima yang lebih kecil daripada max, kita mengurangkan max hingga separuh array ini digunakan untuk memisahkan nombor bentuk i + j + 2 * i * j dari orang lain di mana 1 <= i <= j; Logik utama Sundaram. Tandakan semua nombor yang tidak menjana nombor perdana dengan melakukan 2 * i + 1; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Berfungsi untuk melakukan sangkaan Goldbach; Kembali jika nombor tidak atau kurang daripada 3; Semak hanya separuh daripada nombor; Cari perbezaan dengan menolak perdana semasa dari n; Cari jika perbezaannya juga merupakan nombor utama; Menyatakan sebagai jumlah prima; Kod pemacu; Mencari semua nombor perdana sebelum had; Nombor Ekspres sebagai Jumlah Dua Prima", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; vector < int > primes ; void sieveSundaram ( ) { bool marked [ MAX / 2 + 100 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; } void findPrimes ( int n ) { if ( n <= 2 n % 2 != 0 ) { cout << \" Invalid ▁ Input ▁ STRNEWLINE \" ; return ; } for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { int diff = n - primes [ i ] ; if ( binary_search ( primes . begin ( ) , primes . end ( ) , diff ) ) { cout << primes [ i ] << \" ▁ + ▁ \" << diff << \" ▁ = ▁ \" << n << endl ; return ; } } } int main ( ) { sieveSundaram ( ) ; findPrimes ( 4 ) ; findPrimes ( 38 ) ; findPrimes ( 100 ) ; return 0 ; }"}
{"text": "K | Program untuk mencetak faktor utama kth; Fungsi untuk menjana faktor utama nombor n dan mengembalikan faktor utama; Cari bilangan 2 yang membahagikan k; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, simpan saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes di mana n adalah nombor perdana yang lebih besar daripada 2; Program Pemandu", "code": "# include <bits/stdc++.h> NEW_LINE using namespace std ; int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return -1 ; } int main ( ) { int n = 12 , k = 3 ; cout << kPrimeFactor ( n , k ) << endl ; n = 14 , k = 3 ; cout << kPrimeFactor ( n , k ) << endl ; return 0 ; }"}
{"text": "K | Program C ++ untuk mencari faktor utama K - menggunakan SIEVE OF ERATOSTHENES. Program ini adalah cekap apabila kita mempunyai pelbagai nombor. ; Menggunakan Sieveoferatosthenes untuk mencari faktor utama terkecil semua nombor. Sebagai contoh, jika max adalah 10, s [2] = s [4] = s [6] = s [10] = 2 s [3] = s [9] = 3 s [5] = 5 s [7] = 7; Buat array Boolean \"Perdana [0.. Max]\" dan memulakan semua penyertaan di dalamnya sebagai palsu. ; Memulakan faktor terkecil sama dengan 2 untuk semua nombor walaupun; Untuk nombor ganjil kurang kemudian sama dengan n; S (i) untuk perdana adalah nombor itu sendiri; Untuk semua gandaan nombor perdana semasa; Saya adalah faktor utama terkecil untuk nombor \"i * j\". ; Berfungsi untuk menjana faktor utama dan mengembalikan faktor utama. S [i] menyimpan faktor utama i. ; Terus membahagikan n dengan faktor utama walaupun sama ada n tidak 1 atau kiraan faktor utama bukan k. ; Untuk menjejaki kiraan faktor utama; Bahagikan N untuk mencari faktor utama seterusnya; Program pemacu; S [i] akan menyimpan faktor utama i.", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10001 ; void sieveOfEratosthenes ( int s [ ] ) { vector < bool > prime ( MAX + 1 , false ) ; for ( int i = 2 ; i <= MAX ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= MAX ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= MAX ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } int kPrimeFactor ( int n , int k , int s [ ] ) { while ( n > 1 ) { if ( k == 1 ) return s [ n ] ; k -- ; n /= s [ n ] ; } return -1 ; } int main ( ) { int s [ MAX + 1 ] ; memset ( s , -1 , sizeof ( s ) ) ; sieveOfEratosthenes ( s ) ; int n = 12 , k = 3 ; cout << kPrimeFactor ( n , k , s ) << endl ; n = 14 , k = 3 ; cout << kPrimeFactor ( n , k , s ) << endl ; return 0 ; }"}
{"text": "Cari jumlah pembahagi semua pembahagi nombor semulajadi | Program C ++ untuk mencari jumlah pembahagi semua pembahagi nombor semulajadi. ; Mengembalikan jumlah pembahagi semua pembahagi N; Mengira kuasa faktor utama dan menyimpannya dalam MP MP []. ; Jika n adalah nombor perdana; Untuk setiap faktor utama, mengira (p ^ (a + 1) - 1) / (p - 1) dan menambahnya untuk menjawab. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumDivisorsOfDivisors ( int n ) { map < int , int > mp ; for ( int j = 2 ; j <= sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count ) mp [ j ] = count ; } if ( n != 1 ) mp [ n ] = 1 ; int ans = 1 ; for ( auto it : mp ) { int pw = 1 ; int sum = 0 ; for ( int i = it . second + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw *= it . first ; } ans *= sum ; } return ans ; } int main ( ) { int n = 10 ; cout << sumDivisorsOfDivisors ( n ) ; return 0 ; }"}
{"text": "Perdana terdekat yang kurang daripada bilangan N | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengembalikan nombor perdana terdekat; Semua nombor utama adalah ganjil kecuali dua; Ia hanya akan dilaksanakan apabila n adalah 3; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int prime ( int n ) { if ( n & 1 ) n -= 2 ; else n -- ; int i , j ; for ( i = n ; i >= 2 ; i -= 2 ) { if ( i % 2 == 0 ) continue ; for ( j = 3 ; j <= sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) break ; } if ( j > sqrt ( i ) ) return i ; } return 2 ; } int main ( ) { int n = 17 ; cout << prime ( n ) ; return 0 ; }"}
{"text": "Cari urutan berulang dalam pecahan | Program C ++ untuk mencari urutan berulang dalam pecahan; Fungsi ini mengembalikan urutan berulang pecahan. Jika mengulangi urutan tidak keluar, maka mengembalikan rentetan kosong; Buat peta untuk menyimpan sisa sisa sisa digunakan sebagai kunci dan kedudukannya dalam hasilnya disimpan sebagai nilai. Perhatikan bahawa kita memerlukan kedudukan untuk kes -kes seperti 1/6. Dalam kes ini, urutan berulang tidak bermula dari sisa pertama. ; Cari sisa pertama; Terus mencari baki sehingga sama ada baki menjadi 0 atau mengulangi; Simpan selebihnya ini; Kain baki dengan 10; Tambah REM / DENR untuk menghasilkan; Baki kemas kini; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string fractionToDecimal ( int numr , int denr ) { map < int , int > mp ; mp . clear ( ) ; int rem = numr % denr ; while ( ( rem != 0 ) && ( mp . find ( rem ) == mp . end ( ) ) ) { mp [ rem ] = res . length ( ) ; rem = rem * 10 ; int res_part = rem / denr ; res += to_string ( res_part ) ; rem = rem % denr ; } return ( rem == 0 ) ? \" \" : res . substr ( mp [ rem ] ) ; } int main ( ) { int numr = 50 , denr = 22 ; string res = fractionToDecimal ( numr , denr ) ; if ( res == \" \" ) cout << \" No ▁ recurring ▁ sequence \" ; else cout << \" Recurring ▁ sequence ▁ is ▁ \" << res ; return 0 ; }"}
{"text": "NOMBOR NOMBOR YANG MEMILIKI 0 A DENGIT | Program C ++ untuk mengira nombor dari 1 hingga n dengan 0 sebagai digit; Pulangan 1 jika x mempunyai 0, lain 0; Melintasi semua digit X untuk memeriksa sama ada ia mempunyai 0 .; Jika digit semasa adalah 0, kembali benar; Mengembalikan kiraan nombor dari 1 hingga n dengan 0 sebagai digit; Memulakan kiraan nombor yang mempunyai 0 sebagai digit; Melintasi semua nombor dan untuk setiap nombor cek jika ia mempunyai 0 .; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int has0 ( int x ) { while ( x ) { if ( x % 10 == 0 ) return 1 ; x /= 10 ; } return 0 ; } int getCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) count += has0 ( i ) ; return count ; } int main ( ) { int n = 107 ; cout << \" Count ▁ of ▁ numbers ▁ from ▁ 1\" << \" ▁ to ▁ \" << n << \" ▁ is ▁ \" << getCount ( n ) ; }"}
{"text": "Kriteria Euler (periksa jika akar persegi di bawah modulo p wujud) | Program C ++ yang mudah untuk memeriksa sama ada akar persegi nombor di bawah Modulo P wujud atau tidak; Pulangan benar jika akar persegi n di bawah modulo p wujud; Satu demi satu periksa semua nombor dari 2 hingga p - 1; Program Pemandu untuk Menguji", "code": "#include <iostream> NEW_LINE using namespace std ; bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; } int main ( ) { int p = 7 ; int n = 2 ; squareRootExists ( n , p ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }"}
{"text": "Formula Legendre (diberikan p dan n, cari x terbesar sedemikian rupa sehingga p^x membahagikan n!) | Program C ++ untuk mencari x terbesar sedemikian rupa sehingga p * x membahagikan n! ; Mengembalikan kuasa terbesar P yang membahagikan N! ; Memulakan hasil; Kirakan x = n / p + n / (p ^ 2) + n / (p ^ 3) + .... ; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int largestPower ( int n , int p ) { int x = 0 ; while ( n ) { n /= p ; x += n ; } return x ; } int main ( ) { int n = 10 , p = 3 ; cout << \" The ▁ largest ▁ power ▁ of ▁ \" << p << \" ▁ that ▁ divides ▁ \" << n << \" ! ▁ is ▁ \" << largestPower ( n , p ) << endl ; return 0 ; }"}
{"text": "Program untuk faktorial nombor | Program C ++ untuk mencari faktorial nombor yang diberikan; Baris tunggal untuk mencari faktorial; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; cout << \" Factorial ▁ of ▁ \" << num << \" ▁ is ▁ \" << factorial ( num ) ; return 0 ; }"}
{"text": "Semua tentang manipulasi bit | Berfungsi untuk mendapatkan bit pada kedudukan ITH; Kembali benar jika bit ditetapkan. Sebaliknya kembali palsu", "code": "boolean getBit ( int num , int i ) { return ( ( num & ( 1 << i ) ) != 0 ) ; }"}
{"text": "Semua tentang manipulasi bit | Berfungsi untuk membersihkan sedikit nombor n; Buat topeng untuk bit ith tidak teratur; Kembalikan nilai kemas kini", "code": "int clearBit ( int num , int i ) { int mask = ~ ( 1 << i ) ; return num & mask ; }"}
{"text": "Jumlah bitwise dan setiap elemen array dengan unsur -unsur array lain | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira dan jumlah untuk setiap elemen array; Mengisytiharkan pelbagai saiz 32 untuk menyimpan kiraan setiap bit; Melintasi array arr2 [] dan simpan kiraan sedikit dalam array kekerapan; Kedudukan bit semasa; Walaupun NUM lebih besar daripada 0; Memeriksa jika bit ith ditetapkan atau tidak; Kenaikan kiraan sedikit demi satu; Meningkatkan kedudukan bit oleh satu; Kanan beralih num oleh satu; Melintasi Arr2 []; Simpan nilai bit ith; Jumlah jumlah yang diperlukan; Melintasi julat [0, 31]; Cek jika bit semasa ditetapkan; Kenaikan jumlah bitwise dengan kekerapan [bit_position] * value_at_that_bit; ; Shift kanan dengan satu; Shift kiri vale_at_that_bit oleh satu; Cetak jumlah yang diperolehi untuk nombor ith di arr1 []; Kod pemacu; Diberikan arr1 []; Diberikan arr2 []; Saiz arr1 []; Saiz arr2 []; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Bitwise_AND_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { int frequency [ 32 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num ) { if ( num & 1 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_AND_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( num & 1 ) { bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } cout << bitwise_AND_sum << ' ▁ ' ; } return ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 3 } ; int arr2 [ ] = { 1 , 2 , 3 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int M = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) ; return 0 ; }"}
{"text": "Matikan Bit Set Bit | Tetapkan 2 | Program C ++ untuk menyegarkan bit set paling kanan; Tidak menetapkan bit set yang paling kanan dan mengembalikan hasilnya; Memeriksa sama ada kedudukan bit ditetapkan atau tidak; Jika kedudukan bit ditemui, kami flip sedikit ini dengan nombor dan nombor yang diberikan dengan set kedudukan bit; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) & 1 ) { n = n ^ ( 1ll << bit ) ; break ; } } cout << \" The ▁ number ▁ after ▁ unsetting ▁ the \" ; cout << \" ▁ rightmost ▁ set ▁ bit ▁ \" << n ; } int main ( ) { int N = 12 ; FlipBits ( N ) ; return 0 ; }"}
{"text": "Bitwise dan semua nombor ganjil dari 1 hingga n | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bitwise dan semua bilangan bulat ganjil dari julat [1, n]; Memulakan hasil kepada 1; Bermula dari 3, bitwise dan semua bilangan bulat ganjil kurang daripada atau sama dengan n; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } int main ( ) { int n = 10 ; cout << bitwiseAndOdd ( n ) ; return 0 ; }"}
{"text": "Bitwise dan semua nombor ganjil dari 1 hingga n | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bitwise dan semua bilangan bulat ganjil dari julat [1, n]; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int bitwiseAndOdd ( int n ) { return 1 ; } int main ( ) { int n = 10 ; cout << bitwiseAndOdd ( n ) ; return 0 ; }"}
{"text": "Bit sebenar bit nombor yang diberikan | C ++ pelaksanaan untuk membalikkan bit nombor; berfungsi untuk membalikkan bit nombor; melintasi bit 'n' dari kanan; Bitwise kiri Shift 'Rev' oleh 1; jika bit semasa ialah '1'; Bitwise kanan shift 'n' oleh 1; nombor yang diperlukan; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int reverseBits ( unsigned int n ) { unsigned int rev = 0 ; while ( n > 0 ) { rev <<= 1 ; if ( n & 1 == 1 ) rev ^= 1 ; n >>= 1 ; } return rev ; } int main ( ) { unsigned int n = 11 ; cout << reverseBits ( n ) ; return 0 ; }"}
{"text": "Cara untuk memecah array ke dalam dua kumpulan nilai XOR yang sama | Program CPP untuk mengira bilangan cara untuk memecah array ke dalam dua kumpulan supaya setiap kumpulan mempunyai nilai XOR yang sama; Kembalikan jumlah cara untuk memecah array ke dalam dua kumpulan supaya setiap kumpulan mempunyai nilai XOR yang sama. ; Kita boleh berpecah hanya jika XOR adalah 0. Oleh kerana XOR semua adalah 0, kita boleh mempertimbangkan semua subset sebagai satu kumpulan. ; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countgroup ( a , n ) << endl ; return 0 ; }"}
{"text": "Ekstrak 'k' bit dari kedudukan tertentu dalam nombor. | Program C ++ untuk mengekstrak k bit dari kedudukan tertentu. ; Berfungsi untuk mengekstrak k bit dari kedudukan p dan mengembalikan nilai yang diekstrak sebagai integer; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; } int main ( ) { int number = 171 , k = 5 , p = 2 ; cout << \" The ▁ extracted ▁ number ▁ is ▁ \" << bitExtracted ( number , k , p ) ; return 0 ; }"}
{"text": "Memaksimumkan nombor nombor yang tidak ditandatangani dengan menukar bit di kedudukan yang melampau. | Program C ++ untuk mencari nombor maksimum dengan menukar bit melampau. ; Melintasi bit dari kedua -dua ekstrem; Mendapatkan bit i - th dan j - th; Menukar bit jika lebih rendah penting adalah lebih besar daripada bit yang lebih tinggi dan dengan sewajarnya mengubah suai nombor; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ull  unsigned long long int NEW_LINE ull findMax ( ull num ) { ull num_copy = num ; int j = sizeof ( unsigned long long int ) * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; } int main ( ) { ull num = 4 ; cout << findMax ( num ) ; return 0 ; }"}
{"text": "Periksa dengan cekap sama ada n adalah pelbagai 4 atau tidak | C ++ pelaksanaan untuk memeriksa dengan cekap sama ada n adalah pelbagai 4 atau tidak; fungsi untuk memeriksa sama ada 'n' adalah pelbagai 4 atau tidak; jika benar, maka 'n' adalah pelbagai 4; lain 'n' bukanlah pelbagai 4; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string isAMultipleOf4 ( int n ) { if ( ( n & 3 ) == 0 ) return \" Yes \" ; return \" No \" ; } int main ( ) { int n = 16 ; cout << isAMultipleOf4 ( n ) ; return 0 ; }"}
{"text": "Kirakan persegi nombor tanpa menggunakan *, / dan pow () | Penyelesaian mudah untuk mengira persegi tanpa menggunakan * dan pow (); mengendalikan input negatif; Memulakan hasil; Tambah n ke res n - 1 kali; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; } int main ( ) { for ( int n = 1 ; n <= 5 ; n ++ ) cout << \" n ▁ = ▁ \" << n << \" , ▁ n ^ 2 ▁ = ▁ \" << square ( n ) << endl ; return 0 ; }"}
{"text": "Cari titik yang terletak di dalam Kuadrat yang tepat K yang diberikan | C ++ pelaksanaan pendekatan; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int PointInKSquares ( int n , int a [ ] , int k ) { sort ( a , a + n ) ; return a [ n - k ] ; } int main ( ) { int k = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int x = PointInKSquares ( n , a , k ) ; cout << \" ( \" << x << \" , ▁ \" << x << \" ) \" ; }"}
{"text": "Bilangan N digit Nombor Langkah | Penyelesaian Dioptimumkan Ruang | Program CPP untuk mengira bilangan nombor loncatan n digit. ; fungsi yang mengira jawapannya; DP [J] Kedai kiraan saya angka melangkah angka yang berakhir dengan digit j. ; Untuk menyimpan hasil panjang i - 1 sebelum mengemas kini dp [j] untuk panjang i. ; Jika n adalah 1 maka jawapannya akan menjadi 10 .; Memulakan nilai untuk mengira digit sama dengan 1 .; Mengira nilai untuk mengira digit lebih daripada 1 .; Jika angka berakhir adalah 0; Jika angka berakhir adalah 9; Untuk digit lain. ; menyimpan jawapan terakhir; program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long answer ( int n ) { int dp [ 10 ] ; int prev [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ; else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ; else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } } long long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; } int main ( ) { int n = 2 ; cout << answer ( n ) ; return 0 ; }"}
{"text": "Perubahan minimum diperlukan untuk membuat urutan Catalan | C ++ pelaksanaan pendekatan; Untuk menyimpan nombor N First N; Berfungsi untuk mencari nombor N Catalan pertama; Memulakan dua nilai pertama dalam jadual; Isi penyertaan di Catalan [] menggunakan formula rekursif; Berfungsi untuk mengembalikan perubahan minimum yang diperlukan; Cari nombor N Catalan pertama; A dan B adalah dua nombor urutan Catalan pertama; Masukkan unsur -unsur Catalan pertama untuk ditetapkan; Jika elemen Catalan hadir dalam array kemudian keluarkannya dari set; Kembalikan bilangan elemen dalam set; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100000 NEW_LINE #define ll  long long int NEW_LINE ll catalan [ MAX ] ; void catalanDP ( ll n ) { catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } int CatalanSequence ( int arr [ ] , int n ) { catalanDP ( n ) ; unordered_multiset < int > s ; int a = 1 , b = 1 ; int c ; s . insert ( a ) ; if ( n >= 2 ) s . insert ( b ) ; for ( int i = 2 ; i < n ; i ++ ) { s . insert ( catalan [ i ] ) ; } unordered_multiset < int > :: iterator it ; for ( int i = 0 ; i < n ; i ++ ) { it = s . find ( arr [ i ] ) ; if ( it != s . end ( ) ) s . erase ( it ) ; } return s . size ( ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 41 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CatalanSequence ( arr , n ) ; return 0 ; }"}
{"text": "Jumlah semua nombor komposit dari indeks ganjil array yang diberikan | C ++ pelaksanaan untuk mencari jumlah semua nombor komposit dari indeks ganjil array yang diberikan; Berfungsi untuk memeriksa nombor komposit; Periksa sama ada faktor lebih besar daripada 2; Semak sama ada nombor itu komposit atau tidak; Berfungsi untuk mencetak jumlah semua nombor komposit dalam array; Berulang untuk indeks ganjil dalam array; Semak sama ada nombor itu komposit kemudian tambahkannya ke jumlah; mengembalikan jumlahnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int composite ( int n ) { int flag = 0 ; int c = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( n % j == 0 ) { c += 1 ; } } if ( c >= 3 ) flag = 1 ; return flag ; } void odd_indices ( int arr [ ] , int n ) { int sum = 0 ; for ( int k = 0 ; k < n ; k += 2 ) { int check = composite ( arr [ k ] ) ; if ( check == 1 ) sum += arr [ k ] ; } cout << sum << endl ; } int main ( ) { int arr [ ] = { 13 , 5 , 8 , 16 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; odd_indices ( arr , n ) ; }"}
{"text": "Pertanyaan pada kiraan mata terletak di dalam bulatan | Program C ++ untuk mencari bilangan mata yang terletak di dalam atau di lilitan bulatan untuk pertanyaan Q. ; Pengkomputeran X ^ 2 + y ^ 2 untuk setiap titik yang diberikan dan menyusunnya. ; Kembali kiraan mata terletak di dalam atau pada lilitan bulatan menggunakan carian binari pada p [0. n - 1]; Program yang didorong; Kirakan jarak semua mata dan simpan jarak yang disusun supaya pertanyaan dapat berfungsi dalam O (logn) menggunakan carian binari. ; Cetak nombor mata dalam lingkaran radius 3 .; Cetak nombor mata dalam lingkaran radius 32.", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void preprocess ( int p [ ] , int x [ ] , int y [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( p , p + n ) ; } int query ( int p [ ] , int n , int rad ) { int start = 0 , end = n - 1 ; while ( ( end - start ) > 1 ) { int mid = ( start + end ) / 2 ; double tp = sqrt ( p [ mid ] ) ; if ( tp > ( rad * 1.0 ) ) end = mid - 1 ; else start = mid ; } double tp1 = sqrt ( p [ start ] ) , tp2 = sqrt ( p [ end ] ) ; if ( tp1 > ( rad * 1.0 ) ) return 0 ; else if ( tp2 <= ( rad * 1.0 ) ) return end + 1 ; else return start + 1 ; } int main ( ) { int x [ ] = { 1 , 2 , 3 , -1 , 4 } ; int y [ ] = { 1 , 2 , 3 , -1 , 4 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; int p [ n ] ; preprocess ( p , x , y , n ) ; cout << query ( p , n , 3 ) << endl ; cout << query ( p , n , 32 ) << endl ; return 0 ; }"}
{"text": "Count bilangan panjang n mempunyai nombor perdana pada indeks ganjil dan nombor ganjil pada indeks walaupun | C ++ program untuk mengira bilangan panjang n yang mempunyai nombor perdana pada indeks ganjil dan nombor ganjil pada indeks walaupun; berfungsi untuk mencari jumlah cara; Tiada indeks ganjil dalam nombor n - digit; Tidak ada indeks dalam nombor n - digit; Tidak ada cara untuk mengatur digit nombor utama dalam indeks ganjil; Tidak ada cara untuk mengatur digit nombor ganjil dalam indeks walaupun; mengembalikan jumlah cara; kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_Numb_ways ( int n ) { int odd_indices = n / 2 ; int even_indices = ( n / 2 ) + ( n % 2 ) ; int arr_odd = pow ( 4 , odd_indices ) ; int arr_even = pow ( 5 , even_indices ) ; return arr_odd * arr_even ; } int main ( ) { int n = 4 ; cout << find_Numb_ways ( n ) << endl ; return 0 ; }"}
{"text": "Semak jika array yang diberikan disusun secara lingkaran atau tidak | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk memeriksa sama ada array disusun secara rohani atau tidak; Kedai memulakan indeks array; Kedai akhir indeks array; Jika arr [mula] lebih besar daripada arr [end]; Kemas kini Mula; Jika arr [end] lebih besar daripada arr [start]; Akhir kemas kini; Kod pemacu; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; bool isSpiralSorted ( int arr [ ] , int n ) { int start = 0 ; int end = n - 1 ; while ( start < end ) { if ( arr [ start ] > arr [ end ] ) { return false ; } start ++ ; if ( arr [ end ] > arr [ start ] ) { return false ; } end -- ; } return true ; } int main ( ) { int arr [ ] = { 1 , 10 , 14 , 20 , 18 , 12 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSpiralSorted ( arr , N ) ) cout << \" YES \" << endl ; else cout << \" NO \" << endl ; return 0 ; }"}
{"text": "Cetak semua rentetan dari array yang diberikan yang boleh ditaip menggunakan kekunci dari satu baris papan kekunci QWERTY | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencetak semua rentetan yang boleh ditaip menggunakan kunci satu baris dalam papan kekunci QWERTY; Kedai baris nombor semua watak yang mungkin dari rentetan; Melintasi array; Jika rentetan semasa bukan rentetan kosong; Menetapkan benar / palsu jika rentetan boleh ditaip menggunakan kunci satu baris atau tidak; Kedai baris nombor watak pertama rentetan semasa; Kedai panjang perkataan; Melintasi rentetan semasa; Jika watak semasa tidak boleh ditaip menggunakan kekunci rownum sahaja; Bendera kemas kini; Jika rentetan semasa boleh ditaip menggunakan kekunci dari rownum sahaja; Cetak rentetan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWordsSameRow ( vector < string > & arr ) { unordered_map < char , int > mp { { ' q ' , 1 } , { ' w ' , 1 } , { ' e ' , 1 } , { ' r ' , 1 } , { ' t ' , 1 } , { ' y ' , 1 } , { ' u ' , 1 } , { ' o ' , 1 } , { ' p ' , 1 } , { ' i ' , 1 } , { ' a ' , 2 } , { ' s ' , 2 } , { ' d ' , 2 } , { ' f ' , 2 } , { ' g ' , 2 } , { ' h ' , 2 } , { ' j ' , 2 } , { ' k ' , 2 } , { ' l ' , 2 } , { ' z ' , 3 } , { ' x ' , 3 } , { ' c ' , 3 } , { ' v ' , 3 } , { ' b ' , 3 } , { ' n ' , 3 } , { ' m ' , 3 } } ; for ( auto word : arr ) { if ( ! word . empty ( ) ) { bool flag = true ; int rowNum = mp [ tolower ( word [ 0 ] ) ] ; int M = word . length ( ) ; for ( int i = 1 ; i < M ; i ++ ) { if ( mp [ tolower ( word [ i ] ) ] != rowNum ) { flag = false ; break ; } } if ( flag ) { cout << word << \" ▁ \" ; } } } } int main ( ) { vector < string > words = { \" Yeti \" , \" Had \" , \" GFG \" , \" comment \" } ; findWordsSameRow ( words ) ; }"}
{"text": "Kiraan quadruples jenis yang diberikan dari array yang diberikan | C ++ program pendekatan di atas; Fungsi untuk mencari kiraan jenis berikutnya; Menyimpan kiraan quadruples; Menjana semua kemungkinan kombinasi quadruples; Semak jika elemen 1 ST sama dengan elemen 3 RD; Semak jika elemen 2 ND adalah sama dengan elemen ke -4; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; const int maxN = 2002 ; int countSubsequece ( int a [ ] , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; } int main ( ) { int a [ 7 ] = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; cout << countSubsequece ( a , 7 ) ; return 0 ; }"}
{"text": "Watak terkecil dalam rentetan yang mempunyai jumlah minimum jarak antara pengulangan berturut -turut | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari watak berulang dengan jarak minimum; Menyimpan indeks pertama dan terakhir; Inisialisasi dengan - 1; Dapatkan nilai kejadian terakhir dan pertama; Mengemas kini indeks pertama; Mengemas kini indeks terakhir; Memulakan min; Dapatkan minimum; Nilai tidak boleh sama; Mengemas kini jarak minimum; kembali Ans; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; char minDistChar ( string s ) { int n = s . length ( ) ; int * first = new int [ 26 ] ; int * last = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( first [ s [ i ] - ' a ' ] == -1 ) { first [ s [ i ] - ' a ' ] = i ; } last [ s [ i ] - ' a ' ] = i ; } int min = INT_MAX ; char ans = '1' ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( last [ i ] == first [ i ] ) continue ; if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = i + ' a ' ; } } return ans ; } int main ( ) { string str = \" geeksforgeeks \" ; cout << minDistChar ( str ) ; return 0 ; }"}
{"text": "Langkah -langkah minimum yang diperlukan untuk mencapai akhir matriks | Tetapkan 2 | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan langkah minimum yang diperlukan untuk mencapai akhir matriks; Array untuk menentukan sama ada sel telah dikunjungi sebelum ini; Giliran untuk BFS; Memulakan giliran; Untuk menyimpan kedalaman carian; Algoritma BFS; Saiz giliran semasa; Atas - kebanyakan elemen barisan; Untuk menyimpan indeks sel untuk kesederhanaan; Kes asas; Jika kita mencapai (n - 1, n - 1); Menandakan sel yang dikunjungi; Menolak sel -sel bersebelahan dalam barisan yang boleh dikunjungi dari sel semasa; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE using namespace std ; int minSteps ( int arr [ ] [ n ] ) { bool v [ n ] [ n ] = { 0 } ; queue < pair < int , int > > q ; q . push ( { 0 , 0 } ) ; int depth = 0 ; while ( q . size ( ) != 0 ) { int x = q . size ( ) ; while ( x -- ) { pair < int , int > y = q . front ( ) ; int i = y . first , j = y . second ; q . pop ( ) ; if ( v [ i ] [ j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i ] [ j ] = 1 ; if ( i + arr [ i ] [ j ] < n ) q . push ( { i + arr [ i ] [ j ] , j } ) ; if ( j + arr [ i ] [ j ] < n ) q . push ( { i , j + arr [ i ] [ j ] } ) ; } depth ++ ; } return -1 ; } int main ( ) { int arr [ n ] [ n ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; cout << minSteps ( arr ) ; return 0 ; }"}
{"text": "Jurang terbesar dalam array | Program C ++ untuk mencari jurang terbesar antara dua elemen dalam array. ; fungsi untuk menyelesaikan masalah yang diberikan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int a [ ] , int n ) { int max1 = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , -4 , -10 , 22 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Largest ▁ gap ▁ is ▁ : ▁ \" << solve ( arr , size ) ; return 0 ; }"}
{"text": "Jurang terbesar dalam array | Program C ++ untuk mencari jurang terbesar antara dua elemen dalam array. ; fungsi untuk menyelesaikan masalah yang diberikan; mencari maksimum dan minimum array; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return abs ( min1 - max1 ) ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , 4 , -10 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Largest ▁ gap ▁ is ▁ : ▁ \" << solve ( arr , size ) ; return 0 ; }"}
{"text": "Cetak rentetan terbalik selepas mengeluarkan vokal | Program CPP untuk mengeluarkan aksara dari rentetan terbalik di mana vokal hadir dalam rentetan asal; Fungsi untuk menggantikan rentetan; memulakan rentetan panjang n; Melintasi semua aksara rentetan; Berikan nilai kepada rentetan r dari indeks terakhir rentetan s; jika S [i] adalah konsonan maka cetak r [i]; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void replaceOriginal ( string s , int n ) { string r ( n , ' ▁ ' ) ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != ' a ' && s [ i ] != ' e ' && s [ i ] != ' i ' && s [ i ] != ' o ' && s [ i ] != ' u ' ) { cout << r [ i ] ; } } cout << endl ; } int main ( ) { string s = \" geeksforgeeks \" ; int n = s . length ( ) ; replaceOriginal ( s , n ) ; return 0 ; }"}
{"text": "Semak jika rentetan boleh dibuat sama dengan rentetan lain dengan menukar atau penggantian aksara | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari jika rentetan yang diberikan adalah sama atau tidak; Keadaan asas; Kedai kekerapan aksara string str1 dan str2; Traverse Strings str1 & str2 dan frekuensi kedai dalam [] dan b []; Semak sama ada kedua -dua rentetan mempunyai aksara yang sama atau tidak; Jika watak hadir dalam satu rentetan dan tidak dalam rentetan lain, kembali palsu; Susun array A [] dan B []; Periksa Array A dan B mengandungi kekerapan yang sama atau tidak; Jika frekuensi tidak sama selepas menyusun; Pada ketika ini, Str1 boleh ditukar kepada Str2; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sameStrings ( string str1 , string str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N != M ) { return false ; } int a [ 256 ] = { 0 } , b [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { a [ str1 [ i ] - ' a ' ] ++ ; b [ str2 [ i ] - ' a ' ] ++ ; } int i = 0 ; while ( i < 256 ) { if ( ( a [ i ] == 0 && b [ i ] == 0 ) || ( a [ i ] != 0 && b [ i ] != 0 ) ) { i ++ ; } else { return false ; } } sort ( a , a + 256 ) ; sort ( b , b + 256 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( a [ i ] != b [ i ] ) return false ; } return true ; } int main ( ) { string S1 = \" cabbba \" , S2 = \" abbccc \" ; if ( sameStrings ( S1 , S2 ) ) cout << \" YES \" << endl ; else cout << \" ▁ NO \" << endl ; return 0 ; }"}
{"text": "Kurangkan tiga nombor dengan menurunkan pasangan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari operasi nombor minimum; Masukkan tiga nombor dalam array; Susun array; Kes 2; Kes 1; Kod pemacu; Diberikan a, b, c; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solution ( int A , int B , int C ) { int arr [ 3 ] ; arr [ 0 ] = A , arr [ 1 ] = B , arr [ 2 ] = C ; sort ( arr , arr + 3 ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; } int main ( ) { int A = 8 , B = 1 , C = 5 ; cout << solution ( A , B , C ) ; return 0 ; }"}
{"text": "Cari elemen dalam array yang disusun dan diputar dengan pendua | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan indeks kunci dalam arr [l. . h] jika kunci hadir sebaliknya kembali - 1; Kes yang rumit, hanya kemas kini kiri dan kanan; Jika arr [l ... pertengahan] disusun; Oleh kerana subarray ini disusun, kita dapat dengan cepat memeriksa sama ada kunci terletak pada mana -mana bahagian; Jika kunci tidak terletak pada separuh pertama subarray maka bahagikan separuh lagi ke dalam dua subarray sehingga kita dapat dengan cepat memeriksa apakah kunci terletak pada separuh lagi; Jika arr [l. . pertengahan] subarray pertama tidak disusun kemudian arr [pertengahan ... h] mesti disusun subarray; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { ++ l ; -- h ; return search ( arr , l , h , key ) ; } if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } int main ( ) { int arr [ ] = { 3 , 3 , 1 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int key = 3 ; cout << search ( arr , 0 , n - 1 , key ) ; return 0 ; }"}
{"text": "Kes | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang disusun; Vektor untuk menyimpan huruf kecil dan huruf besar; Menyusun kedua -dua vektor; Jika watak semasa adalah huruf kecil kemudian pilih watak huruf kecil dari senarai yang disusun; Lain memilih watak huruf besar; Kembalikan rentetan yang disusun; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string getSortedString ( string s , int n ) { vector < char > v1 , v2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) v1 . push_back ( s [ i ] ) ; if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) v2 . push_back ( s [ i ] ) ; } sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int i = 0 , j = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( s [ k ] >= ' a ' && s [ k ] <= ' z ' ) { s [ k ] = v1 [ i ] ; ++ i ; } else if ( s [ k ] >= ' A ' && s [ k ] <= ' Z ' ) { s [ k ] = v2 [ j ] ; ++ j ; } } return s ; } int main ( ) { string s = \" gEeksfOrgEEkS \" ; int n = s . length ( ) ; cout << getSortedString ( s , n ) ; return 0 ; }"}
{"text": "Semak jika rentetan mengandungi huruf berturut -turut dan setiap huruf berlaku tepat sekali | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk memeriksa sama ada keadaan memegang; Dapatkan panjang rentetan; Susun rentetan yang diberikan; ITERATE untuk setiap indeks dan periksa keadaan; Jika tidak berturut -turut; Kod pemacu; Contoh 1 st; Contoh 2 nd", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s ) { int l = s . length ( ) ; sort ( s . begin ( ) , s . end ( ) ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; } int main ( ) { string str = \" dcef \" ; if ( check ( str ) ) cout << \" Yes STRNEWLINE \" ; else cout << \" No STRNEWLINE \" ; str = \" xyza \" ; if ( check ( str ) ) cout << \" Yes STRNEWLINE \" ; else cout << \" No STRNEWLINE \" ; return 0 ; }"}
{"text": "Subset terkecil dengan jumlah yang lebih besar daripada semua elemen lain | Program CPP untuk mencari bilangan elemen minimum supaya jumlahnya lebih besar daripada jumlah unsur -unsur yang tersisa dari array. ; Fungsi untuk mencari elemen minimum yang diperlukan. ; mengira separuh daripada jumlah array; Susun array dalam urutan menurun. ; jumlah semasa lebih besar daripada jumlah; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; sort ( arr , arr + n , greater < int > ( ) ) ; int res = 0 , curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; } int main ( ) { int arr [ ] = { 3 , 1 , 7 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minElements ( arr , n ) << endl ; return 0 ; }"}
{"text": "Peningkatan dan penurunan minimum oleh k setiap elemen pasangan yang diperlukan untuk membuat semua elemen array sama | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada mungkin untuk membuat semua elemen array sama atau tidak; Menyimpan jumlah array; Melintasi array; Jika jumlahnya boleh dibahagikan dengan n; Jika tidak, tidak mungkin untuk membuat semua elemen array sama; Kod pemacu; Diberikan array; Saiz array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void arrayElementEqual ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum % N == 0 ) { cout << \" Yes \" ; } else { cout << \" No \" << endl ; } } int main ( ) { int arr [ ] = { 1 , 5 , 6 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; arrayElementEqual ( arr , N ) ; }"}
{"text": "Susun semula Arahan untuk memaksimumkan jumlah GCD unsur -unsur array dengan indeks masing -masing | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari jumlah maksimum GCD (arr [i], i) dengan menyusun semula array; Kedai maksimum jumlah GCD (arr [i], i) dengan menyusun semula elemen array; Kemas kini res; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxValByRearrArr ( int arr [ ] , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxValByRearrArr ( arr , N ) ; return 0 ; }"}
{"text": "Poligon dengan sisi maksimum yang boleh ditulis dalam N | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari poligon maksimum yang boleh ditulis; Kes asas; Kembali n / 2 jika n adalah sebaliknya, kembali - 1; Kod pemacu; Diberikan n; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaximumSides ( int n ) { if ( n < 4 ) return -1 ; return n % 2 == 0 ? n / 2 : -1 ; } int main ( ) { int N = 8 ; cout << MaximumSides ( N ) ; return 0 ; }"}
{"text": "Purata array yang dihasilkan oleh produk semua pasang array yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari min pasangan array arr []; Memulakan array jumlah akhiran; Membina array Jumlah Akhiran; Saiz pairproductarray; Kedai Jumlah PairProductArray; Simpan min; Cari min PairProductArray; Mengembalikan maksud yang dihasilkan; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float pairProductMean ( int arr [ ] , int N ) { int suffixSumArray [ N ] ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; } int length = ( N * ( N - 1 ) ) / 2 ; float res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; } float mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << fixed << setprecision ( 2 ) << pairProductMean ( arr , N ) ; return 0 ; }"}
{"text": "Kurangkan kiraan laluan unik dari kiri atas ke kanan bawah matriks dengan meletakkan k 1 s | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan nilai pekali binomial C (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Berfungsi untuk mencari kiraan minimum laluan dari kiri ke bawah ke bawah kanan dengan meletakkan k 1 s dalam matriks; Mengira cara tanpa 1 s; Mengira laluan dari titik permulaan ke titik pertengahan; Mengira laluan dari titik pertengahan ke titik akhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int ncr ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int countPath ( int N , int M , int K ) { int answer ; if ( K >= 2 ) answer = 0 ; else if ( K == 0 ) answer = ncr ( N + M - 2 , N - 1 ) ; else { answer = ncr ( N + M - 2 , N - 1 ) ; int X = ( N - 1 ) / 2 + ( M - 1 ) / 2 ; int Y = ( N - 1 ) / 2 ; int midCount = ncr ( X , Y ) ; X = ( ( N - 1 ) - ( N - 1 ) / 2 ) + ( ( M - 1 ) - ( M - 1 ) / 2 ) ; Y = ( ( N - 1 ) - ( N - 1 ) / 2 ) ; midCount *= ncr ( X , Y ) ; answer -= midCount ; } return answer ; } int main ( ) { int N = 3 ; int M = 3 ; int K = 1 ; cout << countPath ( N , M , K ) ; return 0 ; }"}
{"text": "Bilangan maksimum operasi yang diperlukan supaya tiada pasangan dari tumpang tindih matriks | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari kiraan maksimum operasi; Inisialisasi kiraan oleh 0; Melangkah ke atas pasangan yang tinggal; Semak jika operasi pertama terpakai; Semak jika operasi 2 ND terpakai; Jika tidak; Mengembalikan kiraan operasi; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_max ( vector < pair < int , int > > v , int n ) { int count = 0 ; if ( n >= 2 ) count = 2 ; else count = 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( v [ i - 1 ] . first < ( v [ i ] . first - v [ i ] . second ) ) count ++ ; else if ( v [ i + 1 ] . first > ( v [ i ] . first + v [ i ] . second ) ) { count ++ ; v [ i ] . first = v [ i ] . first + v [ i ] . second ; } else continue ; } return count ; } int main ( ) { int n = 3 ; vector < pair < int , int > > v ; v . push_back ( { 10 , 20 } ) ; v . push_back ( { 15 , 10 } ) ; v . push_back ( { 20 , 16 } ) ; cout << find_max ( v , n ) ; return 0 ; }"}
{"text": "Count substrings yang dibentuk menggunakan set aksara yang diberikan sahaja | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari bilangan substring yang boleh dibentuk menggunakan aksara yang diberikan; Array Boolean untuk menyimpan watak -watak yang tersedia; Tandakan indeks semua aksara yang tersedia sebagai 1; Memulakan lastpos sebagai - 1; Inisialisasi ANS dengan jumlah tidak mungkin substrings yang mungkin; Melintasi rentetan dari kiri ke kanan; Jika watak semasa tidak hadir dalam B; Tolak jumlah substrings yang mungkin; Kemas kini nilai LastPOS ke indeks semasa; Cetak jawapan terakhir; Kod pemacu; Diberikan rentetan; Diberikan pelbagai watak; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberofsubstrings ( string str , int k , char charArray [ ] ) { int N = str . length ( ) ; bool available [ 26 ] = { 0 } ; for ( int i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - ' a ' ] = 1 ; } int lastPos = -1 ; int ans = ( N * ( N + 1 ) ) / 2 ; for ( int i = 0 ; i < N ; i ++ ) { if ( available [ str [ i ] - ' a ' ] == 0 ) { ans -= ( ( i - lastPos ) * ( N - i ) ) ; lastPos = i ; } } cout << ans << endl ; } int main ( ) { string str = \" abcb \" ; int k = 2 ; char charArray [ k ] = { ' a ' , ' b ' } ; numberofsubstrings ( str , k , charArray ) ; return 0 ; }"}
{"text": "Kos minimum untuk mencapai titik n dari 0 dengan dua operasi yang berbeza dibenarkan | Pelaksanaan CPP pendekatan di atas; Berfungsi untuk mengembalikan kos minimum untuk mencapai tujuan; Memulakan kos kepada 0; pergi ke belakang sehingga kita mencapai kedudukan awal; Jika 2 * x melompat lebih baik daripada x + 1; Jika lompat x + 1 lebih baik; kos pulangan; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; } int main ( ) { int N = 9 , P = 5 , Q = 1 ; cout << minCost ( N , P , Q ) ; return 0 ; }"}
{"text": "Bilangan cara untuk mencapai pada node permulaan selepas perjalanan melalui tepi K dalam graf lengkap | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari bilangan cara untuk mencapai dari nod 1 hingga 1 sekali lagi, selepas bergerak tepat K tepi; Memulakan array dp [], di mana dp [i] menyimpan bilangan cara untuk mencapai nod; Memulakan array DP dengan 0; Kes asas; Berulang untuk bilangan tepi bergerak; Jumlah akan menyimpan beberapa cara untuk mencapai semua nod; Berulang untuk setiap keadaan yang mungkin untuk langkah semasa; Kemas kini nilai array DP selepas perjalanan setiap kelebihan; Cetak dp [0] sebagai jawapannya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberOfWays ( int n , int k ) { int dp [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { int numWays = 0 ; for ( int j = 0 ; j < n ; j ++ ) { numWays += dp [ j ] ; } for ( int j = 0 ; j < n ; j ++ ) { dp [ j ] = numWays - dp [ j ] ; } } cout << dp [ 0 ] << endl ; } int main ( ) { int N = 5 , K = 3 ; numberOfWays ( N , K ) ; return 0 ; }"}
{"text": "Kira penyahkodan mungkin urutan digit yang diberikan dengan aksara tersembunyi | Program C ++ untuk pendekatan di atas; Jika s [i] = = ' *' boleh ada 9 nilai yang mungkin *; Jika watak sebelumnya adalah 1 maka perkataan yang boleh dibentuk adalah k (11), l (12), m (13), n (14) o (15), p (16), q (17), r (18), s (19); Jika watak sebelumnya adalah 2 maka kata -kata yang boleh dibentuk ialah u (21), v (22), w (23), x (24) y (25), z (26); Jika digit sebelumnya * maka semua 15 2 - aksara digit boleh dibentuk; Jika s [i]! = ' *'; Menambah pertama di kedua jika s [i - 1] = 1; Menambah pertama dalam kedua jika s [i - 1] = = 2 dan s [i] <= '6'; Jika s [i - 1] = = ' *' Kesatuan di atas 2 kes perlu dilakukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int M = 1000000007 ; int waysOfDecoding ( string s ) { long first = 1 , second = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { long temp = second ; if ( s [ i ] == ' * ' ) { second = 9 * second ; if ( s [ i - 1 ] == '1' ) second = ( second + 9 * first ) % M ; else if ( s [ i - 1 ] == '2' ) second = ( second + 6 * first ) % M ; else if ( s [ i - 1 ] == ' * ' ) second = ( second + 15 * first ) % M ; } else { second = s [ i ] != '0' ? second : 0 ; if ( s [ i - 1 ] == '1' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == ' * ' ) second = ( second + ( s [ i ] <= '6' ? 2 : 1 ) * first ) % M ; } first = temp ; } return ( int ) second ; } int main ( ) { string s = \" * \" ; cout << waysOfDecoding ( s ) ; return 0 ; }"}
{"text": "Kos minimum membeli sekurang -kurangnya x coklat | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira kos minimum membeli coklat paling kurang x; Kes asas; Sertakan kotak i - th; Kecualikan kotak i - th; Mengembalikan minimum dua kes di atas; Kod pemacu; Diberikan array dan nilai x; Simpan saiz array; Cetak jawapannya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinCost ( pair < int , int > arr [ ] , int X , int n , int i = 0 ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return INT_MAX ; int inc = findMinCost ( arr , X - arr [ i ] . first , n , i + 1 ) ; if ( inc != INT_MAX ) inc += arr [ i ] . second ; int exc = findMinCost ( arr , X , n , i + 1 ) ; return min ( inc , exc ) ; } int main ( ) { pair < int , int > arr [ ] = { { 4 , 3 } , { 3 , 2 } , { 2 , 4 } , { 1 , 3 } , { 4 , 2 } } ; int X = 7 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int ans = findMinCost ( arr , X , n ) ; if ( ans != INT_MAX ) cout << ans ; else cout << -1 ; return 0 ; }"}
{"text": "Kebarangkalian bahawa jumlah semua nombor yang diperolehi membuang dadu n kali terletak di antara dua bilangan bulat yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira kebarangkalian bagi jumlah yang diberikan untuk menjadi sama dengan jumlah dalam n lontaran dadu; Kes asas; Kod pemacu; Cetak jawapannya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } long double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; long double probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }"}
{"text": "Langkah minimum untuk mengurangkan n hingga 0 dengan operasi yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari nombor minimum ke langkah untuk mengurangkan n hingga 0; Kes asas; Panggilan rekursif untuk mengira langkah minimum yang diperlukan; Kembalikan jawapannya; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; } int main ( ) { int N = 6 ; cout << minDays ( N ) ; return 0 ; }"}
