{"text": "Program untuk menukar sentimeter ke piksel | Berfungsi untuk menukar sentimeter ke piksel; Kod pemacu", "code": "def Conversion ( centi ) : NEW_LINE INDENT pixels = ( 96 * centi ) / 2.54 NEW_LINE print ( round ( pixels , 2 ) ) NEW_LINE DEDENT centi = 15 NEW_LINE Conversion ( centi ) NEW_LINE"}
{"text": "Elemen Arus KTH selepas penggantian elemen array oleh xor pasangan bersebelahan | Kaedah yang mengembalikan output yang sepadan dengan mengambil input yang diberikan. ; Jika keadaan ini berpuas hati, nilai m tidak sah; Semak sama ada indeks k adalah sah; Gelung untuk melaksanakan operasi M; Mewujudkan senarai sementara; Melintasi array; Mengira nilai XOR unsur -unsur bersebelahan; Menambah nilai ini ke senarai sementara; Kemas kini array asal; Mendapatkan nilai pada indeks k; Bilangan elemen; Diberikan array arr []; Panggilan fungsi", "code": "def xor_operations ( N , arr , M , K ) : NEW_LINE INDENT if M < 0 or M >= N : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if K < 0 or K >= N - M : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for _ in range ( M ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT value = arr [ i ] ^ arr [ i + 1 ] NEW_LINE temp . append ( value ) NEW_LINE DEDENT arr = temp [ : ] NEW_LINE DEDENT ans = arr [ K ] NEW_LINE return ans NEW_LINE DEDENT N = 5 NEW_LINE arr = [ 1 , 4 , 5 , 6 , 7 ] NEW_LINE M = 1 NEW_LINE K = 2 NEW_LINE print ( xor_operations ( N , arr , M , K ) ) NEW_LINE"}
{"text": "Semak jika n boleh dibahagikan kepada elemen K berturut -turut dengan jumlah yang sama dengan N | Fungsi untuk mencari unsur -unsur berturut -turut dengan jumlah yang sama dengan n; Melangkah ke atas [2, inf]; Simpan jumlahnya; Jika jumlah melebihi n maka pecahkan gelung; Perbezaan umum harus dibahagikan dengan bilangan istilah; Cetak nilai i & kembali; Cetak \" - 1\" jika tidak mungkin untuk memecahkan n; Diberikan n; Panggilan fungsi", "code": "def canBreakN ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT m = i * ( i + 1 ) // 2 NEW_LINE if ( m > n ) : NEW_LINE INDENT break NEW_LINE DEDENT k = n - m NEW_LINE if ( k % i ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( i ) NEW_LINE return NEW_LINE DEDENT print ( \" - 1\" ) NEW_LINE DEDENT N = 12 NEW_LINE canBreakN ( N ) NEW_LINE"}
{"text": "Pembahagi Coprime nombor | Program python3 untuk mencari dua pembahagi coprime nombor tertentu supaya kedua -duanya lebih besar daripada 1; Fungsi yang mendapati sepasang pembahagi n yang diperlukan; Kami melangkah sehingga sqrt (n) kerana kita dapat mencari semua pembahagi n pada masa ini; Jika x adalah pembahagi n terus membahagikan selagi mungkin; Kami telah menemui pasangan yang diperlukan; Tidak ada sepasang pembahagi n yang dijumpai, oleh itu cetak - 1; Contoh Contoh 1; Contoh Contoh 2", "code": "import math NEW_LINE def findCoprimePair ( N ) : NEW_LINE INDENT for x in range ( 2 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % x == 0 ) : NEW_LINE INDENT while ( N % x == 0 ) : NEW_LINE INDENT N //= x NEW_LINE DEDENT if ( N > 1 ) : NEW_LINE INDENT print ( x , N ) NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT print ( \" - 1\" ) NEW_LINE DEDENT N = 45 NEW_LINE findCoprimePair ( N ) NEW_LINE N = 25 NEW_LINE findCoprimePair ( N ) NEW_LINE"}
{"text": "Nombor Sisa | Program Python3 untuk pendekatan di atas; Array untuk menyimpan semua perdana kurang daripada dan sama dengan max. ; Fungsi untuk penapis Sundaram; Array Boolean; Tandakan semua nombor yang tidak menjana nombor perdana dengan 2 * i + 1; Oleh kerana 2 adalah nombor perdana; Cetak prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Fungsi yang pulih benar jika n adalah nombor yang membazir; Mengira digit dalam nombor asal; Kira semua digit dalam faktor utama N pdigit akan memegang nilai ini. ; Mengira kuasa p dalam n; Jika prima [i] adalah faktor utama ,; Mengira kuasa faktor utama; Tambah digitnya ke PDIGIT; Tambah digit kuasa faktor utama kepada pdigit. ; Jika n! = 1 maka satu faktor utama masih akan disimpulkan; Jika digit dalam faktor utama lebih daripada digit dalam nombor asal maka kembali benar. Lain kembali palsu. ; Berfungsi untuk mencetak nombor yang membazir sebelum n; Melepasi sehingga n dan periksa sama ada saya membazir atau tidak; Nombor Perdana Precompute sehingga 10 ^ 6; Panggilan fungsi", "code": "import math NEW_LINE MAX = 10000 NEW_LINE primes = [ ] NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * ( ( MAX // 2 ) + 1 ) NEW_LINE for i in range ( 1 , ( ( int ( math . sqrt ( MAX ) ) - 1 ) // 2 ) + 1 ) : NEW_LINE INDENT j = ( i * ( i + 1 ) ) << 1 NEW_LINE while j <= ( MAX // 2 ) : NEW_LINE INDENT marked [ j ] = True NEW_LINE j = j + 2 * i + 1 NEW_LINE DEDENT DEDENT primes . append ( 2 ) NEW_LINE for i in range ( 1 , ( MAX // 2 ) + 1 ) : NEW_LINE INDENT if marked [ i ] == False : NEW_LINE INDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT DEDENT DEDENT def isWasteful ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT original_no = n NEW_LINE sumDigits = 0 NEW_LINE while ( original_no > 0 ) : NEW_LINE INDENT sumDigits += 1 NEW_LINE original_no = original_no // 10 NEW_LINE DEDENT pDigit , count_exp , p = 0 , 0 , 0 NEW_LINE i = 0 NEW_LINE while ( primes [ i ] <= ( n // 2 ) ) : NEW_LINE INDENT while ( n % primes [ i ] == 0 ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE n = n // p NEW_LINE count_exp += 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT pDigit += 1 NEW_LINE p = p // 10 NEW_LINE DEDENT while ( count_exp > 1 ) : NEW_LINE INDENT pDigit += 1 NEW_LINE count_exp = count_exp // 10 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( n != 1 ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT pDigit += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT DEDENT return bool ( pDigit > sumDigits ) NEW_LINE DEDENT def Solve ( N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( isWasteful ( i ) ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT sieveSundaram ( ) NEW_LINE N = 10 NEW_LINE Solve ( N ) NEW_LINE"}
{"text": "Nombor Hexanacci | Berfungsi untuk mencetak nombor hexanacci nth; Kod pemacu", "code": "def printhexaRec ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 or \\ n == 2 or n == 3 or \\ n == 4 or n == 5 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n == 6 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) NEW_LINE DEDENT DEDENT def printhexa ( n ) : NEW_LINE INDENT print ( printhexaRec ( n ) ) NEW_LINE DEDENT n = 11 NEW_LINE printhexa ( n ) NEW_LINE"}
{"text": "Nombor Hexanacci | Berfungsi untuk mencetak istilah n nombor hexanacci; Memulakan lima nombor pertama untuk kes asas; mengisytiharkan pemboleh ubah semasa; Gelung untuk menambah lima nombor sebelumnya untuk setiap nombor bermula dari 5 dan kemudian berikan pertama, kedua, kedua, keempat kelima hingga kedua, ketiga, keempat, kelima dan curr masing -masing; Kod pemacu", "code": "def printhexa ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE third = 0 NEW_LINE fourth = 0 NEW_LINE fifth = 0 NEW_LINE sixth = 1 NEW_LINE curr = 0 NEW_LINE if ( n < 6 ) : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif ( n == 6 ) : NEW_LINE INDENT print ( sixth ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 6 , n ) : NEW_LINE INDENT curr = first + second + third + fourth + fifth + sixth NEW_LINE first = second NEW_LINE second = third NEW_LINE third = fourth NEW_LINE fourth = fifth NEW_LINE fifth = sixth NEW_LINE sixth = curr NEW_LINE DEDENT DEDENT print ( curr ) NEW_LINE DEDENT n = 11 NEW_LINE printhexa ( n ) NEW_LINE"}
{"text": "Cari nombor terkecil yang jumlah digitnya adalah n | Berfungsi untuk mencari nombor terkecil yang jumlah digit juga n; Kod pemacu", "code": "def smallestNumber ( N ) : NEW_LINE INDENT print ( ( N % 9 + 1 ) * pow ( 10 , ( N // 9 ) ) - 1 ) NEW_LINE DEDENT N = 10 NEW_LINE smallestNumber ( N ) NEW_LINE"}
{"text": "Kompositori Nombor | Fungsi untuk memeriksa sama ada nombor adalah komposit. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor tengah dalam gelung di bawah; Fungsi ini menyimpan semua nombor komposit kurang daripada n; Fungsi untuk mengira kompositori n; Multiply nombor komposit pertama N; Kod pemacu; Vektor untuk menyimpan semua komposit kurang daripada n", "code": "def isComposite ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT def Compositorial_list ( n ) : NEW_LINE INDENT l = 0 NEW_LINE for i in range ( 4 , 10 ** 6 ) : NEW_LINE INDENT if l < n : NEW_LINE INDENT if isComposite ( i ) : NEW_LINE INDENT compo . append ( i ) NEW_LINE l += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def calculateCompositorial ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = result * compo [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE compo = [ ] NEW_LINE Compositorial_list ( n ) NEW_LINE print ( calculateCompositorial ( n ) ) NEW_LINE DEDENT"}
{"text": "Kuasa yang berbeza dari nombor n supaya jumlahnya sama dengan k | Memulakan PowerArray dengan semua 0; Fungsi untuk mencari kuasa n yang menambah sehingga k; Memulakan kaunter; Melaksanakan gelung sementara sehingga k lebih besar daripada 0; Jika k % n == 1, maka array kuasa ditingkatkan dengan 1; Memeriksa jika ada kuasa yang berlaku lebih dari sekali; Untuk apa -apa nilai lain, jumlah kuasa tidak boleh ditambah sehingga k; Mencetak kuasa N yang merangkumi K; Kod pemacu", "code": "b = [ 0 for i in range ( 50 ) ] NEW_LINE def PowerArray ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE while ( k ) : NEW_LINE INDENT if ( k % n == 0 ) : NEW_LINE INDENT k //= n NEW_LINE count += 1 NEW_LINE DEDENT elif ( k % n == 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE b [ count ] += 1 NEW_LINE if ( b [ count ] > 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT for i in range ( 50 ) : NEW_LINE INDENT if ( b [ i ] ) : NEW_LINE INDENT print ( i , end = \" , \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE K = 40 NEW_LINE PowerArray ( N , K ) NEW_LINE DEDENT"}
{"text": "Program untuk mencari nilai 1 ^ k + 2 ^ k + 3 ^ k + ... + n ^ k | Program Python 3 Untuk mencari nilai 1 ^ K + 2 ^ K + 3 ^ K +. . + N ^ k; Fungsi untuk mencari nilai 1 ^ K + 2 ^ K + 3 ^ K +. . + N ^ k; INISIISE SUM kepada 0; Cari nilai POW (i, 4) dan kemudian tambahkannya ke jumlah; Mengembalikan jumlahnya; Kod pemacu; Fungsi panggilan untuk mencari jumlah", "code": "from math import pow NEW_LINE def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE k = 4 NEW_LINE print ( int ( findSum ( N , k ) ) ) NEW_LINE DEDENT"}
{"text": "Kira indeks dalam array yang memenuhi syarat yang diberikan | Berfungsi untuk mengembalikan kiraan indeks yang memenuhi syarat yang diberikan; Untuk menyimpan hasilnya; Untuk menyimpan maksimum semasa yang dimulakan ke 0 kerana hanya terdapat unsur -unsur positif dalam array; Saya adalah indeks yang sah; Mengemas kini maksimum setakat ini; Kenaikan kaunter; Kod pemacu", "code": "def countIndices ( arr , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE max = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max < arr [ i ] ) : NEW_LINE INDENT max = arr [ i ] ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countIndices ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Kekerapan maksimum modulo 2 i | Perwakilan binari digit; Berfungsi untuk mengembalikan kekerapan maksimum modulo S dengan kuasa 2; Simpan perwakilan binari; Tukar oktal ke binari; Keluarkan LSB; Sekiranya terdapat 1 dalam perwakilan binari; Cari bilangan sifar di antara dua 1 dalam perwakilan binari; Kod pemacu", "code": "bin = [ \"000\" , \"001\" , \"010\" , \"011\" , \"100\" , \"101\" , \"110\" , \"111\" ] ; NEW_LINE def maxFreq ( s ) : NEW_LINE INDENT binary = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT binary += bin [ ord ( s [ i ] ) - ord ( '0' ) ] ; NEW_LINE DEDENT binary = binary [ 0 : len ( binary ) - 1 ] ; NEW_LINE count = 1 ; prev = - 1 ; j = 0 ; NEW_LINE for i in range ( len ( binary ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( binary [ i ] == '1' ) : NEW_LINE INDENT count = max ( count , j - prev ) ; NEW_LINE prev = j ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT octal = \"13\" ; NEW_LINE print ( maxFreq ( octal ) ) ; NEW_LINE DEDENT"}
{"text": "Cari semua nombor utama nombor digit yang diberikan | Python 3 pelaksanaan pendekatan; Fungsi untuk penapis eratosthenes; Berfungsi untuk mencetak semua nombor utama dengan digit D; Julat untuk memeriksa bilangan bulat; Untuk setiap integer dalam julat; Jika integer semasa adalah perdana; Kod pemacu; Menjana prima", "code": "from math import sqrt , pow NEW_LINE sz = 100005 NEW_LINE isPrime = [ True for i in range ( sz + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( sqrt ( sz ) ) + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findPrimesD ( d ) : NEW_LINE INDENT left = int ( pow ( 10 , d - 1 ) ) NEW_LINE right = int ( pow ( 10 , d ) - 1 ) NEW_LINE for i in range ( left , right + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sieve ( ) NEW_LINE d = 1 NEW_LINE findPrimesD ( d ) NEW_LINE DEDENT"}
{"text": "Cari bilangan sel dalam jadual mengandungi x | Fungsi untuk mencari bilangan sel dalam jadual mengandungi x; Kod pemacu; Panggilan fungsi", "code": "def Cells ( n , x ) : NEW_LINE INDENT if ( n <= 0 or x <= 0 or x > n * n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT i = 1 NEW_LINE count = 0 NEW_LINE while ( i * i < x ) : NEW_LINE INDENT if ( x % i == 0 and x <= n * i ) : NEW_LINE INDENT count += 2 ; NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i * i == x ) : NEW_LINE INDENT return count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return count NEW_LINE DEDENT DEDENT n = 6 NEW_LINE x = 12 NEW_LINE print ( Cells ( n , x ) ) NEW_LINE"}
{"text": "Cari nilai maksimum nilai minimum array yang diubah suai | Berfungsi untuk mencari nilai maksimum nilai minimum array yang diubah suai; Untuk menyimpan nilai minimum array; Untuk menyimpan jumlah elemen array; Penyelesaian tidak mungkin; Zero adalah nilai yang mungkin; nilai minimum yang mungkin; nilai maksimum yang mungkin; untuk menyimpan jawapan yang diperlukan; Carian binari; Sekiranya pertengahan mungkin maka cuba tambah jawapan yang diperlukan; Jika pertengahan tidak mungkin maka penurunan jawapan yang diperlukan; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "def maxOfMin ( a , n , S ) : NEW_LINE INDENT mi = 10 ** 9 NEW_LINE s1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s1 += a [ i ] NEW_LINE mi = min ( a [ i ] , mi ) NEW_LINE DEDENT if ( s1 < S ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( s1 == S ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT low = 0 NEW_LINE high = mi NEW_LINE ans = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( s1 - ( mid * n ) >= S ) : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT a = [ 10 , 10 , 10 , 10 , 10 ] NEW_LINE S = 10 NEW_LINE n = len ( a ) NEW_LINE print ( maxOfMin ( a , n , S ) ) NEW_LINE"}
{"text": "Program untuk mencetak 'n' abjad menggunakan corak nombor dari 1 hingga n | Berfungsi untuk mencetak corak abjad n yang dikehendaki; Mengisytiharkan nilai -nilai hak, kiri dan pepenjuru; Gelung utama untuk baris; Untuk nilai kiri; Ruang untuk pepenjuru; Keadaan untuk pepenjuru; Ruang untuk nilai yang betul; Untuk nilai yang betul; Kod pemacu; Saiz corak; Memanggil fungsi untuk mencetak corak yang dikehendaki", "code": "def Alphabet_N_Pattern ( N ) : NEW_LINE INDENT Right = 1 NEW_LINE Left = 1 NEW_LINE Diagonal = 2 NEW_LINE for index in range ( N ) : NEW_LINE INDENT print ( Left , end = \" \" ) NEW_LINE Left += 1 NEW_LINE for side_index in range ( 0 , 2 * ( index ) , 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT if ( index != 0 and index != N - 1 ) : NEW_LINE INDENT print ( Diagonal , end = \" \" ) NEW_LINE Diagonal += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT for side_index in range ( 0 , 2 * ( N - index - 1 ) , 1 ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( Right , end = \" \" ) NEW_LINE Right += 1 NEW_LINE print ( \" \" , ▁ end ▁ = ▁ \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Size = 6 NEW_LINE Alphabet_N_Pattern ( Size ) NEW_LINE DEDENT"}
{"text": "Semak jika jumlah digit nombor n membahagikannya | Berfungsi untuk memeriksa sama ada jumlah digit nombor membahagikannya; Hitung jumlah semua digit N; Kod pemacu", "code": "def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE if ( isSumDivides ( N ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Jumlah nombor dari 1 hingga N yang boleh dibahagikan dengan 3 atau 4 | Berfungsi untuk mengira jumlah nombor yang boleh dibahagi dengan 3 atau 4;", "code": "def sum ( N ) : NEW_LINE INDENT global S1 , S2 , S3 NEW_LINE S1 = ( ( ( N // 3 ) ) * ( 2 * 3 + ( N // 3 - 1 ) * 3 ) // 2 ) NEW_LINE S2 = ( ( ( N // 4 ) ) * ( 2 * 4 + ( N // 4 - 1 ) * 4 ) // 2 ) NEW_LINE S3 = ( ( ( N // 12 ) ) * ( 2 * 12 + ( N // 12 - 1 ) * 12 ) // 2 ) NEW_LINE return int ( S1 + S2 - S3 ) NEW_LINE DEDENT / * Driver code * / NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( sum ( N ) ) NEW_LINE DEDENT"}
{"text": "Seterusnya nombor yang lebih besar daripada n dengan betul -betul sedikit berbeza dalam perwakilan binari n | Berfungsi untuk mencari nombor seterusnya yang lebih besar daripada n dengan tepat satu yang berbeza dalam perwakilan binari n; Ia dijamin bahawa terdapat sedikit sifar dalam nombor; Jika bit beralih adalah sifar maka pecah; meningkatkan peralihan sedikit; meningkatkan kuasa 2; Tetapkan bit paling rendah nombor; Kod pemacu; Paparkan nombor seterusnya", "code": "def nextGreater ( N ) : NEW_LINE INDENT power_of_2 = 1 ; NEW_LINE shift_count = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT shift_count += 1 ; NEW_LINE power_of_2 = power_of_2 * 2 ; NEW_LINE DEDENT return ( N + power_of_2 ) ; NEW_LINE DEDENT N = 11 ; NEW_LINE print ( \" The ▁ next ▁ number ▁ is ▁ = \" , nextGreater ( N ) ) ; NEW_LINE"}
{"text": "Mengira bilangan cara untuk menutup jarak | Tetapkan 2 | Berfungsi untuk mengembalikan kiraan jumlah cara untuk menutup jarak dengan 1, 2 dan 3 langkah; Keadaan asas; Untuk menyimpan tiga peringkat terakhir; Cari bilangan langkah yang diperlukan untuk mencapai jarak i; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "def countWays ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT f0 = 1 NEW_LINE f1 = 1 NEW_LINE f2 = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT ans = f0 + f1 + f2 NEW_LINE f0 = f1 NEW_LINE f1 = f2 NEW_LINE f2 = ans NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 4 NEW_LINE print ( countWays ( n ) ) NEW_LINE"}
{"text": "Memaksimumkan jumlah dengan memilih unsur -unsur dari bahagian yang berbeza dari matriks | Program Python3 untuk pendekatan di atas; Berfungsi untuk mencari nilai maksimum; Jadual DP; Isi DP secara bawah; Maksimum tiga bahagian; Maksimum bahagian pertama; Maksimum bahagian kedua; Maksimum bahagian ketiga; Jika kita memilih elemen dari Bahagian 1, kita tidak boleh mempunyai pemilihan dari bahagian yang sama di baris bersebelahan; Cetak jumlah maksimum; Kod pemacu", "code": "import numpy as np NEW_LINE n = 6 ; m = 6 ; NEW_LINE def maxSum ( arr ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , 3 ) ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m1 = 0 ; m2 = 0 ; m3 = 0 ; NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( ( j // ( m // 3 ) ) == 0 ) : NEW_LINE INDENT m1 = max ( m1 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT elif ( ( j // ( m // 3 ) ) == 1 ) : NEW_LINE INDENT m2 = max ( m2 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT elif ( ( j // ( m // 3 ) ) == 2 ) : NEW_LINE INDENT m3 = max ( m3 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; NEW_LINE dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; NEW_LINE DEDENT print ( max ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] ] ; NEW_LINE maxSum ( arr ) ; NEW_LINE DEDENT"}
{"text": "Jumlah Bilangan Panjang Panjang Panjang Panjang | Berfungsi untuk mencari jumlah sub - urutan panjang palindromik - urutan; Array DP untuk menyimpan bilangan seterusnya Palindromic untuk 0 hingga I - 1 dan J + 1 hingga N - 1; Kami akan bermula dengan jarak terbesar antara i dan j; Untuk setiap len, kami menetapkan saya; Untuk ini saya akan dapati J kami; Kes asas; Jika watak -wataknya sama maka cari indeks terikat; Kami hanya mempunyai 1 cara yang hanya memilih watak -watak ini; Sekiranya watak tidak sama; Kurangkannya kerana kami telah mengira dua kali; Kami hanya mempunyai 1 urutan palindrome panjang 1; Jumlah cara yang lain adalah jumlah DP [i - 1] [i + 1], iaitu bilangan subindrome sub - urutan dari 1 hingga i - 1 + bilangan subindrome sub - urutan dari i + 1 hingga n - 1; Kod pemacu", "code": "def solve ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for Len in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i + Len >= n : NEW_LINE INDENT break NEW_LINE DEDENT j = i + Len NEW_LINE if ( i == 0 and j == n - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( s [ i ] != s [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT if ( i - 1 >= 0 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j + 1 <= n - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i ] [ j + 1 ] NEW_LINE DEDENT if ( i - 1 < 0 or j + 1 >= n ) : NEW_LINE INDENT dp [ i ] [ j ] += 1 NEW_LINE DEDENT DEDENT elif ( s [ i ] != s [ j ] ) : NEW_LINE INDENT if ( i - 1 >= 0 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j + 1 <= n - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i ] [ j + 1 ] NEW_LINE DEDENT if ( i - 1 >= 0 and j + 1 <= n - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] -= dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT ways = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 or i == n - 1 ) : NEW_LINE INDENT ways . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT total = dp [ i - 1 ] [ i + 1 ] NEW_LINE ways . append ( total ) NEW_LINE DEDENT DEDENT for i in ways : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT s = \" xyxyx \" NEW_LINE solve ( s ) NEW_LINE"}
{"text": "Cari bilangan anak ayam di kebun binatang pada hari ke hari | Berfungsi untuk mengembalikan bilangan anak ayam pada hari ke hari; Saiz DP [] harus sekurang -kurangnya 6 (pengindeksan berasaskan 1 (1); Setiap hari penduduk semasa akan menjadi tiga kali pada hari sebelumnya; Nilai yang dikira secara manual; Dari hari ke -8 dan seterusnya; Penduduk anak ayam berkurangan sebanyak 2/3 setiap hari. Untuk hari ke -8 pada [i - 6] i. Populasi hari ke -2 adalah 3 dan jadi 2 orang baru dilahirkan pada hari ke -6 dan sebagainya untuk hari -hari yang akan datang; Kod pemacu", "code": "def getChicks ( n ) : NEW_LINE INDENT size = max ( n , 7 ) ; NEW_LINE dp = [ 0 ] * size ; NEW_LINE dp [ 0 ] = 0 ; NEW_LINE dp [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , 7 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] * 3 ; NEW_LINE DEDENT dp [ 6 ] = 726 ; NEW_LINE for i in range ( 8 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] // 3 ) ) * 3 ; NEW_LINE DEDENT return dp [ n ] ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( getChicks ( n ) ) ; NEW_LINE"}
{"text": "Cari bilangan anak ayam di kebun binatang pada hari ke hari | Berfungsi untuk mengembalikan bilangan anak ayam pada hari ke hari; Kod pemacu", "code": "def getChicks ( n ) : NEW_LINE INDENT chicks = pow ( 3 , n - 1 ) NEW_LINE return chicks NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( getChicks ( n ) ) NEW_LINE DEDENT"}
{"text": "Cari langkah minimum yang diperlukan untuk mencapai akhir matriks | Tetapkan 2 | Pelaksanaan Python3 pendekatan; Array 2d untuk menyimpan negeri -negeri DP; Array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Berfungsi untuk mengembalikan langkah minimum yang diperlukan; Kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula; Hubungan berulang; Kod pemacu", "code": "import numpy as np NEW_LINE n = 3 NEW_LINE dp = np . zeros ( ( n , n ) ) NEW_LINE v = np . zeros ( ( n , n ) ) ; NEW_LINE def minSteps ( i , j , arr ) : NEW_LINE INDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i > n - 1 or j > n - 1 ) : NEW_LINE INDENT return 9999999 ; NEW_LINE DEDENT if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT v [ i ] [ j ] = 1 ; NEW_LINE dp [ i ] [ j ] = 9999999 ; NEW_LINE for k in range ( max ( 0 , arr [ i ] [ j ] + j - n + 1 ) , min ( n - i - 1 , arr [ i ] [ j ] ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; NEW_LINE DEDENT dp [ i ] [ j ] += 1 ; NEW_LINE return dp [ i ] [ j ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 4 , 1 , 2 ] , [ 1 , 1 , 1 ] , [ 2 , 1 , 1 ] ] ; NEW_LINE ans = minSteps ( 0 , 0 , arr ) ; NEW_LINE if ( ans >= 9999999 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT DEDENT"}
{"text": "Cari langkah minimum yang diperlukan untuk mencapai akhir matriks | Set | Program Python3 untuk melaksanakan pendekatan di atas; Array 2d untuk menyimpan negeri -negeri DP; array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Berfungsi untuk mencari bilangan langkah minimum untuk mencapai akhir matriks; kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula. ; hubungan berulang; Kod pemacu", "code": "import numpy as np ; NEW_LINE n = 3 NEW_LINE dp = np . zeros ( ( n , n ) ) ; NEW_LINE v = np . zeros ( ( n , n ) ) ; NEW_LINE def minSteps ( i , j , arr ) : NEW_LINE INDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i > n - 1 or j > n - 1 ) : NEW_LINE INDENT return 9999999 ; NEW_LINE DEDENT if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT v [ i ] [ j ] = 1 ; NEW_LINE dp [ i ] [ j ] = 1 + min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; NEW_LINE return dp [ i ] [ j ] ; NEW_LINE DEDENT arr = [ [ 2 , 1 , 2 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ; NEW_LINE ans = minSteps ( 0 , 0 , arr ) ; NEW_LINE if ( ans >= 9999999 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT"}
{"text": "Treasure and Cities | Program berasaskan memoisasi untuk mencari harta maksimum yang boleh dikumpulkan. ; K ialah indeks semasa dan col adalah warna sebelumnya. ; Kes asas; Kami mempunyai dua pilihan sama ada melawat bandar semasa atau melangkauinya; Semak sama ada warna bandar ini sama dengan bandar yang dilawati sebelum ini; kembali maksimum kedua -dua pilihan; Kod pemacu", "code": "MAX = 1001 NEW_LINE dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE def MaxProfit ( treasure , color , n , k , col , A , B ) : NEW_LINE INDENT if ( k == n ) : NEW_LINE INDENT dp [ k ] [ col ] = 0 NEW_LINE return dp [ k ] [ col ] NEW_LINE DEDENT if ( dp [ k ] [ col ] != - 1 ) : NEW_LINE INDENT return dp [ k ] [ col ] NEW_LINE DEDENT summ = 0 NEW_LINE if ( col == color [ k ] ) : NEW_LINE INDENT summ += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT else : NEW_LINE INDENT summ += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT dp [ k ] [ col ] = summ NEW_LINE return dp [ k ] [ col ] NEW_LINE DEDENT A = - 5 NEW_LINE B = 7 NEW_LINE treasure = [ 4 , 8 , 2 , 9 ] NEW_LINE color = [ 2 , 2 , 6 , 2 ] NEW_LINE n = len ( color ) NEW_LINE print ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) NEW_LINE"}
{"text": "Nombor Tetranacci | Berfungsi untuk mencetak nombor tetranacci N - th; kes asas; Kod pemacu", "code": "def printTetra ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 5 ) ; NEW_LINE dp [ 0 ] = 0 ; NEW_LINE dp [ 1 ] = 1 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE dp [ 3 ] = 2 ; NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ) ; NEW_LINE DEDENT print ( dp [ n ] ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE printTetra ( n ) ; NEW_LINE"}
{"text": "Jumlah maksimum dalam array bulat supaya tiada dua elemen bersebelahan | Fungsi untuk mengira jumlah dari kedudukan ke -0 ke (n - 2) kedudukan; Salin elemen array asal ke dp []; Cari elemen maksimum dalam array; Mulakan dari 2 nd hingga n - 1 th pos; melintasi semua pendekatan berpasangan bawah; DP - keadaan; Cari jumlah maksimum; mengembalikan maksimum; Berfungsi untuk mencari jumlah maksimum dari kedudukan 1 ke kedudukan n - 1 - th; Melintasi dari ketiga ke n - th pos; pendekatan bootom - up; keadaan DP; Cari jumlah maksimum; kembali max; Kod pemacu", "code": "def maxSum1 ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE maxi = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE if ( maxi < arr [ i ] ) : NEW_LINE INDENT maxi = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 2 , n - 1 ) : NEW_LINE INDENT for j in range ( i - 1 ) : NEW_LINE INDENT if ( dp [ i ] < dp [ j ] + arr [ i ] ) : NEW_LINE INDENT dp [ i ] = dp [ j ] + arr [ i ] NEW_LINE if ( maxi < dp [ i ] ) : NEW_LINE INDENT maxi = dp [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxi NEW_LINE DEDENT def maxSum2 ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE maxi = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE if ( maxi < arr [ i ] ) : NEW_LINE INDENT maxi = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT for j in range ( 1 , i - 1 ) : NEW_LINE INDENT if ( dp [ i ] < arr [ i ] + dp [ j ] ) : NEW_LINE INDENT dp [ i ] = arr [ i ] + dp [ j ] NEW_LINE if ( maxi < dp [ i ] ) : NEW_LINE INDENT maxi = dp [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxi NEW_LINE DEDENT def findMaxSum ( arr , n ) : NEW_LINE INDENT return max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Koefisien Permutasi | Pulangan nilai pekali permutasi p (n, k); Hitung nilai pekali permutasi dengan cara bawah; Kes asas; Hitung nilai menggunakan nilai yang disimpan sebelumnya; Langkah ini penting kerana p (i, j) = 0 untuk j> i; Kod pemacu", "code": "def permutationCoeff ( n , k ) : NEW_LINE INDENT P = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT P [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = P [ i - 1 ] [ j ] + ( j * P [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT P [ i ] [ j + 1 ] = 0 NEW_LINE DEDENT DEDENT DEDENT return P [ n ] [ k ] NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE print ( \" Value ▁ fo ▁ P ( \" , n , \" , ▁ \" , k , \" ) ▁ is ▁ \" , permutationCoeff ( n , k ) , sep = \" \" ) NEW_LINE"}
{"text": "Koefisien Permutasi | Pulangan nilai pekali permutasi p (n, k); Kes asas; Hitung faktorial nilai sehingga n; P (n, k) = n! / (n - k)! ; Kod pemacu", "code": "def permutationCoeff ( n , k ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT return int ( fact [ n ] / fact [ n - k ] ) NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE print ( \" Value ▁ of ▁ P ( \" , n , \" , ▁ \" , k , \" ) ▁ is ▁ \" , permutationCoeff ( n , k ) , sep = \" \" ) NEW_LINE"}
{"text": "Pengaturcaraan Dinamik | Pulangan benar jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Kod pemacu", "code": "def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT"}
{"text": "Count of Cyclic Permutations yang mempunyai XOR dengan rentetan binari lain sebagai 0 | Pelaksanaan z - algoritma untuk corak corak masa linear; Berfungsi untuk mendapatkan kiraan permutasi kitaran B yang diberikan 0 apabila xored dengan a; Concatenate B dengan B; BARU B kini mengandungi semua permutasi kitaran Old B sebagai sub-string; corak concatenate dengan teks; Isi arus z yang digunakan dalam algoritma Z; Corak berlaku pada indeks i kerana nilai z sama dengan panjang corak; Kod pemacu", "code": "def compute_z ( s , z ) : NEW_LINE INDENT l = 0 NEW_LINE r = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( i > r ) : NEW_LINE INDENT l = i NEW_LINE r = i NEW_LINE while ( r < n and s [ r - l ] == s [ r ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT z [ i ] = r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = i - l NEW_LINE if ( z [ k ] < r - i + 1 ) : NEW_LINE INDENT z [ i ] = z [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT l = i NEW_LINE while ( r < n and s [ r - l ] == s [ r ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT z [ i ] = r - l NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def countPermutation ( a , b ) : NEW_LINE INDENT b = b + b NEW_LINE b = b [ 0 : len ( b ) - 1 ] NEW_LINE ans = 0 NEW_LINE s = a + \" $ \" + b NEW_LINE n = len ( s ) NEW_LINE z = [ 0 for i in range ( n ) ] NEW_LINE compute_z ( s , z ) NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( z [ i ] == len ( a ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \"101\" NEW_LINE b = \"101\" NEW_LINE print ( countPermutation ( a , b ) ) NEW_LINE DEDENT"}
{"text": "Lexicographically terkecil k | Berfungsi untuk mencari saiz ksatria terkecil secara lexicographically K; Panjang rentetan; Menyimpan berikutnya minimum; Melintasi rentetan s; Sekiranya timbunan kosong; Melangkah sehingga watak semasa kurang daripada watak di bahagian atas timbunan; Jika saiz timbunan adalah <k; Tolak watak semasa ke dalamnya; Menyimpan rentetan yang dihasilkan; Berulang sehingga timbunan kosong; Membalikkan rentetan; Cetak rentetan; Kod pemacu", "code": "def smallestSubsequence ( S , K ) : NEW_LINE INDENT N = len ( S ) NEW_LINE answer = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( len ( answer ) == 0 ) : NEW_LINE INDENT answer . append ( S [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( len ( answer ) > 0 and ( S [ i ] < answer [ len ( answer ) - 1 ] ) and ( len ( answer ) - 1 + N - i >= K ) ) : NEW_LINE INDENT answer = answer [ : - 1 ] NEW_LINE DEDENT if ( len ( answer ) == 0 or len ( answer ) < K ) : NEW_LINE INDENT answer . append ( S [ i ] ) NEW_LINE DEDENT DEDENT DEDENT ret = [ ] NEW_LINE while ( len ( answer ) > 0 ) : NEW_LINE INDENT ret . append ( answer [ len ( answer ) - 1 ] ) NEW_LINE answer = answer [ : - 1 ] NEW_LINE DEDENT ret = ret [ : : - 1 ] NEW_LINE ret = ' ' . join ( ret ) NEW_LINE print ( ret ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" aabdaabc \" NEW_LINE K = 3 NEW_LINE smallestSubsequence ( S , K ) NEW_LINE DEDENT"}
{"text": "Semak sama ada rentetan betul ke kiri pepenjuru atau tidak | Program python3 untuk memeriksa sama ada yang diberikan adalah hak untuk kiri pepenjuru atau tidak; Fungsi untuk memeriksa sama ada yang diberikan adalah hak untuk kiri pepenjuru atau tidak; Melangkah ke atas rentetan; Jika watak tidak sama dengan watak pertama maka kembali palsu; Kod pemacu; Diberikan string str; Panggilan fungsi", "code": "from math import sqrt , floor , ceil NEW_LINE def is_rtol ( s ) : NEW_LINE INDENT tmp = floor ( sqrt ( len ( s ) ) ) - 1 NEW_LINE first = s [ tmp ] NEW_LINE for pos in range ( tmp , len ( s ) - 1 , tmp ) : NEW_LINE INDENT if ( s [ pos ] != first ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abcxabxcaxbcxabc \" NEW_LINE if ( is_rtol ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Pecahkan rentetan yang diberikan ke dalam substrings panjang k dengan jumlah nilai ASCII yang sama | Fungsi untuk memeriksa rentetan; Semak sama ada rentetan boleh dibahagikan kepada substrings panjang K panjang sahaja; Kirakan jumlah substring pertama panjang k; Kirakan jumlah substrings yang tinggal; Semak sama ada jumlahnya sama dengan substring pertama; Oleh kerana semua jumlah tidak sama, kembali palsu; Semua jumlah adalah sama, kembali benar; Semua substrings tidak boleh bersaiz k; Kod pemacu", "code": "def check ( str , K ) : NEW_LINE INDENT if ( len ( str ) % K == 0 ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT sum += ord ( str [ i ] ) ; NEW_LINE DEDENT for j in range ( K , len ( str ) , K ) : NEW_LINE INDENT s_comp = 0 ; NEW_LINE for p in range ( j , j + K ) : NEW_LINE INDENT s_comp += ord ( str [ p ] ) ; NEW_LINE DEDENT if ( s_comp != sum ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT K = 3 ; NEW_LINE str = \" abdcbbdba \" ; NEW_LINE if ( check ( str , K ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan kiraan 0 s di kiri dan 1 s dalam substring kanan dengan memisahkan rentetan binari yang diberikan | Berfungsi untuk memaksimumkan jumlah kiraan sifar dan yang di dalam substring kiri dan kanan; Hitung jumlah yang ada di STR; Untuk menyimpan kiraan sifar dan yang melintasi rentetan; Melepasi dan mengemas kini jumlah maksimum; Mengemas kini jumlah maksimum; Kod pemacu; Diberikan rentetan binari; Panggilan fungsi", "code": "def maxSum ( str ) : NEW_LINE INDENT maximumSum = 0 NEW_LINE totalOnes = 0 NEW_LINE for i in str : NEW_LINE INDENT if i == '1' : NEW_LINE INDENT totalOnes += 1 NEW_LINE DEDENT DEDENT zero = 0 NEW_LINE ones = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT maximumSum = max ( maximumSum , zero + ( totalOnes - ones ) ) NEW_LINE i += 1 NEW_LINE DEDENT return maximumSum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"011101\" NEW_LINE print ( maxSum ( str ) ) NEW_LINE DEDENT"}
{"text": "Substring terpanjang supaya tidak ada tiga aksara berturut -turut yang sama | Berfungsi untuk mengembalikan panjang substring terpanjang sehingga tiada tiga aksara berturut -turut adalah sama; Jika panjang rentetan yang diberikan kurang daripada 3; Inisialisasi ANS sementara dan akhir hingga 2 kerana ini adalah panjang minimum substring apabila panjang rentetan yang diberikan lebih besar daripada 2; Melintasi rentetan dari watak ketiga ke yang terakhir; Jika tiada tiga aksara berturut -turut adalah sama maka kenaikan sementara sementara; Lain mengemas kini Ans akhir dan menetapkan semula kiraan sementara; Kod pemacu", "code": "def maxLenSubStr ( s ) : NEW_LINE INDENT if ( len ( s ) < 3 ) : NEW_LINE INDENT return len ( s ) NEW_LINE DEDENT temp = 2 NEW_LINE ans = 2 NEW_LINE for i in range ( 2 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] or s [ i ] != s [ i - 2 ] ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( temp , ans ) NEW_LINE temp = 2 NEW_LINE DEDENT DEDENT ans = max ( temp , ans ) NEW_LINE return ans NEW_LINE DEDENT s = \" baaabbabbb \" NEW_LINE print ( maxLenSubStr ( s ) ) NEW_LINE"}
{"text": "Bilangan cara untuk mengeluarkan sub | Fungsi untuk mengembalikan bilangan cara mengeluarkan sub -rentetan dari S sedemikian rupa sehingga semua aksara yang tinggal adalah sama; Untuk menyimpan kiraan awalan dan akhiran; Gelung untuk mengira awalan; Gelung untuk mengira akhiran; Watak pertama dan terakhir rentetan adalah sama; Jika tidak; Kod pemacu", "code": "def no_of_ways ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count_left = 0 NEW_LINE count_right = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ 0 ] ) : NEW_LINE INDENT count_left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == s [ n - 1 ] ) : NEW_LINE INDENT count_right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( s [ 0 ] == s [ n - 1 ] ) : NEW_LINE INDENT return ( ( count_left + 1 ) * ( count_right + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( count_left + count_right + 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( no_of_ways ( s ) ) NEW_LINE DEDENT"}
{"text": "Kira bilangan indeks seperti S [i] = s [i + 1]: pertanyaan pelbagai | Fungsi untuk membuat array awalan; Berfungsi untuk mengembalikan hasil pertanyaan; Kod pemacu; Pertanyaan 1; Pertanyaan 2", "code": "def preCompute ( n , s , pref ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] NEW_LINE if s [ i - 1 ] == s [ i ] : NEW_LINE INDENT pref [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def query ( pref , l , r ) : NEW_LINE INDENT return pref [ r ] - pref [ l ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ggggggg \" NEW_LINE n = len ( s ) NEW_LINE pref = [ 0 ] * n NEW_LINE preCompute ( n , s , pref ) NEW_LINE l = 1 NEW_LINE r = 2 NEW_LINE print ( query ( pref , l , r ) ) NEW_LINE l = 1 NEW_LINE r = 5 NEW_LINE print ( query ( pref , l , r ) ) NEW_LINE DEDENT"}
{"text": "Cari arah dari rentetan yang diberikan | Berfungsi untuk mencari arah akhir; Sekiranya kiraan positif yang membayangkan hasilnya adalah arah arah jam; Sekiranya kiraan negatif yang membayangkan hasilnya adalah arah anti jam; Kod pemacu", "code": "def findDirection ( s ) : NEW_LINE INDENT count = 0 NEW_LINE d = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' L ' ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( s [ i ] == ' R ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( count > 0 ) : NEW_LINE INDENT if ( count % 4 == 0 ) : NEW_LINE INDENT d = \" N \" NEW_LINE DEDENT elif ( count % 4 == 10 ) : NEW_LINE INDENT d = \" E \" NEW_LINE DEDENT elif ( count % 4 == 2 ) : NEW_LINE INDENT d = \" S \" NEW_LINE DEDENT elif ( count % 4 == 3 ) : NEW_LINE INDENT d = \" W \" NEW_LINE DEDENT DEDENT if ( count < 0 ) : NEW_LINE INDENT count *= - 1 NEW_LINE if ( count % 4 == 0 ) : NEW_LINE INDENT d = \" N \" NEW_LINE DEDENT elif ( count % 4 == 1 ) : NEW_LINE INDENT d = \" W \" NEW_LINE DEDENT elif ( count % 4 == 2 ) : NEW_LINE INDENT d = \" S \" NEW_LINE DEDENT elif ( count % 4 == 3 ) : NEW_LINE INDENT d = \" E \" NEW_LINE DEDENT DEDENT return d NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" LLRLRRL \" NEW_LINE print ( findDirection ( s ) ) NEW_LINE s = \" LL \" NEW_LINE print ( findDirection ( s ) ) NEW_LINE DEDENT"}
{"text": "Semak jika huruf kecil dan huruf besar berada dalam susunan yang sama | Fungsi untuk memeriksa sama ada kes itu mengikuti perintah yang sama; Melintasi rentetan; Simpan kedua -dua huruf kecil dan huruf besar dalam dua rentetan yang berbeza; transfor lowerstr ke huruf besar; Kod pemacu", "code": "def isCheck ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE lowerStr , upperStr = \" \" , \" \" NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( ord ( str [ i ] ) >= 65 and ord ( str [ i ] ) <= 91 ) : NEW_LINE INDENT upperStr = upperStr + str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT lowerStr = lowerStr + str [ i ] NEW_LINE DEDENT DEDENT transformStr = lowerStr . upper ( ) NEW_LINE return transformStr == upperStr NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeGkEEsKS \" NEW_LINE if isCheck ( str ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Cetak semua laluan pokok binari dengan elemen maksimum dalam setiap laluan yang lebih besar daripada atau sama dengan k | Nod pokok binari; Fungsi rekursif untuk mencetak laluan yang elemen maksimumnya lebih besar daripada atau sama dengan k. ; Jika nilai nod semasa lebih besar daripada atau sama dengan k, maka semua subtrees berikutan nod tersebut akan dicetak, bendera = 1 menunjukkan untuk mencetak jalan yang diperlukan; Jika nod daun ditemui, maka jalan dicetak jika saiz vektor laluan lebih besar daripada 0; Tambah nod ke vektor jalan; Mengulangi subtrees kiri dan kanan; Backtracking untuk mengembalikan vektor dan mencetak jalan jika bendera adalah 1; Fungsi untuk memulakan pembolehubah dan panggil fungsi utiliti untuk mencetak laluan dengan nilai maksimum lebih besar daripada atau sama dengan k; Memulakan bendera; Ans digunakan untuk memeriksa keadaan kosong; Fungsi panggilan yang mencetak jalan; Sekiranya jalan tidak wujud; Kod pemacu; Membina pokok berikut: 10 / \\ 5 8 / \\ / \\ 29 2 1 98 / \\ 20 50", "code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def findPathUtil ( root : Node , k : int , path : list , flag : int ) : NEW_LINE INDENT global ans NEW_LINE if root is None : NEW_LINE INDENT return NEW_LINE DEDENT if root . data >= k : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT if root . left is None and root . right is None : NEW_LINE INDENT if flag : NEW_LINE INDENT ans = 1 NEW_LINE print ( \" ( \" , end = \" \" ) NEW_LINE for i in range ( len ( path ) ) : NEW_LINE INDENT print ( path [ i ] , end = \" , ▁ \" ) NEW_LINE DEDENT print ( root . data , end = \" ) , ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT path . append ( root . data ) NEW_LINE findPathUtil ( root . left , k , path , flag ) NEW_LINE findPathUtil ( root . right , k , path , flag ) NEW_LINE path . pop ( ) NEW_LINE DEDENT def findPath ( root : Node , k : int ) : NEW_LINE INDENT global ans NEW_LINE flag = 0 NEW_LINE ans = 0 NEW_LINE v = [ ] NEW_LINE findPathUtil ( root , k , v , flag ) NEW_LINE if ans == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT ans = 0 NEW_LINE k = 25 NEW_LINE root = Node ( 10 ) NEW_LINE root . left = Node ( 5 ) NEW_LINE root . right = Node ( 8 ) NEW_LINE root . left . left = Node ( 29 ) NEW_LINE root . left . right = Node ( 2 ) NEW_LINE root . right . right = Node ( 98 ) NEW_LINE root . right . left = Node ( 1 ) NEW_LINE root . right . right . right = Node ( 50 ) NEW_LINE root . left . left . left = Node ( 20 ) NEW_LINE findPath ( root , k ) NEW_LINE DEDENT"}
{"text": "Nombor TrideCagonal | Berfungsi untuk mencari nombor tridecagonal n; Formula untuk mengira nombor tridecagonal nth; Kod pemacu", "code": "def Tridecagonal_num ( n ) : NEW_LINE INDENT return ( 11 * n * n - 9 * n ) / 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( Tridecagonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Tridecagonal_num ( n ) ) ) NEW_LINE"}
{"text": "Bilangan bilangan bulat n digit dengan berat w | Berfungsi untuk mencari jumlah nombor yang mungkin dengan digit dan berat w; Apabila berat integer positif; Tolak berat dari 9; Apabila berat integer adalah negatif; Tambah berat badan kepada 10 untuk menjadikannya positif; bilangan digit dalam integer dan w sebagai berat; Cetak jumlah nombor yang mungkin dengan N digit dan berat w", "code": "def findNumbers ( n , w ) : NEW_LINE INDENT x = 0 ; NEW_LINE sum = 0 ; NEW_LINE if ( w >= 0 and w <= 8 ) : NEW_LINE INDENT x = 9 - w ; NEW_LINE DEDENT elif ( w >= - 9 and w <= - 1 ) : NEW_LINE INDENT x = 10 + w ; NEW_LINE DEDENT sum = pow ( 10 , n - 2 ) ; NEW_LINE sum = ( x * sum ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE w = 4 ; NEW_LINE print ( findNumbers ( n , w ) ) ; NEW_LINE"}
{"text": "Ketinggian maksimum susunan segi tiga nilai array | Program Python untuk mencari ketinggian maksimum susunan piramida nilai array; Hanya memeriksa sama ada tahap ith mungkin atau tidak jika mungkin maka kita mesti mempunyai atleast (i * (i + 1)) / 2 elemen dalam array; mengemas kini nilai hasil setiap kali; Jika tidak, kita telah melebihi nilai n; Kod pemacu", "code": "def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) / 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE"}
{"text": "K | Kod python3 untuk mencari elemen k - tH dalam urutan ganjil - walaupun. ; Masukkan semua nombor ganjil dari 1 hingga n. ; Masukkan semua nombor dari 1 hingga n. ; Kod pemacu", "code": "def findK ( n , k ) : NEW_LINE INDENT a = list ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT a . append ( i ) NEW_LINE i = i + 2 NEW_LINE DEDENT i = 2 NEW_LINE while i < n : NEW_LINE INDENT a . append ( i ) NEW_LINE i = i + 2 NEW_LINE DEDENT return ( a [ k - 1 ] ) NEW_LINE DEDENT n = 10 NEW_LINE k = 3 NEW_LINE print ( findK ( n , k ) ) NEW_LINE"}
{"text": "Satu fungsi baris untuk faktorial nombor | Program python3 untuk mencari faktorial nombor yang diberikan; Baris tunggal untuk mencari faktorial; Kod pemacu", "code": "def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) ; NEW_LINE DEDENT num = 5 ; NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) ; NEW_LINE"}
{"text": "Nombor Pell | Hitung nombor pell; fungsi pemacu", "code": "def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = 2 * b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT n = 4 NEW_LINE print ( pell ( n ) ) NEW_LINE"}
{"text": "Cara yang cekap untuk memeriksa sama ada N | Pulangan benar jika nombor fibonacci n - th adalah berganda dari 10 .; Kod pemacu", "code": "def isMultipleOf10 ( n ) : NEW_LINE INDENT return ( n % 15 == 0 ) NEW_LINE DEDENT n = 30 NEW_LINE if ( isMultipleOf10 ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"text": "Cari kesopanan nombor | Fungsi untuk mengira semua faktor utama ganjil nombor n; Menghapuskan semua faktor utama bilangan n; n mesti ganjil pada ketika ini, jadi berulang hanya untuk nombor ganjil sehingga sqrt (n); Jika saya membahagikan N, maka mula mengira pembahagi ganjil; Jika n yang ganjil masih kekal maka hitungnya; Program pemacu untuk menguji fungsi di atas", "code": "def countOddPrimeFactors ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i <= n : NEW_LINE INDENT divCount = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n /= i NEW_LINE divCount = divCount + 1 NEW_LINE DEDENT result = result * divCount + 1 NEW_LINE i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT result = result * 2 NEW_LINE DEDENT return result NEW_LINE DEDENT def politness ( n ) : NEW_LINE INDENT return countOddPrimeFactors ( n ) - 1 ; NEW_LINE DEDENT n = 90 NEW_LINE print \" Politness ▁ of ▁ \" , n , \" ▁ = ▁ \" , politness ( n ) NEW_LINE n = 15 NEW_LINE print \" Politness ▁ of ▁ \" , n , \" ▁ = ▁ \" , politness ( n ) NEW_LINE"}
{"text": "Perdana terdekat yang kurang daripada bilangan N | Program Python3 untuk mencari perdana terdekat kepada n. ; array untuk menyimpan semua prima kurang daripada 10 ^ 6; Fungsi utiliti penapis Sundaram; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x; Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j; menghapuskan indeks yang tidak menghasilkan prima; Oleh kerana 2 adalah nombor perdana; Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Carian binari yang diubah suai untuk mencari perdana terdekat kurang daripada n; Keadaan asas adalah, jika kita sampai di sudut kiri atau sudut kanan prima [] array kemudian kembali elemen sudut kerana sebelum atau selepas itu kita tidak mempunyai sebarang nombor utama dalam array prima; Sekarang jika N sendiri menjadi perdana jadi ia akan hadir dalam pelbagai prima dan di sini kita perlu mencari perdana terdekat yang kurang daripada n supaya kita akan mengembalikan prima [pertengahan - 1]; Sekarang jika prima [pertengahan] <n dan prima [pertengahan + 1]> n itu bermakna kita sampai pada perdana terdekat; Kod pemacu", "code": "import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def Sieve ( ) : NEW_LINE INDENT n = MAX ; NEW_LINE nNew = int ( math . sqrt ( n ) ) ; NEW_LINE marked = [ 0 ] * ( int ( n / 2 + 500 ) ) ; NEW_LINE for i in range ( 1 , int ( ( nNew - 1 ) / 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( ( i * ( i + 1 ) ) << 1 ) , ( int ( n / 2 ) + 1 ) , ( 2 * i + 1 ) ) : NEW_LINE INDENT marked [ j ] = 1 ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def binarySearch ( left , right , n ) : NEW_LINE INDENT if ( left <= right ) : NEW_LINE INDENT mid = int ( ( left + right ) / 2 ) ; NEW_LINE if ( mid == 0 or mid == len ( primes ) - 1 ) : NEW_LINE INDENT return primes [ mid ] ; NEW_LINE DEDENT if ( primes [ mid ] == n ) : NEW_LINE INDENT return primes [ mid - 1 ] ; NEW_LINE DEDENT if ( primes [ mid ] < n and primes [ mid + 1 ] > n ) : NEW_LINE INDENT return primes [ mid ] ; NEW_LINE DEDENT if ( n < primes [ mid ] ) : NEW_LINE INDENT return binarySearch ( left , mid - 1 , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( mid + 1 , right , n ) ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT Sieve ( ) ; NEW_LINE n = 17 ; NEW_LINE print ( binarySearch ( 0 , len ( primes ) - 1 , n ) ) ; NEW_LINE"}
{"text": "Program untuk faktorial nombor | Fungsi untuk mencari faktorial nombor yang diberikan; Kod pemacu", "code": "def factorial ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT num = 5 ; NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"}
{"text": "Matikan Bit Set Bit | Tetapkan 2 | Tidak menetapkan bit set yang paling kanan dan mengembalikan hasilnya; Kod pemacu", "code": "def FlipBits ( n ) : NEW_LINE INDENT n -= ( n & ( - n ) ) ; NEW_LINE return n ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 ; NEW_LINE print ( \" The ▁ number ▁ after ▁ unsetting ▁ the \" , end = \" \" ) ; NEW_LINE print ( \" ▁ rightmost ▁ set ▁ bit : ▁ \" , FlipBits ( N ) ) ; NEW_LINE DEDENT"}
{"text": "Nilai maksimum XOR di antara semua tiga kali ganda array | berfungsi untuk mengira nilai XOR maksimum untuk triplet; Set digunakan untuk mengelakkan pengulangan; Simpan semua kemungkinan nilai XOR yang unik; menyimpan nilai maksimum; Kod pemacu", "code": "def Maximum_xor_Triplet ( n , a ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT s . add ( a [ i ] ^ a [ j ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in s : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT ans = max ( ans , i ^ a [ j ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 3 , 8 , 15 ] NEW_LINE n = len ( a ) NEW_LINE Maximum_xor_Triplet ( n , a ) NEW_LINE DEDENT"}
{"text": "Cari unsur -unsur yang hilang dari julat | Perpustakaan Python untuk Carian Perduaan; Cetak semua elemen julat [rendah, tinggi] yang tidak hadir dalam arr [0 .. n - 1]; Lakukan pencarian binari untuk 'rendah' ​​dalam array yang disusun dan cari indeks elemen pertama yang sama sama dengan atau lebih besar daripada rendah. ; Mulakan dari indeks yang dijumpai dan cari secara linear setiap elemen julat x selepas indeks ini di arr []; Jika x tidak matematik dengan elemen semasa mencetaknya; Jika x sepadan, pindah ke elemen seterusnya dalam arr []; Bergerak ke elemen seterusnya dalam julat [rendah, tinggi]; Elemen pelbagai cetak thar lebih besar daripada elemen terakhir array yang disusun. ; Kod pemacu", "code": "from bisect import bisect_left NEW_LINE def printMissing ( arr , n , low , high ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ptr = bisect_left ( arr , low ) NEW_LINE index = ptr NEW_LINE i = index NEW_LINE x = low NEW_LINE while ( i < n and x <= high ) : NEW_LINE INDENT if ( arr [ i ] != x ) : NEW_LINE INDENT print ( x , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT while ( x <= high ) : NEW_LINE INDENT print ( x , end = \" ▁ \" ) NEW_LINE x = x + 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE low = 1 NEW_LINE high = 10 NEW_LINE printMissing ( arr , n , low , high ) ; NEW_LINE"}
{"text": "Cari unsur -unsur yang hilang dari julat | Cetak semua elemen julat [rendah, tinggi] yang tidak hadir dalam arr [0 .. n - 1]; Buat Senarai Boolean Saiz Tinggi - Rendah + 1, Setiap Indeks I Mewakili Elemen TH Wether (I + Rendah) Ditemui atau tidak. ; Sekiranya elemen ARR berada dalam jarak rendah hingga tinggi maka tandakan indeks yang sepadan sebagai benar dalam array; Melintasi julat dan mencetak semua elemen yang nilainya palsu; Kod pemacu", "code": "def printMissing ( arr , n , low , high ) : NEW_LINE INDENT points_of_range = [ False ] * ( high - low + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( low <= arr [ i ] and arr [ i ] <= high ) : NEW_LINE INDENT points_of_range [ arr [ i ] - low ] = True NEW_LINE DEDENT DEDENT for x in range ( high - low + 1 ) : NEW_LINE INDENT if ( points_of_range [ x ] == False ) : NEW_LINE INDENT print ( low + x , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 3 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE low , high = 1 , 10 NEW_LINE printMissing ( arr , n , low , high ) NEW_LINE"}
{"text": "Cari unsur -unsur yang hilang dari julat | Cetak semua elemen julat [rendah, tinggi] yang tidak hadir dalam arr [0 .. n - 1]; Masukkan semua elemen ARR [] dalam set; Melintasi julat dan mencetak semua elemen yang hilang; Kod pemacu", "code": "def printMissing ( arr , n , low , high ) : NEW_LINE INDENT s = set ( arr ) NEW_LINE for x in range ( low , high + 1 ) : NEW_LINE INDENT if x not in s : NEW_LINE INDENT print ( x , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 3 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE low , high = 1 , 10 NEW_LINE printMissing ( arr , n , low , high ) NEW_LINE"}
{"text": "K | Mengembalikan elemen k - yang hilang. Ia kembali - 1 jika tiada k adalah lebih daripada bilangan elemen yang hilang. ; Masukkan semua elemen urutan yang diberikan B []. ; Melintasi urutan yang semakin meningkat dan menjejaki jumlah nombor yang hilang. ; Kod pemacu", "code": "def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if a [ i ] not in s : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if missing == k : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT a = [ 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 ] NEW_LINE b = [ 4 , 10 , 6 , 8 , 12 ] NEW_LINE n1 = len ( a ) NEW_LINE n2 = len ( b ) NEW_LINE k = 3 NEW_LINE print ( find ( a , b , k , n1 , n2 ) ) NEW_LINE"}
{"text": "Kurangkan langkah -langkah untuk membentuk rentetan s dari rentetan rawak panjang K menggunakan Panjang Tetap Panjang | '' Fungsi untuk mencari bilangan minimum rentetan yang diperlukan untuk menjana rentetan asal; '' Menyimpan kekerapan setiap watak rentetan s; '' Menyimpan kekerapan setiap watak rentetan s; '' Mengira watak -watak yang unik dalam s; '' Jika watak unik lebih besar maka n, maka kembali -1; '' Sebaliknya; '' Melakukan carian binari; '' Cari nilai pertengahan; '' Melangkah ke atas julat [0, 26]; '' Jika jumlah [i] lebih besar daripada 0; '' Kemas kini julat; '' Cari rentetan yang dihasilkan; Menjana berikutnya; '' U u u u u u u u u u u u u u u u u u »» '' '' '' '' '' ' '' Cetak rentetan; '' Kod pemandu", "code": "def findString ( S , N ) : NEW_LINE INDENT amounts = [ 0 ] * 26 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT amounts [ ord ( S [ i ] ) - 97 ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if amounts [ i ] > 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count > N : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = \" \" NEW_LINE high = 100001 NEW_LINE low = 0 NEW_LINE while ( high - low ) > 1 : NEW_LINE INDENT total = 0 NEW_LINE mid = ( high + low ) // 2 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if amounts [ i ] > 0 : NEW_LINE INDENT total += ( amounts [ i ] - 1 ) // mid + 1 NEW_LINE DEDENT DEDENT if total <= N : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid NEW_LINE DEDENT DEDENT print ( high , end = \" ▁ \" ) NEW_LINE total = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if amounts [ i ] > 0 : NEW_LINE INDENT total += ( amounts [ i ] - 1 ) // high + 1 NEW_LINE for j in range ( ( amounts [ i ] - 1 ) // high + 1 ) : NEW_LINE INDENT ans += chr ( i + 97 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( total , N ) : NEW_LINE INDENT ans += ' a ' NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT S = \" toffee \" NEW_LINE K = 4 NEW_LINE findString ( S , K ) NEW_LINE"}
{"text": "Cari elemen berulang pertama dalam pelbagai integer | Fungsi ini mencetak elemen berulang pertama dalam arr []; Memulakan indeks elemen berulang pertama; Mewujudkan hashset kosong; Melintasi array input dari kanan ke kiri; Jika elemen sudah ada dalam hash set, kemas kini min; Lain tambah elemen ke hash set; Cetak hasilnya; Kod pemacu", "code": "def printFirstRepeating ( arr , n ) : NEW_LINE INDENT Min = - 1 NEW_LINE myset = dict ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in myset . keys ( ) : NEW_LINE INDENT Min = i NEW_LINE DEDENT else : NEW_LINE INDENT myset [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if ( Min != - 1 ) : NEW_LINE INDENT print ( \" The ▁ first ▁ repeating ▁ element ▁ is \" , arr [ Min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" There ▁ are ▁ no ▁ repeating ▁ elements \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printFirstRepeating ( arr , n ) NEW_LINE"}
{"text": "Cari elemen berulang pertama dalam pelbagai integer | Fungsi ini mencetak elemen berulang pertama dalam arr []; Ini akan menetapkan k = 1, jika ada elemen berulang yang dijumpai; max = maksimum dari (semua elemen & n); Array A adalah untuk menyimpan 1 masa yang berlaku pada elemen yang diasaskan oleh 0; Simpan 1 dalam array b Jika elemen adalah pendua yang diasaskan oleh 0; Elemen pendua yang dijumpai; Menyimpan 1 st kejadian arr [i]; Trace Array A & Cari Elemen Berulang dengan Min Index; Kod pemacu", "code": "def printFirstRepeating ( arr , n ) : NEW_LINE INDENT k = 0 NEW_LINE max = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max < arr [ i ] ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT a = [ 0 for i in range ( max + 1 ) ] NEW_LINE b = [ 0 for i in range ( max + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ arr [ i ] ] ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 NEW_LINE k = 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT a [ arr [ i ] ] = i NEW_LINE DEDENT DEDENT if ( k == 0 ) : NEW_LINE INDENT print ( \" No ▁ repeating ▁ element ▁ found \" ) NEW_LINE DEDENT else : NEW_LINE INDENT min = max + 1 NEW_LINE for i in range ( max + 1 ) : NEW_LINE INDENT if ( a [ i ] and ( min > ( a [ i ] ) ) and b [ i ] ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT print ( arr [ min ] ) NEW_LINE DEDENT DEDENT arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printFirstRepeating ( arr , n ) NEW_LINE"}
{"text": "K | Mengembalikan elemen yang berbeza dalam arr. ; Semak jika elemen semasa hadir di tempat lain. ; Jika elemen adalah unik; Kod pemacu", "code": "def printKDistinct ( arr , n , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ( i != j and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE k = 2 NEW_LINE print ( printKDistinct ( ar , n , k ) ) NEW_LINE"}
{"text": "Count Subarrays mempunyai kiraan yang sama dengan 0 dan 1 S berasal | '' Fungsi untuk mengira subarray yang mempunyai kiraan yang sama dengan 0s dan 1s dengan semua 0s dan semua 1s dikumpulkan bersama; '' Menyimpan kiraan; '' Inisialisasi dengan elemen pertama; '' Jika elemen seterusnya adalah sama dengan elemen semasa; '' Kiraan kenaikan; '' Kemas kini Curr; '' Melangkah ke atas kiraan array; '' Pertimbangkan minimum;  ; '' Diberikan arr []; '' Panggilan fungsi", "code": "def countSubarrays ( A ) : NEW_LINE INDENT res = 0 NEW_LINE curr , cnt = A [ 0 ] , [ 1 ] NEW_LINE for c in A [ 1 : ] : NEW_LINE INDENT if c == curr : NEW_LINE INDENT cnt [ - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT curr = c NEW_LINE DEDENT cnt . append ( 1 ) NEW_LINE DEDENT for i in range ( 1 , len ( cnt ) ) : NEW_LINE INDENT res += min ( cnt [ i - 1 ] , cnt [ i ] ) NEW_LINE DEDENT print ( res - 1 ) NEW_LINE DEDENT / * Driver code * / NEW_LINE A = [ 1 , 1 , 0 , 0 , 1 , 0 ] NEW_LINE countSubarrays ( A ) NEW_LINE"}
{"text": "Semak jika pokok binari adalah walaupun | '' Nod pokok; '' Fungsi untuk mengembalikan nod pokok baru; '' Fungsi untuk memeriksa sama ada pokok itu adalah pokok ganjil; '' Kedai nod setiap peringkat; '' Simpan tahap semasa pokok binari; '' Melintasi sehingga barisan kosong; '' Menyimpan bilangan nod yang terdapat di peringkat semasa; '' Periksa sama ada tahapnya atau ganjil; '' Tambah nod tahap seterusnya ke dalam barisan; '' Meningkatkan kiraan tahap; '' Kod pemandu; '' Membina pokok binari; '' Periksa sama ada pokok binari adalah pokok ganjil atau tidak", "code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . left = None NEW_LINE self . right = None NEW_LINE self . val = data NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT temp = Node ( data ) NEW_LINE return temp NEW_LINE DEDENT def isEvenOddBinaryTree ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE level = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT size = len ( q ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT node = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( level % 2 == 0 ) : NEW_LINE INDENT if ( node . val % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( level % 2 == 1 ) : NEW_LINE INDENT if ( node . val % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( node . left != None ) : NEW_LINE INDENT q . append ( node . left ) NEW_LINE DEDENT if ( node . right != None ) : NEW_LINE INDENT q . append ( node . right ) NEW_LINE DEDENT DEDENT level += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = None NEW_LINE root = newNode ( 2 ) NEW_LINE root . left = newNode ( 3 ) NEW_LINE root . right = newNode ( 9 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 10 ) NEW_LINE root . right . right = newNode ( 6 ) NEW_LINE if ( isEvenOddBinaryTree ( root ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Memaksimumkan jarak minimum antara pengulangan dari sebarang permutasi array yang diberikan | Program Python3 untuk melaksanakan pendekatan di atas; Saiz array; Menyimpan kekerapan elemen array; Cari kekerapan tertinggi dalam array; Meningkatkan kiraan elemen maksimum; Sekiranya tiada pengulangan hadir; Cari jarak maksimum; Mengembalikan jarak maksimum; Kod pemacu", "code": "import sys NEW_LINE def findMaxLen ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE freq = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT maxFreqElement = - sys . maxsize - 1 NEW_LINE maxFreqCount = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( freq [ i ] > maxFreqElement ) : NEW_LINE INDENT maxFreqElement = freq [ i ] NEW_LINE maxFreqCount = 1 NEW_LINE DEDENT elif ( freq [ i ] == maxFreqElement ) : NEW_LINE INDENT maxFreqCount += 1 NEW_LINE DEDENT DEDENT if ( maxFreqElement == 1 ) : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( ( n - maxFreqCount ) // ( maxFreqElement - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 1 , 2 , 1 , 2 ] NEW_LINE print ( findMaxLen ( a ) ) NEW_LINE"}
{"text": "Pertanyaan untuk menilai persamaan yang diberikan dalam julat [l, r] | Program Python3 untuk melaksanakan pendekatan di atas; Berfungsi untuk mendapatkan indeks pertengahan julat; Fungsi rekursif untuk mendapatkan jumlah nilai dalam julat yang diberikan dari array. Berikut adalah parameter untuk fungsi ini. st. Penunjuk ke nod pokok segmen. Indeks nod semasa dalam segmen pokok SS & SE. Memulakan dan mengakhiri indeks segmen yang diwakili oleh nod semasa, i. e. , St [nod] L & R. Memulakan dan mengakhiri indeks pertanyaan pelbagai; Jika segmen nod ini terletak sepenuhnya dalam julat yang diberikan; Pulangan maksimum dalam segmen; Jika segmen nod ini terletak di luar julat yang diberikan; Jika segmen nod ini terletak sebahagiannya dalam julat yang diberikan; Berfungsi untuk mengembalikan maksimum dalam julat dari [L, R]; Semak nilai input yang salah; Berfungsi untuk pokok consegment untuk subarray [ss. . se]; Untuk satu elemen; Jika tidak; Berulang untuk subtree kiri; Berulang untuk subtree yang betul; Berfungsi untuk pokok consegment dari array yang diberikan; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan; Mengembalikan pokok segmen yang dibina; Kod pemacu; Bina pokok segmen dari array yang diberikan", "code": "import math NEW_LINE def getMid ( s , e ) : NEW_LINE INDENT return ( s + ( e - s ) // 2 ) NEW_LINE DEDENT def MaxUtil ( st , ss , se , l , r , node ) : NEW_LINE INDENT if ( l <= ss and r >= se ) : NEW_LINE INDENT return st [ node ] NEW_LINE DEDENT if ( se < l or ss > r ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) NEW_LINE DEDENT def getMax ( st , n , l , r ) : NEW_LINE INDENT if ( l < 0 or r > n - 1 or l > r ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) NEW_LINE DEDENT def constructSTUtil ( arr , ss , se , st , si ) : NEW_LINE INDENT if ( ss == se ) : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE return arr [ ss ] NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE st [ si ] = max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) NEW_LINE return st [ si ] NEW_LINE DEDENT def constructST ( arr , n ) : NEW_LINE INDENT x = ( int ) ( math . ceil ( math . log ( n ) ) ) NEW_LINE max_size = 2 * ( int ) ( pow ( 2 , x ) ) - 1 NEW_LINE st = [ 0 ] * max_size NEW_LINE constructSTUtil ( arr , 0 , n - 1 , st , 0 ) NEW_LINE return st NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE st = constructST ( arr , n ) NEW_LINE Q = [ [ 1 , 3 ] , [ 0 , 2 ] ] NEW_LINE for i in range ( len ( Q ) ) : NEW_LINE INDENT Max = getMax ( st , n , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) NEW_LINE ok = 0 NEW_LINE for j in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT if ( ( Max & ( 1 << j ) ) != 0 ) : NEW_LINE INDENT ok = 1 NEW_LINE DEDENT if ( ok <= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT Max |= ( 1 << j ) NEW_LINE DEDENT print ( Max , end = \" ▁ \" ) NEW_LINE DEDENT"}
{"text": "Cari bilangan pasangan dalam array supaya XOR mereka adalah 0 | Fungsi untuk mengira kiraan; Menyusun senarai menggunakan fungsi terbina; Melintasi unsur -unsur; Mengira frequncy setiap elemen; Menambah sumbangan kekerapan kepada jawapannya; Kod pemacu; Cetak kiraan", "code": "def calculate ( a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE count = 1 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE count = 1 NEW_LINE DEDENT DEDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 1 , 2 , 4 ] NEW_LINE print ( calculate ( a ) ) NEW_LINE DEDENT"}
{"text": "Cari bilangan pasangan dalam array supaya XOR mereka adalah 0 | Berfungsi untuk mengira jawapannya; Mencari maksimum array; Mewujudkan array frekuensi dengan nilai awal 0; Melintasi array; Kekerapan mengira; Melintasi pelbagai frekuensi; Mengira jawapan; Kod pemacu; Fungsi panggilan", "code": "def calculate ( a ) : NEW_LINE INDENT maximum = max ( a ) NEW_LINE frequency = [ 0 for x in range ( maximum + 1 ) ] NEW_LINE for i in a : NEW_LINE INDENT frequency [ i ] += 1 NEW_LINE DEDENT answer = 0 NEW_LINE for i in frequency : NEW_LINE INDENT answer = answer + i * ( i - 1 ) // 2 NEW_LINE DEDENT return answer NEW_LINE DEDENT a = [ 1 , 2 , 1 , 2 , 4 ] NEW_LINE print ( calculate ( a ) ) NEW_LINE"}
{"text": "Subarray terbesar dengan bilangan yang sama 0 s dan 1 s | Fungsi ini mencetak indeks permulaan dan akhir subarray terbesar dengan bilangan yang sama 0 s dan 1 s. Juga mengembalikan saiz subarray tersebut. ; Pilih titik permulaan seperti saya; Pertimbangkan semua subarrays bermula dari i; Jika ini adalah subarray 0 jumlah, maka bandingkan dengan subarray saiz maksimum yang dikira setakat ini; Program pemacu untuk menguji fungsi di atas", "code": "def findSubArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxsize = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT sum = - 1 if ( arr [ i ] == 0 ) else 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 NEW_LINE if ( sum == 0 and maxsize < j - i + 1 ) : NEW_LINE INDENT maxsize = j - i + 1 NEW_LINE startindex = i NEW_LINE DEDENT DEDENT DEDENT if ( maxsize == - 1 ) : NEW_LINE INDENT print ( \" No ▁ such ▁ subarray \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( startindex , \" to \" , startindex + maxsize - 1 ) ; NEW_LINE DEDENT return maxsize NEW_LINE DEDENT arr = [ 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE findSubArray ( arr , size ) NEW_LINE"}
{"text": "Elemen maksimum dalam array yang disusun dan diputar | Berfungsi untuk mengembalikan elemen maksimum; Sekiranya terdapat hanya satu elemen yang tersisa; Cari pertengahan; Semak jika pertengahan mencapai 0, ia lebih besar daripada elemen seterusnya atau tidak; Periksa sama ada pertengahan sendiri adalah elemen maksimum; Tentukan sama ada kita perlu pergi ke separuh kiri atau separuh kanan; Kod pemacu", "code": "def findMax ( arr , low , high ) : NEW_LINE INDENT if ( high == low ) : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid == 0 and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( mid < high and arr [ mid + 1 ] < arr [ mid ] and mid > 0 and arr [ mid ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( arr [ low ] > arr [ mid ] ) : NEW_LINE INDENT return findMax ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMax ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT arr = [ 6 , 5 , 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMax ( arr , 0 , n - 1 ) ) NEW_LINE"}
{"text": "Carian Ternary | Berfungsi untuk melakukan carian ternary; Cari Mid1 dan Mid2; Semak jika kunci berada di mana -mana pertengahan; Oleh kerana kunci tidak hadir pada pertengahan, periksa di mana rantau ia hadir kemudian ulangi operasi carian di rantau itu; kunci terletak di antara L dan MID1; Kunci terletak di antara MID2 dan R; Kunci terletak di antara Mid1 dan Mid2; kunci tidak dijumpai; Dapatkan senarai menyusun senarai jika tidak disusun; Indeks permulaan; Panjang senarai; Kunci untuk dicari dalam senarai; Cari kunci menggunakan carian ternary; Cetak hasilnya; Kunci untuk dicari dalam senarai; Cari kunci menggunakan carian ternary; Cetak hasilnya", "code": "def ternarySearch ( l , r , key , ar ) : NEW_LINE INDENT while r >= l : NEW_LINE INDENT mid1 = l + ( r - l ) // 3 NEW_LINE mid2 = r - ( r - l ) // 3 NEW_LINE if key == ar [ mid1 ] : NEW_LINE INDENT return mid1 NEW_LINE DEDENT if key == mid2 : NEW_LINE INDENT return mid2 NEW_LINE DEDENT if key < ar [ mid1 ] : NEW_LINE INDENT r = mid1 - 1 NEW_LINE DEDENT elif key > ar [ mid2 ] : NEW_LINE INDENT l = mid2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid1 + 1 NEW_LINE r = mid2 - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE l = 0 NEW_LINE r = 9 NEW_LINE key = 5 NEW_LINE p = ternarySearch ( l , r , key , ar ) NEW_LINE print ( \" Index ▁ of \" , key , \" is \" , p ) NEW_LINE key = 50 NEW_LINE p = ternarySearch ( l , r , key , ar ) NEW_LINE print ( \" Index ▁ of \" , key , \" is \" , p ) NEW_LINE"}
{"text": "Elemen Majoriti | Set | berfungsi untuk mencetak MajoritiNumber; Kod pemacu", "code": "def majorityNumber ( nums ) : NEW_LINE INDENT num_count = { } NEW_LINE for num in nums : NEW_LINE INDENT if num in num_count : NEW_LINE INDENT num_count [ num ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num_count [ num ] = 1 NEW_LINE DEDENT DEDENT for num in num_count : NEW_LINE INDENT if num_count [ num ] > len ( nums ) / 2 : NEW_LINE INDENT return num NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT a = [ 2 , 2 , 1 , 1 , 1 , 2 , 2 ] NEW_LINE print majorityNumber ( a ) NEW_LINE"}
{"text": "Cari elemen dalam array yang disusun dan diputar | Pulangan indeks kunci dalam arr [l. . h] jika kunci hadir, jika tidak pulangan - 1; Jika arr [l ... pertengahan] disusun; Oleh kerana subarray ini disusun, kita dapat dengan cepat memeriksa sama ada kunci terletak pada separuh atau separuh lagi; Jika kunci tidak terletak pada separuh pertama subarray, bahagikan separuh lagi ke dalam dua subarray, supaya kita dapat dengan cepat memeriksa jika kunci terletak pada separuh lain; Jika arr [l. . pertengahan] tidak disusun, maka arr [pertengahan ... r] mesti disusun; Program Pemandu", "code": "def search ( arr , l , h , key ) : NEW_LINE INDENT if l > h : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ l ] <= arr [ mid ] : NEW_LINE INDENT if key >= arr [ l ] and key <= arr [ mid ] : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if key >= arr [ mid ] and key <= arr [ h ] : NEW_LINE INDENT return search ( a , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ] NEW_LINE key = 6 NEW_LINE i = search ( arr , 0 , len ( arr ) - 1 , key ) NEW_LINE if i != - 1 : NEW_LINE INDENT print ( \" Index : ▁ % ▁ d \" % i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Key ▁ not ▁ found \" ) NEW_LINE DEDENT"}
{"text": "Cari elemen minimum dalam array yang disusun dan diputar | Program Python untuk mencari elemen minimum dalam array yang disusun dan diputar; Keadaan ini diperlukan untuk mengendalikan kes apabila array tidak diputar sama sekali; Sekiranya terdapat hanya satu elemen yang tersisa; Cari pertengahan; Semak jika elemen (pertengahan + 1) adalah elemen minimum. Pertimbangkan kes seperti [3, 4, 5, 1, 2]; Semak jika Mid sendiri adalah elemen minimum; Tentukan sama ada kita perlu pergi ke separuh kiri atau kanan; Program pemacu untuk menguji fungsi di atas", "code": "def findMin ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if high == low : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return arr [ mid + 1 ] NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return findMin ( arr , low , mid - 1 ) NEW_LINE DEDENT return findMin ( arr , mid + 1 , high ) NEW_LINE DEDENT arr1 = [ 5 , 6 , 1 , 2 , 3 , 4 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" + str ( findMin ( arr1 , 0 , n1 - 1 ) ) ) NEW_LINE arr2 = [ 1 , 2 , 3 , 4 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" + str ( findMin ( arr2 , 0 , n2 - 1 ) ) ) NEW_LINE arr3 = [ 1 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" + str ( findMin ( arr3 , 0 , n3 - 1 ) ) ) NEW_LINE arr4 = [ 1 , 2 ] NEW_LINE n4 = len ( arr4 ) NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" + str ( findMin ( arr4 , 0 , n4 - 1 ) ) ) NEW_LINE arr5 = [ 2 , 1 ] NEW_LINE n5 = len ( arr5 ) NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" + str ( findMin ( arr5 , 0 , n5 - 1 ) ) ) NEW_LINE arr6 = [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ] NEW_LINE n6 = len ( arr6 ) NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" + str ( findMin ( arr6 , 0 , n6 - 1 ) ) ) NEW_LINE arr7 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n7 = len ( arr7 ) NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" + str ( findMin ( arr7 , 0 , n7 - 1 ) ) ) NEW_LINE arr8 = [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 ] NEW_LINE n8 = len ( arr8 ) NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" + str ( findMin ( arr8 , 0 , n8 - 1 ) ) ) NEW_LINE arr9 = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n9 = len ( arr9 ) NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" + str ( findMin ( arr9 , 0 , n9 - 1 ) ) ) NEW_LINE"}
{"text": "Cari elemen minimum dalam array yang disusun dan diputar | Berfungsi untuk mencari elemen minimum; Kod pemacu", "code": "def findMin ( arr , low , high ) : NEW_LINE INDENT while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 ; NEW_LINE if ( arr [ mid ] == arr [ high ] ) : NEW_LINE INDENT high -= 1 ; NEW_LINE DEDENT elif ( arr [ mid ] > arr [ high ] ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return arr [ high ] ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 5 , 6 , 1 , 2 , 3 , 4 ] ; NEW_LINE n1 = len ( arr1 ) ; NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" , findMin ( arr1 , 0 , n1 - 1 ) ) ; NEW_LINE arr2 = [ 1 , 2 , 3 , 4 ] ; NEW_LINE n2 = len ( arr2 ) ; NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" , findMin ( arr2 , 0 , n2 - 1 ) ) ; NEW_LINE arr3 = [ 1 ] ; NEW_LINE n3 = len ( arr3 ) ; NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" , findMin ( arr3 , 0 , n3 - 1 ) ) ; NEW_LINE arr4 = [ 1 , 2 ] ; NEW_LINE n4 = len ( arr4 ) ; NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" , findMin ( arr4 , 0 , n4 - 1 ) ) ; NEW_LINE arr5 = [ 2 , 1 ] ; NEW_LINE n5 = len ( arr5 ) ; NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" , findMin ( arr5 , 0 , n5 - 1 ) ) ; NEW_LINE arr6 = [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ] ; NEW_LINE n6 = len ( arr6 ) ; NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" , findMin ( arr6 , 0 , n6 - 1 ) ) ; NEW_LINE arr7 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ; NEW_LINE n7 = len ( arr7 ) ; NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" , findMin ( arr7 , 0 , n7 - 1 ) ) ; NEW_LINE arr8 = [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 ] ; NEW_LINE n8 = len ( arr8 ) ; NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" , findMin ( arr8 , 0 , n8 - 1 ) ) ; NEW_LINE arr9 = [ 3 , 4 , 5 , 1 , 2 ] ; NEW_LINE n9 = len ( arr9 ) ; NEW_LINE print ( \" The ▁ minimum ▁ element ▁ is ▁ \" , findMin ( arr9 , 0 , n9 - 1 ) ) ; NEW_LINE DEDENT"}
{"text": "K | Program Python3 untuk mencari perbezaan mutlak antara dua elemen; Mengembalikan bilangan pasangan dengan perbezaan mutlak kurang daripada atau sama dengan pertengahan. ; Upper Bound Returns Pointer ke kedudukan nombor seterusnya yang lebih tinggi daripada [i] + pertengahan dalam [i. . n - 1]. Kami tolak (a + i + 1) dari kedudukan ini untuk dikira; Pulangan k - perbezaan mutlak; Susun array; Perbezaan mutlak minimum; Perbezaan mutlak maksimum; Adakah pencarian binari untuk perbezaan mutlak; Kod pemacu", "code": "from bisect import bisect as upper_bound NEW_LINE def countPairs ( a , n , mid ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += upper_bound ( a , a [ i ] + mid ) NEW_LINE DEDENT return res NEW_LINE DEDENT def kthDiff ( a , n , k ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE low = a [ 1 ] - a [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT low = min ( low , a [ i + 1 ] - a [ i ] ) NEW_LINE DEDENT high = a [ n - 1 ] - a [ 0 ] NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( countPairs ( a , n , mid ) < k ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT k = 3 NEW_LINE a = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( kthDiff ( a , n , k ) ) NEW_LINE"}
{"text": "Cari elemen terkecil terkecil dan kedua dalam array | Program Python untuk mencari elemen terkecil terkecil dan kedua; Berfungsi untuk mencetak unsur -unsur terkecil terkecil pertama dan kedua; Harus ada dua elemen; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Fungsi pemacu untuk menguji fungsi di atas", "code": "import sys NEW_LINE def print2Smallest ( arr ) : NEW_LINE INDENT arr_size = len ( arr ) NEW_LINE if arr_size < 2 : NEW_LINE INDENT print \" Invalid ▁ Input \" NEW_LINE return NEW_LINE DEDENT first = second = sys . maxint NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] < first : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] ; NEW_LINE DEDENT DEDENT if ( second == sys . maxint ) : NEW_LINE INDENT print \" No ▁ second ▁ smallest ▁ element \" NEW_LINE DEDENT else : NEW_LINE INDENT print ' The ▁ smallest ▁ element ▁ is ' , first , ' and ' ' ▁ second ▁ smallest ▁ element ▁ is ' , second NEW_LINE DEDENT DEDENT arr = [ 12 , 13 , 1 , 10 , 34 , 1 ] NEW_LINE print2Smallest ( arr ) NEW_LINE"}
{"text": "Range LCM Queries | LCM pertanyaan pelbagai yang diberikan menggunakan pokok segmen; memperuntukkan ruang untuk pokok; mengisytiharkan array di seluruh dunia; Berfungsi untuk mengembalikan GCD A dan B; fungsi utiliti untuk mencari LCM; Fungsi untuk membina nod pokok segmen memulakan indeks permulaan subtree semasa. Permulaan dan akhir adalah indeks dalam arr [] yang global; Sekiranya terdapat hanya satu elemen dalam subarray semasa; membina segmen kiri dan kanan; membina ibu bapa; Berfungsi untuk membuat pertanyaan untuk pelbagai array) l, r). Node adalah indeks akar segmen semasa dalam pokok segmen (perhatikan bahawa indeks dalam pokok segmen bermula dengan 1F atau kesederhanaan). Mula dan akhir adalah indeks subarray yang dilindungi oleh akar segmen semasa. ; Sepenuhnya di luar segmen, kembali 1 tidak akan menjejaskan LCM; ; sepenuhnya di dalam segmen; sebahagiannya di dalam; Kod pemacu; memulakan array; membina pokok segmen; Sekarang kita dapat menjawab setiap pertanyaan dengan cekap mencetak LCM (2, 5); Cetak LCM (5, 10); Cetak LCM (0, 10)", "code": "MAX = 1000 NEW_LINE tree = [ 0 ] * ( 4 * MAX ) NEW_LINE arr = [ 0 ] * MAX NEW_LINE def gcd ( a : int , b : int ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a : int , b : int ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT def build ( node : int , start : int , end : int ) : NEW_LINE INDENT if start == end : NEW_LINE INDENT tree [ node ] = arr [ start ] NEW_LINE return NEW_LINE DEDENT mid = ( start + end ) // 2 NEW_LINE build ( 2 * node , start , mid ) NEW_LINE build ( 2 * node + 1 , mid + 1 , end ) NEW_LINE left_lcm = tree [ 2 * node ] NEW_LINE right_lcm = tree [ 2 * node + 1 ] NEW_LINE tree [ node ] = lcm ( left_lcm , right_lcm ) NEW_LINE DEDENT def query ( node : int , start : int , end : int , l : int , r : int ) : NEW_LINE INDENT if end < l or start > r : NEW_LINE INDENT return 1 NEW_LINE DEDENT if l <= start and r >= end : NEW_LINE INDENT return tree [ node ] NEW_LINE DEDENT mid = ( start + end ) // 2 NEW_LINE left_lcm = query ( 2 * node , start , mid , l , r ) NEW_LINE right_lcm = query ( 2 * node + 1 , mid + 1 , end , l , r ) NEW_LINE return lcm ( left_lcm , right_lcm ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr [ 0 ] = 5 NEW_LINE arr [ 1 ] = 7 NEW_LINE arr [ 2 ] = 5 NEW_LINE arr [ 3 ] = 2 NEW_LINE arr [ 4 ] = 10 NEW_LINE arr [ 5 ] = 12 NEW_LINE arr [ 6 ] = 11 NEW_LINE arr [ 7 ] = 17 NEW_LINE arr [ 8 ] = 14 NEW_LINE arr [ 9 ] = 1 NEW_LINE arr [ 10 ] = 44 NEW_LINE build ( 1 , 0 , 10 ) NEW_LINE print ( query ( 1 , 0 , 10 , 2 , 5 ) ) NEW_LINE print ( query ( 1 , 0 , 10 , 5 , 10 ) ) NEW_LINE print ( query ( 1 , 0 , 10 , 0 , 10 ) ) NEW_LINE DEDENT"}
{"text": "Kira penyahkodan mungkin urutan digit yang diberikan dengan aksara tersembunyi | Program Python untuk pendekatan di atas; Semak watak pertama rentetan jika ' *' maka 9 cara; melintasi rentetan; Jika s [i] = = ' *' boleh ada 9 nilai yang mungkin *; Jika watak sebelumnya adalah 1 maka perkataan yang boleh dibentuk adalah k (11), l (12), m (13), n (14) o (15), p (16), q (17), r (18), s (19); Jika watak sebelumnya adalah 2 maka kata -kata yang boleh dibentuk ialah u (21), v (22), w (23), x (24) y (25), z (26); Jika digit sebelumnya * maka semua 15 2 - aksara digit boleh dibentuk; mengambil nilai dari langkah sebelumnya; Jika watak sebelumnya adalah 1 maka watak I - 1 dan watak itu boleh dikodkan dalam satu watak oleh itu, menambah DP [i - 1]. ; Jika watak sebelumnya adalah 2 dan watak ith kurang daripada 6 maka watak I - 1 dan watak ith boleh dikodkan dalam satu watak oleh itu, menambah DP [i - 1]. ; Jika watak sebelumnya * maka ia akan mengandungi 2 kes di atas; Kod pemacu", "code": "M = 1000000007 NEW_LINE def waysOfDecoding ( s ) : NEW_LINE INDENT dp = [ 0 ] * ( len ( s ) + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE if s [ 0 ] == ' * ' : NEW_LINE INDENT dp [ 1 ] = 9 NEW_LINE DEDENT elif s [ 0 ] == '0' : NEW_LINE INDENT dp [ 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] = 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' * ' ) : NEW_LINE INDENT dp [ i + 1 ] = 9 * dp [ i ] NEW_LINE if ( s [ i - 1 ] == '1' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == '2' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == ' * ' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ i ] != '0' : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] = 0 NEW_LINE DEDENT if ( s [ i - 1 ] == '1' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == '2' and s [ i ] <= '6' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == ' * ' ) : NEW_LINE INDENT if ( s [ i ] <= '6' ) : NEW_LINE INDENT dp [ i + 1 ] = dp [ i + 1 ] + 2 * dp [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] = dp [ i + 1 ] + 1 * dp [ i - 1 ] NEW_LINE DEDENT dp [ i + 1 ] = dp [ i + 1 ] % M NEW_LINE DEDENT DEDENT DEDENT return dp [ len ( s ) ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"12\" NEW_LINE print ( waysOfDecoding ( s ) ) NEW_LINE DEDENT"}
{"text": "Kira cara untuk memecah array ke dalam dua subset yang mempunyai perbezaan antara jumlah mereka sama dengan k | Fungsi untuk mengira bilangan cara untuk membahagikan array ke dalam dua subset dan sedemikian rupa sehingga perbezaan antara jumlah mereka adalah sama dengan perbezaan; Simpan jumlah set S1; Memulakan matriks; Bilangan cara untuk mendapatkan jumlah menggunakan 0 elemen adalah 0; Bilangan cara untuk mendapatkan jumlah 0 menggunakan elemen i adalah 1; Melintasi array 2D; Jika nilai lebih besar daripada jumlah menyimpan nilai keadaan sebelumnya; Mengembalikan hasilnya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "def countSubset ( arr , n , diff ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT sum += diff NEW_LINE sum = sum // 2 NEW_LINE t = [ [ 0 for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for j in range ( sum + 1 ) : NEW_LINE INDENT t [ 0 ] [ j ] = 0 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT t [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] > j ) : NEW_LINE INDENT t [ i ] [ j ] = t [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] NEW_LINE DEDENT DEDENT DEDENT return t [ n ] [ sum ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT diff , n = 1 , 4 NEW_LINE arr = [ 1 , 1 , 2 , 3 ] NEW_LINE print ( countSubset ( arr , n , diff ) ) NEW_LINE DEDENT"}
{"text": "Kebarangkalian bahawa jumlah semua nombor yang diperolehi membuang dadu n kali terletak di antara dua bilangan bulat yang diberikan | Program Python3 untuk pendekatan di atas; Fungsi untuk mengira kebarangkalian bahawa jumlah nombor pada n lontaran dadu terletak di antara a dan b; Kes asas; Tambah kebarangkalian untuk semua nombor antara A dan B; Kod pemacu; Cetak jawapannya", "code": "dp = [ [ 0 for i in range ( 605 ) ] for j in range ( 105 ) ] NEW_LINE def find ( N , a , b ) : NEW_LINE INDENT probability = 0.0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1.0 / 6 NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT for j in range ( i , ( 6 * i ) + 1 ) : NEW_LINE INDENT for k in range ( 1 , 7 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 NEW_LINE DEDENT DEDENT DEDENT for Sum in range ( a , b + 1 ) : NEW_LINE INDENT probability = probability + dp [ N ] [ Sum ] NEW_LINE DEDENT return probability NEW_LINE DEDENT N , a , b = 4 , 13 , 17 NEW_LINE probability = find ( N , a , b ) NEW_LINE print ( ' % .6f ' % probability ) NEW_LINE"}
{"text": "Jumlah maksimum dari pokok dengan tahap bersebelahan tidak dibenarkan | Kod python3 untuk jumlah maksimum dengan tahap bersebelahan tidak dibenarkan; Nod BST; Fungsi rekursif untuk mencari jumlah maksimum yang dikembalikan untuk nod akar dan cucunya; Mengembalikan jumlah maksimum dengan tahap bersebelahan tidak dibenarkan. Fungsi ini terutamanya menggunakan getSumalternate (); Kami mengira jumlah tahap alternatif bermula tahap pertama dan dari tahap kedua. Dan kembali maksimum dua nilai. ; Kod pemacu", "code": "from collections import deque as queue NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getSumAlternate ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = root . data NEW_LINE if ( root . left != None ) : NEW_LINE INDENT sum += getSum ( root . left . left ) NEW_LINE sum += getSum ( root . left . right ) NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT sum += getSum ( root . right . left ) NEW_LINE sum += getSum ( root . right . right ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def getSum ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( getSumAlternate ( root ) , ( getSumAlternate ( root . left ) + getSumAlternate ( root . right ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . right . left = Node ( 4 ) NEW_LINE root . right . left . right = Node ( 5 ) NEW_LINE root . right . left . right . left = Node ( 6 ) NEW_LINE print ( getSum ( root ) ) NEW_LINE DEDENT"}
{"text": "Subset Jumlah Masalah di O (SUM) Ruang | Pulangan benar jika terdapat subset dengan jumlah yang diberikan dalam arr []; Nilai subset [i % 2] [j] akan benar jika terdapat subset jumlah J dalam arr [0, 1, .... , i - 1]; Subset dengan jumlah 0 selalu mungkin; Sekiranya tidak ada unsur tidak ada jumlah yang mungkin; Kod pemacu", "code": "def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for j in range ( sum + 1 ) ] for i in range ( 3 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = True NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = False NEW_LINE DEDENT elif ( arr [ i - 1 ] <= j ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return subset [ n % 2 ] [ sum ] NEW_LINE DEDENT arr = [ 6 , 2 , 5 ] NEW_LINE sum = 7 NEW_LINE n = len ( arr ) NEW_LINE if ( isSubsetSum ( arr , n , sum ) == True ) : NEW_LINE INDENT print ( \" There ▁ exists ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ exists ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT"}
{"text": "Sum maksimum equlibrium dalam array | Program Python 3 untuk mencari jumlah keseimbangan maksimum. ; Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Kod pemacu", "code": "import sys NEW_LINE def findMaxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum = arr [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT prefix_sum += arr [ j ] NEW_LINE DEDENT suffix_sum = arr [ i ] NEW_LINE j = n - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT suffix_sum += arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( prefix_sum == suffix_sum ) : NEW_LINE INDENT res = max ( res , prefix_sum ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Sum maksimum equlibrium dalam array | Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Array to Store Prefix Sum. ; Array untuk menyimpan jumlah akhiran. ; Pembolehubah untuk menyimpan jumlah maksimum. ; Kirakan jumlah awalan. ; Kirakan jumlah akhiran dan bandingkan dengan jumlah awalan. Kemas kini Ans dengan sewajarnya. ; Kod pemacu", "code": "def findMaxSum ( arr , n ) : NEW_LINE INDENT preSum = [ 0 for i in range ( n ) ] NEW_LINE suffSum = [ 0 for i in range ( n ) ] NEW_LINE ans = - 10000000 NEW_LINE preSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT preSum [ i ] = preSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT suffSum [ n - 1 ] = arr [ n - 1 ] NEW_LINE if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) : NEW_LINE INDENT ans = max ( ans , preSum [ n - 1 ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] NEW_LINE if ( suffSum [ i ] == preSum [ i ] ) : NEW_LINE INDENT ans = max ( ans , preSum [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Sum maksimum equlibrium dalam array | Program Python3 untuk mencari jumlah keseimbangan maksimum. ; Berfungsi untuk mencari jumlah keseimbangan maksimum. ; Kod pemacu", "code": "import sys NEW_LINE def findMaxSum ( arr , n ) : NEW_LINE INDENT ss = sum ( arr ) NEW_LINE prefix_sum = 0 NEW_LINE res = - sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum += arr [ i ] NEW_LINE if prefix_sum == ss : NEW_LINE INDENT res = max ( res , prefix_sum ) ; NEW_LINE DEDENT ss -= arr [ i ] ; NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Elemen Majoriti | Berfungsi untuk mencari elemen majoriti dalam array; sentinel; Kemas kini MaxCount jika kiraan elemen semasa lebih besar; Jika MaxCount lebih besar daripada n / 2 mengembalikan elemen yang sepadan; Kod pemacu; Fungsi panggilan", "code": "def findMajority ( arr , n ) : NEW_LINE INDENT maxCount = 0 NEW_LINE index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > maxCount ) : NEW_LINE INDENT maxCount = count NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( maxCount > n // 2 ) : NEW_LINE INDENT print ( arr [ index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Majority ▁ Element \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 1 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findMajority ( arr , n ) NEW_LINE DEDENT"}
{"text": "Elemen Majoriti | Berfungsi untuk mencari calon untuk majoriti; Berfungsi untuk memeriksa sama ada calon berlaku lebih daripada n / 2 kali; Berfungsi untuk mencetak elemen majoriti; Cari calon untuk majoriti; Cetak calon jika ia adalah majoriti; Kod pemacu; Panggilan fungsi", "code": "def findCandidate ( A ) : NEW_LINE INDENT maj_index = 0 NEW_LINE count = 1 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ maj_index ] == A [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if count == 0 : NEW_LINE INDENT maj_index = i NEW_LINE count = 1 NEW_LINE DEDENT DEDENT return A [ maj_index ] NEW_LINE DEDENT def isMajority ( A , cand ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ i ] == cand : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count > len ( A ) / 2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def printMajority ( A ) : NEW_LINE INDENT cand = findCandidate ( A ) NEW_LINE if isMajority ( A , cand ) == True : NEW_LINE INDENT print ( cand ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Majority ▁ Element \" ) NEW_LINE DEDENT DEDENT A = [ 1 , 3 , 3 , 1 , 2 ] NEW_LINE printMajority ( A ) NEW_LINE"}
{"text": "Elemen Majoriti | Program Python3 untuk mencari elemen majoriti dalam array; Kod pemacu; Fungsi panggilan", "code": "def findMajority ( arr , size ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] in m : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for key in m : NEW_LINE INDENT if m [ key ] > size / 2 : NEW_LINE INDENT count = 1 NEW_LINE print ( \" Majority ▁ found ▁ : - \" , key ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( \" No ▁ Majority ▁ element \" ) NEW_LINE DEDENT DEDENT arr = [ 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE findMajority ( arr , n ) NEW_LINE"}
{"text": "Elemen Majoriti | Fungsi untuk mencari elemen majoriti dalam array ia kembali - 1 jika tidak ada unsur majoriti; Susun array dalam O (nlogn); Meningkatkan kiraan jika elemen yang sama berlaku sebaliknya mula mengira elemen baru; menetapkan kiraan maksimum dan menyimpan elemen maksimum yang berlaku setakat ini jika kiraan maksimum menjadi lebih besar daripada n / 2 ia memecahkan penetapan bendera; Mengembalikan elemen maksimum yang berlaku jika tidak ada elemen sedemikian, pulangan - 1; Kod pemacu; Fungsi panggilan", "code": "def majorityElement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count , max_ele , temp , f = 1 , - 1 , arr [ 0 ] , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( temp == arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE temp = arr [ i ] NEW_LINE DEDENT if ( max_ele < count ) : NEW_LINE INDENT max_ele = count NEW_LINE ele = arr [ i ] NEW_LINE if ( max_ele > ( n // 2 ) ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if f == 1 : NEW_LINE INDENT return ele NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 1 , 2 , 1 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( majorityElement ( arr , n ) ) NEW_LINE"}
{"text": "Pengaturcaraan Dinamik | Pulangan benar jika terdapat subset set [] dengan jumlah yang sama dengan jumlah yang diberikan; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara bawah; Uncomment Kod ini untuk mencetak jadual; Kod pemacu", "code": "def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if j < set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if j >= set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE for j in range ( sum + 1 ) : NEW_LINE print ( subset [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE print ( ) NEW_LINE return subset [ n ] [ sum ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Pengaturcaraan Dinamik | Mengambil matriks secara global; Semak jika boleh subset dengan jumlah yang diberikan adalah mungkin atau tidak; Sekiranya jumlahnya adalah sifar, ia bermakna kami mendapat jumlah yang diharapkan; Jika nilai tidak - 1 ia bermakna ia sudah memanggil fungsi dengan nilai yang sama. Ia akan menyelamatkan kami dari pengulangan. ; Jika nilai A [n - 1] lebih besar daripada jumlahnya. Kami memanggil nilai seterusnya; Di sini kita melakukan dua panggilan kerana kita tidak tahu apa -apa yang akan dipenuhi oleh kami. Kod pemacu", "code": "tab = [ [ - 1 for i in range ( 2000 ) ] for j in range ( 2000 ) ] NEW_LINE def subsetSum ( a , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( tab [ n - 1 ] [ sum ] != - 1 ) : NEW_LINE INDENT return tab [ n - 1 ] [ sum ] NEW_LINE DEDENT if ( a [ n - 1 ] > sum ) : NEW_LINE INDENT tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) NEW_LINE return tab [ n - 1 ] [ sum ] NEW_LINE DEDENT else : NEW_LINE INDENT tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) NEW_LINE return tab [ n - 1 ] [ sum ] or subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE a = [ 1 , 5 , 3 , 7 , 4 ] NEW_LINE sum = 12 NEW_LINE if ( subsetSum ( a , n , sum ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text": "Jumlah perbezaan bit untuk nombor dari 0 hingga n | Program Python3 untuk pendekatan di atas; Berfungsi untuk melaksanakan eksponensi cepat; Berfungsi untuk mengembalikan nilai untuk kuasa 2; Berfungsi untuk menukar n ke dalam binari; Untuk menyimpan perwakilan binari; Melepasi setiap digit n; Mengembalikan perwakilan binari; Berfungsi untuk mencari perbezaan bit; Dapatkan perwakilan binari; Jumlah bilangan perbezaan bit dari 0 hingga n; Melangkah ke atas setiap bit binari; Jika bit semasa adalah '1' kemudian tambahkan kiraan bit semasa; Nombor yang diberikan; Panggilan fungsi", "code": "from math import log NEW_LINE def binpow ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = res * a NEW_LINE DEDENT a = a * a NEW_LINE b //= 2 NEW_LINE DEDENT return res NEW_LINE DEDENT def find ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT p = log ( x ) / log ( 2 ) NEW_LINE return binpow ( 2 , p + 1 ) - 1 NEW_LINE DEDENT def getBinary ( n ) : NEW_LINE INDENT ans = \" \" NEW_LINE while ( n > 0 ) : NEW_LINE INDENT dig = n % 2 NEW_LINE ans += str ( dig ) NEW_LINE n //= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT def totalCountDifference ( n ) : NEW_LINE INDENT ans = getBinary ( n ) NEW_LINE req = 0 NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT if ( ans [ i ] == '1' ) : NEW_LINE INDENT req += find ( binpow ( 2 , i ) ) NEW_LINE DEDENT DEDENT return req NEW_LINE DEDENT N = 5 NEW_LINE print ( totalCountDifference ( N ) ) NEW_LINE"}
{"text": "Cari panjang maksimum awalan | Berfungsi untuk mengembalikan panjang maksimum awalan yang diperlukan; Array untuk menyimpan kekerapan setiap elemen array; Melangkah untuk semua elemen; Kemas kini kekerapan elemen semasa i. e. v; Disusun nilai positif dari array Count; Jika awalan semasa memenuhi syarat yang diberikan; Mengembalikan panjang maksimum; Kod pemacu", "code": "def Maximum_Length ( a ) : NEW_LINE INDENT counts = [ 0 ] * 11 NEW_LINE for index , v in enumerate ( a ) : NEW_LINE INDENT counts [ v ] += 1 NEW_LINE k = sorted ( [ i for i in counts if i ] ) NEW_LINE if len ( k ) == 1 or ( k [ 0 ] == k [ - 2 ] and k [ - 1 ] - k [ - 2 ] == 1 ) or ( k [ 0 ] == 1 and k [ 1 ] == k [ - 1 ] ) : NEW_LINE INDENT ans = index NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 1 , 2 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( Maximum_Length ( a ) ) NEW_LINE DEDENT"}
{"text": "Pertanyaan dalam talian untuk GCD Array Selepas Membahagikan Operasi | Mengembalikan GCD selepas semua kemas kini dalam array; Fungsi untuk mengira GCD pertanyaan onine; Menyimpan GCD elemen array awal; mengira GCD; melakukan pertanyaan dalam talian; Indeks adalah 1 berdasarkan; Bahagikan elemen array; mengira GCD semasa; Cetak GCD selepas setiap langkah; Kod pemacu", "code": "def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def print_gcd_online ( n , m , query , arr ) : NEW_LINE INDENT max_gcd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_gcd = gcd ( max_gcd , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT query [ i ] [ 0 ] -= 1 NEW_LINE arr [ query [ i ] [ 0 ] ] //= query [ i ] [ 1 ] NEW_LINE max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) NEW_LINE print ( max_gcd ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 3 , 3 NEW_LINE query = [ [ 1 , 3 ] , [ 3 , 12 ] , [ 2 , 4 ] ] NEW_LINE arr = [ 36 , 24 , 72 ] NEW_LINE print_gcd_online ( n , m , query , arr ) NEW_LINE DEDENT"}
{"text": "Nombor dalam julat [l, r] supaya kiraan pembahagi mereka adalah kedua -duanya dan perdana | Python 3 pelaksanaan pendekatan; Kedai sama ada nombor itu adalah perdana atau tidak; menyimpan kiraan nombor perdana kurang daripada atau sama dengan indeks; buat penapis; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaan sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika 'I' bukanlah perdana, yang lain benar; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; menyimpan jumlah awalan bilangan prima kurang daripada atau sama dengan 'i; Kod pemacu; buat penapis; 'l' dan 'r' adalah batas bawah dan atas julat; Dapatkan nilai kiraan; Paparkan kiraan", "code": "MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE sum = [ 0 ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT i = p * 2 NEW_LINE while i <= MAX : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT sum [ i ] = 1 NEW_LINE DEDENT sum [ i ] += sum [ i - 1 ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE l = 3 NEW_LINE r = 9 NEW_LINE c = ( sum [ r ] - sum [ l - 1 ] ) NEW_LINE print ( \" Count : \" , c ) NEW_LINE DEDENT"}
{"text": "Kawasan bulatan yang ditulis dalam segi empat tepat yang tertulis dalam separuh bulatan | Program Python 3 untuk mencari kawasan bulatan yang ditulis dalam segi empat tepat yang seterusnya ditulis dalam separuh bulatan; Berfungsi untuk mencari kawasan bulatan; Radius tidak boleh negatif; kawasan bulatan; Kod pemacu", "code": "from math import pow , sqrt NEW_LINE def area ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; NEW_LINE return area ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE print ( \" { 0 : . 6 } \" . format ( area ( a ) ) ) NEW_LINE DEDENT"}
{"text": "Cari kiraan nombor hampir perdana dari 1 hingga n | Program Python 3 untuk mengira hampir nombor utama dari 1 hingga N; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Fungsi untuk mengira hampir nombor utama dari 1 hingga n; untuk menyimpan jawapan yang diperlukan; 6 adalah nombor hampir perdana pertama; untuk mengira faktor utama; Jika ia sempurna persegi; Sekiranya saya hampir nombor utama; Kod pemacu", "code": "from math import * NEW_LINE N = 100005 NEW_LINE prime = [ True ] * N NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( N ) ) ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( 2 * p , N , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def almostPrimes ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 6 , n + 1 ) : NEW_LINE INDENT c = 0 NEW_LINE for j in range ( 2 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT if prime [ j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if prime [ j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if prime [ i // j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if c == 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 21 NEW_LINE print ( almostPrimes ( n ) ) NEW_LINE DEDENT"}
{"text": "Bahagikan nombor menjadi dua bahagian supaya jumlah digit adalah maksimum | Mengembalikan jumlah digit X; Mengembalikan nombor terdekat kepada X dari segi 9; Kod pemacu", "code": "def sumOfDigitsSingle ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while x : NEW_LINE INDENT ans += x % 10 NEW_LINE x //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT def closest ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( ans * 10 + 9 <= x ) : NEW_LINE INDENT ans = ans * 10 + 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sumOfDigitsTwoParts ( N ) : NEW_LINE INDENT A = closest ( N ) NEW_LINE return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 35 NEW_LINE print ( sumOfDigitsTwoParts ( N ) ) NEW_LINE DEDENT"}
{"text": "Ujian Primal | Tetapkan 5 (menggunakan Lucas | berfungsi untuk memeriksa sama ada (2 ^ p - 1) adalah perdana atau tidak., Menjana nombor, nombor pertama siri; menjana sisanya (p - 2) syarat siri; sekarang jika (p -1) istilah 0 kembali benar palsu.", "code": "def isPrime ( p ) : NEW_LINE INDENT checkNumber = 2 ** p - 1 NEW_LINE nextval = 4 % checkNumber NEW_LINE for i in range ( 1 , p - 1 ) : NEW_LINE INDENT nextval = ( nextval * nextval - 2 ) % checkNumber NEW_LINE DEDENT if ( nextval == 0 ) : return True NEW_LINE else : return False NEW_LINE DEDENT p = 7 NEW_LINE checkNumber = 2 ** p - 1 NEW_LINE if isPrime ( p ) : NEW_LINE INDENT print ( checkNumber , ' is ▁ Prime . ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( checkNumber , ' is ▁ not ▁ Prime ' ) NEW_LINE DEDENT"}
{"text": "Sophie Germain Prime | Fungsi untuk mengesan nombor perdana di sini kami telah menggunakan kaedah penapis https: www. Geeksforgeeks. org / sieve - of - eratosthenes / untuk mengesan nombor perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Kami telah membuat array sehingga 2 * n + 1 supaya kami dapat memeriksa nombor perdana sehingga itu dan menyimpulkan tentang Sophie Jerman Prime. ; Memeriksa setiap saya sama ada Sophie Jerman Perdana atau tidak. ; Kod pemacu", "code": "def sieve ( n , prime ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def printSophieGermanNumber ( n ) : NEW_LINE INDENT prime = [ True ] * ( 2 * n + 1 ) NEW_LINE sieve ( 2 * n + 1 , prime ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ 2 * i + 1 ] ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT n = 25 NEW_LINE printSophieGermanNumber ( n ) NEW_LINE"}
{"text": "Interpolasi Bessel | mengira anda disebut dalam formula; mengira faktorial nombor n; Bilangan nilai yang diberikan; y [] [] digunakan untuk jadual perbezaan dengan y [] [0] digunakan untuk input; Mengira jadual perbezaan pusat; Memaparkan jadual perbezaan pusat; nilai untuk interpolasi pada; Memulakan u dan jumlah; k ialah asalnya ialah F (0); jika ((n % 2)> 0): asal untuk ganjil; k = int (n / 2 - 1); Asal untuk walaupun; Menyelesaikan menggunakan formula Bessel", "code": "def ucal ( u , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT temp = u ; NEW_LINE for i in range ( 1 , int ( n / 2 + 1 ) ) : NEW_LINE INDENT temp = temp * ( u - i ) ; NEW_LINE DEDENT for i in range ( 1 , int ( n / 2 ) ) : NEW_LINE INDENT temp = temp * ( u + i ) ; NEW_LINE DEDENT return temp ; NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT f = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f *= i ; NEW_LINE DEDENT return f ; NEW_LINE DEDENT n = 6 ; NEW_LINE x = [ 25 , 26 , 27 , 28 , 29 , 30 ] ; NEW_LINE y = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] ; NEW_LINE y [ 0 ] [ 0 ] = 4.000 ; NEW_LINE y [ 1 ] [ 0 ] = 3.846 ; NEW_LINE y [ 2 ] [ 0 ] = 3.704 ; NEW_LINE y [ 3 ] [ 0 ] = 3.571 ; NEW_LINE y [ 4 ] [ 0 ] = 3.448 ; NEW_LINE y [ 5 ] [ 0 ] = 3.333 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n - i ) : NEW_LINE INDENT y [ j ] [ i ] = y [ j + 1 ] [ i - 1 ] - y [ j ] [ i - 1 ] ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n - i ) : NEW_LINE INDENT print ( y [ i ] [ j ] , \" TABSYMBOL \" , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT value = 27.4 ; NEW_LINE sum = ( y [ 2 ] [ 0 ] + y [ 3 ] [ 0 ] ) / 2 ; NEW_LINE k = 0 ; NEW_LINE INDENT k = int ( n / 2 ) ; NEW_LINE DEDENT else : NEW_LINE u = ( value - x [ k ] ) / ( x [ 1 ] - x [ 0 ] ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT sum = sum + ( ( u - 0.5 ) * ucal ( u , i - 1 ) * y [ k ] [ i ] ) / fact ( i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + ( ucal ( u , i ) * ( y [ k ] [ i ] + y [ k - 1 ] [ i ] ) / ( fact ( i ) * 2 ) ) ; NEW_LINE k -= 1 ; NEW_LINE DEDENT DEDENT print ( \" Value ▁ at \" , value , \" is \" , round ( sum , 5 ) ) ; NEW_LINE"}
{"text": "Cara yang cekap untuk memeriksa sama ada N | Program Python 3 yang mudah untuk memeriksa sama ada nombor Fibonacci adalah berganda dari 10 .; Pulangan benar jika nombor fibonacci n - th adalah berganda dari 10 .; Kod pemacu", "code": "def fibonacci ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT def isMultipleOf10 ( n ) : NEW_LINE INDENT f = fibonacci ( 30 ) NEW_LINE return ( f % 10 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 30 NEW_LINE if ( isMultipleOf10 ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 | fungsi yang memeriksa sama ada nombor adalah kuasa 2; Kes asas '1' adalah satu -satunya nombor ganjil yang merupakan kuasa 2 (2 ^ 0); Semua nombor ganjil yang lain bukan kuasa 2; panggilan fungsi rekursif; Kod pemacu; Benar; Palsu", "code": "def powerof2 ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT elif n % 2 != 0 or n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return powerof2 ( n / 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( powerof2 ( 64 ) ) NEW_LINE print ( powerof2 ( 12 ) ) NEW_LINE DEDENT"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 | Fungsi untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Kod pemacu", "code": "def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"}
{"text": "Program untuk mencari sama ada nombor tertentu adalah kuasa 2 | Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "def isPowerofTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( n & ( ~ ( n - 1 ) ) ) == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( isPowerofTwo ( 30 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerofTwo ( 128 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"}
{"text": "Kuasa terkecil 2 yang lebih besar daripada atau sama dengan jumlah unsur array | Berfungsi untuk mencari kuasa terdekat 2; Nombornya; Jika sudah menjadi kuasa 2; Cari kuasa seterusnya 2; Berfungsi untuk mencari memori yang digunakan; Jumlah array; Melintasi dan mencari jumlah array; Fungsi panggilan untuk mencari kuasa terdekat 2; Kod pemacu", "code": "def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT def memoryUsed ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT nearest = nextPowerOf2 ( sum ) NEW_LINE return nearest NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( memoryUsed ( arr , n ) ) NEW_LINE"}
{"text": "Toggling k | Kod python3 untuk bertukar -tukar k - th bit n; Kod pemacu", "code": "def toggleKthBit ( n , k ) : NEW_LINE INDENT return ( n ^ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT n = 5 NEW_LINE k = 1 NEW_LINE print ( toggleKthBit ( n , k ) ) NEW_LINE"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Program python untuk mencari kuasa terkecil 2 lebih besar daripada atau sama dengan n; Pertama n dalam keadaan di bawah adalah untuk kes di mana n adalah 0; Kod pemacu", "code": "def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT n = 0 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE"}
{"text": "Nombor kth dari set gandaan nombor A, B dan C | Berfungsi untuk mengembalikan GCD A dan B; Berfungsi untuk mengembalikan LCM A dan B; Berfungsi untuk mengembalikan elemen kth dari set yang diperlukan jika ia berganda A; Mula dan tamat untuk carian binari; Jika tiada jawapan yang dijumpai kembali - 1; Kemasukan dan pengecualian; Pelbagai harus lebih kecil; Pelbagai harus lebih besar; Berfungsi untuk mengembalikan elemen kth dari set yang diperlukan jika ia berbilang b; Mula dan tamat untuk carian binari; Jika tiada jawapan yang dijumpai kembali - 1; Kemasukan dan pengecualian; Pelbagai harus lebih kecil; Pelbagai harus lebih besar; Berfungsi untuk mengembalikan elemen kth dari set yang diperlukan jika ia berbilang C; Mula dan tamat untuk carian binari; Jika tiada jawapan yang dijumpai kembali - 1; Kemasukan dan pengecualian; Pelbagai harus lebih kecil; Pelbagai harus lebih besar; Berfungsi untuk mengembalikan elemen KTH dari set gandaan A, B dan C; Memohon carian binari pada gandaan A; Sekiranya elemen yang diperlukan bukanlah pelbagai A maka gandaan B dan C perlu diperiksa; Sekiranya elemen yang diperlukan bukanlah pelbagai atau pelbagai b maka gandaan C perlu diperiksa; Kod pemacu", "code": "def gcd ( A , B ) : NEW_LINE INDENT if ( B == 0 ) : NEW_LINE INDENT return A NEW_LINE DEDENT return gcd ( B , A % B ) NEW_LINE DEDENT def lcm ( A , B ) : NEW_LINE INDENT return ( A * B ) // gcd ( A , B ) NEW_LINE DEDENT def checkA ( A , B , C , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = K NEW_LINE ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE value = A * mid NEW_LINE divA = mid - 1 NEW_LINE divB = value // B - 1 if ( value % B == 0 ) else value // B NEW_LINE divC = value // C - 1 if ( value % C == 0 ) else value // C NEW_LINE divAB = value // lcm ( A , B ) - 1 if ( value % lcm ( A , B ) == 0 ) else value // lcm ( A , B ) NEW_LINE divBC = value // lcm ( C , B ) - 1 if ( value % lcm ( C , B ) == 0 ) else value // lcm ( C , B ) NEW_LINE divAC = value // lcm ( A , C ) - 1 if ( value % lcm ( A , C ) == 0 ) else value // lcm ( A , C ) NEW_LINE divABC = value // lcm ( A , lcm ( B , C ) ) - 1 if ( value % lcm ( A , lcm ( B , C ) ) == 0 ) else value // lcm ( A , lcm ( B , C ) ) NEW_LINE elem = divA + divB + divC - divAC - divBC - divAB + divABC NEW_LINE if ( elem == ( K - 1 ) ) : NEW_LINE INDENT ans = value NEW_LINE break NEW_LINE DEDENT elif ( elem > ( K - 1 ) ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def checkB ( A , B , C , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = K NEW_LINE ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE value = B * mid NEW_LINE divB = mid - 1 NEW_LINE if ( value % A == 0 ) : NEW_LINE INDENT divA = value // A - 1 NEW_LINE DEDENT else : value // A NEW_LINE if ( value % C == 0 ) : NEW_LINE INDENT divC = value // C - 1 NEW_LINE DEDENT else : value // C NEW_LINE if ( value % lcm ( A , B ) == 0 ) : NEW_LINE INDENT divAB = value // lcm ( A , B ) - 1 NEW_LINE DEDENT else : value // lcm ( A , B ) NEW_LINE if ( value % lcm ( C , B ) == 0 ) : NEW_LINE INDENT divBC = value // lcm ( C , B ) - 1 NEW_LINE DEDENT else : value // lcm ( C , B ) NEW_LINE if ( value % lcm ( A , C ) == 0 ) : NEW_LINE INDENT divAC = value // lcm ( A , C ) - 1 NEW_LINE DEDENT else : value // lcm ( A , C ) NEW_LINE if ( value % lcm ( A , lcm ( B , C ) ) == 0 ) : NEW_LINE INDENT divABC = value // lcm ( A , lcm ( B , C ) ) - 1 NEW_LINE DEDENT else : value // lcm ( A , lcm ( B , C ) ) NEW_LINE elem = divA + divB + divC - divAC - divBC - divAB + divABC NEW_LINE if ( elem == ( K - 1 ) ) : NEW_LINE INDENT ans = value NEW_LINE break NEW_LINE DEDENT elif ( elem > ( K - 1 ) ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def checkC ( A , B , C , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = K NEW_LINE ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE value = C * mid NEW_LINE divC = mid - 1 NEW_LINE if ( value % B == 0 ) : NEW_LINE INDENT divB = value // B - 1 NEW_LINE DEDENT else : value // B NEW_LINE if ( value % A == 0 ) : NEW_LINE INDENT divA = value // A - 1 NEW_LINE DEDENT else : value // A NEW_LINE if ( value % lcm ( A , B ) == 0 ) : NEW_LINE INDENT divAB = value // lcm ( A , B ) - 1 NEW_LINE DEDENT else : value // lcm ( A , B ) NEW_LINE if ( value % lcm ( C , B ) == 0 ) : NEW_LINE INDENT divBC = value // lcm ( C , B ) - 1 NEW_LINE DEDENT else : value // lcm ( C , B ) NEW_LINE if ( value % lcm ( A , C ) == 0 ) : NEW_LINE INDENT divAC = value // lcm ( A , C ) - 1 NEW_LINE DEDENT else : value // lcm ( A , C ) NEW_LINE if ( value % lcm ( A , lcm ( B , C ) ) == 0 ) : NEW_LINE INDENT divABC = value // lcm ( A , lcm ( B , C ) ) - 1 NEW_LINE DEDENT else : value // lcm ( A , lcm ( B , C ) ) NEW_LINE elem = divA + divB + divC - divAC - divBC - divAB + divABC NEW_LINE if ( elem == ( K - 1 ) ) : NEW_LINE INDENT ans = value NEW_LINE break NEW_LINE DEDENT elif ( elem > ( K - 1 ) ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def findKthMultiple ( A , B , C , K ) : NEW_LINE INDENT res = checkA ( A , B , C , K ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT res = checkB ( A , B , C , K ) NEW_LINE DEDENT if ( res == - 1 ) : NEW_LINE INDENT res = checkC ( A , B , C , K ) NEW_LINE DEDENT return res NEW_LINE DEDENT A = 2 NEW_LINE B = 4 NEW_LINE C = 5 NEW_LINE K = 5 NEW_LINE print ( findKthMultiple ( A , B , C , K ) ) NEW_LINE"}
{"text": "Tambah elemen dalam mula menyusun array | Variasi Stalin Sort | Berfungsi untuk menyusun array; Iterator <Integer> index = arr. iterator (); ; Kod pemacu; Panggilan fungsi", "code": "def variationStalinsort ( arr ) : NEW_LINE INDENT j = 0 NEW_LINE while True : NEW_LINE INDENT moved = 0 NEW_LINE for i in range ( len ( arr ) - 1 - j ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT arr . insert ( moved , arr . pop ( i + 1 ) ) NEW_LINE moved += 1 NEW_LINE DEDENT DEDENT j += 1 NEW_LINE if moved == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 4 , 3 , 6 , 5 , 8 , 7 , 10 , 9 ] NEW_LINE print ( variationStalinsort ( arr ) ) NEW_LINE DEDENT"}
{"text": "Susun array yang mengandungi nilai 1 hingga n dalam o (n) menggunakan jenis kitaran | Berfungsi untuk mencetak elemen array; Melintasi array; Berfungsi untuk menyusun array dalam O (n); Melintasi array; Jika elemen semasa berada pada kedudukan yang betul; Lain menukar elemen semasa dengan kedudukan yang betul; Swap nilai arr [i] dan arr [arr [i] - 1]; Kod pemacu; Fungsi panggilan untuk menyusun array; Fungsi panggilan untuk mencetak array", "code": "def printArray ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def sortArray ( arr , N ) : NEW_LINE INDENT i = 0 NEW_LINE while i < N : NEW_LINE INDENT if arr [ i ] == i + 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = arr [ i ] NEW_LINE temp2 = arr [ arr [ i ] - 1 ] NEW_LINE arr [ i ] = temp2 NEW_LINE arr [ temp1 - 1 ] = temp1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 5 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE sortArray ( arr , N ) NEW_LINE printArray ( arr , N ) NEW_LINE DEDENT"}
{"text": "Jumlah maksimum nilai n item dalam 0 | Berfungsi untuk mencari nilai maksimum; keadaan asas; Unsur k telah dikurangkan kepada separuh daripada berat badan mereka; Jangan sertakan item; Jika berat item kurang daripada atau sama dengan berat yang tinggal maka masukkan item; Mengembalikan maksimum kedua -dua kes; Jika pengurangan berat badan kepada separuh mungkin; Langkau item; Sertakan item dengan berat penuh jika berat item kurang daripada berat badan yang tinggal; Sertakan item dengan separuh berat jika separuh berat item kurang daripada berat badan yang tinggal; Mengembalikan maksimum semua 3 kes; Kod pemacu", "code": "def maximum ( value , weight , weight1 , flag , K , index , val_len ) : NEW_LINE INDENT if ( index >= val_len ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( flag == K ) : NEW_LINE INDENT skip = maximum ( value , weight , weight1 , flag , K , index + 1 , val_len ) NEW_LINE full = 0 NEW_LINE if ( weight [ index ] <= weight1 ) : NEW_LINE INDENT full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 , val_len ) NEW_LINE DEDENT return max ( full , skip ) NEW_LINE DEDENT else : NEW_LINE INDENT skip = maximum ( value , weight , weight1 , flag , K , index + 1 , val_len ) NEW_LINE full = 0 NEW_LINE half = 0 NEW_LINE if ( weight [ index ] <= weight1 ) : NEW_LINE INDENT full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 , val_len ) NEW_LINE DEDENT if ( weight [ index ] / 2 <= weight1 ) : NEW_LINE INDENT half = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] / 2 , flag , K , index + 1 , val_len ) NEW_LINE DEDENT return max ( full , max ( skip , half ) ) NEW_LINE DEDENT DEDENT value = [ 17 , 20 , 10 , 15 ] NEW_LINE weight = [ 4 , 2 , 7 , 5 ] NEW_LINE K = 1 NEW_LINE W = 4 NEW_LINE val_len = len ( value ) NEW_LINE print ( maximum ( value , weight , W , 0 , K , 0 , val_len ) ) NEW_LINE"}
{"text": "D | Program Python3 untuk mencari saiz set dominasi minimum pokok; Definisi nod pokok; Fungsi penolong yang memperuntukkan nod baru; Array DP untuk precompute dan menyimpan hasilnya; mindominatingsettion untuk mengembalikan saiz set dominasi minimum array; Kes asas; Menetapkan nilai wajib jika diperlukan; Semak sama ada jawapannya telah dikira; Jika ia adalah wajib untuk memilih nod; Pilih nod dan tetapkan anak -anaknya seperti yang dilindungi; Jika ia dilindungi; Sekiranya nod semasa tidak dilindungi atau tidak perlu dipilih secara paksa; Simpan hasilnya; Kod pemacu; Membina pokok", "code": "N = 1005 NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT node = Node ( data ) NEW_LINE return node NEW_LINE DEDENT dp = [ [ [ - 1 for i in range ( 5 ) ] for j in range ( 5 ) ] for k in range ( N ) ] ; NEW_LINE def minDominatingSet ( root , covered , compulsory ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( not root . left and not root . right and not covered ) : NEW_LINE INDENT compulsory = True ; NEW_LINE DEDENT if ( dp [ root . data ] [ covered ] [ compulsory ] != - 1 ) : NEW_LINE INDENT return dp [ root . data ] [ covered ] [ compulsory ] ; NEW_LINE DEDENT if ( compulsory ) : NEW_LINE INDENT dp [ root . data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; NEW_LINE return dp [ root . data ] [ covered ] [ compulsory ] NEW_LINE DEDENT if ( covered ) : NEW_LINE INDENT dp [ root . data ] [ covered ] [ compulsory ] = min ( 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; NEW_LINE return dp [ root . data ] [ covered ] [ compulsory ] NEW_LINE DEDENT ans = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; NEW_LINE if ( root . left ) : NEW_LINE INDENT ans = min ( ans , minDominatingSet ( root . left , 0 , 1 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT ans = min ( ans , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 1 ) ) ; NEW_LINE DEDENT dp [ root . data ] [ covered ] [ compulsory ] = ans ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) ; NEW_LINE root . left = newNode ( 2 ) ; NEW_LINE root . left . left = newNode ( 3 ) ; NEW_LINE root . left . right = newNode ( 4 ) ; NEW_LINE root . left . left . left = newNode ( 5 ) ; NEW_LINE root . left . left . left . left = newNode ( 6 ) ; NEW_LINE root . left . left . left . right = newNode ( 7 ) ; NEW_LINE root . left . left . left . right . right = newNode ( 10 ) ; NEW_LINE root . left . left . left . left . left = newNode ( 8 ) ; NEW_LINE root . left . left . left . left . right = newNode ( 9 ) ; NEW_LINE print ( minDominatingSet ( root , 0 , 0 ) ) NEW_LINE DEDENT"}
{"text": "Bilangan subset dengan jumlah sifar | Python3 pelaksanaan pendekatan di atas; pembolehubah untuk menyimpan negeri -negeri DP; Untuk mencari bilangan subset dengan jumlah yang sama dengan 0. Oleh kerana S boleh menjadi negatif, kami akan memaksimumkannya untuk menjadikannya positif; Kes asas; Mengembalikan nilai jika keadaan sudah diselesaikan; Jika Negeri tidak dikunjungi, maka teruskan; Hubungan berulang; Mengembalikan nilai; Kod pemacu", "code": "import numpy as np NEW_LINE maxSum = 100 NEW_LINE arrSize = 51 NEW_LINE dp = np . zeros ( ( arrSize , maxSum ) ) ; NEW_LINE visit = np . zeros ( ( arrSize , maxSum ) ) ; NEW_LINE def SubsetCnt ( i , s , arr , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( visit [ i ] [ s + arrSize ] ) : NEW_LINE INDENT return dp [ i ] [ s + arrSize ] ; NEW_LINE DEDENT visit [ i ] [ s + arrSize ] = 1 ; NEW_LINE dp [ i ] [ s + arrSize ] = ( SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ) ; NEW_LINE return dp [ i ] [ s + arrSize ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 2 , 2 , - 4 , - 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( SubsetCnt ( 0 , 0 , arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Nombor Tetranacci | Berfungsi untuk mencetak nombor tetranacci N - th; Memulakan empat nombor pertama untuk kes asas; mengisytiharkan pemboleh ubah semasa; Gelung untuk menambah empat nombor sebelumnya untuk setiap nombor bermula dari 4 dan kemudian berikan pertama, kedua, ketiga hingga kedua, ketiga, keempat dan curr masing -masing; Kod pemacu", "code": "def printTetra ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT first = 0 ; NEW_LINE second = 1 ; NEW_LINE third = 1 ; NEW_LINE fourth = 2 ; NEW_LINE curr = 0 ; NEW_LINE if ( n == 0 ) : NEW_LINE INDENT print ( first ) ; NEW_LINE DEDENT elif ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( second ) ; NEW_LINE DEDENT elif ( n == 3 ) : NEW_LINE INDENT print ( fourth ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 4 , n + 1 ) : NEW_LINE INDENT curr = first + second + third + fourth ; NEW_LINE first = second ; NEW_LINE second = third ; NEW_LINE third = fourth ; NEW_LINE fourth = curr ; NEW_LINE DEDENT DEDENT print ( curr ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE printTetra ( n ) ; NEW_LINE"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Fungsi rekursif yang digunakan oleh Countways; Kod pemacu", "code": "def countWays ( n ) : NEW_LINE INDENT res = [ 0 ] * ( n + 2 ) NEW_LINE res [ 0 ] = 1 NEW_LINE res [ 1 ] = 1 NEW_LINE res [ 2 ] = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT n = 4 NEW_LINE print ( countWays ( n ) ) NEW_LINE"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Fungsi rekursif yang digunakan oleh Countways; mengisytiharkan tiga pembolehubah dan memegang cara untuk tiga tangga pertama; D = 0 Pembolehubah Keempat; Bermula dari 4 seperti yang telah dikira untuk 3 tangga; Program pemacu untuk menguji fungsi di atas", "code": "def countWays ( n ) : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 4 NEW_LINE if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return c NEW_LINE DEDENT for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = c + b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE DEDENT return d NEW_LINE DEDENT n = 4 NEW_LINE print ( countWays ( n ) ) NEW_LINE"}
{"text": "Subset Jumlah Masalah di O (SUM) Ruang |  ; Memulakan dengan 1 sebagai jumlah 0 selalu mungkin; gelung untuk melalui setiap elemen array elemen; untuk menukar nilai o Semua nilai jumlah yang mungkin kepada Benar; Sekiranya sasaran mungkin kembali benar lain palsu; Kod pemacu", "code": "def isPossible ( elements , target ) : NEW_LINE INDENT dp = [ False ] * ( target + 1 ) NEW_LINE dp [ 0 ] = True NEW_LINE for ele in elements : NEW_LINE INDENT for j in range ( target , ele - 1 , - 1 ) : NEW_LINE INDENT if dp [ j - ele ] : NEW_LINE INDENT dp [ j ] = True NEW_LINE DEDENT DEDENT DEDENT return dp [ target ] NEW_LINE DEDENT arr = [ 6 , 2 , 5 ] NEW_LINE target = 7 NEW_LINE if isPossible ( arr , target ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text": "Pengaturcaraan Dinamik | Tinggi | Mengembalikan jumlah tugas maksimum yang boleh dilakukan sehingga hari n; Jika n kurang daripada sama dengan 0, maka tiada penyelesaian wujud; Menentukan tugas mana yang hendak dipilih pada hari n, kemudian mengembalikan maksimum sehingga hari itu; Kod pemacu", "code": "def maxTasks ( high , low , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE high = [ 3 , 6 , 8 , 7 , 6 ] NEW_LINE low = [ 1 , 5 , 4 , 5 , 3 ] NEW_LINE print ( maxTasks ( high , low , n ) ) ; NEW_LINE DEDENT"}
{"text": "Watak kth selepas menggantikan setiap watak rentetan dengan kekerapannya tepat x kali | Program Python3 untuk pendekatan di atas; Fungsi untuk mencari watak kth selepas x hari; Pembolehubah untuk menyimpan kthchar; Melintasi rentetan; Menukar char ke int; Hitung watak; Jika k kurang daripada jumlah daripada ans = str [i]; Jawapan kembali; Diberikan input; Panggilan fungsi", "code": "import math NEW_LINE def FindKthChar ( Str , K , X ) : NEW_LINE INDENT ans = ' ▁ ' NEW_LINE Sum = 0 NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT digit = ord ( Str [ i ] ) - 48 NEW_LINE Range = int ( math . pow ( digit , X ) ) NEW_LINE Sum += Range NEW_LINE if ( K <= Sum ) : NEW_LINE INDENT ans = Str [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT Str = \"123\" NEW_LINE K = 9 NEW_LINE X = 3 NEW_LINE ans = FindKthChar ( Str , K , X ) NEW_LINE print ( ans ) NEW_LINE"}
{"text": "Jumlah pasangan watak dari dua rentetan, dengan bilangan bit set yang sama dalam nilai ASCII mereka | Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Berfungsi untuk mengembalikan kiraan pasangan yang sah; Kekerapan kedai bilangan bit yang ditetapkan untuk S1; Kekerapan kedai bilangan bit yang ditetapkan untuk S2; Kirakan jumlah pasangan; Mengembalikan kiraan pasangan yang sah; Kod pemacu", "code": "def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE arr1 = [ 0 ] * 7 ; arr2 = [ 0 ] * 7 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s1 [ i ] ) ) NEW_LINE arr1 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s2 [ i ] ) ) ; NEW_LINE arr2 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeks \" ; NEW_LINE s2 = \" forgeeks \" ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT"}
{"text": "Kira perkataan dalam rentetan yang diberikan | Program Python3 untuk mengira perkataan dalam rentetan yang diberikan; Mengembalikan bilangan perkataan dalam rentetan; kiraan perkataan; Imbas semua watak satu demi satu; Jika watak seterusnya adalah pemisah, tetapkan keadaan sebagai keluar; Jika watak seterusnya bukan pemisah perkataan dan keadaan keluar, maka tetapkan keadaan seperti dalam dan kiraan kata kenaikan; Mengembalikan bilangan perkataan; Kod pemacu", "code": "OUT = 0 NEW_LINE IN = 1 NEW_LINE def countWords ( string ) : NEW_LINE INDENT state = OUT NEW_LINE wc = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ' ▁ ' or string [ i ] ==   ' ' ▁ or ▁ string [ i ] ▁ = = ▁ ' \t ' ) : NEW_LINE INDENT state = OUT NEW_LINE DEDENT elif state == OUT : NEW_LINE INDENT state = IN NEW_LINE wc += 1 NEW_LINE DEDENT DEDENT return wc NEW_LINE DEDENT string =   \" One two three NEW_LINE INDENT four five   \" NEW_LINE DEDENT print ( \" No . ▁ of ▁ words ▁ : ▁ \" + str ( countWords ( string ) ) ) NEW_LINE"}
{"text": "Nombor Enneadecagonal | Berfungsi untuk mencari nombor enneadecagonal nth; Formula untuk mengira nombor enneadecagonal nth; Kod pemacu", "code": "def nthEnneadecagonal ( n ) : NEW_LINE INDENT return ( 17 * n * n - 15 * n ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( n , \" th ▁ Enneadecagonal ▁ number ▁ : \" , nthEnneadecagonal ( n ) ) NEW_LINE DEDENT"}
{"text": "Kawasan lingkaran yang dilampirkan dari persegi | Program Python3 untuk mencari kawasan bulatan yang dilampirkan; Fungsi utiliti; Kod pemacu", "code": "PI = 3.14159265 NEW_LINE def areacircumscribed ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 ) ) NEW_LINE DEDENT a = 6 NEW_LINE print ( \" ▁ Area ▁ of ▁ an ▁ circumscribed ▁ circle ▁ is ▁ : \" , round ( areacircumscribed ( a ) , 2 ) ) NEW_LINE"}
{"text": "Cari item n yang diedarkan dari item tak terhingga jenis tak terhingga berdasarkan syarat -syarat yang diberikan | Berfungsi untuk mencari jenis item yang diberikan mengikut peraturan yang diberikan; Menyimpan kiraan item yang diberikan pada setiap langkah; Melangkah untuk mencari hari ke hari yang diberikan diberikan; Cari bilangan hadiah yang diberikan pada hari adalah hari * (hari + 1) / 2; Melangkah ke atas jenis; Mengembalikan jenis yang dihasilkan; Kod pemacu", "code": "def itemType ( n ) : NEW_LINE INDENT count = 0 NEW_LINE day = 1 NEW_LINE while ( count + day * ( day + 1 ) // 2 < n ) : NEW_LINE INDENT count += day * ( day + 1 ) // 2 ; NEW_LINE day += 1 NEW_LINE DEDENT type = day NEW_LINE while ( type > 0 ) : NEW_LINE INDENT count += type NEW_LINE if ( count >= n ) : NEW_LINE INDENT return type NEW_LINE DEDENT type -= 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( itemType ( N ) ) NEW_LINE DEDENT"}
{"text": "Semak jika senarai yang dipautkan disusun (berulang dan rekursif) | Nod senarai yang dipautkan; fungsi untuk menyemak senarai yang dipautkan disusun mengikut urutan menurun atau tidak; Melintasi senarai sehingga nod terakhir dan kembali palsu jika nod lebih kecil daripada atau sama dengan yang seterusnya. ; Kod pemacu", "code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data ; NEW_LINE self . next = next ; NEW_LINE DEDENT DEDENT def isSortedDesc ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT while ( head . next != None ) : NEW_LINE INDENT t = head ; NEW_LINE if ( t . data <= t . next . data ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT head = head . next NEW_LINE DEDENT return True ; NEW_LINE DEDENT def newNode ( data ) : NEW_LINE INDENT temp = Node ( 0 ) ; NEW_LINE temp . next = None ; NEW_LINE temp . data = data ; NEW_LINE return temp ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = newNode ( 7 ) ; NEW_LINE head . next = newNode ( 5 ) ; NEW_LINE head . next . next = newNode ( 4 ) ; NEW_LINE head . next . next . next = newNode ( 3 ) ; NEW_LINE if ( isSortedDesc ( head ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"text": "Panjang maksimum berturut -turut 1 s atau 0 s selepas membalikkan kebanyakan watak K | Berfungsi untuk mencari segmen berterusan maksimum aksara C selepas membalikkan kebanyakan aksara K; Menyimpan panjang maksimum; Menyimpan kiraan char 'c; Permulaan tetingkap; Keluarkan tambahan 'c' dari kiri; Meningkatkan nilai kiri; Mengemas kini panjang maksimum aksara CH; Fungsi untuk mencari panjang maksimum 0 s atau 1 s dengan membalikkan kebanyakan aksara K pada rentetan; Cetak maksimum panjang maksimum 0 s atau 1 s; Kod pemacu", "code": "def maxLength ( str , n , c , k ) : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT ' NEW_LINE INDENT cnt = 0 NEW_LINE left = 0 NEW_LINE for right in range ( 0 , n ) : NEW_LINE INDENT if ( str [ right ] == c ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT while ( cnt > k ) : NEW_LINE INDENT if ( str [ left ] == c ) : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT left += 1 NEW_LINE DEDENT ans = max ( ans , right - left + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def maxConsecutiveSegment ( S , K ) : NEW_LINE INDENT N = len ( S ) NEW_LINE return max ( maxLength ( S , N , '0' , K ) , maxLength ( S , N , '1' , K ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"1001\" NEW_LINE K = 1 NEW_LINE print ( maxConsecutiveSegment ( S , K ) ) NEW_LINE DEDENT"}
{"text": "Kurangkan syiling yang diperlukan untuk mendapatkan semua nilai yang mungkin sehingga n | Fungsi untuk mencari kiraan minimum {1, 2, 5} syiling bernilai diperlukan untuk membuat perubahan semua nilai dalam julat [1, n]; Bilangan 5 duit syiling yang diperlukan; Bilangan 1 duit syiling yang diperlukan; Bilangan 2 syiling bernilai diperlukan; Kod pemacu", "code": "def find ( N ) : NEW_LINE INDENT F = int ( ( N - 4 ) / 5 ) NEW_LINE if ( ( N - 5 * F ) % 2 ) == 0 : NEW_LINE INDENT O = 2 NEW_LINE DEDENT else : NEW_LINE INDENT O = 1 NEW_LINE DEDENT T = ( N - 5 * F - O ) // 2 NEW_LINE print ( \" Count ▁ of ▁ 5 ▁ valueds ▁ coins : ▁ \" , F ) NEW_LINE print ( \" Count ▁ of ▁ 2 ▁ valueds ▁ coins : ▁ \" , T ) NEW_LINE print ( \" Count ▁ of ▁ 1 ▁ valueds ▁ coins : ▁ \" , O ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE find ( N ) NEW_LINE DEDENT"}
{"text": "Semak jika diberikan rentetan adalah substring rentetan yang dibentuk oleh penggabungan berulang z ke a | Pemeriksaan fungsi jika diberikan sah atau tidak dan mencetak output; Pembolehubah bendera Boolean untuk menandakan jika diberikan adalah sah; Melintasi rentetan yang diberikan; Jika watak bersebelahan berbeza dengan 1; Jika watak 'A' diikuti oleh 4; Lain flip bendera dan pecahkan dari gelung; Output mengikut pemboleh ubah bendera; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "def checkInfinite ( s ) : NEW_LINE INDENT flag = 1 NEW_LINE N = len ( s ) NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( s [ i ] == chr ( ord ( s [ i + 1 ] ) + 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( s [ i ] == ' a ' and s [ i + 1 ] == ' z ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" ecbaz \" NEW_LINE checkInfinite ( s ) NEW_LINE DEDENT"}
{"text": "Perubahan minimum dalam lorong yang diperlukan untuk menyeberang semua halangan | Berfungsi untuk mencari bilangan minimum perubahan lorong yang diperlukan; Sekiranya terdapat halangan, maka tambahkan nilai yang sangat besar; Tambah nilai minimum untuk memindahkan Forword dengan atau tanpa melintasi halangan; Mengembalikan nilai minimum dp [0], dp [1] dan dp [2]; Kod pemacu", "code": "def minChangeInLane ( barrier , n ) : NEW_LINE INDENT dp = [ 1 , 0 , 1 ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT val = barrier [ j ] NEW_LINE if ( val > 0 ) : NEW_LINE INDENT dp [ val - 1 ] = 1000000 NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT if ( val != i + 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT return min ( dp [ 0 ] , min ( dp [ 1 ] , dp [ 2 ] ) ) NEW_LINE DEDENT barrier = [ 0 , 1 , 2 , 3 , 0 ] NEW_LINE N = len ( barrier ) NEW_LINE print ( minChangeInLane ( barrier , N ) ) NEW_LINE"}
{"text": "Pertanyaan untuk mengira kumpulan pelajar N yang mungkin mempunyai jumlah penilaian dalam julat yang diberikan | Fungsi untuk mengira bilangan cara untuk mendapatkan kumpulan jumlah yang diberikan; Arahan DP Inisiasi; Tandakan semua nilai baris 1 sebagai 1 sejak tikar [0] [i] adalah semua jumlah yang mungkin dalam baris pertama; Betulkan baris ith; Betulkan jumlahnya; Melewati semua nilai baris ith; Jika jumlah boleh diperolehi; Cari Jumlah awalan baris terakhir; Melintasi setiap pertanyaan; Tidak ada cara untuk membentuk kumpulan; Kod pemacu; Diberikan N Batch dan K pelajar; Diberikan penilaian; Panggilan fungsi", "code": "def numWays ( ratings , queries , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 10002 ) ] for j in range ( n ) ] ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT dp [ 0 ] [ ratings [ 0 ] [ i ] ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for sum in range ( 10001 ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT if ( sum >= ratings [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ sum ] += dp [ i - 1 ] [ sum - ratings [ i ] [ j ] ] ; NEW_LINE DEDENT DEDENT DEDENT DEDENT for sum in range ( 1 , 10001 ) : NEW_LINE INDENT dp [ n - 1 ] [ sum ] += dp [ n - 1 ] [ sum - 1 ] ; NEW_LINE DEDENT for q in range ( len ( queries ) ) : NEW_LINE INDENT a = queries [ q ] [ 0 ] ; NEW_LINE b = queries [ q ] [ 1 ] ; NEW_LINE print ( dp [ n - 1 ] [ b ] - dp [ n - 1 ] [ a - 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 ; NEW_LINE K = 3 ; NEW_LINE ratings = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ; NEW_LINE queries = [ [ 6 , 6 ] , [ 1 , 6 ] ] ; NEW_LINE numWays ( ratings , queries , N , K ) ; NEW_LINE DEDENT"}
{"text": "Bilangan permutasi dengan inversions k | Tetapkan 2 | Berfungsi untuk mengira permutasi dengan penyongsangan k; Menyimpan bilangan permutasi dengan penyongsangan K; Jika n = 1 hanya 1 permutasi tanpa penyongsangan; Untuk k = 0 hanya 1 permutasi tanpa penyongsangan; Sebaliknya mengemas kini setiap keadaan DP mengikut hubungan reccurrance yang terbentuk; Cetak kiraan akhir; Kod pemacu; Diberikan n dan k; Panggilan fungsi", "code": "def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT dp = [ [ 0 ] * ( K + 1 ) ] * 2 NEW_LINE mod = 1000000007 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 0 , K + 1 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 1 if ( j == 0 ) else 0 NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT var = ( 0 if ( max ( j - ( i - 1 ) , 0 ) == 0 ) else dp [ 1 - i % 2 ] [ max ( j - ( i - 1 ) , 0 ) - 1 ] ) NEW_LINE dp [ i % 2 ] [ j ] = ( ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( var ) + mod ) % mod ) % mod ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N % 2 ] [ K ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE K = 2 NEW_LINE numberOfPermWithKInversion ( N , K ) NEW_LINE DEDENT"}
{"text": "Treasure and Cities | K ialah indeks semasa dan col adalah warna sebelumnya. ; Kes asas; Semak sama ada warna bandar ini sama dengan bandar yang dilawati sebelum ini; kembali maksimum kedua -dua pilihan; Kod pemacu; Pada mulanya bermula dengan warna 0", "code": "def MaxProfit ( treasure , color , n , k , col , A , B ) : NEW_LINE INDENT sum = 0 NEW_LINE if k == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if col == color [ k ] : NEW_LINE INDENT sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT A = - 5 NEW_LINE B = 7 NEW_LINE treasure = [ 4 , 8 , 2 , 9 ] NEW_LINE color = [ 2 , 2 , 6 , 2 ] NEW_LINE n = len ( color ) NEW_LINE print ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) NEW_LINE"}
{"text": "Nombor Tetranacci | Berfungsi untuk mengembalikan nombor tetranacci N; kes asas; kes asas; kes asas; berfungsi untuk mencetak nombor tetranacci nth; Kod pemacu", "code": "def printTetraRec ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ) ; NEW_LINE DEDENT DEDENT def printTetra ( n ) : NEW_LINE INDENT print ( printTetraRec ( n ) , end = \" ▁ \" ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE printTetra ( n ) ; NEW_LINE"}
{"text": "Jumlah produk semua gabungan diambil (1 hingga n) pada satu masa | untuk menyimpan jumlah kombinasi; Jika kita telah mencapai kedalaman yang mencukupi; Cari produk gabungan; Tambah produk ke dalam jumlah; rekursi untuk menghasilkan gabungan yang berbeza; berfungsi untuk mencetak jumlah produk semua gabungan yang diambil 1 - n pada satu masa; mewujudkan array sementara untuk menyimpan kombinasi; gabungan panggilan dengan r = i untuk gabungan yang diambil saya pada satu masa; memaparkan jumlah; Kod pemacu; menyimpan nombor dari 1 - n dalam array; Memanggil AllCombination", "code": "def Combination ( a , combi , n , r , depth , index ) : NEW_LINE INDENT global Sum NEW_LINE if index == r : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( r ) : NEW_LINE INDENT product = product * combi [ i ] NEW_LINE DEDENT Sum += product NEW_LINE return NEW_LINE DEDENT for i in range ( depth , n ) : NEW_LINE INDENT combi [ index ] = a [ i ] NEW_LINE Combination ( a , combi , n , r , i + 1 , index + 1 ) NEW_LINE DEDENT DEDENT def allCombination ( a , n ) : NEW_LINE INDENT global Sum NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT combi = [ 0 ] * i NEW_LINE Combination ( a , combi , n , i , 0 , 0 ) NEW_LINE print ( \" f ( \" , i , \" ) ▁ - - > ▁ \" , Sum ) NEW_LINE Sum = 0 NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE n = 5 NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = i + 1 NEW_LINE DEDENT allCombination ( a , n ) NEW_LINE"}
{"text": "Pengaturcaraan Dinamik | Tinggi |  ; Mengembalikan jumlah tugas maksimum yang boleh dilakukan sehingga hari n; Task_dp array yang menyimpan tugas maksimum yang dilakukan; Jika n = 0, tiada penyelesaian wujud; Jika n = 1, tugas usaha yang tinggi pada hari itu akan menjadi penyelesaian; Isi keseluruhan array menentukan tugas mana yang hendak dipilih pada hari I; Kod pemacu", "code": "/ * Returns the maximum among the 2 numbers * / NEW_LINE def max1 ( x , y ) : NEW_LINE INDENT return x if ( x > y ) else y ; NEW_LINE DEDENT def maxTasks ( high , low , n ) : NEW_LINE INDENT task_dp = [ 0 ] * ( n + 1 ) ; NEW_LINE task_dp [ 0 ] = 0 ; NEW_LINE task_dp [ 1 ] = high [ 0 ] ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT task_dp [ i ] = max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; NEW_LINE DEDENT return task_dp [ n ] ; NEW_LINE DEDENT n = 5 ; NEW_LINE high = [ 3 , 6 , 8 , 7 , 6 ] ; NEW_LINE low = [ 1 , 5 , 4 , 5 , 3 ] ; NEW_LINE print ( maxTasks ( high , low , n ) ) ; NEW_LINE"}
{"text": "Masalah Partition | DP | Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; hitung jumlah semua elemen; memulakan baris atas sebagai benar; memulakan lajur paling kiri, kecuali bahagian [0] [0], sebagai 0; Isi jadual partition dengan cara bawah; Uncomment Bahagian ini untuk mencetak jadual; Kod pemacu; Panggilan fungsi", "code": "def findPartition ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i , j = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if sum % 2 != 0 : NEW_LINE INDENT return false NEW_LINE DEDENT part = [ [ True for i in range ( n + 1 ) ] for j in range ( sum // 2 + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT part [ 0 ] [ i ] = True NEW_LINE DEDENT for i in range ( 1 , sum // 2 + 1 ) : NEW_LINE INDENT part [ i ] [ 0 ] = False NEW_LINE DEDENT for i in range ( 1 , sum // 2 + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT part [ i ] [ j ] = part [ i ] [ j - 1 ] NEW_LINE if i >= arr [ j - 1 ] : NEW_LINE INDENT part [ i ] [ j ] = ( part [ i ] [ j ] or part [ i - arr [ j - 1 ] ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return part [ sum // 2 ] [ n ] NEW_LINE DEDENT arr = [ 3 , 1 , 1 , 2 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE if findPartition ( arr , n ) == True : NEW_LINE INDENT print ( \" Can ▁ be ▁ divided ▁ into ▁ two \" , \" subsets ▁ of ▁ equal ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Can ▁ not ▁ be ▁ divided ▁ into ▁ \" , \" two ▁ subsets ▁ of ▁ equal ▁ sum \" ) NEW_LINE DEDENT"}
{"text": "Bilangan minimum tambahan x atau y aksara dari hujung ke depan yang diperlukan untuk mendapatkan rentetan yang diberikan | Berfungsi untuk mencari operasi minimum yang diperlukan untuk mendapatkan rentetan yang diberikan selepas menambahkan aksara M atau N dari hujung ke hadapan rentetan dalam setiap operasi; Simpan rentetan asal; Menyimpan kiraan operasi; Melintasi rentetan; Potong huruf dari akhir; Masukkan huruf potong untuk permulaan; Kemas kini j; Semak sama ada rentetan adalah sama; Potong n huruf dari hujung; Masukkan huruf potong n untuk permulaan; Kemas kini j; Semak sama ada rentetan adalah sama; Mengemas kini giliran; Diberikan rentetan s; Panggilan fungsi", "code": "def minimumOperations ( orig_str , m , n ) : NEW_LINE INDENT orig = orig_str NEW_LINE turn = 1 NEW_LINE j = 1 NEW_LINE for i in orig_str : NEW_LINE INDENT m_cut = orig_str [ - m : ] NEW_LINE orig_str = orig_str . replace ( ' ▁ ' , ' ' ) [ : - m ] NEW_LINE orig_str = m_cut + orig_str NEW_LINE j = j + 1 NEW_LINE if orig != orig_str : NEW_LINE INDENT turn = turn + 1 NEW_LINE n_cut = orig_str [ - n : ] NEW_LINE orig_str = orig_str . replace ( ' ▁ ' , ' ' ) [ : - n ] NEW_LINE orig_str = n_cut + orig_str NEW_LINE j = j + 1 NEW_LINE DEDENT if orig == orig_str : NEW_LINE INDENT break NEW_LINE DEDENT turn = turn + 1 NEW_LINE DEDENT print ( turn ) NEW_LINE DEDENT S = \" GeeksforGeeks \" NEW_LINE X = 5 NEW_LINE Y = 3 NEW_LINE minimumOperations ( S , X , Y ) NEW_LINE"}
{"text": "Putaran minimum diperlukan untuk mendapatkan rentetan yang sama | Set | Cetakan kejadian txt [] dalam pat []; Buat LPS [] yang akan memegang nilai akhiran awalan terpanjang untuk corak; Pra -proses corak (hitung array LPS []); Indeks untuk txt [], indeks untuk pat []; Tidak sepadan selepas perlawanan J; Jangan sepadan dengan LPS [0 .. LPS [J - 1]] aksara, mereka akan sepadan pula; Mengisi LPS [] untuk corak yang diberikan Pat [0. M - 1]; Panjang akhiran awalan terpanjang sebelumnya; LPS [0] sentiasa 0; Gelung mengira LPS [i] untuk i = 1 hingga m - 1; (pat [i]! = pat [_len]); Ini sukar. Pertimbangkan contohnya. AAACAAAA dan I = 7. Idea ini sama dengan langkah carian. ; Mengembalikan kiraan putaran untuk mendapatkan rentetan yang sama kembali; Bentuk rentetan tidak termasuk watak pertama dan menggabungkan rentetan pada akhir; Menukar rentetan ke array aksara; Gunakan algoritma carian KMP untuk mencarinya dalam masa O (n); Kod pemacu", "code": "def KMPSearch ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE lps = [ 0 ] * M NEW_LINE computeLPSArray ( pat , M , lps ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < N : NEW_LINE INDENT if pat [ j ] == txt [ i ] : NEW_LINE INDENT j += 1 NEW_LINE i += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT return i - j NEW_LINE j = lps [ j - 1 ] NEW_LINE DEDENT elif i < N and pat [ j ] != txt [ i ] : NEW_LINE INDENT if j != 0 : NEW_LINE INDENT j = lps [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def computeLPSArray ( pat , M , lps ) : NEW_LINE INDENT _len = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i < M : NEW_LINE INDENT if pat [ i ] == pat [ _len ] : NEW_LINE INDENT _len += 1 NEW_LINE lps [ i ] = _len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if _len != 0 : NEW_LINE INDENT _len = lps [ _len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def countRotations ( s ) : NEW_LINE INDENT s1 = s [ 1 : len ( s ) ] + s NEW_LINE pat = s [ : ] NEW_LINE text = s1 [ : ] NEW_LINE return 1 + KMPSearch ( pat , text ) NEW_LINE DEDENT s1 = \" geeks \" NEW_LINE print ( countRotations ( s1 ) ) NEW_LINE"}
{"text": "DFA untuk rentetan tidak berakhir dengan \"The\" | Fungsi ini adalah untuk keadaan permulaan (zeroth) DFA; Apabila menerima 'T' atau 'T' Goto State First (1); Fungsi ini adalah untuk keadaan pertama DFA; Apabila menerima 'T' atau 'T' Goto State First (1); Apabila menerima 'H' atau 'H' Goto kedua negeri (2); lain Goto State State (0); Fungsi ini adalah untuk keadaan kedua DFA; Apabila menerima 'E' atau 'E' Goto Negeri Ketiga (3) Lain Goto State State (0); Fungsi ini adalah untuk keadaan ketiga DFA; Apabila menerima 'T' atau 'T' Goto State First (1) Lain Goto State State (0); Panjang simpan tali; Kod pemacu", "code": "def start ( c ) : NEW_LINE INDENT if ( c == ' t ' or c == ' T ' ) : NEW_LINE INDENT dfa = 1 NEW_LINE DEDENT DEDENT def state1 ( c ) : NEW_LINE INDENT if ( c == ' t ' or c == ' T ' ) : NEW_LINE INDENT dfa = 1 NEW_LINE DEDENT elif ( c == ' h ' or c == ' H ' ) : NEW_LINE INDENT dfa = 2 NEW_LINE DEDENT else : NEW_LINE INDENT dfa = 0 NEW_LINE DEDENT DEDENT def state2 ( c ) : NEW_LINE INDENT if ( c == ' e ' or c == ' E ' ) : NEW_LINE INDENT dfa = 3 NEW_LINE DEDENT else : NEW_LINE INDENT dfa = 0 NEW_LINE DEDENT DEDENT def state3 ( c ) : NEW_LINE INDENT if ( c == ' t ' or c == ' T ' ) : NEW_LINE INDENT dfa = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dfa = 0 NEW_LINE DEDENT DEDENT def isAccepted ( string ) : NEW_LINE INDENT length = len ( string ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( dfa == 0 ) : NEW_LINE INDENT start ( string [ i ] ) NEW_LINE DEDENT elif ( dfa == 1 ) : NEW_LINE INDENT state1 ( string [ i ] ) NEW_LINE DEDENT elif ( dfa == 2 ) : NEW_LINE INDENT state2 ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT state3 ( string [ i ] ) NEW_LINE DEDENT DEDENT return ( dfa != 3 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" forTHEgeeks \" NEW_LINE DEDENT dfa = 0 NEW_LINE INDENT if isAccepted ( string ) : NEW_LINE INDENT print ( \" ACCEPTED \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NOT ▁ ACCEPTED \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Semak jika satu rentetan boleh ditukar kepada yang lain | Pelaksanaan Python3 pendekatan di atas. ; Fungsi untuk mencari dari algoritma disjoset; Fungsi untuk kesatuan dari algoritma disjoset; Fungsi untuk memeriksa sama ada satu rentetan boleh ditukar kepada yang lain. ; Semua watak diperiksa sama ada ia sama ada tidak diganti atau digantikan oleh watak yang sama menggunakan peta. ; Untuk memeriksa sama ada terdapat kitaran. Jika ya, maka mereka tidak boleh ditukar. Selain itu, mereka boleh ditukar. ; Fungsi untuk memulakan array induk untuk kesatuan dan mencari algoritma. ; Kod pemacu", "code": "parent = [ 0 ] * 256 NEW_LINE def find ( x ) : NEW_LINE INDENT if ( x != parent [ x ] ) : NEW_LINE INDENT parent [ x ] = find ( parent [ x ] ) NEW_LINE return parent [ x ] NEW_LINE DEDENT return x NEW_LINE DEDENT def join ( x , y ) : NEW_LINE INDENT px = find ( x ) NEW_LINE pz = find ( y ) NEW_LINE if ( px != pz ) : NEW_LINE INDENT parent [ pz ] = px NEW_LINE DEDENT DEDENT def convertible ( s1 , s2 ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] in mp ) : NEW_LINE INDENT mp [ s1 [ i ] ] = s2 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT if s1 [ i ] in mp and mp [ s1 [ i ] ] != s2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for it in mp : NEW_LINE INDENT if ( it == mp [ it ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( find ( ord ( it ) ) == find ( ord ( it ) ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT join ( ord ( it ) , ord ( it ) ) NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def initialize ( ) : NEW_LINE INDENT for i in range ( 256 ) : NEW_LINE INDENT parent [ i ] = i NEW_LINE DEDENT DEDENT s1 = \" abbcaa \" NEW_LINE s2 = \" bccdbb \" NEW_LINE initialize ( ) NEW_LINE if ( convertible ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Cetak Watak yang mempunyai frekuensi utama dalam urutan kejadian | Python 3 pelaksanaan pendekatan; Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mencetak aksara frekuensi utama mengikut urutan kejadian mereka; Berfungsi untuk membuat ayak untuk memeriksa prima; Untuk menyimpan kekerapan setiap watak rentetan; Kemas kini kekerapan setiap aksara; Traverse str -watak oleh watak; Jika kekerapan watak semasa adalah perdana; Kod pemacu", "code": "SIZE = 26 NEW_LINE from math import sqrt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printChar ( str , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , len ( str ) + 1 ) NEW_LINE freq = [ 0 for i in range ( SIZE ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prime [ freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] ] ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT"}
{"text": "Cetak Watak yang mempunyai frekuensi utama dalam urutan kejadian | Kod python untuk pendekatan di atas; Berfungsi untuk memeriksa prima; Mengira kekerapan semua watak menggunakan fungsi kaunter; Melintasi rentetan; Kod pemacu; lulus rentetan ke fungsi checkstring", "code": "from collections import Counter NEW_LINE import math NEW_LINE def prime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT max_div = math . floor ( math . sqrt ( n ) ) NEW_LINE for i in range ( 2 , 1 + max_div ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkString ( s ) : NEW_LINE INDENT freq = Counter ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if prime ( freq [ s [ i ] ] ) : NEW_LINE INDENT print ( s [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT s = \" geeksforgeeks \" NEW_LINE checkString ( s ) NEW_LINE"}
{"text": "Cetak Watak yang mempunyai frekuensi walaupun dalam urutan kejadian | Pelaksanaan Python3 pendekatan; Berfungsi untuk mencetak aksara kekerapan walaupun dalam urutan kejadian mereka; Untuk menyimpan kekerapan setiap watak dari tali yang memulakan semua elemen freq [] hingga 0; Kemas kini kekerapan setiap aksara; Melintasi watak rentetan oleh watak; Jika kekerapan watak semasa adalah walaupun; Kod pemacu", "code": "SIZE = 26 NEW_LINE def printChar ( string , n ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE n = len ( string ) NEW_LINE printChar ( string , n ) NEW_LINE DEDENT"}
{"text": "Bandingkan dua rentetan memandangkan hanya aksara alfanumerik | Berfungsi untuk memeriksa kesamaan alfanumerik kedua -dua rentetan; Perisytiharan Variabel; Panjang rentetan pertama; Panjang rentetan kedua; Untuk memeriksa setiap watak kedua -dua rentetan; Jika watak semasa rentetan pertama bukan watak alfanumerik, tingkatkan penunjuk I; Jika watak semasa rentetan kedua bukan watak alfanumerik, tingkatkan penunjuk j; Jika semua aksara alfanumerik kedua -dua rentetan adalah sama, maka kembali benar; Jika mana -mana aksara alfanumerik kedua -dua rentetan tidak sama, maka kembali palsu; Jika watak semasa dipadankan, tingkatkan kedua -dua petunjuk untuk memeriksa watak seterusnya; Jika tidak sama, maka kembali palsu; Berfungsi untuk mencetak sama atau tidak sama rata jika rentetan sama atau tidak; Semak kesamaan alfanumerik kedua -dua rentetan; Sekiranya kedua -duanya adalah sama dengan alfanumerik, cetak sama; sebaliknya mencetak tidak sama rata; Kod pemacu", "code": "def CompareAlphanumeric ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE while ( i <= len1 and j <= len2 ) : NEW_LINE INDENT while ( i < len1 and ( ( ( str1 [ i ] >= ' a ' and str1 [ i ] <= ' z ' ) or ( str1 [ i ] >= ' A ' and str1 [ i ] <= ' Z ' ) or ( str1 [ i ] >= '0' and str1 [ i ] <= '9' ) ) == False ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( j < len2 and ( ( ( str2 [ j ] >= ' a ' and str2 [ j ] <= ' z ' ) or ( str2 [ j ] >= ' A ' and str2 [ j ] <= ' Z ' ) or ( str2 [ j ] >= '0' and str2 [ j ] <= '9' ) ) == False ) ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( i == len1 and j == len2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def CompareAlphanumericUtil ( str1 , str2 ) : NEW_LINE INDENT res = CompareAlphanumeric ( str1 , str2 ) NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( \" Equal \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Unequal \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" Ram , ▁ Shyam \" NEW_LINE str2 = \" ▁ Ram ▁ - ▁ Shyam . \" NEW_LINE CompareAlphanumericUtil ( str1 , str2 ) NEW_LINE str1 = \" abc123\" NEW_LINE str2 = \"123abc \" NEW_LINE CompareAlphanumericUtil ( str1 , str2 ) NEW_LINE DEDENT"}
{"text": "Pertanyaan untuk mencetak watak yang berlaku bilangan maksimum kali dalam julat yang diberikan | Fungsi yang menjawab semua pertanyaan; Panjang rentetan; Bilangan pertanyaan; Arahan awalan; Melewati semua watak; Meningkatkan kiraan watak; Arahan anggaran untuk semua 26 aksara; Kemas kini array awalan; Jawab setiap pertanyaan; Julat; ITERATE untuk semua watak; Kali watak huruf kecil j berlaku sehingga indeks r - th; Tolak masa yang berlaku sehingga indeks (l - 1) th; Maksimum masa itu berlaku; Cetak jawapannya; Kod pemacu", "code": "def solveQueries ( Str , query ) : NEW_LINE INDENT ll = len ( Str ) NEW_LINE Q = len ( query ) NEW_LINE pre = [ [ 0 for i in range ( 256 ) ] for i in range ( ll ) ] NEW_LINE for i in range ( ll ) : NEW_LINE INDENT pre [ i ] [ ord ( Str [ i ] ) ] += 1 NEW_LINE if ( i ) : NEW_LINE INDENT for j in range ( 256 ) : NEW_LINE INDENT pre [ i ] [ j ] += pre [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( Q ) : NEW_LINE INDENT l = query [ i ] [ 0 ] NEW_LINE r = query [ i ] [ 1 ] NEW_LINE maxi = 0 NEW_LINE c = ' a ' NEW_LINE for j in range ( 256 ) : NEW_LINE INDENT times = pre [ r ] [ j ] NEW_LINE if ( l ) : NEW_LINE INDENT times -= pre [ l - 1 ] [ j ] NEW_LINE DEDENT if ( times > maxi ) : NEW_LINE INDENT maxi = times NEW_LINE c = chr ( j ) NEW_LINE DEDENT DEDENT print ( \" Query ▁ \" , i + 1 , \" : ▁ \" , c ) NEW_LINE DEDENT DEDENT Str = \" striver \" NEW_LINE query = [ [ 0 , 1 ] , [ 1 , 6 ] , [ 5 , 6 ] ] NEW_LINE solveQueries ( Str , query ) NEW_LINE"}
{"text": "Semak sama ada rentetan yang diberikan boleh dijana selepas menyatukan rentetan yang diberikan | Fungsi yang kembali benar jika pra adalah awalan str; Walaupun ada watak untuk dipadankan; Jika watak berbeza di mana -mana kedudukan; STR bermula dengan pra; Fungsi yang kembali benar jika Suff adalah akhiran str; Walaupun ada watak untuk dipadankan; Jika watak berbeza di mana -mana kedudukan; str berakhir dengan suff; Fungsi yang kembali benar jika str = a + b atau str = b + a; STR tidak boleh dihasilkan dengan menggabungkan A dan B; Jika str bermula dengan i. e. A adalah awalan str; Semak sama ada watak -watak yang lain adalah sama dengan b i. e. B adalah akhiran str; Jika str bermula dengan b i. e. B adalah awalan str; Semak sama ada watak -watak yang lain adalah sama dengan i. e. A adalah akhiran str; Kod pemacu", "code": "def startsWith ( str , pre ) : NEW_LINE INDENT strLen = len ( str ) NEW_LINE preLen = len ( pre ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < strLen and j < preLen ) : NEW_LINE INDENT if ( str [ i ] != pre [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def endsWith ( str , suff ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE j = len ( suff ) - 1 NEW_LINE while ( i >= 0 and j >= 0 ) : NEW_LINE INDENT if ( str [ i ] != suff [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def checkString ( str , a , b ) : NEW_LINE INDENT if ( len ( str ) != len ( a ) + len ( b ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( startsWith ( str , a ) ) : NEW_LINE INDENT if ( endsWith ( str , b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if ( startsWith ( str , b ) ) : NEW_LINE INDENT if ( endsWith ( str , a ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT str = \" GeeksforGeeks \" NEW_LINE a = \" Geeksfo \" NEW_LINE b = \" rGeeks \" NEW_LINE if ( checkString ( str , a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Cetak Watak yang mempunyai frekuensi ganjil mengikut urutan kejadian | Pelaksanaan Python3 pendekatan; Berfungsi untuk mencetak aksara frekuensi ganjil mengikut urutan kejadian mereka; Untuk menyimpan kekerapan setiap watak rentetan dan memulakan semua elemen freq [] hingga 0; Kemas kini kekerapan setiap aksara; Traverse str -watak oleh watak; Jika kekerapan watak semasa adalah ganjil; Kod pemacu", "code": "import sys NEW_LINE import math NEW_LINE def printChar ( str_ , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] ) % 2 == 1 : NEW_LINE INDENT print ( \" { } \" . format ( str_ [ i ] ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str_ = \" geeksforgeeks \" NEW_LINE n = len ( str_ ) NEW_LINE printChar ( str_ , n ) NEW_LINE DEDENT"}
{"text": "Bilangan minimum operasi untuk memindahkan semua aksara huruf besar sebelum semua aksara kes yang lebih rendah | Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan; Untuk menyimpan indeks huruf besar terakhir dan watak huruf kecil pertama; Cari watak huruf besar terakhir; Cari watak huruf kecil pertama; Jika semua watak adalah huruf besar atau huruf kecil; Kiraan aksara huruf besar yang muncul selepas watak huruf kecil pertama; Count huruf kecil yang muncul sebelum watak huruf besar terakhir; Mengembalikan operasi minimum yang diperlukan; Kod pemacu", "code": "def minOperations ( str , n ) : NEW_LINE INDENT lastUpper = - 1 NEW_LINE firstLower = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT lastUpper = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] . islower ( ) ) : NEW_LINE INDENT firstLower = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( lastUpper == - 1 or firstLower == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT countUpper = 0 NEW_LINE for i in range ( firstLower , n ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT countUpper += 1 NEW_LINE DEDENT DEDENT countLower = 0 NEW_LINE for i in range ( lastUpper ) : NEW_LINE INDENT if ( str [ i ] . islower ( ) ) : NEW_LINE INDENT countLower += 1 NEW_LINE DEDENT DEDENT return min ( countLower , countUpper ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geEksFOrGEekS \" NEW_LINE n = len ( str ) NEW_LINE print ( minOperations ( str , n ) ) NEW_LINE DEDENT"}
{"text": "Cari jumlah semua nombor pertunangan sehingga n | Program Python3 untuk mencari jumlah semua nombor pertunangan sehingga n; Berfungsi untuk mencari jumlah semua nombor pertunangan; Untuk menyimpan nombor pertunangan; Hitung jumlah pembahagi nombor_1; i = 2 kerana kita tidak mahu memasukkan 1 sebagai pembahagi. ; Jumlah semua nombor pertunangan sehingga n; Kod pemacu", "code": "import math NEW_LINE def Betrothed_Sum ( n ) : NEW_LINE INDENT Set = [ ] NEW_LINE for number_1 in range ( 1 , n ) : NEW_LINE INDENT sum_divisor_1 = 1 NEW_LINE i = 2 NEW_LINE while i * i <= number_1 : NEW_LINE INDENT if ( number_1 % i == 0 ) : NEW_LINE INDENT sum_divisor_1 = sum_divisor_1 + i NEW_LINE if ( i * i != number_1 ) : NEW_LINE INDENT sum_divisor_1 += number_1 // i NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT if ( sum_divisor_1 > number_1 ) : NEW_LINE INDENT number_2 = sum_divisor_1 - 1 NEW_LINE sum_divisor_2 = 1 NEW_LINE j = 2 NEW_LINE while j * j <= number_2 : NEW_LINE INDENT if ( number_2 % j == 0 ) : NEW_LINE INDENT sum_divisor_2 += j NEW_LINE if ( j * j != number_2 ) : NEW_LINE INDENT sum_divisor_2 += number_2 // j NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE DEDENT if ( sum_divisor_2 == number_1 + 1 and number_1 <= n and number_2 <= n ) : NEW_LINE INDENT Set . append ( number_1 ) NEW_LINE Set . append ( number_2 ) NEW_LINE DEDENT DEDENT DEDENT Summ = 0 NEW_LINE for i in Set : NEW_LINE INDENT if i <= n : NEW_LINE INDENT Summ += i NEW_LINE DEDENT DEDENT return Summ NEW_LINE DEDENT n = 78 NEW_LINE print ( Betrothed_Sum ( n ) ) NEW_LINE"}
{"text": "Kebarangkalian hujan pada hari n + 1 | | Fungsi untuk mencari kebarangkalian; kiraan kejadian 1; Cari kebarangkalian; Kod pemacu", "code": "def rainDayProbability ( a , n ) : NEW_LINE INDENT count = a . count ( 1 ) NEW_LINE m = count / n NEW_LINE return m NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( rainDayProbability ( a , n ) ) NEW_LINE DEDENT"}
{"text": "Program untuk mencari jumlah siri 1 + 1/2 ^ 2 + 1/3 ^ 3 + â € |. . + 1 / n ^ n | Fungsi untuk mengira siri berikut; Kod pemacu", "code": "def Series ( n ) : NEW_LINE INDENT sums = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ser = 1 / ( i ** i ) NEW_LINE sums += ser NEW_LINE DEDENT return sums NEW_LINE DEDENT n = 3 NEW_LINE res = round ( Series ( n ) , 5 ) NEW_LINE print ( res ) NEW_LINE"}
{"text": "Rentetan lexicographically terbesar yang terbentuk dalam langkah minimum dengan menggantikan watak -watak rentetan yang diberikan | Berfungsi untuk mencetak secara lexicographically rentetan terbesar yang diperolehi dalam proses mendapatkan rentetan yang mengandungi pertama N Lower Case English Alphabtes; Simpan kekerapan setiap watak; Melintasi rentetan s; Menyimpan watak -watak yang tidak muncul dalam s; Menyimpan indeks watak terbesar dalam array V, yang perlu diganti; Melintasi rentetan, s; Jika kekerapan S [i] lebih besar daripada 1 atau ia berada di luar julat; Menurunkan kekerapannya dengan 1; UPDATE S [I]; Penurunan j oleh 1; Melintasi rentetan, s; Menurunkan kekerapannya dengan 1; UPDATE S [I]; Kenaikan l oleh 1; Pulangan s; Diberikan input; Panggilan fungsi", "code": "def lexicographicallyMaximum ( S , N ) : NEW_LINE INDENT M = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if S [ i ] in M : NEW_LINE M [ S [ i ] ] += 1 NEW_LINE else : NEW_LINE INDENT M [ S [ i ] ] = 1 NEW_LINE DEDENT DEDENT V = [ ] NEW_LINE for i in range ( ord ( ' a ' ) , ord ( ' a ' ) + min ( N , 25 ) ) : NEW_LINE INDENT if i not in M : NEW_LINE INDENT V . append ( chr ( i ) ) NEW_LINE DEDENT DEDENT j = len ( V ) - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( ord ( S [ i ] ) >= ( ord ( ' a ' ) + min ( N , 25 ) ) or ( S [ i ] in M and M [ S [ i ] ] > 1 ) ) : NEW_LINE INDENT if ( ord ( V [ j ] ) < ord ( S [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT M [ S [ i ] ] -= 1 NEW_LINE S = S [ 0 : i ] + V [ j ] + S [ ( i + 1 ) : ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( l > j ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( ord ( S [ i ] ) >= ( ord ( ' a ' ) + min ( N , 25 ) ) or S [ i ] in M and M [ S [ i ] ] > 1 ) : NEW_LINE INDENT M [ S [ i ] ] -= 1 NEW_LINE S = S [ 0 : i ] + V [ l ] + S [ ( i + 1 ) : ] NEW_LINE l += 1 NEW_LINE DEDENT DEDENT s = list ( S ) NEW_LINE s [ len ( s ) - 1 ] = ' d ' NEW_LINE S = \" \" . join ( s ) NEW_LINE return S NEW_LINE DEDENT S = \" abccefghh \" NEW_LINE N = len ( S ) NEW_LINE print ( lexicographicallyMaximum ( S , N ) ) NEW_LINE"}
{"text": "Semak jika mana -mana subarray boleh dibuat palindromic dengan menggantikan kurang daripada separuh elemennya | Fungsi utiliti untuk memeriksa sama ada subarray boleh menjadi palindromic dengan menggantikan kurang daripada separuh unsur yang ada di dalamnya; Kedai kekerapan elemen array; Melintasi array; Kekerapan kemas kini setiap elemen array; Iterator di atas peta; Jika kekerapan mana -mana elemen melebihi 1; Sekiranya tiada pengulangan dijumpai; Berfungsi untuk memeriksa dan mencetak jika mana -mana subarray boleh dibuat palindromic dengan menggantikan kurang daripada separuh elemennya; Kod pemacu; Diberikan array arr []; Saiz array; Panggilan fungsi", "code": "def isConsistingSubarrayUtil ( arr , n ) : NEW_LINE INDENT mp = { } ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT for it in mp : NEW_LINE INDENT if ( mp [ it ] > 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT def isConsistingSubarray ( arr , N ) : NEW_LINE INDENT if ( isConsistingSubarrayUtil ( arr , N ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 1 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE isConsistingSubarray ( arr , N ) ; NEW_LINE DEDENT"}
{"text": "Nombor Fibonacci Komposit dari Arahan yang diberikan | Program Python3 untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari semua nombor Fibonacci sehingga maks; Simpan semua nombor Fibonacci sehingga max; Kedai elemen sebelumnya dari urutan Fibonacci; Kedai elemen sebelumnya dari urutan Fibonacci; Masukkan prev ke hashmap; Masukkan semua nombor Fibonacci sehingga maks; Masukkan curr ke hashmap; Kedai -kedai Curr Into Temp; Kemas kini curr; UPDATE PREV; Berfungsi untuk mencari semua nombor komposit sehingga maks; Isprime [i]: Kedai jika saya adalah nombor utama atau tidak; Kirakan semua nombor perdana sehingga maksimum menggunakan penapis eratosthenes; Jika p adalah nombor utama; Tetapkan semua pelbagai p sebagai bukan perdana; Fungsi untuk mencari nombor yang merupakan nombor komposit dan fibonacci; Menyimpan elemen terbesar array; Melintasi array arr []; Kemas kini Max; isprim [i] periksa saya adalah nombor utama atau tidak; Menyimpan semua nombor Fibonacci; Melintasi array arr []; Elemen semasa bukan nombor komposit; Jika elemen semasa adalah nombor fibonacci dan komposit; Cetak elemen semasa; Kod pemacu", "code": "import math NEW_LINE def createhashmap ( Max ) : NEW_LINE INDENT hashmap = { \" \" } NEW_LINE curr = 1 NEW_LINE prev = 0 NEW_LINE hashmap . add ( prev ) NEW_LINE while ( curr <= Max ) : NEW_LINE INDENT hashmap . add ( curr ) NEW_LINE temp = curr NEW_LINE curr = curr + prev NEW_LINE prev = temp NEW_LINE DEDENT return hashmap NEW_LINE DEDENT def SieveOfEratosthenes ( Max ) : NEW_LINE INDENT isPrime = [ 1 for x in range ( Max + 1 ) ] NEW_LINE isPrime [ 0 ] = 0 NEW_LINE isPrime [ 1 ] = 0 NEW_LINE for p in range ( 0 , int ( math . sqrt ( Max ) ) ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , Max , p ) : NEW_LINE INDENT isPrime [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT return isPrime NEW_LINE DEDENT def cntFibonacciPrime ( arr , N ) : NEW_LINE INDENT Max = arr [ 0 ] NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT Max = max ( Max , arr [ i ] ) NEW_LINE DEDENT isPrime = SieveOfEratosthenes ( Max ) NEW_LINE hashmap = createhashmap ( Max ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ( arr [ i ] in hashmap ) and ( not ( isPrime [ arr [ i ] ] ) ) ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 13 , 55 , 7 , 3 , 5 , 21 , 233 , 144 , 89 ] NEW_LINE N = len ( arr ) NEW_LINE cntFibonacciPrime ( arr , N ) NEW_LINE"}
{"text": "Kurangkan nombor yang diberikan untuk membentuk kunci oleh operasi yang diberikan | Program Python3 pendekatan di atas; Berfungsi untuk mencari kunci nombor yang diberikan; Tukar integer ke rentetan; Melepasi rentetan num untuk mendapatkan hasilnya; Semak sama ada digit adalah atau ganjil; Berulang sehingga jumlah ganjil diperolehi dengan menambahkan digit berturut -turut; Semak jika jumlahnya menjadi ganjil; Tambah hasil dalam ANS; Berikan indeks digit ke rentetan NUM; Jika nombor itu ganjil; Berulang sehingga jumlah ganjil diperolehi dengan menambahkan digit berturut -turut; Semak sama ada jumlahnya menjadi walaupun; Tambah hasil dalam ANS; Berikan indeks digit ke numstring utama; Periksa sama ada semua digit dikunjungi atau tidak;", "code": "import math NEW_LINE def key ( N ) : NEW_LINE INDENT num = \" \" + str ( N ) NEW_LINE ans = 0 NEW_LINE j = 0 NEW_LINE while j < len ( num ) : NEW_LINE INDENT if ( ( ord ( num [ j ] ) - 48 ) % 2 == 0 ) : NEW_LINE INDENT add = 0 NEW_LINE i = j NEW_LINE while j < len ( num ) : NEW_LINE INDENT add += ord ( num [ j ] ) - 48 NEW_LINE if ( add % 2 == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( add == 0 ) : NEW_LINE INDENT ans *= 10 NEW_LINE DEDENT else : NEW_LINE INDENT digit = int ( math . floor ( math . log10 ( add ) + 1 ) ) NEW_LINE ans *= ( pow ( 10 , digit ) ) NEW_LINE ans += add NEW_LINE DEDENT i = j NEW_LINE DEDENT else : NEW_LINE INDENT add = 0 NEW_LINE i = j NEW_LINE while j < len ( num ) : NEW_LINE INDENT add += ord ( num [ j ] ) - 48 NEW_LINE if ( add % 2 == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( add == 0 ) : NEW_LINE INDENT ans *= 10 NEW_LINE DEDENT else : NEW_LINE INDENT digit = int ( math . floor ( math . log10 ( add ) + 1 ) ) NEW_LINE ans *= ( pow ( 10 , digit ) ) NEW_LINE ans += add NEW_LINE DEDENT i = j NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j + 1 ) >= len ( num ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT ans += ord ( num [ len ( num ) - 1 ] ) - 48 NEW_LINE return ans NEW_LINE DEDENT DEDENT / * Driver Code * / NEW_LINE N = 1667848271 NEW_LINE print ( key ( N ) ) NEW_LINE"}
{"text": "Sentinel Linear Search | Pelaksanaan Python3 fungsi pendekatan untuk mencari kunci dalam array yang diberikan; Berfungsi untuk mencari x dalam array yang diberikan; Elemen terakhir array; Unsur yang akan dicari diletakkan pada indeks terakhir; Letakkan elemen terakhir kembali; Kod pemacu", "code": "def sentinelSearch ( arr , n , key ) : NEW_LINE def sentinelSearch ( arr , n , key ) : NEW_LINE INDENT last = arr [ n - 1 ] NEW_LINE arr [ n - 1 ] = key NEW_LINE i = 0 NEW_LINE while ( arr [ i ] != key ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT arr [ n - 1 ] = last NEW_LINE if ( ( i < n - 1 ) or ( arr [ n - 1 ] == key ) ) : NEW_LINE INDENT print ( key , \" is ▁ present ▁ at ▁ index \" , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element ▁ Not ▁ found \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 180 , 30 , 60 , 50 , 110 , 100 , 70 ] NEW_LINE n = len ( arr ) NEW_LINE key = 180 NEW_LINE sentinelSearch ( arr , n , key ) NEW_LINE"}
{"text": "Unsur pertengahan maksimum yang mungkin selepas memadam Elements Kepatnya | Fungsi untuk mengira nilai tengah maksimum yang mungkin dari array selepas memadam elemen K tepat; Memulakan jawapan sebagai - 1; Hitung pelbagai elemen yang boleh memberikan nilai tengah maksimum yang mungkin dari array kerana indeks nilai maksimum yang mungkin ditengah selepas memadam unsur -unsur K tepat dari array akan terletak di antara rendah dan tinggi; Cari elemen maksimum array dalam jarak rendah dan tinggi; Oleh kerana pengindeksan adalah 1 berasaskan jadi elemen semak pada indeks I - 1; Kembalikan nilai tengah maksimum yang mungkin dari array selepas memadam elemen K tepat dari array; Kod pemacu", "code": "def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) // 2 NEW_LINE high = ( n + 1 - k ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n , k = 9 , 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE DEDENT"}
{"text": "Carian Ternary | Program Python3 untuk menggambarkan pendekatan rekursif untuk carian ternary; Berfungsi untuk melakukan carian ternary; Cari Mid1 dan Mid2; Semak sama ada kunci hadir di mana -mana pertengahan; Oleh kerana kunci tidak hadir pada pertengahan, periksa di mana rantau ia hadir kemudian ulangi operasi carian di rantau itu; Kunci terletak di antara L dan MID1; Kunci terletak di antara Mid2 dan R; Kuncinya terletak di antara Mid1 dan Mid2; Kunci tidak dijumpai; Kod pemacu; Dapatkan array jenis array jika tidak disusun; Indeks permulaan; panjang array; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya; Kunci untuk dicari dalam array; Cari kunci menggunakan TernarySearch; Cetak hasilnya", "code": "import math as mt NEW_LINE def ternarySearch ( l , r , key , ar ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid1 = l + ( r - l ) // 3 NEW_LINE mid2 = r - ( r - l ) // 3 NEW_LINE if ( ar [ mid1 ] == key ) : NEW_LINE INDENT return mid1 NEW_LINE DEDENT if ( ar [ mid2 ] == key ) : NEW_LINE INDENT return mid2 NEW_LINE DEDENT if ( key < ar [ mid1 ] ) : NEW_LINE INDENT return ternarySearch ( l , mid1 - 1 , key , ar ) NEW_LINE DEDENT elif ( key > ar [ mid2 ] ) : NEW_LINE INDENT return ternarySearch ( mid2 + 1 , r , key , ar ) NEW_LINE DEDENT else : NEW_LINE INDENT return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT l , r , p = 0 , 9 , 5 NEW_LINE ar = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE l = 0 NEW_LINE r = 9 NEW_LINE key = 5 NEW_LINE p = ternarySearch ( l , r , key , ar ) NEW_LINE print ( \" Index ▁ of \" , key , \" is \" , p ) NEW_LINE key = 50 NEW_LINE p = ternarySearch ( l , r , key , ar ) NEW_LINE print ( \" Index ▁ of \" , key , \" is \" , p ) NEW_LINE"}
{"text": "Bilangan minimum mata yang akan dikeluarkan untuk mendapatkan mata yang tinggal di satu sisi paksi | Berfungsi untuk mencari bilangan minimum mata; Bilangan mata di sebelah kiri y - paksi. ; Bilangan mata di sebelah kanan paksi y. ; Bilangan mata di atas x - paksi. ; Bilangan mata di bawah x - paksi. ; Kod pemacu", "code": "def findmin ( p , n ) : NEW_LINE INDENT a , b , c , d = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] [ 0 ] <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] [ 0 ] >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( p [ i ] [ 1 ] >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( p [ i ] [ 1 ] <= 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( [ a , b , c , d ] ) NEW_LINE DEDENT p = [ [ 1 , 1 ] , [ 2 , 2 ] , [ - 1 , - 1 ] , [ - 2 , 2 ] ] NEW_LINE n = len ( p ) NEW_LINE print ( findmin ( p , n ) ) NEW_LINE"}
{"text": "Bilangan maksimum pengurangan pasangan yang mungkin pada triplet tertentu | Fungsi untuk mengira bilangan maksimum pengurangan pasangan yang mungkin pada triplet tertentu; Tukar mereka menjadi array; Kedai kiraan operasi; Susun array; Jika dua elemen array pertama berkurangan kepada 0; Memohon operasi; Kiraan kenaikan; Cetak kiraan maksimum; Diberikan triplet", "code": "def maxOps ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE count = 0 NEW_LINE while True : NEW_LINE INDENT arr . sort ( ) NEW_LINE if not arr [ 0 ] and not arr [ 1 ] : NEW_LINE break NEW_LINE arr [ 1 ] -= 1 NEW_LINE arr [ 2 ] -= 1 NEW_LINE count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT a , b , c = 4 , 3 , 2 NEW_LINE maxOps ( a , b , c ) NEW_LINE"}
{"text": "Kes | Pelaksanaan Python3 pendekatan; Berfungsi untuk mengembalikan rentetan yang disusun; Untuk menyimpan frekuensi huruf kecil dan aksara huruf besar dalam rentetan yang diberikan; Jika watak semasa adalah huruf kecil maka kenaikan kekerapannya dalam array yang lebih rendah []; Lain kenaikan dalam array atas []; Petunjuk yang menunjuk pada huruf kecil terkecil dan watak -watak huruf kecil terkecil masing -masing dalam rentetan yang diberikan; Untuk setiap watak dalam rentetan yang diberikan; Jika watak semasa adalah huruf kecil kemudian gantikannya dengan watak kecil terkecil yang tersedia; Pengurangan kekerapan watak yang digunakan; Lain menggantikannya dengan watak huruf kecil terkecil yang ada; Pengurangan kekerapan watak yang digunakan; Kembalikan rentetan yang disusun; Kod pemacu", "code": "MAX = 26 NEW_LINE def getSortedString ( s , n ) : NEW_LINE INDENT lower = [ 0 ] * MAX ; NEW_LINE upper = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] . islower ( ) ) : NEW_LINE INDENT lower [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT elif ( s [ i ] . isupper ( ) ) : NEW_LINE INDENT upper [ ord ( s [ i ] ) - ord ( ' A ' ) ] += 1 ; NEW_LINE DEDENT DEDENT i = 0 ; j = 0 ; NEW_LINE while ( i < MAX and lower [ i ] == 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT while ( j < MAX and upper [ j ] == 0 ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT for k in range ( n ) : NEW_LINE INDENT if ( s [ k ] . islower ( ) ) : NEW_LINE INDENT while ( lower [ i ] == 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT s [ k ] = chr ( i + ord ( ' a ' ) ) ; NEW_LINE lower [ i ] -= 1 ; NEW_LINE DEDENT elif ( s [ k ] . isupper ( ) ) : NEW_LINE INDENT while ( upper [ j ] == 0 ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT s [ k ] = chr ( j + ord ( ' A ' ) ) ; NEW_LINE upper [ j ] -= 1 ; NEW_LINE DEDENT DEDENT return \" \" . join ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" gEeksfOrgEEkS \" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( getSortedString ( list ( s ) , n ) ) ; NEW_LINE DEDENT"}
{"text": "Cetak watak dan frekuensi mereka mengikut urutan kejadian | Pelaksanaan Python3 kepada PR watak dan kekerapannya dalam rangka kejadiannya; Berfungsi untuk mencetak watak dan kekerapannya mengikut urutan kejadiannya; Saiz 'str; Memulakan semua elemen freq [] hingga 0; Mengumpul kekerapan setiap watak dalam 'str; Melintasi 'str' dari kiri ke kanan; jika kekerapan watak str [i] tidak sama dengan 0; Cetak watak bersama kekerapannya; Kemas kini kekerapan STR [i] hingga 0 supaya watak yang sama tidak dicetak lagi; Kod pemacu", "code": "import numpy as np NEW_LINE def prCharWithFreq ( str ) : NEW_LINE ' NEW_LINE INDENT n = len ( str ) NEW_LINE freq = np . zeros ( 26 , dtype = np . int ) NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] != 0 ) : NEW_LINE INDENT print ( str [ i ] , freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] , end = \" ▁ \" ) NEW_LINE freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] = 0 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" ; NEW_LINE prCharWithFreq ( str ) ; NEW_LINE DEDENT ' NEW_LINE"}
{"text": "Kata -kata terbalik dalam rentetan yang diberikan | Program python3 untuk membalikkan rentetan s = input ()", "code": "s = \" i ▁ like ▁ this ▁ program ▁ very ▁ much \" NEW_LINE words = s . split ( ' ▁ ' ) NEW_LINE string = [ ] NEW_LINE for word in words : NEW_LINE INDENT string . insert ( 0 , word ) NEW_LINE DEDENT print ( \" Reversed ▁ String : \" ) NEW_LINE print ( \" ▁ \" . join ( string ) ) NEW_LINE"}
{"text": "Mengasingkan Perdana dan Bukan | Berfungsi untuk menjana nombor perdana menggunakan ayak eratosthenes; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Berfungsi untuk memisahkan prima dan bukan prima; Menjana semua prima sehingga 10 ^ 7; Memulakan kiri dan kanan; Melintasi array; Peningkatan kiri manakala elemen array di sebelah kiri adalah perdana; Pengurangan betul manakala elemen array di sebelah kanan adalah bukan perdana; Jika kiri <kanan, kemudian swap arr [kiri] dan arr [kanan]; Swap arr [kiri] dan arr [kanan]; Cetak array terasing; Kod pemacu; Panggilan fungsi", "code": "def SieveOfEratosthenes ( prime , n ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * p NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def segregatePrimeNonPrime ( prime , arr , N ) : NEW_LINE INDENT SieveOfEratosthenes ( prime , 10000000 ) NEW_LINE left , right = 0 , N - 1 NEW_LINE while ( left < right ) : NEW_LINE INDENT while ( prime [ arr [ left ] ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT while ( not prime [ arr [ right ] ] ) : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT if ( left < right ) : NEW_LINE INDENT arr [ left ] , arr [ right ] = arr [ right ] , arr [ left ] NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT for num in arr : NEW_LINE INDENT print ( num , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE prime = [ True ] * 10000001 NEW_LINE segregatePrimeNonPrime ( prime , arr , N ) NEW_LINE"}
{"text": "Hitung kedalaman pokok binari penuh dari preorder | berfungsi untuk mengembalikan maksimum ketinggian subtree kiri atau ketinggian subtree kanan; ketinggian calc subtree kiri (dalam preorder kiri subtree diproses sebelum kanan); ketinggian calc subtree kanan; Pembalut ke atas findDepThrec (); Program pemacu untuk menguji fungsi di atas", "code": "def findDepthRec ( tree , n , index ) : NEW_LINE INDENT if ( index [ 0 ] >= n or tree [ index [ 0 ] ] == ' l ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT index [ 0 ] += 1 NEW_LINE left = findDepthRec ( tree , n , index ) NEW_LINE index [ 0 ] += 1 NEW_LINE right = findDepthRec ( tree , n , index ) NEW_LINE return ( max ( left , right ) + 1 ) NEW_LINE DEDENT def findDepth ( tree , n ) : NEW_LINE INDENT index = [ 0 ] NEW_LINE return findDepthRec ( tree , n , index ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT tree = \" nlnnlll \" NEW_LINE n = len ( tree ) NEW_LINE print ( findDepth ( tree , n ) ) NEW_LINE DEDENT"}
{"text": "Nombor terbesar di BST yang kurang daripada atau sama dengan N | Pembina untuk membuat nod baru; Untuk memasukkan nod baru di BST; Jika pokok kosong kembali nod baru; Jika kunci kurang atau lebih besar maka nilai nod maka mengulangi pokok itu; Kembalikan penunjuk nod (tidak berubah); fungsi untuk mencari nilai maksimum kurang kemudian n; Kes asas; Jika nilai root lebih kecil, cuba subtree kanan; Jika kekunci Root lebih besar, nilai pulangan dari subtree kiri. ; Kod pemacu; Mencipta BST 5 / \\ 2 12 / \\ / \\ 1 3 9 21 / \\ 19 25", "code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . key = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node , key ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return newNode ( key ) NEW_LINE DEDENT if key < node . key : NEW_LINE INDENT node . left = insert ( node . left , key ) NEW_LINE DEDENT elif key > node . key : NEW_LINE INDENT node . right = insert ( node . right , key ) NEW_LINE DEDENT return node NEW_LINE DEDENT def findMaxforN ( root , N ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if root . key == N : NEW_LINE INDENT return N NEW_LINE DEDENT elif root . key < N : NEW_LINE INDENT k = findMaxforN ( root . right , N ) NEW_LINE if k == - 1 : NEW_LINE INDENT return root . key NEW_LINE DEDENT else : NEW_LINE INDENT return k NEW_LINE DEDENT DEDENT elif root . key > N : NEW_LINE INDENT return findMaxforN ( root . left , N ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE root = None NEW_LINE root = insert ( root , 25 ) NEW_LINE insert ( root , 2 ) NEW_LINE insert ( root , 1 ) NEW_LINE insert ( root , 3 ) NEW_LINE insert ( root , 12 ) NEW_LINE insert ( root , 9 ) NEW_LINE insert ( root , 21 ) NEW_LINE insert ( root , 19 ) NEW_LINE insert ( root , 25 ) NEW_LINE print ( findMaxforN ( root , N ) ) NEW_LINE DEDENT"}
{"text": "Nombor terbesar di BST yang kurang daripada atau sama dengan N | Kod python3 untuk mencari nilai terbesar yang lebih kecil daripada atau sama dengan n; Untuk membuat nod BST baru; Untuk memasukkan nod baru di BST; Jika pokok kosong kembali nod baru; Jika kunci kurang atau lebih besar maka nilai nod maka mengulangi pokok itu; Kembalikan penunjuk nod (tidak berubah); Fungsi untuk mencari nilai maksimum kurang kemudian n; Mulakan dari akar dan terus mencari lebih besar; Jika akar lebih kecil pergi ke sebelah kanan; Jika akar lebih besar pergi ke sebelah kiri; Kod pemacu", "code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . key = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node , key ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return newNode ( key ) NEW_LINE DEDENT if ( key < node . key ) : NEW_LINE INDENT node . left = insert ( node . left , key ) NEW_LINE DEDENT elif ( key > node . key ) : NEW_LINE INDENT node . right = insert ( node . right , key ) NEW_LINE DEDENT return node NEW_LINE DEDENT def findMaxforN ( root , N ) : NEW_LINE INDENT while ( root != None and root . right != None ) : NEW_LINE INDENT if ( N > root . key and N >= root . right . key ) : NEW_LINE INDENT root = root . right NEW_LINE DEDENT elif ( N < root . key ) : NEW_LINE INDENT root = root . left NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( root == None or root . key > N ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( root . key ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 50 NEW_LINE root = None NEW_LINE root = insert ( root , 5 ) NEW_LINE insert ( root , 2 ) NEW_LINE insert ( root , 1 ) NEW_LINE insert ( root , 3 ) NEW_LINE insert ( root , 12 ) NEW_LINE insert ( root , 9 ) NEW_LINE insert ( root , 21 ) NEW_LINE insert ( root , 19 ) NEW_LINE insert ( root , 25 ) NEW_LINE findMaxforN ( root , N ) NEW_LINE DEDENT"}
{"text": "Unsur maksimum antara dua nod BST | Program Python 3 untuk mencari elemen maksimum di jalan antara dua nod pokok carian binari. Buat dan kembalikan penunjuk nod baru. ; Pembina untuk membuat nod baru; Masukkan nod baru dalam pokok carian binari. ; Kembalikan elemen maksimum antara nod dan nenek moyangnya. ; Melintasi jalan antara ansektor dan nod dan mencari elemen maksimum. ; Pulangan elemen maksimum di jalan antara dua nod yang diberikan BST. ; Mencari LCA Node X dan Node Y; Memeriksa jika kedua -dua nod terletak di sebelah kiri ibu bapa p. ; Memeriksa jika kedua -dua nod terletak di sebelah kanan ibu bapa p. ; Kembalikan maksimum elemen maksimum berlaku di jalan dari nenek moyang ke kedua -dua nod. ; Kod pemacu; Mewujudkan akar pokok carian binari; Memasukkan nod dalam pokok carian binari", "code": "class createNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insertNode ( root , x ) : NEW_LINE INDENT p , q = root , None NEW_LINE while p != None : NEW_LINE INDENT q = p NEW_LINE if p . data < x : NEW_LINE INDENT p = p . right NEW_LINE DEDENT else : NEW_LINE INDENT p = p . left NEW_LINE DEDENT DEDENT if q == None : NEW_LINE INDENT p = createNode ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT if q . data < x : NEW_LINE INDENT q . right = createNode ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT q . left = createNode ( x ) NEW_LINE DEDENT DEDENT DEDENT def maxelpath ( q , x ) : NEW_LINE INDENT p = q NEW_LINE mx = - 999999999999 NEW_LINE while p . data != x : NEW_LINE INDENT if p . data > x : NEW_LINE INDENT mx = max ( mx , p . data ) NEW_LINE p = p . left NEW_LINE DEDENT else : NEW_LINE INDENT mx = max ( mx , p . data ) NEW_LINE p = p . right NEW_LINE DEDENT DEDENT return max ( mx , x ) NEW_LINE DEDENT def maximumElement ( root , x , y ) : NEW_LINE INDENT p = root NEW_LINE while ( ( x < p . data and y < p . data ) or ( x > p . data and y > p . data ) ) : NEW_LINE INDENT if x < p . data and y < p . data : NEW_LINE INDENT p = p . left NEW_LINE DEDENT elif x > p . data and y > p . data : NEW_LINE INDENT p = p . right NEW_LINE DEDENT DEDENT return max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 ] NEW_LINE a , b = 1 , 10 NEW_LINE n = len ( arr ) NEW_LINE root = createNode ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT insertNode ( root , arr [ i ] ) NEW_LINE DEDENT print ( maximumElement ( root , a , b ) ) NEW_LINE DEDENT"}
{"text": "Pokok binari yang diulurkan | Penyisipan | Penyisipan dalam pokok carian binari berulir. ; Benar jika penunjuk kiri titik kepada pendahulunya dalam inorder traversal; Benar jika penunjuk kanan menunjuk kepada pengganti dalam Inorder Traversal; Masukkan nod dalam pokok berulir binari; Mencari nod dengan nilai yang diberikan; Ibu bapa kunci yang akan dimasukkan; Jika kunci sudah ada, kembali; Mengemas kini penunjuk induk; Bergerak di subtree kiri. ; Bergerak ke Subtree Kanan. ; Buat nod baru; Mengembalikan pengganti inorder menggunakan RTHREAD; Jika RTHREAD ditetapkan, kita dapat dengan cepat mencari; Lain kembali anak paling kiri dari subtree kanan; Mencetak pokok berulir; Mencapai nod paling kiri; Satu demi satu pengganti cetak; Kod pemacu", "code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . info = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE self . lthread = True NEW_LINE self . rthread = True NEW_LINE DEDENT DEDENT def insert ( root , ikey ) : NEW_LINE INDENT ptr = root NEW_LINE par = None NEW_LINE while ptr != None : NEW_LINE INDENT if ikey == ( ptr . info ) : NEW_LINE INDENT print ( \" Duplicate ▁ Key ▁ ! \" ) NEW_LINE return root NEW_LINE DEDENT par = ptr NEW_LINE if ikey < ptr . info : NEW_LINE INDENT if ptr . lthread == False : NEW_LINE INDENT ptr = ptr . left NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ptr . rthread == False : NEW_LINE INDENT ptr = ptr . right NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT tmp = newNode ( ikey ) NEW_LINE if par == None : NEW_LINE INDENT root = tmp NEW_LINE tmp . left = None NEW_LINE tmp . right = None NEW_LINE DEDENT elif ikey < ( par . info ) : NEW_LINE INDENT tmp . left = par . left NEW_LINE tmp . right = par NEW_LINE par . lthread = False NEW_LINE par . left = tmp NEW_LINE DEDENT else : NEW_LINE INDENT tmp . left = par NEW_LINE tmp . right = par . right NEW_LINE par . rthread = False NEW_LINE par . right = tmp NEW_LINE DEDENT return root NEW_LINE DEDENT def inorderSuccessor ( ptr ) : NEW_LINE INDENT if ptr . rthread == True : NEW_LINE INDENT return ptr . right NEW_LINE DEDENT ptr = ptr . right NEW_LINE while ptr . lthread == False : NEW_LINE INDENT ptr = ptr . left NEW_LINE DEDENT return ptr NEW_LINE DEDENT def inorder ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT print ( \" Tree ▁ is ▁ empty \" ) NEW_LINE DEDENT ptr = root NEW_LINE while ptr . lthread == False : NEW_LINE INDENT ptr = ptr . left NEW_LINE DEDENT while ptr != None : NEW_LINE INDENT print ( ptr . info , end = \" ▁ \" ) NEW_LINE ptr = inorderSuccessor ( ptr ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 20 ) NEW_LINE root = insert ( root , 10 ) NEW_LINE root = insert ( root , 30 ) NEW_LINE root = insert ( root , 5 ) NEW_LINE root = insert ( root , 16 ) NEW_LINE root = insert ( root , 14 ) NEW_LINE root = insert ( root , 17 ) NEW_LINE root = insert ( root , 13 ) NEW_LINE inorder ( root ) NEW_LINE DEDENT"}
{"text": "Semak simetri mendatar dan menegak dalam matriks binari | Program Python3 untuk mencari jika matriks adalah simetri. ; Memulakan sebagai simetri mendatar dan menegak. ; Memeriksa simetri mendatar. Kami membandingkan baris pertama dengan baris terakhir, baris kedua dengan barisan terakhir kedua dan sebagainya. ; Memeriksa setiap sel lajur. ; Semak jika setiap sel adalah sama; Memeriksa simetri menegak. Kami membandingkan lajur pertama dengan lajur terakhir, xolumn kedua dengan lajur terakhir kedua dan sebagainya. ; Memeriksa setiap sel baris. ; Semak jika setiap sel adalah sama; Kod pemacu", "code": "MAX = 1000 NEW_LINE def checkHV ( arr , N , M ) : NEW_LINE INDENT horizontal = True NEW_LINE vertical = True NEW_LINE i = 0 NEW_LINE k = N - 1 NEW_LINE while ( i < N // 2 ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) : NEW_LINE INDENT horizontal = False NEW_LINE break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE k -= 1 NEW_LINE DEDENT i = 0 NEW_LINE k = M - 1 NEW_LINE while ( i < M // 2 ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) : NEW_LINE INDENT vertical = False NEW_LINE break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE k -= 1 NEW_LINE DEDENT if ( not horizontal and not vertical ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT elif ( horizontal and not vertical ) : NEW_LINE INDENT print ( \" HORIZONTAL \" ) NEW_LINE DEDENT elif ( vertical and not horizontal ) : NEW_LINE INDENT print ( \" VERTICAL \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" BOTH \" ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 0 , 1 ] , [ 0 , 0 , 0 ] , [ 1 , 0 , 1 ] ] NEW_LINE checkHV ( mat , 3 , 3 ) NEW_LINE"}
{"text": "Gantikan setiap elemen matriks dengan maksimum GCD baris atau lajur | Program Python3 untuk menggantikan setiap elemen dengan maksimum GCD baris atau lajur. ; mengembalikan pembahagi biasa dua nombor; Mencari GCD setiap baris dan lajur dan menggantikan dengan setiap elemen dengan maksimum GCD baris atau lajur. ; Mengira GCD setiap baris dan setiap lajur dalam O (Mn) dan simpan dalam tatasusunan. ; Menggantikan elemen matriks; Kod pemacu", "code": "R = 3 NEW_LINE C = 4 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def replacematrix ( mat , n , m ) : NEW_LINE INDENT rgcd = [ 0 ] * R NEW_LINE cgcd = [ 0 ] * C NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) NEW_LINE cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT mat [ i ] [ j ] = max ( rgcd [ i ] , cgcd [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = [ [ 1 , 2 , 3 , 3 ] , [ 4 , 5 , 6 , 6 ] , [ 7 , 8 , 9 , 9 ] ] NEW_LINE replacematrix ( m , R , C ) NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT print ( m [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"}
{"text": "Program untuk penambahan dua matriks | Program Python3 untuk penambahan dua matriks; Fungsi ini menambah [] [] dan b [] [], dan menyimpan hasil dalam c [] []; kod pemacu", "code": "N = 4 NEW_LINE def add ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE C = A [ : ] [ : ] NEW_LINE add ( A , B , C ) NEW_LINE print ( \" Result ▁ matrix ▁ is \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( C [ i ] [ j ] , \" ▁ \" , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text": "Program untuk pengurangan matriks | Program Python 3 untuk pengurangan matriks; Fungsi ini mengembalikan 1 jika a [] [] dan b [] [] adalah sama sebaliknya pulangan 0; Kod pemacu", "code": "N = 4 NEW_LINE def subtract ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE C = A [ : ] [ : ] NEW_LINE subtract ( A , B , C ) NEW_LINE print ( \" Result ▁ matrix ▁ is \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( C [ i ] [ j ] , \" ▁ \" , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text": "Cari titik tetap (nilai sama dengan indeks) dalam array yang diberikan | Program Python untuk memeriksa titik tetap dalam array menggunakan carian linear; Jika tiada titik tetap hadir kemudian kembali - 1; Program pemacu untuk menyemak fungsi di atas", "code": "def linearSearch ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] is i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Fixed ▁ Point ▁ is ▁ \" + str ( linearSearch ( arr , n ) ) ) NEW_LINE"}
{"text": "Cari titik tetap (nilai sama dengan indeks) dalam array yang diberikan | Program Python untuk memeriksa titik tetap dalam array menggunakan carian binari;  ; Kembali - 1 jika tiada titik tetap; Program pemacu untuk menyemak fungsi di atas", "code": "def binarySearch ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE DEDENT if mid is arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , low , ( mid - 1 ) ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Fixed ▁ Point ▁ is ▁ \" + str ( binarySearch ( arr , 0 , n - 1 ) ) ) NEW_LINE"}
{"text": "Jumlah maksimum triplet dalam array | Python 3 kod untuk mencari jumlah triplet maksimum; Memulakan jumlah dengan int_min; Kod yang didorong", "code": "def maxTripletSum ( arr , n ) : NEW_LINE INDENT sm = - 1000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) : NEW_LINE INDENT sm = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return sm NEW_LINE DEDENT arr = [ 1 , 0 , 8 , 6 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxTripletSum ( arr , n ) ) NEW_LINE"}
{"text": "Jumlah maksimum triplet dalam array | Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya tiga elemen dalam ARR []. ; Susun array yang diberikan; Selepas menyusun array. Tambah tiga elemen terakhir dari array yang diberikan; Kod yang didorong", "code": "def maxTripletSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) NEW_LINE DEDENT arr = [ 1 , 0 , 8 , 6 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxTripletSum ( arr , n ) ) NEW_LINE"}
{"text": "Jumlah maksimum triplet dalam array | Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya tiga elemen dalam ARR []. ; Memulakan elemen maksimum maksimum dan maksimum maksimum maksimum; Mengemas kini elemen maksimum maksimum dan ketiga; Mengemas kini elemen maksimum maksimum dan ketiga; Mengemas kini elemen maksimum ketiga; Kod yang didorong", "code": "def maxTripletSum ( arr , n ) : NEW_LINE INDENT maxA = - 100000000 NEW_LINE maxB = - 100000000 NEW_LINE maxC = - 100000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > maxA ) : NEW_LINE INDENT maxC = maxB NEW_LINE maxB = maxA NEW_LINE maxA = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxB ) : NEW_LINE INDENT maxC = maxB NEW_LINE maxB = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxC ) : NEW_LINE INDENT maxC = arr [ i ] NEW_LINE DEDENT DEDENT return ( maxA + maxB + maxC ) NEW_LINE DEDENT arr = [ 1 , 0 , 8 , 6 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxTripletSum ( arr , n ) ) NEW_LINE"}
{"text": "Carian Linear | Kod python3 untuk mencari linearly x dalam arr []. Jika x hadir kemudian kembalikan lokasi, jika tidak, pulangan - 1; Kod pemacu; Panggilan fungsi", "code": "def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE n = len ( arr ) NEW_LINE result = search ( arr , n , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element ▁ is ▁ present ▁ at ▁ index \" , result ) NEW_LINE DEDENT"}
{"text": "Carian Linear | Program python3 untuk carian linear; Jalankan gelung dari 0 ke kanan; Jika search_element ditemui dengan pembolehubah kiri; Jika search_element ditemui dengan pemboleh ubah yang betul; Jika elemen tidak dijumpai; Kod pemacu; Panggilan fungsi", "code": "def search ( arr , search_Element ) : NEW_LINE INDENT left = 0 NEW_LINE length = len ( arr ) NEW_LINE position = - 1 NEW_LINE right = length - 1 NEW_LINE for left in range ( 0 , right , 1 ) : NEW_LINE INDENT if ( arr [ left ] == search_Element ) : NEW_LINE INDENT position = left NEW_LINE print ( \" Element ▁ found ▁ in ▁ Array ▁ at ▁ \" , position + 1 , \" ▁ Position ▁ with ▁ \" , left + 1 , \" ▁ Attempt \" ) NEW_LINE break NEW_LINE DEDENT if ( arr [ right ] == search_Element ) : NEW_LINE INDENT position = right NEW_LINE print ( \" Element ▁ found ▁ in ▁ Array ▁ at ▁ \" , position + 1 , \" ▁ Position ▁ with ▁ \" , length - right , \" ▁ Attempt \" ) NEW_LINE break NEW_LINE DEDENT left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT if ( position == - 1 ) : NEW_LINE INDENT print ( \" Not ▁ found ▁ in ▁ Array ▁ with ▁ \" , left , \" ▁ Attempt \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE search_element = 5 NEW_LINE search ( arr , search_element ) NEW_LINE"}
{"text": "Mengira jenis | Fungsi utama yang menyusun rentetan yang diberikan [] dalam susunan abjad; Pelbagai watak output yang akan menyusun ARR; Buat array kiraan untuk menyimpan kiraan aksara inidividul dan memulakan array kiraan sebagai 0; Menyimpan kiraan setiap watak; Tukar kiraan [i] supaya kiraan [i] kini mengandungi kedudukan sebenar watak ini dalam pelbagai output; Membina array watak output; Salin array output ke ARR, supaya ARR kini mengandungi aksara yang disusun; Program pemacu untuk menguji fungsi di atas", "code": "def countSort ( arr ) : NEW_LINE INDENT output = [ 0 for i in range ( len ( arr ) ) ] NEW_LINE count = [ 0 for i in range ( 256 ) ] NEW_LINE for i in arr : NEW_LINE INDENT count [ ord ( i ) ] += 1 NEW_LINE DEDENT for i in range ( 256 ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT output [ count [ ord ( arr [ i ] ) ] - 1 ] = arr [ i ] NEW_LINE count [ ord ( arr [ i ] ) ] -= 1 NEW_LINE DEDENT ans = [ \" \" for _ in arr ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT ans [ i ] = output [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = \" geeksforgeeks \" NEW_LINE ans = countSort ( arr ) NEW_LINE print ( \" Sorted ▁ character ▁ array ▁ is ▁ % ▁ s \" % ( \" \" . join ( ans ) ) ) NEW_LINE"}
{"text": "Mengira jenis | Fungsi yang menyusun ARR []; Program pemacu untuk menguji fungsi di atas", "code": "def count_sort ( arr ) : NEW_LINE INDENT max_element = int ( max ( arr ) ) NEW_LINE min_element = int ( min ( arr ) ) NEW_LINE range_of_elements = max_element - min_element + 1 NEW_LINE count_arr = [ 0 for _ in range ( range_of_elements ) ] NEW_LINE output_arr = [ 0 for _ in range ( len ( arr ) ) ] NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT count_arr [ arr [ i ] - min_element ] += 1 NEW_LINE DEDENT for i in range ( 1 , len ( count_arr ) ) : NEW_LINE INDENT count_arr [ i ] += count_arr [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( arr ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT output_arr [ count_arr [ arr [ i ] - min_element ] - 1 ] = arr [ i ] NEW_LINE count_arr [ arr [ i ] - min_element ] -= 1 NEW_LINE DEDENT for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT arr [ i ] = output_arr [ i ] NEW_LINE DEDENT return arr NEW_LINE DEDENT arr = [ - 5 , - 10 , 0 , - 3 , 8 , 5 , - 1 , 10 ] NEW_LINE ans = count_sort ( arr ) NEW_LINE print ( \" Sorted ▁ character ▁ array ▁ is ▁ \" + str ( ans ) ) NEW_LINE"}
{"text": "Koefisien binomial | DP | Pulangan nilai pekali binomial c (n, k); Kes asas; Panggilan rekursif; Program pemacu untuk menguji fungsi HT di atas", "code": "def binomialCoeff ( n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if k == 0 or k == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE print \" Value ▁ of ▁ C ( % d , % d ) ▁ is ▁ ( % d ) \" % ( n , k , binomialCoeff ( n , k ) ) NEW_LINE"}
{"text": "Koefisien binomial | DP | Program Python untuk penyelesaian pengaturcaraan dinamik yang dioptimumkan untuk pekali binomail. Ini menggunakan konsep segitiga Pascal dan memori yang kurang; kerana NC0 adalah 1; Kirakan baris seterusnya segitiga Pascal menggunakan baris sebelumnya; Kod pemacu", "code": "def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 for i in xrange ( k + 1 ) ] NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = min ( i , k ) NEW_LINE while ( j > 0 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE print \" Value ▁ of ▁ C ( % d , % d ) ▁ is ▁ % d \" % ( n , k , binomialCoeff ( n , k ) ) NEW_LINE"}
{"text": "Koefisien binomial | DP | Kod python untuk pendekatan di atas; Kes asas; C (n, r) = c (n, n - r) kerumitan untuk kod ini lebih rendah untuk n - r yang lebih rendah; menetapkan faktor utama terkecil bagi setiap nombor sendiri; menetapkan faktor utama terkecil dari semua nombor walaupun 2; Semak jika saya adalah Perdana; Semua gandaan saya adalah komposit (dan dibahagikan dengan i) jadi tambahkan saya kepada pemfaktoran utama mereka getpow (j, i) kali; kamus untuk menyimpan kuasa setiap perdana dalam c (n, r); Untuk kekerapan kiraan pengangka setiap faktor utama; Bahagian rekursif untuk mencari pemfaktoran utama i; Untuk penyebut tolak kuasa setiap faktor utama; Bahagian rekursif untuk mencari pemfaktoran utama i;  ; Penggunaan (a * b) % mod = (mod mod * b %) %; POW (asas, exp, mod) digunakan untuk mencari (asas ^ exp) % mod cepat; Kod pemacu", "code": "import math NEW_LINE class GFG : NEW_LINE INDENT def nCr ( self , n , r ) : NEW_LINE INDENT if r > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n - r > r : NEW_LINE INDENT r = n - r NEW_LINE DEDENT SPF = [ i for i in range ( n + 1 ) ] NEW_LINE for i in range ( 4 , n + 1 , 2 ) : NEW_LINE INDENT SPF [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if SPF [ i ] == i : NEW_LINE INDENT for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT if SPF [ j ] == j : NEW_LINE INDENT SPF [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT prime_pow = { } NEW_LINE for i in range ( r + 1 , n + 1 ) : NEW_LINE INDENT t = i NEW_LINE while t > 1 : NEW_LINE INDENT if not SPF [ t ] in prime_pow : NEW_LINE INDENT prime_pow [ SPF [ t ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime_pow [ SPF [ t ] ] += 1 NEW_LINE DEDENT t //= SPF [ t ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n - r + 1 ) : NEW_LINE INDENT t = i NEW_LINE while t > 1 : NEW_LINE INDENT prime_pow [ SPF [ t ] ] -= 1 NEW_LINE t //= SPF [ t ] NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE for i in prime_pow : NEW_LINE INDENT ans = ( ans * pow ( i , prime_pow [ i ] , mod ) ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT n = 5 NEW_LINE k = 2 NEW_LINE ob = GFG ( ) NEW_LINE print ( \" Value ▁ of ▁ C ( \" + str ( n ) + \" , ▁ \" + str ( k ) + \" ) ▁ is \" , ob . nCr ( n , k ) ) NEW_LINE"}
{"text": "Koefisien binomial | DP | Berfungsi untuk mencari pekali binomial; Mendapatkan penyongsangan modular untuk semua nombor dari 2 hingga R berkenaan dengan M di sini M = 1000000007; untuk 1 / (r!) Bahagian; untuk (n) * (n - 1) * (n - 2) * ... * (n - r + 1) bahagian; Kod pemacu", "code": "def binomialCoeff ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT m = 1000000007 NEW_LINE inv = [ 0 for i in range ( r + 1 ) ] NEW_LINE inv [ 0 ] = 1 NEW_LINE if ( r + 1 >= 2 ) : NEW_LINE INDENT inv [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , r + 1 ) : NEW_LINE INDENT inv [ i ] = m - ( m // i ) * inv [ m % i ] % m NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 2 , r + 1 ) : NEW_LINE INDENT ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m NEW_LINE DEDENT for i in range ( n , n - r , - 1 ) : NEW_LINE INDENT ans = ( ( ans % m ) * ( i % m ) ) % m NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE r = 2 NEW_LINE print ( \" Value ▁ of ▁ C ( \" , n , \" , ▁ \" , r , \" ) ▁ is ▁ \" , binomialCoeff ( n , r ) ) NEW_LINE"}
{"text": "Masalah Partition | DP | Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah semua elemen; Permulaan array bahagian sebagai 0; Isi jadual partition dengan cara bawah; Unsur yang akan dimasukkan dalam jumlah tidak boleh lebih besar daripada jumlahnya; Semak jika jumlah - arr [i] boleh dibentuk dari subset menggunakan elemen sebelum indeks I; Kod pemacu; Panggilan fungsi", "code": "def findPartiion ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT if ( Sum % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT part = [ 0 ] * ( ( Sum // 2 ) + 1 ) NEW_LINE for i in range ( ( Sum // 2 ) + 1 ) : NEW_LINE INDENT part [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( Sum // 2 , arr [ i ] - 1 , - 1 ) : NEW_LINE INDENT if ( part [ j - arr [ i ] ] == 1 or j == arr [ i ] ) : NEW_LINE INDENT part [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT return part [ Sum // 2 ] NEW_LINE DEDENT arr = [ 1 , 3 , 3 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( findPartiion ( arr , n ) == 1 ) : NEW_LINE INDENT print ( \" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Can ▁ not ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ sum \" ) NEW_LINE DEDENT"}
{"text": "Pengaturcaraan Dinamik | Pulangan benar jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Kod pemacu", "code": "def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT"}
{"text": "Pengaturcaraan Dinamik | Pulangan benar jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara Botton; Jadual Cetak; Kod pemacu", "code": "def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if j < set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if j >= set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE INDENT print ( subset [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT return subset [ n ] [ sum ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found ▁ a ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ subset ▁ with ▁ given ▁ sum \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Fungsi rekursif yang mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada; Memulakan hasil; Cuba semua rehat yang mungkin - mata untuk mana -mana kekunci n, kita perlu gelung dari n - 3 kekunci kembali ke 1 keystroke untuk mencari breakpoint 'b' selepas itu kita akan mempunyai ctrl - a, ctrl - c dan kemudian hanya ctrl - v sepanjang jalan. ; Jika titik putus adalah s pada b 'th keystroke maka rentetan optimum akan mempunyai panjang (n-b-1)*skrin [b-1]; ; Program pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "def findoptimal ( N ) : NEW_LINE INDENT if N <= 6 : NEW_LINE INDENT return N NEW_LINE DEDENT maxi = 0 NEW_LINE for b in range ( N - 3 , 0 , - 1 ) : NEW_LINE INDENT curr = ( N - b - 1 ) * findoptimal ( b ) NEW_LINE if curr > maxi : NEW_LINE INDENT maxi = curr NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for n in range ( 1 , 21 ) : NEW_LINE INDENT print ( ' Maximum ▁ Number ▁ of ▁ As ▁ with ▁ ' , n , ' keystrokes ▁ is ▁ ' , findoptimal ( n ) ) NEW_LINE DEDENT DEDENT"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Fungsi ini mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7; Array untuk menyimpan hasil subproblem; Memulakan Arus Panjang Optimal untuk Uptil 6 Strok Input. ; Selesaikan semua subproblem dengan cara bawah; Memulakan panjang rentetan optimum untuk ketukan n; Untuk mana -mana kekunci n, kita perlu gelung dari n - 3 ketukan kembali ke 1 keystroke untuk mencari breakpoint 'b' selepas itu kita akan mempunyai ctrl - a, ctrl - c dan kemudian hanya ctrl - v sepanjang jalan. ; Sekiranya titik putus berada di b 'th keystroke maka rentetan optimum akan mempunyai panjang (n-b-1)*skrin [b-1]; ; Program pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = 0 NEW_LINE for b in range ( n - 3 , 0 , - 1 ) : NEW_LINE INDENT curr = ( n - b - 1 ) * screen [ b - 1 ] NEW_LINE if ( curr > screen [ n - 1 ] ) : NEW_LINE INDENT screen [ n - 1 ] = curr NEW_LINE DEDENT DEDENT DEDENT return screen [ N - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT for N in range ( 1 , 21 ) : NEW_LINE INDENT print ( \" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ \" , N , \" ▁ keystrokes ▁ is ▁ \" , findoptimal ( N ) ) NEW_LINE DEDENT DEDENT"}
{"text": "Cara Mencetak Bilangan Maksimum A Menggunakan Empat Kekunci yang Diberikan | Fungsi ini mengembalikan rentetan panjang optimum untuk ketukan n; Panjang rentetan optimum adalah n apabila n lebih kecil daripada 7; Array untuk menyimpan hasil subproblem; Memulakan Arus Panjang Optimal untuk Uptil 6 Strok Input. ; Selesaikan semua subproblem dengan cara bawah; Untuk mana -mana kekunci n, kita perlu memilih antara: - 1. Menekan Ctrl - V sekali selepas menyalin A 'yang diperolehi oleh ~ 3. ~ 2. Tekan ~ Ctrl - V ~ Dua kali ~ Selepas menyalin 'S yang diperolehi oleh N - 4 Keystrokes. 3. Menekan Ctrl - V tiga kali selepas menyalin A 'S yang diperolehi oleh N -5 Keystrokes. ; Kod pemacu; Untuk sisa array kita akan bergantung pada entri sebelumnya untuk mengira yang baru", "code": "def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; NEW_LINE DEDENT return screen [ N - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT for N in range ( 1 , 21 ) : NEW_LINE INDENT print ( \" Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ \" , N , \" ▁ keystrokes ▁ is ▁ \" , findoptimal ( N ) ) NEW_LINE DEDENT DEDENT"}
{"text": "Tulis program untuk mengira POW (x, n) | Fungsi untuk mengira x yang dibangkitkan kepada kuasa y; Kod pemacu", "code": "def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE elif ( int ( y % 2 ) == 0 ) : NEW_LINE INDENT return ( power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEW_LINE DEDENT DEDENT x = 2 ; y = 3 NEW_LINE print ( power ( x , y ) ) NEW_LINE"}
{"text": "Tulis program untuk mengira POW (x, n) | Berfungsi untuk mengira x yang dibangkitkan kepada kuasa y dalam o (logn)", "code": "def power ( x , y ) : NEW_LINE INDENT temp = 0 NEW_LINE if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( x , int ( y / 2 ) ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp ; NEW_LINE DEDENT else : NEW_LINE INDENT return x * temp * temp ; NEW_LINE DEDENT DEDENT"}
{"text": "Tulis program untuk mengira POW (x, n) | Kod python3 untuk fungsi kuasa lanjutan yang boleh berfungsi untuk float x dan negatif y; Kod pemacu", "code": "def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE temp = power ( x , int ( y / 2 ) ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT if ( y > 0 ) : return x * temp * temp NEW_LINE else : return ( temp * temp ) / x NEW_LINE DEDENT DEDENT x , y = 2 , - 3 NEW_LINE print ( ' % .6f ' % ( power ( x , y ) ) ) NEW_LINE"}
{"text": "Tulis program untuk mengira POW (x, n) | Program Python3 untuk pendekatan di atas; Jika x ^ 0 kembali 1; Jika kita perlu mencari 0 ^ y; Untuk semua kes lain; Kod pemacu", "code": "def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return x * power ( x , y - 1 ) NEW_LINE DEDENT x = 2 NEW_LINE y = 3 NEW_LINE print ( power ( x , y ) ) NEW_LINE"}
{"text": "Kaedah Babylon untuk Root Square | Mengembalikan akar kuadrat n. Perhatikan bahawa fungsi itu; Kami menggunakan N sendiri sebagai penghampiran awal ini pasti dapat diperbaiki; E memutuskan tahap ketepatan; Program pemacu untuk menguji fungsi di atas", "code": "def squareRoot ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE e = 0.000001 NEW_LINE while ( x - y > e ) : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT n = 50 NEW_LINE print ( \" Square ▁ root ▁ of \" , n , \" is \" , round ( squareRoot ( n ) , 6 ) ) NEW_LINE"}
{"text": "Purata aliran nombor | Mengembalikan purata baru selepas termasuk x; Mencetak purata aliran nombor; Kod pemacu", "code": "def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( ( prev_avg * n + x ) / ( n + 1 ) ) ; NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) ; NEW_LINE print ( \" Average ▁ of ▁ \" , i + 1 , \" ▁ numbers ▁ is ▁ \" , avg ) ; NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE"}
{"text": "Purata aliran nombor | Mengembalikan purata baru selepas termasuk x; Mencetak purata aliran nombor; Kod pemacu", "code": "def getAvg ( x , n , sum ) : NEW_LINE INDENT sum = sum + x ; NEW_LINE return float ( sum ) / n ; NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( arr [ i ] , i + 1 , sum ) ; NEW_LINE sum = avg * ( i + 1 ) ; NEW_LINE print ( \" Average ▁ of ▁ \" , end = \" \" ) ; NEW_LINE print ( i + 1 , end = \" \" ) ; NEW_LINE print ( \" ▁ numbers ▁ is ▁ \" , end = \" \" ) ; NEW_LINE print ( avg ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE"}
{"text": "Koefisien Binomial Ruang dan Masa yang cekap | Pulangan nilai pekali binomial c (n, k); kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Program pemacu untuk menguji fungsi di atas", "code": "def binomialCoefficient ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res / ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 8 NEW_LINE k = 2 NEW_LINE res = binomialCoefficient ( n , k ) NEW_LINE print ( \" Value ▁ of ▁ C ( % ▁ d , ▁ % ▁ d ) ▁ is ▁ % ▁ d \" % ( n , k , res ) ) NEW_LINE"}
{"text": "Program yang cekap untuk mencetak semua faktor utama nombor tertentu | Program python untuk mencetak faktor utama; Fungsi untuk mencetak semua faktor utama nombor n tertentu; Cetak bilangan dua yang membahagikan n; n mesti ganjil pada ketika ini supaya skip 2 (i = i + 2) boleh digunakan; Walaupun saya membahagikan n, cetak saya advide n; Keadaan jika n adalah nombor perdana yang lebih besar daripada 2; Program pemacu untuk menguji fungsi di atas", "code": "import math NEW_LINE def primeFactors ( n ) : NEW_LINE INDENT while n % 2 == 0 : NEW_LINE INDENT print 2 , NEW_LINE n = n / 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT print i , NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT print n NEW_LINE DEDENT DEDENT n = 315 NEW_LINE primeFactors ( n ) NEW_LINE"}
{"text": "Cetak semua kemungkinan kombinasi elemen R dalam pelbagai saiz n | Fungsi utama yang mencetak semua kombinasi saiz r dalam arr [] saiz n. Fungsi ini terutamanya menggunakan gabunganUtil (); Arahan sementara untuk menyimpan semua gabungan satu demi satu; Cetak semua gabungan menggunakan data temprary array []; arr [] - -> data array input [] - -> array sementara untuk menyimpan kombinasi semasa & akhir - -> menatap dan mengakhiri indeks dalam arr [] indeks - -> indeks semasa dalam data [] r - -> saiz kombinasi yang akan dicetak; Gabungan semasa sudah siap dicetak, mencetaknya; Gantikan indeks dengan semua elemen yang mungkin. Keadaan \"Akhir - I + 1 = u r - indeks\" memastikan bahawa termasuk satu elemen di indeks akan membuat kombinasi dengan elemen yang tinggal pada kedudukan yang tinggal; Kod pemacu", "code": "def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r ; NEW_LINE combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; NEW_LINE DEDENT def combinationUtil ( arr , data , start , end , index , r ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE return ; NEW_LINE DEDENT i = start ; NEW_LINE while ( i <= end and end - i + 1 >= r - index ) : NEW_LINE INDENT data [ index ] = arr [ i ] ; NEW_LINE combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE r = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE printCombination ( arr , n , r ) ; NEW_LINE"}
{"text": "Cetak semua kemungkinan kombinasi elemen R dalam pelbagai saiz n | Fungsi utama yang mencetak semua kombinasi saiz r dalam arr [] saiz n. Fungsi ini terutamanya menggunakan gabunganUtil (); Arahan sementara untuk menyimpan semua gabungan satu demi satu; Cetak semua gabungan menggunakan data temprary array []; arr [] - -> array input n - -> saiz array input r - -> saiz gabungan untuk dicetak indeks - -> indeks semasa dalam data [] data [] - -> array sementara untuk menyimpan kombinasi semasa i - -> indeks elemen semasa dalam arr []; Perbadanan semasa sudah siap, cetaknya; Apabila tidak ada lagi elemen yang ada untuk dimasukkan ke dalam data []; Semasa dimasukkan, letakkan seterusnya di lokasi seterusnya; Semasa dikecualikan, gantikannya dengan seterusnya (perhatikan bahawa i + 1 diluluskan, tetapi indeks tidak berubah); Kod pemacu", "code": "def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r NEW_LINE combinationUtil ( arr , n , r , 0 , data , 0 ) NEW_LINE DEDENT def combinationUtil ( arr , n , r , index , data , i ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT data [ index ] = arr [ i ] NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) NEW_LINE combinationUtil ( arr , n , r , index , data , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE r = 3 NEW_LINE n = len ( arr ) NEW_LINE printCombination ( arr , n , r ) NEW_LINE DEDENT"}
{"text": "Kira semua kumpulan saiz 2 atau 3 yang mungkin mempunyai jumlah sebagai pelbagai 3 | Mengembalikan kiraan semua kumpulan yang mungkin boleh dibentuk dari unsur -unsur []. ; Buat array C [3] untuk menyimpan bilangan elemen dengan selebihnya 0, 1 dan 2. C [i] akan menyimpan kiraan elemen dengan selebihnya I; Untuk menyimpan hasilnya; Mengira elemen dengan selebihnya 0, 1 dan 2; Kes 3. A: Kumpulan Kumpulan Saiz 2 dari 0 elemen yang tinggal; Kes 3. B: Kumpulan Kumpulan Saiz 2 dengan satu elemen dengan 1 baki dan lain -lain dengan 2 selebihnya; Kes 4. A: Kumpulan Kumpulan Saiz 3 dengan semua 0 elemen yang tinggal; Kes 4. B: Kumpulan Kumpulan Saiz 3 dengan semua 1 elemen yang tinggal; Kes 4. C: Kumpulan Kumpulan Saiz 3 dengan semua 2 elemen yang tinggal; Kes 4. C: Kumpulan Kumpulan Saiz 3 dengan sisa yang berbeza; Mengembalikan jumlah jumlah yang disimpan dalam res; Program Pemandu", "code": "def findgroups ( arr , n ) : NEW_LINE INDENT c = [ 0 , 0 , 0 ] NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT c [ arr [ i ] % 3 ] += 1 NEW_LINE DEDENT res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) NEW_LINE res += c [ 1 ] * c [ 2 ] NEW_LINE res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 NEW_LINE res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 NEW_LINE res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) NEW_LINE res += c [ 0 ] * c [ 1 ] * c [ 2 ] NEW_LINE return res NEW_LINE DEDENT arr = [ 3 , 6 , 7 , 2 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Required ▁ number ▁ of ▁ groups ▁ are \" , int ( findgroups ( arr , n ) ) ) NEW_LINE"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N |  ; Pertama n dalam keadaan di bawah adalah untuk kes di mana n adalah 0; Kod pemacu", "code": "def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count ; NEW_LINE DEDENT n = 0 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N |  ; Kod pemacu", "code": "def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p ; NEW_LINE DEDENT n = 5 NEW_LINE print ( nextPowerOf2 ( n ) ) ; NEW_LINE"}
{"text": "Kuasa terkecil 2 lebih besar daripada atau sama dengan N | Cari kuasa seterusnya dua untuk n. Jika n sendiri adalah kuasa dua maka pulangan n; Program pemacu untuk menguji fungsi di atas", "code": "def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT n = 5 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | Berfungsi untuk memisahkan 0 s dan 1 s; Mengira tiada sifar dalam arr; Gelung mengisi ARR dengan 0 sehingga dikira; Gelung mengisi ruang yang tinggal dengan 1; Berfungsi untuk mencetak array terasing; Fungsi pemacu", "code": "def segregate0and1 ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , count ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT for i in range ( count , n ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT def print_arr ( arr , n ) : NEW_LINE INDENT print ( \" Array ▁ after ▁ segregation ▁ is ▁ \" , end = \" \" ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE segregate0and1 ( arr , n ) NEW_LINE print_arr ( arr , n ) NEW_LINE"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | Berfungsi untuk meletakkan semua 0 s di kiri dan semua 1 s di sebelah kanan; Memulakan indeks kiri dan kanan; Indeks Kiri Peningkatan semasa kita melihat 0 di sebelah kiri; Indeks kanan pengurangan semasa kita melihat 1 di sebelah kanan; Jika kiri lebih kecil daripada kanan maka terdapat 1 di sebelah kiri dan 0 di sebelah kanan. Pertukaran arr [kiri] dan arr [kanan]; Program Pemandu untuk Menguji", "code": "def segregate0and1 ( arr , size ) : NEW_LINE INDENT left , right = 0 , size - 1 NEW_LINE while left < right : NEW_LINE INDENT while arr [ left ] == 0 and left < right : NEW_LINE INDENT left += 1 NEW_LINE DEDENT while arr [ right ] == 1 and left < right : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT if left < right : NEW_LINE INDENT arr [ left ] = 0 NEW_LINE arr [ right ] = 1 NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE print ( \" Array ▁ after ▁ segregation \" ) NEW_LINE print ( segregate0and1 ( arr , arr_size ) ) NEW_LINE"}
{"text": "Mengasingkan 0 s dan 1 s dalam array | Berfungsi untuk meletakkan semua 0 s di kiri dan semua 1 s di sebelah kanan; Kod pemacu", "code": "def segregate0and1 ( arr , size ) : NEW_LINE INDENT type0 = 0 NEW_LINE type1 = size - 1 NEW_LINE while ( type0 < type1 ) : NEW_LINE INDENT if ( arr [ type0 ] == 1 ) : NEW_LINE INDENT ( arr [ type0 ] , arr [ type1 ] ) = ( arr [ type1 ] , arr [ type0 ] ) NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE segregate0and1 ( arr , arr_size ) NEW_LINE print ( \" Array ▁ after ▁ segregation ▁ is \" , end = \" ▁ \" ) NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"}
{"text": "Unsur -unsur bersebelahan yang berbeza dalam array | Program Python untuk memeriksa sama ada kita boleh membuat jiran berbeza. ; dict digunakan untuk mengira kekerapan setiap elemen yang berlaku dalam array; Dalam gelung ini kita mengira kekerapan elemen melalui peta m; MX Simpan kekerapan elemen yang paling banyak berlaku dalam array. ; Dalam gelung ini kita mengira kekerapan maksimum dan simpannya dalam MX yang berubah -ubah. ; Dengan menukar kita boleh menyesuaikan array hanya apabila kekerapan elemen yang berlaku kebanyakannya kurang daripada atau sama dengan (n + 1) / 2. ; Kod pemacu", "code": "def distantAdjacentElement ( a , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in m : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mx < m [ a [ i ] ] : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT DEDENT if mx > ( n + 1 ) // 2 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 7 , 7 , 7 ] NEW_LINE n = len ( a ) NEW_LINE distantAdjacentElement ( a , n ) NEW_LINE DEDENT"}
{"text": "Memandangkan array arr [], cari maksimum j | Untuk array arr [], mengembalikan maksimum J a i sedemikian rupa sehingga arr [j]> arr [i]; kod pemacu", "code": "def maxIndexDiff ( arr , n ) : NEW_LINE INDENT maxDiff = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = n - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] and maxDiff < ( j - i ) : NEW_LINE INDENT maxDiff = j - i NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT return maxDiff NEW_LINE DEDENT arr = [ 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE maxDiff = maxIndexDiff ( arr , n ) NEW_LINE print ( maxDiff ) NEW_LINE"}
{"text": "Memandangkan array arr [], cari maksimum j | Untuk array array yang diberikan, hitung maksimum j a i sedemikian rupa sehingga arr [j]> arr [i]; Buat array MaxFromend; Kami menyimpan ini sebagai jawapan semasa dan mencari nombor yang lebih besar lagi ke sebelah kanan; Menjaga jejak perbezaan maksimum indeks", "code": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT v = [ 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 ] ; NEW_LINE n = len ( v ) ; NEW_LINE maxFromEnd = [ - 38749432 ] * ( n + 1 ) ; NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT maxFromEnd [ i ] = max ( maxFromEnd [ i + 1 ] , v [ i ] ) ; NEW_LINE DEDENT result = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT low = i + 1 ; high = n - 1 ; ans = i ; NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) ; NEW_LINE if ( v [ i ] <= maxFromEnd [ mid ] ) : NEW_LINE INDENT ans = max ( ans , mid ) ; NEW_LINE low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 ; NEW_LINE DEDENT DEDENT result = max ( result , ans - i ) ; NEW_LINE DEDENT print ( result , end = \" \" ) ; NEW_LINE DEDENT"}
{"text": "Cetak elemen array yang berbeza | Program Python3 untuk mencetak elemen yang disusun. ; Buat set menggunakan elemen array; Cetak kandungan set. ; Kod pemacu", "code": "def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE printRepeating ( arr , size ) NEW_LINE DEDENT"}
{"text": "Swap minimum untuk membuat dua tatasusunan sama | Fungsi Mengembalikan bilangan swap minimum yang diperlukan untuk menyusun array kaedah ini diambil dari bawah post https: www. Geeksforgeeks. org / minimum - nombor - swap - diperlukan - sort - array /; Buat pelbagai pasangan di mana elemen pertama adalah elemen array dan elemen kedua adalah kedudukan elemen pertama; Susun array dengan nilai elemen array untuk mendapatkan kedudukan yang betul setiap elemen sebagai elemen kedua pasangan. ; Untuk menjejaki elemen yang dikunjungi. Memulakan semua elemen yang tidak dikunjungi atau palsu. ; Memulakan hasil; Elemen Array Traverse; Sudah bertukar dan diperbetulkan atau sudah hadir di pos yang betul; Ketahui bilangan nod dalam kitaran ini dan tambah dalam ANS; Pindah ke Node Next; Kemas kini jawapan dengan menambahkan kitaran semasa. ; Hasil pulangan; Kaedah Mengembalikan bilangan swap minimum ke array mak Ar Array A; peta untuk menyimpan kedudukan elemen dalam Array B Kami pada dasarnya menyimpan elemen untuk indeks pemetaan. ; Kini kami menyimpan kedudukan array elemen dalam Array B .; Menghidupkan swap minimum untuk menyusun dalam array yang diubah suai b sebagai jawapan akhir; Kod pemacu", "code": "def minSwapsToSort ( arr , n ) : NEW_LINE INDENT arrPos = [ [ 0 for x in range ( 2 ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrPos [ i ] [ 0 ] = arr [ i ] NEW_LINE arrPos [ i ] [ 1 ] = i NEW_LINE DEDENT arrPos . sort ( ) NEW_LINE vis = [ False ] * ( n ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] or arrPos [ i ] [ 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while ( not vis [ j ] ) : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE j = arrPos [ j ] [ 1 ] NEW_LINE cycle_size += 1 NEW_LINE DEDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def minSwapToMakeArraySame ( a , b , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ b [ i ] ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b [ i ] = mp [ a [ i ] ] NEW_LINE DEDENT return minSwapsToSort ( b , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 6 , 4 , 8 ] NEW_LINE b = [ 4 , 6 , 8 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( minSwapToMakeArraySame ( a , b , n ) ) NEW_LINE DEDENT"}
{"text": "K | Berfungsi untuk mencari elemen k - th yang hilang; interating melalui array; Semak jika saya - th dan (i + 1) - elemen tidak berturut -turut; Simpan perbezaan mereka; Semak perbezaan dan diberikan k; jika dijumpai; Arahan input; K - elemen yang hilang dapat dijumpai dalam array; fungsi panggilan untuk mencari elemen yang hilang", "code": "def missingK ( a , k , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE count = k NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT difference = 0 NEW_LINE if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) : NEW_LINE INDENT difference += ( a [ i + 1 ] - a [ i ] ) - 1 NEW_LINE if ( difference >= count ) : NEW_LINE INDENT ans = a [ i ] + count NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT count -= difference NEW_LINE DEDENT DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT a = [ 1 , 5 , 11 , 19 ] NEW_LINE k = 11 NEW_LINE n = len ( a ) NEW_LINE missing = missingK ( a , k , n ) NEW_LINE print ( missing ) NEW_LINE"}
{"text": "K | Berfungsi untuk mencari nombor kth yang hilang; Sekiranya jumlah jumlah nombor yang hilang adalah sama dengan k kita boleh melangkah ke belakang untuk nombor yang hilang pertama dan itu akan menjadi jawapannya. ; Untuk mengoptimumkan lagi, kita periksa sama ada elemen sebelumnya yang hilang. Eg: 4,5,6,7,8] u u u obs obs u u u u u u u u u u. »~ Carian ~ tetingkap» dan u (LOGN) ~ masa Kompleksiti ~ f f f fely 'akan' telah o (n). ; Lain kita kembali arr [pertengahan] - 1 .; Di sini kita menyempitkan tetingkap carian dengan sewajarnya. ; Sekiranya had atas adalah - ia bermakna set nombor yang hilang ialah 1, 2 ,. . , k dan oleh itu kita terus kembali k. ; Lain kita dapati jumlah sisa nombor yang kita 'd kemudian tambahkan ke arr [u] dan dapatkan nombor kth yang hilang. ; Kembali arr [u] + k; Kod pemacu; Panggilan fungsi", "code": "def missingK ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE l = 0 NEW_LINE u = n - 1 NEW_LINE mid = 0 NEW_LINE while ( l <= u ) : NEW_LINE INDENT mid = ( l + u ) // 2 ; NEW_LINE numbers_less_than_mid = arr [ mid ] - ( mid + 1 ) ; NEW_LINE if ( numbers_less_than_mid == k ) : NEW_LINE if ( mid > 0 and ( arr [ mid - 1 ] - ( mid ) ) == k ) : NEW_LINE INDENT u = mid - 1 ; NEW_LINE continue ; NEW_LINE DEDENT return arr [ mid ] - 1 ; NEW_LINE if ( numbers_less_than_mid < k ) : NEW_LINE l = mid + 1 ; NEW_LINE elif ( k < numbers_less_than_mid ) : NEW_LINE u = mid - 1 ; NEW_LINE DEDENT if ( u < 0 ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT less = arr [ u ] - ( u + 1 ) ; NEW_LINE k -= less ; NEW_LINE return arr [ u ] + k ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 7 , 11 ] ; NEW_LINE k = 5 ; NEW_LINE print ( \" Missing ▁ kth ▁ number ▁ = ▁ \" + str ( missingK ( arr , k ) ) ) NEW_LINE DEDENT"}
{"text": "Alternatif ganjil dan juga nod dalam senarai yang berkaitan dengan tunggal | Nod senarai pautan; Fungsi utiliti untuk mencetak senarai yang dipautkan; Berfungsi untuk membuat newnode dalam senarai LinkedL; Berfungsi untuk memasukkan pada permulaan; Berfungsi untuk menyusun semula nod yang ganjil dan bahkan; Nilai ganjil dalam kedudukan walaupun menunjuk penunjuk ke nod semasa dalam timbunan ganjil; Malah nilai dalam kedudukan ganjil menambah penunjuk ke nod semasa dalam timbunan walaupun; Swap data di bahagian atas dua susunan; Kod pemacu", "code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = node . next NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT def newNode ( key ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = key NEW_LINE temp . next = None NEW_LINE return temp NEW_LINE DEDENT def insertBeg ( head , val ) : NEW_LINE INDENT temp = newNode ( val ) NEW_LINE temp . next = head NEW_LINE head = temp NEW_LINE return head NEW_LINE DEDENT def rearrangeOddEven ( head ) : NEW_LINE INDENT odd = [ ] NEW_LINE even = [ ] NEW_LINE i = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT if ( head . data % 2 != 0 and i % 2 == 0 ) : NEW_LINE INDENT odd . append ( head ) NEW_LINE DEDENT elif ( head . data % 2 == 0 and i % 2 != 0 ) : NEW_LINE INDENT even . append ( head ) NEW_LINE DEDENT head = head . next NEW_LINE i = i + 1 NEW_LINE DEDENT while ( len ( odd ) != 0 and len ( even ) != 0 ) : NEW_LINE INDENT odd [ - 1 ] . data , even [ - 1 ] . data = even [ - 1 ] . data , odd [ - 1 ] . data NEW_LINE odd . pop ( ) NEW_LINE even . pop ( ) NEW_LINE DEDENT return head NEW_LINE DEDENT head = newNode ( 8 ) NEW_LINE head = insertBeg ( head , 7 ) NEW_LINE head = insertBeg ( head , 6 ) NEW_LINE head = insertBeg ( head , 5 ) NEW_LINE head = insertBeg ( head , 3 ) NEW_LINE head = insertBeg ( head , 2 ) NEW_LINE head = insertBeg ( head , 1 ) NEW_LINE print ( \" Linked ▁ List : \" ) NEW_LINE printList ( head ) NEW_LINE rearrangeOddEven ( head ) NEW_LINE print ( \" Linked ▁ List ▁ after ▁ \" , \" Rearranging : \" ) NEW_LINE printList ( head ) NEW_LINE"}
{"text": "Alternatif ganjil dan juga nod dalam senarai yang berkaitan dengan tunggal | Struktur nod; Fungsi utiliti untuk mencetak senarai yang dipautkan; Berfungsi untuk membuat newnode dalam senarai LinkedL; Berfungsi untuk memasukkan pada permulaan; Berfungsi untuk menyusun semula nod yang ganjil dan bahkan; Langkah 1: Mengasingkan Node Even dan Odd Langkah 2: Split Odd dan juga menyenaraikan Langkah 3: Gabungkan senarai bahkan ke dalam senarai ganjil; Langkah 1: Mengasingkan ganjil dan juga nod; Sandaran penunjuk seterusnya temp; Jika temp adalah ganjil bergerak nod ke permulaan senarai; Pointer Temp Advance; Langkah 2 memecah senarai ke dalam ganjil dan bahkan; Tamatkan senarai ganjil (buat nod terakhir tiada); Langkah 3: Gabungkan bahkan senarai ke dalam ganjil; Walaupun kedua -dua senarai itu tidak habis sandaran sandaran seterusnya I dan J; PTR menunjuk kepada nod terkini yang ditambah; Advance I dan J Pointers; Senarai ganjil ekzos sebelum walaupun, tambahkan selebihnya senarai yang ganjil. ; Kes di mana senarai ekzos sebelum senarai ganjil ditangani secara automatik kerana kami menggabungkan senarai bahkan ke dalam senarai ganjil; Kod pemacu", "code": "class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = node . next NEW_LINE DEDENT print ( \" ▁ \" ) NEW_LINE DEDENT def newNode ( key ) : NEW_LINE INDENT temp = Node ( ) NEW_LINE temp . data = key NEW_LINE temp . next = None NEW_LINE return temp NEW_LINE DEDENT def insertBeg ( head , val ) : NEW_LINE INDENT temp = newNode ( val ) NEW_LINE temp . next = head NEW_LINE head = temp NEW_LINE return head NEW_LINE DEDENT def rearrange ( head ) : NEW_LINE INDENT even = None NEW_LINE temp = None NEW_LINE prev_temp = None NEW_LINE i = None NEW_LINE j = None NEW_LINE k = None NEW_LINE l = None NEW_LINE ptr = None NEW_LINE temp = ( head ) . next NEW_LINE prev_temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT x = temp . next NEW_LINE if ( temp . data % 2 != 0 ) : NEW_LINE INDENT prev_temp . next = x NEW_LINE temp . next = ( head ) NEW_LINE ( head ) = temp NEW_LINE DEDENT else : NEW_LINE INDENT prev_temp = temp NEW_LINE DEDENT temp = x NEW_LINE DEDENT temp = ( head ) . next NEW_LINE prev_temp = ( head ) NEW_LINE while ( temp != None and temp . data % 2 != 0 ) : NEW_LINE INDENT prev_temp = temp NEW_LINE temp = temp . next NEW_LINE DEDENT even = temp NEW_LINE prev_temp . next = None NEW_LINE i = head NEW_LINE j = even NEW_LINE while ( j != None and i != None ) : NEW_LINE INDENT k = i . next NEW_LINE l = j . next NEW_LINE i . next = j NEW_LINE j . next = k NEW_LINE ptr = j NEW_LINE i = k NEW_LINE j = l NEW_LINE DEDENT if ( i == None ) : NEW_LINE INDENT ptr . next = j NEW_LINE DEDENT return head NEW_LINE DEDENT head = newNode ( 8 ) NEW_LINE head = insertBeg ( head , 7 ) NEW_LINE head = insertBeg ( head , 6 ) NEW_LINE head = insertBeg ( head , 3 ) NEW_LINE head = insertBeg ( head , 5 ) NEW_LINE head = insertBeg ( head , 1 ) NEW_LINE head = insertBeg ( head , 2 ) NEW_LINE head = insertBeg ( head , 10 ) NEW_LINE print ( \" Linked ▁ List : \" ) NEW_LINE printList ( head ) NEW_LINE print ( \" Rearranged ▁ List \" ) NEW_LINE head = rearrange ( head ) NEW_LINE printList ( head ) NEW_LINE"}
{"text": "Putar semua elemen matriks kecuali kali pepenjuru k dengan 90 darjah dalam arah arah jam | Berfungsi untuk mencetak matriks; Melangkah ke atas baris; Melangkah ke atas lajur; Cetak nilai; Berfungsi untuk melaksanakan pertukaran unsur matriks dengan cara mengikut arah jam; Menyimpan baris terakhir; Menyimpan lajur terakhir; Melakukan swap; Berfungsi untuk memutar unsur -unsur pepenjuru bukan matriks k dalam arah arah jam; Kemas kini K ke K % 4; Melangkah sehingga k positif; Melepasi setiap baris n / 2 - th; Melepasi setiap lajur dari i ke n - i - 1; Semak sama ada elemen di i, j bukan elemen pepenjuru; Melakukan pertukaran; Cetak matriks; Kod pemacu", "code": "def printMat ( mat ) : NEW_LINE INDENT for i in range ( len ( mat ) ) : NEW_LINE INDENT for j in range ( len ( mat [ 0 ] ) ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def performSwap ( mat , i , j ) : NEW_LINE INDENT N = len ( mat ) NEW_LINE ei = N - 1 - i NEW_LINE ej = N - 1 - j NEW_LINE temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ ej ] [ i ] NEW_LINE mat [ ej ] [ i ] = mat [ ei ] [ ej ] NEW_LINE mat [ ei ] [ ej ] = mat [ j ] [ ei ] NEW_LINE mat [ j ] [ ei ] = temp NEW_LINE DEDENT def rotate ( mat , N , K ) : NEW_LINE INDENT K = K % 4 NEW_LINE while ( K > 0 ) : NEW_LINE INDENT for i in range ( int ( N / 2 ) ) : NEW_LINE INDENT for j in range ( i , N - i - 1 ) : NEW_LINE INDENT if ( i != j and ( i + j ) != N - 1 ) : NEW_LINE INDENT performSwap ( mat , i , j ) NEW_LINE DEDENT DEDENT DEDENT K -= 1 NEW_LINE DEDENT printMat ( mat ) NEW_LINE DEDENT K = 5 NEW_LINE mat = [ [ 1 , 2 , 3 , 4 ] , [ 6 , 7 , 8 , 9 ] , [ 11 , 12 , 13 , 14 ] , [ 16 , 17 , 18 , 19 ] ] NEW_LINE N = len ( mat ) NEW_LINE rotate ( mat , N , K ) NEW_LINE"}
{"text": "Putaran minimum diperlukan untuk mendapatkan rentetan yang sama | Mengembalikan kiraan putaran untuk mendapatkan kembali rentetan yang sama. ; TMP adalah rentetan yang disatukan. ; Substring dari I Indeks saiz rentetan asal. ; Jika substring sepadan dengan rentetan asal maka kami akan keluar dari gelung. ; Kod pemacu", "code": "def findRotations ( str ) : NEW_LINE INDENT tmp = str + str NEW_LINE n = len ( str ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT substring = tmp [ i : i + n ] NEW_LINE if ( str == substring ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abc \" NEW_LINE print ( findRotations ( str ) ) NEW_LINE DEDENT"}
{"text": "Count of Elements yang Kuasa 2 dalam Subarray Julat tertentu untuk QQueries | Pelaksanaan Python3 untuk mencari unsur -unsur yang merupakan kuasa dua; Awalan [i] akan menyimpan bilangan elemen yang merupakan kuasa dua hingga i (termasuk i). ; Berfungsi untuk mencari julat maksimum yang jumlahnya boleh dibahagikan dengan m. ; Kirakan jumlah awalan; Berfungsi untuk mengembalikan bilangan elemen yang merupakan kuasa dua dalam subarray; Kod pemacu", "code": "MAX = 10000 NEW_LINE prefix = [ 0 ] * ( MAX + 1 ) NEW_LINE def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x and ( not ( x & ( x - 1 ) ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def computePrefix ( n , a ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ 0 ] ) ) : NEW_LINE INDENT prefix [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] NEW_LINE if ( isPowerOfTwo ( a [ i ] ) ) : NEW_LINE INDENT prefix [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def query ( L , R ) : NEW_LINE INDENT return prefix [ R ] - prefix [ L - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 8 , 5 , 2 , 5 , 10 ] NEW_LINE N = len ( A ) NEW_LINE Q = 2 NEW_LINE computePrefix ( N , A ) NEW_LINE print ( query ( 0 , 4 ) ) NEW_LINE print ( query ( 3 , 5 ) ) NEW_LINE DEDENT"}
{"text": "Count of Integral Coordinates yang terletak di dalam persegi | Berfungsi untuk mengira titik integral di dalam persegi; Kod pemacu", "code": "def countIntgralPoints ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 1 NEW_LINE y1 = 1 NEW_LINE x2 = 4 NEW_LINE y2 = 4 NEW_LINE countIntgralPoints ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT"}
{"text": "Cari nombor seterusnya yang mempunyai digit yang berbeza dari nombor N | Berfungsi untuk mencari nombor digit yang berbeza; Gelung untuk mencari digit yang berbeza menggunakan array hash dan bilangan digit; Gelung untuk mencari digit yang paling ketara dari nombor seterusnya; Keadaan untuk memeriksa sama ada nombor itu mungkin dengan bilangan angka yang sama; Keadaan untuk memeriksa sama ada digit yang paling significant yang dikehendaki dijumpai; Gelung untuk mencari digit seterusnya minimum yang tidak hadir dalam nombor; Pengiraan nombor; Syarat untuk memeriksa sama ada nombor itu lebih besar daripada nombor yang diberikan; Kod pemacu", "code": "def findNextNumber ( n ) : NEW_LINE INDENT h = [ 0 for i in range ( 10 ) ] NEW_LINE i = 0 NEW_LINE msb = n NEW_LINE rem = 0 NEW_LINE next_num = - 1 NEW_LINE count = 0 NEW_LINE while ( msb > 9 ) : NEW_LINE INDENT rem = msb % 10 NEW_LINE h [ rem ] = 1 NEW_LINE msb //= 10 NEW_LINE count += 1 NEW_LINE DEDENT h [ msb ] = 1 NEW_LINE count += 1 NEW_LINE for i in range ( msb + 1 , 10 , 1 ) : NEW_LINE INDENT if ( h [ i ] == 0 ) : NEW_LINE INDENT next_num = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( next_num == - 1 ) : NEW_LINE INDENT for i in range ( 1 , msb , 1 ) : NEW_LINE INDENT if ( h [ i ] == 0 ) : NEW_LINE INDENT next_num = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( next_num > 0 ) : NEW_LINE INDENT for i in range ( 0 , 10 , 1 ) : NEW_LINE INDENT if ( h [ i ] == 0 ) : NEW_LINE INDENT msb = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 1 , count , 1 ) : NEW_LINE INDENT next_num = ( ( next_num * 10 ) + msb ) NEW_LINE DEDENT if ( next_num > n ) : NEW_LINE INDENT print ( next_num ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2019 NEW_LINE findNextNumber ( n ) NEW_LINE DEDENT"}
{"text": "Cari triplet (a, b, c) supaya 3 * a + 5 * b + 7 * c sama dengan n | Berfungsi untuk mencari triplet (a, b, c) supaya 3 * a + 5 * b + 7 * c ialah n; Melangkah ke atas julat [0, N7]; Melangkah ke atas julat [0, N5]; Cari nilai a; Jika A lebih besar daripada atau sama dengan 0 dan dibahagikan dengan 3; Jika tidak, cetak - 1; Kod pemacu", "code": "def CalculateValues ( N ) : NEW_LINE INDENT for C in range ( 0 , N // 7 + 1 ) : NEW_LINE INDENT for B in range ( 0 , N // 5 + 1 ) : NEW_LINE INDENT A = N - 7 * C - 5 * B NEW_LINE if ( A >= 0 and A % 3 == 0 ) : NEW_LINE INDENT print ( \" A ▁ = \" , A / 3 , \" , ▁ B ▁ = \" , B , \" , ▁ \\ ▁ C ▁ = \" , C , sep = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 19 NEW_LINE CalculateValues ( 19 ) NEW_LINE DEDENT"}
{"text": "Kurangkan jumlah masa yang diambil oleh dua orang untuk melawat bandar -bandar sehingga tidak ada yang bertemu | Berfungsi untuk mencari masa minimum untuk melawat semua bandar sehingga kedua -dua orang tidak pernah bertemu; Memulakan jumlah sebagai 0; Cari elemen maksimum; Melintasi array; Jumlah kenaikan oleh arr [i]; Prmaximum 2 * t dan jumlah; Kod pemacu; Panggilan fungsi", "code": "def minimumTime ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE T = max ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( max ( 2 * T , sum ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 8 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE minimumTime ( arr , N ) NEW_LINE DEDENT"}
{"text": "Rentetan lexicographically terbesar mungkin dengan membalikkan substring yang mempunyai bilangan 1 s | Berfungsi untuk mencari rentetan maksimum lexicographically dengan membalikkan substrings yang mempunyai bilangan 1 s; Saiz saiz rentetan; Melintasi rentetan; Kira bilangan 1 s; Menyimpan indeks permulaan; Menyimpan indeks akhir; Kiraan kenaikan, apabila 1 ditemui; Melintasi rentetan yang tinggal; Temp adalah untuk membalikkan rentetan dari indeks permulaan dan akhir; Mencetak rentetan; Kod pemacu", "code": "def lexicographicallyMax ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE beg = i NEW_LINE end = i NEW_LINE if ( s [ i ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( s [ j ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count % 2 == 0 and count != 0 ) : NEW_LINE INDENT end = j NEW_LINE break NEW_LINE DEDENT DEDENT temp = s [ beg : end + 1 ] NEW_LINE temp = temp [ : : - 1 ] NEW_LINE s = s [ 0 : beg ] + temp + s [ end + 1 : ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT S = \"0101\" NEW_LINE lexicographicallyMax ( S ) NEW_LINE"}
{"text": "Kira pasangan maksimum yang mungkin dari array yang mempunyai jumlah k | Fungsi untuk mengira bilangan maksimum pasangan dari array yang diberikan dengan jumlah k; Susun array dalam urutan yang semakin meningkat; Menyimpan hasil akhir; Memulakan penunjuk kiri dan kanan; TRAVERSE ARRAY Sehingga mula <end; Pengurangan hak oleh 1; Kenaikan ditinggalkan oleh 1; Hasil kenaikan dan penunjuk kiri oleh 1 dan penunjuk kanan penurunan dengan 1; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "def maxPairs ( nums , k ) : NEW_LINE INDENT nums = sorted ( nums ) NEW_LINE result = 0 NEW_LINE start , end = 0 , len ( nums ) - 1 NEW_LINE while ( start < end ) : NEW_LINE INDENT if ( nums [ start ] + nums [ end ] > k ) : NEW_LINE INDENT end -= 1 NEW_LINE DEDENT elif ( nums [ start ] + nums [ end ] < k ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT else : NEW_LINE INDENT start += 1 NEW_LINE end -= 1 NEW_LINE result += 1 NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE K = 5 NEW_LINE maxPairs ( arr , K ) NEW_LINE DEDENT"}
{"text": "Kira pasangan maksimum yang mungkin dari array yang mempunyai jumlah k | Berfungsi untuk mencari bilangan maksimum pasangan dengan jumlah k sedemikian rupa sehingga elemen yang sama tidak dapat digunakan dua kali; Memulakan hashm; Simpan hasil akhir; Melangkah ke atas array nums []; Menurunkan kekerapannya dalam m dan kenaikan hasilnya dengan 1; Meningkatkan kekerapannya dengan 1 jika sudah ada dalam m. Jika tidak, tetapkan kekerapannya kepada 1; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "def maxPairs ( nums , k ) : NEW_LINE INDENT m = { } NEW_LINE result = 0 NEW_LINE for i in nums : NEW_LINE INDENT if ( ( i in m ) and m [ i ] > 0 ) : NEW_LINE INDENT m [ i ] = m [ i ] - 1 NEW_LINE result += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if k - i in m : NEW_LINE INDENT m [ k - i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ k - i ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( result ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE K = 5 NEW_LINE maxPairs ( arr , K ) NEW_LINE"}
{"text": "Indeks cetak elemen array yang penyingkirannya menjadikan jumlah ganjil dan bahkan | Fungsi untuk mencari indeks unsur -unsur array yang penyingkirannya menjadikan jumlah elemen array yang ganjil dan juga diindeks sama; Kedai saiz array; Simpan awalan jumlah elemen array indeks ganjil; Simpan awalan jumlah elemen array indeks walaupun; Kemas kini walaupun [0]; Melintasi array yang diberikan; Mengemas kini ganjil [i]; Kemas kini walaupun [i]; Jika indeks semasa adalah nombor yang sama; Kemas kini walaupun [i]; Jika indeks semasa adalah nombor ganjil; Mengemas kini ganjil [i]; Semak sama ada sekurang -kurangnya satu indeks yang dijumpai atau tidak yang memenuhi syarat; Simpan indeks ganjil dengan mengeluarkan indeks 0 - TH; Simpan walaupun indeks jumlah dengan mengeluarkan indeks 0 - Th; Jika p dan q sama; Melintasi array arr; Jika saya adalah nombor yang sama; Kemas kini P dengan mengeluarkan elemen i - th; Kemas kini Q dengan mengeluarkan elemen I - th; Kemas kini Q dengan mengeluarkan elemen I - th; Kemas kini P dengan mengeluarkan elemen i - th; Jika nilai indeks ganjil jumlah sama dengan nilai indeks walaupun jumlah; Tetapkan pemboleh ubah mencari; Cetak indeks semasa; Jika tidak ada indeks yang dijumpai; Cetak tidak mungkin; Kod pemacu", "code": "def removeIndicesToMakeSumEqual ( arr ) : NEW_LINE INDENT N = len ( arr ) ; NEW_LINE odd = [ 0 ] * N ; NEW_LINE even = [ 0 ] * N ; NEW_LINE even [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT odd [ i ] = odd [ i - 1 ] ; NEW_LINE even [ i ] = even [ i - 1 ] ; NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT even [ i ] += arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT odd [ i ] += arr [ i ] ; NEW_LINE DEDENT DEDENT find = False ; NEW_LINE p = odd [ N - 1 ] ; NEW_LINE q = even [ N - 1 ] - arr [ 0 ] ; NEW_LINE if ( p == q ) : NEW_LINE INDENT print ( \"0 ▁ \" ) ; NEW_LINE find = True ; NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; NEW_LINE q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; NEW_LINE p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; NEW_LINE DEDENT if ( p == q ) : NEW_LINE INDENT find = True ; NEW_LINE print ( i , end = \" \" ) ; NEW_LINE DEDENT DEDENT if ( find == False ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 1 , 6 , 2 ] ; NEW_LINE removeIndicesToMakeSumEqual ( arr ) ; NEW_LINE DEDENT"}
{"text": "Penyingkiran minimum diperlukan untuk membuat bitonic array yang diberikan | Fungsi untuk coutnt elemen array minimum yang diperlukan untuk dikeluarkan untuk membuat bitonic array; Kiri [i]: menyimpan panjang lis sehingga indeks i - th; kanan [i]: menyimpan panjang penurunan seterusnya ke atas julat [i, n]; Kirakan panjang LIS sehingga indeks i - th; Melintasi array sehingga indeks i - th; Jika arr [j] kurang daripada arr [i]; Kemas kini kiri [i]; Kirakan panjang penurunan seterusnya ke atas julat [i, n]; Melintasi kanan [] array; Jika arr [i] lebih besar daripada arr [j]; Kemas kini betul [i]; Kedai panjang array bitonic terpanjang; Traverse kiri [] dan kanan [] array; Kemas kini Maxlen; Fungsi untuk penyingkiran prminimum yang diperlukan untuk membuat bitonic array yang diberikan; Kod pemacu", "code": "def min_element_removal ( arr , N ) : NEW_LINE INDENT left = [ 1 ] * N NEW_LINE right = [ 1 ] * ( N ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT left [ i ] = max ( left [ i ] , left [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 1 , i , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT right [ i ] = max ( right [ i ] , right [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT maxLen = 0 NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT maxLen = max ( maxLen , left [ i ] + right [ i ] - 1 ) NEW_LINE DEDENT print ( ( N - maxLen ) ) NEW_LINE DEDENT def makeBitonic ( arr , N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE return NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT if ( arr [ 0 ] != arr [ 1 ] ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"1\" ) NEW_LINE DEDENT return NEW_LINE DEDENT min_element_removal ( arr , N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 1 , 5 , 6 , 2 , 3 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE makeBitonic ( arr , N ) NEW_LINE DEDENT"}
{"text": "Count Subarrays mempunyai kiraan yang sama dengan 0 dan 1 S berasal | Fungsi untuk mengira subarray yang mempunyai kiraan yang sama dengan 0 s dan 1 s dengan semua 0 s dan semua 1 dikelompokkan bersama; Menyimpan kiraan subarray; Jika elemen semasa berbeza daripada elemen array seterusnya; Kiraan kenaikan; Hitung kekerapan 1 s dan 0 s; Kiraan kenaikan; Cetak kiraan akhir; Kod pemacu; Panggilan fungsi", "code": "def countSubarrays ( A , N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i ] != A [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE j = i - 1 ; k = i + 2 ; NEW_LINE while ( j >= 0 and k < N and A [ j ] == A [ i ] and A [ k ] == A [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE j -= 1 ; NEW_LINE k += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 1 , 0 , 0 , 1 , 0 ] ; NEW_LINE N = len ( A ) ; NEW_LINE countSubarrays ( A , N ) ; NEW_LINE DEDENT"}
{"text": "Kiraan quadruples jenis yang diberikan dari array yang diberikan | Program Python3 pendekatan di atas; lcount [i] [j]: menyimpan kiraan saya di sebelah kiri indeks j; rcount [i] [j]: menyimpan kiraan saya di kanan indeks j; Berfungsi untuk mengira unsur -unsur unik di kiri dan kanan mana -mana indeks; Cari elemen array maksimum; Kirakan jumlah awalan jumlah setiap nilai; Kirakan jumlah akhiran jumlah setiap nilai; Berfungsi untuk mengira kuadruples jenis yang diperlukan; Kod pemacu", "code": "maxN = 2002 NEW_LINE lcount = [ [ 0 for i in range ( maxN ) ] for j in range ( maxN ) ] NEW_LINE rcount = [ [ 0 for i in range ( maxN ) ] for j in range ( maxN ) ] NEW_LINE def fill_counts ( a , n ) : NEW_LINE INDENT maxA = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > maxA ) : NEW_LINE INDENT maxA = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT lcount [ a [ i ] ] [ i ] = 1 NEW_LINE rcount [ a [ i ] ] [ i ] = 1 NEW_LINE DEDENT for i in range ( maxA + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT lcount [ i ] [ j ] = ( lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ) NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT rcount [ i ] [ j ] = ( rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def countSubsequence ( a , n ) : NEW_LINE INDENT fill_counts ( a , n ) NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT answer += ( lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT a = [ 1 , 2 , 3 , 2 , 1 , 3 , 2 ] NEW_LINE print ( countSubsequence ( a , 7 ) ) NEW_LINE"}
{"text": "Kurangkan rentetan dengan mengeluarkan kurungan paling luar dari setiap substring primitif | Fungsi untuk menghapuskan tanda kurung paling luar setiap substring primitif dari rentetan yang diberikan; Menyimpan rentetan yang dihasilkan; Menyimpan kiraan tanda kurung yang dibuka; Melintasi rentetan; Jika pembukaan kurungan ditemui dan kiraan mereka melebihi 0; Termasuk watak; Jika penutupan kurungan ditemui dan kiraannya kurang daripada mengira tanda kurung pembukaan; Termasuk watak; Kembali rentetan yang dihasilkan; Kod pemacu", "code": "def removeOuterParentheses ( S ) : NEW_LINE INDENT res = \" \" NEW_LINE count = 0 NEW_LINE for c in S : NEW_LINE INDENT if ( c == ' ( ' and count > 0 ) : NEW_LINE INDENT res += c NEW_LINE DEDENT if ( c == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( c == ' ) ' and count > 1 ) : NEW_LINE INDENT res += c NEW_LINE DEDENT if ( c == ' ) ' ) : NEW_LINE count -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" ( ( ) ( ) ) ( ( ) ) ( ) \" NEW_LINE print ( removeOuterParentheses ( S ) ) NEW_LINE DEDENT"}
{"text": "Panjang subarray terpanjang dengan peningkatan unsur -unsur bersebelahan | Berfungsi untuk mencari subarray terpanjang dengan unsur -unsur bersebelahan yang semakin meningkat; Menyimpan panjang subarray terpanjang yang diperlukan; Menyimpan panjang panjang subarray yang paling lama dari indeks ith; Jika unsur -unsur berturut -turut semakin meningkat dan berbeza dengan 1; Jika tidak; Kemas kini subarray terpanjang yang diperoleh setakat ini; Mengembalikan panjang yang diperoleh; Kod pemacu", "code": "def maxiConsecutiveSubarray ( arr , N ) : NEW_LINE INDENT maxi = 0 ; NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE for j in range ( i , N - 1 ) : NEW_LINE INDENT if ( arr [ j + 1 ] == arr [ j ] + 1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT maxi = max ( maxi , cnt ) ; NEW_LINE i = j ; NEW_LINE DEDENT return maxi ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 11 ; NEW_LINE arr = [ 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 ] ; NEW_LINE print ( maxiConsecutiveSubarray ( arr , N ) ) ; NEW_LINE DEDENT"}
{"text": "Panjang seterusnya terpanjang yang mempunyai jumlah digit setiap elemen sebagai nombor komposit | Pelaksanaan Python3 pendekatan di atas; Berfungsi untuk menjana nombor perdana menggunakan ayak eratosthenes; Tetapkan 0 dan 1 sebagai bukan perdana; Jika p adalah perdana; Tetapkan semua gandaan p sebagai bukan perdana; Berfungsi untuk mencari jumlah digit nombor tertentu; Menyimpan jumlah digit; Ekstrak digit dan tambah kepada jumlah; Kembalikan jumlah digit; Berfungsi untuk mencari berikutnya yang paling lama dengan jumlah digit setiap elemen bersamaan dengan nombor komposit; Hitung jumlah digit elemen array semasa; Jika jumlah digit sama dengan 1; Jika jumlah digit adalah perdana; Kod pemacu; Panggilan fungsi", "code": "N = 100005 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def digitSum ( number ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT sum += ( number % 10 ) NEW_LINE number //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def longestCompositeDigitSumSubsequence ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE prime = [ True ] * ( N + 1 ) NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = digitSum ( arr [ i ] ) NEW_LINE if ( res == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( not prime [ res ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 13 , 55 , 7 , 3 , 5 , 1 , 10 , 21 , 233 , 144 , 89 ] NEW_LINE n = len ( arr ) NEW_LINE longestCompositeDigitSumSubsequence ( arr , n ) NEW_LINE DEDENT"}
{"text": "Jumlah nod yang seimbang dari pokok binari yang diberikan | Struktur pokok binari; Berfungsi untuk membuat nod baru; Mengembalikan nod yang dibuat; Berfungsi untuk memasukkan nod di dalam pokok; Penyisipan kiri; Penyisipan kanan; Mengembalikan nod akar; Berfungsi untuk mencari jumlah node yang seimbang di dalam pokok; Kes asas; Cari jumlah subtree kiri; Cari jumlah yang betul; Keadaan node yang seimbang; Keadaan node yang seimbang; Mengembalikan jumlahnya; Berfungsi untuk membina pokok binari; Bentuk nod akar pokok; Masukkan nod ke dalam pokok; Buat nod baru; Masukkan nod; Kembalikan akar pokok; Berfungsi untuk mencari jumlah node yang seimbang; Membina pokok; Menyimpan jumlah node yang seimbang; Panggilan fungsi; Cetak jumlah yang diperlukan; Kod pemacu; Diberikan nod; Diberikan akar; Diberikan maklumat laluan nod dari akar; Diberikan nilai nod; Panggilan fungsi", "code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newnode ( data ) : NEW_LINE INDENT temp = Node ( data ) NEW_LINE return temp NEW_LINE DEDENT def insert ( s , i , N , root , temp ) : NEW_LINE INDENT if ( i == N ) : NEW_LINE INDENT return temp NEW_LINE DEDENT if ( s [ i ] == ' L ' ) : NEW_LINE INDENT root . left = insert ( s , i + 1 , N , root . left , temp ) NEW_LINE DEDENT else : NEW_LINE INDENT root . right = insert ( s , i + 1 , N , root . right , temp ) NEW_LINE DEDENT return root NEW_LINE DEDENT def SBTUtil ( root , sum ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return [ 0 , sum ] NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return [ root . data , sum ] NEW_LINE DEDENT left , sum = SBTUtil ( root . left , sum ) NEW_LINE right , sum = SBTUtil ( root . right , sum ) NEW_LINE if ( root . left and root . right ) : NEW_LINE INDENT if ( ( left % 2 == 0 and right % 2 != 0 ) or ( left % 2 != 0 and right % 2 == 0 ) ) : NEW_LINE INDENT sum += root . data NEW_LINE DEDENT DEDENT return [ left + right + root . data , sum ] NEW_LINE DEDENT def build_tree ( R , N , str , values ) : NEW_LINE INDENT root = newnode ( R ) NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT s = str [ i ] NEW_LINE x = values [ i ] NEW_LINE temp = newnode ( x ) NEW_LINE root = insert ( s , 0 , len ( s ) , root , temp ) NEW_LINE DEDENT return root NEW_LINE DEDENT def speciallyBalancedNodes ( R , N , str , values ) : NEW_LINE INDENT root = build_tree ( R , N , str , values ) NEW_LINE sum = 0 NEW_LINE tmp , sum = SBTUtil ( root , sum ) NEW_LINE print ( sum , end = ' ▁ ' ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 7 NEW_LINE R = 12 NEW_LINE str = [ \" L \" , \" R \" , \" RL \" , \" RR \" , \" RLL \" , \" RLR \" ] NEW_LINE values = [ 17 , 16 , 4 , 9 , 2 , 3 ] NEW_LINE speciallyBalancedNodes ( R , N , str , values ) NEW_LINE DEDENT"}
{"text": "Pasangan yang mempunyai semua pasangan lain yang terletak di antara minimum dan maksimumnya | Fungsi untuk mencari kedudukan pasangan yang meliputi setiap pasangan dalam array arr; Menyimpan indeks pasangan yang dihasilkan; Untuk mengira kejadian; Berulang untuk memeriksa setiap pasangan; Tetapkan kiraan ke 0; Keadaan untuk diperiksa untuk bertindih pasangan; Jika pasangan itu dapat menutup semua pasangan lain maka simpan kedudukannya; Jika kedudukan tidak dijumpai; Jika tidak; Kod pemacu; Diberikan pelbagai pasangan; Panggilan fungsi", "code": "def position ( arr , N ) : NEW_LINE INDENT pos = - 1 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] and arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT if ( count == N ) : NEW_LINE INDENT pos = i ; NEW_LINE DEDENT DEDENT if ( pos == - 1 ) : NEW_LINE INDENT print ( pos ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( pos + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 3 , 3 ] , [ 1 , 3 ] , [ 2 , 2 ] , [ 2 , 3 ] , [ 1 , 2 ] ] ; NEW_LINE N = len ( arr ) ; NEW_LINE position ( arr , N ) ; NEW_LINE DEDENT"}
{"text": "Pasangan yang mempunyai semua pasangan lain yang terletak di antara minimum dan maksimumnya | Program Python3 untuk pendekatan di atas; Fungsi untuk mencari kedudukan pasangan yang meliputi setiap pasangan dalam array arr [] []; Kedudukan untuk menyimpan indeks; Menyimpan nilai kedua minimum; Menyimpan nilai pertama maksimum; Melangkah ke atas pelbagai pasangan; Kemas kini maksimum yang betul; Kemas kini minimum kiri; Melangkah ke atas pelbagai pasangan; Jika ada pasangan yang ada dengan nilai {kiri, kemudian simpannya; Cetak jawapannya; Kod pemacu; Diberikan pelbagai pasangan; Panggilan fungsi", "code": "import sys NEW_LINE def position ( arr , N ) : NEW_LINE INDENT pos = - 1 NEW_LINE right = - sys . maxsize - 1 NEW_LINE left = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] [ 1 ] > right ) : NEW_LINE INDENT right = arr [ i ] [ 1 ] NEW_LINE DEDENT if ( arr [ i ] [ 0 ] < left ) : NEW_LINE INDENT left = arr [ i ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] == left and arr [ i ] [ 1 ] == right ) : NEW_LINE INDENT pos = i + 1 NEW_LINE DEDENT DEDENT print ( pos ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 3 , 3 ] , [ 1 , 3 ] , [ 2 , 2 ] , [ 2 , 3 ] , [ 1 , 2 ] ] NEW_LINE N = len ( arr ) NEW_LINE position ( arr , N ) NEW_LINE DEDENT"}
{"text": "Kurangkan kiraan operasi yang diberikan untuk membuat dua permutasi rentetan yang diberikan antara satu sama lain | Berfungsi untuk meminimumkan kiraan operasi untuk membuat permutasi Str1 dan Str2 antara satu sama lain; Simpan kekerapan setiap watak Str1; Simpan kekerapan setiap watak Str2; Melintasi freq1 [] dan freq2 []; Jika kekerapan watak dalam str1 lebih besar daripada str2; Jika tidak; Simpan jumlah Freq1 []; Simpan jumlah freq2 []; Kod pemacu", "code": "def ctMinEdits ( str1 , str2 ) : NEW_LINE INDENT N1 = len ( str1 ) NEW_LINE N2 = len ( str2 ) NEW_LINE freq1 = [ 0 ] * 256 NEW_LINE for i in range ( N1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT freq2 = [ 0 ] * 256 NEW_LINE for i in range ( N2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 256 ) : NEW_LINE INDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT freq1 [ i ] = freq1 [ i ] - freq2 [ i ] NEW_LINE freq2 [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT freq2 [ i ] = freq2 [ i ] - freq1 [ i ] NEW_LINE freq1 [ i ] = 0 NEW_LINE DEDENT DEDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT sum1 += freq1 [ i ] NEW_LINE sum2 += freq2 [ i ] NEW_LINE DEDENT return max ( sum1 , sum2 ) NEW_LINE DEDENT str1 = \" geeksforgeeks \" NEW_LINE str2 = \" geeksforcoder \" NEW_LINE print ( ctMinEdits ( str1 , str2 ) ) NEW_LINE"}
{"text": "Kiraan pasangan (i, j) dari arrays arr [] & brr [] sedemikian rupa sehingga arr [i] | Fungsi untuk mengira pasangan sedemikian rupa sehingga keadaan yang diberikan berpuas hati; Menyimpan jumlah elemen pada setiap indeks yang sepadan; Cari jumlah setiap indeks kedua -dua array; Kedai kekerapan setiap elemen yang terdapat di Sumarr; Memulakan bilangan pasangan; Tambah mungkin pasangan VAID; Pulangan bilangan pasangan; Diberikan array arr [] dan brr []; Saiz array yang diberikan; Fungsi panggilan", "code": "def CountPairs ( a , b , n ) : NEW_LINE INDENT C = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT C [ i ] = a [ i ] + b [ i ] NEW_LINE DEDENT freqCount = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if C [ i ] in freqCount . keys ( ) : NEW_LINE INDENT freqCount [ C [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freqCount [ C [ i ] ] = 1 NEW_LINE DEDENT DEDENT NoOfPairs = 0 NEW_LINE for x in freqCount : NEW_LINE INDENT y = freqCount [ x ] NEW_LINE NoOfPairs = ( NoOfPairs + y * ( y - 1 ) // 2 ) NEW_LINE DEDENT print ( NoOfPairs ) NEW_LINE DEDENT arr = [ 1 , 4 , 20 , 3 , 10 , 5 ] NEW_LINE brr = [ 9 , 6 , 1 , 7 , 11 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE CountPairs ( arr , brr , N ) NEW_LINE"}
{"text": "Perubahan dalam median array yang diberikan selepas memadam elemen yang diberikan | Berfungsi untuk mencari perubahan median selepas mengeluarkan elemen dari ARR2 []; Untuk menyimpan median; Jika n adalah ganjil; Jika n juga; Cari elemen semasa dalam ARR1; Padamkan elemen; Pengurangan n; Jika n adalah ganjil; Jika n juga; Cetak perbezaan median yang sepadan; Kod pemacu; Diberikan susunan; Panggilan fungsi", "code": "def medianChange ( arr1 , arr2 ) : NEW_LINE INDENT N = len ( arr1 ) NEW_LINE median = [ ] NEW_LINE if ( N & 1 ) : NEW_LINE INDENT median . append ( arr1 [ N // 2 ] * 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT median . append ( ( arr1 [ N // 2 ] + arr1 [ ( N - 1 ) // 2 ] ) // 2 ) NEW_LINE DEDENT for x in arr2 : NEW_LINE INDENT it = arr1 . index ( x ) NEW_LINE arr1 . pop ( it ) NEW_LINE N -= 1 NEW_LINE if ( N & 1 ) : NEW_LINE INDENT median . append ( arr1 [ N // 2 ] * 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT median . append ( ( arr1 [ N // 2 ] + arr1 [ ( N - 1 ) // 2 ] ) // 2 ) NEW_LINE DEDENT DEDENT for i in range ( len ( median ) - 1 ) : NEW_LINE INDENT print ( median [ i + 1 ] - median [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 2 , 4 , 6 , 8 , 10 ] NEW_LINE arr2 = [ 4 , 6 ] NEW_LINE medianChange ( arr1 , arr2 ) NEW_LINE DEDENT"}
{"text": "NFA untuk menerima rentetan yang mempunyai atleast satu watak yang berlaku dalam pelbagai 3 | Pembolehubah NFA yang menjejaki keadaan semasa urus niaga. ; Pemeriksaan ini untuk input tidak sah. ; Fungsi untuk keadaan Q2; Peralihan Negeri 'A' mengambil ke Q4, dan 'B' dan 'C' kekal pada Q2; Fungsi untuk keadaan Q3; Peralihan Negeri 'A' mengambil ke Q3, dan 'B' dan 'C' kekal pada Q4; Fungsi untuk keadaan Q4; Peralihan Negeri 'A' mengambil ke Q2, dan 'B' dan 'C' kekal pada Q3; Fungsi untuk negeri Q5; Peralihan negeri 'B' mengambil ke Q6, dan 'A' dan 'C' kekal pada Q5; Fungsi untuk keadaan Q6; Peralihan Negeri 'B' mengambil Q7, dan 'A' dan 'C' kekal pada Q7; Fungsi untuk negeri Q7; Peralihan Negeri 'B' mengambil ke Q5, dan 'A' dan 'C' kekal pada Q7; Fungsi untuk negeri Q8; Peralihan Negeri 'C' mengambil Q9, dan 'A' dan 'B' kekal pada Q8; Fungsi untuk Negeri Q9; Peralihan Negeri 'C' mengambil ke Q10, dan 'A' dan 'B' kekal pada Q9; Fungsi untuk keadaan Q10; Peralihan Negeri 'C' mengambil ke Q8, dan 'A' dan 'B' kekal pada Q10; Berfungsi untuk memeriksa 3 a; Berfungsi untuk memeriksa 3 b; Berfungsi untuk memeriksa 3 c 's; Kod pemacu; Sekiranya mana -mana negeri adalah benar, iaitu, sama ada bilangan bilangan atau jumlah atau jumlahnya adalah pelbagai tiga, maka diterima", "code": "nfa = 1 NEW_LINE flag = 0 NEW_LINE def state1 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == ' a ' ) : NEW_LINE INDENT nfa = 2 NEW_LINE DEDENT elif ( c == ' b ' or c == ' c ' ) : NEW_LINE INDENT nfa = 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT def state2 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == ' a ' ) : NEW_LINE INDENT nfa = 3 NEW_LINE DEDENT elif ( c == ' b ' or c == ' c ' ) : NEW_LINE INDENT nfa = 2 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT def state3 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == ' a ' ) : NEW_LINE INDENT nfa = 1 NEW_LINE DEDENT elif ( c == ' b ' or c == ' c ' ) : NEW_LINE INDENT nfa = 3 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT def state4 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == ' b ' ) : NEW_LINE INDENT nfa = 5 NEW_LINE DEDENT elif ( c == ' a ' or c == ' c ' ) : NEW_LINE INDENT nfa = 4 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT def state5 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == ' b ' ) : NEW_LINE INDENT nfa = 6 NEW_LINE DEDENT elif ( c == ' a ' or c == ' c ' ) : NEW_LINE INDENT nfa = 5 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT def state6 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == ' b ' ) : NEW_LINE INDENT nfa = 4 NEW_LINE DEDENT elif ( c == ' a ' or c == ' c ' ) : NEW_LINE INDENT nfa = 6 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT def state7 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == ' c ' ) : NEW_LINE INDENT nfa = 8 NEW_LINE DEDENT elif ( c == ' b ' or c == ' a ' ) : NEW_LINE INDENT nfa = 7 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT def state8 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == ' c ' ) : NEW_LINE INDENT nfa = 9 NEW_LINE DEDENT elif ( c == ' b ' or c == ' a ' ) : NEW_LINE INDENT nfa = 8 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT def state9 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE if ( c == ' c ' ) : NEW_LINE INDENT nfa = 7 NEW_LINE DEDENT elif ( c == ' b ' or c == ' a ' ) : NEW_LINE INDENT nfa = 9 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT def checkA ( s , x ) : NEW_LINE INDENT global nfa , flag NEW_LINE for i in range ( x ) : NEW_LINE INDENT if ( nfa == 1 ) : NEW_LINE INDENT state1 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 2 ) : NEW_LINE INDENT state2 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 3 ) : NEW_LINE INDENT state3 ( s [ i ] ) NEW_LINE DEDENT DEDENT if ( nfa == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT nfa = 4 NEW_LINE DEDENT DEDENT def checkB ( s , x ) : NEW_LINE INDENT global nfa , flag NEW_LINE for i in range ( x ) : NEW_LINE INDENT if ( nfa == 4 ) : NEW_LINE INDENT state4 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 5 ) : NEW_LINE INDENT state5 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 6 ) : NEW_LINE INDENT state6 ( s [ i ] ) NEW_LINE DEDENT DEDENT if ( nfa == 4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT nfa = 7 NEW_LINE DEDENT DEDENT def checkC ( s , x ) : NEW_LINE INDENT global nfa , flag NEW_LINE for i in range ( x ) : NEW_LINE INDENT if ( nfa == 7 ) : NEW_LINE INDENT state7 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 8 ) : NEW_LINE INDENT state8 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 9 ) : NEW_LINE INDENT state9 ( s [ i ] ) NEW_LINE DEDENT DEDENT if ( nfa == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT s = \" bbbca \" NEW_LINE x = 5 NEW_LINE if ( checkA ( s , x ) or checkB ( s , x ) or checkC ( s , x ) ) : NEW_LINE INDENT print ( \" ACCEPTED \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" NOT ▁ ACCEPTED \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" INPUT ▁ OUT ▁ OF ▁ DICTIONARY . \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Kiraan kedudukan sedemikian rupa sehingga semua elemen sebelum ia lebih besar | Fungsi untuk mengira kedudukan supaya semua elemen sebelum ia lebih besar; Count pada mulanya 1 untuk elemen pertama; Minimum awal; Melintasi array; Jika elemen semasa adalah minimum baru; Mengemas kini minimum; Kiraan kenaikan; Kod pemacu", "code": "def getPositionCount ( a , n ) : NEW_LINE INDENT count = 1 ; NEW_LINE min = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] <= min ) : NEW_LINE INDENT min = a [ i ] ; NEW_LINE count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , 4 , 6 , 1 , 3 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( getPositionCount ( a , n ) ) ; NEW_LINE DEDENT"}
{"text": "Panjang maksimum L sedemikian rupa sehingga jumlah semua subarray panjang L kurang daripada k | Berfungsi untuk mengembalikan jumlah maksimum dalam subarray saiz k; k mesti lebih besar; Kirakan jumlah tetingkap pertama saiz k; Kirakan jumlah tingkap yang tersisa dengan mengeluarkan elemen pertama tetingkap sebelumnya dan menambah elemen terakhir tetingkap semasa. ; Berfungsi untuk mengembalikan panjang jumlah subarray semua subarray panjang ini kurang daripada atau sama dengan k; Carian binari dari L ke R kerana semua elemen array adalah positif supaya jumlah subarray maksimum meningkat secara monotonik; Semak sama ada jumlah subarray lebih besar daripada k atau tidak; Mengemas kini panjang maksimum; Kod pemacu", "code": "def maxSum ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT res = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT res += arr [ i ] ; NEW_LINE DEDENT curr_sum = res ; NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] ; NEW_LINE res = max ( res , curr_sum ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def solve ( arr , n , k ) : NEW_LINE INDENT max_len = 0 ; l = 0 ; r = n ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) // 2 ; NEW_LINE if ( maxSum ( arr , n , m ) > k ) : NEW_LINE INDENT r = m - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 ; NEW_LINE max_len = m ; NEW_LINE DEDENT DEDENT return max_len ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 10 ; NEW_LINE print ( solve ( arr , n , k ) ) ; NEW_LINE DEDENT"}
{"text": "Count of triplets dalam array yang memenuhi syarat -syarat yang diberikan | Pelaksanaan Python3 pendekatan; Semua penyelesaian yang mungkin dalam persamaan 1 / a + 1 / b + 1 / c = 1; Berfungsi untuk mencari tiga kali ganda; Menyimpan indeks unsur -unsur; Semak jika Y boleh bertindak sebagai elemen tengah triplet dengan penyelesaian yang diberikan 1 / a + 1 / b + 1 / c = 1; Carian binari untuk mencari bilangan nilai yang mungkin bagi elemen pertama; Carian binari untuk mencari bilangan nilai yang mungkin bagi elemen ketiga; Sumbangan kepada jawapannya ialah pendaraban nilai yang mungkin untuk elemen pertama dan ketiga; Kod pemacu", "code": "MAX = 100001 NEW_LINE ROW = 10 NEW_LINE COL = 3 NEW_LINE indices = [ 0 ] * MAX NEW_LINE test = [ [ 2 , 3 , 6 ] , [ 2 , 4 , 4 ] , [ 2 , 6 , 3 ] , [ 3 , 2 , 6 ] , [ 3 , 3 , 3 ] , [ 3 , 6 , 2 ] , [ 4 , 2 , 4 ] , [ 4 , 4 , 2 ] , [ 6 , 2 , 3 ] , [ 6 , 3 , 2 ] ] NEW_LINE def find_triplet ( array , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT indices [ i ] = [ ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT indices [ array [ i ] ] . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT y = array [ i ] NEW_LINE for j in range ( ROW ) : NEW_LINE INDENT s = test [ j ] [ 1 ] * y NEW_LINE if s % test [ j ] [ 0 ] != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if s % test [ j ] [ 2 ] != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT x = s // test [ j ] [ 0 ] NEW_LINE z = s // test [ j ] [ 2 ] NEW_LINE if x > MAX or z > MAX : NEW_LINE INDENT continue NEW_LINE DEDENT l = 0 NEW_LINE r = len ( indices [ x ] ) - 1 NEW_LINE first = - 1 NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if indices [ x ] [ m ] < i : NEW_LINE INDENT first = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT l = 0 NEW_LINE r = len ( indices [ z ] ) - 1 NEW_LINE third = - 1 NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if indices [ z ] [ m ] > i : NEW_LINE INDENT third = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if first != - 1 and third != - 1 : NEW_LINE INDENT answer += ( first + 1 ) * ( len ( indices [ z ] ) - third ) NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ 2 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( array ) NEW_LINE print ( find_triplet ( array , n ) ) NEW_LINE DEDENT"}
{"text": "Unsur -unsur bersebelahan yang berbeza dalam array binari | Pelaksanaan Python3 pendekatan di atas; Jika array hanya mempunyai satu elemen, kembali 1; Untuk elemen pertama bandingkan dengan hanya elemen seterusnya; Untuk unsur -unsur yang tersisa berbanding dengan kedua -dua elemen sebelumnya dan seterusnya; Untuk elemen terakhir bandingkan dengan hanya elemen sebelumnya; Kod pemacu", "code": "def distinct ( arr ) : NEW_LINE INDENT count = 0 NEW_LINE if len ( arr ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 0 , len ( arr ) - 1 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT elif ( i > 0 & i < len ( arr ) - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] or arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( arr [ len ( arr ) - 1 ] != arr [ len ( arr ) - 2 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 0 , 0 , 0 , 0 , 0 , 1 , 0 ] NEW_LINE print ( distinct ( arr ) ) NEW_LINE"}
{"text": "Semak jika pelbagai pasangan boleh disusun dengan menukar pasangan dengan elemen pertama yang berbeza | Berfungsi untuk memeriksa sama ada array disusun atau tidak; Melintasi array arr []; Kembali benar; Fungsi untuk memeriksa sama ada mungkin untuk menyusun array w. r. t. elemen pertama; Menyimpan id elemen pertama; Melintasi array arr []; Jika arr [i] [1] tidak sama dengan kumpulan; Jika array disusun; Kod pemacu", "code": "def isSorted ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] > arr [ i - 1 ] [ 0 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPossibleToSort ( arr , N ) : NEW_LINE INDENT group = arr [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] [ 1 ] != group ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT DEDENT if ( isSorted ( arr , N ) ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 340000 , 2 ] , [ 45000 , 1 ] , [ 30000 , 2 ] , [ 50000 , 4 ] ] NEW_LINE N = len ( arr ) NEW_LINE print ( isPossibleToSort ( arr , N ) ) NEW_LINE DEDENT"}
{"text": "Cari skor alpha langkah -langkah yang diberikan (menggunakan BST) | Struktur nod; Berfungsi untuk mengira dan mengembalikan skor alpha perjalanan; Traverse kiri subtree; Kirakan skor alpha langkah semasa; Kemas kini skor Alpha perjalanan; Melintasi subtree kanan; Kembali; Berfungsi untuk membina BST dari array array yang disusun []; Masukkan akar; Membina subtree kiri; Membina subtree kanan; Pulangan akar; Kod pemacu; Susun array; Bina BST dari array yang disusun", "code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE total_sum = 0 NEW_LINE mod = 1000000007 NEW_LINE def getAlphaScore ( node ) : NEW_LINE INDENT global sum NEW_LINE global total_sum NEW_LINE if node . left != None : NEW_LINE INDENT getAlphaScore ( node . left ) NEW_LINE DEDENT sum = ( sum + node . data ) % mod NEW_LINE total_sum = ( total_sum + sum ) % mod NEW_LINE if node . right != None : NEW_LINE INDENT getAlphaScore ( node . right ) NEW_LINE DEDENT return total_sum NEW_LINE DEDENT def constructBST ( arr , start , end , root ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return None NEW_LINE DEDENT mid = ( start + end ) // 2 NEW_LINE if root == None : NEW_LINE INDENT root = Node ( arr [ mid ] ) NEW_LINE DEDENT root . left = constructBST ( arr , start , mid - 1 , root . left ) NEW_LINE root . right = constructBST ( arr , mid + 1 , end , root . right ) NEW_LINE return root NEW_LINE DEDENT arr = [ 10 , 11 , 12 ] NEW_LINE length = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE root = None NEW_LINE root = constructBST ( arr , 0 , length - 1 , root ) NEW_LINE print ( getAlphaScore ( root ) ) NEW_LINE"}
{"text": "Menyusun elemen array mengikut kekerapan dalam penurunan urutan | Fungsi yang mengembalikan indeks sehingga semua elemen array dikemas kini. ; Permulaan maxe = - 1; Cari elemen maksimum ARR []; Membuat frekuensi array freq []; Mengemas kini array frekuensi mengikut kejadian elemen dalam arr []; Permulaan CNT hingga 0; Melintasi freq []; Jika freq dari elemen lebih besar daripada 0 mengemas kini nilai ARR [] pada indeks CNT & kenaikan CNT; Kembali CNT; Fungsi yang mencetak array arr [] elemen dalam urutan yang disusun; Melintasi arr [] sehingga indeks cnt; Cari kekerapan elemen; Cari nilai di Indeks I; Melintasi kekerapan untuk mencetak nilai pada indeks I; Kod pemacu; Saiz array arr []; Fungsi panggilan untuk mendapatkan CNT; Susun arr [] dalam penurunan urutan; Fungsi yang mencetak elemen dalam penurunan urutan", "code": "def sortByFreq ( arr , n ) : NEW_LINE INDENT maxE = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxE = max ( maxE , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 ] * ( maxE + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE for i in range ( maxE + 1 ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT value = 100000 - i ; NEW_LINE arr [ cnt ] = 100000 * freq [ i ] + value ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT def printSortedArray ( arr , cnt ) : NEW_LINE INDENT for i in range ( cnt ) : NEW_LINE INDENT frequency = arr [ i ] / 100000 ; NEW_LINE value = 100000 - ( arr [ i ] % 100000 ) ; NEW_LINE for j in range ( int ( frequency ) ) : NEW_LINE INDENT print ( value , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE cnt = sortByFreq ( arr , n ) ; NEW_LINE arr . sort ( reverse = True ) NEW_LINE printSortedArray ( arr , cnt ) ; NEW_LINE DEDENT"}
{"text": "Semak jika N Rectangles kawasan yang sama boleh dibentuk dari (4 * n) integer | Berfungsi untuk memeriksa sama ada kita boleh membuat segi empat tepat kawasan yang sama; Susun array; Cari kawasan mana -mana segi empat tepat; Semak sama ada kita mempunyai dua sisi yang sama untuk setiap segi empat tepat dan kawasan setiap segi empat tepat yang terbentuk adalah sama; Kemas kini jawapan kepada palsu jika keadaan gagal; Jika boleh; Kod pemacu", "code": "def checkRectangles ( arr , n ) : NEW_LINE INDENT ans = True NEW_LINE arr . sort ( ) NEW_LINE area = arr [ 0 ] * arr [ 4 * n - 1 ] NEW_LINE for i in range ( 0 , 2 * n , 2 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] or arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] or arr [ i ] * arr [ 4 * n - i - 1 ] != area ) : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 ] NEW_LINE n = 2 NEW_LINE if ( checkRectangles ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Count of Elements yang tidak berada di kedudukan yang betul | Berfungsi untuk mengembalikan kiraan elemen yang tidak berada di kedudukan yang betul apabila disusun; Untuk menyimpan salinan array asal; Salin unsur -unsur array yang diberikan kepada array baru; Untuk menyimpan kiraan yang diperlukan; Susun array asal; Jika elemen semasa tidak berada di kedudukan yang betul; Kod pemacu", "code": "def cntElements ( arr , n ) : NEW_LINE INDENT copy_arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT copy_arr [ i ] = arr [ i ] NEW_LINE DEDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != copy_arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cntElements ( arr , n ) ) NEW_LINE"}
{"text": "Cari k yang diperintahkan pasangan dalam array dengan perbezaan minimum d | Fungsi untuk mencari pasangan yang diperlukan; Harus ada elemen 2 * k; Untuk menyimpan pasangan; Susun array yang diberikan; Untuk setiap pasangan yang mungkin; Jika pasangan semasa adalah sah; Masukkannya ke dalam vektor pasangan; Jika pasangan k tidak mungkin; Cetak pasangan; Kod pemacu", "code": "def findPairs ( arr , n , k , d ) : NEW_LINE INDENT if ( n < 2 * k ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT pairs = [ ] NEW_LINE arr = sorted ( arr ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ n - k + i ] - arr [ i ] >= d ) : NEW_LINE INDENT pairs . append ( [ arr [ i ] , arr [ n - k + i ] ] ) NEW_LINE DEDENT DEDENT if ( len ( pairs ) < k ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT for v in pairs : NEW_LINE INDENT print ( \" ( \" , v [ 0 ] , \" , ▁ \" , v [ 1 ] , \" ) \" ) NEW_LINE DEDENT DEDENT arr = [ 4 , 6 , 10 , 23 , 14 , 7 , 2 , 20 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE d = 3 NEW_LINE findPairs ( arr , n , k , d ) NEW_LINE"}
{"text": "Kira pasangan dengan jumlah yang diberikan | Tetapkan 2 | Berfungsi untuk mengembalikan kiraan pasangan dari ARR dengan jumlah yang diberikan; Untuk menyimpan kiraan pasangan; Susun array yang diberikan; Ambil dua petunjuk; Jika jumlahnya lebih besar; Jika jumlahnya lebih rendah; Jika jumlahnya sama; Cari kekerapan arr [i]; Cari kekerapan Arr [J]; Jika arr [i] dan arr [j] sama maka keluarkan nombor tambahan yang dikira; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] NEW_LINE xx = i NEW_LINE while ( i < j and arr [ i ] == x ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = arr [ j ] NEW_LINE yy = j NEW_LINE while ( j >= i and arr [ j ] == y ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 5 , 7 , 5 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( pairs_count ( arr , n , sum ) ) NEW_LINE"}
{"text": "Semak jika rentetan mengandungi huruf berturut -turut dan setiap huruf berlaku tepat sekali | Program Python3 untuk melaksanakan pendekatan di atas; Untuk semua watak rentetan; Cari nilai ASCII watak; Semak sama ada watak yang sah, jika tidak maka kembali palsu; Hitung jumlah semua nilai ASCII; Cari nilai ASCII minimum dari rentetan; Cari nilai ASCII maksimum dari rentetan; Untuk mendapatkan elemen sebelumnya nilai ASCII minimum; Ambil jumlah yang diharapkan dari persamaan di atas; Semak sama ada jumlah yang dijangkakan adalah sama dengan jumlah yang dikira atau tidak; Kod pemacu; Contoh 1 st; Contoh 2 nd", "code": "import sys NEW_LINE def check ( str ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE max = - sys . maxsize - 1 NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ascii = str [ i ] NEW_LINE if ( ord ( ascii ) < 96 or ord ( ascii ) > 122 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ord ( ascii ) NEW_LINE if ( min > ord ( ascii ) ) : NEW_LINE INDENT min = ord ( ascii ) NEW_LINE DEDENT if ( max < ord ( ascii ) ) : NEW_LINE INDENT max = ord ( ascii ) NEW_LINE DEDENT DEDENT min -= 1 NEW_LINE eSum = ( ( ( max * ( max + 1 ) ) // 2 ) - ( ( min * ( min + 1 ) ) // 2 ) ) NEW_LINE return sum == eSum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" dcef \" NEW_LINE if ( check ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT str1 = \" xyza \" NEW_LINE if ( check ( str1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "K | Berfungsi untuk mencari jumlah minimum semua subarray; Masukkan semua elemen dalam satu set; Cari elemen maksimum dan minimum; Melintasi unsur minimum hingga maksimum; Semak sama ada \"Saya\" hilang; Semak sama ada kth hilang; Jika tiada elemen kth hilang; Kod pemacu", "code": "def findKth ( arr , n , k ) : NEW_LINE INDENT missing = dict ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT missing [ arr [ i ] ] = 1 NEW_LINE DEDENT maxm = max ( arr ) NEW_LINE minm = min ( arr ) NEW_LINE for i in range ( minm + 1 , maxm ) : NEW_LINE INDENT if ( i not in missing . keys ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 10 , 9 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( findKth ( arr , n , k ) ) NEW_LINE"}
{"text": "Susun senarai yang dipautkan yang mengandungi nilai dari 1 hingga n | Program Python3 untuk menyusun senarai berkaitan yang mengandungi nilai dari 1 hingga n; Nod senarai yang dipautkan; Berfungsi untuk menyusun senarai yang dipautkan; Berfungsi untuk menambah nod pada permulaan senarai yang dipautkan; memperuntukkan nod; masukkan data; Pautan senarai lama dari nod baru; gerakkan kepala ke PO ke nod baru; Fungsi ini PRS kandungan senarai yang dipautkan bermula dari nod yang diberikan; Kod pemacu; Senarai berkaitan yang dibina ialah: 3.5. 4.6 .1. 2", "code": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def sortList ( head ) : NEW_LINE INDENT startVal = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT head . data = startVal NEW_LINE startVal = startVal + 1 NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def prList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 1 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 3 ) NEW_LINE sortList ( head ) NEW_LINE prList ( head ) NEW_LINE DEDENT"}
{"text": "Semak jika senarai yang dipautkan disusun (berulang dan rekursif) | Nod senarai yang dipautkan; Fungsi untuk menyemak senarai yang dipautkan disusun mengikut urutan menurun atau tidak; Kes asas; Semak dua nod pertama dan semak semula rekursif. ; Kod pemacu", "code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def isSortedDesc ( head ) : NEW_LINE INDENT if ( head == None or head . next == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT return ( head . data > head . next . data and isSortedDesc ( head . next ) ) NEW_LINE DEDENT def newNode ( data ) : NEW_LINE INDENT temp = Node ( data ) NEW_LINE return temp NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT head = newNode ( 7 ) NEW_LINE head . next = newNode ( 5 ) NEW_LINE head . next . next = newNode ( 4 ) NEW_LINE head . next . next . next = newNode ( 3 ) NEW_LINE if isSortedDesc ( head ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Susun semula array untuk meminimumkan jumlah produk elemen pasangan berturut -turut | Program Python 3 untuk menyusun array sedemikian rupa sehingga jumlah produk elemen alternatif adalah minimum. ; Buat Evenarr [] dan Oddarr []; Susun pelbagai utama dalam urutan menaik; Letakkan unsur -unsur di Oddarr [] dan evenarr [] seperti nilai yang dikehendaki. ; Susun everarr [] dalam urutan menurun; menggabungkan kedua -dua sub - array dan mengira jumlah minimum produk elemen alternatif; Kod pemacu", "code": "def minSum ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( reverse = True ) NEW_LINE i = 0 NEW_LINE sum = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE sum += evenArr [ j ] * oddArr [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ required ▁ sum ▁ = \" , minSum ( arr , n ) ) NEW_LINE print ( \" Sorted ▁ array ▁ in ▁ required ▁ format ▁ : ▁ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Masa minimum diperlukan untuk mencetak rentetan yang diberikan dari bekas bulat berdasarkan syarat yang diberikan | Berfungsi untuk mengira masa minimum untuk mencetak semua aksara dalam rentetan; Elemen semasa di mana penunjuk sedang menunjuk; Cari indeks elemen itu; Kirakan perbezaan mutlak antara indeks penunjuk dan indeks aksara sebagai jarak mengikut arah jam; Kurangkan masa mengikut arah jam dari 26 untuk mendapatkan masa anti -jam; Tambah minimum kedua -dua kali untuk jawapannya; Tambah satu unit masa untuk mencetak watak; Cetak jawapan terakhir; Kod pemacu; Diberikan perkataan rentetan; Panggilan fungsi", "code": "def minTime ( word ) : NEW_LINE INDENT ans = 0 NEW_LINE curr = 0 NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT k = ord ( word [ i ] ) - 97 NEW_LINE a = abs ( curr - k ) NEW_LINE b = 26 - abs ( curr - k ) NEW_LINE ans += min ( a , b ) NEW_LINE ans += 1 NEW_LINE curr = ord ( word [ i ] ) - 97 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" zjpc \" NEW_LINE minTime ( str ) NEW_LINE DEDENT"}
{"text": "Pengurangan minimum atau pembahagian oleh pembahagi yang betul yang diperlukan untuk mengurangkan N hingga 1 | Fungsi untuk mencari bilangan langkah minimum yang diperlukan untuk mengurangkan n hingga 1; Menyimpan bilangan langkah yang diperlukan; Jika nilai n sama dengan 2 atau n adalah ganjil; Penurunan n oleh 1; Kenaikan CNT oleh 1; Jika n juga; Kemas kini n; Kenaikan CNT oleh 1; Mengembalikan bilangan langkah yang diperoleh; Kod pemacu", "code": "def reduceToOne ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( N != 1 ) : NEW_LINE INDENT if ( N == 2 or ( N % 2 == 1 ) ) : NEW_LINE INDENT N = N - 1 NEW_LINE cnt += 1 NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT N = N / ( N / 2 ) NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 35 NEW_LINE print ( reduceToOne ( N ) ) NEW_LINE DEDENT"}
{"text": "Bilangan maksimum berlian yang boleh diperolehi dalam minit k | Berfungsi untuk mencari bilangan maksimum berlian yang boleh diperolehi dalam beberapa minit; Menyimpan semua elemen array; Tolak semua elemen ke barisan keutamaan; Menyimpan hasil yang diperlukan; Gelung manakala barisan tidak kosong dan k positif; Simpan elemen teratas dari PQ; Pop dari PQ; Tambahkannya kepada jawapannya; Bahagikannya dengan 2 dan tolaknya kembali ke PQ; Cetak jawapannya; Kod pemacu", "code": "def maxDiamonds ( A , N , K ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT pq . append ( A [ i ] ) NEW_LINE DEDENT pq . sort ( ) NEW_LINE ans = 0 NEW_LINE while ( len ( pq ) > 0 and K > 0 ) : NEW_LINE INDENT pq . sort ( ) NEW_LINE top = pq [ len ( pq ) - 1 ] NEW_LINE pq = pq [ 0 : len ( pq ) - 1 ] NEW_LINE ans += top NEW_LINE top = top // 2 ; NEW_LINE pq . append ( top ) NEW_LINE K -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 2 , 1 , 7 , 4 , 2 ] NEW_LINE K = 3 NEW_LINE N = len ( A ) NEW_LINE maxDiamonds ( A , N , K ) NEW_LINE DEDENT"}
{"text": "Kurangkan kos kenaikan atau pengurangan seperti unsur -unsur yang diindeks yang sama menjadi pelbagai antara satu sama lain | Fungsi untuk mencari kos minimum untuk membuat [i] berbilang b [i] atau naib - sebaliknya untuk setiap elemen array; Menyimpan kos minimum; Melintasi array; Kes 1: Kemas kini [i]; Kes 2: Kemas kini B [i]; Tambah minimum dua kes di atas; Mengembalikan kos yang dihasilkan; Kod pemacu", "code": "def MinimumCost ( A , B , N ) : NEW_LINE INDENT totalCost = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT mod_A = B [ i ] % A [ i ] NEW_LINE totalCost_A = min ( mod_A , A [ i ] - mod_A ) NEW_LINE mod_B = A [ i ] % B [ i ] NEW_LINE totalCost_B = min ( mod_B , B [ i ] - mod_B ) NEW_LINE totalCost += min ( totalCost_A , totalCost_B ) NEW_LINE DEDENT return totalCost NEW_LINE DEDENT A = [ 3 , 6 , 3 ] NEW_LINE B = [ 4 , 8 , 13 ] NEW_LINE N = len ( A ) NEW_LINE print ( MinimumCost ( A , B , N ) ) NEW_LINE"}
{"text": "Nombor terbesar dibahagi dengan 50 yang boleh dibentuk dari satu set digit N yang terdiri daripada 0 s dan 7 s sahaja | Cetak nombor terbesar yang boleh dibahagikan dengan 50; Mengira nombor 0 s dan 7 s; Jika kiraan 7 boleh dibahagikan dengan 50; Jika kiraan 7 kurang daripada 5; Jika kiraan 7 tidak boleh dibahagikan dengan 50; Count kumpulan 5 di mana kiraan 7 s boleh dikumpulkan; Kod pemacu; Diberikan array; Saiz array", "code": "def printLargestDivisible ( arr , N ) : NEW_LINE INDENT count0 = 0 ; count7 = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT count0 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count7 += 1 ; NEW_LINE DEDENT DEDENT if ( count7 % 50 == 0 ) : NEW_LINE INDENT while ( count7 ) : NEW_LINE INDENT count7 -= 1 ; NEW_LINE print ( 7 , end = \" \" ) ; NEW_LINE DEDENT while ( count0 ) : NEW_LINE INDENT count0 -= 1 ; NEW_LINE print ( count0 , end = \" \" ) ; NEW_LINE DEDENT DEDENT elif ( count7 < 5 ) : NEW_LINE INDENT if ( count0 == 0 ) : NEW_LINE INDENT print ( \" No \" , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" \" ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT count7 = count7 - count7 % 5 ; NEW_LINE while ( count7 ) : NEW_LINE INDENT count7 -= 1 ; NEW_LINE print ( 7 , end = \" \" ) ; NEW_LINE DEDENT while ( count0 ) : NEW_LINE INDENT count0 -= 1 ; NEW_LINE print ( 0 , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 0 , 7 , 0 , 7 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 7 , 7 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE printLargestDivisible ( arr , N ) ; NEW_LINE DEDENT"}
{"text": "Susun semula Arahan untuk memaksimumkan jumlah GCD unsur -unsur array dengan indeks masing -masing | Berfungsi untuk mencari jumlah maksimum GCD (arr [i], i) dengan menyusun semula array; Susun array dalam urutan menaik; Kedai maksimum jumlah GCD (arr [i], i) dengan menyusun semula elemen array; Menjana semua permutasi yang mungkin dari array; Kedai jumlah GCD (arr [i], i); Melintasi array; Kemas kini Jumlah; Kemas kini res; Kod pemacu", "code": "def findMaxValByRearrArr ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE while ( True ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT Sum += __gcd ( i + 1 , arr [ i ] ) NEW_LINE DEDENT res = max ( res , Sum ) NEW_LINE if ( not next_permutation ( arr ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def next_permutation ( p ) : NEW_LINE INDENT for a in range ( len ( p ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( p [ a ] < p [ a + 1 ] ) : NEW_LINE INDENT b = len ( p ) - 1 NEW_LINE while True : NEW_LINE INDENT if ( p [ b ] > p [ a ] ) : NEW_LINE INDENT t = p [ a ] NEW_LINE p [ a ] = p [ b ] NEW_LINE p [ b ] = t NEW_LINE a += 1 NEW_LINE b = len ( p ) - 1 NEW_LINE while a < b : NEW_LINE INDENT t = p [ a ] NEW_LINE p [ a ] = p [ b ] NEW_LINE p [ b ] = t NEW_LINE a += 1 NEW_LINE b -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT b -= 1 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 3 , 2 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findMaxValByRearrArr ( arr , N ) ) NEW_LINE"}
{"text": "Penyingkiran minimum diperlukan untuk membuat kekerapan setiap elemen array sama dengan nilainya | Fungsi untuk mencari kiraan minimum elemen yang diperlukan untuk dikeluarkan sedemikian rupa sehingga kekerapan arr [i] sama dengan arr [i]; Kedai kekerapan setiap elemen array; Melintasi array; Kemas kini kekerapan ARR [i]; Kedai kiraan minimum penyingkiran; Melintasi peta; Menyimpan nilai utama peta; Jika kekerapan saya kurang daripada saya; Mengemas kini cntminrem; Jika kekerapan saya lebih besar daripada saya; Mengemas kini cntminrem; Kod pemacu", "code": "def min_elements ( arr , N ) : NEW_LINE INDENT mp = { } ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT cntMinRem = 0 ; NEW_LINE for it in mp : NEW_LINE INDENT i = it ; NEW_LINE if ( mp [ i ] < i ) : NEW_LINE INDENT cntMinRem += mp [ i ] ; NEW_LINE DEDENT elif ( mp [ i ] > i ) : NEW_LINE INDENT cntMinRem += ( mp [ i ] - i ) ; NEW_LINE DEDENT DEDENT return cntMinRem ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 1 , 4 , 2 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE print ( min_elements ( arr , N ) ) ; NEW_LINE DEDENT"}
{"text": "Peningkatan minimum untuk membuat semua elemen array sama dengan jumlah yang sama dengan array yang diberikan selepas tepat satu penyingkiran | Fungsi untuk memeriksa sama ada pelbagai elemen yang sama dengan jumlah yang sama dengan array yang diberikan boleh diperoleh atau tidak; Kes asas; Kedai jumlah elemen array; Menyimpan elemen array kedua terbesar; Menyimpan elemen array terbesar; Melintasi array; Kemas kini SecMax; Kemas kini Max; Kemas kini SecMax; Kemas kini totalsum; Jika totalsum kurang daripada secmax * (n - 1)); Jika totalsum tidak boleh dibahagikan dengan (n - 1); Kod pemacu", "code": "def CheckAllarrayEqual ( arr , N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT totalSum = arr [ 0 ] NEW_LINE secMax = - 10 ** 19 NEW_LINE Max = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] >= Max ) : NEW_LINE INDENT secMax = Max NEW_LINE Max = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secMax ) : NEW_LINE INDENT secMax = arr [ i ] NEW_LINE DEDENT totalSum += arr [ i ] NEW_LINE DEDENT if ( ( secMax * ( N - 1 ) ) > totalSum ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( totalSum % ( N - 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 6 , 2 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE if ( CheckAllarrayEqual ( arr , N ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Kira cara untuk membuat bitwise xor ganjil dan bahkan elemen diindeks sama dengan mengeluarkan elemen array | Berfungsi untuk mengira cara untuk membuat bitwise xor aneh dan bahkan elemen diindeks sama dengan mengeluarkan elemen array; Kedai xor unsur -unsur ganjil dan bahkan diindeks dari akhir; Kedai xor unsur -unsur ganjil dan bahkan diindeks dari awal; Menyimpan kiraan yang diperlukan; Melintasi array secara terbalik; Sekiranya saya ganjil; Sekiranya saya juga; Melintasi array; Sekiranya saya ganjil; Sekiranya saya juga; Mengeluarkan arr [i], kedai post_even xor unsur -unsur yang diindeks ganjil; Mengeluarkan arr [i], post_odd menyimpan xor walaupun elemen yang diindeks; Semak sama ada mereka sama; Jika saya ganjil, xor dengan curr_odd; Jika saya juga, xor dengan curr_even; Akhirnya cetak res; Kod pemacu; Diberikan array; Saiz yang diberikan; Panggilan fungsi", "code": "def Remove_one_element ( arr , n ) : NEW_LINE INDENT post_odd = 0 NEW_LINE post_even = 0 NEW_LINE curr_odd = 0 NEW_LINE curr_even = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT post_odd ^= arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT post_even ^= arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT post_odd ^= arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT post_even ^= arr [ i ] NEW_LINE DEDENT X = curr_odd ^ post_even NEW_LINE Y = curr_even ^ post_odd NEW_LINE if ( X == Y ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( i % 2 ) : NEW_LINE INDENT curr_odd ^= arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT curr_even ^= arr [ i ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE Remove_one_element ( arr , N ) NEW_LINE DEDENT"}
{"text": "Kira cara untuk membuat jumlah elemen ganjil dan bahkan diindeks sama dengan mengeluarkan elemen array | Fungsi untuk mengira indeks array yang penyingkirannya menjadikan jumlah unsur -unsur yang ganjil dan juga diindeks sama; Jika saiz array adalah 1; Jika saiz array adalah 2; Kedai -kedai jumlah unsur -unsur yang diindeks dari array yang diberikan; Kedai Jumlah unsur -unsur yang diindeks dari array yang diberikan; Melintasi array; Jika saya adalah nombor yang sama; Kemas kini Sumeven; Jika saya adalah nombor ganjil; Kemas kini Sumodd; Kedai Jumlah unsur -unsur array yang diindeks sehingga indeks i - th; Kedai Jumlah unsur array yang diindeks sehingga indeks i - th; Kedai -kedai mengira indeks yang penyingkirannya membuat jumlah unsur -unsur yang ganjil dan juga diindeks sama; Kedai -kedai jumlah unsur -unsur yang diindeks selepas mengeluarkan elemen i - th; Kedai Jumlah unsur -unsur yang diindeks selepas mengeluarkan elemen i - th; Melintasi array; Jika saya adalah nombor ganjil; Kemas kini Currodd; Kemas kini Newevensum; Kemas kini Newoddsum; Jika saya adalah nombor yang sama; Kemas kini Curreven; Kemas kini Newoddsum; Kemas kini Newevensum; Jika Newevensum sama dengan Newoddsum; Meningkatkan kiraan; Jika jumlah unsur -unsur yang diindeks dan ganjil - diindeks adalah sama dengan mengeluarkan elemen pertama; Meningkatkan kiraan; Jika panjang array adalah nombor ganjil; Jika jumlah unsur -unsur yang diindeks dan ganjil - diindeks adalah sama dengan mengeluarkan elemen terakhir; Meningkatkan kiraan; Jika panjang array adalah nombor yang sama; Jika jumlah unsur -unsur yang diindeks dan ganjil - diindeks adalah sama dengan mengeluarkan elemen terakhir; Meningkatkan kiraan; Kod pemacu", "code": "def cntIndexesToMakeBalance ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sumEven = 0 NEW_LINE sumOdd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT sumEven += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sumOdd += arr [ i ] NEW_LINE DEDENT DEDENT currOdd = 0 NEW_LINE currEven = arr [ 0 ] NEW_LINE res = 0 NEW_LINE newEvenSum = 0 NEW_LINE newOddSum = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT currOdd += arr [ i ] NEW_LINE newEvenSum = ( currEven + sumOdd - currOdd ) NEW_LINE newOddSum = ( currOdd + sumEven - currEven - arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT currEven += arr [ i ] NEW_LINE newOddSum = ( currOdd + sumEven - currEven ) NEW_LINE newEvenSum = ( currEven + sumOdd - currOdd - arr [ i ] ) NEW_LINE DEDENT if ( newEvenSum == newOddSum ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if ( sumOdd == sumEven - arr [ 0 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT if ( sumOdd == sumEven - arr [ n - 1 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( sumEven == sumOdd - arr [ n - 1 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cntIndexesToMakeBalance ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Cari dua nombor dari jumlah dan xor mereka | Tetapkan 2 | Fungsi untuk mencari nilai a dan b yang jumlahnya adalah x dan xor adalah y; Memulakan dua nombor; Kes 1: x <y; Kes 2: x - y adalah ganjil; Kes 3: Jika kedua -dua jumlah dan XOR adalah sama; Kes 4: jika di atas kes gagal; Kemas kini nilai a; Semak jika nilai A & Y ialah 0; Jika benar, kemas kini b; Sebaliknya berikan - 1 hingga a, - 1 hingga b; Nombor nombor a dan b; Kod pemacu; Diberikan jumlah dan xor 2 nombor; Panggilan fungsi", "code": "def findNums ( X , Y ) : NEW_LINE INDENT A = 0 ; NEW_LINE B = 0 ; NEW_LINE if ( X < Y ) : NEW_LINE INDENT A = - 1 ; NEW_LINE B = - 1 ; NEW_LINE DEDENT elif ( ( ( abs ( X - Y ) ) & 1 ) != 0 ) : NEW_LINE INDENT A = - 1 ; NEW_LINE B = - 1 ; NEW_LINE DEDENT elif ( X == Y ) : NEW_LINE INDENT A = 0 ; NEW_LINE B = Y ; NEW_LINE DEDENT else : NEW_LINE INDENT A = ( X - Y ) // 2 ; NEW_LINE if ( ( A & Y ) == 0 ) : NEW_LINE INDENT B = ( A + Y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT A = - 1 ; NEW_LINE B = - 1 ; NEW_LINE DEDENT DEDENT print A ; NEW_LINE print B ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 17 ; NEW_LINE Y = 13 ; NEW_LINE findNums ( X , Y ) ; NEW_LINE DEDENT"}
{"text": "Pertanyaan untuk memeriksa sama ada kiraan peningkatan dan penurunan subarray adalah sama dalam julat yang diberikan | Fungsi untuk memeriksa sama ada julat yang diberikan mempunyai bilangan yang sama dan penurunan subarrays; Melintasi setiap pertanyaan; Untuk pengindeksan berasaskan 0; Keadaan untuk kiraan yang sama meningkatkan & menurunkan subarray; Kod pemacu", "code": "def checkCount ( A , Q , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT L = Q [ i ] [ 0 ] NEW_LINE R = Q [ i ] [ 1 ] NEW_LINE L -= 1 NEW_LINE R -= 1 NEW_LINE if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 11 , 13 , 12 , 14 ] NEW_LINE Q = [ [ 1 , 4 ] , [ 2 , 4 ] ] NEW_LINE q = len ( Q ) NEW_LINE checkCount ( arr , Q , q ) NEW_LINE DEDENT"}
{"text": "Purata array yang dihasilkan oleh produk semua pasang array yang diberikan | Berfungsi untuk mencari min pasangan array arr; Menyimpan produk pasangan; Menjana semua pasangan yang tidak teratur; Menyimpan produk pasangan; Saiz PairArray; Simpan Jumlah PairArray; Menyimpan min PairArray; Cari min PairArray; Mengembalikan maksud yang dihasilkan; Kod pemacu; Diberikan array arr; Panggilan fungsi", "code": "def pairProductMean ( arr , N ) : NEW_LINE INDENT pairArray = [ ] ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT pairProduct = arr [ i ] * arr [ j ] ; NEW_LINE pairArray . append ( pairProduct ) ; NEW_LINE DEDENT DEDENT length = len ( pairArray ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT sum += pairArray [ i ] ; NEW_LINE DEDENT mean = 0 ; NEW_LINE if ( length != 0 ) : NEW_LINE INDENT mean = sum / length ; NEW_LINE DEDENT else : NEW_LINE INDENT mean = 0 ; NEW_LINE DEDENT return mean ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE print ( \" { 0 : . 2f } \" . format ( pairProductMean ( arr , N ) ) ) NEW_LINE DEDENT"}
{"text": "Bilangan terkecil melebihi n yang bit kth ditetapkan | Berfungsi untuk mencari nombor yang lebih besar daripada n yang bit kthnya ditetapkan; Berulang dari n + 1; Semak sama ada bit kth ditetapkan atau tidak; Kenaikan m untuk nombor seterusnya; Mengembalikan nilai minimum; Kod pemacu; Diberikan n dan k; Panggilan fungsi", "code": "def find_next ( n , k ) : NEW_LINE INDENT M = n + 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( ( M & ( 1 << k ) ) > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT M += 1 ; NEW_LINE DEDENT return M ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 ; K = 2 ; NEW_LINE print ( find_next ( N , K ) ) ; NEW_LINE DEDENT"}
{"text": "Bilangan terkecil melebihi n yang bit kth ditetapkan | Berfungsi untuk mencari nombor yang lebih besar daripada n yang bit kthnya ditetapkan; Menyimpan nombor yang dihasilkan; Jika bit kth tidak ditetapkan; Cur akan menjadi jumlah semua kuasa 2 <k; Jika bit semasa ditetapkan; Tambah kuasa kth 2 hingga n dan tolak semua kuasa 2 kurang daripada k yang ditetapkan; Jika bit kth ditetapkan; Kedudukan bit pertama yang pertama; Jumlah bit yang ditetapkan; Tambah kuasa kth 2 hingga n dan tolak semua kuasa 2 kurang daripada k yang ditetapkan; Jika kth bit menjadi tidak tersendiri maka tetapkannya lagi; Mengembalikan nombor yang dihasilkan; Kod pemacu; Cetak Ans", "code": "def find_next ( n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( ( n & ( 1 << k ) ) == 0 ) : NEW_LINE INDENT cur = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( n & ( 1 << i ) ) : NEW_LINE INDENT cur += 1 << i NEW_LINE DEDENT DEDENT ans = n - cur + ( 1 << k ) NEW_LINE DEDENT else : NEW_LINE INDENT first_unset_bit , cur = - 1 , 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if ( ( n & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT first_unset_bit = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT cur += ( 1 << i ) NEW_LINE DEDENT DEDENT ans = n - cur + ( 1 << first_unset_bit ) NEW_LINE if ( ( ans & ( 1 << k ) ) == 0 ) : NEW_LINE INDENT ans += ( 1 << k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N , K = 15 , 2 NEW_LINE print ( find_next ( N , K ) ) NEW_LINE"}
{"text": "Lexicographically terbesar mungkin rentetan selepas penyingkiran Kara K | Program Python3 untuk melaksanakan pendekatan di atas; Rentetan hasil akhir; Jika char semasa melebihi watak di bahagian atas timbunan; Keluarkan dari hujung rentetan; Kurangkan k untuk penyingkiran; Masukkan watak semasa; Lakukan penghapusan k yang tersisa dari akhir rentetan; Kembalikan rentetan; Kod pemacu", "code": "def largestString ( num , k ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT while ( len ( ans ) and ans [ - 1 ] < num [ i ] and k > 0 ) : NEW_LINE INDENT ans . pop ( ) NEW_LINE k -= 1 NEW_LINE DEDENT ans . append ( num [ i ] ) NEW_LINE DEDENT while ( len ( ans ) and k ) : NEW_LINE INDENT k -= 1 NEW_LINE ans . pop ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT str = \" zyxedcba \" NEW_LINE k = 1 NEW_LINE print ( * largestString ( str , k ) , sep = \" \" ) NEW_LINE"}
{"text": "Panjang maksimum subarray yang terdiri daripada jenis elemen yang sama pada kedua -dua bahagian sub | Fungsi yang mendapati panjang maksimum sub -sub -yang mengandungi elemen yang sama pada kedua -dua bahagian sub -array; Untuk menyimpan kejadian berterusan unsur; Untuk menyimpan kejadian ke hadapan yang berterusan; Untuk menyimpan kejadian mundur yang berterusan; Untuk menyimpan panjang maksimum; Cari panjang maksimum; Cetak hasilnya; Diberikan array; Saiz array; Panggilan fungsi", "code": "def maxLengthSubArray ( A , N ) : NEW_LINE INDENT forward = [ 0 ] * N NEW_LINE backward = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i == 0 or A [ i ] != A [ i - 1 ] : NEW_LINE INDENT forward [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT forward [ i ] = forward [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if i == N - 1 or A [ i ] != A [ i + 1 ] : NEW_LINE INDENT backward [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT backward [ i ] = backward [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i ] != A [ i + 1 ] ) : NEW_LINE INDENT ans = max ( ans , min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 4 , 4 , 6 , 6 , 6 , 9 ] NEW_LINE N = len ( arr ) NEW_LINE maxLengthSubArray ( arr , N ) NEW_LINE"}
{"text": "Nombor digit terkecil divisible oleh semua angka utama yang mungkin | Pelaksanaan Python3 pendekatan di atas; Fungsi untuk mencari bilangan minimum n digit yang boleh dibahagikan oleh semua digit utama. ; Kod pemacu", "code": "from math import * NEW_LINE def minNum ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 210 * ( 10 ** ( n - 1 ) // 210 + 1 ) ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE minNum ( n ) NEW_LINE"}
{"text": "Nombor terkecil lebih besar daripada y dengan jumlah digit yang sama dengan x | Berfungsi untuk mengembalikan rentetan minimum panjang d yang mempunyai jumlah digit s; Mengembalikan rentetan panjang d; Ramuan meletakkan 9 pada akhirnya; Masukkan jumlah yang tersisa; Berfungsi untuk mencari nombor terkecil yang lebih besar daripada y yang jumlah digitnya adalah x; Tukar nombor y ke rentetan; Mengekalkan jumlah awalan digit; Melangkah ke atas Y dari belakang di mana k adalah panjang akhiran semasa; Kedai digit semasa; Meningkatkan digit semasa; Jumlah awalan semasa; Kembali Jawapan Jika baki jumlah boleh diperolehi dalam akhiran; Cari akhiran panjang k mempunyai jumlah digit x - r; Tambah watak semasa; Mengembalikan hasilnya; Kod pemacu; Diberi nombor dan jumlah; Panggilan fungsi", "code": "def helper ( d , s ) : NEW_LINE INDENT ans = [ '0' ] * d NEW_LINE for i in range ( d - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s >= 9 ) : NEW_LINE INDENT ans [ i ] = '9' NEW_LINE s -= 9 NEW_LINE DEDENT else : NEW_LINE INDENT c = chr ( s + ord ( '0' ) ) NEW_LINE ans [ i ] = c ; NEW_LINE s = 0 ; NEW_LINE DEDENT DEDENT return ' ' . join ( ans ) ; NEW_LINE DEDENT def findMin ( x , Y ) : NEW_LINE INDENT y = str ( Y ) ; NEW_LINE n = len ( y ) NEW_LINE p = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT p [ i ] = ( ord ( y [ i ] ) - ord ( '0' ) ) NEW_LINE if ( i > 0 ) : NEW_LINE INDENT p [ i ] += p [ i - 1 ] ; NEW_LINE DEDENT DEDENT n - 1 NEW_LINE k = 0 NEW_LINE while True : NEW_LINE INDENT d = 0 ; NEW_LINE if ( i >= 0 ) : NEW_LINE INDENT d = ( ord ( y [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT for j in range ( d + 1 , 10 ) : NEW_LINE INDENT r = ( ( i > 0 ) * p [ i - 1 ] + j ) ; NEW_LINE if ( x - r >= 0 and x - r <= 9 * k ) : NEW_LINE INDENT suf = helper ( k , x - r ) ; NEW_LINE pre = \" \" ; NEW_LINE if ( i > 0 ) : NEW_LINE INDENT pre = y [ 0 : i ] NEW_LINE DEDENT cur = chr ( j + ord ( '0' ) ) NEW_LINE pre += cur ; NEW_LINE return pre + suf ; NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 18 ; NEW_LINE y = 99 ; NEW_LINE print ( findMin ( x , y ) ) NEW_LINE DEDENT"}
{"text": "Nombor terbesar yang terdiri daripada x dan y dengan kiraan x dibahagi dengan y dan y oleh x | Berfungsi untuk menjana dan mengembalikan nombor terbesar; Simpan yang lebih kecil di y; Simpan yang lebih besar dalam x; Kedai masing -masing; Jika n boleh dibahagikan dengan y; Tambah x, n kali ke jawapan; Mengurangkan n ke sifar; Mengurangkan n oleh x; Tambah y, x kali ke jawapan; Jika nombor boleh dibentuk; Jika tidak; Kod pemacu", "code": "def largestNumber ( n , X , Y ) : NEW_LINE INDENT maxm = max ( X , Y ) NEW_LINE Y = X + Y - maxm NEW_LINE X = maxm NEW_LINE Xs = 0 NEW_LINE Ys = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % Y == 0 ) : NEW_LINE INDENT Xs += n NEW_LINE n = 0 NEW_LINE DEDENT else : NEW_LINE INDENT n -= X NEW_LINE Ys += X NEW_LINE DEDENT DEDENT if ( n == 0 ) : NEW_LINE INDENT while ( Xs > 0 ) : NEW_LINE INDENT Xs -= 1 NEW_LINE print ( X , end = ' ' ) NEW_LINE DEDENT while ( Ys > 0 ) : NEW_LINE INDENT Ys -= 1 NEW_LINE print ( Y , end = ' ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT n = 19 NEW_LINE X = 7 NEW_LINE Y = 5 NEW_LINE largestNumber ( n , X , Y ) NEW_LINE"}
{"text": "Flip minimum yang diperlukan untuk menjana substring berterusan 0 € ™ s dan 1 € ™ s | Pelaksanaan Python3 pendekatan di atas; Melintasi rentetan input dan simpan kiraan 0; Melintasi rentetan input sekali lagi untuk mencari bilangan minimum flip; Kod pemacu", "code": "def minChanges ( str , N ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE for x in str : NEW_LINE INDENT count0 += ( x == '0' ) NEW_LINE DEDENT res = count0 NEW_LINE for x in str : NEW_LINE INDENT count0 -= ( x == '0' ) NEW_LINE count1 += ( x == '1' ) NEW_LINE res = min ( res , count1 + count0 ) NEW_LINE DEDENT return res NEW_LINE DEDENT N = 9 NEW_LINE str = \"000101001\" NEW_LINE print ( minChanges ( str , N ) ) NEW_LINE"}
{"text": "Kejadian yang hilang dari nombor dalam array sedemikian rupa sehingga perbezaan mutlak unsur -unsur bersebelahan adalah minimum | Pelaksanaan Python3 nombor yang hilang sedemikian rupa sehingga perbezaan mutlak maksimum antara elemen bersebelahan adalah minimum; Berfungsi untuk mencari nombor yang hilang supaya perbezaan mutlak maksimum adalah minimum; Gelung untuk mencari elemen bersebelahan maksimum dan minimum kepada nombor yang hilang; Kod pemacu; Panggilan fungsi", "code": "import sys NEW_LINE def missingnumber ( n , arr ) -> int : NEW_LINE INDENT mn = sys . maxsize ; NEW_LINE mx = - sys . maxsize - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 and arr [ i ] == - 1 and arr [ i - 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i - 1 ] ) ; NEW_LINE mx = max ( mx , arr [ i - 1 ] ) ; NEW_LINE DEDENT if ( i < ( n - 1 ) and arr [ i ] == - 1 and arr [ i + 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i + 1 ] ) ; NEW_LINE mx = max ( mx , arr [ i + 1 ] ) ; NEW_LINE DEDENT DEDENT res = ( mx + mn ) / 2 ; NEW_LINE return res ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE arr = [ - 1 , 10 , - 1 , 12 , - 1 ] ; NEW_LINE res = missingnumber ( n , arr ) ; NEW_LINE print ( res ) ; NEW_LINE DEDENT"}
{"text": "Memaksimumkan [panjang (x) / 2 ^ (xor (x, y))] dengan memilih substrings x dan y dari rentetan a dan b masing -masing | Berfungsi untuk mencari panjang substring biasa terpanjang rentetan x dan y; Lcsuff [i] [j] menyimpan panjang akhiran biasa substrings yang paling lama; Itearate atas rentetan a dan b; Jika baris pertama atau lajur; Jika padanan dijumpai; Jika tidak, jika padanan tidak dijumpai; Akhirnya, kembalikan nilai maksimum yang dihasilkan; Kod pemacu; Panggilan fungsi", "code": "def LCSubStr ( A , B , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = \"0110\" NEW_LINE B = \"1101\" NEW_LINE M = len ( A ) NEW_LINE N = len ( B ) NEW_LINE print ( LCSubStr ( A , B , M , N ) ) NEW_LINE DEDENT"}
{"text": "Kira cara untuk memecah array ke dalam sepasang subset dengan perbezaan antara jumlah mereka sama dengan k | Program Python untuk pendekatan di atas; Untuk menyimpan negeri -negeri DP; Fungsi untuk mencari kiraan subset dengan jumlah yang diberikan; Kes asas; Jika subproblem yang telah dikira berlaku; Tetapkan negeri seperti diselesaikan; Hubungan berulang; Berfungsi untuk mengira cara untuk memecah array ke dalam sepasang subset dengan perbezaan k; Simpan jumlah keseluruhan elemen array; Melintasi array; Hitung jumlah elemen array; Simpan jumlah yang diperlukan; Bilangan subset dengan jumlah yang sama dengan S1; Kod pemacu; Panggilan fungsi", "code": "maxN = 20 ; NEW_LINE maxSum = 50 ; NEW_LINE minSum = 50 ; NEW_LINE Base = 50 ; NEW_LINE dp = [ [ 0 for i in range ( maxSum + minSum ) ] for j in range ( maxN ) ] ; NEW_LINE v = [ [ False for i in range ( maxSum + minSum ) ] for j in range ( maxN ) ] ; NEW_LINE def findCnt ( arr , i , required_sum , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( required_sum == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ required_sum + Base ] ) : NEW_LINE INDENT return dp [ i ] [ required_sum + Base ] ; NEW_LINE DEDENT v [ i ] [ required_sum + Base ] = True ; NEW_LINE dp [ i ] [ required_sum + Base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; NEW_LINE return dp [ i ] [ required_sum + Base ] ; NEW_LINE DEDENT def countSubsets ( arr , K , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT S1 = ( sum + K ) // 2 ; NEW_LINE print ( findCnt ( arr , 0 , S1 , n ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 1 ; NEW_LINE countSubsets ( arr , K , N ) ; NEW_LINE DEDENT"}
{"text": "Kebarangkalian bahawa jumlah semua nombor yang diperolehi membuang dadu n kali terletak di antara dua bilangan bulat yang diberikan | Program Python untuk pendekatan di atas; Fungsi untuk mengira kebarangkalian bagi jumlah yang diberikan untuk menjadi sama dengan jumlah dalam n lontaran dadu; Kes asas; Kod pemacu; Kirakan kebarangkalian semua jumlah dari A hingga B; Jawapan", "code": "dp = [ [ 0 for i in range ( 605 ) ] for j in range ( 105 ) ] ; NEW_LINE def find ( N , sum ) : NEW_LINE INDENT if ( N < 0 sum < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ N ] [ sum ] > 0 ) : NEW_LINE INDENT return dp [ N ] [ sum ] ; NEW_LINE DEDENT if ( sum > 6 * N or sum < N ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return ( float ) ( 1.0 / 6 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; NEW_LINE DEDENT return dp [ N ] [ sum ] ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; a = 13 ; b = 17 ; NEW_LINE probability = 0.0 NEW_LINE f = 0 ; NEW_LINE for sum in range ( a , b + 1 ) : NEW_LINE INDENT probability = probability + find ( N , sum ) ; NEW_LINE DEDENT print ( \" % .6f \" % probability ) ; NEW_LINE DEDENT"}
{"text": "Langkah minimum untuk mengurangkan n hingga 0 dengan operasi yang diberikan | Berfungsi untuk mencari nombor minimum ke langkah untuk mengurangkan n hingga 0; Kamus untuk menyimpan jumlah yang dipraktikkan; Kes -kes asas; Semak jika n tidak dalam DP maka hanya panggil fungsi untuk mengurangkan panggilan rekursif; Kembalikan jawapannya; Diberi nombor n; Panggilan fungsi", "code": "def count ( n ) : NEW_LINE INDENT dp = dict ( ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE if n not in dp : NEW_LINE INDENT dp [ n ] = 1 + min ( n % 2 + count ( n // 2 ) , n % 3 + count ( n // 3 ) ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT N = 6 NEW_LINE print ( str ( count ( N ) ) ) NEW_LINE"}
{"text": "Pengiraan minimum kenaikan saiz K subarrays diperlukan untuk membentuk array yang diberikan | Berfungsi untuk mencari bilangan minimum operasi yang diperlukan untuk menukar semua pelbagai sifar supaya setiap elemen lebih besar daripada array yang diberikan; Mengisytiharkan pelbagai perbezaan saiz n; Bilangan operasi; Kemas kini pertama nilai D [i] dengan nilai sebelumnya; Indeks saya perlu ditingkatkan; Kita perlu melakukan operasi (b [i] - d [i]) lebih banyak; Meningkatkan julat saya ke i + k dengan keperluan; Semak jika i + k adalah indeks sah; Kod pemacu; Panggilan fungsi", "code": "def find_minimum_operations ( n , b , k ) : NEW_LINE INDENT d = [ 0 for i in range ( n + 1 ) ] NEW_LINE operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ i ] += d [ i - 1 ] NEW_LINE if b [ i ] > d [ i ] : NEW_LINE INDENT operations += ( b [ i ] - d [ i ] ) NEW_LINE need = ( b [ i ] - d [ i ] ) NEW_LINE d [ i ] += need NEW_LINE if i + k <= n : NEW_LINE INDENT d [ i + k ] -= need NEW_LINE DEDENT DEDENT DEDENT return operations NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE b = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE k = 2 NEW_LINE print ( find_minimum_operations ( n , b , k ) ) NEW_LINE DEDENT"}
{"text": "Bilangan cara memotong matriks supaya atleast satu sel diisi dalam setiap bahagian | Berfungsi untuk mencari bilangan cara untuk memotong matriks ke bahagian k supaya setiap bahagian mempunyai atleast satu sel yang dipenuhi; Gelung untuk mencari awalan jumlah matriks yang diberikan; dp (r, c, 1) = 1 jika anggapan [r] lain 0; Gelung untuk melangkah ke atas jadual DP matriks yang diberikan; Semak jika boleh dipotong secara mendatar pada R1, sekurang -kurangnya satu epal dalam matriks (r, c) -> r1, c - 1; Semak jika kita boleh memotong secara menegak di C1, sekurang -kurangnya satu epal dalam matriks (r, c) -> r - 1, c1; Kod pemacu; Panggilan fungsi", "code": "def ways ( arr , k ) : NEW_LINE INDENT R = len ( arr ) NEW_LINE C = len ( arr [ 0 ] ) NEW_LINE K = k NEW_LINE preSum = [ [ 0 for _ in range ( C ) ] \\ for _ in range ( R ) ] NEW_LINE for r in range ( R - 1 , - 1 , - 1 ) : NEW_LINE INDENT for c in range ( C - 1 , - 1 , - 1 ) : NEW_LINE INDENT preSum [ r ] = arr [ r ] NEW_LINE if r + 1 < R : NEW_LINE INDENT preSum [ r ] += preSum [ r + 1 ] NEW_LINE DEDENT if c + 1 < C : NEW_LINE INDENT preSum [ r ] += preSum [ r ] NEW_LINE DEDENT if r + 1 < R and c + 1 < C : NEW_LINE INDENT preSum [ r ] -= preSum [ r + 1 ] NEW_LINE DEDENT DEDENT DEDENT dp = [ [ [ 0 for _ in range ( C ) ] \\ for _ in range ( R ) ] \\ for _ in range ( K + 1 ) ] NEW_LINE for k in range ( 1 , K + 1 ) : NEW_LINE INDENT for r in range ( R - 1 , - 1 , - 1 ) : NEW_LINE INDENT for c in range ( C - 1 , - 1 , - 1 ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT dp [ k ] [ r ] = 1 if preSum [ r ] > 0 else 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ k ] [ r ] = 0 NEW_LINE for r1 in range ( r + 1 , R ) : NEW_LINE INDENT if preSum [ r ] - preSum [ r1 ] > 0 : NEW_LINE INDENT dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] NEW_LINE DEDENT DEDENT for c1 in range ( c + 1 , C ) : NEW_LINE INDENT if preSum [ r ] - preSum [ r ] [ c1 ] > 0 : NEW_LINE INDENT dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return dp [ K ] [ 0 ] [ 0 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 0 , 0 ] , [ 1 , 1 , 1 ] , [ 0 , 0 , 0 ] ] NEW_LINE k = 3 NEW_LINE print ( ways ( arr , k ) ) NEW_LINE DEDENT"}
{"text": "Produk semua subset saiz saiz k menggunakan unsur -unsur yang indeksnya membahagikan k sepenuhnya | Pelaksanaan Python3 pendekatan di atas; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang; Fungsi iteratif untuk mengira (NCR) % p dan simpan dalam f [n] [r]; Jika j> saya kemudian c (i, j) = 0; Jika saya sama dengan j maka c (i, j) = 1; Fungsi mengira jawapan akhir; Memulakan ans; x adalah kiraan kejadian arr [i] dalam set yang berbeza sedemikian rupa sehingga indeks arr [i] dalam set tersebut membahagikan k sepenuhnya. ; Mencari kiraan arr [i] dengan meletakkannya di indeks yang membahagikan k sepenuhnya; Oleh teorem Fermat; Kod pemacu", "code": "p = 1000000007 NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , p , f , m ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT if ( j > i ) : NEW_LINE INDENT f [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( j == 0 or j == i ) : NEW_LINE INDENT f [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p NEW_LINE DEDENT DEDENT DEDENT DEDENT def ProductOfSubsets ( arr , n , m ) : NEW_LINE INDENT f = [ [ 0 for i in range ( 100 ) ] for j in range ( n + 1 ) ] NEW_LINE nCr ( n , p - 1 , f , m ) NEW_LINE arr . sort ( reverse = False ) NEW_LINE ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = 0 NEW_LINE for j in range ( 1 , m + 1 , 1 ) : NEW_LINE INDENT if ( m % j == 0 ) : NEW_LINE INDENT x = ( ( x + ( f [ n - i - 1 ] [ m - j ] * f [ i ] [ j - 1 ] ) % ( p - 1 ) ) % ( p - 1 ) ) NEW_LINE DEDENT DEDENT ans = ( ( ans * power ( arr [ i ] , x , p ) ) % p ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 5 , 7 , 9 , 3 ] NEW_LINE K = 4 NEW_LINE N = len ( arr ) ; NEW_LINE ProductOfSubsets ( arr , N , K ) NEW_LINE DEDENT"}
{"text": "Bilangan cara untuk menulis n sebagai jumlah k non | Fungsi untuk mengira bilangan cara untuk menulis n sebagai jumlah kaum non - negatif; Inisiasi dp [] [] array; Hanya 1 cara untuk memilih nilai dengan jumlah k; Jumlah permulaan; Mengira cara dari negeri -negeri sebelumnya; Mengemas kini jumlah; Mengembalikan kiraan akhir cara; Kod pemacu; Panggilan fungsi", "code": "def countWays ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 2 , m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( j + 1 ) : NEW_LINE INDENT sum += dp [ i - 1 ] [ k ] NEW_LINE DEDENT dp [ i ] [ j ] = sum NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 NEW_LINE K = 3 NEW_LINE print ( countWays ( N , K ) ) NEW_LINE DEDENT"}
{"text": "Bilangan cara untuk menulis n sebagai jumlah k non | Fungsi untuk mengira bilangan cara untuk menulis n sebagai jumlah kaum non - negatif; Inisiasi dp [] [] array; Isi dp [] [] dengan jumlah = m; Melelehkan dp [] [] untuk mengisi array dp [] []; Keadaan untuk lajur pertama; Lain mengisi dp [] [] dengan jumlah sehingga (i, j); Jika sampai ke akhir, maka kembalikan nilai; Mengemas kini pada indeks semasa; Kod pemacu; Panggilan fungsi", "code": "def countWays ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE if ( i != 0 ) : NEW_LINE INDENT dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 2 , m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE if ( i == m and j == n ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] += dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT N = 2 NEW_LINE K = 3 NEW_LINE print ( countWays ( N , K ) ) NEW_LINE"}
{"text": "Susunan terpanjang sedemikian rupa sehingga setiap elemen dalam berikutnya dibentuk dengan mengalikan elemen sebelumnya dengan perdana | Program Python3 untuk melaksanakan pendekatan di atas; Berfungsi untuk prima pra -pra; Kaedah ayak untuk memeriksa sama ada perdana atau tidak; Gandaan; Pra -simpan semua prima; Berfungsi untuk mencari berikutnya terpanjang; Peta hash; Hubungi fungsi untuk menyimpan prima; Memulakan elemen terakhir dengan 1 kerana yang paling lama mungkin; Melangkah dari belakang dan cari yang paling lama; Dapatkan nombor; Memulakan dp [i] sebagai 1 sebagai elemen hanya akan saya dalam berikutnya; Melangkah dalam semua prima dan berlipat ganda untuk mendapatkan elemen seterusnya; Elemen seterusnya jika didarabkan dengannya; Jika melebihi elemen terakhir maka pecah; Jika nombor ada dalam array; Dapatkan unsur maksimum yang paling maksimum; Hash elemen; Cari yang paling lama; Kod pemacu", "code": "from math import sqrt NEW_LINE def SieveOfEratosthenes ( MAX , primes ) : NEW_LINE INDENT prime = [ True ] * ( MAX + 1 ) ; NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p ** 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT primes . append ( i ) ; NEW_LINE DEDENT DEDENT DEDENT def findLongest ( A , n ) : NEW_LINE INDENT mpp = { } ; NEW_LINE primes = [ ] ; NEW_LINE SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; NEW_LINE dp = [ 0 ] * n ; NEW_LINE dp [ n - 1 ] = 1 ; NEW_LINE mpp [ A [ n - 1 ] ] = n - 1 ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT num = A [ i ] ; NEW_LINE dp [ i ] = 1 ; NEW_LINE maxi = 0 ; NEW_LINE for it in primes : NEW_LINE INDENT xx = num * it ; NEW_LINE if ( xx > A [ n - 1 ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT elif xx in mpp : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , 1 + dp [ mpp [ xx ] ] ) ; NEW_LINE DEDENT DEDENT mpp [ A [ i ] ] = i ; NEW_LINE DEDENT ans = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 5 , 6 , 12 , 35 , 60 , 385 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( findLongest ( a , n ) ) ; NEW_LINE DEDENT"}
{"text": "Bilangan rentetan binari panjang n dengan k bit set bersebelahan | Berfungsi untuk mencari bilangan rentetan bit panjang n dengan k bit set bersebelahan; Kes asas apabila kita membentuk rentetan panjang n; jika f (bit string) = k, hitung cara ini; Semak sama ada bit terakhir ditetapkan, jika ditetapkan maka hubungi indeks seterusnya dengan menambah kiraan bit bersebelahan lain, hubungi indeks seterusnya dengan nilai yang sama dari kiraan bit bersebelahan dan sama ada tetapkan bit pada indeks semasa atau biarkan ia tetap tidak tersembunyi; Tetapkan bit pada CurrentIndex; tidak jelas sedikit pada currentIndex; Kod pemacu; Jumlah cara = (cara dengan meletakkan bit 1 st 1 + cara dengan meletakkan bit 1 sebagai 0)", "code": "def waysToKAdjacentSetBits ( n , k , currentIndex , adjacentSetBits , lastBit ) : NEW_LINE INDENT if ( currentIndex == n ) : NEW_LINE INDENT if ( adjacentSetBits == k ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 NEW_LINE DEDENT noOfWays = 0 NEW_LINE if ( lastBit == 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; NEW_LINE DEDENT elif ( lastBit != 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; NEW_LINE DEDENT return noOfWays ; NEW_LINE DEDENT n = 5 ; k = 2 ; NEW_LINE totalWays = ( waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ) ; NEW_LINE print ( \" Number ▁ of ▁ ways ▁ = \" , totalWays ) ; NEW_LINE"}
{"text": "Jumlah produk semua gabungan diambil (1 hingga n) pada satu masa | Cari array Jumlah Postfix; Ubah suai array supaya kita tidak perlu mengira produk yang diperoleh sebelum ini; Mencari jumlah semua gabungan yang diambil 1 hingga n pada satu masa; Jumlah yang diambil 1 pada masa hanya jumlah 1 - n; untuk jumlah produk untuk semua kombinasi; mencari array postfix; Jumlah produk yang diambil i + 1 pada satu masa; Ubah suai array untuk masalah bertindih; Kod pemandu; menyimpan nombor dari 1 hingga n; Memanggil AllCombination", "code": "def postfix ( a , n ) : NEW_LINE INDENT for i in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT a [ i - 1 ] = a [ i - 1 ] + a [ i ] NEW_LINE DEDENT DEDENT def modify ( a , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT a [ i - 1 ] = i * a [ i ] ; NEW_LINE DEDENT DEDENT def allCombination ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT print ( \" f ( 1 ) ▁ - - > ▁ \" , sum ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT postfix ( a , n - i + 1 ) NEW_LINE sum = 0 NEW_LINE for j in range ( 1 , n - i + 1 ) : NEW_LINE INDENT sum += ( j * a [ j ] ) NEW_LINE DEDENT print ( \" f ( \" , i + 1 , \" ) ▁ - - > ▁ \" , sum ) NEW_LINE modify ( a , n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = i + 1 NEW_LINE DEDENT allCombination ( a , n ) NEW_LINE DEDENT"}
{"text": "Kira cara untuk mencapai tangga nth menggunakan langkah 1, 2 atau 3 | Mengembalikan kiraan cara untuk mencapai tangga N - menggunakan 1 atau 2 atau 3 langkah. ; Kod pemacu", "code": "def findStep ( n ) : NEW_LINE INDENT if ( n == 1 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE print ( findStep ( n ) ) NEW_LINE"}
{"text": "Masalah Partition | DP | Fungsi utiliti yang kembali benar jika terdapat subset arr [] dengan matahari sama dengan jumlah yang diberikan; Kes asas; Jika elemen terakhir lebih besar daripada jumlah, maka abaikannya; Selain itu, periksa sama ada SUM boleh diperolehi oleh mana -mana yang berikut (a) termasuk elemen terakhir (b) tidak termasuk elemen terakhir; Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah elemen dalam array; Jika jumlahnya ganjil, tidak ada dua subset dengan jumlah yang sama; Cari jika terdapat subset dengan jumlah yang sama dengan separuh daripada jumlah keseluruhan; Kod pemacu; Panggilan fungsi", "code": "def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT if sum == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 0 and sum != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if arr [ n - 1 ] > sum : NEW_LINE INDENT return isSubsetSum ( arr , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( arr , n - 1 , sum ) or isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) NEW_LINE DEDENT def findPartion ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if sum % 2 != 0 : NEW_LINE INDENT return false NEW_LINE DEDENT return isSubsetSum ( arr , n , sum // 2 ) NEW_LINE DEDENT arr = [ 3 , 1 , 5 , 9 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE if findPartion ( arr , n ) == True : NEW_LINE INDENT print ( \" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Can ▁ not ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ sum \" ) NEW_LINE DEDENT"}
{"text": "Masalah Partition | DP | Pulangan benar jika ARR [] boleh dibahagikan dalam dua subset jumlah yang sama, jika tidak palsu; Hitung jumlah semua elemen; Memulakan array bahagian sebagai 0; Isi jadual partition dengan cara bawah; Unsur yang akan dimasukkan dalam jumlah tidak boleh lebih besar daripada jumlahnya; Semak jika jumlah - arr [i] boleh dibentuk dari subset menggunakan elemen sebelum indeks I; Kod pemacu; Panggilan fungsi", "code": "def findPartiion ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT if ( Sum % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT part = [ 0 ] * ( ( Sum // 2 ) + 1 ) NEW_LINE for i in range ( ( Sum // 2 ) + 1 ) : NEW_LINE INDENT part [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( Sum // 2 , arr [ i ] - 1 , - 1 ) : NEW_LINE INDENT if ( part [ j - arr [ i ] ] == 1 or j == arr [ i ] ) : NEW_LINE INDENT part [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT return part [ Sum // 2 ] NEW_LINE DEDENT arr = [ 1 , 3 , 3 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( findPartiion ( arr , n ) == 1 ) : NEW_LINE INDENT print ( \" Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Can ▁ not ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ sum \" ) NEW_LINE DEDENT"}
{"text": "Koefisien binomial | DP | Berfungsi untuk mencari pekali binomial; Mendapatkan penyongsangan modular untuk semua nombor dari 2 hingga R berkenaan dengan M di sini M = 1000000007; untuk 1 / (r!) Bahagian; untuk (n) * (n - 1) * (n - 2) * ... * (n - r + 1) bahagian; Kod pemacu", "code": "def binomialCoeff ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT m = 1000000007 NEW_LINE inv = [ 0 for i in range ( r + 1 ) ] NEW_LINE inv [ 0 ] = 1 ; NEW_LINE if ( r + 1 >= 2 ) NEW_LINE inv [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , r + 1 ) : NEW_LINE INDENT inv [ i ] = m - ( m // i ) * inv [ m % i ] % m NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 2 , r + 1 ) : NEW_LINE INDENT ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m NEW_LINE DEDENT for i in range ( n , n - r , - 1 ) : NEW_LINE INDENT ans = ( ( ans % m ) * ( i % m ) ) % m NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE r = 2 NEW_LINE print ( \" Value ▁ of ▁ C ( \" , n , \" , ▁ \" , r , \" ) ▁ is ▁ \" , binomialCoeff ( n , r ) ) NEW_LINE"}
{"text": "Semak sama ada mungkin untuk mencapai (x, y) dari (1, 1) dengan langkah -langkah yang diberikan | Berfungsi untuk mencari GCD dua nombor; Kes asas; Berulang; Berfungsi untuk mencetak jawapan; GCD X dan Y; Jika GCD adalah kuasa 2; Kod pemacu; Diberikan x dan y; Panggilan fungsi", "code": "def gcd ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT t = a NEW_LINE a = b NEW_LINE b = t NEW_LINE DEDENT if ( a % b == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def printAnswer ( x , y ) : NEW_LINE INDENT val = gcd ( x , y ) NEW_LINE if ( ( val & ( val - 1 ) ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 4 NEW_LINE y = 7 NEW_LINE printAnswer ( x , y ) NEW_LINE DEDENT"}
{"text": "Cari elemen dalam matriks yang dihasilkan oleh peraturan yang diberikan | Berfungsi untuk mengembalikan elemen dalam lajur RTH dan lajur CTH dari matriks yang diperlukan; Keadaan untuk separuh bawah matriks; Keadaan jika elemen berada di baris pertama; Memulakan elemen AP dalam baris R; Perbezaan umum AP dalam baris r; Kedudukan elemen untuk mencari di AP dalam baris r; Kod pemacu", "code": "def getElement ( N , r , c ) : NEW_LINE INDENT if ( r > c ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( r == 1 ) : NEW_LINE INDENT return c ; NEW_LINE DEDENT a = ( r + 1 ) * pow ( 2 , r - 2 ) ; NEW_LINE d = pow ( 2 , r - 1 ) ; NEW_LINE c = c - r ; NEW_LINE element = a + d * c ; NEW_LINE return element ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; R = 3 ; C = 4 ; NEW_LINE print ( getElement ( N , R , C ) ) ; NEW_LINE DEDENT"}
{"text": "Cari nombor terkecil yang dibentuk dengan memasukkan digit yang diberikan | Fungsi untuk memasukkan x dalam n dan mengembalikan rentetan nilai minimum; Pembolehubah untuk menyimpan panjang rentetan n; Pembolehubah untuk menunjukkan kedudukan di mana x mesti ditambah; Jika rentetan yang diberikan n mewakili nilai negatif; X mesti diletakkan pada indeks terakhir di mana lebih besar daripada n [i]; Untuk nombor positif, x mesti diletakkan pada indeks terakhir di mana ia lebih kecil daripada n [i]; Masukkan x pada kedudukan itu; Kembalikan rentetan; Diberikan input; Panggilan fungsi", "code": "def MinValue ( N , X ) : NEW_LINE INDENT N = list ( N ) ; NEW_LINE ln = len ( N ) NEW_LINE position = ln + 1 NEW_LINE if ( N [ 0 ] == ' - ' ) : NEW_LINE INDENT for i in range ( ln - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( ( ord ( N [ i ] ) - ord ( '0' ) ) < X ) : NEW_LINE INDENT position = i NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( ln - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( ( ord ( N [ i ] ) - ord ( '0' ) ) > X ) : NEW_LINE INDENT position = i NEW_LINE DEDENT DEDENT DEDENT c = chr ( X + ord ( '0' ) ) NEW_LINE str = N . insert ( position , c ) ; NEW_LINE return ' ' . join ( N ) NEW_LINE DEDENT N = \"89\" NEW_LINE X = 1 NEW_LINE print ( MinValue ( N , X ) ) NEW_LINE"}
{"text": "Semak jika perwakilan perpuluhan rentetan binari yang diberikan dapat dibahagikan dengan k atau tidak | Fungsi untuk memeriksa nombor binari yang boleh dibahagikan oleh k; Array Poweroftwo akan menyimpan pow (2, i) % k; Memulakan elemen pertama dalam array; Menyimpan setiap nilai pow (2, i) % k dalam array; Untuk menyimpan baki; Melangkah sehingga n; Jika bit semasa ialah 1; Mengemas kini REM; Jika benar -benar boleh dibahagikan; Jika tidak sepenuhnya dibahagi; Kod pemacu; Diberikan input; panjang rentetan s; Panggilan fungsi", "code": "def divisibleByk ( s , n , k ) : NEW_LINE INDENT poweroftwo = [ 0 for i in range ( n ) ] NEW_LINE poweroftwo [ 0 ] = 1 % k NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT poweroftwo [ i ] = ( poweroftwo [ i - 1 ] * ( 2 % k ) ) % k NEW_LINE DEDENT rem = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ n - i - 1 ] == '1' ) : NEW_LINE INDENT rem += ( poweroftwo [ i ] ) NEW_LINE rem %= k NEW_LINE DEDENT DEDENT if ( rem == 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"1010001\" NEW_LINE k = 9 NEW_LINE n = len ( s ) NEW_LINE print ( divisibleByk ( s , n , k ) ) NEW_LINE DEDENT"}
{"text": "Mengira penyingkiran pasangan yang diperlukan untuk kosongkan semua berikutnya Parenthesis Balanced | Fungsi untuk mencari kiraan maksimum pasangan yang diperlukan untuk dikeluarkan supaya rentetan seterusnya tidak mengandungi sebarang kurungan yang sah; Kedai kiraan pasangan kurungan seimbang; Kedai -kedai mengira kurungan seimbang; Kedai mengira kurungan seimbang kecil; Kedai kiraan kurungan seimbang persegi; Melangkah ke atas aksara rentetan; Mengemas kini cntcurly; Kemas kini CNTSML; Kemas kini CNTSQR; Mengemas kini cntcurly; Kemas kini CNTPairs; Kemas kini CNTSML; Kemas kini CNTPairs; Kemas kini CNTSML; Kemas kini CNTPairs; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "def cntBalancedParenthesis ( s , N ) : NEW_LINE INDENT cntPairs = 0 ; NEW_LINE cntCurly = 0 ; NEW_LINE cntSml = 0 ; NEW_LINE cntSqr = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( ord ( s [ i ] ) == ord ( ' { ' ) ) : NEW_LINE INDENT cntCurly += 1 ; NEW_LINE DEDENT elif ( ord ( s [ i ] ) == ord ( ' ( ' ) ) : NEW_LINE INDENT cntSml += 1 ; NEW_LINE DEDENT elif ( ord ( s [ i ] ) == ord ( ' [ ' ) ) : NEW_LINE INDENT cntSqr += 1 ; NEW_LINE DEDENT elif ( ord ( s [ i ] ) == ord ( ' } ' ) and cntCurly > 0 ) : NEW_LINE INDENT cntCurly -= 1 ; NEW_LINE cntPairs += 1 ; NEW_LINE DEDENT elif ( ord ( s [ i ] ) == ord ( ' ) ' ) and cntSml > 0 ) : NEW_LINE INDENT cntSml -= 1 ; NEW_LINE cntPairs += 1 ; NEW_LINE DEDENT elif ( ord ( s [ i ] ) == ord ( ' ] ' ) and cntSqr > 0 ) : NEW_LINE INDENT cntSqr -= 1 ; NEW_LINE cntPairs += 1 ; NEW_LINE DEDENT DEDENT print ( cntPairs ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" { ( } ) \" ; NEW_LINE N = len ( s ) ; NEW_LINE cntBalancedParenthesis ( s , N ) ; NEW_LINE DEDENT"}
{"text": "Count of Strings yang tidak mengandungi persimpangan arka | Berfungsi untuk memeriksa sama ada terdapat persimpangan arka atau tidak; Melintasi rentetan s; Masukkan semua elemen dalam timbunan satu demi satu; Ekstrak elemen teratas; Pop keluar elemen teratas; Semak sama ada elemen atas adalah sama dengan elemen yang muncul; Jika tidak; Sekiranya timbunan kosong; Fungsi untuk memeriksa sama ada terdapat persimpangan arka atau tidak untuk pelbagai rentetan yang diberikan; Kedai kiraan rentetan tidak mempunyai persimpangan arka; Berulang melalui array; Panjang setiap rentetan; Panggilan fungsi; Cetak kiraan yang dikehendaki; Kod pemacu; Panggilan fungsi", "code": "def arcIntersection ( S , lenn ) : NEW_LINE INDENT stk = [ ] NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT stk . append ( S [ i ] ) NEW_LINE if ( len ( stk ) >= 2 ) : NEW_LINE INDENT temp = stk [ - 1 ] NEW_LINE del stk [ - 1 ] NEW_LINE if ( stk [ - 1 ] == temp ) : NEW_LINE INDENT del stk [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( temp ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( stk ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def countString ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT lenn = len ( arr [ i ] ) NEW_LINE count += arcIntersection ( arr [ i ] , lenn ) NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \"0101\" , \"0011\" , \"0110\" ] NEW_LINE N = len ( arr ) NEW_LINE countString ( arr , N ) NEW_LINE DEDENT"}
{"text": "Semak jika perwakilan perpuluhan rentetan binari boleh dibahagikan dengan 9 atau tidak | Berfungsi untuk menukar rentetan binari ke dalam perwakilan oktal; Kedai perwakilan binari nilai perpuluhan [0 - 7]; Menyimpan nilai perpuluhan rentetan binari [0 - 7]; Kedai panjang s; Kemas kini s; Kemas kini s; Kemas kini n; Kedai perwakilan oktal rentetan binari; Melintasi rentetan binari; Kedai 3 aksara berturut -turut rentetan binari; Tambah perwakilan oktal temp; Fungsi untuk memeriksa sama ada rentetan binari boleh dibahagikan dengan 9 atau tidak; Kedai perwakilan oktal S; Kedai jumlah unsur yang hadir pada kedudukan ganjil OCT; Kedai jumlah unsur yang hadir pada kedudukan ganjil OCT; Kedai panjang OCT; Melintasi rentetan OCT; Mengemas kini oddsum; Melintasi rentetan OCT; Kemas kini Evensum; Kedai perwakilan cotal 9; Jika nilai mutlak (oddsum - evensum) boleh dibahagikan dengan Okt_9; Kod pemacu", "code": "def ConvertequivalentBase8 ( S ) : NEW_LINE INDENT mp = { } NEW_LINE mp [ \"000\" ] = '0' NEW_LINE mp [ \"001\" ] = '1' NEW_LINE mp [ \"010\" ] = '2' NEW_LINE mp [ \"011\" ] = '3' NEW_LINE mp [ \"100\" ] = '4' NEW_LINE mp [ \"101\" ] = '5' NEW_LINE mp [ \"110\" ] = '6' NEW_LINE mp [ \"111\" ] = '7' NEW_LINE N = len ( S ) NEW_LINE if ( N % 3 == 2 ) : NEW_LINE INDENT S = \"0\" + S NEW_LINE DEDENT elif ( N % 3 == 1 ) : NEW_LINE INDENT S = \"00\" + S NEW_LINE DEDENT N = len ( S ) NEW_LINE octal = \" \" NEW_LINE for i in range ( 0 , N , 3 ) : NEW_LINE INDENT temp = S [ i : i + 3 ] NEW_LINE if temp in mp : NEW_LINE octal += ( mp [ temp ] ) NEW_LINE DEDENT return octal NEW_LINE DEDENT def binString_div_9 ( S , N ) : NEW_LINE INDENT octal = ConvertequivalentBase8 ( S ) NEW_LINE oddSum = 0 NEW_LINE evenSum = 0 NEW_LINE M = len ( octal ) NEW_LINE for i in range ( 0 , M , 2 ) : NEW_LINE INDENT oddSum += ord ( octal [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for i in range ( 1 , M , 2 ) : NEW_LINE INDENT evenSum += ord ( octal [ i ] ) - ord ( '0' ) NEW_LINE DEDENT Oct_9 = 11 NEW_LINE if ( abs ( oddSum - evenSum ) % Oct_9 == 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT return \" No \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"1010001\" NEW_LINE N = len ( S ) NEW_LINE print ( binString_div_9 ( S , N ) ) NEW_LINE DEDENT"}
{"text": "Kos minimum untuk mengeluarkan ruang antara aksara rentetan dengan menyusun semula aksara | Fungsi untuk mengira kos minimum; Menyimpan kos minimum; Menyimpan kiraan watak yang dijumpai; Menyimpan kiraan ruang kosong yang dijumpai; Menyimpan kiraan jumlah aksara; Jika kiraan aksara sama dengan 1; Melangkah ke atas rentetan; Pertimbangkan watak sebelumnya bersama -sama dengan watak semasa; Sekiranya tidak bersama sudah; Tambah kos untuk mengumpulkannya bersama -sama; Meningkatkan kiraan watak yang dijumpai; Jika tidak; Meningkatkan kiraan ruang yang dijumpai; Mengembalikan jumlah kos yang diperoleh; Kod pemacu", "code": "def min_cost ( S ) : NEW_LINE INDENT cost = 0 NEW_LINE F = 0 NEW_LINE B = 0 NEW_LINE n = len ( S ) - S . count ( ' ▁ ' ) NEW_LINE if n == 1 : NEW_LINE INDENT return cost NEW_LINE DEDENT for char in S : NEW_LINE INDENT if char != ' ▁ ' : NEW_LINE INDENT if B != 0 : NEW_LINE INDENT cost += min ( n - F , F ) * B NEW_LINE B = 0 NEW_LINE DEDENT F += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT S = \" ▁ @ TABSYMBOL $ \" NEW_LINE print ( min_cost ( S ) ) NEW_LINE"}
{"text": "Kurangkan kos untuk menggantikan semua vokal rentetan yang diberikan oleh vokal tunggal | Fungsi yang kembali benar jika watak yang diberikan adalah vokal; Berfungsi untuk mengembalikan kos minimum untuk menukar semua vokal rentetan kepada satu; Kedai mengira vokal masing -masing; Melangkah melalui rentetan; Jika vokal ditemui; Kirakan kos; Mengembalikan kos minimum; Kod pemacu", "code": "def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT def minCost ( S ) : NEW_LINE INDENT cA = 0 ; NEW_LINE cE = 0 ; NEW_LINE cI = 0 ; NEW_LINE cO = 0 ; NEW_LINE cU = 0 ; NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if ( isVowel ( S [ i ] ) ) : NEW_LINE INDENT cA += abs ( ord ( S [ i ] ) - ord ( ' a ' ) ) ; NEW_LINE cE += abs ( ord ( S [ i ] ) - ord ( ' e ' ) ) ; NEW_LINE cI += abs ( ord ( S [ i ] ) - ord ( ' i ' ) ) ; NEW_LINE cO += abs ( ord ( S [ i ] ) - ord ( ' o ' ) ) ; NEW_LINE cU += abs ( ord ( S [ i ] ) - ord ( ' u ' ) ) ; NEW_LINE DEDENT DEDENT return min ( min ( min ( min ( cA , cE ) , cI ) , cO ) , cU ) ; NEW_LINE DEDENT S = \" geeksforgeeks \" ; NEW_LINE print ( minCost ( S ) ) NEW_LINE"}
{"text": "Menjana rentetan yang semua k | Berfungsi untuk mengembalikan rentetan yang diperlukan; Melepasi rentetan yang diberikan; Tambah watak pertama setiap substring panjang k; Pertimbangkan semua watak dari substring terakhir; Kod pemacu", "code": "def decode_String ( st , K ) : NEW_LINE INDENT ans = \" \" NEW_LINE for i in range ( 0 , len ( st ) , K ) : NEW_LINE INDENT ans += st [ i ] NEW_LINE DEDENT for i in range ( len ( st ) - ( K - 1 ) , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT K = 3 NEW_LINE st = \" abcbcscsesesesd \" NEW_LINE decode_String ( st , K ) NEW_LINE DEDENT"}
{"text": "Lexicographically terkecil k | Fungsi yang mencetak substring panjang K - panjang terkecil yang mengandungi bilangan vokal maksimum; Simpan panjang rentetan; Memulakan array jumlah awalan; Gelung melalui rentetan untuk membuat array Sum Prefix; Simpan 1 pada indeks jika ia adalah vokal; Jika tidak, simpan 0; Proses array awalan; Memulakan pembolehubah untuk menyimpan kiraan maksimum vokal; Memulakan pembolehubah untuk menyimpan substring dengan kiraan maksimum vokal; Gelung melalui array awalan; Simpan kiraan vokal semasa; Kemas kini hasil jika kiraan semasa lebih besar daripada kiraan maksimum; Kemas kini substring terkecil secara lexicographically jika kiraan semasa adalah sama dengan kiraan maksimum; Mengembalikan hasilnya; Kod pemacu", "code": "def maxVowelSubString ( str1 , K ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE pref = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( str1 [ i ] == ' a ' or str1 [ i ] == ' e ' or str1 [ i ] == ' i ' or str1 [ i ] == ' o ' or str1 [ i ] == ' u ' ) : NEW_LINE INDENT pref [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pref [ i ] = 0 NEW_LINE DEDENT if ( i ) : NEW_LINE INDENT pref [ i ] += pref [ i - 1 ] NEW_LINE DEDENT DEDENT maxCount = pref [ K - 1 ] NEW_LINE res = str1 [ 0 : K ] NEW_LINE for i in range ( K , N ) : NEW_LINE INDENT currCount = pref [ i ] - pref [ i - K ] NEW_LINE if ( currCount > maxCount ) : NEW_LINE INDENT maxCount = currCount NEW_LINE res = str1 [ i - K + 1 : i + 1 ] NEW_LINE DEDENT elif ( currCount == maxCount ) : NEW_LINE INDENT temp = str1 [ i - K + 1 : i + 1 ] NEW_LINE if ( temp < res ) : NEW_LINE INDENT res = temp NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" ceebbaceeffo \" NEW_LINE K = 3 NEW_LINE print ( maxVowelSubString ( str1 , K ) ) NEW_LINE DEDENT"}
{"text": "Decode rentetan yang dikodkan dengan algoritma yang diberikan | Berfungsi untuk menyahkod dan mencetak rentetan asal; Untuk menyimpan rentetan yang dikodkan; Mendapatkan elemen pertengahan; Menyimpan elemen pertama rentetan pada kedudukan median; Jika panjangnya, kemudian simpan elemen kedua juga; K mewakili bilangan aksara yang telah disimpan dalam C []; Jika panjang rentetan ganjil; Jika ia juga; Cetak rentetan decoded; Kod pemacu", "code": "def decodeStr ( str , len ) : NEW_LINE INDENT c = [ \" \" for i in range ( len ) ] NEW_LINE pos = 1 NEW_LINE if ( len % 2 == 1 ) : NEW_LINE INDENT med = int ( len / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT med = int ( len / 2 - 1 ) NEW_LINE DEDENT c [ med ] = str [ 0 ] NEW_LINE if ( len % 2 == 0 ) : NEW_LINE INDENT c [ med + 1 ] = str [ 1 ] NEW_LINE DEDENT if ( len & 1 ) : NEW_LINE INDENT k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 2 NEW_LINE DEDENT for i in range ( k , len , 2 ) : NEW_LINE INDENT c [ med - pos ] = str [ i ] NEW_LINE if ( len % 2 == 1 ) : NEW_LINE INDENT c [ med + pos ] = str [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT c [ med + pos + 1 ] = str [ i + 1 ] NEW_LINE DEDENT pos += 1 NEW_LINE DEDENT print ( * c , sep = \" \" ) NEW_LINE DEDENT str = \" ofrsgkeeeekgs \" NEW_LINE len = len ( str ) NEW_LINE decodeStr ( str , len ) NEW_LINE"}
{"text": "Mengira watak -watak yang berbeza dalam substring dengan julat yang diberikan untuk pertanyaan q | Program Python3 untuk pendekatan naif; Kaunter untuk mengira char yang berbeza; Array frekuensi memulakan untuk mengira aksara sebagai muncul dalam substring s [l: r]; Melangkah ke atas [L] ke S [r]; Meningkatkan kiraan S [i] watak dalam pelbagai frekuensi; Jika kekerapan mana -mana watak adalah> 0 maka kenaikan kaunter; Kod pemacu", "code": "def findCount ( s , L , R ) : NEW_LINE INDENT distinct = 0 NEW_LINE frequency = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( L , R + 1 , 1 ) : NEW_LINE INDENT frequency [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( frequency [ i ] > 0 ) : NEW_LINE INDENT distinct += 1 NEW_LINE DEDENT DEDENT print ( distinct ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeksisacomputerscienceportal \" NEW_LINE queries = 3 NEW_LINE Q = [ [ 0 , 10 ] , [ 15 , 18 ] , [ 12 , 20 ] ] NEW_LINE for i in range ( queries ) : NEW_LINE INDENT findCount ( s , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT"}
{"text": "String yang diperoleh dengan membalikkan dan melengkapkan rentetan binari K kali | Berfungsi untuk melaksanakan operasi k pada rentetan dan mencari rentetan yang diubah suai; Bilangan operasi terbalik; Bilangan operasi pelengkap; Jika rev adalah pariti ganjil; Jika pelengkap adalah pariti ganjil; Melengkapi setiap kedudukan; Kembalikan rentetan yang diubah suai; Kod pemacu; Panggilan fungsi", "code": "def ReverseComplement ( s , n , k ) : NEW_LINE INDENT rev = ( k + 1 ) // 2 NEW_LINE complement = k - rev NEW_LINE if ( rev % 2 ) : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE DEDENT if ( complement % 2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT s [ i ] = '1' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = '0' NEW_LINE DEDENT DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \"10011\" NEW_LINE k = 5 NEW_LINE n = len ( str1 ) NEW_LINE print ( ReverseComplement ( str1 , n , k ) ) NEW_LINE DEDENT"}
{"text": "Semak jika ada permutasi rentetan adalah rentetan kim yang berulang kali | Fungsi untuk memeriksa bahawa permutasi rentetan yang diberikan adalah rentetan mengulangi kali; Jika panjang rentetan tidak dapat dibahagikan dengan k; Pelbagai kekerapan; Pada mulanya kekerapan setiap watak ialah 0; Pengkomputeran kekerapan setiap aksara dalam rentetan; Gelung untuk memeriksa kekerapan setiap watak rentetan itu boleh dibahagikan dengan k; Kod pemacu", "code": "def repeatingString ( s , n , k ) : NEW_LINE INDENT if ( n % k != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT frequency = [ 0 for i in range ( 123 ) ] NEW_LINE for i in range ( 123 ) : NEW_LINE INDENT frequency [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT frequency [ s [ i ] ] += 1 NEW_LINE DEDENT repeat = n // k NEW_LINE for i in range ( 123 ) : NEW_LINE INDENT if ( frequency [ i ] % repeat != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" abcdcba \" NEW_LINE n = len ( s ) NEW_LINE k = 3 NEW_LINE if ( repeatingString ( s , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Cari dua digit terakhir yang hilang dari nombor telefon yang diberikan | Berfungsi untuk mencari dua digit terakhir nombor dan mencetak nombor lengkap; Jumlah lapan digit nombor pertama; jika jumlah <10, maka dua digit adalah '0' dan nilai jumlah; Jika jumlah> 10, maka dua digit adalah nilai jumlah; Kod pemacu", "code": "def findPhoneNumber ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp // 10 NEW_LINE DEDENT if ( sum < 10 ) : NEW_LINE INDENT print ( n , \"0\" , sum ) NEW_LINE DEDENT else : NEW_LINE INDENT n = str ( n ) NEW_LINE sum = str ( sum ) NEW_LINE n += sum NEW_LINE print ( n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 98765432 NEW_LINE findPhoneNumber ( n ) NEW_LINE DEDENT"}
{"text": "Bilangan cara untuk memecah nombor binari supaya setiap bahagian boleh dibahagikan dengan 2 | Berfungsi untuk mengembalikan kiraan yang diperlukan; Jika pemisahan tidak mungkin; Untuk menyimpan kiraan sifar; Mengira bilangan sifar; Kembalikan jawapan terakhir; Kod pemacu", "code": "def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_zero = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT c_zero += ( s [ i ] == '0' ) ; NEW_LINE DEDENT return int ( pow ( 2 , c_zero - 1 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"10010\" ; NEW_LINE print ( cntSplits ( s ) ) ; NEW_LINE DEDENT"}
{"text": "Kira bilangan substrings rentetan yang terdiri daripada aksara yang sama | Berfungsi untuk mengembalikan bilangan substrings aksara yang sama; Saiz rentetan; Memulakan kiraan kepada 1; Memulakan kiri ke 0 dan kanan ke 1 untuk melintasi rentetan; Memeriksa jika aksara berturut -turut adalah sama dan kenaikan kiraan; Apabila kita menghadapi watak yang berbeza; Meningkatkan hasilnya; Untuk mengulangi keseluruhan proses set kiri sama dan mengira pembolehubah kepada 1; Simpan nilai akhir hasil; Kod pemacu", "code": "def findNumbers ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 1 NEW_LINE result = 0 NEW_LINE left = 0 NEW_LINE right = 1 NEW_LINE while ( right < n ) : NEW_LINE INDENT if ( s [ left ] == s [ right ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += count * ( count + 1 ) // 2 NEW_LINE left = right NEW_LINE count = 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT result += count * ( count + 1 ) // 2 NEW_LINE print ( result ) NEW_LINE DEDENT s = \" bbbcbb \" NEW_LINE findNumbers ( s ) NEW_LINE"}
{"text": "Program untuk menduplikasi vokal dalam rentetan | Berfungsi untuk memeriksa vokal; Berfungsi untuk mendapatkan rentetan yang dihasilkan dengan vokal yang diduplikasi; Satu lagi untuk menyimpan rentetan yang dihasilkan; Gelung untuk memeriksa setiap watak; Kod pemacu; Cetak rentetan asal; Cetak tali yang dihasilkan", "code": "def isVowel ( ch ) : NEW_LINE INDENT ch = ch . upper ( ) NEW_LINE if ( ch == ' A ' or ch == ' E ' or ch == ' I ' or ch == ' O ' or ch == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def duplicateVowels ( S ) : NEW_LINE INDENT t = len ( S ) NEW_LINE res = \" \" NEW_LINE for i in range ( t ) : NEW_LINE INDENT if ( isVowel ( S [ i ] ) ) : NEW_LINE INDENT res += S [ i ] NEW_LINE DEDENT res += S [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT S = \" helloworld \" NEW_LINE print ( \" Original ▁ String : ▁ \" , S ) NEW_LINE res = duplicateVowels ( S ) NEW_LINE print ( \" String ▁ with ▁ Vowels ▁ duplicated : ▁ \" , res ) NEW_LINE"}
{"text": "Tukar rentetan ke integer menggunakan rekursi | Fungsi rekursif untuk menukar rentetan ke integer; Jika nombor yang diwakili sebagai rentetan hanya mengandungi satu digit, maka mengembalikan nilainya; Panggilan rekursif untuk sub -rentetan bermula pada watak kedua; Digit pertama nombor; Digit pertama didarab dengan kuasa yang sesuai 10 dan kemudian tambah hasil rekursif sebagai contoh, xy = ((x * 10) + y); Kod pemacu", "code": "def stringToInt ( str ) : NEW_LINE INDENT if ( len ( str ) == 1 ) : NEW_LINE INDENT return ord ( str [ 0 ] ) - ord ( '0' ) ; NEW_LINE DEDENT y = stringToInt ( str [ 1 : ] ) ; NEW_LINE x = ord ( str [ 0 ] ) - ord ( '0' ) ; NEW_LINE x = x * ( 10 ** ( len ( str ) - 1 ) ) + y ; NEW_LINE return int ( x ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"1235\" ; NEW_LINE print ( stringToInt ( str ) ) ; NEW_LINE DEDENT"}
{"text": "Susunan terpanjang dengan sekurang -kurangnya satu watak yang terdapat dalam setiap rentetan | Pelaksanaan Python3 pendekatan; Berfungsi untuk mengembalikan panjang sub -urutan terpanjang dengan sekurang -kurangnya satu watak biasa dalam setiap rentetan; Kira [0] akan menyimpan bilangan rentetan yang mengandungi 'A', kiraan [1] akan menyimpan bilangan rentetan yang mengandungi 'B' dan sebagainya. . ; Untuk setiap rentetan; Arus hash untuk menetapkan watak mana yang ada dalam rentetan semasa; Jika watak semasa muncul dalam rentetan maka kemas kini kiraannya; Kod pemacu", "code": "MAX = 26 NEW_LINE def largestSubSeq ( arr , n ) : NEW_LINE INDENT count = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT string = arr [ i ] NEW_LINE _hash = [ False ] * MAX NEW_LINE for j in range ( len ( string ) ) : NEW_LINE INDENT _hash [ ord ( string [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT for j in range ( MAX ) : NEW_LINE INDENT if _hash [ j ] == True : NEW_LINE INDENT count [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT return max ( count ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" ab \" , \" bc \" , \" de \" ] NEW_LINE n = len ( arr ) NEW_LINE print ( largestSubSeq ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Menjana nombor dengan operasi yang diberikan dan periksa sama ada Palindrome | Fungsi yang kembali benar jika STR adalah palindrome; Fungsi yang mengembalikan benar jika rentetan yang dihasilkan adalah palindrome; sub mengandungi n sebagai rentetan; Kirakan jumlah digit; Ulangi substring sehingga panjang rentetan yang dihasilkan <jumlah; Jika panjang rentetan yang dihasilkan melebihi jumlah maka ambil substring dari 0 hingga jumlah - 1; Jika rentetan yang dihasilkan adalah palindrome; Kod pemacu", "code": "def isPalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l // 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ l - 1 - i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT sub = \" \" + chr ( N ) NEW_LINE res_str = \" \" NEW_LINE sum = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT digit = N % 10 NEW_LINE sum += digit NEW_LINE N = N // 10 NEW_LINE DEDENT while ( len ( res_str ) < sum ) : NEW_LINE INDENT res_str += sub NEW_LINE DEDENT if ( len ( res_str ) > sum ) : NEW_LINE INDENT res_str = res_str [ 0 : sum ] NEW_LINE DEDENT if ( isPalindrome ( res_str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10101 NEW_LINE if ( createStringAndCheckPalindrome ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Kurangkan panjang rentetan dengan mengeluarkan kejadian hanya satu aksara | Berfungsi untuk mencari panjang minimum; Hitung kekerapan setiap abjad; Cari huruf dengan kekerapan maksimum; Tolak kekerapan aksara dari panjang rentetan; Kod pemacu", "code": "def minimumLength ( s ) : NEW_LINE INDENT maxOcc = 0 NEW_LINE n = len ( s ) NEW_LINE arr = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if arr [ i ] > maxOcc : NEW_LINE INDENT maxOcc = arr [ i ] NEW_LINE DEDENT DEDENT return n - maxOcc NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" afddewqd \" NEW_LINE print ( minimumLength ( str ) ) NEW_LINE DEDENT"}
{"text": "Keluarkan semua aksara selain Alphabets dari String | berfungsi untuk menghapuskan aksara dan rentetan baru PR; Mencari watak yang nilai ASCII jatuh di bawah julat ini; memadamkan fungsi untuk memadamkan watak; Kod pemacu", "code": "def removeSpecialCharacter ( s ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if ( ord ( s [ i ] ) < ord ( ' A ' ) or ord ( s [ i ] ) > ord ( ' Z ' ) and ord ( s [ i ] ) < ord ( ' a ' ) or ord ( s [ i ] ) > ord ( ' z ' ) ) : NEW_LINE INDENT del s [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( \" \" . join ( s ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? \" NEW_LINE s = [ i for i in s ] NEW_LINE removeSpecialCharacter ( s ) NEW_LINE DEDENT"}
{"text": "Keluarkan semua aksara selain Alphabets dari String | Berfungsi untuk menghapuskan watak khas dan menyimpannya dalam pembolehubah lain; Menyimpan hanya aksara yang sah; Kod pemacu", "code": "def removeSpecialCharacter ( s ) : NEW_LINE INDENT t = \" \" NEW_LINE for i in s : NEW_LINE INDENT if ( i >= ' A ' and i <= ' Z ' ) or ( i >= ' a ' and i <= ' z ' ) : NEW_LINE INDENT t += i NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT s = \" $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? \" NEW_LINE removeSpecialCharacter ( s ) NEW_LINE"}
{"text": "Cari watak berulang yang hadir terlebih dahulu dalam rentetan | Program Python3 untuk mencari watak pertama yang diulang; Ini adalah kaedah O (n ^ 2); Kod pemacu", "code": "def findRepeatFirstN2 ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT p = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( p != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE pos = findRepeatFirstN2 ( str ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" Not ▁ found \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str [ pos ] ) NEW_LINE DEDENT DEDENT"}
{"text": "Cetak watak dan frekuensi mereka mengikut urutan kejadian | Pelaksanaan Python3 untuk mencetak aksara dan frekuensi dalam rangka kejadiannya; Simpan semua watak dan frekuensi mereka dalam kamus; Cetak watak dan frekuensi mereka dalam susunan yang sama penampilan mereka; Cetak hanya jika watak ini tidak dicetak sebelum ini. ; Kod pemacu", "code": "def prCharWithFreq ( str ) : NEW_LINE INDENT d = { } NEW_LINE for i in str : NEW_LINE INDENT if i in d : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT for i in str : NEW_LINE INDENT if d [ i ] != 0 : NEW_LINE INDENT print ( \" { } { } \" . format ( i , d [ i ] ) , end = \" ▁ \" ) NEW_LINE d [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" ; NEW_LINE prCharWithFreq ( str ) ; NEW_LINE DEDENT ' NEW_LINE"}
{"text": "Kira bilangan rentetan (diperbuat daripada r, g dan b) menggunakan kombinasi yang diberikan | Berfungsi untuk mengira bilangan rentetan; Menyimpan faktorial nombor sehingga n untuk pengiraan selanjutnya; Cari nilai yang akan ditambah; Buat semua kemungkinan kombinasi R, B dan G untuk nilai yang tinggal; Kirakan permutasi setiap gabungan satu demi satu dan tambahkannya. ; Kembali Jumlah No. rentetan / permutasi; Kod pemacu", "code": "def possibleStrings ( n , r , b , g ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT left = n - ( r + g + b ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , left + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , left - i + 1 , 1 ) : NEW_LINE INDENT k = left - ( i + j ) NEW_LINE sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE r = 2 NEW_LINE b = 0 NEW_LINE g = 1 NEW_LINE print ( int ( possibleStrings ( n , r , b , g ) ) ) NEW_LINE DEDENT"}
{"text": "Keluarkan bilangan minimum aksara supaya dua rentetan menjadi anagram | Program Python 3 untuk mencari bilangan minimum aksara yang akan dikeluarkan untuk membuat dua rentetan anagram. ; fungsi untuk mengira bilangan minimum aksara yang akan dikeluarkan untuk membuat dua rentetan anagram; Buat array hash untuk kedua -dua rentetan dan hitung kekerapan setiap aksara; Mengira kekerapan setiap aksara dalam rentetan pertama; Mengira kekerapan setiap aksara dalam rentetan kedua; TRAVERSE COUNT TRAVSE untuk mencari bilangan aksara yang akan dikeluarkan; Program pemacu untuk menjalankan kes itu", "code": "CHARS = 26 NEW_LINE def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" bcadeh \" NEW_LINE str2 = \" hea \" NEW_LINE print ( remAnagram ( str1 , str2 ) ) NEW_LINE DEDENT"}
{"text": "Semak jika rentetan mempunyai semua aksara dengan kekerapan yang sama dengan satu variasi yang dibenarkan | Dengan mengandaikan hanya aksara kes yang lebih rendah; Untuk memeriksa rentetan S boleh ditukar kepada rentetan yang sah dengan mengeluarkan kurang daripada atau sama dengan satu aksara. ; Freq []: Menyimpan kekerapan setiap aksara rentetan; Cari watak pertama dengan kekerapan bukan sifar; Cari watak dengan kekerapan yang berbeza daripada Freq1. ; Jika kita mendapati kekerapan bukan sifar ketiga atau kiraan kedua -dua frekuensi menjadi lebih daripada 1, maka kembali palsu; Jika kita mencari non -nol nol ketiga; Jika tuduhan kedua -dua frekuensi lebih daripada 1; Kembali benar jika kita sampai di sini; Kod pemacu", "code": "CHARS = 26 NEW_LINE def isValidString ( str ) : NEW_LINE INDENT freq = [ 0 ] * CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT freq1 = 0 NEW_LINE count_freq1 = 0 NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT freq1 = freq [ i ] NEW_LINE count_freq1 = 1 NEW_LINE break NEW_LINE DEDENT DEDENT freq2 = 0 NEW_LINE count_freq2 = 0 NEW_LINE for j in range ( i + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ j ] != 0 ) : NEW_LINE INDENT if ( freq [ j ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1 NEW_LINE freq2 = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ k ] != 0 ) : NEW_LINE INDENT if ( freq [ k ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT if ( freq [ k ] == freq2 ) : NEW_LINE INDENT count_freq2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( count_freq1 > 1 and count_freq2 > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abcbc \" NEW_LINE if ( isValidString ( str ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Semak jika rentetan mempunyai semua aksara dengan kekerapan yang sama dengan satu variasi yang dibenarkan | Untuk memeriksa rentetan S boleh ditukar kepada rentetan variasi; Run Loop Borang 0 hingga panjang rentetan; pengisytiharan pembolehubah; jika pertama adalah benar daripada kenaikan countofval1; jika kedua adalah benar daripada kenaikan countofval2; Kod pemacu", "code": "def checkForVariation ( strr ) : NEW_LINE INDENT if ( len ( strr ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT mapp = { } NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT if strr [ i ] in mapp : NEW_LINE INDENT mapp [ strr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mapp [ strr [ i ] ] = 1 NEW_LINE DEDENT DEDENT first = True NEW_LINE second = True NEW_LINE val1 = 0 NEW_LINE val2 = 0 NEW_LINE countOfVal1 = 0 NEW_LINE countOfVal2 = 0 NEW_LINE for itr in mapp : NEW_LINE INDENT i = itr NEW_LINE if ( first ) : NEW_LINE INDENT val1 = i NEW_LINE first = False NEW_LINE countOfVal1 += 1 NEW_LINE continue NEW_LINE DEDENT if ( i == val1 ) : NEW_LINE INDENT countOfVal1 += 1 NEW_LINE continue NEW_LINE DEDENT if ( second ) : NEW_LINE INDENT val2 = i NEW_LINE countOfVal2 += 1 NEW_LINE second = False NEW_LINE continue NEW_LINE DEDENT if ( i == val2 ) : NEW_LINE INDENT countOfVal2 += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT if ( countOfVal1 > 1 and countOfVal2 > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT print ( checkForVariation ( \" abcbc \" ) ) NEW_LINE"}
{"text": "Pasangan rentetan lengkap dalam dua set rentetan | Mengembalikan kiraan pasangan lengkap dari set [0 .. n - 1] dan set2 [0 .. m - 1]; con_s1 [i] akan menyimpan integer yang set bit mewakili kehadiran / ketiadaan aksara dalam set1 [i]. Begitu juga con_s2 [i] akan menyimpan integer yang set bit mewakili kehadiran / ketiadaan aksara dalam set2 [i]; Proses semua rentetan dalam set1 []; memulakan semua bit ke 0; Menetapkan Kod ASCII Char S [i] [J] hingga 1 dalam integer yang dimampatkan. ; Proses semua rentetan dalam SET2 []; memulakan semua bit ke 0; Menetapkan Kod ASCII Char S [i] [J] hingga 1 dalam integer yang dimampatkan. ; Menetapkan pembolehubah yang semua 26 (0 ... 25) bit ditetapkan kepada 1; Sekarang pertimbangkan setiap pasangan integer dalam con_s1 [] dan con_s2 [] dan periksa sama ada pasangan itu selesai. ; Jika semua bit ditetapkan, rentetan selesai! ; Kod pemacu", "code": "def countCompletePairs ( set1 , set2 , n , m ) : NEW_LINE INDENT result = 0 NEW_LINE con_s1 , con_s2 = [ 0 ] * n , [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT con_s1 [ i ] = 0 NEW_LINE for j in range ( len ( set1 [ i ] ) ) : NEW_LINE INDENT con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( ord ( set1 [ i ] [ j ] ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT con_s2 [ i ] = 0 NEW_LINE for j in range ( len ( set2 [ i ] ) ) : NEW_LINE INDENT con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( ord ( set2 [ i ] [ j ] ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT DEDENT complete = ( 1 << 26 ) - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set1 = [ \" abcdefgh \" , \" geeksforgeeks \" , \" lmnopqrst \" , \" abc \" ] NEW_LINE set2 = [ \" ijklmnopqrstuvwxyz \" , \" abcdefghijklmnopqrstuvwxyz \" , \" defghijklmnopqrstuvwxyz \" ] NEW_LINE n = len ( set1 ) NEW_LINE m = len ( set2 ) NEW_LINE print ( countCompletePairs ( set1 , set2 , n , m ) ) NEW_LINE DEDENT"}
{"text": "Cari semua rentetan yang sepadan dengan corak tertentu dalam kamus | Fungsi untuk mengekodkan rentetan yang diberikan; Untuk setiap watak dalam rentetan yang diberikan; Sekiranya watak itu berlaku untuk kali pertama, berikan nombor unik seterusnya kepada char itu; Tambah nombor yang berkaitan dengan watak semasa ke dalam rentetan output; Berfungsi untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam corak dipetakan secara unik kepada watak dalam kamus; Len adalah panjang corak; Encode rentetan; Untuk setiap perkataan dalam pelbagai kamus; Jika saiz corak sama dengan saiz kata kamus semasa dan kedua -dua corak dan perkataan mempunyai hash yang sama, cetak perkataan; Kod pemacu", "code": "def encodeString ( Str ) : NEW_LINE INDENT map = { } NEW_LINE res = \" \" NEW_LINE i = 0 NEW_LINE for ch in Str : NEW_LINE INDENT if ch not in map : NEW_LINE INDENT map [ ch ] = i NEW_LINE i += 1 NEW_LINE DEDENT res += str ( map [ ch ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT def findMatchedWords ( dict , pattern ) : NEW_LINE INDENT Len = len ( pattern ) NEW_LINE hash = encodeString ( pattern ) NEW_LINE for word in dict : NEW_LINE INDENT if ( len ( word ) == Len and encodeString ( word ) == hash ) : NEW_LINE INDENT print ( word , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT dict = [ \" abb \" , \" abc \" , \" xyz \" , \" xyy \" ] NEW_LINE pattern = \" foo \" NEW_LINE findMatchedWords ( dict , pattern ) NEW_LINE"}
{"text": "Cari semua rentetan yang sepadan dengan corak tertentu dalam kamus | Program Python3 untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam coraknya dipetakan secara unik kepada watak dalam kamus; Berfungsi untuk mencetak semua rentetan yang sepadan dengan corak yang diberikan di mana setiap watak dalam corak dipetakan secara unik kepada watak dalam kamus; Len adalah panjang corak; Untuk setiap perkataan dalam kamus; Kod pemacu", "code": "def check ( pattern , word ) : NEW_LINE INDENT if ( len ( pattern ) != len ( word ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT ch = [ 0 for i in range ( 128 ) ] NEW_LINE Len = len ( word ) NEW_LINE for i in range ( Len ) : NEW_LINE INDENT if ( ch [ ord ( pattern [ i ] ) ] == 0 ) : NEW_LINE INDENT ch [ ord ( pattern [ i ] ) ] = word [ i ] NEW_LINE DEDENT elif ( ch [ ord ( pattern [ i ] ) ] != word [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findMatchedWords ( Dict , pattern ) : NEW_LINE INDENT Len = len ( pattern ) NEW_LINE for word in range ( len ( Dict ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( check ( pattern , Dict [ word ] ) ) : NEW_LINE INDENT print ( Dict [ word ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT Dict = [ \" abb \" , \" abc \" , \" xyz \" , \" xyy \" ] NEW_LINE pattern = \" foo \" NEW_LINE findMatchedWords ( Dict , pattern ) NEW_LINE"}
{"text": "Kira perkataan dalam rentetan yang diberikan | Berfungsi untuk mengira jumlah perkataan dalam rentetan; Semak sama ada rentetan itu batal atau kosong kemudian kembali sifar; Menukar rentetan yang diberikan ke dalam array watak; Semak sama ada watak itu adalah huruf dan indeks array aksara tidak sama dengan akhir garis yang bermaksud, ia adalah perkataan dan set isword dengan benar; Semak sama ada watak itu bukan surat yang bermaksud terdapat ruang, maka kami menambah kata -kata dengan satu dan tetapkan isword dengan palsu; Semak perkataan terakhir ayat dan kenaikan kata WordCount oleh satu; Kembalikan jumlah perkataan dalam rentetan; Diberikan string str; Cetak hasilnya", "code": "def countWords ( Str ) : NEW_LINE INDENT if ( Str == None or len ( Str ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT wordCount = 0 NEW_LINE isWord = False NEW_LINE endOfLine = len ( Str ) - 1 NEW_LINE ch = list ( Str ) NEW_LINE for i in range ( len ( ch ) ) : NEW_LINE INDENT if ( ch [ i ] . isalpha ( ) and i != endOfLine ) : NEW_LINE INDENT isWord = True NEW_LINE DEDENT elif ( not ch [ i ] . isalpha ( ) and isWord ) : NEW_LINE INDENT wordCount += 1 NEW_LINE isWord = False NEW_LINE DEDENT elif ( ch [ i ] . isalpha ( ) and i == endOfLine ) : NEW_LINE INDENT wordCount += 1 NEW_LINE DEDENT DEDENT return wordCount NEW_LINE DEDENT Str =   \" One two three NEW_LINE INDENT four five   \" NEW_LINE DEDENT print ( \" No ▁ of ▁ words ▁ : \" , countWords ( Str ) ) NEW_LINE"}
{"text": "Kata -kata terbalik dalam rentetan yang diberikan | Membalikkan rentetan; Semak sama ada bilangan perkataan walaupun; Cari perkataan tengah; Bermula dari pertengahan mula menukar kata -kata di kedudukan jth dan kedudukan l - 1 - j; Semak sama ada bilangan perkataan adalah ganjil; Cari perkataan tengah; Bermula dari pertengahan mula menukar kata -kata di kedudukan jth dan kedudukan l - 1 - j; mengembalikan kalimat terbalik; Kod pemacu", "code": "def RevString ( s , l ) : NEW_LINE INDENT if l % 2 == 0 : NEW_LINE INDENT j = int ( l / 2 ) NEW_LINE while ( j <= l - 1 ) : NEW_LINE s [ j ] , s [ l - j - 1 ] = s [ l - j - 1 ] , s [ j ] NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j = int ( l / 2 + 1 ) NEW_LINE while ( j <= l - 1 ) : NEW_LINE s [ j ] , s [ l - 1 - j ] = s [ l - j - 1 ] , s [ j ] NEW_LINE j += 1 NEW_LINE return s ; NEW_LINE DEDENT DEDENT s = ' getting ▁ good ▁ at ▁ coding ▁ needs ▁ a ▁ lot ▁ of ▁ practice ' NEW_LINE string = s . split ( ' ▁ ' ) NEW_LINE string = RevString ( string , len ( string ) ) NEW_LINE print ( \" ▁ \" . join ( string ) ) NEW_LINE"}
{"text": "Laluan cetak dari akar ke semua nod dalam pokok binari yang lengkap | Berfungsi untuk mencetak laluan semua nod nth node mewakili sebagai node node node yang diberikan mewakili sebagai nod kiri dan kanan; Keadaan asas jika nilai nod kth lebih besar maka nod nth maka nod kth bermakna tidak sah sehingga kami tidak menyimpannya ke dalam res hanya kami hanya kembali; Menyimpan nod ke res; Cetak jalan dari akar ke nod; Simpan jalan kiri pokok supaya kiri kita akan pergi nod (kthNode * 2); Jalan kanan pokok dan untuk betul kita akan pergi nod (kthnode * 2 + 1); Berfungsi untuk mencetak laluan dari akar ke semua nod; Res adalah untuk menyimpan jalan dari akar ke nod partikulat; Cetak jalan dari akar ke semua nod. Hujah ketiga 1 kerana kita perlu mempertimbangkan nod akar adalah 1; Kod pemacu; Diberikan nod; Cetak jalan dari akar ke semua nod.", "code": "def printPath ( res , nThNode , kThNode ) : NEW_LINE INDENT if kThNode > nThNode : NEW_LINE INDENT return NEW_LINE DEDENT res . append ( kThNode ) NEW_LINE for i in range ( 0 , len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE printPath ( res [ : ] , nThNode , kThNode * 2 ) NEW_LINE printPath ( res [ : ] , nThNode , kThNode * 2 + 1 ) NEW_LINE DEDENT def printPathToCoverAllNodeUtil ( nThNode ) : NEW_LINE INDENT res = [ ] NEW_LINE printPath ( res , nThNode , 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT nThNode = 7 NEW_LINE printPathToCoverAllNodeUtil ( nThNode ) NEW_LINE DEDENT"}
{"text": "Array Range Queries Untuk Mencari Nombor Armstrong Maksimum dengan Kemas Kini | Kod python untuk melaksanakan pendekatan di atas; Fungsi utiliti untuk mendapatkan indeks pertengahan julat yang diberikan. ; Fungsi yang kembali benar jika num adalah armstrong lain kembali palsu; Fungsi rekursif untuk mendapatkan jumlah nilai dalam julat array yang diberikan. Berikut adalah parameter untuk fungsi ini. ST -> Pointer ke Segmen Tree Node -> Indeks nod semasa dalam pokok segmen. SS & SE -> Memulakan dan mengakhiri indeks segmen yang diwakili oleh nod semasa, i. e. , St [nod] L & R -> Memulakan dan menamatkan indeks pertanyaan pelbagai; Jika segmen nod ini benar -benar sebahagian daripada julat yang diberikan, maka kembalikan segmen maksimum. ; Jika segmen nod ini tidak tergolong dalam julat yang diberikan; Jika segmen nod ini sebahagiannya adalah sebahagian daripada julat yang diberikan; Fungsi rekursif untuk mengemas kini nod yang telah diberikan indeks dalam julatnya. Berikut adalah parameter ST, SS dan SE adalah sama seperti yang ditakrifkan di atas indeks -> indeks elemen yang akan dikemas kini. ; nilai kemas kini dalam array dan dalam pokok segmen; Kembalikan max elemen dalam julat dari indeks l (pertanyaan permulaan) ke r (ujung pertanyaan). ; Semak nilai input yang salah; Fungsi rekursif yang membina pokok segmen untuk array [ss. . se]. Si adalah indeks nod semasa dalam segmen Tree St; Jika terdapat satu elemen dalam array, simpannya dalam nod semasa pokok segmen dan kembali; Sekiranya terdapat lebih daripada satu elemen, maka berulang untuk subtrees kiri dan kanan dan simpan nilai maksimum dalam nod ini; Fungsi untuk membina pokok segmen dari array yang diberikan. Fungsi ini memperuntukkan memori untuk pokok segmen. ; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan ST; Mengembalikan pokok segmen yang dibina; Kod pemacu; Membina pokok segmen dari array yang diberikan; Cetak maksimum nilai dalam array dari indeks 1 hingga 3; Kemas kini: Tetapkan ARR [1] = 153 dan kemas kini nod pokok segmen yang sepadan. ; Cari max selepas nilai dikemas kini", "code": "import math NEW_LINE def getMid ( s : int , e : int ) -> int : NEW_LINE INDENT return s + ( e - s ) // 2 NEW_LINE DEDENT def isArmstrong ( x : int ) -> bool : NEW_LINE INDENT n = len ( str ( x ) ) NEW_LINE sum1 = 0 NEW_LINE temp = x NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += pow ( digit , n ) NEW_LINE temp //= 10 NEW_LINE DEDENT if ( sum1 == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def MaxUtil ( st , ss , se , l , r , node ) : NEW_LINE INDENT if ( l <= ss and r >= se ) : NEW_LINE INDENT return st [ node ] NEW_LINE DEDENT if ( se < l or ss > r ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) NEW_LINE DEDENT def updateValue ( arr , st , ss , se , index , value , node ) : NEW_LINE INDENT if ( index < ss or index > se ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT if ( ss == se ) : NEW_LINE INDENT arr [ index ] = value NEW_LINE if ( isArmstrong ( value ) ) : NEW_LINE INDENT st [ node ] = value NEW_LINE DEDENT else : NEW_LINE INDENT st [ node ] = - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT mid = getMid ( ss , se ) NEW_LINE if ( index >= ss and index <= mid ) : NEW_LINE INDENT updateValue ( arr , st , ss , mid , index , value , 2 * node + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT updateValue ( arr , st , mid + 1 , se , index , value , 2 * node + 2 ) NEW_LINE DEDENT st [ node ] = max ( st [ 2 * node + 1 ] , st [ 2 * node + 2 ] ) NEW_LINE DEDENT return NEW_LINE DEDENT def getMax ( st , n , l , r ) : NEW_LINE INDENT if ( l < 0 or r > n - 1 or l > r ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) NEW_LINE DEDENT def constructSTUtil ( arr , ss , se , st , si ) : NEW_LINE INDENT if ( ss == se ) : NEW_LINE INDENT if ( isArmstrong ( arr [ ss ] ) ) : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE DEDENT else : NEW_LINE INDENT st [ si ] = - 1 NEW_LINE DEDENT return st [ si ] NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE st [ si ] = max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) NEW_LINE return st [ si ] NEW_LINE DEDENT def constructST ( arr , n ) : NEW_LINE INDENT x = int ( math . ceil ( math . log2 ( n ) ) ) NEW_LINE max_size = 2 * int ( math . pow ( 2 , x ) ) - 1 NEW_LINE st = [ 0 for _ in range ( max_size ) ] NEW_LINE constructSTUtil ( arr , 0 , n - 1 , st , 0 ) NEW_LINE return st NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 192 , 113 , 535 , 7 , 19 , 111 ] NEW_LINE n = len ( arr ) NEW_LINE st = constructST ( arr , n ) NEW_LINE print ( \" Maximum ▁ armstrong ▁ number ▁ in ▁ given ▁ range ▁ = ▁ { } \" . format ( getMax ( st , n , 1 , 3 ) ) ) NEW_LINE updateValue ( arr , st , 0 , n - 1 , 1 , 153 , 0 ) NEW_LINE print ( \" Updated ▁ Maximum ▁ armstrong ▁ number ▁ in ▁ given ▁ range ▁ = ▁ { } \" . format ( getMax ( st , n , 1 , 3 ) ) ) NEW_LINE DEDENT"}
{"text": "Bilangan maksimum rantau di mana n non | Berfungsi untuk mencari bilangan maksimum kawasan di atas kapal terbang; Cetak bilangan maksimum kawasan; Kod pemacu", "code": "def maxRegions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) // 2 + 1 NEW_LINE print ( num ) NEW_LINE DEDENT n = 10 NEW_LINE maxRegions ( n ) NEW_LINE"}
{"text": "Semak sama ada teka -teki jigsaw boleh diselesaikan atau tidak | Berfungsi untuk memeriksa sama ada teka -teki jigsaw boleh diselesaikan atau tidak; Kes asas; Dengan meletakkan tab kosong sebagai rantai; Kod pemacu", "code": "def checkSolveable ( n , m ) : NEW_LINE INDENT if n == 1 or m == 1 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif m == 2 and n == 2 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1 NEW_LINE m = 3 NEW_LINE checkSolveable ( n , m ) NEW_LINE DEDENT"}
{"text": "Semak sama ada mungkin untuk mencapai (x, y) dari (1, 0) dengan langkah -langkah yang diberikan | Berfungsi untuk mencari GCD dua nombor A dan B; Kes asas; Recursif mencari GCD; Fungsi untuk memeriksa sama ada (x, y) boleh dicapai dari (1, 0) dari langkah yang diberikan; Jika GCD adalah 1, maka PR \"ya\"; Kod pemacu; Diberikan x dan y; Panggilan fungsi", "code": "def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return GCD ( b , a % b ) NEW_LINE DEDENT DEDENT def check ( x , y ) : NEW_LINE INDENT if ( GCD ( x , y ) == 1 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 2 NEW_LINE Y = 7 NEW_LINE check ( X , Y ) NEW_LINE DEDENT"}
{"text": "Kebarangkalian fungsi ketat Euler dalam julat [l, r] untuk dibahagikan dengan m | Program Python3 untuk melaksanakan pendekatan di atas; Seieve of erotosthenes untuk mengira semua prima; Jika Perdana; Tandakan semua gandaannya sebagai bukan perdana; Fungsi untuk mencari kebarangkalian fungsi ketat Euler dalam julat tertentu; Memulakan dua tatasusunan dengan nilai dari L ke R untuk Totient Euler; Pengindeksan dari 0; Jika nombor semasa adalah perdana; Memeriksa jika saya adalah faktor utama nombor dalam julat l ke r; Kemas kini semua nombor yang mempunyai faktor utama i; Jika nombor dalam julat mempunyai faktor utama> matematik. sqrt (nombor); Hitung mereka yang boleh dibahagikan dengan m; Mengembalikan hasilnya; Kod pemacu", "code": "size = 1000001 NEW_LINE def seiveOfEratosthenes ( prime ) : NEW_LINE INDENT prime [ 0 ] = 1 NEW_LINE prime [ 1 ] = 0 NEW_LINE i = 2 NEW_LINE while ( i * i < 1000001 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j < 1000001 ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE j = j + i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def probabiltyEuler ( prime , L , R , M ) : NEW_LINE INDENT arr = [ 0 ] * size NEW_LINE eulerTotient = [ 0 ] * size NEW_LINE count = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT eulerTotient [ i - L ] = i NEW_LINE arr [ i - L ] = i NEW_LINE DEDENT for i in range ( 2 , 1000001 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( ( L // i ) * i , R + 1 , i ) : NEW_LINE INDENT if ( j - L >= 0 ) : NEW_LINE INDENT eulerTotient [ j - L ] = ( eulerTotient [ j - L ] // i * ( i - 1 ) ) NEW_LINE while ( arr [ j - L ] % i == 0 ) : NEW_LINE INDENT arr [ j - L ] = arr [ j - L ] // i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( arr [ i - L ] > 1 ) : NEW_LINE INDENT eulerTotient [ i - L ] = ( ( eulerTotient [ i - L ] // arr [ i - L ] ) * ( arr [ i - L ] - 1 ) ) NEW_LINE DEDENT DEDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( ( eulerTotient [ i - L ] % M ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( float ) ( 1.0 * count / ( R + 1 - L ) ) NEW_LINE DEDENT prime = [ 0 ] * size NEW_LINE seiveOfEratosthenes ( prime ) NEW_LINE L , R , M = 1 , 7 , 3 NEW_LINE print ( probabiltyEuler ( prime , L , R , M ) ) NEW_LINE"}
{"text": "Permainan pembahagi ganjil terbesar untuk memeriksa pemain mana yang menang | Pelaksanaan Python3 untuk mencari permainan pembahagi ganjil terbesar untuk memeriksa pemain mana yang menang; Berfungsi untuk mencari permainan pembahagi ganjil terbesar untuk memeriksa pemain mana yang menang; Semak jika n == 1 maka pemain 2 akan menang; Semak jika n == 2 atau n adalah ganjil; Manakala n lebih besar daripada k dan dibahagikan dengan 2 terus meningkatkan val; Gelung untuk mencari pembahagi ganjil yang paling hebat; Periksa sama ada n adalah kuasa 2; Semak sama ada CNT bukanlah pemain yang menang 1; Kod pemacu", "code": "import math NEW_LINE def findWinner ( n , k ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT elif ( ( n & 1 ) or n == 2 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT tmp = n ; NEW_LINE val = 1 ; NEW_LINE while ( tmp > k and tmp % 2 == 0 ) : NEW_LINE INDENT tmp //= 2 ; NEW_LINE val *= 2 ; NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( tmp ) ) + 1 ) : NEW_LINE INDENT while ( tmp % i == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE tmp //= i ; NEW_LINE DEDENT DEDENT if ( tmp > 1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT if ( val == n ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT elif ( n / tmp == 2 and cnt == 1 ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1 ; k = 1 ; NEW_LINE findWinner ( n , k ) ; NEW_LINE DEDENT"}
{"text": "Cari semua nombor sehingga N yang kedua -dua pentagonal dan heksagon | Program Python3 pendekatan di atas; Berfungsi untuk mencetak nombor sehingga kedua -dua pentagonal dan nombor heksagon; Kirakan nombor pentagonal saya; Semak sama ada nombor pentagonal PN adalah heksagon atau tidak; Kod pemacu", "code": "import math NEW_LINE def pen_hex ( n ) : NEW_LINE INDENT pn = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pn = ( int ) ( i * ( 3 * i - 1 ) / 2 ) NEW_LINE if ( pn > n ) : NEW_LINE INDENT break NEW_LINE DEDENT seqNum = ( 1 + math . sqrt ( 8 * pn + 1 ) ) / 4 NEW_LINE if ( seqNum == ( int ) ( seqNum ) ) : NEW_LINE INDENT print ( pn , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT N = 1000000 NEW_LINE pen_hex ( N ) NEW_LINE"}
{"text": "Semak jika baris | Fungsi untuk memeriksa sama ada baris - perintah utama traversal matriks adalah palindrome; Gelung untuk memeriksa sama ada matriks adalah matriks adalah palindrome atau tidak; Kod pemacu", "code": "def isPal ( a , n , m ) : NEW_LINE INDENT for i in range ( 0 , n // 2 ) : NEW_LINE INDENT for j in range ( 0 , m - 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE m = 3 ; NEW_LINE a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 4 ] , [ 3 , 2 , 1 ] ] ; NEW_LINE if ( isPal ( a , n , m ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"}
{"text": "Cari nombor terkecil yang jumlah digitnya adalah n | Berfungsi untuk mendapatkan jumlah digit; Berfungsi untuk mencari nombor terkecil yang jumlah digit juga n; Memeriksa jika nombor mempunyai jumlah digit = n; Kod pemacu", "code": "def getSum ( n ) : NEW_LINE INDENT sum1 = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum1 = sum1 + n % 10 ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return sum1 ; NEW_LINE DEDENT def smallestNumber ( N ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( getSum ( i ) == N ) : NEW_LINE INDENT print ( i ) ; NEW_LINE break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT N = 10 ; NEW_LINE smallestNumber ( N ) ; NEW_LINE"}
{"text": "Nombor jarang | Pelaksanaan Python3 untuk memeriksa sama ada N adalah nombor yang jarang berlaku; Fungsi berulang untuk membalikkan digit NUM; Fungsi untuk memeriksa sama ada N adalah persegi sempurna; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Fungsi untuk memeriksa sama ada n adalah nombor yang jarang berlaku; Cari terbalik n; Nombor harus bukan palindromic; Kod pemacu", "code": "import math NEW_LINE def reversDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - int ( sr ) ) == 0 ) NEW_LINE DEDENT def isRare ( N ) : NEW_LINE INDENT reverseN = reversDigits ( N ) NEW_LINE if ( reverseN == N ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( isPerfectSquare ( N + reverseN ) and isPerfectSquare ( N - reverseN ) ) NEW_LINE DEDENT N = 65 NEW_LINE if ( isRare ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Kira nombor dari julat yang faktor utama hanya 2 dan 3 menggunakan tatasusunan | Tetapkan 2 | Fungsi yang akan mengira unsur -unsur dalam julat yang diberikan; Simpan kuasa semasa 2; Simpan kuasa semasa 3; Power23 [] akan menyimpan produk pasangan unsur -unsur Power2 dan Power3 yang <= r; Masukkan dalam Power23] [] hanya jika Mul <= r; Simpan jawapan yang diperlukan; Cetak hasilnya; Kod pemacu", "code": "def calc_ans ( l , r ) : NEW_LINE INDENT power2 = [ ] ; power3 = [ ] ; NEW_LINE mul2 = 1 ; NEW_LINE while ( mul2 <= r ) : NEW_LINE INDENT power2 . append ( mul2 ) ; NEW_LINE mul2 *= 2 ; NEW_LINE DEDENT mul3 = 1 ; NEW_LINE while ( mul3 <= r ) : NEW_LINE INDENT power3 . append ( mul3 ) ; NEW_LINE mul3 *= 3 ; NEW_LINE DEDENT power23 = [ ] ; NEW_LINE for x in range ( len ( power2 ) ) : NEW_LINE INDENT for y in range ( len ( power3 ) ) : NEW_LINE INDENT mul = power2 [ x ] * power3 [ y ] ; NEW_LINE if ( mul == 1 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( mul <= r ) : NEW_LINE INDENT power23 . append ( mul ) ; NEW_LINE DEDENT DEDENT DEDENT ans = 0 ; NEW_LINE for x in power23 : NEW_LINE INDENT if ( x >= l and x <= r ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1 ; r = 10 ; NEW_LINE calc_ans ( l , r ) ; NEW_LINE DEDENT"}
{"text": "Count k panjangnya yang produknya juga | Fungsi untuk mengira NCR; Mengembalikan faktorial n; Fungsi untuk mencari bilangan Kekuatan panjang K yang produknya adalah bilangannya; Mengira nombor ganjil dalam array; Kod pemacu", "code": "def nCr ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def countSubsequences ( arr , n , k ) : NEW_LINE INDENT countOdd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT countOdd += 1 ; NEW_LINE DEDENT DEDENT ans = nCr ( n , k ) - nCr ( countOdd , k ) ; NEW_LINE return ans NEW_LINE DEDENT arr = [ 2 , 4 ] NEW_LINE K = 1 NEW_LINE N = len ( arr ) NEW_LINE print ( countSubsequences ( arr , N , K ) ) NEW_LINE"}
{"text": "Cari bit yang paling ketara dari nombor x dalam asas y | Program Python3 untuk mencari digit pertama X dalam asas y; Berfungsi untuk mencari digit pertama x dalam asas y; Mengira bilangan digit x dalam asas y; Mencari digit pertama X dalam asas y; Kod pemacu", "code": "import math NEW_LINE def first_digit ( x , y ) : NEW_LINE INDENT length = int ( math . log ( x ) / math . log ( y ) + 1 ) NEW_LINE first_digit = x / math . pow ( y , length - 1 ) NEW_LINE print ( int ( first_digit ) ) NEW_LINE DEDENT X = 55 NEW_LINE Y = 3 NEW_LINE first_digit ( X , Y ) NEW_LINE"}
{"text": "Nombor Curzon | Berfungsi untuk memeriksa sama ada nombor adalah nombor curzon atau tidak; Cari 2 ^ n + 1; Cari 2 * n + 1; Semak untuk pembahagian; Kod pemacu", "code": "def checkIfCurzonNumber ( N ) : NEW_LINE INDENT powerTerm , productTerm = 0 , 0 NEW_LINE powerTerm = pow ( 2 , N ) + 1 NEW_LINE productTerm = 2 * N + 1 NEW_LINE if ( powerTerm % productTerm == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE checkIfCurzonNumber ( N ) NEW_LINE N = 10 NEW_LINE checkIfCurzonNumber ( N ) NEW_LINE DEDENT"}
{"text": "Kiraan minimum nombor yang diperlukan berakhir dengan 7 hingga jumlah sebagai nombor tertentu | Fungsi untuk mengembalikan kiraan nombor minimum yang berakhir dengan 7 yang diperlukan supaya jumlah nombor ini adalah n; Hasharr [i] akan menyimpan nombor minimum yang berakhir dengan 7 supaya ia merangkumi jumlah yang berakhir dengan Digit I; Ia sentiasa mungkin untuk menulis nombor> 69 untuk menulis sebagai nombor yang berakhir dengan 7; Jika nombor itu sama dengan jumlah nombor minimum yang berakhir dengan 7; Kod pemacu", "code": "def minCount ( n ) : NEW_LINE INDENT hasharr = [ 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 ] NEW_LINE if ( n > 69 ) : NEW_LINE INDENT return hasharr [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( n >= hasharr [ n % 10 ] * 7 ) : NEW_LINE INDENT return hasharr [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT n = 38 ; NEW_LINE print ( minCount ( n ) ) NEW_LINE"}
{"text": "Program untuk mencetak corak segitiga binari yang diubahsuai | Berfungsi untuk mencetak corak binari yang diubah suai; Gelung untuk melintasi baris; Gelung untuk melintasi nombor dalam setiap baris; Periksa sama ada J adalah 1 atau saya dalam cetakan kes 1; Lain cetak 0; Tukar kursor ke baris seterusnya selepas setiap baris; Kod pemacu; Panggilan fungsi", "code": "def modifiedBinaryPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 , 1 ) : NEW_LINE INDENT if ( j == 1 or j == i ) : NEW_LINE INDENT print ( 1 , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ' ' , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE modifiedBinaryPattern ( n ) NEW_LINE DEDENT"}
{"text": "Cari bahagian sebenar dan khayalan nombor kompleks | Berfungsi untuk mencari bahagian sebenar dan khayalan nombor kompleks; panjang rentetan yang disimpan dalam pembolehubah L; pembolehubah untuk indeks pemisah; Menyimpan indeks '+; lain menyimpan indeks '-; Mencari bahagian sebenar nombor kompleks; Mencari bahagian khayalan nombor kompleks; Kod pemacu", "code": "def findRealAndImag ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE DEDENT ' NEW_LINE INDENT if ( s . find ( ' + ' ) != - 1 ) : NEW_LINE INDENT i = s . find ( ' + ' ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT else : NEW_LINE INDENT i = s . find ( ' - ' ) ; NEW_LINE DEDENT real = s [ : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE print ( \" Real ▁ part : \" , real ) NEW_LINE print ( \" Imaginary ▁ part : \" , imaginary ) NEW_LINE DEDENT s = \"3 + 4i \" ; NEW_LINE findRealAndImag ( s ) ; NEW_LINE"}
{"text": "Kuasa yang berbeza dari nombor n supaya jumlahnya sama dengan k | Pelaksanaan Python 3 untuk mencari kuasa yang berbeza N yang menambah sehingga k; Berfungsi untuk mengembalikan kuasa tertinggi n tidak melebihi k; Gelung untuk mencari kuasa tertinggi kurang daripada k; Memulakan PowerArray dengan semua 0. ; Berfungsi untuk mencetak kuasa yang berbeza n yang menambah sehingga k; Mendapatkan kuasa tertinggi N sebelum k; Untuk memeriksa sama ada kuasa digunakan dua kali atau tidak; Cetak - 1 jika kuasa digunakan dua kali; Jika kuasa tidak dikunjungi, maka tandakan kuasa seperti yang dikunjungi; Menurunkan nilai k; Mencetak kuasa N yang merangkumi K; Kod pemacu", "code": "from math import pow NEW_LINE def highestPower ( n , k ) : NEW_LINE INDENT i = 0 NEW_LINE a = pow ( n , i ) NEW_LINE while ( a <= k ) : NEW_LINE INDENT i += 1 NEW_LINE a = pow ( n , i ) NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT b = [ 0 for i in range ( 50 ) ] NEW_LINE def PowerArray ( n , k ) : NEW_LINE INDENT while ( k ) : NEW_LINE INDENT t = highestPower ( n , k ) NEW_LINE if ( b [ t ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT b [ t ] = 1 NEW_LINE DEDENT k -= pow ( n , t ) NEW_LINE DEDENT for i in range ( 50 ) : NEW_LINE INDENT if ( b [ i ] ) : NEW_LINE INDENT print ( i , end = ' , ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE K = 40 NEW_LINE PowerArray ( N , K ) NEW_LINE DEDENT"}
{"text": "Jumlah elemen dalam array yang mempunyai kekerapan komposit | Program Python3 untuk mencari jumlah elemen dalam array yang mempunyai kekerapan komposit; Berfungsi untuk membuat ayak untuk memeriksa prima; Jika komposit [p] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada komposit; Berfungsi untuk mengembalikan jumlah elemen dalam array yang mempunyai kekerapan komposit; Peta digunakan untuk menyimpan frekuensi elemen; Untuk menyimpan jumlah; Melintasi peta menggunakan iterators; Kira bilangan elemen yang mempunyai frekuensi komposit; Kod pemacu; Panggilan fungsi", "code": "N = 100005 NEW_LINE def SieveOfEratosthenes ( composite ) : NEW_LINE INDENT for p in range ( 2 , N ) : NEW_LINE INDENT if p * p > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( composite [ p ] == False ) : NEW_LINE INDENT for i in range ( 2 * p , N , p ) : NEW_LINE INDENT composite [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumOfElements ( arr , n ) : NEW_LINE INDENT composite = [ False ] * N NEW_LINE SieveOfEratosthenes ( composite ) NEW_LINE m = dict ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT sum = 0 NEW_LINE for it in m : NEW_LINE INDENT if ( composite [ m [ it ] ] ) : NEW_LINE INDENT sum += ( it ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 1 , 1 , 3 , 3 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumOfElements ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Padam semua elemen kekerapan ganjil dari array | Fungsi yang menghilangkan unsur -unsur yang mempunyai frekuensi ganjil dalam array; Buat peta untuk menyimpan kekerapan setiap elemen; Keluarkan unsur -unsur yang mempunyai frekuensi ganjil; Jika elemen mempunyai kekerapan ganjil maka lompat; Kod pemacu; Panggilan fungsi", "code": "def remove ( arr , n ) : NEW_LINE INDENT m = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( ( m [ arr [ i ] ] & 1 ) ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT print ( arr [ i ] , end = \" , ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE remove ( arr , n ) ; NEW_LINE DEDENT"}
{"text": "Memaksimumkan elemen pertama array supaya purata tetap tetap | Nilai maksimum elemen array pertama yang boleh dicapai; Pembolehubah untuk menyimpan jumlahnya; Gelung untuk mencari jumlah array; Nilai maksimum yang dikehendaki; Kod pemacu", "code": "def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT"}
{"text": "Panjang minimum laluan terpendek segitiga | berfungsi untuk mendapatkan panjang minimum bahagian yang lebih pendek dari segitiga; melintasi setiap mata di atas kapal terbang; Jika jumlah mata lebih besar daripada yang sebelumnya, maksimum akan diganti; Cetak panjang; Kod pemacu; memulakan bilangan mata; mata di kapal terbang", "code": "def shortestLength ( n , x , y ) : NEW_LINE INDENT answer = 0 NEW_LINE i = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if ( x [ i ] + y [ i ] > answer ) : NEW_LINE INDENT answer = x [ i ] + y [ i ] NEW_LINE DEDENT i += 1 NEW_LINE n -= 1 NEW_LINE DEDENT print ( \" Length ▁ - > ▁ \" + str ( answer ) ) NEW_LINE print ( \" Path ▁ - > ▁ \" + \" ( ▁ 1 , ▁ \" + str ( answer ) + \" ▁ ) \" + \" and ▁ ( ▁ \" + str ( answer ) + \" , ▁ 1 ▁ ) \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE x = [ 1 , 4 , 2 , 1 ] NEW_LINE y = [ 4 , 1 , 1 , 2 ] NEW_LINE shortestLength ( n , x , y ) NEW_LINE DEDENT"}
{"text": "Berpotongan segi empat tepat apabila bawah | berfungsi untuk mencari persegi persegi persegi dua segi empat tepat. ; memberikan titik kiri bawah persegi persegi persegi; memberikan titik kanan persegi persegi persegi; tiada persimpangan; memberikan titik kiri atas persegi persegi persegi; memberikan titik bawah persegi persegi persegi; Kod pemacu; bawah - kiri dan atas - sudut kanan segi empat tepat pertama; bawah - kiri dan atas - sudut kanan segi empat tepat pertama; panggilan fungsi", "code": "def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y1 , y3 ) NEW_LINE x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE if ( x5 > x6 or y5 > y6 ) : NEW_LINE INDENT print ( \" No ▁ intersection \" ) NEW_LINE return NEW_LINE DEDENT print ( \" ( \" , x5 , \" , ▁ \" , y5 , \" ) ▁ \" , end = \" ▁ \" ) NEW_LINE print ( \" ( \" , x6 , \" , ▁ \" , y6 , \" ) ▁ \" , end = \" ▁ \" ) NEW_LINE x7 = x5 NEW_LINE y7 = y6 NEW_LINE print ( \" ( \" , x7 , \" , ▁ \" , y7 , \" ) ▁ \" , end = \" ▁ \" ) NEW_LINE x8 = x6 NEW_LINE y8 = y5 NEW_LINE print ( \" ( \" , x8 , \" , ▁ \" , y8 , \" ) ▁ \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 10 NEW_LINE y2 = 8 NEW_LINE x3 = 2 NEW_LINE y3 = 3 NEW_LINE x4 = 7 NEW_LINE y4 = 9 NEW_LINE FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) NEW_LINE DEDENT"}
{"text": "Cari Sudut Rectangle Menggunakan Poin Mid | Program Python3 untuk mencari titik sudut segi empat tepat menggunakan titik panjang dan tengah yang diberikan. ; Struktur untuk mewakili titik co -ordinate; Fungsi ini menerima dua mata dan panjang sisi segi empat tepat dan mencetak titik 4 sudut segi empat tepat; Rectangle mendatar; Segi empat tepat menegak; Segi empat tepat; Hitung cerun sisi; Kirakan anjakan di sepanjang paksi; Kod pemacu", "code": "import math NEW_LINE class Point : NEW_LINE INDENT def __init__ ( self , a = 0 , b = 0 ) : NEW_LINE INDENT self . x = a NEW_LINE self . y = b NEW_LINE DEDENT DEDENT def printCorners ( p , q , l ) : NEW_LINE INDENT a , b , c , d = Point ( ) , Point ( ) , Point ( ) , Point ( ) NEW_LINE if ( p . x == q . x ) : NEW_LINE INDENT a . x = p . x - ( l / 2.0 ) NEW_LINE a . y = p . y NEW_LINE d . x = p . x + ( l / 2.0 ) NEW_LINE d . y = p . y NEW_LINE b . x = q . x - ( l / 2.0 ) NEW_LINE b . y = q . y NEW_LINE c . x = q . x + ( l / 2.0 ) NEW_LINE c . y = q . y NEW_LINE DEDENT elif ( p . y == q . y ) : NEW_LINE INDENT a . y = p . y - ( l / 2.0 ) NEW_LINE a . x = p . x NEW_LINE d . y = p . y + ( l / 2.0 ) NEW_LINE d . x = p . x NEW_LINE b . y = q . y - ( l / 2.0 ) NEW_LINE b . x = q . x NEW_LINE c . y = q . y + ( l / 2.0 ) NEW_LINE c . x = q . x NEW_LINE DEDENT else : NEW_LINE INDENT m = ( p . x - q . x ) / ( q . y - p . y ) NEW_LINE dx = ( l / math . sqrt ( 1 + ( m * m ) ) ) * 0.5 NEW_LINE dy = m * dx NEW_LINE a . x = p . x - dx NEW_LINE a . y = p . y - dy NEW_LINE d . x = p . x + dx NEW_LINE d . y = p . y + dy NEW_LINE b . x = q . x - dx NEW_LINE b . y = q . y - dy NEW_LINE c . x = q . x + dx NEW_LINE c . y = q . y + dy NEW_LINE DEDENT print ( int ( a . x ) , \" , ▁ \" , int ( a . y ) , sep = \" \" ) NEW_LINE print ( int ( b . x ) , \" , ▁ \" , int ( b . y ) , sep = \" \" ) NEW_LINE print ( int ( c . x ) , \" , ▁ \" , int ( c . y ) , sep = \" \" ) NEW_LINE print ( int ( d . x ) , \" , ▁ \" , int ( d . y ) , sep = \" \" ) NEW_LINE print ( ) NEW_LINE DEDENT p1 = Point ( 1 , 0 ) NEW_LINE q1 = Point ( 1 , 2 ) NEW_LINE printCorners ( p1 , q1 , 2 ) NEW_LINE p = Point ( 1 , 1 ) NEW_LINE q = Point ( - 1 , - 1 ) NEW_LINE printCorners ( p , q , 2 * math . sqrt ( 2 ) ) NEW_LINE"}
{"text": "Kurangkan kos untuk mengubah suai array sedemikian rupa sehingga indeks mempunyai unsur -unsur dan sebaliknya | Berfungsi untuk mencari kos minimum untuk mengubah suai array mengikut kriteria yang diberikan; Mengira kedudukan yang salah dan juga unsur -unsur; Kiraan ganjil; Malah mengira; Kos menukar; Menurun kos selepas bertukar; Hanya pengurangan kos; Mengembalikan kos minimum dua kes; Kod pemacu", "code": "def minimumCost ( arr , N , X , Y ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( ( arr [ i ] & 1 ) and ( i % 2 == 0 ) ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( ( arr [ i ] % 2 ) == 0 and ( i & 1 ) ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT cost1 = X * min ( odd_count , even_count ) NEW_LINE cost2 = Y * ( max ( odd_count , even_count ) - min ( odd_count , even_count ) ) NEW_LINE cost3 = ( odd_count + even_count ) * Y NEW_LINE return min ( cost1 + cost2 , cost3 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 3 , 7 , 2 , 1 ] NEW_LINE X = 10 NEW_LINE Y = 2 NEW_LINE N = len ( arr ) NEW_LINE print ( minimumCost ( arr , N , X , Y ) ) NEW_LINE DEDENT"}
{"text": "Produk minimum elemen maksimum dan minimum ke atas semua subarray yang mungkin | Berfungsi untuk mencari produk minimum minimum dan maksimum di antara semua subarray yang mungkin; Kedai produk minimum yang dihasilkan; Melintasi array yang diberikan []; Min produk dari dua sepasang elemen berturut -turut; Mengembalikan nilai yang dihasilkan; Kod pemacu", "code": "def findMinMax ( a ) : NEW_LINE INDENT min_val = 1000000000 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) NEW_LINE DEDENT return min_val NEW_LINE DEDENT if __name__ == ( \" _ _ main _ _ \" ) : NEW_LINE INDENT arr = [ 6 , 4 , 5 , 6 , 2 , 4 , 1 ] NEW_LINE print ( findMinMax ( arr ) ) NEW_LINE DEDENT"}
{"text": "Jumlah semua nod dengan nilai yang lebih kecil pada jarak k dari nod yang diberikan dalam BST | Struktur pokok; Pembina untuk membuat nod baru; Berfungsi untuk menambah nod ke jumlah di bawah nod sasaran; Kes asas; Jika nod jauh kth dicapai; Berulang untuk kiri dan subtrees kanan; Fungsi untuk mencari nod jauh dari nod sasaran, ia kembali - 1 jika nod sasaran tidak hadir di dalam pokok; Kes asas 1; Jika sasaran sama dengan akar. ; Berulang untuk subtree kiri; Pokok adalah BST jadi mengurangkan ruang carian; Semak jika nod sasaran ditemui di subtree kiri; Jika akar berada pada jarak k dari sasaran; Node kurang daripada sasaran akan hadir di sebelah kiri; Apabila nod tidak hadir di subtree kiri; Jika nod jauh kth dicapai; Node kurang daripada sasaran pada jarak k mungkin terdapat di pokok kiri; Jika sasaran tidak hadir di sebelah kiri atau di subtree kanan; Berfungsi untuk memasukkan nod dalam BST; Jika akar adalah batal; Masukkan data pada separuh kanan; Masukkan data di separuh kiri; Mengembalikan nod akar; Fungsi untuk mencari jumlah n nod jauh dari nod sasaran yang mempunyai nilai kurang daripada nod sasaran; Menyimpan jumlah nod yang mempunyai nilai <sasaran pada jarak k; Cetak jumlah yang dihasilkan; Kod pemacu; Buat pokok", "code": "sum = 0 NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def kDistanceDownSum ( root , k ) : NEW_LINE INDENT global sum NEW_LINE if ( root == None or k < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT sum += root . data NEW_LINE return NEW_LINE DEDENT kDistanceDownSum ( root . left , k - 1 ) NEW_LINE kDistanceDownSum ( root . right , k - 1 ) NEW_LINE DEDENT def kDistanceSum ( root , target , k ) : NEW_LINE INDENT global sum NEW_LINE if ( root == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( root . data == target ) : NEW_LINE INDENT kDistanceDownSum ( root . left , k - 1 ) NEW_LINE return 0 NEW_LINE DEDENT dl = - 1 NEW_LINE if ( target < root . data ) : NEW_LINE INDENT dl = kDistanceSum ( root . left , target , k ) NEW_LINE DEDENT if ( dl != - 1 ) : NEW_LINE INDENT if ( dl + 1 == k ) : NEW_LINE INDENT sum += root . data NEW_LINE DEDENT return - 1 NEW_LINE DEDENT dr = - 1 NEW_LINE if ( target > root . data ) : NEW_LINE INDENT dr = kDistanceSum ( root . right , target , k ) NEW_LINE DEDENT if ( dr != - 1 ) : NEW_LINE INDENT if ( dr + 1 == k ) : NEW_LINE INDENT sum += root . data NEW_LINE DEDENT else : NEW_LINE INDENT kDistanceDownSum ( root . left , k - dr - 2 ) NEW_LINE DEDENT return 1 + dr NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def insertNode ( data , root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT node = Node ( data ) NEW_LINE return node NEW_LINE DEDENT elif ( data > root . data ) : NEW_LINE INDENT root . right = insertNode ( data , root . right ) NEW_LINE DEDENT elif ( data <= root . data ) : NEW_LINE INDENT root . left = insertNode ( data , root . left ) NEW_LINE DEDENT return root NEW_LINE DEDENT def findSum ( root , target , K ) : NEW_LINE INDENT kDistanceSum ( root , target , K ) NEW_LINE print ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE N = 11 NEW_LINE tree = [ 3 , 1 , 7 , 0 , 2 , 5 , 10 , 4 , 6 , 9 , 8 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT root = insertNode ( tree [ i ] , root ) NEW_LINE DEDENT target = 7 NEW_LINE K = 2 NEW_LINE findSum ( root , target , K ) NEW_LINE DEDENT"}
{"text": "Cari item n yang diedarkan dari item tak terhingga jenis tak terhingga berdasarkan syarat -syarat yang diberikan | Berfungsi untuk mencari jenis item yang diberikan mengikut peraturan yang diberikan; Menyimpan kiraan item yang diberikan pada setiap langkah; Melangkah ke hari dari 1; Melewati jenis item pada hari itu; Count item yang diberikan hendaklah melebihi n; Kod pemacu", "code": "def itemType ( n ) : NEW_LINE INDENT count = 0 NEW_LINE day = 1 NEW_LINE while ( True ) : NEW_LINE INDENT for type in range ( day , 0 , - 1 ) : NEW_LINE INDENT count += type NEW_LINE if ( count >= n ) : NEW_LINE INDENT return type NEW_LINE DEDENT DEDENT DEDENT DEDENT N = 10 NEW_LINE print ( itemType ( N ) ) NEW_LINE"}
{"text": "Cari jumlah semua elemen array yang sama dari dua kuasa berturut -turut 2 | Program Python3 untuk pendekatan di atas; Berfungsi untuk jumlah unsur -unsur array yang sama dari dua kuasa berturut -turut 2; Menyimpan jumlah yang dihasilkan dari unsur -unsur array; Melintasi array arr []; Menyimpan kuasa 2 daripada nombor arr [i]; Menyimpan nombor yang kuasa 2 dan lebih rendah daripada atau sama dengan arr [i]; Menyimpan nombor yang kuasa 2 dan lebih besar daripada atau sama dengan arr [i]; Jika arr [i] - Lesservalue adalah sama seperti besar - arr [i]; Kenaikan res oleh arr [i]; Mengembalikan jumlah yang dihasilkan; Kod pemacu", "code": "from math import log2 NEW_LINE def FindSum ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT power = int ( log2 ( arr [ i ] ) ) NEW_LINE LesserValue = pow ( 2 , power ) NEW_LINE LargerValue = pow ( 2 , power + 1 ) NEW_LINE if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 24 , 17 , 3 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE print ( FindSum ( arr , N ) ) NEW_LINE DEDENT"}
{"text": "Cari orang yang akan selesai terakhir | Berfungsi untuk mencari orang yang akan selesai terakhir; Untuk menjejaki baris dan lajur yang mempunyai 1; Baris dan lajur yang ada; Bilangan minimum pilihan yang kita ada; Jika bilangan pilihan ganjil; P1 akan selesai terakhir; Jika tidak, P2 akan selesai terakhir; Diberi matriks", "code": "def findLast ( mat ) : NEW_LINE INDENT m = len ( mat ) NEW_LINE n = len ( mat [ 0 ] ) NEW_LINE rows = set ( ) NEW_LINE cols = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] : NEW_LINE INDENT rows . add ( i ) NEW_LINE cols . add ( j ) NEW_LINE DEDENT DEDENT DEDENT avRows = m - len ( list ( rows ) ) NEW_LINE avCols = n - len ( list ( cols ) ) NEW_LINE choices = min ( avRows , avCols ) NEW_LINE if choices & 1 : NEW_LINE INDENT print ( ' P1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' P2' ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 1 ] ] NEW_LINE findLast ( mat ) NEW_LINE"}
{"text": "Jumlah perpuluhan yang merupakan perwakilan binari nombor semulajadi n pertama | Program Python3 untuk pendekatan di atas; Berfungsi untuk mencari jumlah nombor semulajadi N pertama yang diwakili dalam perwakilan binari; Menyimpan jumlah yang dihasilkan; Melangkah sehingga nilai n lebih besar daripada 0; Jika n kurang daripada 2; Simpan kedudukan MSB N; Iterat dalam julat [1, x] dan tambahkan sumbangan nombor dari 1 hingga (2 ^ x - 1); Kemas kini nilai CUR dan tambah; Tambah cur ke ans; Simpan nombor yang tinggal; Tambah sumbangan oleh MSB dengan bilangan yang tinggal; Lelaran seterusnya akan diulangi untuk 2 ^ x - 1; Cetak hasilnya; Kod pemacu", "code": "from math import log2 , pow NEW_LINE MOD = 1000000007 NEW_LINE def sumOfBinaryNumbers ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE one = 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT ans = ( ans + n ) % MOD NEW_LINE break NEW_LINE DEDENT x = int ( log2 ( n ) ) NEW_LINE cur = 0 NEW_LINE add = ( one << ( x - 1 ) ) NEW_LINE for i in range ( 1 , x + 1 , 1 ) : NEW_LINE INDENT cur = ( cur + add ) % MOD NEW_LINE add = ( add * 10 % MOD ) NEW_LINE DEDENT ans = ( ans + cur ) % MOD NEW_LINE rem = n - ( one << x ) + 1 NEW_LINE p = pow ( 10 , x ) NEW_LINE p = ( p * ( rem % MOD ) ) % MOD NEW_LINE ans = ( ans + p ) % MOD NEW_LINE n = rem - 1 NEW_LINE DEDENT print ( int ( ans ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE sumOfBinaryNumbers ( N ) NEW_LINE DEDENT"}
{"text": "Nombor Fibonacci terdekat kepada N | Berfungsi untuk mencari nombor Fibonacci yang paling dekat dengan N; Kes asas; Memulakan syarat pertama & kedua siri Fibonacci; Simpan istilah ketiga; ITERATE Sehingga istilah ketiga kurang daripada atau sama dengan NUM; Kemas kini yang pertama; Kemas kini yang kedua; Mengemas kini yang ketiga; Simpan nombor Fibonacci yang mempunyai perbezaan yang lebih kecil dengan N; Cetak hasilnya; Kod pemacu", "code": "def nearestFibonacci ( num ) : NEW_LINE INDENT if ( num == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT first = 0 NEW_LINE second = 1 NEW_LINE third = first + second NEW_LINE while ( third <= num ) : NEW_LINE INDENT first = second NEW_LINE second = third NEW_LINE third = first + second NEW_LINE DEDENT if ( abs ( third - num ) >= abs ( second - num ) ) : NEW_LINE INDENT ans = second NEW_LINE DEDENT else : NEW_LINE INDENT ans = third NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 17 NEW_LINE nearestFibonacci ( N ) NEW_LINE DEDENT"}
{"text": "Permutasi nombor semulajadi n pertama yang diberikan array sebagai array maksimum awalan | Program Python3 untuk pendekatan di atas; Fungsi untuk memeriksa sama ada array awalan maksimum ANS [] sama dengan array arr []; Memulakan pembolehubah, maks; Melintasi array, ans []; Simpan nilai maksimum sehingga indeks i; Jika ia tidak sama dengan [i], maka kembali palsu; Sebaliknya kembali palsu; Berfungsi untuk mencari permutasi array yang array maksimum awalan yang sama dengan array yang diberikan []; Menyimpan permutasi yang diperlukan; Menyimpan indeks kejadian pertama unsur; Melintasi array a []; Jika A [i] tidak hadir di um, maka simpannya di um; Kemas kini Ans [i] ke [i]; Menyimpan nombor yang tidak disokong; Isi array, v []; Simpan indeks; Melintasi array, ans []; Isi V [J] di tempat -tempat di mana Ans [i] adalah 0; Semak sama ada array awalan maksimum permutasi semasa adalah sama dengan array yang diberikan []; Jika benar, cetak permutasi; Jika tidak, cetak - 1; Kod pemacu; Panggilan fungsi", "code": "import sys NEW_LINE def checkPermutation ( ans , a , n ) : NEW_LINE INDENT Max = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Max = max ( Max , ans [ i ] ) NEW_LINE if ( Max != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findPermutation ( a , n ) : NEW_LINE INDENT ans = [ 0 ] * n NEW_LINE um = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] not in um ) : NEW_LINE INDENT ans [ i ] = a [ i ] NEW_LINE um [ a [ i ] ] = i NEW_LINE DEDENT DEDENT v = [ ] NEW_LINE j = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i not in um ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( ans [ i ] == 0 ) : NEW_LINE INDENT ans [ i ] = v [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( checkPermutation ( ans , a , n ) ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 5 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE findPermutation ( arr , N ) NEW_LINE DEDENT"}
{"text": "Kira pasangan elemen yang sama mungkin dengan tidak termasuk setiap elemen array sekali | Fungsi untuk mengira bilangan pasangan yang diperlukan untuk setiap elemen array; Memulakan peta; Mengemas kini kekerapan setiap elemen; Menyimpan kiraan pasangan; Melintasi peta; Hitung bilangan cara untuk memilih pasangan yang terdiri daripada unsur yang sama sahaja; Melintasi array; Cetak kiraan untuk setiap elemen array; Kod pemacu; Diberikan array; Saiz array", "code": "def countEqualElementPairs ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT total += ( value * ( value - 1 ) ) / 2 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( int ( total - ( mp [ arr [ i ] ] - 1 ) ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 1 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE countEqualElementPairs ( arr , N ) NEW_LINE DEDENT"}
{"text": "Count of Octal Number sehingga digit N | Berfungsi untuk mengembalikan kiraan nombor oktal semulajadi sehingga digit; Gelung untuk berulang dari 1 hingga N dan mengira bilangan nombor oktal untuk setiap digit 'i' th. ; Kod pemacu", "code": "def count ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT sum += 7 * ( 8 ** ( i - 1 ) ) ; NEW_LINE DEDENT return int ( sum ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE print ( count ( N ) ) ; NEW_LINE DEDENT"}
{"text": "Pembahagi Palindromic nombor | Program Python3 untuk mencari semua pembahagi palindromik nombor; Fungsi untuk memeriksa adalah NUM adalah palindromic atau tidak; Tukar n ke string str; Memulakan dan mengakhiri indeks string str; Jika char di s dan e tidak sama maka kembali palsu; Berfungsi untuk mencari pembahagi palindromik; Untuk sakit pembahagi palindromik nombor n; Jika n boleh dibahagikan dengan i; Semak jika nombor adalah persegi yang sempurna; Periksa pembahagi adalah palindromic, kemudian simpannya; Semak jika pembahagi adalah palindrome; Semak jika N / pembahagi adalah palindromik atau tidak; Cetak semua pembahagi palindromik dalam urutan yang disusun; Kod pemacu; Fungsi panggilan untuk mencari semua pembahagi palindromik", "code": "from math import sqrt ; NEW_LINE def isPalindrome ( n ) : NEW_LINE INDENT string = str ( n ) ; NEW_LINE s = 0 ; e = len ( string ) - 1 ; NEW_LINE while ( s < e ) : NEW_LINE INDENT if ( string [ s ] != string [ e ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT s += 1 ; NEW_LINE e -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def palindromicDivisors ( n ) : NEW_LINE INDENT PalindromDivisors = [ ] ; NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT PalindromDivisors . append ( i ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT PalindromDivisors . append ( i ) ; NEW_LINE DEDENT if ( isPalindrome ( n // i ) ) : NEW_LINE INDENT PalindromDivisors . append ( n // i ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT PalindromDivisors . sort ( ) ; NEW_LINE for i in range ( len ( PalindromDivisors ) ) : NEW_LINE INDENT print ( PalindromDivisors [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 66 ; NEW_LINE palindromicDivisors ( n ) ; NEW_LINE DEDENT"}
{"text": "Keluarkan nombor minimum dari array untuk mendapatkan minimum atau nilai | Pelaksanaan Python3 pendekatan; Berfungsi untuk mengembalikan penghapusan minimum untuk mendapatkan minimum atau; Untuk menyimpan elemen minimum; Cari elemen minimum dari array; Untuk menyimpan kekerapan elemen minimum; Cari kekerapan elemen minimum; Kembalikan jawapan terakhir; Kod pemacu", "code": "import sys NEW_LINE def findMinDel ( arr , n ) : NEW_LINE INDENT min_num = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_num ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return n - cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findMinDel ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Program untuk mencetak nombor perdana dari 1 hingga n. | Berfungsi untuk mencetak nombor utama n pertama; Mengisytiharkan pembolehubah; Mesej paparan cetak; Melintasi setiap nombor dari 1 hingga n dengan bantuan untuk gelung; Langkau 0 dan 1 kerana mereka bukan Perdana atau Komposit; pembolehubah bendera untuk memberitahu jika saya adalah perdana atau tidak; Bendera = 1 bermakna saya adalah perdana dan bendera = 0 bermakna saya bukan perdana; Kod pemacu", "code": "def print_primes_till_N ( N ) : NEW_LINE INDENT i , j , flag = 0 , 0 , 0 ; NEW_LINE print ( \" Prime ▁ numbers ▁ between ▁ 1 ▁ and ▁ \" , N , \" ▁ are : \" ) ; NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( i == 1 or i == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT flag = 1 ; NEW_LINE for j in range ( 2 , ( ( i // 2 ) + 1 ) , 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT N = 100 ; NEW_LINE print_primes_till_N ( N ) ; NEW_LINE"}
{"text": "Memaksimumkan ungkapan (a dan x) * (b dan x) | Manipulasi Bit | Pelaksanaan Python3 pendekatan; Fungsi untuk mencari x mengikut syarat yang diberikan; Int boleh mempunyai 32 bit; Bit sementara; Kirakan sedikit x mengikut syarat -syarat yang diberikan di bawah adalah kesimpulan langsung dari ilustrasi yang telah kami ambil sebelumnya; Tambah sedikit x ke x; Kod pemacu", "code": "MAX = 32 NEW_LINE def findX ( A , B ) : NEW_LINE INDENT X = 0 ; NEW_LINE for bit in range ( MAX ) : NEW_LINE INDENT tempBit = 1 << bit ; NEW_LINE bitOfX = A & B & tempBit ; NEW_LINE X += bitOfX ; NEW_LINE DEDENT return X ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 11 ; B = 13 ; NEW_LINE print ( findX ( A , B ) ) ; NEW_LINE DEDENT"}
{"text": "Bilangan subset yang min adalah maksimum | Berfungsi untuk mengembalikan kiraan subset dengan min maksimum; Nilai maksimum dari array; Untuk menyimpan bilangan elemen maksimum kali muncul dalam array; Mengembalikan kiraan subset yang sah; Kod pemacu", "code": "def cntSubSets ( arr , n ) : NEW_LINE INDENT maxVal = max ( arr ) ; NEW_LINE cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == maxVal ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return ( ( 2 ** cnt ) - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( cntSubSets ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Kebarangkalian bahawa pasangan rawak yang dipilih dari array (a [i], a [j]) mempunyai jumlah maksimum | Pelaksanaan Python3 pendekatan; Berfungsi untuk mengembalikan kebarangkalian mendapatkan jumlah pasangan maksimum apabila pasangan rawak dipilih dari array yang diberikan; Memulakan jumlah maksimum, kiraannya dan kiraan jumlah pasangan; Untuk setiap pasangan; Dapatkan jumlah pasangan semasa; Jika jumlahnya sama dengan jumlah maksimum semasa setakat ini; Kenaikan kiraannya; Jika jumlahnya lebih besar daripada maksimum semasa; Kemas kini maksimum semasa dan semula - memulakan kiraan kepada 1; Cari kebarangkalian yang diperlukan; Kod pemacu", "code": "import sys NEW_LINE def findProb ( arr , n ) : NEW_LINE INDENT maxSum = - ( sys . maxsize - 1 ) ; NEW_LINE maxCount = 0 ; NEW_LINE totalPairs = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] ; NEW_LINE if ( sum == maxSum ) : NEW_LINE INDENT maxCount += 1 ; NEW_LINE DEDENT elif ( sum > maxSum ) : NEW_LINE INDENT maxSum = sum ; NEW_LINE maxCount = 1 ; NEW_LINE DEDENT totalPairs += 1 ; NEW_LINE DEDENT DEDENT prob = maxCount / totalPairs ; NEW_LINE return prob ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 2 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findProb ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Kiraan maksimum pembahagi umum a dan b sedemikian rupa sehingga semua adalah co | Pelaksanaan Python3 pendekatan; Fungsi untuk mengembalikan kiraan faktor umum a dan b supaya semua elemen adalah co - perdana antara satu sama lain; GCD A dan B; Termasuk 1 pada mulanya; Cari semua faktor utama GCD; Jika GCD adalah perdana; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "import math NEW_LINE def maxCommonFactors ( a , b ) : NEW_LINE INDENT gcd = math . gcd ( a , b ) NEW_LINE ans = 1 ; NEW_LINE i = 2 NEW_LINE while ( i * i <= gcd ) : NEW_LINE INDENT if ( gcd % i == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE while ( gcd % i == 0 ) : NEW_LINE INDENT gcd = gcd // i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( gcd != 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = 12 NEW_LINE b = 18 NEW_LINE print ( maxCommonFactors ( a , b ) ) NEW_LINE"}
{"text": "Cari nombor hari dalam tahun semasa untuk tarikh yang diberikan | Pelaksanaan Python3 pendekatan; Berfungsi untuk mengembalikan bilangan hari tahun ini untuk tarikh yang diberikan; Ekstrak tahun, bulan dan hari dari rentetan tarikh; Sekiranya tahun semasa adalah tahun lompat dan tarikh yang diberikan adalah selepas 28 Februari maka ia mesti termasuk 29 Februari; Tambah hari pada bulan -bulan sebelumnya; Kod pemacu", "code": "days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ; NEW_LINE def dayOfYear ( date ) : NEW_LINE INDENT year = ( int ) ( date [ 0 : 4 ] ) ; NEW_LINE month = ( int ) ( date [ 5 : 7 ] ) ; NEW_LINE day = ( int ) ( date [ 8 : ] ) ; NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 ; NEW_LINE DEDENT month -= 1 ; NEW_LINE while ( month > 0 ) : NEW_LINE INDENT day = day + days [ month - 1 ] ; NEW_LINE month -= 1 ; NEW_LINE DEDENT return day ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT date = \"2019-01-09\" ; NEW_LINE print ( dayOfYear ( date ) ) ; NEW_LINE DEDENT"}
{"text": "Cari bilangan sel dalam jadual mengandungi x | Fungsi untuk mencari bilangan sel dalam jadual mengandungi x; Kod pemacu; Panggilan fungsi", "code": "def Cells ( n , x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x % i == 0 and x / i <= n ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 ; x = 12 ; NEW_LINE print ( Cells ( n , x ) ) ; NEW_LINE DEDENT"}
{"text": "Kuasa terkecil 4 lebih besar daripada atau sama dengan N | Python3 pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan kuasa terkecil 4 lebih besar daripada atau sama dengan n; Jika n sendiri adalah kuasa 4 maka kembali n; Kod pemacu", "code": "import math NEW_LINE def nextPowerOfFour ( n ) : NEW_LINE INDENT x = math . floor ( ( n ** ( 1 / 2 ) ) ** ( 1 / 2 ) ) ; NEW_LINE if ( ( x ** 4 ) == n ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT else : NEW_LINE INDENT x = x + 1 ; NEW_LINE return ( x ** 4 ) ; NEW_LINE DEDENT DEDENT n = 122 ; NEW_LINE print ( nextPowerOfFour ( n ) ) ; NEW_LINE"}
{"text": "Operasi minimum yang diperlukan untuk menukar x ke y dengan mendarabkan x dengan co yang diberikan | Berfungsi untuk mengembalikan operasi minimum yang diperlukan; Tidak mungkin; Untuk menyimpan kuasa terbesar p yang membahagikan d; Sementara dibahagi oleh p; Untuk menyimpan kuasa terbesar Q yang membahagikan d; Manakala dibahagi oleh q; Jika d> 1; Kerana, d = p ^ a * q ^ b; Kod pemacu", "code": "def minOperations ( x , y , p , q ) : NEW_LINE INDENT if ( y % x != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = y // x NEW_LINE a = 0 NEW_LINE while ( d % p == 0 ) : NEW_LINE INDENT d //= p NEW_LINE a += 1 NEW_LINE DEDENT b = 0 NEW_LINE while ( d % q == 0 ) : NEW_LINE INDENT d //= q NEW_LINE b += 1 NEW_LINE DEDENT if ( d != 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( a + b ) NEW_LINE DEDENT x = 12 NEW_LINE y = 2592 NEW_LINE p = 2 NEW_LINE q = 3 NEW_LINE print ( minOperations ( x , y , p , q ) ) NEW_LINE"}
{"text": "Bilangan kuadrup dengan GCD sama dengan k | Pelaksanaan Python3 pendekatan; Fungsi untuk mengira NC4; Kes asas untuk mengira NC4; Berfungsi untuk mengembalikan kiraan kuadrup yang diperlukan menggunakan pengecualian inklusi; Berkesan n; Melangkah lebih dari 2 hingga m; Bilangan pembahagi saya hingga m; Count menyimpan bilangan pembahagi utama yang berlaku tepat sekali; Untuk mengelakkan pengulangan pembahagi utama; Jika pengulangan pembahagi utama hadir mengabaikan nombor ini; Jika kiraan pembahagi utama ganjil tolaknya dari jawapan lain, tambah; Kod pemacu", "code": "from math import sqrt NEW_LINE def nCr ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; NEW_LINE answer //= 24 ; NEW_LINE return answer ; NEW_LINE DEDENT def countQuadruples ( N , K ) : NEW_LINE INDENT M = N // K ; NEW_LINE answer = nCr ( M ) ; NEW_LINE for i in range ( 2 , M ) : NEW_LINE INDENT j = i ; NEW_LINE temp2 = M // i ; NEW_LINE count = 0 ; NEW_LINE check = 0 ; NEW_LINE temp = j ; NEW_LINE while ( j % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE j //= 2 ; NEW_LINE if ( count >= 2 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT check = 1 ; NEW_LINE DEDENT for k in range ( 3 , int ( sqrt ( temp ) ) , 2 ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE while ( j % k == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE j //= k ; NEW_LINE if ( cnt >= 2 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( cnt >= 2 ) : NEW_LINE INDENT check = 1 ; NEW_LINE break ; NEW_LINE DEDENT elif ( cnt == 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT if ( j > 2 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( check ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count % 2 == 1 ) : NEW_LINE INDENT answer -= nCr ( temp2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT answer += nCr ( temp2 ) ; NEW_LINE DEDENT DEDENT DEDENT return answer ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 ; K = 2 ; NEW_LINE print ( countQuadruples ( N , K ) ) ; NEW_LINE DEDENT"}
{"text": "Cari nombor yang ditambah kepada nisbah yang diberikan A: B, nisbah berubah kepada C: D | Berfungsi untuk mengembalikan nombor x yang diperlukan; Kod pemacu", "code": "def getX ( a , b , c , d ) : NEW_LINE INDENT X = ( b * c - a * d ) // ( d - c ) NEW_LINE return X NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 5 NEW_LINE print ( getX ( a , b , c , d ) ) NEW_LINE"}
{"text": "Bilangan cara untuk mengatur perkataan sedemikian rupa sehingga tiada vokal berlaku bersama | Fungsi untuk memeriksa sama ada watak adalah vokal atau konsonen; Berfungsi untuk mengira faktorial nombor; Mengira tidak ada cara untuk mengatur vokal; Melelehkan peta dan mengira bilangan vokal dan mengira tiada cara untuk mengatur vokal; mengira tidak ada cara untuk mengatur perkataan yang diberikan supaya vokal bersatu; Kira tidak ada cara untuk mengatur vokal; untuk menyimpan penyebut pecahan; Count of Consonents; Kirakan bilangan cara untuk mengatur perkataan sedemikian rupa sehingga vokal bersatu; Untuk mengira jumlah permutasi; Untuk menyimpan panjang perkataan yang diberikan; penyebut pecahan; mengembalikan jumlah permutasi perkataan yang diberikan; Berfungsi untuk mengira bilangan permutasi supaya tiada vokal bersatu; untuk menyimpan kekerapan watak; mengira kekerapan acharacters; Hitung jumlah permutasi; Kirakan jumlah permutasi seperti vokal yang datang bersama; substrat vwl_tgthr dari total untuk mendapatkan hasilnya; mengembalikan hasilnya; Kod pemacu", "code": "def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def fact ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT def only_vowels ( freq ) : NEW_LINE INDENT denom = 1 NEW_LINE cnt_vwl = 0 NEW_LINE for itr in freq : NEW_LINE INDENT if ( isVowel ( itr ) ) : NEW_LINE INDENT denom *= fact ( freq [ itr ] ) NEW_LINE cnt_vwl += freq [ itr ] NEW_LINE DEDENT DEDENT return fact ( cnt_vwl ) // denom NEW_LINE DEDENT def all_vowels_together ( freq ) : NEW_LINE INDENT vow = only_vowels ( freq ) NEW_LINE denom = 1 NEW_LINE cnt_cnst = 0 NEW_LINE for itr in freq : NEW_LINE INDENT if ( isVowel ( itr ) == False ) : NEW_LINE INDENT denom *= fact ( freq [ itr ] ) NEW_LINE cnt_cnst += freq [ itr ] NEW_LINE DEDENT DEDENT ans = fact ( cnt_cnst + 1 ) // denom NEW_LINE return ( ans * vow ) NEW_LINE DEDENT def total_permutations ( freq ) : NEW_LINE INDENT cnt = 0 NEW_LINE denom = 1 NEW_LINE for itr in freq : NEW_LINE INDENT denom *= fact ( freq [ itr ] ) NEW_LINE cnt += freq [ itr ] NEW_LINE DEDENT return fact ( cnt ) // denom NEW_LINE DEDENT def no_vowels_together ( word ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in word : NEW_LINE INDENT ch = i . lower ( ) NEW_LINE freq [ ch ] = freq . get ( ch , 0 ) + 1 NEW_LINE DEDENT total = total_permutations ( freq ) NEW_LINE vwl_tgthr = all_vowels_together ( freq ) NEW_LINE res = total - vwl_tgthr NEW_LINE return res NEW_LINE DEDENT word = \" allahabad \" NEW_LINE ans = no_vowels_together ( word ) NEW_LINE print ( ans ) NEW_LINE word = \" geeksforgeeks \" NEW_LINE ans = no_vowels_together ( word ) NEW_LINE print ( ans ) NEW_LINE word = \" abcd \" NEW_LINE ans = no_vowels_together ( word ) NEW_LINE print ( ans ) NEW_LINE"}
{"text": "Program untuk mencari bilangan lelaki pada mulanya | Berfungsi untuk mengembalikan bilangan lelaki pada mulanya; Kod pemacu", "code": "def numberOfMen ( D , m , d ) : NEW_LINE INDENT Men = ( m * ( D - d ) ) / d ; NEW_LINE return int ( Men ) ; NEW_LINE DEDENT D = 5 ; m = 4 ; d = 4 ; NEW_LINE print ( numberOfMen ( D , m , d ) ) ; NEW_LINE"}
{"text": "Kawasan segitiga yang dibentuk oleh paksi Co | Berfungsi untuk mencari kawasan; Kod pemacu", "code": "def area ( a , b , c ) : NEW_LINE INDENT d = abs ( ( c * c ) / ( 2 * a * b ) ) NEW_LINE return d NEW_LINE DEDENT a = - 2 NEW_LINE b = 4 NEW_LINE c = 3 NEW_LINE print ( area ( a , b , c ) ) NEW_LINE"}
{"text": "Jumlah dua nombor di mana satu nombor diwakili sebagai pelbagai digit | Berfungsi untuk mengembalikan vektor yang mengandungi jawapannya; Vektor V adalah untuk menyimpan setiap digit jumlah dan vektor ANS adalah untuk menyimpan jawapannya; Tidak dibawa pada mulanya; Mula gelung dari hujung dan ambil elemen satu demi satu; Indeks array dan nombor angka terakhir; Mengekalkan pembawa penjumlahan; Tolak nilai digit ke dalam array; Nilai k lebih besar kemudian 0; Tolak digit k satu demi satu dalam array; Juga mengekalkan pembawa dengan penjumlahan; Membalikkan unsur -unsur vektor v dan simpannya dalam vektor ans; Kod pemacu; Cetak jawapannya", "code": "def addToArrayForm ( A , K ) : NEW_LINE INDENT v , ans = [ ] , [ ] NEW_LINE rem , i = 0 , 0 NEW_LINE for i in range ( len ( A ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT my = A [ i ] + ( K % 10 ) + rem NEW_LINE if my > 9 : NEW_LINE INDENT rem = 1 NEW_LINE v . append ( my % 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( my ) NEW_LINE rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT while K > 0 : NEW_LINE INDENT my = ( K % 10 ) + rem NEW_LINE v . append ( my % 10 ) NEW_LINE if my // 10 > 0 : NEW_LINE INDENT rem = 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT if rem > 0 : NEW_LINE INDENT v . append ( rem ) NEW_LINE DEDENT for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans . append ( v [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 2 , 7 , 4 ] NEW_LINE K = 181 NEW_LINE ans = addToArrayForm ( A , K ) NEW_LINE for i in range ( 0 , len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Kirakan maksimum fungsi dengan cekap ke atas semua sub | Pelaksanaan Python3 pendekatan di atas; Berfungsi untuk mengembalikan jumlah maksimum sub - array; Berfungsi untuk mengembalikan nilai maksimum fungsi f; Mengira Arrays B [] dan C []; Cari Sub Maksimum Sub - pelbagai tatasusunan dan mengambil maksimum di antara mereka; Kod pemacu", "code": "MAX = 100005 ; NEW_LINE def kadaneAlgorithm ( ar , n ) : NEW_LINE INDENT sum = 0 ; maxSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ar [ i ] ; NEW_LINE if ( sum < 0 ) : NEW_LINE INDENT sum = 0 ; NEW_LINE DEDENT maxSum = max ( maxSum , sum ) ; NEW_LINE DEDENT return maxSum ; NEW_LINE DEDENT def maxFunction ( arr , n ) : NEW_LINE INDENT b = [ 0 ] * MAX ; NEW_LINE c = [ 0 ] * MAX ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT b [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) ; NEW_LINE c [ i ] = - b [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT c [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) ; NEW_LINE b [ i ] = - c [ i ] ; NEW_LINE DEDENT DEDENT ans = kadaneAlgorithm ( b , n - 1 ) ; NEW_LINE ans = max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 4 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( maxFunction ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Ketiga digit terakhir dalam 5 ^ n untuk diberikan n | Berfungsi untuk mencari elemen; jika n <3; Jika n juga kembali 6 jika n adalah pulangan ganjil 1; Kod pemacu", "code": "def findThirdDigit ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 if n and 1 else 6 NEW_LINE DEDENT n = 7 NEW_LINE print ( findThirdDigit ( n ) ) NEW_LINE"}
{"text": "Kebarangkalian memenangi perlawanan apabila kebarangkalian individu memukul sasaran yang diberikan | Berfungsi untuk mengembalikan kebarangkalian kemenangan; P dan Q menyimpan nilai pecahan A / B dan C / D; Untuk menyimpan kebarangkalian kemenangan A; Kod pemacu", "code": "def getProbability ( a , b , c , d ) : NEW_LINE INDENT p = a / b ; NEW_LINE q = c / d ; NEW_LINE ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; NEW_LINE return round ( ans , 5 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 1 ; b = 2 ; c = 10 ; d = 11 ; NEW_LINE print ( getProbability ( a , b , c , d ) ) ; NEW_LINE DEDENT"}
{"text": "Nombor palindromik terbesar dalam array | Fungsi untuk memeriksa sama ada n adalah palindrome; Cari pembahagi yang sesuai untuk mengekstrak digit terkemuka; Jika digit pertama dan terakhir tidak sama maka kembali palsu; Mengeluarkan digit terkemuka dan trailing dari nombor; Mengurangkan pembahagi dengan faktor 2 sebagai 2 digit dijatuhkan; Berfungsi untuk mencari nombor palindromik terbesar; Sekiranya palindrom lebih besar daripada semasa yang dijumpai; Mengembalikan nombor palindromik terbesar dari array; Kod pemacu; Cetak jawapan yang diperlukan", "code": "def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( int ( n / divisor ) >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = int ( n / divisor ) NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( ( n % divisor ) / 10 ) NEW_LINE divisor = int ( divisor / 100 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def largestPalindrome ( A , n ) : NEW_LINE INDENT currentMax = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( A [ i ] > currentMax and isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT currentMax = A [ i ] NEW_LINE DEDENT DEDENT return currentMax NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 232 , 54545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestPalindrome ( A , n ) ) NEW_LINE DEDENT"}
{"text": "Kurangkan array ke satu elemen dengan operasi yang diberikan | Berfungsi untuk mengembalikan elemen akhir; Kod pemacu", "code": "def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE while finalNum * 2 <= n : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE print ( getFinalElement ( N ) ) NEW_LINE DEDENT"}
{"text": "Jumlah elemen dalam array yang mempunyai kekerapan utama | Program Python3 untuk mencari jumlah elemen dalam array yang mempunyai kekerapan utama; Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mengembalikan jumlah elemen dalam array yang mempunyai kekerapan utama; Peta digunakan untuk menyimpan frekuensi elemen; Melintasi peta menggunakan iterators; Mengira bilangan elemen yang mempunyai frekuensi utama; Kod pemacu", "code": "import math as mt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( p_size + 1 ) ) ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def SumOfElements ( arr , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE i , j = 0 , 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE for i in m : NEW_LINE INDENT if ( prime [ m [ i ] ] ) : NEW_LINE INDENT Sum += ( i ) NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( SumOfElements ( arr , n ) ) NEW_LINE"}
{"text": "Jumlah semua nombor palindromik panjang dalam julat [l, r] | Fungsi yang mengembalikan benar jika nombor yang diberikan adalah palindrome; Di sini kita menjana nombor baru (reverse_num) dengan membalikkan digit nombor input asal; Jika nombor input asal (NUM) adalah sama dengan terbalik (reverse_num) maka palindrome yang lain tidak. ; Fungsi yang mengembalikan benar jika nombor yang diberikan adalah panjang ganjil; Berfungsi untuk mengembalikan jumlah semua nombor palindromik panjang yang ganjil dalam julat yang diberikan; jika nombor adalah palindrome dan panjang ganjil; Kod pemacu", "code": "def isPalindrome ( num ) : NEW_LINE INDENT reverse_num = 0 NEW_LINE temp = num NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT remainder = temp % 10 NEW_LINE reverse_num = reverse_num * 10 + remainder NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( reverse_num == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isOddLength ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT num = int ( num / 10 ) NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def sumOfAllPalindrome ( L , R ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( L <= R ) : NEW_LINE INDENT for i in range ( L , R + 1 , 1 ) : NEW_LINE INDENT if ( isPalindrome ( i ) and isOddLength ( i ) ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 110 NEW_LINE R = 1130 NEW_LINE print ( sumOfAllPalindrome ( L , R ) ) NEW_LINE DEDENT"}
{"text": "Bilangan cara untuk mengatur perkataan sedemikian rupa sehingga semua vokal berlaku bersama | Faktorial nombor; mengira cara untuk mengatur konsonan; Abaikan vokal; mengira cara untuk mengatur vokal; Fungsi untuk mengira jumlah no. cara; Mengira vokal dan konsonan; Jumlah tidak. cara; Kod pemacu", "code": "def fact ( n ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f = f * i NEW_LINE DEDENT return f NEW_LINE DEDENT def waysOfConsonants ( size1 , freq ) : NEW_LINE INDENT ans = fact ( size1 ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( i == 0 or i == 4 or i == 8 or i == 14 or i == 20 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans // fact ( freq [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def waysOfVowels ( size2 , freq ) : NEW_LINE INDENT return ( fact ( size2 ) // ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ) NEW_LINE DEDENT def countWays ( str1 ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT vowel = 0 NEW_LINE consonant = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] != ' a ' and str1 [ i ] != ' e ' and str1 [ i ] != ' i ' and str1 [ i ] != ' o ' and str1 [ i ] != ' u ' ) : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT else : NEW_LINE INDENT vowel += 1 NEW_LINE DEDENT DEDENT return ( waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" NEW_LINE print ( countWays ( str1 ) ) NEW_LINE DEDENT"}
{"text": "Jumlah nombor Fibonacci dengan negatif alternatif | Mengira nilai nombor Fibonacci pertama dan menyimpan jumlah alternatif mereka; Memulakan hasil; Tambah istilah yang tinggal; Bahkan istilah; Untuk istilah ganjil; Mengembalikan jumlah bergantian; Program pemacu untuk menguji fungsi di atas; Dapatkan n; Cari jumlah bergantian", "code": "def calculateAlternateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT sum -= fibo [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += fibo [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 NEW_LINE print ( \" Alternating ▁ Fibonacci ▁ Sum ▁ upto ▁ \" , n , \" ▁ terms : ▁ \" , calculateAlternateSum ( n ) ) NEW_LINE DEDENT"}
{"text": "Cari istilah n Siri 1 2 2 4 4 4 4 8 8 8 8 8 8 8 8 ... | Fungsi yang akan mengembalikan istilah nth; Dapatkan n; Dapatkan nilai; Dapatkan n; Dapatkan nilai", "code": "def getValue ( n ) : NEW_LINE INDENT i = 0 ; NEW_LINE k = 1 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT i = i + k ; NEW_LINE k = k * 2 ; NEW_LINE DEDENT return int ( k / 2 ) ; NEW_LINE DEDENT n = 9 ; NEW_LINE print ( getValue ( n ) ) ; NEW_LINE n = 1025 ; NEW_LINE print ( getValue ( n ) ) ; NEW_LINE"}
{"text": "Bina pelbagai frekuensi digit nilai yang diperoleh dari x ^ 1, x ^ 2, ... .... . , x ^ n | Python 3 pelaksanaan pendekatan di atas; Fungsi yang melintasi digit dalam nombor dan mengubah suai jumlah kekerapan kekerapan; Array untuk menyimpan kiraan digit; Melintasi x ^ 1 hingga x ^ n; Untuk fungsi kuasa, kedua -dua parameternya akan dua kali ganda; Memanggil Countdigits berfungsi pada x ^ i; Mencetak kiraan digit 0 - 9; Kod pemacu", "code": "import math NEW_LINE def countDigits ( val , arr ) : NEW_LINE INDENT while ( val > 0 ) : NEW_LINE INDENT digit = val % 10 NEW_LINE arr [ int ( digit ) ] += 1 NEW_LINE val = val // 10 NEW_LINE DEDENT return ; NEW_LINE DEDENT def countFrequency ( x , n ) : NEW_LINE INDENT freq_count = [ 0 ] * 10 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val = math . pow ( x , i ) NEW_LINE countDigits ( val , freq_count ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( freq_count [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 15 NEW_LINE n = 3 NEW_LINE countFrequency ( x , n ) NEW_LINE DEDENT"}
{"text": "Bilangan nilai b seperti a = b + (a ^ b) | berfungsi untuk mengembalikan bilangan penyelesaian; Semak setiap nilai yang mungkin; Kod pemacu", "code": "def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT"}
{"text": "Bilangan nilai b seperti a = b + (a ^ b) | berfungsi untuk mengembalikan bilangan penyelesaian; Kod pemacu", "code": "def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE return 2 ** count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT"}
{"text": "Jumlah kawasan semua persegi yang mungkin di dalam segi empat tepat | Fungsi untuk mengira jumlah kawasan semua dataran yang mungkin masuk ke dalam segi empat tepat; Persegi dengan saiz maksimum mungkin; Kirakan jumlah persegi saiz tertentu; mengira kawasan dataran dengan saiz tertentu; Jumlah kawasan; saiz kenaikan; Kod pemacu", "code": "def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE INDENT totalSquares = ( ( l - size + 1 ) * ( b - size + 1 ) ) NEW_LINE area = ( totalSquares * size * size ) NEW_LINE totalArea += area NEW_LINE size += 1 NEW_LINE DEDENT return totalArea NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 4 NEW_LINE b = 3 NEW_LINE print ( calculateAreaSum ( l , b ) ) NEW_LINE DEDENT"}
{"text": "Hyperfactorial nombor | fungsi untuk mengira nilai hiperfakterial; memulakan val kepada 1; mengembalikan hiperfactoral nombor; Kod pemacu", "code": "def boost_hyperfactorial ( num ) : NEW_LINE INDENT val = 1 ; NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT val = val * pow ( i , i ) ; NEW_LINE DEDENT return val ; NEW_LINE DEDENT num = 5 ; NEW_LINE print ( boost_hyperfactorial ( num ) ) ; NEW_LINE"}
{"text": "Hyperfactorial nombor | fungsi untuk mengira nilai hiperfakterial; memulakan val kepada 1; 1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . ; mengembalikan hiperfactoral nombor; Kod pemacu", "code": "def boost_hyperfactorial ( num ) : NEW_LINE INDENT val = 1 ; NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT val *= i ; NEW_LINE DEDENT DEDENT return val ; NEW_LINE DEDENT num = 5 ; NEW_LINE print ( boost_hyperfactorial ( num ) ) ; NEW_LINE"}
{"text": "Kurangkan 1 tanpa pengendali aritmetik | Kod Python 3 untuk menolak satu daripada nombor tertentu; Flip semua bit set sehingga kita dapati 1; Flip paling tepat 1 bit; Kod pemacu", "code": "def subtractOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while ( ( x & m ) == False ) : NEW_LINE INDENT x = x ^ m NEW_LINE m = m << 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( subtractOne ( 13 ) ) NEW_LINE DEDENT"}
{"text": "Cari vektor min matriks | Program python3 untuk mencari vektor min matriks yang diberikan; Fungsi untuk mencari vektor min; gelung untuk melintasi setiap lajur; untuk mengira min setiap baris; untuk menyimpan jumlah elemen lajur; Kod pemacu", "code": "rows = 3 ; NEW_LINE cols = 3 ; NEW_LINE def meanVector ( mat ) : NEW_LINE INDENT print ( \" [ ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( rows ) : NEW_LINE INDENT mean = 0.00 ; NEW_LINE sum = 0 ; NEW_LINE for j in range ( cols ) : NEW_LINE INDENT sum = sum + mat [ j ] [ i ] ; mean = int ( sum / rows ) ; print ( mean , end = \" ▁ \" ) ; print ( \" ] \" ) ; NEW_LINE DEDENT DEDENT DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; NEW_LINE meanVector ( mat ) ; NEW_LINE"}
{"text": "Nombor Hoax | Kod Python3 untuk memeriksa sama ada nombor adalah nombor tipuan atau tidak. ; Fungsi untuk mencari faktor utama yang berbeza dari nombor n; N adalah ganjil pada ketika ini, kerana ia tidak lagi dibahagikan dengan 2. Oleh itu, kita boleh menguji hanya untuk nombor ganjil, sama ada faktor n; Semak jika saya adalah faktor utama; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Fungsi untuk mengira jumlah digit faktor utama yang berbeza dari nombor N dan jumlah digit nombor N dan bandingkan jumlah yang diperoleh; Faktor utama N sedang disimpan dalam vektor PF; Jika n adalah nombor perdana, ia tidak boleh menjadi nombor tipuan; Mencari jumlah digit faktor utama yang berbeza dari nombor n; Mencari jumlah digit dalam faktor utama semasa PF [i]. ; Mencari jumlah digit nombor n; Membandingkan dua jumlah yang dikira; Kaedah Pemandu", "code": "import math NEW_LINE def primeFactors ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT res . append ( 2 ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE DEDENT res . append ( i ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT res . append ( n ) NEW_LINE DEDENT return res NEW_LINE DEDENT def isHoax ( n ) : NEW_LINE INDENT pf = primeFactors ( n ) NEW_LINE if ( pf [ 0 ] == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT all_pf_sum = 0 NEW_LINE for i in range ( 0 , len ( pf ) ) : NEW_LINE INDENT pf_sum = 0 NEW_LINE while ( pf [ i ] > 0 ) : NEW_LINE INDENT pf_sum += pf [ i ] % 10 NEW_LINE pf [ i ] = int ( pf [ i ] / 10 ) NEW_LINE DEDENT all_pf_sum += pf_sum NEW_LINE DEDENT sum_n = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum_n += n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum_n == all_pf_sum NEW_LINE DEDENT n = 84 ; NEW_LINE if ( isHoax ( n ) ) : NEW_LINE INDENT print ( \" A Hoax Number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not a Hoax Number \" ) NEW_LINE DEDENT"}
{"text": "Ujian Primal | Tetapkan 5 (Menggunakan Lucas | Fungsi untuk mengetahui terma pertama N (Memandangkan 4 sebagai istilah ke -0) Lucas - siri Lehmer.; Istilah 0 siri adalah 4., Buat array untuk menyimpan syarat -syarat.", "code": "def LucasLehmer ( n ) : NEW_LINE INDENT current_val = 4 ; NEW_LINE series = [ ] NEW_LINE series . append ( current_val ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_val = current_val * current_val - 2 ; NEW_LINE series . append ( current_val ) ; NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( \" Term \" , i , \" : \" , series [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE LucasLehmer ( n ) ; NEW_LINE DEDENT"}
{"text": "Modular multiplicative songsang dari 1 hingga n | Kaedah naif untuk mencari terbalik berbilang modular 'A' di bawah modulo 'Perdana; Program Pemandu", "code": "' NEW_LINE def modInverse ( a , prime ) : NEW_LINE INDENT a = a % prime NEW_LINE for x in range ( 1 , prime ) : NEW_LINE INDENT if ( ( a * x ) % prime == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def printModIverses ( n , prime ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( modInverse ( i , prime ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE prime = 17 NEW_LINE printModIverses ( n , prime ) NEW_LINE"}
{"text": "Tukar ke nombor dengan digit sebagai 3 dan 8 sahaja | fungsi untuk operasi minimum; baki dan kiraan operasi; mengira digit tidak sama dengan 3 atau 8; Kod pemacu", "code": "def minOp ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE if ( not ( rem == 3 or rem == 8 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT num = num // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT num = 234198 NEW_LINE print ( \" Minimum ▁ Operations ▁ = \" , minOp ( num ) ) NEW_LINE"}
{"text": "Integer terbesar yang mempunyai jumlah digit maksimum dalam julat dari 1 hingga n | berfungsi untuk mengira jumlah digit nombor. ; Mengembalikan nombor maksimum dengan jumlah maksimum digit. ; memulakan b sebagai 1 dan jumlah maksimum awal menjadi n; berulang dari kanan ke kiri dalam digit; Walaupun meleleh ini adalah nombor dari kanan ke kiri; memanggil fungsi untuk memeriksa sama ada jumlah CUR adalah lebih daripada ANS; mengurangkan nombor ke satu unit kurang; program pemacu untuk menguji fungsi di atas", "code": "def sumOfDigits ( a ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT sm = sm + a % 10 NEW_LINE a = a // 10 NEW_LINE DEDENT return sm NEW_LINE DEDENT def findMax ( x ) : NEW_LINE INDENT b = 1 NEW_LINE ans = x NEW_LINE while ( x != 0 ) : NEW_LINE INDENT cur = ( x - 1 ) * b + ( b - 1 ) NEW_LINE if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) or ( sumOfDigits ( cur ) == sumOfDigits ( ans ) and cur > ans ) ) : NEW_LINE INDENT ans = cur NEW_LINE DEDENT x = x // 10 NEW_LINE b = b * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 521 NEW_LINE print ( findMax ( n ) ) NEW_LINE"}
{"text": "Julat Interquartile (IQR) | Fungsi untuk memberi indeks median; Fungsi untuk mengira IQR; Indeks median keseluruhan data; Median separuh pertama; Median separuh kedua; Pengiraan IQR; Fungsi pemacu", "code": "def median ( a , l , r ) : NEW_LINE INDENT n = r - l + 1 NEW_LINE n = ( n + 1 ) // 2 - 1 NEW_LINE return n + l NEW_LINE DEDENT def IQR ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE mid_index = median ( a , 0 , n ) NEW_LINE Q1 = a [ median ( a , 0 , mid_index ) ] NEW_LINE Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] NEW_LINE return ( Q3 - Q1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 19 , 7 , 6 , 5 , 9 , 12 , 27 , 18 , 2 , 15 ] NEW_LINE n = len ( a ) NEW_LINE print ( IQR ( a , n ) ) NEW_LINE DEDENT"}
{"text": "Nombor palindromik terbesar dalam array | Fungsi untuk memeriksa sama ada n adalah palindrome; Cari pembahagi yang sesuai untuk mengekstrak digit terkemuka; Jika digit pertama dan terakhir tidak sama maka kembali palsu; Mengeluarkan digit terkemuka dan trailing dari nombor; Mengurangkan pembahagi dengan faktor 2 sebagai 2 digit dijatuhkan; Berfungsi untuk mencari nombor palindromik terbesar; Susun array; Jika nombor adalah palindrome; Jika tiada nombor palindromik yang dijumpai; Kod pemacu; Cetak jawapan yang diperlukan", "code": "def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n / divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) // 10 NEW_LINE divisor = divisor // 100 NEW_LINE DEDENT return True NEW_LINE DEDENT def largestPalindrome ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 232 , 54545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestPalindrome ( A , n ) ) NEW_LINE DEDENT"}
{"text": "Jumlah gandaan dua nombor di bawah n | Berfungsi untuk mengembalikan jumlah semua bilangan bulat di bawah n yang merupakan gandaan sama ada A atau B; Jika saya adalah pelbagai A atau B; Kod pemacu", "code": "def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE DEDENT"}
{"text": "Kurangkan 1 tanpa pengendali aritmetik | '' Kod pemandu", "code": "def subtractOne ( x ) : NEW_LINE INDENT return ( ( x << 1 ) + ( ~ x ) ) ; NEW_LINE DEDENT print ( subtractOne ( 13 ) ) ; NEW_LINE"}
{"text": "Nombor Pell | Hitung nombor pell; Fungsi pemacu", "code": "def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) NEW_LINE DEDENT n = 4 ; NEW_LINE print ( pell ( n ) ) NEW_LINE"}
{"text": "Mencari LCM lebih daripada dua (atau array) tanpa menggunakan GCD | Mengembalikan LCM ARR [0 .. n - 1]; Cari nilai maksimum dalam ARR []; Memulakan hasil; Cari semua faktor yang terdapat dalam dua atau lebih elemen array. x = 2; Faktor semasa. ; Untuk menyimpan indeks semua elemen array yang boleh dibahagikan dengan x. ; Sekiranya terdapat 2 atau lebih elemen array yang boleh dibahagikan dengan x. ; Kurangkan semua elemen array yang boleh dibahagikan dengan x. ; Kemudian kalikan semua elemen array yang dikurangkan; Kod pemacu", "code": "def LCM ( arr , n ) : NEW_LINE INDENT max_num = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max_num < arr [ i ] ) : NEW_LINE INDENT max_num = arr [ i ] ; NEW_LINE DEDENT DEDENT res = 1 ; NEW_LINE while ( x <= max_num ) : NEW_LINE INDENT indexes = [ ] ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % x == 0 ) : NEW_LINE INDENT indexes . append ( j ) ; NEW_LINE DEDENT DEDENT if ( len ( indexes ) >= 2 ) : NEW_LINE INDENT for j in range ( len ( indexes ) ) : NEW_LINE INDENT arr [ indexes [ j ] ] = int ( arr [ indexes [ j ] ] / x ) ; NEW_LINE DEDENT res = res * x ; NEW_LINE DEDENT else : NEW_LINE INDENT x += 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT res = res * arr [ i ] ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( LCM ( arr , n ) ) ; NEW_LINE"}
{"text": "Cari kesopanan nombor | Program Python untuk pendekatan di atas; Berfungsi untuk mencari kesopanan; sqrt (2 * n) sebagai panjang maksimum akan apabila jumlahnya bermula dari 1 yang mengikuti persamaan n ^ 2 - n - (2 * jumlah) = 0; Program pemacu untuk menguji fungsi di atas", "code": "import math NEW_LINE def politness ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , int ( math . sqrt ( 2 * n ) ) + 1 ) : NEW_LINE INDENT if ( ( 2 * n ) % i != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT a = 2 * n NEW_LINE a = a / i NEW_LINE a = a - ( i - 1 ) NEW_LINE if ( a % 2 != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT a /= 2 NEW_LINE if ( a > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 90 NEW_LINE print \" Politness ▁ of ▁ \" , n , \" ▁ = ▁ \" , politness ( n ) NEW_LINE n = 15 NEW_LINE print \" Politness ▁ of ▁ \" , n , \" ▁ = ▁ \" , politness ( n ) NEW_LINE"}
{"text": "Program untuk tekaan Goldbach (dua prima dengan jumlah yang diberikan) | Program Python3 untuk melaksanakan tekaan Goldbach; Array untuk menyimpan semua perdana kurang daripada dan sama dengan 10 ^ 6; Fungsi utiliti untuk Sieve of Sundaram; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahukan prima yang lebih kecil daripada Max, kita mengurangkan max hingga separuh. Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 * i * j dari orang lain di mana 1 <= i <= j; Logik utama Sundaram. Tandakan semua nombor yang tidak menjana nombor perdana dengan melakukan 2 * i + 1; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Berfungsi untuk melakukan sangkaan Goldbach; Kembali jika nombor tidak atau kurang daripada 3; Semak hanya separuh daripada nombor; Cari perbezaan dengan menolak perdana semasa dari n; Cari jika perbezaannya juga merupakan nombor utama; Menyatakan sebagai jumlah prima; Mencari semua nombor perdana sebelum had; Nombor Ekspres sebagai Jumlah Dua Prima", "code": "import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * ( int ( MAX / 2 ) + 100 ) ; NEW_LINE for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) / 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX / 2 ) + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( MAX / 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def findPrimes ( n ) : NEW_LINE INDENT if ( n <= 2 or n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) ; NEW_LINE return ; NEW_LINE DEDENT i = 0 ; NEW_LINE while ( primes [ i ] <= n // 2 ) : NEW_LINE INDENT diff = n - primes [ i ] ; NEW_LINE if diff in primes : NEW_LINE INDENT print ( primes [ i ] , \" + \" , diff , \" = \" , n ) ; NEW_LINE return ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT sieveSundaram ( ) ; NEW_LINE findPrimes ( 4 ) ; NEW_LINE findPrimes ( 38 ) ; NEW_LINE findPrimes ( 100 ) ; NEW_LINE"}
{"text": "K | Program python untuk mencetak faktor utama kth; Fungsi untuk menjana faktor utama nombor n dan mengembalikan faktor utama; Cari bilangan 2 yang membahagikan k; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, simpan saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes di mana n adalah nombor perdana yang lebih besar daripada 2; Program Pemandu", "code": "import math NEW_LINE def kPrimeFactor ( n , k ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT k = k - 1 NEW_LINE n = n / 2 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT k = k - 1 NEW_LINE n = n / i NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 and k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( kPrimeFactor ( n , k ) ) NEW_LINE n = 14 NEW_LINE k = 3 NEW_LINE print ( kPrimeFactor ( n , k ) ) NEW_LINE"}
{"text": "K | Program Python3 untuk mencari faktor utama menggunakan SIEVE OF ERATOSTHENES. Program ini adalah cekap apabila kita mempunyai pelbagai nombor. ; Menggunakan Sieveoferatosthenes untuk mencari faktor utama terkecil semua nombor. Sebagai contoh, jika max adalah 10, s [2] = s [4] = s [6] = s [10] = 2 s [3] = s [9] = 3 s [5] = 5 s [7] = 7; Buat array Boolean \"Perdana [0.. Max]\" dan memulakan semua penyertaan di dalamnya sebagai palsu. ; Memulakan faktor terkecil sama dengan 2 untuk semua nombor walaupun; Untuk nombor ganjil kurang kemudian sama dengan n; S (i) untuk perdana adalah nombor itu sendiri; Untuk semua gandaan nombor perdana semasa; Saya adalah faktor utama terkecil untuk nombor \"i * j\". ; Berfungsi untuk menjana faktor utama dan mengembalikan faktor utama. S [i] menyimpan faktor utama i. ; Terus membahagikan n dengan faktor utama walaupun sama ada n tidak 1 atau kiraan faktor utama bukan k. ; Untuk menjejaki kiraan faktor utama; Bahagikan N untuk mencari faktor utama seterusnya; S [i] akan menyimpan faktor utama i.", "code": "MAX = 10001 NEW_LINE def sieveOfEratosthenes ( s ) : NEW_LINE INDENT prime = [ False for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( 2 , MAX + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 ; NEW_LINE DEDENT for i in range ( 3 , MAX , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , MAX + 1 , 2 ) : NEW_LINE INDENT if j * j > MAX : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def kPrimeFactor ( n , k , s ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return s [ n ] NEW_LINE DEDENT k -= 1 NEW_LINE n //= s [ n ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT s = [ - 1 for i in range ( MAX + 1 ) ] NEW_LINE sieveOfEratosthenes ( s ) NEW_LINE n = 12 NEW_LINE k = 3 NEW_LINE print ( kPrimeFactor ( n , k , s ) ) NEW_LINE n = 14 NEW_LINE k = 3 NEW_LINE print ( kPrimeFactor ( n , k , s ) ) NEW_LINE"}
{"text": "Cari jumlah pembahagi semua pembahagi nombor semulajadi | Program Python3 untuk mencari jumlah pembahagi semua pembahagi nombor semulajadi. ; Mengembalikan jumlah pembahagi semua pembahagi N; Mengira kuasa faktor utama dan menyimpannya dalam MP MP []. ; Jika n adalah nombor perdana; Untuk setiap faktor utama, mengira (p ^ (a + 1) - 1) / (p - 1) dan menambahnya untuk menjawab. ; Kod pemacu", "code": "import math as mt NEW_LINE def sumDivisorsOfDivisors ( n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( 2 , mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % j == 0 ) : NEW_LINE INDENT n //= j NEW_LINE count += 1 NEW_LINE DEDENT if ( count ) : NEW_LINE INDENT mp [ j ] = count NEW_LINE DEDENT DEDENT if ( n != 1 ) : NEW_LINE INDENT mp [ n ] = 1 NEW_LINE DEDENT ans = 1 NEW_LINE for it in mp : NEW_LINE INDENT pw = 1 NEW_LINE summ = 0 NEW_LINE for i in range ( mp [ it ] + 1 , 0 , - 1 ) : NEW_LINE INDENT summ += ( i * pw ) NEW_LINE pw *= it NEW_LINE DEDENT ans *= summ NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 10 NEW_LINE print ( sumDivisorsOfDivisors ( n ) ) NEW_LINE"}
{"text": "Cari urutan berulang dalam pecahan | Fungsi ini mengembalikan urutan berulang pecahan. Jika mengulangi urutan tidak keluar, maka mengembalikan rentetan kosong; Memulakan hasil; Buat peta untuk menyimpan yang sudah dilihat sisa. Sisa digunakan sebagai kunci dan kedudukannya dalam hasil disimpan sebagai nilai. Perhatikan bahawa kita memerlukan kedudukan untuk kes -kes seperti 1/6. Dalam kes ini, urutan berulang tidak bermula dari sisa pertama. ; Cari sisa pertama; Terus mencari baki sehingga sama ada baki menjadi 0 atau mengulangi; Simpan selebihnya ini; Kain baki dengan 10; Tambah REM / DENR untuk menghasilkan; Baki kemas kini; Kod pemacu", "code": "def fractionToDecimal ( numr , denr ) : NEW_LINE INDENT res = \" \" NEW_LINE mp = { } NEW_LINE rem = numr % denr NEW_LINE while ( ( rem != 0 ) and ( rem not in mp ) ) : NEW_LINE INDENT mp [ rem ] = len ( res ) NEW_LINE rem = rem * 10 NEW_LINE res_part = rem // denr NEW_LINE res += str ( res_part ) NEW_LINE rem = rem % denr NEW_LINE DEDENT if ( rem == 0 ) : NEW_LINE INDENT return \" \" NEW_LINE DEDENT else : NEW_LINE INDENT return res [ mp [ rem ] : ] NEW_LINE DEDENT DEDENT numr , denr = 50 , 22 NEW_LINE res = fractionToDecimal ( numr , denr ) NEW_LINE if ( res == \" \" ) : NEW_LINE INDENT print ( \" No ▁ recurring ▁ sequence \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Recurring ▁ sequence ▁ is \" , res ) NEW_LINE DEDENT"}
{"text": "NOMBOR NOMBOR YANG MEMILIKI 0 A DENGIT | Pulangan 1 jika x mempunyai 0, lain 0; Melintasi semua digit X untuk memeriksa sama ada ia mempunyai 0 .; Jika digit semasa adalah 0, kembali benar; Mengembalikan kiraan nombor dari 1 hingga n dengan 0 sebagai digit; Mulakan kiraan nombor yang mempunyai 0 sebagai digit. ; Melintasi semua nombor dan untuk setiap nombor cek jika ia mempunyai 0 .; Program Pemandu", "code": "def has0 ( x ) : NEW_LINE INDENT while ( x != 0 ) : NEW_LINE INDENT if ( x % 10 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def getCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = count + has0 ( i ) NEW_LINE DEDENT return count NEW_LINE DEDENT n = 107 NEW_LINE print ( \" Count ▁ of ▁ numbers ▁ from ▁ 1\" , \" ▁ to ▁ \" , n , \" ▁ is ▁ \" , getCount ( n ) ) NEW_LINE"}
{"text": "Kriteria Euler (periksa jika akar persegi di bawah modulo p wujud) | Pulangan benar jika akar persegi n di bawah modulo p wujud; Satu demi satu periksa semua nombor dari 2 hingga p - 1; Kod pemacu", "code": "def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 7 NEW_LINE n = 2 NEW_LINE if ( squareRootExists ( n , p ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Formula Legendre (diberikan p dan n, cari x terbesar sedemikian rupa sehingga p^x membahagikan n!) | Mengembalikan kuasa terbesar P yang membahagikan N! ; Memulakan hasil; Kirakan x = n / p + n / (p ^ 2) + n / (p ^ 3) + .... ; Program Pemandu", "code": "def largestPower ( n , p ) : NEW_LINE INDENT x = 0 NEW_LINE while n : NEW_LINE INDENT n /= p NEW_LINE x += n NEW_LINE DEDENT return x NEW_LINE DEDENT n = 10 ; p = 3 NEW_LINE print ( \" The largest power of % d that divides % d ! is % d \" % ( p , n , largestPower ( n , p ) ) ) NEW_LINE"}
{"text": "Program untuk faktorial nombor | Program Python 3 untuk mencari faktorial nombor yang diberikan; Baris tunggal untuk mencari faktorial; Kod pemacu", "code": "def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT num = 5 NEW_LINE print ( \" Factorial ▁ of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"}
{"text": "Semua tentang manipulasi bit | Berfungsi untuk mendapatkan bit pada kedudukan ITH; Kembali benar jika bit ditetapkan. Sebaliknya kembali palsu", "code": "def getBit ( num , i ) : NEW_LINE INDENT return ( ( num & ( 1 << i ) ) != 0 ) NEW_LINE DEDENT"}
{"text": "Semua tentang manipulasi bit | Berfungsi untuk membersihkan sedikit nombor n; Buat topeng untuk bit ith tidak teratur; Kembalikan nilai kemas kini", "code": "def clearBit ( num , i ) : NEW_LINE INDENT mask = ~ ( 1 << i ) NEW_LINE return num & mask NEW_LINE DEDENT"}
{"text": "Jumlah bitwise dan setiap elemen array dengan unsur -unsur array lain | Berfungsi untuk mengira dan jumlah untuk setiap elemen array; Mengisytiharkan pelbagai saiz 32 untuk menyimpan kiraan setiap bit; Melintasi array arr2 [] dan simpan kiraan sedikit dalam array kekerapan; Kedudukan bit semasa; Walaupun NUM lebih besar daripada 0; Memeriksa jika bit ith ditetapkan atau tidak; Kenaikan kiraan sedikit demi satu; Meningkatkan kedudukan bit oleh satu; Kanan beralih num oleh satu; Melintasi Arr2 []; Simpan nilai bit ith; Jumlah jumlah yang diperlukan; Melintasi julat [0, 31]; Cek jika bit semasa ditetapkan; Kenaikan jumlah bitwise dengan kekerapan [bit_position] * value_at_that_bit; Shift kanan dengan satu; Shift kiri vale_at_that_bit oleh satu; Cetak Jumlah yang diperolehi untuk nombor ith di arr1 []; Kod pemacu; Diberikan arr1 []; Diberikan ARR2; Saiz arr1 []; Saiz arr2 []; Panggilan fungsi", "code": "def Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) : NEW_LINE INDENT frequency = [ 0 ] * 32 NEW_LINE for i in range ( N ) : NEW_LINE INDENT bit_position = 0 NEW_LINE num = arr1 [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT frequency [ bit_position ] += 1 NEW_LINE DEDENT bit_position += 1 NEW_LINE num >>= 1 NEW_LINE DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT num = arr2 [ i ] NEW_LINE value_at_that_bit = 1 NEW_LINE bitwise_AND_sum = 0 NEW_LINE for bit_position in range ( 32 ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit NEW_LINE DEDENT num >>= 1 NEW_LINE value_at_that_bit <<= 1 NEW_LINE DEDENT print ( bitwise_AND_sum , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 1 , 2 , 3 ] NEW_LINE N = len ( arr1 ) NEW_LINE M = len ( arr2 ) NEW_LINE Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) NEW_LINE DEDENT"}
{"text": "Matikan Bit Set Bit | Tetapkan 2 | Tidak menetapkan bit set yang paling kanan dan mengembalikan hasilnya; Memeriksa sama ada kedudukan bit ditetapkan atau tidak; Jika kedudukan bit ditemui, kami flip sedikit ini dengan nombor dan nombor yang diberikan dengan set kedudukan bit; Kod pemacu", "code": "def FlipBits ( n ) : NEW_LINE INDENT for bit in range ( 32 ) : NEW_LINE INDENT if ( ( n >> bit ) & 1 ) : NEW_LINE INDENT n = n ^ ( 1 << bit ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( \" The ▁ number ▁ after ▁ unsetting ▁ the \" , end = \" ▁ \" ) NEW_LINE print ( \" rightmost ▁ set ▁ bit \" , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 ; NEW_LINE FlipBits ( N ) NEW_LINE DEDENT"}
{"text": "Bitwise dan semua nombor ganjil dari 1 hingga n | Berfungsi untuk mengembalikan bitwise dan semua bilangan bulat ganjil dari julat [1, n]; Memulakan hasil kepada 1; Bermula dari 3, bitwise dan semua bilangan bulat ganjil kurang daripada atau sama dengan n; Kod pemacu", "code": "def bitwiseAndOdd ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT result = ( result & i ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 ; NEW_LINE print ( bitwiseAndOdd ( n ) ) ; NEW_LINE DEDENT"}
{"text": "Bitwise dan semua nombor ganjil dari 1 hingga n | Berfungsi untuk mengembalikan bitwise dan semua bilangan bulat ganjil dari julat [1, n]; Kod pemacu", "code": "def bitwiseAndOdd ( n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT n = 10 NEW_LINE print ( bitwiseAndOdd ( n ) ) NEW_LINE"}
{"text": "Cara untuk memecah array ke dalam dua kumpulan nilai XOR yang sama | Kembalikan kiraan bilangan cara untuk memecah array ke dalam dua kumpulan supaya setiap kumpulan mempunyai nilai XOR yang sama. ; Kita boleh berpecah hanya jika XOR adalah 0. Oleh kerana XOR semua adalah 0, kita boleh mempertimbangkan semua subset sebagai satu kumpulan. ; Program Pemandu", "code": "def countgroup ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT if xs == 0 : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countgroup ( a , n ) ) NEW_LINE"}
{"text": "Ekstrak 'k' bit dari kedudukan tertentu dalam nombor. | Berfungsi untuk mengekstrak k bit dari kedudukan p dan mengembalikan nilai yang diekstrak sebagai integer; Nombor adalah dari mana bit 'k' diekstrak dari kedudukan p", "code": "def bitExtracted ( number , k , p ) : NEW_LINE INDENT return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; NEW_LINE DEDENT number = 171 NEW_LINE k = 5 NEW_LINE p = 2 NEW_LINE print \" The ▁ extracted ▁ number ▁ is ▁ \" , bitExtracted ( number , k , p ) NEW_LINE"}
{"text": "Memaksimumkan nombor nombor yang tidak ditandatangani dengan menukar bit di kedudukan yang melampau. | Program Python 3 untuk mencari nombor maksimum dengan menukar bit melampau. ; Melintasi bit dari kedua -dua ekstrem; Mendapatkan bit i - th dan j - th; Menukar bit jika lebih rendah penting adalah lebih besar daripada bit yang lebih tinggi dan dengan sewajarnya mengubah suai nombor; Kod pemacu", "code": "def findMax ( num ) : NEW_LINE INDENT num_copy = num NEW_LINE j = 4 * 8 - 1 ; NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT x = ( 1 << i 1 << j ) NEW_LINE num = num ^ x NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 4 NEW_LINE print ( findMax ( num ) ) NEW_LINE DEDENT"}
{"text": "Periksa dengan cekap sama ada n adalah pelbagai 4 atau tidak | fungsi untuk memeriksa sama ada 'n' adalah pelbagai 4 atau tidak; jika benar, maka 'n' adalah pelbagai 4; lain 'n' bukanlah pelbagai 4; Kod pemacu", "code": "def isAMultipleOf4 ( n ) : NEW_LINE INDENT if ( ( n & 3 ) == 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT return \" No \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 16 NEW_LINE print ( isAMultipleOf4 ( n ) ) NEW_LINE DEDENT"}
{"text": "Kirakan persegi nombor tanpa menggunakan *, / dan pow () | Penyelesaian mudah untuk mengira persegi tanpa menggunakan * dan pow (); mengendalikan input negatif; Memulakan hasil; Tambah n ke res n - 1 kali; Kod pemacu", "code": "def square ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT res = n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res += n NEW_LINE DEDENT return res NEW_LINE DEDENT for n in range ( 1 , 6 ) : NEW_LINE INDENT print ( \" n ▁ = \" , n , end = \" , ▁ \" ) NEW_LINE print ( \" n ^ 2 ▁ = \" , square ( n ) ) NEW_LINE DEDENT"}
{"text": "Cari titik yang terletak di dalam Kuadrat yang tepat K yang diberikan | Python 3 pelaksanaan pendekatan di atas; Kod pemacu", "code": "def PointInKSquares ( n , a , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return a [ n - k ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 2 NEW_LINE a = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE x = PointInKSquares ( n , a , k ) NEW_LINE print ( \" ( \" , x , \" , \" , x , \" ) \" ) NEW_LINE DEDENT"}
{"text": "Bilangan N digit Nombor Langkah | Penyelesaian Dioptimumkan Ruang | fungsi yang mengira jawapannya; DP [J] Kedai kiraan saya angka melangkah angka yang berakhir dengan digit j. ; Untuk menyimpan resu1lt panjang i - 1 sebelum mengemas kini dp [j] untuk panjang i. ; Jika n adalah 1 maka jawapannya akan menjadi 10 .; Memulakan nilai untuk mengira digit sama dengan 1 .; Mengira nilai untuk mengira digit lebih daripada 1 .; Jika angka berakhir adalah 0; Jika angka berakhir adalah 9; Untuk digit lain. ; menyimpan jawapan terakhir; Kod pemacu", "code": "def answer ( n ) : NEW_LINE INDENT dp = [ 0 ] * 10 NEW_LINE prev = [ 0 ] * 10 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT dp [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT prev [ j ] = dp [ j ] NEW_LINE DEDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ j ] = prev [ j + 1 ] NEW_LINE DEDENT elif ( j == 9 ) : NEW_LINE INDENT dp [ j ] = prev [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT sum = sum + dp [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 2 NEW_LINE print ( answer ( n ) ) NEW_LINE"}
{"text": "Perubahan minimum diperlukan untuk membuat urutan Catalan | Pelaksanaan Python3 pendekatan; Untuk menyimpan nombor N First N; Berfungsi untuk mencari nombor N Catalan pertama; Memulakan dua nilai pertama dalam jadual; Isi penyertaan di Catalan [] menggunakan formula rekursif; Berfungsi untuk mengembalikan perubahan minimum yang diperlukan; Cari nombor N Catalan pertama; A dan B adalah dua nombor urutan Catalan pertama; Masukkan unsur -unsur Catalan pertama untuk ditetapkan; Jika elemen Catalan hadir dalam array kemudian keluarkannya dari set; Kembalikan bilangan elemen dalam set; Kod pemacu", "code": "MAX = 100000 ; NEW_LINE catalan = [ 0 ] * MAX ; NEW_LINE def catalanDP ( n ) : NEW_LINE INDENT catalan [ 0 ] = catalan [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT def CatalanSequence ( arr , n ) : NEW_LINE INDENT catalanDP ( n ) ; NEW_LINE s = set ( ) ; NEW_LINE a = 1 ; b = 1 ; NEW_LINE s . add ( a ) ; NEW_LINE if ( n >= 2 ) : NEW_LINE INDENT s . add ( b ) ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT s . add ( catalan [ i ] ) ; NEW_LINE DEDENT temp = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s : NEW_LINE INDENT temp . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT s = s - temp ; NEW_LINE return len ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 41 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( CatalanSequence ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Jumlah semua nombor komposit dari indeks ganjil array yang diberikan | Berfungsi untuk mencetak jumlah semua nombor komposit dalam array; Berulang untuk indeks ganjil dalam array; Semak sama ada nombor itu komposit kemudian tambahkannya ke jumlah; mengembalikan jumlahnya; Berfungsi untuk memeriksa nombor komposit; Periksa sama ada faktor lebih besar daripada 2; Semak sama ada nombor itu komposit atau tidak; Kod pemacu", "code": "def odd_indices ( arr ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , len ( arr ) , 2 ) : NEW_LINE INDENT check = composite ( arr [ k ] ) NEW_LINE sum += arr [ k ] if check == 1 else 0 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT def composite ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE c = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % j == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c >= 3 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT return flag NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 13 , 5 , 8 , 16 , 25 ] NEW_LINE odd_indices ( arr ) NEW_LINE DEDENT"}
{"text": "Pertanyaan pada kiraan mata terletak di dalam bulatan | Program Python 3 untuk mencari bilangan mata yang terletak di dalam atau di lilitan bulatan untuk pertanyaan Q. ; Pengkomputeran X ^ 2 + y ^ 2 untuk setiap titik yang diberikan dan menyusunnya. ; Kembali kiraan mata terletak di dalam atau pada lilitan bulatan menggunakan carian binari pada p [0. n - 1]; Kod pemacu; Kirakan jarak semua mata dan simpan jarak yang disusun supaya pertanyaan dapat berfungsi dalam O (logn) menggunakan carian binari. ; Cetak nombor mata dalam lingkaran radius 3 .; Cetak nombor mata dalam lingkaran radius 32.", "code": "import math NEW_LINE def preprocess ( p , x , y , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT p . sort ( ) NEW_LINE DEDENT def query ( p , n , rad ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE while ( ( end - start ) > 1 ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE tp = math . sqrt ( p [ mid ] ) NEW_LINE if ( tp > ( rad * 1.0 ) ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT tp1 = math . sqrt ( p [ start ] ) NEW_LINE tp2 = math . sqrt ( p [ end ] ) NEW_LINE if ( tp1 > ( rad * 1.0 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( tp2 <= ( rad * 1.0 ) ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return start + 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = [ 1 , 2 , 3 , - 1 , 4 ] NEW_LINE y = [ 1 , 2 , 3 , - 1 , 4 ] NEW_LINE n = len ( x ) NEW_LINE p = [ 0 ] * n NEW_LINE preprocess ( p , x , y , n ) NEW_LINE print ( query ( p , n , 3 ) ) NEW_LINE print ( query ( p , n , 32 ) ) NEW_LINE DEDENT"}
{"text": "Count bilangan panjang n mempunyai nombor perdana pada indeks ganjil dan nombor ganjil pada indeks walaupun | Program Python untuk pendekatan di atas; Tiada indeks ganjil dalam nombor n - digit; Tidak ada indeks dalam nombor n - digit; Tidak ada cara untuk mengatur digit nombor utama dalam indeks ganjil; Tidak ada cara untuk mengatur digit nombor ganjil dalam indeks walaupun; mengembalikan jumlah cara; Kod pemacu; memanggil fungsi", "code": "def count ( N ) : NEW_LINE INDENT odd_indices = N // 2 NEW_LINE even_indices = N // 2 + N % 2 NEW_LINE arrange_odd = 4 ** odd_indices NEW_LINE arrange_even = 5 ** even_indices NEW_LINE return arrange_odd * arrange_even NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE print ( count ( N ) ) NEW_LINE DEDENT"}
{"text": "Semak jika array yang diberikan disusun secara lingkaran atau tidak | Berfungsi untuk memeriksa sama ada array disusun secara rohani atau tidak; Kedai memulakan indeks array; Kedai akhir indeks array; Jika arr [mula] lebih besar daripada arr [end]; Kemas kini Mula; Jika arr [end] lebih besar daripada arr [start]; Akhir kemas kini; Kod pemacu; Panggilan fungsi", "code": "def isSpiralSorted ( arr , n ) : NEW_LINE INDENT start = 0 ; NEW_LINE end = n - 1 ; NEW_LINE while ( start < end ) : NEW_LINE INDENT if ( arr [ start ] > arr [ end ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT start += 1 ; NEW_LINE if ( arr [ end ] > arr [ start ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT end -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 10 , 14 , 20 , 18 , 12 , 5 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE if ( isSpiralSorted ( arr , N ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"}
{"text": "Cetak semua rentetan dari array yang diberikan yang boleh ditaip menggunakan kekunci dari satu baris papan kekunci QWERTY | Berfungsi untuk mencetak semua rentetan yang boleh ditaip menggunakan kunci satu baris dalam papan kekunci QWERTY; Kedai baris nombor semua watak yang mungkin dari rentetan; Melintasi array; Jika rentetan semasa bukan rentetan kosong; Menetapkan benar / palsu jika rentetan boleh ditaip menggunakan kunci satu baris atau tidak; Kedai baris nombor watak pertama rentetan semasa; Kedai panjang perkataan; Melintasi rentetan semasa; Jika watak semasa tidak boleh ditaip menggunakan kekunci rownum sahaja; Bendera kemas kini; Jika rentetan semasa boleh ditaip menggunakan kekunci dari rownum sahaja; Cetak rentetan; Kod pemacu", "code": "def findWordsSameRow ( arr ) : NEW_LINE INDENT mp = { ' q ' : 1 , ' w ' : 1 , ' e ' : 1 , ' r ' : 1 , ' t ' : 1 , ' y ' : 1 , ' u ' : 1 , ' o ' : 1 , ' p ' : 1 , ' i ' : 1 , ' a ' : 2 , ' s ' : 2 , ' d ' : 2 , ' f ' : 2 , ' g ' : 2 , ' h ' : 2 , ' j ' : 2 , ' k ' : 2 , ' l ' : 2 , ' z ' : 3 , ' x ' : 3 , ' c ' : 3 , ' v ' : 3 , ' b ' : 3 , ' n ' : 3 , ' m ' : 3 } NEW_LINE for word in arr : NEW_LINE INDENT if ( len ( word ) != 0 ) : NEW_LINE INDENT flag = True NEW_LINE rowNum = mp [ word [ 0 ] . lower ( ) ] NEW_LINE M = len ( word ) NEW_LINE for i in range ( 1 , M ) : NEW_LINE INDENT if ( mp [ word [ i ] . lower ( ) ] != rowNum ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( word , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT words = [ \" Yeti \" , \" Had \" , \" GFG \" , \" comment \" ] NEW_LINE findWordsSameRow ( words ) NEW_LINE"}
{"text": "Kiraan quadruples jenis yang diberikan dari array yang diberikan | Program Python3 pendekatan di atas; Fungsi untuk mencari kiraan jenis berikutnya; Menyimpan kiraan quadruples; Menjana semua kemungkinan kombinasi quadruples; Semak jika elemen 1 ST sama dengan elemen 3 RD; Semak jika elemen 2 ND adalah sama dengan elemen ke -4; Kod pemacu", "code": "maxN = 2002 NEW_LINE def countSubsequece ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( a [ j ] == a [ l ] and a [ i ] == a [ k ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 3 , 2 , 1 , 3 , 2 ] NEW_LINE print ( countSubsequece ( a , 7 ) ) NEW_LINE DEDENT"}
{"text": "Watak terkecil dalam rentetan yang mempunyai jumlah minimum jarak antara pengulangan berturut -turut | Program Python3 untuk pendekatan di atas; Berfungsi untuk mencari watak berulang dengan jarak minimum; Menyimpan indeks pertama dan terakhir; Intialize dengan - 1; Dapatkan nilai kejadian terakhir dan pertama; Mengemas kini indeks pertama; Mengemas kini indeks terakhir; INTIALIZE MIN; Dapatkan minimum; Nilai tidak boleh sama; Mengemas kini jarak minimum; kembali Ans; Kod pemacu; Panggilan fungsi", "code": "import sys NEW_LINE def minDistChar ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE first = [ ] NEW_LINE last = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT first . append ( - 1 ) NEW_LINE last . append ( - 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( first [ ord ( s [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT first [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i NEW_LINE DEDENT last [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i NEW_LINE DEDENT min = sys . maxsize NEW_LINE ans = '1' NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( last [ i ] == first [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( min > last [ i ] - first [ i ] ) : NEW_LINE INDENT min = last [ i ] - first [ i ] NEW_LINE ans = i + ord ( ' a ' ) NEW_LINE DEDENT DEDENT return chr ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE print ( minDistChar ( str ) ) NEW_LINE DEDENT"}
{"text": "Langkah -langkah minimum yang diperlukan untuk mencapai akhir matriks | Tetapkan 2 | Python 3 pelaksanaan pendekatan; Berfungsi untuk mengembalikan langkah minimum yang diperlukan untuk mencapai akhir matriks; Array untuk menentukan sama ada sel telah dikunjungi sebelum ini; Giliran untuk BFS; Untuk menyimpan kedalaman carian; Algoritma BFS; Saiz giliran semasa; Atas - kebanyakan elemen barisan; Untuk menyimpan indeks sel untuk kesederhanaan; Kes asas; Jika kita mencapai (n - 1, n - 1); Menandakan sel yang dikunjungi; Menolak sel -sel bersebelahan dalam barisan yang boleh dikunjungi dari sel semasa; Kod pemacu", "code": "n = 3 NEW_LINE def minSteps ( arr ) : NEW_LINE INDENT v = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE q = [ [ 0 , 0 ] ] NEW_LINE depth = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT x = len ( q ) NEW_LINE while ( x > 0 ) : NEW_LINE INDENT y = q [ 0 ] NEW_LINE i = y [ 0 ] NEW_LINE j = y [ 1 ] NEW_LINE q . remove ( q [ 0 ] ) NEW_LINE x -= 1 NEW_LINE if ( v [ i ] [ j ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return depth NEW_LINE DEDENT v [ i ] [ j ] = 1 NEW_LINE if ( i + arr [ i ] [ j ] < n ) : NEW_LINE INDENT q . append ( [ i + arr [ i ] [ j ] , j ] ) NEW_LINE DEDENT if ( j + arr [ i ] [ j ] < n ) : NEW_LINE INDENT q . append ( [ i , j + arr [ i ] [ j ] ] ) NEW_LINE DEDENT DEDENT depth += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE print ( minSteps ( arr ) ) NEW_LINE DEDENT"}
{"text": "Jurang terbesar dalam array | Program Python 3 untuk mencari jurang terbesar antara dua elemen dalam array. ; fungsi untuk menyelesaikan masalah yang diberikan; Kod pemacu", "code": "import sys NEW_LINE def solve ( a , n ) : NEW_LINE INDENT max1 = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT for j in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( abs ( a [ i ] - a [ j ] ) > max1 ) : NEW_LINE INDENT max1 = abs ( a [ i ] - a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return max1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 1 , 2 , 3 , - 4 , - 10 , 22 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Largest ▁ gap ▁ is ▁ : \" , solve ( arr , size ) ) NEW_LINE DEDENT"}
{"text": "Jurang terbesar dalam array | fungsi untuk menyelesaikan masalah yang diberikan; mencari maksimum dan minimum array; Kod pemacu", "code": "def solve ( a , n ) : NEW_LINE INDENT min1 = a [ 0 ] NEW_LINE max1 = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max1 ) : NEW_LINE INDENT max1 = a [ i ] NEW_LINE DEDENT if ( a [ i ] < min1 ) : NEW_LINE INDENT min1 = a [ i ] NEW_LINE DEDENT DEDENT return abs ( min1 - max1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 1 , 2 , 3 , 4 , - 10 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Largest ▁ gap ▁ is ▁ : ▁ \" , solve ( arr , size ) ) NEW_LINE DEDENT"}
{"text": "Cetak rentetan terbalik selepas mengeluarkan vokal | Fungsi untuk menggantikan rentetan; memulakan rentetan panjang n; Melintasi semua aksara rentetan; Berikan nilai kepada rentetan r dari indeks terakhir rentetan s; jika S [i] adalah konsonan maka cetak r [i]; Kod pemacu", "code": "def replaceOriginal ( s , n ) : NEW_LINE INDENT r = [ ' ▁ ' ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE n = len ( s ) NEW_LINE replaceOriginal ( s , n ) NEW_LINE DEDENT"}
{"text": "Semak jika rentetan boleh dibuat sama dengan rentetan lain dengan menukar atau penggantian aksara | Fungsi untuk mencari jika rentetan yang diberikan adalah sama atau tidak; Keadaan asas; Kedai kekerapan aksara str1 dan str2; Traverse Strings str1 & str2 dan frekuensi kedai dalam [] dan b []; Semak sama ada kedua -dua rentetan mempunyai aksara yang sama atau tidak; Jika watak hadir dalam satu dan tidak dalam rentetan lain, kembali palsu; Susun array A [] dan B []; Periksa Array A dan B mengandungi kekerapan yang sama atau tidak; Jika frekuensi tidak sama selepas menyusun; Pada ketika ini, Str1 boleh ditukar kepada Str2; Kod pemacu", "code": "def sameStrings ( str1 , str2 ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE M = len ( str2 ) NEW_LINE if ( N != M ) : NEW_LINE INDENT return False NEW_LINE DEDENT a , b = [ 0 ] * 256 , [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE b [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT i = 0 NEW_LINE while ( i < 256 ) : NEW_LINE INDENT if ( ( a [ i ] == 0 and b [ i ] == 0 ) or ( a [ i ] != 0 and b [ i ] != 0 ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = sorted ( a ) NEW_LINE b = sorted ( b ) NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S1 , S2 = \" cabbba \" , \" abbccc \" NEW_LINE if ( sameStrings ( S1 , S2 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Kurangkan tiga nombor dengan menurunkan pasangan | Berfungsi untuk mencari operasi nombor minimum; Masukkan tiga nombor dalam array; Susun array; Kes 2; Kes 1; Kod pemacu; Diberikan a, b, c; Panggilan fungsi", "code": "def solution ( A , B , C ) : NEW_LINE INDENT arr = [ 0 ] * 3 NEW_LINE arr [ 0 ] = A NEW_LINE arr [ 1 ] = B NEW_LINE arr [ 2 ] = C NEW_LINE arr = sorted ( arr ) NEW_LINE if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) : NEW_LINE INDENT return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 8 NEW_LINE B = 1 NEW_LINE C = 5 NEW_LINE print ( solution ( A , B , C ) ) NEW_LINE DEDENT"}
{"text": "Cari elemen dalam array yang disusun dan diputar dengan pendua | Berfungsi untuk mengembalikan indeks kunci dalam arr [l. . h] jika kunci hadir sebaliknya kembali - 1; Kes yang rumit, hanya kemas kini kiri dan kanan; Jika arr [l ... pertengahan] disusun; Oleh kerana subarray ini disusun, kita dapat dengan cepat memeriksa sama ada kunci terletak pada mana -mana bahagian; Jika kunci tidak terletak pada separuh pertama subarray maka bahagikan separuh lagi ke dalam dua subarray sehingga kita dapat dengan cepat memeriksa apakah kunci terletak pada separuh lagi; Jika arr [l. . pertengahan] subarray pertama tidak disusun kemudian arr [pertengahan ... h] mesti disusun subarray; Kod pemacu", "code": "def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT mid = ( l + h ) // 2 ; NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( ( arr [ l ] == arr [ mid ] ) and ( arr [ h ] == arr [ mid ] ) ) : NEW_LINE INDENT l += 1 ; NEW_LINE h -= 1 ; NEW_LINE return search ( arr , l , h , key ) NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) ; NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) ; NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) ; NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 1 , 2 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE key = 3 ; NEW_LINE print ( search ( arr , 0 , n - 1 , key ) ) ; NEW_LINE DEDENT"}
{"text": "Kes | Berfungsi untuk mengembalikan rentetan yang disusun; Vektor untuk menyimpan huruf kecil dan huruf besar; Menyusun kedua -dua vektor; Jika watak semasa adalah huruf kecil kemudian pilih watak huruf kecil dari senarai yang disusun; Lain memilih watak huruf besar; Kembalikan rentetan yang disusun; Kod pemacu", "code": "def getSortedString ( s , n ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] >= ' a ' and s [ i ] <= ' z ' ) : NEW_LINE INDENT v1 . append ( s [ i ] ) NEW_LINE DEDENT if ( s [ i ] >= ' A ' and s [ i ] <= ' Z ' ) : NEW_LINE INDENT v2 . append ( s [ i ] ) NEW_LINE DEDENT DEDENT v1 = sorted ( v1 ) NEW_LINE v2 = sorted ( v2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if ( s [ k ] >= ' a ' and s [ k ] <= ' z ' ) : NEW_LINE INDENT s [ k ] = v1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( s [ k ] >= ' A ' and s [ k ] <= ' Z ' ) : NEW_LINE INDENT s [ k ] = v2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return \" \" . join ( s ) NEW_LINE DEDENT s = \" gEeksfOrgEEkS \" NEW_LINE ss = [ i for i in s ] NEW_LINE n = len ( ss ) NEW_LINE print ( getSortedString ( ss , n ) ) NEW_LINE"}
{"text": "Semak jika rentetan mengandungi huruf berturut -turut dan setiap huruf berlaku tepat sekali | Berfungsi untuk memeriksa sama ada keadaan memegang; Dapatkan panjang rentetan; Susun rentetan yang diberikan; ITERATE untuk setiap indeks dan periksa keadaan; Jika tidak berturut -turut; Kod pemacu; Contoh 1 st; Contoh 2 nd", "code": "def check ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s = ' ' . join ( sorted ( s ) ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" dcef \" NEW_LINE if check ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT string = \" xyza \" NEW_LINE if check ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Subset terkecil dengan jumlah yang lebih besar daripada semua elemen lain | Fungsi untuk mencari elemen minimum yang diperlukan. ; mengira separuh daripada jumlah array; Susun array dalam urutan menurun. ; jumlah semasa lebih besar daripada jumlah; kod pemacu", "code": "def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum / 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 1 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minElements ( arr , n ) ) NEW_LINE"}
{"text": "Peningkatan dan penurunan minimum oleh k setiap elemen pasangan yang diperlukan untuk membuat semua elemen array sama | Berfungsi untuk memeriksa sama ada mungkin untuk membuat semua elemen array sama atau tidak; Menyimpan jumlah array; Melintasi array; Jika jumlahnya boleh dibahagikan dengan n; Jika tidak, tidak mungkin untuk membuat semua elemen array sama; Diberikan array; Saiz array", "code": "def arrayElementEqual ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % N == 0 ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 6 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE arrayElementEqual ( arr , N ) NEW_LINE"}
{"text": "Susun semula Arahan untuk memaksimumkan jumlah GCD unsur -unsur array dengan indeks masing -masing | Berfungsi untuk mencari jumlah maksimum GCD (arr [i], i) dengan menyusun semula array; Kedai maksimum jumlah GCD (arr [i], i) dengan menyusun semula elemen array; Kemas kini res; Kod pemacu", "code": "def findMaxValByRearrArr ( arr , N ) : NEW_LINE INDENT res = 0 ; NEW_LINE res = ( N * ( N + 1 ) ) // 2 ; NEW_LINE return res ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 1 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE print ( findMaxValByRearrArr ( arr , N ) ) ; NEW_LINE DEDENT"}
{"text": "Poligon dengan sisi maksimum yang boleh ditulis dalam N | Berfungsi untuk mencari poligon maksimum yang boleh ditulis; Kes asas; Kembali n / 2 jika n adalah sebaliknya, kembali - 1; Kod pemacu; Diberikan n; Panggilan fungsi", "code": "def MaximumSides ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE print ( MaximumSides ( N ) ) NEW_LINE DEDENT"}
{"text": "Purata array yang dihasilkan oleh produk semua pasang array yang diberikan | Fungsi untuk mencari min pasangan array arr []; Memulakan array jumlah akhiran; Membina array Jumlah Akhiran; Saiz pairproductarray; Kedai Jumlah PairProductArray; Simpan min; Cari min PairProductArray; Mengembalikan maksud yang dihasilkan; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "def pairProductMean ( arr , N ) : NEW_LINE INDENT suffixSumArray = [ 0 ] * N NEW_LINE suffixSumArray [ N - 1 ] = arr [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] NEW_LINE DEDENT length = ( N * ( N - 1 ) ) // 2 NEW_LINE res = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT res += arr [ i ] * suffixSumArray [ i + 1 ] NEW_LINE DEDENT mean = 0 NEW_LINE if ( length != 0 ) : NEW_LINE INDENT mean = res / length NEW_LINE DEDENT else : NEW_LINE INDENT mean = 0 NEW_LINE DEDENT return mean NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE print ( round ( pairProductMean ( arr , N ) , 2 ) ) NEW_LINE DEDENT"}
{"text": "Kurangkan kiraan laluan unik dari kiri atas ke kanan bawah matriks dengan meletakkan k 1 s | Berfungsi untuk mengembalikan nilai pekali binomial C (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Berfungsi untuk mencari kiraan minimum laluan dari kiri ke bawah ke bawah kanan dengan meletakkan k 1 s dalam matriks; Mengira cara tanpa 1 s; Mengira laluan dari memulakan POTO Mid Point; Count Paths dari Mid Poto End Point; Kod pemacu", "code": "def ncr ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countPath ( N , M , K ) : NEW_LINE INDENT answer = 0 NEW_LINE if ( K >= 2 ) : NEW_LINE INDENT answer = 0 NEW_LINE DEDENT elif ( K == 0 ) : NEW_LINE INDENT answer = ncr ( N + M - 2 , N - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT answer = ncr ( N + M - 2 , N - 1 ) NEW_LINE X = ( N - 1 ) // 2 + ( M - 1 ) // 2 NEW_LINE Y = ( N - 1 ) // 2 NEW_LINE midCount = ncr ( X , Y ) NEW_LINE X = ( ( N - 1 ) - ( N - 1 ) // 2 ) + NEW_LINE INDENT ( ( M - 1 ) - ( M - 1 ) // 2 ) NEW_LINE DEDENT Y = ( ( N - 1 ) - ( N - 1 ) // 2 ) NEW_LINE midCount *= ncr ( X , Y ) NEW_LINE answer -= midCount NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE K = 1 NEW_LINE print ( countPath ( N , M , K ) ) NEW_LINE DEDENT"}
{"text": "Bilangan maksimum operasi yang diperlukan supaya tiada pasangan dari tumpang tindih matriks | Berfungsi untuk mencari kiraan maksimum operasi; Inisialisasi kiraan oleh 0; Melangkah ke atas pasangan yang tinggal; Semak jika operasi pertama terpakai; Semak jika operasi 2 ND terpakai; Jika tidak; Mengembalikan kiraan operasi; Kod pemacu", "code": "def find_max ( v , n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n >= 2 ) : NEW_LINE INDENT count = 2 NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( v [ i - 1 ] [ 0 ] > ( v [ i ] [ 0 ] + v [ i ] [ 1 ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif ( v [ i + 1 ] [ 0 ] > ( v [ i ] [ 0 ] + v [ i ] [ 1 ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE v [ i ] [ 0 ] = v [ i ] [ 0 ] + v [ i ] [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE v = [ ] NEW_LINE v . append ( [ 10 , 20 ] ) NEW_LINE v . append ( [ 15 , 10 ] ) NEW_LINE v . append ( [ 20 , 16 ] ) NEW_LINE print ( find_max ( v , n ) ) NEW_LINE"}
{"text": "Count substrings yang dibentuk menggunakan set aksara yang diberikan sahaja | Fungsi untuk mencari bilangan substring yang boleh dibentuk menggunakan aksara yang diberikan; Array Boolean untuk menyimpan watak -watak yang tersedia; Tandakan indeks semua aksara yang tersedia sebagai 1; Memulakan lastpos sebagai - 1; Inisialisasi ANS dengan jumlah tidak mungkin substrings yang mungkin; Melintasi rentetan dari kiri ke kanan; Jika watak semasa tidak hadir dalam B; Tolak jumlah substrings yang mungkin; Kemas kini nilai LastPOS ke indeks semasa; Cetak jawapan terakhir; Diberikan rentetan; Diberikan pelbagai watak; Panggilan fungsi", "code": "def numberofsubstrings ( str , k , charArray ) : NEW_LINE INDENT N = len ( str ) NEW_LINE available = [ 0 ] * 26 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT available [ ord ( charArray [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT lastPos = - 1 NEW_LINE ans = ( N * ( N + 1 ) ) / 2 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( available [ ord ( str [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT ans -= ( ( i - lastPos ) * ( N - i ) ) NEW_LINE lastPos = i NEW_LINE DEDENT DEDENT print ( int ( ans ) ) NEW_LINE DEDENT str = \" abcb \" NEW_LINE k = 2 NEW_LINE charArray = [ ' a ' , ' b ' ] NEW_LINE numberofsubstrings ( str , k , charArray ) NEW_LINE"}
{"text": "Kos minimum untuk mencapai titik n dari 0 dengan dua operasi yang berbeza dibenarkan | Berfungsi untuk mengembalikan kos minimum untuk mencapai tujuan; Memulakan kos kepada 0; pergi ke belakang sehingga kita mencapai kedudukan awal; Jika 2 * x melompat lebih baik daripada x + 1; Jika lompat x + 1 lebih baik; Program Pemandu", "code": "def minCost ( N , P , Q ) : NEW_LINE INDENT cost = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT cost += P NEW_LINE N -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = N // 2 ; NEW_LINE if ( temp * P > Q ) : NEW_LINE INDENT cost += Q NEW_LINE DEDENT else : NEW_LINE INDENT cost += P * temp NEW_LINE DEDENT N //= 2 NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT N = 9 NEW_LINE P = 5 NEW_LINE Q = 1 NEW_LINE print ( minCost ( N , P , Q ) ) NEW_LINE"}
{"text": "Bilangan cara untuk mencapai pada node permulaan selepas perjalanan melalui tepi K dalam graf lengkap | Fungsi untuk mencari bilangan cara untuk mencapai dari nod 1 hingga 1 sekali lagi, selepas bergerak tepat K tepi; Memulakan array dp [], di mana dp [i] menyimpan bilangan cara untuk mencapai nod; Kes asas; Berulang untuk bilangan tepi bergerak; Jumlah akan menyimpan beberapa cara untuk mencapai semua nod; Berulang untuk setiap keadaan yang mungkin untuk langkah semasa; Kemas kini nilai array DP selepas perjalanan setiap kelebihan; Cetak dp [0] sebagai jawapannya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "def numberOfWays ( n , k ) : NEW_LINE INDENT dp = [ 0 for i in range ( 1000 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , k + 1 , 1 ) : NEW_LINE INDENT numWays = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT numWays += dp [ j ] NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT dp [ j ] = numWays - dp [ j ] NEW_LINE DEDENT DEDENT print ( dp [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE K = 3 NEW_LINE numberOfWays ( N , K ) NEW_LINE DEDENT"}
{"text": "Kos minimum membeli sekurang -kurangnya x coklat | Fungsi untuk mengira kos minimum membeli coklat paling kurang x; Kes asas; Sertakan kotak i - th; Kecualikan kotak i - th; Mengembalikan minimum dua kes di atas; Kod pemacu; Diberikan array dan nilai x; Simpan saiz array; Jawapan cetak", "code": "def findMinCost ( arr , X , n , i = 0 ) : NEW_LINE INDENT if ( X <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 10 ** 8 NEW_LINE DEDENT inc = findMinCost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) NEW_LINE if ( inc != 10 ** 8 ) : NEW_LINE INDENT inc += arr [ i ] [ 1 ] NEW_LINE DEDENT exc = findMinCost ( arr , X , n , i + 1 ) NEW_LINE return min ( inc , exc ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 4 , 3 ] , [ 3 , 2 ] , [ 2 , 4 ] , [ 1 , 3 ] , [ 4 , 2 ] ] NEW_LINE X = 7 NEW_LINE n = len ( arr ) NEW_LINE ans = findMinCost ( arr , X , n ) NEW_LINE if ( ans != 10 ** 8 ) : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT"}
{"text": "Kebarangkalian bahawa jumlah semua nombor yang diperolehi membuang dadu n kali terletak di antara dua bilangan bulat yang diberikan | Fungsi untuk mengira kebarangkalian bagi jumlah yang diberikan untuk menjadi sama dengan jumlah dalam n lontaran dadu; Kes asas; Kod pemacu; Cetak jawapannya", "code": "def find ( N , sum ) : NEW_LINE INDENT if ( sum > 6 * N or sum < N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return 1.0 / 6 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT s = s + find ( N - 1 , sum - i ) / 6 NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE a = 13 NEW_LINE b = 17 NEW_LINE probability = 0.0 NEW_LINE for sum in range ( a , b + 1 ) : NEW_LINE INDENT probability = probability + find ( N , sum ) NEW_LINE DEDENT print ( round ( probability , 6 ) ) NEW_LINE DEDENT"}
{"text": "Langkah minimum untuk mengurangkan n hingga 0 dengan operasi yang diberikan | Berfungsi untuk mencari nombor minimum ke langkah untuk mengurangkan n hingga 0; Kes asas; Panggilan rekursif untuk mengira langkah minimum yang diperlukan; Kembalikan jawapannya; Diberi nombor n; Panggilan fungsi", "code": "def minDays ( n ) : NEW_LINE INDENT if n < 1 : NEW_LINE INDENT return n NEW_LINE DEDENT cnt = 1 + min ( n % 2 + minDays ( n // 2 ) , n % 3 + minDays ( n // 3 ) ) NEW_LINE return cnt NEW_LINE DEDENT N = 6 NEW_LINE print ( str ( minDays ( N ) ) ) NEW_LINE"}
