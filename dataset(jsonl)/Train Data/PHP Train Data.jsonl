{"text": "Semak sama ada nombor itu atau ganjil yang digit dan asasnya (radix) diberikan | Fungsi yang mengembalikan benar jika nombor yang diwakili oleh arr [] bahkan berada di pangkalan r; Sekiranya asasnya, maka digit terakhir diperiksa; Jika asas adalah ganjil, maka bilangan digit ganjil diperiksa; Untuk menyimpan kiraan digit ganjil; Nombor adalah ganjil; Kod pemacu", "code": "< ? php function isEven ( $ arr , $ n , $ r ) { if ( $ r % 2 == 0 ) { if ( $ arr [ $ n - 1 ] % 2 == 0 ) return true ; } else { $ oddCount = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ arr [ $ i ] % 2 != 0 ) $ oddCount ++ ; } if ( $ oddCount % 2 == 0 ) return true ; } return false ; } $ arr = array ( 1 , 0 ) ; $ n = Count ( $ arr ) ; $ r = 2 ; if ( isEven ( $ arr , $ n , $ r ) ) echo \" Even \" ; else echo \" Odd \" ; ? >"}
{"text": "Susun semula array untuk memaksimumkan bilangan prima dalam jumlah awalan array | Berfungsi untuk mencetak array yang disusun semula; Hitung bilangan yang dan dua dalam []; Jika elemen array adalah 1; Unsur array adalah 2; Jika ia mempunyai sekurang -kurangnya satu 2 mengisi pertama 2; Kurangkan CNT orang jika walaupun; Isi dengan kiraan ganjil yang ganjil; Isi dengan baki dua; Jika juga, maka isi kedudukan terakhir; Cetak array yang disusun semula; Kod pemacu", "code": "< ? php function solve ( $ a , $ n ) { $ ones = 0 ; $ twos = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 1 ) $ ones ++ ; else $ twos ++ ; } $ ind = 0 ; if ( $ twos ) $ a [ $ ind ++ ] = 2 ; $ evenOnes = ( $ ones % 2 == 0 ) ? true : false ; if ( $ evenOnes ) $ ones -= 1 ; for ( $ i = 0 ; $ i < $ ones ; $ i ++ ) $ a [ $ ind ++ ] = 1 ; for ( $ i = 0 ; $ i < $ twos - 1 ; $ i ++ ) $ a [ $ ind ++ ] = 2 ; if ( $ evenOnes ) $ a [ $ ind ++ ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ a [ $ i ] , \" ▁ \" ; } $ a = array ( 1 , 2 , 1 , 2 , 1 ) ; $ n = count ( $ a ) ; solve ( $ a , $ n ) ; ? >"}
{"text": "Menjana pelbagai di mana Count of Even and Odd Sum Sub | Berfungsi untuk menjana dan mencetak array yang diperlukan; Cari bilangan wang awalan ganjil; Jika tiada jumlah awalan ganjil dijumpai; Mengira bilangan wang awalan bahkan; Menyimpan jumlah awalan semasa; Jika jumlah awalan semasa adalah walaupun; Cetak 0 hingga E = evenPresums - 1; Cetak 1 apabila E = evenpresums; Cetak 0 untuk sisa nilai; Kod pemacu", "code": "< ? php function CreateArray ( $ N , $ even , $ odd ) { $ temp = -1 ; $ OddPreSums = 0 ; for ( $ i = 0 ; $ i <= $ N + 1 ; $ i ++ ) { if ( $ i * ( ( $ N + 1 ) - $ i ) == $ odd ) { $ temp = 0 ; $ OddPreSums = $ i ; break ; } } if ( $ temp == -1 ) { echo temp ; } else { $ EvenPreSums = ( $ N + 1 ) - $ OddPreSums ; $ e = 1 ; $ o = 0 ; $ CurrSum = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ CurrSum % 2 == 0 ) { if ( $ e < $ EvenPreSums ) { $ e ++ ; echo \"0 ▁ \" ; } else { $ o ++ ; echo \"1 ▁ \" ; $ CurrSum ++ ; } } else { if ( $ e < $ EvenPreSums ) { $ e ++ ; echo \"1 ▁ \" ; $ CurrSum ++ ; } else { $ o ++ ; echo \"0 ▁ \" ; } } } echo \" STRNEWLINE \" ; } } $ N = 15 ; $ even = 60 ; $ odd = 60 ; CreateArray ( $ N , $ even , $ odd ) ; ? >"}
{"text": "Pilih x sedemikian rupa (A xor x) + (b xor x) diminimumkan | Berfungsi untuk mengembalikan integer x sedemikian rupa sehingga (xor x) + (b ^ x) diminimumkan; Walaupun sama ada A atau B bukan sifar; Kedudukan di mana kedua -dua A dan B mempunyai bit set; Memasukkan bit set dalam x; Peralihan kanan kedua -dua nombor untuk melintasi semua bit; Kod pemacu", "code": "< ? php function findX ( $ A , $ B ) { $ j = 0 ; $ x = 0 ; while ( $ A $ B ) { if ( ( $ A & 1 ) && ( $ B & 1 ) ) { $ x += ( 1 << $ j ) ; } $ A >>= 1 ; $ B >>= 1 ; $ j += 1 ; } return $ x ; } $ A = 2 ; $ B = 3 ; $ X = findX ( $ A , $ B ) ; echo \" X = \" ▁ , ▁ $ X ▁ , ▁ \" , Sum = \" ( $ A ^ $ X ) + ( $ B ^ $ X ) ; ? >"}
{"text": "Bandingkan Jumlah Pertama N | Fungsi yang kembali benar jika jumlah unsur n - 1 pertama adalah sama dengan elemen terakhir; Cari jumlah unsur pertama n - 1 dari array; Jika jumlah sama dengan elemen terakhir; Kod pemacu", "code": "< ? php function isSumEqual ( $ ar , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ sum += $ ar [ $ i ] ; if ( $ sum == $ ar [ $ n - 1 ] ) return true ; return false ; } $ arr = array ( 1 , 2 , 3 , 4 , 10 ) ; $ n = count ( $ arr ) ; if ( isSumEqual ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Kira nombor 1 s dalam array selepas n bergerak | Berfungsi untuk mengira bilangan kotak yang sempurna; Mengira bilangan kotak yang sempurna antara A dan B; Berfungsi untuk mengira bilangan 1 s dalam array selepas n bergerak; Memulakan saiz array; Memulakan semua elemen hingga 0", "code": "< ? php function perfectSquares ( $ a , $ b ) { return ( floor ( sqrt ( $ b ) ) - ceil ( sqrt ( $ a ) ) + 1 ) ; } function countOnes ( $ arr , $ n ) { return perfectSquares ( 1 , $ n ) ; } $ N = 10 ; $ arr [ 10 ] = array ( 0 ) ; echo countOnes ( $ arr , $ N ) ; ? >"}
{"text": "Cari kedudukan kotak yang menduduki bola yang diberikan | berfungsi untuk mencari batas bawah; Berfungsi untuk mencetak kedudukan setiap kotak di mana bola perlu diletakkan; Cari jumlah array kumulatif A []; Cari kedudukan kotak untuk setiap bola; Nombor baris; Lajur (kedudukan kotak dalam baris tertentu); Baris + 1 menandakan baris jika pengindeksan array bermula dari 1; Kod pemacu", "code": "< ? php function lower_bound ( $ A , $ valueTosearch ) { $ row = 0 ; foreach ( $ A as $ key = > $ value ) { if ( $ valueTosearch <= $ value ) return $ row ; $ row ++ ; } return $ row + 1 ; } function printPosition ( $ A , $ B , $ sizeOfA , $ sizeOfB ) { for ( $ i = 1 ; $ i < $ sizeOfA ; $ i ++ ) $ A [ $ i ] += $ A [ $ i - 1 ] ; for ( $ i = 0 ; $ i < $ sizeOfB ; $ i ++ ) { $ row = lower_bound ( $ A , $ B [ $ i ] ) ; $ boxNumber = ( $ row >= 1 ) ? $ B [ $ i ] - $ A [ $ row - 1 ] : $ B [ $ i ] ; print_r ( $ row +1 . \" , ▁ \" . $ boxNumber ) ; echo \" STRNEWLINE \" ; } } $ A = array ( 2 , 2 , 2 , 2 ) ; $ B = array ( 1 , 2 , 3 , 4 ) ; $ sizeOfA = count ( $ A ) ; $ sizeOfB = count ( $ B ) ; printPosition ( $ A , $ B , $ sizeOfA , $ sizeOfB ) ; ? >"}
{"text": "Kuasa tertinggi nombor yang membahagikan nombor lain | Berfungsi untuk mendapatkan faktor utama dan kiraan masa ia dibahagikan; Kira bilangan 2 s yang membahagikan n; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, kiraan saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Berfungsi untuk mengembalikan kuasa tertinggi;  ; Dapatkan faktor utama N dan M; Melangkah dan mencari kuasa maksimum; Jika saya bukan faktor utama N dan M; Jika saya adalah faktor utama n dan m jika kiraan saya membahagikan m lebih daripada saya membahagikan n, maka kuasa akan menjadi 0; Jika saya adalah faktor utama M; Dapatkan kuasa maksimum; Kod pemandu", "code": "< ? php function primeFactors ( $ n , $ freq ) { $ cnt = 0 ; while ( $ n % 2 == 0 ) { $ cnt ++ ; $ n = floor ( $ n / 2 ) ; } $ freq [ 2 ] = $ cnt ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { $ cnt = 0 ; while ( $ n % $ i == 0 ) { $ cnt ++ ; $ n = floor ( $ n / $ i ) ; } $ freq [ $ i ] = $ cnt ; } if ( $ n > 2 ) $ freq [ $ n ] = 1 ; return $ freq ; } function getMaximumPower ( $ n , $ m ) { ' ' ' Initialize two arrays ' ' ' $ freq1 = array_fill ( 0 , $ n + 1 , 0 ) ; $ freq2 = array_fill ( 0 , $ m + 1 , 0 ) ; $ freq1 = primeFactors ( $ n , $ freq1 ) ; $ freq2 = primeFactors ( $ m , $ freq2 ) ; $ maxi = 0 ; for ( $ i = 2 ; $ i <= $ m ; $ i ++ ) { if ( $ freq1 [ $ i ] == 0 && $ freq2 [ $ i ] == 0 ) continue ; if ( $ freq2 [ $ i ] > $ freq1 [ $ i ] ) return 0 ; if ( $ freq2 [ $ i ] ) { $ maxi = max ( $ maxi , floor ( $ freq1 [ $ i ] / $ freq2 [ $ i ] ) ) ; } } return $ maxi ; } $ n = 48 ; $ m = 4 ; echo getMaximumPower ( $ n , $ m ) ; ? >"}
{"text": "Cari bilangan pembahagi semua nombor dalam julat [1, n] | Berfungsi untuk mencari bilangan pembahagi semua nombor dalam julat [1, n]; Array untuk menyimpan kiraan pembahagi; Untuk setiap nombor dari 1 hingga n; Meningkatkan pengiraan pembahagi untuk setiap nombor yang boleh dibahagikan oleh i; Cetak pembahagi; Kod pemacu", "code": "< ? php function findDivisors ( $ n ) { $ div = array_fill ( 0 , $ n + 2 , 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j * $ i <= $ n ; $ j ++ ) $ div [ $ i * $ j ] ++ ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ div [ $ i ] , \" ▁ \" ; } $ n = 10 ; findDivisors ( $ n ) ; ? >"}
{"text": "Ramalkan pemenang permainan berdasarkan perbezaan mutlak jumlah dengan memilih nombor | Berfungsi untuk menentukan pemenang; Melangkah untuk semua nombor dalam array; Jika mod memberikan 0; Jika mod memberikan 1; Jika mod memberikan 2; Jika mod memberikan 3; Semak keadaan menang untuk x; Kod pemacu", "code": "< ? php function decideWinner ( $ a , $ n ) { $ count0 = 0 ; $ count1 = 0 ; $ count2 = 0 ; $ count3 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 4 == 0 ) $ count0 ++ ; else if ( $ a [ $ i ] % 4 == 1 ) $ count1 ++ ; else if ( $ a [ $ i ] % 4 == 2 ) $ count2 ++ ; else if ( $ a [ $ i ] % 4 == 3 ) $ count3 ++ ; } if ( $ count0 % 2 == 0 && $ count1 % 2 == 0 && $ count2 % 2 == 0 && $ count3 == 0 ) return 1 ; else return 2 ; } $ a = array ( 4 , 8 , 5 , 9 ) ; $ n = count ( $ a ) ; if ( decideWinner ( $ a , $ n ) == 1 ) echo \" X ▁ wins \" ; else echo \" Y ▁ wins \" ; ? >"}
{"text": "Kira semua awalan array binari yang diberikan yang boleh dibahagikan dengan x | Fungsi untuk mengembalikan kiraan awalan binari total yang boleh dibahagikan dengan x; Inisialisasi dengan sifar; Daripada menukar semua awalan ke perpuluhan, ambil peringatan dengan x; Jika nombor dibahagikan dengan x maka peringatan = 0; Kod pemacu", "code": "< ? php function CntDivbyX ( $ arr , $ n , $ x ) { $ number = 0 ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ number = ( $ number * 2 + $ arr [ $ i ] ) % $ x ; if ( $ number == 0 ) $ count1 += 1 ; } return $ count1 ; } $ arr = array ( 1 , 0 , 1 , 0 , 1 , 1 , 0 ) ; $ n = sizeof ( $ arr ) ; $ x = 2 ; echo CntDivbyX ( $ arr , $ n , $ x ) ; ? >"}
{"text": "Panjang bilangan terkecil yang boleh dibahagikan dengan k dan dibentuk dengan menggunakan 1 's sahaja | Berfungsi untuk mengembalikan panjang nombor yang dihasilkan; Jika k adalah pelbagai 2 atau 5; Daripada menjana semua kemungkinan nombor 1, 11, 111, 111, ..., k 1 's mengambil selebihnya dengan k; Jika nombor dibahagikan oleh k maka selebihnya akan menjadi 0; Kod pemacu", "code": "< ? php function numLen ( $ K ) { if ( $ K % 2 == 0 $ K % 5 == 0 ) return -1 ; $ number = 0 ; $ len = 1 ; for ( $ len = 1 ; $ len <= $ K ; $ len ++ ) { $ number = ( $ number * 10 + 1 ) % $ K ; if ( $ number == 0 ) return $ len ; } return -1 ; } $ K = 7 ; echo numLen ( $ K ) ; ? >"}
{"text": "Jumlah pendaraban triplet pembahagi nombor | Pelaksanaan PHP pendekatan; Perisytiharan Arus Global; Berfungsi untuk mencari jumlah pendaraban setiap triplet dalam pembahagi nombor; sum1 [x] mewakili jumlah semua pembahagi x; Menambah saya ke Sum1 [J] kerana saya adalah pembahagi J; Sum2 [x] mewakili jumlah semua pembahagi x; Di sini saya adalah pembahagi j dan sum1 [j] - saya mewakili jumlah semua pembahagi j yang tidak termasuk saya jadi kita menambah i * (sum1 [j] - i) ke sum2 [j]; Dalam pelaksanaan di atas, kami telah mempertimbangkan setiap pasangan dua kali supaya kita harus membahagikan setiap elemen array SUM2 oleh 2; Di sini saya adalah pembahagi J dan kami cuba menambah jumlah pendaraban semua tiga pembahagi J seperti salah satu pembahagi adalah i; Dalam pelaksanaan di atas, kami telah mempertimbangkan setiap triplet tiga kali jadi kita perlu membahagikan setiap elemen array SUM3 dengan 3; Cetak hasilnya; Kod pemacu; Precomputing", "code": "< ? php $ max_Element = 1005 ; $ sum1 = array_fill ( 0 , $ max_Element , 0 ) ; $ sum2 = array_fill ( 0 , $ max_Element , 0 ) ; $ sum3 = array_fill ( 0 , $ max_Element , 0 ) ; function precomputation ( $ arr , $ n ) { global $ max_Element , $ sum3 , $ sum2 , $ sum1 ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) for ( $ j = $ i ; $ j < $ max_Element ; $ j += $ i ) $ sum1 [ $ j ] += $ i ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) for ( $ j = $ i ; $ j < $ max_Element ; $ j += $ i ) $ sum2 [ $ j ] += ( $ sum1 [ $ j ] - $ i ) * $ i ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) $ sum2 [ $ i ] = ( int ) ( $ sum2 [ $ i ] / 2 ) ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) for ( $ j = $ i ; $ j < $ max_Element ; $ j += $ i ) $ sum3 [ $ j ] += $ i * ( $ sum2 [ $ j ] - $ i * ( $ sum1 [ $ j ] - $ i ) ) ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) $ sum3 [ $ i ] = ( int ) ( $ sum3 [ $ i ] / 3 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ sum3 [ $ arr [ $ i ] ] . \" ▁ \" ; } $ arr = array ( 9 , 5 , 6 ) ; $ n = count ( $ arr ) ; precomputation ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah nombor Fibonacci dalam julat | Berfungsi untuk mengembalikan nombor Nth Fibonacci; Berfungsi untuk mengembalikan jumlah yang diperlukan; Menggunakan hasil yang disimpulkan kami; Kod pemacu", "code": "< ? php function fib ( $ n ) { $ phi = ( 1 + sqrt ( 5 ) ) / 2 ; return ( int ) round ( pow ( $ phi , $ n ) / sqrt ( 5 ) ) ; } function calculateSum ( $ l , $ r ) { $ sum = fib ( $ r + 2 ) - fib ( $ l + 1 ) ; return $ sum ; } $ l = 4 ; $ r = 8 ; echo ( calculateSum ( $ l , $ r ) ) ; ? >"}
{"text": "Cetak ekspresi pendakap yang seimbang menggunakan kurungan yang diberikan | Berfungsi untuk mencetak ekspresi pendakap seimbang jika mungkin; Jika keadaan dipenuhi; Cetak kurungan jenis - 1; Cetak kurungan jenis - 3; Cetak kurungan jenis - 4; Cetak kurungan jenis - 2; Jika keadaan tidak dipenuhi; Kod pemacu", "code": "< ? php function printBalancedExpression ( $ a , $ b , $ c , $ d ) { if ( ( $ a == $ d && $ a ) || ( $ a == 0 && $ c == 0 && $ d == 0 ) ) { for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) echo \" ( ( \" ; for ( $ i = 1 ; $ i <= $ c ; $ i ++ ) echo \" ) ( \" ; for ( $ i = 1 ; $ i <= $ d ; $ i ++ ) echo \" ) ) \" ; for ( $ i = 1 ; $ i <= $ b ; $ i ++ ) echo \" ( ) \" ; } else echo - 1 ; } $ a = 3 ; $ b = 1 ; $ c = 4 ; $ d = 3 ; printBalancedExpression ( $ a , $ b , $ c , $ d ) ; ? >"}
{"text": "Nombor Count yang mempunyai N 0 'dan u dan' 1 tanpa sifar utama | Berfungsi untuk mengembalikan faktorial nombor; Fungsi untuk mengembalikan kiraan nombor digit (n + m) yang mempunyai n 0 's dan u dan' 1 tanpa sifar utama; Kod pemacu", "code": "< ? php function factorial ( $ f ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ f ; $ i ++ ) $ fact *= $ i ; return $ fact ; } function findPermutation ( $ N , $ M ) { $ permutation = factorial ( $ N + $ M - 1 ) / ( factorial ( $ N ) * factorial ( $ M - 1 ) ) ; return $ permutation ; } $ N = 3 ; $ M = 3 ; echo findPermutation ( $ N , $ M ) ; ? >"}
{"text": "Nilai maksimum | | Arr [0] | Berfungsi untuk mengembalikan nilai maksimum yang diperlukan; Kod pemacu", "code": "< ? php function maxValue ( $ n ) { if ( $ n == 1 ) return 0 ; return ( ( $ n * $ n / 2 ) - 1 ) ; } $ n = 4 ; echo maxValue ( $ n ) ; ? >"}
{"text": "Kira A, B & C selepas N Seconds untuk Kadar Pembiakan yang diberikan | Berfungsi untuk mencetak kiraan A, B dan C selepas N saat; Bilangan gandaan 60 di bawah n; Pelbagai daripada 60 yang terdekat dengan n; Tukar semua A ke B; Tukar semua B ke C; Tukar setiap c ke dua a; Cetak nilai terkini A, B dan C; Kod pemacu", "code": "< ? php function findCount ( $ n ) { $ a = 1 ; $ b = 0 ; $ c = 0 ; $ x = $ n / 60 ; $ a = pow ( 32 , $ x ) ; $ x = 60 * $ x ; for ( $ i = $ x + 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) { $ b += $ a ; $ a = 0 ; } if ( $ i % 5 == 0 ) { $ c += $ b ; $ b = 0 ; } if ( $ i % 12 == 0 ) { $ a += ( 2 * $ c ) ; $ c = 0 ; } } echo ( \" a ▁ = ▁ \" . $ a . \" , b = \" ▁ . ▁ $ b ▁ . ▁ \" , c = \" } $ n = 72 ; findCount ( $ n ) ; ? >"}
{"text": "Cari GCD faktorial unsur -unsur array yang diberikan | Pelaksanaan fungsi faktorial; Fungsi untuk mencari GCD faktorial unsur -unsur dari array; Cari elemen minimum array; mengembalikan faktorial elemen minimum; Kod pemacu", "code": "< ? php function factorial ( $ n ) { return ( $ n == 1 $ n == 0 ) ? 1 : factorial ( $ n - 1 ) * $ n ; } function gcdOfFactorial ( $ arr , $ n ) { $ minm = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ minm = $ minm > $ arr [ $ i ] ? $ arr [ $ i ] : $ minm ; return factorial ( $ minm ) ; } $ arr = array ( 9 , 12 , 122 , 34 , 15 ) ; $ n = count ( $ arr ) ; echo gcdOfFactorial ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah siri 1 ^ 1 + 2 ^ 2 + 3 ^ 3 + .... . + n ^ n Menggunakan rekursi | Fungsi rekursif untuk mengembalikan jumlah siri yang diberikan; 1 ^ 1 = 1; Panggilan rekursif; Kod pemacu", "code": "< ? php function sum ( $ n ) { if ( $ n == 1 ) return 1 ; else return ( pow ( $ n , $ n ) + sum ( $ n - 1 ) ) ; } $ n = 2 ; echo ( sum ( $ n ) ) ; ? >"}
{"text": "Mengira permutasi yang pertama kali berkurangan kemudian meningkat. | Pelaksanaan PHP pendekatan di atas; Fungsi untuk mengira mod a ^ n %; Fungsi untuk mengira permutasi yang pertama berkurangan dan kemudian meningkat; Untuk n = 1 kembali 0; Hitung dan pulangan hasil; Kod pemacu", "code": "< ? php $ mod = 1000000007 ; function power ( $ a , $ n ) { global $ mod ; if ( $ n == 0 ) return 1 ; $ p = power ( $ a , $ n / 2 ) % $ mod ; $ p = ( $ p * $ p ) % $ mod ; if ( $ n & 1 ) $ p = ( $ p * $ a ) % $ mod ; return $ p ; } function countPermutations ( $ n ) { global $ mod ; if ( $ n == 1 ) { return 0 ; } return ( power ( 2 , $ n - 1 ) - 2 ) % $ mod ; } $ n = 5 ; echo countPermutations ( $ n ) ; ? >"}
{"text": "Cari kiraan nombor yang boleh dibentuk menggunakan digit 3, 4 sahaja dan mempunyai panjang pada max n. | Fungsi untuk mencari kiraan nombor yang boleh dibentuk menggunakan digit 3, 4 sahaja dan mempunyai panjang pada max n. ; Kod pemacu", "code": "< ? php function numbers ( $ n ) { return ( pow ( 2 , $ n + 1 ) ) - 2 ; } $ n = 2 ; echo numbers ( $ n ) ; ? >"}
{"text": "Cara untuk meletakkan 4 item dalam kedudukan n ^ 2 supaya tiada baris / lajur mengandungi lebih daripada satu | Berfungsi untuk mengembalikan bilangan cara untuk meletakkan 4 item dalam kedudukan n ^ 2; Kod pemacu", "code": "< ? php function NumberofWays ( $ n ) { $ x = ( 1 * ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; $ y = ( 1 * ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) ) ; return ( 1 * $ x * $ y ) ; } $ n = 4 ; echo NumberofWays ( $ n ) ; ? >"}
{"text": "Cari istilah n Siri 1, 6, 18, 40, 75, .... | Berfungsi untuk menghasilkan nombor tetap; (N ^ 2 * (n + 1)) / 2; Kod pemacu", "code": "< ? php function nthTerm ( $ N ) { $ nth = 0 ; $ nth = ( $ N * $ N * ( $ N + 1 ) ) / 2 ; return $ nth ; } $ N = 5 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Cetak N nombor sedemikian rupa sehingga jumlah mereka adalah persegi yang sempurna | Berfungsi untuk nombor PRN supaya jumlahnya adalah persegi yang sempurna; Cetak nombor ganjil; Kod pemacu", "code": "< ? php function findNumbers ( $ n ) { $ i = 1 ; while ( $ i <= $ n ) { echo ( ( 2 * $ i ) - 1 ) . \" ▁ \" ; $ i ++ ; } } $ n = 3 ; findNumbers ( $ n ) ; ? >"}
{"text": "Hilang elemen yang hilang dan ganjil dari tatasusunan yang diberikan | Berfungsi untuk mencari nombor yang hilang; Untuk menyimpan minimum dan maksimum ganjil dan juga unsur -unsur dari tatasusunan; Untuk menyimpan jumlah elemen array; Dapatkan minimum dan maksimum unsur -unsur dari array; Dapatkan minimum dan elemen ganjil maksimum dari array; Untuk menyimpan jumlah terma dalam siri ini dan jumlah array yang diperlukan; Jumlah terma dari 2 hingga Mineven; Jumlah semua nombor dari 2 hingga Mineven; Jumlah terma dari 2 hingga maxeven; Jumlah semua nombor dari 2 hingga maxeven; Jumlah yang diperlukan untuk array walaupun; Kehilangan nombor walaupun; Jumlah terma dari 1 hingga Minodd; Jumlah semua nombor ganjil dari 1 hingga Minodd; Jumlah terma dari 1 hingga Maxodd; Jumlah semua nombor ganjil dari 1 hingga Maxodd; Jumlah yang diperlukan untuk pelbagai ganjil; Kehilangan nombor ganjil; Kod pemacu", "code": "< ? php function findMissingNums ( $ even , $ sizeEven , $ odd , $ sizeOdd ) { $ minEven = PHP_INT_MAX ; $ maxEven = PHP_INT_MIN ; $ minOdd = PHP_INT_MAX ; $ maxOdd = PHP_INT_MIN ; $ sumEvenArr = $ sumOddArr = 0 ; for ( $ i = 0 ; $ i < $ sizeEven ; $ i ++ ) { $ minEven = min ( $ minEven , $ even [ $ i ] ) ; $ maxEven = max ( $ maxEven , $ even [ $ i ] ) ; $ sumEvenArr += $ even [ $ i ] ; } for ( $ i = 0 ; $ i < $ sizeOdd ; $ i ++ ) { $ minOdd = min ( $ minOdd , $ odd [ $ i ] ) ; $ maxOdd = max ( $ maxOdd , $ odd [ $ i ] ) ; $ sumOddArr += $ odd [ $ i ] ; } $ totalTerms = $ reqSum = 0 ; $ totalTerms = ( int ) ( $ minEven / 2 ) ; $ evenSumMin = $ totalTerms * ( $ totalTerms + 1 ) ; $ totalTerms = ( int ) ( $ maxEven / 2 ) ; $ evenSumMax = $ totalTerms * ( $ totalTerms + 1 ) ; $ reqSum = ( $ evenSumMax - $ evenSumMin + $ minEven ) ; echo \" Even = \" ▁ . ▁ ( $ reqSum ▁ - ▁ $ sumEvenArr ) ▁ . ▁ \" \" $ totalTerms = ( int ) ( ( $ minOdd / 2 ) + 1 ) ; $ oddSumMin = $ totalTerms * $ totalTerms ; $ totalTerms = ( int ) ( ( $ maxOdd / 2 ) + 1 ) ; $ oddSumMax = $ totalTerms * $ totalTerms ; $ reqSum = ( $ oddSumMax - $ oddSumMin + $ minOdd ) ; echo \" Odd = \" } $ even = array ( 6 , 4 , 8 , 14 , 10 ) ; $ sizeEven = count ( $ even ) ; $ odd = array ( 7 , 5 , 3 , 11 , 13 ) ; $ sizeOdd = count ( $ odd ) ; findMissingNums ( $ even , $ sizeEven , $ odd , $ sizeOdd ) ; ? >"}
{"text": "Perlawanan minimum pasukan perlu menang untuk melayakkan diri | Berfungsi untuk mengembalikan bilangan minimum perlawanan untuk menang untuk memenuhi syarat untuk pusingan seterusnya; Lakukan carian binari untuk mencari; Cari elemen pertengahan; Semak keadaan $ untuk memenuhi syarat untuk pusingan seterusnya; Kod pemacu", "code": "< ? php function findMinimum ( $ x , $ y ) { $ low = 0 ; $ high = $ y ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) >> 1 ; if ( ( $ mid * 2 + ( $ y - $ mid ) ) >= $ x ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return $ low ; } $ x = 6 ; $ y = 5 ; echo findMinimum ( $ x , $ y ) ; ? >"}
{"text": "Kira semua nombor dalam julat [l, r] yang jumlah digitnya boleh dibahagikan dengan 3 | Berfungsi untuk mengembalikan jumlah digit x; Berfungsi untuk mengembalikan kiraan nombor yang diperlukan; Sekiranya saya dibahagikan dengan 2 dan jumlah digit saya boleh dibahagikan dengan 3; Mengembalikan kiraan yang diperlukan; Kod pemacu", "code": "< ? php function sumOfDigits ( $ x ) { $ sum = 0 ; while ( $ x != 0 ) { $ sum += $ x % 10 ; $ x = $ x / 10 ; } return $ sum ; } function countNumbers ( $ l , $ r ) { $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( $ i % 2 == 0 && sumOfDigits ( $ i ) % 3 == 0 ) $ count ++ ; } return $ count ; } $ l = 1000 ; $ r = 6000 ; echo countNumbers ( $ l , $ r ) ; ? >"}
{"text": "Jumlah elemen minimum semua subarrays array yang disusun | Berfungsi untuk mencari jumlah minimum semua subarray; Kod pemacu", "code": "< ? php function findMinSum ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] * ( $ n - $ i ) ; return $ sum ; } $ arr = array ( 3 , 5 , 7 , 8 ) ; $ n = count ( $ arr ) ; echo findMinSum ( $ arr , $ n ) ; ? >"}
{"text": "Sub terpanjang | Berfungsi untuk mengembalikan panjang maksimum sub -sub -yang mempunyai purata maksimum (nilai purata elemen); Mencari nilai maksimum; Jika maksimum berturut -turut dijumpai; Cari panjang maksimum max berturut -turut; Kod pemacu", "code": "< ? php function maxLenSubArr ( $ a , $ n ) { $ cm = 1 ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ max ) $ max = $ a [ $ i ] ; } for ( $ i = 0 ; $ i < $ n - 1 ; ) { $ count = 1 ; if ( $ a [ $ i ] == $ a [ $ i + 1 ] && $ a [ $ i ] == $ max ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ j ] == $ max ) { $ count ++ ; $ i ++ ; } else break ; } if ( $ count > $ cm ) $ cm = $ count ; } else $ i ++ ; } return $ cm ; } $ arr = array ( 6 , 1 , 6 , 6 , 0 ) ; $ n = sizeof ( $ arr ) ; echo maxLenSubArr ( $ arr , $ n ) ; ? >"}
{"text": "Minimum kemungkinan jumlah elemen array selepas melakukan operasi yang diberikan | Berfungsi untuk mengembalikan jumlah yang diminimumkan; Untuk menyimpan elemen terbesar dari array yang boleh dibahagikan dengan x; Jumlah elemen array sebelum melakukan sebarang operasi; Jika elemen semasa dibahagikan dengan x dan ia adalah maksimum setakat ini; Mengemas kini elemen minimum; Sekiranya tiada elemen dapat dikurangkan maka tidak ada gunanya melakukan operasi kerana kita akan meningkatkan jumlahnya apabila elemen didarab dengan x; Tolak unsur -unsur yang dipilih dari jumlah dan kemudian tambah nilai yang dikemas kini; Mengembalikan jumlah yang diminimumkan; Kod pemacu", "code": "< ? php function minSum ( $ arr , $ n , $ x ) { $ sum = 0 ; $ largestDivisible = -1 ; $ minimum = $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; if ( $ arr [ $ i ] % $ x == 0 && $ largestDivisible < $ arr [ $ i ] ) $ largestDivisible = $ arr [ $ i ] ; if ( $ arr [ $ i ] < $ minimum ) $ minimum = $ arr [ $ i ] ; } if ( $ largestDivisible == -1 ) return $ sum ; $ sumAfterOperation = $ sum - $ minimum - $ largestDivisible + ( $ x * $ minimum ) + ( $ largestDivisible / $ x ) ; return min ( $ sum , $ sumAfterOperation ) ; } $ arr = array ( 5 , 5 , 5 , 5 , 6 ) ; $ n = sizeof ( $ arr ) ; $ x = 3 ; print ( minSum ( $ arr , $ n , $ x ) ) ; ? >"}
{"text": "Maksimum bitwise dan pasangan dari julat yang diberikan | Berfungsi untuk mengembalikan bitwise maksimum dan mungkin di antara semua pasangan yang mungkin; Sekiranya terdapat hanya satu nilai dalam julat [l, r]; Sekiranya terdapat hanya dua nilai dalam julat [L, R]; Kod pemacu", "code": "< ? php function maxAND ( $ L , $ R ) { if ( $ L == $ R ) return $ L ; else if ( ( $ R - $ L ) == 1 ) return ( $ R & $ L ) ; else { if ( ( ( $ R - 1 ) & $ R ) > ( ( $ R - 2 ) & ( $ R - 1 ) ) ) return ( ( $ R - 1 ) & $ R ) ; else return ( ( $ R - 2 ) & ( $ R - 1 ) ) ; } } $ L = 1 ; $ R = 632 ; echo maxAND ( $ L , $ R ) ; ? >"}
{"text": "Perdana khas terkecil yang lebih besar daripada atau sama dengan nombor tertentu | Berfungsi untuk memeriksa sama ada nombor itu adalah perdana khas atau tidak; Walaupun nombor tidak sama dengan sifar; Jika nombor itu bukan pulangan utama palsu. ; Lain keluarkan digit terakhir dengan membahagikan nombor dengan 10 .; Sekiranya nombor itu menjadi sifar maka nombor itu adalah perdana khas, maka kembali benar; Berfungsi untuk mencari perdana khas terkecil yang lebih besar daripada atau sama dengan nombor tertentu; Pada mulanya semua nombor dianggap prima. ; Selalu ada jawapan yang mungkin; Memeriksa sama ada nombor itu adalah perdana khas atau tidak; Jika ya cetak nombor dan pecahkan gelung. ; Lain menambah nombor. ; Kod pemacu", "code": "< ? php function checkSpecialPrime ( $ sieve , $ num ) { while ( $ num ) { if ( ! $ sieve [ $ num ] ) { return false ; } $ num = floor ( $ num / 10 ) ; } return true ; } function findSpecialPrime ( $ N ) { $ sieve = array_fill ( 0 , $ N * 10 , true ) ; $ sieve [ 0 ] = $ sieve [ 1 ] = false ; for ( $ i = 2 ; $ i <= $ N * 10 ; $ i ++ ) { if ( $ sieve [ $ i ] ) { for ( $ j = $ i * $ i ; $ j <= $ N * 10 ; $ j += $ i ) { $ sieve [ $ j ] = false ; } } } while ( true ) { if ( checkSpecialPrime ( $ sieve , $ N ) ) { echo $ N , \" STRNEWLINE \" ; break ; } else $ N ++ ; } } $ N = 379 ; findSpecialPrime ( $ N ) ; $ N = 100 ; findSpecialPrime ( $ N ) ; ? >"}
{"text": "Bilangan minimum langkah yang diberikan diperlukan untuk membuat n dibahagi dengan 25 | Berfungsi untuk mengembalikan bilangan minimum langkah yang diperlukan untuk menjadikan N dibahagi dengan 25; Tukar nombor menjadi rentetan; Untuk menyimpan jawapan yang diperlukan; Panjang rentetan; Untuk memeriksa semua pasangan yang mungkin; Buat rentetan pendua; Bilangan swap yang diperlukan untuk meletakkan digit ith dalam kedudukan terakhir; Bilangan swap yang diperlukan untuk meletakkan digit JTH dalam kedudukan terakhir ke -2; Cari angka bukan sifar pertama; Letakkan angka bukan sifar pertama di kedudukan pertama; Tukar rentetan ke nombor; Jika nombor ini boleh dibahagikan dengan 25 maka Cur adalah salah satu jawapan yang mungkin; Jika tidak mungkin; Kod pemacu", "code": "< ? php function minMoves ( $ n ) { $ s = strval ( $ n ) ; $ ans = PHP_INT_MAX ; $ len = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) { for ( $ j = 0 ; $ j < $ len ; ++ $ j ) { if ( $ i == $ j ) continue ; $ t = $ s ; $ cur = 0 ; for ( $ k = $ i ; $ k < $ len - 1 ; ++ $ k ) { $ e = $ t [ $ k ] ; $ t [ $ k ] = $ t [ $ k + 1 ] ; $ t [ $ k + 1 ] = $ e ; ++ $ cur ; } for ( $ k = $ j - ( $ j > $ i ) ; $ k < $ len - 2 ; ++ $ k ) { $ e = $ t [ $ k ] ; $ t [ $ k ] = $ t [ $ k + 1 ] ; $ t [ $ k + 1 ] = $ e ; ++ $ cur ; } $ pos = -1 ; for ( $ k = 0 ; $ k < $ len ; ++ $ k ) { if ( $ t [ $ k ] != '0' ) { $ pos = $ k ; break ; } } for ( $ k = $ pos ; $ k > 0 ; -- $ k ) { $ e = $ t [ $ k ] ; $ t [ $ k ] = $ t [ $ k + 1 ] ; $ t [ $ k + 1 ] = $ e ; ++ $ cur ; } $ nn = intval ( $ t ) ; if ( $ nn % 25 == 0 ) $ ans = min ( $ ans , $ cur ) ; } } if ( $ ans == PHP_INT_MAX ) return -1 ; return $ ans ; } $ n = 509201 ; echo minMoves ( $ n ) ; ? >"}
{"text": "Integer positif maksimum dibahagikan dengan c dan berada dalam julat [a, b] | Berfungsi untuk mengembalikan nombor yang diperlukan; Jika b % c = 0 maka b ialah nombor yang diperlukan; Lain mendapatkan pelbagai maksimum c lebih kecil daripada b; Kod pemacu", "code": "< ? php function getMaxNum ( $ a , $ b , $ c ) { if ( $ b % $ c == 0 ) return $ b ; $ x = ( ( int ) ( $ b / $ c ) * $ c ) ; if ( $ x >= $ a && $ x <= $ b ) return $ x ; else return -1 ; } $ a = 2 ; $ b = 10 ; $ c = 3 ; echo ( getMaxNum ( $ a , $ b , $ c ) ) ; ? >"}
{"text": "Kira jumlah kuadrat yang boleh dikunjungi oleh uskup dalam satu langkah | Berfungsi untuk mengembalikan kiraan jumlah kedudukan uskup yang boleh dikunjungi dalam satu langkah; Mengira kotak kiri atas; Mengira kotak kanan bawah; Mengira kotak kanan atas; Mengira kotak kiri bawah; Mengembalikan jumlah jumlah; Kedudukan Bishop", "code": "< ? php function countSquares ( $ row , $ column ) { $ topLeft = min ( $ row , $ column ) - 1 ; $ bottomRight = 8 - max ( $ row , $ column ) ; $ topRight = min ( $ row , 9 - $ column ) - 1 ; $ bottomLeft = 8 - max ( $ row , 9 - $ column ) ; return ( $ topLeft + $ topRight + $ bottomRight + $ bottomLeft ) ; } $ row = 4 ; $ column = 4 ; echo countSquares ( $ row , $ column ) ; ? >"}
{"text": "Semak sama ada Bishop boleh mengambil bidak atau tidak | Fungsi yang kembali benar jika uskup boleh menurunkan bidak; Jika pajak berada pada sudut 45 atau 225 darjah dari kedudukan Bishop; Jika pajak berada pada sudut 135 atau 315 darjah dari kedudukan Bishop; Kedudukan Bishop; Kedudukan Pawn", "code": "< ? php function canTakeDown ( $ bishopX , $ bishopY , $ pawnX , $ pawnY ) { if ( $ pawnX - $ bishopX == $ pawnY - $ bishopY ) return true ; else if ( - $ pawnX + $ bishopX == $ pawnY - $ bishopY ) return true ; else return false ; } $ bishopX = 5 ; $ bishopY = 5 ; $ pawnX = 1 ; $ pawnY = 1 ; if ( canTakeDown ( $ bishopX , $ bishopY , $ pawnX , $ pawnY ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cari operasi maksimum untuk mengurangkan n hingga 1 | Program PHP untuk mencari gerakan nombor maksimum yang mungkin; Untuk menyimpan bilangan faktor utama setiap nombor; Berfungsi untuk mencari bilangan faktor utama setiap nombor; Sekiranya saya adalah nombor utama; Meningkatkan nilai oleh satu daripada pelbagai yang berkebolehan; Buat Jumlah Awalan Ini akan berguna untuk pelbagai kes ujian; Menjana array primefactors; jawapan yang diperlukan", "code": "< ? php $ N = 10005 ; $ primeFactors = array_fill ( 0 , $ N , 0 ) ; function findPrimeFactors ( ) { global $ N , $ primeFactors ; for ( $ i = 2 ; $ i < $ N ; $ i ++ ) if ( $ primeFactors [ $ i ] == 0 ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) $ primeFactors [ $ j ] = $ primeFactors [ ( int ) ( $ j / $ i ) ] + 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ primeFactors [ $ i ] += $ primeFactors [ $ i - 1 ] ; } findPrimeFactors ( ) ; $ a = 6 ; $ b = 3 ; print ( ( $ primeFactors [ $ a ] - $ primeFactors [ $ b ] ) ) ; ? >"}
{"text": "Integer terkecil dengan jumlah digit m dan pelbagai n | Berfungsi untuk mengembalikan jumlah digit; Berfungsi untuk mengetahui integer terkecil; Permulaan iterator (pelbagai terkecil n); Kod pemacu", "code": "< ? php function digitSum ( $ n ) { $ ans = 0 ; while ( $ n ) { $ ans += $ n % 10 ; $ n /= 10 ; } return $ ans ; } function findInt ( $ n , $ m ) { $ minDigit = floor ( $ m / 9 ) ; $ start = pow ( 10 , $ minDigit ) - ( int ) pow ( 10 , $ minDigit ) % $ n ; while ( $ start < PHP_INT_MAX ) { if ( digitSum ( $ start ) == $ m ) return $ start ; else $ start += $ n ; } return -1 ; } $ n = 13 ; $ m = 32 ; echo findInt ( $ n , $ m ) ; # This  code is contributed by ajit. NEW_LINE ? >"}
{"text": "Jumlah maksimum selepas berulang kali membahagikan n oleh pembahagi | Berfungsi untuk mencari pembahagi terkecil; Berfungsi untuk mencari jumlah maksimum; Kod pemacu", "code": "< ? php function smallestDivisor ( $ n ) { $ mx = sqrt ( $ n ) ; for ( $ i = 2 ; $ i <= $ mx ; $ i ++ ) if ( $ n % $ i == 0 ) return $ i ; return $ n ; } function maxSum ( $ n ) { $ res = $ n ; while ( $ n > 1 ) { $ divi = smallestDivisor ( $ n ) ; $ n /= $ divi ; $ res += $ n ; } return $ res ; } $ n = 34 ; echo maxSum ( $ n ) ; #This  code is contributed by akt_mit. NEW_LINE ? >"}
{"text": "Buat semua elemen array sama dengan operasi yang diberikan | Fungsi yang mengembalikan benar jika semua elemen array boleh dibuat sama dengan operasi yang diberikan; Untuk menyimpan jumlah elemen array dan elemen maksimum dari array; Kod pemacu", "code": "< ? php function isPossible ( $ n , $ k , $ arr ) { $ sum = $ arr [ 0 ] ; $ maxVal = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ maxVal = max ( $ maxVal , $ arr [ $ i ] ) ; } if ( ( float ) $ maxVal > ( float ) ( $ sum + $ k ) / $ n ) return false ; return true ; } $ k = 8 ; $ arr = array ( 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; if ( isPossible ( $ n , $ k , $ arr ) ) echo \" Yes \" ; else echo \" No \" ; # This  code is contributed by akt_miit. NEW_LINE ? >"}
{"text": "Memaksimumkan nilai x + y + z sedemikian rupa sehingga kapak + oleh + cz = n | Berfungsi untuk mengembalikan nilai maksimum (x + y + z) seperti itu (Ax + by + cz = n); Saya mewakili kemungkinan nilai a * x; J mewakili kemungkinan nilai b * y; Jika z adalah integer; Kod pemacu; Panggilan fungsi", "code": "< ? php function maxResult ( $ n , $ a , $ b , $ c ) { $ maxVal = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i += $ a ) for ( $ j = 0 ; $ j <= $ n - $ i ; $ j += $ b ) { $ z = ( $ n - ( $ i + $ j ) ) / $ c ; if ( floor ( $ z ) == ceil ( $ z ) ) { $ x = ( int ) ( $ i / $ a ) ; $ y = ( int ) ( $ j / $ b ) ; $ maxVal = max ( $ maxVal , $ x + $ y + ( int ) $ z ) ; } } return $ maxVal ; } $ n = 10 ; $ a = 5 ; $ b = 3 ; $ c = 4 ; echo maxResult ( $ n , $ a , $ b , $ c ) ; ? >"}
{"text": "Buat semua nombor array sama | Fungsi yang mengembalikan benar jika semua elemen array boleh dibuat sama dengan operasi yang diberikan; Membahagikan nombor dengan 2; Bahagikan nombor dengan 3; Kod pemacu", "code": "< ? php function EqualNumbers ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ a [ $ i ] % 2 == 0 ) $ a [ $ i ] /= 2 ; while ( $ a [ $ i ] % 3 == 0 ) $ a [ $ i ] /= 3 ; if ( $ a [ $ i ] != $ a [ 0 ] ) { return false ; } } return true ; } $ a = array ( 50 , 75 , 150 ) ; $ n = sizeof ( $ a ) / sizeof ( $ a [ 0 ] ) ; if ( EqualNumbers ( $ a , $ n ) ) echo \" Yes \" ; else echo \" No \" ; #This  code is contributed by ajit.. NEW_LINE ? >"}
{"text": "GCD maksimum dari produk yang tidak diketahui | Berfungsi untuk mengembalikan GCD yang diperlukan; Kira bilangan kali 2 membahagikan p; Bersamaan dengan p = p / 2; ; Jika 2 membahagikan p; Semak semua nombor yang mungkin boleh membahagikan p; Jika n pada akhirnya adalah nombor utama; Mengembalikan GCD yang diperlukan; Kod pemacu", "code": "< ? php function max_gcd ( $ n , $ p ) { $ count = 0 ; $ gcd = 1 ; while ( $ p % 2 == 0 ) { $ p >>= 1 ; $ count ++ ; } if ( $ count > 0 ) $ gcd *= pow ( 2 , ( int ) ( $ count / $ n ) ) ; for ( $ i = 3 ; $ i <= ( int ) sqrt ( $ p ) ; $ i += 2 ) { $ count = 0 ; while ( $ p % $ i == 0 ) { $ count ++ ; $ p = ( int ) ( $ p / $ i ) ; } if ( $ count > 0 ) { $ gcd *= pow ( $ i , ( int ) ( $ count / $ n ) ) ; } } if ( $ p > 2 ) $ gcd *= pow ( $ p , ( int ) ( 1 / $ n ) ) ; return $ gcd ; } $ n = 3 ; $ p = 80 ; echo ( max_gcd ( $ n , $ p ) ) ;"}
{"text": "Integer positif minimum dibahagi dengan c dan tidak dalam julat [a, b] | Berfungsi untuk mengembalikan nombor yang diperlukan; Jika tidak tergolong dalam julat maka c adalah nombor yang diperlukan; Lain dapatkan pelbagai seterusnya C bermula dari B + 1; Kod pemacu", "code": "< ? php function getMinNum ( $ a , $ b , $ c ) { if ( $ c < $ a $ c > $ b ) return $ c ; $ x = ( floor ( ( $ b / $ c ) ) * $ c ) + $ c ; return $ x ; } $ a = 2 ; $ b = 4 ; $ c = 4 ; echo getMinNum ( $ a , $ b , $ c ) ; ? >"}
{"text": "Count pasangan (i, j) seperti itu ((n % i) % j) % n dimaksimumkan | Berfungsi untuk mengembalikan kiraan pasangan yang diperlukan; Kes khas; Nombor yang akan memberikan nilai maksimum. untuk ((n % i) % j) % n; Untuk menyimpan nilai maksimum yang mungkin ((n % i) % j) % n; Kiraan pasangan yang mungkin; Kod pemacu", "code": "< ? php function countPairs ( $ n ) { if ( $ n == 2 ) return 4 ; $ num = ( ( int ) ( $ n / 2 ) + 1 ) ; $ max = $ n % $ num ; $ count = ( $ n - $ max ) ; return $ count ; } $ n = 5 ; echo ( countPairs ( $ n ) ) ; ? >"}
{"text": "Keluarkan aksara dari rentetan angka supaya rentetan menjadi dibahagikan dengan 8 | Fungsi yang kembali benar jika sub adalah sub -urutan dalam s; Berfungsi untuk mengembalikan pelbagai 8 yang dibentuk selepas mengeluarkan 0 atau lebih aksara dari rentetan yang diberikan; Melangkah ke atas semua gandaan 8; Jika berbilang semasa wujud sebagai seterusnya dalam rentetan yang diberikan; Kod pemacu", "code": "< ? php function checkSub ( $ sub , $ s ) { $ j = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) if ( $ sub [ $ j ] == $ s [ $ i ] ) $ j ++ ; return $ j == strlen ( $ sub ) ; } function getMultiple ( $ s ) { for ( $ i = 0 ; $ i < 1e3 ; $ i += 8 ) { if ( checkSub ( ( string ) ( $ i ) , $ s ) ) return $ i ; } return -1 ; } $ s = \"3454\" ; echo getMultiple ( $ s ) ;"}
{"text": "Program untuk mencari jumlah siri harmonik | Program PHP untuk mencari jumlah siri harmonik menggunakan rekursi; Keadaan asas; Kod pemacu", "code": "< ? php function sum ( $ n ) { if ( $ n < 2 ) return 1 ; else return 1 / $ n + ( sum ( $ n - 1 ) ) ; } echo sum ( 8 ) . \" STRNEWLINE \" ; echo sum ( 10 ) ; ? >"}
{"text": "Jumlah syarat AP jika istilah mth dan nth diberikan | Fungsi untuk mengira nilai; Hitung nilai d menggunakan formula; Hitung nilai formula menggunakan; Pasangan kembali; Fungsi untuk mengira jumlah nilai nombor p pertama siri; Pertama mengira nilai a dan d; Hitung jumlahnya dengan menggunakan formula; Mengembalikan jumlahnya; Kod pemacu", "code": "< ? php function findingValues ( $ m , $ n , $ mth , $ nth ) { $ d = ( abs ( $ mth - $ nth ) ) / abs ( ( $ m - 1 ) - ( $ n - 1 ) ) ; $ a = $ mth - ( ( $ m - 1 ) * $ d ) ; return array ( $ a , $ d ) ; } function findSum ( $ m , $ n , $ mth , $ nth , $ p ) { $ ad = findingValues ( $ m , $ n , $ mth , $ nth ) ; $ a = $ ad [ 0 ] ; $ d = $ ad [ 1 ] ; $ sum = ( $ p * ( 2 * $ a + ( $ p - 1 ) * $ d ) ) / 2 ; return $ sum ; } $ m = 6 ; $ n = 10 ; $ mTerm = 12 ; $ nTerm = 20 ; $ p = 5 ; echo findSum ( $ m , $ n , $ mTerm , $ nTerm , $ p ) ; ? >"}
{"text": "Cetak semua integer yang jumlah kuasa dua nombor yang diberikan | Berfungsi untuk mencetak bilangan bulat kuat; Set digunakan untuk menyimpan nombor yang berbeza dalam susunan yang disusun; Simpan semua kuasa y <terikat dalam vektor untuk mengelakkan mengira mereka lagi dan lagi; x ^ i; Jika Num berada dalam had memasukkannya ke dalam set; Keluar dari gelung dalaman; Menambah apa -apa nombor kepadanya akan berada di luar batas; Kenaikan i; Cetak kandungan set; Kod pemacu; Cetak bilangan bulat yang kuat", "code": "< ? php function powerfulIntegers ( $ x , $ y , $ bound ) { $ s = array ( ) ; $ powersOfY = array ( ) ; array_push ( $ powersOfY , 1 ) ; $ i = $ y ; while ( $ i < $ bound && $ y != 1 ) { array_push ( $ powersOfY , $ i ) ; $ i *= $ y ; } $ i = 0 ; while ( true ) { $ xPowI = pow ( $ x , $ i ) ; for ( $ j = 0 ; $ j < count ( $ powersOfY ) ; $ j ++ ) { $ num = $ xPowI + $ powersOfY [ $ j ] ; if ( $ num <= $ bound ) array_push ( $ s , $ num ) ; else break ; } if ( $ xPowI >= $ bound $ x == 1 ) break ; $ i += 1 ; } $ s = array_unique ( $ s ) ; sort ( $ s ) ; foreach ( $ s as & $ itr ) print ( $ itr . \" \" ) ; } $ x = 2 ; $ y = 3 ; $ bound = 10 ; powerfulIntegers ( $ x , $ y , $ bound ) ; ? >"}
{"text": "Mengedarkan gula -gula di kalangan orang K | Berfungsi untuk mengetahui bilangan gula -gula setiap orang yang diterima; Kiraan bilangan giliran lengkap; Dapatkan istilah terakhir; Menyimpan bilangan gula -gula; Tempoh terakhir siri terakhir dan semasa; Jumlah siri semasa dan terakhir; Jumlah siri semasa sahaja; Jika jumlah arus kurang daripada n; lain secara individu mengedarkan; Istilah pertama; Mengedarkan gula -gula sehingga ke sana; Gula -gula yang ada; Tidak tersedia; Mengira jumlah gula -gula; Cetak jumlah gula -gula; Kod pemacu", "code": "< ? php function candies ( $ n , $ k ) { $ count = 0 ; $ ind = 1 ; $ arr = array_fill ( 0 , $ k , 0 ) ; while ( $ n ) { $ f1 = ( $ ind - 1 ) * $ k ; $ f2 = $ ind * $ k ; $ sum1 = floor ( ( $ f1 * ( $ f1 + 1 ) ) / 2 ) ; $ sum2 = floor ( ( $ f2 * ( $ f2 + 1 ) ) / 2 ) ; $ res = $ sum2 - $ sum1 ; if ( $ res <= $ n ) { $ count ++ ; $ n -= $ res ; $ ind ++ ; } { $ i = 0 ; $ term = ( ( $ ind - 1 ) * $ k ) + 1 ; while ( $ n > 0 ) { if ( $ term <= $ n ) { $ arr [ $ i ++ ] = $ term ; $ n -= $ term ; $ term ++ ; } else { $ arr [ $ i ++ ] = $ n ; $ n = 0 ; } } } } for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ arr [ $ i ] += floor ( ( $ count * ( $ i + 1 ) ) + ( $ k * ( $ count * ( $ count - 1 ) ) / 2 ) ) ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; } $ n = 10 ; $ k = 3 ; candies ( $ n , $ k ) ; ? >"}
{"text": "Mengedarkan gula -gula di kalangan orang K | Berfungsi untuk mengetahui bilangan gula -gula setiap orang yang diterima; Kiraan bilangan giliran lengkap; Dapatkan istilah terakhir; Menyimpan bilangan gula -gula; Lakukan carian binari untuk mencari nombor yang jumlahnya kurang daripada n. ; Dapatkan Mide; Jika jumlah di bawah n; Cari bilangan giliran lengkap; Halve kanan; Separuh kiri; Tempoh terakhir siri lengkap terakhir; Tolak jumlah sehingga; Tempoh pertama siri tidak lengkap; Mengira jumlah gula -gula; Cetak jumlah gula -gula; Kod pemacu", "code": "< ? php function candies ( $ n , $ k ) { $ count = 0 ; $ ind = 1 ; $ arr = array_fill ( 0 , $ k , 0 ) ; $ low = 0 ; $ high = $ n ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) >> 1 ; $ sum = ( $ mid * ( $ mid + 1 ) ) >> 1 ; if ( $ sum <= $ n ) { $ count = ( int ) ( $ mid / $ k ) ; $ low = $ mid + 1 ; } else { $ high = $ mid - 1 ; } } $ last = ( $ count * $ k ) ; $ n -= ( int ) ( ( $ last * ( $ last + 1 ) ) / 2 ) ; $ i = 0 ; $ term = ( $ count * $ k ) + 1 ; while ( $ n ) { if ( $ term <= $ n ) { $ arr [ $ i ++ ] = $ term ; $ n -= $ term ; $ term ++ ; } else { $ arr [ $ i ] += $ n ; $ n = 0 ; } } for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ arr [ $ i ] += ( $ count * ( $ i + 1 ) ) + ( int ) ( $ k * ( $ count * ( $ count - 1 ) ) / 2 ) ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } $ n = 7 ; $ k = 4 ; candies ( $ n , $ k ) ; ? >"}
{"text": "Pelbagai terkecil 3 yang terdiri daripada tiga yang diberikan bukan | Berfungsi untuk mengembalikan nombor minimum yang boleh dibahagikan dengan 3 yang dibentuk oleh digit yang diberikan; Susun array yang diberikan dalam menaik; Periksa sama ada mana -mana digit boleh dibahagikan dengan 3; Semak sama ada nombor dua digit yang dibentuk oleh digit yang diberikan boleh dibahagikan dengan 3 bermula dari minimum; Menjana nombor dua digit; Jika tiada yang di atas adalah benar, kita boleh membentuk nombor tiga digit dengan mengambil [0] tiga kali. ; Kod pemacu", "code": "< ? php function printSmallest ( $ a ) { sort ( $ a ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { if ( $ a [ $ i ] % 3 == 0 ) return $ a [ $ i ] ; } for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { for ( $ j = 0 ; $ j < 3 ; $ j ++ ) { $ num = ( $ a [ $ i ] * 10 ) + $ a [ $ j ] ; if ( $ num % 3 == 0 ) return $ num ; } } return $ a [ 0 ] * 100 + $ a [ 0 ] * 10 + $ a [ 0 ] ; } $ arr = array ( 7 , 7 , 1 ) ; echo printSmallest ( $ arr ) ; ? >"}
{"text": "Cetak Matriks Selepas Memohon Operasi Peningkatan Dalam M Ranges | Berfungsi untuk mengemas kini dan mencetak matriks selepas melakukan pertanyaan; Tambah 1 ke elemen pertama sub -matriks; Sekiranya terdapat elemen selepas elemen terakhir sub -matriks kemudian turunkannya dengan 1; Kirakan jumlah yang berjalan; Cetak elemen yang dikemas kini; Baris seterusnya; Saiz matriks; Pertanyaan", "code": "< ? php function updateMatrix ( $ n , $ q , $ mat ) { for ( $ i = 0 ; $ i < sizeof ( $ q ) ; $ i ++ ) { $ X1 = $ q [ $ i ] [ 0 ] ; $ Y1 = $ q [ $ i ] [ 1 ] ; $ X2 = $ q [ $ i ] [ 2 ] ; $ Y2 = $ q [ $ i ] [ 3 ] ; $ mat [ $ X1 ] [ $ Y1 ] ++ ; if ( $ Y2 + 1 < $ n ) $ mat [ $ X2 ] [ $ Y2 + 1 ] -- ; else if ( $ X2 + 1 < $ n ) $ mat [ $ X2 + 1 ] [ 0 ] -- ; } $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ sum += $ mat [ $ i ] [ $ j ] ; echo ( $ sum . \" \" ) ; } echo ( \" STRNEWLINE \" ) ; } } $ n = 5 ; $ mat = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; $ q = array ( array ( 0 , 0 , 1 , 2 ) , array ( 1 , 2 , 3 , 4 ) , array ( 1 , 4 , 3 , 4 ) ) ; updateMatrix ( $ n , $ q , $ mat ) ; ? >"}
{"text": "Gantikan elemen maksimum dalam array dengan pekali julat | Fungsi utiliti untuk mencetak kandungan array; Berfungsi untuk menggantikan elemen maksimum dari array dengan pekali julat array; Elemen maksimum dari array; Elemen minimum dari array; Kirakan pekali julat untuk array; Dengan mengandaikan semua elemen array adalah berbeza. Menggantikan elemen maksimum dengan pekali julat array; Cetak array yang dikemas kini; Kod pemacu", "code": "< ? php function printArr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } function replaceMax ( $ arr , $ n ) { $ max = max ( $ arr ) ; $ min = min ( $ arr ) ; $ range = $ max - $ min ; $ coeffOfRange = round ( $ range / ( $ max + $ min ) , 6 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ max ) { $ arr [ $ i ] = $ coeffOfRange ; break ; } } printArr ( $ arr , $ n ) ; } $ arr = array ( 15 , 16 , 10 , 9 , 6 , 7 , 17 ) ; $ n = count ( $ arr ) ; replaceMax ( $ arr , $ n ) ; ? >"}
{"text": "Bahagikan dua nombor yang diberikan oleh pembahagi umum mereka | Cetak nombor selepas membahagikannya dengan faktor umum mereka; berulang dari 1 hingga minimum a dan b; Jika saya adalah faktor umum kedua -dua nombor; Kod pemacu; Bahagikan A dan B oleh faktor biasa mereka", "code": "< ? php function divide ( $ a , $ b ) { for ( $ i = 2 ; $ i <= min ( $ a , $ b ) ; $ i ++ ) { while ( $ a % $ i == 0 && $ b % $ i == 0 ) { $ a = $ a / $ i ; $ b = $ b / $ i ; } } echo \" A = \" , ▁ $ a , ▁ \" , B = \" , ▁ $ b , ▁ \" \" } $ A = 10 ; $ B = 15 ; divide ( $ A , $ B ) ; ? >"}
{"text": "Bahagikan dua nombor yang diberikan oleh pembahagi umum mereka | Berfungsi untuk mengira GCD dua nombor; Fungsi untuk mengira semua pembahagi biasa dua nombor tertentu A, B -> Input Integer Number; Cari GCD A, B; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function commDiv ( $ a , $ b ) { $ n = gcd ( $ a , $ b ) ; $ a = ( int ) ( $ a / $ n ) ; $ b = ( int ) ( $ b / $ n ) ; echo \" A = \" ▁ . ▁ $ a ▁ . STRNEWLINE TABSYMBOL TABSYMBOL \" , B = \" ▁ . ▁ $ b ▁ . ▁ \" \" } $ a = 10 ; $ b = 15 ; commDiv ( $ a , $ b ) ; ? >"}
{"text": "Perbezaan mutlak minimum antara n dan kuasa 2 | Berfungsi untuk mengembalikan perbezaan minimum antara n dan kuasa 2; Kuasa 2 paling dekat dengan n di sebelah kiri; Kuasa 2 paling dekat dengan n di sebelah kanannya; Mengembalikan perbezaan abs minimum; Kod pemacu", "code": "< ? php function minAbsDiff ( $ n ) { $ left = 1 << ( ( floor ( log ( $ n ) / log ( 2 ) ) ) ) ; $ right = $ left * 2 ; return min ( ( $ n - $ left ) , ( $ right - $ n ) ) ; } $ n = 15 ; echo minAbsDiff ( $ n ) ; ? >"}
{"text": "Cari kebarangkalian bahawa pemain menang apabila kebarangkalian memukul sasaran diberikan | Berfungsi untuk mengembalikan kebarangkalian pemenang; Kod pemacu; Akan mencetak 9 digit selepas titik perpuluhan", "code": "< ? php function find_probability ( $ p , $ q , $ r , $ s ) { $ t = ( 1 - $ p / $ q ) * ( 1 - $ r / $ s ) ; $ ans = ( $ p / $ q ) / ( 1 - $ t ) ; return $ ans ; } $ p = 1 ; $ q = 2 ; $ r = 1 ; $ s = 2 ; $ res = find_probability ( $ p , $ q , $ r , $ s ) ; $ update = number_format ( $ res , 7 ) ; echo $ update ; ? >"}
{"text": "Mewakili n sebagai jumlah kuasa kut yang tepat dari dua | Tetapkan 2 | Fungsi untuk mencetak nombor k yang kuasa dua dan jumlahnya sama dengan n; Memulakan jumlah dengan k; Memulakan array A dengan elemen K dan mengisi semua elemen dengan 1; Mengalihkan [] dari k - 1 hingga 0; Kemas kini jumlah dan [i] sehingga jumlah + a [i] kurang daripada sama dengan n; Mustahil untuk mencari gabungan; Penyelesaian yang mungkin disimpan dalam []; Kod pemacu", "code": "< ? php function FindAllElements ( $ n , $ k ) { $ sum = $ k ; $ A = array_fill ( 0 , $ k , 1 ) ; for ( $ i = $ k - 1 ; $ i >= 0 ; -- $ i ) { while ( $ sum + $ A [ $ i ] <= $ n ) { $ sum += $ A [ $ i ] ; $ A [ $ i ] *= 2 ; } } if ( $ sum != $ n ) { echo \" Impossible \" ; } else { for ( $ i = 0 ; $ i < $ k ; ++ $ i ) echo $ A [ $ i ] , ' ▁ ' ; } } $ n = 12 ; $ k = 6 ; FindAllElements ( $ n , $ k ) ; ? >"}
{"text": "Semak sama ada A + B = C atau tidak selepas mengeluarkan semua sifar dari A, B dan C | Berfungsi untuk mengeluarkan sifar; Inisialisasi hasil kepada sifar memegang keputusan selepas mengeluarkan sifar dari NO; Memulakan pembolehubah d hingga 1 yang memegang digit NO; Gelung manakala n lebih besar maka sifar; Semak jika n mod 10 tidak sama dengan sifar; Simpan hasilnya dengan mengeluarkan sifar dan kenaikan d sebanyak 10; Pergi ke digit seterusnya; Mengembalikan hasilnya; Fungsi untuk memeriksa sama ada SUM adalah benar selepas mengeluarkan semua sifar. ; Hubungi RoveWero () untuk kedua -dua belah pihak dan periksa sama ada ia sama selepas mengeluarkan sifar. ; Kod pemacu", "code": "< ? php function removeZero ( $ n ) { $ res = 0 ; $ d = 1 ; while ( $ n > 0 ) { if ( $ n % 10 != 0 ) { $ res += ( $ n % 10 ) * $ d ; $ d *= 10 ; } $ n = floor ( $ n / 10 ) ; } return $ res ; } function isEqual ( $ a , $ b ) { if ( removeZero ( $ a ) + removeZero ( $ b ) == removeZero ( $ a + $ b ) ) return true ; return false ; } $ a = 105 ; $ b = 106 ; if ( isEqual ( $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Teka -teki Array Jumlah | Pelaksanaan PHP pendekatan di atas; Memperuntukkan memori untuk array sementara kiri [], rightsum [] dan jumlah []; Kiri paling banyak elemen array kiri sentiasa 0; Paling tidak paling elemen dari array kanan sentiasa 0; Membina array kiri; Membina array yang betul; Membina array jumlah menggunakan kiri [] dan kanan []; Cetak array prod yang dibina; Kod pemacu", "code": "< ? php function sumArray ( $ arr , $ n ) { $ leftSum = array_fill ( 0 , $ n , 0 ) ; $ rightSum = array_fill ( 0 , $ n , 0 ) ; $ Sum = array_fill ( 0 , $ n , 0 ) ; $ leftSum [ 0 ] = 0 ; $ rightSum [ $ n - 1 ] = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ leftSum [ $ i ] = $ arr [ $ i - 1 ] + $ leftSum [ $ i - 1 ] ; for ( $ j = $ n - 2 ; $ j >= 0 ; $ j -- ) $ rightSum [ $ j ] = $ arr [ $ j + 1 ] + $ rightSum [ $ j + 1 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ Sum [ $ i ] = $ leftSum [ $ i ] + $ rightSum [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ Sum [ $ i ] . \" ▁ \" ; } $ arr = array ( 3 , 6 , 4 , 8 , 9 ) ; $ n = count ( $ arr ) ; sumArray ( $ arr , $ n ) ; ? >"}
{"text": "Cari minimum x seperti itu (x % k) * (x / k) == n | Set | Fungsi memberikan jawapan yang diperlukan; Melangkah untuk semua faktor; Semak jika saya adalah faktor; Pertimbangkan saya untuk menjadi A dan N / I menjadi b; Pertimbangkan saya untuk menjadi b dan n / i untuk menjadi; Kod pemacu", "code": "< ? php function minimumX ( $ n , $ k ) { $ mini = PHP_INT_MAX ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ fir = $ i ; $ sec = ( int ) $ n / $ i ; $ num1 = $ fir * $ k + $ sec ; $ res = ( int ) ( $ num1 / $ k ) * ( $ num1 % $ k ) ; if ( $ res == $ n ) $ mini = min ( $ num1 , $ mini ) ; $ num2 = $ sec * $ k + $ fir ; $ res = ( int ) ( $ num2 / $ k ) * ( $ num2 % $ k ) ; if ( $ res == $ n ) $ mini = min ( $ num2 , $ mini ) ; } } return $ mini ; } $ n = 4 ; $ k = 6 ; echo minimumX ( $ n , $ k ) , \" STRNEWLINE \" ; $ n = 5 ; $ k = 5 ; echo minimumX ( $ n , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari minimum x seperti itu (x % k) * (x / k) == n | Fungsi ini memberikan jawapan yang diperlukan; Melangkah ke atas semua sisa yang mungkin; ia mesti membahagikan n; Kod pemacu", "code": "< ? php function minimumX ( $ n , $ k ) { $ ans = PHP_INT_MAX ; for ( $ rem = $ k - 1 ; $ rem > 0 ; $ rem -- ) { if ( $ n % $ rem == 0 ) $ ans = min ( $ ans , $ rem + ( $ n / $ rem ) * $ k ) ; } return $ ans ; } $ n = 4 ; $ k = 6 ; echo minimumX ( $ n , $ k ) , \" STRNEWLINE \" ; $ n = 5 ; $ k = 5 ; echo minimumX ( $ n , $ k ) ; ? >"}
{"text": "Cari Nth Hermite Number | Berfungsi untuk mengembalikan nombor hermite nth; Keadaan asas; Kod pemacu; Cetak nombor Hermite n", "code": "< ? php function getHermiteNumber ( $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n == 1 ) return 0 ; else return -2 * ( $ n - 1 ) * getHermiteNumber ( $ n - 2 ) ; } $ n = 6 ; echo getHermiteNumber ( $ n ) ; ? >"}
{"text": "Cari Nombor A dan B yang memenuhi syarat -syarat yang diberikan | Berfungsi untuk mencetak nombor yang diperlukan; Katakan b = n dan kami mahu % b = 0 dan juga (a / b) <n so a = b * (n - 1); Kes khas jika n = 1 kita mendapat a = 0 jadi (a * b) <n; Jika tiada pasangan memenuhi syarat; Kod pemacu", "code": "< ? php function find ( $ n ) { $ b = $ n ; $ a = $ b * ( $ n - 1 ) ; if ( $ a * $ b > $ n && $ a / $ b < $ n ) { echo \" a = \" ▁ , ▁ $ a ▁ , ▁ \" , b = \" } else echo - 1 ; } $ n = 10 ; find ( $ n ) ; ? >"}
{"text": "Square sempurna yang paling dekat dan jaraknya | Berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Berfungsi untuk mencari persegi sempurna yang paling dekat mengambil langkah -langkah minimum untuk dicapai dari nombor; Pembolehubah untuk menyimpan nombor persegi sempurna pertama di atas dan di bawah n; Mencari nombor persegi pertama yang lebih besar daripada n; Mencari nombor persegi pertama yang kurang daripada n; Pembolehubah untuk menyimpan perbezaan; Kod pemacu", "code": "< ? php function isPerfect ( $ N ) { if ( ( sqrt ( $ N ) - floor ( sqrt ( $ N ) ) ) != 0 ) return false ; return true ; } function getClosestPerfectSquare ( $ N ) { if ( isPerfect ( $ N ) ) { echo $ N , \" ▁ \" , \"0\" , \" STRNEWLINE \" ; return ; } $ aboveN = -1 ; $ belowN = -1 ; $ n1 ; $ n1 = $ N + 1 ; while ( true ) { if ( isPerfect ( $ n1 ) ) { $ aboveN = $ n1 ; break ; } else $ n1 ++ ; } $ n1 = $ N - 1 ; while ( true ) { if ( isPerfect ( $ n1 ) ) { $ belowN = $ n1 ; break ; } else $ n1 -- ; } $ diff1 = $ aboveN - $ N ; $ diff2 = $ N - $ belowN ; if ( $ diff1 > $ diff2 ) echo $ belowN , \" ▁ \" , $ diff2 ; else echo $ aboveN , \" ▁ \" , $ diff1 ; } $ N = 1500 ; getClosestPerfectSquare ( $ N ) ; ? >"}
{"text": "Pecahan | Berfungsi untuk mengembalikan GCD A dan B; Berfungsi untuk menukar pecahan yang diperolehi ke dalam bentuk yang paling mudah; Mencari GCD kedua -dua istilah; Menukar kedua -dua istilah ke dalam istilah yang lebih mudah dengan membahagikannya dengan faktor umum; Berfungsi untuk menambah dua pecahan; Mencari GCD DEN1 dan DEN2; Penyebut pecahan akhir diperolehi mencari LCM DEN1 dan DEN2 LCM * GCD = A * B; Menukar pecahan untuk mempunyai pengangka penyebut yang sama dari pecahan akhir yang diperolehi; Fungsi memanggil untuk menukar pecahan akhir ke dalam bentuk yang paling mudah; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function lowest ( & $ den3 , & $ num3 ) { $ common_factor = gcd ( $ num3 , $ den3 ) ; $ den3 = ( int ) $ den3 / $ common_factor ; $ num3 = ( int ) $ num3 / $ common_factor ; } function addFraction ( $ num1 , $ den1 , $ num2 , $ den2 , & $ num3 , & $ den3 ) { $ den3 = gcd ( $ den1 , $ den2 ) ; $ den3 = ( $ den1 * $ den2 ) / $ den3 ; $ num3 = ( $ num1 ) * ( $ den3 / $ den1 ) + ( $ num2 ) * ( $ den3 / $ den2 ) ; lowest ( $ den3 , $ num3 ) ; } $ num1 = 1 ; $ den1 = 500 ; $ num2 = 2 ; $ den2 = 1500 ; $ den3 ; $ num3 ; addFraction ( $ num1 , $ den1 , $ num2 , $ den2 , $ num3 , $ den3 ) ; echo $ num1 , \" / \" , $ den1 , \" ▁ + ▁ \" , $ num2 , \" / \" , $ den2 , \" ▁ is ▁ equal ▁ to ▁ \" , $ num3 , \" / \" , $ den3 , \" STRNEWLINE \" ; ? >"}
{"text": "Pembahagi terbesar nombor yang tidak dapat dibahagikan dengan persegi yang sempurna | Berfungsi untuk mencari pembahagi terbesar yang tidak dapat dibahagikan dengan mana -mana persegi sempurna lebih besar daripada 1; Jika nombor itu boleh dibahagikan dengan i * i, maka keluarkan satu i; Sekarang semua dataran dikeluarkan dari N; Kod pemacu", "code": "< ? php function findLargestDivisor ( $ n ) { for ( $ i = 2 ; $ i < sqrt ( $ n ) + 1 ; $ i ++ ) { while ( $ n % ( $ i * $ i ) == 0 ) { $ n = $ n / $ i ; } } return $ n ; } $ n = 12 ; echo ( findLargestDivisor ( $ n ) ) ; echo ( \" STRNEWLINE \" ) ; $ n = 97 ; echo ( findLargestDivisor ( $ n ) ) ; ? >"}
{"text": "Perkembangan Aritmetik | Pulangan benar jika permutasi ARR [0 .. n - 1] boleh membentuk perkembangan aritmetik; Susun array; Selepas menyusun, perbezaan antara unsur -unsur berturut -turut mestilah sama. ; Kod pemacu", "code": "< ? php function checkIsAP ( $ arr , $ n ) { if ( $ n == 1 ) return true ; sort ( $ arr ) ; $ d = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] != $ d ) return false ; return true ; } $ arr = array ( 20 , 15 , 5 , 0 , 10 ) ; $ n = count ( $ arr ) ; if ( checkIsAP ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak jika nombor adalah nombor Triperfect | Pulangan benar jika n adalah triperfect; Untuk menyimpan jumlah pembahagi. Menambah 1 dan N kerana mereka adalah pembahagi n. ; Cari semua pembahagi dan tambahkannya; Jika jumlah pembahagi adalah sama dengan 3 * n, maka n adalah nombor triperfect; Kod pemacu", "code": "< ? php function isTriPerfect ( $ n ) { $ sum = 1 + $ n ; $ i = 2 ; while ( $ i * $ i <= $ n ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ sum = $ sum + $ i ; else $ sum = $ sum + $ i + $ n / $ i ; } $ i += 1 ; } if ( $ sum == 3 * $ n and $ n != 1 ) return true ; else false ; } $ n = 120 ; if ( isTriPerfect ( $ n ) ) echo $ n . \" ▁ is ▁ a ▁ Triperfect ▁ number \" ; else echo $ n . \" ▁ is ▁ not ▁ a ▁ Triperfect ▁ number \" ; ? >"}
{"text": "Jumlah nombor semulajadi n yang pertama yang boleh dibahagikan dengan x atau y | Berfungsi untuk mengira jumlah nombor yang boleh dibahagi dengan x atau y; Kod pemacu", "code": "< ? php function sum ( $ N , $ X , $ Y ) { $ S1 ; $ S2 ; $ S3 ; $ S1 = floor ( ( ( int ) $ N / $ X ) ) * ( 2 * $ X + ( int ) ( ( int ) $ N / $ X - 1 ) * $ X ) / 2 ; $ S2 = floor ( ( ( int ) $ N / $ Y ) ) * ( 2 * $ Y + ( int ) ( ( int ) $ N / $ Y - 1 ) * $ Y ) / 2 ; $ S3 = floor ( ( ( int ) $ N / ( $ X * $ Y ) ) ) * ( 2 * ( $ X * $ Y ) + ( ( int ) $ N / ( $ X * $ Y ) - 1 ) * ( int ) ( $ X * $ Y ) ) / 2 ; return ceil ( $ S1 + ( $ S2 - $ S3 ) ) ; } $ N = 14 ; $ X = 3 ; $ Y = 5 ; echo sum ( $ N , $ X , $ Y ) ; #This  code is contributed by ajit. NEW_LINE ? >"}
{"text": "Kira nombor dari julat yang faktor utama hanya 2 dan 3 | Berfungsi untuk mengira nombor dalam julat yang faktor utama hanya 2 dan 3; Mulakan dengan 2 supaya 1 tidak dapat dikira; Walaupun NUM dibahagikan dengan 2, bahagikannya dengan 2; Walaupun NUM dibahagikan dengan 3, bahagikannya dengan 3; Jika NUM dikurangkan kepada 1 maka ia hanya mempunyai 2 dan 3 sebagai faktor utama; Kod pemacu", "code": "< ? php function findTwoThreePrime ( $ l , $ r ) { if ( $ l == 1 ) $ l ++ ; $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ num = $ i ; while ( $ num % 2 == 0 ) $ num /= 2 ; while ( $ num % 3 == 0 ) $ num /= 3 ; if ( $ num == 1 ) $ count ++ ; } return $ count ; } $ l = 1 ; $ r = 10 ; echo findTwoThreePrime ( $ l , $ r ) ; ? >"}
{"text": "Nombor maksimum dengan produk faktorial digit yang sama | Berfungsi untuk mengembalikan nombor yang diperlukan; Hitung kekerapan setiap digit; 4! boleh dinyatakan sebagai 2! * 2! * 3! ; 6! boleh dinyatakan sebagai 5! * 3! ; 8! boleh dinyatakan sebagai 7! * 2! * 2! * 2! ; 9! boleh dinyatakan sebagai 7! * 3! * 3! * 2! ; Untuk menyimpan nombor yang diperlukan; Jika nombor hanya mempunyai 1 dan 0 sebagai digitnya; Menjana bilangan terbesar yang mungkin; Kod pemacu", "code": "< ? php function getNumber ( $ s ) { $ number_of_digits = strlen ( $ s ) ; $ freq = array_fill ( 0 , 10 , 0 ) ; for ( $ i = 0 ; $ i < $ number_of_digits ; $ i ++ ) { if ( $ s [ $ i ] == '1' $ s [ $ i ] == '2' $ s [ $ i ] == '3' $ s [ $ i ] == '5' $ s [ $ i ] == '7' ) { $ freq [ ord ( $ s [ $ i ] ) - 48 ] += 1 ; } if ( $ s [ $ i ] == '4' ) { $ freq [ 2 ] += 2 ; $ freq [ 3 ] ++ ; } if ( $ s [ $ i ] == '6' ) { $ freq [ 5 ] ++ ; $ freq [ 3 ] ++ ; } if ( $ s [ $ i ] == '8' ) { $ freq [ 7 ] ++ ; $ freq [ 2 ] += 3 ; } if ( $ s [ $ i ] == '9' ) { $ freq [ 7 ] ++ ; $ freq [ 3 ] += 2 ; $ freq [ 2 ] ++ ; } } $ t = \" \" ; if ( $ freq [ 1 ] == $ number_of_digits || $ freq [ 0 ] == $ number_of_digits || ( $ freq [ 0 ] + $ freq [ 1 ] ) == $ number_of_digits ) { return $ s ; } else { for ( $ i = 9 ; $ i >= 2 ; $ i -- ) { $ ctr = $ freq [ $ i ] ; while ( $ ctr -- ) { $ t . = chr ( $ i + 48 ) ; } } return $ t ; } } $ s = \"1280\" ; echo getNumber ( $ s ) ; ? >"}
{"text": "Program untuk mencari nombor N iccanobif pertama | Fungsi berulang untuk membalikkan digit NUM; Berfungsi untuk mencetak nombor n icanobif pertama; Memulakan nombor kedua, kedua; Cetak dua nombor pertama; Membalikkan digit dua syarat terdahulu dan menambahkannya; Kod pemacu", "code": "< ? php function reversDigits ( $ num ) { $ rev_num = 0 ; while ( $ num > 0 ) { $ rev_num = ( $ rev_num * 10 ) + ( $ num % 10 ) ; $ num = ( int ) ( $ num / 10 ) ; } return $ rev_num ; } function icanobifNumbers ( $ N ) { $ first = 0 ; $ second = 1 ; if ( $ N == 1 ) echo $ first ; else if ( $ N == 2 ) echo $ first , \" ▁ \" , $ second ; else { echo $ first , \" \" ▁ , ▁ $ second , ▁ \" \" for ( $ i = 3 ; $ i <= $ N ; $ i ++ ) { $ x = reversDigits ( $ first ) ; $ y = reversDigits ( $ second ) ; echo ( $ x + $ y ) , \" ▁ \" ; $ temp = $ second ; $ second = $ x + $ y ; $ first = $ temp ; } } } $ N = 12 ; icanobifNumbers ( $ N ) ; ? >"}
{"text": "Tambah n digit ke A sedemikian rupa sehingga dibahagikan dengan b selepas setiap tambahan | Pelaksanaan PHP pendekatan; Cuba semua digit dari (0 hingga 9); Gagal dalam langkah pertama itu sendiri; Tambah (n - 1) 0 's; Kod pemacu", "code": "< ? php function addNDigits ( $ a , $ b , $ n ) { $ num = $ a ; for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { $ tmp = $ a * 10 + $ i ; if ( $ tmp % $ b == 0 ) { $ a = $ tmp ; break ; } } if ( $ num == $ a ) return -1 ; for ( $ j = 0 ; $ j < $ n - 1 ; $ j ++ ) $ a *= 10 ; return $ a ; } $ a = 5 ; $ b = 3 ; $ n = 3 ; echo addNDigits ( $ a , $ b , $ n ) ;"}
{"text": "Bilangan kiraan tiga (a, b, c) sedemikian rupa sehingga a ^ 2 + b ^ 2 = c ^ 2 dan 1 <= a <= b <= c <= n | Fungsi kepada IND bilangan triplet 1 <= a <= b <= c <= n, seperti itu ^ 2 + b ^ 2 = c ^ 2; untuk menyimpan jawapan yang diperlukan; Jalankan gelung bersarang untuk dua nombor pertama. ; nombor ketiga; Semak jika nombor ketiga adalah persegi sempurna dan kurang daripada n; Kod pemacu; panggilan fungsi", "code": "< ? php function Triplets ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = $ i ; $ j <= $ n ; ++ $ j ) { $ x = $ i * $ i + $ j * $ j ; $ y = ( int ) sqrt ( $ x ) ; if ( $ y * $ y == $ x && $ y <= $ n ) ++ $ ans ; } } return $ ans ; } $ n = 10 ; echo Triplets ( $ n ) ; ? >"}
{"text": "Jumlah digit nombor n yang ditulis dalam semua pangkalan dari 2 hingga n / 2 | Fungsi untuk mengira jumlah digit n dalam asas yang diberikan; Jumlah digit; Digit n dalam asas yang diberikan; Tambah digit; Fungsi untuk mengira jumlah digit N dalam pangkalan dari 2 hingga n / 2; untuk menyimpan jumlah digit di semua pangkalan; fungsi panggilan untuk pelbagai pangkalan; Kod pemacu", "code": "< ? php function solve ( $ n , $ base ) { $ sum = 0 ; while ( $ n > 0 ) { $ remainder = $ n % $ base ; $ sum += $ remainder ; $ n = $ n / $ base ; } return $ sum ; } function SumsOfDigits ( $ n ) { $ sum = 0 ; for ( $ base = 2 ; $ base <= $ n / 2 ; ++ $ base ) $ sum += solve ( $ n , $ base ) ; echo $ sum ; } $ n = 8 ; SumsOfDigits ( $ n ) ; ? >"}
{"text": "Nombor terbesar dalam array yang bukan kiub yang sempurna | Berfungsi untuk memeriksa sama ada nombor adalah nombor kiub yang sempurna atau tidak; mengambil sqrt nombor; cek jika ia adalah nombor kiub yang sempurna; Berfungsi untuk mencari nombor kiub bukan sempurna dalam array; menyimpan maksimum semua nombor kiub yang sempurna; Melintasi semua elemen dalam array; Simpan maksimum jika elemen semasa adalah kiub bukan sempurna; Kod pemacu", "code": "< ? php function checkPerfectcube ( $ n ) { $ d = ( int ) round ( pow ( $ n , 1 / 3 ) ) ; if ( $ d * $ d * $ d == $ n ) return true ; return false ; } function largestNonPerfectcubeNumber ( $ a , $ n ) { $ maxi = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ! checkPerfectcube ( $ a [ $ i ] ) ) $ maxi = max ( $ a [ $ i ] , $ maxi ) ; } return $ maxi ; } $ a = array ( 16 , 64 , 25 , 2 , 3 , 10 ) ; $ n = count ( $ a ) ; echo largestNonPerfectcubeNumber ( $ a , $ n ) ; ? >"}
{"text": "Semak jika n boleh diwakili sebagai jumlah bilangan bulat yang dipilih dari set {a, b} | Fungsi untuk mencari jika nombor n boleh diwakili sebagai jumlah 's dan u; keadaan asas; Jika X sudah dilawati; Tetapkan x yang mungkin; panggilan rekursif; Kod pemacu", "code": "< ? php function checkIfPossibleRec ( $ x , $ a , $ b , $ isPossible , $ n ) { if ( $ x > $ n ) return ; if ( $ isPossible == true ) return ; $ isPossible [ $ x ] = true ; checkIfPossibleRec ( $ x + $ a , $ a , $ b , $ isPossible , $ n ) ; checkIfPossibleRec ( $ x + $ b , $ a , $ b , $ isPossible , $ n ) ; } function checkPossible ( $ n , $ a , $ b ) { $ isPossible [ $ n + 1 ] = array ( false ) ; checkIfPossibleRec ( 0 , $ a , $ b , $ isPossible , $ n ) ; return $ isPossible ; } $ a = 3 ; $ b = 7 ; $ n = 8 ; if ( checkPossible ( $ a , $ b , $ n ) ) echo \" No \" ; else echo \" Yes \" ; ? >"}
{"text": "Jumlah semua nombor semulajadi ganjil dalam julat l dan r | Berfungsi untuk mengembalikan jumlah semua nombor semulajadi yang ganjil; Berfungsi untuk mengembalikan jumlah semua nombor ganjil dalam julat l dan r; Kod pemacu", "code": "< ? php function sumOdd ( $ n ) { $ terms = ( int ) ( $ n + 1 ) / 2 ; $ sum = $ terms * $ terms ; return $ sum ; } function suminRange ( $ l , $ r ) { return sumOdd ( $ r ) - sumOdd ( $ l - 1 ) ; } $ l = 2 ; $ r = 5 ; echo \" Sum ▁ of ▁ odd ▁ natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ \" , suminRange ( $ l , $ r ) ; ? >"}
{"text": "Jumlah pembahagi biasa dua nombor a dan b | Berfungsi untuk mengira GCD dua nombor; Fungsi untuk mengira semua pembahagi biasa dua nombor tertentu A, B -> Input Integer Number; Cari GCD A, B; Cari jumlah pembahagi n. ; jika 'i' adalah faktor n; Semak jika pembahagi adalah sama; Program pemacu untuk menjalankan kes itu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function sumcommDiv ( $ a , $ b ) { $ n = gcd ( $ a , $ b ) ; $ sum = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ sum += $ i ; else $ sum += ( $ n / $ i ) + $ i ; } } return $ sum ; } $ a = 10 ; $ b = 15 ; echo \" Sum = \" ? >"}
{"text": "Semak sama ada nombor dibentuk dengan penggabungan 1, 14 atau 144 sahaja | Fungsi untuk memeriksa sama ada nombor dibentuk oleh penggabungan 1, 14 atau 144 sahaja; Semak untuk setiap digit yang mungkin jika diberi nombor terdiri daripada yang lain maka 1, 14, 144 cetak tidak lain cetak ya; Kod pemacu", "code": "< ? php function checkNumber ( $ N ) { $ temp = $ N ; while ( $ temp > 0 ) { if ( $ temp % 1000 == 144 ) $ temp /= 1000 ; else if ( $ temp % 100 == 14 ) $ temp /= 100 ; else if ( $ temp % 10 == 1 ) $ temp /= 10 ; else { return \" YES \" ; } } return \" NO \" ; } $ N = 1414 ; echo checkNumber ( $ N ) ; ? >"}
{"text": "Masalah Fibonacci (Nilai FIB (N) * FIB (N) | PHP Pelaksanaan Pendekatan; Kod Pemandu", "code": "< ? php function getResult ( $ n ) { if ( $ n & 1 ) return 1 ; return -1 ; } $ n = 3 ; echo getResult ( $ n ) ; ? >"}
{"text": "Cari dua nombor dengan jumlah dan produk yang sama seperti n | Berfungsi untuk mengembalikan rentetan terkecil; Tidak mungkin; Cari A dan B; Kod pemacu", "code": "< ? php function findAandB ( $ N ) { $ val = $ N * $ N - 4.0 * $ N ; if ( $ val < 0 ) { echo \" NO \" ; return ; } $ a = ( $ N + sqrt ( $ val ) ) / 2.0 ; $ b = ( $ N - sqrt ( $ val ) ) / 2.0 ; echo \" a = \" ▁ , ▁ $ a , ▁ \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" b = \" ▁ , ▁ $ b , ▁ \" \" } $ N = 69.0 ; findAandB ( $ N ) ; ? >"}
{"text": "Cari operasi minimum yang diperlukan untuk membuat array cantik | Berfungsi untuk mencari operasi minimum yang diperlukan untuk membuat array cantik; Mengira sifar berturut -turut. ; Semak permulaan dan akhir yang sama; Cek adalah sifar dan satu sama; Kod pemacu", "code": "< ? php function minOperations ( $ A , $ n ) { if ( $ n & 1 ) return -1 ; $ zeros = 0 ; $ consZeros = 0 ; $ ones = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ A [ $ i ] == 0 ? $ zeros ++ : $ ones ++ ; if ( ( $ i + 1 ) < $ n ) { if ( $ A [ $ i ] == 0 && $ A [ $ i + 1 ] == 0 ) $ consZeros ++ ; } } if ( $ A [ 0 ] == $ A [ $ n - 1 ] && $ A [ 0 ] == 0 ) $ consZeros ++ ; if ( $ zeros == $ ones ) return $ consZeros ; else return -1 ; } $ A = array ( 1 , 1 , 0 , 0 ) ; $ n = sizeof ( $ A ) ; echo minOperations ( $ A , $ n ) ; ? >"}
{"text": "Langkah -langkah untuk mengurangkan N hingga sifar dengan menolak digit yang paling penting pada setiap langkah | Berfungsi untuk mengira bilangan digit dalam nombor m; Berfungsi untuk mengira bilangan langkah untuk mencapai 0; mengira jumlah STESP; melangkah sehingga kita mencapai 0; Kira digit pada terakhir; mengurangkannya dengan 1; Cari nombor di bahagiannya, kami mendapat digit pertama; digit pertama pada terakhir; Cari nombor pertama yang kurang daripada yang terakhir di mana angka pertama berubah; Cari bilangan nombor dengan digit pertama yang sama yang melompat; mengira langkah -langkah; nombor seterusnya dengan digit pertama yang berbeza; Kod pemacu", "code": "< ? php function countdig ( $ m ) { if ( $ m == 0 ) return 0 ; else return 1 + countdig ( ( int ) ( $ m / 10 ) ) ; } function countSteps ( $ x ) { $ c = 0 ; $ last = $ x ; while ( $ last ) { $ digits = countdig ( $ last ) ; $ digits -= 1 ; $ divisor = pow ( 10 , $ digits ) ; $ first = ( int ) ( $ last / $ divisor ) ; $ lastnumber = $ first * $ divisor ; $ skipped = ( $ last - $ lastnumber ) / $ first ; $ skipped += 1 ; $ c += $ skipped ; $ last = $ last - ( $ first * $ skipped ) ; } return $ c ; } $ n = 14 ; echo countSteps ( $ n ) ;"}
{"text": "GCD nombor yang dibangkitkan kepada beberapa kuasa dan nombor lain | Mengira eksponensi modular, i. e. , (x ^ y) % p dalam o (log y); $ x = $ x % $ p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; Mengembalikan GCD A ^ n dan B; Kod pemacu", "code": "< ? php function power ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function powerGCD ( $ a , $ b , $ n ) { $ e = power ( $ a , $ n , $ b ) ; return gcd ( $ e , $ b ) ; } $ a = 5 ; $ b = 4 ; $ n = 2 ; echo powerGCD ( $ a , $ b , $ n ) ; ? >"}
{"text": "Nombor terbesar tidak lebih besar daripada n semua digit yang ganjil | Fungsi untuk memeriksa sama ada semua digit nombor adalah ganjil; melangkah untuk semua digit; jika digit adalah walaupun; Semua digit adalah ganjil; berfungsi untuk mengembalikan nombor terbesar dengan semua digit ganjil; Iterat sehingga kita dapati nombor dengan semua digit ganjil; Kod pemacu", "code": "< ? php function allOddDigits ( $ n ) { while ( $ n > 1 ) { if ( ( $ n % 10 ) % 2 == 0 ) return false ; $ n = ( int ) $ n / 10 ; } return true ; } function largestNumber ( $ n ) { if ( $ n % 2 == 0 ) $ n -- ; for ( $ i = $ n ; ; $ i = ( $ i - 2 ) ) if ( allOddDigits ( $ i ) ) return $ i ; } $ N = 23 ; echo largestNumber ( $ N ) ; ? >"}
{"text": "Nombor kiraan kurang daripada n yang merupakan produk dataran yang sempurna | Berfungsi untuk mengira nombor kurang daripada n yang merupakan produk dari mana -mana dua dataran yang sempurna; Kod pemacu", "code": "< ? php function countNumbers ( $ N ) { return ( int ) ( sqrt ( $ N ) ) - 1 ; } $ N = 36 ; echo countNumbers ( $ N ) ; ? >"}
{"text": "Kira pasangan yang diperintahkan dengan produk kurang daripada n | Berfungsi untuk mengembalikan kiraan pasangan yang diperintahkan yang produknya kurang daripada n; Inisialisasi kiraan ke 0; mengira jumlah pasangan; Multiply by 2 untuk mendapatkan pesanan_pairs; Kurangkan pasangan berlebihan (a, b) di mana a == b. ; jawapan kembali; Kod pemacu; fungsi panggilan untuk mencetak jawapan yang diperlukan", "code": "< ? php function countOrderedPairs ( $ N ) { $ count_pairs = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ N - 1 ) ; ++ $ i ) { for ( $ j = $ i ; $ j * $ i < $ N ; ++ $ j ) ++ $ count_pairs ; } $ count_pairs *= 2 ; $ count_pairs -= ( sqrt ( $ N - 1 ) ) ; return $ count_pairs ; } $ N = 5 ; echo countOrderedPairs ( $ N ) ; ? >"}
{"text": "Perbezaan mutlak semua elemen berturut -turut pasangan dalam array | Berfungsi untuk mencetak perbezaan mutlak pasangan unsur berturut -turut; perbezaan mutlak antara nombor berturut -turut; Kod pemacu", "code": "< ? php function pairwiseDifference ( $ arr , $ n ) { $ diff = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ diff = abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; echo $ diff . \" \" ; } } $ arr = array ( 4 , 10 , 15 , 5 , 6 ) ; $ n = sizeof ( $ arr ) ; pairwiseDifference ( $ arr , $ n ) ; ? >"}
{"text": "Cari jumlah semua gandaan 2 dan 5 di bawah n | Fungsi untuk mencari jumlah siri AP; Bilangan istilah; Berfungsi untuk mencari jumlah semua gandaan 2 dan 5 di bawah n; Oleh kerana, kita memerlukan jumlah gandaan kurang daripada n; Kod pemacu", "code": "< ? php function sumAP ( $ n , $ d ) { $ n = ( int ) ( $ n / $ d ) ; return ( $ n ) * ( ( 1 + $ n ) * ( int ) $ d / 2 ) ; } function sumMultiples ( $ n ) { $ n -- ; return sumAP ( $ n , 2 ) + sumAP ( $ n , 5 ) - sumAP ( $ n , 10 ) ; } $ n = 20 ; echo sumMultiples ( $ n ) ; ? >"}
{"text": "Cari jumlah markah yang diperoleh mengikut skim penandaan yang diberikan | Fungsi yang mengira tanda. ; kerana tidak mencuba skor + 0; Untuk setiap skor jawapan yang betul + 3; Untuk setiap skor jawapan yang salah - 1; mengira jumlah markah; Kod pemacu", "code": "< ? php function markingScheme ( $ N , $ answerKey , $ studentAnswer ) { $ positive = 0 ; $ negative = 0 ; $ notattempt = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ studentAnswer [ $ i ] == 0 ) $ notattempt ++ ; else if ( $ answerKey [ $ i ] == $ studentAnswer [ $ i ] ) $ positive ++ ; else if ( $ answerKey [ $ i ] != $ studentAnswer [ $ i ] ) $ negative ++ ; } return ( $ positive * 3 ) + ( $ negative * -1 ) ; } $ answerKey = array ( 1 , 2 , 3 , 4 , 1 ) ; $ studentAnswer = array ( 1 , 2 , 3 , 4 , 0 ) ; $ N = sizeof ( $ answerKey ) ; echo markingScheme ( $ N , $ answerKey , $ studentAnswer ) ; ? >"}
{"text": "Cari produk nombor Nirt N Perdana | Pelaksanaan PHP penyelesaian di atas; Buat array boolean \"$ prime [0. $ n]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam $ Perdana [i] akhirnya akan palsu jika saya bukan $ Perdana, yang lain benar. ; Jika $ prime [$ p] tidak berubah, maka ia adalah $ prime; Tetapkan semua gandaan $$ p ke bukan $ prime; Cari produk nombor 1 st $ prime; $ Count $ prime nombor; Produk $ Nombor Perdana; Jika nombor $ prime tambahkannya; Meningkatkan kiraan $; sampai ke nombor seterusnya; buat penapis; Cari nilai nombor Perdana 1 ST $ N $", "code": "< ? php $ MAX = 10000 ; $ prime = array_fill ( 0 , $ MAX + 1 , true ) ; function SieveOfEratosthenes ( ) { global $ MAX ; global $ prime ; $ prime = array_fill ( 0 , $ MAX + 1 , true ) ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ MAX ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ MAX ; $ i += $ p ) $ prime [ $ i ] = false ; } } } function solve ( $ n ) { global $ prime ; $ count = 0 ; $ num = 1 ; $ prod = 1 ; while ( $ count < $ n ) { if ( $ prime [ $ num ] == true ) { $ prod *= $ num ; $ count ++ ; } $ num ++ ; } return $ prod ; } SieveOfEratosthenes ( ) ; $ n = 5 ; echo solve ( $ n ) ; ? >"}
{"text": "Semak jika ada pasangan dalam julat yang diberikan dengan GCD boleh dibahagikan dengan k | Mengembalikan kiraan nombor dalam [l r] yang boleh dibahagikan oleh k. ; Tambah 1 secara eksplisit kerana L boleh dibahagikan dengan k; L tidak boleh dibahagikan dengan k; Kod pemacu", "code": "< ? php function Check_is_possible ( $ l , $ r , $ k ) { $ div_count = ( int ) ( $ r / $ k ) - ( int ) ( $ l / $ k ) ; if ( $ l % $ k == 0 ) $ div_count ++ ; return ( $ div_count > 1 ) ; } $ l = 30 ; $ r = 70 ; $ k = 10 ; if ( Check_is_possible ( $ l , $ r , $ k ) ) echo \" YES STRNEWLINE \" ; else echo \" NO STRNEWLINE \" ; ? >"}
{"text": "Cari Jumlah N | hitung jumlah kumpulan nth; Kod pemacu", "code": "< ? php function nth_group ( $ n ) { return $ n * ( 2 * pow ( $ n , 2 ) + 1 ) ; } $ N = 5 ; echo nth_group ( $ N ) ; ? >"}
{"text": "Cari jika molekul boleh dibentuk dari 3 atom menggunakan nombor valensi mereka | Fungsi untuk memeriksa sama ada mungkin; Kod pemacu", "code": "< ? php function printPossible ( $ a , $ b , $ c ) { if ( ( $ a + $ b + $ c ) % 2 != 0 $ a + $ b < $ c ) echo ( \" NO \" ) ; else echo ( \" YES \" ) ; } $ a = 2 ; $ b = 4 ; $ c = 2 ; printPossible ( $ a , $ b , $ c ) ; ? >"}
{"text": "Cari Jumlah Terma pertama N Siri 2 Ã - 3 + 4 Ã - 4 + 6 Ã - 5 + 8 Ã - 6 + ... | Kirakan jumlah siri siri siri; Kod pemacu", "code": "< ? php function Sum_upto_nth_Term ( $ n ) { $ r = $ n * ( $ n + 1 ) * ( 2 * $ n + 7 ) / 3 ; echo $ r ; } $ N = 5 ; Sum_upto_nth_Term ( $ N ) ; ? >"}
{"text": "Perbezaan mutlak antara jumlah bukan | Fungsi untuk mencari perbezaan antara jumlah prima bukan dan jumlah prima array. ; Cari nilai maksimum dalam array; Gunakan ayak untuk mencari semua nombor perdana kurang daripada atau sama dengan max_val Buat array boolean \"Perdana [0 ... N]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Baki bahagian Sieve; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Simpan jumlah prima di S1 ​​dan jumlah prima di S2; Nombor itu adalah perdana; Nombor itu bukan perdana; Mengembalikan perbezaan mutlak; Dapatkan array; Cari perbezaan mutlak", "code": "< ? php function CalculateDifference ( $ arr , $ n ) { $ max_val = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ max_val ) $ max_val = $ arr [ $ i ] ; } $ prime = array_fill ( 0 , $ max_val + 1 , true ) ; $ prime [ 0 ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ max_val ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ max_val ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ S1 = 0 ; $ S2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ prime [ $ arr [ $ i ] ] ) { $ S1 += $ arr [ $ i ] ; } else if ( $ arr [ $ i ] != 1 ) { $ S2 += $ arr [ $ i ] ; } } return abs ( $ S2 - $ S1 ) ; } $ arr = array ( 1 , 3 , 5 , 10 , 15 , 7 ) ; $ n = sizeof ( $ arr ) ; echo CalculateDifference ( $ arr , $ n ) ; ? >"}
{"text": "Bilangan bilangan bilangan bulat kurang daripada atau sama dengan n yang mempunyai 9 pembahagi | Fungsi untuk mengira faktor dalam O (n); melangkah dan periksa sama ada faktor atau tidak; Fungsi untuk mengira nombor yang mempunyai 9 pembahagi; Semak semua nombor <= n; Semak sama ada 9 faktor atau tidak; Kod pemacu", "code": "< ? php Function numberOfDivisors ( $ num ) { $ c = 0 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { if ( $ num % $ i == 0 ) { $ c += 1 ; } } return $ c ; } Function countNumbers ( $ n ) { $ c = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( numberOfDivisors ( $ i ) == 9 ) $ c += 1 ; } return $ c ; } $ n = 1000 ; echo countNumbers ( $ n ) ; ? >"}
{"text": "Bilangan bilangan bulat yang diperolehi oleh LCM (x, n) / x | Fungsi untuk mengira bilangan bilangan bulat yang berbeza di atas oleh LCM (x, num) / x; berulang untuk mengira bilangan faktor; Kod pemacu", "code": "< ? php function numberOfDistinct ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ ans ++ ; if ( ( $ n / $ i ) != $ i ) $ ans ++ ; } } return $ ans ; } $ n = 3 ; echo numberOfDistinct ( $ n ) ; ? >"}
{"text": "Cari bilangan segi empat tepat saiz 2 * 1 yang boleh diletakkan di dalam segi empat tepat saiz n * m | berfungsi untuk mencari bilangan segi empat tepat saiz 2 * 1 boleh diletakkan di dalam segi empat tepat saiz n * m; jika n juga; jika m adalah walaupun; Jika kedua -duanya ganjil; Kod pemacu; panggilan fungsi", "code": "< ? php function NumberOfRectangles ( $ n , $ m ) { if ( $ n % 2 == 0 ) return ( $ n / 2 ) * $ m ; else if ( $ m % 2 == 0 ) return ( $ m / 2 ) * $ n ; return ( $ n * $ m - 1 ) / 2 ; } $ n = 3 ; $ m = 3 ; echo NumberOfRectangles ( $ n , $ m ) ; ? >"}
{"text": "Seterusnya nombor yang lebih besar daripada n dengan kuantiti digit yang sama a dan b | Fungsi rekursif untuk mencari nombor yang diperlukan; Jika nombor yang dihasilkan adalah> = n dan kiraan a = kiraan b, kembalikan nombor; Pilih minimum dua dan hubungi fungsi lagi; Berfungsi untuk mencari nombor seterusnya nombor yang lebih besar daripada n dengan kuantiti digit A dan B yang sama; Kod pemacu", "code": "< ? php function findNumUtil ( $ res , $ a , $ aCount , $ b , $ bCount , $ n ) { if ( $ res > 100000000000 ) return 10000000000 ; if ( $ aCount == $ bCount && $ res >= $ n ) return $ res ; return min ( findNumUtil ( $ res * 10 + $ a , $ a , $ aCount + 1 , $ b , $ bCount , $ n ) , findNumUtil ( $ res * 10 + $ b , $ a , $ aCount , $ b , $ bCount + 1 , $ n ) ) ; } function findNum ( $ n , $ a , $ b ) { $ result = 0 ; $ aCount = 0 ; $ bCount = 0 ; return findNumUtil ( $ result , $ a , $ aCount , $ b , $ bCount , $ n ) ; } $ N = 4500 ; $ A = 4 ; $ B = 7 ; echo findNum ( $ N , $ A , $ B ) ; ? >"}
{"text": "Minimum dan maksimum bilangan n coklat selepas pengedaran di kalangan pelajar k | Kod pemacu", "code": "< ? php $ n = 7 ; $ k = 3 ; if ( $ n % $ k == 0 ) echo $ n / $ k . \" ▁ \" . $ n / $ k ; else echo ( ( $ n - ( $ n % $ k ) ) / $ k ) . \" ▁ \" . ( ( ( $ n - ( $ n % $ k ) ) / $ k ) + 1 ) ; ? >"}
{"text": "Jumlah wang yang akan dibayar selepas perjalanan bilangan jam yang diberikan | Pelaksanaan PHP pendekatan di atas; Mengira jam perjalanan", "code": "< ? php $ m = 50 ; $ n = 5 ; $ x = 67 ; $ h = 2927 ; $ z = ( int ) ( ceil ( $ h / 60 ) ) ; if ( $ z <= $ n ) print ( $ z * $ m ) ; else print ( $ n * $ m + ( $ z - $ n ) * $ x ) ; ? >"}
{"text": "Perbezaan mutlak antara jumlah dan produk akar persamaan kuartik | Fungsi mengambil pekali setiap istilah persamaan sebagai input; Mencari jumlah akar; Mencari produk akar; Perbezaan mutlak; Kod pemacu", "code": "< ? php function sumProductDifference ( $ a , $ b , $ c , $ d , $ e ) { $ rootSum = ( double ) ( -1 * $ b ) / $ a ; $ rootProduct = ( double ) $ e / $ a ; return abs ( $ rootSum - $ rootProduct ) ; } echo sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ; ? >"}
{"text": "Bilangan penyelesaian n = x + n Âš • x | Fungsi untuk mencari bilangan penyelesaian n = n xor x; Kaunter untuk menyimpan bilangan penyelesaian yang dijumpai; Kod pemacu", "code": "< ? php function numberOfSolutions ( $ n ) { $ c = 0 ; for ( $ x = 0 ; $ x <= $ n ; ++ $ x ) if ( $ n == $ x + $ n ^ $ x ) ++ $ c ; return $ c ; } $ n = 3 ; echo numberOfSolutions ( $ n ) ;"}
{"text": "Program untuk mencari bilangan kuliah minimum untuk menghadiri untuk mengekalkan 75 % | Berfungsi untuk mengira kuliah minimum; Formula untuk mengira; Kod pemacu", "code": "< ? php function minimumLectures ( $ m , $ n ) { $ ans = 0 ; if ( $ n < ceil ( 0.75 * $ m ) ) $ ans = ( int ) ceil ( ( ( 0.75 * $ m ) - $ n ) / 0.25 ) ; else $ ans = 0 ; return $ ans ; } $ M = 9 ; $ N = 1 ; echo minimumLectures ( $ M , $ N ) ; ? >"}
{"text": "Nombor kiraan dengan digit N yang terdiri daripada nombor ganjil 0 's | Berfungsi untuk mengira nombor dengan digit N yang terdiri daripada nombor ganjil 0; Kod pemacu", "code": "< ? php function countNumbers ( $ N ) { return ( pow ( 10 , $ N ) - pow ( 8 , $ N ) ) / 2 ; } $ n = 5 ; echo countNumbers ( $ n ) ; ? >"}
{"text": "Jumlah terma pertama N Siri 5, 12, 23, 38. ... | Berfungsi untuk mengira jumlah; bilangan terma yang akan dimasukkan dalam jumlah; Cari SN", "code": "< ? php function calculateSum ( $ n ) { return 2 * ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 6 ) + $ n * ( $ n + 1 ) / 2 + 2 * ( $ n ) ; } $ n = 3 ; echo \" Sum = \" ? >"}
{"text": "Program untuk mencari bilangan penyelesaian dalam persamaan kuadrat | Kaedah untuk memeriksa penyelesaian persamaan; Jika ungkapan lebih besar daripada 0, maka 2 penyelesaian; Jika ungkapan adalah sama 0, maka 2 penyelesaian; Lain tiada penyelesaian; Kod pemacu", "code": "< ? php function checkSolution ( $ a , $ b , $ c ) { if ( ( ( $ b * $ b ) - ( 4 * $ a * $ c ) ) > 0 ) echo \"2 ▁ solutions \" ; else if ( ( ( $ b * $ b ) - ( 4 * $ a * $ c ) ) == 0 ) echo \"1 ▁ solution \" ; else echo \" No ▁ solutions \" ; } $ a = 2 ; $ b = 5 ; $ c = 2 ; checkSolution ( $ a , $ b , $ c ) ; ? >"}
{"text": "Program untuk menukar kilobytes ke bait dan bit | Berfungsi untuk mengira bit; mengira bit 1 kilobytes (s) = 8192 bit; Berfungsi untuk mengira bait; mengira bait 1 kb = 1024 bait; Kod pemacu", "code": "< ? php function Bits ( $ kilobytes ) { $ Bits = 0 ; $ Bits = $ kilobytes * 8192 ; return $ Bits ; } function Bytes ( $ kilobytes ) { $ Bytes = 0 ; $ Bytes = $ kilobytes * 1024 ; return $ Bytes ; } $ kilobytes = 1 ; echo $ kilobytes ; echo ( \" ▁ Kilobytes ▁ = ▁ \" ) ; echo Bytes ( $ kilobytes ) ; echo ( \" ▁ Bytes ▁ and ▁ \" ) ; echo Bits ( $ kilobytes ) ; echo ( \" ▁ Bits . \" ) ; ? >"}
{"text": "Program untuk mencari nombor tersembunyi | Mendapatkan saiz array; Mendapatkan pelbagai saiz n; Penyelesaian; Mencari jumlah elemen array; Membahagikan jumlah dengan saiz n; Cetak x, jika dijumpai", "code": "< ? php $ n = 3 ; $ a = array ( 1 , 2 , 3 ) ; $ i = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; } $ x = $ sum / $ n ; if ( $ x * $ n == $ sum ) echo ( $ x ) ; else echo ( \" - 1\" ) ; ? >"}
{"text": "Cari jumlah siri? 3 +? 12 + ... ... ... sehingga istilah | Berfungsi untuk mencari jumlah; Memohon formula AP; bilangan istilah", "code": "< ? php function findSum ( $ n ) { return sqrt ( 3 ) * ( $ n * ( $ n + 1 ) / 2 ) ; } $ n = 10 ; echo findSum ( $ n ) ; ? >"}
{"text": "Cari jumlah siri x (x + y) + x ^ 2 (x ^ 2 + y ^ 2) + x ^ 3 (x ^ 3 + y ^ 3) + ... + x ^ n (x ^ n + y ^ n) | Fungsi untuk mengembalikan jumlah yang diperlukan; Jumlah siri pertama; Jumlah siri kedua; Kod pemacu; fungsi panggilan untuk mencetak jumlah", "code": "< ? php function sum ( $ x , $ y , $ n ) { $ sum1 = ( pow ( $ x , 2 ) * ( pow ( $ x , 2 * $ n ) - 1 ) ) / ( pow ( $ x , 2 ) - 1 ) ; $ sum2 = ( $ x * $ y * ( pow ( $ x , $ n ) * pow ( $ y , $ n ) - 1 ) ) / ( $ x * $ y - 1 ) ; return $ sum1 + $ sum2 ; } $ x = 2 ; $ y = 2 ; $ n = 2 ; echo sum ( $ x , $ y , $ n ) ; ? >"}
{"text": "Cari mana -mana pasangan dengan GCD dan LCM yang diberikan | Berfungsi untuk mencetak pasangan; Kod pemacu", "code": "< ? php function printPair ( $ g , $ l ) { echo $ g ; echo ( \" ▁ \" ) ; echo $ l ; } $ g = 3 ; $ l = 12 ; printPair ( $ g , $ l ) ; ? >"}
{"text": "Jumlah terma pertama n Siri 3, 6, 11, .... . | Berfungsi untuk mengira jumlah; nombor permulaan; Nisbah biasa; Perbezaan umum; Istilah nth untuk dijumpai; Cari SN", "code": "< ? php function calculateSum ( $ n ) { $ a1 = 1 ; $ a2 = 2 ; $ r = 2 ; $ d = 1 ; return ( $ n ) * ( 2 * $ a1 + ( $ n - 1 ) * $ d ) / 2 + $ a2 * ( pow ( $ r , $ n ) - 1 ) / ( $ r - 1 ) ; } $ n = 5 ; echo \" Sum = \" ? >"}
{"text": "Bilangan minimum sub | Fungsi yang kembali benar jika n adalah kuasa 5; Berfungsi untuk mengembalikan nilai perpuluhan bersamaan binari; Berfungsi untuk mengembalikan potongan minimum yang diperlukan; Memori memori untuk array DP []; Dari panjang 1 hingga n; Jika watak sebelumnya adalah '0' maka abaikan untuk mengelakkan nombor dengan 0 s. ; Abaikan S [j] = '0' Nombor permulaan; Nombor yang dibentuk dari S [J .... i]; Periksa kuasa 5; Menetapkan nilai min untuk mendapatkan pemotongan min; (n + 1) Untuk memeriksa sama ada semua rentetan dilalui dan tidak dapat dibahagikan dengan 5 diperoleh seperti 000000; Kod pemacu", "code": "< ? php function ispower ( $ n ) { if ( $ n < 125 ) return ( $ n == 1 $ n == 5 $ n == 25 ) ; if ( $ n % 125 != 0 ) return false ; else return ispower ( $ n / 125 ) ; } function number ( $ s , $ i , $ j ) { $ ans = 0 ; for ( $ x = $ i ; $ x < $ j ; $ x ++ ) { $ ans = $ ans * 2 + ( ord ( $ s [ $ x ] ) - ord ( '0' ) ) ; } return $ ans ; } function minCuts ( $ s , $ n ) { $ dp = array_fill ( 0 , $ n + 1 , $ n + 1 ) ; $ dp [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ s [ $ i - 1 ] == '0' ) continue ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( $ s [ $ j ] == '0' ) continue ; $ num = number ( $ s , $ j , $ i ) ; if ( ! ispower ( $ num ) ) continue ; $ dp [ $ i ] = min ( $ dp [ $ i ] , $ dp [ $ j ] + 1 ) ; } } return ( ( $ dp [ $ n ] < $ n + 1 ) ? $ dp [ $ n ] : -1 ) ; } $ s = \"101101101\" ; $ n = strlen ( $ s ) ; echo minCuts ( $ s , $ n ) ; ? >"}
{"text": "Bilangan minimum kiub yang jumlahnya sama dengan nombor n | Berfungsi untuk mengembalikan bilangan minimum kiub yang jumlahnya adalah k; Jika k kurang daripada 2 ^ 3; Memulakan dengan bilangan maksimum kiub yang diperlukan; Kod pemacu", "code": "< ? php function MinOfCubed ( $ k ) { if ( $ k < 8 ) return $ k ; $ res = $ k ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( ( $ i * $ i * $ i ) > $ k ) return $ res ; $ res = min ( $ res , MinOfCubed ( $ k - ( $ i * $ i * $ i ) ) + 1 ) ; } return $ res ; } $ num = 15 ; echo MinOfCubed ( $ num ) ; ? >"}
{"text": "Bilangan minimum kiub yang jumlahnya sama dengan nombor n | Berfungsi untuk mengembalikan bilangan minimum kiub yang jumlahnya adalah k; Manakala kiub sempurna semasa adalah kurang daripada elemen semasa; Jika saya adalah kiub yang sempurna; i = (i - 1) + 1 ^ 3; Seterusnya Cube Perfect; Re - Inisialisasi untuk elemen seterusnya; Kod pemacu", "code": "< ? php function MinOfCubedDP ( $ k ) { $ DP = array ( $ k + 1 ) ; $ j = 1 ; $ t = 1 ; $ DP [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { $ DP [ $ i ] = PHP_INT_MAX ; while ( $ j <= $ i ) { if ( $ j == $ i ) $ DP [ $ i ] = 1 ; else if ( $ DP [ $ i ] > $ DP [ $ i - $ j ] ) $ DP [ $ i ] = $ DP [ $ i - $ j ] + 1 ; $ t ++ ; $ j = $ t * $ t * $ t ; } $ t = $ j = 1 ; } return $ DP [ $ k ] ; } $ num = 15 ; echo ( MinOfCubedDP ( $ num ) ) ; ? >"}
{"text": "Subarray Maksimum selepas membalikkan paling banyak dua elemen | Berfungsi untuk mengembalikan jumlah maksimum yang diperlukan - jumlah array; Mewujudkan satu pengindeksan berasaskan; Arahan 2D untuk mengandungi penyelesaian untuk setiap langkah; Kes 1: Memilih semasa atau (semasa + sebelumnya) mana yang lebih kecil; Kes 2: (a) Mengubah tanda dan tambah pada kes sebelumnya 1 atau nilai 0; Kes 2: (b) Menambah elemen semasa dengan kes sebelumnya 2 dan mengemas kini maksimum; Kes 3: (a) Mengubah tanda dan tambah pada kes sebelumnya 2; Kes 3: (b) Menambah elemen semasa dengan kes sebelumnya 3; Mengemas kini nilai maksimum pembolehubah ANS; Mengembalikan penyelesaian akhir; Kod pemacu", "code": "< ? php function maxSum ( $ a , $ n ) { $ ans = 0 ; $ arr = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ arr [ $ i ] = $ a [ $ i - 1 ] ; $ dp = array ( array ( ) ) ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ dp [ $ i ] [ 0 ] = max ( $ arr [ $ i ] , $ dp [ $ i - 1 ] [ 0 ] + $ arr [ $ i ] ) ; $ dp [ $ i ] [ 1 ] = max ( 0 , $ dp [ $ i - 1 ] [ 0 ] ) - $ arr [ $ i ] ; if ( $ i >= 2 ) $ dp [ $ i ] [ 1 ] = max ( $ dp [ $ i ] [ 1 ] , $ dp [ $ i - 1 ] [ 1 ] + $ arr [ $ i ] ) ; if ( $ i >= 2 ) $ dp [ $ i ] [ 2 ] = $ dp [ $ i - 1 ] [ 1 ] - $ arr [ $ i ] ; if ( $ i >= 3 ) $ dp [ $ i ] [ 2 ] = max ( $ dp [ $ i ] [ 2 ] , $ dp [ $ i - 1 ] [ 2 ] + $ arr [ $ i ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 0 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 1 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 2 ] ) ; } return $ ans ; } $ arr = array ( -5 , 3 , 2 , 7 , -8 , 3 , 7 , -9 , 10 , 12 , -6 ) ; $ n = count ( $ arr ) ; echo maxSum ( $ arr , $ n ) ; ? >"}
{"text": "Kos minimum untuk membentuk nombor x dengan menambah kuasa 2 | Berfungsi untuk mengembalikan kos minimum; Re - Kirakan array; Tambah jawapan untuk bit yang ditetapkan; Jika bit ditetapkan; Meningkatkan kaunter; Pergeseran kanan nombor; Kod pemacu", "code": "< ? php function MinimumCost ( $ a , $ n , $ x ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = min ( $ a [ $ i ] , 2 * $ a [ $ i - 1 ] ) ; } $ ind = 0 ; $ sum = 0 ; while ( $ x ) { if ( $ x & 1 ) $ sum += $ a [ $ ind ] ; $ ind ++ ; $ x = $ x >> 1 ; } return $ sum ; } $ a = array ( 20 , 50 , 60 , 90 ) ; $ x = 7 ; $ n = sizeof ( $ a ) / sizeof ( $ a [ 0 ] ) ; echo MinimumCost ( $ a , $ n , $ x ) ; ? >"}
{"text": "Cara untuk membentuk array yang mempunyai bilangan bulat dalam julat yang diberikan sedemikian rupa sehingga jumlah jumlah yang boleh dibahagikan dengan 2 | Berfungsi untuk mengembalikan bilangan cara untuk membentuk pelbagai saiz n sedemikian rupa sehingga jumlah semua elemen boleh dibahagikan dengan 2; Mewakili nombor pertama dan terakhir setiap jenis (Modulo 0 dan 1); Kiraan nombor setiap jenis antara julat; Kes asas; Cara untuk membentuk array yang jumlahnya sehingga saya nombor modulo 2 adalah 0; Cara untuk membentuk pelbagai yang jumlahnya sehingga saya nombor modulo 2 adalah 1; Mengembalikan cara yang diperlukan; Kod pemacu", "code": "< ? php function countWays ( $ n , $ l , $ r ) { $ tL = $ l ; $ tR = $ r ; $ L = array_fill ( 0 , 2 , 0 ) ; $ R = array_fill ( 0 , 2 , 0 ) ; $ L [ $ l % 2 ] = $ l ; $ R [ $ r % 2 ] = $ r ; $ l ++ ; $ r -- ; if ( $ l <= $ tR && $ r >= $ tL ) { $ L [ $ l % 2 ] = $ l ; $ R [ $ r % 2 ] = $ r ; } $ cnt0 = 0 ; $ cnt1 = 0 ; if ( $ R [ 0 ] && $ L [ 0 ] ) $ cnt0 = ( $ R [ 0 ] - $ L [ 0 ] ) / 2 + 1 ; if ( $ R [ 1 ] && $ L [ 1 ] ) $ cnt1 = ( $ R [ 1 ] - $ L [ 1 ] ) / 2 + 1 ; $ dp = array ( ) ; $ dp [ 1 ] [ 0 ] = $ cnt0 ; $ dp [ 1 ] [ 1 ] = $ cnt1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] [ 0 ] = ( $ cnt0 * $ dp [ $ i - 1 ] [ 0 ] + $ cnt1 * $ dp [ $ i - 1 ] [ 1 ] ) ; $ dp [ $ i ] [ 1 ] = ( $ cnt0 * $ dp [ $ i - 1 ] [ 1 ] + $ cnt1 * $ dp [ $ i - 1 ] [ 0 ] ) ; } return $ dp [ $ n ] [ 0 ] ; } $ n = 2 ; $ l = 1 ; $ r = 3 ; echo countWays ( $ n , $ l , $ r ) ; ? >"}
{"text": "Kotak warna N menggunakan warna M seperti kotak K mempunyai warna yang berbeza dari kotak di sebelah kiri | Program PHP untuk melukis kotak N menggunakan warna M sedemikian rupa sehingga kotak K mempunyai warna yang berbeza dari warna kotak di sebelah kiri; Fungsi ini mengembalikan bilangan cara yang diperlukan di mana IDX adalah indeks semasa dan diff adalah bilangan kotak yang mempunyai warna yang berbeza dari kotak di sebelah kiri; Kes asas; Jika sudah dikira; Sama ada cat dengan warna yang sama seperti sebelumnya; Atau cat dengan warna yang tinggal (m - 1); Kod pemacu; Multiply m sejak kotak pertama boleh dicat dengan mana -mana warna m dan mula menyelesaikan dari kotak 2 nd", "code": "< ? php $ M = 1001 ; $ MOD = 998244353 ; $ dp = array_fill ( 0 , $ M , array_fill ( 0 , $ M , -1 ) ) ; function solve ( $ idx , $ diff , $ N , $ M , $ K ) { global $ dp , $ MOD ; if ( $ idx > $ N ) { if ( $ diff == $ K ) return 1 ; return 0 ; } if ( $ dp [ $ idx ] [ $ diff ] != -1 ) return $ dp [ $ idx ] [ $ diff ] ; $ ans = solve ( $ idx + 1 , $ diff , $ N , $ M , $ K ) ; $ ans += ( $ M - 1 ) * solve ( $ idx + 1 , $ diff + 1 , $ N , $ M , $ K ) ; return $ dp [ $ idx ] [ $ diff ] = $ ans % $ MOD ; } $ N = 3 ; $ M = 3 ; $ K = 0 ; echo ( $ M * solve ( 2 , 0 , $ N , $ M , $ K ) ) ; ? >"}
{"text": "Jumlah Maksimum dalam Segitiga Terbalik | Tetapkan 2 | Pelaksanaan program PHP masalah maksimum dalam segitiga; Fungsi untuk mencari jumlah maksimum; Gelung untuk pengiraan bawah; Untuk setiap elemen, periksa kedua -dua elemen di bawah nombor dan di bawah kiri ke nombor tambah maksimumnya; Mengembalikan jumlah maksimum; Kod pemacu", "code": "< ? php $ N = 3 ; function maxPathSum ( $ tri ) { global $ N ; $ ans = 0 ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ N - $ i ; $ j ++ ) { if ( $ j - 1 >= 0 ) $ tri [ $ i ] [ $ j ] += max ( $ tri [ $ i + 1 ] [ $ j ] , $ tri [ $ i + 1 ] [ $ j - 1 ] ) ; else $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j ] ; $ ans = max ( $ ans , $ tri [ $ i ] [ $ j ] ) ; } } return $ ans ; } $ tri = array ( array ( 1 , 5 , 3 ) , array ( 4 , 8 , 0 ) , array ( 1 , 0 , 0 ) ) ; echo maxPathSum ( $ tri ) ; ? >"}
{"text": "Kira tidak. subset yang diperintahkan yang mempunyai nilai XOR tertentu | Mengembalikan kiraan subset yang diperintahkan ARR [] dengan nilai xor = k; Cari elemen maksimum dalam ARR []; Nilai maksimum XOR yang mungkin; Nilai dp [i] [j] [k] adalah bilangan subset panjang k yang mempunyai xor unsur -unsur mereka sebagai j dari set arr [0 .. . i - 1]; Memulakan semua nilai dp [i] [j] [k] sebagai 0; XOR subset kosong ialah 0; Isi jadual DP; Jawapannya ialah bilangan subset dari semua panjang dari set arr [0 .. n - 1] mempunyai xor elemen sebagai k; Kod pemacu", "code": "< ? php function subsetXOR ( $ arr , $ n , $ K ) { $ max_ele = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max_ele ) $ max_ele = $ arr [ $ i ] ; $ m = ( 1 << ( floor ( log ( $ max_ele , 2 ) ) + 1 ) ) - 1 ; $ dp = array ( array ( array ( ) ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) for ( $ k = 0 ; $ k <= $ n ; $ k ++ ) $ dp [ $ i ] [ $ j ] [ $ k ] = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) { for ( $ k = 0 ; $ k <= $ n ; $ k ++ ) { $ dp [ $ i ] [ $ j ] [ $ k ] = $ dp [ $ i - 1 ] [ $ j ] [ $ k ] ; if ( $ k != 0 ) { $ dp [ $ i ] [ $ j ] [ $ k ] += $ k * $ dp [ $ i - 1 ] [ $ j ^ $ arr [ $ i - 1 ] ] [ $ k - 1 ] ; } } } } $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ ans += $ dp [ $ n ] [ $ K ] [ $ i ] ; } return $ ans ; } $ arr = [ 1 , 2 , 3 ] ; $ k = 1 ; $ n = sizeof ( $ arr ) ; echo subsetXOR ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Kemungkinan pemotongan nombor sedemikian rupa sehingga bahagian maksimum boleh dibahagikan dengan 3 | Program PHP untuk mencari bilangan maksimum nombor yang boleh dibahagikan dengan 3 dalam jumlah yang besar; Ini akan mengandungi kiraan perpecahan; Ini akan menyimpan jumlah semua bilangan bulat berturut -turut, apabila mereka tidak dapat dipisahkan oleh 3; Inilah keadaan mencari perpecahan; Kod pemacu", "code": "< ? php function get_max_splits ( $ num_string ) { $ count = 0 ; $ running_sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num_string ) ; $ i ++ ) { $ current_num = intval ( $ num_string [ $ i ] ) ; $ running_sum += $ current_num ; if ( $ current_num % 3 == 0 or ( $ running_sum != 0 and $ running_sum % 3 == 0 ) ) { $ count += 1 ; $ running_sum = 0 ; } } return $ count ; } print ( get_max_splits ( \"12345\" ) ) ; ? >"}
{"text": "Borang N | Mengembalikan kos minimum untuk membentuk rentetan salinan N. Di sini, x -> kos untuk menambah / mengeluarkan satu aksara 'g' dan y -> kos untuk menambah rentetan kepada dirinya sendiri; Kes asas: Untuk membentuk rentetan 1 - Salin kita perlu melakukan operasi jenis 1 (i tambah); Kes1. Lakukan operasi tambah pada (i - 1) - Salin rentetan, Case2. Lakukan operasi Type 2 pada ((i + 1) / 2) - Salin rentetan; Kes1. Lakukan operasi tambah pada (i - 1) - Salin rentetan, Case2. Lakukan operasi Type 3 pada (I / 2) - Salin rentetan; Kod pemacu", "code": "< ? php function findMinimumCost ( $ n , $ x , $ y ) { $ dp [ $ n + 1 ] = array ( ) ; $ dp [ 1 ] = $ x ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i & 1 ) { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] + $ x , $ dp [ ( $ i + 1 ) / 2 ] + $ y + $ x ) ; } else { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] + $ x , $ dp [ $ i / 2 ] + $ y ) ; } } return $ dp [ $ n ] ; } $ n = 4 ; $ x = 2 ; $ y = 1 ; echo findMinimumCost ( $ n , $ x , $ y ) ; ? >"}
{"text": "Kira bilangan permutasi khas | Berfungsi untuk mengembalikan bilangan cara untuk memilih objek R dari objek N; Berfungsi untuk mengembalikan bilangan gangguan N; Berfungsi untuk mengembalikan bilangan permutasi yang diperlukan; Cara untuk memilih indeks saya dari indeks n; Dearangements of (n - i) indeks; Kod pemacu", "code": "< ? php function nCr ( $ n , $ r ) { $ ans = 1 ; if ( $ r > $ n - $ r ) $ r = $ n - $ r ; for ( $ i = 0 ; $ i < $ r ; $ i ++ ) { $ ans *= ( $ n - $ i ) ; $ ans /= ( $ i + 1 ) ; } return $ ans ; } function countDerangements ( $ n ) { $ der = array ( $ n + 1 ) ; $ der [ 0 ] = 1 ; $ der [ 1 ] = 0 ; $ der [ 2 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ der [ $ i ] = ( $ i - 1 ) * ( $ der [ $ i - 1 ] + $ der [ $ i - 2 ] ) ; return $ der [ $ n ] ; } function countPermutations ( $ n , $ k ) { $ ans = 0 ; for ( $ i = $ n - $ k ; $ i <= $ n ; $ i ++ ) { $ ways = nCr ( $ n , $ i ) ; $ ans += $ ways * countDerangements ( $ n - $ i ) ; } return $ ans ; } $ n = 5 ; $ k = 3 ; echo ( countPermutations ( $ n , $ k ) ) ; ? >"}
{"text": "Cara untuk meletakkan uskup k di papan catur nÃ - n sehingga tidak ada dua serangan | Mengembalikan bilangan dataran di pepenjuru I; Mengembalikan bilangan cara untuk mengisi papan catur n dengan k uskup supaya tidak ada dua uskup menyerang satu sama lain. ; kembali 0 jika bilangan tempat yang sah untuk diisi adalah kurang daripada bilangan uskup; Jadual DP untuk menyimpan nilai -nilai; Menetapkan keadaan asas; hitung bilangan cara yang diperlukan; menyimpan jawapannya; Kod pemacu", "code": "< ? php function squares ( $ i ) { if ( ( $ i & 1 ) == 1 ) return intval ( $ i / 4 ) * 2 + 1 ; else return intval ( ( $ i - 1 ) / 4 ) * 2 + 2 ; } function bishop_placements ( $ n , $ k ) { if ( $ k > 2 * $ n - 1 ) return 0 ; $ dp = array_fill ( 0 , $ n * 2 , array_fill ( 0 , $ k + 1 , NULL ) ) ; for ( $ i = 0 ; $ i < $ n * 2 ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; $ dp [ 1 ] [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ n * 2 ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 2 ] [ $ j ] + $ dp [ $ i - 2 ] [ $ j - 1 ] * ( squares ( $ i ) - $ j + 1 ) ; } $ ans = 0 ; for ( $ i = 0 ; $ i <= $ k ; $ i ++ ) { $ ans += $ dp [ $ n * 2 - 1 ] [ $ i ] * $ dp [ $ n * 2 - 2 ] [ $ k - $ i ] ; } return $ ans ; } $ n = 2 ; $ k = 2 ; $ ans = bishop_placements ( $ n , $ k ) ; echo $ ans ; ? >"}
{"text": "Jumlah bilangan tangga yang berbeza yang boleh dibuat dari kotak n | Berfungsi untuk mencari jumlah tangga yang berbeza yang boleh dibuat dari kotak N; Memulakan semua elemen jadual kepada sifar; Kes asas; Apabila langkah sama dengan 2; Apabila langkah lebih besar daripada 2; Hitung tangga total dari semua langkah; Kod pemacu", "code": "< ? php function countStaircases ( $ N ) { for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ N ; $ j ++ ) { $ memo [ $ i ] [ $ j ] = 0 ; } } $ memo [ 3 ] [ 2 ] = $ memo [ 4 ] [ 2 ] = 1 ; for ( $ i = 5 ; $ i <= $ N ; $ i ++ ) { for ( $ j = 2 ; $ j <= $ i ; $ j ++ ) { if ( $ j == 2 ) { $ memo [ $ i ] [ $ j ] = $ memo [ $ i - $ j ] [ $ j ] + 1 ; } else { $ memo [ $ i ] [ $ j ] = $ memo [ $ i - $ j ] [ $ j ] + $ memo [ $ i - $ j ] [ $ j - 1 ] ; } } } $ answer = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ answer = $ answer + $ memo [ $ N ] [ $ i ] ; return $ answer ; } $ N = 7 ; echo countStaircases ( $ N ) ; ? >"}
{"text": "Kira bilangan cara untuk melintasi matriks | Mengembalikan bilangan jalan dari atas - kiri ke tikar [m - 1] [n - 1]; Kembali 1 jika ia adalah baris pertama atau lajur pertama; Recursif mencari jalan untuk mencapai sel terakhir. ; Kod pemacu", "code": "< ? php function countPaths ( $ m , $ n ) { if ( $ m == 1 $ n == 1 ) return 1 ; return countPaths ( $ m - 1 , $ n ) + countPaths ( $ m , $ n - 1 ) ; } $ n = 5 ; $ m = 5 ; echo countPaths ( $ n , $ m ) ; ? >"}
{"text": "Kira bilangan cara untuk melintasi matriks | Mengembalikan bilangan jalan dari atas - kiri ke tikar [m - 1] [n - 1]; Kod pemacu", "code": "< ? php function countPaths ( $ m , $ n ) { $ dp ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 1 $ j == 1 ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i ] [ $ j - 1 ] ; } } return $ dp [ $ m ] [ $ n ] ; } $ n = 5 ; $ m = 5 ; echo countPaths ( $ n , $ m ) ; ? >"}
{"text": "Bilangan cara Poligon cembung n + 2 sisi boleh dibahagikan kepada segitiga dengan menyambungkan simpang | Pulangan nilai pekali binomial c (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Fungsi berasaskan pekali binomial untuk mencari nombor catalan n dalam masa O (n); Hitung nilai 2 ncn; kembali 2 ncn / (n + 1); Kod pemacu", "code": "< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; } function catalan ( $ n ) { $ c = binomialCoeff ( 2 * $ n , $ n ) ; return $ c / ( $ n + 1 ) ; } $ n = 3 ; echo catalan ( $ n ) ; ? >"}
{"text": "Nombor Fibonacci Alternatif | Siri Fibonacci alternatif menggunakan pengaturcaraan dinamik; Nombor 0 dan 1 siri adalah 0 dan 1; Kod pemacu", "code": "< ? php function alternateFib ( $ n ) { if ( $ n < 0 ) return ; $ f1 = 0 ; $ f2 = 1 ; echo $ f1 . \" \" ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ f3 = $ f2 + $ f1 ; if ( $ i % 2 == 0 ) echo $ f3 . \" \" ; $ f1 = $ f2 ; $ f2 = $ f3 ; } } $ N = 15 ; alternateFib ( $ N ) ; ? >"}
{"text": "Bilangan cara untuk membentuk array dengan elemen bersebelahan yang berbeza | Mengembalikan jumlah cara untuk membentuk tatasusunan supaya setiap elemen berturut -turut adalah berbeza dan setiap elemen kecuali yang pertama dan terakhir boleh mengambil nilai dari 1 hingga m; Tentukan array DP [] []; Jika elemen pertama ialah 1; Hanya ada satu cara untuk meletakkan 1 pada indeks pertama; Nilai pada indeks pertama perlu 1, oleh itu tidak ada cara untuk meletakkan satu integer bukan; Jika elemen pertama adalah 1 maka pada indeks 1, hanya satu integer yang tidak boleh diletakkan sehingga ada m - 1 cara untuk meletakkan integer bukan satu pada indeks 2 dan 0 cara untuk meletakkan 1 pada indeks 2 nd; Lain -lain ada satu cara untuk meletakkan satu di indeks 2 dan jika orang tidak perlu diletakkan di sini, terdapat (m - 2) pilihan, i. e tidak elemen di indeks ini harus 1, tidak sepatutnya sama dengan elemen sebelumnya; Membina array DP dengan cara bawah; f (i, one) = f (i - 1, non - one); f (i, non - one) = f (i - 1, one) * (m - 1) + f (i - 1, non - one) * (m - 2); Unsur terakhir perlu menjadi satu, jadi kembali dp [n - 1] [0]; Kod pemacu", "code": "< ? php function totalWays ( $ N , $ M , $ X ) { $ dp = array ( array ( ) ) ; if ( $ X == 1 ) { $ dp [ 0 ] [ 0 ] = 1 ; } else { $ dp [ 0 ] [ 1 ] = 0 ; } if ( $ X == 1 ) { $ dp [ 1 ] [ 0 ] = 0 ; $ dp [ 1 ] [ 1 ] = $ M - 1 ; } else { $ dp [ 1 ] [ 0 ] = 1 ; $ dp [ 1 ] [ 1 ] = ( $ M - 2 ) ; } for ( $ i = 2 ; $ i < $ N ; $ i ++ ) { $ dp [ $ i ] [ 0 ] = $ dp [ $ i - 1 ] [ 1 ] ; $ dp [ $ i ] [ 1 ] = $ dp [ $ i - 1 ] [ 0 ] * ( $ M - 1 ) + $ dp [ $ i - 1 ] [ 1 ] * ( $ M - 2 ) ; } return $ dp [ $ N - 1 ] [ 0 ] ; } $ N = 4 ; $ M = 3 ; $ X = 2 ; echo totalWays ( $ N , $ M , $ X ) ; ? >"}
{"text": "Memoisasi (1d, 2d dan 3d) | Siri Fibonacci menggunakan rekursi; Kes asas; panggilan rekursif; Kod pemacu", "code": "< ? php function fib ( $ n ) { if ( $ n <= 1 ) return $ n ; return fib ( $ n - 1 ) + fib ( $ n - 2 ) ; } $ n = 6 ; echo fib ( $ n ) ; ? >"}
{"text": "Jumlah produk pekali binomial berturut -turut | Program PHP untuk mencari jumlah produk pekali binomial berturut -turut. ; Cari pekali binomial sehingga istilah n; $ C [0] = 1; NC0 adalah 1; Kirakan baris seterusnya segitiga Pascal menggunakan baris sebelumnya; Kembalikan jumlah produk pekali binomial berturut -turut. ; Kod pemacu", "code": "< ? php $ MAX = 100 ; function binomialCoeff ( $ n , $ k ) { $ C = array_fill ( 0 , ( $ k + 1 ) , 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ k ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C [ $ k ] ; } function sumOfproduct ( $ n ) { return binomialCoeff ( 2 * $ n , $ n - 1 ) ; } $ n = 3 ; echo sumOfproduct ( $ n ) ; ? >"}
{"text": "Cetak urutan Fibonacci menggunakan 2 pembolehubah | Program PHP mudah untuk mencetak urutan Fibonacci; Kod pemacu", "code": "< ? php function fib ( $ n ) { $ a = 0 ; $ b = 1 ; $ c ; if ( $ n >= 0 ) echo $ a , \" ▁ \" ; if ( $ n >= 1 ) echo $ b , \" ▁ \" ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ c = $ a + $ b ; echo $ c , \" \" ; $ a = $ b ; $ b = $ c ; } } fib ( 9 ) ; ? >"}
{"text": "Jumlah maksimum yang semakin meningkat dari awalan dan elemen yang diberikan selepas awalan mesti | Program PHP untuk mencari jumlah maksimum yang semakin meningkat sehingga indeks i - th dan termasuk indeks k - th. ; Memulakan baris pertama DP [] []. ; Membuat matriks DP [] []. ; Untuk mengira untuk i = 4 dan k = 6 .; Kod pemacu", "code": "< ? php function pre_compute ( & $ a , $ n , $ index , $ k ) { $ dp = array_fill ( 0 , $ n , array_fill ( 0 , $ n , NULL ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ a [ 0 ] ) $ dp [ 0 ] [ $ i ] = $ a [ $ i ] + $ a [ 0 ] ; else $ dp [ 0 ] [ $ i ] = $ a [ $ i ] ; } for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ j ] > $ a [ $ i ] && $ j > $ i ) { if ( ( $ dp [ $ i - 1 ] [ $ i ] + $ a [ $ j ] ) > $ dp [ $ i - 1 ] [ $ j ] ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ i ] + $ a [ $ j ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] ; } else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] ; } } return $ dp [ $ index ] [ $ k ] ; } $ a = array ( 1 , 101 , 2 , 3 , 100 , 4 , 5 ) ; $ n = sizeof ( $ a ) ; $ index = 4 ; $ k = 6 ; echo pre_compute ( $ a , $ n , $ index , $ k ) ; ? >"}
{"text": "Moser | Berfungsi untuk menjana istilah nth Moser - de Bruijn urutan; S (2 * n) = 4 * s (n); S (2 * n + 1) = 4 * s (n) + 1; Menjana terma pertama 'N' Moser - de Bruijn; Kod pemacu", "code": "< ? php function gen ( $ n ) { $ S = array ( ) ; $ S [ 0 ] = 0 ; $ S [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ S [ $ i ] = 4 * $ S [ $ i / 2 ] ; else $ S [ $ i ] = 4 * $ S [ $ i / 2 ] + 1 ; } return $ S [ $ n ] ; } function moserDeBruijn ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo gen ( $ i ) , \" ▁ \" ; echo \" STRNEWLINE \" ; } $ n = 15 ; echo \" First ▁ \" , $ n , \" ▁ terms ▁ of ▁ \" , \" Moser - de ▁ Bruijn ▁ Sequence ▁ : ▁ STRNEWLINE \" ; moserDeBruijn ( $ n ) ; ? >"}
{"text": "Substring biasa terpanjang (Penyelesaian DP yang dioptimumkan ruang) | Berfungsi untuk mencari substring biasa terpanjang. ; Cari panjang kedua -dua rentetan. ; Pembolehubah untuk menyimpan panjang substring biasa terpanjang. ; Matriks untuk menyimpan hasil dua baris berturut -turut pada satu masa. ; Pembolehubah untuk mewakili baris matriks yang mana adalah baris semasa. ; Untuk nilai tertentu I dan J, Len [Currrow] [J] menyimpan panjang substring biasa terpanjang dalam rentetan x [0. .. i] dan y [0. .. j]. ; Buat baris semasa sebagai baris sebelumnya dan baris sebelumnya sebagai baris semasa baru. ; Kod pemacu", "code": "< ? php function LCSubStr ( $ X , $ Y ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ result = 0 ; $ len = array ( array ( ) , array ( ) , ) ; $ currRow = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) { $ len [ $ currRow ] [ $ j ] = 0 ; } else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) { $ len [ $ currRow ] [ $ j ] = $ len [ 1 - $ currRow ] [ $ j - 1 ] + 1 ; $ result = max ( $ result , $ len [ $ currRow ] [ $ j ] ) ; } else { $ len [ $ currRow ] [ $ j ] = 0 ; } } $ currRow = 1 - $ currRow ; } return $ result ; } $ X = \" GeeksforGeeks \" ; $ Y = \" GeeksQuiz \" ; print ( LCSubStr ( $ X , $ Y ) ) ; ? >"}
{"text": "Langkah minimum untuk membentuk rentetan dengan menambahkan aksara atau menambahkan rentetan itu sendiri | berfungsi untuk mengembalikan bilangan langkah yang minimum; memulakan dp [i] ke int_max; memulakan kedua -dua rentetan ke batal; Kes asas; Semak sama ada ia boleh dilampirkan; Penambahan watak mengambil satu langkah; Memperjuangkan mengambil 1 langkah, dan kami terus mencapai Indeks I * 2 + 1 selepas menambahkan sehingga bilangan langkah adalah stabil dalam i * 2 + 1; Kod pemacu; Fungsi Panggilan untuk mengembalikan jumlah langkah yang minimum", "code": "< ? php function minimalSteps ( $ s , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = PHP_INT_MAX ; $ s1 = \" \" ; $ s2 = \" \" ; $ dp [ 0 ] = 1 ; $ s1 = $ s1 . $ s [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ s1 = $ s1 . $ s [ $ i ] ; $ s2 = substr ( $ s , $ i + 1 , $ i + 1 ) ; $ dp [ $ i ] = min ( $ dp [ $ i ] , $ dp [ $ i - 1 ] + 1 ) ; if ( $ s1 == $ s2 ) $ dp [ $ i * 2 + 1 ] = min ( $ dp [ $ i ] + 1 , $ dp [ $ i * 2 + 1 ] ) ; } return $ dp [ $ n - 1 ] ; } $ s = \" aaaaaaaa \" ; $ n = strlen ( $ s ) ; echo minimalSteps ( $ s , $ n ) ; ? >"}
{"text": "Urutan Golomb | Cetak istilah N pertama urutan Golomb; kes asas; Mencari dan mencetak terma N pertama urutan Golomb. ; Kod pemacu", "code": "< ? php function printGolomb ( $ n ) { $ dp [ 1 ] = 1 ; echo $ dp [ 1 ] , \" \" ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = 1 + $ dp [ $ i - $ dp [ $ dp [ $ i - 1 ] ] ] ; echo $ dp [ $ i ] , \" \" ; } } $ n = 9 ; printGolomb ( $ n ) ; ? >"}
{"text": "Perbezaan maksimum sifar dan yang dalam rentetan binari | Tetapkan 2 (o (n) masa) | Mengembalikan panjang substring dengan perbezaan maksimum sifar dan yang dalam rentetan binari; melintasi rentetan binari dari kiri ke kanan; tambah nilai semasa ke current_sum mengikut watak jika ia '0' tambah 1 else -1; mengemas kini jumlah maksimum; pulangan - 1 jika rentetan tidak mengandungi apa -apa sifar yang bermaksud semua yang sebaliknya max_sum; Kod pemacu", "code": "< ? php function findLength ( $ str , $ n ) { $ current_sum = 0 ; $ max_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ current_sum += ( $ str [ $ i ] == '0' ? 1 : -1 ) ; if ( $ current_sum < 0 ) $ current_sum = 0 ; $ max_sum = max ( $ current_sum , $ max_sum ) ; } return $ max_sum == 0 ? -1 : $ max_sum ; } $ s = \"11000010001\" ; $ n = 11 ; echo findLength ( $ s , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Bilangan bilangan perpuluhan panjang k, yang ketat monoton | Program PHP untuk mengira nombor K digit yang sangat monoton. ; Dp [i] [j] akan menyimpan nombor monoton panjang i + 1 memandangkan J + 1 digit (1, 2, 3 ,. .9); Nombor panjang unit; Bangunan dp [] di bawah ke bawah; Kod pemacu", "code": "< ? php $ DP_s = 9 ; function getNumStrictMonotone ( $ len ) { global $ DP_s ; $ DP = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { for ( $ j = 0 ; $ j < $ DP_s ; $ j ++ ) $ DP [ $ i ] [ $ j ] = 0 ; } for ( $ i = 0 ; $ i < $ DP_s ; ++ $ i ) $ DP [ 0 ] [ $ i ] = $ i + 1 ; for ( $ i = 1 ; $ i < $ len ; ++ $ i ) for ( $ j = 1 ; $ j < $ DP_s ; ++ $ j ) $ DP [ $ i ] [ $ j ] = $ DP [ $ i - 1 ] [ $ j - 1 ] + $ DP [ $ i ] [ $ j - 1 ] ; return $ DP [ $ len - 1 ] [ $ DP_s - 1 ] ; } echo ( getNumStrictMonotone ( 2 ) ) ; ? >"}
{"text": "Kira cara untuk membahagikan bulatan menggunakan n non | Kod PHP untuk mengira cara untuk membahagikan lingkaran menggunakan n bukan - bersilang kord. ; n = tiada mata yang diperlukan; Arahan DP yang mengandungi jumlah; mengembalikan nombor yang diperlukan; Kod pemacu", "code": "< ? php function chordCnt ( $ A ) { $ n = 2 * $ A ; $ dpArray = array_fill ( 0 , $ n + 1 , 0 ) ; $ dpArray [ 0 ] = 1 ; $ dpArray [ 2 ] = 1 ; for ( $ i = 4 ; $ i <= $ n ; $ i += 2 ) { for ( $ j = 0 ; $ j < $ i - 1 ; $ j += 2 ) { $ dpArray [ $ i ] += ( $ dpArray [ $ j ] * $ dpArray [ $ i - 2 - $ j ] ) ; } } return $ dpArray [ $ n ] ; } $ N = 2 ; echo chordCnt ( $ N ) , \" STRNEWLINE \" ; $ N = 1 ; echo chordCnt ( $ N ) , \" STRNEWLINE \" ; $ N = 4 ; echo chordCnt ( $ N ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak jalan yang mungkin dalam matriks 2D | Program PHP untuk mencari jika terdapat jalan dari kiri atas ke kanan bawah; untuk mencari jalan dari kiri atas ke bawah kanan; set arr [0] [0] = 1; Mark boleh dicapai (dari kiri atas) nod dalam baris pertama dan lajur pertama. ; Tanda nod yang boleh dicapai dalam matriks yang tinggal. ; kembali ya jika indeks bawah kanan adalah 1; Diberikan array; jalan dari arr [0] [0] ke arr [row] [col]", "code": "< ? php $ row = 5 ; $ col = 5 ; function isPath ( $ arr ) { global $ row , $ col ; $ arr [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ row ; $ i ++ ) if ( $ arr [ $ i ] [ 0 ] != -1 ) $ arr [ $ i ] [ 0 ] = $ arr [ $ i - 1 ] [ 0 ] ; for ( $ j = 1 ; $ j < $ col ; $ j ++ ) if ( $ arr [ 0 ] [ $ j ] != -1 ) $ arr [ 0 ] [ $ j ] = $ arr [ 0 ] [ $ j - 1 ] ; for ( $ i = 1 ; $ i < $ row ; $ i ++ ) for ( $ j = 1 ; $ j < $ col ; $ j ++ ) if ( $ arr [ $ i ] [ $ j ] != -1 ) $ arr [ $ i ] [ $ j ] = max ( $ arr [ $ i ] [ $ j - 1 ] , $ arr [ $ i - 1 ] [ $ j ] ) ; return ( $ arr [ $ row - 1 ] [ $ col - 1 ] == 1 ) ; } $ arr = array ( array ( 0 , 0 , 0 , 1 , 0 ) , array ( -1 , 0 , 0 , -1 , -1 ) , array ( 0 , 0 , 0 , -1 , 0 ) , array ( -1 , 0 , -1 , 0 , -1 ) , array ( 0 , 0 , -1 , 0 , 0 ) ) ; if ( isPath ( $ arr ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Newmanâ € \"Shanksâ €\" Williams Prime | kembali nth Newman a Shanks A Williams Prime; Kes asas; Langkah rekursif; Kod pemacu", "code": "< ? php function nswp ( $ n ) { if ( $ n == 0 $ n == 1 ) return 1 ; return 2 * nswp ( $ n - 1 ) + nswp ( $ n - 2 ) ; } $ n = 3 ; echo ( nswp ( $ n ) ) ; ? >"}
{"text": "Newman Shanks Williams Prime | kembali n Newman Shanks Williams Prime; Kes asas; Mencari nth Newman Shanks Williams Prime; Kod pemacu", "code": "< ? php function nswp ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = 2 * $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] ; return $ dp [ $ n ] ; } $ n = 3 ; echo ( nswp ( $ n ) ) ; ? >"}
{"text": "Kos minimum untuk membuat dua rentetan sama dengan memadam digit | Fungsi untuk mengembalikan kos untuk mengeluarkan aksara yang sama dalam LCS untuk x [0 .. m - 1], y [0 .. n - 1]; Langkah -langkah berikut membina l [m + 1] [n + 1] dalam fesyen bawah. Perhatikan bahawa l [i] [j] mengandungi kos untuk mengeluarkan aksara yang sama dalam LCs x [0 .. i - 1] dan y [0. .. J - 1]; Jika kedua -dua wataknya sama, tambahkan kedua -duanya; Jika tidak, cari kos maksimum di antara mereka; Mengembalikan kos membuat x [] dan y [] identik; Cari LCS X [] dan Y []; Memulakan pemboleh ubah kos; Cari kos semua watak dalam kedua -dua rentetan; Kod pemacu", "code": "< ? php function lcs ( $ X , $ Y , $ m , $ n ) { $ L = array ( $ m + 1 , $ n + 1 ) ; for ( $ i = 0 ; $ i <= $ m ; ++ $ i ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ i ] [ $ j ] = $ L [ $ i - 1 ] [ $ j - 1 ] + 2 * ( $ X [ $ i - 1 ] - '0' ) ; else $ L [ $ i ] [ $ j ] = $ L [ $ i - 1 ] [ $ j ] > $ L [ $ i ] [ $ j - 1 ] ? $ L [ $ i - 1 ] [ $ j ] : $ L [ $ i ] [ $ j - 1 ] ; } } return $ L [ $ m ] [ $ n ] ; } function findMinCost ( $ X , $ Y ) { $ m = sizeof ( $ X ) ; $ n = sizeof ( $ Y ) ; $ cost = 0 ; for ( $ i = 0 ; $ i < $ m ; ++ $ i ) $ cost += $ X [ $ i ] - '0' ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cost += $ Y [ $ i ] - '0' ; return $ cost - lcs ( $ X , $ Y , $ m , $ n ) ; } $ X = str_split ( \"3759\" ) ; $ Y = str_split ( \"9350\" ) ; echo ( \" Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings \" . \" identical is = \""}
{"text": "Memandangkan sejumlah besar, periksa sama ada satu digitnya boleh dibahagikan dengan 8 | Fungsi mengambil pelbagai nombor, secara dinamik pergi ke lokasi dan membuat gabungan nombor. ; Menukar rentetan ke array integer untuk kemudahan pengiraan (pengindeksan dalam ARR [] dianggap bermula dari 1); Jika kita menganggap nombor dalam gabungan kami, kami menambahnya kepada gabungan sebelumnya; Jika kita mengecualikan nombor dari gabungan kita; Jika di DP [i] [0], kita dapati nilai 1 / benar, ia menunjukkan bahawa nombor itu wujud pada nilai 'i'; Kod pemacu", "code": "< ? php function isSubSeqDivisible ( $ str ) { $ n = strlen ( $ str ) ; $ dp = array_fill ( 0 , $ n + 1 , array_fill ( 0 , 10 , NULL ) ) ; $ arr = array_fill ( 0 , ( $ n + 1 ) , NULL ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ arr [ $ i ] = $ str [ $ i - 1 ] - '0' ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] [ $ arr [ $ i ] % 8 ] = 1 ; for ( $ j = 0 ; $ j < 8 ; $ j ++ ) { if ( $ dp [ $ i - 1 ] [ $ j ] > $ dp [ $ i ] [ ( $ j * 10 + $ arr [ $ i ] ) % 8 ] ) $ dp [ $ i ] [ ( $ j * 10 + $ arr [ $ i ] ) % 8 ] = $ dp [ $ i - 1 ] [ $ j ] ; if ( $ dp [ $ i - 1 ] [ $ j ] > $ dp [ $ i ] [ $ j ] ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] ; } } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ dp [ $ i ] [ 0 ] == 1 ) return true ; } return false ; } $ str = \"3144\" ; if ( isSubSeqDivisible ( $ str ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Panjang Susunan Terpanjang yang paling lama | Program PHP untuk mencari panjang seterusnya yang paling lama seimbang; Memandangkan semua substrings seimbang panjang 2; Memandangkan semua substring lain; Kod pemacu", "code": "< ? php function maxLength ( $ s , $ n ) { $ dp = array_fill ( 0 , $ n , array_fill ( 0 , $ n , NULL ) ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ s [ $ i ] == ' ( ' && $ s [ $ i + 1 ] == ' ) ' ) $ dp [ $ i ] [ $ i + 1 ] = 2 ; for ( $ l = 2 ; $ l < $ n ; $ l ++ ) { for ( $ i = 0 , $ j = $ l ; $ j < $ n ; $ i ++ , $ j ++ ) { if ( $ s [ $ i ] == ' ( ' && $ s [ $ j ] == ' ) ' ) $ dp [ $ i ] [ $ j ] = 2 + $ dp [ $ i + 1 ] [ $ j - 1 ] ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j ] , $ dp [ $ i ] [ $ k ] + $ dp [ $ k + 1 ] [ $ j ] ) ; } } return $ dp [ 0 ] [ $ n - 1 ] ; } $ s = \" ( ) ( ( ( ( ( ( ) \" ; $ n = strlen ( $ s ) ; echo maxLength ( $ s , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Subarray Bersebelahan Jumlah Terkecil | berfungsi untuk mencari subarray bersebelahan jumlah terkecil; untuk menyimpan nilai minimum yang berakhir dengan indeks semasa; untuk menyimpan nilai minimum yang dihadapi setakat ini; melintasi unsur -unsur array; Jika min_ending_here> 0, maka ia tidak mungkin menyumbang kepada jumlah minimum lagi; lain tambah nilai arr [i] ke min_ending_here; kemas kini min_so_far; memerlukan nilai subarray bersebelahan yang paling kecil; Kod pemacu", "code": "< ? php function smallestSumSubarr ( $ arr , $ n ) { $ min_ending_here = 999999 ; $ min_so_far = 999999 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ min_ending_here > 0 ) $ min_ending_here = $ arr [ $ i ] ; else $ min_ending_here += $ arr [ $ i ] ; $ min_so_far = min ( $ min_so_far , $ min_ending_here ) ; } return $ min_so_far ; } $ arr = array ( 3 , -4 , 2 , -3 , -1 , 7 , -5 ) ; $ n = count ( $ arr ) ; echo \" Smallest ▁ sum : ▁ \" . smallestSumSubarr ( $ arr , $ n ) ; ? >"}
{"text": "Lukisan Algoritma Pagar | Mengembalikan kiraan cara untuk mewarna k jawatan menggunakan warna k; Terdapat cara untuk mewarnai jawatan pertama; Terdapat 0 cara untuk jawatan tunggal untuk melanggar (warna yang sama", "code": "< ? php function countWays ( $ n , $ k ) { $ total = $ k ; $ mod = 1000000007 ; $ same = 0 ; $ diff = $ k ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ same = $ diff ; $ diff = $ total * ( $ k - 1 ) ; $ diff = $ diff % $ mod ; $ total = ( $ same + $ diff ) % $ mod ; } return $ total ; } $ n = 3 ; $ k = 2 ; echo countWays ( $ n , $ k ) . \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah semua substrings rentetan yang mewakili nombor | Tetapkan 2 (ruang tambahan yang berterusan) | Mengembalikan jumlah semua substring NUM; Memulakan hasil; Di sini melintasi array dalam urutan terbalik. Memulakan gelung dari elemen terakhir. MF mengalikan faktor. ; Setiap kali jumlah ditambah kepada jumlah sebelumnya. Mengalikan tiga faktor seperti yang dijelaskan di atas. S [i] - '0' dilakukan untuk menukar char ke int. ; Membuat faktor penggandaan baru seperti yang dijelaskan di atas. ; Kod pemacu", "code": "< ? php function sumOfSubstrings ( $ num ) { $ sum = 0 ; $ mf = 1 ; for ( $ i = strlen ( $ num ) - 1 ; $ i >= 0 ; $ i -- ) { $ sum += ( $ num [ $ i ] - '0' ) * ( $ i + 1 ) * $ mf ; $ mf = $ mf * 10 + 1 ; } return $ sum ; } $ num = \"6759\" ; echo sumOfSubstrings ( $ num ) , \" STRNEWLINE \" ; ? >"}
{"text": "Subarray Jumlah terbesar dengan AT | Mengembalikan jumlah maksimum subarray dengan unsur -unsur paling kurang. ; Maxsum [i] akan menyimpan jumlah maksimum sehingga indeks i sedemikian rupa sehingga [i] adalah sebahagian daripada jumlahnya. ; Kami menggunakan algoritma Kadane untuk mengisi MaxSum []; Jumlah elemen k pertama; Gunakan konsep tetingkap gelongsor; Kirakan jumlah elemen k yang berakhir dengan [i]. ; Hasil kemas kini jika diperlukan; Termasuk jumlah maksimum sehingga [i - k] juga jika ia meningkatkan keseluruhan maks. ; Kod pemacu", "code": "< ? php function maxSumWithK ( $ a , $ n , $ k ) { $ maxSum [ 0 ] = $ a [ 0 ] ; $ curr_max = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_max = max ( $ a [ $ i ] , $ curr_max + $ a [ $ i ] ) ; $ maxSum [ $ i ] = $ curr_max ; } $ sum = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ sum += $ a [ $ i ] ; $ result = $ sum ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ a [ $ i ] - $ a [ $ i - $ k ] ; $ result = max ( $ result , $ sum ) ; $ result = max ( $ result , $ sum + $ maxSum [ $ i - $ k ] ) ; } return $ result ; } $ a = array ( 1 , 2 , 3 , -10 , -3 ) ; $ k = 4 ; $ n = sizeof ( $ a ) ; echo maxSumWithK ( $ a , $ n , $ k ) ; ? >"}
{"text": "Cara untuk Jumlah ke N Menggunakan Elemen Array Dengan Pengulangan Dibenarkan | berfungsi untuk mengira jumlah cara untuk meringkaskan 'n'; Kes asas; Hitung cara untuk semua nilai sehingga 'n' dan simpan hasilnya; jika i> = arr [j] kemudian mengumpul kiraan untuk nilai 'i' sebagai cara untuk membentuk nilai 'i - arr [j]'; bilangan cara yang diperlukan; Kod pemacu", "code": "< ? php function countWays ( $ arr , $ m , $ N ) { $ count = array_fill ( 0 , $ N + 1 , 0 ) ; $ count [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ i >= $ arr [ $ j ] ) $ count [ $ i ] += $ count [ $ i - $ arr [ $ j ] ] ; return $ count [ $ N ] ; } $ arr = array ( 1 , 5 , 6 ) ; $ m = count ( $ arr ) ; $ N = 7 ; echo \" Total ▁ number ▁ of ▁ ways ▁ = ▁ \" , countWays ( $ arr , $ m , $ N ) ; ? >"}
{"text": "Urutan panjang yang diberikan di mana setiap elemen lebih daripada atau sama dengan dua kali dari sebelumnya | Fungsi rekursif untuk mencari bilangan urutan khas; Urutan khas tidak boleh wujud jika panjang n adalah lebih daripada nilai maksimum m. ; Jika n adalah 0, mendapati urutan khas kosong; Terdapat dua kemungkinan: (1) mengurangkan nilai elemen terakhir (2) Pertimbangkan elemen terakhir sebagai m dan mengurangkan bilangan istilah; Kod pemacu", "code": "< ? php function getTotalNumberOfSequences ( $ m , $ n ) { if ( $ m < $ n ) return 0 ; if ( $ n == 0 ) return 1 ; return getTotalNumberOfSequences ( $ m - 1 , $ n ) + getTotalNumberOfSequences ( $ m / 2 , $ n - 1 ) ; } $ m = 10 ; $ n = 4 ; echo ( \" Total ▁ number ▁ of ▁ possible ▁ sequences ▁ \" ) ; echo ( getTotalNumberOfSequences ( $ m , $ n ) ) ; ? >"}
{"text": "Urutan panjang yang diberikan di mana setiap elemen lebih daripada atau sama dengan dua kali dari sebelumnya | Fungsi berasaskan DP untuk mencari bilangan urutan khas; Tentukan t dan bina dengan cara bawah untuk menyimpan bilangan urutan khas panjang n dan nilai maksimum m; Kes asas: Jika panjang urutan adalah 0 atau nilai maksimum adalah 0, tidak ada urutan khas; Jika panjang urutan lebih daripada nilai maksimum, urutan khas tidak dapat wujud; Jika panjang urutan adalah 1 maka bilangan urutan khas adalah sama dengan nilai maksimum contohnya dengan nilai maksimum 2 dan panjang 1, terdapat 2 urutan khas {1}, {2}; sebaliknya hitung; Kod pemacu", "code": "< ? php function getTotalNumberOfSequences ( $ m , $ n ) { $ T = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ m + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n + 1 ; $ j ++ ) { if ( $ i == 0 or $ j == 0 ) $ T [ $ i ] [ $ j ] = 0 ; else if ( $ i < $ j ) $ T [ $ i ] [ $ j ] = 0 ; else if ( $ j == 1 ) $ T [ $ i ] [ $ j ] = $ i ; else $ T [ $ i ] [ $ j ] = $ T [ $ i - 1 ] [ $ j ] + $ T [ $ i / 2 ] [ $ j - 1 ] ; } } return $ T [ $ m ] [ $ n ] ; } $ m = 10 ; $ n = 4 ; echo \" Total ▁ number ▁ of ▁ possible ▁ sequences ▁ \" , getTotalNumberOfSequences ( $ m , $ n ) ; ? >"}
{"text": "Bilangan minimum penghapusan untuk membuat urutan yang disusun | lis () mengembalikan panjang seterusnya yang paling lama meningkat dalam arr [] saiz n; Memulakan nilai LIS untuk semua indeks; Kirakan nilai LIS yang dioptimumkan dengan cara bawah; Pilih keputusan semua nilai LIS; berfungsi untuk mengira bilangan pemadaman minimum; Cari seterusnya yang paling lama; Selepas mengeluarkan unsur -unsur selain daripada LIS, kami mendapat urutan yang disusun. ; Kod pemacu", "code": "< ? php function lis ( $ arr , $ n ) { $ result = 0 ; $ lis [ $ n ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ result < $ lis [ $ i ] ) $ result = $ lis [ $ i ] ; return $ result ; } function minimumNumberOfDeletions ( $ arr , $ n ) { $ len = lis ( $ arr , $ n ) ; return ( $ n - $ len ) ; } $ arr = array ( 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo \" Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ \" , minimumNumberOfDeletions ( $ arr , $ n ) ; ? >"}
{"text": "Bilangan minimum penghapusan untuk membuat palindrome tali | Mengembalikan panjang Palindromic yang paling lama dalam 'STR'; Buat jadual untuk menyimpan hasil subproblem; Rentetan panjang 1 adalah palindrome panjang 1; Bina meja. Perhatikan bahawa nilai -nilai pepenjuru yang lebih rendah jadual tidak berguna dan tidak diisi dalam proses. C1 adalah panjang substring; panjang subseq palindromik terpanjang; berfungsi untuk mengira bilangan pemadaman minimum; Cari Palindromic Longest Palindromic; Selepas mengeluarkan watak selain daripada LPS, kami mendapat palindrome. ; Kod pemacu", "code": "< ? php function lps ( $ str ) { $ n = strlen ( $ str ) ; $ L ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ L [ $ i ] [ $ i ] = 1 ; for ( $ cl = 2 ; $ cl <= $ n ; $ cl ++ ) { for ( $ i = 0 ; $ i < $ n - $ cl + 1 ; $ i ++ ) { $ j = $ i + $ cl - 1 ; if ( $ str [ $ i ] == $ str [ $ j ] && $ cl == 2 ) $ L [ $ i ] [ $ j ] = 2 ; else if ( $ str [ $ i ] == $ str [ $ j ] ) $ L [ $ i ] [ $ j ] = $ L [ $ i + 1 ] [ $ j - 1 ] + 2 ; else $ L [ $ i ] [ $ j ] = max ( $ L [ $ i ] [ $ j - 1 ] , $ L [ $ i + 1 ] [ $ j ] ) ; } } return $ L [ 0 ] [ $ n - 1 ] ; } function minimumNumberOfDeletions ( $ str ) { $ n = strlen ( $ str ) ; $ len = lps ( $ str ) ; return ( $ n - $ len ) ; } { $ str = \" geeksforgeeks \" ; echo \" Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ \" , minimumNumberOfDeletions ( $ str ) ; return 0 ; } ? >"}
{"text": "Tawaran Kuil | Mengembalikan tawaran minimum yang diperlukan; Pergi melalui semua templs satu demi satu; Pergi ke kiri sementara ketinggian terus meningkat; Pergi ke kanan sementara ketinggian terus meningkat; Kuil ini harus menawarkan maksimum dua nilai untuk mengikuti peraturan. ; Kod pemacu", "code": "< ? php function offeringNumber ( $ n , $ templeHeight ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ left = 0 ; $ right = 0 ; for ( $ j = $ i - 1 ; $ j >= 0 ; -- $ j ) { if ( $ templeHeight [ $ j ] < $ templeHeight [ $ j + 1 ] ) ++ $ left ; else break ; } for ( $ j = $ i + 1 ; $ j < $ n ; ++ $ j ) { if ( $ templeHeight [ $ j ] < $ templeHeight [ $ j - 1 ] ) ++ $ right ; else break ; } $ sum += max ( $ right , $ left ) + 1 ; } return $ sum ; } $ arr1 = array ( 1 , 2 , 2 ) ; echo offeringNumber ( 3 , $ arr1 ) , \" STRNEWLINE \" ; $ arr2 = array ( 1 , 4 , 3 , 6 , 2 , 1 ) ; echo offeringNumber ( 6 , $ arr2 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Subset dengan jumlah yang boleh dibahagi dengan m | Pulangan benar jika terdapat subset arr [] dengan jumlah yang boleh dibahagi oleh m; Arahan ini akan menjejaki semua jumlah yang mungkin (selepas modulo m) yang boleh dibuat menggunakan subset arr [] inisiasi array boolean dengan semua palsu; Kami akan melalui semua elemen arr []; Bila -bila masa kita menemui jumlah yang boleh dibahagi dengan m, kita sudah selesai; Untuk menyimpan semua jumlah baru yang ditemui (selepas modulo). Ia digunakan untuk memastikan bahawa ARR [i] hanya ditambah kepada penyertaan yang mana DP [J] adalah benar sebelum lelaran semasa. ; Untuk setiap elemen ARR [], kami gelung melalui semua elemen jadual DP dari 1 hingga m dan kami menambah elemen semasa i. e. , arr [i] kepada semua elemen yang benar dalam jadual DP; Jika elemen adalah benar dalam jadual DP; Kami mengemas kini dalam temp dan mengemas kini ke DP sekali gelung J berakhir; Mengemas kini semua elemen temp ke jadual DP sejak lelaran lebih daripada J berakhir; Juga sejak arr [i] adalah subset elemen tunggal, arr [i] % m adalah salah satu daripada jumlah yang mungkin; Kod pemacu", "code": "< ? php function modularSum ( $ arr , $ n , $ m ) { if ( $ n > $ m ) return true ; $ DP = Array_fill ( 0 , $ m , false ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ DP [ 0 ] ) return true ; $ temp = array_fill ( 0 , $ m , false ) ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ DP [ $ j ] == true ) { if ( $ DP [ ( $ j + $ arr [ $ i ] ) % $ m ] == false ) $ temp [ ( $ j + $ arr [ $ i ] ) % $ m ] = true ; } } for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ temp [ $ j ] ) $ DP [ $ j ] = true ; $ DP [ $ arr [ $ i ] % $ m ] = true ; } return $ DP [ 0 ] ; } $ arr = array ( 1 , 7 ) ; $ n = sizeof ( $ arr ) ; $ m = 5 ; if ( modularSum ( $ arr , $ n , $ m ) == true ) echo \" YES STRNEWLINE \" ; else echo \" NO STRNEWLINE \" ; ? >"}
{"text": "Jumlah maksimum jalan dalam segitiga nombor yang betul | berfungsi untuk mencari laluan jumlah maksimum; Menambah elemen baris 1 ke kedua -dua elemen baris 2 untuk mengurangkan langkah dari gelung; Melintasi baris yang tinggal; Gelung untuk melintasi lajur; Tri [i] akan menyimpan kemungkinan kombinasi jumlah laluan; array di indeks n - 1 (tri [i]) menyimpan semua kemungkinan menambah kombinasi, mencari maksimum dari mereka; Kod pemacu", "code": "< ? php function maxSum ( $ tri , $ n ) { if ( $ n > 1 ) $ tri [ 1 ] [ 1 ] = $ tri [ 1 ] [ 1 ] + $ tri [ 0 ] [ 0 ] ; $ tri [ 1 ] [ 0 ] = $ tri [ 1 ] [ 0 ] + $ tri [ 0 ] [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ tri [ $ i ] [ 0 ] = $ tri [ $ i ] [ 0 ] + $ tri [ $ i - 1 ] [ 0 ] ; $ tri [ $ i ] [ $ i ] = $ tri [ $ i ] [ $ i ] + $ tri [ $ i - 1 ] [ $ i - 1 ] ; for ( $ j = 1 ; $ j < $ i ; $ j ++ ) { if ( $ tri [ $ i ] [ $ j ] + $ tri [ $ i - 1 ] [ $ j - 1 ] >= $ tri [ $ i ] [ $ j ] + $ tri [ $ i - 1 ] [ $ j ] ) $ tri [ $ i ] [ $ j ] = $ tri [ $ i ] [ $ j ] + $ tri [ $ i - 1 ] [ $ j - 1 ] ; else $ tri [ $ i ] [ $ j ] = $ tri [ $ i ] [ $ j ] + $ tri [ $ i - 1 ] [ $ j ] ; } } $ max = $ tri [ $ n - 1 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ max < $ tri [ $ n - 1 ] [ $ i ] ) $ max = $ tri [ $ n - 1 ] [ $ i ] ; } return $ max ; } $ tri = array ( array ( 1 ) , array ( 2 , 1 ) , array ( 3 , 3 , 2 ) ) ; echo maxSum ( $ tri , 3 ) ; ? >"}
{"text": "Ubah suai array untuk memaksimumkan jumlah perbezaan bersebelahan | Pulangan Maksimum - Perbezaan - Jumlah dengan pengubahsuaian array yang dibenarkan. ; Inisialisasi DP [] [] dengan nilai 0. ; Untuk [i + 1] [0] (i. E. Nilai diubahsuai semasa ialah 1), pilih maksimum dari dp [$ i] [0] + abs (1 - 1) = dp [i] [0] dan dp [$ i] [1] + abs (1 - arr [i]); untuk [i + 1] [1] (i. E. Nilai diubah suai semasa adalah arr [i + 1]), pilih maksimum dari dp [i] [0] + abs (arr [i + 1] - 1) dan dp [i] [1] + abs (arr [i + 1] - arr [i]); Kod pemacu", "code": "< ? php function maximumDifferenceSum ( $ arr , $ N ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ dp [ $ i ] [ 1 ] = 0 ; for ( $ i = 0 ; $ i < ( $ N - 1 ) ; $ i ++ ) { $ dp [ $ i + 1 ] [ 0 ] = max ( $ dp [ $ i ] [ 0 ] , $ dp [ $ i ] [ 1 ] + abs ( 1 - $ arr [ $ i ] ) ) ; $ dp [ $ i + 1 ] [ 1 ] = max ( $ dp [ $ i ] [ 0 ] + abs ( $ arr [ $ i + 1 ] - 1 ) , $ dp [ $ i ] [ 1 ] + abs ( $ arr [ $ i + 1 ] - $ arr [ $ i ] ) ) ; } return max ( $ dp [ $ N - 1 ] [ 0 ] , $ dp [ $ N - 1 ] [ 1 ] ) ; } $ arr = array ( 3 , 2 , 1 , 4 , 5 ) ; $ N = count ( $ arr ) ; echo maximumDifferenceSum ( $ arr , $ N ) ; ? >"}
{"text": "Kebarangkalian ksatria untuk kekal di papan catur | saiz papan catur; vektor arah untuk ksatria; mengembalikan benar jika ksatria berada di dalam papan catur; Pendekatan bawah untuk mencari kebarangkalian keluar dari papan catur. ; array dp; Untuk 0 bilangan langkah, setiap kedudukan akan mempunyai kebarangkalian 1; untuk setiap bilangan langkah s; untuk setiap kedudukan (x, y) selepas bilangan langkah; untuk setiap kedudukan yang dapat dicapai dari (x, y); jika kedudukan ini terletak di dalam papan; Simpan hasilnya; mengembalikan hasilnya; bilangan langkah; Panggilan fungsi", "code": "< ? php $ N = 8 ; $ dx = array ( 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 ) ; $ dy = array ( 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 ) ; function inside ( $ x , $ y ) { global $ N ; return ( $ x >= 0 and $ x < $ N and $ y >= 0 and $ y < $ N ) ; } function findProb ( $ start_x , $ start_y , $ steps ) { global $ N , $ dx , $ dy ; $ dp1 = array_fill ( 0 , $ N , array_fill ( 0 , $ N , array_fill ( 0 , $ steps + 1 , NULL ) ) ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) for ( $ j = 0 ; $ j < $ N ; ++ $ j ) $ dp1 [ $ i ] [ $ j ] [ 0 ] = 1 ; for ( $ s = 1 ; $ s <= $ steps ; ++ $ s ) { for ( $ x = 0 ; $ x < $ N ; ++ $ x ) { for ( $ y = 0 ; $ y < $ N ; ++ $ y ) { $ prob = 0.0 ; for ( $ i = 0 ; $ i < 8 ; ++ $ i ) { $ nx = $ x + $ dx [ $ i ] ; $ ny = $ y + $ dy [ $ i ] ; if ( inside ( $ nx , $ ny ) ) $ prob += $ dp1 [ $ nx ] [ $ ny ] [ $ s - 1 ] / 8.0 ; } $ dp1 [ $ x ] [ $ y ] [ $ s ] = $ prob ; } } } return $ dp1 [ $ start_x ] [ $ start_y ] [ $ steps ] ; } $ K = 3 ; echo findProb ( 0 , 0 , $ K ) . \" STRNEWLINE \" ; ? >"}
{"text": "Count of Subarrays yang elemen maksimum lebih besar daripada k | Pulangan bilangan subarray yang elemen maksimumnya kurang daripada atau sama dengan k. ; Untuk menyimpan kiraan subarray dengan semua elemen kurang daripada atau sama dengan k. ; Melintasi array. ; Jika elemen lebih besar daripada k, abaikan. ; Mengira panjang subarray yang setiap elemen kurang daripada sama dengan k. ; Jumlah bilangan subarray yang elemen maksimumnya kurang daripada k. ; Program yang didorong", "code": "< ? php function countSubarray ( $ arr , $ n , $ k ) { $ s = 0 ; $ i = 0 ; while ( $ i < $ n ) { if ( $ arr [ $ i ] > $ k ) { $ i ++ ; continue ; } $ count = 0 ; while ( $ i < $ n and $ arr [ $ i ] <= $ k ) { $ i ++ ; $ count ++ ; } $ s += ( ( $ count * ( $ count + 1 ) ) / 2 ) ; } return ( $ n * ( $ n + 1 ) / 2 - $ s ) ; } $ arr = array ( 1 , 2 , 3 ) ; $ k = 2 ; $ n = count ( $ arr ) ; echo countSubarray ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Jumlah purata semua subset | Pulangan nilai pekali binomial c (n, k); Hitung nilai pekali binomial dengan cara bawah; Kes asas; Hitung nilai menggunakan nilai yang disimpan sebelumnya; kaedah mengembalikan jumlah purata semua subset; Memulakan hasil; Cari jumlah elemen; gelung sekali untuk semua subset dengan saiz yang sama; Setiap elemen berlaku NCR (n - 1, n - 1) kali sambil mempertimbangkan subset saiz n; Kod pemacu", "code": "< ? php function nCr ( $ n , $ k ) { $ C [ $ n + 1 ] [ $ k + 1 ] = 0 ; $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ k ) ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } return $ C [ $ n ] [ $ k ] ; } function resultOfAllSubsets ( $ arr , $ N ) { $ result = 0.0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ n = 1 ; $ n <= $ N ; $ n ++ ) $ result += ( ( $ sum * ( nCr ( $ N - 1 , $ n - 1 ) ) ) / $ n ) ; return $ result ; } $ arr = array ( 2 , 3 , 5 , 7 ) ; $ N = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo resultOfAllSubsets ( $ arr , $ N ) ; ? >"}
{"text": "Jumlah berikutnya maksimum supaya tiada tiga berturut -turut | Program PHP untuk mencari jumlah maksimum supaya tidak ada tiga yang berturut -turut menggunakan rekursi. ; Mengembalikan jumlah berikutnya yang maksimum supaya tiada tiga elemen berturut -turut; Kes asas (proses tiga elemen pertama); Proses selebihnya unsur -unsur kita mempunyai tiga kes; Kod pemacu", "code": "< ? php $ arr = array ( 100 , 1000 , 100 , 1000 , 1 ) ; $ sum = array_fill ( 0 , count ( $ arr ) + 1 , -1 ) ; function maxSumWO3Consec ( $ n ) { global $ sum , $ arr ; if ( $ sum [ $ n ] != -1 ) return $ sum [ $ n ] ; if ( $ n == 0 ) return $ sum [ $ n ] = 0 ; if ( $ n == 1 ) return $ sum [ $ n ] = $ arr [ 0 ] ; if ( $ n == 2 ) return $ sum [ $ n ] = $ arr [ 1 ] + $ arr [ 0 ] ; return $ sum [ $ n ] = max ( max ( maxSumWO3Consec ( $ n - 1 ) , maxSumWO3Consec ( $ n - 2 ) + $ arr [ $ n ] ) , $ arr [ $ n ] + $ arr [ $ n - 1 ] + maxSumWO3Consec ( $ n - 3 ) ) ; } $ n = count ( $ arr ) ; echo maxSumWO3Consec ( $ n ) ; ? >"}
{"text": "Jumlah maksimum pasangan dengan perbezaan tertentu | Kaedah untuk mengembalikan jumlah maksimum yang kita dapat dengan mencari kurang daripada pasangan perbezaan; Susun unsur -unsur untuk memastikan setiap i dan i - 1 adalah pasangan yang paling dekat; Untuk mendapatkan jumlah maksimum yang mungkin, berulang dari terbesar hingga terkecil, memberikan keutamaan nombor yang lebih besar ke atas nombor yang lebih kecil. ; Kes I: diff of Arr [i] dan arr [i - 1] kurang kemudian k, tambah ke maxsum kes ii: diff antara arr [i] dan arr [i - 1] tidak kurang dari k, bergerak ke seterusnya saya kerana dengan menyusun kita tahu, arr [i] - arr [i - 1] <arr [i] - arr [i - 2] dan sebagainya. ; Mengandaikan hanya nombor positif. ; Apabila perlawanan dijumpai melangkau pasangan ini; Kod pemacu", "code": "< ? php function maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ k ) { $ maxSum = 0 ; sort ( $ arr ) ; for ( $ i = $ N - 1 ; $ i > 0 ; -- $ i ) { if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] < $ k ) { $ maxSum += $ arr [ $ i ] ; $ maxSum += $ arr [ $ i - 1 ] ; -- $ i ; } } return $ maxSum ; } $ arr = array ( 3 , 5 , 10 , 15 , 17 , 12 , 9 ) ; $ N = sizeof ( $ arr ) ; $ K = 4 ; echo maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ K ) ; ? >"}
{"text": "Count angka kumpulan nombor dengan kekangan yang diberikan | Berfungsi untuk mencari subkumpulan; Menamatkan keadaan; jumlah digit; Melintasi semua digit dari kedudukan semasa hingga berehat panjang rentetan; Jika forward_sum lebih besar daripada jumlah sebelumnya, maka hubungi kaedah sekali lagi; Nota: Kami lulus jumlah semasa seperti jumlah sebelumnya; Jumlah bilangan subkumpulan sehingga kedudukan semasa; Kod pemacu", "code": "< ? php function countGroups ( $ position , $ previous_sum , $ length , $ num ) { if ( $ position == $ length ) return 1 ; $ res = 0 ; $ sum = 0 ; for ( $ i = $ position ; $ i < $ length ; $ i ++ ) { $ sum += ( $ num [ $ i ] - '0' ) ; if ( $ sum >= $ previous_sum ) $ res += countGroups ( $ i + 1 , $ sum , $ length , $ num ) ; } return $ res ; } $ num = \"1119\" ; $ len = strlen ( $ num ) ; echo countGroups ( 0 , 0 , $ len , $ num ) ; ? >"}
{"text": "Cari bilangan kali rentetan berlaku sebagai berikutnya dalam rentetan yang diberikan | Fungsi DP iteratif untuk mencari bilangan kali rentetan kedua berlaku dalam rentetan pertama, sama ada berterusan atau tidak berterusan; Buat jadual untuk menyimpan hasil sub - masalah; Jika rentetan kedua kosong; Isi carian [] [] dengan cara bawah; Jika watak terakhir adalah sama, kami mempunyai dua pilihan - 1. Pertimbangkan watak terakhir kedua -dua rentetan dalam penyelesaian 2. Abaikan watak terakhir rentetan pertama; Jika watak terakhir berbeza, abaikan watak terakhir rentetan pertama; Kod pemacu", "code": "< ? php function count1 ( $ a , $ b ) { $ m = strlen ( $ a ) ; $ n = strlen ( $ b ) ; $ lookup = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , 0 ) ) ; for ( $ i = 0 ; $ i <= $ m ; ++ $ i ) $ lookup [ $ i ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ a [ $ i - 1 ] == $ b [ $ j - 1 ] ) $ lookup [ $ i ] [ $ j ] = $ lookup [ $ i - 1 ] [ $ j - 1 ] + $ lookup [ $ i - 1 ] [ $ j ] ; else $ lookup [ $ i ] [ $ j ] = $ lookup [ $ i - 1 ] [ $ j ] ; } } return $ lookup [ $ m ] [ $ n ] ; } $ a = \" GeeksforGeeks \" ; $ b = \" Gks \" ; echo count1 ( $ a , $ b ) ; ? >"}
{"text": "Penyelesaian LCS yang dioptimumkan ruang | Mengembalikan panjang LCS untuk x [0 .. m - 1], y [0 .. n - 1]; Cari panjang dua rentetan; Indeks binari, digunakan untuk mengindeks baris semasa dan baris sebelumnya. ; Mengira indeks binari semasa; Kemasukan yang diisi terakhir mengandungi panjang LCS untuk x [0. n - 1] dan y [0 .. m - 1]; Kod pemacu", "code": "< ? php function lcs ( $ X , $ Y ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ L = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { $ bi = $ i & 1 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ bi ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ bi ] [ $ j ] = $ L [ 1 - $ bi ] [ $ j - 1 ] + 1 ; else $ L [ $ bi ] [ $ j ] = max ( $ L [ 1 - $ bi ] [ $ j ] , $ L [ $ bi ] [ $ j - 1 ] ) ; } } return $ L [ $ bi ] [ $ n ] ; } $ X = \" AGGTAB \" ; $ Y = \" GXTXAYB \" ; echo \" Length ▁ of ▁ LCS ▁ is ▁ : ▁ \" , lcs ( $ X , $ Y ) ; ? >"}
{"text": "Kira bilangan subset yang mempunyai nilai XOR tertentu | Mengembalikan kiraan subset ARR [] dengan nilai XOR sama dengan k. ; Cari elemen maksimum dalam ARR []; Nilai maksimum XOR yang mungkin; Memulakan semua nilai dp [i] [j] sebagai 0; XOR subset kosong ialah 0; Isi jadual DP; Jawapannya ialah bilangan subset dari set arr [0 .. n - 1] mempunyai xor elemen sebagai k; Kod pemacu", "code": "< ? php function subsetXOR ( $ arr , $ n , $ k ) { $ max_ele = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max_ele ) $ max_ele = $ arr [ $ i ] ; $ m = ( 1 << ( int ) ( log ( $ max_ele , 2 ) + 1 ) ) - 1 ; if ( $ k > $ m ) { return 0 ; } for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j ^ $ arr [ $ i - 1 ] ] ; return $ dp [ $ n ] [ $ k ] ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ k = 4 ; $ n = sizeof ( $ arr ) ; echo \" Count ▁ of ▁ subsets ▁ is ▁ \" , subsetXOR ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Cari bilangan penyelesaian persamaan linear pembolehubah N | Fungsi rekursif yang mengembalikan kiraan penyelesaian untuk nilai RHS yang diberikan dan koefisien Coeff [Mula. . akhir]; Kes asas; Memulakan kiraan penyelesaian; Satu dengan menolak semua koeficiants yang lebih kecil atau sama dan berulang; Kod pemacu", "code": "< ? php function countSol ( $ coeff , $ start , $ end , $ rhs ) { if ( $ rhs == 0 ) return 1 ; $ result = 0 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) if ( $ coeff [ $ i ] <= $ rhs ) $ result += countSol ( $ coeff , $ i , $ end , $ rhs - $ coeff [ $ i ] ) ; return $ result ; } $ coeff = array ( 2 , 2 , 5 ) ; $ rhs = 4 ; $ n = sizeof ( $ coeff ) ; echo countSol ( $ coeff , 0 , $ n - 1 , $ rhs ) ; ? >"}
{"text": "Langkah Minimum Untuk Mencapai Destinasi | Sumber -> Sumber Vertex Langkah -> Nilai Langkah Terakhir Diambil Dest -> Vertex Destinasi; kes asas; Jika kita pergi ke sisi positif; Jika kita pergi ke sisi negatif; minimum kedua -dua kes; Kod pemacu", "code": "< ? php function steps ( $ source , $ step , $ dest ) { if ( abs ( $ source ) > ( $ dest ) ) return PHP_INT_MAX ; if ( $ source == $ dest ) return $ step ; $ pos = steps ( $ source + $ step + 1 , $ step + 1 , $ dest ) ; $ neg = steps ( $ source - $ step - 1 , $ step + 1 , $ dest ) ; return min ( $ pos , $ neg ) ; } $ dest = 11 ; echo \" No . ▁ of ▁ steps ▁ required ▁ to ▁ reach ▁ \" , $ dest , \" ▁ is ▁ \" , steps ( 0 , 0 , $ dest ) ; ? >"}
{"text": "Substring biasa terpanjang | DP | Mengembalikan panjang fungsi untuk substring biasa terpanjang x [0. .. m - 1] dan y [0 .. n - 1]; Kod pemacu", "code": "< ? php function lcs ( $ i , $ j , $ count , & $ X , & $ Y ) { if ( $ i == 0 $ j == 0 ) return $ count ; if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) { $ count = lcs ( $ i - 1 , $ j - 1 , $ count + 1 , $ X , $ Y ) ; } $ count = max ( $ count , lcs ( $ i , $ j - 1 , 0 , $ X , $ Y ) , lcs ( $ i - 1 , $ j , 0 , $ X , $ Y ) ) ; return $ count ; } $ X = \" abcdxyz \" ; $ Y = \" xyzabcd \" ; $ n = strlen ( $ X ) ; $ m = strlen ( $ Y ) ; echo lcs ( $ n , $ m , 0 , $ X , $ Y ) ; ? >"}
{"text": "Cetak nombor sebagai rentetan 'a' dan 'b' dalam urutan lexicographic | Berfungsi untuk mengira bilangan aksara dalam rentetan yang sepadan dengan 'A' dan 'B'; Oleh kerana bilangan minimum aksara akan menjadi 1; Mengira bilangan aksara; Oleh kerana rentetan panjang k boleh mewakili paling banyak POW (2, k + 1) - 2 iaitu jika k = 4, ia boleh mewakili paling banyak POW (2, 4 + 1) - 2 = 30 jadi kita perlu mengira panjang rentetan yang sepadan; kembalikan panjang rentetan yang sepadan; Berfungsi untuk mencetak rentetan yang sepadan 'A' dan 'B'; Cari panjang rentetan; Oleh kerana nombor pertama yang boleh diwakili oleh rentetan panjang k akan (pow (2, k) - 2) + 1 dan ia akan menjadi aaa ... a, k kali, oleh itu, n akan menyimpannya berapa banyak yang perlu kita cetak; Pada masa tertentu, kita perlu memutuskan sama ada kita perlu mencetak 'A' atau 'B', ini boleh diperiksa dengan mengira nilai POW (2, k - 1); Cetak garis baru; Kod pemacu", "code": "< ? php function no_of_characters ( $ M ) { $ k = 1 ; while ( true ) { if ( pow ( 2 , $ k + 1 ) - 2 < $ M ) $ k ++ ; else break ; } return $ k ; } function print_string ( $ M ) { $ k ; $ num ; $ N ; $ k = no_of_characters ( $ M ) ; $ N = $ M - ( pow ( 2 , $ k ) - 2 ) ; while ( $ k > 0 ) { $ num = pow ( 2 , $ k - 1 ) ; if ( $ num >= $ N ) echo \" A \" ; else { echo \" B \" ; $ N -= $ num ; } $ k -- ; } echo \" STRNEWLINE \" ; } $ M ; $ M = 30 ; print_string ( $ M ) ; $ M = 55 ; print_string ( $ M ) ; $ M = 100 ; print_string ( $ M ) ; ? >"}
{"text": "Gantikan dua substrings (rentetan) antara satu sama lain | Berfungsi untuk mengembalikan rentetan yang dihasilkan; Melangkah melalui semua jawatan i; Sub semasa - rentetan panjang = len (a) = len (b); Jika sub -rentetan semasa mendapat sama dengan A atau B; Kemas kini selepas menggantikan A; Kemas kini S selepas menggantikan B; Kembalikan rentetan yang dikemas kini; Kod pemacu", "code": "< ? php function updateString ( $ S , $ A , $ B ) { $ l = strlen ( $ A ) ; for ( $ i = 0 ; $ i + $ l <= strlen ( $ S ) ; $ i ++ ) { $ curr = substr ( $ S , $ i , $ i + $ l ) ; if ( strcmp ( $ curr , $ A ) == 0 ) { $ new_string = substr ( $ S , 0 , $ i ) . $ B . substr ( $ S , $ i + $ l , strlen ( $ S ) ) ; $ S = $ new_string ; $ i += $ l - 1 ; } else { $ new_string = substr ( $ S , 0 , $ i ) . $ A . substr ( $ S , $ i + $ l , strlen ( $ S ) ) ; $ S = $ new_string ; $ i += $ l - 1 ; } } return $ S ; } $ S = \" aab \" ; $ A = \" aa \" ; $ B = \" bb \" ; echo ( updateString ( $ S , $ A , $ B ) ) ;"}
{"text": "Cetak n 0 s dan m 1 s sedemikian rupa sehingga tidak ada dua 0 s dan tidak ada tiga 1 s bersama | Berfungsi untuk mencetak corak yang diperlukan; Apabila keadaan gagal; Apabila m = n - 1; Kod pemacu", "code": "< ? php function printPattern ( $ n , $ m ) { if ( $ m > 2 * ( $ n + 1 ) $ m < $ n - 1 ) { echo ( \" - 1\" ) ; } else if ( abs ( $ n - $ m ) <= 1 ) { while ( $ n > 0 && $ m > 0 ) { System . out . print ( \"01\" ) ; $ n -- ; $ m -- ; } if ( $ n != 0 ) { echo ( \"0\" ) ; } if ( $ m != 0 ) { echo ( \"1\" ) ; } } else { while ( $ m - $ n > 1 && $ n > 0 ) { echo ( \"110\" ) ; $ m = $ m - 2 ; $ n = $ n - 1 ; } while ( $ n > 0 ) { echo ( \"10\" ) ; $ n -- ; $ m -- ; } while ( $ m > 0 ) { echo ( \"1\" ) ; $ m -- ; } } } $ n = 4 ; $ m = 8 ; printPattern ( $ n , $ m ) ; ? >"}
{"text": "Cari kiraan subarrays yang sangat menurun | Berfungsi untuk mengira bilangan subarray yang semakin berkurangan; Memulakan panjang subarray penurunan semasa; Melintasi array; Jika arr [i + 1] kurang daripada arr [i], maka panjang kenaikan; Lain mengemas kini kiraan dan set semula; Jika panjang terakhir adalah lebih daripada 1; Kod pemacu", "code": "< ? php function countDecreasing ( $ A , $ n ) { $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ A [ $ i + 1 ] < $ A [ $ i ] ) $ len ++ ; else { $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; return $ cnt ; } $ A = array ( 100 , 3 , 1 , 13 ) ; $ n = sizeof ( $ A ) ; echo countDecreasing ( $ A , $ n ) ; ? >"}
{"text": "Perubahan minimum diperlukan untuk membuat substring rentetan pertama rentetan kedua | Berfungsi untuk mencari bilangan minimum aksara yang akan diganti dalam String S2, sehingga S1 adalah substring S2; Dapatkan saiz kedua -dua rentetan; Melintasi rentetan S2; Dari setiap indeks dalam S2, periksa bilangan aksara MIS yang sepadan dalam substring panjang S1; Ambil minimum prev dan mis semasa - perlawanan; jawapan kembali; Kod pemacu", "code": "< ? php function minimumChar ( $ S1 , $ S2 ) { $ n = strlen ( $ S1 ) ; $ m = strlen ( $ S2 ) ; $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ m - $ n + 1 ; $ i ++ ) { $ minRemovedChar = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ S1 [ $ j ] != $ S2 [ $ i + $ j ] ) { $ minRemovedChar ++ ; } } $ ans = min ( $ minRemovedChar , $ ans ) ; } return $ ans ; } $ S1 = \" abc \" ; $ S2 = \" paxzk \" ; echo minimumChar ( $ S1 , $ S2 ) ; ? >"}
{"text": "Kekerapan substring dalam rentetan | Program PHP mudah untuk mengira kejadian PAT dalam TXT. ; Gelung untuk meluncur pat [] satu demi satu; Untuk indeks semasa I, periksa perlawanan corak; Jika Pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]; Kod pemacu", "code": "< ? php function countFreq ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ res = 0 ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { $ res ++ ; $ j = 0 ; } } return $ res ; } $ txt = \" dhimanman \" ; $ pat = \" man \" ; echo countFreq ( $ pat , $ txt ) ;"}
{"text": "Algoritma naif yang dioptimumkan untuk mencari corak | Algorithn mencari Pettern Naive yang dioptimumkan untuk kes -kes apabila semua watak corak adalah berbeza; Untuk indeks semasa I, periksa perlawanan corak; Jika Pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]; Luncurkan corak oleh J; Kod pemacu", "code": "< ? php function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i = 0 ; while ( $ i <= $ N - $ M ) { $ j ; for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { echo ( \" Pattern ▁ found ▁ at ▁ index ▁ $ i \" . \" STRNEWLINE \" ) ; $ i = $ i + $ M ; } else if ( $ j == 0 ) $ i = $ i + 1 ; else $ i = $ i + $ j ; } } $ txt = \" ABCEABCDABCEABCD \" ; $ pat = \" ABCD \" ; search ( $ pat , $ txt ) ; ? >"}
{"text": "Cetak matriks n x m supaya setiap baris dan lajur mempunyai semua vokal di dalamnya | Berfungsi untuk mencetak matriks yang diperlukan; Mustahil untuk menghasilkan matriks yang diperlukan; Simpan semua vokal; Cetak matriks; Cetak vokal untuk setiap indeks; Mengalihkan vokal dengan satu; Kod pemacu", "code": "< ? php function printMatrix ( $ n , $ m ) { if ( $ n < 5 $ m < 5 ) { echo - 1 ; return ; } $ s = \" aeiou \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { echo $ s [ $ j % 5 ] . \" \" ; } echo \" STRNEWLINE \" ; $ c = $ s [ 0 ] ; for ( $ k = 0 ; $ k < 4 ; $ k ++ ) { $ s [ $ k ] = $ s [ $ k + 1 ] ; } $ s [ 4 ] = $ c ; } } $ n = 5 ; $ m = 5 ; printMatrix ( $ n , $ m ) ; return 0 ; ? >"}
{"text": "Bilangan pembetulan watak dalam rentetan yang diberikan untuk menjadikannya sama | Berfungsi untuk mengembalikan kiraan operasi yang diperlukan; Untuk menyimpan kiraan operasi; Tiada operasi diperlukan; Satu operasi diperlukan apabila mana -mana dua aksara adalah sama; Dua operasi diperlukan apabila tiada watak yang sama; Mengembalikan kiraan operasi minimum yang diperlukan; Kod pemacu", "code": "< ? php function minOperations ( $ n , $ a , $ b , $ c ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = $ a [ $ i ] ; $ y = $ b [ $ i ] ; $ z = $ c [ $ i ] ; if ( $ x == $ y && $ y == $ z ) ; else if ( $ x == $ y $ y == $ z $ x == $ z ) { $ ans ++ ; } else { $ ans += 2 ; } } return $ ans ; } $ a = \" place \" ; $ b = \" abcde \" ; $ c = \" plybe \" ; $ n = strlen ( $ a ) ; echo minOperations ( $ n , $ a , $ b , $ c ) ; ? >"}
{"text": "Semak jika rentetan boleh dibuat secara lexicographically lebih kecil dengan membalikkan mana -mana substring | Fungsi yang mengembalikan benar jika S boleh dibuat secara leksikografi lebih kecil dengan membalikkan sub -rentetan dalam s; Melintasi rentetan; Semak jika $ s [$ i + 1] <$ s [$ i]; Tidak mungkin; Kod pemacu", "code": "< ? php function check ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ s [ $ i ] > $ s [ $ i + 1 ] ) return true ; } return false ; } $ s = \" geeksforgeeks \" ; if ( check ( $ s ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Count of Sub | Berfungsi untuk mengembalikan kiraan sub -rentetan yang diperlukan; Bilangan sub -rentetan dari kedudukan X semasa hingga akhir STR; Untuk menyimpan bilangan aksara sebelum x; Kod pemacu", "code": "< ? php function countSubStr ( $ str , $ n , $ x ) { $ res = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ x ) { $ res += ( ( $ count + 1 ) * ( $ n - $ i ) ) ; $ count = 0 ; } else $ count ++ ; } return $ res ; } $ str = \" abcabc \" ; $ n = strlen ( $ str ) ; $ x = ' c ' ; echo countSubStr ( $ str , $ n , $ x ) ; ? >"}
{"text": "Count of Sub | Berfungsi untuk mengembalikan kiraan sub -rentetan panjang n; Kod pemacu", "code": "< ? php function countSubStr ( $ str , $ n ) { $ len = strlen ( $ str ) ; return ( $ len - $ n + 1 ) ; } $ str = \" geeksforgeeks \" ; $ n = 5 ; echo ( countSubStr ( $ str , $ n ) ) ; ? >"}
{"text": "Count of Sub | Berfungsi untuk mengembalikan bilangan sub -rentetan yang tidak mengandungi watak yang diberikan c; Panjang rentetan; Melintasi rentetan; Jika watak semasa berbeza daripada watak yang diberikan; Kemas kini bilangan sub -rentetan; Tetapkan semula kiraan ke 0; Untuk watak -watak yang muncul selepas kejadian terakhir C; Kod pemacu", "code": "< ? php function countSubstrings ( $ s , $ c ) { $ n = strlen ( $ s ) ; $ cnt = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] != $ c ) $ cnt ++ ; else { $ sum += floor ( ( $ cnt * ( $ cnt + 1 ) ) / 2 ) ; $ cnt = 0 ; } } $ sum += floor ( ( $ cnt * ( $ cnt + 1 ) ) / 2 ) ; return $ sum ; } $ s = \" baa \" ; $ c = ' b ' ; echo countSubstrings ( $ s , $ c ) ; ? >"}
{"text": "Cari Indeks I seperti awalan S1 dan akhiran S2 sehingga saya membentuk palindrome apabila disatukan | Fungsi yang kembali benar jika s adalah palindrome; Fungsi untuk mengembalikan indeks yang diperlukan; Salin watak ith dalam s; Salin semua watak String S2 dalam temp; Semak sama ada rentetan itu adalah palindrome; Kod pemacu", "code": "< ? php function isPalindrome ( $ s ) { $ i = 0 ; $ j = strlen ( $ s ) - 1 ; while ( $ i < $ j ) { if ( $ s [ $ i ] != $ s [ $ j ] ) return false ; $ i ++ ; $ j -- ; } return true ; } function getIndex ( $ S1 , $ S2 , $ n ) { $ S = \" \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ S = $ S . $ S1 [ $ i ] ; $ Temp = \" \" ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ Temp . = $ S2 [ $ j ] ; if ( isPalindrome ( $ S . $ Temp ) ) { return $ i ; } } return -1 ; } $ S1 = \" abcdf \" ; $ S2 = \" sfgba \" ; $ n = strlen ( $ S1 ) ; echo getIndex ( $ S1 , $ S2 , $ n ) ; ? >"}
{"text": "Sub | Fungsi yang kembali benar jika setiap watak huruf kecil muncul sekali; Setiap kekerapan watak mestilah tidak lebih besar daripada satu; Fungsi yang mengembalikan rentetan baik yang diubah suai jika boleh; Jika panjang rentetan kurang daripada n; Sub - rentetan panjang 26; Untuk menyimpan kekerapan setiap watak; Dapatkan kekerapan setiap aksara dalam sub -rentetan semasa; Semak jika kita boleh mendapatkan sub -rentetan yang mengandungi semua 26 aksara; Cari watak mana yang hilang; Isi dengan watak yang hilang; Cari watak yang hilang seterusnya; Kembalikan rentetan yang baik; Kod pemacu", "code": "< ? php function valid ( & $ cnt ) { for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ cnt [ $ i ] >= 2 ) return false ; } return true ; } function getGoodString ( $ s , $ n ) { if ( $ n < 26 ) return \" - 1\" ; for ( $ i = 25 ; $ i < $ n ; $ i ++ ) { $ cnt = array_fill ( 0 , 26 , NULL ) ; for ( $ j = $ i ; $ j >= $ i - 25 ; $ j -- ) { if ( $ s [ $ j ] != ' ? ' ) $ cnt [ ord ( $ s [ $ j ] ) - ord ( ' a ' ) ] ++ ; } if ( valid ( $ cnt ) ) { $ cur = 0 ; while ( $ cur < 26 && $ cnt [ $ cur ] > 0 ) $ cur ++ ; for ( $ j = $ i - 25 ; $ j <= $ i ; $ j ++ ) { if ( $ s [ $ j ] == ' ? ' ) { $ s [ $ j ] = chr ( $ cur + ord ( ' a ' ) ) ; $ cur ++ ; while ( $ cur < 26 && $ cnt [ $ cur ] > 0 ) $ cur ++ ; } } return $ s ; } } return \" - 1\" ; } $ s = \" abcdefghijkl ? nopqrstuvwxy ? \" ; $ n = strlen ( $ s ) ; echo getGoodString ( $ s , $ n ) ; ? >"}
{"text": "Ubah suai rentetan dengan menukar vokal atau konsonan berterusan | Fungsi untuk memeriksa sama ada watak adalah vokal; Berfungsi untuk menukar dua vokal atau konsonan yang berulang -ulang berturut -turut; Melintasi panjang rentetan; Semak sama ada kedua -dua aksara berturut -turut adalah vokal atau konsonan; Tukar dua watak; Kod pemacu", "code": "< ? php function isVowel ( $ c ) { $ c = strtolower ( $ c ) ; if ( $ c == ' a ' $ c == ' e ' $ c == ' i ' $ c == ' o ' $ c == ' u ' ) return true ; return false ; } function swapRepeated ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) - 1 ; $ i ++ ) { if ( ( isVowel ( $ str [ $ i ] ) && isVowel ( $ str [ $ i + 1 ] ) ) || ( ! isVowel ( $ str [ $ i ] ) && ! isVowel ( $ str [ $ i + 1 ] ) ) ) { $ t = $ str [ $ i ] ; $ str [ $ i ] = $ str [ $ i + 1 ] ; $ str [ $ i + 1 ] = $ t ; } } return $ str ; } $ str = \" geeksforgeeks \" ; echo swapRepeated ( $ str ) ; return 0 ; ? >"}
{"text": "Cari Palindromic Lexicographically terbesar dari rentetan | Berfungsi untuk mencari seterusnya Palindromic terbesar; Cari watak terbesar; Tambah semua kejadian watak terbesar kepada rentetan yang dihasilkan; Kod pemacu", "code": "< ? php function largestPalinSub ( $ s ) { $ res = \" \" ; $ mx = $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ mx = max ( $ mx , $ s [ $ i ] ) ; } for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ mx ) { $ res . = $ s [ $ i ] ; } } return $ res ; } $ s = \" geeksforgeeks \" ; echo ( largestPalinSub ( $ s ) ) ; ? >"}
{"text": "Menjana rentetan terkecil lexicographically 0, 1 dan 2 dengan swap bersebelahan dibenarkan | Berfungsi untuk mencetak rentetan yang diperlukan; kiraan nombor 1 s; Untuk memeriksa sama ada semua 1 s telah digunakan atau tidak; Cetak semua 1 s jika mana -mana 2 ditemui; Jika str [i] = 0 atau str [i] = 2; Jika 1 s belum dicetak; Kod pemacu", "code": "< ? php function printString ( $ str , $ n ) { $ ones = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ str [ $ i ] == '1' ) $ ones ++ ; $ used = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == '2' && ! $ used ) { $ used = 1 ; for ( $ j = 0 ; $ j < $ ones ; $ j ++ ) echo \"1\" ; } if ( $ str [ $ i ] != '1' ) echo $ str [ $ i ] ; } if ( ! $ used ) for ( $ j = 0 ; $ j < $ ones ; $ j ++ ) echo \"1\" ; } $ str = \"100210\" ; $ n = strlen ( $ str ) ; printString ( $ str , $ n ) ; ? >"}
{"text": "K perkataan panjang yang boleh dibentuk dari aksara yang diberikan tanpa pengulangan | Berfungsi untuk mengembalikan kiraan yang diperlukan; Untuk menyimpan kiraan watak yang berbeza dalam $ str; Traverse $ str -watak oleh watak; Jika watak semasa muncul untuk kali pertama dalam $ str; Meningkatkan kiraan watak yang berbeza; Mengemas kini penampilan watak semasa; Sejak p (n, r) = n! / (n - r)! ; Kembalikan jawapannya; Kod pemacu", "code": "< ? php function findPermutation ( $ str , $ k ) { $ has = array ( ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { $ has [ $ i ] = false ; } $ cnt = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ has [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] == false ) { $ cnt ++ ; $ has [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] = true ; } } $ ans = 1 ; for ( $ i = 2 ; $ i <= $ cnt ; $ i ++ ) $ ans *= $ i ; for ( $ i = $ cnt - $ k ; $ i > 1 ; $ i -- ) $ ans /= $ i ; return $ ans ; } $ str = \" geeksforgeeks \" ; $ k = 4 ; echo findPermutation ( $ str , $ k ) ; ? >"}
{"text": "Cari nombor dalam julat yang mempunyai produk maksimum digit | Mengembalikan produk digit nombor X; Fungsi ini mengembalikan nombor yang mempunyai produk maksimum digit; Biarkan jawapan semasa menjadi r; Menukar kedua -dua bilangan bulat ke rentetan; Menyimpan nombor semasa yang mempunyai digit semasa satu kurang daripada digit semasa dalam b; Gantikan semua digit berikut dengan 9 untuk memaksimumkan produk; Tukar rentetan ke nombor; Semak jika ia terletak dalam julat dan produknya lebih besar daripada produk maksimum; Kod pemacu", "code": "< ? php function product ( $ x ) { $ prod = 1 ; while ( $ x ) { $ prod *= ( $ x % 10 ) ; $ x = ( int ) ( $ x / 10 ) ; } return $ prod ; } function findNumber ( $ l , $ r ) { $ ans = $ r ; $ a = strval ( $ l ) ; $ b = strval ( $ r ) ; for ( $ i = 0 ; $ i < strlen ( $ b ) ; $ i ++ ) { if ( $ b [ $ i ] == '0' ) continue ; $ curr = $ b ; $ curr [ $ i ] = chr ( ( ( ord ( $ curr [ $ i ] ) - ord ( '0' ) ) - 1 ) + ord ( '0' ) ) ; for ( $ j = $ i + 1 ; $ j < strlen ( $ curr ) ; $ j ++ ) $ curr [ $ j ] = '9' ; $ num = 0 ; for ( $ c = 0 ; $ c < strlen ( $ curr ) ; $ c ++ ) $ num = $ num * 10 + ( ord ( $ curr [ $ c ] ) - ord ( '0' ) ) ; if ( $ num >= $ l and product ( $ ans ) < product ( $ num ) ) $ ans = $ num ; } return $ ans ; } $ l = 1 ; $ r = 10 ; print ( findNumber ( $ l , $ r ) . \" \" ) ; $ l = 51 ; $ r = 62 ; print ( findNumber ( $ l , $ r ) ) ; ? >"}
{"text": "Bina rentetan binari berikutan kekangan yang diberikan | Fungsi untuk mencetak rentetan binari yang mempunyai 'A' nombor 0, 'b' '' 'dari indeks' x 'sekurang -kurangnya bahawa S [i]! = S [i + 1]; Bahagikan nilai indeks dengan 2 dan simpannya ke D; Jika nilai indeks x adalah walaupun dan x / 2 tidak sama dengan A; Gelung untuk d untuk setiap c cetak 10; tolak d dari a dan b; Gelung untuk b untuk mencetak baki 1 s; Gelung untuk mencetak baki 0; Kod pemacu", "code": "< ? php function constructBinString ( $ a , $ b , $ x ) { $ d ; $ i ; $ d = $ x / 2 ; if ( $ x % 2 == 0 && $ x / 2 != $ a ) { $ d -- ; echo 0 ; $ a -- ; } for ( $ i = 0 ; $ i < $ d ; $ i ++ ) echo \"10\" ; $ a = $ a - $ d ; $ b = $ b - $ d ; for ( $ i = 0 ; $ i < $ b ; $ i ++ ) { echo \"1\" ; } for ( $ i = 0 ; $ i < $ a ; $ i ++ ) { echo \"0\" ; } } $ a = 4 ; $ b = 3 ; $ x = 2 ; constructBinString ( $ a , $ b , $ x ) ; ? >"}
{"text": "Periksa sama ada setiap kumpulan yang diikuti dengan '' u u u u u u u u u u u u ' Berfungsi untuk dipadankan sama ada sentiasa ada n berturut -turut B 'diikuti' '' '' '' '' '' '' '' '' Melintasi rentetan; Mengira A dalam segmen semasa; Count B dalam segmen semasa; Jika kedua -dua tuduhan tidak sama. ; Kod pemacu", "code": "< ? php function matchPattern ( $ s ) { $ count = 0 ; $ n = strlen ( $ s ) ; $ i = 0 ; while ( $ i < $ n ) { while ( $ i < $ n && $ s [ $ i ] == ' a ' ) { $ count ++ ; $ i ++ ; } while ( $ i < $ n && $ s [ $ i ] == ' b ' ) { $ count -- ; $ i ++ ; } if ( $ count != 0 ) return false ; } return true ; } $ s = \" bb \" ; if ( matchPattern ( $ s ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Panjang yang paling lama berturut -turut oleh paling banyak swap dalam rentetan binari | Berfungsi untuk mengira panjang 1 sentuhan paling lama; Untuk mengira semua 1 dalam rentetan; Untuk menyimpan kumulatif 1 's $ kiri [$ n]; $ right [$ n]; ; Mengira kumulatif 1 dari kiri; Jika 0 kemudian mulakan kumulatif baru dari itu saya; melakukan langkah 3 pendekatan; Langkah 3; rentetan", "code": "< ? php function maximum_one ( $ s , $ n ) { $ cnt_one = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '1' ) $ cnt_one ++ ; } if ( $ s [ 0 ] == '1' ) $ left [ 0 ] = 1 ; else $ left [ 0 ] = 0 ; if ( $ s [ $ n - 1 ] == '1' ) $ right [ $ n - 1 ] = 1 ; else $ right [ $ n - 1 ] = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '1' ) $ left [ $ i ] = $ left [ $ i - 1 ] + 1 ; else $ left [ $ i ] = 0 ; } for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ s [ $ i ] == '1' ) $ right [ $ i ] = $ right [ $ i + 1 ] + 1 ; else $ right [ $ i ] = 0 ; } $ cnt = 0 ; $ max_cnt = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ s [ $ i ] == '0' ) { $ sum = $ left [ $ i - 1 ] + $ right [ $ i + 1 ] ; if ( $ sum < $ cnt_one ) $ cnt = $ sum + 1 ; else $ cnt = $ sum ; $ max_cnt = max ( $ max_cnt , $ cnt ) ; $ cnt = 0 ; } } return $ max_cnt ; } $ s = \"111011101\" ; echo maximum_one ( $ s , strlen ( $ s ) ) ; ? >"}
{"text": "Substring terkecil lexicographically dengan kejadian maksimum yang mengandungi satu -satunya | Fungsi untuk mencari substring terkecil secara leksikografi dalam rentetan yang diberikan dengan kekerapan maksimum dan mengandungi satu -satunya. ; Untuk menyimpan kekerapan digit; saiz rentetan; Ambil digit secara lexicographically di B; Dapatkan kekerapan setiap watak; Jika tiada rentetan itu keluar; Kekerapan maksimum; Kod pemacu", "code": "< ? php function maxFreq ( $ s , $ a , $ b ) { $ fre = array_fill ( 0 , 10 , 0 ) ; $ n = strlen ( $ s ) ; if ( $ a > $ b ) { $ xx = $ a ; $ a = $ b ; $ b = $ xx ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a = ord ( $ s [ $ i ] ) - ord ( '0' ) ; $ fre [ $ a ] += 1 ; } if ( $ fre [ $ a ] == 0 and $ fre [ $ b ] == 0 ) return -1 ; else if ( $ fre [ $ a ] >= $ fre [ $ b ] ) return $ a ; else return $ b ; } $ a = 4 ; $ b = 7 ; $ s = \"47744\" ; print ( maxFreq ( $ s , $ a , $ b ) ) ; ? >"}
{"text": "Langkah -langkah minimum untuk menukar satu rentetan binari kepada yang lain hanya menggunakan penolakan | Berfungsi untuk mencari langkah minimum untuk menukar rentetan A ke rentetan b; array untuk menandakan kedudukan yang diperlukan untuk ditolak; Jika dua watak tidak sama maka mereka perlu ditolak; Untuk mengira blok 1; Untuk mengira bilangan 1 s »~ setiap» blok 1 's; Untuk blok terakhir 1 s; Kod pemacu", "code": "< ? php function convert ( $ n , $ a , $ b ) { $ l = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ l [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] != $ b [ $ i ] ) $ l [ $ i ] = 1 ; } $ cc = 0 ; $ vl = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ l [ $ i ] == 0 ) { if ( $ vl != 0 ) $ cc += 1 ; $ vl = 0 ; } else $ vl += 1 ; } if ( $ vl != 0 ) $ cc += 1 ; echo $ cc . \" STRNEWLINE \" ; } $ a = \"101010\" ; $ b = \"110011\" ; $ n = strlen ( $ a ) ; convert ( $ n , $ a , $ b ) ; ? >"}
{"text": "Bilangan cara untuk menukar dua bit S1 supaya bitwise atau perubahan S1 dan S2 | Berfungsi untuk mencari bilangan cara; Hasil permulaan yang menyimpan tidak. swap diperlukan; Melintasi kedua -dua rentetan dan periksa bit seperti yang dijelaskan; hitung hasil; Kod pemacu", "code": "< ? php function countWays ( $ s1 , $ s2 , $ n ) { $ a = $ b = $ c = $ d = 0 ; $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s2 [ $ i ] == '0' ) { if ( $ s1 [ $ i ] == '0' ) { $ c ++ ; } else { $ d ++ ; } } else { if ( $ s1 [ $ i ] == '0' ) { $ a ++ ; } else { $ b ++ ; } } } $ result = $ a * $ d + $ b * $ c + $ c * $ d ; return $ result ; } $ n = 5 ; $ s1 = \"01011\" ; $ s2 = \"11001\" ; echo countWays ( $ s1 , $ s2 , $ n ) ; ? >"}
{"text": "Cari pemain yang menyusun semula watak -watak untuk mendapatkan rentetan palindrome terlebih dahulu | Fungsi yang mengembalikan pemenang permainan; Memulakan array freq ke 0 int freq [26]; memset (freq, 0, sizeof freq); $ freg = array_fill (); Melangkah dan mengira frekuensi setiap aksara dalam rentetan; Mengira watak yang ganjil; Jika kejadian ganjil; Semak Keadaan untuk Pemain - 1 memenangi permainan; Kod pemacu; Fungsi panggilan yang mengembalikan pemenang", "code": "< ? php function returnWinner ( $ s , $ l ) { $ freq = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { $ freq [ $ s [ $ i ] - ' a ' ] ++ ; } $ cnt = 0 ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ freq [ $ i ] & 1 ) $ cnt ++ ; } if ( $ cnt == 0 $ cnt & 1 ) return 1 ; else return 2 ; } $ s = \" abaaab \" ; $ l = strlen ( $ s ) ; $ winner = returnWinner ( $ s , $ l ) ; echo \" Player - \" , $ winner ; ? >"}
{"text": "Jumlah maksimum dan produk dari digit berturut -turut dalam nombor | Berfungsi untuk mencari produk maksimum; Kod pemacu", "code": "< ? php function maxProductSum ( $ str , $ m ) { $ n = strlen ( $ str ) ; $ maxProd = PHP_INT_MIN ; $ maxSum = PHP_INT_MIN ; for ( $ i = 0 ; $ i <= ( $ n - $ m ) ; $ i ++ ) { $ product = 1 ; $ sum = 0 ; for ( $ j = $ i ; $ j < ( $ m + $ i ) ; $ j ++ ) { $ product = $ product * ( $ str [ $ j ] - '0' ) ; $ sum = $ sum + ( $ str [ $ j ] - '0' ) ; } $ maxProd = max ( $ maxProd , $ product ) ; $ maxSum = max ( $ maxSum , $ sum ) ; } echo \" Maximum ▁ Product ▁ = ▁ \" , $ maxProd ; echo \" Maximum Sum = \" } $ str = \"3605356297\" ; $ m = 3 ; maxProductSum ( $ str , $ m ) ; ? >"}
{"text": "Cari masa yang diambil untuk isyarat untuk mencapai semua kedudukan dalam rentetan | Mengembalikan masa yang diperlukan untuk isyarat untuk melintasi rentetan lengkap. ; untuk pengiraan indeks terakhir; Untuk rentetan seperti Oxoooo, xoxxoooo. . ; Jika coun lebih besar daripada max_length; jika 'x' hadir di sebelah kanan max_length; jika 'x' hadir di sebelah kiri max_length; Kami menggunakan fungsi siling untuk mengendalikan nombor ganjil 'o' s; Kod pemacu", "code": "< ? php function maxLength ( $ s , $ n ) { $ right = 0 ; $ left = 0 ; $ coun = 0 ; $ max_length = PHP_INT_MIN ; $ s = $ s . '1' ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' o ' ) $ coun ++ ; else { if ( $ coun > $ max_length ) { $ right = 0 ; $ left = 0 ; if ( $ s [ $ i ] == ' x ' ) $ right = 1 ; if ( ( ( $ i - $ coun ) > 0 ) && ( $ s [ $ i - $ coun - 1 ] == ' x ' ) ) $ left = 1 ; $ coun = ( int ) ceil ( ( double ) $ coun / ( $ right + $ left ) ) ; $ max_length = max ( $ max_length , $ coun ) ; } $ coun = 0 ; } } return $ max_length ; } $ s = \" oooxoooooooooxooo \" ; $ n = strlen ( $ s ) ; echo ( maxLength ( $ s , $ n ) ) ;"}
{"text": "Semak sama ada vokal dalam rentetan dalam susunan abjad atau tidak | Fungsi yang memeriksa sama ada aksara vokal dalam rentetan adalah dalam susunan abjad atau tidak; Nilai ASCII 64 adalah kurang daripada semua huruf sehingga menggunakannya sebagai nilai lalai; Semak sama ada vokal dalam rentetan disusun atau tidak; Jika vokal lebih kecil daripada vokal sebelumnya; Simpan vokal; Kod pemacu; periksa sama ada aksara vokal dalam rentetan dalam susunan abjad atau tidak", "code": "< ? php function areVowelsInOrder ( $ s ) { $ n = strlen ( $ s ) ; $ c = chr ( 64 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' $ s [ $ i ] == ' e ' $ s [ $ i ] == ' $ i ' $ s [ $ i ] == ' o ' $ s [ $ i ] == ' u ' ) { if ( $ s [ $ i ] < $ c ) return false ; else { $ c = $ s [ $ i ] ; } } } return true ; } $ s = \" aabbbddeecc \" ; if ( areVowelsInOrder ( $ s ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Program untuk mencari baki apabila bilangan besar dibahagikan dengan r | Berfungsi untuk mengembalikan baki; Len adalah berubah -ubah untuk menyimpan panjang rentetan nombor. ; gelung yang mencari selebihnya; Kembalikan selebihnya; Dapatkan nombor besar sebagai rentetan; Dapatkan pembahagi r; Cari dan cetak selebihnya", "code": "< ? php function Remainder ( $ str , $ R ) { $ len = strlen ( $ str ) ; $ Num = 0 ; $ Rem = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ Num = $ Rem * 10 + ( $ str [ $ i ] - '0' ) ; $ Rem = $ Num % $ R ; } return $ Rem ; } $ str = \"13589234356546756\" ; $ R = 13 ; echo Remainder ( $ str , $ R ) ;"}
{"text": "Kira bilangan operasi membawa yang diperlukan untuk menambah dua nombor | Berfungsi untuk mengira bilangan operasi bawa; Memulakan nilai bawa ke 0; Mengira bilangan operasi membawa; Memulakan len_a dan len_b dengan saiz rentetan; Memberikan nilai ASCII watak; Tambah kedua -dua nombor / digit; Jika jumlah> 0, kiraan kenaikan dan set membawa kepada 1; Lain, set membawa kepada 0; Kod pemacu", "code": "< ? php function count_carry ( $ a , $ b ) { $ carry = 0 ; $ count = 0 ; $ len_a = strlen ( $ a ) ; $ len_b = strlen ( $ b ) ; while ( $ len_a != 0 $ len_b != 0 ) { $ x = 0 ; $ y = 0 ; if ( $ len_a > 0 ) { $ x = $ a [ $ len_a - 1 ] - '0' ; $ len_a -- ; } if ( $ len_b > 0 ) { $ y = $ b [ $ len_b - 1 ] - '0' ; $ len_b -- ; } $ sum = $ x + $ y + $ carry ; if ( $ sum >= 10 ) { $ carry = 1 ; $ count ++ ; } else $ carry = 0 ; } return $ count ; } $ a = \"9555\" ; $ b = \"555\" ; $ count = count_carry ( $ a , $ b ) ; if ( $ count == 0 ) echo \"0 STRNEWLINE \" ; else if ( $ count == 1 ) echo \"1 STRNEWLINE \" ; else echo $ count , \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika nombor berada di pangkalan yang diberikan atau tidak | Program PHP untuk memeriksa sama ada nombor diberikan dalam asas atau tidak. ; Pangkalan yang dibenarkan sehingga 16 (heksadesimal); Jika asas berada di bawah atau sama dengan 10, maka semua digit harus dari 0 hingga 9; Jika asas berada di bawah atau sama dengan 16, maka semua digit harus dari 0 hingga 9 atau dari 'A'; Kod pemacu", "code": "< ? php function isInGivenBase ( $ str , $ base ) { if ( $ base > 16 ) return false ; else if ( $ base <= 10 ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ! ( $ str [ $ i ] >= '0' and $ str [ $ i ] < ( '0' + $ base ) ) ) return false ; } else { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ! ( ( $ str [ $ i ] >= '0' && $ str [ $ i ] < ( '0' + $ base ) ) || ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] < ( ' A ' + $ base - 10 ) ) ) ) return false ; } return true ; } $ str = \" AF87\" ; if ( isInGivenBase ( $ str , 16 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cari indeks semua kejadian satu rentetan di lain | Program PHP untuk mencari indeks semua kejadian satu rentetan di lain -lain. ; Kod pemacu", "code": "< ? php function printIndex ( $ str , $ s ) { $ flag = false ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( substr ( $ str , $ i , strlen ( $ s ) ) == $ s ) { echo $ i . \" \" ; $ flag = true ; } } if ( $ flag == false ) echo \" NONE \" ; } $ str1 = \" GeeksforGeeks \" ; $ str2 = \" Geeks \" ; printIndex ( $ str1 , $ str2 ) ; ? >"}
{"text": "Semak tanda kurung yang seimbang dalam ungkapan | O (1) Ruang | Fungsi1 untuk memadankan pendakap penutupan; Fungsi1 untuk memadankan pendakap pembukaan; Fungsi untuk memeriksa kurungan seimbang; pembolehubah pembantu; Mengendalikan kes pembukaan tanda kurung; Menangani kes penutupan tanda kurung; Sekiranya tanda -tanda pembukaan yang sepadan tidak sepadan tidak terletak pada selang masa yang diberikan 0; lain terus; Sekiranya tanda kurung penutup yang sepadan tidak terletak pada pulangan selang yang diberikan 0; Jika dijumpai, sekarang semak setiap pembukaan dan penutupan tanda kurung dalam selang ini; Kod pemacu", "code": "< ? php function matchClosing ( $ X , $ start , $ end , $ open , $ close ) { $ c = 1 ; $ i = $ start + 1 ; while ( $ i <= $ end ) { if ( $ X [ $ i ] == $ open ) { $ c ++ ; } else if ( $ X [ $ i ] == $ close ) { $ c -- ; } if ( $ c == 0 ) { return $ i ; } $ i ++ ; } return $ i ; } function matchingOpening ( $ X , $ start , $ end , $ open , $ close ) { $ c = -1 ; $ i = $ end - 1 ; while ( $ i >= $ start ) { if ( $ X [ $ i ] == $ open ) { $ c ++ ; } else if ( $ X [ $ i ] == $ close ) { $ c -- ; } if ( $ c == 0 ) { return $ i ; } $ i -- ; } return -1 ; } function isBalanced ( $ X , $ n ) { $ i ; $ j = 0 ; $ k ; $ x ; $ start ; $ end ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ X [ $ i ] == ' ( ' ) { $ j = matchClosing ( $ X , $ i , $ n - 1 , ' ( ' , ' ) ' ) ; } else if ( $ X [ $ i ] == ' { ' ) { $ j = matchClosing ( $ X , $ i , $ n - 1 , ' { ' , ' } ' ) ; } else if ( $ X [ $ i ] == ' [ ' ) { $ j = matchClosing ( $ X , $ i , $ n - 1 , ' [ ' , ' ] ' ) ; } else { if ( $ X [ $ i ] == ' ) ' ) { $ j = matchingOpening ( $ X , 0 , $ i , ' ( ' , ' ) ' ) ; } else if ( $ X [ $ i ] == ' } ' ) { $ j = matchingOpening ( $ X , 0 , $ i , ' { ' , ' } ' ) ; } else if ( $ X [ $ i ] == ' ] ' ) { $ j = matchingOpening ( $ X , 0 , $ i , ' [ ' , ' ] ' ) ; } if ( $ j < 0 $ j >= $ i ) { return false ; } continue ; } if ( $ j >= $ n $ j < 0 ) { return false ; } $ start = $ i ; $ end = $ j ; for ( $ k = $ start + 1 ; $ k < $ end ; $ k ++ ) { if ( $ X [ $ k ] == ' ( ' ) { $ x = matchClosing ( $ X , $ k , $ end , ' ( ' , ' ) ' ) ; if ( ! ( $ k < $ x && $ x < $ end ) ) { return false ; } } else if ( $ X [ $ k ] == ' ) ' ) { $ x = matchingOpening ( $ X , $ start , $ k , ' ( ' , ' ) ' ) ; if ( ! ( $ start < $ x && $ x < $ k ) ) { return false ; } } if ( $ X [ $ k ] == ' { ' ) { $ x = matchClosing ( $ X , $ k , $ end , ' { ' , ' } ' ) ; if ( ! ( $ k < $ x && $ x < $ end ) ) { return false ; } } else if ( $ X [ $ k ] == ' } ' ) { $ x = matchingOpening ( $ X , $ start , $ k , ' { ' , ' } ' ) ; if ( ! ( $ start < $ x && $ x < $ k ) ) { return false ; } } if ( $ X [ $ k ] == ' [ ' ) { $ x = matchClosing ( $ X , $ k , $ end , ' [ ' , ' ] ' ) ; if ( ! ( $ k < $ x && $ x < $ end ) ) { return false ; } } else if ( $ X [ $ k ] == ' ] ' ) { $ x = matchingOpening ( $ X , $ start , $ k , ' [ ' , ' ] ' ) ; if ( ! ( $ start < $ x && $ x < $ k ) ) { return false ; } } } } return true ; } $ X = str_split ( \" [ ( ) ] ( ) \" ) ; $ n = 6 ; if ( isBalanced ( $ X , $ n ) ) echo ( \" Yes STRNEWLINE \" ) ; else echo ( \" No STRNEWLINE \" ) ; $ Y = str_split ( \" [ [ ( ) ] ] ) \" ) ; $ n = 7 ; if ( isBalanced ( $ Y , $ n ) ) echo ( \" Yes STRNEWLINE \" ) ; else echo ( \" No STRNEWLINE \" ) ; ? >"}
{"text": "Sorting array dengan bertukar bersyarat | Fungsi untuk memeriksa sama ada mungkin untuk menyusun array; Mengira max_element pada setiap lelaran. ; Jika kita tidak dapat menukar elemen i - th. ; Sekiranya mustahil untuk menukar max_element maka kita tidak boleh menyusun array. ; Jika tidak, kita boleh menyusun array. ; Kod pemacu", "code": "< ? php function possibleToSort ( $ arr , $ n , $ str ) { $ max_element = -1 ; for ( $ i = 0 ; $ i < sizeof ( $ str ) ; $ i ++ ) { $ max_element = max ( $ max_element , $ arr [ $ i ] ) ; if ( $ str [ $ i ] == '0' ) { if ( $ max_element > $ i + 1 ) return \" No \" ; } } return \" Yes \" ; } $ arr = array ( 1 , 2 , 5 , 3 , 4 , 6 ) ; $ n = sizeof ( $ arr ) ; $ str = \"01110\" ; echo possibleToSort ( $ arr , $ n , $ str ) ; ? >"}
{"text": "Rentetan Perdana | Fungsi yang memeriksa jika jumlahnya adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Kod pemacu", "code": "< ? php function isPrimeString ( $ str ) { $ len = strlen ( $ str ) ; $ n = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ n += ( int ) $ str [ $ i ] ; if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } $ str = \" geekRam \" ; if ( isPrimeString ( $ str ) ) echo \" Yes \" , \" STRNEWLINE \" ; else echo \" No \" , \" STRNEWLINE \" ; ? >"}
{"text": "Bilangan permutasi palindromik | Tetapkan 1 | Program PHP untuk mencari bilangan permutasi palindromik rentetan yang diberikan; Mengembalikan faktorial n; Mengembalikan kiraan permutasi palindromic Str. ; Mengira frekuensi semua aksara; Sejak separuh daripada watak memutuskan kiraan permutasi palindromik, kami mengambil (n / 2)! ; Untuk memastikan bahawa terdapat paling banyak yang aneh; Melintasi semua tuduhan; Untuk memastikan bahawa rentetan boleh membentuk palindrome; Sekiranya terdapat lebih daripada satu chars yang ganjil; Bahagikan semua permutasi dengan aksara berulang; Kod pemacu", "code": "< ? php $ MAX = 256 ; function fact ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } function countPalinPermutations ( & $ str ) { global $ MAX ; $ n = strlen ( $ str ) ; $ freq = ( 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = fact ( $ n / 2 ) ; $ oddFreq = false ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { $ half = $ freq [ $ i ] / 2 ; if ( $ freq [ $ i ] % 2 != 0 ) { if ( $ oddFreq == true ) return 0 ; $ oddFreq = true ; } $ res = $ res / fact ( $ half ) ; } return $ res ; } $ str = \" gffg \" ; echo countPalinPermutations ( $ str ) ; ? >"}
{"text": "Tukar rentetan ke dalam rentetan palindrome dengan menukar hanya satu aksara | Fungsi untuk memeriksa sama ada mungkin untuk menukar rentetan ke dalam palindrome; Mengira bilangan aksara yang perlu diubah. ; Jika kiraan perubahan kurang daripada atau sama dengan 1; Kod pemacu", "code": "< ? php function checkPalindrome ( $ str ) { $ n = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n / 2 ; ++ $ i ) if ( $ str [ $ i ] != $ str [ $ n - $ i - 1 ] ) ++ $ count ; return ( $ count <= 1 ) ; } { $ str = \" abccaa \" ; if ( checkPalindrome ( $ str ) ) echo \" Yes \" ; else echo \" No \" ; return 0 ; } ? >"}
{"text": "Mengira walaupun substring nilai perpuluhan dalam rentetan binari | fungsi pulangan fungsi walaupun substring nilai perpuluhan; Simpan kiraan walaupun substring nilai perpuluhan; Substring bermula dengan '0'; Hasil kenaikan oleh (n - i) kerana semua substring yang dihasilkan oleh watak ini menghasilkan nilai perpuluhan. ; Kod pemacu", "code": "< ? php function evenDecimalValue ( $ str , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) { $ result += ( $ n - $ i ) ; } } return $ result ; } $ str = \"10010\" ; $ n = 5 ; echo evenDecimalValue ( $ str , $ n ) ; return 0 ; ? >"}
{"text": "Bilangan substrings dengan nilai perpuluhan ganjil dalam rentetan binari | berfungsi untuk mengira bilangan substring dengan perwakilan perpuluhan yang ganjil; array tambahan untuk menyimpan kiraan 1 sebelum indeks ith; kiraan kedai 1 sebelum indeks i-th; pembolehubah untuk menyimpan jawapan; melintasi rentetan terbalik untuk mengira bilangan substring ganjil sebelum indeks saya; Kod pemacu", "code": "< ? php function countSubstr ( $ s ) { $ n = strlen ( $ s ) ; $ auxArr = array ( ) ; if ( $ s [ 0 ] == '1' ) $ auxArr [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '1' ) $ auxArr [ $ i ] = $ auxArr [ $ i - 1 ] + 1 ; else $ auxArr [ $ i ] = $ auxArr [ $ i - 1 ] ; } $ count = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) if ( $ s [ $ i ] == '1' ) $ count += $ auxArr [ $ i ] ; return $ count ; } $ s = \"1101\" ; echo countSubstr ( $ s ) ; ? >"}
{"text": "Semak sama ada rentetan kedua boleh dibentuk dari watak -watak rentetan pertama | Program PHP untuk memeriksa sama ada rentetan kedua boleh dibentuk dari rentetan pertama; Buat array kiraan dan kiraan frekuensi aksara dalam STR1. ; Sekarang melintasi STR2 untuk memeriksa sama ada setiap watak mempunyai jumlah yang cukup; Kod pemacu", "code": "< ? php $ MAX = 256 ; function canMakeStr2 ( $ str1 , $ str2 ) { $ count = ( 0 ) ; for ( $ i = 0 ; $ i < strlen ( $ str1 ) ; $ i ++ ) for ( $ i = 0 ; $ i < strlen ( $ str2 ) ; $ i ++ ) { if ( $ count [ $ str2 [ $ i ] ] == 0 ) return -1 ; } return true ; } $ str1 = \" geekforgeeks \" ; $ str2 = \" for \" ; if ( canMakeStr2 ( $ str1 , $ str2 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Kedudukan robot selepas pergerakan yang diberikan | berfungsi untuk mencari kedudukan akhir robot selepas pergerakan lengkap; melintasi rentetan arahan 'bergerak'; Bagi setiap pergerakan meningkatkan kaunter masing -masing; Kedudukan akhir robot yang diperlukan; Kod pemacu", "code": "< ? php function finalPosition ( $ move ) { $ l = strlen ( $ move ) ; $ countUp = 0 ; $ countDown = 0 ; $ countLeft = 0 ; $ countRight = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ move [ $ i ] == ' U ' ) $ countUp ++ ; else if ( $ move [ $ i ] == ' D ' ) $ countDown ++ ; else if ( $ move [ $ i ] == ' L ' ) $ countLeft ++ ; else if ( $ move [ $ i ] == ' R ' ) $ countRight ++ ; } echo \" Final ▁ Position : ▁ ( \" . ( $ countRight - $ countLeft ) . \" , \" ▁ , ▁ ( $ countUp ▁ - ▁ $ countDown ) ▁ . ▁ \" ) \" ▁ . \" \" } $ move = \" UDDLLRUUUDUURUDDUULLDRRRR \" ; finalPosition ( $ move ) ; ? >"}
{"text": "Panjang Parentheses Balanced Terpanjang Awalan | Kembalikan panjang kurungan kurungan seimbang yang paling lama. ; Melintasi rentetan. ; Jika pendakap terbuka tambah 1 hingga jumlah. ; Jika kurungan tertutup tolak 1 dari jumlah; Jika pendakap pertama menutup kurungan maka keadaan ini akan membantu; Jika jumlah adalah 0, simpan nilai indeks. ; Kod pemacu", "code": "< ? php function maxbalancedprefix ( $ str , $ n ) { $ sum = 0 ; $ maxi = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' ( ' ) $ sum += 1 ; else $ sum -= 1 ; if ( $ sum < 0 ) break ; if ( $ sum == 0 ) $ maxi = $ i + 1 ; } return $ maxi ; } $ str = array ( ' ( ' , ' ( ' , ' ( ' , ' ) ' , ' ( ' , ' ) ' , ' ) ' , ' ( ' , ' ) ' , ' ) ' , ' ( ' , ' ( ' ) ; $ n = count ( $ str ) ; echo maxbalancedprefix ( $ str , $ n ) ; ? >"}
{"text": "Kos minimum untuk menukar rentetan ke palindrome | Berfungsi untuk mengembalikan kos; panjang rentetan; Iterat dari kedua -dua belah rentetan. Jika tidak sama, kos akan berada di sana; Kod pemacu", "code": "< ? php function cost ( $ str ) { $ len = strlen ( $ str ) ; $ res = 0 ; for ( $ i = 0 , $ j = $ len - 1 ; $ i < $ j ; $ i ++ , $ j -- ) if ( $ str [ $ i ] != $ str [ $ j ] ) $ res += ( min ( ord ( $ str [ $ i ] ) , ord ( $ str [ $ j ] ) ) - ord ( ' a ' ) + 1 ) ; return $ res ; } $ str = \" abcdef \" ; echo cost ( $ str ) ; ? >"}
{"text": "Kemungkinan perkataan dari satu set aksara yang diberikan | Program PHP untuk memeriksa sama ada rentetan pertanyaan hadir diberikan set. ; Kira kejadian semua aksara dalam s. ; Semak jika bilangan kejadian setiap watak dalam q kurang daripada atau sama dengan yang dalam s. ; Kod pemacu", "code": "< ? php function isPresent ( $ s , $ q ) { $ freq = array ( 256 ) ; for ( $ i = 0 ; $ i < 256 ; $ i ++ ) $ freq [ $ i ] = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) $ freq [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < strlen ( $ q ) ; $ i ++ ) { $ freq [ ord ( $ q [ $ i ] ) - ord ( ' a ' ) ] -- ; if ( $ freq [ ord ( $ q [ $ i ] ) - ord ( ' a ' ) ] < 0 ) return false ; } return true ; } $ s = \" abctd \" ; $ q = \" cat \" ; if ( isPresent ( $ s , $ q ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Minimum mengurangkan operasi untuk menukar rentetan yang diberikan ke dalam palindrome | Mengembalikan kiraan watak minimum mengurangkan operasi untuk menjadikan palindrome. ; Bandingkan setiap watak separuh pertama dengan watak yang sama pada separuh kedua dan tambahkan perbezaan. ; Kod pemacu", "code": "< ? php function countReduce ( $ str ) { $ n = strlen ( $ str ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) $ res += abs ( ord ( $ str [ $ i ] ) - ord ( $ str [ ( $ n - $ i - 1 ) ] ) ) ; return $ res ; } $ str = \" abcd \" ; echo countReduce ( $ str ) ; ? >"}
{"text": "Operasi minimum untuk membuat nombor ajaib | berfungsi untuk mengira perubahan minimum; digit maksimum yang boleh diubah; gelung bersarang untuk menjana semua 6 digit nombor; kaunter untuk mengira bilangan perubahan yang diperlukan; Jika digit pertama adalah sama; Jika 2 digit adalah sama; Jika 3 rd digit adalah sama; jika digit ke -4 adalah sama; jika digit ke -5 adalah sama; jika digit ke -6 adalah sama; cek jika kurang maka sebelumnya mengira perubahan; mengembalikan jawapannya; nombor yang disimpan dalam rentetan; Mencetak operasi minimum", "code": "< ? php function calculate ( $ s ) { $ ans = 6 ; for ( $ i = 0 ; $ i < 10 ; ++ $ i ) { for ( $ j = 0 ; $ j < 10 ; ++ $ j ) { for ( $ k = 0 ; $ k < 10 ; ++ $ k ) { for ( $ l = 0 ; $ l < 10 ; ++ $ l ) { for ( $ m = 0 ; $ m < 10 ; ++ $ m ) { for ( $ n = 0 ; $ n < 10 ; ++ $ n ) { if ( $ i + $ j + $ k == $ l + $ m + $ n ) { $ c = 0 ; if ( $ i != $ s [ 0 ] - '0' ) $ c ++ ; if ( $ j != $ s [ 1 ] - '0' ) $ c ++ ; if ( $ k != $ s [ 2 ] - '0' ) $ c ++ ; if ( $ l != $ s [ 3 ] - '0' ) $ c ++ ; if ( $ m != $ s [ 4 ] - '0' ) $ c ++ ; if ( $ n != $ s [ 5 ] - '0' ) $ c ++ ; if ( $ c < $ ans ) $ ans = $ c ; } } } } } } } return $ ans ; } $ s = \"123456\" ; echo calculate ( $ s ) ; ? >"}
{"text": "Semak jika dua rentetan aksara boleh dibuat menggunakan kata -kata yang diberikan | Fungsi untuk memeriksa sama ada STR boleh dibuat menggunakan kata -kata yang diberikan; Jika STR sendiri hadir; Padankan watak pertama STR dengan kedua perkataan dan sebaliknya; Jika kedua -dua watak dijumpai. ; Kod pemacu", "code": "< ? php function makeAndCheckString ( $ words , $ str ) { $ n = sizeof ( $ words ) ; $ first = false ; $ second = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ words [ $ i ] == $ str ) return true ; if ( $ str [ 0 ] == $ words [ $ i ] [ 1 ] ) $ first = true ; if ( $ str [ 1 ] == $ words [ $ i ] [ 0 ] ) $ second = true ; if ( $ first && $ second ) return true ; } return false ; } $ str = \" ya \" ; $ words = array ( \" ah \" , \" oy \" , \" to \" , \" ha \" ) ; if ( makeAndCheckString ( $ words , $ str ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Palindrome ayat (palindrome selepas mengeluarkan ruang, titik ,. dll) | Untuk memeriksa ayat adalah palindrome atau tidak; Rentetan huruf kecil; Membandingkan watak sehingga mereka sama; Sekiranya terdapat simbol lain di sebelah kiri ayat; Sekiranya terdapat simbol lain di sebelah kanan hukuman; Sekiranya watak adalah sama; Jika watak tidak sama maka ayat bukan palindrome; Pulangan benar jika ayat adalah palindrome; Program Pemandu untuk Menguji SentenPalindrome ()", "code": "< ? php function sentencePalindrome ( $ str ) { $ l = 0 ; $ h = strlen ( $ str ) - 1 ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) $ str [ $ i ] = strtolower ( $ str [ $ i ] ) ; while ( $ l <= $ h ) { if ( ! ( $ str [ $ l ] >= ' a ' && $ str [ $ l ] <= ' z ' ) ) $ l ++ ; else if ( ! ( $ str [ $ h ] >= ' a ' && $ str [ $ h ] <= ' z ' ) ) $ h -- ; else if ( $ str [ $ l ] == $ str [ $ h ] ) { $ l ++ ; $ h -- ; } else return false ; } return true ; } $ str = \" Too ▁ hot ▁ to ▁ hoot . \" ; if ( sentencePalindrome ( $ str ) ) echo \" Sentence ▁ is ▁ palindrome . \" ; else echo \" Sentence ▁ is ▁ not ▁ palindrome . \" ; return 0 ; ? >"}
{"text": "Cara untuk mengeluarkan satu elemen dari rentetan binari supaya XOR menjadi sifar | Mengembalikan bilangan cara di mana XOR menjadi sifar dengan mengeluarkan 1 elemen; Mengira nombor 0 dan 1; Jika kiraan orang -orang itu kemudiannya kembali kiraan sifar sifar lain dari satu; Kod pemacu", "code": "< ? php function xorZero ( $ str ) { $ one_count = 0 ; $ zero_count = 0 ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ str [ $ i ] == '1' ) $ one_count ++ ; else $ zero_count ++ ; if ( $ one_count % 2 == 0 ) return $ zero_count ; return $ one_count ; } $ str = \"11111\" ; echo xorZero ( $ str ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika kedua -dua bahagian rentetan mempunyai set aksara yang sama | Program PHP untuk memeriksa sama ada mungkin untuk memecah rentetan atau tidak; berfungsi untuk memeriksa sama ada kita boleh memecah rentetan atau tidak; Arahan kaunter diasaskan dengan 0; Panjang rentetan; melintasi sehingga elemen tengah dicapai; Separuh pertama; Separuh kedua; Memeriksa jika nilai adalah bendera set yang berbeza kepada 1; Rentetan yang akan diperiksa", "code": "< ? php $ MAX_CHAR = 26 ; function checkCorrectOrNot ( $ s ) { global $ MAX_CHAR ; $ count = array_fill ( 0 , $ MAX_CHAR , NULL ) ; $ n = strlen ( $ s ) ; if ( $ n == 1 ) return true ; for ( $ i = 0 , $ j = $ n - 1 ; $ i < $ j ; $ i ++ , $ j -- ) { $ count [ $ s [ $ i ] - ' a ' ] ++ ; $ count [ $ s [ $ j ] - ' a ' ] -- ; } for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) if ( $ count [ $ i ] != 0 ) return false ; return true ; } $ s = \" abab \" ; if ( checkCorrectOrNot ( $ s ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Tentukan jika rentetan mempunyai semua watak unik | Program PHP untuk menggambarkan rentetan dengan aksara unik menggunakan teknik kekerasan; Dengan mengandaikan rentetan boleh mempunyai aksara A - z, ini mempunyai 32 bit yang ditetapkan kepada 0; Jika bit itu sudah ditetapkan dalam pemeriksa, kembali palsu; Jika tidak, kemas kini dan teruskan dengan menetapkan sedikit di dalam pemeriksa; Tiada pendua yang dihadapi, kembali benar; Kod pemacu", "code": "< ? php function uniqueCharacters ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ bitAtIndex = $ str [ $ i ] - ' a ' ; if ( ( $ checker & ( 1 << $ bitAtIndex ) ) > 0 ) { return false ; } $ checker = $ checker | ( 1 << $ bitAtIndex ) ; } return true ; } $ str = \" geeksforgeeks \" ; if ( uniqueCharacters ( $ str ) ) { echo \" The ▁ String ▁ \" , $ str , \" ▁ has ▁ all ▁ unique ▁ characters STRNEWLINE \" ; } else { echo \" The ▁ String ▁ \" , $ str , \" ▁ has ▁ duplicate ▁ characters STRNEWLINE \" ; } ? >"}
{"text": "Semak sama ada k | Program PHP untuk memeriksa sama ada bit bit K - TH ditetapkan atau tidak; Kod pemacu", "code": "< ? php function isKthBitSet ( $ n , $ k ) { if ( $ n & ( 1 << ( $ k - 1 ) ) ) echo \" SET \" ; else echo \" NOT ▁ SET \" ; } $ n = 5 ; $ k = 1 ; isKthBitSet ( $ n , $ k ) ; ? >"}
{"text": "Fungsi rekursif untuk memeriksa sama ada rentetan adalah palindrome | Fungsi rekursif yang memeriksa str [s. . e] adalah palindrome atau tidak. ; Jika hanya ada satu watak; Jika watak pertama dan terakhir tidak sepadan; Sekiranya terdapat lebih daripada dua aksara, periksa sama ada substring tengah juga palindrome atau tidak. ; Rentetan kosong dianggap sebagai palindrome; Kod pemacu", "code": "< ? php function isPalRec ( $ str , $ s , $ e ) { if ( $ s == $ e ) return true ; if ( $ str [ $ s ] != $ str [ $ e ] ) return false ; if ( $ s < $ e + 1 ) return isPalRec ( $ str , $ s + 1 , $ e - 1 ) ; return true ; } function isPalindrome ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 0 ) return true ; return isPalRec ( $ str , 0 , $ n - 1 ) ; } { $ str = \" geeg \" ; if ( isPalindrome ( $ str ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; return 0 ; } ? >"}
{"text": "Kira substrings dengan watak pertama dan terakhir yang sama | mengandaikan kes yang lebih rendah sahaja; Mengira kekerapan setiap aksara dalam rentetan. ; Hasil pengkomputeran menggunakan tuduhan; Kod pemacu", "code": "< ? php $ MAX_CHAR = 26 ; function countSubstringWithEqualEnds ( $ s ) { global $ MAX_CHAR ; $ result = 0 ; $ n = strlen ( $ s ) ; $ count = array_fill ( 0 , $ MAX_CHAR , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) $ result += ( $ count [ $ i ] * ( $ count [ $ i ] + 1 ) / 2 ) ; return $ result ; } $ s = \" abcab \" ; echo countSubstringWithEqualEnds ( $ s ) ; ? >"}
{"text": "Maksimum Maksimum Berulang Karakter dalam String | Mengembalikan watak berulang maksimum dalam rentetan yang diberikan; Traverse String kecuali watak terakhir; Jika watak semasa sepadan dengan seterusnya; Jika tidak sepadan, hasil kemas kini (jika diperlukan) dan tetapkan semula kiraan; Kod pemacu", "code": "< ? php function maxRepeating ( $ str ) { $ n = strlen ( $ str ) ; $ count = 0 ; $ res = $ str [ 0 ] ; $ cur_count = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i < $ n - 1 && $ str [ $ i ] == $ str [ $ i + 1 ] ) $ cur_count ++ ; else { if ( $ cur_count > $ count ) { $ count = $ cur_count ; $ res = $ str [ $ i ] ; } $ cur_count = 1 ; } } return $ res ; } $ str = \" aaaabbaaccde \" ; echo maxRepeating ( $ str ) ; ? >"}
{"text": "Pertanyaan untuk watak dalam rentetan berulang | Cetak sama ada Indeks I dan J mempunyai elemen yang sama atau tidak. ; Mencari kedudukan relatif Indeks I, j. ; Pemeriksaan adalah elemen yang sama pada indeks I, j. ; Kod pemacu", "code": "< ? php function query ( $ s , $ i , $ j ) { $ n = strlen ( $ s ) ; $ i %= $ n ; $ j %= $ n ; if ( ( $ s [ $ i ] == $ s [ $ j ] ) ) echo \" Yes STRNEWLINE \" ; else echo \" No \" ; } $ X = \" geeksforgeeks \" ; query ( $ X , 0 , 8 ) ; query ( $ X , 8 , 13 ) ; query ( $ X , 6 , 15 ) ; ? >"}
{"text": "Count pasangan watak pada jarak yang sama seperti dalam Alphabets Bahasa Inggeris | Berfungsi untuk mengira pasangan; Kiraan kenaikan jika aksara berada pada jarak yang sama; Kod pemacu", "code": "< ? php function countPairs ( $ str ) { $ result = 0 ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( ord ( $ str [ $ i ] ) - ord ( $ str [ $ j ] ) ) == abs ( $ i - $ j ) ) $ result ++ ; return $ result ; } $ str = \" geeksforgeeks \" ; echo countPairs ( $ str ) ; ? >"}
{"text": "Susunan biasa terpanjang dengan permutasi dibenarkan | Fungsi untuk mengira string terpanjang str1 -> String pertama Str2 -> Count String kedua1 [] -> Hash Array untuk mengira kekerapan aksara dalam kiraan Str1 [2] -> Hash array untuk mengira kekerapan aksara dalam hasil str2 -> rentetan terpanjang yang dihasilkannya yang permutasi adalah sub -urutan yang diberikan dua rentetan; hitung kekerapan aksara; Sekarang melintasi hash array; tambah aksara ('a' + i) dalam hasil rentetan yang dihasilkan 'oleh min (count1 [$ i], count2 [$ i]) kali; Kod pemacu", "code": "< ? php function longestString ( $ str1 , $ str2 ) { $ count1 = array_fill ( 0 , 26 , NULL ) ; $ count2 = array_fill ( 0 , 26 , NULL ) ; for ( $ i = 0 ; $ i < strlen ( $ str1 ) ; $ i ++ ) $ count1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < strlen ( $ str2 ) ; $ i ++ ) $ count2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; $ result = \" \" ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) for ( $ j = 1 ; $ j <= min ( $ count1 [ $ i ] , $ count2 [ $ i ] ) ; $ j ++ ) $ result = $ result . chr ( ord ( ' a ' ) + $ i ) ; echo $ result ; } $ str1 = \" geeks \" ; $ str2 = \" cake \" ; longestString ( $ str1 , $ str2 ) ; ? >"}
{"text": "Kira bilangan substrings dengan tepat Kara Kisipan K | Berfungsi untuk mengira bilangan substring dengan watak -watak unik yang betul; Memulakan hasil; Untuk menyimpan kiraan watak dari 'A' hingga 'Z'; Pertimbangkan semua substrings bermula dengan STR [i]; Memulakan array kiraan dengan 0; Pertimbangkan semua substring antara STR [i. . j]; Jika ini adalah watak baru untuk substring ini, kenaikan dist_count. ; Kiraan kenaikan watak semasa; Jika kiraan watak yang berbeza menjadi k, maka hasil kenaikan. ; Kod pemacu", "code": "< ? php function countkDist ( $ str , $ k ) { $ res = 0 ; $ n = strlen ( $ str ) ; $ cnt = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dist_count = 0 ; $ cnt = array_fill ( 0 , 0 , true ) ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { if ( $ cnt [ ord ( $ str [ $ j ] ) - ord ( ' a ' ) ] == 0 ) $ dist_count ++ ; $ cnt [ ord ( $ str [ $ j ] ) - ord ( ' a ' ) ] ++ ; if ( $ dist_count == $ k ) $ res ++ ; } } return $ res ; } { $ ch = \" abcbaa \" ; $ k = 3 ; echo ( \" Total ▁ substrings ▁ with ▁ exactly ▁ \" . $ k . \" ▁ distinct ▁ characters ▁ : ▁ \" . countkDist ( $ ch , $ k ) ) ; }"}
{"text": "Keluarkan digit berulang dalam nombor tertentu | Program PHP untuk menghapuskan digit berulang; Simpan digit pertama sebagai digit sebelumnya; Memulakan kuasa; Melangkah melalui semua digit N, ambil perhatian bahawa digit diproses dari digit paling ketara ke digit yang paling penting. ; Menyimpan digit semasa; Tambah digit semasa ke permulaan hasil; Mengemas kini hasil dan kuasa sebelumnya; Keluarkan digit terakhir dari N; Kod pemacu", "code": "< ? php function removeRecur ( $ n ) { $ prev_digit = $ n % 10 ; $ pow = 10 ; $ res = $ prev_digit ; while ( $ n ) { $ curr_digit = $ n % 10 ; if ( $ curr_digit != $ prev_digit ) { $ res += $ curr_digit * $ pow ; $ prev_digit = $ curr_digit ; $ pow *= 10 ; } $ n = $ n / 10 ; } return $ res ; } $ n = 12224 ; echo removeRecur ( $ n ) ; ? >"}
{"text": "Menjana semua rentetan binari n bit | Berfungsi untuk mencetak output; Berfungsi untuk menjana semua rentetan binari; Pertama berikan \"0\" pada kedudukan ith dan cuba untuk semua permutasi lain untuk kedudukan yang tinggal; Dan kemudian berikan \"1\" pada kedudukan ith dan cuba untuk semua permutasi lain untuk kedudukan yang tinggal; Kod pemacu; Cetak semua rentetan binari", "code": "< ? php function printTheArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ arr [ $ i ] , \" \" ; } echo \" STRNEWLINE \" ; } function generateAllBinaryStrings ( $ n , $ arr , $ i ) { if ( $ i == $ n ) { printTheArray ( $ arr , $ n ) ; return ; } $ arr [ $ i ] = 0 ; generateAllBinaryStrings ( $ n , $ arr , $ i + 1 ) ; $ arr [ $ i ] = 1 ; generateAllBinaryStrings ( $ n , $ arr , $ i + 1 ) ; } $ n = 4 ; $ arr = array_fill ( 0 , $ n , 0 ) ; generateAllBinaryStrings ( $ n , $ arr , 0 ) ; ? >"}
{"text": "Nombor terbesar n yang boleh dikurangkan kepada 0 dalam langkah K | Fungsi utiliti untuk mengembalikan digit pertama nombor. ; Keluarkan digit terakhir dari nombor sehingga hanya satu digit yang tersisa; Kembalikan angka pertama; Fungsi utiliti yang mengembalikan kiraan nombor yang ditulis apabila bermula dari N; Berfungsi untuk mencari nombor terbesar N yang boleh dikurangkan kepada 0 dalam langkah K; Dapatkan panjang urutan titik pertengahan; Sehingga panjang urutan k dicapai; Kemas kini titik pertengahan; Dapatkan kiraan titik pertengahan baru; Kemas kini Hak ke Mid; Kemas kini kiri ke pertengahan; Peningkatan titik pertengahan oleh satu manakala kiraan adalah sama dengan k untuk mendapatkan nilai maksimum titik pertengahan; Kod pemacu", "code": "< ? php function firstDigit ( $ n ) { while ( $ n >= 10 ) { $ n = ( int ) ( $ n / 10 ) ; } return $ n ; } function getCount ( $ n ) { $ count = 1 ; while ( $ n != 0 ) { $ leadDigit = firstDigit ( $ n ) ; $ n -= $ leadDigit ; $ count ++ ; } return $ count ; } function getLargestNumber ( $ k ) { $ left = $ k ; $ right = $ k * 10 ; $ mid = ( int ) ( ( $ left + $ right ) / 2 ) ; $ len = getCount ( $ mid ) ; while ( $ len != $ k ) { $ mid = ( int ) ( ( $ left + $ right ) / 2 ) ; $ len = getCount ( $ mid ) ; if ( $ len > $ k ) { $ right = $ mid ; } else { $ left = $ mid ; } } while ( $ len == $ k ) { if ( $ len != getCount ( $ mid + 1 ) ) { break ; } $ mid ++ ; } return ( $ mid ) ; } $ k = 3 ; echo ( getLargestNumber ( $ k ) ) ; ? >"}
{"text": "Cari diameter atau kord terpanjang lingkaran | Berfungsi untuk mencari kord terpanjang; Dapatkan jejari; Cari diameter", "code": "< ? php function diameter ( $ r ) { echo \" The ▁ length ▁ of ▁ the ▁ longest ▁ chord \" , \" ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ \" , 2 * $ r << \" STRNEWLINE \" ; } $ r = 4 ; diameter ( $ r ) ; ? >"}
{"text": "Cerun garis selari dengan garis dengan cerun yang diberikan | Berfungsi untuk mengembalikan cerun garis yang selari dengan garis dengan cerun yang diberikan; Kod pemacu", "code": "< ? php function getSlope ( $ m ) { return $ m ; } $ m = 2 ; echo getSlope ( $ m ) ; ? >"}
{"text": "Jumlah segitiga yang terbentuk apabila terdapat garis menegak dan V menegak | Berfungsi untuk mengembalikan jumlah segitiga; Hanya segitiga yang mungkin adalah segitiga yang diberikan; Jika hanya garis menegak hadir; Jika hanya garis mendatar hadir; Mengembalikan jumlah segitiga; Kod pemacu", "code": "< ? php function totalTriangles ( $ h , $ v ) { if ( $ h == 0 && $ v == 0 ) return 1 ; if ( $ h == 0 ) return ( ( $ v + 1 ) * ( $ v + 2 ) / 2 ) ; if ( $ v == 0 ) return ( $ h + 1 ) ; $ Total = ( $ h + 1 ) * ( ( $ v + 1 ) * ( $ v + 2 ) / 2 ) ; return $ Total ; } $ h = 2 ; $ v = 2 ; echo totalTriangles ( $ h , $ v ) ; ? >"}
{"text": "Sfera terbesar yang boleh ditulis dalam silinder bulat yang betul yang tertulis dalam frustum | Berfungsi untuk mencari sfera terbesar; Radii dan ketinggian tidak boleh negatif; jejari sfera; jumlah sfera; Kod pemacu", "code": "< ? php function sph ( $ r , $ R , $ h ) { if ( $ r < 0 && $ R < 0 && $ h < 0 ) return -1 ; $ x = $ r ; $ V = ( 4 * 3.14 * pow ( $ r , 3 ) ) / 3 ; return $ V ; } $ r = 5 ; $ R = 8 ; $ h = 11 ; echo sph ( $ r , $ R , $ h ) ; #This  Code is contributed by ajit.. NEW_LINE ? >"}
{"text": "Semak sama ada dua garis lurus adalah ortogonal atau tidak | Berfungsi untuk memeriksa sama ada dua garis lurus adalah ortogonal atau tidak; Kedua -dua baris mempunyai cerun tak terhingga; Hanya baris 1 yang mempunyai cerun tak terhingga; Hanya garis 2 yang mempunyai cerun tak terhingga; Cari lereng garis; Periksa sama ada produk mereka - 1; Kod pemacu", "code": "< ? php function checkOrtho ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) { if ( $ x2 - $ x1 == 0 && $ x4 - $ x3 == 0 ) return false ; else if ( $ x2 - $ x1 == 0 ) { $ m2 = ( int ) ( ( $ y4 - $ y3 ) / ( $ x4 - $ x3 ) ) ; if ( $ m2 == 0 ) return true ; else return false ; } else if ( $ x4 - $ x3 == 0 ) { $ m1 = ( int ) ( ( $ y2 - $ y1 ) / ( $ x2 - $ x1 ) ) ; if ( $ m1 == 0 ) return true ; else return false ; } else { $ m1 = ( int ) ( ( $ y2 - $ y1 ) / ( $ x2 - $ x1 ) ) ; $ m2 = ( int ) ( ( $ y4 - $ y3 ) / ( $ x4 - $ x3 ) ) ; if ( $ m1 * $ m2 == -1 ) return true ; else return false ; } } $ x1 = 0 ; $ y1 = 4 ; $ x2 = 0 ; $ y2 = -9 ; $ x3 = 2 ; $ y3 = 0 ; $ x4 = -1 ; $ y4 = 0 ; if ( checkOrtho ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; ? >"}
{"text": "Diagonal Pentagon biasa | Berfungsi untuk mencari pepenjuru pentagon biasa; Sisi tidak boleh negatif; Panjang pepenjuru; Kod pemacu", "code": "< ? php function pentdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.22 * $ a ; return $ d ; } $ a = 6 ; echo pentdiagonal ( $ a ) ; ? >"}
{"text": "Kawasan Hexagon dengan Panjang Diagonal yang diberikan | Berfungsi untuk mengira kawasan; Formula untuk mencari kawasan; Kod pemacu", "code": "< ? php function hexagonArea ( $ d ) { return ( 3 * sqrt ( 3 ) * pow ( $ d , 2 ) ) / 8 ; } $ d = 10 ; echo \" Area ▁ of ▁ hexagon : ▁ \" , hexagonArea ( $ d ) ; ? >"}
{"text": "Bilangan kotak panjang yang diperlukan untuk menutupi segi empat tepat n * m | berfungsi untuk mencari bilangan kotak A * yang diperlukan untuk menutupi segi empat tepat n * m; Kod pemacu; panggilan fungsi", "code": "< ? php function Squares ( $ n , $ m , $ a ) { return ( ( int ) ( ( $ m + $ a - 1 ) / $ a ) ) * ( ( int ) ( ( $ n + $ a - 1 ) / $ a ) ) ; } $ n = 6 ; $ m = 6 ; $ a = 4 ; echo Squares ( $ n , $ m , $ a ) ; ? >"}
{"text": "Panjang pepenjuru oktagon | Berfungsi untuk mencari pepenjuru oktagon; sisi tidak boleh negatif; pepenjuru oktagon; Kod pemacu", "code": "< ? php function octadiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; return $ a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; } $ a = 4 ; echo octadiagonal ( $ a ) ; ? >"}
{"text": "Program untuk mengira perimeter decagon | Fungsi untuk mencari perimeter; Kod pemacu", "code": "< ? php function CalPeri ( $ s ) { $ Perimeter = 10 * $ s ; echo \" The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ $ Perimeter \" ; } $ s = 5 ; CalPeri ( $ s ) ; ? >"}
{"text": "Jumlah panjang semua 12 tepi mana -mana parallelepiped segi empat tepat | berfungsi untuk mencari jumlah semua tepi parallelepiped; untuk mengira panjang satu tepi; Jumlah semua tepi satu sisi; Jumlah bersih akan sama dengan penjumlahan tepi semua sisi; memulakan kawasan tiga muka yang mempunyai puncak biasa", "code": "< ? php function findEdges ( $ s1 , $ s2 , $ s3 ) { $ a = sqrt ( $ s1 * $ s2 / $ s3 ) ; $ b = sqrt ( $ s3 * $ s1 / $ s2 ) ; $ c = sqrt ( $ s3 * $ s2 / $ s1 ) ; $ sum = $ a + $ b + $ c ; return 4 * $ sum ; } $ s1 ; $ s2 ; $ s3 ; $ s1 = 65 ; $ s2 = 156 ; $ s3 = 60 ; echo findEdges ( $ s1 , $ s2 , $ s3 ) ; ? >"}
{"text": "Bilangan maksimum kepingan dalam pemotongan n | Fungsi untuk mencari kepingan maksimum dengan pemotongan N. ; Untuk memaksimumkan bilangan kepingan x adalah potongan mendatar; Sekarang (x) adalah potongan mendatar dan (n - x) adalah pemotongan menegak, maka bilangan maksimum kepingan = (x + 1) * (n - x + 1); Mengambil bilangan maksimum pemotongan yang dibenarkan sebagai 3; Mencari dan Mencetak Bilangan Maksimum", "code": "< ? php function findMaximumPieces ( $ n ) { $ x = ( int ) ( $ n / 2 ) ; return ( ( $ x + 1 ) * ( $ n - $ x + 1 ) ) ; } $ n = 3 ; echo \" Max ▁ number ▁ of ▁ pieces ▁ for ▁ n ▁ = ▁ \" . $ n . \" ▁ is ▁ \" . findMaximumPieces ( 3 ) ; ? >"}
{"text": "Program untuk memeriksa sama ada 4 mata dalam 3 | Fungsi untuk mencari persamaan satah. ; memeriksa jika titik ke -4 memenuhi persamaan di atas; Kod pemacu; fungsi panggilan", "code": "< ? php function equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 , $ x , $ y , $ z ) { $ a1 = $ x2 - $ x1 ; $ b1 = $ y2 - $ y1 ; $ c1 = $ z2 - $ z1 ; $ a2 = $ x3 - $ x1 ; $ b2 = $ y3 - $ y1 ; $ c2 = $ z3 - $ z1 ; $ a = $ b1 * $ c2 - $ b2 * $ c1 ; $ b = $ a2 * $ c1 - $ a1 * $ c2 ; $ c = $ a1 * $ b2 - $ b1 * $ a2 ; $ d = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 ) ; if ( $ a * $ x + $ b * $ y + $ c * $ z + $ d == 0 ) echo ( \" Coplanar \" ) ; else echo ( \" Not ▁ Coplanar \" ) ; } $ x1 = 3 ; $ y1 = 2 ; $ z1 = -5 ; $ x2 = -1 ; $ y2 = 4 ; $ z2 = -3 ; $ x3 = -3 ; $ y3 = 8 ; $ z3 = -5 ; $ x4 = -3 ; $ y4 = 2 ; $ z4 = 1 ; equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 , $ x4 , $ y4 , $ z4 ) ; ? >"}
{"text": "Sudut antara dua pesawat dalam 3D | Berfungsi untuk mencari sudut; Kod pemacu", "code": "< ? php function distance ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) { $ d = ( $ a1 * $ a2 + $ b1 * $ b2 + $ c1 * $ c2 ) ; $ e1 = sqrt ( $ a1 * $ a1 + $ b1 * $ b1 + $ c1 * $ c1 ) ; $ e2 = sqrt ( $ a2 * $ a2 + $ b2 * $ b2 + $ c2 * $ c2 ) ; $ d = $ d / ( $ e1 * $ e2 ) ; $ pi = 3.14159 ; $ A = ( 180 / $ pi ) * ( acos ( $ d ) ) ; echo sprintf ( \" Angle ▁ is ▁ % .2f ▁ degree \" , $ A ) ; } $ a1 = 1 ; $ b1 = 1 ; $ c1 = 2 ; $ d1 = 1 ; $ a2 = 2 ; $ b2 = -1 ; $ c2 = 1 ; $ d2 = -4 ; distance ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) ; ? >"}
{"text": "Cermin titik melalui pesawat 3 d | Berfungsi untuk mencerminkan imej; Kod pemacu; panggilan fungsi", "code": "< ? php function mirror_point ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) { $ k = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 - $ d ) / ( $ a * $ a + $ b * $ b + $ c * $ c ) ; $ x2 = $ a * $ k + $ x1 ; $ y2 = $ b * $ k + $ y1 ; $ z2 = $ c * $ k + $ z1 ; $ x3 = 2 * $ x2 - $ x1 ; $ y3 = 2 * $ y2 - $ y1 ; $ z3 = 2 * $ z2 - $ z1 ; echo sprintf ( \" x3 ▁ = ▁ % .1f ▁ \" , $ x3 ) ; echo sprintf ( \" y3 ▁ = ▁ % .1f ▁ \" , $ y3 ) ; echo sprintf ( \" z3 ▁ = ▁ % .1f ▁ \" , $ z3 ) ; } $ a = 1 ; $ b = -2 ; $ c = 0 ; $ d = 0 ; $ x1 = -1 ; $ y1 = 3 ; $ z1 = 4 ; mirror_point ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) ; ? >"}
{"text": "Bilangan segi empat tepat dalam lingkaran radius r | Berfungsi untuk mengembalikan jumlah segi empat tepat yang boleh dipotong dari bulatan; Diameter = 2 * $ radius; Persegi diameter yang merupakan kuadrat panjang maksimum pepenjuru; menjana semua kombinasi A dan B dalam julat (1, (2 * radius - 1)) (kedua -duanya termasuk); Hitung panjang pepenjuru segi empat tepat ini; Jika panjang pepenjuru segi empat tepat ini kurang daripada diameter, ia adalah segi empat tepat yang sah, oleh itu kaunter kenaikan; Jejari bulatan", "code": "< ? php function countRectangles ( $ radius ) { $ rectangles = 0 ; $ diameter = 2 * $ radius ; $ diameterSquare = $ diameter * $ diameter ; for ( $ a = 1 ; $ a < 2 * $ radius ; $ a ++ ) { for ( $ b = 1 ; $ b < 2 * $ radius ; $ b ++ ) { $ diagonalLengthSquare = ( $ a * $ a + $ b * $ b ) ; if ( $ diagonalLengthSquare <= $ diameterSquare ) { $ rectangles ++ ; } } } return $ rectangles ; } $ radius = 2 ; $ totalRectangles ; $ totalRectangles = countRectangles ( $ radius ) ; echo $ totalRectangles , \" ▁ rectangles ▁ can ▁ be ▁ \" , \" cut ▁ from ▁ a ▁ circle ▁ of ▁ Radius ▁ \" , $ radius ; ? >"}
{"text": "Program untuk menyemak persamaan dua segitiga yang diberikan | Fungsi untuk persamaan AAA; Semak AAA; Fungsi untuk persamaan SAS; Sudut b / w Dua sisi terkecil adalah terbesar. ; kerana kita mengambil sudut b / w sisi. ; Fungsi untuk persamaan SSS; Semak SSS; Kod pemacu; fungsi panggilan untuk persamaan AAA; fungsi panggilan untuk persamaan SSS; fungsi panggilan untuk persamaan SAS; Periksa sama ada segitiga serupa atau tidak", "code": "< ? php function simi_aaa ( $ a1 , $ a2 ) { sort ( $ a1 ) ; sort ( $ a2 ) ; if ( $ a1 [ 0 ] == $ a2 [ 0 ] && $ a1 [ 1 ] == $ a2 [ 1 ] && $ a1 [ 2 ] == $ a2 [ 2 ] ) return 1 ; else return 0 ; } function simi_sas ( $ s1 , $ s2 , $ a1 , $ a2 ) { sort ( $ a1 ) ; sort ( $ a2 ) ; sort ( $ s1 ) ; sort ( $ s2 ) ; if ( $ s1 [ 0 ] / $ s2 [ 0 ] == $ s1 [ 1 ] / $ s2 [ 1 ] ) { if ( $ a1 [ 2 ] == $ a2 [ 2 ] ) return 1 ; } if ( $ s1 [ 1 ] / $ s2 [ 1 ] == $ s1 [ 2 ] / $ s2 [ 2 ] ) { if ( $ a1 [ 0 ] == $ a2 [ 0 ] ) return 1 ; } if ( $ s1 [ 2 ] / $ s2 [ 2 ] == $ s1 [ 0 ] / $ s2 [ 0 ] ) { if ( $ a1 [ 1 ] == $ a2 [ 1 ] ) return 1 ; } return 0 ; } function simi_sss ( $ s1 , $ s2 ) { sort ( $ s1 ) ; sort ( $ s2 ) ; if ( $ s1 [ 0 ] / $ s2 [ 0 ] == $ s1 [ 1 ] / $ s2 [ 1 ] && $ s1 [ 1 ] / $ s2 [ 1 ] == $ s1 [ 2 ] / $ s2 [ 2 ] && $ s1 [ 2 ] / $ s2 [ 2 ] == $ s1 [ 0 ] / $ s2 [ 0 ] ) return 1 ; return 0 ; } $ s1 = array ( 2 , 3 , 3 ) ; $ s2 = array ( 4 , 6 , 6 ) ; $ a1 = array ( 80 , 60 , 40 ) ; $ a2 = array ( 40 , 60 , 80 ) ; $ aaa = simi_aaa ( $ a1 , $ a2 ) ; $ sss = simi_sss ( $ s1 , $ s2 ) ; $ sas = simi_sas ( $ s1 , $ s2 , $ a1 , $ a2 ) ; if ( $ aaa == 1 $ sss == 1 $ sas == 1 ) { echo \" Triangles ▁ are ▁ similar ▁ by ▁ \" ; if ( $ aaa == 1 ) echo \" AAA ▁ \" ; if ( $ sss == 1 ) echo \" SSS ▁ \" ; if ( $ sas == 1 ) echo \" SAS . \" ; } else echo \" Triangles ▁ are ▁ not ▁ similar \" ; ? >"}
{"text": "Nombor pentadecagonal yang berpusat | fungsi pentadecagonal yang berpusat; Formula untuk mengira nombor pentadecagonal yang berpusat di nth; Kod pemacu", "code": "< ? php function center_pentadecagonal_num ( $ n ) { return ( 15 * $ n * $ n - 15 * $ n + 2 ) / 2 ; } $ n = 3 ; echo $ n , \" th ▁ number ▁ : ▁ \" , center_pentadecagonal_num ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 10 ; echo $ n , \" th ▁ number ▁ : ▁ \" , center_pentadecagonal_num ( $ n ) ; ? >"}
{"text": "Nombor nonadecagonal yang berpusat | fungsi nonadecagonal yang berpusat; Formula untuk mengira nombor nonadecagonal yang berpusat di Nth; Kod pemacu", "code": "< ? php function center_nonadecagon_num ( $ n ) { return ( 19 * $ n * $ n - 19 * $ n + 2 ) / 2 ; } $ n = 2 ; echo $ n , \" th ▁ centered ▁ \" + \" nonadecagonal ▁ number ▁ : ▁ \" , center_nonadecagon_num ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 7 ; echo $ n , \" th ▁ centered ▁ \" + \" nonadecagonal ▁ number ▁ : ▁ \" , center_nonadecagon_num ( $ n ) ; ? >"}
{"text": "Nombor Hendecagonal | Berfungsi untuk mencari nombor Hendecagonal; Formula untuk mengira nombor Hendecagonal nth; Kod pemacu", "code": "< ? php function hendecagonal_num ( $ n ) { return ( 9 * $ n * $ n - 7 * $ n ) / 2 ; } $ n = 3 ; echo $ n , \" th ▁ Hendecagonal ▁ number : ▁ \" ; echo hendecagonal_num ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 10 ; echo $ n , \" th ▁ Hendecagonal ▁ number : ▁ \" ; echo hendecagonal_num ( $ n ) ; ? >"}
{"text": "Nombor Octagon yang berpusat | Fungsi nombor oktagon yang berpusat; Formula untuk mengira nombor oktagon yang berpusat di NTH & mengembalikannya ke dalam fungsi utama. ; Kod pemacu", "code": "< ? php function cen_octagonalnum ( $ n ) { return ( 4 * $ n * $ n - 4 * $ n + 1 ) ; } $ n = 6 ; echo $ n , \" th ▁ centered \" , \" ▁ octagonal ▁ number ▁ : ▁ \" ; echo cen_octagonalnum ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 11 ; echo $ n , \" th ▁ centered \" , \" ▁ octagonal ▁ number ▁ : ▁ \" ; echo cen_octagonalnum ( $ n ) ; ? >"}
{"text": "Bilangan poin yang diperintahkan pasangan persamaan garis yang memuaskan | Cek jika (i, j) adalah sah, titik (i, j) adalah sah jika titik (arr [i], arr [j]) memenuhi persamaan y = mx + c dan saya tidak sama dengan j; Semak sama ada saya sama dengan J; Persamaan LHS = Y, dan RHS = MX + C; Mengembalikan bilangan pasangan yang diperintahkan (i, j) yang mana (arr [i], arr [j]) memenuhi persamaan garis y = mx + c; Untuk setiap yang mungkin (i, j) semak jika (a [i], a [j]) memenuhi persamaan y = mx + c; (FirstIndex, SecondIndex) adalah sama seperti (i, j); Semak jika (FirstIndex, SecondIndex) adalah titik yang sah; Kod pemacu; persamaan garis ialah y = mx + c", "code": "< ? php function isValid ( $ arr , $ i , $ j , $ m , $ c ) { if ( $ i == $ j ) return false ; $ lhs = $ arr [ $ j ] ; $ rhs = $ m * $ arr [ $ i ] + $ c ; return ( $ lhs == $ rhs ) ; } function findOrderedPoints ( $ arr , $ n , $ m , $ c ) { $ counter = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ firstIndex = $ i ; $ secondIndex = $ j ; if ( isValid ( $ arr , $ firstIndex , $ secondIndex , $ m , $ c ) ) $ counter ++ ; } } return $ counter ; } $ arr = array ( 1 , 2 , 3 , 4 , 2 ) ; $ n = count ( $ arr ) ; $ m = 1 ; $ c = 1 ; echo ( findOrderedPoints ( $ arr , $ n , $ m , $ c ) ) ; ? >"}
{"text": "Semak jika bulatan yang diberikan terletak sepenuhnya di dalam cincin yang dibentuk oleh dua lingkaran sepusat | Berfungsi untuk memeriksa sama ada bulatan terletak di cincin; Jarak antara pusat pusat bulatan lingkaran sepusat (asal) menggunakan teorem Pythagoras; Keadaan untuk memeriksa sama ada bulatan adalah ketat di dalam cincin; Kedua -dua bulatan dengan radius 'r' dan 'r' mempunyai pusat (0, 0)", "code": "< ? php function checkcircle ( $ r , $ R , $ r1 , $ x1 , $ y1 ) { $ dis = sqrt ( $ x1 * $ x1 + $ y1 * $ y1 ) ; return ( $ dis - $ r1 >= $ R && $ dis + $ r1 <= $ r ) ; } $ r = 8 ; $ R = 4 ; $ r1 = 2 ; $ x1 = 6 ; $ y1 = 0 ; if ( checkcircle ( $ r , $ R , $ r1 , $ x1 , $ y1 ) ) echo \" yes \" , \" STRNEWLINE \" ; else echo \" no \" , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk kawasan permukaan octahedron | fungsi utiliti; Kod pemacu", "code": "< ? php function surface_area_octahedron ( $ side ) { return ( 2 * ( sqrt ( 3 ) ) * ( $ side * $ side ) ) ; } $ side = 7 ; echo ( \" Surface ▁ area ▁ of ▁ octahedron ▁ = \" ) ; echo ( surface_area_octahedron ( $ side ) ) ; ? >"}
{"text": "Mengira garis lurus yang berbeza dengan jumlah N Points dengan M collinear | Pulangan nilai pekali binomial; $ C [0] = 1; NC0 adalah 1; Kirakan baris seterusnya segitiga Pascal menggunakan baris sebelumnya; fungsi untuk mengira bilangan garis lurus boleh dibentuk; Kod pemacu", "code": "< ? php function nCk ( $ n , $ k ) { $ C = array_fill ( 0 , $ k + 1 , NULL ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ k ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C [ $ k ] ; } function count_Straightlines ( $ n , $ m ) { return ( nCk ( $ n , 2 ) - nCk ( $ m , 2 ) + 1 ) ; } $ n = 4 ; $ m = 3 ; echo ( count_Straightlines ( $ n , $ m ) ) ; ? >"}
{"text": "Kirakan jumlah dodecahedron | fungsi utiliti; Fungsi pemacu", "code": "< ? php function vol_of_dodecahedron ( $ side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow ( $ side , 3 ) ) ) ; } $ side = 4 ; echo ( \" Volume ▁ of ▁ dodecahedron ▁ = ▁ \" ) ; echo ( vol_of_dodecahedron ( $ side ) ) ; ? >"}
{"text": "Program untuk memeriksa sama ada tangki air melimpah apabila bola pepejal dicelupkan dalam tangki air | berfungsi untuk mencari jika tangki akan melimpah atau tidak; kapasiti silinder; jumlah air dalam tangki; jumlah bola N; jumlah jumlah air dan bola yang dicelupkan; keadaan untuk memeriksa sama ada tangki berada dalam keadaan limpahan atau tidak; memberi dimensi; fungsi panggilan", "code": "< ? php function overflow ( $ H , $ r , $ h , $ N , $ R ) { $ tank_cap = 3.14 * $ r * $ r * $ H ; $ water_vol = 3.14 * $ r * $ r * $ h ; $ balls_vol = $ N * ( 4 / 3 ) * 3.14 * $ R * $ R * $ R ; $ vol = $ water_vol + $ balls_vol ; if ( $ vol > $ tank_cap ) { echo \" Overflow \" , \" STRNEWLINE \" ; } else { echo \" Not ▁ in ▁ overflow ▁ state \" , \" STRNEWLINE \" ; } } $ H = 10 ; $ r = 5 ; $ h = 5 ; $ N = 2 ; $ R = 2 ; overflow ( $ H , $ r , $ h , $ N , $ R ) ; ? >"}
{"text": "Program untuk memeriksa sama ada tangki akan melimpah, mengalir atau diisi masa yang diberikan | fungsi untuk mengira jumlah tangki; berfungsi untuk mencetak limpahan / diisi / bawah aliran dengan sewajarnya; jejari tangki; ketinggian tangki; kadar aliran air; masa diberikan; hitung masa yang diperlukan; mencetak hasilnya", "code": "< ? php function volume ( $ radius , $ height ) { return ( ( 22 / 7 ) * $ radius * $ radius * $ height ) ; } function check_and_print ( $ required_time , $ given_time ) { if ( $ required_time < $ given_time ) echo ( \" Overflow \" ) ; else if ( $ required_time > $ given_time ) echo ( \" Underflow \" ) ; else echo ( \" Filled \" ) ; } $ radius = 5 ; $ height = 10 ; $ rate_of_flow = 10 ; $ given_time = 70.0 ; $ required_time = volume ( $ radius , $ height ) / $ rate_of_flow ; check_and_print ( $ required_time , $ given_time ) ; ? >"}
{"text": "Program untuk mencari sisi ketiga segitiga menggunakan undang -undang kosines | Fungsi untuk mengira nilai cos sudut C; Menukar darjah kepada Radian; Peta jumlah sepanjang siri; Memegang nilai sebenar dosa (n); Berfungsi untuk mencari bahagian ketiga; Kod pemacu; panggilan fungsi", "code": "< ? php function cal_cos ( $ n ) { $ accuracy = 0.0001 ; $ x1 ; $ denominator ; $ cosx ; $ cosval ; $ n = $ n * ( 3.142 / 180.0 ) ; $ x1 = 1 ; $ cosx = $ x1 ; $ cosval = cos ( $ n ) ; $ i = 1 ; do { $ denominator = 2 * $ i * ( 2 * $ i - 1 ) ; $ x1 = - $ x1 * $ n * $ n / $ denominator ; $ cosx = $ cosx + $ x1 ; $ i = $ i + 1 ; } while ( $ accuracy <= ( $ cosval - $ cosx ) ) ; return $ cosx ; } function third_side ( $ a , $ b , $ c ) { $ angle = cal_cos ( $ c ) ; return sqrt ( ( $ a * $ a ) + ( $ b * $ b ) - 2 * $ a * $ b * $ angle ) ; } $ c = 49 ; $ a = 5 ; $ b = 8 ; echo third_side ( $ a , $ b , $ c ) ; ? >"}
{"text": "Semak sama ada bulatan yang diberikan berada di sempadan yang dikekalkan oleh dua lingkaran lain | berfungsi untuk memeriksa sama ada bulatan yang diberikan sesuai di sempadan atau tidak; Jarak dari pusat; Memeriksa sudut bulatan; Jejari lingkaran luar dan bulatan dalaman masing -masing; Co - Ordinat dan Radius Lingkaran yang akan diperiksa", "code": "< ? php function fitOrNotFit ( $ R , $ r , $ x , $ y , $ rad ) { $ val = sqrt ( pow ( $ x , 2 ) + pow ( $ y , 2 ) ) ; if ( $ val + $ rad <= $ R && $ val - $ rad >= $ R - $ r ) echo \" Fits STRNEWLINE \" ; else echo \" Doesn ' t ▁ Fit STRNEWLINE \" ; } $ R = 8 ; $ r = 4 ; $ x = 5 ; $ y = 3 ; $ rad = 3 ; fitOrNotFit ( $ R , $ r , $ x , $ y , $ rad ) ; ? >"}
{"text": "Poligon biasa menggunakan hanya 1 s dalam bulatan bernombor binari | Kaedah pulangan benar jika poligon mungkin dengan bilangan titik tengah 'titik tengah'; gelung untuk mendapatkan puncak pertama poligon; gelung ke atas nilai array pada jarak 'titik tengah'; dan (&) semua nilai tersebut, walaupun salah satu daripada mereka adalah 0, Val akan menjadi 0; Jika Val masih 1 dan (N / Midpoints) atau (bilangan simpang) adalah lebih daripada dua (untuk poligon minimum) hasil cetak dan kembali benar; kaedah mencetak sisi dalam poligon atau cetak tidak mungkin sekiranya tidak mungkin poligon; had untuk melelehkan pembahagi; Jika saya membahagikan n maka saya dan (n / i) akan menjadi pembahagi; Semak poligon untuk kedua -dua pembahagi; Kod pemacu", "code": "< ? php function checkPolygonWithMidpoints ( $ arr , $ N , $ midpoints ) { for ( $ j = 0 ; $ j < $ midpoints ; $ j ++ ) { $ val = 1 ; for ( $ k = $ j ; $ k < $ N ; $ k += $ midpoints ) { $ val &= $ arr [ $ k ] ; } if ( $ val && $ N / $ midpoints > 2 ) { echo \" Polygon ▁ possible ▁ with ▁ side ▁ length ▁ \" , ( $ N / $ midpoints ) , \" STRNEWLINE \" ; return true ; } } return false ; } function isPolygonPossible ( $ arr , $ N ) { $ limit = sqrt ( $ N ) ; for ( $ i = 1 ; $ i <= $ limit ; $ i ++ ) { if ( $ N % $ i == 0 ) { if ( checkPolygonWithMidpoints ( $ arr , $ N , $ i ) || checkPolygonWithMidpoints ( $ arr , $ N , ( $ N / $ i ) ) ) return ; } } echo \" Not ▁ possiblen \" ; } $ arr = array ( 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ) ; $ N = sizeof ( $ arr ) ; isPolygonPossible ( $ arr , $ N ) ; ? >"}
{"text": "Ketinggian maksimum apabila duit syiling disusun dalam segitiga | Mengembalikan akar kuadrat n. Perhatikan bahawa fungsi itu; Kami menggunakan N sendiri sebagai penghampiran awal ini pasti dapat diperbaiki; E memutuskan tahap ketepatan; Kaedah untuk mencari ketinggian maksimum susunan duit syiling; mengira bahagian di dalam akar persegi; Kod pemacu untuk menguji kaedah di atas", "code": "< ? php function squareRoot ( $ n ) { $ x = $ n ; $ y = 1 ; $ e = 0.000001 ; while ( $ x - $ y > $ e ) { $ x = ( $ x + $ y ) / 2 ; $ y = $ n / $ x ; } return $ x ; } function findMaximumHeight ( $ N ) { $ n = 1 + 8 * $ N ; $ maxH = ( -1 + squareRoot ( $ n ) ) / 2 ; return floor ( $ maxH ) ; } $ N = 12 ; echo findMaximumHeight ( $ N ) ; ? >"}
{"text": "Masalah Saham Saham | Mengisi array s [] dengan nilai span; Nilai span hari pertama sentiasa 1; Hitung nilai span hari yang tinggal dengan memeriksa secara linear hari sebelumnya; Memulakan nilai span; Traverse kiri manakala elemen seterusnya di sebelah kiri adalah lebih kecil daripada harga [i]; Cetak nilai span yang dikira; Kod pemacu; Isi nilai rentang dalam array s []", "code": "< ? php function calculateSpan ( $ price , $ n , $ S ) { $ S [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ S [ $ i ] = 1 ; for ( $ j = $ i - 1 ; ( $ j >= 0 ) && ( $ price [ $ i ] >= $ price [ $ j ] ) ; $ j -- ) $ S [ $ i ] ++ ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ S [ $ i ] . \" ▁ \" ; ; } $ price = array ( 10 , 4 , 5 , 90 , 120 , 80 ) ; $ n = count ( $ price ) ; $ S = array ( $ n ) ; calculateSpan ( $ price , $ n , $ S ) ; ? >"}
{"text": "Elemen yang lebih besar seterusnya | Cetak elemen dan pasangan NGE untuk semua elemen arr [] saiz n; Kod pemacu", "code": "< ? php function printNGE ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ next = -1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) { $ next = $ arr [ $ j ] ; break ; } } echo $ arr [ $ i ] . \" -- \" . ▁ $ next . \" \" } } $ arr = array ( 11 , 13 , 21 , 3 ) ; $ n = count ( $ arr ) ; printNGE ( $ arr , $ n ) ; ? >"}
{"text": "Program untuk Menara Hanoi | Menara algoritma Hanoi (N - disk) dalam PHP dengan paparan tiang / batang kandungan perwakilan 3 tiang; Bilangan cakera; A, B dan C adalah nama batang", "code": "< ? php $ poles = array ( array ( ) , array ( ) , array ( ) ) ; function TOH ( $ n , $ A = \" A \" , $ B = \" B \" , $ C = \" C \" ) { if ( $ n > 0 ) { TOH ( $ n - 1 , $ A , $ C , $ B ) ; echo \" Move ▁ disk ▁ from ▁ rod ▁ $ A ▁ to ▁ rod ▁ $ C ▁ STRNEWLINE \" ; move ( $ A , $ C ) ; dispPoles ( ) ; TOH ( $ n - 1 , $ B , $ A , $ C ) ; } else { return ; } } function initPoles ( $ n ) { global $ poles ; for ( $ i = $ n ; $ i >= 1 ; -- $ i ) { $ poles [ 0 ] [ ] = $ i ; } } function move ( $ source , $ destination ) { global $ poles ; if ( $ source == \" A \" ) $ ptr1 = 0 ; elseif ( $ source == \" B \" ) $ ptr1 = 1 ; else $ ptr1 = 2 ; if ( $ destination == \" A \" ) $ ptr2 = 0 ; elseif ( $ destination == \" B \" ) $ ptr2 = 1 ; else $ ptr2 = 2 ; $ top = array_pop ( $ poles [ $ ptr1 ] ) ; array_push ( $ poles [ $ ptr2 ] , $ top ) ; } function dispPoles ( ) { global $ poles ; echo \" A : ▁ [ \" . implode ( \" , ▁ \" , $ poles [ 0 ] ) . \" ] ▁ \" ; echo \" B : ▁ [ \" . implode ( \" , ▁ \" , $ poles [ 1 ] ) . \" ] ▁ \" ; echo \" C : ▁ [ \" . implode ( \" , ▁ \" , $ poles [ 2 ] ) . \" ] ▁ \" ; echo \" STRNEWLINE STRNEWLINE \" ; } $ numdisks = 4 ; initPoles ( $ numdisks ) ; echo \" Tower ▁ of ▁ Hanoi ▁ Solution ▁ for ▁ $ numdisks ▁ disks : ▁ STRNEWLINE STRNEWLINE \" ; dispPoles ( ) ; TOH ( $ numdisks ) ; ? >"}
{"text": "Cari maksimum minimum untuk setiap saiz tetingkap dalam array yang diberikan | Program PHP untuk mencari maksimum minimum semua tingkap kaedah saiz yang berbeza untuk mencari maksimum minimum semua tingkap saiz yang berbeza; Pertimbangkan semua tingkap saiz yang berbeza bermula dari saiz 1; Memulakan maksimum min untuk saiz tetingkap semasa k; Melintasi semua tingkap saiz semasa k; Cari minimum tetingkap semasa; Kemas kini maxofmin jika diperlukan; Cetak maksimum min untuk saiz tetingkap semasa; Kod pemacu", "code": "< ? php function printMaxOfMin ( $ arr , $ n ) { for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) { $ maxOfMin = PHP_INT_MIN ; for ( $ i = 0 ; $ i <= $ n - $ k ; $ i ++ ) { $ min = $ arr [ $ i ] ; for ( $ j = 1 ; $ j < $ k ; $ j ++ ) { if ( $ arr [ $ i + $ j ] < $ min ) $ min = $ arr [ $ i + $ j ] ; } if ( $ min > $ maxOfMin ) $ maxOfMin = $ min ; } echo $ maxOfMin , \" \" ; } } $ arr = array ( 10 , 20 , 30 , 50 , 10 , 70 , 30 ) ; $ n = sizeof ( $ arr ) ; printMaxOfMin ( $ arr , $ n ) ; ? >"}
{"text": "Balikkan nombor menggunakan stack | Tumpukan untuk mengekalkan urutan digit; Berfungsi untuk menolak digit ke dalam timbunan; Berfungsi untuk membalikkan nombor; Fungsi panggilan untuk menolak nombor nombor untuk disusun; Muncul digit dan membentuk nombor terbalik; Mengembalikan nombor terbalik yang terbentuk; Kod pemacu; Fungsi panggilan untuk membalikkan nombor", "code": "< ? php $ st = array ( ) ; function push_digits ( $ number ) { global $ st ; while ( $ number != 0 ) { array_push ( $ st , $ number % 10 ) ; $ number = ( int ) ( $ number / 10 ) ; } } function reverse_number ( $ number ) { global $ st ; push_digits ( $ number ) ; $ reverse = 0 ; $ i = 1 ; while ( ! empty ( $ st ) ) { $ reverse = $ reverse + ( $ st [ count ( $ st ) - 1 ] * $ i ) ; array_pop ( $ st ) ; $ i = $ i * 10 ; } return $ reverse ; } $ number = 39997 ; echo reverse_number ( $ number ) ; ? >"}
{"text": "Heapsort | Untuk mengakhiri subtree yang berakar dengan nod I yang merupakan indeks dalam arr []. n adalah saiz timbunan; Memulakan terbesar sebagai akar; kiri = 2 * i + 1; betul = 2 * i + 2; Jika anak kiri lebih besar daripada akar; Jika anak yang betul lebih besar daripada yang terbesar setakat ini; Jika terbesar tidak akar; Secara rekursif mengendalikan sub -pokok yang terjejas; fungsi utama untuk melakukan jenis timbunan; Membina timbunan (menyusun semula array); Satu demi satu mengekstrak elemen dari timbunan; Gerakkan akar semasa ke akhir; Hubungi Max Heave pada timbunan yang dikurangkan; Fungsi utiliti untuk mencetak pelbagai saiz n; Program Pemandu", "code": "< ? php function heapify ( & $ arr , $ n , $ i ) { $ largest = $ i ; $ l = 2 * $ i + 1 ; $ r = 2 * $ i + 2 ; if ( $ l < $ n && $ arr [ $ l ] > $ arr [ $ largest ] ) $ largest = $ l ; if ( $ r < $ n && $ arr [ $ r ] > $ arr [ $ largest ] ) $ largest = $ r ; if ( $ largest != $ i ) { $ swap = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ largest ] ; $ arr [ $ largest ] = $ swap ; heapify ( $ arr , $ n , $ largest ) ; } } function heapSort ( & $ arr , $ n ) { for ( $ i = $ n / 2 - 1 ; $ i >= 0 ; $ i -- ) heapify ( $ arr , $ n , $ i ) ; for ( $ i = $ n - 1 ; $ i > 0 ; $ i -- ) { $ temp = $ arr [ 0 ] ; $ arr [ 0 ] = $ arr [ $ i ] ; $ arr [ $ i ] = $ temp ; heapify ( $ arr , $ i , 0 ) ; } } function printArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) echo ( $ arr [ $ i ] . \" ▁ \" ) ; } $ arr = array ( 12 , 11 , 13 , 5 , 6 , 7 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; heapSort ( $ arr , $ n ) ; echo ' Sorted array is ' . \" STRNEWLINE \" ; printArray ( $ arr , $ n ) ; ? >"}
{"text": "Bagaimana untuk memeriksa sama ada array yang diberikan mewakili timbunan binari? | Pulangan benar jika arr [i. . n - 1] mewakili maksimum - timbunan; Jika nod daun; Jika nod dalaman dan lebih besar daripada anak -anaknya, dan sama adalah benar untuk kanak -kanak; Kod pemacu", "code": "< ? php function isHeap ( $ arr , $ i , $ n ) { if ( $ i >= ( $ n - 2 ) / 2 ) return true ; if ( $ arr [ $ i ] >= $ arr [ 2 * $ i + 1 ] && $ arr [ $ i ] >= $ arr [ 2 * $ i + 2 ] && isHeap ( $ arr , 2 * $ i + 1 , $ n ) && isHeap ( $ arr , 2 * $ i + 2 , $ n ) ) return true ; return false ; } $ arr = array ( 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ) ; $ n = sizeof ( $ arr ) ; if ( isHeap ( $ arr , 0 , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Bagaimana untuk memeriksa sama ada array yang diberikan mewakili timbunan binari? | Pulangan benar jika arr [i. . n - 1] mewakili maksimum - timbunan; Mulakan dari akar dan pergi sehingga nod dalaman terakhir; Jika anak kiri lebih besar, kembali palsu; Jika anak yang betul lebih besar, kembali palsu; Kod pemacu", "code": "< ? php function isHeap ( $ arr , $ i , $ n ) { for ( $ i = 0 ; $ i < ( ( $ n - 2 ) / 2 ) + 1 ; $ i ++ ) { if ( $ arr [ 2 * $ i + 1 ] > $ arr [ $ i ] ) return False ; if ( 2 * $ i + 2 < $ n && $ arr [ 2 * $ i + 2 ] > $ arr [ $ i ] ) return False ; return True ; } } $ arr = array ( 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ) ; $ n = sizeof ( $ arr ) ; if ( isHeap ( $ arr , 0 , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Kekurangan urutan terkecil | Program PHP yang cekap untuk mencari kegelisahan terkecil. ; Menjana urutan s; Menjana gangguan; Hanya jika saya adalah swap ganjil S [n - 1] dan S [n]; Cetak derangement; Program Pemandu", "code": "< ? php function generate_derangement ( $ N ) { $ S = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ S [ $ i ] = $ i ; $ D = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i += 2 ) { if ( $ i == $ N ) { $ D [ $ N ] = $ S [ $ N - 1 ] ; $ D [ $ N - 1 ] = $ S [ $ N ] ; } else { $ D [ $ i ] = $ i + 1 ; $ D [ $ i + 1 ] = $ i ; } } for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ D [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } generate_derangement ( 10 ) ; ? >"}
{"text": "Program untuk mengira keuntungan atau kerugian | Berfungsi untuk mengira keuntungan. ; Fungsi untuk mengira kerugian. ; Kod pemacu.", "code": "< ? php function Profit ( $ costPrice , $ sellingPrice ) { $ profit = ( $ sellingPrice - $ costPrice ) ; return $ profit ; } function Loss ( $ costPrice , $ sellingPrice ) { $ Loss = ( $ costPrice - $ sellingPrice ) ; return $ Loss ; } $ costPrice = 1500 ; $ sellingPrice = 2000 ; if ( $ sellingPrice == $ costPrice ) echo \" No ▁ profit ▁ nor ▁ Loss \" ; else if ( $ sellingPrice > $ costPrice ) echo Profit ( $ costPrice , $ sellingPrice ) . \" ▁ Profit ▁ \" ; else echo Loss ( $ costPrice , $ sellingPrice ) . \" ▁ Loss ▁ \" ; ? >"}
{"text": "Cari persegi sempurna seterusnya lebih besar daripada nombor tertentu | Berfungsi untuk mencari persegi sempurna seterusnya; Kod pemacu", "code": "< ? php function nextPerfectSquare ( $ N ) { $ nextN = floor ( sqrt ( $ N ) ) + 1 ; return $ nextN * $ nextN ; } $ n = 35 ; echo nextPerfectSquare ( $ n ) ; ? >"}
{"text": "Cetak semua substring nombor tanpa sebarang penukaran | Berfungsi untuk mencetak substrings nombor; Kirakan jumlah digit; 0.5 telah ditambah kerana ia akan mengembalikan nilai ganda seperti 99.556; Cetak semua nombor dari kedudukan permulaan; Kemas kini no. ; Kemas kini no. daripada digit; Kod pemacu", "code": "< ? php function printSubstrings ( $ n ) { $ s = ( int ) log10 ( $ n ) ; $ d = ( int ) ( pow ( 10 , $ s ) + 0.5 ) ; $ k = $ d ; while ( $ n ) { while ( $ d ) { echo ( int ) ( $ n / $ d ) . \" STRNEWLINE \" ; $ d = ( int ) ( $ d / 10 ) ; } $ n = $ n % $ k ; $ k = ( int ) ( $ k / 10 ) ; $ d = $ k ; } } $ n = 123 ; printSubstrings ( $ n ) ; ? >"}
{"text": "Kuasa Modulo untuk jumlah besar diwakili sebagai rentetan | Program PHP untuk mencari (A ^ B) mod % di mana A dan B mungkin sangat besar dan diwakili sebagai rentetan. ; Mengembalikan eksponensi Modulo untuk dua nombor yang diwakili sebagai int yang panjang. Ia digunakan oleh PowerStrings (). Kerumitannya adalah log (n); Mengembalikan eksponensi Modulo untuk dua nombor yang diwakili sebagai rentetan. Ia digunakan oleh PowerStrings (); Kami menukar rentetan ke nombor; mengira mod %; mengira B % (mod - 1); Sekarang A dan B sudah lama int. Kami mengira A ^ B menggunakan eksponensi modulo; Sebagai nombor yang sangat besar, ia mungkin mengandungi sehingga 10 ^ 6 digit. Jadi, kami menggunakan rentetan.", "code": "< ? php $ MOD = 1000000007 ; function powerLL ( $ x , $ n ) { global $ MOD ; $ result = 1 ; while ( $ n ) { if ( $ n & 1 ) $ result = $ result * $ x % $ MOD ; $ n = ( int ) $ n / 2 ; $ x = $ x * $ x % $ MOD ; } return $ result ; } function powerStrings ( $ sa , $ sb ) { global $ MOD ; $ a = 0 ; $ b = 0 ; for ( $ i = 0 ; $ i < strlen ( $ sa ) ; $ i ++ ) $ a = ( $ a * 10 + ( $ sa [ $ i ] - '0' ) ) % $ MOD ; for ( $ i = 0 ; $ i < strlen ( $ sb ) ; $ i ++ ) $ b = ( $ b * 10 + ( $ sb [ $ i ] - '0' ) ) % ( $ MOD - 1 ) ; return powerLL ( $ a , $ b ) ; } $ sa = \"2\" ; $ sb = \"3\" ; echo powerStrings ( $ sa , $ sb ) ; ? >"}
{"text": "Semak jika nombor boleh dinyatakan sebagai 2 ^ x + 2 ^ y | Fungsi utiliti untuk memeriksa sama ada nombor adalah kuasa 2 atau tidak; Fungsi utiliti untuk menentukan nilai kuasa sebelumnya 2; fungsi untuk memeriksa sama ada n boleh dinyatakan sebagai 2 ^ x + 2 ^ y atau tidak; Jika nilai n ialah 0 atau 1 ia tidak boleh dinyatakan sebagai 2 ^ x + 2 ^ y; Jika nombor adalah kuasa 2 maka ia boleh dinyatakan sebagai 2 ^ x + 2 ^ y; Jika selebihnya selepas menolak kuasa sebelumnya 2 juga kuasa 2 maka ia boleh dinyatakan sebagai 2 ^ x + 2 ^ y; Kod pemacu", "code": "< ? php function isPowerOfTwo ( $ n ) { return ( $ n and ! ( $ n & ( $ n - 1 ) ) ) ; } function previousPowerOfTwo ( $ n ) { while ( $ n & $ n - 1 ) { $ n = $ n & $ n - 1 ; } return $ n ; } function checkSum ( $ n ) { if ( $ n == 0 or $ n == 1 ) return false ; else if ( isPowerOfTwo ( $ n ) ) { echo \" \" ▁ , ▁ $ n ▁ / ▁ 2 ▁ , ▁ \" \" return true ; } else { $ x = previousPowerOfTwo ( $ n ) ; $ y = $ n - $ x ; if ( isPowerOfTwo ( $ y ) ) { echo $ x , \" \" , $ y ; return true ; } } return false ; } $ n1 = 20 ; if ( checkSum ( $ n1 ) == false ) echo \" No \" ; echo \" STRNEWLINE \" ; $ n2 = 11 ; if ( checkSum ( $ n2 ) == false ) echo \" No \" ; ? >"}
{"text": "Pelengkap nombor perpuluhan 10 | Berfungsi untuk mencari pelengkap 10; Mengira jumlah digit dalam NUM; pulihkan num; Kirakan pelengkap 10; Kod pemacu", "code": "< ? php function complement ( $ num ) { $ i ; $ len = 0 ; $ comp ; $ temp = $ num ; while ( 1 ) { $ len ++ ; $ num = ( int ) ( $ num / 10 ) ; if ( abs ( $ num ) == 0 ) break ; } $ num = $ temp ; $ comp = pow ( 10 , $ len ) - $ num ; return $ comp ; } echo complement ( 25 ) . \" STRNEWLINE \" ; echo complement ( 456 ) ; ? >"}
{"text": "Program untuk mencari HCF (faktor umum tertinggi) daripada 2 nombor | Fungsi rekursif untuk mengembalikan GCD A dan B; Semuanya membahagikan 0; Kes asas; A lebih besar; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 && $ b == 0 ) return 0 ; if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; } $ a = 98 ; $ b = 56 ; echo \" GCD ▁ of ▁ $ a ▁ and ▁ $ b ▁ is ▁ \" , gcd ( $ a , $ b ) ; ? >"}
{"text": "Jumlah semua elemen sehingga baris nth dalam segitiga Pascal | Berfungsi untuk mencari jumlah semua elemen sehingga baris nth. ; Memulakan jumlah dengan 0; Gelung untuk mengira kuasa 2 sehingga n dan tambahkannya; Kod pemacu", "code": "< ? php function calculateSum ( $ n ) { $ sum = 0 ; for ( $ row = 0 ; $ row < $ n ; $ row ++ ) { $ sum = $ sum + ( 1 << $ row ) ; } return $ sum ; } $ n = 10 ; echo \" ▁ Sum ▁ of ▁ all ▁ elements ▁ : ▁ \" . calculateSum ( $ n ) ; ? >"}
{"text": "Bilangan urutan yang mempunyai kepala pada kedudukan alternatif di sebelah kanan kepala pertama | fungsi untuk mengira jumlah urutan yang mungkin; Nilai N adalah walaupun; Nilai N adalah ganjil; Kod pemacu", "code": "< ? php function findAllSequence ( $ N ) { if ( $ N % 2 == 0 ) { return pow ( 2 , $ N / 2 + 1 ) + pow ( 2 , $ N / 2 ) - 2 ; } else { return pow ( 2 , ( $ N + 1 ) / 2 ) + pow ( 2 , ( $ N + 1 ) / 2 ) - 2 ; } } $ N = 2 ; echo findAllSequence ( $ N ) ; ? >"}
{"text": "Bilangan orang dalam repunit terkecil | Berfungsi untuk mencari bilangan 1 s dalam repunit terkecil pelbagai nombor; Untuk menyimpan nombor 1 s dalam pelbagai repunit terkecil nombor. ; memulakan REM dengan 1; Jalankan gelung sehingga REM menjadi sifar; Rem * 10 + 1 di sini mewakili modulo repunit n; Apabila baki menjadi 0 kiraan kembali; Kod pemacu; Fungsi panggilan", "code": "< ? php function countOnes ( $ n ) { $ count = 1 ; $ rem = 1 ; while ( $ rem != 0 ) { $ rem = ( $ rem * 10 + 1 ) % $ n ; $ count ++ ; } return $ count ; } $ n = 13 ; echo countOnes ( $ n ) ; ? >"}
{"text": "Terbesar dua nombor yang berbeza tanpa menggunakan sebarang penyataan atau pengendali bersyarat | Berfungsi untuk mencari nombor terbesar; Kod pemandu", "code": "< ? php function largestNum ( $ a , $ b ) { return ( $ a * ( boolean ) floor ( ( $ a / $ b ) ) ) + ( $ b * ( boolean ) floor ( ( $ b / $ a ) ) ) ; } $ a = 22 ; $ b = 1231 ; echo ( largestNum ( $ a , $ b ) ) ;"}
{"text": "Bilangan titik mesyuarat yang berbeza di jalan bulat | Mengembalikan GCD dua nombor. ; Mengembalikan bilangan mata mesyuarat yang berbeza. ; Cari kelajuan relatif. ; Tukar nilai negatif kepada positif. ; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { $ c = $ a % $ b ; while ( $ c != 0 ) { $ a = $ b ; $ b = $ c ; $ c = $ a % $ b ; } return $ b ; } function numberOfmeet ( $ a , $ b ) { $ ans ; if ( $ a > $ b ) $ ans = $ a - $ b ; else $ ans = $ b - $ a ; if ( $ a < 0 ) $ a = $ a * ( -1 ) ; if ( $ b < 0 ) $ b = $ b * ( -1 ) ; return $ ans / gcd ( $ a , $ b ) ; } $ a = 1 ; $ b = -1 ; echo numberOfmeet ( $ a , $ b ) . \" STRNEWLINE \" ; ? >"}
{"text": "Cari lebih besar daripada x ^ y dan y ^ x | Program php untuk mencetak lebih besar daripada x ^ y dan y ^ x; Kod pemacu", "code": "< ? php function printGreater ( $ x , $ y ) { $ X = $ y * log ( $ x ) ; $ Y = $ x * log ( $ y ) ; if ( abs ( $ X - $ Y ) < 1e-9 ) { echo \" Equal \" ; } else if ( $ X > $ Y ) { echo $ x . \" ^ \" . $ y ; } else { echo $ y . \" ^ \" . $ x ; } } $ x = 5 ; $ y = 8 ; printGreater ( $ x , $ y ) ; ? >"}
{"text": "N | Fungsi untuk mencari istilah n; Kod pemacu", "code": "< ? php function sumOfSeries ( $ n ) { return $ n * ( $ n + 1 ) * ( 6 * $ n * $ n * $ n + 9 * $ n * $ n + $ n - 1 ) / 30 ; } $ n = 4 ; echo sumOfSeries ( $ n ) ; ? >"}
{"text": "Produk Factorial N First | Untuk mengira (a * b) mod %; $ res = 0; Memulakan hasil; Jika B adalah ganjil, tambah 'A' untuk menghasilkan; Multiply 'a' dengan 2; Bahagikan B dengan 2; Hasil pulangan; Fungsi ini mengira faktorial dan produk dengan menggunakan fungsi di atas i. e. pendaraban modular; Memulakan produk dan fakta dengan 1; ith factorial; produk faktorial pertama saya; Jika pada mana -mana lelaran, produk menjadi dibahagikan dengan mod, hanya kembali 0; ; Kod pemacu", "code": "< ? php function mulmod ( $ a , $ b , $ mod ) { $ a = $ a % $ mod ; while ( $ b > 0 ) { if ( $ b % 2 == 1 ) $ res = ( $ res + $ a ) % $ mod ; $ a = ( $ a * 2 ) % $ mod ; $ b /= 2 ; } return $ res % $ mod ; } function findProduct ( $ N ) { $ product = 1 ; $ fact = 1 ; $ MOD = 1000000000 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ fact = mulmod ( $ fact , $ i , $ MOD ) ; $ product = mulmod ( $ product , $ fact , $ MOD ) ; if ( $ product == 0 ) return 0 ; } return $ product ; } $ N = 3 ; echo findProduct ( $ N ) , \" STRNEWLINE \" ; $ N = 5 ; echo findProduct ( $ N ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika jumlah pembahagi dua nombor adalah sama | Fungsi untuk mengira jumlah semua pembahagi yang betul Num -> diberi nombor semulajadi; Untuk menyimpan jumlah pembahagi; Cari semua pembahagi dan tambahkannya; Fungsi untuk memeriksa sama ada kedua -dua nombor bersamaan atau tidak; Kod pemacu", "code": "< ? php function divSum ( $ n ) { $ sum = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ sum = $ sum + $ i + floor ( $ n / $ i ) ; return $ sum ; } function areEquivalent ( $ num1 , $ num2 ) { return divSum ( $ num1 ) == divSum ( $ num2 ) ; } $ num1 = 559 ; $ num2 = 703 ; if ( areEquivalent ( $ num1 , $ num2 ) == true ) echo \" Equivalent \" ; else echo \" Not ▁ Equivalent \" ; ? >"}
{"text": "Nombor Dodecahedral | Berfungsi untuk mencari nombor dodecahedral; Formula untuk mengira nombor dodecahedral n dan mengembalikannya ke dalam fungsi utama. ; Kod pemacu; hasil cetak", "code": "< ? php function dodecahedral_num ( $ n ) { return $ n * ( 3 * $ n - 1 ) * ( 3 * $ n - 2 ) / 2 ; } $ n = 5 ; echo $ n , \" th ▁ Dodecahedral ▁ number : ▁ \" ; echo dodecahedral_num ( $ n ) ; ? >"}
{"text": "Count of Divisors yang mempunyai lebih banyak bit set daripada quotient pada pembahagian n | Kembalikan kiraan set bit. ; Semak jika Q dan D mempunyai bilangan bit yang sama. ; Carian binari untuk mencari titik di mana bilangan set dalam Q kurang daripada atau sama dengan d. ; Walaupun indeks kiri kurang daripada indeks kanan; Mencari tengah. ; Semak sama ada Q dan D mempunyai bilangan yang sama atau tidak. ; Kod pemacu", "code": "< ? php function bit ( $ x ) { $ ans = 0 ; while ( $ x ) { $ x /= 2 ; $ ans ++ ; } return $ ans ; } function check ( $ d , $ x ) { if ( bit ( $ x / $ d ) <= bit ( $ d ) ) return true ; return false ; } function bs ( int $ n ) { $ l = 1 ; $ r = sqrt ( $ n ) ; while ( $ l < $ r ) { $ m = ( $ l + $ r ) / 2 ; if ( check ( $ m , $ n ) ) $ r = $ m ; else $ l = $ m + 1 ; } if ( ! check ( $ l , $ n ) ) return floor ( $ l + 1 ) ; else return floor ( $ l ) ; } function countDivisor ( $ n ) { return $ n - bs ( $ n ) + 1 ; } $ n = 5 ; echo countDivisor ( $ n ) ; ? >"}
{"text": "Semak jika dua orang bermula dari pelbagai mata yang pernah bertemu | Program PHP untuk mencari jika dua orang bermula dari kedudukan yang berbeza pernah bertemu atau tidak. ; Jika kelajuan seseorang berada di kedudukan sebelum orang lain lebih kecil, maka kembali palsu. ; Memastikan bahawa X1 lebih besar; Sehingga satu orang melintasi yang lain; Orang pertama mengambil satu lompatan dalam setiap lelaran; Orang kedua mengambil satu lompatan dalam setiap lelaran; Kod pemacu", "code": "< ? php function everMeet ( $ x1 , $ x2 , $ v1 , $ v2 ) { if ( $ x1 < $ x2 && $ v1 <= $ v2 ) return false ; if ( $ x1 > $ x2 && $ v1 >= $ v2 ) return false ; if ( $ x1 < $ x2 ) { list ( $ x1 , $ x2 ) = array ( $ x2 , $ x1 ) ; list ( $ v1 , $ v2 ) = array ( $ v2 , $ v1 ) ; } while ( $ x1 >= $ x2 ) { if ( $ x1 == $ x2 ) return true ; $ x1 = $ x1 + $ v1 ; $ x2 = $ x2 + $ v2 ; } return false ; } $ x1 = 5 ; $ v1 = 8 ; $ x2 = 4 ; $ v2 = 7 ; if ( everMeet ( $ x1 , $ x2 , $ v1 , $ v2 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Divisi oleh 3 di mana setiap digit adalah jumlah semua angka awalan modulo 10 | Berfungsi untuk memeriksa pembahagian; Kitaran; tidak ada istilah sisa; Jumlah istilah sisa; jika tiada istilah residu = 0; jika tiada istilah residu = 1; jika tiada istilah residu = 2; jika tiada istilah residu = 3; Jumlah semua digit; pemeriksaan pembahagian; Kod pemacu", "code": "< ? php function check ( $ k , $ d0 , $ d1 ) { $ s = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 + ( 8 * ( $ d0 + $ d1 ) ) % 10 + ( 6 * ( $ d0 + $ d1 ) ) % 10 ; $ a = ( $ k - 3 ) % 4 ; $ x ; switch ( $ a ) { case 0 : $ x = 0 ; break ; case 1 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 ; break ; case 2 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 ; break ; case 3 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 + ( 8 * ( $ d0 + $ d1 ) ) % 10 ; break ; } $ sum = $ d0 + $ d1 + ( int ) ( ( $ k - 3 ) / 4 ) * $ s + $ x ; if ( $ sum % 3 == 0 ) return \" YES \" ; return \" NO \" ; } $ k ; $ d0 ; $ d1 ; $ k = 13 ; $ d0 = 8 ; $ d1 = 1 ; echo check ( $ k , $ d0 , $ d1 ) , \" STRNEWLINE \" ; $ k = 5 ; $ d0 = 3 ; $ d1 = 4 ; echo check ( $ k , $ d0 , $ d1 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari Ceil of A / B tanpa menggunakan fungsi Ceil () | mengambil input 1; Contoh bahagian yang sempurna mengambil input 2", "code": "< ? php $ a = 4 ; $ b = 3 ; $ val = ( $ a / $ b ) + ( ( $ a % $ b ) != 0 ) ; echo \" The ▁ ceiling ▁ value ▁ of ▁ 4/3 ▁ is ▁ \" , floor ( $ val ) , \" STRNEWLINE \" ; $ a = 6 ; $ b = 3 ; $ val = ( $ a / $ b ) + ( ( $ a % $ b ) != 0 ) ; echo \" The ▁ ceiling ▁ value ▁ of ▁ 6/3 ▁ is ▁ \" , $ val ; ? >"}
{"text": "Program untuk mencetak urutan collatz | Program PHP untuk mencetak urutan Collatz; Kami hanya mengikuti langkah -langkah semasa kami tidak mencapai 1; Jika $ n adalah ganjil; Jika walaupun; Cetak 1 pada akhir; Kod pemacu", "code": "< ? php function printCollatz ( $ n ) { while ( $ n != 1 ) { echo $ n . \" \" ; if ( $ n & 1 ) $ n = 3 * $ n + 1 ; else $ n = $ n / 2 ; } echo $ n ; } printCollatz ( 6 ) ; ? >"}
{"text": "Kuasa 2 hingga Jumlah yang Diperlukan | Program PHP untuk mencari blok untuk nombor tertentu. ; Menukar nombor perpuluhan kepada setara binari; Memaparkan output apabila bit adalah '1' dalam setara bilangan binari. ; Kod pemacu", "code": "< ? php function block ( $ x ) { $ v = array ( ) ; echo ' locks for ' . $ x . ' ▁ : ▁ ' ; while ( $ x > 0 ) { array_push ( $ v , intval ( $ x % 2 ) ) ; $ x = intval ( $ x / 2 ) ; } for ( $ i = 0 ; $ i < sizeof ( $ v ) ; $ i ++ ) { if ( $ v [ $ i ] == 1 ) { print $ i ; if ( $ i != sizeof ( $ v ) - 1 ) echo ' , ▁ ' ; } } echo \" STRNEWLINE \" ; } block ( 71307 ) ; block ( 1213 ) ; block ( 29 ) ; block ( 100 ) ; ? >"}
{"text": "Memandangkan nombor n dalam asas perpuluhan, cari nombor digitnya di mana -mana asas (asas b) | berfungsi untuk mencetak bilangan digit; Mengira log menggunakan asas menukar harta dan kemudian mengambil lantai dan kemudian menambah 1 .; output percetakan; mengambil input; Memanggil kaedah", "code": "< ? php function findNumberOfDigits ( $ n , $ b ) { $ dig = ( int ) ( floor ( log ( $ n ) / log ( $ b ) ) + 1 ) ; echo ( \" The ▁ Number ▁ of ▁ digits \" . \" ▁ of ▁ Number ▁ \" . $ n . \" ▁ in ▁ base ▁ \" . $ b . \" ▁ is ▁ \" . $ dig ) ; } $ n = 1446 ; $ b = 7 ; findNumberOfDigits ( $ n , $ b ) ; ? >"}
{"text": "Ketidaksamaan Nesbitt | Kod PHP untuk mengesahkan ketidaksamaan Nesbitt; 3 bahagian jumlah ketidaksamaan; Kod pemacu", "code": "< ? php function isValidNesbitt ( $ a , $ b , $ c ) { $ A = $ a / ( $ b + $ c ) ; $ B = $ b / ( $ a + $ c ) ; $ C = $ c / ( $ a + $ b ) ; $ inequality = $ A + $ B + $ C ; return ( $ inequality >= 1.5 ) ; } $ a = 1.0 ; $ b = 2.0 ; $ c = 3.0 ; if ( isValidNesbitt ( $ a , $ b , $ c ) ) echo \" Nesbitt ' s ▁ inequality ▁ satisfied . \" , \" for ▁ real ▁ numbers ▁ \" , $ a , \" , ▁ \" , $ b , \" , ▁ \" , $ c , \" STRNEWLINE \" ; else cout << \" Not ▁ satisfied \" ; ? >"}
{"text": "Nombor bebas kiub lebih kecil daripada n | Program PHP yang cekap untuk mencetak semua nombor bebas kiub lebih kecil daripada atau sama dengan n. ; Memulakan semua nombor sebagai tidak kiub percuma; Melintasi semua akar kiub yang mungkin; Jika saya sendiri adalah kiub percuma; Tandakan semua gandaan saya sebagai bukan kiub percuma; Cetak semua nombor percuma kiub; Kod pemacu", "code": "< ? php function printCubeFree ( $ n ) { $ cubFree = array_fill ( 0 , ( $ n + 1 ) , 1 ) ; $ i = 2 ; while ( $ i * $ i * $ i <= $ n ) { if ( $ cubFree [ $ i ] == 1 ) { $ multiple = 1 ; while ( $ i * $ i * $ i * $ multiple <= $ n ) { $ cubFree [ $ i * $ i * $ i * $ multiple ] = 0 ; $ multiple += 1 ; } } $ i += 1 ; } for ( $ i = 2 ; $ i < $ n + 1 ; $ i ++ ) if ( $ cubFree [ $ i ] == 1 ) echo $ i . \" \" ; } printCubeFree ( 20 ) ; ? >"}
{"text": "Nombor segi tiga kuadrat (jumlah kiub) | Pulangan akar n (n + 1) / 2 = num jika num adalah segi tiga (atau integerroot wujud). Lain kembali - 1 .; Memandangkan persamaan n * (n + 1) / 2 = num. Persamaannya ialah: a (n ^ 2) + bn + c = 0 \";; cari akar persamaan; memeriksa jika root1 adalah semula jadi; memeriksa jika root2 adalah semulajadi; pulangan akar persegi x jika ia sempurna persegi.", "code": "< ? php function isTriangular ( $ num ) { if ( $ num < 0 ) return false ; $ c = ( -2 * $ num ) ; $ b = 1 ; $ a = 1 ; $ d = ( $ b * $ b ) - ( 4 * $ a * $ c ) ; if ( $ d < 0 ) return -1 ; $ root1 = ( - $ b + sqrt ( $ d ) ) / ( 2 * $ a ) ; $ root2 = ( - $ b - sqrt ( $ d ) ) / ( 2 * $ a ) ; if ( $ root1 > 0 && floor ( $ root1 ) == $ root1 ) return $ root1 ; if ( $ root2 > 0 && floor ( $ root2 ) == $ root2 ) return $ root2 ; return -1 ; } function isPerfectSquare ( $ x ) { $ sr = sqrt ( $ x ) ; if ( ( $ sr - floor ( $ sr ) ) == 0 ) return floor ( $ sr ) ; else return -1 ; } function findS ( $ s ) { $ sr = isPerfectSquare ( $ s ) ; if ( $ sr == -1 ) return -1 ; return isTriangular ( $ sr ) ; } $ s = 9 ; $ n = findS ( $ s ) ; if ( $ n == -1 ) echo \" - 1\" ; else echo $ n ; ? >"}
{"text": "Terkecil walaupun nombor digit tidak kurang daripada n | berfungsi untuk mengembalikan jawapan apabila digit ganjil pertama adalah 9; Traverse Towwars kiri untuk mencari digit 8; indeks digit; Jika digit tidak 8, maka pecah; Jika di sebelah kiri '9', No 8 ditemui maka kami kembali dengan menambah 2 dan 0; Hingga bukan 8 digit tambahkan semua nombor; Jika bukan - 8 adalah atau ganjil daripada menambah yang seterusnya. ; tambah 0 ke kanan 9; berfungsi untuk mengembalikan nombor terkecil dengan semua digit walaupun; menukar nombor ke rentetan untuk melaksanakan operasi; cari nombor ganjil pertama; Jika tiada nombor ganjil yang ada, daripada n adalah jawapannya; Jika nombor ganjil adalah 9, daripada kes rumit mengendalikannya; Tambah semua digit hingga pertama ganjil; meningkatkan digit ganjil dengan 1; Tambah 0 di sebelah kanan nombor ganjil; Kod pemacu", "code": "< ? php function trickyCase ( $ s , $ index ) { $ index1 = -1 ; for ( $ i = $ index - 1 ; $ i >= 0 ; $ i -- ) { $ digit = $ s [ $ i ] - '0' ; if ( $ digit != 8 ) { $ index1 = $ i ; break ; } } if ( $ index1 == -1 ) return 2 * pow ( 10 , strlen ( $ s ) ) ; $ num = 0 ; for ( $ i = 0 ; $ i < $ index1 ; $ i ++ ) $ num = $ num * 10 + ( $ s [ $ i ] - '0' ) ; if ( $ s [ $ index1 ] % 2 == 0 ) $ num = $ num * 10 + ( $ s [ $ index1 ] - '0' + 2 ) ; else $ num = $ num * 10 + ( $ s [ $ index1 ] - '0' + 1 ) ; for ( $ i = $ index1 + 1 ; $ i < strlen ( $ s ) ; $ i ++ ) $ num = $ num * 10 ; return $ num ; } function smallestNumber ( $ n ) { $ num = 0 ; $ s = \" \" ; $ duplicate = $ n ; while ( $ n ) { $ s = chr ( $ n % 10 + 48 ) . $ s ; $ n = ( int ) ( $ n / 10 ) ; } $ index = -1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ digit = $ s [ $ i ] - '0' ; if ( $ digit & 1 ) { $ index = $ i ; break ; } } if ( $ index == -1 ) return $ duplicate ; if ( $ s [ $ index ] == '9' ) { $ num = trickyCase ( $ s , $ index ) ; return $ num ; } for ( $ i = 0 ; $ i < $ index ; $ i ++ ) $ num = $ num * 10 + ( $ s [ $ i ] - '0' ) ; $ num = $ num * 10 + ( $ s [ $ index ] - '0' + 1 ) ; for ( $ i = $ index + 1 ; $ i < strlen ( $ s ) ; $ i ++ ) $ num = $ num * 10 ; return $ num ; } $ N = 2397 ; echo smallestNumber ( $ N ) ; ? >"}
{"text": "N | Program PHP mudah untuk mencari nombor n - dengan jumlah digit sebagai 10 .; Cari jumlah digit dalam no semasa. ; Jika jumlah adalah 10, kita kenaikan kiraan; Jika kiraan menjadi n, kami mengembalikan nombor semasa. ; Kod pemacu", "code": "< ? php function findNth ( $ n ) { $ count = 0 ; for ( $ curr = 19 ; ; $ curr += 9 ) { $ sum = 0 ; for ( $ x = $ curr ; $ x > 0 ; $ x = ( int ) $ x / 10 ) $ sum = $ sum + $ x % 10 ; if ( $ sum == 10 ) $ count ++ ; if ( $ count == $ n ) return $ curr ; } return -1 ; } echo findNth ( 5 ) ; ? >"}
{"text": "Jumlah Produk Pairwise | Program PHP mudah untuk mencari jumlah siri yang diberikan. ; Kod pemacu", "code": "< ? php function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = $ i ; $ j <= $ n ; $ j ++ ) $ sum = $ sum + $ i * $ j ; return $ sum ; } $ n = 5 ; echo findSum ( $ n ) ; ? >"}
{"text": "Jumlah Produk Pairwise | Program PHP yang cekap untuk mencari jumlah siri yang diberikan. ; Jumlah gandaan 1 adalah 1 * (1 + 2 +.); Menambah jumlah gandaan nombor selain daripada 1, bermula dari 2 .; Kurangkan nombor sebelumnya dari berbilang semasa. ; Sebagai contoh, untuk 2, kita mendapat jumlah sebagai (2 + 3 + 4 + ....) * 2; Kod pemacu", "code": "< ? php function findSum ( $ n ) { $ multiTerms = ( int ) ( $ n * ( $ n + 1 ) / 2 ) ; $ sum = $ multiTerms ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ multiTerms = $ multiTerms - ( $ i - 1 ) ; $ sum = $ sum + $ multiTerms * $ i ; } return $ sum ; } $ n = 5 ; echo findSum ( $ n ) ; ? >"}
{"text": "Jumlah nombor digit N dibahagi dengan nombor tertentu | Cari jumlah yang mempunyai digit dan dibahagikan dengan nombor; Kirakan istilah pertama dan terakhir; Nombor pertama yang boleh dibahagikan dengan nombor tertentu; nombor terakhir yang boleh dibahagikan dengan nombor tertentu; jumlah bilangan yang boleh dibahagi; mengembalikan jumlah keseluruhan; Kod pemacu", "code": "< ? php function totalSumDivisibleByNum ( $ digit , $ number ) { $ firstnum = pow ( 10 , $ digit - 1 ) ; $ lastnum = pow ( 10 , $ digit ) ; $ firstnum = ( $ firstnum - $ firstnum % $ number ) + $ number ; $ lastnum = ( $ lastnum - $ lastnum % $ number ) ; $ count = ( ( $ lastnum - $ firstnum ) / $ number + 1 ) ; return ( ( $ lastnum + $ firstnum ) * $ count ) / 2 ; } $ n = 3 ; $ number = 7 ; echo totalSumDivisibleByNum ( $ n , $ number ) ; ? >"}
{"text": "Program untuk n | Program PHP untuk mencari istilah perkembangan aritmetik; menggunakan formula untuk mencari istilah n (n) = a (1) + (n - 1) * d; nombor permulaan; Perbezaan umum; Istilah n untuk mencari; Paparkan output", "code": "< ? php function Nth_of_AP ( $ a , $ d , $ N ) { return ( $ a + ( $ N - 1 ) * $ d ) ; } $ a = 2 ; $ d = 1 ; $ N = 5 ; echo ( \" The ▁ \" . $ N . \" th ▁ term ▁ of ▁ the ▁ series ▁ is ▁ : ▁ \" . Nth_of_AP ( $ a , $ d , $ N ) ) ; ? >"}
{"text": "Nombor Fibbinary (tidak berturut -turut 1 s dalam binari) | fungsi untuk memeriksa sama ada perwakilan binari integer mempunyai 1 s berturut -turut; menyimpan bit terakhir sebelum ini sebagai 0; Jika bit terakhir dan bit terakhir sebelumnya ialah 1; menyimpan bit terakhir; Pergeseran kanan nombor; Kod pemacu", "code": "< ? php function checkFibinnary ( $ n ) { $ prev_last = 0 ; while ( $ n ) { if ( ( $ n & 1 ) && $ prev_last ) return false ; $ prev_last = $ n & 1 ; $ n >>= 1 ; } return true ; } $ n = 10 ; if ( checkFibinnary ( $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Jumlah siri 5 + 55 + 555 +. . Sehingga N Syarat | fungsi yang mengembalikan jumlah siri; Kod pemacu", "code": "< ? php function sumOfSeries ( $ n ) { return ( int ) ( 0.6172 * ( pow ( 10 , $ n ) - 1 ) - 0.55 * $ n ) ; } $ n = 2 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text": "Nombor Nonagonal | Berfungsi untuk mencari nombor nonagon nth. ; Formula untuk mencari nombor nonagon nth. ; Kod pemacu", "code": "< ? php function Nonagonal ( $ n ) { return $ n * ( 7 * $ n - 5 ) / 2 ; } $ n = 10 ; echo Nonagonal ( $ n ) ; ? >"}
{"text": "Semak jika sebilangan besar boleh dibahagikan dengan 20 | Program PHP untuk memeriksa sama ada sebilangan besar boleh dibahagikan dengan 20 .; Dapatkan nombor dengan dua digit terakhir; Semak sama ada nombor yang dibentuk oleh dua digit terakhir boleh dibahagikan dengan 5 dan 4 .; Kod pemacu", "code": "< ? php function divisibleBy20 ( $ num ) { $ lastTwoDigits = intval ( substr ( $ num , ( strlen ( $ num ) - 2 ) , 2 ) ) ; return ( ( $ lastTwoDigits % 5 == 0 ) && ( $ lastTwoDigits % 4 == 0 ) ) ; } $ num = \"63284689320\" ; if ( divisibleBy20 ( $ num ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Divisibility oleh 12 untuk sebilangan besar | Program PHP untuk memeriksa sama ada nombor dibahagikan dengan 12; jika nombor lebih besar maka 3; Cari digit terakhir; tidak ganjil; Cari digit terakhir kedua; Cari jumlah semua digit; jika nombor kurang kemudian atau sama dengan 100; Kod pemacu", "code": "< ? php function isDvisibleBy12 ( $ num ) { if ( strlen ( $ num ) >= 3 ) { $ d1 = ( int ) $ num [ strlen ( $ num ) - 1 ] ; if ( $ d1 % 2 != 0 ) return ( 0 ) ; $ d2 = ( int ) $ num [ strlen ( $ num ) - 2 ] ; $ sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num ) ; $ i ++ ) $ sum += $ num [ $ i ] ; return ( $ sum % 3 == 0 && ( $ d2 * 10 + $ d1 ) % 4 == 0 ) ; } else { $ number = stoi ( $ num ) ; return ( $ number % 12 == 0 ) ; } } $ num = \"12244824607284961224\" ; if ( isDvisibleBy12 ( $ num ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Nombor terbesar yang bukan persegi yang sempurna | Program PHP untuk mencari nombor persegi yang tidak sempurna di antara nombor N; mengambil sqrt nombor; memeriksa jika ia adalah nombor persegi yang sempurna; berfungsi untuk mencari nombor persegi bukan sempurna terbesar; menyimpan maksimum semua nombor persegi yang tidak sempurna; melintasi semua elemen dalam array; Simpan maksimum jika tidak persegi yang sempurna; Kod pemacu; panggilan fungsi", "code": "< ? php function check ( $ n ) { $ d = sqrt ( $ n ) ; if ( $ d * $ d == $ n ) return true ; return false ; } function largestNonPerfectSquareNumber ( $ a , $ n ) { $ maxi = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ! check ( $ a [ $ i ] ) ) $ maxi = max ( $ a [ $ i ] , $ maxi ) ; } return $ maxi ; } $ a = array ( 16 , 20 , 25 , 2 , 3 , 10 ) ; $ n = count ( $ a ) ; echo largestNonPerfectSquareNumber ( $ a , $ n ) ; ? >"}
{"text": "Program untuk mencetak Siri Kemajuan Aritmetik | Program PHP untuk mencetak siri perkembangan aritmetik; Percetakan AP dengan hanya menambahkan D ke istilah sebelumnya. ; nombor permulaan; Perbezaan umum; Istilah n yang boleh dijumpai", "code": "< ? php function printAP ( $ a , $ d , $ n ) { $ curr_term ; $ curr_term = a ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo ( $ curr_term . \" \" ) ; $ curr_term += $ d ; } } $ a = 2 ; $ d = 1 ; $ n = 5 ; printAP ( $ a , $ d , $ n ) ; ? >"}
{"text": "Program untuk mencetak nombor bukan persegi | Program PHP untuk mencetak nombor n bukan - persegi pertama. ; Cetak nombor curr_count. curr_count adalah jurang semasa antara dua nombor persegi. ; Langkau nombor persegi. ; Kira nombor bukan persegi seterusnya adalah nombor seterusnya. ; Kod pemacu", "code": "< ? php function printNonSquare ( $ n ) { $ curr_count = 2 ; $ num = 2 ; $ count = 0 ; while ( $ count < $ n ) { for ( $ i = 0 ; $ i < $ curr_count && $ count < $ n ; $ i ++ ) { echo ( $ num . \" \" ) ; $ count ++ ; $ num ++ ; } $ num ++ ; $ curr_count += 2 ; } } $ n = 10 ; printNonSquare ( $ n ) ; ? >"}
{"text": "Bilangan bilangan sifar trailing dalam produk array | Mengembalikan kiraan sifar dalam produk array; kiraan nombor 2 s dalam setiap elemen; kiraan nombor 5 s dalam setiap elemen; mengembalikan minimum; Kod pemacu", "code": "< ? php function countZeros ( $ a , $ n ) { $ count2 = 0 ; $ count5 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ a [ $ i ] % 2 == 0 ) { $ a [ $ i ] = $ a [ $ i ] / 2 ; $ count2 ++ ; } while ( $ a [ $ i ] % 5 == 0 ) { $ a [ $ i ] = $ a [ $ i ] / 5 ; $ count5 ++ ; } } return ( $ count2 < $ count5 ) ? $ count2 : $ count5 ; } $ a = array ( 10 , 100 , 20 , 30 , 50 , 90 , 12 , 80 ) ; $ n = sizeof ( $ a ) ; echo ( countZeros ( $ a , $ n ) ) ; ? >"}
{"text": "Jumlah Square of First N Even Numbers | Kaedah PHP yang cekap untuk mencari jumlah persegi nombor n pertama. ; Kod pemacu", "code": "< ? php function squareSum ( $ n ) { return 2 * $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 3 ; } echo squareSum ( 8 ) ; ? >"}
{"text": "MÃ ¼ Nchhausen Number | pwr [i] akan menyimpan saya dibangkitkan untuk kuasa i. ; Fungsi untuk menyemak sama ada nombor itu adalah nombor MA14NCHHAUSEN atau tidak; Precompute Saya dibangkitkan untuk kuasa saya untuk setiap saya; Input di sini ditetapkan i. e. ia akan memeriksa n; Semak integer untuk nombor MA14NCHHAUSEN, jika ya kemudian cetak nombor; Kod pemacu", "code": "< ? php $ pwr = array_fill ( 0 , 10 , 0 ) ; function isMunchhausen ( $ n ) { global $ pwr ; $ sm = 0 ; $ temp = $ n ; while ( $ temp ) { $ sm = $ sm + $ pwr [ ( $ temp % 10 ) ] ; $ temp = ( int ) ( $ temp / 10 ) ; } return ( $ sm == $ n ) ; } function printMunchhausenNumbers ( $ n ) { global $ pwr ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ pwr [ $ i ] = pow ( ( float ) ( $ i ) , ( float ) ( $ i ) ) ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) if ( isMunchhausen ( $ i ) ) print ( $ i . \" STRNEWLINE \" ) ; } $ n = 10000 ; printMunchhausenNumbers ( $ n ) ; ? >"}
{"text": "K | Untuk mengira k - th digit dalam a ^ b; Pengkomputeran A ^ B; mendapat digit terakhir; peningkatan kiraan dengan 1; Jika nombor semasa diperlukan digit; keluarkan digit terakhir; Kod pemacu", "code": "< ? php function kthdigit ( $ a , $ b , $ k ) { $ p = pow ( $ a , $ b ) ; $ count = 0 ; while ( $ p > 0 and $ count < $ k ) { $ rem = $ p % 10 ; $ count ++ ; if ( $ count == $ k ) return $ rem ; $ p = $ p / 10 ; } return 0 ; } $ a = 5 ; $ b = 2 ; $ k = 1 ; echo kthdigit ( $ a , $ b , $ k ) ; ? >"}
{"text": "Jumlah angka rekursif dalam n ^ x, di mana n dan x sangat besar | berfungsi untuk mendapatkan jumlah digit nombor; berfungsi untuk mengembalikan jumlah; Cari jumlah digit dalam n; Cari baki eksponen; Kod pemacu", "code": "< ? php function digSum ( $ n ) { if ( $ n == 0 ) return 0 ; return ( $ n % 9 == 0 ) ? 9 : ( $ n % 9 ) ; } function PowDigSum ( $ n , $ x ) { $ sum = digSum ( $ n ) ; $ rem = $ x % 6 ; if ( ( $ sum == 3 $ sum == 6 ) && $ x > 1 ) return 9 ; else if ( $ x == 1 ) return $ sum ; else if ( $ x == 0 ) return 1 ; else if ( $ rem == 0 ) return digSum ( pow ( $ sum , 6 ) ) ; else return digSum ( pow ( $ sum , $ rem ) ) ; } $ n = 33333 ; $ x = 332654 ; echo PowDigSum ( $ n , $ x ) ; ? >"}
{"text": "Bekas dengan kebanyakan air | Kod PHP untuk bekas air max; Mengira kawasan maksimum; Kod pemacu", "code": "< ? php function maxArea ( $ A , $ len ) { $ l = 0 ; $ r = $ len - 1 ; $ area = 0 ; while ( $ l < $ r ) { $ area = max ( $ area , min ( $ A [ $ l ] , $ A [ $ r ] ) * ( $ r - $ l ) ) ; if ( $ A [ $ l ] < $ A [ $ r ] ) $ l += 1 ; else $ r -= 1 ; } return $ area ; } $ a = array ( 1 , 5 , 4 , 3 ) ; $ b = array ( 3 , 1 , 2 , 4 , 5 ) ; $ len1 = sizeof ( $ a ) / sizeof ( $ a [ 0 ] ) ; echo maxArea ( $ a , $ len1 ) . \" STRNEWLINE \" ; $ len2 = sizeof ( $ b ) / sizeof ( $ b [ 0 ] ) ; echo maxArea ( $ b , $ len2 ) ; ? >"}
{"text": "Program untuk fungsi mobius | Pulangan nilai mobius (); Mengendalikan 2 secara berasingan; Jika 2 ^ 2 juga membahagikan n; Semak semua faktor utama lain; Jika saya membahagikan n; Jika i ^ 2 juga membahagikan n; Kod pemacu", "code": "< ? php function mobius ( $ n ) { $ p = 0 ; if ( $ n % 2 == 0 ) { $ n = $ n / 2 ; $ p ++ ; if ( $ n % 2 == 0 ) return 0 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { $ n = $ n / $ i ; $ p ++ ; if ( $ n % $ i == 0 ) return 0 ; } } return ( $ p % 2 == 0 ) ? -1 : 1 ; } $ N = 17 ; echo \" Mobius ▁ Functions ▁ M ( N ) ▁ at ▁ N ▁ = ▁ \" , $ N , \" ▁ is : ▁ \" , mobius ( $ N ) , \" STRNEWLINE \" ; echo \" Mobius ▁ Functions ▁ M ( N ) ▁ at ▁ N ▁ = ▁ \" , 25 , \" ▁ is : ▁ \" , mobius ( 25 ) , \" STRNEWLINE \" ; echo \" Mobius ▁ Functions ▁ M ( N ) ▁ at ▁ N ▁ = ▁ \" , 6 , \" ▁ is : ▁ \" , mobius ( 6 ) ; ? >"}
{"text": "Jumlah kuadrat koefisien binomial | berfungsi untuk mengembalikan produk nombor dari awal hingga akhir. ; Mengembalikan jumlah persegi pekali binomial; Kod pemacu", "code": "< ? php function factorial ( $ start , $ end ) { $ res = 1 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) $ res *= $ i ; return $ res ; } function sumofsquare ( $ n ) { return factorial ( $ n + 1 , 2 * $ n ) / factorial ( 1 , $ n ) ; } $ n = 4 ; echo sumofsquare ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari nombor Nth Fibonacci menggunakan nisbah emas | Anggaran nilai nisbah emas; Berfungsi untuk mencari nombor nth fibonacci; Nombor Fibonacci untuk n <6; Lain mula mengira dari tempoh ke -5; Kod pemacu", "code": "< ? php $ PHI = 1.6180339 ; function fib ( $ n ) { global $ PHI ; $ f = array ( 0 , 1 , 1 , 2 , 3 , 5 ) ; if ( $ n < 6 ) return $ f [ $ n ] ; $ t = 5 ; $ fn = 5 ; while ( $ t < $ n ) { $ fn = round ( $ fn * $ PHI ) ; $ t ++ ; } return $ fn ; } $ n = 9 ; echo $ n , \" th ▁ Fibonacci ▁ Number ▁ = ▁ \" , fib ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Kaedah Euler untuk Menyelesaikan Persamaan Pembezaan | Pertimbangkan persamaan pembezaan dy / dx = (x + y + xy); Fungsi untuk formula Euler; Melangkah sehingga titik di mana kita memerlukan penghampiran; Penghampiran percetakan; Nilai awal; Nilai x di mana kita memerlukan penghampiran", "code": "< ? php function func ( $ x , $ y ) { return ( $ x + $ y + $ x * $ y ) ; } function euler ( $ x0 , $ y , $ h , $ x ) { $ temp = -0 ; while ( $ x0 < $ x ) { $ temp = $ y ; $ y = $ y + $ h * func ( $ x0 , $ y ) ; $ x0 = $ x0 + $ h ; } echo \" Approximate ▁ solution ▁ at ▁ x ▁ = ▁ \" , $ x , \" ▁ is ▁ \" , $ y , \" STRNEWLINE \" ; } $ x0 = 0 ; $ y0 = 1 ; $ h = 0.025 ; $ x = 0.1 ; euler ( $ x0 , $ y0 , $ h , $ x ) ; ? >"}
{"text": "Cari x dan y memuaskan kapak + by = n | berfungsi untuk mencari penyelesaian; melintasi semua nilai yang mungkin; Semak sama ada ia memuaskan persamaan; Kod pemacu", "code": "< ? php function solution ( $ a , $ b , $ n ) { for ( $ i = 0 ; $ i * $ a <= $ n ; $ i ++ ) { if ( ( $ n - ( $ i * $ a ) ) % $ b == 0 ) { echo \" x = \" ▁ , ▁ $ i ▁ , ▁ \" , y = \" ( $ n - ( $ i * $ a ) ) / $ b ; return ; } } echo \" No ▁ solution \" ; } $ a = 2 ; $ b = 3 ; $ n = 7 ; solution ( $ a , $ b , $ n ) ; ? >"}
{"text": "Jumlah koefisien binomial | Pulangan nilai pekali binomial jumlah yang 2 dinaikkan kepada kuasa n. ; Kod pemacu", "code": "< ? php function binomialCoeffSum ( $ n ) { return ( 1 << $ n ) ; } $ n = 4 ; echo binomialCoeffSum ( $ n ) ; ? >"}
{"text": "Program untuk mengira bahagian ke tempat perpuluhan | Program PHP untuk mengira bahagian tempat perpuluhan. ; Kes asas; Sejak n <= 0, jangan mengira selepas perpuluhan; Mengendalikan nombor negatif; Bahagian Integral; Sekarang satu dengan digit cetak selepas DOT menggunakan kaedah Bahagian Sekolah. ; Kod pemacu", "code": "< ? php function precisionCompute ( $ x , $ y , $ n ) { if ( $ y == 0 ) { echo \" Infinite \" , \" STRNEWLINE \" ; return ; } if ( $ x == 0 ) { echo 0 , \" STRNEWLINE \" ; return ; } if ( $ n <= 0 ) { echo $ x / $ y , \" STRNEWLINE \" ; return ; } if ( ( ( $ x > 0 ) && ( $ y < 0 ) ) || ( ( $ x < 0 ) && ( $ y > 0 ) ) ) { echo \" - \" $ x = $ x > 0 ? $ x : - $ x ; $ y = $ y > 0 ? $ y : - $ y ; } $ d = $ x / $ y ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { echo $ d ; $ x = $ x - ( $ y * $ d ) ; if ( $ x == 0 ) break ; $ x = $ x * 10 ; $ d = $ x / $ y ; if ( $ i == 0 ) echo \" . \" ; } } $ x = 22 ; $ y = 7 ; $ n = 15 ; precisionCompute ( $ x , $ y , $ n ) ; ? >"}
{"text": "Program untuk menentukan kuadran pesawat Cartesian | Berfungsi untuk memeriksa kuadran; Kod pemacu; Panggilan fungsi", "code": "< ? php function quadrant ( $ x , $ y ) { if ( $ x > 0 and $ y > 0 ) echo ( \" lies ▁ in ▁ First ▁ quadrant \" ) ; else if ( $ x < 0 and $ y > 0 ) echo ( \" lies ▁ in ▁ Second ▁ quadrant \" ) ; else if ( $ x < 0 and $ y < 0 ) echo ( \" lies ▁ in ▁ Third ▁ quadrant \" ) ; else if ( $ x > 0 and $ y < 0 ) echo ( \" lies ▁ in ▁ Fourth ▁ quadrant \" ) ; else if ( $ x == 0 and $ y > 0 ) echo ( \" lies ▁ at ▁ positive ▁ y ▁ axis \" ) ; else if ( $ x == 0 and $ y < 0 ) echo ( \" lies ▁ at ▁ negative ▁ y ▁ axis \" ) ; else if ( $ y == 0 and $ x < 0 ) echo ( \" lies ▁ at ▁ negative ▁ x ▁ axis \" ) ; else if ( $ y == 0 and $ x > 0 ) echo ( \" lies ▁ at ▁ positive ▁ x ▁ axis \" ) ; else echo ( \" lies ▁ at ▁ origin \" ) ; } $ x = 1 ; $ y = 1 ; quadrant ( $ x , $ y ) ; ? >"}
{"text": "Semak sama ada nombor penuh Perdana | berfungsi untuk memeriksa digit; Semak semua digit adalah perdana atau tidak; Periksa sama ada digit adalah perdana atau tidak; Untuk memeriksa sama ada n adalah perdana atau tidak; Semak semua faktor; Untuk memeriksa sama ada n adalah perdana penuh; Perintah ini penting di sini untuk kecekapan. ; Kod pemacu", "code": "< ? php function checkDigits ( $ n ) { while ( $ n ) { $ dig = $ n % 10 ; if ( $ dig != 2 && $ dig != 3 && $ dig != 5 && $ dig != 7 ) return false ; $ n = ( int ) ( $ n / 10 ) ; } return true ; } function prime ( $ n ) { if ( $ n == 1 ) return false ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) return false ; } return true ; } function isFullPrime ( $ n ) { return ( checkDigits ( $ n ) && prime ( $ n ) ) ; } $ n = 53 ; if ( isFullPrime ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "SchrÃ ¶ derâ € \"Nombor Hipparchus | Program PHP yang Dioptimumkan Memoizing untuk Mencari N - Th Schraderahipparchus Nombor; Kod Pemandu", "code": "< ? php $ MAX = 500 ; function nthSHN ( $ n , $ dp ) { if ( $ n == 1 $ n == 2 ) return $ dp [ $ n ] = 1 ; if ( $ dp [ $ n ] != -1 ) return $ dp [ $ n ] ; return $ dp [ $ n ] = ( ( 6 * $ n - 9 ) * nthSHN ( $ n - 1 , $ dp ) - ( $ n - 3 ) * nthSHN ( $ n - 2 , $ dp ) ) / $ n ; } $ n = 6 ; $ dp = array_fill ( 0 , $ MAX , true ) ; echo nthSHN ( $ n , $ dp ) , \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah nombor pertama n bahkan | fungsi untuk mencari jumlah nombor n pertama; jumlah nombor pertama n bahkan; Seterusnya nombor juga; Jumlah yang diperlukan; Program Pemandu untuk diuji di atas", "code": "< ? php function evenSum ( $ n ) { $ curr = 2 ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ sum += $ curr ; $ curr += 2 ; } return $ sum ; } $ n = 20 ; echo \" Sum ▁ of ▁ first ▁ \" . $ n . \" ▁ Even ▁ numbers ▁ is : ▁ \" . evenSum ( $ n ) ; ? >"}
{"text": "Jumlah nombor pertama n bahkan | fungsi untuk mencari jumlah nombor n pertama; Jumlah yang diperlukan; Kod pemacu", "code": "< ? php function evenSum ( $ n ) { return ( $ n * ( $ n + 1 ) ) ; } $ n = 20 ; echo \" Sum ▁ of ▁ first ▁ \" , $ n , \" ▁ Even ▁ numbers ▁ is : ▁ \" , evenSum ( $ n ) ; ? >"}
{"text": "Program untuk menukar km / jam ke batu / jam dan sebaliknya | Berfungsi untuk menukar kmph ke mph; Berfungsi untuk menukar MPH ke KMPH; Kod pemacu", "code": "< ? php function kmphTOmph ( $ kmph ) { return 0.6214 * $ kmph ; } function mphTOkmph ( $ mph ) { return $ mph * 1.60934 ; } $ kmph = 150 ; $ mph = 100 ; echo \" speed ▁ in ▁ mph ▁ is ▁ \" , kmphTOmph ( $ kmph ) , \" STRNEWLINE \" ; echo \" speed ▁ in ▁ kmph ▁ is ▁ \" , mphTOkmph ( $ mph ) ; ? >"}
{"text": "Cari elemen dalam array yang membahagikan semua elemen array | Mengembalikan GCD dua nombor; Berfungsi untuk mengembalikan nombor yang dikehendaki jika ada; Cari GCD Array; Semak jika GCD hadir dalam pelbagai; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function findNumber ( $ arr , $ n ) { $ ans = $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ ans = gcd ( $ ans , $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ ans ) return $ ans ; return -1 ; } $ arr = array ( 2 , 2 , 4 ) ; $ n = sizeof ( $ arr ) ; echo findNumber ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Nombor Perdana Khas | Program PHP untuk memeriksa sama ada terdapat sekurang -kurangnya k atau tidak dalam julat [2. n]; Menjana semua nombor perdana dari 2 hingga n. ; Jika nombor perdana adalah nombor utama khas, maka kami meningkatkan nilai k. ; Jika sekurang -kurangnya k nombor perdana khas hadir, maka kita kembali 1. Jika kita kembali 0 dari luar gelung luar. ; Kod pemacu", "code": "< ? php $ primes = array ( ) ; function SieveofEratosthenes ( $ n ) { global $ primes ; $ visited = array_fill ( 0 , $ n , false ) ; for ( $ i = 2 ; $ i <= $ n + 1 ; $ i ++ ) if ( ! $ visited [ $ i ] ) { for ( $ j = $ i * $ i ; $ j <= $ n + 1 ; $ j += $ i ) $ visited [ $ j ] = true ; array_push ( $ primes , $ i ) ; } } function specialPrimeNumbers ( $ n , $ k ) { global $ primes ; SieveofEratosthenes ( $ n ) ; $ count = 0 ; for ( $ i = 0 ; $ i < count ( $ primes ) ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i - 1 ; $ j ++ ) { if ( $ primes [ $ j ] + $ primes [ $ j + 1 ] + 1 == $ primes [ $ i ] ) { $ count ++ ; break ; } } if ( $ count == $ k ) return true ; } return false ; } $ n = 27 ; $ k = 2 ; if ( specialPrimeNumbers ( $ n , $ k ) ) echo \" YES STRNEWLINE \" ; else echo \" NO STRNEWLINE \" ; ? >"}
{"text": "Faktor Perdana yang besar | fungsi untuk mengira semua faktor utama dan mengira setiap faktor utama; Kira bilangan kali 2 membahagikan; bersamaan dengan n = n / 2; ; jika 2 membahagikannya; Semak semua nombor yang mungkin boleh membahagikannya; Jika n pada akhir adalah nombor utama. ; Kod pemacu", "code": "< ? php function factorize ( $ n ) { $ count = 0 ; while ( ! ( $ n % 2 ) ) { $ n >>= 1 ; $ count ++ ; } if ( $ count ) echo ( 2 . \" \" ▁ . ▁ $ count ▁ . ▁ \" \" for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i += 2 ) { $ count = 0 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = $ n / $ i ; } if ( $ count ) echo ( $ i . \" ▁ \" . $ count ) ; } if ( $ n > 2 ) echo ( $ n . \" ▁ \" . 1 ) ; } $ n = 1000000000000000000 ; factorize ( $ n ) ; ? >"}
{"text": "Operasi GCD minimum untuk membuat semua elemen array satu | __GCD Fungsi; Berfungsi untuk mengira bilangan bergerak. ; Mengira bilangan yang. ; Jika ada satu; Cari subarray terkecil dengan GCD sama dengan satu. ; untuk mengira GCD; Tidak mungkin; Jawapan terakhir; Kod pemacu", "code": "< ? php function __gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return __gcd ( $ b % $ a , $ a ) ; } function minimumMoves ( $ A , $ N ) { $ one = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ A [ $ i ] == 1 ) $ one ++ ; if ( $ one != 0 ) return $ N - $ one ; $ minimum = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ g = $ A [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { $ g = __gcd ( $ A [ $ j ] , $ g ) ; if ( $ g == 1 ) { $ minimum = min ( $ minimum , $ j - $ i ) ; break ; } } } if ( $ minimum == PHP_INT_MAX ) return -1 ; else return $ N + $ minimum - 1 ; } $ A = array ( 2 , 4 , 3 , 9 ) ; $ N = sizeof ( $ A ) ; echo ( minimumMoves ( $ A , $ N ) ) ; ? >"}
{"text": "Diberikan n dan sisihan piawai, cari elemen n | berfungsi untuk mencetak siri elemen N; jika s. D. adalah 0 kemudian cetak semua elemen sebagai 0 .; cetak n 0 's; jika s. D. juga; cetak - sd, + sd, - sd, + sd; jika ganjil; menukar n ke integer terapung; Cetak satu elemen menjadi 0; cetak (n - 1) elemen sebagai xi yang diperolehi dari formula; Kod pemacu", "code": "< ? php function series ( $ n , $ d ) { if ( $ d == 0 ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo \"0 ▁ \" ; echo \" STRNEWLINE \" ; return ; } if ( $ n % 2 == 0 ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo pow ( -1 , $ i ) * $ d , \" \" ; } echo \" STRNEWLINE \" ; } else { $ m = $ n ; $ r = ( $ m / ( $ m - 1 ) ) ; $ g = ( $ d * sqrt ( $ r ) ) ; echo \"0 ▁ \" ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { echo pow ( -1 , $ i ) * $ g , \" \" ; } echo \" STRNEWLINE \" ; } } $ n = 3 ; $ d = 3 ; series ( $ n , $ d ) ; ? >"}
{"text": "Jumlah No 1 dalam nombor | Kod PHP untuk mengira kekerapan 1 dalam nombor kurang daripada atau sama dengan nombor yang diberikan. ; Kod pemacu", "code": "< ? php function countDigitOne ( $ n ) { $ countr = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ str = strval ( $ i ) ; $ countr += substr_count ( $ str , '1' ) ; } return $ countr ; } $ n = 13 ; echo countDigitOne ( $ n ) . \" STRNEWLINE \" ; $ n = 131 ; echo countDigitOne ( $ n ) . \" STRNEWLINE \" ; $ n = 159 ; echo countDigitOne ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Exponential Squaring (Modulo Multiplication Fast) | Nilai Modulo Perdana; Bagi kes -kes di mana eksponen bukan nilai yang sama; Kod pemacu", "code": "< ? php $ N = 1000000007 ; function exponentiation ( $ bas , $ exp ) { global $ N ; $ t = 1 ; while ( $ exp > 0 ) { if ( $ exp % 2 != 0 ) $ t = ( $ t * $ bas ) % $ N ; $ bas = ( $ bas * $ bas ) % $ N ; $ exp = ( int ) $ exp / 2 ; } return $ t % $ N ; } $ bas = 5 ; $ exp = 100000 ; $ modulo = exponentiation ( $ bas , $ exp ) ; echo ( $ modulo ) ; ? >"}
{"text": "GCD FAKTORIAL DUA NOMBOR | Program PHP untuk mencari GCD faktorial dua nombor. ; Kod pemacu", "code": "< ? php function factorial ( $ x ) { if ( $ x <= 1 ) return 1 ; $ res = 2 ; for ( $ i = 3 ; $ i <= $ x ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } function gcdOfFactorial ( $ m , $ n ) { return factorial ( min ( $ m , $ n ) ) ; } $ m = 5 ; $ n = 9 ; echo gcdOfFactorial ( $ m , $ n ) ; ? >"}
{"text": "Jumlah angka rekursif nombor adalah perdana atau tidak | Fungsi untuk jumlah digit rekursif; berfungsi untuk memeriksa sama ada perdana atau tidak satu digit; fungsi panggilan yang mengembalikan jumlah sehingga digit tunggal; Memeriksa Perdana; Kod pemacu", "code": "< ? php function recDigSum ( $ n ) { if ( $ n == 0 ) return 0 ; else { if ( $ n % 9 == 0 ) return 9 ; else return $ n % 9 ; } } function check ( $ n ) { $ n = recDigSum ( $ n ) ; if ( $ n == 2 or $ n == 3 or $ n == 5 or $ n == 7 ) echo \" Yes \" ; else echo \" No \" ; } $ n = 5602 ; check ( $ n ) ; ? >"}
{"text": "Cari n | Definisi fungsi findnumber; Mencari x dari persamaan n = x (x + 1) / 2 + 1; Asas blok semasa; Nilai elemen n - th; Kod pemacu", "code": "< ? php function findNumber ( $ n ) { $ x = floor ( ( -1 + sqrt ( 1 + 8 * $ n - 8 ) ) / 2 ) ; $ base = ( $ x * ( $ x + 1 ) ) / 2 + 1 ; return $ n - $ base + 1 ; } $ n = 55 ; echo findNumber ( $ n ) ; ? >"}
{"text": "Program untuk purata berat bilangan semula jadi. | Mengembalikan Berat Benar dengan menganggap nombor {1, 2 ,. . n} dan berat {1, 2 ,. . n}; Kod pemacu", "code": "< ? php function weightedMean ( $ n ) { return ( 2 * $ n + 1 ) / 3 ; } $ n = 10 ; echo ( weightedMean ( $ n ) ) ; ? >"}
{"text": "Bahagikan setiap elemen satu array oleh elemen array lain | Berfungsi untuk mengira kuota setiap elemen array; Kirakan produk semua elemen; Untuk mengira kuota setiap elemen array; Kod pemacu", "code": "< ? php function calculate ( $ a , $ b , $ n , $ m ) { $ mul = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ b [ $ i ] != 0 ) $ mul = $ mul * $ b [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = floor ( $ a [ $ i ] / $ mul ) ; echo $ x , \" \" ; } } $ a = array ( 5 , 100 , 8 ) ; $ b = array ( 2 , 3 ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; calculate ( $ a , $ b , $ n , $ m ) ; ? >"}
{"text": "Bilangan bom minimum | berfungsi untuk mencetak di mana untuk menembak; tidak. bom diperlukan; Bom semua jawatan; Bom semua kedudukan ganjil; Bom semua kedudukan lagi; Kod pemacu", "code": "< ? php function p_rint ( $ n ) { echo floor ( $ n + $ n / 2 ) , \" STRNEWLINE \" ; for ( $ i = 2 ; $ i <= $ n ; $ i += 2 ) echo $ i , \" ▁ \" ; for ( $ i = 1 ; $ i <= $ n ; $ i += 2 ) echo $ i , \" ▁ \" ; for ( $ i = 2 ; $ i <= $ n ; $ i += 2 ) echo $ i , \" ▁ \" ; } $ n = 3 ; p_rint ( $ n ) ; ? >"}
{"text": "LCM digit nombor tertentu | Tentukan fungsi LCM; Jika di mana -mana titik LCM menjadi 0. mengembalikannya; Kod pemacu", "code": "< ? php function lcm_fun ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return lcm_fun ( $ b , $ a % $ b ) ; } function digitLCM ( $ n ) { $ lcm = 1 ; while ( $ n > 0 ) { $ lcm = ( int ) ( ( $ n % 10 * $ lcm ) / lcm_fun ( $ n % 10 , $ lcm ) ) ; if ( $ lcm == 0 ) return 0 ; $ n = ( int ) ( $ n / 10 ) ; } return $ lcm ; } $ n = 397 ; echo digitLCM ( $ n ) ; ? >"}
{"text": "Masalah Setiausaha (masalah berhenti optimum) | Program PHP untuk menguji undang -undang 1 / e untuk Masalah Setiausaha :; Untuk mencari integer terdekat NUM. ; Cari calon terbaik menggunakan peraturan N / E. Calon [] mewakili bakat n calon. ; Mengira saiz sampel untuk penandaarasan. ; Mencari calon terbaik dalam saiz sampel; Mencari calon terbaik pertama yang lebih baik daripada set penanda aras. ; Kod pemacu; N = 8 calon dan array calon mengandungi bakat n calon di mana bilangan terbesar bermakna calon berbakat tertinggi. ; Menjana nombor rawak antara 1 hingga 8 untuk bakat calon", "code": "< ? php $ e = 2.71828 ; function roundNo ( $ num ) { return $ num < 0 ? $ num - 0.5 : $ num + 0.5 ; } function printBestCandidate ( $ candidate , $ n ) { global $ e ; $ sample_size = roundNo ( $ n / $ e ) ; echo \" Sample size is \" floor ( $ sample_size ) . \" STRNEWLINE \" ; $ best = 0 ; for ( $ i = 1 ; $ i < $ sample_size ; $ i ++ ) if ( $ candidate [ $ i ] > $ candidate [ $ best ] ) $ best = $ i ; for ( $ i = $ sample_size ; $ i < $ n ; $ i ++ ) if ( $ candidate [ $ i ] >= $ candidate [ $ best ] ) { $ best = $ i ; break ; } if ( $ best >= $ sample_size ) echo \" Best candidate found is \" . floor ( $ best + 1 ) . \" ▁ with ▁ talent ▁ \" . floor ( $ candidate [ $ best ] ) . \" STRNEWLINE \" ; else echo \" Couldn ' t ▁ find ▁ a ▁ best ▁ candidate STRNEWLINE \" ; } $ n = 8 ; $ candidate = array_fill ( 0 , $ n , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ candidate [ $ i ] = 1 + rand ( 1 , 8 ) ; echo \" Candidate ▁ : ▁ \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ i + 1 ) . \" ▁ \" ; echo \" Talents : \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ candidate [ $ i ] . \" ▁ \" ; printBestCandidate ( $ candidate , $ n ) ; ? >"}
{"text": "Newton Forward and Backward Interpolation | Pengiraan anda disebut dalam formula; Mengira faktorial yang diberikan n; bilangan nilai yang diberikan; y [] [] digunakan untuk jadual perbezaan dan y [] [0] digunakan untuk input; Mengira jadual perbezaan mundur; Memaparkan jadual perbezaan mundur; Nilai untuk interpolasi pada; Memulakan u dan jumlah", "code": "< ? php function u_cal ( $ u , $ n ) { $ temp = $ u ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ temp = $ temp * ( $ u + $ i ) ; return $ temp ; } function fact ( $ n ) { $ f = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ f *= $ i ; return $ f ; } $ n = 5 ; $ x = array ( 1891 , 1901 , 1911 , 1921 , 1931 ) ; $ y = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; $ y [ 0 ] [ 0 ] = 46 ; $ y [ 1 ] [ 0 ] = 66 ; $ y [ 2 ] [ 0 ] = 81 ; $ y [ 3 ] [ 0 ] = 93 ; $ y [ 4 ] [ 0 ] = 101 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ n - 1 ; $ j >= $ i ; $ j -- ) $ y [ $ j ] [ $ i ] = $ y [ $ j ] [ $ i - 1 ] - $ y [ $ j - 1 ] [ $ i - 1 ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) print ( $ y [ $ i ] [ $ j ] . \" TABSYMBOL \" ) ; print ( \" STRNEWLINE \" ) ; } $ value = 1925 ; $ sum = $ y [ $ n - 1 ] [ 0 ] ; $ u = ( $ value - $ x [ $ n - 1 ] ) / ( $ x [ 1 ] - $ x [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( u_cal ( $ u , $ i ) * $ y [ $ n - 1 ] [ $ i ] ) / fact ( $ i ) ; } print ( \" Value at \" ▁ . ▁ $ value ▁ . STRNEWLINE TABSYMBOL \" is \" ? >"}
{"text": "Nombor gembira | Mengembalikan jumlah kuadrat digit nombor n. Contohnya untuk n = 12 ia mengembalikan 1 + 4 = 5; Pulangan benar jika n adalah bilangan gembira lain mengembalikan palsu. ; Terus menggantikan N dengan jumlah kuadrat digit sehingga kita mencapai 1 atau kita berakhir dalam kitaran; Nombor gembira jika kita mencapai 1; Menggantikan n dengan jumlah kuadrat digit; Nombor tidak gembira jika kita mencapai 4; Kod pemacu", "code": "< ? php function sumDigitSquare ( $ n ) { $ sq = 0 ; while ( $ n ) { $ digit = $ n % 10 ; $ sq += $ digit * $ digit ; $ n = $ n / 10 ; } return $ sq ; } function isHappy ( $ n ) { while ( 1 ) { if ( $ n == 1 ) return true ; $ n = sumDigitSquare ( $ n ) ; if ( $ n == 4 ) return false ; } return false ; } $ n = 23 ; if ( isHappy ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Jumlah semua subset set yang dibentuk oleh nombor semulajadi n Pertama | Program PHP untuk mencari jumlah semua subset satu set; jumlah subset adalah (n * (n + 1) / 2) * pow (2, n - 1); Kod pemacu", "code": "< ? php function findSumSubsets ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 1 << ( $ n - 1 ) ) ; } $ n = 3 ; echo findSumSubsets ( $ n ) ; ? >"}
{"text": "Elemen minimum yang n | berfungsi untuk mencari elemen minimum; gelung untuk melintasi dan menyimpan jumlah log; Mengira jumlah; Mengira unsur -unsur mengikut formula. ; mengembalikan elemen minimum; array yang dimulakan; mengira saiz array; mencetak elemen minimum", "code": "< ? php function findMin ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += log ( $ a [ $ i ] ) ; $ x = exp ( $ sum / $ n ) ; return ( int ) ( $ x + 1 ) ; } $ a = array ( 3 , 2 , 1 , 4 ) ; $ n = sizeof ( $ a ) ; echo ( findMin ( $ a , $ n ) ) ; ? >"}
{"text": "Menjana semua permutasi kitaran nombor | Berfungsi untuk mengira jumlah digit dalam nombor. ; Berfungsi untuk menjana semua permutasi kitaran nombor; Berikutan tiga baris menghasilkan pukulan bulat nombor. ; Jika semua permutasi diperiksa dan kami memperoleh nombor asal keluar dari gelung. ; Kod pemacu", "code": "< ? php function countdigits ( $ N ) { $ count = 0 ; while ( $ N ) { $ count ++ ; $ N = floor ( $ N / 10 ) ; } return $ count ; } function cyclic ( $ N ) { $ num = $ N ; $ n = countdigits ( $ N ) ; while ( 1 ) { echo ( $ num ) ; echo \" STRNEWLINE \" ; $ rem = $ num % 10 ; $ div = floor ( $ num / 10 ) ; $ num = ( pow ( 10 , $ n - 1 ) ) * $ rem + $ div ; if ( $ num == $ N ) break ; } } $ N = 5674 ; cyclic ( $ N ) ; ? >"}
{"text": "Semak sama ada nombor adalah Pekeliling Perdana atau tidak | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi untuk memeriksa sama ada nombor itu adalah pekeliling utama atau tidak. ; Mengira digit. ; Berikutan tiga baris menjana permutasi bulat seterusnya nombor. Kami bergerak digit terakhir ke kedudukan pertama. ; Jika semua permutasi diperiksa dan kami memperoleh nombor asal keluar dari gelung. ; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return -1 ; return true ; } function checkCircular ( $ N ) { $ count = 0 ; $ temp = $ N ; while ( $ temp ) { $ count ++ ; $ temp = ( int ) $ temp / 10 ; } $ num = $ N ; while ( isPrime ( $ num ) ) { $ rem = $ num % 10 ; $ div = ( int ) $ num / 10 ; $ num = ( pow ( 10 , $ count - 1 ) ) * $ rem + $ div ; if ( $ num == $ N ) return true ; } return -1 ; } $ N = 1193 ; if ( checkCircular ( $ N ) ) echo \" Yes \" , \" STRNEWLINE \" ; else echo \" No \" , \" STRNEWLINE \" ; ? >"}
{"text": "Cari jika dua orang pernah bertemu selepas jumlah lompat yang sama | berfungsi untuk mencari sama ada salah seorang daripada mereka boleh mengatasi yang lain; Oleh kerana titik permulaan selalu berbeza, mereka akan bertemu jika keadaan berikut dipenuhi. (1) Kelajuan tidak sama (2) perbezaan antara kelajuan membahagikan jumlah jarak antara titik awal. ; Kod pemacu", "code": "< ? php function sackRace ( $ p1 , $ s1 , $ p2 , $ s2 ) { return ( ( $ s1 > $ s2 && ( $ p2 - $ p1 ) % ( $ s1 - $ s2 ) == 0 ) || ( $ s2 > $ s1 && ( $ p1 - $ p2 ) % ( $ s2 - $ s1 ) == 0 ) ) ; } $ p1 = 4 ; $ s1 = 4 ; $ p2 = 8 ; $ s2 = 2 ; if ( sackRace ( $ p1 , $ s1 , $ p2 , $ s2 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Pecahan yang betul dengan jumlah pengangka dan penyebut sama dengan nombor tertentu | Program PHP untuk mencari pecahan terbesar A / B supaya A + B sama dengan nombor yang diberikan dan A <B. ; Hitung n / 2; ; Semak sama ada N adalah ganjil atau bahkan; Jika n adalah jawapan ganjil akan menjadi Ceil (n / 2) - 1 dan lantai (n / 2) + 1; Jika n juga periksa sama ada n / 2 i. e a adalah atau ganjil; Jika n / 2 juga memohon formula sebelumnya; Jika n / 2 adalah jawapan ganjil akan menjadi Ceil (n / 2) - 2 dan lantai (n / 2) + 2; fungsi pemacu", "code": "< ? php function solve ( $ n ) { $ a = ( float ) $ n / 2 ; if ( $ n % 2 != 0 ) echo ceil ( $ a ) - 1 , \" ▁ \" , floor ( $ a ) + 1 , \" STRNEWLINE \" ; else { if ( $ a % 2 == 0 ) { echo ceil ( $ a ) - 1 , \" ▁ \" , floor ( $ a ) + 1 , \" STRNEWLINE \" ; } else { echo ceil ( $ a ) - 2 , \" ▁ \" , floor ( $ a ) + 2 , \" STRNEWLINE \" ; } } } $ n = 34 ; solve ( $ n ) ; ? >"}
{"text": "Program untuk mencari minat mudah | Kita boleh menukar nilai di sini untuk input yang berbeza; Hitung minat mudah; Cetak nilai hasil SI", "code": "< ? php $ P = 1 ; $ R = 1 ; $ T = 1 ; $ SI = ( $ P * $ T * $ R ) / 100 ; echo \" Simple ▁ Interest ▁ = ▁ \" . $ SI ; ? >"}
{"text": "Bilangan digit dalam produk dua nombor | berfungsi untuk mengira bilangan digit dalam produk dua nombor; nilai mutlak produk dua nombor; jika produk adalah 0; kiraan nombor digit dalam produk 'P'; kiraan digit yang diperlukan; Kod pemacu", "code": "< ? php function countDigits ( $ a , $ b ) { $ count = 0 ; $ p = abs ( $ a * $ b ) ; if ( $ p == 0 ) return 1 ; while ( $ p > 0 ) { $ count ++ ; $ p = ( int ) ( $ p / 10 ) ; } return $ count ; } $ a = 33 ; $ b = -24 ; echo \" Number ▁ of ▁ digits ▁ = ▁ \" . countDigits ( $ a , $ b ) ; ? >"}
{"text": "Cari berganda x paling dekat dengan atau a ^ b (yang dinaikkan ke kuasa b) | fungsi untuk mencari pelbagai terdekat x ke A ^ B; Kirakan A ^ B / X; Jawapan sama ada (ans * x) atau (ans + 1) * x; Mencetak jawapan terdekat; Kod pemacu", "code": "< ? php function multiple ( $ a , $ b , $ x ) { if ( $ b < 0 ) { if ( $ a == 1 && $ x == 1 ) echo \"1\" ; else echo \"0\" ; } $ mul = pow ( $ a , $ b ) ; $ ans = $ mul / $ x ; $ ans1 = $ x * $ ans ; $ ans2 = $ x * ( $ ans + 1 ) ; $ k = ( ( ( $ mul - $ ans1 ) <= ( $ ans2 - $ mul ) ) ? $ ans1 : $ ans2 ) ; echo ( $ k ) ; } $ a = 348 ; $ b = 1 ; $ x = 4 ; multiple ( $ a , $ b , $ x ) ; ? >"}
{"text": "Jumlah maksimum perbezaan unsur -unsur bersebelahan | Untuk mencari jumlah permutasi maksimum; Kes asas; Jika tidak, jumlah maksimum akan menjadi (n * (n - 1) / 2) - 1 + n / 2; Kod pemacu", "code": "< ? php function maxSum ( $ n ) { if ( $ n == 1 ) return 1 ; else return ( $ n * ( $ n - 1 ) / 2 ) - 1 + $ n / 2 ; } $ n = 3 ; echo intval ( maxSum ( $ n ) ) ; ? >"}
{"text": "Tambah nombor minimum ke array supaya jumlahnya menjadi bahkan | Berfungsi untuk mengetahui nombor minimum; Mengira jumlah terma dalam array; Kod pemacu", "code": "< ? php function minNum ( $ arr , $ n ) { $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 ) $ odd = ! $ odd ; if ( $ odd ) return 1 ; return 2 ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; $ n = sizeof ( $ arr ) ; echo minNum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak sama ada nombor tersebar atau tidak | Berfungsi untuk memeriksa sama ada nombor bergelora atau tidak; Nombor digit tunggal; Memeriksa setiap digit melalui gelung; Semua digit telah diperiksa; Digit di Indeks I; Digit di Indeks I - 1; Jika perbezaan lebih besar daripada 1; Nombor diperiksa; - 1234 untuk diperiksa; 287 untuk diperiksa", "code": "< ? php function checkJumbled ( $ num ) { if ( $ num / 10 == 0 ) return true ; while ( $ num != 0 ) { if ( $ num / 10 == 0 ) return true ; $ digit1 = $ num % 10 ; $ digit2 = ( $ num / 10 ) % 10 ; if ( abs ( $ digit2 - $ digit1 ) > 1 ) return false ; $ num = $ num / 10 ; } return true ; } $ num = -1234 ; if ( checkJumbled ( $ num ) ) echo \" True ▁ STRNEWLINE \" ; else echo \" False ▁ STRNEWLINE \" ; $ num = -1247 ; if ( checkJumbled ( $ num ) ) echo \" True ▁ STRNEWLINE \" ; else echo \" False ▁ STRNEWLINE \" ; ? >"}
{"text": "Masalah Josephus Menggunakan Bit Magic | fungsi untuk mencari kedudukan bit yang paling penting; menyimpan bit beralih ke kanan sehingga kita ditinggalkan dengan 0; berfungsi untuk kembali ke tempat Josephus harus duduk untuk mengelakkan dibunuh; Mendapatkan kedudukan Bit Paling Penting (MSB). Yang paling kiri '1'. Jika nombor itu '41' maka binari adalah '101001'. Jadi MSBPOS (41) = 6; 'J' menyimpan nombor yang mana untuk xor nombor 'n'. Oleh kerana kita memerlukan '100000'. Kami akan melakukan 1 << 6 - 1 untuk mendapatkan '100000'; Mengubah sedikit yang paling ketara. Menukar '1' paling kiri hingga '0'. 101001 ^ 100000 = 001001 (9); Kiri - beralih sekali untuk menambah '0' tambahan ke hujung kanan nombor binari 001001 = 010010 (18); Mengubah '0' pada akhir hingga '1' yang pada dasarnya sama seperti meletakkan MSB di tempat paling kanan. 010010 | 1 = 010011 (19); Kod pemacu", "code": "< ? php function msbPos ( $ n ) { $ pos = 0 ; while ( $ n != 0 ) { $ pos ++ ; $ n = $ n >> 1 ; } return $ pos ; } function josephify ( $ n ) { $ position = msbPos ( $ n ) ; $ j = 1 << ( $ position - 1 ) ; $ n = $ n ^ $ j ; $ n = $ n << 1 ; $ n = $ n | 1 ; return $ n ; } $ n = 41 ; print ( josephify ( $ n ) ) ; ? >"}
{"text": "Kira pasangan dengan XOR ganjil | Fungsi akan mengembalikan bilangan pasangan yang XOR adalah ganjil; Untuk menyimpan kiraan pasangan XOR; Jika XOR adalah kiraan kenaikan ganjil; Kiraan pulangan; Kod pemacu", "code": "< ? php function countXorPair ( $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ i ] ^ $ arr [ $ j ] ) % 2 == 1 ) $ count ++ ; } return $ count ; } $ arr = array ( 1 , 2 , 3 ) ; $ n = count ( $ arr ) ; echo countXorPair ( $ arr , $ n ) ; ? >"}
{"text": "Logaritma diskret (cari integer k sedemikian rupa sehingga a ^ k adalah modul kongruen b) | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); $ x = $ x % $ p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; Fungsi untuk mengira k untuk diberikan a, b, m; Simpan semua nilai A ^ (n * i) LHS; Hitung (a ^ j) * b dan periksa perlanggaran; Sekiranya perlanggaran berlaku i. e. , LHS = RHS; Semak sama ada Ans terletak di bawah m atau tidak; Kod pemacu", "code": "< ? php function powmod ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function discreteLogarithm ( $ a , $ b , $ m ) { $ n = ( int ) sqrt ( $ m ) + 1 ; $ value = array_fill ( 0 , $ m , NULL ) ; for ( $ i = $ n ; $ i >= 1 ; -- $ i ) $ value [ powmod ( $ a , $ i * $ n , $ m ) ] = $ i ; for ( $ j = 0 ; $ j < $ n ; ++ $ j ) { $ cur = ( powmod ( $ a , $ j , $ m ) * $ b ) % $ m ; if ( $ value [ $ cur ] ) { $ ans = $ value [ $ cur ] * $ n - $ j ; if ( $ ans < $ m ) return $ ans ; } } return -1 ; } $ a = 2 ; $ b = 3 ; $ m = 5 ; echo discreteLogarithm ( $ a , $ b , $ m ) , \" \" ; $ a = 3 ; $ b = 7 ; $ m = 11 ; echo discreteLogarithm ( $ a , $ b , $ m ) , \" \" ; ? >"}
{"text": "Logaritma diskret (cari integer k sedemikian rupa sehingga a ^ k adalah modul kongruen b) | Program PHP untuk mengira logaritma diskret; Hitung a ^ n; Simpan semua nilai A ^ (n * i) LHS; Hitung (a ^ j) * b dan periksa perlanggaran; Kod pemacu", "code": "< ? php function discreteLogarithm ( $ a , $ b , $ m ) { $ n = ( int ) sqrt ( $ m ) + 1 ; $ an = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ an = ( $ an * $ a ) % $ m ; $ value = array_fill ( 0 , $ m , NULL ) ; for ( $ i = 1 , $ cur = $ an ; $ i <= $ n ; ++ $ i ) { if ( ! $ value [ $ cur ] ) $ value [ $ cur ] = $ i ; $ cur = ( $ cur * $ an ) % $ m ; } for ( $ i = 0 , $ cur = $ b ; $ i <= $ n ; ++ $ i ) { if ( $ value [ $ cur ] ) { $ ans = $ value [ $ cur ] * $ n - $ i ; if ( $ ans < $ m ) return $ ans ; } $ cur = ( $ cur * $ a ) % $ m ; } return -1 ; } $ a = 2 ; $ b = 3 ; $ m = 5 ; echo discreteLogarithm ( $ a , $ b , $ m ) , \" \" ; $ a = 3 ; $ b = 7 ; $ m = 11 ; echo discreteLogarithm ( $ a , $ b , $ m ) ; ? >"}
{"text": "Mencari n | Program PHP untuk mencari nombor n - tH dengan digit utama 2, 3 dan 7; sisa untuk kedudukan elemen cek; Jika nombor adalah kedudukan 1 st di pokok; jika nombor adalah kedudukan 2 nd dalam pokok; Jika nombor adalah kedudukan 3 rd dalam pokok; jika nombor adalah kedudukan ke -4 dalam pokok; Kod pemacu", "code": "< ? php function nthprimedigitsnumber ( $ number ) { $ num = \" \" ; while ( $ number > 0 ) { $ rem = $ number % 4 ; switch ( $ rem ) { case 1 : $ num . = '2' ; break ; case 2 : $ num . = '3' ; break ; case 3 : $ num . = '5' ; break ; case 0 : $ num . = '7' ; break ; } if ( $ number % 4 == 0 ) $ number -- ; $ number = ( int ) ( $ number / 4 ) ; } return strrev ( $ num ) ; } $ number = 21 ; print ( nthprimedigitsnumber ( 10 ) . \" STRNEWLINE \" ) ; print ( nthprimedigitsnumber ( $ number ) ) ;"}
{"text": "Kiraan pasangan (a, b) yang jumlah kiub adalah n (a ^ 3 + b ^ 3 = n) | Fungsi untuk mengira pasangan yang memuaskan ^ 3 + b ^ 3 = n; Semak setiap nombor 1 ke CBRT (n); Menyimpan kiub nombor; Tolak kiub dari diberikan n; Semak sama ada perbezaannya juga kiub yang sempurna; Jika ya, maka kiraan kenaikan; Kiraan pulangan; Gelung untuk mengira tidak. pasangan yang memuaskan ^ 3 + b ^ 3 = i untuk n = 1 hingga 10", "code": "< ? php function countPairs ( $ N ) { $ count = 0 ; for ( $ i = 1 ; $ i <= ( int ) pow ( $ N , 1 / 3 ) ; $ i ++ ) { $ cb = $ i * $ i * $ i ; $ diff = ( $ N - $ cb ) ; $ cbrtDiff = ( int ) pow ( $ diff , 1 / 3 ) ; if ( $ cbrtDiff * $ cbrtDiff * $ cbrtDiff == $ diff ) $ count ++ ; } return $ count ; } for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) echo \" For ▁ n ▁ = ▁ \" , $ i , \" , ▁ \" , countPairs ( $ i ) , \" ▁ pair ▁ exists STRNEWLINE \" ; ? >"}
{"text": "Mencari 'k' sedemikian rupa sehingga modulus dengan setiap elemen array adalah sama | Mencetak semua k sedemikian rupa sehingga ar [i] % k adalah sama untuk semua i; menyusun nombor; Perbezaan maksimum akan menjadi perbezaan antara elemen pertama dan terakhir yang disusun; Kes apabila semua elemen array adalah sama; Cari semua pembahagi D dan simpan dalam vektor V []; Semak setiap v [i] jika modulus dengan setiap elemen array adalah sama atau tidak; Memeriksa setiap elemen array jika modulus dengan k adalah sama dengan k atau tidak; jika cek adalah cetak benar v [i]; Kaedah Pemandu", "code": "< ? php function printEqualModNumbers ( $ arr , $ n ) { sort ( $ arr ) ; $ d = $ arr [ $ n - 1 ] - $ arr [ 0 ] ; if ( d == 0 ) { print ( \" Infinite ▁ solution \" ) ; return ; } $ v = array ( ) ; for ( $ i = 1 ; $ i * $ i <= $ d ; $ i ++ ) { if ( $ d % $ i == 0 ) { array_push ( $ v , $ i ) ; if ( $ i != $ d / $ i ) array_push ( $ v , $ d / $ i ) ; } } for ( $ i = 0 ; $ i < count ( $ v ) ; $ i ++ ) { $ temp = $ arr [ 0 ] % $ v [ $ i ] ; $ j = 1 ; for ( ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ j ] % $ v [ $ i ] != $ temp ) break ; if ( $ j == $ n ) print ( $ v [ $ i ] . \" ▁ \" ) ; } } $ arr = array ( 38 , 6 , 34 ) ; printEqualModNumbers ( $ arr , count ( $ arr ) ) ; ? >"}
{"text": "Digit pertama dalam produk pelbagai nombor | Mengembalikan digit pertama produk elemen ARR []; menyimpan logaritma produk elemen ARR []; pecahan (s) = s - lantai (s); ans = 10 ^ fract_s; Kod pemacu", "code": "< ? php function FirstDigit ( $ arr , $ n ) { $ S = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ S = $ S + log10 ( $ arr [ $ i ] * 1.0 ) ; $ fract_S = $ S - floor ( $ S ) ; $ ans = pow ( 10 , $ fract_S ) ; return floor ( $ ans ) ; } $ arr = array ( 5 , 8 , 3 , 7 ) ; $ n = sizeof ( $ arr ) ; echo FirstDigit ( $ arr , $ n ) ; ? >"}
{"text": "Cari kiraan digit dalam nombor yang membahagikan nombor | Kembalikan bilangan digit yang membahagikan nombor tersebut. ; Mengambil setiap digit nombor; Memeriksa jika digit lebih besar daripada 0 dan boleh membahagikan n. ; Kod pemacu", "code": "< ? php function countDigit ( $ n ) { $ temp = $ n ; $ count = 0 ; while ( $ temp != 0 ) { $ d = $ temp % 10 ; $ temp /= 10 ; if ( $ d > 0 && $ n % $ d == 0 ) $ count ++ ; } return $ count ; } $ n = 1012 ; echo countDigit ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Integer positif minimum untuk membahagikan nombor supaya hasilnya adalah ganjil | Berfungsi untuk mencari nilai; Kembali 1 jika sudah ganjil; Semak berapa kali ia dibahagikan dengan 2; Kod pemacu", "code": "< ? php function makeOdd ( $ n ) { if ( $ n % 2 != 0 ) return 1 ; $ resul = 1 ; while ( $ n % 2 == 0 ) { $ n /= 2 ; $ resul *= 2 ; } return $ resul ; } $ n = 36 ; echo makeOdd ( $ n ) ; ? >"}
{"text": "Pelbagai x paling dekat dengan n | Berfungsi untuk mengira pelbagai terkecil; Kod pemacu", "code": "< ? php function closestMultiple ( $ n , $ x ) { if ( $ x > $ n ) return $ x ; $ n = $ n + $ x / 2 ; $ n = $ n - ( $ n % $ x ) ; return $ n ; } $ n = 9 ; $ x = 4 ; echo closestMultiple ( $ n , $ x ) ; ? >"}
{"text": "Kiub sempurna dalam julat | Penyelesaian yang cekap untuk mencetak kiub sempurna antara a dan b; Cari akar kiub kedua -dua A dan B; Cetak kiub antara ACRT dan BCRT; Kod pemacu", "code": "< ? php function printCubes ( $ a , $ b ) { $ acrt = ( int ) pow ( $ a , 1 / 3 ) ; $ bcrt = ( int ) pow ( $ b , 1 / 3 ) ; for ( $ i = $ acrt ; $ i <= $ bcrt ; $ i ++ ) if ( $ i * $ i * $ i >= $ a && $ i * $ i * $ i <= $ b ) echo $ i * $ i * $ i , \" ▁ \" ; } $ a = 24 ; $ b = 576 ; echo \" Perfect ▁ cubes ▁ in ▁ given ▁ range : STRNEWLINE \" , printCubes ( $ a , $ b ) ; ? >"}
{"text": "Bilangan kejadian 2 sebagai digit dalam nombor dari 0 hingga n | Mengira bilangan digit '2' dalam satu nombor; Mengira bilangan digit '2' antara 0 dan n; Memulakan hasil; Kira 2 dalam setiap nombor dari 2 hingga N; Kod pemacu", "code": "< ? php function number0f2s ( $ n ) { $ count = 0 ; while ( $ n > 0 ) { if ( $ n % 10 == 2 ) $ count ++ ; $ n = $ n / 10 ; } return $ count ; } function numberOf2sinRange ( $ n ) { $ count = 0 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ count += number0f2s ( $ i ) ; return $ count ; } echo ( numberOf2sinRange ( 22 ) ) ; echo \" STRNEWLINE \" ; echo numberOf2sinRange ( 100 ) ; ? >"}
{"text": "Togol minimum untuk memisahkan array binari supaya ia mempunyai 0 s pertama kemudian 1 s | Fungsi untuk mengira toggling minimum yang diperlukan dengan menggunakan pengaturcaraan dinamik; Isi penyertaan dalam sifar [] sedemikian rupa sehingga sifar kiraan sifar di sebelah kiri i (exl; jika sifar didapati kemas kini sifar [] array; mencari toggle minimum yang diperlukan dari setiap indeks (0 hingga n - 1);", "code": "< ? php function minToggle ( $ arr , $ n ) { $ zero [ 0 ] = 0 ; $ zero [ $ n + 1 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { if ( $ arr [ $ i - 1 ] == 0 ) $ zero [ $ i ] = $ zero [ $ i - 1 ] + 1 ; else $ zero [ $ i ] = $ zero [ $ i - 1 ] ; } $ ans = $ n ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ ans = min ( $ ans , $ i - $ zero [ $ i ] + $ zero [ $ n ] - $ zero [ $ i ] ) ; return $ ans ; } $ arr = array ( 1 , 0 , 1 , 1 , 0 ) ; $ n = sizeof ( $ arr ) ; echo minToggle ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika sebilangan besar boleh dibahagikan dengan 6 atau tidak | Berfungsi untuk mencari nombor yang boleh dibahagikan dengan 6 atau tidak; Kembali palsu jika nombor tidak dapat dibahagikan dengan 2 .; Mengira jumlah digit; Semak sama ada jumlah digit boleh dibahagikan dengan 3; Kod pemacu", "code": "< ? php function check ( $ str ) { $ n = strlen ( $ str ) ; if ( ( $ str [ $ n - 1 ] - '0' ) % 2 != 0 ) return false ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 3 == 0 ) ; } $ str = \"1332\" ; if ( check ( $ str ) ) echo \" Yes \" ; else echo \" ▁ No ▁ \" ; return 0 ; ? >"}
{"text": "Cari cara integer boleh dinyatakan sebagai jumlah n | Program PHP untuk mencari bilangan cara untuk mengekspresikan nombor sebagai jumlah kuasa nombor. ; Pembalut atas checkRecursive (); Kod pemacu", "code": "< ? php $ res = 0 ; function checkRecursive ( $ num , $ x , $ k , $ n ) { global $ res ; if ( $ x == 0 ) $ res ++ ; $ r = ( int ) floor ( pow ( $ num , 1.0 / $ n ) ) ; for ( $ i = $ k + 1 ; $ i <= $ r ; $ i ++ ) { $ a = $ x - ( int ) pow ( $ i , $ n ) ; if ( $ a >= 0 ) checkRecursive ( $ num , $ x - ( int ) pow ( $ i , $ n ) , $ i , $ n ) ; } return $ res ; } function check ( $ x , $ n ) { return checkRecursive ( $ x , $ x , 0 , $ n ) ; } echo ( check ( 10 , 2 ) ) ; ? >"}
{"text": "N 'Th Palindrome of K digit | Fungsi utiliti untuk membalikkan nombor n; Fungsi Boolean untuk memeriksa nombor palindromik; Fungsi untuk mencari palindrome n digit K; Dapatkan nombor digit terkecil; Semak nombornya adalah palindrom atau tidak; Jika palindrome n 'th mendapati memecahkan gelung; Nombor kenaikan untuk memeriksa palindrome seterusnya; Kod pemacu", "code": "< ? php function reverseNum ( $ n ) { $ rem ; $ rev = 0 ; while ( $ n ) { $ rem = $ n % 10 ; $ rev = ( $ rev * 10 ) + $ rem ; $ n = ( int ) ( $ n / 10 ) ; } return $ rev ; } function isPalindrom ( $ num ) { return $ num == reverseNum ( $ num ) ; } function nthPalindrome ( $ n , $ k ) { $ num = pow ( 10 , $ k - 1 ) ; while ( true ) { if ( isPalindrom ( $ num ) ) -- $ n ; if ( ! $ n ) break ; ++ $ num ; } return $ num ; } $ n = 6 ; $ k = 5 ; echo $ n , \" th ▁ palindrome ▁ of ▁ \" , $ k , \" ▁ digit ▁ = ▁ \" , nthPalindrome ( $ n , $ k ) , \" STRNEWLINE \" ; $ n = 10 ; $ k = 6 ; echo $ n , \" th ▁ palindrome ▁ of ▁ \" , $ k , \" ▁ digit ▁ = ▁ \" , nthPalindrome ( $ n , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text": "N 'Th Palindrome of K digit | Program PHP mencari palindrome dari K digit; Tentukan angka separuh pertama; Cetak separuh digit Palindrome; Jika k adalah ganjil, memotong digit terakhir; Cetak separuh angka terakhir Palindrome; Kod pemacu", "code": "< ? php function nthPalindrome ( $ n , $ k ) { $ temp = ( $ k & 1 ) ? ( int ) ( $ k / 2 ) : ( int ) ( $ k / 2 - 1 ) ; $ palindrome = ( int ) pow ( 10 , $ temp ) ; $ palindrome += $ n - 1 ; print ( $ palindrome ) ; if ( $ k & 1 ) $ palindrome = ( int ) ( $ palindrome / 10 ) ; while ( $ palindrome > 0 ) { print ( $ palindrome % 10 ) ; $ palindrome = ( int ) ( $ palindrome / 10 ) ; } print ( \" STRNEWLINE \" ) ; } $ n = 6 ; $ k = 5 ; print ( $ n . \" th ▁ palindrome ▁ of ▁ $ k ▁ digit ▁ = ▁ \" ) ; nthPalindrome ( $ n , $ k ) ; $ n = 10 ; $ k = 6 ; print ( $ n . \" th ▁ palindrome ▁ of ▁ $ k ▁ digit ▁ = ▁ \" ) ; nthPalindrome ( $ n , $ k ) ; ? >"}
{"text": "Summation of GCD semua pasangan sehingga n | Pendekatan PHP mencari jumlah GCD semua pasangan; PHI [i] menyimpan fungsi Euler Totient untuk hasil [J] hasil untuk nilai j; Precomputation nombor Phi []. Rujuk pautan untuk butiran: https: goo. gl / luqdty; Rujuk https: goo. gl / luqdty; Precomputes hasil untuk semua nombor sehingga max; Precompute semua nilai phi; Melontarkan semua pembahagi i. ; Tambah penjumlahan jumlah yang dikira sebelumnya; Berfungsi untuk mengira jumlah semua pasangan GCD", "code": "< ? php $ MAX = 100001 ; $ phi = array_fill ( 0 , $ MAX , 0 ) ; $ result = array_fill ( 0 , $ MAX , 0 ) ; function computeTotient ( ) { global $ MAX , $ phi ; $ phi [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) { if ( ! $ phi [ $ i ] ) { $ phi [ $ i ] = $ i - 1 ; for ( $ j = ( $ i << 1 ) ; $ j < $ MAX ; $ j += $ i ) { if ( ! $ phi [ $ j ] ) $ phi [ $ j ] = $ j ; $ phi [ $ j ] = ( $ phi [ $ j ] / $ i ) * ( $ i - 1 ) ; } } } } function sumOfGcdPairs ( ) { global $ MAX , $ phi , $ result ; computeTotient ( ) ; for ( $ i = 1 ; $ i < $ MAX ; ++ $ i ) { for ( $ j = 2 ; $ i * $ j < $ MAX ; ++ $ j ) $ result [ $ i * $ j ] += $ i * $ phi [ $ j ] ; } for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) $ result [ $ i ] += $ result [ $ i - 1 ] ; } sumOfGcdPairs ( ) ; $ N = 4 ; echo \" Summation ▁ of ▁ \" . $ N . \" ▁ = ▁ \" . $ result [ $ N ] . \" STRNEWLINE \" ; $ N = 12 ; echo \" Summation ▁ of ▁ \" . $ N . \" ▁ = ▁ \" . $ result [ $ N ] . \" STRNEWLINE \" ; $ N = 5000 ; echo \" Summation ▁ of ▁ \" . $ N . \" ▁ = ▁ \" . $ result [ $ N ] . \" STRNEWLINE \" ; ? >"}
{"text": "Cari koordinat segitiga yang diberikan tengah titik setiap sisi | Program PHP untuk mencari koordinat segitiga yang diberi titik tengah setiap sisi; Kembali selepas menyelesaikan persamaan dan mencari koordinat simpang. ; Mencari jumlah tiga koordinat. ; Menyelesaikan persamaan. ; Menemukan simpul segitiga dari simpang tengah yang diberikan. ; Cari x koordinat simpang. ; Cari koordinat y vertices. ; Output penyelesaian. ; Kod pemacu", "code": "< ? php $ N = 3 ; function solve ( $ v ) { $ res = array ( ) ; $ all3 = $ v [ 0 ] + $ v [ 1 ] + $ v [ 2 ] ; array_push ( $ res , $ all3 - $ v [ 1 ] * 2 ) ; array_push ( $ res , $ all3 - $ v [ 2 ] * 2 ) ; array_push ( $ res , $ all3 - $ v [ 0 ] * 2 ) ; return $ res ; } function findVertex ( $ xmid , $ ymid ) { $ V1 = solve ( $ xmid ) ; $ V2 = solve ( $ ymid ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) print ( $ V1 [ $ i ] . \" ▁ \" . $ V2 [ $ i ] . \" STRNEWLINE \" ) ; } $ xmid = array ( 5 , 4 , 5 ) ; $ ymid = array ( 3 , 4 , 5 ) ; findVertex ( $ xmid , $ ymid ) ? >"}
{"text": "N | Kembalikan nombor n dalam senarai disusun gandaan dua nombor. ; Menjana Pertama n Pelbagai a. ; Menyusun urutan. ; Menjana dan Menyimpan Pertama N Pelbagai B dan menyimpan jika tidak hadir dalam urutan. ; Jika tidak hadir dalam urutan; Menyimpan dalam urutan. ; Kod pemacu", "code": "< ? php function nthElement ( $ a , $ b , $ n ) { $ seq = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) array_push ( $ seq , $ a * $ i ) ; sort ( $ seq ) ; for ( $ i = 1 , $ k = $ n ; $ i <= $ n && $ k > 0 ; $ i ++ ) { if ( array_search ( $ b * $ i , $ seq ) == 0 ) { array_push ( $ seq , $ b * $ i ) ; sort ( $ seq ) ; $ k -- ; } } return $ seq [ $ n - 1 ] ; } $ a = 3 ; $ b = 5 ; $ n = 5 ; echo nthElement ( $ a , $ b , $ n ) ; ? >"}
{"text": "Kira pasangan nombor semula jadi dengan GCD sama dengan nombor yang diberikan | Kembalikan GCD dua nombor. ; Kembalikan kiraan pasangan yang mempunyai GCD sama dengan g. ; Menetapkan nilai L, r. ; Untuk setiap pasangan yang mungkin semak jika GCD adalah 1 .; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { return $ b ? gcd ( $ b , $ a % $ b ) : $ a ; } function countGCD ( $ L , $ R , $ g ) { $ L = ( $ L + $ g - 1 ) / $ g ; $ R = $ R / $ g ; $ ans = 0 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) for ( $ j = $ L ; $ j <= $ R ; $ j ++ ) if ( gcd ( $ i , $ j ) == 1 ) $ ans ++ ; return $ ans ; } $ L = 1 ; $ R = 11 ; $ g = 5 ; echo countGCD ( $ L , $ R , $ g ) ; ? >"}
{"text": "Terakhir bukan | Memulakan nilai angka bukan sifar yang terakhir dari 0 hingga 9; Semak sama ada puluhan (atau kedua terakhir) digit adalah ganjil atau walaupun n = 375, jadi n / 10 = 37 dan (n / 10) % 10 = 7 memohon formula untuk kes -kes yang lebih dan ganjil. ; Kod pemacu", "code": "< ? php $ dig = array ( 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 ) ; function lastNon0Digit ( $ n ) { global $ dig ; if ( $ n < 10 ) return $ dig [ $ n ] ; if ( ( ( $ n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( $ n / 5 ) * $ dig [ $ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( $ n / 5 ) * $ dig [ $ n % 10 ] ) % 10 ; } $ n = 14 ; echo ( lastNon0Digit ( $ n ) ) ; ? >"}
{"text": "Cari nombor semulajadi pertama yang faktorial dapat dibahagikan dengan x | Fungsi GCD untuk mengira pembahagi terbesar di kalangan A dan B; Mengembalikan nombor pertama yang faktorial membahagikan x. ; Hasil; Keluarkan faktor biasa; Kami menjumpai pertama i. ; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( ( $ a % $ b ) == 0 ) return $ b ; return gcd ( $ b , $ a % $ b ) ; } function firstFactorialDivisibleNumber ( $ x ) { $ i = 1 ; $ new_x = $ x ; for ( $ i = 1 ; $ i < $ x ; $ i ++ ) { $ new_x /= gcd ( $ i , $ new_x ) ; if ( $ new_x == 1 ) break ; } return $ i ; } $ x = 16 ; echo ( firstFactorialDivisibleNumber ( $ x ) ) ; ? >"}
{"text": "Cari digit tertinggi dalam nombor utama dalam julat | Ayak eratosthenes; Mengembalikan angka maksimum yang berlaku dalam prima dari L ke R. ; Mencari nombor utama sehingga r. ; Kekerapan permulaan semua digit hingga 0 .; Untuk semua nombor antara L ke R, periksa jika Perdana atau tidak. Jika Perdana, meningkatkan kekerapan digit yang terdapat dalam nombor Perdana. ; $ p = $ i; Sekiranya saya adalah perdana; Mencari digit dengan kekerapan tertinggi. ; Kod pemacu", "code": "< ? php function sieve ( & $ prime , $ n ) { for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == false ) for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = true ; } } function maxDigitInPrimes ( $ L , $ R ) { $ prime = array_fill ( 0 , $ R + 1 , false ) ; sieve ( $ prime , $ R ) ; $ freq = array_fill ( 0 , 10 , 0 ) ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { if ( ! $ prime [ $ i ] ) { while ( $ p ) { $ freq [ $ p % 10 ] ++ ; $ p = ( int ) ( $ p / 10 ) ; } } } $ max = $ freq [ 0 ] ; $ ans = 0 ; for ( $ j = 1 ; $ j < 10 ; $ j ++ ) { if ( $ max <= $ freq [ $ j ] ) { $ max = $ freq [ $ j ] ; $ ans = $ j ; } } return $ ans ; } $ L = 1 ; $ R = 20 ; echo maxDigitInPrimes ( $ L , $ R ) ; ? >"}
{"text": "Pembahagi Biasa Dua Nombor | Berfungsi untuk mengira GCD dua nombor; Fungsi untuk mengira semua pembahagi biasa dua nombor tertentu A, B -> Input Integer Number; Cari GCD A, B; Mengira pembahagi n. ; jika 'i' adalah faktor n; Semak jika pembahagi adalah sama; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function commDiv ( $ a , $ b ) { $ n = gcd ( $ a , $ b ) ; $ result = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ result += 1 ; else $ result += 2 ; } } return $ result ; } $ a = 12 ; $ b = 24 ; echo ( commDiv ( $ a , $ b ) ) ; ? >"}
{"text": "Kira cara untuk mengeja nombor dengan digit berulang | Berfungsi untuk mengira semua jampi yang mungkin nombor dengan digit berulang Num -> rentetan yang merupakan nombor kegemaran; kiraan akhir jumlah mantra yang mungkin; berulang melalui nombor lengkap; mengira kekerapan bersebelahan angka tertentu [i]; Hitung 2 ^ (Count - 1) dan Garab dengan hasil; Kod pemacu", "code": "< ? php function spellsCount ( $ num ) { $ n = strlen ( $ num ) ; $ result = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 1 ; while ( $ i < $ n - 1 && $ num [ $ i + 1 ] == $ num [ $ i ] ) { $ count ++ ; $ i ++ ; } $ result = $ result * pow ( 2 , $ count - 1 ) ; } return $ result ; } $ num = \"11112\" ; echo spellsCount ( $ num ) ; ? >"}
{"text": "Nombor gembira | Kaedah utiliti untuk mengembalikan jumlah persegi digit n; Kaedah kembali benar jika n adalah nombor gembira; memulakan perlahan dan cepat oleh n; gerakkan nombor perlahan dengan satu lelaran; Pindahkan nombor cepat dengan dua lelaran; Jika kedua -dua nombor bertemu pada 1, maka kembali benar; Kod pemacu", "code": "< ? php function numSquareSum ( $ n ) { $ squareSum = 0 ; while ( $ n ) { $ squareSum += ( $ n % 10 ) * ( $ n % 10 ) ; $ n /= 10 ; } return $ squareSum ; } function isHappynumber ( $ n ) { $ slow ; $ fast ; $ slow = $ n ; $ fast = $ n ; do { $ slow = numSquareSum ( $ slow ) ; $ fast = numSquareSum ( numSquareSum ( $ fast ) ) ; } while ( $ slow != $ fast ) ; return ( $ slow == 1 ) ; } $ n = 13 ; if ( isHappynumber ( $ n ) ) echo $ n , \" ▁ is ▁ a ▁ Happy ▁ number STRNEWLINE \" ; else echo n , \" ▁ is ▁ not ▁ a ▁ Happy ▁ number STRNEWLINE \" ; ? >"}
{"text": "Count Pembahagi Factorial | AllPrimes [] menyimpan semua nombor utama kurang daripada atau sama dengan n. ; Mengisi di atas vektor allprimes [] untuk n yang diberikan; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Gelung untuk mengemas kini perdana []; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Menyimpan prima dalam vektor AllPrimes; Fungsi untuk mencari semua hasil nombor faktorial; Memulakan hasil; Cari eksponen semua prima yang membahagikan n dan kurang daripada n; Pembahagi semasa; Cari kuasa tertinggi (disimpan dalam exp) Allprimes [i] yang membahagikan n menggunakan formula Legendre. ; Mengadili eksponen semua prima kurang daripada n; mengembalikan jumlah pembahagi; Kod pemacu", "code": "< ? php $ allPrimes = array ( ) ; function sieve ( $ n ) { global $ allPrimes ; $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) if ( $ prime [ $ p ] ) array_push ( $ allPrimes , $ p ) ; } function factorialDivisors ( $ n ) { global $ allPrimes ; $ result = 1 ; for ( $ i = 0 ; $ i < count ( $ allPrimes ) ; $ i ++ ) { $ p = $ allPrimes [ $ i ] ; $ exp = 0 ; while ( $ p <= $ n ) { $ exp = $ exp + ( int ) ( $ n / $ p ) ; $ p = $ p * $ allPrimes [ $ i ] ; } $ result = $ result * ( $ exp + 1 ) ; } return $ result ; } echo factorialDivisors ( 6 ) ; ? >"}
{"text": "Non Fibonacci Nombor | Mengembalikan nombor bukan fibonacci; Curr adalah untuk menjejaki nombor Fibonacci semasa, sebelum ini, sebelumnya, sebelumnya adalah sebelumnya. ; Walaupun kiraan nombor bukan fibonacci tidak menjadi negatif atau sifar; Logik nombor fibonacci mudah; (curr - prev - 1) adalah kiraan nombor bukan fibonacci antara curr dan prev. ; n mungkin negatif sekarang. Pastikan ia menjadi positif dengan mengeluarkan jurang tambahan yang terakhir. ; Sekarang tambahkan n positif ke nombor fibonacci sebelumnya untuk mencari n 'th non-fibonacci. ; Kod pemacu", "code": "< ? php function nonFibonacci ( $ n ) { $ prevPrev = 1 ; $ prev = 2 ; $ curr = 3 ; while ( $ n > 0 ) { $ prevPrev = $ prev ; $ prev = $ curr ; $ curr = $ prevPrev + $ prev ; $ n = $ n - ( $ curr - $ prev - 1 ) ; } $ n = $ n + ( $ curr - $ prev - 1 ) ; return $ prev + $ n ; } echo nonFibonacci ( 5 ) ; ? >"}
{"text": "Algoritma Stein untuk Mencari GCD | Berfungsi untuk melaksanakan algoritma Stein; GCD (0, b) == B; Gcd (a, 0) == a, gcd (0, 0) == 0; Menemukan k, di mana k adalah kuasa terbesar 2 yang membahagikan kedua -dua a dan b. ; Membahagikan A dengan 2 sehingga A menjadi ganjil; Dari sini, 'A' sentiasa ganjil. ; Sekiranya B adalah, keluarkan semua faktor 2 dalam B; Sekarang A dan B adalah kedua -duanya ganjil. Swap jika perlu jadi a <= b, kemudian tetapkan b = b - a (yang juga); memulihkan faktor umum 2; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; $ k ; for ( $ k = 0 ; ( ( $ a $ b ) & 1 ) == 0 ; ++ $ k ) { $ a >>= 1 ; $ b >>= 1 ; } while ( ( $ a & 1 ) == 0 ) $ a >>= 1 ; do { while ( ( $ b & 1 ) == 0 ) $ b >>= 1 ; if ( $ a > $ b ) swap ( $ a , $ b ) ; $ b = ( $ b - $ a ) ; } while ( $ b != 0 ) ; return $ a << $ k ; } $ a = 34 ; $ b = 17 ; echo \" Gcd ▁ of ▁ given ▁ numbers ▁ is ▁ \" . gcd ( $ a , $ b ) ; ? >"}
{"text": "Cetak semua n | N -> Nilai Input Out -> Indeks Arus Output -> Indeks Digit Seterusnya untuk diisi dalam Output Array Evensum, Oddsum -> Jumlah Digit Even dan Ganjil setakat ini; Kes asas; Jika nombor menjadi n - digit; Jika perbezaan mutlak antara jumlah angka Even dan ganjil adalah 1, cetak nombor; Jika indeks semasa adalah ganjil, maka tambahkannya kepada jumlah ganjil dan recurse; lain -lain menambah jumlah dan recurse; Ini terutamanya pembungkus atas findndigitnumsutil. Ia secara eksplisit mengendalikan digit terkemuka dan panggilan findnDigitNumsUtil () untuk indeks yang tinggal. ; Arahan output untuk menyimpan nombor N - digit; Inisialisasi indeks nombor dianggap setakat ini; Inisialisasi jumlah yang lebih baik dan ganjil; Secara eksplisit mengendalikan digit pertama dan hubungi fungsi rekursif findndigitnumsutil untuk indeks yang tinggal. Perhatikan bahawa digit pertama dianggap hadir dalam kedudukan walaupun. ; Program Pemandu", "code": "< ? php function findNDigitNumsUtil ( $ n , $ out , $ index , $ evenSum , $ oddSum ) { if ( $ index > $ n ) return ; if ( $ index == $ n ) { if ( abs ( $ evenSum - $ oddSum ) == 1 ) { echo implode ( \" \" , $ out ) . \" \" } return ; } if ( $ index & 1 ) { for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { $ out [ $ index ] = $ i + '0' ; findNDigitNumsUtil ( $ n , $ out , $ index + 1 , $ evenSum , $ oddSum + $ i ) ; } } { for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { $ out [ $ index ] = $ i + '0' ; findNDigitNumsUtil ( $ n , $ out , $ index + 1 , $ evenSum + $ i , $ oddSum ) ; } } } function findNDigitNums ( $ n ) { $ out = array_fill ( 0 , $ n + 1 , \" \" ) ; $ index = 0 ; $ evenSum = 0 ; $ oddSum = 0 ; for ( $ i = 1 ; $ i <= 9 ; $ i ++ ) { $ out [ $ index ] = $ i + '0' ; findNDigitNumsUtil ( $ n , $ out , $ index + 1 , $ evenSum + $ i , $ oddSum ) ; } } $ n = 3 ; findNDigitNums ( $ n ) ; ? >"}
{"text": "Program untuk menukar nombor yang diberikan kepada perkataan | Tetapkan 2 | Strings pada indeks 0 tidak digunakan, ia adalah untuk membuat pengindeksan array mudah; Strings pada indeks 0 dan 1 tidak digunakan, mereka adalah untuk membuat pengindeksan array mudah; n ialah 1 - atau 2 - nombor digit; Jika n lebih daripada 19, bahagikannya; jika n bukan sifar; Berfungsi untuk mencetak nombor yang diberikan dalam kata -kata; Kedai perwakilan perkataan nombor n; mengendalikan digit pada sepuluh juta dan ratus juta tempat (jika ada); mengendalikan digit pada seratus ribu dan satu juta tempat (jika ada); mengendalikan digit pada beribu -ribu dan puluhan ribuan tempat (jika ada); mengendalikan digit di beratus -ratus tempat (jika ada); mengendalikan digit di tempat -tempat dan puluhan (jika ada); mengendalikan panjang sehingga 9 digit tiada perubahan kepada int lama yang tidak ditandatangani untuk mengendalikan lebih banyak nombor digit; Tukar nombor yang diberikan dengan kata -kata", "code": "< ? php $ one = array ( \" \" , \" one ▁ \" , \" two ▁ \" , \" three ▁ \" , \" four ▁ \" , \" five ▁ \" , \" six ▁ \" , \" seven ▁ \" , \" eight ▁ \" , \" nine ▁ \" , \" ten ▁ \" , \" eleven ▁ \" , \" twelve ▁ \" , \" thirteen ▁ \" , \" fourteen ▁ \" , \" fifteen ▁ \" , \" sixteen ▁ \" , \" seventeen ▁ \" , \" eighteen ▁ \" , \" nineteen ▁ \" ) ; $ ten = array ( \" \" , \" \" , \" twenty ▁ \" , \" thirty ▁ \" , \" forty ▁ \" , \" fifty ▁ \" , \" sixty ▁ \" , \" seventy ▁ \" , \" eighty ▁ \" , \" ninety ▁ \" ) ; function numToWords ( $ n , $ s ) { global $ one , $ ten ; $ str = \" \" ; if ( $ n > 19 ) { $ str . = $ ten [ ( int ) ( $ n / 10 ) ] ; $ str . = $ one [ $ n % 10 ] ; } else $ str . = $ one [ $ n ] ; if ( $ n != 0 ) $ str . = $ s ; return $ str ; } function convertToWords ( $ n ) { $ out = \" \" ; $ out . = numToWords ( ( int ) ( $ n / 10000000 ) , \" crore ▁ \" ) ; $ out . = numToWords ( ( ( int ) ( $ n / 100000 ) % 100 ) , \" lakh ▁ \" ) ; $ out . = numToWords ( ( ( int ) ( $ n / 1000 ) % 100 ) , \" thousand ▁ \" ) ; $ out . = numToWords ( ( ( int ) ( $ n / 100 ) % 10 ) , \" hundred ▁ \" ) ; if ( $ n > 100 && $ n % 100 ) $ out . = \" and ▁ \" ; $ out . = numToWords ( ( $ n % 100 ) , \" \" ) ; return $ out ; } $ n = 438237764 ; echo convertToWords ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Persamaan Diophantine Linear | fungsi utiliti untuk mencari GCD dua nombor; Fungsi ini memeriksa jika penyelesaian integral mungkin; Contoh pertama; Contoh kedua; Contoh ketiga", "code": "< ? php function gcd ( $ a , $ b ) { return ( $ a % $ b == 0 ) ? abs ( $ b ) : gcd ( $ b , $ a % $ b ) ; } function isPossible ( $ a , $ b , $ c ) { return ( $ c % gcd ( $ a , $ b ) == 0 ) ; } $ a = 3 ; $ b = 6 ; $ c = 9 ; if ( isPossible ( $ a , $ b , $ c ) == true ) echo \" Possible STRNEWLINE \" ; else echo \" Not ▁ Possible STRNEWLINE \" ; $ a = 3 ; $ b = 6 ; $ c = 8 ; if ( isPossible ( $ a , $ b , $ c ) == true ) echo \" Possible STRNEWLINE \" ; else echo \" Not ▁ Possible STRNEWLINE \" ; $ a = 2 ; $ b = 5 ; $ c = 1 ; if ( isPossible ( $ a , $ b , $ c ) == true ) echo \" Possible STRNEWLINE \" ; else echo \" Not ▁ Possible STRNEWLINE \" ; ? >"}
{"text": "Urutan Farey | Fungsi yang dioptimumkan untuk mencetak urutan pesanan nasi n; Kami tahu dua syarat pertama adalah 0/1 dan 1 / n; Untuk terma seterusnya untuk dinilai; Menggunakan hubungan berulang untuk mencari istilah seterusnya; Cetak istilah seterusnya; Kemas kini X1, Y1, X2 dan Y2 untuk lelaran seterusnya; Kod pemacu", "code": "< ? php function farey ( $ n ) { $ x1 = 0 ; $ y1 = 1 ; $ x2 = 1 ; $ y2 = $ n ; echo $ x1 , \" / \" , $ y1 , \" ▁ \" , $ x2 , \" / \" , $ y2 , \" ▁ \" ; $ x ; $ y = 0 ; while ( $ y != 1.0 ) { $ x = floor ( ( $ y1 + $ n ) / $ y2 ) * $ x2 - $ x1 ; $ y = floor ( ( $ y1 + $ n ) / $ y2 ) * $ y2 - $ y1 ; echo $ x , \" / \" , $ y , \" ▁ \" ; $ x1 = $ x2 ; $ x2 = $ x ; $ y1 = $ y2 ; $ y2 = $ y ; } } $ n = 7 ; echo \" Farey ▁ Sequence ▁ of ▁ order ▁ \" , $ n , \" ▁ is STRNEWLINE \" ; farey ( $ n ) ; ? >"}
{"text": "Cari nilai terkecil x dan y sedemikian rupa sehingga kapak | Untuk mencari GCD menggunakan algoritma Eculcid; Mencetak nilai -nilai terkecil x dan y yang memuaskan \"kapak ~ ~ ~ = ~ u 0\"; Cari LCM; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return ( gcd ( $ b , $ a % $ b ) ) ; } function findSmallest ( $ a , $ b ) { $ lcm = ( $ a * $ b ) / gcd ( $ a , $ b ) ; echo \" x ▁ = ▁ \" , $ lcm / $ a , \" y = \" } $ a = 25 ; $ b = 35 ; findSmallest ( $ a , $ b ) ; ? >"}
{"text": "Kirakan N! di bawah modulo p | Fungsi utiliti untuk melakukan eksponensi modular. Ia kembali (x ^ y) % p; $ res = 1; Inisialisasi hasil $ x = $ x % $ p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; Fungsi untuk mencari songsang modular di bawah modulo p menggunakan kaedah Fermat. Asumsi: P adalah perdana; Pulangan n! % p menggunakan teorem Wilson; n! % p ialah 0 jika n> = p; Inisialisasi hasil sebagai (p - 1)! iaitu - 1 atau (p - 1); Multiply Modulo songsang semua nombor dari (n + 1) hingga p; Kod pemacu", "code": "< ? php function power ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function modInverse ( $ a , $ p ) { return power ( $ a , $ p - 2 , $ p ) ; } function modFact ( $ n , $ p ) { if ( $ p <= $ n ) return 0 ; $ res = ( $ p - 1 ) ; for ( $ i = $ n + 1 ; $ i < $ p ; $ i ++ ) $ res = ( $ res * modInverse ( $ i , $ p ) ) % $ p ; return $ res ; } $ n = 25 ; $ p = 29 ; echo modFact ( $ n , $ p ) ; ? >"}
{"text": "Mengira bilangan cara untuk membahagikan nombor dalam 4 bahagian | Mengembalikan kiraan cara; Memulakan hasil; Menjana semua kaunter kuadrup dan kenaikan yang mungkin apabila jumlah kuadruplet adalah sama dengan N; Kod pemacu", "code": "< ? php function countWays ( $ n ) { $ counter = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i ; $ j < $ n ; $ j ++ ) for ( $ k = $ j ; $ k < $ n ; $ k ++ ) for ( $ l = $ k ; $ l < $ n ; $ l ++ ) if ( $ i + $ j + $ k + $ l == $ n ) $ counter ++ ; return $ counter ; } $ n = 8 ; echo countWays ( $ n ) ; ? >"}
{"text": "Jumlah bitwise dan semua pasangan dalam array yang diberikan | Pulangan nilai \"arr [0] u arr [0] [0] [2] ur [2]. Memulakan hasil; Pertimbangkan semua pasangan (arr [i], arr [j) supaya saya <j; Kod pemacu", "code": "< ? php function pairAndSum ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ ans += $ arr [ $ i ] & $ arr [ $ j ] ; return $ ans ; } $ arr = array ( 5 , 10 , 15 ) ; $ n = sizeof ( $ arr ) ; echo pairAndSum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah bitwise dan semua pasangan dalam array yang diberikan | Pulangan nilai \"arr [0] u arr [0] [0] [2] ur [2]. Memulakan hasil; Melintasi semua bit; Kiraan bilangan elemen dengan set bit i 'th inisialisasi kiraan; Terdapat bit set k, bermakna k (k - 1) / 2 pasang. Setiap pasangan menambah 2 ^ i ke jawapannya. Oleh itu, kami menambah \"2 ^ i u u '(K * (K - 1) / 2]\" kepada jawapannya. ; Kod pemacu", "code": "< ? php function pairAndSum ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { $ k = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) ) $ k ++ ; $ ans += ( 1 << $ i ) * ( $ k * ( $ k - 1 ) / 2 ) ; } return $ ans ; } $ arr = array ( 5 , 10 , 15 ) ; $ n = sizeof ( $ arr ) ; echo pairAndSum ( $ arr , $ n ) ; ? >"}
{"text": "Ujian Primal | Tetapkan 1 (Pengenalan dan Kaedah Sekolah) | Program PHP berasaskan kaedah sekolah untuk memeriksa sama ada nombor adalah perdana; Kes sudut; Semak dari 2 hingga n - 1; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) return false ; return true ; } $ tet = isPrime ( 11 ) ? \" ▁ true STRNEWLINE \" : \" ▁ false STRNEWLINE \" ; echo $ tet ; $ tet = isPrime ( 15 ) ? \" ▁ true STRNEWLINE \" : \" ▁ false STRNEWLINE \" ; echo $ tet ; ? >"}
{"text": "Fungsi Euler untuk semua nombor yang lebih kecil daripada atau sama dengan N | Mengira dan mencetak semua nombor yang lebih kecil daripada atau sama dengan n. ; Buat dan mulakan array untuk menyimpan phi atau nilai -nilai taksis; Menunjukkan belum dinilai dan memulakan untuk formula produk. ; Mengira nilai phi lain; Jika phi [p] tidak dikira sudah, maka nombor p adalah perdana; Phi nombor utama p sentiasa sama dengan p - 1 .; Mengemas kini nilai phi semua gandaan p; Tambah sumbangan p kepada pelbagai i dengan mendarab dengan (1 - 1 / $ p); Mencetak nilai pHi yang dipraktikkan; Kod pemacu", "code": "< ? php function computeTotient ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ phi [ $ i ] = $ i ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ phi [ $ p ] == $ p ) { $ phi [ $ p ] = $ p - 1 ; for ( $ i = 2 * $ p ; $ i <= $ n ; $ i += $ p ) { $ phi [ $ i ] = ( $ phi [ $ i ] / $ p ) * ( $ p - 1 ) ; } } } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo \" Totient ▁ of ▁ \" , $ i , \" ▁ is ▁ \" , $ phi [ $ i ] , \" STRNEWLINE \" ; } $ n = 12 ; computeTotient ( $ n ) ; ? >"}
{"text": "Jumlah semua elemen antara K1 'th »dan u k2' unsur -unsur terkecil | Mengembalikan jumlah antara dua elemen terkecil dari array; Susun array yang diberikan; Kod di bawah adalah bersamaan dengan; Program Pemandu", "code": "< ? php function sumBetweenTwoKth ( $ arr , $ n , $ k1 , $ k2 ) { sort ( $ arr ) ; $ result = 0 ; for ( $ i = $ k1 ; $ i < $ k2 - 1 ; $ i ++ ) $ result += $ arr [ $ i ] ; return $ result ; } $ arr = array ( 20 , 8 , 22 , 4 , 12 , 10 , 14 ) ; $ k1 = 3 ; $ k2 = 6 ; $ n = count ( $ arr ) ; ; echo sumBetweenTwoKth ( $ arr , $ n , $ k1 , $ k2 ) ; ? >"}
{"text": "Teka -teki | Program untuk mencari bilangan kotak di papan catur | Berfungsi untuk mengembalikan kiraan kuadrat; ; Cara yang lebih baik untuk menulis n * (n + 1) * (2 n + 1) / 6; Kod pemacu", "code": "< ? php function countSquares ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; } $ n = 4 ; echo \" Count ▁ of ▁ squares ▁ is ▁ \" , countSquares ( $ n ) ; ? >"}
{"text": "Cari nombor sihir nth | Berfungsi untuk mencari nombor sihir n; Pergi melalui setiap n; Jika bit terakhir N ditetapkan; teruskan ke seterusnya $ n >> = 1; atau $ n = $ n / 2; Kod pemacu", "code": "< ? php function nthMagicNo ( $ n ) { $ pow = 1 ; $ answer = 0 ; while ( $ n ) { $ pow = $ pow * 5 ; if ( $ n & 1 ) $ answer += $ pow ; } return $ answer ; } $ n = 5 ; echo \" nth ▁ magic ▁ number ▁ is ▁ \" , nthMagicNo ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Memandangkan nombor n, hitung semua gandaan 3 dan / atau 5 dalam set {1, 2, 3, ... n} | Program PHP untuk mencari kiraan gandaan 3 dan 5 dalam {1, 2, 3 ,. . n}; Tambah gandaan 3 dan 5. Oleh kerana gandaan biasa dikira dua kali dalam n / 3 + n / 15, tolak gandaan biasa; Kod pemacu", "code": "< ? php function countOfMultiples ( $ n ) { return floor ( floor ( $ n / 3 ) + floor ( $ n / 5 ) - floor ( $ n / 15 ) ) ; } echo countOfMultiples ( 6 ) , \" STRNEWLINE \" ; echo countOfMultiples ( 16 ) ; ? >"}
{"text": "Program untuk mencari GCD atau HCF dua nombor | Fungsi rekursif untuk mengembalikan GCD A dan B; Semuanya membahagikan 0; Kes asas; A lebih besar; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; } $ a = 98 ; $ b = 56 ; echo \" GCD ▁ of ▁ $ a ▁ and ▁ $ b ▁ is ▁ \" , gcd ( $ a , $ b ) ; ? >"}
{"text": "Teori Permainan dalam Sistem Numeral Ternary Balanced | (Bergerak 3 k langkah pada satu masa) | Fungsi yang kembali benar jika permainan tidak boleh dimenangi; Kod pemacu; Panjang biasa", "code": "< ? php function isDefeat ( $ s1 , $ s2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ s1 [ $ i ] == '0' && $ s2 [ $ i ] == '1' ) || ( $ s1 [ $ i ] == '1' && $ s2 [ $ i ] == '0' ) ) continue ; else if ( ( $ s1 [ $ i ] == '0' && $ s2 [ $ i ] == ' Z ' ) || ( $ s1 [ $ i ] == ' Z ' && $ s2 [ $ i ] == '0' ) ) continue ; else { return true ; } } return false ; } $ s1 = ( \"01001101ZZ \" ) ; $ s2 = ( \"10Z1001000\" ) ; $ n = 10 ; if ( isDefeat ( $ s1 , $ s2 , $ n ) ) echo ( \" Defeat \" ) ; else echo ( \" Victory \" ) ;"}
{"text": "Semak jika Matrix A boleh ditukar kepada B dengan menukar pariti unsur sudut mana -mana submatrix | Pelaksanaan PHP pendekatan di atas; Fungsi Boolean yang kembali benar atau palsu; Melintasi semua elemen; Jika kedua -duanya tidak sama; Tukar pariti semua elemen sudut; Semak sama ada A adalah sama dengan B; Tidak sama; Matriks binari pertama; Matriks binari kedua", "code": "< ? php $ N = 3 ; $ M = 3 ; function check ( $ a , $ b ) { for ( $ i = 1 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) { for ( $ j = 1 ; $ j < $ GLOBALS [ ' M ' ] ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] != $ b [ $ i ] [ $ j ] ) { $ a [ $ i ] [ $ j ] ^= 1 ; $ a [ 0 ] [ 0 ] ^= 1 ; $ a [ 0 ] [ $ j ] ^= 1 ; $ a [ $ i ] [ 0 ] ^= 1 ; } } } for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) { for ( $ j = 0 ; $ j < $ GLOBALS [ ' M ' ] ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] != $ b [ $ i ] [ $ j ] ) return false ; } } return true ; } $ a = array ( array ( 0 , 1 , 0 ) , array ( 0 , 1 , 0 ) , array ( 1 , 0 , 0 ) ) ; $ b = array ( array ( 1 , 0 , 0 ) , array ( 1 , 0 , 0 ) , array ( 1 , 0 , 0 ) ) ; if ( check ( $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Kedudukan k | Fungsi yang mengembalikan bit set kth; Melintasi binari; Semak sama ada bit terakhir ditetapkan atau tidak; Semak sama ada kiraan adalah sama dengan k kemudian kembalikan indeks; Meningkatkan indeks ketika kita bergerak dengan betul; Pergeseran kanan nombor dengan 1; Kod pemacu", "code": "< ? php function FindIndexKthBit ( $ n , $ k ) { $ cnt = 0 ; $ ind = 0 ; while ( $ n ) { if ( $ n & 1 ) $ cnt ++ ; if ( $ cnt == $ k ) return $ ind ; $ ind ++ ; $ n = $ n >> 1 ; } return -1 ; } $ n = 15 ; $ k = 3 ; $ ans = FindIndexKthBit ( $ n , $ k ) ; if ( $ ans != -1 ) echo $ ans ; else echo \" No ▁ k - th ▁ set ▁ bit \" ; ? >"}
{"text": "Jarak antara dua nod pokok binari dengan nilai nod dari 1 hingga n | Berfungsi untuk mendapatkan jarak laluan minimum; mengira panjang bit N1 dan N2; Cari perbezaan bit dan maxbit; Hitung hasil dengan formula; Kod pemacu", "code": "< ? php function minDistance ( $ n1 , $ n2 ) { $ bitCount1 = floor ( log ( $ n1 , 2 ) ) + 1 ; $ bitCount2 = floor ( log ( $ n2 , 2 ) ) + 1 ; $ bitDiff = abs ( $ bitCount1 - $ bitCount2 ) ; $ maxBitCount = max ( $ bitCount1 , $ bitCount2 ) ; if ( $ bitCount1 > $ bitCount2 ) { $ n2 = $ n2 * pow ( 2 , $ bitDiff ) ; } else { $ n1 = $ n1 * pow ( 2 , $ bitDiff ) ; } $ xorValue = $ n1 ^ $ n2 ; $ bitCountXorValue = floor ( log ( $ xorValue , 2 ) ) + 1 ; $ disSimilarBitPosition = $ maxBitCount - $ bitCountXorValue ; $ result = $ bitCount1 + $ bitCount2 - 2 * $ disSimilarBitPosition ; return $ result ; } $ n1 = 12 ; $ n2 = 5 ; echo minDistance ( $ n1 , $ n2 ) ; ? >"}
{"text": "Keluarkan satu bit dari nombor binari untuk mendapatkan nilai maksimum | Berfungsi untuk mencari nombor binari maksimum; Melintasi nombor binari; Cuba cari 0 dan langkau; Dapatkan nombor binari; Cari nombor binari maksimum", "code": "< ? php function printMaxAfterRemoval ( $ s ) { $ flag = false ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '0' && $ flag == false ) { $ flag = true ; continue ; } else echo $ s [ $ i ] ; } } $ s = \"1001\" ; printMaxAfterRemoval ( $ s ) ; ? >"}
{"text": "Cari Kedudukan Kiri Paling Dis | Fungsi untuk mencari dis - bit serupa; kembali sifar untuk nombor yang sama; mengira panjang bit N1 dan N2; Cari perbezaan bit dan maxbit; Kod pemacu", "code": "< ? php function bitPos ( $ n1 , $ n2 ) { if ( $ n1 == $ n2 ) return 0 ; $ bitCount1 = floor ( log ( $ n1 , 2 ) ) + 1 ; $ bitCount2 = floor ( log ( $ n2 , 2 ) ) + 1 ; $ bitDiff = abs ( $ bitCount1 - $ bitCount2 ) ; $ maxBitCount = max ( $ bitCount1 , $ bitCount2 ) ; if ( $ bitCount1 > $ bitCount2 ) { $ n2 = $ n2 * pow ( 2 , $ bitDiff ) ; } else { $ n1 = $ n1 * pow ( 2 , $ bitDiff ) ; } $ xorValue = $ n1 ^ $ n2 ; $ bitCountXorValue = floor ( log ( $ xorValue , 2 ) ) + 1 ; $ disSimilarBitPosition = $ maxBitCount - $ bitCountXorValue + 1 ; return $ disSimilarBitPosition ; } $ n1 = 53 ; $ n2 = 55 ; echo bitPos ( $ n1 , $ n2 ) ; ? >"}
{"text": "Bilangan pasangan dengan bitwise atau sebagai nombor ganjil | Berfungsi untuk mengira pasangan dengan ganjil atau; Kiraan jumlah nombor walaupun dalam array; Malah kiraan pasangan; Jumlah pasangan; Kembali kiraan pasangan ganjil; Pemandu utama", "code": "< ? php function countOddPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ! ( $ A [ $ i ] & 1 ) ) $ count ++ ; $ evenPairCount = $ count * ( $ count - 1 ) / 2 ; $ totPairs = $ N * ( $ N - 1 ) / 2 ; return ( $ totPairs - $ evenPairCount ) ; } $ A = array ( 5 , 6 , 2 , 8 ) ; $ N = sizeof ( $ A ) ; echo countOddPair ( $ A , $ N ) , \" STRNEWLINE \" ; ? >"}
{"text": "Gantikan setiap elemen array oleh bitwise xor elemen sebelumnya dan seterusnya | Program PHP untuk mengemas kini setiap elemen array dengan jumlah nombor sebelumnya dan seterusnya dalam array; Tiada apa -apa kaitan apabila saiz array adalah 1; Simpan nilai semasa ARR [0] dan kemas kini; Kemas kini selebihnya elemen array; Simpan nilai semasa interaksi seterusnya; Kemas kini nilai semasa menggunakan nilai sebelumnya; Mengemas kini nilai sebelumnya; Mengemas kini elemen array terakhir secara berasingan; Kod pemacu; Cetak array yang diubah suai", "code": "< ? php function ReplaceElements ( & $ arr , $ n ) { if ( $ n <= 1 ) return ; $ prev = $ arr [ 0 ] ; $ arr [ 0 ] = $ arr [ 0 ] ^ $ arr [ 1 ] ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ curr = $ arr [ $ i ] ; $ arr [ $ i ] = $ prev ^ $ arr [ $ i + 1 ] ; $ prev = $ curr ; } $ arr [ $ n - 1 ] = $ prev ^ $ arr [ $ n - 1 ] ; } $ arr = array ( 2 , 3 , 4 , 5 , 6 ) ; $ n = sizeof ( $ arr ) ; ReplaceElements ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Cari bitwise atau semua sub | berfungsi untuk mengembalikan atau sub -tatasusunan; Kod pemacu; Cetak atau semua subarrays", "code": "< ? php function O_R ( $ a , $ n ) { $ ans = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) $ ans |= $ a [ $ i ] ; return $ ans ; } $ a = array ( 1 , 4 , 6 ) ; $ n = count ( $ a ) ; echo O_R ( $ a , $ n ) ; ? >"}
{"text": "Set bit set maksimum dalam array tanpa mempertimbangkan unsur -unsur bersebelahan | Berfungsi untuk mengira jumlah bit set dalam integer; Jumlah maksimum bit set; Kirakan jumlah bit set untuk setiap elemen array; Cari jumlah bit set untuk setiap nombor dan simpan kembali ke dalam array; Max semasa tidak termasuk i; Max semasa termasuk i; kembali max incl and excl; Kod pemacu", "code": "< ? php function bit ( $ n ) { $ count = 0 ; while ( $ n ) { $ count ++ ; $ n = $ n & ( $ n - 1 ) ; } return $ count ; } function maxSumOfBits ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ i ] = bit ( $ arr [ $ i ] ) ; } $ incl = $ arr [ 0 ] ; $ excl = 0 ; $ excl_new ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ excl_new = ( $ incl > $ excl ) ? $ incl : $ excl ; $ incl = $ excl + $ arr [ $ i ] ; $ excl = $ excl_new ; } return ( ( $ incl > $ excl ) ? $ incl : $ excl ) ; } $ arr = array ( 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo maxSumOfBits ( $ arr , $ n ) ; #This  Code is Contributed by ajit  NEW_LINE ? >"}
{"text": "Kenaikan nombor tanpa menggunakan ++ atau + | fungsi yang meningkatkan nilai. ; Membalikkan bit dan memohon tanda negatif; Kod pemacu", "code": "< ? php function increment ( $ i ) { $ i = - ( ~ ord ( $ i ) ) ; return chr ( $ i ) ; } $ n = ' a ' ; echo increment ( $ n ) ; ? >"}
{"text": "Kira pasangan dengan bitwise xor sebagai nombor ganjil | Berfungsi untuk mengira bilangan pasangan ganjil; Cari semua pasangan; pulangan bilangan pasangan ganjil; Kod pemacu; Fungsi panggilan findoddpair dan cetak nombor pasangan ganjil", "code": "< ? php function findOddPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ A [ $ i ] % 2 == 0 ) $ count ++ ; } return $ count * ( $ N - $ count ) ; } $ a = array ( 5 , 4 , 7 , 2 , 1 ) ; $ n = count ( $ a ) ; echo ( findOddPair ( $ a , $ n ) ) ; ? >"}
{"text": "Bitwise atau (atau |) pelbagai | Mengembalikan kedudukan bit yang paling ketara (MSB); Mengembalikan bitwise atau semua bilangan bulat antara L dan R; Cari kedudukan MSB dalam L; Cari kedudukan MSB dalam R; Tambah nilai ini sehingga MSB_P1 dan MSB_P2 adalah sama; ; Hitung MSB_P1 dan MSB_P2; Cari maksimum msb_p1 dan msb_p2; Tetapkan semua bit dari msb_p1 sehingga bit 0 pada hasilnya; Kod pemacu", "code": "< ? php function MSBPosition ( $ N ) { $ msb_p = -1 ; while ( $ N ) { $ N = $ N >> 1 ; $ msb_p ++ ; } return $ msb_p ; } function findBitwiseOR ( $ L , $ R ) { $ res = 0 ; $ msb_p1 = MSBPosition ( $ L ) ; $ msb_p2 = MSBPosition ( $ R ) ; while ( $ msb_p1 == $ msb_p2 ) { $ res_val = ( 1 << $ msb_p1 ) ; $ res += $ res_val ; $ L -= $ res_val ; $ R -= $ res_val ; $ msb_p1 = MSBPosition ( $ L ) ; $ msb_p2 = MSBPosition ( $ R ) ; } $ msb_p1 = max ( $ msb_p1 , $ msb_p2 ) ; for ( $ i = $ msb_p1 ; $ i >= 0 ; $ i -- ) { $ res_val = ( 1 << $ i ) ; $ res += $ res_val ; } return $ res ; } $ L = 12 ; $ R = 18 ; echo findBitwiseOR ( $ L , $ R ) ; ? >"}
{"text": "Memaksimumkan bitwise atau array | Berfungsi untuk memaksimumkan bitwise atau jumlah; Kirakan x ^ k; Cari awalan bitwise atau; Cari akhiran bitwise atau; Cari maksimum atau nilai; Kod pemacu", "code": "< ? php function maxOR ( $ arr , $ n , $ k , $ x ) { $ res ; $ pow = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ pow *= $ x ; $ preSum [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ preSum [ $ i + 1 ] = $ preSum [ $ i ] | $ arr [ $ i ] ; $ suffSum [ $ n ] = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) $ suffSum [ $ i ] = $ suffSum [ $ i + 1 ] | $ arr [ $ i ] ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = max ( $ res , $ preSum [ $ i ] | ( $ arr [ $ i ] * $ pow ) $ suffSum [ $ i + 1 ] ) ; return $ res ; } $ arr = array ( 1 , 2 , 4 , 8 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; $ x = 3 ; echo maxOR ( $ arr , $ n , $ k , $ x ) , \" STRNEWLINE \" ; ? >"}
{"text": "Bagaimana cara menghidupkan bit tertentu dalam nombor? | Mengembalikan nombor yang mempunyai semua bit sama seperti n kecuali k 'th bit yang dibuat 1; k mestilah lebih besar daripada 0; Lakukan | n dengan nombor dengan semua bit yang tidak tersendiri kecuali k 'th bit; Kod pemacu", "code": "< ? php function turnOnK ( $ n , $ k ) { if ( $ k <= 0 ) return $ n ; return ( $ n | ( 1 << ( $ k - 1 ) ) ) ; } $ n = 4 ; $ k = 2 ; echo turnOnK ( $ n , $ k ) ; ? >"}
{"text": "Jumlah minimum dua nombor yang dibentuk dari digit array | Mengembalikan jumlah dua nombor yang dibentuk dari semua digit dalam []; menyusun unsur -unsur; Kod pemacu", "code": "< ? php function minSum ( $ a , $ n ) { sort ( $ a ) ; $ num1 = 0 ; $ num2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ num1 = $ num1 * 10 + $ a [ $ i ] ; else $ num2 = $ num2 * 10 + $ a [ $ i ] ; } return ( $ num2 + $ num1 ) ; } $ arr = array ( 5 , 3 , 0 , 7 , 4 ) ; $ n = sizeof ( $ arr ) ; echo \" The ▁ required ▁ sum ▁ is ▁ \" , minSum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari nilai k | Program PHP untuk mencari k - th bit dari kanan; Kod pemacu; Panggilan fungsi", "code": "< ? php function printKthBit ( $ n , $ k ) { echo ( $ n & ( 1 << ( $ k - 1 ) ) ) ; } $ n = 13 ; $ k = 2 ; printKthBit ( $ n , $ k ) ; ? >"}
{"text": "Nombor ganjil dalam n | Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Kira nombor 1 dalam perwakilan binari n. ; Bilangan nombor ganjil dalam baris n - th adalah 2 yang dibangkitkan untuk menguasai kiraan. ; Kod pemacu", "code": "< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += $ n & 1 ; $ n >>= 1 ; } return $ count ; } function countOfOddsPascal ( $ n ) { $ c = countSetBits ( $ n ) ; return pow ( 2 , $ c ) ; } $ n = 20 ; echo countOfOddsPascal ( $ n ) ; ? >"}
{"text": "Pertanyaan pada Xor Xors Semua Subarrays | Output untuk setiap pertanyaan; Jika bilangan elemen adalah walaupun. ; Jika bilangan elemen ganjil. ; jika saya juga; jika saya ganjil; Fungsi pembalut; Menilai prefixodd dan prefixeven; Kod pemacu", "code": "< ? php function ansQueries ( $ prefeven , $ prefodd , $ l , $ r ) { if ( ( $ r - $ l + 1 ) % 2 == 0 ) { echo \"0\" ; } else { if ( $ l % 2 == 0 ) echo ( $ prefeven [ $ r ] ^ $ prefeven [ $ l - 1 ] ) ; else echo ( $ prefodd [ $ r ] ^ $ prefodd [ $ l - 1 ] ) ; } echo \" STRNEWLINE \" ; } function wrapper ( array $ arr , $ n , array $ l , array $ r , $ q ) { $ prefodd = array_fill ( 0 , 100 , 0 ) ; $ prefeven = array_fill ( 0 , 100 , 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( ( $ i ) % 2 == 0 ) { $ prefeven [ $ i ] = $ arr [ $ i - 1 ] ^ $ prefeven [ $ i - 1 ] ; $ prefodd [ $ i ] = $ prefodd [ $ i - 1 ] ; } else { $ prefeven [ $ i ] = $ prefeven [ $ i - 1 ] ; $ prefodd [ $ i ] = $ prefodd [ $ i - 1 ] ^ $ arr [ $ i - 1 ] ; } } $ i = 0 ; while ( $ i != $ q ) { ansQueries ( $ prefeven , $ prefodd , $ l [ $ i ] , $ r [ $ i ] ) ; $ i ++ ; } } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; $ l = array ( 1 , 1 , 2 ) ; $ r = array ( 2 , 3 , 4 ) ; $ q = sizeof ( $ l ) / sizeof ( $ l [ 0 ] ) ; wrapper ( $ arr , $ n , $ l , $ r , $ q ) ; ? >"}
{"text": "Variasi dalam permainan NIM | Berfungsi untuk mengembalikan nombor grundy akhir (g) permainan; Jika saiz longgokan ganjil; Kami XOR Pile Saiz + 1; Kami XOR Pile Saiz - 1; Permainan dengan 3 buasir; tumpukan dengan saiz yang berbeza; Fungsi untuk mengembalikan hasil permainan; jika ($ res == 0) jika g adalah sifar; lain jika g bukan sifar", "code": "< ? php function solve ( $ p , $ n ) { $ G = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ p [ $ i ] & 1 ) $ G ^= ( $ p [ $ i ] + 1 ) ; $ G ^= ( $ p [ $ i ] - 1 ) ; } return $ G ; } $ n = 3 ; $ p = array ( 32 , 49 , 58 ) ; $ res = solve ( $ p , $ n ) ; echo \" Player ▁ 2 ▁ wins \" ; echo \" Player ▁ 1 ▁ wins \" ; ? >"}
{"text": "Maksimum dan nilai pasangan dalam array | Fungsi utiliti untuk memeriksa bilangan elemen yang telah menetapkan MSB sebagai corak; Fungsi untuk mencari pasangan maksimum dan nilai; melangkah lebih daripada 30 bit dari MSB ke LSB; Cari kiraan elemen yang telah menetapkan MSB; jika kiraan> = 2 tetapkan bit tertentu dalam hasil; Kod pemacu", "code": "< ? php function checkBit ( $ pattern , $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( ( $ pattern & $ arr [ $ i ] ) == $ pattern ) $ count ++ ; return $ count ; } function maxAND ( $ arr , $ n ) { $ res = 0 ; $ count ; for ( $ bit = 31 ; $ bit >= 0 ; $ bit -- ) { $ count = checkBit ( $ res | ( 1 << $ bit ) , $ arr , $ n ) ; if ( $ count >= 2 ) $ res |= ( 1 << $ bit ) ; } return $ res ; } $ arr = array ( 4 , 8 , 6 , 2 ) ; $ n = count ( $ arr ) ; echo \" Maximum ▁ AND ▁ Value ▁ = ▁ \" , maxAND ( $ arr , $ n ) ; ? >"}
{"text": "Semak jika nombor adalah kuasa 8 atau tidak | berfungsi untuk memeriksa sama ada kuasa 8; Hitung log8 (n); Periksa sama ada saya adalah integer atau tidak; Kod pemacu", "code": "< ? php function checkPowerof8 ( $ n ) { $ i = log ( $ n ) / log ( 8 ) ; return ( $ i - floor ( $ i ) < 0.000001 ) ; } $ n = 65 ; if ( checkPowerof8 ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak jika perwakilan binari nombor tertentu dan pelengkapnya adalah anagram | Pulangan benar jika perwakilan binari A dan B adalah anagram. ; _POPCNT64 (a) Memberi bilangan 1 yang hadir dalam perwakilan binari a. Jika bilangan 1s adalah separuh daripada jumlah bit, kembali benar. ; Kod pemacu", "code": "< ? php function bit_anagram_check ( $ a ) { $ longSize = 8 ; $ ULL_SIZE = 8 * $ longSize ; return ( BitCount ( $ a ) == ( $ ULL_SIZE >> 1 ) ) ; } function BitCount ( $ n ) { $ count = 0 ; while ( $ n != 0 ) { $ count ++ ; $ n &= ( $ n - 1 ) ; } return $ count ; } $ a = 4294967295 ; echo ( bit_anagram_check ( $ a ) ) ; ? >"}
{"text": "Jumlah nombor dengan tepat 2 bit set | Untuk mengira jumlah nombor; Cari nombor yang 2 bit ditetapkan; Jika nombor lebih besar maka kita tidak termasuk ini dalam jumlah; Mengembalikan jumlah nombor; Kod pemacu", "code": "< ? php function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; ( 1 << $ i ) < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { $ num = ( 1 << $ i ) + ( 1 << $ j ) ; if ( $ num <= $ n ) $ sum += $ num ; } } return $ sum ; } $ n = 10 ; echo findSum ( $ n ) ; ? >"}
{"text": "Kedudukan Bit yang paling berbeza | Fungsi untuk mencari bit paling jauh dalam dua nombor. ; Kod pemacu", "code": "< ? php function posOfRightMostDiffBit ( $ m , $ n ) { $ t = floor ( log ( $ m ^ $ n , 2 ) ) ; return $ t ; } $ m = 52 ; $ n = 4 ; echo \" Position ▁ = ▁ \" , posOfRightMostDiffBit ( $ m , $ n ) ; ? >"}
{"text": "Tetapkan k | fungsi untuk menetapkan bit kth; KTH bit n sedang ditetapkan oleh operasi ini; Kod pemacu", "code": "< ? php function setKthBit ( $ n , $ k ) { return ( ( 1 << $ k ) $ n ) ; } $ n = 10 ; $ k = 2 ; echo \" Kth ▁ bit ▁ set ▁ number ▁ = ▁ \" , setKthBit ( $ n , $ k ) ; ? >"}
{"text": "Membalikkan array tanpa menggunakan tanda tolak â € ~ | Fungsi untuk membalikkan array; Trick To Ganti - 1 kepada pembolehubah; Arahan terbalik dengan cara yang mudah; Swap nilai indeks dengan (n - i - 1) nilai indeks; Kod pemacu; Cetak pelbagai terbalik", "code": "< ? php function reverseArray ( & $ arr , $ n ) { $ x = ( PHP_INT_MIN / PHP_INT_MAX ) ; for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) swap ( $ arr , $ i , $ n + ( $ x * $ i ) + $ x ) ; } function swap ( & $ arr , $ i , $ j ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ temp ; return $ arr ; } $ arr = array ( 5 , 3 , 7 , 2 , 1 , 6 ) ; $ n = sizeof ( $ arr ) ; reverseArray ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ $ i ] . \" ▁ \" ) ;"}
{"text": "Membalikkan array tanpa menggunakan tanda tolak â € ~ | Fungsi untuk membalikkan array; Arahan terbalik dengan cara yang mudah; SWAP ITH Nilai Indeks dengan (N - I - 1) Nilai Indeks Nota: a - b = a + ~ b + 1 jadi n - i = n + ~ i + 1 maka n - i - 1 = (n + ~ i + 1) + 1 + 1; Kod pemacu; Cetak pelbagai terbalik", "code": "< ? php function reverseArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) { swap ( $ arr , $ i , ( $ n + ~ $ i + 1 ) + ~ 1 + 1 ) ; } } function swap ( & $ arr , $ i , $ j ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ temp ; return $ arr ; } { $ arr = array ( 5 , 3 , 7 , 2 , 1 , 6 ) ; $ n = sizeof ( $ arr ) ; reverseArray ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo ( $ arr [ $ i ] . \" \" ) ; } }"}
{"text": "Nilai XOR maksimum pasangan dari julat | kaedah untuk mendapatkan nilai XOR maksimum dalam julat [L, R]; Dapatkan Xor had; gelung untuk mendapatkan kedudukan MSB l ^ r; Membina hasil dengan menambah 1, MSBPOS kali; Kod pemacu", "code": "< ? php function maxXORInRange ( $ L , $ R ) { $ LXR = $ L ^ $ R ; $ msbPos = 0 ; while ( $ LXR ) { $ msbPos ++ ; $ LXR >>= 1 ; } $ maxXOR = 0 ; $ two = 1 ; while ( $ msbPos -- ) { $ maxXOR += $ two ; $ two <<= 1 ; } return $ maxXOR ; } $ L = 8 ; $ R = 20 ; echo maxXORInRange ( $ L , $ R ) , \" STRNEWLINE \" ; ? >"}
{"text": "Nombor yang bitwise atau dan jumlah dengan n adalah sama | Berfungsi untuk mencari jumlah 0 bit dalam nombor; Fungsi untuk mencari kiraan nombor bukan negatif kurang daripada atau sama dengan n, yang bitwise atau dan jumlah dengan n adalah sama. ; kiraan bilangan sifar bit dalam n; kuasa 2 untuk dikira; Kod pemacu", "code": "< ? php function CountZeroBit ( $ n ) { $ count = 0 ; while ( $ n ) { if ( ! ( $ n & 1 ) ) $ count ++ ; $ n >>= 1 ; } return $ count ; } function CountORandSumEqual ( $ N ) { $ count = CountZeroBit ( $ N ) ; return ( 1 << $ count ) ; } $ N = 10 ; echo CountORandSumEqual ( $ N ) ; ? >"}
{"text": "Kira nombor yang lebih kecil yang XOR dengan N menghasilkan nilai yang lebih besar | Program PHP untuk mengira nombor yang XOR dengan N menghasilkan nilai lebih daripada n. ; Kedudukan bit semasa dalam n; Memulakan hasil; Jika bit semasa adalah 0, maka terdapat nombor 2 ^ k dengan bit semasa 1 dan yang XOR dengan n menghasilkan nilai yang lebih besar; Meningkatkan kedudukan untuk bit seterusnya; Kurangkan n untuk mencari bit seterusnya; Kod pemacu", "code": "< ? php function countNumbers ( $ n ) { $ k = 0 ; $ count = 0 ; while ( $ n > 0 ) { if ( ( $ n & 1 ) == 0 ) $ count += pow ( 2 , $ k ) ; $ k += 1 ; $ n >>= 1 ; } return $ count ; } $ n = 11 ; echo countNumbers ( $ n ) ; ? >"}
{"text": "Gandaan 4 (kaedah yang menarik) | Pulangan benar jika n adalah pelbagai 4 .; Cari xor semua nombor dari 1 hingga n; Jika xor adalah sama n, maka kembali benar; Mencetak gandaan 4 menggunakan kaedah di atas", "code": "< ? php function isMultipleOf4 ( $ n ) { if ( $ n == 1 ) return false ; $ XOR = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ XOR = $ XOR ^ $ i ; return ( $ XOR == $ n ) ; } for ( $ n = 0 ; $ n <= 42 ; $ n ++ ) if ( isMultipleOf4 ( $ n ) ) echo $ n , \" ▁ \" ; ? >"}
{"text": "Gandaan 4 (kaedah yang menarik) | Pulangan benar jika n adalah pelbagai 4 .; Mencetak gandaan 4 menggunakan kaedah di atas", "code": "< ? php function isMultipleOf4 ( $ n ) { if ( $ n == 0 ) return true ; return ( ( ( $ n >> 2 ) << 2 ) == $ n ) ; } for ( $ n = 0 ; $ n <= 42 ; $ n ++ ) if ( isMultipleOf4 ( $ n ) ) echo $ n , \" ▁ \" ; ? >"}
{"text": "Semak jika nombor adalah suram | Fungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari lulus no binari. ; Fungsi untuk mengembalikan siling log x dalam asas 2. Sebagai contoh, ia mengembalikan 3 untuk 8 dan 4 untuk 9 .; Pulangan benar jika n adalah suram; Semak semua nombor 'x' lebih kecil daripada n. Jika x + countsetBits (x) menjadi n, maka n tidak boleh menjadi suram; Kod pemacu", "code": "< ? php function countSetBits ( $ x ) { $ count = 0 ; while ( $ x ) { $ x &= ( $ x - 1 ) ; $ count ++ ; } return $ count ; } function ceilLog2 ( $ x ) { $ count = 0 ; $ x -- ; while ( $ x > 0 ) { $ x = $ x >> 1 ; $ count ++ ; } return $ count ; } function isBleak ( $ n ) { for ( $ x = $ n - ceilLog2 ( $ n ) ; $ x < $ n ; $ x ++ ) if ( $ x + countSetBits ( $ x ) == $ n ) return false ; return true ; } if ( isBleak ( 3 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; if ( isBleak ( 4 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Kira tali dengan berturut -turut 1 's | Mengembalikan kiraan N panjang binari rentetan dengan berturut -turut 1 's; Kira rentetan binari tanpa berturut -turut 1.  Lihat pendekatan yang dibincangkan BE (http: goo.gl/p8a3sw); Tolak a [n - 1] + b [n - 1] dari 2 ^ n; Kod pemacu", "code": "< ? php function countStrings ( $ n ) { $ a [ $ n ] = 0 ; $ b [ $ n ] = 0 ; $ a [ 0 ] = $ b [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = $ a [ $ i - 1 ] + $ b [ $ i - 1 ] ; $ b [ $ i ] = $ a [ $ i - 1 ] ; } return ( 1 << $ n ) - $ a [ $ n - 1 ] - $ b [ $ n - 1 ] ; } echo countStrings ( 5 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Jarak sel terdekat yang mempunyai 1 dalam matriks binari | Program PHP untuk mencari jarak sel terdekat yang mempunyai 1 dalam matriks binari. ; Cetak jarak sel terdekat yang mempunyai 1 untuk setiap sel. ; Mulakan matriks jawapan dengan int_max. ; Untuk setiap sel; Melintasi keseluruhan matriks untuk mencari jarak minimum. ; Jika sel mengandungi 1, periksa jarak minimum. ; Mencetak jawapannya. ; Kod pemacu", "code": "< ? php $ N = 3 ; $ M = 4 ; function printDistance ( $ mat ) { global $ N , $ M ; $ ans = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ M ; $ j ++ ) $ ans [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { for ( $ k = 0 ; $ k < $ N ; $ k ++ ) for ( $ l = 0 ; $ l < $ M ; $ l ++ ) { if ( $ mat [ $ k ] [ $ l ] == 1 ) $ ans [ $ i ] [ $ j ] = min ( $ ans [ $ i ] [ $ j ] , abs ( $ i - $ k ) + abs ( $ j - $ l ) ) ; } } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) echo $ ans [ $ i ] [ $ j ] , \" ▁ \" ; echo \" STRNEWLINE \" ; } } $ mat = array ( array ( 0 , 0 , 0 , 1 ) , array ( 0 , 0 , 1 , 1 ) , array ( 0 , 1 , 1 , 0 ) ) ; printDistance ( $ mat ) ; ? >"}
{"text": "Perintah Tahap yang diberikan dari Pokok Binari, periksa sama ada pokok itu adalah min | Pulangan benar jika traversal perintah yang diberikan adalah tumpukan min. ; Nod bukan daun pertama berada di indeks (n / 2 - 1). Semak sama ada setiap ibu bapa lebih besar daripada kanak -kanak; Kanak -kanak kiri akan berada di Indeks 2 * i + 1 anak kanan akan berada di Indeks 2 * i + 2; Jika ibu bapa lebih besar daripada anak yang betul; Kod pemacu", "code": "< ? php function isMinHeap ( $ level , $ n ) { for ( $ i = ( $ n / 2 - 1 ) ; $ i >= 0 ; $ i -- ) { if ( $ level [ $ i ] > $ level [ 2 * $ i + 1 ] ) return false ; if ( 2 * $ i + 2 < $ n ) { if ( $ level [ $ i ] > $ level [ 2 * $ i + 2 ] ) return false ; } } return true ; } $ level = array ( 10 , 15 , 14 , 25 , 30 ) ; $ n = sizeof ( $ level ) ; if ( isMinHeap ( $ level , $ n ) ) echo \" True \" ; else echo \" False \" ;"}
{"text": "Elemen yang paling kerap dalam array | Program PHP untuk mencari elemen yang paling kerap dalam array. ; Susun array; Cari kekerapan maksimum menggunakan traversal linear; Jika elemen terakhir adalah paling kerap; Kod pemacu", "code": "< ? php function mostFrequent ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ max_count = 1 ; $ res = $ arr [ 0 ] ; $ curr_count = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) $ curr_count ++ ; else { if ( $ curr_count > $ max_count ) { $ max_count = $ curr_count ; $ res = $ arr [ $ i - 1 ] ; } $ curr_count = 1 ; } } if ( $ curr_count > $ max_count ) { $ max_count = $ curr_count ; $ res = $ arr [ $ n - 1 ] ; } return $ res ; } { $ arr = array ( 1 , 5 , 2 , 1 , 3 , 2 , 1 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo mostFrequent ( $ arr , $ n ) ; return 0 ; } ? >"}
{"text": "Bagaimana untuk memeriksa sama ada dua set yang diberikan adalah disjoint? | Pulangan benar jika set1 [] dan set2 [] adalah disjoint, lain -lain palsu; Ambil setiap elemen set1 [] dan cari dalam SET2; Jika tiada elemen set1 terdapat dalam SET2; Kod pemacu", "code": "< ? php function areDisjoint ( $ set1 , $ set2 , $ m , $ n ) { for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ set1 [ $ i ] == $ set2 [ $ j ] ) return false ; return true ; } $ set1 = array ( 12 , 34 , 11 , 9 , 3 ) ; $ set2 = array ( 7 , 2 , 1 , 5 ) ; $ m = sizeof ( $ set1 ) ; $ n = sizeof ( $ set2 ) ; if ( areDisjoint ( $ set1 , $ set2 , $ m , $ n ) == true ) echo \" Yes \" ; else echo \" ▁ No \" ; ? >"}
{"text": "Cari unsur -unsur yang terdapat dalam array pertama dan tidak di tempat kedua | Fungsi untuk mencari unsur -unsur yang ada di [] tetapi tidak dalam b []. ; Kod pemacu", "code": "< ? php function findMissing ( $ a , $ b , $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ a [ $ i ] == $ b [ $ j ] ) break ; if ( $ j == $ m ) echo $ a [ $ i ] , \" ▁ \" ; } } $ a = array ( 1 , 2 , 6 , 3 , 4 , 5 ) ; $ b = array ( 2 , 4 , 3 , 1 , 0 ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; findMissing ( $ a , $ b , $ n , $ m ) ; ? >"}
{"text": "Semak jika dua tatasusunan sama atau tidak | Pulangan benar jika arr1 [0 .. n - 1] dan arr2 [0 .. M - 1] mengandungi elemen yang sama. ; Jika panjang array tidak sama dengan cara array tidak sama; Menyusun kedua -dua tatasusunan; Linear membandingkan unsur -unsur; Jika semua elemen sama. ; Kod pemacu", "code": "< ? php function areEqual ( $ arr1 , $ arr2 , $ n , $ m ) { if ( $ n != $ m ) return false ; sort ( $ arr1 ) ; sort ( $ arr2 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr1 [ $ i ] != $ arr2 [ $ i ] ) return false ; return true ; } $ arr1 = array ( 3 , 5 , 2 , 5 , 2 ) ; $ arr2 = array ( 2 , 3 , 5 , 5 , 2 ) ; $ n = count ( $ arr1 ) ; $ m = count ( $ arr2 ) ; if ( areEqual ( $ arr1 , $ arr2 , $ n , $ m ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Pasangan dengan produk yang diberikan | Tetapkan 1 (cari jika ada pasangan) | Pulangan benar jika terdapat pasangan dalam arr [0. n - 1] dengan produk sama dengan x. ; Pertimbangkan semua pasangan yang mungkin dan periksa setiap pasangan. ; Kod pemacu", "code": "< ? php function isProduct ( $ arr , $ n , $ x ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] * $ arr [ $ j ] == $ x ) return true ; return false ; } $ arr = array ( 10 , 20 , 9 , 40 ) ; $ x = 400 ; $ n = count ( $ arr ) ; if ( isProduct ( $ arr , $ n , $ x ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; $ x = 190 ; if ( isProduct ( $ arr , $ n , $ x ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Cari pasangan dengan produk terbaik dalam Array | Berfungsi untuk mencari nombor terbesar; Kod pemacu", "code": "< ? php function findGreatest ( $ arr , $ n ) { $ result = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ j ] * $ arr [ $ k ] == $ arr [ $ i ] ) $ result = max ( $ result , $ arr [ $ i ] ) ; return $ result ; } $ arr = array ( 30 , 10 , 9 , 3 , 35 ) ; $ n = count ( $ arr ) ; echo findGreatest ( $ arr , $ n ) ; ? >"}
{"text": "Kira pasangan dengan jumlah yang diberikan | Mengembalikan bilangan pasangan dalam arr [0. n - 1] dengan jumlah yang sama dengan 'jumlah'; Memulakan hasil; Pertimbangkan semua pasangan yang mungkin dan periksa jumlah mereka; Kod pemacu", "code": "< ? php function getPairsCount ( $ arr , $ n , $ sum ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] == $ sum ) $ count ++ ; return $ count ; } $ arr = array ( 1 , 5 , 7 , -1 , 5 ) ; $ n = sizeof ( $ arr ) ; $ sum = 6 ; echo \" Count ▁ of ▁ pairs ▁ is ▁ \" , getPairsCount ( $ arr , $ n , $ sum ) ; ? >"}
{"text": "Kira pasangan dari dua susunan yang disusun yang jumlahnya sama dengan nilai tertentu x | fungsi untuk mengira semua pasangan dari kedua -dua susunan yang disusun yang jumlahnya sama dengan nilai yang diberikan; Menjana pasangan dari kedua -dua tatasusunan; jika jumlah pasangan adalah sama dengan kiraan kenaikan 'x'; kiraan pasangan yang diperlukan; Kod pemacu", "code": "< ? php function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ arr1 [ $ i ] + $ arr2 [ $ j ] ) == $ x ) $ count ++ ; return $ count ; } $ arr1 = array ( 1 , 3 , 5 , 7 ) ; $ arr2 = array ( 2 , 3 , 5 , 8 ) ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; $ x = 10 ; echo \" Count ▁ = ▁ \" , countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) ; ? >"}
{"text": "Kira pasangan dari dua susunan yang disusun yang jumlahnya sama dengan nilai tertentu x | fungsi untuk mencari 'nilai' dalam array yang diberikan 'arr []' ia menggunakan teknik carian binari sebagai 'arr []' disusun; nilai yang dijumpai; nilai tidak dijumpai; fungsi untuk mengira semua pasangan dari kedua -dua susunan yang disusun yang jumlahnya sama dengan nilai yang diberikan; untuk setiap arr1 [i]; Semak sama ada 'nilai' hadir dalam 'arr2 []'; kiraan pasangan yang diperlukan; Kod pemacu", "code": "< ? php function isPresent ( $ arr , $ low , $ high , $ value ) { while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( $ arr [ $ mid ] == $ value ) return true ; else if ( $ arr [ $ mid ] > $ value ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return false ; } function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ value = $ x - $ arr1 [ $ i ] ; if ( isPresent ( $ arr2 , 0 , $ n - 1 , $ value ) ) $ count ++ ; } return $ count ; } $ arr1 = array ( 1 , 3 , 5 , 7 ) ; $ arr2 = array ( 2 , 3 , 5 , 8 ) ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; $ x = 10 ; echo \" Count ▁ = ▁ \" , countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) ; ? >"}
{"text": "Kira pasangan dari dua susunan yang disusun yang jumlahnya sama dengan nilai tertentu x | fungsi untuk mengira semua pasangan dari kedua -dua susunan yang disusun yang jumlahnya sama dengan nilai yang diberikan; melintasi 'arr1 []' dari kiri ke kanan melintasi 'arr2 []' dari kanan ke kiri; Jika jumlah ini sama dengan 'x', maka kenaikan 'l', pengurangan 'r' dan kenaikan 'kiraan'; Jika jumlah ini kurang daripada x, maka kenaikan l; lain pengurangan 'r'; kiraan pasangan yang diperlukan; Kod pemacu", "code": "< ? php function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l < $ m and $ r >= 0 ) { if ( ( $ arr1 [ $ l ] + $ arr2 [ $ r ] ) == $ x ) { $ l ++ ; $ r -- ; $ count ++ ; } else if ( ( $ arr1 [ $ l ] + $ arr2 [ $ r ] ) < $ x ) $ l ++ ; else $ r -- ; } return $ count ; } $ arr1 = array ( 1 , 3 , 5 , 7 ) ; $ arr2 = array ( 2 , 3 , 5 , 8 ) ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; $ x = 10 ; echo \" Count ▁ = ▁ \" , countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) ; ? >"}
{"text": "Count quadruples dari empat susunan yang disusun yang jumlahnya sama dengan nilai yang diberikan x | Cari 'nilai' dalam array yang diberikan 'ARR []' Teknik carian binari digunakan; 'nilai' dijumpai; 'nilai' tidak dijumpai; fungsi untuk mengira semua kuadrup dari empat susunan yang disusun yang jumlahnya sama dengan nilai x yang diberikan; menjana semua tiga kali ganda dari tiga tatasusunan tiga; Kirakan jumlah elemen dalam triplet yang dijana; Semak jika 'x - t' hadir dalam array ke -4 atau tidak; kiraan kenaikan; kiraan kuadrup yang diperlukan; Empat susunan disusun setiap saiz 'n'", "code": "< ? php function isPresent ( $ arr , $ low , $ high , $ value ) { while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( $ arr [ $ mid ] == $ value ) return true ; else if ( $ arr [ $ mid ] > $ value ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return false ; } function countQuadruples ( $ arr1 , $ arr2 , $ arr3 , $ arr4 , $ n , $ x ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { $ T = $ arr1 [ $ i ] + $ arr2 [ $ j ] + $ arr3 [ $ k ] ; if ( isPresent ( $ arr4 , 0 , $ n , $ x - $ T ) ) $ count ++ ; } return $ count ; } $ arr1 = array ( 1 , 4 , 5 , 6 ) ; $ arr2 = array ( 2 , 3 , 7 , 8 ) ; $ arr3 = array ( 1 , 4 , 6 , 10 ) ; $ arr4 = array ( 2 , 4 , 7 , 8 ) ; $ n = sizeof ( $ arr1 ) ; $ x = 30 ; echo \" Count = \" ? >"}
{"text": "Kiraan pasangan yang produknya ada dalam array | Mengembalikan kiraan pasangan yang produknya wujud di arr []; Cari produk dalam pelbagai; jika produk mendapati kaunter kenaikan; Kembali kiraan semua pasangan yang produknya wujud dalam pelbagai; Kod pemacu", "code": "< ? php function countPairs ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ product = $ arr [ $ i ] * $ arr [ $ j ] ; for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ k ] == $ product ) { $ result ++ ; break ; } } } } return $ result ; } $ arr = array ( 6 , 2 , 4 , 12 , 5 , 3 ) ; $ n = sizeof ( $ arr ) ; echo countPairs ( $ arr , $ n ) ;"}
{"text": "Teorem Guru untuk Mengurangkan dan Menakluk Kembalikan | Kod PHP untuk pendekatan di atas; Kod pemacu", "code": "< ? php function fib ( $ n ) { if ( $ n <= 1 ) return $ n ; return fib ( $ n - 1 ) + fib ( $ n - 2 ) ; } $ n = 9 ; echo fib ( $ n ) ; ? >"}
{"text": "Rekursi Tail | Fungsi rekursif ekor untuk mengira faktorial; Pembungkus ke atas facttr; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function factTR ( $ n , $ a ) { if ( $ n == 0 ) return $ a ; return factTR ( $ n - 1 , $ n * $ a ) ; } function fact ( $ n ) { return factTR ( $ n , 1 ) ; } echo fact ( 5 ) ; ? >"}
{"text": "Memandangkan dua susunan yang tidak disusun, cari semua pasangan yang jumlahnya adalah x | Berfungsi untuk mencetak semua pasangan dalam kedua -dua array yang jumlahnya sama dengan nilai yang diberikan x; Kod pemacu", "code": "< ? php function findPairs ( $ arr1 , $ arr2 , $ n , $ m , $ x ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ arr1 [ $ i ] + $ arr2 [ $ j ] == $ x ) echo $ arr1 [ $ i ] . \" ▁ \" . $ arr2 [ $ j ] . \" STRNEWLINE \" ; } $ arr1 = array ( 1 , 2 , 3 , 7 , 5 , 4 ) ; $ arr2 = array ( 0 , 7 , 4 , 3 , 2 , 1 ) ; $ n = count ( $ arr1 ) ; $ m = count ( $ arr2 ) ; $ x = 8 ; findPairs ( $ arr1 , $ arr2 , $ n , $ m , $ x ) ; ? >"}
{"text": "Cari pasangan dalam array yang jumlahnya sudah ada dalam array | Berfungsi untuk mencari pasangan yang jumlahnya wujud dalam arr []; Kod pemacu", "code": "< ? php function findPair ( $ arr , $ n ) { $ found = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ i ] + $ arr [ $ j ] == $ arr [ $ k ] ) { echo $ arr [ $ i ] , \" ▁ \" , $ arr [ $ j ] ; $ found = true ; } } } } if ( $ found == false ) echo \" Not ▁ exist \" ; } $ arr = array ( 10 , 4 , 8 , 13 , 5 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; findPair ( $ arr , $ n ) ; ? >"}
{"text": "Cari semua pasangan (a, b) dalam array sedemikian rupa sehingga a % b = k | Berfungsi untuk mencari pasangan seperti itu (a % b = k); Pertimbangkan setiap pasangan; Cetak jika modulo mereka sama dengan k; Kod pemacu", "code": "< ? php function printPairs ( $ arr , $ n , $ k ) { $ isPairFound = true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i != $ j && $ arr [ $ i ] % $ arr [ $ j ] == $ k ) { echo \" ( \" , $ arr [ $ i ] , \" , ▁ \" , $ arr [ $ j ] , \" ) \" , \" ▁ \" ; $ isPairFound = true ; } } } return $ isPairFound ; } $ arr = array ( 2 , 3 , 5 , 4 , 7 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; if ( printPairs ( $ arr , $ n , $ k ) == false ) echo \" No ▁ such ▁ pair ▁ exists \" ; ? >"}
{"text": "Kembali maksimum aksara yang berlaku dalam rentetan input | Program PHP untuk mengeluarkan watak maksimum yang berlaku dalam rentetan; Buat array untuk mengekalkan kiraan aksara individu dan memulakan array sebagai 0; Membina pelbagai kiraan aksara dari rentetan input. ; Memulakan kiraan max; Melintasi rentetan dan mengekalkan kiraan setiap watak; Kod pemacu", "code": "< ? php $ ASCII_SIZE = 256 ; function getMaxOccuringChar ( $ str ) { global $ ASCII_SIZE ; $ count = array_fill ( 0 , $ ASCII_SIZE , NULL ) ; $ len = strlen ( $ str ) ; $ max = 0 ; for ( $ i = 0 ; $ i < ( $ len ) ; $ i ++ ) { $ count [ ord ( $ str [ $ i ] ) ] ++ ; if ( $ max < $ count [ ord ( $ str [ $ i ] ) ] ) { $ max = $ count [ ord ( $ str [ $ i ] ) ] ; $ result = $ str [ $ i ] ; } } return $ result ; } $ str = \" sample ▁ string \" ; echo \" Max ▁ occurring ▁ character ▁ is ▁ \" . getMaxOccuringChar ( $ str ) ; ? >"}
{"text": "Bukan | Program PHP mudah untuk mencari elemen yang tidak berulang. ; Kod pemacu", "code": "< ? php function firstNonRepeating ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ i != $ j && $ arr [ $ i ] == $ arr [ $ j ] ) break ; if ( $ j == $ n ) return $ arr [ $ i ] ; } return -1 ; } $ arr = array ( 9 , 4 , 9 , 6 , 7 , 4 ) ; $ n = sizeof ( $ arr ) ; echo firstNonRepeating ( $ arr , $ n ) ; ? >"}
{"text": "Subarray tanpa pasangan yang boleh dibahagi dengan k | berfungsi untuk mencari subarray tanpa pasangan yang boleh dibahagikan dengan k; Jadual Hash untuk menyimpan baki yang diperolehi dengan membahagikan oleh k; S: Memulakan indeks subarray semasa, E: Mengakhiri indeks subarray semasa, Maxs: Memulakan indeks subarray saiz maksimum setakat ini, Maxe: mengakhiri indeks subarray saiz maksimum setakat ini; Masukkan elemen pertama dalam set; Mengeluarkan unsur -unsur permulaan subarray semasa semasa terdapat elemen dalam set yang membuat pasangan dengan mod [i] supaya jumlah pasangan itu dapat dibahagikan. ; termasuk elemen semasa dalam subarray semasa indeks akhir kenaikan subarray semasa oleh satu; Bandingkan saiz subarray semasa dengan saiz maksimum setakat ini; Kod pemacu", "code": "< ? php function subarrayDivisibleByK ( $ arr , $ n , $ k ) { $ mp = array_fill ( 0 , 1000 , 0 ) ; $ s = 0 ; $ e = 0 ; $ maxs = 0 ; $ maxe = 0 ; $ mp [ $ arr [ 0 ] % $ k ] ++ ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ mod = $ arr [ $ i ] % $ k ; while ( $ mp [ $ k - $ mod ] != 0 || ( $ mod == 0 && $ mp [ $ mod ] != 0 ) ) { $ mp [ $ arr [ $ s ] % $ k ] -- ; $ s ++ ; } $ mp [ $ mod ] ++ ; $ e ++ ; if ( ( $ e - $ s ) > ( $ maxe - $ maxs ) ) { $ maxe = $ e ; $ maxs = $ s ; } } echo ( \" The ▁ maximum ▁ size ▁ is ▁ \" . ( $ maxe - $ maxs + 1 ) . \" ▁ and ▁ the ▁ subarray ▁ is \" . \" ▁ as ▁ follows STRNEWLINE \" ) ; for ( $ i = $ maxs ; $ i <= $ maxe ; $ i ++ ) echo ( $ arr [ $ i ] . \" ▁ \" ) ; } $ k = 3 ; $ arr = array ( 5 , 10 , 15 , 20 , 25 ) ; $ n = count ( $ arr ) ; subarrayDivisibleByK ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Cari tiga elemen dari tiga tatasusunan yang berbeza seperti A + B + C = SUM | Fungsi untuk memeriksa sama ada terdapat elemen dari setiap array sedemikian rupa sehingga jumlah tiga elemen adalah sama dengan jumlah yang diberikan. ; Kod pemacu", "code": "< ? php function findTriplet ( $ a1 , $ a2 , $ a3 , $ n1 , $ n2 , $ n3 , $ sum ) { for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ n2 ; $ j ++ ) for ( $ k = 0 ; $ k < $ n3 ; $ k ++ ) if ( $ a1 [ $ i ] + $ a2 [ $ j ] + $ a3 [ $ k ] == $ sum ) return true ; return false ; } $ a1 = array ( 1 , 2 , 3 , 4 , 5 ) ; $ a2 = array ( 2 , 3 , 6 , 1 , 2 ) ; $ a3 = array ( 3 , 2 , 4 , 5 , 6 ) ; $ sum = 9 ; $ n1 = count ( $ a1 ) ; $ n2 = count ( $ a2 ) ; $ n3 = count ( $ a3 ) ; if ( findTriplet ( $ a1 , $ a2 , $ a3 , $ n1 , $ n2 , $ n3 , $ sum ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Sisipan minimum untuk membentuk palindrome dengan permutasi yang dibenarkan | Fungsi akan mengembalikan bilangan aksara yang akan ditambah; Untuk menyimpan panjang rentetan; Untuk menyimpan bilangan aksara yang berlaku pada masa yang ganjil; Untuk menyimpan kiraan setiap watak; Untuk menyimpan kejadian setiap watak; Untuk mengira aksara dengan kejadian ganjil; Sebagai satu watak boleh menjadi ganjil kembali res - 1 tetapi jika rentetan sudah Palindrome kembali 0; Program Pemandu", "code": "< ? php function minInsertion ( $ str ) { $ n = strlen ( $ str ) ; $ res = 0 ; $ count = array ( 26 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ count [ $ i ] % 2 == 1 ) $ res ++ ; } return ( $ res == 0 ) ? 0 : $ res - 1 ; } $ str = \" geeksforgeeks \" ; echo ( minInsertion ( $ str ) ) ; ? >"}
{"text": "Perbezaan antara frekuensi tertinggi dan paling tidak dalam array | Kod PHP untuk mencari perbezaan antara fungsi frekuensi tertinggi dan paling kurang yang mengembalikan perbezaan; Susun array; memeriksa elemen berturut -turut; Kod pemacu", "code": "< ? php function findDiff ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 0 ; $ max_count = 0 ; $ min_count = $ n ; for ( $ i = 0 ; $ i < ( $ n - 1 ) ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) { $ count += 1 ; continue ; } else { $ max_count = max ( $ max_count , $ count ) ; $ min_count = min ( $ min_count , $ count ) ; $ count = 0 ; } } return ( $ max_count - $ min_count ) ; } $ arr = array ( 7 , 8 , 4 , 5 , 4 , 1 , 1 , 7 , 7 , 2 , 5 ) ; $ n = sizeof ( $ arr ) ; echo ( findDiff ( $ arr , $ n ) . \" \" ) ; ? >"}
{"text": "Perbezaan maksimum dua subset dari array | fungsi untuk subset maksimum diff; jika kekerapan mana -mana elemen adalah dua membuat kedua -duanya sama dengan sifar; Kod pemacu", "code": "< ? php function maxDiff ( $ arr , $ n ) { $ SubsetSum_1 = 0 ; $ SubsetSum_2 = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ isSingleOccurance = true ; for ( $ j = $ i + 1 ; $ j <= $ n - 1 ; $ j ++ ) { if ( $ arr [ $ i ] == $ arr [ $ j ] ) { $ isSingleOccurance = false ; $ arr [ $ i ] = $ arr [ $ j ] = 0 ; break ; } } if ( $ isSingleOccurance ) { if ( $ arr [ $ i ] > 0 ) $ SubsetSum_1 += $ arr [ $ i ] ; else $ SubsetSum_2 += $ arr [ $ i ] ; } } return abs ( $ SubsetSum_1 - $ SubsetSum_2 ) ; } $ arr = array ( 4 , 2 , -3 , 3 , -2 , -2 , 8 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum ▁ Difference ▁ = ▁ \" , maxDiff ( $ arr , $ n ) ; ? >"}
{"text": "Perbezaan maksimum dua subset dari array | fungsi untuk subset maksimum diff; Susun array; Hitung hasilnya; Semak elemen terakhir; hasil pulangan; Kod pemacu", "code": "< ? php function maxDiff ( $ arr , $ n ) { $ result = 0 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] ) $ result += abs ( $ arr [ $ i ] ) ; else $ i ++ ; } if ( $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) $ result += abs ( $ arr [ $ n - 1 ] ) ; return $ result ; } $ arr = array ( 4 , 2 , -3 , 3 , -2 , -2 , 8 ) ; $ n = count ( $ arr ) ; echo \" Maximum ▁ Difference ▁ = ▁ \" , maxDiff ( $ arr , $ n ) ; ? >"}
{"text": "Cetak semua tiga kali ganda dalam array yang disusun yang membentuk AP | Berfungsi untuk mencetak semua tiga kali ganda dalam pelbagai disusun yang dibentuk yang membentuk AP; Gunakan hash untuk mencari jika terdapat elemen sebelumnya dengan perbezaan yang sama dengan arr [j] - arr [i]; Kod pemacu", "code": "< ? php function printAllAPTriplets ( $ arr , $ n ) { $ s = array ( ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ diff = $ arr [ $ j ] - $ arr [ $ i ] ; if ( in_array ( $ arr [ $ i ] - $ diff , $ arr ) ) echo ( ( $ arr [ $ i ] - $ diff ) . \" \" ▁ . ▁ $ arr [ $ i ] ▁ . ▁ \" \" ▁ . ▁ $ arr [ $ j ] ▁ . ▁ \" \" } array_push ( $ s , $ arr [ $ i ] ) ; } } $ arr = array ( 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ) ; $ n = count ( $ arr ) ; printAllAPTriplets ( $ arr , $ n ) ; ? >"}
{"text": "Cetak semua tiga kali ganda dalam array yang disusun yang membentuk AP | Berfungsi untuk mencetak semua tiga kali ganda dalam pelbagai disusun yang dibentuk yang membentuk AP; Cari dua elemen lain AP dengan ARR [i] sebagai tengah. ; jika triplet dijumpai; Oleh kerana unsur -unsur berbeza, arr [k] dan arr [j] tidak dapat membentuk lebih banyak tiga kali ganda dengan arr [i]; Jika elemen tengah lebih bergerak ke sisi yang lebih tinggi, lain bergerak lebih rendah. ; Kod pemacu", "code": "< ? php function findAllTriplets ( $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = $ i - 1 , $ k = $ i + 1 ; $ j >= 0 && $ k < $ n { if ( $ arr [ $ j ] + $ arr [ $ k ] == 2 * $ arr [ $ i ] ) { echo $ arr [ $ j ] . \" ▁ \" . $ arr [ $ i ] . \" ▁ \" . $ arr [ $ k ] . \" STRNEWLINE \" ; $ k ++ ; $ j -- ; } else if ( $ arr [ $ j ] + $ arr [ $ k ] < 2 * $ arr [ $ i ] ) $ k ++ ; else $ j -- ; } } } $ arr = array ( 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ) ; $ n = count ( $ arr ) ; findAllTriplets ( $ arr , $ n ) ; ? >"}
{"text": "Kira bilangan tiga kali ganda dengan produk yang sama dengan nombor yang diberikan | Berfungsi untuk mengira tiga kali ganda; Pertimbangkan semua tiga kali ganda dan hitung jika produk mereka sama dengan m; Kod pemacu", "code": "< ? php function countTriplets ( $ arr , $ n , $ m ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] == $ m ) $ count ++ ; return $ count ; } $ arr = array ( 1 , 4 , 6 , 2 , 3 , 8 ) ; $ n = sizeof ( $ arr ) ; $ m = 24 ; echo countTriplets ( $ arr , $ n , $ m ) ; ? >"}
{"text": "Kira pasangan indeks dengan elemen yang sama dalam array | Kembalikan bilangan pasangan dengan nilai yang sama. ; untuk setiap indeks i dan j; Mencari indeks dengan nilai yang sama tetapi indeks yang berbeza. ; Kod yang didorong", "code": "< ? php function countPairs ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ ans ++ ; return $ ans ; } $ arr = array ( 1 , 1 , 2 ) ; $ n = count ( $ arr ) ; echo countPairs ( $ arr , $ n ) ; ? >"}
{"text": "Pertanyaan untuk menjawab bilangan yang dan sifar di sebelah kiri indeks yang diberikan | Fungsi untuk pra - hitung array kiri []; Berulang dalam array binari; Memulakan bilangan 1 dan 0; Meningkatkan kiraan; Kod pemacu; Pertanyaan; Menyelesaikan pertanyaan", "code": "< ? php function preCalculate ( $ binary , $ n ) { $ left = array ( ) ; $ count1 = 0 ; $ count0 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ left [ $ i ] = array ( $ count1 , $ count0 ) ; if ( $ binary [ $ i ] ) $ count1 ++ ; else $ count0 ++ ; } return $ left ; } $ binary = array ( 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ) ; $ n = count ( $ binary ) ; $ left = preCalculate ( $ binary , $ n ) ; $ queries = array ( 0 , 1 , 2 , 4 ) ; $ q = count ( $ queries ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo $ left [ $ queries [ $ i ] ] [ 0 ] , \" ▁ ones ▁ \" , $ left [ $ queries [ $ i ] ] [ 1 ] , \" ▁ zeros STRNEWLINE \" ; ? >"}
{"text": "Partition Array menjadi tiga segmen jumlah yang sama | Indeks akhir segmen pertama; Indeks permulaan segmen ketiga; Fungsi ini kembali benar jika array boleh dibahagikan kepada tiga segmen jumlah yang sama; Array Jumlah Awalan; Suffix jumlah array; Menyimpan jumlah jumlah array; Kita juga boleh mengambil pra [pos2 - 1] - pra [pos1] == total_sum / 3 di sini. ; Kod pemacu", "code": "< ? php $ pos1 = -1 ; $ pos2 = -1 ; function equiSumUtil ( $ arr ) { global $ pos2 , $ pos1 ; $ n = count ( $ arr ) ; $ pre = array_fill ( 0 , $ n , 0 ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ pre [ $ i ] = $ sum ; } $ suf = array_fill ( 0 , $ n , 0 ) ; $ sum = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ sum += $ arr [ $ i ] ; $ suf [ $ i ] = $ sum ; } $ total_sum = $ sum ; $ i = 0 ; $ j = $ n - 1 ; while ( $ i < $ j - 1 ) { if ( $ pre [ $ i ] == $ total_sum / 3 ) { $ pos1 = $ i ; } if ( $ suf [ $ j ] == $ total_sum / 3 ) { $ pos2 = $ j ; } if ( $ pos1 != -1 && $ pos2 != -1 ) { if ( $ suf [ $ pos1 + 1 ] - $ suf [ $ pos2 ] == $ total_sum / 3 ) { return true ; } else { return false ; } } if ( $ pre [ $ i ] < $ suf [ $ j ] ) { $ i ++ ; } else { $ j -- ; } } return false ; } function equiSum ( $ arr ) { global $ pos2 , $ pos1 ; $ ans = equiSumUtil ( $ arr ) ; if ( $ ans ) { print ( \" First ▁ Segment ▁ : ▁ \" ) ; for ( $ i = 0 ; $ i <= $ pos1 ; $ i ++ ) { print ( $ arr [ $ i ] . \" \" ) ; } print ( \" STRNEWLINE \" ) ; print ( \" Second ▁ Segment ▁ : ▁ \" ) ; for ( $ i = $ pos1 + 1 ; $ i < $ pos2 ; $ i ++ ) { print ( $ arr [ $ i ] . \" \" ) ; } print ( \" STRNEWLINE \" ) ; print ( \" Third ▁ Segment ▁ : ▁ \" ) ; for ( $ i = $ pos2 ; $ i < count ( $ arr ) ; $ i ++ ) { print ( $ arr [ $ i ] . \" \" ) ; } print ( \" STRNEWLINE \" ) ; } else { println ( \" Array ▁ cannot ▁ be ▁ divided ▁ into ▁ \" , \" three ▁ equal ▁ sum ▁ segments \" ) ; } } $ arr = array ( 1 , 3 , 6 , 2 , 7 , 1 , 2 , 8 ) ; equiSum ( $ arr ) ; ? >"}
{"text": "Indeks paling kiri dan paling kanan maksimum dan elemen minimum array | Berfungsi untuk mengembalikan indeks elemen minimum paling kanan dari array; Unsur pertama adalah minimum dalam array yang disusun; Manakala unsur -unsur adalah sama dengan rightmin kemas kini minimum; Pemeriksaan akhir sama ada terdapat sebarang elemen yang sama dengan minimum; Berfungsi untuk mengembalikan indeks elemen maksimum paling kiri dari array; Unsur terakhir adalah maksimum dalam array yang disusun; Walaupun unsur -unsur adalah sama dengan kemas kini maksimum leftmax; Pemeriksaan akhir sama ada terdapat sebarang elemen yang sama dengan maksimum; Kod pemacu; Unsur pertama adalah minimum paling kiri dalam array yang disusun; Elemen terakhir adalah maksimum paling tepat dalam array yang disusun", "code": "< ? php function getRightMin ( $ arr , $ n ) { $ min = $ arr [ 0 ] ; $ rightMin = 0 ; $ i = 1 ; while ( $ i < $ n ) { if ( $ arr [ $ i ] == $ min ) $ rightMin = $ i ; $ i *= 2 ; } $ i = $ rightMin + 1 ; while ( $ i < $ n && $ arr [ $ i ] == $ min ) { $ rightMin = $ i ; $ i ++ ; } return $ rightMin ; } function getLeftMax ( $ arr , $ n ) { $ max = $ arr [ $ n - 1 ] ; $ leftMax = $ n - 1 ; $ i = $ n - 2 ; while ( $ i > 0 ) { if ( $ arr [ $ i ] == $ max ) $ leftMax = $ i ; $ i /= 2 ; } $ i = $ leftMax - 1 ; while ( $ i >= 0 && $ arr [ $ i ] == $ max ) { $ leftMax = $ i ; $ i -- ; } return $ leftMax ; } $ arr = array ( 0 , 0 , 1 , 2 , 5 , 5 , 6 , 8 , 8 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum ▁ left ▁ : ▁ \" , 0 , \" STRNEWLINE \" ; echo \" Minimum ▁ right ▁ : ▁ \" , getRightMin ( $ arr , $ n ) , \" STRNEWLINE \" ; echo \" Maximum ▁ left ▁ : ▁ \" , getLeftMax ( $ arr , $ n ) , \" STRNEWLINE \" ; echo \" Maximum ▁ right ▁ : ▁ \" , ( $ n - 1 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Unsur -unsur yang akan ditambah supaya semua elemen julat hadir dalam array | Berfungsi untuk mengira nombor yang akan ditambah; Susun array; Periksa sama ada elemen berturut -turut atau tidak. Jika tidak, kiraan kemas kini; Kod pemacu", "code": "< ? php function countNum ( $ arr , $ n ) { $ count = 0 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] && $ arr [ $ i ] != $ arr [ $ i + 1 ] - 1 ) $ count += $ arr [ $ i + 1 ] - $ arr [ $ i ] - 1 ; return $ count ; } $ arr = array ( 3 , 5 , 8 , 6 ) ; $ n = count ( $ arr ) ; echo countNum ( $ arr , $ n ) ; ? >"}
{"text": "Kira subarray dengan elemen yang sama dan ganjil | fungsi yang mengembalikan kiraan subarray yang mengandungi bilangan yang sama ganjil dan juga nombor; memulakan perbezaan dan jawapan dengan 0; memulakan susunan tambahan ini dengan 0; Oleh kerana perbezaannya pada mulanya 0, kita perlu memulakan hash_positive [0] dengan 1; untuk gelung untuk melangkah melalui keseluruhan array (pengindeksan berasaskan sifar digunakan); Meningkatkan atau menurunkan perbezaan berdasarkan arr [i] yang menjadi lebih ganjil, periksa jika arr [i] adalah ganjil; Menambah nilai hash 'perbezaan' kepada jawapan kami kerana semua kejadian sebelumnya nilai perbezaan yang sama akan membuat subarray ganjil yang berakhir pada indeks 'i'. Selepas itu, kami akan meningkatkan array hash untuk nilai 'perbezaan' untuk kejadiannya di indeks 'i'. Jika perbezaan negatif maka gunakan hash_negative; lain menggunakan hash_positive; mengembalikan jumlah keseluruhan - subarray ganjil; Kod pemacu; Mencetak jumlah keseluruhan - subarray ganjil", "code": "< ? php function countSubarrays ( & $ arr , $ n ) { $ difference = 0 ; $ ans = 0 ; $ hash_positive = array_fill ( 0 , $ n + 1 , NULL ) ; $ hash_negative = array_fill ( 0 , $ n + 1 , NULL ) ; $ hash_positive [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & 1 == 1 ) $ difference ++ ; else $ difference -- ; if ( $ difference < 0 ) { $ ans += $ hash_negative [ - $ difference ] ; $ hash_negative [ - $ difference ] ++ ; } else { $ ans += $ hash_positive [ $ difference ] ; $ hash_positive [ $ difference ] ++ ; } } return $ ans ; } $ arr = array ( 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ) ; $ n = sizeof ( $ arr ) ; echo \" Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays \" . \" ▁ are ▁ \" . countSubarrays ( $ arr , $ n ) ; ? >"}
{"text": "Algoritma Carian Saddleback dalam Array 2D | Program PHP untuk mencari elemen dalam baris - bijak dan lajur - matriks yang disusun bijak; Mencari elemen x dalam tikar [m] [n]. Jika elemen dijumpai, maka mencetak kedudukannya dan mengembalikan benar, jika tidak, cetak \"tidak» dijumpai \"dan mengembalikan palsu; Tetapkan indeks untuk elemen kiri bawah; jika mat [i] [j] <x; Kod pemacu", "code": "< ? php $ MAX = 100 ; function search ( $ mat , $ m , $ n , $ x ) { $ i = $ m - 1 ; $ j = 0 ; while ( $ i >= 0 && $ j < $ n ) { if ( $ mat [ $ i ] [ $ j ] == $ x ) return true ; if ( $ mat [ $ i ] [ $ j ] > $ x ) $ i -- ; else $ j ++ ; } return false ; } $ mat = array ( array ( 10 , 20 , 30 , 40 ) , array ( 15 , 25 , 35 , 45 ) , array ( 27 , 29 , 37 , 48 ) , array ( 32 , 33 , 39 , 50 ) , array ( 50 , 60 , 70 , 80 ) ) ; if ( search ( $ mat , 5 , 4 , 29 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Bilangan elemen yang lebih besar di sebelah kanan dalam rentetan | Program PHP untuk mencari tuduhan watak yang lebih besar untuk setiap watak. ; Kod pemacu", "code": "< ? php function printGreaterCount ( $ str ) { $ len = strlen ( $ str ) ; $ right = array_fill ( 0 , $ len , 0 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ len ; $ j ++ ) if ( $ str [ $ i ] < $ str [ $ j ] ) $ right [ $ i ] ++ ; } for ( $ i = 0 ; $ i < $ len ; $ i ++ ) echo $ right [ $ i ] . \" ▁ \" ; } $ str = ' bcd ' printGreaterCount ( $ str ) ; ? >"}
{"text": "N / 3 Nombor berulang dalam array dengan ruang O (1) | Program PHP untuk mencari jika mana -mana elemen muncul lebih daripada n / 3 .; Ambil integer sebagai nilai maksimum integer yang berharap integer tidak akan hadir dalam array; Jika elemen ini sebelum ini dilihat, kiraan kenaikan1. ; Jika elemen ini sebelum ini dilihat, kiraan kenaikan2. ; Jika elemen semasa adalah berbeza dari kedua -dua pembolehubah yang telah dilihat sebelum ini, pengurangan kedua -dua tuduhan. ; Sekali lagi melintasi array dan cari tuduhan sebenar. ; Kod pemacu", "code": "< ? php function appearsNBy3 ( $ arr , $ n ) { $ count1 = 0 ; $ count2 = 0 ; $ first = PHP_INT_MAX ; $ second = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ first == $ arr [ $ i ] ) $ count1 ++ ; else if ( $ second == $ arr [ $ i ] ) $ count2 ++ ; else if ( $ count1 == 0 ) { $ count1 ++ ; $ first = $ arr [ $ i ] ; } else if ( $ count2 == 0 ) { $ count2 ++ ; $ second = $ arr [ $ i ] ; } else { $ count1 -- ; $ count2 -- ; } } $ count1 = 0 ; $ count2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ first ) $ count1 ++ ; else if ( $ arr [ $ i ] == $ second ) $ count2 ++ ; } if ( $ count1 > $ n / 3 ) return $ first ; if ( $ count2 > $ n / 3 ) return $ second ; return -1 ; } $ arr = array ( 1 , 2 , 3 , 1 , 1 ) ; $ n = count ( $ arr ) ; echo appearsNBy3 ( $ arr , $ n ) ; ? >"}
{"text": "Kira pasangan dalam pelbagai yang jumlahnya boleh dibahagikan dengan 4 | Program untuk mengira pasangan yang jumlahnya dibahagikan dengan '4'; Buat array frekuensi untuk mengira kejadian semua sisa apabila dibahagikan dengan 4; Mengira kejadian semua sisa; Jika kedua -dua pasangan boleh dibahagikan dengan '4'; Jika kedua -dua pasangan adalah 2 Modulo 4; Jika salah satu daripada mereka adalah sama dengan 1 Modulo 4 dan yang lain adalah sama dengan 3 Modulo 4; Kod pemacu", "code": "< ? php function count4Divisibiles ( $ arr , $ n ) { $ freq = array ( 0 , 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) ++ $ freq [ $ arr [ $ i ] % 4 ] ; $ ans = $ freq [ 0 ] * ( $ freq [ 0 ] - 1 ) / 2 ; $ ans += $ freq [ 2 ] * ( $ freq [ 2 ] - 1 ) / 2 ; $ ans += $ freq [ 1 ] * $ freq [ 3 ] ; return $ ans ; } $ arr = array ( 2 , 2 , 1 , 7 , 5 ) ; $ n = sizeof ( $ arr ) ; echo count4Divisibiles ( $ arr , $ n ) ; ? >"}
{"text": "Nombor terkecil yang bit yang ditetapkan adalah maksimum dalam julat tertentu | Mengembalikan nombor terkecil yang bit set adalah maksimum dalam julat yang diberikan. ; Memulakan kiraan maksimum dan jawapan akhir sebagai 'num'; Melintasi setiap bit 'i' nombor; Jika kiraan lebih besar daripada max_count yang dikira sebelumnya, kemas kini; Kod pemacu", "code": "< ? php function countMaxSetBits ( $ left , $ right ) { $ max_count = -1 ; $ num ; for ( $ i = $ left ; $ i <= $ right ; ++ $ i ) { $ temp = $ i ; $ cnt = 0 ; while ( $ temp ) { if ( $ temp & 1 ) ++ $ cnt ; $ temp >>= 1 ; } if ( $ cnt > $ max_count ) { $ max_count = $ cnt ; $ num = $ i ; } } return $ num ; } $ l = 1 ; $ r = 5 ; echo countMaxSetBits ( $ l , $ r ) , \" STRNEWLINE \" ; $ l = 1 ; $ r = 10 ; echo countMaxSetBits ( $ l , $ r ) ; ? >"}
{"text": "Urutan Recaman | Mencetak terma n pertama urutan rekaman; Istilah pertama urutan sentiasa 0; Isikan istilah yang tinggal menggunakan formula rekursif. ; Jika arr [i - 1] - Saya negatif atau sudah wujud. ; Kod pemacu", "code": "< ? php function recaman ( $ n ) { $ arr [ 0 ] = 0 ; echo $ arr [ 0 ] , \" , ▁ \" ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr = $ arr [ $ i - 1 ] - $ i ; $ j ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( ( $ arr [ $ j ] == $ curr ) $ curr < 0 ) { $ curr = $ arr [ $ i - 1 ] + $ i ; break ; } } $ arr [ $ i ] = $ curr ; echo $ arr [ $ i ] , \" , ▁ \" ; } } $ n = 17 ; recaman ( $ n ) ; ? >"}
{"text": "Urutan Recaman | Mencetak terma n pertama urutan rekaman; Cetak istilah pertama dan simpan dalam hash; Cetak istilah yang tinggal menggunakan formula rekursif. ; Jika arr [i - 1] - Saya negatif atau sudah wujud. ; Kod pemacu", "code": "< ? php function recaman ( $ n ) { if ( $ n <= 0 ) return ; print ( \"0 , ▁ \" ) ; $ s = array ( ) ; array_push ( $ s , 0 ) ; $ prev = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr = $ prev - $ i ; if ( $ curr < 0 or in_array ( $ curr , $ s ) ) $ curr = $ prev + $ i ; array_push ( $ s , $ curr ) ; print ( $ curr . \" , \" ) ; $ prev = $ curr ; } } $ n = 17 ; recaman ( $ n ) ; ? >"}
{"text": "Rectangle kawasan maksimum dengan memilih empat sisi dari Array | fungsi untuk mencari kawasan maks; Susun array dalam perintah yang tidak meningkat; Memulakan dua sisi segi empat tepat; melintasi array; Jika mana -mana elemen berlaku dua kali menyimpannya sebagai dimensi; mengembalikan produk dimensi; Kod pemacu", "code": "< ? php function findArea ( $ arr , $ n ) { rsort ( $ arr ) ; $ dimension = array ( 0 , 0 ) ; for ( $ i = 0 , $ j = 0 ; $ i < $ n - 1 && $ j < 2 ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) $ dimension [ $ j ++ ] = $ arr [ $ i ++ ] ; return ( $ dimension [ 0 ] * $ dimension [ 1 ] ) ; } $ arr = array ( 4 , 2 , 1 , 4 , 6 , 6 , 2 , 5 ) ; $ n = count ( $ arr ) ; echo findArea ( $ arr , $ n ) ; ? >"}
{"text": "Memandangkan array yang disusun dan diputar, cari jika ada pasangan dengan jumlah yang diberikan | Fungsi ini kembali benar jika arr [0 .. n - 1] mempunyai pasangan dengan jumlah sama dengan x. ; Cari elemen pivot; L kini indeks elemen terkecil; R kini indeks elemen terbesar; Terus bergerak sama ada L atau R sehingga mereka bertemu; Jika kita mencari pasangan dengan jumlah X, kita kembali benar; Jika jumlah pasangan semasa kurang, bergerak ke jumlah yang lebih tinggi; Berpindah ke bahagian bawah; Kod pemacu", "code": "< ? php function pairInSortedRotated ( $ arr , $ n , $ x ) { $ i ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) break ; $ l = ( $ i + 1 ) % $ n ; $ r = $ i ; while ( $ l != $ r ) { if ( $ arr [ $ l ] + $ arr [ $ r ] == $ x ) return true ; if ( $ arr [ $ l ] + $ arr [ $ r ] < $ x ) $ l = ( $ l + 1 ) % $ n ; else $ r = ( $ n + $ r - 1 ) % $ n ; } return false ; } $ arr = array ( 11 , 15 , 6 , 8 , 9 , 10 ) ; $ sum = 16 ; $ n = sizeof ( $ arr ) ; if ( pairInSortedRotated ( $ arr , $ n , $ sum ) ) echo \" Array ▁ has ▁ two ▁ elements ▁ \" . \" with ▁ sum ▁ 16\" ; else echo \" Array ▁ doesn ' t ▁ have ▁ two ▁ \" . \" elements ▁ with ▁ sum ▁ 16 ▁ \" ; ? >"}
{"text": "Memandangkan array yang disusun dan diputar, cari jika ada pasangan dengan jumlah yang diberikan | Fungsi ini mengembalikan kiraan bilangan pasangan dengan jumlah sama dengan x. ; Cari elemen pivot. Elemen pivot adalah elemen terbesar array. ; L adalah indeks elemen terkecil. ; R adalah indeks elemen terbesar. ; Pembolehubah untuk menyimpan kiraan bilangan pasangan. ; Cari jumlah pasangan yang dibentuk oleh arr [l] dan arr [r] dan kemas kini l, r dan cnt dengan sewajarnya. ; Jika kita mencari pasangan dengan jumlah x, maka kenaikan CNT, gerakkan L dan R ke elemen seterusnya. ; Keadaan ini diperlukan untuk diperiksa, jika tidak, l dan r akan menyeberang satu sama lain dan gelung tidak akan pernah ditamatkan. ; Jika jumlah pasangan semasa kurang, bergerak ke sisi jumlah yang lebih tinggi. ; Jika jumlah pasangan semasa lebih besar, bergerak ke bahagian bawah jumlah. ; Kod pemacu", "code": "< ? php function pairsInSortedRotated ( $ arr , $ n , $ x ) { $ i ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) break ; $ l = ( $ i + 1 ) % $ n ; $ r = $ i ; $ cnt = 0 ; while ( $ l != $ r ) { if ( $ arr [ $ l ] + $ arr [ $ r ] == $ x ) { $ cnt ++ ; if ( $ l == ( $ r - 1 + $ n ) % $ n ) { return $ cnt ; } $ l = ( $ l + 1 ) % $ n ; $ r = ( $ r - 1 + $ n ) % $ n ; } else if ( $ arr [ $ l ] + $ arr [ $ r ] < $ x ) $ l = ( $ l + 1 ) % $ n ; else $ r = ( $ n + $ r - 1 ) % $ n ; } return $ cnt ; } $ arr = array ( 11 , 15 , 6 , 7 , 9 , 10 ) ; $ sum = 16 ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo pairsInSortedRotated ( $ arr , $ n , $ sum ) ; ? >"}
{"text": "Cari nilai maksimum jumlah (i * arr [i]) dengan hanya putaran pada array yang dibenarkan | Mengembalikan nilai maksimum yang mungkin i * arr [i]; Cari jumlah array dan i * arr [i] tanpa kedai putaran jumlah arr [i]; Kedai jumlah i * arr [i]; Inisialisasi hasil sebagai 0 putaran jumlah; Cuba semua putaran satu demi satu dan cari jumlah putaran maksimum. ; Hasil pulangan; Kod pemacu", "code": "< ? php function maxSum ( $ arr , $ n ) { $ arrSum = 0 ; $ currVal = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arrSum = $ arrSum + $ arr [ $ i ] ; $ currVal = $ currVal + ( $ i * $ arr [ $ i ] ) ; } $ maxVal = $ currVal ; for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { $ currVal = $ currVal + $ arrSum - $ n * $ arr [ $ n - $ j ] ; if ( $ currVal > $ maxVal ) $ maxVal = $ currVal ; } return $ maxVal ; } $ arr = array ( 10 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; $ n = sizeof ( $ arr ) ; echo \" Max ▁ sum ▁ is ▁ \" , maxSum ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah maksimum i * arr [i] di antara semua putaran array yang diberikan | Mengembalikan nilai maksimum i * arr [i]; Memulakan hasil; Pertimbangkan putaran bermula dengan saya untuk semua nilai yang mungkin i. ; Memulakan jumlah putaran semasa; Kirakan jumlah semua nilai. Kami tidak benar -benar memutar array, tetapi mengira jumlah dengan mencari indeks apabila arr [i] adalah elemen pertama; Hasil kemas kini jika diperlukan; Kod pemacu", "code": "< ? php function maxSum ( $ arr , $ n ) { $ res = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ index = ( $ i + $ j ) % $ n ; $ curr_sum += $ j * $ arr [ $ index ] ; } $ res = max ( $ res , $ curr_sum ) ; } return $ res ; } $ arr = array ( 8 , 3 , 1 , 2 ) ; $ n = sizeof ( $ arr ) ; echo maxSum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah maksimum i * arr [i] di antara semua putaran array yang diberikan | Program php yang cekap untuk mengira jumlah maksimum i * arr [i]; Mengira jumlah semua elemen array; Kirakan jumlah i * arr [i] untuk konfigurasi awal. ; Memulakan hasil; Mengira nilai untuk lelaran lain; Kirakan nilai seterusnya menggunakan nilai sebelumnya dalam O (1) masa; Mengemas kini nilai semasa; Hasil kemas kini jika diperlukan; Kod pemacu", "code": "< ? php function maxSum ( $ arr , $ n ) { $ cum_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ cum_sum += $ arr [ $ i ] ; $ curr_val = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ curr_val += $ i * $ arr [ $ i ] ; $ res = $ curr_val ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ next_val = $ curr_val - ( $ cum_sum - $ arr [ $ i - 1 ] ) + $ arr [ $ i - 1 ] * ( $ n - 1 ) ; $ curr_val = $ next_val ; $ res = max ( $ res , $ next_val ) ; } return $ res ; } $ arr = array ( 8 , 3 , 1 , 2 ) ; $ n = sizeof ( $ arr ) ; echo maxSum ( $ arr , $ n ) ; ? >"}
{"text": "Cari kiraan putaran dalam array yang disusun diputar | Mengembalikan kiraan putaran untuk array yang pertama kali disusun dalam urutan menaik, kemudian diputar; Kami pada dasarnya mendapati indeks elemen minimum; Kod pemacu", "code": "< ? php function countRotations ( $ arr , $ n ) { $ min = $ arr [ 0 ] ; $ min_index ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ min > $ arr [ $ i ] ) { $ min = $ arr [ $ i ] ; $ min_index = $ i ; } } return $ min_index ; } $ arr = array ( 15 , 18 , 2 , 3 , 6 , 12 ) ; $ n = sizeof ( $ arr ) ; echo countRotations ( $ arr , $ n ) ; ? >"}
{"text": "Cari kiraan putaran dalam array yang disusun diputar | Mengembalikan kiraan putaran untuk array yang pertama kali disusun dalam urutan menaik, kemudian diputar; Keadaan ini diperlukan untuk mengendalikan kes apabila array tidak diputar sama sekali; Sekiranya terdapat hanya satu elemen yang tersisa; Cari pertengahan; Semak jika elemen (pertengahan + 1) adalah elemen minimum. Pertimbangkan kes seperti {3, 4, 5, 1, 2}; Semak jika Mid sendiri adalah elemen minimum; Tentukan sama ada kita perlu pergi ke separuh kiri atau kanan; Kod pemacu", "code": "< ? php function countRotations ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return 0 ; if ( $ high == $ low ) return $ low ; $ mid = $ low + ( $ high - $ low ) / 2 ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return ( int ) ( $ mid + 1 ) ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return ( int ) ( $ mid ) ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return countRotations ( $ arr , $ low , $ mid - 1 ) ; return countRotations ( $ arr , $ mid + 1 , $ high ) ; } $ arr = array ( 15 , 18 , 2 , 3 , 6 , 12 ) ; $ n = sizeof ( $ arr ) ; echo countRotations ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text": "Cepat mencari giliran kiri pelbagai array | Tetapkan 1 | Mengisi $ temp dengan dua salinan $ arr; Simpan elemen $ arr pada i dan i + n; Fungsi ke kiri berputar kali K Array; Memulakan kedudukan array selepas putaran k di temp [] akan k % n; Cetak array selepas putaran k; Kod pemacu", "code": "< ? php function preprocess ( & $ arr , $ n , & $ temp ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ temp [ $ i ] = $ temp [ $ i + $ n ] = $ arr [ $ i ] ; } function leftRotate ( & $ arr , $ n , $ k , & $ temp ) { $ start = $ k % $ n ; for ( $ i = $ start ; $ i < $ start + $ n ; $ i ++ ) echo $ temp [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 1 , 3 , 5 , 7 , 9 ) ; $ n = sizeof ( $ arr ) ; $ temp [ 2 * $ n ] = array ( ) ; preprocess ( $ arr , $ n , $ temp ) ; $ k = 2 ; leftRotate ( $ arr , $ n , $ k , $ temp ) ; $ k = 3 ; leftRotate ( $ arr , $ n , $ k , $ temp ) ; $ k = 4 ; leftRotate ( $ arr , $ n , $ k , $ temp ) ; ? >"}
{"text": "Cepat mencari giliran kiri pelbagai array | Tetapkan 1 | Fungsi ke kiri berputar kali K Array; Cetak array selepas putaran k; Program Pemandu", "code": "< ? php function leftRotate ( $ arr , $ n , $ k ) { for ( $ i = $ k ; $ i < $ k + $ n ; $ i ++ ) echo $ arr [ $ i % $ n ] , \" ▁ \" ; } $ arr = array ( 1 , 3 , 5 , 7 , 9 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; leftRotate ( $ arr , $ n , $ k ) ; echo \" STRNEWLINE \" ; $ k = 3 ; leftRotate ( $ arr , $ n , $ k ) ; echo \" STRNEWLINE \" ; $ k = 4 ; leftRotate ( $ arr , $ n , $ k ) ; echo \" STRNEWLINE \" ; ? >"}
{"text": "Algoritma pembalikan untuk putaran kanan array | Fungsi untuk membalikkan arr [] dari indeks mula berakhir; Fungsi ke kanan berputar arr [] saiz n oleh d; berfungsi untuk mencetak array; Kod pemacu", "code": "< ? php function reverseArray ( & $ arr , $ start , $ end ) { while ( $ start < $ end ) { $ temp = $ arr [ $ start ] ; $ arr [ $ start ] = $ arr [ $ end ] ; $ arr [ $ end ] = $ temp ; $ start ++ ; $ end -- ; } } function rightRotate ( & $ arr , $ d , $ n ) { reverseArray ( $ arr , 0 , $ n - 1 ) ; reverseArray ( $ arr , 0 , $ d - 1 ) ; reverseArray ( $ arr , $ d , $ n - 1 ) ; } function printArray ( & $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; rightRotate ( $ arr , $ k , $ n ) ; printArray ( $ arr , $ n ) ; ? >"}
{"text": "Cari putaran dengan jarak Hamming Maksimum | Mengembalikan jarak Hamming maksimum putaran; Arr [] ke BRR [] dua kali supaya kita dapat melintasi semua putaran. ; Kami tahu jarak Hamming dengan 0 putaran akan 0 .; Kami mencuba putaran lain satu demi satu dan mengira jarak Hamming setiap putaran; Kita tidak boleh mendapatkan lebih daripada n. ; Kod pemacu", "code": "< ? php function maxHamming ( $ arr , $ n ) { $ brr = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ brr [ $ i ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ brr [ $ n + $ i ] = $ arr [ $ i ] ; $ maxHam = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ currHam = 0 ; for ( $ j = $ i , $ k = 0 ; $ j < ( $ i + $ n ) ; $ j ++ , $ k ++ ) if ( $ brr [ $ j ] != $ arr [ $ k ] ) $ currHam ++ ; if ( $ currHam == $ n ) return $ n ; $ maxHam = max ( $ maxHam , $ currHam ) ; } return $ maxHam ; } $ arr = array ( 2 , 4 , 6 , 80 ) ; $ n = count ( $ arr ) ; echo maxHamming ( $ arr , $ n ) ; ? >"}
{"text": "Cetak putaran kiri array dalam o (n) masa dan o (1) ruang | Berfungsi untuk array leftrotate beberapa kali; Untuk mendapatkan titik permulaan array berputar; Mencetak array yang diputar dari kedudukan permulaan; Kod pemacu; Panggilan fungsi; Panggilan fungsi; Panggilan fungsi", "code": "< ? php function leftRotate ( $ arr , $ n , $ k ) { $ mod = $ k % $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ ( $ mod + $ i ) % $ n ] ) , \" ▁ \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 1 , 3 , 5 , 7 , 9 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; leftRotate ( $ arr , $ n , $ k ) ; $ k = 3 ; leftRotate ( $ arr , $ n , $ k ) ; $ k = 4 ; leftRotate ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Cari elemen di indeks yang diberikan selepas beberapa putaran | Fungsi untuk mengira elemen pada indeks yang diberikan; Julat [kiri ... kanan]; Putaran tidak akan memberi kesan; Kembali elemen baru; Kod pemacu; Tidak. putaran; Julat mengikut pengindeksan berasaskan 0", "code": "< ? php function findElement ( $ arr , $ ranges , $ rotations , $ index ) { for ( $ i = $ rotations - 1 ; $ i >= 0 ; $ i -- ) { $ left = $ ranges [ $ i ] [ 0 ] ; $ right = $ ranges [ $ i ] [ 1 ] ; if ( $ left <= $ index && $ right >= $ index ) { if ( $ index == $ left ) $ index = $ right ; else $ index -- ; } } return $ arr [ $ index ] ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ rotations = 2 ; $ ranges = array ( array ( 0 , 2 ) , array ( 0 , 3 ) ) ; $ index = 1 ; echo findElement ( $ arr , $ ranges , $ rotations , $ index ) ; ? >"}
{"text": "Pecahkan array dan tambahkan bahagian pertama hingga akhir | Program PHP untuk memecah array dan bergerak bahagian pertama ke akhir. ; Berputar array oleh 1 .; Kod pemacu", "code": "< ? php function splitArr ( & $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ x = $ arr [ 0 ] ; for ( $ j = 0 ; $ j < $ n - 1 ; ++ $ j ) $ arr [ $ j ] = $ arr [ $ j + 1 ] ; $ arr [ $ n - 1 ] = $ x ; } } $ arr = array ( 12 , 10 , 5 , 6 , 52 , 36 ) ; $ n = sizeof ( $ arr ) ; $ position = 2 ; splitArr ( $ arr , 6 , $ position ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) echo $ arr [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Shell | Berfungsi untuk menyusun arr [] menggunakan jenis shell Metzner; Tetapkan saiz langkah awal ke saiz array; Saiz langkah menurun sebanyak separuh setiap kali; k ialah had atas untuk j; J adalah titik permulaan; Saya sama dengan nilai yang lebih kecil; L sama dengan nilai yang lebih besar; Bandingkan dan swap arr [i] dengan arr [l]; Mengurangkan nilai yang lebih kecil mengikut saiz langkah; Kenaikan had bawah i; Berfungsi untuk mencetak kandungan array; Kod pemacu; Susun array menggunakan jenis Shell Metzner; Cetak array yang disusun", "code": "< ? php function sort_shell_metzner ( $ arr , $ n ) { $ m = $ n ; while ( $ m > 0 ) { $ m = $ m / 2 ; $ k = $ n - $ m ; $ j = 0 ; do { $ i = $ j ; do { $ l = $ i + $ m ; if ( $ arr [ $ i ] > $ arr [ $ l ] ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ l ] ; $ arr [ $ l ] = $ temp ; $ i -= $ m ; } else break ; } while ( $ i >= 0 ) ; $ j ++ ; } while ( $ j <= $ k ) ; } return $ arr ; } function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; } $ arr = array ( 0 , -2 , 8 , 5 , 1 ) ; $ n = count ( $ arr ) ; $ result_array = sort_shell_metzner ( $ arr , $ n ) ; printArray ( $ result_array , $ n ) ; ? >"}
{"text": "Menyusun semula array sedemikian rupa sehingga arr [i]> = arr [j] jika saya juga dan arr [i] <= arr [j] jika saya ganjil dan j <i | berfungsi untuk menyusun semula array; Jumlah jawatan walaupun; Jumlah kedudukan ganjil; Salin array asal dalam pelbagai tambahan; Susun array tambahan; Isi kedudukan ganjil dalam array asal; Isi walaupun kedudukan dalam array asal; pelbagai paparan; Kod pemacu", "code": "< ? php function rearrangeArr ( & $ arr , $ n ) { $ evenPos = intval ( $ n / 2 ) ; $ oddPos = $ n - $ evenPos ; $ tempArr = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ tempArr [ $ i ] = $ arr [ $ i ] ; sort ( $ tempArr ) ; $ j = $ oddPos - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i += 2 ) { $ arr [ $ i ] = $ tempArr [ $ j ] ; $ j -- ; } $ j = $ oddPos ; for ( $ i = 1 ; $ i < $ n ; $ i += 2 ) { $ arr [ $ i ] = $ tempArr [ $ j ] ; $ j ++ ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ; $ size = sizeof ( $ arr ) ; rearrangeArr ( $ arr , $ size ) ; ? >"}
{"text": "Jumlah maksimum perbezaan mutlak sebarang permutasi | Pelaksanaan PHP algoritma di atas; urutan akhir yang disimpan dalam vektor; Susun array asal supaya kita dapat mengambil unsur -unsur besar dari akhir elemen array; Dalam gelung ini terlebih dahulu kita akan memasukkan satu elemen terkecil yang tidak dimasukkan sehingga masa itu dalam urutan akhir dan kemudian masukkan elemen tertinggi (tidak dimasukkan sehingga masa itu) dalam urutan akhir supaya kita mempunyai nilai perbezaan yang besar. Proses ini diulang sehingga semua array telah dimasukkan sepenuhnya dalam urutan. Di sini, kami mempunyai gelung sehingga n / 2 kerana kami memasukkan dua elemen pada satu masa dalam gelung. ; Sekiranya terdapat unsur -unsur ganjil, tolak elemen pertengahan pada akhir. ; pembolehubah untuk menyimpan jumlah maksimum perbezaan mutlak; Dalam gelung ini perbezaan mutlak elemen untuk urutan akhir dikira. ; Perbezaan mutlak elemen terakhir dan elemen 1; mengembalikan nilai; Kod pemacu", "code": "< ? php function MaxSumDifference ( & $ a , $ n ) { $ finalSequence = array ( ) ; sort ( $ a ) ; for ( $ i = 0 ; $ i < $ n / 2 ; ++ $ i ) { array_push ( $ finalSequence , $ a [ $ i ] ) ; array_push ( $ finalSequence , $ a [ $ n - $ i - 1 ] ) ; } if ( $ n % 2 != 0 ) array_push ( $ finalSequence , $ a [ $ n - 1 ] ) ; $ MaximumSum = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { $ MaximumSum = $ MaximumSum + abs ( $ finalSequence [ $ i ] - $ finalSequence [ $ i + 1 ] ) ; } $ MaximumSum = $ MaximumSum + abs ( $ finalSequence [ $ n - 1 ] - $ finalSequence [ 0 ] ) ; return $ MaximumSum ; } $ a = array ( 1 , 2 , 4 , 8 ) ; $ n = sizeof ( $ a ) ; echo MaxSumDifference ( $ a , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Swap minimum diperlukan untuk membawa semua elemen kurang daripada atau sama dengan k bersama -sama | Fungsi utiliti untuk mencari swap minimum yang diperlukan untuk kelab semua elemen kurang daripada atau sama dengan k bersama -sama; Cari kiraan elemen yang kurang daripada sama dengan k; Cari unsur -unsur yang tidak diingini dalam tetingkap semasa saiz 'Count'; Memulakan jawapan dengan nilai 'buruk' tetingkap semasa; Pengurangan kiraan tetingkap sebelumnya; Kiraan kenaikan tetingkap semasa; Kemas kini Ans Jika Count 'Bad' kurang dalam tetingkap semasa; Kod pemacu", "code": "< ? php function minSwap ( $ arr , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) if ( $ arr [ $ i ] <= $ k ) ++ $ count ; $ bad = 0 ; for ( $ i = 0 ; $ i < $ count ; ++ $ i ) if ( $ arr [ $ i ] > $ k ) ++ $ bad ; $ ans = $ bad ; for ( $ i = 0 , $ j = $ count ; $ j < $ n ; ++ $ i , ++ $ j ) { if ( $ arr [ $ i ] > $ k ) -- $ bad ; if ( $ arr [ $ j ] > $ k ) ++ $ bad ; $ ans = min ( $ ans , $ bad ) ; } return $ ans ; } $ arr = array ( 2 , 1 , 5 , 6 , 3 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; echo ( minSwap ( $ arr , $ n , $ k ) . \" \" ) ; $ arr1 = array ( 2 , 7 , 9 , 5 , 8 , 7 , 4 ) ; $ n = sizeof ( $ arr1 ) ; $ k = 5 ; echo ( minSwap ( $ arr1 , $ n , $ k ) ) ; ? >"}
{"text": "Produk maksimum berikutnya saiz k | Fungsi yang diperlukan; menyusun array input yang diberikan; pembolehubah untuk menyimpan produk akhir semua elemen sub -urutan saiz k; Kes I Jika elemen max adalah 0 dan k adalah ganjil maka produk max akan menjadi 0; Kes II Jika semua elemen negatif dan k adalah ganjil maka produk maksimum akan menjadi produk paling rendah - subarray saiz k; lain saya adalah indeks penunjuk kiri semasa; J adalah indeks penunjuk kanan semasa; Kes III Jika K adalah elemen ganjil dan paling kanan dalam array yang disusun adalah positif maka ia mesti datang dalam seterusnya mengalikan [j] dengan produk dan sejajar dengan j; Kes IV Sekarang K bahkan sekarang kita berurusan dengan pasangan setiap kali pasangan didarabkan kepada produk IE. . Dua elemen ditambah kepada berikutnya setiap kali K berkesan K menjadi separuh daripada itu, k >> = 1 bermakna k /= 2; Sekarang mencari pasangan yang sepadan untuk mendapatkan nilai produk maksimum; produk dari petunjuk kiri; produk dari petunjuk kanan; Mengambil produk maksimum dari dua pilihan yang sama mengubah kedudukan penunjuk; Akhirnya mengembalikan produk; Kod pemacu", "code": "< ? php function maxProductSubarrayOfSizeK ( $ A , $ n , $ k ) { sort ( $ A ) ; $ product = 1 ; if ( $ A [ $ n - 1 ] == 0 && ( $ k & 1 ) ) return 0 ; if ( $ A [ $ n - 1 ] <= 0 && ( $ k & 1 ) ) { for ( $ i = $ n - 1 ; $ i >= $ n - $ k ; $ i -- ) $ product *= $ A [ $ i ] ; return $ product ; } $ i = 0 ; $ j = $ n - 1 ; if ( $ k & 1 ) { $ product *= $ A [ $ j ] ; $ j -- ; $ k -- ; } $ k >>= 1 ; for ( $ itr = 0 ; $ itr < $ k ; $ itr ++ ) { $ left_product = $ A [ $ i ] * $ A [ $ i + 1 ] ; $ right_product = $ A [ $ j ] * $ A [ $ j - 1 ] ; if ( $ left_product > $ right_product ) { $ product *= $ left_product ; $ i += 2 ; } else { $ product *= $ right_product ; $ j -= 2 ; } } return $ product ; } $ A = array ( 1 , 2 , -1 , -3 , -6 , 4 ) ; $ n = count ( $ A ) ; $ k = 4 ; echo maxProductSubarrayOfSizeK ( $ A , $ n , $ k ) ; ? >"}
{"text": "Menyusun semula array mengikut indeks yang diberikan | Fungsi untuk menyusun semula unsur -unsur ARR [] mengikut indeks []; $ temp [$ n]; arr [i] harus hadir di indeks indeks [i]; Salin temp [] ke arr []; Kod pemacu", "code": "< ? php function reorder ( $ arr , $ index , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp [ $ index [ $ i ] ] = $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ i ] = $ temp [ $ i ] ; $ index [ $ i ] = $ i ; } echo \" Reordered ▁ array ▁ is : ▁ STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ arr [ $ i ] . \" \" ; } echo \" Modified Index array is : \" for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ index [ $ i ] . \" \" ; } } $ arr = array ( 50 , 40 , 70 , 60 , 90 ) ; $ index = array ( 3 , 0 , 4 , 1 , 2 ) ; $ n = sizeof ( $ arr ) ; reorder ( $ arr , $ index , $ n ) ; ? >"}
{"text": "Kira bilangan minimum subset (atau berikutnya) dengan nombor berturut -turut | Mengembalikan kiraan subset dengan nombor berturut -turut; Susun array supaya unsur -unsur yang berturut -turut berturut -turut menjadi berturut -turut dalam array. ; Memulakan hasil; Semak jika terdapat permulaan subset lain dari nombor berturut -turut; Kod pemacu", "code": "< ? php function numofsubset ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] + 1 != $ arr [ $ i + 1 ] ) $ count ++ ; } return $ count ; } $ arr = array ( 100 , 56 , 5 , 6 , 102 , 58 , 101 , 57 , 7 , 103 , 59 ) ; $ n = sizeof ( $ arr ) ; echo numofsubset ( $ arr , $ n ) ; ? >"}
{"text": "Gnome Sort | Fungsi untuk menyusun algoritma menggunakan jenis gnome; Kod pemacu", "code": "< ? php function gnomeSort ( $ arr , $ n ) { $ index = 0 ; while ( $ index < $ n ) { if ( $ index == 0 ) $ index ++ ; if ( $ arr [ $ index ] >= $ arr [ $ index - 1 ] ) $ index ++ ; else { $ temp = 0 ; $ temp = $ arr [ $ index ] ; $ arr [ $ index ] = $ arr [ $ index - 1 ] ; $ arr [ $ index - 1 ] = $ temp ; $ index -- ; } } echo \" Sorted ▁ sequence ▁ \" , \" after ▁ Gnome ▁ sort : ▁ \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 34 , 2 , 10 , -9 ) ; $ n = count ( $ arr ) ; gnomeSort ( $ arr , $ n ) ; ? >"}
{"text": "Cari titik di mana selang maksimum bertindih | Program PHP untuk mencari tetamu maksimum pada bila -bila masa dalam parti; Susun ketibaan dan tatasusunan keluar; tetamu_in menunjukkan bilangan tetamu pada satu masa; Sama seperti menggabungkan gabungan untuk memproses semua peristiwa dalam urutan yang disusun; Jika acara seterusnya dalam urutan yang disusun adalah ketibaan, kenaikan kiraan tetamu; Kemas kini max_guests jika diperlukan; indeks kenaikan array ketibaan; Sekiranya acara keluar, pengurangan kiraan tetamu. ; tetamu. ; Kod pemacu", "code": "< ? php function findMaxGuests ( $ arrl , $ exit , $ n ) { sort ( $ arrl ) ; sort ( $ exit ) ; $ guests_in = 1 ; $ max_guests = 1 ; $ time = $ arrl [ 0 ] ; $ i = 1 ; $ j = 0 ; while ( $ i < $ n and $ j < $ n ) { if ( $ arrl [ $ i ] <= $ exit [ $ j ] ) { $ guests_in ++ ; if ( $ guests_in > $ max_guests ) { $ max_guests = $ guests_in ; $ time = $ arrl [ $ i ] ; } $ i ++ ; } else { $ guests_in -- ; $ j ++ ; } } echo \" Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ \" , $ max_guests , \" ▁ at ▁ time ▁ \" , $ time ; } $ arr1 = array ( 1 , 2 , 10 , 5 , 5 ) ; $ exit = array ( 4 , 5 , 12 , 9 , 120 ) ; $ n = count ( $ arr1 ) ; findMaxGuests ( $ arr1 , $ exit , $ n ) ; ? >"}
{"text": "Cari titik di mana selang maksimum bertindih |  ; Mencari masa permulaan maksimum o (n); Mencari masa berakhir maksimum o (n); Mewujudkan dan array bantu o (n); Penambahan malas; Lazily mengira nilai pada indeks i o (n); Kod pemacu", "code": "< ? php function maxOverlap ( $ start , $ end ) { $ n = count ( $ start ) ; $ maxa = max ( $ start ) ; $ maxb = max ( $ end ) ; $ maxc = max ( $ maxa , $ maxb ) ; $ x = array_fill ( 0 , $ maxc + 2 , 0 ) ; $ cur = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { ++ $ x [ $ start [ $ i ] ] ; -- $ x [ $ end [ $ i ] + 1 ] ; } $ maxy = - PHP_INT_MAX ; for ( $ i = 0 ; $ i <= $ maxc ; $ i ++ ) { $ cur += $ x [ $ i ] ; if ( $ maxy < $ cur ) { $ maxy = $ cur ; $ idx = $ i ; } } echo \" Maximum ▁ value ▁ is ▁ \" . $ maxy . \" ▁ at ▁ position ▁ \" . $ idx . \" STRNEWLINE \" ; } $ start = array ( 13 , 28 , 29 , 14 , 40 , 17 , 3 ) ; $ end = array ( 107 , 95 , 111 , 105 , 70 , 127 , 74 ) ; maxOverlap ( $ start , $ end ) ; ? >"}
{"text": "Susun semula array dalam bentuk minimum maksimum | Tetapkan 1 | Cetak max pada kedudukan pertama, min pada kedudukan kedua max kedua pada kedudukan ketiga, min kedua pada kedudukan keempat dan sebagainya. ; Pelbagai tambahan untuk memegang array yang diubah suai; Indeks unsur -unsur terkecil dan terbesar dari array yang tinggal. ; Untuk menunjukkan sama ada kita perlu menyalin baki terbesar atau paling kecil pada kedudukan seterusnya; Kedai menghasilkan temp []; Salin temp [] ke arr []; Kod pemacu", "code": "< ? php function rearrange ( & $ arr , $ n ) { $ temp = array ( ) ; $ small = 0 ; $ large = $ n - 1 ; $ flag = true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ flag ) $ temp [ $ i ] = $ arr [ $ large -- ] ; else $ temp [ $ i ] = $ arr [ $ small ++ ] ; $ flag = ! $ flag ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 ) ; $ n = count ( $ arr ) ; echo \" Original ▁ Arrayn STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; rearrange ( $ arr , $ n ) ; echo \" Modified Arrayn \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Susun semula array dalam bentuk minimum maksimum | Tetapkan 2 (o (1) ruang tambahan) | Cetak max pada kedudukan pertama, min pada kedudukan kedua max kedua pada kedudukan ketiga, min kedua pada kedudukan keempat dan sebagainya. ; memulakan indeks minimum pertama dan elemen maksimum pertama; menyimpan elemen maksimum array; Elemen Array Traverse; Pada indeks walaupun: kita perlu meletakkan elemen maksimum; Pada Indeks Ganjil: Kita perlu meletakkan elemen minimum; unsur -unsur array kembali kepada bentuk asalnya; Kod pemacu", "code": "< ? php function rearrange ( & $ arr , $ n ) { $ max_idx = $ n - 1 ; $ min_idx = 0 ; $ max_elem = $ arr [ $ n - 1 ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) { $ arr [ $ i ] += ( $ arr [ $ max_idx ] % $ max_elem ) * $ max_elem ; $ max_idx -- ; } else { $ arr [ $ i ] += ( $ arr [ $ min_idx ] % $ max_elem ) * $ max_elem ; $ min_idx ++ ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = ( int ) ( $ arr [ $ i ] / $ max_elem ) ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; $ n = sizeof ( $ arr ) ; echo \" Original ▁ Array \" . \" STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; rearrange ( $ arr , $ n ) ; echo \" Modified Array \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ;"}
{"text": "Gerakkan semua nombor negatif ke permulaan dan positif untuk berakhir dengan ruang tambahan yang berterusan | Program PHP untuk meletakkan semua nombor negatif sebelum nombor positif; Fungsi utiliti untuk mencetak array; Kod pemacu", "code": "< ? php function rearrange ( & $ arr , $ n ) { $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < 0 ) { if ( $ i != $ j ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ temp ; } $ j ++ ; } } } function printArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } $ arr = array ( -1 , 2 , -3 , 4 , 5 , 6 , -7 , 8 , 9 ) ; $ n = sizeof ( $ arr ) ; rearrange ( $ arr , $ n ) ; printArray ( $ arr , $ n ) ; ? >"}
{"text": "Gerakkan semua elemen negatif untuk berakhir dengan ruang tambahan yang dibenarkan | Menggerakkan semua elemen ke akhir array dalam urutan yang sama. ; Buat array kosong untuk menyimpan hasil; TRAVERSAL ARRAY DAN STORE + VE ELEMENT DALAM TEMPAT TEMPAT INDEKS TEMP; Jika array mengandungi semua positif atau semua negatif. ; Store - VE elemen dalam Temp Array; Salin kandungan temp [] ke arr []; Kod pemacu", "code": "< ? php function segregateElements ( & $ arr , $ n ) { $ temp = array ( 0 , $ n , NULL ) ; $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] >= 0 ) $ temp [ $ j ++ ] = $ arr [ $ i ] ; if ( $ j == $ n $ j == 0 ) return ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < 0 ) $ temp [ $ j ++ ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; } $ arr = array ( 1 , -1 , -3 , -2 , 7 , 5 , 11 , 6 ) ; $ n = sizeof ( $ arr ) ; segregateElements ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Susun semula array sedemikian rupa sehingga elemen indeks adalah elemen indeks yang lebih kecil dan ganjil lebih besar | Swap; Menyusun semula; Utiliti yang mencetak array dalam satu baris; Kod pemacu", "code": "< ? php function swap ( & $ a , & $ b ) { $ temp = $ a ; $ a = $ b ; $ b = $ temp ; } function rearrange ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ i % 2 == 0 && $ arr [ $ i ] > $ arr [ $ i + 1 ] ) swap ( $ arr [ $ i ] , $ arr [ $ i + 1 ] ) ; if ( $ i % 2 != 0 && $ arr [ $ i ] < $ arr [ $ i + 1 ] ) swap ( $ arr [ $ i ] , $ arr [ $ i + 1 ] ) ; } } function printArray ( & $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 6 , 4 , 2 , 1 , 8 , 3 ) ; $ n = sizeof ( $ arr ) ; echo \" Before ▁ rearranging : ▁ STRNEWLINE \" ; printArray ( $ arr , $ n ) ; rearrange ( $ arr , $ n ) ; echo \" After ▁ rearranging : ▁ STRNEWLINE \" ; printArray ( $ arr , $ n ) ; ? >"}
{"text": "Unsur -unsur positif pada bahkan dan negatif pada kedudukan ganjil (perintah relatif tidak dikekalkan) | Program PHP untuk menyusun semula nombor positif dan negatif; Bergerak ke hadapan penunjuk positif sehingga nombor negatif tidak ditemui; Melangkah ke hadapan penunjuk negatif sehingga nombor positif tidak ditemui; Swap array elements untuk menetapkan kedudukan mereka. ; Break dari gelung sementara apabila mana -mana indeks melebihi saiz array; Kod pemacu", "code": "< ? php function rearrange ( & $ a , $ size ) { $ positive = 0 ; $ negative = 1 ; while ( true ) { while ( $ positive < $ size && $ a [ $ positive ] >= 0 ) $ positive += 2 ; while ( $ negative < $ size && $ a [ $ negative ] <= 0 ) $ negative += 2 ; if ( $ positive < $ size && $ negative < $ size ) { $ temp = $ a [ $ positive ] ; $ a [ $ positive ] = $ a [ $ negative ] ; $ a [ $ negative ] = $ temp ; } else break ; } } $ arr = array ( 1 , -3 , 5 , 6 , -3 , 6 , 7 , -4 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; rearrange ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Mengasingkan Nombor Even dan Ganjil | Set 3 | Berfungsi untuk memisahkan nombor ganjil walaupun; Bertukar -tukar nombor walaupun dan ganjil; Percetakan Array Terasing; Kod pemacu", "code": "< ? php function arrayEvenAndOdd ( $ arr , $ n ) { $ i = -1 ; $ j = 0 ; $ t ; while ( $ j != $ n ) { if ( $ arr [ $ j ] % 2 == 0 ) { $ i ++ ; $ x = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ x ; } $ j ++ ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } $ arr = array ( 1 , 3 , 2 , 4 , 7 , 6 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; arrayEvenAndOdd ( $ arr , $ n ) ; ? >"}
{"text": "Program untuk mencari elemen terbesar dalam array | Fungsi php untuk mencari maksimum dalam arr [] saiz n; Memulakan elemen maksimum; Melintasi unsur -unsur array dari kedua dan bandingkan setiap elemen dengan max semasa; Kod pemacu", "code": "< ? php function largest ( $ arr , $ n ) { $ i ; $ max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; return $ max ; } $ arr = array ( 10 , 324 , 45 , 90 , 9808 ) ; $ n = sizeof ( $ arr ) ; echo \" Largest ▁ in ▁ given ▁ array ▁ is ▁ \" , largest ( $ arr , $ n ) ; ? >"}
{"text": "Program untuk mencari elemen terbesar dalam array | pulangan maksimum dalam arr [] saiz n; Kod pemacu", "code": "< ? php function largest ( $ arr , $ n ) { return max ( $ arr ) ; } $ arr = array ( 10 , 324 , 45 , 90 , 9808 ) ; $ n = count ( $ arr ) ; echo largest ( $ arr , $ n ) ; ? >"}
{"text": "Program untuk min dan median array yang tidak disusun | Fungsi untuk mengira min; Fungsi untuk mengira median; Pertama kita menyusun array; Semak kes walaupun; Kod pemacu; Panggilan fungsi", "code": "< ? php function findMean ( & $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; return ( double ) $ sum / ( double ) $ n ; } function findMedian ( & $ a , $ n ) { sort ( $ a ) ; if ( $ n % 2 != 0 ) return ( double ) $ a [ $ n / 2 ] ; return ( double ) ( $ a [ ( $ n - 1 ) / 2 ] + $ a [ $ n / 2 ] ) / 2.0 ; } $ a = array ( 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 ) ; $ n = sizeof ( $ a ) ; echo \" Mean ▁ = ▁ \" . findMean ( $ a , $ n ) . \" STRNEWLINE \" ; echo \" Median ▁ = ▁ \" . findMedian ( $ a , $ n ) ; ? >"}
{"text": "k elemen terkecil dalam urutan yang sama menggunakan O (1) ruang tambahan | Fungsi untuk mencetak nombor k terkecil dalam arr [0. n - 1]; Bagi setiap ARR [i] mendapati sama ada ia adalah sebahagian daripada N - terkecil dengan konsep jenis penyisipan; Cari terbesar dari elemen k - pertama; Jika terbesar adalah lebih besar daripada ARR [i] mengalihkan semua elemen satu tempat yang tersisa; membuat arr [k - 1] = arr [i]; hasil cetak; Kod pemacu", "code": "< ? php function printSmall ( $ arr , $ n , $ k ) { for ( $ i = $ k ; $ i < $ n ; ++ $ i ) { $ max_var = $ arr [ $ k - 1 ] ; $ pos = $ k - 1 ; for ( $ j = $ k - 2 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ j ] > $ max_var ) { $ max_var = $ arr [ $ j ] ; $ pos = $ j ; } } if ( $ max_var > $ arr [ $ i ] ) { $ j = $ pos ; while ( $ j < $ k - 1 ) { $ arr [ $ j ] = $ arr [ $ j + 1 ] ; $ j ++ ; } $ arr [ $ k - 1 ] = $ arr [ $ i ] ; } } for ( $ i = 0 ; $ i < $ k ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; } $ arr = array ( 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ) ; $ n = count ( $ arr ) ; $ k = 5 ; printSmall ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Cari elemen kedua terbesar dalam array | Berfungsi untuk mencetak elemen kedua terbesar; Harus ada dua elemen; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Kod pemacu", "code": "< ? php function print2largest ( $ arr , $ arr_size ) { if ( $ arr_size < 2 ) { echo ( \" ▁ Invalid ▁ Input ▁ \" ) ; return ; } $ first = $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { if ( $ arr [ $ i ] > $ first ) { $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ second && $ arr [ $ i ] != $ first ) $ second = $ arr [ $ i ] ; } if ( $ second == PHP_INT_MIN ) echo ( \" There ▁ is ▁ no ▁ second ▁ largest ▁ element STRNEWLINE \" ) ; else echo ( \" The ▁ second ▁ largest ▁ element ▁ is ▁ \" . $ second . \" STRNEWLINE \" ) ; } $ arr = array ( 12 , 35 , 1 , 10 , 34 , 1 ) ; $ n = sizeof ( $ arr ) ; print2largest ( $ arr , $ n ) ; ? >"}
{"text": "Cari Jumlah semua nod pokok binari yang sempurna | berfungsi untuk mencari jumlah semua nod yang diberikan pokok binari yang sempurna; tiada nod daun; Jumlah nod pada tahap terakhir; Jumlah semua nod; Kod pemacu", "code": "< ? php function sumNodes ( $ l ) { $ leafNodeCount = ( $ l - 1 ) * ( $ l - 1 ) ; $ sumLastLevel = 0 ; $ sumLastLevel = ( $ leafNodeCount * ( $ leafNodeCount + 1 ) ) / 2 ; $ sum = $ sumLastLevel * $ l ; return $ sum ; } $ l = 3 ; echo ( sumNodes ( $ l ) ) ; ? >"}
{"text": "Julat Malar Tambah Operasi pada Array | Kaedah utiliti untuk menambah nilai val, ke julat [lo, hi]; Kaedah utiliti untuk mendapatkan array sebenar dari pelbagai operasi; tukar array ke dalam array jumlah awalan; kaedah untuk mencetak array yang dikemas kini akhir; Kod pemacu; Range tambah pertanyaan", "code": "< ? php function add ( & $ arr , $ N , $ lo , $ hi , $ val ) { $ arr [ $ lo ] += $ val ; if ( $ hi != $ N - 1 ) $ arr [ $ hi + 1 ] -= $ val ; } function updateArray ( & $ arr , $ N ) { for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ arr [ $ i ] += $ arr [ $ i - 1 ] ; } function printArr ( & $ arr , $ N ) { updateArray ( $ arr , $ N ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } $ N = 6 ; $ arr = array_fill ( 0 , $ N , NULL ) ; add ( $ arr , $ N , 0 , 2 , 100 ) ; add ( $ arr , $ N , 1 , 5 , 100 ) ; add ( $ arr , $ N , 2 , 3 , 100 ) ; printArr ( $ arr , $ N ) ; ? >"}
{"text": "Pertanyaan untuk GCD dari semua nombor array kecuali unsur -unsur dalam julat yang diberikan | Mengira GCD menggunakan algoritma Euclid; Mengisi array awalan dan akhiran; Mengisi array awalan berikut awalan hubungan (i) = gcd (awalan (i - 1), arr (i)); Mengisi array akhiran berikutan akhiran hubungan (i) = gcd (akhiran (i + 1), arr (i)); Untuk mengira GCD nombor di luar julat; Jika l = 0, kita perlu memberitahu GCD nombor dari R + 1 hingga n; Jika r = n - 1 kita perlu mengembalikan nombor GCD dari 1 hingga l; Kod pemacu", "code": "< ? php function GCD ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return GCD ( $ b , $ a % $ b ) ; } function FillPrefixSuffix ( & $ prefix , & $ arr , & $ suffix , $ n ) { $ prefix [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ prefix [ $ i ] = GCD ( $ prefix [ $ i - 1 ] , $ arr [ $ i ] ) ; $ suffix [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) $ suffix [ $ i ] = GCD ( $ suffix [ $ i + 1 ] , $ arr [ $ i ] ) ; } function GCDoutsideRange ( $ l , $ r , & $ prefix , & $ suffix , $ n ) { if ( $ l == 0 ) return $ suffix [ $ r + 1 ] ; if ( $ r == $ n - 1 ) return $ prefix [ $ l - 1 ] ; return GCD ( $ prefix [ $ l - 1 ] , $ suffix [ $ r + 1 ] ) ; } $ arr = array ( 2 , 6 , 9 ) ; $ n = sizeof ( $ arr ) ; $ prefix = array_fill ( 0 , $ n , NULL ) ; $ suffix = array_fill ( 0 , $ n , NULL ) ; FillPrefixSuffix ( $ prefix , $ arr , $ suffix , $ n ) ; $ l = 0 ; $ r = 0 ; echo GCDoutsideRange ( $ l , $ r , $ prefix , $ suffix , $ n ) . \" \" ; $ l = 1 ; $ r = 1 ; echo GCDoutsideRange ( $ l , $ r , $ prefix , $ suffix , $ n ) . \" \" ; $ l = 1 ; $ r = 2 ; echo GCDoutsideRange ( $ l , $ r , $ prefix , $ suffix , $ n ) . \" \" ; ? >"}
{"text": "Pertanyaan untuk tuduhan array unsur dengan nilai dalam julat yang diberikan | fungsi untuk mengira unsur -unsur dalam julat yang diberikan; memulakan hasil; Semak jika elemen berada dalam julat; Kod pemacu; Menjawab pertanyaan", "code": "< ? php function countInRange ( $ arr , $ n , $ x , $ y ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] >= $ x && $ arr [ $ i ] <= $ y ) $ count ++ ; } return $ count ; } $ arr = array ( 1 , 3 , 4 , 9 , 10 , 3 ) ; $ n = count ( $ arr ) ; $ i = 1 ; $ j = 4 ; echo countInRange ( $ arr , $ n , $ i , $ j ) . \" \" ; $ i = 9 ; $ j = 12 ; echo countInRange ( $ arr , $ n , $ i , $ j ) . \" \" ; ? >"}
{"text": "Pertanyaan untuk tuduhan array unsur dengan nilai dalam julat yang diberikan | fungsi untuk mencari indeks pertama> = x; fungsi untuk mencari indeks terakhir <= y; fungsi untuk mengira unsur -unsur dalam julat yang diberikan; memulakan hasil; Kod pemacu; Array preprocess; Menjawab pertanyaan", "code": "< ? php function lowerIndex ( $ arr , $ n , $ x ) { $ l = 0 ; $ h = $ n - 1 ; while ( $ l <= $ h ) { $ mid = ( $ l + $ h ) / 2 ; if ( $ arr [ $ mid ] >= $ x ) $ h = $ mid - 1 ; else $ l = $ mid + 1 ; } return $ l ; } function upperIndex ( $ arr , $ n , $ y ) { $ l = 0 ; $ h = $ n - 1 ; while ( $ l <= $ h ) { $ mid = ( $ l + $ h ) / 2 ; if ( $ arr [ $ mid ] <= $ y ) $ l = $ mid + 1 ; else $ h = $ mid - 1 ; } return $ h ; } function countInRange ( $ arr , $ n , $ x , $ y ) { $ count = 0 ; $ count = ( upperIndex ( $ arr , $ n , $ y ) - lowerIndex ( $ arr , $ n , $ x ) + 1 ) ; $ t = floor ( $ count ) ; return $ t ; } $ arr = array ( 1 , 4 , 4 , 9 , 10 , 3 ) ; $ n = sizeof ( $ arr ) ; sort ( $ arr ) ; $ i = 1 ; $ j = 4 ; echo countInRange ( $ arr , $ n , $ i , $ j ) , \" \" ; $ i = 9 ; $ j = 12 ; echo countInRange ( $ arr , $ n , $ i , $ j ) , \" \" ; ? >"}
{"text": "Pertanyaan untuk nilai perpuluhan subarrays array binari | Mengisi pra []; Mengembalikan nombor yang diwakili oleh subarray binari L ke R; Jika R adalah sama dengan N - 1 R + 1 tidak wujud; Kod pemacu", "code": "< ? php function precompute ( & $ arr , $ n , & $ pre ) { $ pre [ $ n - 1 ] = $ arr [ $ n - 1 ] * pow ( 2 , 0 ) ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) $ pre [ $ i ] = $ pre [ $ i + 1 ] + $ arr [ $ i ] * ( 1 << ( $ n - 1 - $ i ) ) ; } function decimalOfSubarr ( & $ arr , $ l , $ r , $ n , & $ pre ) { if ( $ r != $ n - 1 ) return ( $ pre [ $ l ] - $ pre [ $ r + 1 ] ) / ( 1 << ( $ n - 1 - $ r ) ) ; return $ pre [ $ l ] / ( 1 << ( $ n - 1 - $ r ) ) ; } $ arr = array ( 1 , 0 , 1 , 0 , 1 , 1 ) ; $ n = sizeof ( $ arr ) ; $ pre = array_fill ( 0 , $ n , NULL ) ; precompute ( $ arr , $ n , $ pre ) ; echo decimalOfSubarr ( $ arr , 2 , 4 , $ n , $ pre ) . \" \" ; echo decimalOfSubarr ( $ arr , 4 , 5 , $ n , $ pre ) . \" \" ; ? >"}
{"text": "Kira elemen yang membahagikan semua nombor dalam julat l | fungsi untuk mengira kerumitan masa elemen o (n ^ 2) kes terburuk; jawapan untuk pertanyaan; Indeks berasaskan 0; melangkah untuk semua elemen; Semak jika elemen membahagikan semua nombor dalam julat; tidak ada unsur; jika semua elemen boleh dibahagikan dengan [i]; jawapan untuk setiap pertanyaan; Kod pemacu", "code": "< ? php function answerQuery ( $ a , $ n , $ l , $ r ) { $ count = 0 ; $ l = $ l - 1 ; for ( $ i = $ l ; $ i < $ r ; $ i ++ ) { $ element = $ a [ $ i ] ; $ divisors = 0 ; for ( $ j = $ l ; $ j < $ r ; $ j ++ ) { if ( $ a [ $ j ] % $ a [ $ i ] == 0 ) $ divisors ++ ; else break ; } if ( $ divisors == ( $ r - $ l ) ) $ count ++ ; } return $ count ; } $ a = array ( 1 , 2 , 3 , 5 ) ; $ n = sizeof ( $ a ) ; $ l = 1 ; $ r = 4 ; echo answerQuery ( $ a , $ n , $ l , $ r ) . \" STRNEWLINE \" ; $ l = 2 ; $ r = 4 ; echo answerQuery ( $ a , $ n , $ l , $ r ) . \" STRNEWLINE \" ;"}
{"text": "Nombor yang jumlahnya XOR dengan julat array yang diberikan adalah maksimum | Program PHP untuk mencari integer terkecil x sedemikian rupa sehingga jumlah XOR dengan julatnya adalah maksimum. ; Berfungsi untuk membuat array awalan yang mengira 1 dari setiap bit sehingga nombor itu; Membuat array awalan yang jumlah jumlah 1 sehingga ke kedudukan itu; Jika b - bit nombor ditetapkan kemudian tambahkan satu ke sebelumnya dikira 1 's; Fungsi untuk mencari x; Pada mulanya mengambil nilai maksimum semua bit 1; Melangkah ke atas setiap bit; Dapatkan 1 's u u u u u u u u u u' '' '' '' '' '' '' '' '' '' '' '' '' '' '' '' '' '' '' \" Jika 1 's' lebih daripada atau sama dengan 'hingga ke ~ maka tidak dapat diselesaikan dengan sedikit dari jawapan; Tetapkan ith bit hingga 0 dengan melakukan XOR dengan 1; Kod pemacu", "code": "< ? php $ one = array ( ) ; $ MAX = 2147483647 ; function make_prefix ( $ A , $ n ) { global $ one , $ MAX ; for ( $ j = 0 ; $ j < 32 ; $ j ++ ) $ one [ 0 ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ a = $ A [ $ i - 1 ] ; for ( $ j = 0 ; $ j < 32 ; $ j ++ ) { $ x = pow ( 2 , $ j ) ; if ( $ a & $ x ) $ one [ $ i ] [ $ j ] = 1 + $ one [ $ i - 1 ] [ $ j ] ; else $ one [ $ i ] [ $ j ] = $ one [ $ i - 1 ] [ $ j ] ; } } } function Solve ( $ L , $ R ) { global $ one , $ MAX ; $ l = $ L ; $ r = $ R ; $ tot_bits = $ r - $ l + 1 ; $ X = $ MAX ; for ( $ i = 0 ; $ i < 31 ; $ i ++ ) { $ x = $ one [ $ r ] [ $ i ] - $ one [ $ l - 1 ] [ $ i ] ; if ( $ x >= ( $ tot_bits - $ x ) ) { $ ith_bit = pow ( 2 , $ i ) ; $ X = $ X ^ $ ith_bit ; } } return $ X ; } $ n = 5 ; $ q = 3 ; $ A = [ 210 , 11 , 48 , 22 , 133 ] ; $ L = [ 1 , 4 , 2 ] ; $ R = [ 3 , 14 , 4 ] ; make_prefix ( $ A , $ n ) ; for ( $ j = 0 ; $ j < $ q ; $ j ++ ) echo ( Solve ( $ L [ $ j ] , $ R [ $ j ] ) . \" STRNEWLINE \" ) ; ? >"}
{"text": "Count pasangan dari 1 hingga a dan 1 hingga b yang jumlahnya boleh dibahagikan dengan n | Fungsi untuk mencari pasangan yang berbeza dari 1 - A & 1 - B supaya jumlahnya dapat dibahagikan dengan n. ; Melangkah lebih dari 1 ke A untuk mencari pasangan yang berbeza; Bagi setiap integer dari 1 hingga b / n bilangan bulat sedemikian rupa sehingga jumlah pasangan boleh dibahagikan dengan n; Jika (i % n + b % n)> = n Satu lagi pasangan adalah mungkin; Jawapan kembali; Kod pemacu", "code": "< ? php function findCountOfPairs ( $ a , $ b , $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) { $ ans += ( int ) ( $ b / $ n ) ; $ ans += ( ( $ i % $ n ) + ( $ b % $ n ) ) >= $ n ? 1 : 0 ; } return $ ans ; } $ a = 5 ; $ b = 13 ; $ n = 3 ; echo findCountOfPairs ( $ a , $ b , $ n ) ; ? >"}
{"text": "Beli Item Minimum Tanpa Perubahan dan Dibayar Syiling | Lihat jika kita boleh membeli kurang daripada 10 item menggunakan 10 duit syiling RS dan satu rs duit syiling; Kami sentiasa boleh membeli 10 item; Kod pemacu", "code": "< ? php function minItems ( $ k , $ r ) { for ( $ i = 1 ; $ i < 10 ; $ i ++ ) if ( ( $ i * $ k - $ r ) % 10 == 0 || ( $ i * $ k ) % 10 == 0 ) return $ i ; return 10 ; } $ k = 15 ; $ r = 2 ; echo minItems ( $ k , $ r ) ; ? >"}
{"text": "Bilangan indeks dengan elemen yang sama dalam julat yang diberikan | fungsi yang menjawab setiap pertanyaan dalam O (R - L); melintasi L ke R dan mengira indeks yang diperlukan; Kod pemacu; 1 - pertanyaan ST; Pertanyaan 2 ND", "code": "< ? php function answer_query ( $ a , $ n , $ l , $ r ) { $ count = 0 ; for ( $ i = $ l ; $ i < $ r ; $ i ++ ) if ( $ a [ $ i ] == $ a [ $ i + 1 ] ) $ count += 1 ; return $ count ; } $ a = array ( 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ) ; $ n = count ( $ a ) ; $ L = 1 ; $ R = 8 ; echo ( answer_query ( $ a , $ n , $ L , $ R ) . \" \" ) ; $ L = 0 ; $ R = 4 ; echo ( answer_query ( $ a , $ n , $ L , $ R ) . \" \" ) ; ? >"}
{"text": "Bilangan indeks dengan elemen yang sama dalam julat yang diberikan | Program PHP untuk mengira bilangan indeks dalam julat l r seperti AI = AI + 1; array untuk menyimpan kiraan indeks dari 0 hingga saya yang mematuhi keadaan; prefixan precomputing [] array; melintasi untuk mengira array prefixans []; fungsi yang menjawab setiap pertanyaan dalam O (1); Kod pemacu; pra - pengiraan; 1 - pertanyaan ST; Pertanyaan 2 ND", "code": "< ? php $ N = 1000 ; $ prefixans = array_fill ( 0 , $ N , 0 ) ; function countIndex ( $ a , $ n ) { global $ N , $ prefixans ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ a [ $ i ] == $ a [ $ i + 1 ] ) $ prefixans [ $ i ] = 1 ; if ( $ i != 0 ) $ prefixans [ $ i ] += $ prefixans [ $ i - 1 ] ; } } function answer_query ( $ l , $ r ) { global $ N , $ prefixans ; if ( $ l == 0 ) return $ prefixans [ $ r - 1 ] ; else return ( $ prefixans [ $ r - 1 ] - $ prefixans [ $ l - 1 ] ) ; } $ a = array ( 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ) ; $ n = count ( $ a ) ; countIndex ( $ a , $ n ) ; $ L = 1 ; $ R = 8 ; echo ( answer_query ( $ L , $ R ) . \" \" ) ; $ L = 0 ; $ R = 4 ; echo ( answer_query ( $ L , $ R ) . \" \" ) ; ? >"}
{"text": "Count Subarrays dengan Perdana Sum | Berfungsi untuk mengira subarray dengan jumlah perdana; Gunakan ayak untuk mencari semua nombor perdana kurang daripada atau sama dengan max_val Buat array boolean \"Perdana [0 ... N]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Baki bahagian Sieve; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Memulakan hasil; Melintasi array; jawapan kembali; Program Pemandu", "code": "< ? php function primeSubarrays ( $ A , $ n ) { $ max_val = pow ( 10 , 5 ) ; $ prime = array_fill ( 0 , $ max_val + 1 , true ) ; $ prime [ 0 ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ max_val ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ max_val ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { $ val = $ A [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ n ; ++ $ j ) { $ val += $ A [ $ j ] ; if ( $ prime [ $ val ] ) ++ $ cnt ; } } return $ cnt ; } $ A = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = count ( $ A ) ; echo primeSubarrays ( $ A , $ n ) ; ? >"}
{"text": "Jumlah nombor tanpa digit berulang dalam julat | Berfungsi untuk memeriksa sama ada nombor yang diberikan telah berulang digit atau tidak; Melintasi setiap digit; Jika digit hadir lebih dari sekali dalam nombor; kembali 0 jika nombor telah mengulangi digit; kembali 1 jika nombor itu tidak mempunyai digit berulang; Berfungsi untuk mencari jumlah keseluruhan dalam julat yang diberikan yang tidak mempunyai digit berulang; Melintasi julat; Tambah 1 kepada jawapan jika saya tidak mempunyai angka berulang lagi 0; Kod pemacu; Memanggil Hitung", "code": "< ? php function repeated_digit ( $ n ) { $ c = 10 ; $ a = array_fill ( 0 , $ c , 0 ) ; while ( $ n > 0 ) { $ d = $ n % 10 ; if ( $ a [ $ d ] > 0 ) { return 0 ; } $ a [ $ d ] ++ ; $ n = ( int ) ( $ n / 10 ) ; } return 1 ; } function calculate ( $ L , $ R ) { $ answer = 0 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { $ answer += repeated_digit ( $ i ) ; } return $ answer ; } $ L = 1 ; $ R = 100 ; echo calculate ( $ L , $ R ) ; ? >"}
{"text": "Swap minimum diperlukan untuk membuat rentetan binari bergantian | Mengembalikan bilangan swap minimum rentetan binari yang diluluskan sebagai hujah untuk menjadikannya bergantian; Mengira bilangan sifar pada kedudukan ganjil dan bahkan; Mengira bilangan yang ganjil dan juga kedudukan; Rentetan berganti bermula dengan 0; Rentetan berganti bermula dengan 1; mengira bilangan swap minimum; Kod pemacu", "code": "< ? php function countMinSwaps ( $ st ) { $ min_swaps = 0 ; $ odd_0 = 0 ; $ even_0 = 0 ; $ odd_1 = 0 ; $ even_1 = 0 ; $ n = strlen ( $ st ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) { if ( $ st [ $ i ] == '1' ) { $ even_1 ++ ; } else { $ even_0 ++ ; } } else { if ( $ st [ $ i ] == '1' ) { $ odd_1 ++ ; } else { $ odd_0 ++ ; } } } $ cnt_swaps_1 = min ( $ even_0 , $ odd_1 ) ; $ cnt_swaps_2 = min ( $ even_1 , $ odd_0 ) ; return min ( $ cnt_swaps_1 , $ cnt_swaps_2 ) ; } $ st = \"000111\" ; echo ( countMinSwaps ( $ st ) ) ; ? >"}
{"text": "Cari nilai fungsi y = (x ^ 6 + x ^ 2 + 9894845) % 971 | Pengkomputeran (A ^ B) % C; Kod pemacu", "code": "< ? php function modpow ( $ base , $ exp , $ modulus ) { $ base %= $ modulus ; $ result = 1 ; while ( $ exp > 0 ) { if ( $ exp & 1 ) $ result = ( $ result * $ base ) % $ modulus ; $ base = ( $ base * $ base ) % $ modulus ; $ exp >>= 1 ; } return $ result ; } $ n = 654654 ; $ mod = 971 ; echo ( ( ( modpow ( $ n , 6 , $ mod ) + modpow ( $ n , 2 , $ mod ) ) % $ mod + 355 ) % $ mod ) ; ? >"}
{"text": "Subarray Bersebelahan Jumlah Terbesar | Program PHP untuk mencetak jumlah array bersebelahan terbesar; Kod pemacu", "code": "< ? php function maxSubArraySum ( $ a , $ size ) { $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; } return $ max_so_far ; } $ a = array ( -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 ) ; $ n = count ( $ a ) ; $ max_sum = maxSubArraySum ( $ a , $ n ) ; echo \" Maximum ▁ contiguous ▁ sum ▁ is ▁ \" , $ max_sum ; ? >"}
{"text": "Subarray Bersebelahan Jumlah Terbesar |  ; Jangan bandingkan untuk semua elemen. Bandingkan hanya apabila max_ending_here> 0", "code": "< ? php < ? php function maxSubArraySum ( & $ a , $ size ) { $ max_so_far = $ a [ 0 ] ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; else if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; } return $ max_so_far ; ? >"}
{"text": "Bilik minimum untuk peristiwa M Batch N dengan jadual yang diberikan | Mengembalikan bilangan minimum bilik yang diperlukan untuk melaksanakan kelas kumpulan N dalam slot M dengan jadual yang diberikan. ; Kira -kira kelas yang berlaku di setiap slot. ; memulakan semua nilai kepada sifar; Bilangan bilik yang diperlukan adalah sama dengan kelas maksimum yang berlaku dalam slot tertentu. ; Kod pemacu", "code": "< ? php function findMinRooms ( $ slots , $ n , $ m ) { $ counts = array_fill ( 0 , $ m , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ slots [ $ i ] [ $ j ] == '1' ) $ counts [ $ j ] ++ ; return max ( $ counts ) ; } $ n = 3 ; $ m = 7 ; $ slots = array ( \"0101011\" , \"0011001\" , \"0110111\" ) ; echo findMinRooms ( $ slots , $ n , $ m ) ; ? >"}
{"text": "Subarray Bersebelahan Jumlah Terbesar |  ; Kod pemacu", "code": "< ? php < ? php function maxSubArraySum ( $ a , $ size ) { $ max_so_far = $ a [ 0 ] ; $ curr_max = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) { $ curr_max = max ( $ a [ $ i ] , $ curr_max + $ a [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ curr_max ) ; } return $ max_so_far ; } $ a = array ( -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 ) ; $ n = sizeof ( $ a ) ; $ max_sum = maxSubArraySum ( $ a , $ n ) ; echo \" Maximum ▁ contiguous ▁ sum ▁ is ▁ \" . $ max_sum ; ? >"}
{"text": "Subarray Bersebelahan Jumlah Terbesar | Program PHP untuk mencetak jumlah array bersebelahan terbesar; Kod pemacu", "code": "< ? php function maxSubArraySum ( $ a , $ size ) { $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; $ start = 0 ; $ end = 0 ; $ s = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here += $ a [ $ i ] ; if ( $ max_so_far < $ max_ending_here ) { $ max_so_far = $ max_ending_here ; $ start = $ s ; $ end = $ i ; } if ( $ max_ending_here < 0 ) { $ max_ending_here = 0 ; $ s = $ i + 1 ; } } echo \" Maximum ▁ contiguous ▁ sum ▁ is ▁ \" . $ max_so_far . \" STRNEWLINE \" ; echo \" Starting ▁ index ▁ \" . $ start . \" \" . STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Ending index \" ▁ . ▁ $ end ▁ . ▁ \" \" } $ a = array ( -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 ) ; $ n = sizeof ( $ a ) ; $ max_sum = maxSubArraySum ( $ a , $ n ) ; ? >"}
{"text": "Cari bilangan minimum nota mata wang dan nilai yang jumlahnya kepada jumlah yang diberikan | fungsi untuk mengira dan nota prcurrency; Nota kiraan menggunakan pendekatan tamak; Nota cetak; Kod pemacu", "code": "< ? php function countCurrency ( $ amount ) { $ notes = array ( 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ) ; $ noteCounter = array ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < 9 ; $ i ++ ) { if ( $ amount >= $ notes [ $ i ] ) { $ noteCounter [ $ i ] = intval ( $ amount / $ notes [ $ i ] ) ; $ amount = $ amount - $ noteCounter [ $ i ] * $ notes [ $ i ] ; } } echo ( \" Currency ▁ Count ▁ - > \" . \" STRNEWLINE \" ) ; for ( $ i = 0 ; $ i < 9 ; $ i ++ ) { if ( $ noteCounter [ $ i ] != 0 ) { echo ( $ notes [ $ i ] . \" : \" ▁ . ▁ $ noteCounter [ $ i ] ▁ . ▁ \" \" } } } $ amount = 868 ; countCurrency ( $ amount ) ; ? >"}
{"text": "Jumlah minimum dengan memilih minimum pasangan dari array | Mengembalikan jumlah minimum yang mungkin dalam array b []; Kod pemacu", "code": "< ? php function minSum ( $ A , $ n ) { $ min_val = min ( $ A ) ; return ( $ min_val * ( $ n - 1 ) ) ; } $ A = array ( 3 , 6 , 2 , 8 , 7 , 5 ) ; $ n = count ( $ A ) ; echo minSum ( $ A , $ n ) ; ? >"}
{"text": "Program untuk Algoritma Fit Seterusnya dalam Pengurusan Memori | Berfungsi untuk memperuntukkan memori ke blok mengikut algoritma sesuai seterusnya; Kedai blok ID blok yang diperuntukkan kepada proses; Pilih setiap proses dan cari blok yang sesuai mengikut saiz iklannya yang diberikan kepadanya; Jangan bermula dari awal; memperuntukkan blok j ke P [i] proses; Kurangkan memori yang ada di blok ini. ; Mod M akan membantu melintasi blok dari blok permulaan selepas kami sampai ke akhir. ; Program Pemandu", "code": "< ? php function NextFit ( $ blockSize , $ m , $ processSize , $ n ) { $ allocation = array_fill ( 0 , $ n , -1 ) ; $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ j < $ m ) { if ( $ blockSize [ $ j ] >= $ processSize [ $ i ] ) { $ allocation [ $ i ] = $ j ; $ blockSize [ $ j ] -= $ processSize [ $ i ] ; break ; } $ j = ( $ j + 1 ) % $ m ; } } echo \" Process No . Process Size Block no . \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo \" \" . ( $ i ▁ + ▁ 1 ) . \" \" . $ processSize [ $ i ] . \" \" if ( $ allocation [ $ i ] != -1 ) echo ( $ allocation [ $ i ] + 1 ) ; else echo \" Not ▁ Allocated \" ; echo \" STRNEWLINE \" ; } } $ blockSize = array ( 5 , 10 , 20 ) ; $ processSize = array ( 10 , 20 , 5 ) ; $ m = count ( $ blockSize ) ; $ n = count ( $ processSize ) ; NextFit ( $ blockSize , $ m , $ processSize , $ n ) ; ? >"}
{"text": "Cari subarray dengan sekurang -kurangnya purata | Cetakan bermula dan mengakhiri indeks subarray saiz K dengan purata minimum; k mestilah lebih kecil daripada atau sama dengan n; Memulakan indeks permulaan hasil; Kirakan jumlah subarray pertama saiz k; Memulakan jumlah minimum sebagai jumlah semasa; Melintasi (k + 1) 'th »elemen ke elemen; Tambah item semasa dan keluarkan item pertama subarray sebelumnya; Hasil kemas kini jika diperlukan; Kod pemacu; Saiz subarray", "code": "< ? php function findMinAvgSubarray ( $ arr , $ n , $ k ) { if ( $ n < $ k ) return ; $ res_index = 0 ; $ curr_sum = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ curr_sum += $ arr [ $ i ] ; $ min_sum = $ curr_sum ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ curr_sum += $ arr [ $ i ] - $ arr [ $ i - $ k ] ; if ( $ curr_sum < $ min_sum ) { $ min_sum = $ curr_sum ; $ res_index = ( $ i - $ k + 1 ) ; } } echo \" Subarray between [ \" ▁ , $ res _ index ▁ , ▁ \" , \" ▁ , $ res _ index ▁ + ▁ $ k ▁ - ▁ 1 , ▁ \" ] has minimum average \" ; } $ arr = array ( 3 , 7 , 90 , 20 , 10 , 50 , 40 ) ; $ k = 3 ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; findMinAvgSubarray ( $ arr , $ n , $ k ) ; return 0 ; ? >"}
{"text": "Cari elemen menggunakan segmen minimum dalam tujuh paparan segmen | Nilai -nilai segmen yang digunakan oleh digit 0 hingga 9 .; Kembalikan bilangan segmen yang digunakan oleh x. ; Mencari jumlah segmen yang digunakan oleh setiap digit nombor. ; Memulakan segmen minimum dan indeks nombor minimum. ; Mencari dan membandingkan segmen yang digunakan oleh setiap nombor ARR [i]. ; Jika ARR [i] menggunakan segmen kurang maka kemas kini segmen minimum dan nombor minimum. ; Kod pemacu", "code": "< ? php $ seg = array ( 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ) ; function computeSegment ( $ x ) { global $ seg ; if ( $ x == 0 ) return $ seg [ 0 ] ; $ count = 0 ; while ( $ x ) { $ count += $ seg [ $ x % 10 ] ; $ x = ( int ) $ x / 10 ; } return $ count ; } function elementMinSegment ( $ arr , $ n ) { $ minseg = computeSegment ( $ arr [ 0 ] ) ; $ minindex = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ temp = computeSegment ( $ arr [ $ i ] ) ; if ( $ temp < $ minseg ) { $ minseg = $ temp ; $ minindex = $ i ; } } return $ arr [ $ minindex ] ; } $ arr = array ( 489 , 206 , 745 , 123 , 756 ) ; $ n = sizeof ( $ arr ) ; echo elementMinSegment ( $ arr , $ n ) , \" \" ; ? >"}
{"text": "Cari nombor terbesar dengan jumlah digit dan jumlah digit | Mencetak nombor yang mungkin kecil dengan nombor digit 'S' dan 'M' digit. ; Jika jumlah digit adalah 0, maka nombor adalah mungkin hanya jika bilangan digit adalah 1; Jumlah lebih besar daripada jumlah maksimum yang mungkin. ; Isi dari digit yang paling penting ke digit paling tidak penting. ; Isi 9 pertama untuk membuat nombor terbesar; Jika baki jumlah menjadi kurang daripada 9, maka isi jumlah yang tinggal; Kod pemacu", "code": "< ? php function findLargest ( $ m , $ s ) { if ( $ s == 0 ) { if ( ( $ m == 1 ) == true ) echo \" Largest ▁ number ▁ is ▁ \" , 0 ; else echo \" Not ▁ possible \" ; return ; } if ( $ s > 9 * $ m ) { echo \" Not ▁ possible \" ; return ; } for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ s >= 9 ) { $ res [ $ i ] = 9 ; $ s -= 9 ; } else { $ res [ $ i ] = $ s ; $ s = 0 ; } } echo \" Largest ▁ number ▁ is ▁ \" ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) echo $ res [ $ i ] ; } $ s = 9 ; $ m = 2 ; findLargest ( $ m , $ s ) ; ? >"}
{"text": "Bilangan lompat minimum untuk mencapai hujung | Mengembalikan bilangan lompatan minimum untuk mencapai arr [h] dari arr [l]; Kes asas: Apabila sumber dan destinasi sama; Apabila tiada apa yang dapat dicapai dari sumber yang diberikan; Melintasi semua mata yang dapat dicapai dari arr [l]. Recursif Dapatkan bilangan lompatan minimum yang diperlukan untuk mencapai arr [H] dari titik -titik yang dapat dicapai ini. ; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function minJumps ( $ arr , $ l , $ h ) { if ( $ h == $ l ) return 0 ; if ( $ arr [ $ l ] == 0 ) return INT_MAX ; $ min = 999999 ; for ( $ i = $ l + 1 ; $ i <= $ h && $ i <= $ l + $ arr [ $ l ] ; $ i ++ ) { $ jumps = minJumps ( $ arr , $ i , $ h ) ; if ( $ jumps != 999999 && $ jumps + 1 < $ min ) $ min = $ jumps + 1 ; } return $ min ; } $ arr = array ( 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 ) ; $ n = count ( $ arr ) ; echo \" Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach ▁ \" . \" end ▁ is ▁ \" . minJumps ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text": "Bilangan lompat minimum untuk mencapai hujung | Mengembalikan bilangan lompatan minimum untuk mencapai hujung; melompat [0] akan memegang hasilnya; Bilangan lompatan minimum yang diperlukan untuk mencapai elemen terakhir dari unsur -unsur terakhir itu sendiri selalu 0; Mulakan dari elemen kedua, bergerak dari kanan ke kiri dan membina array lompatan [] di mana melompat [i] mewakili bilangan lompatan minimum yang diperlukan untuk mencapai arr [m - 1] dari arr [i]; Jika arr [i] adalah 0 maka arr [n - 1] tidak dapat dicapai dari sini; Sekiranya kita dapat mencapai titik akhir dari sini maka melompat [i] adalah 1; Jika tidak, untuk mengetahui bilangan lompatan minimum yang diperlukan untuk mencapai ARR [n - 1], periksa semua mata yang boleh dicapai dari sini dan melompat [] nilai untuk mata tersebut; memulakan nilai min; Mengikuti pemeriksaan gelung dengan semua titik yang boleh dicapai dan mengambil minimum; Mengendalikan limpahan; atau int_max; Kod pemacu", "code": "< ? php function minJumps ( $ arr , $ n ) { $ jumps [ $ n ] = array ( ) ; $ min ; $ jumps [ $ n - 1 ] = array ( 0 ) ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] == 0 ) $ jumps [ $ i ] = PHP_INT_MAX ; else if ( $ arr [ $ i ] >= ( $ n - $ i ) - 1 ) $ jumps [ $ i ] = 1 ; else { $ min = PHP_INT_MAX ; for ( $ j = $ i + 1 ; $ j < $ n && $ j <= $ arr [ $ i ] + $ i ; $ j ++ ) { if ( $ min > $ jumps [ $ j ] ) $ min = $ jumps [ $ j ] ; } if ( $ min != PHP_INT_MAX ) $ jumps [ $ i ] = $ min + 1 ; else $ jumps [ $ i ] = $ min ; } } return $ jumps [ 0 ] ; } $ arr = array ( 1 , 3 , 6 , 1 , 0 , 9 ) ; $ size = sizeof ( $ arr ) ; echo \" Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach \" , \" ▁ end ▁ is ▁ \" , minJumps ( $ arr , $ size ) ; ? >"}
{"text": "Subarray terkecil dengan jumlah yang lebih besar daripada nilai tertentu | Mengembalikan panjang subarray terkecil dengan jumlah yang lebih besar daripada x. Sekiranya tidak ada subarray dengan jumlah yang diberikan, maka pulangan n + 1; Memulakan panjang subarray terkecil sebagai n + 1; Pilih setiap elemen sebagai titik permulaan; Memulakan jumlah bermula dengan permulaan semasa; Jika elemen pertama itu sendiri lebih besar; Cuba titik akhir yang berbeza untuk permulaan Curremt; Tambah elemen terakhir kepada jumlah semasa; Jika jumlah menjadi lebih daripada x dan panjang subarray ini lebih kecil daripada panjang terkecil semasa, kemas kini panjang terkecil (atau hasil); Kod pemacu", "code": "< ? php function smallestSubWithSum ( $ arr , $ n , $ x ) { $ min_len = $ n + 1 ; for ( $ start = 0 ; $ start < $ n ; $ start ++ ) { $ curr_sum = $ arr [ $ start ] ; if ( $ curr_sum > $ x ) return 1 ; for ( $ end = $ start + 1 ; $ end < $ n ; $ end ++ ) { $ curr_sum += $ arr [ $ end ] ; if ( $ curr_sum > $ x && ( $ end - $ start + 1 ) < $ min_len ) $ min_len = ( $ end - $ start + 1 ) ; } } return $ min_len ; } $ arr1 = array ( 1 , 4 , 45 , 6 , 10 , 19 ) ; $ x = 51 ; $ n1 = sizeof ( $ arr1 ) ; $ res1 = smallestSubWithSum ( $ arr1 , $ n1 , $ x ) ; if ( ( $ res1 == $ n1 + 1 ) == true ) echo \" Not ▁ possible STRNEWLINE \" ; else echo $ res1 , \" STRNEWLINE \" ; $ arr2 = array ( 1 , 10 , 5 , 2 , 7 ) ; $ n2 = sizeof ( $ arr2 ) ; $ x = 9 ; $ res2 = smallestSubWithSum ( $ arr2 , $ n2 , $ x ) ; if ( ( $ res2 == $ n2 + 1 ) == true ) echo \" Not ▁ possible STRNEWLINE \" ; else echo $ res2 , \" STRNEWLINE \" ; $ arr3 = array ( 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ) ; $ n3 = sizeof ( $ arr3 ) ; $ x = 280 ; $ res3 = smallestSubWithSum ( $ arr3 , $ n3 , $ x ) ; if ( ( $ res3 == $ n3 + 1 ) == true ) echo \" Not ▁ possible STRNEWLINE \" ; else echo $ res3 , \" STRNEWLINE \" ; ? >"}
{"text": "Subarray terkecil dengan jumlah yang lebih besar daripada nilai tertentu | Mengembalikan panjang subarray terkecil dengan jumlah yang lebih besar daripada x. Sekiranya tidak ada subarray dengan jumlah yang diberikan, maka pulangan n + 1; Memulakan jumlah semasa dan panjang minimum; Memulakan indeks permulaan dan akhir; Terus menambah elemen array manakala jumlah semasa lebih kecil daripada atau sama dengan x; Jika jumlah semasa menjadi lebih besar daripada x. ; Mengemas kini panjang minimum jika diperlukan; keluarkan elemen permulaan; Kod pemacu", "code": "< ? php function smallestSubWithSum ( $ arr , $ n , $ x ) { $ curr_sum = 0 ; $ min_len = $ n + 1 ; $ start = 0 ; $ end = 0 ; while ( $ end < $ n ) { while ( $ curr_sum <= $ x && $ end < $ n ) $ curr_sum += $ arr [ $ end ++ ] ; while ( $ curr_sum > $ x && $ start < $ n ) { if ( $ end - $ start < $ min_len ) $ min_len = $ end - $ start ; $ curr_sum -= $ arr [ $ start ++ ] ; } } return $ min_len ; } $ arr1 = array ( 1 , 4 , 45 , 6 , 10 , 19 ) ; $ x = 51 ; $ n1 = sizeof ( $ arr1 ) ; $ res1 = smallestSubWithSum ( $ arr1 , $ n1 , $ x ) ; if ( $ res1 == $ n1 + 1 ) echo \" Not ▁ possible STRNEWLINE \" ; else echo $ res1 , \" STRNEWLINE \" ; $ arr2 = array ( 1 , 10 , 5 , 2 , 7 ) ; $ n2 = sizeof ( $ arr2 ) ; $ x = 9 ; $ res2 = smallestSubWithSum ( $ arr2 , $ n2 , $ x ) ; if ( $ res2 == $ n2 + 1 ) echo \" Not ▁ possible STRNEWLINE \" ; else echo $ res2 , \" STRNEWLINE \" ; $ arr3 = array ( 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ) ; $ n3 = sizeof ( $ arr3 ) ; $ x = 280 ; $ res3 = smallestSubWithSum ( $ arr3 , $ n3 , $ x ) ; if ( $ res3 == $ n3 + 1 ) echo \" Not ▁ possible STRNEWLINE \" ; else echo $ res3 , \" STRNEWLINE \" ; ? >"}
{"text": "Kira langkah minimum untuk mendapatkan array yang dikehendaki | Mengembalikan kiraan operasi minimum untuk menukar array sifar ke array sasaran dengan kenaikan dan operasi dua kali ganda. Fungsi ini mengira kiraan dengan melakukan langkah terbalik, i. e. , menukar sasaran kepada sifar. ; Memulakan hasil (kiraan langkah minimum); Teruskan gelung sementara semua elemen sasaran tidak menjadi 0 .; Untuk menyimpan kiraan sifar dalam array sasaran semasa; Untuk mencari elemen ganjil pertama; Jika nombor ganjil dijumpai; Jika 0, maka kenaikan sifar_count; Semua nombor adalah 0; Semua nombor juga; Bahagikan keseluruhan array dengan 2 dan hasil kenaikan; Buat semua nombor ganjil walaupun dengan menolak satu dan hasil kenaikan. ; Kod pemacu", "code": "< ? php function countMinOperations ( $ target , $ n ) { $ result = 0 ; while ( 1 ) { $ zero_count = 0 ; $ i = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ target [ $ i ] & 1 ) break ; else if ( $ target [ $ i ] == 0 ) $ zero_count ++ ; } if ( $ zero_count == $ n ) return $ result ; if ( $ i == $ n ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ target [ $ j ] = $ target [ $ j ] / 2 ; $ result ++ ; } for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { if ( $ target [ $ j ] & 1 ) { $ target [ $ j ] -- ; $ result ++ ; } } } } $ arr = array ( 16 , 16 , 16 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum ▁ number ▁ of ▁ steps ▁ required ▁ to ▁ STRNEWLINE \" . \" get ▁ the ▁ given ▁ target ▁ array ▁ is ▁ \" . countMinOperations ( $ arr , $ n ) ; ? >"}
{"text": "Cari bilangan minimum operasi gabungan untuk membuat palindrome array | Mengembalikan bilangan minimum operasi kiraan yang diperlukan untuk membuat Palindrome; Memulakan hasil; Bermula dari dua sudut; Jika elemen sudut sama, masalah mengurangkan ARR [i + 1. J - 1]; Jika elemen kiri lebih besar, maka kita bergabung dengan dua elemen kanan; perlu bergabung dari ekor. ; Lain kita bergabung meninggalkan dua elemen; Kod pemacu", "code": "< ? php function findMinOps ( $ arr , $ n ) { $ ans = 1 ; for ( $ i = 0 , $ j = $ n - 1 ; $ i <= $ j { if ( $ arr [ $ i ] == $ arr [ $ j ] ) { $ i ++ ; $ j -- ; } else if ( $ arr [ $ i ] > $ arr [ $ j ] ) { $ j -- ; $ arr [ $ j ] += $ arr [ $ j + 1 ] ; $ ans ++ ; } else { $ i ++ ; $ arr [ $ i ] += $ arr [ $ i - 1 ] ; $ ans ++ ; } } return $ ans ; } $ arr [ ] = array ( 1 , 4 , 5 , 9 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Count ▁ of ▁ minimum ▁ operations ▁ is ▁ \" , findMinOps ( $ arr , $ n ) ; ? >"}
{"text": "Cari nilai integer positif terkecil yang tidak dapat diwakili sebagai jumlah subset dari array yang diberikan | Mengembalikan bilangan terkecil yang tidak dapat diwakili sebagai jumlah subset unsur -unsur dari set yang diwakili oleh array array yang disusun [0. n - 1]; Memulakan hasil; Melintasi array dan kenaikan 'res' jika arr [i] lebih kecil daripada atau sama dengan 'res'. ; Kod pemacu", "code": "< ? php function findSmallest ( $ arr , $ n ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ n and $ arr [ $ i ] <= $ res ; $ i ++ ) $ res = $ res + $ arr [ $ i ] ; return $ res ; } $ arr1 = array ( 1 , 3 , 4 , 5 ) ; $ n1 = count ( $ arr1 ) ; echo findSmallest ( $ arr1 , $ n1 ) , \" STRNEWLINE \" ; $ arr2 = array ( 1 , 2 , 6 , 10 , 11 , 15 ) ; $ n2 = count ( $ arr2 ) ; echo findSmallest ( $ arr2 , $ n2 ) , \" STRNEWLINE \" ; $ arr3 = array ( 1 , 1 , 1 , 1 ) ; $ n3 = count ( $ arr3 ) ; echo findSmallest ( $ arr3 , $ n3 ) , \" STRNEWLINE \" ; $ arr4 = array ( 1 , 1 , 3 , 4 ) ; $ n4 = count ( $ arr4 ) ; echo findSmallest ( $ arr4 , $ n4 ) ; ? >"}
{"text": "Cari perbezaan minimum antara dua elemen | Mengembalikan perbezaan minimum antara mana -mana pasangan; Memulakan perbezaan sebagai tak terhingga; Cari Min diff dengan membandingkan perbezaan semua pasangan yang mungkin dalam array yang diberikan; Pulangan min diff; Kod pemacu", "code": "< ? php function findMinDiff ( $ arr , $ n ) { $ diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) < $ diff ) $ diff = abs ( $ arr [ $ i ] - $ arr [ $ j ] ) ; return $ diff ; } $ arr = array ( 1 , 5 , 3 , 19 , 18 , 25 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum ▁ difference ▁ is ▁ \" , findMinDiff ( $ arr , $ n ) ; ? >"}
{"text": "Cari perbezaan minimum antara dua elemen | Mengembalikan perbezaan minimum antara mana -mana pasangan; Susun array dalam perintah yang tidak menurun; Memulakan perbezaan sebagai tak terhingga; Cari Min diff dengan membandingkan pasangan bersebelahan dalam array yang disusun; Pulangan min diff; Kod pemacu", "code": "< ? php function findMinDiff ( $ arr , $ n ) { sort ( $ arr ) ; $ diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i + 1 ] - $ arr [ $ i ] < $ diff ) $ diff = $ arr [ $ i + 1 ] - $ arr [ $ i ] ; return $ diff ; } $ arr = array ( 1 , 5 , 3 , 19 , 18 , 25 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum ▁ difference ▁ is ▁ \" , findMinDiff ( $ arr , $ n ) ; ? >"}
{"text": "Pengoptimuman Ruang Menggunakan Manipulasi Bit | Kod pemacu; Melangkah melalui A ke B, jika ia adalah pelbagai indeks 2 atau 5 markah dalam array sebagai 1", "code": "< ? php $ a = 2 ; $ b = 10 ; $ size = abs ( $ b - $ a ) + 1 ; $ array = array_fill ( 0 , $ size , 0 ) ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) if ( $ i % 2 == 0 $ i % 5 == 0 ) $ array [ $ i - $ a ] = 1 ; echo \" MULTIPLES ▁ of ▁ 2 ▁ and ▁ 5 : STRNEWLINE \" ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) if ( $ array [ $ i - $ a ] == 1 ) echo $ i . \" \" ; ? >"}
{"text": "Rentang terpanjang dengan jumlah yang sama dalam dua tatasusunan binari | Mengembalikan panjang subarray yang paling lama dengan jumlah yang sama; Memulakan hasil; Satu demi satu memilih semua titik permulaan subarrays yang mungkin; Memulakan jumlah subarray semasa; Conider semua mata untuk bermula dengan ARR [i]; Kemas kini Jumlah; Jika jumlah yang sama dan panjang semasa lebih daripada Maxlen, kemas kini Maxlen; Kod pemacu", "code": "< ? php function longestCommonSum ( $ arr1 , $ arr2 , $ n ) { $ maxLen = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ sum1 += $ arr1 [ $ j ] ; $ sum2 += $ arr2 [ $ j ] ; if ( $ sum1 == $ sum2 ) { $ len = $ j - $ i + 1 ; if ( $ len > $ maxLen ) $ maxLen = $ len ; } } } return $ maxLen ; } $ arr1 = array ( 0 , 1 , 0 , 1 , 1 , 1 , 1 ) ; $ arr2 = array ( 1 , 1 , 1 , 1 , 1 , 0 , 1 ) ; $ n = sizeof ( $ arr1 ) ; echo \" Length ▁ of ▁ the ▁ longest ▁ common ▁ span ▁ \" . \" with ▁ same ▁ \" , \" sum ▁ is ▁ \" , longestCommonSum ( $ arr1 , $ arr2 , $ n ) ; ? >"}
{"text": "Gabungkan pelbagai saiz n ke dalam pelbagai saiz m + n | Dengan asumsi - 1 dipenuhi untuk tempat -tempat di mana elemen tidak tersedia; Berfungsi untuk memindahkan elemen m pada akhir array mplusn []; Menggabungkan array n [] saiz n ke dalam array mplusn [] saiz m + n; Indeks semasa I / P bahagian MPLUSN []; Indeks semasa N []; Indeks semasa output mplusn []; Ambil elemen dari mplusn [] jika a) nilai elemen yang dipilih lebih kecil dan kami belum sampai ke akhir b) Kami telah mencapai akhir n []; Jika tidak, ambil elemen dari n []; Utiliti yang mencetak array pada baris; Memulakan susunan; Gerakkan elemen M pada akhir Mplusn; Gabungan n [] ke mplusn []; Cetak mplusn yang dihasilkan", "code": "< ? php $ NA = -1 ; function moveToEnd ( & $ mPlusN , $ size ) { global $ NA ; $ j = $ size - 1 ; for ( $ i = $ size - 1 ; $ i >= 0 ; $ i -- ) if ( $ mPlusN [ $ i ] != $ NA ) { $ mPlusN [ $ j ] = $ mPlusN [ $ i ] ; $ j -- ; } } function merge ( & $ mPlusN , & $ N , $ m , $ n ) { $ i = $ n ; $ j = 0 ; $ k = 0 ; while ( $ k < ( $ m + $ n ) ) { if ( ( $ j == $ n ) || ( $ i < ( $ m + $ n ) && $ mPlusN [ $ i ] <= $ N [ $ j ] ) ) { $ mPlusN [ $ k ] = $ mPlusN [ $ i ] ; $ k ++ ; $ i ++ ; } else { $ mPlusN [ $ k ] = $ N [ $ j ] ; $ k ++ ; $ j ++ ; } } } function printArray ( & $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } $ mPlusN = array ( 2 , 8 , $ NA , $ NA , $ NA , 13 , $ NA , 15 , 20 ) ; $ N = array ( 5 , 7 , 9 , 25 ) ; $ n = sizeof ( $ N ) ; $ m = sizeof ( $ mPlusN ) - $ n ; moveToEnd ( $ mPlusN , $ m + $ n ) ; merge ( $ mPlusN , $ N , $ m , $ n ) ; printArray ( $ mPlusN , $ m + $ n ) ; ? >"}
{"text": "Susun 1 hingga n dengan menukar elemen bersebelahan | Kembali benar jika array boleh disusun sebaliknya palsu; Semak array bool b dan jenis elemen untuk urutan berterusan 1; Susun array A dari saya ke J; Periksa sama ada array disusun atau tidak; Kod pemacu", "code": "< ? php function sortedAfterSwap ( $ A , $ B , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ B [ $ i ] ) { $ j = $ i ; while ( $ B [ $ j ] ) $ j ++ ; sort ( $ A ) ; $ i = $ j ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ A [ $ i ] != $ i + 1 ) return false ; } return true ; } $ A = array ( 1 , 2 , 5 , 3 , 4 , 6 ) ; $ B = array ( 0 , 1 , 1 , 1 , 0 ) ; $ n = count ( $ A ) ; if ( sortedAfterSwap ( $ A , $ B , $ n ) ) echo \" A ▁ can ▁ be ▁ sorted STRNEWLINE \" ; else echo \" A ▁ can ▁ not ▁ be ▁ sorted STRNEWLINE \" ; ? >"}
{"text": "Susun 1 hingga n dengan menukar elemen bersebelahan | Kembali benar jika array boleh disusun sebaliknya palsu; Periksa sama ada array disusun atau tidak; Kod pemacu", "code": "< ? php function sortedAfterSwap ( & $ A , & $ B , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ B [ $ i ] ) { if ( $ A [ $ i ] != $ i + 1 ) { $ t = $ A [ $ i ] ; $ A [ $ i ] = $ A [ $ i + 1 ] ; $ A [ $ i + 1 ] = $ t ; } } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ A [ $ i ] != $ i + 1 ) return false ; } return true ; } $ A = array ( 1 , 2 , 5 , 3 , 4 , 6 ) ; $ B = array ( 0 , 1 , 1 , 1 , 0 ) ; $ n = sizeof ( $ A ) ; if ( sortedAfterSwap ( $ A , $ B , $ n ) ) echo \" A ▁ can ▁ be ▁ sorted STRNEWLINE \" ; else echo \" A ▁ can ▁ not ▁ be ▁ sorted STRNEWLINE \" ; ? >"}
{"text": "Sort Array yang Mengandungi Dua Jenis Elemen | Kaedah untuk pemisahan 0 dan 1 diberikan array input; Kod pemacu", "code": "< ? php function segregate0and1 ( $ arr , $ n ) { $ type0 = 0 ; $ type1 = $ n - 1 ; while ( $ type0 < $ type1 ) { if ( $ arr [ $ type0 ] == 1 ) { $ temp = $ arr [ $ type0 ] ; $ arr [ $ type0 ] = $ arr [ $ type1 ] ; $ arr [ $ type1 ] = $ temp ; $ type1 -- ; } else { $ type0 ++ ; } } return $ arr ; } $ arr = array ( 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 ) ; $ n = count ( $ arr ) ; $ arr1 = segregate0and1 ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr1 [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Kira Inversions dalam Array | Tetapkan 1 (menggunakan jenis gabungan) | Program PHP untuk mengira inversi dalam array; Kod pemacu", "code": "< ? php function getInvCount ( & $ arr , $ n ) { $ inv_count = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ inv_count ++ ; return $ inv_count ; } $ arr = array ( 1 , 20 , 6 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; echo \" Number ▁ of ▁ inversions ▁ are ▁ \" , getInvCount ( $ arr , $ n ) ; ? >"}
{"text": "Dua elemen yang jumlahnya paling dekat dengan Zero | Program PHP untuk mencari dua elemen yang jumlahnya paling dekat dengan sifar; Array harus mempunyai sekurang -kurangnya dua elemen; Permulaan nilai; Kod pemacu", "code": "< ? php function minAbsSumPair ( $ arr , $ arr_size ) { $ inv_count = 0 ; if ( $ arr_size < 2 ) { echo \" Invalid ▁ Input \" ; return ; } $ min_l = 0 ; $ min_r = 1 ; $ min_sum = $ arr [ 0 ] + $ arr [ 1 ] ; for ( $ l = 0 ; $ l < $ arr_size - 1 ; $ l ++ ) { for ( $ r = $ l + 1 ; $ r < $ arr_size ; $ r ++ ) { $ sum = $ arr [ $ l ] + $ arr [ $ r ] ; if ( abs ( $ min_sum ) > abs ( $ sum ) ) { $ min_sum = $ sum ; $ min_l = $ l ; $ min_r = $ r ; } } } echo \" The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are ▁ \" . $ arr [ $ min_l ] . \" ▁ and ▁ \" . $ arr [ $ min_r ] ; } $ arr = array ( 1 , 60 , -10 , 70 , -80 , 85 ) ; minAbsSumPair ( $ arr , 6 ) ; ? >"}
{"text": "Terpendek PBB | Fungsi BOOL untuk memeriksa elemen array semakin meningkat. ; Fungsi BOOL untuk memeriksa elemen array sedang menurun. ; Peningkatan dan penurunan adalah dua fungsi. jika fungsi mengembalikan nilai sebenar maka cetak 0 sebaliknya 3 .; Kod pemacu", "code": "< ? php function increasing ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ a [ $ i ] >= $ a [ $ i + 1 ] ) return false ; return true ; } function decreasing ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ a [ $ i ] < $ a [ $ i + 1 ] ) return false ; return true ; } function shortestUnsorted ( $ a , $ n ) { if ( increasing ( $ a , $ n ) == true || decreasing ( $ a , $ n ) == true ) return 0 ; else return 3 ; } $ ar = array ( 7 , 9 , 10 , 8 , 11 ) ; $ n = sizeof ( $ ar ) ; echo shortestUnsorted ( $ ar , $ n ) ; ? >"}
{"text": "Kesatuan dan persimpangan dua susunan yang disusun | Fungsi cetakan kesatuan arr1 [] dan arr2 [] m ialah bilangan elemen dalam arr1 [] n ialah bilangan elemen dalam arr2 []; Cetak elemen baki array yang lebih besar; Kod pemacu", "code": "< ? php function printUnion ( $ arr1 , $ arr2 , $ m , $ n ) { $ i = 0 ; $ j = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) echo ( $ arr1 [ $ i ++ ] . \" ▁ \" ) ; else if ( $ arr2 [ $ j ] < $ arr1 [ $ i ] ) echo ( $ arr2 [ $ j ++ ] . \" ▁ \" ) ; else { echo ( $ arr2 [ $ j ++ ] . \" \" ) ; $ i ++ ; } } while ( $ i < $ m ) echo ( $ arr1 [ $ i ++ ] . \" ▁ \" ) ; while ( $ j < $ n ) echo ( $ arr2 [ $ j ++ ] . \" ▁ \" ) ; } $ arr1 = array ( 1 , 2 , 4 , 5 , 6 ) ; $ arr2 = array ( 2 , 3 , 5 , 7 ) ; $ m = sizeof ( $ arr1 ) ; $ n = sizeof ( $ arr2 ) ; printUnion ( $ arr1 , $ arr2 , $ m , $ n ) ; ? >"}
{"text": "Kesatuan dan persimpangan dua susunan yang disusun | Fungsi cetakan persimpangan arr1 [] dan arr2 [] m ialah bilangan elemen dalam arr1 [] n ialah bilangan elemen dalam arr2 []; Kod pemacu; Fungsi panggilan", "code": "< ? php function printIntersection ( $ arr1 , $ arr2 , $ m , $ n ) { $ i = 0 ; $ j = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) $ i ++ ; else if ( $ arr2 [ $ j ] < $ arr1 [ $ i ] ) $ j ++ ; else { echo $ arr2 [ $ j ] , \" \" ; $ i ++ ; $ j ++ ; } } } $ arr1 = array ( 1 , 2 , 4 , 5 , 6 ) ; $ arr2 = array ( 2 , 3 , 5 , 7 ) ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; printIntersection ( $ arr1 , $ arr2 , $ m , $ n ) ; ? >"}
{"text": "Cari kesatuan dan persimpangan dua tatasusunan yang tidak disusun | Cetak Kesatuan ARR1 [0 .. M - 1] dan ARR2 [0 .. n - 1]; Sebelum mencari kesatuan, pastikan arr1 [0. M - 1] lebih kecil; Sekarang arr1 [] lebih kecil jenis array pertama dan mencetak unsur -unsurnya (kedua -dua langkah ini boleh ditukar sebagai perintah dalam output tidak penting); Cari setiap elemen array yang lebih besar dalam array yang lebih kecil dan cetak elemen jika tidak dijumpai; Cetak persimpangan ARR1 [0 .. M - 1] dan ARR2 [0 .. n - 1]; Sebelum mencari persimpangan, pastikan ARR1 [0. M - 1] lebih kecil; Sekarang arr1 [] adalah jenis yang lebih kecil yang lebih kecil arr1 [0.. m - 1]; Cari setiap elemen array yang lebih besar dalam array yang lebih kecil dan cetak elemen jika dijumpai; Fungsi carian binari rekursif. Ia mengembalikan lokasi x dalam array yang diberikan [l. . r] hadir, jika tidak - 1; Jika elemen hadir di tengah -tengahnya sendiri; Jika elemen lebih kecil daripada pertengahan, maka ia hanya boleh dijadikan di subarray kiri; Lain elemen hanya boleh hadir di subarray kanan; Kami sampai di sini apabila elemen tidak hadir dalam pelbagai; Program pemacu untuk menguji fungsi di atas; Panggilan fungsi", "code": "< ? php function printUnion ( $ arr1 , $ arr2 , $ m , $ n ) { if ( $ m > $ n ) { $ tempp = $ arr1 ; $ arr1 = $ arr2 ; $ arr2 = $ tempp ; $ temp = $ m ; $ m = $ n ; $ n = $ temp ; } sort ( $ arr1 ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) echo $ arr1 [ $ i ] . \" ▁ \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( binarySearch ( $ arr1 , 0 , $ m - 1 , $ arr2 [ $ i ] ) == -1 ) echo $ arr2 [ $ i ] . \" ▁ \" ; } function printIntersection ( $ arr1 , $ arr2 , $ m , $ n ) { if ( $ m > $ n ) { $ tempp = $ arr1 ; $ arr1 = $ arr2 ; $ arr2 = $ tempp ; $ temp = $ m ; $ m = $ n ; $ n = $ temp ; } sort ( $ arr1 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( binarySearch ( $ arr1 , 0 , $ m - 1 , $ arr2 [ $ i ] ) != -1 ) echo $ arr2 [ $ i ] . \" ▁ \" ; } function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = ( int ) ( $ l + ( $ r - $ l ) / 2 ) ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } return -1 ; } $ arr1 = array ( 7 , 1 , 5 , 2 , 3 , 6 ) ; $ arr2 = array ( 3 , 8 , 6 , 20 , 7 ) ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; echo \" Union ▁ of ▁ two ▁ arrays ▁ is ▁ STRNEWLINE \" ; printUnion ( $ arr1 , $ arr2 , $ m , $ n ) ; echo \" Intersection of two arrays is \" ; printIntersection ( $ arr1 , $ arr2 , $ m , $ n ) ; ? >"}
{"text": "Cari kesatuan dan persimpangan dua tatasusunan yang tidak disusun | Berfungsi untuk mencari persimpangan; Apabila kedua -duanya sama; Kod pemacu; jenis; Panggilan fungsi", "code": "< ? php function intersection ( $ a , $ b , $ n , $ m ) { $ i = 0 ; $ j = 0 ; while ( $ i < $ n && $ j < $ m ) { if ( $ a [ $ i ] > $ b [ $ j ] ) { $ j ++ ; } else if ( $ b [ $ j ] > $ a [ $ i ] ) { $ i ++ ; } else { echo ( $ a [ $ i ] . \" \" ) ; $ i ++ ; $ j ++ ; } } } $ a = array ( 1 , 3 , 2 , 3 , 4 , 5 , 5 , 6 ) ; $ b = array ( 3 , 3 , 5 ) ; $ n = sizeof ( $ a ) ; $ m = sizeof ( $ b ) ; sort ( $ a ) ; sort ( $ b ) ; intersection ( $ a , $ b , $ n , $ m ) ; ? >"}
{"text": "Susun pelbagai 0 s, 1 s dan 2 s | Fungsi utiliti; Susun array input, array diandaikan mempunyai nilai dalam {0, 1, 2}; Fungsi utiliti untuk mencetak array arr []; Kod pemacu", "code": "< ? php function swap ( & $ a , & $ b ) { $ temp = $ a ; $ a = $ b ; $ b = $ temp ; } function sort012 ( & $ a , $ arr_size ) { $ lo = 0 ; $ hi = $ arr_size - 1 ; $ mid = 0 ; while ( $ mid <= $ hi ) { switch ( $ a [ $ mid ] ) { case 0 : swap ( $ a [ $ lo ++ ] , $ a [ $ mid ++ ] ) ; break ; case 1 : $ mid ++ ; break ; case 2 : swap ( $ a [ $ mid ] , $ a [ $ hi -- ] ) ; break ; } } } function printArray ( & $ arr , $ arr_size ) { for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 ) ; $ arr_size = sizeof ( $ arr ) ; sort012 ( $ arr , $ arr_size ) ; echo \" array ▁ after ▁ segregation ▁ \" ; printArray ( $ arr , $ arr_size ) ; ? >"}
{"text": "Cari subarray yang tidak disusun panjang minimum, menyusun yang menjadikan array lengkap disusun | Program PHP untuk mencari subarray yang tidak disusun panjang minimum, penyortiran yang menjadikan array lengkap disusun; Langkah 1 (a) Algo di atas; Langkah 1 (b) di atas algo; Langkah 2 (a) Algo di atas; Langkah 2 (b) di atas algo; Langkah 2 (c) Algo di atas; Langkah 3 dari algo di atas", "code": "< ? php function printUnsorted ( & $ arr , $ n ) { $ s = 0 ; $ e = $ n - 1 ; for ( $ s = 0 ; $ s < $ n - 1 ; $ s ++ ) { if ( $ arr [ $ s ] > $ arr [ $ s + 1 ] ) break ; } if ( $ s == $ n - 1 ) { echo \" The ▁ complete ▁ array ▁ is ▁ sorted \" ; return ; } for ( $ e = $ n - 1 ; $ e > 0 ; $ e -- ) { if ( $ arr [ $ e ] < $ arr [ $ e - 1 ] ) break ; } $ max = $ arr [ $ s ] ; $ min = $ arr [ $ s ] ; for ( $ i = $ s + 1 ; $ i <= $ e ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; if ( $ arr [ $ i ] < $ min ) $ min = $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ s ; $ i ++ ) { if ( $ arr [ $ i ] > $ min ) { $ s = $ i ; break ; } } for ( $ i = $ n - 1 ; $ i >= $ e + 1 ; $ i -- ) { if ( $ arr [ $ i ] < $ max ) { $ e = $ i ; break ; } } echo \" ▁ The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ \" . \" the ▁ given ▁ array ▁ \" . \" STRNEWLINE \" . \" ▁ sorted ▁ lies ▁ between ▁ the ▁ indees ▁ \" . $ s . \" ▁ and ▁ \" . $ e ; return ; } $ arr = array ( 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 ) ; $ arr_size = sizeof ( $ arr ) ; printUnsorted ( $ arr , $ arr_size ) ; ? >"}
{"text": "Kira bilangan segitiga yang mungkin | Fungsi untuk mengira semua segi tiga yang mungkin dengan elemen ARR []; Susun unsur -unsur array dalam perintah yang tidak menurun; Memulakan kiraan segitiga; Betulkan elemen pertama. Kita perlu berjalan sehingga n - 3 kerana dua elemen lain dipilih dari arr [i + 1. . n - 1]; Memulakan indeks elemen ketiga paling kanan; Betulkan elemen kedua; Cari elemen paling kanan yang lebih kecil daripada jumlah dua elemen tetap. Perkara penting yang perlu diperhatikan di sini ialah, kami menggunakan nilai sebelumnya k. Jika nilai arr [i] + arr [j - 1] lebih besar daripada arr [k], maka arr [i] + arr [j] mestilah lebih besar daripada k, kerana array disusun. ; Jumlah bilangan segitiga yang mungkin boleh dibentuk dengan dua elemen tetap adalah k - j - 1. Kedua -dua elemen tetap adalah arr [i] dan arr [j]. Semua elemen antara arr [j + 1] ke arr [k - 1] boleh membentuk segitiga dengan arr [i] dan arr [j]. Satu dikurangkan dari k kerana k ditingkatkan satu tambahan di atas sementara gelung. k akan sentiasa lebih besar daripada j. Jika j menjadi sama dengan k, maka di atas gelung akan meningkat k, kerana arr [k] + arr [i] sentiasa / lebih besar daripada arr [k]; Kod pemacu", "code": "< ? php function findNumberOfTriangles ( $ arr ) { $ n = count ( $ arr ) ; sort ( $ arr ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; ++ $ i ) { $ k = $ i + 2 ; for ( $ j = $ i + 1 ; $ j < $ n ; ++ $ j ) { while ( $ k < $ n && $ arr [ $ i ] + $ arr [ $ j ] > $ arr [ $ k ] ) ++ $ k ; if ( $ k > $ j ) $ count += $ k - $ j - 1 ; } } return $ count ; } $ arr = array ( 10 , 21 , 22 , 100 , 101 , 200 , 300 ) ; echo \" Total ▁ number ▁ of ▁ triangles ▁ is ▁ \" , findNumberOfTriangles ( $ arr ) ; ? >"}
{"text": "Kira semua pasangan yang berbeza dengan perbezaan sama dengan k | Program PHP mudah untuk mengira pasangan dengan perbezaan k; Pilih semua elemen satu demi satu; Lihat jika terdapat sepasang elemen yang dipilih ini; Kod pemacu", "code": "< ? php function countPairsWithDiffK ( $ arr , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] - $ arr [ $ j ] == $ k or $ arr [ $ j ] - $ arr [ $ i ] == $ k ) $ count ++ ; } return $ count ; } $ arr = array ( 1 , 5 , 3 , 4 , 2 ) ; $ n = count ( $ arr ) ; $ k = 3 ; echo \" Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ \" , countPairsWithDiffK ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Kira semua pasangan yang berbeza dengan perbezaan sama dengan k | Fungsi carian binari standard; Mengembalikan kiraan pasangan dengan perbezaan k dalam arr [] saiz n. ; Susun elemen array; Pilih titik elemen pertama; Kod pemacu", "code": "< ? php function binarySearch ( $ arr , $ low , $ high , $ x ) { if ( $ high >= $ low ) { $ mid = $ low + ( $ high - $ low ) / 2 ; if ( $ x == $ arr [ $ mid ] ) return $ mid ; if ( $ x > $ arr [ $ mid ] ) return binarySearch ( $ arr , ( $ mid + 1 ) , $ high , $ x ) ; else return binarySearch ( $ arr , $ low , ( $ mid - 1 ) , $ x ) ; } return -1 ; } function countPairsWithDiffK ( $ arr , $ n , $ k ) { $ count = 0 ; $ i ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( binarySearch ( $ arr , $ i + 1 , $ n - 1 , $ arr [ $ i ] + $ k ) != -1 ) $ count ++ ; return $ count ; } $ arr = array ( 1 , 5 , 3 , 4 , 2 ) ; $ n = count ( $ arr ) ; $ k = 3 ; echo \" Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ \" , countPairsWithDiffK ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Kira semua pasangan yang berbeza dengan perbezaan sama dengan k | Mengembalikan kiraan pasangan dengan perbezaan k dalam arr [] saiz n. ; Susun elemen array; arr [r] - arr [l] <k; Kod pemacu", "code": "< ? php function countPairsWithDiffK ( $ arr , $ n , $ k ) { $ count = 0 ; sort ( $ arr ) ; $ l = 0 ; $ r = 0 ; while ( $ r < $ n ) { if ( $ arr [ $ r ] - $ arr [ $ l ] == $ k ) { $ count ++ ; $ l ++ ; $ r ++ ; } else if ( $ arr [ $ r ] - $ arr [ $ l ] > $ k ) $ l ++ ; else $ r ++ ; } return $ count ; } $ arr = array ( 1 , 5 , 3 , 4 , 2 ) ; $ n = count ( $ arr ) ; $ k = 3 ; echo \" Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ \" , countPairsWithDiffK ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Bina pelbagai dari pasangannya | Mengisi elemen dalam arr [] dari pasangan array pasangannya []. n adalah saiz arr []; Kod pemacu", "code": "< ? php function constructArr ( $ pair ) { $ arr = array ( ) ; $ n = 5 ; $ arr [ 0 ] = intval ( ( $ pair [ 0 ] + $ pair [ 1 ] - $ pair [ $ n - 1 ] ) / 2 ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ pair [ $ i - 1 ] - $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } $ pair = array ( 15 , 13 , 11 , 10 , 12 , 10 , 9 , 8 , 7 , 5 ) ; constructArr ( $ pair ) ; ? >"}
{"text": "Gabungkan dua susunan yang disusun dengan O (1) ruang tambahan | Gabungkan AR1 [] dan Ar2 [] dengan O (1) ruang tambahan; Melangkah melalui semua elemen AR2 [] bermula dari elemen terakhir; Cari elemen terkecil lebih besar daripada AR2 [i]. Gerakkan semua elemen satu kedudukan di hadapan sehingga elemen yang paling kecil tidak dijumpai; Sekiranya terdapat elemen yang lebih besar; Program Pemandu", "code": "< ? php function merge ( & $ ar1 , & $ ar2 , $ m , $ n ) { for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ last = $ ar1 [ $ m - 1 ] ; for ( $ j = $ m - 2 ; $ j >= 0 && $ ar1 [ $ j ] > $ ar2 [ $ i ] ; $ j -- ) $ ar1 [ $ j + 1 ] = $ ar1 [ $ j ] ; if ( $ j != $ m - 2 $ last > $ ar2 [ $ i ] ) { $ ar1 [ $ j + 1 ] = $ ar2 [ $ i ] ; $ ar2 [ $ i ] = $ last ; } } } $ ar1 = array ( 1 , 5 , 9 , 10 , 15 , 20 ) ; $ ar2 = array ( 2 , 3 , 8 , 13 ) ; $ m = sizeof ( $ ar1 ) / sizeof ( $ ar1 [ 0 ] ) ; $ n = sizeof ( $ ar2 ) / sizeof ( $ ar2 [ 0 ] ) ; merge ( $ ar1 , $ ar2 , $ m , $ n ) ; echo \" First Array : \" for ( $ i = 0 ; $ i < $ m ; $ i ++ ) echo $ ar1 [ $ i ] . \" ▁ \" ; echo \" Second Array : \" for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ ar2 [ $ i ] . \" ▁ \" ; return 0 ; ? >"}
{"text": "Urutan Gould | Berfungsi untuk menjana urutan Gould; gelung untuk menjana setiap baris segitiga Pascal sehingga baris nth; Gelung untuk menjana setiap elemen baris ith; Jika C adalah kiraan kenaikan ganjil; cetak kiraan elemen ganjil; Dapatkan n; Panggilan fungsi", "code": "< ? php function gouldSequence ( $ n ) { for ( $ row_num = 1 ; $ row_num <= $ n ; $ row_num ++ ) { $ count = 1 ; $ c = 1 ; for ( $ i = 1 ; $ i <= $ row_num ; $ i ++ ) { $ c = $ c * ( $ row_num - $ i ) / $ i ; if ( $ c % 2 == 1 ) $ count ++ ; } echo $ count , \" \" ; } } $ n = 16 ; gouldSequence ( $ n ) ; ? >"}
{"text": "Produk maksimum dalam array pertama dan minimum di kedua | Berfungsi untuk mengira produk; Susun tatasusunan untuk mencari elemen maksimum dan minimum dalam tatasusunan yang diberikan; Pulangan produk maksimum dan minimum. ; Kod pemacu", "code": "< ? php function minMaxProduct ( $ arr1 , $ arr2 , $ n1 , $ n2 ) { sort ( $ arr1 ) ; sort ( $ arr2 ) ; return $ arr1 [ $ n1 - 1 ] * $ arr2 [ 0 ] ; } $ arr1 = array ( 10 , 2 , 3 , 6 , 4 , 1 ) ; $ arr2 = array ( 5 , 1 , 4 , 2 , 6 , 9 ) ; $ n1 = count ( $ arr1 ) ; $ n2 = count ( $ arr2 ) ; echo minMaxProduct ( $ arr1 , $ arr2 , $ n1 , $ n2 ) ; ? >"}
{"text": "Laluan Kos Ganjil Minimum dalam Matriks | Program PHP untuk mencari laluan kos ganjil minimum dalam matriks; Berfungsi untuk mencari kos minimum; elemen paling kiri; elemen paling kanan; Mana -mana elemen kecuali elemen paling kiri dan paling kanan baris boleh dicapai dari blok atas atas atau kanan atas blok atas atau kiri; Mengira kos minimum; Cari kos minimum; Kod pemacu", "code": "< ? php $ M = 100 ; $ N = 100 ; function find_min_odd_cost ( $ given , $ m , $ n ) { global $ M , $ N ; $ floor1 [ $ M ] [ $ N ] = array ( array ( 0 ) , array ( 0 ) ) ; $ min_odd_cost = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ floor1 [ 0 ] [ $ j ] = $ given [ 0 ] [ $ j ] ; for ( $ i = 1 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ j == 0 ) { $ floor1 [ $ i ] [ $ j ] = $ given [ $ i ] [ $ j ] ; $ floor1 [ $ i ] [ $ j ] += min ( $ floor1 [ $ i - 1 ] [ $ j ] , $ floor1 [ $ i - 1 ] [ $ j + 1 ] ) ; } else if ( $ j == $ n - 1 ) { $ floor1 [ $ i ] [ $ j ] = $ given [ $ i ] [ $ j ] ; $ floor1 [ $ i ] [ $ j ] += min ( $ floor1 [ $ i - 1 ] [ $ j ] , $ floor1 [ $ i - 1 ] [ $ j - 1 ] ) ; } else { $ temp = min ( $ floor1 [ $ i - 1 ] [ $ j ] , $ floor1 [ $ i - 1 ] [ $ j - 1 ] ) ; $ temp = min ( $ temp , $ floor1 [ $ i - 1 ] [ $ j + 1 ] ) ; $ floor1 [ $ i ] [ $ j ] = $ given [ $ i ] [ $ j ] + $ temp ; } } $ min_odd_cost = PHP_INT_MAX ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ floor1 [ $ n - 1 ] [ $ j ] % 2 == 1 ) { if ( $ min_odd_cost > $ floor1 [ $ n - 1 ] [ $ j ] ) $ min_odd_cost = $ floor1 [ $ n - 1 ] [ $ j ] ; } } if ( $ min_odd_cost == PHP_INT_MIN ) return -1 ; return $ min_odd_cost ; } $ m = 5 ; $ n = 5 ; $ given = array ( array ( 1 , 2 , 3 , 4 , 6 ) , array ( 1 , 2 , 3 , 4 , 5 ) , array ( 1 , 2 , 3 , 4 , 5 ) , array ( 1 , 2 , 3 , 4 , 5 ) , array ( 100 , 2 , 3 , 4 , 5 ) ) ; echo \" Minimum ▁ odd ▁ cost ▁ is ▁ \" . find_min_odd_cost ( $ given , $ m , $ n ) ; ? >"}
{"text": "Produk maksimum dalam array pertama dan minimum di kedua | Berfungsi untuk mengira produk; Memulakan max array pertama; memulakan min array kedua; Untuk mencari elemen maksimum dalam array pertama; Untuk mencari elemen minimum dalam array kedua; Proses baki elemen; Kod yang didorong", "code": "< ? php function minMaxProduct ( $ arr1 , $ arr2 , $ n1 , $ n2 ) { $ max = $ arr1 [ 0 ] ; $ min = $ arr2 [ 0 ] ; $ i ; for ( $ i = 1 ; $ i < $ n1 && $ i < $ n2 ; ++ $ i ) { if ( $ arr1 [ $ i ] > $ max ) $ max = $ arr1 [ $ i ] ; if ( $ arr2 [ $ i ] < $ min ) $ min = $ arr2 [ $ i ] ; } while ( $ i < $ n1 ) { if ( $ arr1 [ $ i ] > $ max ) $ max = $ arr1 [ $ i ] ; $ i ++ ; } while ( $ i < $ n2 ) { if ( $ arr2 [ $ i ] < $ min ) $ min = $ arr2 [ $ i ] ; $ i ++ ; } return $ max * $ min ; } $ arr1 = array ( 10 , 2 , 3 , 6 , 4 , 1 ) ; $ arr2 = array ( 5 , 1 , 4 , 2 , 6 , 9 ) ; $ n1 = count ( $ arr1 ) ; $ n2 = count ( $ arr2 ) ; echo minMaxProduct ( $ arr1 , $ arr2 , $ n1 , $ n2 ) ; ? >"}
{"text": "Cari, masukkan dan padamkan dalam array yang tidak disusun | Berfungsi untuk melaksanakan operasi carian; Kod pemacu; Menggunakan elemen terakhir sebagai elemen carian", "code": "< ? php function findElement ( $ arr , $ n , $ key ) { $ i ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ key ) return $ i ; return -1 ; } $ arr = array ( 12 , 34 , 10 , 6 , 40 ) ; $ n = sizeof ( $ arr ) ; $ key = 40 ; $ position = findElement ( $ arr , $ n , $ key ) ; if ( $ position == - 1 ) echo ( \" Element ▁ not ▁ found \" ) ; else echo ( \" Element ▁ Found ▁ at ▁ Position : ▁ \" . ( $ position + 1 ) ) ; ? >"}
{"text": "Cari, masukkan dan padamkan dalam array yang tidak disusun | Masukkan kunci dalam ARR [] kapasiti yang diberikan. n ialah saiz semasa ARR []. Fungsi ini mengembalikan n + 1 jika penyisipan berjaya, lain n. ; Tidak boleh memasukkan lebih banyak elemen jika n sudah lebih daripada atau sama dengan capcity; Kod pemacu; Memasukkan kekunci", "code": "< ? php function insertSorted ( & $ arr , $ n , $ key , $ capacity ) { if ( $ n >= $ capacity ) return $ n ; array_push ( $ arr , $ key ) ; return ( $ n + 1 ) ; } $ arr = array ( 12 , 16 , 20 , 40 , 50 , 70 ) ; $ capacity = 20 ; $ n = 6 ; $ key = 26 ; echo \" Before ▁ Insertion : ▁ \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; $ n = insertSorted ( $ arr , $ n , $ key , $ capacity ) ; echo \" After Insertion : \" for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Cari, masukkan dan padamkan dalam array yang tidak disusun | Untuk mencari kunci untuk dipadam; Berfungsi untuk memadam elemen; Cari kedudukan elemen untuk dipadamkan; Memadam elemen; Kod pemacu", "code": "< ? php function findElement ( & $ arr , $ n , $ key ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ key ) return $ i ; return -1 ; } function deleteElement ( & $ arr , $ n , $ key ) { $ pos = findElement ( $ arr , $ n , $ key ) ; if ( $ pos == -1 ) { echo \" Element ▁ not ▁ found \" ; return $ n ; } for ( $ i = $ pos ; $ i < $ n - 1 ; $ i ++ ) $ arr [ $ i ] = $ arr [ $ i + 1 ] ; return $ n - 1 ; } $ arr = array ( 10 , 50 , 30 , 40 , 20 ) ; $ n = count ( $ arr ) ; $ key = 30 ; echo \" Array ▁ before ▁ deletion STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; $ n = deleteElement ( $ arr , $ n , $ key ) ; echo \" Array after deletion \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Cari, masukkan dan padamkan dalam array yang disusun | berfungsi untuk melaksanakan carian binari; rendah + (tinggi - rendah) / 2; Kod pemacu biarkan kami mencari 3 di bawah array", "code": "< ? php function binarySearch ( $ arr , $ low , $ high , $ key ) { if ( $ high < $ low ) return -1 ; $ mid = ( $ low + $ high ) / 2 ; if ( $ key == $ arr [ ( int ) $ mid ] ) return $ mid ; if ( $ key > $ arr [ ( int ) $ mid ] ) return binarySearch ( $ arr , ( $ mid + 1 ) , $ high , $ key ) ; return ( binarySearch ( $ arr , $ low , ( $ mid -1 ) , $ key ) ) ; } $ arr = array ( 5 , 6 , 7 , 8 , 9 , 10 ) ; $ n = count ( $ arr ) ; $ key = 10 ; echo \" Index : ▁ \" , ( int ) binarySearch ( $ arr , 0 , $ n -1 , $ key ) ; ? >"}
{"text": "Cari n | berfungsi untuk mencari siri diatomik nth '; Tetapkan kes asas; Melintasi array dari elemen 2 nd ke elemen n; Kes 1: walaupun n; Kes 2: Untuk ODD N; Kod pemacu", "code": "< ? php function findSDSFunc ( $ n ) { $ DP [ 0 ] = 0 ; $ DP [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ DP [ $ i ] = $ DP [ $ i / 2 ] ; else $ DP [ $ i ] = $ DP [ ( $ i - 1 ) / 2 ] + $ DP [ ( $ i + 1 ) / 2 ] ; } return $ DP [ $ n ] ; } $ n = 15 ; echo ( findSDSFunc ( $ n ) ) ; ? >"}
{"text": "Cari Elemen Biasa dalam Tiga Sista Susun | Fungsi ini mencetak elemen umum dalam AR1; Memulakan indeks permulaan untuk AR1 [], ar2 [] dan ar3 []; Melangkah melalui tiga tatasusunan manakala semua tatasusunan mempunyai elemen; Jika x = y dan y = z, cetak mana -mana daripada mereka dan bergerak ke hadapan dalam semua tatasusunan; x <y; y <z; Kami sampai di sini apabila x> y dan z <y, i. e. , Z adalah terkecil; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function findCommon ( $ ar1 , $ ar2 , $ ar3 , $ n1 , $ n2 , $ n3 ) { $ i = 0 ; $ j = 0 ; $ k = 0 ; while ( $ i < $ n1 && $ j < $ n2 && $ k < $ n3 ) { if ( $ ar1 [ $ i ] == $ ar2 [ $ j ] && $ ar2 [ $ j ] == $ ar3 [ $ k ] ) { echo $ ar1 [ $ i ] , \" \" ; $ i ++ ; $ j ++ ; $ k ++ ; } else if ( $ ar1 [ $ i ] < $ ar2 [ $ j ] ) $ i ++ ; else if ( $ ar2 [ $ j ] < $ ar3 [ $ k ] ) $ j ++ ; else $ k ++ ; } } $ ar1 = array ( 1 , 5 , 10 , 20 , 40 , 80 ) ; $ ar2 = array ( 6 , 7 , 20 , 80 , 100 ) ; $ ar3 = array ( 3 , 4 , 15 , 20 , 30 , 70 , 80 , 120 ) ; $ n1 = count ( $ ar1 ) ; $ n2 = count ( $ ar2 ) ; $ n3 = count ( $ ar3 ) ; echo \" Common ▁ Elements ▁ are ▁ \" ; findCommon ( $ ar1 , $ ar2 , $ ar3 , $ n1 , $ n2 , $ n3 ) ; ? >"}
{"text": "Jacobsthal dan Jacobsthal | Kembali ke nombor Jacobsthal. ; Kes asas; Kembali ke Jacobsthal - Nombor Lucas. ; Kes asas; Kod pemacu", "code": "< ? php function Jacobsthal ( $ n ) { $ dp [ $ n + 1 ] ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + 2 * $ dp [ $ i - 2 ] ; return $ dp [ $ n ] ; } function Jacobsthal_Lucas ( $ n ) { $ dp [ $ n + 1 ] ; $ dp [ 0 ] = 2 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + 2 * $ dp [ $ i - 2 ] ; return $ dp [ $ n ] ; } $ n = 5 ; echo \" Jacobsthal ▁ number : ▁ \" , Jacobsthal ( $ n ) , \" STRNEWLINE \" ; echo \" Jacobsthal - Lucas ▁ number : ▁ \" , Jacobsthal_Lucas ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari kedudukan elemen dalam pelbagai sisihan nombor tak terhingga | Algoritma carian binari mudah; Fungsi mengambil array saiz tak terhingga dan kunci untuk dicari dan mengembalikan kedudukannya jika dijumpai lain - 1. Kami tidak tahu saiz arr [] dan kita boleh menganggap saiz tidak terhingga dalam fungsi ini. Perhatikan bahawa fungsi ini menganggap arr [] sebagai saiz tak terhingga oleh itu, tidak ada indeks daripada pemeriksaan terikat; Cari H untuk melakukan carian binari; Simpan tinggi sebelumnya; Indeks dua kali ganda; Kemas kini Val baru; Pada ketika ini kami telah mengemas kini indeks yang rendah dan tinggi, dengan itu menggunakan carian binari di antara mereka; Kod pemacu", "code": "< ? php function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = $ l + ( $ r - $ l ) / 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } return -1 ; } function findPos ( $ arr , $ key ) { $ l = 0 ; $ h = 1 ; $ val = $ arr [ 0 ] ; while ( $ val < $ key ) { $ l = $ h ; $ h = 2 * $ h ; $ val = $ arr [ $ h ] ; } return binarySearch ( $ arr , $ l , $ h , $ key ) ; } $ arr = array ( 3 , 5 , 7 , 9 , 10 , 90 , 100 , 130 , 140 , 160 , 170 ) ; $ ans = findPos ( $ arr , 10 ) ; if ( $ ans == -1 ) echo \" Element ▁ not ▁ found \" ; else echo \" Element ▁ found ▁ at ▁ index ▁ \" , $ ans ; ? >"}
{"text": "Bilangan N digit Nombor Langkah | fungsi yang mengira jawapannya; Jika n adalah 1 maka jawapannya akan menjadi 10 .; Mengira nilai untuk mengira digit lebih daripada 1 .; Jika angka berakhir adalah 0; Jika angka berakhir adalah 9; Untuk digit lain. ; menyimpan jawapan terakhir; Kod pemacu", "code": "< ? php function answer ( $ n ) { if ( $ n == 1 ) return 10 ; for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) $ dp [ 1 ] [ $ j ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) { if ( $ j == 0 ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j + 1 ] ; else if ( $ j == 9 ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j - 1 ] + $ dp [ $ i - 1 ] [ $ j + 1 ] ; } } $ sum = 0 ; for ( $ j = 1 ; $ j <= 9 ; $ j ++ ) $ sum += $ dp [ $ n ] [ $ j ] ; return $ sum ; } $ n = 2 ; echo answer ( $ n ) ; ? >"}
{"text": "Cari elemen yang muncul sekali dalam array di mana setiap elemen lain muncul dua kali | Kembalikan jumlah maksimum perbezaan antara elemen berturut -turut. ; Lakukan xor semua elemen dan kembali; Kod pemacu", "code": "< ? php function findSingle ( $ ar , $ ar_size ) { $ res = $ ar [ 0 ] ; for ( $ i = 1 ; $ i < $ ar_size ; $ i ++ ) $ res = $ res ^ $ ar [ $ i ] ; return $ res ; } $ ar = array ( 2 , 3 , 5 , 4 , 5 , 3 , 4 ) ; $ n = count ( $ ar ) ; echo \" Element ▁ occurring ▁ once ▁ is ▁ \" , findSingle ( $ ar , $ n ) ; ? >"}
{"text": "Kira semua tiga kali ganda jumlahnya sama dengan kiub yang sempurna | Program PHP untuk mengira semua tiga kali ganda yang jumlahnya adalah kiub sempurna. ; Fungsi untuk mengira semua kejadian nombor dalam julat tertentu; jika i == 0 Berikan 1 untuk mempersembahkan keadaan; lain tambah + 1 ke keadaan semasa dengan keadaan sebelumnya; Fungsi untuk mengira tiga kali ganda yang jumlahnya sama dengan kiub yang sempurna; Memulakan jawapan; mengira semua kejadian triplet ketiga dalam julat dari J + 1 hingga n; Kod pemacu", "code": "< ? php $ dp = array_fill ( 0 , 1001 , array_fill ( 0 , 15001 , NULL ) ) ; function computeDpArray ( & $ arr , $ n ) { global $ dp ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { for ( $ j = 1 ; $ j <= 15000 ; ++ $ j ) { if ( $ i == 0 ) $ dp [ $ i ] [ $ j ] = ( $ j == $ arr [ $ i ] ) ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + ( $ arr [ $ i ] == $ j ) ; } } } function countTripletSum ( & $ arr , $ n ) { global $ dp ; computeDpArray ( $ arr , $ n ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; ++ $ i ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; ++ $ j ) { for ( $ k = 1 ; $ k <= 24 ; ++ $ k ) { $ cube = $ k * $ k * $ k ; $ rem = $ cube - ( $ arr [ $ i ] + $ arr [ $ j ] ) ; if ( $ rem > 0 ) $ ans += $ dp [ $ n - 1 ] [ $ rem ] - $ dp [ $ j ] [ $ rem ] ; } } } return $ ans ; } $ arr = array ( 2 , 5 , 1 , 20 , 6 ) ; $ n = sizeof ( $ arr ) ; echo countTripletSum ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah subarray maksimum tidak termasuk unsur -unsur tertentu | Fungsi untuk memeriksa elemen yang ada dalam array b; Fungsi utiliti untuk findMaxSubArraysum () dengan parameter berikut a => array a, b => array b, n => bilangan elemen dalam array a, m => bilangan elemen dalam array b; Tetapkan max_so_far ke int_min; Jika elemen hadir dalam b, tetapkan maksimum semasa ke 0 dan pindah ke elemen seterusnya; Teruskan seperti dalam algoritma Kadane; Pembalut untuk findMaxSubArraySumutil (); Kes ini akan berlaku apabila semua elemen A hadir dalam B, oleh itu tiada subarray boleh dibentuk; Kod pemacu; Panggilan fungsi", "code": "< ? php function isPresent ( $ B , $ m , $ x ) { for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ B [ $ i ] == $ x ) return true ; return false ; } function findMaxSubarraySumUtil ( $ A , $ B , $ n , $ m ) { $ max_so_far = PHP_INT_MIN ; $ curr_max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( isPresent ( $ B , $ m , $ A [ $ i ] ) ) { $ curr_max = 0 ; continue ; } $ curr_max = max ( $ A [ $ i ] , $ curr_max + $ A [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ curr_max ) ; } return $ max_so_far ; } function findMaxSubarraySum ( $ A , $ B , $ n , $ m ) { $ maxSubarraySum = findMaxSubarraySumUtil ( $ A , $ B , $ n , $ m ) ; if ( $ maxSubarraySum == PHP_INT_MIN ) { echo ( \" Maximum ▁ Subarray ▁ \" . \" Sum ▁ cant ▁ be ▁ found STRNEWLINE \" ) ; } else { echo ( \" The ▁ Maximum ▁ Subarray ▁ Sum ▁ = ▁ \" . $ maxSubarraySum . \" STRNEWLINE \" ) ; } } $ A = array ( 3 , 4 , 5 , -4 , 6 ) ; $ B = array ( 1 , 8 , 5 ) ; $ n = count ( $ A ) ; $ m = count ( $ B ) ; findMaxSubarraySum ( $ A , $ B , $ n , $ m ) ; ? >"}
{"text": "Bilangan N | Mengembalikan kiraan nombor yang tidak menurun dengan digit N. ; Inisialisasi semua nombor 0 - digit; Inisialisasi semua nombor I - digit bukan penurunan yang membawa dengan 9; Untuk semua digit kita harus mengira bilangan cara bergantung kepada digit utama; Kod pemacu", "code": "< ? php function nonDecNums ( $ n ) { for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) $ a [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ a [ $ i ] [ 9 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 8 ; $ j >= 0 ; $ j -- ) $ a [ $ i ] [ $ j ] = $ a [ $ i - 1 ] [ $ j ] + $ a [ $ i ] [ $ j + 1 ] ; return $ a [ $ n ] [ 0 ] ; } $ n = 2 ; echo \" Non - decreasing ▁ digits ▁ = ▁ \" , nonDecNums ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Kira pokok binari seimbang ketinggian h | Program PHP untuk mengira bilangan seimbang; kes asas; Kod pemacu", "code": "< ? php $ mod = 1000000007 ; function countBT ( $ h ) { global $ mod ; $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ h ; $ i ++ ) { $ dp [ $ i ] = ( $ dp [ $ i - 1 ] * ( ( 2 * $ dp [ $ i - 2 ] ) % $ mod + $ dp [ $ i - 1 ] ) % $ mod ) % $ mod ; } return $ dp [ $ h ] ; } $ h = 3 ; echo \" No . ▁ of ▁ balanced ▁ binary ▁ trees \" , \" ▁ of ▁ height ▁ h ▁ is : ▁ \" , countBT ( $ h ) , \" STRNEWLINE \" ; ? >"}
{"text": "Indeks Keseimbangan Array | berfungsi untuk mencari indeks keseimbangan; Semak indeks satu demi satu sehingga indeks keseimbangan dijumpai; Dapatkan jumlah kiri; Dapatkan jumlah yang betul; Jika Leftsum dan Rightsum sama, maka kita sudah selesai; Pulangan - 1 Jika tiada indeks keseimbangan dijumpai; Kod pemacu", "code": "< ? php function equilibrium ( $ arr , $ n ) { $ i ; $ j ; $ leftsum ; $ rightsum ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ leftsum = 0 ; $ rightsum = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ leftsum += $ arr [ $ j ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ rightsum += $ arr [ $ j ] ; if ( $ leftsum == $ rightsum ) return $ i ; } return -1 ; } $ arr = array ( -7 , 1 , 5 , 2 , -4 , 3 , 0 ) ; $ arr_size = sizeof ( $ arr ) ; echo equilibrium ( $ arr , $ arr_size ) ; ? >"}
{"text": "Cari Bilangan Poin Tidak Berkesuai | Mengembalikan kiraan mata yang tidak berkesudahan; Mengisi matriks lajur. Untuk setiap lajur, mulakan dari setiap baris terakhir dan isi setiap entri sebagai penyumbatan selepas 0 ditemui. ; Bendera yang akan menjadi sifar sebaik sahaja kita mendapat '0' dan ia akan menjadi 1 sebaliknya; Menemui '0', tetapkan pemboleh ubah ISendless kepada palsu; Begitu juga, isi matriks baris; Mengira jumlah kiraan mata yang tidak berkesudahan; Sekiranya tiada penyumbatan atau lajur selepas titik ini, hasil kenaikan. ; Kod pemacu", "code": "< ? php function countEndless ( $ input , $ n ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ isEndless = 1 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ input [ $ i ] [ $ j ] == 0 ) $ isEndless = 0 ; $ col [ $ i ] [ $ j ] = $ isEndless ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ isEndless = 1 ; for ( $ j = $ n - 1 ; $ j >= 0 ; $ j -- ) { if ( $ input [ $ i ] [ $ j ] == 0 ) $ isEndless = 0 ; $ row [ $ i ] [ $ j ] = $ isEndless ; } } $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 1 ; $ j < $ n ; $ j ++ ) if ( $ row [ $ i ] [ $ j ] && $ col [ $ i ] [ $ j ] ) $ ans ++ ; return $ ans ; } $ input = array ( array ( 1 , 0 , 1 , 1 ) , array ( 0 , 1 , 1 , 1 ) , array ( 1 , 1 , 1 , 1 ) , array ( 0 , 1 , 1 , 0 ) ) ; $ n = 4 ; echo countEndless ( $ input , $ n ) ; ? >"}
{"text": "Indeks Keseimbangan Array | berfungsi untuk mencari indeks keseimbangan; memulakan jumlah keseluruhan array; memulakan leftsum; Cari jumlah keseluruhan array; Jumlah kini Jumlah Jumlah untuk Indeks I; Jika tiada indeks keseimbangan dijumpai, maka kembali 0; Kod pemacu", "code": "< ? php function equilibrium ( $ arr , $ n ) { $ sum = 0 ; $ leftsum = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ sum -= $ arr [ $ i ] ; if ( $ leftsum == $ sum ) return $ i ; $ leftsum += $ arr [ $ i ] ; } return -1 ; } $ arr = array ( -7 , 1 , 5 , 2 , -4 , 3 , 0 ) ; $ arr_size = sizeof ( $ arr ) ; echo \" First ▁ equilibrium ▁ index ▁ is ▁ \" , equilibrium ( $ arr , $ arr_size ) ; ? >"}
{"text": "Jumlah semua substrings rentetan yang mewakili nombor | Tetapkan 1 | Kaedah untuk menukar digit aksara ke digit integer; Mengembalikan jumlah semua substring NUM; memperuntukkan memori sama dengan panjang rentetan; memulakan nilai pertama dengan digit pertama; gelung ke atas semua digit rentetan; Kemas kini setiap sumofdigit dari nilai sebelumnya; Tambah nilai semasa ke hasilnya; Kod pemacu", "code": "< ? php function toDigit ( $ ch ) { return ( $ ch - '0' ) ; } function sumOfSubstrings ( $ num ) { $ n = strlen ( $ num ) ; $ sumofdigit [ $ n ] = 0 ; $ sumofdigit [ 0 ] = toDigit ( $ num [ 0 ] ) ; $ res = $ sumofdigit [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ numi = toDigit ( $ num [ $ i ] ) ; $ sumofdigit [ $ i ] = ( $ i + 1 ) * $ numi + 10 * $ sumofdigit [ $ i - 1 ] ; $ res += $ sumofdigit [ $ i ] ; } return $ res ; } $ num = \"1234\" ; echo sumOfSubstrings ( $ num ) ; ? >"}
{"text": "Pemimpin dalam array | Fungsi PHP untuk mencetak pemimpin dalam pelbagai; Gelung itu tidak memecahkan; Kod pemacu", "code": "< ? php function printLeaders ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ size ; $ j ++ ) { if ( $ arr [ $ i ] <= $ arr [ $ j ] ) break ; } if ( $ j == $ size ) echo ( $ arr [ $ i ] . \" ▁ \" ) ; } } $ arr = array ( 16 , 17 , 4 , 3 , 5 , 2 ) ; $ n = sizeof ( $ arr ) ; printLeaders ( $ arr , $ n ) ; ? >"}
{"text": "Pemimpin dalam array | Fungsi PHP untuk mencetak pemimpin dalam pelbagai; Elemen paling kanan sentiasa pemimpin; Kod pemacu", "code": "< ? php function printLeaders ( & $ arr , $ size ) { $ max_from_right = $ arr [ $ size - 1 ] ; echo ( $ max_from_right ) ; echo ( \" ▁ \" ) ; for ( $ i = $ size - 2 ; $ i >= 0 ; $ i -- ) { if ( $ max_from_right < $ arr [ $ i ] ) { $ max_from_right = $ arr [ $ i ] ; echo ( $ max_from_right ) ; echo ( \" ▁ \" ) ; } } } $ arr = array ( 16 , 17 , 4 , 3 , 5 , 2 ) ; $ n = sizeof ( $ arr ) ; printLeaders ( $ arr , $ n ) ; ? >"}
{"text": "Knapsack yang tidak dibatalkan (pengulangan item yang dibenarkan) | Mengembalikan nilai maksimum dengan kapasiti Wapsack; DP [i] akan menyimpan nilai maksimum dengan kapasiti knapsack i. ; Isi DP [] menggunakan formula rekursif di atas; Kod pemacu", "code": "< ? php function unboundedKnapsack ( $ W , $ n , $ val , $ wt ) { for ( $ i = 0 ; $ i <= $ W ; $ i ++ ) $ dp [ $ i ] = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i <= $ W ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ wt [ $ j ] <= $ i ) $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ i - $ wt [ $ j ] ] + $ val [ $ j ] ) ; return $ dp [ $ W ] ; } $ W = 100 ; $ val = array ( 10 , 30 , 20 ) ; $ wt = array ( 5 , 10 , 15 ) ; $ n = count ( $ val ) ; sizeof ( $ val ) / sizeof ( $ val [ 0 ] ) ; echo unboundedKnapsack ( $ W , $ n , $ val , $ wt ) ; ? >"}
{"text": "Siling dalam array yang disusun | Fungsi untuk mendapatkan indeks siling x dalam arr [rendah. . tinggi]; Jika x lebih kecil daripada atau sama dengan elemen pertama, maka kembalikan elemen pertama; Jika tidak, linear cari nilai ceil; jika x terletak di antara arr [i] dan arr [i + 1] termasuk arr [i + 1], kemudian kembali arr [i + 1]; Jika kita sampai di sini maka x lebih besar daripada elemen terakhir array, kembali - 1 dalam kes ini; Kod pemacu", "code": "< ? php function ceilSearch ( $ arr , $ low , $ high , $ x ) { if ( $ x <= $ arr [ $ low ] ) return $ low ; for ( $ i = $ low ; $ i < $ high ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; if ( $ arr [ $ i ] < $ x && $ arr [ $ i + 1 ] >= $ x ) return $ i + 1 ; } return -1 ; } $ arr = array ( 1 , 2 , 8 , 10 , 10 , 12 , 19 ) ; $ n = sizeof ( $ arr ) ; $ x = 3 ; $ index = ceilSearch ( $ arr , 0 , $ n - 1 , $ x ) ; if ( $ index == -1 ) echo ( \" Ceiling ▁ of ▁ \" . $ x . \" ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ \" ) ; else echo ( \" ceiling ▁ of ▁ \" . $ x . \" ▁ is ▁ \" . $ arr [ $ index ] ) ; ? >"}
{"text": "Maksimum SUM Subarray Mengeluarkan Paling Satu Elemen | Kaedah Mengembalikan jumlah maksimum semua subarray di mana mengeluarkan satu elemen juga dibenarkan; Subarray maksimum dalam arah ke hadapan dan ke belakang; Memulakan max dan max semasa setakat ini. ; mengira subarray jumlah maksimum ke arah hadapan; menyimpan maksimum semasa sehingga ith, dalam pelbagai ke hadapan; mengira subarray jumlah maksimum ke arah mundur; menyimpan maksimum semasa dari ith, dalam pelbagai mundur; Memulakan ans akhir oleh max_so_far supaya, kes apabila tiada elemen dikeluarkan untuk mendapatkan subarray max juga dikendalikan; memilih maksimum mengabaikan elemen ith; Kod pemacu", "code": "< ? php function maxSumSubarrayRemovingOneEle ( $ arr , $ n ) { $ fw = array ( ) ; $ bw = array ( ) ; $ cur_max = $ arr [ 0 ] ; $ max_so_far = $ arr [ 0 ] ; $ fw [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ cur_max = max ( $ arr [ $ i ] , $ cur_max + $ arr [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ cur_max ) ; $ fw [ $ i ] = $ cur_max ; } $ cur_max = $ max_so_far = $ bw [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ cur_max = max ( $ arr [ $ i ] , $ cur_max + $ arr [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ cur_max ) ; $ bw [ $ i ] = $ cur_max ; } $ fans = $ max_so_far ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) $ fans = max ( $ fans , $ fw [ $ i - 1 ] + $ bw [ $ i + 1 ] ) ; return $ fans ; } $ arr = array ( -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 ) ; $ n = count ( $ arr ) ; echo maxSumSubarrayRemovingOneEle ( $ arr , $ n ) ; ? >"}
{"text": "Siling dalam array yang disusun | Fungsi untuk mendapatkan indeks siling x dalam arr [rendah. . tinggi]; Jika x lebih kecil daripada atau sama dengan elemen pertama, maka kembalikan elemen pertama; Jika x lebih besar daripada elemen terakhir, maka kembali - 1; Dapatkan indeks elemen tengah ARR [rendah. . tinggi]; Jika x sama dengan elemen tengah, maka kembali pertengahan; Jika x lebih besar daripada arr [pertengahan], maka sama ada arr [pertengahan + 1] adalah siling x atau siling terletak pada arr [pertengahan + 1. . tinggi]; Jika x lebih kecil daripada arr [pertengahan], maka sama ada arr [pertengahan] adalah siling x atau siling terletak pada arr [rendah .... pertengahan - 1]; Kod pemacu", "code": "< ? php function ceilSearch ( $ arr , $ low , $ high , $ x ) { $ mid ; if ( $ x <= $ arr [ $ low ] ) return $ low ; if ( $ x > $ arr [ $ high ] ) return -1 ; $ mid = ( $ low + $ high ) / 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; else if ( $ arr [ $ mid ] < $ x ) { if ( $ mid + 1 <= $ high && $ x <= $ arr [ $ mid + 1 ] ) return $ mid + 1 ; else return ceilSearch ( $ arr , $ mid + 1 , $ high , $ x ) ; } else { if ( $ mid - 1 >= $ low && $ x > $ arr [ $ mid - 1 ] ) return $ mid ; else return ceilSearch ( $ arr , $ low , $ mid - 1 , $ x ) ; } } $ arr = array ( 1 , 2 , 8 , 10 , 10 , 12 , 19 ) ; $ n = sizeof ( $ arr ) ; $ x = 20 ; $ index = ceilSearch ( $ arr , 0 , $ n - 1 , $ x ) ; if ( $ index == -1 ) echo ( \" Ceiling ▁ of ▁ $ x ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ \" ) ; else echo ( \" ceiling ▁ of ▁ $ x ▁ is \" ) ; echo ( isset ( $ arr [ $ index ] ) ) ; ? >"}
{"text": "Jalan dengan nilai purata maksimum | Kaedah mengembalikan purata maksimum semua laluan matriks kos; Memulakan lajur pertama jumlah kos (dp); Memulakan baris pertama array DP; Membina selebihnya dari array DP; Bahagikan jumlah maksimum dengan panjang laluan malar: (2 n - 1) untuk mendapatkan purata; Kod pemacu", "code": "< ? php function maxAverageOfPath ( $ cost , $ N ) { $ dp = array ( array ( ) ) ; $ dp [ 0 ] [ 0 ] = $ cost [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ dp [ $ i - 1 ] [ 0 ] + $ cost [ $ i ] [ 0 ] ; for ( $ j = 1 ; $ j < $ N ; $ j ++ ) $ dp [ 0 ] [ $ j ] = $ dp [ 0 ] [ $ j - 1 ] + $ cost [ 0 ] [ $ j ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) + $ cost [ $ i ] [ $ j ] ; } return $ dp [ $ N - 1 ] [ $ N - 1 ] / ( 2 * $ N - 1 ) ; } $ cost = array ( array ( 1 , 2 , 3 ) , array ( 6 , 5 , 4 ) , array ( 7 , 3 , 9 ) ) ; echo maxAverageOfPath ( $ cost , 3 ) ; ? >"}
{"text": "Laluan Berat Maksimum Berakhir Pada Mana -mana Elemen Baris Terakhir Dalam Matriks | Fungsi yang mengembalikan jumlah laluan berat maksimum; Cipta matriks 2D untuk menyimpan jumlah jalan; Memulakan lajur pertama jumlah berat berat (dp [i to n] [0]); Kirakan jumlah laluan REST matriks berat; Cari jumlah laluan berat maksimum untuk mengulangi baris terakhir; mengembalikan jumlah laluan berat maksimum; Program Pemandu", "code": "< ? php function maxCost ( $ mat , $ N ) { $ dp = array ( array ( ) ) ; memset ( dp , 0 , sizeof ( dp ) ) ; $ dp [ 0 ] [ 0 ] = $ mat [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ mat [ $ i ] [ 0 ] + $ dp [ $ i - 1 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j < $ i + 1 && $ j < $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + max ( $ dp [ $ i - 1 ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } $ result = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ result < $ dp [ $ N - 1 ] [ $ i ] ) $ result = $ dp [ $ N - 1 ] [ $ i ] ; return $ result ; } $ mat = array ( array ( 4 , 1 , 5 , 6 , 1 ) , array ( 2 , 9 , 2 , 11 , 10 ) , array ( 15 , 1 , 3 , 15 , 2 ) , array ( 16 , 92 , 41 , 4 , 3 ) , array ( 8 , 142 , 6 , 4 , 8 ) ) ; $ N = 5 ; echo \" Maximum ▁ Path ▁ Sum ▁ : ▁ \" , maxCost ( $ mat , $ N ) ; ? >"}
{"text": "Keuntungan maksimum dengan membeli dan menjual bahagian pada kebanyakan k kali | Fungsi untuk mengetahui keuntungan maksimum dengan membeli & menjual saham Atmost k kali diberikan harga saham N hari; Jadual untuk menyimpan hasil subproblems keuntungan [t] [i] menyimpan keuntungan maksimum menggunakan urus niaga atmost t hingga hari I (termasuk hari I); Untuk hari 0, anda tidak boleh mendapatkan wang tanpa mengira berapa kali anda berdagang; Keuntungan adalah 0 jika kita tidak melakukan apa -apa transaksi (iaitu k = 0); Isi meja di bawah fesyen; Kod pemacu", "code": "< ? php function maxProfit ( $ price , $ n , $ k ) { $ profit [ $ k + 1 ] [ $ n + 1 ] = 0 ; for ( $ i = 0 ; $ i <= $ k ; $ i ++ ) $ profit [ $ i ] [ 0 ] = 0 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ profit [ 0 ] [ $ j ] = 0 ; $ prevDiff = NULL ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { $ prevDiff = max ( $ prevDiff , $ profit [ $ i - 1 ] [ $ j - 1 ] - $ price [ $ j - 1 ] ) ; $ profit [ $ i ] [ $ j ] = max ( $ profit [ $ i ] [ $ j - 1 ] , $ price [ $ j ] + $ prevDiff ) ; } } return $ profit [ $ k ] [ $ n - 1 ] ; } $ k = 3 ; $ price = array ( 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 ) ; $ n = sizeof ( $ price ) ; echo \" Maximum ▁ profit ▁ is : ▁ \" , maxProfit ( $ price , $ n , $ k ) ; ? >"}
{"text": "Kira urutan binari panjang dengan jumlah yang sama dengan bit separuh pertama dan kedua | Diff adalah perbezaan antara jumlah bit pertama dan bits terakhir; Kita tidak dapat menampung perbezaan lebih daripada n dengan bit 2n; n == 1, i. e. , Urutan 2 bit panjang; Bit pertama ialah 0 & bit terakhir ialah 1; Bit pertama dan terakhir adalah sama; Bit pertama ialah 1 & bit terakhir ialah 0; Kod pemacu", "code": "< ? php function countSeq ( $ n , $ diff ) { if ( abs ( $ diff ) > $ n ) return 0 ; if ( $ n == 1 && $ diff == 0 ) return 2 ; if ( $ n == 1 && abs ( $ diff ) == 1 ) return 1 ; $ res = countSeq ( $ n - 1 , $ diff + 1 ) + 2 * countSeq ( $ n - 1 , $ diff ) + countSeq ( $ n - 1 , $ diff - 1 ) ; return $ res ; } $ n = 2 ; echo \" Count ▁ of ▁ sequences ▁ is ▁ \" , countSeq ( $ n , 0 ) ; ? >"}
{"text": "Kira urutan binari panjang dengan jumlah yang sama dengan bit separuh pertama dan kedua | Program php berasaskan memoisasi untuk mengira urutan binari panjang sehingga jumlah bit separuh pertama dan kedua adalah sama; Jadual carian untuk menyimpan hasil subproblem; DIF adalah perbezaan antara jumlah bit pertama dan bit n yang terakhir. e. , dif = (jumlah bit pertama) - (jumlah bit terakhir); Kita tidak dapat menampung perbezaan lebih daripada n dengan bit 2n; n == 1, i. e. , Urutan 2 bit panjang; Semak jika subproblem ini sudah diselesaikan n ditambah kepada DIF untuk memastikan indeks menjadi positif; $ res = bit pertama ialah 0 & bit terakhir ialah 1; Bit pertama dan terakhir adalah sama; Bit pertama ialah 1 & bit terakhir ialah 0; Kedai menghasilkan jadual carian dan mengembalikan hasilnya; Pembalut atas countsequtil (). Ia terutamanya memulakan jadual carian, kemudian memanggil countsequtil (); hubungi CountSequtil (); Kod pemacu", "code": "< ? php $ MAX = 1000 ; $ lookup = array_fill ( 0 , $ MAX , array_fill ( 0 , $ MAX , -1 ) ) ; function countSeqUtil ( $ n , $ dif ) { global $ lookup ; if ( abs ( $ dif ) > $ n ) return 0 ; if ( $ n == 1 && $ dif == 0 ) return 2 ; if ( $ n == 1 && abs ( $ dif ) == 1 ) return 1 ; if ( $ lookup [ $ n ] [ $ n + $ dif ] != -1 ) return $ lookup [ $ n ] [ $ n + $ dif ] ; countSeqUtil ( $ n - 1 , $ dif + 1 ) + 2 * countSeqUtil ( $ n - 1 , $ dif ) + countSeqUtil ( $ n - 1 , $ dif - 1 ) ; return $ lookup [ $ n ] [ $ n + $ dif ] = $ res ; } function countSeq ( $ n ) { return countSeqUtil ( $ n , 0 ) ; } $ n = 2 ; echo \" Count ▁ of ▁ sequences ▁ is ▁ \" . countSeq ( $ n ) ; ? >"}
{"text": "Keluarkan unsur -unsur minimum dari kedua -dua belah pihak supaya 2 * min menjadi lebih daripada max | Fungsi utiliti untuk mencari minimum dalam arr [l. . h]; Fungsi utiliti untuk mencari maksimum dalam arr [l. . h]; Mengembalikan bilangan minimum penyingkiran dari kedua -dua hujung di arr [l. . H] supaya 2 * min menjadi lebih besar daripada maks. ; Sekiranya terdapat 1 atau kurang elemen, kembali 0. Untuk satu elemen, 2 * min> max. (Asumsi: Semua elemen positif dalam arr []); 1) Cari minimum dan maksimum dalam arr [l. . h]; Sekiranya harta itu diikuti, tiada penyingkiran diperlukan; Jika tidak, keluarkan watak dari hujung kiri dan berulang, kemudian keluarkan watak dari hujung kanan dan berulang, ambil minimum dua dikembalikan; Kod pemacu", "code": "< ? php function min_1 ( & $ arr , $ l , $ h ) { $ mn = $ arr [ $ l ] ; for ( $ i = $ l + 1 ; $ i <= $ h ; $ i ++ ) if ( $ mn > $ arr [ $ i ] ) $ mn = $ arr [ $ i ] ; return $ mn ; } function max_1 ( & $ arr , $ l , $ h ) { $ mx = $ arr [ $ l ] ; for ( $ i = $ l + 1 ; $ i <= $ h ; $ i ++ ) if ( $ mx < $ arr [ $ i ] ) $ mx = $ arr [ $ i ] ; return $ mx ; } function minRemovals ( & $ arr , $ l , $ h ) { if ( $ l >= $ h ) return 0 ; $ mn = min_1 ( $ arr , $ l , $ h ) ; $ mx = max_1 ( $ arr , $ l , $ h ) ; if ( 2 * $ mn > $ mx ) return 0 ; return min ( minRemovals ( $ arr , $ l + 1 , $ h ) , minRemovals ( $ arr , $ l , $ h - 1 ) ) + 1 ; } $ arr = array ( 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 ) ; $ n = sizeof ( $ arr ) ; echo minRemovals ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text": "Kira semua jalan yang mungkin dari kiri ke bawah kanan kanan matriks MXN | Mengembalikan kiraan laluan yang mungkin untuk mencapai sel pada nombor baris m dan nombor lajur n dari sel paling kiri (sel pada 1, 1); Buat jadual 2D untuk menyimpan hasil subproblem; Count laluan untuk mencapai mana -mana sel dalam lajur pertama ialah 1; Count laluan untuk mencapai mana -mana sel dalam lajur pertama ialah 1; Hitung kiraan laluan untuk sel -sel lain di bawah dengan cara menggunakan penyelesaian rekursif; Dengan Uncommenting bahagian terakhir kod mengira jumlah laluan yang mungkin jika pergerakan pepenjuru dibenarkan; Kod pemacu", "code": "< ? php function numberOfPaths ( $ m , $ n ) { $ count = array ( ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ count [ $ i ] [ 0 ] = 1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ count [ 0 ] [ $ j ] = 1 ; for ( $ i = 1 ; $ i < $ m ; $ i ++ ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) $ count [ $ i ] [ $ j ] = $ count [ $ i - 1 ] [ $ j ] + $ count [ $ i ] [ $ j - 1 ] + count [ i - 1 ] [ j - 1 ] ; } return $ count [ $ m - 1 ] [ $ n - 1 ] ; } echo numberOfPaths ( 3 , 3 ) ; ? >"}
{"text": "Pemotongan Produk Maksimum | DP | Fungsi utiliti untuk mendapatkan maksimum dua dan tiga bilangan bulat; Fungsi utama yang mengembalikan produk maksimum yang dapat diperoleh dari tali panjang n; Kes asas; Buat potongan di tempat yang berbeza dan ambil maksimum semua; Mengembalikan maksimum semua nilai; Kod pemacu", "code": "< ? php function max_1 ( $ a , $ b , $ c ) { return max ( $ a , max ( $ b , $ c ) ) ; } function maxProd ( $ n ) { if ( $ n == 0 $ n == 1 ) return 0 ; $ max_val = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ max_val = max_1 ( $ max_val , $ i * ( $ n - $ i ) , maxProd ( $ n - $ i ) * $ i ) ; return $ max_val ; } echo \" Maximum ▁ Product ▁ is ▁ \" . maxProd ( 10 ) ; ? >"}
{"text": "Penjadualan baris pemasangan | DP | Program PHP untuk mencari masa minimum yang mungkin oleh casis kereta untuk disiapkan; Fungsi utiliti untuk mencari minimum dua nombor; masa yang diambil untuk meninggalkan stesen pertama dalam baris 1; masa yang diambil untuk meninggalkan stesen pertama dalam baris 2; Mengisi jadual t1 [] dan t2 [] menggunakan hubungan rekursif yang diberikan di atas; Pertimbangkan masa keluar dan pulangan minimum; Kod pemacu", "code": "< ? php $ NUM_LINE = 2 ; $ NUM_STATION = 4 ; function carAssembly ( $ a , $ t , $ e , $ x ) { global $ NUM_LINE , $ NUM_STATION ; $ T1 = array ( ) ; $ T2 = array ( ) ; $ i ; $ T1 [ 0 ] = $ e [ 0 ] + $ a [ 0 ] [ 0 ] ; $ T2 [ 0 ] = $ e [ 1 ] + $ a [ 1 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ NUM_STATION ; ++ $ i ) { $ T1 [ $ i ] = min ( $ T1 [ $ i - 1 ] + $ a [ 0 ] [ $ i ] , $ T2 [ $ i - 1 ] + $ t [ 1 ] [ $ i ] + $ a [ 0 ] [ $ i ] ) ; $ T2 [ $ i ] = min ( $ T2 [ $ i - 1 ] + $ a [ 1 ] [ $ i ] , $ T1 [ $ i - 1 ] + $ t [ 0 ] [ $ i ] + $ a [ 1 ] [ $ i ] ) ; } return min ( $ T1 [ $ NUM_STATION - 1 ] + $ x [ 0 ] , $ T2 [ $ NUM_STATION - 1 ] + $ x [ 1 ] ) ; } $ a = array ( array ( 4 , 5 , 3 , 2 ) , array ( 2 , 10 , 1 , 4 ) ) ; $ t = array ( array ( 0 , 7 , 4 , 5 ) , array ( 0 , 9 , 2 , 8 ) ) ; $ e = array ( 10 , 12 ) ; $ x = array ( 18 , 7 ) ; echo carAssembly ( $ a , $ t , $ e , $ x ) ; ? >"}
{"text": "Substring biasa terpanjang | DP | Mengembalikan panjang substring biasa terpanjang x [0 .. m - 1] dan y [0 .. n - 1]; Buat jadual untuk menyimpan panjang akhiran substrings yang paling lama. Notethat lcsuff [i] [j] mengandungi panjang akhiran biasa terpanjang x [0 .. i - 1] dan y [0. .. J - 1]. Barisan pertama dan entri lajur pertama tidak mempunyai makna logik, ia hanya digunakan untuk kesederhanaan program; Untuk menyimpan panjang substring biasa terpanjang; Langkah -langkah berikut membina lcsuff [m + 1] [n + 1] dalam fesyen bawah. ; Kod pemacu", "code": "< ? php function LCSubStr ( $ X , $ Y , $ m , $ n ) { $ LCSuff = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , NULL ) ) ; $ result = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ LCSuff [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) { $ LCSuff [ $ i ] [ $ j ] = $ LCSuff [ $ i - 1 ] [ $ j - 1 ] + 1 ; $ result = max ( $ result , $ LCSuff [ $ i ] [ $ j ] ) ; } else $ LCSuff [ $ i ] [ $ j ] = 0 ; } } return $ result ; } $ X = \" OldSite : GeeksforGeeks . org \" ; $ Y = \" NewSite : GeeksQuiz . com \" ; $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; echo \" Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ▁ \" . LCSubStr ( $ X , $ Y , $ m , $ n ) ; ? >"}
{"text": "SUM MAXIMUM SUMS menggunakan algoritma membahagikan dan menaklukkan | Cari jumlah maksimum yang mungkin dalam arr [] supaya arr [m] adalah sebahagian daripadanya; Termasuk unsur -unsur di sebelah kiri pertengahan. ; Termasuk unsur -unsur di sebelah kanan pertengahan; Kembali jumlah elemen di kiri dan kanan pertengahan kembali hanya left_sum + right_sum akan gagal untuk [ - 2, 1]; Mengembalikan jumlah maksimum subarray dalam aa [l. . h]; Kes asas: Hanya satu elemen; Cari titik tengah; Pulangan maksimum berikut tiga kes yang mungkin a) jumlah subarray maksimum di separuh kiri b) jumlah subarray maksimum di separuh kanan c) Subarray maksimum sehingga subarray melintasi titik tengah; Kod pemacu", "code": "< ? php function maxCrossingSum ( & $ arr , $ l , $ m , $ h ) { $ sum = 0 ; $ left_sum = PHP_INT_MIN ; for ( $ i = $ m ; $ i >= $ l ; $ i -- ) { $ sum = $ sum + $ arr [ $ i ] ; if ( $ sum > $ left_sum ) $ left_sum = $ sum ; } $ sum = 0 ; $ right_sum = PHP_INT_MIN ; for ( $ i = $ m + 1 ; $ i <= $ h ; $ i ++ ) { $ sum = $ sum + $ arr [ $ i ] ; if ( $ sum > $ right_sum ) $ right_sum = $ sum ; } return max ( $ left_sum + $ right_sum , $ left_sum , $ right_sum ) ; } function maxSubArraySum ( & $ arr , $ l , $ h ) { if ( $ l == $ h ) return $ arr [ $ l ] ; $ m = intval ( ( $ l + $ h ) / 2 ) ; return max ( maxSubArraySum ( $ arr , $ l , $ m ) , maxSubArraySum ( $ arr , $ m + 1 , $ h ) , maxCrossingSum ( $ arr , $ l , $ m , $ h ) ) ; } $ arr = array ( 2 , 3 , 4 , 5 , 7 ) ; $ n = count ( $ arr ) ; $ max_sum = maxSubArraySum ( $ arr , 0 , $ n - 1 ) ; echo \" Maximum ▁ contiguous ▁ sum ▁ is ▁ \" . $ max_sum ; ? >"}
{"text": "Program untuk mencari jumlah air dalam kaca tertentu | Mengembalikan jumlah air dalam kaca JTH baris; Nombor baris saya mempunyai lajur maksimum i. Jadi nombor lajur input mestilah kurang daripada saya; Akan ada i * (i + 1) / 2 gelas sehingga baris ith (termasuk baris ith) dan memulakan semua gelas sebagai kosong; Letakkan semua air dalam kaca pertama; Sekarang biarkan aliran air ke gelas ke bawah sehingga nombor baris kurang daripada atau / sama dengan pembetulan saya (diberi baris): X boleh menjadi sifar untuk gelas sampingan kerana mereka mempunyai kadar yang lebih rendah untuk diisi; Isi gelas dalam baris tertentu. Bilangan lajur berturut -turut adalah sama dengan nombor baris; Dapatkan air dari kaca semasa; Pastikan jumlah yang kurang daripada atau sama dengan kapasiti dalam kaca semasa; Dapatkan baki jumlah; Mengedarkan baki jumlah ke bawah dua gelas; Indeks gelas jth di baris ith akan menjadi i * (i - 1) / 2 + j - 1; Kod pemacu; Jumlah air", "code": "< ? php function findWater ( $ i , $ j , $ X ) { if ( $ j > $ i ) { echo \" Incorrect ▁ Input STRNEWLINE \" ; return ; } $ glass = array_fill ( 0 , ( int ) ( $ i * ( $ i + 1 ) / 2 ) , 0 ) ; $ index = 0 ; $ glass [ $ index ] = $ X ; for ( $ row = 1 ; $ row < $ i ; ++ $ row ) { for ( $ col = 1 ; $ col <= $ row ; ++ $ col , ++ $ index ) { $ X = $ glass [ $ index ] ; $ glass [ $ index ] = ( $ X >= 1.0 ) ? 1.0 : $ X ; $ X = ( $ X >= 1.0 ) ? ( $ X - 1 ) : 0.0 ; $ glass [ $ index + $ row ] += ( double ) ( $ X / 2 ) ; $ glass [ $ index + $ row + 1 ] += ( double ) ( $ X / 2 ) ; } } return $ glass [ ( int ) ( $ i * ( $ i - 1 ) / 2 + $ j - 1 ) ] ; } $ i = 2 ; $ j = 2 ; $ X = 2.0 ; echo \" Amount ▁ of ▁ water ▁ in ▁ jth ▁ \" , \" glass ▁ of ▁ ith ▁ row ▁ is : ▁ \" . str_pad ( findWater ( $ i , $ j , $ X ) , 8 , '0' ) ; ? >"}
{"text": "Partitioning Palindrome | DP | Mengembalikan bilangan minimum pemotongan yang diperlukan untuk memisahkan rentetan supaya setiap bahagian adalah palindrome; Dapatkan panjang rentetan; Buat dua tatasusunan untuk membina penyelesaian dengan cara bawah C [i] [j] = bilangan minimum pemotongan yang diperlukan untuk pembahagian palindrome substring str [i. . j] p [i] [j] = Benar jika substring str [i. . J] adalah palindrome, lain -lain yang salah nota bahawa C [i] [j] adalah 0 jika p [i] [j] adalah benar; Setiap substring panjang 1 adalah palindrome; L adalah panjang substring. Bina penyelesaian dengan cara bawah dengan mempertimbangkan semua substrings panjang bermula dari 2 hingga n. Struktur gelung adalah sama seperti masalah pendaraban rantai matriks (lihat https: www Geeksforgeeks. Org / matriks - rantai - pendaraban - dp - 8 /); Untuk substring panjang L, tetapkan indeks permulaan yang berbeza; Tetapkan indeks akhir; Jika L adalah 2, maka kita hanya perlu membandingkan dua aksara. Lain perlu menyemak dua aksara sudut dan nilai p [i + 1] [j - 1]; Jika str [i. . J] adalah palindrome, maka C [i] [j] adalah 0; Buat potongan di setiap lokasi yang mungkin bermula dari saya ke J, dan dapatkan potongan kos minimum. ; Kembalikan nilai potong min untuk rentetan lengkap. i. e. , str [0 .. n - 1]; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function minPalPartion ( $ str ) { $ n = strlen ( $ str ) ; $ C = array_fill ( 0 , $ n , array_fill ( 0 , $ n , NULL ) ) ; $ P = array_fill ( false , $ n , array_fill ( false , $ n , NULL ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ P [ $ i ] [ $ i ] = true ; $ C [ $ i ] [ $ i ] = 0 ; } for ( $ L = 2 ; $ L <= $ n ; $ L ++ ) { for ( $ i = 0 ; $ i < $ n - $ L + 1 ; $ i ++ ) { $ j = $ i + $ L - 1 ; if ( $ L == 2 ) $ P [ $ i ] [ $ j ] = ( $ str [ $ i ] == $ str [ $ j ] ) ; else $ P [ $ i ] [ $ j ] = ( $ str [ $ i ] == $ str [ $ j ] ) && $ P [ $ i + 1 ] [ $ j - 1 ] ; if ( $ P [ $ i ] [ $ j ] == true ) $ C [ $ i ] [ $ j ] = 0 ; else { $ C [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ k = $ i ; $ k <= $ j - 1 ; $ k ++ ) $ C [ $ i ] [ $ j ] = min ( $ C [ $ i ] [ $ j ] , $ C [ $ i ] [ $ k ] + $ C [ $ k + 1 ] [ $ j ] + 1 ) ; } } } return $ C [ 0 ] [ $ n - 1 ] ; } $ str = \" ababbbabbababa \" ; echo \" Min ▁ cuts ▁ needed ▁ for ▁ Palindrome ▁ Partitioning ▁ is ▁ \" . minPalPartion ( $ str ) ; return 0 ; ? >"}
{"text": "Pencocokan rentetan dengan * (yang sepadan dengan mana -mana) dalam mana -mana dua rentetan | Berfungsi untuk memeriksa sama ada kedua -dua rentetan boleh dipadankan atau tidak; Jika rentetan tidak mempunyai * maka watak pada kedudukan itu mestilah sama. ; Kod pemacu", "code": "< ? php function doMatch ( $ A , $ B ) { for ( $ i = 0 ; $ i < strlen ( $ A ) ; $ i ++ ) if ( $ A [ $ i ] != ' * ' && $ B [ $ i ] != ' * ' ) if ( $ A [ $ i ] != $ B [ $ i ] ) return false ; return true ; } $ A = \" gee * sforgeeks \" ; $ B = \" geeksforgeeks \" ; echo doMatch ( $ A , $ B ) ; ? >"}
{"text": "Cari istilah n Siri 0, 2, 4, 8, 12, 18. . | Mengira istilah siri nth; Kod pemacu", "code": "< ? php function nthTerm ( $ N ) { return ( int ) ( ( $ N + $ N * ( $ N - 1 ) ) / 2 ) ; } $ N = 5 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Bilangan substrings satu rentetan yang hadir di lain | Program PHP untuk mengira bilangan substring S1 yang hadir dalam S2. ; S3 menyimpan semua substrings S1; Semak kehadiran S3 dalam S2; Kod pemacu", "code": "< ? php function countSubstrs ( $ s1 , $ s2 ) { $ ans = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s1 ) ; $ i ++ ) { $ s3 = \" \" ; for ( $ j = $ i ; $ j < strlen ( $ s1 ) ; $ j ++ ) { $ s3 += $ s1 [ $ j ] ; if ( stripos ( $ s2 , $ s3 , 0 ) != -1 ) $ ans ++ ; } } return $ ans ; } $ s1 = \" aab \" ; $ s2 = \" aaaab \" ; echo countSubstrs ( $ s1 , $ s2 ) ; ? >"}
{"text": "Cari istilah n Siri 1, 4, 15, 72, 420. . | Fungsi untuk mencari faktorial n; Kembali faktorial n; Fungsi untuk mengira istilah siri nth; Kod pemacu", "code": "< ? php function factorial ( $ N ) { $ fact = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ fact = $ fact * $ i ; return $ fact ; } function nthTerm ( $ N ) { return ( factorial ( $ N ) * ( $ N + 2 ) / 2 ) ; } $ N = 6 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Ekspresi Padankan Di mana satu watak khas dalam corak boleh memadankan satu atau lebih aksara | Pulangan benar jika Pat sepadan dengan teks; Saya digunakan sebagai indeks dalam corak dan j sebagai indeks dalam teks; Melintasi corak; Jika watak corak semasa tidak ' #'; Jika tidak sepadan dengan teks; Jika perlawanan, kenaikan i dan j; Watak semasa ialah ' #'; Sekurang -kurangnya satu watak mesti sepadan dengan #; Padankan aksara dengan # sehingga watak yang sepadan dijumpai. ; Memadankan dengan # berakhir, bergerak ke hadapan dalam corak; Kod pemacu", "code": "< ? php function regexMatch ( $ text , $ pat ) { $ lenText = strlen ( $ text ) ; $ letPat = strlen ( $ pat ) ; $ i = 0 ; $ j = 0 ; while ( $ i < $ letPat ) { if ( $ pat [ $ i ] != ' # ' ) { if ( $ pat [ $ i ] != $ text [ $ j ] ) return false ; $ i ++ ; $ j ++ ; } else { $ j ++ ; while ( $ text [ $ j ] != $ pat [ $ i + 1 ] ) $ j ++ ; $ i ++ ; } } return ( $ j == $ lenText ) ; } $ str = \" ABABABA \" ; $ pat = \" A # B # A \" ; if ( regexMatch ( $ str , $ pat ) ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text": "Pokok Indeks Perduaan: Kemas Kini Range dan Pertanyaan Titik | Kemas kini seperti getElement () mendapat nilai yang lebih tinggi apabila ditanya dari L ke R. ; Dapatkan elemen diindeks pada i; Untuk mendapatkan jumlah elemen semua elemen dari 0 hingga saya perlu dikira; Kod pemacu; Cari elemen di Indeks 4; Cari elemen di Indeks 3", "code": "< ? php function update ( & $ arr , $ l , $ r , $ val ) { $ arr [ $ l ] += $ val ; if ( $ r + 1 < sizeof ( $ arr ) ) $ arr [ $ r + 1 ] -= $ val ; } function getElement ( & $ arr , $ i ) { $ res = 0 ; for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) $ res += $ arr [ $ j ] ; return $ res ; } $ arr = array ( 0 , 0 , 0 , 0 , 0 ) ; $ n = sizeof ( $ arr ) ; $ l = 2 ; $ r = 4 ; $ val = 2 ; update ( $ arr , $ l , $ r , $ val ) ; $ index = 4 ; echo ( \" Element ▁ at ▁ index ▁ \" . $ index . \" ▁ is ▁ \" . getElement ( $ arr , $ index ) . \" STRNEWLINE \" ) ; $ l = 0 ; $ r = 3 ; $ val = 4 ; update ( $ arr , $ l , $ r , $ val ) ; $ index = 3 ; echo ( \" Element ▁ at ▁ index ▁ \" . $ index . \" ▁ is ▁ \" . getElement ( $ arr , $ index ) ) ; ? >"}
{"text": "Bilangan cara untuk mengatur 2 * n orang di kedua -dua belah meja dengan orang X dan Y di sisi bertentangan | Berfungsi untuk mencari faktorial nombor; Berfungsi untuk mencari NCR; Berfungsi untuk mencari bilangan cara untuk mengatur 2 orang; Kod pemacu; Panggilan fungsi", "code": "< ? php function factorial ( $ n ) { if ( $ n <= 1 ) return 1 ; return $ n * factorial ( $ n - 1 ) ; } function nCr ( $ n , $ r ) { return factorial ( $ n ) / ( factorial ( $ n - $ r ) * factorial ( $ r ) ) ; } function NumberOfWays ( $ n , $ x , $ y ) { return nCr ( 2 * $ n - $ x - $ y , $ n - $ x ) * factorial ( $ n ) * factorial ( $ n ) ; } $ n = 5 ; $ x = 4 ; $ y = 2 ; echo ( NumberOfWays ( $ n , $ x , $ y ) ) ; ? >"}
{"text": "Kira pasangan dari dua tatasusunan dengan jumlah keseluruhan | Berfungsi untuk mengembalikan kiraan pasangan yang diperlukan; Kiraan ganjil dan bahkan nombor dari kedua -dua tatasusunan; Cari kiraan ganjil dan juga unsur -unsur dalam []; Cari kiraan ganjil dan juga unsur -unsur dalam B []; Mengira bilangan pasangan; Mengembalikan bilangan pasangan; Kod pemacu; Kod ini disumbangkan oleh ankitrai01", "code": "< ? php function count_pairs ( $ a , $ b , $ n , $ m ) { $ odd1 = 0 ; $ even1 = 0 ; $ odd2 = 0 ; $ even2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 == 1 ) $ odd1 ++ ; else $ even1 ++ ; } for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ b [ $ i ] % 2 == 1 ) $ odd2 ++ ; else $ even2 ++ ; } $ pairs = min ( $ odd1 , $ odd2 ) + min ( $ even1 , $ even2 ) ; return $ pairs ; } $ a = array ( 9 , 14 , 6 , 2 , 11 ) ; $ b = array ( 8 , 4 , 7 , 20 ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; echo count_pairs ( $ a , $ b , $ n , $ m ) ; ? >"}
{"text": "Cari nilai n apabila f (n) = f (a) + f (b) di mana a + b adalah minimum mungkin dan a * b = n | Berfungsi untuk mengembalikan nilai f (n); Kes asas; Kira bilangan kali nombor jika dibahagikan dengan 2; Mengembalikan penjumlahan; Kod pemacu", "code": "< ? php function getValueOfF ( $ n ) { if ( $ n == 1 ) return 0 ; if ( $ n == 2 ) return 1 ; $ cnt = 0 ; while ( $ n % 2 == 0 ) { $ cnt += 1 ; $ n /= 2 ; } return 2 * $ cnt ; } $ n = 20 ; echo getValueOfF ( $ n ) ; ? >"}
{"text": "Cari (1 ^ n + 2 ^ n + 3 ^ n + 4 ^ n) mod 5 | Tetapkan 2 | Berfungsi untuk mengembalikan mod B; panjang rentetan; untuk menyimpan jawapan yang diperlukan; Fungsi untuk kembali (1 ^ n + 2 ^ n + 3 ^ n + 4 ^ n) % 5; Hitung dan kembalikan Ans; Kod pemacu", "code": "< ? php function A_mod_B ( $ N , $ a ) { $ len = strlen ( $ N ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ ans = ( $ ans * 10 + ( int ) $ N [ $ i ] - '0' ) % $ a ; return $ ans % $ a ; } function findMod ( $ N ) { $ mod = A_mod_B ( $ N , 4 ) ; $ ans = ( 1 + pow ( 2 , $ mod ) + pow ( 3 , $ mod ) + pow ( 4 , $ mod ) ) ; return ( $ ans % 5 ) ; } $ N = \"4\" ; echo findMod ( $ N ) ; ? >"}
{"text": "Unsur -unsur yang lebih besar daripada elemen sebelumnya dan seterusnya dalam array | Berfungsi untuk mencetak elemen lebih besar daripada elemen sebelumnya dan seterusnya dalam array; Arus melintasi Indeks 1 hingga n - 2 dan periksa keadaan yang diberikan; Kod pemacu", "code": "< ? php function printElements ( $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] and $ arr [ $ i ] > $ arr [ $ i + 1 ] ) echo $ arr [ $ i ] . \" ▁ \" ; } } $ arr = array ( 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 ) ; $ n = sizeof ( $ arr ) ; printElements ( $ arr , $ n ) ;"}
{"text": "Jumlah siri KN + (k (n | rekursif c program untuk mengira kuasa modular; kes asas; jika b juga; jika b adalah ganjil; berfungsi untuk mengembalikan jumlah; kod pemacu", "code": "< ? php function exponent ( $ A , $ B ) { if ( $ A == 0 ) return 0 ; if ( $ B == 0 ) return 1 ; if ( $ B % 2 == 0 ) { $ y = exponent ( $ A , $ B / 2 ) ; $ y = ( $ y * $ y ) ; } else { $ y = $ A ; $ y = ( $ y * exponent ( $ A , $ B - 1 ) ) ; } return $ y ; } function sum ( $ k , $ n ) { $ sum = exponent ( $ k , $ n + 1 ) - exponent ( $ k - 1 , $ n + 1 ) ; return $ sum ; } $ n = 3 ; $ K = 3 ; echo sum ( $ K , $ n ) ; ? >"}
{"text": "Kurangkan kos untuk memecah nombor | Periksa sama ada nombor adalah perdana atau tidak; Jalankan gelung sehingga akar persegi x; Berfungsi untuk mengembalikan kos yang diminimumkan; Jika n adalah perdana; Jika n adalah ganjil dan boleh dibahagikan kepada (Prime + 2) maka kos akan menjadi 1 + 1 = 2; Setiap nombor bukan perdana boleh dinyatakan sebagai jumlah dua prima; n adalah ganjil jadi n boleh dibahagikan kepada (3 + walaupun) lebih jauh walaupun bahagian boleh dibahagikan kepada (Perdana + Perdana) (3 + Perdana + Perdana) akan menelan kos 3; Kod pemacu", "code": "< ? php function isPrime ( $ x ) { for ( $ i = 2 ; $ i * $ i <= $ x ; $ i ++ ) { if ( $ x % $ i == 0 ) return 0 ; } return 1 ; } function minimumCost ( $ n ) { if ( isPrime ( $ n ) ) return 1 ; if ( $ n % 2 == 1 && isPrime ( $ n - 2 ) ) return 2 ; if ( $ n % 2 == 0 ) return 2 ; return 3 ; } $ n = 6 ; echo ( minimumCost ( $ n ) ) ;"}
{"text": "Cari jumlah air yang sia -sia selepas mengisi tangki | Fungsi untuk mengira jumlah air sia -sia; Jumlah air yang diisi dalam satu minit; Jumlah masa yang diambil untuk mengisi tangki kerana kebocoran; jumlah air yang terbuang; Kod pemacu", "code": "< ? php function wastedWater ( $ V , $ M , $ N ) { $ amt_per_min = $ M - $ N ; $ time_to_fill = $ V / $ amt_per_min ; $ wasted_amt = $ N * $ time_to_fill ; return $ wasted_amt ; } $ V = 700 ; $ M = 10 ; $ N = 3 ; echo wastedWater ( $ V , $ M , $ N ) , \" STRNEWLINE \" ; $ V = 1000 ; $ M = 100 ; $ N = 50 ; echo wastedWater ( $ V , $ M , $ N ) ;"}
{"text": "Terkecil dan terbesar n | Berfungsi untuk mencetak kiub sempurna N - digit yang terbesar dan terkecil; N - digit Cube sempurna; N - digit Cube sempurna; Kod pemacu", "code": "< ? php function nDigitPerfectCubes ( $ n ) { print ( pow ( ceil ( pow ( pow ( 10 , ( $ n - 1 ) ) , 1 / 3 ) ) , 3 ) . \" ▁ \" ) ; print ( ( int ) pow ( ceil ( pow ( pow ( 10 , ( $ n ) ) , 1 / 3 ) ) - 1 , 3 ) ) ; } $ n = 3 ; nDigitPerfectCubes ( $ n ) ; ? >"}
{"text": "Nombor kiraan yang boleh dibahagikan dengan semua nombor dari 2 hingga 10 | Berfungsi untuk mengembalikan kiraan nombor dari 1 hingga N yang boleh dibahagikan dengan semua nombor dari 2 hingga 10; Kod pemacu", "code": "< ? php function countNumbers ( $ n ) { return ( int ) ( $ n / 2520 ) ; } $ n = 3000 ; echo ( countNumbers ( $ n ) ) ; ? >"}
{"text": "Jumlah semua faktor ganjil nombor dalam julat [l, r] | Pelaksanaan PHP pendekatan; Fungsi untuk mengira jumlah awalan semua faktor ganjil; Tambah saya kepada semua gandaan i; Mengemas kini jumlah awalan; Berfungsi untuk mengembalikan jumlah semua faktor ganjil nombor dalam julat yang diberikan; Kod pemacu", "code": "< ? php $ MAX = 10001 ; $ prefix = array_fill ( 0 , $ MAX , 0 ) ; function sieve_modified ( ) { global $ prefix , $ MAX ; for ( $ i = 1 ; $ i < $ MAX ; $ i += 2 ) { for ( $ j = $ i ; $ j < $ MAX ; $ j += $ i ) $ prefix [ $ j ] += $ i ; } for ( $ i = 1 ; $ i < $ MAX ; $ i ++ ) $ prefix [ $ i ] += $ prefix [ $ i - 1 ] ; } function sumOddFactors ( $ L , $ R ) { global $ prefix ; return ( $ prefix [ $ R ] - $ prefix [ $ L - 1 ] ) ; } sieve_modified ( ) ; $ l = 6 ; $ r = 10 ; echo sumOddFactors ( $ l , $ r ) ;"}
{"text": "Xor pertanyaan submatrix | Pelaksanaan PHP pendekatan; Fungsi untuk pra - mengira XOR; Kiri ke kanan awalan xor untuk setiap baris; Atas ke bawah ke bawah xor untuk setiap lajur; Berfungsi untuk memproses pertanyaan X1, X2, Y1, Y2 mewakili kedudukan sudut kanan kiri dan bawah; Untuk menyimpan nilai XOR; Mencari nilai yang kita perlukan untuk XOR dengan nilai pada (x2, y2) dalam awalan - matriks xor; Kembalikan XOR awalan yang diperlukan; Kod pemacu; Untuk menyimpan XOR yang dikira pra; Pra - pengkomputeran xor; Pertanyaan", "code": "< ? php $ n = 3 ; function preComputeXor ( $ arr , & $ prefix_xor ) { global $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ j == 0 ) $ prefix_xor [ $ i ] [ $ j ] = $ arr [ $ i ] [ $ j ] ; else $ prefix_xor [ $ i ] [ $ j ] = ( $ prefix_xor [ $ i ] [ $ j - 1 ] ^ $ arr [ $ i ] [ $ j ] ) ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 1 ; $ j < $ n ; $ j ++ ) $ prefix_xor [ $ j ] [ $ i ] = ( $ prefix_xor [ $ j - 1 ] [ $ i ] ^ $ prefix_xor [ $ j ] [ $ i ] ) ; } function ansQuerie ( $ prefix_xor , $ x1 , $ y1 , $ x2 , $ y2 ) { $ xor_1 = $ xor_2 = $ xor_3 = 0 ; if ( $ x1 != 0 ) $ xor_1 = $ prefix_xor [ $ x1 - 1 ] [ $ y2 ] ; if ( $ y1 != 0 ) $ xor_2 = $ prefix_xor [ $ x2 ] [ $ y1 - 1 ] ; if ( $ x1 != 0 and $ y1 != 0 ) $ xor_3 = $ prefix_xor [ $ x1 - 1 ] [ $ y1 - 1 ] ; return ( ( $ prefix_xor [ $ x2 ] [ $ y2 ] ^ $ xor_1 ) ^ ( $ xor_2 ^ $ xor_3 ) ) ; } $ arr = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; $ prefix_xor = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; preComputeXor ( $ arr , $ prefix_xor ) ; echo ansQuerie ( $ prefix_xor , 1 , 1 , 2 , 2 ) . \" \" ; echo ansQuerie ( $ prefix_xor , 1 , 2 , 2 , 2 ) ; ? >"}
{"text": "Bilangan kurang daripada n yang sempurna kiub dan jumlah digit mereka dikurangkan menjadi satu digit ialah 1 | Fungsi yang mengembalikan benar jika jumlah nombor angka nm adalah 1; Sekiranya peringatan akan 1 maka jumlahnya adalah 1; Berfungsi untuk mencetak nombor yang diperlukan kurang daripada n; Jika ia adalah kiub sempurna yang diperlukan; Kod pemacu", "code": "< ? php function isDigitSumOne ( $ nm ) { if ( $ nm % 9 == 1 ) return true ; else return false ; } function printValidNums ( $ n ) { $ cbrt_n = ceil ( pow ( $ n , 1 / 3 ) ) ; for ( $ i = 1 ; $ i <= $ cbrt_n ; $ i ++ ) { $ cube = pow ( $ i , 3 ) ; if ( $ cube >= 1 && $ cube <= $ n && isDigitSumOne ( $ cube ) ) echo $ cube , \" ▁ \" ; } } $ n = 1000 ; printValidNums ( $ n ) ; ? >"}
{"text": "Kira bilangan rhombi yang mungkin di dalam segi empat tepat saiz yang diberikan | Berfungsi untuk mengembalikan kiraan rhombi mungkin; Semua kemungkinan panjang pepenjuru; Mengemas kini rhombi mungkin dengan panjang pepenjuru semasa; Mengembalikan jumlah kiraan rhombi yang mungkin; Kod pemacu", "code": "< ? php function countRhombi ( $ h , $ w ) { $ ct = 0 ; for ( $ i = 2 ; $ i <= $ h ; $ i += 2 ) for ( $ j = 2 ; $ j <= $ w ; $ j += 2 ) $ ct += ( $ h - $ i + 1 ) * ( $ w - $ j + 1 ) ; return $ ct ; } $ h = 2 ; $ w = 2 ; echo ( countRhombi ( $ h , $ w ) ) ; ? >"}
{"text": "Program untuk mengira kawasan antara dua lingkaran sepusat | Fungsi untuk mencari kawasan antara kedua -dua bulatan sepusat yang diberikan; Mengisytiharkan nilai pi; Hitung kawasan bulatan luar; Hitung kawasan bulatan dalaman; Perbezaan kawasan; Kod pemacu", "code": "< ? php function calculateArea ( $ x , $ y ) { $ pi = 3.1415926536 ; $ arx = $ pi * $ x * $ x ; $ ary = $ pi * $ y * $ y ; return ( $ arx - $ ary ) ; } $ x = 2 ; $ y = 1 ; echo calculateArea ( $ x , $ y ) ; ? >"}
{"text": "Cari pemenang dengan menambahkan perbezaan elemen pasangan dalam array sehingga mungkin | Fungsi untuk mengira GCD; Berfungsi untuk mengembalikan pemenang permainan; Untuk menyimpan GCD array asal; Untuk menyimpan elemen maksimum dari array asal; Jika bilangan gerakan ganjil; Kod pemacu", "code": "< ? php function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } function getWinner ( $ arr , $ n ) { $ gcd = $ arr [ 0 ] ; $ maxEle = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ gcd = __gcd ( $ gcd , $ arr [ $ i ] ) ; $ maxEle = max ( $ maxEle , $ arr [ $ i ] ) ; } $ totalMoves = ( $ maxEle / $ gcd ) - $ n ; if ( $ totalMoves % 2 == 1 ) return ' A ' ; return ' B ' ; } $ arr = array ( 5 , 6 , 7 ) ; $ n = sizeof ( $ arr ) ; echo getWinner ( $ arr , $ n ) ; ? >"}
{"text": "Count pasangan (i, j) seperti itu ((n % i) % j) % n dimaksimumkan | Pelaksanaan PHP pendekatan; Nombor yang akan memberikan nilai maksimum untuk ((n % i) % j) % n; Untuk menyimpan nilai maksimum yang mungkin ((n % i) % j) % n; Untuk menyimpan kiraan pasangan yang mungkin; Semak semua pasangan yang mungkin; Mengira nilai ((n % i) % j) % n; Jika nilai adalah sama dengan maksimum; Mengembalikan bilangan pasangan yang mungkin; Kod pemacu", "code": "< ? php function countPairs ( $ n ) { $ num = ( ( $ n / 2 ) + 1 ) ; $ max = $ n % $ num ; $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { $ val = ( ( $ n % $ i ) % $ j ) % $ n ; if ( $ val == $ max ) $ count ++ ; } } return $ count ; } $ n = 5 ; echo ( countPairs ( $ n ) ) ; ? >"}
{"text": "Program untuk memeriksa sama ada nombor boleh dibahagikan dengan mana -mana digitnya | Fungsi untuk memeriksa sama ada nombor yang diberikan boleh dibahagikan dengan mana -mana digitnya; Periksa sama ada mana -mana digit membahagikan n; Semak jika k membahagikan n; Kod pemacu", "code": "< ? php function isDivisible ( $ n ) { $ temp = $ n ; while ( $ n ) { $ k = $ n % 10 ; if ( $ temp % $ k == 0 ) return \" YES \" ; $ n = floor ( $ n / 10 ) ; } return \" NO \" ; } $ n = 9876543 ; echo isDivisible ( $ n ) ; ? >"}
{"text": "Program untuk mencari jumlah siri harmonik | Fungsi untuk mengembalikan jumlah siri harmonik; Kod pemacu", "code": "< ? php function sum ( $ n ) { $ i ; $ s = 0.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ s = $ s + 1 / $ i ; return $ s ; } $ n = 5 ; echo ( \" Sum ▁ is ▁ \" ) ; echo ( sum ( $ n ) ) ; ? >"}
{"text": "Semak jika nombor boleh dinyatakan sebagai jumlah dua nombor yang banyak | Fungsi untuk mengembalikan semua nombor yang berlimpah Fungsi ini akan berguna untuk pelbagai pertanyaan; Untuk menyimpan nombor yang banyak; Untuk menyimpan jumlah pembahagi termasuk 1 dalam jumlah; Jika J adalah pembahagi yang betul; Jika saya bukan persegi yang sempurna; Jika jumlah lebih besar daripada saya maka saya adalah jumlah yang banyak; Semak sama ada nombor n dinyatakan sebagai jumlah dua nombor yang banyak; Jika kedua -dua saya dan n - saya banyak nombor; tidak boleh dinyatakan; Kod pemacu", "code": "< ? php function ABUNDANT ( ) { $ N = 100005 ; $ v = array ( ) ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ sum = 1 ; for ( $ j = 2 ; $ j * $ j <= $ i ; $ j ++ ) { if ( $ i % $ j == 0 ) { $ sum += $ j ; if ( $ i / $ j != $ j ) $ sum += $ i / $ j ; } } if ( $ sum > $ i ) array_push ( $ v , $ i ) ; } $ v = array_unique ( $ v ) ; return $ v ; } function SumOfAbundant ( $ n ) { $ v = ABUNDANT ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( in_array ( $ i , $ v ) && in_array ( $ n - $ i , $ v ) ) { echo $ i , \" ▁ \" , $ n - $ i ; return ; } } echo - 1 ; } $ n = 24 ; SumOfAbundant ( $ n ) ; ? >"}
{"text": "Cari istilah n Siri 5 2 13 41 | fungsi untuk mengira istilah ke siri; jika n adalah nombor juga; jika n adalah nombor ganjil; kembali istilah n; Kod pemacu", "code": "< ? php function nthTermOfTheSeries ( $ n ) { if ( $ n % 2 == 0 ) $ nthTerm = pow ( $ n - 1 , 2 ) + $ n ; else $ nthTerm = pow ( $ n + 1 , 2 ) + $ n ; return $ nthTerm ; } $ n = 8 ; echo nthTermOfTheSeries ( $ n ) . \" STRNEWLINE \" ; $ n = 12 ; echo nthTermOfTheSeries ( $ n ) . \" STRNEWLINE \" ; $ n = 102 ; echo nthTermOfTheSeries ( $ n ) . \" STRNEWLINE \" ; $ n = 999 ; echo nthTermOfTheSeries ( $ n ) . \" STRNEWLINE \" ; $ n = 9999 ; echo nthTermOfTheSeries ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Cari harga kos dari harga jualan dan keuntungan atau kerugian yang diberikan | Fungsi untuk mengira harga kos dengan keuntungan; Formula yang diperlukan untuk mengira CP dengan keuntungan; Fungsi untuk mengira harga kos dengan kerugian; Formula yang diperlukan untuk mengira CP dengan kerugian; Kod pemacu", "code": "< ? php function CPwithProfit ( $ sellingPrice , $ profit ) { $ costPrice = ( $ sellingPrice * 100.0 ) / ( 100 + $ profit ) ; return $ costPrice ; } function CPwithLoss ( $ sellingPrice , $ loss ) { $ costPrice = ( $ sellingPrice * 100.0 ) / ( 100 - $ loss ) ; return $ costPrice ; } $ SP = 1020 ; $ profit = 20 ; echo ( \" Cost ▁ Price ▁ = ▁ \" ) ; echo ( CPwithProfit ( $ SP , $ profit ) ) ; echo ( \" STRNEWLINE \" ) ; $ SP = 900 ; $ loss = 10 ; echo ( \" Cost ▁ Price ▁ = ▁ \" ) ; echo ( CPwithLoss ( $ SP , $ loss ) ) ; echo ( \" STRNEWLINE \" ) ; $ SP = 42039 ; $ profit = 8 ; echo ( \" Cost ▁ Price ▁ = ▁ \" ) ; echo ( CPwithProfit ( $ SP , $ profit ) ) ; echo ( \" STRNEWLINE \" ) ; ? >"}
{"text": "Semak sama ada nombor bukan | Fungsi untuk mencari faktor utama dan periksa sama ada bentuk 4 k + 1 atau tidak; 2 adalah nombor perdana tetapi tidak dari bentuk 4 k + 1 jadi, terus membahagikan n dengan 2 hingga n dapat dibahagikan dengan 2; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); jika saya membahagikan n periksa sama ada saya bentuk 4 k + 1 atau tidak; Walaupun saya membahagikan n membahagikan n oleh i dan kemas kini n; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Fungsi ujian; Kod pemacu", "code": "< ? php function isNonHypotenuse ( $ n ) { while ( $ n % 2 == 0 ) { $ n = $ n / 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { if ( ( $ i - 1 ) % 4 == 0 ) return false ; while ( $ n % $ i == 0 ) { $ n = $ n / $ i ; } } } if ( $ n > 2 && ( $ n - 1 ) % 4 == 0 ) return false ; else return true ; } function test ( $ n ) { echo \" Testing ▁ for ▁ \" , $ n , \" ▁ : ▁ \" ; if ( isNonHypotenuse ( $ n ) ) echo \" YES \" . \" STRNEWLINE \" ; else echo \" NO \" . \" STRNEWLINE \" ; } $ n = 11 ; test ( $ n ) ; $ n = 10 ; test ( $ n ) ; ? >"}
{"text": "Cari n | Berfungsi untuk mengembalikan rentetan Nth dalam urutan yang diperlukan; Panjang rentetan yang dihasilkan; Indeks relatif; Rentetan awal panjang terdiri daripada semua A sejak senarai disusun; Tukar indeks relatif kepada bentuk binari dan tetapkan 0 = a dan 1 = b; Membalikkan dan mengembalikan rentetan; Kod pemacu", "code": "< ? php function obtain_str ( $ n ) { $ len = ( int ) ( log ( $ n + 1 ) / log ( 2 ) ) ; $ rel_ind = $ n + 1 - pow ( 2 , $ len ) ; $ i = 0 ; $ str = \" \" ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ str . = ' a ' ; } $ i = 0 ; while ( $ rel_ind > 0 ) { if ( $ rel_ind % 2 == 1 ) $ str [ $ i ] = ' b ' ; $ rel_ind = ( int ) ( $ rel_ind / 2 ) ; $ i ++ ; } return strrev ( $ str ) ; } $ n = 11 ; echo obtain_str ( $ n ) ; ? >"}
{"text": "Program untuk mencari istilah n Siri 0, 3/1, 8/3, 15/5. ... ... | Berfungsi untuk mengembalikan istilah ke siri yang diberikan; istilah n; Kod pemacu", "code": "< ? php function Nthterm ( $ n ) { $ numerator = ( pow ( $ n , 2 ) ) -1 ; $ denomenator = 2 * $ n - 3 ; echo $ numerator , \" / \" , $ denomenator ; return $ Tn ; } $ n = 3 ; Nthterm ( $ n ) ; ? >"}
{"text": "Jumlah setiap elemen yang dibangkitkan kepada (Prime | berfungsi untuk mengembalikan jumlah yang diperlukan; kod pemacu", "code": "< ? php function getSum ( $ arr , $ p ) { return count ( $ arr ) ; } $ arr = array ( 5 , 6 , 8 ) ; $ p = 7 ; echo ( getSum ( $ arr , $ p ) ) ; ? >"}
{"text": "Nombor Count sehingga kedua -dua persegi sempurna dan sempurna kiub | Fungsi untuk mengembalikan kiraan yang diperlukan; Kod pemacu; fungsi panggilan untuk mencetak jawapan yang diperlukan", "code": "< ? php function SquareCube ( $ N ) { $ cnt = 0 ; $ i = 1 ; while ( ( pow ( $ i , 6 ) ) <= $ N ) { ++ $ cnt ; ++ $ i ; } return $ cnt ; } $ N = 100000 ; echo SquareCube ( $ N ) ; ? >"}
{"text": "Jumlah integer sehingga n dengan digit unit yang diberikan | Berfungsi untuk mengembalikan jumlah yang diperlukan; Kod pemacu", "code": "< ? php function getSum ( $ n , $ d ) { $ sum = 0 ; while ( $ d <= $ n ) { $ sum += $ d ; $ d += 10 ; } return $ sum ; } $ n = 30 ; $ d = 3 ; echo ( getSum ( $ n , $ d ) ) ; ? >"}
{"text": "Merumuskan Siri SUM | Berfungsi untuk mengira dua kali ganda jumlah nombor semulajadi n pertama; Fungsi untuk mengira syarat penjumlahan siri SUM; Kod pemacu", "code": "< ? php function sum ( $ N ) { $ MOD = 1000000007 ; $ val = $ N * ( $ N + 1 ) ; $ val = $ val % $ MOD ; return $ val ; } function sumX ( $ N , $ M , $ K ) { $ MOD = 1000000007 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { $ N = sum ( $ K + $ N ) ; } $ N = $ N % $ MOD ; return $ N ; } $ N = 1 ; $ M = 2 ; $ K = 3 ; echo ( sumX ( $ N , $ M , $ K ) ) ; ? >"}
{"text": "Logaritma | Program PHP untuk mencari log (n) menggunakan rekursi; Memandu utama", "code": "< ? php function Log2n ( $ n ) { return ( $ n > 1 ) ? 1 + Log2n ( $ n / 2 ) : 0 ; } $ n = 32 ; echo Log2n ( $ n ) ; ? >"}
{"text": "Kemajuan Harmonik | Program PHP untuk memeriksa sama ada array yang diberikan boleh membentuk perkembangan harmonik; Cari timbal balik arr []; Selepas mencari timbal balik, periksa sama ada timbal balik dalam a. P. Untuk memeriksa a. P. , susun pertama array timbal balik, kemudian periksa perbezaan antara unsur -unsur berturut -turut; siri untuk memeriksa sama ada dalam h. P; Memeriksa siri adalah dalam h. P atau tidak", "code": "< ? php function checkIsHP ( $ arr ) { $ n = count ( $ arr ) ; if ( $ n == 1 ) return true ; $ rec = array ( ) ; for ( $ i = 0 ; $ i < count ( $ arr ) ; $ i ++ ) { $ a = 1 / $ arr [ $ i ] ; array_push ( $ rec , $ a ) ; } return ( $ rec ) ; sort ( $ rec ) ; $ d = $ rec [ 1 ] - $ rec [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ rec [ $ i ] - $ rec [ $ i - 1 ] != $ d ) return false ; return true ; } $ arr = array ( 1 / 5 , 1 / 10 , 1 / 15 , 1 / 20 , 1 / 25 ) ; if ( checkIsHP ( $ arr ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; ? >"}
{"text": "Aritmetik min | Cetakan n aritmetik antara a dan b. ; Kirakan perbezaan biasa (d); untuk mencari n aritmetik antara a dan b; Kod pemacu", "code": "< ? php function printAMeans ( $ A , $ B , $ N ) { $ d = ( $ B - $ A ) / ( $ N + 1 ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo ( $ A + $ i * $ d ) , \" ▁ \" ; } $ A = 20 ; $ B = 32 ; $ N = 5 ; printAMeans ( $ A , $ B , $ N ) ;"}
{"text": "Faktor Perdana | berfungsi untuk mencetak semua faktor utama nombor n tertentu; Cetak bilangan 2 s yang membahagikan n; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, cetak saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Kod pemacu", "code": "< ? php function primeFactors ( $ n ) { while ( $ n % 2 == 0 ) { echo 2 , \" ▁ \" ; $ n = $ n / 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { while ( $ n % $ i == 0 ) { echo $ i , \" \" ; $ n = $ n / $ i ; } } if ( $ n > 2 ) echo $ n , \" ▁ \" ; } $ n = 315 ; primeFactors ( $ n ) ; ? >"}
{"text": "Masa yang diambil oleh dua orang untuk bertemu di trek bulat | Pelaksanaan PHP pendekatan di atas; Berfungsi untuk mengembalikan masa apabila kedua -dua orang akan bertemu di titik permulaan; Masa untuk menutup 1 pusingan oleh kedua -duanya; Mencari LCM untuk mendapatkan titik mesyuarat; Berfungsi untuk mengembalikan masa apabila kedua -dua orang akan bertemu untuk kali pertama; Kod pemacu; Fungsi panggilan", "code": "< ? php function gcd ( $ a , $ b ) { return $ b ? gcd ( $ b , $ a % $ b ) : $ a ; } function startingPoint ( $ Length , $ Speed1 , $ Speed2 ) { $ result1 = 0 ; $ result2 = 0 ; $ time1 = $ Length / $ Speed1 ; $ time2 = $ Length / $ Speed2 ; $ result1 = gcd ( $ time1 , $ time2 ) ; $ result2 = $ time1 * $ time2 / ( $ result1 ) ; return $ result2 ; } function firstTime ( $ Length , $ Speed1 , $ Speed2 ) { $ result = 0 ; $ relativeSpeed = abs ( $ Speed1 - $ Speed2 ) ; $ result = ( ( float ) $ Length / $ relativeSpeed ) ; return $ result ; } $ L = 30 ; $ S1 = 5 ; $ S2 = 2 ; $ first_Time = firstTime ( $ L , $ S1 , $ S2 ) ; $ starting_Point = startingPoint ( $ L , $ S1 , $ S2 ) ; echo \" Met ▁ first ▁ time ▁ after ▁ \" . $ first_Time . \" ▁ hrs \" . \" STRNEWLINE \" ; echo \" Met ▁ at ▁ starting ▁ point ▁ after ▁ \" . $ starting_Point . \" ▁ hrs \" . \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika array mempunyai elemen yang sama dengan produk elemen yang tinggal | Fungsi untuk memeriksa sama ada array mempunyai elemen yang sama dengan produk semua elemen yang tinggal; Kirakan produk semua elemen; Kembali benar jika ada elemen tersebut dijumpai; Jika tiada elemen dijumpai; Kod pemacu", "code": "< ? php function CheckArray ( $ arr , $ n ) { $ prod = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ prod *= $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) if ( $ arr [ $ i ] == $ prod / $ arr [ $ i ] ) return true ; return false ; } $ arr = array ( 1 , 2 , 12 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; if ( CheckArray ( $ arr , $ n ) ) echo \" YES \" ; else echo \" NO \" ;"}
{"text": "Jumlah pembahagi biasa dua nombor a dan b | Cetak jumlah faktor biasa; jumlah faktor biasa; berulang dari 1 hingga minimum a dan b; Jika saya adalah faktor umum kedua -dua nombor; Kod pemacu; Cetak jumlah faktor biasa", "code": "< ? php function sum ( $ a , $ b ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= min ( $ a , $ b ) ; $ i ++ ) if ( $ a % $ i == 0 && $ b % $ i == 0 ) $ sum += $ i ; return $ sum ; } $ A = 10 ; $ B = 15 ; echo \" Sum = \" ? >"}
{"text": "Bilangan minimum pemotongan yang diperlukan untuk membuat segmen bulatan sama bersaiz | Fungsi rekursif untuk mengembalikan GCD dua NOS; Fungsi untuk mencari bilangan minimum pemotongan tambahan yang diperlukan untuk membuat segmen bulatan adalah sama bersaiz; Susun array; Nilai GCD awal; Termasuk segmen terakhir; Kod pemacu", "code": "< ? php function findgcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return findgcd ( $ b , $ a % $ b ) ; } function minimumCuts ( $ a , $ n ) { sort ( $ a ) ; $ gcd = $ a [ 1 ] - $ a [ 0 ] ; $ s = $ gcd ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ gcd = findgcd ( $ gcd , $ a [ $ i ] - $ a [ $ i - 1 ] ) ; $ s += $ a [ $ i ] - $ a [ $ i - 1 ] ; } if ( 360 - $ s > 0 ) $ gcd = findgcd ( $ gcd , 360 - $ s ) ; return ( 360 / $ gcd ) - $ n ; } $ arr = array ( 30 , 60 , 180 ) ; $ n = sizeof ( $ arr ) ; echo ( minimumCuts ( $ arr , $ n ) ) ; ? >"}
{"text": "Cari harga jualan dari peratusan keuntungan dan kos yang diberikan | Fungsi untuk mengira harga jualan; Setara dengan peratusan keuntungan; Cari harga jualan; mengembalikan harga jualan yang dikira; Dapatkan CP dan keuntungan %; Mencetak nilai yang dikembalikan", "code": "< ? php function SellingPrice ( $ CP , $ PP ) { $ P_decimal = 1 + ( $ PP / 100 ) ; $ res = $ P_decimal * $ CP ; return $ res ; } $ C = 720 ; $ P = 13 ; echo SellingPrice ( $ C , $ P ) ; ? >"}
{"text": "Produk semua nombor komposit dalam array | Fungsi yang mengembalikan produk semua nombor komposit; Cari nilai maksimum dalam array; Gunakan ayak untuk mencari semua nombor perdana kurang daripada atau sama dengan max_val Buat array boolean \"Perdana [0 ... N]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Tetapkan 0 dan 1 sebagai prima kerana mereka tidak perlu dikira sebagai nombor komposit; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cari produk semua nombor komposit dalam ARR []; Kod pemacu", "code": "< ? php function compositeProduct ( $ arr , $ n ) { $ max_val = max ( $ arr ) ; $ prime = array_fill ( 0 , $ max_val + 1 , true ) ; $ prime [ 0 ] = true ; $ prime [ 1 ] = true ; for ( $ p = 2 ; $ p * $ p <= $ max_val ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ max_val ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( ! $ prime [ $ arr [ $ i ] ] ) { $ product *= $ arr [ $ i ] ; } return $ product ; } $ arr = array ( 2 , 3 , 4 , 5 , 6 , 7 ) ; $ n = count ( $ arr ) ; echo compositeProduct ( $ arr , $ n ) ; ? >"}
{"text": "Ujian Primal untuk jumlah digit di tempat ganjil nombor | Fungsi yang mengembalikan jumlah digit di tempat yang ganjil; Fungsi yang mengembalikan benar jika nombor itu adalah Perdana lain palsu; Kes sudut; Keadaan ini diperiksa supaya kita dapat melangkaui lima nombor tengah dalam gelung di bawah; Kod pemacu; Dapatkan jumlah digit di tempat yang ganjil", "code": "< ? php function sum_odd ( $ n ) { $ sum = 0 ; $ pos = 1 ; while ( $ n ) { if ( $ pos % 2 == 1 ) $ sum += $ n % 10 ; $ n = ( int ) ( $ n / 10 ) ; $ pos ++ ; } return $ sum ; } function check_prime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = ( $ i + 6 ) ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } $ n = 223 ; $ sum = sum_odd ( $ n ) ; if ( check_prime ( $ sum ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Cari jumlah yang akan ditambah untuk mencapai nisbah sasaran dalam campuran yang diberikan | Program PHP untuk mencari jumlah air yang akan ditambah untuk mencapai nisbah sasaran yang diberikan. ; Kod pemacu", "code": "< ? php function findAmount ( $ X , $ W , $ Y ) { return ( $ X * ( $ Y - $ W ) ) / ( 100 - $ Y ) ; } $ X = 100 ; $ W = 50 ; $ Y = 60 ; echo \" Water ▁ to ▁ be ▁ added ▁ = ▁ \" . findAmount ( $ X , $ W , $ Y ) ; ? >"}
{"text": "Semak jika nombor adalah nombor misteri | Cari terbalik Num x. ; Sekiranya dijumpai mencetak pasangan, kembali", "code": "< ? php function reverseNum ( $ x ) { $ s = ( string ) $ x ; $ s = strrev ( $ s ) ; $ rev = ( int ) $ s ; return $ rev ; } function isMysteryNumber ( $ n ) { for ( $ i = 1 ; $ i <= $ n / 2 ; $ i ++ ) { $ j = reverseNum ( $ i ) ; if ( $ i + $ j == $ n ) { echo $ i . \" ▁ \" . $ j ; return true ; } } echo \" Not ▁ a ▁ Mystery ▁ Number \" ; return false ; } $ n = 121 ; isMysteryNumber ( $ n ) ; return 0 ; ? >"}
{"text": "Gantikan setiap elemen array dengan produk semua elemen lain | Program PHP untuk menggantikan setiap elemen dengan produk semua elemen lain; Kirakan produk semua elemen; Menggantikan setiap produk elemen dari semua elemen lain; Kod pemacu; Cetak array yang diubahsuai.", "code": "< ? php function ReplaceElements ( $ arr , $ n ) { $ prod = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ prod *= $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ arr [ $ i ] = ( int ) ( $ prod / $ arr [ $ i ] ) ; } return $ arr ; } $ arr = array ( 2 , 3 , 3 , 5 , 7 ) ; $ n = sizeof ( $ arr ) ; $ arr1 = ReplaceElements ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { echo $ arr1 [ $ i ] . \" \" ; } ? >"}
{"text": "Semak jika ada pasangan dalam julat yang diberikan dengan GCD boleh dibahagikan dengan k | berfungsi untuk mengira nombor yang mungkin; Jika saya dibahagikan dengan k; jika kiraan nombor tersebut lebih besar daripada satu; Kod pemacu", "code": "< ? php function Check_is_possible ( $ l , $ r , $ k ) { $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( $ i % $ k == 0 ) $ count ++ ; } return ( $ count > 1 ) ; } $ l = 4 ; $ r = 12 ; $ k = 5 ; if ( Check_is_possible ( $ l , $ r , $ k ) ) echo \" YES STRNEWLINE \" ; else echo \" NO STRNEWLINE \" ; ? >"}
{"text": "Jumlah nombor semulajadi N yang pertama yang boleh dibahagikan dengan 2 dan 7 | Berfungsi untuk mengira jumlah nombor yang boleh dibahagi dengan 2 atau 7; Kod pemacu", "code": "< ? php function sum ( $ N ) { $ S1 = ( int ) ( ( $ N / 2 ) ) * ( int ) ( 2 * 2 + ( int ) ( $ N / 2 - 1 ) * 2 ) / 2 ; $ S2 = ( int ) ( ( $ N / 7 ) ) * ( int ) ( 2 * 7 + ( int ) ( $ N / 7 - 1 ) * 7 ) / 2 ; $ S3 = ( int ) ( ( $ N / 14 ) ) * ( int ) ( 2 * 14 + ( int ) ( $ N / 14 - 1 ) * 14 ) / 2 ; return ( $ S1 + $ S2 ) - $ S3 ; } $ N = 20 ; echo sum ( $ N ) ;"}
{"text": "Cara untuk mewarnai pokok miring supaya ibu bapa dan kanak -kanak mempunyai warna yang berbeza | Fast_way adalah kaedah rekursif untuk mengira kuasa; Kod pemacu", "code": "< ? php function fastPow ( $ N , $ K ) { if ( $ K == 0 ) return 1 ; $ temp = fastPow ( $ N , $ K / 2 ) ; if ( $ K % 2 == 0 ) return $ temp * $ temp ; else return $ N * $ temp * $ temp ; } function countWays ( $ N , $ K ) { return $ K * fastPow ( $ K - 1 , $ N - 1 ) ; } $ N = 3 ; $ K = 3 ; echo countWays ( $ N , $ K ) ; ? >"}
{"text": "Jumlah istilah nth siri Fibonacci yang diubahsuai yang dibuat oleh setiap sepasang dua tatasusunan | Program PHP untuk mencari jumlah terma fibonacci seperti siri yang dibentuk menggunakan dua syarat pertama dua tatasusunan. ; Jika jumlah istilah pertama diperlukan; Jika jumlah istilah kedua diperlukan; Siri Fibonacci digunakan untuk mencari istilah ke setiap siri; kerana setiap istilah b [i] muncul m kali dan setiap istilah [i] juga muncul m kali; m adalah saiz array", "code": "< ? php function sumNth ( & $ A , & $ B , & $ m , & $ n ) { $ res = 0 ; if ( $ n == 1 ) { for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ res = $ res + $ A [ $ i ] ; } else if ( $ n == 2 ) { for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ res = $ res + $ B [ $ i ] * $ m ; } else { $ f = array ( ) ; $ f [ 0 ] = 0 ; $ f [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ f [ $ i ] = $ f [ $ i - 1 ] + $ f [ $ i - 2 ] ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ res = $ res + ( $ m * ( $ B [ $ i ] * $ f [ $ n - 1 ] ) ) + ( $ m * ( $ A [ $ i ] * $ f [ $ n - 2 ] ) ) ; } } return $ res ; } $ A = array ( 1 , 2 , 3 ) ; $ B = array ( 4 , 5 , 6 ) ; $ n = 3 ; $ m = sizeof ( $ A ) ; echo ( sumNth ( $ A , $ B , $ m , $ n ) ) ; ? >"}
{"text": "Teka -teki | Jarak minimum untuk kadal | sisi kiub; memahami dari rajah; memahami dari rajah; jarak minimum", "code": "< ? php $ a = 5 ; $ AC = $ a ; $ CE = 2 * $ a ; $ shortestDistance = ( double ) ( sqrt ( $ AC * $ AC + $ CE * $ CE ) ) ; echo $ shortestDistance . \" STRNEWLINE \" ; ? >"}
{"text": "Cari Jumlah Siri 1 ^ 2 | Fungsi untuk mencari jumlah siri; Jika n juga; Jika n adalah ganjil; mengembalikan hasilnya; Dapatkan n; Cari jumlahnya; Dapatkan n; Cari jumlahnya", "code": "< ? php function sum_of_series ( $ n ) { $ result = 0 ; if ( $ n % 2 == 0 ) { $ result = - ( $ n * ( $ n + 1 ) ) / 2 ; } else { $ result = ( $ n * ( $ n + 1 ) ) / 2 ; } return $ result ; } $ n = 3 ; echo sum_of_series ( $ n ) ; echo ( \" STRNEWLINE \" ) ; $ n = 10 ; echo sum_of_series ( $ n ) ; echo ( \" STRNEWLINE \" ) ; ? >"}
{"text": "Semak sama ada nombor yang diberikan adalah sepupu utama atau tidak | Fungsi untuk memeriksa sama ada nombor yang diberikan adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Pulangan benar jika N1 dan N2 adalah prima sepupu; Periksa sama ada nombor yang diberikan berbeza dengan 4 atau tidak; Semak sama ada kedua -dua nombor adalah perdana atau tidak; Dapatkan nombor 2; Periksa nombor untuk sepupu perdana", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function isCousinPrime ( $ n1 , $ n2 ) { if ( abs ( $ n1 - $ n2 ) != 4 ) return false ; else return ( isPrime ( $ n1 ) && isPrime ( $ n2 ) ) ; } $ n1 = 7 ; $ n2 = 11 ; if ( isCousinPrime ( $ n1 , $ n2 ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Nombor Thabit | Fungsi utiliti untuk memeriksa kuasa dua; fungsi untuk memeriksa sama ada nombor yang diberikan adalah nombor Thabit; Tambah 1 ke nombor; Bahagikan nombor dengan 3; Semak sama ada nombor yang diberikan adalah kuasa 2; Kod pemacu; Semak jika nombor adalah nombor Thabit", "code": "< ? php function isPowerOfTwo ( $ n ) { return ( $ n && ! ( $ n & ( $ n - 1 ) ) ) ; } function isThabitNumber ( $ n ) { $ n = $ n + 1 ; if ( $ n % 3 == 0 ) $ n = $ n / 3 ; else return false ; if ( isPowerOfTwo ( $ n ) ) return true ; else return false ; } $ n = 47 ; if ( isThabitNumber ( $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Integer terkecil untuk dimasukkan untuk mempunyai jumlah yang sama | Fungsi untuk mencari nilai minimum yang akan ditambah; Pembolehubah untuk menyimpan keseluruhan jumlah array; Pembolehubah untuk menyimpan jumlah Subarray1 dan Subarray 2; nilai minimum yang akan ditambah; Melintasi array; Jumlah kedua -dua bahagian; Kirakan nombor minimum yang akan ditambah; Kod pemacu; Panjang array", "code": "< ? php function findMinEqualSums ( $ a , $ N ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ sum += $ a [ $ i ] ; } $ sum1 = 0 ; $ sum2 = 0 ; $ min = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ sum1 += $ a [ $ i ] ; $ sum2 = $ sum - $ sum1 ; if ( abs ( $ sum1 - $ sum2 ) < $ min ) { $ min = abs ( $ sum1 - $ sum2 ) ; } if ( $ min == 0 ) { break ; } } return $ min ; } $ a = array ( 3 , 2 , 1 , 5 , 7 , 8 ) ; $ N = count ( $ a ) ; echo ( findMinEqualSums ( $ a , $ N ) ) ; ? >"}
{"text": "Cari jumlah digit dalam (n!) N | Fungsi untuk mencari jumlah digit dalam (n!) ^ N; Mencari x; Mengira n * x; Lantai (n * x) + 1 kembali ceil ($ jumlah); bersamaan dengan lantai (jumlah) + 1; Kod pemacu", "code": "< ? php function CountDigits ( $ n ) { if ( $ n == 1 ) return 1 ; $ sum = 0 ; for ( $ i = 2 ; $ i <= $ n ; ++ $ i ) { $ sum += log ( $ i ) / log ( 10 ) ; } $ sum *= $ n ; } $ N = 5 ; echo CountDigits ( $ N ) ; ? >"}
{"text": "Cari nilai max (f (x)) | Pelaksanaan PHP pendekatan di atas; Fungsi untuk mengira nilai; membentuk tatasusunan jumlah awalan; Mengambil pertanyaan; Mencari jumlah dalam julat L ke r dalam array A; Mencari jumlah dalam julat L ke r dalam array B; Mencari nilai maksimum fungsi; Mencari nilai min fungsi; Kod pemacu", "code": "< ? php $ MAX = 200006 ; $ CONS = 32766 ; function calc ( $ a , $ b , $ lr , $ q , $ n ) { global $ MAX ; global $ CONS ; $ M ; $ m ; $ i ; $ j ; $ k ; $ l ; $ r ; $ suma ; $ sumb ; $ cc ; $ cc = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { $ a [ $ i + 1 ] += $ a [ $ i ] ; $ b [ $ i + 1 ] += $ b [ $ i ] ; } while ( $ q -- ) { $ l = $ lr [ $ cc ++ ] ; $ r = $ lr [ $ cc ++ ] ; $ l -= 2 ; $ r -= 1 ; $ suma = $ a [ $ r ] ; $ sumb = $ b [ $ r ] ; if ( $ l >= 0 ) { $ suma -= $ a [ $ l ] ; $ sumb -= $ b [ $ l ] ; } $ M = max ( $ CONS * $ suma + $ CONS * $ sumb , - $ CONS * $ suma - $ CONS * $ sumb ) ; $ M = max ( $ M , max ( $ CONS * $ suma - $ CONS * $ sumb , - $ CONS * $ suma + $ CONS * $ sumb ) ) ; $ m = min ( $ CONS * $ suma + $ CONS * $ sumb , - $ CONS * $ suma - $ CONS * $ sumb ) ; $ m = min ( $ m , min ( $ CONS * $ suma - $ CONS * $ sumb , - $ CONS * $ suma + $ CONS * $ sumb ) ) ; echo ( $ M - $ m ) , \" STRNEWLINE \" ; } } $ n = 5 ; $ q = 2 ; $ a = array ( 0 , 7 , 3 , 4 , 5 ) ; $ b = array ( 0 , 3 , 1 , 2 , 3 ) ; $ lr [ 0 ] = 1 ; $ lr [ 1 ] = 1 ; $ lr [ 2 ] = 1 ; $ lr [ 3 ] = 3 ; calc ( $ a , $ b , $ lr , $ q , $ n ) ; ? >"}
{"text": "Program untuk mencari nombor n Siri 2, 10, 24, 44, 70. .... | berfungsi untuk mengembalikan istilah siri; Mengambil n sebagai 4; Dapatkan istilah n", "code": "< ? php function NthTerm ( $ n ) { $ mod = 1000000009 ; $ x = ( 3 * $ n * $ n ) % $ mod ; return ( $ x - $ n + $ mod ) % $ mod ; } let N = 4 ; echo NthTerm ( $ N ) ; ? >"}
{"text": "Jumlah nombor semulajadi n pertama dengan mengambil kuasa 2 sebagai nombor negatif | untuk menyimpan kuasa 2; untuk menyimpan anggapan kuasa 2; fungsi untuk mencari kuasa 2; untuk menyimpan kuasa 2; untuk menyimpan jumlah pra; Berfungsi untuk mencari jumlah; Jumlah kedai pertama N pertama. ; Cari nombor pertama yang lebih besar daripada nombor yang diberikan kemudian tolak dua kali ganda ini dari jawapan; panggilan fungsi; panggilan fungsi", "code": "< ? php $ power = array_fill ( 0 , 31 , 0 ) ; $ pre = array_fill ( 0 , 31 , 0 ) ; function PowerOfTwo ( ) { global $ power , $ pre ; $ x = 1 ; for ( $ i = 0 ; $ i < 31 ; $ i ++ ) { $ power [ $ i ] = $ x ; $ x *= 2 ; } $ pre [ 0 ] = 1 ; for ( $ i = 1 ; $ i < 31 ; $ i ++ ) $ pre [ $ i ] = $ pre [ $ i - 1 ] + $ power [ $ i ] ; } function Sum ( $ n ) { global $ power , $ pre ; $ ans = $ n * ( $ n + 1 ) / 2 ; for ( $ i = 0 ; $ i < 31 ; $ i ++ ) if ( $ power [ $ i ] > $ n ) { $ ans -= 2 * $ pre [ $ i - 1 ] ; break ; } return $ ans ; } PowerOfTwo ( ) ; $ n = 4 ; print ( Sum ( $ n ) ) ; ? >"}
{"text": "Semak jika nombor adalah kuartan utama atau tidak | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Kod pemacu; Periksa sama ada nombor adalah perdana dan borang 16 * n + 1", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) { if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) { return false ; } } return true ; } $ n = 17 ; if ( isPrime ( $ n ) && ( $ n % 16 == 1 ) ) { echo \" YES \" ; } else { echo \" NO \" ; }"}
{"text": "Cetak nombor dengan ketat kurang daripada nombor tertentu supaya semua digitnya berbeza. | Berfungsi untuk mencari nombor yang kurang daripada n sedemikian rupa sehingga semua digitnya berbeza; gelung melalui nombor kurang daripada n; memulakan array hash; mewujudkan salinan i; memulakan pembolehubah untuk membandingkan panjang digit; Mengira kekerapan digit; Memeriksa jika setiap digit hadir sekali; Kod pemacu", "code": "< ? php function findNumber ( $ n ) { for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ count = array_fill ( 0 , 10 , 0 ) ; $ x = $ i ; $ count1 = 0 ; $ count2 = 0 ; while ( $ x ) { $ count [ $ x % 10 ] ++ ; $ x = ( int ) ( $ x / 10 ) ; $ count1 ++ ; } for ( $ j = 0 ; $ j < 10 ; $ j ++ ) { if ( $ count [ $ j ] == 1 ) $ count2 ++ ; } if ( $ count1 == $ count2 ) return $ i ; } } $ n = 8490 ; echo findNumber ( $ n ) ; ? >"}
{"text": "Cari dua nombor perdana yang berbeza dengan produk yang diberikan | Berfungsi untuk menjana semua nombor perdana kurang daripada n; Inisialisasi semua penyertaan array Boolean sebagai benar. Nilai dalam Isprime [i] akhirnya akan palsu jika saya bukan perdana, lain -lain bool isprime [n + 1]; ; Jika Isprime [p] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Berfungsi untuk mencetak pasangan utama dengan produk yang diberikan; Menjana prima menggunakan ayak; Melintasi semua nombor untuk mencari pasangan pertama; Kod pemacu", "code": "< ? php function SieveOfEratosthenes ( $ n , & $ isPrime ) { $ isPrime [ 0 ] = false ; $ isPrime [ 1 ] = false ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ isPrime [ $ i ] = true ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ isPrime [ $ p ] ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ isPrime [ $ i ] = false ; } } } function findPrimePair ( $ n ) { $ flag = 0 ; $ isPrime = array_fill ( 0 , ( $ n + 1 ) , false ) ; SieveOfEratosthenes ( $ n , $ isPrime ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ x = ( int ) ( $ n / $ i ) ; if ( $ isPrime [ $ i ] && $ isPrime [ $ x ] and $ x != $ i and $ x * $ i == $ n ) { echo $ i . \" ▁ \" . $ x ; $ flag = 1 ; return ; } } if ( ! $ flag ) echo \" No ▁ such ▁ pair ▁ found \" ; } $ n = 39 ; findPrimePair ( $ n ) ; ? >"}
{"text": "Program untuk mencari nisbah biasa tiga nombor | Fungsi utiliti; Fungsi untuk mencetak A: B: C; Untuk mencetak bahagian yang diberikan dalam bentuk yang paling mudah. ; Dapatkan nisbah mendapatkan nisbah A: B1; Dapatkan nisbah b2: c; Cari nisbah a: b: c", "code": "< ? php function __gcd ( $ a , $ b ) { return $ b == 0 ? $ a : __gcd ( $ b , $ a % $ b ) ; } function solveProportion ( $ a , $ b1 , $ b2 , $ c ) { $ A = $ a * $ b2 ; $ B = $ b1 * $ b2 ; $ C = $ b1 * $ c ; $ gcd = __gcd ( __gcd ( $ A , $ B ) , $ C ) ; echo ( $ A / $ gcd ) . \" : \" . ( $ B / $ gcd ) . \" : \" . ( $ C / $ gcd ) ; } $ a = 3 ; $ b1 = 4 ; $ b2 = 8 ; $ c = 9 ; solveProportion ( $ a , $ b1 , $ b2 , $ c ) ; ? >"}
{"text": "Bilangan pembahagi nombor n yang dibahagikan dengan k | Berfungsi untuk mengira bilangan pembahagi n yang boleh dibahagikan oleh k; Pembolehubah untuk menyimpan kiraan pembahagi; Melintasi 1 hingga n; Meningkatkan kiraan jika kedua -dua keadaan berpuas hati; Kod pemacu", "code": "< ? php function countDivisors ( $ n , $ k ) { $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 && $ i % $ k == 0 ) { $ count ++ ; } } return $ count ; } $ n = 12 ; $ k = 3 ; echo countDivisors ( $ n , $ k ) ;"}
{"text": "Kirakan kelantangan dan kawasan permukaan kerucut | Fungsi untuk mengira jumlah kon; Berfungsi untuk mengira kawasan permukaan kon; Kod pemacu; Nilai percetakan kelantangan dan kawasan permukaan", "code": "< ? php function volume ( $ r , $ h ) { $ pi = 3.14159 ; return ( 1 / 3 ) * $ pi * $ r * $ r * $ h ; } function surface_area ( $ r , $ s ) { $ pi = 3.14159 ; return $ pi * $ r * $ s + $ pi * $ r * $ r ; } $ radius = 5 ; $ slant_height = 13 ; $ height = 12 ; echo ( \" Volume ▁ Of ▁ Cone ▁ : ▁ \" ) ; echo ( volume ( $ radius , $ height ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Surface ▁ Area ▁ Of ▁ Cone ▁ : ▁ \" ) ; echo ( surface_area ( $ radius , $ slant_height ) ) ; ? >"}
{"text": "Program untuk mencari istilah n Siri 0, 14, 40, 78, 124, ... | hitung jumlah siri siri siri; mengembalikan jumlah akhir; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return 6 * pow ( $ n , 2 ) - 4 * $ n - 2 ; } $ N = 4 ; echo nthTerm ( $ N ) ;"}
{"text": "Program untuk mencari istilah n Siri 5, 10, 17, 26, 37, 50, 65, 82, ... | mengira istilah siri nth; mengembalikan jumlah akhir; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return pow ( $ n , 2 ) + 2 * $ n + 2 ; } $ N = 4 ; echo nthTerm ( $ N ) ;"}
{"text": "Cari Tempoh N Hubungan Berulang yang diberikan | fungsi untuk mengembalikan nilai yang diperlukan; Dapatkan jawapannya; Kembalikan jawapannya; Dapatkan nilai n; fungsi panggilan untuk mencetak hasil", "code": "< ? php function sum ( $ n ) { $ ans = ( $ n * ( $ n - 1 ) ) / 2 ; return $ ans ; } $ n = 5 ; echo sum ( $ n ) ; ? >"}
{"text": "Program untuk mencari istilah n Siri 3, 12, 29, 54, 87, ... | mengira istilah siri nth; Kembali istilah n; pengisytiharan bilangan istilah; Dapatkan istilah n", "code": "< ? php function getNthTerm ( $ N ) { return 4 * pow ( $ N , 2 ) - 3 * $ N + 2 ; } $ N = 10 ; echo getNthTerm ( $ N ) ; ? >"}
{"text": "Cari jumlah produk nombor dalam siri yang diberikan | fungsi untuk mengira (a ^ b) % p; Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; berfungsi untuk mengembalikan jawapan yang diperlukan; Modulo songsang penyebut; mengira bahagian pengulas; Mengira T! ; mengumpulkan jawapan terakhir; Kod pemacu; fungsi panggilan untuk mencetak jumlah yang diperlukan", "code": "< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function sumProd ( $ n , $ t ) { $ MOD = 1000000007 ; $ dino = power ( $ t + 1 , $ MOD - 2 , $ MOD ) ; $ ans = 1 ; for ( $ i = $ n + $ t + 1 ; $ i > $ n ; -- $ i ) $ ans = ( $ ans % $ MOD * $ i % $ MOD ) % $ MOD ; $ tfact = 1 ; for ( $ i = 1 ; $ i <= $ t ; ++ $ i ) $ tfact = ( $ tfact * $ i ) % $ MOD ; $ ans = $ ans * $ dino - $ tfact + $ MOD ; return $ ans % $ MOD ; } $ n = 3 ; $ t = 2 ; echo sumProd ( $ n , $ t ) ; ? >"}
{"text": "Cari jumlah Siri 3, 7, 13, 21, 31 ... | Fungsi untuk mengira jumlah; Kembali jumlah; Kod pemacu", "code": "< ? php function findSum ( $ n ) { return ( $ n * ( pow ( $ n , 2 ) + 3 * $ n + 5 ) ) / 3 ; } $ n = 25 ; echo findSum ( $ n ) ; ? >"}
{"text": "Pemain minimum diperlukan untuk memenangi permainan | fungsi untuk mengira (a ^ b) % (10 ^ 9 + 7). ; berfungsi untuk mencari pemain minimum yang diperlukan; Pengkomputeran Nenomenator; pengkomputeran modulo songsang penyebut; hasil akhir; Kod pemacu", "code": "< ? php function power ( $ a , $ b ) { $ mod = 1000000007 ; $ res = 1 ; while ( $ b ) { if ( $ b & 1 ) { $ res *= $ a ; $ res %= $ mod ; } $ b /= 2 ; $ a *= $ a ; $ a %= $ mod ; } return $ res ; } function minPlayer ( $ n , $ k ) { $ mod = 1000000007 ; $ num = ( ( power ( $ k , $ n ) - 1 ) + $ mod ) % $ mod ; $ den = ( power ( $ k - 1 , $ mod - 2 ) + $ mod ) % $ mod ; $ ans = ( ( ( $ num * $ den ) % $ mod ) * $ k ) % $ mod ; return $ ans ; } $ n = 3 ; $ k = 3 ; echo minPlayer ( $ n , $ k ) ; ? >"}
{"text": "Jumlah faktor nombor menggunakan pemfaktoran utama | Menggunakan Sieveoferatosthenes untuk mencari faktor utama terkecil semua nombor. Sebagai contoh, jika n adalah 10, s [2] = s [4] = s [6] = s [10] = 2 S [3] = S [9] = 3 S [5] = 5 S [7] = 7; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaan di dalamnya sebagai palsu. ; Memulakan faktor terkecil sama dengan 2 untuk semua nombor walaupun; Untuk nombor ganjil kurang kemudian sama dengan n; S (i) untuk perdana adalah nombor itu sendiri; Untuk semua gandaan nombor perdana semasa; Saya adalah faktor utama terkecil untuk nombor \"i * j\". ; Fungsi untuk mencari jumlah semua faktor utama; Mengisytiharkan array untuk menyimpan faktor utama terkecil saya di indeks i - th; Mengisi nilai dalam S [] menggunakan ayak; Faktor utama semasa n; Kuasa faktor utama semasa; N sekarang n / s [n]. Jika New N als mempunyai faktor utama terkecil sebagai currfactor, kuasa kenaikan; Mengemas kini faktor utama semasa sebagai S [n] dan memulakan kuasa faktor sebagai 1 .; Kod pemacu", "code": "< ? php function sieveOfEratosthenes ( $ N , & $ s ) { $ prime = array_fill ( 0 , $ N + 1 , false ) ; for ( $ i = 2 ; $ i <= $ N ; $ i += 2 ) $ s [ $ i ] = 2 ; for ( $ i = 3 ; $ i <= $ N ; $ i += 2 ) { if ( $ prime [ $ i ] == false ) { $ s [ $ i ] = $ i ; for ( $ j = $ i ; $ j * $ i <= $ N ; $ j += 2 ) { if ( $ prime [ $ i * $ j ] == false ) { $ prime [ $ i * $ j ] = true ; $ s [ $ i * $ j ] = $ i ; } } } } } function findSum ( $ N ) { $ s = array_fill ( 0 , $ N + 1 , 0 ) ; $ ans = 1 ; sieveOfEratosthenes ( $ N , $ s ) ; $ currFactor = $ s [ $ N ] ; $ power = 1 ; while ( $ N > 1 ) { $ N /= $ s [ $ N ] ; if ( $ currFactor == $ s [ $ N ] ) { $ power ++ ; continue ; } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ power ; $ i ++ ) $ sum += ( int ) pow ( $ currFactor , $ i ) ; $ ans *= $ sum ; $ currFactor = $ s [ $ N ] ; $ power = 1 ; } return $ ans ; } $ n = 12 ; echo \" Sum ▁ of ▁ the ▁ factors ▁ is ▁ : ▁ \" ; echo findSum ( $ n ) ; ? >"}
{"text": "Cari gandaan 2 atau 3 atau 5 kurang daripada atau sama dengan N | Fungsi kiraan bit; Berfungsi untuk mengira bilangan gandaan 2 atau 3 atau 5 kurang daripada atau sama dengan n; Seperti yang kita perlu periksa divisibility dengan tiga nombor, jadi kita boleh melaksanakan bit masking; Kami periksa sama ada bit jth ditetapkan atau tidak, jika bit jth ditetapkan, hanya kalikan untuk prod; Semak bit set; Semak pelbagai produk; Kod pemacu", "code": "< ? php function popcount ( $ value ) { $ count = 0 ; while ( $ value ) { $ count += ( $ value & 1 ) ; $ value = $ value >> 1 ; } return $ count ; } function countMultiples ( $ n ) { $ multiple = array ( 2 , 3 , 5 ) ; $ count = 0 ; $ mask = pow ( 2 , 3 ) ; for ( $ i = 1 ; $ i < $ mask ; $ i ++ ) { $ prod = 1 ; for ( $ j = 0 ; $ j < 3 ; $ j ++ ) { if ( $ i & 1 << $ j ) $ prod = $ prod * $ multiple [ $ j ] ; } if ( popcount ( $ i ) % 2 == 1 ) $ count = $ count + ( int ) ( $ n / $ prod ) ; else $ count = $ count - ( int ) ( $ n / $ prod ) ; } return $ count ; } $ n = 10 ; echo countMultiples ( $ n ) ; ? >"}
{"text": "Nilai minimum n sedemikian rupa sehingga xor dari 1 hingga n adalah sama dengan k | Fungsi untuk mencari nilai n; pembolehubah untuk menyimpan hasilnya; pengendalian kes untuk '0'; pengendalian kes untuk '1'; Apabila nombor dibahagikan sepenuhnya dengan 4 maka minimum 'x' akan 'k'; Apabila bilangan dibahagikan dengan 4 memberikan 3 sebagai selebihnya maka minimum 'x' akan 'k - 1'; lain tidak mungkin untuk mendapatkan k untuk sebarang nilai x; Biarkan nombor yang diberikan 7", "code": "< ? php function findN ( $ k ) { $ ans ; if ( $ k == 0 ) $ ans = 3 ; if ( $ k == 1 ) $ ans = 1 ; else if ( $ k % 4 == 0 ) $ ans = $ k ; else if ( $ k % 4 == 3 ) $ ans = $ k - 1 ; else $ ans = -1 ; return $ ans ; } $ k = 7 ; $ res = findN ( $ k ) ; if ( $ res == -1 ) echo \" Not ▁ possible \" ; else echo $ res ; ? >"}
{"text": "Permutasi untuk mengatur N orang di sekitar meja bulat | Berfungsi untuk mencari tidak. daripada permutasi; Kod pemacu", "code": "< ? php function Circular ( $ n ) { $ Result = 1 ; while ( $ n > 0 ) { $ Result = $ Result * $ n ; $ n -- ; } return $ Result ; } $ n = 4 ; echo Circular ( $ n - 1 ) ; ? >"}
{"text": "Masa minimum diperlukan untuk menyelesaikan kerja oleh orang N Bersama | Berfungsi untuk mengira masa; Kod pemacu", "code": "< ? php function calTime ( & $ arr , $ n ) { $ work = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ work += 1 / $ arr [ $ i ] ; return 1 / $ work ; } $ arr = array ( 6.0 , 3.0 , 4.0 ) ; $ n = sizeof ( $ arr ) ; echo calTime ( $ arr , $ n ) ; echo \" ▁ Hours \" ;"}
{"text": "Cari kembar terbesar dalam julat yang diberikan | Berfungsi untuk mencari kembar; Buat array Boolean \"Perdana [0 ... tinggi]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Cari kembar terkecil; Jika p tidak ditandakan, maka ia adalah perdana; Kemas kini semua gandaan P; Sekarang cetak kembar terbesar dalam julat; Program Pemandu", "code": "< ? php function printTwins ( $ low , $ high ) { $ prime [ $ high + 1 ] = array ( ) ; $ twin = false ; $ prime = array_fill ( 0 , ( $ high + 1 ) , true ) ; $ prime [ 0 ] = $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p <= floor ( sqrt ( $ high ) ) + 1 ; $ p ++ ) { if ( $ prime [ $ p ] ) { for ( $ i = $ p * 2 ; $ i <= $ high ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ i = $ high ; $ i >= $ low ; $ i -- ) { if ( $ prime [ $ i ] && ( $ i - 2 >= $ low && $ prime [ $ i - 2 ] == true ) ) { echo \" Largest ▁ twins ▁ in ▁ given ▁ range : ▁ ( \" , $ i - 2 , \" , ▁ \" , $ i , \" ) \" ; $ twin = true ; break ; } } if ( $ twin == false ) echo \" No ▁ such ▁ pair ▁ exists \" ; } printTwins ( 10 , 100 ) ; ? >"}
{"text": "Pelengkap nombor dengan mana -mana asas b | Fungsi untuk mencari (b - 1) pelengkap; Hitung bilangan digit dalam nombor yang diberikan; Digit terbesar dalam sistem nombor dengan asas B; Nombor terbesar dalam sistem nombor dengan asas B; pelengkap pulangan; Berfungsi untuk mencari pelengkap B; B 's ~ complement = (b - 1) pelengkap + 1; Kod pemacu", "code": "< ? php function prevComplement ( $ n , $ b ) { $ maxNum = 0 ; $ digits = 0 ; $ num = $ n ; while ( ( int ) $ n != 0 ) { $ digits ++ ; $ n = $ n / 10 ; } $ maxDigit = $ b - 1 ; while ( $ digits -- ) { $ maxNum = $ maxNum * 10 + $ maxDigit ; } return $ maxNum - $ num ; } function complement ( $ n , $ b ) { return prevComplement ( $ n , $ b ) + 1 ; } echo prevComplement ( 25 , 7 ) , \" STRNEWLINE \" ; echo ( complement ( 25 , 7 ) ) ; ? >"}
{"text": "Nilai integer positif minimum mungkin x untuk diberikan a dan b dalam x = p * a + q * b | Berfungsi untuk mengembalikan GCD A dan B; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } $ a = 2 ; $ b = 4 ; echo gcd ( $ a , $ b ) ; ? >"}
{"text": "Mengira elemen dalam julat yang diberikan yang mempunyai bilangan maksimum pembahagi | Berfungsi untuk mengira unsur -unsur dengan bilangan maksimum pembahagi; untuk menyimpan bilangan pembahagi yang dimulakan dengan sifar; untuk menyimpan bilangan maksimum pembahagi; untuk menyimpan jawapan yang diperlukan; Cari nombor yang boleh dibahagi pertama; Kiraan bilangan pembahagi; Cari bilangan elemen dengan bilangan maksimum pembahagi; Kod pemacu", "code": "< ? php function MaximumDivisors ( $ X , $ Y ) { $ arr = array_fill ( 0 , ( $ Y - $ X + 1 ) , NULL ) ; $ mx = PHP_INT_MIN ; $ cnt = 0 ; for ( $ i = 1 ; $ i * $ i <= $ Y ; $ i ++ ) { $ sq = $ i * $ i ; if ( ( $ X / $ i ) * $ i >= $ X ) $ first_divisible = ( $ X / $ i ) * $ i ; else $ first_divisible = ( $ X / $ i + 1 ) * $ i ; for ( $ j = $ first_divisible ; $ j < $ Y ; $ j += $ i ) { if ( $ j < $ sq ) continue ; else if ( $ j == $ sq ) $ arr [ $ j - $ X ] ++ ; else $ arr [ $ j - $ X ] += 2 ; } } for ( $ i = $ X ; $ i <= $ Y ; $ i ++ ) { if ( $ arr [ $ i - $ X ] > $ mx ) { $ cnt = 1 ; $ mx = $ arr [ $ i - $ X ] ; } else if ( $ arr [ $ i - $ X ] == $ mx ) $ cnt ++ ; } return $ cnt ; } $ X = 1 ; $ Y = 10 ; echo MaximumDivisors ( $ X , $ Y ) . \" STRNEWLINE \" ; ? >"}
{"text": "Cari elemen pertama di AP yang berganda dari Perdana yang diberikan | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; berfungsi untuk mencari elemen terdekat yang sama; keadaan asas; Kod pemacu; modul kedua -dua A dan D; panggilan fungsi", "code": "< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function NearestElement ( $ A , $ D , $ P ) { if ( $ A == 0 ) return 0 ; else if ( $ D == 0 ) return -1 ; else { $ X = power ( $ D , $ P - 2 , $ P ) ; return ( $ X * ( $ P - $ A ) ) % $ P ; } } $ A = 4 ; $ D = 9 ; $ P = 11 ; $ A %= $ P ; $ D %= $ P ; echo NearestElement ( $ A , $ D , $ P ) ; ? >"}
{"text": "Rantai Cunningham | Berfungsi untuk mencetak rantai Cunningham dari jenis pertama; Iterat sehingga semua elemen dicetak; periksa perdana atau tidak; Kod pemacu", "code": "< ? php function print_C ( $ p0 ) { $ p1 = 0 ; $ i = 0 ; $ x ; $ flag ; $ k ; while ( 1 ) { $ flag = 1 ; $ x = pow ( 2 , $ i ) ; $ p1 = $ x * $ p0 + ( $ x - 1 ) ; for ( $ k = 2 ; $ k < $ p1 ; $ k ++ ) { if ( $ p1 % $ k == 0 ) { $ flag = 0 ; break ; } } if ( $ flag == 0 ) break ; echo $ p1 . \" \" ; $ i ++ ; } } $ p0 = 2 ; print_C ( $ p0 ) ;"}
{"text": "Kira pasangan dengan bitwise dan sebagai nombor ganjil | Berfungsi untuk mengira bilangan pasangan ganjil; pemboleh ubah untuk mengira pasangan ganjil; Cari semua pasangan; Cari dan operasi semak ganjil atau bahkan; pulangan bilangan pasangan ganjil; Kod pemacu; Fungsi panggilan findoddpair dan cetak nombor pasangan ganjil", "code": "< ? php function findOddPair ( & $ A , $ N ) { $ oddPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] & $ A [ $ j ] ) % 2 != 0 ) $ oddPair = $ oddPair + 1 ; } } return $ oddPair ; } $ a = array ( 5 , 1 , 3 , 2 ) ; $ n = sizeof ( $ a ) ; echo ( findOddPair ( $ a , $ n ) ) ; ? >"}
{"text": "Jumlah semua elemen sehingga baris nth dalam segitiga Pascal | Berfungsi untuk mencari jumlah semua elemen sehingga baris nth. ; Memulakan jumlah dengan 0; Hitung 2 ^ n; Kod pemacu", "code": "< ? php function calculateSum ( $ n ) { $ sum = 0 ; $ sum = 1 << $ n ; return ( $ sum - 1 ) ; } $ n = 10 ; echo \" ▁ Sum ▁ of ▁ all ▁ elements : \" , calculateSum ( $ n ) ; ? >"}
{"text": "Bahagikan dua bilangan bulat tanpa menggunakan pendaraban, pembahagian dan pengendali mod | Set2 | Mengembalikan kuota dividen / pembahagi. ; Kirakan tanda pembahagi i. e. , tanda akan menjadi negatif hanya jika salah satu daripada mereka adalah negatif jika tidak, ia akan menjadi positif; Keluarkan tanda dividen dan pembahagi; Pengecualian Bahagian Zero. ; Menggunakan formula yang diperolehi di atas. ; Kod pemacu", "code": "< ? php function Divide ( $ a , $ b ) { $ dividend = $ a ; $ divisor = $ b ; $ sign = ( $ dividend < 0 ) ^ ( $ divisor < 0 ) ? -1 : 1 ; $ dividend = abs ( $ dividend ) ; $ divisor = abs ( $ divisor ) ; if ( $ divisor == 0 ) { echo \" Cannot ▁ Divide ▁ by ▁ 0\" ; echo \" \" ; } if ( $ dividend == 0 ) { echo $ a , \" ▁ / ▁ \" , $ b , \" ▁ is ▁ equal ▁ to ▁ : ▁ \" , 0 ; echo \" \" ; } if ( $ divisor == 1 ) { echo $ a , \" ▁ / ▁ \" , $ b , \" ▁ is ▁ equal ▁ to ▁ : ▁ \" , $ sign * $ dividend . \" STRNEWLINE \" ; echo \" \" ; } echo $ a , \" ▁ / ▁ \" , $ b , \" ▁ is ▁ equal ▁ to ▁ : ▁ \" , $ sign * exp ( log ( $ dividend ) - log ( $ divisor ) ) . \" STRNEWLINE \" ; echo \" \" ; } $ a = 10 ; $ b = 5 ; Divide ( $ a , $ b ) ; $ a = 49 ; $ b = -7 ; Divide ( $ a , $ b ) ; ? >"}
{"text": "Semak jika n | Kembali jika istilah nth adalah walaupun atau ganjil. ; Jika A adalah juga; Jika B juga; Jika B adalah ganjil; Jika A adalah ganjil; Jika B adalah ganjil; Jika B adalah Hawa; Kod pemacu", "code": "< ? php function findNature ( $ a , $ b , $ n ) { if ( $ n == 0 ) return ( $ a & 1 ) ; if ( $ n == 1 ) return ( $ b & 1 ) ; if ( ! ( $ a & 1 ) ) { if ( ! ( $ b & 1 ) ) return false ; else return ( $ n % 3 != 0 ) ; } else { if ( ! ( $ b & 1 ) ) return ( ( $ n - 1 ) % 3 != 0 ) ; else return ( ( $ n + 1 ) % 3 != 0 ) ; } } $ a = 2 ; $ b = 4 ; $ n = 3 ; if ( findNature ( $ a , $ b , $ n ) == true ) echo \" Odd \" , \" ▁ \" ; else echo \" Even \" , \" ▁ \" ; ? >"}
{"text": "Semak jika imej cermin nombor adalah sama jika dipaparkan dalam tujuh paparan segmen | Kembali \"ya\", jika imej cermin nombor adalah sama dengan nombor yang diberikan lain kembali \"tidak\"; Memeriksa jika nombor itu hanya mengandungi 0, 1, 8 .; Memeriksa jika nombor itu adalah palindrome atau tidak. ; Jika indeks sepadan tidak sama. ; Kod pemacu", "code": "< ? php function checkEqual ( $ S ) { for ( $ i = 0 ; $ i < strlen ( $ S ) ; $ i ++ ) { if ( $ S [ $ i ] != '1' && $ S [ $ i ] != '0' && $ S [ $ i ] != '8' ) { return \" No \" ; } } $ start = 0 ; $ end = strlen ( $ S ) - 1 ; while ( $ start < $ end ) { if ( $ S [ $ start ] != $ S [ $ end ] ) { return \" No \" ; } $ start ++ ; $ end -- ; } return \" Yes \" ; } $ S = \"101\" ; echo checkEqual ( $ S ) ; ? >"}
{"text": "Semak jika nombor yang diberikan adalah kuasa d di mana d adalah kuasa 2 | Program PHP untuk mencari jika nombor adalah kuasa D di mana D adalah kuasa 2 .; Fungsi untuk mengira bilangan cara untuk melukis grid N * 3 berdasarkan syarat -syarat yang diberikan; Semak sama ada hanya satu set bit dalam n; Kira 0 bit sebelum ditetapkan bit; Jika kiraan adalah pelbagai log2 (d) maka kembali benar lain palsu; Sekiranya terdapat lebih daripada 1 bit set maka n bukan kuasa 4; Kod pemacu", "code": "< ? php function Log2n ( $ n ) { return ( $ n > 1 ) ? 1 + Log2n ( $ n / 2 ) : 0 ; } function isPowerOfd ( $ n , $ d ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) { while ( $ n > 1 ) { $ n >>= 1 ; $ count += 1 ; } return ( $ count % ( Log2n ( $ d ) ) == 0 ) ; } return false ; } $ n = 64 ; $ d = 8 ; if ( isPowerOfd ( $ n , $ d ) ) echo $ n , \" ▁ \" , \" is ▁ a ▁ power ▁ of ▁ \" , $ d ; else echo $ n , \" ▁ \" , \" is ▁ not ▁ a ▁ power ▁ of ▁ \" , $ d ; ? >"}
{"text": "Nombor Octahedral | Berfungsi untuk mencari nombor octahedral; Formula untuk mengira nombor octahedral n dan mengembalikannya ke dalam fungsi utama. ; Kod pemacu; hasil cetak", "code": "< ? php function octahedral_num ( $ n ) { return $ n * ( 2 * $ n * $ n + 1 ) / 3 ; } $ n = 5 ; echo $ n , \" th ▁ Octahedral ▁ number : ▁ \" ; echo octahedral_num ( $ n ) ; ? >"}
{"text": "Nombor tetrahedral berpusat | Berfungsi untuk mencari nombor tetrahedral berpusat berpusat; Formula untuk mengira nombor tetrahedral yang berpusat dan mengembalikannya ke dalam fungsi utama. ; Kod pemacu", "code": "< ? php function centeredTetrahedralNumber ( $ n ) { return ( 2 * $ n + 1 ) * ( $ n * $ n + $ n + 3 ) / 3 ; } $ n = 6 ; echo centeredTetrahedralNumber ( $ n ) ; ? >"}
{"text": "Bertukar Empat Pembolehubah Tanpa Pembolehubah Sementara | Program PHP untuk menukar 4 pembolehubah tanpa menggunakan pemboleh ubah sementara; menukar pembolehubah A dan B; menukar pembolehubah B dan C; menukar pembolehubah C dan D; pembolehubah permulaan; Panggilan fungsi", "code": "< ? php function swap ( $ a , $ b , $ c , $ d ) { $ a = $ a + $ b ; $ b = $ a - $ b ; $ a = $ a - $ b ; $ b = $ b + $ c ; $ c = $ b - $ c ; $ b = $ b - $ c ; $ c = $ c + $ d ; $ d = $ c - $ d ; $ c = $ c - $ d ; echo \" values ▁ after ▁ swapping ▁ are ▁ : ▁ \" , \" STRNEWLINE \" ; echo \" a = \" ▁ , ▁ $ a ▁ , \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" b = \" ▁ , ▁ $ b ▁ , \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" c = \" ▁ , $ c ▁ , \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" d = \" ▁ , ▁ $ d ▁ , \" \" } $ a = 1 ; $ b = 2 ; $ c = 3 ; $ d = 4 ; echo \" Values ▁ before ▁ swapping ▁ are ▁ : \" , \" STRNEWLINE \" ; echo \" a = \" ▁ , ▁ $ a ▁ , \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" b = \" ▁ , $ b , \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" c = \" ▁ , ▁ $ c ▁ , \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" d = \" ▁ , ▁ $ d ▁ , \" \" , \" \" swap ( $ a , $ b , $ c , $ d ) ; ? >"}
{"text": "Jumlah nombor semulajadi n Pertama | Berfungsi untuk mencari jumlah siri; Kod pemacu", "code": "< ? php function seriesSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += $ i * ( $ i + 1 ) / 2 ; return $ sum ; } $ n = 4 ; echo ( seriesSum ( $ n ) ) ; ? >"}
{"text": "Matriks Centrosymmetric | Program PHP untuk memeriksa sama ada matriks yang diberikan adalah centrosymmetric atau tidak. ; Mencari baris tengah matriks; untuk setiap baris sehingga baris tengah. ; Jika setiap elemen dan elemen yang sepadan tidak sama maka kembali palsu. ; Kod pemacu", "code": "< ? php function checkCentrosymmetricted ( $ n , $ m ) { $ mid_row ; if ( $ n & 1 ) $ mid_row = $ n / 2 + 1 ; else $ mid_row = $ n / 2 ; for ( $ i = 0 ; $ i < $ mid_row ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ m [ $ i ] [ $ j ] != $ m [ $ n - $ i - 1 ] [ $ n - $ j - 1 ] ) return false ; } } return true ; } $ n = 3 ; $ m = array ( array ( 1 , 3 , 5 ) , array ( 6 , 8 , 6 ) , array ( 5 , 3 , 1 ) ) ; if ( checkCentrosymmetricted ( $ n , $ m ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Nombor segi tiga yang berpusat | fungsi untuk nombor segi tiga yang berpusat; Formula untuk mencari nombor segitiga yang berpusat pada istilah n; Untuk nombor segi tiga berpusat 3 RD; Untuk nombor segi tiga berpusat ke -12", "code": "< ? php function Centered_Triangular_num ( $ n ) { return ( 3 * $ n * $ n + 3 * $ n + 2 ) / 2 ; } $ n = 3 ; echo Centered_Triangular_num ( $ n ) , \" STRNEWLINE \" ; $ n = 12 ; echo Centered_Triangular_num ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "COMBINATORICS ON TREES YANG DIPERLUKAN | Fungsi pulangan nilai pekali binomial c (n, k); Hitung nilai pekali binomial dengan cara bawah; Kes asas; Hitung nilai menggunakan nilai yang disimpan sebelumnya; Fungsi untuk mengira bilangan pokok dengan daun yang betul. ; Fungsi untuk mengira jumlah nod darjah D di pokok -pokok ini. ; Fungsi untuk mengira bilangan pokok di mana akar mempunyai ijar r. ; Program Pemandu untuk Menguji Fungsi Di atas Bilangan pokok yang mempunyai 3 tepi dan betul -betul 2 daun; Bilangan nod ijazah 3 dalam pokok yang mempunyai 4 tepi; Bilangan pokok yang mempunyai 3 tepi di mana akar mempunyai ijazah 2", "code": "< ? php function binomialCoeff ( $ n , $ k ) { $ C = array ( array ( ) ) ; $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ k ) ; $ j ++ ) { if ( $ j == 0 or $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } return $ C [ $ n ] [ $ k ] ; } function k_Leaves ( $ n , $ k ) { $ ans = ( binomialCoeff ( $ n , $ k ) * binomialCoeff ( $ n , $ k - 1 ) ) / $ n ; echo \" Number ▁ of ▁ trees ▁ having ▁ 4 ▁ edges ▁ and ▁ \" , \" exactly ▁ 2 ▁ leaves ▁ : ▁ \" , $ ans , \" STRNEWLINE \" ; return 0 ; } function numberOfNodes ( $ n , $ d ) { $ ans = binomialCoeff ( 2 * $ n - 1 - $ d , $ n - 1 ) ; echo \" Number ▁ of ▁ nodes ▁ of ▁ degree ▁ 1 ▁ in \" , \" ▁ a ▁ tree ▁ having ▁ 4 ▁ edges ▁ : ▁ \" , $ ans , \" STRNEWLINE \" ; return 0 ; } function rootDegreeR ( $ n , $ r ) { $ ans = $ r * binomialCoeff ( 2 * $ n - 1 - $ r , $ n - 1 ) ; $ ans = $ ans / $ n ; echo \" Number ▁ of ▁ trees ▁ having ▁ 4 ▁ edges \" , \" ▁ where ▁ root ▁ has ▁ degree ▁ 2 ▁ : ▁ \" , $ ans ; return 0 ; } k_Leaves ( 3 , 2 ) ; numberOfNodes ( 3 , 1 ) ; rootDegreeR ( 3 , 2 ) ; ? >"}
{"text": "Pembahagian Unit Berulang | Untuk mencari nilai paling kurang k; Untuk memeriksa n adalah coprime atau tidak; untuk menyimpan nilai r (k) mod n dan 10 ^ k mod n; Kod pemacu", "code": "< ? php function repUnitValue ( $ n ) { if ( $ n % 2 == 0 $ n % 5 == 0 ) return 0 ; $ rem = 1 ; $ power = 1 ; $ k = 1 ; while ( $ rem % $ n != 0 ) { $ k ++ ; $ power = $ power * 10 % $ n ; $ rem = ( $ rem + $ power ) % $ n ; } return $ k ; } $ n = 13 ; echo repUnitValue ( $ n ) ; ? >"}
{"text": "Pertama n semulajadi boleh dibahagikan kepada dua set dengan perbezaan yang diberikan dan co | Kod PHP untuk menentukan sama ada nombor 1 hingga n boleh dibahagikan kepada dua set sedemikian rupa sehingga perbezaan mutlak antara jumlah kedua -dua set ini adalah m dan kedua -dua jumlah ini adalah co -prime; Fungsi yang mengembalikan nilai Boolean berdasarkan sama ada ia mungkin untuk membahagikan nombor 1 hingga N ke dalam dua set yang memenuhi syarat yang diberikan. ; memulakan jumlah jumlah nombor 1 hingga N; Oleh kerana (1) total_sum = sum_s1 + sum_s2 dan (2) m = sum_s1 - sum_s2 dengan asumsi sum_s1> sum_s2. menyelesaikan 2 persamaan ini untuk mendapatkan sum_s1 dan sum_s2; total_sum = sum_s1 + sum_s2 dan oleh itu; Jika jumlah jumlah adalah kurang daripada perbezaan mutlak maka tidak ada cara kita dapat memecah nombor N menjadi dua set sehingga kembali palsu; Semak sama ada kedua -dua jumlah ini adalah bilangan bulat dan mereka menambah jumlah jumlah dan juga jika perbezaan mutlak mereka adalah m. ; Sekarang jika dua jumlah adalah co - perdana kemudian kembali benar, lain kembali palsu. ; Sekiranya dua jumlah wang tidak menambah jumlah jumlah atau jika perbezaan mutlak mereka tidak m, maka tidak ada cara untuk memecah nombor, maka kembali palsu; Kod pemacu; panggilan fungsi untuk menentukan jawapan", "code": "< ? php function __gcd ( $ a , $ b ) { return $ b == 0 ? $ a : __gcd ( $ b , $ a % $ b ) ; } function isSplittable ( $ n , $ m ) { $ total_sum = ( int ) ( ( $ n * ( $ n + 1 ) ) / 2 ) ; $ sum_s1 = ( int ) ( ( $ total_sum + $ m ) / 2 ) ; $ sum_s2 = $ total_sum - $ sum_s1 ; if ( $ total_sum < $ m ) return false ; if ( $ sum_s1 + $ sum_s2 == $ total_sum && $ sum_s1 - $ sum_s2 == $ m ) return ( __gcd ( $ sum_s1 , $ sum_s2 ) == 1 ) ; return false ; } $ n = 5 ; $ m = 7 ; if ( isSplittable ( $ n , $ m ) ) echo \" Yes \" ; else echo \" No \" ;"}
{"text": "Membuat pelbagai sifar dengan menurunkan pasangan bersebelahan | Pelaksanaan PHP pendekatan di atas; Menukar elemen array ke dalam nombor; Semak jika dibahagikan dengan 11; Kod pemacu", "code": "< ? php function isPossibleToZero ( $ a , $ n ) { $ num = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ num = $ num * 10 + $ a [ $ i ] ; return ( $ num % 11 == 0 ) ; } $ arr = array ( 0 , 1 , 1 , 0 ) ; $ n = sizeof ( $ arr ) ; if ( isPossibleToZero ( $ arr , $ n ) ) echo \" YES \" ; else echo \" NO \" ;"}
{"text": "Blum Integer | Fungsi untuk pipi jika nombor adalah blum integer; untuk menyimpan nombor perdana dari 2 hingga n; Jika Perdana [i] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Untuk memeriksa sama ada integer ganjil yang diberikan adalah blum integer atau tidak; Memeriksa faktor -faktor adalah bentuk 4 t + 3 atau tidak; Beri integer ganjil lebih besar daripada 20", "code": "< ? php function isBlumInteger ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ prime [ $ i ] == true ) { for ( $ j = $ i * 2 ; $ j <= $ n ; $ j += $ i ) $ prime [ $ j ] = false ; } } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ prime [ $ i ] ) { if ( ( $ n % $ i == 0 ) && ( ( $ i - 3 ) % 4 ) == 0 ) { $ q = ( int ) $ n / $ i ; return ( $ q != $ i && $ prime [ $ q ] && ( $ q - 3 ) % 4 == 0 ) ; } } } return false ; } $ n = 249 ; if ( isBlumInteger ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Program untuk mengira nilai NCR | Program PHP untuk mengira nilai NCR; Mengembalikan faktorial n; Kod pemacu", "code": "< ? php function nCr ( $ n , $ r ) { return fact ( $ n ) / ( fact ( $ r ) * fact ( $ n - $ r ) ) ; } function fact ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } $ n = 5 ; $ r = 3 ; echo nCr ( $ n , $ r ) ; ? >"}
{"text": "Program untuk mencetak jumlah istilah nth yang diberikan | fungsi untuk mengira jumlah siri; Jumlah istilah n ialah n ^ 2; Kod pemacu", "code": "< ? php function summingSeries ( $ n ) { return pow ( $ n , 2 ) ; } $ n = 100 ; echo \" The ▁ sum ▁ of ▁ n ▁ term ▁ is : ▁ \" , summingSeries ( $ n ) ; ? >"}
{"text": "Brahmagupta Fibonacci Identiti | Kod PHP untuk mengesahkan identiti Brahmagupta Fibonacci; mewakili produk sebagai jumlah 2 kotak; Semak kriteria identiti; 1 ^ 2 + 2 ^ 2; 3 ^ 2 + 4 ^ 2; Ekspres produk dari 2 kotak sebagai jumlah (jumlah 2 kotak)", "code": "< ? php function find_sum_of_two_squares ( $ a , $ b ) { $ ab = $ a * $ b ; for ( $ i = 0 ; $ i * $ i <= $ ab ; $ i ++ ) { for ( $ j = $ i ; $ i * $ i + $ j * $ j <= $ ab ; $ j ++ ) { if ( $ i * $ i + $ j * $ j == $ ab ) echo $ i , \" ^ 2 ▁ + ▁ \" , $ j , \" ^ 2 ▁ = ▁ \" , $ ab , \" STRNEWLINE \" ; } } } $ a = 1 * 1 + 2 * 2 ; $ b = 3 * 3 + 4 * 4 ; echo \" Representation ▁ of ▁ a ▁ * ▁ b ▁ \" . \" as ▁ sum ▁ of ▁ 2 ▁ squares : STRNEWLINE \" ; find_sum_of_two_squares ( $ a , $ b ) ; ? >"}
{"text": "Nombor Tetrahedral | Berfungsi untuk mencari nombor tetrahedral; Kod pemacu", "code": "< ? php function tetrahedralNumber ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) / 6 ; } $ n = 5 ; echo tetrahedralNumber ( $ n ) ; ? >"}
{"text": "Euler's Four Square Identity | berfungsi untuk memeriksa Euler empat identiti persegi; gelung memeriksa jumlah kotak; Jumlah 2 kotak; jumlah 3 dataran; Jumlah 4 dataran; produk daripada 2 nombor yang diwakili sebagai jumlah empat dataran I, J, K, L; produk 2 nombor A dan B diwakili sebagai jumlah empat dataran I, J, K, L; Nombor yang diberikan boleh diwakili sebagai jumlah 4 kotak oleh empat produk identiti persegi Euler juga boleh diwakili sebagai jumlah 4 kotak", "code": "< ? php function check_euler_four_square_identity ( $ a , $ b , $ ab ) { $ s = 0 ; for ( $ i = 0 ; $ i * $ i <= $ ab ; $ i ++ ) { $ s = $ i * $ i ; for ( $ j = $ i ; $ j * $ j <= $ ab ; $ j ++ ) { $ s = $ j * $ j + $ i * $ i ; for ( $ k = $ j ; $ k * $ k <= $ ab ; $ k ++ ) { $ s = $ k * $ k + $ j * $ j + $ i * $ i ; for ( $ l = $ k ; $ l * $ l <= $ ab ; $ l ++ ) { $ s = $ l * $ l + $ k * $ k + $ j * $ j + $ i * $ i ; if ( $ s == $ ab ) { echo ( \" i ▁ = ▁ \" . $ i . \" STRNEWLINE \" ) ; echo ( \" j ▁ = ▁ \" . $ j . \" STRNEWLINE \" ) ; echo ( \" k ▁ = ▁ \" . $ k . \" STRNEWLINE \" ) ; echo ( \" l ▁ = ▁ \" . $ l . \" STRNEWLINE \" ) ; echo \" \" . \" Product ▁ of ▁ \" . $ a . \" ▁ and ▁ \" . $ b ; echo \" ▁ can ▁ be ▁ written \" . \" ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ \" . \" j , ▁ k , ▁ l STRNEWLINE \" ; echo $ ab . \" ▁ = ▁ \" ; echo $ i . \" * \" ▁ . ▁ $ i . ▁ \" + \" echo $ j . \" * \" . $ j . \" ▁ + ▁ \" ; echo $ k . \" * \" ▁ . ▁ $ k ▁ . ▁ \" + \" echo $ l . \" * \" . $ l . \" STRNEWLINE \" ; echo \" STRNEWLINE \" ; } } } } } } $ ab = $ a * $ b ; check_euler_four_square_identity ( $ a , $ b , $ ab ) ; ? >"}
{"text": "Bilangan Penyelesaian kepada Persamaan Modular | Mengembalikan bilangan pembahagi (a - b) lebih besar daripada b; jika n boleh dibahagikan dengan i; hitung hanya pembahagi yang lebih besar daripada b; Memeriksa jika pembahagi tidak dikira dua kali; Fungsi utiliti untuk mengira bilangan semua nilai yang mungkin x yang mana persamaan modular memegang benar; Jika a = b terdapat banyak penyelesaian untuk persamaan atau kita katakan x boleh mengambil banyak nilai> a. Kami kembali - 1 dalam kes ini; Jika A <b, tidak ada nilai yang mungkin untuk memenuhi persamaan; Kes terakhir adalah apabila A> B, di sini kita mengira bilangan pembahagi (A - B), yang lebih besar daripada B; Fungsi pembalut untuk nomborFpossibleWaysUtil (); Sekiranya banyak penyelesaian yang tersedia; Kod pemacu", "code": "< ? php function calculateDivisors ( $ A , $ B ) { $ N = ( $ A - $ B ) ; $ noOfDivisors = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ N ) ; $ i ++ ) { if ( ( $ N % $ i ) == 0 ) { if ( $ i > $ B ) $ noOfDivisors ++ ; if ( ( $ N / $ i ) != $ i && ( $ N / $ i ) > $ B ) $ noOfDivisors ++ ; } } return $ noOfDivisors ; } function numberOfPossibleWaysUtil ( $ A , $ B ) { if ( $ A == $ B ) return -1 ; if ( $ A < $ B ) return 0 ; $ noOfDivisors = 0 ; $ noOfDivisors = calculateDivisors ( $ A , $ B ) ; return $ noOfDivisors ; } function numberOfPossibleWays ( $ A , $ B ) { $ noOfSolutions = numberOfPossibleWaysUtil ( $ A , $ B ) ; if ( $ noOfSolutions == -1 ) { echo \" For A = \" ▁ , ▁ $ A , ▁ \" and B = \" ▁ , $ B , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" X can take Infinitely many values greater than \" ▁ , ▁ $ A ▁ , ▁ \" \" ; STRNEWLINE TABSYMBOL } STRNEWLINE TABSYMBOL else ▁ { STRNEWLINE TABSYMBOL TABSYMBOL echo ▁ \" For A = \" , ▁ $ A ▁ , ▁ \" and B = \" ▁ , $ B , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" X can take \" , $ noOfSolutions , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" values \" } } $ A = 26 ; $ B = 2 ; numberOfPossibleWays ( $ A , $ B ) ; $ A = 21 ; $ B = 5 ; numberOfPossibleWays ( $ A , $ B ) ;"}
{"text": "Kuasa sempurna (1, 4, 8, 9, 16, 25, 27, ...) | Fungsi yang menyimpan semua nombor kuasa ganjil sehingga n; Kami perlu mengecualikan dataran sempurna. ; Susun vektor; Kembali jumlah ganjil dan bahkan kuasa. ; Kod pemacu", "code": "< ? php function powerNumbers ( $ n ) { $ v = array ( ) ; for ( $ i = 2 ; $ i * $ i * $ i <= $ n ; $ i ++ ) { $ j = $ i * $ i ; while ( $ j * $ i <= $ n ) { $ j *= $ i ; $ s = sqrt ( $ j ) ; if ( $ s * $ s != $ j ) array_push ( $ v , $ j ) ; } } sort ( $ v ) ; $ uni = array_unique ( $ v ) ; for ( $ i = 0 ; $ i < count ( $ uni ) ; $ i ++ ) { $ key = array_search ( $ uni [ $ i ] , $ v ) ; unset ( $ v [ $ key ] ) ; } return count ( $ v ) + 3 + intval ( sqrt ( $ n ) ) ; } echo ( powerNumbers ( 50 ) ) ; ? >"}
{"text": "Varians dan Standard | fungsi pengisytiharan fungsi varians untuk mengira min; Mengira jumlah; Kembali bermakna; Fungsi untuk mengira varians; Mengurangkan min dari unsur -unsur; a [i] [j] = fabs (a [i] [j]); mengikat setiap istilah; mengambil jumlah; mengisytiharkan dan memulakan matriks; untuk min; untuk varians; untuk sisihan piawai; memaparkan varians dan penyelewengan", "code": "< ? php function mean ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ a [ $ i ] [ $ j ] ; return floor ( ( int ) $ sum / ( $ n * $ n ) ) ; } function variance ( $ a , $ n , $ m ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ a [ $ i ] [ $ j ] -= $ m ; $ a [ $ i ] [ $ j ] *= $ a [ $ i ] [ $ j ] ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ a [ $ i ] [ $ j ] ; return floor ( ( int ) $ sum / ( $ n * $ n ) ) ; } $ mat = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; $ m = mean ( $ mat , 3 ) ; $ var = variance ( $ mat , 3 , $ m ) ; $ dev = sqrt ( $ var ) ; echo \" Mean : \" ▁ , ▁ $ m ▁ , ▁ \" \" , STRNEWLINE TABSYMBOL \" Variance : \" ▁ , ▁ $ var ▁ , STRNEWLINE TABSYMBOL \" \" , ▁ \" Deviation : \" floor ( $ dev ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari n aritmetik antara a dan b | Cetakan n aritmetik antara a dan b. ; Kirakan perbezaan biasa (d); untuk mencari n aritmetik antara a dan b; Kod pemacu", "code": "< ? php function printAMeans ( $ A , $ B , $ N ) { $ d = ( $ B - $ A ) / ( $ N + 1 ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo ( $ A + $ i * $ d ) , \" ▁ \" ; } $ A = 20 ; $ B = 32 ; $ N = 5 ; printAMeans ( $ A , $ B , $ N ) ; ? >"}
{"text": "Jumlah Siri 1.2. 3 + 2.3. 4 + ... + n (n + 1) (n + 2) | fungsi untuk mengira jumlah siri; Kod pemacu", "code": "< ? php function sumofseries ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) * ( $ n + 3 ) / 4 ) ; } echo sumofseries ( 3 ) ; ? >"}
{"text": "Nombor terbesar dalam [2, 3 ,. . n] yang co | Pulangan benar jika saya adalah co - perdana dengan nombor dalam set [2, 3, ... m]; Menjalankan gelung sehingga akar persegi N untuk mengurangkan kerumitan masa dari n; Cari minimum akar persegi N dan M untuk menjalankan gelung sehingga yang lebih kecil; Semak dari 2 hingga min (m, sqrt (n)); Berfungsi untuk mencari nombor terbesar yang kurang daripada n yang merupakan perdana dengan semua nombor dari 2 hingga m; Melangkah dari N ke M + 1 untuk mencari nombor; memeriksa setiap nombor untuk syarat -syarat yang diberikan; Nombor pertama yang memenuhi syarat adalah jawapannya; Sekiranya tiada nombor yang memenuhi syarat, maka nombor cetak tidak wujud. ; Kod pemacu", "code": "< ? php function isValid ( $ i , $ m ) { $ sq_i = sqrt ( $ i ) ; $ sq = min ( $ m , $ sq_i ) ; for ( $ j = 2 ; $ j <= $ sq ; $ j ++ ) if ( $ i % $ j == 0 ) return false ; return true ; } function findLargestNum ( $ n , $ m ) { for ( $ i = $ n ; $ i > $ m ; $ i -- ) { if ( isValid ( $ i , $ m ) ) { echo $ i , \" STRNEWLINE \" ; return ; } } echo \" Number ▁ Doesn ' t ▁ Exists STRNEWLINE \" ; } $ n = 16 ; $ m = 3 ; findLargestNum ( $ n , $ m ) ; ? >"}
{"text": "Semak sama ada matriks yang diberikan adalah ortogonal atau tidak | Berfungsi untuk memeriksa orthogonalilty; Cari transpose; Cari produk [] [] dan transposinya; Oleh kerana kita mendarab dengan transpose dari dirinya sendiri. Kami menggunakan; Semak sama ada produk adalah matriks identiti; Kod pemacu", "code": "< ? php function isOrthogonal ( $ a , $ m , $ n ) { if ( $ m != $ n ) return false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ trans [ $ i ] [ $ j ] = $ a [ $ j ] [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ sum = 0 ; for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { $ sum = $ sum + ( $ a [ $ i ] [ $ k ] * $ a [ $ j ] [ $ k ] ) ; } $ prod [ $ i ] [ $ j ] = $ sum ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i != $ j && $ prod [ $ i ] [ $ j ] != 0 ) return false ; if ( $ i == $ j && $ prod [ $ i ] [ $ j ] != 1 ) return false ; } } return true ; } $ a = array ( array ( 1 , 0 , 0 ) , array ( 0 , 1 , 0 ) , array ( 0 , 0 , 1 ) ) ; if ( isOrthogonal ( $ a , 3 , 3 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak jika nombor yang diberikan adalah persegi yang sempurna | Program PHP untuk mencari jika X adalah persegi yang sempurna. ; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Kod pemacu", "code": "< ? php function isPerfectSquare ( $ x ) { $ sr = sqrt ( $ x ) ; return ( ( $ sr - floor ( $ sr ) ) == 0 ) ; } $ x = 2502 ; if ( isPerfectSquare ( $ x ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Program untuk mencetak GP (perkembangan geometri) | berfungsi untuk mencetak GP; nombor permulaan; Nisbah biasa; Istilah n yang boleh dijumpai", "code": "< ? php function printGP ( $ a , $ r , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_term = $ a * pow ( $ r , $ i ) ; echo $ curr_term , \" \" ; } } $ a = 2 ; $ r = 3 ; $ n = 5 ; printGP ( $ a , $ r , $ n ) ; ? >"}
{"text": "Kaedah berulang yang cekap ruang untuk nombor Fibonacci | Dapatkan MSB kedua; Secara konsisten menetapkan semua bit; mengembalikan MSB kedua; Fungsi penggandaan; Fungsi untuk mengira f [] [] menaikkan kuasa n; Kes asas; Ambil array 2D untuk menyimpan nombor nombor; Run Loop hingga MSB> 0; Untuk mengembalikan nombor Fibonacci; Diberikan n", "code": "< ? php function getMSB ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; return ( ( $ n + 1 ) >> 2 ) ; } function multiply ( & $ F , & $ M ) { $ x = $ F [ 0 ] [ 0 ] * $ M [ 0 ] [ 0 ] + $ F [ 0 ] [ 1 ] * $ M [ 1 ] [ 0 ] ; $ y = $ F [ 0 ] [ 0 ] * $ M [ 0 ] [ 1 ] + $ F [ 0 ] [ 1 ] * $ M [ 1 ] [ 1 ] ; $ z = $ F [ 1 ] [ 0 ] * $ M [ 0 ] [ 0 ] + $ F [ 1 ] [ 1 ] * $ M [ 1 ] [ 0 ] ; $ w = $ F [ 1 ] [ 0 ] * $ M [ 0 ] [ 1 ] + $ F [ 1 ] [ 1 ] * $ M [ 1 ] [ 1 ] ; $ F [ 0 ] [ 0 ] = $ x ; $ F [ 0 ] [ 1 ] = $ y ; $ F [ 1 ] [ 0 ] = $ z ; $ F [ 1 ] [ 1 ] = $ w ; } function power ( & $ F , $ n ) { if ( $ n == 0 $ n == 1 ) return ; $ M = array ( array ( 1 , 1 ) , array ( 1 , 0 ) ) ; for ( $ m = getMSB ( $ n ) ; $ m ; $ m = $ m >> 1 ) { multiply ( $ F , $ F ) ; if ( $ n & $ m ) { multiply ( $ F , $ M ) ; } } } function fib ( $ n ) { $ F = array ( array ( 1 , 1 ) , array ( 1 , 0 ) ) ; if ( $ n == 0 ) return 0 ; power ( $ F , $ n - 1 ) ; return $ F [ 0 ] [ 0 ] ; } $ n = 6 ; echo fib ( $ n ) . \" \" ; ? >"}
{"text": "Stern | Program PHP untuk mencetak urutan Brocot; gelung untuk membuat urutan; Menambah jumlah elemen yang dipertimbangkan dan presedennya; Menambah elemen yang dipertimbangkan seterusnya; urutan percetakan. . ; Kod pemacu; Menambah dua elemen pertama dalam urutan", "code": "< ? php function SternSequenceFunc ( & $ BrocotSequence , $ n ) { for ( $ i = 1 ; count ( $ BrocotSequence ) < $ n ; $ i ++ ) { $ considered_element = $ BrocotSequence [ $ i ] ; $ precedent = $ BrocotSequence [ $ i - 1 ] ; array_push ( $ BrocotSequence , $ considered_element + $ precedent ) ; array_push ( $ BrocotSequence , $ considered_element ) ; } for ( $ i = 0 ; $ i < 15 ; ++ $ i ) echo ( $ BrocotSequence [ $ i ] . \" ▁ \" ) ; } $ n = 15 ; $ BrocotSequence = array ( ) ; array_push ( $ BrocotSequence , 1 ) ; array_push ( $ BrocotSequence , 1 ) ; SternSequenceFunc ( $ BrocotSequence , $ n ) ; ? >"}
{"text": "Mengira nombor yang perbezaannya dari terbalik adalah produk k | Program PHP untuk mengira nombor dalam julat yang diberikan di mana apabila anda menolak nombor dari sebaliknya, perbezaannya adalah produk k; fungsi untuk memeriksa sama ada nombor dan sebaliknya mempunyai perbezaan mutlak mereka yang boleh dibahagikan oleh k; membalikkan nombor; Kod pemacu", "code": "< ? php function isRevDiffDivisible ( $ x , $ k ) { $ n = $ x ; $ m = 0 ; $ flag ; while ( $ x > 0 ) { $ m = $ m * 10 + $ x % 10 ; $ x = ( int ) $ x / 10 ; } return ( abs ( $ n - $ m ) % $ k == 0 ) ; } function countNumbers ( $ l , $ r , $ k ) { $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) if ( isRevDiffDivisible ( $ i , $ k ) ) ++ $ count ; return $ count ; } $ l = 20 ; $ r = 23 ; $ k = 6 ; echo countNumbers ( $ l , $ r , $ k ) ; ? >"}
{"text": "Semak pasangan yang baik | Fungsi untuk mengira jumlah semua pembahagi yang betul bagi nombor tertentu; Jumlah pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'n'; Jika kedua -dua pembahagi adalah sama maka tambahkannya sekali lagi tambah kedua -duanya; Tambah 1 dan N untuk menghasilkan seperti gelung di atas menganggap pembahagi yang betul lebih besar daripada 1; Pulangan benar jika x dan y adalah baik yang lain palsu. ; Kod pemacu", "code": "< ? php function divSum ( $ n ) { $ result = 0 ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ i == ( $ n / $ i ) ) $ result += $ i ; else $ result += ( $ i + $ n / $ i ) ; } } return ( $ result + 1 ) ; } function areAmicable ( $ x , $ y ) { if ( divSum ( $ x ) != $ y ) return false ; return ( divSum ( $ y ) == $ x ) ; } $ x = 220 ; $ y = 284 ; if ( areAmicable ( $ x , $ y ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Program untuk mencetak nombor bukan persegi | Berfungsi untuk memeriksa persegi yang sempurna; berfungsi untuk mencetak semua nombor bukan persegi; pemboleh ubah yang menyimpan kiraan; tidak sempurna persegi; Kod pemacu", "code": "< ? php function isPerfectSquare ( $ n ) { if ( $ n < 0 ) return false ; $ root = round ( sqrt ( $ n ) ) ; return $ n == $ root * $ root ; } function printnonsquare ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ count < $ n ; ++ $ i ) { if ( ! isPerfectSquare ( $ i ) ) { echo $ i . \" \" ; $ count ++ ; } } } $ n = 10 ; printnonsquare ( $ n ) ; ? >"}
{"text": "Program untuk mencetak nombor bukan persegi | Mengembalikan N - Th Non - Square Number. ; gelung untuk mencetak bukan dataran di bawah n; Kod pemacu", "code": "< ? php function nonsquare ( $ n ) { return $ n + ( int ) ( 0.5 + sqrt ( $ n ) ) ; } function printNonSquare ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) printf ( nonsquare ( $ i ) . \" ▁ \" ) ; } $ n = 10 ; printNonSquare ( $ n ) ; ? >"}
{"text": "Program untuk membandingkan dua pecahan | Dapatkan maksimum dari dua pecahan; Mengisytiharkan NUME1 dan NUME2 untuk mendapatkan nilai pengangka pertama dan pengangka kedua; Mengira iklan - BC; Kod pemacu", "code": "< ? php function maxFraction ( $ first , $ sec ) { $ a = $ first [ 0 ] ; $ b = $ first [ 1 ] ; $ c = $ sec [ 0 ] ; $ d = $ sec [ 1 ] ; $ Y = $ a * $ d - $ b * $ c ; return ( $ Y ) ? $ first : $ sec ; } $ first = array ( 3 , 2 ) ; $ sec = array ( 3 , 4 ) ; $ res = maxFraction ( $ first , $ sec ) ; echo $ res [ 0 ] . \" / \" . $ res [ 1 ] ; ? >"}
{"text": "Program untuk memeriksa sama ada n adalah nombor pentagonal | Fungsi untuk menentukan sama ada n adalah pentagonal atau tidak. ; Nilai pengganti i dalam formula. ; Kod pemacu", "code": "< ? php function isPentagonal ( int $ N ) { $ i = 1 ; $ M ; do { $ M = ( 3 * $ i * $ i - $ i ) / 2 ; $ i += 1 ; } while ( $ M < $ N ) ; return ( $ M == $ N ) ; } $ N = 12 ; if ( isPentagonal ( $ N ) ) echo $ N , \" ▁ is ▁ pentagonal ▁ \" ; else echo $ N , \" ▁ is ▁ not ▁ pentagonal \" ; ? >"}
{"text": "Jumlah Kuasa Keempat Nombor Semulajadi N Pertama | Mengembalikan jumlah kuasa keempat nombor natural pertama; Kod pemacu", "code": "< ? php function fourthPowerSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + ( $ i * $ i * $ i * $ i ) ; return $ sum ; } $ n = 6 ; echo ( fourthPowerSum ( $ n ) ) ; ? >"}
{"text": "Jumlah Kuasa Keempat Nombor Semulajadi N Pertama | Mengembalikan jumlah kuasa keempat nombor natural pertama; Kod pemacu", "code": "< ? php function fourthPowerSum ( $ n ) { return ( ( 6 * $ n * $ n * $ n * $ n * $ n ) + ( 15 * $ n * $ n * $ n * $ n ) + ( 10 * $ n * $ n * $ n ) - $ n ) / 30 ; } $ n = 6 ; echo ( fourthPowerSum ( $ n ) ) ; ? >"}
{"text": "Cari Digit Unit X yang dibangkitkan ke Power Y | Cari Digit Unit; Dapatkan digit terakhir X; Nilai modular kitaran terakhir; Di sini kita hanya mengembalikan angka unit atau kuasa nombor; Kod pemacu; Dapatkan nombor digit unit di sini kami lulus digit unit x dan nombor cyclicity terakhir iaitu y % 4", "code": "< ? php function unitnumber ( $ x , $ y ) { $ x = $ x % 10 ; if ( $ y != 0 ) $ y = $ y % 4 + 4 ; return ( ( ( int ) ( pow ( $ x , $ y ) ) ) % 10 ) ; } $ x = 133 ; $ y = 5 ; echo ( unitnumber ( $ x , $ y ) ) ; ? >"}
{"text": "Aliquot Sum | Berfungsi untuk mengira jumlah semua pembahagi yang betul; Kod pemacu", "code": "< ? php function aliquotSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ sum += $ i ; return $ sum ; } $ n = 12 ; echo ( aliquotSum ( $ n ) ) ; ? >"}
{"text": "Pendaraban dua nombor kompleks yang diberikan sebagai rentetan | Program PHP untuk membiak dua nombor kompleks yang diberikan sebagai rentetan. ; Meludah bahagian sebenar dan khayalan rentetan kompleks yang diberikan berdasarkan simbol ' +' dan 'i'. ; Menyimpan bahagian sebenar rentetan kompleks A; Menyimpan bahagian khayalan rentetan kompleks A; Menyimpan bahagian sebenar rentetan kompleks b; Menyimpan bahagian khayalan rentetan kompleks B; Mengembalikan produk. ; Kod pemacu", "code": "< ? php function complexNumberMultiply ( $ a , $ b ) { $ x = preg_split ( \" / [ \\s + ] + ▁ i / \" , $ a ) ; $ y = preg_split ( \" / [ \\s + ] + ▁ i / \" , $ b ) ; $ a_real = intval ( $ x [ 0 ] ) ; $ a_img = intval ( $ x [ 1 ] ) ; $ b_real = intval ( $ y [ 0 ] ) ; $ b_img = intval ( $ y [ 1 ] ) ; return ( $ a_real * $ b_real - $ a_img * $ b_img ) . \" + \" ( $ a_real * $ b_img + $ a_img * $ b_real ) . \" i \" ; } $ str1 = \"1 + 1i \" ; $ str2 = \"1 + 1i \" ; echo complexNumberMultiply ( $ str1 , $ str2 ) ; ? >"}
{"text": "Purata Squares of Natural Number | Berfungsi untuk mendapatkan purata; Kod pemacu", "code": "< ? php function AvgofSquareN ( $ n ) { return ( ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; } $ n = 2 ; echo ( AvgofSquareN ( $ n ) ) ; ? >"}
{"text": "Program untuk melaksanakan peraturan 3/8 Simpson | Fungsi yang diberikan untuk disepadukan; Berfungsi untuk melakukan pengiraan; Mengira nilai sehingga had integral; Kod pemacu", "code": "< ? php function func ( $ x ) { return ( 1 / ( 1 + $ x * $ x ) ) ; } function calculate ( $ lower_limit , $ upper_limit , $ interval_limit ) { $ interval_size = ( $ upper_limit - $ lower_limit ) / $ interval_limit ; $ sum = func ( $ lower_limit ) + func ( $ upper_limit ) ; for ( $ i = 1 ; $ i < $ interval_limit ; $ i ++ ) { if ( $ i % 3 == 0 ) $ sum = $ sum + 2 * func ( $ lower_limit + $ i * $ interval_size ) ; else $ sum = $ sum + 3 * func ( $ lower_limit + $ i * $ interval_size ) ; } return ( 3 * $ interval_size / 8 ) * $ sum ; } $ interval_limit = 10 ; $ lower_limit = 1 ; $ upper_limit = 10 ; $ integral_res = calculate ( $ lower_limit , $ upper_limit , $ interval_limit ) ; echo $ integral_res ; ? >"}
{"text": "Program untuk panjang fokus lensa | Fungsi untuk menentukan panjang fokus kanta; pembolehubah untuk menyimpan jarak antara lensa dan imej; pemboleh ubah untuk menyimpan jarak antara lensa dan objek", "code": "< ? php function focal_length ( $ image_distance , $ object_distance ) { return 1 / ( ( 1 / $ image_distance ) + ( 1 / $ object_distance ) ) ; } $ image_distance = 2 ; $ object_distance = 50 ; echo \" Focal ▁ length ▁ of ▁ a ▁ lens ▁ is ▁ \" , focal_length ( $ image_distance , $ object_distance ) , \" ▁ units ▁ . \" ; ? >"}
{"text": "Kira nombor dalam julat l | Semak sama ada nombor itu boleh dibahagikan dengan digit. ; berfungsi untuk mengira bilangan nombor; Fungsi pemacu", "code": "< ? php function check ( $ n ) { $ m = $ n ; while ( $ n ) { $ r = $ n % 10 ; if ( $ r > 0 ) if ( ( $ m % $ r ) != 0 ) return false ; $ n /= 10 ; } return true ; } function countIn ( $ l , $ r ) { $ ans = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) if ( check ( $ i ) ) $ ans += 1 ; return $ ans ; } $ l = 10 ; $ r = 20 ; echo countIn ( $ l , $ r ) ;"}
{"text": "Jumlah siri 1 / (1 * 2) + 1 / (2 * 3) + 1 / (3 * 4) + 1 / (4 * 5) +. . . . . | fungsi untuk mencari jumlah siri yang diberikan; Pengkomputeran Jumlah Jangka Jangka; Kod pemacu", "code": "< ? php function sumOfTheSeries ( $ n ) { $ sum = 0.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 1.0 / ( $ i * ( $ i + 1 ) ) ; return $ sum ; } $ n = 10 ; echo sumOfTheSeries ( $ n ) ; ? >"}
{"text": "Jumlah siri (n / 1) + (n / 2) + (n / 3) + (n / 4) + ... .... + (n / n) | fungsi untuk mencari jumlah siri; Kod pemacu", "code": "< ? php function sum ( $ n ) { $ root = intval ( sqrt ( $ n ) ) ; $ ans = 0 ; for ( $ i = 1 ; $ i <= $ root ; $ i ++ ) $ ans += intval ( $ n / $ i ) ; $ ans = ( 2 * $ ans ) - ( $ root * $ root ) ; return $ ans ; } $ n = 35 ; echo ( sum ( $ n ) ) ; ? >"}
{"text": "Jumlah siri 2 + (2 + 4) + (2 + 4 + 6) + (2 + 4 + 6 + 8) + â € | â € | + (2 + 4 + 6 + 8 + â € |. fungsi untuk mencari jumlah siri yang diberikan; jumlah nombor semulajadi; jumlah kuadrat 1 st n bilangan semula jadi; Jumlah yang diperlukan; Kod pemacu", "code": "< ? php function sumOfTheSeries ( $ n ) { $ sum_n = ( $ n * ( $ n + 1 ) / 2 ) ; $ sum_sq_n = ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; return ( $ sum_n + $ sum_sq_n ) ; } $ n = 5 ; echo ( \" Sum ▁ = ▁ \" . sumOfTheSeries ( $ n ) ) ; ? >"}
{"text": "Jumlah kuadrat koefisien binomial | Mengembalikan jumlah persegi pekali binomial; Hitung nilai pekali binomial dengan cara bawah; Kes asas; Hitung nilai menggunakan nilai yang disimpan sebelumnya; Mencari jumlah persegi pekali binomial. ; Program yang didorong", "code": "< ? php function sumofsquare ( $ n ) { $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ n ) ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ C [ $ n ] [ $ i ] * $ C [ $ n ] [ $ i ] ) ; return $ sum ; } $ n = 4 ; echo sumofsquare ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari jumlah siri 1 + 2 + 2 + 3 + 3 + 3 +. . . + n | Fungsi yang menemui jumlah siri. ; Kod pemacu; Panggilan fungsi", "code": "< ? php function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ sum = $ sum + $ i ; return $ sum ; } $ n = 10 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text": "Cari jumlah pekali binomial indeks walaupun | Mengembalikan jumlah istilah indeks walaupun; Hitung nilai pekali binomial dengan cara bawah; Kes asas; Hitung nilai menggunakan nilai yang disimpan sebelumnya; Mencari jumlah istilah indeks walaupun. ; Kod pemacu", "code": "< ? php function evenSum ( $ n ) { $ C = array ( array ( ) ) ; $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ n ) ; $ j ++ ) { if ( $ j == 0 or $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i += 2 ) $ sum += $ C [ $ n ] [ $ i ] ; return $ sum ; } $ n = 4 ; echo evenSum ( $ n ) ; ? >"}
{"text": "Program untuk mencetak siri nombor segitiga sehingga n | Berfungsi untuk mencari nombor segi tiga; Kod pemacu", "code": "< ? php function triangular_series ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo ( \" ▁ \" . $ i * ( $ i + 1 ) / 2 . \" ▁ \" ) ; } $ n = 5 ; triangular_series ( $ n ) ; ? >"}
{"text": "Semak jika nombor boleh ditulis sebagai jumlah tiga bilangan bulat berturut -turut | Fungsi untuk memeriksa sama ada nombor boleh ditulis sebagai jumlah tiga bilangan bulat berturut -turut. ; jika n adalah pelbagai 3; lain cetak \" - 1\". ; Program Pemandu", "code": "< ? php function checksum ( $ n ) { if ( $ n % 3 == 0 ) echo $ n / 3 - 1 , \" ▁ \" , $ n / 3 , \" ▁ \" , $ n / 3 + 1 ; else echo \" - 1\" ; } $ n = 6 ; checksum ( $ n ) ; ? >"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | Fungsi utiliti untuk mencari jumlah semua pembahagi nombor sehingga 'n'; Kod pemacu", "code": "< ? php function divisorSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ sum += floor ( $ n / $ i ) * $ i ; return $ sum ; } $ n = 4 ; echo divisorSum ( $ n ) , \" STRNEWLINE \" ; $ n = 5 ; echo divisorSum ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "N | berfungsi untuk menilai nombor sopan nth; Kod pemacu", "code": "< ? php function polite ( $ n ) { $ n += 1 ; $ base = 2 ; return $ n + ( log ( ( $ n + ( log ( $ n ) / log ( $ base ) ) ) ) ) / log ( $ base ) ; } $ n = 7 ; echo ( ( int ) polite ( $ n ) ) ; ? >"}
{"text": "Cari Bilangan Langkah Tangga | Fungsi carian binari yang diubahsuai untuk menyelesaikan persamaan; jika pertengahan adalah penyelesaian kepada persamaan; Jika penyelesaian kami untuk persamaan terletak di antara pertengahan dan pertengahan - 1; jika penyelesaian kepada persamaan lebih besar daripada pertengahan; jika penyelesaian kepada persamaan kurang dari pertengahan; Kod pemacu; Panggil kaedah carian binari untuk menyelesaikan had 1 hingga t; Kerana corak kami bermula dari 2, 3, 4, 5. . Jadi, kita tolak 1 dari ANS", "code": "< ? php function solve ( $ low , $ high , $ T ) { while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( ( $ mid * ( $ mid + 1 ) ) == $ T ) return $ mid ; if ( $ mid > 0 && ( $ mid * ( $ mid + 1 ) ) > $ T && ( $ mid * ( $ mid - 1 ) ) <= $ T ) return $ mid - 1 ; if ( ( $ mid * ( $ mid + 1 ) ) > $ T ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return -1 ; } $ T = 15 ; $ ans = solve ( 1 , $ T , 2 * $ T ) ; if ( $ ans != -1 ) $ ans -- ; echo \" Number ▁ of ▁ stair ▁ steps ▁ = ▁ \" , $ ans , \" STRNEWLINE \" ; ? >"}
{"text": "Semak Integer Overflow pada pendaraban | Fungsi untuk memeriksa sama ada terdapat limpahan dalam A * B atau tidak. Ia kembali benar jika terdapat limpahan. ; Semak sama ada salah satu daripada mereka adalah sifar; Kod pemacu", "code": "< ? php function isOverflow ( $ a , $ b ) { if ( $ a == 0 $ b == 0 ) return false ; $ result = $ a * $ b ; if ( $ a == ( int ) $ result / $ b ) return false ; else return true ; } $ a = 10000000000 ; $ b = -10000000000 ; if ( isOverflow ( $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Jumlah nombor pertama N yang pertama dalam kerumitan O (1) | Mengembalikan jumlah nombor pertama yang pertama; Kod pemacu", "code": "< ? php function oddSum ( $ n ) { $ sum = 0 ; $ curr = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ curr ; $ curr += 2 ; } return $ sum ; } $ n = 20 ; echo \" ▁ Sum ▁ of ▁ first ▁ \" , $ n , \" ▁ Odd ▁ Numbers ▁ is : ▁ \" , oddSum ( $ n ) ; ? >"}
{"text": "Jumlah nombor pertama N yang pertama dalam kerumitan O (1) | Mengembalikan jumlah nombor pertama yang pertama; Kod pemacu", "code": "< ? php function oddSum ( $ n ) { return ( $ n * $ n ) ; } $ n = 20 ; echo \" ▁ Sum ▁ of ▁ first ▁ \" , $ n , \" ▁ Odd ▁ Numbers ▁ is : ▁ \" , oddSum ( $ n ) ; ? >"}
{"text": "K | Mengembalikan jumlah nombor pertama yang pertama; Kira faktor utama semua nombor sehingga b. ; Cetak semua nombor dengan faktor utama; Kod pemacu", "code": "< ? php function printKPFNums ( $ A , $ B , $ K ) { $ prime = array_fill ( true , $ B + 1 , NULL ) ; $ p_factors = array_fill ( 0 , $ B + 1 , NULL ) ; for ( $ p = 2 ; $ p <= $ B ; $ p ++ ) if ( $ p_factors [ $ p ] == 0 ) for ( $ i = $ p ; $ i <= $ B ; $ i += $ p ) $ p_factors [ $ i ] ++ ; for ( $ i = $ A ; $ i <= $ B ; $ i ++ ) if ( $ p_factors [ $ i ] == $ K ) echo $ i . \" \" ; } $ A = 14 ; $ B = 18 ; $ K = 2 ; printKPFNums ( $ A , $ B , $ K ) ; ? >"}
{"text": "Pertanyaan untuk perbezaan maksimum antara nombor perdana dalam julat yang diberikan | Program PHP untuk mencari perbezaan maksimum antara dua nombor utama dalam julat yang diberikan; Penapis precompute, array awalan, array akhiran; Ayak eratosthenes; Arahan awalan precomputing. ; Arahan akhiran precompute. ; Berfungsi untuk menyelesaikan setiap pertanyaan; Kod pemacu", "code": "< ? php $ MAX = 100005 ; function precompute ( & $ prefix , & $ suffix ) { global $ MAX ; $ prime = array_fill ( 0 , $ MAX , true ) ; for ( $ i = 2 ; $ i * $ i < $ MAX ; $ i ++ ) { if ( $ prime [ $ i ] ) { for ( $ j = $ i * $ i ; $ j < $ MAX ; $ j += $ i ) $ prime [ $ j ] = false ; } } $ prefix [ 1 ] = 1 ; $ suffix [ $ MAX - 1 ] = 1e9 + 7 ; for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) { if ( $ prime [ $ i ] ) $ prefix [ $ i ] = $ i ; else $ prefix [ $ i ] = $ prefix [ $ i - 1 ] ; } for ( $ i = $ MAX - 1 ; $ i > 1 ; $ i -- ) { if ( $ prime [ $ i ] ) $ suffix [ $ i ] = $ i ; else $ suffix [ $ i ] = $ suffix [ $ i + 1 ] ; } } function query ( $ prefix , $ suffix , $ L , $ R ) { if ( $ prefix [ $ R ] < $ L $ suffix [ $ L ] > $ R ) return 0 ; else return $ prefix [ $ R ] - $ suffix [ $ L ] ; } $ q = 3 ; $ L = array ( 2 , 2 , 24 ) ; $ R = array ( 5 , 2 , 28 ) ; $ prefix = array_fill ( 0 , $ MAX + 1 , 0 ) ; $ suffix = array_fill ( 0 , $ MAX + 1 , 0 ) ; precompute ( $ prefix , $ suffix ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo query ( $ prefix , $ suffix , $ L [ $ i ] , $ R [ $ i ] ) . \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah siri 1 + x / 1 + x ^ 2/2 + x ^ 3/3 +. . + x ^ n / n | Kod untuk mencetak jumlah siri; Kod pemacu", "code": "< ? php function sum ( $ x , $ n ) { $ i ; $ total = 1.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ total = $ total + ( pow ( $ x , $ i ) / $ i ) ; return $ total ; } $ x = 2 ; $ n = 5 ; echo ( sum ( $ x , $ n ) ) ; ? >"}
{"text": "Cari jika nombor adalah sebahagian daripada AP yang elemen dan perbezaan pertama diberikan | mengembalikan ya jika wujud lain tidak. ; Jika perbezaan adalah 0, maka x mestilah sama dengan A; Perbezaan lain antara x dan A mesti dibahagikan dengan d. ; Kod pemacu.", "code": "< ? php function isMember ( $ a , $ d , $ x ) { if ( $ d == 0 ) return ( $ x == $ a ) ; return ( ( $ x - $ a ) % $ d == 0 && ( $ x - $ a ) / $ d >= 0 ) ; } $ a = 1 ; $ x = 7 ; $ d = 3 ; if ( isMember ( $ a , $ d , $ x ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak sama ada nombor boleh diwakili oleh jumlah dua dataran | Fungsi untuk memeriksa sama ada terdapat dua nombor jumlah yang dikelilingi olehnya. ; Kod pemacu", "code": "< ? php function sumSquare ( int $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j * $ j <= $ n ; $ j ++ ) if ( $ i * $ i + $ j * $ j == $ n ) { echo $ i , \" ^ 2 ▁ + ▁ \" , $ j , \" ^ 2\" ; return true ; } return false ; } $ n = 25 ; if ( sumSquare ( $ n ) ) echo \" ▁ STRNEWLINE \" , \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Akar terkecil persamaan x ^ 2 + s (x) * x | fungsi untuk memeriksa sama ada jumlah digit adalah sama dengan penjumlahan yang diandaikan; Kirakan jumlah digit; berfungsi untuk mencari akar terbesar yang mungkin. ; ITERATE untuk semua jumlah digit yang mungkin. ; Semak jika diskriminasi adalah persegi yang sempurna. ; Periksa sama ada diskriminasi adalah persegi yang sempurna dan jika ia sebagai akar perefect persamaan; Fungsi mengembalikan jawapan; Kod pemacu", "code": "< ? php function check ( $ a , $ b ) { $ c = 0 ; while ( $ a != 0 ) { $ c = $ c + $ a % 10 ; $ a = ( int ) ( $ a / 10 ) ; } return ( $ c == $ b ) ? true : false ; } function root ( $ n ) { $ found = false ; $ mx = 1000000000000000001 ; for ( $ i = 0 ; $ i <= 90 ; $ i ++ ) { $ s = $ i * $ i + 4 * $ n ; $ sq = ( int ) ( sqrt ( $ s ) ) ; if ( $ sq * $ sq == $ s && check ( ( int ) ( ( $ sq - $ i ) / 2 ) , $ i ) ) { $ found = true ; $ mx = min ( $ mx , ( int ) ( ( $ sq - $ i ) / 2 ) ) ; } } if ( $ found ) return $ mx ; else return -1 ; } $ n = 110 ; echo root ( $ n ) ; ? >"}
{"text": "Jumlah digit nombor yang diberikan kepada kuasa tertentu | Fungsi untuk mengira jumlah; Kod pemacu", "code": "< ? php function calculate ( $ n , $ power ) { $ sum = 0 ; $ bp = ( int ) pow ( $ n , $ power ) ; while ( $ bp != 0 ) { $ d = $ bp % 10 ; $ sum += $ d ; $ bp /= 10 ; } return $ sum ; } $ n = 5 ; $ power = 4 ; echo ( calculate ( $ n , $ power ) ) ; ? >"}
{"text": "Co | Fungsi utiliti; fungsi untuk memeriksa sama ada pasangan adalah co - perdana atau tidak; berfungsi untuk mencari dan mencetak pasangan perdana; Kod pemacu", "code": "< ? php function gcd ( $ num1 , $ num2 ) { while ( $ num2 != 0 ) { $ t = $ num1 % $ num2 ; $ num1 = $ num2 ; $ num2 = $ t ; } return $ num1 ; } function coprime ( $ a , $ b ) { if ( gcd ( $ a , $ b ) == 1 ) return 1 ; else return 0 ; } function pairSum ( $ n ) { $ mid = ( int ) ( ( $ n / 2 ) ) ; for ( $ i = $ mid ; $ i >= 1 ; $ i -- ) { if ( coprime ( $ i , $ n - $ i ) == 1 ) { echo $ i . \" ▁ \" . ( $ n - $ i ) ; break ; } } } $ n = 11 ; pairSum ( $ n ) ; ? >"}
{"text": "Program untuk Quotient dan Baki Besar Besar | Berfungsi untuk mengira modulus; Simpan modulus nombor besar; Lakukan langkah demi langkah; Kemas kini modulo dengan menggabungkan digit semasa. ; Kemas kini Quotient; Kemas kini mod untuk lelaran seterusnya. ; Bendera digunakan untuk mengeluarkan sifar permulaan; Kod pemacu", "code": "< ? php function modBigNumber ( $ num , $ m ) { $ vec ; $ x = 0 ; $ mod = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num ) ; $ i ++ ) { $ digit = $ num [ $ i ] - '0' ; $ mod = $ mod * 10 + $ digit ; $ quo = ( int ) ( $ mod / $ m ) ; $ vec [ $ x ++ ] = $ quo ; $ mod = $ mod % $ m ; } echo \" Remainder ▁ : ▁ \" . $ mod . \" STRNEWLINE \" ; echo \" Quotient ▁ : ▁ \" ; $ zeroflag = 0 ; for ( $ i = 0 ; $ i < $ x ; $ i ++ ) { if ( $ vec [ $ i ] == 0 && $ zeroflag == 0 ) continue ; $ zeroflag = 1 ; echo $ vec [ $ i ] ; } return ; } $ num = \"14598499948265358486\" ; $ m = 487 ; modBigNumber ( $ num , $ m ) ; ? >"}
{"text": "Pertanyaan untuk mencari sama ada nombor mempunyai empat faktor yang berbeza atau tidak | Memulakan pembolehubah global mengikut keadaan yang diberikan supaya dapat diakses oleh semua fungsi; Fungsi untuk mengira semua nombor yang mempunyai empat faktor yang berbeza; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Memulakan array Perdana [] yang akan mengandungi semua prima dari 1 - n; Melangkah ke atas semua nombor utama; Tanda akar kiub nombor perdana; Menandakan produk nombor utama; Kod pemacu", "code": "< ? php $ N = 1000001 ; $ fourDiv = array_fill ( 0 , $ N + 1 , false ) ; function fourDistinctFactors ( ) { global $ N ; global $ fourDiv ; $ primeAll = array_fill ( 0 , $ N + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ N ; $ p ++ ) { if ( $ primeAll [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ N ; $ i += $ p ) $ primeAll [ $ i ] = false ; } } $ prime ; $ x = 0 ; for ( $ p = 2 ; $ p <= $ N ; $ p ++ ) if ( $ primeAll [ $ p ] ) $ prime [ $ x ++ ] = $ p ; for ( $ i = 0 ; $ i < $ x ; ++ $ i ) { $ p = $ prime [ $ i ] ; if ( 1 * $ p * $ p * $ p <= $ N ) $ fourDiv [ $ p * $ p * $ p ] = true ; for ( $ j = $ i + 1 ; $ j < $ x ; ++ $ j ) { $ q = $ prime [ $ j ] ; if ( 1 * $ p * $ q > $ N ) break ; $ fourDiv [ $ p * $ q ] = true ; } } } fourDistinctFactors ( ) ; $ num = 10 ; if ( $ fourDiv [ $ num ] ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; $ num = 12 ; if ( $ fourDiv [ $ num ] ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Leonardo Number | Program rekursif mudah untuk mencari nombor Leonardo. ; Kod pemacu", "code": "< ? php function leonardo ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] + 1 ; return $ dp [ $ n ] ; } echo leonardo ( 3 ) ; ? >"}
{"text": "Penguraian Cholesky: Penguraian Matriks | Program PHP untuk menguraikan matriks menggunakan penguraian Cholesky; Menguraikan matriks ke dalam segi tiga yang lebih rendah; penjumlahan untuk pepenjuru; Menilai l (i, j) menggunakan l (j, j); Memaparkan segi tiga yang lebih rendah dan transposinya; Rendah segi tiga; Transpose segi tiga yang lebih rendah; Kod pemacu", "code": "< ? php $ MAX = 100 ; function Cholesky_Decomposition ( $ matrix , $ n ) { $ lower ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ lower [ $ i ] [ $ j ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { $ sum = 0 ; if ( $ j == $ i ) { for ( $ k = 0 ; $ k < $ j ; $ k ++ ) $ sum += pow ( $ lower [ $ j ] [ $ k ] , 2 ) ; $ lower [ $ j ] [ $ j ] = sqrt ( $ matrix [ $ j ] [ $ j ] - $ sum ) ; } else { for ( $ k = 0 ; $ k < $ j ; $ k ++ ) $ sum += ( $ lower [ $ i ] [ $ k ] * $ lower [ $ j ] [ $ k ] ) ; $ lower [ $ i ] [ $ j ] = ( $ matrix [ $ i ] [ $ j ] - $ sum ) / $ lower [ $ j ] [ $ j ] ; } } } echo \" TABSYMBOL Lower ▁ Triangular \" . str_pad ( \" Transpose \" , 30 , \" ▁ \" , STR_PAD_BOTH ) . \" STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo str_pad ( $ lower [ $ i ] [ $ j ] , 6 , \" ▁ \" , STR_PAD_BOTH ) . \" TABSYMBOL \" ; echo \" TABSYMBOL \" ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo str_pad ( $ lower [ $ j ] [ $ i ] , 6 , \" ▁ \" , STR_PAD_BOTH ) . \" TABSYMBOL \" ; echo \" STRNEWLINE \" ; } } $ n = 3 ; $ matrix = array ( array ( 4 , 12 , -16 ) , array ( 12 , 37 , -43 ) , array ( -16 , -43 , 98 ) ) ; Cholesky_Decomposition ( $ matrix , $ n ) ; ? >"}
{"text": "Program untuk jumlah siri aritmetik | Kod PHP yang cekap untuk mencari jumlah siri aritmetik. ; Kod pemacu", "code": "< ? php function sumOfAP ( $ a , $ d , $ n ) { $ sum = ( $ n / 2 ) * ( 2 * $ a + ( $ n - 1 ) * $ d ) ; return $ sum ; } $ n = 20 ; $ a = 2.5 ; $ d = 1.5 ; echo ( sumOfAP ( $ a , $ d , $ n ) ) ; ? >"}
{"text": "Program untuk jumlah Cube Nombor Natural Pertama | Mengembalikan jumlah nombor semulajadi n pertama; Kod pemacu", "code": "< ? php function sumOfSeries ( $ n ) { $ x ; if ( $ n % 2 == 0 ) $ x = ( $ n / 2 ) * ( $ n + 1 ) ; else $ x = ( ( $ n + 1 ) / 2 ) * $ n ; return $ x * $ x ; } $ n = 5 ; echo sumOfSeries ( $ n ) ; ? >"}
{"text": "Nilai maksimum | | arr [i] | Program PHP untuk mencari nilai maksimum | arr [i] - arr [j] | + | i - j | ; Pulangan nilai maksimum | arr [i] - arr [j] | + | i - j | ; Melangkah dua untuk gelung, satu untuk saya dan satu lagi untuk j. ; Menilai | arr [i] - arr [j] | + | i - j | dan bandingkan dengan maksimum sebelumnya. ; Kod pemacu", "code": "< ? php $ MAX = 10 ; function findValue ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ ans = max ( $ ans , abs ( $ arr [ $ i ] - $ arr [ $ j ] ) + abs ( $ i - $ j ) ) ; return $ ans ; } $ arr = array ( 1 , 2 , 3 , 1 ) ; $ n = count ( $ arr ) ; echo findValue ( $ arr , $ n ) ; ? >"}
{"text": "Nilai maksimum | | arr [i] | Pulangan maksimum | arr [i] - arr [j] | + | i - j | ; Mengira first_array dan second_array; Mencari nilai maksimum dan minimum dalam first_array; Menyimpan perbezaan antara nilai maksimum dan minimum dalam first_array; Mencari nilai maksimum dan minimum dalam Second_array; Menyimpan perbezaan antara nilai maksimum dan minimum dalam Second_array; Kod pemacu", "code": "< ? php function findValue ( $ arr , $ n ) { $ a [ ] = array ( ) ; $ b = array ( ) ; $ tmp ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = ( $ arr [ $ i ] + $ i ) ; $ b [ $ i ] = ( $ arr [ $ i ] - $ i ) ; } $ x = $ a [ 0 ] ; $ y = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ x ) $ x = $ a [ $ i ] ; if ( $ a [ $ i ] < $ y ) $ y = $ a [ $ i ] ; } $ ans1 = ( $ x - $ y ) ; $ x = $ b [ 0 ] ; $ y = $ b [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ b [ $ i ] > $ x ) $ x = $ b [ $ i ] ; if ( $ b [ $ i ] < $ y ) $ y = $ b [ $ i ] ; } $ ans2 = ( $ x - $ y ) ; return max ( $ ans1 , $ ans2 ) ; } $ arr = array ( 1 , 2 , 3 , 1 ) ; $ n = count ( $ arr ) ; echo findValue ( $ arr , $ n ) ; ? >"}
{"text": "Bilangan subarray yang mempunyai produk kurang daripada k | Program PHP untuk mengira subarray yang mempunyai produk kurang daripada k. ; Kaunter untuk elemen tunggal; Pelbagai subarray; Jika pelbagai ini kurang daripada k, maka kenaikan; Kod pemacu", "code": "< ? php function countsubarray ( $ array , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ array [ $ i ] < $ k ) $ count ++ ; $ mul = $ array [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ mul = $ mul * $ array [ $ j ] ; if ( $ mul < $ k ) $ count ++ ; else break ; } } return $ count ; } $ array = array ( 1 , 2 , 3 , 4 ) ; $ k = 10 ; $ size = sizeof ( $ array ) ; $ count = countsubarray ( $ array , $ size , $ k ) ; echo ( $ count . \" \" ) ; ? >"}
{"text": "Program yang cekap untuk mencetak bilangan faktor nombor n | Program PHP untuk mengira bilangan faktor pelbagai bilangan bulat; berfungsi untuk menjana semua faktor utama nombor dari 1 hingga 10 ^ 6; Memulakan semua kedudukan dengan nilai mereka. ; Memulakan semua gandaan 2 dengan 2; Versi Sieve of Eratosthenes yang diubahsuai untuk menyimpan faktor utama terkecil yang membahagikan setiap nombor. ; Semak sama ada ia tidak mempunyai faktor utama. ; Memulakan j bermula dari i * i; Jika ia tidak mempunyai faktor utama sebelum ini, maka menyimpan pembahagi utama terkecil; berfungsi untuk mengira bilangan faktor; menyimpan nombor utama terkecil yang membahagikan n; menyimpan kiraan bilangan kali nombor utama membahagikan n. ; mengurangkan kepada nombor seterusnya selepas pemfaktoran utama N; palsu apabila pemfaktoran utama dilakukan; Jika nombor perdana yang sama membahagikan n, maka kami meningkatkan kiraan; Jika faktor utama yang baru yang mempraktikkan n, maka kami sekali lagi menetapkan c = 1 dan menukar DUP ke faktor utama yang baru, dan memohon formula yang dijelaskan di atas. ; Perdana mempengaruhi nombor; untuk faktor utama yang terakhir; menjana faktor utama nombor sehingga 10 ^ 6", "code": "< ? php $ MAX = 1000001 ; $ factor = array_fill ( 0 , $ MAX + 1 , 0 ) ; function generatePrimeFactors ( ) { global $ factor ; global $ MAX ; $ factor [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) $ factor [ $ i ] = $ i ; for ( $ i = 4 ; $ i < $ MAX ; $ i += 2 ) $ factor [ $ i ] = 2 ; for ( $ i = 3 ; $ i * $ i < $ MAX ; $ i ++ ) { if ( $ factor [ $ i ] == $ i ) { for ( $ j = $ i * $ i ; $ j < $ MAX ; $ j += $ i ) { if ( $ factor [ $ j ] == $ j ) $ factor [ $ j ] = $ i ; } } } } function calculateNoOFactors ( $ n ) { global $ factor ; if ( $ n == 1 ) return 1 ; $ ans = 1 ; $ dup = $ factor [ $ n ] ; $ c = 1 ; $ j = ( int ) ( $ n / $ factor [ $ n ] ) ; while ( $ j != 1 ) { if ( $ factor [ $ j ] == $ dup ) $ c += 1 ; else { $ dup = $ factor [ $ j ] ; $ ans = $ ans * ( $ c + 1 ) ; $ c = 1 ; } $ j = ( int ) ( $ j / $ factor [ $ j ] ) ; } $ ans = $ ans * ( $ c + 1 ) ; return $ ans ; } generatePrimeFactors ( ) ; $ a = array ( 10 , 30 , 100 , 450 , 987 ) ; $ q = sizeof ( $ a ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo calculateNoOFactors ( $ a [ $ i ] ) . \" ▁ \" ; ? >"}
{"text": "Digit | berfungsi untuk menghasilkan dan mencetak urutan produk digit; Array yang menyimpan urutan; Pembolehubah sementara untuk menyimpan produk; Memulakan elemen pertama array dengan 1; Jalankan gelung dari 1 hingga n. Semak sama ada nombor sebelumnya adalah satu digit atau tidak. Jika ya maka produk = 1 lain mengambil modulus. Kemudian sekali lagi periksa sama ada nombor sebelumnya adalah satu digit atau tidak jika ya kemudian simpan nombor sebelumnya, lain simpan nilai pertamanya maka untuk setiap saya menyimpan nilai dalam array. ; Urutan cetak; Nilai n; Fungsi panggilan", "code": "< ? php function digit_product_Sum ( $ N ) { $ a = array_fill ( 0 , $ N , 0 ) ; $ product = 1 ; $ a [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ product = ( int ) ( $ a [ $ i - 1 ] / 10 ) ; if ( $ product == 0 ) $ product = 1 ; else $ product = $ a [ $ i - 1 ] % 10 ; $ val = ( int ) ( $ a [ $ i - 1 ] / 10 ) ; if ( $ val == 0 ) $ val = $ a [ $ i - 1 ] ; $ a [ $ i ] = $ a [ $ i - 1 ] + ( $ val * $ product ) ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) echo $ a [ $ i ] . \" ▁ \" ; } $ N = 10 ; digit_product_Sum ( $ N ) ; ? >"}
{"text": "Geometric min (dua kaedah) | Fungsi untuk mengira min geometri dan pulangan nilai terapung. ; mengisytiharkan pemboleh ubah produk dan memulakannya kepada 1 .; Kirakan produk semua elemen dalam array. ; Kirakan geometri min melalui formula POW (produk, 1 / n) dan kembalikan nilai kepada fungsi utama. ; Kod pemacu", "code": "< ? php function geometricMean ( $ arr , $ n ) { $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product = $ product * $ arr [ $ i ] ; $ gm = pow ( $ product , ( float ) ( 1 / $ n ) ) ; return $ gm ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ) ; $ n = sizeof ( $ arr ) ; echo ( geometricMean ( $ arr , $ n ) ) ; ? >"}
{"text": "Semak sama ada nombor boleh dinyatakan sebagai produk nombor digit tunggal | berfungsi untuk memeriksa sama ada nombor boleh dinyatakan sebagai produk nombor digit tunggal; Jika 'n' adalah nombor digit tunggal, maka ia boleh dinyatakan; Tentukan pelbagai nombor nombor utama digit; berulang kali membahagikan 'n' oleh nombor perdana yang diberikan sehingga semua nombor digunakan atau 'n' 1; jika benar, maka 'n' boleh dinyatakan; Kod pemacu", "code": "< ? php function productOfSingelDgt ( $ n , $ SIZE ) { if ( $ n >= 0 && $ n <= 9 ) return true ; $ prime = array ( 2 , 3 , 5 , 7 ) ; for ( $ i = 0 ; $ i < $ SIZE && $ n > 1 ; $ i ++ ) while ( $ n % $ prime [ $ i ] == 0 ) $ n = $ n / $ prime [ $ i ] ; return ( $ n == 1 ) ; } $ SIZE = 4 ; $ n = 24 ; if ( productOfSingelDgt ( $ n , $ SIZE ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Program untuk mencari jumlah nombor natural pertama | Mengembalikan jumlah nombor semulajadi n pertama; Jika n adalah ganjil, (n + 1) mestilah walaupun; Kod pemacu", "code": "< ? php function findSum ( $ n ) { if ( $ n % 2 == 0 ) return ( $ n / 2 ) * ( $ n + 1 ) ; else return ( ( $ n + 1 ) / 2 ) * $ n ; } $ n = 5 ; echo findSum ( $ n ) ; ? >"}
{"text": "Bilangan Maksimum Faktor Perdana yang unik | Mengembalikan bilangan faktor utama bagi mana -mana nombor dalam [1, n]; Berdasarkan penapis Eratosthenes; Jika p adalah perdana; Kami hanya melipatgandakan set nombor utama manakala produk lebih kecil daripada n. ; Kod pemacu", "code": "< ? php function maxPrimefactorNum ( $ N ) { if ( $ N < 2 ) return 0 ; $ arr = array_fill ( 0 , ( $ N + 1 ) , true ) ; $ prod = 1 ; $ res = 0 ; for ( $ p = 2 ; $ p * $ p <= $ N ; $ p ++ ) { if ( $ arr [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ N ; $ i += $ p ) $ arr [ $ i ] = false ; $ prod *= $ p ; if ( $ prod > $ N ) return $ res ; $ res ++ ; } } return $ res ; } $ N = 500 ; echo maxPrimefactorNum ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencetak jadual pendaraban nombor | Tukar Nombor Input Perubahan di sini ke; perubahan hasil.", "code": "< ? php $ n = 8 ; $ range = 12 ; for ( $ i = 1 ; $ i <= $ range ; ++ $ i ) echo $ n , \" ▁ * ▁ \" , $ i , \" ▁ = ▁ \" , $ n * $ i , \" STRNEWLINE \" ; ? >"}
{"text": "Untuk memeriksa nombor adalah palindrome atau tidak tanpa menggunakan ruang tambahan | Fungsi untuk memeriksa sama ada nombor yang diberikan adalah palindrome atau tidak tanpa menggunakan ruang tambahan; Cari pembahagi yang sesuai untuk mengekstrak digit terkemuka; Jika digit pertama dan terakhir tidak sama pulangan palsu; Mengeluarkan digit terkemuka dan trailing dari nombor; Mengurangkan pembahagi dengan faktor 2 sebagai 2 digit dijatuhkan; Kod pemacu", "code": "< ? php function isPalindrome ( $ n ) { $ divisor = 1 ; while ( $ n / $ divisor >= 10 ) $ divisor *= 10 ; while ( $ n != 0 ) { $ leading = floor ( $ n / $ divisor ) ; $ trailing = $ n % 10 ; if ( $ leading != $ trailing ) return false ; $ n = ( $ n % $ divisor ) / 10 ; $ divisor = $ divisor / 100 ; } return true ; } if ( isPalindrome ( 1001 ) == true ) echo \" Yes , ▁ it ▁ is ▁ Palindrome \" ; else echo \" No , ▁ not ▁ Palindrome \" ; ? >"}
{"text": "Cari sama ada integer yang diberikan adalah kuasa 3 atau tidak | Pulangan benar jika n adalah kuasa 3, lain -lain palsu; Kuasa maksimum 3 nilai yang dapat dipegang integer ialah 1162261467 (3 ^ 19). ; Kod pemacu", "code": "< ? php function check ( $ n ) { return 1162261467 % $ n == 0 ; } $ n = 9 ; if ( check ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Nombor Demlo (Square of 11 ... .1) | Untuk mengembalikan nombor Demlo. Fungsi ini mengandaikan bahawa panjang STR lebih kecil daripada 10; Tambah nombor untuk menyiapkan saiz str dan kemudian tambahkan nombor terbalik kepadanya; Kod pemacu", "code": "< ? php function printDemlo ( $ str ) { $ len = strlen ( $ str ) ; $ res = \" \" ; for ( $ i = 1 ; $ i <= $ len ; $ i ++ ) $ res . = chr ( $ i + 48 ) ; for ( $ i = $ len - 1 ; $ i >= 1 ; $ i -- ) $ res . = chr ( $ i + 48 ) ; return $ res ; } $ str = \"111111\" ; echo printDemlo ( $ str ) ; ? >"}
{"text": "Bilangan kali nombor boleh digantikan dengan jumlah digitnya sehingga ia hanya mengandungi satu digit | Program PHP untuk mengira bilangan kali kita perlu menambah digit untuk mendapatkan satu digit. ; Di sini kedai pembolehubah kiraan berapa kali kita melakukan jumlah digit dan sementara_sum selalu menyimpan jumlah sementara yang kita dapatkan pada setiap lelaran. ; Dalam gelung ini, kita sentiasa mengira jumlah digit dalam pembolehubah sementara dan mengubahnya menjadi string str sehingga panjangnya menjadi 1 dan meningkatkan kiraan dalam setiap lelaran. ; pengkomputeran jumlah digitnya; Menukar sementara_sum ke string str sekali lagi. ; meningkatkan kiraan; Kod pemacu", "code": "< ? php function NumberofTimes ( $ str ) { $ temporary_sum = 0 ; $ count = 0 ; while ( strlen ( $ str ) > 1 ) { $ temporary_sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ temporary_sum += ( $ str [ $ i ] - '0' ) ; $ str = ( string ) ( $ temporary_sum ) ; $ count ++ ; } return $ count ; } $ s = \"991\" ; echo NumberofTimes ( $ s ) ; ? >"}
{"text": "Mendaki N | fungsi mengembalikan bilangan cara; Kod pemacu", "code": "< ? php function calculateLeaps ( $ n ) { if ( $ n == 0 $ n == 1 ) { return 1 ; } else { $ leaps = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ leaps += calculateLeaps ( $ i ) ; return $ leaps ; } } echo calculateLeaps ( 4 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cetak angka terakhir k A ^ b (yang dibangkitkan ke kuasa b) | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; $ x = $ x % $ p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; berfungsi untuk mengira bilangan digit dalam x; berfungsi untuk mencetak digit terakhir A ^ b; Menjana 10 ^ k; Memanggil eksponensi modular; Mencetak sifar paling kiri. Oleh kerana (a ^ b) % k boleh mempunyai digit kurang maka k. Dalam hal ini kita perlu mencetak sifar; Jika temp tidak sifar maka cetak temp jika temp adalah sifar maka sudah dicetak; Kod pemacu", "code": "< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function numberOfDigits ( $ x ) { $ i = 0 ; while ( $ x ) { $ x = ( int ) $ x / 10 ; $ i ++ ; } return $ i ; } function printLastKDigits ( $ a , $ b , $ k ) { echo \" Last ▁ \" , $ k ; echo \" ▁ digits ▁ of ▁ \" , $ a ; echo \" ^ \" , $ b , \" ▁ = ▁ \" ; $ temp = 1 ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) $ temp *= 10 ; $ temp = power ( $ a , $ b , $ temp ) ; for ( $ i = 0 ; $ i < $ k - numberOfDigits ( $ temp ) ; $ i ++ ) echo 0 ; if ( $ temp ) echo $ temp ; } $ a = 11 ; $ b = 3 ; $ k = 2 ; printLastKDigits ( $ a , $ b , $ k ) ; ? >"}
{"text": "Nombor Adam | Untuk membalikkan nombor nombor; Ke nombor persegi; Untuk memeriksa nombor Adam; Square nombor pertama dan digit terbalik persegi nombor kedua; Jika terbalik B sama dengan nombor yang diberikan ialah nombor ADAM; Kod pemacu", "code": "< ? php function reverseDigits ( $ num ) { $ rev = 0 ; while ( $ num > 0 ) { $ rev = $ rev * 10 + $ num % 10 ; $ num = ( int ) $ num / 10 ; } return $ rev ; } function square ( $ num ) { return ( $ num * $ num ) ; } function checkAdamNumber ( $ num ) { $ a = square ( $ num ) ; $ b = square ( reverseDigits ( $ num ) ) ; if ( $ a == reverseDigits ( $ b ) ) return 0 ; return -1 ; } $ num = 12 ; if ( checkAdamNumber ( $ num ) ) echo \" Adam ▁ Number \" ; else echo \" Not ▁ a ▁ Adam ▁ Number \" ; ? >"}
{"text": "Kirakan pariti nombor menggunakan XOR dan Jadual Lihat | Menjana jadual rupa semasa pra -pemprosesan; Look_up adalah pengembangan makro untuk menjana jadual; Berfungsi untuk mencari pariti; Nombor dianggap sebagai 32 bit; Membahagikan nombor ke dalam ketulan 8 - bit semasa melakukan x - atau; Masalah nombor dengan 0xFF (11111111) untuk menghasilkan hasil 8 - bit yang sah; Kod pemacu; Hasilnya adalah 1 untuk pariti ganjil, 0 untuk pariti bahkan; Mencetak hasil yang diinginkan", "code": "< ? php #define P2 ( n )  n, n ^ 1, n ^ 1, n NEW_LINE #define P4 ( n )  P2(n), P2(n ^ 1),  NEW_LINE P2 ( n ^ 1 ) , P2 ( n ) #define P6 ( n )  P4(n), P4(n ^ 1),  NEW_LINE P4 ( n ^ 1 ) , P4 ( n ) #define LOOK_UP  P6(0), P6(1),  NEW_LINE P6 ( 1 ) , P6 ( 0 ) $ table = array ( LOOK_UP ) ; function Parity ( $ num ) { global $ table ; $ max = 16 ; while ( $ max >= 8 ) { $ num = $ num ^ ( $ num >> $ max ) ; $ max = ( int ) $ max / 2 ; } return $ table [ $ num & 0xff ] ; } $ num = 1742346774 ; $ result = Parity ( $ num ) ; if ( $ result == true ) echo \" Odd ▁ Parity \" ; else echo \" Even ▁ Parity \" ; ? >"}
{"text": "Kira jumlah digit dari 1 hingga n | Program PHP untuk mengira jumlah digit yang perlu kita tulis dari 1 hingga n; Number_of_digits menyimpan jumlah digit yang perlu kita tulis; Dalam gelung kita menurun 0, 9, 99 ... dari n hingga (n - i + 1) adalah lebih besar daripada 0 dan jumlahnya ke nombor_of_digit untuk mendapatkan jumlah yang diperlukan; Kod pemacu", "code": "< ? php function totalDigits ( $ n ) { $ number_of_digits = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i *= 10 ) $ number_of_digits += ( $ n - $ i + 1 ) ; return $ number_of_digits ; } $ n = 13 ; echo totalDigits ( $ n ) ; ? >"}
{"text": "Nombor dengan tepat 3 pembahagi | Menghasilkan semua prima sehingga mencetak dataran mereka; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cetak dataran prima sehingga n. ; Kod pemacu", "code": "< ? php function numbersWith3Divisors ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; $ prime [ 0 ] = $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } echo \" Numbers ▁ with ▁ 3 ▁ divisors ▁ : STRNEWLINE \" ; for ( $ i = 0 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ prime [ $ i ] ) echo $ i * $ i . \" ▁ \" ; } $ n = 96 ; numbersWith3Divisors ( $ n ) ; ? >"}
{"text": "Program untuk perpuluhan kepada penukaran heksadesimal | berfungsi untuk menukar perpuluhan ke hexadecimal; Char Array untuk menyimpan nombor heksadesimal; kaunter untuk array nombor heksadesimal; Pembolehubah sementara untuk menyimpan baki; Menyimpan baki dalam pembolehubah temp. ; Semak jika temp <10; Percetakan array nombor heksadesimal dalam urutan terbalik; Kod pemacu", "code": "< ? php function decToHexa ( $ n ) { $ hexaDeciNum ; $ i = 0 ; while ( $ n != 0 ) { $ temp = 0 ; $ temp = $ n % 16 ; if ( $ temp < 10 ) { $ hexaDeciNum [ $ i ] = chr ( $ temp + 48 ) ; $ i ++ ; } else { $ hexaDeciNum [ $ i ] = chr ( $ temp + 55 ) ; $ i ++ ; } $ n = ( int ) ( $ n / 16 ) ; } for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) echo $ hexaDeciNum [ $ j ] ; } $ n = 2545 ; decToHexa ( $ n ) ; ? >"}
{"text": "Program untuk perpuluhan kepada penukaran binari | berfungsi untuk menukar perpuluhan kepada binari; array untuk menyimpan nombor binari; kaunter untuk array binari; menyimpan sisa dalam array binari; mencetak array binari dalam urutan terbalik; Kod pemacu", "code": "< ? php function decToBinary ( $ n ) { $ binaryNum ; $ i = 0 ; while ( $ n > 0 ) { $ binaryNum [ $ i ] = $ n % 2 ; $ n = ( int ) ( $ n / 2 ) ; $ i ++ ; } for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) echo $ binaryNum [ $ j ] ; } $ n = 17 ; decToBinary ( $ n ) ; ? >"}
{"text": "Pecahkan nombor menjadi tiga bahagian | Berfungsi untuk mengira bilangan cara untuk membuat nombor n yang diberikan; Kod pemacu", "code": "< ? php function count_of_ways ( $ n ) { $ count ; $ count = ( $ n + 1 ) * ( $ n + 2 ) / 2 ; return $ count ; } $ n = 3 ; echo count_of_ways ( $ n ) ; ? >"}
{"text": "Melaksanakan *, | Berfungsi untuk membalikkan tanda menggunakan hanya \" +\" operator (ia adalah mudah dengan ' *' dibenarkan. Kita perlu melakukan a = ( - 1) * a; jika tanda adalah + ve gilirannya - ve - versa; Tanda akhir mestilah - ve;", "code": "< ? php function flipSign ( $ a ) { $ neg = 0 ; $ tmp = $ a < 0 ? 1 : -1 ; while ( $ a != 0 ) { $ neg += $ tmp ; $ a += $ tmp ; } return $ neg ; } function areDifferentSign ( $ a , $ b ) { return ( ( $ a < 0 && $ b > 0 ) || ( $ a > 0 && $ b < 0 ) ) ; } function sub ( $ a , $ b ) { return $ a + flipSign ( $ b ) ; } function mul ( $ a , $ b ) { if ( $ a < $ b ) return mul ( $ b , $ a ) ; $ sum = 0 ; for ( $ i = abs ( $ b ) ; $ i > 0 ; $ i -- ) $ sum += $ a ; if ( $ b < 0 ) $ sum = flipSign ( $ sum ) ; return $ sum ; } function division ( $ a , $ b ) { $ quotient = 0 ; $ divisor = flipSign ( abs ( $ b ) ) ; for ( $ dividend = abs ( $ a ) ; $ dividend >= abs ( $ divisor ) ; $ dividend += $ divisor ) $ quotient ++ ; if ( areDifferentSign ( $ a , $ b ) ) $ quotient = flipSign ( $ quotient ) ; return $ quotient ; } print ( \" Subtraction ▁ is ▁ \" . sub ( 4 , -2 ) . \" STRNEWLINE \" ) ; print ( \" Product ▁ is ▁ \" . mul ( -9 , 6 ) . \" STRNEWLINE \" ) ; list ( $ a , $ b ) = array ( 8 , 2 ) ; if ( $ b ) print ( \" Division ▁ is ▁ \" . division ( $ a , $ b ) ) ; else print ( \" Exception ▁ : - ▁ Divide ▁ by ▁ 0\" ) ; ? >"}
{"text": "Bilangan kumpulan saiz dua atau tiga dibahagi dengan 3 | Program PHP untuk mencari kumpulan 2 atau 3 yang jumlahnya boleh dibahagikan dengan 3; Memulakan kumpulan ke 0; Kumpulan kenaikan dengan selebihnya yang ditentukan; Kumpulan pulangan menggunakan formula; Kod pemacu", "code": "< ? php function numOfCombinations ( $ arr , $ N ) { $ C = array ( 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) ++ $ C [ $ arr [ $ i ] % 3 ] ; return $ C [ 1 ] * $ C [ 2 ] + $ C [ 0 ] * ( $ C [ 0 ] - 1 ) / 2 + $ C [ 0 ] * ( $ C [ 0 ] - 1 ) * ( $ C [ 0 ] - 2 ) / 6 + $ C [ 1 ] * ( $ C [ 1 ] - 1 ) * ( $ C [ 1 ] - 2 ) / 6 + $ C [ 2 ] * ( $ C [ 2 ] - 1 ) * ( $ C [ 2 ] - 2 ) / 6 + $ C [ 0 ] * $ C [ 1 ] * $ C [ 2 ] ; } $ arr1 = array ( 1 , 5 , 7 , 2 , 9 , 14 ) ; echo numOfCombinations ( $ arr1 , 6 ) , \" STRNEWLINE \" ; $ arr2 = array ( 3 , 6 , 9 , 12 ) ; echo numOfCombinations ( $ arr2 , 4 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika nombor boleh ditulis sebagai jumlah 'K' Nombor Perdana | Memeriksa sama ada nombor adalah perdana atau tidak; Semak nombor dari 2 hingga sqrt (x) jika ia boleh dibahagi pulangan palsu; Pulangan benar jika n boleh ditulis sebagai jumlah k prima; N <2 k terus kembali palsu; Jika k = 1 nilai pulangan bergantung kepada primal n; Jika n bahkan terus kembali benar; ; Jika n adalah ganjil, maka satu perdana mestilah 2. Semua prima yang lain adalah ganjil dan tidak boleh mempunyai jumlah pasangan yang sama. ; Jika k> = 3 kembali benar; ; Kod pemacu", "code": "< ? php function isprime ( $ x ) { for ( $ i = 2 ; $ i * $ i <= $ x ; $ i ++ ) if ( $ x % $ i == 0 ) return false ; return true ; } function isSumOfKprimes ( $ N , $ K ) { if ( $ N < 2 * $ K ) return false ; if ( $ K == 1 ) return isprime ( $ N ) ; if ( $ K == 2 ) { if ( $ N % 2 == 0 ) return true ; return isprime ( $ N - 2 ) ; } return true ; } $ n = 10 ; $ k = 2 ; if ( isSumOfKprimes ( $ n , $ k ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Kira jumlah pembahagi a atau b dalam julat tertentu | Fungsi utiliti untuk mencari GCD dua nombor; Fungsi utiliti untuk mencari LCM dua nombor; Fungsi untuk mengira semua pembahagi dalam julat tertentu; Cari LCM A dan B; Cari pembahagi biasa dengan menggunakan LCM; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { return ( $ a % $ b ) ? gcd ( $ b , $ a % $ b ) : $ b ; } function FindLCM ( $ a , $ b ) { return ( $ a * $ b ) / gcd ( $ a , $ b ) ; } function rangeDivisor ( $ m , $ n , $ a , $ b ) { $ lcm = FindLCM ( $ a , $ b ) ; $ a_divisor = $ n / $ a - ( $ m - 1 ) / $ a ; $ b_divisor = $ n / $ b - ( $ m - 1 ) / $ b ; $ common_divisor = $ n / $ lcm - ( $ m - 1 ) / $ lcm ; $ ans = $ a_divisor + $ b_divisor - $ common_divisor ; return $ ans ; } $ m = 3 ; $ n = 11 ; $ a = 2 ; $ b = 3 ; print ( ceil ( rangeDivisor ( $ m , $ n , $ a , $ b ) ) ) ; echo \" STRNEWLINE \" ; $ m = 11 ; $ n = 1000000 ; $ a = 6 ; $ b = 35 ; print ( ceil ( rangeDivisor ( $ m , $ n , $ a , $ b ) ) ) ; ? >"}
{"text": "Nombor yang mempunyai digit yang unik (atau berbeza) | Fungsi untuk mencetak nombor digit yang unik dalam julat dari L ke R. ; Mula melintasi nombor; Cari digit dan simpan hashnya; Jika digit berlaku lebih daripada 1 kali maka pecah; Num akan menjadi 0 hanya apabila di atas gelung tidak mendapat rehat yang bermaksud nombor itu unik jadi mencetaknya. ; Kod pemacu", "code": "< ? php function printUnique ( $ l , $ r ) { for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ num = $ i ; $ visited = ( false ) ; while ( $ num ) { if ( $ visited [ $ num % 10 ] ) $ visited [ $ num % 10 ] = true ; $ num = ( int ) $ num / 10 ; } if ( $ num == 0 ) echo $ i , \" ▁ \" ; } } $ l = 1 ; $ r = 20 ; printUnique ( $ l , $ r ) ; ? >"}
{"text": "Fibonacci Modulo P | Mengembalikan kedudukan nombor Fibonacci pertama yang modulo p ialah 0 .; Tambah dua sisa sebelumnya dan kemudian ambil modulo p. ; Kod pemacu", "code": "< ? php function findMinZero ( $ p ) { $ first = 1 ; $ second = 1 ; $ number = 2 ; $ next = 1 ; while ( $ next ) { $ next = ( $ first + $ second ) % $ p ; $ first = $ second ; $ second = $ next ; $ number ++ ; } return $ number ; } $ p = 7 ; echo \" Minimal ▁ zero ▁ is : ▁ \" , findMinZero ( $ p ) , \" STRNEWLINE \" ; ? >"}
{"text": "Kiub sempurna dalam julat | Kaedah mudah untuk mengira kiub antara a dan b; Melintasi semua nombor dalam julat yang diberikan dan satu demi satu cek jika nombor adalah perdana; Semak jika nombor semasa 'I' adalah kiub sempurna; Kod pemacu", "code": "< ? php function printCubes ( $ a , $ b ) { for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) { for ( $ j = 1 ; $ j * $ j * $ j <= $ i ; $ j ++ ) { if ( $ j * $ j * $ j == $ i ) { echo $ j * $ j * $ j , \" \" ; break ; } } } } $ a = 1 ; $ b = 100 ; echo \" Perfect ▁ cubes ▁ in ▁ given ▁ range : STRNEWLINE ▁ \" ; printCubes ( $ a , $ b ) ; ? >"}
{"text": "Menukar nombor sebenar (antara 0 dan 1) ke rentetan binari | Berfungsi untuk menukar nombor sebenar binari ke rentetan; Semak sama ada nombor antara 0 hingga 1 atau tidak; Menetapkan Had pada Panjang: 32 aksara. ; Bandingkan nombor itu kepada .5; Sekarang ia menjadi 0.25; Nilai input", "code": "< ? php function toBinary ( $ n ) { if ( $ n >= 1 $ n <= 0 ) return \" ERROR \" ; $ frac = 0.5 ; $ answer = \" . \" ; while ( $ n > 0 ) { if ( strlen ( $ answer ) >= 32 ) return \" ERROR \" ; if ( $ n >= $ frac ) { $ answer . = \"1\" ; $ n = $ n - $ frac ; } else { $ answer . = \"0\" ; } $ frac = ( $ frac / 2 ) ; } return $ answer ; } $ n = 0.625 ; $ result = toBinary ( $ n ) ; print ( \" ( 0\" . $ result . \" ) ▁ in ▁ base ▁ 2 STRNEWLINE \" ) ; $ m = 0.72 ; $ result = toBinary ( $ m ) ; print ( \" ( \" . $ result . \" ) \" ) ; ? >"}
{"text": "Memandangkan nombor n, cari digit k pertama n ^ n | Fungsi yang secara manual mengira n ^ n dan kemudian menghilangkan digit sehingga angka k kekal; Gelung akan ditamatkan apabila hanya terdapat digit K ditinggalkan; Kod pemacu", "code": "< ? php function firstkdigits ( $ n , $ k ) { $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product *= $ n ; while ( ( int ) ( $ product / pow ( 10 , $ k ) ) != 0 ) $ product = ( int ) $ product / 10 ; return floor ( $ product ) ; } $ n = 15 ; $ k = 4 ; echo firstkdigits ( $ n , $ k ) ; ? >"}
{"text": "Semak jika sebilangan besar boleh dibahagikan dengan 9 atau tidak | Berfungsi untuk mencari nombor yang boleh dibahagikan dengan 9 atau tidak; Mengira jumlah digit; Semak sama ada jumlah digit boleh dibahagikan dengan 9 .; Kod pemacu", "code": "< ? php function check ( $ str ) { $ n = strlen ( $ str ) ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 9 == 0 ) ; } $ str = \"99333\" ; $ x = check ( $ str ) ? \" Yes \" : \" No ▁ \" ; echo ( $ x ) ; ? >"}
{"text": "XOR Semua Subarray Xors | Tetapkan 1 | Mengembalikan xor semua subarray xors; Inisialisasi hasil oleh 0 sebagai (A XOR 0 = A); pilih elemen permulaan; pilih elemen akhir; Lakukan xor elemen dalam subarray semasa; Kod pemacu", "code": "< ? php function getTotalXorOfSubarrayXors ( $ arr , $ N ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i ; $ j < $ N ; $ j ++ ) for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) $ res = $ res ^ $ arr [ $ k ] ; return $ res ; } $ arr = array ( 3 , 5 , 2 , 4 , 6 ) ; $ N = sizeof ( $ arr ) ; echo getTotalXorOfSubarrayXors ( $ arr , $ N ) ; ? >"}
{"text": "XOR Semua Subarray Xors | Tetapkan 1 | Mengembalikan xor semua subarray xors; Inisialisasi hasil oleh 0 sebagai (A XOR 0 = A); gelung ke atas semua elemen sekali; Dapatkan kekerapan elemen semasa; Jika kekerapan adalah ganjil, maka masukkannya dalam hasilnya; mengembalikan hasilnya; Kod pemacu", "code": "< ? php function getTotalXorOfSubarrayXors ( $ arr , $ N ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ freq = ( $ i + 1 ) * ( $ N - $ i ) ; if ( $ freq % 2 == 1 ) $ res = $ res ^ $ arr [ $ i ] ; } return $ res ; } $ arr = array ( 3 , 5 , 2 , 4 , 6 ) ; $ N = count ( $ arr ) ; echo getTotalXorOfSubarrayXors ( $ arr , $ N ) ; ? >"}
{"text": "GCD lebih daripada dua (atau array) nombor | Berfungsi untuk mengembalikan GCD A dan B; Berfungsi untuk mencari GCD pelbagai nombor; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function findGCD ( $ arr , $ n ) { $ result = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ result = gcd ( $ arr [ $ i ] , $ result ) ; if ( $ result == 1 ) { return 1 ; } } return $ result ; } $ arr = array ( 2 , 4 , 6 , 8 , 16 ) ; $ n = sizeof ( $ arr ) ; echo ( findGCD ( $ arr , $ n ) ) ; ? >"}
{"text": "Nombor Superperfect | Berfungsi untuk mengira jumlah semua pembahagi; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Pulangan benar jika n adalah super sempurna lain palsu. ; Cari jumlah semua pembahagi nombor n; Sekali lagi cari jumlah semua pembahagi N1 dan periksa sama ada jumlahnya sama dengan N1; Kod pemacu", "code": "< ? php function divSum ( $ num ) { $ result = 0 ; for ( $ i = 1 ; $ i * $ i <= $ num ; ++ $ i ) { if ( $ num % $ i == 0 ) { if ( $ i == ( $ num / $ i ) ) $ result += $ i ; else $ result += ( $ i + $ num / $ i ) ; } } return $ result ; } function isSuperPerfect ( $ n ) { $ n1 = divSum ( $ n ) ; return ( 2 * $ n == divSum ( $ n1 ) ) ; } $ n = 16 ; $ hh = ( isSuperPerfect ( $ n ) ? \" Yes STRNEWLINE \" : \" No STRNEWLINE \" ) ; echo ( $ hh ) ; $ n = 6 ; $ hh = ( isSuperPerfect ( $ n ) ? \" Yes STRNEWLINE \" : \" No STRNEWLINE \" ) ; echo ( $ hh ) ; ? >"}
{"text": "Nombor Refactorable | Berfungsi untuk mengira semua pembahagi; Memulakan hasil; Jika pembahagi adalah sama, hitung hanya satu. ; Jika tidak, kiraan kedua -duanya; Kod pemacu", "code": "< ? php function isRefactorableNumber ( $ n ) { $ divCount = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; ++ $ i ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) ++ $ divCount ; else $ divCount += 2 ; } } return $ n % $ divCount == 0 ; } $ n = 8 ; if ( isRefactorableNumber ( $ n ) ) echo \" yes \" ; else echo \" no \" ; echo \" STRNEWLINE \" ; $ n = 14 ; if ( isRefactorableNumber ( $ n ) ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text": "Kira semua pembahagi sempurna nombor | berfungsi untuk memeriksa nombor persegi yang sempurna; Mengembalikan kiraan semua pembahagi sempurna N; Memulakan hasil; Pertimbangkan setiap nombor yang boleh menjadi pembahagi n; Jika saya seorang pembahagi; Kod pemacu", "code": "< ? php function isPerfectSquare ( $ n ) { $ sq = sqrt ( $ n ) ; return ( $ n == $ sq * $ sq ) ; } function countPerfectDivisors ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i * $ i <= $ n ; ++ $ i ) { if ( $ n % $ i == 0 ) { if ( isPerfectSquare ( $ i ) ) ++ $ count ; if ( $ n / $ i != $ i && isPerfectSquare ( $ n / $ i ) ) ++ $ count ; } } return $ count ; } $ n = 16 ; echo \" Total ▁ perfect ▁ divisors ▁ of ▁ \" , $ n , \" ▁ = ▁ \" , countPerfectDivisors ( $ n ) , \" STRNEWLINE \" ; $ n = 12 ; echo \" Total ▁ perfect ▁ divisors ▁ of ▁ \" , $ n , \" ▁ = ▁ \" , countPerfectDivisors ( $ n ) ; ? >"}
{"text": "Elemen terdekat dengan di | Program PHP untuk mencetak elemen terdekat dengan sekurang -kurangnya satu faktor utama biasa. ; Loop merangkumi setiap elemen arr []; Gelung yang meliputi dari 0 hingga i - 1 dan i + 1 hingga n - 1 indeks serentak; kedudukan cetak elemen terdekat; Fungsi rekursif untuk mengembalikan GCD A dan B; Kod pemacu", "code": "< ? php function nearestGcd ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ closest = -1 ; for ( $ j = $ i - 1 , $ k = $ i + 1 ; $ j > 0 $ k <= $ n ; -- $ j , ++ $ k ) { if ( $ j >= 0 && __gcd ( $ arr [ $ i ] , $ arr [ $ j ] ) > 1 ) { $ closest = $ j + 1 ; break ; } if ( $ k < $ n && __gcd ( $ arr [ $ i ] , $ arr [ $ k ] ) > 1 ) { $ closest = $ k + 1 ; break ; } } echo $ closest . \" \" ; } } function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } $ arr = array ( 2 , 9 , 4 , 3 , 13 ) ; $ n = sizeof ( $ arr ) ; nearestGcd ( $ arr , $ n ) ; ? >"}
{"text": "Susunan terbesar yang mempunyai GCD lebih besar daripada 1 | Program PHP yang cekap untuk mencari panjang seterusnya terbesar dengan GCD lebih besar daripada 1 .; Perdana [] untuk menyimpan pembahagi utama yang terkecil dari kiraan elemen [] untuk menyimpan bilangan kali pembahagi tertentu berlaku dalam berikutnya; Ayakan mudah untuk mencari faktor utama terkecil nombor yang lebih kecil daripada max; Nombor Perdana akan mempunyai pembahagi yang sama; Mengembalikan panjang berikutnya dengan GCD lebih daripada 1 .; Ambil jumlah pembahagi utama unsur yang unik; Kiraan kenaikan [] setiap pembahagi yang unik yang kami dapat sehingga sekarang; Cari kekerapan maksimum pembahagi; Pra - mengira pembahagi terkecil dari semua nombor", "code": "< ? php $ MAX = 10001 ; $ prime = array_fill ( 0 , $ MAX , 0 ) ; $ countdiv = array_fill ( 0 , $ MAX , 0 ) ; function SieveOfEratosthenes ( ) { global $ MAX , $ prime ; for ( $ i = 2 ; $ i * $ i <= $ MAX ; ++ $ i ) { if ( $ prime [ $ i ] == 0 ) for ( $ j = $ i * 2 ; $ j <= $ MAX ; $ j += $ i ) $ prime [ $ j ] = $ i ; } for ( $ i = 1 ; $ i < $ MAX ; ++ $ i ) if ( $ prime [ $ i ] == 0 ) $ prime [ $ i ] = $ i ; } function largestGCDSubsequence ( $ arr , $ n ) { global $ countdiv , $ prime ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ element = $ arr [ $ i ] ; while ( $ element > 1 ) { $ div = $ prime [ $ element ] ; ++ $ countdiv [ $ div ] ; $ ans = max ( $ ans , $ countdiv [ $ div ] ) ; while ( $ element % $ div == 0 ) $ element = ( int ) ( $ element / $ div ) ; } } return $ ans ; } SieveOfEratosthenes ( ) ; $ arr = array ( 10 , 15 , 7 , 25 , 9 , 35 ) ; $ size = count ( $ arr ) ; echo largestGCDSubsequence ( $ arr , $ size ) ; ? >"}
{"text": "Kira nombor angka binari lebih kecil daripada n | kaedah mengembalikan kiraan nombor angka binari yang lebih kecil daripada n; giliran untuk menyimpan semua nombor angka binari perantaraan; Digit binari bermula dengan 1; gelung sehingga kita mempunyai elemen dalam barisan; Tolak nombor angka binari seterusnya hanya jika elemen muncul semasa adalah n; Uncomment di bawah baris untuk mencetak nombor sebenar dalam cout urutan yang disusun << t << \"~\"; ; Kod pemacu", "code": "< ? php function countOfBinaryNumberLessThanN ( $ N ) { $ q = array ( ) ; array_push ( $ q , 1 ) ; $ cnt = 0 ; $ t = 0 ; while ( ! empty ( $ q ) ) { $ t = array_pop ( $ q ) ; if ( $ t <= $ N ) { $ cnt ++ ; array_push ( $ q , $ t * 10 ) ; array_push ( $ q , ( $ t * 10 + 1 ) ) ; } } return $ cnt ; } $ N = 200 ; echo countOfBinaryNumberLessThanN ( $ N ) ; ? >"}
{"text": "Jumlah produk x dan y seperti lantai (n / x) = y | Kembalikan jumlah produk x * y. ; Mengalihkan x dari 1 hingga n; Mencari Y = N / X. ; Menambah produk X dan Y untuk menjawab. ; Kod pemacu", "code": "< ? php function sumofproduct ( $ n ) { $ ans = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) { $ y = ( int ) ( $ n / $ x ) ; $ ans += ( $ y * $ x ) ; } return $ ans ; } $ n = 10 ; echo sumofproduct ( $ n ) ; ? >"}
{"text": "Program untuk nombor Perrin | Program PHP yang dioptimumkan untuk nombor n 'th Perrin; Kod pemacu", "code": "< ? php function per ( $ n ) { $ a = 3 ; $ b = 0 ; $ c = 2 ; $ i ; $ m ; if ( $ n == 0 ) return $ a ; if ( $ n == 1 ) return $ b ; if ( $ n == 2 ) return $ c ; while ( $ n > 2 ) { $ m = $ a + $ b ; $ a = $ b ; $ b = $ c ; $ c = $ m ; $ n -- ; } return $ m ; } $ n = 9 ; echo per ( $ n ) ; ? >"}
{"text": "Cari nombor semulajadi pertama yang faktorial dapat dibahagikan dengan x | fungsi untuk mengira faktorial; fungsi untuk cek special_factorial_number; Fungsi fakta panggilan dan modulo dengan k dan periksa sama ada keadaan adalah benar kemudian kembali i; mengambil input", "code": "< ? php function fact ( $ n ) { $ num = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ num = $ num * $ i ; return $ num ; } function Special_Factorial_Number ( $ k ) { for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( ( fact ( $ i ) % $ k ) == 0 ) { return $ i ; } } } $ k = 16 ; echo Special_Factorial_Number ( $ k ) ; ? >"}
{"text": "Program untuk teka -teki coklat dan pembungkus | Mengembalikan bilangan maksimum coklat yang boleh kita makan dengan wang yang diberikan, harga coklat dan bilangan bungkus yang diperlukan untuk mendapatkan coklat. ; Kes sudut; Pertama cari bilangan coklat yang boleh dibeli dengan jumlah yang diberikan; Sekarang tambahkan bilangan coklat dengan coklat yang diperoleh oleh bungkus; Jumlah wang; kos setiap gula -gula; Tiada pembalut perlu; ditukar untuk satu coklat.", "code": "< ? php function countMaxChoco ( $ money , $ price , $ wrap ) { if ( $ money < $ price ) return 0 ; $ choc = $ money / $ price ; $ choc = $ choc + ( $ choc - 1 ) / ( $ wrap - 1 ) ; return $ choc ; } $ money = 15 ; $ price = 1 ; $ wrap = 3 ; echo countMaxChoco ( $ money , $ price , $ wrap ) ; ? >"}
{"text": "Semak jika boleh bergerak dari koordinat yang diberikan kepada koordinat yang dikehendaki | Mengembalikan GCD I dan J; Pulangan benar jika mungkin untuk pergi ke (a, b) dari (x, y); Cari nilai mutlak semua sebagai tanda tidak penting. ; Jika GCD adalah sama maka ia mungkin dapat dicapai. Lain tidak mungkin. ; Kod pemacu; Menukar koordinat menjadi integer positif", "code": "< ? php function gcd ( $ i , $ j ) { if ( $ i == $ j ) return $ i ; if ( $ i > $ j ) return gcd ( $ i - $ j , $ j ) ; return gcd ( $ i , $ j - $ i ) ; } function ispossible ( $ x , $ y , $ a , $ b ) { $ x = abs ( $ x ) ; $ y = abs ( $ y ) ; $ a = abs ( $ a ) ; $ b = abs ( $ b ) ; return ( gcd ( $ x , $ y ) == gcd ( $ a , $ b ) ) ; } { $ x = 35 ; $ y = 15 ; $ a = 20 ; $ b = 25 ; if ( ispossible ( $ x , $ y , $ a , $ b ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; return 0 ; } ? >"}
{"text": "Nombor Equidigital | Program PHP untuk mencari nombor equidigital sehingga n; Array untuk menyimpan semua perdana kurang daripada dan sama dengan max. ; Fungsi utiliti untuk Sieve of Sundaram; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahu prima yang lebih kecil daripada max, kita mengurangkan maksimum hingga separuh array ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j; Logik utama Sundaram. Tandakan semua nombor yang tidak menjana nombor perdana dengan melakukan 2 * i + 1; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Pulangan benar jika n adalah nombor equidigital, lain -lain palsu. ; Mengira digit dalam nombor asal; Kira semua digit dalam faktor utama N pdigit akan memegang nilai ini. ; Mengira kuasa p dalam n; Jika prima [i] adalah faktor utama ,; Mengira kuasa faktor utama; Tambah digitnya ke PDIGIT. ; Tambah digit kuasa faktor utama kepada pdigit. ; Jika n! = 1 maka satu faktor utama masih akan disimpulkan; ; Jika digit dalam faktor utama dan digit dalam nombor asal adalah sama, maka kembali benar. Lain kembali palsu. ; Mencari semua nombor perdana sebelum had. Nombor ini digunakan untuk mencari faktor utama.", "code": "< ? php $ MAX = 10000 ; $ primes = array ( ) ; function sieveSundaram ( ) { global $ primes , $ MAX ; $ marked = array_fill ( 0 , ( $ MAX / 2 + 1 ) , false ) ; for ( $ i = 1 ; $ i <= ( ( int ) sqrt ( $ MAX ) - 1 ) / 2 ; $ i ++ ) for ( $ j = ( $ i * ( $ i + 1 ) ) << 1 ; $ j <= ( int ) ( $ MAX / 2 ) ; $ j = $ j + 2 * $ i + 1 ) $ marked [ $ j ] = true ; array_push ( $ primes , 2 ) ; for ( $ i = 1 ; $ i <= ( int ) ( $ MAX / 2 ) ; $ i ++ ) if ( $ marked [ $ i ] == false ) array_push ( $ primes , 2 * $ i + 1 ) ; } function isEquidigital ( $ n ) { global $ primes , $ MAX ; if ( $ n == 1 ) return true ; $ original_no = $ n ; $ sumDigits = 0 ; while ( $ original_no > 0 ) { $ sumDigits ++ ; $ original_no = ( int ) ( $ original_no / 10 ) ; } $ pDigit = 0 ; $ count_exp = 0 ; $ p = 0 ; for ( $ i = 0 ; $ primes [ $ i ] <= ( int ) ( $ n / 2 ) ; $ i ++ ) { while ( $ n % $ primes [ $ i ] == 0 ) { $ p = $ primes [ $ i ] ; $ n = ( int ) ( $ n / $ p ) ; $ count_exp ++ ; } while ( $ p > 0 ) { $ pDigit ++ ; $ p = ( int ) ( $ p / 10 ) ; } while ( $ count_exp > 1 ) { $ pDigit ++ ; $ count_exp = ( int ) ( $ count_exp / 10 ) ; } } if ( $ n != 1 ) { while ( $ n > 0 ) { $ pDigit ++ ; $ n = ( int ) ( $ n / 10 ) ; } } return ( $ pDigit == $ sumDigits ) ; } sieveSundaram ( ) ; echo \" Printing ▁ first ▁ few ▁ Equidigital ▁ Numbers ▁ using ▁ isEquidigital ( ) STRNEWLINE \" ; for ( $ i = 1 ; $ i < 20 ; $ i ++ ) if ( isEquidigital ( $ i ) ) echo $ i . \" \" ; ? >"}
{"text": "Jumlah maksimum nombor yang berbeza dengan LCM sebagai n | Mengembalikan jumlah maksimum nombor dengan LCM sebagai n; Mencari pembahagi n dan menambahkannya ke max_sum; jika 'saya' adalah pembahagi 'n'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Kod pemacu", "code": "< ? php function maxSumLCM ( $ n ) { $ max_sum = 0 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ max_sum += $ i ; if ( $ n / $ i != $ i ) $ max_sum += ( $ n / $ i ) ; } } return $ max_sum ; } $ n = 2 ; echo MaxSumLCM ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Nombor terkecil dibahagi dengan nombor n pertama | Fungsi mengembalikan LCM nombor N pertama; Kod pemacu", "code": "< ? php function lcm ( $ n ) { $ ans = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans = ( $ ans * $ i ) / ( gmp_gcd ( strval ( ans ) , strval ( i ) ) ) ; return $ ans ; } $ n = 20 ; echo lcm ( $ n ) ; ? >"}
{"text": "Peraturan trapezoid untuk anggaran nilai integral pasti | Fungsi sampel yang nilai anggaran integral yang pasti dikira menggunakan peraturan trapezoid; Mengisytiharkan fungsi f (x) = 1 / (1 + x * x); Fungsi untuk menilai nilai integral; Jarak grid; Pengkomputeran jumlah terma pertama dan terakhir dalam formula di atas; Menambah istilah pertengahan dalam formula di atas; H / 2 menunjukkan (b - a) / 2 n. Mengalikan h / 2 dengan s. ; Pelbagai integral yang pasti; Bilangan grid. Nilai yang lebih tinggi bermaksud lebih ketepatan", "code": "< ? php function y ( $ x ) { return 1 / ( 1 + $ x * $ x ) ; } function trapezoidal ( $ a , $ b , $ n ) { $ h = ( $ b - $ a ) / $ n ; $ s = y ( $ a ) + y ( $ b ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ s += 2 * Y ( $ a + $ i * $ h ) ; return ( $ h / 2 ) * $ s ; } $ x0 = 0 ; $ xn = 1 ; $ n = 6 ; echo ( \" Value ▁ of ▁ integral ▁ is ▁ \" ) ; echo ( trapezoidal ( $ x0 , $ xn , $ n ) ) ; ? >"}
{"text": "Mencari nombor digit dalam nombor n 'th fibonacci | Fungsi ini mengembalikan bilangan digit dalam nombor Fibonacci nth selepas silingnya formula yang digunakan (n * log (phi) - (log 5) / 2); menggunakan phi = 1.6180339887498948; Kod pemacu", "code": "< ? php function numberOfDigits ( $ n ) { if ( $ n == 1 ) return 1 ; $ d = ( $ n * log10 ( 1.6180339887498948 ) ) - ( ( log10 ( 5 ) ) / 2 ) ; return ceil ( $ d ) ; } $ i ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) echo \" Number ▁ of ▁ Digits ▁ in ▁ F ( $ i ) ▁ - ▁ \" , numberOfDigits ( $ i ) , \" STRNEWLINE \" ; ? >"}
{"text": "Bilangan elemen dengan faktor ganjil dalam julat yang diberikan | Berfungsi untuk mengira dataran ganjil; Kod pemacu", "code": "< ? php function countOddSquares ( $ n , $ m ) { return pow ( $ m , 0.5 ) - pow ( $ n - 1 , 0.5 ) ; } $ n = 5 ; $ m = 100 ; echo \" Count ▁ is ▁ \" , countOddSquares ( $ n , $ m ) ; ? >"}
{"text": "Semak jika nombor adalah kuasa nombor lain | Pulangan 1 jika y adalah kuasa x; Satu -satunya kuasa 1 ialah 1 sendiri; Berulang kali mengira kuasa x; Periksa sama ada kuasa x menjadi y; Semak hasil untuk benar / palsu dan cetak.", "code": "< ? php function isPower ( $ x , $ y ) { if ( $ x == 1 ) return ( $ y == 1 ? 1 : 0 ) ; $ pow = 1 ; while ( $ pow < $ y ) $ pow *= $ x ; return ( $ pow == $ y ? 1 : 0 ) ; } echo isPower ( 10 , 1 ) . \" STRNEWLINE \" ; echo isPower ( 1 , 20 ) . \" STRNEWLINE \" ; echo isPower ( 2 , 128 ) . \" STRNEWLINE \" ; echo isPower ( 2 , 30 ) . \" STRNEWLINE \" ; ? >"}
{"text": "Bilangan dataran sempurna antara dua nombor yang diberikan | Kaedah untuk mengira persegi antara a dan b; Kod pemacu", "code": "< ? php function countSquares ( $ a , $ b ) { return ( floor ( sqrt ( $ b ) ) - ceil ( sqrt ( $ a ) ) + 1 ) ; } { $ a = 9 ; $ b = 25 ; echo \" Count ▁ of ▁ squares ▁ is ▁ \" , countSquares ( $ a , $ b ) ; return 0 ; } ? >"}
{"text": "Kira integer positif dengan 0 sebagai digit dan maksimum 'D' digit | berfungsi untuk mengira kiraan nombor semulajadi sehingga bilangan digit yang mengandungi atleast satu sifar; Jumlah dua siri GP; Kod pemacu", "code": "< ? php function findCountUpto ( $ d ) { $ GP1_Sum = 9 * ( ( pow ( 10 , $ d ) - 1 ) / 9 ) ; $ GP2_Sum = 9 * ( ( pow ( 9 , $ d ) - 1 ) / 8 ) ; return $ GP1_Sum - $ GP2_Sum ; } $ d = 1 ; echo findCountUpto ( $ d ) , \" STRNEWLINE \" ; $ d = 2 ; echo findCountUpto ( $ d ) , \" STRNEWLINE \" ; $ d = 4 ; echo findCountUpto ( $ d ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak sama ada Count of Divisors adalah atau ganjil | Berfungsi untuk mengira pembahagi; Memulakan kiraan pembahagi; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi adalah jumlah kenaikan yang sama dengan satu kiraan kenaikan sebaliknya sebanyak 2; Kod pemacu", "code": "< ? php function countDivisors ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) + 1 ; $ i ++ ) { if ( $ n % $ i == 0 ) $ count += ( $ n / $ i == $ i ) ? 1 : 2 ; } if ( $ count % 2 == 0 ) echo \" Even STRNEWLINE \" ; else echo \" Odd STRNEWLINE \" ; } echo \" The ▁ count ▁ of ▁ divisor : ▁ \" ; countDivisors ( 10 ) ; ? >"}
{"text": "Kirakan N! di bawah modulo p | Mengembalikan kuasa terbesar P yang membahagikan N! ; Memulakan hasil; Kirakan x = n / p + n / (p ^ 2) + n / (p ^ 3) + .... ; Fungsi utiliti untuk melakukan eksponensi modular. Ia kembali (x ^ y) % p; $ res = 1; Inisialisasi hasil $ x = $ x % $ p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; Pulangan n! % p; Gunakan penapis eratosthenes untuk mencari semua prima yang lebih kecil daripada n; Pertimbangkan semua prima yang dijumpai oleh SIEVE; Cari kuasa terbesar 'I' yang membahagikan n; Berbanding hasil dengan (i ^ k) % p; Kod pemacu", "code": "< ? php function largestPower ( $ n , $ p ) { $ x = 0 ; while ( $ n ) { $ n = ( int ) ( $ n / $ p ) ; $ x += $ n ; } return $ x ; } function power ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function modFact ( $ n , $ p ) { if ( $ n >= $ p ) return 0 ; $ res = 1 ; $ isPrime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ isPrime [ $ i ] ) { for ( $ j = 2 * $ i ; $ j <= $ n ; $ j += $ i ) $ isPrime [ $ j ] = 0 ; } } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ isPrime [ $ i ] ) { $ k = largestPower ( $ n , $ i ) ; $ res = ( $ res * power ( $ i , $ k , $ p ) ) % $ p ; } } return $ res ; } $ n = 25 ; $ p = 29 ; echo modFact ( $ n , $ p ) ; ? >"}
{"text": "Kira nombor kuadrat dalam segi empat tepat | Mengembalikan kiraan semua dataran dalam segi empat tepat saiz m x n; Jika n lebih kecil, swap m dan n; Sekarang n adalah dimensi yang lebih besar, gunakan formula; Kod pemacu", "code": "< ? php function countSquares ( $ m , $ n ) { if ( $ n < $ m ) list ( $ m , $ n ) = array ( $ n , $ m ) ; return $ m * ( $ m + 1 ) * ( 2 * $ m + 1 ) / 6 + ( $ n - $ m ) * $ m * ( $ m + 1 ) / 2 ; } $ m = 4 ; $ n = 3 ; echo ( \" Count ▁ of ▁ squares ▁ is ▁ \" . countSquares ( $ m , $ n ) ) ; ? >"}
{"text": "Tambah dua nombor menggunakan ++ dan / atau | Pulangan nilai x + y tanpa menggunakan +; Jika y positif, y kali tambah 1 hingga x; Jika y negatif, y kali tolak 1 dari x; Kod pemacu", "code": "< ? php function add ( $ x , $ y ) { while ( $ y > 0 && $ y -- ) $ x ++ ; while ( $ y < 0 && $ y ++ ) $ x -- ; return $ x ; } echo add ( 43 , 23 ) , \" STRNEWLINE \" ; echo add ( 43 , -23 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Kira nombor faktorial dalam julat yang diberikan | Fungsi untuk mengira faktorial; Cari nombor fakta pertama 'fakta' lebih besar daripada atau sama dengan 'rendah'; Mengira nombor faktorial dalam julat [rendah, tinggi]; Mengembalikan kiraan; Kod pemacu", "code": "< ? php function countFact ( $ low , $ high ) { $ fact = 1 ; $ x = 1 ; while ( $ fact < $ low ) { $ fact = $ fact * $ x ; $ x ++ ; } $ res = 0 ; while ( $ fact <= $ high ) { $ res ++ ; $ fact = $ fact * $ x ; $ x ++ ; } return $ res ; } echo \" Count ▁ is ▁ \" , countFact ( 2 , 720 ) ; ? >"}
{"text": "Cari tempoh tempoh dalam nilai perpuluhan 1 / n | Fungsi untuk mencari tempoh tempoh dalam 1 / n; Cari sisa (n + 1) selepas titik perpuluhan dalam nilai 1 / n; Simpan (n + 1) sisa; Kira bilangan sisa sebelum kejadian berikutnya (n + 1) 'th »sisa' d '; Kod pemacu", "code": "< ? php function getPeriod ( $ n ) { $ rem = 1 ; for ( $ i = 1 ; $ i <= $ n + 1 ; $ i ++ ) $ rem = ( 10 * $ rem ) % $ n ; $ d = $ rem ; $ count = 0 ; do { $ rem = ( 10 * $ rem ) % $ n ; $ count ++ ; } while ( $ rem != $ d ) ; return $ count ; } echo getPeriod ( 3 ) , \" STRNEWLINE \" ; echo getPeriod ( 7 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari baki tanpa menggunakan pengendali modulo atau % | Fungsi ini mengembalikan baki NUM / pembahagi tanpa menggunakan operator % (modulo); Kod pemacu", "code": "< ? php function getRemainder ( $ num , $ divisor ) { $ t = ( $ num - $ divisor * ( int ) ( $ num / $ divisor ) ) ; return $ t ; } echo getRemainder ( 100 , 7 ) ; ? >"}
{"text": "Program yang cekap untuk mengira jumlah siri 1/1! + 1/2! + 1/3! + 1/4! +. . + 1 / n! | Fungsi yang cekap untuk mengembalikan nilai 1/1! + 1/2! +. . + 1 / n! ; Kemas kini faktorial; Kemas kini jumlah siri; Kod pemacu", "code": "< ? php function sum ( $ n ) { $ sum = 0 ; $ fact = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ fact *= $ i ; $ sum += 1.0 / $ fact ; } return $ sum ; } $ n = 5 ; echo sum ( $ n ) ; ? >"}
{"text": "Cetak Digit K pertama 1 / N di mana n adalah integer positif | Fungsi untuk mencetak digit k pertama selepas titik dalam nilai 1 / n. n dianggap sebagai integer positif. ; Memulakan selebihnya; Jalankan kali gelung k untuk mencetak digit k; Digit seterusnya boleh diperolehi sebagai melakukan (10 * REM) / 10; Baki kemas kini; Kod pemacu", "code": "< ? php function println ( $ n , $ k ) { $ rem = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { echo floor ( ( 10 * $ rem ) / $ n ) ; $ rem = ( 10 * $ rem ) % $ n ; } } $ n = 7 ; $ k = 3 ; println ( $ n , $ k ) ; echo \" STRNEWLINE \" ; $ n = 21 ; $ k = 4 ; println ( $ n , $ k ) ; ? >"}
{"text": "Program untuk mencari jumlah siri 1 + 1/2 + 1/3 + 1/4 +. . + 1 / n | Fungsi untuk mengembalikan jumlah 1/1 + 1/2 + 1/3 +. . + 1 / n; Kod pemacu", "code": "< ? php function sum ( $ n ) { $ i ; $ s = 0.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ s = $ s + 1 / $ i ; return $ s ; } $ n = 5 ; echo ( \" Sum ▁ is ▁ \" ) ; echo ( sum ( $ n ) ) ; ? >"}
{"text": "Program untuk mencari GCD atau HCF dua nombor | Fungsi rekursif untuk mengembalikan GCD A dan B; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } $ a = 98 ; $ b = 56 ; echo \" GCD ▁ of ▁ $ a ▁ and ▁ $ b ▁ is ▁ \" , gcd ( $ a , $ b ) ; ? >"}
{"text": "Susun semula array supaya arr [i] menjadi arr [arr [i]] dengan o (1) ruang tambahan | Fungsi untuk menyusun semula array di tempat supaya arr [i] menjadi arr [arr [i]]. ; Langkah pertama: Meningkatkan semua nilai dengan (arr [arr [i]] % n) * n; Langkah kedua: Bahagikan semua nilai oleh n; Fungsi utiliti untuk mencetak pelbagai saiz n; Kod pemacu", "code": "< ? php function rearrange ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] += ( $ arr [ $ arr [ $ i ] ] % $ n ) * $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = intval ( $ arr [ $ i ] / $ n ) ; } function printArr ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 3 , 2 , 0 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Given ▁ array ▁ is ▁ STRNEWLINE \" ; printArr ( $ arr , $ n ) ; rearrange ( $ arr , $ n ) ; echo \" Modified ▁ array ▁ is ▁ STRNEWLINE \" ; printArr ( $ arr , $ n ) ; ? >"}
{"text": "Cetak semua urutan panjang yang diberikan | Fungsi utiliti yang mencetak saiz panjang yang diberikan; Fungsi teras yang menghasilkan dan mencetak semua urutan panjang k; Fungsi yang menggunakan PrintSeSeenceRecur () untuk mencetak semua urutan dari 1, 1 ,. .1 hingga n, n ,. . n; Kod pemacu", "code": "< ? php function printArray ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; return ; } function printSequencesRecur ( $ arr , $ n , $ k , $ index ) { if ( $ k == 0 ) { printArray ( $ arr , $ index ) ; } if ( $ k > 0 ) { for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ arr [ $ index ] = $ i ; printSequencesRecur ( $ arr , $ n , $ k - 1 , $ index + 1 ) ; } } } function printSequences ( $ n , $ k ) { $ arr = array ( ) ; printSequencesRecur ( $ arr , $ n , $ k , 0 ) ; return ; } $ n = 3 ; $ k = 2 ; printSequences ( $ n , $ k ) ; ? >"}
{"text": "Semak jika nombor adalah berganda 5 tanpa menggunakan / dan % operator | menganggap bahawa n adalah integer positif; Kod pemacu", "code": "< ? php function isMultipleof5 ( $ n ) { while ( $ n > 0 ) $ n = $ n - 5 ; if ( $ n == 0 ) return true ; return false ; } $ n = 19 ; if ( isMultipleof5 ( $ n ) == true ) echo ( \" $ n ▁ is ▁ multiple ▁ of ▁ 5\" ) ; else echo ( \" $ n ▁ is ▁ not ▁ a ▁ multiple ▁ of ▁ 5\" ) ; ? >"}
{"text": "Jumlah pasangan dalam array sedemikian rupa sehingga bitwise dan bitwise atau dan bitwise xor lsb adalah 1 | Fungsi untuk mencari kiraan pasangan yang diperlukan; Untuk menyimpan kiraan unsur -unsur yang memberikan selebihnya 0 i. e. walaupun nilai; Untuk menyimpan kiraan unsur -unsur yang memberikan selebihnya 1 i. e. nilai ganjil; Kod pemacu", "code": "< ? php function CalculatePairs ( $ a , $ n ) { $ cnt_zero = 0 ; $ cnt_one = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 == 0 ) $ cnt_zero += 1 ; else $ cnt_one += 1 ; } $ total_XOR_pairs = $ cnt_zero * $ cnt_one ; $ total_AND_pairs = ( $ cnt_one ) * ( $ cnt_one - 1 ) / 2 ; $ total_OR_pairs = $ cnt_zero * $ cnt_one + ( $ cnt_one ) * ( $ cnt_one - 1 ) / 2 ; echo ( \" cntXOR ▁ = ▁ $ total _ XOR _ pairs STRNEWLINE \" ) ; echo ( \" cntAND ▁ = ▁ $ total _ AND _ pairs STRNEWLINE \" ) ; echo ( \" cntOR ▁ = ▁ $ total _ OR _ pairs STRNEWLINE \" ) ; } $ a = array ( 1 , 3 , 4 , 2 ) ; $ n = count ( $ a ) ; CalculatePairs ( $ a , $ n ) ; ? >"}
{"text": "Berikan nilai lain kepada pembolehubah dari dua nilai yang mungkin | Berfungsi untuk menggantikan nilai; Kod pemacu", "code": "< ? php function alternate ( & $ a , & $ b , & $ x ) { $ x = $ a + $ b - $ x ; } $ a = -10 ; $ b = 15 ; $ x = $ a ; echo \" x ▁ is ▁ : ▁ \" , $ x ; alternate ( $ a , $ b , $ x ) ; echo \" After change \" ; echo \" x is : \" ? >"}
{"text": "Kuasa tertinggi dua yang membahagikan nombor tertentu | Program PHP untuk mencari kuasa tertinggi 2 yang membahagikan n. ; Kod pemacu", "code": "< ? php function highestPowerOf2 ( $ n ) { return ( $ n & ( ~ ( $ n - 1 ) ) ) ; } $ n = 48 ; echo highestPowerOf2 ( $ n ) ; ? >"}
{"text": "Semak sama ada bitwise dan nombor dengan mana -mana subset array adalah sifar atau tidak | Berfungsi untuk memeriksa sama ada bitwise dan nombor dengan mana -mana subset array adalah sifar atau tidak; pembolehubah untuk menyimpan dan semua elemen; Cari dan semua elemen array; jika dan semua elemen array dan n sama dengan sifar; Kod pemacu", "code": "< ? php function isSubsetAndZero ( $ array , $ length , $ N ) { $ arrAnd = $ array [ 0 ] ; for ( $ i = 1 ; $ i < $ length ; $ i ++ ) { $ arrAnd = $ arrAnd & $ array [ $ i ] ; } if ( ( $ arrAnd & $ N ) == 0 ) echo ( \" YES \" ) ; else echo ( \" NO \" ) ; } $ array = array ( 1 , 2 , 4 ) ; $ length = count ( $ array ) ; $ N = 3 ; isSubsetAndZero ( $ array , $ length , $ N ) ; ? >"}
{"text": "Mencari pariti nombor dengan cekap | Berfungsi untuk mencari pariti; Bit paling kanan Y memegang nilai pariti jika (y & 1) adalah 1 maka pariti adalah ganjil lain walaupun; Kod pemacu", "code": "< ? php function findParity ( $ x ) { $ y = $ x ^ ( $ x >> 1 ) ; $ y = $ y ^ ( $ y >> 2 ) ; $ y = $ y ^ ( $ y >> 4 ) ; $ y = $ y ^ ( $ y >> 8 ) ; $ y = $ y ^ ( $ y >> 16 ) ; if ( $ y & 1 ) return 1 ; return 0 ; } ( findParity ( 9 ) == 0 ) ? print ( \" Even ▁ Parity STRNEWLINE \" ) : print ( \" Odd ▁ Parity STRNEWLINE \" ) ; ( findParity ( 13 ) == 0 ) ? print ( \" Even ▁ Parity STRNEWLINE \" ) : print ( \" Odd ▁ Parity STRNEWLINE \" ) ; ? >"}
{"text": "Semak jika bit dalam julat L ke r dua nombor melengkapi satu sama lain atau tidak | fungsi untuk memeriksa sama ada semua bit ditetapkan dalam julat yang diberikan atau tidak; Mengira nombor 'num' mempunyai bilangan bit dan bit dalam julat L ke r adalah satu -satunya bit yang ditetapkan; Nombor baru yang hanya akan mempunyai satu atau lebih bit set dalam julat L ke R dan tempat lain; Jika kedua -duanya sama, maka semua bit ditetapkan dalam julat yang diberikan; lain semua bit tidak ditetapkan; berfungsi untuk memeriksa sama ada semua bit dalam julat dua nombor yang diberikan adalah melengkapi satu sama lain; Kod pemacu", "code": "< ? php function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = ( $ n & $ num ) ; if ( $ num == $ new_num ) return true ; return false ; } function bitsAreComplement ( $ a , $ b , $ l , $ r ) { $ xor_value = $ a ^ $ b ; return allBitsSetInTheGivenRange ( $ xor_value , $ l , $ r ) ; } $ a = 10 ; $ b = 5 ; $ l = 1 ; $ r = 3 ; if ( bitsAreComplement ( $ a , $ b , $ l , $ r ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Jumlah siri 2 ^ 0 + 2 ^ 1 + 2 ^ 2 + .... . + 2 ^ n | fungsi untuk mengira jumlah siri; memulakan jumlah sebagai 0; gelung untuk mengira jumlah siri; Kirakan 2 ^ i dan tambahkannya kepada jumlah; Kod pemacu", "code": "< ? php function calculateSum ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( 1 << $ i ) ; } return $ sum ; } $ n = 10 ; echo \" Sum ▁ of ▁ the ▁ series ▁ of ▁ \" . \" power ▁ 2 ▁ is ▁ : ▁ \" , calculateSum ( $ n ) ; ? >"}
{"text": "Cetak semua kombinasi elemen N dengan menukar tanda supaya jumlah mereka dapat dibahagikan dengan m | Berfungsi untuk mencetak semua kombinasi; Berulang untuk semua kombinasi; Pada mulanya 100 dalam binari jika n ialah 3 sebagai 1 << (3 - 1) = 100 dalam binari; Melangkah dalam array dan berikan tanda -tanda kepada unsur -unsur array; Jika b - th bit dari kiri ditetapkan ambil ' +' tanda; Peralihan kanan untuk memeriksa sama ada bit jth ditetapkan atau tidak; Re - Inisialisasi; Melewati unsur -unsur array; Jika jth dari kiri ditetapkan; peralihan kanan; Kod pemacu", "code": "< ? php function printCombinations ( $ a , $ n , $ m ) { for ( $ i = 0 ; $ i < ( 1 << $ n ) ; $ i ++ ) { $ sum = 0 ; $ num = 1 << ( $ n - 1 ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i & $ num ) $ sum += $ a [ $ j ] ; else $ sum += ( -1 * $ a [ $ j ] ) ; $ num = $ num >> 1 ; } if ( $ sum % $ m == 0 ) { $ num = 1 << ( $ n - 1 ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( $ i & $ num ) ) echo \" + \" ▁ , ▁ $ a [ $ j ] ▁ , ▁ \" \" ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL else STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL echo ▁ \" - \" ▁ , ▁ $ a [ $ j ] ▁ , ▁ \" \" $ num = $ num >> 1 ; } echo \" STRNEWLINE \" ; } } } $ a = array ( 3 , 5 , 6 , 8 ) ; $ n = sizeof ( $ a ) ; $ m = 5 ; printCombinations ( $ a , $ n , $ m ) ; ? >"}
{"text": "Bilangan bit set yang sama sebagai n | Mengembalikan bilangan bit set dalam nombor; fungsi; __builtin_popcount Fungsi yang mengira set bit dalam n; Berulang dari n - 1 hingga 1; Semak sama ada bilangan bit set sama dengan kiraan kenaikan temp; Kod pemacu", "code": "< ? php function __builtin_popcount ( $ n ) { $ t = 0 ; while ( $ n > 0 ) { $ d = $ n % 2 ; $ n = intval ( $ n / 2 ) ; if ( $ d == 1 ) $ t ++ ; } return $ t ; } function smallerNumsWithSameSetBits ( $ n ) { $ temp = __builtin_popcount ( $ n ) ; $ count = 0 ; for ( $ i = $ n - 1 ; $ i > 0 ; $ i -- ) { if ( $ temp == __builtin_popcount ( $ i ) ) $ count ++ ; } return $ count ; } $ n = 4 ; echo ( smallerNumsWithSameSetBits ( $ n ) ) ; ? >"}
{"text": "Masukkan sebarang nombor dengan 4 Menggunakan Operator Bitwise | Fungsi pulangan membiak nombor dengan 4 menggunakan pengendali bitwise; Kembali nombor dengan Multiply dengan 4 menggunakan 2 bit beralih ke kanan; Kod pemacu", "code": "< ? php function multiplyWith4 ( $ n ) { return ( $ n << 2 ) ; } $ n = 4 ; echo multiplyWith4 ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Tetapkan semua bit nombor | Menetapkan walaupun bit N dan mengembalikan nombor diubahsuai. ; Menjana 101010. .. .10 Nombor dan simpan di Res. ; jika bit bahkan kemudian menghasilkan nombor dan atau dengan res; pulangan atau nombor; Kod pemacu", "code": "< ? php function evenbitsetnumber ( $ n ) { $ count = 0 ; $ res = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ n $ res ) ; } $ n = 10 ; echo evenbitsetnumber ( $ n ) ; ? >"}
{"text": "Tetapkan semua bit nombor | Kembalikan nombor set MSB; Tetapkan semua bit; mengembalikan kenaikan MSB n oleh 1 dan shift sebanyak 1; kembali nombor yang ditetapkan; Dapatkan MSB di sini; menjana walaupun bit seperti 101010.. ; Jika bit adalah ganjil maka beralih dengan 1; kembali walaupun menetapkan nombor bit; Tetapkan semua bit di sini; mengambil atau dengan set bit bit bahkan; Kod pemacu", "code": "< ? php function getmsb ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; return ( $ n + 1 ) >> 1 ; } function getevenbits ( $ n ) { $ n = getmsb ( $ n ) ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; if ( $ n & 1 ) $ n = $ n >> 1 ; return $ n ; } function setallevenbits ( $ n ) { return $ n | getevenbits ( $ n ) ; } $ n = 10 ; echo setallevenbits ( $ n ) ; ? >"}
{"text": "Tetapkan semua bit ganjil nombor | Tetapkan semua sedikit ganjil; res untuk kedai 010101.. nombor; Menjana borang nombor 010101. .. . Hingga saiz temp; Jika bit adalah ganjil, maka menjana nombor dan atau dengan res; Kod pemacu", "code": "< ? php function oddbitsetnumber ( $ n ) { $ count = 0 ; $ res = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 0 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ n $ res ) ; } $ n = 10 ; echo oddbitsetnumber ( $ n ) ; ? >"}
{"text": "Tetapkan semua bit ganjil nombor | Kembalikan nombor set MSB; Tetapkan semua bit termasuk MSB. ; kembali MSB; Mengembalikan beberapa saiz yang sama (kedudukan msb atsame) sebagai n dan semua bit ganjil yang ditetapkan; Menjana bit ganjil seperti 010101.. ; jika bit bahkan kemudian beralih dengan 1; kembali nombor bit set ganjil; Tetapkan semua bit ganjil di sini; mengambil atau dengan nombor bit set ganjil; Kod pemacu", "code": "< ? php function getmsb ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; return ( $ n + 1 ) >> 1 ; } function getevenbits ( $ n ) { $ n = getmsb ( $ n ) ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; if ( ( $ n & 1 ) == 0 ) $ n = $ n >> 1 ; return $ n ; } function setalloddbits ( $ n ) { return $ n | getevenbits ( $ n ) ; } $ n = 10 ; echo setalloddbits ( $ n ) ; ? >"}
{"text": "Cetak nombor dalam julat 1 hingga n mempunyai bit dalam corak alternatif | berfungsi untuk mencetak nombor dalam julat 1 hingga n yang mempunyai bit dalam corak alternatif; Nombor pertama yang mempunyai bit dalam corak alternatif; paparan; gelung sehingga n <curr_num; menjana nombor seterusnya yang mempunyai corak bit alternatif; jika benar maka pecah; paparan; menjana nombor seterusnya yang mempunyai corak bit alternatif; jika benar maka pecah; paparan; Kod pemacu", "code": "< ? php function printNumHavingAltBitPatrn ( $ n ) { $ curr_num = 1 ; echo $ curr_num . \" \" ; while ( 1 ) { $ curr_num <<= 1 ; if ( $ n < $ curr_num ) break ; echo $ curr_num . \" \" ; $ curr_num = ( ( $ curr_num ) << 1 ) ^ 1 ; if ( $ n < $ curr_num ) break ; echo $ curr_num . \" \" ; } } $ n = 50 ; printNumHavingAltBitPatrn ( $ n ) ; ? >"}
{"text": "Kuasa sempurna terkecil 2 lebih besar daripada n (tanpa menggunakan pengendali aritmetik) | Berfungsi untuk mencari kuasa sempurna yang paling kecil daripada 2 lebih besar daripada n; Untuk menyimpan kuasa sempurna 2; Bitwise kiri peralihan oleh 1; Bitwise shift kanan dengan 1; Diperlukan kuasa sempurna 2; Kod pemacu", "code": "< ? php function perfectPowerOf2 ( $ n ) { $ per_pow = 1 ; while ( $ n > 0 ) { $ per_pow = $ per_pow << 1 ; $ n = $ n >> 1 ; } return $ per_pow ; } $ n = 128 ; echo \" Perfect ▁ power ▁ of ▁ 2 ▁ greater ▁ than ▁ \" . $ n . \" : ▁ \" . perfectPowerOf2 ( $ n ) ; ? >"}
{"text": "Cari pasangan yang unik dalam array dengan pasangan nombor | Program PHP untuk mencari pasangan yang unik dalam pelbagai pasangan. ; Xor setiap elemen dan dapatkan Xor dua elemen unik (ANS); Dapatkan bit set XOR (kami mendapat bit set kanan); Sekarang bahagikan unsur -unsur dalam dua set dengan membandingkan bit XOR set paling kanan dengan bit pada kedudukan yang sama dalam setiap elemen. Memulakan nombor yang hilang; Xor set pertama di arr []; Xor set kedua dalam arr []; Kod pemacu", "code": "< ? php function findUniquePair ( $ arr , $ n ) { $ XOR = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ XOR = $ XOR ^ $ arr [ $ i ] ; $ set_bit_no = $ XOR & ~ ( $ XOR - 1 ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo \" The ▁ unique ▁ pair ▁ is ▁ \" , \" ( \" , $ x , \" ▁ \" , $ y , \" ) \" ; } $ a = array ( 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 ) ; $ n = count ( $ a ) ; findUniquePair ( $ a , $ n ) ; ? >"}
{"text": "Kira bit unset nombor | Program PHP yang dioptimumkan untuk mengira bit yang tidak tersendiri dalam integer. ; Ini memastikan dua bit (dari MSB dan termasuk MSB) ditetapkan; Ini memastikan 4 bit (dari MSB dan termasuk MSB) ditetapkan; Kiraan set bit dalam nombor tagihan; Kod pemacu", "code": "< ? php function countUnsetBits ( $ n ) { $ x = $ n ; $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; $ t = log ( $ x ^ $ n , 2 ) ; return floor ( $ t ) ; } $ n = 17 ; echo countUnsetBits ( $ n ) ; ? >"}
{"text": "Kira jumlah bit dalam nombor | Berfungsi untuk mendapatkan bit dalam perwakilan binari integer positif; Kod pemacu", "code": "< ? php function countBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count ++ ; $ n >>= 1 ; } return $ count ; } $ i = 65 ; echo ( countBits ( $ i ) ) ; ? >"}
{"text": "Togol semua bit selepas bit yang paling penting | Fungsi untuk bertukar -tukar bit bermula dari MSB; Pembolehubah sementara untuk menggunakan XOR dengan salah satu n; Jalankan gelung sehingga satu -satunya set bit di Temp melintasi MST n. ; Togol sedikit N yang sepadan dengan bit set semasa dalam temp. ; Pindah set bit ke kedudukan yang lebih tinggi seterusnya. ; Kod pemacu", "code": "< ? php function toggle ( & $ n ) { $ temp = 1 ; while ( $ temp <= $ n ) { $ n = $ n ^ $ temp ; $ temp = $ temp << 1 ; } } $ n = 10 ; toggle ( $ n ) ; echo $ n ; ? >"}
{"text": "Cari n | Cari jika bit kth ditetapkan dalam perwakilan binari; Mengembalikan kedudukan bit set kiri dalam perwakilan binari; Mendapati sama ada integer dalam perwakilan binari adalah palindrome atau tidak; Satu demi satu membandingkan bit; Bandingkan bit kiri dan kanan dan berkumpul; Bermula dari 1, melintasi semua bilangan bulat; Jika kita mencapai n, pecahkan gelung; Kod pemacu; Panggilan fungsi", "code": "< ? php function isKthBitSet ( $ x , $ k ) { return ( $ x & ( 1 << ( $ k - 1 ) ) ) ? 1 : 0 ; } function leftmostSetBit ( $ x ) { $ count = 0 ; while ( $ x ) { $ count ++ ; $ x = $ x >> 1 ; } return $ count ; } function isBinPalindrome ( $ x ) { $ l = leftmostSetBit ( $ x ) ; $ r = 1 ; while ( $ l > $ r ) { if ( isKthBitSet ( $ x , $ l ) != isKthBitSet ( $ x , $ r ) ) return 0 ; $ l -- ; $ r ++ ; } return 1 ; } function findNthPalindrome ( $ n ) { $ pal_count = 0 ; $ i = 0 ; for ( $ i = 1 ; $ i <= PHP_INT_MAX ; $ i ++ ) { if ( isBinPalindrome ( $ i ) ) { $ pal_count ++ ; } if ( $ pal_count == $ n ) break ; } return $ i ; } $ n = 9 ; echo ( findNthPalindrome ( $ n ) ) ; ? >"}
{"text": "Cetak 'K' paling sedikit nombor yang signifikan | Fungsi pulangan 1 jika ditetapkan, 0 jika tidak; Kod pemacu; Panggilan fungsi", "code": "< ? php function LSB ( $ num , $ K ) { return ( $ num & ( 1 << ( $ K - 1 ) ) ) ; } $ num = 10 ; $ K = 4 ; $ r = LSB ( $ num , $ K ) ; if ( $ r ) echo '1' ; else echo '0' ; ? >"}
{"text": "Semak jika dua nombor adalah sama tanpa menggunakan pengendali perbandingan | Cari jika A dan B sama; Kod pemacu", "code": "< ? php function areSame ( $ a , $ b ) { if ( ! ( $ a - $ b ) ) echo \" Same \" ; else echo \" Not ▁ Same \" ; } areSame ( 10 , 20 ) ; ? >"}
{"text": "Togol bit dalam julat yang diberikan | berfungsi untuk bertukar -tukar bit dalam julat yang diberikan; Mengira nombor 'num' mempunyai bilangan bit dan bit dalam julat L ke r adalah satu -satunya bit yang ditetapkan; Togol bit dalam julat l ke r dalam 'n' Selain itu, kita boleh mengira num sebagai: $ num = (1 << $ r) - $ l. dan mengembalikan nombor; Kod pemacu", "code": "< ? php function toggleBitsFromLToR ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; return ( $ n ^ $ num ) ; } $ n = 50 ; $ l = 2 ; $ r = 5 ; echo toggleBitsFromLToR ( $ n , $ l , $ r ) ; ? >"}
{"text": "Kedudukan Bit yang paling berbeza | Fungsi untuk mencari kedudukan set paling kanan dalam 'n'; untuk mengendalikan kes kelebihan apabila n = 0 .; Berfungsi untuk mencari kedudukan paling tepat yang berbeza dalam perwakilan binari 'M' dan 'N'; Kedudukan bit yang paling tepat; Kod pemacu", "code": "< ? php function getRightMostSetBit ( $ n ) { if ( $ n == 0 ) return 0 ; return log ( $ n & - $ n , ( 2 ) ) + 1 ; } function posOfRightMostDiffBit ( $ m , $ n ) { return getRightMostSetBit ( $ m ^ $ n ) ; } $ m = 52 ; $ n = 4 ; echo posOfRightMostDiffBit ( $ m , $ n ) ; ? >"}
{"text": "Terdekat (atau seterusnya) lebih kecil dan lebih besar dengan bilangan bit set yang sama | Fungsi utama untuk mencari nombor terkecil seterusnya yang lebih besar daripada N; Mengira C0 dan C1; Jika tidak ada bilangan yang lebih besar dengan tidak sama. daripada 1 s; input 1; input 2", "code": "< ? php function getNext ( $ n ) { $ c = $ n ; $ c0 = 0 ; $ c1 = 0 ; while ( ( ( $ c & 1 ) == 0 ) && ( $ c != 0 ) ) { $ c0 ++ ; $ c >>= 1 ; } while ( ( $ c & 1 ) == 1 ) { $ c1 ++ ; $ c >>= 1 ; } if ( $ c0 + $ c1 == 31 $ c0 + $ c1 == 0 ) return -1 ; return $ n + ( 1 << $ c0 ) + ( 1 << ( $ c1 - 1 ) ) - 1 ; } $ n = 5 ; echo getNext ( $ n ) ; $ n = 8 ; echo \" STRNEWLINE \" ; echo getNext ( $ n ) ; ? >"}
{"text": "Kira bit minimum untuk membalikkan sedemikian rupa sehingga xor a dan b sama dengan c | Kod PHP untuk mengira bit minimum dalam A dan B; Jika kedua -dua [i] dan b [i] adalah sama; Jika kedua -dua A dan B tidak sama rata; N mewakili jumlah bit bit", "code": "< ? php function totalFlips ( $ A , $ B , $ C , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { if ( $ A [ $ i ] == $ B [ $ i ] && $ C [ $ i ] == '1' ) ++ $ count ; else if ( $ A [ $ i ] != $ B [ $ i ] && $ C [ $ i ] == '0' ) ++ $ count ; } return $ count ; } $ N = 5 ; $ a = \"10100\" ; $ b = \"00010\" ; $ c = \"10011\" ; echo totalFlips ( $ a , $ b , $ c , $ N ) ; ? >"}
{"text": "Tukar tiga pembolehubah tanpa menggunakan pembolehubah sementara | Berikan nilai c 's' ke nilai B dan B ke c. ; Simpan xor semua dalam A; Selepas ini, B mempunyai nilai A; Selepas ini, C mempunyai nilai B; Selepas ini, mempunyai nilai C; Kod pemacu; Fungsi panggilan", "code": "< ? php function swapThree ( & $ a , & $ b , & $ c ) { $ a = $ a ^ $ b ^ $ c ; $ b = $ a ^ $ b ^ $ c ; $ c = $ a ^ $ b ^ $ c ; $ a = $ a ^ $ b ^ $ c ; } $ a = 10 ; $ b = 20 ; $ c = 30 ; echo \" Before ▁ swapping ▁ a ▁ = ▁ \" , $ a , \" , ▁ b ▁ = ▁ \" , $ b , \" , ▁ c ▁ = ▁ \" , $ c , \" STRNEWLINE \" ; swapThree ( $ a , $ b , $ c ) ; echo \" After ▁ swapping ▁ a ▁ = ▁ \" , $ a , \" , ▁ b ▁ = ▁ \" , $ b , \" , ▁ c ▁ = ▁ \" , $ c , \" STRNEWLINE \" ; ? >"}
{"text": "Cari dua nombor yang hilang | Tetapkan 2 (penyelesaian berasaskan XOR) | Fungsi untuk mencari dua nombor yang hilang dalam julat [1, n]. Fungsi ini mengandaikan bahawa saiz array adalah n - 2 dan semua elemen array berbeza; Dapatkan xor semua elemen dalam arr [] dan {1, 2. . n}; Dapatkan bit set XOR (kami mendapat bit set kanan); Sekarang bahagikan unsur -unsur dalam dua set dengan membandingkan bit XOR set paling kanan dengan bit pada kedudukan yang sama dalam setiap elemen. ; Xor set pertama di arr []; Xor set kedua dalam arr []; Xor set pertama dalam arr [] dan {1, 2, ... n}; Xor set kedua dalam arr [] dan {1, 2, ... n}; Kod pemacu; Pelbagai nombor adalah 2 tambah saiz tatasusunan", "code": "< ? php function findTwoMissingNumbers ( $ arr , $ n ) { $ XOR = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n - 2 ; $ i ++ ) $ XOR ^= $ arr [ $ i ] ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ XOR ^= $ i ; $ set_bit_no = $ XOR & ~ ( $ XOR - 1 ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i & $ set_bit_no ) $ x = $ x ^ $ i ; else $ y = $ y ^ $ i ; } echo \" Two ▁ Missing ▁ Numbers ▁ are STRNEWLINE \" , $ x ; echo \" STRNEWLINE \" , $ y ; } $ arr = array ( 1 , 3 , 5 , 6 ) ; $ n = 2 + count ( $ arr ) ; findTwoMissingNumbers ( $ arr , $ n ) ; ? >"}
{"text": "Cari Profesion dalam Keluarga Khas | Fungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari lulus no binari. ; Mengembalikan 'E' jika profesion nod pada tahap dan kedudukan tertentu adalah jurutera. Lain doktor. Fungsi ini menganggap bahawa kedudukan dan tahap yang diberikan mempunyai nilai yang sah. ; Kiraan set bit dalam 'pos - 1'; Jika set bit bit adalah ganjil, maka doktor, jurutera lain; Kod pemacu", "code": "< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ n &= ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function findProffesion ( $ level , $ pos ) { $ c = countSetBits ( $ pos - 1 ) ; return ( $ c % 2 ) ? ' d ' : ' e ' ; } $ level = 3 ; $ pos = 4 ; if ( ( findProffesion ( $ level , $ pos ) == ' e ' ) == true ) echo \" Engineer ▁ STRNEWLINE \" ; else echo \" Doctor ▁ STRNEWLINE \" ; ? >"}
{"text": "Melaksanakan rand3 () menggunakan rand2 () | Fungsi rawak untuk pulangan 0 atau 1 dengan kebarangkalian yang sama; Fungsi rand () akan menjana ganjil atau bilangan yang sama dengan kebarangkalian yang sama. Jika Rand () menjana nombor ganjil, fungsi akan kembali 1, ia akan kembali 0 .; Fungsi rawak kepada pulangan 0, 1 atau 2 dengan kebarangkalian yang sama 1 dengan 75 %; pulangan 0, 1, 2 atau 3 dengan kebarangkalian 25 %; Kod pemacu", "code": "< ? php function rand2 ( ) { return rand ( ) & 1 ; } function rand3 ( ) { $ r = 2 * rand2 ( ) + rand2 ( ) ; if ( $ r < 3 ) return $ r ; return rand3 ( ) ; } srand ( time ( NULL ) ) ; for ( $ i = 0 ; $ i < 100 ; $ i ++ ) echo rand3 ( ) ; ? >"}
{"text": "Cari pasangan yang berbeza (x, y) dalam julat yang diberikan supaya x membahagikan y | Berfungsi untuk mengembalikan pasangan yang mungkin; ANS1, nilai kedai ANS2 masing -masing x dan y; Kod pemacu", "code": "< ? php function findpair ( $ l , $ r ) { $ ans1 = $ l ; $ ans2 = 2 * $ l ; echo ( $ ans1 . \" , ▁ \" . $ ans2 ) ; } $ l = 1 ; $ r = 10 ; findpair ( $ l , $ r ) ;"}
{"text": "Unsur maksimum yang boleh dibuat sama dengan Kemas Kini K | Fungsi untuk mengira bilangan maksimum elemen yang sama dengan peningkatan nilai K. Di sini kita telah melakukan tetingkap gelongsor untuk menentukan sama ada terdapat bilangan unsur -unsur yang hadir pada kenaikan yang akan menjadi sama. Gelung di sini akan berjalan dalam fesyen seperti 0. . x - 1, 1 .. . x, 2.. . x + 1, .... , n - x - 1. . n - 1; Ia dapat dijelaskan dengan alasan bahawa jika untuk beberapa bilangan unsur x kita dapat mengemas kini nilai -nilai maka kenaikan ke segmen (i hingga j yang mempunyai panjang -> x) supaya semua akan sama adalah (x * maxx [j]) ini adalah jumlah segmen dan (pre [j] - pre [i]) Susun array dalam urutan menaik; Memulakan array awalan dan array maksimum; Mengira jumlah awalan array; Mengira nilai maksimum sehingga kedudukan itu dalam array; Carian binari digunakan untuk pengiraan di sini; hasil percetakan; Kod pemacu", "code": "< ? php function ElementsCalculationFunc ( $ pre , $ maxx , $ x , $ k , $ n ) { for ( $ i = 0 , $ j = $ x ; $ j <= $ n ; $ j ++ , $ i ++ ) { if ( $ x * $ maxx [ $ j ] - ( $ pre [ $ j ] - $ pre [ $ i ] ) <= $ k ) return true ; } return false ; } function MaxNumberOfElements ( $ a , $ n , $ k ) { sort ( $ a ) ; for ( $ i = 0 ; $ i <= $ n ; ++ $ i ) { $ pre [ $ i ] = 0 ; $ maxx [ $ i ] = 0 ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ pre [ $ i ] = $ pre [ $ i - 1 ] + $ a [ $ i - 1 ] ; $ maxx [ $ i ] = max ( $ maxx [ $ i - 1 ] , $ a [ $ i - 1 ] ) ; } $ l = 1 ; $ r = $ n ; $ ans ; while ( $ l < $ r ) { $ mid = ( $ l + $ r ) / 2 ; if ( ElementsCalculationFunc ( $ pre , $ maxx , $ mid - 1 , $ k , $ n ) ) { $ ans = $ mid ; $ l = $ mid + 1 ; } else $ r = $ mid - 1 ; } echo $ ans , \" STRNEWLINE \" ; } $ arr = array ( 2 , 4 , 9 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; $ k = 3 ; MaxNumberOfElements ( $ arr , $ n , $ k ) ; #This  code is contributed by akt_mit. NEW_LINE ? >"}
{"text": "Count Palindromic Ciri -ciri Rentetan | Program PHP yang mengira ciri -ciri palindromik yang berbeza dari rentetan. ; fungsi yang memeriksa sama ada substr [i. . j] yang diberikan adalah palindrome atau tidak. ; P [i, j] = benar jika substr [i. . j] adalah palindrome, lain -lain palsu; palindrome panjang tunggal; palindrome panjang 2; Palindromes panjang lebih dari 2. Gelung ini sama dengan pendaraban rantai matriks. Kami bermula dengan jurang panjang 2 dan mengisi jadual P dengan cara yang jurang antara permulaan dan akhir indeks meningkatkan satu demi satu dengan gelung luar. ; Pilih titik permulaan untuk jurang semasa; Tetapkan titik akhir; Jika rentetan semasa adalah palindrome; fungsi yang dikira secara rekursif jika str [i. . j] adalah k - palindromic atau tidak. ; menamatkan syarat untuk A yang merupakan K - palindrome. ; menamatkan keadaan untuk A yang bukan K - palindrome. ; Meningkatkan kaunter untuk jika ia adalah k - palindrome. ; Mid adalah penunjuk tengah str [i ... j]. ; Jika panjangnya (j - i + 1) adalah ganjil daripada kita perlu menolak satu dari pertengahan lain jika walaupun tidak ada perubahan. ; Jika k - palindrome maka kita periksa sama ada ia adalah (k + 1) - palindrome atau tidak dengan hanya menghantar mana -mana separuh daripada fungsi count_k_palindrome. ; Mencari semua substrings palindromic rentetan yang diberikan; Mengira k - palindromes untuk setiap sub rentetan yang diberikan. . ; Output bilangan substrings k - palindromic rentetan yang diberikan. ; Kod pemacu", "code": "< ? php $ MAX_STR_LEN = 1000 ; $ P = array ( array ( ) ) ; $ Kpal = array_fill ( 0 , $ MAX_STR_LEN , 0 ) ; for ( $ i = 0 ; $ i < $ MAX_STR_LEN ; $ i ++ ) { for ( $ j = 0 ; $ j < $ MAX_STR_LEN ; $ j ++ ) $ P [ $ i ] [ $ j ] = false ; } function checkSubStrPal ( $ str , $ n ) { global $ P , $ Kpal , $ MAX_STR_LEN ; for ( $ i = 0 ; $ i < $ MAX_STR_LEN ; $ i ++ ) { for ( $ j = 0 ; $ j < $ MAX_STR_LEN ; $ j ++ ) $ P [ $ i ] [ $ j ] = false ; $ Kpal [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ P [ $ i ] [ $ i ] = true ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ str [ $ i ] == $ str [ $ i + 1 ] ) $ P [ $ i ] [ $ i + 1 ] = true ; for ( $ gap = 2 ; $ gap < $ n ; $ gap ++ ) { for ( $ i = 0 ; $ i < $ n - $ gap ; $ i ++ ) { $ j = $ gap + $ i ; if ( $ str [ $ i ] == $ str [ $ j ] && $ P [ $ i + 1 ] [ $ j - 1 ] ) $ P [ $ i ] [ $ j ] = true ; } } } function countKPalindromes ( $ i , $ j , $ k ) { global $ Kpal , $ P ; if ( $ i == $ j ) { $ Kpal [ $ k ] ++ ; return ; } if ( $ P [ $ i ] [ $ j ] == false ) return ; $ Kpal [ $ k ] ++ ; $ mid = ( $ i + $ j ) / 2 ; if ( ( $ j - $ i + 1 ) % 2 == 1 ) $ mid -- ; countKPalindromes ( $ i , $ mid , $ k + 1 ) ; } function printKPalindromes ( $ s ) { global $ P , $ Kpal , $ MAX_STR_LEN ; $ n = strlen ( $ s ) ; checkSubStrPal ( $ s , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n - $ i ; $ j ++ ) countKPalindromes ( $ j , $ j + $ i , 1 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo ( $ Kpal [ $ i ] . \" ▁ \" ) ; echo ( \" STRNEWLINE \" ) ; } $ s = \" abacaba \" ; printKPalindromes ( $ s ) ; ? >"}
{"text": "Negara Pengumpulan | Program PHP untuk mengira tiada negara yang berbeza dari sekumpulan orang tertentu; Jawapan adalah sah jika orang duduk bersebelahan memberi jawapan yang sama; Seseorang memberikan jawapan yang berbeza; periksa orang seterusnya; Satu kumpulan negara yang sah telah dijumpai; Kod pemacu", "code": "< ? php function countCountries ( $ ans , $ N ) { $ total_countries = 0 ; $ i = 0 ; $ invalid = false ; while ( $ i < $ N ) { $ curr_size = $ ans [ $ i ] ; $ num = $ ans [ $ i ] ; while ( $ num > 0 ) { if ( $ ans [ $ i ] != $ curr_size ) { echo \" Invalid ▁ Answer STRNEWLINE \" ; return ; } else $ num -- ; $ i ++ ; } $ total_countries ++ ; } echo \" There ▁ are ▁ \" , $ total_countries , \" ▁ distinct ▁ companies ▁ in ▁ the ▁ group . STRNEWLINE \" ; } $ ans = array ( 1 , 1 , 2 , 2 , 4 , 4 , 4 , 4 ) ; $ n = sizeof ( $ ans ) ; countCountries ( $ ans , $ n ) ; ? >"}
{"text": "Semak jika array mengandungi semua elemen julat yang diberikan | Fungsi untuk memeriksa array untuk unsur -unsur dalam julat yang diberikan; Julat adalah no. unsur -unsur yang akan diperiksa; Melintasi array; Jika elemen berada dalam julat; Memeriksa sama ada elemen dalam julat 0 - julat adalah negatif; Unsur dari julat hilang dari array; Semua elemen jarak hadir; Menentukan array dan saiz; A adalah had yang lebih rendah dan B ialah had atas julat; Benar menandakan semua elemen hadir; Palsu menandakan sebarang elemen tidak hadir", "code": "< ? php function check_elements ( $ arr , $ n , $ A , $ B ) { $ range = $ B - $ A ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( abs ( $ arr [ $ i ] ) >= $ z = abs ( $ arr [ $ i ] ) - $ A ; if ( $ arr [ $ z ] > 0 ) { $ arr [ $ z ] = $ arr [ $ z ] * -1 ; } } } $ A && abs ( $ arr [ $ i ] ) <= $ B ) { $ count = 0 ; for ( $ i = 0 ; $ i <= $ range && $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > 0 ) return -1 ; else $ count ++ ; } if ( $ count != ( $ range + 1 ) ) return -1 ; return true ; } $ arr = array ( 1 , 4 , 5 , 2 , 7 , 8 , 3 ) ; $ n = sizeof ( $ arr ) ; $ A = 2 ; $ B = 5 ; if ( ( check_elements ( $ arr , $ n , $ A , $ B ) ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Program rekursif untuk mencari elemen minimum dan maksimum array | berfungsi untuk mencetak elemen minimum menggunakan rekursi; jika saiz = 0 bermaksud keseluruhan array telah dilalui; Kod pemacu", "code": "< ? php function findMinRec ( $ A , $ n ) { if ( $ n == 1 ) return $ A [ 0 ] ; return min ( $ A [ $ n - 1 ] , findMinRec ( $ A , $ n - 1 ) ) ; } $ A = array ( 1 , 4 , 45 , 6 , -50 , 10 , 2 ) ; $ n = sizeof ( $ A ) ; echo findMinRec ( $ A , $ n ) ; ? >"}
{"text": "Peruntukkan bilangan halaman minimum | Fungsi utiliti untuk memeriksa sama ada nilai minimum semasa boleh dilaksanakan atau tidak. ; melangkah ke atas semua buku; Semak jika bilangan halaman semasa lebih besar daripada curr_min yang bermaksud kita akan mendapat keputusan selepas pertengahan no. halaman; Kira berapa banyak pelajar yang dikehendaki mengedarkan halaman curr_min; kiraan pelajar kenaikan; kemas kini curr_sum; Sekiranya pelajar diperlukan menjadi lebih besar daripada diberi tidak. pelajar, kembali palsu; lain kemas kini curr_sum; berfungsi untuk mencari halaman minimum; kembali - 1 jika tidak. buku kurang daripada tidak. pelajar; Mengira jumlah halaman; Inisialisasi bermula sebagai 0 halaman dan berakhir sebagai halaman keseluruhan; melintasi sehingga mula <= akhir; Semak sama ada mungkin untuk mengedarkan buku dengan menggunakan pertengahan sebagai minimum semasa; Hasil kemas kini kepada pengedaran semasa kerana ia adalah yang terbaik yang kami dapati sehingga sekarang; Seperti yang kita dapati minimum dan buku disusun supaya mengurangkan akhir = pertengahan - 1 yang bermaksud; jika tidak mungkin bermakna halaman harus ditingkatkan supaya kemas kini start = pertengahan + 1; AT - Pulangan terakhir minimum no. halaman; Bilangan halaman dalam buku; $ m = 2; Tidak. pelajar", "code": "< ? php function isPossible ( $ arr , $ n , $ m , $ curr_min ) { $ studentsRequired = 1 ; $ curr_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ curr_min ) return false ; if ( $ curr_sum + $ arr [ $ i ] > $ curr_min ) { $ studentsRequired ++ ; $ curr_sum = $ arr [ $ i ] ; if ( $ studentsRequired > $ m ) return false ; } else $ curr_sum += $ arr [ $ i ] ; } return true ; } function findPages ( $ arr , $ n , $ m ) { $ sum = 0 ; if ( $ n < $ m ) return -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; $ start = 0 ; $ end = $ sum ; $ result = PHP_INT_MAX ; while ( $ start <= $ end ) { $ mid = ( int ) ( $ start + $ end ) / 2 ; if ( isPossible ( $ arr , $ n , $ m , $ mid ) ) { $ result = $ mid ; $ end = $ mid - 1 ; } else $ start = $ mid + 1 ; } return $ result ; } $ arr = array ( 12 , 34 , 67 , 90 ) ; $ n = count ( $ arr ) ; echo \" Minimum ▁ number ▁ of ▁ pages ▁ = ▁ \" , findPages ( $ arr , $ n , $ m ) , \" STRNEWLINE \" ; ? >"}
{"text": "Mengira unsur -unsur yang berbeza dalam array | Fungsi ini mencetak semua elemen yang berbeza; Mewujudkan hashset kosong; Melintasi array input; Jika tidak hadir, kemudian masukkannya dalam hashtable dan hasil kenaikan; Kod pemacu", "code": "< ? php function countDistinct ( $ arr , $ n ) { $ s = array ( ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { array_push ( $ s , $ arr [ $ i ] ) ; } $ s = array_unique ( $ s ) ; return count ( $ s ) ; } $ arr = array ( 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ) ; $ n = count ( $ arr ) ; echo countDistinct ( $ arr , $ n ) ; ? >"}
{"text": "Susun semula array untuk memaksimumkan i * arr [i] | Fungsi untuk mengira titik maksimum yang diperoleh dengan membuat pemilihan optimum pada array yang diberikan; Menyusun array; Pembolehubah untuk menyimpan jumlah mata yang diperoleh; Kod pemacu", "code": "< ? php function findOptimalSolution ( $ a , $ N ) { sort ( $ a ) ; $ points = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ points += $ a [ $ i ] * $ i ; } return $ points ; } $ a = array ( 1 , 4 , 2 , 3 , 9 ) ; $ N = sizeof ( $ a ) ; echo ( findOptimalSolution ( $ a , $ N ) ) ; ? >"}
{"text": "Bilangan minimum menara yang diperlukan supaya setiap rumah berada dalam lingkungan sekurang -kurangnya satu menara | Berfungsi untuk mengira bilangan menara; Mula -mula kita menyusun nombor rumah; untuk mengira bilangan menara; untuk melangkah ke semua rumah; kiraan bilangan menara; Cari cari lokasi tengah; melintasi lokasi tengah; Ini adalah titik ke rumah tengah di mana kita memasukkan menara; Sekarang cari lokasi terakhir; melintasi rumah terakhir; mengembalikan bilangan menara; diberi unsur; Cetak nombor menara", "code": "< ? php function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; } $ house = array ( 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 ) ; $ range = 2 ; $ n = sizeof ( $ house ) / sizeof ( $ house [ 0 ] ) ; echo number_of_tower ( $ house , $ range , $ n ) ; ? >"}
{"text": "Semak jika watak -watak rentetan yang diberikan dalam susunan abjad | Fungsi yang memeriksa sama ada rentetan dalam susunan abjad atau tidak; panjang rentetan; Buat pelbagai watak panjang rentetan; berikan rentetan kepada array aksara; Susun array watak; Semak sama ada array watak adalah sama dengan rentetan atau tidak; Kod pemacu; periksa sama ada rentetan dalam susunan abjad atau tidak", "code": "< ? php Function isAlphabaticOrder ( $ s ) { $ n = strlen ( $ s ) ; $ c = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ c [ $ i ] = $ s [ $ i ] ; } sort ( $ c ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ c [ $ i ] != $ s [ $ i ] ) return false ; return true ; } $ s = \" aabbbcc \" ; if ( isAlphabaticOrder ( $ s ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Susun nilai k pertama dalam urutan menaik dan baki n | berfungsi untuk menyusun array; Menyusun unsur -unsur pertama k dalam urutan menaik; Susun baki elemen n - k dalam urutan menurun; ARR kami mengandungi 8 elemen", "code": "< ? php function printOrder ( $ arr , $ n , $ k ) { $ a = array_slice ( $ arr , 0 , $ k ) ; sort ( $ a ) ; $ b = array_slice ( $ arr , $ k , $ n ) ; sort ( $ b ) ; $ b = array_reverse ( $ b ) ; unset ( $ arr ) ; $ arr = $ a ; return array_merge ( $ arr , $ b ) ; } $ arr = array ( 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , -1 ) ; $ k = 4 ; $ n = count ( $ arr ) ; $ arr = printOrder ( $ arr , $ n , $ k ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Program untuk menyusun rentetan dalam urutan menurun | Program PHP untuk menyusun rentetan dalam urutan menurun menggunakan fungsi perpustakaan; Kod pemacu; descorder ($ s); panggilan fungsi", "code": "< ? php function descOrder ( $ s ) { $ s = str_split ( $ s ) ; rsort ( $ s ) ; echo implode ( ' ' , $ s ) ; } $ s = \" geeksforgeeks \" ; ? >"}
{"text": "Elemen terkecil dalam array yang diulangi tepat kali 'k'. | Program PHP untuk mencari bilangan terkecil dalam array yang diulangi tepat kali 'k'. ; Cari bilangan terkecil di arr yang berulang kali; Frekuensi pengkomputeran semua elemen; Mencari elemen terkecil dengan kekerapan sebagai k; Jika kekerapan mana -mana nombor adalah sama dengan k bermula dari 0 maka kembalikan nombor; Kod pemacu", "code": "< ? php $ MAX = 1000 ; function findDuplicate ( $ arr , $ n , $ k ) { global $ MAX ; $ freq = array_fill ( 0 , $ MAX , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < 1 && $ arr [ $ i ] > $ MAX ) { echo \" Out ▁ of ▁ range \" ; return -1 ; } $ freq [ $ arr [ $ i ] ] += 1 ; } for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { if ( $ freq [ $ i ] == $ k ) return $ i ; } return -1 ; } $ arr = array ( 2 , 2 , 1 , 3 , 1 ) ; $ k = 2 ; $ n = count ( $ arr ) ; echo findDuplicate ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Program untuk mencetak array dalam susunan pendulum | Cetak susunan pendulam arr []; menyusun unsur -unsur; Array tambahan untuk menyimpan output; mengira indeks pertengahan; Menyimpan elemen minimum di tengah I ialah indeks untuk array output dan j adalah untuk array input. ; pelarasan untuk apabila tidak. unsur -unsur adalah juga; Mencetak susunan pendulum; Arahan input; Memanggil fungsi pendulum", "code": "< ? php function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr , $ n ) ; sort ( $ arr ) ; $ op [ $ n ] = NULL ; $ mid = floor ( ( $ n - 1 ) / 2 ) ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo \" Pendulum ▁ arrangement : \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ op [ $ i ] , \" ▁ \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 14 , 6 , 19 , 21 , 12 ) ; $ n = sizeof ( $ arr ) ; pendulumArrangement ( $ arr , $ n ) ; ? >"}
{"text": "Kurangkan jumlah produk dua tatasusunan dengan permutasi yang dibenarkan | Mengembalikan jumlah minimum produk dua tatasusunan dengan permutasi yang dibenarkan; Susun A dan B supaya nilai minimum dan maksimum boleh diambil dengan mudah. ; Mengalikan nilai minimum a dan nilai maksimum B; Kod pemacu", "code": "< ? php function minValue ( $ A , $ B , $ n ) { sort ( $ A ) ; sort ( $ A , $ n ) ; sort ( $ B ) ; sort ( $ B , $ n ) ; $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result += ( $ A [ $ i ] * $ B [ $ n - $ i - 1 ] ) ; return $ result ; } $ A = array ( 3 , 1 , 1 ) ; $ B = array ( 6 , 5 , 4 ) ; $ n = sizeof ( $ A ) / sizeof ( $ A [ 0 ] ) ; echo minValue ( $ A , $ B , $ n ) ; ? >"}
{"text": "Nombor maksimum yang boleh dipaparkan pada tujuh paparan segmen menggunakan segmen N | Berfungsi untuk mencetak nombor maksimum yang boleh dibentuk menggunakan segmen N; Jika n adalah ganjil; Gunakan 3 tiga segmen untuk mencetak 7; baki untuk mencetak 1; Jika n juga; Cetak n / 2 1 s. ; Kod pemandu", "code": "< ? php function printMaxNumber ( $ n ) { if ( $ n & 1 ) { echo \"7\" ; for ( $ i = 0 ; $ i < ( $ n - 3 ) / 2 ; $ i ++ ) echo \"1\" ; } else { for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) echo \"1\" ; } } $ n = 5 ; printMaxNumber ( $ n ) ; ? >"}
{"text": "Partition array seperti ke segmen peningkatan maksimum | Mengembalikan bilangan maksimum subarray yang disusun dalam partition yang sah; Cari nilai minimum dari kanan untuk setiap indeks; Mencari awalan terpendek supaya semua elemen dalam awalan kurang daripada atau sama dengan unsur -unsur di seluruh array. ; Jika max semasa kurang daripada awalan kanan min, kami meningkatkan bilangan partition. ; Kod pemacu; Cari nilai minimum dari kanan untuk setiap indeks", "code": "< ? php function sorted_partitions ( $ arr , $ n ) { $ right_min [ $ n + 1 ] = array ( ) ; $ right_min [ $ n ] = PHP_INT_MAX ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ right_min [ $ i ] = min ( $ right_min [ $ i + 1 ] , $ arr [ $ i ] ) ; } $ partitions = 0 ; for ( $ current_max = $ arr [ 0 ] , $ i = 0 ; $ i < $ n ; $ i ++ ) { $ current_max = max ( $ current_max , $ arr [ $ i ] ) ; if ( $ current_max <= $ right_min [ $ i + 1 ] ) $ partitions ++ ; } return $ partitions ; } $ arr = array ( 3 , 1 , 2 , 4 , 100 , 7 , 9 ) ; $ n = sizeof ( $ arr ) ; $ ans = sorted_partitions ( $ arr , $ n ) ; echo $ ans , \" STRNEWLINE \" ; ? >"}
{"text": "Kurangkan kos dengan penggantian dengan yang lain dibenarkan | Fungsi ini mengembalikan kos minimum array; Kod didorong", "code": "< ? php function getMinCost ( $ arr , $ n ) { $ min_ele = min ( $ arr ) ; return $ min_ele * ( $ n - 1 ) ; } $ arr = array ( 4 , 2 , 5 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo getMinCost ( $ arr , $ n ) ; #This  code contributed by ajit NEW_LINE ? >"}
{"text": "Semak jika mungkin untuk kembali ke kedudukan permulaan selepas bergerak ke arah yang diberikan | Kaedah utama; $ n = 0; Count of North $ s = 0; Count of South $ e = 0; Count of East $ w = 0; Count of West", "code": "< ? php $ st = \" NNNWEWESSS \" ; $ len = strlen ( $ st ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ st [ $ i ] == ' N ' ) $ n += 1 ; if ( $ st [ $ i ] == ' S ' ) $ s += 1 ; if ( $ st [ $ i ] == ' W ' ) $ w += 1 ; if ( $ st [ $ i ] == ' E ' ) $ e += 1 ; } if ( $ n == $ s && $ w == $ e ) echo \" YES STRNEWLINE \" ; else echo \" NO STRNEWLINE \" ; ? >"}
{"text": "Kos minimum untuk membuat saiz array 1 dengan mengeluarkan lebih besar pasangan | fungsi untuk mengira kos minimum; Kos minimum adalah n - 1 didarab dengan elemen minimum. ; Kod pemacu", "code": "< ? php function cost ( $ a , $ n ) { return ( $ n - 1 ) * ( min ( $ a ) ) ; } $ a = array ( 4 , 3 , 2 ) ; $ n = count ( $ a ) ; echo cost ( $ a , $ n ) ; ? >"}
{"text": "Kos minimum untuk memperoleh semua duit syiling dengan d syiling tambahan yang dibenarkan dengan setiap duit syiling | fungsi untuk mengira kos min; menyusun nilai syiling; Kirakan tidak. duit syiling yang diperlukan; hitung jumlah semua syiling terpilih; Kod pemacu", "code": "< ? php function minCost ( $ coin , $ n , $ k ) { sort ( $ coin ) ; sort ( $ coin , $ n ) ; $ coins_needed = ceil ( 1.0 * $ n / ( $ k + 1 ) ) ; $ ans = 0 ; for ( $ i = 0 ; $ i <= $ coins_needed - 1 ; $ i ++ ) $ ans += $ coin [ $ i ] ; return $ ans ; } { $ coin = array ( 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 ) ; $ n = sizeof ( $ coin ) / sizeof ( $ coin [ 0 ] ) ; $ k = 3 ; echo minCost ( $ coin , $ n , $ k ) ; return 0 ; } ? >"}
{"text": "Urutan Gould | Fungsi utiliti untuk mengira nombor ganjil dalam baris segitiga Pascals; Inisialisasi kiraan sebagai sifar; Kembali 2 ^ Count; Berfungsi untuk menjana urutan Gould; gelung untuk menjana urutan Gould sehingga n; Dapatkan n; Panggilan fungsi", "code": "< ? php function countOddNumber ( $ row_num ) { $ count = 0 ; while ( $ row_num ) { $ count += $ row_num & 1 ; $ row_num >>= 1 ; } return ( 1 << $ count ) ; } function gouldSequence ( $ n ) { for ( $ row_num = 0 ; $ row_num < $ n ; $ row_num ++ ) { echo countOddNumber ( $ row_num ) , \" \" ; } } $ n = 16 ; gouldSequence ( $ n ) ; ? >"}
{"text": "Jubin dengan domino | Program PHP untuk mencari tidak. cara untuk mengisi papan 3 XN dengan 2 domino X1. ; Kod pemacu", "code": "< ? php function countWays ( $ n ) { $ A = array ( ) ; $ B = array ( ) ; $ A [ 0 ] = 1 ; $ A [ 1 ] = 0 ; $ B [ 0 ] = 0 ; $ B [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ A [ $ i ] = $ A [ $ i - 2 ] + 2 * $ B [ $ i - 1 ] ; $ B [ $ i ] = $ A [ $ i - 1 ] + $ B [ $ i - 2 ] ; } return $ A [ $ n ] ; } $ n = 8 ; echo countWays ( $ n ) ; ? >"}
{"text": "Newman | Fungsi rekursif untuk mencari elemen n - th; Kod pemacu", "code": "< ? php function sequence ( $ n ) { if ( $ n == 1 $ n == 2 ) return 1 ; else return sequence ( sequence ( $ n - 1 ) ) + sequence ( $ n - sequence ( $ n - 1 ) ) ; } $ n = 10 ; echo ( sequence ( $ n ) ) ; ? >"}
{"text": "Mengira pasangan apabila seseorang boleh membentuk pasangan dengan yang paling satu | Bilangan cara peserta boleh mengambil bahagian. ; Keadaan asas; Peserta boleh memilih untuk mempertimbangkan (1) masih tunggal. Bilangan orang berkurangan kepada (x - 1) (2) pasang dengan salah satu daripada (x - 1) yang lain. Bagi setiap pasangan, bilangan peopl mengurangkan kepada (x - 2). ; Kod pemacu", "code": "< ? php function numberOfWays ( $ x ) { if ( $ x == 0 $ x == 1 ) return 1 ; else return numberOfWays ( $ x - 1 ) + ( $ x - 1 ) * numberOfWays ( $ x - 2 ) ; } $ x = 3 ; echo numberOfWays ( $ x ) ; ? >"}
{"text": "Mengira pasangan apabila seseorang boleh membentuk pasangan dengan yang paling satu | Program PHP untuk bilangan cara di mana peserta boleh mengambil bahagian. ; Kod pemacu", "code": "< ? php function numberOfWays ( $ x ) { $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ x ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; return $ dp [ $ x ] ; } $ x = 3 ; echo numberOfWays ( $ x ) ; ? >"}
{"text": "Susunan berulang yang paling lama | Rujuk https: www. Geeksforgeeks. org / terpanjang - mengulangi - seterusnya / untuk kod lengkap. Fungsi ini terutamanya mengembalikan LCS (STR, STR) dengan syarat bahawa aksara yang sama pada indeks yang sama tidak dipertimbangkan. ; Buat dan memulakan jadual DP; Mengisi jadual DP (serupa dengan gelung LCS); Jika watak sepadan dan indeks tidak sama; Sekiranya watak tidak sepadan", "code": "< ? php function findLongestRepeatingSubSeq ( $ str ) { $ n = strlen ( $ str ) ; $ dp = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ n + 1 , NULL ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ str [ $ i - 1 ] == $ str [ $ j - 1 ] && $ i != $ j ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } } return $ dp [ $ n ] [ $ n ] ; } ? >"}
{"text": "Bilangan cara untuk mengatur item n di bawah kekangan yang diberikan | kaedah mengembalikan bilangan cara dengan item yang boleh diatur; Hitung nilai pekali binomial dengan cara bawah; Kes asas; Hitung nilai menggunakan nilai yang disimpan sebelumnya; mengisytiharkan array DP untuk menyimpan hasil sehingga item berwarna; Pembolehubah untuk menjejaki kiraan item yang dipertimbangkan sehingga sekarang; gelung atas semua warna yang berbeza; Mengisi nilai seterusnya menggunakan nilai semasa dan hubungan yang dinyatakan; Nilai pulangan yang disimpan pada indeks terakhir; Kod pemacu", "code": "< ? php function waysToArrange ( $ N , $ K , $ k ) { $ C [ $ N + 1 ] [ $ N + 1 ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = ( $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ) ; } } $ dp [ $ K ] = array ( ) ; $ count = 0 ; $ dp [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ K ; $ i ++ ) { $ dp [ $ i + 1 ] = ( $ dp [ $ i ] * $ C [ $ count + $ k [ $ i ] - 1 ] [ $ k [ $ i ] - 1 ] ) ; $ count += $ k [ $ i ] ; } return $ dp [ $ K ] ; } $ N = 4 ; $ k = array ( 2 , 2 ) ; $ K = sizeof ( $ k ) ; echo waysToArrange ( $ N , $ K , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text": "Sel minimum yang diperlukan untuk mencapai destinasi dengan melompat sama dengan nilai sel | berfungsi untuk mengira sel minimum yang diperlukan untuk dilindungi untuk mencapai destinasi; untuk menyimpan sel min yang diperlukan untuk dilindungi untuk mencapai sel tertentu; Pada mulanya tiada sel boleh dicapai; Kes asas; membina matriks DP [] []; dp [i] [j]! = int_max menandakan bahawa sel (i, j) boleh dicapai dari sel (0, 0) dan separuh lagi keadaan mendapati sel di sebelah kanan yang dapat dicapai dari (i, j); Separuh lagi keadaan mendapati sel betul di bawah yang boleh dicapai dari (i, j); Ia benar kemudian sel (m - 1, n - 1) boleh dicapai dari sel (0, 0) dan mengembalikan bilangan minimum sel yang dilindungi; sel (m - 1, n - 1) tidak dapat dicapai dari sel (0, 0); Kod pemacu", "code": "< ? php function minCells ( $ mat , $ m , $ n ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = PHP_INT_MAX ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ dp [ $ i ] [ $ j ] != PHP_INT_MAX and ( $ j + $ mat [ $ i ] [ $ j ] ) < $ n and ( $ dp [ $ i ] [ $ j ] + 1 ) < $ dp [ $ i ] [ $ j + $ mat [ $ i ] [ $ j ] ] ) $ dp [ $ i ] [ $ j + $ mat [ $ i ] [ $ j ] ] = $ dp [ $ i ] [ $ j ] + 1 ; if ( $ dp [ $ i ] [ $ j ] != PHP_INT_MAX and ( $ i + $ mat [ $ i ] [ $ j ] ) < $ m and ( $ dp [ $ i ] [ $ j ] + 1 ) < $ dp [ $ i + $ mat [ $ i ] [ $ j ] ] [ $ j ] ) $ dp [ $ i + $ mat [ $ i ] [ $ j ] ] [ $ j ] = $ dp [ $ i ] [ $ j ] + 1 ; } } if ( $ dp [ $ m - 1 ] [ $ n - 1 ] != PHP_INT_MAX ) return $ dp [ $ m - 1 ] [ $ n - 1 ] ; return -1 ; } $ mat = array ( array ( 2 , 3 , 2 , 1 , 4 ) , array ( 3 , 2 , 5 , 8 , 2 ) , array ( 1 , 1 , 2 , 2 , 1 ) ) ; $ m = 3 ; $ n = 5 ; echo \" Minimum ▁ number ▁ of ▁ cells ▁ = ▁ \" , minCells ( $ mat , $ m , $ n ) ; ? >"}
{"text": "Memaksimumkan matriks binari dengan filpping submatrix sekali | Program PHP untuk mencari bilangan maksimum yang selepas satu membalikkan matriks binari; Pulangan bilangan yang dalam submatrix persegi saiz k x k bermula dari (x, y); Pulangan maksimum 1 s selepas membalikkan submatrix; Precomputing bilangan 1 s; Mencari bilangan maksimum 1 s selepas membalikkan; Kod pemacu", "code": "< ? php $ R = 3 ; $ C = 3 ; function cal ( $ ones , $ x , $ y , $ k ) { return $ ones [ $ x + $ k - 1 ] [ $ y + $ k - 1 ] - $ ones [ $ x - 1 ] [ $ y + $ k - 1 ] - $ ones [ $ x + $ k - 1 ] [ $ y - 1 ] + $ ones [ $ x - 1 ] [ $ y - 1 ] ; } function sol ( $ mat ) { global $ C , $ R ; $ ans = 0 ; $ ones = array_fill ( 0 , $ R + 1 , array_fill ( 0 , $ C + 1 , 0 ) ) ; for ( $ i = 1 ; $ i <= $ R ; $ i ++ ) for ( $ j = 1 ; $ j <= $ C ; $ j ++ ) $ ones [ $ i ] [ $ j ] = $ ones [ $ i - 1 ] [ $ j ] + $ ones [ $ i ] [ $ j - 1 ] - $ ones [ $ i - 1 ] [ $ j - 1 ] + ( int ) ( $ mat [ $ i - 1 ] [ $ j - 1 ] == 1 ) ; for ( $ k = 1 ; $ k <= min ( $ R , $ C ) ; $ k ++ ) for ( $ i = 1 ; $ i + $ k - 1 <= $ R ; $ i ++ ) for ( $ j = 1 ; $ j + $ k - 1 <= $ C ; $ j ++ ) $ ans = max ( $ ans , ( $ ones [ $ R ] [ $ C ] + $ k * $ k - 2 * cal ( $ ones , $ i , $ j , $ k ) ) ) ; return $ ans ; } $ mat = array ( array ( 0 , 0 , 1 ) , array ( 0 , 0 , 1 ) , array ( 1 , 0 , 1 ) ) ; echo sol ( $ mat ) ; ? >"}
{"text": "Langkah minimum untuk meminimumkan n seperti keadaan yang diberikan | Penyelesaian berasaskan tabulasi dalam PHP; Kod pemacu", "code": "< ? php function getMinSteps ( $ n ) { $ table = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] = $ n - $ i ; for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { if ( ! ( $ i % 2 ) ) $ table [ $ i / 2 ] = min ( $ table [ $ i ] + 1 , $ table [ $ i / 2 ] ) ; if ( ! ( $ i % 3 ) ) $ table [ $ i / 3 ] = min ( $ table [ $ i ] + 1 , $ table [ $ i / 3 ] ) ; } return $ table [ 1 ] ; } $ n = 10 ; echo getMinSteps ( $ n ) ; ? >"}
{"text": "Susunan terpanjang sedemikian rupa sehingga perbezaan di antara penjahat adalah satu | Berfungsi untuk mencari panjang berikutnya terpanjang; Inisialisasi array DP [] dengan 1 sebagai elemen tunggal akan menjadi 1 panjang; Mula melintasi array yang diberikan; Bandingkan dengan semua elemen sebelumnya; Jika elemen berturut -turut maka pertimbangkan berikutnya dan kemas kini DP [i] jika diperlukan. ; Panjang terpanjang akan menjadi nilai maksimum array DP. ; Paling terpanjang dengan satu perbezaan ialah {1, 2, 3, 4, 3, 2}", "code": "< ? php function longestSubseqWithDiffOne ( $ arr , $ n ) { $ dp [ $ n ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( ( $ arr [ $ i ] == $ arr [ $ j ] + 1 ) || ( $ arr [ $ i ] == $ arr [ $ j ] - 1 ) ) $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ j ] + 1 ) ; } } $ result = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ result < $ dp [ $ i ] ) $ result = $ dp [ $ i ] ; return $ result ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; echo longestSubseqWithDiffOne ( $ arr , $ n ) ; ? >"}
{"text": "Bukan | Fungsi berasaskan pengaturcaraan dinamik untuk mencari nombor Catalan n; Memulakan dua nilai pertama dalam jadual; Isi penyertaan di Catalan [] menggunakan formula rekursif; Kembali entri terakhir; Mengembalikan cara untuk menyambungkan titik N pada bulatan supaya tidak ada dua garis penyambung menyeberang antara satu sama lain dan setiap titik dihubungkan dengan satu titik lain. ; Buang ralat jika n adalah ganjil; Lain kembali nombor Catalan n / 2 '; Kod pemacu", "code": "< ? php function catalanDP ( $ n ) { $ catalan [ 0 ] = $ catalan [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ catalan [ $ i ] = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ catalan [ $ i ] += $ catalan [ $ j ] * $ catalan [ $ i - $ j - 1 ] ; } return $ catalan [ $ n ] ; } function countWays ( $ n ) { if ( $ n & 1 ) { echo \" Invalid \" ; return 0 ; } return catalanDP ( $ n / 2 ) ; } echo countWays ( 6 ) , \" \" ; ? >"}
{"text": "Cara untuk mengatur bola sedemikian rupa sehingga bola bersebelahan adalah pelbagai jenis | Program PHP untuk mengira bilangan cara untuk mengatur tiga jenis bola sehingga tidak ada dua bola warna yang sama bersebelahan antara satu sama lain; Jadual untuk menyimpan untuk menyimpan hasil subproblem; Mengembalikan kiraan pengaturan di mana bola diletakkan terakhir adalah 'terakhir'. 'terakhir' adalah 0 untuk 'p', 1 untuk 'q' dan 2 untuk 'r'; Jika bilangan bola dari mana -mana warna menjadi kurang daripada 0 bilangan cara pengaturan adalah 0; Jika bola terakhir yang diperlukan adalah jenis P dan bilangan bola jenis P adalah 1 manakala bilangan bola warna lain adalah 0 bilangan cara ialah 1 .; Kes yang sama seperti di atas untuk 'Q' dan 'R'; Jika subproblem ini sudah dinilai; Jika bola terakhir yang diperlukan adalah p dan bilangan cara adalah jumlah bilangan cara untuk membentuk urutan dengan bola 'p - 1' p, bola q q dan bola r yang berakhir dengan q dan r. ; Sama seperti kes di atas untuk 'q' dan 'r'; lain (terakhir == 2); Mengembalikan kiraan pengaturan yang diperlukan; Tiga kes timbul: Kembali Countways ($ p, $ q, $ r, 0) + bola terakhir yang diperlukan adalah jenis P Countways ($ p, $ q, $ r, 1) + bola terakhir yang diperlukan adalah jenis q countways ($ p, $ q, $ r, 2); Bola yang terakhir yang diperlukan ialah Type R; Kod pemacu", "code": "< ? php $ MAX = 100 ; $ dp = array_fill ( 0 , $ MAX , array_fill ( 0 , $ MAX , array_fill ( 0 , $ MAX , array_fill ( 0 , 3 , -1 ) ) ) ) ; function countWays ( $ p , $ q , $ r , $ last ) { global $ dp ; if ( $ p < 0 $ q < 0 $ r < 0 ) return 0 ; if ( $ p == 1 && $ q == 0 && $ r == 0 && $ last == 0 ) return 1 ; if ( $ p == 0 && $ q == 1 && $ r == 0 && $ last == 1 ) return 1 ; if ( $ p == 0 && $ q == 0 && $ r == 1 && $ last == 2 ) return 1 ; if ( $ dp [ $ p ] [ $ q ] [ $ r ] [ $ last ] != -1 ) return $ dp [ $ p ] [ $ q ] [ $ r ] [ $ last ] ; if ( $ last == 0 ) $ dp [ $ p ] [ $ q ] [ $ r ] [ $ last ] = countWays ( $ p - 1 , $ q , $ r , 1 ) + countWays ( $ p - 1 , $ q , $ r , 2 ) ; else if ( $ last == 1 ) $ dp [ $ p ] [ $ q ] [ $ r ] [ $ last ] = countWays ( $ p , $ q - 1 , $ r , 0 ) + countWays ( $ p , $ q - 1 , $ r , 2 ) ; $ dp [ $ p ] [ $ q ] [ $ r ] [ $ last ] = countWays ( $ p , $ q , $ r - 1 , 0 ) + countWays ( $ p , $ q , $ r - 1 , 1 ) ; return $ dp [ $ p ] [ $ q ] [ $ r ] [ $ last ] ; } function countUtil ( $ p , $ q , $ r ) { } $ p = 1 ; $ q = 1 ; $ r = 1 ; print ( countUtil ( $ p , $ q , $ r ) ) ; ? >"}
{"text": "Count derangements (permutasi supaya tiada elemen muncul dalam kedudukan asalnya) | Berfungsi untuk mengira kecemasan; Kes asas; penghitungan (n) = (n - 1) [pengiraan (n - 1) + der (n - 2)]; Kod pemacu", "code": "< ? php function countDer ( $ n ) { if ( $ n == 1 ) return 0 ; if ( $ n == 2 ) return 1 ; return ( $ n - 1 ) * ( countDer ( $ n - 1 ) + countDer ( $ n - 2 ) ) ; } $ n = 4 ; echo \" Count ▁ of ▁ Derangements ▁ is ▁ \" , countDer ( $ n ) ; ? >"}
{"text": "Count derangements (permutasi supaya tiada elemen muncul dalam kedudukan asalnya) | Berfungsi untuk mengira kecemasan; Kes asas; Isi der [0 .. n] dengan cara bawah menggunakan formula rekursif di atas; Keputusan pulangan untuk n; Kod pemacu", "code": "< ? php function countDer ( $ n ) { $ der [ 1 ] = 0 ; $ der [ 2 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; ++ $ i ) $ der [ $ i ] = ( $ i - 1 ) * ( $ der [ $ i - 1 ] + $ der [ $ i - 2 ] ) ; return $ der [ $ n ] ; } $ n = 4 ; echo \" Count ▁ of ▁ Derangements ▁ is ▁ \" , countDer ( $ n ) ; ? >"}
{"text": "Cari bilangan penyelesaian persamaan linear pembolehubah N | Mengembalikan kiraan penyelesaian untuk RHS dan koefisien yang diberikan Coeff [0. n - 1]; Membuat dan memulakan jadual untuk menyimpan hasil subproblem; Mengisi jadual dengan cara bawah; Kod pemacu", "code": "< ? php function countSol ( $ coeff , $ n , $ rhs ) { $ dp = str_repeat ( \" \\0\" , 256 ) ; $ dp [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ coeff [ $ i ] ; $ j <= $ rhs ; $ j ++ ) $ dp [ $ j ] = $ dp [ $ j ] + ( $ dp [ $ j - $ coeff [ $ i ] ] ) ; return $ dp [ $ rhs ] ; } $ coeff = array ( 2 , 2 , 5 ) ; $ rhs = 4 ; $ n = sizeof ( $ coeff ) / sizeof ( $ coeff [ 0 ] ) ; echo countSol ( $ coeff , $ n , $ rhs ) ; ? >"}
{"text": "Pemotongan Produk Maksimum | DP | Fungsi utama yang mengembalikan produk maksimum; N sama dengan 2 atau 3 mesti dikendalikan secara eksplisit; Terus mengeluarkan bahagian saiz 3 manakala n lebih besar daripada 4; Simpan mendarab 3 ke res; Bahagian terakhir didarabkan oleh bahagian sebelumnya; Kod pemacu", "code": "< ? php function maxProd ( $ n ) { if ( $ n == 2 $ n == 3 ) return ( $ n - 1 ) ; $ res = 1 ; while ( $ n > 4 ) { $ n = $ n - 3 ; $ res = $ res * 3 ; } return ( $ n * $ res ) ; } echo ( \" Maximum ▁ Product ▁ is ▁ \" ) ; echo ( maxProd ( 10 ) ) ; ? >"}
{"text": "Dadu membuang | DP | Fungsi utama yang mengembalikan bilangan cara untuk mendapatkan jumlah 'x' dengan 'n' dice dan 'm' dengan wajah m. ; Buat jadual untuk menyimpan hasil subproblem. Satu baris dan lajur tambahan digunakan untuk kesilapan (bilangan dadu secara langsung digunakan sebagai indeks baris dan jumlahnya secara langsung digunakan sebagai indeks lajur). Penyertaan dalam baris 0 dan lajur 0 tidak pernah digunakan. ; Penyertaan jadual untuk hanya satu dadu; Isi sisa penyertaan dalam jadual menggunakan hubungan rekursif i: bilangan dadu, j: jumlah; Nilai pulangan; Kod pemacu", "code": "< ? php function findWays ( $ m , $ n , $ x ) { $ table ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) for ( $ j = 1 ; $ j < $ x + 1 ; $ j ++ ) $ table [ $ i ] [ $ j ] = 0 ; for ( $ j = 1 ; $ j <= $ m && $ j <= $ x ; $ j ++ ) $ table [ 1 ] [ $ j ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ x ; $ j ++ ) for ( $ k = 1 ; $ k <= $ m && $ k < $ j ; $ k ++ ) $ table [ $ i ] [ $ j ] += $ table [ $ i - 1 ] [ $ j - $ k ] ; return $ table [ $ n ] [ $ x ] ; } echo findWays ( 4 , 2 , 1 ) . \" STRNEWLINE \" ; echo findWays ( 2 , 2 , 3 ) . \" STRNEWLINE \" ; echo findWays ( 6 , 3 , 8 ) . \" STRNEWLINE \" ; echo findWays ( 4 , 2 , 5 ) . \" STRNEWLINE \" ; echo findWays ( 4 , 3 , 5 ) . \" STRNEWLINE \" ; ? >"}
{"text": "Palindromik Palindromik Terpanjang | DP | Mengembalikan panjang Palindromic yang paling lama di SEQ; Kes asas 1: Jika hanya ada 1 aksara; Kes asas 2: Jika hanya terdapat 2 aksara dan kedua -duanya sama; Jika watak pertama dan terakhir sepadan; Jika watak pertama dan terakhir tidak sepadan; Kod pemacu", "code": "< ? php function lps ( $ seq , $ i , $ j ) { if ( $ i == $ j ) return 1 ; if ( $ seq [ $ i ] == $ seq [ $ j ] && $ i + 1 == $ j ) return 2 ; if ( $ seq [ $ i ] == $ seq [ $ j ] ) return lps ( $ seq , $ i + 1 , $ j - 1 ) + 2 ; return max ( lps ( $ seq , $ i , $ j - 1 ) , lps ( $ seq , $ i + 1 , $ j ) ) ; } $ seq = \" GEEKSFORGEEKS \" ; $ n = strlen ( $ seq ) ; echo \" The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ \" . lps ( $ seq , 0 , $ n - 1 ) ; ? >"}
{"text": "Mengira kejadian rentetan yang boleh dibina dari rentetan yang lain | Berfungsi untuk mencari kiraan; Memulakan hash untuk kedua -dua rentetan; hash kekerapan huruf str1; hash kekerapan huruf str2; Cari kiraan Str2 yang dibina dari Str1; Jawapan kembali; Kod pemacu", "code": "< ? php function findCount ( $ str1 , $ str2 ) { $ len = strlen ( $ str1 ) ; $ len2 = strlen ( $ str1 ) ; $ ans = PHP_INT_MAX ; $ hash1 = array_fill ( 0 , 26 , 0 ) ; $ hash2 = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ hash1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ len2 ; $ i ++ ) $ hash2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( $ hash2 [ $ i ] ) $ ans = min ( $ ans , $ hash1 [ $ i ] / $ hash2 [ $ i ] ) ; return $ ans ; } $ str1 = \" geeksclassesatnoida \" ; $ str2 = \" sea \" ; echo findCount ( $ str1 , $ str2 ) ; ? >"}
{"text": "Semak jika rentetan adalah nama yang ditaip nama yang diberikan | Periksa sama ada watak itu vokal atau tidak; Pulangan benar jika 'ditaip' adalah nama yang ditaip yang diberikan str; Melintasi semua watak STR. ; Sekiranya aksara semasa tidak sepadan; Jika tidak vokal, hanya bergerak ke hadapan dalam kedua -duanya; Mengira kejadian vokal semasa dalam str; Mengira kejadian vokal semasa dalam ditaip. ; Kod pemacu", "code": "< ? php function isVowel ( $ c ) { $ vowel = \" aeiou \" ; for ( $ i = 0 ; $ i < strlen ( $ vowel ) ; ++ $ i ) if ( $ vowel [ $ i ] == $ c ) return true ; return false ; } function printRLE ( $ str , $ typed ) { $ n = strlen ( $ str ) ; $ m = strlen ( $ typed ) ; $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] != $ typed [ $ j ] ) return false ; if ( isVowel ( $ str [ $ i ] ) == false ) { $ j ++ ; continue ; } $ count1 = 1 ; while ( $ i < $ n - 1 && $ str [ $ i ] == $ str [ $ i + 1 ] ) { $ count1 ++ ; $ i ++ ; } $ count2 = 1 ; while ( $ j < $ m - 1 && $ typed [ $ j ] == $ str [ $ i ] ) { $ count2 ++ ; $ j ++ ; } if ( $ count1 > $ count2 ) return false ; } return true ; } $ name = \" alex \" ; $ typed = \" aaalaeex \" ; if ( printRLE ( $ name , $ typed ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Program untuk menggantikan perkataan dengan asterisk dalam ayat | Fungsi mengambil dua parameter; Memecahkan kalimat dengan ruang '' dan simpan setiap perkataan individu dalam senarai yang berbeza; Rentetan baru untuk menyimpan hasilnya; Mewujudkan penapis yang merupakan teks \" *\" teks panjang kata penapis; Mengira pembolehubah untuk mengakses Word_List kami; Melangkah melalui senarai kata -kata yang diekstrak; mengubah perkataan yang ditapis untuk mencipta penapis asterisk; Sertailah kata -kata; Kod pemacu", "code": "< ? php function censor ( $ text , $ word ) { $ word_list = explode ( \" ▁ \" , $ text ) ; $ result = ' ' $ stars = \" \" ; for ( $ i = 0 ; $ i < strlen ( $ word ) ; $ i ++ ) $ stars . = \" * \" ; $ count = 0 ; $ index = 0 ; for ( $ i = 0 ; $ i < sizeof ( $ word_list ) ; $ i ++ ) { if ( $ word_list [ $ i ] == $ word ) $ word_list [ $ index ] = $ stars ; $ index += 1 ; } return implode ( ' ▁ ' , $ word_list ) ; } $ extract = \" GeeksforGeeks ▁ is ▁ a ▁ computer ▁ science ▁ \" . \" portal for geeks . I am pursuing my \" . STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL \" major in computer science . \" $ cen = \" computer \" ; echo censor ( $ extract , $ cen ) ; ? >"}
{"text": "Cari masa yang Palindromic dan datang selepas masa yang diberikan | Berfungsi untuk mengembalikan masa yang diperlukan; Untuk menyimpan masa yang dihasilkan; Jam disimpan dalam h sebagai integer; Minit disimpan dalam m sebagai integer; Terbalik h; Terbalik H sebagai rentetan; Jika mm <terbalik (hh); 0 ditambah jika HH <10; 0 ditambah jika rev_h <10; Jam kenaikan; Terbalik jam selepas kenaikan 1; 0 ditambah jika HH <10; 0 ditambah jika rev_h <10; Kod pemacu", "code": "< ? php function getTime ( $ s , $ n ) { $ res = \" \" ; $ h = intval ( $ s . substr ( 0 , 2 ) ) ; $ m = intval ( $ s . substr ( 3 , 2 ) ) ; $ rev_h = ( $ h % 10 ) * 10 + ( ( $ h % 100 ) - ( $ h % 10 ) ) / 10 ; $ rev_hs = strval ( $ rev_h ) ; if ( $ h == 23 && $ m >= 32 ) { $ res = \" - 1\" ; } else if ( $ m < $ rev_h ) { $ temp = \" \" ; if ( $ h < 10 ) $ temp = \"0\" ; $ temp = $ temp . strval ( $ h ) ; if ( $ rev_h < 10 ) $ res = $ res . $ temp . \" : 0\" . $ rev_hs ; else $ res = $ res . $ temp . \" : \" . $ rev_hs ; } else { $ h ++ ; $ rev_h = ( $ h % 10 ) * 10 + ( ( $ h % 100 ) - ( $ h % 10 ) ) / 10 ; $ rev_hs = strval ( $ rev_h ) ; $ temp = \" \" ; if ( $ h < 10 ) $ temp = \"0\" ; $ temp = $ temp . strval ( $ h ) ; if ( $ rev_h < 10 ) $ res = $ res . $ temp . \" : 0\" . $ rev_hs ; else $ res = $ res . $ temp . \" : \" . $ rev_hs ; } return $ res ; } $ s = \"21:12\" ; $ n = strlen ( $ s ) ; echo getTime ( $ s , $ n ) ; return 0 ; ? >"}
{"text": "Count of Sub | Berfungsi untuk mengembalikan kiraan sub -rentetan yang sah; Variabel ANS untuk menyimpan semua substrings yang mungkin memulakan nilainya sebagai jumlah substrings yang boleh dibentuk dari rentetan yang diberikan; Kedai indeks baru -baru ini dari watak -watak; Jika watak adalah indeks kemas kini dan pembolehubah ans; Jika watak adalah indeks b update b dan pembolehubah ans; Jika watak adalah indeks C Kod pemacu", "code": "< ? php function CountSubstring ( $ str , $ n ) { $ ans = ( $ n * ( $ n + 1 ) ) / 2 ; $ a_index = 0 ; $ b_index = 0 ; $ c_index = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' a ' ) { $ a_index = $ i + 1 ; $ ans -= min ( $ b_index , $ c_index ) ; } else if ( $ str [ $ i ] == ' b ' ) { $ b_index = $ i + 1 ; $ ans -= min ( $ a_index , $ c_index ) ; } else { $ c_index = $ i + 1 ; $ ans -= min ( $ a_index , $ b_index ) ; } } return $ ans ; } { $ str = str_split ( \" babac \" ) ; $ n = sizeof ( $ str ) ; echo ( CountSubstring ( $ str , $ n ) ) ; }"}
{"text": "Semak jika rentetan binari mengandungi sama berturut -turut atau tidak | Fungsi yang pulangan benar adalah STR adalah sah; Dengan mengandaikan rentetan adalah binari jika ada dua aksara berturut -turut adalah sama maka rentetan tidak sah; Jika rentetan bergantian; Kod pemacu", "code": "< ? php function isValid ( $ str , $ len ) { for ( $ i = 1 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == $ str [ $ i - 1 ] ) return false ; } return true ; } $ str = \"0110\" ; $ len = strlen ( $ str ) ; if ( isValid ( $ str , $ len ) ) echo \" Valid \" ; else echo \" Invalid \" ; ? >"}
{"text": "Minimum k sedemikian rupa sehingga setiap substring panjang atleast k mengandungi watak c | Fungsi ini memeriksa jika terdapat beberapa watak yang muncul dalam semua substrings panjang K; Melangkah ke atas semua watak yang mungkin; menyimpan kejadian terakhir; Tetapkan jawapan sebagai benar; ; Tiada kejadian yang dijumpai watak semasa dalam substring pertama panjang k; Semak setiap substring terakhir panjang k di mana berlaku terakhir - ada dalam substring; Jika OCC terakhir tidak hadir dalam substring; Watak semasa adalah K AMAZING; Fungsi ini melakukan carian binari atas jawapan untuk meminimumkannya; Semak jika jawapan dijumpai cuba meminimumkannya; Kod pemacu", "code": "< ? php function check ( $ s , $ K ) { for ( $ ch = 0 ; $ ch < 26 ; $ ch ++ ) { $ c = chr ( ord ( ' a ' ) + $ ch ) ; $ last = -1 ; $ found = true ; for ( $ i = 0 ; $ i < $ K ; $ i ++ ) if ( $ s [ $ i ] == $ c ) $ last = $ i ; if ( $ last == -1 ) continue ; for ( $ i = $ K ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ c ) $ last = $ i ; if ( $ last <= ( $ i - $ K ) ) { $ found = false ; break ; } } if ( $ found ) return 1 ; } return 0 ; } function binarySearch ( $ s ) { $ low = 1 ; $ high = strlen ( $ s ) ; while ( $ low <= $ high ) { $ mid = ( $ high + $ low ) >> 1 ; if ( check ( $ s , $ mid ) ) { $ ans = $ mid ; $ high = $ mid - 1 ; } else $ low = $ mid + 1 ; } return $ ans ; } $ s = \" abcde \" ; echo binarySearch ( $ s ) . \" STRNEWLINE \" ; $ s = \" aaaa \" ; echo binarySearch ( $ s ) . \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika nombor boleh dipaparkan menggunakan tujuh segmen LED | Nilai -nilai segmen yang dikira sebelum ini yang digunakan oleh digit 0 hingga 9 .; Semak sama ada mungkin untuk memaparkan nombor; Mencari jumlah segmen yang digunakan oleh setiap digit nombor; Kod pemacu; Fungsi panggilan untuk mencetak jawapan yang diperlukan", "code": "< ? php $ seg = array ( 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ) ; function LedRequired ( $ s , $ led ) { $ count = 0 ; global $ seg ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; ++ $ i ) { $ count += $ seg [ ord ( $ s [ $ i ] ) - 48 ] ; } if ( $ count <= $ led ) return \" YES \" ; else return \" NO \" ; } $ S = \"123456789\" ; $ led = 20 ; echo LedRequired ( $ S , $ led ) ; ? >"}
{"text": "Kira bilangan vokal yang berlaku dalam semua substrings rentetan yang diberikan | Mengembalikan jumlah keseluruhan kejadian semua vokal; Tidak. kejadian watak ke -0 dalam semua substring; Tidak. kejadian watak ith dalam semua substrings; Semak sama ada wataknya adalah vokal; Mengembalikan jumlah keseluruhan kejadian vokal; Kod pemacu", "code": "< ? php function vowel_calc ( $ s ) { $ n = strlen ( $ s ) ; $ arr = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i == 0 ) $ arr [ $ i ] = $ n ; else $ arr [ $ i ] = ( $ n - $ i ) + $ arr [ $ i - 1 ] - $ i ; } $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' $ s [ $ i ] == ' e ' $ s [ $ i ] == ' i ' $ s [ $ i ] == ' o ' $ s [ $ i ] == ' u ' ) $ sum += $ arr [ $ i ] ; } return $ sum ; } $ s = \" daceh \" ; echo ( vowel_calc ( $ s ) ) ; ? >"}
{"text": "Kira semua palindrome yang merupakan persegi palindrome | Semak sama ada nombor adalah palindrome; Fungsi untuk mengembalikan kiraan palindromes yang diperlukan; Julat [l, r]; Had atas; mengira panjang palindromes; jika s = '1234'; Kemudian, t = '1234321'; mengira panjang palindromes; jika s = '1234'; Kemudian, t = '12344321'; Kembali kiraan super - palindromes; Kod pemacu; panggilan fungsi untuk mendapatkan jawapan yang diperlukan", "code": "< ? php function ispalindrome ( $ x ) { $ ans = 0 ; $ temp = $ x ; while ( $ temp > 0 ) { $ ans = ( 10 * $ ans ) + ( $ temp % 10 ) ; $ temp = ( int ) ( $ temp / 10 ) ; } return $ ans == $ x ; } function SuperPalindromes ( $ L , $ R ) { $ L = ( int ) $ L ; $ R = ( int ) $ R ; $ LIMIT = 100000 ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ LIMIT ; $ i ++ ) { $ s = ( string ) $ i ; $ rs = substr ( $ s , 0 , strlen ( $ s ) - 1 ) ; $ p = $ s . strrev ( $ rs ) ; $ p_sq = ( int ) $ p * * 2 ; if ( $ p_sq > $ R ) { break ; } if ( $ p_sq >= $ L and ispalindrome ( $ p_sq ) ) { $ ans = $ ans + 1 ; } } for ( $ i = 0 ; $ i < $ LIMIT ; $ i ++ ) { $ s = ( string ) $ i ; $ p = $ s . strrev ( $ s ) ; $ p_sq = ( int ) $ p * * 2 ; if ( $ p_sq > $ R ) { break ; } if ( $ p_sq >= $ L and ispalindrome ( $ p_sq ) ) { $ ans = $ ans + 1 ; } } return $ ans ; } $ L = \"4\" ; $ R = \"1000\" ; echo SuperPalindromes ( $ L , $ R ) ; ? >"}
{"text": "Sub | Fungsi yang mengira semua sub -rentetan panjang 'k' yang mempunyai semua watak yang sama; kiraan sub -rentetan, panjang, kedudukan awal tetingkap gelongsor; peta untuk menyimpan kekerapan aksara sub -rentetan; meningkatkan kekerapan watak dan panjang sub -rentetan; Jika panjang sub -rentetan lebih besar daripada k; Keluarkan watak dari permulaan sub -rentetan; Jika panjang rentetan sub adalah sama dengan k dan kekerapan salah satu wataknya adalah sama dengan panjang sub -rentetan i. e. Semua watak yang sama meningkatkan kiraan; Paparkan bilangan sub -rentetan yang sah; Kod pemacu", "code": "< ? php function solve ( $ s , $ k ) { $ count = 0 ; $ length = 0 ; $ pos = 0 ; $ m = array ( ) ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ m [ $ s [ $ i ] ] ++ ; $ length ++ ; if ( $ length > $ k ) { $ m [ $ s [ $ pos ++ ] ] -- ; $ length -- ; } if ( $ length == $ k && $ m [ $ s [ $ i ] ] == $ length ) $ count ++ ; } echo $ count . \" STRNEWLINE \" ; } $ s = \" aaaabbbccdddd \" ; $ k = 4 ; solve ( $ s , $ k ) ; ? >"}
{"text": "Program untuk menggantikan setiap ruang dalam rentetan dengan tanda hubung | Dapatkan rentetan; Melintasi watak rentetan dengan watak. ; Menukar watak ith ke ' -' jika ia adalah ruang. ; Cetak rentetan yang diubahsuai.", "code": "< ? php $ str = \" A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks \" ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; ++ $ i ) { if ( $ str [ $ i ] == ' ▁ ' ) { $ str [ $ i ] = ' - ' ; } } echo $ str . \" STRNEWLINE \" ;"}
{"text": "Semak jika ada permutasi sejumlah besar boleh dibahagikan dengan 8 | Program PHP untuk memeriksa sama ada sebarang permutasi sejumlah besar boleh dibahagikan dengan 8 atau tidak; Berfungsi untuk memeriksa sama ada permutasi sejumlah besar boleh dibahagikan dengan 8; Kurang daripada tiga nombor digit boleh diperiksa secara langsung. ; Periksa sebaliknya nombor; Menyimpan kekerapan aksara dalam n. ; Berulang untuk ketiga -tiga nombor digit yang boleh dibahagikan dengan 8; menyimpan kekerapan semua digit tunggal dalam nombor tiga digit; Semak sama ada nombor asal mempunyai digit; Apabila semua diperiksa tidak mungkin; Kod pemacu", "code": "< ? php error_reporting ( 0 ) ; function solve ( $ n , $ l ) { if ( $ l < 3 ) { if ( intval ( $ n ) % 8 == 0 ) return true ; strrev ( $ n ) ; if ( intval ( $ n ) % 8 == 0 ) return true ; return false ; } $ hash [ 10 ] = array ( 0 ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ hash [ $ n [ $ i ] - '0' ] ++ ; for ( $ i = 104 ; $ i < 1000 ; $ i += 8 ) { $ dup = $ i ; $ freq [ 10 ] = array ( 0 ) ; $ freq [ $ dup % 10 ] ++ ; $ dup = $ dup / 10 ; $ freq [ $ dup % 10 ] ++ ; $ dup = $ dup / 10 ; $ freq [ $ dup % 10 ] ++ ; $ dup = $ i ; if ( $ freq [ $ dup % 10 ] > $ hash [ $ dup % 10 ] ) continue ; $ dup = $ dup / 10 ; if ( $ freq [ $ dup % 10 ] > $ hash [ $ dup % 10 ] ) continue ; $ dup = $ dup / 10 ; if ( $ freq [ $ dup % 10 ] > $ hash [ $ dup % 10 ] ) continue ; return true ; } return false ; } $ number = \"31462708\" ; $ l = strlen ( $ number ) ; if ( solve ( $ number , $ l ) ) echo \" Yes \" ; else echo \" No \" ;"}
{"text": "Rentetan terkecil lexicographically dibentuk dengan memancarkan watak dari watak k pertama rentetan yang diberikan | Berfungsi untuk mencari rentetan baru yang dibentuk dengan mengeluarkan aksara; rentetan baru; Keluarkan aksara sehingga rentetan kosong; Melintasi mencari watak terkecil dalam watak -watak K pertama; tambah watak terkecil; mengeluarkan watak terkecil secara leksikografi dari rentetan; Kod pemacu", "code": "< ? php function newString ( $ s , $ k ) { $ X = \" \" ; while ( strlen ( $ s ) > 0 ) { $ temp = $ s [ 0 ] ; for ( $ i = 1 ; $ i < $ k && $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] < $ temp ) { $ temp = $ s [ $ i ] ; } } $ X = $ X . $ temp ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { if ( $ s [ $ i ] == $ temp ) { $ s = substr ( $ s , 0 , $ i ) . substr ( $ s , $ i + 1 , strlen ( $ s ) ) ; break ; } } } return $ X ; } $ s = \" gaurang \" ; $ k = 3 ; echo ( newString ( $ s , $ k ) ) ; ? >"}
{"text": "Tukar rentetan ke dalam urutan binari | fungsi utiliti; Tukar setiap char ke nilai ASCII; Menukar nilai ASCII kepada binari; Kod pemacu", "code": "< ? php function strToBinary ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ val = ord ( $ s [ $ i ] ) ; $ bin = \" \" ; while ( $ val > 0 ) { ( $ val % 2 ) ? $ bin = $ bin . '1' : $ bin = $ bin . '0' ; $ val = floor ( $ val / 2 ) ; } for ( $ x = strlen ( $ bin ) - 1 ; $ x >= 0 ; $ x -- ) echo $ bin [ $ x ] ; echo \" ▁ \" ; } } $ s = \" geeks \" ; strToBinary ( $ s ) ; ? >"}
{"text": "Tukar ayat ke dalam urutan pad kekunci angka mudah alih yang bersamaan | Fungsi yang mengira urutan; panjang rentetan input; Memeriksa ruang; Mengira indeks untuk setiap watak; Urutan output; menyimpan urutan dalam pelbagai", "code": "< ? php function printSequence ( & $ arr , $ input ) { $ output = \" \" ; $ n = strlen ( $ input ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ input [ $ i ] == ' ▁ ' ) $ output = $ output + \"0\" ; else { $ position = ord ( $ input [ $ i ] ) - ord ( ' A ' ) ; $ output = $ output . $ arr [ $ position ] ; } } return $ output ; } $ str = array ( \"2\" , \"22\" , \"222\" , \"3\" , \"33\" , \"333\" , \"4\" , \"44\" , \"444\" , \"5\" , \"55\" , \"555\" , \"6\" , \"66\" , \"666\" , \"7\" , \"77\" , \"777\" , \"7777\" , \"8\" , \"88\" , \"888\" , \"9\" , \"99\" , \"999\" , \"9999\" ) ; $ input = \" GEEKSFORGEEKS \" ; echo printSequence ( $ str , $ input ) ; ? >"}
{"text": "Semak sama ada diberi nombor titik terapung adalah atau ganjil | Berfungsi untuk memeriksa walaupun atau ganjil. ; Gelung untuk melintasi nombor dari LSB; Kami mengabaikan trailing 0 s selepas titik; Jika ia '. 'Kami akan memeriksa digit seterusnya dan ini bermakna bahagian perpuluhan dilalui. ; Jika digit boleh dibahagikan dengan 2 bermakna nombor. ; Kod pemacu", "code": "< ? php function isEven ( $ s ) { $ l = strlen ( $ s ) ; $ dotSeen = false ; for ( $ i = $ l - 1 ; $ i >= 0 ; $ i -- ) { if ( $ s [ $ i ] == '0' && $ dotSeen == false ) continue ; if ( $ s [ $ i ] == ' . ' ) { $ dotSeen = true ; continue ; } if ( ( $ s [ $ i ] - '0' ) % 2 == 0 ) return true ; return false ; } } $ s = \"100.70\" ; if ( isEven ( $ s ) ) echo \" Even \" ; else echo \" Odd \" ; ? >"}
{"text": "Panjang sub terkecil | Program PHP untuk mencari panjang substring terkecil yang terdiri daripada aksara maksimum yang berbeza; Cari aksara maksimum yang berbeza dalam mana -mana rentetan; Memulakan semua kiraan watak dengan 0; Meningkatkan kiraan dalam array jika watak dijumpai; saiz rentetan yang diberikan; Cari aksara maksimum yang berbeza dalam mana -mana rentetan; hasil; Pendekatan kekerasan untuk mencari semua substring; Kita perlu menyemak di sini kedua -dua keadaan bersama -sama 1. Panjang Substring hendaklah minimum; Rentetan input", "code": "< ? php $ NO_OF_CHARS = 256 ; function max_distinct_char ( $ str , $ n ) { global $ NO_OF_CHARS ; $ count = array_fill ( 0 , $ NO_OF_CHARS , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) ] ++ ; $ max_distinct = 0 ; for ( $ i = 0 ; $ i < $ NO_OF_CHARS ; $ i ++ ) if ( $ count [ $ i ] != 0 ) $ max_distinct ++ ; return $ max_distinct ; } function smallesteSubstr_maxDistictChar ( $ str ) { $ n = strlen ( $ str ) ; $ max_distinct = max_distinct_char ( $ str , $ n ) ; $ minl = $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ subs = substr ( $ str , $ i , $ j ) ; $ subs_lenght = strlen ( $ subs ) ; $ sub_distinct_char = max_distinct_char ( $ subs , $ subs_lenght ) ; if ( $ subs_lenght < $ minl && $ max_distinct == $ sub_distinct_char ) { $ minl = $ subs_lenght ; } } } return $ minl ; } $ str = \" AABBBCBB \" ; $ len = smallesteSubstr_maxDistictChar ( $ str ) ; echo \" ▁ The ▁ length ▁ of ▁ the ▁ smallest ▁ substring \" . \" ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ characters ▁ : ▁ \" . $ len ; ? >"}
{"text": "Menilai ungkapan boolean yang diwakili sebagai rentetan | Menilai ekspresi boolean dan mengembalikan hasilnya; Melintasi semua operan dengan melompat watak selepas setiap lelaran. ; Jika pengendali bersebelahan dengan pengendali semasa adalah dan. ; Jika pengendali bersebelahan dengan operan semasa adalah atau. ; Jika pengendali bersebelahan dengan operan semasa adalah XOR (dengan mengandaikan input yang sah); Kod pemacu", "code": "< ? php function evaluateBoolExpr ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i += 2 ) { if ( ( $ i + 1 ) < $ n && $ s [ $ i + 1 ] == ' A ' ) { if ( $ s [ $ i + 2 ] == '0' $ s [ $ i ] == '0' ) $ s [ $ i + 2 ] = '0' ; else $ s [ $ i + 2 ] = '1' ; } else if ( ( $ i + 1 ) < $ n && $ s [ $ i + 1 ] == ' B ' ) { if ( $ s [ $ i + 2 ] == '1' $ s [ $ i ] == '1' ) $ s [ $ i + 2 ] = '1' ; else $ s [ $ i + 2 ] = '0' ; } else { if ( ( $ i + 2 ) < $ n && $ s [ $ i + 2 ] == $ s [ $ i ] ) $ s [ $ i + 2 ] = '0' ; else $ s [ $ i + 2 ] = '1' ; } } return $ s [ $ n - 1 ] - '0' ; } $ s = \"1C1B1B0A0\" ; echo evaluateBoolExpr ( $ s ) ;"}
{"text": "Cekik mencari watak berulang pertama dalam rentetan tanpa menggunakan sebarang struktur data tambahan dalam satu traversal | Pulangan - 1 Jika semua watak STR adalah unik. Andaian: (1) STR mengandungi hanya aksara dari 'A' hingga 'Z' (2) integer disimpan menggunakan 32 bit; Integer untuk menyimpan kehadiran / ketiadaan 26 aksara menggunakan 32 bitnya. ; Jika bit sepadan dengan watak semasa sudah ditetapkan; Tetapkan bit dalam pemeriksa; Kod pemacu", "code": "< ? php function FirstRepeated ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; ++ $ i ) { $ val = ( ord ( $ str [ $ i ] ) - ord ( ' a ' ) ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return $ i ; $ checker |= ( 1 << $ val ) ; } return -1 ; } $ s = \" abcfdeacf \" ; $ i = FirstRepeated ( $ s ) ; if ( $ i != -1 ) echo \" Char ▁ = ▁ \" . $ s [ $ i ] . \" ▁ and ▁ Index ▁ = ▁ \" . $ i ; else echo \" No ▁ repeated ▁ Char \" ; ? >"}
{"text": "Bilangan substrings dalam rentetan digit | Kembalikan substring nombor juga. ; Sekiranya digit semasa, tambah kiraan substrings yang berakhir dengannya. Kiraannya ialah (i + 1); Kod pemacu", "code": "< ? php function evenNumSubstring ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ temp = $ str [ $ i ] - '0' ; if ( $ temp % 2 == 0 ) $ count += ( $ i + 1 ) ; } return $ count ; } $ str = \"1234\" ; echo evenNumSubstring ( $ str ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari perkataan terbesar dalam kamus dengan memadam beberapa watak rentetan yang diberikan | Pulangan benar jika str1 [] adalah seterusnya STR2 []. m adalah panjang str1 dan n ialah panjang str2; Traverse Str2 dan Str1, dan membandingkan watak semasa STR2 dengan Char STR1 yang tidak dapat ditandingi pertama, jika dipadankan kemudian bergerak ke hadapan dalam STR1; Jika semua watak STR1 ditemui dalam STR2; Mengembalikan rentetan terpanjang dalam kamus yang merupakan seterusnya STR. ; Melintasi semua perkataan kamus; Sekiranya perkataan semasa adalah STR dan perkataan terbesar setakat ini. ; Kembali rentetan terpanjang; Kod pemacu", "code": "< ? php function isSubSequence ( $ str1 , $ str2 ) { $ m = strlen ( $ str1 ) ; $ n = strlen ( $ str2 ) ; for ( $ i = 0 ; $ i < $ n && $ j < $ m ; $ i ++ ) if ( $ str1 [ $ j ] == $ str2 [ $ i ] ) $ j ++ ; return ( $ j == $ m ) ; } function findLongestString ( $ dict , $ str ) { $ result = \" \" ; $ length = 0 ; foreach ( $ dict as $ word ) { if ( $ length < strlen ( $ word ) && isSubSequence ( $ word , $ str ) ) { $ result = $ word ; $ length = strlen ( $ word ) ; } } return $ result ; } $ dict = array ( \" ale \" , \" apple \" , \" monkey \" , \" plea \" ) ; $ str = \" abpcplea \" ; echo findLongestString ( $ dict , $ str ) ; ? >"}
{"text": "Semak jika mengedit jarak antara dua rentetan adalah satu | Pulangan benar jika mengedit jarak antara S1 dan S2 adalah satu, lain -lain palsu; Cari panjang rentetan yang diberikan; Jika perbezaan antara panjang lebih daripada 1, maka rentetan tidak dapat berada pada satu jarak; Count of Sedit; Jika watak semasa tidak sepadan; Jika panjang satu rentetan lebih banyak, maka hanya boleh mengedit adalah untuk mengeluarkan watak; Jika panjang kedua -dua rentetan adalah sama; Kiraan kenaikan suntingan; Sekiranya watak semasa sepadan; Jika watak terakhir adalah tambahan dalam mana -mana rentetan; Kod pemacu", "code": "< ? php function isEditDistanceOne ( $ s1 , $ s2 ) { $ m = strlen ( $ s1 ) ; $ n = strlen ( $ s2 ) ; if ( abs ( $ m - $ n ) > 1 ) return false ; $ count = 0 ; $ i = 0 ; $ j = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ s1 [ $ i ] != $ s2 [ $ j ] ) { if ( $ count == 1 ) return false ; if ( $ m > $ n ) $ i ++ ; else if ( $ m < $ n ) $ j ++ ; else { $ i ++ ; $ j ++ ; } $ count ++ ; } else { $ i ++ ; $ j ++ ; } } if ( $ i < $ m $ j < $ n ) $ count ++ ; return $ count == 1 ; } $ s1 = \" gfg \" ; $ s2 = \" gf \" ; if ( isEditDistanceOne ( $ s1 , $ s2 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Memandangkan rentetan binari, bilangan substrings yang bermula dan berakhir dengan 1. | Program PHP yang mudah untuk mengira bilangan substrings bermula dan berakhir dengan 1; Memulakan hasil; Pilih titik permulaan; Cari semua titik akhir yang mungkin; Kod pemacu", "code": "< ? php function countSubStr ( $ str ) { $ res = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) if ( $ str [ $ j ] == '1' ) $ res ++ ; } } return $ res ; } $ str = \"00100101\" ; echo countSubStr ( $ str ) ; ? >"}
{"text": "Exponentiation Modular (Recursive) | Program PHP rekursif untuk mengira kuasa modular; Kes asas; Jika B juga; Jika B adalah ganjil; Kod pemacu", "code": "< ? php function exponentMod ( $ A , $ B , $ C ) { if ( $ A == 0 ) return 0 ; if ( $ B == 0 ) return 1 ; if ( $ B % 2 == 0 ) { $ y = exponentMod ( $ A , $ B / 2 , $ C ) ; $ y = ( $ y * $ y ) % $ C ; } else { $ y = $ A % $ C ; $ y = ( $ y * exponentMod ( $ A , $ B - 1 , $ C ) % $ C ) % $ C ; } return ( ( $ y + $ C ) % $ C ) ; } $ A = 2 ; $ B = 5 ; $ C = 13 ; echo \" Power ▁ is ▁ \" . exponentMod ( $ A , $ B , $ C ) ; ? >"}
{"text": "Exponentiation Modular (Kuasa dalam Aritmetik Modular) | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang; Kod pemacu", "code": "< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; if ( $ x == 0 ) return 0 ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; y = $ y / 2 $ y = $ y >> 1 ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } $ x = 2 ; $ y = 5 ; $ p = 13 ; echo \" Power ▁ is ▁ \" , power ( $ x , $ y , $ p ) ; ? >"}
{"text": "Kawasan segitiga terbesar yang tertulis dalam segi enam | Berfungsi untuk mencari kawasan segitiga; sisi tidak boleh negatif; kawasan segitiga; Kod pemacu", "code": "< ? php function trianglearea ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = ( 3 * sqrt ( 3 ) * pow ( $ a , 2 ) ) / 4 ; return $ area ; } $ a = 6 ; echo trianglearea ( $ a ) ; ? >"}
{"text": "Persamaan Ellipse dari Fokus, Directrix, dan Excentricity | Fungsi untuk mencari persamaan elips. ; Kod pemacu", "code": "< ? php function equation_ellipse ( $ x1 , $ y1 , $ a , $ b , $ c , $ e ) { $ t = ( $ a * $ a ) + ( $ b * $ b ) ; $ a1 = $ t - $ e * ( $ a * $ a ) ; $ b1 = $ t - $ e * ( $ b * $ b ) ; $ c1 = ( -2 * $ t * $ x1 ) - ( 2 * $ e * $ c * $ a ) ; $ d1 = ( -2 * $ t * $ y1 ) - ( 2 * $ e * $ c * $ b ) ; $ e1 = -2 * $ e * $ a * $ b ; $ f1 = ( - $ e * $ c * $ c ) + ( $ t * $ x1 * $ x1 ) + ( $ t * $ y1 * $ y1 ) ; $ fixed ; echo \" Equation ▁ of ▁ ellipse ▁ is ▁ STRNEWLINE \" , $ a1 , \" ▁ x ^ 2 ▁ + ▁ \" , $ b1 , \" ▁ y ^ 2 ▁ + ▁ \" , $ c1 , \" ▁ x ▁ + ▁ \" , $ d1 , \" ▁ y ▁ + ▁ \" , $ e1 , \" ▁ xy ▁ + ▁ \" , $ f1 , \" ▁ = ▁ 0\" ; } $ x1 = 1 ; $ y1 = 1 ; $ a = 1 ; $ b = -1 ; $ c = 3 ; $ e = 0.5 * 0.5 ; equation_ellipse ( $ x1 , $ y1 , $ a , $ b , $ c , $ e ) ; ? >"}
{"text": "Kawasan bulatan yang ditulis dalam segitiga sama rata | Fungsi mengembalikan kawasan bulatan yang ditulis dalam segitiga sama rata; Kod pemacu", "code": "< ? php function circle_inscribed ( $ a ) { return 3.14 * ( $ a * $ a ) / 12 ; } $ a = 4 ; echo circle_inscribed ( $ a ) ;"}
{"text": "Program untuk mencari jumlah tetrahedron yang tidak teratur | Berfungsi untuk mencari kelantangan; Langkah -langkah untuk mengira jumlah tetrahedron menggunakan formula; panjang tepi", "code": "< ? php function findVolume ( $ u , $ v , $ w , $ U , $ V , $ W , $ b ) { $ uPow = pow ( $ u , 2 ) ; $ vPow = pow ( $ v , 2 ) ; $ wPow = pow ( $ w , 2 ) ; $ UPow = pow ( $ U , 2 ) ; $ VPow = pow ( $ V , 2 ) ; $ WPow = pow ( $ W , 2 ) ; $ a = 4 * ( $ uPow * $ vPow * $ wPow ) - $ uPow * pow ( ( $ vPow + $ wPow - $ UPow ) , 2 ) - $ vPow * pow ( ( $ wPow + $ uPow - $ VPow ) , 2 ) - $ wPow * pow ( ( $ uPow + $ vPow - $ WPow ) , 2 ) + ( $ vPow + $ wPow - $ UPow ) * ( $ wPow + $ uPow - $ VPow ) * ( $ uPow + $ vPow - $ WPow ) ; $ vol = sqrt ( $ a ) ; $ vol /= $ b ; echo $ vol ; } $ u = 1000 ; $ v = 1000 ; $ w = 1000 ; $ U = 3 ; $ V = 4 ; $ W = 5 ; $ b = 12 ; findVolume ( $ u , $ v , $ w , $ U , $ V , $ W , $ b ) ; ? >"}
{"text": "Semak sama ada mungkin untuk membuat poligon dengan sudut yang diberikan | Fungsi untuk memeriksa sama ada mungkin untuk membuat poligon biasa dengan sudut yang diberikan. ; N menandakan bilangan sisi poligon yang mungkin; Kod pemacu; berfungsi untuk mencetak jawapan yang diperlukan", "code": "< ? php function makePolygon ( $ a ) { $ n = 360 / ( 180 - $ a ) ; if ( $ n == ( int ) $ n ) echo \" YES \" ; else echo \" NO \" ; } $ a = 90 ; makePolygon ( $ a ) ; ? >"}
{"text": "Mencari kuadran koordinat berkenaan dengan bulatan | Oleh itu, fungsi mengembalikan nombor kuadran; Bertepatan dengan pusat; Di luar bulatan; 1 St Quadrant; 2 Nd Quadrant; 3 Rd Quadrant; Kuadran ke -4; Koordinat pusat; Jejari bulatan; Koordinat PO $ yang diberikan", "code": "< ? php function getQuadrant ( $ X , $ Y , $ R , $ PX , $ PY ) { if ( $ PX == $ X and $ PY == $ Y ) return 0 ; $ val = pow ( ( $ PX - $ X ) , 2 ) + pow ( ( $ PY - $ Y ) , 2 ) ; if ( $ val > pow ( $ R , 2 ) ) return -1 ; if ( $ PX > $ X and $ PY >= $ Y ) return 1 ; if ( $ PX <= $ X and $ PY > $ Y ) return 2 ; if ( $ PX < $ X and $ PY <= $ Y ) return 3 ; if ( $ PX >= $ X and $ PY < $ Y ) return 4 ; } $ X = 0 ; $ Y = 3 ; $ R = 2 ; $ PX = 1 ; $ PY = 4 ; $ ans = getQuadrant ( $ X , $ Y , $ R , $ PX , $ PY ) ; if ( $ ans == -1 ) echo \" Lies ▁ Outside ▁ the ▁ circle \" ; else if ( $ ans == 0 ) echo \" Coincides ▁ with ▁ centre \" ; else echo $ ans , \" ▁ Quadrant \" ; ? >"}
{"text": "Nombor Hexadecagonal | Berfungsi untuk mengira nombor heksadekagonal; Kod pemacu", "code": "< ? php function hexadecagonalNum ( $ n ) { return ( ( 14 * $ n * $ n ) - 12 * $ n ) / 2 ; } $ n = 5 ; echo $ n , \" th ▁ Hexadecagonal ▁ number ▁ : ▁ \" ; echo hexadecagonalNum ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 9 ; echo $ n , \" th ▁ Hexadecagonal ▁ number ▁ : ▁ \" ; echo hexadecagonalNum ( $ n ) ;"}
{"text": "Cari perimeter silinder | Berfungsi untuk mengira perimeter; Kod pemacu", "code": "< ? php function perimeter ( $ diameter , $ height ) { return 2 * ( $ diameter + $ height ) ; } $ diameter = 5 ; $ height = 10 ; echo ( \" Perimeter ▁ = ▁ \" ) ; echo ( perimeter ( $ diameter , $ height ) ) ; echo ( \" ▁ units \" ) ; ? >"}
{"text": "Cari semua kemungkinan koordinat paralelogram | koordinat a; koordinat B; Koordinat c", "code": "< ? php $ ax = 5 ; $ ay = 0 ; $ bx = 1 ; $ by = 1 ; $ cx = 2 ; $ cy = 5 ; echo $ ax + $ bx - $ cx , \" , ▁ \" , $ ay + $ by - $ cy , \" STRNEWLINE \" ; echo $ ax + $ cx - $ bx , \" , ▁ \" , $ ay + $ cy - $ by , \" STRNEWLINE \" ; echo $ cx + $ bx - $ ax , \" , ▁ \" , $ cy + $ by - $ ax ; ? >"}
{"text": "Semak sama ada titik tertentu terletak di dalam segi empat tepat atau tidak | Fungsi utiliti untuk mengira kawasan segitiga yang dibentuk oleh (x1, y1), (x2, y2) dan (x3, y3); Fungsi untuk memeriksa sama ada titik p (x, y) terletak di dalam segi empat tepat yang dibentuk oleh A (X1, Y1), B (X2, Y2), C (X3, Y3) dan D (X4, Y4); Hitung kawasan Rectangle ABCD; Hitung kawasan Segitiga Pab; Hitung kawasan segitiga PBC; Hitung kawasan segitiga PCD; Hitung kawasan pad segi tiga; Semak sama ada jumlah A1, A2, A3 dan A4 adalah sama dengan A; Marilah kita periksa sama ada titik p (10, 15) terletak di dalam segi empat tepat yang dibentuk oleh A (0, 10), B (10, 0) C (0, - 10) D ( - 10, 0)", "code": "< ? php function area ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) { return abs ( ( $ x1 * ( $ y2 - $ y3 ) + $ x2 * ( $ y3 - $ y1 ) + $ x3 * ( $ y1 - $ y2 ) ) / 2.0 ) ; } function check ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 , $ x , $ y ) { $ A = area ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) + area ( $ x1 , $ y1 , $ x4 , $ y4 , $ x3 , $ y3 ) ; $ A1 = area ( $ x , $ y , $ x1 , $ y1 , $ x2 , $ y2 ) ; $ A2 = area ( $ x , $ y , $ x2 , $ y2 , $ x3 , $ y3 ) ; $ A3 = area ( $ x , $ y , $ x3 , $ y3 , $ x4 , $ y4 ) ; $ A4 = area ( $ x , $ y , $ x1 , $ y1 , $ x4 , $ y4 ) ; return ( $ A == $ A1 + $ A2 + $ A3 + $ A4 ) ; } if ( check ( 0 , 10 , 10 , 0 , 0 , -10 , -10 , 0 , 10 , 15 ) ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text": "Masalah Pizza Cut (atau Bahagian Lingkaran mengikut baris) | Fungsi untuk mencari kepingan maksimum dengan pemotongan N. ; Kod pemacu", "code": "< ? php function findMaximumPieces ( $ n ) { return 1 + $ n * ( $ n + 1 ) / 2 ; } echo findMaximumPieces ( 3 ) ; ? >"}
{"text": "Penyelesaian DP yang dioptimumkan ruang untuk 0 | Val [] adalah untuk menyimpan keuntungan maksimum bagi setiap berat wt [] adalah untuk menyimpan berat n bilangan item w kapasiti maksimum beg tikar [2] [w + 1] untuk menyimpan hasil akhir; matriks untuk menyimpan hasil akhir; melangkah melalui semua item; Satu demi satu melintasi setiap elemen; melintasi semua berat j <= w; Jika saya ganjil yang bermaksud sehingga sekarang kita mempunyai bilangan elemen yang ganjil sehingga kami menyimpan hasil dalam baris yang diindeks ke -1; periksa setiap nilai; termasuk elemen; tidak termasuk elemen; Sekiranya saya juga bermaksud sehingga kini kita mempunyai bilangan elemen sehingga kami menyimpan hasil dalam baris diindeks ke -0; Kembali tikar [0] [w] jika n adalah ganjil, lain tikar [1] [w]; Kod pemacu", "code": "< ? php function KnapSack ( & $ val , & $ wt , $ n , $ W ) { $ mat = array_fill ( 0 , 2 , array_fill ( 0 , $ W + 1 , NULL ) ) ; $ i = 0 ; while ( $ i < $ n ) { $ j = 0 ; if ( $ i % 2 != 0 ) { { while ( ++ $ j <= $ W ) if ( $ wt [ $ i ] <= $ j ) $ mat [ 1 ] [ $ j ] = max ( $ val [ $ i ] + $ mat [ 0 ] [ $ j - $ wt [ $ i ] ] , $ mat [ 0 ] [ $ j ] ) ; else $ mat [ 1 ] [ $ j ] = $ mat [ 0 ] [ $ j ] ; } } else { while ( ++ $ j <= $ W ) { if ( $ wt [ $ i ] <= $ j ) $ mat [ 0 ] [ $ j ] = max ( $ val [ $ i ] + $ mat [ 1 ] [ $ j - $ wt [ $ i ] ] , $ mat [ 1 ] [ $ j ] ) ; else $ mat [ 0 ] [ $ j ] = $ mat [ 1 ] [ $ j ] ; } } $ i ++ ; } if ( $ n % 2 != 0 ) return $ mat [ 0 ] [ $ W ] ; else return $ mat [ 1 ] [ $ W ] ; } $ val = array ( 7 , 8 , 4 ) ; $ wt = array ( 3 , 8 , 6 ) ; $ W = 10 ; $ n = 3 ; echo KnapSack ( $ val , $ wt , $ n , $ W ) . \" STRNEWLINE \" ; ? >"}
{"text": "Cari Nombor Asal dari GCD () Setiap Pasangan | Pelaksanaan PHP pendekatan; Fungsi utiliti untuk mencetak kandungan array; Berfungsi untuk mencari nombor yang diperlukan; Susun array dalam penurunan urutan; Kiraan kekerapan setiap elemen; Saiz array yang dihasilkan; Simpan elemen tertinggi dalam array yang dihasilkan; Menurunkan kekerapan elemen itu; Mengira GCD; Nilai GCD penurunan sebanyak 2; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { return ( $ a % $ b ) ? gcd ( $ b , $ a % $ b ) : $ b ; } function printArr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; } function findNumbers ( $ arr , $ n ) { rsort ( $ arr ) ; $ freq = array_fill ( 0 , $ arr [ 0 ] + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ freq [ $ arr [ $ i ] ] ++ ; $ size = floor ( sqrt ( $ n ) ) ; $ brr = array_fill ( 0 , $ size , 0 ) ; $ l = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ freq [ $ arr [ $ i ] ] > 0 ) { $ brr [ $ l ] = $ arr [ $ i ] ; $ freq [ $ brr [ $ l ] ] -- ; $ l ++ ; for ( $ j = 0 ; $ j < $ l ; $ j ++ ) { if ( $ i != $ j ) { $ x = gcd ( $ arr [ $ i ] , $ brr [ $ j ] ) ; $ freq [ $ x ] -= 2 ; } } } } printArr ( $ brr , $ size ) ; } $ arr = array ( 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5 , 5 , 5 , 7 , 10 , 12 , 2 , 2 ) ; $ n = count ( $ arr ) ; findNumbers ( $ arr , $ n ) ; ? >"}
{"text": "Susun semula ganjil dan juga nilai -nilai dalam fesyen alternatif dalam urutan menaik | Pelaksanaan PHP pendekatan di atas; Susun array; $ v1 = array (); untuk memasukkan walaupun nilai $ v2 = array (); untuk memasukkan nilai ganjil; Tetapkan bendera ke benar jika elemen pertama adalah walaupun; Mula menyusun semula array; Jika elemen pertama adalah walaupun; Lain -lain, elemen pertama adalah ganjil; Cetak array yang disusun semula; Kod pemacu", "code": "< ? php function AlternateRearrange ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 == 0 ) array_push ( $ v1 , $ arr [ $ i ] ) ; else array_push ( $ v2 , $ arr [ $ i ] ) ; $ index = 0 ; $ i = 0 ; $ j = 0 ; $ flag = false ; if ( $ arr [ 0 ] % 2 == 0 ) $ flag = true ; while ( $ index < $ n ) { if ( $ flag == true ) { $ arr [ $ index ++ ] = $ v1 [ $ i ++ ] ; $ flag = ! $ flag ; } else { $ arr [ $ index ++ ] = $ v2 [ $ j ++ ] ; $ flag = ! $ flag ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; } $ arr = array ( 9 , 8 , 13 , 2 , 19 , 14 ) ; $ n = sizeof ( $ arr ) ; AlternateRearrange ( $ arr , $ n ) ; ? >"}
{"text": "Menukar Arahan yang diberikan kepada perkembangan aritmetik dengan menambahkan elemen | Berfungsi untuk mengembalikan nombor yang akan ditambah; Jika perbezaan unsur -unsur berturut -turut semasa adalah berbeza daripada perbezaan biasa; Sekiranya nombor telah dipilih maka tidak mungkin untuk menambah nombor lain; Jika berbeza semasa adalah dua kali perbezaan biasa maka nombor boleh ditambah di pertengahan dari elemen semasa dan sebelumnya; Nombor telah dipilih; Ia tidak mungkin untuk mengekalkan perbezaan yang sama; Kembali elemen terakhir + perbezaan biasa jika tiada elemen dipilih dan array sudah ada di AP; Lain mengembalikan nombor yang dipilih; Kod pemacu", "code": "< ? php function getNumToAdd ( $ arr , $ n ) { sort ( $ arr ) ; $ d = $ arr [ 1 ] - $ arr [ 0 ] ; $ numToAdd = -1 ; $ numAdded = false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ diff = $ arr [ $ i ] - $ arr [ $ i - 1 ] ; if ( $ diff != $ d ) { if ( $ numAdded ) return -1 ; if ( $ diff == 2 * $ d ) { $ numToAdd = $ arr [ $ i ] - $ d ; $ numAdded = true ; } else return -1 ; } } if ( $ numToAdd == -1 ) return ( $ arr [ $ n - 1 ] + $ d ) ; return $ numToAdd ; } $ arr = array ( 1 , 3 , 5 , 7 , 11 , 13 , 15 ) ; $ n = sizeof ( $ arr ) ; echo getNumToAdd ( $ arr , $ n ) ; ? >"}
{"text": "Dapatkan item maksimum apabila item lain dari jumlah kos item adalah percuma | Berfungsi untuk mengira jumlah item; Menyusun harga; Pilih elemen terakhir; Kiraan awal item; Jumlah untuk menjejaki jumlah harga item percuma; Jika jumlahnya kurang daripada atau sama dengan z maka kita akan menambah 1 kepada jawapannya; Kod pemacu", "code": "< ? php function items ( $ n , $ a ) { sort ( $ a ) ; $ z = $ a [ $ n - 1 ] ; $ x = 1 ; $ s = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ s += $ a [ $ i ] ; if ( $ s <= $ z ) $ x += 1 ; else break ; } return $ x ; } $ n = 5 ; $ a = array ( 5 , 3 , 1 , 5 , 6 ) ; echo items ( $ n , $ a ) ; ? >"}
{"text": "Kotak minimum diperlukan untuk membawa semua hadiah | Berfungsi untuk mengembalikan bilangan kotak; Menyusun kotak dalam urutan menaik; Cuba muat kotak terkecil dengan kotak paling berat semasa (dari sebelah kanan); Program Pemandu", "code": "< ? php function numBoxes ( $ A , $ n , $ K ) { sort ( $ A ) ; $ i = 0 ; $ j = $ n - 1 ; $ ans = 0 ; while ( $ i <= $ j ) { $ ans ++ ; if ( $ A [ $ i ] + $ A [ $ j ] <= $ K ) $ i ++ ; $ j -- ; } return $ ans ; } $ A = array ( 3 , 2 , 2 , 1 ) ; $ K = 3 ; $ n = sizeof ( $ A ) / sizeof ( $ A [ 0 ] ) ; echo numBoxes ( $ A , $ n , $ K ) ; ? >"}
{"text": "Memaksimumkan keuntungan dengan menjual di | Berfungsi untuk mencari keuntungan; Mengira keuntungan untuk setiap alat; Susun pelbagai keuntungan dalam urutan menurun; pembolehubah untuk mengira jumlah keuntungan; Semak keuntungan terbaik; Kod pemacu", "code": "< ? php function solve ( $ N , $ M , & $ cp , & $ sp ) { $ profit = array_fill ( 0 , $ N , NULL ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ profit [ $ i ] = $ sp [ $ i ] - $ cp [ $ i ] ; rsort ( $ profit ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { if ( $ profit [ $ i ] > 0 ) $ sum += $ profit [ $ i ] ; else break ; } return $ sum ; } $ N = 5 ; $ M = 3 ; $ CP = array ( 5 , 10 , 35 , 7 , 23 ) ; $ SP = array ( 11 , 10 , 0 , 9 , 19 ) ; echo solve ( $ N , $ M , $ CP , $ SP ) ; ? >"}
{"text": "Cari nombor terbesar yang boleh dibentuk dengan digit yang diberikan | Berfungsi untuk menjana nombor terbesar yang mungkin dengan digit yang diberikan; Susun array yang diberikan dalam urutan menurun; menjana nombor; Kod pemacu", "code": "< ? php function findMaxNum ( & $ arr , $ n ) { rsort ( $ arr ) ; $ num = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ num = $ num * 10 + $ arr [ $ i ] ; } return $ num ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 0 ) ; $ n = sizeof ( $ arr ) ; echo findMaxNum ( $ arr , $ n ) ; ? >"}
{"text": "Partition minimum saiz maksimum 2 dan jumlah terhad oleh nilai yang diberikan | Program PHP untuk mengira bilangan minimum partition saiz 2 dan jumlah yang lebih kecil daripada atau sama dengan kunci yang diberikan. ; Susun array; Jika jumlah ith yang lebih kecil dan elemen yang lebih besar adalah kurang daripada kunci, kemudian pek kedua -dua nombor dalam set sebaliknya bungkus nombor yang lebih besar sahaja dalam set; Selepas berakhir gelung saya akan mengandungi bilangan set minimum; Kod pemacu", "code": "< ? php function minimumSets ( $ arr , $ n , $ key ) { $ i ; $ j ; sort ( $ arr ) ; for ( $ i = 0 , $ j = $ n - 1 ; $ i <= $ j ; ++ $ i ) if ( $ arr [ $ i ] + $ arr [ $ j ] <= $ key ) $ j -- ; return $ i ; } $ arr = array ( 3 , 5 , 3 , 4 ) ; $ n = count ( $ arr ) ; $ key = 5 ; echo minimumSets ( $ arr , $ n , $ key ) ; ? >"}
{"text": "Bilangan kotak yang kelihatan selepas meletakkan satu di dalam yang lain | mengembalikan bilangan minimum kotak yang kelihatan; Barisan bilangan bulat baru. ; menyusun array; melintasi array; Memeriksa jika elemen semasa lebih besar daripada atau sama dengan dua kali elemen depan; Menolak setiap elemen array; Kod pemacu", "code": "< ? php function minimumBox ( $ arr , $ n ) { $ q = array ( ) ; sort ( $ arr ) ; array_push ( $ q , $ arr [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ now = $ q [ 0 ] ; if ( $ arr [ $ i ] >= 2 * $ now ) array_pop ( $ q ) ; array_push ( $ q , $ arr [ $ i ] ) ; } return count ( $ q ) ; } $ arr = array ( 4 , 1 , 2 , 8 ) ; $ n = count ( $ arr ) ; echo minimumBox ( $ arr , $ n ) ; ? >"}
{"text": "Sort Array Perduaan Menggunakan Satu Traversal | Kod PHP untuk menyusun array binari menggunakan satu traversal; Jika nombor lebih kecil daripada 1 maka swapnya dengan nombor J - th; Kod pemacu", "code": "< ? php function sortBinaryArray ( $ a , $ n ) { $ j = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] < 1 ) { $ j ++ ; $ temp = $ a [ $ j ] ; $ a [ $ j ] = $ a [ $ i ] ; $ a [ $ i ] = $ temp ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ a [ $ i ] . \" ▁ \" ; } $ a = array ( 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 ) ; $ n = count ( $ a ) ; sortBinaryArray ( $ a , $ n ) ; ? >"}
{"text": "Elemen terkecil dalam array yang diulangi tepat kali 'k'. | mencari bilangan terkecil di arr [] yang diulang kali K; Sejak ARR [] mempunyai nombor dalam jarak dari 1 hingga max; Tetapkan kiraan hingga 1 sebagai nombor sekali; Jika kekerapan nombor adalah sama dengan 'k'; Kod pemacu", "code": "< ? php function findDuplicate ( $ arr , $ n , $ k ) { $ MAX = 1000 ; $ res = $ MAX + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > 0 ) { $ count = 1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ count += 1 ; if ( $ count == $ k ) $ res = min ( $ res , $ arr [ $ i ] ) ; } } return $ res ; } $ arr = array ( 2 , 2 , 1 , 3 , 1 ) ; $ k = 2 ; $ n = count ( $ arr ) ; echo findDuplicate ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Elemen terkecil dalam array yang diulangi tepat kali 'k'. | mencari bilangan terkecil di arr [] yang diulang kali K; Susun array; Cari elemen pertama dengan kejadian yang betul. ; Kod pemacu", "code": "< ? php function findDuplicate ( $ arr , $ n , $ k ) { sort ( $ arr ) ; $ i = 0 ; while ( $ i < $ n ) { $ j ; $ count = 1 ; for ( $ j = $ i + 1 ; $ j < $ n && $ arr [ $ j ] == $ arr [ $ i ] ; $ j ++ ) $ count ++ ; if ( $ count == $ k ) return $ arr [ $ i ] ; $ i = $ j ; } return -1 ; } $ arr = array ( 2 , 2 , 1 , 3 , 1 ) ; $ k = 2 ; $ n = sizeof ( $ arr ) ; echo ( findDuplicate ( $ arr , $ n , $ k ) ) ; ? >"}
{"text": "Semak sama ada mungkin untuk menyusun array dengan bertukar bersyarat bersebelahan yang dibenarkan | Pulangan benar jika mungkin untuk menyusun yang lain palsu; Kita perlu melakukan sesuatu hanya jika elemen sebelumnya lebih besar; Jika perbezaan lebih daripada satu, maka tidak mungkin; Kod pemacu", "code": "< ? php function checkForSorting ( $ arr , $ n ) { $ temp = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) { if ( $ arr [ $ i ] - $ arr [ $ i + 1 ] == 1 ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ i + 1 ] ; $ arr [ $ i + 1 ] = $ temp ; } else return false ; } } return true ; } $ arr = array ( 1 , 0 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; if ( checkForSorting ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "K | Kembalikan elemen terkecil. ; sort (arr, ar + n); ; Memeriksa jika K terletak sebelum elemen 1; Jika k adalah elemen pertama array arr []. ; Jika k lebih daripada elemen terakhir; Jika elemen pertama array adalah 1; Mengurangkan k oleh nombor sebelum ARR [0]. ; Menemukan elemen terkecil selepas mengeluarkan unsur -unsur array. ; Mencari kiraan elemen antara elemen i - th dan (i - 1) - ke. ; Kod pemacu", "code": "< ? php function ksmallest ( $ arr , $ n , $ k ) { sort ( $ arr ) ; if ( $ k < $ arr [ 0 ] ) return $ k ; if ( $ k == $ arr [ 0 ] ) return $ arr [ 0 ] + 1 ; if ( $ k > $ arr [ $ n - 1 ] ) return $ k + $ n ; if ( $ arr [ 0 ] == 1 ) $ k -- ; else $ k -= ( $ arr [ 0 ] - 1 ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ c = $ arr [ $ i ] - $ arr [ $ i - 1 ] - 1 ; if ( $ k <= $ c ) return $ arr [ $ i - 1 ] + $ k ; else $ k -= $ c ; } return $ arr [ $ n - 1 ] + $ k ; } $ k = 1 ; $ arr = array ( 1 ) ; $ n = sizeof ( $ arr ) ; echo ksmallest ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Semak sama ada nombor tertentu adalah atau ganjil | Pulangan benar jika n adalah walaupun, lain -lain ganjil; N & 1 adalah 1, kemudian ganjil, lain -lain pun; Kod pemacu", "code": "< ? php function isEven ( $ n ) { return ( ! ( n & 1 ) ) ; } $ n = 101 ; if ( isEven ( $ n ) == true ) echo \" Even \" ; else echo \" Odd \" ; ? >"}
{"text": "Mengira kejadian yang berbeza sebagai berikutnya | Program PHP untuk mengira bilangan kali S muncul sebagai seterusnya dalam T; T boleh muncul sebagai seterusnya dalam s; Mat [i] [j] menyimpan kiraan kejadian t (1 ... i) dalam s (1 ... j). ; Memulakan lajur pertama dengan semua 0 s. Rentetan kosong tidak boleh mempunyai rentetan lain sebagai suhsequence; Memulakan baris pertama dengan semua 1 s. Rentetan kosong adalah seterusnya. ; Isi tikar [] [] dengan cara bawah; Jika watak terakhir tidak sepadan, maka nilai adalah sama dengan nilai tanpa watak terakhir dalam S .; Nilai lain diperoleh memandangkan dua kes. a) Semua substrings tanpa watak terakhir dalam s b) semua substrings tanpa watak terakhir dalam kedua -duanya. ; Uncomment ini untuk mencetak matriks matriks untuk (int i = 1; i <= m; i ++, cout << endl) untuk (int j = 1; j <= n; j ++) cout << mat [i] [j] << \"\"; ; Kod pemacu", "code": "< ? php function findSubsequenceCount ( $ S , $ T ) { $ m = strlen ( $ T ) ; $ n = strlen ( $ S ) ; if ( $ m > $ n ) return 0 ; $ mat = array ( array ( ) ) ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) $ mat [ $ i ] [ 0 ] = 0 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ mat [ 0 ] [ $ j ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ T [ $ i - 1 ] != $ S [ $ j - 1 ] ) $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j - 1 ] ; else $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j - 1 ] + $ mat [ $ i - 1 ] [ $ j - 1 ] ; } } return $ mat [ $ m ] [ $ n ] ; } $ T = \" ge \" ; $ S = \" geeksforgeeks \" ; echo findSubsequenceCount ( $ S , $ T ) . \" \" ;"}
{"text": "Semak sama ada mungkin untuk membuat dua matriks dengan ketat meningkat dengan menukar nilai yang sepadan sahaja | Fungsi untuk memeriksa sama ada matriks boleh dibuat dengan ketat dengan operasi yang diberikan; Swap hanya apabila [i] [j]> b [i] [j]; Semak jika baris semakin meningkat; Semak sama ada lajur semakin meningkat; Kod pemacu", "code": "< ? php function Check ( $ a , $ b , $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] > $ b [ $ i ] [ $ j ] ) { $ temp = $ a [ $ i ] [ $ j ] ; $ a [ $ i ] [ $ j ] = $ b [ $ i ] [ $ j ] ; $ b [ $ i ] [ $ j ] = $ temp ; } } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m - 1 ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] >= $ a [ $ i ] [ $ j + 1 ] or $ b [ $ i ] [ $ j ] >= $ b [ $ i ] [ $ j + 1 ] ) return \" No \" ; } } for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] >= $ a [ $ i + 1 ] [ $ j ] or $ b [ $ i ] [ $ j ] >= $ b [ $ i + 1 ] [ $ j ] ) return \" No \" ; } } return \" Yes \" ; } $ n = 2 ; $ m = 2 ; $ a = array ( array ( 2 , 10 ) , array ( 11 , 5 ) ) ; $ b = array ( array ( 9 , 4 ) , array ( 3 , 12 ) ) ; print ( Check ( $ a , $ b , $ n , $ m ) ) ; ? >"}
{"text": "Cari rentetan terkecil lexicographically yang memenuhi syarat yang diberikan | Berfungsi untuk mengembalikan rentetan yang diperlukan; Watak pertama akan sentiasa 'a'; Untuk menyimpan rentetan yang dihasilkan; Oleh kerana panjang rentetan harus lebih besar daripada 0 dan elemen pertama array harus 1; Semak satu demi satu semua elemen array awalan yang diberikan; Jika perbezaan antara mana -mana dua elemen berturut -turut array awalan adalah lebih besar daripada 1 maka tidak akan ada rentetan sedemikian yang mungkin yang memenuhi array yang diberikan juga, rentetan tidak boleh mempunyai lebih daripada 26 aksara yang berbeza; Jika perbezaan adalah 0 maka watak (i ​​+ 1) akan sama dengan watak ith; Jika perbezaan adalah 1 maka watak (i ​​+ 1) akan berbeza dari watak ith; Kembali rentetan yang dihasilkan; Kod pemacu", "code": "< ? php function smallestString ( $ N , $ A ) { $ ch = ' a ' ; $ S = \" \" ; if ( $ N < 1 $ A [ 0 ] != 1 ) { $ S = \" - 1\" ; return $ S ; } $ S . = $ ch ; $ ch ++ ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ diff = $ A [ $ i ] - $ A [ $ i - 1 ] ; if ( $ diff > 1 $ diff < 0 $ A [ $ i ] > 26 ) { $ S = \" - 1\" ; return $ S ; } else if ( $ diff == 0 ) $ S . = ' a ' ; else { $ S . = $ ch ; $ ch ++ ; } } return $ S ; } $ arr = array ( 1 , 1 , 2 , 3 , 3 ) ; $ n = sizeof ( $ arr ) ; echo ( smallestString ( $ n , $ arr ) ) ; ? >"}
{"text": "Count of Alphabets yang nilai ASCII boleh dibentuk dengan digit N | Fungsi yang pulih benar jika NUM boleh dibentuk dengan digit dalam angka [] array; Salinan array digit; Dapatkan digit terakhir; Jika pelbagai digit tidak mengandungi digit semasa; Satu kejadian digunakan; Keluarkan digit terakhir; Berfungsi untuk mengembalikan kiraan huruf yang diperlukan; Untuk menyimpan kejadian digit (0 - 9); Dapatkan digit terakhir; Mengemas kini kejadian digit; Keluarkan digit terakhir; Jika mana -mana watak huruf kecil boleh dipilih dari digit semasa; Jika mana -mana watak huruf besar boleh dipilih dari digit semasa; Mengembalikan kiraan huruf yang diperlukan; Kod pemacu", "code": "< ? php function canBePicked ( $ digits , $ num ) { $ copyDigits = array ( ) ; for ( $ i = 0 ; $ i < sizeof ( $ digits ) ; $ i ++ ) $ copyDigits [ $ i ] = $ digits [ $ i ] ; while ( $ num > 0 ) { $ digit = $ num % 10 ; if ( $ copyDigits [ $ digit ] == 0 ) return false ; else $ copyDigits [ $ digit ] -- ; $ num = floor ( $ num / 10 ) ; } return true ; } function countAlphabets ( $ n ) { $ count = 0 ; $ digits = array_fill ( 0 , 10 , 0 ) ; while ( $ n > 0 ) { $ digit = $ n % 10 ; $ digits [ $ digit ] ++ ; $ n = floor ( $ n / 10 ) ; } for ( $ i = ord ( ' a ' ) ; $ i <= ord ( ' z ' ) ; $ i ++ ) if ( canBePicked ( $ digits , $ i ) ) $ count ++ ; for ( $ i = ord ( ' A ' ) ; $ i <= ord ( ' Z ' ) ; $ i ++ ) if ( canBePicked ( $ digits , $ i ) ) $ count ++ ; return $ count ; } $ n = 1623455078 ; echo countAlphabets ( $ n ) ; ? >"}
{"text": "Cari dua nombor yang jumlahnya dan GCD diberikan | Berfungsi untuk mencari GCD dua nombor; Fungsi untuk mencari dua nombor yang jumlahnya dan GCD diberikan; SUM! = GCD memeriksa bahawa kedua -dua angka itu positif atau tidak; Kod pemacu", "code": "< ? php function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } function findTwoNumbers ( $ sum , $ gcd ) { if ( __gcd ( $ gcd , $ sum - $ gcd ) == $ gcd && $ sum != $ gcd ) echo \" a = \" ▁ , ▁ min ( $ gcd , ▁ $ sum ▁ - ▁ $ gcd ) , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" b = \" else echo ( -1 ) ; } $ sum = 8 ; $ gcd = 2 ; findTwoNumbers ( $ sum , $ gcd ) ; ? >"}
{"text": "Cari jarak maksimum antara mana -mana bandar dan stesen | Berfungsi untuk mengira jarak maksimum antara mana -mana bandar dan stesen terdekatnya; Memulakan senarai boolean; Berikan sejati kepada bandar yang mengandungi stesen; Kod pemacu", "code": "< ? php function findMaxDistance ( $ numOfCities , $ station , $ n ) { $ hasStation = array_fill ( 0 , $ numOfCities + 1 , false ) ; for ( $ city = 0 ; $ city < $ n ; $ city ++ ) { $ hasStation [ $ station [ $ city ] ] = true ; } $ dist = 0 ; $ maxDist = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ maxDist = min ( $ station [ $ i ] , $ maxDist ) ; } for ( $ city = 0 ; $ city < $ numOfCities ; $ city ++ ) { if ( $ hasStation [ $ city ] == true ) { $ maxDist = max ( ( int ) ( ( $ dist + 1 ) / 2 ) , $ maxDist ) ; $ dist = 0 ; } else $ dist += 1 ; } return max ( $ maxDist , $ dist ) ; } $ numOfCities = 6 ; $ station = array ( 3 , 1 ) ; $ n = count ( $ station ) ; echo \" Max ▁ Distance : ▁ \" . findMaxDistance ( $ numOfCities , $ station , $ n ) ; ? >"}
{"text": "Pecahkan nombor ke dalam bahagian N seperti perbezaan antara bahagian terkecil dan terbesar adalah minimum | Fungsi yang mencetak urutan yang diperlukan; Jika kita tidak dapat memecah nombor ke dalam bahagian yang tepat; Jika x % n == 0 maka perbezaan minimum adalah 0 dan semua nombor adalah x / n; sehingga n - (x % n) nilai -nilai akan menjadi x / n selepas itu nilai -nilai akan menjadi x / n + 1; Kod pemacu", "code": "< ? php function split ( $ x , $ n ) { if ( $ x < $ n ) echo ( -1 ) ; else if ( $ x % $ n == 0 ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo ( $ x / $ n ) ; echo ( \" ▁ \" ) ; } } else { $ zp = $ n - ( $ x % $ n ) ; $ pp = $ x / $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i >= $ zp ) { echo ( int ) $ pp + 1 ; echo ( \" ▁ \" ) ; } else { echo ( int ) $ pp ; echo ( \" ▁ \" ) ; } } } } $ x = 5 ; $ n = 3 ; split ( $ x , $ n ) ; ? >"}
{"text": "Masa minimum untuk mencapai titik dengan + t dan | Mengembalikan masa minimum yang diperlukan untuk mencapai 'X'; Menyimpan masa minimum; kenaikan 't' oleh 1; mengemas kini jumlah; Kod pemacu", "code": "< ? php function cal_minimum_time ( $ X ) { $ t = 0 ; $ sum = 0 ; while ( $ sum < $ X ) { $ t ++ ; $ sum = $ sum + $ t ; } return $ t ; } $ n = 6 ; $ ans = cal_minimum_time ( $ n ) ; echo \" The ▁ minimum ▁ time ▁ required ▁ is ▁ : ▁ \" . $ ans ; ? >"}
{"text": "Jumlah perbezaan minimum antara elemen berturut -turut array | fungsi untuk mencari jumlah minimum perbezaan unsur berturut -turut; UL untuk menyimpan had atas untuk menyimpan had yang lebih rendah; menyimpan julat yang lebih rendah di LL dan julat atas di UL; memulakan jawapan dengan 0; melangkah untuk semua julat; Kes 1, dalam kes ini perbezaannya ialah 0; Tukar had atas dan had yang lebih rendah; Kes 2; Simpan perbezaan; Kes 3; Simpan perbezaan; pelbagai julat", "code": "< ? php function solve ( $ v , $ n ) { $ ans ; $ ul ; $ ll ; $ first = 0 ; $ second = 1 ; $ ll = $ v [ 0 ] [ $ first ] ; $ ul = $ v [ 0 ] [ $ second ] ; $ ans = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( ( $ v [ $ i ] [ $ first ] <= $ ul and $ v [ $ i ] [ $ first ] >= $ ll ) or ( $ v [ $ i ] [ $ second ] >= $ ll and $ v [ $ i ] [ $ second ] <= $ ul ) ) { if ( $ v [ $ i ] [ $ first ] > $ ll ) { $ ll = $ v [ $ i ] [ $ first ] ; } if ( $ v [ $ i ] [ $ second ] < $ ul ) { $ ul = $ v [ $ i ] [ $ second ] ; } } else if ( $ v [ $ i ] [ $ first ] > $ ul ) { $ ans += abs ( $ ul - $ v [ $ i ] [ $ first ] ) ; $ ul = $ v [ $ i ] [ $ first ] ; $ ll = $ v [ $ i ] [ $ first ] ; } else if ( $ v [ $ i ] [ $ second ] < $ ll ) { $ ans += abs ( $ ll - $ v [ $ i ] [ $ second ] ) ; $ ul = $ v [ $ i ] [ $ second ] ; $ ll = $ v [ $ i ] [ $ second ] ; } } return $ ans ; } $ v = array ( array ( 1 , 3 ) , array ( 2 , 5 ) , array ( 6 , 8 ) , array ( 1 , 2 ) , array ( 2 , 3 ) ) ; $ n = 5 ; echo ( solve ( $ v , $ n ) ) ; ? >"}
{"text": "Cari kiub terbesar yang dibentuk dengan memadam digit minimum dari nombor | Mengembalikan vektor kiub sempurna yang diproses pra; Tukar kiub ke rentetan dan tolak ke preprocessedCubes vector; Fungsi utiliti untuk findlargestcube (). Mengembalikan nombor kiub terbesar yang boleh dibentuk; membalikkan kiub pra -diproses supaya kita mempunyai kiub terbesar pada permulaan vektor; melangkah ke atas semua kiub; Semak sama ada digit semasa kiub sepadan dengan nombor nombor; Jika kawalan sampai di sini, yang tidak mungkin untuk membentuk kiub yang sempurna; pembalut untuk findlargestcubeutil (); Pra Proses Kiub sempurna; Tukar nombor n ke rentetan; Kod pemacu", "code": "< ? php function preProcess ( $ n ) { $ preProcessedCubes = array ( ) ; for ( $ i = 1 ; $ i * $ i * $ i < $ n ; $ i ++ ) { $ iThCube = $ i * $ i * $ i ; $ cubeString = strval ( $ iThCube ) ; array_push ( $ preProcessedCubes , $ cubeString ) ; } return $ preProcessedCubes ; } function findLargestCubeUtil ( $ num , $ preProcessedCubes ) { $ preProcessedCubes = array_reverse ( $ preProcessedCubes ) ; $ totalCubes = count ( $ preProcessedCubes ) ; for ( $ i = 0 ; $ i < $ totalCubes ; $ i ++ ) { $ currCube = $ preProcessedCubes [ $ i ] ; $ digitsInCube = strlen ( $ currCube ) ; $ index = 0 ; $ digitsInNumber = strlen ( $ num ) ; for ( $ j = 0 ; $ j < $ digitsInNumber ; $ j ++ ) { if ( $ num [ $ j ] == $ currCube [ $ index ] ) $ index += 1 ; if ( $ digitsInCube == $ index ) return $ currCube ; } } return \" Not ▁ Possible \" ; } function findLargestCube ( $ n ) { $ preProcessedCubes = preProcess ( $ n ) ; $ num = strval ( $ n ) ; $ ans = findLargestCubeUtil ( $ num , $ preProcessedCubes ) ; print ( \" Largest ▁ Cube ▁ that ▁ can ▁ be ▁ formed ▁ from ▁ \" . $ n . \" ▁ is ▁ \" . $ ans . \" STRNEWLINE \" ) ; } $ n = 4125 ; findLargestCube ( $ n ) ; $ n = 876 ; findLargestCube ( $ n ) ? >"}
{"text": "Cetak rentetan terdekat yang tidak mengandungi pendua bersebelahan | Berfungsi untuk mencetak rentetan mudah; Jika mana -mana dua watak bersebelahan adalah sama; Memulakannya ke 'a'; Melintasi gelung sehingga ia berbeza dari huruf kiri dan kanan. ; Kod pemacu", "code": "< ? php function noAdjacentDup ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { $ s [ $ i ] = ' a ' ; while ( $ s [ $ i ] == $ s [ $ i - 1 ] || ( $ i + 1 < $ n && $ s [ $ i ] == $ s [ $ i + 1 ] ) ) $ s [ $ i ] ++ ; $ i ++ ; } } return $ s ; } $ s = \" geeksforgeeks \" ; echo ( noAdjacentDup ( $ s ) ) ; ? >"}
{"text": "Elemen Array Dipindahkan oleh K Menggunakan Gerakan Single | Program PHP untuk mencari pemenang permainan; Jika bilangan langkah lebih banyak maka n - 1 ,; Pada mulanya yang terbaik adalah 0 dan tidak. kemenangan adalah 0.; melintasi semua nombor; Sekiranya nilai array lebih banyak daripada yang terbaik sebelumnya; Terbaik digantikan oleh [i]; jika bukan indeks pertama; Tiada kemenangan adalah 1 sekarang; jika ia menang; Sekiranya kedudukan mempunyai lebih banyak maka k menang maka kembali; Elemen maksimum akan menjadi pemenang kerana kita memindahkan elemen yang lebih kecil pada akhir dan mengulangi prosesnya. ; Kod pemacu", "code": "< ? php function winner ( $ a , $ n , $ k ) { if ( $ k >= $ n - 1 ) return $ n ; $ best = 0 ; $ times = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ best ) { $ best = $ a [ $ i ] ; if ( $ i ) $ times = 1 ; } else $ times += 1 ; if ( $ times >= $ k ) return $ best ; } return $ best ; } $ a = array ( 2 , 1 , 3 , 4 , 5 ) ; $ n = sizeof ( $ a ) ; $ k = 2 ; echo ( winner ( $ a , $ n , $ k ) ) ; ? >"}
{"text": "Pertanyaan untuk bitwise atau dalam julat indeks [l, r] array yang diberikan | Pelaksanaan PHP pendekatan; Array untuk menyimpan bit - kiraan awalan bijak; Fungsi untuk mencari jumlah awalan; Gelung untuk setiap bit; Gelung untuk mencari kiraan awalan; Berfungsi untuk menjawab pertanyaan; Untuk menyimpan jawapannya; Gelung untuk setiap bit; Untuk menyimpan bilangan pembolehubah dengan set bit ith; Keadaan untuk sedikit jawapan untuk ditetapkan; Kod pemacu", "code": "< ? php $ MAX = 100000 ; $ bitscount = 32 ; $ prefix_count = array_fill ( 0 , $ bitscount , array_fill ( 0 , $ MAX , NULL ) ) ; function findPrefixCount ( & $ arr , $ n ) { global $ MAX , $ bitscount , $ prefix_count ; for ( $ i = 0 ; $ i < $ bitscount ; $ i ++ ) { $ prefix_count [ $ i ] [ 0 ] = ( ( $ arr [ 0 ] >> $ i ) & 1 ) ; for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { $ prefix_count [ $ i ] [ $ j ] = ( ( $ arr [ $ j ] >> $ i ) & 1 ) ; $ prefix_count [ $ i ] [ $ j ] += $ prefix_count [ $ i ] [ $ j - 1 ] ; } } } function rangeOr ( $ l , $ r ) { global $ MAX , $ bitscount , $ prefix_count ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ bitscount ; $ i ++ ) { if ( $ l == 0 ) $ x = $ prefix_count [ $ i ] [ $ r ] ; else $ x = $ prefix_count [ $ i ] [ $ r ] - $ prefix_count [ $ i ] [ l - 1 ] ; if ( $ x != 0 ) $ ans = ( $ ans | ( 1 << $ i ) ) ; } return $ ans ; } $ arr = array ( 7 , 5 , 3 , 5 , 2 , 3 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; findPrefixCount ( $ arr , $ n ) ; $ queries = array ( array ( 1 , 3 ) , array ( 4 , 5 ) ) ; $ q = sizeof ( $ queries ) / sizeof ( $ queries [ 0 ] ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo rangeOr ( $ queries [ $ i ] [ 0 ] , $ queries [ $ i ] [ 1 ] ) . \" STRNEWLINE \" ; return 0 ; ? >"}
{"text": "Algoritma Bellman Ford (Pelaksanaan Mudah) | Fungsi utama yang menemui jarak terpendek dari SRC ke semua simpul lain menggunakan algoritma Bellman - Ford. Fungsi ini juga mengesan kitaran berat negatif graf baris [i] mewakili kelebihan saya dengan tiga nilai u, v dan w. ; Memulakan jarak dari semua simpang sebagai tak terhingga. ; memulakan jarak sumber sebagai 0; Bersantai semua tepi | V | - 1 kali. Laluan terpendek yang mudah dari SRC ke mana -mana puncak lain boleh mempunyai - paling banyak | V | - 1 tepi; Periksa kitaran berat negatif. Langkah di atas menjamin jarak terpendek jika graf tidak mengandungi kitaran berat negatif. Jika kita mendapat jalan yang lebih pendek, maka ada kitaran. ; Setiap kelebihan mempunyai tiga nilai (u, v, w) di mana tepi adalah dari puncak u ke v. Dan berat tepi adalah w.", "code": "< ? php function BellmanFord ( $ graph , $ V , $ E , $ src ) { $ dis = array ( ) ; for ( $ i = 0 ; $ i < $ V ; $ i ++ ) $ dis [ $ i ] = PHP_INT_MAX ; $ dis [ $ src ] = 0 ; for ( $ i = 0 ; $ i < $ V - 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ E ; $ j ++ ) { if ( $ dis [ $ graph [ $ j ] [ 0 ] ] != PHP_INT_MAX && $ dis [ $ graph [ $ j ] [ 0 ] ] + $ graph [ $ j ] [ 2 ] < $ dis [ $ graph [ $ j ] [ 1 ] ] ) $ dis [ $ graph [ $ j ] [ 1 ] ] = $ dis [ $ graph [ $ j ] [ 0 ] ] + $ graph [ $ j ] [ 2 ] ; } } for ( $ i = 0 ; $ i < $ E ; $ i ++ ) { $ x = $ graph [ $ i ] [ 0 ] ; $ y = $ graph [ $ i ] [ 1 ] ; $ weight = $ graph [ $ i ] [ 2 ] ; if ( $ dis [ $ x ] != PHP_INT_MAX && $ dis [ $ x ] + $ weight < $ dis [ $ y ] ) echo \" Graph ▁ contains ▁ negative ▁ weight ▁ cycle ▁ STRNEWLINE \" ; } echo \" Vertex ▁ Distance ▁ from ▁ Source ▁ STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ V ; $ i ++ ) echo $ i , \" TABSYMBOL TABSYMBOL \" , $ dis [ $ i ] , \" STRNEWLINE \" ; } $ graph = array ( array ( 0 , 1 , -1 ) , array ( 0 , 2 , 4 ) , array ( 1 , 2 , 3 ) , array ( 1 , 3 , 2 ) , array ( 1 , 4 , 2 ) , array ( 3 , 2 , 5 ) , array ( 3 , 1 , 1 ) , array ( 4 , 3 , -3 ) ) ; BellmanFord ( $ graph , $ V , $ E , 0 ) ; ? >"}
{"text": "Cari bilangan maksimum summands komposit nombor | Pelaksanaan PHP pendekatan di atas; Berfungsi untuk menghasilkan array DP; gabungan tiga bilangan bulat; Ambil jumlah maksimum summands; Berfungsi untuk mencari bilangan maksimum summands; Jika n adalah nombor yang lebih kecil, kurang daripada 16 pulangan dp [n]; Lain, cari nombor minimum T seperti yang dijelaskan dalam penyelesaian; Kod pemacu; Menjana array DP", "code": "< ? php $ maxn = 16 ; function precompute ( ) { $ dp = array_fill ( 0 , $ GLOBALS [ ' axn ' , -1 ) ; $ dp [ 0 ] = 0 ; $ v = array ( 4 , 6 , 9 ) ; for ( $ i = 1 ; $ i < $ GLOBALS [ ' axn ' ; ++ $ i ) { for ( $ k = 0 ; $ k < 3 ; $ k ++ ) { $ j = $ v [ $ k ] ; if ( $ i >= $ j && $ dp [ $ i - $ j ] != -1 ) { $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ i - $ j ] + 1 ) ; } } } return $ dp ; } function Maximum_Summands ( $ dp , $ n ) { if ( $ n < $ GLOBALS [ ' axn ' ) return $ dp [ $ n ] ; else { $ t = ( $ n - $ GLOBALS [ ' axn ' ) / 4 + 1 ; return $ t + $ dp [ $ n - 4 * $ t ] ; } } $ n = 12 ; $ dp = precompute ( ) ; echo Maximum_Summands ( $ dp , $ n ) ; ? >"}
{"text": "Cari sub | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan jumlah sub -matriks; Fungsi yang mengembalikan benar jika mungkin untuk mencari sub -matriks dengan jumlah yang diperlukan; 2 - D Array untuk menyimpan jumlah semua sub -matriks; Pengisian dp [] [] array; Memeriksa setiap sub - matriks saiz k x k; Sub - matriks dengan jumlah yang diberikan tidak dijumpai; Kod pemacu; Panggilan fungsi", "code": "< ? php $ GLOBALS [ ' N ' ] = 4 ; function getSum ( $ r1 , $ r2 , $ c1 , $ c2 , $ dp ) { return $ dp [ $ r2 ] [ $ c2 ] - $ dp [ $ r2 ] [ $ c1 ] - $ dp [ $ r1 ] [ $ c2 ] + $ dp [ $ r1 ] [ $ c1 ] ; } function sumFound ( $ K , $ S , $ grid ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) $ dp [ $ i + 1 ] [ $ j + 1 ] = $ dp [ $ i + 1 ] [ $ j ] + $ dp [ $ i ] [ $ j + 1 ] - $ dp [ $ i ] [ $ j ] + $ grid [ $ i ] [ $ j ] ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) { $ sum = getSum ( $ i , $ i + $ K , $ j , $ j + $ K , $ dp ) ; if ( $ sum == $ S ) return true ; } return false ; } $ grid = array ( array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) , array ( 9 , 10 , 11 , 12 ) , array ( 13 , 14 , 15 , 16 ) ) ; $ K = 2 ; $ S = 14 ; if ( sumFound ( $ K , $ S , $ grid ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Bilangan minimum operasi yang diperlukan untuk jumlah rentetan binari s | Berfungsi untuk mengembalikan operasi minimum yang diperlukan untuk jumlah kepada nombor yang ditambah oleh rentetan binari; Membalikkan rentetan untuk mempertimbangkannya dari LSB ke MSB; memulakan jadual DP; Jika S [0] = '0', tidak perlu melakukan apa -apa operasi; Jika s [0] = '1', hanya lakukan satu operasi (i. E tambah 2 ^ 0); Tanpa mengira LSB, DP [0] [1] selalu 1 kerana selalu ada keperluan untuk membuat akhiran rentetan binari bentuk \"11 ... 1\" seperti yang dicadangkan oleh definisi dp [i] [1]; Peralihan dari dp [i - 1] [0]; 1. Peralihan dari dp [i - 1] [1] dengan hanya melakukan 1 operasi tambahan untuk menolak 2 ^ i 2. Peralihan dari dp [i - 1] [1]; 1. Peralihan dari dp [i - 1] [1] dengan hanya melakukan 1 operasi tambahan menambah 2 ^ (i + 1) 2. Peralihan dari dp [i - 1] [0] dengan hanya melakukan 1 operasi tambahan untuk menambah 2 ^ i; Kod pemacu", "code": "< ? php function findMinOperations ( $ S ) { $ p = strrev ( $ S ) ; $ n = strlen ( $ p ) ; $ dp = array_fill ( 0 , $ n + 1 , array_fill ( 0 , 2 , NULL ) ) ; if ( $ p [ 0 ] == '0' ) { $ dp [ 0 ] [ 0 ] = 0 ; } else { $ dp [ 0 ] [ 0 ] = 1 ; } $ dp [ 0 ] [ 1 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ p [ $ i ] == '0' ) { $ dp [ $ i ] [ 0 ] = $ dp [ $ i - 1 ] [ 0 ] ; $ dp [ $ i ] [ 1 ] = 1 + min ( $ dp [ $ i - 1 ] [ 1 ] , $ dp [ $ i - 1 ] [ 0 ] ) ; } else { $ dp [ $ i ] [ 1 ] = $ dp [ $ i - 1 ] [ 1 ] ; $ dp [ $ i ] [ 0 ] = 1 + min ( $ dp [ $ i - 1 ] [ 0 ] , $ dp [ $ i - 1 ] [ 1 ] ) ; } } return $ dp [ $ n - 1 ] [ 0 ] ; } $ S = \"100\" ; echo findMinOperations ( $ S ) . \" STRNEWLINE \" ; $ S = \"111\" ; echo findMinOperations ( $ S ) . \" STRNEWLINE \" ; return 0 ; ? >"}
{"text": "K | Fungsi yang menemui elemen n siri K - Fibonacci; Jika n kurang daripada k maka elemen adalah '1'; Unsur K pertama ialah 1; (K + 1) elemen adalah k; Cari unsur -unsur siri K - Fibonacci; tolak elemen pada indeks i - k - 1 dan tambahkan elemen pada indeks i - i dari jumlah (jumlah mengandungi jumlah elemen 'k' sebelumnya); Tetapkan jumlah baru; Kod pemacu; Dapatkan nilai ke siri K - Fibonacci", "code": "< ? php function solve ( $ N , $ K ) { $ Array = array_fill ( 0 , $ N + 1 , NULL ) ; if ( $ N <= $ K ) { echo \"1\" . \" STRNEWLINE \" ; return ; } $ i = 0 ; $ sum = $ K ; for ( $ i = 1 ; $ i <= $ K ; ++ $ i ) { $ Array [ $ i ] = 1 ; } $ Array [ $ i ] = $ sum ; for ( $ i = $ K + 2 ; $ i <= $ N ; ++ $ i ) { $ Array [ $ i ] = $ sum - $ Array [ $ i - $ K - 1 ] + $ Array [ $ i - 1 ] ; $ sum = $ Array [ $ i ] ; } echo $ Array [ $ N ] . \" STRNEWLINE \" ; } $ N = 4 ; $ K = 2 ; solve ( $ N , $ K ) ; ? >"}
{"text": "Jumlah minimum kemungkinan mana -mana urutan kurungan panjang n | Program PHP untuk mencari jumlah minimum yang mungkin bagi mana -mana urutan kurungan panjang n menggunakan nilai yang diberikan untuk kurungan; Array dp; Fungsi rekursif untuk memeriksa ekspresi pendakap yang betul; / Bukan ungkapan pendakap yang betul; Jika sampai pada akhir; / Jika ekspresi kurungan yang betul; lain jika tidak, kembali max; Jika sudah dikunjungi; Untuk mengetahui jumlah minimum; Kod pemacu", "code": "< ? php $ MAX_VAL = 10000000 ; $ dp = array_fill ( 0 , 100 , array_fill ( 0 , 100 , -1 ) ) ; function find ( $ index , $ openbrk , $ n , $ adj ) { global $ MAX_VAL ; global $ dp ; if ( $ openbrk < 0 ) return $ MAX_VAL ; if ( $ index == $ n ) { if ( $ openbrk == 0 ) { return 0 ; } return $ MAX_VAL ; } if ( $ dp [ $ index ] [ $ openbrk ] != -1 ) return $ dp [ $ index ] [ $ openbrk ] ; $ dp [ $ index ] [ $ openbrk ] = min ( $ adj [ $ index ] [ 1 ] + find ( $ index + 1 , $ openbrk + 1 , $ n , $ adj ) , $ adj [ $ index ] [ 0 ] + find ( $ index + 1 , $ openbrk - 1 , $ n , $ adj ) ) ; return $ dp [ $ index ] [ $ openbrk ] ; } $ n = 4 ; $ adj = array ( array ( 5000 , 3000 ) , array ( 6000 , 2000 ) , array ( 8000 , 1000 ) , array ( 9000 , 6000 ) ) ; echo find ( 1 , 1 , $ n , $ adj ) + $ adj [ 0 ] [ 1 ] ; ? >"}
{"text": "Panjang maksimum segmen 0 's dan 1' s | Fungsi rekursif untuk mencari jumlah panjang array di mana 1 lebih besar daripada sifar; Jika sampai ke hujung; Jika $ dp disimpan; Mencari untuk setiap panjang; Jika watak yang diimbas adalah 1; Jika seseorang lebih besar daripada sifar, tambahkan jumlah panjang yang diimbas sehingga sekarang; Teruskan dengan panjang seterusnya; Kembalikan nilai untuk indeks permulaan $; Kod pemacu; Saiz rentetan; Memanggil fungsi untuk mencari nilai fungsi", "code": "< ? php function find ( $ start , $ adj , $ n , $ dp ) { if ( $ start == $ n ) return 0 ; if ( $ dp [ $ start ] != -1 ) return $ dp [ $ start ] ; $ dp [ $ start ] = 0 ; $ one = 0 ; $ zero = 0 ; for ( $ k = $ start ; $ k < $ n ; $ k ++ ) { if ( $ adj [ $ k ] == '1' ) $ one ++ ; else $ zero ++ ; if ( $ one > $ zero ) $ dp [ $ start ] = max ( $ dp [ $ start ] , find ( $ k + 1 , $ adj , $ n , $ dp ) + $ k - $ start + 1 ) ; else $ dp [ $ start ] = max ( $ dp [ $ start ] , find ( $ k + 1 , $ adj , $ n , $ dp ) ) ; } return $ dp [ $ start ] ; } $ adj = \"100110001010001\" ; $ n = strlen ( $ adj ) ; $ dp = array_fill ( 0 , $ n + 1 , -1 ) ; echo find ( 0 , $ adj , $ n , $ dp ) ; ? >"}
{"text": "Panjang selekoh biasa yang paling lama mengandungi vokal | fungsi untuk memeriksa sama ada 'ch' adalah vokal atau tidak; berfungsi untuk mencari panjang selaras biasa yang paling lama yang mengandungi semua aksara vokal; Langkah -langkah berikut membina l [m + 1] [n + 1] dalam fesyen bawah. Perhatikan bahawa l [i] [j] mengandungi panjang LCs x [0 .. i - 1] dan y [0. .. J - 1]; L [M] [n] mengandungi panjang LCS untuk x [0 .. n - 1] dan y [0 .. m - 1] yang mengandungi semua aksara vokal; Kod pemacu", "code": "< ? php function isVowel ( $ ch ) { if ( $ ch == ' a ' $ ch == ' e ' $ ch == ' i ' $ ch == ' o ' $ ch == ' u ' ) return true ; return false ; } function lcs ( $ X , $ Y , $ m , $ n ) { $ L = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , NULL ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ i ] [ $ j ] = 0 ; else if ( ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) && isVowel ( $ X [ $ i - 1 ] ) ) $ L [ $ i ] [ $ j ] = $ L [ $ i - 1 ] [ $ j - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] = max ( $ L [ $ i - 1 ] [ $ j ] , $ L [ $ i ] [ $ j - 1 ] ) ; } } return $ L [ $ m ] [ $ n ] ; } $ X = \" aieef \" ; $ Y = \" klaief \" ; $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; echo \" Length ▁ of ▁ LCS ▁ = ▁ \" . lcs ( $ X , $ Y , $ m , $ n ) ; ? >"}
{"text": "Bilangan minimum prima digit tunggal yang diperlukan yang jumlahnya sama dengan n | fungsi untuk memeriksa sama ada indeks saya adalah sah atau tidak; berfungsi untuk mencari bilangan minimum nombor utama digit yang diperlukan yang apabila disimpulkan sama dengan nombor n. ; Tidak mungkin; Kod pemacu", "code": "< ? php function check ( $ i , $ val ) { if ( $ i - $ val < 0 ) return false ; return true ; } function MinimumPrimes ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = 1e9 ; $ dp [ 0 ] = $ dp [ 2 ] = $ dp [ 3 ] = $ dp [ 5 ] = $ dp [ 7 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( check ( $ i , 2 ) ) $ dp [ $ i ] = min ( $ dp [ $ i ] , 1 + $ dp [ $ i - 2 ] ) ; if ( check ( $ i , 3 ) ) $ dp [ $ i ] = min ( $ dp [ $ i ] , 1 + $ dp [ $ i - 3 ] ) ; if ( check ( $ i , 5 ) ) $ dp [ $ i ] = min ( $ dp [ $ i ] , 1 + $ dp [ $ i - 5 ] ) ; if ( check ( $ i , 7 ) ) $ dp [ $ i ] = min ( $ dp [ $ i ] , 1 + $ dp [ $ i - 7 ] ) ; } if ( $ dp [ $ n ] == ( 1e9 ) ) return -1 ; else return $ dp [ $ n ] ; } $ n = 12 ; $ minimal = MinimumPrimes ( $ n ) ; if ( $ minimal != -1 ) { echo ( \" Minimum ▁ number ▁ of ▁ single ▁ \" . \" digit ▁ primes ▁ required ▁ : \" ) ; echo ( $ minimal ) ; } else { echo ( \" Not ▁ possible \" ) ; } ? >"}
{"text": "Bilangan BST yang unik dengan kunci yang diberikan | Pengaturcaraan Dinamik | Berfungsi untuk mencari bilangan BST yang unik; DP untuk menyimpan bilangan BST yang unik dengan Key I; Kes asas; Isi jadual DP di atas pendekatan bawah. ; n - i di sebelah kanan * i - 1 di sebelah kiri; Kod pemacu", "code": "< ? php function numberOfBST ( $ n ) { $ dp = array ( $ n + 1 ) ; for ( $ i = 0 ; $ i <= $ n + 1 ; $ i ++ ) $ dp [ $ i ] = 0 ; $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ dp [ $ i ] += ( ( $ dp [ $ i - $ j ] ) * ( $ dp [ $ j - 1 ] ) ) ; } } return $ dp [ $ n ] ; } $ n = 3 ; echo \" Number ▁ of ▁ structurally ▁ \" . \" Unique ▁ BST ▁ with ▁ \" , $ n , \" ▁ keys ▁ are ▁ : ▁ \" , numberOfBST ( $ n ) ; ? >"}
{"text": "Jumlah produk pekali binomial R dan Rth (R * NCR) | PEMULIHAN PEMBELAJARAN R * NCR; Kod pemacu", "code": "< ? php function summation ( $ n ) { return $ n << ( $ n - 1 ) ; } $ n = 2 ; echo summation ( $ n ) ; ? >"}
{"text": "Subarray Produk Maksimum | Menambah kes produk negatif | Berfungsi untuk mencari produk subarray maksimum. ; Oleh kerana produk maksimum boleh menjadi negatif, jadi inisialisasi ANS dengan nilai integer minimum. ; Pembolehubah untuk menyimpan produk maksimum sehingga nilai semasa. ; Pembolehubah untuk menyimpan produk minimum sehingga nilai semasa. ; Pembolehubah yang digunakan semasa pengemaskinian produk maksimum dan produk minimum. adalah prevmax; Jika elemen semasa positif, kemas kini maxval. Kemas kini Minval jika ia negatif. ; Jika elemen semasa adalah sifar, produk maksimum tidak boleh berakhir pada elemen semasa. Kemas kini minval dengan 1 dan maxval dengan 0. Maxval dikemas kini kepada 0 seperti dalam kes semua elemen lain adalah negatif, maka maxval adalah 0 .; Jika elemen semasa adalah negatif, maka nilai baru maxval adalah Minval * ARR [i] dan nilai baru minval adalah Maxval sebelumnya * arr [i]. Sebelum mengemas kini Maxval, simpan nilai sebelumnya di PrevMax untuk digunakan untuk mengemas kini Minval. ; Kemas kini Ans jika perlu. ; Jika maxval adalah sifar, maka untuk mengira produk untuk lelaran seterusnya, ia harus ditetapkan kepada 1 sebagai subarray produk maksimum tidak termasuk 0. Nilai minimum yang mungkin untuk dipertimbangkan dalam subarray produk maksimum telah disimpan di Minval, jadi apabila maxval negatif, ia ditetapkan kepada 1 .; Kod pemacu", "code": "< ? php function findMaxProduct ( & $ arr , $ n ) { $ ans = 0 ; $ maxval = 1 ; $ minval = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > 0 ) { $ maxval = $ maxval * $ arr [ i ] ; $ minval = min ( 1 , $ minval * $ arr [ $ i ] ) ; } else if ( $ arr [ $ i ] == 0 ) { $ minval = 1 ; $ maxval = 0 ; } else if ( $ arr [ $ i ] < 0 ) { $ prevMax = $ maxval ; $ maxval = $ minval * $ arr [ $ i ] ; $ minval = $ prevMax * $ arr [ $ i ] ; } $ ans = max ( $ ans , $ maxval ) ; if ( $ maxval <= 0 ) { $ maxval = 1 ; } } return $ ans ; } $ arr = array ( 0 , -4 , 0 , -2 ) ; $ n = sizeof ( $ arr ) ; echo findMaxProduct ( $ arr , $ n ) ; ? >"}
{"text": "Nilai maksimum dan minimum ungkapan algebra | Program PHP untuk mencari nilai maksimum dan minimum ungkapan algebra bentuk yang diberikan; Mencari jumlah elemen array; Pergeseran bilangan bulat sebanyak 50 supaya mereka menjadi positif; dp [i] [j] mewakili benar jika jumlah j boleh dicapai dengan memilih nombor i; Jika dp [i] [j] adalah benar, itu bermakna ia mungkin untuk memilih nombor saya dari (n + m) nombor untuk jumlah sehingga j; k boleh berada di max n kerana ungkapan kiri mempunyai nombor n; Memeriksa jika jumlah tertentu dapat dicapai dengan memilih nombor N; Mendapatkan jumlah sebenar ketika kami mengalihkan angka dengan 50 untuk mengelakkan pengindeksan negatif dalam pelbagai; Kod pemacu", "code": "< ? php function minMaxValues ( $ arr , $ n , $ m ) { $ sum = 0 ; $ INF = 1000000000 ; $ MAX = 50 ; for ( $ i = 0 ; $ i < ( $ n + $ m ) ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ arr [ $ i ] += 50 ; } $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ MAX + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ MAX * $ MAX + 1 ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; } $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i < ( $ n + $ m ) ; $ i ++ ) { for ( $ k = min ( $ n , $ i + 1 ) ; $ k >= 1 ; $ k -- ) { for ( $ j = 0 ; $ j < $ MAX * $ MAX + 1 ; $ j ++ ) { if ( $ dp [ $ k - 1 ] [ $ j ] ) $ dp [ $ k ] [ $ j + $ arr [ $ i ] ] = 1 ; } } } $ max_value = -1 * $ INF ; $ min_value = $ INF ; for ( $ i = 0 ; $ i < $ MAX * $ MAX + 1 ; $ i ++ ) { if ( $ dp [ $ n ] [ $ i ] ) { $ temp = $ i - 50 * $ n ; $ max_value = max ( $ max_value , $ temp * ( $ sum - $ temp ) ) ; $ min_value = min ( $ min_value , $ temp * ( $ sum - $ temp ) ) ; } } echo ( \" Maximum ▁ Value : ▁ \" . $ max_value . \" \" . ▁ \" Minimum Value : \" . ▁ $ min _ value . ▁ \" \" } $ n = 2 ; $ m = 2 ; $ arr = [ 1 , 2 , 3 , 4 ] ; minMaxValues ( $ arr , $ n , $ m ) ; ? >"}
{"text": "Urutan Golomb | Kembalikan elemen n urutan Golomb; Kes asas; Langkah rekursif; Cetak istilah N pertama urutan Golomb; Mencari terma pertama N Golomb urutan. ; Kod pemacu", "code": "< ? php function findGolomb ( $ n ) { if ( $ n == 1 ) return 1 ; return 1 + findGolomb ( $ n - findGolomb ( findGolomb ( $ n - 1 ) ) ) ; } function printGolomb ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo findGolomb ( $ i ) , \" ▁ \" ; } $ n = 9 ; printGolomb ( $ n ) ; ? >"}
{"text": "Percetakan Item dalam 0/1 Knapsack | Mencetak item yang disimpan dalam kapasiti kapasiti w; Membina jadual k [] [] dengan cara bawah; menyimpan hasil knapsack; Sama ada hasilnya datang dari bahagian atas (k [i - 1] [w]) atau dari (val [i - 1] + k [i - 1] [w - wt [i - 1]]) seperti dalam jadual knapsack. Jika ia datang dari yang terakhir / ia bermakna item itu dimasukkan. ; Item ini dimasukkan. ; Oleh kerana berat ini dimasukkan nilainya ditolak; Kod pemacu", "code": "< ? php function printknapSack ( $ W , & $ wt , & $ val , $ n ) { $ K = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ W + 1 , NULL ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ w = 0 ; $ w <= $ W ; $ w ++ ) { if ( $ i == 0 $ w == 0 ) $ K [ $ i ] [ $ w ] = 0 ; else if ( $ wt [ $ i - 1 ] <= $ w ) $ K [ $ i ] [ $ w ] = max ( $ val [ $ i - 1 ] + $ K [ $ i - 1 ] [ $ w - $ wt [ $ i - 1 ] ] , $ K [ $ i - 1 ] [ $ w ] ) ; else $ K [ $ i ] [ $ w ] = $ K [ $ i - 1 ] [ $ w ] ; } } $ res = $ K [ $ n ] [ $ W ] ; echo $ res . \" STRNEWLINE \" ; $ w = $ W ; for ( $ i = $ n ; $ i > 0 && $ res > 0 ; $ i -- ) { if ( $ res == $ K [ $ i - 1 ] [ $ w ] ) continue ; else { echo $ wt [ $ i - 1 ] . \" \" ; $ res = $ res - $ val [ $ i - 1 ] ; $ w = $ w - $ wt [ $ i - 1 ] ; } } } $ val = array ( 60 , 100 , 120 ) ; $ wt = array ( 10 , 20 , 30 ) ; $ W = 50 ; $ n = sizeof ( $ val ) ; printknapSack ( $ W , $ wt , $ val , $ n ) ; ? >"}
{"text": "Bilangan maksimum segmen panjang a, b dan c | berfungsi untuk mencari bilangan maksimum segmen; menyimpan bilangan maksimum segmen setiap indeks boleh; Inisialisasi dengan - 1; Indeks ke 0 akan mempunyai 0 Segmen Base Case; melintasi semua segmen yang mungkin sehingga n; syarat jika ($ i + $ a <= $ n) Elakkan limpahan penampan; jika ($ i + $ b <= $ n) Elakkan limpahan penampan; jika ($ i + $ c <= $ n) Elakkan limpahan penampan; Kod pemacu", "code": "< ? php function maximumSegments ( $ n , $ a , $ b , $ c ) { $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ n + 10 ; $ i ++ ) $ dp [ $ i ] = -1 ; $ dp [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ dp [ $ i ] != -1 ) { $ dp [ $ i + $ a ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ a ] ) ; $ dp [ $ i + $ b ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ b ] ) ; $ dp [ $ i + $ c ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ c ] ) ; } } return $ dp [ $ n ] ; } $ n = 7 ; $ a = 5 ; $ b = 2 ; $ c = 5 ; echo ( maximumSegments ( $ n , $ a , $ b , $ c ) ) ; ? >"}
{"text": "Cetak N Syarat Newman | Berfungsi untuk mencari elemen n - th; Mengisytiharkan array untuk menyimpan urutan; Kod pemacu", "code": "< ? php function sequence ( $ n ) { $ f = array ( 0 ) ; $ f [ 0 ] = 0 ; $ f [ 1 ] = 1 ; $ f [ 2 ] = 1 ; echo $ f [ 1 ] , \" \" ▁ , ▁ $ f [ 2 ] ▁ , ▁ \" \" for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ f [ $ i ] = $ f [ $ f [ $ i - 1 ] ] + $ f [ $ i - $ f [ $ i - 1 ] ] ; echo $ f [ $ i ] , \" \" ; } } { $ n = 13 ; sequence ( $ n ) ; return 0 ; } ? >"}
{"text": "Nombor entringer | Kembali nombor entringer E (n, k); Kes asas; Mencari DP [i] [J]; Kod yang didorong", "code": "< ? php function zigzag ( $ n , $ k ) { $ dp = array ( array ( ) ) ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i ] [ $ j - 1 ] + $ dp [ $ i - 1 ] [ $ i - $ j ] ; } return $ dp [ $ n ] [ $ k ] ; } $ n = 4 ; $ k = 3 ; echo zigzag ( $ n , $ k ) ; ? >"}
{"text": "Nombor lobb | Program PHP untuk mencari nombor ln, m lobb. ; Pulangan nilai pekali binomial c (n, k); Hitung nilai pekali binomial dengan cara bawah; Kes asas; Hitung nilai menggunakan nilai yang disimpan secara reviang; Kembalikan nombor lm, n lobb. ; Kod yang didorong", "code": "< ? php $ MAXN = 109 ; function binomialCoeff ( $ n , $ k ) { $ C = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ k ) ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } return $ C [ $ n ] [ $ k ] ; } function lobb ( $ n , int $ m ) { return ( ( 2 * $ m + 1 ) * binomialCoeff ( 2 * $ n , $ m + $ n ) ) / ( $ m + $ n + 1 ) ; } $ n = 5 ; $ m = 3 ; echo lobb ( $ n , $ m ) ; ? >"}
{"text": "Count of Arrays yang mempunyai elemen berturut -turut dengan nilai yang berbeza | Program PHP untuk mencari kiraan tatasusunan. ; Kembalikan bilangan tatasusunan dengan konstart yang diberikan. ; Inisialisasi DP [0] dan DP [1]. ; Pengkomputeran F (i) untuk setiap 2 <= i <= n. ; Kod yang didorong", "code": "< ? php $ MAXN = 109 ; function countarray ( $ n , $ k , $ x ) { $ dp = array ( 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = ( $ k - 2 ) * $ dp [ $ i - 1 ] + ( $ k - 1 ) * $ dp [ $ i - 2 ] ; return ( $ x == 1 ? ( $ k - 1 ) * $ dp [ $ n - 2 ] : $ dp [ $ n - 1 ] ) ; } $ n = 4 ; $ k = 3 ; $ x = 2 ; echo countarray ( $ n , $ k , $ x ) ; ? >"}
{"text": "Bilangan Palindromic Panjang Panjang K di mana k <= 3 | Program PHP untuk mengira bilangan berikutnya panjang yang diberikan. ; Precompute Awalan dan array akhiran. ; Precompute array 2D awalan; Precompute Suffix 2D Arus. ; Cari bilangan Palindromic selepas panjang K; Jika k adalah 1.; Jika k adalah 2; Menambah semua produk array awalan; Untuk k lebih besar daripada 2. Menambah semua produk nilai awalan dan sufiks array. ; Kod pemacu", "code": "< ? php $ MAX = 100 ; $ MAX_CHAR = 26 ; function precompute ( $ s , $ n , & $ l , & $ r ) { global $ MAX , $ MAX_CHAR ; $ l [ ord ( $ s [ 0 ] ) - ord ( ' a ' ) ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ MAX_CHAR ; $ j ++ ) $ l [ $ j ] [ $ i ] += $ l [ $ j ] [ $ i - 1 ] ; $ l [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] [ $ i ] ++ ; } $ r [ ord ( $ s [ $ n - 1 ] ) - ord ( ' a ' ) ] [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ MAX_CHAR ; $ j ++ ) $ r [ $ j ] [ $ i ] += $ r [ $ j ] [ $ i + 1 ] ; $ r [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] [ $ i ] ++ ; } } function countPalindromes ( $ k , $ n , & $ l , & $ r ) { global $ MAX , $ MAX_CHAR ; $ ans = 0 ; if ( $ k == 1 ) { for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) $ ans += $ l [ $ i ] [ $ n - 1 ] ; return $ ans ; } if ( $ k == 2 ) { for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) $ ans += ( ( $ l [ $ i ] [ $ n - 1 ] * ( $ l [ $ i ] [ $ n - 1 ] - 1 ) ) / 2 ) ; return $ ans ; } for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ MAX_CHAR ; $ j ++ ) $ ans += $ l [ $ j ] [ $ i - 1 ] * $ r [ $ j ] [ $ i + 1 ] ; return $ ans ; } $ s = \" aabab \" ; $ k = 2 ; $ n = strlen ( $ s ) ; $ l = array_fill ( 0 , $ MAX_CHAR , array_fill ( 0 , $ MAX , NULL ) ) ; $ r = array_fill ( 0 , $ MAX_CHAR , array_fill ( 0 , $ MAX , NULL ) ) ; precompute ( $ s , $ n , $ l , $ r ) ; echo countPalindromes ( $ k , $ n , $ l , $ r ) . \" \" ; ? >"}
{"text": "Laluan Jumlah Maksimum dalam Matriks dari atas ke Bawah | Pelaksanaan PHP untuk mencari laluan jumlah maksimum dalam matriks; berfungsi untuk mencari laluan jumlah maksimum dalam matrik; Sekiranya terdapat satu elemen sahaja; dp [] [] matriks untuk menyimpan hasil setiap lelaran; kes asas, menyalin elemen baris terakhir; membina matriks DP [] [] dari bawah ke baris atas; Mencari elemen pepenjuru maksimum dalam baris (i + 1) jika sel itu wujud; menambah bahawa elemen 'max' ke elemen [i] [j]; mencari nilai maksimum dari baris pertama dp [] []; Jumlah maksimum yang diperlukan; Kod pemacu", "code": "< ? php $ SIZE = 10 ; function maxSum ( $ mat , $ n ) { if ( $ n == 1 ) return $ mat [ 0 ] [ 0 ] ; $ dp = array ( array ( ) ) ; $ maxSum = PHP_INT_MIN ; $ max ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ n - 1 ] [ $ j ] = $ mat [ $ n - 1 ] [ $ j ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ max = PHP_INT_MIN ; if ( ( ( $ j - 1 ) >= 0 ) and ( $ max < $ dp [ $ i + 1 ] [ $ j - 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j - 1 ] ; if ( ( ( $ j + 1 ) < $ n ) and ( $ max < $ dp [ $ i + 1 ] [ $ j + 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j + 1 ] ; $ dp [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + $ max ; } } for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ maxSum < $ dp [ 0 ] [ $ j ] ) $ maxSum = $ dp [ 0 ] [ $ j ] ; return $ maxSum ; } $ mat = array ( array ( 5 , 6 , 1 , 7 ) , array ( -2 , 10 , 8 , -1 ) , array ( 3 , -7 , -9 , 11 ) , array ( 12 , -4 , 2 , 6 ) ) ; $ n = 4 ; echo \" Maximum ▁ Sum ▁ = ▁ \" , maxSum ( $ mat , $ n ) ; ? >"}
{"text": "Susunan berulang yang paling lama | Fungsi ini terutamanya mengembalikan LCS (STR, STR) dengan syarat bahawa aksara yang sama pada indeks yang sama tidak dipertimbangkan. ; Bahagian kod ini sama seperti di bawah pos. Ia mengisi dp [] [] https: www. Geeksforgeeks. org / terpanjang - mengulangi - seterusnya / atau kod yang disebutkan di atas. ; Bahagian kod ini mendapati rentetan hasil menggunakan dp [] [], memulakan hasil; Traverse dp [] [] dari kanan bawah; Jika sel ini sama dengan sel bersebelahan diagonal di atasnya, maka watak -watak yang sama hadir di STR [i - 1] dan str [J - 1]. Tambah mana -mana daripada mereka untuk menghasilkan. ; Jika tidak, kita berpindah ke sisi yang memberi kita hasil maksimum; Oleh kerana kita melintasi dp [] [] dari bawah, kita dapat menghasilkan urutan terbalik. ; Kod pemacu", "code": "< ? php function longestRepeatedSubSeq ( $ str ) { $ n = strlen ( $ str ) ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) if ( $ str [ $ i - 1 ] == $ str [ $ j - 1 ] && $ i != $ j ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; $ res = \" \" ; $ i = $ n ; $ j = $ n ; while ( $ i > 0 && $ j > 0 ) { if ( $ dp [ $ i ] [ $ j ] == $ dp [ $ i - 1 ] [ $ j - 1 ] + 1 ) { $ res = $ res . $ str [ $ i - 1 ] ; $ i -- ; $ j -- ; } else if ( $ dp [ $ i ] [ $ j ] == $ dp [ $ i - 1 ] [ $ j ] ) $ i -- ; else $ j -- ; } return strrev ( $ res ) ; } $ str = \" AABEBCDD \" ; echo longestRepeatedSubSeq ( $ str ) ; ? >"}
{"text": "Unsur maksimum yang boleh dibuat sama dengan Kemas Kini K | Program PHP untuk mencari elemen maksimum yang boleh dibuat sama dengan k; Fungsi untuk mengira bilangan maksimum elemen yang sama dengan peningkatan nilai K. Di sini kita telah melakukan tetingkap gelongsor untuk menentukan sama ada terdapat bilangan unsur -unsur yang hadir pada kenaikan yang akan menjadi sama. Gelung di sini akan berjalan dalam fesyen seperti 0. . x - 1, 1 .. . x, 2.. . x + 1, .... , n - x - 1. . n - 1; Ia dapat dijelaskan dengan alasan bahawa jika untuk beberapa bilangan unsur x kita dapat mengemas kini nilai -nilai maka kenaikan ke segmen (i hingga j yang mempunyai panjang -> x) supaya semua akan sama adalah (x * maxx [j]) ini adalah jumlah segmen dan (pre [j] - pre [i]) Susun array dalam urutan menaik; Memulakan array awalan dan array maksimum; Mengira jumlah awalan array; Mengira nilai maksimum sehingga kedudukan itu dalam array; Carian binari digunakan untuk pengiraan di sini; hasil percetakan; Kod pemacu", "code": "< ? php function ElementsCalculationFunc ( $ pre , $ maxx , $ x , $ k , $ n ) { for ( $ i = 0 , $ j = $ x ; $ j <= $ n ; $ j ++ , $ i ++ ) { function ElementsCalculationFunc ( $ pre , $ maxx , $ x , $ k , $ n ) { for ( $ i = 0 , $ j = $ x ; $ j <= $ n ; $ j ++ , $ i ++ ) { if ( $ x * $ maxx [ $ j ] - ( $ pre [ $ j ] - $ pre [ $ i ] ) <= $ k ) return true ; } return false ; } function MaxNumberOfElements ( $ a , $ n , $ k ) { sort ( $ a ) ; for ( $ i = 0 ; $ i <= $ n ; ++ $ i ) { $ pre [ $ i ] = 0 ; $ maxx [ $ i ] = 0 ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ pre [ $ i ] = $ pre [ $ i - 1 ] + $ a [ $ i - 1 ] ; $ maxx [ $ i ] = max ( $ maxx [ $ i - 1 ] , $ a [ $ i - 1 ] ) ; } $ l = 1 ; $ r = $ n ; $ ans ; while ( $ l < $ r ) { $ mid = ( $ l + $ r ) / 2 ; if ( ElementsCalculationFunc ( $ pre , $ maxx , $ mid - 1 , $ k , $ n ) ) { $ ans = $ mid ; $ l = $ mid + 1 ; } else $ r = $ mid - 1 ; } echo $ ans , \" STRNEWLINE \" ; } $ arr = array ( 2 , 4 , 9 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; $ k = 3 ; MaxNumberOfElements ( $ arr , $ n , $ k ) ; #This  code is contributed by akt_mit. NEW_LINE ? >"}
{"text": "Keluarkan elemen akhir array untuk memaksimumkan jumlah produk | Program PHP untuk mencari skor maksimum yang boleh kita dapatkan dengan mengeluarkan elemen dari kedua -dua hujungnya. ; Jika hanya satu elemen yang tersisa. ; Jika sudah dikira, kembalikan nilai. ; Nilai Maksimum Pengkomputeran Apabila elemen pada Indeks I dan Indeks J akan dipilih. ; Kod pemacu", "code": "< ? php $ MAX = 50 ; function solve ( $ dp , $ a , $ low , $ high , $ turn ) { if ( $ low == $ high ) return $ a [ $ low ] * $ turn ; if ( $ dp [ $ low ] [ $ high ] != 0 ) return $ dp [ $ low ] [ $ high ] ; $ dp [ $ low ] [ $ high ] = max ( $ a [ $ low ] * $ turn + solve ( $ dp , $ a , $ low + 1 , $ high , $ turn + 1 ) , $ a [ $ high ] * $ turn + solve ( $ dp , $ a , $ low , $ high - 1 , $ turn + 1 ) ) ; return $ dp [ $ low ] [ $ high ] ; } $ arr = array ( 1 , 3 , 1 , 5 , 2 ) ; $ n = count ( $ arr ) ; $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { $ dp [ $ i ] = array_fill ( $ i , $ MAX , 0 ) ; } echo solve ( $ dp , $ arr , 0 , $ n - 1 , 1 ) ; ? >"}
{"text": "SUBRAY BITONIC MAXIMUM | berfungsi untuk mencari subarray bitonic maksimum; 'MSIS []' untuk menyimpan jumlah maksimum yang meningkatkan subarray sehingga setiap indeks 'arr' dari awal 'msds []' untuk menyimpan jumlah maksimum yang menurunkan subarray dari setiap indeks 'arr' hingga akhir; untuk menyimpan subarray bitonic maksimum; membina jumlah maksimum yang semakin meningkat untuk setiap indeks array; Membina jumlah maksimum menurun subarray untuk setiap indeks array; Bagi setiap indeks array, mengira jumlah maksimum subarray bitonic yang mana ia adalah sebahagian daripada; Jika benar, maka kemas kini 'max' bitonic subarray sum; Jumlah maksimum yang diperlukan; Kod pemacu", "code": "< ? php function maxSumBitonicSubArr ( $ arr , $ n ) { $ msis = array ( ) ; $ msds = array ( ) ; $ max_sum = PHP_INT_MIN ; $ msis [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) $ msis [ $ i ] = $ msis [ $ i - 1 ] + $ arr [ $ i ] ; else $ msis [ $ i ] = $ arr [ $ i ] ; $ msds [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) $ msds [ $ i ] = $ msds [ $ i + 1 ] + $ arr [ $ i ] ; else $ msds [ $ i ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max_sum < ( $ msis [ $ i ] + $ msds [ $ i ] - $ arr [ $ i ] ) ) $ max_sum = $ msis [ $ i ] + $ msds [ $ i ] - $ arr [ $ i ] ; return $ max_sum ; } $ arr = array ( 5 , 3 , 9 , 2 , 7 , 6 , 4 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum ▁ Sum ▁ = ▁ \" , maxSumBitonicSubArr ( $ arr , $ n ) ; ? >"}
{"text": "Kira bilangan cara untuk jubin lantai saiz n x m menggunakan jubin saiz 1 x m | berfungsi untuk mengira jumlah cara; Jadual untuk menyimpan nilai subproblem; Isi jadual sehingga nilai n; hubungan berulang; kes asas; i = = m; bilangan cara yang diperlukan; Kod pemacu", "code": "< ? php function countWays ( $ n , $ m ) { $ count [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i > $ m ) $ count [ $ i ] = $ count [ $ i - 1 ] + $ count [ $ i - $ m ] ; else if ( $ i < $ m or $ i == 1 ) $ count [ $ i ] = 1 ; else $ count [ $ i ] = 2 ; } return $ count [ $ n ] ; } $ n = 7 ; $ m = 4 ; echo \" Number ▁ of ▁ ways ▁ = ▁ \" , countWays ( $ n , $ m ) ; ? >"}
{"text": "Jumlah Zigzag Jumlah terbesar dalam matriks | Program PHP untuk mencari urutan zigzag jumlah terbesar; Mengembalikan jumlah terbesar urutan zigzag bermula dari (i, j) dan berakhir di sel bawah. ; Jika kita telah mencapai bawah; Cari jumlah terbesar dengan mempertimbangkan semua elemen seterusnya dalam urutan. ; Mengembalikan jumlah terbesar urutan Zizag bermula dari atas dan berakhir di bawah. ; Pertimbangkan semua sel baris teratas sebagai titik permulaan; Kod pemacu", "code": "< ? php $ MAX = 100 ; function largestZigZagSumRec ( $ mat , $ i , $ j , $ n ) { if ( $ i == $ n - 1 ) return $ mat [ $ i ] [ $ j ] ; $ zzs = 0 ; for ( $ k = 0 ; $ k < $ n ; $ k ++ ) if ( $ k != $ j ) $ zzs = max ( $ zzs , largestZigZagSumRec ( $ mat , $ i + 1 , $ k , $ n ) ) ; return $ zzs + $ mat [ $ i ] [ $ j ] ; } function largestZigZag ( $ mat , $ n ) { $ res = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ res = max ( $ res , largestZigZagSumRec ( $ mat , 0 , $ j , $ n ) ) ; return $ res ; } $ n = 3 ; $ mat = array ( array ( 4 , 2 , 1 ) , array ( 3 , 9 , 6 ) , array ( 11 , 3 , 15 ) ) ; echo \" Largest ▁ zigzag ▁ sum : ▁ \" , largestZigZag ( $ mat , $ n ) ; ? >"}
{"text": "Count of Strings yang boleh dibentuk menggunakan A, B dan C di bawah kekangan yang diberikan | n adalah jumlah aksara. Bcount dan Ccount adalah tuduhan 'B' dan 'C' masing -masing. ; Kes asas; Tiga kes, kami memilih, a atau b atau c. Dalam ketiga -tiga kes N berkurangan sebanyak 1 .; Jumlah watak", "code": "< ? php function countStr ( $ n , $ bCount , $ cCount ) { if ( $ bCount < 0 $ cCount < 0 ) return 0 ; if ( $ n == 0 ) return 1 ; if ( $ bCount == 0 && $ cCount == 0 ) return 1 ; $ res = countStr ( $ n - 1 , $ bCount , $ cCount ) ; $ res += countStr ( $ n - 1 , $ bCount - 1 , $ cCount ) ; $ res += countStr ( $ n - 1 , $ bCount , $ cCount - 1 ) ; return $ res ; } $ n = 3 ; echo countStr ( $ n , 1 , 2 ) ; ? >"}
{"text": "Jumlah laluan maksimum yang bermula dengan mana -mana sel 0 | Program PHP untuk mencari jalur maksimum Mulakan mana -mana lajur dalam baris '0' dan berakhir dengan mana -mana lajur dalam baris 'n - 1'; fungsi mencari laluan jumlah maksimum; Buat matriks 2D untuk menyimpan jumlah jalan; Salin semua elemen lajur pertama ke dalam lajur pertama 'DP'; Cari jumlah laluan maksimum yang berakhir di mana -mana lajur baris terakhir 'n - 1'; kembali laluan jumlah maksimum; Kod pemacu", "code": "< ? php $ N = 4 ; function MaximumPath ( & $ Mat ) { global $ N ; $ result = 0 ; $ dp = array_fill ( 0 , $ N , array_fill ( 0 , $ N + 2 , NULL ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dp [ 0 ] [ $ i + 1 ] = $ Mat [ 0 ] [ $ i ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 1 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i - 1 ] [ $ j - 1 ] , max ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i - 1 ] [ $ j + 1 ] ) ) + $ Mat [ $ i ] [ $ j - 1 ] ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) $ result = max ( $ result , $ dp [ $ N - 1 ] [ $ i ] ) ; return $ result ; } $ Mat = array ( array ( 4 , 2 , 3 , 4 ) , array ( 2 , 9 , 1 , 10 ) , array ( 15 , 1 , 3 , 0 ) , array ( 16 , 92 , 41 , 44 ) ) ; echo MaximumPath ( $ Mat ) . \" STRNEWLINE \" ; ? >"}
{"text": "Kebarangkalian mendapatkan sekurang -kurangnya k kepala dalam n duit syiling | Pendekatan dinamik dan logaritma mencari kebarangkalian sekurang -kurangnya kepala K; DP [i] akan menyimpan log (i!) Dalam asas 2; Memulakan hasil; Berulang dari kepala k ke kepala n; Pra -proses semua nilai logaritma pada asas 2; Kod pemacu; Kebarangkalian mendapatkan 2 kepala daripada 3 syiling; Kebarangkalian mendapatkan 3 kepala daripada 6 syiling; Kebarangkalian mendapatkan 500 kepala daripada 10000 syiling", "code": "< ? php $ MAX = 100001 ; $ dp = array_fill ( 0 , $ MAX , 0 ) ; function probability ( $ k , $ n ) { global $ MAX , $ dp ; $ ans = 0 ; for ( $ i = $ k ; $ i <= $ n ; ++ $ i ) { $ res = $ dp [ $ n ] - $ dp [ $ i ] - $ dp [ $ n - $ i ] - $ n ; $ ans += pow ( 2.0 , $ res ) ; } return $ ans ; } function precompute ( ) { global $ MAX , $ dp ; for ( $ i = 2 ; $ i < $ MAX ; ++ $ i ) precompute ( ) ; echo probability ( 2 , 3 ) . \" STRNEWLINE \" ; echo probability ( 3 , 6 ) . \" STRNEWLINE \" ; echo probability ( 500 , 1000 ) ; ? >"}
{"text": "Jumlah Jalan Maksimum untuk setiap kedudukan dengan melompat di bawah keadaan divisibilitas | Program PHP untuk mencetak jumlah laluan maksimum yang berakhir dengan setiap kedudukan x supaya semua kedudukan langkah jalan membahagikan x. ; Buat array sedemikian rupa sehingga DP [i] menyimpan jumlah laluan maksimum yang berakhir dengan i. ; Mengira laluan jumlah maksimum untuk setiap elemen. ; Mencari langkah sebelumnya untuk ARR [i] bergerak dari 1 ke sqrt (i + 1) kerana semua pembahagi hadir dari sqrt (i + 1). ; Memeriksa jika J adalah pembahagi i + 1 .; Memeriksa pembahagi mana yang akan memberikan nilai yang lebih besar. ; Mencetak Jawapan (Jumlah Maksimum Jumlah Berakhir dengan Setiap Kedudukan I + 1.; Program Didorong; Fungsi Memanggil", "code": "< ? php function printMaxSum ( $ arr , $ n ) { $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp [ $ i ] = $ arr [ $ i ] ; $ maxi = 0 ; for ( $ j = 1 ; $ j <= sqrt ( $ i + 1 ) ; $ j ++ ) { if ( ( ( $ i + 1 ) % $ j == 0 ) && ( $ i + 1 ) != $ j ) { if ( $ dp [ $ j - 1 ] > $ maxi ) $ maxi = $ dp [ $ j - 1 ] ; if ( $ dp [ ( $ i + 1 ) / $ j - 1 ] > $ maxi && $ j != 1 ) $ maxi = $ dp [ ( $ i + 1 ) / $ j - 1 ] ; } } $ dp [ $ i ] += $ maxi ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ dp [ $ i ] , \" ▁ \" ; } $ arr = array ( 2 , 3 , 1 , 4 , 6 , 5 ) ; $ n = sizeof ( $ arr ) ; printMaxSum ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah maksimum berselang -seli | Pulangan jumlah maksimum urutan bergantian bermula dengan ARR [0] dan mula berkurangan. ; mengendalikan kes kelebihan; Kedai jumlah penurunan dan peningkatan sub -urutan; Simpan jumlah peningkatan dan penurunan matahari - urutan; Seperti soalan, elemen pertama mesti menjadi sebahagian daripada penyelesaian. ; Melintasi unsur -unsur array; Jika sub -urutan semasa mengurangkan kemas kini DEC [J] jika diperlukan. Dec [i] oleh Current Inc [j] + arr [i]; Kembalikan bendera, jika penurunan pertama dijumpai; Jika elemen seterusnya lebih besar tetapi bendera harus 1 i. e. Unsur ini harus dikira selepas elemen penurunan pertama dikira; Jika sub -urutan semasa semakin meningkat maka kemas kini inc [i]; Cari jumlah maksimum dalam b / w inc [] dan dec []; kembali maksimum SUN SUN - urutan; Kod pemacu", "code": "< ? php function maxAlternateSum ( $ arr , $ n ) { if ( $ n == 1 ) return $ arr [ 0 ] ; $ min = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ min = max ( $ min , $ arr [ $ i ] ) ; } if ( $ arr [ 0 ] == $ min ) return $ arr [ 0 ] ; $ dec = array_fill ( 0 , $ n , 0 ) ; $ inc = array_fill ( 0 , $ n , 0 ) ; $ dec [ 0 ] = $ inc [ 0 ] = $ arr [ 0 ] ; $ flag = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( $ arr [ $ j ] > $ arr [ $ i ] ) { $ dec [ $ i ] = max ( $ dec [ $ i ] , $ inc [ $ j ] + $ arr [ $ i ] ) ; $ flag = 1 ; } else if ( $ arr [ $ j ] < $ arr [ $ i ] && $ flag == 1 ) $ inc [ $ i ] = max ( $ inc [ $ i ] , $ dec [ $ j ] + $ arr [ $ i ] ) ; } } $ result = - ( PHP_INT_MAX - 1 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ result < $ inc [ $ i ] ) $ result = $ inc [ $ i ] ; if ( $ result < $ dec [ $ i ] ) $ result = $ dec [ $ i ] ; } return $ result ; } $ arr = array ( 8 , 2 , 3 , 5 , 7 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum ▁ sum ▁ = ▁ \" , maxAlternateSum ( $ arr , $ n ) ; ? >"}
{"text": "Urutan Padovan | Berfungsi untuk mengira nombor Padovan p (n); 0 Th, 1 st dan 2 Nd nombor siri adalah 1; Kod pemacu", "code": "< ? php function pad ( $ n ) { $ pPrevPrev = 1 ; $ pPrev = 1 ; $ pCurr = 1 ; $ pNext = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ pNext = $ pPrevPrev + $ pPrev ; $ pPrevPrev = $ pPrev ; $ pPrev = $ pCurr ; $ pCurr = $ pNext ; } return $ pNext ; } $ n = 12 ; echo ( pad ( $ n ) ) ; ? >"}
{"text": "Nombor Lucas | Fungsi iteratif; mengisytiharkan nilai asas untuk kedudukan 0 dan 1; nombor penjanaan; Kod pemacu", "code": "< ? php function lucas ( $ n ) { $ a = 2 ; $ b = 1 ; $ c ; $ i ; if ( $ n == 0 ) return $ a ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ c = $ a + $ b ; $ a = $ b ; $ b = $ c ; } return $ b ; } $ n = 9 ; echo lucas ( $ n ) ; ? >"}
{"text": "Recursif memecahkan nombor dalam 3 bahagian untuk mendapatkan jumlah maksimum | Berfungsi untuk mencari jumlah maksimum; keadaan asas; Isi cara bawah menggunakan formula rekursif. ; Kod pemacu", "code": "< ? php function breakSum ( $ n ) { $ dp = array_fill ( 0 , $ n + 1 , 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = max ( $ dp [ ( int ) ( $ i / 2 ) ] + $ dp [ ( int ) ( $ i / 3 ) ] + $ dp [ ( int ) ( $ i / 4 ) ] , $ i ) ; return $ dp [ $ n ] ; } $ n = 24 ; echo breakSum ( $ n ) ; ? >"}
{"text": "Masa minimum untuk menyelesaikan tugas tanpa melangkau dua berturut -turut | arr [] mewakili masa yang diambil oleh tugas yang diberikan; Kes sudut; Tugas pertama dikecualikan; Proses yang tinggal n - 1 tugas; Masa yang diambil jika tugas semasa dimasukkan terdapat dua kemungkinan (a) tugas sebelumnya juga termasuk (b) tugas sebelumnya tidak termasuk; Masa yang diambil apabila tugas semasa tidak termasuk. Hanya ada satu kemungkinan bahawa tugas sebelumnya juga dimasukkan. ; Kemas kini termasuk dan excl untuk lelaran seterusnya; Pulangan maksimum dua nilai untuk tugas terakhir; Kod pemacu", "code": "< ? php function minTime ( $ arr , $ n ) { if ( $ n <= 0 ) return 0 ; $ excl = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ incl_new = $ arr [ $ i ] + min ( $ excl , $ incl ) ; $ excl_new = $ incl ; $ incl = $ incl_new ; $ excl = $ excl_new ; } return min ( $ incl , $ excl ) ; } $ arr1 = array ( 10 , 5 , 2 , 7 , 10 ) ; $ n1 = sizeof ( $ arr1 ) ; echo minTime ( $ arr1 , $ n1 ) , \" STRNEWLINE \" ; $ arr2 = array ( 10 , 5 , 7 , 10 ) ; $ n2 = sizeof ( $ arr2 ) ; echo minTime ( $ arr2 , $ n2 ) , \" STRNEWLINE \" ; $ arr3 = array ( 10 , 5 , 2 , 4 , 8 , 6 , 7 , 10 ) ; $ n3 = sizeof ( $ arr3 ) ; echo minTime ( $ arr3 , $ n3 ) ; ? >"}
{"text": "MATRIX Exponentiation | Fungsi utiliti untuk melipatgandakan dua matriks a [] [] dan b [] []. Hasil pendaraban disimpan kembali dalam b [] []; Mewujudkan matriks tambahan untuk menyimpan unsur -unsur matriks pendaraban; Menyimpan hasil pendaraban dalam [] []; Mengemas kini matriks kami; Fungsi untuk mengira f kenaikan kuasa n - 2 .; Dalikan dengan nilai awal i. e dengan f (0) = 0, f (1) = 1, f (2) = 1; Dalikan dengan nilai awal i. e dengan f (0) = 0, f (1) = 1, f (2) = 1; Kembalikan istilah siri yang ditakrifkan menggunakan hubungan berulang di bawah. F (n) ditakrifkan sebagai f (n) = f (n-1) + f (n-2) + f (n-3), n> = 3 kes asas: f (0) = 0, f (1) = 1, f (2) = 1; Kod pemacu", "code": "< ? php function multiply ( & $ a , & $ b ) { $ mul = array_fill ( 0 , 3 , array_fill ( 0 , 3 , 0 ) ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { for ( $ j = 0 ; $ j < 3 ; $ j ++ ) { $ mul [ $ i ] [ $ j ] = 0 ; for ( $ k = 0 ; $ k < 3 ; $ k ++ ) $ mul [ $ i ] [ $ j ] += $ a [ $ i ] [ $ k ] * $ b [ $ k ] [ $ j ] ; } } for ( $ i = 0 ; $ i < 3 ; $ i ++ ) for ( $ j = 0 ; $ j < 3 ; $ j ++ ) $ a [ $ i ] [ $ j ] = $ mul [ $ i ] [ $ j ] ; } function power ( $ F , $ n ) { $ M = array ( array ( 1 , 1 , 1 ) , array ( 1 , 0 , 0 ) , array ( 0 , 1 , 0 ) ) ; if ( $ n == 1 ) return $ F [ 0 ] [ 0 ] + $ F [ 0 ] [ 1 ] ; power ( $ F , ( int ) ( $ n / 2 ) ) ; multiply ( $ F , $ F ) ; if ( $ n % 2 != 0 ) multiply ( $ F , $ M ) ; return $ F [ 0 ] [ 0 ] + $ F [ 0 ] [ 1 ] ; } function findNthTerm ( $ n ) { $ F = array ( array ( 1 , 1 , 1 ) , array ( 1 , 0 , 0 ) , array ( 0 , 1 , 0 ) ) ; return power ( $ F , $ n - 2 ) ; } $ n = 5 ; echo \" F ( 5 ) ▁ is ▁ \" . findNthTerm ( $ n ) ; ? >"}
{"text": "Kira bilangan cara untuk mengisi grid \"n ~ ~ 4\" menggunakan jubin \"1 ~ ~ 4\" | Mengembalikan kiraan cara untuk meletakkan 1 x 4 jubin pada grid n x 4. ; Buat jadual untuk menyimpan hasil subproblem dp [i] kedai mengira cara untuk i x 4 grid. ; Isi jadual dari D [1] ke DP [n]; Kes asas; DP (I - 1): Letakkan jubin pertama dp (n - 4): Letakkan jubin pertama secara menegak yang bermaksud 3 jubin lagi perlu diletakkan secara menegak. ; Kod pemacu", "code": "< ? php function countt ( $ n ) { $ dp [ $ n + 1 ] = 0 ; $ dp [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i >= 1 && $ i <= 3 ) $ dp [ $ i ] = 1 ; else if ( $ i == 4 ) $ dp [ $ i ] = 2 ; else $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 4 ] ; } return $ dp [ $ n ] ; } $ n = 5 ; echo \" Count ▁ of ▁ ways ▁ is ▁ \" , countt ( $ n ) ; ? >"}
{"text": "Kirakan NCR % P | Tetapkan 1 (Pengenalan dan Penyelesaian Pengaturcaraan Dinamik) | Mengembalikan NCR % p; Pengoptimuman untuk kes -kes apabila R adalah besar; Arus C akan menyimpan baris terakhir Pascal Triangle pada akhir. Dan kemasukan terakhir baris terakhir ialah NCR; Baris atas segitiga Pascal; Satu dengan membina baris segitiga Pascal dari atas ke bawah; Isi penyertaan baris semasa menggunakan nilai baris sebelumnya; ncj = (n - 1) cj + (n - 1) c (j - 1); ; Kod pemacu", "code": "< ? php function nCrModp ( $ n , $ r , $ p ) { if ( $ r > $ n - $ r ) $ r = $ n - $ r ; $ C = array ( ) ; for ( $ i = 0 ; $ i < $ r + 1 ; $ i ++ ) $ C [ $ i ] = 0 ; $ C [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = Min ( $ i , $ r ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = ( $ C [ $ j ] + $ C [ $ j - 1 ] ) % $ p ; } return $ C [ $ r ] ; } $ n = 10 ; $ r = 2 ; $ p = 13 ; echo \" Value ▁ of ▁ nCr ▁ % ▁ p ▁ is ▁ \" , nCrModp ( $ n , $ r , $ p ) ; ? >"}
{"text": "Nombor Bell (bilangan cara untuk memisahkan satu set) | fungsi yang mengembalikan nombor loceng n 'th; Secara eksplisit mengisi j = 0; Isi nilai baki J; Kod pemacu", "code": "< ? php function bellNumber ( $ n ) { $ bell [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ bell [ $ i ] [ 0 ] = $ bell [ $ i - 1 ] [ $ i - 1 ] ; for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ bell [ $ i ] [ $ j ] = $ bell [ $ i - 1 ] [ $ j - 1 ] + $ bell [ $ i ] [ $ j - 1 ] ; } return $ bell [ $ n ] [ 0 ] ; } for ( $ n = 0 ; $ n <= 5 ; $ n ++ ) echo ( \" Bell ▁ Number ▁ \" . $ n . \" ▁ is ▁ \" . bellNumber ( $ n ) . \" STRNEWLINE \" ) ; ? >"}
{"text": "Mengira bilangan cara untuk menutup jarak | Fungsi mengembalikan kiraan cara untuk menutup 'dist'; Inisialisasi nilai asas. Terdapat satu cara untuk menampung 0 dan 1 jarak dan dua cara untuk menutup 2 jarak; Isi array kiraan dengan cara bawah; Kod pemacu", "code": "< ? php function printCountDP ( $ dist ) { $ count = array ( ) ; $ count [ 0 ] = 1 ; $ count [ 1 ] = 1 ; $ count [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ dist ; $ i ++ ) $ count [ $ i ] = $ count [ $ i - 1 ] + $ count [ $ i - 2 ] + $ count [ $ i - 3 ] ; return $ count [ $ dist ] ; } $ dist = 4 ; echo printCountDP ( $ dist ) ; ? >"}
{"text": "Kira urutan binari panjang dengan jumlah yang sama dengan bit separuh pertama dan kedua | Mengembalikan kiraan urutan panjang; Hitung jumlah ((NCR) ^ 2); Kirakan NCR menggunakan NC (R - 1) NCR / NC (R - 1) = (N + 1 - R) / R; ; Kod pemacu", "code": "< ? php function countSeq ( $ n ) { $ nCr = 1 ; $ res = 1 ; for ( $ r = 1 ; $ r <= $ n ; $ r ++ ) { $ nCr = ( $ nCr * ( $ n + 1 - $ r ) ) / $ r ; $ res = $ res + ( $ nCr * $ nCr ) ; } return $ res ; } $ n = 2 ; echo ( \" Count ▁ of ▁ sequences ▁ is ▁ \" ) ; echo countSeq ( $ n ) ; ? >"}
{"text": "Keluarkan unsur -unsur minimum dari kedua -dua belah pihak supaya 2 * min menjadi lebih daripada max | Fungsi utiliti untuk mencari minimum dalam arr [l. . h]; Fungsi utiliti untuk mencari maksimum dalam arr [l. . h]; Mengembalikan bilangan minimum penyingkiran dari kedua -dua hujung di arr [l. . H] supaya 2 * min menjadi lebih besar daripada maks. ; Buat jadual untuk menyimpan penyelesaian subproblem; Isi jadual menggunakan formula rekursif di atas. Perhatikan bahawa jadual diisi dalam fesyen pepenjuru (serupa dengan http: goo GL / pqqOS), dari unsur -unsur pepenjuru ke Jadual [0] [n - 1] yang hasilnya. ; Kod pemacu", "code": "< ? php function min1 ( $ arr , $ l , $ h ) { $ mn = $ arr [ $ l ] ; for ( $ i = $ l + 1 ; $ i <= $ h ; $ i ++ ) if ( $ mn > $ arr [ $ i ] ) $ mn = $ arr [ $ i ] ; return $ mn ; } function max1 ( $ arr , $ l , $ h ) { $ mx = $ arr [ $ l ] ; for ( $ i = $ l + 1 ; $ i <= $ h ; $ i ++ ) if ( $ mx < $ arr [ $ i ] ) $ mx = $ arr [ $ i ] ; return $ mx ; } function minRemovalsDP ( $ arr , $ n ) { $ table = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; for ( $ gap = 0 ; $ gap < $ n ; ++ $ gap ) { for ( $ i = 0 , $ j = $ gap ; $ j < $ n ; ++ $ i , ++ $ j ) { $ mn = min1 ( $ arr , $ i , $ j ) ; $ mx = max1 ( $ arr , $ i , $ j ) ; $ table [ $ i ] [ $ j ] = ( 2 * $ mn > $ mx ) ? 0 : min ( $ table [ $ i ] [ $ j - 1 ] + 1 , $ table [ $ i + 1 ] [ $ j ] + 1 ) ; } } return $ table [ 0 ] [ $ n - 1 ] ; } $ arr = array ( 20 , 4 , 1 , 3 ) ; $ n = count ( $ arr ) ; echo minRemovalsDP ( $ arr , $ n ) ; ? >"}
{"text": "Kira semua jalan yang mungkin dari kiri ke bawah kanan kanan matriks MXN | Mengembalikan kiraan laluan yang mungkin untuk mencapai sel pada nombor baris m dan nombor lajur n dari sel paling kiri (sel pada 1, 1); Jika sama ada nombor baris yang diberikan adalah nombor lajur pertama atau diberikan adalah yang pertama; Jika pergerakan pepenjuru dibenarkan maka penambahan terakhir diperlukan. ; Kod pemacu", "code": "< ? php function numberOfPaths ( $ m , $ n ) { if ( $ m == 1 $ n == 1 ) return 1 ; return numberOfPaths ( $ m - 1 , $ n ) + numberOfPaths ( $ m , $ n - 1 ) ; } echo numberOfPaths ( 3 , 3 ) ; ? >"}
{"text": "Kira semua jalan yang mungkin dari kiri ke bawah kanan kanan matriks MXN | Program PHP untuk mengira semua laluan yang mungkin dari kiri ke atas ke bahagian atas menggunakan kombinatorik; Kita perlu mengira m + n - 2 c n - 1 di sini yang akan menjadi (m + n - 2)! / (n - 1)! (M - 1)! ; Kod pemacu", "code": "< ? php function numberOfPaths ( $ m , $ n ) { $ path = 1 ; for ( $ i = $ n ; $ i < ( $ m + $ n - 1 ) ; $ i ++ ) { $ path *= $ i ; $ path /= ( $ i - $ n + 1 ) ; } return $ path ; } { echo ( numberOfPaths ( 3 , 3 ) ) ; }"}
{"text": "Kemajuan Aritmetik Terpanjang | DP | Mengembalikan panjang subset AP terpanjang dalam satu set tertentu; Buat jadual dan mulakan semua nilai sebagai 2. Nilai L [i] [j] menyimpan llap dengan set [i] dan tetapkan [j] sebagai dua elemen pertama AP. Hanya penyertaan yang sah adalah penyertaan di mana j> i; Isi penyertaan dalam lajur terakhir sebagai 2. Selalu ada dua elemen di AP dengan bilangan terakhir yang ditetapkan sebagai elemen kedua dalam AP; Pertimbangkan setiap elemen sebagai elemen kedua AP; Cari i dan k untuk j; Sebelum menukar saya, tetapkan l [i] [j] sebagai 2; Mendapati i dan k untuk j, llap dengan I dan J sebagai dua elemen pertama adalah sama dengan LLAP dengan J dan K sebagai dua elemen pertama ditambah 1. L [J] [K] mesti diisi sebelum ketika kami menjalankan gelung dari sebelah kanan; Mengemas kini LLAP secara keseluruhan, jika diperlukan; Tukar I dan K untuk mengisi lebih banyak nilai L [i] [j] untuk semasa J; Jika gelung dihentikan kerana k menjadi lebih daripada n - 1, tetapkan entiti yang tinggal dalam lajur J sebagai 2; Kod pemacu", "code": "< ? php function lenghtOfLongestAP ( $ set , $ n ) { if ( $ n <= 2 ) return $ n ; $ L [ $ n ] [ $ n ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ L [ $ i ] [ $ n - 1 ] = 2 ; for ( $ j = $ n - 2 ; $ j >= 1 ; $ j -- ) { $ i = $ j - 1 ; $ k = $ j + 1 ; while ( $ i >= 0 && $ k <= $ n - 1 ) { if ( $ set [ $ i ] + $ set [ $ k ] < 2 * $ set [ $ j ] ) $ k ++ ; else if ( $ set [ $ i ] + $ set [ $ k ] > 2 * $ set [ $ j ] ) { $ L [ $ i ] [ $ j ] = 2 ; $ i -- ; } else { $ L [ $ i ] [ $ j ] = $ L [ $ j ] [ $ k ] + 1 ; $ llap = max ( $ llap , $ L [ $ i ] [ $ j ] ) ; $ i -- ; $ k ++ ; } } while ( $ i >= 0 ) { $ L [ $ i ] [ $ j ] = 2 ; $ i -- ; } } return $ llap ; } $ set1 = array ( 1 , 7 , 10 , 13 , 14 , 19 ) ; $ n1 = sizeof ( $ set1 ) ; echo lenghtOfLongestAP ( $ set1 , $ n1 ) , \" \" ; $ set2 = array ( 1 , 7 , 10 , 15 , 27 , 29 ) ; $ n2 = sizeof ( $ set2 ) ; echo lenghtOfLongestAP ( $ set2 , $ n2 ) , \" \" ; $ set3 = array ( 2 , 4 , 6 , 8 , 10 ) ; $ n3 = sizeof ( $ set3 ) ; echo lenghtOfLongestAP ( $ set3 , $ n3 ) , \" \" ; ? >"}
{"text": "Susunan Bitonik Terpanjang | DP | lbs () Mengembalikan panjang seterusnya bitonic berikutnya dalam arr [] saiz n. Fungsi ini terutamanya mewujudkan dua array sementara LIS [] dan LDS [] dan mengembalikan maksimum lis [i] + lds [i] - 1. Lis [i] ==> Paulat yang paling lama meningkat seterusnya dengan ARR [i] lds [i] ==> paling lama penurunan berikutnya bermula dengan ARR [i]; Memperuntukkan memori untuk LIS [] dan memulakan nilai LIS sebagai 1 untuk semua indeks; Kirakan nilai lis dari kiri ke kanan; Memperuntukkan memori untuk LDS dan memulakan nilai LDS untuk semua indeks; Mengira nilai LDS dari kanan ke kiri; Kembalikan nilai maksimum LIS [i] + lds [i] - 1; Kod pemacu", "code": "< ? php function lbs ( & $ arr , $ n ) { $ lis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ lds = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lds [ $ i ] < $ lds [ $ j ] + 1 ) $ lds [ $ i ] = $ lds [ $ j ] + 1 ; $ max = $ lis [ 0 ] + $ lds [ 0 ] - 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ lis [ $ i ] + $ lds [ $ i ] - 1 > $ max ) $ max = $ lis [ $ i ] + $ lds [ $ i ] - 1 ; return $ max ; } $ arr = array ( 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 ) ; $ n = sizeof ( $ arr ) ; echo \" Length ▁ of ▁ LBS ▁ is ▁ \" . lbs ( $ arr , $ n ) ; ? >"}
{"text": "Teka -teki menjatuhkan telur | DP | Berfungsi untuk mendapatkan bilangan minimum ujian yang diperlukan dalam kes terburuk dengan telur N dan l lantai; Jadual 2D di mana kemasukan urgfloor [i] [j] akan mewakili bilangan minimum ujian yang diperlukan untuk saya telur dan lantai j. ; Kami memerlukan satu percubaan untuk satu tingkat dan0 ujian untuk 0 tingkat; Kami sentiasa memerlukan ujian untuk satu lantai telur dan J. ; Isi sisa penyertaan dalam jadual menggunakan harta substruktur yang optimum; Eggfloor [n] [k] memegang hasilnya; Kod pemacu", "code": "< ? php function eggDrop ( $ n , $ k ) { $ eggFloor = array ( array ( ) ) ; ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ eggFloor [ $ i ] [ 1 ] = 1 ; $ eggFloor [ $ i ] [ 0 ] = 0 ; } for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) $ eggFloor [ 1 ] [ $ j ] = $ j ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 2 ; $ j <= $ k ; $ j ++ ) { $ eggFloor [ $ i ] [ $ j ] = 999999 ; for ( $ x = 1 ; $ x <= $ j ; $ x ++ ) { $ res = 1 + max ( $ eggFloor [ $ i - 1 ] [ $ x - 1 ] , $ eggFloor [ $ i ] [ $ j - $ x ] ) ; if ( $ res < $ eggFloor [ $ i ] [ $ j ] ) $ eggFloor [ $ i ] [ $ j ] = $ res ; } } } return $ eggFloor [ $ n ] [ $ k ] ; } $ n = 2 ; $ k = 36 ; echo \" Minimum ▁ number ▁ of ▁ trials ▁ in ▁ worst ▁ case ▁ with ▁ \" . $ n . \" ▁ eggs ▁ and ▁ \" . $ k . \" ▁ floors ▁ is ▁ \" . eggDrop ( $ n , $ k ) ; ? >"}
{"text": "0 | Mengembalikan nilai maksimum yang boleh dimasukkan ke dalam kapasiti kapasiti w; Kes asas; Jika berat item nth lebih daripada kapasiti knapsack W, maka item ini tidak dapat dimasukkan ke dalam penyelesaian optimum; Kembalikan maksimum dua kes: (1) item Nth termasuk (2) tidak termasuk; Kod pemacu", "code": "< ? php function knapSack ( $ W , $ wt , $ val , $ n ) { if ( $ n == 0 $ W == 0 ) return 0 ; if ( $ wt [ $ n - 1 ] > $ W ) return knapSack ( $ W , $ wt , $ val , $ n - 1 ) ; else return max ( $ val [ $ n - 1 ] + knapSack ( $ W - $ wt [ $ n - 1 ] , $ wt , $ val , $ n - 1 ) , knapSack ( $ W , $ wt , $ val , $ n - 1 ) ) ; } $ val = array ( 60 , 100 , 120 ) ; $ wt = array ( 10 , 20 , 30 ) ; $ W = 50 ; $ n = count ( $ val ) ; echo knapSack ( $ W , $ wt , $ val , $ n ) ; ? >"}
{"text": "Jumlah bilangan pokok carian binari yang mungkin dan pokok binari dengan kekunci N | Fungsi untuk mencari faktorial nombor tertentu; Hitung nilai [1 ​​* (2) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Fungsi berasaskan pekali binomial untuk mencari nombor catalan n dalam masa O (n); Hitung nilai 2 ncn; kembali 2 ncn / (n + 1); Fungsi untuk mengira bilangan BST dengan nod N menggunakan Catalan; Cari nombor Catalan n; mengembalikan nombor catalan n; Fungsi untuk mengira bilangan pokok binari dengan nod N; Cari kiraan BST dengan nombor N; Kembali kiraan * n! ; Kod pemacu; Cari kiraan pokok BST dan binari dengan nod N; Cetak kiraan BST dan pokok binari dengan nod N", "code": "< ? php function factorial ( $ n ) { $ res = 1 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ res *= $ i ; } return $ res ; } function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res = ( int ) $ res / ( $ i + 1 ) ; } return $ res ; } function catalan ( $ n ) { $ c = binomialCoeff ( 2 * $ n , $ n ) ; return ( int ) $ c / ( $ n + 1 ) ; } function countBST ( $ n ) { $ count = catalan ( $ n ) ; return $ count ; } function countBT ( $ n ) { $ count = catalan ( $ n ) ; return $ count * factorial ( $ n ) ; } $ count1 ; $ count2 ; $ n = 5 ; $ count1 = countBST ( $ n ) ; $ count2 = countBT ( $ n ) ; echo \" Count ▁ of ▁ BST ▁ with ▁ \" , $ n , \" ▁ nodes ▁ is ▁ \" , $ count1 , \" STRNEWLINE \" ; echo \" Count ▁ of ▁ binary ▁ trees ▁ with ▁ \" , $ n , \" ▁ nodes ▁ is ▁ \" , $ count2 ; ? >"}
{"text": "Menjana permutasi 1 hingga n seperti perbezaan mutlak nombor berturut -turut memberikan k yang berbeza | Fungsi untuk menghasilkan permutasi bilangan bulat dari 1 hingga n supaya perbezaan mutlak semua kedua -dua integer berturut -turut memberikan integer yang berbeza; Untuk menyimpan permutasi; Untuk urutan 1 2 3.. . ; Untuk urutan N, n - 1, n - 2 .. . ; Bendera digunakan untuk bergantian antara di atas jika pernyataan lain; Jika elemen terakhir ditambah ialah R + 1; Jika elemen terakhir ditambah ialah l - 1; Cetak permutasi; Kod pemacu", "code": "< ? php function printPermutation ( $ N , $ K ) { $ res = array ( ) ; $ l = 1 ; $ r = $ N ; $ flag = 0 ; for ( $ i = 0 ; $ i < $ K ; $ i ++ ) { if ( ! $ flag ) { array_push ( $ res , $ l ) ; $ l ++ ; } else { array_push ( $ res , $ r ) ; $ r -- ; } $ flag ^= 1 ; } if ( ! $ flag ) { for ( $ i = $ r ; $ i >= $ l ; $ i -- ) array_push ( $ res , $ i ) ; } else { for ( $ i = l ; $ i <= $ r ; $ i ++ ) array_push ( $ res , $ i ) ; } for ( $ i = 0 ; $ i < sizeof ( $ res ) ; $ i ++ ) echo $ res [ $ i ] , \" ▁ \" ; } $ N = 10 ; $ K = 4 ; printPermutation ( $ N , $ K ) ; ? >"}
{"text": "Cari istilah n Siri 1, 8, 54, 384. . | Hitung faktorial n; mengira istilah siri nth; Kod pemacu", "code": "< ? php function fact ( $ N ) { $ product = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ product = $ product * $ i ; return $ product ; } function nthTerm ( $ N ) { return ( $ N * $ N ) * fact ( $ N ) ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Rabin | D ialah bilangan aksara dalam abjad input; Pat -> Corak Txt -> Teks Q -> Nombor Perdana; $ p = 0; nilai hash untuk corak $ t = 0; nilai hash untuk txt; Nilai H ialah \"pow (d, u, 1) % q\"; Kirakan nilai hash corak dan tetingkap pertama teks; Luncurkan corak ke atas teks satu demi satu; Semak nilai hash tetingkap semasa teks dan corak. Jika nilai hash sepadan maka hanya periksa aksara oleh satu; Semak watak satu demi satu; jika p == t dan pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]; Kirakan nilai hash untuk tetingkap teks seterusnya: Keluarkan digit terkemuka, tambah digit trailing; Kami mungkin mendapat nilai negatif T, menukarnya kepada positif; Kod pemacu; Nombor perdana; Panggilan fungsi", "code": "< ? php $ d = 256 ; function search ( $ pat , $ txt , $ q ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i ; $ j ; $ h = 1 ; $ d = 1 ; for ( $ i = 0 ; $ i < $ M - 1 ; $ i ++ ) $ h = ( $ h * $ d ) % $ q ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { $ p = ( $ d * $ p + $ pat [ $ i ] ) % $ q ; $ t = ( $ d * $ t + $ txt [ $ i ] ) % $ q ; } for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { if ( $ p == $ t ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; } if ( $ j == $ M ) echo \" Pattern ▁ found ▁ at ▁ index ▁ \" , $ i , \" STRNEWLINE \" ; } if ( $ i < $ N - $ M ) { $ t = ( $ d * ( $ t - $ txt [ $ i ] * $ h ) + $ txt [ $ i + $ M ] ) % $ q ; if ( $ t < 0 ) $ t = ( $ t + $ q ) ; } } } $ txt = \" GEEKS ▁ FOR ▁ GEEKS \" ; $ pat = \" GEEK \" ; $ q = 101 ; search ( $ pat , $ txt , $ q ) ; ? >"}
{"text": "Bilangan minimum menara yang diperlukan supaya setiap rumah berada dalam lingkungan sekurang -kurangnya satu menara | Berfungsi untuk mengira bilangan menara; Mula -mula kita menyusun nombor rumah; untuk mengira bilangan menara; untuk melangkah ke semua rumah; kiraan bilangan menara; Cari cari lokasi tengah; melintasi lokasi tengah; Ini adalah titik ke rumah tengah di mana kita memasukkan menara; Sekarang cari lokasi terakhir; melintasi rumah terakhir; mengembalikan bilangan menara; diberi unsur; Cetak nombor menara", "code": "< ? php function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; } $ house = array ( 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 ) ; $ range = 2 ; $ n = sizeof ( $ house ) / sizeof ( $ house [ 0 ] ) ; echo number_of_tower ( $ house , $ range , $ n ) ; ? >"}
{"text": "Elemen terkecil dalam array yang diulangi tepat kali 'k'. | Program PHP untuk mencari bilangan terkecil dalam array yang diulangi tepat kali 'k'. ; Frekuensi pengkomputeran semua elemen; Mencari elemen terkecil dengan kekerapan sebagai k; Jika kekerapan mana -mana nombor adalah sama dengan k bermula dari 0 maka kembalikan nombor; Kod pemacu", "code": "< ? php $ MAX = 1000 ; function findDuplicate ( $ arr , $ n , $ k ) { global $ MAX ; $ freq = array_fill ( 0 , $ MAX , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < 1 && $ arr [ $ i ] > $ MAX ) { echo \" Out ▁ of ▁ range \" ; return -1 ; } $ freq [ $ arr [ $ i ] ] += 1 ; } for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { if ( $ freq [ $ i ] == $ k ) return $ i ; } return -1 ; } $ arr = array ( 2 , 2 , 1 , 3 , 1 ) ; $ k = 2 ; $ n = count ( $ arr ) ; echo findDuplicate ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Program untuk mencetak array dalam susunan pendulum | Cetak susunan pendulam arr []; menyusun unsur -unsur; Array tambahan untuk menyimpan output; mengira indeks pertengahan; Menyimpan elemen minimum di tengah I ialah indeks untuk array output dan j adalah untuk array input. ; pelarasan untuk apabila tidak. unsur -unsur adalah juga; Mencetak susunan pendulum; Arahan input; mengira panjang array A; Memanggil fungsi pendulum", "code": "< ? php function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr , $ n ) ; sort ( $ arr ) ; $ op [ $ n ] = NULL ; $ mid = floor ( ( $ n - 1 ) / 2 ) ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo \" Pendulum ▁ arrangement : \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ op [ $ i ] , \" ▁ \" ; echo \" STRNEWLINE \" ; } arr = array ( 14 , 6 , 19 , 21 , 12 ) ; $ n = sizeof ( $ arr ) ; pendulumArrangement ( $ arr , $ n ) ; ? >"}
{"text": "Pertanyaan untuk mencari yang terakhir bukan | Watak yang berbeza maksimum mungkin; Untuk menyimpan kekerapan aksara; Fungsi untuk pra - Kirakan pelbagai frekuensi; Hanya watak pertama yang mempunyai kekerapan 1 hingga indeks 0; Bermula dari watak kedua rentetan; Untuk setiap watak yang mungkin; Watak semasa yang dipertimbangkan; Jika ia sama dengan watak pada indeks semasa; Fungsi untuk mengembalikan kekerapan watak yang diberikan dalam sub -string $ str [$ l ... $ r]; Berfungsi untuk mengembalikan watak bukan berulang yang terakhir; Bermula dari watak terakhir; Watak semasa; Jika kekerapan aksara semasa adalah 1 maka kembalikan watak; Semua watak sub -rentetan mengulangi; Kod pemacu; Pra - Kirakan pelbagai kekerapan", "code": "< ? php $ MAX = 256 ; $ freq = array_fill ( 0 , 256 , array_fill ( 0 , 1000 , 0 ) ) ; function preCalculate ( $ str , $ n ) { global $ freq ; global $ MAX ; $ freq [ ord ( $ str [ 0 ] ) ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ ch = $ str [ $ i ] ; for ( $ j = 0 ; $ j < $ MAX ; $ j ++ ) { $ charToUpdate = chr ( $ j ) ; if ( $ charToUpdate == $ ch ) $ freq [ $ j ] [ $ i ] = $ freq [ $ j ] [ $ i - 1 ] + 1 ; else $ freq [ $ j ] [ $ i ] = $ freq [ $ j ] [ $ i - 1 ] ; } } } function getFrequency ( $ ch , $ l , $ r ) { global $ freq ; if ( $ l == 0 ) return $ freq [ ord ( $ ch ) ] [ $ r ] ; else return ( $ freq [ ord ( $ ch ) ] [ $ r ] - $ freq [ ord ( $ ch ) ] [ $ l - 1 ] ) ; } function lastNonRepeating ( $ str , $ n , $ l , $ r ) { for ( $ i = $ r ; $ i >= $ l ; $ i -- ) { $ ch = $ str [ $ i ] ; if ( getFrequency ( $ ch , $ l , $ r ) == 1 ) return $ ch ; } return \" - 1\" ; } $ str = \" GeeksForGeeks \" ; $ n = strlen ( $ str ) ; $ queries = array ( array ( 2 , 9 ) , array ( 2 , 3 ) , array ( 0 , 12 ) ) ; $ q = 3 ; preCalculate ( $ str , $ n ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) { echo ( lastNonRepeating ( $ str , $ n , $ queries [ $ i ] [ 0 ] , $ queries [ $ i ] [ 1 ] ) ) , \" STRNEWLINE \" ; } ? >"}
{"text": "Kos minimum untuk mengubah suai rentetan | Berfungsi untuk mengembalikan kos minimum; Memulakan hasil; Untuk menyimpan kekerapan aksara rentetan array Inisialisasi dengan 0; Kemas kini frekuensi aksara rentetan; Gelung untuk memeriksa semua tingkap dari a - z di mana saiz tetingkap adalah k; Memulakan indeks tetingkap; Mengakhiri indeks tetingkap; Semak sama ada rentetan mengandungi watak; Semak jika watak berada di sebelah kiri tetingkap Cari kos pengubahsuaian untuk watak menambah nilai untuk mengira mengira jarak pengubahsuaian yang terdekat; Semak sama ada watak berada di sebelah kanan tetingkap Cari kos pengubahsuaian untuk watak menambah nilai untuk mengira mengira jarak pengubahsuaian yang terdekat; Cari minimum semua kos untuk mengubah suai rentetan; Gelung untuk memeriksa semua tingkap di sini tetingkap mengandungi aksara sebelum z dan selepas z saiz tetingkap k; Memulakan indeks tetingkap; Mengakhiri indeks tetingkap; Semak sama ada rentetan mengandungi watak; Jika aksara berada di luar tetingkap mencari kos untuk mengubahsuai aksara menambah nilai untuk dikira; Cari minimum semua kos untuk mengubah suai rentetan; Kod pemacu", "code": "< ? php function minCost ( $ str , $ K ) { $ n = strlen ( $ str ) ; $ res = 999999999 ; $ count = 0 ; $ cnt = array_fill ( 0 , 27 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ cnt [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) + 1 ] ++ ; for ( $ i = 1 ; $ i < ( 26 - $ K + 1 ) ; $ i ++ ) { $ a = $ i ; $ b = $ i + $ K ; $ count = 0 ; for ( $ j = 1 ; $ j <= 26 ; $ j ++ ) { if ( $ cnt [ $ j ] > 0 ) { if ( $ j >= $ a && $ j >= $ b ) $ count = $ count + ( min ( $ j - $ b , 25 - $ j + $ a + 1 ) ) * $ cnt [ $ j ] ; else if ( $ j <= $ a && $ j <= $ b ) $ count = $ count + ( min ( $ a - $ j , 25 + $ j - $ b + 1 ) ) * $ cnt [ $ j ] ; } } $ res = min ( $ res , $ count ) ; } for ( $ i = 26 - $ K + 1 ; $ i <= 26 ; $ i ++ ) { $ a = $ i ; $ b = ( $ i + $ K ) % 26 ; $ count = 0 ; for ( $ j = 1 ; $ j <= 26 ; $ j ++ ) { if ( $ cnt [ $ j ] > 0 ) { if ( $ j >= $ b and $ j <= $ a ) $ count = $ count + ( min ( $ j - $ b , $ a - $ j ) ) * $ cnt [ $ j ] ; } } $ res = min ( $ res , $ count ) ; } return $ res ; } $ str = \" abcdefghi \" ; $ K = 2 ; echo minCost ( $ str , $ K ) ; ? >"}
{"text": "Cetak watak terakhir setiap perkataan dalam rentetan | Berfungsi untuk mencetak watak terakhir setiap perkataan dalam rentetan yang diberikan; Sekarang, perkataan terakhir juga diikuti oleh ruang; Jika watak semasa adalah ruang; Kemudian watak sebelumnya mestilah watak terakhir dari beberapa perkataan; Kod pemacu", "code": "< ? php function printLastChar ( $ str ) { $ str = $ str . \" ▁ \" ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ! strcmp ( $ str [ $ i ] , ' ▁ ' ) ) echo ( $ str [ $ i - 1 ] . \" ▁ \" ) ; } } $ str = \" Geeks ▁ for ▁ Geeks \" ; printLastChar ( $ str ) ; ? >"}
{"text": "Panjang maksimum rentetan seimbang selepas bertukar dan penyingkiran aksara | Pelaksanaan PHP fungsi pendekatan untuk mengembalikan panjang sub -rentetan seimbang terpanjang; Untuk menyimpan kiraan kurungan; Melintasi rentetan; Semak jenis kurungan dan kenaikan kiraan untuknya; Jumlah semua sepasang kurungan seimbang; Kod yang didorong", "code": "< ? php function maxBalancedStr ( $ s ) { $ open1 = 0 ; $ close1 = 0 ; $ open2 = 0 ; $ close2 = 0 ; $ open3 = 0 ; $ close3 = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { switch ( $ s [ $ i ] ) { case ' ( ' : $ open1 ++ ; break ; case ' ) ' : $ close1 ++ ; break ; case ' { ' : $ open2 ++ ; break ; case ' } ' : $ close2 ++ ; break ; case ' [ ' : $ open3 ++ ; break ; case ' ] ' : $ close3 ++ ; break ; } } $ maxLen = 2 * min ( $ open1 , $ close1 ) + 2 * min ( $ open2 , $ close2 ) + 2 * min ( $ open3 , $ close3 ) ; return $ maxLen ; } { $ s = \" ) ) [ ] ] ( ( \" ; echo ( maxBalancedStr ( $ s ) ) ; }"}
{"text": "Gantikan semua kejadian rentetan dengan ruang | Berfungsi untuk mengekstrak mesej rahsia; Menggantikan semua kejadian sub di STR oleh ruang kosong; Mengeluarkan ruang yang tidak diingini pada permulaan dan akhir rentetan; Kod pemacu", "code": "< ? php function extractSecretMessage ( $ Str , $ Sub ) { $ Str = str_replace ( $ Sub , \" ▁ \" , $ Str ) ; return trim ( $ Str ) ; } $ Str = \" LIELIEILIEAMLIECOOL \" ; $ Sub = \" LIE \" ; echo extractSecretMessage ( $ Str , $ Sub ) ; ? >"}
{"text": "Carian Binari Rentetan | Pulangan indeks x jika ada di arr [], lain kembali - 1; Semak sama ada X hadir pada pertengahan; Jika x lebih besar, abaikan separuh kiri; Jika x lebih kecil, abaikan separuh kanan; Kod pemacu", "code": "< ? php function binarySearch ( $ arr , $ x ) { $ l = 0 ; $ r = count ( $ arr ) ; while ( $ l <= $ r ) { $ m = $ l + ( int ) ( ( $ r - $ l ) / 2 ) ; $ res = strcmp ( $ x , $ arr [ $ m ] ) ; if ( $ res == 0 ) return $ m - 1 ; if ( $ res > 0 ) $ l = $ m + 1 ; else $ r = $ m - 1 ; } return -1 ; } $ arr = array ( \" contribute \" , \" geeks \" , \" ide \" , \" practice \" ) ; $ x = \" ide \" ; $ result = binarySearch ( $ arr , $ x ) ; if ( $ result == -1 ) print ( \" Element ▁ not ▁ present \" ) ; else print ( \" Element ▁ found ▁ at ▁ index ▁ \" . $ result ) ; ? >"}
{"text": "Pelajar dengan skor purata maksimum tiga subjek | Fungsi untuk mencari senarai pelajar yang mempunyai skor purata maksimum; Pembolehubah untuk menyimpan skor purata pelajar dan skor purata maksimum; Senaraikan untuk menyimpan nama pelajar yang mempunyai skor purata maksimum; Melintasi data fail; mencari skor purata pelajar; Kosongkan senarai dan tambahkan nama pelajar yang mempunyai skor purata maksimum semasa dalam senarai; Mencetak skor purata maksimum dan nama pelajar yang mempunyai skor purata maksimum ini mengikut pesanan dalam fail. ; Kod pemacu; Bilangan elemen dalam array rentetan", "code": "< ? php function getStudentsList ( $ file , $ n ) { $ maxAvgScore = PHP_INT_MIN ; $ names = array ( ) ; $ avgScore = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i += 4 ) { $ avgScore = ( int ) ( ( intval ( $ file [ $ i + 1 ] ) + intval ( $ file [ $ i + 2 ] ) + intval ( $ file [ $ i + 3 ] ) ) / 3 ) ; if ( $ avgScore > $ maxAvgScore ) { $ maxAvgScore = $ avgScore ; unset ( $ names ) ; $ names = array ( ) ; array_push ( $ names , $ file [ $ i ] ) ; } else if ( $ avgScore == $ maxAvgScore ) array_push ( $ names , $ file [ $ i ] ) ; } for ( $ i = 0 ; $ i < count ( $ names ) ; $ i ++ ) { echo $ names [ $ i ] . \" \" ; } echo $ maxAvgScore ; } $ file = array ( \" Shrikanth \" , \"20\" , \"30\" , \"10\" , \" Ram \" , \"100\" , \"50\" , \"10\" ) ; $ n = count ( $ file ) ; getStudentsList ( $ file , $ n ) ; ? >"}
{"text": "Jumlah nilai abjad aksara rentetan | Berfungsi untuk mencari skor rentetan; Kod pemacu", "code": "< ? php function strScore ( $ str , $ s , $ n ) { $ score = 0 ; $ index ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ s ) { for ( $ j = 0 ; $ j < strlen ( $ s ) ; $ j ++ ) $ score += ( ord ( $ s [ $ j ] ) - ord ( ' a ' ) ) + 1 ; $ index = ( $ i + 1 ) ; break ; } } $ score = $ score * $ index ; return $ score ; } $ str = array ( \" sahil \" , \" shashanak \" , \" sanjit \" , \" abhinav \" , \" mohit \" ) ; $ s = \" abhinav \" ; $ n = sizeof ( $ str ) ; $ score = strScore ( $ str , $ s , $ n ) ; echo $ score , \" STRNEWLINE \" ; ? >"}
{"text": "Bilangan minimum tanda kurung yang akan ditambah untuk menjadikannya sah | Berfungsi untuk mengembalikan nombor minimum yang diperlukan; mengekalkan keseimbangan rentetan; Ia dijamin BAL> = - 1; Kod pemacu; Berfungsi untuk mencetak jawapan yang diperlukan", "code": "< ? php function minParentheses ( $ p ) { $ bal = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i < strlen ( $ p ) ; ++ $ i ) { if ( $ p [ $ i ] == ' ( ' ) $ bal += 1 ; else $ bal += -1 ; if ( $ bal == -1 ) { $ ans += 1 ; $ bal += 1 ; } } return $ bal + $ ans ; } $ p = \" ( ) ) \" ; echo minParentheses ( $ p ) ; ? >"}
{"text": "Semak jika akhiran dan awalan rentetan adalah palindromes | Berfungsi untuk memeriksa sama ada rentetan itu adalah palindrome; membalikkan rentetan untuk dibandingkan dengan rentetan asal; Periksa sama ada kedua -duanya sama; Fungsi untuk memeriksa sama ada rentetan mempunyai awalan dan substring akhiran panjang lebih besar daripada 1 yang merupakan palindromes. ; Semak semua substring awalan; Semak sama ada substring awalan adalah palindrome; Sekiranya kita tidak menemui apa -apa awalan palindrome panjang yang lebih besar daripada 1; Semak semua substring akhiran, kerana rentetan dibalikkan sekarang; Semak sama ada substring akhiran adalah palindrome; Jika kita tidak menemui akhiran; Kod pemacu", "code": "< ? php function isPalindrome ( $ r ) { $ p = $ r ; strrev ( $ p ) ; return ( $ r == $ p ) ; } function CheckStr ( $ s ) { $ l = strlen ( $ s ) ; for ( $ i = 2 ; $ i <= $ l ; $ i ++ ) { if ( isPalindrome ( substr ( $ s , 0 , $ i ) ) ) break ; } if ( $ i == ( $ l + 1 ) ) return false ; $ i = 2 ; for ( $ i = 2 ; $ i <= $ l ; $ i ++ ) { if ( isPalindrome ( substr ( $ s , $ l - $ i , $ i ) ) ) return true ; } return false ; } $ s = \" abccbarfgdbd \" ; if ( CheckStr ( $ s ) ) echo ( \" YES STRNEWLINE \" ) ; else echo ( \" NO STRNEWLINE \" ) ; ? >"}
{"text": "Putaran rentetan binari dengan nilai ganjil | fungsi untuk mengira jumlah perpuluhan yang ganjil; Kod pemacu", "code": "< ? php function oddEquivalent ( $ s , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '1' ) $ count ++ ; } return $ count ; } $ s = \"1011011\" ; $ n = strlen ( $ s ) ; echo ( oddEquivalent ( $ s , $ n ) ) ; ? >"}
{"text": "Count of Strings yang boleh dibentuk dari rentetan lain menggunakan setiap aksara di | Fungsi untuk mencari bilangan STR2 yang boleh dibentuk menggunakan watak Str1; melangkah dan menandakan frekuensi semua aksara dalam str1; Cari kekerapan minimum setiap watak dalam Str1; Kod pemacu", "code": "< ? php function findNumberOfTimes ( $ str1 , $ str2 ) { $ freq = array_fill ( 0 , 26 , NULL ) ; $ l1 = strlen ( $ str1 ) ; $ freq2 = array_fill ( 0 , 26 , NULL ) ; $ l2 = strlen ( $ str2 ) ; for ( $ i = 0 ; $ i < $ l1 ; $ i ++ ) $ freq [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] += 1 ; for ( $ i = 0 ; $ i < $ l2 ; $ i ++ ) $ freq2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] += 1 ; $ count = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ l2 ; $ i ++ ) $ count = min ( $ count , $ freq [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] / $ freq2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ) ; return $ count ; } $ str1 = \" foreeksgekseg \" ; $ str2 = \" geeks \" ; echo findNumberOfTimes ( $ str1 , $ str2 ) . \" \" ; ? >"}
{"text": "Transformasi String Menggunakan XOR dan ATAU | fungsi untuk memeriksa sama ada penukaran mungkin atau tidak; Jika panjang berbeza; berulang untuk memeriksa sama ada kedua -dua rentetan mempunyai 1; Untuk memeriksa sama ada terdapat satu 1 dalam rentetan S1; Untuk memeriksa sama ada terdapat satu 1 dalam rentetan S2; Jika kedua -dua rentetan tidak mempunyai '1'. ; Kod pemacu", "code": "< ? php function solve ( $ s1 , $ s2 ) { if ( strlen ( $ s1 ) != strlen ( $ s2 ) ) return false ; $ l = strlen ( $ s1 ) ; for ( $ i = 0 ; $ i < 1 ; $ i ++ ) { if ( $ s1 [ $ i ] == '1' ) $ flag1 = 1 ; if ( $ s2 [ $ i ] == '1' ) $ flag2 = 1 ; if ( ! $ flag1 && ! $ flag2 ) return true ; } return false ; } $ s1 = \"100101\" ; $ s2 = \"100000\" ; if ( solve ( $ s1 , $ s2 ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Substring terpanjang 0 s dalam rentetan yang dibentuk oleh Koncatenations K | Fungsi untuk mengira panjang maksimum substring yang mengandungi hanya sifar; Gelung untuk mengira substring terpanjang dalam rentetan; Jika semua elemen dalam rentetan adalah '0'; Lain, cari saiz awalan dan akhiran yang mengandungi hanya sifar; Hitung awalan yang mengandungi hanya sifar; Hitung akhiran yang mengandungi hanya sifar; jika k <= 1 maka tidak perlu mengambil awalan + akhiran ke dalam akaun; Kod pemacu", "code": "< ? php function subzero ( $ str , $ k ) { $ ans = 0 ; $ curr = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) { if ( $ str [ $ i ] == '0' ) $ curr ++ ; else $ curr = 0 ; $ ans = max ( $ ans , $ curr ) ; } if ( $ ans == $ len ) return $ len * $ k ; else { $ pre = 0 ; $ suff = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) $ pre ++ ; else break ; } for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] == '0' ) $ suff ++ ; else break ; } if ( $ k > 1 ) $ ans = max ( $ ans , $ pre + $ suff ) ; return $ ans ; } } $ str = \"00100110\" ; $ k = 5 ; echo subzero ( $ str , $ k ) ; ? >"}
{"text": "Cari Terma N Dragon Curve Sequence | berfungsi untuk menjana istilah n; istilah pertama; menjana setiap istilah urutan; gelung untuk menjana istilah ith; Tambah watak dari rentetan asal; tambah alternatif 0 dan 1 di antara; Jika istilah tambah sebelumnya adalah '0' maka tambah '1'; Sekarang istilah semasa menjadi istilah sebelumnya; Jika istilah tambah sebelumnya adalah '1', kemudian tambah '0'; Sekarang istilah semasa menjadi istilah sebelumnya; S menjadi istilah ITH urutan; Mengambil input; menjana istilah naga keluk naga; Output percetakan", "code": "< ? php function Dragon_Curve_Sequence ( $ n ) { $ s = \"1\" ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ temp = \"1\" ; $ prev = '1' ; $ zero = '0' ; $ one = '1' ; for ( $ j = 0 ; $ j < strlen ( $ s ) ; $ j ++ ) { $ temp . = $ s [ $ j ] ; if ( $ prev == '0' ) { $ temp . = $ one ; $ prev = $ one ; } else { $ temp . = $ zero ; $ prev = $ zero ; } } $ s = $ temp ; } return $ s ; } $ n = 4 ; $ s = Dragon_Curve_Sequence ( $ n ) ; echo $ s . \" STRNEWLINE \" ; ? >"}
{"text": "Bilangan substrings rentetan | Program PHP untuk mengira bilangan substrings rentetan; Kod pemacu", "code": "< ? php function countNonEmptySubstr ( $ str ) { $ n = strlen ( $ str ) ; return $ n * ( $ n + 1 ) / 2 ; } $ s = \" abcde \" ; echo countNonEmptySubstr ( $ s ) ; ? >"}
{"text": "Semak jika watak satu rentetan boleh ditukar untuk membentuk yang lain | Program PHP untuk memeriksa sama ada watak -watak satu rentetan boleh ditukar untuk membentuk yang lain; Jika panjang tidak sama cetak tidak; Mengira frekuensi watak dalam rentetan pertama. ; melangkah melalui jumlah pengurangan rentetan kedua aksara dalam rentetan kedua; Oleh kerana panjangnya, sesetengah nilai pasti akan menjadi negatif jika hasilnya palsu. ; Kod pemacu", "code": "< ? php $ MAX = 26 ; function targetstring ( $ str1 , $ str2 ) { global $ MAX ; $ l1 = strlen ( $ str1 ) ; $ l2 = strlen ( $ str2 ) ; if ( $ l1 != $ l2 ) return false ; $ map [ $ MAX ] = array ( 0 ) ; for ( $ i = 0 ; $ i < $ l1 ; $ i ++ ) $ map [ $ str1 [ $ i ] - ' a ' ] ++ ; for ( $ i = 0 ; $ i < $ l2 ; $ i ++ ) { $ map [ $ str2 [ $ i ] - ' a ' ] -- ; if ( $ map [ $ str2 [ $ i ] - ' a ' ] < 0 ) return false ; } return true ; } $ str1 = \" geeksforgeeks \" ; $ str2 = \" geegeeksksfor \" ; if ( targetstring ( $ str1 , $ str2 ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Cari nombor yang mengandungi digit d | Pulangan benar jika d hadir sebagai digit dalam nombor x. ; Loop breal jika D hadir sebagai digit; Jika gelung pecah; berfungsi untuk memaparkan nilai; Semak semua nombor satu demi satu; memeriksa digit; Kod pemacu", "code": "< ? php function isDigitPresent ( $ x , $ d ) { while ( $ x > 0 ) { if ( $ x % 10 == $ d ) break ; $ x = $ x / 10 ; } return ( $ x > 0 ) ; } function printNumbers ( $ n , $ d ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( $ i == $ d || isDigitPresent ( $ i , $ d ) ) echo $ i , \" ▁ \" ; } $ n = 47 ; $ d = 7 ; printNumbers ( $ n , $ d ) ; ? >"}
{"text": "Cari satu watak tambahan dalam rentetan | Program PHP untuk mencari watak tambahan dalam satu rentetan; hasil menyimpan hasilnya; melintasi rentetan sehingga hujung dan xor dengan res; xor dengan res; Traverse String b hingga akhir dan xor dengan res; xor dengan res; Hasil cetak pada akhir; Diberi rentetan", "code": "< ? php function findExtraCharcter ( $ strA , $ strB ) { $ res = 0 ; for ( $ i = 0 ; $ i < strlen ( $ strA ) ; $ i ++ ) { $ res ^= ord ( $ strA [ $ i ] ) ; } for ( $ i = 0 ; $ i < strlen ( $ strB ) ; $ i ++ ) { $ res ^= ord ( $ strB [ $ i ] ) ; } return $ res ; } $ strA = \" abcd \" ; $ strB = \" cbdad \" ; echo chr ( findExtraCharcter ( $ strA , $ strB ) ) ; ? >"}
{"text": "Menilai ungkapan array dengan nombor, + dan | Fungsi untuk mencari jumlah array yang diberikan; Jika rentetan kosong; Fungsi Stoi untuk menukar rentetan menjadi integer; Cast untuk menukar rentetan menjadi integer; Cari pengendali; Jika pengendali adalah sama dengan ' +', tambahkan nilai dalam jumlah pembolehubah lain tolak; Kod pemacu", "code": "< ? php function calculateSum ( $ arr , $ n ) { if ( $ n == 0 ) return 0 ; $ s = $ arr [ 0 ] ; $ value = ( int ) $ s ; $ sum = $ value ; for ( $ i = 2 ; $ i < $ n ; $ i = $ i + 2 ) { $ s = $ arr [ $ i ] ; $ value = ( int ) $ s ; $ operation = $ arr [ $ i - 1 ] ; if ( $ operation == ' + ' ) $ sum += $ value ; else if ( $ operation == ' - ' ) $ sum -= $ value ; } return $ sum ; } $ arr = array ( \"3\" , \" + \" , \"4\" , \" - \" , \"7\" , \" + \" , \"13\" ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo calculateSum ( $ arr , $ n ) ; ? >"}
{"text": "String dengan bilangan maksimum aksara unik | Berfungsi untuk mencari rentetan dengan bilangan maksimum aksara unik; Indeks rentetan dengan aksara unik maksimum; melangkah melalui semua rentetan; array yang menunjukkan mana -mana abjad yang disertakan atau tidak termasuk; kiraan bilangan huruf unik dalam setiap rentetan; menjejaki bilangan abjad maksimum; hasil cetak; Kod pemacu", "code": "< ? php function LargestString ( $ na ) { $ N = sizeof ( $ na ) ; $ c = array_fill ( 0 , $ N , 0 ) ; $ m = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ character = array_fill ( 0 , 26 , false ) ; for ( $ k = 0 ; $ k < strlen ( $ na [ $ j ] ) ; $ k ++ ) { $ x = ord ( $ na [ $ j ] [ $ k ] ) - 65 ; if ( ( $ na [ $ j ] [ $ k ] != ' ▁ ' ) && ( $ character [ $ x ] == false ) ) { $ c [ $ j ] ++ ; $ character [ $ x ] = true ; } } if ( $ c [ $ j ] > $ c [ $ m ] ) $ m = $ j ; } echo $ na [ $ m ] . \" STRNEWLINE \" ; } $ na = array ( \" BOB \" , \" A ▁ AB ▁ C ▁ JOHNSON \" , \" ASKRIT \" , \" ARMAN ▁ MALLIK \" , \" ANJALI \" ) ; LargestString ( $ na ) ; ? >"}
{"text": "Pelaksanaan Kod Morse | berfungsi untuk mengekod abjad sebagai kod Morse; Rujuk kepada imej jadual Morse yang dilampirkan dalam artikel; untuk ruang; Watak oleh watak cetak morse kod; Kod pemacu", "code": "< ? php function morseEncode ( $ x ) { switch ( $ x ) { case ' a ' : return \" . - \" ; case ' b ' : return \" - . . . \" ; case ' c ' : return \" - . - . \" ; case ' d ' : return \" - . . \" ; case ' e ' : return \" . \" ; case ' f ' : return \" . . - . \" ; case ' g ' : return \" - - . \" ; case ' h ' : return \" . . . . \" ; case ' i ' : return \" . . \" ; case ' j ' : return \" . - - - \" ; case ' k ' : return \" - . - \" ; case ' l ' : return \" . - . . \" ; case ' m ' : return \" - - \" ; case ' n ' : return \" - . \" ; case ' o ' : return \" - - - \" ; case ' p ' : return \" . - - . \" ; case ' q ' : return \" - - . - \" ; case ' r ' : return \" . - . \" ; case ' s ' : return \" . . . \" ; case ' t ' : return \" - \" ; case ' u ' : return \" . . - \" ; case ' v ' : return \" . . . - \" ; case ' w ' : return \" . - - \" ; case ' x ' : return \" - . . - \" ; case ' y ' : return \" - . - - \" ; case ' z ' : return \" - - . . \" ; case '1' : return \" . - - - - \" ; case '2' : return \" . . - - - \" ; case '3' : return \" . . . - - \" ; case '4' : return \" . . . . - \" ; case '5' : return \" . . . . . \" ; case '6' : return \" - . . . . \" ; case '7' : return \" - - . . . \" ; case '8' : return \" - - - . . \" ; case '9' : return \" - - - - . \" ; case '0' : return \" - - - - - \" ; } } function morseCode ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) echo morseEncode ( $ s [ $ i ] ) ; echo \" STRNEWLINE \" ; } $ s = \" geeksforgeeks \" ; morseCode ( $ s ) ; ? >"}
{"text": "Polybius Square Cipher | berfungsi untuk memaparkan teks cipher polybius; Tukar setiap aksara ke kod yang disulitkan; mencari baris meja; mencari lajur jadual; jika watak adalah 'k'; jika watak lebih besar daripada 'j'; Kod pemacu; Cetak cipher \"Geeksforgeeks", "code": "< ? php function polybiusCipher ( $ s ) { $ row = 0 ; $ col = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ row = floor ( ( ord ( $ s [ $ i ] ) - ord ( ' a ' ) ) / 5 ) + 1 ; $ col = ( ( ord ( $ s [ $ i ] ) - ord ( ' a ' ) ) % 5 ) + 1 ; if ( $ s [ $ i ] == ' k ' ) { $ row = $ row - 1 ; $ col = 5 - $ col + 1 ; } else if ( $ s [ $ i ] >= ' j ' ) { if ( $ col == 1 ) { $ col = 6 ; $ row = $ row - 1 ; } $ col = $ col - 1 ; } echo ( $ row . $ col ) ; } echo ( \" STRNEWLINE \" ) ; } $ s = \" geeksforgeeks \" ; polybiusCipher ( $ s ) ; ? >"}
{"text": "Pembuangan minimum untuk membuat permutasi palindrome | berfungsi untuk mencari penyingkiran minimum aksara; Hash untuk menyimpan kekerapan setiap aksara dan menetapkan array hash ke sifar; Mengira kekerapan setiap aksara; Hitung aksara frekuensi ganjil; jika kiraan adalah - 1 pulangan 0 jika tidak, kiraan balik; Kod pemacu", "code": "< ? php function minRemoval ( $ str ) { $ hash = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ hash [ ord ( $ str [ $ i ] ) - 97 ] ++ ; $ count = 0 ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( $ hash [ $ i ] % 2 ) $ count ++ ; return ( $ count == 0 ) ? 0 : $ count - 1 ; } $ str = \" geeksforgeeks \" ; echo minRemoval ( $ str ) . \" STRNEWLINE \" ; ? >"}
{"text": "Susunan yang paling lama tidak lama lagi | berfungsi untuk mengira panjang berikutnya yang paling lama tidak lama lagi; Kes 1: Jika rentetan sama; untuk kes 2 dan kes 3; rentetan input", "code": "< ? php function findLUSlength ( $ a , $ b ) { if ( ! strcmp ( $ a , $ b ) ) return 0 ; return max ( strlen ( $ a ) , strlen ( $ b ) ) ; } $ a = \" abcdabcd \" ; $ b = \" abcabc \" ; echo ( findLUSlength ( $ a , $ b ) ) ; ? >"}
{"text": "Menukar bahagian pertama dan kedua rentetan | Berfungsi untuk menggabungkan dua bahagian yang berbeza dari rentetan yang diberikan; Membuat rentetan baru dengan bertukar separuh pertama A dan B. ; Kod pemacu; Fungsi panggilan", "code": "< ? php function swapTwoHalves ( $ a , $ b ) { $ la = strlen ( $ a ) ; $ lb = strlen ( $ b ) ; $ c = substr ( $ a , 0 , intval ( $ la / 2 ) ) . substr ( $ b , intval ( $ lb / 2 ) , $ lb ) ; $ d = substr ( $ b , 0 , intval ( $ lb / 2 ) ) . substr ( $ a , intval ( $ la / 2 ) , $ la ) ; echo ( $ c . \" \" ▁ . ▁ $ d ▁ . ▁ \" \" } $ a = \" remuneration \" ; $ b = \" day \" ; swapTwoHalves ( $ a , $ b ) ; ? >"}
{"text": "Sub terpanjang | Pelaksanaan PHP untuk mencari panjang sub $ terpanjang yang mempunyai kekerapan setiap aksara kurang daripada sama dengan k; fungsi untuk mencari panjang sub terpanjang $ mempunyai kekerapan setiap aksara kurang daripada sama dengan k; Jadual hash untuk menyimpan kekerapan setiap jadual; 'Mula' indeks substring semasa; untuk menyimpan panjang maksimum; melintasi $ 'str'; Dapatkan watak semasa sebagai 'ch'; meningkatkan kekerapan 'ch' dalam 'freq []'; jika kekerapan 'ch' menjadi lebih daripada 'k'; Kemas kini 'Maxlen'; Kurangkan kekerapan setiap watak kerana mereka ditemui dari indeks 'mula' sehingga kekerapan 'ch' lebih besar daripada 'k'; kekerapan pengurangan oleh '1'; kenaikan 'permulaan'; Kemas kini Maxlen; panjang yang diperlukan; Kod pemacu", "code": "< ? php $ SIZE = 26 ; function longSubstring ( $ str , $ k ) { global $ SIZE ; $ freq = array ( ) ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) $ freq [ $ i ] = 0 ; $ start = 0 ; $ maxLen = 0 ; $ ch = ' ' $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ ch = $ str [ $ i ] ; $ freq [ ord ( $ ch ) - ord ( ' a ' ) ] ++ ; if ( $ freq [ ord ( $ ch ) - ord ( ' a ' ) ] > $ k ) { if ( $ maxLen < ( $ i - $ start ) ) $ maxLen = $ i - $ start ; while ( $ freq [ ord ( $ ch ) - ord ( ' a ' ) ] > $ k ) { $ freq [ ord ( $ str [ $ start ] ) - ord ( ' a ' ) ] -- ; $ start ++ ; } } } if ( $ maxLen < ( $ n - $ start ) ) $ maxLen = $ n - $ start ; return $ maxLen ; } $ str = \" babcaag \" ; $ k = 1 ; echo ( \" Length ▁ = ▁ \" . longSubstring ( $ str , $ k ) ) ; ? >"}
{"text": "Indeks ajaib dalam array | Fungsi untuk mengira bilangan indeks ajaib. ; Array untuk menyimpan nod induk traversal. ; Array untuk menentukan sama ada nod semasa sudah dikira dalam kitaran. ; Memulakan array. ; Semak jika nod semasa sudah dilalui atau tidak. Jika nod tidak dilalui, maka nilai induk akan - 1 .; Melintasi graf sehingga nod yang sudah dilawati tidak dijumpai. ; Semak nilai induk untuk memastikan kitaran hadir. ; Kira bilangan nod dalam kitaran. ; Kod pemacu", "code": "< ? php function solve ( $ A , $ n ) { $ i = 0 ; $ cnt = 0 ; $ j = 0 ; $ parent = array ( ) ; $ vis = array ( ) ; for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) { $ parent [ $ i ] = -1 ; $ vis [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j = $ i ; if ( $ parent [ $ j ] == -1 ) { while ( $ parent [ $ j ] == -1 ) { $ parent [ $ j ] = $ i ; $ j = ( $ j + $ A [ $ j ] + 1 ) % $ n ; } if ( $ parent [ $ j ] == $ i ) { while ( $ vis [ $ j ] == 0 ) { $ vis [ $ j ] = 1 ; $ cnt ++ ; $ j = ( $ j + $ A [ $ j ] + 1 ) % $ n ; } } } } return $ cnt ; } $ A = array ( 0 , 0 , 0 , 2 ) ; $ n = count ( $ A ) ; echo ( solve ( $ A , $ n ) ) ; ? >"}
{"text": "Tug of War | penyelesaian dengan memanggil sendiri secara rekursif; memeriksa sama ada ia akan terikat; Memeriksa bahawa bilangan elemen yang tersisa tidak kurang daripada bilangan elemen yang diperlukan untuk membentuk penyelesaian; Pertimbangkan kes apabila elemen semasa tidak termasuk dalam penyelesaian; Tambah elemen semasa ke penyelesaian; cek jika penyelesaian terbentuk; cek jika penyelesaian yang terbentuk adalah lebih baik daripada penyelesaian terbaik setakat ini; Pertimbangkan kes di mana elemen semasa dimasukkan ke dalam penyelesaian; membuang elemen semasa sebelum kembali ke pemanggil fungsi ini; fungsi utama yang menjana ARR; Arahan Boolean yang mengandungi kemasukan dan pengecualian elemen dalam set semasa. Nombor yang dikecualikan secara automatik membentuk set lain; Pelbagai inklusi / pengecualian untuk penyelesaian akhir; Cari penyelesaian menggunakan fungsi rekursif towutil (); Cetak penyelesaian; Kod pemacu", "code": "< ? php function TOWUtil ( & $ arr , $ n , & $ curr_elements , $ no_of_selected_elements , & $ soln , & $ min_diff , $ sum , $ curr_sum , $ curr_position ) { if ( $ curr_position == $ n ) return ; if ( ( intval ( $ n / 2 ) - $ no_of_selected_elements ) > ( $ n - $ curr_position ) ) return ; TOWUtil ( $ arr , $ n , $ curr_elements , $ no_of_selected_elements , $ soln , $ min_diff , $ sum , $ curr_sum , $ curr_position + 1 ) ; $ no_of_selected_elements ++ ; $ curr_sum = ( $ curr_sum + $ arr [ $ curr_position ] ) ; $ curr_elements [ $ curr_position ] = true ; if ( $ no_of_selected_elements == intval ( $ n / 2 ) ) { if ( abs ( intval ( $ sum / 2 ) - $ curr_sum ) < $ min_diff ) { $ min_diff = abs ( intval ( $ sum / 2 ) - $ curr_sum ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ soln [ $ i ] = $ curr_elements [ $ i ] ; } } else { TOWUtil ( $ arr , $ n , $ curr_elements , $ no_of_selected_elements , $ soln , $ min_diff , $ sum , $ curr_sum , $ curr_position + 1 ) ; } $ curr_elements [ $ curr_position ] = false ; } function tugOfWar ( & $ arr , $ n ) { $ curr_elements = array_fill ( 0 , $ n , 0 ) ; $ soln = array_fill ( 0 , $ n , 0 ) ; $ min_diff = PHP_INT_MAX ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ curr_elements [ $ i ] = $ soln [ $ i ] = false ; } TOWUtil ( $ arr , $ n , $ curr_elements , 0 , $ soln , $ min_diff , $ sum , 0 , 0 ) ; echo \" The ▁ first ▁ subset ▁ is : ▁ \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ soln [ $ i ] == true ) echo $ arr [ $ i ] . \" ▁ \" ; } echo \" The second subset is : \" for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ soln [ $ i ] == false ) echo $ arr [ $ i ] . \" ▁ \" ; } } $ arr = array ( 23 , 45 , -34 , 12 , 0 , 98 , -99 , 4 , 189 , -1 , 4 ) ; $ n = count ( $ arr ) ; tugOfWar ( $ arr , $ n ) ; ? >"}
{"text": "Panjang sub terkecil | Program PHP untuk mencari panjang substring terkecil yang terdiri daripada aksara maksimum yang berbeza; Cari aksara maksimum yang berbeza dalam mana -mana rentetan; Memulakan semua kiraan watak dengan 0; Meningkatkan kiraan dalam array jika watak dijumpai; saiz rentetan yang diberikan; Cari aksara maksimum yang berbeza dalam mana -mana rentetan; hasil; Pendekatan kekerasan untuk mencari semua substring; Kita perlu menyemak di sini kedua -dua keadaan bersama -sama 1. Panjang Substring hendaklah minimum; Rentetan input", "code": "< ? php $ NO_OF_CHARS = 256 ; function max_distinct_char ( $ str , $ n ) { global $ NO_OF_CHARS ; $ count = array_fill ( 0 , $ NO_OF_CHARS , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) ] ++ ; $ max_distinct = 0 ; for ( $ i = 0 ; $ i < $ NO_OF_CHARS ; $ i ++ ) if ( $ count [ $ i ] != 0 ) $ max_distinct ++ ; return $ max_distinct ; } function smallesteSubstr_maxDistictChar ( $ str ) { $ n = strlen ( $ str ) ; $ max_distinct = max_distinct_char ( $ str , $ n ) ; $ minl = $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ subs = substr ( $ str , $ i , $ j ) ; $ subs_lenght = strlen ( $ subs ) ; $ sub_distinct_char = max_distinct_char ( $ subs , $ subs_lenght ) ; if ( $ subs_lenght < $ minl && $ max_distinct == $ sub_distinct_char ) { $ minl = $ subs_lenght ; } } } return $ minl ; } $ str = \" AABBBCBB \" ; $ len = smallesteSubstr_maxDistictChar ( $ str ) ; echo \" ▁ The ▁ length ▁ of ▁ the ▁ smallest ▁ substring \" . \" ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ characters ▁ : ▁ \" . $ len ; ? >"}
{"text": "Bilangan substrings dalam rentetan digit | Kembalikan substring nombor juga. ; Sekiranya digit semasa, tambah kiraan substrings yang berakhir dengannya. Kiraannya ialah (i + 1); Kod pemacu", "code": "< ? php function evenNumSubstring ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ temp = $ str [ $ i ] - '0' ; if ( $ temp % 2 == 0 ) $ count += ( $ i + 1 ) ; } return $ count ; } $ str = \"1234\" ; echo evenNumSubstring ( $ str ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari indeks sedemikian rupa sehingga perbezaan antara produk elemen sebelum dan selepas ia adalah minimum | Berfungsi untuk mengembalikan indeks saya supaya perbezaan mutlak antara produk unsur -unsur sehingga indeks itu dan produk sisa unsur -unsur array adalah minimum; Untuk menyimpan indeks yang diperlukan; Arahan produk awalan; Kirakan pelbagai produk; Melelehkan pelbagai produk untuk mencari indeks; Kod pemacu", "code": "< ? php function findIndex ( $ a , $ n ) { $ min_diff = PHP_INT_MAX ; $ prod = array ( ) ; $ prod [ 0 ] = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ prod [ $ i ] = $ prod [ $ i - 1 ] * $ a [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ curr_diff = abs ( ( $ prod [ $ n - 1 ] / $ prod [ $ i ] ) - $ prod [ $ i ] ) ; if ( $ curr_diff < $ min_diff ) { $ min_diff = $ curr_diff ; $ res = $ i ; } } return $ res ; } $ arr = array ( 3 , 2 , 5 , 7 , 2 , 9 ) ; $ N = count ( $ arr ) ; echo findIndex ( $ arr , $ N ) ; ? >"}
{"text": "Cetak semua nombor yang set faktor utama adalah subset dari set faktor utama x | Berfungsi untuk mencetak semua nombor; Berulang untuk setiap elemen dalam array; Cari GCD; Iterat sehingga GCD adalah 1 dari nombor dan x; Bahagikan nombor dengan GCD; Cari GCDG baru; Jika nombor adalah 1 pada akhir kemudian cetak nombor; Sekiranya tiada nombor di sana; Kod pemacu", "code": "< ? php function printNumbers ( $ a , $ n , $ x ) { $ flag = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ num = $ a [ $ i ] ; $ g = __gcd ( $ num , $ x ) ; while ( $ g != 1 ) { $ num /= $ g ; $ g = __gcd ( $ num , $ x ) ; } if ( $ num == 1 ) { $ flag = true ; echo $ a [ $ i ] , \" \" ; } } if ( ! $ flag ) echo ( \" There ▁ are ▁ no ▁ such ▁ numbers \" ) ; } function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } $ x = 60 ; $ a = array ( 2 , 5 , 10 , 7 , 17 ) ; $ n = count ( $ a ) ; printNumbers ( $ a , $ n , $ x ) ; ? >"}
{"text": "Cari Radiasi Akhir setiap stesen yang dipancarkan | Berfungsi untuk mencetak radiasi akhir; Berfungsi untuk membuat pelbagai radiasi yang dihasilkan; Radiasi yang dihasilkan; Mengisytiharkan kaunter indeks untuk radiasi kiri dan kanan; Radiasi yang berkesan untuk kes kiri dan kanan; Radiasi untuk stesen i - th; Kenaikan radiasi untuk stesen kiri; Kenaikan radiasi untuk stesen kanan; Cetak radiasi yang dihasilkan untuk setiap stesen; 1 - Pengindeksan berasaskan", "code": "< ? php function print_radiation ( $ rStation , $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo $ rStation [ $ i ] . \" \" ; } echo \" STRNEWLINE \" ; } function radiated_Station ( $ station , $ n ) { $ rStation = array ( ) ; $ rStation = array_fill ( 0 , $ n + 1 , 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ li = $ i - 1 ; $ ri = $ i + 1 ; $ lRad = $ station [ $ i ] - 1 ; $ rRad = $ station [ $ i ] - 1 ; $ rStation [ $ i ] += $ station [ $ i ] ; while ( $ li >= 1 && $ lRad >= 1 ) { $ rStation [ $ li -- ] += $ lRad -- ; } while ( $ ri <= $ n && $ rRad >= 1 ) { $ rStation [ $ ri ++ ] += $ rRad -- ; } } print_radiation ( $ rStation , $ n ) ; } $ station = array ( 0 , 7 , 9 , 12 , 2 , 5 ) ; $ n = ( sizeof ( $ station ) / sizeof ( $ station [ 0 ] ) ) - 1 ; radiated_Station ( $ station , $ n ) ; ? >"}
{"text": "Program untuk mencari perbezaan maksimum antara indeks mana -mana dua nombor yang berbeza | Berfungsi untuk mengembalikan perbezaan maksimum; Periksa dari belakang; Nombor yang berbeza; Periksa secara beransur -ansur dari awal; Nombor yang berbeza; Kod pemacu", "code": "< ? php function findMaximumDiff ( $ a , $ n ) { $ ind1 = 0 ; for ( $ i = $ n - 1 ; $ i > 0 ; $ i -- ) { if ( $ a [ 0 ] != $ a [ $ i ] ) { $ ind1 = $ i ; break ; } } $ ind2 = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ a [ $ n - 1 ] != $ a [ $ i ] ) { $ ind2 = ( $ n - 1 - $ i ) ; break ; } } return max ( $ ind1 , $ ind2 ) ; } $ a = array ( 1 , 2 , 3 , 2 , 3 ) ; $ n = count ( $ a ) ; echo findMaximumDiff ( $ a , $ n ) ; ? >"}
{"text": "Jumlah siri KN + (k (n | berfungsi untuk mengembalikan jumlah; kod pemacu", "code": "< ? php function sum ( $ k , $ n ) { $ sum = pow ( $ k , $ n + 1 ) - pow ( $ k - 1 , $ n + 1 ) ; return $ sum ; } $ n = 3 ; $ K = 3 ; echo sum ( $ K , $ n ) ;"}
{"text": "Semak sama ada faktorial n boleh dibahagikan dengan jumlah nombor semulajadi n pertama | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak. ; Mengira pembolehubah untuk menyimpan bilangan faktor 'num'; Mengira bilangan faktor; Jika nombor adalah pulangan utama benar; Berfungsi untuk memeriksa kebolehpasaran; jika 'n' sama dengan 1 maka pembahagian adalah mungkin; Lain periksa sama ada 'n + 1' adalah perdana atau tidak; Jika 'n + 1' adalah perdana maka 'n! 'tidak boleh dibahagikan dengan' n * (n + 1) / 2 '; Lain -lain pembahagian berlaku; Ujian untuk n = 3; Ujian untuk n = 4", "code": "< ? php function is_prime ( $ num ) { $ count1 = 0 ; for ( $ i = 1 ; $ i * $ i <= ( $ num ) ; $ i ++ ) { if ( ( $ num ) % $ i == 0 ) { if ( $ i * $ i != ( $ num ) ) $ count1 += 2 ; else $ count1 ++ ; } } if ( $ count1 == 2 ) return true ; else return false ; } function is_divisible ( $ n ) { if ( $ n == 1 ) { return \" YES \" ; } else { if ( is_prime ( $ n + 1 ) ) return \" NO \" ; else return \" YES \" ; } } $ n = 3 ; echo is_divisible ( $ n ) . \" STRNEWLINE \" ; $ n = 4 ; echo is_divisible ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Memandangkan dua rentetan binari melakukan operasi sehingga b> ​​0 dan cetak hasilnya | Pelaksanaan PHP pendekatan; Fungsi untuk mengembalikan hasil yang diperlukan; Membalikkan rentetan; Kira bilangan bit set dalam B; Untuk menyimpan kuasa 2; kuasa [i] = pow (2, i) % mod; Untuk menyimpan jawapan terakhir; Tambah kuasa [i] ke ANS selepas mengalikannya dengan bilangan bit yang ditetapkan dalam b; Bahagikan dengan 2 bermakna peralihan kanan b >> 1 jika b mempunyai 1 di sebelah kanan yang paling banyak daripada bilangan bit yang ditetapkan akan berkurangan; Jika tidak ada lagi bit yang ditetapkan dalam b i. e. B = 0; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "< ? php $ GLOBALS [ ' mod ' ] = ( 1e9 + 7 ) ; function BitOperations ( $ a , $ n , $ b , $ m ) { $ a = strrev ( $ a ) ; $ b = strrev ( $ b ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ b [ $ i ] == '1' ) $ c ++ ; $ power = array ( ) ; $ power [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ power [ $ i ] = ( $ power [ $ i - 1 ] * 2 ) % $ GLOBALS [ ' mod ' ] ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == '1' ) { $ ans += $ c * $ power [ $ i ] ; if ( $ ans >= $ GLOBALS [ ' mod ' ] ) $ ans %= $ GLOBALS [ ' mod ' ] ; } if ( $ b [ $ i ] == '1' ) $ c -- ; if ( $ c == 0 ) break ; } return $ ans ; } $ a = \"1001\" ; $ b = \"10101\" ; $ n = strlen ( $ a ) ; $ m = strlen ( $ b ) ; echo BitOperations ( $ a , $ n , $ b , $ m ) ; ? >"}
{"text": "Cetak nombor utama dengan jumlah utama digit dalam array | Berfungsi untuk menyimpan prima; Berfungsi untuk mengembalikan jumlah digit; Berfungsi untuk mencetak prima bahan tambahan; Jika nombor itu adalah perdana; Semak jika jumlah digitnya adalah perdana; Kod pemacu", "code": "< ? php function sieve ( $ maxEle , & $ prime ) { $ prime [ 0 ] = $ prime [ 1 ] = 1 ; for ( $ i = 2 ; $ i * $ i <= $ maxEle ; $ i ++ ) { if ( ! $ prime [ $ i ] ) { for ( $ j = 2 * $ i ; $ j <= $ maxEle ; $ j += $ i ) $ prime [ $ j ] = 1 ; } } } function digitSum ( $ n ) { $ sum = 0 ; while ( $ n ) { $ sum += $ n % 10 ; $ n = $ n / 10 ; } return $ sum ; } function printAdditivePrime ( $ arr , $ n ) { $ maxEle = max ( $ arr ) ; $ prime = array_fill ( 0 , $ maxEle + 1 , 0 ) ; sieve ( $ maxEle , $ prime ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ prime [ $ arr [ $ i ] ] == 0 ) { $ sum = digitSum ( $ arr [ $ i ] ) ; if ( $ prime [ $ sum ] == 0 ) print ( $ arr [ $ i ] . \" ▁ \" ) ; } } } $ a = array ( 2 , 4 , 6 , 11 , 12 , 18 , 7 ) ; $ n = count ( $ a ) ; printAdditivePrime ( $ a , $ n ) ; ? >"}
{"text": "Program untuk mencari istilah n Siri 1 4 15 24 45 60 92 | fungsi untuk mengira istilah ke siri; Variabel nth akan menyimpan istilah siri nth; jika n juga; jika n adalah ganjil; kembali istilah n; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { $ nth ; if ( $ n % 2 == 0 ) $ nth = 2 * ( ( $ n * $ n ) - $ n ) ; else $ nth = ( 2 * $ n * $ n ) - $ n ; return $ nth ; } $ n = 5 ; echo nthTerm ( $ n ) , \" STRNEWLINE \" ; $ n = 25 ; echo nthTerm ( $ n ) , \" STRNEWLINE \" ; $ n = 25000000 ; echo nthTerm ( $ n ) , \" STRNEWLINE \" ; $ n = 250000007 ; echo nthTerm ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari istilah n Siri 9, 45, 243, 1377 | Berfungsi untuk mengembalikan istilah ke siri yang diberikan; istilah siri yang diberikan; Kod pemacu", "code": "< ? php function nthterm ( $ n ) { $ An = ( pow ( 1 , $ n ) + pow ( 2 , $ n ) ) * pow ( 3 , $ n ) ; return $ An ; } $ n = 3 ; echo nthterm ( $ n ) ; ? >"}
{"text": "Kira nombor <n yang mempunyai bilangan pembahagi yang sama sebagai k | Berfungsi untuk mengembalikan kiraan pembahagi nombor; Kira bilangan 2 s yang membahagikan n; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen; Sementara saya membahagikan n; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama> 2; Hitung jumlah elemen yang mempunyai pembahagi sama persis dengan K 's; Tidak termasuk k dari hasilnya jika ia lebih kecil daripada n. ; Kod pemacu", "code": "< ? php function countDivisors ( $ n ) { $ x = 0 ; $ ans = 1 ; while ( $ n % 2 == 0 ) { $ x ++ ; $ n = $ n / 2 ; } $ ans = $ ans * ( $ x + 1 ) ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { $ x = 0 ; while ( $ n % $ i == 0 ) { $ x ++ ; $ n = $ n / $ i ; } $ ans = $ ans * ( $ x + 1 ) ; } if ( $ n > 2 ) $ ans = $ ans * 2 ; return $ ans ; } function getTotalCount ( $ n , $ k ) { $ k_count = countDivisors ( $ k ) ; $ count = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ k_count == countDivisors ( $ i ) ) $ count ++ ; if ( $ k < $ n ) $ count = $ count - 1 ; return $ count ; } $ n = 500 ; $ k = 6 ; echo getTotalCount ( $ n , $ k ) ; #This  code is contributed by Sachin.. NEW_LINE ? >"}
{"text": "Cari istilah n Siri 0, 8, 64, 216, 512 ,. . . | Berfungsi untuk mengembalikan istilah ke siri yang diberikan; Perbezaan umum; Istilah pertama; istilah n; istilah siri yang diberikan; Kod pemacu", "code": "< ? php function term ( $ n ) { $ d = 2 ; $ a1 = 0 ; $ An = $ a1 + ( $ n - 1 ) * $ d ; return pow ( $ An , 3 ) ; } $ n = 5 ; echo term ( $ n ) ; ? >"}
{"text": "Kira bilangan selang di mana nilai yang diberikan terletak | Program PHP untuk mengira bilangan selang di mana nilai tertentu terletak; Fungsi untuk mengira bilangan selang di mana nilai tertentu terletak; Pembolehubah untuk menyimpan minimum dan maksimum selang; Pembolehubah untuk menyimpan permulaan dan akhir selang; Arahan kekerapan untuk menjejaki berapa selang yang diberikan sebagai elemen terletak pada; Membina pelbagai frekuensi; Kod pemacu; panjang array", "code": "< ? php $ MAX_VAL = 200000 ; function countIntervals ( $ arr , $ V , $ N ) { global $ MAX_VAL ; $ min = PHP_INT_MAX ; $ max = 0 ; $ li = 0 ; $ ri = 0 ; $ freq = array_fill ( 0 , $ MAX_VAL , 0 ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ li = $ arr [ $ i ] [ 0 ] ; $ freq [ $ li ] = $ freq [ $ li ] + 1 ; $ ri = $ arr [ $ i ] [ 1 ] ; $ freq [ $ ri + 1 ] = $ freq [ $ ri + 1 ] - 1 ; if ( $ li < $ min ) $ min = $ li ; if ( $ ri > $ max ) $ max = $ ri ; } for ( $ i = $ min ; $ i <= $ max ; $ i ++ ) $ freq [ $ i ] = $ freq [ $ i ] + $ freq [ $ i - 1 ] ; return $ freq [ $ V ] ; } $ arr = array ( array ( 1 , 10 ) , array ( 5 , 10 ) , array ( 15 , 25 ) , array ( 7 , 12 ) , array ( 20 , 25 ) ) ; $ V = 7 ; $ N = count ( $ arr ) ; echo ( countIntervals ( $ arr , $ V , $ N ) ) ; ? >"}
{"text": "Split n ^ 2 nombor ke dalam kumpulan N yang sama jumlah | Berfungsi untuk mencetak kumpulan n jumlah yang sama; Tidak. kumpulan; N / 2 pasang; Kod pemacu", "code": "< ? php function printGroups ( $ n ) { $ x = 1 ; $ y = $ n * $ n ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n / 2 ; $ j ++ ) { echo \" { \" ▁ , ▁ $ x ▁ , ▁ \" , \" ▁ , ▁ $ y ▁ , ▁ \" } \" $ x ++ ; $ y -- ; } echo \" STRNEWLINE \" ; } } $ n = 4 ; printGroups ( $ n ) ; ? >"}
{"text": "Program untuk mencari titik rehat walaupun | Fungsi untuk mengira titik pecah walaupun; Mengira bilangan artikel yang akan dijual; Kod pemacu", "code": "< ? php function breakEvenPoint ( $ exp , $ S , $ M ) { $ earn = $ S - $ M ; $ res = ceil ( $ exp / $ earn ) ; return $ res ; } $ exp = 3550 ; $ S = 90 ; $ M = 65 ; echo breakEvenPoint ( $ exp , $ S , $ M ) ; ? >"}
{"text": "Kurangkan nilai n dengan menggunakan operasi yang diberikan | berfungsi untuk mengembalikan produk faktor utama yang berbeza bagi nombor; Cari Perdana yang berbeza; Kod pemacu", "code": "< ? php function minimum ( $ n ) { $ product = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { while ( $ n % $ i == 0 ) $ n = $ n / $ i ; $ product = $ product * $ i ; } } if ( $ n >= 2 ) $ product = $ product * $ n ; return $ product ; } $ n = 20 ; echo minimum ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "N digit nombor dibahagikan dengan 5 yang dibentuk dari digit M | Berfungsi untuk mencari kiraan semua nombor digit yang mungkin dibahagikan dengan 5 yang dibentuk dari digit M; Jika tidak mungkin untuk membentuk nombor digit dari digit M yang diberikan tanpa pengulangan; Jika kedua -dua sifar dan lima wujud; Baki n - 1 lelaran; Baki n - 1 lelaran; Kod pemacu", "code": "< ? php function numbers ( $ n , $ arr , $ m ) { $ isZero = 0 ; $ isFive = 0 ; $ result = 0 ; if ( $ m < $ n ) { return -1 ; } for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ arr [ $ i ] == 0 ) $ isZero = 1 ; if ( $ arr [ $ i ] == 5 ) $ isFive = 1 ; } if ( $ isZero && $ isFive ) { $ result = 2 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ result = $ result * ( -- $ m ) ; } } else if ( $ isZero $ isFive ) { $ result = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ result = $ result * ( -- $ m ) ; } } else $ result = -1 ; return $ result ; } $ n = 3 ; $ m = 6 ; $ arr = array ( 2 , 3 , 5 , 6 , 7 , 9 ) ; echo numbers ( $ n , $ arr , $ m ) ; ? >"}
{"text": "Program untuk mencari elemen terkecil di antara tiga elemen | Pelaksanaan PHP untuk mencari yang terkecil daripada tiga elemen", "code": "< ? php $ a = 5 ; $ b = 7 ; $ c = 10 ; if ( $ a <= $ b && $ a <= $ c ) echo $ a . \" ▁ is ▁ the ▁ smallest \" ; else if ( $ b <= $ a && $ b <= $ c ) echo $ b . \" ▁ is ▁ the ▁ smallest \" ; else echo $ c . \" ▁ is ▁ the ▁ smallest \" ;"}
{"text": "Cari berikutnya dengan bitwise maksimum dan bitwise atau | Berfungsi untuk mencari jumlah maksimum; Maksimum dan elemen maksimum; Maksimum atau bitwise atau semua. ; Kod pemacu", "code": "< ? php function maxSum ( $ a , $ n ) { $ maxAnd = max ( $ a ) ; $ maxOR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ maxOR |= $ a [ $ i ] ; print ( $ maxAnd + $ maxOR ) ; } $ n = 4 ; $ a = array ( 3 , 5 , 6 , 1 ) ; maxSum ( $ a , $ n ) ; ? >"}
{"text": "Elemen minimum dan maksimum array yang boleh dibahagikan dengan nombor tertentu k | Berfungsi untuk mencari elemen minimum; Berfungsi untuk mencari elemen maksimum; Kod pemacu", "code": "< ? php function getMin ( $ arr , $ n , $ k ) { $ res = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % $ k == 0 ) $ res = min ( $ res , $ arr [ $ i ] ) ; } return $ res ; } function getMax ( $ arr , $ n , $ k ) { $ res = PHP_INT_MIN ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % $ k == 0 ) $ res = max ( $ res , $ arr [ $ i ] ) ; } return $ res ; } $ arr = array ( 10 , 1230 , 45 , 67 , 1 ) ; $ k = 10 ; $ n = sizeof ( $ arr ) ; echo \" Minimum ▁ element ▁ of ▁ array ▁ which ▁ is ▁ \" . \" divisible ▁ by ▁ k : ▁ \" , getMin ( $ arr , $ n , $ k ) , \" STRNEWLINE \" ; echo \" Maximum ▁ element ▁ of ▁ array ▁ which ▁ is ▁ \" . \" divisible ▁ by ▁ k : ▁ \" , getMax ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Cetak nombor yang mengandungi digit k dengan akar digital d | Berfungsi untuk mencari nombor; Jika d adalah 0 k harus 1; Cetak k - 1 sifar; Kod pemacu", "code": "< ? php function printNumberWithDR ( $ k , $ d ) { if ( $ d == 0 && $ k != 1 ) echo \" - 1\" ; else { echo $ d ; $ k -- ; while ( $ k -- ) echo \"0\" ; } } $ k = 4 ; $ d = 4 ; printNumberWithDR ( $ k , $ d ) ; ? >"}
{"text": "Bilangan bilangan bilangan bulat kurang daripada atau sama dengan n yang mempunyai 9 pembahagi | Pelaksanaan PHP fungsi pendekatan di atas untuk mengira nombor yang mempunyai 9 pembahagi; Pelbagai ayak; Pada mulanya Perdana [i] = i; Gunakan konsep penapis untuk menyimpan faktor utama pertama setiap nombor; Tandakan semua faktor i; Semak semua nombor jika mereka boleh dinyatakan dalam bentuk p * q; faktor utama; q faktor utama; Jika kedua -dua faktor utama berbeza jika p * q <= n dan q! =; Semak sama ada ia boleh dinyatakan sebagai p ^ 8; Kod pemacu", "code": "< ? php function countNumbers ( $ n ) { $ c = 0 ; $ limit = sqrt ( $ n ) ; $ prime [ $ limit + 1 ] = array ( 0 ) ; for ( $ i = 1 ; $ i <= $ limit ; $ i ++ ) $ prime [ $ i ] = $ i ; for ( $ i = 2 ; $ i * $ i <= $ limit ; $ i ++ ) { if ( $ prime [ $ i ] == $ i ) { for ( $ j = $ i * $ i ; $ j <= $ limit ; $ j += $ i ) if ( $ prime [ $ j ] == $ j ) $ prime [ $ j ] = $ i ; } } for ( $ i = 2 ; $ i <= $ limit ; $ i ++ ) { $ p = $ prime [ $ i ] ; $ q = $ prime [ $ i / $ prime [ $ i ] ] ; if ( $ p * $ q == $ i && $ q != 1 && $ p != $ q ) { $ c += 1 ; } else if ( $ prime [ $ i ] == $ i ) { if ( pow ( $ i , 8 ) <= $ n ) { $ c += 1 ; } } } return $ c ; } $ n = 1000 ; echo countNumbers ( $ n ) ; ? >"}
{"text": "Interprime | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Berfungsi untuk memeriksa sama ada nombor yang diberikan adalah interprima atau tidak; Interprima terkecil adalah 4 jadi bilangan kurang daripada 4 tidak boleh menjadi interprima; Hitung nombor perdana pertama <n; Hitung nombor perdana pertama> n; Semak jika prev_prime dan next_prime mempunyai purata yang sama; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 or $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) { if ( $ n % $ i == 0 or $ n % ( $ i + 2 ) == 0 ) { return false ; } } return true ; } function isInterprime ( $ n ) { if ( $ n < 4 ) return false ; $ prev_prime = $ n ; $ next_prime = $ n ; while ( ! isPrime ( $ prev_prime ) ) { $ prev_prime -- ; } while ( ! isPrime ( $ next_prime ) ) { $ next_prime ++ ; } if ( ( $ prev_prime + $ next_prime ) == 2 * $ n ) return true ; else return false ; } $ n = 9 ; if ( isInterprime ( $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Cari Unit Place Digit of Sum of N Factorials | Berfungsi untuk mencari digit tempat unit; Marilah kita menulis untuk kes apabila n lebih kecil daripada atau sama dengan 4 .; Kami tahu berikut (1! + 2! + 3! + 4!) % 10 = 3 lain (n> = 4); Kod pemacu", "code": "< ? php function get_unit_digit ( $ N ) { if ( $ N == 0 $ N == 1 ) return 1 ; else if ( $ N == 2 ) return 3 ; else if ( $ N == 3 ) return 9 ; return 3 ; } $ N = 1 ; for ( $ N = 0 ; $ N <= 10 ; $ N ++ ) echo \" For ▁ N ▁ = ▁ \" . $ N . \" ▁ : ▁ \" . get_unit_digit ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah Squares of Fibonacci Numbers | Program PHP untuk mencari jumlah kuadrat nombor Fibonacci dalam masa O (log n). ; Buat array untuk memoisasi; Mengembalikan nombor fibonacci n 'th menggunakan jadual f []; Kes asas; Jika FIB (n) sudah dikira; Memohon formula di atas [Nota Nota N & 1 adalah 1 jika n adalah ganjil, lain 0]. ; Berfungsi untuk mengira jumlah kuadrat nombor Fibonacci; Kod pemacu", "code": "< ? php $ MAX = 1000 ; global $ f ; $ f = array_fill ( 0 , $ MAX , 0 ) ; function fib ( $ n ) { if ( $ n == 0 ) return 0 ; if ( $ n == 1 $ n == 2 ) return ( $ f [ $ n ] = 1 ) ; $ k = ( $ n & 1 ) ? ( $ n + 1 ) / 2 : $ n / 2 ; $ f [ $ n ] = ( $ n & 1 ) ? ( fib ( $ k ) * fib ( $ k ) + fib ( $ k - 1 ) * fib ( $ k - 1 ) ) : ( 2 * fib ( $ k - 1 ) + fib ( $ k ) ) * fib ( $ k ) ; return $ f [ $ n ] ; } function calculateSumOfSquares ( $ n ) { return fib ( $ n ) * fib ( $ n + 1 ) ; } $ n = 6 ; echo \" Sum ▁ of ▁ Squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ \" ; echo calculateSumOfSquares ( $ n ) ; ? >"}
{"text": "Bilangan penyelesaian untuk persamaan x + y + z <= n | Fungsi untuk mencari bilangan penyelesaian untuk persamaan x + y + z <= n, seperti 0 <= x <= x, 0 <= y <= y, 0 <= z <= z. ; untuk menyimpan jawapan; untuk nilai x; untuk nilai y; nilai maksimum z; Jika nilai z lebih besar daripada sama dengan 0 maka hanya ia sah; Cari minimum temp dan z; mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "< ? php function NumberOfSolutions ( $ x , $ y , $ z , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i <= $ x ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ y ; $ j ++ ) { $ temp = $ n - $ i - $ j ; if ( $ temp >= 0 ) { $ temp = min ( $ temp , $ z ) ; $ ans += $ temp + 1 ; } } } return $ ans ; } $ x = 1 ; $ y = 2 ; $ z = 3 ; $ n = 4 ; echo NumberOfSolutions ( $ x , $ y , $ z , $ n ) ; ? >"}
{"text": "Program untuk mencari istilah n Siri 5, 12, 21, 32, 45. .... . | mengira istilah siri nth; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return pow ( $ n , 2 ) + 4 * $ n ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Nombor kurang daripada n yang merupakan produk dari dua nombor perdana yang berbeza | Berfungsi untuk memeriksa sama ada nombor adalah sempurna atau tidak; Fungsi untuk memeriksa sama ada nombor adalah produk dari dua prima yang berbeza; Fungsi untuk mencari nombor yang merupakan produk dari dua nombor perdana yang berbeza. ; Vektor untuk menyimpan nombor tersebut; masukkan dalam vektor; Cetak semua nombor sehingga n dari vektor; Kod pemacu", "code": "< ? php function isPerfectSquare ( $ x ) { $ sr = sqrt ( $ x ) ; return ( ( $ sr - floor ( $ sr ) ) == 0 ) ; } function isProduct ( $ num ) { $ cnt = 0 ; for ( $ i = 2 ; $ cnt < 2 && $ i * $ i <= $ num ; ++ $ i ) { while ( $ num % $ i == 0 ) { $ num /= $ i ; ++ $ cnt ; } } if ( $ num > 1 ) ++ $ cnt ; return $ cnt == 2 ; } function findNumbers ( $ N ) { $ vec = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( isProduct ( $ i ) && ! isPerfectSquare ( $ i ) ) { array_push ( $ vec , $ i ) ; } } for ( $ i = 0 ; $ i < sizeof ( $ vec ) ; $ i ++ ) { echo $ vec [ $ i ] . \" \" ; } } $ N = 30 ; findNumbers ( $ N ) ;"}
{"text": "Program untuk mencari istilah n Siri 3, 20, 63, 144, 230, â € | â € | | mengira istilah siri nth; kembali jumlah akhir; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return 2 * pow ( $ n , 3 ) + pow ( $ n , 2 ) ; } $ N = 3 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Cari nombor n Siri 1, 6, 15, 28, 45, .... . | Program PHP untuk mencari istilah siri; berfungsi untuk mengembalikan istilah siri; Mengambil n sebagai 4; panggilan fungsi", "code": "< ? php $ mod = 1000000009 ; function NthTerm ( $ n ) { global $ mod ; $ x = ( 2 * $ n * $ n ) % $ mod ; return ( $ x - $ n + $ mod ) % $ mod ; } $ N = 4 ; echo NthTerm ( $ N ) ; ? >"}
{"text": "Program untuk mencetak jumlah siri | mengira istilah siri nth; Dapatkan nilai n; Dapatkan jumlah siri", "code": "< ? php function findSum ( $ N ) { return ( $ N * ( $ N + 1 ) * ( 2 * $ N - 5 ) + 4 * $ N ) / 2 ; } $ N = 3 ; echo findSum ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari istilah siri nth | mengira istilah siri nth; Dapatkan nilai n; Cari istilah n dan cetaknya", "code": "< ? php function nthTerm ( $ N ) { return ( ( 3 * $ N * $ N ) - ( 6 * $ N ) + 2 ) ; } $ N = 3 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Program untuk mencari nilai tan (nî ~) | Program PHP untuk mencari nilai cos (n - theta); Fungsi ini digunakan untuk mengira pekali binomial sehingga 15; Gunakan DP mudah untuk mencari pekali; Fungsi untuk mencari nilai; menyimpan jawapan yang diperlukan; Gunakan untuk menandatangani tanda togol. ; hitung pengangka; hitung penyebut; Kod pemacu.", "code": "< ? php $ MAX = 16 ; $ nCr = array_fill ( 0 , $ MAX , array_fill ( 0 , $ MAX , 0 ) ) ; function binomial ( ) { global $ MAX , $ nCr ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ nCr [ $ i ] [ $ j ] = 1 ; else $ nCr [ $ i ] [ $ j ] = $ nCr [ $ i - 1 ] [ $ j ] + $ nCr [ $ i - 1 ] [ $ j - 1 ] ; } } } function findTanNTheta ( $ tanTheta , $ n ) { global $ MAX , $ nCr ; $ ans = 0 ; $ numerator = 0 ; $ denominator = 0 ; $ toggle = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i += 2 ) { $ numerator = $ numerator + $ nCr [ $ n ] [ $ i ] * pow ( $ tanTheta , $ i ) * $ toggle ; $ toggle = $ toggle * -1 ; } $ denominator = 1 ; $ toggle = -1 ; for ( $ i = 2 ; $ i <= $ n ; $ i += 2 ) { $ numerator = $ numerator + $ nCr [ $ n ] [ $ i ] * pow ( $ tanTheta , $ i ) * $ toggle ; $ toggle = $ toggle * -1 ; } $ ans = $ numerator / $ denominator ; return $ ans ; } binomial ( ) ; $ tanTheta = 0.3 ; $ n = 10 ; echo findTanNTheta ( $ tanTheta , $ n ) ; ? >"}
{"text": "Masalah Pizza Cut (atau Bahagian Lingkaran mengikut baris) | Fungsi untuk mencari kepingan maksimum dengan pemotongan N. ; Kod pemacu", "code": "< ? php function findMaximumPieces ( $ n ) { return 1 + $ n * ( $ n + 1 ) / 2 ; } echo findMaximumPieces ( 3 ) ; ? >"}
{"text": "Semak sama ada bilangan besar boleh dibahagikan dengan 19 atau tidak | Berfungsi untuk memeriksa sama ada nombor itu boleh dibahagikan dengan 19 atau tidak; Mengekstrak digit terakhir; Memotong nombor; Menambah dua kali digit terakhir ke nombor yang tinggal; kembali benar jika nombor boleh dibahagikan dengan 19; Kod pemacu", "code": "< ? php function isDivisible ( $ n ) { while ( 1 ) { $ d = $ n % 10 ; $ n = $ n / 10 ; $ n = $ n + $ d * 2 ; if ( $ n < 100 ) break ; } return ( $ n % 19 == 0 ) ; } $ n = 38 ; if ( isDivisible ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Program untuk mencari jumlah siri 1 * 3 + 3 * 5 + .... | Program PHP untuk mencari jumlah terma pertama N; Sn = n * (4 * n * n + 6 * n - 1) / 3; bilangan syarat yang akan dimasukkan dalam jumlah; Cari SN", "code": "< ? php function calculateSum ( $ n ) { return ( $ n * ( 4 * $ n * $ n + 6 * $ n - 1 ) / 3 ) ; } $ n = 4 ; echo \" Sum = \" ? >"}
{"text": "Triplet tanpa unsur yang boleh dibahagikan dengan 3 dan jumlah n | Berfungsi untuk mencetak A, B dan C; gelung pertama; Semak nombor 1 st; gelung kedua; Semak nombor 2 ND; gelung ketiga; Semak nombor 3 RD; Kod pemacu", "code": "< ? php function printCombination ( $ n ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ i % 3 != 0 ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ j % 3 != 0 ) { for ( $ k = 1 ; $ k < $ n ; $ k ++ ) { if ( $ k % 3 != 0 && ( $ i + $ j + $ k ) == $ n ) { echo $ i , \" \" ▁ , ▁ $ j ▁ , ▁ \" \" return ; } } } } } } } $ n = 233 ; printCombination ( $ n ) ;"}
{"text": "Program untuk mencari peratusan perbezaan antara dua nombor | Fungsi untuk mengira peratusan; Kod pemacu; Fungsi panggilan", "code": "< ? php function percent ( $ a , $ b ) { $ result = 0 ; $ result = ( ( $ b - $ a ) * 100 ) / $ a ; return $ result ; } $ a = 20 ; $ b = 25 ; echo percent ( $ a , $ b ) . \" % \" ; ? >"}
{"text": "Nombor kiraan yang boleh diwakili sebagai jumlah prima pariti yang sama | Fungsi untuk mengira kiraan; Kod pemacu", "code": "< ? php function calculate ( & $ array , $ size ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) if ( $ array [ $ i ] % 2 == 0 && $ array [ $ i ] != 0 && $ array [ $ i ] != 2 ) $ count ++ ; return $ count ; } $ a = array ( 1 , 3 , 4 , 6 ) ; $ size = sizeof ( $ a ) ; echo calculate ( $ a , $ size ) ; ? >"}
{"text": "Program untuk mencari HCF (faktor umum tertinggi) daripada 2 nombor | Fungsi rekursif untuk mengembalikan GCD A dan B; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } $ a = 98 ; $ b = 56 ; echo \" GCD ▁ of ▁ $ a ▁ and ▁ $ b ▁ is ▁ \" , gcd ( $ a , $ b ) ; ? >"}
{"text": "Nombor terbesar dengan nines trailing maksimum yang kurang daripada n dan lebih besar daripada n | fungsi untuk mengira tiada digit; fungsi untuk melaksanakan pendekatan di atas; jika perbezaan antara kuasa dan n tidak melebihi d; gelung untuk membina nombor dari NO angka yang sesuai yang mengandungi hanya 9; jika nombor binaan sama dengan nombor asal (n); pemerhatian; Kod pemacu; pemboleh ubah yang tidak menyimpan digit dalam n", "code": "< ? php function dig ( $ a ) { $ count = 0 ; while ( $ a > 0 ) { $ a = ( int ) ( $ a / 10 ) ; $ count ++ ; } return $ count ; } function required_number ( $ num , $ n , $ d ) { $ flag = 0 ; for ( $ i = $ num ; $ i >= 1 ; $ i -- ) { $ power = pow ( 10 , $ i ) ; $ a = $ n % $ power ; if ( $ d > $ a ) { $ flag = 1 ; break ; } } if ( $ flag ) { $ t = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { $ t += 9 * pow ( 10 , $ j ) ; } if ( $ n % $ power == $ t ) echo $ n ; else { echo ( $ n - ( $ n % $ power ) - 1 ) ; } } else echo $ n ; } $ n = 1029 ; $ d = 102 ; $ num = dig ( $ n ) ; required_number ( $ num , $ n , $ d ) ; ? >"}
{"text": "Telur menjatuhkan teka -teki dengan 2 telur dan l lantai | Program PHP untuk mencari bilangan percubaan yang optimum untuk lantai K dan 2 telur. ; Kod pemacu", "code": "< ? php function twoEggDrop ( $ k ) { return ceil ( ( -1.0 + sqrt ( 1 + 8 * $ k ) ) / 2.0 ) ; } $ k = 100 ; echo twoEggDrop ( $ k ) ;"}
{"text": "Program untuk mencari kawasan dan jumlah icosahedron | Fungsi untuk mencari kawasan icosahedron; Formula untuk mengira kawasan; Fungsi untuk mencari jumlah icosahedron; Formula untuk mengira jumlah; Kod pemacu; Panggilan fungsi untuk mencari kawasan icosahedron. ; Panggilan fungsi untuk mencari kelantangan icosahedron.", "code": "< ? php function findArea ( $ a ) { $ area ; $ area = 5 * sqrt ( 3 ) * $ a * $ a ; return $ area ; } function findVolume ( $ a ) { $ volume ; $ volume = ( ( float ) 5 / 12 ) * ( 3 + sqrt ( 5 ) ) * $ a * $ a * $ a ; return $ volume ; } $ a = 5 ; echo \" Area : \" ▁ , ▁ findArea ( $ a ) , ▁ \" \" ; STRNEWLINE echo ▁ \" Volume : \" ? >"}
{"text": "Jumlah cara untuk meletakkan x dan y di tempat -tempat sedemikian rupa sehingga tidak ada dua x bersama -sama | Berfungsi untuk mengembalikan bilangan cara; untuk n = 1; untuk n = 2; berulang untuk mencari istilah Fibonacci; Jumlah tempat", "code": "< ? php function ways ( $ n ) { $ first = 2 ; $ second = 3 ; $ res = 0 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ res = $ first + $ second ; $ first = $ second ; $ second = $ res ; } return $ res ; } $ n = 7 ; echo \" Total ▁ ways ▁ are : ▁ \" , ways ( $ n ) ; ? >"}
{"text": "Bilangan digit dalam f faktorial kepada kuasa n | Program PHP untuk mencari kiraan digit dalam f faktorial yang dibangkitkan kepada N; Kami mengambil jumlah logaritma seperti yang dijelaskan dalam pendekatan; kalikan hasil dengan n; Kod pemacu", "code": "< ? php function countDigits ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += log10 ( $ i ) ; $ ans = $ ans * $ n ; return 1 + floor ( $ ans ) ; } $ n = 4 ; echo countDigits ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk menukar sentimeter ke meter dan kilometer | Kod pemacu; Menukarkan sentimeter ke meter dan kilometer", "code": "< ? php $ cm ; $ meter ; $ kilometer ; $ cm = 1000 ; $ meter = $ cm / 100.0 ; $ kilometer = $ cm / 100000.0 ; echo \" Length ▁ in ▁ meter ▁ = ▁ \" , $ meter , \" m \" , \" STRNEWLINE \" ; echo \" Length ▁ in ▁ Kilometer ▁ = ▁ \" , $ kilometer , \" km \" , \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika dua orang bermula dari pelbagai mata yang pernah bertemu | Program PHP untuk mencari jika dua orang bermula dari kedudukan yang berbeza pernah bertemu atau tidak. ; Jika kelajuan seseorang berada di kedudukan sebelum orang lain lebih kecil, maka kembali palsu. ; Memastikan bahawa X1 lebih besar; Memeriksa jika kelajuan relatif adalah faktor jarak relatif atau tidak; Kod pemacu", "code": "< ? php function everMeet ( $ x1 , $ x2 , $ v1 , $ v2 ) { if ( $ x1 < $ x2 && $ v1 <= $ v2 ) return false ; if ( $ x1 > $ x2 && $ v1 >= $ v2 ) return false ; if ( $ x1 < $ x2 ) { list ( $ x1 , $ x2 ) = array ( $ x2 , $ x1 ) ; list ( $ v2 , $ v1 ) = array ( $ v1 , $ v2 ) ; } return ( ( $ x1 - $ x2 ) % ( $ v1 - $ v2 ) == 0 ) ; } $ x1 = 5 ; $ v1 = 8 ; $ x2 = 4 ; $ v2 = 7 ; if ( everMeet ( $ x1 , $ x2 , $ v1 , $ v2 ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; ? >"}
{"text": "Cari Ceil of A / B tanpa menggunakan fungsi Ceil () | mengambil input 1; Contoh bahagian yang sempurna mengambil input 2", "code": "< ? php $ a = 4 ; $ b = 3 ; $ val = ( $ a + $ b - 1 ) / $ b ; echo \" The ▁ ceiling ▁ value ▁ of ▁ 4/3 ▁ is ▁ \" , floor ( $ val ) , \" STRNEWLINE \" ; $ a = 6 ; $ b = 3 ; $ val = ( $ a + $ b - 1 ) / $ b ; echo \" The ▁ ceiling ▁ value ▁ of ▁ 6/3 ▁ is ▁ \" , floor ( $ val ) ; ? >"}
{"text": "Jumlah julat dalam satu siri ganjil pertama kemudian nombor semulajadi | Fungsi yang mengembalikan jumlah dalam julat 1 hingga x dalam urutan 1 3 5 7. .... N 2 4 6.. . N - 1; bilangan nombor ganjil; bilangan nombor tambahan yang diperlukan; Kod pemacu", "code": "< ? php function sumTillX ( $ x , $ n ) { $ odd = ceil ( $ n / 2.0 ) ; if ( $ x <= $ odd ) return $ x * $ x ; $ even = $ x - $ odd ; return ( ( $ odd * $ odd ) + ( $ even * $ even ) + $ even ) ; } function rangeSum ( $ N , $ L , $ R ) { return sumTillX ( $ R , $ N ) - sumTillX ( $ L - 1 , $ N ) ; } $ N = 10 ; $ L = 1 ; $ R = 6 ; echo ( rangeSum ( $ N , $ L , $ R ) ) ; ? >"}
{"text": "Nombor Perdana Twin antara 1 dan N | Program PHP untuk mencetak semua prima berkembar menggunakan penapis eratosthenes. ; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Untuk memeriksa nombor perdana berkembar memaparkan prima berkembar; Kod pemacu; Memanggil fungsi", "code": "< ? php function printTwinPrime ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ p = 2 ; $ p <= $ n - 2 ; $ p ++ ) if ( $ prime [ $ p ] && $ prime [ $ p + 2 ] ) echo \" ( \" . $ p . \" , ▁ \" . ( $ p + 2 ) . \" ) \" ; } $ n = 25 ; printTwinPrime ( $ n ) ; ? >"}
{"text": "Nombor bebas kiub lebih kecil daripada n | Pulangan benar jika n adalah nombor percuma kiub, lain mengembalikan palsu. ; Semak semua kemungkinan kiub yang boleh dibahagikan; Cetak semua nombor percuma kiub lebih kecil daripada n. ; Kod pemacu", "code": "< ? php function isCubeFree ( $ n ) { if ( $ n == 1 ) return false ; for ( $ i = 2 ; $ i * $ i * $ i <= $ n ; $ i ++ ) if ( $ n % ( $ i * $ i * $ i ) == 0 ) return false ; return true ; } function printCubeFree ( $ n ) { for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) if ( isCubeFree ( $ i ) ) echo $ i . \" \" ; } $ n = 20 ; printCubeFree ( $ n ) ; ? >"}
{"text": "Setara dengan kod kelabu dan songsangnya | Berfungsi untuk menukar bilangan perpuluhan yang diberikan oleh kod kelabu ke dalam songsangnya dalam bentuk perpuluhan; Mengambil XOR sehingga n menjadi sifar; Kod pemacu", "code": "< ? php function inversegrayCode ( $ n ) { $ inv = 0 ; for ( ; $ n ; $ n = $ n >> 1 ) $ inv ^= $ n ; return $ inv ; } $ n = 15 ; echo inversegrayCode ( $ n ) ; ? >"}
{"text": "Produk Faktor Perdana Unik Nombor | Fungsi untuk mencetak semua faktor utama nombor n tertentu; Mengendalikan Faktor Perdana 2 secara eksplisit supaya secara optimum dapat mengendalikan faktor utama yang lain. ; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, cetak saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Kod pemacu", "code": "< ? php function productPrimeFactors ( $ n ) { $ product = 1 ; if ( $ n % 2 == 0 ) { $ product *= 2 ; while ( $ n % 2 == 0 ) $ n = $ n / 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { $ product = $ product * $ i ; while ( $ n % $ i == 0 ) $ n = $ n / $ i ; } } if ( $ n > 2 ) $ product = $ product * $ n ; return $ product ; } $ n = 44 ; echo productPrimeFactors ( $ n ) ; ? >"}
{"text": "Memaksimumkan kebarangkalian satu jenis dari bekas N | Mengembalikan kebarangkalian maksimum untuk melukis 1 salinan nombor A dari n bekas dengan N salinan setiap nombor A dan B; Pmax = n / (n + 1); 1. N = 1; 2. N = 2; 3. N = 10", "code": "< ? php function calculateProbability ( $ N ) { $ probability = $ N / ( $ N + 1 ) ; return $ probability ; } $ N = 1 ; $ probabilityMax = calculateProbability ( $ N ) ; echo ( \" Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ \" . $ N . \" is , \" round ( $ probabilityMax , 4 ) . \" STRNEWLINE \" ) ; $ N = 2 ; $ probabilityMax = calculateProbability ( $ N ) ; echo ( \" Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ \" . $ N . \" is , \" round ( $ probabilityMax , 4 ) . \" STRNEWLINE \" ) ; $ N = 10 ; $ probabilityMax = calculateProbability ( $ N ) ; echo ( \" Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ \" . $ N . \" is , \" round ( $ probabilityMax , 4 ) . \" STRNEWLINE \" ) ; ? >"}
{"text": "Program untuk melaksanakan sisihan piawai data dikumpulkan | Fungsi untuk mencari purata data dikumpulkan. ; Fungsi untuk mencari sisihan piawai data dikumpulkan. ; Formula untuk mencari sisihan piawai data dikumpulkan. ; Mengisytiharkan dan memulakan had selang atas. ; Mengisytiharkan dan memulakan had selang atas. ; Mengira saiz array.", "code": "< ? php function mean ( $ mid , $ freq , $ n ) { $ sum = 0 ; $ freqSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ mid [ $ i ] * $ freq [ $ i ] ; $ freqSum = $ freqSum + $ freq [ $ i ] ; } return $ sum / $ freqSum ; } function groupedSD ( $ lower_limit , $ upper_limit , $ freq , $ n ) { $ mid = array ( ) ; $ sum = 0 ; $ freqSum = 0 ; $ sd ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ mid [ $ i ] = ( $ lower_limit [ $ i ] + $ upper_limit [ $ i ] ) / 2 ; $ sum = $ sum + $ freq [ $ i ] * $ mid [ $ i ] * $ mid [ $ i ] ; $ freqSum = $ freqSum + $ freq [ $ i ] ; } $ sd = sqrt ( ( $ sum - $ freqSum * mean ( $ mid , $ freq , $ n ) * mean ( $ mid , $ freq , $ n ) ) / ( $ freqSum - 1 ) ) ; return $ sd ; } $ lower_limit = array ( 50 , 61 , 71 , 86 , 96 ) ; $ upper_limit = array ( 60 , 70 , 85 , 95 , 100 ) ; $ freq = array ( 9 , 7 , 9 , 12 , 8 ) ; $ n = count ( $ lower_limit ) ; echo groupedSD ( $ lower_limit , $ upper_limit , $ freq , $ n ) ; ? >"}
{"text": "Purata N pertama walaupun nombor semula jadi | fungsi untuk mencari purata jumlah nombor n pertama; jumlah nombor pertama n bahkan; mengira purata; Kod pemacu", "code": "< ? php function avg_of_even_num ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 2 * $ i ; return $ sum / $ n ; } $ n = 9 ; echo ( avg_of_even_num ( $ n ) ) ; ? >"}
{"text": "Purata N pertama walaupun nombor semula jadi | Kembalikan purata jumlah nombor n pertama; Kod pemacu", "code": "< ? php function avg_of_even_num ( $ n ) { return $ n + 1 ; } $ n = 8 ; echo ( avg_of_even_num ( $ n ) ) ; ? >"}
{"text": "Jumlah Square of First N Odd Number | Kaedah PHP yang cekap untuk mencari jumlah persegi nombor n pertama. ; kod pemacu", "code": "< ? php < ? php function squareSum ( $ n ) { return $ n * ( 4 * $ n * $ n - 1 ) / 3 ; } echo squareSum ( 8 ) ; ? >"}
{"text": "Semak sama ada diberikan tiga nombor adalah prima bersebelahan | Cek Nombor yang diberikan cuaca adalah perdana atau tidak. ; Semak jika n adalah pelbagai 2; Jika tidak, maka periksa kemungkinan; kembali nombor perdana seterusnya; Mulakan dengan nombor seterusnya. ; rehat selepas mencari nombor perdana seterusnya; Semak yang diberikan tiga nombor adalah prima bersebelahan tidak. ; Semak yang diberikan tiga nombor adalah prima tidak. ; Cari Perdana Seterusnya A; Jika seterusnya tidak sama dengan 'A'; Jika seterusnya seterusnya tidak sama dengan 'C'; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n % 2 == 0 ) return false ; for ( $ i = 3 ; $ i * $ i <= $ n ; $ i += 2 ) if ( $ n % $ i == 0 ) return false ; return true ; } function nextPrime ( $ start ) { $ next = $ start + 1 ; while ( ! isPrime ( $ next ) ) $ next ++ ; return $ next ; } function areAdjacentPrimes ( $ a , $ b , $ c ) { if ( ! isPrime ( $ a ) || ! isPrime ( $ b ) || ! isPrime ( $ c ) ) return false ; $ next = nextPrime ( $ a ) ; if ( $ next != $ b ) return false ; if ( nextPrime ( $ b ) != $ c ) return false ; return true ; } if ( areAdjacentPrimes ( 11 , 13 , 19 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak sama ada nombor semiprime atau tidak | Fungsi utiliti untuk memeriksa sama ada nombor adalah semiprime atau tidak; Jika nombor lebih besar daripada 1, tambahkannya ke pemboleh ubah kiraan kerana ia menunjukkan bilangan yang kekal adalah nombor utama; Kembali '1' jika kiraan adalah sama dengan '2' lain kembali '0'; Berfungsi untuk mencetak 'benar' atau 'palsu' mengikut keadaan semiprim; Kod pemacu", "code": "< ? php function checkSemiprime ( $ num ) { $ cnt = 0 ; for ( $ i = 2 ; $ cnt < 2 && $ i * $ i <= $ num ; ++ $ i ) while ( $ num % $ i == 0 ) $ num /= $ i ; ++ $ cnt ; if ( $ num > 1 ) ++ $ cnt ; return $ cnt == 2 ; } function semiprime ( $ n ) { if ( checkSemiprime ( $ n ) ) echo \" True STRNEWLINE \" ; else echo \" False STRNEWLINE \" ; } $ n = 6 ; semiprime ( $ n ) ; $ n = 8 ; semiprime ( $ n ) ; ? >"}
{"text": "Program untuk mencari jumlah siri 1 + 2 + 2 + 3 + 3 + 3 +. . . + n | Fungsi untuk mencari jumlah siri. ; Kod pemacu; Panggilan fungsi", "code": "< ? php function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + $ i * $ i ; return $ sum ; } $ n = 10 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text": "Program untuk mencari jumlah siri 1 + 2 + 2 + 3 + 3 + 3 +. . . + n | Fungsi untuk mencari jumlah siri. ; Kod pemacu", "code": "< ? php function sumOfSeries ( $ n ) { return ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; } $ n = 10 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text": "Nilai terma pekali binomial maksimum | Pulangan nilai pekali binomial c (n, k); Hitung nilai pekali binomial dengan cara bawah; Kes asas; Hitung nilai menggunakan nilai yang disimpan sebelumnya; Kembalikan nilai terma pekali binomial maksimum. ; jika n juga; jika n adalah ganjil; Kod pemacu", "code": "< ? php function binomialCoeff ( $ n , $ k ) { $ C [ $ n + 1 ] [ $ k + 1 ] = array ( 0 ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ k ) ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } return $ C [ $ n ] [ $ k ] ; } function maxcoefficientvalue ( $ n ) { if ( $ n % 2 == 0 ) return binomialCoeff ( $ n , $ n / 2 ) ; else return binomialCoeff ( $ n , ( $ n + 1 ) / 2 ) ; } $ n = 4 ; echo maxcoefficientvalue ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Nombor digit terkecil dibahagi dengan diberikan tiga nombor |  ; LCM untuk x, y, z; Mengembalikan nombor digit terkecil yang boleh dibahagikan dengan x, y dan z; Cari LCM; Cari kuasa 10 untuk nombor paling sedikit; peringatan selepas; Jika bilangan terkecil itu sendiri membahagikan LCM. ; Tambah LCM - Nombor Peringatan untuk Nombor N Digit Next; Keadaan ini periksa nombor digit n adalah mungkin atau tidak jika mungkin ia mengembalikan nombor lain kembali 0; kod pemacu; Sekiranya nombor mungkin maka ia mencetak nombor", "code": "< ? php function gcd ( $ a , $ b ) { return ( $ a % $ b ) ? gcd ( $ b , $ a % $ b ) : $ b ; } function LCM ( $ x , $ y , $ z ) { $ ans = floor ( ( $ x * $ y ) / ( gcd ( $ x , $ y ) ) ) ; return floor ( ( $ z * $ ans ) / ( gcd ( $ ans , $ z ) ) ) ; } function findDivisible ( $ n , $ x , $ y , $ z ) { $ lcm = LCM ( $ x , $ y , $ z ) ; $ ndigitnumber = pow ( 10 , $ n - 1 ) ; $ reminder = $ ndigitnumber % $ lcm ; if ( $ reminder == 0 ) return $ ndigitnumber ; $ ndigitnumber += $ lcm - $ reminder ; if ( $ ndigitnumber < pow ( 10 , $ n ) ) return $ ndigitnumber ; else return 0 ; } $ n = 4 ; $ x = 2 ; $ y = 3 ; $ z = 5 ; $ res = findDivisible ( $ n , $ x , $ y , $ z ) ; if ( $ res != 0 ) echo $ res ; else echo \" Not ▁ possible \" ; ? >"}
{"text": "Jumlah Squares of First N Natural Number | Mengembalikan jumlah kuadrat nombor semulajadi n pertama; Kod pemacu", "code": "< ? php function squaresum ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; } $ n = 4 ; echo squaresum ( $ n ) ; ? >"}
{"text": "Program untuk mengira jarak antara dua mata | Berfungsi untuk mengira jarak; Jarak mengira; Kod pemacu", "code": "< ? php function distance ( $ x1 , $ y1 , $ x2 , $ y2 ) { return sqrt ( pow ( $ x2 - $ x1 , 2 ) + pow ( $ y2 - $ y1 , 2 ) * 1.0 ) ; } echo ( distance ( 3 , 4 , 4 , 3 ) ) ; ? >"}
{"text": "Semak jika sebilangan besar adalah divisibilitas oleh 15 | untuk mencari jumlah; berfungsi untuk memeriksa sama ada sebilangan besar boleh dibahagikan dengan 15; panjang rentetan; periksa pembahagian sebanyak 5; Jumlah digit; jika dibahagikan dengan 3; Kod pemacu", "code": "< ? php function accumulate ( $ s ) { $ acc = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ acc += $ s [ $ i ] - '0' ; } return $ acc ; } function isDivisible ( $ s ) { $ n = strlen ( $ s ) ; if ( $ s [ $ n - 1 ] != '5' && $ s [ $ n - 1 ] != '0' ) return false ; $ sum = accumulate ( $ s ) ; return ( $ sum % 3 == 0 ) ; } $ s = \"15645746327462384723984023940239\" ; isDivisible ( $ s ) ? print ( \" Yes STRNEWLINE \" ) : print ( \" No STRNEWLINE \" ) ; $ s = \"15645746327462384723984023940235\" ; isDivisible ( $ s ) ? print ( \" Yes STRNEWLINE \" ) : print ( \" No STRNEWLINE \" ) ; ? >"}
{"text": "Nombor persegi sempurna terbesar dalam array | Berfungsi untuk memeriksa sama ada nombor adalah nombor persegi yang sempurna atau tidak; mengambil sqrt nombor; memeriksa jika ia adalah nombor persegi yang sempurna; Berfungsi untuk mencari nombor persegi sempurna terbesar dalam array; menyimpan maksimum semua nombor persegi yang sempurna; Melintasi semua elemen dalam array; Simpan maksimum jika elemen semasa adalah persegi yang sempurna; Kod pemacu", "code": "< ? php function checkPerfectSquare ( $ n ) { $ d = sqrt ( $ n ) ; if ( $ d * $ d == $ n ) return true ; return false ; } function largestPerfectSquareNumber ( $ a , $ n ) { $ maxi = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( checkPerfectSquare ( $ a [ $ i ] ) ) $ maxi = max ( $ a [ $ i ] , $ maxi ) ; } return $ maxi ; } $ a = array ( 16 , 20 , 25 , 2 , 3 , 10 ) ; $ n = count ( $ a ) ; echo largestPerfectSquareNumber ( $ a , $ n ) ; ? >"}
{"text": "Kira pasangan (i, j) sedemikian rupa sehingga (i + j) boleh dibahagikan dengan a dan b kedua -duanya | Pelaksanaan PHP pendekatan di atas; Berfungsi untuk mencari LCM; Berfungsi untuk mengira pasangan; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { return $ b == 0 ? $ a : gcd ( $ b , $ a % $ b ) ; } function find_LCM ( $ x , $ y ) { return ( int ) ( ( $ x * $ y ) / gcd ( $ x , $ y ) ) ; } function CountPairs ( $ n , $ m , $ A , $ B ) { $ cnt = 0 ; $ lcm = find_LCM ( $ A , $ B ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ cnt += ( int ) ( ( $ m + ( $ i % $ lcm ) ) / $ lcm ) ; return $ cnt ; } $ n = 60 ; $ m = 90 ; $ A = 5 ; $ B = 10 ; echo CountPairs ( $ n , $ m , $ A , $ B ) ; ? >"}
{"text": "Memandangkan array dan dua bilangan bulat l dan r, cari elemen terbesar kth dalam julat [l, r] | Pelaksanaan PHP pendekatan; Fungsi untuk mengira awalan; Mewujudkan satu pengindeksan berasaskan; Memulakan dan membuat array awalan; Mewujudkan array awalan untuk setiap nilai yang mungkin dalam julat tertentu; Berfungsi untuk mengembalikan elemen terbesar kth dalam julat indeks [l, r]; Mencari binari melalui array 2D dan hanya memeriksa julat di mana sub array adalah sebahagian; Kod pemacu; Mewujudkan array awalan untuk array yang diberikan; Pertanyaan; Melakukan pertanyaan", "code": "< ? php $ MAX = 101 ; $ prefix = array_fill ( 0 , $ MAX , array_fill ( 0 , $ MAX , 0 ) ) ; $ ar = array_fill ( 0 , $ MAX , 0 ) ; function cal_prefix ( $ n , $ arr ) { global $ prefix , $ ar , $ MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ ar [ $ i + 1 ] = $ arr [ $ i ] ; for ( $ i = 1 ; $ i < $ MAX ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ prefix [ $ i ] [ $ j ] = 0 ; for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { $ prefix [ $ i ] [ $ j ] = $ prefix [ $ i ] [ $ j - 1 ] + ( int ) ( $ ar [ $ j ] <= $ i ? 1 : 0 ) ; } } } function ksub ( $ l , $ r , $ n , $ k ) { global $ prefix , $ ar , $ MAX ; $ lo = 1 ; $ hi = $ MAX - 1 ; while ( $ lo + 1 < $ hi ) { $ mid = ( int ) ( ( $ lo + $ hi ) / 2 ) ; if ( $ prefix [ $ mid ] [ $ r ] - $ prefix [ $ mid ] [ $ l - 1 ] >= $ k ) $ hi = $ mid ; else $ lo = $ mid + 1 ; } if ( $ prefix [ $ lo ] [ $ r ] - $ prefix [ $ lo ] [ $ l - 1 ] >= $ k ) $ hi = $ lo ; return $ hi ; } $ arr = array ( 1 , 4 , 2 , 3 , 5 , 7 , 6 ) ; $ n = count ( $ arr ) ; $ k = 4 ; cal_prefix ( $ n , $ arr ) ; $ queries = array ( array ( 1 , $ n , 1 ) , array ( 2 , $ n - 2 , 2 ) , array ( 3 , $ n - 1 , 3 ) ) ; $ q = count ( $ queries ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo ksub ( $ queries [ $ i ] [ 0 ] , $ queries [ $ i ] [ 1 ] , $ n , $ queries [ $ i ] [ 2 ] ) . \" STRNEWLINE \" ; ? >"}
{"text": "Keluarkan satu elemen dari array seperti yang Max | fungsi untuk mengira max - min; Harus ada sekurang -kurangnya dua elemen; Untuk menyimpan minimum pertama dan kedua; Untuk menyimpan maksimum pertama dan kedua; Kod pemacu", "code": "< ? php function max_min ( $ a , $ n ) { if ( $ n <= 1 ) return PHP_INT_MAX ; $ f_min = $ a [ 0 ] ; $ s_min = PHP_INT_MAX ; $ f_max = $ a [ 0 ] ; $ s_max = ~ PHP_INT_MAX ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] <= $ f_min ) { $ s_min = $ f_min ; $ f_min = $ a [ $ i ] ; } else if ( $ a [ $ i ] < $ s_min ) { $ s_min = $ a [ $ i ] ; } if ( $ a [ $ i ] >= $ f_max ) { $ s_max = $ f_max ; $ f_max = $ a [ $ i ] ; } else if ( $ a [ $ i ] > $ s_max ) { $ s_max = $ a [ $ i ] ; } } return min ( ( $ f_max - $ s_min ) , ( $ s_max - $ f_min ) ) ; } $ a = array ( 1 , 3 , 3 , 7 ) ; $ n = sizeof ( $ a ) ; echo ( max_min ( $ a , $ n ) ) ; ? >"}
{"text": "Minimum dalam array yang pertama kali berkurangan kemudian meningkat | Berfungsi untuk mencari indeks nombor terkecil; Melakukan carian binari; Cari elemen pertengahan; Periksa titik rehat; Mengembalikan indeks; Kod pemacu; Cetak nombor terkecil", "code": "< ? php function minimal ( $ a , $ n ) { $ lo = 0 ; $ hi = $ n - 1 ; while ( $ lo < $ hi ) { $ mid = ( $ lo + $ hi ) >> 1 ; if ( $ a [ $ mid ] < $ a [ $ mid + 1 ] ) { $ hi = $ mid ; } else { $ lo = $ mid + 1 ; } } return $ lo ; } $ a = array ( 8 , 5 , 4 , 3 , 4 , 10 ) ; $ n = sizeof ( $ a ) ; $ ind = minimal ( $ a , $ n ) ; echo $ a [ $ ind ] ; ? >"}
{"text": "Indeks paling kiri dan paling kanan maksimum dan elemen minimum array | Pelaksanaan PHP pendekatan; Jika didapati minimum baru; Jika arr [i] = min maka indeks paling kanan untuk min akan berubah; Jika dijumpai maksimum baru; Jika arr [i] = max maka indeks paling kanan untuk max akan berubah; Kod pemacu", "code": "< ? php function findIndices ( $ arr , $ n ) { $ leftMin = 0 ; $ rightMin = 0 ; $ leftMax = 0 ; $ rightMax = 0 ; $ min = $ arr [ 0 ] ; $ max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ min ) { $ leftMin = $ rightMin = $ i ; $ min = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] == $ min ) $ rightMin = $ i ; if ( $ arr [ $ i ] > $ max ) { $ leftMax = $ rightMax = $ i ; $ max = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] == $ max ) $ rightMax = $ i ; } echo \" Minimum ▁ left ▁ : ▁ \" , $ leftMin , \" STRNEWLINE \" ; echo \" Minimum ▁ right ▁ : ▁ \" , $ rightMin , \" STRNEWLINE \" ; echo \" Maximum ▁ left ▁ : ▁ \" , $ leftMax , \" STRNEWLINE \" ; echo \" Maximum ▁ right ▁ : ▁ \" , $ rightMax , \" STRNEWLINE \" ; } $ arr = array ( 2 , 1 , 1 , 2 , 1 , 5 , 6 , 5 ) ; $ n = sizeof ( $ arr ) ; findIndices ( $ arr , $ n ) ; ? >"}
{"text": "Cari elemen terkecil dan terbesar dari pepenjuru matriks persegi | Berfungsi untuk mencari elemen terkecil dan terbesar dari pepenjuru utama dan sekunder; Ambil panjang $ matriks; mengisytiharkan dan memulakan pembolehubah dengan nilai yang sesuai; Keadaan untuk pepenjuru utama; Ambil nilai terkecil baru; Ambil nilai terbesar baru; Keadaan untuk pepenjuru sekunder; Ambil nilai terkecil baru; Ambil nilai terbesar baru; Mengisytiharkan dan memulakan matriks 5 x5", "code": "< ? php function diagonalsMinMax ( $ mat ) { $ n = count ( $ mat ) ; if ( $ n == 0 ) return ; $ principalMin = $ mat [ 0 ] [ 0 ] ; $ principalMax = $ mat [ 0 ] [ 0 ] ; $ secondaryMin = $ mat [ $ n - 1 ] [ 0 ] ; $ secondaryMax = $ mat [ $ n - 1 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ i == $ j ) { if ( $ mat [ $ i ] [ $ j ] < $ principalMin ) { $ principalMin = $ mat [ $ i ] [ $ j ] ; } if ( $ mat [ $ i ] [ $ j ] > $ principalMax ) { $ principalMax = $ mat [ $ i ] [ $ j ] ; } } if ( ( $ i + $ j ) == ( $ n - 1 ) ) { if ( $ mat [ $ i ] [ $ j ] < $ secondaryMin ) { $ secondaryMin = $ mat [ $ i ] [ $ j ] ; } if ( $ mat [ $ i ] [ $ j ] > $ secondaryMax ) { $ secondaryMax = $ mat [ $ i ] [ $ j ] ; } } } } echo \" Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ \" , $ principalMin , \" STRNEWLINE \" ; echo \" Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ \" , $ principalMax , \" STRNEWLINE \" ; echo \" Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ \" , $ secondaryMin , \" STRNEWLINE \" ; echo \" Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ \" , $ secondaryMax , \" STRNEWLINE \" ; } $ matrix = array ( array ( 1 , 2 , 3 , 4 , -10 ) , array ( 5 , 6 , 7 , 8 , 6 ) , array ( 1 , 2 , 11 , 3 , 4 ) , array ( 5 , 6 , 70 , 5 , 8 ) , array ( 4 , 9 , 7 , 1 , -5 ) ) ; diagonalsMinMax ( $ matrix ) ; ? >"}
{"text": "Carian Sequential Diindeks | Program PHP untuk carian berurutan yang diindeks; Menyimpan elemen; Menyimpan indeks; Kod pemacu; Elemen untuk mencari; Panggilan fungsi", "code": "< ? php function indexedSequentialSearch ( $ arr , $ n , $ k ) { $ elements = array ( ) ; $ indices = array ( ) ; $ temp = array ( ) ; $ j = 0 ; $ ind = 0 ; $ start = 0 ; $ end = 0 ; $ set = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i += 3 ) { $ elements [ $ ind ] = $ arr [ $ i ] ; $ indices [ $ ind ] = $ i ; $ ind ++ ; } if ( $ k < $ elements [ 0 ] ) { echo \" Not ▁ found \" ; } else { for ( $ i = 1 ; $ i <= $ ind ; $ i ++ ) if ( $ k < $ elements [ $ i ] ) { $ start = $ indices [ $ i - 1 ] ; $ set = 1 ; $ end = $ indices [ $ i ] ; break ; } } if ( $ set == 1 ) { $ start = $ indices [ $ i - 1 ] ; $ end = $ n ; } for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { if ( $ k == $ arr [ $ i ] ) { $ j = 1 ; break ; } } if ( $ j == 1 ) echo \" Found ▁ at ▁ index ▁ \" , $ i ; else echo \" Not ▁ found \" ; } $ arr = array ( 6 , 7 , 8 , 9 , 10 ) ; $ n = count ( $ arr ) ; $ k = 8 ; indexedSequentialSearch ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Bilangan segmen di mana semua elemen lebih besar daripada x | Berfungsi untuk mengira bilangan segmen; Melangkah dalam array; Semak jika elemen array lebih besar kemudian x atau tidak; Jika bendera adalah benar; Selepas Peralihan Lengkap untuk segmen terakhir; Kod pemacu", "code": "< ? php function countSegments ( $ a , $ n , $ x ) { $ flag = false ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ x ) { $ flag = true ; } else { if ( $ flag ) $ count += 1 ; $ flag = false ; } } if ( $ flag ) $ count += 1 ; return $ count ; } $ a = array ( 8 , 25 , 10 , 19 , 19 , 18 , 20 , 11 , 18 ) ; $ n = sizeof ( $ a ) ; $ x = 13 ; echo countSegments ( $ a , $ n , $ x ) ; ? >"}
{"text": "Count Triplets (A, B, C) supaya A + B, B + C dan A + C semuanya boleh dibahagikan dengan k | Fungsi untuk mencari persamaan kuadrat yang akarnya adalah A dan B; berulang untuk semua pasangan tiga (i, j, l); Sekiranya keadaan itu berpuas hati; Kod pemacu", "code": "< ? php function count_triples ( $ n , $ k ) { $ i = 0 ; $ j = 0 ; $ l = 0 ; $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { for ( $ l = 1 ; $ l <= $ n ; $ l ++ ) { if ( ( $ i + $ j ) % $ k == 0 && ( $ i + $ l ) % $ k == 0 && ( $ j + $ l ) % $ k == 0 ) $ count ++ ; } } } return $ count ; } $ n = 3 ; $ k = 2 ; $ ans = count_triples ( $ n , $ k ) ; echo ( $ ans ) ; ? >"}
{"text": "KTH terkecil / terbesar dalam pelbagai kecil yang tidak disusun | Program PHP KTH terkecil / terbesar dalam pelbagai kecil yang tidak disusun; Menyimpan tuduhan elemen; TRAVERSE Hash Array membina di atas sehingga kita mencapai elemen terkecil. ; Kod pemacu", "code": "< ? php $ maxs = 1000001 ; function kthSmallestLargest ( & $ arr , $ n , $ k ) { global $ maxs ; $ max_val = max ( $ arr ) ; $ hash = array_fill ( 0 , $ max_val + 1 , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ hash [ $ arr [ $ i ] ] ++ ; $ count = 0 ; for ( $ i = 0 ; $ i <= $ max_val ; $ i ++ ) { while ( $ hash [ $ i ] > 0 ) { $ count ++ ; if ( $ count == $ k ) return $ i ; $ hash [ $ i ] -- ; } } return -1 ; } $ arr = array ( 11 , 6 , 2 , 9 , 4 , 3 , 16 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; $ k = 3 ; echo \" kth ▁ smallest ▁ number ▁ is : ▁ \" . kthSmallestLargest ( $ arr , $ n , $ k ) . \" STRNEWLINE \" ; return 0 ; ? >"}
{"text": "Meta Binary Search | Satu | Berfungsi untuk menunjukkan kerja carian binari meta; Menetapkan bilangan bit untuk mewakili; Indeks array terbesar Ini berlebihan dan akan menyebabkan kesilapan bagi sesetengah kes sementara ((1 << $ lg) <$ n - 1) $ lg += 1; ; Secara bertahap membina indeks nilai sasaran; Cari elemen dalam satu arah dan kemas kini kedudukan $; Jika elemen dijumpai pulangan $ POS sebaliknya - 1; Kod pemacu", "code": "< ? php function bsearch ( $ A , $ key_to_search , $ n ) { $ lg = log ( $ n - 1 , 2 ) + 1 ; $ pos = 0 ; for ( $ i = $ lg - 1 ; $ i >= 0 ; $ i -- ) { if ( $ A [ $ pos ] == $ key_to_search ) return $ pos ; $ new_pos = $ pos | ( 1 << $ i ) ; if ( ( $ new_pos < $ n ) && ( $ A [ $ new_pos ] <= $ key_to_search ) ) $ pos = $ new_pos ; } return ( ( $ A [ $ pos ] == $ key_to_search ) ? $ pos : -1 ) ; } $ A = [ -2 , 10 , 100 , 250 , 32315 ] ; $ ans = bsearch ( $ A , 10 , 5 ) ; echo $ ans ; ? >"}
{"text": "Median dari dua susunan yang disusun dengan saiz yang berbeza | Tetapkan 1 (linear) | Fungsi ini mengembalikan median A [] dan B []. Andaian dalam fungsi ini: Kedua -dua [] dan B [] disusun array; Indeks semasa I / P Array A []; Indeks semasa Arus I / P B []; Di bawah ini adalah untuk mengendalikan kes di mana semua elemen A [] lebih kecil daripada elemen terkecil (atau pertama) B [] atau A [] kosong; Di bawah ini adalah untuk mengendalikan kes di mana semua elemen B [] lebih kecil daripada elemen terkecil (atau pertama) A [] atau B [] kosong; Di bawah ini adalah untuk mengendalikan kes di mana jumlah bilangan unsur tatasusunan adalah walaupun; Di bawah ini adalah untuk mengendalikan kes di mana jumlah bilangan unsur tatasusunan adalah ganjil; Kod pemacu", "code": "< ? php function findmedian ( $ a , $ n1 , $ b , $ n2 ) { $ i = 0 ; $ j = 0 ; $ k ; $ m1 = -1 ; $ m2 = -1 ; for ( $ k = 0 ; $ k <= ( $ n1 + $ n2 ) / 2 ; $ k ++ ) { if ( $ i < $ n1 and $ j < $ n2 ) { if ( $ a [ $ i ] < $ b [ $ j ] ) { $ m2 = $ m1 ; $ m1 = $ a [ $ i ] ; $ i ++ ; } else { $ m2 = $ m1 ; $ m1 = $ b [ $ j ] ; $ j ++ ; } } else if ( i == n1 ) { $ m2 = $ m1 ; $ m1 = $ b [ j ] ; $ j ++ ; } else if ( $ j == $ n2 ) { $ m2 = $ m1 ; $ m1 = $ a [ $ i ] ; $ i ++ ; } } if ( ( $ n1 + $ n2 ) % 2 == 0 ) return ( $ m1 + $ m2 ) * 1.0 / 2 ; return m1 ; } $ a = array ( 1 , 12 , 15 , 26 , 38 ) ; $ b = array ( 2 , 13 , 24 ) ; $ n1 = count ( $ a ) ; $ n2 = count ( $ b ) ; echo ( findmedian ( $ a , $ n1 , $ b , $ n2 ) ) ; ? >"}
{"text": "Elemen yang lebih kecil seterusnya | cetak elemen dan pasangan NSE untuk semua elemen arr [] saiz n; Kod pemacu", "code": "< ? php function printNSE ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ next = -1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] > $ arr [ $ j ] ) { $ next = $ arr [ $ j ] ; break ; } } echo $ arr [ $ i ] . \" -- \" . ▁ $ next . \" \" } } $ arr = array ( 11 , 13 , 21 , 3 ) ; $ n = count ( $ arr ) ; printNSE ( $ arr , $ n ) ; ? >"}
{"text": "Subarray terpanjang supaya perbezaan max dan min berada di | Kod PHP untuk mencari subarray terpanjang dengan perbezaan antara max dan min sebagai - paling 1 .; panjang jarak tetap terpanjang; nombor pertama; Sekiranya kita melihat nombor yang sama; Jika kita melihat nombor yang berbeza, tetapi sama seperti sebelumnya. ; Jika nombor tidak sama seperti sebelumnya atau semasa. ; Kod pemacu", "code": "< ? php function longestSubarray ( $ input , $ length ) { $ prev = -1 ; $ prevCount = 0 ; $ currentCount = 1 ; $ longest = 1 ; $ current = $ input [ 0 ] ; for ( $ i = 1 ; $ i < $ length ; $ i ++ ) { $ next = $ input [ $ i ] ; if ( $ next == $ current ) { $ currentCount ++ ; } else if ( $ next == $ prev ) { $ prevCount += $ currentCount ; $ prev = $ current ; $ current = $ next ; $ currentCount = 1 ; } else { $ longest = max ( $ longest , $ currentCount + $ prevCount ) ; $ prev = $ current ; $ prevCount = $ currentCount ; $ current = $ next ; $ currentCount = 1 ; } } return max ( $ longest , $ currentCount + $ prevCount ) ; } $ input = array ( 5 , 5 , 6 , 7 , 6 ) ; echo ( longestSubarray ( $ input , count ( $ input ) ) ) ; ? >"}
{"text": "Subarray terpanjang dengan elemen pertama lebih besar daripada atau sama dengan elemen terakhir | Fungsi carian untuk mencari elemen pertama subarray yang lebih besar atau sama dengan elemen terakhir (NUM); Mengembalikan panjang array terpanjang dengan elemen pertama yang lebih kecil daripada elemen terakhir. ; Pada mulanya ruang carian kosong. ; Kami akan menambah elemen ITH di ruang carian jika ruang carian kosong atau jika elemen ITH lebih besar daripada elemen terakhir ruang carian. ; Kami akan mencari elemen indeks pertama di ruang carian dan kami akan menggunakannya mencari indeksnya dalam array asal. ; Kemas kini jawapan jika panjang subarray lebih besar daripada panjang yang dikira sebelumnya. ; Kod pemacu", "code": "< ? php function binarySearch ( $ searchSpace , $ s , $ e , $ num ) { $ ans = 0 ; while ( $ s <= $ e ) { $ mid = ( $ s + $ e ) / 2 ; if ( $ searchSpace [ $ mid ] >= $ num ) { $ ans = $ mid ; $ e = $ mid - 1 ; } else { $ s = $ mid + 1 ; } } return $ ans ; } function longestSubArr ( & $ arr , $ n ) { $ j = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ j == 0 or $ searchSpace [ $ j - 1 ] < $ arr [ $ i ] ) { $ searchSpace [ $ j ] = $ arr [ $ i ] ; $ index [ $ j ] = $ i ; $ j ++ ; } $ idx = binarySearch ( $ searchSpace , 0 , $ j - 1 , $ arr [ $ i ] ) ; $ ans = max ( $ ans , $ i - $ index [ $ idx ] + 1 ) ; } return $ ans ; } $ arr = array ( -5 , -1 , 7 , 5 , 1 , -2 ) ; $ n = sizeof ( $ arr ) ; echo ( longestSubArr ( $ arr , $ n ) ) ; ? >"}
{"text": "Semak jika rentetan adalah akhiran yang lain | Program PHP untuk mencari jika rentetan adalah akhiran yang lain; Kod pemacu; Kes Ujian - Pelaksanaan Sensitif Fungsi EndSwith", "code": "< ? php function isSuffix ( $ s1 , $ s2 ) { $ n1 = ( $ s1 ) ; $ n2 = strlen ( $ s2 ) ; if ( $ n1 > $ n2 ) return false ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) if ( $ s1 [ $ n1 - $ i - 1 ] != $ s2 [ $ n2 - $ i - 1 ] ) return false ; return true ; } $ s1 = \" geeks \" ; $ s2 = \" geeksforgeeks \" ; $ result = isSuffix ( $ s1 , $ s2 ) ; if ( $ result ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak jika semua kejadian watak muncul bersama | Untuk menunjukkan sama ada satu atau lebih kejadian 'C' dilihat atau tidak. ; Traverse diberikan rentetan; Jika watak semasa adalah sama dengan C, kita mula -mula memeriksa sama ada C telah dilihat. ; Jika ini adalah penampilan pertama C, kita melintasi semua kejadian berturut -turut. ; Untuk menunjukkan bahawa watak itu dilihat sekali. ; Kod pemacu", "code": "< ? php $ oneSeen = false ; $ i = 0 ; $ n = strlen ( $ s ) ; while ( $ i < $ n ) { if ( $ s [ $ i ] == $ c ) { if ( $ oneSeen == true ) return false ; while ( $ i < $ n && $ s [ $ i ] == $ c ) $ i ++ ; $ oneSeen = true ; } else $ i ++ ; } return true ; } $ s = \"110029\" ; if ( checkIfAllTogether ( $ s , '1' ) ) echo ( \" Yes STRNEWLINE \" ) ; else echo ( \" No STRNEWLINE \" ) ; ? >"}
{"text": "Carian depan dan belakang dalam array yang tidak disusun | Program PHP untuk melaksanakan carian depan dan belakang; Mula mencari dari kedua -dua hujung; Terus mencari sementara dua indeks tidak menyeberang. ; Kod pemacu", "code": "< ? php function search ( $ arr , $ n , $ x ) { $ front = 0 ; $ back = $ n - 1 ; while ( $ front <= $ back ) { if ( $ arr [ $ front ] == $ x $ arr [ $ back ] == $ x ) return true ; $ front ++ ; $ back -- ; } return false ; } $ arr = array ( 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ) ; $ x = 130 ; $ n = sizeof ( $ arr ) ; if ( search ( $ arr , $ n , $ x ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Malah | Program PHP untuk mencari max (x, y) / min (x, y) selepas p beralih; 1 kes ujian; Kes ujian 2 nd", "code": "< ? php function findValue ( $ X , $ Y , $ P ) { if ( $ P % 2 == 0 ) return ( int ) ( max ( $ X , $ Y ) / min ( $ X , $ Y ) ) ; else return ( int ) ( max ( 2 * $ X , $ Y ) / min ( 2 * $ X , $ Y ) ) ; } $ X = 1 ; $ Y = 2 ; $ P = 1 ; echo findValue ( $ X , $ Y , $ P ) , \" STRNEWLINE \" ; $ X = 3 ; $ Y = 7 ; $ P = 2 ; echo findValue ( $ X , $ Y , $ P ) , \" STRNEWLINE \" ; ? >"}
{"text": "Masalah partition pelukis | fungsi untuk mengira jumlah antara dua indeks dalam pelbagai; bawah tabular dp; memulakan jadual; Kes asas k = 1; n = 1; 2 hingga K partisi; Jejak minimum; I - 1 pemisah sebelum kedudukan ARR [p = 1. j]; diperlukan; Kod pemacu; Kirakan saiz array.", "code": "< ? php function sum ( $ arr , $ from , $ to ) { $ total = 0 ; for ( $ i = $ from ; $ i <= $ to ; $ i ++ ) $ total += $ arr [ $ i ] ; return $ total ; } function findMax ( $ arr , $ n , $ k ) { $ dp [ $ k + 1 ] [ $ n + 1 ] = array ( 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ dp [ 1 ] [ $ i ] = sum ( $ arr , 0 , $ i - 1 ) ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) $ dp [ $ i ] [ 1 ] = $ arr [ 0 ] ; for ( $ i = 2 ; $ i <= $ k ; $ i ++ ) { $ best = PHP_INT_MAX ; for ( $ p = 1 ; $ p <= $ j ; $ p ++ ) $ best = min ( $ best , max ( $ dp [ $ i - 1 ] [ $ p ] , sum ( $ arr , $ p , $ j - 1 ) ) ) ; $ dp [ $ i ] [ $ j ] = $ best ; } } return $ dp [ $ k ] [ $ n ] ; } $ arr = array ( 10 , 20 , 60 , 50 , 30 , 40 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; echo findMax ( $ arr , $ n , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text": "Mengira garis salib dalam array | Fungsi pulangan fungsi salib dalam array; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; peningkatan garis silang oleh satu; Kod pemacu", "code": "< ? php function countCrossLine ( $ arr , $ n ) { $ count_crossline = 0 ; $ i ; $ key ; $ j ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ key = $ arr [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 and $ arr [ $ j ] > $ key ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ j = $ j - 1 ; $ count_crossline ++ ; } $ arr [ $ j + 1 ] = $ key ; } return $ count_crossline ; } $ arr = array ( 4 , 3 , 1 , 2 ) ; $ n = count ( $ arr ) ; echo countCrossLine ( $ arr , $ n ) ; ? >"}
{"text": "Program rekursif untuk mencari elemen minimum dan maksimum array | berfungsi untuk mengembalikan elemen maksimum menggunakan rekursi; Jika n = 0 bermaksud pelbagai array telah dilalui; Kod pemacu; Fungsi panggilan", "code": "< ? php function findMaxRec ( $ A , $ n ) { if ( $ n == 1 ) return $ A [ 0 ] ; return max ( $ A [ $ n - 1 ] , findMaxRec ( $ A , $ n - 1 ) ) ; } $ A = array ( 1 , 4 , 45 , 6 , -50 , 10 , 2 ) ; $ n = sizeof ( $ A ) ; echo findMaxRec ( $ A , $ n ) ; ? >"}
{"text": "Panjang minimum persegi untuk mengandungi sekurang -kurangnya separuh daripada koordinat yang diberikan | Fungsi untuk mengira nilai mutlak; Fungsi untuk mengira nilai minimum m; Untuk menyimpan m minimum untuk setiap titik dalam array; Susun array; Indeks di mana titik yang diperlukan adalah di dalam kuadrat panjang 2 * m; Kod pemacu", "code": "< ? php function mod ( $ x ) { if ( $ x >= 0 ) return $ x ; return - $ x ; } function findSquare ( $ n ) { $ points = array ( array ( 1 , 2 ) , array ( -3 , 4 ) , array ( 1 , 78 ) , array ( -3 , -7 ) ) ; $ a [ $ n ] = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x ; $ y ; $ x = $ points [ $ i ] [ 0 ] ; $ y = $ points [ $ i ] [ 1 ] ; $ a [ $ i ] = max ( mod ( $ x ) , mod ( $ y ) ) ; } sort ( $ a ) ; $ index = floor ( $ n / 2 ) - 1 ; echo \" Minimum ▁ M ▁ required ▁ is : ▁ \" , $ a [ $ index ] , \" STRNEWLINE \" ; } $ N = 4 ; findSquare ( $ N ) ; ? >"}
{"text": "Sort Even and Odd diletakkan elemen dalam peningkatan urutan | berfungsi untuk menggabungkan digit yang ganjil dan juga diindeks; senarai untuk menyimpan digit yang ganjil dan juga diposisikan; melintasi semua indeks dalam integer; Jika digit berada dalam kedudukan ODD_INDEX masukkannya ke senarai ODD_POSITION; lain menambahkannya ke senarai Even_position; Cetak elemen dalam senarai dalam urutan yang disusun; Kod pemacu", "code": "< ? php function odd_even ( $ n ) { $ odd_indexes = array ( ) ; $ even_indexes = array ( ) ; for ( $ i = 0 ; $ i < sizeof ( $ n ) ; $ i ++ ) { if ( $ i % 2 == 0 ) array_push ( $ odd_indexes , $ n [ $ i ] ) ; else array_push ( $ even_indexes , $ n [ $ i ] ) ; } sort ( $ odd_indexes ) ; for ( $ i = 0 ; $ i < sizeof ( $ odd_indexes ) ; $ i ++ ) echo $ odd_indexes [ $ i ] , \" ▁ \" ; sort ( $ even_indexes ) ; for ( $ i = 0 ; $ i < sizeof ( $ even_indexes ) ; $ i ++ ) echo $ even_indexes [ $ i ] , \" ▁ \" ; } $ n = array ( 3 , 2 , 7 , 6 , 8 ) ; odd_even ( $ n ) ; ? >"}
{"text": "Peningkatan minimum di sisi yang diperlukan untuk mendapatkan bukan | Berfungsi untuk mengembalikan peningkatan minimum dalam panjang sampingan segitiga; Tolak tiga sisi ke array; Susun array; Semak sama ada jumlahnya lebih besar daripada pihak ketiga; Kod pemacu", "code": "< ? php function minimumIncrease ( $ a , $ b , $ c ) { $ arr = array ( $ a , $ b , $ c ) ; sort ( $ arr ) ; if ( $ arr [ 0 ] + $ arr [ 1 ] >= $ arr [ 2 ] ) return 0 ; else return $ arr [ 2 ] - ( $ arr [ 0 ] + $ arr [ 1 ] ) ; } $ a = 3 ; $ b = 5 ; $ c = 10 ; echo minimumIncrease ( $ a , $ b , $ c ) ; ? >"}
{"text": "Jumlah minimum perbezaan dengan elemen dalam array | berfungsi untuk mencari min jumlah selepas operasi; Susun array; Memilih nilai tengah; Jumlah perbezaan mutlak. ; Kod pemacu", "code": "< ? php function absSumDidd ( $ a , $ n ) { sort ( $ a ) ; $ midValue = $ a [ ( $ n / 2 ) ] ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + abs ( $ a [ $ i ] - $ midValue ) ; } return $ sum ; } $ arr = array ( 5 , 11 , 14 , 10 , 17 , 15 ) ; $ n = count ( $ arr ) ; echo absSumDidd ( $ arr , $ n ) ; ? >"}
{"text": "Kira berikutnya dalam rentetan pertama yang merupakan anagrams rentetan kedua | Pelaksanaan PHP untuk mengira berikutnya dalam $ pertama yang merupakan anagrams rentetan kedua; Pulangan nilai pekali binomial c (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; berfungsi untuk mengira berikutnya dalam rentetan pertama yang merupakan anagrams rentetan kedua; Jadual hash untuk menyimpan frekuensi setiap watak; kekerapan kedai setiap watak 'str1'; kekerapan kedai setiap watak 'str2'; untuk menyimpan jumlah kiraan berikutnya; jika watak (i ​​+ 'a') wujud dalam 'str2'; Sekiranya kekerapan watak ini 'dalam' 'str2' 'dalam u atau sama dengan kekerapannya. ▁ If ▁ its ▁ ▁ frequency ▁ in ▁ ' str1 ' ▁ is ▁ ' n ' ▁ ▁ and ▁ in ▁ ' str2 ' ▁ is ▁ ' r ', then  its contribution will be nCr,  where C is the binomial  coefficient. ; lain kembali 0 kerana tidak ada berikutnya yang merupakan anagram 'str2'; kiraan kiraan yang diperlukan; Kod pemacu", "code": "< ? php $ SIZE = 26 ; function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; } function countSubsequences ( $ str1 , $ str2 ) { global $ SIZE ; $ freq1 = array ( ) ; $ freq2 = array ( ) ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ freq1 [ $ i ] = 0 ; $ freq2 [ $ i ] = 0 ; } $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) $ freq1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ n2 ; $ i ++ ) $ freq2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; $ count = 1 ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) if ( $ freq2 [ $ i ] != 0 ) { if ( $ freq2 [ $ i ] <= $ freq1 [ $ i ] ) $ count = $ count * binomialCoeff ( $ freq1 [ $ i ] , $ freq2 [ $ i ] ) ; else return 0 ; } return $ count ; } $ str1 = \" abacd \" ; $ str2 = \" abc \" ; echo ( \" Count ▁ = ▁ \" . countSubsequences ( $ str1 , $ str2 ) ) ; ? >"}
{"text": "Kira seterusnya panjang tiga dalam rentetan yang diberikan | Berfungsi untuk mencari bilangan kejadian seterusnya panjang tiga dalam rentetan; pembolehubah untuk menyimpan tiada kejadian; gelung untuk mencari watak pertama; gelung untuk mencari watak 2 nd; gelung untuk mencari watak 3 rd; kiraan kenaikan jika seterusnya dijumpai; Kod pemacu", "code": "< ? php function findOccurrences ( $ str , $ substr ) { $ counter = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == $ substr [ 0 ] ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) { if ( $ str [ $ j ] == $ substr [ 1 ] ) { for ( $ k = $ j + 1 ; $ k < strlen ( $ str ) ; $ k ++ ) { if ( $ str [ $ k ] == $ substr [ 2 ] ) $ counter ++ ; } } } } } return $ counter ; } $ str = \" GFGFGYSYIOIWIN \" ; $ substr = \" GFG \" ; echo findOccurrences ( $ str , $ substr ) ; ? >"}
{"text": "Kira seterusnya panjang tiga dalam rentetan yang diberikan | Berfungsi untuk mencari bilangan kejadian seterusnya panjang tiga dalam rentetan; Hitung panjang rentetan; Arahan tambahan untuk menyimpan kejadian watak pertama; pelbagai tambahan untuk menyimpan kejadian watak ketiga; Kirakan kejadian watak pertama sehingga indeks ith dari kiri; Kirakan kejadian watak ketiga sehingga indeks ITH dari kanan; pembolehubah untuk menyimpan jumlah kejadian; gelung untuk mencari kejadian elemen tengah; jika watak tengah seterusnya didapati dalam rentetan; Mengalikan jumlah kejadian watak pertama sebelum watak pertengahan dengan jumlah kejadian watak ketiga selepas watak pertengahan; Kod pemacu", "code": "< ? php function findOccurrences ( $ str , $ substr ) { $ n = strlen ( $ str ) ; $ preLeft = array ( 0 ) ; $ preRight = array ( 0 ) ; if ( $ str [ 0 ] == $ substr [ 0 ] ) $ preLeft [ 0 ] ++ ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ substr [ 0 ] ) $ preLeft [ $ i ] = $ preLeft [ $ i - 1 ] + 1 ; else $ preLeft [ $ i ] = $ preLeft [ $ i - 1 ] ; } if ( $ str [ $ n - 1 ] == $ substr [ 2 ] ) $ preRight [ $ n - 1 ] ++ ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] == $ substr [ 2 ] ) $ preRight [ $ i ] = ( $ preRight [ $ i + 1 ] + 1 ) ; else $ preRight [ $ i ] = $ preRight [ $ i + 1 ] ; } $ counter = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ str [ $ i ] == $ str [ 1 ] ) { $ total = $ preLeft [ $ i - 1 ] * $ preRight [ $ i + 1 ] ; $ counter += $ total ; } } return $ counter ; } $ str = \" GFGFGYSYIOIWIN \" ; $ substr = \" GFG \" ; echo findOccurrences ( $ str , $ substr ) ; ? >"}
{"text": "Rentetan terkecil lexicographically yang jarak Hamming dari rentetan yang diberikan adalah betul -betul k | berfungsi untuk mencari rentetan terkecil secara leksikografi dengan jarak Hamming K; Jika k adalah 0, rentetan input output; Menyalin rentetan input ke rentetan output; Melintasi semua watak rentetan; Jika watak semasa tidak 'a'; Salin aksara 'A' ke rentetan output; str2 [i] = 'a'; ; Jika jarak Hamming menjadi k, rehat; ; Jika k kurang daripada p; Melintasi rentetan dalam urutan terbalik; Kod pemacu", "code": "< ? php function findString ( $ str , $ n , $ k ) { if ( $ k == 0 ) { echo $ str . \" STRNEWLINE \" ; return ; } $ str2 = $ str ; $ p = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str2 [ $ i ] != ' a ' ) { $ str2 [ $ i ] = ' a ' ; $ p ++ ; p ++ ; if ( $ p == $ k ) break ; } } if ( $ p < $ k ) { for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) if ( $ str [ $ i ] == ' a ' ) { $ str2 [ $ i ] = ' b ' ; $ p ++ ; if ( $ p == $ k ) break ; } } echo $ str2 . \" STRNEWLINE \" ; } $ str = \" pqrs \" ; $ n = strlen ( $ str ) ; $ k = 2 ; findString ( $ str , $ n , $ k ) ; ? >"}
{"text": "Cetak semua rentetan yang boleh dibuat dengan meletakkan ruang | Berfungsi untuk mencetak semua berikutnya; Kod pemacu", "code": "< ? php function printSubsequences ( $ str ) { $ n = strlen ( $ str ) ; $ opsize = pow ( 2 , $ n - 1 ) ; for ( $ counter = 0 ; $ counter < $ opsize ; $ counter ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { echo $ str [ $ j ] ; if ( $ counter & ( 1 << $ j ) ) echo \" ▁ \" ; } echo \" STRNEWLINE \" ; } } $ str = \" ABC \" ; printSubsequences ( $ str ) ; ? >"}
{"text": "Bilangan minimum penghapusan supaya tidak ada dua berturut -turut adalah sama | Fungsi untuk menghitung penghapusan; Jika dua watak berturut -turut adalah sama, padamkan salah satu daripada mereka. ; Kod pemacu; Fungsi panggilan untuk mencetak jawapan", "code": "< ? php function countDeletions ( $ str ) { $ ans = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) - 1 ; $ i ++ ) if ( $ str [ $ i ] == $ str [ $ i + 1 ] ) $ ans ++ ; return $ ans ; } $ str = \" AAABBB \" ; echo countDeletions ( $ str ) ; ? >"}
{"text": "Nth walaupun panjang palindrome | Berfungsi untuk mencari nth walaupun panjang palindrome; String r untuk menyimpan palindrome yang dihasilkan. Inisialisasi sama seperti S; Dalam gelung ini, rentetan R Stores Reverse of String S selepas rentetan S secara berturut -turut. ; Kod pemacu; Panggilan fungsi", "code": "< ? php function evenlength ( $ n ) { $ res = $ n ; for ( $ j = strlen ( $ n ) - 1 ; $ j >= 0 ; -- $ j ) $ res = $ res . $ n [ $ j ] ; return $ res ; } $ n = \"10\" ; echo evenlength ( $ n ) ; ? >"}
{"text": "Tentukan jika rentetan mempunyai semua watak unik | Program PHP untuk menggambarkan rentetan dengan aksara unik menggunakan teknik kekerasan; Jika pada bila -bila masa kita menghadapi 2 aksara yang sama, kembali palsu; Jika tiada watak pendua yang dihadapi, kembali benar; Kod pemacu", "code": "< ? php function uniqueCharacters ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) { if ( $ str [ $ i ] == $ str [ $ j ] ) { return false ; } } } return true ; } $ str = \" GeeksforGeeks \" ; if ( uniqueCharacters ( $ str ) ) { echo \" The ▁ String ▁ \" , $ str , \" ▁ has ▁ all ▁ unique ▁ characters STRNEWLINE \" ; } else { echo \" The ▁ String ▁ \" , $ str , \" ▁ has ▁ duplicate ▁ characters STRNEWLINE \" ; } ? >"}
{"text": "Cari titik yang sama dalam rentetan kurungan | Kaedah untuk mencari indeks yang sama; Simpan bilangan kurungan pembukaan pada setiap indeks; Simpan bilangan kurungan penutup pada setiap indeks; Semak sama ada tidak ada pendakap pembukaan atau penutupan; Semak jika terdapat sebarang indeks di mana kedua -dua kurungan adalah sama; Kod pemacu", "code": "< ? php function findIndex ( $ str ) { $ len = strlen ( $ str ) ; $ open = array ( 0 , $ len + 1 , NULL ) ; $ close = array ( 0 , $ len + 1 , NULL ) ; $ index = -1 ; $ open [ 0 ] = 0 ; $ close [ $ len ] = 0 ; if ( $ str [ 0 ] == ' ( ' ) $ open [ 1 ] = 1 ; if ( $ str [ $ len - 1 ] == ' ) ' ) $ close [ $ len - 1 ] = 1 ; for ( $ i = 1 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == ' ( ' ) $ open [ $ i + 1 ] = $ open [ $ i ] + 1 ; else $ open [ $ i + 1 ] = $ open [ $ i ] ; } for ( $ i = $ len - 2 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] == ' ) ' ) $ close [ $ i ] = $ close [ $ i + 1 ] + 1 ; else $ close [ $ i ] = $ close [ $ i + 1 ] ; } if ( $ open [ $ len ] == 0 ) return $ len ; if ( $ close [ 0 ] == 0 ) return 0 ; for ( $ i = 0 ; $ i <= $ len ; $ i ++ ) if ( $ open [ $ i ] == $ close [ $ i ] ) $ index = $ i ; return $ index ; } $ str = \" ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) \" ; echo ( findIndex ( $ str ) ) ; ? >"}
{"text": "Tukar pecahan perpuluhan kepada nombor binari | Berfungsi untuk menukar perpuluhan kepada binari sehingga ketat selepas titik perpuluhan; Mengambil bahagian penting nombor perpuluhan; Ambil nombor perpuluhan bahagian pecahan; Penukaran bahagian penting kepada bersamaan binari; Tambah 0 dalam binari; Rentetan terbalik untuk mendapatkan setara binari asal; Tambah titik sebelum penukaran bahagian pecahan; Penukaran bahagian pecahan kepada bersamaan binari; Cari sedikit seterusnya dalam pecahan; Kod pemacu", "code": "< ? php function decimalToBinary ( $ num , $ k_prec ) { $ binary = \" \" ; $ Integral = ( int ) ( $ num ) ; $ fractional = $ num - $ Integral ; while ( $ Integral ) { $ rem = $ Integral % 2 ; $ binary . = chr ( $ rem + 48 ) ; $ Integral = ( int ) ( $ Integral / 2 ) ; } $ binary = strrev ( $ binary ) ; $ binary . = ' . ' ; while ( $ k_prec -- ) { $ fractional *= 2 ; $ fract_bit = ( int ) $ fractional ; if ( $ fract_bit == 1 ) { $ fractional -= $ fract_bit ; $ binary . = chr ( 1 + 48 ) ; } else $ binary . = chr ( 0 + 48 ) ; } return $ binary ; } $ n = 4.47 ; $ k = 3 ; echo decimalToBinary ( $ n , $ k ) . \" STRNEWLINE \" ; $ n = 6.986 ; $ k = 5 ; echo decimalToBinary ( $ n , $ k ) ; ? >"}
{"text": "Perbezaan Dua Bilangan Besar | Pulangan benar jika Str1 lebih kecil daripada STR2, lain -lain palsu. ; Hitung panjang kedua -dua rentetan; Fungsi untuk mencari perbezaan nombor yang lebih besar; Sebelum meneruskan, pastikan STR1 tidak lebih kecil; Ambil rentetan kosong untuk menyimpan hasil; Hitung panjang kedua -dua rentetan; Pada mulanya membawa sifar; Melintasi akhir kedua -dua rentetan; Adakah matematik sekolah, mengira perbezaan digit semasa dan dibawa; tolak angka yang tersisa Str1 []; jika ($ i> 0 $ sub> 0) Keluarkan sebelum 0 's; rentetan hasil terbalik; Kod pemacu; Panggilan fungsi", "code": "< ? php function isSmaller ( $ str1 , $ str2 ) { $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; if ( $ n1 < $ n2 ) return true ; if ( $ n2 < $ n1 ) return false ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) { if ( $ str1 [ $ i ] < $ str2 [ $ i ] ) return true ; else if ( $ str1 [ $ i ] > $ str2 [ $ i ] ) return false ; } return false ; } function findDiff ( $ str1 , $ str2 ) { if ( isSmaller ( $ str1 , $ str2 ) ) { $ t = $ str1 ; $ str1 = $ str2 ; $ str2 = $ t ; } $ str = \" \" ; $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; $ diff = $ n1 - $ n2 ; $ carry = 0 ; for ( $ i = $ n2 - 1 ; $ i >= 0 ; $ i -- ) { $ sub = ( ( ord ( $ str1 [ $ i + $ diff ] ) - ord ( '0' ) ) - ( ord ( $ str2 [ $ i ] ) - ord ( '0' ) ) - $ carry ) ; if ( $ sub < 0 ) { $ sub = $ sub + 10 ; $ carry = 1 ; } else $ carry = 0 ; $ str . = chr ( $ sub + ord ( \"0\" ) ) ; } for ( $ i = $ n1 - $ n2 - 1 ; $ i >= 0 ; $ i -- ) { if ( $ str1 [ $ i ] == '0' && $ carry > 0 ) { $ str . = \"9\" ; continue ; } $ sub = ( ord ( $ str1 [ $ i ] ) - ord ( '0' ) - $ carry ) ; $ str . = chr ( $ sub + ord ( \"0\" ) ) ; $ carry = 0 ; } return strrev ( $ str ) ; } $ str1 = \"88\" ; $ str2 = \"1079\" ; print ( findDiff ( $ str1 , $ str2 ) ) ; ? >"}
{"text": "Semak jika dua rentetan adalah k | Program PHP yang dioptimumkan untuk memeriksa sama ada dua rentetan adalah k anagram atau tidak. ; Fungsi untuk memeriksa sama ada str1 dan str2 adalah k - anagram atau tidak; Jika kedua -dua rentetan tidak sama panjang maka kembali palsu; Simpan kejadian semua aksara dalam hash_array; Simpan kejadian semua aksara dalam hash_array; Kembali benar jika kiraan kurang daripada atau sama dengan k; Kod pemacu", "code": "< ? php $ MAX_CHAR = 26 ; function areKAnagrams ( $ str1 , $ str2 , $ k ) { global $ MAX_CHAR ; $ n = strlen ( $ str1 ) ; if ( strlen ( $ str2 ) != $ n ) return false ; $ hash_str1 = array ( 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ hash_str1 [ $ str1 [ $ i ] - ' a ' ] ++ ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ hash_str1 [ $ str2 [ $ i ] - ' a ' ] > 0 ) $ hash_str1 [ $ str2 [ $ i ] - ' a ' ] -- ; else $ count ++ ; if ( $ count > $ k ) return false ; } return true ; } $ str1 = \" fodr \" ; $ str2 = \" gork \" ; $ k = 2 ; if ( areKAnagrams ( $ str1 , $ str2 , $ k ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Nth Watak dalam rentetan perpuluhan yang disatukan | Kaedah untuk mendapatkan digit nombor n; Kaedah untuk mengembalikan watak ke dalam rentetan perpuluhan yang disatukan; Jumlah akan menyimpan watak yang melarikan diri sehingga sekarang; Dist akan menyimpan nombor yang melarikan diri sehingga sekarang; gelung untuk panjang nombor; Sembilan * len akan ditingkatkan aksara dan sembilan akan ditambah nombor; memulihkan pembolehubah kepada keadaan yang betul sebelumnya; Dapatkan jarak dari satu digit terakhir kurang nombor maksimum; D akan menyimpan digit DTH nombor semasa; Kaedah akan mengembalikan nombor nombor DTH (Dist + Diff); Kod pemacu", "code": "< ? php function getDigit ( $ N , $ d ) { $ string = strval ( $ N ) ; return $ string [ $ d - 1 ] ; } function getNthChar ( $ N ) { $ sum = 0 ; $ nine = 9 ; $ dist = 0 ; for ( $ len = 1 ; $ len < $ N ; $ len ++ ) { $ sum += $ nine * $ len ; $ dist += $ nine ; if ( $ sum >= $ N ) { $ sum -= $ nine * $ len ; $ dist -= $ nine ; $ N -= $ sum ; break ; } $ nine *= 10 ; } $ diff = ( $ N / $ len ) + 1 ; $ d = $ N % $ len ; if ( $ d == 0 ) $ d = $ len ; return getDigit ( $ dist + $ diff , $ d ) ; } $ N = 251 ; echo getNthChar ( $ N ) ; ? >"}
{"text": "Kira watak pada kedudukan yang sama seperti dalam abjad Inggeris | Berfungsi untuk mengira bilangan aksara pada kedudukan yang sama seperti dalam huruf Inggeris; Melintasi rentetan input; Semak bahawa indeks aksara rentetan adalah sama seperti abjad Bahasa Inggeris dengan menggunakan nilai ASCII dan fakta bahawa semua aksara abjad yang lebih rendah datang bersama -sama dalam urutan yang sama dalam jadual ASCII. Dan sama berlaku untuk kes atas. ; Kod pemacu", "code": "< ? php function findCount ( $ str ) { $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ( $ i == ord ( $ str [ $ i ] ) - ord ( ' a ' ) ) or ( $ i == ord ( $ str [ $ i ] ) - ord ( ' A ' ) ) ) $ result += 1 ; } return $ result ; } $ str = \" AbgdeF \" ; print ( findCount ( $ str ) ) ? >"}
{"text": "Menjana semua rentetan binari dari corak yang diberikan | Fungsi rekursif untuk menjana semua rentetan binari yang dibentuk dengan menggantikan setiap watak wildcard sebanyak 0 atau 1; ganti '? 'oleh' 0 'dan Recurse; ganti '? 'oleh' 1 'dan Recurse; Tidak perlu mundur sebagai rentetan diluluskan oleh nilai kepada fungsi; Kod pemacu", "code": "< ? php function print1 ( $ str , $ index ) { if ( $ index == strlen ( $ str ) ) { echo $ str . \" STRNEWLINE \" ; return ; } if ( $ str [ $ index ] == ' ? ' ) { $ str [ $ index ] = '0' ; print1 ( $ str , $ index + 1 ) ; $ str [ $ index ] = '1' ; print1 ( $ str , $ index + 1 ) ; } else print1 ( $ str , $ index + 1 ) ; } $ str = \"1 ? ? 0?101\" ; print1 ( $ str , 0 ) ; ? >"}
{"text": "Cari digit yang paling kerap tanpa menggunakan Array / String | Fungsi mudah untuk mengira kejadian digit D dalam x; Inisialisasi kiraan digit D; Kiraan kenaikan jika digit semasa adalah sama dengan D; Mengembalikan angka maksimum yang berlaku dalam x; Mengendalikan nombor negatif; Melintasi semua digit; Mengira kejadian digit semasa; Kemas kini max_count dan hasil jika diperlukan; Kod pemacu", "code": "< ? php function countOccurrences ( $ x , $ d ) { $ count = 0 ; while ( $ x ) { if ( $ x % 10 == $ d ) $ count ++ ; $ x = ( int ) ( $ x / 10 ) ; } return $ count ; } function maxOccurring ( $ x ) { if ( $ x < 0 ) $ x = - $ x ; for ( $ d = 0 ; $ d <= 9 ; $ d ++ ) { $ count = countOccurrences ( $ x , $ d ) ; if ( $ count >= $ max_count ) { $ max_count = $ count ; $ result = $ d ; } } return $ result ; } $ x = 1223355 ; echo \" Max ▁ occurring ▁ digit ▁ is ▁ \" . maxOccurring ( $ x ) ; ? >"}
{"text": "Cari subarray maksimum XOR dalam array yang diberikan | Program PHP yang mudah untuk mencari Max Subarray XOR; Memulakan hasil; Pilih titik permulaan subarray; untuk menyimpan xor subarray semasa; Pilih titik akhir subarrays bermula dengan i; Kod pemacu", "code": "< ? php function maxSubarrayXOR ( $ arr , $ n ) { $ ans = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_xor = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ curr_xor = $ curr_xor ^ $ arr [ $ j ] ; $ ans = max ( $ ans , $ curr_xor ) ; } } return $ ans ; } $ arr = array ( 8 , 1 , 2 , 12 ) ; $ n = count ( $ arr ) ; echo \" Max ▁ subarray ▁ XOR ▁ is ▁ \" , maxSubarrayXOR ( $ arr , $ n ) ; ? >"}
{"text": "Memandangkan rentetan, cari yang pertama bukan | Program PHP untuk mencari watak pertama bukan berulang; Hitung kiraan aksara dalam rentetan yang diluluskan; Kaedah mengembalikan indeks watak bukan berulang pertama dalam rentetan. Jika semua aksara mengulangi maka kembali - 1; Kod pemacu", "code": "< ? php $ NO_OF_CHARS = 256 ; $ count = array_fill ( 0 , 200 , 0 ) ; function getCharCountArray ( $ str ) { global $ count ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) ] ++ ; } function firstNonRepeating ( $ str ) { global $ count ; getCharCountArray ( $ str ) ; $ index = -1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ count [ ord ( $ str [ $ i ] ) ] == 1 ) { $ index = $ i ; break ; } } return $ index ; } $ str = \" geeksforgeeks \" ; $ index = firstNonRepeating ( $ str ) ; if ( $ index == -1 ) echo \" Either ▁ all ▁ characters ▁ are \" . \" ▁ repeating ▁ or ▁ string ▁ is ▁ empty \" ; else echo \" First ▁ non - repeating ▁ \" . \" character ▁ is ▁ \" . $ str [ $ index ] ; ? >"}
{"text": "Bahagikan rentetan dalam bahagian yang sama | Berfungsi untuk mencetak bahagian yang sama str; Semak jika rentetan boleh dibahagikan kepada bahagian yang sama; Kirakan saiz bahagian untuk mencari titik pembahagian; Panjang kod pemandu OD rentetan adalah 28; Cetak 4 bahagian yang sama dari rentetan", "code": "< ? php function divideString ( $ str , $ n ) { $ str_size = strlen ( $ str ) ; $ i ; $ part_size ; if ( $ str_size % $ n != 0 ) { echo \" Invalid ▁ Input : ▁ String ▁ size \" ; echo \" ▁ is ▁ not ▁ divisible ▁ by ▁ n \" ; return ; } $ part_size = $ str_size / $ n ; for ( $ i = 0 ; $ i < $ str_size ; $ i ++ ) { if ( $ i % $ part_size == 0 ) echo \" STRNEWLINE \" ; echo $ str [ $ i ] ; } } $ str = \" a _ simple _ divide _ string _ quest \" ; divideString ( $ str , 4 ) ; ? >"}
{"text": "Cari istilah n (contoh eksponensi matriks) | Program PHP untuk mencari terma fungsi rekursif menggunakan eksponensi matriks. ; Fungsi kuasa ini mengembalikan baris pertama {matriks transformasi} ^ n - 1 * vektor awal; Ini adalah matriks identiti. ; Ini adalah matriks transformasi. ; MATRIX Exponentiation untuk mengira kuasa {tmat} ^ n - 1 kedai res dalam matriks \"res\". ; Res Store {Matriks Transformasi} ^ n - 1 Oleh itu, akan menjadi baris pertama res * vektor awal. ; Kod pemacu", "code": "< ? php $ MOD = 1000000009 ; function power ( $ n ) { global $ MOD ; if ( $ n <= 1 ) return 1 ; $ n -- ; $ res = array ( array ( 1 , 0 ) , array ( 0 , 1 ) ) ; $ tMat = array ( array ( 2 , 3 ) , array ( 1 , 0 ) ) ; while ( $ n ) { if ( $ n & 1 ) { $ tmp = array_fill ( 0 , 2 , array_fill ( 0 , 2 , 0 ) ) ; $ tmp [ 0 ] [ 0 ] = ( $ res [ 0 ] [ 0 ] * $ tMat [ 0 ] [ 0 ] + $ res [ 0 ] [ 1 ] * $ tMat [ 1 ] [ 0 ] ) % $ MOD ; $ tmp [ 0 ] [ 1 ] = ( $ res [ 0 ] [ 0 ] * $ tMat [ 0 ] [ 1 ] + $ res [ 0 ] [ 1 ] * $ tMat [ 1 ] [ 1 ] ) % $ MOD ; $ tmp [ 1 ] [ 0 ] = ( $ res [ 1 ] [ 0 ] * $ tMat [ 0 ] [ 0 ] + $ res [ 1 ] [ 1 ] * $ tMat [ 1 ] [ 0 ] ) % $ MOD ; $ tmp [ 1 ] [ 1 ] = ( $ res [ 1 ] [ 0 ] * $ tMat [ 0 ] [ 1 ] + $ res [ 1 ] [ 1 ] * $ tMat [ 1 ] [ 1 ] ) % $ MOD ; $ res [ 0 ] [ 0 ] = $ tmp [ 0 ] [ 0 ] ; $ res [ 0 ] [ 1 ] = $ tmp [ 0 ] [ 1 ] ; $ res [ 1 ] [ 0 ] = $ tmp [ 1 ] [ 0 ] ; $ res [ 1 ] [ 1 ] = $ tmp [ 1 ] [ 1 ] ; } $ n = ( int ) ( $ n / 2 ) ; $ tmp = array_fill ( 0 , 2 , array_fill ( 0 , 2 , 0 ) ) ; $ tmp [ 0 ] [ 0 ] = ( $ tMat [ 0 ] [ 0 ] * $ tMat [ 0 ] [ 0 ] + $ tMat [ 0 ] [ 1 ] * $ tMat [ 1 ] [ 0 ] ) % $ MOD ; $ tmp [ 0 ] [ 1 ] = ( $ tMat [ 0 ] [ 0 ] * $ tMat [ 0 ] [ 1 ] + $ tMat [ 0 ] [ 1 ] * $ tMat [ 1 ] [ 1 ] ) % $ MOD ; $ tmp [ 1 ] [ 0 ] = ( $ tMat [ 1 ] [ 0 ] * $ tMat [ 0 ] [ 0 ] + $ tMat [ 1 ] [ 1 ] * $ tMat [ 1 ] [ 0 ] ) % $ MOD ; $ tmp [ 1 ] [ 1 ] = ( $ tMat [ 1 ] [ 0 ] * $ tMat [ 0 ] [ 1 ] + $ tMat [ 1 ] [ 1 ] * $ tMat [ 1 ] [ 1 ] ) % $ MOD ; $ tMat [ 0 ] [ 0 ] = $ tmp [ 0 ] [ 0 ] ; $ tMat [ 0 ] [ 1 ] = $ tmp [ 0 ] [ 1 ] ; $ tMat [ 1 ] [ 0 ] = $ tmp [ 1 ] [ 0 ] ; $ tMat [ 1 ] [ 1 ] = $ tmp [ 1 ] [ 1 ] ; } return ( $ res [ 0 ] [ 0 ] * 1 + $ res [ 0 ] [ 1 ] * 1 ) % $ MOD ; } $ n = 3 ; echo power ( $ n ) ; ? >"}
{"text": "Tempat k elemen supaya jarak minimum dimaksimumkan | Pulangan benar jika ada kemungkinan untuk mengatur unsur -unsur arr [0 .. n - 1] dengan jarak minimum yang diberikan sebagai pertengahan. ; Letakkan elemen pertama di kedudukan ARR [0]; Mulakan kiraan elemen yang diletakkan. ; Cuba letakkan elemen k dengan jarak minimum pertengahan. ; Letakkan elemen seterusnya jika jarak dari elemen yang diletakkan sebelum ini lebih besar daripada pertengahan semasa; Kembali jika semua elemen diletakkan dengan jayanya; Mengembalikan jarak minimum terbesar untuk elemen k di arr [0. n - 1]. Jika elemen tidak dapat diletakkan, pulangan -1. ; Menyusun kedudukan; Memulakan hasil. ; Pertimbangkan jarak maksimum; Melakukan pencarian binari untuk jarak minimum terbesar; Sekiranya mungkin untuk meletakkan elemen k dengan jarak minimum pertengahan, cari jarak yang lebih tinggi. ; Tukar nilai max variabel ke pertengahan IFF Semua elemen boleh diletakkan dengan jayanya; Jika tidak mungkin untuk meletakkan elemen k, cari jarak yang lebih rendah; Kod pemacu", "code": "< ? php function isFeasible ( $ mid , $ arr , $ n , $ k ) { $ pos = $ arr [ 0 ] ; $ elements = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] - $ pos >= $ mid ) { $ pos = $ arr [ $ i ] ; $ elements ++ ; if ( $ elements == $ k ) return true ; } } return 0 ; } function largestMinDist ( $ arr , $ n , $ k ) { sort ( $ arr ) ; $ res = -1 ; $ left = 1 ; $ right = $ arr [ $ n - 1 ] ; while ( $ left < $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( isFeasible ( $ mid , $ arr , $ n , $ k ) ) { $ res = max ( $ res , $ mid ) ; $ left = $ mid + 1 ; } else $ right = $ mid ; } return $ res ; } $ arr = array ( 1 , 2 , 8 , 4 , 9 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; echo largestMinDist ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Akar persegi integer | Mengembalikan lantai akar persegi x; Kes asas; Melakukan pencarian binari untuk lantai (sqrt (x)); Jika x adalah persegi yang sempurna; Oleh kerana kita memerlukan lantai, kita mengemas kini jawapan apabila pertengahan * pertengahan lebih kecil daripada x, dan bergerak lebih dekat ke sqrt (x); Jika pertengahan * pertengahan lebih besar daripada x; Kod pemacu", "code": "< ? php function floorSqrt ( $ x ) { if ( $ x == 0 $ x == 1 ) return $ x ; $ start = 1 ; $ end = $ x ; $ ans ; while ( $ start <= $ end ) { $ mid = ( $ start + $ end ) / 2 ; if ( $ mid * $ mid == $ x ) return $ mid ; if ( $ mid * $ mid < $ x ) { $ start = $ mid + 1 ; $ ans = $ mid ; } else $ end = $ mid - 1 ; } return $ ans ; } $ x = 11 ; echo floorSqrt ( $ x ) , \" STRNEWLINE \" ; ? >"}
{"text": "Count of Rectangles yang berbeza yang ditulis dalam segitiga sama rata | Berfungsi untuk mengembalikan kiraan segi empat tepat apabila n adalah ganjil; Mengira bilangan titik dalam tahap menegak; Mengira bilangan cara untuk memilih dua mata dalam tahap mendatar I; Gongangkan kedua -duanya untuk mendapatkan bilangan segi empat tepat yang terbentuk pada tahap itu; Mengira bilangan titik dalam tahap menegak; Mengira bilangan cara untuk memilih dua mata dalam tahap mendatar I; Gongangkan kedua -duanya untuk mendapatkan bilangan segi empat tepat yang terbentuk pada tahap itu; Berfungsi untuk mengembalikan kiraan segi empat tepat apabila n adalah walaupun; Kod pemacu; Sekiranya N adalah ganjil", "code": "< ? php function countOdd ( $ n ) { $ coun = 0 ; for ( $ i = $ n - 2 ; $ i >= 1 ; $ i -- ) { if ( $ i & 1 ) { $ m = ( $ n - $ i ) / 2 ; $ j = ( $ i * ( $ i + 1 ) ) / 2 ; $ coun += $ j * $ m ; } else { $ m = ( ( $ n - 1 ) - $ i ) / 2 ; $ j = ( $ i * ( $ i + 1 ) ) / 2 ; $ coun += $ j * $ m ; } } return $ coun ; } function countEven ( $ n ) { $ coun = 0 ; for ( $ i = $ n - 2 ; $ i >= 1 ; $ i -- ) { if ( $ i & 1 ) { $ m = ( ( $ n - 1 ) - i ) / 2 ; $ j = ( $ i * ( $ i + 1 ) ) / 2 ; $ coun += $ j * $ m ; } else { $ m = ( $ n - $ i ) / 2 ; $ j = ( $ i * ( $ i + 1 ) ) / 2 ; $ coun += $ j * $ m ; } } return $ coun ; } $ n = 5 ; if ( $ n & 1 ) echo countOdd ( $ n ) ; else echo countEven ( $ n ) ; ? >"}
{"text": "Kawasan elips terbesar yang tertulis dalam segi empat tepat | Berfungsi untuk mencari kawasan elips; Sisi tidak boleh negatif; Kawasan elips; Kod pemacu", "code": "< ? php function ellipse ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ x = ( 3.14 * $ l * $ b ) / 4 ; return $ x ; } $ l = 5 ; $ b = 3 ; echo ellipse ( $ l , $ b ) . \" STRNEWLINE \" ; ? >"}
{"text": "Tentukan bilangan dataran kawasan unit yang akan dilalui. | Berfungsi untuk mengembalikan kedudukan yang diperlukan;  ; Kod pemacu", "code": "< ? php function noOfSquares ( $ x1 , $ y1 , $ x2 , $ y2 ) { $ dx = abs ( $ x2 - $ x1 ) ; $ dy = abs ( $ y2 - $ y1 ) ; $ ans = $ dx + $ dy - gcd ( $ dx , $ dy ) ; echo ( $ ans ) ; } function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } $ x1 = 1 ; $ y1 = 1 ; $ x2 = 4 ; $ y2 = 3 ; noOfSquares ( $ x1 , $ y1 , $ x2 , $ y2 ) ; ? >"}
{"text": "Kira laluan dengan jarak yang sama dengan jarak Manhattan | Berfungsi untuk mengembalikan nilai NCK; Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Berfungsi untuk mengembalikan bilangan laluan; Perbezaan antara koordinat 'X' dari titik -titik yang diberikan; Perbezaan antara koordinat 'y' dari titik -titik yang diberikan; Kod pemacu", "code": "< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; } function countPaths ( $ x1 , $ y1 , $ x2 , $ y2 ) { $ m = abs ( $ x1 - $ x2 ) ; $ n = abs ( $ y1 - $ y2 ) ; return ( binomialCoeff ( $ m + $ n , $ n ) ) ; } { $ x1 = 2 ; $ y1 = 3 ; $ x2 = 4 ; $ y2 = 5 ; echo ( countPaths ( $ x1 , $ y1 , $ x2 , $ y2 ) ) ; }"}
{"text": "Cari kawasan bulatan terbesar yang tertulis dalam Ellipse | Program PHP untuk mencari kawasan bulatan; Kawasan segitiga Reuleaux; Kod pemacu", "code": "< ? php $ GLOBALS [ ' pi ' ] = 3.1415926 ; function areaCircle ( $ b ) { $ area = $ GLOBALS [ ' pi ' ] * $ b * $ b ; return $ area ; } $ a = 10 ; $ b = 8 ; echo round ( areaCircle ( $ b ) , 3 ) ; ? >"}
{"text": "Formula Seksyen untuk 3 D | Berfungsi untuk mencari bahagian garis; Memohon formula seksyen; Hasil percetakan; Kod pemacu", "code": "< ? php function section ( $ x1 , $ x2 , $ y1 , $ y2 , $ z1 , $ z2 , $ m , $ n ) { $ x = ( ( $ m * $ x2 ) + ( $ n * $ x1 ) ) / ( $ m + $ n ) ; $ y = ( ( $ m * $ y2 ) + ( $ n * $ y1 ) ) / ( $ m + $ n ) ; $ z = ( ( $ m * $ z2 ) + ( $ n * $ z1 ) ) / ( $ m + $ n ) ; echo \" ( \" . $ x . \" , \" ; ▁ echo ▁ $ y ▁ . ▁ \" , \" ; ▁ echo ▁ $ z ▁ . ▁ \" ) \" ▁ . \" \" } $ x1 = 2 ; $ x2 = 4 ; $ y1 = -1 ; $ y2 = 3 ; $ z1 = 4 ; $ z2 = 2 ; $ m = 2 ; $ n = 3 ; section ( $ x1 , $ x2 , $ y1 , $ y2 , $ z1 , $ z2 , $ m , $ n ) ;"}
{"text": "Program untuk mencari lingkaran mana -mana poligon biasa | Berfungsi untuk mencari jejari lingkaran; Ini tidak boleh negatif; Jejari circumcircle; Mengembalikan jejari; Kod pemacu; Cari jejari lingkaran", "code": "< ? php function findRadiusOfcircumcircle ( $ n , $ a ) { if ( $ n < 0 $ a < 0 ) return -1 ; $ radius = $ a / sqrt ( 2 - ( 2 * cos ( 360 / $ n ) ) ) ; return $ radius ; } $ n = 5 ; $ a = 6 ; echo findRadiusOfcircumcircle ( $ n , $ a ) ; ? >"}
{"text": "Program untuk mencari jejari incircle segitiga | Berfungsi untuk mencari jejari incircle; Sisi tidak boleh negatif; Semi - perimeter bulatan; kawasan segitiga; Jejari incircle; Mengembalikan jejari; Dapatkan sisi segitiga; Cari jejari yang tidak bulat", "code": "< ? php function findRadiusOfIncircle ( $ a , $ b , $ c ) { if ( $ a < 0 $ b < 0 $ c < 0 ) return -1 ; $ p = ( $ a + $ b + $ c ) / 2 ; $ area = sqrt ( $ p * ( $ p - $ a ) * ( $ p - $ b ) * ( $ p - $ c ) ) ; $ radius = $ area / $ p ; return $ radius ; } $ a = 2 ; $ b = 2 ; $ c = 3 ; echo findRadiusOfIncircle ( $ a , $ b , $ c ) . \" \" ;"}
{"text": "Cari kawasan segitiga jika dua vektor dari dua sisi bersebelahan diberikan | berfungsi untuk mengira kawasan segitiga; Kod pemacu", "code": "< ? php function area ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) { $ area = sqrt ( pow ( ( $ y1 * $ z2 - $ y2 * $ z1 ) , 2 ) + pow ( ( $ x1 * $ z2 - $ x2 * $ z1 ) , 2 ) + pow ( ( $ x1 * $ y2 - $ x2 * $ y1 ) , 2 ) ) ; $ area = $ area / 2 ; return $ area ; } $ x1 = -2 ; $ y1 = 0 ; $ z1 = -5 ; $ x2 = 1 ; $ y2 = -2 ; $ z2 = -1 ; $ a = area ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) ; echo \" Area = \" . $ a ▁ . \" \" ? >"}
{"text": "Trapezoid terbesar yang boleh ditulis dalam separuh bulatan | Berfungsi untuk mencari kawasan trapezoid terbesar; Radius tidak boleh negatif; kawasan trapezoid; Kod pemacu", "code": "< ? php function trapezoidarea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( 3 * sqrt ( 3 ) * pow ( $ r , 2 ) ) / 4 ; return $ a ; } $ r = 5 ; echo trapezoidarea ( $ r ) . \" STRNEWLINE \" ; ? >"}
{"text": "Rectangle terbesar yang boleh ditulis dalam separuh bulatan | Berfungsi untuk mencari kawasan segi empat tepat terbesar; Radius tidak boleh negatif; kawasan segi empat tepat; Kod pemacu", "code": "< ? php function rectanglearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = $ r * $ r ; return $ a ; } $ r = 5 ; echo rectanglearea ( $ r ) . \" STRNEWLINE \" ; ? >"}
{"text": "Garis maksimum yang melewati satu titik | berfungsi untuk mencari garisan maksimum yang melalui satu titik; Kod pemacu", "code": "< ? php function maxLines ( $ n , $ x1 , $ y1 , $ x2 , $ y2 ) { $ s = array ( ) ; $ slope ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ x1 [ $ i ] == $ x2 [ $ i ] ) $ slope = PHP_INT_MAX ; else $ slope = ( $ y2 [ $ i ] - $ y1 [ $ i ] ) * 1.0 / ( $ x2 [ $ i ] - $ x1 [ $ i ] ) * 1.0 ; array_push ( $ s , $ slope ) ; } return count ( $ s ) ; } $ n = 2 ; $ x1 = array ( 1 , 2 ) ; $ y1 = array ( 1 , 2 ) ; $ x2 = array ( 2 , 4 ) ; $ y2 = array ( 2 , 10 ) ; echo maxLines ( $ n , $ x1 , $ y1 , $ x2 , $ y2 ) ; ? >"}
{"text": "Cari kawasan paralelogram jika vektor dua sisi bersebelahan diberikan | Berfungsi untuk mengira kawasan paralelogram; Kod pemacu", "code": "< ? php function area ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) { $ area = sqrt ( pow ( ( $ y1 * $ z2 - $ y2 * $ z1 ) , 2 ) + pow ( ( $ x1 * $ z2 - $ x2 * $ z1 ) , 2 ) + pow ( ( $ x1 * $ y2 - $ x2 * $ y1 ) , 2 ) ) ; return $ area ; } $ x1 = 3 ; $ y1 = 1 ; $ z1 = -2 ; $ x2 = 1 ; $ y2 = -3 ; $ z2 = 4 ; $ a = area ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) ; echo ( \" Area ▁ = ▁ \" ) ; echo ( $ a ) ; ? >"}
{"text": "Persimpangan maksimum yang mungkin dengan memindahkan pusat segmen garis | Berfungsi untuk mencetak persimpangan maksimum; Kes 1; Kes 2; Kes 3; Kod pemacu", "code": "< ? php function max_intersection ( $ center , $ length , $ k ) { sort ( $ center ) ; if ( $ center [ 2 ] - $ center [ 0 ] >= 2 * $ k + $ length ) { return 0 ; } else if ( $ center [ 2 ] - $ center [ 0 ] >= 2 * $ k ) { return ( 2 * $ k - ( $ center [ 2 ] - $ center [ 0 ] - $ length ) ) ; } else return $ length ; } $ center = array ( 1 , 2 , 3 ) ; $ L = 1 ; $ K = 1 ; echo max_intersection ( $ center , $ L , $ K ) ; ? >"}
{"text": "Formula Haversine untuk mencari jarak antara dua mata pada sfera | Program PHP untuk Formula Haversine; jarak antara latitud dan bujur; menukar kepada radian; memohon formula; Kod pemacu", "code": "< ? php function haversine ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) { $ dLat = ( $ lat2 - $ lat1 ) * M_PI / 180.0 ; $ dLon = ( $ lon2 - $ lon1 ) * M_PI / 180.0 ; $ lat1 = ( $ lat1 ) * M_PI / 180.0 ; $ lat2 = ( $ lat2 ) * M_PI / 180.0 ; $ a = pow ( sin ( $ dLat / 2 ) , 2 ) + pow ( sin ( $ dLon / 2 ) , 2 ) * cos ( $ lat1 ) * cos ( $ lat2 ) ; $ rad = 6371 ; $ c = 2 * asin ( sqrt ( $ a ) ) ; return $ rad * $ c ; } $ lat1 = 51.5007 ; $ lon1 = 0.1246 ; $ lat2 = 40.6892 ; $ lon2 = 74.0445 ; echo haversine ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) . \" ▁ K . M . \" ; ? >"}
{"text": "Nombor pentatope | Fungsi yang mengembalikan nombor pentatope nth; Untuk nombor pentatope ke -5; Untuk nombor pentatope ke -11", "code": "< ? php function pentatopeNum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) * ( $ n + 3 ) ) / 24 ; } $ n = 5 ; echo pentatopeNum ( $ n ) , \" STRNEWLINE \" ; $ n = 11 ; echo pentatopeNum ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Nombor Heptagonal | Berfungsi untuk mengembalikan nombor heptagon nth; Kod pemacu", "code": "< ? php function heptagonalNumber ( $ n ) { return ( ( 5 * $ n * $ n ) - ( 3 * $ n ) ) / 2 ; } $ n = 2 ; echo heptagonalNumber ( $ n ) , \" STRNEWLINE \" ; $ n = 15 ; echo heptagonalNumber ( $ n ) ; ? >"}
{"text": "Nombor Icosidigonal | Berfungsi untuk mengira nombor icosidigonal; Formula untuk mencari nombor icosidigonal nth; Kod pemacu", "code": "< ? php function icosidigonal_num ( $ n ) { return ( 20 * $ n * $ n - 18 * $ n ) / 2 ; } $ n = 4 ; echo $ n , \" th ▁ Icosidigonal ▁ number ▁ : ▁ \" , icosidigonal_num ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 8 ; echo $ n , \" th ▁ Icosidigonal ▁ number ▁ : ▁ \" , icosidigonal_num ( $ n ) ; ? >"}
{"text": "Hypercube Graph | Program PHP untuk mencari simpul dalam graf hypercube pesanan n; Fungsi untuk mencari kuasa 2; Kod pemacu", "code": "< ? php { function power ( $ n ) { if ( $ n == 1 ) return 2 ; return 2 * power ( $ n - 1 ) ; } { $ n = 4 ; echo ( power ( $ n ) ) ; } } ? >"}
{"text": "Refleksi titik pada putaran 180 darjah titik lain | Program PHP untuk mencari refleksi 180 darjah satu titik di sekitar titik lain. ; Kod pemacu", "code": "< ? php function findPoint ( $ x1 , $ y1 , $ x2 , $ y2 ) { echo \" ( \" , 2 * $ x2 - $ x1 , \" , ▁ \" , 2 * $ y2 - $ y1 , \" ) \" ; } $ x1 = 0 ; $ y1 = 0 ; $ x2 = 1 ; $ y2 = 1 ; findPoint ( $ x1 , $ y1 , $ x2 , $ y2 ) ; ? >"}
{"text": "Program untuk memeriksa sama ada mata selari dengan paksi x atau paksi y | Untuk memeriksa garis selari; Memeriksa selari dengan keadaan paksi X dan Y; Untuk memaparkan output; Kod pemandu", "code": "< ? php function parallel ( $ n , $ a ) { $ x = true ; $ y = true ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ a [ $ i ] [ 0 ] != $ a [ $ i + 1 ] [ 0 ] ) $ x = false ; if ( $ a [ $ i ] [ 1 ] != $ a [ $ i + 1 ] [ 1 ] ) $ y = false ; } if ( $ x ) echo \" parallel ▁ to ▁ Y ▁ Axis \" ; else if ( y ) echo \" parallel ▁ to ▁ X ▁ Axis \" ; else echo \" Not ▁ parallel ▁ to ▁ X \" , \" ▁ and ▁ Y ▁ Axis \" ; } $ a = array ( array ( 1 , 2 ) , array ( 1 , 4 ) , array ( 1 , 6 ) , array ( 1 , 0 ) ) ; $ n = count ( $ a ) ; parallel ( $ n , $ a ) ; ? >"}
{"text": "Nombor Matchstick Triangular | Program PHP untuk mencari nombor Matchstick TH - TH Triangular; Kod pemacu", "code": "< ? php function numberOfSticks ( $ x ) { return ( 3 * $ x * ( $ x + 1 ) ) / 2 ; } echo ( numberOfSticks ( 7 ) ) ; ? >"}
{"text": "Kawasan persegi yang dilampirkan oleh Circle | Berfungsi untuk mencari kawasan persegi; Jejari bulatan; Fungsi panggilan untuk mencari kawasan persegi", "code": "< ? php function find_Area ( $ r ) { return ( 2 * $ r * $ r ) ; } $ r = 3 ; echo ( \" Area ▁ of ▁ square ▁ = ▁ \" ) ; echo ( find_Area ( $ r ) ) ; ? >"}
{"text": "Semak sama ada segitiga sah atau tidak jika sisi diberikan | berfungsi untuk memeriksa sama ada tiga sider membentuk segitiga atau tidak; periksa keadaan; Kod pemacu; fungsi panggilan dan cetak output", "code": "< ? php function checkValidity ( $ a , $ b , $ c ) { if ( $ a + $ b <= $ c $ a + $ c <= $ b $ b + $ c <= $ a ) return false ; else return true ; } $ a = 7 ; $ b = 10 ; $ c = 5 ; if ( checkValidity ( $ a , $ b , $ c ) ) echo \" Valid \" ; else echo \" Invalid \" ; ? >"}
{"text": "Cari kawasan permukaan Rajah 3D | Mengisytiharkan saiz matriks; Perbezaan mutlak antara ketinggian dua blok berturut -turut; Berfungsi untuk mengira jumlah surfacearea. ; Melintasi matriks. ; Jika kita sedang mengembara baris paling atas dalam matriks, kita mengisytiharkan dinding di atasnya sebagai 0 kerana tidak ada dinding di atasnya. ; Sekiranya kita mengembara lajur paling kiri di dalam matriks, kita mengisytiharkan dinding yang tersisa sebagai 0 kerana tidak ada dinding yang meninggalkannya. ; Jika bukan baris paling atas; Jika bukan lajur paling kiri; Merumuskan sumbangan oleh blok semasa; Jika blok paling kanan matriks ia akan menyumbang kawasan yang sama dengan ketinggiannya sebagai dinding di sebelah kanan angka itu; Jika blok terendah matriks ia akan menyumbang kawasan yang sama dengan ketinggiannya sebagai dinding di bahagian bawah angka; Menambah sumbangan oleh asas dan bahagian atas angka; Kod pemacu", "code": "< ? php $ M = 3 ; $ N = 3 ; function contribution_height ( $ current , $ previous ) { return abs ( $ current - $ previous ) ; } function surfaceArea ( $ A ) { global $ M ; global $ N ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { $ up = 0 ; $ left = 0 ; if ( $ i > 0 ) $ up = $ A [ $ i - 1 ] [ $ j ] ; if ( $ j > 0 ) $ left = $ A [ $ i ] [ $ j - 1 ] ; $ ans += contribution_height ( $ A [ $ i ] [ $ j ] , $ up ) + contribution_height ( $ A [ $ i ] [ $ j ] , $ left ) ; if ( $ i == $ N - 1 ) $ ans += $ A [ $ i ] [ $ j ] ; if ( $ j == $ M - 1 ) $ ans += $ A [ $ i ] [ $ j ] ; } } $ ans += $ N * $ M * 2 ; return $ ans ; } $ A = array ( array ( 1 , 3 , 4 ) , array ( 2 , 2 , 3 ) , array ( 1 , 2 , 4 ) ) ; echo surfaceArea ( $ A ) ;"}
{"text": "Program untuk mengira kawasan dan jumlah tetrahedron | Fungsi utiliti; Kod pemacu", "code": "< ? php function area_of_tetrahedron ( $ side ) { return ( sqrt ( 3 ) * ( $ side * $ side ) ) ; } $ side = 3 ; echo \" Area ▁ of ▁ Tetrahedron ▁ = ▁ \" , area_of_tetrahedron ( $ side ) ; ? >"}
{"text": "Program untuk mengira kawasan dan jumlah tetrahedron | Berfungsi untuk mengira kelantangan; Kod pemacu", "code": "< ? php function vol_tetra ( $ side ) { $ volume = ( pow ( $ side , 3 ) / ( 6 * sqrt ( 2 ) ) ) ; return $ volume ; } $ side = 3 ; $ vol = vol_tetra ( $ side ) ; echo $ vol ; ? >"}
{"text": "Mengira pasangan apabila seseorang boleh membentuk pasangan dengan yang paling satu | Program PHP untuk bilangan cara di mana peserta boleh mengambil bahagian. ; Kod pemacu", "code": "< ? php function numberOfWays ( $ x ) { $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ x ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; return $ dp [ $ x ] ; } $ x = 3 ; echo numberOfWays ( $ x ) ; ? >"}
{"text": "Program untuk mengira kawasan dan perimeter segitiga sama rata | Fungsi untuk mengira kawasan segitiga sama rata; Berfungsi untuk mengira perimeter segitiga sama rata; Kod pemacu", "code": "< ? php function area_equi_triangle ( $ side ) { return sqrt ( 3 ) / 4 * $ side * $ side ; } function peri_equi_triangle ( $ side ) { return 3 * $ side ; } $ side = 4 ; echo ( \" Area ▁ of ▁ Equilateral ▁ Triangle : ▁ \" ) ; echo ( area_equi_triangle ( $ side ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Perimeter ▁ of ▁ Equilateral ▁ Triangle : ▁ \" ) ; echo ( peri_equi_triangle ( $ side ) ) ; ? >"}
{"text": "Program untuk kelantangan dan kawasan permukaan cuboid | fungsi utiliti; Kod pemacu", "code": "< ? php function areaCuboid ( $ l , $ h , $ w ) { return ( $ l * $ h * $ w ) ; } function surfaceAreaCuboid ( $ l , $ h , $ w ) { return ( 2 * $ l * $ w + 2 * $ w * $ h + 2 * $ l * $ h ) ; } $ l = 1 ; $ h = 5 ; $ w = 7 ; echo \" Area ▁ = ▁ \" , areaCuboid ( $ l , $ h , $ w ) , \" STRNEWLINE \" ; echo \" Total ▁ Surface ▁ Area ▁ = ▁ \" , surfaceAreaCuboid ( $ l , $ h , $ w ) ; ? >"}
{"text": "Program untuk mencari lilitan bulatan | Program PHP untuk mencari lilitan bulatan; fungsi utiliti; Kod pemacu", "code": "< ? php $ PI = 3.1415 ; function circumference ( $ r ) { global $ PI ; $ cir = 2 * $ PI * $ r ; return $ cir ; } $ r = 5 ; echo \" Circumference ▁ = ▁ \" , circumference ( $ r ) ;"}
{"text": "Program untuk memeriksa sama ada tiga mata adalah collinear | berfungsi untuk memeriksa sama ada titik collinear atau tidak; Kod pemacu", "code": "< ? php function collinear ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) { if ( ( $ y3 - $ y2 ) * ( $ x2 - $ x1 ) == ( $ y2 - $ y1 ) * ( $ x3 - $ x2 ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; } $ x1 = 1 ; $ x2 = 1 ; $ x3 = 0 ; $ y1 = 1 ; $ y2 = 6 ; $ y3 = 9 ; collinear ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) ; ? >"}
{"text": "Bilangan segi empat tepat dalam n * m grid | Program PHP untuk mengira bilangan segi empat tepat dalam grid n x m; Kod pemacu", "code": "< ? php function rectCount ( $ n , $ m ) { return ( $ m * $ n * ( $ n + 1 ) * ( $ m + 1 ) ) / 4 ; } $ n = 5 ; $ m = 4 ; echo rectCount ( $ n , $ m ) ; ? >"}
{"text": "Bilangan segi empat tepat yang unik yang dibentuk menggunakan dataran unit N | ketinggian> = panjang dikekalkan; Kod pemacu", "code": "< ? php function countRect ( $ n ) { $ ans = 0 ; for ( $ length = 1 ; $ length <= sqrt ( $ n ) ; $ length ++ ) for ( $ height = $ length ; $ height * $ length <= $ n ; $ height ++ ) $ ans ++ ; return $ ans ; } $ n = 5 ; echo countRect ( $ n ) ; ? >"}
{"text": "Cari titik paralelogram yang hilang | Kod pemacu; koordinat a; koordinat B; Koordinat c", "code": "< ? php $ ax = 5 ; $ ay = 0 ; $ bx = 1 ; $ by = 1 ; $ cx = 2 ; $ cy = 5 ; echo $ ax + $ cx - $ bx , \" , ▁ \" , $ ay + $ cy - $ by ; ? >"}
{"text": "Mewakili satu set mata yang diberikan oleh garis lurus yang terbaik | berfungsi untuk mengira m dan c yang paling sesuai dengan titik yang diwakili oleh x [] dan y []; Kod pemacu", "code": "< ? php function bestApproximate ( $ x , $ y , $ n ) { $ i ; $ j ; $ m ; $ c ; $ sum_x = 0 ; $ sum_y = 0 ; $ sum_xy = 0 ; $ sum_x2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum_x += $ x [ $ i ] ; $ sum_y += $ y [ $ i ] ; $ sum_xy += $ x [ $ i ] * $ y [ $ i ] ; $ sum_x2 += ( $ x [ $ i ] * $ x [ $ i ] ) ; } $ m = ( $ n * $ sum_xy - $ sum_x * $ sum_y ) / ( $ n * $ sum_x2 - ( $ sum_x * $ sum_x ) ) ; $ c = ( $ sum_y - $ m * $ sum_x ) / $ n ; echo \" m = \" , ▁ $ m ; STRNEWLINE TABSYMBOL echo ▁ \" c = \" } $ x = array ( 1 , 2 , 3 , 4 , 5 ) ; $ y = array ( 14 , 27 , 40 , 55 , 68 ) ; $ n = sizeof ( $ x ) ; bestApproximate ( $ x , $ y , $ n ) ; ? >"}
{"text": "Semak Grafik Bintang | Tentukan saiz matriks kejadian; berfungsi untuk mencari graf bintang; memulakan bilangan puncak dengan DEG 1 dan N - 1; Semak S1; Semak S2; Semak SN (n> 2); Kod pemacu", "code": "< ? php $ size = 4 ; function checkStar ( $ mat ) { global $ size ; $ vertexD1 = 0 ; $ vertexDn_1 = 0 ; if ( $ size == 1 ) return ( $ mat [ 0 ] [ 0 ] == 0 ) ; if ( $ size == 2 ) return ( $ mat [ 0 ] [ 0 ] == 0 && $ mat [ 0 ] [ 1 ] == 1 && $ mat [ 1 ] [ 0 ] == 1 && $ mat [ 1 ] [ 1 ] == 0 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ degreeI = 0 ; for ( $ j = 0 ; $ j < $ size ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] ) $ degreeI ++ ; if ( $ degreeI == 1 ) $ vertexD1 ++ ; else if ( $ degreeI == $ size - 1 ) $ vertexDn_1 ++ ; } return ( $ vertexD1 == ( $ size - 1 ) && $ vertexDn_1 == 1 ) ; } $ mat = array ( array ( 0 , 1 , 1 , 1 ) , array ( 1 , 0 , 0 , 0 ) , array ( 1 , 0 , 0 , 0 ) , array ( 1 , 0 , 0 , 0 ) ) ; if ( checkStar ( $ mat ) ) echo ( \" Star ▁ Graph \" ) ; else echo ( \" Not ▁ a ▁ Star ▁ Graph \" ) ; ? >"}
{"text": "Langkah minimum untuk meminimumkan n seperti keadaan yang diberikan | Penyelesaian berasaskan tabulasi dalam PHP; Kod pemacu", "code": "< ? php function getMinSteps ( $ n ) { $ table = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] = $ n - $ i ; for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { if ( ! ( $ i % 2 ) ) $ table [ $ i / 2 ] = min ( $ table [ $ i ] + 1 , $ table [ $ i / 2 ] ) ; if ( ! ( $ i % 3 ) ) $ table [ $ i / 3 ] = min ( $ table [ $ i ] + 1 , $ table [ $ i / 3 ] ) ; } return $ table [ 1 ] ; } $ n = 10 ; echo getMinSteps ( $ n ) ; ? >"}
{"text": "Semak jika rentetan adalah nama yang ditaip nama yang diberikan | Periksa sama ada watak itu vokal atau tidak; Pulangan benar jika 'ditaip' adalah nama yang ditaip yang diberikan str; Melintasi semua watak STR. ; Sekiranya aksara semasa tidak sepadan; Jika tidak vokal, hanya bergerak ke hadapan dalam kedua -duanya; Mengira kejadian vokal semasa dalam str; Mengira kejadian vokal semasa dalam ditaip. ; Kod pemacu", "code": "< ? php function isVowel ( $ c ) { $ vowel = \" aeiou \" ; for ( $ i = 0 ; $ i < strlen ( $ vowel ) ; ++ $ i ) if ( $ vowel [ $ i ] == $ c ) return true ; return false ; } function printRLE ( $ str , $ typed ) { $ n = strlen ( $ str ) ; $ m = strlen ( $ typed ) ; $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] != $ typed [ $ j ] ) return false ; if ( isVowel ( $ str [ $ i ] ) == false ) { $ j ++ ; continue ; } $ count1 = 1 ; while ( $ i < $ n - 1 && $ str [ $ i ] == $ str [ $ i + 1 ] ) { $ count1 ++ ; $ i ++ ; } $ count2 = 1 ; while ( $ j < $ m - 1 && $ typed [ $ j ] == $ str [ $ i ] ) { $ count2 ++ ; $ j ++ ; } if ( $ count1 > $ count2 ) return false ; } return true ; } $ name = \" alex \" ; $ typed = \" aaalaeex \" ; if ( printRLE ( $ name , $ typed ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak sama ada darjah simpul yang diberikan mewakili graf atau pokok | Fungsi pulangan benar untuk pokok palsu untuk graf; Cari jumlah semua darjah; Graf adalah pokok jika jumlahnya sama dengan 2 (n - 1); Kod pemacu", "code": "< ? php function check ( & $ degree , $ n ) { $ deg_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ deg_sum += $ degree [ $ i ] ; return ( 2 * ( $ n - 1 ) == $ deg_sum ) ; } $ n = 5 ; $ degree = array ( 2 , 3 , 1 , 1 , 1 ) ; if ( check ( $ degree , $ n ) ) echo \" Tree \" ; else echo \" Graph \" ; ? >"}
{"text": "Semak jika array mewakili inorder pokok carian binari atau tidak | Fungsi yang mengembalikan benar jika array adalah inorder traversal dari mana -mana pokok carian binari atau tidak. ; Array mempunyai satu atau tiada elemen; Pasangan yang tidak disusun dijumpai; Tiada pasangan yang tidak disusun dijumpai; Kod pemacu", "code": "< ? php function isInorder ( $ arr , $ n ) { if ( $ n == 0 $ n == 1 ) return true ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i - 1 ] > $ arr [ $ i ] ) return false ; return true ; } $ arr = array ( 19 , 23 , 25 , 30 , 45 ) ; $ n = sizeof ( $ arr ) ; if ( isInorder ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Percetakan pesanan yang disusun dari array yang diberikan yang mewakili BST | Kod PHP untuk Percetakan Pesanan Diisih dari pelbagai yang mewakili BST; cetak subtree kiri; cetak akar; cetak subtree kanan; Kod pemacu", "code": "< ? php function printSorted ( $ arr , $ start , $ end ) { if ( $ start > $ end ) return ; printSorted ( $ arr , $ start * 2 + 1 , $ end ) ; echo ( $ arr [ $ start ] . \" \" ) ; printSorted ( $ arr , $ start * 2 + 2 , $ end ) ; } $ arr = array ( 4 , 2 , 5 , 1 , 3 ) ; printSorted ( $ arr , 0 , sizeof ( $ arr ) - 1 ) ;"}
{"text": "Nod daun dari preorder pokok carian binari (menggunakan rekursi) | Cetak nod daun dari preorder BST yang diberikan. ; Kod pemacu", "code": "< ? php function isLeaf ( $ pre , & $ i , $ n , $ min , $ max ) { if ( $ i >= $ n ) return false ; if ( $ pre [ $ i ] > $ min && $ pre [ $ i ] < $ max ) { $ i ++ ; $ left = isLeaf ( $ pre , $ i , $ n , $ min , $ pre [ $ i - 1 ] ) ; $ right = isLeaf ( $ pre , $ i , $ n , $ pre [ $ i - 1 ] , $ max ) ; if ( ! $ left && ! $ right ) echo $ pre [ $ i - 1 ] , \" ▁ \" ; return true ; } return false ; } function printLeaves ( $ preorder , $ n ) { $ i = 0 ; isLeaf ( $ preorder , $ i , $ n , PHP_INT_MIN , PHP_INT_MAX ) ; } $ preorder = array ( 890 , 325 , 290 , 530 , 965 ) ; $ n = sizeof ( $ preorder ) ; printLeaves ( $ preorder , $ n ) ; ? >"}
{"text": "Nilai minimum kemungkinan | | AI + AJ | fungsi untuk mencari pasangan dan nilai min; memulakan terkecil dan dikira; melangkah ke atas semua pasangan; Nilai ABS lebih kecil daripada kemas kini terkecil terkecil dan tetapkan semula kepada 1; Jika nilai ABS sama dengan nilai kiraan kenaikan terkecil; hasil cetak; Kod pemacu", "code": "< ? php function pairs ( $ arr , $ n , $ k ) { $ smallest = PHP_INT_MAX ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) < $ smallest ) { $ smallest = abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) ; $ count = 1 ; } else if ( abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) == $ smallest ) $ count ++ ; } echo \" Minimal Value = \" ▁ , ▁ $ smallest ▁ , ▁ \" \" ; STRNEWLINE TABSYMBOL TABSYMBOL echo ▁ \" Total Pairs = \" , ▁ $ count ▁ , ▁ \" \" } $ arr = array ( 3 , 5 , 7 , 5 , 1 , 9 , 9 ) ; $ k = 12 ; $ n = sizeof ( $ arr ) ; pairs ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Pangkat elemen dalam aliran | Kod pemacu", "code": "< ? php $ a = array ( 5 , 1 , 14 , 4 , 15 , 9 , 7 , 20 , 11 ) ; $ key = 20 ; $ arraySize = sizeof ( $ a ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ arraySize ; $ i ++ ) { if ( $ a [ $ i ] <= $ key ) { $ count += 1 ; } } echo \" Rank ▁ of ▁ \" . $ key . \" ▁ in ▁ stream ▁ is : ▁ \" . ( $ count - 1 ) . \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah baris dan lajur tengah dalam matriks | Program PHP untuk mencari jumlah baris dan lajur tengah dalam matriks; gelung untuk jumlah baris; gelung untuk jumlah lajur; Fungsi pemacu", "code": "< ? php function middlesum ( $ mat , $ n ) { $ row_sum = 0 ; $ col_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ row_sum += $ mat [ $ n / 2 ] [ $ i ] ; echo \" Sum ▁ of ▁ middle ▁ row ▁ = ▁ \" , $ row_sum , \" STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ col_sum += $ mat [ $ i ] [ $ n / 2 ] ; echo \" Sum ▁ of ▁ middle ▁ column ▁ = ▁ \" , $ col_sum ; } $ mat = array ( array ( 2 , 5 , 7 ) , array ( 3 , 7 , 2 ) , array ( 5 , 6 , 9 ) ) ; middlesum ( $ mat , 3 ) ; ? >"}
{"text": "Putar matriks kanan oleh k kali | saiz matriks; berfungsi untuk memutar matriks oleh k kali; pelbagai saiz ms sementara; dalam saiz matriks; Salin unsur pertama m - k ke array sementara; Salin unsur -unsur dari k hingga akhir hingga bermula; Salin elemen dari array sementara hingga akhir; berfungsi untuk memaparkan matriks; Kod pemacu; Putar matriks oleh k; Paparkan matriks berputar", "code": "< ? php $ M = 3 ; $ N = 3 ; function rotateMatrix ( & $ matrix , $ k ) { global $ M , $ N ; $ temp = array ( ) ; $ k = $ k % $ M ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ t = 0 ; $ t < $ M - $ k ; $ t ++ ) $ temp [ $ t ] = $ matrix [ $ i ] [ $ t ] ; for ( $ j = $ M - $ k ; $ j < $ M ; $ j ++ ) $ matrix [ $ i ] [ $ j - $ M + $ k ] = $ matrix [ $ i ] [ $ j ] ; for ( $ j = $ k ; $ j < $ M ; $ j ++ ) $ matrix [ $ i ] [ $ j ] = $ temp [ $ j - $ k ] ; } } function displayMatrix ( & $ matrix ) { global $ M , $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) echo ( $ matrix [ $ i ] [ $ j ] . \" ▁ \" ) ; echo ( \" STRNEWLINE \" ) ; } } $ matrix = array ( array ( 12 , 23 , 34 ) , array ( 45 , 56 , 67 ) , array ( 78 , 89 , 91 ) ) ; $ k = 2 ; rotateMatrix ( $ matrix , $ k ) ; displayMatrix ( $ matrix ) ; ? >"}
{"text": "Program untuk memeriksa matriks yang terlibat | Program untuk melaksanakan matriks yang terlibat. ; Fungsi untuk pendaraban matriks. ; Fungsi untuk memeriksa matriks yang terlibat. ; Multiply Function Call. ; Kod pemacu; Panggilan fungsi. Jika fungsi kembali benar maka jika bahagian akan melaksanakan sebaliknya bahagian lain akan dilaksanakan.", "code": "< ? php $ N = 3 ; function multiply ( $ mat , $ res ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ res [ $ i ] [ $ j ] = 0 ; for ( $ k = 0 ; $ k < $ N ; $ k ++ ) $ res [ $ i ] [ $ j ] += $ mat [ $ i ] [ $ k ] * $ mat [ $ k ] [ $ j ] ; } } return $ res ; } function InvolutoryMatrix ( $ mat ) { global $ N ; $ res ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ res [ $ i ] [ $ j ] = 0 ; $ res = multiply ( $ mat , $ res ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ i == $ j && $ res [ $ i ] [ $ j ] != 1 ) return false ; if ( $ i != $ j && $ res [ $ i ] [ $ j ] != 0 ) return false ; } } return true ; } $ mat = array ( array ( 1 , 0 , 0 ) , array ( 0 , -1 , 0 ) , array ( 0 , 0 , -1 ) ) ; if ( InvolutoryMatrix ( $ mat ) ) echo \" Involutory ▁ Matrix \" ; else echo \" Not ▁ Involutory ▁ Matrix \" ; ? >"}
{"text": "Elemen Pertukaran Baris Pertama dan Terakhir di Matrix | Kod PHP untuk menukar elemen baris pertama dan terakhir dan memaparkan hasilnya; menukar elemen antara baris pertama dan terakhir; input dalam array; Mencetak Matriks Terang", "code": "< ? php $ n = 4 ; function interchangeFirstLast ( & $ m ) { global $ n ; $ rows = $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ t = $ m [ 0 ] [ $ i ] ; $ m [ 0 ] [ $ i ] = $ m [ $ rows - 1 ] [ $ i ] ; $ m [ $ rows - 1 ] [ $ i ] = $ t ; } } $ m = array ( array ( 8 , 9 , 7 , 6 ) , array ( 4 , 7 , 6 , 5 ) , array ( 3 , 2 , 1 , 8 ) , array ( 9 , 9 , 7 , 7 ) ) ; interchangeFirstLast ( $ m ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo $ m [ $ i ] [ $ j ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } ? >"}
{"text": "Program untuk Markov Matrix | Kod PHP untuk memeriksa Matriks Markov; gelung luar untuk mengakses baris dan dalaman untuk mengakses lajur; Cari jumlah baris semasa; Matriks untuk memeriksa; Panggil Pemeriksaan Fungsi ()", "code": "< ? php function checkMarkov ( $ m ) { $ n = 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum = $ sum + $ m [ $ i ] [ $ j ] ; if ( $ sum != 1 ) return false ; } return true ; } $ m = array ( array ( 0 , 0 , 1 ) , array ( 0.5 , 0 , 0.5 ) , array ( 1 , 0 , 0 ) ) ; if ( checkMarkov ( $ m ) ) echo \" ▁ yes ▁ \" ; else echo \" ▁ no ▁ \" ; ? >"}
{"text": "Program untuk memeriksa matriks pepenjuru dan matriks skalar | Program untuk memeriksa matriks adalah matriks pepenjuru atau tidak. ; Fungsi untuk memeriksa matriks adalah matriks pepenjuru atau tidak. ; Keadaan untuk memeriksa unsur -unsur lain kecuali pepenjuru utama adalah sifar atau tidak. ; Kod pemacu", "code": "< ? php $ N = 4 ; function isDiagonalMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( ( $ i != $ j ) && ( $ mat [ $ i ] [ $ j ] != 0 ) ) return false ; return true ; } $ mat = array ( array ( 4 , 0 , 0 , 0 ) , array ( 0 , 7 , 0 , 0 ) , array ( 0 , 0 , 5 , 0 ) , array ( 0 , 0 , 0 , 1 ) ) ; if ( isDiagonalMatrix ( $ mat ) ) echo \" Yes \" , \" STRNEWLINE \" ; else echo \" No \" , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk memeriksa matriks pepenjuru dan matriks skalar | Program untuk memeriksa matriks adalah matriks skalar atau tidak. ; Fungsi untuk memeriksa matriks adalah matriks skalar atau tidak. ; Semak semua elemen kecuali pepenjuru utama adalah sifar atau tidak. ; Semak semua elemen pepenjuru adalah sama atau tidak. ; Kod pemacu; Panggilan fungsi", "code": "< ? php $ N = 4 ; function isScalarMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( ( $ i != $ j ) && ( $ mat [ $ i ] [ $ j ] != 0 ) ) return false ; for ( $ i = 0 ; $ i < $ N - 1 ; $ i ++ ) if ( $ mat [ $ i ] [ $ i ] != $ mat [ $ i + 1 ] [ $ i + 1 ] ) return false ; return true ; } $ mat = array ( array ( 2 , 0 , 0 , 0 ) , array ( 0 , 2 , 0 , 0 ) , array ( 0 , 0 , 2 , 0 ) , array ( 0 , 0 , 0 , 2 ) ) ; if ( isScalarMatrix ( $ mat ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak matriks yang diberikan adalah Magic Square atau tidak | Pulangan benar jika Mat [] [] adalah Magic Square, lain -lain mengembalikan palsu. ; hitung jumlah pepenjuru utama; pepenjuru sekunder; Untuk jumlah baris; Semak sama ada setiap baris baris adalah sama dengan jumlah pepenjuru utama; Untuk jumlah lajur; Semak sama ada setiap jumlah lajur adalah sama dengan jumlah pepenjuru utama; Kod pemacu", "code": "< ? php function isMagicSquare ( $ mat ) { $ sum = 0 ; $ N = 3 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ sum = $ sum + $ mat [ $ i ] [ $ i ] ; $ sum2 = 0 ; $ N = 3 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ sum2 = $ sum2 + $ mat [ $ i ] [ $ N - $ i - 1 ] ; if ( $ sum != $ sum2 ) return false ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ rowSum = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ rowSum += $ mat [ $ i ] [ $ j ] ; if ( $ rowSum != $ sum ) return false ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ colSum = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ colSum += $ mat [ $ j ] [ $ i ] ; if ( $ sum != $ colSum ) return false ; } return true ; } { $ mat = array ( array ( 2 , 7 , 6 ) , array ( 9 , 5 , 1 ) , array ( 4 , 3 , 8 ) ) ; if ( isMagicSquare ( $ mat ) ) echo \" Magic ▁ Square \" ; else echo \" Not ▁ a ▁ magic ▁ Square \" ; return 0 ; } ? >"}
{"text": "Count sub | Fungsi untuk mengira semua sub - array yang boleh dibahagikan oleh k; Buat array hash tambahan untuk mengira kekerapan sisa; Melintasi array asal dan mengira jumlah kumulatif mengambil baki jumlah kumulatif semasa dan kenaikan kiraan sebanyak 1 untuk baki ini dalam array mod; Oleh kerana jumlahnya boleh negatif, mengambil modulo dua kali; Memulakan hasil; Traverse Mod; Jika terdapat lebih daripada satu subarray awalan dengan nilai mod tertentu. ; Tambah subarrays bermula dari arr [i] yang boleh dibahagikan oleh K sendiri; fungsi untuk mengira semua sub -matriks yang mempunyai jumlah yang boleh dibahagikan dengan nilai 'k'; Pembolehubah untuk menyimpan output akhir; Tetapkan lajur kiri; Memulakan semua elemen temp sebagai 0; Tetapkan lajur kanan untuk lajur kiri yang ditetapkan oleh Loop Luar; Hitung jumlah antara kiri dan kanan semasa untuk setiap baris 'I'; Kiraan bilangan subarrays dalam temp yang mempunyai jumlah yang boleh dibahagikan dengan 'k' dan kemudian tambahkannya ke 'tot _ count'; kiraan sub -matriks yang diperlukan mempunyai jumlah yang boleh dibahagi dengan 'k'; Kod pemacu", "code": "< ? php function subCount ( $ arr , $ n , $ k ) { $ mod = array ( ) ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ mod [ $ i ] = 0 ; $ cumSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ cumSum += $ arr [ $ i ] ; $ mod [ ( ( $ cumSum % $ k ) + $ k ) % $ k ] ++ ; } $ result = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) if ( $ mod [ $ i ] > 1 ) $ result += ( $ mod [ $ i ] * ( $ mod [ $ i ] - 1 ) ) / 2 ; $ result += $ mod [ 0 ] ; return $ result ; } function countSubmatrix ( $ mat , $ n , $ k ) { $ tot_count = 0 ; $ temp = array ( ) ; for ( $ left = 0 ; $ left < $ n ; $ left ++ ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ temp [ $ i ] = 0 ; for ( $ right = $ left ; $ right < $ n ; $ right ++ ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ temp [ $ i ] += $ mat [ $ i ] [ $ right ] ; $ tot_count += subCount ( $ temp , $ n , $ k ) ; } } return $ tot_count ; } $ mat = array ( array ( 5 , -1 , 6 ) , array ( -2 , 3 , 8 ) , array ( 7 , 4 , -9 ) ) ; $ n = 3 ; $ k = 4 ; echo ( \" Count ▁ = ▁ \" . countSubmatrix ( $ mat , $ n , $ k ) ) ; ? >"}
{"text": "Mengira kekerapan k dalam matriks saiz n di mana matriks (i, j) = i + j | Program PHP untuk mencari kekerapan k dalam matriks di mana m (i, j) = i + j; Kod pemacu", "code": "< ? php function find ( $ n , $ k ) { if ( $ n + 1 >= $ k ) return ( $ k - 1 ) ; else return ( 2 * $ n + 1 - $ k ) ; } $ n = 4 ; $ k = 7 ; $ freq = find ( $ n , $ k ) ; if ( $ freq < 0 ) echo \" ▁ element ▁ not ▁ exist ▁ STRNEWLINE ▁ \" ; else echo \" ▁ Frequency ▁ of ▁ \" , $ k , \" ▁ is ▁ \" , $ freq , \" STRNEWLINE \" ; ? >"}
{"text": "Diberikan 1 's, ~ 2, 3' s. . . . . . K mencetak mereka dengan cara zig zag. | Fungsi yang mencetak bilangan 1 's, ~ 2, 3 s. . . . K di zig - zag cara. ; Arahan dua - dimensi untuk menyimpan nombor. ; Bagi baris. ; untuk setiap lajur. ; menyimpan elemen. ; Elemen pengurangan pada indeks kth. ; Jika array mengandungi sifar maka indeks kenaikan untuk membuat indeks seterusnya; Untuk baris ganjil. ; untuk setiap lajur. ; menyimpan elemen. ; Elemen pengurangan pada indeks kth. ; Jika array mengandungi sifar maka indeks kenaikan untuk membuat indeks seterusnya. ; Mencetak elemen yang disimpan. ; Kod pemacu", "code": "< ? php function ZigZag ( $ rows , $ columns , $ numbers ) { $ k = 0 ; $ arr = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ rows ; $ i ++ ) { if ( $ i % 2 == 0 ) { for ( $ j = 0 ; $ j < $ columns and $ numbers [ $ k ] > 0 ; $ j ++ ) { $ arr [ $ i ] [ $ j ] = $ k + 1 ; $ numbers [ $ k ] -- ; if ( $ numbers [ $ k ] == 0 ) $ k ++ ; } } else { for ( $ j = $ columns - 1 ; $ j >= 0 and $ numbers [ $ k ] > 0 ; $ j -- ) { $ arr [ $ i ] [ $ j ] = $ k + 1 ; $ numbers [ $ k ] -- ; if ( $ numbers [ $ k ] == 0 ) $ k ++ ; } } } for ( $ i = 0 ; $ i < $ rows ; $ i ++ ) { for ( $ j = 0 ; $ j < $ columns ; $ j ++ ) echo $ arr [ $ i ] [ $ j ] , \" ▁ \" ; echo \" STRNEWLINE \" ; } } $ rows = 4 ; $ columns = 5 ; $ Numbers = array ( 3 , 4 , 2 , 2 , 3 , 1 , 5 ) ; ZigZag ( $ rows , $ columns , $ Numbers ) ; ? >"}
{"text": "Bilangan sel Ratu boleh bergerak dengan halangan di Chessborad | Kembalikan bilangan kedudukan yang boleh bergerak ratu. ; D11, D12, D21, D22 adalah untuk jarak diagnoal. R1, R2 adalah untuk jarak menegak. C1, C2 adalah untuk jarak mendatar. ; Memulakan jarak ke hujung papan. ; Untuk setiap halangan cari jarak minimum. Jika halangan hadir dalam mana -mana arah, jarak akan dikemas kini. ; Saiz papan catur; bilangan halangan; Kedudukan Queen X; Kedudukan ratu; X Kedudukan halangan; kedudukan rintangan", "code": "< ? php function numberofPosition ( $ n , $ k , $ x , $ y , $ obstPosx , $ obstPosy ) { $ d11 ; $ d12 ; $ d21 ; $ d22 ; $ r1 ; $ r2 ; $ c1 ; $ c2 ; $ d11 = min ( $ x - 1 , $ y - 1 ) ; $ d12 = min ( $ n - $ x , $ n - $ y ) ; $ d21 = min ( $ n - $ x , $ y - 1 ) ; $ d22 = min ( $ x - 1 , $ n - $ y ) ; $ r1 = $ y - 1 ; $ r2 = $ n - $ y ; $ c1 = $ x - 1 ; $ c2 = $ n - $ x ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { if ( $ x > $ obstPosx [ $ i ] && $ y > $ obstPosy [ $ i ] && $ x - $ obstPosx [ $ i ] == $ y - $ obstPosy [ $ i ] ) $ d11 = min ( $ d11 , $ x - $ obstPosx [ $ i ] - 1 ) ; if ( $ obstPosx [ $ i ] > $ x && $ obstPosy [ $ i ] > $ y && $ obstPosx [ $ i ] - $ x == $ obstPosy [ $ i ] - $ y ) $ d12 = min ( $ d12 , $ obstPosx [ $ i ] - $ x - 1 ) ; if ( $ obstPosx [ $ i ] > $ x && $ y > $ obstPosy [ $ i ] && $ obstPosx [ $ i ] - $ x == $ y - $ obstPosy [ $ i ] ) $ d21 = min ( $ d21 , $ obstPosx [ $ i ] - $ x - 1 ) ; if ( $ x > $ obstPosx [ $ i ] && $ obstPosy [ $ i ] > $ y && $ x - $ obstPosx [ $ i ] == $ obstPosy [ $ i ] - $ y ) $ d22 = min ( $ d22 , $ x - $ obstPosx [ $ i ] - 1 ) ; if ( $ x == $ obstPosx [ $ i ] && $ obstPosy [ $ i ] < $ y ) $ r1 = min ( $ r1 , $ y - $ obstPosy [ $ i ] - 1 ) ; if ( $ x == $ obstPosx [ $ i ] && $ obstPosy [ $ i ] > $ y ) $ r2 = min ( $ r2 , $ obstPosy [ $ i ] - $ y - 1 ) ; if ( $ y == $ obstPosy [ $ i ] && $ obstPosx [ $ i ] < $ x ) $ c1 = min ( $ c1 , $ x - $ obstPosx [ $ i ] - 1 ) ; if ( $ y == $ obstPosy [ $ i ] && $ obstPosx [ $ i ] > $ x ) $ c2 = min ( $ c2 , $ obstPosx [ $ i ] - $ x - 1 ) ; } return $ d11 + $ d12 + $ d21 + $ d22 + $ r1 + $ r2 + $ c1 + $ c2 ; } $ n = 8 ; $ k = 1 ; $ Qposx = 4 ; $ Qposy = 4 ; $ obstPosx = array ( 3 ) ; $ obstPosy = array ( 5 ) ; echo numberofPosition ( $ n , $ k , $ Qposx , $ Qposy , $ obstPosx , $ obstPosy ) ; ? >"}
{"text": "Produk maksimum 4 elemen bersebelahan dalam matriks | Program PHP untuk mengetahui produk maksimum dalam matriks yang empat elemen bersebelahan antara satu sama lain dalam satu arah; berfungsi untuk mencari produk maks; melelehkan baris. ; melelehkan lajur. ; Semak produk maksimum dalam baris mendatar. ; Semak produk maksimum dalam baris menegak. ; Semak produk maksimum dalam pepenjuru yang turun - betul; Semak produk maksimum dalam pepenjuru yang berjalan - betul; Kod pemacu", "code": "< ? php $ n = 5 ; function FindMaxProduct ( $ arr , $ n ) { $ max = 0 ; $ result ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( $ j - 3 ) >= 0 ) { $ result = $ arr [ $ i ] [ $ j ] * $ arr [ $ i ] [ $ j - 1 ] * $ arr [ $ i ] [ $ j - 2 ] * $ arr [ $ i ] [ $ j - 3 ] ; if ( $ max < $ result ) $ max = $ result ; } if ( ( $ i - 3 ) >= 0 ) { $ result = $ arr [ $ i ] [ $ j ] * $ arr [ $ i - 1 ] [ $ j ] * $ arr [ $ i - 2 ] [ $ j ] * $ arr [ $ i - 3 ] [ $ j ] ; if ( $ max < $ result ) $ max = $ result ; } if ( ( $ i - 3 ) >= 0 and ( $ j - 3 ) >= 0 ) { $ result = $ arr [ $ i ] [ $ j ] * $ arr [ $ i - 1 ] [ $ j - 1 ] * $ arr [ $ i - 2 ] [ $ j - 2 ] * $ arr [ $ i - 3 ] [ $ j - 3 ] ; if ( $ max < $ result ) $ max = $ result ; } if ( ( $ i - 3 ) >= 0 and ( $ j - 1 ) <= 0 ) { $ result = $ arr [ $ i ] [ $ j ] * $ arr [ $ i - 1 ] [ $ j + 1 ] * $ arr [ $ i - 2 ] [ $ j + 2 ] * $ arr [ $ i - 3 ] [ $ j + 3 ] ; if ( $ max < $ result ) $ max = $ result ; } } } return $ max ; } $ arr = array ( array ( 1 , 2 , 3 , 4 , 5 ) , array ( 6 , 7 , 8 , 9 , 1 ) , array ( 2 , 3 , 4 , 5 , 6 ) , array ( 7 , 8 , 9 , 1 , 0 ) , array ( 9 , 6 , 4 , 2 , 3 ) ) ; echo FindMaxProduct ( $ arr , $ n ) ; ? >"}
{"text": "Flip minimum diperlukan untuk membuat simetri matriks binari | Program PHP untuk mencari flip minimum yang diperlukan untuk membuat; Kembalikan flip minimum yang diperlukan untuk membuat simetri matriks binari di sepanjang pepenjuru utama. ; mencari transpose matriks; Mencari bilangan kedudukan di mana elemen tidak sama. ; Kod pemacu", "code": "< ? php $ N = 3 ; function minimumflip ( $ mat , $ n ) { global $ N ; $ transpose ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ transpose [ $ i ] [ $ j ] = $ mat [ $ j ] [ $ i ] ; $ flip = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ transpose [ $ i ] [ $ j ] != $ mat [ $ i ] [ $ j ] ) $ flip ++ ; return $ flip / 2 ; } $ n = 3 ; $ mat = array ( array ( 0 , 0 , 1 ) , array ( 1 , 1 , 1 ) , array ( 1 , 0 , 0 ) ) ; echo minimumflip ( $ mat , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Flip minimum diperlukan untuk membuat simetri matriks binari | Program PHP untuk mencari flip minimum yang diperlukan untuk membuat simetri matriks binari di sepanjang pepenjuru utama; Kembalikan flip minimum yang diperlukan untuk membuat simetri matriks binari di sepanjang pepenjuru utama. ; Membandingkan unsur -unsur di seluruh pepenjuru; Kod pemacu", "code": "< ? php $ N = 3 ; function minimumflip ( $ mat , $ n ) { $ flip = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ j ] [ $ i ] ) $ flip ++ ; return $ flip ; } $ n = 3 ; $ mat = array ( array ( 0 , 0 , 1 ) , array ( 1 , 1 , 1 ) , array ( 1 , 0 , 0 ) ) ; echo minimumflip ( $ mat , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Frekuensi nombor walaupun dan ganjil dalam matriks | Program PHP untuk mencari kekerapan nombor Even dan ganjil dalam matriks; fungsi untuk mengira kekerapan; Modulo dengan 2 untuk memeriksa walaupun dan ganjil; kekerapan cetak nombor; Kod pemacu", "code": "< ? php $ MAX = 100 ; function freq ( $ ar , $ m , $ n ) { $ even = 0 ; $ odd = 0 ; for ( $ i = 0 ; $ i < $ m ; ++ $ i ) { for ( $ j = 0 ; $ j < $ n ; ++ $ j ) { if ( ( $ ar [ $ i ] [ $ j ] % 2 ) == 0 ) ++ $ even ; else ++ $ odd ; } } echo \" ▁ Frequency ▁ of ▁ odd ▁ number ▁ = ▁ \" , $ odd , \" STRNEWLINE \" ; echo \" ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ \" , $ even ; } $ m = 3 ; $ n = 3 ; $ array = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; freq ( $ array , $ m , $ n ) ; ? >"}
{"text": "Elemen pusat matriks sama dengan jumlah separuh pepenjuru | Program PHP untuk memeriksa sama ada elemen pusat adalah sama dengan jumlah individu dari semua separuh pepenjuru; Fungsi untuk memeriksa elemen pusat adalah sama dengan jumlah individu dari semua pepenjuru separuh; Cari jumlah separuh pepenjuru; Kod pemacu", "code": "< ? php $ MAX = 100 ; function HalfDiagonalSums ( $ mat , $ n ) { global $ MAX ; $ diag1_left = 1 ; $ diag1_right = 1 ; $ diag2_left = 1 ; $ diag2_right = 1 ; for ( $ i = 0 , $ j = $ n - 1 ; $ i < $ n ; $ i ++ , $ j -- ) { if ( $ i < $ n / 2 ) { $ diag1_left += $ mat [ $ i ] [ $ i ] ; $ diag2_left += $ mat [ $ j ] [ $ i ] ; } else if ( $ i > $ n / 2 ) { $ diag1_right += $ mat [ $ i ] [ $ i ] ; $ diag2_right += $ mat [ $ j ] [ $ i ] ; } } return ( $ diag1_left == $ diag2_right && $ diag2_right == $ diag2_left && $ diag1_right == $ diag2_left && $ diag2_right == $ mat [ $ n / 2 ] [ $ n / 2 ] ) ; } $ a = array ( array ( 2 , 9 , 1 , 4 , -2 ) , array ( 6 , 7 , 2 , 11 , 4 ) , array ( 4 , 2 , 9 , 2 , 4 ) , array ( 1 , 9 , 2 , 4 , 4 ) , array ( 0 , 2 , 4 , 2 , 5 ) ) ; if ( HalfDiagonalSums ( $ a , 5 ) == 0 ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Program untuk Matriks Identiti | Program PHP untuk mencetak matriks identiti; Memeriksa jika baris adalah sama dengan lajur; Kod pemacu", "code": "< ? php function Identity ( $ num ) { $ row ; $ col ; for ( $ row = 0 ; $ row < $ num ; $ row ++ ) { for ( $ col = 0 ; $ col < $ num ; $ col ++ ) { if ( $ row == $ col ) echo 1 , \" ▁ \" ; else echo 0 , \" ▁ \" ; } echo \" STRNEWLINE \" ; } return 0 ; } $ size = 5 ; identity ( $ size ) ; ? >"}
{"text": "Program untuk Matriks Identiti | Program PHP untuk memeriksa sama ada matriks yang diberikan adalah identiti $ max = 100; ; Kod pemacu", "code": "< ? php function isIdentity ( $ mat , $ N ) { for ( $ row = 0 ; $ row < $ N ; $ row ++ ) { for ( $ col = 0 ; $ col < $ N ; $ col ++ ) { if ( $ row == $ col and $ mat [ $ row ] [ $ col ] != 1 ) return false ; else if ( $ row != $ col && $ mat [ $ row ] [ $ col ] != 0 ) return false ; } } return true ; } $ N = 4 ; $ mat = array ( array ( 1 , 0 , 0 , 0 ) , array ( 0 , 1 , 0 , 0 ) , array ( 0 , 0 , 1 , 0 ) , array ( 0 , 0 , 0 , 1 ) ) ; if ( isIdentity ( $ mat , $ N ) ) echo \" Yes ▁ \" ; else echo \" No ▁ \" ; ? >"}
{"text": "Cara mengisi matriks supaya produk semua baris dan semua lajur adalah sama dengan perpaduan | Program PHP untuk mencari beberapa cara untuk mengisi matriks di bawah kekangan yang diberikan; Mengembalikan kuasa yang dibangkitkan t di bawah mod Modulo; Mengira bilangan cara mengisi matriks; Fungsi mengira jawapannya; Jika jumlah bilangan baris dan lajur adalah ganjil i. e (n ​​+ m) % 2 == 1 dan k = - 1 maka terdapat 0 cara memfailkan matriks. ; Sekiranya terdapat satu baris atau satu lajur maka hanya ada satu cara untuk mengisi matriks; Jika kes -kes di atas tidak diikuti maka kita dapati cara untuk mengisi baris n - 1 dan m - 1 lajur iaitu 2 ^ ((m - 1) * (n - 1)). ; Kod pemacu", "code": "< ? php $ mod = 100000007 ; function modPower ( $ a , $ t ) { global $ mod ; $ now = $ a ; $ ret = 1 ; while ( $ t ) { if ( $ t & 1 ) $ ret = $ now * ( $ ret % $ mod ) ; $ now = $ now * ( $ now % $ mod ) ; $ t >>= 1 ; } return $ ret ; } function countWays ( $ n , $ m , $ k ) { global $ mod ; if ( $ k == -1 and ( $ n + $ m ) % 2 == 1 ) return 0 ; if ( $ n == 1 or $ m == 1 ) return 1 ; return ( modPower ( modPower ( 2 , $ n - 1 ) , $ m - 1 ) % $ mod ) ; } $ n = 2 ; $ m = 7 ; $ k = 1 ; echo countWays ( $ n , $ m , $ k ) ; ? >"}
{"text": "Cermin matriks di seberang pepenjuru | Program PHP yang cekap untuk mencari cermin matriks di seluruh pepenjuru. ; melintasi matriks dan swap tikar [i] [j] dengan tikar [j] [i]; Fungsi utiliti untuk mencetak matriks; Kod pemacu", "code": "< ? php function imageSwap ( & $ mat , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + $ mat [ $ j ] [ $ i ] - ( $ mat [ $ j ] [ $ i ] = $ mat [ $ i ] [ $ j ] ) ; } function printMatrix ( & $ mat , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { echo ( $ mat [ $ i ] [ $ j ] ) ; echo ( \" ▁ \" ) ; } echo ( \" STRNEWLINE \" ) ; } } $ mat = array ( array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) , array ( 9 , 10 , 11 , 12 ) , array ( 13 , 14 , 15 , 16 ) ) ; $ n = 4 ; imageSwap ( $ mat , $ n ) ; printMatrix ( $ mat , $ n ) ; ? >"}
{"text": "Cari berturut -turut dan lajur yang bijak matriks disusun | Mencari elemen $ x dalam tikar [] []. Jika elemen dijumpai, maka mencetak kedudukannya dan mengembalikan benar, jika tidak, cetak \"tidak» dijumpai \"dan mengembalikan palsu; Tetapkan indeks untuk elemen kanan atas; jika $ mat [$ i] [$ j] <$ x; jika ($ i == $ n $ j == - 1); Kod pemacu", "code": "< ? php function search ( & $ mat , $ n , $ x ) { $ i = 0 ; $ j = $ n - 1 ; while ( $ i < $ n && $ j >= 0 ) { if ( $ mat [ $ i ] [ $ j ] == $ x ) { echo \" n ▁ found ▁ at ▁ \" . $ i . \" , ▁ \" . $ j ; return 1 ; } if ( $ mat [ $ i ] [ $ j ] > $ x ) $ j -- ; else $ i ++ ; } echo \" n ▁ Element ▁ not ▁ found \" ; return 0 ; } $ mat = array ( array ( 10 , 20 , 30 , 40 ) , array ( 15 , 25 , 35 , 45 ) , array ( 27 , 29 , 37 , 48 ) , array ( 32 , 33 , 39 , 50 ) ) ; search ( $ mat , 4 , 29 ) ; ? >"}
{"text": "Buat matriks dengan segi empat tepat berganti O dan X | Berfungsi untuk mencetak segi empat tepat berganti 0 dan x; K - Indeks baris permulaan m - Indeks baris akhir l - Indeks lajur bermula n - Ending Column Index I - Iterator; Simpan bilangan baris dan lajur yang diberikan untuk kegunaan kemudian; Ini akan menjadi watak yang akan ditangkap dalam [] []; Isi aksara dalam [] [] dalam bentuk lingkaran. Setiap lelaran mengisi satu segi empat tepat sama ada XS atau OS; Isi baris pertama dari baris yang tinggal; Isi lajur terakhir dari lajur yang tinggal; Isi baris terakhir dari baris yang tinggal; Cetak lajur pertama dari lajur yang tinggal; Watak flip untuk lelaran seterusnya; Cetak matriks yang diisi; Kod pemacu", "code": "< ? php function fill0X ( $ m , $ n ) { $ k = 0 ; $ l = 0 ; $ r = $ m ; $ c = $ n ; $ x = ' X ' ; while ( $ k < $ m && $ l < $ n ) { for ( $ i = $ l ; $ i < $ n ; ++ $ i ) $ a [ $ k ] [ $ i ] = $ x ; $ k ++ ; for ( $ i = $ k ; $ i < $ m ; ++ $ i ) $ a [ $ i ] [ $ n - 1 ] = $ x ; $ n -- ; if ( $ k < $ m ) { for ( $ i = $ n - 1 ; $ i >= $ l ; -- $ i ) $ a [ $ m - 1 ] [ $ i ] = $ x ; $ m -- ; } if ( $ l < $ n ) { for ( $ i = $ m - 1 ; $ i >= $ k ; -- $ i ) $ a [ $ i ] [ $ l ] = $ x ; $ l ++ ; } $ x = ( $ x == '0' ) ? ' X ' : '0' ; } for ( $ i = 0 ; $ i < $ r ; $ i ++ ) { for ( $ j = 0 ; $ j < $ c ; $ j ++ ) echo ( $ a [ $ i ] [ $ j ] . \" ▁ \" ) ; echo \" STRNEWLINE \" ; } } echo \" Output ▁ for ▁ m ▁ = ▁ 5 , ▁ n ▁ = ▁ 6 STRNEWLINE \" ; fill0X ( 5 , 6 ) ; echo \" Output for m = 4 , n = 4 \" ; fill0X ( 4 , 4 ) ; echo \" Output for m = 3 , n = 4 \" ; fill0X ( 3 , 4 ) ; ? >"}
{"text": "Kos minimum untuk menyusun matriks nombor dari 0 hingga n ^ 2 | berfungsi untuk mencari jumlah tenaga yang diperlukan untuk menyusun semula nombor; gelung bersarang untuk mengakses unsur -unsur matriks yang diberikan; kedai quotient; Lokasi Destinasi Akhir (I_DES, J_DES) dari Element Mat [i] [j] sedang dikira; Tenaga yang diperlukan untuk pergerakan elemen tikar [i] [j] dikira dan kemudian terkumpul dalam 'tot _ tenaga'; jumlah tenaga yang diperlukan; Kod pemacu", "code": "< ? php function calculateEnergy ( $ mat , $ n ) { $ i_des ; $ j_des ; $ q ; $ tot_energy = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ q = ( int ) ( $ mat [ $ i ] [ $ j ] / $ n ) ; $ i_des = $ q ; $ j_des = $ mat [ $ i ] [ $ j ] - ( $ n * $ q ) ; $ tot_energy += abs ( $ i_des - $ i ) + abs ( $ j_des - $ j ) ; } } return $ tot_energy ; } $ mat = array ( array ( 4 , 7 , 0 , 3 ) , array ( 8 , 5 , 6 , 1 ) , array ( 9 , 11 , 10 , 2 ) , array ( 15 , 13 , 14 , 12 ) ) ; $ n = 4 ; echo \" Total ▁ energy ▁ required ▁ = ▁ \" , calculateEnergy ( $ mat , $ n ) , \" ▁ units \" ; ? >"}
{"text": "Sel unik dalam matriks binari | Program PHP untuk mengira sel -sel yang unik dalam matriks; Pulangan benar jika Mat [i] [j] adalah unik; Memeriksa baris mengira sumrow akan bergerak lajur bijak; Memeriksa dalam lajur mengira sumcol akan bergerak baris bijak; Kod pemacu", "code": "< ? php $ MAX = 100 ; function isUnique ( $ mat , $ i , $ j , $ n , $ m ) { global $ MAX ; $ sumrow = 0 ; for ( $ k = 0 ; $ k < $ m ; $ k ++ ) { $ sumrow += $ mat [ $ i ] [ $ k ] ; if ( $ sumrow > 1 ) return false ; } $ sumcol = 0 ; for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { $ sumcol += $ mat [ $ k ] [ $ j ] ; if ( $ sumcol > 1 ) return false ; } return true ; } function countUnique ( $ mat , $ n , $ m ) { $ uniquecount = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] && isUnique ( $ mat , $ i , $ j , $ n , $ m ) ) $ uniquecount ++ ; return $ uniquecount ; } $ mat = array ( array ( 0 , 1 , 0 , 0 ) , array ( 0 , 0 , 1 , 0 ) , array ( 1 , 0 , 0 , 1 ) ) ; echo countUnique ( $ mat , 3 , 4 ) ; ? >"}
{"text": "Semak jika matriks yang diberikan adalah jarang atau tidak | Kod PHP untuk memeriksa sama ada matriks adalah jarang. ; Kiraan bilangan sifar dalam matriks; Kod pemacu", "code": "< ? php $ MAX = 100 ; function isSparse ( $ array , $ m , $ n ) { $ counter = 0 ; for ( $ i = 0 ; $ i < $ m ; ++ $ i ) for ( $ j = 0 ; $ j < $ n ; ++ $ j ) if ( $ array [ $ i ] [ $ j ] == 0 ) ++ $ counter ; return ( $ counter > ( ( $ m * $ n ) / 2 ) ) ; } $ array = array ( array ( 1 , 0 , 3 ) , array ( 0 , 0 , 4 ) , array ( 6 , 0 , 0 ) ) ; $ m = 3 ; $ n = 3 ; if ( isSparse ( $ array , $ m , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Baris | Program PHP untuk mencari unsur -unsur biasa dalam dua pepenjuru. ; Mengembalikan kiraan baris yang sama dengan unsur -unsur yang sama dalam dua pepenjuru Mat [n] [n]; Kod pemacu", "code": "< ? php $ MAX = 100 ; function countCommon ( $ mat , $ n ) { global $ MAX ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ mat [ $ i ] [ $ i ] == $ mat [ $ i ] [ $ n - $ i - 1 ] ) $ res ++ ; return $ res ; } $ mat = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; echo countCommon ( $ mat , 3 ) ; ? >"}
{"text": "Semak jika jumlah saya | Fungsi untuk memeriksa jika jumlah baris adalah sama dengan lajur yang sepadan; bilangan baris; bilangan lajur", "code": "< ? php function areSumSame ( $ a , $ n , $ m ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { $ sum1 += $ a [ $ i ] [ $ j ] ; $ sum2 += $ a [ $ j ] [ $ i ] ; } if ( $ sum1 == $ sum2 ) return true ; } return false ; } $ n = 4 ; $ m = 4 ; $ M = array ( array ( 1 , 2 , 3 , 4 ) , array ( 9 , 5 , 3 , 1 ) , array ( 0 , 3 , 5 , 6 ) , array ( 0 , 4 , 5 , 6 ) ) ; echo areSumSame ( $ M , $ n , $ m ) ; ? >"}
{"text": "Cari Nombor Baris Matriks Perduaan yang Mempunyai Bilangan Maksimum 1 S | Program PHP untuk mencari baris dengan maksimum 1 dalam baris matriks binari yang disusun; fungsi untuk mencari baris dengan maksimum 1; Cari kedudukan paling banyak 1 berturut -turut Cari 1 sifnya berturut -turut; Kod pemacu", "code": "< ? php $ N = 4 ; function findMax ( $ arr ) { global $ N ; $ row = 0 ; $ i ; $ j = $ N - 1 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { while ( $ arr [ $ i ] [ $ j ] == 1 && $ j >= 0 ) { $ row = $ i ; $ j -- ; } } echo \" Row ▁ number ▁ = ▁ \" , $ row + 1 ; echo \" , MaxCount = \" } $ arr = array ( array ( 0 , 0 , 0 , 1 ) , array ( 0 , 0 , 0 , 1 ) , array ( 0 , 0 , 0 , 0 ) , array ( 0 , 1 , 1 , 1 ) ) ; findMax ( $ arr ) ; ? >"}
{"text": "Kemungkinan bergerak ksatria | Program PHP untuk mencari bilangan langkah ksatria yang mungkin; Untuk mengira kemungkinan bergerak; Semua kemungkinan gerakan seorang ksatria; Periksa sama ada setiap langkah yang mungkin sah atau tidak; Kedudukan ksatria selepas bergerak; mengira langkah yang sah; Pulangan bilangan gerakan yang mungkin; Kod pemacu", "code": "< ? php $ n = 4 ; $ m = 4 ; function findPossibleMoves ( $ mat , $ p , $ q ) { global $ n ; global $ m ; $ X = array ( 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 ) ; $ Y = array ( 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 ) ; $ count = 0 ; for ( $ i = 0 ; $ i < 8 ; $ i ++ ) { $ x = $ p + $ X [ $ i ] ; $ y = $ q + $ Y [ $ i ] ; if ( $ x >= 0 && $ y >= 0 && $ x < $ n && $ y < $ m && $ mat [ $ x ] [ $ y ] == 0 ) $ count ++ ; } return $ count ; } $ mat = array ( array ( 1 , 0 , 1 , 0 ) , array ( 0 , 1 , 1 , 1 ) , array ( 1 , 1 , 0 , 1 ) , array ( 0 , 1 , 1 , 1 ) ) ; $ p = 2 ; $ q = 2 ; echo findPossibleMoves ( $ mat , $ p , $ q ) ; ? >"}
{"text": "Mengira jumlah keseluruhan pepenjuru matriks | Program PHP yang mudah untuk mencari jumlah pepenjuru; Keadaan untuk pepenjuru utama; Keadaan untuk pepenjuru sekunder; Kod pemacu", "code": "< ? php $ MAX = 100 ; function printDiagonalSums ( $ mat , $ n ) { global $ MAX ; $ principal = 0 ; $ secondary = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == $ j ) $ principal += $ mat [ $ i ] [ $ j ] ; if ( ( $ i + $ j ) == ( $ n - 1 ) ) $ secondary += $ mat [ $ i ] [ $ j ] ; } } echo \" Principal ▁ Diagonal : \" , $ principal , \" STRNEWLINE \" ; echo \" Secondary ▁ Diagonal : \" , $ secondary , \" STRNEWLINE \" ; } $ a = array ( array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) , array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) ) ; printDiagonalSums ( $ a , 4 ) ; ? >"}
{"text": "Mengira jumlah keseluruhan pepenjuru matriks | Program PHP yang cekap untuk mencari jumlah pepenjuru; Kod pemacu", "code": "< ? php $ MAX = 100 ; function printDiagonalSums ( $ mat , $ n ) { global $ MAX ; $ principal = 0 ; $ secondary = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ principal += $ mat [ $ i ] [ $ i ] ; $ secondary += $ mat [ $ i ] [ $ n - $ i - 1 ] ; } echo \" Principal ▁ Diagonal : \" , $ principal , \" STRNEWLINE \" ; echo \" Secondary ▁ Diagonal : \" , $ secondary , \" STRNEWLINE \" ; } $ a = array ( array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) , array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) ) ; printDiagonalSums ( $ a , 4 ) ; ? >"}
{"text": "Unsur sempadan matriks | Program PHP untuk mencetak elemen sempadan matriks. ; Kod pemacu", "code": "< ? php $ MAX = 100 ; function printBoundary ( $ a , $ m , $ n ) { global $ MAX ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == 0 ) echo $ a [ $ i ] [ $ j ] , \" ▁ \" ; else if ( $ i == $ m - 1 ) echo $ a [ $ i ] [ $ j ] , \" ▁ \" ; else if ( $ j == 0 ) echo $ a [ $ i ] [ $ j ] , \" ▁ \" ; else if ( $ j == $ n - 1 ) echo $ a [ $ i ] [ $ j ] , \" ▁ \" ; else echo \" ▁ \" , \" ▁ \" ; } echo \" STRNEWLINE \" ; } } $ a = array ( array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) , array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) ) ; printBoundary ( $ a , 4 , 4 ) ; ? >"}
{"text": "Unsur sempadan matriks | Program PHP untuk mencari jumlah elemen sempadan matriks. ; Kod pemacu", "code": "< ? php function getBoundarySum ( $ a , $ m , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == 0 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ i == $ m - 1 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ j == 0 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ j == $ n - 1 ) $ sum += $ a [ $ i ] [ $ j ] ; } } return $ sum ; } $ a = array ( array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) , array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) ) ; $ sum = getBoundarySum ( $ a , 4 , 4 ) ; echo \" Sum ▁ of ▁ boundary ▁ elements ▁ is ▁ \" , $ sum ; ? >"}
{"text": "Cetak matriks dalam bentuk lingkaran bermula dari titik | Program PHP untuk mencetak matriks dalam bentuk lingkaran. ; Kod pemacu; Fungsi panggilan", "code": "< ? php $ MAX = 100 ; function printSpiral ( $ mat , $ r , $ c ) { global $ MAX ; $ i ; $ a = 0 ; $ b = 2 ; $ low_row = ( 0 > $ a ) ? 0 : $ a ; $ low_column = ( 0 > $ b ) ? 0 : $ b - 1 ; $ high_row = ( ( $ a + 1 ) >= $ r ) ? $ r - 1 : $ a + 1 ; $ high_column = ( ( $ b + 1 ) >= $ c ) ? $ c - 1 : $ b + 1 ; while ( ( $ low_row > 0 - $ r && $ low_column > 0 - $ c ) ) { for ( $ i = $ low_column + 1 ; $ i <= $ high_column && $ i < $ c && $ low_row >= 0 ; ++ $ i ) echo $ mat [ $ low_row ] [ $ i ] , \" ▁ \" ; $ low_row -= 1 ; for ( $ i = $ low_row + 2 ; $ i <= $ high_row && $ i < $ r && $ high_column < $ c ; ++ $ i ) echo $ mat [ $ i ] [ $ high_column ] , \" ▁ \" ; $ high_column += 1 ; for ( $ i = $ high_column - 2 ; $ i >= $ low_column && $ i >= 0 && $ high_row < $ r ; -- $ i ) echo $ mat [ $ high_row ] [ $ i ] , \" ▁ \" ; $ high_row += 1 ; for ( $ i = $ high_row - 2 ; $ i > $ low_row && $ i >= 0 && $ low_column >= 0 ; -- $ i ) echo $ mat [ $ i ] [ $ low_column ] , \" ▁ \" ; $ low_column -= 1 ; } echo \" STRNEWLINE \" ; } $ mat = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; $ r = 3 ; $ c = 3 ; printSpiral ( $ mat , $ r , $ c ) ; ? >"}
{"text": "Cari Perbezaan Antara Jumlah Dua Diagonal | Program PHP untuk mencari perbezaan antara jumlah pepenjuru. ; Memulakan jumlah pepenjuru; mencari jumlah pepenjuru utama; mencari jumlah pepenjuru sekunder; Perbezaan mutlak jumlah di seluruh pepenjuru; Kod pemacu", "code": "< ? php function difference ( $ arr , $ n ) { $ d1 = 0 ; $ d2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == $ j ) $ d1 += $ arr [ $ i ] [ $ j ] ; if ( $ i == $ n - $ j - 1 ) $ d2 += $ arr [ $ i ] [ $ j ] ; } } return abs ( $ d1 - $ d2 ) ; } { $ n = 3 ; $ arr = array ( array ( 11 , 2 , 4 ) , array ( 4 , 5 , 6 ) , array ( 10 , 8 , -12 ) ) ; echo difference ( $ arr , $ n ) ; return 0 ; } ? >"}
{"text": "Cari Perbezaan Antara Jumlah Dua Diagonal | Program PHP untuk mencari perbezaan antara jumlah pepenjuru. ; Memulakan jumlah pepenjuru; Perbezaan mutlak jumlah di seluruh pepenjuru; Kod pemacu", "code": "< ? php function difference ( $ arr , $ n ) { $ d1 = 0 ; $ d2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ d1 += $ arr [ $ i ] [ $ i ] ; $ d2 += $ arr [ $ i ] [ $ n - $ i - 1 ] ; } return abs ( $ d1 - $ d2 ) ; } { $ n = 3 ; $ arr = array ( array ( 11 , 2 , 4 ) , array ( 4 , 5 , 6 ) , array ( 10 , 8 , -12 ) ) ; echo difference ( $ arr , $ n ) ; return 0 ; } ? >"}
{"text": "Matriks Pekeliling (membina matriks dengan nombor 1 hingga m * n dalam cara spiral) | Mengisi [m] [n] dengan nilai dari 1 hingga m * n dalam fesyen spiral. ; Memulakan nilai yang akan diisi dalam matriks; K - Indeks baris permulaan m - Indeks baris akhir l - Indeks lajur permulaan n - Indeks lajur berakhir; Cetak baris pertama dari baris yang tinggal; Cetak lajur terakhir dari lajur yang tinggal; Cetak baris terakhir dari baris yang tinggal; Cetak lajur pertama dari lajur yang tinggal; Kod pemacu", "code": "< ? php function spiralFill ( $ m , $ n , & $ a ) { $ val = 1 ; $ k = 0 ; $ l = 0 ; while ( $ k < $ m && $ l < $ n ) { for ( $ i = $ l ; $ i < $ n ; ++ $ i ) $ a [ $ k ] [ $ i ] = $ val ++ ; $ k ++ ; for ( $ i = $ k ; $ i < $ m ; ++ $ i ) $ a [ $ i ] [ $ n - 1 ] = $ val ++ ; $ n -- ; if ( $ k < $ m ) { for ( $ i = $ n - 1 ; $ i >= $ l ; -- $ i ) $ a [ $ m - 1 ] [ $ i ] = $ val ++ ; $ m -- ; } if ( $ l < $ n ) { for ( $ i = $ m - 1 ; $ i >= $ k ; -- $ i ) $ a [ $ i ] [ $ l ] = $ val ++ ; $ l ++ ; } } } $ m = 4 ; $ n = 4 ; spiralFill ( $ m , $ n , $ a ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { echo ( $ a [ $ i ] [ $ j ] ) ; echo ( \" ▁ \" ) ; } echo ( \" STRNEWLINE \" ) ; } ? >"}
{"text": "Maksimum dan minimum dalam matriks persegi. | Program PHP untuk mencari maksimum dan minimum dalam matriks. ; Cari maksimum dan minimum dalam ARR [0. n - 1] [0 .. n - 1] menggunakan perbandingan pasangan yang bijak; Traverses baris satu demi satu; Bandingkan unsur -unsur dari awal dan akhir baris semasa; Kod pemacu", "code": "< ? php $ MAX = 100 ; function maxMin ( $ arr , $ n ) { $ min = PHP_INT_MAX ; $ max = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n / 2 ; $ j ++ ) { if ( $ arr [ $ i ] [ $ j ] > $ arr [ $ i ] [ $ n - $ j - 1 ] ) { if ( $ min > $ arr [ $ i ] [ $ n - $ j - 1 ] ) $ min = $ arr [ $ i ] [ $ n - $ j - 1 ] ; if ( $ max < $ arr [ $ i ] [ $ j ] ) $ max = $ arr [ $ i ] [ $ j ] ; } else { if ( $ min > $ arr [ $ i ] [ $ j ] ) $ min = $ arr [ $ i ] [ $ j ] ; if ( $ max < $ arr [ $ i ] [ $ n - $ j - 1 ] ) $ max = $ arr [ $ i ] [ $ n - $ j - 1 ] ; } } } echo \" Maximum = \" ▁ , ▁ $ max STRNEWLINE TABSYMBOL TABSYMBOL , \" , Minimum = \" } $ arr = array ( array ( 5 , 9 , 11 ) , array ( 25 , 0 , 14 ) , array ( 21 , 6 , 4 ) ) ; maxMin ( $ arr , 3 ) ; ? >"}
{"text": "Operasi minimum diperlukan untuk menetapkan semua elemen matriks binari | Program PHP untuk mencari operasi minimum yang diperlukan untuk menetapkan semua elemen matriks binari; Pulangan operasi minimum diperlukan untuk membuat semua 1 s. ; Semak jika sel ini sama dengan 0; meningkatkan bilangan langkah; Flip dari sel ini ke titik permulaan; flip sel; Kod pemacu", "code": "< ? php $ N = 5 ; $ M = 5 ; function minOperation ( & $ arr ) { global $ N , $ M ; $ ans = 0 ; for ( $ i = $ N - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = $ M - 1 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ i ] [ $ j ] == 0 ) { $ ans ++ ; for ( $ k = 0 ; $ k <= $ i ; $ k ++ ) { for ( $ h = 0 ; $ h <= $ j ; $ h ++ ) { if ( $ arr [ $ k ] [ $ h ] == 1 ) $ arr [ $ k ] [ $ h ] = 0 ; else $ arr [ $ k ] [ $ h ] = 1 ; } } } } } return $ ans ; } $ mat = array ( array ( 0 , 0 , 1 , 1 , 1 ) , array ( 0 , 0 , 0 , 1 , 1 ) , array ( 0 , 0 , 0 , 1 , 1 ) , array ( 1 , 1 , 1 , 1 , 1 ) , array ( 1 , 1 , 1 , 1 , 1 ) ) ; echo minOperation ( $ mat ) ; ? >"}
{"text": "Jumlah elemen matriks di mana setiap elemen adalah pembahagian integer baris dan lajur | Kembali jumlah elemen matriks di mana setiap elemen adalah pembahagian baris dan lajur yang sepadan. ; Untuk setiap lajur. ; Kira bilangan elemen setiap lajur. Inisialisasi kepada I - 1 kerana bilangan sifar adalah i - 1 .; Untuk kalikan; Kod pemacu", "code": "< ? php function findSum ( $ n ) { $ ans = 0 ; $ temp = 0 ; $ num ; for ( $ i = 1 ; $ i <= $ n and $ temp < $ n ; $ i ++ ) { $ temp = $ i - 1 ; $ num = 1 ; while ( $ temp < $ n ) { if ( $ temp + $ i <= $ n ) $ ans += ( $ i * $ num ) ; else $ ans += ( ( $ n - $ temp ) * $ num ) ; $ temp += $ i ; $ num ++ ; } } return $ ans ; } $ N = 2 ; echo findSum ( $ N ) ; ? >"}
{"text": "Cari bilangan transformasi untuk membuat dua matriks sama | Program PHP untuk mencari bilangan countopsation untuk membuat dua matriks sama dengan; Kemas kini Matriks A [] [] supaya hanya [] [] harus dikira; Semak syarat yang diperlukan untuk keadaan untuk kewujudan Countopsation Penuh; Jika Countopsation mungkin mengira jumlah countopsation; Kod pemacu", "code": "< ? php function countOps ( $ A , $ B , $ m , $ n ) { $ MAX = 1000 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) $ A [ $ i ] [ $ j ] -= $ B [ $ i ] [ $ j ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 1 ; $ j < $ m ; $ j ++ ) if ( $ A [ $ i ] [ $ j ] - $ A [ $ i ] [ 0 ] - $ A [ 0 ] [ $ j ] + $ A [ 0 ] [ 0 ] != 0 ) return -1 ; $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result += abs ( $ A [ $ i ] [ 0 ] ) ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) $ result += abs ( $ A [ 0 ] [ $ j ] - $ A [ 0 ] [ 0 ] ) ; return ( $ result ) ; } $ A = array ( array ( 1 , 1 , 1 ) , array ( 1 , 1 , 1 ) , array ( 1 , 1 , 1 ) ) ; $ B = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; echo countOps ( $ A , $ B , 3 , 3 ) ; ? >"}
{"text": "Borang gegelung dalam matriks | Cetak gegelung dalam matriks saiz 4 n x 4 n; Bilangan elemen dalam setiap gegelung; Marilah kita mengisi unsur -unsur dalam gegelung 1 .; Elemen pertama Coil1 4 * n * 2 * n + 2 * n; ; Mengisi baki m - 1 elemen dalam gegelung []; Mengisi unsur -unsur langkah semasa dari bawah ke atas; Elemen seterusnya dari elemen semasa; Isi unsur -unsur langkah semasa dari ke bawah. ; Dapatkan Coil2 dari Coil1; Cetak kedua -dua gegelung; Kod pemacu", "code": "< ? php function printCoils ( $ n ) { $ m = 8 * $ n * $ n ; $ coil1 = array ( ) ; $ coil1 [ 0 ] = 8 * $ n * $ n + 2 * $ n ; $ curr = $ coil1 [ 0 ] ; $ nflg = 1 ; $ step = 2 ; $ index = 1 ; while ( $ index < $ m ) { for ( $ i = 0 ; $ i < $ step ; $ i ++ ) { $ curr = $ coil1 [ $ index ++ ] = ( $ curr - 4 * $ n * $ nflg ) ; if ( $ index >= $ m ) break ; } if ( $ index >= $ m ) break ; for ( $ i = 0 ; $ i < $ step ; $ i ++ ) { $ curr = $ coil1 [ $ index ++ ] = $ curr + $ nflg ; if ( $ index >= $ m ) break ; } $ nflg = $ nflg * ( -1 ) ; $ step += 2 ; } $ coil2 = array ( ) ; for ( $ i = 0 ; $ i < 8 * $ n * $ n ; $ i ++ ) $ coil2 [ $ i ] = 16 * $ n * $ n + 1 - $ coil1 [ $ i ] ; echo \" Coil ▁ 1 ▁ : ▁ \" ; for ( $ i = 0 ; $ i < 8 * $ n * $ n ; $ i ++ ) echo $ coil1 [ $ i ] , \" ▁ \" ; echo \" Coil 2 : \" ; for ( $ i = 0 ; $ i < 8 * $ n * $ n ; $ i ++ ) echo $ coil2 [ $ i ] , \" ▁ \" ; } $ n = 1 ; printCoils ( $ n ) ; ? >"}
{"text": "Jumlah matriks di mana setiap elemen adalah perbezaan mutlak baris dan nombor lajurnya | Retuen jumlah matriks di mana setiap elemen adalah perbezaan mutlak baris baris dan lajur yang sepadan; Menjana matriks; Mengira jumlah; Kod pemacu", "code": "< ? php function findSum ( $ n ) { $ arr = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ arr [ $ i ] [ $ j ] = abs ( $ i - $ j ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ arr [ $ i ] [ $ j ] ; return $ sum ; } $ n = 3 ; echo findSum ( $ n ) ; ? >"}
{"text": "Jumlah matriks di mana setiap elemen adalah perbezaan mutlak baris dan nombor lajurnya | Kembalikan jumlah matriks di mana setiap elemen adalah perbezaan mutlak baris baris dan lajur yang sama; Kod pemacu", "code": "< ? php function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ i * ( $ n - $ i ) ; return 2 * $ sum ; } $ n = 3 ; echo findSum ( $ n ) ; ? >"}
{"text": "Jumlah matriks di mana setiap elemen adalah perbezaan mutlak baris dan nombor lajurnya | Retuen jumlah matriks di mana setiap elemen adalah perbezaan mutlak baris baris dan lajur yang sepadan; Kod pemacu", "code": "< ? php function findSum ( $ n ) { $ n -- ; $ sum = 0 ; $ sum += ( $ n * ( $ n + 1 ) ) / 2 ; $ sum += ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; return $ sum ; } $ n = 3 ; echo findSum ( $ n ) ; ? >"}
{"text": "Jumlah kedua -dua pepenjuru ganjil lingkaran | fungsi mengembalikan jumlah pepenjuru; Oleh kerana perintah harus hanya ganjil kita harus lulus hanya ganjil - bilangan bulat; Kod pemacu", "code": "< ? php function spiralDiaSum ( $ n ) { if ( $ n == 1 ) return 1 ; return ( 4 * $ n * $ n - 6 * $ n + 6 + spiralDiaSum ( $ n - 2 ) ) ; } $ n = 7 ; echo spiralDiaSum ( $ n ) ; ? >"}
{"text": "Cari perimeter bentuk yang dibentuk dengan 1 s dalam matriks binari | Program PHP untuk mencari perimeter kawasan yang diliputi oleh 1 dalam 2d matriks konsisten 0 dan '1 s. ; Cari bilangan sampingan yang dilindungi untuk tikar [i] [j]. ; Naik; Kiri; Ke bawah; Betul; Mengembalikan jumlah perimeter bentuk yang dibentuk dengan 1 s; Melintasi matriks dan mencari orang untuk mengira sumbangan mereka. ; Kod pemacu", "code": "< ? php $ R = 3 ; $ C = 5 ; function numofneighbour ( $ mat , $ i , $ j ) { global $ R ; global $ C ; $ count = 0 ; if ( $ i > 0 && ( $ mat [ $ i - 1 ] [ $ j ] ) ) $ count ++ ; if ( $ j > 0 && ( $ mat [ $ i ] [ $ j - 1 ] ) ) $ count ++ ; if ( ( $ i < $ R - 1 ) && ( $ mat [ $ i + 1 ] [ $ j ] ) ) $ count ++ ; if ( ( $ j < $ C - 1 ) && ( $ mat [ $ i ] [ $ j + 1 ] ) ) $ count ++ ; return $ count ; } function findperimeter ( $ mat ) { global $ R ; global $ C ; $ perimeter = 0 ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) for ( $ j = 0 ; $ j < $ C ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] ) $ perimeter += ( 4 - numofneighbour ( $ mat , $ i , $ j ) ) ; return $ perimeter ; } $ mat = array ( array ( 0 , 1 , 0 , 0 , 0 ) , array ( 1 , 1 , 1 , 0 , 0 ) , array ( 1 , 0 , 0 , 0 , 0 ) ) ; echo findperimeter ( $ mat ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cetak matriks dalam corak pepenjuru | program PHP untuk mencetak matriks dalam urutan pepenjuru; Memulakan indeks elemen yang akan dicetak seterusnya; Arah pada mulanya turun ke atas; Melintasi matriks sehingga semua elemen dilalui; Jika isup = benar kemudian melintasi ke bawah ke atas; Set i dan j mengikut arah; Jika isup = 0 kemudian melintasi ke bawah; Set i dan j mengikut arah; Mengembalikan ISUP untuk mengubah arah; Kod pemacu", "code": "< ? php $ MAX = 100 ; function printMatrixDiagonal ( $ mat , $ n ) { $ i = 0 ; $ j = 0 ; $ isUp = true ; for ( $ k = 0 ; $ k < $ n * $ n { if ( $ isUp ) { for ( ; $ i >= 0 && $ j < $ n ; $ j ++ , $ i -- ) { echo $ mat [ $ i ] [ $ j ] . \" \" ; $ k ++ ; } if ( $ i < 0 && $ j <= $ n - 1 ) $ i = 0 ; if ( $ j == $ n ) { $ i = $ i + 2 ; $ j -- ; } } else { for ( ; $ j >= 0 && $ i < $ n ; $ i ++ , $ j -- ) { echo $ mat [ $ i ] [ $ j ] . \" \" ; $ k ++ ; } if ( $ j < 0 && $ i <= $ n - 1 ) $ j = 0 ; if ( $ i == $ n ) { $ j = $ j + 2 ; $ i -- ; } } $ isUp = ! $ isUp ; } } $ mat = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; $ n = 3 ; printMatrixDiagonal ( $ mat , $ n ) ; ? >"}
{"text": "Perbezaan maksimum jumlah elemen dalam dua baris dalam matriks | Program PHP untuk mencari perbezaan maksimum jumlah elemen dua baris; Fungsi untuk mencari perbezaan maksimum jumlah unsur -unsur dua baris sehingga baris kedua muncul sebelum baris pertama. ; Arahan tambahan untuk menyimpan jumlah semua elemen setiap baris; Hitung jumlah setiap baris dan simpan dalam array rowsum; mengira perbezaan maksimum dua elemen seperti rowsum [i] <rowsum [j]; jika perbezaan semasa lebih besar daripada sebelumnya maka kemas kini; Jika elemen baru kurang daripada elemen minimum sebelumnya maka kemas kini supaya kita dapat mendapat perbezaan maksimum dalam array yang tinggal; Kod pemacu", "code": "< ? php $ MAX = 100 ; function maxRowDiff ( $ mat , $ m , $ n ) { global $ MAX ; $ rowSum = array ( ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ mat [ $ i ] [ $ j ] ; $ rowSum [ $ i ] = $ sum ; } $ max_diff = $ rowSum [ 1 ] - $ rowSum [ 0 ] ; $ min_element = $ rowSum [ 0 ] ; for ( $ i = 1 ; $ i < $ m ; $ i ++ ) { if ( $ rowSum [ $ i ] - $ min_element > $ max_diff ) $ max_diff = $ rowSum [ $ i ] - $ min_element ; if ( $ rowSum [ $ i ] < $ min_element ) $ min_element = $ rowSum [ $ i ] ; } return $ max_diff ; } $ m = 5 ; $ n = 4 ; $ mat = array ( array ( -1 , 2 , 3 , 4 ) , array ( 5 , 3 , -2 , 1 ) , array ( 6 , 7 , 2 , -3 ) , array ( 2 , 9 , 1 , 4 ) , array ( 2 , 1 , -2 , 0 ) ) ; echo maxRowDiff ( $ mat , $ m , $ n ) ; ? >"}
{"text": "Kira semua baris yang disusun dalam matriks | Program PHP untuk mencari bilangan baris yang disusun; Berfungsi untuk mengira semua baris yang disusun dalam matriks; Memulakan hasil; Mulakan dari sebelah kiri matriks untuk mengira baris pesanan yang semakin meningkat; Semak jika terdapat mana -mana pasangan elemen yang tidak dalam urutan yang semakin meningkat. ; Sekiranya gelung itu tidak pecah (semua elemen baris semasa berada dalam urutan yang semakin meningkat); Bermula dari sebelah kanan matriks untuk mengira baris pesanan yang semakin meningkat (rujukan ke kiri ini adalah dalam urutan yang berkurangan); Semak jika terdapat mana -mana pasangan elemen yang tidak berkurangan. ; Nota c> 1 keadaan diperlukan untuk memastikan bahawa satu baris lajur tidak dikira dua kali (perhatikan bahawa satu baris lajur disusun dalam peningkatan dan penurunan urutan); Kod pemacu", "code": "< ? php $ MAX = 100 ; function sortedCount ( $ mat , $ r , $ c ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ r ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ c - 1 ; $ j ++ ) if ( $ mat [ $ i ] [ $ j + 1 ] <= $ mat [ $ i ] [ $ j ] ) break ; if ( $ j == $ c - 1 ) $ result ++ ; } for ( $ i = 0 ; $ i < $ r ; $ i ++ ) { $ j ; for ( $ j = $ c - 1 ; $ j > 0 ; $ j -- ) if ( $ mat [ $ i ] [ $ j - 1 ] <= $ mat [ $ i ] [ $ j ] ) break ; if ( $ c > 1 && $ j == 0 ) $ result ++ ; } return $ result ; } $ m = 4 ; $ n = 5 ; $ mat = array ( array ( 1 , 2 , 3 , 4 , 5 ) , array ( 4 , 3 , 1 , 2 , 6 ) , array ( 8 , 7 , 6 , 5 , 4 ) , array ( 5 , 7 , 8 , 9 , 10 ) ) ; echo sortedCount ( $ mat , $ m , $ n ) ; ? >"}
{"text": "Nilai XOR Maksimum dalam Matriks | Program PHP untuk mencari nilai XOR maksimum dalam matriks sama ada baris atau lajur bijak bilangan baris dan lajur maksimum; fungsi mengembalikan nilai XOR maksimum yang sama ada baris atau lajur bijak; untuk baris XOR dan Lajur XOR; Traverse matriks; elemen baris XOR; Untuk setiap lajur: J bertindak sebagai baris & saya bertindak sebagai elemen lajur lajur XOR; Kemas kini maksimum antara R_XOR, C_XOR; mengembalikan nilai XOR maksimum; Kod pemacu", "code": "< ? php $ MAX = 1000 ; function maxXOR ( $ mat , $ N ) { $ r_xor ; $ c_xor ; $ max_xor = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ r_xor = 0 ; $ c_xor = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ r_xor = $ r_xor ^ $ mat [ $ i ] [ $ j ] ; $ c_xor = $ c_xor ^ $ mat [ $ j ] [ $ i ] ; } if ( $ max_xor < max ( $ r_xor , $ c_xor ) ) $ max_xor = max ( $ r_xor , $ c_xor ) ; } return $ max_xor ; } $ N = 3 ; $ mat = array ( array ( 1 , 5 , 4 ) , array ( 3 , 7 , 2 ) , array ( 5 , 9 , 10 ) ) ; echo \" maximum ▁ XOR ▁ value ▁ : ▁ \" , maxXOR ( $ mat , $ N ) ; ? >"}
{"text": "Arah pada blok persegi terakhir | Fungsi yang memberitahu arah semasa; Kod pemacu", "code": "< ? php function direction ( $ R , $ C ) { if ( $ R != $ C && $ R % 2 == 0 && $ C % 2 != 0 && $ R < $ C ) { echo \" Left \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 != 0 && $ C % 2 == 0 && $ R > $ C ) { echo \" Up \" , \" STRNEWLINE \" ; return ; } if ( $ R == $ C && $ R % 2 != 0 && $ C % 2 != 0 ) { echo \" Right \" , \" STRNEWLINE \" ; return ; } if ( $ R == $ C && $ R % 2 == 0 && $ C % 2 == 0 ) { echo \" Left \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 != 0 && $ C % 2 != 0 && $ R < $ C ) { echo \" Right \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 != 0 && $ C % 2 != 0 && $ R > $ C ) { echo \" Down \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 == 0 && $ C % 2 == 0 && $ R < $ C ) { echo \" Left \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 == 0 && $ C % 2 == 0 && $ R > $ C ) { echo \" Up \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 == 0 && $ C % 2 != 0 && $ R > $ C ) { echo \" Down \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 != 0 && $ C % 2 == 0 && $ R < $ C ) { echo \" Right \" , \" STRNEWLINE \" ; return ; } } $ R = 3 ; $ C = 1 ; direction ( $ R , $ C ) ; ? >"}
{"text": "Cari jika diberi matriks adalah toeplitz atau tidak | Fungsi untuk memeriksa sama ada semua elemen yang hadir dalam pepenjuru menurun bermula dari kedudukan (i, j) dalam matriks adalah sama atau tidak; ketidakcocokan dijumpai; Kami hanya sampai di sini apabila semua elemen dalam pepenjuru yang diberikan adalah sama; Fungsi untuk memeriksa sama ada matriks yang diberikan adalah matriks toeplitz atau tidak; lakukan untuk setiap elemen dalam baris pertama; Semak pepenjuru turun bermula dari kedudukan (0, j) dalam matriks; lakukan untuk setiap elemen dalam lajur pertama; Semak pepenjuru turun bermula dari kedudukan (i, 0) dalam matriks; Kami hanya sampai di sini apabila setiap pepenjuru turun dari kiri ke kanan adalah sama; Kod pemacu; Panggilan fungsi", "code": "< ? php function checkDiagonal ( $ mat , $ i , $ j ) { $ N = 5 ; $ M = 4 ; $ res = $ mat [ $ i ] [ $ j ] ; while ( ++ $ i < $ N && ++ $ j < $ M ) { if ( $ mat [ $ i ] [ $ j ] != $ res ) return false ; } return true ; } function isToepliz ( $ mat ) { $ N = 5 ; $ M = 4 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { if ( ! checkDiagonal ( $ mat , 0 , $ i ) ) return false ; } for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { if ( ! checkDiagonal ( $ mat , $ i , 0 ) ) return false ; } return true ; } $ mat = array ( array ( 6 , 7 , 8 , 9 ) , array ( 4 , 6 , 7 , 8 ) , array ( 1 , 4 , 6 , 7 ) , array ( 0 , 1 , 4 , 6 ) , array ( 2 , 0 , 1 , 4 ) ) ; if ( isToepliz ( $ mat ) ) echo \" Matrix ▁ is ▁ a ▁ Toepliz ▁ \" ; else echo \" Matrix ▁ is ▁ not ▁ a ▁ Toepliz ▁ \" ; ? >"}
{"text": "Count Zeros berturut -turut Bijaksana dan Lajur Bijaksana Sorted Matrix | Program PHP untuk mengira nombor 0 s dalam baris yang diberikan - bijak dan lajur - matriks binari yang disusun bijak. ; Fungsi untuk mengira nombor 0 s dalam baris yang diberikan - bijak dan lajur - matriks binari yang disusun bijak. ; bermula dari sudut kiri bawah matriks; Kedai bilangan sifar dalam matriks; bergerak sehingga anda mencari 0; Jika sifar tidak terdapat dalam lajur semasa, kami sudah selesai; Tambah 0 s hadir dalam lajur semasa untuk menghasilkan; bergerak ke kanan ke lajur seterusnya; Kod pemacu", "code": "< ? php $ N = 5 ; function countZeroes ( $ mat ) { $ row = $ N - 1 ; $ col = 0 ; $ count = 0 ; while ( $ col < $ N ) { while ( $ mat [ $ row ] [ $ col ] ) if ( -- $ row < 0 ) return $ count ; $ count += ( $ row + 1 ) ; $ col ++ ; } return $ count ; } $ mat = array ( array ( 0 , 0 , 0 , 0 , 1 ) , array ( 0 , 0 , 0 , 1 , 1 ) , array ( 0 , 1 , 1 , 1 , 1 ) , array ( 1 , 1 , 1 , 1 , 1 ) , array ( 1 , 1 , 1 , 1 , 1 ) ) ; echo countZeroes ( $ mat ) ; ? >"}
{"text": "Cari saiz ' +' terbesar yang dibentuk oleh semua yang dalam matriks binari | saiz matriks persegi binari; Berfungsi untuk mencari saiz terbesar ' +' yang dibentuk oleh semua 1 dalam matriks binari yang diberikan; Kiri [j] [j], kanan [i] [j], atas [i] [j] dan bawah [i] [j] menyimpan bilangan maksimum berturut -turut 1 's hadir ke kiri, kanan, atas dan bawah tikar [i] [j] termasuk sel (i, j) masing -masing; memulakan di atas empat matriks; memulakan baris pertama di atas; memulakan baris terakhir bawah; memulakan lajur pertama kiri; memulakan lajur terakhir kanan; Isi semua sel di atas empat matriks; hitung matriks kiri (diisi kiri ke kanan); Hitung matriks atas; Hitung nilai baru j untuk mengira nilai bawah (i, j) dan kanan (i, j); kirakan matriks bawah; Kirakan matriks kanan; kembali ke Old J; n kedai panjang terpanjang + dijumpai setakat ini; Kirakan terpanjang +; Cari minimum kiri (i, j), kanan (i, j), atas (i, j), bawah (i, j); terbesar + akan dibentuk oleh sel yang mempunyai nilai maksimum; 4 arah panjang n - 1 dan 1 untuk sel tengah; Matriks mengandungi semua 0; Kod pemacu", "code": "< ? php $ N = 10 ; function findLargestPlus ( $ mat ) { global $ N ; $ left [ $ N ] [ $ N ] = array ( ) ; $ right [ $ N ] [ $ N ] = array ( ) ; $ top [ $ N ] [ $ N ] = array ( ) ; $ bottom [ $ N ] [ $ N ] = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ top [ 0 ] [ $ i ] = $ mat [ 0 ] [ $ i ] ; $ bottom [ $ N - 1 ] [ $ i ] = $ mat [ $ N - 1 ] [ $ i ] ; $ left [ $ i ] [ 0 ] = $ mat [ $ i ] [ 0 ] ; $ right [ $ i ] [ $ N - 1 ] = $ mat [ $ i ] [ $ N - 1 ] ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j < $ N ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == 1 ) $ left [ $ i ] [ $ j ] = $ left [ $ i ] [ $ j - 1 ] + 1 ; else $ left [ $ i ] [ $ j ] = 0 ; if ( $ mat [ $ j ] [ $ i ] == 1 ) $ top [ $ j ] [ $ i ] = $ top [ $ j - 1 ] [ $ i ] + 1 ; else $ top [ $ j ] [ $ i ] = 0 ; $ j = $ N - 1 - $ j ; if ( $ mat [ $ j ] [ $ i ] == 1 ) $ bottom [ $ j ] [ $ i ] = $ bottom [ $ j + 1 ] [ $ i ] + 1 ; else $ bottom [ $ j ] [ $ i ] = 0 ; if ( $ mat [ $ i ] [ $ j ] == 1 ) $ right [ $ i ] [ $ j ] = $ right [ $ i ] [ $ j + 1 ] + 1 ; else $ right [ $ i ] [ $ j ] = 0 ; $ j = $ N - 1 - $ j ; } } $ n = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ len = min ( min ( $ top [ $ i ] [ $ j ] , $ bottom [ $ i ] [ $ j ] ) , min ( $ left [ $ i ] [ $ j ] , $ right [ $ i ] [ $ j ] ) ) ; if ( $ len > $ n ) $ n = $ len ; } } if ( $ n ) return 4 * ( $ n - 1 ) + 1 ; return 0 ; } $ mat = array ( array ( 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ) , array ( 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 ) , array ( 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 ) , array ( 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ) , array ( 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 ) , array ( 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 ) , array ( 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 ) , array ( 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 ) , array ( 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 ) , array ( 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ) ) ; echo findLargestPlus ( $ mat ) ; ? >"}
{"text": "Kembalikan elemen sebelumnya dalam matriks yang berkembang | Pulangan kiri STR dalam matriks berkembang A, B, C dan D. ; Bermula dari kedudukan paling kanan; Jika watak semasa adalah b atau d, tukar kepada A atau C masing -masing dan memecahkan gelung; Jika watak semasa adalah A atau C, ubahnya ke B atau D masing -masing; Kod pemacu", "code": "< ? php function findLeft ( $ str ) { $ n = strlen ( $ str ) ; while ( $ n -- ) { if ( $ str [ $ n ] == ' d ' ) { $ str [ $ n ] = ' c ' ; break ; } if ( $ str [ $ n ] == ' b ' ) { $ str [ $ n ] = ' a ' ; break ; } if ( $ str [ $ n ] == ' a ' ) $ str [ $ n ] = ' b ' ; else if ( $ str [ $ n ] == ' c ' ) $ str [ $ n ] = ' d ' ; } return $ str ; } $ str = \" aacbddc \" ; echo \" Left ▁ of ▁ \" . $ str . \" ▁ is ▁ \" . findLeft ( $ str ) ; return 0 ; ? >"}
{"text": "Cetak N X N Spiral Matriks Menggunakan O (1) Ruang Tambahan | Mencetak matriks lingkaran saiz n x n yang mengandungi nombor dari 1 hingga n x n; X menyimpan lapisan di mana (i, j) elemen terletak; Mencari minimum empat input; Untuk separuh kanan atas; untuk separuh kiri bawah; Kod pemacu; Cetak matriks lingkaran n x n di ruang O (1)", "code": "< ? php function printSpiral ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ x ; $ x = min ( min ( $ i , $ j ) , min ( $ n - 1 - $ i , $ n - 1 - $ j ) ) ; if ( $ i <= $ j ) echo \" TABSYMBOL ▁ \" , ( $ n - 2 * $ x ) * ( $ n - 2 * $ x ) - ( $ i - $ x ) - ( $ j - $ x ) ; else echo \" TABSYMBOL ▁ \" , ( $ n - 2 * $ x - 2 ) * ( $ n - 2 * $ x - 2 ) + ( $ i - $ x ) + ( $ j - $ x ) ; } echo \" STRNEWLINE \" ; } } $ n = 5 ; printSpiral ( $ n ) ; ? >"}
{"text": "Soalan Matriks Boolean | Kod PHP untuk soalan matriks Boolean; Memulakan semua nilai baris [] sebagai 0; Memulakan semua nilai col [] sebagai 0; Simpan baris dan lajur untuk ditandakan sebagai 1 dalam baris [] dan col [] array masing -masing; Ubah suai matriks input [] menggunakan baris yang dibina di atas [] dan col [] array; Fungsi utiliti untuk mencetak matriks 2D; Kod pemacu", "code": "< ? php $ R = 3 ; $ C = 4 ; function modifyMatrix ( & $ mat ) { global $ R , $ C ; $ row = array ( ) ; $ col = array ( ) ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { $ row [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ C ; $ i ++ ) { $ col [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == 1 ) { $ row [ $ i ] = 1 ; $ col [ $ j ] = 1 ; } } } for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C ; $ j ++ ) { if ( $ row [ $ i ] == 1 $ col [ $ j ] == 1 ) { $ mat [ $ i ] [ $ j ] = 1 ; } } } } function printMatrix ( & $ mat ) { global $ R , $ C ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C ; $ j ++ ) { echo $ mat [ $ i ] [ $ j ] . \" \" ; } echo \" STRNEWLINE \" ; } } $ mat = array ( array ( 1 , 0 , 0 , 1 ) , array ( 0 , 0 , 1 , 0 ) , array ( 0 , 0 , 0 , 0 ) ) ; echo \" Input ▁ Matrix ▁ STRNEWLINE \" ; printMatrix ( $ mat ) ; modifyMatrix ( $ mat ) ; echo \" Matrix ▁ after ▁ modification ▁ STRNEWLINE \" ; printMatrix ( $ mat ) ; ? >"}
{"text": "Soalan Matriks Boolean | Kod PHP untuk soalan matriks Boolean; pembolehubah untuk memeriksa sama ada terdapat 1 dalam baris dan lajur pertama; mengemas kini baris pertama dan col jika 1 ditemui; Ubah suai matriks input [] menggunakan baris pertama dan lajur pertama matriks matrik; Ubah suai baris pertama jika ada 1; Ubah suai col pertama jika ada 1; Fungsi utiliti untuk mencetak matriks 2D; Kod pemacu", "code": "< ? php $ R = 3 ; $ C = 4 ; function modifyMatrix ( & $ mat ) { global $ R , $ C ; $ row_flag = false ; $ col_flag = false ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C ; $ j ++ ) { if ( $ i == 0 && $ mat [ $ i ] [ $ j ] == 1 ) $ row_flag = true ; if ( $ j == 0 && $ mat [ $ i ] [ $ j ] == 1 ) $ col_flag = true ; if ( $ mat [ $ i ] [ $ j ] == 1 ) { $ mat [ 0 ] [ $ j ] = 1 ; $ mat [ $ i ] [ 0 ] = 1 ; } } } for ( $ i = 1 ; $ i < $ R ; $ i ++ ) { for ( $ j = 1 ; $ j < $ C ; $ j ++ ) { if ( $ mat [ 0 ] [ $ j ] == 1 $ mat [ $ i ] [ 0 ] == 1 ) { $ mat [ $ i ] [ $ j ] = 1 ; } } } if ( $ row_flag == true ) { for ( $ i = 0 ; $ i < $ C ; $ i ++ ) { $ mat [ 0 ] [ $ i ] = 1 ; } } if ( $ col_flag == true ) { for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { $ mat [ $ i ] [ 0 ] = 1 ; } } } function printMatrix ( & $ mat ) { global $ R , $ C ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C ; $ j ++ ) { echo $ mat [ $ i ] [ $ j ] . \" \" ; } echo \" STRNEWLINE \" ; } } $ mat = array ( array ( 1 , 0 , 0 , 1 ) , array ( 0 , 0 , 1 , 0 ) , array ( 0 , 0 , 0 , 0 ) ) ; echo \" Input ▁ Matrix ▁ : STRNEWLINE \" ; printMatrix ( $ mat ) ; modifyMatrix ( $ mat ) ; echo \" Matrix ▁ After ▁ Modification ▁ : STRNEWLINE \" ; printMatrix ( $ mat ) ; ? >"}
{"text": "Memandangkan matriks Boolean, cari k sedemikian rupa sehingga semua elemen dalam k 'th »u u u dan lajur adalah 1. | Program php untuk mencari saya sedemikian rupa sehingga semua penyertaan dalam i 'th u u u u dan semua entri u u u' th lajur adalah 1; Mula dari bahagian atas - paling tepat di sudut (kita boleh bermula dari sudut lain juga); Memulakan hasil; Cari indeks (gelung ini berjalan paling 2 n kali, kami sama ada nombor baris tambahan atau nombor lajur penurunan); Jika elemen semasa adalah 0, maka baris ini mungkin penyelesaian; Semak semua elemen dalam baris ini; Jika semua nilai adalah 0, maka simpan baris ini sebagai hasil; Kami sampai di sini jika kami menemui 1 dalam baris semasa, jadi baris ini tidak boleh menjadi penyelesaian, nombor baris kenaikan; Jika elemen semasa ialah 1; Semak semua elemen dalam lajur ini; Jika semua elemen adalah 1; Kami sampai di sini jika kami mendapati 0 dalam lajur semasa, jadi lajur ini tidak boleh menjadi penyelesaian, nombor lajur kenaikan; Sekiranya kita tidak dapat mencari hasil di atas, maka hasilnya tidak wujud; Semak sama ada di atas yang dikira adalah sah; Kod pemacu", "code": "< ? php function find ( & $ arr ) { $ n = 5 ; $ i = 0 ; $ j = $ n - 1 ; $ res = -1 ; while ( $ i < $ n && $ j >= 0 ) { if ( $ arr [ $ i ] [ $ j ] == 0 ) { while ( $ j >= 0 && ( $ arr [ $ i ] [ $ j ] == 0 $ i == $ j ) ) $ j -- ; if ( $ j == -1 ) { $ res = $ i ; break ; } else $ i ++ ; } else { while ( $ i < $ n && ( $ arr [ $ i ] [ $ j ] == 1 $ i == $ j ) ) $ i ++ ; if ( $ i == $ n ) { $ res = $ j ; break ; } else $ j -- ; } } if ( $ res == -1 ) return $ res ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ res != $ i && $ arr [ $ i ] [ $ res ] != 1 ) return -1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ res != $ j && $ arr [ $ res ] [ $ j ] != 0 ) return -1 ; return $ res ; } $ mat = array ( array ( 0 , 0 , 1 , 1 , 0 ) , array ( 0 , 0 , 0 , 1 , 0 ) , array ( 1 , 1 , 1 , 1 , 0 ) , array ( 0 , 0 , 0 , 0 , 0 ) , array ( 1 , 1 , 1 , 1 , 1 ) ) ; echo ( find ( $ mat ) ) ; ? >"}
{"text": "Submatrix Sum Queries | Fungsi untuk preprace Mat Input [m] [n]. Fungsi ini terutamanya mengisi aux [m] [n] supaya aux [i] [j] menyimpan jumlah elemen dari (0, 0) hingga (i, j); Salin baris pertama tikar [] [] ke aux [] []; Lakukan lajur bijak; Do Row Wise Sum; A o (1) fungsi masa untuk mengira jumlah submatrix antara (TLI, TLJ) dan (RBI, RBJ) menggunakan Aux [] [] yang dibina oleh fungsi pra -proses; Hasilnya kini jumlah unsur antara (0, 0) dan (RBI, RBJ); Keluarkan unsur -unsur antara (0, 0) dan (TLI - 1, RBJ); Keluarkan unsur antara (0, 0) dan (RBI, TLJ - 1); Tambah aux [tli - 1] [tlj - 1] sebagai unsur antara (0, 0) dan (tli - 1, tlj - 1) dikurangkan dua kali; Kod pemacu", "code": "< ? php function preProcess ( & $ mat , & $ aux ) { $ M = 4 ; $ N = 5 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ aux [ 0 ] [ $ i ] = $ mat [ 0 ] [ $ i ] ; for ( $ i = 1 ; $ i < $ M ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ aux [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + $ aux [ $ i - 1 ] [ $ j ] ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) for ( $ j = 1 ; $ j < $ N ; $ j ++ ) $ aux [ $ i ] [ $ j ] += $ aux [ $ i ] [ $ j - 1 ] ; } function sumQuery ( & $ aux , $ tli , $ tlj , $ rbi , $ rbj ) { $ res = $ aux [ $ rbi ] [ $ rbj ] ; if ( $ tli > 0 ) $ res = $ res - $ aux [ $ tli - 1 ] [ $ rbj ] ; if ( $ tlj > 0 ) $ res = $ res - $ aux [ $ rbi ] [ $ tlj - 1 ] ; if ( $ tli > 0 && $ tlj > 0 ) $ res = $ res + $ aux [ $ tli - 1 ] [ $ tlj - 1 ] ; return $ res ; } $ mat = array ( array ( 1 , 2 , 3 , 4 , 6 ) , array ( 5 , 3 , 8 , 1 , 2 ) , array ( 4 , 6 , 7 , 5 , 5 ) , array ( 2 , 4 , 8 , 9 , 4 ) ) ; preProcess ( $ mat , $ aux ) ; $ tli = 2 ; $ tlj = 2 ; $ rbi = 3 ; $ rbj = 4 ; echo ( \" Query1 : ▁ \" ) ; echo ( sumQuery ( $ aux , $ tli , $ tlj , $ rbi , $ rbj ) ) ; $ tli = 0 ; $ tlj = 0 ; $ rbi = 1 ; $ rbj = 1 ; echo ( \" Query2 : \" echo ( sumQuery ( $ aux , $ tli , $ tlj , $ rbi , $ rbj ) ) ; $ tli = 1 ; $ tlj = 2 ; $ rbi = 3 ; $ rbj = 3 ; echo ( \" Query3 : \" echo ( sumQuery ( $ aux , $ tli , $ tlj , $ rbi , $ rbj ) ) ; ? >"}
{"text": "Program untuk pangkat matriks | Program PHP untuk mencari pangkat matriks; fungsi untuk bertukar dua baris matriks; fungsi untuk mencari pangkat matriks; Sebelum kita melawat baris semasa 'baris', kita pastikan bahawa tikar [baris] [0], .... Mat [baris] [baris - 1] adalah 0. Elemen pepenjuru tidak sifar; Ini menjadikan semua penyertaan lajur semasa sebagai 0 kecuali entri 'tikar [baris] [baris]'; Unsur pepenjuru sudah sifar. Dua kes timbul: 1) Jika terdapat baris di bawahnya dengan kemasukan bukan sifar, maka swap baris ini dengan baris dan proses yang baris 2) Jika semua elemen dalam lajur semasa di bawah tikar [r] [baris] adalah 0, maka remvoe lajur ini dengan menukarnya dengan lajur terakhir dan mengurangkan bilangan lajur dengan 1; Cari elemen bukan sifar dalam lajur semasa; Tukar baris dengan elemen bukan sifar dengan baris ini. ; Jika kita tidak menemui sebarang baris dengan elemen bukan sifar dalam lajur semasa, maka semua nilai dalam lajur ini adalah 0 .; Mengurangkan bilangan lajur; Salin lajur terakhir di sini; Proses baris ini lagi; Uncomment garis -garis ini untuk melihat paparan hasil pertengahan (MAT, R, C); printf (\"\\ n\"); ; berfungsi untuk memaparkan matriks; Kod pemacu", "code": "< ? php $ R = 3 ; $ C = 3 ; function swap ( & $ mat , $ row1 , $ row2 , $ col ) { for ( $ i = 0 ; $ i < $ col ; $ i ++ ) { $ temp = $ mat [ $ row1 ] [ $ i ] ; $ mat [ $ row1 ] [ $ i ] = $ mat [ $ row2 ] [ $ i ] ; $ mat [ $ row2 ] [ $ i ] = $ temp ; } } function rankOfMatrix ( $ mat ) { global $ R , $ C ; $ rank = $ C ; for ( $ row = 0 ; $ row < $ rank ; $ row ++ ) { if ( $ mat [ $ row ] [ $ row ] ) { for ( $ col = 0 ; $ col < $ R ; $ col ++ ) { if ( $ col != $ row ) { $ mult = $ mat [ $ col ] [ $ row ] / $ mat [ $ row ] [ $ row ] ; for ( $ i = 0 ; $ i < $ rank ; $ i ++ ) $ mat [ $ col ] [ $ i ] -= $ mult * $ mat [ $ row ] [ $ i ] ; } } } else { $ reduce = true ; for ( $ i = $ row + 1 ; $ i < $ R ; $ i ++ ) { if ( $ mat [ $ i ] [ $ row ] ) { swap ( $ mat , $ row , $ i , $ rank ) ; $ reduce = false ; break ; } } if ( $ reduce ) { $ rank -- ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) $ mat [ $ i ] [ $ row ] = $ mat [ $ i ] [ $ rank ] ; } $ row -- ; } } return $ rank ; } function display ( $ mat , $ row , $ col ) { for ( $ i = 0 ; $ i < $ row ; $ i ++ ) { for ( $ j = 0 ; $ j < $ col ; $ j ++ ) print ( \" ▁ $ mat [ $ i ] [ $ j ] \" ) ; print ( \" STRNEWLINE \" ) ; } } $ mat = array ( array ( 10 , 20 , 10 ) , array ( -20 , -30 , 10 ) , array ( 30 , 50 , 0 ) ) ; print ( \" Rank ▁ of ▁ the ▁ matrix ▁ is ▁ : ▁ \" . rankOfMatrix ( $ mat ) ) ; ? >"}
{"text": "Kira nombor pulau di mana setiap pulau berturut -turut | Fungsi ini mengambil matriks 'X' dan 'O' dan mengembalikan bilangan pulau -pulau segi empat tepat 'X' di mana tidak ada dua pulau yang baris - bijak atau lajur - bijak bersebelahan, pulau -pulau mungkin bersebelahan bersebelahan; Memulakan hasil; Melintasi matriks input; Jika sel semasa adalah 'x', maka periksa sama ada ini adalah bahagian atas - paling kiri dari segi empat tepat. Jika ya, maka kiraan kenaikan; Kod pemacu", "code": "< ? php function countIslands ( $ mat ) { $ M = 6 ; $ N = 3 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == ' X ' ) { if ( ( $ i == 0 $ mat [ $ i - 1 ] [ $ j ] == ' O ' ) && ( $ j == 0 $ mat [ $ i ] [ $ j - 1 ] == ' O ' ) ) $ count ++ ; } } } return $ count ; } $ mat = array ( array ( ' O ' , ' O ' , ' O ' ) , array ( ' X ' , ' X ' , ' O ' ) , array ( ' X ' , ' X ' , ' O ' ) , array ( ' O ' , ' O ' , ' X ' ) , array ( ' O ' , ' O ' , ' X ' ) , array ( ' X ' , ' X ' , ' O ' ) ) ; echo \" Number ▁ of ▁ rectangular ▁ islands ▁ is ▁ \" , countIslands ( $ mat ) ; ? >"}
{"text": "Memandangkan matriks 'O' dan 'X', ganti 'O' dengan 'X' jika dikelilingi oleh 'X' | Saiz matriks yang diberikan adalah m x n; Fungsi rekursif untuk menggantikan nilai sebelumnya 'prevv' pada '(x, y)' dan semua nilai sekitar (x, y) dengan nilai baru 'newv'. ; Kes asas; Menggantikan warna pada (x, y); Berulang untuk Utara, Timur, Selatan dan Barat; Mengembalikan saiz matriks subsquare saiz maksimum yang dikelilingi oleh 'x'; Langkah 1: Gantikan semua 'O' dengan ' -'; Call Floodfill for All ' -' berbaring di tepi; Sebelah kanan; Bahagian atas; Bahagian bawah; Langkah 3: Gantikan semua ' -' dengan 'x'; Kod pemacu", "code": "< ? php $ M = 6 ; $ N = 6 ; function floodFillUtil ( & $ mat , $ x , $ y , $ prevV , $ newV ) { if ( $ x < 0 $ x >= $ GLOBALS [ ' M ' ] $ y < 0 $ y >= $ GLOBALS [ ' N ' ] ) return ; if ( $ mat [ $ x ] [ $ y ] != $ prevV ) return ; $ mat [ $ x ] [ $ y ] = $ newV ; floodFillUtil ( $ mat , $ x + 1 , $ y , $ prevV , $ newV ) ; floodFillUtil ( $ mat , $ x - 1 , $ y , $ prevV , $ newV ) ; floodFillUtil ( $ mat , $ x , $ y + 1 , $ prevV , $ newV ) ; floodFillUtil ( $ mat , $ x , $ y - 1 , $ prevV , $ newV ) ; } function replaceSurrounded ( & $ mat ) { for ( $ i = 0 ; $ i < $ GLOBALS [ ' M ' ] ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] == ' O ' ) $ mat [ $ i ] [ $ j ] = ' - ' ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' M ' ] ; $ i ++ ) if ( $ mat [ $ i ] [ 0 ] == ' - ' ) floodFillUtil ( $ mat , $ i , 0 , ' - ' , ' O ' ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' M ' ] ; $ i ++ ) if ( $ mat [ $ i ] [ $ GLOBALS [ ' N ' ] - 1 ] == ' - ' ) floodFillUtil ( $ mat , $ i , $ GLOBALS [ ' N ' ] - 1 , ' - ' , ' O ' ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) if ( $ mat [ 0 ] [ $ i ] == ' - ' ) floodFillUtil ( $ mat , 0 , $ i , ' - ' , ' O ' ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) if ( $ mat [ $ GLOBALS [ ' M ' ] - 1 ] [ $ i ] == ' - ' ) floodFillUtil ( $ mat , $ GLOBALS [ ' M ' ] - 1 , $ i , ' - ' , ' O ' ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' M ' ] ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] == ' - ' ) $ mat [ $ i ] [ $ j ] = ' X ' ; } $ mat = array ( array ( ' X ' , ' O ' , ' X ' , ' O ' , ' X ' , ' X ' ) , array ( ' X ' , ' O ' , ' X ' , ' X ' , ' O ' , ' X ' ) , array ( ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' X ' ) , array ( ' O ' , ' X ' , ' X ' , ' X ' , ' X ' , ' X ' ) , array ( ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' O ' ) , array ( ' O ' , ' O ' , ' X ' , ' O ' , ' O ' , ' O ' ) ) ; replaceSurrounded ( $ mat ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' M ' ] ; $ i ++ ) { for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) echo $ mat [ $ i ] [ $ j ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } ? >"}
{"text": "Cari panjang jalan terpanjang berturut -turut dari watak permulaan yang diberikan | Program PHP untuk mencari jalan terpanjang berturut -turut; Matriks alat untuk berulang untuk sel -sel bersebelahan. ; dp [i] [j] menyimpan panjang laluan terpanjang berturut -turut bermula pada ARR [i] [j]. ; Semak sama ada Mat [i] [j] adalah sel yang sah atau tidak. ; Semak sama ada watak semasa bersebelahan dengan watak sebelumnya (watak yang diproses dalam panggilan ibu bapa) atau tidak. ; Saya, j ialah indeks sel semasa dan Prev adalah watak yang diproses dalam panggilan ibu bapa. . Juga tikar [i] [j] adalah watak semasa kami. ; Jika sel ini tidak sah atau semasa tidak bersebelahan dengan yang terdahulu (e g. D tidak bersebelahan dengan b) atau jika sel ini sudah dimasukkan ke dalam jalan daripada pulangan 0.; Jika subproblem ini sudah diselesaikan, kembalikan jawapannya; Memulakan jawapan; berulang untuk laluan dengan sel -sel bersebelahan yang berbeza dan menyimpan panjang laluan terpanjang. ; simpan jawapan dan kembalikan; Mengembalikan panjang laluan terpanjang dengan semua watak berturut -turut antara satu sama lain. Fungsi ini mula -mula memulakan array DP yang digunakan untuk menyimpan hasil subproblem, maka ia memanggil fungsi berasaskan DFS rekursif getLenutil () untuk mencari laluan panjang maksimum; Periksa setiap titik permulaan yang mungkin; berulang untuk semua lapan sel bersebelahan; Kod pemacu", "code": "< ? php $ R = 3 ; $ C = 3 ; $ x = array ( 0 , 1 , 1 , -1 , 1 , 0 , -1 , -1 ) ; $ y = array ( 1 , 0 , 1 , 1 , -1 , -1 , 0 , -1 ) ; $ dp = array_fill ( 0 , $ R , array_fill ( 0 , $ C , -1 ) ) ; function isvalid ( $ i , $ j ) { global $ R , $ C ; if ( $ i < 0 $ j < 0 $ i >= $ R $ j >= $ C ) return false ; return true ; } function isadjacent ( $ prev , $ curr ) { return ( ( ord ( $ curr ) - ord ( $ prev ) ) == 1 ) ; } function getLenUtil ( $ mat , $ i , $ j , $ prev ) { global $ x , $ y , $ dp ; if ( ! isvalid ( $ i , $ j ) || ! isadjacent ( $ prev , $ mat [ $ i ] [ $ j ] ) ) return 0 ; if ( $ dp [ $ i ] [ $ j ] != -1 ) return $ dp [ $ i ] [ $ j ] ; $ ans = 0 ; for ( $ k = 0 ; $ k < 8 ; $ k ++ ) $ ans = max ( $ ans , 1 + getLenUtil ( $ mat , $ i + $ x [ $ k ] , $ j + $ y [ $ k ] , $ mat [ $ i ] [ $ j ] ) ) ; $ dp [ $ i ] [ $ j ] = $ ans ; return $ ans ; } function getLen ( $ mat , $ s ) { global $ R , $ C , $ x , $ y ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == $ s ) { for ( $ k = 0 ; $ k < 8 ; $ k ++ ) $ ans = max ( $ ans , 1 + getLenUtil ( $ mat , $ i + $ x [ $ k ] , $ j + $ y [ $ k ] , $ s ) ) ; } } } return $ ans ; } $ mat = array ( array ( ' a ' , ' c ' , ' d ' ) , array ( ' h ' , ' b ' , ' a ' ) , array ( ' i ' , ' g ' , ' f ' ) ) ; print ( getLen ( $ mat , ' a ' ) . \" \" ) ; print ( getLen ( $ mat , ' e ' ) . \" \" ) ; print ( getLen ( $ mat , ' b ' ) . \" \" ) ; print ( getLen ( $ mat , ' f ' ) . \" \" ) ; ? >"}
{"text": "Mata permulaan minimum untuk mencapai destinasi | Program PHP untuk mencari mata awal minimum untuk mencapai destinasi; DP [i] [j] mewakili pemain mata awal minimum harus mempunyai supaya apabila bermula dengan sel (i, j) berjaya mencapai sel destinasi (m - 1, n - 1); Kes asas; Isi baris terakhir dan lajur terakhir sebagai asas untuk mengisi keseluruhan jadual; Isi meja di bawah fesyen; Kod pemacu", "code": "< ? php $ R = 3 ; $ C = 3 ; function minInitialPoints ( $ points ) { global $ R ; global $ C ; $ dp [ $ R ] [ $ C ] = array ( ) ; $ m = $ R ; $ n = $ C ; $ dp [ $ m - 1 ] [ $ n - 1 ] = $ points [ $ m - 1 ] [ $ n - 1 ] > 0 ? 1 : abs ( $ points [ $ m - 1 ] [ $ n - 1 ] ) + 1 ; for ( $ i = $ m - 2 ; $ i >= 0 ; $ i -- ) $ dp [ $ i ] [ $ n - 1 ] = max ( $ dp [ $ i + 1 ] [ $ n - 1 ] - $ points [ $ i ] [ $ n - 1 ] , 1 ) ; for ( $ j = $ n - 2 ; $ j >= 0 ; $ j -- ) $ dp [ $ m - 1 ] [ $ j ] = max ( $ dp [ $ m - 1 ] [ $ j + 1 ] - $ points [ $ m - 1 ] [ $ j ] , 1 ) ; for ( $ i = $ m - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = $ n - 2 ; $ j >= 0 ; $ j -- ) { $ min_points_on_exit = min ( $ dp [ $ i + 1 ] [ $ j ] , $ dp [ $ i ] [ $ j + 1 ] ) ; $ dp [ $ i ] [ $ j ] = max ( $ min_points_on_exit - $ points [ $ i ] [ $ j ] , 1 ) ; } } return $ dp [ 0 ] [ 0 ] ; } $ points = array ( array ( -2 , -3 , 3 ) , array ( -5 , -10 , 1 ) , array ( 10 , 30 , -5 ) ) ; echo \" Minimum ▁ Initial ▁ Points ▁ Required : ▁ \" , minInitialPoints ( $ points ) ; ? >"}
{"text": "Cari Elemen Puncak | Fungsi berasaskan carian binari yang mengembalikan indeks elemen puncak; Cari indeks elemen pertengahan (rendah + tinggi) / 2; Bandingkan elemen pertengahan dengan jirannya (jika jiran wujud); Jika elemen tengah tidak puncak dan jiran kiri lebih besar daripada itu, maka separuh kiri mesti mempunyai elemen puncak; Jika elemen tengah tidak puncak dan jiran kanannya lebih besar daripada itu, maka separuh kanan mesti mempunyai elemen puncak; Pembungkus ke atas fungsi rekursif findpeakutil (); Kod pemacu", "code": "< ? php function findPeakUtil ( $ arr , $ low , $ high , $ n ) { $ mid = $ low + ( $ high - $ low ) / 2 ; if ( ( $ mid == 0 $ arr [ $ mid - 1 ] <= $ arr [ $ mid ] ) && ( $ mid == $ n - 1 $ arr [ $ mid + 1 ] <= $ arr [ $ mid ] ) ) return $ mid ; else if ( $ mid > 0 && $ arr [ $ mid - 1 ] > $ arr [ $ mid ] ) return findPeakUtil ( $ arr , $ low , ( $ mid - 1 ) , $ n ) ; else return ( findPeakUtil ( $ arr , ( $ mid + 1 ) , $ high , $ n ) ) ; } function findPeak ( $ arr , $ n ) { return floor ( findPeakUtil ( $ arr , 0 , $ n - 1 , $ n ) ) ; } $ arr = array ( 1 , 3 , 20 , 4 , 1 , 0 ) ; $ n = sizeof ( $ arr ) ; echo \" Index ▁ of ▁ a ▁ peak ▁ point ▁ is ▁ \" , findPeak ( $ arr , $ n ) ; ? >"}
{"text": "Cari dua elemen berulang dalam array yang diberikan | Cetak fungsi berulang; Kod pemacu", "code": "< ? php function printRepeating ( $ arr , $ size ) { $ i ; $ j ; echo \" ▁ Repeating ▁ elements ▁ are ▁ \" ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ size ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) echo $ arr [ $ i ] , \" ▁ \" ; } $ arr = array ( 4 , 2 , 4 , 5 , 2 , 3 , 1 ) ; $ arr_size = sizeof ( $ arr , 0 ) ; printRepeating ( $ arr , $ arr_size ) ; ? >"}
{"text": "Cari dua elemen berulang dalam array yang diberikan | Fungsi; Kod pemacu", "code": "< ? php function printRepeating ( $ arr , $ size ) { $ count = array_fill ( 0 , $ size , 0 ) ; echo \" Repeated ▁ elements ▁ are ▁ \" ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ count [ $ arr [ $ i ] ] == 1 ) echo $ arr [ $ i ] . \" ▁ \" ; else $ count [ $ arr [ $ i ] ] ++ ; } } $ arr = array ( 4 , 2 , 4 , 5 , 2 , 3 , 1 ) ; $ arr_size = count ( $ arr ) ; printRepeating ( $ arr , $ arr_size ) ; ? >"}
{"text": "Cari dua elemen berulang dalam array yang diberikan | fungsi printRepeating; S adalah untuk jumlah elemen dalam arr []; P adalah untuk produk elemen dalam arr []; X dan Y adalah dua elemen berulang; D adalah untuk perbezaan x dan y, i. e. , x - y; Hitung jumlah dan produk semua elemen dalam arr []; S adalah x + y sekarang; P adalah x * y sekarang; D adalah x - y sekarang; faktorial n; kod pemacu", "code": "< ? php function printRepeating ( $ arr , $ size ) { $ S = 0 ; $ P = 1 ; $ x ; $ y ; $ D ; $ n = $ size - 2 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ S = $ S + $ arr [ $ i ] ; $ P = $ P * $ arr [ $ i ] ; } $ S = $ S - $ n * ( $ n + 1 ) / 2 ; $ P = $ P / fact ( $ n ) ; $ D = sqrt ( $ S * $ S - 4 * $ P ) ; $ x = ( $ D + $ S ) / 2 ; $ y = ( $ S - $ D ) / 2 ; echo \" The ▁ two ▁ Repeating ▁ elements ▁ are ▁ \" . $ x . \" & \" } function fact ( $ n ) { return ( $ n == 0 ) ? 1 : $ n * fact ( $ n - 1 ) ; } $ arr = array ( 4 , 2 , 4 , 5 , 2 , 3 , 1 ) ; $ arr_size = count ( $ arr ) ; printRepeating ( $ arr , $ arr_size ) ; ? >"}
{"text": "Cari dua elemen berulang dalam array yang diberikan | Kod PHP untuk mencari dua elemen berulang dalam array yang diberikan; Akan memegang xor semua elemen; Hanya mempunyai satu set bit XOR; Dapatkan xor semua elemen dalam arr [] dan {1, 2. . n}; Dapatkan bit set kanan dalam set_bit_no; Sekarang bahagikan unsur -unsur dalam dua set dengan membandingkan bit XOR set paling kanan dengan bit pada kedudukan yang sama dalam setiap elemen. ; Xor set pertama di arr []; Xor set kedua dalam arr []; Xor set pertama dalam arr [] dan {1, 2, ... n}; Xor set kedua dalam arr [] dan {1, 2, ... n}; kod pemacu", "code": "< ? php function printRepeating ( $ arr , $ size ) { $ xor = $ arr [ 0 ] ; $ set_bit_no ; $ i ; $ n = $ size - 2 ; $ x = 0 ; $ y = 0 ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) $ xor ^= $ arr [ $ i ] ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ xor ^= $ i ; $ set_bit_no = $ xor & ~ ( $ xor - 1 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i & $ set_bit_no ) $ x = $ x ^ $ i ; else $ y = $ y ^ $ i ; } echo \" n ▁ The ▁ two ▁ repeating ▁ elements ▁ are ▁ \" ; echo $ y . \" ▁ \" . $ x ; } ? > $ arr = array ( 4 , 2 , 4 , 5 , 2 , 3 , 1 ) ; $ arr_size = count ( $ arr ) ; printRepeating ( $ arr , $ arr_size ) ;"}
{"text": "Cari dua elemen berulang dalam array yang diberikan | Berfungsi untuk mencetak berulang; Kod pemacu", "code": "< ? php function printRepeating ( $ arr , $ size ) { $ i ; echo \" The ▁ repeating ▁ elements ▁ are \" , \" ▁ \" ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ abs ( $ arr [ $ i ] ) ] > 0 ) $ arr [ abs ( $ arr [ $ i ] ) ] = - $ arr [ abs ( $ arr [ $ i ] ) ] ; else echo abs ( $ arr [ $ i ] ) , \" ▁ \" ; } } $ arr = array ( 4 , 2 , 4 , 5 , 2 , 3 , 1 ) ; $ arr_size = sizeof ( $ arr ) ; printRepeating ( $ arr , $ arr_size ) ; #This  code is contributed by aj_36 NEW_LINE ? >"}
{"text": "Cari subarray dengan jumlah yang diberikan | Tetapkan 1 (Nombor Nonnegative) | Pulangan benar jika ada subarray arr [] dengan jumlah yang sama dengan 'jumlah' sebaliknya mengembalikan palsu. Juga, mencetak hasilnya; Pilih titik permulaan; Cuba semua subarrays bermula dengan 'I'; Kod pemacu", "code": "< ? php function subArraySum ( $ arr , $ n , $ sum ) { $ curr_sum ; $ i ; $ j ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum = $ arr [ $ i ] ; for ( $ j = $ i + 1 ; $ j <= $ n ; $ j ++ ) { if ( $ curr_sum == $ sum ) { echo \" Sum ▁ found ▁ between ▁ indexes ▁ \" , $ i , \" ▁ and ▁ \" , $ j - 1 ; return 1 ; } if ( $ curr_sum > $ sum $ j == $ n ) break ; $ curr_sum = $ curr_sum + $ arr [ $ j ] ; } } echo \" No ▁ subarray ▁ found \" ; return 0 ; } $ arr = array ( 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 ) ; $ n = sizeof ( $ arr ) ; $ sum = 23 ; subArraySum ( $ arr , $ n , $ sum ) ; return 0 ; ? >"}
{"text": "Cari subarray dengan jumlah yang diberikan | Tetapkan 1 (Nombor Nonnegative) | Pulangan benar jika ada subarray arr [] dengan jumlah yang sama dengan 'jumlah' sebaliknya mengembalikan palsu. Juga, mencetak hasilnya; Memulakan curr_sum sebagai nilai elemen pertama dan titik permulaan sebagai 0; Tambah elemen satu demi satu ke curr_sum dan jika curr_sum melebihi jumlah, kemudian keluarkan elemen permulaan; Jika curr_sum melebihi jumlah, maka keluarkan elemen permulaan; Jika curr_sum menjadi sama dengan jumlah, maka kembali benar; Tambah elemen ini ke curr_sum; Jika kita sampai di sini, maka tidak ada subarray; Kod pemacu", "code": "< ? php function subArraySum ( $ arr , $ n , $ sum ) { $ curr_sum = $ arr [ 0 ] ; $ start = 0 ; $ i ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { while ( $ curr_sum > $ sum and $ start < $ i - 1 ) { $ curr_sum = $ curr_sum - $ arr [ $ start ] ; $ start ++ ; } if ( $ curr_sum == $ sum ) { echo \" Sum ▁ found ▁ between ▁ indexes \" , \" ▁ \" , $ start , \" ▁ \" , \" and ▁ \" , \" ▁ \" , $ i - 1 ; return 1 ; } if ( $ i < $ n ) $ curr_sum = $ curr_sum + $ arr [ $ i ] ; } echo \" No ▁ subarray ▁ found \" ; return 0 ; } $ arr = array ( 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 ) ; $ n = count ( $ arr ) ; $ sum = 23 ; subArraySum ( $ arr , $ n , $ sum ) ;"}
{"text": "Perbezaan terkecil dari tiga tatasusunan | berfungsi untuk mencari nombor maksimum; berfungsi untuk mencari nombor minimum; Mencari dan mencetak triplet perbezaan terkecil; menyusun ketiga -tiga tatasusunan; Untuk menyimpan tiga nombor yang dihasilkan; penunjuk kepada arr1, arr2, arr3 masing -masing; Gelung sehingga satu array sampai ke hujungnya mencari perbezaan terkecil. ; nombor maksimum; Cari minimum dan kenaikan indeksnya. ; membandingkan perbezaan baru dengan yang sebelumnya dan mengemas kini dengan sewajarnya; Hasil cetak; Kod pemacu", "code": "< ? php function maximum ( $ a , $ b , $ c ) { return max ( max ( $ a , $ b ) , $ c ) ; } function minimum ( $ a , $ b , $ c ) { return min ( min ( $ a , $ b ) , $ c ) ; } function smallestDifferenceTriplet ( $ arr1 , $ arr2 , $ arr3 , $ n ) { sort ( $ arr1 ) ; sort ( $ arr2 ) ; sort ( $ arr3 ) ; $ res_min ; $ res_max ; $ res_mid ; $ i = 0 ; $ j = 0 ; $ k = 0 ; $ diff = PHP_INT_MAX ; while ( $ i < $ n && $ j < $ n && $ k < $ n ) { $ sum = $ arr1 [ $ i ] + $ arr2 [ $ j ] + $ arr3 [ $ k ] ; $ max = maximum ( $ arr1 [ $ i ] , $ arr2 [ $ j ] , $ arr3 [ $ k ] ) ; $ min = minimum ( $ arr1 [ $ i ] , $ arr2 [ $ j ] , $ arr3 [ $ k ] ) ; if ( $ min == $ arr1 [ $ i ] ) $ i ++ ; else if ( $ min == $ arr2 [ $ j ] ) $ j ++ ; else $ k ++ ; if ( $ diff > ( $ max - $ min ) ) { $ diff = $ max - $ min ; $ res_max = $ max ; $ res_mid = $ sum - ( $ max + $ min ) ; $ res_min = $ min ; } } echo $ res_max , \" , ▁ \" , $ res_mid , \" , ▁ \" , $ res_min ; } $ arr1 = array ( 5 , 2 , 8 ) ; $ arr2 = array ( 10 , 7 , 12 ) ; $ arr3 = array ( 9 , 14 , 6 ) ; $ n = sizeof ( $ arr1 ) ; smallestDifferenceTriplet ( $ arr1 , $ arr2 , $ arr3 , $ n ) ; ? >"}
{"text": "Cari triplet yang Jumlah kepada nilai tertentu | pulangan benar jika terdapat triplet dengan jumlah yang sama dengan 'jumlah' yang ada dalam []. Juga, mencetak triplet; Betulkan elemen pertama sebagai [i]; Betulkan elemen kedua sebagai [J]; Sekarang cari nombor ketiga; Jika kita sampai di sini, maka tiada triplet ditemui; Kod pemacu", "code": "< ? php function find3Numbers ( $ A , $ arr_size , $ sum ) { $ l ; $ r ; for ( $ i = 0 ; $ i < $ arr_size - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ arr_size - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ arr_size ; $ k ++ ) { if ( $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] == $ sum ) { echo \" Triplet ▁ is \" , \" ▁ \" , $ A [ $ i ] , \" , ▁ \" , $ A [ $ j ] , \" , ▁ \" , $ A [ $ k ] ; return true ; } } } } return false ; } $ A = array ( 1 , 4 , 45 , 6 , 10 , 8 ) ; $ sum = 22 ; $ arr_size = sizeof ( $ A ) ; find3Numbers ( $ A , $ arr_size , $ sum ) ; ? >"}
{"text": "Cari triplet yang Jumlah kepada nilai tertentu | pulangan benar jika terdapat triplet dengan jumlah yang sama dengan 'jumlah' yang ada dalam []. Juga, mencetak triplet; Menyusun unsur -unsur; Sekarang selesaikan elemen pertama satu demi satu dan cari dua elemen lain; Untuk mencari dua elemen yang lain, mulakan dua pembolehubah indeks dari dua sudut array dan gerakkannya ke indeks satu sama lain dari elemen pertama; Dalam indeks elemen yang tinggal dari elemen terakhir; A [i] + a [l] + a [r]> sum; Jika kita sampai di sini, maka tiada triplet ditemui; Kod pemacu", "code": "< ? php function find3Numbers ( $ A , $ arr_size , $ sum ) { $ l ; $ r ; sort ( $ A ) ; for ( $ i = 0 ; $ i < $ arr_size - 2 ; $ i ++ ) { $ l = $ i + 1 ; $ r = $ arr_size - 1 ; while ( $ l < $ r ) { if ( $ A [ $ i ] + $ A [ $ l ] + $ A [ $ r ] == $ sum ) { echo \" Triplet ▁ is ▁ \" , $ A [ $ i ] , \" ▁ \" , $ A [ $ l ] , \" ▁ \" , $ A [ $ r ] , \" STRNEWLINE \" ; return true ; } else if ( $ A [ $ i ] + $ A [ $ l ] + $ A [ $ r ] < $ sum ) $ l ++ ; else $ r -- ; } } return false ; } $ A = array ( 1 , 4 , 45 , 6 , 10 , 8 ) ; $ sum = 22 ; $ arr_size = sizeof ( $ A ) ; find3Numbers ( $ A , $ arr_size , $ sum ) ; ? >"}
{"text": "Subarray / substring vs seterusnya dan program untuk menjana mereka | Cetak semua subarrays di arr [0. n - 1]; Pilih titik permulaan; Memilih titik akhir; Cetak subarray antara titik permulaan dan akhir semasa; Kod pemacu", "code": "< ? php function subArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) echo $ arr [ $ k ] , \" ▁ \" ; echo \" STRNEWLINE \" ; } } } $ arr = array ( 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo \" All ▁ Non - empty ▁ Subarrays STRNEWLINE \" ; subArray ( $ arr , $ n ) ; ? >"}
{"text": "Subarray / substring vs seterusnya dan program untuk menjana mereka | Kod PHP untuk menjana semua kemungkinan berikutnya. Kerumitan masa o (n * 2 ^ n); Bilangan berikutnya ialah (2 * * n - 1); Jalankan dari kaunter 000.. 1 hingga 111. 1; Semak jika bit jth di kaunter ditetapkan jika ditetapkan kemudian cetak elemen jth dari arr []; Kod pemacu", "code": "< ? php function printSubsequences ( $ arr , $ n ) { $ opsize = pow ( 2 , $ n ) ; for ( $ counter = 1 ; $ counter < $ opsize ; $ counter ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ counter & ( 1 << $ j ) ) echo $ arr [ $ j ] , \" ▁ \" ; } echo \" STRNEWLINE \" ; } } $ arr = array ( 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo \" All ▁ Non - empty ▁ Subsequences STRNEWLINE \" ; printSubsequences ( $ arr , $ n ) ; ? >"}
{"text": "Teka -teki Arus Produk | Berfungsi untuk mencetak pelbagai produk untuk array arr [] saiz n; Kes asas; Memperuntukkan memori untuk ProductArray; Memulakan array produk sebagai 1; Dalam gelung ini, pembolehubah temp mengandungi produk unsur -unsur di sebelah kiri tidak termasuk ARR [i]; Memulakan temp untuk 1 untuk produk di sebelah kanan; Dalam gelung ini, pembolehubah temp mengandungi produk unsur -unsur di sebelah kanan tidak termasuk ARR [i]; Cetak array prod yang dibina; Kod pemacu", "code": "< ? php function productArray ( $ arr , $ n ) { if ( $ n == 1 ) { echo \"0\" ; return ; } $ i ; $ temp = 1 ; $ prod = array ( ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ prod [ $ j ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ prod [ $ i ] = $ temp ; $ temp *= $ arr [ $ i ] ; } $ temp = 1 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ prod [ $ i ] *= $ temp ; $ temp *= $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ prod [ $ i ] , \" ▁ \" ; return ; } $ arr = array ( 10 , 3 , 5 , 6 , 2 ) ; $ n = count ( $ arr ) ; echo \" The ▁ product ▁ array ▁ is ▁ : ▁ STRNEWLINE \" ; productArray ( $ arr , $ n ) ; ? >"}
{"text": "Semak jika elemen array berturut -turut | Kaedah ditambah 3 | Fungsi memeriksa jika elemen array berturut -turut. Jika unsur -unsur berturut -turut, maka kembali benar, lain -lain mengembalikan palsu; 1) Dapatkan elemen minimum dalam array; 2) Dapatkan elemen maksimum dalam array; 3) $ max - $ min + 1 adalah sama dengan $ n, maka hanya periksa semua elemen; Buat array temp untuk memegang bendera yang dilawati semua elemen. ; Jika kita melihat elemen lagi, maka kembali palsu; Jika dikunjungi kali pertama, maka tandakan elemen seperti yang dikunjungi; Jika semua elemen berlaku sekali, maka kembali benar; jika ($ max - $ min + 1! = $ n); Fungsi utiliti; Kod pemacu", "code": "< ? php function areConsecutive ( $ arr , $ n ) { if ( $ n < 1 ) return false ; $ min = getMin ( $ arr , $ n ) ; $ max = getMax ( $ arr , $ n ) ; if ( $ max - $ min + 1 == $ n ) { $ visited = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ visited [ $ i ] = false ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ visited [ $ arr [ $ i ] - $ min ] != false ) return false ; $ visited [ $ arr [ $ i ] - $ min ] = true ; } return true ; } return false ; } function getMin ( $ arr , $ n ) { $ min = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < $ min ) $ min = $ arr [ $ i ] ; return $ min ; } function getMax ( $ arr , $ n ) { $ max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; return $ max ; } $ arr = array ( 5 , 4 , 2 , 3 , 1 , 6 ) ; $ n = count ( $ arr ) ; if ( areConsecutive ( $ arr , $ n ) == true ) echo \" Array ▁ elements ▁ are ▁ consecutive ▁ \" ; else echo \" Array ▁ elements ▁ are ▁ not ▁ consecutive ▁ \" ; ? >"}
{"text": "Semak jika elemen array berturut -turut | Kaedah ditambah 3 | Fungsi memeriksa jika unsur -unsur array berturut -turut jika unsur -unsur berturut -turut, maka kembali benar, lain -lain mengembalikan palsu; 1) Dapatkan elemen minimum dalam array; 2) Dapatkan elemen maksimum dalam array; 3) max - min + 1 adalah sama dengan n maka hanya periksa semua elemen; Jika nilai pada indeks j adalah negatif maka terdapat pengulangan; Jika kita tidak melihat nilai negatif maka semua elemen adalah berbeza; jika (max - min + 1! = n); Fungsi utiliti; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function areConsecutive ( $ arr , $ n ) { if ( $ n < 1 ) return false ; $ min = getMin ( $ arr , $ n ) ; $ max = getMax ( $ arr , $ n ) ; if ( $ max - $ min + 1 == $ n ) { $ i ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; if ( $ arr [ $ i ] < 0 ) $ j = - $ arr [ $ i ] - $ min ; else $ j = $ arr [ $ i ] - $ min ; if ( $ arr [ $ j ] > 0 ) $ arr [ $ j ] = - $ arr [ $ j ] ; else return false ; } return true ; } return false ; } function getMin ( $ arr , $ n ) { $ min = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < $ min ) $ min = $ arr [ $ i ] ; return $ min ; } function getMax ( $ arr , $ n ) { $ max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; return $ max ; } $ arr = array ( 1 , 4 , 5 , 3 , 2 , 6 ) ; $ n = count ( $ arr ) ; if ( areConsecutive ( $ arr , $ n ) == true ) echo \" ▁ Array ▁ elements ▁ are ▁ consecutive ▁ \" ; else echo \" ▁ Array ▁ elements ▁ are ▁ not ▁ consecutive ▁ \" ; ? >"}
{"text": "Cari pelengkap relatif dua susunan yang disusun | Program PHP untuk mencari semua elemen ARR1 [] yang tidak hadir dalam ARR2 []; Jika elemen semasa dalam arr2 [] lebih besar, maka arr1 [i] tidak dapat hadir dalam arr2 [j..m-1]; Melangkau unsur -unsur yang lebih kecil daripada ARR2 []; Unsur -unsur yang sama dijumpai (melangkau dalam kedua -dua tatasusunan); Mencetak elemen yang tinggal dari ARR1 []; Kod pemacu", "code": "< ? php function relativeComplement ( $ arr1 , $ arr2 , $ n , $ m ) { $ i = 0 ; $ j = 0 ; while ( $ i < $ n && $ j < $ m ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) { echo $ arr1 [ $ i ] , \" \" ; $ i ++ ; } else if ( $ arr1 [ $ i ] > $ arr2 [ $ j ] ) { $ j ++ ; } else if ( $ arr1 [ $ i ] == $ arr2 [ $ j ] ) { $ i ++ ; $ j ++ ; } } while ( $ i < $ n ) echo $ arr1 [ $ i ] , \" ▁ \" ; } { $ arr1 = array ( 3 , 6 , 10 , 12 , 15 ) ; $ arr2 = array ( 1 , 3 , 5 , 10 , 16 ) ; $ n = sizeof ( $ arr1 ) / sizeof ( $ arr1 [ 0 ] ) ; $ m = sizeof ( $ arr2 ) / sizeof ( $ arr2 [ 0 ] ) ; relativeComplement ( $ arr1 , $ arr2 , $ n , $ m ) ; return 0 ; } ? >"}
{"text": "Kenaikan minimum oleh operasi k untuk menjadikan semua elemen sama | fungsi untuk mengira operasi min; unsur maksimum array; melangkah untuk semua elemen; Semak jika elemen boleh membuat sama dengan max atau tidak jika tidak kemudian kembali - 1; lain kemas kini res untuk operasi yang diperlukan; hasil pulangan; Kod pemacu", "code": "< ? php function minOps ( $ arr , $ n , $ k ) { $ max = max ( $ arr ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ max - $ arr [ $ i ] ) % $ k != 0 ) return -1 ; else $ res += ( $ max - $ arr [ $ i ] ) / $ k ; } return $ res ; } $ arr = array ( 21 , 33 , 9 , 45 , 63 ) ; $ n = count ( $ arr ) ; $ k = 6 ; print ( minOps ( $ arr , $ n , $ k ) ) ; ? >"}
{"text": "Meminimumkan (max (a [i], b [j], c [k]) | kod php untuk pendekatan di atas; mengira perbezaan min dari indeks terakhir senarai; memeriksa keadaan; mengira istilah maksimum dari senarai; bergerak ke nilai yang lebih kecil dalam array dengan maksimum dari tiga.;", "code": "< ? php function solve ( $ A , $ B , $ C , $ i , $ j , $ k ) { $ min_diff ; $ current_diff ; $ max_term ; $ min_diff = abs ( max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) - min ( $ A [ $ i ] , min ( $ B [ $ j ] , $ C [ $ k ] ) ) ) ; while ( $ i != -1 && $ j != -1 && $ k != -1 ) { $ current_diff = abs ( max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) - min ( $ A [ $ i ] , min ( $ B [ $ j ] , $ C [ $ k ] ) ) ) ; if ( $ current_diff < $ min_diff ) $ min_diff = $ current_diff ; $ max_term = max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) ; if ( $ A [ $ i ] == $ max_term ) $ i -= 1 ; else if ( $ B [ $ j ] == $ max_term ) $ j -= 1 ; else $ k -= 1 ; } return $ min_diff ; } $ D = array ( 5 , 8 , 10 , 15 ) ; $ E = array ( 6 , 9 , 15 , 78 , 89 ) ; $ F = array ( 2 , 3 , 6 , 6 , 8 , 8 , 10 ) ; $ nD = sizeof ( $ D ) ; $ nE = sizeof ( $ E ) ; $ nF = sizeof ( $ F ) ; echo solve ( $ D , $ E , $ F , $ nD - 1 , $ nE - 1 , $ nF - 1 ) ; ? >"}
{"text": "Analisis Algoritma | Tetapkan 2 (kes terburuk, purata dan terbaik) | Linearly cari x dalam arr []. Jika x hadir kemudian kembalikan indeks, jika tidak, pulangan - 1; Kod pemacu", "code": "< ? php function search ( $ arr , $ n , $ x ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; } return -1 ; } $ arr = array ( 1 , 10 , 30 , 15 ) ; $ x = 30 ; $ n = sizeof ( $ arr ) ; echo $ x . \" ▁ is ▁ present ▁ at ▁ index ▁ \" . search ( $ arr , $ n , $ x ) ;"}
{"text": "Carian binari | Fungsi carian binari rekursif. Ia mengembalikan lokasi x dalam array yang diberikan [l. . r] hadir, jika tidak - 1; Jika elemen hadir di tengah -tengahnya sendiri; Jika elemen lebih kecil daripada pertengahan, maka ia hanya boleh hadir di subarray kiri; Lain elemen hanya boleh hadir di subarray kanan; Kami sampai di sini apabila elemen tidak hadir dalam pelbagai; Kod pemacu", "code": "< ? php function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = ceil ( $ l + ( $ r - $ l ) / 2 ) ; if ( $ arr [ $ mid ] == $ x ) return floor ( $ mid ) ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } return -1 ; } $ arr = array ( 2 , 3 , 4 , 10 , 40 ) ; $ n = count ( $ arr ) ; $ x = 10 ; $ result = binarySearch ( $ arr , 0 , $ n - 1 , $ x ) ; if ( ( $ result == -1 ) ) echo \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ; else echo \" Element ▁ is ▁ present ▁ at ▁ index ▁ \" , $ result ; ? >"}
{"text": "Carian binari | Fungsi carian binari berulang. Ia mengembalikan lokasi x dalam array yang diberikan [l. . r] jika hadir, jika tidak - 1; Semak sama ada X hadir pada pertengahan; Jika x lebih besar, abaikan separuh kiri; Jika x lebih kecil, abaikan separuh kanan; Jika kita sampai di sini, maka elemen tidak hadir; Kod pemacu", "code": "< ? php function binarySearch ( $ arr , $ l , $ r , $ x ) { while ( $ l <= $ r ) { $ m = $ l + ( $ r - $ l ) / 2 ; if ( $ arr [ $ m ] == $ x ) return floor ( $ m ) ; if ( $ arr [ $ m ] < $ x ) $ l = $ m + 1 ; else $ r = $ m - 1 ; } return -1 ; } $ arr = array ( 2 , 3 , 4 , 10 , 40 ) ; $ n = count ( $ arr ) ; $ x = 10 ; $ result = binarySearch ( $ arr , 0 , $ n - 1 , $ x ) ; if ( ( $ result == -1 ) ) echo \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ; else echo \" Element ▁ is ▁ present ▁ at ▁ index ▁ \" , $ result ; ? >"}
{"text": "Jump Search | Program PHP untuk melaksanakan carian melompat; Mencari saiz blok untuk melompat; Mencari blok di mana elemen hadir (jika ada); Melakukan carian linear untuk x dalam blok bermula dengan sebelumnya. ; Jika kita mencapai blok seterusnya atau akhir array, elemen tidak hadir. ; Jika elemen dijumpai; Program pemacu untuk menguji fungsi; Cari indeks '$ x' menggunakan carian lompat; Cetak indeks di mana '$ x' terletak", "code": "< ? php function jumpSearch ( $ arr , $ x , $ n ) { $ step = sqrt ( $ n ) ; $ prev = 0 ; while ( $ arr [ min ( $ step , $ n ) - 1 ] < $ x ) { $ prev = $ step ; $ step += sqrt ( $ n ) ; if ( $ prev >= $ n ) return -1 ; } while ( $ arr [ $ prev ] < $ x ) { $ prev ++ ; if ( $ prev == min ( $ step , $ n ) ) return -1 ; } if ( $ arr [ $ prev ] == $ x ) return $ prev ; return -1 ; } $ arr = array ( 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 ) ; $ x = 55 ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; $ index = jumpSearch ( $ arr , $ x , $ n ) ; echo \" Number ▁ \" . $ x . \" ▁ is ▁ at ▁ index ▁ \" . $ index ; return 0 ; ? >"}
{"text": "Carian Eksponen | Mengembalikan kedudukan kejadian pertama X dalam array; Jika X hadir di lokasi pertama itu sendiri; Cari julat untuk carian binari dengan berulang kali ganda; Panggil pencarian binari untuk julat yang dijumpai. ; Fungsi carian binari rekursif. Ia mengembalikan lokasi x dalam array yang diberikan [l. . r] hadir, jika tidak - 1; Jika elemen hadir di tengah -tengahnya sendiri; Jika elemen lebih kecil daripada pertengahan, maka ia hanya boleh hadir n subarray kiri; Lain elemen hanya boleh hadir di subarray kanan; Kami sampai di sini apabila elemen tidak hadir dalam pelbagai; Kod pemacu", "code": "< ? php function exponentialSearch ( $ arr , $ n , $ x ) { if ( $ arr [ 0 ] == $ x ) return 0 ; $ i = 1 ; while ( $ i < $ n and $ arr [ $ i ] <= $ x ) $ i = $ i * 2 ; return binarySearch ( $ arr , $ i / 2 , min ( $ i , $ n - 1 ) , $ x ) ; } function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = $ l + ( $ r - $ l ) / 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } return -1 ; } $ arr = array ( 2 , 3 , 4 , 10 , 40 ) ; $ n = count ( $ arr ) ; $ x = 10 ; $ result = exponentialSearch ( $ arr , $ n , $ x ) ; if ( $ result == -1 ) echo \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ; else echo \" Element ▁ is ▁ present ▁ at ▁ index ▁ \" , $ result ; ? >"}
{"text": "Radix Sort | Fungsi untuk mengira jenis ARR [] mengikut digit yang diwakili oleh EXP. ; pelbagai output; Menyimpan kiraan kejadian dalam kiraan []; Tukar kiraan [i] supaya kiraan [i] kini mengandungi kedudukan sebenar digit ini dalam output []; Membina array output; Salin array output ke arr [], supaya arr [] kini mengandungi nombor yang disusun mengikut digit semasa; Fungsi utama untuk jenis arr [] saiz n menggunakan jenis radix; Cari nombor maksimum untuk mengetahui bilangan digit; Adakah mengira jenis untuk setiap digit. Perhatikan bahawa bukannya lulus nombor digit, EXP diluluskan. exp adalah 10 ^ i di mana saya adalah nombor digit semasa; Fungsi utiliti untuk mencetak array; Kod pemacu; Panggilan fungsi", "code": "< ? php function countSort ( & $ arr , $ n , $ exp ) { $ output = array_fill ( 0 , $ n , 0 ) ; $ count = array_fill ( 0 , 10 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ( $ arr [ $ i ] / $ exp ) % 10 ] ++ ; for ( $ i = 1 ; $ i < 10 ; $ i ++ ) $ count [ $ i ] += $ count [ $ i - 1 ] ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ output [ $ count [ ( $ arr [ $ i ] / $ exp ) % 10 ] - 1 ] = $ arr [ $ i ] ; $ count [ ( $ arr [ $ i ] / $ exp ) % 10 ] -- ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ output [ $ i ] ; } function radixsort ( & $ arr , $ n ) { $ m = max ( $ arr ) ; for ( $ exp = 1 ; $ m / $ exp > 0 ; $ exp *= 10 ) countSort ( $ arr , $ n , $ exp ) ; } function PrintArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } $ arr = array ( 170 , 45 , 75 , 90 , 802 , 24 , 2 , 66 ) ; $ n = count ( $ arr ) ; radixsort ( $ arr , $ n ) ; PrintArray ( $ arr , $ n ) ; ? >"}
{"text": "SENARAI ITERATIVE SENDIRI | Berfungsi untuk menukar nombor; Fungsi ini mengambil elemen terakhir sebagai pivot, meletakkan elemen pivot pada kedudukan yang betul dalam array yang disusun, dan tempat yang lebih kecil (lebih kecil daripada pivot) ke kiri pivot dan semua unsur yang lebih besar ke kanan pivot; A [] -> array untuk disusun, l -> indeks permulaan, h -> indeks akhir; Indeks pembahagian; Kod pemacu", "code": "< ? php function swap ( & $ a , & $ b ) { $ temp = $ a ; $ a = $ b ; $ b = $ temp ; } function partition ( & $ arr , $ l , $ h ) { $ x = $ arr [ $ h ] ; $ i = ( $ l - 1 ) ; for ( $ j = $ l ; $ j <= $ h - 1 ; $ j ++ ) { if ( $ arr [ $ j ] <= $ x ) { $ i ++ ; swap ( $ arr [ $ i ] , $ arr [ $ j ] ) ; } } swap ( $ arr [ $ i + 1 ] , $ arr [ $ h ] ) ; return ( $ i + 1 ) ; } function quickSort ( & $ A , $ l , $ h ) { if ( $ l < $ h ) { $ p = partition ( $ A , $ l , $ h ) ; quickSort ( $ A , $ l , $ p - 1 ) ; quickSort ( $ A , $ p + 1 , $ h ) ; } } $ n = 5 ; $ arr = array ( 4 , 2 , 6 , 9 , 2 ) ; quickSort ( $ arr , 0 , $ n - 1 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ arr [ $ i ] . \" ▁ \" ; } ? >"}
{"text": "SENARAI ITERATIVE SENDIRI | Fungsi utiliti untuk menukar dua elemen; Fungsi ini sama dalam kedua -dua berulang dan rekursif; A [] -> array untuk disusun, l -> indeks permulaan, h -> indeks akhir; Buat timbunan tambahan; memulakan bahagian atas timbunan; tolak nilai awal L dan H ke timbunan; Terus muncul dari timbunan sementara tidak kosong; Pop H dan L; Tetapkan elemen pivot pada kedudukan yang betul dalam array yang disusun; Sekiranya terdapat unsur -unsur di sebelah kiri pivot, maka tekan sebelah kiri untuk disusun; Sekiranya terdapat unsur -unsur di sebelah kanan pivot, maka tekan sebelah kanan untuk disusun; Fungsi utiliti untuk mencetak kandungan ARR; Kod pemacu; Fungsi panggilan", "code": "< ? php function swap ( & $ a , & $ b ) { $ t = $ a ; $ a = $ b ; $ b = $ t ; } function partition ( & $ arr , $ l , $ h ) { $ x = $ arr [ $ h ] ; $ i = ( $ l - 1 ) ; for ( $ j = $ l ; $ j <= $ h - 1 ; $ j ++ ) { if ( $ arr [ $ j ] <= $ x ) { $ i ++ ; swap ( $ arr [ $ i ] , $ arr [ $ j ] ) ; } } swap ( $ arr [ $ i + 1 ] , $ arr [ $ h ] ) ; return ( $ i + 1 ) ; } function quickSortIterative ( & $ arr , $ l , $ h ) { $ stack = array_fill ( 0 , $ h - $ l + 1 , 0 ) ; $ top = -1 ; $ stack [ ++ $ top ] = $ l ; $ stack [ ++ $ top ] = $ h ; while ( $ top >= 0 ) { $ h = $ stack [ $ top -- ] ; $ l = $ stack [ $ top -- ] ; $ p = partition ( $ arr , $ l , $ h ) ; if ( $ p - 1 > $ l ) { $ stack [ ++ $ top ] = $ l ; $ stack [ ++ $ top ] = $ p - 1 ; } if ( $ p + 1 < $ h ) { $ stack [ ++ $ top ] = $ p + 1 ; $ stack [ ++ $ top ] = $ h ; } } } function printArr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) echo $ arr [ $ i ] . \" ▁ \" ; } $ arr = array ( 4 , 3 , 5 , 2 , 1 , 3 , 2 , 3 ) ; $ n = count ( $ arr ) ; quickSortIterative ( $ arr , 0 , $ n - 1 ) ; printArr ( $ arr , $ n ) ; ? >"}
{"text": "Cari dalam array yang hampir disusun | Fungsi berasaskan carian binari rekursif. Ia mengembalikan indeks x dalam array yang diberikan [l. . r] hadir, jika tidak - 1; Jika elemen hadir di salah satu kedudukan tengah 3; Jika elemen lebih kecil daripada pertengahan, maka ia hanya boleh hadir di subarray kiri; Lain elemen hanya boleh hadir di subarray kanan; Kami sampai di sini apabila elemen tidak hadir dalam pelbagai; Kod pemacu", "code": "< ? php function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = $ l + ( $ r - $ l ) / 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; if ( $ mid > $ l && $ arr [ $ mid - 1 ] == $ x ) return ( $ mid - 1 ) ; if ( $ mid < $ r && $ arr [ $ mid + 1 ] == $ x ) return ( $ mid + 1 ) ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 2 , $ x ) ; return binarySearch ( $ arr , $ mid + 2 , $ r , $ x ) ; } return -1 ; } $ arr = array ( 3 , 2 , 10 , 4 , 40 ) ; $ n = sizeof ( $ arr ) ; $ x = 4 ; $ result = binarySearch ( $ arr , 0 , $ n - 1 , $ x ) ; if ( $ result == -1 ) echo ( \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ) ; else echo ( \" Element ▁ is ▁ present ▁ at ▁ index ▁ $ result \" ) ; ? >"}
{"text": "Cari pasangan terdekat dari dua tatasusunan yang disusun | AR1 [0 .. M - 1] dan AR2 [0 .. N - 1] adalah dua susunan yang disusun dan X diberi nombor. Fungsi ini mencetak pasangan dari kedua -dua tatasusunan supaya jumlah pasangan itu paling dekat dengan x. ; Inisialisasi perbezaan antara jumlah pasangan dan x. ; RES_L dan RES_R adalah indeks hasil dari AR1 [] dan AR2 [] masing -masing; Bermula dari sebelah kiri AR1 [] dan sebelah kanan AR2 []; Jika pasangan ini lebih dekat dengan x daripada yang paling dekat, maka kemas kini res_l, res_r dan diff; Jika jumlah pasangan ini lebih daripada x, bergerak ke sisi yang lebih kecil; bergerak ke sisi yang lebih besar; Cetak hasilnya; Kod pemacu", "code": "< ? php function printClosest ( $ ar1 , $ ar2 , $ m , $ n , $ x ) { $ diff = PHP_INT_MAX ; $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l < $ m and $ r >= 0 ) { if ( abs ( $ ar1 [ $ l ] + $ ar2 [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ ar1 [ $ l ] + $ ar2 [ $ r ] - $ x ) ; } if ( $ ar1 [ $ l ] + $ ar2 [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo \" The ▁ closest ▁ pair ▁ is ▁ [ \" , $ ar1 [ $ res_l ] , \" , ▁ \" , $ ar2 [ $ res_r ] , \" ] ▁ STRNEWLINE \" ; } $ ar1 = array ( 1 , 4 , 5 , 7 ) ; $ ar2 = array ( 10 , 20 , 30 , 40 ) ; $ m = count ( $ ar1 ) ; $ n = count ( $ ar2 ) ; $ x = 38 ; printClosest ( $ ar1 , $ ar2 , $ m , $ n , $ x ) ; ? >"}
{"text": "Memandangkan array yang disusun dan nombor X, cari pasangan dalam array yang jumlahnya paling dekat dengan x | Mencetak pasangan dengan jumlah yang paling dekat dengan x; Untuk menyimpan indeks pasangan hasil; Memulakan indeks kiri dan kanan dan perbezaan antara jumlah pasangan dan x; Walaupun terdapat unsur -unsur antara L dan R; Semak jika pasangan ini lebih dekat daripada pasangan terdekat setakat ini; Jika pasangan ini mempunyai lebih banyak jumlah, bergerak ke nilai yang lebih kecil. ; Bergerak ke nilai yang lebih besar; Kod pemacu", "code": "< ? php function printClosest ( $ arr , $ n , $ x ) { $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; $ diff = PHP_INT_MAX ; while ( $ r > $ l ) { if ( abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) ; } if ( $ arr [ $ l ] + $ arr [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo \" ▁ The ▁ closest ▁ pair ▁ is ▁ \" , $ arr [ $ res_l ] , \" ▁ and ▁ \" , $ arr [ $ res_r ] ; } $ arr = array ( 10 , 22 , 28 , 29 , 30 , 40 ) ; $ x = 54 ; $ n = count ( $ arr ) ; printClosest ( $ arr , $ n , $ x ) ; ? >"}
{"text": "Kira 1 dalam array binari yang disusun | Mengembalikan tuduhan 1 dalam arr [rendah..high]. Arahan diandaikan disusun mengikut urutan yang tidak meningkat; Dapatkan indeks tengah; Semak sama ada elemen di Indeks Tengah adalah terakhir 1; Jika elemen tidak terakhir 1, berulang untuk sebelah kanan; lain berulang untuk sebelah kiri; Kod pemacu", "code": "< ? php function countOnes ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = $ low + ( $ high - $ low ) / 2 ; if ( ( $ mid == $ high or $ arr [ $ mid + 1 ] == 0 ) and ( $ arr [ $ mid ] == 1 ) ) return $ mid + 1 ; if ( $ arr [ $ mid ] == 1 ) return countOnes ( $ arr , ( $ mid + 1 ) , $ high ) ; return countOnes ( $ arr , $ low , ( $ mid - 1 ) ) ; } return 0 ; } $ arr = array ( 1 , 1 , 1 , 1 , 0 , 0 , 0 ) ; $ n = count ( $ arr ) ; echo \" Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ array ▁ is ▁ \" , countOnes ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text": "Swap bersebelahan minimum untuk bergerak maksimum dan minimum ke sudut | Fungsi yang mengembalikan swap minimum; Indeks unsur paling kiri terbesar; Indeks elemen paling kecil yang paling kecil; Kod pemacu", "code": "< ? php function solve ( $ a , $ n ) { $ maxx = -1 ; $ minn = $ a [ 0 ] ; $ l = 0 ; $ r = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ maxx ) { $ maxx = $ a [ $ i ] ; $ l = $ i ; } if ( $ a [ $ i ] <= $ minn ) { $ minn = $ a [ $ i ] ; $ r = $ i ; } } if ( $ r < $ l ) echo $ l + ( $ n - $ r - 2 ) ; else echo $ l + ( $ n - $ r - 1 ) ; } $ a = array ( 5 , 6 , 1 , 3 ) ; $ n = count ( $ a ) ; solve ( $ a , $ n ) ; ? >"}
{"text": "Masalah Pemilihan Aktiviti | Algo Greedy | Mencetak set maksimum aktiviti yang boleh dilakukan oleh satu orang, satu demi satu. n -> Jumlah bilangan aktiviti s [] -> array yang mengandungi masa mula semua aktiviti f [] -> array yang mengandungi masa selesai semua aktiviti; Aktiviti pertama sentiasa dipilih; Pertimbangkan sisa aktiviti; Jika aktiviti ini telah memulakan masa lebih besar daripada atau sama dengan masa penamat aktiviti yang dipilih sebelum ini, kemudian pilihnya; Kod pemacu", "code": "< ? php function printMaxActivities ( $ s , $ f , $ n ) { echo \" Following ▁ activities ▁ are ▁ selected ▁ \" . \" STRNEWLINE \" ; $ i = 0 ; echo $ i . \" \" ; for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ s [ $ j ] >= $ f [ $ i ] ) { echo $ j . \" \" ; $ i = $ j ; } } } $ s = array ( 1 , 3 , 0 , 5 , 8 , 5 ) ; $ f = array ( 2 , 4 , 6 , 7 , 9 , 9 ) ; $ n = sizeof ( $ s ) ; printMaxActivities ( $ s , $ f , $ n ) ; ? >"}
{"text": "Susunan Umum Terpanjang | DP | Mengembalikan panjang LCS untuk x [0 .. m - 1], y [0 .. n - 1]; Kod pemacu", "code": "< ? php function lcs ( $ X , $ Y , $ m , $ n ) { if ( $ m == 0 $ n == 0 ) return 0 ; else if ( $ X [ $ m - 1 ] == $ Y [ $ n - 1 ] ) return 1 + lcs ( $ X , $ Y , $ m - 1 , $ n - 1 ) ; else return max ( lcs ( $ X , $ Y , $ m , $ n - 1 ) , lcs ( $ X , $ Y , $ m - 1 , $ n ) ) ; } $ X = \" AGGTAB \" ; $ Y = \" GXTXAYB \" ; echo \" Length ▁ of ▁ LCS ▁ is ▁ \" ; echo lcs ( $ X , $ Y , strlen ( $ X ) , strlen ( $ Y ) ) ; ? >"}
{"text": "Susunan Umum Terpanjang | DP | Pengaturcaraan dinamik C # pelaksanaan masalah LCS; Cari panjang rentetan; Langkah -langkah berikut membina l [m + 1] [n + 1] dalam fesyen bawah. Nota: l [i] [j] mengandungi panjang LCs x [0 .. i - 1] dan y [0. .. J - 1]; L [m] [n] mengandungi panjang LCs x [0. .. n - 1] & y [0. .. m - 1]; Kod pemacu", "code": "< ? php function lcs ( $ X , $ Y ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ i ] [ $ j ] = $ L [ $ i - 1 ] [ $ j - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] = max ( $ L [ $ i - 1 ] [ $ j ] , $ L [ $ i ] [ $ j - 1 ] ) ; } } return $ L [ $ m ] [ $ n ] ; } $ X = \" AGGTAB \" ; $ Y = \" GXTXAYB \" ; echo \" Length ▁ of ▁ LCS ▁ is ▁ \" ; echo lcs ( $ X , $ Y ) ; ? >"}
{"text": "Laluan Kos Min | DP | Pelaksanaan rekursif naif MCP (laluan kos minimum); Fungsi utiliti yang mengembalikan minimum 3 bilangan bulat; Mengembalikan kos laluan kos minimum dari (0, 0) hingga (m, n) dalam tikar [r] [c]; Kod pemacu", "code": "< ? php $ R = 3 ; $ C = 3 ; function min1 ( $ x , $ y , $ z ) { if ( $ x < $ y ) return ( $ x < $ z ) ? $ x : $ z ; else return ( $ y < $ z ) ? $ y : $ z ; } function minCost ( $ cost , $ m , $ n ) { global $ R ; global $ C ; if ( $ n < 0 $ m < 0 ) return PHP_INT_MAX ; else if ( $ m == 0 && $ n == 0 ) return $ cost [ $ m ] [ $ n ] ; else return $ cost [ $ m ] [ $ n ] + min1 ( minCost ( $ cost , $ m - 1 , $ n - 1 ) , minCost ( $ cost , $ m - 1 , $ n ) , minCost ( $ cost , $ m , $ n - 1 ) ) ; } $ cost = array ( array ( 1 , 2 , 3 ) , array ( 4 , 8 , 2 ) , array ( 1 , 5 , 3 ) ) ; echo minCost ( $ cost , 2 , 2 ) ; ? >"}
{"text": "Laluan Kos Min | DP | Pelaksanaan DP masalah MCP; Daripada baris berikut, kita boleh menggunakan Int Tc [M + 1] [n + 1] atau secara dinamik memperuntukkan memori untuk menjimatkan ruang. Baris berikut digunakan untuk memastikan program ini mudah dan menjadikannya berfungsi pada semua penyusun. ; Memulakan lajur pertama jumlah kos (TC); Memulakan baris pertama tc array; Membina selebihnya dari array TC; mengembalikan minimum 3 bilangan bulat; Kod pemacu", "code": "< ? php $ R = 3 ; $ C = 3 ; function minCost ( $ cost , $ m , $ n ) { global $ R ; global $ C ; $ tc ; for ( $ i = 0 ; $ i <= $ R ; $ i ++ ) for ( $ j = 0 ; $ j <= $ C ; $ j ++ ) $ tc [ $ i ] [ $ j ] = 0 ; $ tc [ 0 ] [ 0 ] = $ cost [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) $ tc [ $ i ] [ 0 ] = $ tc [ $ i - 1 ] [ 0 ] + $ cost [ $ i ] [ 0 ] ; for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) $ tc [ 0 ] [ $ j ] = $ tc [ 0 ] [ $ j - 1 ] + $ cost [ 0 ] [ $ j ] ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) $ tc [ $ i ] [ $ j ] = min ( $ tc [ $ i - 1 ] [ $ j - 1 ] , $ tc [ $ i - 1 ] [ $ j ] , $ tc [ $ i ] [ $ j - 1 ] ) + $ cost [ $ i ] [ $ j ] ; return $ tc [ $ m ] [ $ n ] ; } $ cost = array ( array ( 1 , 2 , 3 ) , array ( 4 , 8 , 2 ) , array ( 1 , 5 , 3 ) ) ; echo minCost ( $ cost , 2 , 2 ) ; ? >"}
{"text": "0 | Mengembalikan nilai maksimum yang boleh dimasukkan ke dalam kapasiti kapasiti w; Kes asas; Jika berat item nth lebih daripada kapasiti knapsack W, maka item ini tidak dapat dimasukkan ke dalam penyelesaian optimum; Kembalikan maksimum dua kes: (1) item Nth termasuk (2) tidak termasuk; Kod pemacu", "code": "< ? php function knapSack ( $ W , $ wt , $ val , $ n ) { if ( $ n == 0 $ W == 0 ) return 0 ; if ( $ wt [ $ n - 1 ] > $ W ) return knapSack ( $ W , $ wt , $ val , $ n - 1 ) ; else return max ( $ val [ $ n - 1 ] + knapSack ( $ W - $ wt [ $ n - 1 ] , $ wt , $ val , $ n - 1 ) , knapSack ( $ W , $ wt , $ val , $ n - 1 ) ) ; } $ val = array ( 60 , 100 , 120 ) ; $ wt = array ( 10 , 20 , 30 ) ; $ W = 50 ; $ n = count ( $ val ) ; echo knapSack ( $ W , $ wt , $ val , $ n ) ; ? >"}
{"text": "0 | Mengembalikan nilai maksimum yang boleh dimasukkan ke dalam kapasiti kapasiti w; Membina jadual k [] [] dengan cara bawah; Kod pemacu", "code": "< ? php function knapSack ( $ W , $ wt , $ val , $ n ) { $ K = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ w = 0 ; $ w <= $ W ; $ w ++ ) { if ( $ i == 0 $ w == 0 ) $ K [ $ i ] [ $ w ] = 0 ; else if ( $ wt [ $ i - 1 ] <= $ w ) $ K [ $ i ] [ $ w ] = max ( $ val [ $ i - 1 ] + $ K [ $ i - 1 ] [ $ w - $ wt [ $ i - 1 ] ] , $ K [ $ i - 1 ] [ $ w ] ) ; else $ K [ $ i ] [ $ w ] = $ K [ $ i - 1 ] [ $ w ] ; } } return $ K [ $ n ] [ $ W ] ; } $ val = array ( 60 , 100 , 120 ) ; $ wt = array ( 10 , 20 , 30 ) ; $ W = 50 ; $ n = count ( $ val ) ; echo knapSack ( $ W , $ wt , $ val , $ n ) ; ? >"}
{"text": "Teka -teki menjatuhkan telur | DP | Berfungsi untuk mendapatkan bilangan minimum ujian yang diperlukan dalam kes terburuk dengan telur N dan l lantai; Jadual 2D di mana kemasukan urgfloor [i] [j] akan mewakili bilangan minimum ujian yang diperlukan untuk saya telur dan lantai j. ; Kami memerlukan satu percubaan untuk satu tingkat dan0 ujian untuk 0 tingkat; Kami sentiasa memerlukan ujian untuk satu lantai telur dan J. ; Isi sisa penyertaan dalam jadual menggunakan harta substruktur yang optimum; Eggfloor [n] [k] memegang hasilnya; Kod pemacu", "code": "< ? php function eggDrop ( $ n , $ k ) { $ eggFloor = array ( array ( ) ) ; ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ eggFloor [ $ i ] [ 1 ] = 1 ; $ eggFloor [ $ i ] [ 0 ] = 0 ; } for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) $ eggFloor [ 1 ] [ $ j ] = $ j ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 2 ; $ j <= $ k ; $ j ++ ) { $ eggFloor [ $ i ] [ $ j ] = 999999 ; for ( $ x = 1 ; $ x <= $ j ; $ x ++ ) { $ res = 1 + max ( $ eggFloor [ $ i - 1 ] [ $ x - 1 ] , $ eggFloor [ $ i ] [ $ j - $ x ] ) ; if ( $ res < $ eggFloor [ $ i ] [ $ j ] ) $ eggFloor [ $ i ] [ $ j ] = $ res ; } } } return $ eggFloor [ $ n ] [ $ k ] ; } $ n = 2 ; $ k = 36 ; echo \" Minimum ▁ number ▁ of ▁ trials ▁ in ▁ worst ▁ case ▁ with ▁ \" . $ n . \" ▁ eggs ▁ and ▁ \" . $ k . \" ▁ floors ▁ is ▁ \" . eggDrop ( $ n , $ k ) ; ? >"}
{"text": "Palindromik Palindromik Terpanjang | DP | Mengembalikan panjang Palindromic yang paling lama di SEQ; Kes asas 1: Jika hanya ada 1 aksara; Kes asas 2: Jika hanya terdapat 2 aksara dan kedua -duanya sama; Jika watak pertama dan terakhir sepadan; Jika watak pertama dan terakhir tidak sepadan; Kod pemacu", "code": "< ? php function lps ( $ seq , $ i , $ j ) { if ( $ i == $ j ) return 1 ; if ( $ seq [ $ i ] == $ seq [ $ j ] && $ i + 1 == $ j ) return 2 ; if ( $ seq [ $ i ] == $ seq [ $ j ] ) return lps ( $ seq , $ i + 1 , $ j - 1 ) + 2 ; return max ( lps ( $ seq , $ i , $ j - 1 ) , lps ( $ seq , $ i + 1 , $ j ) ) ; } $ seq = \" GEEKSFORGEEKS \" ; $ n = strlen ( $ seq ) ; echo \" The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ \" . lps ( $ seq , 0 , $ n - 1 ) ; ? >"}
{"text": "Palindromik Palindromik Terpanjang | DP | Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Mengembalikan panjang Palindromic yang paling lama di SEQ; Buat jadual untuk menyimpan hasil subproblem; Rentetan panjang 1 adalah palindrome Lentgh 1; Bina meja. Perhatikan bahawa nilai -nilai pepenjuru yang lebih rendah jadual tidak berguna dan tidak diisi dalam proses. Nilai -nilai diisi dengan cara yang serupa dengan penyelesaian DP pendaraban rantaian matriks (Seewww. HTTPS: CL adalah panjang substring; Kod pemacu", "code": "< ? php function max ( $ x , $ y ) { return ( $ x > $ y ) ? $ x : $ y ; } function lps ( $ str ) { $ n = strlen ( $ str ) ; $ i ; $ j ; $ cl ; $ L [ ] [ ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ L [ $ i ] [ $ i ] = 1 ; for ( $ cl = 2 ; $ cl <= $ n ; $ cl ++ ) { for ( $ i = 0 ; $ i < $ n - $ cl + 1 ; $ i ++ ) { $ j = $ i + $ cl - 1 ; if ( $ str [ $ i ] == $ str [ $ j ] && $ cl == 2 ) $ L [ $ i ] [ $ j ] = 2 ; else if ( $ str [ $ i ] == $ str [ $ j ] ) $ L [ $ i ] [ $ j ] = $ L [ $ i + 1 ] [ $ j - 1 ] + 2 ; else $ L [ $ i ] [ $ j ] = max ( $ L [ $ i ] [ $ j - 1 ] , $ L [ $ i + 1 ] [ $ j ] ) ; } } return $ L [ 0 ] [ $ n - 1 ] ; } $ seq = ' EEKS FOR GEEKS ' ; $ n = strlen ( $ seq ) ; echo \" The ▁ length ▁ of ▁ the ▁ \" . \" LPS ▁ is ▁ \" , lps ( $ seq ) ; ? >"}
{"text": "Susunan Bitonik Terpanjang | DP | lbs () Mengembalikan panjang seterusnya bitonic berikutnya dalam arr [] saiz n. Fungsi ini terutamanya mewujudkan dua array sementara LIS [] dan LDS [] dan mengembalikan maksimum lis [i] + lds [i] - 1. Lis [i] ==> Paulat yang paling lama meningkat seterusnya dengan ARR [i] lds [i] ==> paling lama penurunan berikutnya bermula dengan ARR [i]; Memperuntukkan memori untuk LIS [] dan memulakan nilai LIS sebagai 1 untuk semua indeks; Kirakan nilai lis dari kiri ke kanan; Memperuntukkan memori untuk LDS dan memulakan nilai LDS untuk semua indeks; Mengira nilai LDS dari kanan ke kiri; Kembalikan nilai maksimum LIS [i] + lds [i] - 1; Kod pemacu", "code": "< ? php function lbs ( & $ arr , $ n ) { $ lis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ lds = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lds [ $ i ] < $ lds [ $ j ] + 1 ) $ lds [ $ i ] = $ lds [ $ j ] + 1 ; $ max = $ lis [ 0 ] + $ lds [ 0 ] - 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ lis [ $ i ] + $ lds [ $ i ] - 1 > $ max ) $ max = $ lis [ $ i ] + $ lds [ $ i ] - 1 ; return $ max ; } $ arr = array ( 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 ) ; $ n = sizeof ( $ arr ) ; echo \" Length ▁ of ▁ LBS ▁ is ▁ \" . lbs ( $ arr , $ n ) ; ? >"}
{"text": "Nombor Ugly | Fungsi ini membahagikan kuasa yang paling besar dari B; Berfungsi untuk memeriksa sama ada nombor adalah hodoh atau tidak; Berfungsi untuk mendapatkan nombor hodoh nth; kiraan nombor hodoh; Semak semua bilangan bulat sehingga hodoh menjadi n; Kod pemacu", "code": "< ? php function maxDivide ( $ a , $ b ) { while ( $ a % $ b == 0 ) $ a = $ a / $ b ; return $ a ; } function isUgly ( $ no ) { $ no = maxDivide ( $ no , 2 ) ; $ no = maxDivide ( $ no , 3 ) ; $ no = maxDivide ( $ no , 5 ) ; return ( $ no == 1 ) ? 1 : 0 ; } function getNthUglyNo ( $ n ) { $ i = 1 ; $ count = 1 ; while ( $ n > $ count ) { $ i ++ ; if ( isUgly ( $ i ) ) $ count ++ ; } return $ i ; } $ no = getNthUglyNo ( 150 ) ; echo \"150th ▁ ugly ▁ no . ▁ is ▁ \" . $ no ; ? >"}
{"text": "Kira nombor N digit yang jumlah digit sama dengan jumlah yang diberikan | Fungsi rekursif untuk mengira nombor digit 'n' dengan jumlah digit sebagai 'jumlah'. Fungsi ini menganggap yang memimpin 0 juga sebagai digit, itulah sebabnya tidak dipanggil secara langsung; Kes asas; Memulakan jawapan; Melintasi setiap digit dan nombor kiraan yang bermula dengan menggunakan rekursi; Ini terutamanya pembungkus ke atas Countrec. Ia secara eksplisit mengendalikan digit terkemuka dan memanggil countrec () untuk baki digit. ; Memulakan jawapan akhir; Melintasi setiap digit dari 1 hingga 9 dan mengira nombor bermula dengannya; Kod pemacu", "code": "< ? php function countRec ( $ n , $ sum ) { if ( $ n == 0 ) return $ sum == 0 ; if ( $ sum == 0 ) return 1 ; $ ans = 0 ; for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) if ( $ sum - $ i >= 0 ) $ ans += countRec ( $ n - 1 , $ sum - $ i ) ; return $ ans ; } function finalCount ( $ n , $ sum ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= 9 ; $ i ++ ) if ( $ sum - $ i >= 0 ) $ ans += countRec ( $ n - 1 , $ sum - $ i ) ; return $ ans ; } $ n = 2 ; $ sum = 5 ; echo finalCount ( $ n , $ sum ) ; ? >"}
{"text": "Kira nombor N digit yang jumlah digit sama dengan jumlah yang diberikan | Jadual carian yang digunakan untuk memoisasi; Memoization berasaskan pelaksanaan fungsi rekursif; Kes asas; Jika subproblem ini sudah dinilai, kembalikan nilai yang dinilai; Memulakan jawapan; Melintasi setiap digit dan mengira nombor rekursif bermula dengannya; Ini terutamanya pembungkus ke atas Countrec. Ia secara eksplisit mengendalikan digit terkemuka dan memanggil countrec () untuk baki n. ; Memulakan jawapan akhir; Melintasi setiap digit dari 1 hingga 9 dan mengira nombor bermula dengannya; Kod pemacu", "code": "< ? php $ lookup = array_fill ( 0 , 101 , array_fill ( 0 , 501 , -1 ) ) ; function countRec ( $ n , $ sum ) { global $ lookup ; if ( $ n == 0 ) return $ sum == 0 ; if ( $ lookup [ $ n ] [ $ sum ] != -1 ) return $ lookup [ $ n ] [ $ sum ] ; $ ans = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) if ( $ sum - $ i >= 0 ) $ ans += countRec ( $ n - 1 , $ sum - $ i ) ; return $ lookup [ $ n ] [ $ sum ] = $ ans ; } function finalCount ( $ n , $ sum ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= 9 ; $ i ++ ) if ( $ sum - $ i >= 0 ) $ ans += countRec ( $ n - 1 , $ sum - $ i ) ; return $ ans ; } $ n = 3 ; $ sum = 5 ; echo finalCount ( $ n , $ sum ) ; ? >"}
{"text": "Kira nombor N digit yang jumlah digit sama dengan jumlah yang diberikan | Program PHP untuk mengira nombor digit N yang jumlah digit sama dengan jumlah yang diberikan; Dalam kes n = 2 permulaan adalah 10 dan akhir adalah (100 - 1) = 99; Kod pemacu", "code": "< ? php function findCount ( $ n , $ sum ) { $ start = ( int ) pow ( 10 , $ n - 1 ) ; $ end = ( int ) pow ( 10 , $ n ) - 1 ; $ count = 0 ; $ i = $ start ; while ( $ i < $ end ) { $ cur = 0 ; $ temp = $ i ; while ( $ temp != 0 ) { $ cur += $ temp % 10 ; $ temp = ( int ) $ temp / 10 ; } if ( $ cur == $ sum ) { $ count ++ ; $ i += 9 ; } else $ i ++ ; } echo ( $ count ) ; } $ n = 3 ; $ sum = 5 ; findCount ( $ n , $ sum ) ; ? >"}
{"text": "Jumlah Bilangan Bukan | Program PHP untuk mengira nombor penurunan bukan dengan digit N; dp [i] [j] mengandungi jumlah kiraan nombor yang tidak berkurangan yang berakhir dengan digit I dan panjang j; Isi jadual untuk tidak menurun bilangan panjang 1 kes asas 0, 1, 2, 3, 4, 5, 6, 7, 8, 9; Isi jadual dengan cara bawah; Mengira jumlah bilangan yang tidak berkurangan panjang 'len'; jumlah semua bilangan panjang len - 1 di mana digit terakhir x adalah <= 'digit'; Terdapat jumlah yang tidak dapat disangkal panjang panjang n wiint menjadi dp [0] [n] + dp [1] [n]. . + dp [9] [n]; Program Pemandu", "code": "< ? php function countNonDecreasing ( $ n ) { $ dp = array_fill ( 0 , 10 , array_fill ( 0 , $ n + 1 , NULL ) ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ dp [ $ i ] [ 1 ] = 1 ; for ( $ digit = 0 ; $ digit <= 9 ; $ digit ++ ) { for ( $ len = 2 ; $ len <= $ n ; $ len ++ ) { for ( $ x = 0 ; $ x <= $ digit ; $ x ++ ) $ dp [ $ digit ] [ $ len ] += $ dp [ $ x ] [ $ len - 1 ] ; } } $ count = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ count += $ dp [ $ i ] [ $ n ] ; return $ count ; } $ n = 3 ; echo countNonDecreasing ( $ n ) ; return 0 ; ? >"}
{"text": "Jumlah Bilangan Bukan | Program PHP untuk mengira nonnner yang tidak menurun dengan digit N; Kirakan nilai n * (n + 1) / 2 * (n + 2) / 3 * ... .... * (N + n - 1) / n; Kod pemacu", "code": "< ? php function countNonDecreasing ( $ n ) { $ N = 10 ; $ count = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ count *= ( $ N + $ i - 1 ) ; $ count /= $ i ; } return $ count ; } $ n = 3 ; echo countNonDecreasing ( $ n ) ; ? >"}
{"text": "Bilangan minimum kuadrat yang jumlahnya sama dengan nombor n | Mengembalikan kiraan kotak minimum yang jumlahnya kepada n; kes asas; GetMinSquares selebihnya dari jadual menggunakan formula rekursif maksimum kotak yang diperlukan ialah N (1 * 1 + 1 * 1 +.); Pergi melalui semua nombor yang lebih kecil untuk mencari minimum; Kod pemacu", "code": "< ? php function getMinSquares ( $ n ) { if ( $ n <= 3 ) return $ n ; $ res = $ n ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) { $ temp = $ x * $ x ; if ( $ temp > $ n ) break ; else $ res = min ( $ res , 1 + getMinSquares ( $ n - $ temp ) ) ; } return $ res ; } echo getMinSquares ( 6 ) ; ? >"}
{"text": "Bilangan minimum kuadrat yang jumlahnya sama dengan nombor n | Mengembalikan kiraan kotak minimum yang jumlahnya kepada n; Buat jadual pengaturcaraan dinamik untuk menyimpan SQ; jadual getMinsquares untuk penyertaan kes asas; GetMinsquares selebihnya menggunakan formula rekursif; Nilai maksimum saya kerana saya sentiasa boleh diwakili sebagai 1 * 1 + 1 * 1 + ...; Pergi melalui semua nombor yang lebih kecil untuk mencari minimum; Hasil kedai dan dp percuma []; Kod pemacu", "code": "< ? php function getMinSquares ( $ n ) { $ dp ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; $ dp [ 2 ] = 2 ; $ dp [ 3 ] = 3 ; for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = $ i ; for ( $ x = 1 ; $ x <= ceil ( sqrt ( $ i ) ) ; $ x ++ ) { $ temp = $ x * $ x ; if ( $ temp > $ i ) break ; else $ dp [ $ i ] = min ( $ dp [ $ i ] , ( 1 + $ dp [ $ i - $ temp ] ) ) ; } } $ res = $ dp [ $ n ] ; return $ res ; } echo getMinSquares ( 6 ) ; ? >"}
{"text": "Cari bilangan minimum syiling yang membuat nilai yang diberikan | m adalah saiz array duit syiling (bilangan duit syiling yang berbeza); Kes asas; Memulakan hasil; Cuba setiap duit syiling yang mempunyai nilai yang lebih kecil daripada V; Semak int_max untuk mengelakkan limpahan dan lihat jika keputusan dapat dikurangkan; Kod pemacu", "code": "< ? php function minCoins ( $ coins , $ m , $ V ) { if ( $ V == 0 ) return 0 ; $ res = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ coins [ $ i ] <= $ V ) { $ sub_res = minCoins ( $ coins , $ m , $ V - $ coins [ $ i ] ) ; if ( $ sub_res != PHP_INT_MAX && $ sub_res + 1 < $ res ) $ res = $ sub_res + 1 ; } } return $ res ; } $ coins = array ( 9 , 6 , 5 , 1 ) ; $ m = sizeof ( $ coins ) ; $ V = 11 ; echo \" Minimum ▁ coins ▁ required ▁ is ▁ \" , minCoins ( $ coins , $ m , $ V ) ; ? >"}
{"text": "Cari bilangan minimum syiling yang membuat nilai yang diberikan | m adalah saiz array duit syiling (bilangan duit syiling yang berbeza); Jadual [i] akan menyimpan bilangan minimum syiling yang diperlukan untuk nilai saya. Jadi Jadual [V] akan hasil; Kes asas (jika diberi nilai V ialah 0); Memulakan semua nilai jadual sebagai tak terhingga; Kirakan syiling minimum yang diperlukan untuk semua nilai dari 1 hingga V; Pergi melalui semua duit syiling yang lebih kecil daripada saya; Kod pemacu", "code": "< ? php function minCoins ( $ coins , $ m , $ V ) { $ table [ $ V + 1 ] = array ( ) ; $ table [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ V ; $ i ++ ) $ table [ $ i ] = PHP_INT_MAX ; for ( $ i = 1 ; $ i <= $ V ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ coins [ $ j ] <= $ i ) { $ sub_res = $ table [ $ i - $ coins [ $ j ] ] ; if ( $ sub_res != PHP_INT_MAX && $ sub_res + 1 < $ table [ $ i ] ) $ table [ $ i ] = $ sub_res + 1 ; } } if ( $ table [ $ V ] == PHP_INT_MAX ) return -1 ; return $ table [ $ V ] ; } $ coins = array ( 9 , 6 , 5 , 1 ) ; $ m = sizeof ( $ coins ) ; $ V = 11 ; echo \" Minimum ▁ coins ▁ required ▁ is ▁ \" , minCoins ( $ coins , $ m , $ V ) ; ? >"}
{"text": "SUPERSEQUENCE COMMON terpendek | Program php rekursif naif untuk mencari panjang supersequence terpendek; Kod pemacu", "code": "< ? php function superSeq ( $ X , $ Y , $ m , $ n ) { if ( ! $ m ) return $ n ; if ( ! $ n ) return $ m ; if ( $ X [ $ m - 1 ] == $ Y [ $ n - 1 ] ) return 1 + superSeq ( $ X , $ Y , $ m - 1 , $ n - 1 ) ; return 1 + min ( superSeq ( $ X , $ Y , $ m - 1 , $ n ) , superSeq ( $ X , $ Y , $ m , $ n - 1 ) ) ; } $ X = \" AGGTAB \" ; $ Y = \" GXTXAYB \" ; echo \" Length ▁ of ▁ the ▁ shortest ▁ supersequence ▁ is ▁ \" , superSeq ( $ X , $ Y , strlen ( $ X ) , strlen ( $ Y ) ) ; ? >"}
{"text": "SUPERSEQUENCE COMMON terpendek | Mengembalikan panjang supersequence terpendek X dan Y; Mengisi jadual dengan cara bawah; Di bawah langkah -langkah diikuti di atas berulang; Kod pemacu", "code": "< ? php function superSeq ( $ X , $ Y , $ m , $ n ) { $ dp = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , 0 ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( ! $ i ) $ dp [ $ i ] [ $ j ] = $ j ; else if ( ! $ j ) $ dp [ $ i ] [ $ j ] = $ i ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = 1 + min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) ; } } return $ dp [ $ m ] [ $ n ] ; } $ X = \" AGGTAB \" ; $ Y = \" GXTXAYB \" ; echo \" Length ▁ of ▁ the ▁ shortest ▁ supersequence ▁ is ▁ \" . superSeq ( $ X , $ Y , strlen ( $ X ) , strlen ( $ Y ) ) ; ? >"}
{"text": "Kirakan jumlah digit dalam semua nombor dari 1 hingga n | Mengembalikan jumlah semua digit dalam nombor dari 1 hingga n; memulakan hasil; Satu demi satu mengira jumlah digit dalam setiap nombor dari 1 hingga n; Fungsi utiliti untuk mengira jumlah digit dalam nombor X yang diberikan; Program Pemandu", "code": "< ? php function sumOfDigitsFrom1ToN ( $ n ) { $ result = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) $ result += sumOfDigits ( $ x ) ; return $ result ; } function sumOfDigits ( $ x ) { $ sum = 0 ; while ( $ x != 0 ) { $ sum += $ x % 10 ; $ x = $ x / 10 ; } return $ sum ; } $ n = 328 ; echo \" Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ from \" . \" ▁ 1 ▁ to ▁ \" . $ n . \" ▁ is ▁ \" . sumOfDigitsFrom1ToN ( $ n ) ; ? >"}
{"text": "Kirakan jumlah digit dalam semua nombor dari 1 hingga n | Berfungsi untuk jumlah komputer digit dalam nombor dari 1 hingga n. Komen Gunakan contoh 328 untuk menerangkan kod; Kes asas: jika n <10 kembali jumlah nombor natural pertama; D = Bilangan digit dikurangkan satu dalam n. Untuk 328, D ialah 2; pengkomputeran jumlah digit dari 1 hingga 10 ^ d - 1, d = 1 a [0] = 0; d = 2 a [1] = jumlah digit dari 1 hingga 9 = 45 d = 3 a [2] = jumlah digit dari 1 hingga 99 = a [1] * 10 + 45 * 10 ^ 1 = 900 d = 4 a [3] = jumlah digit dari 1 hingga 999 = a [2] * 10 + 45 * 10 ^ 2 = 13500; Pengkomputeran 10 ^ d; Digit yang paling penting (MSD) N, untuk 328, MSD adalah 3 yang boleh diperolehi menggunakan 328 /100; Penjelasan untuk istilah pertama dan kedua di bawah baris kod pertama dua istilah mengira jumlah digit dari 1 hingga 299 (jumlah digit dalam julat 1 - 99 yang disimpan dalam [d]) + (jumlah digit dalam julat 100 - 199, boleh dikira sebagai 1 * 100 + a [d] + 2) * 100 Penjelasan untuk Terma Ketiga dan Keempat Dalam baris di bawah kod Dua istilah terakhir mengira jumlah digit dalam 300 hingga 328. Istilah ketiga menambah 3 * 29 hingga jumlah sebagai digit 3 berlaku dalam semua nombor dari 300 hingga 328", "code": "< ? php function sumOfDigitsFrom1ToN ( $ n ) { if ( $ n < 10 ) return ( $ n * ( $ n + 1 ) / 2 ) ; $ d = ( int ) ( log10 ( $ n ) ) ; $ a [ $ d + 1 ] = array ( ) ; $ a [ 0 ] = 0 ; $ a [ 1 ] = 45 ; for ( $ i = 2 ; $ i <= $ d ; $ i ++ ) $ a [ $ i ] = $ a [ $ i - 1 ] * 10 + 45 * ( int ) ( ceil ( pow ( 10 , $ i - 1 ) ) ) ; $ p = ( int ) ( ceil ( pow ( 10 , $ d ) ) ) ; $ msd = ( int ) ( $ n / $ p ) ; return ( $ msd * $ a [ $ d ] + ( $ msd * ( int ) ( $ msd - 1 ) / 2 ) * $ p + $ msd * ( 1 + $ n % $ p ) + sumOfDigitsFrom1ToN ( $ n % $ p ) ) ; } $ n = 328 ; echo ( \" Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ \" ) , \" from ▁ 1 ▁ to ▁ \" , $ n , \" ▁ is ▁ \" , sumOfDigitsFrom1ToN ( $ n ) ; ? >"}
{"text": "Kira cara yang mungkin untuk membina bangunan | Mengembalikan kiraan cara yang mungkin untuk bahagian N; Kes asas; 2 untuk satu sisi dan 4 untuk dua sisi; Countb adalah cara dengan cara dengan bangunan pada akhir adalah menghitung cara dengan ruang pada akhir prev_countb dan prev_counts adalah nilai -nilai sebelumnya dari CountB dan Count masing -masing. Memulakan CountB dan Count untuk satu sisi; Gunakan formula rekursif di atas untuk mengira CountB dan Count menggunakan nilai sebelumnya; Hasil untuk satu sisi adalah jumlah cara yang berakhir dengan bangunan dan berakhir dengan ruang; Keputusan untuk 2 sisi adalah persegi hasil untuk satu sisi; Kod pemacu", "code": "< ? php function countWays ( $ N ) { if ( $ N == 1 ) return 4 ; $ countB = 1 ; $ countS = 1 ; $ prev_countB ; $ prev_countS ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { $ prev_countB = $ countB ; $ prev_countS = $ countS ; $ countS = $ prev_countB + $ prev_countS ; $ countB = $ prev_countS ; } $ result = $ countS + $ countB ; return ( $ result * $ result ) ; } $ N = 3 ; echo \" Count ▁ of ▁ ways ▁ for ▁ \" , $ N , \" ▁ sections ▁ is ▁ \" , countWays ( $ N ) ; ? >"}
{"text": "Mengira jumlah cara untuk mencapai skor yang diberikan dalam permainan | Mengembalikan bilangan cara untuk mencapai skor n; Jadual [i] akan menyimpan kiraan penyelesaian untuk nilai i. Memulakan semua nilai jadual sebagai 0; Kes asas (jika diberi nilai adalah 0); Satu demi satu mempertimbangkan diberikan 3 langkah dan mengemas kini nilai [] nilai selepas indeks lebih besar daripada atau sama dengan nilai langkah yang dipilih; Kod pemacu", "code": "< ? php function counts ( $ n ) { for ( $ j = 0 ; $ j < $ n + 1 ; $ j ++ ) $ table [ $ j ] = 0 ; $ table [ 0 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 3 ] ; for ( $ i = 5 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 5 ] ; for ( $ i = 10 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 10 ] ; return $ table [ $ n ] ; } $ n = 20 ; echo \" Count ▁ for ▁ \" ; echo ( $ n ) ; echo ( \" ▁ is ▁ \" ) ; echo counts ( $ n ) ; $ n = 13 ; echo ( \" STRNEWLINE \" ) ; echo \" Count ▁ for ▁ \" ; echo ( $ n ) ; echo ( \" ▁ is ▁ \" ) ; echo counts ( $ n ) ; ? >"}
{"text": "Algoritma naif untuk mencari corak | Program PHP untuk Algoritma Mencari Corak Naive; Gelung untuk meluncur pat [] satu demi satu; Untuk indeks semasa I, periksa perlawanan corak; Jika Pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]; Kod pemacu", "code": "< ? php function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) echo \" Pattern ▁ found ▁ at ▁ index ▁ \" , $ i . \" STRNEWLINE \" ; } } $ txt = \" AABAACAADAABAAABAA \" ; $ pat = \" AABA \" ; search ( $ pat , $ txt ) ; ? >"}
{"text": "Rabin | D ialah bilangan aksara dalam abjad input; Pat -> Corak Txt -> Teks Q -> Nombor Perdana; nilai hash; untuk nilai hash corak; Nilai H ialah \"pow (d, u, 1) % q\"; Kirakan nilai hash corak dan tetingkap pertama teks; Luncurkan corak ke atas teks satu demi satu; Semak nilai hash tetingkap semasa teks dan corak. Jika nilai hash sepadan maka hanya periksa aksara oleh satu; Semak watak satu demi satu; jika p == t dan pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]; Kirakan nilai hash untuk tetingkap teks seterusnya: Keluarkan digit terkemuka, tambah digit trailing; Kami mungkin mendapat nilai negatif T, menukarnya kepada positif; Kod pemacu; Nombor perdana; Panggilan fungsi", "code": "< ? php $ d = 256 ; function search ( $ pat , $ txt , $ q ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i ; $ j ; $ p = 0 ; $ t = 0 ; $ h = 1 ; $ d = 1 ; for ( $ i = 0 ; $ i < $ M - 1 ; $ i ++ ) $ h = ( $ h * $ d ) % $ q ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { $ p = ( $ d * $ p + $ pat [ $ i ] ) % $ q ; $ t = ( $ d * $ t + $ txt [ $ i ] ) % $ q ; } for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { if ( $ p == $ t ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; } if ( $ j == $ M ) echo \" Pattern ▁ found ▁ at ▁ index ▁ \" , $ i , \" STRNEWLINE \" ; } if ( $ i < $ N - $ M ) { $ t = ( $ d * ( $ t - $ txt [ $ i ] * $ h ) + $ txt [ $ i + $ M ] ) % $ q ; if ( $ t < 0 ) $ t = ( $ t + $ q ) ; } } } $ txt = \" GEEKS ▁ FOR ▁ GEEKS \" ; $ pat = \" GEEK \" ; $ q = 101 ; search ( $ pat , $ txt , $ q ) ; ? >"}
{"text": "Algoritma naif yang dioptimumkan untuk mencari corak | Algorithn mencari Pettern Naive yang dioptimumkan untuk kes -kes apabila semua watak corak adalah berbeza; Untuk indeks semasa I, periksa perlawanan corak; Jika Pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]; Luncurkan corak oleh J; Kod pemacu", "code": "< ? php function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i = 0 ; while ( $ i <= $ N - $ M ) { $ j ; for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { echo ( \" Pattern ▁ found ▁ at ▁ index ▁ $ i \" . \" STRNEWLINE \" ) ; $ i = $ i + $ M ; } else if ( $ j == 0 ) $ i = $ i + 1 ; else $ i = $ i + $ j ; } } $ txt = \" ABCEABCDABCEABCD \" ; $ pat = \" ABCD \" ; search ( $ pat , $ txt ) ; ? >"}
{"text": "Cetak semua rentetan yang boleh dibuat dengan meletakkan ruang | Fungsi secara rekursif mencetak rentetan yang mempunyai corak ruang. Saya dan J adalah indeks dalam 'str []' dan 'buff []' masing -masing; Sama ada meletakkan watak; Atau meletakkan ruang diikuti oleh watak seterusnya; Fungsi ini mewujudkan Buf [] untuk menyimpan rentetan output individu dan menggunakan printPatternUtil () untuk mencetak semua permutasi. ; Penampan untuk memegang rentetan yang mengandungi ruang 2 n - 1 aksara dan 1 rentetan terminator; Salin watak pertama seperti itu, kerana ia akan sentiasa berada di kedudukan pertama; Kod pemacu", "code": "< ? php function printPatternUtil ( $ str , $ buff , $ i , $ j , $ n ) { if ( $ i == $ n ) { $ buff [ $ j ] = ' ' ; echo str_replace ( ' , ▁ ' , ' ' , implode ( ' , ▁ ' , $ buff ) ) . \" STRNEWLINE \" ; return ; } $ buff [ $ j ] = $ str [ $ i ] ; printPatternUtil ( $ str , $ buff , $ i + 1 , $ j + 1 , $ n ) ; $ buff [ $ j ] = ' ▁ ' ; $ buff [ $ j + 1 ] = $ str [ $ i ] ; printPatternUtil ( $ str , $ buff , $ i +1 , $ j + 2 , $ n ) ; } function printPattern ( $ str ) { $ n = strlen ( $ str ) ; $ buf = array_fill ( 0 , 2 * $ n , null ) ; $ buf [ 0 ] = $ str [ 0 ] ; printPatternUtil ( $ str , $ buf , 1 , 1 , $ n ) ; } $ str = \" ABCD \" ; printPattern ( $ str ) ; ? >"}
{"text": "Median dari dua susunan yang disusun dengan saiz yang sama | Fungsi ini mengembalikan median AR1 [] dan AR2 []. Andaian dalam fungsi ini: kedua -dua Ar1 [] dan Ar2 [] disusun susunan kedua -duanya mempunyai unsur N; Oleh kerana terdapat 2 elemen, median akan menjadi purata elemen pada indeks n - 1 dan n dalam array yang diperolehi selepas menggabungkan AR1 dan AR2; Di bawah ini adalah untuk mengendalikan kes di mana semua elemen AR1 [] lebih kecil daripada elemen terkecil (atau pertama) AR2 []; Di bawah ini adalah untuk mengendalikan kes di mana semua elemen AR2 [] lebih kecil daripada elemen terkecil (atau pertama) AR1 []; sama dengan tanda kerana jika dua tatasusunan mempunyai beberapa elemen biasa; Simpan median sebelumnya; Simpan median sebelumnya; Kod pemacu", "code": "< ? php function getMedian ( $ ar1 , $ ar2 , $ n ) { $ i = 0 ; $ j = 0 ; $ count ; $ m1 = -1 ; $ m2 = -1 ; for ( $ count = 0 ; $ count <= $ n ; $ count ++ ) { if ( $ i == $ n ) { $ m1 = $ m2 ; $ m2 = $ ar2 [ 0 ] ; break ; } else if ( $ j == $ n ) { $ m1 = $ m2 ; $ m2 = $ ar1 [ 0 ] ; break ; } if ( $ ar1 [ $ i ] <= $ ar2 [ $ j ] ) { $ m1 = $ m2 ; $ m2 = $ ar1 [ $ i ] ; $ i ++ ; } else { $ m1 = $ m2 ; $ m2 = $ ar2 [ $ j ] ; $ j ++ ; } } return ( $ m1 + $ m2 ) / 2 ; } $ ar1 = array ( 1 , 12 , 15 , 26 , 38 ) ; $ ar2 = array ( 2 , 13 , 17 , 30 , 45 ) ; $ n1 = sizeof ( $ ar1 ) ; $ n2 = sizeof ( $ ar2 ) ; if ( $ n1 == $ n2 ) echo ( \" Median ▁ is ▁ \" . getMedian ( $ ar1 , $ ar2 , $ n1 ) ) ; else echo ( \" Doesn ' t ▁ work ▁ for ▁ arrays \" . \" of ▁ unequal ▁ size \" ) ; ? >"}
{"text": "Semak sama ada titik tertentu terletak di dalam segitiga atau tidak | Fungsi utiliti untuk mengira kawasan segitiga yang dibentuk oleh (x1, y1), (x2, y2) dan (x3, y3); Fungsi untuk memeriksa sama ada p (x, y) terletak di dalam segitiga yang dibentuk oleh A (x1, y1), b (x2, y2) dan c (x3, y3); Mengira kawasan segitiga ABC; Hitung kawasan segitiga PBC; Hitung kawasan segitiga PAC; Hitung kawasan Segitiga Pab; Semak sama ada jumlah A1, A2 dan A3 adalah sama dengan A; Marilah kita periksa sama ada P (10, 15) terletak di dalam segitiga yang dibentuk oleh A (0, 0), B (20, 0) dan C (10, 30)", "code": "< ? php function area ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) { return abs ( ( $ x1 * ( $ y2 - $ y3 ) + $ x2 * ( $ y3 - $ y1 ) + $ x3 * ( $ y1 - $ y2 ) ) / 2.0 ) ; } function isInside ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x , $ y ) { $ A = area ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) ; $ A1 = area ( $ x , $ y , $ x2 , $ y2 , $ x3 , $ y3 ) ; $ A2 = area ( $ x1 , $ y1 , $ x , $ y , $ x3 , $ y3 ) ; $ A3 = area ( $ x1 , $ y1 , $ x2 , $ y2 , $ x , $ y ) ; return ( $ A == $ A1 + $ A2 + $ A3 ) ; } if ( isInside ( 0 , 0 , 20 , 0 , 10 , 30 , 10 , 15 ) ) echo \" Inside \" ; else echo \" Not ▁ Inside \" ; ? >"}
{"text": "Nombor bertuah | Pulangan 1 Jika n adalah tidak bertuah. Ohterwise pulangan 0; Variable next_position hanya untuk kebolehbacaan program yang kita boleh mengeluarkannya dan menggunakan n sahaja; Kirakan kedudukan input No yang seterusnya; Kod pemacu", "code": "< ? php function isLucky ( $ n ) { $ counter = 2 ; $ next_position = $ n ; if ( $ counter > $ n ) return 1 ; if ( $ n % $ counter == 0 ) return 0 ; $ next_position -= $ next_position / $ counter ; $ counter ++ ; return isLucky ( $ next_position ) ; } $ x = 5 ; if ( isLucky ( $ x ) ) echo $ x , \" ▁ is ▁ a ▁ lucky ▁ no . \" ; else echo $ x , \" ▁ is ▁ not ▁ a ▁ lucky ▁ no . \" ; ? >"}
{"text": "Tulis kuasa anda sendiri tanpa menggunakan pengendali pendaraban ( *) dan pembahagian ( /) | Berfungsi hanya jika a> = 0 dan b> = 0; Kod pemacu", "code": "< ? php function poww ( $ a , $ b ) { if ( $ b == 0 ) return 1 ; $ answer = $ a ; $ increment = $ a ; $ i ; $ j ; for ( $ i = 1 ; $ i < $ b ; $ i ++ ) { for ( $ j = 1 ; $ j < $ a ; $ j ++ ) { $ answer += $ increment ; } $ increment = $ answer ; } return $ answer ; } echo ( poww ( 5 , 3 ) ) ; ? >"}
{"text": "Tulis kuasa anda sendiri tanpa menggunakan pengendali pendaraban ( *) dan pembahagian ( /) | Fungsi rekursif untuk mendapatkan x * y; Fungsi rekursif untuk mendapatkan A ^ B berfungsi hanya jika a> = 0 dan b> = 0; Kod pemacu", "code": "< ? php function multiply ( $ x , $ y ) { if ( $ y ) return ( $ x + multiply ( $ x , $ y - 1 ) ) ; else return 0 ; } function p_ow ( $ a , $ b ) { if ( $ b ) return multiply ( $ a , p_ow ( $ a , $ b - 1 ) ) ; else return 1 ; } echo pow ( 5 , 3 ) ; ? >"}
{"text": "Kira nombor yang tidak mengandungi 3 | Mengembalikan kiraan nombor yang berada dalam jarak dari 1 hingga N dan Don 't mengandungi 3 sebagai digit; Kes asas (dengan asumsi n tidak negatif); Kirakan 10 ^ (d - 1) (10 Raise ke kuasa d - 1) di mana d adalah bilangan digit dalam n. PO akan menjadi 100 untuk n = 578; Cari digit yang paling penting (MSD ialah 5 untuk 578); Untuk 578, jumlahnya akan menjadi 4 * kiraan (10 ^ 2 - 1) + 4 + kiraan (78); Untuk 35, jumlah akan sama dengan kiraan (29); Program pemacu untuk menguji fungsi di atas", "code": "< ? php function count1 ( $ n ) { if ( $ n < 3 ) return $ n ; if ( $ n >= 3 && $ n < 10 ) return $ n - 1 ; $ po = 1 ; for ( $ x = intval ( $ n / $ po ) ; $ x > 9 ; $ x = intval ( $ n / $ po ) ) $ po = $ po * 10 ; $ msd = intval ( $ n / $ po ) ; if ( $ msd != 3 ) return count1 ( $ msd ) * count1 ( $ po - 1 ) + count1 ( $ msd ) + count1 ( $ n % $ po ) ; else return count1 ( $ msd * $ po - 1 ) ; } echo count1 ( 578 ) ; ? >"}
{"text": "Nombor yang mempunyai bilangan maksimum faktor utama yang berbeza dalam julat m hingga n | Berfungsi untuk mengembalikan nombor maksimum; array untuk menyimpan bilangan prima yang berbeza; Benar jika indeks 'i' adalah perdana; memulakan bilangan faktor kepada 0 dan; Digunakan dalam ayak; Keadaan hanya berfungsi apabila 'i' adalah perdana, oleh itu untuk faktor -faktor semua nombor perdana, status utama ditukar kepada palsu; Nombor adalah perdana; Bilangan faktor nombor perdana ialah 1; Meningkatkan faktor -faktor semua faktor i; dan menukar status utama menjadi palsu; Memulakan maksimum dan num; Mendapat nombor maksimum; Mendapat nombor maksimum; Kod pemacu; Fungsi panggilan", "code": "< ? php function maximumNumberDistinctPrimeRange ( $ m , $ n ) { $ factorCount = array ( ) ; $ prime = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { $ factorCount [ $ i ] = 0 ; $ prime [ $ i ] = true ; } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ prime [ $ i ] == true ) { $ factorCount [ $ i ] = 1 ; for ( $ j = $ i * 2 ; $ j <= $ n ; $ j += $ i ) { $ factorCount [ $ j ] ++ ; $ prime [ $ j ] = false ; } } } $ max = $ factorCount [ $ m ] ; $ num = $ m ; for ( $ i = $ m ; $ i <= $ n ; $ i ++ ) { if ( $ factorCount [ $ i ] > $ max ) { $ max = $ factorCount [ $ i ] ; $ num = $ i ; } } return $ num ; } $ m = 4 ; $ n = 6 ; echo maximumNumberDistinctPrimeRange ( $ m , $ n ) ; ? >"}
{"text": "Kedudukan Lexicographic rentetan | Fungsi utiliti untuk mencari faktorial n; Fungsi utiliti untuk mengira aksara yang lebih kecil di sebelah kanan ARR [rendah]; Fungsi untuk mencari pangkat rentetan dalam semua permutasi aksara; kiraan bilangan chars lebih kecil daripada str [i] fron str [i + 1] ke str [len - 1]; Kod pemacu", "code": "< ? php function fact ( $ n ) { return ( $ n <= 1 ) ? 1 : $ n * fact ( $ n - 1 ) ; } function findSmallerInRight ( $ str , $ low , $ high ) { $ countRight = 0 ; for ( $ i = $ low + 1 ; $ i <= $ high ; ++ $ i ) if ( $ str [ $ i ] < $ str [ $ low ] ) ++ $ countRight ; return $ countRight ; } function findRank ( $ str ) { $ len = strlen ( $ str ) ; $ mul = fact ( $ len ) ; $ rank = 1 ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) { $ mul /= $ len - $ i ; $ countRight = findSmallerInRight ( $ str , $ i , $ len - 1 ) ; $ rank += $ countRight * $ mul ; } return $ rank ; } $ str = \" string \" ; echo findRank ( $ str ) ; ? >"}
{"text": "Kedudukan Lexicographic rentetan | Penyelesaian o (n) untuk mencari pangkat rentetan; Semua elemen kiraan [] diasaskan dengan 0; Fungsi utiliti untuk mencari faktorial n; Membina array kiraan di mana nilai pada setiap indeks mengandungi kiraan aksara yang lebih kecil dalam keseluruhan rentetan; Membuang watak ch dari Count [] array yang dibina oleh populateAndIncreaseCount (); Fungsi untuk mencari pangkat rentetan dalam semua permutasi aksara; Mengisi array kiraan seperti yang dikira [i] mengandungi kiraan aksara yang terdapat di STR dan lebih kecil daripada saya; kiraan bilangan chars lebih kecil daripada str [i] fron str [i + 1] ke str [len - 1]; Mengurangkan kiraan watak yang lebih besar daripada STR [i]; Kod pemacu", "code": "< ? php $ MAX_CHAR = 256 ; $ count = array_fill ( 0 , $ MAX_CHAR + 1 , 0 ) ; function fact ( $ n ) { return ( $ n <= 1 ) ? 1 : $ n * fact ( $ n - 1 ) ; } function populateAndIncreaseCount ( & $ count , $ str ) { global $ MAX_CHAR ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; ++ $ i ) ++ $ count [ ord ( $ str [ $ i ] ) ] ; for ( $ i = 1 ; $ i < $ MAX_CHAR ; ++ $ i ) $ count [ $ i ] += $ count [ $ i - 1 ] ; } function updatecount ( & $ count , $ ch ) { global $ MAX_CHAR ; for ( $ i = ord ( $ ch ) ; $ i < $ MAX_CHAR ; ++ $ i ) -- $ count [ $ i ] ; } function findRank ( $ str ) { global $ MAX_CHAR ; $ len = strlen ( $ str ) ; $ mul = fact ( $ len ) ; $ rank = 1 ; populateAndIncreaseCount ( $ count , $ str ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) { $ mul = ( int ) ( $ mul / ( $ len - $ i ) ) ; $ rank += $ count [ ord ( $ str [ $ i ] ) - 1 ] * $ mul ; updatecount ( $ count , $ str [ $ i ] ) ; } return $ rank ; } $ str = \" string \" ; echo findRank ( $ str ) ; ? >"}
{"text": "Program yang cekap untuk mengira e ^ x | Mengembalikan nilai anggaran e ^ x menggunakan jumlah terma pertama n siri Taylor; memulakan jumlah siri; Kod pemacu", "code": "< ? php function exponential ( $ n , $ x ) { $ sum = 1.0 ; for ( $ i = $ n - 1 ; $ i > 0 ; -- $ i ) $ sum = 1 + $ x * $ sum / $ i ; return $ sum ; } $ n = 10 ; $ x = 1.0 ; echo ( \" e ^ x ▁ = ▁ \" . exponential ( $ n , $ x ) ) ; ? >"}
{"text": "Bagaimana untuk memeriksa sama ada nombor tertentu adalah nombor Fibonacci? | Fungsi utiliti yang kembali benar jika x adalah persegi sempurna; Pulangan benar jika n adalah nombor Fibinacci, lain -lain palsu; n ialah Fibinacci jika salah satu daripada 5 * n * n + 4 atau 5 * n * n - 4 atau kedua -duanya adalah persegi Perferct; Kod pemacu", "code": "< ? php function isPerfectSquare ( $ x ) { $ s = ( int ) ( sqrt ( $ x ) ) ; return ( $ s * $ s == $ x ) ; } function isFibonacci ( $ n ) { return isPerfectSquare ( 5 * $ n * $ n + 4 ) || isPerfectSquare ( 5 * $ n * $ n - 4 ) ; } for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) if ( isFibonacci ( $ i ) ) echo \" $ i ▁ is ▁ a ▁ Fibonacci ▁ Number ▁ STRNEWLINE \" ; else echo \" $ i ▁ is ▁ a ▁ not ▁ Fibonacci ▁ Number ▁ STRNEWLINE \" ; ? >"}
{"text": "Mengira sifar dalam faktorial nombor | Berfungsi untuk kembali trailing 0 s dalam faktorial n; Memulakan hasil; Pastikan membahagikan n dengan kuasa 5 dan mengemaskini kiraan; Kod pemacu", "code": "< ? php function findTrailingZeros ( $ n ) { $ count = 0 ; for ( $ i = 5 ; $ n / $ i >= 1 ; $ i *= 5 ) $ count += $ n / $ i ; return $ count ; } $ n = 100 ; echo \" Count ▁ of ▁ trailing ▁ 0s ▁ in ▁ \" , 100 , \" ! ▁ is ▁ \" , findTrailingZeros ( $ n ) ; ? >"}
{"text": "Program untuk Nth Catalan Number | Fungsi rekursif untuk mencari nombor nth Catalan; Kes asas; Catalan (N) adalah jumlah Catalan (I) * Catalan (N - I - 1); Kod pemacu", "code": "< ? php function catalan ( $ n ) { if ( $ n <= 1 ) return 1 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res += catalan ( $ i ) * catalan ( $ n - $ i - 1 ) ; return $ res ; } for ( $ i = 0 ; $ i < 10 ; $ i ++ ) echo catalan ( $ i ) , \" ▁ \" ; ? >"}
{"text": "Program untuk Nth Catalan Number | Program PHP untuk Nth Catalan nombor fungsi berasaskan pengaturcaraan dinamik untuk mencari nombor Catalan n; Jadual untuk menyimpan hasil subproblem; Memulakan dua nilai pertama dalam jadual; Isi penyertaan di Catalan [] menggunakan formula rekursif; Kembali entri terakhir; Kod pemacu", "code": "< ? php function catalanDP ( $ n ) { $ catalan = array ( ) ; $ catalan [ 0 ] = $ catalan [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ catalan [ $ i ] = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ catalan [ $ i ] += $ catalan [ $ j ] * $ catalan [ $ i - $ j - 1 ] ; } return $ catalan [ $ n ] ; } for ( $ i = 0 ; $ i < 10 ; $ i ++ ) echo catalanDP ( $ i ) , \" ▁ \" ;"}
{"text": "Program untuk Nth Catalan Number | Pulangan nilai pekali binomial c (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Fungsi berasaskan pekali binomial untuk mencari nombor catalan n dalam masa O (n); Hitung nilai 2 ncn; kembali 2 ncn / (n + 1); Kod pemacu", "code": "< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res = floor ( $ res / ( $ i + 1 ) ) ; } return $ res ; } function catalan ( $ n ) { $ c = binomialCoeff ( 2 * ( $ n ) , $ n ) ; return floor ( $ c / ( $ n + 1 ) ) ; } for ( $ i = 0 ; $ i < 10 ; $ i ++ ) echo catalan ( $ i ) , \" ▁ \" ; ? >"}
{"text": "Kirakan sudut antara tangan dan tangan minit | Fungsi utiliti untuk mencari minimum dua bilangan bulat; Berfungsi untuk mengira sudut; mengesahkan input; Kirakan sudut yang dipindahkan mengikut jam dan minit dengan merujuk kepada 12: 00; Cari perbezaan antara dua sudut; Mengembalikan sudut yang lebih kecil daripada dua sudut yang mungkin; Kod pemacu", "code": "< ? php function mintwo ( $ x , $ y ) { return ( $ x < $ y ) ? $ x : $ y ; } function calcAngle ( $ h , $ m ) { if ( $ h < 0 $ m < 0 $ h > 12 $ m > 60 ) echo \" Wrong ▁ input \" ; if ( $ h == 12 ) $ h = 0 ; if ( $ m == 60 ) { $ m = 0 ; $ h += 1 ; if ( $ h > 12 ) $ h = $ h - 12 ; } $ hour_angle = 0.5 * ( $ h * 60 + $ m ) ; $ minute_angle = 6 * $ m ; $ angle = abs ( $ hour_angle - $ minute_angle ) ; $ angle = min ( 360 - $ angle , $ angle ) ; return $ angle ; } echo calcAngle ( 9 , 60 ) , \" STRNEWLINE \" ; echo calcAngle ( 3 , 30 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Bagaimana untuk memeriksa sama ada contoh 8 teka -teki boleh diselesaikan? | Fungsi utiliti untuk mengira penyongsangan dalam array yang diberikan 'arr []'; Nilai 0 digunakan untuk ruang kosong; Fungsi ini kembali benar jika diberikan 8 teka -teki boleh diselesaikan. ; Mengira penyongsangan dalam teka -teki yang diberikan 8; Kembali benar jika kiraan penyongsangan adalah juga. ; Kod pemacu", "code": "< ? php function getInvCount ( $ arr ) { $ inv_count = 0 ; for ( $ i = 0 ; $ i < 9 - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < 9 ; $ j ++ ) $ inv_count ++ ; return $ inv_count ; } function isSolvable ( $ puzzle ) { $ invCount = getInvCount ( $ puzzle ) ; return ( $ invCount % 2 == 0 ) ; } $ puzzle = array ( array ( 1 , 8 , 2 ) , array ( 0 , 4 , 3 ) , array ( 7 , 6 , 5 ) ) ; if ( isSolvable ( $ puzzle ) == true ) echo \" Solvable \" ; else echo \" Not ▁ Solvable \" ; ? >"}
{"text": "Paradoks Hari Lahir | Mengembalikan anggaran bilangan orang untuk kebarangkalian yang diberikan; Kod pemacu", "code": "< ? php function find ( $ p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - $ p ) ) ) ) ; } echo find ( 0.70 ) ; ? >"}
{"text": "Count berbeza bukan | Fungsi Mengira bilangan pasangan (x, y) yang memenuhi ketidaksamaan x * x + y * y <n. ; Kod pemacu", "code": "< ? php function countSolutions ( $ n ) { $ res = 0 ; for ( $ x = 0 ; $ x * $ x < $ n ; $ x ++ ) for ( $ y = 0 ; $ x * $ x + $ y * $ y < $ n ; $ y ++ ) $ res ++ ; return $ res ; } { echo \" Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ \" ; echo countSolutions ( 6 ) ; return 0 ; } ? >"}
{"text": "Count berbeza bukan | Fungsi ini mengira bilangan pasangan (x, y) yang memenuhi ketidaksamaan x * x + y * y <n. ; Cari kiraan nilai y yang berbeza untuk x = 0 .; Satu demi satu peningkatan nilai x, dan cari ycount untuk x semasa. Jika ycount menjadi 0, maka kami telah mencapai nilai maksimum x. ; Tambah ycount (kiraan nilai yang berbeza mungkin y untuk x semasa) untuk menghasilkan; Kenaikan x; Kemas kini ycount untuk x semasa. Terus mengurangkan ycount sementara ketidaksamaan tidak berpuas hati. ; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function countSolutions ( $ n ) { $ x = 0 ; $ yCount ; $ res = 0 ; for ( $ yCount = 0 ; $ yCount * $ yCount < $ n ; $ yCount ++ ) ; while ( $ yCount != 0 ) { $ res += $ yCount ; $ x ++ ; while ( $ yCount != 0 and ( $ x * $ x + ( $ yCount - 1 ) * ( $ yCount - 1 ) >= $ n ) ) $ yCount -- ; } return $ res ; } echo \" Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative \" , \" pairs ▁ is ▁ \" , countSolutions ( 6 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk Kaedah Newton Raphson | Program PHP untuk pelaksanaan kaedah Newton Raphson untuk menyelesaikan persamaan; Fungsi contoh yang penyelesaiannya ditentukan menggunakan kaedah bisection. Fungsi ini adalah x ^ 3 - x ^ 2 + 2; Derivatif fungsi di atas iaitu 3 * x ^ x - 2 * x; Berfungsi untuk mencari akar; x (i + 1) = x (i) - f (x) / f '(x); Nilai awal diandaikan", "code": "< ? php $ EPSILON = 0.001 ; function func ( $ x ) { return $ x * $ x * $ x - $ x * $ x + 2 ; } function derivFunc ( $ x ) { return 3 * $ x * $ x - 2 * $ x ; } function newtonRaphson ( $ x ) { global $ EPSILON ; $ h = func ( $ x ) / derivFunc ( $ x ) ; while ( abs ( $ h ) >= $ EPSILON ) { $ h = func ( $ x ) / derivFunc ( $ x ) ; $ x = $ x - $ h ; } echo \" The ▁ value ▁ of ▁ the ▁ \" . \" root ▁ is ▁ : ▁ \" , $ x ; } $ x0 = -20 ; newtonRaphson ( $ x0 ) ; ? >"}
{"text": "Cari elemen yang muncul sekali | Kaedah untuk mencari elemen yang berlaku sekali sahaja; Ungkapan \"Satu & ur [i]\" memberikan bit yang ada di kedua -dua 'Ones' dan elemen baru dari ARR []. Kami menambah bit ini kepada 'twos' menggunakan bitwise atau nilai 'twos' akan ditetapkan sebagai 0, 3, 3 dan 1 selepas 1 st, 2 nd, 3 rd dan 4 lelaran masing -masing; Xor bit baru dengan 'yang terdahulu' untuk mendapatkan semua bit yang muncul bilangan ganjil kali nilai 'Ones' akan ditetapkan sebagai 3, 0, 2 dan 3 selepas 1 st, 2 nd, 3 rd dan ke -4 lelaran masing -masing; Bit biasa adalah bit yang muncul kali ketiga. Jadi bit ini tidak boleh berada di kedua -dua 'orang' dan 'twos'. Common_bit_mask mengandungi semua bit ini sebagai 0, supaya bit dapat dikeluarkan dari nilai 'Ones' dan 'Twos' dari 'Common _ Bit _ Mask' akan ditetapkan sebagai 00, 00, 01 dan 10 selepas 1 ST, 2 ND, 3 RD dan 4 ITERASI masing -masing; Keluarkan bit biasa (bit yang muncul kali ketiga) dari nilai 'Ones' dari 'Ones' akan ditetapkan sebagai 3, 0, 0 dan 2 selepas 1 st, 2 nd, 3 rd dan 4 lelaran masing -masing; Keluarkan bit biasa (bit yang muncul kali ketiga) dari nilai 'twos' dari 'twos' akan ditetapkan sebagai 0, 3, 1 dan 0 selepas 1 st, 2 nd, 3 rd dan ke -4 masing -masing; Kod pemacu", "code": "< ? php function getSingle ( $ arr , $ n ) { $ ones = 0 ; $ twos = 0 ; $ common_bit_mask ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ twos = $ twos | ( $ ones & $ arr [ $ i ] ) ; $ ones = $ ones ^ $ arr [ $ i ] ; $ common_bit_mask = ~ ( $ ones & $ twos ) ; $ ones &= $ common_bit_mask ; $ twos &= $ common_bit_mask ; } return $ ones ; } $ arr = array ( 3 , 3 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; echo \" The ▁ element ▁ with ▁ single ▁ \" . \" occurrence ▁ is ▁ \" , getSingle ( $ arr , $ n ) ; ? >"}
{"text": "Cari elemen yang muncul sekali | Kod PHP untuk mencari elemen yang berlaku sekali sahaja; Memulakan hasil; Melangkah melalui setiap bit; Cari jumlah bit set pada kedudukan ith dalam semua elemen array; Bit dengan jumlah tidak berganda 3, adalah bit elemen dengan kejadian tunggal. ; Kod pemacu", "code": "< ? php $ INT_SIZE = 32 ; function getSingle ( $ arr , $ n ) { global $ INT_SIZE ; $ result = 0 ; $ x ; $ sum ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) { $ sum = 0 ; $ x = ( 1 << $ i ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] & $ x ) $ sum ++ ; } if ( ( $ sum % 3 ) != 0 ) $ result |= $ x ; } return $ result ; } $ arr = array ( 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 ) ; $ n = sizeof ( $ arr ) ; echo \" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ \" , getSingle ( $ arr , $ n ) ; ? >"}
{"text": "Mengesan jika dua bilangan bulat mempunyai tanda bertentangan | Berfungsi untuk mengesan tanda; Kod pemacu", "code": "< ? php function oppositeSigns ( $ x , $ y ) { return ( ( $ x ^ $ y ) < 0 ) ; } $ x = 100 ; $ y = -100 ; if ( oppositeSigns ( $ x , $ y ) == true ) echo ( \" Signs ▁ are ▁ opposite \" ) ; else echo ( \" Signs ▁ are ▁ not ▁ opposite \" ) ; ? >"}
{"text": "Kira jumlah set bit dalam semua nombor dari 1 hingga n | Mengembalikan kiraan bit set yang terdapat dalam semua nombor dari 1 hingga n; memulakan hasilnya; Fungsi utiliti untuk mengira bit set dalam nombor x; Kod pemacu", "code": "< ? php function countSetBits ( $ n ) { $ bitCount = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ bitCount += countSetBitsUtil ( $ i ) ; return $ bitCount ; } function countSetBitsUtil ( $ x ) { if ( $ x <= 0 ) return 0 ; return ( $ x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( $ x / 2 ) ; } $ n = 4 ; echo \" Total ▁ set ▁ bit ▁ count ▁ is ▁ \" . countSetBits ( $ n ) ; ? >"}
{"text": "Kira jumlah set bit dalam semua nombor dari 1 hingga n | Fungsi yang mengira bit set dari 0 hingga n; Jumlah kedai set bit dari 0 hingga n; manakala n lebih besar daripada sama dengan 2 ^ i; K ini akan dibalikkan selepas 2 ^ ierasi; Perubahan adalah iterator dari 2 ^ i ke 1; Ini akan gelung dari 0 hingga N untuk setiap kedudukan bit; Apabila perubahan = 1 flip bit; sekali lagi tetapkan perubahan kepada 2 ^ i; Meningkatkan kedudukan; Kod pemacu", "code": "< ? php function countSetBits ( $ n ) { $ i = 0 ; $ ans = 0 ; while ( ( 1 << $ i ) <= $ n ) { $ k = 0 ; $ change = 1 << $ i ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { $ ans += $ k ; if ( $ change == 1 ) { $ k = ! $ k ; $ change = 1 << $ i ; } else { $ change -- ; } } $ i ++ ; } return $ ans ; } $ n = 17 ; echo ( countSetBits ( $ n ) ) ; ? >"}
{"text": "Swap bit dalam nombor tertentu | Program PHP untuk menukar bit dalam fungsi nombor tertentu mengembalikan bit bertukar; Gerakkan semua bit set pertama ke sebelah kanan; Gerakkan semua bit set kedua ke sebelah kanan; Xor dua set; Letakkan bit XOR kembali ke kedudukan asal mereka; Xor 'xor' dengan nombor asal supaya kedua -dua set itu ditukar; Kod pemacu", "code": "< ? php function swapBits ( $ x , $ p1 , $ p2 , $ n ) { $ set1 = ( $ x >> $ p1 ) & ( ( 1 << $ n ) - 1 ) ; $ set2 = ( $ x >> $ p2 ) & ( ( 1 << $ n ) - 1 ) ; $ xor = ( $ set1 ^ $ set2 ) ; $ xor = ( $ xor << $ p1 ) | ( $ xor << $ p2 ) ; $ result = $ x ^ $ xor ; return $ result ; } $ res = swapBits ( 28 , 0 , 3 , 2 ) ; echo \" Result = \" ? >"}
{"text": "Terkecil daripada tiga bilangan bulat tanpa pengendali perbandingan | Program PHP untuk mencari terkecil daripada tiga bilangan bulat tanpa pengendali perbandingan; Kod pemacu", "code": "< ? php function smallest ( $ x , $ y , $ z ) { $ c = 0 ; while ( $ x && $ y && $ z ) { $ x -- ; $ y -- ; $ z -- ; $ c ++ ; } return $ c ; } $ x = 12 ; $ y = 15 ; $ z = 5 ; echo \" Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ \" . smallest ( $ x , $ y , $ z ) ; ? >"}
{"text": "Nombor seterusnya yang lebih tinggi dengan bilangan bit set yang sama | Fungsi ini mengembalikan nombor yang lebih tinggi seterusnya dengan bilangan bit yang sama seperti x. ; betul -betul betul bit; Tetapkan semula corak dan tetapkan bahagian kiri yang lebih tinggi seterusnya X akan berada di sini; Nexthigheronebit kini menjadi sebahagian daripada penjelasan di atas. mengasingkan corak; corak penyesuaian yang betul; faktor pembetulan; Rightonespattern kini menjadi sebahagian daripada penjelasan di atas. mengintegrasikan corak baru (tambah [d] dan [a]); Kod pemacu", "code": "< ? php function snoob ( $ x ) { $ next = 0 ; if ( $ x ) { $ rightOne = $ x & - $ x ; $ nextHigherOneBit = $ x + $ rightOne ; $ rightOnesPattern = $ x ^ $ nextHigherOneBit ; $ rightOnesPattern = intval ( ( $ rightOnesPattern ) / $ rightOne ) ; $ rightOnesPattern >>= 2 ; $ next = $ nextHigherOneBit | $ rightOnesPattern ; } return $ next ; } $ x = 156 ; echo \" Next ▁ higher ▁ number ▁ with ▁ same ▁ \" . \" number ▁ of ▁ set ▁ bits ▁ is ▁ \" . snoob ( $ x ) ; ? >"}
{"text": "Tambah 1 ke nombor tertentu | Kod PHP untuk menambah Tambah satu ke nombor tertentu; Flip semua bit set sehingga kita dapati 0; Flip paling tepat 0 bit; Kod pemacu", "code": "< ? php function addOne ( $ x ) { $ m = 1 ; while ( $ x & $ m ) { $ x = $ x ^ $ m ; $ m <<= 1 ; } $ x = $ x ^ $ m ; return $ x ; } echo addOne ( 13 ) ; ? >"}
{"text": "Tambah 1 ke nombor tertentu | Kod PHP untuk menambah 1 ke nombor tertentu; Kod pemacu", "code": "< ? php function addOne ( $ x ) { return ( - ( ~ $ x ) ) ; } echo addOne ( 13 ) ; ? >"}
{"text": "Masukkan integer yang diberikan dengan 3.5 | Program PHP untuk membiak nombor dengan 3.5; Kod pemacu", "code": "< ? php function multiplyWith3Point5 ( $ x ) { return ( $ x << 1 ) + $ x + ( $ x >> 1 ) ; } $ x = 4 ; echo multiplyWith3Point5 ( $ x ) ; ? >"}
{"text": "Matikan Bit Set Bit | tidak menetapkan bit set yang paling kanan dan mengembalikan hasilnya; Kod pemacu", "code": "< ? php function fun ( $ n ) { return $ n & ( $ n - 1 ) ; } $ n = 7 ; echo \" The ▁ number ▁ after ▁ unsetting ▁ the \" . \" ▁ rightmost ▁ set ▁ bit ▁ \" , fun ( $ n ) ; ? >"}
{"text": "Cari sama ada nombor tertentu adalah kuasa 4 atau tidak | Fungsi untuk memeriksa sama ada x adalah kuasa 4; Kod pemacu", "code": "< ? php function isPowerOfFour ( $ n ) { if ( $ n == 0 ) return 0 ; while ( $ n != 1 ) { if ( $ n % 4 != 0 ) return 0 ; $ n = $ n / 4 ; } return 1 ; } $ test_no = 64 ; if ( isPowerOfFour ( $ test_no ) ) echo $ test_no , \" ▁ is ▁ a ▁ power ▁ of ▁ 4\" ; else echo $ test_no , \" ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4\" ; ? >"}
{"text": "Cari sama ada nombor tertentu adalah kuasa 4 atau tidak | Fungsi untuk memeriksa sama ada x adalah kuasa 4; Semak sama ada hanya satu set bit dalam n; Kira 0 bit sebelum ditetapkan bit; Sekiranya kiraannya, maka kembali lagi yang lain palsu; Sekiranya terdapat lebih daripada 1 bit set maka n bukan kuasa 4; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function isPowerOfFour ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) { while ( $ n > 1 ) { $ n >>= 1 ; $ count += 1 ; } return ( $ count % 2 == 0 ) ? 1 : 0 ; } return 0 ; } $ test_no = 64 ; if ( isPowerOfFour ( $ test_no ) ) echo $ test_no , \" ▁ is ▁ a ▁ power ▁ of ▁ 4\" ; else echo $ test_no , \" ▁ not ▁ is ▁ a ▁ power ▁ of ▁ 4\" ; ? >"}
{"text": "Kirakan minimum atau maksimum dua bilangan bulat tanpa bercabang | Berfungsi untuk mencari minimum x dan y; Fungsi untuk mencari maksimum x dan y; Kod pemacu", "code": "< ? php function m_in ( $ x , $ y ) { return $ y ^ ( ( $ x ^ $ y ) & - ( $ x < $ y ) ) ; } function m_ax ( $ x , $ y ) { return $ x ^ ( ( $ x ^ $ y ) & - ( $ x < $ y ) ) ; } $ x = 15 ; $ y = 6 ; echo \" Minimum ▁ of \" , \" ▁ \" , $ x , \" ▁ \" , \" and \" , \" ▁ \" , $ y , \" ▁ \" , \" ▁ is ▁ \" , \" ▁ \" ; echo m_in ( $ x , $ y ) ; echo \" Maximum of \" , \" \" , $ x , \" \" , STRNEWLINE TABSYMBOL \" and \" , \" \" , $ y , \" \" , ▁ \" is \" echo m_ax ( $ x , $ y ) ; ? >"}
{"text": "Cari nombor yang berlaku pada masa yang ganjil | Berfungsi untuk mencari elemen yang berlaku bilangan kali ganjil; Kod pemacu; Fungsi panggilan", "code": "< ? php function getOddOccurrence ( & $ arr , $ arr_size ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { for ( $ j = 0 ; $ j < $ arr_size ; $ j ++ ) { if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ count ++ ; } if ( $ count % 2 != 0 ) return $ arr [ $ i ] ; } return -1 ; } $ arr = array ( 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ) ; $ n = sizeof ( $ arr ) ; echo ( getOddOccurrence ( $ arr , $ n ) ) ; ? >"}
{"text": "Kira bilangan bit yang akan dibalik untuk menukar A ke B | Fungsi yang mengira bit set; Fungsi yang dikembalikan kiraan nombor terbalik; Kembali kiraan bit set dalam XOR B; Kod pemacu", "code": "< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += 1 ; $ n &= ( n - 1 ) ; } return $ count ; } function FlippedCount ( $ a , $ b ) { return countSetBits ( $ a ^ $ b ) ; } $ a = 10 ; $ b = 20 ; echo FlippedCount ( $ a , $ b ) ; ? >"}
{"text": "Kedudukan Bit Set Bit | Kod PHP untuk kedudukan bit set kanan; Kod pemacu", "code": "< ? php function getFirstSetBitPos ( $ n ) { return ceil ( log ( ( $ n & - $ n ) + 1 , 2 ) ) ; } $ n = 12 ; echo getFirstSetBitPos ( $ n ) ; ? >"}
{"text": "Kedudukan Bit Set Bit | berfungsi untuk mencari bit set paling kanan; Pemboleh ubah kedudukan yang dimulakan dengan pembolehubah 1 m digunakan untuk memeriksa bit set; peralihan kiri; Kod pemacu; panggilan fungsi", "code": "< ? php function PositionRightmostSetbit ( $ n ) { $ position = 1 ; $ m = 1 ; while ( ! ( $ n & $ m ) ) { $ m = $ m << 1 ; $ position ++ ; } return $ position ; } $ n = 16 ; echo PositionRightmostSetbit ( $ n ) ; ? >"}
{"text": "Kedudukan Bit Set Bit | Pelaksanaan PHP pendekatan di atas; Mengira kedudukan bit set pertama; Kod pemacu", "code": "< ? php function Right_most_setbit ( $ num ) { $ pos = 1 ; $ INT_SIZE = 32 ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) { if ( ! ( $ num & ( 1 << $ i ) ) ) $ pos ++ ; else break ; } return $ pos ; } $ num = 18 ; $ pos = Right_most_setbit ( $ num ) ; echo $ pos ; echo ( \" STRNEWLINE \" ) ? >"}
{"text": "Perwakilan binari nombor tertentu | Berfungsi untuk menukar perpuluhan kepada nombor binari; Kod pemacu", "code": "< ? php function bin ( $ n ) { if ( $ n > 1 ) bin ( $ n >> 1 ) ; echo ( $ n & 1 ) ; } bin ( 131 ) ; echo \" STRNEWLINE \" ; bin ( 3 ) ;"}
{"text": "Tukar semua ganjil dan juga bit | Berfungsi untuk menukar bit walaupun dan ganjil; Dapatkan semua bit x; Dapatkan semua bit ganjil X; Peralihan kanan walaupun bit; Shift kiri bit ganjil; Menggabungkan bit walaupun dan ganjil; 00010111; Output adalah 43 (00101011)", "code": "< ? php function swapBits ( $ x ) { $ even_bits = $ x & 0xAAAAAAAA ; $ odd_bits = $ x & 0x55555555 ; $ even_bits >>= 1 ; $ odd_bits <<= 1 ; return ( $ even_bits $ odd_bits ) ; } $ x = 23 ; echo swapBits ( $ x ) ; ? >"}
{"text": "Cari kedudukan satu -satunya set bit | Fungsi utiliti untuk memeriksa sama ada n adalah kuasa 2 atau goo. gl / 17 arj tidak. Lihat http :; Mengembalikan kedudukan satu -satunya set bit dalam 'n'; Melangkah melalui bit n sehingga kita dapati set bit i & n akan bukan sifar hanya apabila 'i' dan 'n' mempunyai bit set pada kedudukan yang sama; Bit semasa yang tidak tersendiri dan tetapkan bit seterusnya dalam 'I'; kedudukan kenaikan; Kod pemacu", "code": "< ? php function isPowerOfTwo ( $ n ) { return $ n && ( ! ( $ n & ( $ n - 1 ) ) ) ; } function findPosition ( $ n ) { if ( ! isPowerOfTwo ( $ n ) ) return -1 ; $ i = 1 ; $ pos = 1 ; while ( ! ( $ i & $ n ) ) { $ i = $ i << 1 ; ++ $ pos ; } return $ pos ; } $ n = 16 ; $ pos = findPosition ( $ n ) ; if ( ( $ pos == -1 ) == true ) echo \" n = \" , ▁ $ n , ▁ \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Invalid number \" , ▁ \" \" ; STRNEWLINE else STRNEWLINE TABSYMBOL TABSYMBOL echo ▁ \" n = \" , ▁ $ n , ▁ \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Position \" , ▁ $ pos , ▁ \" \" $ n = 12 ; $ pos = findPosition ( $ n ) ; if ( ( $ pos == -1 ) == true ) echo \" n = \" , ▁ $ n , ▁ \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Invalid number \" , ▁ \" \" ; STRNEWLINE else STRNEWLINE TABSYMBOL TABSYMBOL echo ▁ \" n = \" , ▁ $ n , ▁ \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Position \" , ▁ $ pos , ▁ \" \" $ n = 128 ; $ pos = findPosition ( $ n ) ; if ( ( $ pos == -1 ) == true ) echo \" n = \" , ▁ $ n , ▁ \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Invalid number \" , ▁ \" \" ; STRNEWLINE else STRNEWLINE TABSYMBOL TABSYMBOL echo ▁ \" n = \" , ▁ $ n , ▁ \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Position \" , ▁ $ pos , ▁ \" \" ? >"}
{"text": "Cari kedudukan satu -satunya set bit | Fungsi utiliti untuk memeriksa sama ada n adalah kuasa 2 atau tidak; Mengembalikan kedudukan satu -satunya set bit dalam 'n'; Satu demi satu bergerak satu -satunya set bit ke kanan sehingga ia mencapai akhir; kiraan kenaikan peralihan; Kod pemacu", "code": "< ? php function isPowerOfTwo ( $ n ) { return $ n && ( ! ( $ n & ( $ n - 1 ) ) ) ; } function findPosition ( $ n ) { if ( ! isPowerOfTwo ( $ n ) ) return -1 ; $ count = 0 ; while ( $ n ) { $ n = $ n >> 1 ; ++ $ count ; } return $ count ; } $ n = 0 ; $ pos = findPosition ( $ n ) ; if ( ( $ pos == -1 ) == true ) echo \" n = \" , ▁ $ n , ▁ \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL \" Invalid number \" , ▁ \" \" ; STRNEWLINE else STRNEWLINE TABSYMBOL echo ▁ \" n = \" , ▁ $ n , ▁ \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL \" Position \" , ▁ $ pos , ▁ \" \" $ n = 12 ; $ pos = findPosition ( $ n ) ; if ( ( $ pos == -1 ) == true ) echo \" n = \" , ▁ $ n , ▁ \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Invalid number \" , ▁ \" \" ; STRNEWLINE else STRNEWLINE TABSYMBOL TABSYMBOL echo ▁ \" n = \" , ▁ $ n , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Position \" , ▁ $ pos , ▁ \" \" $ n = 128 ; $ pos = findPosition ( $ n ) ; if ( ( $ pos == -1 ) == true ) echo \" n = \" , ▁ $ n , ▁ \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Invalid number \" , ▁ \" \" ; STRNEWLINE else STRNEWLINE TABSYMBOL TABSYMBOL echo ▁ \" n = \" , ▁ $ n , ▁ \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Position \" , ▁ $ pos , ▁ \" \" ? >"}
{"text": "Bagaimana cara menukar dua nombor tanpa menggunakan pemboleh ubah sementara? | Kod pemacu; Kod untuk menukar 'x' dan 'y' x kini menjadi 50; y menjadi 10; x menjadi 5", "code": "< ? php $ x = 10 ; $ y = 5 ; $ x = $ x * $ y ; $ y = $ x / $ y ; $ x = $ x / $ y ; echo \" After ▁ Swapping : ▁ x ▁ = ▁ \" , $ x , \" ▁ \" , \" y ▁ = ▁ \" , $ y ; ? >"}
{"text": "Bagaimana cara menukar dua nombor tanpa menggunakan pemboleh ubah sementara? | Kod PHP untuk menukar menggunakan XOR; Kod untuk menukar 'x' (1010) dan 'y' (0101) x kini menjadi 15 (1111); y menjadi 10 (1010); x menjadi 5 (0101)", "code": "< ? php $ x = 10 ; $ y = 5 ; $ x = $ x ^ $ y ; $ y = $ x ^ $ y ; $ x = $ x ^ $ y ; echo \" After ▁ Swapping : ▁ x ▁ = ▁ \" , $ x , \" , ▁ \" , \" y ▁ = ▁ \" , $ y ; ? >"}
{"text": "Bagaimana cara menukar dua nombor tanpa menggunakan pemboleh ubah sementara? | Fungsi swap; Kod pemacu", "code": "< ? php function swap ( & $ xp , & $ yp ) { $ xp = $ xp ^ $ yp ; $ yp = $ xp ^ $ yp ; $ xp = $ xp ^ $ yp ; } $ x = 10 ; swap ( $ x , $ x ) ; print ( \" After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ \" . $ x ) ; ? >"}
{"text": "Cari indeks 0 untuk digantikan dengan 1 untuk mendapatkan urutan berterusan paling lama 1 s dalam array binari | Indeks pulangan 0 untuk digantikan dengan 1 untuk mendapatkan urutan berterusan paling lama 1 s. Jika tidak ada 0 dalam array, maka ia kembali - 1 .; untuk bilangan maksimum; 1 sekitar sifar untuk menyimpan hasil; Indeks sifar sebelumnya; Indeks sebelumnya ke; sifar sebelumnya melintasi array input; Jika elemen semasa adalah 0, maka hitung perbezaan antara curr dan prev_prev_zero; Hasil kemas kini jika kiraan 1 s sekitar prev_zero lebih banyak; Kemas kini untuk lelaran seterusnya; Semak sifar yang ditemui terakhir; Kod pemacu", "code": "< ? php function maxOnesIndex ( $ arr , $ n ) { $ max_count = 0 ; $ max_index ; $ prev_zero = -1 ; $ prev_prev_zero = -1 ; for ( $ curr = 0 ; $ curr < $ n ; ++ $ curr ) { if ( $ arr [ $ curr ] == 0 ) { if ( $ curr - $ prev_prev_zero > $ max_count ) { $ max_count = $ curr - $ prev_prev_zero ; $ max_index = $ prev_zero ; } $ prev_prev_zero = $ prev_zero ; $ prev_zero = $ curr ; } } if ( $ n - $ prev_prev_zero > $ max_count ) $ max_index = $ prev_zero ; return $ max_index ; } $ arr = array ( 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Index ▁ of ▁ 0 ▁ to ▁ be ▁ replaced ▁ is ▁ \" , maxOnesIndex ( $ arr , $ n ) ; ? >"}
{"text": "Panjang subarray terbesar dengan unsur -unsur bersebelahan | Tetapkan 1 | Fungsi utiliti untuk mencari minimum dan maksimum dua elemen; Mengembalikan panjang subarray bersebelahan terpanjang; Memulakan hasil; Inisialisasi min dan max untuk semua subarrays bermula dengan i; Pertimbangkan semua subarrays bermula dengan saya dan berakhir dengan j; Mengemas kini min dan max dalam subarray ini jika diperlukan; Jika subarray semasa mempunyai semua elemen bersebelahan; Hasil pulangan; Kod pemacu", "code": "< ? php function mins ( $ x , $ y ) { if ( $ x < $ y ) return $ x ; else return $ y ; } function maxi ( $ a , $ b ) { if ( $ a > $ b ) return $ a ; else return $ b ; } function findLength ( & $ arr , $ n ) { $ max_len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ mn = $ arr [ $ i ] ; $ mx = $ arr [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ mn = mins ( $ mn , $ arr [ $ j ] ) ; $ mx = maxi ( $ mx , $ arr [ $ j ] ) ; if ( ( $ mx - $ mn ) == $ j - $ i ) $ max_len = maxi ( $ max_len , $ mx - $ mn + 1 ) ; } } return $ max_len ; } $ arr = array ( 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 ) ; $ n = sizeof ( $ arr ) ; echo ( \" Length ▁ of ▁ the ▁ longest ▁ contiguous \" . \" ▁ subarray ▁ is ▁ \" ) ; echo ( findLength ( $ arr , $ n ) ) ; ? >"}
{"text": "Cetak semua urutan yang semakin meningkat dari K dari nombor semulajadi n Pertama | Fungsi utiliti untuk mencetak kandungan ARR [0 .. k - 1]; Fungsi rekursif untuk mencetak semua urutan yang semakin meningkat dari nombor semulajadi N yang pertama. Setiap urutan hendaklah panjang k. Array arr [] digunakan untuk menyimpan urutan semasa. ; Jika panjang urutan peningkatan semasa menjadi k, cetaknya; Tentukan nombor permulaan untuk dimasukkan ke dalam kedudukan semasa: Jika panjang adalah 0, maka tidak ada unsur -unsur sebelumnya dalam ARR []. Jadi mula meletakkan nombor baru dengan 1. Jika panjang tidak 0, maka mulakan dari nilai elemen sebelumnya ditambah 1 .; Peningkatan panjang; Letakkan semua nombor (yang lebih besar daripada elemen sebelumnya) pada kedudukan baru. ; Ini penting. Pembolehubah 'len' dikongsi di antara semua panggilan fungsi dalam pokok rekursi. Nilainya mesti dibawa kembali sebelum lelaran seterusnya semasa gelung; Fungsi ini mencetak semua urutan yang semakin meningkat dari nombor semulajadi N yang pertama. Panjang setiap urutan mestilah k. Fungsi ini terutamanya menggunakan printsequtil (); Array untuk menyimpan urutan individu panjang awal; urutan semasa; Kod pemacu", "code": "< ? php function printArr ( $ arr , $ k ) { for ( $ i = 0 ; $ i < $ k ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; echo \" STRNEWLINE \" ; } function printSeqUtil ( $ n , $ k , $ len , $ arr ) { if ( $ len == $ k ) { printArr ( $ arr , $ k ) ; return ; } $ i = ( $ len == 0 ) ? 1 : $ arr [ $ len - 1 ] + 1 ; $ len ++ ; while ( $ i <= $ n ) { $ arr [ $ len - 1 ] = $ i ; printSeqUtil ( $ n , $ k , $ len , $ arr ) ; $ i ++ ; } $ len -- ; } function printSeq ( $ n , $ k ) { $ arr = array ( ) ; $ len = 0 ; printSeqUtil ( $ n , $ k , $ len , $ arr ) ; } $ k = 3 ; $ n = 7 ; printSeq ( $ n , $ k ) ; ? >"}
{"text": "Memandangkan dua rentetan, cari jika rentetan pertama adalah seterusnya kedua | Pulangan benar jika str1 [] adalah seterusnya STR2 []. m adalah panjang str1 dan n ialah panjang str2; Kes asas; Jika watak terakhir dua rentetan sepadan; Sekiranya watak terakhir tidak sepadan; Kod pemacu", "code": "< ? php function isSubSequence ( $ str1 , $ str2 , $ m , $ n ) { if ( $ m == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ str1 [ $ m - 1 ] == $ str2 [ $ n - 1 ] ) return isSubSequence ( $ str1 , $ str2 , $ m - 1 , $ n - 1 ) ; return isSubSequence ( $ str1 , $ str2 , $ m , $ n - 1 ) ; } $ str1 = \" gksrek \" ; $ str2 = \" geeksforgeeks \" ; $ m = strlen ( $ str1 ) ; $ n = strlen ( $ str2 ) ; $ t = isSubSequence ( $ str1 , $ str2 , $ m , $ n ) ? \" Yes ▁ \" : \" No \" ; if ( $ t = true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Gantikan setiap elemen dengan elemen terbesar di sebelah kanan | Berfungsi untuk menggantikan setiap elemen dengan elemen terbesar seterusnya; Memulakan elemen terbesar seterusnya; Elemen terbesar seterusnya untuk elemen paling kanan adalah sentiasa - 1; Menggantikan semua elemen lain dengan yang paling besar; Simpan elemen semasa (diperlukan kemudian untuk mengemas kini elemen terbesar seterusnya); Menggantikan elemen semasa dengan yang paling besar seterusnya; Mengemas kini elemen terbesar, jika diperlukan; Fungsi utiliti yang mencetak array; Kod pemacu", "code": "< ? php function nextGreatest ( & $ arr , $ size ) { $ max_from_right = $ arr [ $ size - 1 ] ; $ arr [ $ size - 1 ] = -1 ; for ( $ i = $ size - 2 ; $ i >= 0 ; $ i -- ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ max_from_right ; if ( $ max_from_right < $ temp ) $ max_from_right = $ temp ; } } function printArray ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 16 , 17 , 4 , 3 , 5 , 2 ) ; $ size = count ( $ arr ) ; nextGreatest ( $ arr , $ size ) ; echo \" The ▁ modified ▁ array ▁ is : ▁ STRNEWLINE \" ; printArray ( $ arr , $ size ) ; ? >"}
{"text": "Pembinaan Susunan Terpanjang (N Log N) | Carian binari; Tambah kes sempadan, apabila array n adalah sifar bergantung kepada penunjuk pintar; diasaskan dengan - 1; Ia akan sentiasa menunjuk ke lokasi kosong; Nilai terkecil baru; Arr [i] mahu melanjutkan seterusnya; ARR [i] mahu menjadi potensi yang berpotensi untuk masa depan ia akan menggantikan nilai ceil dalam tailindices; Kod pemacu", "code": "< ? php function GetCeilIndex ( $ arr , $ T , $ l , $ r , $ key ) { while ( $ r - $ l > 1 ) { $ m = ( int ) ( $ l + ( $ r - $ l ) / 2 ) ; if ( $ arr [ $ T [ $ m ] ] >= $ key ) $ r = $ m ; else $ l = $ m ; } return $ r ; } function LongestIncreasingSubsequence ( $ arr , $ n ) { $ tailIndices = array_fill ( 0 , $ n + 1 , 0 ) ; $ prevIndices = array_fill ( 0 , $ n + 1 , -1 ) ; $ len = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ arr [ $ tailIndices [ 0 ] ] ) { $ tailIndices [ 0 ] = $ i ; } else if ( $ arr [ $ i ] > $ arr [ $ tailIndices [ $ len - 1 ] ] ) { $ prevIndices [ $ i ] = $ tailIndices [ $ len - 1 ] ; $ tailIndices [ $ len ++ ] = $ i ; } else { $ pos = GetCeilIndex ( $ arr , $ tailIndices , -1 , $ len - 1 , $ arr [ $ i ] ) ; $ prevIndices [ $ i ] = $ tailIndices [ $ pos - 1 ] ; $ tailIndices [ $ pos ] = $ i ; } } echo \" LIS ▁ of ▁ given ▁ input STRNEWLINE \" ; for ( $ i = $ tailIndices [ $ len - 1 ] ; $ i >= 0 ; $ i = $ prevIndices [ $ i ] ) echo $ arr [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; return $ len ; } $ arr = array ( 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 ) ; $ n = count ( $ arr ) ; print ( \" LIS ▁ size ▁ \" . LongestIncreasingSubsequence ( $ arr , $ n ) ) ; ? >"}
{"text": "Menjana semua susunan yang disusun dari elemen alternatif dua tatasusunan disusun yang diberikan | Fungsi untuk menjana dan mencetak semua tatasusunan yang disusun dari elemen alternatif 'a [i. . m - 1] 'dan' b [j. . n - 1] 'Jika' bendera 'adalah benar, maka elemen semasa dimasukkan dari sebaliknya dari b. 'len' adalah indeks dalam array output c []. Kami mencetak array output setiap kali sebelum memasukkan watak dari hanya jika panjang output array lebih besar daripada 0. Kami cuba daripada semua kombinasi yang mungkin; Sertakan elemen yang sah dari A; Cetak output jika terdapat sekurang -kurangnya satu 'b' dalam array output 'c'; Berulang untuk semua elemen A selepas indeks semasa; Blok ini berfungsi untuk panggilan pertama untuk memasukkan elemen pertama dalam array output; Don 't kenaikan lem sebagai b dimasukkan lagi; termasuk elemen yang sah dari A dan Recur; Termasuk elemen yang sah dari B dan Recur; Fungsi pembalut; pelbagai output; Fungsi utiliti untuk mencetak array; Kod pemacu", "code": "< ? php function generateUtil ( & $ A , & $ B , & $ C , $ i , $ j , $ m , $ n , $ len , $ flag ) { if ( $ flag ) { if ( $ len ) printArr ( $ C , $ len + 1 ) ; for ( $ k = $ i ; $ k < $ m ; $ k ++ ) { if ( ! $ len ) { $ C [ $ len ] = $ A [ $ k ] ; generateUtil ( $ A , $ B , $ C , $ k + 1 , $ j , $ m , $ n , $ len , ! $ flag ) ; } else { if ( $ A [ $ k ] > $ C [ $ len ] ) { $ C [ $ len + 1 ] = $ A [ $ k ] ; generateUtil ( $ A , $ B , $ C , $ k + 1 , $ j , $ m , $ n , $ len + 1 , ! $ flag ) ; } } } } else { for ( $ l = $ j ; $ l < $ n ; $ l ++ ) { if ( $ B [ $ l ] > $ C [ $ len ] ) { $ C [ $ len + 1 ] = $ B [ $ l ] ; generateUtil ( $ A , $ B , $ C , $ i , $ l + 1 , $ m , $ n , $ len + 1 , ! $ flag ) ; } } } } function generate ( & $ A , & $ B , $ m , $ n ) { $ C = array_fill ( 0 , ( $ m + $ n ) , NULL ) ; generateUtil ( $ A , $ B , $ C , 0 , 0 , $ m , $ n , 0 , true ) ; } function printArr ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } $ A = array ( 10 , 15 , 25 ) ; $ B = array ( 5 , 20 , 30 ) ; $ n = sizeof ( $ A ) ; $ m = sizeof ( $ B ) ; generate ( $ A , $ B , $ n , $ m ) ; ? >"}
{"text": "Gantikan dua nilai sama berturut -turut dengan satu lebih besar | Berfungsi untuk menggantikan elemen yang sama berturut -turut; Indeks hasil; untuk mencetak array baru; Kod pemacu", "code": "< ? php function replace_elements ( $ arr , $ n ) { $ pos = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ pos ++ ] = $ arr [ $ i ] ; while ( $ pos > 1 && $ arr [ $ pos - 2 ] == $ arr [ $ pos - 1 ] ) { $ pos -- ; $ arr [ $ pos - 1 ] ++ ; } } for ( $ i = 0 ; $ i < $ pos ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } $ arr = array ( 6 , 4 , 3 , 4 , 3 , 3 , 5 ) ; $ n = count ( $ arr ) ; replace_elements ( $ arr , $ n ) ; ? >"}
{"text": "Susun semula rentetan binari sebagai alternatif x dan y kejadian | Fungsi yang mengatur rentetan yang diberikan; Mengira nombor 0 dan ~ 1 dalam rentetan yang diberikan. ; Percetakan Pertama semua 0 's u -masa dan »pengurangan» u u u u u u u u u' dan melakukan tugas yang sama dengan '1'; Kod pemacu", "code": "< ? php function arrangeString ( $ str , $ x , $ y ) { $ count_0 = 0 ; $ count_1 = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) $ count_0 ++ ; else $ count_1 ++ ; } while ( $ count_0 > 0 $ count_1 > 0 ) { for ( $ j = 0 ; $ j < $ x && $ count_0 > 0 ; $ j ++ ) { if ( $ count_0 > 0 ) { echo \"0\" ; $ count_0 -- ; } } for ( $ j = 0 ; $ j < $ y && $ count_1 > 0 ; $ j ++ ) { if ( $ count_1 > 0 ) { echo \"1\" ; $ count_1 -- ; } } } } $ str = \"01101101101101101000000\" ; $ x = 1 ; $ y = 2 ; arrangeString ( $ str , $ x , $ y ) ; ? >"}
{"text": "Shuffle 2 n bilangan bulat sebagai a1 | berfungsi untuk menyusun semula array; Jika saiz adalah null atau pulangan yang ganjil kerana tidak mungkin untuk menyusun semula; bermula dari indeks tengah; Setiap kali kita akan menetapkan dua elemen dari permulaan ke kedudukan yang sah dengan menukar; Kod pemacu", "code": "< ? php function rearrange ( & $ arr , $ n ) { if ( $ arr == NULL $ n % 2 == 1 ) return ; $ currIdx = intval ( ( $ n - 1 ) / 2 ) ; while ( $ currIdx > 0 ) { $ count = $ currIdx ; $ swapIdx = $ currIdx ; while ( $ count -- > 0 ) { $ temp = $ arr [ $ swapIdx + 1 ] ; $ arr [ $ swapIdx + 1 ] = $ arr [ $ swapIdx ] ; $ arr [ $ swapIdx ] = $ temp ; $ swapIdx ++ ; } $ currIdx -- ; } } $ arr = array ( 1 , 3 , 5 , 2 , 4 , 6 ) ; $ n = count ( $ arr ) ; rearrange ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ $ i ] . \" ▁ \" ) ; ? >"}
{"text": "Perbezaan maksimum antara dua elemen sehingga elemen yang lebih besar muncul selepas nombor yang lebih kecil | Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya dua elemen dalam array. Fungsi ini mengembalikan nilai negatif jika array disusun dalam penurunan urutan dan pulangan 0 jika elemen adalah sama; Kod pemacu; Fungsi panggilan", "code": "< ? php function maxDiff ( $ arr , $ arr_size ) { $ max_diff = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ arr_size ; $ j ++ ) { if ( $ arr [ $ j ] - $ arr [ $ i ] > $ max_diff ) $ max_diff = $ arr [ $ j ] - $ arr [ $ i ] ; } } return $ max_diff ; } $ arr = array ( 1 , 2 , 90 , 10 , 110 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum ▁ difference ▁ is ▁ \" . maxDiff ( $ arr , $ n ) ;"}
{"text": "Perbezaan maksimum antara dua elemen sehingga elemen yang lebih besar muncul selepas nombor yang lebih kecil | Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya dua elemen dalam array. Fungsi ini mengembalikan nilai negatif jika array disusun dalam penurunan urutan dan pulangan 0 jika elemen adalah sama; Memulakan hasil; Memulakan elemen max dari sebelah kanan; Kod pemacu; Fungsi panggilan", "code": "< ? php function maxDiff ( $ arr , $ n ) { $ maxDiff = -1 ; $ maxRight = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] > $ maxRight ) $ maxRight = $ arr [ $ i ] ; else { $ diff = $ maxRight - $ arr [ $ i ] ; if ( $ diff > $ maxDiff ) { $ maxDiff = $ diff ; } } } return $ maxDiff ; } $ arr = array ( 1 , 2 , 90 , 10 , 110 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum ▁ difference ▁ is ▁ \" , maxDiff ( $ arr , $ n ) ; ? >"}
{"text": "Perbezaan maksimum antara dua elemen sehingga elemen yang lebih besar muncul selepas nombor yang lebih kecil | Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya dua elemen dalam array. Fungsi ini mengembalikan nilai negatif jika array disusun dalam penurunan urutan dan pulangan 0 jika elemen adalah sama; Inisialisasi diff, jumlah semasa dan jumlah maksimum; Mengira perbezaan semasa; Hitung jumlah semasa; Kemas kini jumlah max, jika diperlukan; Kod pemacu; Fungsi panggilan", "code": "< ? php function maxDiff ( $ arr , $ n ) { $ diff = $ arr [ 1 ] - $ arr [ 0 ] ; $ curr_sum = $ diff ; $ max_sum = $ curr_sum ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ diff = $ arr [ $ i + 1 ] - $ arr [ $ i ] ; if ( $ curr_sum > 0 ) $ curr_sum += $ diff ; else $ curr_sum = $ diff ; if ( $ curr_sum > $ max_sum ) $ max_sum = $ curr_sum ; } return $ max_sum ; } $ arr = array ( 80 , 2 , 6 , 3 , 100 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum ▁ difference ▁ is ▁ \" , maxDiff ( $ arr , $ n ) ; ? >"}
{"text": "Cari elemen maksimum dalam array yang mula -mula meningkat dan kemudian berkurangan | Program PHP untuk mencari elemen maksimum dalam array yang mula -mula meningkat dan kemudian menurun; Kod pemacu", "code": "< ? php function findMaximum ( $ arr , $ low , $ high ) { $ max = $ arr [ $ low ] ; $ i ; for ( $ i = $ low ; $ i <= $ high ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; } return $ max ; } $ arr = array ( 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 ) ; $ n = count ( $ arr ) ; echo \" The ▁ maximum ▁ element ▁ is ▁ \" , findMaximum ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text": "Cari elemen maksimum dalam array yang mula -mula meningkat dan kemudian berkurangan | Program PHP untuk mencari elemen maksimum dalam array yang mula -mula meningkat dan kemudian menurun; Kes asas: Hanya satu elemen yang terdapat dalam ARR [rendah. . tinggi]; Sekiranya terdapat dua elemen dan pertama lebih besar maka elemen pertama adalah maksimum; Sekiranya terdapat dua elemen dan kedua adalah lebih besar maka elemen kedua adalah maksimum; Jika kita mencapai titik di mana arr [pertengahan] lebih besar daripada kedua -dua unsur -unsur bersebelahannya arr [pertengahan - 1] dan arr [pertengahan + 1], maka arr [mid] adalah elemen maksimum; Jika arr [pertengahan] lebih besar daripada elemen seterusnya dan lebih kecil daripada elemen sebelumnya maka maksimum terletak di sebelah kiri pertengahan; apabila arr [pertengahan] lebih besar daripada arr [pertengahan - 1] dan lebih kecil daripada arr [pertengahan + 1]; Kod pemacu", "code": "< ? php function findMaximum ( $ arr , $ low , $ high ) { if ( $ low == $ high ) return $ arr [ $ low ] ; if ( ( $ high == $ low + 1 ) && $ arr [ $ low ] >= $ arr [ $ high ] ) return $ arr [ $ low ] ; if ( ( $ high == $ low + 1 ) && $ arr [ $ low ] < $ arr [ $ high ] ) return $ arr [ $ high ] ; $ mid = ( $ low + $ high ) / 2 ; if ( $ arr [ $ mid ] > $ arr [ $ mid + 1 ] && $ arr [ $ mid ] > $ arr [ $ mid - 1 ] ) return $ arr [ $ mid ] ; if ( $ arr [ $ mid ] > $ arr [ $ mid + 1 ] && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return findMaximum ( $ arr , $ low , $ mid - 1 ) ; else return findMaximum ( $ arr , $ mid + 1 , $ high ) ; } $ arr = array ( 1 , 3 , 50 , 10 , 9 , 7 , 6 ) ; $ n = sizeof ( $ arr ) ; echo ( \" The ▁ maximum ▁ element ▁ is ▁ \" ) ; echo ( findMaximum ( $ arr , 0 , $ n -1 ) ) ; ? >"}
{"text": "Laluan Jumlah Maksimum dalam Dua Array | Fungsi ini mengembalikan jumlah elemen pada jalan maksimum dari awal hingga akhir; memulakan indeks untuk AR1 [] dan AR2 []; Memulakan hasil dan jumlah semasa melalui AR1 [] dan AR2 []. ; Di bawah 3 gelung adalah serupa dengan gabungan dalam gabungan; Tambah unsur -unsur AR1 [] ke SUM1; Tambah unsur -unsur AR2 [] ke SUM2; Kami mencapai titik yang sama; Ambil maksimum dua jumlah dan tambah hasil juga menambah elemen biasa array, sekali; Kemas kini SUM1 dan SUM2 untuk unsur -unsur selepas titik persimpangan ini; Kemas kini I dan J untuk berpindah ke elemen seterusnya setiap array; Tambah elemen yang tinggal dari AR1 []; Tambah elemen yang tinggal dari AR2 []; Tambah maksimum dua jumlah elemen yang tinggal; Kod pemacu; Panggilan fungsi", "code": "< ? php function maxPathSum ( $ ar1 , $ ar2 , $ m , $ n ) { $ i = 0 ; $ j = 0 ; $ result = 0 ; $ sum1 = 0 ; $ sum2 = 0 ; while ( $ i < $ m and $ j < $ n ) { if ( $ ar1 [ $ i ] < $ ar2 [ $ j ] ) $ sum1 += $ ar1 [ $ i ++ ] ; else if ( $ ar1 [ $ i ] > $ ar2 [ $ j ] ) $ sum2 += $ ar2 [ $ j ++ ] ; else { $ result += max ( $ sum1 , $ sum2 ) + $ ar1 [ $ i ] ; $ sum1 = 0 ; $ sum2 = 0 ; $ i ++ ; $ j ++ ; } } while ( $ i < $ m ) $ sum1 += $ ar1 [ $ i ++ ] ; while ( $ j < $ n ) $ sum2 += $ ar2 [ $ j ++ ] ; $ result += max ( $ sum1 , $ sum2 ) ; return $ result ; } $ ar1 = array ( 2 , 3 , 7 , 10 , 12 , 15 , 30 , 34 ) ; $ ar2 = array ( 1 , 5 , 7 , 8 , 10 , 15 , 16 , 19 ) ; $ m = count ( $ ar1 ) ; $ n = count ( $ ar2 ) ; echo \" Maximum ▁ sum ▁ path ▁ is ▁ \" , maxPathSum ( $ ar1 , $ ar2 , $ m , $ n ) ; ? >"}
{"text": "Unsur -unsur yang paling kecil dalam keseluruhan array | Program PHP mudah untuk mencari elemen yang paling kecil dalam keseluruhan array untuk setiap elemen. ; Cari elemen yang paling dekat untuk arr [J] dalam keseluruhan array. ; Semak jika Arr [i] adalah yang terbesar; Kod pemacu", "code": "< ? php function smallestGreater ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ diff = PHP_INT_MAX ; $ closest = -1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] && $ arr [ $ j ] - $ arr [ $ i ] < $ diff ) { $ diff = $ arr [ $ j ] - $ arr [ $ i ] ; $ closest = $ j ; } } if ( $ closest == -1 ) echo \" _ ▁ \" ; else echo $ arr [ $ closest ] , \" ▁ \" ; } } $ ar = array ( 6 , 3 , 9 , 8 , 10 , 2 , 1 , 15 , 7 ) ; $ n = sizeof ( $ ar ) ; smallestGreater ( $ ar , $ n ) ; ? >"}
{"text": "Cari sifar untuk dibalik supaya bilangan 1 berturut -turut dimaksimumkan | m adalah maksimum bilangan sifar yang dibenarkan untuk flip n adalah saiz array; Indeks kiri dan kanan tetingkap semasa; Indeks kiri dan saiz tetingkap terluas; Count sifar dalam tetingkap semasa; Manakala sempadan kanan tetingkap semasa tidak menyeberang kanan; Jika kiraan sifar tetingkap semasa kurang daripada m, melebarkan tetingkap ke arah kanan; Jika kiraan sifar tetingkap semasa lebih daripada m, kurangkan tetingkap dari kiri; Tetingkap WILE UpdQate jika saiz tetingkap ini lebih banyak; Cetak kedudukan sifar dalam tetingkap terluas; Kod pemacu", "code": "< ? php function findZeroes ( $ arr , $ n , $ m ) { $ wL = 0 ; $ wR = 0 ; $ bestL = 0 ; $ bestWindow = 0 ; $ zeroCount = 0 ; while ( $ wR < $ n ) { if ( $ zeroCount <= $ m ) { if ( $ arr [ $ wR ] == 0 ) $ zeroCount ++ ; $ wR ++ ; } if ( $ zeroCount > $ m ) { if ( $ arr [ $ wL ] == 0 ) $ zeroCount -- ; $ wL ++ ; } if ( ( $ wR - $ wL > $ bestWindow ) && ( $ zeroCount <= $ m ) ) { $ bestWindow = $ wR - $ wL ; $ bestL = $ wL ; } } for ( $ i = 0 ; $ i < $ bestWindow ; $ i ++ ) { if ( $ arr [ $ bestL + $ i ] == 0 ) echo $ bestL + $ i . \" ▁ \" ; } } $ arr = array ( 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 ) ; $ m = 2 ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo \" Indexes ▁ of ▁ zeroes ▁ to ▁ be ▁ flipped ▁ are ▁ \" ; findZeroes ( $ arr , $ n , $ m ) ; return 0 ; ? >"}
{"text": "Mengira Subarrays Meningkatkan Segera | Program PHP untuk mengira bilangan subarray yang ketat; Memulakan kiraan subarrays sebagai 0; Pilih titik permulaan; Memilih titik akhir; Jika subarray arr [i. . J] tidak meningkat dengan ketat, kemudian subarrays selepas itu, i. e. , arr [i. . J + 1], arr [i. . J + 2], .... tidak boleh meningkat dengan ketat; Program Pemandu", "code": "< ? php function countIncreasing ( $ arr , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] > $ arr [ $ j - 1 ] ) $ cnt ++ ; else break ; } } return $ cnt ; } $ arr = array ( 1 , 2 , 2 , 4 ) ; $ n = count ( $ arr ) ; echo \" Count ▁ of ▁ strictly ▁ increasing ▁ \" , \" subarrays ▁ is ▁ \" , countIncreasing ( $ arr , $ n ) ; ? >"}
{"text": "Mengira Subarrays Meningkatkan Segera | Program PHP untuk mengira bilangan subarray yang ketat dalam masa O (n). ; Memulakan hasil; Memulakan panjang subarray peningkatan semasa; Melintasi array; Jika arr [i + 1] lebih besar daripada arr [i], maka panjang kenaikan; Lain mengemas kini kiraan dan set semula; Jika panjang terakhir adalah lebih daripada 1; Kod pemacu", "code": "< ? php function countIncreasing ( $ arr , $ n ) { $ cnt = 0 ; $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ arr [ $ i + 1 ] > $ arr [ $ i ] ) $ len ++ ; else { $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; return $ cnt ; } $ arr = array ( 1 , 2 , 2 , 4 ) ; $ n = count ( $ arr ) ; echo \" Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is ▁ \" , countIncreasing ( $ arr , $ n ) ; ? >"}
{"text": "Perbezaan maksimum antara kumpulan k | fungsi utiliti untuk jumlah array; fungsi untuk mencari perbezaan kumpulan maksimum array; Susun array; Cari jumlah array; perbezaan untuk k - terkecil diff1 = (arraysum - k_smallest) - k_smallest; Arahan terbalik untuk mencari jumlah 0f 1 st k - terbesar; perbezaan untuk K - terbesar diff2 = (arraysum - k_largest) - k_largest; mengembalikan nilai perbezaan maksimum; Kod pemacu", "code": "< ? php function arraySum ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + $ arr [ $ i ] ; return $ sum ; } function maxDiff ( $ arr , $ n , $ k ) { sort ( $ arr ) ; $ arraysum = arraySum ( $ arr , $ n ) ; $ diff1 = abs ( $ arraysum - 2 * arraySum ( $ arr , $ k ) ) ; array_reverse ( $ arr ) ; $ diff2 = abs ( $ arraysum - 2 * arraySum ( $ arr , $ k ) ) ; return ( max ( $ diff1 , $ diff2 ) ) ; } $ arr = array ( 1 , 7 , 4 , 8 , -1 , 5 , 2 , 1 ) ; $ n = count ( $ arr ) ; $ k = 3 ; echo \" Maximum ▁ Difference ▁ = ▁ \" , maxDiff ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Bilangan elemen minimum untuk ditambah untuk membuat median sama dengan x | Mengembalikan kiraan elemen yang akan ditambah untuk membuat median x. Fungsi ini mengandaikan bahawa [] mempunyai ruang tambahan yang cukup. ; untuk menyusun array dalam peningkatan urutan. ; Kod pemacu", "code": "< ? php function minNumber ( $ a , $ n , $ x ) { sort ( $ a ) ; $ k ; for ( $ k = 0 ; $ a [ ( $ n - 1 ) / 2 ] != $ x ; $ k ++ ) { $ a [ $ n ++ ] = $ x ; sort ( $ a ) ; } return $ k ; } $ x = 10 ; $ a = array ( 10 , 20 , 30 ) ; $ n = 3 ; echo minNumber ( $ a , $ n , $ x ) , \" STRNEWLINE \" ; ? >"}
{"text": "Bilangan elemen minimum untuk ditambah untuk membuat median sama dengan x | Program PHP untuk mencari bilangan elemen minimum untuk ditambah supaya mediannya sama dengan x. ; tidak. unsur sama dengan x, iaitu, e. ; tidak. unsur -unsur yang lebih besar daripada x, iaitu, h. ; tidak. unsur -unsur yang lebih kecil daripada x, iaitu, l. ; tolak no. unsur -unsur yang sama dengan x. ; Kod pemacu", "code": "< ? php function minNumber ( $ a , $ n , $ x ) { $ l = 0 ; $ h = 0 ; $ e = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ x ) $ e ++ ; else if ( $ a [ $ i ] > $ x ) $ h ++ ; else if ( $ a [ $ i ] < $ x ) $ l ++ ; } $ ans = 0 ; if ( $ l > $ h ) $ ans = $ l - $ h ; else if ( $ l < $ h ) $ ans = $ h - $ l - 1 ; return $ ans + 1 - $ e ; } $ x = 10 ; $ a = array ( 10 , 20 , 30 ) ; $ n = sizeof ( $ a ) ; echo minNumber ( $ a , $ n , $ x ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak array binari nombor yang diwakili oleh subarray adalah ganjil atau bahkan | cetakan jika subarray adalah atau ganjil; jika arr [r] = 1 cetak ganjil; jika arr [r] = 0 cetak walaupun; Kod pemacu", "code": "< ? php function checkEVENodd ( $ arr , $ n , $ l , $ r ) { if ( $ arr [ $ r ] == 1 ) echo \" odd \" , \" STRNEWLINE \" ; else echo \" even \" , \" STRNEWLINE \" ; } $ arr = array ( 1 , 1 , 0 , 1 ) ; $ n = sizeof ( $ arr ) ; checkEVENodd ( $ arr , $ n , 1 , 3 ) ; ? >"}
{"text": "Purata julat dalam array | Untuk mencari min dalam l dalam l ke r; Kedua -dua jumlah dan kiraan adalah permulaan kepada 0; Untuk mengira jumlah dan bilangan elemen dalam julat L hingga R; Hitung nilai lantai min; Pulangan bermakna array dalam julat L ke r; Kod pemacu", "code": "< ? php function findMean ( $ arr , $ l , $ r ) { $ sum = 0 ; $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ count ++ ; } $ mean = floor ( $ sum / $ count ) ; return $ mean ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; echo findMean ( $ arr , 0 , 2 ) , \" STRNEWLINE \" ; echo findMean ( $ arr , 1 , 3 ) , \" STRNEWLINE \" ; echo findMean ( $ arr , 0 , 4 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Produk julat dalam array | Fungsi untuk mengira produk dalam julat yang diberikan. ; Oleh kerana array kami adalah 0 berdasarkan AS dan L dan R diberikan sebagai indeks berasaskan 1. ; Kod pemacu", "code": "< ? php function calculateProduct ( $ A , $ L , $ R , $ P ) { $ L = $ L - 1 ; $ R = $ R - 1 ; $ ans = 1 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { $ ans = $ ans * $ A [ $ i ] ; $ ans = $ ans % $ P ; } return $ ans ; } $ A = array ( 1 , 2 , 3 , 4 , 5 , 6 ) ; $ P = 229 ; $ L = 2 ; $ R = 5 ; echo calculateProduct ( $ A , $ L , $ R , $ P ) , \" \" ; $ L = 1 ; $ R = 3 ; echo calculateProduct ( $ A , $ L , $ R , $ P ) , \" \" ; ? >"}
{"text": "Kiraan prima dalam julat | Program PHP untuk menjawab pertanyaan untuk mengira prima dalam julat yang diberikan. ; Awalan [i] akan menyimpan kiraan prima sehingga saya (termasuk i). ; Buat nilai array Boolean dalam Perdana [i] akan \"Perdana [0 ... N]\". Akhirnya palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Membina array awalan $ awalan [0] = $ awalan [1] = 0; ; Mengembalikan kiraan prima dalam jarak dari L ke R (kedua -duanya termasuk). ; Kod pemacu", "code": "< ? php $ MAX = 10000 ; $ prefix = array_fill ( 0 , ( $ MAX + 1 ) , 0 ) ; function buildPrefix ( ) { global $ MAX , $ prefix ; $ prime = array_fill ( 0 , ( $ MAX + 1 ) , true ) ; for ( $ p = 2 ; $ p * $ p <= $ MAX ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ MAX ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ p = 2 ; $ p <= $ MAX ; $ p ++ ) { $ prefix [ $ p ] = $ prefix [ $ p - 1 ] ; if ( $ prime [ $ p ] ) $ prefix [ $ p ] ++ ; } } function query ( $ L , $ R ) { global $ prefix ; return $ prefix [ $ R ] - $ prefix [ $ L - 1 ] ; } buildPrefix ( ) ; $ L = 5 ; $ R = 10 ; echo query ( $ L , $ R ) . \" STRNEWLINE \" ; $ L = 1 ; $ R = 10 ; echo query ( $ L , $ R ) . \" STRNEWLINE \" ; ? >"}
{"text": "Arahan Perduaan Selepas M RANGE TOGGLE OPERASI | fungsi untuk bertukar; fungsi untuk pemprosesan akhir array; fungsi untuk hasil percetakan; Kod pemacu; fungsi panggilan untuk togol; pelbagai proses; hasil cetak", "code": "< ? php function command ( $ arr , $ a , $ b ) { $ arr [ $ a ] = $ arr [ $ a ] ^ 1 ; $ arr [ $ b + 1 ] ^= 1 ; } function process ( $ arr , $ n ) { for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) { $ arr [ $ k ] = $ arr [ $ k ] ^ $ arr [ $ k - 1 ] ; } } function result ( $ arr , $ n ) { for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) echo $ arr [ $ k ] . \" ▁ \" ; } $ n = 5 ; $ m = 3 ; $ arr = new SplFixedArray ( 7 ) ; $ arr [ 6 ] = array ( 0 ) ; command ( $ arr , 1 , 5 ) ; command ( $ arr , 2 , 5 ) ; command ( $ arr , 3 , 5 ) ; process ( $ arr , $ n ) ; result ( $ arr , $ n ) ; ? >"}
{"text": "Kebarangkalian pasangan rawak menjadi pasangan berwajaran maksimum | Berfungsi untuk mengembalikan kebarangkalian; Mengira kejadian elemen maksimum dalam []; Mengira kejadian elemen maksimum dalam b []; Kebarangkalian kembali; Kod pemacu", "code": "< ? php function probability ( $ a , $ b , $ size1 , $ size2 ) { $ max1 = PHP_INT_MIN ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ size1 ; $ i ++ ) { if ( $ a [ $ i ] > $ max1 ) { $ max1 = $ a [ $ i ] ; $ count1 = 1 ; } else if ( $ a [ $ i ] == $ max1 ) { $ count1 ++ ; } } $ max2 = PHP_INT_MIN ; $ count2 = 0 ; for ( $ i = 0 ; $ i < $ size2 ; $ i ++ ) { if ( $ b [ $ i ] > $ max2 ) { $ max2 = $ b [ $ i ] ; $ count2 = 1 ; } else if ( $ b [ $ i ] == $ max2 ) { $ count2 ++ ; } } return ( double ) ( $ count1 * $ count2 ) / ( $ size1 * $ size2 ) ; } $ a = array ( 1 , 2 , 3 ) ; $ b = array ( 1 , 3 , 3 ) ; $ size1 = sizeof ( $ a ) ; $ size2 = sizeof ( $ b ) ; echo probability ( $ a , $ b , $ size1 , $ size2 ) ; ? >"}
{"text": "Minimum DE | berfungsi untuk mengira dearrangement; Buat salinan Array Asal; Susun array; TRAVERSE SISTED ARRAY UNTUK MENGURANGKAN MISMATCHES; membalikkan array yang disusun; melintasi array yang disusun terbalik untuk mengira ketidakcocokan; Kembali kiraan mismatch minimum; Kod pemacu", "code": "< ? php function countDe ( $ arr , $ n ) { $ v = $ arr ; sort ( $ arr ) ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count1 ++ ; rsort ( $ arr ) ; $ count2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count2 ++ ; return ( min ( $ count1 , $ count2 ) ) ; } $ arr = array ( 5 , 9 , 21 , 17 , 13 ) ; $ n = count ( $ arr ) ; echo \" Minimum ▁ Dearrangement ▁ = ▁ \" . countDe ( $ arr , $ n ) ; ? >"}
{"text": "Bahagikan array ke segmen K untuk memaksimumkan maksimum segmen segmen | fungsi untuk mengira maksimum semua segmen minimum; Jika kita perlu membahagikannya ke dalam 1 segmen maka min akan menjadi jawapannya; Jika k> = 3, kembali maksimum semua elemen. ; Kod pemacu", "code": "< ? php function maxOfSegmentMins ( $ a , $ n , $ k ) { if ( $ k == 1 ) return min ( $ a ) ; if ( $ k == 2 ) return max ( $ a [ 0 ] , $ a [ $ n - 1 ] ) ; return max ( $ a ) ; } $ a = array ( -10 , -9 , -8 , 2 , 7 , -6 , -5 ) ; $ n = count ( $ a ) ; $ k = 2 ; echo maxOfSegmentMins ( $ a , $ n , $ k ) ; ? >"}
{"text": "Pasangan Produk Minimum Pelbagai Integer Positif | Fungsi untuk mengira produk minimum pasangan; Memulakan minimum pertama dan kedua. Dianggap bahawa array mempunyai sekurang -kurangnya dua elemen. ; Melintasi array yang tersisa dan menjejaki dua elemen minimum (perhatikan bahawa kedua -dua elemen minimum mungkin sama jika elemen minimum muncul lebih daripada sekali) lebih daripada sekali); Kod pemacu", "code": "< ? php function printMinimumProduct ( $ arr , $ n ) { $ first_min = min ( $ arr [ 0 ] , $ arr [ 1 ] ) ; $ second_min = max ( $ arr [ 0 ] , $ arr [ 1 ] ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ first_min ) { $ second_min = $ first_min ; $ first_min = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] < $ second_min ) $ second_min = $ arr [ $ i ] ; } return $ first_min * $ second_min ; } $ a = array ( 11 , 8 , 5 , 7 , 5 , 100 ) ; $ n = sizeof ( $ a ) ; echo ( printMinimumProduct ( $ a , $ n ) ) ; ? >"}
{"text": "Kira cara untuk membentuk triplet produk minimum | berfungsi untuk mengira bilangan tiga kali ganda; Susun array; Mengira kejadian elemen ketiga; Jika ketiga -tiga elemen adalah sama (elemen minimum muncul sekurang -kurangnya 3 kali). Jawapannya ialah NC3. ; Jika elemen minimum muncul sekali. Jawapannya ialah NC2. ; Minimum dua elemen adalah berbeza. Jawapannya ialah NC1. ; Kod pemacu", "code": "< ? php function noOfTriples ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ 2 ] ) $ count ++ ; if ( $ arr [ 0 ] == $ arr [ 2 ] ) return ( $ count - 2 ) * ( $ count - 1 ) * ( $ count ) / 6 ; else if ( $ arr [ 1 ] == $ arr [ 2 ] ) return ( $ count - 1 ) * ( $ count ) / 2 ; return $ count ; } $ arr = array ( 1 , 3 , 3 , 4 ) ; $ n = count ( $ arr ) ; echo noOfTriples ( $ arr , $ n ) ; ? >"}
{"text": "Semak jika membalikkan sub array membuat array disusun | Kembali benar, jika membalikkan subarray akan menyusun array, lain kembali palsu. ; Menyalin array. ; Susun array yang disalin. ; Mencari ketidakcocokan pertama. ; Mencari ketidakcocokan terakhir. ; Jika keseluruhan array disusun; Memeriksa subarray berkurangan atau tidak. ; Kod pemacu", "code": "< ? php function checkReverse ( $ arr , $ n ) { $ temp [ $ n ] = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ temp [ $ i ] = $ arr [ $ i ] ; sort ( $ temp , 0 ) ; $ front ; for ( $ front = 0 ; $ front < $ n ; $ front ++ ) if ( $ temp [ $ front ] != $ arr [ $ front ] ) break ; $ back ; for ( $ back = $ n - 1 ; $ back >= 0 ; $ back -- ) if ( $ temp [ $ back ] != $ arr [ $ back ] ) break ; if ( $ front >= $ back ) return true ; do { $ front ++ ; if ( $ arr [ $ front - 1 ] < $ arr [ $ front ] ) return false ; } while ( $ front != $ back ) ; return true ; } $ arr = array ( 1 , 2 , 5 , 4 , 3 ) ; $ n = sizeof ( $ arr ) ; if ( checkReverse ( $ arr , $ n ) ) echo \" Yes \" . \" STRNEWLINE \" ; else echo \" No \" . \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika membalikkan sub array membuat array disusun | Kembali benar, jika membalikkan subarray akan menyusun array, lain kembali palsu. ; Cari bahagian pertama yang semakin meningkat; Cari bahagian terbalik; Cari bahagian yang semakin meningkat; Untuk mengendalikan kes seperti {1, 2, 3, 4, 20, 9, 16, 17}; Kod pemacu", "code": "< ? php function checkReverse ( $ arr , $ n ) { if ( $ n == 1 ) return true ; for ( $ i = 1 ; $ i < $ n && $ arr [ $ i - 1 ] < $ arr [ $ i ] ; $ i ++ ) ; if ( $ i == $ n ) return true ; $ j = $ i ; while ( $ arr [ $ j ] < $ arr [ $ j - 1 ] ) { if ( $ i > 1 && $ arr [ $ j ] < $ arr [ $ i - 2 ] ) return false ; $ j ++ ; } if ( $ j == $ n ) return true ; $ k = $ j ; if ( $ arr [ $ k ] < $ arr [ $ i - 1 ] ) return false ; while ( $ k > 1 && $ k < $ n ) { if ( $ arr [ $ k ] < $ arr [ $ k - 1 ] ) return false ; $ k ++ ; } return true ; } $ arr = array ( 1 , 3 , 4 , 10 , 9 , 8 ) ; $ n = sizeof ( $ arr ) ; if ( checkReverse ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Membuat unsur -unsur dua tatasusunan sama dengan kenaikan / penurunan minimum | Program PHP untuk mencari operasi kenaikan / penurunan minimum untuk membuat elemen array sama. ; menyusun kedua -dua tatasusunan dalam urutan menaik; pembolehubah untuk menyimpan hasil akhir; Selepas menyusun kedua -dua tatasusunan sekarang setiap array berada dalam perintah yang tidak menurun. Oleh itu, kita akan membandingkan setiap elemen array dan melakukan operasi kenaikan atau pengurangan bergantung kepada nilai array B []. ; Kod pemacu", "code": "< ? php function MinOperation ( $ a , $ b , $ n ) { sort ( $ a ) ; sort ( $ b ) ; $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ a [ $ i ] > $ b [ $ i ] ) $ result = $ result + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; else if ( $ a [ $ i ] < $ b [ $ i ] ) $ result = $ result + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; } return $ result ; } $ a = array ( 3 , 1 , 1 ) ; $ b = array ( 1 , 2 , 2 ) ; $ n = sizeof ( $ a ) ; echo MinOperation ( $ a , $ b , $ n ) ; ? >"}
{"text": "Sorting Array Kecuali Elemen dalam Subarray | Susun seluruh array a [] kecuali unsur -unsur dalam julat a [l. . r]; Salin semua elemen yang perlu disusun ke array tambahan B []; Susun array b; Salin unsur -unsur yang disusun kembali ke []; Kod pemacu", "code": "< ? php function sortExceptUandL ( $ a , $ l , $ u , $ n ) { $ b = array ( ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ b [ $ i ] = $ a [ $ i ] ; for ( $ i = $ u + 1 ; $ i < $ n ; $ i ++ ) $ b [ $ l + ( $ i - ( $ u + 1 ) ) ] = $ a [ $ i ] ; sort ( $ b ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ a [ $ i ] = $ b [ $ i ] ; for ( $ i = $ u + 1 ; $ i < $ n ; $ i ++ ) $ a [ $ i ] = $ b [ $ l + ( $ i - ( $ u + 1 ) ) ] ; } $ a = array ( 4 , 5 , 3 , 12 , 14 , 9 ) ; $ n = count ( $ a ) ; $ l = 2 ; $ u = 4 ; sortExceptUandL ( $ a , $ l , $ u , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ a [ $ i ] . \" ▁ \" ) ; ? >"}
{"text": "Menyusun semua elemen array kecuali satu | Program PHP untuk menyusun semua elemen kecuali elemen pada indeks k. ; Gerakkan elemen k - ke berakhir; Menyusun semua elemen kecuali yang terakhir; Simpan elemen terakhir (asalnya k - th); Gerakkan semua elemen dari k - ke satu kedudukan di hadapan. ; Memulihkan elemen k - th; Kod pemacu", "code": "< ? php function sortExceptK ( & $ arr , $ k , $ n ) { $ t = $ arr [ $ k ] ; $ arr [ $ k ] = $ arr [ $ n - 1 ] ; $ arr [ $ n - 1 ] = $ t ; $ t = $ arr [ count ( $ arr ) - 1 ] ; $ arr = array_slice ( $ arr , 0 , -1 ) ; sort ( $ arr ) ; array_push ( $ arr , $ t ) ; $ last = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 1 ; $ i > $ k ; $ i -- ) $ arr [ $ i ] = $ arr [ $ i - 1 ] ; $ arr [ $ k ] = $ last ; } $ a = array ( 10 , 4 , 11 , 7 , 6 , 20 ) ; $ k = 2 ; $ n = count ( $ a ) ; sortExceptK ( $ a , $ k , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ a [ $ i ] . \" ▁ \" ) ; ? >"}
{"text": "Bilangan maksimum partisi yang boleh disusun secara individu untuk membuat disusun | Berfungsi untuk mencari partition maksimum. ; Cari maksimum dalam awalan arr [0 .. i]; Jika maksimum setakat ini sama dengan indeks, kita boleh membuat partition baru yang berakhir pada indeks i. ; Kod pemacu", "code": "< ? php function maxPartitions ( $ arr , $ n ) { $ ans = 0 ; $ max_so_far = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ max_so_far = max ( $ max_so_far , $ arr [ $ i ] ) ; if ( $ max_so_far == $ i ) $ ans ++ ; } return $ ans ; } { $ arr = array ( 1 , 0 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo maxPartitions ( $ arr , $ n ) ; return 0 ; } ? >"}
{"text": "Tali ditinggalkan selepas setiap penyingkiran terkecil | Fungsi Cetak berapa banyak tali yang ditinggalkan operasi pemotongan; menyusun semua tali dalam peningkatan panjang di sana; Tali panjang min; kini melintasi tali yang diberikan dalam peningkatan urutan panjang; Selepas memotong jika panjang tali semasa lebih besar daripada '0' yang bermaksud semua tali ke sebelah kanannya juga lebih besar daripada 0; Sekarang tali semasa menjadi tali panjang min; Selepas operasi pertama semua tali panjang menjadi sifar; Kod pemacu", "code": "< ? php function cuttringRopes ( $ Ropes , $ n ) { sort ( $ Ropes ) ; $ singleOperation = 0 ; $ cuttingLenght = $ Ropes [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ Ropes [ $ i ] - $ cuttingLenght > 0 ) { echo ( $ n - $ i ) . \" ▁ \" ; $ cuttingLenght = $ Ropes [ $ i ] ; $ singleOperation ++ ; } } if ( $ singleOperation == 0 ) echo \"0 ▁ \" ; } $ Ropes = array ( 5 , 1 , 1 , 2 , 3 , 5 ) ; $ n = count ( $ Ropes ) ; cuttringRopes ( $ Ropes , $ n ) ; ? >"}
{"text": "Pangkat semua elemen dalam array | Berfungsi untuk mencari pangkat; Vektor pangkat; Sapu melalui semua elemen dalam A untuk setiap elemen mengira bilangan kurang daripada unsur -unsur yang sama secara berasingan dalam R dan S. ; Gunakan formula untuk mendapatkan pangkat; Kod pemacu", "code": "< ? php function rankify ( $ A , $ n ) { $ R = array ( 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ r = 1 ; $ s = 1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ j != $ i && $ A [ $ j ] < $ A [ $ i ] ) $ r += 1 ; if ( $ j != $ i && $ A [ $ j ] == $ A [ $ i ] ) $ s += 1 ; } $ R [ $ i ] = $ r + ( float ) ( $ s - 1 ) / ( float ) 2 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) print number_format ( $ R [ $ i ] , 1 ) . ' ▁ ' ; } $ A = array ( 1 , 2 , 5 , 2 , 1 , 25 , 2 ) ; $ n = count ( $ A ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ A [ $ i ] . ' ▁ ' ; echo \" STRNEWLINE \" ; rankify ( $ A , $ n ) ; ? >"}
{"text": "Bilangan minimum pengurangan operasi untuk membuat array berkurangan | Fungsi untuk mengira minimum tiada operasi; Kira berapa kali kita perlu ditolak. ; Semak penolakan tambahan diperlukan atau tidak. ; Ubah suai nilai ARR [i]. ; Kira Jumlah Tidak Operasi / Penolakan. ; Kod pemacu", "code": "< ? php function min_noOf_operation ( $ arr , $ n , $ k ) { $ noOfSubtraction ; $ res = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ noOfSubtraction = 0 ; if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) { $ noOfSubtraction = ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) / $ k ; if ( ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) % $ k != 0 ) $ noOfSubtraction ++ ; $ arr [ $ i ] = $ arr [ $ i ] - $ k * $ noOfSubtraction ; } $ res = $ res + $ noOfSubtraction ; } return floor ( $ res ) ; } $ arr = array ( 1 , 1 , 2 , 3 ) ; $ N = count ( $ arr ) ; $ k = 5 ; echo min_noOf_operation ( $ arr , $ N , $ k ) ; ? >"}
{"text": "Memaksimumkan jumlah arr [i] * i | Program php untuk mencari nilai maksimum i * arr [i]; Susun array; Mencari jumlah arr [i] * i; Kod pemacu", "code": "< ? php function maxSum ( $ arr , $ n ) { sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( $ arr [ $ i ] * $ i ) ; return $ sum ; } $ arr = array ( 3 , 5 , 6 , 1 ) ; $ n = count ( $ arr ) ; echo maxSum ( $ arr , $ n ) ; ? >"}
{"text": "Pasangan dengan perbezaan kurang daripada k | Berfungsi untuk mengira pasangan; Kod pemacu", "code": "< ? php function countPairs ( $ a , $ n , $ k ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( $ a [ $ j ] - $ a [ $ i ] ) < $ k ) $ res ++ ; return $ res ; } $ a = array ( 1 , 10 , 4 , 2 ) ; $ k = 3 ; $ n = count ( $ a ) ; echo countPairs ( $ a , $ n , $ k ) ; ? >"}
{"text": "Pasangan dengan perbezaan kurang daripada k | Kod PHP untuk mencari kiraan pasangan dengan perbezaan kurang daripada k. ; untuk menyusun array. ; Simpan hasil yang lebih tinggi manakala unsur -unsur berikutnya berada dalam had. ; Kod pemacu", "code": "< ? php function countPairs ( $ a , $ n , $ k ) { sort ( $ a ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j = $ i + 1 ; while ( $ j < $ n and $ a [ $ j ] - $ a [ $ i ] < $ k ) { $ res ++ ; $ j ++ ; } } return $ res ; } $ a = array ( 1 , 10 , 4 , 2 ) ; $ k = 3 ; $ n = count ( $ a ) ; echo countPairs ( $ a , $ n , $ k ) ; ? >"}
{"text": "Jumlah perbezaan mutlak minimum setiap elemen array | berfungsi untuk mencari jumlah perbezaan mutlak minimum; Susun array yang diberikan; memulakan jumlah; Perbezaan mutlak min untuk elemen array 1 ST; Perbezaan mutlak min untuk elemen array terakhir; Cari perbezaan mutlak min untuk sisa elemen array dan tambahkannya kepada jumlah; Jumlah yang diperlukan; Kod pemacu", "code": "< ? php function sumOfMinAbsDifferences ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ sum = 0 ; $ sum += abs ( $ arr [ 0 ] - $ arr [ 1 ] ) ; $ sum += abs ( $ arr [ $ n - 1 ] - $ arr [ $ n - 2 ] ) ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) $ sum += min ( abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) , abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ) ; return $ sum ; } $ arr = array ( 5 , 10 , 1 , 4 , 8 , 7 ) ; $ n = sizeof ( $ arr ) ; echo \" Sum = \" ? >"}
{"text": "Sepasang nilai yang paling kecil antara dua tatasusunan yang tidak disusun | fungsi untuk mengira hasil kecil antara dua tatasusunan; Susun kedua -dua tatasusunan menggunakan fungsi jenis; Memulakan hasil sebagai nilai maksimum; Imbas kedua -dua array sehingga saiz susunan; Bergerak nilai yang lebih kecil; kembali keputusan SMA akhir; Kod pemacu; Input diberikan array a; Input diberikan array b; Hitung saiz kedua -dua tatasusunan; Fungsi panggilan untuk mencetak hasil terkecil", "code": "< ? php function findSmallestDifference ( $ A , $ B , $ m , $ n ) { sort ( $ A ) ; sort ( $ A , $ m ) ; sort ( $ B ) ; sort ( $ B , $ n ) ; $ a = 0 ; $ b = 0 ; $ INT_MAX = 1 ; $ result = $ INT_MAX ; while ( $ a < $ m && $ b < $ n ) { if ( abs ( $ A [ $ a ] - $ B [ $ b ] ) < $ result ) $ result = abs ( $ A [ $ a ] - $ B [ $ b ] ) ; if ( $ A [ $ a ] < $ B [ $ b ] ) $ a ++ ; else $ b ++ ; } return $ result ; } { $ A = array ( 1 , 2 , 11 , 5 ) ; $ B = array ( 4 , 12 , 19 , 23 , 127 , 235 ) ; $ m = sizeof ( $ A ) / sizeof ( $ A [ 0 ] ) ; $ n = sizeof ( $ B ) / sizeof ( $ B [ 0 ] ) ; echo findSmallestDifference ( $ A , $ B , $ m , $ n ) ; return 0 ; } ? >"}
{"text": "Cari elemen yang lebih besar daripada separuh elemen dalam array | Cetak elemen yang lebih besar daripada elemen n / 2; Susun array dalam urutan menaik; Cetak elemen ceil terakhir (n / 2); Kod pemacu", "code": "< ? php function findLarger ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = $ n - 1 ; $ i >= $ n / 2 ; $ i -- ) echo $ arr [ $ i ] , \" ▁ \" ; } $ arr = array ( 1 , 3 , 6 , 1 , 0 , 9 ) ; $ n = count ( $ arr ) ; findLarger ( $ arr , $ n ) ; ? >"}
{"text": "Cari nombor yang hilang | getmissingno mengambil array dan saiz array sebagai argumen; Kod pemacu", "code": "< ? php function getMissingNo ( $ a , $ n ) { $ total = ( $ n + 1 ) * ( $ n + 2 ) / 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ total -= $ a [ $ i ] ; return $ total ; } $ a = array ( 1 , 2 , 4 , 5 , 6 ) ; $ miss = getMissingNo ( $ a , 5 ) ; echo ( $ miss ) ; ? >"}
{"text": "Kira bilangan kejadian (atau kekerapan) dalam array yang disusun | Mengembalikan bilangan kali x berlaku di arr [0 .. n - 1]; Kod pemacu", "code": "< ? php function countOccurrences ( $ arr , $ n , $ x ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ x == $ arr [ $ i ] ) $ res ++ ; return $ res ; } $ arr = array ( 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ) ; $ n = count ( $ arr ) ; $ x = 2 ; echo countOccurrences ( $ arr , $ n , $ x ) ; ? >"}
{"text": "Kira bilangan kejadian (atau kekerapan) dalam array yang disusun | Fungsi carian binari rekursif. Ia mengembalikan lokasi x dalam array yang diberikan [l. . r] hadir, jika tidak - 1; Jika elemen hadir di tengah -tengahnya sendiri; Jika elemen lebih kecil daripada pertengahan, maka ia hanya boleh hadir di subarray kiri; Lain elemen hanya boleh hadir di subarray kanan; Mengembalikan bilangan kali x berlaku di arr [0 .. n - 1]; Jika elemen tidak hadir; Kira elemen di sebelah kiri. ; Kira elemen di sebelah kanan. ; Kod pemacu", "code": "< ? php function binarySearch ( & $ arr , $ l , $ r , $ x ) { if ( $ r < $ l ) return -1 ; $ mid = $ l + ( $ r - $ l ) / 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } function countOccurrences ( $ arr , $ n , $ x ) { $ ind = binarySearch ( $ arr , 0 , $ n - 1 , $ x ) ; if ( $ ind == -1 ) return 0 ; $ count = 1 ; $ left = $ ind - 1 ; while ( $ left >= 0 && $ arr [ $ left ] == $ x ) { $ count ++ ; $ left -- ; } $ right = $ ind + 1 ; while ( $ right < $ n && $ arr [ $ right ] == $ x ) { $ count ++ ; $ right ++ ; } return $ count ; } $ arr = array ( 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ) ; $ n = sizeof ( $ arr ) ; $ x = 2 ; echo countOccurrences ( $ arr , $ n , $ x ) ; ? >"}
{"text": "Memandangkan array yang disusun dan nombor X, cari pasangan dalam array yang jumlahnya paling dekat dengan x | Mencetak pasangan dengan jumlah yang paling dekat dengan x; Untuk menyimpan indeks pasangan hasil; Memulakan indeks kiri dan kanan dan perbezaan antara jumlah pasangan dan x; Walaupun terdapat unsur -unsur antara L dan R; Semak jika pasangan ini lebih dekat daripada pasangan terdekat setakat ini; Jika pasangan ini mempunyai lebih banyak jumlah, bergerak ke nilai yang lebih kecil. ; Bergerak ke nilai yang lebih besar; Kod pemacu", "code": "< ? php function printClosest ( $ arr , $ n , $ x ) { $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; $ diff = PHP_INT_MAX ; while ( $ r > $ l ) { if ( abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) ; } if ( $ arr [ $ l ] + $ arr [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo \" ▁ The ▁ closest ▁ pair ▁ is ▁ \" , $ arr [ $ res_l ] , \" ▁ and ▁ \" , $ arr [ $ res_r ] ; } $ arr = array ( 10 , 22 , 28 , 29 , 30 , 40 ) ; $ x = 54 ; $ n = count ( $ arr ) ; printClosest ( $ arr , $ n , $ x ) ; ? >"}
{"text": "Kira 1 dalam array binari yang disusun | Mengembalikan tuduhan 1 dalam arr [rendah..high]. Arahan diandaikan disusun mengikut urutan yang tidak meningkat; Dapatkan indeks tengah; Semak sama ada elemen di Indeks Tengah adalah terakhir 1; Jika elemen tidak terakhir 1, berulang untuk sebelah kanan; lain berulang untuk sebelah kiri; Kod pemacu", "code": "< ? php function countOnes ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = $ low + ( $ high - $ low ) / 2 ; if ( ( $ mid == $ high or $ arr [ $ mid + 1 ] == 0 ) and ( $ arr [ $ mid ] == 1 ) ) return $ mid + 1 ; if ( $ arr [ $ mid ] == 1 ) return countOnes ( $ arr , ( $ mid + 1 ) , $ high ) ; return countOnes ( $ arr , $ low , ( $ mid - 1 ) ) ; } return 0 ; } $ arr = array ( 1 , 1 , 1 , 1 , 0 , 0 , 0 ) ; $ n = count ( $ arr ) ; echo \" Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ array ▁ is ▁ \" , countOnes ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text": "Cari elemen yang hilang dari array yang diduplikasi | Fungsi untuk mencari elemen yang hilang berdasarkan pendekatan carian binari. arr1 [] adalah saiz yang lebih besar dan n adalah saiznya. arr1 [] dan arr2 [] diandaikan berada dalam urutan yang sama. ; Kes khas, hanya untuk elemen yang hilang dalam array kedua; Kes khas, untuk elemen pertama hilang; Memulakan titik sudut semasa; gelung sehingga lo <hi; Jika elemen pada indeks pertengahan adalah sama maka pergi ke subarray kanan; jika lo, hi menjadi bersebelahan, pecah; Elemen yang hilang akan berada di Indeks HI Array yang lebih besar; Fungsi ini terutamanya melakukan pemeriksaan ralat asas dan panggilan findmissingutil; Kod pemacu", "code": "< ? php function findMissingUtil ( $ arr1 , $ arr2 , $ N ) { if ( $ N == 1 ) return $ arr1 [ 0 ] ; if ( $ arr1 [ 0 ] != $ arr2 [ 0 ] ) return $ arr1 [ 0 ] ; $ lo = 0 ; $ hi = $ N - 1 ; while ( $ lo < $ hi ) { $ mid = ( $ lo + $ hi ) / 2 ; if ( $ arr1 [ $ mid ] == $ arr2 [ $ mid ] ) $ lo = $ mid ; else $ hi = $ mid ; if ( $ lo == $ hi - 1 ) break ; } return $ arr1 [ $ hi ] ; } function findMissing ( $ arr1 , $ arr2 , $ M , $ N ) { if ( $ N == $ M - 1 ) echo \" Missing ▁ Element ▁ is ▁ \" , findMissingUtil ( $ arr1 , $ arr2 , $ M ) ; else if ( $ M == $ N - 1 ) echo \" Missing ▁ Element ▁ is ▁ \" , findMissingUtil ( $ arr2 , $ arr1 , $ N ) ; else echo \" Invalid ▁ Input \" ; } $ arr1 = array ( 1 , 4 , 5 , 7 , 9 ) ; $ arr2 = array ( 4 , 5 , 7 , 9 ) ; $ M = count ( $ arr1 ) ; $ N = count ( $ arr2 ) ; findMissing ( $ arr1 , $ arr2 , $ M , $ N ) ; ? >"}
{"text": "Cari elemen yang hilang dari array yang diduplikasi | Fungsi ini terutamanya adalah xor semua elemen arr1 [] dan arr2 []; Lakukan xor semua elemen; Kod pemacu", "code": "< ? php function findMissing ( $ arr1 , $ arr2 , $ M , $ N ) { if ( $ M != $ N - 1 && $ N != $ M - 1 ) { echo \" Invalid ▁ Input \" ; return ; } $ res = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) $ res = $ res ^ $ arr1 [ $ i ] ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ res = $ res ^ $ arr2 [ $ i ] ; echo \" Missing ▁ element ▁ is ▁ \" , $ res ; } $ arr1 = array ( 4 , 1 , 5 , 9 , 7 ) ; $ arr2 = array ( 7 , 5 , 9 , 4 ) ; $ M = sizeof ( $ arr1 ) ; $ N = sizeof ( $ arr2 ) ; findMissing ( $ arr1 , $ arr2 , $ M , $ N ) ; ? >"}
{"text": "Cari pengulangan dan yang hilang | Menambah 3 Kaedah Baru | Program PHP untuk mencari unsur -unsur berulang dan hilang; Kod pemacu", "code": "< ? php function printTwoElements ( $ arr , $ size ) { $ i ; echo \" The ▁ repeating ▁ element ▁ is \" , \" ▁ \" ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ abs ( $ arr [ $ i ] ) - 1 ] > 0 ) $ arr [ abs ( $ arr [ $ i ] ) - 1 ] = - $ arr [ abs ( $ arr [ $ i ] ) - 1 ] ; else echo ( abs ( $ arr [ $ i ] ) ) ; } echo \" and the missing element is \" ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ $ i ] > 0 ) echo ( $ i + 1 ) ; } } $ arr = array ( 7 , 3 , 4 , 5 , 5 , 6 , 2 ) ; $ n = count ( $ arr ) ; printTwoElements ( $ arr , $ n ) ; ? >"}
{"text": "Cari pengulangan dan yang hilang | Menambah 3 Kaedah Baru | Program PHP untuk mencari unsur -unsur berulang dan hilang; Akan memegang xor semua elemen dan nombor dari 1 hingga n; Hanya akan mempunyai bit satu set XOR1; Dapatkan XOR semua elemen array; Xor hasil sebelumnya dengan nombor dari 1 hingga n; Dapatkan bit set kanan dalam set_bit_no; Sekarang bahagikan unsur -unsur dalam dua set dengan membandingkan bit set kanan XOR1 dengan bit pada kedudukan yang sama dalam setiap elemen. Juga, dapatkan Xors dua set. Kedua -dua XOR adalah elemen output. Dua berikut untuk gelung berfungsi dengan tujuan; arr [i] tergolong dalam set pertama; Arr [i] tergolong dalam set kedua; Saya tergolong dalam set pertama; Saya tergolong dalam set kedua; * x dan * y memegang elemen output yang dikehendaki; Kod pemacu", "code": "< ? php function getTwoElements ( & $ arr , $ n ) { $ xor1 ; $ set_bit_no ; $ i ; $ x = 0 ; $ y = 0 ; $ xor1 = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ xor1 = $ xor1 ^ $ arr [ $ i ] ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ xor1 = $ xor1 ^ $ i ; $ set_bit_no = $ xor1 & ~ ( $ xor1 - 1 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ arr [ $ i ] & $ set_bit_no ) != 0 ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( ( $ i & $ set_bit_no ) != 0 ) $ x = $ x ^ $ i ; else $ y = $ y ^ $ i ; } } $ arr = array ( 1 , 3 , 4 , 5 , 1 , 6 , 2 ) ; $ n = sizeof ( $ arr ) ; getTwoElements ( $ arr , $ n ) ;"}
{"text": "Cari empat elemen yang Jumlah kepada nilai tertentu | Tetapkan 1 (N ^ 3 Penyelesaian) | Penyelesaian naif untuk mencetak semua gabungan 4 elemen dalam [] dengan jumlah yang sama dengan x; Betulkan elemen pertama dan cari tiga yang lain; Betulkan elemen kedua dan cari dua yang lain; Betulkan elemen ketiga dan cari keempat; Cari keempat; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function findFourElements ( $ A , $ n , $ X ) { for ( $ i = 0 ; $ i < $ n - 3 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 2 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n - 1 ; $ k ++ ) { for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) if ( $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] + $ A [ $ l ] == $ X ) echo $ A [ $ i ] , \" , ▁ \" , $ A [ $ j ] , \" , ▁ \" , $ A [ $ k ] , \" , ▁ \" , $ A [ $ l ] ; } } } } $ A = array ( 10 , 20 , 30 , 40 , 1 , 2 ) ; $ n = sizeof ( $ A ) ; $ X = 91 ; findFourElements ( $ A , $ n , $ X ) ; ? >"}
{"text": "Cari elemen dalam array di mana perbezaan antara elemen bersebelahan ialah 1 | x adalah elemen yang akan dicari dalam arr [0. n - 1]; Melintasi array yang diberikan bermula dari elemen paling kiri; Jika x ditemui di Indeks I; Lompat perbezaan antara elemen array semasa dan x; Kod pemacu", "code": "< ? php function search ( $ arr , $ n , $ x ) { $ i = 0 ; while ( $ i < $ n ) { if ( $ arr [ $ i ] == $ x ) return $ i ; $ i = $ i + abs ( $ arr [ $ i ] - $ x ) ; } echo \" number ▁ is ▁ not ▁ present ! \" ; return -1 ; } $ arr = array ( 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 ) ; $ n = sizeof ( $ arr ) ; $ x = 3 ; echo \" Element ▁ \" , $ x , \" ▁ is ▁ present ▁ \" , \" at ▁ index ▁ \" , search ( $ arr , $ n , 3 ) ; ? >"}
{"text": "Elemen ketiga terbesar dalam pelbagai unsur yang berbeza | Program PHP untuk mencari elemen ketiga terbesar dalam pelbagai elemen yang berbeza; Harus ada tiga elemen; Cari elemen terbesar pertama; Cari elemen kedua terbesar; Cari elemen ketiga terbesar; Kod pemacu", "code": "< ? php function thirdLargest ( $ arr , $ arr_size ) { if ( $ arr_size < 3 ) { echo \" ▁ Invalid ▁ Input ▁ \" ; return ; } $ first = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ first ) $ first = $ arr [ $ i ] ; $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ second && $ arr [ $ i ] < $ first ) $ second = $ arr [ $ i ] ; $ third = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ third && $ arr [ $ i ] < $ second ) $ third = $ arr [ $ i ] ; echo \" The ▁ third ▁ Largest ▁ element ▁ is ▁ \" , $ third , \" STRNEWLINE \" ; } $ arr = array ( 12 , 13 , 1 , 10 , 34 , 16 ) ; $ n = sizeof ( $ arr ) ; thirdLargest ( $ arr , $ n ) ; ? >"}
{"text": "Elemen ketiga terbesar dalam pelbagai unsur yang berbeza | Program PHP untuk mencari elemen ketiga terbesar dalam array; Harus ada tiga elemen; Memulakan elemen pertama, kedua dan ketiga terbesar; Melintasi unsur -unsur array untuk mencari yang ketiga terbesar; Jika elemen semasa lebih besar daripada yang pertama, maka kemas kini pertama, kedua dan ketiga; Jika arr [i] berada di antara pertama dan kedua; Jika arr [i] berada di antara kedua dan ketiga; Kod pemacu", "code": "< ? php function thirdLargest ( $ arr , $ arr_size ) { if ( $ arr_size < 3 ) { echo \" ▁ Invalid ▁ Input ▁ \" ; return ; } $ first = $ arr [ 0 ] ; $ second = PHP_INT_MIN ; $ third = PHP_INT_MIN ; for ( $ i = 1 ; $ i < $ arr_size ; $ i ++ ) { if ( $ arr [ $ i ] > $ first ) { $ third = $ second ; $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ second ) { $ third = $ second ; $ second = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ third ) $ third = $ arr [ $ i ] ; } echo \" The ▁ third ▁ Largest ▁ element ▁ is ▁ \" , $ third ; } $ arr = array ( 12 , 13 , 1 , 10 , 34 , 16 ) ; $ n = sizeof ( $ arr ) ; thirdLargest ( $ arr , $ n ) ; ? >"}
{"text": "Semak jika terdapat dua elemen dalam array yang jumlahnya sama dengan jumlah sisa array | Fungsi untuk memeriksa sama ada dua elemen wujudnya sama dengan jumlah unsur -unsur yang lain. ; Cari jumlah keseluruhan array; Jika jumlah array tidak lebih daripada kita tidak dapat membahagikannya ke dalam dua bahagian; Untuk setiap elemen arr [i], lihat jika terdapat elemen lain dengan jumlah Vaalue - arr [i]; Jika elemen wujud daripada mengembalikan pasangan; Kod pemacu", "code": "< ? php function checkPair ( & $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; if ( $ sum % 2 != 0 ) return false ; $ sum = $ sum / 2 ; $ s = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ val = $ sum - $ arr [ $ i ] ; if ( array_search ( $ val , $ s ) ) { echo \" Pair ▁ elements ▁ are ▁ \" . $ arr [ $ i ] . \" ▁ and ▁ \" . $ val . \" STRNEWLINE \" ; return true ; } array_push ( $ s , $ arr [ $ i ] ) ; } return false ; } $ arr = array ( 2 , 11 , 5 , 1 , 4 , 7 ) ; $ n = sizeof ( $ arr ) ; if ( checkPair ( $ arr , $ n ) == false ) echo \" No ▁ pair ▁ found \" ; ? >"}
{"text": "Cari elemen dalam array yang tidak disusun menggunakan bilangan perbandingan minimum | berfungsi untuk mencari elemen dalam bilangan perbandingan minimum; 1 perbandingan; tiada keadaan penamatan dan oleh itu tiada perbandingan; Ini akan dilaksanakan pada - kebanyakan masa dan oleh itu - kebanyakan perbandingan; Ganti arr [n - 1] dengan elemen sebenar seperti dalam 'arr []' asal; Jika 'x' ditemui sebelum indeks '(n - 1), maka ia hadir dalam perbandingan akhir array; lain tidak hadir dalam array; Kod pemacu", "code": "< ? php function search ( $ arr , $ n , $ x ) { if ( $ arr [ $ n - 1 ] == $ x ) return \" Found \" ; $ backup = $ arr [ $ n - 1 ] ; $ arr [ $ n - 1 ] = $ x ; for ( $ i = 0 ; ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) { $ arr [ $ n - 1 ] = $ backup ; if ( $ i < $ n - 1 ) return \" Found \" ; return \" Not ▁ Found \" ; } } } $ arr = array ( 4 , 6 , 1 , 5 , 8 ) ; $ n = sizeof ( $ arr ) ; $ x = 1 ; echo ( search ( $ arr , $ n , $ x ) ) ; ? >"}
{"text": "Cari elemen dalam array yang disusun yang kekerapannya lebih besar daripada atau sama dengan n / 2. | Kod PHP untuk mencari elemen majoriti dalam array yang disusun; Kod pemacu", "code": "< ? php function findMajority ( $ arr , $ n ) { return $ arr [ intval ( $ n / 2 ) ] ; } $ arr = array ( 1 , 2 , 2 , 3 ) ; $ n = count ( $ arr ) ; echo findMajority ( $ arr , $ n ) ; ? >"}
{"text": "Perbezaan mutlak minimum unsur -unsur bersebelahan dalam array bulat | Program PHP untuk mencari perbezaan maksimum antara unsur -unsur bersebelahan dalam array bulat. ; Memeriksa unsur -unsur bersebelahan yang normal; Memeriksa pautan bulat; Kod pemacu", "code": "< ? php function minAdjDifference ( $ arr , $ n ) { if ( $ n < 2 ) return ; $ res = abs ( $ arr [ 1 ] - $ arr [ 0 ] ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ res = min ( $ res , abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ) ; $ res = min ( $ res , abs ( $ arr [ $ n - 1 ] - $ arr [ 0 ] ) ) ; echo \" Min ▁ Difference ▁ = ▁ \" , $ res ; } $ a = array ( 10 , 12 , 13 , 15 , 10 ) ; $ n = count ( $ a ) ; minAdjDifference ( $ a , $ n ) ; ? >"}
{"text": "Cari elemen minimum pertama, kedua dan ketiga dalam array | Program PHP untuk mencari elemen minimum pertama, kedua dan ketiga dalam array; Semak jika elemen semasa kurang daripada firstmin, kemudian kemas kini pertama, kedua dan ketiga; Semak jika elemen semasa kurang daripada secmin kemudian kemas kini kedua dan ketiga; Semak jika elemen semasa kurang daripada kemudian kemas kini ketiga; Kod pemacu", "code": "< ? php function Print3Smallest ( $ array , $ n ) { $ MAX = 100000 ; $ firstmin = $ MAX ; $ secmin = $ MAX ; $ thirdmin = $ MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ array [ $ i ] < $ firstmin ) { $ thirdmin = $ secmin ; $ secmin = $ firstmin ; $ firstmin = $ array [ $ i ] ; } else if ( $ array [ $ i ] < $ secmin ) { $ thirdmin = $ secmin ; $ secmin = $ array [ $ i ] ; } else if ( $ array [ $ i ] < $ thirdmin ) $ thirdmin = $ array [ $ i ] ; } echo \" First min = \" . $ firstmin . \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" Second min = \" . $ secmin . \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" Third min = \" . $ thirdmin . \" \" } $ array = array ( 4 , 9 , 1 , 32 , 12 ) ; $ n = sizeof ( $ array ) / sizeof ( $ array [ 0 ] ) ; Print3Smallest ( $ array , $ n ) ; ? >"}
{"text": "Program untuk mencari elemen minimum (atau maksimum) array | Program PHP untuk mencari elemen minimum (atau maksimum) dalam array. ; Kod pemacu", "code": "< ? php function getMin ( & $ arr , $ n ) { return min ( $ arr ) ; } function getMax ( & $ arr , $ n ) { return max ( $ arr ) ; } $ arr = array ( 12 , 1234 , 45 , 67 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum ▁ element ▁ of ▁ array : ▁ \" . getMin ( $ arr , $ n ) . \" STRNEWLINE \" ; echo \" Maximum ▁ element ▁ of ▁ array : ▁ \" . getMax ( $ arr , $ n ) ; ? >"}
{"text": "Mengira frekuensi semua elemen dalam array dalam O (1) ruang tambahan dan O (n) masa | Fungsi untuk mencari tuduhan semua elemen yang ada di arr [0. n - 1]. Unsur -unsur array mesti berkisar antara 1 hingga n; Tolak 1 dari setiap elemen supaya unsur -unsur menjadi berkisar dari 0 hingga n - 1; Gunakan setiap elemen arr [i] sebagai indeks dan tambah 'n' ke elemen yang hadir di arr [i] % n untuk menjejaki kiraan kejadian arr [i]; Untuk mencetak bilangan, cetak bilangan kali N telah ditambah pada indeks yang sepadan dengan setiap elemen; Kod pemacu", "code": "< ? php function printfrequency ( $ arr , $ n ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ arr [ $ j ] = $ arr [ $ j ] - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ arr [ $ i ] % $ n ] = $ arr [ $ arr [ $ i ] % $ n ] + $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ i + 1 , \" ▁ - > ▁ \" , ( int ) ( $ arr [ $ i ] / $ n ) , \" STRNEWLINE \" ; } $ arr = array ( 2 , 3 , 3 , 2 , 5 ) ; $ n = sizeof ( $ arr ) ; printfrequency ( $ arr , $ n ) ; ? >"}
{"text": "Kira penyongsangan saiz tiga dalam array yang diberikan | Mengembalikan kiraan penyongsangan saiz 3; Memulakan hasil; Mengira semua elemen yang lebih kecil di sebelah kanan arr [i]; Mengira semua elemen yang lebih besar di sebelah kiri ARR [i]; Kemas kini kiraan penyongsangan dengan menambahkan semua inversi yang mempunyai ARR [i] sebagai pertengahan tiga elemen; Kod pemacu", "code": "< ? php function getInvCount ( $ arr , $ n ) { $ invcount = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ small = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ small ++ ; $ great = 0 ; for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) if ( $ arr [ $ i ] < $ arr [ $ j ] ) $ great ++ ; $ invcount += $ great * $ small ; } return $ invcount ; } $ arr = array ( 8 , 4 , 2 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Inversion ▁ Count ▁ : ▁ \" , getInvCount ( $ arr , $ n ) ; ? >"}
{"text": "Perangkap air hujan | Program PHP untuk mencari jumlah maksimum air yang boleh terperangkap dalam set bar yang diberikan. ; Memulakan hasil; Mengisi array kiri; Isi array yang betul; Kirakan elemen air terkumpul dengan elemen Pertimbangkan jumlah air pada bar saya, jumlah air yang terkumpul di bar tertentu akan sama dengan min (kiri [i], kanan [i]) - arr [i]. ; Program Pemandu", "code": "< ? php function findWater ( $ arr , $ n ) { $ water = 0 ; $ left [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ left [ $ i ] = max ( $ left [ $ i - 1 ] , $ arr [ $ i ] ) ; $ right [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) $ right [ $ i ] = max ( $ right [ $ i + 1 ] , $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ water += min ( $ left [ $ i ] , $ right [ $ i ] ) - $ arr [ $ i ] ; return $ water ; } $ arr = array ( 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum ▁ water ▁ that ▁ can ▁ be ▁ accumulated ▁ is ▁ \" , findWater ( $ arr , $ n ) ; ? >"}
{"text": "Perangkap air hujan | Kaedah untuk mencari jumlah maksimum air yang boleh terperangkap dalam set bar yang diberikan. ; memulakan output; elemen maksimum di kiri dan kanan; indeks untuk melintasi array; Kemas kini max di sebelah kiri; air pada elemen curr = max - curr; Kemas kini maksimum yang betul; Kod pemacu", "code": "< ? php function findWater ( $ arr , $ n ) { $ result = 0 ; $ left_max = 0 ; $ right_max = 0 ; $ lo = 0 ; $ hi = $ n - 1 ; while ( $ lo <= $ hi ) { if ( $ arr [ $ lo ] < $ arr [ $ hi ] ) { if ( $ arr [ $ lo ] > $ left_max ) $ left_max = $ arr [ $ lo ] ; else $ result += $ left_max - $ arr [ $ lo ] ; $ lo ++ ; } else { if ( $ arr [ $ hi ] > $ right_max ) $ right_max = $ arr [ $ hi ] ; else $ result += $ right_max - $ arr [ $ hi ] ; $ hi -- ; } } return $ result ; } $ arr = array ( 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 ) ; $ n = count ( $ arr ) ; echo \" Maximum ▁ water ▁ that ▁ can ▁ be ▁ accumulated ▁ is ▁ \" , findWater ( $ arr , $ n ) ; ? >"}
{"text": "Median dua susunan yang disusun dengan saiz yang berbeza dalam O (log (min (n, m))) | Kod PHP untuk median dengan kes mengembalikan nilai berganda apabila bilangan elemen hadir dalam kedua -dua array gabungan; Berfungsi untuk mencari max; Berfungsi untuk mencari minimum; Berfungsi untuk mencari median dua susunan yang disusun; Jika i = n, ini bermakna unsur -unsur dari [] pada separuh kedua adalah set kosong. Dan jika J = 0, ini bermakna unsur -unsur dari B [] pada separuh pertama adalah set kosong. Oleh itu, adalah perlu untuk menyemaknya, kerana kita membandingkan unsur -unsur dari kedua -dua kumpulan ini. Mencari di sebelah kanan; Jika i = 0, ini bermakna unsur -unsur dari [] pada separuh pertama adalah set kosong dan jika j = m, ini bermakna unsur -unsur dari B [] pada babak kedua adalah set kosong. Oleh itu, adalah perlu untuk menyemaknya, kerana kita membandingkan unsur -unsur dari kedua -dua kumpulan ini. mencari di sebelah kiri; Kami telah menemui bahagian yang dikehendaki. ; Keadaan ini berlaku apabila kita tidak mempunyai unsur -unsur pada babak pertama dari [] jadi kita mengembalikan elemen terakhir di B [] dari babak pertama. ; Dan keadaan ini berlaku apabila kita tidak mempunyai unsur -unsur pada babak pertama dari B [] jadi kita mengembalikan elemen terakhir dalam [] dari babak pertama. ; mengira median. Jika bilangan elemen ganjil terdapat satu elemen tengah. ; Unsur -unsur dari [] pada babak kedua adalah set kosong. ; Unsur -unsur dari B [] pada babak kedua adalah set kosong. ; Kod pemacu; Kita perlu menentukan array yang lebih kecil sebagai parameter pertama untuk memastikan kerumitan masa akan O (log (min (n, m)))", "code": "< ? php $ median = 0 ; $ i = 0 ; $ j = 0 ; function maximum ( $ a , $ b ) { return $ a > $ b ? $ a : $ b ; } function minimum ( $ a , $ b ) { return $ a < $ b ? $ a : $ b ; } function findMedianSortedArrays ( & $ a , $ n , & $ b , $ m ) { global $ median , $ i , $ j ; $ min_index = 0 ; $ max_index = $ n ; while ( $ min_index <= $ max_index ) { $ i = intval ( ( $ min_index + $ max_index ) / 2 ) ; $ j = intval ( ( ( $ n + $ m + 1 ) / 2 ) - $ i ) ; if ( $ i < $ n && $ j > 0 && $ b [ $ j - 1 ] > $ a [ $ i ] ) $ min_index = $ i + 1 ; else if ( $ i > 0 && $ j < $ m && $ b [ $ j ] < $ a [ $ i - 1 ] ) $ max_index = $ i - 1 ; else { if ( $ i == 0 ) $ median = $ b [ $ j - 1 ] ; else if ( $ j == 0 ) $ median = $ a [ $ i - 1 ] ; else $ median = maximum ( $ a [ $ i - 1 ] , $ b [ $ j - 1 ] ) ; break ; } } if ( ( $ n + $ m ) % 2 == 1 ) return $ median ; if ( $ i == $ n ) return ( ( $ median + $ b [ $ j ] ) / 2.0 ) ; if ( $ j == $ m ) return ( ( $ median + $ a [ $ i ] ) / 2.0 ) ; return ( ( $ median + minimum ( $ a [ $ i ] , $ b [ $ j ] ) ) / 2.0 ) ; } $ a = array ( 900 ) ; $ b = array ( 10 , 13 , 14 ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; if ( $ n < $ m ) echo ( \" The ▁ median ▁ is ▁ : ▁ \" . findMedianSortedArrays ( $ a , $ n , $ b , $ m ) ) ; else echo ( \" The ▁ median ▁ is ▁ : ▁ \" . findMedianSortedArrays ( $ b , $ m , $ a , $ n ) ) ; ? >"}
{"text": "Cetak elemen yang tidak biasa dari dua susunan yang disusun | Program PHP untuk mencari unsur -unsur yang tidak biasa dari dua susunan yang disusun; Jika tidak biasa, prsmaller; Melangkau elemen biasa; mencetak elemen yang tinggal; Kod pemacu", "code": "< ? php function printUncommon ( $ arr1 , $ arr2 , $ n1 , $ n2 ) { $ i = 0 ; $ j = 0 ; $ k = 0 ; while ( $ i < $ n1 && $ j < $ n2 ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) { echo $ arr1 [ $ i ] . \" \" ; $ i ++ ; $ k ++ ; } else if ( $ arr2 [ $ j ] < $ arr1 [ $ i ] ) { echo $ arr2 [ $ j ] . \" \" ; $ k ++ ; $ j ++ ; } else { $ i ++ ; $ j ++ ; } } while ( $ i < $ n1 ) { echo $ arr1 [ $ i ] . \" \" ; $ i ++ ; $ k ++ ; } while ( $ j < $ n2 ) { echo $ arr2 [ $ j ] . \" \" ; $ j ++ ; $ k ++ ; } } $ arr1 = array ( 10 , 20 , 30 ) ; $ arr2 = array ( 20 , 25 , 30 , 40 , 50 ) ; $ n1 = sizeof ( $ arr1 ) ; $ n2 = sizeof ( $ arr2 ) ; printUncommon ( $ arr1 , $ arr2 , $ n1 , $ n2 ) ; ? >"}
{"text": "Unsur paling kerap dalam array | Program PHP untuk mencari elemen paling kerap dalam array. ; Susun array; Cari kekerapan min menggunakan traversal linear; Jika elemen terakhir adalah paling tidak kerap; Kod pemacu", "code": "< ? php function leastFrequent ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ min_count = $ n + 1 ; $ res = -1 ; $ curr_count = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) $ curr_count ++ ; else { if ( $ curr_count < $ min_count ) { $ min_count = $ curr_count ; $ res = $ arr [ $ i - 1 ] ; } $ curr_count = 1 ; } } if ( $ curr_count < $ min_count ) { $ min_count = $ curr_count ; $ res = $ arr [ $ n - 1 ] ; } return $ res ; } { $ arr = array ( 1 , 3 , 2 , 1 , 2 , 2 , 3 , 1 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo leastFrequent ( $ arr , $ n ) ; return 0 ; } ? >"}
{"text": "Jumlah maksimum unsur -unsur pesanan yang semakin meningkat dari N array | Program PHP untuk mencari jumlah maksimum dengan memilih elemen dari array N; Untuk mengira jumlah maksimum dengan memilih elemen dari setiap array; Menyusun setiap array; Simpan elemen maksimum array terakhir; Memilih elemen maksimum dari elemen yang dipilih sebelum ini; J = - 1 bermaksud tiada elemen yang terdapat dalam [i] jadi kembali 0; Kod pemacu", "code": "< ? php $ M = 4 ; function maximumSum ( $ a , $ n ) { global $ M ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) sort ( $ a [ $ i ] ) ; $ sum = $ a [ $ n - 1 ] [ $ M - 1 ] ; $ prev = $ a [ $ n - 1 ] [ $ M - 1 ] ; $ i ; $ j ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = $ M - 1 ; $ j >= 0 ; $ j -- ) { if ( $ a [ $ i ] [ $ j ] < $ prev ) { $ prev = $ a [ $ i ] [ $ j ] ; $ sum += $ prev ; break ; } } if ( $ j == -1 ) return 0 ; } return $ sum ; } $ arr = array ( array ( 1 , 7 , 3 , 4 ) , array ( 4 , 2 , 5 , 1 ) , array ( 9 , 5 , 1 , 8 ) ) ; $ n = sizeof ( $ arr ) ; echo maximumSum ( $ arr , $ n ) ; ? >"}
{"text": "Pasangan seperti itu adalah kuasa berganda yang lain | fungsi untuk mengira pasangan yang diperlukan; Susun array yang diberikan; untuk setiap array berehat [i] melintasi; Count AJ sedemikian rupa sehingga ai * k ^ x = aj; Meningkatkan X hingga Ai * k ^ x <= elemen terbesar; Kod pemacu", "code": "< ? php function countPairs ( $ A , $ n , $ k ) { $ ans = 0 ; sort ( $ A ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ x = 0 ; while ( ( $ A [ $ i ] * pow ( $ k , $ x ) ) <= $ A [ $ j ] ) { if ( ( $ A [ $ i ] * pow ( $ k , $ x ) ) == $ A [ $ j ] ) { $ ans ++ ; break ; } $ x ++ ; } } } return $ ans ; } $ A = array ( 3 , 8 , 9 , 12 , 18 , 4 , 24 , 2 , 6 ) ; $ n = count ( $ A ) ; $ k = 3 ; echo countPairs ( $ A , $ n , $ k ) ; ? >"}
{"text": "Jarak minimum antara dua kejadian maksimum | berfungsi untuk mengembalikan jarak min; kes a; kes b; kes c; Kod pemacu", "code": "< ? php function minDistance ( $ arr , $ n ) { $ maximum_element = $ arr [ 0 ] ; $ min_dis = $ n ; $ index = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ maximum_element == $ arr [ $ i ] ) { $ min_dis = min ( $ min_dis , ( $ i - $ index ) ) ; $ index = $ i ; } else if ( $ maximum_element < $ arr [ $ i ] ) { $ maximum_element = $ arr [ $ i ] ; $ min_dis = $ n ; $ index = $ i ; } else continue ; } return $ min_dis ; } $ arr = array ( 6 , 3 , 1 , 3 , 6 , 4 , 6 ) ; $ n = count ( $ arr ) ; echo \" Minimum ▁ distance ▁ = ▁ \" . minDistance ( $ arr , $ n ) ; ? >"}
{"text": "Cari nilai akhir jika kita berganda selepas setiap carian yang berjaya dalam array | Fungsi untuk mencari nilai k; Cari k. Selepas setiap carian yang berjaya, double k. ; Kod pemacu", "code": "< ? php function findValue ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ k ) $ k *= 2 ; return $ k ; } $ arr = array ( 2 , 3 , 4 , 10 , 8 , 1 ) ; $ k = 2 ; $ n = count ( $ arr ) ; echo findValue ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Elemen pendua terakhir dalam array yang disusun | Program PHP untuk mencetak elemen pendua terakhir dan indeksnya dalam array yang disusun; Jika array adalah batal atau saiz kurang daripada sama dengan 0 pulangan; Bandingkan unsur -unsur dan kembalikan pendua terakhir dan indeksnya; Jika kita sampai di sini, maka tidak ada pendua yang dijumpai. ; Kod pemacu", "code": "< ? php function dupLastIndex ( $ arr , $ n ) { if ( $ arr == null or $ n <= 0 ) return ; for ( $ i = $ n - 1 ; $ i > 0 ; $ i -- ) { if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) { echo \" Last ▁ index : \" , $ i , \" STRNEWLINE \" ; echo \" Last ▁ duplicate ▁ item : \" , $ arr [ $ i ] ; return ; } } echo \" no ▁ duplicate ▁ found \" ; } $ arr = array ( 1 , 5 , 5 , 6 , 6 , 7 , 9 ) ; $ n = count ( $ arr ) ; dupLastIndex ( $ arr , $ n ) ; ? >"}
{"text": "Cari elemen array supaya semua elemen boleh dibahagikan olehnya | berfungsi untuk mencari nombor terkecil; melintasi semua elemen; menyimpan minimum jika ia membahagikan semua; Kod pemacu", "code": "< ? php function findSmallest ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ j ] % $ a [ $ i ] ) break ; if ( $ j == $ n ) return $ a [ $ i ] ; } return -1 ; } $ a = array ( 25 , 20 , 5 , 10 , 100 ) ; $ n = sizeof ( $ a ) ; echo findSmallest ( $ a , $ n ) ; ? >"}
{"text": "Cari elemen array supaya semua elemen boleh dibahagikan olehnya | berfungsi untuk mencari nombor terkecil; Cari elemen terkecil; Semak sama ada semua elemen array boleh dibahagikan dengan terkecil. ; Kod pemacu", "code": "< ? php function findSmallest ( $ a , $ n ) { $ smallest = min ( $ a ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] % $ smallest ) return -1 ; return $ smallest ; } $ a = array ( 25 , 20 , 5 , 10 , 100 ) ; $ n = count ( $ a ) ; echo findSmallest ( $ a , $ n ) ; ? >"}
{"text": "Maksimum dalam pelbagai yang berada di | Berfungsi untuk mencari indeks elemen max yang memenuhi syarat; Mencari indeks max array; Pulangan - 1 Jika elemen maksimum tidak dua kali dari elemen i - th. ; Kod pemacu", "code": "< ? php function findIndex ( $ arr , $ len ) { $ maxIndex = 0 ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) if ( $ arr [ $ i ] > $ arr [ $ maxIndex ] ) $ maxIndex = $ i ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) if ( $ maxIndex != $ i and $ arr [ $ maxIndex ] < 2 * $ arr [ $ i ] ) return -1 ; return $ maxIndex ; } $ arr = array ( 3 , 6 , 1 , 0 ) ; $ len = count ( $ arr ) ; echo findIndex ( $ arr , $ len ) ; ? >"}
{"text": "Langkah berturut -turut ke atas bumbung | Fungsi untuk mengira langkah berturut -turut; mengira bilangan bangunan ketinggian yang semakin meningkat berturut -turut; Kod pemacu", "code": "< ? php function find_consecutive_steps ( $ arr , $ len ) { $ count = 0 ; $ maximum = 0 ; for ( $ index = 1 ; $ index < $ len ; $ index ++ ) { if ( $ arr [ $ index ] > $ arr [ $ index - 1 ] ) $ count ++ ; else { $ maximum = max ( $ maximum , $ count ) ; $ count = 0 ; } } return max ( $ maximum , $ count ) ; } $ arr = array ( 1 , 2 , 3 , 4 ) ; $ len = count ( $ arr ) ; echo find_consecutive_steps ( $ arr , $ len ) ; ? >"}
{"text": "Perbezaan maksimum antara kumpulan saiz dua | Program PHP untuk mencari perbezaan minimum antara kumpulan jumlah tertinggi dan terendah. ; Menyusun keseluruhan array. ; Kod pemacu", "code": "< ? php function CalculateMax ( $ arr , $ n ) { sort ( $ arr ) ; $ min_sum = $ arr [ 0 ] + $ arr [ 1 ] ; $ max_sum = $ arr [ $ n - 1 ] + $ arr [ $ n - 2 ] ; return abs ( $ max_sum - $ min_sum ) ; } $ arr = array ( 6 , 7 , 1 , 11 ) ; $ n = sizeof ( $ arr ) ; echo CalculateMax ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Perbezaan minimum antara kumpulan saiz dua | Program PHP untuk mencari perbezaan minimum antara kumpulan jumlah tertinggi dan terendah. ; Menyusun keseluruhan array. ; Menjana kumpulan jumlah. ; Kod pemacu", "code": "< ? php function calculate ( $ a , $ n ) { sort ( $ a ) ; $ s = array ( ) ; for ( $ i = 0 , $ j = $ n - 1 ; $ i < $ j ; $ i ++ , $ j -- ) array_push ( $ s , ( $ a [ $ i ] + $ a [ $ j ] ) ) ; $ mini = min ( $ s ) ; $ maxi = max ( $ s ) ; return abs ( $ maxi - $ mini ) ; } $ a = array ( 2 , 6 , 4 , 3 ) ; $ n = sizeof ( $ a ) ; echo calculate ( $ a , $ n ) ; ? >"}
{"text": "Nombor terdekat dari senarai bilangan bulat yang tidak disusun | Mengembalikan perbezaan minimum antara mana -mana dua pasangan dalam ARR [0. n - 1]; Susun elemen array; Bandingkan perbezaan pasangan bersebelahan untuk mencari perbezaan minimum. ; TRAVERSE Array sekali lagi dan cetak semua pasangan dengan perbezaan sebagai Mindiff. ; Kod pemacu", "code": "< ? php function printMinDiffPairs ( $ arr , $ n ) { if ( $ n <= 1 ) return ; sort ( $ arr ) ; $ minDiff = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ minDiff = min ( $ minDiff , $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) == $ minDiff ) echo \" ( \" , $ arr [ $ i - 1 ] , \" , ▁ \" , $ arr [ $ i ] , \" ) , ▁ \" ; } $ arr = array ( 5 , 3 , 2 , 4 , 1 ) ; $ n = sizeof ( $ arr ) ; printMinDiffPairs ( $ arr , $ n ) ; ? >"}
{"text": "Perbezaan maksimum nilai dan jumlah indeks | Program PHP kekerasan untuk mengira perbezaan mutlak maksimum array. ; Fungsi utiliti untuk mengira nilai perbezaan mutlak untuk pasangan (i, j). ; Fungsi untuk mengembalikan perbezaan mutlak maksimum dalam daya brute. ; Pembolehubah untuk menyimpan jarak mutlak maksimum sepanjang traversal gelung. ; Melangkah melalui semua pasangan. ; Jika perbezaan mutlak pasangan semasa (i, j) adalah lebih besar daripada perbezaan maksimum yang dikira sehingga sekarang, kemas kini nilai hasil. ; Kod pemacu", "code": "< ? php function calculateDiff ( $ i , $ j , $ arr ) { return abs ( $ arr [ $ i ] - $ arr [ $ j ] ) + abs ( $ i - $ j ) ; } function maxDistance ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { if ( calculateDiff ( $ i , $ j , $ arr ) > $ result ) $ result = calculateDiff ( $ i , $ j , $ arr ) ; } } return $ result ; } $ arr = array ( -70 , -64 , -6 , -56 , 64 , 61 , -57 , 16 , 48 , -98 ) ; $ n = sizeof ( $ arr ) ; echo maxDistance ( $ arr , $ n ) ; ? >"}
{"text": "Perbezaan maksimum nilai dan jumlah indeks | Berfungsi untuk mengembalikan perbezaan mutlak maksimum dalam masa linear. ; Pembolehubah maksimum dan min seperti yang diterangkan dalam algoritma. ; Mengemas kini pembolehubah max dan min seperti yang diterangkan dalam algoritma. ; Mengira perbezaan mutlak maksimum. ; Kod pemacu", "code": "< ? php function maxDistance ( $ arr , $ n ) { $ max1 = PHP_INT_MIN ; $ min1 = PHP_INT_MAX ; $ max2 = PHP_INT_MIN ; $ min2 = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ max1 = max ( $ max1 , $ arr [ $ i ] + $ i ) ; $ min1 = min ( $ min1 , $ arr [ $ i ] + $ i ) ; $ max2 = max ( $ max2 , $ arr [ $ i ] - $ i ) ; $ min2 = min ( $ min2 , $ arr [ $ i ] - $ i ) ; } return max ( $ max1 - $ min1 , $ max2 - $ min2 ) ; } $ arr = array ( -70 , -64 , -6 , -56 , 64 , 61 , -57 , 16 , 48 , -98 ) ; $ n = count ( $ arr ) ; echo maxDistance ( $ arr , $ n ) ; ? >"}
{"text": "Bilangan ekstrem tempatan dalam array | berfungsi untuk mencari ekstrem tempatan; Mula gelung dari kedudukan 1 hingga n - 1; Semak jika [i] lebih besar daripada kedua -dua jirannya kemudian tambah 1 ke x; Semak jika [i] kurang daripada kedua -dua jirannya, kemudian tambah 1 ke x; Kod pemacu", "code": "< ? php function extrema ( $ a , $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ count += ( $ a [ $ i ] > $ a [ $ i - 1 ] and $ a [ $ i ] > $ a [ $ i + 1 ] ) ; $ count += ( $ a [ $ i ] < $ a [ $ i - 1 ] and $ a [ $ i ] < $ a [ $ i + 1 ] ) ; } return $ count ; } $ a = array ( 1 , 0 , 2 , 1 ) ; $ n = count ( $ a ) ; echo extrema ( $ a , $ n ) ; ? >"}
{"text": "Cari nombor terdekat dalam Array | Mengembalikan elemen yang paling dekat dengan sasaran dalam arr []; Kes sudut; Melakukan carian binari; Jika sasaran kurang daripada elemen array, maka cari di sebelah kiri; Jika sasaran lebih besar daripada sebelumnya hingga pertengahan, kembali paling dekat dengan dua; Ulangi separuh kiri; Jika sasaran lebih besar daripada pertengahan; Kemas kini i; Hanya elemen tunggal yang tersisa selepas carian; Kaedah untuk membandingkan mana yang lebih dekat. Kami mendapati yang paling dekat dengan mengambil perbezaan antara sasaran dan kedua -dua nilai. Ia mengandaikan bahawa Val2 lebih besar daripada Val1 dan sasaran terletak di antara kedua -dua mereka. ; Kod pemacu", "code": "< ? php function findClosest ( $ arr , $ n , $ target ) { if ( $ target <= $ arr [ 0 ] ) return $ arr [ 0 ] ; if ( $ target >= $ arr [ $ n - 1 ] ) return $ arr [ $ n - 1 ] ; $ i = 0 ; $ j = $ n ; $ mid = 0 ; while ( $ i < $ j ) { $ mid = ( $ i + $ j ) / 2 ; if ( $ arr [ $ mid ] == $ target ) return $ arr [ $ mid ] ; if ( $ target < $ arr [ $ mid ] ) { if ( $ mid > 0 && $ target > $ arr [ $ mid - 1 ] ) return getClosest ( $ arr [ $ mid - 1 ] , $ arr [ $ mid ] , $ target ) ; $ j = $ mid ; } else { if ( $ mid < $ n - 1 && $ target < $ arr [ $ mid + 1 ] ) return getClosest ( $ arr [ $ mid ] , $ arr [ $ mid + 1 ] , $ target ) ; $ i = $ mid + 1 ; } } return $ arr [ $ mid ] ; } function getClosest ( $ val1 , $ val2 , $ target ) { if ( $ target - $ val1 >= $ val2 - $ target ) return $ val2 ; else return $ val1 ; } $ arr = array ( 1 , 2 , 4 , 5 , 6 , 6 , 8 , 9 ) ; $ n = sizeof ( $ arr ) ; $ target = 11 ; echo ( findClosest ( $ arr , $ n , $ target ) ) ; ? >"}
{"text": "Bilangan pasangan dengan jumlah maksimum | berfungsi untuk mencari bilangan jumlah pasangan maksimum; melintasi semua pasangan; melintasi semua pasangan dan menyimpan kiraan bilangan pasangan maksimum; Kod pemacu", "code": "< ? php function sum ( $ a , $ n ) { $ maxSum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ maxSum = max ( $ maxSum , $ a [ $ i ] + $ a [ $ j ] ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ i ] + $ a [ $ j ] == $ maxSum ) $ c ++ ; return $ c ; } $ array = array ( 1 , 1 , 1 , 2 , 2 , 2 ) ; $ n = count ( $ array ) ; echo sum ( $ array , $ n ) ; ? >"}
{"text": "Bilangan pasangan dengan jumlah maksimum | berfungsi untuk mencari bilangan jumlah pasangan maksimum; Cari elemen maksimum maksimum dan kedua. Juga cari tuduhan mereka. ; Jika elemen maksimum muncul lebih dari sekali. ; Jika elemen maksimum muncul sekali sahaja. ; Kod pemacu", "code": "< ? php function sum ( $ a , $ n ) { $ maxVal = $ a [ 0 ] ; $ maxCount = 1 ; $ secondMax = PHP_INT_MIN ; $ secondMaxCount ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ maxVal ) $ maxCount ++ ; else if ( $ a [ $ i ] > $ maxVal ) { $ secondMax = $ maxVal ; $ secondMaxCount = $ maxCount ; $ maxVal = $ a [ $ i ] ; $ maxCount = 1 ; } else if ( $ a [ $ i ] == $ secondMax ) { $ secondMax = $ a [ $ i ] ; $ secondMaxCount ++ ; } else if ( $ a [ $ i ] > $ secondMax ) { $ secondMax = $ a [ $ i ] ; $ secondMaxCount = 1 ; } } if ( $ maxCount > 1 ) return $ maxCount * ( $ maxCount - 1 ) / 2 ; return $ secondMaxCount ; } $ array = array ( 1 , 1 , 1 , 2 , 2 , 2 , 3 ) ; $ n = count ( $ array ) ; echo sum ( $ array , $ n ) ; ? >"}
{"text": "Cari nombor semulajadi k pertama yang hilang dalam array yang diberikan | Cetak nombor semulajadi k pertama di arr [0. n - 1]; Cari nombor positif pertama; Sekarang cari nombor yang hilang antara elemen array; Cari nombor yang hilang selepas maksimum. ; Kod pemacu", "code": "< ? php function printKMissing ( $ arr , $ n , $ k ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ i = 0 ; while ( $ i < $ n && $ arr [ $ i ] <= 0 ) $ i ++ ; $ count = 0 ; $ curr = 1 ; while ( $ count < $ k && $ i < $ n ) { if ( $ arr [ $ i ] != $ curr ) { echo $ curr , \" \" ; $ count ++ ; } else $ i ++ ; $ curr ++ ; } while ( $ count < $ k ) { echo $ curr , \" \" ; $ curr ++ ; $ count ++ ; } } $ arr = array ( 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; printKMissing ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Integer mulia dalam array (kiraan elemen yang lebih besar adalah sama dengan nilai) | Mengembalikan integer mulia jika ada, yang lain kembali - 1 .; Jika mengira unsur -unsur yang lebih besar adalah sama dengan arr [i]; Kod pemacu", "code": "< ? php function nobleInteger ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ size ; $ j ++ ) if ( $ arr [ $ i ] < $ arr [ $ j ] ) $ count ++ ; if ( $ count == $ arr [ $ i ] ) return $ arr [ $ i ] ; } return -1 ; } $ arr = array ( 10 , 3 , 20 , 40 , 2 ) ; $ size = count ( $ arr ) ; $ res = nobleInteger ( $ arr , $ size ) ; if ( $ res != -1 ) echo \" The ▁ noble ▁ integer ▁ is ▁ \" , $ res ; else echo \" No ▁ Noble ▁ Integer ▁ Found \" ; ? >"}
{"text": "Integer mulia dalam array (kiraan elemen yang lebih besar adalah sama dengan nilai) | Mengembalikan integer mulia jika ada, yang lain kembali - 1 .; Kembalikan elemen mulia jika hadir sebelum terakhir. ; Sekiranya pendua, kita mencapai kejadian terakhir di sini. ; Kod pemacu", "code": "< ? php function nobleInteger ( $ arr ) { sort ( $ arr ) ; $ n = count ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) continue ; if ( $ arr [ $ i ] == $ n - $ i - 1 ) return $ arr [ $ i ] ; } if ( $ arr [ $ n - 1 ] == 0 ) return $ arr [ $ n - 1 ] ; return -1 ; } $ arr = array ( 10 , 3 , 20 , 40 , 2 ) ; $ res = nobleInteger ( $ arr ) ; if ( $ res != -1 ) echo \" The ▁ noble ▁ integer ▁ is ▁ \" , $ res ; else echo \" No ▁ Noble ▁ Integer ▁ Found \" ; ? >"}
{"text": "Jumlah minimum perbezaan mutlak pasangan dua tatasusunan | Mengembalikan minimum mungkin perbezaan mutlak pasangan dua tatasusunan. ; Menyusun kedua -dua tatasusunan; Cari jumlah perbezaan mutlak; Kedua -dua [] dan B [] mestilah saiz yang sama.", "code": "< ? php function findMinSum ( $ a , $ b , $ n ) { sort ( $ a ) ; sort ( $ a , $ n ) ; sort ( $ b ) ; sort ( $ b , $ n ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; return $ sum ; } $ a = array ( 4 , 1 , 8 , 7 ) ; $ b = array ( 2 , 3 , 6 , 5 ) ; $ n = sizeof ( $ a ) ; echo ( findMinSum ( $ a , $ b , $ n ) ) ; ? >"}
{"text": "Subset produk minimum array | Berfungsi untuk mencari produk maksimum subset; Cari kiraan nombor negatif, kiraan sifar, nombor negatif yang bernilai maksimum, bilangan positif yang bernilai minimum dan produk nombor sifar; Sekiranya nombor adalah 0, kami tidak membiaknya dengan produk. ; Kira negatif dan menjejaki negatif yang bernilai maksimum. ; Menjejaki bilangan array minimum; Sekiranya terdapat semua sifar atau tiada nombor negatif yang ada; Sekiranya ada yang positif; Sekiranya terdapat bilangan nombor negatif dan count_neg bukan 0; Jika tidak, hasilnya adalah produk semua non - nol yang dibahagikan dengan negatif yang bernilai maksimum. ; Kod pemacu", "code": "< ? php function minProductSubset ( $ a , $ n ) { if ( $ n == 1 ) return $ a [ 0 ] ; $ max_neg = PHP_INT_MIN ; $ min_pos = PHP_INT_MAX ; $ count_neg = 0 ; $ count_zero = 0 ; $ prod = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 0 ) { $ count_zero ++ ; continue ; } if ( $ a [ $ i ] < 0 ) { $ count_neg ++ ; $ max_neg = max ( $ max_neg , $ a [ $ i ] ) ; } if ( $ a [ $ i ] > 0 ) $ min_pos = min ( $ min_pos , $ a [ $ i ] ) ; $ prod = $ prod * $ a [ $ i ] ; } if ( $ count_zero == $ n || ( $ count_neg == 0 && $ count_zero > 0 ) ) return 0 ; if ( $ count_neg == 0 ) return $ min_pos ; if ( ! ( $ count_neg & 1 ) && $ count_neg != 0 ) { $ prod = $ prod / $ max_neg ; } return $ prod ; } $ a = array ( -1 , -1 , -2 , 4 , 3 ) ; $ n = sizeof ( $ a ) ; echo ( minProductSubset ( $ a , $ n ) ) ; ? >"}
{"text": "Berulang kali mencari elemen dengan menggandakannya selepas setiap carian yang berjaya | Program PHP berulang kali mencari elemen dengan menggandakannya selepas setiap carian yang berjaya; Susun array yang diberikan supaya carian binari boleh digunakan di atasnya; Elemen array maksimum; Cari elemen B hadir atau tidak dalam array; Kod pemacu", "code": "< ? php function binary_search ( $ a , $ x , $ lo = 0 , $ hi = NULL ) { if ( $ hi == NULL ) $ hi = count ( $ a ) ; while ( $ lo < $ hi ) { $ mid = ( $ lo + $ hi ) / 2 ; $ midval = $ a [ $ mid ] ; if ( $ midval < $ x ) $ lo = $ mid + 1 ; else if ( $ midval > $ x ) $ hi = $ mid ; else return $ mid ; } return -1 ; } function findElement ( $ a , $ n , $ b ) { sort ( $ a ) ; $ mx = $ a [ $ n - 1 ] ; while ( $ b < max ( $ a ) ) { if ( binary_search ( $ a , $ b , 0 , $ n ) != -1 ) $ b *= 2 ; else return $ b ; } return $ b ; } $ a = array ( 1 , 2 , 3 ) ; $ n = count ( $ a ) ; $ b = 1 ; echo findElement ( $ a , $ n , $ b ) ; ? >"}
{"text": "Jumlah maksimum produk pasangan dalam array dengan negatif dibenarkan | Program PHP untuk pelaksanaan di atas; Berfungsi untuk mencari jumlah maksimum; Susun array terlebih dahulu; Pertama kali ganda nombor negatif berpasangan dan meringkaskan dari permulaan untuk mendapatkan jumlah maksimum. ; Kedua membiak nombor positif pasangan dan disimpulkan dari yang terakhir untuk mendapatkan jumlah maksimum. ; Untuk mengendalikan kes jika nombor positif dan negatif kedua -duanya adalah ganjil dalam tuduhan. ; Jika salah satu daripada mereka berlaku masa yang ganjil; Kod pemacu", "code": "< ? php $ Mod = 1000000007 ; function findSum ( & $ arr , $ n ) { global $ Mod ; $ sum = 0 ; sort ( $ arr ) ; $ i = 0 ; while ( $ i < $ n && $ arr [ $ i ] < 0 ) { if ( $ i != $ n - 1 && $ arr [ $ i + 1 ] <= 0 ) { $ sum = ( $ sum + ( $ arr [ $ i ] * $ arr [ $ i + 1 ] ) % $ Mod ) % $ Mod ; $ i += 2 ; } else break ; } $ j = $ n - 1 ; while ( $ j >= 0 && $ arr [ $ j ] > 0 ) { if ( $ j != 0 && $ arr [ $ j - 1 ] > 0 ) { $ sum = ( $ sum + ( $ arr [ $ j ] * $ arr [ $ j - 1 ] ) % $ Mod ) % $ Mod ; $ j -= 2 ; } else break ; } if ( $ j > $ i ) $ sum = ( $ sum + ( $ arr [ $ i ] * $ arr [ $ j ] ) % $ Mod ) % $ Mod ; else if ( $ i == $ j ) $ sum = ( $ sum + $ arr [ $ i ] ) % Mod ; return $ sum ; } $ arr = array ( -1 , 9 , 4 , 5 , -4 , 7 ) ; $ n = sizeof ( $ arr ) ; echo findSum ( $ arr , $ n ) ; ? >"}
{"text": "Kira putaran N yang ganjil dan bahkan | Fungsi untuk mengira semua putaran yang ganjil dan bahkan; Kod pemacu", "code": "< ? php function countOddRotations ( $ n ) { $ odd_count = 0 ; $ even_count = 0 ; do { $ digit = $ n % 10 ; if ( $ digit % 2 == 1 ) $ odd_count ++ ; else $ even_count ++ ; $ n = ( int ) ( $ n / 10 ) ; } while ( $ n != 0 ) ; echo \" Odd = \" , ▁ $ odd _ count , ▁ \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" Even = \" , ▁ $ even _ count , ▁ \" \" } $ n = 1234 ; countOddRotations ( $ n ) ; ? >"}
{"text": "Menjana semua putaran nombor | Berfungsi untuk mengembalikan kiraan digit n; Berfungsi untuk mencetak nombor peralihan kiri; Formula untuk mengira peralihan kiri dari nombor sebelumnya; Mengemas kini nombor asal; Kod pemacu", "code": "< ? php function numberOfDigits ( $ n ) { $ cnt = 0 ; while ( $ n > 0 ) { $ cnt ++ ; $ n = floor ( $ n / 10 ) ; } return $ cnt ; } function cal ( $ num ) { $ digits = numberOfDigits ( $ num ) ; $ powTen = pow ( 10 , $ digits - 1 ) ; for ( $ i = 0 ; $ i < $ digits - 1 ; $ i ++ ) { $ firstDigit = floor ( $ num / $ powTen ) ; $ left = ( ( $ num * 10 ) + $ firstDigit ) - ( $ firstDigit * $ powTen * 10 ) ; echo $ left , \" \" ; $ num = $ left ; } } $ num = 1445 ; cal ( $ num ) ; ? >"}
{"text": "Semak sama ada semua putaran nombor tertentu adalah lebih besar daripada atau sama dengan nombor yang diberikan atau tidak | Pelaksanaan PHP pendekatan; Memisahkan nombor pada indeks I dan menambah ke hadapan; Memeriksa jika nilai lebih besar daripada atau sama dengan nilai yang diberikan; Kod pemacu", "code": "< ? php function CheckKCycles ( $ n , $ s ) { $ ff = true ; $ x = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ x = strlen ( substr ( $ s , $ i ) . substr ( $ s , 0 , $ i ) ) ; if ( $ x >= strlen ( $ s ) ) { continue ; } $ ff = false ; break ; } if ( $ ff ) { print ( \" Yes \" ) ; } else { print ( \" No \" ) ; } } $ n = 3 ; $ s = \"123\" ; CheckKCycles ( $ n , $ s ) ; ? >"}
{"text": "Menjana nombor yang menjadi pembahagi hak mereka | Fungsi untuk memeriksa sama ada n adalah pembahagi kanannya - putaran; Berfungsi untuk menjana nombor M - digit yang merupakan pembahagi hak mereka - putaran; Kod pemacu", "code": "< ? php function rightRotationDivisor ( $ N ) { $ lastDigit = $ N % 10 ; $ rightRotation = ( $ lastDigit * pow ( 10 , ( int ) ( log10 ( $ N ) ) ) ) + floor ( $ N / 10 ) ; return ( $ rightRotation % $ N == 0 ) ; } function generateNumbers ( $ m ) { for ( $ i = pow ( 10 , ( $ m - 1 ) ) ; $ i < pow ( 10 , $ m ) ; $ i ++ ) if ( rightRotationDivisor ( $ i ) ) echo $ i . \" STRNEWLINE \" ; } $ m = 3 ; generateNumbers ( $ m ) ; ? >"}
{"text": "Semak jika array disusun dan diputar | Berfungsi untuk memeriksa sama ada array disusun dan diputar mengikut arah jam; Cari elemen minimum dan indeksnya; Semak sama ada semua elemen sebelum MinIndex berada dalam urutan yang semakin meningkat; Semak sama ada semua elemen selepas Minindex berada dalam urutan yang semakin meningkat; Semak sama ada elemen terakhir array lebih kecil daripada elemen yang hanya memulakan elemen array untuk tatasusunan seperti [3, 4, 6, 1, 2, 5] - tidak disusun array bulat; Kod pemacu; Panggilan fungsi", "code": "< ? php function checkIfSortRotated ( $ arr , $ n ) { $ minEle = PHP_INT_MAX ; $ maxEle = PHP_INT_MIN ; $ minIndex = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ minEle ) { $ minEle = $ arr [ $ i ] ; $ minIndex = $ i ; } } $ flag1 = 1 ; for ( $ i = 1 ; $ i < $ minIndex ; $ i ++ ) { if ( $ arr [ $ i ] < $ arr [ $ i - 1 ] ) { $ flag1 = 0 ; break ; } } $ flag2 = 1 ; for ( $ i = $ minIndex + 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ arr [ $ i - 1 ] ) { $ flag2 = 0 ; break ; } } if ( $ flag1 && $ flag2 && ( $ arr [ $ n - 1 ] < $ arr [ $ 0 ] ) ) echo ( \" YES \" ) ; else echo ( \" NO \" ) ; } $ arr = array ( 3 , 4 , 5 , 1 , 2 ) ; $ n = count ( $ arr ) ; checkIfSortRotated ( $ arr , $ n ) ; ? >"}
{"text": "Unsur -unsur yang berlaku hanya sekali dalam array | Fungsi untuk mencari unsur -unsur yang muncul hanya sekali dalam array; Susun array; Semak elemen pertama; Semak semua elemen jika ia berbeza unsur -unsur bersebelahannya; Semak elemen terakhir; Kod pemacu", "code": "< ? php function occurredOnce ( & $ arr , $ n ) { sort ( $ arr ) ; if ( $ arr [ 0 ] != $ arr [ 1 ] ) echo $ arr [ 0 ] . \" ▁ \" ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] && $ arr [ $ i ] != $ arr [ $ i - 1 ] ) echo $ arr [ $ i ] . \" ▁ \" ; if ( $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) echo $ arr [ $ n - 1 ] . \" ▁ \" ; } $ arr = array ( 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 ) ; $ n = sizeof ( $ arr ) ; occurredOnce ( $ arr , $ n ) ; ? >"}
{"text": "Unsur -unsur yang berlaku hanya sekali dalam array | Fungsi untuk mencari unsur -unsur yang muncul hanya sekali dalam array; Semak sama ada elemen pertama dan terakhir adalah sama. Jika ya, keluarkan unsur -unsur tersebut; Mula melintasi unsur -unsur yang tersisa; Semak jika elemen semasa adalah sama dengan elemen pada indeks terdahulu jika ya, periksa yang sama untuk elemen seterusnya; Lain mencetak elemen semasa; Semak elemen terakhir; Kod pemacu", "code": "< ? php function occurredOnce ( & $ arr , $ n ) { $ i = 1 ; $ len = $ n ; if ( $ arr [ 0 ] == $ arr [ $ len - 1 ] ) { $ i = 2 ; $ len -- ; } for ( ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) $ i ++ ; else echo $ arr [ $ i - 1 ] . \" ▁ \" ; if ( $ arr [ $ n - 1 ] != $ arr [ 0 ] && $ arr [ $ n - 1 ] != $ arr [ $ n - 2 ] ) echo $ arr [ $ n - 1 ] ; } $ arr = array ( 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 ) ; $ n = sizeof ( $ arr ) ; occurredOnce ( $ arr , $ n ) ; ? >"}
{"text": "Pecahkan array dan tambahkan bahagian pertama hingga akhir | Tetapkan 2 | Fungsi untuk membalikkan arr [] dari indeks mula berakhir; Berfungsi untuk mencetak array; Berfungsi ke kiri berputar arr [] saiz n oleh k; Program pemacu untuk menguji fungsi di atas; Fungsi panggilan", "code": "< ? php function rvereseArray ( & $ arr , $ start , $ end ) { while ( $ start < $ end ) { $ temp = $ arr [ $ start ] ; $ arr [ $ start ] = $ arr [ $ end ] ; $ arr [ $ end ] = $ temp ; $ start ++ ; $ end -- ; } } function printArray ( & $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } function splitArr ( & $ arr , $ k , $ n ) { rvereseArray ( $ arr , 0 , $ n - 1 ) ; rvereseArray ( $ arr , 0 , $ n - $ k - 1 ) ; rvereseArray ( $ arr , $ n - $ k , $ n - 1 ) ; } $ arr = array ( 12 , 10 , 5 , 6 , 52 , 36 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; splitArr ( $ arr , $ k , $ n ) ; printArray ( $ arr , $ n ) ; ? >"}
{"text": "Kiraan putaran dibahagi dengan 8 | berfungsi untuk mengira semua putaran yang boleh dibahagikan dengan 8; Untuk nombor digit tunggal; Untuk nombor dua digit (mempertimbangkan semua pasangan); pasangan pertama; pasangan kedua; Memandangkan ketiga -tiga urutan digit; Memandangkan nombor yang dibentuk oleh digit terakhir dan dua digit pertama; Memandangkan nombor yang dibentuk oleh dua digit terakhir dan digit pertama; kiraan putaran yang diperlukan; Kod pemacu", "code": "< ? php function countRotationsDivBy8 ( $ n ) { $ len = strlen ( $ n ) ; $ count = 0 ; if ( $ len == 1 ) { $ oneDigit = $ n [ 0 ] - '0' ; if ( $ oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( $ len == 2 ) { $ first = ( $ n [ 0 ] - '0' ) * 10 + ( $ n [ 1 ] - '0' ) ; $ second = ( $ n [ 1 ] - '0' ) * 10 + ( $ n [ 0 ] - '0' ) ; if ( $ first % 8 == 0 ) $ count ++ ; if ( $ second % 8 == 0 ) $ count ++ ; return $ count ; } $ threeDigit ; for ( $ i = 0 ; $ i < ( $ len - 2 ) ; $ i ++ ) { $ threeDigit = ( $ n [ $ i ] - '0' ) * 100 + ( $ n [ $ i + 1 ] - '0' ) * 10 + ( $ n [ $ i + 2 ] - '0' ) ; if ( $ threeDigit % 8 == 0 ) $ count ++ ; } $ threeDigit = ( $ n [ $ len - 1 ] - '0' ) * 100 + ( $ n [ 0 ] - '0' ) * 10 + ( $ n [ 1 ] - '0' ) ; if ( $ threeDigit % 8 == 0 ) $ count ++ ; $ threeDigit = ( $ n [ $ len - 2 ] - '0' ) * 100 + ( $ n [ $ len - 1 ] - '0' ) * 10 + ( $ n [ 0 ] - '0' ) ; if ( $ threeDigit % 8 == 0 ) $ count ++ ; return $ count ; } $ n = \"43262488612\" ; echo \" Rotations : ▁ \" . countRotationsDivBy8 ( $ n ) ; ? >"}
{"text": "Semak jika dua nombor adalah putaran bit antara satu sama lain atau tidak | fungsi untuk memeriksa sama ada dua nombor adalah sama selepas putaran bit; X64 mempunyai penggabungan x dengan sendirinya. ; Comapring hanya 32 bit terakhir; Peralihan kanan oleh 1 unit; Kod pemacu", "code": "< ? php function isRotation ( $ x , $ y ) { $ x64 = $ x | ( $ x << 32 ) ; while ( $ x64 >= $ y ) { if ( ( $ x64 ) == $ y ) return 1 ; $ x64 >>= 1 ; } return -1 ; } $ x = 122 ; $ y = 2147483678 ; if ( isRotation ( $ x , $ y ) ) echo \" yes \" , \" STRNEWLINE \" ; else echo \" no \" , \" STRNEWLINE \" ; ? >"}
{"text": "Kiraan putaran dibahagikan dengan 4 | Mengembalikan kiraan semua putaran yang boleh dibahagikan dengan 4; Untuk nombor digit tunggal; Sekurang -kurangnya 2 nombor digit (mempertimbangkan semua pasangan); Memandangkan bilangan yang dibentuk oleh pasangan digit terakhir dan 1 digit; Kod pemacu", "code": "< ? php function countRotations ( $ n ) { $ len = strlen ( $ n ) ; if ( $ len == 1 ) { $ oneDigit = $ n [ 0 ] - '0' ; if ( $ oneDigit % 4 == 0 ) return 1 ; return 0 ; } $ twoDigit ; $ count = 0 ; for ( $ i = 0 ; $ i < ( $ len - 1 ) ; $ i ++ ) { $ twoDigit = ( $ n [ $ i ] - '0' ) * 10 + ( $ n [ $ i + 1 ] - '0' ) ; if ( $ twoDigit % 4 == 0 ) $ count ++ ; } $ twoDigit = ( $ n [ $ len - 1 ] - '0' ) * 10 + ( $ n [ 0 ] - '0' ) ; if ( $ twoDigit % 4 == 0 ) $ count ++ ; return $ count ; } $ n = \"4834\" ; echo \" Rotations : ▁ \" , countRotations ( $ n ) ; ? >"}
{"text": "Panjang maksimum subarray sedemikian rupa sehingga jumlah subarray bahkan | Berfungsi untuk mencari panjang subarray terpanjang seperti jumlah subarray adalah walaupun; Semak sama ada jumlah array lengkap juga; jika ($ sum % 2 == 0) Jumlah jumlah sudah pun; Cari indeks saya seperti [i] adalah ganjil dan bandingkan panjang kedua -dua separuh tidak termasuk [i] untuk mencari subarray panjang maksimum; Kod pemacu", "code": "< ? php function maxLength ( $ a , $ n ) { $ sum = 0 ; $ len = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; return $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 == 1 ) $ len = max ( $ len , $ max ( $ n - $ i - 1 , $ i ) ) ; } return $ len ; } $ a = array ( 1 , 2 , 3 , 2 ) ; $ n = count ( $ a ) ; echo maxLength ( $ a , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari matriks simetri pesanan n yang mengandungi bilangan bulat dari 0 hingga n | Berfungsi untuk menghasilkan matriks yang diperlukan; Bentuk pelbagai unsur siklik 1 hingga n - 1; Simpan array awal ke dalam array akhir; Isi baris dan lajur terakhir dengan 0; Swap 0 dan nombor yang hadir pada baris diindeks semasa; Juga membuat perubahan dalam baris terakhir dengan nombor yang kami bertukar; Cetak array akhir; Kod pemacu", "code": "< ? php function solve ( $ n ) { $ initial_array = array ( array ( ) ) ; $ final_array = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) $ initial_array [ 0 ] [ $ i ] = $ i + 1 ; for ( $ i = 1 ; $ i < $ n - 1 ; ++ $ i ) for ( $ j = 0 ; $ j < $ n - 1 ; ++ $ j ) $ initial_array [ $ i ] [ $ j ] = $ initial_array [ $ i - 1 ] [ ( $ j + 1 ) % ( $ n - 1 ) ] ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) for ( $ j = 0 ; $ j < $ n - 1 ; ++ $ j ) $ final_array [ $ i ] [ $ j ] = $ initial_array [ $ i ] [ $ j ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ final_array [ $ i ] [ $ n - 1 ] = $ final_array [ $ n - 1 ] [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ t0 = $ final_array [ $ i ] [ $ i ] ; $ t1 = $ final_array [ $ i ] [ $ n - 1 ] ; $ temp = $ final_array [ $ i ] [ $ i ] ; $ final_array [ $ i ] [ $ i ] = $ final_array [ $ i ] [ $ n - 1 ] ; $ final_array [ $ i ] [ $ n - 1 ] = $ temp ; $ final_array [ $ n - 1 ] [ $ i ] = $ t0 ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { for ( $ j = 0 ; $ j < $ n ; ++ $ j ) echo $ final_array [ $ i ] [ $ j ] , \" ▁ \" ; echo \" STRNEWLINE \" ; } } $ n = 5 ; solve ( $ n ) ; ? >"}
{"text": "Cari nombor terkecil k seperti k % p = 0 dan q % k = 0 | Berfungsi untuk mengembalikan nilai minimum k seperti k % p = 0 dan q % k = 0; Jika k mungkin; Tidak ada k seperti itu; Kod pemacu", "code": "< ? php function getMinVal ( $ p , $ q ) { if ( $ q % $ p == 0 ) return $ p ; return -1 ; } $ p = 24 ; $ q = 48 ; echo getMinVal ( $ p , $ q ) ; ? >"}
{"text": "Hitung Semua Panjang Perdana Palindromic Substrings | Fungsi yang kembali benar jika sub -rentetan bermula pada saya dan berakhir di J dalam str adalah palindrome; Fungsi untuk mengira semua substring palindromik yang lwngth adalah nombor utama; 0 dan 1 bukan prima; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat nombor IT yang berganda p dan kurang daripada p ^ 2 telah ditandakan. ; Untuk menyimpan bilangan sub -rentetan yang diperlukan; Bermula dari perdana terkecil sehingga panjang terbesar sub -rentetan mungkin; Jika J adalah Perdana; Semak semua sub - rentetan panjang j; Jika sub -rentetan semasa adalah palindrome; Kod pemacu", "code": "< ? php function isPalindrome ( $ str , $ i , $ j ) { while ( $ i < $ j ) { if ( $ str [ $ i ] != $ str [ $ j ] ) return false ; $ i ++ ; $ j -- ; } return true ; } function countPrimePalindrome ( $ str , $ len ) { $ prime = array_fill ( 0 , $ len + 1 , true ) ; $ prime [ 0 ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ len ; $ p ++ ) { if ( $ prime [ $ p ] ) { for ( $ i = $ p * $ p ; $ i <= $ len ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ count = 0 ; for ( $ j = 2 ; $ j <= $ len ; $ j ++ ) { if ( $ prime [ $ j ] ) { for ( $ i = 0 ; $ i + $ j - 1 < $ len ; $ i ++ ) { if ( isPalindrome ( $ str , $ i , $ i + $ j - 1 ) ) $ count ++ ; } } } return $ count ; } $ s = \" geeksforgeeks \" ; $ len = strlen ( $ s ) ; echo countPrimePalindrome ( $ s , $ len ) ; ? >"}
{"text": "Operasi minimum jenis yang diberikan diperlukan untuk membuat graf lengkap | Berfungsi untuk mengembalikan bilangan langkah minimum yang diperlukan; Kod pemacu", "code": "< ? php function minOperations ( $ N ) { $ x = log ( $ N , 2 ) ; $ ans = ceil ( $ x ) ; return $ ans ; } $ N = 10 ; echo minOperations ( $ N ) ; ? >"}
{"text": "Pembahagi terbesar yang membahagikan semua nombor semulajadi dalam julat [l, r] | Berfungsi untuk mengembalikan pembahagi terbesar yang membahagikan semua nombor semulajadi dalam julat [l, r]; Kod pemacu", "code": "< ? php function find_greatest_divisor ( $ l , $ r ) { if ( $ l == $ r ) return $ l ; return 1 ; } $ l = 2 ; $ r = 12 ; echo find_greatest_divisor ( $ l , $ r ) ; ? >"}
{"text": "Kebarangkalian mendapatkan dua kepala berturut -turut selepas memilih duit syiling rawak di antara dua jenis syiling yang berbeza | Berfungsi untuk mengembalikan kebarangkalian mendapatkan dua kepala berturut -turut; Formula yang berasal dari teorem Bayes; Memandangkan kebarangkalian mendapat kepala untuk kedua -dua duit syiling", "code": "< ? php function getProbability ( $ p , $ q ) { $ p /= 100 ; $ q /= 100 ; $ probability = ( $ p * $ p + $ q * $ q ) / ( $ p + $ q ) ; return $ probability ; } $ p = 80 ; $ q = 40 ; echo getProbability ( $ p , $ q ) ; ? >"}
{"text": "Semak sama ada bitwise atau nombor n adalah atau ganjil | Berfungsi untuk memeriksa sama ada bitwise atau nombor n adalah atau ganjil; Jika sekurang -kurangnya satu nombor ganjil dijumpai, maka bitwise atau semua nombor akan menjadi ganjil; Bitwise atau nombor ganjil; Kod pemacu", "code": "< ? php function check ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & 1 ) return true ; } return false ; } $ arr = array ( 3 , 9 , 12 , 13 , 15 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; if ( check ( $ arr , $ n ) ) echo \" Odd ▁ Bit - wise ▁ OR \" ; else echo \" Even ▁ Bit - wise ▁ OR \" ; ? >"}
{"text": "Logaritma Logarited Log * (n) | Program PHP rekursif untuk mencari nilai logaritma berulang; Kod pemacu", "code": "< ? php function _log ( $ x , $ base ) { return ( int ) ( log ( $ x ) / log ( $ base ) ) ; } function recursiveLogStar ( $ n , $ b ) { if ( $ n > 1.0 ) return 1.0 + recursiveLogStar ( _log ( $ n , $ b ) , $ b ) ; else return 0 ; } $ n = 100 ; $ base = 5 ; echo \" Log * ( \" ▁ , ▁ $ n ▁ , ▁ \" ) \" , \" ▁ = ▁ \" , recursiveLogStar ( $ n , $ base ) , \" STRNEWLINE \" ; ? >"}
{"text": "Masa minimum diperlukan untuk mengangkut semua kotak dari sumber ke destinasi di bawah kekangan yang diberikan | Fungsi yang mengembalikan benar jika mungkin untuk mengangkut semua kotak dalam jumlah masa yang diberikan; Jika semua kotak boleh diangkut dalam masa yang diberikan; Sekiranya semua kotak tidak dapat diangkut dalam masa yang diberikan; Berfungsi untuk mengembalikan masa minimum yang diperlukan; Susun dua tatasusunan; Kedai masa minimum di mana semua kotak boleh diangkut; Semak masa minimum di mana semua kotak boleh diangkut; Sekiranya mungkin untuk mengangkut semua kotak pada pertengahan masa; Kod pemacu", "code": "< ? php function isPossible ( $ box , $ truck , $ n , $ m , $ min_time ) { $ temp = 0 ; $ count = 0 ; while ( $ count < $ m ) { for ( $ j = 0 ; $ j < $ min_time && $ temp < $ n && $ truck [ $ count ] >= $ box [ $ temp ] ; $ j += 2 ) $ temp ++ ; $ count ++ ; } if ( $ temp == $ n ) return true ; return false ; } function minTime ( $ box , $ truck , $ n , $ m ) { sort ( $ box ) ; sort ( $ truck ) ; $ l = 0 ; $ h = 2 * $ n ; $ min_time = 0 ; while ( $ l <= $ h ) { $ mid = intdiv ( ( $ l + $ h ) , 2 ) ; if ( isPossible ( $ box , $ truck , $ n , $ m , $ mid ) ) { $ min_time = $ mid ; $ h = $ mid - 1 ; } else $ l = $ mid + 1 ; } return $ min_time ; } $ box = array ( 10 , 2 , 16 , 19 ) ; $ truck = array ( 29 , 25 ) ; $ n = sizeof ( $ box ) ; $ m = sizeof ( $ truck ) ; echo minTime ( $ box , $ truck , $ n , $ m ) ; ? >"}
{"text": "Cari minimum panjang maksimum lompatan yang diperlukan untuk mencapai pulau terakhir dengan tepat K melompat | Fungsi yang mengembalikan benar jika mungkin untuk mencapai hujung array dengan tepat K melompat; Pembolehubah untuk menyimpan bilangan langkah yang diperlukan untuk mencapai akhir; Sekiranya mungkin untuk mencapai hujung dengan tepat K melompat; Mengembalikan jarak maksimum minimum yang diperlukan untuk mencapai hujung array dengan tepat K melompat; Menyimpan jawapannya; Carian binari untuk mengira hasilnya; Kod pemacu", "code": "< ? php function isPossible ( $ arr , $ n , $ dist , $ k ) { $ req = 0 ; $ curr = 0 ; $ prev = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ curr != $ n && $ arr [ $ curr ] - $ arr [ $ prev ] <= $ dist ) $ curr ++ ; $ req ++ ; if ( $ curr == $ n ) break ; $ prev = $ curr - 1 ; } if ( $ curr != $ n ) return false ; if ( $ req <= $ k ) return true ; return false ; } function minDistance ( $ arr , $ n , $ k ) { $ l = 0 ; $ h = $ arr [ $ n - 1 ] ; $ ans = 0 ; while ( $ l <= $ h ) { $ m = floor ( ( $ l + $ h ) / 2 ) ; if ( isPossible ( $ arr , $ n , $ m , $ k ) ) { $ ans = $ m ; $ h = $ m - 1 ; } else $ l = $ m + 1 ; } return $ ans ; } $ arr = array ( 2 , 15 , 36 , 43 ) ; $ n = count ( $ arr ) ; $ k = 2 ; echo minDistance ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Cari elemen KTH dalam siri yang dihasilkan oleh julat N yang diberikan | Berfungsi untuk mengembalikan elemen kth siri yang diperlukan; Untuk menyimpan bilangan bilangan bulat yang terletak sehingga indeks ith; Kirakan bilangan bilangan bulat; Menyimpan indeks, berbaring dari 1 hingga n ,; Menggunakan carian binari, cari indeks di mana elemen kth akan berbohong; Cari kedudukan elemen kth dalam selang di mana ia terletak; Kod pemacu", "code": "< ? php function getKthElement ( $ n , $ k , $ L , $ R ) { $ l = 1 ; $ h = $ n ; $ total = array ( ) ; $ total [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ total [ $ i + 1 ] = $ total [ $ i ] + ( $ R [ $ i ] - $ L [ $ i ] ) + 1 ; } $ index = -1 ; while ( $ l <= $ h ) { $ m = floor ( ( $ l + $ h ) / 2 ) ; if ( $ total [ $ m ] > $ k ) { $ index = $ m ; $ h = $ m - 1 ; } else if ( $ total [ $ m ] < $ k ) $ l = $ m + 1 ; else { $ index = $ m ; break ; } } $ l = $ L [ $ index - 1 ] ; $ h = $ R [ $ index - 1 ] ; $ x = $ k - $ total [ $ index - 1 ] ; while ( $ l <= $ h ) { $ m = floor ( ( $ l + $ h ) / 2 ) ; if ( ( $ m - $ L [ $ index - 1 ] ) + 1 == $ x ) { return $ m ; } else if ( ( $ m - $ L [ $ index - 1 ] ) + 1 > $ x ) $ h = $ m - 1 ; else $ l = $ m + 1 ; } } $ L = array ( 1 , 8 , 21 ) ; $ R = array ( 4 , 10 , 23 ) ; $ n = count ( $ L ) ; $ k = 6 ; echo getKthElement ( $ n , $ k , $ L , $ R ) ; ? >"}
{"text": "Cari Integer Positif Minimum x supaya A (X ^ 2) + B (X) + C> = K | Berfungsi untuk mengembalikan integer positif minimum yang memenuhi persamaan yang diberikan; Carian binari untuk mencari nilai x; Kembalikan jawapannya; Kod pemacu", "code": "< ? php function MinimumX ( $ a , $ b , $ c , $ k ) { $ x = PHP_INT_MAX ; if ( $ k <= $ c ) return 0 ; $ h = $ k - $ c ; $ l = 0 ; while ( $ l <= $ h ) { $ m = floor ( ( $ l + $ h ) / 2 ) ; if ( ( $ a * $ m * $ m ) + ( $ b * $ m ) > ( $ k - $ c ) ) { $ x = min ( $ x , $ m ) ; $ h = $ m - 1 ; } else if ( ( $ a * $ m * $ m ) + ( $ b * $ m ) < ( $ k - $ c ) ) $ l = $ m + 1 ; else return $ m ; } return $ x ; } $ a = 3 ; $ b = 2 ; $ c = 4 ; $ k = 15 ; echo MinimumX ( $ a , $ b , $ c , $ k ) ; ? >"}
{"text": "Bahagikan array menjadi dua bahagian dengan jumlah yang sama mengikut kekangan yang diberikan | Fungsi yang memeriksa jika syarat -syarat yang diberikan dipenuhi; Untuk menyimpan awalan $ jumlah elemen array; Susun array; Kirakan array jumlah awalan; Elemen maksimum dalam array; Pembolehubah untuk memeriksa sama ada terdapat nombor apa -apa; Menyimpan indeks bilangan terbesar yang terdapat dalam array yang lebih kecil daripada saya; Menyimpan indeks bilangan terkecil yang ada dalam array yang lebih besar daripada saya; Cari indeks bilangan terkecil yang lebih besar daripada saya; Cari indeks bilangan terkecil yang lebih besar daripada saya; Jika ada nombor; Jika tiada nombor sedemikian ada cetak tidak; Kod pemacu", "code": "< ? php function IfExists ( $ arr , $ n ) { $ sum = array_fill ( 0 , $ n , 0 ) ; sort ( $ arr ) ; $ sum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ sum [ $ i ] = $ sum [ $ i - 1 ] + $ arr [ $ i ] ; $ max = $ arr [ $ n - 1 ] ; $ flag = false ; for ( $ i = 1 ; $ i <= $ max ; $ i ++ ) { $ findex = 0 ; $ lindex = 0 ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l <= $ r ) { $ m = ( $ l + $ r ) / 2 ; if ( $ arr [ $ m ] < $ i ) { $ findex = $ m ; $ l = $ m + 1 ; } else $ r = $ m - 1 ; } $ l = 1 ; $ r = $ n ; $ flag = false ; while ( $ l <= $ r ) { $ m = ( $ r + $ l ) / 2 ; if ( $ arr [ $ m ] > $ i ) { $ lindex = $ m ; $ r = $ m - 1 ; } else $ l = $ m + 1 ; } if ( $ sum [ $ findex ] == $ sum [ $ n - 1 ] - $ sum [ $ lindex - 1 ] ) { $ flag = true ; break ; } } if ( $ flag == true ) echo \" Yes \" ; else echo \" No \" ; } $ arr = array ( 1 , 2 , 2 , 5 ) ; $ n = sizeof ( $ arr ) ; IfExists ( $ arr , $ n ) ; ? >"}
{"text": "Cari elemen yang hilang dalam pelbagai nombor berturut -turut yang disusun | Berfungsi untuk mengembalikan elemen yang hilang; Semak jika elemen tengah konsisten; Tiada ketidakkonsistenan sehingga unsur -unsur pertengahan apabila elemen yang hilang hanya selepas elemen pertengahan; Bergerak kanan; Ketidakkonsistenan yang dijumpai apabila elemen yang hilang adalah sebelum elemen pertengahan; Bergerak ke kiri; Tiada elemen yang hilang dijumpai; Kod pemacu", "code": "< ? php function findMissing ( $ arr , $ n ) { $ l = 0 ; $ h = $ n - 1 ; while ( $ h > $ l ) { $ mid = floor ( $ l + ( $ h - $ l ) / 2 ) ; if ( $ arr [ $ mid ] - $ mid == $ arr [ 0 ] ) { if ( $ arr [ $ mid + 1 ] - $ arr [ $ mid ] > 1 ) return $ arr [ $ mid ] + 1 ; else { $ l = $ mid + 1 ; } } else { if ( $ arr [ $ mid ] - $ arr [ $ mid - 1 ] > 1 ) return $ arr [ $ mid ] - 1 ; else { $ h = $ mid - 1 ; } } } return -1 ; } $ arr = array ( -9 , -8 , -7 , -5 , - 4 , -3 , -2 , -1 , 0 ) ; $ n = count ( $ arr ) ; echo findMissing ( $ arr , $ n ) ; ? >"}
{"text": "Cari jumlah maksimum yang mengambil setiap elemen kth dalam array | Fungsi untuk mengembalikan jumlah maksimum untuk setiap urutan yang mungkin supaya [i] + a [i + k] + a [i + 2 k] + ... + a [i + qk] dimaksimumkan; Memulakan maksimum dengan nilai terkecil; Cari maksimum dari semua urutan; Jumlah urutan bermula dari Indeks I; Kemas kini maksimum; Kod pemacu", "code": "< ? php function maxSum ( $ arr , $ n , $ K ) { $ maximum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sumk = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j += $ K ) $ sumk = $ sumk + $ arr [ $ j ] ; $ maximum = max ( $ maximum , $ sumk ) ; } return $ maximum ; } $ arr = array ( 3 , 6 , 4 , 7 , 2 ) ; $ n = sizeof ( $ arr ) ; $ K = 2 ; echo maxSum ( $ arr , $ n , $ K ) ; ? >"}
{"text": "Cari bilangan elemen yang lebih besar daripada k dalam array yang disusun | Fungsi untuk mengembalikan kiraan elemen dari array yang lebih besar daripada k; Menyimpan indeks elemen paling kiri dari array yang lebih besar daripada k; Mencari bilangan elemen yang lebih besar daripada k; Jika elemen pertengahan lebih besar daripada K kemas kini leftgreater dan r; Jika elemen pertengahan kurang daripada atau sama dengan K kemas kini l; Mengembalikan kiraan elemen yang lebih besar daripada k; Kod pemacu", "code": "< ? php function countGreater ( $ arr , $ n , $ k ) { $ l = 0 ; $ r = $ n - 1 ; $ leftGreater = $ n ; while ( $ l <= $ r ) { $ m = $ l + ( int ) ( ( $ r - $ l ) / 2 ) ; if ( $ arr [ $ m ] > $ k ) { $ leftGreater = $ m ; $ r = $ m - 1 ; } else $ l = $ m + 1 ; } return ( $ n - $ leftGreater ) ; } $ arr = array ( 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 ) ; $ n = sizeof ( $ arr ) ; $ k = 7 ; echo countGreater ( $ arr , $ n , $ k ) ;"}
{"text": "Kira bilangan operasi yang diperlukan untuk mengurangkan nombor yang diberikan | Pelaksanaan PHP pendekatan; Untuk menyimpan nilai normal semua operasi; Nilai minimum yang mungkin untuk satu siri operasi; Jika k dapat dikurangkan dengan operasi pertama (i + 1); Mustahil untuk mengurangkan k; Bilangan kali semua operasi boleh dilakukan pada k tanpa mengurangkannya ke <= 0; Melakukan operasi; Pemeriksaan akhir; Kod pemacu", "code": "< ? php function operations ( $ op , $ n , $ k ) { $ count = 0 ; $ nVal = 0 ; $ minimum = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ nVal += $ op [ $ i ] ; $ minimum = min ( $ minimum , $ nVal ) ; if ( ( $ k + $ nVal ) <= 0 ) return ( $ i + 1 ) ; } if ( $ nVal >= 0 ) return -1 ; $ times = round ( ( $ k - abs ( $ minimum ) ) / abs ( $ nVal ) ) ; $ k = ( $ k - ( $ times * abs ( $ nVal ) ) ) ; $ count = ( $ times * $ n ) ; while ( $ k > 0 ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ k = $ k + $ op [ $ i ] ; $ count ++ ; if ( $ k <= 0 ) break ; } } return $ count ; } $ op = array ( -60 , 65 , -1 , 14 , -25 ) ; $ n = sizeof ( $ op ) ; $ k = 100000 ; echo operations ( $ op , $ n , $ k ) ; ? >"}
{"text": "Cari nombor terkecil x seperti x! Mengandungi sekurang -kurangnya y yang menyuarakan sifar. | Fungsi untuk mengira bilangan faktor p dalam x! ; Berfungsi untuk mencari x terkecil seperti x! Mengandungi Y Zeros; Kod pemacu", "code": "< ? php function countFactor ( $ P , $ X ) { if ( $ X < $ P ) return 0 ; return ( ( int ) ( $ X / $ P ) + countFactor ( $ P , ( $ X / $ P ) ) ) ; } function findSmallestX ( $ Y ) { $ low = 0 ; $ high = 5 * $ Y ; $ N = 0 ; while ( $ low <= $ high ) { $ mid = ( int ) ( ( $ high + $ low ) / 2 ) ; if ( countFactor ( 5 , $ mid ) < $ Y ) { $ low = $ mid + 1 ; } else { $ N = $ mid ; $ high = $ mid - 1 ; } } return $ N ; } $ Y = 10 ; echo ( findSmallestX ( $ Y ) ) ; ? >"}
{"text": "Cari maksimum n sedemikian rupa sehingga jumlah persegi nombor semulajadi n pertama tidak lebih daripada x | Berfungsi untuk mengembalikan jumlah kuadrat nombor semulajadi n pertama; Berfungsi untuk mengembalikan maksimum n sedemikian rupa sehingga jumlah kuadrat nombor semulajadi n pertama tidak lebih daripada x; Kod pemacu", "code": "< ? php function squareSum ( $ N ) { $ sum = ( $ N * ( int ) ( $ N + 1 ) * ( 2 * $ N + 1 ) ) / 6 ; return $ sum ; } function findMaxN ( $ X ) { $ low = 1 ; $ high = 100000 ; $ N = 0 ; while ( $ low <= $ high ) { $ mid = ( int ) ( $ high + $ low ) / 2 ; if ( squareSum ( $ mid ) <= $ X ) { $ N = $ mid ; $ low = $ mid + 1 ; } else $ high = $ mid - 1 ; } return $ N ; } $ X = 25 ; echo findMaxN ( $ X ) ; ? >"}
{"text": "Unsur carian dalam matriks yang disusun secara roh | Pelaksanaan PHP pendekatan di atas; Fungsi untuk mengembalikan cincin, nombor X dimiliki. ; Pulangan - 1 jika nombor x lebih kecil daripada elemen arr; L dan R mewakili unsur -unsur pepenjuru untuk mencari; Pulangan - 1 jika nombor X lebih besar daripada elemen terbesar ARR; Berfungsi untuk melakukan carian binari pada array yang disusun dalam peningkatan urutan l dan r mewakili indeks kiri dan kanan baris untuk dicari; Berfungsi untuk melakukan carian binari pada lajur tertentu dari t dan b 2D mewakili baris atas dan bawah; Berfungsi untuk melakukan carian binari pada array yang disusun dalam penurunan urutan; Berfungsi untuk melakukan carian binari pada lajur tertentu dari array 2D; Berfungsi untuk mencari kedudukan nombor x; Mencari cincin; Untuk menyimpan baris dan lajur; Kes kelebihan jika n adalah ganjil; Semak mana dari 4 sisi, nombor X terletak di; Mencetak kedudukan; Kod pemacu", "code": "< ? php $ n = 4 ; function findRing ( $ arr , $ x ) { global $ n ; if ( $ arr [ 0 ] [ 0 ] > $ x ) return -1 ; $ l = 0 ; $ r = ( int ) ( ( $ n + 1 ) / 2 - 1 ) ; if ( $ n % 2 == 1 && $ arr [ $ r ] [ $ r ] < $ x ) return -1 ; if ( $ n % 2 == 0 && $ arr [ $ r + 1 ] [ $ r ] < $ x ) return -1 ; while ( $ l < $ r ) { $ mid = ( int ) ( ( $ l + $ r ) / 2 ) ; if ( $ arr [ $ mid ] [ $ mid ] <= $ x ) if ( $ mid == ( int ) ( ( $ n + 1 ) / 2 - 1 ) $ arr [ $ mid + 1 ] [ $ mid + 1 ] > $ x ) return $ mid ; else $ l = $ mid + 1 ; else $ r = $ mid - 1 ; } return $ r ; } function binarySearchRowInc ( $ arr , $ row , $ l , $ r , $ x ) { while ( $ l <= $ r ) { $ mid = ( int ) ( ( $ l + $ r ) / 2 ) ; if ( $ arr [ $ row ] [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ row ] [ $ mid ] < $ x ) $ l = $ mid + 1 ; else $ r = $ mid - 1 ; } return -1 ; } function binarySearchColumnInc ( $ arr , $ col , $ t , $ b , $ x ) { while ( $ t <= $ b ) { $ mid = ( int ) ( ( $ t + b ) / 2 ) ; if ( $ arr [ $ mid ] [ $ col ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] [ $ col ] < $ x ) $ t = $ mid + 1 ; else $ b = $ mid - 1 ; } return -1 ; } function binarySearchRowDec ( $ arr , $ row , $ l , $ r , $ x ) { while ( $ l <= $ r ) { $ mid = ( int ) ( ( $ l + $ r ) / 2 ) ; if ( $ arr [ $ row ] [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ row ] [ $ mid ] < $ x ) $ r = $ mid - 1 ; else $ l = $ mid + 1 ; } return -1 ; } function binarySearchColumnDec ( $ arr , $ col , $ t , $ b , $ x ) { while ( $ t <= $ b ) { $ mid = ( int ) ( ( $ t + $ b ) / 2 ) ; if ( $ arr [ $ mid ] [ $ col ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] [ $ col ] < $ x ) $ b = $ mid - 1 ; else $ t = $ mid + 1 ; } return -1 ; } function spiralBinary ( $ arr , $ x ) { global $ n ; $ f1 = findRing ( $ arr , $ x ) ; $ r = -1 ; $ c = -1 ; if ( $ f1 == -1 ) { echo \" - 1\" ; return ; } if ( $ n % 2 == 1 && $ f1 == ( int ) ( ( $ n + 1 ) / 2 - 1 ) ) { echo $ f1 . \" \" ▁ . ▁ $ f1 ▁ . ▁ \" \" return ; } if ( $ x < $ arr [ $ f1 ] [ $ n - $ f1 - 1 ] ) { $ c = binarySearchRowInc ( $ arr , $ f1 , $ f1 , $ n - $ f1 - 2 , $ x ) ; $ r = $ f1 ; } else if ( $ x < $ arr [ $ n - $ f1 - 1 ] [ $ n - $ f1 - 1 ] ) { $ c = $ n - $ f1 - 1 ; $ r = binarySearchColumnInc ( $ arr , $ n - $ f1 - 1 , $ f1 , $ n - $ f1 - 2 , $ x ) ; } else if ( $ x < $ arr [ $ n - $ f1 - 1 ] [ $ f1 ] ) { $ c = binarySearchRowDec ( $ arr , $ n - $ f1 - 1 , $ f1 + 1 , $ n - $ f1 - 1 , $ x ) ; $ r = $ n - $ f1 - 1 ; } else { $ r = binarySearchColumnDec ( $ arr , $ f1 , $ f1 + 1 , $ n - $ f1 - 1 , $ x ) ; $ c = $ f1 ; } if ( $ c == -1 $ r == -1 ) echo \" - 1\" ; else echo $ r . \" ▁ \" . $ c ; return ; } $ arr = array ( array ( 1 , 2 , 3 , 4 ) , array ( 12 , 13 , 14 , 5 ) , array ( 11 , 16 , 15 , 6 ) , array ( 10 , 9 , 8 , 7 ) ) ; spiralBinary ( $ arr , 7 ) ; ? >"}
{"text": "Bilangan subarrays mempunyai bitwise atau> = k | Berfungsi untuk mengembalikan kiraan sub -tatasusunan yang diperlukan; TRAVERSE SUB - Array [i. . j]; Kod pemacu", "code": "< ? php function countSubArrays ( $ arr , $ n , $ K ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ bitwise_or = 0 ; for ( $ k = $ i ; $ k < $ j + 1 ; $ k ++ ) $ bitwise_or = $ bitwise_or | $ arr [ $ k ] ; if ( $ bitwise_or >= $ K ) $ count += 1 ; } } return $ count ; } $ arr = array ( 3 , 4 , 5 ) ; $ n = count ( $ arr ) ; $ k = 6 ; print ( countSubArrays ( $ arr , $ n , $ k ) ) ; ? >"}
{"text": "Kejadian corak dalam perwakilan binari nombor | Berfungsi untuk mengembalikan kiraan kejadian pat dalam perwakilan binari n; Untuk menyimpan nilai perpuluhan corak; Untuk menyimpan nombor yang mempunyai semua dalam perwakilan binari dan panjang yang sama dengan panjang corak; Cari nilai $ corak_int dan $ all_ones; Jika corak berlaku pada digit terakhir $ n; Peralihan kanan $ n dengan 1 bit; Kod pemacu", "code": "< ? php function countPattern ( $ n , $ pat ) { $ pattern_int = 0 ; $ power_two = 1 ; $ all_ones = 0 ; for ( $ i = strlen ( $ pat ) - 1 ; $ i >= 0 ; $ i -- ) { $ current_bit = $ pat [ $ i ] - '0' ; $ pattern_int += ( $ power_two * $ current_bit ) ; $ all_ones = $ all_ones + $ power_two ; $ power_two = $ power_two * 2 ; } $ count = 0 ; while ( $ n && $ n >= $ pattern_int ) { if ( ( $ n & $ all_ones ) == $ pattern_int ) { $ count ++ ; } $ n = $ n >> 1 ; } return $ count ; } $ n = 500 ; $ pat = \"10\" ; echo countPattern ( $ n , $ pat ) ; ? >"}
{"text": "Keluarkan satu elemen dari array seperti yang Max | fungsi untuk mengira max - min; Kod pemacu", "code": "< ? php function max_min ( & $ a , $ n ) { sort ( $ a ) ; return min ( $ a [ $ n - 2 ] - $ a [ 0 ] , $ a [ $ n - 1 ] - $ a [ 1 ] ) ; } $ a = array ( 1 , 3 , 3 , 7 ) ; $ n = sizeof ( $ a ) ; echo ( max_min ( $ a , $ n ) ) ; ? >"}
{"text": "Nombor kiraan <= n yang perbezaannya dengan kiraan prima sehingga mereka adalah> = k | Pelaksanaan PHP pendekatan di atas; Primeupto [i] menandakan kiraan nombor perdana sehingga i; Berfungsi untuk mengira semua nombor utama dan mengemas kini array primeupto; 0 dan 1 bukan prima; Sekiranya saya adalah perdana; Tetapkan semua gandaan saya sebagai bukan perdana; Kirakan Array Primeupto; Berfungsi untuk mengembalikan kiraan nombor yang sah; Kirakan Array Primeupto; Semak jika nombor itu sah, cuba mengurangkannya; Ans adalah nombor minimum yang sah; Kod pemacu", "code": "< ? php $ MAX = 100001 ; $ primeUpto = array_fill ( 0 , $ MAX , 0 ) ; function SieveOfEratosthenes ( ) { global $ MAX , $ primeUpto ; $ isPrime = array_fill ( 0 , $ MAX , true ) ; $ isPrime [ 0 ] = $ isPrime [ 1 ] = false ; for ( $ i = 2 ; $ i * $ i < $ MAX ; $ i ++ ) { if ( $ isPrime [ $ i ] ) { for ( $ j = $ i * 2 ; $ j < $ MAX ; $ j += $ i ) $ isPrime [ $ j ] = false ; } } for ( $ i = 1 ; $ i < $ MAX ; $ i ++ ) { $ primeUpto [ $ i ] = $ primeUpto [ $ i - 1 ] ; if ( $ isPrime [ $ i ] ) $ primeUpto [ $ i ] ++ ; } } function countOfNumbers ( $ N , $ K ) { SieveOfEratosthenes ( ) ; global $ primeUpto ; $ low = 1 ; $ high = $ N ; $ ans = 0 ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) >> 1 ; if ( $ mid - $ primeUpto [ $ mid ] >= $ K ) { $ ans = $ mid ; $ high = $ mid - 1 ; } else $ low = $ mid + 1 ; } return ( $ ans ? $ N - $ ans + 1 : 0 ) ; } $ N = 10 ; $ K = 3 ; echo countOfNumbers ( $ N , $ K ) ; ? >"}
{"text": "Cari elemen yang pendaraban dengan | Fungsi untuk mencari indeks minimum sehingga jumlahnya menjadi 0 apabila elemen didarab dengan - 1; Cari jumlah array; Cari elemen dengan nilai yang sama dengan jumlah / 2; Apabila jumlah adalah sama dengan 2 * elemen maka ini adalah elemen yang diperlukan; Kod pemacu", "code": "< ? php function minIndex ( & $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( 2 * $ arr [ $ i ] == $ sum ) return ( $ i + 1 ) ; } return -1 ; } $ arr = array ( 1 , 3 , -5 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo ( minIndex ( $ arr , $ n ) ) ; ? >"}
{"text": "Cari persimpangan dua matriks | Berfungsi untuk mencetak matriks yang dihasilkan; Cetak nilai elemen untuk elemen yang sama lain *; Kod pemacu", "code": "< ? php function printIntersection ( $ A , $ B ) { $ N = 4 ; $ M = 4 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ A [ $ i ] [ $ j ] == $ B [ $ i ] [ $ j ] ) echo $ A [ $ i ] [ $ j ] . \" ▁ \" ; else echo \" * ▁ \" ; } echo \" STRNEWLINE \" ; } } $ A = array ( array ( 2 , 4 , 6 , 8 ) , array ( 1 , 3 , 5 , 7 ) , array ( 8 , 6 , 4 , 2 ) , array ( 7 , 5 , 3 , 1 ) ) ; $ B = array ( array ( 2 , 3 , 6 , 8 ) , array ( 1 , 3 , 5 , 2 ) , array ( 8 , 1 , 4 , 2 ) , array ( 3 , 5 , 4 , 1 ) ) ; printIntersection ( $ A , $ B ) ; ? >"}
{"text": "Kira tiga kali ganda bahawa salah satu daripada nombor boleh ditulis sebagai jumlah dua yang lain | Fungsi untuk mengira bilangan cara untuk memilih triple; Kirakan nilai maksimum dalam array dan buat pelbagai frekuensi saiz max_val + 1. Kami juga boleh menggunakan hashmap untuk menyimpan frekuensi. Kami telah menggunakan array untuk mengekalkan kod yang tersisa. ; Kes 1: 0, 0, 0; Kes 2: 0, x, x; Kes 3: x, x, 2 * x; Kes 4: x, y, x + y melewati semua pasangan (x, y); Kod pemacu", "code": "< ? php function countWays ( $ arr , $ n ) { $ max_val = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ max_val = max ( $ max_val , $ arr [ $ i ] ) ; $ freq = array_fill ( 0 , $ max_val + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ freq [ $ arr [ $ i ] ] ++ ; $ ans += ( int ) ( $ freq [ 0 ] * ( $ freq [ 0 ] - 1 ) * ( $ freq [ 0 ] - 2 ) / 6 ) ; for ( $ i = 1 ; $ i <= $ max_val ; $ i ++ ) $ ans += ( int ) ( $ freq [ 0 ] * $ freq [ $ i ] * ( $ freq [ $ i ] - 1 ) / 2 ) ; for ( $ i = 1 ; 2 * $ i <= $ max_val ; $ i ++ ) $ ans += ( int ) ( $ freq [ $ i ] * ( $ freq [ $ i ] - 1 ) / 2 * $ freq [ 2 * $ i ] ) ; for ( $ i = 1 ; $ i <= $ max_val ; $ i ++ ) { for ( $ j = $ i + 1 ; $ i + $ j <= $ max_val ; $ j ++ ) $ ans += $ freq [ $ i ] * $ freq [ $ j ] * $ freq [ $ i + $ j ] ; } return $ ans ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = count ( $ arr ) ; echo countWays ( $ arr , $ n ) ; ? >"}
{"text": "Subarray terpanjang dengan unsur -unsur yang mempunyai modulo yang sama k | fungsi untuk mencari sub -panjang yang paling lama yang elemennya memberikan sisa yang sama apabila dibahagikan dengan k; Melangkah dalam array; Semak jika elemen array lebih besar kemudian x atau tidak; Kod pemacu", "code": "< ? php function LongestSubarray ( $ arr , $ n , $ k ) { $ cnt = 1 ; $ max_length = 1 ; $ prev_mod = $ arr [ 0 ] % $ k ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_mod = $ arr [ $ i ] % $ k ; if ( $ curr_mod == $ prev_mod ) { $ cnt ++ ; } else { $ max_length = max ( $ max_length , $ cnt ) ; $ cnt = 1 ; $ prev_mod = $ curr_mod ; } } return max ( $ max_length , $ cnt ) ; } $ arr = array ( 4 , 9 , 7 , 18 , 29 , 11 ) ; $ n = count ( $ arr ) ; $ k = 11 ; echo LongestSubarray ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Cari dalam matriks 2D yang disusun (disimpan dalam perintah utama baris) | Program PHP untuk mencari sama ada elemen yang diberikan dalam matriks 2 - D yang diberikan; Carian binari asas untuk mencari elemen dalam array 1 - d; jika elemen dijumpai kembali benar; jika pertengahan kurang daripada k kemudian langkau bahagian kiri array lain melangkau bahagian yang betul; jika tidak dijumpai kembali palsu; Berfungsi untuk mencari elemen dalam matriks berdasarkan pendekatan membahagikan dan menaklukkan; Jika elemen terletak pada julat baris ini maka hubungi 1 - d binari carian pada baris ini; Jika elemen kurang maka elemen permulaan baris itu maka cari di baris atas lain cari di baris bawah; jika tidak dijumpai; Kod pemacu", "code": "< ? php $ M = 3 ; $ N = 4 ; function binarySearch1D ( $ arr , $ K ) { $ low = 0 ; $ high = $ GLOBALS [ ' N ' ] - 1 ; while ( $ low <= $ high ) { $ mid = $ low + ( int ) ( $ high - $ low ) / 2 ; if ( $ arr [ $ mid ] == $ K ) return True ; if ( $ arr [ $ mid ] < $ K ) $ low = $ mid + 1 ; else $ high = $ mid - 1 ; } return False ; } function searchMatrix ( $ matrix , $ K ) { $ low = 0 ; $ high = $ GLOBALS [ ' M ' ] - 1 ; while ( $ low <= $ high ) { $ mid = $ low + ( int ) ( $ high - $ low ) / 2 ; if ( $ K >= $ matrix [ $ mid ] [ 0 ] && $ K <= $ matrix [ $ mid ] [ $ GLOBALS [ ' N ' ] - 1 ] ) return binarySearch1D ( $ matrix [ $ mid ] , $ K ) ; if ( $ K < $ matrix [ $ mid ] [ 0 ] ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return False ; } $ matrix = array ( [ 1 , 3 , 5 , 7 ] , [ 10 , 11 , 16 , 20 ] , [ 23 , 30 , 34 , 50 ] ) ; $ K = 3 ; $ M = 3 ; $ N = 4 ; if ( searchMatrix ( $ matrix , $ K ) ) echo \" Found \" ; else echo \" Not ▁ found \" ; ? >"}
{"text": "Bilangan elemen yang dapat dilihat dari sebelah kanan | Program PHP untuk mencari bilangan elemen yang dapat dilihat dari sebelah kanan. ; Kod pemacu", "code": "< ? php function numberOfElements ( $ height , $ n ) { $ max_so_far = 0 ; $ coun = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ height [ $ i ] > $ max_so_far ) { $ max_so_far = $ height [ $ i ] ; $ coun ++ ; } } return $ coun ; } $ n = 6 ; $ height = array ( 4 , 8 , 2 , 0 , 0 , 5 ) ; echo numberOfElements ( $ height , $ n ) ;"}
{"text": "Elemen terbesar dalam array yang diulang tepat K kali | Fungsi yang mendapati elemen terbesar yang diulangi 'k' kali; Susun array; Jika nilai 'k' adalah 1 dan yang terbesar muncul hanya sekali dalam array; kaunter untuk mengira unsur -unsur berulang; Semak sama ada elemen di indeks 'i' adalah sama dengan elemen pada indeks 'i + 1' kemudian tambah kiraan; lain menetapkan kiraan kepada 1 untuk mula mengira kekerapan nombor baru; Jika kiraan adalah sama dengan k dan elemen sebelumnya tidak sama dengan elemen ini; jika tidak ada elemen sedemikian; Kod pemacu; cari elemen terbesar yang diulang k kali", "code": "< ? php function solve ( & $ arr , $ n , $ k ) { sort ( $ arr ) ; if ( $ k == 1 && $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) { echo $ arr [ $ n - 1 ] ; echo ( \" STRNEWLINE \" ) ; return ; } $ count = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) $ count ++ ; else $ count = 1 ; if ( $ count == $ k && ( $ i == 0 || ( $ arr [ $ i - 1 ] != $ arr [ $ i ] ) ) ) { echo ( $ arr [ $ i ] ) ; echo ( \" STRNEWLINE \" ) ; return ; } } echo ( \" No ▁ such ▁ element \" ) ; echo ( \" STRNEWLINE \" ) ; } $ arr = array ( 1 , 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 , 6 , 6 ) ; $ k = 2 ; $ n = sizeof ( $ arr ) ; solve ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Jumlah dan produk elemen minimum dan maksimum array | Berfungsi untuk mencari elemen minimum; Berfungsi untuk mencari elemen maksimum; Berfungsi untuk mendapatkan jumlah; Berfungsi untuk mendapatkan produk; Kod pemacu; Jumlah elemen min dan max; Produk elemen min dan max", "code": "< ? php function getMin ( $ arr , $ n ) { $ res = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ res = min ( $ res , $ arr [ $ i ] ) ; return $ res ; } function getMax ( $ arr , $ n ) { $ res = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ res = max ( $ res , $ arr [ $ i ] ) ; return $ res ; } function findSum ( $ arr , $ n ) { $ min = getMin ( $ arr , $ n ) ; $ max = getMax ( $ arr , $ n ) ; return $ min + $ max ; } function findProduct ( $ arr , $ n ) { $ min = getMin ( $ arr , $ n ) ; $ max = getMax ( $ arr , $ n ) ; return $ min * $ max ; } $ arr = array ( 12 , 1234 , 45 , 67 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Sum = \" ▁ . ▁ findSum ( $ arr , ▁ $ n ) ▁ . ▁ \" \" ; STRNEWLINE echo ▁ \" Product = \""}
{"text": "Kira watak dengan jiran yang sama | Berfungsi untuk mengira watak -watak dengan watak bersebelahan yang sama; jika panjang kurang daripada 3 maka panjang kembali kerana hanya akan ada dua aksara; Melintasi rentetan; Meningkatkan kiraan jika watak sebelumnya dan seterusnya adalah sama; Kiraan pulangan; Kod pemacu", "code": "< ? php function countChar ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n <= 2 ) return $ n ; $ count = 2 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) if ( $ str [ $ i - 1 ] == $ str [ $ i + 1 ] ) $ count ++ ; return $ count ; } $ str = \" egeeksk \" ; echo countChar ( $ str ) ; ? >"}
{"text": "Pertama elemen yang lebih kecil dalam array yang disusun di Java | Program PHP untuk mencari elemen pertama yang lebih kecil daripada sasaran yang diberikan. ; Saiz minimum array hendaklah 1; Jika sasaran terletak di luar elemen max, daripada indeks nilai ketat yang lebih kecil daripada sasaran harus (akhir - 1); Pindah ke sebelah kiri jika sasaran lebih kecil; Bergerak sebelah kanan; Kod pemacu", "code": "< ? php function next0 ( $ arr , $ target ) { $ start = 0 ; $ end = sizeof ( $ arr ) - 1 ; if ( $ end == 0 ) return -1 ; if ( $ target > $ arr [ $ end ] ) return $ end ; $ ans = -1 ; while ( $ start <= $ end ) { $ mid = ( int ) ( ( $ start + $ end ) / 2 ) ; if ( $ arr [ $ mid ] >= $ target ) { $ end = $ mid - 1 ; } else { $ ans = $ mid ; $ start = $ mid + 1 ; } } return $ ans ; } { $ arr = array ( 1 , 2 , 3 , 5 , 8 , 12 ) ; echo ( next0 ( $ arr , 5 ) ) ; }"}
{"text": "Pertama elemen yang lebih besar dalam array yang disusun di Java | Program PHP untuk mencari elemen pertama yang lebih besar daripada sasaran yang diberikan. ; Pindah ke sebelah kanan jika sasaran lebih besar. ; Bergerak sebelah kiri. ; Kod pemacu", "code": "< ? php function next0 ( $ arr , $ target ) { $ start = 0 ; $ end = sizeof ( $ arr ) - 1 ; $ ans = -1 ; while ( $ start <= $ end ) { $ mid = ( int ) ( ( $ start + $ end ) / 2 ) ; if ( $ arr [ $ mid ] <= $ target ) { $ start = $ mid + 1 ; } else { $ ans = $ mid ; $ end = $ mid - 1 ; } } return $ ans ; } { $ arr = array ( 1 , 2 , 3 , 5 , 8 , 12 ) ; echo ( next0 ( $ arr , 8 ) ) ; } ? >"}
{"text": "Pengagihan semula elemen berdasarkan lokasi rujukan | Fungsi untuk melakukan carian berurutan. ; Linear cari elemen; Jika tidak dijumpai; Elemen peralihan sebelum satu kedudukan; Kod pemacu", "code": "< ? php function search ( $ arr , $ n , $ x ) { $ res = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ x == $ arr [ $ i ] ) $ res = $ i ; if ( $ res == -1 ) return false ; $ temp = $ arr [ $ res ] ; for ( $ i = $ res ; $ i > 0 ; $ i -- ) $ arr [ $ i ] = $ arr [ $ i - 1 ] ; $ arr [ 0 ] = $ temp ; return true ; } $ arr = array ( 12 , 25 , 36 , 85 , 98 , 75 , 89 , 15 , 63 , 66 , 64 , 74 , 27 , 83 , 97 ) ; $ q = array ( 63 , 63 , 86 , 63 , 78 ) ; $ n = sizeof ( $ arr ) ; $ m = sizeof ( $ q ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( search ( $ arr , $ n , $ q [ $ i ] ) ) echo \" Yes ▁ \" ; else echo \" No ▁ \" ;"}
{"text": "Kebarangkalian kunci K hadir dalam array | Fungsi untuk mencari kebarangkalian; Cari kebarangkalian; Kod pemacu", "code": "< ? php function kPresentProbability ( & $ a , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] == $ k ) $ count ++ ; return $ count / $ n ; } $ A = array ( 4 , 7 , 2 , 0 , 8 , 7 , 5 ) ; $ K = 2 ; $ N = sizeof ( $ A ) ; echo round ( kPresentProbability ( $ A , $ N , $ K ) , 2 ) ; ? >"}
{"text": "Cari cerun nombor yang diberikan | berfungsi untuk mencari cerun nombor; untuk menyimpan cerun nombor 'num' yang diberikan; gelung dari digit 2 nd sehingga ke -2 nd angka terakhir nombor 'num'; Jika digit adalah maxima; Jika digit adalah minima; cerun yang diperlukan; Kod pemacu", "code": "< ? php function slopeOfNum ( $ num , $ n ) { $ slope = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ num [ $ i ] > $ num [ $ i - 1 ] && $ num [ $ i ] > $ num [ $ i + 1 ] ) $ slope ++ ; else if ( $ num [ $ i ] < $ num [ $ i - 1 ] && $ num [ $ i ] < $ num [ $ i + 1 ] ) $ slope ++ ; } return $ slope ; } $ num = \"1213321\" ; $ n = strlen ( $ num ) ; echo \" Slope = \" ? >"}
{"text": "Elemen Besar Sebelumnya | Program PHP sebelumnya Elemen yang lebih besar penyelesaian naif untuk mencetak elemen yang lebih besar sebelumnya untuk setiap elemen dalam array. ; Sebelum ini lebih besar untuk elemen pertama tidak pernah wujud, jadi kami mencetak - 1 .; Marilah kita memproses elemen yang tinggal. ; Cari elemen pertama di sebelah kiri yang lebih besar daripada ARR [i]. ; Jika semua elemen di sebelah kiri lebih kecil. ; Kod pemacu", "code": "< ? php function prevGreater ( & $ arr , $ n ) { echo ( \" - 1 , ▁ \" ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) { echo ( $ arr [ $ j ] ) ; echo ( \" , ▁ \" ) ; break ; } } if ( $ j == -1 ) echo ( \" - 1 , ▁ \" ) ; } } $ arr = array ( 10 , 4 , 2 , 20 , 40 , 12 , 30 ) ; $ n = sizeof ( $ arr ) ; prevGreater ( $ arr , $ n ) ; ? >"}
{"text": "Duplikat dalam array dalam O (n) masa dan dengan menggunakan O (1) ruang tambahan | Set | Berfungsi untuk mencari elemen berulang; Pembolehubah bendera yang digunakan untuk mewakili sama ada elemen mengulangi dijumpai atau tidak. ; Semak jika elemen semasa mengulang atau tidak. Jika ia mengulangi maka nilai akan lebih besar daripada atau sama dengan n. ; Semak sama ada pengulangan pertama atau tidak. Sekiranya pengulangan pertama maka nilai pada indeks arr [i] kurang daripada 2 * n. Cetak arr [i] jika pengulangan pertama. ; Tambah n ke indeks arr [i] untuk menandakan kehadiran arr [i] atau menandakan pengulangan arr [i]. ; Jika pemboleh ubah bendera tidak ditetapkan maka tiada elemen berulang ditemui. Jadi cetak - 1 .; Fungsi pemacu", "code": "< ? php function printDuplicates ( $ arr , $ n ) { $ i ; $ fl = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ arr [ $ i ] % $ n ] >= $ n ) { if ( $ arr [ $ arr [ $ i ] % $ n ] < 2 * $ n ) { echo $ arr [ $ i ] % $ n . \" \" ; $ fl = 1 ; } } $ arr [ $ arr [ $ i ] % $ n ] += $ n ; } if ( ! $ fl ) echo \" - 1\" ; } $ arr = array ( 1 , 6 , 3 , 1 , 3 , 6 , 6 ) ; $ arr_size = sizeof ( $ arr ) ; printDuplicates ( $ arr , $ arr_size ) ;"}
{"text": "Cari nombor positif terkecil yang hilang dari array yang tidak disusun | Tetapkan 2 | Berfungsi untuk mencari nombor positif yang paling kecil. ; untuk menyimpan elemen array semasa; untuk menyimpan elemen array seterusnya dalam traversal semasa; Jika nilai negatif atau lebih besar daripada saiz array, maka ia tidak boleh ditandakan dalam array. Jadi pindah ke elemen seterusnya. ; melintasi array sehingga kita mencapai unsur yang sudah ditandakan atau yang tidak dapat ditandakan. ; Cari indeks array pertama yang tidak ditandakan yang juga nombor positif yang paling kecil. ; Jika semua indeks ditandakan, maka nombor positif yang paling kecil adalah array_size + 1 .; Kod pemacu", "code": "< ? php function findMissingNo ( $ arr , $ n ) { $ val ; $ nextval ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] <= 0 $ arr [ $ i ] > $ n ) continue ; $ val = $ arr [ $ i ] ; while ( $ arr [ $ val - 1 ] != $ val ) { $ nextval = $ arr [ $ val - 1 ] ; $ arr [ $ val - 1 ] = $ val ; $ val = $ nextval ; if ( $ val <= 0 $ val > $ n ) break ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] != $ i + 1 ) { return $ i + 1 ; } } return $ n + 1 ; } $ arr = array ( 2 , 3 , 7 , 6 , 8 , -1 , -10 , 15 ) ; $ arr_size = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; $ missing = findMissingNo ( $ arr , $ arr_size ) ; echo \" The ▁ smallest ▁ positive ▁ \" . \" missing ▁ number ▁ is ▁ \" , $ missing ; ? >"}
{"text": "Cetak semua tiga dengan jumlah yang diberikan | Mencetak semua tiga kali ganda dalam arr [] dengan jumlah yang diberikan; Kod pemacu", "code": "< ? php function findTriplets ( $ arr , $ n , $ sum ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] == $ sum ) { echo $ arr [ $ i ] , \" \" , $ arr [ $ j ] , \" \" , $ arr [ $ k ] , \" \" ; } } } } } $ arr = array ( 0 , -1 , 2 , -3 , 1 ) ; $ n = sizeof ( $ arr ) ; findTriplets ( $ arr , $ n , -2 ) ; ? >"}
{"text": "Maksimum Produk Berkelanjutan (sub | berfungsi untuk mencari produk maksimum empat kali ganda dalam pelbagai integer saiz n; jika saiz kurang daripada 4, tidak ada empat kali ganda; akan mengandungi produk maksimum; kod pemacu", "code": "< ? php function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; $ max_product = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n - 3 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 2 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n - 1 ; $ k ++ ) for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) $ max_product = max ( $ max_product , $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] * $ arr [ $ l ] ) ; return $ max_product ; } $ arr = array ( 10 , 3 , 5 , 6 , 20 ) ; $ n = count ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) echo \" No ▁ Quadruple ▁ Exists \" ; else echo \" Maximum ▁ product ▁ is ▁ \" , $ max ; ? >"}
{"text": "Kuadrup produk maksimum (sub | berfungsi untuk mencari produk maksimum kuadruple dalam pelbagai bilangan bulat saiz n; jika saiz kurang daripada 4, tiada empat kali ganda wujud; sort array dalam urutan menaik; kembalikan maksimum x, y dan z;", "code": "< ? php function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; sort ( $ arr ) ; $ x = $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] * $ arr [ $ n - 3 ] * $ arr [ $ n - 4 ] ; $ y = $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ 2 ] * $ arr [ 3 ] ; $ z = $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] ; return max ( $ x , max ( $ y , $ z ) ) ; } $ arr = array ( -10 , -3 , 5 , 6 , -20 ) ; $ n = sizeof ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) echo \" No ▁ Quadruple ▁ Exists \" ; else echo \" Maximum ▁ product ▁ is ▁ \" . $ max ;"}
{"text": "Nilai minimum \"maksimum\" dalam subarray | Program PHP untuk mencari jumlah maksimum dan minimum dalam mana -mana subarray pelbagai nombor positif. ; Kod pemacu", "code": "< ? php function maxSum ( $ arr , $ n ) { if ( $ n < 2 ) return -1 ; $ ans = $ arr [ 0 ] + $ arr [ 1 ] ; for ( $ i = 1 ; $ i + 1 < $ n ; $ i ++ ) $ ans = min ( $ ans , ( $ arr [ $ i ] + $ arr [ $ i + 1 ] ) ) ; return $ ans ; } $ arr = array ( 1 , 12 , 2 , 2 ) ; $ n = count ( $ arr ) ; echo maxSum ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah maksimum elemen dari setiap baris dalam matriks | Program PHP untuk mencari baris - jumlah unsur maksimum yang bijak memandangkan unsur -unsur dalam peningkatan urutan. ; Berfungsi untuk melaksanakan tugas yang diberikan; Mendapatkan elemen maksimum dari baris terakhir; Membandingkannya dengan unsur -unsur baris di atas; Maksimum baris semasa. ; Jika kita tidak dapat elemen lebih kecil daripada prev_max. ; Kod pemacu", "code": "< ? php $ N = 3 ; function getGreatestSum ( $ a ) { global $ N ; $ prev_max = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ prev_max < $ a [ $ N - 1 ] [ $ j ] ) $ prev_max = $ a [ $ N - 1 ] [ $ j ] ; $ sum = $ prev_max ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { $ curr_max = PHP_INT_MIN ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ prev_max > $ a [ $ i ] [ $ j ] and $ a [ $ i ] [ $ j ] > $ curr_max ) $ curr_max = $ a [ $ i ] [ $ j ] ; if ( $ curr_max == PHP_INT_MIN ) return -1 ; $ prev_max = $ curr_max ; $ sum += $ prev_max ; } return $ sum ; } $ a = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; echo getGreatestSum ( $ a ) , \" STRNEWLINE \" ; $ b = array ( array ( 4 , 5 , 6 ) , array ( 4 , 5 , 6 ) , array ( 4 , 5 , 6 ) ) ; echo getGreatestSum ( $ b ) , \" STRNEWLINE \" ; ? >"}
{"text": "Nilai k | Program PHP ke elemen FIN K - TH selepas menambah dan memasukkan operasi pertengahan; Elemen tengah urutan; Panjang urutan yang dihasilkan. ; Mengemas kini elemen pertengahan urutan seterusnya; Bergerak ke sebelah kiri elemen tengah. ; Bergerak ke sebelah kanan elemen tengah. ; Kod pemacu", "code": "< ? php function findElement ( $ n , $ k ) { $ ans = $ n ; $ left = 1 ; $ right = pow ( 2 , $ n ) - 1 ; while ( 1 ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ k == $ mid ) { echo $ ans , \" STRNEWLINE \" ; break ; } $ ans -- ; if ( $ k < $ id ) $ right = $ mid - 1 ; else $ left = $ mid + 1 ; } } $ n = 4 ; $ k = 8 ; findElement ( $ n , $ k ) ; ? >"}
{"text": "Pasangan cetak dengan maksimum dan nilai dalam array | Fungsi utiliti untuk memeriksa bilangan elemen yang telah menetapkan MSB sebagai corak; Fungsi untuk mencari pasangan maksimum dan nilai; melangkah lebih daripada 30 bit dari MSB ke LSB; Cari kiraan elemen yang telah menetapkan MSB; jika kiraan> = 2 tetapkan bit tertentu dalam hasil; Cari unsur -unsur; Cetak sepasang elemen; Inc Nilai kiraan selepas elemen percetakan; mengembalikan nilai hasil; Kod pemacu", "code": "< ? php function checkBit ( $ pattern , $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( ( $ pattern & $ arr [ $ i ] ) == $ pattern ) $ count ++ ; return $ count ; } function maxAND ( $ arr , $ n ) { $ res = 0 ; for ( $ bit = 31 ; $ bit >= 0 ; $ bit -- ) { $ count = checkBit ( $ res | ( 1 << $ bit ) , $ arr , $ n ) ; if ( $ count >= 2 ) $ res |= ( 1 << $ bit ) ; } if ( $ res == 0 ) echo \" Not ▁ Possible STRNEWLINE \" ; else { echo \" Pair = \" $ count = 0 ; for ( $ i = 0 ; $ i < $ n && $ count < 2 ; $ i ++ ) { if ( ( $ arr [ $ i ] & $ res ) == $ res ) { $ count ++ ; echo $ arr [ $ i ] . \" \" ; } } } return $ res ; } $ arr = array ( 4 , 8 , 6 , 2 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo \" Maximum AND Value = \" ? >"}
{"text": "Kebarangkalian memilih pasangan rawak dengan jumlah maksimum dalam array | Berfungsi untuk mendapatkan max pertama dan kedua; Jika elemen semasa lebih kecil daripada yang pertama, maka kemas kini kedua -dua dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; kekerapan maksimum pertama; kekerapan maksimum kedua; Mengembalikan kebarangkalian memilih pasangan dengan jumlah maksimum. ; Kod pemacu", "code": "< ? php function countMaxSumPairs ( $ a , $ n ) { $ first = PHP_INT_MIN ; $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ first ) { $ second = $ first ; $ first = $ a [ $ i ] ; } else if ( $ a [ $ i ] > $ second && $ a [ $ i ] != $ first ) $ second = $ a [ $ i ] ; } $ cnt1 = 0 ; $ cnt2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ first ) $ cnt1 ++ ; if ( $ a [ $ i ] == $ second ) $ cnt2 ++ ; } if ( $ cnt1 == 1 ) return $ cnt2 ; if ( $ cnt1 > 1 ) return $ cnt1 * ( $ cnt1 - 1 ) / 2 ; } function findMaxSumProbability ( $ a , $ n ) { $ total = $ n * ( $ n - 1 ) / 2 ; $ max_sum_pairs = countMaxSumPairs ( $ a , $ n ) ; return ( float ) $ max_sum_pairs / ( float ) $ total ; } $ a = array ( 1 , 2 , 2 , 3 ) ; $ n = sizeof ( $ a ) ; echo findMaxSumProbability ( $ a , $ n ) ; ? >"}
{"text": "Cari jika nombor yang diberikan adalah jumlah nombor semulajadi n pertama | Berfungsi untuk mencari tidak. unsur -unsur yang akan ditambah dari 1 untuk mendapatkan n; Mula menambah nombor dari 1; Jika jumlah menjadi sama dengan s pulangan n; Kod pemandu", "code": "< ? php function findS ( $ s ) { $ sum = 0 ; for ( $ n = 1 ; $ sum < $ s ; $ n ++ ) { $ sum += $ n ; if ( $ sum == $ s ) return $ n ; } return -1 ; } $ s = 15 ; $ n = findS ( $ s ) ; if ( $ n == -1 ) echo \" - 1\" ; else echo $ n ; ? >"}
{"text": "Jimat dari Bishop di Chessboard | fungsi untuk mengira jumlah kedudukan selamat; Saya, J menandakan baris dan lajur kedudukan uskup; Jarak Calc dalam empat arah; Calc Jumlah Jumlah Jarak + 1 untuk kedudukan yang tidak selamat; mengembalikan jumlah kedudukan selamat; Kod pemacu", "code": "< ? php function calcSafe ( $ pos ) { $ j = $ pos % 10 ; $ i = $ pos / 10 ; $ dis_11 = min ( abs ( 1 - $ i ) , abs ( 1 - $ j ) ) ; $ dis_18 = min ( abs ( 1 - $ i ) , abs ( 8 - $ j ) ) ; $ dis_81 = min ( abs ( 8 - $ i ) , abs ( 1 - $ j ) ) ; $ dis_88 = min ( abs ( 8 - $ i ) , abs ( 8 - $ j ) ) ; $ sum = $ dis_11 + $ dis_18 + $ dis_81 + $ dis_88 + 1 ; return ceil ( 64 - $ sum ) ; } $ pos = 34 ; echo \" Safe ▁ Positions ▁ = ▁ \" , calcSafe ( $ pos ) ; ? >"}
{"text": "Kira bilangan elemen antara dua elemen yang diberikan dalam array | Fungsi untuk mengira bilangan elemen berlaku di antara unsur -unsur. ; Cari num1; Jika NUM1 tidak hadir atau hadir pada akhir; Cari num2; Jika NUM2 tidak hadir; Pulangan bilangan elemen betweenthe dua elemen. ; Kod pemacu", "code": "< ? php function getCount ( $ arr , $ n , $ num1 , $ num2 ) { $ i = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ num1 ) break ; if ( $ i >= $ n - 1 ) return 0 ; $ j ; for ( $ j = $ n - 1 ; $ j >= $ i + 1 ; $ j -- ) if ( $ arr [ $ j ] == $ num2 ) break ; if ( $ j == $ i ) return 0 ; return ( $ j - $ i - 1 ) ; } $ arr = array ( 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 ) ; $ n = sizeof ( $ arr ) ; $ num1 = 5 ; $ num2 = 4 ; echo ( getCount ( $ arr , $ n , $ num1 , $ num2 ) ) ; ? >"}
{"text": "Kira nombor dengan perbezaan antara nombor dan jumlah digitnya lebih besar daripada nilai tertentu | kaedah untuk mendapatkan jumlah digit k; gelung sehingga k tidak sifar; kaedah mengembalikan kiraan nombor yang lebih kecil daripada N, keadaan perbezaan yang memuaskan; carian binari semasa gelung; Jika perbezaan antara bilangan dan jumlah digitnya lebih kecil daripada perbezaan yang diberikan maka nombor terkecil akan berada di sebelah kiri; Jika perbezaan antara bilangan dan jumlah digitnya lebih besar daripada atau sama dengan perbezaan yang diberikan maka nombor terkecil akan berada di sebelah kanan; mengembalikan perbezaan antara 'terkecil' nombor 'dijumpai' dan 'n' sebagai hasil; Kod pemacu", "code": "< ? php function sumOfDigit ( $ K ) { $ sod = 0 ; while ( $ K ) { $ sod += $ K % 10 ; $ K /= 10 ; } return $ sod ; } function totalNumbersWithSpecificDifference ( $ N , $ diff ) { $ low = 1 ; $ high = $ N ; while ( $ low <= $ high ) { $ mid = floor ( ( $ low + $ high ) / 2 ) ; if ( $ mid - sumOfDigit ( $ mid ) < $ diff ) $ low = $ mid + 1 ; else $ high = $ mid - 1 ; } return ( $ N - $ high ) ; } $ N = 13 ; $ diff = 2 ; echo totalNumbersWithSpecificDifference ( $ N , $ diff ) ; ? >"}
{"text": "Bilangan bangunan yang menghadap matahari | Mengembalikan bangunan kiraan yang dapat melihat cahaya matahari; Hasil inisial (perhatikan bahawa bangunan pertama selalu melihat cahaya matahari); Mula melintasi elemen; Jika curr_element adalah elemen maksimum atau semasa adalah sama, kemas kini maksimum dan kiraan kenaikan; Kod pemacu", "code": "< ? php function countBuildings ( $ arr , $ n ) { $ count = 1 ; $ curr_max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ curr_max $ arr [ $ i ] == $ curr_max ) { $ count ++ ; $ curr_max = $ arr [ $ i ] ; } } return $ count ; } $ arr = array ( 7 , 4 , 8 , 2 , 9 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo countBuildings ( $ arr , $ n ) ; ? >"}
{"text": "Cari indeks elemen tambahan yang ada dalam satu array yang disusun | Mengembalikan indeks elemen tambahan dalam ARR1 []. n ialah saiz arr2 []. Saiz arr1 [] adalah n - 1 .; Kod pemacu; Selesaikan kedua -dua tatasusunan", "code": "< ? php function findExtra ( $ arr1 , $ arr2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr1 [ $ i ] != $ arr2 [ $ i ] ) return $ i ; return $ n ; } $ arr1 = array ( 2 , 4 , 6 , 8 , 10 , 12 , 13 ) ; $ arr2 = array ( 2 , 4 , 6 , 8 , 10 , 12 ) ; $ n = sizeof ( $ arr2 ) ; echo findExtra ( $ arr1 , $ arr2 , $ n ) ; ? >"}
{"text": "Cari indeks elemen tambahan yang ada dalam satu array yang disusun | Mengembalikan indeks elemen tambahan dalam ARR1 []. n ialah saiz arr2 []. Saiz arr1 [] adalah n - 1 .; Memulakan hasil; Kiri dan kanan adalah titik akhir yang menandakan julat semasa. ; Jika elemen tengah adalah sama dari kedua -dua tatasusunan, ini bermakna elemen tambahan adalah selepas pertengahan sehingga kami mengemas kini kiri ke pertengahan + 1; Jika elemen tengah adalah berbeza daripada tatasusunan, ini bermakna indeks yang kita cari adalah sama ada pertengahan, atau sebelum pertengahan. Oleh itu, kami mengemas kini ke pertengahan - 1 .; Apabila betul lebih besar dari kiri, carian kami selesai. ; Kod pemacu; Selesaikan kedua -dua tatasusunan", "code": "< ? php function findExtra ( $ arr1 , $ arr2 , $ n ) { $ index = $ n ; $ left = 0 ; $ right = $ n - 1 ; while ( $ left <= $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ arr2 [ $ mid ] == $ arr1 [ $ mid ] ) $ left = $ mid + 1 ; else { $ index = $ mid ; $ right = $ mid - 1 ; } } return $ index ; } { $ arr1 = array ( 2 , 4 , 6 , 8 , 10 , 12 , 13 ) ; $ arr2 = array ( 2 , 4 , 6 , 8 , 10 , 12 ) ; $ n = sizeof ( $ arr2 ) / sizeof ( $ arr2 [ 0 ] ) ; echo findExtra ( $ arr1 , $ arr2 , $ n ) ; return 0 ; } ? >"}
{"text": "Buat semua elemen array sama dengan kos minimum | Kaedah utiliti untuk mengira kos, apabila semua nilai array dibuat sama dengan x; Kaedah untuk mencari kos minimum untuk menjadikan semua elemen sama; menetapkan had untuk carian ternary oleh elemen terkecil dan terbesar; gelung sehingga perbezaan antara rendah dan tinggi menjadi kurang daripada 3, kerana selepas itu MID1 dan MID2 akan mula mengulangi; MID1 dan MID2 adalah array perwakilan yang sama nilai ruang carian; Jika Mid2 Point memberikan lebih banyak kos, melangkau bahagian ketiga; Jika Mid1 Point memberikan lebih banyak kos, langkau bahagian pertama; Computecost mendapat kos optimum dengan menghantar purata rendah dan tinggi sebagai x; Kod pemacu", "code": "< ? php function computeCost ( $ arr , $ N , $ X ) { $ cost = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ cost += abs ( $ arr [ $ i ] - $ X ) ; return $ cost ; } function minCostToMakeElementEqual ( $ arr , $ N ) { $ low ; $ high ; $ low = $ high = $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ low > $ arr [ $ i ] ) $ low = $ arr [ $ i ] ; if ( $ high < $ arr [ $ i ] ) $ high = $ arr [ $ i ] ; } while ( ( $ high - $ low ) > 2 ) { $ mid1 = $ low + ( floor ( $ high - $ low ) / 3 ) ; $ mid2 = $ high - ( $ high - $ low ) / 3 ; $ cost1 = computeCost ( $ arr , $ N , $ mid1 ) ; $ cost2 = computeCost ( $ arr , $ N , $ mid2 ) ; if ( $ cost1 < $ cost2 ) $ high = $ mid2 ; else $ low = $ mid1 ; } return computeCost ( $ arr , $ N , ( $ low + $ high ) / 2 ) ; } $ arr = array ( 1 , 100 , 101 ) ; $ N = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo minCostToMakeElementEqual ( $ arr , $ N ) ; ? >"}
{"text": "Elemen terkecil lebih besar daripada x yang tidak hadir dalam array | Berfungsi untuk mengembalikan elemen terkecil lebih besar daripada x yang tidak hadir dalam []; Susun array; Teruskan sehingga rendah kurang daripada atau sama dengan tinggi; Cari pertengahan; Jika elemen pada pertengahan kurang daripada atau sama dengan elemen mencari; Jika MID adalah sama dengan elemen mencari; Elemen pencarian kenaikan; Buat tinggi sebagai n - 1; Buat rendah sebagai pertengahan + 1; Buat tinggi sebagai pertengahan - 1; Kembali elemen yang lebih besar seterusnya; Kod pemacu", "code": "< ? php function Next_greater ( $ a , $ n , $ x ) { sort ( $ a ) ; $ low = 0 ; $ high = $ n - 1 ; $ ans = $ x + 1 ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( $ a [ $ mid ] <= $ ans ) { if ( $ a [ $ mid ] == $ ans ) { $ ans ++ ; $ high = $ n - 1 ; } $ low = $ mid + 1 ; } else $ high = $ mid - 1 ; } return $ ans ; } $ a = array ( 1 , 5 , 10 , 4 , 7 ) ; $ x = 4 ; $ n = count ( $ a ) ; echo Next_greater ( $ a , $ n , $ x ) ; ? >"}
{"text": "Kira bilangan subset yang mediannya juga terdapat dalam subset yang sama | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan faktorial nombor; Berfungsi untuk mengembalikan nilai NCR; Berfungsi untuk mengembalikan A yang dibangkitkan kepada kuasa n dengan kerumitan o (log (n)); Berfungsi untuk mengembalikan bilangan sub -set yang mediannya juga hadir dalam set; Bilangan sub - set panjang yang ganjil; Susun array; Memeriksa setiap elemen untuk elemen tengah paling kiri semasa mereka sama; Kirakan bilangan elemen di sebelah kanan elemen tengah paling kanan; Kirakan bilangan elemen di sebelah kiri elemen tengah paling kiri; Tambah subset panjang yang dipilih untuk jawapannya; Kod pemacu", "code": "< ? php $ mod = 1000000007 ; function fact ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } function nCr ( $ n , $ r ) { return fact ( $ n ) / ( fact ( $ r ) * fact ( $ n - $ r ) ) ; } function powmod ( $ a , $ n ) { global $ mod ; if ( $ n == 0 ) return 1 ; $ pt = powmod ( $ a , $ n / 2 ) ; $ pt = ( $ pt * $ pt ) % $ mod ; if ( $ n % 2 == 1 ) return ( $ pt * $ a ) % $ mod ; else return $ pt ; } function CountSubset ( $ arr , $ n ) { global $ mod ; $ ans = powmod ( 2 , $ n - 1 ) ; sort ( $ arr , 0 ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ j = $ i + 1 ; while ( $ j < $ n && $ arr [ $ j ] == $ arr [ $ i ] ) { $ r = $ n - 1 - $ j ; $ l = $ i ; $ ans = ( $ ans + nCr ( $ l + $ r , $ l ) ) % $ mod ; $ j ++ ; } } return $ ans ; } { $ arr = array ( 2 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; echo ( CountSubset ( $ arr , $ n ) ) ; }"}
{"text": "Menyusun semula kedudukan kata -kata dalam susunan abjad | Berfungsi untuk mencetak pesanan perkataan; Mewujudkan senarai perkataan dan memberikan nombor indeks mereka; Susun senarai perkataan secara lexicographically; Cetak pesanan; Kod pemacu", "code": "< ? php function reArrange ( $ words , $ n ) { $ freq = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ freq [ $ words [ $ i ] ] = ( $ i + 1 ) ; } sort ( $ words ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ freq [ $ words [ $ i ] ] , \" ▁ \" ; } $ words = array ( \" live \" , \" place \" , \" travel \" , \" word \" , \" sky \" ) ; $ n = count ( $ words ) ; reArrange ( $ words , $ n ) ; ? >"}
{"text": "Jumlah elemen dalam array 1 ST sehingga jumlah elemen kurang daripada atau sama dengan mereka dalam array 2 nd adalah maksimum | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan jumlah yang diperlukan; Mewujudkan array hash pada mulanya diisi dengan sifar; Kirakan kekerapan elemen ARR2 []; Running jumlah hash array sedemikian rupa sehingga hash [i] akan memberikan kiraan unsur -unsur kurang daripada atau sama dengan saya dalam arr2 []; Untuk menyimpan nilai maksimum bilangan elemen dalam ARR2 [] yang lebih kecil daripada atau sama dengan beberapa elemen ARR1 []; Kirakan jumlah elemen dari ARR1 [] sepadan dengan kekerapan maksimum; Mengembalikan jumlah yang diperlukan; Kod pemacu", "code": "< ? php $ MAX = 10000 ; function findSumofEle ( $ arr1 , $ m , $ arr2 , $ n ) { $ hash = array_fill ( 0 , $ GLOBALS [ ' MAX ' ] , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ hash [ $ arr2 [ $ i ] ] ++ ; for ( $ i = 1 ; $ i < $ GLOBALS [ ' MAX ' ] ; $ i ++ ) $ hash [ $ i ] = $ hash [ $ i ] + $ hash [ $ i - 1 ] ; $ maximumFreq = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ maximumFreq = max ( $ maximumFreq , $ hash [ $ arr1 [ $ i ] ] ) ; $ sumOfElements = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ sumOfElements += ( $ maximumFreq == $ hash [ $ arr1 [ $ i ] ] ) ? $ arr1 [ $ i ] : 0 ; return $ sumOfElements ; } $ arr1 = array ( 2 , 5 , 6 , 8 ) ; $ arr2 = array ( 4 , 10 ) ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; echo findSumofEle ( $ arr1 , $ m , $ arr2 , $ n ) ; ? >"}
{"text": "Cari A dan B dari Senarai Pembahagi | Berfungsi untuk mencetak a dan b semua pembahagi yang hadir dalam array yang diberikan; Susun array; A adalah elemen terbesar dari array; Berulang dari elemen kedua terbesar; Jika elemen semasa bukan pembahagi A maka ia mestilah b; Jika elemen semasa berlaku lebih dari sekali; Cetak A dan B; Kod pemacu", "code": "< ? php function printNumbers ( $ arr , $ n ) { sort ( $ arr ) ; $ A = $ arr [ $ n - 1 ] ; $ B = -1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ A % $ arr [ $ i ] != 0 ) { $ B = $ arr [ $ i ] ; break ; } if ( $ i - 1 >= 0 && $ arr [ $ i ] == $ arr [ $ i - 1 ] ) { $ B = $ arr [ $ i ] ; break ; } } echo ( \" A ▁ = ▁ \" . $ A . \" , B = \" } $ arr = array ( 1 , 2 , 4 , 8 , 16 , 1 , 2 , 4 ) ; $ n = sizeof ( $ arr ) ; printNumbers ( $ arr , $ n ) ;"}
{"text": "Cari array yang diubahsuai selepas melakukan operasi K jenis yang diberikan | Fungsi utiliti untuk mencetak kandungan array; Berfungsi untuk mengeluarkan nilai minimum array dari setiap elemen array; Dapatkan nilai minimum dari array; Keluarkan nilai minimum dari setiap elemen array; Berfungsi untuk mengeluarkan setiap elemen array dari nilai maksimum array; Dapatkan nilai maksimum dari array; Keluarkan setiap elemen array dari nilai maksimum array; Berfungsi untuk mencetak array yang diubahsuai selepas operasi K; Jika k adalah ganjil maka keluarkan elemen minimum array dari setiap elemen array; Lain keluarkan setiap elemen array dari nilai maksimum dari array; Cetak array yang diubah suai; Kod pemacu", "code": "< ? php function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } function removeMin ( & $ arr , $ n ) { $ minVal = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ minVal = min ( $ minVal , $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ arr [ $ i ] - $ minVal ; } function removeFromMax ( & $ arr , $ n ) { $ maxVal = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ maxVal = max ( $ maxVal , $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ maxVal - $ arr [ $ i ] ; } function modifyArray ( $ arr , $ n , $ k ) { if ( $ k % 2 == 0 ) removeMin ( $ arr , $ n ) ; else removeFromMax ( $ arr , $ n ) ; printArray ( $ arr , $ n ) ; } $ arr = array ( 4 , 8 , 12 , 16 ) ; $ n = count ( $ arr ) ; $ k = 2 ; modifyArray ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Kurangkan jumlah kuadrat dari jumlah unsur setiap kumpulan array dibahagikan kepada | Berfungsi untuk mengembalikan jumlah yang diminimumkan; Susun array untuk memasangkan unsur -unsur; Pembolehubah untuk memegang jawapannya; Sepasang terkecil dengan terbesar, kedua terkecil dengan kedua terbesar, dan sebagainya; Kod pemacu", "code": "< ? php function findAnswer ( $ n , $ arr ) { sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n / 2 ; ++ $ i ) { $ sum += ( $ arr [ $ i ] + $ arr [ $ n - $ i - 1 ] ) * ( $ arr [ $ i ] + $ arr [ $ n - $ i - 1 ] ) ; } return $ sum ; } $ arr = array ( 53 , 28 , 143 , 5 ) ; $ n = count ( $ arr ) ; echo findAnswer ( $ n , $ arr ) ; ? >"}
{"text": "Gabungkan Katur Susun | | Tetapkan 3 (Menggunakan Pendekatan Membahagikan dan Menakluk) | Program PHP untuk menggabungkan susunan K yang disusun; Berfungsi untuk melaksanakan operasi gabungan; untuk menyimpan titik permulaan array kiri dan kanan; untuk menyimpan saiz array kiri dan kanan; array untuk sementara menyimpan array kiri dan kanan; menyimpan data dalam array kiri; menyimpan data dalam array kanan; untuk menyimpan indeks semasa array kiri dan kanan sementara; untuk menyimpan indeks semasa untuk array output; Dua penunjuk bergabung untuk dua susunan yang disusun; Kod untuk Memacu Gabungan - Susun dan buat pokok rekursi; langkah asas untuk memulakan array output sebelum melakukan operasi gabungan; untuk menyusun separuh kiri; untuk menyusun separuh kanan; menggabungkan separuh kiri dan kanan; input 2D - array; Bilangan tatasusunan; Pelbagai output; Cetak Array yang digabungkan", "code": "< ? php $ n = 4 ; function merge ( $ l , $ r , & $ output ) { global $ n ; $ l_in = $ l * $ n ; $ r_in = ( ( int ) ( ( $ l + $ r ) / 2 ) + 1 ) * $ n ; $ l_c = ( int ) ( ( ( ( $ l + $ r ) / 2 ) - $ l + 1 ) * $ n ) ; $ r_c = ( $ r - ( int ) ( ( $ l + $ r ) / 2 ) ) * $ n ; $ l_arr = array_fill ( 0 , $ l_c , 0 ) ; $ r_arr = array_fill ( 0 , $ r_c , 0 ) ; for ( $ i = 0 ; $ i < $ l_c ; $ i ++ ) $ l_arr [ $ i ] = $ output [ $ l_in + $ i ] ; for ( $ i = 0 ; $ i < $ r_c ; $ i ++ ) $ r_arr [ $ i ] = $ output [ $ r_in + $ i ] ; $ l_curr = 0 ; $ r_curr = 0 ; $ in = $ l_in ; while ( $ l_curr + $ r_curr < $ l_c + $ r_c ) { if ( $ r_curr == $ r_c || ( $ l_curr != $ l_c && $ l_arr [ $ l_curr ] < $ r_arr [ $ r_curr ] ) ) { $ output [ $ in ] = $ l_arr [ $ l_curr ] ; $ l_curr ++ ; $ in ++ ; } else { $ output [ $ in ] = $ r_arr [ $ r_curr ] ; $ r_curr ++ ; $ in ++ ; } } } function divide ( $ l , $ r , & $ output , $ arr ) { global $ n ; if ( $ l == $ r ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ output [ $ l * $ n + $ i ] = $ arr [ $ l ] [ $ i ] ; return ; } divide ( $ l , ( int ) ( ( $ l + $ r ) / 2 ) , $ output , $ arr ) ; divide ( ( int ) ( ( $ l + $ r ) / 2 ) + 1 , $ r , $ output , $ arr ) ; merge ( $ l , $ r , $ output ) ; } $ arr = array ( array ( 5 , 7 , 15 , 18 ) , array ( 1 , 8 , 9 , 17 ) , array ( 1 , 4 , 7 , 7 ) ) ; $ k = count ( $ arr ) ; $ output = array_fill ( 0 , $ n * $ k , 0 ) ; divide ( 0 , $ k - 1 , $ output , $ arr ) ; for ( $ i = 0 ; $ i < $ n * $ k ; $ i ++ ) print ( $ output [ $ i ] . \" ▁ \" ) ; ? >"}
{"text": "Mengira unsur -unsur yang berbeza dalam array | Program PHP untuk mengira unsur -unsur yang berbeza dalam array tertentu; Pilih semua elemen satu demi satu; Jika tidak dicetak lebih awal, kemudian cetaknya; Kod pemacu", "code": "< ? php function countDistinct ( & $ arr , $ n ) { $ res = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) break ; if ( $ i == $ j ) $ res ++ ; } return $ res ; } $ arr = array ( 12 , 10 , 9 , 45 , 2 , 10 , 10 , 45 ) ; $ n = count ( $ arr ) ; echo countDistinct ( $ arr , $ n ) ; ? >"}
{"text": "Mengira unsur -unsur yang berbeza dalam array | Program PHP untuk mengira semua elemen yang berbeza dalam array tertentu; Pertama menyusun array supaya semua kejadian menjadi berturut -turut; Melintasi array yang disusun; Gerakkan indeks di hadapan sementara terdapat pendua; Kod pemacu", "code": "< ? php function countDistinct ( $ arr , $ n ) { sort ( $ arr , 0 ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ i < $ n - 1 && $ arr [ $ i ] == $ arr [ $ i + 1 ] ) $ i ++ ; $ res ++ ; } return $ res ; } $ arr = array ( 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ) ; $ n = sizeof ( $ arr ) ; echo countDistinct ( $ arr , $ n ) ; ? >"}
{"text": "Pilih n elemen supaya maksudnya adalah maksimum | Fungsi utiliti untuk mencetak kandungan array; Berfungsi untuk mencetak array dengan min maksimum; Susun array asal; Membina array baru; Cetak array yang dihasilkan; Kod pemacu", "code": "< ? php function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } function printMaxMean ( $ arr , $ n ) { $ newArr [ $ n ] = array ( ) ; sort ( $ arr , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ newArr [ $ i ] = $ arr [ $ i + $ n ] ; printArray ( $ newArr , $ n ) ; } $ arr = array ( 4 , 8 , 3 , 1 , 3 , 7 , 0 , 4 ) ; $ n = sizeof ( $ arr ) ; printMaxMean ( $ arr , $ n / 2 ) ;"}
{"text": "Rata -rata elemen yang tinggal selepas mengeluarkan elemen terbesar dan k terkecil dari Array | Berfungsi untuk mencari purata; Kes asas jika 2 * k> = n bermaksud semua elemen akan dikeluarkan; Susun pertama semua elemen; Jumlah nombor Req; Cari purata; Kod pemacu", "code": "< ? php function average ( $ arr , $ n , $ k ) { $ total = 0 ; if ( 2 * $ k >= $ n ) return 0 ; sort ( $ arr ) ; $ start = $ k ; $ end = $ n - $ k - 1 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) $ total += $ arr [ $ i ] ; return ( $ total / ( $ n - 2 * $ k ) ) ; } $ arr = array ( 1 , 2 , 4 , 4 , 5 , 6 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; echo average ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Jumlah minimum selepas menolak gandaan k dari unsur -unsur array | berfungsi untuk mengira jumlah minimum selepas transformasi; tiada elemen dapat dikurangkan lagi; Jika semua elemen array adalah sama; Semak sama ada [i] boleh dikurangkan kepada [0]; Salah satu elemen tidak dapat dikurangkan menjadi sama dengan unsur -unsur lain; jika k = 1 maka semua elemen dapat dikurangkan kepada 1; Kod pemacu", "code": "< ? php function min_sum ( $ n , $ k , $ a ) { sort ( $ a ) ; if ( $ a [ 0 ] < 0 ) return -1 ; if ( $ k == 0 ) { if ( $ a [ 0 ] == $ a [ $ n - 1 ] ) return ( $ n * $ a [ 0 ] ) ; else return -1 ; } else { $ f = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ p = $ a [ $ i ] - $ a [ 0 ] ; if ( $ p % $ k == 0 ) continue ; else { $ f = 1 ; break ; } } if ( $ f ) return -1 ; else { if ( $ k == 1 ) return $ n ; else return ( $ n * ( $ a [ 0 ] % $ k ) ) ; } } } $ arr = array ( 2 , 3 , 4 , 5 ) ; $ K = 1 ; $ N = count ( $ arr ) ; echo min_sum ( $ N , $ K , $ arr ) ; ? >"}
{"text": "Peningkatan / Pengurangan Minimum Untuk Membuat Elemen Array Sama | Berfungsi untuk mengembalikan operasi minimum perlu membuat setiap elemen array sama; Memulakan kos kepada 0; Susun array; Elemen tengah; Cari kos; Jika n, juga. Mengambil minimum kos yang diperoleh dengan mempertimbangkan kedua -dua elemen pertengahan; Cari kos lagi; Ambil minimum dua kos; Mengembalikan jumlah kos; Kod pemacu", "code": "< ? php function minCost ( $ A , $ n ) { $ cost = 0 ; sort ( $ A ) ; $ K = $ A [ $ n / 2 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cost += abs ( $ A [ $ i ] - $ K ) ; if ( $ n % 2 == 0 ) { $ tempCost = 0 ; $ K = $ A [ ( $ n / 2 ) - 1 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ tempCost += abs ( $ A [ $ i ] - $ K ) ; $ cost = min ( $ cost , $ tempCost ) ; } return $ cost ; } $ A = array ( 1 , 6 , 7 , 10 ) ; $ n = sizeof ( $ A ) ; echo minCost ( $ A , $ n ) ; ? >"}
{"text": "Cetak Elemen Arahan dalam Perintah Meningkatkan dan Menurunkan Alternatif | Berfungsi untuk mencetak elemen array dalam peningkatan alternatif dan penurunan urutan; Pertama menyusun array dalam peningkatan urutan; Mulakan dengan 2 elemen dalam peningkatan urutan; Sehingga semua elemen tidak dicetak; Mencetak unsur -unsur dalam peningkatan urutan; lain mencetak unsur -unsur dalam penurunan urutan; meningkatkan bilangan elemen untuk dicetak dalam lelaran seterusnya; Kod pemacu", "code": "< ? php function printArray ( $ arr , $ n ) { sort ( $ arr ) ; $ l = 0 ; $ r = $ n - 1 ; $ flag = 0 ; $ k = 2 ; while ( $ l <= $ r ) { if ( $ flag == 0 ) { for ( $ i = $ l ; $ i < $ l + $ k && $ i <= $ r ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; $ flag = 1 ; $ l = $ i ; } { for ( $ i = $ r ; $ i > $ r - $ k && $ i >= $ l ; $ i -- ) echo $ arr [ $ i ] , \" ▁ \" ; $ flag = 0 ; $ r = $ i ; } $ k ++ ; } } $ n = 6 ; $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 ) ; printArray ( $ arr , $ n ) ; ? >"}
{"text": "Semak jika watak -watak rentetan yang diberikan dalam susunan abjad | Fungsi yang memeriksa sama ada rentetan dalam susunan abjad atau tidak; Jika elemen pada indeks 'i' kurang daripada elemen pada indeks 'i - 1' maka rentetan tidak disusun; Kod pemacu; periksa sama ada rentetan dalam susunan abjad atau tidak", "code": "< ? php function isAlphabaticOrder ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] < $ s [ $ i - 1 ] ) return false ; } return true ; } $ s = \" aabbbcc \" ; if ( isAlphabaticOrder ( $ s ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak sama ada mungkin untuk menyusun semula segi empat tepat dalam bukan | Berfungsi untuk memeriksa sama ada mungkin untuk membentuk segi empat tepat dengan ketinggian sebagai tidak naik; Tetapkan maksimum; Gantikan maksimum dengan maksimum sebelumnya; menggantikan minimum dengan minimum sebelumnya; Cetak tidak jika dua syarat di atas gagal sekurang -kurangnya sekali; memulakan bilangan segi empat tepat; memulakan segi empat tepat dengan panjang dan lebar", "code": "< ? php function rotateRec ( $ n , $ L , $ B ) { $ m = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( max ( $ L [ $ i ] , $ B [ $ i ] ) <= $ m ) $ m = max ( $ L [ $ i ] , $ B [ $ i ] ) ; else if ( min ( $ L [ $ i ] , $ B [ $ i ] ) <= $ m ) $ m = min ( $ L [ $ i ] , $ B [ $ i ] ) ; else { return 0 ; } } return 1 ; } $ n = 3 ; $ L = array ( 5 , 5 , 6 ) ; $ B = array ( 6 , 7 , 8 ) ; if ( rotateRec ( $ n , $ L , $ B ) == 1 ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Cari titik sedemikian rupa sehingga jumlah jarak Manhattan diminimumkan | Berfungsi untuk mencetak titik yang diperlukan yang meminimumkan jumlah jarak Manhattan; Menyusun mata dalam semua dimensi K; Output titik k yang diperlukan; Kod pemacu; fungsi panggilan untuk mencetak mata yang diperlukan", "code": "< ? php function minDistance ( $ n , $ k , & $ point ) { for ( $ i = 0 ; $ i < $ k ; ++ $ i ) sort ( $ point [ $ i ] ) ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) echo $ point [ $ i ] [ ( ceil ( ( double ) $ n / 2 ) - 1 ) ] . \" ▁ \" ; } $ n = 4 ; $ k = 4 ; $ point = array ( array ( 1 , 5 , 2 , 4 ) , array ( 6 , 2 , 0 , 6 ) , array ( 9 , 5 , 1 , 3 ) , array ( 6 , 7 , 5 , 9 ) ) ; minDistance ( $ n , $ k , $ point ) ; ? >"}
{"text": "Susun nilai k pertama dalam urutan menaik dan baki n | Berfungsi untuk menyusun array; Simpan elemen k dalam array; Simpan elemen n - k yang tersisa dalam pelbagai; menyusun array dari 0 hingga k - 1 tempat; menyusun array dari tempat k ke n; menyimpan nilai -nilai dalam array array akhir; mencetak array; Kod pemacu", "code": "< ? php function printOrder ( $ arr , $ n , $ k ) { $ len1 = $ k ; $ len2 = $ n - $ k ; $ arr1 = array_fill ( 0 , $ k , 0 ) ; $ arr2 = array_fill ( 0 , ( $ n - $ k ) , 0 ) ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ arr1 [ $ i ] = $ arr [ $ i ] ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) $ arr2 [ $ i - $ k ] = $ arr [ $ i ] ; sort ( $ arr1 ) ; sort ( $ arr2 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ i < $ k ) $ arr [ $ i ] = $ arr1 [ $ i ] ; else { $ arr [ $ i ] = $ arr2 [ $ len2 - 1 ] ; $ len2 -= 1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) print ( $ arr [ $ i ] . \" ▁ \" ) ; } $ arr = array ( 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , -1 ) ; $ k = 4 ; $ n = count ( $ arr ) ; printOrder ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Cari nombor terbesar yang boleh dibentuk dengan digit yang diberikan | Berfungsi untuk menjana nombor terbesar yang mungkin dengan digit yang diberikan; Mengisytiharkan pelbagai hash saiz 10 dan memulakan semua elemen kepada sifar; Simpan bilangan kejadian digit dalam array yang diberikan ke dalam jadual hash; Melintasi hash dalam perintah menurun untuk mencetak nombor yang diperlukan; Cetak bilangan kali digit berlaku; Kod pemacu", "code": "< ? php function findMaxNum ( $ arr , $ n ) { $ hash = array_fill ( 0 , 10 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ hash [ $ arr [ $ i ] ] += 1 ; for ( $ i = 9 ; $ i >= 0 ; $ i -- ) for ( $ j = 0 ; $ j < $ hash [ $ i ] ; $ j ++ ) echo $ i ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 0 ) ; $ n = sizeof ( $ arr ) ; findMaxNum ( $ arr , $ n ) ; ? >"}
{"text": "Sama -sama membahagikan kepada dua set supaya satu set mempunyai unsur -unsur maksimum yang berbeza | Program PHP untuk sama -sama membahagikan elemen N ke dalam dua set sehingga set kedua mempunyai unsur -unsur maksimum yang berbeza. ; Kod pemacu", "code": "< ? php function distribution ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) $ count ++ ; return min ( $ count , $ n / 2 ) ; } $ arr = array ( 1 , 1 , 2 , 1 , 3 , 4 ) ; $ n = count ( $ arr ) ; echo ( distribution ( $ arr , $ n ) ) ; ? >"}
{"text": "Susun 3 nombor | Program PHP untuk menyusun pelbagai saiz 3", "code": "< ? php $ a = array ( 10 , 12 , 5 ) ; sort ( $ a ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) echo $ a [ $ i ] , \" ▁ \" ; ? >"}
{"text": "Cetak tiga kali ganda dengan jumlah kurang daripada k | Program PHP yang mudah untuk mengira tiga kali ganda dengan jumlah yang lebih kecil daripada nilai tertentu; Betulkan elemen pertama sebagai [i]; Betulkan elemen kedua sebagai [J]; Sekarang cari nombor ketiga; Kod pemacu", "code": "< ? php function printTriplets ( & $ arr , $ n , $ sum ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] < $ sum ) { echo ( $ arr [ $ i ] ) ; echo ( \" , ▁ \" ) ; echo ( $ arr [ $ j ] ) ; echo ( \" , ▁ \" ) ; echo ( $ arr [ $ k ] ) ; echo ( \" STRNEWLINE \" ) ; } } } } $ arr = array ( 5 , 1 , 3 , 4 , 7 ) ; $ n = sizeof ( $ arr ) ; $ sum = 12 ; printTriplets ( $ arr , $ n , $ sum ) ; ? >"}
{"text": "Kira nombor tiga dalam array yang mempunyai jumlah dalam julat [a, b] | Berfungsi untuk mengira tiga kali ganda; Memulakan hasil; Betulkan elemen pertama sebagai [i]; Betulkan elemen kedua sebagai [J]; Sekarang cari nombor ketiga; Kod pemacu", "code": "< ? php function countTriplets ( $ arr , $ n , $ a , $ b ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] >= $ a && $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] <= $ b ) $ ans ++ ; } } return $ ans ; } $ arr = array ( 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 ) ; $ n = sizeof ( $ arr ) ; $ a = 8 ; $ b = 16 ; echo countTriplets ( $ arr , $ n , $ a , $ b ) . \" \" ; ? >"}
{"text": "Kira nombor tiga dalam array yang mempunyai jumlah dalam julat [a, b] | Fungsi untuk mencari kiraan tiga kali ganda yang mempunyai jumlah kurang daripada atau sama dengan val. ; Susun array input. ; Memulakan hasil; untuk menyimpan jumlah; Betulkan elemen pertama; Mulakan dua elemen lain sebagai elemen sudut Subarray Arr [J + 1. k]; Gunakan bertemu dalam konsep tengah. ; Jika jumlah triplet semasa lebih besar, maka untuk mengurangkannya berkurangan k. ; Jika jumlahnya kurang daripada atau sama dengan nilai yang diberikan, maka tambahkan kemungkinan tiga kali ganda (k - j) hasilnya. ; Fungsi untuk mengembalikan kiraan tiga kali ganda yang mempunyai jumlah julat [A, B]. ; Untuk menyimpan kiraan tiga kali ganda. ; Cari kiraan tiga kali ganda yang mempunyai jumlah yang kurang daripada atau sama dengan b dan tolak kiraan tiga kali ganda yang mempunyai jumlah kurang daripada atau sama dengan a - 1 .; Kod pemacu", "code": "< ? php function countTripletsLessThan ( $ arr , $ n , $ val ) { sort ( $ arr ) ; $ ans = 0 ; $ sum ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { $ j = $ i + 1 ; $ k = $ n - 1 ; while ( $ j != $ k ) { $ sum = $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] ; if ( $ sum > $ val ) $ k -- ; else { $ ans += ( $ k - $ j ) ; $ j ++ ; } } } return $ ans ; } function countTriplets ( $ arr , $ n , $ a , $ b ) { $ res ; $ res = countTripletsLessThan ( $ arr , $ n , $ b ) - countTripletsLessThan ( $ arr , $ n , $ a - 1 ) ; return $ res ; } $ arr = array ( 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 ) ; $ n = sizeof ( $ arr ) ; $ a = 8 ; $ b = 16 ; echo countTriplets ( $ arr , $ n , $ a , $ b ) , \" \" ; ? >"}
{"text": "Jumlah kawasan segi empat tepat mungkin untuk array | Berfungsi untuk mencari kawasan segi empat tepat; menyusun array dalam urutan menurun; Simpan jumlah akhir semua kawasan segi empat tepat yang mungkin; Pembolehubah sementara untuk menyimpan panjang segi empat tepat; Memilih panjang segi empat tepat supaya perbezaan antara mana -mana dua nombor adalah 1 sahaja. Di sini panjang dipilih supaya bendera ditetapkan; Bendera ditetapkan bermakna kita mempunyai panjang segi empat tepat; Panjang ditetapkan kepada [i + 1] supaya jika [i + 1] kurang daripada [i] oleh 1 maka juga kita mempunyai cecair yang betul untuk panjang; Meningkatkan kaunter sekali lagi kerana kami telah mempertimbangkan elemen [i + 1] juga. ; Memilih lebar segi empat tepat supaya perbezaan antara mana -mana dua nombor adalah 1 sahaja. Di sini lebar dipilih supaya sekarang bendera tidak lagi tidak dapat ditemui untuk segi empat tepat seterusnya; Kawasan dikira untuk segi empat tepat; Bendera ditetapkan palsu untuk segi empat tepat lain yang boleh kita dapatkan dari unsur -unsur dalam array; Meningkatkan kaunter sekali lagi kerana kami telah mempertimbangkan elemen [i + 1] juga. ; Kod pemacu", "code": "< ? php function MaxTotalRectangleArea ( $ a , $ n ) { rsort ( $ a ) ; $ sum = 0 ; $ flag = false ; $ len ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ a [ $ i ] == $ a [ $ i + 1 ] or $ a [ $ i ] - $ a [ $ i + 1 ] == 1 ) and ( ! $ flag ) ) { $ flag = true ; $ len = $ a [ $ i + 1 ] ; $ i ++ ; } else if ( ( $ a [ $ i ] == $ a [ $ i + 1 ] or $ a [ $ i ] - $ a [ $ i + 1 ] == 1 ) and ( $ flag ) ) { $ sum = $ sum + $ a [ $ i + 1 ] * $ len ; $ flag = false ; $ i ++ ; } } return $ sum ; } $ a = array ( 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 ) ; $ n = count ( $ a ) ; echo MaxTotalRectangleArea ( $ a , $ n ) ; ? >"}
{"text": "Jenis stabil untuk perintah menurun | Pelaksanaan jenis gelembung untuk menyusun elemen dalam urutan menurun. ; Sediakan [] dalam urutan menurun menggunakan jenis gelembung. ; Kod pemacu", "code": "< ? php function swap ( & $ x , & $ y ) { $ x ^= $ y ^= $ x ^= $ y ; } function print1 ( $ a , $ n ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) echo ( $ a [ $ i ] . \" ▁ \" ) ; echo ( \" STRNEWLINE \" ) ; } function sort1 ( $ a , $ n ) { for ( $ i = $ n ; $ i >= 0 ; $ i -- ) { for ( $ j = $ n ; $ j > $ n - $ i ; $ j -- ) { if ( $ a [ $ j ] > $ a [ $ j - 1 ] ) swap ( $ a [ $ j ] , $ a [ $ j - 1 ] ) ; } } print1 ( $ a , $ n ) ; } $ n = 6 ; $ a = array ( ) ; array_push ( $ a , 2 ) ; array_push ( $ a , 4 ) ; array_push ( $ a , 3 ) ; array_push ( $ a , 2 ) ; array_push ( $ a , 4 ) ; array_push ( $ a , 5 ) ; array_push ( $ a , 3 ) ; sort1 ( $ a , $ n ) ; ? >"}
{"text": "Jumlah jarak Manhattan antara semua pasangan mata | Kembalikan jumlah jarak antara semua pasangan mata. ; Untuk setiap titik, mencari jarak untuk berehat di titik; Kod pemacu", "code": "< ? php function distancesum ( $ x , $ y , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ sum += ( abs ( $ x [ $ i ] - $ x [ $ j ] ) + abs ( $ y [ $ i ] - $ y [ $ j ] ) ) ; return $ sum ; } $ x = array ( -1 , 1 , 3 , 2 ) ; $ y = array ( 5 , 6 , 5 , 3 ) ; $ n = count ( $ x ) ; echo distancesum ( $ x , $ y , $ n ) ; ? >"}
{"text": "Jumlah jarak Manhattan antara semua pasangan mata | Kembalikan jumlah jarak satu paksi. ; menyusun array. ; Untuk setiap titik, mencari jarak. ; Kod pemacu", "code": "< ? php function distancesum ( $ arr , $ n ) { sort ( $ arr ) ; $ res = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ res += ( $ arr [ $ i ] * $ i - $ sum ) ; $ sum += $ arr [ $ i ] ; } return $ res ; } function totaldistancesum ( $ x , $ y , $ n ) { return distancesum ( $ x , $ n ) + distancesum ( $ y , $ n ) ; } $ x = array ( -1 , 1 , 3 , 2 ) ; $ y = array ( 5 , 6 , 5 , 3 ) ; $ n = sizeof ( $ x ) ; echo totaldistancesum ( $ x , $ y , $ n ) , \" \" ; ? >"}
{"text": "Median selepas ka tambahan K | Cari median array selepas menambah elemen K; Menyusun array dalam peningkatan urutan. ; Mencetak median array. Oleh kerana n + k sentiasa ganjil dan k <n, jadi median array sentiasa terletak dalam julat n. ; Kod pemacu", "code": "< ? php function printMedian ( $ arr , $ n , $ K ) { sort ( $ arr ) ; echo $ arr [ ( $ n + $ K ) / 2 ] ; } $ arr = array ( 5 , 3 , 2 , 8 ) ; $ k = 3 ; $ n = count ( $ arr ) ; printMedian ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Susun array mengikut perbezaan mutlak dengan nilai yang diberikan \"Menggunakan ~ constant amp or e space\" | Program PHP untuk menyusun array berdasarkan perbezaan mutlak dengan nilai x yang diberikan. ; Baris di bawah adalah serupa dengan jenis penyisipan; Masukkan arr [i] di tempat yang betul; Berfungsi untuk mencetak array; Kod pemacu", "code": "< ? php function arrange ( $ arr , $ n , $ x ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ diff = abs ( $ arr [ $ i ] - $ x ) ; $ j = $ i - 1 ; if ( abs ( $ arr [ $ j ] - $ x ) > $ diff ) { $ temp = $ arr [ $ i ] ; while ( abs ( $ arr [ $ j ] - $ x ) > $ diff && $ j >= 0 ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ j -- ; } $ arr [ $ j + 1 ] = $ temp ; } } return $ arr ; } function print_arr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } $ arr = array ( 10 , 5 , 3 , 9 , 2 ) ; $ n = sizeof ( $ arr ) ; $ x = 7 ; $ arr1 = arrange ( $ arr , $ n , $ x ) ; print_arr ( $ arr1 , $ n ) ; ? >"}
{"text": "Susun separuh pertama dalam menaik dan separuh kedua dalam perintah menurun | 1 | berfungsi untuk mencetak separuh daripada array dalam urutan menaik dan separuh lagi dalam urutan menurun; menyusun array; Percetakan separuh pertama dalam urutan menaik; mencetak separuh kedua dalam urutan menurun; Kod pemacu", "code": "< ? php function printOrder ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; for ( $ j = $ n - 1 ; $ j >= $ n / 2 ; $ j -- ) echo $ arr [ $ j ] . \" ▁ \" ; } $ arr = array ( 5 , 4 , 6 , 2 , 1 , 3 , 8 , -1 ) ; $ n = sizeof ( $ arr ) ; printOrder ( $ arr , $ n ) ; ? >"}
{"text": "Cari jumlah minimum dan maksimum untuk membeli semua gula -gula n | Berfungsi untuk mencari jumlah minimum untuk membeli semua gula -gula; Membeli gula -gula semasa; Dan ambil gula -gula secara percuma dari yang terakhir; Berfungsi untuk mencari jumlah maksimum untuk membeli semua gula -gula; Membeli gula -gula dengan jumlah maksimum; Dan dapatkan gula -gula secara percuma dari permulaan; Kod pemacu; Panggilan fungsi", "code": "< ? php function findMinimum ( $ arr , $ n , $ k ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ res += $ arr [ $ i ] ; $ n = $ n - $ k ; } return $ res ; } function findMaximum ( $ arr , $ n , $ k ) { $ res = 0 ; $ index = 0 ; for ( $ i = $ n - 1 ; $ i >= $ index ; $ i -- ) { $ res += $ arr [ $ i ] ; $ index += $ k ; } return $ res ; } $ arr = array ( 3 , 2 , 1 , 4 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; sort ( $ arr ) ; sort ( $ arr , $ n ) ; echo findMinimum ( $ arr , $ n , $ k ) , \" \" , findMaximum ( $ arr , $ n , $ k ) ; return 0 ; ? >"}
{"text": "Cari piramid ketinggian maksimum dari pelbagai objek yang diberikan | Mengembalikan bilangan maksimum paras piramidcal n kotak lebar yang diberikan. ; Menyusun objek dalam meningkatkan urutan lebar; Memulakan hasil; Jumlah lebar tahap sebelumnya dan jumlah objek di peringkat sebelumnya; Bilangan objek dalam tahap semasa. ; Lebar tahap semasa. ; Memilih objek. Oleh itu, tingkatkan lebar semasa dan bilangan objek. ; Jika lebar semasa dan bilangan objek lebih besar daripada sebelumnya. ; Kemas kini lebar sebelumnya, bilangan objek pada tahap sebelumnya. ; Tetapkan semula lebar tahap semasa, bilangan objek pada tahap semasa. ; Peningkatan bilangan tahap. ; Kod pemacu", "code": "< ? php function maxLevel ( $ boxes , $ n ) { sort ( $ boxes ) ; $ ans = 1 ; $ prev_width = $ boxes [ 0 ] ; $ prev_count = 1 ; $ curr_count = 0 ; $ curr_width = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_width += $ boxes [ $ i ] ; $ curr_count += 1 ; if ( $ curr_width > $ prev_width and $ curr_count > $ prev_count ) { $ prev_width = $ curr_width ; $ prev_count = $ curr_count ; $ curr_count = 0 ; $ curr_width = 0 ; $ ans ++ ; } } return $ ans ; } $ boxes = array ( 10 , 20 , 30 , 50 , 60 , 70 ) ; $ n = count ( $ boxes ) ; echo maxLevel ( $ boxes , $ n ) ; ? >"}
{"text": "Susun semua nombor dalam urutan menaik dan kemudian menyusun semua nombor ganjil dalam urutan menurun | Untuk melakukan jenis dua cara. Susun pertama nombor walaupun dalam urutan menaik, kemudian nombor ganjil dalam urutan menurun. ; Buat semua nombor ganjil negatif; jika ($ arr [$ i] & 1) Semak ganjil; Menyusun semua nombor; Mengekalkan array asal; Kod pemacu", "code": "< ? php function twoWaySort ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] *= -1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] & 1 ) $ arr [ $ i ] *= -1 ; } $ arr = array ( 1 , 3 , 2 , 7 , 5 , 4 ) ; $ n = sizeof ( $ arr ) ; twoWaySort ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Mungkin untuk membentuk segitiga dari nilai array | Kaedah mencetak segi tiga yang mungkin apabila nilai array diambil sebagai sisi; Jika bilangan elemen kurang daripada 3, maka tidak ada segitiga yang mungkin; pertama menyusun array; gelung untuk semua 3 tiga kali ganda berturut -turut; Jika triplet memenuhi keadaan segitiga, pecah; Kod pemacu", "code": "< ? php function isPossibleTriangle ( $ arr , $ N ) { if ( $ N < 3 ) return false ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ N - 2 ; $ i ++ ) if ( $ arr [ $ i ] + $ arr [ $ i + 1 ] > $ arr [ $ i + 2 ] ) return true ; } $ arr = array ( 5 , 4 , 3 , 1 , 2 ) ; $ N = count ( $ arr ) ; if ( isPossibleTriangle ( $ arr , $ N ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "K | Program PHP untuk mencari elemen terkecil k - selepas mengeluarkan beberapa bilangan bulat dari nombor semula jadi. ; Kembalikan elemen terkecil. ; Membuat array, dan tandakan semua nombor sebagai tidak ditanda. ; Menandakan nombor yang ada dalam array yang diberikan. ; Jika j tidak ditandakan, kurangkan k oleh 1 .; Jika k adalah 0 pulangan j. ; Kod pemacu", "code": "< ? php $ MAX = 10000 ; function ksmallest ( $ arr , $ n , $ k ) { global $ MAX ; $ b = array_fill ( 0 , $ MAX , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ b [ $ arr [ $ i ] ] = 1 ; for ( $ j = 1 ; $ j < $ MAX ; $ j ++ ) { if ( $ b [ $ j ] != 1 ) $ k -- ; if ( $ k == 0 ) return $ j ; } } $ k = 1 ; $ arr = array ( 1 ) ; $ n = count ( $ arr ) ; echo ksmallest ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Sort Array apabila dua bahagian disusun | Program PHP untuk menggabungkan dua bahagian yang disusun mengikut array ke dalam array yang disusun tunggal; Susun array yang diberikan menggunakan sort STL; Kod pemacu; Cetak array yang disusun", "code": "< ? php function mergeTwoHalf ( & $ A , $ n ) { sort ( $ A , 0 ) ; } $ A = array ( 2 , 3 , 8 , -1 , 7 , 10 ) ; $ n = sizeof ( $ A ) ; mergeTwoHalf ( $ A , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ A [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Pilih elemen array k sedemikian rupa sehingga perbezaan maksimum dan minimum diminimumkan | Kembalikan perbezaan minimum maksimum dan minimum elemen k Arr [0. .. n - 1]. ; Menyusun array. ; Cari nilai minimum di antara semua subarray saiz K. ; Kod pemacu", "code": "< ? php function minDiff ( $ arr , $ n , $ k ) { $ INT_MAX = 2147483647 ; $ result = $ INT_MAX ; sort ( $ arr , $ n ) ; sort ( $ arr ) ; for ( $ i = 0 ; $ i <= $ n - $ k ; $ i ++ ) $ result = min ( $ result , $ arr [ $ i + $ k - 1 ] - $ arr [ $ i ] ) ; return $ result ; } $ arr = array ( 10 , 100 , 300 , 200 , 1000 , 20 , 30 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; echo minDiff ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Bilangan swap untuk disusun apabila hanya swap bersebelahan dibenarkan | Fungsi ini menggabungkan dua susunan yang disusun dan mengembalikan kiraan penyongsangan dalam tatasusunan. ; Saya adalah indeks untuk subarray kiri; J adalah indeks untuk subarray kanan; k ialah indeks untuk subarray yang digabungkan; Ini adalah rumit - lihat di atas penjelasan / rajah untuk gabungan (); Salin unsur -unsur yang tersisa dari subarray kiri (jika ada) untuk temp; Salin unsur -unsur yang tersisa dari subarray kanan (jika ada) untuk temp; Salin kembali elemen yang digabungkan ke array asal; Fungsi rekursif tambahan yang menyusun pelbagai input dan mengembalikan bilangan penyongsangan dalam array. ; Bahagikan array ke dalam dua bahagian dan panggil _mergesortandCountInv () untuk setiap bahagian; Kiraan penyongsangan akan menjadi jumlah penyongsangan di bahagian kiri - bahagian, kanan - bahagian dan bilangan penyongsangan dalam penggabungan; Gabungkan kedua -dua bahagian; Fungsi ini menyusun pelbagai input dan mengembalikan bilangan penyongsangan dalam array; Pemacu pemacu untuk menguji fungsi di atas", "code": "< ? php function merge ( & $ arr , & $ temp , $ left , $ mid , $ right ) { $ inv_count = 0 ; $ i = $ left ; $ j = $ mid ; $ k = $ left ; while ( ( $ i <= $ mid - 1 ) && ( $ j <= $ right ) ) { if ( $ arr [ $ i ] <= $ arr [ $ j ] ) $ temp [ $ k ++ ] = $ arr [ $ i ++ ] ; else { $ temp [ $ k ++ ] = $ arr [ $ j ++ ] ; $ inv_count = $ inv_count + ( $ mid - $ i ) ; } } while ( $ i <= $ mid - 1 ) $ temp [ $ k ++ ] = $ arr [ $ i ++ ] ; while ( $ j <= $ right ) $ temp [ $ k ++ ] = $ arr [ $ j ++ ] ; for ( $ i = $ left ; $ i <= $ right ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; return $ inv_count ; } function _mergeSort ( & $ arr , & $ temp , $ left , $ right ) { $ inv_count = 0 ; if ( $ right > $ left ) { $ mid = intval ( ( $ right + $ left ) / 2 ) ; $ inv_count = _mergeSort ( $ arr , $ temp , $ left , $ mid ) ; $ inv_count += _mergeSort ( $ arr , $ temp , $ mid + 1 , $ right ) ; $ inv_count += merge ( $ arr , $ temp , $ left , $ mid + 1 , $ right ) ; } return $ inv_count ; } function countSwaps ( & $ arr , $ n ) { $ temp = array_fill ( 0 , $ n , NULL ) ; return _mergeSort ( $ arr , $ temp , 0 , $ n - 1 ) ; } $ arr = array ( 1 , 20 , 6 , 4 , 5 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo \" Number ▁ of ▁ swaps ▁ is ▁ \" . countSwaps ( $ arr , $ n ) ; return 0 ; ? >"}
{"text": "Semak sama ada nombor tertentu adalah atau ganjil | Pulangan benar jika n adalah walaupun, lain -lain ganjil; Kod pemacu", "code": "< ? php function isEven ( $ n ) { return ( $ n % 2 == 0 ) ; } $ n = 101 ; if ( isEven != true ) echo \" Even \" ; else echo \" Odd \" ; ? >"}
{"text": "Cari kiraan surpasser setiap elemen dalam array | Berfungsi untuk mencari kiraan surpasser setiap elemen dalam pelbagai; kedai surpasser kiraan untuk elemen arr [i]; Berfungsi untuk mencetak array; Kod pemacu", "code": "< ? php function findSurpasser ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ j ] > $ arr [ $ i ] ) $ count ++ ; echo $ count , \" \" ; } } function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 2 , 7 , 5 , 3 , 0 , 8 , 1 ) ; $ n = count ( $ arr ) ; echo \" Given ▁ array ▁ is ▁ STRNEWLINE \" ; printArray ( $ arr , $ n ) ; echo \" Surpasser ▁ Count ▁ of ▁ array ▁ is ▁ STRNEWLINE \" ; findSurpasser ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah minimum dua nombor yang dibentuk dari digit array | Fungsi untuk mencari dan mengembalikan jumlah minimum dua nombor yang dibentuk dari digit array. ; Susun array; Biarkan dua nombor menjadi A dan B; Isi a dan b dengan setiap digit alternatif array input; mengembalikan jumlahnya; Kod pemacu", "code": "< ? php function solve ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ a = 0 ; $ b = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i & 1 ) $ a = $ a * 10 + $ arr [ $ i ] ; else $ b = $ b * 10 + $ arr [ $ i ] ; } return $ a + $ b ; } $ arr = array ( 6 , 8 , 4 , 5 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; echo \" Sum ▁ is ▁ \" , solve ( $ arr , $ n ) ; ? >"}
{"text": "Produk maksimum triplet (seterusnya saiz 3) dalam array | Berfungsi untuk mencari produk maksimum triplet dalam pelbagai integer saiz n; Jika saiz kurang daripada 3, tiada triplet wujud; akan mengandungi produk maks; Kod pemacu", "code": "< ? php function maxProduct ( $ arr , $ n ) { $ INT_MIN = 0 ; if ( $ n < 3 ) return -1 ; $ max_product = $ INT_MIN ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) $ max_product = max ( $ max_product , $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] ) ; return $ max_product ; } $ arr = array ( 10 , 3 , 5 , 6 , 20 ) ; $ n = sizeof ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) echo \" No ▁ Triplet ▁ Exists \" ; else echo \" Maximum ▁ product ▁ is ▁ \" , $ max ; ? >"}
{"text": "Produk maksimum triplet (seterusnya saiz 3) dalam array | Berfungsi untuk mencari produk maksimum triplet dalam pelbagai integer saiz n; Jika saiz kurang daripada 3, tiada triplet wujud; Membina empat vektor tambahan saiz n dan memulakannya dengan - 1; akan mengandungi produk maks; untuk menyimpan elemen maksimum di sebelah kiri array; untuk menyimpan elemen minimum di sebelah kiri array; leftmax [i] akan mengandungi elemen max di sebelah kiri arr [i] tidak termasuk arr [i]. Leftmin [i] akan mengandungi elemen min di sebelah kiri arr [i] tidak termasuk arr [i]. ; reset max_sum untuk menyimpan elemen maksimum di sebelah kanan array; reset min_sum untuk menyimpan elemen minimum di sebelah kanan array; rightmax [i] akan mengandungi elemen max di sebelah kanan arr [i] tidak termasuk arr [i]. rightmin [i] akan mengandungi elemen min di sebelah kanan arr [i] tidak termasuk arr [i]. ; Untuk semua indeks array i kecuali yang pertama dan terakhir, hitung maksimum arr [i] * x * y di mana x boleh ditinggalkan [i] atau leftmin [i] dan y boleh menjadi rightmax [i] atau rightmin [i]. ; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function maxProduct ( $ arr , $ n ) { if ( $ n < 3 ) return -1 ; $ leftMin = array_fill ( 0 , $ n , -1 ) ; $ rightMin = array_fill ( 0 , $ n , -1 ) ; $ leftMax = array_fill ( 0 , $ n , -1 ) ; $ rightMax = array_fill ( 0 , $ n , -1 ) ; $ max_product = PHP_INT_MIN ; $ max_sum = $ arr [ 0 ] ; $ min_sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ leftMax [ $ i ] = $ max_sum ; if ( $ arr [ $ i ] > $ max_sum ) $ max_sum = $ arr [ $ i ] ; $ leftMin [ $ i ] = $ min_sum ; if ( $ arr [ $ i ] < $ min_sum ) $ min_sum = $ arr [ $ i ] ; } $ max_sum = $ arr [ $ n - 1 ] ; $ min_sum = $ arr [ $ n - 1 ] ; for ( $ j = $ n - 2 ; $ j >= 0 ; $ j -- ) { $ rightMax [ $ j ] = $ max_sum ; if ( $ arr [ $ j ] > $ max_sum ) $ max_sum = $ arr [ $ j ] ; $ rightMin [ $ j ] = $ min_sum ; if ( $ arr [ $ j ] < $ min_sum ) $ min_sum = $ arr [ $ j ] ; } for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ max1 = max ( $ arr [ $ i ] * $ leftMax [ $ i ] * $ rightMax [ $ i ] , $ arr [ $ i ] * $ leftMin [ $ i ] * $ rightMin [ $ i ] ) ; $ max2 = max ( $ arr [ $ i ] * $ leftMax [ $ i ] * $ rightMin [ $ i ] , $ arr [ $ i ] * $ leftMin [ $ i ] * $ rightMax [ $ i ] ) ; $ max_product = max ( $ max_product , max ( $ max1 , $ max2 ) ) ; } return $ max_product ; } $ arr = array ( 1 , 4 , 3 , -6 , -7 , 0 ) ; $ n = count ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) echo \" No ▁ Triplet ▁ Exists \" ; else echo \" Maximum ▁ product ▁ is ▁ \" . $ max ; ? >"}
{"text": "Produk maksimum triplet (seterusnya saiz 3) dalam array | Berfungsi untuk mencari produk maksimum triplet dalam pelbagai integer saiz n; Jika saiz kurang daripada 3, tiada triplet wujud; Susun array dalam urutan menaik; Mengembalikan maksimum produk dari tiga elemen terakhir dan produk dari dua elemen pertama dan elemen terakhir; Kod pemacu", "code": "< ? php function maxProduct ( $ arr , $ n ) { if ( $ n < 3 ) { return -1 ; } sort ( $ arr ) ; return max ( $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ $ n - 1 ] , $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] * $ arr [ $ n - 3 ] ) ; } $ arr = array ( -10 , -3 , 5 , 6 , -20 ) ; $ n = sizeof ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) { echo ( \" No ▁ Triplet ▁ Exists \" ) ; } else { echo ( \" Maximum ▁ product ▁ is ▁ \" . $ max ) ; }"}
{"text": "Substring terbesar dengan watak yang sama | Berfungsi untuk mencari rentetan sub terbesar dengan aksara yang sama; Melintasi rentetan; Jika watak adalah sama dengan nilai suhu kenaikan sebelumnya; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "< ? php function Substring ( $ s ) { $ ans = 1 ; $ temp = 1 ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { ++ $ temp ; } else { $ ans = max ( $ ans , $ temp ) ; $ temp = 1 ; } } $ ans = max ( $ ans , $ temp ) ; return $ ans ; } $ s = \" abcdddddeff \" ; echo Substring ( $ s ) ; ? >"}
{"text": "Menjana pelbagai unsur k seperti jumlah elemen adalah n dan keadaan a [i] <a [i + 1] <= 2 * a [i] dipenuhi | Tetapkan 2 | Fungsi yang mencetak array yang dikehendaki yang memenuhi syarat -syarat yang diberikan; Jika keadaan pengisian terendah adalah tidak sah, maka tidak mungkin untuk menghasilkan array yang diperlukan; Meningkatkan semua elemen dengan CNT; Mula mengisi dari belakang sehingga nombor adalah [i + 1] <= 2 * a [i]; Dapatkan nombor yang akan diisi; Jika ia kurang daripada bilangan baki yang akan diisi; kurang daripada bilangan baki yang akan diisi; Dapatkan jumlah array; Jika keadaan ini tidak sah di mana -mana peringkat semasa mengisi, kemudian cetak - 1; Lain menambahnya kepada jumlah; Jika keadaan jumlah tidak dipenuhi, maka cetak - 1; Cetak array yang dihasilkan; Kod pemacu", "code": "< ? php function solve ( $ n , $ k ) { $ mini = 0 ; $ x1 = 1 ; $ a = array ( ) ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { $ mini += $ x1 ; $ a [ $ i - 1 ] = $ x1 ; $ x1 += 1 ; } if ( $ n < $ mini ) { echo \" - 1\" ; return ; } $ rem = $ n - $ mini ; $ cnt = floor ( $ rem / $ k ) ; $ rem = $ rem % $ k ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ a [ $ i ] += $ cnt ; for ( $ i = $ k - 1 ; $ i > 0 && $ rem > 0 ; $ i -- ) { $ xx = $ a [ $ i - 1 ] * 2 ; $ left = $ xx - $ a [ $ i ] ; if ( $ rem >= $ left ) { $ a [ $ i ] = $ xx ; $ rem -= $ left ; } else { $ a [ $ i ] += $ rem ; $ rem = 0 ; } } $ sum = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ k ; $ i ++ ) { if ( $ a [ $ i ] > 2 * $ a [ $ i - 1 ] ) { echo \" - 1\" ; return ; } $ sum += $ a [ $ i ] ; } if ( $ sum != $ n ) { echo \" - 1\" ; return ; } for ( $ i = 0 ; $ i < $ k ; $ i ++ ) echo $ a [ $ i ] , \" ▁ \" ; } $ n = 26 ; $ k = 6 ; solve ( $ n , $ k ) ; ? >"}
{"text": "Wang maksimum yang boleh ditarik balik dalam dua langkah | Berfungsi untuk mengembalikan duit syiling maksimum yang boleh kita dapatkan; Mengemas kini elemen seperti x> y; Mengambil dari maksimum; Mengisi semula; Sekali lagi, ambil maksimum; Kod pemacu", "code": "< ? php function maxCoins ( $ X , $ Y ) { if ( $ X < $ Y ) swap ( $ X , $ Y ) ; $ coins = $ X ; $ X -- ; $ coins += max ( $ X , $ Y ) ; return $ coins ; } $ X = 7 ; $ Y = 5 ; echo maxCoins ( $ X , $ Y ) ; ? >"}
{"text": "Unsur -unsur maksimum yang boleh diseberang menggunakan unit yang diberikan A dan B | Berfungsi untuk mencari bilangan elemen yang diseberang; Simpan salinan A; Berulang dalam array binari; Jika tidak A dan B ditinggalkan untuk digunakan; Sekiranya tidak ada; Gunakan b dan tambah A dengan 1 jika arr [i] adalah 1; hanya gunakan b; Gunakan A jika ada b; Meningkatkan a dan gunakan b jika arr [i] == 1; Gunakan A; Kod pemacu", "code": "< ? php function findElementsCrossed ( $ arr , $ a , $ b , $ n ) { $ aa = $ a ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a == 0 && $ b == 0 ) break ; else if ( $ a == 0 ) { if ( $ arr [ $ i ] == 1 ) { $ b -= 1 ; $ a = min ( $ aa , $ a + 1 ) ; } else $ b -= 1 ; } else if ( $ b == 0 ) $ a -- ; else if ( $ arr [ $ i ] == 1 && $ a < $ aa ) { $ b -= 1 ; $ a = min ( $ aa , $ a + 1 ) ; } else $ a -- ; $ ans ++ ; } return $ ans ; } $ arr = array ( 1 , 0 , 0 , 1 , 0 , 1 ) ; $ n = sizeof ( $ arr ) ; $ a = 1 ; $ b = 2 ; echo findElementsCrossed ( $ arr , $ a , $ b , $ n ) ; ? >"}
{"text": "Kira pasangan vokal dalam rentetan yang diberikan | Fungsi yang kembali benar jika watak ch adalah vokal; Berfungsi untuk mengembalikan kiraan pasangan vokal bersebelahan dalam rentetan yang diberikan; Jika watak semasa dan watak selepas kedua -dua vokal; Kod pemacu", "code": "< ? php function isVowel ( $ ch ) { if ( $ ch == ' a ' $ ch == ' e ' $ ch == ' i ' $ ch == ' o ' $ ch == ' u ' ) return true ; return false ; } function vowelPairs ( $ s , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( isVowel ( $ s [ $ i ] ) && isVowel ( $ s [ $ i + 1 ] ) ) $ cnt ++ ; } return $ cnt ; } $ s = \" abaebio \" ; $ n = strlen ( $ s ) ; echo vowelPairs ( $ s , $ n ) ; ? >"}
{"text": "Minimum Kemungkinan Kesihatan Akhir Raksasa Terakhir Dalam Permainan | Berfungsi untuk mengembalikan GCD dua nombor; Berfungsi untuk mengembalikan kesihatan minimum yang mungkin untuk raksasa; GCD elemen pertama dan kedua; GCD untuk semua elemen berikutnya; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function solve ( $ health , $ n ) { $ currentgcd = gcd ( $ health [ 0 ] , $ health [ 1 ] ) ; for ( $ i = 2 ; $ i < $ n ; ++ $ i ) { $ currentgcd = gcd ( $ currentgcd , $ health [ $ i ] ) ; } return $ currentgcd ; } $ health = array ( 4 , 6 , 8 , 12 ) ; $ n = sizeof ( $ health ) ; echo solve ( $ health , $ n ) ; ? >"}
{"text": "Bahagikan array ke dalam peningkatan dan penurunan seterusnya tanpa mengubah perintah | Berfungsi untuk mencetak urutan yang semakin meningkat dan ketat jika mungkin; Array untuk menyimpan urutan yang semakin meningkat dan berkurangan; Memulakan elemen terakhir kedua -dua urutan; Melangkah melalui array; Jika elemen semasa boleh dilampirkan kepada kedua -dua urutan; Jika elemen seterusnya lebih besar daripada elemen semasa kemudian masukkannya ke array yang ketat; Jika tidak masukkannya ke array yang ketat; Jika elemen semasa boleh dilampirkan kepada urutan yang semakin meningkat sahaja; Jika elemen semasa boleh dilampirkan kepada urutan yang berkurangan sahaja; Lain -lain kita tidak boleh membuat urutan sedemikian dari array yang diberikan; Cetak urutan yang diperlukan; Kod pemacu", "code": "< ? php function Find_Sequence ( $ arr , $ n ) { $ inc_arr = array ( ) ; $ dec_arr = array ( ) ; $ inc = -1 ; $ dec = 1e7 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ inc < $ arr [ $ i ] && $ arr [ $ i ] < $ dec ) { if ( $ arr [ $ i ] < $ arr [ $ i + 1 ] ) { $ inc = $ arr [ $ i ] ; array_push ( $ inc_arr , $ arr [ $ i ] ) ; } else { $ dec = $ arr [ $ i ] ; array_push ( $ dec_arr , $ arr [ $ i ] ) ; } } else if ( $ inc < $ arr [ $ i ] ) { $ inc = $ arr [ $ i ] ; array_push ( $ inc_arr , $ arr [ $ i ] ) ; } else if ( $ dec > $ arr [ $ i ] ) { $ dec = $ arr [ $ i ] ; array_push ( $ dec_arr , $ arr [ $ i ] ) ; } else { echo ' - 1' ; break ; } } print_r ( $ inc_arr ) ; print_r ( $ dec_arr ) ; } $ arr = array ( 5 , 1 , 3 , 6 , 8 , 2 , 9 , 0 , 10 ) ; $ n = count ( $ arr ) ; Find_Sequence ( $ arr , $ n ) ; ? >"}
{"text": "Cari jumlah digit nombor di tempat yang lebih baik dan ganjil | Berfungsi untuk mengembalikan sebaliknya nombor; Berfungsi untuk mencari jumlah digit yang ganjil dan juga diposisikan dalam nombor; Sekiranya C adalah nombor, maka ia bermakna digit yang diekstrak berada di tempat yang lebih baik; Kod pemacu", "code": "< ? php function reverse ( $ n ) { $ rev = 0 ; while ( $ n != 0 ) { $ rev = ( $ rev * 10 ) + ( $ n % 10 ) ; $ n = floor ( $ n / 10 ) ; } return $ rev ; } function getSum ( $ n ) { $ n = reverse ( $ n ) ; $ sumOdd = 0 ; $ sumEven = 0 ; $ c = 1 ; while ( $ n != 0 ) { if ( $ c % 2 == 0 ) $ sumEven += $ n % 10 ; else $ sumOdd += $ n % 10 ; $ n = floor ( $ n / 10 ) ; $ c ++ ; } echo \" Sum odd = \" , ▁ $ sumOdd , ▁ \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" Sum even = \" } $ n = 457892 ; getSum ( $ n ) ; ? >"}
{"text": "Kira bilangan nota mata wang yang diperlukan | Berfungsi untuk mengembalikan jumlah nota dengan nilai yang diperlukan; Jika boleh; Kod pemacu", "code": "< ? php function bankNotes ( $ A , $ B , $ S , $ N ) { $ numerator = $ S - ( $ B * $ N ) ; $ denominator = $ A - $ B ; if ( $ numerator % $ denominator == 0 ) return ( $ numerator / $ denominator ) ; return -1 ; } $ A = 1 ; $ B = 2 ; $ S = 7 ; $ N = 5 ; echo ( bankNotes ( $ A , $ B , $ S , $ N ) ) ; ? >"}
{"text": "Bahagikan nombor menjadi dua bahagian | Berfungsi untuk mencetak kedua -dua bahagian; Cari kedudukan 4; Jika watak semasa tidak '4' tetapi muncul selepas kejadian pertama '4'; Cetak kedua -dua bahagian; Kod pemacu", "code": "< ? php function twoParts ( $ str ) { $ flag = 0 ; $ a = \" \" ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == '4' ) { $ str [ $ i ] = '3' ; $ a . = '1' ; $ flag = 1 ; } else if ( $ flag ) $ a . = '0' ; } echo $ str . \" ▁ \" . $ a ; } $ str = \"9441\" ; twoParts ( $ str ) ; ? >"}
{"text": "Panjang substring terpanjang tanpa huruf yang sama berturut -turut | Berfungsi untuk mengembalikan panjang sub -rentetan yang diperlukan; Dapatkan panjang rentetan; Iterat dalam rentetan; Semak tidak berturut -turut; Jika CNT lebih besar daripada maxi; Re - Inisialisasi; Semak selepas lelaran selesai; Kod pemacu", "code": "< ? php function longestSubstring ( $ s ) { $ cnt = 1 ; $ maxi = 1 ; $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] != $ s [ $ i - 1 ] ) $ cnt ++ ; else { $ maxi = max ( $ cnt , $ maxi ) ; $ cnt = 1 ; } } $ maxi = max ( $ cnt , $ maxi ) ; return $ maxi ; } $ s = \" ccccdeededff \" ; echo longestSubstring ( $ s ) ; ? >"}
{"text": "Bilangan minimum perubahan seperti unsur -unsur yang pertama negatif dan kemudian positif | Berfungsi untuk mengembalikan kiraan operasi minimum yang diperlukan; Untuk menyimpan kiraan bilangan bulat negatif di sebelah kanan indeks semasa (inklusif); Cari kiraan bilangan bulat negatif di sebelah kanan; Jika elemen semasa adalah negatif; Untuk menyimpan kiraan elemen positif; Cari bilangan bulat positif di sebelah kiri; Jika elemen semasa positif; Mengemas kini jawapannya; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "< ? php function Minimum_Operations ( $ a , $ n ) { $ np = array ( ) ; $ np [ $ n ] = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ np [ $ i ] = $ np [ $ i + 1 ] ; if ( $ a [ $ i ] <= 0 ) $ np [ $ i ] ++ ; } $ pos = 0 ; $ ans = $ n ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ a [ $ i ] >= 0 ) $ pos ++ ; $ ans = min ( $ ans , $ pos + $ np [ $ i + 1 ] ) ; } return $ ans ; } $ a = array ( -1 , 0 , 1 , 2 ) ; $ n = count ( $ a ) ; echo Minimum_Operations ( $ a , $ n ) ; ? >"}
{"text": "Jumlah unsur dalam array yang perbezaannya dengan min array lain adalah kurang daripada k | Fungsi untuk mencari jumlah unsur yang diff dengan min tidak lebih daripada k; Cari min array kedua; Cari jumlah elemen dari Array1 yang perbezaannya dengan min tidak lebih daripada k; Hasil pulangan; Kod pemacu", "code": "< ? php function findSumofEle ( $ arr1 , $ m , $ arr2 , $ n , $ k ) { $ arraySum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arraySum += $ arr2 [ $ i ] ; $ mean = $ arraySum / $ n ; $ sumOfElements = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ difference = $ arr1 [ $ i ] - $ mean ; if ( ( $ difference < 0 ) && ( $ k > ( -1 ) * $ difference ) ) { $ sumOfElements += $ arr1 [ $ i ] ; } if ( ( $ difference >= 0 ) && ( $ k > $ difference ) ) { $ sumOfElements += $ arr1 [ $ i ] ; } } return $ sumOfElements ; } $ arr1 = array ( 1 , 2 , 3 , 4 , 7 , 9 ) ; $ arr2 = array ( 0 , 1 , 2 , 1 , 1 , 4 ) ; $ k = 2 ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; print ( findSumofEle ( $ arr1 , $ m , $ arr2 , $ n , $ k ) ) ; ? >"}
{"text": "Cari n bilangan bulat positif yang memenuhi persamaan yang diberikan | Fungsi untuk mencari n bilangan bulat positif yang memenuhi syarat -syarat yang diberikan; Untuk menyimpan n bilangan bulat positif; Tempat n - 1 satu; Jika tidak dapat meletakkan (y - (n - 1)) sebagai integer nth; Letakkan integer nth; Untuk menyimpan jumlah kuadrat n bilangan bulat; Jika ia kurang daripada x; Cetak bilangan bulat yang diperlukan; Kod pemacu", "code": "< ? php function findIntegers ( $ n , $ x , $ y ) { $ ans = array ( ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) array_push ( $ ans , 1 ) ; if ( $ y - ( $ n - 1 ) <= 0 ) { echo \" - 1\" ; return ; } array_push ( $ ans , $ y - ( $ n - 1 ) ) ; $ store = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ store += $ ans [ $ i ] * $ ans [ $ i ] ; if ( $ store < $ x ) { echo \" - 1\" ; return ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ ans [ $ i ] , \" ▁ \" ; } $ n = 3 ; $ x = 254 ; $ y = 18 ; findIntegers ( $ n , $ x , $ y ) ; ? >"}
{"text": "Cari bilangan langkah minimum untuk mencapai m dari n | Berfungsi untuk mencari bilangan langkah minimum untuk mencapai m dari n; Teruskan sehingga m lebih besar daripada n; Jika m adalah ganjil; tambah satu; Bahagikan M oleh 2; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "< ? php function Minsteps ( $ n , $ m ) { $ ans = 0 ; while ( $ m > $ n ) { if ( $ m % 2 != 0 ) { $ m ++ ; $ ans ++ ; } $ m /= 2 ; $ ans ++ ; } return $ ans + $ n - $ m ; } $ n = 4 ; $ m = 6 ; echo ( Minsteps ( $ n , $ m ) ) ; ? >"}
{"text": "Cari bilangan lompatan untuk mencapai x dalam baris nombor dari sifar | Fungsi utiliti untuk mengira jumlah nombor dari 1 hingga x; Berfungsi untuk mencari bilangan lompatan untuk mencapai x dalam baris nombor dari sifar; Pertama, jawapan positif nombor akan sama sama ada positif atau negatif; Untuk menyimpan jawapan yang diperlukan; Teruskan sehingga jumlahnya lebih rendah atau tidak dalam pariti yang sama; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "< ? php function getsum ( $ x ) { return ( $ x * ( $ x + 1 ) ) / 2 ; } function countJumps ( $ n ) { $ n = abs ( $ n ) ; $ ans = 0 ; while ( getsum ( $ ans ) < $ n or ( getsum ( $ ans ) - $ n ) & 1 ) $ ans ++ ; return $ ans ; } $ n = 9 ; echo countJumps ( $ n ) ; ? >"}
{"text": "Bilangan maksimum gula -gula yang boleh dibeli | Berfungsi untuk mengembalikan gula -gula maksimum yang boleh dibeli; Beli semua gula -gula jenis terakhir; Bermula dari kedua terakhir; Jumlah gula -gula jenis semasa yang boleh dibeli; Tambah gula -gula jenis semasa yang boleh dibeli; Mengemas kini jumlah yang dibeli sebelumnya; Kod pemacu", "code": "< ? php function maxCandies ( $ arr , $ n ) { $ prevBought = $ arr [ $ n - 1 ] ; $ candies = $ prevBought ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ x = min ( $ prevBought - 1 , $ arr [ $ i ] ) ; if ( $ x >= 0 ) { $ candies += $ x ; $ prevBought = $ x ; } } return $ candies ; } $ arr = array ( 1 , 2 , 1 , 3 , 6 ) ; $ n = sizeof ( $ arr ) ; echo ( maxCandies ( $ arr , $ n ) ) ; ? >"}
{"text": "Perubahan minimum diperlukan supaya rentetan memenuhi syarat yang diberikan | Berfungsi untuk mengembalikan perubahan minimum yang diperlukan; Untuk menyimpan kiraan perubahan minimum, bilangan yang dan bilangan sifar; Watak pertama harus '1'; Jika keadaan gagal perubahan perlu dibuat; Mengembalikan kiraan yang diperlukan; Kod pemacu", "code": "< ? php function minChanges ( $ str , $ n ) { $ count = $ zeros = $ ones = 0 ; if ( $ str [ 0 ] != '1' ) { $ count ++ ; $ ones ++ ; } for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) $ zeros ++ ; else $ ones ++ ; if ( $ zeros > $ ones ) { $ zeros -- ; $ ones ++ ; $ count ++ ; } } return $ count ; } $ str = \"0000\" ; $ n = strlen ( $ str ) ; echo minChanges ( $ str , $ n ) ; ? >"}
{"text": "Kira kemungkinan bergerak ke arah yang diberikan dalam grid | Berfungsi untuk mengembalikan kiraan langkah -langkah yang mungkin dalam satu arah; Ia boleh meliputi langkah -langkah tak terhingga; Kami menghampiri X = n; Kami menghampiri X = 1; Berfungsi untuk mengembalikan kiraan langkah; Ambil minimum kedua -dua bergerak secara bebas; Mengemas kini kiraan dan kedudukan semasa; Kod pemacu", "code": "< ? php function steps ( $ cur , $ x , $ n ) { if ( $ x == 0 ) return PHP_INT_MAX ; if ( $ x > 0 ) return floor ( abs ( ( $ n - $ cur ) / $ x ) ) ; else return floor ( abs ( ( $ cur - 1 ) / $ x ) ) ; } function countSteps ( $ curx , $ cury , $ n , $ m , $ moves ) { $ count = 0 ; $ k = sizeof ( $ moves ) ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ x = $ moves [ $ i ] [ 0 ] ; $ y = $ moves [ $ i ] [ 1 ] ; $ stepct = min ( steps ( $ curx , $ x , $ n ) , steps ( $ cury , $ y , $ m ) ) ; $ count += $ stepct ; $ curx += $ stepct * $ x ; $ cury += $ stepct * $ y ; } return $ count ; } $ n = 4 ; $ m = 5 ; $ x = 1 ; $ y = 1 ; $ moves = array ( array ( 1 , 1 ) , array ( 1 , 1 ) , array ( 0 , -2 ) ) ; $ k = sizeof ( $ moves ) ; echo countSteps ( $ x , $ y , $ n , $ m , $ moves ) ; ? >"}
{"text": "Unsur -unsur minimum yang akan dikeluarkan sedemikian rupa sehingga jumlah unsur -unsur bersebelahan sentiasa ganjil | Mengembalikan bilangan minimum penghapusan; Menyimpan elemen sebelumnya; Menyimpan nilai baru; Semak sama ada nilai sebelumnya dan semasa adalah pariti yang sama; Nilai sebelumnya kini nilai semasa; Mengembalikan pemboleh ubah kaunter; Kod pemacu", "code": "< ? php function min_elimination ( $ n , $ arr ) { $ count = 0 ; $ prev_val = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_val = $ arr [ $ i ] ; if ( $ curr_val % 2 == $ prev_val % 2 ) $ count ++ ; $ prev_val = $ curr_val ; } return $ count ; } $ arr = array ( 1 , 2 , 3 , 7 , 9 ) ; $ n = sizeof ( $ arr ) ; echo min_elimination ( $ n , $ arr ) ; ? >"}
{"text": "Kira semua nombor digit yang mungkin memenuhi syarat yang diberikan | Berfungsi untuk mengembalikan kiraan nombor yang diperlukan; Jika n adalah ganjil maka kembali 0; Kod pemacu", "code": "< ? php function getCount ( $ N ) { if ( $ N % 2 == 1 ) return 0 ; $ result = \"9\" ; for ( $ i = 1 ; $ i <= $ N / 2 - 1 ; $ i ++ ) $ result . = \"0\" ; return $ result ; } $ N = 4 ; echo getCount ( $ N ) ; ? >"}
{"text": "Bilangan maksimum pasukan yang boleh dibentuk dengan orang tertentu | Fungsi yang mengembalikan benar jika mungkin untuk membentuk satu pasukan dengan N dan M yang diberikan; 1 orang Type1 dan 2 orang Type2 boleh dipilih; 1 orang Type2 dan 2 orang Type1 boleh dipilih; Tidak boleh dari satu pasukan; Berfungsi untuk mengembalikan bilangan maksimum pasukan yang boleh dibentuk; Untuk menyimpan kiraan pasukan yang diperlukan; Pilih 2 orang Type1; Dan 1 orang Type2; Pilih 2 orang Type2; Dan 1 orang jenis1; Satu lagi pasukan telah dibentuk; Kod pemacu", "code": "< ? php function canFormTeam ( $ n , $ m ) { if ( $ n >= 1 && $ m >= 2 ) return true ; if ( $ m >= 1 && $ n >= 2 ) return true ; return false ; } function maxTeams ( $ n , $ m ) { $ count = 0 ; while ( canFormTeam ( $ n , $ m ) ) { if ( $ n > $ m ) { $ n -= 2 ; $ m -= 1 ; } else { $ m -= 2 ; $ n -= 1 ; } $ count ++ ; } return $ count ; } $ n = 4 ; $ m = 5 ; echo maxTeams ( $ n , $ m ) ; ? >"}
{"text": "Cari sisi dataran terkecil yang boleh mengandungi 4 dataran besar | Berfungsi untuk mencari maksimum dua nilai; Berfungsi untuk mencari bahagian terkecil dari beg pakaian yang sesuai; Susun array untuk mencari sisi beg pakaian terkecil dan terbesar; Sisi beg pakaian akan menjadi terkecil jika mereka disusun dalam 2 x 2 cara supaya mencari semua kemungkinan susunan itu; Oleh kerana beg pakaian hendaklah persegi jadi cari maksimum keempat -empat sisi; Sekarang cari sisi yang paling besar dan itu akan menjadi persegi terkecil; mengembalikan hasilnya; Program pemacu; Dapatkan bahagian 4 dataran kecil; Cari bahagian terkecil; Dapatkan bahagian 4 dataran kecil; Cari bahagian terkecil", "code": "< ? php function max1 ( $ a , $ b ) { if ( $ a > $ b ) return $ a ; else return $ b ; } function smallestSide ( $ a ) { sort ( $ a , 0 ) ; $ side1 = $ a [ 0 ] + $ a [ 3 ] ; $ side2 = $ a [ 1 ] + $ a [ 2 ] ; $ side3 = $ a [ 0 ] + $ a [ 1 ] ; $ side4 = $ a [ 2 ] + $ a [ 3 ] ; $ side11 = max1 ( $ side1 , $ side2 ) ; $ side12 = max1 ( $ side3 , $ side4 ) ; $ sideOfSquare = max1 ( $ side11 , $ side12 ) ; return $ sideOfSquare ; } $ side = array ( ) ; echo \" Test ▁ Case ▁ 1 STRNEWLINE \" ; $ side [ 0 ] = 2 ; $ side [ 1 ] = 2 ; $ side [ 2 ] = 2 ; $ side [ 3 ] = 2 ; echo smallestSide ( $ side ) . \" STRNEWLINE \" ; echo \" Test Case 2 \" ; $ side [ 0 ] = 100000000000000 ; $ side [ 1 ] = 123450000000000 ; $ side [ 2 ] = 987650000000000 ; $ side [ 3 ] = 987654321000000 ; echo smallestSide ( $ side ) . \" STRNEWLINE \" ; ? >"}
{"text": "Rectangle dengan perbezaan minimum yang mungkin antara panjang dan lebar | Fungsi untuk mencetak panjang (l) dan lebar (b) segi empat tepat yang mempunyai kawasan = n dan | L - B | sekurang -kurangnya mungkin; Saya adalah faktor; l> = sqrt (kawasan)> = i; Jadi di sini l adalah + ve selalu; Di sini L dan B adalah panjang dan keluasan segi empat tepat; Kod pemacu", "code": "< ? php function find_rectangle ( $ area ) { $ M = floor ( sqrt ( $ area ) ) ; for ( $ i = $ M ; $ i >= 1 ; $ i -- ) { if ( $ area % $ i == 0 ) { $ l = floor ( $ area / $ i ) ; $ b = $ i ; break ; } } echo \" l = \" , ▁ $ l , ▁ \" , b = \" , ▁ $ b , ▁ \" \" } $ area = 99 ; find_rectangle ( $ area ) ; ? >"}
{"text": "Sub terbesar | Berfungsi untuk mengembalikan saiz sub -set yang diperlukan; Susun array; Tetapkan untuk menyimpan kandungan sub -set yang diperlukan; Masukkan unsur -unsur yang memenuhi syarat; Mengembalikan saiz set; Kod pemacu", "code": "< ? php function sizeSubSet ( $ a , $ k , $ n ) { sort ( $ a ) ; $ s = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % $ k != 0 or ! in_array ( floor ( $ a [ $ i ] / $ k ) , $ s ) ) array_push ( $ s , $ a [ $ i ] ) ; } return sizeof ( $ s ) ; } $ a = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; $ n = sizeof ( $ a ) ; $ k = 2 ; echo sizeSubSet ( $ a , $ k , $ n ) ; ? >"}
{"text": "Bilangan minimum set dengan nombor kurang daripada y | Berfungsi untuk mencari bilangan minimum tembakan; Pembolehubah untuk mengira bilangan set; Iterat dalam rentetan; Tambah nombor ke rentetan; Tandakan bahawa kami mendapat nombor; lain setiap kali ia melebihi; Semak jika sebelumnya adalah bila -bila masa kurang daripada y; Nombor semasa; Periksa nombor semasa; Periksa nombor ditambah terakhir; Kod pemacu", "code": "< ? php function minimumSets ( $ s , $ y ) { $ cnt = 0 ; $ num = 0 ; $ l = strlen ( $ s ) ; $ f = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { $ num = $ num * 10 + ( $ s [ $ i ] - '0' ) ; if ( $ num <= $ y ) $ f = 1 ; { if ( $ f ) $ cnt += 1 ; $ num = $ s [ $ i ] - '0' ; $ f = 0 ; if ( $ num <= $ y ) $ f = 1 ; else $ num = 0 ; } } if ( $ f ) $ cnt += 1 ; return $ cnt ; } $ s = \"1234\" ; $ y = 30 ; echo ( minimumSets ( $ s , $ y ) ) ; ? >"}
{"text": "Cari Arahan Pesanan Tidak Menurun dari Arahan yang Diberikan | Fungsi utiliti untuk mencetak kandungan array; Berfungsi untuk membina array b []; Had bawah dan atas; Untuk menyimpan array yang diperlukan; Memohon pendekatan tamak; Cetak array binaan B []; Kod pemacu", "code": "< ? php function printArr ( $ b , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ b [ $ i ] . \" ▁ \" ; } function ModifiedArray ( $ a , $ n ) { $ l = 0 ; $ r = PHP_INT_MAX ; $ b = array ( 0 ) ; for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) { $ b [ $ i ] = max ( $ l , $ a [ $ i ] - $ r ) ; $ b [ $ n - $ i - 1 ] = $ a [ $ i ] - $ b [ $ i ] ; $ l = $ b [ $ i ] ; $ r = $ b [ $ n - $ i - 1 ] ; } printArr ( $ b , $ n ) ; } $ a = array ( 5 , 6 ) ; $ n = sizeof ( $ a ) ; ModifiedArray ( $ a , 2 * $ n ) ; ? >"}
{"text": "Jumlah maksimum semua elemen array selepas melakukan operasi yang diberikan | Berfungsi untuk mengira jumlah subarray maksimum atau algoritma Kadane; Berfungsi untuk mencari jumlah maksimum selepas operasi yang diberikan; Untuk menyimpan jumlah semua elemen; Jumlah maksimum subarray; Kirakan jumlah semua elemen; Kod pemacu; saiz array", "code": "< ? php function maxSubArraySum ( $ a , $ size ) { $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; } return $ max_so_far ; } function maxSum ( $ a , $ n ) { $ S = 0 ; $ S1 = maxSubArraySum ( $ a , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ S += $ a [ $ i ] ; return ( 2 * $ S1 - $ S ) ; } $ a = array ( -35 , 32 , -24 , 0 , 27 , -10 , 0 , -19 ) ; $ n = sizeof ( $ a ) ; echo ( maxSum ( $ a , $ n ) ) ;"}
{"text": "Kurangkan perbezaan antara elemen minimum dan maksimum | Berfungsi untuk meminimumkan perbezaan antara elemen minimum dan maksimum; Cari elemen max dan min array; Semak sama ada perbezaan antara elemen max dan min kurang daripada atau sama dengan k atau tidak; Hitung purata maksimum dan min; Jika elemen array lebih besar daripada purata maka penurunannya dengan k; Jika elemen array lebih kecil daripada purata maka tingkatkannya dengan k; Cari max dan min array yang diubah suai; mengembalikan perbezaan baru; Kod pemacu", "code": "< ? php function minimizeDiff ( & $ arr , $ n , $ k ) { $ max = max ( $ arr ) ; $ min = min ( $ arr ) ; if ( ( $ max - $ min ) <= $ k ) { return ( $ max - $ min ) ; } $ avg = ( $ max + $ min ) / 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ avg ) $ arr [ $ i ] -= $ k ; else $ arr [ $ i ] += $ k ; } $ max = max ( $ arr ) ; $ min = min ( $ arr ) ; return ( $ max - $ min ) ; } $ arr = array ( 3 , 16 , 12 , 9 , 20 ) ; $ n = 5 ; $ k = 3 ; echo \" Max ▁ height ▁ difference ▁ = ▁ \" . minimizeDiff ( $ arr , $ n , $ k ) . \" STRNEWLINE \" ; ? >"}
{"text": "Liter maksimum air yang boleh dibeli dengan n rupee | Pelaksanaan PHP pendekatan di atas; Jika membeli botol kaca menguntungkan; Botol kaca yang boleh dibeli; Menukar belanjawan mengikut botol yang dibeli; Botol plastik yang boleh dibeli; Jika hanya botol plastik perlu dibeli; Kod pemacu", "code": "< ? php function maxLitres ( $ budget , $ plastic , $ glass , $ refund ) { if ( $ glass - $ refund < $ plastic ) { $ ans = max ( ( int ) ( $ budget - $ refund ) / ( $ glass - $ refund ) , 0 ) ; $ budget -= $ ans * ( $ glass - $ refund ) ; $ ans += ( int ) ( $ budget / $ plastic ) ; echo $ ans . \" STRNEWLINE \" ; } else echo ( int ) ( $ budget / $ plastic ) . \" STRNEWLINE \" ; } $ budget = 10 ; $ plastic = 11 ; $ glass = 9 ; $ refund = 8 ; maxLitres ( $ budget , $ plastic , $ glass , $ refund ) ; ? >"}
{"text": "Cari nombor dari senarai yang diberikan untuk nilai fungsi yang paling dekat dengan | | Fungsi untuk mencari nombor dari senarai yang diberikan untuk nilai fungsi yang paling dekat dengan A; Menyimpan indeks akhir; Mengisytiharkan pembolehubah untuk menyimpan perbezaan mutlak minimum; Mencari f (n); Mengemas kini indeks jawapan jika perbezaan mutlak baru kurang daripada TMP; Kod pemacu", "code": "< ? php function leastValue ( $ P , $ A , $ N , $ a ) { $ ans = -1 ; $ tmp = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ t = $ P - $ a [ $ i ] * 0.006 ; if ( abs ( $ t - $ A ) < $ tmp ) { $ tmp = abs ( $ t - $ A ) ; $ ans = $ i ; } } return $ a [ $ ans ] ; } $ N = 2 ; $ P = 12 ; $ A = 5 ; $ a = array ( 1000 , 2000 ) ; print ( leastValue ( $ P , $ A , $ N , $ a ) ) ; ? >"}
{"text": "Cari permutasi N yang boleh dibahagikan dengan 3 tetapi tidak dibahagikan dengan 6 | Berfungsi untuk mencari permutasi; panjang integer; Jika integer adalah walaupun; kembali integer ganjil; berputar integer; Pulangan - 1 Sekiranya tiada permutasi yang diperlukan; Kod pemacu", "code": "< ? php function findPermutation ( $ n ) { $ len = ceil ( log10 ( $ n ) ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ n % 2 != 0 ) { return ( int ) $ n ; } else { $ n = ( $ n / 10 ) + ( $ n % 10 ) * pow ( 10 , $ len - $ i - 1 ) ; continue ; } } return -1 ; } $ n = 132 ; echo findPermutation ( $ n ) ; ? >"}
{"text": "Semak jika mungkin untuk melayani barisan pelanggan dengan nota yang berbeza | Fungsi yang pulangan benar adalah menjual tiket adalah mungkin; Tiada apa -apa untuk kembali kepada pelanggan; Semak jika 25 boleh dikembalikan kepada pelanggan. ; Cuba kembali 50 dan satu 25; Cuba kembali tiga 25; Jika gelung tidak pecah, semua tiket dijual; Kod pemacu", "code": "< ? php function isSellingPossible ( $ n , $ a ) { $ c25 = 0 ; $ c50 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 25 ) $ c25 ++ ; else if ( $ a [ $ i ] == 50 ) { $ c50 ++ ; if ( $ c25 == 0 ) break ; $ c25 -- ; } else { if ( $ c50 > 0 && $ c25 > 0 ) { $ c50 -- ; $ c25 -- ; } else if ( $ c25 >= 3 ) $ c25 -= 3 ; else break ; } } if ( $ i == $ n ) return true ; else return false ; } $ a = array ( 25 , 25 , 50 , 100 ) ; $ n = sizeof ( $ a ) ; if ( isSellingPossible ( $ n , $ a ) ) { echo \" YES \" ; } else { echo \" NO \" ; } ? >"}
{"text": "Semak jika sel boleh dikunjungi lebih daripada sekali dalam rentetan | Fungsi untuk memeriksa sama ada sel boleh dikunjungi lebih dari sekali; Array untuk menandakan sel; Melintasi rentetan; Meningkatkan kiraan kiraan sel kiri dan kanan dalam array yang boleh dikunjungi; Jika mana -mana sel boleh dikunjungi lebih daripada sekali, kembali benar; Kod pemacu", "code": "< ? php function checkIfOverlap ( $ str ) { $ len = strlen ( $ str ) ; $ visited = array_fill ( 0 , $ len + 1 , NULL ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == ' . ' ) continue ; for ( $ j = max ( 0 , $ i - $ str [ $ i ] ) ; $ j <= min ( $ len , $ i + $ str [ $ i ] ) ; $ j ++ ) $ visited [ $ j ] ++ ; } for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ visited [ $ i ] > 1 ) { return true ; } } return false ; } $ str = \" . 2 . . 2 . \" ; if ( checkIfOverlap ( $ str ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Semak jika nombor mempunyai digit dalam perintah yang diberikan | Semak sama ada digit mengikuti urutan yang betul; untuk menyimpan digit sebelumnya; penunjuk untuk memberitahu jenis urutan yang kita hadapi; Semak jika kita mempunyai digit yang sama dengan digit sebelumnya; memeriksa titik puncak nombor; Semak jika kita mempunyai digit yang sama dengan digit sebelumnya; Semak sama ada digit lebih besar daripada yang sebelumnya jika benar, kemudian pecahkan dari gelung kerana kami berada dalam bahagian perintah menurun; Kod pemacu", "code": "< ? php function isCorrectOrder ( $ n ) { $ flag = true ; $ prev = -1 ; $ type = -1 ; while ( $ n != 0 ) { if ( $ type == -1 ) { if ( $ prev == -1 ) { $ prev = $ n % 10 ; $ n = ( int ) $ n / 10 ; continue ; } if ( $ prev == $ n % 10 ) { $ flag = false ; break ; } if ( $ prev > $ n % 10 ) { $ type = 1 ; $ prev = $ n % 10 ; $ n = ( int ) $ n / 10 ; continue ; } $ prev = $ n % 10 ; $ n = ( int ) $ n / 10 ; } else { if ( $ prev == $ n % 10 ) { $ flag = false ; break ; } if ( $ prev < $ n % 10 ) { $ flag = false ; break ; } $ prev = $ n % 10 ; $ n = ( int ) $ n / 10 ; } } return $ flag ; } $ n = 123454321 ; if ( isCorrectOrder ( $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Permainan duit syiling dua sudut (pendekatan tamak) | Mengembalikan nilai optimum yang mungkin bahawa pemain boleh mengumpul dari pelbagai syiling saiz n. Nota daripada n mestilah; Cari jumlah duit syiling yang ganjil; Cari jumlah duit syiling yang diposisikan; Cetak duit syiling walaupun atau ganjil bergantung kepada jumlah yang lebih besar. ; Kod pemacu", "code": "< ? php function printCoins ( & $ arr , $ n ) { $ oddSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i += 2 ) $ oddSum += $ arr [ $ i ] ; $ evenSum = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i += 2 ) $ evenSum += $ arr [ $ i ] ; $ start = ( ( $ oddSum > $ evenSum ) ? 0 : 1 ) ; for ( $ i = $ start ; $ i < $ n ; $ i += 2 ) echo $ arr [ $ i ] . \" ▁ \" ; } $ arr1 = array ( 8 , 15 , 3 , 7 ) ; $ n = sizeof ( $ arr1 ) ; printCoins ( $ arr1 , $ n ) ; echo \" STRNEWLINE \" ; $ arr2 = array ( 2 , 2 , 2 , 2 ) ; $ n = sizeof ( $ arr2 ) ; printCoins ( $ arr2 , $ n ) ; echo \" STRNEWLINE \" ; $ arr3 = array ( 20 , 30 , 2 , 2 , 2 , 10 ) ; $ n = sizeof ( $ arr3 ) ; printCoins ( $ arr3 , $ n ) ; ? >"}
{"text": "Kedudukan sel akhir dalam matriks | berfungsi untuk mencari kedudukan sel akhir dalam matriks yang diberikan; untuk mengira, ke bawah, kiri dan gerakan gerakan; untuk menyimpan kedudukan koordinat akhir; melintasi array arahan; mengira nilai akhir; Kod pemacu", "code": "< ? php function finalPos ( $ command , $ n , $ x , $ y ) { $ cup ; $ cdown ; $ cleft ; $ cright ; $ final_x ; $ final_y ; $ cup = $ cdown = $ cleft = $ cright = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ command [ $ i ] == ' U ' ) $ cup ++ ; else if ( $ command [ $ i ] == ' D ' ) $ cdown ++ ; else if ( $ command [ $ i ] == ' L ' ) $ cleft ++ ; else if ( $ command [ $ i ] == ' R ' ) $ cright ++ ; } $ final_x = $ x + ( $ cright - $ cleft ) ; $ final_y = $ y + ( $ cdown - $ cup ) ; echo \" Final ▁ Position : ▁ \" . \" ( \" . $ final_x . \" , ▁ \" . $ final_y . \" ) \" ; } $ command = \" DDLRULL \" ; $ n = strlen ( $ command ) ; $ x = 3 ; $ y = 4 ; finalPos ( $ command , $ n , $ x , $ y ) ;"}
{"text": "Subarray Bersebelahan Jumlah Terkecil | Set | Berfungsi untuk mencari subarray bersebelahan jumlah terkecil; Pertama membalikkan tanda unsur -unsur; Memohon algoritma Kadane biasa tetapi pada unsur -unsur array yang mempunyai tanda terbalik; Membalikkan jawapan untuk mendapatkan val minimum; Kod pemacu", "code": "< ? php function smallestSumSubarr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = - $ arr [ $ i ] ; $ sum_here = $ arr [ 0 ] ; $ max_sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum_here = max ( $ sum_here + $ arr [ $ i ] , $ arr [ $ i ] ) ; $ max_sum = max ( $ max_sum , $ sum_here ) ; } return ( -1 ) * $ max_sum ; } $ arr = array ( 3 , -4 , 2 , -3 , -1 , 7 , -5 ) ; $ n = sizeof ( $ arr ) ; echo \" Smallest ▁ sum : ▁ \" , smallestSumSubarr ( $ arr , $ n ) ; ? >"}
{"text": "Nombor maksimum dengan menggabungkan setiap elemen dalam putaran array | Berfungsi untuk mencetak nombor terbesar; Simpan indeks unsur -unsur paling banyak di kiri; ITERATE untuk semua nombor; Semak digit terakhir; Semak angka paling kiri terbesar; Cetak putaran array; Cetak putaran array; Kod pemacu", "code": "< ? php function printLargest ( $ a , $ n ) { $ max = -1 ; $ ind = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ num = $ a [ $ i ] ; while ( $ num ) { $ r = $ num % 10 ; $ num = ( int ) $ num / 10 ; if ( $ num == 0 ) { if ( $ max < $ r ) { $ max = $ r ; $ ind = $ i ; } } } } for ( $ i = $ ind ; $ i < $ n ; $ i ++ ) echo $ a [ $ i ] ; for ( $ i = 0 ; $ i < $ ind ; $ i ++ ) echo $ a [ $ i ] ; } $ a = array ( 54 , 546 , 548 , 60 ) ; $ n = sizeof ( $ a ) ; printLargest ( $ a , $ n ) ; ? >"}
{"text": "Operasi minimum untuk membuat GCD pelbagai pelbagai k | Program PHP untuk membuat GCD Array berganda k. ; Jika nilai array tidak 1 dan ia lebih besar daripada k maka kita boleh meningkatkan atau mengurangkan selebihnya yang diperoleh dengan membahagikan k dari nilai ith array supaya kita mendapat nombor yang sama ada lebih dekat dengan k atau berbilangnya; Lain -lain kita hanya mempunyai satu pilihan yang akan meningkatkan nilai untuk membuat sama dengan k; Kod pemacu", "code": "< ? php function MinOperation ( $ a , $ n , $ k ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ a [ $ i ] != 1 && $ a [ $ i ] > $ k ) { $ result = $ result + min ( $ a [ $ i ] % $ k , $ k - $ a [ $ i ] % $ k ) ; } else { $ result = $ result + $ k - $ a [ $ i ] ; } } return $ result ; } $ arr = array ( 4 , 5 , 6 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; $ k = 5 ; echo MinOperation ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Subset produk maksimum array | Program PHP untuk mencari produk maksimum subset. ; Cari kiraan nombor negatif, kiraan sifar, nombor negatif dengan nilai mutlak dan produk nombor bukan sifar; Sekiranya nombor adalah 0, kami tidak membiaknya dengan produk. ; Kira negatif dan menjejaki nombor negatif dengan nilai mutlak yang paling sedikit. ; Sekiranya terdapat semua sifar; Sekiranya terdapat nombor negatif yang ganjil; Kes yang luar biasa: hanya ada negatif dan semua yang lain adalah sifar; Jika tidak, hasilnya adalah produk semua non - nol yang dibahagikan dengan nombor negatif dengan nilai mutlak yang paling sedikit. ; Kod pemacu", "code": "< ? php function maxProductSubset ( $ a , $ n ) { if ( $ n == 1 ) return $ a [ 0 ] ; $ max_neg = PHP_INT_MIN ; $ count_neg = 0 ; $ count_zero = 0 ; $ prod = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 0 ) { $ count_zero ++ ; continue ; } if ( $ a [ $ i ] < 0 ) { $ count_neg ++ ; $ max_neg = max ( $ max_neg , $ a [ $ i ] ) ; } $ prod = $ prod * $ a [ $ i ] ; } if ( $ count_zero == $ n ) return 0 ; if ( $ count_neg & 1 ) { if ( $ count_neg == 1 && $ count_zero > 0 && $ count_zero + $ count_neg == $ n ) return 0 ; $ prod = $ prod / $ max_neg ; } return $ prod ; } $ a = array ( -1 , -1 , -2 , 4 , 3 ) ; $ n = sizeof ( $ a ) ; echo maxProductSubset ( $ a , $ n ) ; ? >"}
{"text": "Nombor terkecil dengan jumlah digit sebagai n dan dibahagikan dengan 10 ^ n | Program PHP untuk mencari nombor terkecil untuk mencari nombor terkecil dengan n sebagai jumlah digit dan dibahagikan dengan 10 ^ n. ; Jika n = 0 rentetan akan 0; Jika n tidak dapat dibahagikan dengan sempurna oleh 9 output selebihnya; Cetak 9 N / 9 kali; Tambah n Zero ke nombor untuk menjadikannya dibahagikan dengan 10^n; Kod pemacu", "code": "< ? php function digitsNum ( $ N ) { if ( $ N == 0 ) echo \"0 STRNEWLINE \" ; if ( $ N % 9 != 0 ) echo ( $ N % 9 ) ; for ( $ i = 1 ; $ i <= ( $ N / 9 ) ; ++ $ i ) echo \"9\" ; for ( $ i = 1 ; $ i <= $ N ; ++ $ i ) echo \"0\" ; echo \" STRNEWLINE \" ; } $ N = 5 ; echo \" The ▁ number ▁ is ▁ : ▁ \" ; digitsNum ( $ N ) ; ? >"}
{"text": "Bahagikan 1 hingga N ke dalam dua kumpulan dengan perbezaan jumlah minimum | Untuk mencetak vektor sepanjang saiz; Saiz vektor cetak; Elemen vektor cetak; Untuk membahagikan n dalam dua kumpulan supaya perbezaan mutlak jumlah mereka adalah minimum; Cari jumlah semua elemen sehingga n; Jumlah elemen kumpulan1; Jika jumlah lebih besar kemudian atau sama dengan 0 termasuk i dalam kumpulan 1 sebaliknya termasuk dalam kumpulan2; Mengurangkan jumlah kumpulan1; Cetak kedua -dua kumpulan; Kod pemacu", "code": "< ? php function printVector ( $ v ) { echo count ( $ v ) . \" STRNEWLINE \" ; for ( $ i = 0 ; $ i < count ( $ v ) ; $ i ++ ) echo $ v [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } function findTwoGroup ( $ n ) { $ sum = $ n * ( $ n + 1 ) / 2 ; $ group1Sum = ( int ) ( $ sum / 2 ) ; $ group1 ; $ group2 ; $ x = 0 ; $ y = 0 ; for ( $ i = $ n ; $ i > 0 ; $ i -- ) { if ( $ group1Sum - $ i >= 0 ) { $ group1 [ $ x ++ ] = $ i ; $ group1Sum -= $ i ; } else { $ group2 [ $ y ++ ] = $ i ; } } printVector ( $ group1 ) ; printVector ( $ group2 ) ; } $ n = 5 ; findTwoGroup ( $ n ) ; ? >"}
{"text": "Partition menjadi dua subarray panjang k dan (n | berfungsi untuk mengira max_difference; jumlah array; sort array dalam urutan menurun; mengira max_difference; kod pemacu", "code": "< ? php function maxDifference ( $ arr , $ N , $ k ) { $ M ; $ S = 0 ; $ S1 = 0 ; $ max_difference = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ S += $ arr [ $ i ] ; rsort ( $ arr ) ; $ M = max ( $ k , $ N - $ k ) ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) $ S1 += $ arr [ $ i ] ; $ max_difference = $ S1 - ( $ S - $ S1 ) ; return $ max_difference ; } $ arr = array ( 8 , 4 , 5 , 2 , 10 ) ; $ N = count ( $ arr ) ; $ k = 2 ; echo maxDifference ( $ arr , $ N , $ k ) ; ? >"}
{"text": "Jumlah minimum produk dua tatasusunan | Berfungsi untuk mencari produk minimum; Cari produk elemen semasa dan keputusan kemas kini. ; Jika kedua -dua produk dan B [i] adalah negatif, kita mesti meningkatkan nilai [i] untuk meminimumkan hasil. ; Jika kedua -dua produk dan [i] adalah negatif, kita mesti mengurangkan nilai [i] untuk meminimumkan hasil. ; Sama seperti di atas dua kes untuk produk positif. ; Semak jika perbezaan semasa menjadi lebih tinggi daripada perbezaan maksimum setakat ini. ; Kod pemacu", "code": "< ? php function minproduct ( $ a , $ b , $ n , $ k ) { $ diff = 0 ; $ res = 0 ; $ temp ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ pro = $ a [ $ i ] * $ b [ $ i ] ; $ res = $ res + $ pro ; if ( $ pro < 0 and $ b [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] + 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro < 0 and $ a [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] - 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro > 0 and $ a [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] + 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro > 0 and $ a [ $ i ] > 0 ) $ temp = ( $ a [ $ i ] - 2 * $ k ) * $ b [ $ i ] ; $ d = abs ( $ pro - $ temp ) ; if ( $ d > $ diff ) $ diff = $ d ; } return $ res - $ diff ; } $ a = array ( 2 , 3 , 4 , 5 , 4 , 0 ) ; $ b = array ( 3 , 4 , 2 , 3 , 2 ) ; $ n = 5 ; $ k = 3 ; echo minproduct ( $ a , $ b , $ n , $ k ) ; ? >"}
{"text": "Split n ke nombor komposit maksimum | berfungsi untuk mengira bilangan maksimum nombor komposit yang menambah sehingga n; 4 adalah nombor komposit terkecil; menyimpan selebihnya apabila n dibahagikan dengan 4; Jika selebihnya adalah 0, maka ia dapat dibahagikan dengan sempurna oleh 4 .; Jika selebihnya adalah 1; Jika nombor kurang daripada 9, iaitu 5, maka ia tidak boleh dinyatakan sebagai 4 adalah satu -satunya nombor komposit yang kurang daripada 5; Jika nombor lebih besar maka 8, dan mempunyai selebihnya 1, maka nyatakan n sebagai n - 9 a dan ia sangat dibahagikan dengan 4 dan untuk 9, kiraan 1; Apabila selebihnya adalah 2, tolak 6 dari n, supaya N adalah sempurna dibahagikan dengan 4 dan kiraan 1 untuk 6 yang dikurangkan. ; Jika nombor adalah 7, 11 yang tidak dapat dinyatakan sebagai jumlah nombor komposit; Apabila selebihnya adalah 3, kemudian tolak 15 daripadanya dan n menjadi sempurna dibahagikan dengan 4 dan kami menambah 2 untuk 9 dan 6, yang dikurangkan untuk menjadikan N sempurna dibahagikan dengan 4 .; program pemacu untuk menguji fungsi di atas", "code": "< ? php function c_ount ( $ n ) { if ( $ n < 4 ) return -1 ; $ rem = $ n % 4 ; if ( $ rem == 0 ) return $ n / 4 ; if ( $ rem == 1 ) { if ( $ n < 9 ) return -1 ; return ( $ n - 9 ) / 4 + 1 ; } if ( $ rem == 2 ) return ( $ n - 6 ) / 4 + 1 ; if ( $ rem == 3 ) { if ( $ n < 15 ) return -1 ; return ( $ n - 15 ) / 4 + 2 ; } } $ n = 90 ; echo c_ount ( $ n ) , \" STRNEWLINE \" ; $ n = 143 ; echo c_ount ( $ n ) ; ? >"}
{"text": "Putaran minimum untuk membuka kunci kunci bulat | fungsi untuk putaran min; melangkah sehingga input dan buka kunci kod menjadi 0; input dan buka kunci digit terakhir sebagai peringatan; Cari putaran min; kemas kini kod dan input; Kod pemacu", "code": "< ? php function minRotation ( $ input , $ unlock_code ) { $ rotation = 0 ; $ input_digit ; $ code_digit ; while ( $ input $ unlock_code ) { $ input_digit = $ input % 10 ; $ code_digit = $ unlock_code % 10 ; $ rotation += min ( abs ( $ input_digit - $ code_digit ) , 10 - abs ( $ input_digit - $ code_digit ) ) ; $ input /= 10 ; $ unlock_code /= 10 ; } return $ rotation ; } $ input = 28756 ; $ unlock_code = 98234 ; echo \" Minimum ▁ Rotation ▁ = ▁ \" , minRotation ( $ input , $ unlock_code ) ; ? >"}
{"text": "Kos minimum untuk memperoleh semua duit syiling dengan d syiling tambahan yang dibenarkan dengan setiap duit syiling | Menukar duit syiling [] ke array jumlah awalan; menyusun nilai syiling; Mengekalkan array jumlah awalan; Fungsi untuk mengira kos min apabila kita boleh mendapatkan d syiling tambahan selepas membayar kos satu. ; Kirakan tidak. duit syiling yang diperlukan; kembali jumlah dari array awalan; Kod pemacu", "code": "< ? php function preprocess ( & $ coin , $ n ) { sort ( $ coin ) ; for ( $ i = 1 ; $ i <= $ n - 1 ; $ i ++ ) $ coin [ $ i ] += $ coin [ $ i - 1 ] ; } function minCost ( & $ coin , $ n , $ k ) { $ coins_needed = ceil ( 1.0 * $ n / ( $ k + 1 ) ) ; return $ coin [ $ coins_needed - 1 ] ; } $ coin = array ( 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 ) ; $ n = sizeof ( $ coin ) ; preprocess ( $ coin , $ n ) ; $ k = 3 ; echo minCost ( $ coin , $ n , $ k ) . \" STRNEWLINE \" ; $ k = 7 ; echo minCost ( $ coin , $ n , $ k ) . \" STRNEWLINE \" ; ? >"}
{"text": "Memaksimumkan jumlah array selepas K Negasi | Tetapkan 1 | Fungsi ini melakukan operasi pada array dengan cara yang memaksimumkan jumlah array. Indeks -> menyimpan indeks elemen minimum semasa untuk operasi J 'th; Ubah suai array k bilangan kali; Cari elemen minimum dalam array untuk operasi semasa dan ubah suai i. e; arr [j] -> - arr [j]; Ini keadaan jika kita dapati 0 sebagai elemen minimum, jadi ia tidak berguna untuk menggantikan 0 oleh - (0) untuk baki operasi; Mengubah suai elemen array; Hitung jumlah array; Kod pemacu", "code": "< ? php function maximumSum ( $ arr , $ n , $ k ) { $ INT_MAX = 0 ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { $ min = $ INT_MAX ; $ index = -1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] < $ min ) { $ min = $ arr [ $ j ] ; $ index = $ j ; } } if ( $ min == 0 ) break ; $ arr [ $ index ] = - $ arr [ $ index ] ; } $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; return $ sum ; } $ arr = array ( -2 , 0 , 5 , -1 , 2 ) ; $ k = 4 ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo maximumSum ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Jumlah maksimum supaya tidak ada dua elemen bersebelahan | Tetapkan 2 | Program PHP untuk melaksanakan pendekatan di atas; pembolehubah untuk menyimpan negeri -negeri DP; Pembolehubah untuk memeriksa sama ada keadaan tertentu telah diselesaikan; Berfungsi untuk mencari jumlah maksimum berikutnya supaya tiada dua elemen bersebelahan; Kes asas; Untuk memeriksa sama ada keadaan telah diselesaikan; Hubungan berulang yang diperlukan; Mengembalikan nilai; Kod pemacu", "code": "< ? php $ maxLen = 10 ; $ dp = array_fill ( 0 , $ GLOBALS [ ' axLen ' , 0 ) ; $ v = array_fill ( 0 , $ GLOBALS [ ' axLen ' , 0 ) ; function maxSum ( $ arr , $ i , $ n ) { if ( $ i >= $ n ) return 0 ; if ( $ GLOBALS [ ' v ' ] [ $ i ] ) return $ GLOBALS [ ' dp ' ] [ $ i ] ; $ GLOBALS [ ' v ' ] [ $ i ] = 1 ; $ GLOBALS [ ' dp ' ] [ $ i ] = max ( maxSum ( $ arr , $ i + 1 , $ n ) , $ arr [ $ i ] + maxSum ( $ arr , $ i + 2 , $ n ) ) ; return $ GLOBALS [ ' dp ' ] [ $ i ] ; } $ arr = array ( 12 , 9 , 7 , 33 ) ; $ n = count ( $ arr ) ; echo maxSum ( $ arr , 0 , $ n ) ; ? >"}
{"text": "Memaksimumkan jumlah subarray selepas mengalikan semua elemen mana -mana subarray dengan x | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan jumlah maksimum; Kes asas; Jika sudah dikira; Jika tiada unsur telah dipilih; Jangan pilih mana -mana elemen dan gunakan algoritma Kadane dengan mengambil Max; Pilih sub -array dan darab x; Pilih sub -array dan darab x; Menamatkan pendaraban sub - array; Tiada pendaraban lagi; Memoize dan mengembalikan jawapannya; Berfungsi untuk mendapatkan jumlah maksimum; Memulakan DP dengan - 1; Melangkah dari setiap kedudukan dan cari jumlah maksimum yang mungkin; Kod pemacu", "code": "< ? php $ N = 5 ; function func ( $ idx , $ cur , $ a , $ dp , $ n , $ x ) { if ( $ idx == $ n ) return 0 ; if ( $ dp [ $ idx ] [ $ cur ] != -1 ) return $ dp [ $ idx ] [ $ cur ] ; $ ans = 0 ; if ( $ cur == 0 ) { $ ans = max ( $ ans , $ a [ $ idx ] + func ( $ idx + 1 , 0 , $ a , $ dp , $ n , $ x ) ) ; $ ans = max ( $ ans , $ x * $ a [ $ idx ] + func ( $ idx + 1 , 1 , $ a , $ dp , $ n , $ x ) ) ; } else if ( $ cur == 1 ) { $ ans = max ( $ ans , $ x * $ a [ $ idx ] + func ( $ idx + 1 , 1 , $ a , $ dp , $ n , $ x ) ) ; $ ans = max ( $ ans , $ a [ $ idx ] + func ( $ idx + 1 , 2 , $ a , $ dp , $ n , $ x ) ) ; } else $ ans = max ( $ ans , $ a [ $ idx ] + func ( $ idx + 1 , 2 , $ a , $ dp , $ n , $ x ) ) ; return $ dp [ $ idx ] [ $ cur ] = $ ans ; } function getMaximumSum ( $ a , $ n , $ x ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < 3 ; $ j ++ ) { $ dp [ $ i ] [ $ j ] = -1 ; } } $ maxi = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ maxi = max ( $ maxi , func ( $ i , 0 , $ a , $ dp , $ n , $ x ) ) ; return $ maxi ; } $ a = array ( -3 , 8 , -2 , 1 , -6 ) ; $ n = count ( $ a ) ; $ x = -1 ; echo getMaximumSum ( $ a , $ n , $ x ) ; ? >"}
{"text": "Kiraan pasangan bukan | Pelaksanaan PHP pendekatan; Fungsi pra - pemprosesan; Dapatkan saiz rentetan; Pada mulanya menandakan setiap kedudukan sebagai palsu; Untuk panjang; Melangkah untuk setiap indeks dengan panjang j; Jika panjangnya kurang daripada 2; Sekiranya watak adalah sama; Semak sama; Berfungsi untuk mengembalikan bilangan pasangan; Buat jadual DP pada mulanya; Mengisytiharkan array kiri; Mengisytiharkan array yang betul; Pada mulanya ditinggalkan [0] ialah 1; Kira bilangan pasangan palindrome ke kiri; Pada mulanya betul sebagai 1; Kira bilangan pasangan palindrome ke kanan; Mengira bilangan pasangan; Kod pemacu", "code": "< ? php $ N = 100 ; function pre_process ( $ dp , $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = false ; } for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { for ( $ i = 0 ; $ i <= $ n - $ j ; $ i ++ ) { if ( $ j <= 2 ) { if ( $ s [ $ i ] == $ s [ $ i + $ j - 1 ] ) $ dp [ $ i ] [ $ i + $ j - 1 ] = true ; } else if ( $ s [ $ i ] == $ s [ $ i + $ j - 1 ] ) $ dp [ $ i ] [ $ i + $ j - 1 ] = $ dp [ $ i + 1 ] [ $ i + $ j - 2 ] ; } } return $ dp ; } function countPairs ( $ s ) { $ dp = array ( array ( ) ) ; $ dp = pre_process ( $ dp , $ s ) ; $ n = strlen ( $ s ) ; $ left = array_fill ( 0 , $ n , 0 ) ; $ right = array_fill ( 0 , $ n , 0 ) ; $ left [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { if ( $ dp [ $ j ] [ $ i ] == 1 ) $ left [ $ i ] ++ ; } } $ right [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ right [ $ i ] = $ right [ $ i + 1 ] ; for ( $ j = $ n - 1 ; $ j >= $ i ; $ j -- ) { if ( $ dp [ $ i ] [ $ j ] == 1 ) $ right [ $ i ] ++ ; } } $ ans = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ ans += $ left [ $ i ] * $ right [ $ i + 1 ] ; return $ ans ; } $ s = \" abacaba \" ; echo countPairs ( $ s ) ; ? >"}
{"text": "Pertanyaan untuk memeriksa sama ada substring [l ... r] adalah palindrome atau tidak | Pelaksanaan PHP pendekatan; Fungsi pra - pemprosesan; Dapatkan saiz rentetan; Pada mulanya menandakan setiap kedudukan sebagai palsu; Untuk panjang; Melangkah untuk setiap indeks dengan panjang j; Jika panjangnya kurang daripada 2; Sekiranya watak adalah sama; Semak sama; Fungsi untuk menjawab setiap pertanyaan dalam O (1); Kod pemacu", "code": "< ? php $ N = 100 ; function pre_process ( $ dp , $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = false ; } for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { for ( $ i = 0 ; $ i <= $ n - $ j ; $ i ++ ) { if ( $ j <= 2 ) { if ( $ s [ $ i ] == $ s [ $ i + $ j - 1 ] ) $ dp [ $ i ] [ $ i + $ j - 1 ] = true ; } else if ( $ s [ $ i ] == $ s [ $ i + $ j - 1 ] ) $ dp [ $ i ] [ $ i + $ j - 1 ] = $ dp [ $ i + 1 ] [ $ i + $ j - 2 ] ; } } return $ dp ; } function answerQuery ( $ l , $ r , $ dp ) { if ( $ dp [ $ l ] [ $ r ] ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; } $ s = \" abaaab \" ; $ dp = array ( array ( ) ) ; $ dp = pre_process ( $ dp , $ s ) ; $ queries = array ( array ( 0 , 1 ) , array ( 1 , 5 ) ) ; $ q = count ( $ queries ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) answerQuery ( $ queries [ $ i ] [ 0 ] , $ queries [ $ i ] [ 1 ] , $ dp ) ; ? >"}
{"text": "Panjang yang paling lama meningkat selepas itu bahawa tidak ada dua elemen bersebelahan adalah coprime | Program PHP untuk mencari panjang sub urutan yang paling lama meningkat dari array yang diberikan supaya tidak ada dua elemen bersebelahan adalah perdana menteri; Fungsi untuk mencari panjang sub urutan yang paling lama meningkat dari array yang diberikan supaya tidak ada dua elemen bersebelahan yang menjadi perdana; Untuk menyimpan nilai DP dan D; Untuk menyimpan jawapan yang diperlukan; Untuk semua elemen dalam array; Pada mulanya jawapan adalah satu; Untuk semua pembahagi itu; Mengemas kini nilai DP; Mengemas kini nilai pembahagi; Periksa jawapan yang diperlukan; Kemas kini pembahagi [i]; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "< ? php $ N = 100005 ; function LIS ( $ a , $ n ) { $ dp = array ( ) ; $ d = array ( ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp [ $ a [ $ i ] ] = 1 ; for ( $ j = 2 ; $ j * $ j <= $ a [ $ i ] ; $ j ++ ) { if ( $ a [ $ i ] % $ j == 0 ) { $ dp [ $ a [ $ i ] ] = max ( $ dp [ $ a [ $ i ] ] , $ dp [ $ d [ $ j ] ] + 1 ) ; $ dp [ $ a [ $ i ] ] = max ( $ dp [ $ a [ $ i ] ] , $ dp [ $ d [ $ a [ $ i ] / $ j ] ] + 1 ) ; $ d [ $ j ] = $ a [ $ i ] ; $ d [ $ a [ $ i ] / $ j ] = $ a [ $ i ] ; } } $ ans = max ( $ ans , $ dp [ $ a [ $ i ] ] ) ; $ d [ $ a [ $ i ] ] = $ a [ $ i ] ; } return $ ans ; } $ a = array ( 1 , 2 , 3 , 4 , 5 , 6 ) ; $ n = sizeof ( $ a ) ; echo LIS ( $ a , $ n ) ; ? >"}
{"text": "Cari jumlah unsur pepenjuru dari matriks lingkaran n x n yang diberikan | Berfungsi untuk mengembalikan jumlah kedua -dua unsur pepenjuru matriks yang diperlukan; Array untuk menyimpan jumlah elemen pepenjuru; Kes asas; Pengkomputeran nilai DP; Kod pemacu", "code": "< ? php function findSum ( $ n ) { $ dp = array ( ) ; $ dp [ 1 ] = 1 ; $ dp [ 0 ] = 0 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = ( 4 * ( $ i * $ i ) ) - 6 * ( $ i - 1 ) + $ dp [ $ i - 2 ] ; } return $ dp [ $ n ] ; } $ n = 4 ; echo findSum ( $ n ) ; ? >"}
{"text": "Mengira bilangan cara untuk mencapai skor yang diberikan dalam matriks | Pelaksanaan PHP pendekatan; Untuk menyimpan negeri -negeri DP; Untuk memeriksa sama ada keadaan tertentu DP telah diselesaikan; Berfungsi untuk mencari cara menggunakan memoisasi; Kes asas; Jika skor yang diperlukan menjadi negatif; Jika keadaan semasa telah dicapai sebelum ini; Tetapkan keadaan semasa untuk dikunjungi; Kod pemacu", "code": "< ? php $ n = 3 ; $ MAX = 30 ; $ dp = array ( $ n , $ n , $ MAX ) ; $ v = array ( $ n , $ n , $ MAX ) ; function findCount ( $ mat , $ i , $ j , $ m ) { if ( $ i == 0 && $ j == 0 ) { if ( $ m == $ mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( $ m < 0 ) return 0 ; if ( $ i < 0 $ j < 0 ) return 0 ; if ( $ v [ $ i ] [ $ j ] [ $ m ] ) return $ dp [ $ i ] [ $ j ] [ $ m ] ; $ v [ $ i ] [ $ j ] [ $ m ] = true ; $ dp [ $ i ] [ $ j ] [ $ m ] = findCount ( $ mat , $ i - 1 , $ j , $ m - $ mat [ $ i ] [ $ j ] ) + findCount ( $ mat , $ i , $ j - 1 , $ m - $ mat [ $ i ] [ $ j ] ) ; return $ dp [ $ i ] [ $ j ] [ $ m ] ; } $ mat = array ( array ( 1 , 1 , 1 ) , array ( 1 , 1 , 1 ) , array ( 1 , 1 , 1 ) ) ; $ m = 5 ; echo ( findCount ( $ mat , $ n - 1 , $ n - 1 , $ m ) ) ;"}
{"text": "Langkah Minimum Untuk Menghapus Rentetan Dengan Memadam Substring yang terdiri daripada watak yang sama | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan bilangan minimum operasi memadam; Apabila satu watak dipadamkan; Apabila sekumpulan aksara berturut -turut dipadam jika mana -mana daripada mereka sepadan; Apabila kedua -dua watak itu sama kemudian memadam huruf di antara mereka; Memoize; Kod pemacu", "code": "< ? php $ GLOBALS [ ' N ' ] = 10 ; function findMinimumDeletion ( $ l , $ r , $ dp , $ s ) { if ( $ l > $ r ) return 0 ; if ( $ l == $ r ) return 1 ; if ( $ dp [ $ l ] [ $ r ] != -1 ) return $ dp [ $ l ] [ $ r ] ; $ res = 1 + findMinimumDeletion ( $ l + 1 , $ r , $ dp , $ s ) ; for ( $ i = $ l + 1 ; $ i <= $ r ; ++ $ i ) { if ( $ s [ $ l ] == $ s [ $ i ] ) $ res = min ( $ res , findMinimumDeletion ( $ l + 1 , $ i - 1 , $ dp , $ s ) + findMinimumDeletion ( $ i , $ r , $ dp , $ s ) ) ; } return $ dp [ $ l ] [ $ r ] = $ res ; } $ s = \" abcddcba \" ; $ n = strlen ( $ s ) ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) $ dp [ $ i ] [ $ j ] = -1 ; echo findMinimumDeletion ( 0 , $ n - 1 , $ dp , $ s ) ; ? >"}
{"text": "Cari bilangan pasangan simpang yang berbeza yang mempunyai jarak tepat k di pokok | Pelaksanaan PHP pendekatan; Untuk menyimpan simpul dan nilai k; Untuk menyimpan simpul nombor pada tahap I; Untuk menyimpan jawapan terakhir; Berfungsi untuk menambah kelebihan antara dua nod; Berfungsi untuk mencari bilangan pasangan yang berbeza dari simpang yang mempunyai jarak tepat k di dalam pokok; Pada tahap sifar tahap itu sendiri dikira; Kira sepasang simpang pada jarak k; Untuk semua peringkat mengira simpul; Kod pemacu; Tambah tepi; Panggilan fungsi; Jawapan yang diperlukan", "code": "< ? php $ N = 5005 ; $ gr = array_fill ( 0 , $ N , array ( ) ) ; $ d = array_fill ( 0 , $ N , array_fill ( 0 , 505 , 0 ) ) ; $ ans = 0 ; function Add_edge ( $ x , $ y ) { global $ gr ; array_push ( $ gr [ $ x ] , $ y ) ; array_push ( $ gr [ $ y ] , $ x ) ; } function dfs ( $ v , $ par ) { global $ d , $ ans , $ k , $ gr ; $ d [ $ v ] [ 0 ] = 1 ; foreach ( $ gr [ $ v ] as & $ i ) { if ( $ i != $ par ) { dfs ( $ i , $ v ) ; for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) $ ans += $ d [ $ i ] [ $ j - 1 ] * $ d [ $ v ] [ $ k - $ j ] ; for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) $ d [ $ v ] [ $ j ] += $ d [ $ i ] [ $ j - 1 ] ; } } } $ n = 5 ; $ k = 2 ; Add_edge ( 1 , 2 ) ; Add_edge ( 2 , 3 ) ; Add_edge ( 3 , 4 ) ; Add_edge ( 2 , 5 ) ; dfs ( 1 , 0 ) ; echo $ ans ; ? >"}
{"text": "Jumlah xor semua subarrays | Berfungsi untuk mengira jumlah XOR semua subarray; pembolehubah untuk menyimpan jumlah akhir; pengganda; Pembolehubah untuk menyimpan nombor sub -susunan dengan bilangan elemen yang ganjil dengan bit ith bermula dari elemen pertama hingga akhir array; pembolehubah untuk memeriksa status ganjil - bahkan dikira semasa mengira c_odd; gelung untuk mengira nilai awal c_odd; gelung untuk melangkah melalui semua elemen array dan kemas kini jumlah; mengemas kini pengganda; mengembalikan jumlah; Kod pemacu", "code": "< ? php function findXorSum ( $ arr , $ n ) { $ sum = 0 ; $ mul = 1 ; for ( $ i = 0 ; $ i < 30 ; $ i ++ ) { $ c_odd = 0 ; $ odd = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) > 0 ) $ odd = ( ! $ odd ) ; if ( $ odd ) $ c_odd ++ ; } for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ sum += ( $ mul * $ c_odd ) ; if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) > 0 ) $ c_odd = ( $ n - $ j - $ c_odd ) ; } $ mul *= 2 ; } return $ sum ; } $ arr = array ( 3 , 8 , 13 ) ; $ n = sizeof ( $ arr ) ; echo findXorSum ( $ arr , $ n ) ; ? >"}
{"text": "Semak sama ada mungkin untuk kembali ke jam 12 '0 hanya dengan menambah atau menolak detik yang diberikan | Berfungsi untuk memeriksa semua kombinasi; Menjana semua set kuasa; Periksa setiap kombinasi; Simpan jumlah untuk semua kombinasi; Semak jika bit jth di kaunter ditetapkan jika ditetapkan kemudian cetak elemen jth dari set; $ sum += $ a [$ j]; jika ditetapkan kemudian pertimbangkan sebagai ' +'; $ sum -= $ a [$ j]; lain dianggap sebagai ' -'; Jika kita boleh kembali ke 0; Kod pemacu", "code": "< ? php function checkCombinations ( $ a , $ n ) { $ pow_set_size = pow ( 2 , $ n ) ; for ( $ counter = 0 ; $ counter < $ pow_set_size ; $ counter ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ counter & ( 1 << $ j ) ) else } if ( $ sum % ( 24 * 60 ) == 0 ) return true ; } return false ; } $ a = array ( 60 , 60 , 120 ) ; $ n = sizeof ( $ a ) ; if ( checkCombinations ( $ a , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Cari kebarangkalian memilih elemen dari lajur kth selepas n lelaran | Fungsi untuk mengira kebarangkalian; mengisytiharkan dp [] [] dan jumlah []; Memperkenalkan baris pertama; Kirakan kebarangkalian untuk setiap elemen dan kemas kini jadual DP; hasil pulangan; Kod pemacu", "code": "< ? php function calcProbability ( $ M , $ k ) { $ m = 4 ; $ n = 4 ; $ dp = array ( ) ; $ sum = array ( ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ dp [ 0 ] [ $ j ] = $ M [ 0 ] [ $ j ] ; $ sum [ 0 ] += $ dp [ 0 ] [ $ j ] ; } for ( $ i = 1 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ dp [ $ i ] [ $ j ] += $ dp [ $ i - 1 ] [ $ j ] / $ sum [ $ i - 1 ] + $ M [ $ i ] [ $ j ] ; $ sum [ $ i ] += $ dp [ $ i ] [ $ j ] ; } } return $ dp [ $ n - 1 ] [ $ k - 1 ] / $ sum [ $ n - 1 ] ; } $ M = array ( array ( 1 , 1 , 0 , 3 ) , array ( 2 , 3 , 2 , 3 ) , array ( 9 , 3 , 0 , 2 ) , array ( 2 , 3 , 2 , 2 ) ) ; $ k = 3 ; echo calcProbability ( $ M , $ k ) ; ? >"}
{"text": "Kemungkinan pemotongan nombor sedemikian rupa sehingga bahagian maksimum boleh dibahagikan dengan 3 | Berfungsi untuk mencari bilangan maksimum nombor yang boleh dibahagikan dengan 3 dalam jumlah yang besar; saiz kedai rentetan; Kedai indeks terakhir baki; Tempat sifar sifar yang terakhir adalah pada 0 .; Untuk menyimpan hasil dari 0 hingga i; Dapatkan selebihnya; Dapatkan nilai maksimum [i]; Kod pemacu", "code": "< ? php function MaximumNumbers ( $ s ) { $ n = strlen ( $ s ) ; $ remIndex = array_fill ( 0 , 3 , -1 ) ; $ remIndex [ 0 ] = 0 ; $ res = array ( ) ; $ r = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ r = ( $ r + $ s [ $ i - 1 ] - '0' ) % 3 ; $ res [ $ i ] = $ res [ $ i - 1 ] ; if ( $ remIndex [ $ r ] != -1 ) $ res [ $ i ] = max ( $ res [ $ i ] , $ res [ $ remIndex [ $ r ] ] + 1 ) ; $ remIndex [ $ r ] = $ i + 1 ; } return $ res [ $ n ] ; } $ s = \"12345\" ; print ( MaximumNumbers ( $ s ) ) # This  code is contributed by Ryuga NEW_LINE ? >"}
{"text": "Kira bilangan laluan yang berat badannya betul -betul x dan mempunyai pada | Program PHP untuk mengira bilangan laluan; Berfungsi untuk mencari bilangan laluan; Jika penjumlahan lebih daripada x; Jika betul -betul X berat telah mencapai; Sudah dikunjungi; Kiraan laluan; Melintasi semua jalan; Jika berat tepi adalah m; berat badan lain bukan m; Kod pemacu; Memulakan array DP dengan - 1; Berfungsi untuk mengira laluan", "code": "< ? php $ max = 4 ; $ c = 2 ; function countPaths ( $ sum , $ get , $ m , $ n , & $ dp ) { global $ max , $ c ; if ( $ sum < 0 ) return 0 ; if ( $ sum == 0 ) return $ get ; if ( $ dp [ $ sum ] [ $ get ] != -1 ) return $ dp [ $ sum ] [ $ get ] ; $ res = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i == $ m ) $ res += countPaths ( $ sum - $ i , 1 , $ m , $ n , $ dp ) ; $ res += countPaths ( $ sum - $ i , $ get , $ m , $ n , $ dp ) ; } $ dp [ $ sum ] [ $ get ] = $ res ; return $ dp [ $ sum ] [ $ get ] ; } $ n = 3 ; $ m = 2 ; $ x = 3 ; $ dp = array_fill ( 0 , $ max + 1 , NULL ) ; for ( $ i = 0 ; $ i <= $ max ; $ i ++ ) for ( $ j = 0 ; $ j < 2 ; $ j ++ ) $ dp [ $ i ] [ $ j ] = -1 ; echo countPaths ( $ x , 0 , $ m , $ n , $ dp ) ; ? >"}
{"text": "Jumlah kuasa kth dari nombor semulajadi n Pertama | Array global untuk menyimpan faktorial; Berfungsi untuk mengira faktorial semua nombor sehingga k; Berfungsi untuk mengembalikan pekali binomial; ncr = (n! * (n - r)!) / r! ; Berfungsi untuk mengembalikan jumlah kuasa kth dari nombor semulajadi; Apabila J adalah perpaduan; Mengira jumlah (n ^ 1) kuasa perpaduan n; menyimpan jumlah (n ^ 1) untuk jumlah (n ^ 2); Jika k = 1 maka temp adalah hasilnya; Untuk mencari jumlah (n ^ k) mengeluarkan 1 dan n * kck dari (n + 1) ^ k; Mengeluarkan semua kc2 * jumlah (n ^ (k - 2)) + ... + kck - 1 * (jumlah (n ^ (k - (k - 1)); menyimpan hasil untuk jumlah seterusnya kuasa seterusnya k; kod pemacu", "code": "< ? php $ MAX_K = 15 ; $ fac [ $ MAX_K ] = array ( ) ; function factorial ( $ k ) { global $ fac ; $ fac [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ k + 1 ; $ i ++ ) { $ fac [ $ i ] = ( $ i * $ fac [ $ i - 1 ] ) ; } } function bin ( $ a , $ b ) { global $ MAX_K ; global $ fac ; $ ans = ( ( $ fac [ $ a ] ) / ( $ fac [ $ a - $ b ] * $ fac [ $ b ] ) ) ; return $ ans ; } function sumofn ( $ n , $ k ) { $ p = 0 ; $ num1 ; $ temp ; $ arr [ 1000 ] = array ( ) ; for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) { if ( $ j == 1 ) { $ num1 = ( $ n * ( $ n + 1 ) ) / 2 ; $ arr [ $ p ++ ] = $ num1 ; $ temp = $ num1 ; } else { $ temp = ( pow ( $ n + 1 , $ j + 1 ) - 1 - $ n ) ; for ( $ s = 1 ; $ s < $ j ; $ s ++ ) { $ temp = $ temp - ( $ arr [ $ j - $ s - 1 ] * bin ( $ j + 1 , $ s + 1 ) ) ; } $ temp = $ temp / ( $ j + 1 ) ; $ arr [ $ p ++ ] = $ temp ; } } $ temp = $ arr [ $ p - 1 ] ; return $ temp ; } $ n = 5 ; $ k = 2 ; factorial ( $ k ) ; echo sumofn ( $ n , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cara untuk mengisi kedudukan n menggunakan warna m sehingga terdapat perspektif pasangan warna yang bersebelahan dengan warna yang berbeza | Pelaksanaan PHP pendekatan; Fungsi rekursif untuk mencari bilangan cara yang diperlukan; Apabila semua jawatan dipenuhi; Jika pasangan bersebelahan betul -betul k; Jika sudah dikira; Kedudukan seterusnya dipenuhi dengan warna yang sama; Kedudukan seterusnya yang dipenuhi dengan warna yang berbeza supaya ada m - 1 warna yang berbeza; Kod pemacu", "code": "< ? php $ GLOBALS [ ' max ' ] = 4 ; function countWays ( $ index , $ cnt , $ dp , $ n , $ m , $ k ) { if ( $ index == $ n ) { if ( $ cnt == $ k ) return 1 ; else return 0 ; } if ( $ dp [ $ index ] [ $ cnt ] != -1 ) return $ dp [ $ index ] [ $ cnt ] ; $ ans = 0 ; $ ans += countWays ( $ index + 1 , $ cnt , $ dp , $ n , $ m , $ k ) ; $ ans += ( $ m - 1 ) * countWays ( $ index + 1 , $ cnt + 1 , $ dp , $ n , $ m , $ k ) ; $ dp [ $ index ] [ $ cnt ] = $ ans ; return $ dp [ $ index ] [ $ cnt ] ; } $ n = 3 ; $ m = 3 ; $ k = 2 ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' max ' ] ; $ j ++ ) $ dp [ $ i ] [ $ j ] = -1 ; echo $ m * countWays ( 1 , 0 , $ dp , $ n , $ m , $ k ) ; ? >"}
{"text": "Jumlah nombor Fibonacci pada indeks sehingga istilah n | Mengira nilai nombor Fibonacci pertama dan menyimpan jumlah yang diindeks walaupun; Memulakan hasil; Tambah istilah yang tinggal; Untuk indeks walaupun; Kembalikan jumlah alterning; Dapatkan n; Cari jumlah yang ditunjukkan walaupun", "code": "< ? php function calculateEvenSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 2 * $ n + 1 ] = array ( ) ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = 0 ; for ( $ i = 2 ; $ i <= 2 * $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; if ( $ i % 2 == 0 ) $ sum += $ fibo [ $ i ] ; } return $ sum ; } $ n = 8 ; echo \" Even ▁ indexed ▁ Fibonacci ▁ Sum ▁ upto ▁ \" . $ n . \" ▁ terms : ▁ \" . calculateEvenSum ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Urutan Gould | 32768 = 2 ^ 15; Array untuk menyimpan urutan sehingga 2 ^ 16 = 65536; Fungsi utiliti untuk mengira nombor ganjil dalam baris segitiga Pascals; Istilah pertama urutan ialah 1; Memulakan saya hingga 1; Inisialisasi p hingga 1 (i. E 2 ^ i) Dalam setiap lelaran saya akan menjadi kuasa 2; gelung untuk menjana urutan Gould; Saya adalah kuasa pth 2 melintasi array dari j = 0 hingga i i. e (2 ^ p); dua kali ganda nilai arr [j] dan simpan ke arr [i + j]; Kemas kini saya ke kuasa seterusnya 2; kenaikan p; Berfungsi untuk mencetak urutan Gould; gelung untuk menjana urutan Gould sehingga n; Kod pemacu; Dapatkan n; Panggilan fungsi", "code": "< ? php $ MAX = 32768 ; $ arr = array_fill ( 0 , 2 * $ MAX , 0 ) ; function gouldSequence ( ) { global $ MAX , $ arr ; $ arr [ 0 ] = 1 ; $ i = 1 ; $ p = 1 ; while ( $ i <= $ MAX ) { $ j = 0 ; while ( $ j < $ i ) { $ arr [ $ i + $ j ] = 2 * $ arr [ $ j ] ; $ j ++ ; } $ i = ( 1 << $ p ) ; $ p ++ ; } } function printSequence ( $ n ) { global $ MAX , $ arr ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ arr [ $ i ] . \" \" ; } } gouldSequence ( ) ; $ n = 16 ; printSequence ( $ n ) ; ? >"}
{"text": "Pendaraban rantai matriks (A O (N ^ 2) Penyelesaian) | Matrix MI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Untuk kesederhanaan program, satu baris tambahan dan satu lajur tambahan diperuntukkan dalam DP [] []. 0 bar dan lajur 0 dp [] [] tidak digunakan; Kos adalah sifar apabila mendarabkan satu matriks. ; Hanya mengikuti formula rekursif di atas. ; Kod pemacu", "code": "< ? php function MatrixChainOrder ( $ p , $ n ) { $ dp = array ( ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] [ $ i ] = 0 ; for ( $ L = 1 ; $ L < $ n - 1 ; $ L ++ ) for ( $ i = 1 ; $ i < $ n - $ L ; $ i ++ ) $ dp [ $ i ] [ $ i + $ L ] = min ( $ dp [ $ i + 1 ] [ $ i + $ L ] + $ p [ $ i - 1 ] * $ p [ $ i ] * $ p [ $ i + $ L ] , $ dp [ $ i ] [ $ i + $ L - 1 ] + $ p [ $ i - 1 ] * $ p [ $ i + $ L - 1 ] * $ p [ $ i + $ L ] ) ; return $ dp [ 1 ] [ $ n - 1 ] ; } $ arr = array ( 10 , 20 , 30 , 40 , 30 ) ; $ size = sizeof ( $ arr ) ; echo \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" . MatrixChainOrder ( $ arr , $ size ) ; ? >"}
{"text": "Mengira seterusnya dalam dua rentetan | mengembalikan bilangan seterusnya dalam dua rentetan; untuk setiap watak s; untuk setiap watak dalam t; Jika watak adalah sama dalam kedua -dua rentetan; Kod pemacu", "code": "< ? php function CommomSubsequencesCount ( $ s , $ t ) { $ n1 = strlen ( $ s ) ; $ n2 = strlen ( $ t ) ; $ dp = array ( ) ; for ( $ i = 0 ; $ i <= $ n1 ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n2 ; $ j ++ ) { $ dp [ $ i ] [ $ j ] = 0 ; } } for ( $ i = 1 ; $ i <= $ n1 ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n2 ; $ j ++ ) { if ( $ s [ $ i - 1 ] == $ t [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i ] [ $ j - 1 ] + $ dp [ $ i - 1 ] [ $ j ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i ] [ $ j - 1 ] + $ dp [ $ i - 1 ] [ $ j ] - $ dp [ $ i - 1 ] [ $ j - 1 ] ; } } return $ dp [ $ n1 ] [ $ n2 ] ; } $ s = \" ajblqcpdz \" ; $ t = \" aefcnbtdi \" ; echo CommomSubsequencesCount ( $ s , $ t ) . \" \" ; ? >"}
{"text": "Bilangan cara untuk mewakili nombor sebagai jumlah k Fibonacci nombor | Untuk menyimpan nombor Fibonacci 42 nombor kedua dalam siri Fibonacci yang terbesar integer; Berfungsi untuk menjana siri Fibonacci; Fungsi rekursif untuk mengembalikan bilangan cara; keadaan asas; untuk panggilan fungsi rekursif; Kod pemacu", "code": "< ? php $ fib = array_fill ( 0 , 43 , 0 ) ; function fibonacci ( ) { global $ fib ; $ fib [ 0 ] = 1 ; $ fib [ 1 ] = 2 ; for ( $ i = 2 ; $ i < 43 ; $ i ++ ) $ fib [ $ i ] = $ fib [ $ i - 1 ] + $ fib [ $ i - 2 ] ; } function rec ( $ x , $ y , $ last ) { global $ fib ; if ( $ y == 0 ) { if ( $ x == 0 ) return 1 ; return 0 ; } $ sum = 0 ; for ( $ i = $ last ; $ i >= 0 and $ fib [ $ i ] * $ y >= $ x ; $ i -- ) { if ( $ fib [ $ i ] > $ x ) continue ; $ sum += rec ( $ x - $ fib [ $ i ] , $ y - 1 , $ i ) ; } return $ sum ; } fibonacci ( ) ; $ n = 13 ; $ k = 3 ; echo \" Possible ▁ ways ▁ are : ▁ \" . rec ( $ n , $ k , 42 ) ; ? >"}
{"text": "Kos minimum untuk mencapai bahagian atas lantai dengan memanjat tangga | berfungsi untuk mencari kos minimum untuk mencapai lantai n - th; Kes asas; Pada mulanya untuk mendaki sehingga tangga 0 atau ke -1; ITERATE untuk mencari kos; mengembalikan minimum; Kod pemacu", "code": "< ? php function minimumCost ( & $ cost , $ n ) { if ( $ n == 1 ) return $ cost [ 0 ] ; $ dp [ 0 ] = $ cost [ 0 ] ; $ dp [ 1 ] = $ cost [ 1 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] , $ dp [ $ i - 2 ] ) + $ cost [ $ i ] ; } return min ( $ dp [ $ n - 2 ] , $ dp [ $ n - 1 ] ) ; } $ a = array ( 16 , 19 , 10 , 12 , 18 ) ; $ n = sizeof ( $ a ) ; echo ( minimumCost ( $ a , $ n ) ) ; ? >"}
{"text": "Kos minimum untuk mencapai bahagian atas lantai dengan memanjat tangga | berfungsi untuk mencari kos minimum untuk mencapai lantai n - th; melintasi tangga n - th; mengemas kini nilai dua tangga terakhir; Kod pemacu", "code": "< ? php function minimumCost ( & $ cost , $ n ) { $ dp1 = 0 ; $ dp2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp0 = $ cost [ $ i ] + min ( $ dp1 , $ dp2 ) ; $ dp2 = $ dp1 ; $ dp1 = $ dp0 ; } return min ( $ dp1 , $ dp2 ) ; } $ a = array ( 2 , 5 , 3 , 1 , 7 , 3 , 4 ) ; $ n = sizeof ( $ a ) ; echo ( minimumCost ( $ a , $ n ) ) ; ? >"}
{"text": "Edit Jarak dan LCS (Susunan Umum Terpanjang) | Program PHP untuk mencari jarak edit (apabila hanya dua operasi dibenarkan, masukkan dan padamkan) menggunakan LCS. ; Cari LCS; Edit Jarak adalah Padam Operasi + INSERT OPERASI. ; Kod pemacu", "code": "< ? php function editDistanceWith2Ops ( $ X , $ Y ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ L [ $ m + 1 ] [ $ n + 1 ] ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ i ] [ $ j ] = $ L [ $ i - 1 ] [ $ j - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] = max ( $ L [ $ i - 1 ] [ $ j ] , $ L [ $ i ] [ $ j - 1 ] ) ; } } $ lcs = $ L [ $ m ] [ $ n ] ; return ( $ m - $ lcs ) + ( $ n - $ lcs ) ; } $ X = \" abc \" ; $ Y = \" acd \" ; echo editDistanceWith2Ops ( $ X , $ Y ) ; ? >"}
{"text": "Susunan Umum Terpanjang | DP Menggunakan Memoization | Mengembalikan panjang LCS untuk x [0 .. m - 1], y [0 .. n - 1]; Kod pemacu; Cari panjang tali", "code": "< ? php function lcs ( $ X , $ Y , $ m , $ n ) { if ( $ m == 0 $ n == 0 ) return 0 ; if ( $ X [ $ m - 1 ] == $ Y [ $ n - 1 ] ) return 1 + lcs ( $ X , $ Y , $ m - 1 , $ n - 1 ) ; else return max ( lcs ( $ X , $ Y , $ m , $ n - 1 ) , lcs ( $ X , $ Y , $ m - 1 , $ n ) ) ; } $ X = \" AGGTAB \" ; $ Y = \" GXTXAYB \" ; $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; echo \" Length ▁ of ▁ LCS : ▁ \" . lcs ( $ X , $ Y , $ m , $ n ) ; ? >"}
{"text": "Bilangan jalur kitaran yang berbeza panjang n dalam tetrahedron | Berfungsi untuk mengira bilangan langkah dalam tetrahedron; Pada mulanya datang ke B ialah B -> B; tidak dapat mencapai A, D atau C; melangkah untuk semua langkah; hubungan berulang; Memoize nilai sebelumnya; mengembalikan langkah; Kod pemacu", "code": "< ? php function countPaths ( $ n ) { $ zB = 1 ; $ zADC = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ nzB = $ zADC * 3 ; $ nzADC = ( $ zADC * 2 + $ zB ) ; $ zB = $ nzB ; $ zADC = $ nzADC ; } return $ zB ; } $ n = 3 ; echo countPaths ( $ n ) ; ? >"}
{"text": "Masalah penjajaran urutan | berfungsi untuk mengetahui penalti minimum; Jadual untuk menyimpan jawapan substruktur yang optimum; memulakan jadual; mengira penalti minimum; Membina semula penyelesaian $ l = $ n + $ m; panjang maksimum yang mungkin; Jawapan akhir untuk rentetan masing -masing $ xans [$ l + 1]; $ yans [$ l + 1]; ; Oleh kerana kita telah menganggap jawapannya panjang n + m, kita perlu mengeluarkan jurang tambahan dalam ID permulaan mewakili indeks dari mana array Xans, Yans berguna; Mencetak jawapan terakhir; rentetan input; permulaan penalti pelbagai jenis; Memanggil fungsi untuk mengira hasilnya", "code": "< ? php function getMinimumPenalty ( $ x , $ y , $ pxy , $ pgap ) { $ dp [ $ n + $ m + 1 ] [ $ n + $ m + 1 ] = array ( 0 ) ; for ( $ i = 0 ; $ i <= ( $ n + $ m ) ; $ i ++ ) { $ dp [ $ i ] [ 0 ] = $ i * $ pgap ; $ dp [ 0 ] [ $ i ] = $ i * $ pgap ; } for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ x [ $ i - 1 ] == $ y [ $ j - 1 ] ) { $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j - 1 ] ; } else { $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i - 1 ] [ $ j - 1 ] + $ pxy , $ dp [ $ i - 1 ] [ $ j ] + $ pgap , $ dp [ $ i ] [ $ j - 1 ] + $ pgap ) ; } } } $ i = $ m ; $ j = $ n ; $ xpos = $ l ; $ ypos = $ l ; while ( ! ( $ i == 0 $ j == 0 ) ) { if ( $ x [ $ i - 1 ] == $ y [ $ j - 1 ] ) { $ xans [ $ xpos -- ] = $ x [ $ i - 1 ] ; $ yans [ $ ypos -- ] = $ y [ $ j - 1 ] ; $ i -- ; $ j -- ; } else if ( $ dp [ $ i - 1 ] [ $ j - 1 ] + $ pxy == $ dp [ $ i ] [ $ j ] ) { $ xans [ $ xpos -- ] = $ x [ $ i - 1 ] ; $ yans [ $ ypos -- ] = $ y [ $ j - 1 ] ; $ i -- ; $ j -- ; } else if ( $ dp [ $ i - 1 ] [ $ j ] + $ pgap == $ dp [ $ i ] [ $ j ] ) { $ xans [ $ xpos -- ] = $ x [ $ i - 1 ] ; $ yans [ $ ypos -- ] = ' _ ' ; $ i -- ; } else if ( $ dp [ $ i ] [ $ j - 1 ] + $ pgap == $ dp [ $ i ] [ $ j ] ) { $ xans [ $ xpos -- ] = ' _ ' ; $ yans [ $ ypos -- ] = $ y [ $ j - 1 ] ; $ j -- ; } } while ( $ xpos > 0 ) { if ( $ i > 0 ) $ xans [ $ xpos -- ] = $ x [ -- $ i ] ; else $ xans [ $ xpos -- ] = ' _ ' ; } while ( $ ypos > 0 ) { if ( $ j > 0 ) $ yans [ $ ypos -- ] = $ y [ -- $ j ] ; else $ yans [ $ ypos -- ] = ' _ ' ; } $ id = 1 ; for ( $ i = $ l ; $ i >= 1 ; $ i -- ) { if ( $ yans [ $ i ] == ' _ ' && $ xans [ $ i ] == ' _ ' ) { $ id = $ i + 1 ; break ; } } echo \" Minimum ▁ Penalty ▁ in ▁ \" . \" aligning ▁ the ▁ genes ▁ = ▁ \" ; echo $ dp [ $ m ] [ $ n ] . \" STRNEWLINE \" ; echo \" The ▁ aligned ▁ genes ▁ are ▁ : STRNEWLINE \" ; for ( $ i = $ id ; $ i <= $ l ; $ i ++ ) { echo $ xans [ $ i ] ; } echo \" STRNEWLINE \" ; for ( $ i = $ id ; $ i <= $ l ; $ i ++ ) { echo $ yans [ $ i ] ; } return ; } $ gene1 = \" AGGGCT \" ; $ gene2 = \" AGGCA \" ; $ misMatchPenalty = 3 ; $ gapPenalty = 2 ; getMinimumPenalty ( $ gene1 , $ gene2 , $ misMatchPenalty , $ gapPenalty ) ; ? >"}
{"text": "Susunan yang paling lama berkurangan | Fungsi yang mengembalikan panjang seterusnya yang paling lama berkurangan; Inisialisasi LDS dengan 1 untuk semua indeks LD minimum bermula dengan mana -mana elemen sentiasa 1; Kirakan LD dari setiap indeks secara bawah; Pilih maksimum semua nilai LDS; mengembalikan panjang LDS; Kod pemacu", "code": "< ? php function lds ( $ arr , $ n ) { $ lds = array ( ) ; $ i ; $ j ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] < $ arr [ $ j ] and $ lds [ $ i ] < $ lds [ $ j ] + 1 ) { $ lds [ $ i ] = $ lds [ $ j ] + 1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ lds [ $ i ] ) $ max = $ lds [ $ i ] ; return $ max ; } $ arr = array ( 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 ) ; $ n = count ( $ arr ) ; echo \" Length ▁ of ▁ LDS ▁ is ▁ \" , lds ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah produk pekali binomial berturut -turut | Program PHP untuk mencari jumlah produk pekali binomial berturut -turut. ; Cari pekali binomial sehingga istilah nth; $ C [0] = 1; NC0 adalah 1; Kirakan baris seterusnya segitiga Pascal menggunakan baris sebelumnya; Kembalikan jumlah produk pekali binomial berturut -turut. ; Mencari jumlah produk pekali berturut -turut. ; Kod pemacu", "code": "< ? php $ MAX = 100 ; function binomialCoeff ( $ C , $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ n ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C ; } function sumOfproduct ( $ n ) { global $ MAX ; $ sum = 0 ; $ C = array_fill ( 0 , $ MAX , 0 ) ; $ C = binomialCoeff ( $ C , $ n ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ sum += $ C [ $ i ] * $ C [ $ i + 1 ] ; return $ sum ; } $ n = 3 ; echo sumOfproduct ( $ n ) ; ? >"}
{"text": "Jumlah produk pekali binomial R dan Rth (R * NCR) | Program PHP untuk mencari jumlah produk pekali binomial R dan Rth i. E Summation r * ncr; Kembalikan terma N pertama pekali binomial. ; $ C [0] = 1; NC0 adalah 1; Kirakan baris seterusnya segitiga Pascal menggunakan baris sebelumnya; PEMULIHAN PEMBELAJARAN R * NCR; Mencari istilah N pertama pekali binomial; Melelehkan gelung untuk mencari jumlahnya. ; Kod pemacu", "code": "< ? php $ MAX = 100 ; function binomialCoeff ( $ n , & $ C ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ n ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } } function summation ( $ n ) { global $ MAX ; $ C = array_fill ( 0 , $ MAX , 0 ) ; binomialCoeff ( $ n , $ C ) ; $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ C [ $ i ] ) ; return $ sum ; } $ n = 2 ; echo summation ( $ n ) ; ? >"}
{"text": "Bilangan tatasusunan saiz n yang elemennya adalah bilangan bulat positif dan jumlahnya adalah k | Kembali NCR; $ C [0] = 1; NC0 adalah 1; Kirakan baris seterusnya segitiga Pascal menggunakan baris sebelumnya; Kembalikan bilangan array yang boleh dibentuk saiz n dan jumlah sama dengan k. ; Kod pemacu", "code": "< ? php function binomialCoeff ( $ n , $ k ) { $ C = array_fill ( 0 , ( $ k + 1 ) , 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ k ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C [ $ k ] ; } function countArray ( $ N , $ K ) { return binomialCoeff ( $ K - 1 , $ N - 1 ) ; } $ N = 2 ; $ K = 3 ; echo countArray ( $ N , $ K ) ; ? >"}
{"text": "Memaksimumkan Elemen Array sehingga Nombor Diberikan | Fungsi untuk mencari nilai maksimum bilangan yang boleh diperolehi menggunakan elemen array. ; Pembolehubah untuk mewakili indeks semasa. ; Pembolehubah untuk menunjukkan nilai antara 0 dan maxlimit. ; Jadual untuk menyimpan sama ada nilai boleh diperoleh atau tidak sehingga indeks tertentu. 1. Dp [i] [j] = 1 Jika nilai j boleh diperolehi indeks sehingga i. 2. Dp [i] [j] = 0 Jika nilai j tidak dapat diperolehi indeks sehingga i. ; Semak indeks 0 jika diberi nilai val boleh diperoleh dengan sama ada menambah atau menolak ARR [0] dari NUM. ; 1. Jika arr [ind] ditambah untuk mendapatkan val yang diberikan kemudian val - arr [ind] harus diperolehi dari indeks ind - 1. Jika arr [ind] dikurangkan untuk mendapatkan val kemudian val + arr [ind] harus diperoleh dari indeks ind -1. Periksa kedua -dua syarat. ; Jika salah satu daripada satu keadaan adalah benar, maka Val boleh didapati di Indeks Ind. ; Cari nilai maksimum yang diperolehi pada indeks n - 1 .; Jika tiada penyelesaian wujud kembali - 1 .; Kod pemacu", "code": "< ? php function findMaxVal ( $ arr , $ n , $ num , $ maxLimit ) { $ ind ; $ val ; $ dp [ $ n ] [ $ maxLimit + 1 ] = array ( ) ; for ( $ ind = 0 ; $ ind < $ n ; $ ind ++ ) { for ( $ val = 0 ; $ val <= $ maxLimit ; $ val ++ ) { if ( $ ind == 0 ) { if ( $ num - $ arr [ $ ind ] == $ val $ num + $ arr [ $ ind ] == $ val ) { $ dp [ $ ind ] [ $ val ] = 1 ; } else { $ dp [ $ ind ] [ $ val ] = 0 ; } } else { if ( $ val - $ arr [ $ ind ] >= 0 && $ val + $ arr [ $ ind ] <= $ maxLimit ) { $ dp [ $ ind ] [ $ val ] = $ dp [ $ ind - 1 ] [ $ val - $ arr [ $ ind ] ] || $ dp [ $ ind - 1 ] [ $ val + $ arr [ $ ind ] ] ; } else if ( $ val - $ arr [ $ ind ] >= 0 ) { $ dp [ $ ind ] [ $ val ] = $ dp [ $ ind - 1 ] [ $ val - $ arr [ $ ind ] ] ; } else if ( $ val + $ arr [ $ ind ] <= $ maxLimit ) { $ dp [ $ ind ] [ $ val ] = $ dp [ $ ind - 1 ] [ $ val + $ arr [ $ ind ] ] ; } else { $ dp [ $ ind ] [ $ val ] = 0 ; } } } } for ( $ val = $ maxLimit ; $ val >= 0 ; $ val -- ) { if ( $ dp [ $ n - 1 ] [ $ val ] ) { return $ val ; } } return -1 ; } $ num = 1 ; $ arr = array ( 3 , 10 , 6 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; $ maxLimit = 15 ; echo findMaxVal ( $ arr , $ n , $ num , $ maxLimit ) ; ? >"}
{"text": "Moser | Berfungsi untuk menjana istilah nth Moser - de Bruijn urutan; S (0) = 0; S (1) = 1; S (2 * n) = 4 * s (n); S (2 * n + 1) = 4 * s (n) + 1; Menjana terma pertama 'N' Moser - de Bruijn; Kod pemacu", "code": "< ? php function gen ( $ n ) { if ( $ n == 0 ) return 0 ; else if ( $ n == 1 ) return 1 ; else if ( $ n % 2 == 0 ) return 4 * gen ( $ n / 2 ) ; else if ( $ n % 2 == 1 ) return 4 * gen ( $ n / 2 ) + 1 ; } function moserDeBruijn ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( gen ( $ i ) . \" ▁ \" ) ; echo ( \" STRNEWLINE \" ) ; } $ n = 15 ; echo ( \" First ▁ \" . $ n . \" ▁ terms ▁ of ▁ \" . \" Moser - de ▁ Bruijn ▁ Sequence ▁ : ▁ STRNEWLINE \" ) ; echo ( moserDeBruijn ( $ n ) ) ; ? >"}
{"text": "Laluan Jumlah Minimum dalam Segitiga | Menggunakan fungsi untuk mencari jumlah minimum untuk jalan; Untuk menyimpan hasil dalam array 1 - d, dan pada masa yang sama mengemas kini hasilnya. ; Untuk baris bawah; Pengiraan baris yang tinggal, secara bawah. ; mengembalikan elemen teratas; Kod pemacu", "code": "< ? php function minSumPath ( & $ A ) { $ memo = array ( ) ; for ( $ i = 0 ; $ i < count ( $ A ) ; $ i ++ ) $ memo [ $ i ] = 0 ; $ n = count ( $ A ) - 1 ; for ( $ i = 0 ; $ i < count ( $ A [ $ n ] ) ; $ i ++ ) $ memo [ $ i ] = $ A [ $ n ] [ $ i ] ; for ( $ i = count ( $ A ) - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = 0 ; $ j < count ( $ A [ $ i + 1 ] ) - 1 ; $ j ++ ) $ memo [ $ j ] = $ A [ $ i ] [ $ j ] + min ( $ memo [ $ j ] , $ memo [ $ j + 1 ] ) ; return $ memo [ 0 ] ; } $ A = array ( array ( 2 ) , array ( 3 , 9 ) , array ( 1 , 6 , 7 ) ) ; echo ( minSumPath ( $ A ) ) ; ? >"}
{"text": "Penyingkiran minimum dari array untuk membuat max | Program PHP untuk mencari penyingkiran minimum untuk membuat max - min <= k; berfungsi untuk memeriksa semua kemungkinan kombinasi penyingkiran dan mengembalikan minimum; Kes asas apabila semua elemen dikeluarkan; Jika keadaan berpuas hati, tiada lagi penyingkiran diperlukan; Sekiranya negara telah dikunjungi; Apabila AMAX - AMIN> D; Minimum diambil dari penyingkiran elemen minimum atau penyingkiran elemen maksimum; Untuk menyusun array dan mengembalikan jawapannya; Susun array; Isi semua yang dinyatakan dengan - 1 apabila hanya satu elemen; Kod pemacu", "code": "< ? php $ MAX = 100 ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { for ( $ j = 0 ; $ j < $ MAX ; $ j ++ ) $ dp [ $ i ] [ $ j ] = -1 ; } function countRemovals ( $ a , $ i , $ j , $ k ) { global $ dp ; if ( $ i >= $ j ) return 0 ; else if ( ( $ a [ $ j ] - $ a [ $ i ] ) <= $ k ) return 0 ; else if ( $ dp [ $ i ] [ $ j ] != -1 ) return $ dp [ $ i ] [ $ j ] ; else if ( ( $ a [ $ j ] - $ a [ $ i ] ) > $ k ) { $ dp [ $ i ] [ $ j ] = 1 + min ( countRemovals ( $ a , $ i + 1 , $ j , $ k ) , countRemovals ( $ a , $ i , $ j - 1 , $ k ) ) ; } return $ dp [ $ i ] [ $ j ] ; } function removals ( $ a , $ n , $ k ) { sort ( $ a ) ; if ( $ n == 1 ) return 0 ; else return countRemovals ( $ a , 0 , $ n - 1 , $ k ) ; } $ a = array ( 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 ) ; $ n = count ( $ a ) ; $ k = 4 ; echo ( removals ( $ a , $ n , $ k ) ) ; ? >"}
{"text": "Bilangan pasangan yang diperintahkan seperti itu (AI & AJ) = 0 | Fungsi naif untuk mengira bilangan pasangan yang diperintahkan supaya bitwise mereka dan 0; Semak semua pasangan yang mungkin; Tambah 2 sebagai (i, j) dan (j, i) dianggap berbeza; Kod pemacu", "code": "< ? php function countPairs ( $ a , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( ( $ a [ $ i ] & $ a [ $ j ] ) == 0 ) $ count += 2 ; } return $ count ; } { $ a = array ( 3 , 4 , 2 ) ; $ n = sizeof ( $ a ) / sizeof ( $ a [ 0 ] ) ; echo countPairs ( $ a , $ n ) ; return 0 ; }"}
{"text": "Minimum jumlah pendaraban nombor N | Digunakan dalam penyelesaian memoized rekursif; berfungsi untuk mengira jumlah kumulatif dari [i] ke [j]; Kes asas; Memoisasi, jika partition telah dipanggil sebelum kemudian mengembalikan nilai yang disimpan; Simpan nilai maksimum; Kami memecahkan mereka ke dalam partisi K; Simpan min formula yang diperolehi; mengembalikan minimum; Kod pemacu", "code": "< ? php $ dp = array ( array ( ) ) ; function sum ( $ a , $ i , $ j ) { $ ans = 0 ; for ( $ m = $ i ; $ m <= $ j ; $ m ++ ) $ ans = ( $ ans + $ a [ $ m ] ) % 100 ; return $ ans ; } function solve ( $ a , $ i , $ j ) { global $ dp ; if ( $ i == $ j ) return 0 ; if ( $ dp [ $ i ] [ $ j ] != -1 ) return $ dp [ $ i ] [ $ j ] ; $ dp [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) { $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i ] [ $ j ] , ( solve ( $ a , $ i , $ k ) + solve ( $ a , $ k + 1 , $ j ) + ( sum ( $ a , $ i , $ k ) * sum ( $ a , $ k + 1 , $ j ) ) ) ) ; } return $ dp [ $ i ] [ $ j ] ; } function initialize ( $ n ) { global $ dp ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = -1 ; } $ a = array ( 40 , 60 , 20 ) ; $ n = count ( $ a ) ; initialize ( $ n ) ; echo solve ( $ a , 0 , $ n - 1 ) ; ? >"}
{"text": "Cetak Siri Fibonacci dalam urutan terbalik | Program PHP untuk mencetak siri Fibonacci dalam urutan terbalik; Menetapkan elemen pertama dan kedua; menyimpan jumlah di lokasi sebelumnya; pelbagai percetakan dalam urutan terbalik; Kod pemacu", "code": "< ? php function reverseFibonacci ( $ n ) { $ a [ 0 ] = 0 ; $ a [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = $ a [ $ i - 2 ] + $ a [ $ i - 1 ] ; } for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { echo ( $ a [ $ i ] . \" \" ) ; } } $ n = 5 ; reverseFibonacci ( $ n ) ; ? >"}
{"text": "Kebarangkalian mencapai titik dengan 2 atau 3 langkah pada satu masa | Mengembalikan kebarangkalian untuk mencapai n; Kod pemacu", "code": "< ? php function find_prob ( $ N , $ P ) { $ dp ; $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 0 ; $ dp [ 2 ] = $ P ; $ dp [ 3 ] = 1 - $ P ; for ( $ i = 4 ; $ i <= $ N ; ++ $ i ) $ dp [ $ i ] = ( $ P ) * $ dp [ $ i - 2 ] + ( 1 - $ P ) * $ dp [ $ i - 3 ] ; return $ dp [ $ N ] ; } $ n = 5 ; $ p = 0.2 ; echo find_prob ( $ n , $ p ) ; ? >"}
{"text": "Segitiga Hosoya | Program PHP untuk mencetak segitiga ketinggian Hosoya n. ; Cetak segitiga Hosoya ketinggian n. ; Kes asas. ; Untuk setiap baris. ; untuk setiap lajur; ; langkah rekursif. ; Mencetak penyelesaian; Program yang didorong", "code": "< ? php $ N = 5 ; function printHosoya ( $ n ) { global $ N ; $ dp = array_fill ( 0 , $ N , array_fill ( 0 , $ N , 0 ) ) ; $ dp [ 0 ] [ 0 ] = $ dp [ 1 ] [ 0 ] = $ dp [ 1 ] [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i > $ j ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 2 ] [ $ j ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j - 1 ] + $ dp [ $ i - 2 ] [ $ j - 2 ] ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) echo $ dp [ $ i ] [ $ j ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } } $ n = 5 ; printHosoya ( $ n ) ; ? >"}
{"text": "Cara yang berbeza untuk jumlah n menggunakan nombor yang lebih besar daripada atau sama dengan m | Program PHP untuk mencari bilangan cara yang nombor yang lebih besar daripada nombor yang diberikan boleh ditambah untuk mendapatkan jumlah. ; Pulangan bilangan cara yang mana nombor yang lebih besar daripada nombor yang diberikan boleh ditambah untuk mendapatkan jumlah. ; Mengisi meja. K adalah untuk nombor yang lebih besar daripada atau sama yang dibenarkan. ; Saya adalah untuk jumlah; memulakan dp [i] [k] kepada nombor cara untuk mendapatkan jumlah menggunakan nombor yang lebih besar daripada atau sama k + 1; jika saya> k; Program Pemandu", "code": "< ? php $ MAX = 100 ; function numberofways ( $ n , $ m ) { global $ MAX ; $ dp = array_fill ( 0 , $ n + 2 , array_fill ( 0 , $ n + 2 , NULL ) ) ; $ dp [ 0 ] [ $ n + 1 ] = 1 ; for ( $ k = $ n ; $ k >= $ m ; $ k -- ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] [ $ k ] = $ dp [ $ i ] [ $ k + 1 ] ; if ( $ i - $ k >= 0 ) $ dp [ $ i ] [ $ k ] = ( $ dp [ $ i ] [ $ k ] + $ dp [ $ i - $ k ] [ $ k ] ) ; } } return $ dp [ $ n ] [ $ m ] ; } $ n = 3 ; $ m = 1 ; echo numberofways ( $ n , $ m ) ; return 0 ; ? >"}
{"text": "Nombor entringer | Kembali nombor entringer E (n, k); Kes asas; Kes asas; Langkah rekursif; Kod yang didorong", "code": "< ? php function zigzag ( $ n , $ k ) { if ( $ n == 0 and $ k == 0 ) return 1 ; if ( $ k == 0 ) return 0 ; return zigzag ( $ n , $ k - 1 ) + zigzag ( $ n - 1 , $ n - $ k ) ; } $ n = 4 ; $ k = 3 ; echo zigzag ( $ n , $ k ) ; ? >"}
{"text": "Nombor Eulerian | Kembali eulerianNumber a (n, m); Untuk setiap baris dari 1 hingga n; Untuk setiap lajur dari 0 hingga m; Jika saya lebih besar daripada j; Jika J adalah 0, maka buat keadaan itu sebagai 1 .; hubungan pengulangan asas. ; Kod pemacu", "code": "< ? php function eulerian ( $ n , $ m ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ m + 1 ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) { if ( $ i > $ j ) { if ( $ j == 0 ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = ( ( $ i - $ j ) * $ dp [ $ i - 1 ] [ $ j - 1 ] ) + ( ( $ j + 1 ) * $ dp [ $ i - 1 ] [ $ j ] ) ; } } } return $ dp [ $ n ] [ $ m ] ; } $ n = 3 ; $ m = 1 ; echo eulerian ( $ n , $ m ) ; ? >"}
{"text": "Nombor Delannoy | Kembalikan nombor delannoy n. ; Kes asas; Langkah rekursif. ; Kod pemacu", "code": "< ? php function dealnnoy ( $ n , $ m ) { if ( $ m == 0 or $ n == 0 ) return 1 ; return dealnnoy ( $ m - 1 , $ n ) + dealnnoy ( $ m - 1 , $ n - 1 ) + dealnnoy ( $ m , $ n - 1 ) ; } $ n = 3 ; $ m = 4 ; echo dealnnoy ( $ n , $ m ) ; ? >"}
{"text": "Nombor Delannoy | Kembalikan nombor delannoy n. ; Kes asas; Kod yang didorong", "code": "< ? php function dealnnoy ( $ n , $ m ) { $ dp [ $ m + 1 ] [ $ n + 1 ] = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j - 1 ] + $ dp [ $ i ] [ $ j - 1 ] ; return $ dp [ $ m ] [ $ n ] ; } $ n = 3 ; $ m = 4 ; echo dealnnoy ( $ n , $ m ) ; ? >"}
{"text": "Subarray berselang (positif dan negatif) yang paling lama bermula pada setiap indeks | Program PHP untuk mencari subarray berganti terpanjang bermula dari setiap indeks. ; Isi kiraan [] dari akhir. ; Hasil cetak; Kod pemacu", "code": "< ? php function longestAlternating ( $ arr , $ n ) { $ count = array ( ) ; $ count [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] * $ arr [ $ i + 1 ] < 0 ) $ count [ $ i ] = $ count [ $ i + 1 ] + 1 ; else $ count [ $ i ] = 1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ count [ $ i ] , \" ▁ \" ; } $ a = array ( -5 , -1 , -1 , 2 , -2 , -3 ) ; $ n = count ( $ a ) ; longestAlternating ( $ a , $ n ) ; ? >"}
{"text": "Nilai maksimum dengan pilihan sama ada membahagikan atau mempertimbangkan kerana ia | fungsi untuk mengira hasil maksimum yang mungkin; Hitung nilai yang tersisa dengan cara bawah. ; Kod pemacu", "code": "< ? php function maxDP ( $ n ) { $ res [ 0 ] = 0 ; $ res [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res [ $ i ] = max ( $ i , ( $ res [ $ i / 2 ] + $ res [ $ i / 3 ] + $ res [ $ i / 4 ] + $ res [ $ i / 5 ] ) ) ; return $ res [ $ n ] ; } $ n = 60 ; echo \" MaxSum = \" ? >"}
{"text": "Minimum melompat untuk mencapai bangunan terakhir dalam matriks | Program PHP Rekursif untuk mencari lompatan minimum untuk mencapai bangunan terakhir dari pertama. ; Mengembalikan laluan lompat minimum dari (0, 0) hingga (m, n) ketinggian [r] [c]; Kes asas; Cari lompat minimum jika kita melalui pepenjuru; Cari lompat minimum jika kita pergi ke bawah; Cari lompatan minimum jika kita pergi ke kanan; mengembalikan lompatan minimum; Kod pemacu", "code": "< ? php $ R = 4 ; $ C = 3 ; function isSafe ( $ x , $ y ) { global $ R , $ C ; return ( $ x < $ R and $ y < $ C ) ; } function minJump ( $ height , $ x , $ y ) { global $ R , $ C ; if ( $ x == $ R - 1 and $ y == $ C - 1 ) return 0 ; $ diag = PHP_INT_MAX ; if ( isSafe ( $ x + 1 , $ y + 1 ) ) $ diag = minJump ( $ height , $ x + 1 , $ y + 1 ) + abs ( $ height [ $ x ] [ $ y ] - $ height [ $ x + 1 ] [ $ y + 1 ] ) ; $ down = PHP_INT_MAX ; if ( isSafe ( $ x + 1 , $ y ) ) $ down = minJump ( $ height , $ x + 1 , $ y ) + abs ( $ height [ $ x ] [ $ y ] - $ height [ $ x + 1 ] [ $ y ] ) ; $ right = PHP_INT_MAX ; if ( isSafe ( $ x , $ y + 1 ) ) $ right = minJump ( $ height , $ x , $ y + 1 ) + abs ( $ height [ $ x ] [ $ y ] - $ height [ $ x ] [ $ y + 1 ] ) ; return min ( $ down , min ( $ right , $ diag ) ) ; } $ height = array ( array ( 5 , 4 , 2 ) , array ( 9 , 2 , 1 ) , array ( 2 , 5 , 9 ) , array ( 1 , 3 , 11 ) ) ; echo minJump ( $ height , 0 , 0 ) ; ? >"}
{"text": "Jumlah maksimum berikutnya dengan AT | Program PHP untuk mencari jumlah maksimum berikutnya sehingga unsur -unsur sekurang -kurangnya K jarak jauh. ; Kami mengisi MS dari kanan ke kiri. ; Kod pemacu", "code": "< ? php function maxSum ( $ arr , $ N , $ k ) { $ MS [ $ N - 1 ] = $ arr [ $ N - 1 ] ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { if ( $ i + $ k + 1 >= $ N ) $ MS [ $ i ] = max ( $ arr [ $ i ] , $ MS [ $ i + 1 ] ) ; else $ MS [ $ i ] = max ( $ arr [ $ i ] + $ MS [ $ i + $ k + 1 ] , $ MS [ $ i + 1 ] ) ; } return $ MS [ 0 ] ; } $ N = 10 ; $ k = 2 ; $ arr = array ( 50 , 70 , 40 , 50 , 90 , 70 , 60 , 40 , 70 , 50 ) ; echo ( maxSum ( $ arr , $ N , $ k ) ) ; ? >"}
{"text": "Sub Alternating terpanjang | Berfungsi untuk mengira sub -sulung sub -array untuk setiap indeks elemen array; Memulakan keadaan asas Len []; Mengira nilai untuk setiap elemen; Jika kedua -dua elemen adalah berbeza maka tambah 1 ke Len seterusnya [i + 1]; lain yang dimulakan ke 1; Panjang cetak subarray binari. ; Kod pemacu", "code": "< ? php function alternateSubarray ( & $ arr , $ n ) { $ len = array_fill ( 0 , $ n , NULL ) ; $ len [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; -- $ i ) { if ( $ arr [ $ i ] ^ $ arr [ $ i + 1 ] == 1 ) $ len [ $ i ] = $ len [ $ i + 1 ] + 1 ; else $ len [ $ i ] = 1 ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) echo $ len [ $ i ] . \" ▁ \" ; } $ arr = array ( 1 , 0 , 1 , 0 , 0 , 1 ) ; $ n = sizeof ( $ arr ) ; alternateSubarray ( $ arr , $ n ) ; ? >"}
{"text": "Sub Alternating terpanjang | Berfungsi untuk mengira sub -sulung sub -array untuk setiap indeks elemen array; Memulakan pembolehubah kiraan untuk menyimpan panjang sub -array; Inisialisasi 'Prev' Variable yang menunjukkan elemen sebelumnya semasa melintasi indeks 'i'; Jika kedua -dua elemen adalah elemen cetak yang sama kerana elemen alternatif tidak dijumpai untuk indeks semasa; Cetak kiraan dan pengurangannya. ; Kiraan kenaikan untuk elemen seterusnya; Re - memulakan pembolehubah sebelumnya; Jika unsur -unsur masih tersedia selepas melintasi keseluruhan, cetaknya; Kod pemacu", "code": "< ? php function alternateSubarray ( $ arr , $ n ) { $ count = 1 ; $ prev = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) { if ( ( $ arr [ $ i ] ^ $ prev ) == 0 ) { while ( $ count ) echo $ count -- , \" ▁ \" ; } ++ $ count ; $ prev = $ arr [ $ i ] ; } while ( $ count ) echo $ count -- , \" ▁ \" ; } $ arr = array ( 1 , 0 , 1 , 0 , 0 , 1 ) ; $ n = sizeof ( $ arr ) ; alternateSubarray ( $ arr , $ n ) ; ? >"}
{"text": "Kira cara untuk membina jalan di bawah kekangan yang diberikan | berfungsi untuk mengira cara membina jalan baris N; Kes asas; cara membina rumah di kedua -dua tempat baris ith; cara membina pejabat di salah satu daripada dua tempat ITH Row; Jumlah cara untuk baris N; Kod pemacu", "code": "< ? php function countWays ( $ n ) { $ dp [ 0 ] [ 1 ] = 1 ; $ dp [ 1 ] [ 1 ] = 2 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ 0 ] [ $ i ] = $ dp [ 0 ] [ $ i - 1 ] + $ dp [ 1 ] [ $ i - 1 ] ; $ dp [ 1 ] [ $ i ] = $ dp [ 0 ] [ $ i - 1 ] * 2 + $ dp [ 1 ] [ $ i - 1 ] ; } return $ dp [ 0 ] [ $ n ] + $ dp [ 1 ] [ $ n ] ; } $ n = 5 ; echo \" Total ▁ no ▁ of ▁ ways ▁ with ▁ n ▁ = ▁ \" , $ n , \" ▁ are : ▁ \" , countWays ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Panjang maksimum berikutnya dengan perbezaan antara unsur -unsur bersebelahan sama ada 0 atau 1 | berfungsi untuk mencari panjang maksimum selepas perbezaan antara unsur -unsur bersebelahan sama ada 0 atau 1; Memulakan nilai MLS [] untuk semua indeks; Mengira nilai -nilai berikutnya yang dioptimumkan dengan panjang di bawah; Simpan maksimum semua nilai 'mls' dalam 'max'; yang diperlukan panjang maksimum; Kod pemacu", "code": "< ? php function maxLenSub ( $ arr , $ n ) { $ mls = array ( ) ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mls [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) <= 1 and $ mls [ $ i ] < $ mls [ $ j ] + 1 ) $ mls [ $ i ] = $ mls [ $ j ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ mls [ $ i ] ) $ max = $ mls [ $ i ] ; return $ max ; } $ arr = array ( 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ) ; $ n = count ( $ arr ) ; echo \" Maximum ▁ length ▁ subsequence ▁ = ▁ \" , maxLenSub ( $ arr , $ n ) ; ? >"}
{"text": "Pemenang permainan duit syiling di mana setiap pemain mempunyai tiga pilihan | Untuk mencari pemenang permainan; Untuk menyimpan hasil; Nilai awal; Pengkomputeran nilai lain. ; Sekiranya kerugian mana -mana permainan i - 1 atau i - x atau i - y maka dia pasti akan memenangi permainan i; Lain yang kehilangan permainan. ; Jika dp [n] adalah benar maka permainan akan jika dia kehilangan; Program pemandu untuk menguji FindWinner ();", "code": "< ? php function findWinner ( $ x , $ y , $ n ) { $ dp = array ( ) ; $ dp [ 0 ] = false ; $ dp [ 1 ] = true ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i - 1 >= 0 and ! $ dp [ $ i - 1 ] ) $ dp [ $ i ] = true ; else if ( $ i - $ x >= 0 and ! $ dp [ $ i - $ x ] ) $ dp [ $ i ] = true ; else if ( $ i - $ y >= 0 and ! $ dp [ $ i - $ y ] ) $ dp [ $ i ] = true ; else $ dp [ $ i ] = false ; } return $ dp [ $ n ] ; } $ x = 3 ; $ y = 4 ; $ n = 5 ; if ( findWinner ( $ x , $ y , $ n ) ) echo ' A ' ; else echo ' B ' ; ? >"}
{"text": "Permainan maksimum yang dimainkan oleh pemenang | Kaedah Mengembalikan Permainan Maksimum Pemenang perlu bermain dalam kejohanan pemain N; Untuk 0 permainan, 1 pemain diperlukan untuk 1 permainan, 2 pemain diperlukan; gelung sehingga nombor fibonacci saya kurang daripada atau sama dengan n; Keputusan adalah (i - 2) kerana saya akan bertambah satu tambahan dalam gelung dan kami mahu nilai terakhir yang lebih kecil daripada n, jadi satu lagi penurunan; Kod pemacu", "code": "< ? php function maxGameByWinner ( $ N ) { $ dp [ $ N ] = 0 ; $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 2 ; $ i = 2 ; do { $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] ; } while ( $ dp [ $ i ++ ] <= $ N ) ; return ( $ i - 2 ) ; } $ N = 10 ; echo maxGameByWinner ( $ N ) ; ? >"}
{"text": "Tukar untuk meningkatkan array integer dengan ketat dengan perubahan minimum | Untuk mencari elemen min untuk mengeluarkan dari array untuk menjadikannya semakin meningkat; Tandakan semua elemen LIS sebagai 1; Cari lis array; Kembali min perubahan untuk array untuk meningkatkan ketat; Kod pemacu", "code": "< ? php function minRemove ( $ arr , $ n ) { $ LIS = array ( ) ; $ len = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ LIS [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ LIS [ $ i ] = max ( $ LIS [ $ i ] , $ LIS [ $ j ] + 1 ) ; } $ len = max ( $ len , $ LIS [ $ i ] ) ; } return $ n - $ len ; } $ arr = array ( 1 , 2 , 6 , 5 , 4 ) ; $ n = count ( $ arr ) ; echo minRemove ( $ arr , $ n ) ; ? >"}
{"text": "Cari Panjang Susunan Terpanjang Satu Rentetan yang Substring Rentetan Lain | Kembalikan saiz maksimum substring x yang substring dalam y. ; Memulakan DP [] [] hingga 0 .; Mengira nilai untuk setiap elemen. ; Jika abjad rentetan x dan y sama membuat dp [i] [j] = 1 + dp [i - 1] [j - 1]; Lain salin nilai sebelumnya dalam baris i. e dp [i - 1] [j - 1]; Mencari panjang maksimum. ; Kod pemacu", "code": "< ? php function maxSubsequenceSubstring ( $ x , $ y , $ n , $ m ) { $ dp ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ x [ $ j - 1 ] == $ y [ $ i - 1 ] ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i ] [ $ j - 1 ] ; } } $ ans = 0 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) $ ans = max ( $ ans , $ dp [ $ i ] [ $ n ] ) ; return $ ans ; } { $ x = \" ABCD \" ; $ y = \" BACDBDCD \" ; $ n = strlen ( $ x ) ; $ m = strlen ( $ y ) ; echo maxSubsequenceSubstring ( $ x , $ y , $ n , $ m ) ; return 0 ; } ? >"}
{"text": "Jumlah maksimum dalam grid 2 x N supaya tidak ada dua elemen bersebelahan | Berfungsi untuk mencari jumlah maksimum tanpa bersebelahan; Jumlah termasuk elemen maksimum lajur pertama; Tidak termasuk elemen lajur pertama; Melintasi unsur -unsur selanjutnya; Kemas kini max_sum termasuk atau tidak termasuk lajur sebelumnya; Termasuk lajur semasa. Tambah elemen maksimum dari kedua -dua baris lajur semasa; Jika lajur semasa tidak dimasukkan; Pulangan maksimum excl dan termasuk kerana itu akan menjadi jumlah maksimum; Kod pemacu", "code": "< ? php function maxSum ( $ grid , $ n ) { $ incl = max ( $ grid [ 0 ] [ 0 ] , $ grid [ 1 ] [ 0 ] ) ; $ excl = 0 ; $ excl_new ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ excl_new = max ( $ excl , $ incl ) ; $ incl = $ excl + max ( $ grid [ 0 ] [ $ i ] , $ grid [ 1 ] [ $ i ] ) ; $ excl = $ excl_new ; } return max ( $ excl , $ incl ) ; } $ grid = array ( array ( 1 , 2 , 3 , 4 , 5 ) , array ( 6 , 7 , 8 , 9 , 10 ) ) ; $ n = 5 ; echo maxSum ( $ grid , $ n ) ; ? >"}
{"text": "Sisipan minimum untuk menyusun array | kaedah mengembalikan langkah -langkah penyisipan yang perlu kita lakukan untuk menyusun array 'arr'; lis [i] akan menyimpan panjang lis yang berakhir dengan i. ; Memulakan nilai LIS untuk semua indeks; Kirakan nilai LIS yang dioptimumkan dengan cara bawah; LIS keseluruhan mesti berakhir dengan unsur -unsur array. Pilih maksimum semua nilai LIS; saiz pulangan array tolak panjang LIS sebagai hasil akhir; Kod pemacu", "code": "< ? php function minInsertionStepToSortArray ( $ arr , $ N ) { $ lis [ $ N ] = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] >= $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ max = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ max < $ lis [ $ i ] ) $ max = $ lis [ $ i ] ; return ( $ N - $ max ) ; } $ arr = array ( 2 , 3 , 5 , 1 , 4 , 7 , 6 ) ; $ N = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo minInsertionStepToSortArray ( $ arr , $ N ) ; ? >"}
{"text": "Susat yang paling tidak singkat | Program PHP berasaskan pengaturcaraan yang dinamik untuk mencari berikutnya yang tidak biasa. ; Mengembalikan panjang selaras biasa terpendek; mengisytiharkan pelbagai 2D m + 1 baris dan n + 1 lajur secara dinamik; Rentetan t kosong; Rentetan s kosong; char tidak hadir dalam t; Kod pemacu", "code": "< ? php $ GLOBALS [ ' MAX ' ] = 1005 ; function shortestSeq ( $ S , $ T ) { $ m = strlen ( $ S ) ; $ n = strlen ( $ T ) ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ 0 ] [ $ i ] = $ GLOBALS [ ' MAX ' ] ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { $ ch = $ S [ $ i - 1 ] ; for ( $ k = $ j - 1 ; $ k >= 0 ; $ k -- ) if ( $ T [ $ k ] == $ ch ) break ; if ( $ k == -1 ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i - 1 ] [ $ k ] + 1 ) ; } } $ ans = $ dp [ $ m ] [ $ n ] ; if ( $ ans >= $ GLOBALS [ ' MAX ' ] ) $ ans = -1 ; return $ ans ; } $ S = \" babab \" ; $ T = \" babba \" ; $ m = strlen ( $ S ) ; $ n = strlen ( $ T ) ; echo \" Length ▁ of ▁ shortest ▁ subsequence ▁ is ▁ : ▁ \" , shortestSeq ( $ S , $ T ) ; ? >"}
{"text": "Mengira bilangan cara untuk melompat untuk mencapai akhir | berfungsi untuk mengira cara untuk melompat untuk mencapai hujung untuk setiap elemen array; Count_jump [i] menyimpan bilangan cara arr [i] boleh sampai ke akhir; Unsur terakhir tidak memerlukan untuk melompat. Mengira cara untuk melompat untuk elemen yang tinggal; Jika elemen boleh terus melompat ke hujungnya; Tambah kiraan semua elemen yang boleh dicapai untuk berakhir dan arr [i] boleh sampai kepada mereka; Jika elemen boleh sampai ke akhir kemudian tambahkan kiraannya ke count_jump [i]; jika arr [i] tidak dapat sampai ke akhir; cetak count_jump untuk setiap elemen array; Kod pemacu", "code": "< ? php function countWaysToJump ( $ arr , $ n ) { $ count_jump ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count_jump [ $ i ] = 0 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] >= $ n - $ i - 1 ) $ count_jump [ $ i ] ++ ; for ( $ j = $ i + 1 ; $ j < $ n - 1 && $ j <= $ arr [ $ i ] + $ i ; $ j ++ ) if ( $ count_jump [ $ j ] != -1 ) $ count_jump [ $ i ] += $ count_jump [ $ j ] ; if ( $ count_jump [ $ i ] == 0 ) $ count_jump [ $ i ] = -1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ count_jump [ $ i ] . \" ▁ \" ; } $ arr = array ( 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 ) ; $ n = count ( $ arr ) ; countWaysToJump ( $ arr , $ n ) ; ? >"}
{"text": "Langkah Minimum Untuk Menghapus Rentetan Selepas Penghapusan Berulang Substrings Palindrome | kaedah mengembalikan langkah minimum untuk memadam rentetan, di mana dalam satu langkah palindrome dikeluarkan; mengisytiharkan array DP dan memulakannya dengan 0 s; Gelung untuk panjang substring yang kita sedang mempertimbangkan; gelung dengan dua pembolehubah I dan J, menandakan permulaan dan menamatkan substring; Jika panjang substring adalah 1, maka 1 langkah akan diperlukan; Padam char ith secara individu dan berikan hasil untuk subproblem (i + 1, j); Jika char semasa dan seterusnya adalah sama, pilih min dari semasa dan subproblem (i + 2, j); gelung ke atas semua watak yang betul dan anggap kth char adalah sama dengan watak ith kemudian pilih minimum dari arus dan dua substring selepas mengabaikan ith dan kth char; Uncomment di bawah coretan untuk mencetak meja dp sebenar untuk (int i = 0; i <n; i ++, cout << endl) untuk (int j = 0; j <n; j ++) cout << dp [i] [j] << \"\" ; Kod pemacu", "code": "< ? php function minStepToDeleteString ( $ str ) { $ N = strlen ( $ str ) ; $ dp [ $ N + 1 ] [ $ N + 1 ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) for ( $ j = 0 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ len = 1 ; $ len <= $ N ; $ len ++ ) { for ( $ i = 0 , $ j = $ len - 1 ; $ j < $ N ; $ i ++ , $ j ++ ) { if ( $ len == 1 ) $ dp [ $ i ] [ $ j ] = 1 ; else { $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i + 1 ] [ $ j ] ; if ( $ str [ $ i ] == $ str [ $ i + 1 ] ) $ dp [ $ i ] [ $ j ] = min ( 1 + $ dp [ $ i + 2 ] [ $ j ] , $ dp [ $ i ] [ $ j ] ) ; for ( $ K = $ i + 2 ; $ K <= $ j ; $ K ++ ) if ( $ str [ $ i ] == $ str [ $ K ] ) $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i + 1 ] [ $ K - 1 ] + $ dp [ $ K + 1 ] [ $ j ] , $ dp [ $ i ] [ $ j ] ) ; } } } return $ dp [ 0 ] [ $ N - 1 ] ; } $ str = \"2553432\" ; echo minStepToDeleteString ( $ str ) , \" STRNEWLINE \" ; ? >"}
{"text": "Clustering / partitioning array sedemikian rupa sehingga jumlah perbezaan persegi adalah minimum | Inisialisasi jawapan sebagai tak terhingga. ; berfungsi untuk menghasilkan semua jawapan yang mungkin. dan mengira minimum semua kos. i -> adalah indeks partition sebelumnya par -> adalah bilangan partition semasa a [] dan n -> array input dan saiz current_ans -> kos partition yang dibuat setakat ini. ; Jika bilangan partition lebih daripada k; Sekiranya kita mempunyai partisi Mad K dan telah mencapai elemen terakhir; 1) array partition pada titik yang berbeza 2) Untuk setiap titik, tingkatkan kiraan partition, \"par\" oleh 1.3) Sebelum panggilan rekursif, tambah kos partition kepada current_ans; Kod pemacu", "code": "< ? php $ inf = 1000000000 ; $ ans = $ inf ; function solve ( $ i , $ par , & $ a , $ n , $ k , $ current_ans ) { global $ inf , $ ans ; if ( $ par > $ k ) return ; if ( $ par == $ k && $ i == $ n - 1 ) { $ ans = min ( $ ans , $ current_ans ) ; return ; } for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) solve ( $ j , $ par + 1 , $ a , $ n , $ k , $ current_ans + ( $ a [ $ j ] - $ a [ $ i + 1 ] ) * ( $ a [ $ j ] - $ a [ $ i + 1 ] ) ) ; } $ k = 2 ; $ a = array ( 1 , 5 , 8 , 10 ) ; $ n = sizeof ( $ a ) ; solve ( -1 , 0 , $ a , $ n , $ k , 0 ) ; echo $ ans . \" STRNEWLINE \" ; ? >"}
{"text": "Langkah minimum untuk meminimumkan n seperti keadaan yang diberikan | fungsi untuk mengira langkah min; Kes asas; Simpan nilai temp untuk n sebagai min (f (n - 1), f (n / 2), f (n / 3)) + 1; Simpan memo [n] dan kembali; Fungsi ini terutamanya memulakan memo [] dan memanggil getMinsteps (n, memo); memulakan array Memoized; Kod pemacu", "code": "< ? php function getMinSteps ( $ n , $ memo ) { if ( $ n == 1 ) return 0 ; if ( $ memo [ $ n ] != -1 ) return $ memo [ $ n ] ; $ res = getMinSteps ( $ n - 1 , $ memo ) ; if ( $ n % 2 == 0 ) $ res = min ( $ res , getMinSteps ( $ n / 2 , $ memo ) ) ; if ( $ n % 3 == 0 ) $ res = min ( $ res , getMinSteps ( $ n / 3 , $ memo ) ) ; $ memo [ $ n ] = 1 + $ res ; return $ memo [ $ n ] ; } function g_etMinSteps ( $ n ) { $ memo = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ memo [ $ i ] = -1 ; return getMinSteps ( $ n , $ memo ) ; } $ n = 10 ; echo g_etMinSteps ( $ n ) ; ? >"}
{"text": "Rentetan panjang terkecil dengan penggantian berulang dua bersebelahan yang berbeza | Mengembalikan panjang yang paling kecil dengan operasi yang dibenarkan. ; Counint kejadian tiga aksara yang berbeza 'A', 'B' dan 'C' dalam Str; Sekiranya semua aksara sama. ; Jika semua watak hadir walaupun bilangan kali atau semua adalah bilangan kali ganjil. ; Jawapan adalah 1 untuk semua kes lain. ; Kod pemacu", "code": "< ? php function stringReduction ( $ str ) { $ n = strlen ( $ str ) ; $ count = array_fill ( 0 , 3 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ count [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; if ( $ count [ 0 ] == $ n $ count [ 1 ] == $ n $ count [ 2 ] == $ n ) return $ n ; if ( ( $ count [ 0 ] % 2 ) == ( $ count [ 1 ] % 2 ) && ( $ count [ 1 ] % 2 ) == ( $ count [ 2 ] % 2 ) ) return 2 ; return 1 ; } $ str = \" abcbbaacb \" ; print ( stringReduction ( $ str ) ) ; ? >"}
{"text": "Bilangan berikutnya bentuk A ^ i b ^ j c ^ k | Mengembalikan kiraan berikutnya bentuk A ^ i B ^ J C ^ K; Memulakan tuduhan yang berlainan yang disebabkan oleh kombinasi 'A' yang berlainan; Memulakan tuduhan yang berlainan yang disebabkan oleh kombinasi yang berbeza dari 'A' dan gabungan yang berbeza dari 'B'; Mulakan tuduhan yang berlainan yang disebabkan oleh kombinasi yang berbeza dari 'A', 'B' dan 'C'. ; Melintasi semua aksara rentetan yang diberikan; Jika watak semasa adalah 'A', maka terdapat kemungkinan berikut: a) Karakter semasa memulakan berikutnya. b) Karakter semasa adalah sebahagian daripada berikutnya Acount. c) Karakter semasa bukanlah sebahagian daripada berikutnya. ; Jika watak semasa adalah 'B', maka terdapat kemungkinan berikut: a) Watak semasa memulakan berikutnya B 's dengan berikutnya. b) Watak semasa adalah sebahagian daripada BCOUNT. c) Watak semasa bukan sebahagian daripada BCOUNTERS.  ; Jika watak semasa adalah 'c', maka terdapat kemungkinan berikut: a) Watak semasa memulakan berikutnya C 's dengan BCount berikutnya. b) Watak semasa adalah sebahagian daripada CCount berikutnya. c) Watak semasa bukan sebahagian daripada CCount berikutnya.  ; Kod pemacu", "code": "< ? php function countSubsequences ( $ s ) { $ aCount = 0 ; $ bCount = 0 ; $ cCount = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' ) $ aCount = ( 1 + 2 * $ aCount ) ; else if ( $ s [ $ i ] == ' b ' ) $ bCount = ( $ aCount + 2 * $ bCount ) ; else if ( $ s [ $ i ] == ' c ' ) $ cCount = ( $ bCount + 2 * $ cCount ) ; } return $ cCount ; } $ s = \" abbc \" ; echo countSubsequences ( $ s ) ; ? >"}
{"text": "Masalah papan iklan lebuh raya | Program PHP untuk mencari pendapatan maksimum dengan meletakkan Billboard di lebuh raya dengan kekangan yang diberikan. ; Array untuk menyimpan pendapatan maksimum pada setiap batu. ; Jarak minimum sebenar antara 2 papan iklan. ; Semak sama ada semua papan iklan sudah diletakkan. ; Semak jika kami mempunyai Billboard untuk batu tertentu itu. Jika tidak, salin pendapatan maksimum sebelumnya. ; Kami mempunyai papan iklan untuk batu ini. ; Jika kedudukan semasa kurang daripada atau sama dengan T, maka kita hanya boleh mempunyai satu papan iklan. ; Lain -lain kita mungkin perlu mengeluarkan papan iklan yang diletakkan sebelum ini; Kod pemacu", "code": "< ? php function maxRevenue ( $ m , $ x , $ revenue , $ n , $ t ) { $ maxRev = array_fill ( 0 , $ m + 1 , false ) ; $ nxtbb = 0 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { if ( $ nxtbb < $ n ) { if ( $ x [ $ nxtbb ] != $ i ) $ maxRev [ $ i ] = $ maxRev [ $ i - 1 ] ; else { if ( $ i <= $ t ) $ maxRev [ $ i ] = max ( $ maxRev [ $ i - 1 ] , $ revenue [ $ nxtbb ] ) ; else $ maxRev [ $ i ] = max ( $ maxRev [ $ i - $ t - 1 ] + $ revenue [ $ nxtbb ] , $ maxRev [ $ i - 1 ] ) ; $ nxtbb ++ ; } } else $ maxRev [ $ i ] = $ maxRev [ $ i - 1 ] ; } return $ maxRev [ $ m ] ; } $ m = 20 ; $ x = array ( 6 , 7 , 12 , 13 , 14 ) ; $ revenue = array ( 5 , 6 , 5 , 3 , 1 ) ; $ n = sizeof ( $ x ) ; $ t = 5 ; echo maxRevenue ( $ m , $ x , $ revenue , $ n , $ t ) ; ? >"}
{"text": "Mencari sub persegi maksimum | Program Java untuk mencari maksimum k sedemikian rupa sehingga k x k adalah submatrix dengan elemen yang sama. ; Mengembalikan saiz sub - matriks persegi terbesar dengan semua elemen yang sama. ; Jika unsur berada di baris atas atau lajur pertama, ia tidak akan membentuk hak bawah matriks persegi; Semak jika elemen bersebelahan adalah sama; Jika tidak sama, maka ia akan membentuk submatrix 1 x1; Keputusan kemas kini pada setiap (i, j); Kod pemacu", "code": "< ? php $ Row = 6 ; $ Col = 6 ; function largestKSubmatrix ( & $ a ) { global $ Row , $ Col ; $ result = 0 ; for ( $ i = 0 ; $ i < $ Row ; $ i ++ ) { for ( $ j = 0 ; $ j < $ Col ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ dp [ $ i ] [ $ j ] = 1 ; else { if ( $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j ] && $ a [ $ i ] [ $ j ] == $ a [ $ i ] [ $ j - 1 ] && $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = min ( min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) , $ dp [ $ i - 1 ] [ $ j - 1 ] ) + 1 ; else $ dp [ $ i ] [ $ j ] = 1 ; } $ result = max ( $ result , $ dp [ $ i ] [ $ j ] ) ; } } return $ result ; } $ a = array ( array ( 2 , 2 , 3 , 3 , 4 , 4 ) , array ( 5 , 5 , 7 , 7 , 7 , 4 ) , array ( 1 , 2 , 7 , 7 , 7 , 4 ) , array ( 4 , 4 , 7 , 7 , 7 , 4 ) , array ( 5 , 5 , 5 , 1 , 2 , 7 ) , array ( 8 , 7 , 9 , 4 , 4 , 4 ) ) ; echo largestKSubmatrix ( $ a ) ; ? >"}
{"text": "Kebarangkalian mendapatkan sekurang -kurangnya k kepala dalam n duit syiling | Pendekatan naif dalam PHP untuk mencari kebarangkalian sekurang -kurangnya kepala K; Mengembalikan kebarangkalian mendapatkan sekurang -kurangnya k kepala di N melemparkan. ; Kebarangkalian mendapatkan tepat saya kepala dari kepala N; Nota: 1 << n = pow (2, n); Pra -proses semua faktorial hanya sehingga 19, kerana selepas itu ia akan melimpah; Kod pemacu; Kebarangkalian mendapatkan 2 kepala daripada 3 syiling; Kebarangkalian mendapatkan 3 kepala daripada 6 syiling; Kebarangkalian mendapatkan 12 kepala daripada 18 syiling", "code": "< ? php $ MAX = 21 ; $ fact = array_fill ( 0 , $ MAX , 0 ) ; function probability ( $ k , $ n ) { global $ fact ; $ ans = 0 ; for ( $ i = $ k ; $ i <= $ n ; ++ $ i ) $ ans += $ fact [ $ n ] / ( $ fact [ $ i ] * $ fact [ $ n - $ i ] ) ; $ ans = $ ans / ( 1 << $ n ) ; return $ ans ; } function precompute ( ) { global $ fact ; $ fact [ 0 ] = $ fact [ 1 ] = 1 ; for ( $ i = 2 ; $ i < 20 ; ++ $ i ) $ fact [ $ i ] = $ fact [ $ i - 1 ] * $ i ; } precompute ( ) ; echo number_format ( probability ( 2 , 3 ) , 6 ) . \" STRNEWLINE \" ; echo number_format ( probability ( 3 , 6 ) , 6 ) . \" STRNEWLINE \" ; echo number_format ( probability ( 12 , 18 ) , 6 ) ; ? >"}
{"text": "Kira rentetan binari dengan k kali yang muncul bersebelahan dua set bit | Program PHP untuk mengira bilangan rentetan binari dengan k kali yang muncul berturut -turut 1. ; dp [i] [j] [0] Kedai kiraan rentetan binari panjang i dengan J berturut -turut 1 's dan ujung u on ». '' [1] [1] [1] »'mengira»' 'u u u u u u u u' Jika n = 1 dan k = 0 .; bilangan 1 yang bersebelahan tidak boleh melebihi I-1; Kod pemacu", "code": "< ? php function countStrings ( $ n , $ k ) { $ dp = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ k + 1 , array_fill ( 0 , 2 , 0 ) ) ) ; $ dp [ 1 ] [ 0 ] [ 0 ] = 1 ; $ dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( isset ( $ dp [ $ i ] [ $ j ] [ 0 ] ) || isset ( $ dp [ $ i ] [ $ j ] [ 1 ] ) ) { $ dp [ $ i ] [ $ j ] [ 0 ] = $ dp [ $ i - 1 ] [ $ j ] [ 0 ] + $ dp [ $ i - 1 ] [ $ j ] [ 1 ] ; $ dp [ $ i ] [ $ j ] [ 1 ] = $ dp [ $ i - 1 ] [ $ j ] [ 0 ] ; } if ( $ j - 1 >= 0 && isset ( $ dp [ $ i ] [ $ j ] [ 1 ] ) ) $ dp [ $ i ] [ $ j ] [ 1 ] += $ dp [ $ i - 1 ] [ $ j - 1 ] [ 1 ] ; } } return $ dp [ $ n ] [ $ k ] [ 0 ] + $ dp [ $ n ] [ $ k ] [ 1 ] ; } $ n = 5 ; $ k = 2 ; echo countStrings ( $ n , $ k ) ; ? >"}
{"text": "Masalah Pasangan Kawan | Mengembalikan kiraan cara n orang boleh kekal bujang atau dipasangkan. ; Kod pemacu", "code": "< ? php function countFriendsPairings ( $ n ) { $ dp = array_fill ( 0 , 1000 , -1 ) ; if ( $ dp [ $ n ] != -1 ) return $ dp [ $ n ] ; if ( $ n > 2 ) { $ dp [ $ n ] = countFriendsPairings ( $ n - 1 ) + ( $ n - 1 ) * countFriendsPairings ( $ n - 2 ) ; return $ dp [ $ n ] ; } else { $ dp [ $ n ] = $ n ; return $ dp [ $ n ] ; } } $ n = 4 ; echo countFriendsPairings ( $ n ) ? >"}
{"text": "Jumlah laluan maksimum dalam segitiga. | Fungsi untuk mencari jumlah maksimum; gelung untuk pengiraan bawah; Bagi setiap elemen, periksa kedua -dua elemen di bawah nombor dan di bawah kanan ke nombor tambah maksimumnya; mengembalikan elemen teratas yang menyimpan jumlah maksimum; Kod pemacu", "code": "< ? php function maxPathSum ( $ tri , $ m , $ n ) { for ( $ i = $ m - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { if ( $ tri [ $ i + 1 ] [ $ j ] > $ tri [ $ i + 1 ] [ $ j + 1 ] ) $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j ] ; else $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j + 1 ] ; } } return $ tri [ 0 ] [ 0 ] ; } $ tri = array ( array ( 1 , 0 , 0 ) , array ( 4 , 8 , 0 ) , array ( 1 , 5 , 3 ) ) ; echo maxPathSum ( $ tri , 2 , 2 ) ; ? >"}
{"text": "LCS (selaras biasa terpanjang) dari tiga rentetan | Program PHP untuk mencari LC dari tiga rentetan; Mengembalikan panjang LCS untuk x [0 .. m - 1], y [0 .. n - 1] dan z [0 .. o - 1]; Kod pemacu", "code": "< ? php $ X = \" AGGT12\" ; $ Y = \"12TXAYB \" ; $ Z = \"12XBA \" ; $ dp = array_fill ( 0 , 100 , array_fill ( 0 , 100 , array_fill ( 0 , 100 , -1 ) ) ) ; function lcsOf3 ( $ i , $ j , $ k ) { global $ dp , $ X , $ Y , $ Z ; if ( $ i == -1 $ j == -1 $ k == -1 ) return 0 ; if ( $ dp [ $ i ] [ $ j ] [ $ k ] != -1 ) return $ dp [ $ i ] [ $ j ] [ $ k ] ; if ( $ X [ $ i ] == $ Y [ $ j ] && $ Y [ $ j ] == $ Z [ $ k ] ) return $ dp [ $ i ] [ $ j ] [ $ k ] = 1 + lcsOf3 ( $ i - 1 , $ j - 1 , $ k - 1 ) ; else return $ dp [ $ i ] [ $ j ] [ $ k ] = max ( max ( lcsOf3 ( $ i - 1 , $ j , $ k ) , lcsOf3 ( $ i , $ j - 1 , $ k ) ) , lcsOf3 ( $ i , $ j , $ k - 1 ) ) ; } $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ o = strlen ( $ Z ) ; echo \" Length ▁ of ▁ LCS ▁ is ▁ \" . lcsOf3 ( $ m - 1 , $ n - 1 , $ o - 1 ) ; ? >"}
{"text": "Mengira bilangan cara untuk mencapai destinasi dalam labirin | Program PHP untuk mengira bilangan laluan dalam labirin dengan halangan. ; Mengembalikan kiraan laluan yang mungkin dalam labirin [r] [c] dari (0, 0) hingga (r - 1, c - 1); Jika sel awal disekat, tidak ada cara untuk bergerak di mana -mana sahaja; Memulakan lajur paling kiri; Sekiranya kita menghadapi sel yang disekat di barisan kiri, tidak ada cara untuk melawat mana -mana sel di bawahnya. ; Begitu juga memulakan baris paling atas; Jika kita menghadapi sel yang disekat di Bottommost Row, tidak ada cara untuk melawat mana -mana sel di bawahnya. ; Satu -satunya perbezaan ialah jika sel adalah - 1, hanya mengabaikannya dengan lain -lain mengira nilai kiraan maze [i] [j]; Jika penyumbatan dijumpai, abaikan sel ini; Jika kita dapat mencapai maze [i] [j] dari maze [i - 1] [j] maka kiraan kenaikan. ; Jika kita dapat mencapai maze [i] [j] dari maze [i] [j - 1] maka kiraan kenaikan. ; Jika sel akhir disekat, output 0, jika tidak, jawapannya; Kod pemacu", "code": "< ? php $ R = 4 ; $ C = 4 ; function countPaths ( $ maze ) { global $ R , $ C ; if ( $ maze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { if ( $ maze [ $ i ] [ 0 ] == 0 ) $ maze [ $ i ] [ 0 ] = 1 ; else break ; } for ( $ i = 1 ; $ i < $ C ; $ i ++ ) { if ( $ maze [ 0 ] [ $ i ] == 0 ) $ maze [ 0 ] [ $ i ] = 1 ; else break ; } for ( $ i = 1 ; $ i < $ R ; $ i ++ ) { for ( $ j = 1 ; $ j < $ C ; $ j ++ ) { if ( $ maze [ $ i ] [ $ j ] == -1 ) continue ; if ( $ maze [ $ i - 1 ] [ $ j ] > 0 ) $ maze [ $ i ] [ $ j ] = ( $ maze [ $ i ] [ $ j ] + $ maze [ $ i - 1 ] [ $ j ] ) ; if ( $ maze [ $ i ] [ $ j - 1 ] > 0 ) $ maze [ $ i ] [ $ j ] = ( $ maze [ $ i ] [ $ j ] + $ maze [ $ i ] [ $ j - 1 ] ) ; } } return ( $ maze [ $ R - 1 ] [ $ C - 1 ] > 0 ) ? $ maze [ $ R - 1 ] [ $ C - 1 ] : 0 ; } $ maze = array ( array ( 0 , 0 , 0 , 0 ) , array ( 0 , -1 , 0 , 0 ) , array ( -1 , 0 , 0 , 0 ) , array ( 0 , 0 , 0 , 0 ) ) ; echo countPaths ( $ maze ) ; ? >"}
{"text": "Laluan nilai perpuluhan maksimum dalam matriks binari | Mengembalikan nilai perpuluhan maksimum dalam matriks binari. Di sini p menunjukkan kuasa 2; Daripada sempadan matriks; Jika nilai matriks semasa adalah 1 maka hasil kembali + kuasa (2, p) hasil lain; Kod pemacu", "code": "< ? php function maxDecimalValue ( $ mat , $ i , $ j , $ p ) { $ N = 4 ; if ( $ i >= $ N $ j >= $ N ) return 0 ; $ result = max ( maxDecimalValue ( $ mat , $ i , $ j + 1 , $ p + 1 ) , maxDecimalValue ( $ mat , $ i + 1 , $ j , $ p + 1 ) ) ; if ( $ mat [ $ i ] [ $ j ] == 1 ) return pow ( 2 , $ p ) + $ result ; else return $ result ; } $ mat = array ( array ( 1 , 1 , 0 , 1 ) , array ( 0 , 1 , 1 , 0 ) , array ( 1 , 0 , 0 , 1 ) , array ( 1 , 0 , 1 , 1 ) ) ; echo maxDecimalValue ( $ mat , 0 , 0 , 0 ) ; ? >"}
{"text": "Kira Semua Palindrome Sub | Mengembalikan jumlah bilangan substring palindrome panjang yang lebih besar kemudian sama dengan 2; Buat matriks kosong 2 - D yang mengira semua substring palindrome. DP [i] [j] menyimpan jumlah substrings palindromic di ST [i. . j]; P [i] [j] = Benar jika substring str [i. . j] adalah palindrome, lain -lain palsu; palindrome panjang tunggal; palindrome panjang 2; Palindromes panjang lebih dari 2. Gelung ini sama dengan pendaraban rantai matriks. Kami mulakan dengan jurang panjang 2 dan mengisi jadual DP dengan cara yang jurang antara permulaan dan indeks mengakhiri meningkatkan satu demi satu dengan gelung luar. ; Pilih titik permulaan untuk jurang semasa; Tetapkan titik akhir; Jika rentetan semasa adalah palindrome; Tambah substring palindrome semasa ( + 1) dan Rest Palindrome substring (dp [i] [j - 1] + dp [i + 1] [j]) keluarkan substrings palindrome biasa ( - dp [i + 1] [j - 1]); mengembalikan jumlah substrings palindromic; Kod pemacu", "code": "< ? php function CountPS ( $ str , $ n ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; $ P = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ P [ $ i ] [ $ j ] = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ P [ $ i ] [ $ i ] = true ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ str [ $ i ] == $ str [ $ i + 1 ] ) { $ P [ $ i ] [ $ i + 1 ] = true ; $ dp [ $ i ] [ $ i + 1 ] = 1 ; } } for ( $ gap = 2 ; $ gap < $ n ; $ gap ++ ) { for ( $ i = 0 ; $ i < $ n - $ gap ; $ i ++ ) { $ j = $ gap + $ i ; if ( $ str [ $ i ] == $ str [ $ j ] && $ P [ $ i + 1 ] [ $ j - 1 ] ) $ P [ $ i ] [ $ j ] = true ; if ( $ P [ $ i ] [ $ j ] == true ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i ] [ $ j - 1 ] + $ dp [ $ i + 1 ] [ $ j ] + 1 - $ dp [ $ i + 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i ] [ $ j - 1 ] + $ dp [ $ i + 1 ] [ $ j ] - $ dp [ $ i + 1 ] [ $ j - 1 ] ; } } return $ dp [ 0 ] [ $ n - 1 ] ; } $ str = \" abaab \" ; $ n = strlen ( $ str ) ; echo CountPS ( $ str , $ n ) ; ? >"}
{"text": "Jumlah berikutnya maksimum supaya tiada tiga berturut -turut | Mengembalikan jumlah berikutnya yang maksimum supaya tiada tiga elemen berturut -turut; Kedai -kedai hasil untuk Subarray Arr [0. Saya], i. e. , jumlah maksimum yang mungkin dalam Subarray Arr [0 .. Saya] supaya tiada tiga elemen berturut -turut $. ; Kes asas (proses tiga elemen pertama); Proses Selebihnya unsur -unsur kita mempunyai tiga kes 1) tidak termasuk arr [i], i. e. , jumlah [i] = jumlah [i - 1] 2) tidak termasuk arr [i - 1], i. e. , jumlah [i] = jumlah [i - 2] + arr [i] 3) tidak termasuk arr [i - 2], i. e. , jumlah [i - 3] + arr [i] + arr [i - 1]; Kod pemacu", "code": "< ? php function maxSumWO3Consec ( $ arr , $ n ) { $ sum = array ( ) ; if ( $ n >= 1 ) $ sum [ 0 ] = $ arr [ 0 ] ; if ( $ n >= 2 ) $ sum [ 1 ] = $ arr [ 0 ] + $ arr [ 1 ] ; if ( $ n > 2 ) $ sum [ 2 ] = max ( $ sum [ 1 ] , max ( $ arr [ 1 ] + $ arr [ 2 ] , $ arr [ 0 ] + $ arr [ 2 ] ) ) ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ sum [ $ i ] = max ( max ( $ sum [ $ i - 1 ] , $ sum [ $ i - 2 ] + $ arr [ $ i ] ) , $ arr [ $ i ] + $ arr [ $ i - 1 ] + $ sum [ $ i - 3 ] ) ; return $ sum [ $ n - 1 ] ; } $ arr = array ( 100 , 1000 , 100 , 1000 , 1 ) ; $ n = count ( $ arr ) ; echo maxSumWO3Consec ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah maksimum pasangan dengan perbezaan tertentu | kaedah untuk mengembalikan jumlah maksimum yang kita dapat dengan mencari pasangan perbezaan kurang; Susun array input dalam urutan menaik. ; DP [i] menandakan jumlah pasangan disjoint maksimum yang dapat kita capai menggunakan unsur -unsur pertama saya; Jika tiada elemen maka nilai DP akan menjadi 0; Pertama berikan nilai sebelumnya kepada DP [i] i. e. tidak berpasangan dengan elemen (i - 1); jika elemen semasa dan sebelumnya boleh membentuk pasangan; Kemas kini DP [i] dengan memilih maksimum antara pasangan dan tidak berpasangan; Indeks terakhir akan mempunyai hasilnya; Kod pemacu", "code": "< ? php function maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ K ) { sort ( $ arr ) ; $ dp = array ( ) ; $ dp [ 0 ] = 0 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ dp [ $ i ] = $ dp [ $ i - 1 ] ; if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] < $ K ) { if ( $ i >= 2 ) $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ i - 2 ] + $ arr [ $ i ] + $ arr [ $ i - 1 ] ) ; else $ dp [ $ i ] = max ( $ dp [ $ i ] , $ arr [ $ i ] + $ arr [ $ i - 1 ] ) ; } } return $ dp [ $ N - 1 ] ; } $ arr = array ( 3 , 5 , 10 , 15 , 17 , 12 , 9 ) ; $ N = sizeof ( $ arr ) ; $ K = 4 ; echo maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ K ) ; ? >"}
{"text": "Nombor Lucas | fungsi rekursif; Kes asas; hubungan berulang; Kod pemacu", "code": "< ? php function lucas ( $ n ) { if ( $ n == 0 ) return 2 ; if ( $ n == 1 ) return 1 ; return lucas ( $ n - 1 ) + lucas ( $ n - 2 ) ; } $ n = 9 ; echo lucas ( $ n ) ; ? >"}
{"text": "Recursif memecahkan nombor dalam 3 bahagian untuk mendapatkan jumlah maksimum | Berfungsi untuk mencari jumlah maksimum; keadaan asas; Recursif memecahkan nombor dan mengembalikan maksimum yang anda boleh dapatkan; Program pemacu untuk menjalankan kes itu", "code": "< ? php function breakSum ( $ n ) { if ( $ n == 0 $ n == 1 ) return $ n ; return max ( ( breakSum ( intval ( $ n / 2 ) ) + breakSum ( intval ( $ n / 3 ) ) + breakSum ( intval ( $ n / 4 ) ) ) , $ n ) ; } $ n = 12 ; echo breakSum ( $ n ) ; ? >"}
{"text": "Kira Semua Palindromic Susunan dalam rentetan yang diberikan | Fungsi mengembalikan jumlah seterusnya Palindromic; Buat array 2D untuk menyimpan kiraan Palindromic seterusnya; Palindromic berikutnya panjang 1; Semak seterusnya panjang L adalah palindrome atau tidak; mengembalikan jumlah Palindromic berikutnya; Kod pemacu", "code": "< ? php function countPS ( $ str ) { $ N = strlen ( $ str ) ; $ cps = array_fill ( 0 , $ N + 1 , array_fill ( 0 , $ N + 1 , NULL ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ cps [ $ i ] [ $ i ] = 1 ; for ( $ L = 2 ; $ L <= $ N ; $ L ++ ) { for ( $ i = 0 ; $ i <= $ N - $ L ; $ i ++ ) { $ k = $ L + $ i - 1 ; if ( $ str [ $ i ] == $ str [ $ k ] ) $ cps [ $ i ] [ $ k ] = $ cps [ $ i ] [ $ k - 1 ] + $ cps [ $ i + 1 ] [ $ k ] + 1 ; else $ cps [ $ i ] [ $ k ] = $ cps [ $ i ] [ $ k - 1 ] + $ cps [ $ i + 1 ] [ $ k ] - $ cps [ $ i + 1 ] [ $ k - 1 ] ; } } return $ cps [ 0 ] [ $ N - 1 ] ; } $ str = \" abcb \" ; echo \" Total ▁ palindromic ▁ subsequence ▁ are ▁ : ▁ \" . countPS ( $ str ) . \" STRNEWLINE \" ; ? >"}
{"text": "Kira Semua Palindromic Susunan dalam rentetan yang diberikan | Program PHP untuk mengira seterusnya palindromik dalam rentetan yang diberikan menggunakan rekursi; Fungsi mengembalikan jumlah seterusnya Palindromic; Kod pemacu", "code": "< ? php $ dp = array_fill ( 0 , 100 , array_fill ( 0 , 1000 , -1 ) ) ; $ str = \" abcb \" ; $ n = strlen ( $ str ) ; function countPS ( $ i , $ j ) { global $ str , $ dp , $ n ; if ( $ i > $ j ) return 0 ; if ( $ dp [ $ i ] [ $ j ] != -1 ) return $ dp [ $ i ] [ $ j ] ; if ( $ i == $ j ) return $ dp [ $ i ] [ $ j ] = 1 ; else if ( $ str [ $ i ] == $ str [ $ j ] ) return $ dp [ $ i ] [ $ j ] = countPS ( $ i + 1 , $ j ) + countPS ( $ i , $ j - 1 ) + 1 ; else return $ dp [ $ i ] [ $ j ] = countPS ( $ i + 1 , $ j ) + countPS ( $ i , $ j - 1 ) - countPS ( $ i + 1 , $ j - 1 ) ; } echo \" Total ▁ palindromic ▁ subsequence ▁ are ▁ : ▁ \" . countPS ( 0 , $ n - 1 ) ; ? >"}
{"text": "Cari jumlah minimum supaya salah satu daripada setiap tiga elemen berturut -turut diambil | berfungsi untuk mencari minimum 3 elemen; Mengembalikan jumlah elemen minimum yang mungkin sehingga elemen dari setiap tiga elemen berturut -turut dipilih. ; Buat jadual DP untuk menyimpan hasil subproblem. Jumlah [i] akan menyimpan jumlah minimum yang mungkin apabila arr [i] adalah sebahagian daripada penyelesaian. ; Apabila terdapat kurang daripada atau sama dengan 3 elemen; Melangkah melalui semua elemen lain; Kod pemacu", "code": "< ? php function minimum ( $ a , $ b , $ c ) { return min ( min ( $ a , $ b ) , $ c ) ; } function findMinSum ( $ arr , $ n ) { $ sum [ $ n ] = 0 ; $ sum [ 0 ] = $ arr [ 0 ] ; $ sum [ 1 ] = $ arr [ 1 ] ; $ sum [ 2 ] = $ arr [ 2 ] ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ sum [ $ i ] = $ arr [ $ i ] + minimum ( $ sum [ $ i - 3 ] , $ sum [ $ i - 2 ] , $ sum [ $ i - 1 ] ) ; return minimum ( $ sum [ $ n - 1 ] , $ sum [ $ n - 2 ] , $ sum [ $ n - 3 ] ) ; } $ arr = array ( 1 , 2 , 3 , 20 , 2 , 10 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Min ▁ Sum ▁ is ▁ \" , findMinSum ( $ arr , $ n ) ; ? >"}
{"text": "Kos minimum untuk mengisi berat badan dalam beg | Program PHP untuk mencari kos minimum untuk mendapatkan tepat dengan paket yang diberikan; Kos [] pelbagai kos awal termasuk kapasiti paket yang tidak tersedia untuk beg; val [] dan wt [] array val [] array untuk menyimpan kos 'i' kg paket oren wt [] berat badan paket oren; melintasi kos asal [] array dan melangkau paket yang tidak tersedia dan membuat array Val [] dan wt []. Pembolehubah saiz memberitahu bilangan paket berwajaran yang berbeza; Isi baris ke -0 dengan tak terhingga; Isi lajur 0 'dengan 0; Sekarang periksa setiap berat satu demi satu dan isi matriks mengikut keadaan; wt [i - 1]> j bermaksud kapasiti beg kurang daripada berat item; Di sini kami periksa kami mendapat kos minimum sama ada dengan memasukkannya atau tidak termasuknya; Tepat berat w tidak boleh dibuat dengan berat yang diberikan; Kod pemacu", "code": "< ? php $ INF = 1000000 ; function MinimumCost ( & $ cost , $ n , $ W ) { global $ INF ; $ val = array ( ) ; $ wt = array ( ) ; $ size = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ cost [ $ i ] != -1 ) { array_push ( $ val , $ cost [ $ i ] ) ; array_push ( $ wt , $ i + 1 ) ; $ size ++ ; } } $ n = $ size ; $ min_cost = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ W + 1 , NULL ) ) ; for ( $ i = 0 ; $ i <= $ W ; $ i ++ ) $ min_cost [ 0 ] [ $ i ] = $ INF ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ min_cost [ $ i ] [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ W ; $ j ++ ) { if ( $ wt [ $ i - 1 ] > $ j ) $ min_cost [ $ i ] [ $ j ] = $ min_cost [ $ i - 1 ] [ $ j ] ; else $ min_cost [ $ i ] [ $ j ] = min ( $ min_cost [ $ i - 1 ] [ $ j ] , $ min_cost [ $ i ] [ $ j - $ wt [ $ i - 1 ] ] + $ val [ $ i - 1 ] ) ; } } if ( $ min_cost [ $ n ] [ $ W ] == $ INF ) return -1 ; else return $ min_cost [ $ n ] [ $ W ] ; } $ cost = array ( 1 , 2 , 3 , 4 , 5 ) ; $ W = 5 ; $ n = sizeof ( $ cost ) ; echo MinimumCost ( $ cost , $ n , $ W ) ; ? >"}
{"text": "Cari bilangan kali rentetan berlaku sebagai berikutnya dalam rentetan yang diberikan | Fungsi rekursif untuk mencari bilangan kali rentetan kedua berlaku dalam rentetan pertama, sama ada berterusan atau tidak berterusan; Jika kedua -dua rentetan pertama dan kedua kosong, atau jika rentetan kedua kosong, kembali 1; Jika hanya rentetan pertama yang kosong dan rentetan kedua tidak kosong, kembali 0; Jika watak -watak terakhir sama berulang untuk rentetan baki dengan 1. Memandangkan watak -watak terakhir kedua -dua rentetan 2. Mengabaikan watak terakhir rentetan pertama; Jika watak terakhir berbeza, abaikan char terakhir rentetan pertama dan berulang untuk rentetan yang tinggal; Kod pemacu", "code": "< ? php function count_1 ( $ a , $ b , $ m , $ n ) { if ( ( $ m == 0 && $ n == 0 ) $ n == 0 ) return 1 ; if ( $ m == 0 ) return 0 ; if ( $ a [ $ m - 1 ] == $ b [ $ n - 1 ] ) return count_1 ( $ a , $ b , $ m - 1 , $ n - 1 ) + count_1 ( $ a , $ b , $ m - 1 , $ n ) ; else return count_1 ( $ a , $ b , $ m - 1 , $ n ) ; } $ a = \" GeeksforGeeks \" ; $ b = \" Gks \" ; echo count_1 ( $ a , $ b , strlen ( $ a ) , strlen ( $ b ) ) . \" \" ; return 0 ; ? >"}
{"text": "Kos minimum untuk membuat dua rentetan sama | Mengembalikan panjang LCS untuk x [0 .. m - 1], y [0 .. n - 1]; Langkah -langkah berikut membina l [m + 1] [n + 1] dalam fesyen bawah. Perhatikan bahawa l [i] [j] mengandungi panjang LCs x [0 .. i - 1] dan y [0. .. J - 1]; L [M] [n] mengandungi panjang LCS untuk x [0 .. n - 1] dan y [0 .. m - 1]; Mengembalikan kos membuat x [] dan y [] sama. Costx adalah kos untuk mengeluarkan watak dari x [] dan Costy adalah kos untuk mengeluarkan watak dari y [] /; Cari LCS X [] dan Y []; Kos membuat dua rentetan yang sama adalah jumlah berikut 1) kos mengeluarkan aksara tambahan dari rentetan pertama 2) kos mengeluarkan aksara tambahan dari rentetan kedua; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function lcs ( $ X , $ Y , $ m , $ n ) { $ L = array_fill ( 0 , ( $ m + 1 ) , array_fill ( 0 , ( $ n + 1 ) , NULL ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ i ] [ $ j ] = $ L [ $ i - 1 ] [ $ j - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] = max ( $ L [ $ i - 1 ] [ $ j ] , $ L [ $ i ] [ $ j - 1 ] ) ; } } return $ L [ $ m ] [ $ n ] ; } function findMinCost ( & $ X , & $ Y , $ costX , $ costY ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ len_LCS = lcs ( $ X , $ Y , $ m , $ n ) ; return $ costX * ( $ m - $ len_LCS ) + $ costY * ( $ n - $ len_LCS ) ; } $ X = \" ef \" ; $ Y = \" gh \" ; echo \" Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ \" . \" identical is = \" return 0 ; ? >"}
{"text": "Bilangan bukan | Mengembalikan kiraan penyelesaian A + B + C = n; Memulakan hasil; Pertimbangkan semua triplet dan hasil kenaikan apabila jumlah triplet adalah n. ; Kod pemacu", "code": "< ? php function countIntegralSolutions ( $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n - $ i ; $ j ++ ) for ( $ k = 0 ; $ k <= ( $ n - $ i - $ j ) ; $ k ++ ) if ( $ i + $ j + $ k == $ n ) $ result ++ ; return $ result ; } $ n = 3 ; echo countIntegralSolutions ( $ n ) ; ? >"}
{"text": "Bilangan bukan | Mengembalikan kiraan penyelesaian A + B + C = n; Kod pemacu", "code": "< ? php function countIntegralSolutions ( $ n ) { return ( ( $ n + 1 ) * ( $ n + 2 ) ) / 2 ; } $ n = 3 ; echo countIntegralSolutions ( $ n ) ; ? >"}
{"text": "Perbezaan mutlak maksimum antara jumlah dua sub | Cari jumlah subarray maksimum untuk Subarray [0. i] Menggunakan algoritma standard Kadane. Algoritma ini akan berfungsi jika semua nombor negatif; Cari jumlah subarray maksimum untuk Subarray [i. . n] Menggunakan algoritma Kadane. ~ Versi ini algoritma Kadane akan berfungsi jika semua nombor negatif; Fungsi ini mendapati dua sub -tatasusunan yang tidak bertindih seperti perbezaan mutlak antara jumlah dua sub - array adalah maksimum. ; Buat dan bina array yang menyimpan jumlah maksimum subarrays yang terletak di Arr [0 .. . i]; Buat dan bina array yang menyimpan jumlah maksimum subarray yang terletak di arr [i + 1. . n - 1]; Invert Array (Tanda Tukar) untuk mencari subarray Minumum Sum; Buat dan bina array yang menyimpan jumlah minimum subarrays yang terletak di Arr [0 .. . i]; Buat dan bina array yang menyimpan jumlah minimum subarrays yang terletak di arr [i + 1. . n - 1]; Untuk setiap indeks i, ambil maksimum 1. Abs (max jumlah subarray yang terletak di arr [0 ... i] - min jumlah subarray yang terletak di arr [i + 1 ... Kod pemacu", "code": "< ? php function maxLeftSubArraySum ( & $ a , $ size , & $ sum ) { $ max_so_far = $ a [ 0 ] ; $ curr_max = $ a [ 0 ] ; $ sum [ 0 ] = $ max_so_far ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) { $ curr_max = max ( $ a [ $ i ] , $ curr_max + $ a [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ curr_max ) ; $ sum [ $ i ] = $ max_so_far ; } return $ max_so_far ; } function maxRightSubArraySum ( & $ a , $ n , & $ sum ) { $ max_so_far = $ a [ $ n ] ; $ curr_max = $ a [ $ n ] ; $ sum [ $ n ] = $ max_so_far ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ curr_max = max ( $ a [ $ i ] , $ curr_max + $ a [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ curr_max ) ; $ sum [ $ i ] = $ max_so_far ; } return $ max_so_far ; } function findMaxAbsDiff ( & $ arr , $ n ) { $ leftMax = array_fill ( 0 , $ n , NULL ) ; maxLeftSubArraySum ( $ arr , $ n , $ leftMax ) ; $ rightMax = array_fill ( 0 , $ n , NULL ) ; maxRightSubArraySum ( $ arr , $ n - 1 , $ rightMax ) ; $ invertArr = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ invertArr [ $ i ] = - $ arr [ $ i ] ; $ leftMin = array_fill ( 0 , $ n , NULL ) ; maxLeftSubArraySum ( $ invertArr , $ n , $ leftMin ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ leftMin [ $ i ] = - $ leftMin [ $ i ] ; $ rightMin = array_fill ( 0 , $ n , NULL ) ; maxRightSubArraySum ( $ invertArr , $ n - 1 , $ rightMin ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ rightMin [ $ i ] = - $ rightMin [ $ i ] ; $ result = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ absValue = max ( abs ( $ leftMax [ $ i ] - $ rightMin [ $ i + 1 ] ) , abs ( $ leftMin [ $ i ] - $ rightMax [ $ i + 1 ] ) ) ; if ( $ absValue > $ result ) $ result = $ absValue ; } return $ result ; } $ a = array ( -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 ) ; $ n = sizeof ( $ a ) ; echo findMaxAbsDiff ( $ a , $ n ) ; ? >"}
{"text": "Cara untuk mengatur bola sedemikian rupa sehingga bola bersebelahan adalah pelbagai jenis | Mengembalikan kiraan pengaturan di mana bola diletakkan terakhir adalah 'terakhir'. 'terakhir' adalah 0 untuk 'p', 1 untuk 'q' dan 2 untuk 'r'; Jika bilangan bola dari mana -mana warna menjadi kurang daripada 0 bilangan cara pengaturan adalah 0; Jika bola terakhir yang diperlukan adalah jenis P dan bilangan bola jenis P adalah 1 manakala bilangan bola warna lain adalah 0 bilangan cara ialah 1 .; Kes yang sama seperti di atas untuk 'Q' dan 'R'; Jika bola terakhir yang diperlukan adalah p dan bilangan cara adalah jumlah bilangan cara untuk membentuk urutan dengan bola 'p - 1' p, bola q q dan bola r yang berakhir dengan q dan r. ; Sama seperti kes di atas untuk 'q' dan 'r'; Mengembalikan kiraan pengaturan yang diperlukan; Tiga kes timbul: bola terakhir yang diperlukan adalah jenis p yang terakhir yang diperlukan bola adalah jenis q bola terakhir yang diperlukan adalah jenis r; Kod pemacu", "code": "< ? php function countWays ( $ p , $ q , $ r , $ last ) { if ( $ p < 0 $ q < 0 $ r < 0 ) return 0 ; if ( $ p == 1 && $ q == 0 && $ r == 0 && $ last == 0 ) return 1 ; if ( $ p == 0 && $ q == 1 && $ r == 0 && $ last == 1 ) return 1 ; if ( $ p == 0 && $ q == 0 && $ r == 1 && $ last == 2 ) return 1 ; if ( $ last == 0 ) return countWays ( $ p - 1 , $ q , $ r , 1 ) + countWays ( $ p - 1 , $ q , $ r , 2 ) ; if ( $ last == 1 ) return countWays ( $ p , $ q - 1 , $ r , 0 ) + countWays ( $ p , $ q - 1 , $ r , 2 ) ; if ( $ last == 2 ) return countWays ( $ p , $ q , $ r - 1 , 0 ) + countWays ( $ p , $ q , $ r - 1 , 1 ) ; } function countUtil ( $ p , $ q , $ r ) { return countWays ( $ p , $ q , $ r , 0 ) + countWays ( $ p , $ q , $ r , 1 ) + countWays ( $ p , $ q , $ r , 2 ) ; } $ p = 1 ; $ q = 1 ; $ r = 1 ; echo ( countUtil ( $ p , $ q , $ r ) ) ; ? >"}
{"text": "Mengira bilangan cara untuk memisahkan satu set ke dalam sub subset | Mengembalikan kiraan partition yang berlainan elemen N dalam sub subset; Kes asas; S (n + 1, k) = k * s (n, k) + s (n, k - 1); Kod pemacu", "code": "< ? php function countP ( $ n , $ k ) { if ( $ n == 0 $ k == 0 $ k > $ n ) return 0 ; if ( $ k == 1 $ k == $ n ) return 1 ; return $ k * countP ( $ n - 1 , $ k ) + countP ( $ n - 1 , $ k - 1 ) ; } echo countP ( 3 , 2 ) ; ? >"}
{"text": "Mengira bilangan cara untuk memisahkan satu set ke dalam sub subset | Mengembalikan kiraan partition yang berlainan elemen N dalam sub subset; Jadual untuk menyimpan hasil subproblem; Kes asas; Isi sisa penyertaan dalam dp [] [] dengan cara bawah; Kod pemacu", "code": "< ? php function countP ( $ n , $ k ) { $ dp [ $ n + 1 ] [ $ k + 1 ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 0 ; for ( $ i = 0 ; $ i <= $ k ; $ i ++ ) $ dp [ 0 ] [ $ k ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) if ( $ j == 1 $ i == $ j ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = $ j * $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j - 1 ] ; return $ dp [ $ n ] [ $ k ] ; } echo countP ( 5 , 2 ) ; ? >"}
{"text": "Mengira bilangan cara untuk menutup jarak | Mengembalikan kiraan cara untuk menutup 'dist'; Kes asas; Berulang untuk semua 3 sebelumnya dan tambahkan hasilnya; Kod pemacu", "code": "< ? php function printCountRec ( $ dist ) { if ( $ dist < 0 ) return 0 ; if ( $ dist == 0 ) return 1 ; return printCountRec ( $ dist - 1 ) + printCountRec ( $ dist - 2 ) + printCountRec ( $ dist - 3 ) ; } $ dist = 4 ; echo printCountRec ( $ dist ) ; ? >"}
{"text": "Kira nombor dari 1 hingga n yang mempunyai 4 sebagai digit | Mengembalikan jumlah semua digit dalam nombor dari 1 hingga n; Satu demi satu mengira jumlah digit dalam setiap nombor dari 1 hingga n; Fungsi utiliti untuk mengira jumlah digit dalam nombor X yang diberikan; Kod pemacu", "code": "< ? php function countNumbersWith4 ( $ n ) { for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) $ result += has4 ( $ x ) ? 1 : 0 ; return $ result ; } function has4 ( $ x ) { while ( $ x != 0 ) { if ( $ x % 10 == 4 ) return true ; $ x = intval ( $ x / 10 ) ; } return false ; } $ n = 328 ; echo \" Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ \" . $ n . \" ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ a ▁ digit ▁ is ▁ \" . countNumbersWith4 ( $ n ) ; ? >"}
{"text": "Kira nombor dari 1 hingga n yang mempunyai 4 sebagai digit | Berfungsi untuk mengira nombor dari 1 hingga n yang mempunyai 4 sebagai digit; Kes asas; D = Bilangan digit dikurangkan satu dalam n. Untuk 328, D ialah 2; Pengiraan kiraan nombor dari 1 hingga 10 ^ d - 1, d = 0 a [0] = 0; D = 1 A [1] = kiraan nombor dari 0 hingga 9 adalah 1 d = 2 a [2] = kiraan nombor dari 0 hingga 99 adalah [1] * 9 + 10 = 19 d = 3 a [3] = kiraan nombor dari 0 hingga 999 adalah [2] * 19 + 100 = 171; Pengkomputeran 10 ^ d; Digit yang paling penting (MSD) N, untuk 328, MSD adalah 3 yang boleh diperolehi menggunakan 328 /100; Jika MSD adalah 4. Sebagai contoh jika n = 428, maka kiraan nombor adalah jumlah berikut. 1) kiraan nombor dari 1 hingga 399 2) kiraan nombor dari 400 hingga 428 iaitu 29; Jika MSD> 4. Sebagai contoh jika n adalah 728, maka kiraan nombor adalah jumlah berikut. 1) Mengira nombor dari 1 hingga 399 dan kiraan nombor dari 500 hingga 699, i. e. , \"A [2] ~ ~ 6\" 2) kiraan nombor dari 400 hingga 499, i. e. 100 3) kiraan nombor dari 700 hingga 728, berulang selama 28; Jika MSD <4. Sebagai contoh jika n adalah 328, maka kiraan nombor adalah jumlah berikut. 1) kiraan nombor dari 1 hingga 299 a 2) kiraan nombor dari 300 hingga 328, berulang selama 28; Kod pemacu", "code": "< ? php function countNumbersWith4 ( $ n ) { if ( $ n < 4 ) return 0 ; $ d = ( int ) log10 ( $ n ) ; $ a = array_fill ( 0 , $ d + 1 , NULL ) ; $ a [ 0 ] = 0 ; $ a [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ d ; $ i ++ ) $ a [ $ i ] = $ a [ $ i - 1 ] * 9 + ceil ( pow ( 10 , $ i - 1 ) ) ; $ p = ceil ( pow ( 10 , $ d ) ) ; $ msd = intval ( $ n / $ p ) ; if ( $ msd == 4 ) return ( $ msd ) * $ a [ $ d ] + ( $ n % $ p ) + 1 ; if ( $ msd > 4 ) return ( $ msd - 1 ) * $ a [ $ d ] + $ p + countNumbersWith4 ( $ n % $ p ) ; return ( $ msd ) * $ a [ $ d ] + countNumbersWith4 ( $ n % $ p ) ; } $ n = 328 ; echo \" Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ \" . $ n . \" ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is ▁ \" . countNumbersWith4 ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Keluarkan unsur -unsur minimum dari kedua -dua belah pihak supaya 2 * min menjadi lebih daripada max | Mengembalikan bilangan minimum penyingkiran dari kedua -dua hujung di arr [l. . H] supaya 2 * min menjadi lebih besar daripada maks. ; Inisialisasi indeks permulaan dan akhir subarray bersaiz maksimum dengan harta 2 * min> max; Pilih elemen yang berbeza sebagai titik permulaan; Memulakan min dan max untuk permulaan semasa; Pilih mata akhir yang berbeza untuk permulaan semasa; Mengemas kini min dan max jika perlu; Sekiranya harta itu dilanggar, maka tidak ada gunanya untuk meneruskan array yang lebih besar; Kemas kini Longest_Start dan Longest_end jika diperlukan; Sekiranya tidak satu elemen mengikuti harta itu, maka kembali n; Mengembalikan bilangan elemen yang akan dikeluarkan; Kod pemacu", "code": "< ? php function minRemovalsDP ( $ arr , $ n ) { $ longest_start = -1 ; $ longest_end = 0 ; for ( $ start = 0 ; $ start < $ n ; $ start ++ ) { $ min = PHP_INT_MAX ; $ max = PHP_INT_MIN ; for ( $ end = $ start ; $ end < $ n ; $ end ++ ) { $ val = $ arr [ $ end ] ; if ( $ val < $ min ) $ min = $ val ; if ( $ val > $ max ) $ max = $ val ; if ( 2 * $ min <= $ max ) break ; if ( $ end - $ start > $ longest_end - $ longest_start $ longest_start == -1 ) { $ longest_start = $ start ; $ longest_end = $ end ; } } } if ( $ longest_start == -1 ) return $ n ; return ( $ n - ( $ longest_end - $ longest_start + 1 ) ) ; } $ arr = array ( 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 ) ; $ n = sizeof ( $ arr ) ; echo minRemovalsDP ( $ arr , $ n ) ; ? >"}
{"text": "Strategi Optimal untuk Permainan | DP | Mengembalikan nilai optimum yang mungkin bahawa pemain boleh mengumpul dari pelbagai syiling saiz n. Nota daripada n mestilah; Buat jadual untuk menyimpan penyelesaian subproblem; Isi jadual menggunakan formula rekursif di atas. Perhatikan bahawa jadual diisi dalam fesyen pepenjuru (serupa dengan http: goo GL / pqqOS), dari unsur -unsur pepenjuru ke Jadual [0] [n - 1] yang hasilnya. ; Di sini x adalah nilai f (i + 2, j), y adalah f (i + 1, j - 1) dan z ialah f (i, j - 2) di atas formula rekursif; Kod pemacu", "code": "< ? php function optimalStrategyOfGame ( $ arr , $ n ) { $ table = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; for ( $ gap = 0 ; $ gap < $ n ; ++ $ gap ) { for ( $ i = 0 , $ j = $ gap ; $ j < $ n ; ++ $ i , ++ $ j ) { $ x = ( ( $ i + 2 ) <= $ j ) ? $ table [ $ i + 2 ] [ $ j ] : 0 ; $ y = ( ( $ i + 1 ) <= ( $ j - 1 ) ) ? $ table [ $ i + 1 ] [ $ j - 1 ] : 0 ; $ z = ( $ i <= ( $ j - 2 ) ) ? $ table [ $ i ] [ $ j - 2 ] : 0 ; $ table [ $ i ] [ $ j ] = max ( $ arr [ $ i ] + min ( $ x , $ y ) , $ arr [ $ j ] + min ( $ y , $ z ) ) ; } } return $ table [ 0 ] [ $ n - 1 ] ; } $ arr1 = array ( 8 , 15 , 3 , 7 ) ; $ n = count ( $ arr1 ) ; print ( optimalStrategyOfGame ( $ arr1 , $ n ) . \" \" ) ; $ arr2 = array ( 2 , 2 , 2 , 2 ) ; $ n = count ( $ arr2 ) ; print ( optimalStrategyOfGame ( $ arr2 , $ n ) . \" \" ) ; $ arr3 = array ( 20 , 30 , 2 , 2 , 2 , 10 ) ; $ n = count ( $ arr3 ) ; print ( optimalStrategyOfGame ( $ arr3 , $ n ) . \" \" ) ; ? >"}
{"text": "Jumlah maksimum Peningkatan seterusnya | DP | maxSumis () mengembalikan jumlah maksimum peningkatan seterusnya dalam arr [] saiz n; Memulakan nilai MSIS untuk semua indeks; Kirakan nilai jumlah maksimum dengan cara bawah; Pilih maksimum semua nilai MSIS; Kod pemacu", "code": "< ? php function maxSumIS ( $ arr , $ n ) { $ max = 0 ; $ msis = array ( $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ msis [ $ i ] = $ arr [ $ i ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ msis [ $ i ] < $ msis [ $ j ] + $ arr [ $ i ] ) $ msis [ $ i ] = $ msis [ $ j ] + $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ msis [ $ i ] ) $ max = $ msis [ $ i ] ; return $ max ; } $ arr = array ( 1 , 101 , 2 , 3 , 100 , 4 , 5 ) ; $ n = count ( $ arr ) ; echo \" Sum ▁ of ▁ maximum ▁ sum ▁ increasing ▁ subsequence ▁ is ▁ \" . maxSumIS ( $ arr , $ n ) ; ? >"}
{"text": "Kira rentetan yang berakhir dengan corak yang diberikan | Fungsi yang kembali benar jika str berakhir dengan pat; Corak lebih panjang daripada rentetan; Kami sepadan bermula dari akhir manakala Patlen lebih besar daripada atau sama dengan 0 .; Jika di mana -mana indeks str tidak sepadan dengan corak; Jika str berakhir dengan corak yang diberikan; Berfungsi untuk mengembalikan kiraan rentetan yang diperlukan; Jika rentetan semasa berakhir dengan corak yang diberikan; Kod pemacu", "code": "< ? php function endsWith ( $ str , $ pat ) { $ patLen = strlen ( $ pat ) ; $ strLen = strlen ( $ str ) ; if ( $ patLen > $ strLen ) return false ; $ patLen -- ; $ strLen -- ; while ( $ patLen >= 0 ) { if ( $ pat [ $ patLen ] != $ str [ $ strLen ] ) return false ; $ patLen -- ; $ strLen -- ; } return true ; } function countOfStrings ( $ pat , $ n , $ sArr ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( endsWith ( $ sArr [ $ i ] , $ pat ) ) $ count ++ ; return $ count ; } $ pat = \" ks \" ; $ n = 4 ; $ sArr = array ( \" geeks \" , \" geeksforgeeks \" , \" games \" , \" unit \" ) ; echo countOfStrings ( $ pat , $ n , $ sArr ) ; ? >"}
{"text": "Panjang substring terpanjang dengan aksara berturut -turut | Berfungsi untuk mengembalikan indeks akhir untuk sub -rentetan sub -sah / bermula dari indeks I; Jika watak semasa muncul selepas watak sebelumnya mengikut susunan abjad bulat yang diberikan; Berfungsi untuk mengembalikan panjang sub -rentetan watak berturut -turut dari STR; Sub Sub - String wujud dari Indeks I hingga akhir; Mengemas kini panjang; Kod pemacu", "code": "< ? php function getEndingIndex ( $ str , $ n , $ i ) { $ i ++ ; while ( $ i < $ n ) { $ curr = $ str [ $ i ] ; $ prev = $ str [ $ i - 1 ] ; if ( ( $ curr == ' a ' && $ prev == ' z ' ) || ( ord ( $ curr ) - ord ( $ prev ) == 1 ) ) $ i ++ ; else break ; } return $ i - 1 ; } function largestSubStr ( $ str , $ n ) { $ len = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ end = getEndingIndex ( $ str , $ n , $ i ) ; $ len = max ( $ end - $ i + 1 , $ len ) ; $ i = $ end + 1 ; } return $ len ; } $ str = \" abcabcdefabc \" ; $ n = strlen ( $ str ) ; echo largestSubStr ( $ str , $ n ) ; ? >"}
{"text": "Jumlah integer sehingga n dengan digit unit yang diberikan (set 2) | Berfungsi untuk mengembalikan jumlah yang diperlukan; Pengurangan n; Kod pemacu", "code": "< ? php function getSum ( $ n , $ d ) { if ( $ n < $ d ) return 0 ; while ( $ n % 10 != $ d ) $ n -- ; $ k = ( int ) ( $ n / 10 ) ; return ( $ k + 1 ) * $ d + ( $ k * 10 + 10 * $ k * $ k ) / 2 ; } $ n = 30 ; $ d = 3 ; echo getSum ( $ n , $ d ) ; ? >"}
{"text": "Watak minimum akan diganti untuk mengeluarkan substring yang diberikan | berfungsi untuk mengira aksara minimum untuk menggantikan; ketidakcocokan berlaku; Jika semua watak dipadankan, i. e, terdapat substring 'a' yang sama dengan rentetan 'b'; kenaikan saya ke indeks m - 1 supaya aksara minimum digantikan dalam 'A'; Kod pemacu", "code": "< ? php function replace ( $ A , $ B ) { $ n = strlen ( $ A ) ; $ m = strlen ( $ B ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ i + $ j >= $ n ) { break ; } else if ( $ A [ $ i + $ j ] != $ B [ $ j ] ) { break ; } } if ( $ j == $ m ) { $ count ++ ; $ i = $ i + $ m - 1 ; } } return $ count ; } $ str1 = \" aaaaaaaa \" ; $ str2 = \" aaa \" ; echo ( replace ( $ str1 , $ str2 ) ) ; ? >"}
{"text": "Semak jika rentetan adalah substring yang lain | Pulangan benar jika S1 adalah substring S2; Gelung untuk meluncur pat [] satu demi satu; Untuk indeks semasa I, periksa perlawanan corak; Kod pemacu", "code": "< ? php function isSubstring ( $ s1 , $ s2 ) { $ M = strlen ( $ s1 ) ; $ N = strlen ( $ s2 ) ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { $ j = 0 ; for ( ; $ j < $ M ; $ j ++ ) if ( $ s2 [ $ i + $ j ] != $ s1 [ $ j ] ) break ; if ( $ j == $ M ) return $ i ; } return -1 ; } $ s1 = \" for \" ; $ s2 = \" geeksforgeeks \" ; $ res = isSubstring ( $ s1 , $ s2 ) ; if ( $ res == -1 ) echo \" Not ▁ present \" ; else echo \" Present ▁ at ▁ index ▁ \" . $ res ; ? >"}
{"text": "Cari semua corak \"1 (0 +) 1\" dalam rentetan yang diberikan | Tetapkan 1 (Pendekatan Umum) | Berfungsi untuk mengira corak; Pembolehubah untuk menyimpan watak terakhir; Kami mendapati 0 dan watak terakhir adalah '1', perubahan keadaan; Selepas aliran 0, kita mendapat '1', kaunter bertambah; Watak terakhir disimpan; Kod pemacu", "code": "< ? php function patternCount ( $ str ) { $ last = $ str [ 0 ] ; $ i = 1 ; $ counter = 0 ; while ( $ i < strlen ( $ str ) ) { if ( $ str [ $ i ] == '0' && $ last == '1' ) { while ( $ str [ $ i ] == '0' ) $ i ++ ; if ( $ str [ $ i ] == '1' ) $ counter ++ ; } $ last = $ str [ $ i ] ; $ i ++ ; } return $ counter ; } $ str = \"1001ab010abc01001\" ; echo patternCount ( $ str ) ; ? >"}
{"text": "Awalan panjang maksimum satu rentetan yang berlaku sebagai seterusnya dalam yang lain | Kembalikan awalan panjang maksimum yang seterusnya. ; Melangkah rentetan t. ; Jika akhir rentetan s. ; Jika perlawanan watak, kaunter kenaikan. ; Kod pemacu", "code": "< ? php function maxPrefix ( $ s , $ t ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ t ) ; $ i ++ ) { if ( $ count == strlen ( $ s ) ) break ; if ( $ t [ $ i ] == $ s [ $ count ] ) $ count ++ ; } return $ count ; } { $ S = \" digger \" ; $ T = \" biggerdiagram \" ; echo maxPrefix ( $ S , $ T ) ; return 0 ; } ? >"}
{"text": "Gantikan semua kejadian String AB dengan C tanpa menggunakan ruang tambahan | Program PHP untuk menggantikan semua kejadian \"AB\" dengan \"C\"; Mula melintasi watak kedua; Sekiranya watak sebelumnya adalah 'A' dan watak semasa adalah 'B \"; Gantikan watak sebelumnya dengan' C 'dan gerakkan semua aksara berikutnya satu kedudukan kembali; Kod Pemandu", "code": "< ? php function translate ( & $ str ) { if ( $ str [ 0 ] == ' ' ) return ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i - 1 ] == ' A ' && $ str [ $ i ] == ' B ' ) { $ str [ $ i - 1 ] = ' C ' ; for ( $ j = $ i ; $ j < strlen ( $ str ) ; $ j ++ ) $ str [ $ j ] = $ str [ $ j + 1 ] ; } } return ; } $ str = \" helloABworldABGfG \" ; translate ( $ str ) ; echo \" The ▁ modified ▁ string ▁ is ▁ : STRNEWLINE \" ; echo $ str ; ? >"}
{"text": "Cari kedudukan huruf dalam abjad menggunakan operasi bit | Berfungsi untuk mengira kedudukan aksara; Melakukan dan beroperasi dengan nombor 31 $; Kod pemacu", "code": "< ? php function positions ( $ str , $ n ) { $ a = 31 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { print ( ( ord ( $ str [ $ i ] ) & ( $ a ) ) . \" \" ) ; } } $ str = \" Geeks \" ; $ n = strlen ( $ str ) ; positions ( $ str , $ n ) ; ? >"}
{"text": "Panjang substring terpanjang yang tidak mengandungi sebarang palindrome | Berfungsi untuk mencari panjang substring terpanjang; memulakan pembolehubah; Memeriksa palindrome saiz 2 Contoh: AA; Memeriksa palindrome saiz 3 Contoh: ABA; lain meningkatkan panjang substring; $ max1 = max ($ max1, $ len + 1); mencari maksimum; Sekiranya terdapat watak tunggal maka ia sentiasa palindrome; Kod pemacu", "code": "< ? php function lenoflongestnonpalindrome ( $ s ) { $ max1 = 1 ; $ len = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) - 1 ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ len = 0 ; else if ( $ s [ $ i + 1 ] == $ s [ $ i - 1 ] && $ i > 0 ) $ len = 1 ; $ len ++ ; } if ( $ max1 == 1 ) return 0 ; else return $ max1 ; } $ s = \" synapse \" ; echo lenoflongestnonpalindrome ( $ s ) , \" \" ; ? >"}
{"text": "Buat palindrome terkecil secara lexicographically dengan menggantikan watak -watak yang hilang | Berfungsi untuk mengembalikan palindrome terkecil yang boleh dibuat dari rentetan yang diberikan selepas menggantikan aksara yang diperlukan; Jika watak -watak hilang di kedua -dua kedudukan maka gantikannya dengan 'A'; Jika hanya str [j] = ' *' kemudian kemas kini dengan nilai pada str [i]; Jika hanya str [i] = ' *' kemudian kemas kini dengan nilai pada str [j]; Jika watak -watak di kedua -dua kedudukan tidak sama dan! = ' *' Maka rentetan tidak boleh dibuat palindrome; Mengembalikan palindrome yang diperlukan; Kod pemacu", "code": "< ? php function makePalindrome ( $ str ) { $ i = 0 ; $ j = strlen ( $ str ) - 1 ; while ( $ i <= $ j ) { if ( $ str [ $ i ] == ' * ' && $ str [ $ j ] == ' * ' ) { $ str [ $ i ] = ' a ' ; $ str [ $ j ] = ' a ' ; } else if ( $ str [ $ j ] == ' * ' ) $ str [ $ j ] = $ str [ $ i ] ; else if ( $ str [ $ i ] == ' * ' ) $ str [ $ i ] = $ str [ $ j ] ; else if ( $ str [ $ i ] != $ str [ $ j ] ) return \" - 1\" ; $ i ++ ; $ j -- ; } return $ str ; } $ str = \" na * an \" ; echo makePalindrome ( $ str ) ; ? >"}
{"text": "Kirakan skor untuk rentetan binari yang diberikan | Berfungsi untuk mengembalikan skor untuk rentetan binari yang diberikan; Melintasi watak rentetan; Mulakan saiz semasa Chunk; Dapatkan watak semasa; Kirakan jumlah saiz bahagian yang sama; Tambah / tolak pow (chunksize, 2) bergantung kepada watak; Mengembalikan skor; Kod pemacu", "code": "< ? php function calcScore ( $ str ) { $ score = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len { $ chunkSize = 1 ; $ currentChar = $ str [ $ i ++ ] ; while ( $ i < $ len && $ str [ $ i ] == $ currentChar ) { $ chunkSize ++ ; $ i ++ ; } if ( $ currentChar == '1' ) $ score += pow ( $ chunkSize , 2 ) ; else $ score -= pow ( $ chunkSize , 2 ) ; } return $ score ; } $ str = \"11011\" ; echo calcScore ( $ str ) ; ? >"}
{"text": "Bilangan sub | Berfungsi untuk mengembalikan kiraan sub -rentetan yang diperlukan; Kaunter kiri dan kanan untuk aksara di kedua -dua belah tetingkap sub -rentetan; Penunjuk kiri dan kanan pada kedua -dua belah tetingkap sub -rentetan; Memulakan kekerapan; Hasil dan panjang rentetan; Memulakan penunjuk kiri; Memulakan penunjuk yang betul; Melintasi semua tetingkap sub - rentetan; Mengira watak -watak di sebelah kiri tetingkap Sub - String; Mengira aksara di sebelah kanan tetingkap sub -rentetan; Tambah sub -rentetan yang mungkin di kedua -dua belah pihak untuk menghasilkan; Menetapkan kekerapan untuk tetingkap Sub - STRING seterusnya; Tetapkan semula kaunter kiri dan kanan; Kod pemacu", "code": "< ? php function countSubString ( $ s , $ c , $ k ) { $ leftCount = 0 ; $ rightCount = 0 ; $ left = 0 ; $ right = 0 ; $ freq = 0 ; $ result = 0 ; $ len = strlen ( $ s ) ; while ( $ s [ $ left ] != $ c && $ left < $ len ) { $ left ++ ; $ leftCount ++ ; } $ right = $ left + 1 ; while ( $ freq != ( $ k - 1 ) && ( $ right - 1 ) < $ len ) { if ( $ s [ $ right ] == $ c ) $ freq ++ ; $ right ++ ; } while ( $ left < $ len && ( $ right - 1 ) < $ len ) { while ( $ s [ $ left ] != $ c && $ left < $ len ) { $ left ++ ; $ leftCount ++ ; } while ( $ right < $ len && $ s [ $ right ] != $ c ) { if ( $ s [ $ right ] == $ c ) $ freq ++ ; $ right ++ ; $ rightCount ++ ; } $ result = $ result + ( $ leftCount + 1 ) * ( $ rightCount + 1 ) ; $ freq = $ k - 1 ; $ leftCount = 0 ; $ rightCount = 0 ; $ left ++ ; $ right ++ ; } return $ result ; } $ s = \" abada \" ; $ c = ' a ' ; $ k = 2 ; echo countSubString ( $ s , $ c , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak sama ada rentetan yang diberikan adalah pengecam yang sah | Fungsi yang pulih benar jika STR adalah pengenal yang sah; Jika watak pertama tidak sah; Melintasi rentetan untuk seluruh watak; String adalah pengecam yang sah; Kod pemacu", "code": "< ? php function isValid ( $ str , $ n ) { if ( ! ( ( $ str [ 0 ] >= ' a ' && $ str [ 0 ] <= ' z ' ) || ( $ str [ 0 ] >= ' A ' && $ str [ 0 ] <= ' Z ' ) $ str [ 0 ] == ' _ ' ) ) return false ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ! ( ( $ str [ $ i ] >= ' a ' && $ str [ $ i ] <= ' z ' ) || ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) || ( $ str [ $ i ] >= '0' && $ str [ $ i ] <= '9' ) $ str [ $ i ] == ' _ ' ) ) return false ; } return true ; } $ str = \" _ geeks123\" ; $ n = strlen ( $ str ) ; if ( isValid ( $ str , $ n ) ) print ( \" Valid \" ) ; else print ( \" Invalid \" ) ; ? >"}
{"text": "Mempunyai watak pertama dan terakhir setiap perkataan dalam rentetan | Program PHP untuk memanfaatkan watak pertama dan terakhir setiap perkataan dalam rentetan. ; Buat rentetan setara rentetan yang diberikan; $ k Kedai Indeks watak pertama dan $ I akan menyimpan indeks watak terakhir. ; Semak sama ada watak itu adalah huruf kecil jika ya, kemudian memanfaatkan; Kod pemacu", "code": "< ? php function FirstAndLast ( $ str ) { $ ch = $ str ; for ( $ i = 0 ; $ i < strlen ( $ ch ) ; $ i ++ ) { $ k = $ i ; while ( $ i < strlen ( $ ch ) && $ ch [ $ i ] != ' ▁ ' ) $ i ++ ; $ ch [ $ k ] = chr ( ( $ ch [ $ k ] >= ' a ' && $ ch [ $ k ] <= ' z ' ) ? ( ord ( $ ch [ $ k ] ) - 32 ) : ( ord ( $ ch [ $ k ] ) ) ) ; $ ch [ $ i - 1 ] = chr ( ( $ ch [ $ i - 1 ] >= ' a ' && $ ch [ $ i - 1 ] <= ' z ' ) ? ( ord ( $ ch [ $ i - 1 ] ) - 32 ) : ( ord ( $ ch [ $ i - 1 ] ) ) ) ; } return $ ch ; } $ str = \" Geeks ▁ for ▁ Geeks \" ; echo $ str , \" STRNEWLINE \" ; echo FirstAndLast ( $ str ) ; ? >"}
{"text": "Cari bilangan pemain yang melancarkan dadu apabila urutan output dadu diberikan | Berfungsi untuk mengembalikan bilangan pemain; Memulakan CNT sebagai 0; Iterat dalam rentetan; Semak nombor selain x; Kod pemacu", "code": "< ? php function findM ( $ s , $ x ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ s [ $ i ] ) - ord ( '0' ) != $ x ) $ cnt ++ ; } return $ cnt ; } $ s = \"3662123\" ; $ x = 6 ; echo findM ( $ s , $ x ) ; ? >"}
{"text": "Cari sub terpanjang | Berfungsi untuk mencari akhiran awalan terpanjang; Untuk menyimpan akhiran awalan terpanjang; Panjang akhiran awalan terpanjang sebelumnya; LPS [0] sentiasa 0; Gelung mengira LPS [i] untuk i = 1 hingga n - 1; (pat [i]! = pat [len]); Jika len = 0; Fungsi untuk mencari substring terpanjang yang merupakan awalan serta sub -rentetan S [1 .. . n - 2]; Cari akhiran awalan terpanjang; Jika LPS N - 1 adalah sifar; Di mana -mana kedudukan LPS [i] sama dengan LPS [n - 1]; Sekiranya jawapan tidak mungkin; Kod pemacu; panggilan fungsi", "code": "< ? php function compute_lps ( $ s ) { $ n = strlen ( $ s ) ; $ lps = array ( ) ; $ len = 0 ; $ lps [ 0 ] = 0 ; $ i = 1 ; while ( $ i < $ n ) { if ( $ s [ $ i ] == $ s [ $ len ] ) { $ len ++ ; $ lps [ $ i ] = $ len ; $ i ++ ; } else { if ( $ len != 0 ) $ len = $ lps [ $ len - 1 ] ; else { $ lps [ $ i ] = 0 ; $ i ++ ; } } } return $ lps ; } function Longestsubstring ( $ s ) { $ lps = compute_lps ( $ s ) ; $ n = strlen ( $ s ) ; if ( $ lps [ $ n - 1 ] == 0 ) { echo - 1 ; return ; } for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ lps [ $ i ] == $ lps [ $ n - 1 ] ) { echo substr ( $ s , 0 , $ lps [ $ i ] ) ; return ; } } if ( $ lps [ $ lps [ $ n - 1 ] - 1 ] == 0 ) echo - 1 ; else echo substr ( $ s , 0 , $ lps [ $ lps [ $ n - 1 ] - 1 ] ) ; } $ s = \" fixprefixsuffix \" ; Longestsubstring ( $ s ) ; ? >"}
{"text": "Pasangan rentetan yang pada concatenating mengandungi setiap watak \"String\" | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan bitmask untuk rentetan; Berfungsi untuk mengembalikan kiraan pasangan; Bitmask [i] akan menyimpan kiraan rentetan dari array yang bitmask saya; Untuk menyimpan kiraan pasangan; Max - 1 = 63 i. e. 111111 dalam binari; arr [i] tidak boleh membuat pasangan dengan sendirinya. e. (arr [i], arr [i]); Kod pemacu", "code": "< ? php $ MAX = 64 ; function getBitmask ( $ s ) { $ temp = 0 ; for ( $ j = 0 ; $ j < strlen ( $ s ) ; $ j ++ ) { if ( $ s [ $ j ] == ' s ' ) { $ temp = $ temp | ( 1 ) ; } else if ( $ s [ $ j ] == ' t ' ) { $ temp = $ temp | ( 2 ) ; } else if ( $ s [ $ j ] == ' r ' ) { $ temp = $ temp | ( 4 ) ; } else if ( $ s [ $ j ] == ' i ' ) { $ temp = $ temp | ( 8 ) ; } else if ( $ s [ $ j ] == ' n ' ) { $ temp = $ temp | ( 16 ) ; } else if ( $ s [ $ j ] == ' g ' ) { $ temp = $ temp | ( 32 ) ; } } return $ temp ; } function countPairs ( $ arr , $ n ) { $ bitMask = array_fill ( 0 , $ GLOBALS [ ' MAX ' ] , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ bitMask [ getBitmask ( $ arr [ $ i ] ) ] ++ ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' MAX ' ] ; $ i ++ ) { for ( $ j = $ i ; $ j < $ GLOBALS [ ' MAX ' ] ; $ j ++ ) { if ( ( $ i $ j ) == ( $ GLOBALS [ ' MAX ' ] - 1 ) ) { if ( $ i == $ j ) $ cnt += floor ( ( $ bitMask [ $ i ] * $ bitMask [ $ i ] - 1 ) / 2 ) ; else $ cnt += ( $ bitMask [ $ i ] * $ bitMask [ $ j ] ) ; } } } return $ cnt ; } $ arr = array ( \" strrr \" , \" string \" , \" gstrin \" ) ; $ n = count ( $ arr ) ; echo countPairs ( $ arr , $ n ) ; ? >"}
{"text": "Cari kiraan sub | Berfungsi untuk mengembalikan kiraan kejadian yang diperlukan; Untuk menyimpan kiraan kejadian; Semak empat aksara pertama dari kedudukan ith; Pembolehubah untuk mengira aksara yang diperlukan; Semak empat watak bersebelahan yang boleh disusun semula untuk membentuk 'tepukan'; Jika semua empat aksara bersebelahan hadir maka pembolehubah CNT kenaikan; Kod pemacu", "code": "< ? php function countOcc ( $ s ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) - 3 ; $ i ++ ) { $ c = 0 ; $ l = 0 ; $ a = 0 ; $ p = 0 ; for ( $ j = $ i ; $ j < $ i + 4 ; $ j ++ ) { switch ( $ s [ $ j ] ) { case ' c ' : $ c ++ ; break ; case ' l ' : $ l ++ ; break ; case ' a ' : $ a ++ ; break ; case ' p ' : $ p ++ ; break ; } } if ( $ c == 1 && $ l == 1 && $ a == 1 && $ p == 1 ) $ cnt ++ ; } return $ cnt ; } $ s = \" clapc \" ; echo countOcc ( strtolower ( $ s ) ) ; ? >"}
{"text": "Bilangan cara di mana substring dalam julat [l, r] boleh dibentuk menggunakan aksara dari julat | Berfungsi untuk mengembalikan bilangan cara untuk membentuk sub -rentetan; Memulakan hash - jadual dengan 0; Iterat dalam rentetan dan mengira kekerapan aksara yang tidak terletak dalam julat L dan R; Daripada watak jarak jauh; Menyimpan bilangan cara terakhir; Berulang untuk sub -rentetan dalam julat l dan r; Sekiranya wujud maka kalikan bilangan cara dan menurunkan kekerapan; Jika tidak wujud sub -rentetan tidak boleh dibentuk; Kembalikan jawapannya; Kod pemacu", "code": "< ? php function calculateWays ( $ s , $ n , $ l , $ r ) { $ freq = array ( ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { $ freq [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i < $ l $ i > $ r ) $ freq [ ord ( $ s [ $ i ] ) - 97 ] ++ ; } $ ways = 1 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( $ freq [ ord ( $ s [ $ i ] ) - 97 ] ) { $ ways = $ ways * $ freq [ ord ( $ s [ $ i ] ) - 97 ] ; $ freq [ ord ( $ s [ $ i ] ) - 97 ] -- ; } else { $ ways = 0 ; break ; } } return $ ways ; } $ s = \" cabcaab \" ; $ n = strlen ( $ s ) ; $ l = 1 ; $ r = 3 ; echo calculateWays ( $ s , $ n , $ l , $ r ) ; ? >"}
{"text": "Tukar kalimat nilai ASCII ke rentetan setara | Berfungsi untuk mencetak urutan watak untuk kalimat ASCII yang diberikan; Tambah digit semasa; Jika NUM berada dalam julat yang diperlukan; Tukar NUM kepada Char; Tetapkan semula Num kepada 0; Kod pemacu", "code": "< ? php function asciiToSentence ( $ string , $ length ) { $ num = 0 ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ num = $ num * 10 + ( ord ( $ string [ $ i ] ) - ord ( '0' ) ) ; if ( $ num >= 32 && $ num <= 122 ) { $ ch = chr ( $ num ) ; print ( $ ch ) ; $ num = 0 ; } } } $ string = \"7110110110711510211111471101101107115\" ; $ length = strlen ( $ string ) ; asciiToSentence ( $ string , $ length ) ; ? >"}
{"text": "Kira butang ditekan dalam mudah alih mudah alih | Array untuk menyimpan berapa kali butang perlu ditekan untuk menaip watak tertentu; Berfungsi untuk mengembalikan kiraan butang yang ditekan untuk menaip rentetan yang diberikan; Kira penekan kekunci; Mengembalikan kiraan yang diperlukan; Kod pemacu", "code": "< ? php $ arr = array ( 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ) ; function countKeyPressed ( $ str , $ len ) { global $ arr ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ count = $ count + $ arr [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ; return $ count ; } $ str = \" abcdef \" ; $ len = strlen ( $ str ) ; echo countKeyPressed ( $ str , $ len ) ; ? >"}
{"text": "Rentetan pertama dari array yang diberikan yang terbalik juga terdapat dalam array yang sama | Fungsi yang pulih benar jika S1 adalah sama dengan terbalik S2; Jika kedua -dua rentetan berbeza panjang; Sekiranya tidak sepadan watak; Berfungsi untuk mengembalikan perkataan pertama yang terbalik juga terdapat dalam array; Semak setiap rentetan; Sepasang dengan setiap rentetan lain yang muncul selepas rentetan semasa; Jika rentetan pertama sama dengan sebaliknya rentetan kedua; Tiada rentetan seperti itu; Kod pemacu", "code": "< ? php function isReverseEqual ( $ s1 , $ s2 ) { if ( strlen ( $ s1 ) != strlen ( $ s2 ) ) return false ; $ len = strlen ( $ s1 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) if ( $ s1 [ $ i ] != $ s2 [ $ len - $ i - 1 ] ) return false ; return true ; } function getWord ( $ str , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( isReverseEqual ( $ str [ $ i ] , $ str [ $ j ] ) ) return $ str [ $ i ] ; return \" - 1\" ; } $ str = array ( \" geeks \" , \" for \" , \" skeeg \" ) ; $ n = count ( $ str ) ; print ( getWord ( $ str , $ n ) ) ; ? >"}
{"text": "Semak jika rentetan yang diberikan adalah k | Fungsi yang kembali benar jika sub - panjang $ k bermula pada indeks $ i juga merupakan awalan rentetan; $ k panjang sub - tidak boleh bermula pada indeks $ i; Kesamaan watak antara awalan dan sub - bermula pada indeks $ i; Fungsi yang pulih benar jika $ str adalah k - berkala; Semak sama ada semua sub -string $ str [0, $ k - 1], $ str [$ k, 2 k - 1] ... sama dengan awalan panjang $ k; Kod pemacu", "code": "< ? php function isPrefix ( $ str , $ len , $ i , $ k ) { if ( $ i + $ k > $ len ) return false ; for ( $ j = 0 ; $ j < $ k ; $ j ++ ) { if ( $ str [ $ i ] != $ str [ $ j ] ) return false ; $ i ++ ; } return true ; } function isKPeriodic ( $ str , $ len , $ k ) { for ( $ i = $ k ; $ i < $ len ; $ i += $ k ) if ( ! isPrefix ( $ str , $ len , $ i , $ k ) ) return false ; return true ; } $ str = \" geeksgeeks \" ; $ len = strlen ( $ str ) ; $ k = 5 ; if ( isKPeriodic ( $ str , $ len , $ k ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Bilangan minimum huruf yang diperlukan untuk membuat jumlah N | Berfungsi untuk mengembalikan huruf minimum yang diperlukan untuk membuat jumlah N; Kod pemacu", "code": "< ? php function minLettersNeeded ( $ n ) { if ( $ n % 26 == 0 ) return floor ( ( $ n / 26 ) ) ; else return floor ( ( $ n / 26 ) + 1 ) ; } $ n = 52 ; echo minLettersNeeded ( $ n ) ; ? >"}
{"text": "Bilangan minimum penggantian untuk membuat rentetan binari bergantian | Tetapkan 2 | Berfungsi untuk mengembalikan bilangan minimum aksara rentetan binari yang diberikan untuk diganti untuk membuat rentetan berselang -seli; Sekiranya terdapat 1 pada kedudukan indeks walaupun; Sekiranya terdapat 0 pada kedudukan indeks ganjil; Kod pemacu", "code": "< ? php function minReplacement ( $ s , $ len ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ i % 2 == 0 && $ s [ $ i ] == '1' ) $ ans ++ ; if ( $ i % 2 == 1 && $ s [ $ i ] == '0' ) $ ans ++ ; } return min ( $ ans , $ len - $ ans ) ; } $ s = \"1100\" ; $ len = strlen ( $ s ) ; echo minReplacement ( $ s , $ len ) ; ? >"}
{"text": "Kumpulan Kumpulan berturut -turut jenis yang sama dalam rentetan | Berfungsi untuk mengembalikan rentetan yang diubah suai; Simpan rentetan asal; Keluarkan semua ruang putih; Untuk menyimpan rentetan yang dihasilkan; Melintasi rentetan; Kumpulan huruf besar kumpulan; Watak angka kumpulan; Pengendali aritmetik kumpulan; Kembali rentetan yang dihasilkan; Kod pemacu", "code": "< ? php function groupCharacters ( $ s , $ len ) { $ temp = \" \" ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) if ( $ s [ $ i ] != ' ▁ ' ) $ temp = $ temp . $ s [ $ i ] ; $ len = strlen ( $ temp ) ; $ ans = \" \" ; $ i = 0 ; while ( $ i < $ len ) { if ( ord ( $ temp [ $ i ] ) >= ord ( ' A ' ) && ord ( $ temp [ $ i ] ) <= ord ( ' Z ' ) ) { while ( $ i < $ len && ord ( $ temp [ $ i ] ) >= ord ( ' A ' ) && ord ( $ temp [ $ i ] ) <= ord ( ' Z ' ) ) { $ ans = $ ans . $ temp [ $ i ] ; $ i ++ ; } $ ans = $ ans . \" ▁ \" ; } else if ( ord ( $ temp [ $ i ] ) >= ord ( '0' ) && ord ( $ temp [ $ i ] ) <= ord ( '9' ) ) { while ( $ i < $ len && ord ( $ temp [ $ i ] ) >= ord ( '0' ) && ord ( $ temp [ $ i ] ) <= ord ( '9' ) ) { $ ans = $ ans . $ temp [ $ i ] ; $ i ++ ; } $ ans = $ ans . \" ▁ \" ; } else { while ( $ i < $ len && ord ( $ temp [ $ i ] ) >= ord ( ' * ' ) && ord ( $ temp [ $ i ] ) <= ord ( ' / ' ) ) { $ ans = $ ans . $ temp [ $ i ] ; $ i ++ ; } $ ans = $ ans . \" ▁ \" ; } } return $ ans ; } $ s = \"34FTG234 + ▁ + - ▁ * \" ; $ len = strlen ( $ s ) ; print ( groupCharacters ( $ s , $ len ) ) ; ? >"}
{"text": "Cari bilangan minimum langkah pra -proses yang diperlukan untuk membuat dua rentetan sama | Berfungsi untuk mengembalikan bilangan minimum gerakan pemprosesan pra yang diperlukan pada rentetan A; Panjang rentetan yang diberikan; Untuk menyimpan jawapan yang diperlukan; Untuk menyimpan kekerapan 4 aksara; Jalankan gelung sehingga n / 2; Jika saiz adalah 4; Jika saiz adalah 3; Jika saiz adalah 2; Jika n adalah ganjil; Kod pemacu", "code": "< ? php function Preprocess ( $ A , $ B ) { $ n = strlen ( $ A ) ; $ ans = 0 ; $ mp = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mp [ $ A [ $ i ] ] = 0 ; for ( $ i = 0 ; $ i < floor ( $ n / 2 ) ; $ i ++ ) { $ mp [ $ A [ $ i ] ] ++ ; $ mp [ $ A [ $ n - $ i - 1 ] ] ++ ; $ mp [ $ B [ $ i ] ] ++ ; $ mp [ $ B [ $ n - $ i - 1 ] ] ++ ; $ sz = sizeof ( $ mp ) ; if ( $ sz == 4 ) $ ans += 2 ; else if ( $ sz == 3 ) if ( $ A [ $ i ] == $ A [ $ n - $ i - 1 ] ) $ ans += 1 ; else $ ans += 1 ; else if ( $ sz == 2 ) $ ans += $ mp [ $ A [ $ i ] ] != 2 ; } if ( $ n % 2 == 1 && ( $ A [ floor ( $ n / 2 ) ] != $ B [ floor ( $ n / 2 ) ] ) ) $ ans ++ ; return $ ans ; } $ A = \" abacaba \" ; $ B = \" bacabaa \" ; echo Preprocess ( $ A , $ B ) ; ? >"}
{"text": "Semak sama ada dua rentetan bersamaan atau tidak mengikut keadaan yang diberikan | Fungsi ini mengembalikan rentetan aphical Lexicogr yang paling sedikit yang diperoleh dari dua bahagiannya; Kes asas - jika saiz rentetan adalah 1; Bahagikan rentetan ke dalam dua bahagiannya; Membentuk rentetan leksikografi paling sedikit; Kod pemacu", "code": "< ? php function leastLexiString ( $ s ) { if ( strlen ( $ s ) & 1 ) return $ s ; $ x = leastLexiString ( substr ( $ s , 0 , floor ( strlen ( $ s ) / 2 ) ) ) ; $ y = leastLexiString ( substr ( $ s , floor ( strlen ( $ s ) / 2 ) , strlen ( $ s ) ) ) ; return min ( $ x . $ y , $ y . $ x ) ; } function areEquivalent ( $ a , $ b ) { return ( leastLexiString ( $ a ) == leastLexiString ( $ b ) ) ; } $ a = \" aaba \" ; $ b = \" abaa \" ; if ( areEquivalent ( $ a , $ b ) ) echo \" YES \" , \" STRNEWLINE \" ; else echo \" NO \" , \" STRNEWLINE \" ; $ a = \" aabb \" ; $ b = \" abab \" ; if ( areEquivalent ( $ a , $ b ) ) echo \" YES \" , \" STRNEWLINE \" ; else echo \" NO \" , \" STRNEWLINE \" ; ? >"}
{"text": "Menjana rentetan yang terdiri daripada aksara 'A' dan 'B' yang memenuhi syarat -syarat yang diberikan | Berfungsi untuk menjana dan mencetak rentetan yang diperlukan; Lebih 'b', tambah \"BBA\"; Lebih 'a', tambah \"aab\"; Bilangan yang sama 'a' dan 'b' append \"ab\"; Kod pemacu", "code": "< ? php function generateString ( $ A , $ B ) { $ rt = \" \" ; while ( 0 < $ A 0 < $ B ) { if ( $ A < $ B ) { if ( 0 < $ B -- ) { $ rt . = ( ' b ' ) ; } if ( 0 < $ B -- ) { $ rt . = ( ' b ' ) ; } if ( 0 < $ A -- ) { $ rt . = ( ' a ' ) ; } } else if ( $ B < $ A ) { if ( 0 < $ A -- ) { $ rt . = ( ' a ' ) ; } if ( 0 < $ A -- ) { $ rt . = ( ' a ' ) ; } if ( 0 < $ B -- ) { $ rt . = ( ' b ' ) ; } } else { if ( 0 < $ A -- ) { $ rt . = ( ' a ' ) ; } if ( 0 < $ B -- ) { $ rt . = ( ' b ' ) ; } } } echo ( $ rt ) ; } $ A = 2 ; $ B = 6 ; generateString ( $ A , $ B ) ; ? >"}
{"text": "Sub Lexicographically terbesar | Berfungsi untuk mengembalikan sub -urutan terbesar Sub - s urutan S; Dapatkan watak maksimum dari rentetan; Gunakan semua kejadian aksara maksimum semasa; Ulangi langkah -langkah untuk rentetan yang tinggal; Kod pemacu", "code": "< ? php function getSubSeq ( $ s , $ n ) { $ res = \" \" ; $ cr = 0 ; while ( $ cr < $ n ) { $ mx = $ s [ $ cr ] ; for ( $ i = $ cr + 1 ; $ i < $ n ; $ i ++ ) $ mx = max ( $ mx , $ s [ $ i ] ) ; $ lst = $ cr ; for ( $ i = $ cr ; $ i < $ n ; $ i ++ ) if ( $ s [ $ i ] == $ mx ) { $ res . = $ s [ $ i ] ; $ lst = $ i ; } $ cr = $ lst + 1 ; } return $ res ; } $ s = \" geeksforgeeks \" ; $ n = strlen ( $ s ) ; echo getSubSeq ( $ s , $ n ) ; ? >"}
{"text": "Count of Sub | Fungsi untuk mengembalikan kiraan sub -rentetan STR yang boleh dibahagikan oleh k; Ambil semua sub -rentetan bermula dari i; Jika sub -rentetan semasa dibahagikan dengan k; Mengembalikan kiraan yang diperlukan; Kod pemacu", "code": "< ? php function countSubStr ( $ str , $ len , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ n = 0 ; for ( $ j = $ i ; $ j < $ len ; $ j ++ ) { $ n = $ n * 10 + ( $ str [ $ j ] - '0' ) ; if ( $ n % $ k == 0 ) $ count ++ ; } } return $ count ; } $ str = \"33445\" ; $ len = strlen ( $ str ) ; $ k = 11 ; echo countSubStr ( $ str , $ len , $ k ) ; ? >"}
{"text": "Cari Gabungan Warna Yang Berhasil | Berfungsi untuk mengembalikan kombinasi warna; Semak b * g = y; Semak b * y = g; Semak y * g = b; Kod pemacu", "code": "< ? php function Colour_Combination ( $ s ) { $ temp = $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ temp != $ s [ $ i ] ) { if ( ( $ temp == ' B ' $ temp == ' G ' ) && ( $ s [ $ i ] == ' G ' $ s [ $ i ] == ' B ' ) ) $ temp = ' Y ' ; else if ( ( $ temp == ' B ' $ temp == ' Y ' ) && ( $ s [ $ i ] == ' Y ' $ s [ $ i ] == ' B ' ) ) $ temp = ' G ' ; else $ temp = ' B ' ; } } return $ temp ; } $ s = \" GBYGB \" ; echo Colour_Combination ( $ s ) ; ? >"}
{"text": "Reverse Middle X Watak | Berfungsi untuk membalikkan watak X tengah dalam rentetan; Cari kedudukan dari mana watak -watak perlu dibalikkan; Cetak aksara N yang pertama; Cetak aksara X tengah secara terbalik; Cetak aksara N yang terakhir; Kod pemacu", "code": "< ? php function reverse ( $ str , $ x ) { $ n = ( strlen ( $ str ) - $ x ) / 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ str [ $ i ] ) ; for ( $ i = $ n + $ x - 1 ; $ i >= $ n ; $ i -- ) echo ( $ str [ $ i ] ) ; for ( $ i = $ n + $ x ; $ i < strlen ( $ str ) ; $ i ++ ) echo $ str [ $ i ] ; } $ str = \" geeksforgeeks \" ; $ x = 3 ; reverse ( $ str , $ x ) ; ? >"}
{"text": "Kurangkan bilangan pengganti untuk mendapatkan rentetan dengan bilangan yang sama 'a', 'b' dan 'c' di dalamnya | Berfungsi untuk mengira nombor; Kira bilangan 'a', 'b' dan 'c' dalam rentetan; Jika sama sebelum ini; Jika tidak berganda 3; Meningkatkan bilangan A 's' »» '' 'b' dan; c;  ; Semak sama ada 'B' dan lebih daripada n / 3; Semak sama ada 'c' dan lebih daripada n / 3; Meningkatkan bilangan B 's' »» '' 'c'; Semak sama ada 'c' dan lebih daripada n / 3; Meningkatkan bilangan C dari belakang; Semak sama ada 'A' dan lebih daripada n / 3; Meningkatkan bilangan B dari belakang; Semak sama ada 'A' dan lebih daripada n / 3; Meningkatkan bilangan C dari belakang; Semak sama ada 'B' dan lebih daripada n / 3; Kod pemacu", "code": "< ? php function lexoSmallest ( $ s , $ n ) { $ ca = 0 ; $ cb = 0 ; $ cc = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' ) $ ca ++ ; else if ( $ s [ $ i ] == ' b ' ) $ cb ++ ; else $ cc ++ ; } if ( $ ca == $ cb && $ cb == $ cc ) { return $ s ; } $ cnt = floor ( $ n / 3 ) ; if ( $ cnt * 3 != $ n ) { return \" - 1\" ; } $ i = 0 ; while ( $ ca < $ cnt && $ i < $ n ) { if ( $ s [ $ i ] == ' b ' && $ cb > $ cnt ) { $ cb -- ; $ s [ $ i ] = ' a ' ; $ ca ++ ; } else if ( $ s [ $ i ] == ' c ' && $ cc > $ cnt ) { $ cc -- ; $ s [ $ i ] = ' a ' ; $ ca ++ ; } $ i ++ ; } $ i = 0 ; while ( $ cb < $ cnt && $ i < $ n ) { if ( $ s [ $ i ] == ' c ' && $ cc > $ cnt ) { $ cc -- ; $ s [ $ i ] = '1' ; $ cb ++ ; } $ i ++ ; } $ i = $ n - 1 ; while ( $ cc < $ cnt && $ i >= 0 ) { if ( $ s [ $ i ] == ' a ' && $ ca > $ cnt ) { $ ca -- ; $ s [ $ i ] = ' c ' ; $ cc ++ ; } $ i -- ; } $ i = $ n - 1 ; while ( $ cb < $ cnt && $ i >= 0 ) { if ( $ s [ $ i ] == ' a ' && $ ca > $ cnt ) { $ ca -- ; $ s [ $ i ] = ' b ' ; $ cb ++ ; } $ i -- ; } $ i = $ n - 1 ; while ( $ cc < $ cnt && $ i >= 0 ) { if ( $ s [ $ i ] == ' b ' && $ cb > $ cnt ) { $ cb -- ; $ s [ $ i ] = ' c ' ; $ cc ++ ; } $ i -- ; } return $ s ; } $ s = \" aaaaaa \" ; $ n = strlen ( $ s ) ; echo lexoSmallest ( $ s , $ n ) ; ? >"}
{"text": "Pergerakan minimum untuk mencapai dari I ke J dalam rentetan kitaran | Berfungsi untuk mengembalikan kiraan langkah yang diperlukan untuk bergerak dari saya ke j; Bermula dari i + 1; Kiraan langkah; Watak semasa; Jika watak semasa berbeza dari sebelumnya; Langkah kenaikan; Mengemas kini watak semasa; Mengembalikan jumlah langkah; Berfungsi untuk mengembalikan bilangan langkah minimum yang diperlukan untuk mencapai J dari i; Tukar nilai supaya i <= j; Langkah -langkah untuk pergi dari saya ke J (kiri ke kanan); Semasa pergi dari saya ke J (kanan ke kiri) pertama kali pergi dari saya ke 0 kemudian dari (n - 1) ke j; Jika watak pertama dan terakhir berbeza maka ia akan menambah langkah ke stepstoleft; Mengembalikan minimum dua laluan; Kod pemacu", "code": "< ? php function getSteps ( $ str , $ i , $ j , $ n ) { $ k = $ i + 1 ; $ steps = 0 ; $ ch = $ str [ $ i ] ; while ( $ k <= $ j ) { if ( $ str [ $ k ] != $ ch ) { $ steps ++ ; $ ch = $ str [ $ k ] ; } $ k ++ ; } return $ steps ; } function getMinSteps ( $ str , $ i , $ j , $ n ) { if ( $ j < $ i ) { $ temp = $ i ; $ i = $ j ; $ j = $ temp ; } $ stepsToRight = getSteps ( $ str , $ i , $ j , $ n ) ; $ stepsToLeft = getSteps ( $ str , 0 , $ i , $ n ) + getSteps ( $ str , $ j , $ n - 1 , $ n ) ; if ( $ str [ 0 ] != $ str [ $ n - 1 ] ) $ stepsToLeft ++ ; return min ( $ stepsToLeft , $ stepsToRight ) ; } $ str = \" SSNSS \" ; $ n = strlen ( $ str ) ; $ i = 0 ; $ j = 3 ; echo getMinSteps ( $ str , $ i , $ j , $ n ) ; ? >"}
{"text": "Keluarkan huruf berturut -turut yang dalam kes yang sama | Berfungsi untuk mengembalikan rentetan yang diubah suai; Melintasi watak -watak yang tinggal dalam rentetan; Jika arus dan aksara sebelumnya tidak dalam kes yang sama maka ambil watak; Kod pemacu", "code": "< ? php function removeChars ( $ s ) { $ modifiedStr = \" \" ; $ modifiedStr = $ modifiedStr . $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ctype_upper ( $ s [ $ i ] ) && ctype_lower ( $ s [ $ i - 1 ] ) || ctype_lower ( $ s [ $ i ] ) && ctype_upper ( $ s [ $ i - 1 ] ) ) $ modifiedStr = $ modifiedStr . $ s [ $ i ] ; } return $ modifiedStr ; } $ s = \" GeeksForGeeks \" ; echo removeChars ( $ s ) ; ? >"}
{"text": "Kos untuk membuat rentetan Panagram | Berfungsi untuk mengembalikan jumlah kos yang diperlukan untuk membuat pangram rentetan; Tandakan semua huruf yang berlaku dalam rentetan; Kirakan jumlah kos untuk abjad yang hilang; Kod pemacu", "code": "< ? php function pangramCost ( $ arr , $ str ) { $ cost = 0 ; $ occurred = array ( ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ occurred [ $ i ] = false ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ idx = ord ( $ str [ $ i ] ) - 97 ; $ occurred [ $ idx ] = true ; } for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ occurred [ $ i ] == false ) $ cost += $ arr [ $ i ] ; } return $ cost ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 ) ; $ str = \" abcdefghijklmopqrstuvwz \" ; echo pangramCost ( $ arr , $ str ) ; ? >"}
{"text": "Program rekursif untuk memasukkan bintang antara sepasang aksara yang sama | Berfungsi untuk memasukkan * pada kedudukan yang dikehendaki; Tambah watak semasa; Jika kita mencapai watak terakhir; Jika watak seterusnya adalah sama, tambah ' *'; Kod pemacu", "code": "< ? php function pairStar ( & $ input , & $ output , $ i = 0 ) { $ output = $ output . $ input [ $ i ] ; if ( $ i == strlen ( $ input ) - 1 ) return ; if ( $ input [ $ i ] == $ input [ $ i + 1 ] ) $ output = $ output . ' * ' ; pairStar ( $ input , $ output , $ i +1 ) ; } $ input = \" geeks \" ; $ output = \" \" ; pairStar ( $ input , $ output ) ; echo $ output ; return 0 ; ? >"}
{"text": "Bilangan maksimum penyingkiran berikutnya dari rentetan | Berfungsi untuk mengembalikan operasi maksimum yang mungkin dari jenis yang diberikan yang boleh dilakukan pada STR; Kiraan kenaikan sub - urutan 'g'; Kiraan kenaikan sub - urutan 'gk' jika 'g' boleh didapati; Kiraan kenaikan sub -urutan 'GKS' jika sub -urutan 'GK' muncul sebelum ini; Kembalikan kiraan sub -urutan 'gks'; Kod pemacu", "code": "< ? php function maxOperations ( $ str ) { $ i = $ g = $ gk = $ gks = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == ' g ' ) { $ g ++ ; } else if ( $ str [ $ i ] == ' k ' ) { if ( $ g > 0 ) { $ g -- ; $ gk ++ ; } } else if ( $ str [ $ i ] == ' s ' ) { if ( $ gk > 0 ) { $ gk -- ; $ gks ++ ; } } } return $ gks ; } $ a = \" ggkssk \" ; echo maxOperations ( $ a ) ; ? >"}
{"text": "Rentetan terakhir selepas melakukan operasi yang diberikan | Berfungsi untuk mengembalikan rentetan yang diubah suai; Kiraan bilangan 'x'; Kiraan bilangan 'y'; Min (x, y) bilangan 'x' dan 'y' akan dipadamkan; Kod pemacu", "code": "< ? php function printFinalString ( $ s ) { $ n = strlen ( $ s ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' x ' ) $ x ++ ; else $ y ++ ; } $ finalString = ( string ) null ; if ( $ x > $ y ) for ( $ i = 0 ; $ i < $ x - $ y ; $ i ++ ) $ finalString . = \" x \" ; else for ( $ i = 0 ; $ i < $ y - $ x ; $ i ++ ) $ finalString . = \" y \" ; return $ finalString ; } $ s = \" xxyyxyy \" ; echo printFinalString ( $ s ) ; ? >"}
{"text": "Rentetan yang apabila diulang tepat k kali memberikan permutasi s | Berfungsi untuk mengembalikan rentetan yang apabila diulang tepat k kali memberikan permutasi s; saiz rentetan; kepada kekerapan setiap watak; Dapatkan kekerapan setiap watak; untuk menyimpan jawapan akhir; Semak jika kekerapan boleh dibahagikan dengan k; tambah untuk menjawab; Jika kekerapan tidak dapat dibahagikan dengan k; Kod pemacu; panggilan fungsi", "code": "< ? php function K_String ( $ s , $ k ) { $ n = strlen ( $ s ) ; $ fre = $ array = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ fre [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] ++ ; $ str = \" \" ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ fre [ $ i ] % $ k == 0 ) { $ x = $ fre [ $ i ] / $ k ; while ( $ x -- ) { $ str . = chr ( $ i + ord ( ' a ' ) ) ; } } else { return \" - 1\" ; } } return $ str ; } $ s = \" aabb \" ; $ k = 2 ; echo K_String ( $ s , $ k ) ; ? >"}
{"text": "Kira dan cetak huruf yang mempunyai nilai ASCII tidak dalam julat [l, r] | Fungsi untuk mengira bilangan aksara yang nilai ASCII tidak dalam julat [l, r]; Memulakan kiraan kepada 0; menggunakan peta untuk mencetak watak sekali sahaja; Kenaikan kiraan jika nilai kurang; mengembalikan kiraan; Kod pemacu", "code": "< ? php function CountCharacters ( $ str , $ l , $ r ) { $ cnt = 0 ; $ m = array_fill ( 0 , 256 , NULL ) ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( ! ( $ l <= ord ( $ str [ $ i ] ) and ord ( $ str [ $ i ] ) <= $ r ) ) { $ cnt ++ ; if ( isset ( $ m [ ord ( $ str [ $ i ] ) ] ) != 1 ) { echo $ str [ $ i ] . \" \" ; $ m [ ord ( $ str [ $ i ] ) ] ++ ; } } } return $ cnt ; } $ str = \" geeksforgeeks \" ; $ l = 102 ; $ r = 111 ; echo \" Characters ▁ with ▁ ASCII ▁ values ▁ not ▁ in ▁ the ▁ \" . \" in the given string are : \" echo \" and their count is \" . CountCharacters ( $ str , $ l , $ r ) ; ? >"}
{"text": "Kira bilangan perkataan yang mempunyai jumlah nilai ASCII kurang daripada dan lebih besar daripada k | Berfungsi untuk mengira perkataan; Jumlah nilai ASCII; Bilangan perkataan yang mempunyai jumlah ASCII kurang daripada k; Jika watak adalah ruang; Tambah nilai ASCII kepada jumlah; Mengendalikan perkataan terakhir secara berasingan; Kod pemacu", "code": "< ? php function CountWords ( $ str , $ k ) { $ sum = 0 ; $ NumberOfWords = 0 ; $ counter = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) { if ( $ str [ $ i ] == ' ▁ ' ) { if ( $ sum < $ k ) $ counter ++ ; $ sum = 0 ; $ NumberOfWords ++ ; } else $ sum += ord ( $ str [ $ i ] ) ; } $ NumberOfWords ++ ; if ( $ sum < $ k ) $ counter ++ ; echo \" Number ▁ of ▁ words ▁ having ▁ sum ▁ of ▁ ASCII \" . \" values less than k = \" ▁ . ▁ $ counter ▁ . ▁ \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" Number of words having sum of ASCII \" ▁ . STRNEWLINE TABSYMBOL TABSYMBOL \" values greater than or equal to k = \" ( $ NumberOfWords - $ counter ) ; } $ str = \" Learn ▁ how ▁ to ▁ code \" ; $ k = 400 ; CountWords ( $ str , $ k ) ; ? >"}
{"text": "Cari Count of Palindromic Sub | Program PHP untuk mencari kiraan sub -rentetan rentetan rentetan dalam bentuk menaik; berfungsi untuk mengembalikan kiraan sub -rentetan palindromik; kirakan kekerapan; Hitung kiraan sub -rentetan palindromik; hasil pulangan; Kod pemacu", "code": "< ? php $ MAX_CHAR = 26 ; function countPalindrome ( $ str ) { global $ MAX_CHAR ; $ n = strlen ( $ str ) ; $ sum = 0 ; $ hashTable = array_fill ( 0 , $ MAX_CHAR , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ hashTable [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ hashTable [ $ i ] ) $ sum += ( int ) ( $ hashTable [ $ i ] * ( $ hashTable [ $ i ] + 1 ) / 2 ) ; } return $ sum ; } $ str = \" ananananddd \" ; echo countPalindrome ( $ str ) ; ? >"}
{"text": "Bilangan elemen minimum yang akan dikeluarkan supaya elemen berpasangan berturut -turut adalah sama | Fungsi untuk mengira bilangan elemen minimum untuk dikeluarkan dari nombor supaya dua digit berturut -turut berpasangan adalah sama. ; memulakan pembolehubah pengiraan; Semak sama ada dua digit berturut -turut adalah sama; Kod pemacu", "code": "< ? php function countConsecutive ( $ s ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ i ++ ; else $ count ++ ; } return $ count ; } $ str = \"44522255\" ; echo countConsecutive ( $ str ) ; ? >"}
{"text": "Nombor digit ganjil terkecil tidak kurang daripada n | berfungsi untuk memeriksa sama ada semua digit adalah ganjil nombor tertentu; melangkah untuk semua digit; jika digit adalah walaupun; Semua digit adalah ganjil; berfungsi untuk mengembalikan nombor terkecil dengan semua digit ganjil; Iterat sehingga kita dapati nombor dengan semua digit ganjil; Kod pemacu", "code": "< ? php function check_digits ( $ n ) { while ( $ n > 1 ) { if ( ( $ n % 10 ) % 2 == 0 ) return 0 ; $ n = ( int ) $ n / 10 ; } return 1 ; } function smallest_number ( $ n ) { for ( $ i = $ n ; ; $ i ++ ) if ( check_digits ( $ i ) ) return $ i ; } $ N = 2397 ; echo smallest_number ( $ N ) ; ? >"}
{"text": "Kira dan cetak huruf yang mempunyai nilai ASCII dalam julat [l, r] | Fungsi untuk mengira bilangan aksara yang nilai ASCII berada dalam julat [l, r]; Memulakan kiraan kepada 0; Kenaikan kiraan jika nilai kurang; mengembalikan kiraan; Kod pemacu", "code": "< ? php function CountCharacters ( $ str , $ l , $ r ) { $ cnt = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ l <= ord ( $ str [ $ i ] ) && ord ( $ str [ $ i ] ) <= $ r ) { $ cnt ++ ; echo $ str [ $ i ] . \" \" ; } } return $ cnt ; } $ str = \" geeksforgeeks \" ; $ l = 102 ; $ r = 111 ; echo \" Characters ▁ with ▁ ASCII ▁ values \" . \" ▁ in ▁ the ▁ range ▁ [ l , ▁ r ] ▁ are ▁ STRNEWLINE \" ; echo \" and their count is \" . CountCharacters ( $ str , $ l , $ r ) ; ? >"}
{"text": "Langkah Minimum Untuk Mengeluarkan Substring 010 dari rentetan binari | Berfungsi untuk mencari langkah minimum; substring \"010\" dijumpai; Dapatkan rentetan binari; Cari langkah minimum", "code": "< ? php function minSteps ( $ str ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) - 2 ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) { if ( $ str [ $ i + 1 ] == '1' ) { if ( $ str [ $ i + 2 ] == '0' ) { $ count ++ ; $ i += 2 ; } } } } return $ count ; } $ str = \"0101010\" ; echo ( minSteps ( $ str ) ) ; ? >"}
{"text": "Count of Alphabets mempunyai nilai ASCII kurang daripada dan lebih besar daripada k | Fungsi untuk mengira bilangan aksara yang nilai ASCII kurang daripada k; Memulakan kiraan kepada 0; Meningkatkan kiraan jika nilai kurang; mengembalikan kiraan; Kod pemacu", "code": "< ? php function CountCharacters ( $ str , $ k ) { $ cnt = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] < chr ( $ k ) ) $ cnt += 1 ; } return $ cnt ; } $ str = \" GeeksForGeeks \" ; $ k = 90 ; $ count = CountCharacters ( $ str , $ k ) ; echo ( \" Characters ▁ with ▁ ASCII ▁ values \" . \" ▁ less ▁ than ▁ K ▁ are ▁ \" . $ count ) ; echo ( \" Characters with ASCII values \" ▁ . STRNEWLINE TABSYMBOL \" greater than or equal to K are \" ( strlen ( $ str ) - $ count ) ) ; ? >"}
{"text": "Pengaturan watak -watak perkataan sedemikian rupa sehingga semua vokal berada di tempat yang ganjil | Berfungsi untuk mengembalikan faktorial nombor; mengira NPR; Berfungsi untuk mencari bilangan $ cara di mana watak -watak perkataan dapat diatur sedemikian rupa sehingga vokal hanya menduduki kedudukan yang ganjil; Dapatkan jumlah jawatan walaupun; Dapatkan kedudukan ganjil; Simpan $ kekerapan setiap aksara rentetan; Mengira jumlah vokal; Mengira jumlah konsonan; Hitung jumlah cara; Kod pemacu", "code": "< ? php function fact ( $ n ) { $ f = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ f = $ f * $ i ; } return $ f ; } function npr ( $ n , $ r ) { return fact ( $ n ) / fact ( $ n - $ r ) ; } function countPermutations ( $ str ) { $ even = floor ( strlen ( $ str ) / 2 ) ; $ odd = strlen ( $ str ) - $ even ; $ ways = 0 ; $ freq = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { ++ $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ; } $ nvowels = $ freq [ 0 ] + $ freq [ 4 ] + $ freq [ 8 ] + $ freq [ 14 ] + $ freq [ 20 ] ; $ nconsonants = strlen ( $ str ) - $ nvowels ; $ ways = npr ( $ odd , $ nvowels ) * npr ( $ nconsonants , $ nconsonants ) ; return $ ways ; } $ str = \" geeks \" ; echo countPermutations ( $ str ) ; ? >"}
{"text": "Gantikan konsonan dengan konsonan segera seterusnya mengikut abjad dalam rentetan | Fungsi untuk memeriksa sama ada watak adalah vokal atau tidak; Fungsi yang menggantikan konsonan dengan abjad konsonan segera seterusnya; Mula melintasi rentetan; Jika watak adalah z, daripada menggantikannya dengan watak B; Jika abjad tidak z; Gantikan elemen dengan abjad segera seterusnya; Jika abjad segera seterusnya adalah vokal, daripada mengambil abjad segera ke -2 (kerana tidak ada dua vokal yang berlaku secara berturut -turut dalam abjad) oleh itu tiada pemeriksaan lanjut diperlukan; Kod pemacu", "code": "< ? php function isVowel ( $ ch ) { if ( $ ch != ' a ' && $ ch != ' e ' && $ ch != ' i ' && $ ch != ' o ' && $ ch != ' u ' ) return false ; return true ; } function replaceConsonants ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ! isVowel ( $ s [ $ i ] ) ) { if ( $ s [ $ i ] == ' z ' ) $ s [ $ i ] = ' b ' ; else { $ s [ $ i ] = chr ( ord ( $ s [ $ i ] ) + 1 ) ; if ( isVowel ( $ s [ $ i ] ) ) $ s [ $ i ] = chr ( ord ( $ s [ $ i ] ) + 1 ) ; } } } return $ s ; } $ s = \" geeksforgeeks \" ; echo replaceConsonants ( $ s ) ; ? >"}
{"text": "Kira perubahan dalam lampu LED untuk memaparkan digit satu demi satu | Program PHP untuk mengira nombor ON OFS untuk memaparkan digit nombor. ; Simpan lampu LED yang diperlukan untuk memaparkan nombor tertentu. ; Kirakan perubahan dalam LED dan teruskan menambah perubahan; Kod pemacu", "code": "< ? php function countOnOff ( $ n ) { $ Led = array ( 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 ) ; $ len = strlen ( $ n ) ; $ sum = $ Led [ $ n [ 0 ] - '0' ] ; for ( $ i = 1 ; $ i < $ len ; $ i ++ ) { $ sum = $ sum + abs ( $ Led [ $ n [ $ i ] - '0' ] - $ Led [ $ n [ $ i - 1 ] - '0' ] ) ; } return $ sum ; } $ n = \"082\" ; echo countOnOff ( $ n ) ; ? >"}
{"text": "Maksimum sifar berturut -turut dalam rentetan binari yang disatukan | Mengembalikan saiz maksimum substring yang terdiri hanya daripada sifar selepas Konvensyen K; menyimpan panjang maksimum substring yang diperlukan; Jika watak semasa adalah 0; kedai maksimum panjang substring semasa dengan sifar; Jika keseluruhan $ dipenuhi dengan sifar; mengira panjang awalan maksimum yang mengandungi hanya sifar; mengira panjang akhiran maksimum yang mengandungi hanya sifar; Sekiranya lebih daripada 1 penyambungan dibuat; Kod pemacu", "code": "< ? php function max_length_substring ( $ st , $ n , $ k ) { $ max_len = 0 ; $ len = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ st [ $ i ] == '0' ) $ len ++ ; else $ len = 0 ; $ max_len = max ( $ max_len , $ len ) ; } if ( $ max_len == $ n ) return $ n * $ k ; $ pref = 0 ; $ suff = 0 ; for ( $ i = 0 ; $ st [ $ i ] == '0' ; ++ $ i , ++ $ pref ) ; for ( $ i = $ n - 1 ; $ st [ $ i ] == '0' ; -- $ i , ++ $ suff ) ; if ( $ k > 1 ) $ max_len = max ( $ max_len , $ pref + $ suff ) ; return $ max_len ; } $ n = 6 ; $ k = 3 ; $ st = \"110010\" ; $ ans = max_length_substring ( $ st , $ n , $ k ) ; echo $ ans ; ? >"}
{"text": "Kira bilangan substring dengan nilai angka lebih besar daripada x | Fungsi yang mengira sub -rentetan yang sah; Hanya ambil nombor -nombor yang tidak memulakan w $ ith '0'. ; Menukar sub - str $ ing bermula dari indeks 'i' dan mempunyai panjang 'len' ke int dan memeriksa jika ia lebih besar daripada x atau tidak; Kod pemacu", "code": "< ? php function countSubStr ( $ S , $ X ) { $ cnt = 0 ; $ N = strlen ( $ S ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { if ( $ S [ $ i ] != '0' ) { for ( $ len = 1 ; ( $ i + $ len ) <= $ N ; ++ $ len ) { $ num = intval ( substr ( $ S , $ i , $ len ) ) ; if ( $ num > $ X ) $ cnt ++ ; } } } return $ cnt ; } $ S = \"2222\" ; $ X = 97 ; echo countSubStr ( $ S , $ X ) ; ? >"}
{"text": "Semak sama ada rentetan binari boleh dibentuk dengan menggabungkan Nombor N yang berurutan | Fungsi yang mengembalikan palsu jika nombor yang diluluskan sebagai argumen mengandungi digit selain daripada '0' atau '1'; Fungsi yang memeriksa sama ada rentetan binari boleh dibentuk atau tidak; Rentetan kosong untuk menyimpan nombor binari; Semak sama ada [i] boleh menjadi sebahagian daripada rentetan binari; Penukaran int ke dalam rentetan; jika a [i] tidak boleh menjadi bahagian maka memecahkan gelung; mungkin untuk membuat rentetan binari; mustahil untuk membuat rentetan binari; Kod pemacu", "code": "< ? php function isBinary ( $ n ) { while ( $ n != 0 ) { $ temp = $ n % 10 ; if ( $ temp != 0 && $ temp != 1 ) { return false ; } $ n = intval ( $ n / 10 ) ; } return true ; } function formBinaryStr ( $ n , & $ a ) { $ flag = true ; $ s = \" \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( isBinary ( $ a [ $ i ] ) ) $ s = $ s . strval ( $ a [ $ i ] ) ; else { $ flag = false ; break ; } } if ( $ flag ) echo $ s . \" STRNEWLINE \" ; else echo \" - 1 STRNEWLINE \" ; } $ a = array ( 10 , 1 , 0 , 11 , 10 ) ; $ N = sizeof ( $ a ) / sizeof ( $ a [ 0 ] ) ; formBinaryStr ( $ N , $ a ) ; ? >"}
{"text": "Semak sama ada Palindromic Sub | Fungsi untuk memeriksa sama ada rentetan adalah palindrome; Fungsi yang memeriksa sama ada semua sub -rentetan palindromik adalah panjang ganjil. ; Mewujudkan setiap substring; Sekiranya sub -rentetan adalah panjang dan palindrome maka, kita kembali palsu; Kod pemacu", "code": "< ? php function checkPalindrome ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] != $ s [ strlen ( $ s ) - $ i - 1 ] ) return false ; } return true ; } function CheckOdd ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = \" \" ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ x = $ x . $ s [ $ i ] ; if ( strlen ( $ x ) % 2 == 0 && checkPalindrome ( $ x ) == true ) return false ; } } return true ; } $ s = \" geeksforgeeks \" ; if ( CheckOdd ( $ s ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Bilangan permutasi rentetan di mana semua kejadian watak yang diberikan berlaku bersama | Berfungsi untuk mengembalikan faktorial nombor yang diluluskan sebagai hujah; Berfungsi untuk mendapatkan jumlah permutasi yang memenuhi syarat yang diberikan; Buat perlu menyimpan kiraan setiap watak; Menyimpan watak watak; Mengira bilangan kali watak tertentu datang; Jika watak tertentu tidak hadir dalam rentetan maka kembali 0; Keluarkan kiraan watak tertentu; Jumlah panjang rentetan; Anggapkan semua kejadian watak tertentu sebagai satu watak. ; Mengira faktorial panjang; Bahagikan dengan faktorial no. kejadian semua watak. ; mengembalikan hasilnya; Kod pemacu; Dengan mengandaikan rentetan dan wataknya berada di huruf besar", "code": "< ? php function fact ( $ n ) { $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ result *= $ i ; return $ result ; } function getResult ( $ str , $ ch ) { $ has = array_fill ( 0 , 26 , NULL ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ has [ ord ( $ str [ $ i ] ) - ord ( ' A ' ) ] ++ ; $ particular = $ has [ ord ( $ ch ) - ord ( ' A ' ) ] ; if ( $ particular == 0 ) return 0 ; $ has [ ord ( $ ch ) - ord ( ' A ' ) ] = 0 ; $ total = strlen ( $ str ) ; $ total = $ total - $ particular + 1 ; $ result = fact ( $ total ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ has [ $ i ] > 1 ) { $ result = $ result / fact ( $ has [ $ i ] ) ; } } return $ result ; } $ str = \" MISSISSIPPI \" ; echo getResult ( $ str , ' S ' ) . \" STRNEWLINE \" ; ? >"}
{"text": "Pengaturan kata -kata tanpa mengubah kedudukan relatif vokal dan konsonan | Fungsi ini kembali n! ; Ini akan mengembalikan jumlah cara; Freq mengekalkan kekerapan setiap watak dalam perkataan; Periksa watak adalah vokal atau tidak; Watak -watak yang bukan vokal mestilah konsonan; bilangan cara untuk mengatur vokal; Multiply kedua -duanya kerana ini adalah bebas; String mengandungi hanya huruf besar; Ini akan mengandungi Ans", "code": "< ? php function factorial ( $ n ) { $ res = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } function count1 ( $ word ) { $ freq = array_fill ( 0 , 27 , 0 ) ; for ( $ i = 0 ; $ i < 27 ; $ i ++ ) $ freq [ $ i ] = 0 ; $ vowel = 0 ; $ consonant = 0 ; for ( $ i = 0 ; $ i < strlen ( $ word ) ; $ i ++ ) { $ freq [ ord ( $ word [ $ i ] ) - 65 ] ++ ; if ( $ word [ $ i ] == ' A ' $ word [ $ i ] == ' E ' $ word [ $ i ] == ' I ' $ word [ $ i ] == ' O ' $ word [ $ i ] == ' U ' ) { $ vowel ++ ; } else $ consonant ++ ; } $ vowelArrange = factorial ( $ vowel ) ; $ vowelArrange /= factorial ( $ freq [ 0 ] ) ; $ vowelArrange /= factorial ( $ freq [ 4 ] ) ; $ vowelArrange /= factorial ( $ freq [ 8 ] ) ; $ vowelArrange /= factorial ( $ freq [ 14 ] ) ; $ vowelArrange /= factorial ( $ freq [ 20 ] ) ; $ consonantArrange = factorial ( $ consonant ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ i != 0 && $ i != 4 && $ i != 8 && $ i != 14 && $ i != 20 ) $ consonantArrange /= factorial ( $ freq [ $ i ] ) ; } $ total = $ vowelArrange * $ consonantArrange ; return $ total ; } $ word = \" COMPUTER \" ; $ ans = count1 ( $ word ) ; echo ( $ ans ) ; ? >"}
{"text": "Program untuk mencari produk nilai ASCII aksara dalam rentetan | Berfungsi untuk mencari produk nilai ASCII aksara dalam rentetan; Traverse String untuk mencari produk; Mengembalikan produk; Kod pemacu", "code": "< ? php function productAscii ( $ str ) { $ prod = 1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ prod *= ord ( $ str [ $ i ] ) ; } return $ prod ; } $ str = \" GfG \" ; echo productAscii ( $ str ) ; ? >"}
{"text": "Baki rentetan selepas mengeluarkan kurungan tambahan | Cetak seimbang dan keluarkan kurungan tambahan dari rentetan; Mengekalkan kiraan untuk pembukaan kurungan melintasi rentetan; Semak jika membuka kurungan; cetak str [i] dan kenaikan kenaikan sebanyak 1; Semak jika penutupan pendakap dan kiraan! = 0; kiraan pengurangan sebanyak 1; jika str [i] bukan kurungan penutup mencetaknya; kurungan seimbang jika pembukaan kurungan lebih banyak maka menutup kurungan; mencetak kurungan penutup yang tinggal; Kod pemacu", "code": "< ? php function balancedString ( $ str ) { $ count = 0 ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' ( ' ) { echo $ str [ $ i ] ; $ count ++ ; } else if ( $ str [ $ i ] == ' ) ' && $ count != 0 ) { echo $ str [ $ i ] ; $ count -- ; } else if ( $ str [ $ i ] != ' ) ' ) echo $ str [ $ i ] ; } if ( $ count != 0 ) for ( $ i = 0 ; $ i < $ count ; $ i ++ ) echo \" ) \" ; } $ str = \" gau ) ra ) v ( ku ( mar ( rajput ) ) \" ; balancedString ( $ str ) ; ? >"}
{"text": "Mengira rentetan dengan konsonan dan vokal pada kedudukan alternatif | Fungsi untuk mencari kiraan rentetan; Pembolehubah untuk menyimpan hasil akhir; Gelung melangkah melalui rentetan; Jika '$' hadir pada kedudukan yang sama dalam rentetan; 'Sum' didarab dengan 21; Jika '$' hadir pada kedudukan ganjil dalam rentetan; 'Sum' didarab dengan 5; Biarkan rentetan 'str' menjadi s $$ e $; Hasil cetak", "code": "< ? php function countStrings ( $ s ) { $ sum = 1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ i % 2 == 0 && $ s [ $ i ] == ' $ ' ) $ sum *= 21 ; else if ( $ s [ $ i ] == ' $ ' ) $ sum *= 5 ; } return $ sum ; } $ str = \" s\\ $ \\ $ e\\ $ \" ; echo countStrings ( $ str ) ; ? >"}
{"text": "Keluarkan duplikat dari rentetan dalam O (1) ruang tambahan | Fungsi untuk menghapuskan pendua; menjejaki watak -watak yang dikunjungi; mendapat nilai watak; menjejaki panjang rentetan hasil; Semak sama ada kaunter XTH adalah tidak jelas; menandakan watak semasa seperti yang dikunjungi; Kod pemacu", "code": "< ? php function removeDuplicatesFromString ( $ str ) { $ counter = 0 ; $ i = 0 ; $ size = strlen ( $ str ) ; $ x = 0 ; $ length = 0 ; while ( $ i < $ size ) { $ x = ord ( $ str [ $ i ] ) - 97 ; if ( ( $ counter & ( 1 << $ x ) ) == 0 ) { $ str [ $ length ] = chr ( 97 + $ x ) ; $ counter = $ counter | ( 1 << $ x ) ; $ length ++ ; } $ i ++ ; } return substr ( $ str , 0 , $ length ) ; } $ str = \" geeksforgeeks \" ; echo removeDuplicatesFromString ( $ str ) ; ? >"}
{"text": "Semak jika watak -watak dalam rentetan membentuk palindrome dalam O (1) ruang tambahan | Fungsi utiliti untuk mendapatkan kedudukan watak pertama dalam rentetan; Dapatkan kedudukan watak pertama dalam rentetan; Fungsi utiliti untuk mendapatkan kedudukan watak terakhir dalam rentetan; Dapatkan kedudukan watak terakhir dalam rentetan; Berfungsi untuk memeriksa sama ada watak -watak dalam rentetan yang diberikan membentuk palindrome dalam O (1) ruang tambahan; Break, apabila semua huruf diperiksa; Jika ketidakcocokan dijumpai, pecahkan gelung; Kod pemacu", "code": "< ? php function firstPos ( $ str , $ start , $ end ) { $ firstChar = -1 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { if ( $ str [ $ i ] >= ' a ' and $ str [ $ i ] <= ' z ' ) { $ firstChar = $ i ; break ; } } return $ firstChar ; } function lastPos ( $ str , $ start , $ end ) { $ lastChar = -1 ; for ( $ i = $ start ; $ i >= $ end ; $ i -- ) { if ( $ str [ $ i ] >= ' a ' and $ str [ $ i ] <= ' z ' ) { $ lastChar = $ i ; break ; } } return $ lastChar ; } function isPalindrome ( $ str ) { $ firstChar = 0 ; $ lastChar = count ( $ str ) - 1 ; $ ch = true ; for ( $ i = 0 ; $ i < count ( $ str ) ; $ i ++ ) { $ firstChar = firstPos ( $ str , $ firstChar , $ lastChar ) ; $ lastChar = lastPos ( $ str , $ lastChar , $ firstChar ) ; if ( $ lastChar < 0 or $ firstChar < 0 ) break ; if ( $ str [ $ firstChar ] == $ str [ $ lastChar ] ) { $ firstChar ++ ; $ lastChar -- ; continue ; } $ ch = false ; break ; } return ( $ ch ) ; } $ str = \" m ▁ a ▁ 343 ▁ la ▁ y ▁ a ▁ l ▁ am \" ; if ( isPalindrome ( $ str ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Kuasa maksimum lompat diperlukan untuk mencapai hujung rentetan | Berfungsi untuk mengira kuasa maksimum lompat; Memulakan kiraan dengan 1; Cari watak pada indeks terakhir; Mula melintasi rentetan; Semak sama ada char semasa adalah sama dengan watak terakhir; max_so_far menyimpan nilai maksimum kuasa lompat dari bermula ke kedudukan ith; Tetapkan semula kiraan kepada 1; Selain itu, kenaikan bilangan lompatan / kiraan; Mengembalikan jumlah lompatan maksimum; Kod pemacu", "code": "< ? php function powerOfJump ( $ s ) { $ count = 1 ; $ max_so_far = PHP_INT_MIN ; $ ch = $ s [ strlen ( $ s ) - 1 ] ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ ch ) { if ( $ count > $ max_so_far ) { $ max_so_far = $ count ; } $ count = 1 ; } else $ count ++ ; } return $ max_so_far ; } $ st = \"1010101\" ; echo powerOfJump ( $ st ) ; ? >"}
{"text": "Purata nilai ASCII aksara rentetan yang diberikan | Fungsi untuk mencari purata nilai ASCII chars; gelung untuk menyimpulkan nilai ASCII chars; Mengembalikan purata chars; Kod pemacu", "code": "< ? php function averageValue ( $ s ) { $ sum_char = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ sum_char += ord ( $ s [ $ i ] ) ; } return ( int ) ( $ sum_char / strlen ( $ s ) ) ; } $ s = \" GeeksforGeeks \" ; echo averageValue ( $ s ) ; ? >"}
{"text": "Pencocokan awalan biasa terpanjang | Set | Fungsi utiliti untuk mencari awalan umum antara rentetan pertama dan terakhir; Bandingkan Str1 dan Str2; Fungsi yang mengembalikan awalan biasa terpanjang dari pelbagai rentetan; menyusun set n rentetan; mencetak awalan umum yang pertama dan rentetan terakhir set rentetan; Kod pemacu", "code": "< ? php function commonPrefixUtil ( $ str1 , $ str2 ) { $ result = \" \" ; $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; for ( $ i = 0 , $ j = 0 ; $ i <= $ n1 - 1 && $ j <= $ n2 - 1 ; $ i ++ , $ j ++ ) { if ( $ str1 [ $ i ] != $ str2 [ $ j ] ) break ; $ result = $ result . $ str1 [ $ i ] ; } return ( $ result ) ; } function commonPrefix ( & $ arr , $ n ) { sort ( $ arr ) ; echo commonPrefixUtil ( $ arr [ 0 ] , $ arr [ $ n - 1 ] ) ; } $ arr = array ( \" geeksforgeeks \" , \" geeks \" , \" geek \" , \" geezer \" ) ; $ n = sizeof ( $ arr ) ; commonPrefix ( $ arr , $ n ) ; ? >"}
{"text": "Tambah N Binary Strings | Fungsi ini menambah dua rentetan binari dan hasil pulangan sebagai rentetan ketiga; Memulakan hasil; Memulakan jumlah digit; Traverse kedua -dua rentetan bermula dari watak terakhir; Mengira jumlah digit terakhir dan bawa; Jika jumlah digit semasa adalah 1 atau 3, tambah 1 untuk menghasilkan; Mengira bawa; Berpindah ke digit seterusnya; berfungsi untuk menambah rentetan binari; Kod pemacu", "code": "< ? php function addBinaryUtil ( $ a , $ b ) { $ result = \" \" ; $ s = 0 ; $ i = strlen ( $ a ) - 1 ; $ j = strlen ( $ b ) - 1 ; while ( $ i >= 0 $ j >= 0 $ s == 1 ) { $ s += ( ( $ i >= 0 ) ? ord ( $ a [ $ i ] ) - ord ( '0' ) : 0 ) ; $ s += ( ( $ j >= 0 ) ? ord ( $ b [ $ j ] ) - ord ( '0' ) : 0 ) ; $ result = chr ( $ s % 2 + ord ( '0' ) ) . $ result ; $ s = ( int ) ( $ s / 2 ) ; $ i -- ; $ j -- ; } return $ result ; } function addBinary ( $ arr , $ n ) { $ result = \" \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result = addBinaryUtil ( $ result , $ arr [ $ i ] ) ; return $ result ; } $ arr = array ( \"1\" , \"10\" , \"11\" ) ; $ n = count ( $ arr ) ; echo addBinary ( $ arr , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Awalan dengan lebih banyak daripada b | Fungsi untuk mengira awalan; Mengira rentetan s; kiraan == 0 atau apabila n == 1; Apabila semua aksara adalah A atau A - B == 0; Memeriksa ketepuan rentetan selepas penambahan berulang; Kod pemacu", "code": "< ? php function prefix ( $ k , $ n ) { $ a = 0 ; $ b = 0 ; $ count = 0 ; $ i = 0 ; $ len = strlen ( $ k ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ k [ $ i ] == ' a ' ) $ a ++ ; if ( $ k [ $ i ] == ' b ' ) $ b ++ ; if ( $ a > $ b ) { $ count ++ ; } } if ( $ count == 0 $ n == 1 ) { echo ( $ count ) ; return 0 ; } if ( $ count == $ len $ a - $ b == 0 ) { echo ( $ count * $ n ) ; return 0 ; } $ n2 = $ n - 1 ; $ count2 = 0 ; while ( $ n2 != 0 ) { for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ k [ $ i ] == ' a ' ) $ a ++ ; if ( $ k [ $ i ] == ' b ' ) $ b ++ ; if ( $ a > $ b ) { $ count2 ++ ; } } $ count += $ count2 ; $ n2 -- ; if ( $ count2 == 0 ) break ; if ( $ count2 == $ len ) { $ count += ( $ n2 * $ count2 ) ; break ; } $ count2 = 0 ; } return $ count ; } $ S = \" aba \" ; $ N = 2 ; echo ( prefix ( $ S , $ N ) . \" \" ) ; $ S = \" baa \" ; $ N = 3 ; echo ( prefix ( $ S , $ N ) . \" \" ) ;"}
{"text": "Bilangan rentetan asas biasa untuk dua rentetan | Fungsi untuk mencari pembahagi biasa. ; Memeriksa jika 'asas' adalah rentetan asas 'S1'; Memeriksa jika 'asas' adalah rentetan asas 'S2'; Kod pemacu", "code": "< ? php function isCommonBase ( $ base , $ s1 , $ s2 ) { for ( $ j = 0 ; $ j < strlen ( $ s1 ) ; ++ $ j ) if ( $ base [ $ j % strlen ( $ base ) ] != $ s1 [ $ j ] ) return false ; for ( $ j = 0 ; $ j < strlen ( $ s2 ) ; ++ $ j ) if ( $ base [ $ j % strlen ( $ base ) ] != $ s2 [ $ j ] ) return false ; return true ; } function countCommonBases ( $ s1 , $ s2 ) { $ n1 = strlen ( $ s1 ) ; $ n2 = strlen ( $ s2 ) ; $ count = 0 ; for ( $ i = 1 ; $ i <= min ( $ n1 , $ n2 ) ; $ i ++ ) { $ base = substr ( $ s1 , 0 , $ i ) ; if ( isCommonBase ( $ base , $ s1 , $ s2 ) ) $ count ++ ; } return $ count ; } $ s1 = \" pqrspqrs \" ; $ s2 = \" pqrspqrspqrspqrs \" ; echo countCommonBases ( $ s1 , $ s2 ) . \" STRNEWLINE \" ; ? >"}
{"text": "Sempurna Square String | Program PHP untuk mencari jika rentetan adalah persegi yang sempurna atau tidak. ; mengira panjang rentetan; mengira nilai ASCII rentetan; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Kod pemacu", "code": "< ? php function isPerfectSquareString ( $ str ) { $ sum = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ sum += ( int ) $ str [ $ i ] ; $ squareRoot = sqrt ( $ sum ) ; return ( ( $ squareRoot - floor ( $ squareRoot ) ) == 0 ) ; } $ str = \" d \" ; if ( isPerfectSquareString ( $ str ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Keluarkan vokal berturut -turut dari rentetan | fungsi yang mengembalikan benar atau palsu untuk berlakunya vokal; Ini membandingkan vokal dengan watak 'c'; berfungsi untuk mencetak rentetan hasil; cetak 1 watak st; gelung untuk memeriksa setiap watak; perbandingan watak berturut -turut; Kod pemacu", "code": "< ? php function is_vow ( $ c ) { return ( $ c == ' a ' ) || ( $ c == ' e ' ) || ( $ c == ' i ' ) || ( $ c == ' o ' ) || ( $ c == ' u ' ) ; } function removeVowels ( $ str ) { printf ( $ str [ 0 ] ) ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ( ! is_vow ( $ str [ $ i - 1 ] ) ) || ( ! is_vow ( $ str [ $ i ] ) ) ) printf ( $ str [ $ i ] ) ; } $ str = \" ▁ geeks ▁ for ▁ geeks \" ; removeVowels ( $ str ) ; ? >"}
{"text": "Mengubah rentetan supaya ia mempunyai ABCD. . Z Sebagai Susunan | berfungsi untuk mengubah rentetan dengan rentetan diluluskan sebagai rujukan; memulakan pembolehubah CH ke 'A'; Jika panjang rentetan kurang daripada 26, kita tidak dapat memperolehnya yang diperlukan; Jika Ch telah mencapai 'Z', ini bermakna kita telah mengubah rentetan kita supaya yang diperlukan seterusnya dapat diperoleh; Watak semasa tidak lebih besar daripada CH, kemudian menggantikannya dengan CH dan kenaikan CH; Kod pemacu", "code": "< ? php function transformString ( & $ s ) { $ ch = \" a \" ; if ( strlen ( $ s ) < 26 ) return false ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ ch ) > ord ( \" z \" ) ) break ; if ( $ s [ $ i ] <= $ ch ) { $ s [ $ i ] = $ ch ; $ ch = chr ( ord ( $ ch ) + 1 ) ; } } if ( $ ch <= \" z \" ) return false ; return true ; } $ str = \" aaaaaaaaaaaaaaaaaaaaaaaaaa \" ; if ( transformString ( $ str ) ) echo $ str ; else echo \" Not ▁ Possible \" ; ? >"}
{"text": "Bilangan Pasangan Dengan Konvensyen Pandigital | Cek jika $ yang diberikan adalah pandigital; Digit I tidak hadir sehingga tidak pandigital; Mengembalikan bilangan pasang rentetan yang mengakibatkan penggabungan pandigital; melangkah ke atas semua sepasang rentetan; Kod pemacu", "code": "< ? php function isPanDigital ( $ s ) { $ digits = array ( ) ; $ digits = array_fill ( 0 , 10 , false ) ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) $ digits [ ord ( $ s [ $ i ] ) - ord ( '0' ) ] = true ; for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) if ( $ digits [ $ i ] == false ) return false ; return true ; } function countPandigitalPairs ( & $ v ) { $ pairs = 0 ; for ( $ i = 0 ; $ i < count ( $ v ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < count ( $ v ) ; $ j ++ ) { if ( isPanDigital ( $ v [ $ i ] . $ v [ $ j ] ) ) { $ pairs ++ ; } } } return $ pairs ; } $ v = array ( \"123567\" , \"098234\" , \"14765\" , \"19804\" ) ; echo ( countPandigitalPairs ( $ v ) ) ; ? >"}
{"text": "Perubahan minimum kepada rentetan untuk menjadikan semua substrings berbeza | Mengembalikan perubahan minimum kepada STR supaya tiada substring diulang. ; Jika panjang lebih daripada aksara yang dibenarkan maksimum, kita tidak boleh mendapatkan rentetan yang diperlukan. ; Pembolehubah untuk menyimpan kiraan watak yang berbeza; Untuk menyimpan bilangan watak yang berbeza; Jawapannya, n - bilangan char yang berbeza; Kod pemacu", "code": "< ? php function minChanges ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n > 26 ) return -1 ; $ dist_count = 0 ; $ count = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ count [ ord ( $ str [ $ i ] ) - 97 ] == 0 ) $ dist_count ++ ; $ count [ ord ( $ str [ $ i ] ) - 97 ] ++ ; } return ( $ n - $ dist_count ) ; } $ str = \" aebaecedabbee \" ; echo minChanges ( $ str ) ; ? >"}
{"text": "Bilangan rentetan panjang n tanpa rentetan subindromik | Kembalikan kiraan rentetan tanpa substring palindromik. ; Kod pemacu", "code": "< ? php function numofstring ( $ n , $ m ) { if ( $ n == 1 ) return $ m ; if ( $ n == 2 ) return $ m * ( $ m - 1 ) ; return $ m * ( $ m - 1 ) * pow ( $ m - 2 , $ n - 2 ) ; } { $ n = 2 ; $ m = 3 ; echo numofstring ( $ n , $ m ) ; return 0 ; } ? >"}
{"text": "Kira Palindromes Khas dalam rentetan | Berfungsi untuk mengira Susbstring Palindromik Khas; kiraan kedai substring palindromik khas; Ia akan menyimpan kiraan berterusan char yang sama; melintasi watak rentetan dari kiri ke kanan; Simpan kiraan watak yang sama; mengira watak smiler; Kes: 1 Jadi jumlah substring yang boleh kita hasilkan ialah: k * (k + 1) / 2 di sini k adalah samecharcount; Simpan kiraan char yang sama semasa dalam array Samechar []; kenaikan i; Kes 2: Kira semua substring Palindromik Khas Panjang Panjang; Jika watak semasa adalah sama dengan yang sebelumnya maka kami memberikan kiraan aksara yang sama sebelum ini kepada yang ada sekarang; Kes 2: Panjang ganjil; tolak semua substring panjang tunggal; Kod pemacu", "code": "< ? php function CountSpecialPalindrome ( $ str ) { $ n = strlen ( $ str ) ; $ result = 0 ; $ sameChar = array_fill ( 0 , $ n , 0 ) ; $ i = 0 ; while ( $ i < $ n ) { $ sameCharCount = 1 ; $ j = $ i + 1 ; while ( $ j < $ n ) { if ( $ str [ $ i ] != $ str [ $ j ] ) break ; $ sameCharCount ++ ; $ j ++ ; } $ result += ( int ) ( $ sameCharCount * ( $ sameCharCount + 1 ) / 2 ) ; $ sameChar [ $ i ] = $ sameCharCount ; $ i = $ j ; } for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ str [ $ j ] == $ str [ $ j - 1 ] ) $ sameChar [ $ j ] = $ sameChar [ $ j - 1 ] ; if ( $ j > 0 && $ j < ( $ n - 1 ) && ( $ str [ $ j - 1 ] == $ str [ $ j + 1 ] && $ str [ $ j ] != $ str [ $ j - 1 ] ) ) $ result += $ sameChar [ $ j - 1 ] < $ sameChar [ $ j + 1 ] ? $ sameChar [ $ j - 1 ] : $ sameChar [ $ j + 1 ] ; } return $ result - $ n ; } $ str = \" abccba \" ; echo CountSpecialPalindrome ( $ str ) ; ? >"}
{"text": "Cetak nombor pendakap | berfungsi untuk mencetak nombor kurungan; digunakan untuk mencetak nombor pendakap untuk pendakap kiri; digunakan untuk mendapatkan nombor kurungan untuk pendakap yang betul; melintasi ekspresi 'exp' yang diberikan; Jika watak semasa adalah kurungan kiri; cetak 'kiri _ bnum' ,; tolak 'kiri _ bum' ke stack 'kanan _ bnum'; kenaikan 'kiri _ bnum' oleh 1; lain jika watak semasa adalah pendakap yang betul; Cetak elemen atas stack 'kanan _ bnum' ia akan menjadi nombor pendakap yang betul; Pop elemen teratas dari timbunan; Kod pemacu", "code": "< ? php function printBracketNumber ( $ exp , $ n ) { $ left_bnum = 1 ; $ right_bnum = array ( ) ; $ t = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ exp [ $ i ] == ' ( ' ) { echo $ left_bnum . \" \" ; $ right_bnum [ $ t ++ ] = $ left_bnum ; $ left_bnum ++ ; } else if ( $ exp [ $ i ] == ' ) ' ) { echo $ right_bnum [ $ t - 1 ] . \" \" ; $ right_bnum [ $ t - 1 ] = 1 ; $ t -- ; } } } $ exp = \" ( a + ( b * c ) ) + ( d / e ) \" ; $ n = strlen ( $ exp ) ; printBracketNumber ( $ exp , $ n ) ; ? >"}
{"text": "Cari jika rentetan bermula dan berakhir dengan rentetan lain yang diberikan | Program PHP untuk mencari sama ada rentetan sudut yang diberikan hadir di sudut. ; Jika panjang rentetan sudut lebih, ia tidak boleh hadir di sudut. ; Kembali benar jika rentetan sudut hadir di kedua -dua sudut rentetan yang diberikan. ; Kod pemacu", "code": "< ? php function isCornerPresent ( $ str , $ corner ) { $ n = strlen ( $ str ) ; $ cl = strlen ( $ corner ) ; if ( $ n < $ cl ) return false ; return ( ! strcmp ( substr ( $ str , 0 , $ cl ) , $ corner ) && ! strcmp ( substr ( $ str , $ n - $ cl , $ cl ) , $ corner ) ) ; } $ str = \" geeksforgeeks \" ; $ corner = \" geeks \" ; if ( isCornerPresent ( $ str , $ corner ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Menukar satu rentetan ke Lain Menggunakan Append dan Padam Operasi Terakhir | Pulangan benar jika mungkin untuk menukar STR1 ke STR2 menggunakan operasi K. ; Kes a (i); mencari panjang biasa kedua -dua rentetan; Kes A (ii) -; Kes b; Kod pemacu", "code": "< ? php function isConvertible ( $ str1 , $ str2 , $ k ) { if ( ( strlen ( $ str1 ) + strlen ( $ str2 ) ) < $ k ) return true ; $ commonLength = 0 ; for ( $ i = 0 ; $ i < min ( strlen ( $ str1 ) , strlen ( $ str2 ) ) ; $ i ++ ) { if ( $ str1 == $ str2 ) $ commonLength += 1 ; else break ; } if ( ( $ k - strlen ( $ str1 ) - strlen ( $ str2 ) + 2 * $ commonLength ) % 2 == 0 ) return true ; return false ; } $ str1 = \" geek \" ; $ str2 = \" geek \" ; $ k = 7 ; if ( isConvertible ( $ str1 , $ str2 , $ k ) ) echo \" Yes \" . \" STRNEWLINE \" ; else echo \" No \" . \" STRNEWLINE \" ; $ str1 = \" geeks \" ; $ str2 = \" geek \" ; $ k = 5 ; if ( isConvertible ( $ str1 , $ str2 , $ k ) ) echo \" Yes \" . \" STRNEWLINE \" ; else echo \" No \" . \" STRNEWLINE \" ; ? >"}
{"text": "Maksimum huruf kecil yang berbeza antara dua huruf besar | Program PHP untuk mencari huruf kecil maksimum yang terdapat di antara dua huruf besar; Fungsi yang mengira bilangan maksimum huruf kecil yang berbeza antara dua huruf besar; Mengabaikan watak huruf kecil pada mulanya. ; Kami bermula dari surat modal pertama dan melintasi watak yang tinggal. ; Jika watak berada dalam huruf besar ,; Mengira semua watak kes yang lebih rendah; Mengemas kini kiraan maksimum; Reset Count Array; Jika watak berada dalam huruf kecil; Kod pemacu", "code": "< ? php $ MAX_CHAR = 26 ; function maxLower ( $ str ) { global $ MAX_CHAR ; $ n = strlen ( $ str ) ; $ i = 0 ; for ( ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) { $ i ++ ; break ; } } $ maxCount = 0 ; $ count = array_fill ( 0 , $ MAX_CHAR , NULL ) ; for ( ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) { $ currCount = 0 ; for ( $ j = 0 ; $ j < $ MAX_CHAR ; $ j ++ ) if ( $ count [ $ j ] > 0 ) $ currCount ++ ; $ maxCount = max ( $ maxCount , $ currCount ) ; $ count = array_fill ( 0 , $ MAX_CHAR , NULL ) ; } if ( $ str [ $ i ] >= ' a ' && $ str [ $ i ] <= ' z ' ) $ count [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; } return $ maxCount ; } $ str = \" zACaAbbaazzC \" ; echo maxLower ( $ str ) ; ? >"}
{"text": "Huruf besar pertama dalam rentetan (berulang dan rekursif) | Fungsi untuk mencari rentetan yang mempunyai watak pertama setiap perkataan. ; Kod pemacu", "code": "< ? php function first ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ctype_upper ( $ str [ $ i ] ) ) { return $ str [ $ i ] ; } return 0 ; } $ str = \" geeksforGeeKS \" ; $ res = first ( $ str ) ; if ( ord ( $ res ) == ord ( 0 ) ) echo \" No ▁ uppercase ▁ letter \" ; else echo $ res . \" STRNEWLINE \" ; ? >"}
{"text": "Mengira walaupun substring nilai perpuluhan dalam rentetan binari | Menjana semua substring dalam ARR [0 .. n - 1]; Simpan kiraan; Pilih titik permulaan; Memilih titik akhir; substring antara titik permulaan dan akhir semasa; Kuasa kenaikan 2 demi satu; Kod pemacu", "code": "< ? php function evenDecimalValue ( $ str , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ decimalValue = 0 ; $ powerOf2 = 1 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) { $ decimalValue += ( ( $ str [ $ k ] - '0' ) * $ powerOf2 ) ; $ powerOf2 *= 2 ; } if ( $ decimalValue % 2 == 0 ) $ result ++ ; } } return $ result ; } $ str = \"10010\" ; $ n = 5 ; echo evenDecimalValue ( $ str , $ n ) ; ? >"}
{"text": "Buat rentetan baru dengan menggabungkan watak -watak dua bahagian rentetan dalam Reverse | Fungsi melakukan pengiraan; Mengira dua bahagian rentetan S sebagai pertama dan kedua. Rentetan akhir p; Ia menyertai watak -watak untuk rentetan akhir dalam urutan terbalik; Ia menyertai watak -watak untuk rentetan akhir dalam urutan terbalik; Kod pemacu; Fungsi panggilan", "code": "< ? php function solve ( $ s ) { $ l = strlen ( $ s ) ; $ x = $ l / 2 ; $ y = $ l ; $ p = \" \" ; while ( $ x > 0 && $ y > $ l / 2 ) { $ p = $ p . $ s [ $ x - 1 ] ; $ x -- ; $ p = $ p . $ s [ $ y - 1 ] ; $ y -- ; } if ( $ y > $ l / 2 ) { $ p = $ p . $ s [ $ y - 1 ] ; $ y -- ; } echo $ p ; } $ s = \" sunshine \" ; solve ( $ s ) ; ? >"}
{"text": "Program untuk panjang rentetan menggunakan rekursi | Berfungsi untuk mengira panjang; Jika kita sampai pada akhir rentetan; Kod pemacu", "code": "< ? php function recLen ( & $ str , $ i ) { if ( $ i == strlen ( $ str ) ) return 0 ; else return 1 + recLen ( $ str , $ i + 1 ) ; } $ str = \" GeeksforGeeks \" ; echo ( recLen ( $ str , 0 ) ) ; ? >"}
{"text": "Kira konsonan dalam rentetan (kaedah berulang dan rekursif) | Berfungsi untuk memeriksa konsonan; Untuk mengendalikan kes yang lebih rendah; Untuk memeriksa adalah watak adalah konsonan; Kod pemacu", "code": "< ? php function isConsonant ( $ ch ) { $ ch = strtoupper ( $ ch ) ; return ! ( $ ch == ' A ' $ ch == ' E ' $ ch == ' I ' $ ch == ' O ' $ ch == ' U ' ) && ord ( $ ch ) >= 65 && ord ( $ ch ) <= 90 ; } function totalConsonants ( $ str ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( isConsonant ( $ str [ $ i ] ) ) ++ $ count ; return $ count ; } $ str = \" abc ▁ de \" ; echo totalConsonants ( $ str ) ; return 0 ; ? >"}
{"text": "Semak jika perwakilan binari sebenar nombor adalah palindrome | berfungsi untuk membalikkan bit nombor; melintasi bit 'n' dari kanan; Bitwise kiri Shift 'Rev' oleh 1; jika bit semasa ialah '1'; Bitwise kanan shift 'n' oleh 1; nombor yang diperlukan; berfungsi untuk memeriksa sama ada perwakilan binari nombor adalah palindrome atau tidak; Dapatkan nombor dengan membalikkan bit dalam perwakilan binari 'n'; Kod pemacu", "code": "< ? php function reverseBits ( $ n ) { $ rev = 0 ; while ( $ n > 0 ) { $ rev <<= 1 ; if ( $ n & 1 == 1 ) $ rev ^= 1 ; $ n >>= 1 ; } return $ rev ; } function isPalindrome ( $ n ) { $ rev = reverseBits ( $ n ) ; return ( $ n == $ rev ) ; } $ n = 9 ; if ( isPalindrome ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; return 0 ; ? >"}
{"text": "Cari susunan barisan pada masa yang diberikan | mencetak susunan pada masa = t; Memeriksa keseluruhan giliran untuk setiap saat dari masa = 1 hingga masa = t. ; Jika indeks semasa mengandungi 'b' dan indeks seterusnya mengandungi 'g' kemudian swap; Kod pemacu", "code": "< ? php function solve ( $ n , $ t , $ s ) { for ( $ i = 0 ; $ i < $ t ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - 1 ; $ j ++ ) { if ( $ s [ $ j ] == ' B ' && $ s [ $ j + 1 ] == ' G ' ) { $ temp = $ s [ $ j ] ; $ s [ $ j ] = $ s [ $ j + 1 ] ; $ s [ $ j + 1 ] = $ temp ; $ j ++ ; } } } echo ( $ s ) ; } $ n = 6 ; $ t = 2 ; $ s = \" BBGBBG \" ; solve ( $ n , $ t , $ s ) ; ? >"}
{"text": "Tambah dua nombor yang diwakili oleh dua tatasusunan | Kembali jumlah dua nombor yang diwakili oleh tatasusunan. Saiz A [] lebih besar daripada B []. Ia pasti menjadi fungsi pembalut; array untuk menyimpan jumlah. ; Sehingga kita mencapai permulaan array. Kami hanya membandingkan untuk array kedua kerana kami telah membandingkan saiz array dalam fungsi pembalut. ; Cari jumlah elemen yang sama dari kedua -dua array. ; Mencari Carry untuk Jumlah Seterusnya. ; Jika saiz array kedua kurang daripada saiz array pertama. ; Tambah bawa ke elemen array pertama. ; Sekiranya terdapat untuk menambah 0 elemen indeks. Tambah 1 hingga Jumlah Jumlah. ; Menukar array ke dalam nombor. ; Fungsi pembalut; Membuat array pertama yang mempunyai bilangan elemen yang lebih besar; Kod yang didorong", "code": "< ? php function calSumUtil ( $ a , $ b , $ n , $ m ) { $ sum = array ( ) ; $ i = $ n - 1 ; $ j = $ m - 1 ; $ k = $ n - 1 ; $ carry = 0 ; $ s = 0 ; while ( $ j >= 0 ) { $ s = $ a [ $ i ] + $ b [ $ j ] + $ carry ; $ sum [ $ k ] = ( $ s % 10 ) ; $ carry = $ s / 10 ; $ k -- ; $ i -- ; $ j -- ; } while ( $ i >= 0 ) { $ s = $ a [ $ i ] + $ carry ; $ sum [ $ k ] = ( $ s % 10 ) ; $ carry = $ s / 10 ; $ i -- ; $ k -- ; } $ ans = 0 ; if ( $ carry ) $ ans = 10 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ ans += $ sum [ $ i ] ; $ ans *= 10 ; } return $ ans / 10 ; } function calSum ( $ a , $ b , $ n , $ m ) { if ( $ n >= $ m ) return calSumUtil ( $ a , $ b , $ n , $ m ) ; else return calSumUtil ( $ b , $ a , $ m , $ n ) ; } $ a = array ( 9 , 3 , 9 ) ; $ b = array ( 6 , 1 ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; echo calSum ( $ a , $ b , $ n , $ m ) ; ? >"}
{"text": "Susunan anagram biasa terpanjang | Pelaksanaan PHP untuk mencari panjang seterusnya anagram biasa yang paling lama; berfungsi untuk mencari panjang seterusnya anagram biasa yang paling lama; Jadual hash untuk menyimpan frekuensi setiap watak; Kirakan kekerapan setiap watak 'str1'; Kirakan kekerapan setiap watak 'str2'; Bagi setiap watak tambahkan kekerapan minimum daripada dua rentetan dalam 'len'; panjang yang diperlukan; Kod pemacu", "code": "< ? php $ SIZE = 26 ; function longCommomAnagramSubseq ( $ str1 , $ str2 , $ n1 , $ n2 ) { global $ SIZE ; $ freq1 = array ( ) ; $ freq2 = array ( ) ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ freq1 [ $ i ] = 0 ; $ freq2 [ $ i ] = 0 ; } $ len = 0 ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) $ freq1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ n2 ; $ i ++ ) $ freq2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ len += min ( $ freq1 [ $ i ] , $ freq2 [ $ i ] ) ; } return $ len ; } $ str1 = \" abdacp \" ; $ str2 = \" ckamb \" ; $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; echo ( \" Length ▁ = ▁ \" . longCommomAnagramSubseq ( $ str1 , $ str2 , $ n1 , $ n2 ) ) ; ? >"}
{"text": "Tetingkap panalphabetic dalam rentetan | Pulangan jika diberikan rentetan mengandungi tetingkap panalphabetic. ; melintasi rentetan; Jika watak rentetan sama dengan CH, kenaikan ch. ; Jika semua watak dijumpai, kembali benar. ; Kod pemacu", "code": "< ? php function isPanalphabeticWindow ( $ s , $ n ) { $ ch = ' a ' ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ ch ) $ ch ++ ; if ( $ ch == ' z ' ) return true ; } return false ; } $ s = \" abujm ▁ zvcd ▁ acefc ▁ deghf ▁ gijkle \" . \" ▁ m ▁ n ▁ o ▁ p ▁ pafqrstuvwxyzfap \" ; $ n = strlen ( $ s ) ; if ( isPanalphabeticWindow ( $ s , $ n ) ) echo ( \" YES \" ) ; else echo ( \" NO \" ) ; ? >"}
{"text": "Program untuk mencetak aksara yang hadir di Indeks Perdana dalam rentetan yang diberikan | Program PHP untuk mencetak aksara di Indeks Perdana dalam rentetan yang diberikan; Kes sudut; Semak dari 2 hingga n - 1; Berfungsi untuk mencetak watak pada Indeks Perdana; Gelung untuk memeriksa sama ada indeks utama atau tidak; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) return false ; return true ; } function prime_index ( $ input ) { $ n = strlen ( $ input ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) if ( isPrime ( $ i ) ) echo $ input [ $ i - 1 ] ; } $ input = \" GeeksforGeeks \" ; prime_index ( $ input ) ; ? >"}
{"text": "Semak sama ada rentetan yang diberikan adalah heterogram atau tidak | Program PHP untuk memeriksa sama ada rentetan yang diberikan adalah heterogram atau tidak. ; melintasi rentetan. ; abaikan ruang; jika sudah ditemui; lain kembali palsu. ; Kod yang didorong", "code": "< ? php function isHeterogram ( $ s , $ n ) { $ hash = array ( ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ hash [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] != ' ▁ ' ) { if ( $ hash [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] == 0 ) $ hash [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] = 1 ; else return false ; } } return true ; } $ s = \" the ▁ big ▁ dwarf ▁ only ▁ jumps \" ; $ n = strlen ( $ s ) ; if ( isHeterogram ( $ s , $ n ) ) echo ( \" YES \" ) ; else echo ( \" NO \" ) ; ? >"}
{"text": "Cetak yang diberikan ayat ke dalam bentuk ASCII yang setara | Berfungsi untuk mengira nilai ASCII setiap watak satu demi satu; Kod pemacu", "code": "< ? php function ASCIISentence ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) echo ord ( $ str [ $ i ] ) ; } $ str = \" GeeksforGeeks \" ; echo \" ASCII ▁ Sentence : \" . \" STRNEWLINE \" ; ASCIISentence ( $ str ) ; ? >"}
{"text": "Kes ular ayat yang diberikan | Berfungsi untuk menggantikan ruang dan menukar ke dalam kes ular; Menukar ruang untuk menggariskan; Jika tidak ruang, tukar menjadi watak yang lebih rendah; Kod pemacu; Fungsi panggilan", "code": "< ? php function convert ( $ str ) { $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' ▁ ' ) $ str [ $ i ] = ' _ ' ; else $ str [ $ i ] = strtolower ( $ str [ $ i ] ) ; } echo $ str ; } $ str = \" I ▁ got ▁ intern ▁ at ▁ geeksforgeeks \" ; convert ( $ str ) ; ? >"}
{"text": "Gantikan aksara C1 dengan C2 dan C2 dengan C1 dalam rentetan S | Program PHP untuk menggantikan C1 dengan C2 dan C2 dengan C1; gelung untuk melintasi rentetan; Semak C1 dan ganti; Semak C2 dan ganti; Kod pemacu", "code": "< ? php function replace ( $ s , $ c1 , $ c2 ) { $ l = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ s [ $ i ] == $ c1 ) $ s [ $ i ] = $ c2 ; else if ( $ s [ $ i ] == $ c2 ) $ s [ $ i ] = $ c1 ; } return $ s ; } $ s = \" grrksfoegrrks \" ; $ c1 = ' e ' ; $ c2 = ' r ' ; echo replace ( $ s , $ c1 , $ c2 ) ; ? >"}
{"text": "Membina palindrome terkecil secara leksikografi | fungsi untuk percetakan palindrome; melangkah sehingga saya <j; Teruskan jika str [i] == str [j]; kemas kini str [i] = str [j] = 'a' jika kedua -duanya adalah ' *'; kemas kini str [i] = str [j] jika hanya str [i] = ' *'; kemas kini str [j] = str [i] jika hanya str [j] = ' *'; lain cetak tidak mungkin dan kembali; Kod pemacu", "code": "< ? php function constructPalin ( $ str , $ len ) { $ i = 0 ; $ j = $ len - 1 ; for ( ; $ i < $ j ; $ i ++ , $ j -- ) { if ( $ str [ $ i ] == $ str [ $ j ] && $ str [ $ i ] != ' * ' ) continue ; else if ( $ str [ $ i ] == $ str [ $ j ] && $ str [ $ i ] == ' * ' ) { $ str [ $ i ] = ' a ' ; $ str [ $ j ] = ' a ' ; continue ; } else if ( $ str [ $ i ] == ' * ' ) { $ str [ $ i ] = $ str [ $ j ] ; continue ; } else if ( $ str [ $ j ] == ' * ' ) { $ str [ $ j ] = $ str [ $ i ] ; continue ; } echo \" Not ▁ Possible \" ; return \" \" ; } return $ str ; } $ str = \" bca * xc * * b \" ; $ len = strlen ( $ str ) ; echo constructPalin ( $ str , $ len ) ; ? >"}
{"text": "Percetakan rentetan dalam corak ' +' dalam matriks | Berfungsi untuk membuat salib dalam matriks; Seperti, tidak mungkin untuk membuat salib tepat di tengah -tengah matriks dengan rentetan panjang yang lebih panjang. ; mengisytiharkan array 2d i. e matriks; Sekarang, kami akan mengisi semua elemen array dengan 'X'; Sekarang, kita akan meletakkan watak -watak rentetan dalam matriks, supaya salib terbentuk di dalamnya. ; Di sini watak -watak rentetan akan ditambah di lajur tengah array kami. ; Di sini watak -watak rentetan akan ditambah di barisan tengah array kami. ; Sekarang akhirnya, kami akan mencetak array; Kod pemacu", "code": "< ? php function carveCross ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n % 2 == 0 ) { echo ( \" Not ▁ possible . ▁ Please ▁ enter ▁ \" ) ; echo ( \" odd ▁ length ▁ string . STRNEWLINE \" ) ; } else { $ arr = array ( ) ; $ m = $ n / 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ arr [ $ i ] [ $ j ] = ' X ' ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ i ] [ $ m ] = $ str [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ m ] [ $ i ] = $ str [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { echo ( $ arr [ $ i ] [ $ j ] . \" \" ) ; } echo ( \" STRNEWLINE \" ) ; } } } $ str = \" PICTURE \" ; carveCross ( $ str ) ; ? >"}
{"text": "Program untuk mencari baki apabila bilangan besar dibahagikan dengan 11 | Berfungsi untuk mengembalikan baki; Len adalah berubah -ubah untuk menyimpan panjang rentetan nombor. ; gelung yang mencari selebihnya; Kod pemacu", "code": "< ? php function remainder ( $ str ) { $ len = strlen ( $ str ) ; $ num ; $ rem = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ num = $ rem * 10 + ( $ str [ $ i ] - '0' ) ; $ rem = $ num % 11 ; } return $ rem ; } $ str = \"3435346456547566345436457867978\" ; echo ( remainder ( $ str ) ) ; ? >"}
{"text": "Menjana permutasi dengan hanya swap bersebelahan yang dibenarkan | Program PHP untuk menjana permutasi dengan hanya satu swap yang dibenarkan. ; Jangan menukar kedudukan semasa; Tukar dengan watak seterusnya dan kembali perubahan. Seperti yang dijelaskan di atas, bertukar dengan sebelumnya IS tidak diperlukan kerana ia berlaku untuk watak seterusnya. ; Kod pemacu", "code": "< ? php function findPermutations ( $ str , $ index , $ n ) { if ( $ index >= $ n || ( $ index + 1 ) >= $ n ) { echo $ str , \" STRNEWLINE \" ; return ; } findPermutations ( $ str , $ index + 1 , $ n ) ; list ( $ str [ $ index ] , $ str [ $ index + 1 ] ) = array ( $ str [ $ index + 1 ] , $ str [ $ index ] ) ; findPermutations ( $ str , $ index + 2 , $ n ) ; list ( $ str [ $ index ] , $ str [ $ index + 1 ] ) = array ( $ str [ $ index + 1 ] , $ str [ $ index ] ) ; } $ str = \"12345\" ; $ n = strlen ( $ str ) ; findPermutations ( $ str , 0 , $ n ) ; ? >"}
{"text": "Semak jika pengekodan mewakili rentetan binari yang unik | Program PHP untuk memeriksa sama ada pengekodan yang diberikan mewakili rentetan tunggal; Kembali benar jika jumlah menjadi k; Kod pemacu", "code": "< ? php function isUnique ( $ a , $ n , $ k ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; $ sum += $ n - 1 ; return ( $ sum == $ k ) ; } $ a = array ( 3 , 3 , 3 ) ; $ n = count ( $ a ) ; $ k = 12 ; if ( isUnique ( $ a , $ n , $ k ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Bilangan kedudukan di mana huruf boleh dimasukkan supaya rentetan menjadi palindrome | Fungsi untuk memeriksa sama ada rentetan adalah palindrome; untuk mengetahui panjang rentetan; Jika rentetan yang diberikan adalah palindrome (kes - i); Sub - kes - iii); jika panjangnya; sub - kes - i; sub -case - II; titik penyisipan; Kes - i; Kes - ii; Kod pemacu", "code": "< ? php function isPalindrome ( $ s , $ i , $ j ) { $ p = $ j ; for ( $ k = $ i ; $ k <= $ p ; $ k ++ ) { if ( $ s [ $ k ] != $ s [ $ p ] ) return false ; $ p -- ; } return true ; } function countWays ( $ s ) { $ n = strlen ( $ s ) ; $ count = 0 ; if ( isPalindrome ( $ s , 0 , $ n - 1 ) ) { for ( $ i = $ n / 2 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ count ++ ; else break ; } if ( $ n % 2 == 0 ) { $ count ++ ; $ count = 2 * $ count + 1 ; } else $ count = 2 * $ count + 2 ; } else { for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) { if ( $ s [ $ i ] != $ s [ $ n - 1 - $ i ] ) { $ j = $ n - 1 - $ i ; if ( isPalindrome ( $ s , $ i , $ n - 2 - $ i ) ) { for ( $ k = $ i - 1 ; $ k >= 0 ; $ k -- ) { if ( $ s [ $ k ] != $ s [ $ j ] ) break ; $ count ++ ; } $ count ++ ; } if ( isPalindrome ( $ s , $ i + 1 , $ n - 1 - $ i ) ) { for ( $ k = $ n - $ i ; $ k < $ n ; $ k ++ ) { if ( $ s [ $ k ] != $ s [ $ i ] ) break ; $ count ++ ; } $ count ++ ; } break ; } } } return $ count ; } $ s = \" abca \" ; echo countWays ( $ s ) ; ? >"}
{"text": "Count substrings rentetan binari yang mengandungi k yang lain | kaedah mengembalikan jumlah substring yang mempunyai k; Inisialisasi indeks mempunyai jumlah sifar sebagai 1; gelung atas watak binari rentetan; Kemas kini pemboleh ubah countofone dengan nilai watak ith; Jika nilai mencapai lebih daripada k, maka hasil kemas kini; Tambah kekerapan indeks, mempunyai jumlah (jumlah semasa - k), kepada hasilnya; kekerapan kemas kini kiraan seseorang; Kod pemacu", "code": "< ? php function countOfSubstringWithKOnes ( $ s , $ K ) { $ N = strlen ( $ s ) ; $ res = 0 ; $ countOfOne = 0 ; $ freq = array ( ) ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) $ freq [ $ i ] = 0 ; $ freq [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ countOfOne += ( $ s [ $ i ] - '0' ) ; if ( $ countOfOne >= $ K ) { $ res = $ res + $ freq [ $ countOfOne - $ K ] ; } $ freq [ $ countOfOne ] ++ ; } return $ res ; } $ s = \"10010\" ; $ K = 1 ; echo countOfSubstringWithKOnes ( $ s , $ K ) , \" \" ; ? >"}
{"text": "Nombor Palindromic yang lebih tinggi menggunakan set digit yang sama | fungsi untuk membalikkan digit dalam julat I ke j dalam 'num'; berfungsi untuk mencari nombor palindromik yang lebih tinggi seterusnya menggunakan set digit yang sama; Jika panjang bilangan kurang daripada '3' maka tiada nombor palindromik yang lebih tinggi boleh dibentuk; Cari indeks digit terakhir dalam setengah 1 st 'num'; Mulakan dari angka (pertengahan - 1) dan cari digit pertama yang lebih kecil daripada digit di sebelahnya. ; Sekiranya tiada digit sedemikian dijumpai, maka semua digit berada dalam urutan menurun yang bermaksud tidak ada nombor palindromik yang lebih besar dengan set digit yang sama; Cari digit terkecil di sebelah kanan digit ith yang lebih besar daripada num [i] sehingga indeks 'pertengahan'; swap num [i] dengan num [terkecil]; Oleh kerana bilangannya adalah palindrome, swap digit yang sama harus dilakukan pada separuh 2 'num'; digit terbalik dalam julat (i + 1) hingga pertengahan; Jika n adalah walaupun, maka angka terbalik dalam julat pertengahan + 1 hingga n - i - 2; lain jika n adalah ganjil, maka angka terbalik dalam julat pertengahan + 2 hingga n - i - 2; diperlukan nombor palindromik yang lebih tinggi seterusnya; Kod pemacu", "code": "< ? php function reverse ( & $ num , $ i , $ j ) { while ( $ i < $ j ) { $ t = $ num [ $ i ] ; $ num [ $ i ] = $ num [ $ j ] ; $ num [ $ j ] = $ t ; $ i ++ ; $ j -- ; } } function nextPalin ( $ num , $ n ) { if ( $ n <= 3 ) { echo \" Not ▁ Possible \" ; return ; } $ mid = ( $ n / 2 ) - 1 ; $ i = $ mid - 1 ; $ j ; for ( ; $ i >= 0 ; $ i -- ) if ( $ num [ $ i ] < $ num [ $ i + 1 ] ) break ; if ( $ i < 0 ) { echo \" Not ▁ Possible \" ; return ; } $ smallest = $ i + 1 ; $ j = 0 ; for ( $ j = $ i + 2 ; $ j <= $ mid ; $ j ++ ) if ( $ num [ $ j ] > $ num [ $ i ] && $ num [ $ j ] < $ num [ $ smallest ] ) $ smallest = $ j ; $ t = $ num [ $ i ] ; $ num [ $ i ] = $ num [ $ smallest ] ; $ num [ $ smallest ] = $ t ; $ t = $ num [ $ n - $ i - 1 ] ; $ num [ $ n - $ i - 1 ] = $ num [ $ n - $ smallest - 1 ] ; $ num [ $ n - $ smallest - 1 ] = $ t ; reverse ( $ num , $ i + 1 , $ mid ) ; if ( $ n % 2 == 0 ) reverse ( $ num , $ mid + 1 , $ n - $ i - 2 ) ; else reverse ( $ num , $ mid + 2 , $ n - $ i - 2 ) ; echo \" Next ▁ Palindrome : ▁ \" . $ num ; } $ num = \"4697557964\" ; $ n = strlen ( $ num ) ; nextPalin ( $ num , $ n ) ; ? >"}
{"text": "Cetak n | berfungsi untuk menjana nombor digit n; jika nombor dijana; Tambah 1 pada nombor semasa dan mengurangkan tempat yang tinggal oleh satu; Jika lebih banyak daripada sifar, tambah 0 ke nombor semasa dan mengurangkan tempat yang tinggal oleh satu; Kod pemacu; Panggilan fungsi", "code": "< ? php function printRec ( $ number , $ extraOnes , $ remainingPlaces ) { if ( 0 == $ remainingPlaces ) { echo ( $ number . \" \" ) ; return ; } printRec ( $ number . \"1\" , $ extraOnes + 1 , $ remainingPlaces - 1 ) ; if ( 0 < $ extraOnes ) printRec ( $ number . \"0\" , $ extraOnes - 1 , $ remainingPlaces - 1 ) ; } function printNums ( $ n ) { $ str = \" \" ; printRec ( $ str , 0 , $ n ) ; } $ n = 4 ; printNums ( $ n ) ;"}
{"text": "Substring biasa terpanjang dalam pelbagai rentetan | berfungsi untuk mencari batang (substring biasa terpanjang) dari array rentetan; Menentukan saiz array; Ambil perkataan pertama dari array sebagai rujukan; Menjana semua kemungkinan substrings rentetan rujukan kami ARR [0] i. e s; Semak sama ada batang yang dihasilkan adalah perkara biasa untuk semua perkataan; Jika substring semasa hadir dalam semua rentetan dan panjangnya lebih besar daripada hasil semasa; Kod pemacu; Panggilan fungsi", "code": "< ? php function findstem ( $ arr ) { $ n = count ( $ arr ) ; $ s = $ arr [ 0 ] ; $ len = strlen ( $ s ) ; $ res = \" \" ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j <= $ len ; $ j ++ ) { $ stem = substr ( $ s , $ i , $ j - $ i ) ; $ k = 1 ; for ( $ k = 1 ; $ k < $ n ; $ k ++ ) if ( ! strpos ( $ arr [ $ k ] , $ stem ) ) break ; if ( $ k <= $ n && strlen ( $ res ) < strlen ( $ stem ) ) $ res = $ stem ; } } return $ res ; } $ arr = array ( \" grace \" , \" graceful \" , \" disgraceful \" , \" gracefully \" ) ; $ stems = findstem ( $ arr ) ; print ( $ stems ) ; ? >"}
{"text": "Seterusnya nombor yang lebih tinggi menggunakan Operasi Swap Atmost One | berfungsi untuk mencari nombor yang lebih tinggi seterusnya menggunakan operasi swap Atmost satu; untuk menyimpan indeks digit terbesar yang ditemui setakat ini dari kanan; untuk menyimpan indeks angka paling kanan yang mempunyai digit yang lebih besar di sebelah kanannya; mencari 'indeks' digit paling kanan yang mempunyai digit yang lebih besar di sebelah kanannya; Digit yang diperlukan dijumpai, menyimpan 'indeks' dan pecahnya; Jika tiada digit sedemikian dijumpai yang mempunyai digit yang lebih besar di sebelah kanannya; untuk menyimpan indeks digit terkecil lebih besar daripada digit di 'indeks' dan hak untuk itu; mencari indeks digit terkecil lebih besar daripada digit di 'indeks' dan hak untuk itu; menukar digit; nombor yang diperlukan; Kod pemacu", "code": "< ? php function nxtHighUsingAtMostOneSwap ( $ num ) { $ l = strlen ( $ num ) ; $ posRMax = $ l - 1 ; $ index = -1 ; for ( $ i = $ l - 2 ; $ i >= 0 ; $ i -- ) { if ( $ num [ $ i ] >= $ num [ $ posRMax ] ) $ posRMax = $ i ; else { $ index = $ i ; break ; } } if ( $ index == -1 ) return \" Not ▁ Possible \" ; $ greatSmallDgt = -1 ; for ( $ i = $ l - 1 ; $ i > $ index ; $ i -- ) { if ( $ num [ $ i ] > $ num [ $ index ] ) { if ( $ greatSmallDgt == -1 ) $ greatSmallDgt = $ i ; else if ( $ num [ $ i ] <= $ num [ $ greatSmallDgt ] ) $ greatSmallDgt = $ i ; } } $ temp = $ num [ $ index ] ; $ num [ $ index ] = $ num [ $ greatSmallDgt ] ; $ num [ $ greatSmallDgt ] = $ temp ; return $ num ; } $ num = \"218765\" ; echo \" Original ▁ number : ▁ \" . $ num . \" STRNEWLINE \" ; echo \" Next ▁ higher ▁ number : ▁ \" . nxtHighUsingAtMostOneSwap ( $ num ) ; ? >"}
{"text": "Substring vokal terpanjang | Program PHP untuk mencari substring vokal terpanjang. ; Kenaan semasa kenaikan jika s [i] adalah vokal; Semak nilai sebelumnya lebih besar atau tidak; Kod pemacu", "code": "< ? php function isVowel ( $ c ) { return ( $ c == ' a ' $ c == ' e ' $ c == ' i ' $ c == ' o ' $ c == ' u ' ) ; } function longestVowel ( $ s ) { $ count = 0 ; $ res = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( isVowel ( $ s [ $ i ] ) ) $ count ++ ; else { $ res = max ( $ res , $ count ) ; $ count = 0 ; } } return max ( $ res , $ count ) ; } $ s = \" theeare \" ; echo longestVowel ( $ s ) ; ? >"}
{"text": "Bilangan substrings dengan kiraan setiap watak sebagai k | Program PHP untuk mengira bilangan substring dengan tuduhan watak yang berbeza sebagai k. ; Pulangan benar jika semua nilai dalam freq [] sama ada 0 atau k. ; Mengembalikan kiraan substrings di mana kekerapan setiap watak sekarang adalah k; Pilih titik permulaan; Memulakan semua frekuensi sebagai 0 untuk titik permulaan ini; Satu demi satu mata akhir memilih; Kekerapan kenaikan char semasa; Jika kekerapan menjadi lebih daripada k, kita tidak boleh mempunyai lebih banyak substrings bermula dengan i; Jika kekerapan menjadi k, maka periksa frekuensi lain juga. ; Kod pemacu", "code": "< ? php $ MAX_CHAR = 26 ; function check ( & $ freq , $ k ) { global $ MAX_CHAR ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) if ( $ freq [ $ i ] && $ freq [ $ i ] != $ k ) return false ; return true ; } function substrings ( $ s , $ k ) { global $ MAX_CHAR ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ freq = array_fill ( 0 , $ MAX_CHAR , NULL ) ; for ( $ j = $ i ; $ j < strlen ( $ s ) ; $ j ++ ) { $ index = ord ( $ s [ $ j ] ) - ord ( ' a ' ) ; $ freq [ $ index ] ++ ; if ( $ freq [ $ index ] > $ k ) break ; else if ( $ freq [ $ index ] == $ k && check ( $ freq , $ k ) == true ) $ res ++ ; } } return $ res ; } $ s = \" aabbcc \" ; $ k = 2 ; echo substrings ( $ s , $ k ) . \" STRNEWLINE \" ; $ s = \" aabbc \" ; $ k = 2 ; echo substrings ( $ s , $ k ) . \" STRNEWLINE \" ; ? >"}
{"text": "Penyelesaian Rekursif untuk Mengira Substrings Dengan Watak Pertama dan Terakhir Sama | Berfungsi untuk mengira substrings dengan watak pertama dan terakhir yang sama; kes asas; Kod pemacu", "code": "< ? php function countSubstrs ( $ str , $ i , $ j , $ n ) { if ( $ n == 1 ) return 1 ; if ( $ n <= 0 ) return 0 ; $ res = countSubstrs ( $ str , $ i + 1 , $ j , $ n - 1 ) + countSubstrs ( $ str , $ i , $ j - 1 , $ n - 1 ) - countSubstrs ( $ str , $ i + 1 , $ j - 1 , $ n - 2 ) ; if ( $ str [ $ i ] == $ str [ $ j ] ) $ res ++ ; return $ res ; } $ str = \" abcab \" ; $ n = strlen ( $ str ) ; echo ( countSubstrs ( $ str , 0 , $ n - 1 , $ n ) ) ; ? >"}
{"text": "Bilangan minimum manipulasi yang diperlukan untuk membuat dua rentetan anagram tanpa penghapusan watak | Mengira tidak ada manipulasi yang diperlukan; Simpan kiraan watak; Iterat walaupun rentetan pertama dan mengemaskini kiraan; Iterate Melalui Kemas Kini Rentetan Kedua Char_Count. Jika watak tidak dijumpai di char_count maka tambah kiraan; Kod pemacu", "code": "< ? php function countManipulations ( $ s1 , $ s2 ) { $ count = 0 ; $ char_count = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < strlen ( $ s1 ) ; $ i ++ ) $ char_count [ ord ( $ s1 [ $ i ] ) - ord ( ' a ' ) ] += 1 ; for ( $ i = 0 ; $ i < strlen ( $ s2 ) ; $ i ++ ) { $ char_count [ ord ( $ s2 [ $ i ] ) - ord ( ' a ' ) ] -= 1 ; } for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ char_count [ i ] != 0 ) { $ count += abs ( $ char_count [ i ] ) ; } } return $ count ; } $ s1 = \" ddcf \" ; $ s2 = \" cedk \" ; echo countManipulations ( $ s1 , $ s2 ) ; ? >"}
{"text": "Memandangkan dua rentetan rentetan yang membuatkan palindrome pertama | Memandangkan dua rentetan, periksa rentetan yang menjadikan palindrome terlebih dahulu. ; mengembalikan pemenang dua rentetan; Mengira frekuensi aksara dalam kedua -dua rentetan yang diberikan; Semak jika terdapat watak yang muncul lebih dari sekali dalam A dan tidak muncul dalam B; Kod pemacu", "code": "< ? php $ MAX_CHAR = 26 ; function stringPalindrome ( $ A , $ B ) { global $ MAX_CHAR ; $ countA = array_fill ( 0 , $ MAX_CHAR , 0 ) ; $ countB = array_fill ( 0 , $ MAX_CHAR , 0 ) ; $ l1 = strlen ( $ A ) ; $ l2 = strlen ( $ B ) ; for ( $ i = 0 ; $ i < $ l1 ; $ i ++ ) $ countA [ ord ( $ A [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ l2 ; $ i ++ ) $ countB [ ord ( $ B [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( ( $ countA [ $ i ] > 1 && $ countB [ $ i ] == 0 ) ) return ' A ' ; return ' B ' ; } $ a = \" abcdea \" ; $ b = \" bcdesg \" ; echo stringPalindrome ( $ a , $ b ) ; ? >"}
{"text": "Cari nombor kedudukan mengimbangi dalam rentetan | Program PHP untuk mencari bilangan titik pengimbangan dalam rentetan; berfungsi untuk mengembalikan bilangan titik pengimbangan; Arus hash untuk menyimpan hash rentetan yang diasaskan oleh 0 menjadi global; Proses String pada mulanya untuk RightVisited; Periksa titik mengimbangi; untuk setiap kedudukan Inc meninggalkan hash & dec yang betul; Semak sama ada kedua -dua hash mempunyai watak yang sama atau tidak; Sama ada kedua -dua leftvisited [j] dan rightvisited [j] sepatutnya tidak mempunyai nilai sifar atau kedua -duanya harus mempunyai nilai sifar; Jika kedua -duanya mempunyai kiraan kenaikan watak yang sama; Kod pemacu", "code": "< ? php $ MAX_CHAR = 256 ; function countBalance ( $ str ) { global $ MAX_CHAR ; $ leftVisited = array_fill ( 0 , $ MAX_CHAR , NULL ) ; $ rightVisited = array_fill ( 0 , $ MAX_CHAR , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ rightVisited [ ord ( $ str [ $ i ] ) ] ++ ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ leftVisited [ ord ( $ str [ $ i ] ) ] ++ ; $ rightVisited [ ord ( $ str [ $ i ] ) ] -- ; for ( $ j = 0 ; $ j < $ MAX_CHAR ; $ j ++ ) { if ( ( $ leftVisited [ $ j ] == 0 && $ rightVisited [ $ j ] != 0 ) || ( $ leftVisited [ $ j ] != 0 && $ rightVisited [ $ j ] == 0 ) ) break ; } if ( $ j == $ MAX_CHAR ) $ res ++ ; } return $ res ; } $ str = \" abaababa \" ; echo countBalance ( $ str ) ; ? >"}
{"text": "Min flips of watak berterusan untuk membuat semua aksara sama dalam rentetan | Untuk mencari bilangan min dalam rentetan binari; Jika watak terakhir tidak sama dengan STR [i] meningkatkan res; Untuk mengembalikan min flips; Kod pemacu", "code": "< ? php function findFlips ( $ str , $ n ) { $ last = ' ▁ ' ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ last != $ str [ $ i ] ) $ res ++ ; $ last = $ str [ $ i ] ; } return intval ( $ res / 2 ) ; } $ str = \"00011110001110\" ; $ n = strlen ( $ str ) ; echo findFlips ( $ str , $ n ) ; ? >"}
{"text": "Substring panjang maksimum mempunyai semua aksara yang sama selepas perubahan k | berfungsi untuk mencari panjang maksimum substring yang mempunyai watak ch; melintasi seluruh rentetan; Jika watak tidak sama dengan kiraan peningkatan CH; Walaupun mengira> k melintasi rentetan lagi sehingga kiraan menjadi kurang daripada k dan mengurangkan kiraan apabila watak tidak sama; panjang substring akan menjadi rightIndex - leftIndex + 1. Bandingkan ini dengan panjang maksimum dan panjang maksimum pulangan; fungsi yang mengembalikan panjang maksimum substring; Kod pemacu", "code": "< ? php function findLen ( $ A , $ n , $ k , $ ch ) { $ maxlen = 1 ; $ cnt = 0 ; $ l = 0 ; $ r = 0 ; while ( $ r < $ n ) { if ( $ A [ $ r ] != $ ch ) ++ $ cnt ; while ( $ cnt > $ k ) { if ( $ A [ $ l ] != $ ch ) -- $ cnt ; ++ $ l ; } $ maxlen = max ( $ maxlen , $ r - $ l + 1 ) ; ++ $ r ; } return $ maxlen ; } function answer ( $ A , $ n , $ k ) { $ maxlen = 1 ; for ( $ i = 0 ; $ i < 26 ; ++ $ i ) { $ maxlen = max ( $ maxlen , findLen ( $ A , $ n , $ k , $ i + ' A ' ) ) ; $ maxlen = max ( $ maxlen , findLen ( $ A , $ n , $ k , $ i + ' a ' ) ) ; } return $ maxlen ; } $ n = 5 ; $ k = 2 ; $ A = \" ABABA \" ; echo \" Maximum length = \" ▁ . ▁ answer ( $ A , ▁ $ n , ▁ $ k ) ▁ . ▁ \" \" $ n = 6 ; $ k = 4 ; $ B = \" HHHHHH \" ; echo \" Maximum length = \" ▁ . ▁ answer ( $ B , ▁ $ n , ▁ $ k ) ▁ . ▁ \" \" ? >"}
{"text": "Semak jika kedua -dua bahagian rentetan mempunyai set aksara yang sama | Program PHP untuk memeriksa sama ada mungkin untuk memecah rentetan atau tidak; berfungsi untuk memeriksa sama ada kita boleh memecah rentetan atau tidak; Arahan kaunter diasaskan dengan 0; Panjang rentetan; melintasi sehingga elemen tengah dicapai; Separuh pertama; Separuh kedua; Memeriksa jika nilai adalah bendera set yang berbeza kepada 1; Rentetan yang akan diperiksa", "code": "< ? php $ MAX_CHAR = 26 ; function checkCorrectOrNot ( $ s ) { global $ MAX_CHAR ; $ count1 = array_fill ( 0 , $ MAX_CHAR , NULL ) ; $ count2 = array_fill ( 0 , $ MAX_CHAR , NULL ) ; $ n = strlen ( $ s ) ; if ( $ n == 1 ) return true ; for ( $ i = 0 , $ j = $ n - 1 ; $ i < $ j ; $ i ++ , $ j -- ) { $ count1 [ $ s [ $ i ] - ' a ' ] ++ ; $ count2 [ $ s [ $ j ] - ' a ' ] ++ ; } for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) if ( $ count1 [ $ i ] != $ count2 [ $ i ] ) return false ; return true ; } $ s = \" abab \" ; if ( checkCorrectOrNot ( $ s ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Ekstrak nilai angka maksimum dari rentetan yang diberikan | Tetapkan 1 (Pendekatan Umum) | Fungsi utiliti untuk mencari rentetan maksimum; Jika kedua -duanya mempunyai panjang yang sama; Mencapai watak / nilai yang tidak dapat ditandingi pertama; Kembali rentetan dengan nilai maksimum; Jika panjang yang berlainan kembali rentetan dengan panjang maksimum; Berfungsi untuk mengekstrak nilai maksimum; Mula melintasi rentetan; Abaikan sifar utama; Simpan nilai angka ke dalam rentetan; Mengemas kini rentetan maksimum; Untuk mengendalikan kes itu jika terdapat hanya 0 nilai angka; Mengembalikan rentetan maksimum; Program Pemandu", "code": "< ? php function maximumNum ( $ curr_num , $ res ) { $ len1 = strlen ( $ curr_num ) ; $ len2 = strlen ( $ res ) ; if ( $ len1 == $ len2 ) { $ i = 0 ; while ( $ curr_num [ $ i ] == $ res [ $ i ] ) $ i ++ ; if ( $ curr_num [ $ i ] < $ res [ $ i ] ) return $ res ; else return $ curr_num ; } return $ len1 < $ len2 ? $ res : $ curr_num ; } function extractMaximum ( $ str ) { $ n = strlen ( $ str ) ; $ curr_num = \" \" ; $ res = \" \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ i < $ n && $ str [ $ i ] == '0' ) $ i ++ ; while ( $ i < $ n && $ str [ $ i ] >= '0' && $ str [ $ i ] <= '9' ) { $ curr_num . = $ str [ $ i ] ; $ i ++ ; } if ( $ i == $ n ) break ; if ( strlen ( $ curr_num ) > 0 ) $ i -- ; $ res = maximumNum ( $ curr_num , $ res ) ; $ curr_num = \" \" ; } if ( strlen ( $ curr_num ) == 0 && strlen ( $ res ) == 0 ) $ res . = '0' ; return maximumNum ( $ curr_num , $ res ) ; } $ str = \"100klh564abc365bg \" ; echo extractMaximum ( $ str ) ; ? >"}
{"text": "Untuk memeriksa pembahagian mana -mana jumlah besar oleh 999 | berfungsi untuk memeriksa kebolehpasaran; Tambah diperlukan 0 s pada mulanya. ; Tambah digit dalam kumpulan tiga di GSUM; Kumpulan menjimatkan 3 - kumpulan digit; Hitung hasil sehingga 3 digit jumlah; Kod pemacu", "code": "< ? php function isDivisible999 ( $ num ) { $ n = strlen ( $ num ) ; if ( $ n == 0 && $ num [ 0 ] == '0' ) return true ; if ( $ n % 3 == 1 ) $ num = \"00\" . $ num ; if ( $ n % 3 == 2 ) $ num = \"0\" . $ num ; $ gSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i += 3 ) { $ group = 0 ; $ group += ( ord ( $ num [ $ i ] ) - 48 ) * 100 ; $ group += ( ord ( $ num [ $ i + 1 ] ) - 48 ) * 10 ; $ group += ( ord ( $ num [ $ i + 2 ] ) - 48 ) ; $ gSum += $ group ; } if ( $ gSum > 1000 ) { $ num = strval ( $ gSum ) ; $ n = strlen ( $ num ) ; $ gSum = isDivisible999 ( $ num ) ; } return ( $ gSum == 999 ) ; } $ num = \"1998\" ; if ( isDivisible999 ( $ num ) ) echo \" Divisible \" ; else echo \" Not ▁ divisible \" ; ? >"}
{"text": "Susun semula rentetan dalam susunan yang disusun diikuti oleh jumlah integer | Program PHP untuk pelaksanaan di atas; Berfungsi untuk mengembalikan rentetan dalam urutan lexicographic diikuti oleh jumlah bilangan bulat; Melintasi rentetan; Mengira kejadian huruf besar; Menyimpan jumlah bilangan bulat; Melintasi semua aksara a hingga z; Tambahkan watak semasa dalam rentetan no. masa ia berlaku dalam rentetan yang diberikan; Tambah jumlah bilangan bulat; Kembali rentetan hasil; Kod pemacu", "code": "< ? php $ MAX_CHAR = 26 ; function arrangeString ( $ str ) { global $ MAX_CHAR ; $ char_count = array_fill ( 0 , $ MAX_CHAR , NULL ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) $ char_count [ ord ( $ str [ $ i ] ) - ord ( ' A ' ) ] ++ ; else $ sum = $ sum + ( ord ( $ str [ $ i ] ) - ord ( '0' ) ) ; } $ res = \" \" ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) { $ ch = chr ( ord ( ' A ' ) + $ i ) ; while ( $ char_count [ $ i ] -- ) $ res = $ res . $ ch ; } if ( $ sum > 0 ) $ res = $ res . strval ( $ sum ) ; return $ res ; } $ str = \" ACCBA10D2EW30\" ; echo arrangeString ( $ str ) ; ? >"}
{"text": "Program untuk mencetak semua substrings rentetan yang diberikan | Berfungsi untuk mencetak semua sub rentetan; Pilih titik permulaan; Memilih titik akhir; Cetak aksara dari titik permulaan semasa ke titik akhir semasa. ; Kod pemacu", "code": "< ? php function subString ( $ str , $ n ) { for ( $ len = 1 ; $ len <= $ n ; $ len ++ ) { for ( $ i = 0 ; $ i <= $ n - $ len ; $ i ++ ) { $ j = $ i + $ len - 1 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) echo $ str [ $ k ] ; echo \" STRNEWLINE \" ; } } } $ str = \" abc \" ; subString ( $ str , strlen ( $ str ) ) ; ? >"}
{"text": "Program untuk mengira vokal dalam rentetan (berulang dan rekursif) | Fungsi untuk memeriksa vokal; Mengembalikan kiraan vokal dalam str; jika (Isvowel ($ str [$ i])) semak vokal; objek rentetan; Jumlah bilangan vokal", "code": "< ? php function isVowel ( $ ch ) { $ ch = strtoupper ( $ ch ) ; return ( $ ch == ' A ' $ ch == ' E ' $ ch == ' I ' $ ch == ' O ' $ ch == ' U ' ) ; } function countVowels ( $ str ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) ++ $ count ; return $ count ; } $ str = \" abc ▁ de \" ; echo countVowels ( $ str ) . \" STRNEWLINE \" ; ? >"}
{"text": "Menjana semua putaran rentetan yang diberikan | Cetak semua rentetan yang diputar. ; Menjana semua putaran satu demi satu dan cetak; Indeks semasa dalam STR; Indeks semasa dalam temp; Menyalin bahagian kedua dari titik putaran. ; Menyalin bahagian pertama dari titik putaran. ; Kod pemacu", "code": "< ? php function printRotatedString ( $ str ) { $ len = strlen ( $ str ) ; $ temp = \" ▁ \" ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ j = $ i ; $ k = 0 ; while ( $ j < $ len ) { $ temp [ $ k ] = $ str [ $ j ] ; $ k ++ ; $ j ++ ; } $ j = 0 ; while ( $ j < $ i ) { $ temp [ $ k ] = $ str [ $ j ] ; $ j ++ ; $ k ++ ; } echo $ temp . \" STRNEWLINE \" ; } } $ str = \" geeks \" ; printRotatedString ( $ str ) ; ? >"}
{"text": "Termasuk bukan | fungsi utiliti untuk memeriksa sama ada rentetan adalah palindrome atau tidak; Semak palindrome. ; rentetan palindrome; fungsi untuk mencari substring panjang maksimum yang bukan palindrome; Untuk memeriksa sama ada semua aksara rentetan adalah sama atau tidak; Semua watak adalah sama, kita tidak boleh membuat rentetan bukan palindromik. ; Jika rentetan adalah palindrome, kita boleh menjadikannya bukan palindrome dengan mengeluarkan watak sudut; Rentetan lengkap bukanlah palindrome. ; Kod pemacu", "code": "< ? php function isPalindrome ( $ str ) { $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) if ( $ str [ $ i ] != $ str [ $ n - $ i - 1 ] ) return false ; return true ; } function maxLengthNonPalinSubstring ( $ str ) { $ n = strlen ( $ str ) ; $ ch = $ str [ 0 ] ; $ i = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ str [ $ i ] != $ ch ) break ; if ( $ i == $ n ) return 0 ; if ( isPalindrome ( $ str ) ) return ( $ n - 1 ) ; return $ n ; } $ str = \" abba \" ; echo \" Maximum ▁ Length ▁ = ▁ \" , maxLengthNonPalinSubstring ( $ str ) ; ? >"}
{"text": "Semak sama ada k | Program PHP untuk memeriksa sama ada bit bit K - TH ditetapkan atau tidak menggunakan pengendali peralihan kanan. ; Kod pemacu", "code": "< ? php function isKthBitSet ( $ n , $ k ) { if ( ( $ n >> ( $ k - 1 ) ) & 1 ) echo \" SET \" ; else echo \" NOT ▁ SET \" ; } $ n = 5 ; $ k = 1 ; isKthBitSet ( $ n , $ k ) ; ? >"}
{"text": "Lexicographically First Palindromic String | Program PHP untuk mencari permutasi palindromik pertama rentetan yang diberikan; Fungsi untuk mengira kekerapan setiap char dalam rentetan. Freq [0] untuk 'A', .... , freq [25] untuk 'z'; Kes untuk memeriksa sama ada rentetan palindr0mic boleh dibentuk atau tidak; count_odd untuk mengira tiada chars dengan kekerapan ganjil; Untuk rentetan panjang tiada watak Freq ganjil; Untuk rentetan panjang ganjil satu watak freq ganjil; Berfungsi untuk mencari char freq ganjil dan mengurangkan freqnya dengan 1 pulangan \"\" jika char freq ganjil tidak hadir; Untuk mencari rentetan palindromik pertama secara lexicographically. ; Menetapkan aksara Freq Ganjil Jika hadir lain rentetan kosong. ; Melintasi watak -watak dalam peningkatan urutan; Bahagikan semua kejadian menjadi dua bahagian. Perhatikan bahawa watak ganjil dikeluarkan oleh findoddandremoveitsfreq (); mewujudkan rentetan depan; mewujudkan rentetan belakang; Rentetan palindromik terakhir yang pertama kali lexicographically; Kod pemacu", "code": "< ? php $ MAX_CHAR = 26 ; function countFreq ( $ str , & $ freq , $ len ) { for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; } function canMakePalindrome ( $ freq , $ len ) { global $ MAX_CHAR ; $ count_odd = 0 ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) if ( $ freq [ $ i ] % 2 != 0 ) $ count_odd ++ ; if ( $ len % 2 == 0 ) { if ( $ count_odd > 0 ) return false ; else return true ; } if ( $ count_odd != 1 ) return false ; return true ; } function findOddAndRemoveItsFreq ( $ freq ) { global $ MAX_CHAR ; $ odd_str = \" \" ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) { if ( $ freq [ $ i ] % 2 != 0 ) { $ freq [ $ i ] -- ; $ odd_str . = chr ( $ i + ord ( ' a ' ) ) ; return $ odd_str ; } } return $ odd_str ; } function findPalindromicString ( $ str ) { global $ MAX_CHAR ; $ len = strlen ( $ str ) ; $ freq = array_fill ( 0 , $ MAX_CHAR , 0 ) ; countFreq ( $ str , $ freq , $ len ) ; if ( ! canMakePalindrome ( $ freq , $ len ) ) return \" No ▁ Palindromic ▁ String \" ; $ odd_str = findOddAndRemoveItsFreq ( $ freq ) ; $ front_str = \" \" ; $ rear_str = \" ▁ \" ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) { $ temp = \" \" ; if ( $ freq [ $ i ] != 0 ) { $ ch = chr ( $ i + ord ( ' a ' ) ) ; for ( $ j = 1 ; $ j <= ( int ) ( $ freq [ $ i ] / 2 ) ; $ j ++ ) $ temp . = $ ch ; $ front_str . = $ temp ; $ rear_str = $ temp . $ rear_str ; } } return ( $ front_str . $ odd_str . $ rear_str ) ; } $ str = \" malayalam \" ; echo findPalindromicString ( $ str ) ; ? >"}
{"text": "Kira substrings dengan watak pertama dan terakhir yang sama | Pulangan benar jika watak pertama dan terakhir S adalah sama. ; Titik permulaan substring; Panjang substring; Semak sama ada substring semasa mempunyai aksara permulaan dan berakhir yang sama. ; Kod pemacu", "code": "< ? php function checkEquality ( $ s ) { return ( $ s [ 0 ] == $ s [ strlen ( $ s ) - 1 ] ) ; } function countSubstringWithEqualEnds ( $ s ) { $ result = 0 ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ len = 1 ; $ len <= $ n - $ i ; $ len ++ ) if ( checkEquality ( substr ( $ s , $ i , $ len ) ) ) $ result ++ ; return $ result ; } $ s = \" abcab \" ; print ( countSubstringWithEqualEnds ( $ s ) ) ; ? >"}
{"text": "Kira substrings dengan watak pertama dan terakhir yang sama | Program PHP yang cekap ruang untuk mengira semua substrings dengan watak pertama dan terakhir yang sama. ; Melangkah melalui semua substrings dengan cara supaya kita dapat mencari watak pertama dan terakhir dengan mudah; Kod pemacu", "code": "< ? php function countSubstringWithEqualEnds ( $ s ) { $ result = 0 ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i ; $ j < $ n ; $ j ++ ) if ( $ s [ $ i ] == $ s [ $ j ] ) $ result ++ ; return $ result ; } $ s = \" abcab \" ; echo countSubstringWithEqualEnds ( $ s ) ;"}
{"text": "Maksimum Maksimum Berulang Karakter dalam String | berfungsi untuk mengetahui watak berulang maksimum dalam rentetan yang diberikan; Cari watak berulang maksimum bermula dari STR [i]; Hasil kemas kini jika diperlukan; Kod pemacu", "code": "< ? php function maxRepeating ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; $ res = $ str [ 0 ] ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ cur_count = 1 ; for ( $ j = $ i + 1 ; $ j < $ len ; $ j ++ ) { if ( $ str [ $ i ] != $ str [ $ j ] ) break ; $ cur_count ++ ; } if ( $ cur_count > $ count ) { $ count = $ cur_count ; $ res = $ str [ $ i ] ; } } return $ res ; } $ str = \" aaaabbaaccde \" ; echo maxRepeating ( $ str ) ; ? >"}
{"text": "Jumlah dua nombor besar | Fungsi untuk mencari jumlah yang lebih besar; Sebelum meneruskan lagi, pastikan panjang STR2 lebih besar. ; Ambil rentetan kosong untuk menyimpan hasil; Hitung panjang kedua -dua rentetan; Membalikkan kedua -dua rentetan; Adakah matematik sekolah, mengira jumlah digit semasa dan dibawa; Hitung membawa langkah seterusnya; Tambah angka yang lebih besar daripada bilangan yang lebih besar; Tambah baki bawa; rentetan hasil terbalik; Kod pemacu", "code": "< ? php function findSum ( $ str1 , $ str2 ) { if ( strlen ( $ str1 ) > strlen ( $ str2 ) ) { $ t = $ str1 ; $ str1 = $ str2 ; $ str2 = $ t ; } $ str = \" \" ; $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; $ str1 = strrev ( $ str1 ) ; $ str2 = strrev ( $ str2 ) ; $ carry = 0 ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) { $ sum = ( ( ord ( $ str1 [ $ i ] ) -48 ) + ( ( ord ( $ str2 [ $ i ] ) -48 ) + $ carry ) ) ; $ str . = chr ( $ sum % 10 + 48 ) ; $ carry = ( int ) ( $ sum / 10 ) ; } for ( $ i = $ n1 ; $ i < $ n2 ; $ i ++ ) { $ sum = ( ( ord ( $ str2 [ $ i ] ) -48 ) + $ carry ) ; $ str . = chr ( $ sum % 10 + 48 ) ; $ carry = ( int ) ( $ sum / 10 ) ; } if ( $ carry ) $ str . = chr ( $ carry + 48 ) ; $ str = strrev ( $ str ) ; return $ str ; } $ str1 = \"12\" ; $ str2 = \"198111\" ; echo findSum ( $ str1 , $ str2 ) ; ? >"}
{"text": "Jumlah dua nombor besar | Fungsi untuk mencari jumlah yang lebih besar; Sebelum meneruskan lagi, pastikan panjang STR2 lebih besar. ; Ambil rentetan kosong untuk menyimpan hasil; Hitung panjang kedua -dua rentetan; Pada mulanya membawa sifar; Melintasi akhir kedua -dua rentetan; Adakah matematik sekolah, mengira jumlah digit semasa dan dibawa; Tambah angka STR2 []; Tambah baki bawa; rentetan hasil terbalik; Kod pemacu", "code": "< ? php function findSum ( $ str1 , $ str2 ) { if ( strlen ( $ str1 ) > strlen ( $ str2 ) ) { $ temp = $ str1 ; $ str1 = $ str2 ; $ str2 = $ temp ; } $ str3 = \" \" ; $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; $ diff = $ n2 - $ n1 ; $ carry = 0 ; for ( $ i = $ n1 - 1 ; $ i >= 0 ; $ i -- ) { $ sum = ( ( ord ( $ str1 [ $ i ] ) - ord ( '0' ) ) + ( ( ord ( $ str2 [ $ i + $ diff ] ) - ord ( '0' ) ) ) + $ carry ) ; $ str3 . = chr ( $ sum % 10 + ord ( '0' ) ) ; $ carry = ( int ) ( $ sum / 10 ) ; } for ( $ i = $ n2 - $ n1 - 1 ; $ i >= 0 ; $ i -- ) { $ sum = ( ( ord ( $ str2 [ $ i ] ) - ord ( '0' ) ) + $ carry ) ; $ str3 . = chr ( $ sum % 10 + ord ( '0' ) ) ; $ carry = ( int ) ( $ sum / 10 ) ; } if ( $ carry ) $ str3 . = chr ( $ carry + ord ( '0' ) ) ; return strrev ( $ str3 ) ; } $ str1 = \"12\" ; $ str2 = \"198111\" ; print ( findSum ( $ str1 , $ str2 ) ) ; ? >"}
{"text": "Periksa dengan cekap jika rentetan mempunyai semua aksara unik tanpa menggunakan sebarang struktur data tambahan | Pulangan benar jika semua watak STR adalah unik. Andaian: (1) STR mengandungi hanya aksara dari 'A' hingga 'Z' (2) integer disimpan menggunakan 32 bit; Integer untuk menyimpan kehadiran / ketiadaan 26 aksara menggunakan 32 bitnya. ; Jika bit sepadan dengan watak semasa sudah ditetapkan; Tetapkan bit dalam pemeriksa; Kod pemacu", "code": "< ? php function areChractersUnique ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < $ len = strlen ( $ str ) ; ++ $ i ) { $ val = ( $ str [ $ i ] - ' a ' ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return false ; $ checker |= ( 1 << $ val ) ; } return true ; } $ s = \" aaabbccdaa \" ; if ( areChractersUnique ( $ s ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Count of words yang i | Kembalikan kiraan perkataan. ; Jika perkataan mengandungi huruf tunggal, kembali 1 .; Memeriksa surat pertama. ; Melintasi rentetan dan mendarabkan untuk kombinasi. ; Jika ketiga -tiga huruf itu sama. ; Jika dua huruf berbeza. ; Jika ketiga -tiga huruf itu berbeza. ; Memeriksa surat terakhir. ; Kod pemacu", "code": "< ? php function countWords ( $ str , $ len ) { $ count = 1 ; if ( $ len == 1 ) return $ count ; if ( $ str [ 0 ] == $ str [ 1 ] ) $ count *= 1 ; else $ count *= 2 ; for ( $ j = 1 ; $ j < $ len - 1 ; $ j ++ ) { if ( $ str [ $ j ] == $ str [ $ j - 1 ] && $ str [ $ j ] == $ str [ $ j + 1 ] ) $ count *= 1 ; else if ( $ str [ $ j ] == $ str [ $ j - 1 ] $ str [ $ j ] == $ str [ $ j + 1 ] $ str [ $ j - 1 ] == $ str [ $ j + 1 ] ) $ count *= 2 ; else $ count *= 3 ; } if ( $ str [ $ len - 1 ] == $ str [ $ len - 2 ] ) $ count *= 1 ; else $ count *= 2 ; return $ count ; } $ str = \" abc \" ; $ len = strlen ( $ str ) ; echo countWords ( $ str , $ len ) ; ? >"}
{"text": "Jumlah maksimum dan minimum dari dua nombor dengan penggantian digit | Cari nilai baru x selepas menggantikan digit \"dari\" ke \"ke\"; Digit yang diperlukan dijumpai, menggantikannya; Mengembalikan jumlah maksimum dan minimum kemungkinan X1 dan X2 jika penggantian digit dibenarkan. ; Kami sentiasa mendapat jumlah minimum jika kami menggantikan 6 dengan 5 .; Kami sentiasa mendapat jumlah maksimum jika kami menggantikan 5 dengan 6 .; Kod pemacu", "code": "< ? php function replaceDig ( $ x , $ from , $ to ) { $ result = 0 ; $ multiply = 1 ; while ( $ x > 0 ) { $ reminder = $ x % 10 ; if ( $ reminder == $ from ) $ result = $ result + $ to * $ multiply ; else $ result = $ result + $ reminder * $ multiply ; $ multiply *= 10 ; $ x = $ x / 10 ; } return $ result ; } function calculateMinMaxSum ( $ x1 , $ x2 ) { $ minSum = replaceDig ( $ x1 , 6 , 5 ) + replaceDig ( $ x2 , 6 , 5 ) ; $ maxSum = replaceDig ( $ x1 , 5 , 6 ) + replaceDig ( $ x2 , 5 , 6 ) ; echo \" Minimum sum = \" ▁ , ▁ $ minSum , \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" Maximum sum = \" } $ x1 = 5466 ; $ x2 = 4555 ; calculateMinMaxSum ( $ x1 , $ x2 ) ; ? >"}
{"text": "Pertanyaan pada pembentukan palindrome substring | Jenis pertanyaan 1: Kemas kini Posisi String I dengan aksara x. ; Cetak \"ya\" jika julat [l. . R] boleh membentuk palindrome, cetak lain \"tidak\". ; Cari kekerapan setiap watak dalam S [l ... r]. ; Memeriksa jika lebih daripada satu aksara mempunyai kekerapan lebih besar daripada 1; Kod pemacu", "code": "< ? php function qType1 ( $ l , $ x , & $ str ) { $ str [ $ l - 1 ] = $ x ; } function qType2 ( $ l , $ r , $ str ) { $ freq = array_fill ( 0 , 27 , 0 ) ; for ( $ i = $ l - 1 ; $ i <= $ r - 1 ; $ i ++ ) $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; $ count = 0 ; for ( $ j = 0 ; $ j < 26 ; $ j ++ ) if ( $ freq [ $ j ] % 2 ) $ count ++ ; ( $ count <= 1 ) ? ( print ( \" Yes STRNEWLINE \" ) ) : ( print ( \" No STRNEWLINE \" ) ) ; } $ str = \" geeksforgeeks \" ; $ n = strlen ( $ str ) ; qType1 ( 4 , ' g ' , $ str ) ; qType2 ( 1 , 4 , $ str ) ; qType2 ( 2 , 3 , $ str ) ; qType1 ( 10 , ' t ' , $ str ) ; qType2 ( 10 , 11 , $ str ) ; ? >"}
{"text": "Kaedah yang cekap untuk pelengkap 2 rentetan binari | Berfungsi untuk mencari pelengkap dua; Melintasi rentetan untuk mendapatkan '1' pertama dari rentetan terakhir; Sekiranya tidak ada '1' Concatenate 1 pada permulaan rentetan; Teruskan traversal selepas kedudukan pertama '1'; Hanya flip nilai -nilai; Kembalikan rentetan yang diubah suai; Kod pemacu", "code": "< ? php function findTwoscomplement ( $ str ) { $ n = strlen ( $ str ) ; $ i ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) if ( $ str [ $ i ] == '1' ) break ; if ( $ i == -1 ) return '1' + $ str ; for ( $ k = $ i - 1 ; $ k >= 0 ; $ k -- ) { if ( $ str [ $ k ] == '1' ) $ str [ $ k ] = '0' ; else $ str [ $ k ] = '1' ; } return $ str ; ; } $ str = \"00000101\" ; echo findTwoscomplement ( $ str ) ; ? >"}
{"text": "Semak panjang rentetan adalah sama dengan nombor yang dilampirkan pada yang terakhir | Fungsi untuk mencari jika nombor yang diberikan adalah sama dengan panjang atau tidak; Traverse String dari hujung dan cari nombor yang disimpan pada akhir. X digunakan untuk menyimpan kuasa 10 .; Semak sama ada nombor adalah sama dengan panjang rentetan kecuali digit nombor itu; Kod pemacu", "code": "< ? php function isequal ( $ str ) { $ n = strlen ( $ str ) ; $ num = 0 ; $ x = 1 ; $ i = $ n - 1 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( '0' <= $ str [ $ i ] && $ str [ $ i ] <= '9' ) { $ num = ( $ str [ $ i ] - '0' ) * $ x + $ num ; $ x = $ x * 10 ; if ( $ num >= $ n ) return false ; } else break ; } return $ num == $ i + 1 ; } $ str = \" geeksforgeeks13\" ; if ( isequal ( $ str ) ) echo \" Yes \" ; else echo \" No \" ; return 0 ; ? >"}
{"text": "Bilangan minimum aksara yang akan dikeluarkan untuk membuat alternatif rentetan binari | Mengembalikan kiraan aksara minimum yang akan dikeluarkan untuk membuat s bergantian. ; Jika dua watak bergantian rentetan adalah sama; Kemudian perlu memadam watak; Kod pemacu", "code": "< ? php function countToMake0lternate ( $ s ) { $ result = 0 ; for ( $ i = 0 ; $ i < ( strlen ( $ s ) - 1 ) ; $ i ++ ) if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ result ++ ; return $ result ; } echo countToMake0lternate ( \" 000111 \" ) , \" \" ; echo countToMake0lternate ( \" 11111 \" ) , \" \" ; echo countToMake0lternate ( \" 01010101 \" ) ; ? >"}
{"text": "Palindrome terkecil selepas penggantian | Kaedah utiliti untuk memeriksa STR adalah kemungkinan palindrome selepas mengabaikan; Jika kedua -dua watak kiri dan kanan tidak titik dan mereka tidak sama juga, maka tidak mungkin untuk membuat rentetan ini palindrome; Mengembalikan rentetan palindrome terkecil secara leksikografi, jika boleh; gelung melalui watak rentetan; Jika salah satu watak adalah titik, gantikan titik dengan watak lain; Jika kedua -dua watak itu titik, maka gantikannya dengan watak terkecil 'A'; mengembalikan hasilnya; Kod pemacu", "code": "< ? php function isPossiblePalindrome ( $ str ) { $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) { if ( $ str [ $ i ] != ' . ' && $ str [ $ n - $ i - 1 ] != ' . ' && $ str [ $ i ] != $ str [ $ n - $ i - 1 ] ) return false ; } return true ; } function smallestPalindrome ( $ str ) { if ( ! isPossiblePalindrome ( $ str ) ) return \" Not ▁ Possible \" ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' . ' ) { if ( $ str [ $ n - $ i - 1 ] != ' . ' ) $ str [ $ i ] = $ str [ $ n - $ i - 1 ] ; else $ str [ $ i ] = $ str [ $ n - $ i - 1 ] = ' a ' ; } } return $ str ; } $ str = \" ab . . e . c . a \" ; echo smallestPalindrome ( $ str ) ; ? >"}
{"text": "Bilangan singkat untuk membuat alternatif rentetan binari | Tetapkan 1 | Kaedah utiliti untuk membalikkan watak; Kaedah utiliti untuk mendapatkan flip minimum apabila rentetan alternatif bermula dengan char yang diharapkan; Jika watak semasa tidak dijangka, tingkatkan kiraan flip; flip watak yang diharapkan setiap kali; Kaedah mengembalikan flip minimum untuk membuat alternatif rentetan binari; kembali minimum berikut dua 1) flip apabila rentetan alternatif bermula dengan 0 2) flips apabila rentetan alternatif bermula dengan 1; Kod pemacu untuk menguji kaedah di atas", "code": "< ? php function flip ( $ ch ) { return ( $ ch == '0' ) ? '1' : '0' ; } function getFlipWithStartingCharcter ( $ str , $ expected ) { $ flipCount = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] != $ expected ) $ flipCount ++ ; $ expected = flip ( $ expected ) ; } return $ flipCount ; } function minFlipToMakeStringAlternate ( $ str ) { return min ( getFlipWithStartingCharcter ( $ str , '0' ) , getFlipWithStartingCharcter ( $ str , '1' ) ) ; } $ str = \"0001010111\" ; echo minFlipToMakeStringAlternate ( $ str ) ; ? >"}
{"text": "Sisa dengan 7 untuk jumlah besar | Fungsi yang mengembalikan baki selepas membahagikan nombor sebanyak 7; Siri ini digunakan untuk mencari baki dengan 7; Indeks elemen seterusnya dalam siri; Memulakan hasil; Traverse Num dari End; Cari digit semasa NUM; Tambah istilah seterusnya untuk keputusan; Pindah ke istilah seterusnya dalam siri; Pastikan keputusan itu tidak pernah melampaui 7 .; Pastikan baki itu positif; Kod pemacu", "code": "< ? php function remainderWith7 ( $ num ) { $ series = array ( 1 , 3 , 2 , -1 , -3 , -2 ) ; $ series_index = 0 ; $ result = 0 ; for ( $ i = strlen ( $ num ) - 1 ; $ i >= 0 ; $ i -- ) { $ digit = $ num [ $ i ] - '0' ; $ result += $ digit * $ series [ $ series_index ] ; $ series_index = ( $ series_index + 1 ) % 6 ; $ result %= 7 ; } if ( $ result < 0 ) $ result = ( $ result + 7 ) % 7 ; return $ result ; } { $ str = \"12345\" ; echo \" Remainder ▁ with ▁ 7 ▁ is ▁ \" , ( remainderWith7 ( $ str ) ) ; return 0 ; } ? >"}
{"text": "Menukar nombor perpuluhan yang terletak di antara 1 hingga 3999 hingga angka Roman | Berfungsi untuk mengira setara Roman; menyimpan nilai -nilai Rom dari 0 - 9 apabila diletakkan di tempat yang berbeza; Menukar kepada Roman; Kod pemacu", "code": "< ? php function intToRoman ( $ num ) { $ m = array ( \" \" , \" M \" , \" MM \" , \" MMM \" ) ; $ c = array ( \" \" , \" C \" , \" CC \" , \" CCC \" , \" CD \" , \" D \" , \" DC \" , \" DCC \" , \" DCCC \" , \" CM \" ) ; $ x = array ( \" \" , \" X \" , \" XX \" , \" XXX \" , \" XL \" , \" L \" , \" LX \" , \" LXX \" , \" LXXX \" , \" XC \" ) ; $ i = array ( \" \" , \" I \" , \" II \" , \" III \" , \" IV \" , \" V \" , \" VI \" , \" VII \" , \" VIII \" , \" IX \" ) ; $ thousands = $ m [ $ num / 1000 ] ; $ hundereds = $ c [ ( $ num % 1000 ) / 100 ] ; $ tens = $ x [ ( $ num % 100 ) / 10 ] ; $ ones = $ i [ $ num % 10 ] ; $ ans = $ thousands . $ hundereds . $ tens . $ ones ; return $ ans ; } $ number = 3549 ; echo intToRoman ( $ number ) ;"}
{"text": "Cetak rentetan panjang ganjil dalam format 'x' | Berfungsi untuk mencetak rentetan yang diberikan dalam corak silang; Saya dan j adalah indeks aksara yang akan dipaparkan dalam lelaran ith i = 0 pada mulanya dan pergi sehingga panjang rentetan j = panjang rentetan pada mulanya dalam setiap lelaran i, kita kenaikan i dan pengurangan j, kita mencetak watak hanya k == i atau k == j; Kod pemacu", "code": "< ? php function pattern ( $ str , $ len ) { for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ j = $ len - 1 - $ i ; for ( $ k = 0 ; $ k < $ len ; $ k ++ ) { if ( $ k == $ i $ k == $ j ) echo $ str [ $ k ] ; else echo \" ▁ \" ; } echo \" STRNEWLINE \" ; } } $ str = \" geeksforgeeks \" ; $ len = strlen ( $ str ) ; pattern ( $ str , $ len ) ; ? >"}
{"text": "Cari tetingkap terkecil dalam rentetan yang mengandungi semua aksara rentetan lain | Program PHP untuk mencari tetingkap terkecil yang mengandungi semua aksara corak. ; Berfungsi untuk mencari tetingkap terkecil yang mengandungi semua aksara 'pat'; Semak jika rentetan rentetan ~ u kurang daripada panjang corak. Jika ya maka tidak ada tetingkap sedemikian boleh wujud; menyimpan kejadian watak corak; Mula melintasi rentetan $ count = 0; mengira watak; Mengira kejadian watak rentetan; Jika rentetan rentetan ~ perlawanan ~ dengan char corak maka kiraan kenaikan; Jika semua watak dipadankan; Cuba meminimumkan tetingkap i. e. , periksa jika ada watak yang berlaku lebih banyak. masa daripada kejadiannya dalam corak, jika ya kemudian keluarkannya dari permulaan dan juga keluarkan aksara yang tidak berguna. ; Saiz tetingkap kemas kini; Jika tiada tetingkap dijumpai; Kembali substring bermula dari start_index dan panjang min_len; Kod pemacu", "code": "< ? php define ( \" no _ of _ chars \" , 256 ) ; function findSubString ( & $ str , & $ pat ) { $ len1 = strlen ( $ str ) ; $ len2 = strlen ( $ pat ) ; if ( $ len1 < $ len2 ) { echo \" No ▁ such ▁ window ▁ exists \" ; return \" \" ; } $ hash_pat = array_fill ( 0 , no_of_chars , 0 ) ; $ hash_str = array_fill ( 0 , no_of_chars , 0 ) ; for ( $ i = 0 ; $ i < $ len2 ; $ i ++ ) $ hash_pat [ ord ( $ pat [ $ i ] ) ] ++ ; $ start = 0 ; $ start_index = -1 ; $ min_len = PHP_INT_MAX ; for ( $ j = 0 ; $ j < $ len1 ; $ j ++ ) { $ hash_str [ ord ( $ str [ $ j ] ) ] ++ ; if ( $ hash_str [ ord ( $ str [ $ j ] ) ] <= $ hash_pat [ ord ( $ str [ $ j ] ) ] ) $ count ++ ; if ( $ count == $ len2 ) { while ( $ hash_str [ ord ( $ str [ $ start ] ) ] > $ hash_pat [ ord ( $ str [ $ start ] ) ] || $ hash_pat [ ord ( $ str [ $ start ] ) ] == 0 ) { if ( $ hash_str [ ord ( $ str [ $ start ] ) ] > $ hash_pat [ ord ( $ str [ $ start ] ) ] ) $ hash_str [ ord ( $ str [ $ start ] ) ] -- ; $ start ++ ; } $ len_window = $ j - $ start + 1 ; if ( $ min_len > $ len_window ) { $ min_len = $ len_window ; $ start_index = $ start ; } } } if ( $ start_index == -1 ) { echo \" No ▁ such ▁ window ▁ exists \" ; return \" \" ; } return substr ( $ str , $ start_index , $ min_len ) ; } $ str = \" this ▁ is ▁ a ▁ test ▁ string \" ; $ pat = \" tist \" ; echo \" Smallest ▁ window ▁ is ▁ : ▁ STRNEWLINE \" . findSubString ( $ str , $ pat ) ; ? >"}
{"text": "Nombor Perdana selepas Perdana P dengan jumlah S | vektor untuk menyimpan prime dan primes yang jumlahnya sama dengan s; berfungsi untuk memeriksa nombor perdana; akar persegi x; kerana 1 bukan nombor utama; jika ada faktor yang dijumpai kembali palsu; Tiada faktor yang dijumpai; berfungsi untuk memaparkan n prima yang jumlahnya sama dengan s; berfungsi untuk menilai semua kemungkinan n prima yang jumlahnya sama dengan s; jika jumlah sama dengan s dan jumlah dicapai menggunakan primes N; Paparkan prima N; jika jumlah lebih besar daripada S atau jika indeks telah mencapai elemen terakhir; Tambah Perdana [indeks] untuk menetapkan vektor; termasuk (indeks) perdana kepada jumlah; Keluarkan elemen dari vektor set; tidak termasuk (indeks) perdana; berfungsi untuk menjana semua prima; Semua prima kurang daripada S sendiri; Jika saya adalah Perdana Tambahnya ke Vektor Perdana; jika prima kurang daripada n; Kod pemacu", "code": "< ? php $ set = array ( ) ; $ prime = array ( ) ; function isPrime ( $ x ) { $ sqroot = sqrt ( $ x ) ; $ flag = true ; if ( $ x == 1 ) return false ; for ( $ i = 2 ; $ i <= $ sqroot ; $ i ++ ) if ( $ x % $ i == 0 ) return false ; return true ; } function display ( ) { global $ set , $ prime ; $ length = count ( $ set ) ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) echo ( $ set [ $ i ] . \" ▁ \" ) ; echo ( \" STRNEWLINE \" ) ; } function primeSum ( $ total , $ N , $ S , $ index ) { global $ set , $ prime ; if ( $ total == $ S && count ( $ set ) == $ N ) { display ( ) ; return ; } if ( $ total > $ S || $ index == count ( $ prime ) ) return ; array_push ( $ set , $ prime [ $ index ] ) ; primeSum ( $ total + $ prime [ $ index ] , $ N , $ S , $ index + 1 ) ; array_pop ( $ set ) ; primeSum ( $ total , $ N , $ S , $ index + 1 ) ; } function allPrime ( $ N , $ S , $ P ) { global $ set , $ prime ; for ( $ i = $ P + 1 ; $ i <= $ S ; $ i ++ ) { if ( isPrime ( $ i ) ) array_push ( $ prime , $ i ) ; } if ( count ( $ prime ) < $ N ) return ; primeSum ( 0 , $ N , $ S , 0 ) ; } $ S = 54 ; $ N = 2 ; $ P = 3 ; allPrime ( $ N , $ S , $ P ) ; ? >"}
{"text": "Cari 2 ^ (2 ^ a) % b | Berfungsi untuk mengembalikan 2 ^ (2 ^ a) % b; $ Kes asas, 2 ^ (2 ^ 1) % b = 4 % b; Kod pemacu; Cetak 2 ^ (2 ^ $ a) % $ B", "code": "< ? php function F ( $ A , $ B ) { if ( $ A == 1 ) return ( 4 % $ B ) ; else { $ temp = F ( $ A - 1 , $ B ) ; return ( $ temp * $ temp ) % $ B ; } } $ A = 25 ; $ B = 50 ; echo F ( $ A , $ B ) ;"}
{"text": "Jumlah i * Countdigits (i) ^ 2 untuk semua i dalam julat [l, r] | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan jumlah yang diperlukan; Jika julat sah; Jumlah AP; Kod pemacu", "code": "< ? php $ MOD = 1000000007 ; function rangeSum ( $ l , $ r ) { global $ MOD ; $ a = 1 ; $ b = 9 ; $ res = 0 ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { $ L = max ( $ l , $ a ) ; $ R = min ( $ r , $ b ) ; if ( $ L <= $ R ) { $ sum = ( $ L + $ R ) * ( $ R - $ L + 1 ) / 2 ; $ res += ( $ i * $ i ) * ( $ sum % $ MOD ) ; $ res %= $ MOD ; } $ a = $ a * 10 ; $ b = $ b * 10 + 9 ; } return $ res ; } $ l = 98 ; $ r = 102 ; echo rangeSum ( $ l , $ r ) ; ? >"}
{"text": "Menjana permutasi rawak unsur -unsur dari julat [l, r] (membahagikan dan menaklukkan) | Untuk menyimpan permutasi rawak; Fungsi utiliti untuk mencetak permutasi yang dihasilkan; Berfungsi untuk mengembalikan nombor rawak antara x dan y; Fungsi rekursif untuk menjana permutasi rawak; Keadaan asas; Nombor rawak dikembalikan dari fungsi; Memasukkan nombor rawak dalam vektor; Panggilan rekursi untuk [l, n - 1]; Panggilan rekursi untuk [n + 1, r]; Kod pemacu; Menjana permutasi; Cetak permutasi yang dihasilkan", "code": "< ? php $ permutation = array ( ) ; function printPermutation ( ) { global $ permutation ; foreach ( $ permutation as $ i ) echo $ i . \" \" ; } function give_random_number ( $ l , $ r ) { $ x = rand ( ) % ( $ r - $ l + 1 ) + $ l ; return $ x ; } function generate_random_permutation ( $ l , $ r ) { global $ permutation ; if ( $ l > $ r ) return ; $ n = give_random_number ( $ l , $ r ) ; array_push ( $ permutation , $ n ) ; generate_random_permutation ( $ l , $ n - 1 ) ; generate_random_permutation ( $ n + 1 , $ r ) ; } $ l = 5 ; $ r = 15 ; generate_random_permutation ( $ l , $ r ) ; printPermutation ( ) ; ? >"}
{"text": "Nombor minimum n seperti jumlah bit set semua nombor dari 1 hingga n adalah di | Fungsi untuk mengira jumlah bit set semua nombor sehingga n; Berfungsi untuk mencari nombor minimum; Carian binari untuk nombor terendah; Cari nombor pertengahan; Semak jika ia adalah atleast x; Kod pemacu", "code": "< ? php function getSetBitsFromOneToN ( $ N ) { $ two = 2 ; $ ans = 0 ; $ n = $ N ; while ( $ n ) { $ ans += ( int ) ( $ N / $ two ) * ( $ two >> 1 ) ; if ( ( $ N & ( $ two - 1 ) ) > ( $ two >> 1 ) - 1 ) $ ans += ( $ N & ( $ two - 1 ) ) - ( $ two >> 1 ) + 1 ; $ two <<= 1 ; $ n >>= 1 ; } return $ ans ; } function findMinimum ( $ x ) { $ low = 0 ; $ high = 100000 ; $ ans = $ high ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) >> 1 ; if ( getSetBitsFromOneToN ( $ mid ) >= $ x ) { $ ans = min ( $ ans , $ mid ) ; $ high = $ mid - 1 ; } else $ low = $ mid + 1 ; } return $ ans ; } $ x = 20 ; echo findMinimum ( $ x ) ; ? >"}
{"text": "Nombor yang faktorialnya berakhir dengan N Zeros | Berfungsi untuk mengira sifar trailing; Carian binari untuk nombor pertama dengan n trailing nol; Cetak semua nombor selepas rendah dengan n trailing nol. ; Hasil cetak; Kod pemacu", "code": "< ? php function trailingZeroes ( $ n ) { $ cnt = 0 ; while ( $ n > 0 ) { $ n = intval ( $ n / 5 ) ; $ cnt += $ n ; } return $ cnt ; } function binarySearch ( $ n ) { $ low = 0 ; while ( $ low < $ high ) { $ mid = intval ( ( $ low + $ high ) / 2 ) ; $ count = trailingZeroes ( $ mid ) ; if ( $ count < $ n ) $ low = $ mid + 1 ; else $ high = $ mid ; } $ result = array ( ) ; while ( trailingZeroes ( $ low ) == $ n ) { array_push ( $ result , $ low ) ; $ low ++ ; } for ( $ i = 0 ; $ i < sizeof ( $ result ) ; $ i ++ ) echo $ result [ $ i ] . \" ▁ \" ; } $ n = 2 ; binarySearch ( $ n ) ; ? >"}
{"text": "Bilangan hari selepas tangki akan menjadi kosong | Kaedah Mengembalikan bilangan minimum hari selepas tangki akan menjadi kosong; Kod pemacu", "code": "< ? php function minDaysToEmpty ( $ C , $ l ) { if ( $ l >= $ C ) return $ C ; $ eq_root = ( int ) sqrt ( 1 + 8 * ( $ C - $ l ) - 1 ) / 2 ; return ceil ( $ eq_root ) + $ l ; } echo minDaysToEmpty ( 5 , 2 ) , \" STRNEWLINE \" ; echo minDaysToEmpty ( 6514683 , 4965 ) , \" \" ; ? >"}
{"text": "K | Program untuk mencari elemen kth dari dua susunan yang disusun; Kod pemacu", "code": "< ? php function kth ( $ arr1 , $ arr2 , $ m , $ n , $ k ) { $ sorted1 [ $ m + $ n ] = 0 ; $ i = 0 ; $ j = 0 ; $ d = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) $ sorted1 [ $ d ++ ] = $ arr1 [ $ i ++ ] ; else $ sorted1 [ $ d ++ ] = $ arr2 [ $ j ++ ] ; } while ( $ i < $ m ) $ sorted1 [ $ d ++ ] = $ arr1 [ $ i ++ ] ; while ( $ j < $ n ) $ sorted1 [ $ d ++ ] = $ arr2 [ $ j ++ ] ; return $ sorted1 [ $ k - 1 ] ; } $ arr1 = array ( 2 , 3 , 6 , 7 , 9 ) ; $ arr2 = array ( 1 , 4 , 8 , 10 ) ; $ k = 5 ; echo kth ( $ arr1 , $ arr2 , 5 , 4 , $ k ) ; ? >"}
{"text": "Perbezaan minimum antara unsur -unsur array bersebelahan yang mengandungi unsur -unsur dari setiap baris matriks | Program PHP untuk mencari perbezaan mutlak minimum antara mana -mana elemen bersebelahan dengan array yang dicipta dengan memilih satu elemen dari setiap baris matriks. ; Kembalikan elemen terkecil lebih besar daripada atau sama dengan elemen semasa. ; Mengembalikan perbezaan mutlak minimum unsur -unsur pelbagai; Susun setiap baris matriks. ; Untuk setiap elemen matriks; Cari elemen terkecil dalam baris seterusnya yang lebih besar daripada atau sama dengan elemen semasa; Elemen terbesar yang lebih kecil daripada elemen semasa dalam baris seterusnya mestilah sebelum elemen terkecil yang lebih besar daripada atau sama dengan elemen semasa kerana baris disusun. ; Kod pemacu", "code": "< ? php $ R = 2 ; $ C = 2 ; function bsearch ( $ low , $ high , $ n , $ arr ) { $ mid = ( $ low + $ high ) / 2 ; if ( $ low <= $ high ) { if ( $ arr [ $ mid ] < $ n ) return bsearch ( $ mid + 1 , $ high , $ n , $ arr ) ; return bsearch ( $ low , $ mid - 1 , $ n , $ arr ) ; } return $ low ; } function mindiff ( $ arr , $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) sort ( $ arr ) ; $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { $ p = bsearch ( 0 , $ m - 1 , $ arr [ $ i ] [ $ j ] , $ arr [ $ i + 1 ] ) ; $ ans = min ( $ ans , abs ( $ arr [ $ i + 1 ] [ $ p ] - $ arr [ $ i ] [ $ j ] ) ) ; if ( $ p - 1 >= 0 ) $ ans = min ( $ ans , abs ( $ arr [ $ i + 1 ] [ $ p - 1 ] - $ arr [ $ i ] [ $ j ] ) ) ; } } return $ ans ; } $ m = array ( 8 , 5 , 6 , 8 ) ; echo mindiff ( $ m , $ R , $ C ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari titik bitonic dalam urutan bitonic yang diberikan | Berfungsi untuk mencari titik bitonic menggunakan carian binari; Keadaan asas untuk memeriksa sama ada ARR [pertengahan] adalah titik bitonic atau tidak; Kami menganggap bahawa urutan adalah bitonic. Kami pergi ke subarray kanan jika titik tengah adalah sebahagian daripada peningkatan seterusnya. Lain kita pergi ke subarray kiri. ; Kod pemacu", "code": "< ? php function binarySearch ( $ arr , $ left , $ right ) { if ( $ left <= $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ arr [ $ mid - 1 ] < $ arr [ $ mid ] && $ arr [ $ mid ] > $ arr [ $ mid + 1 ] ) return $ mid ; if ( $ arr [ $ mid ] < $ arr [ $ mid + 1 ] ) return binarySearch ( $ arr , $ mid + 1 , $ right ) ; else return binarySearch ( $ arr , $ left , $ mid - 1 ) ; } return -1 ; } $ arr = array ( 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 ) ; $ n = sizeof ( $ arr ) ; $ index = binarySearch ( $ arr , 1 , $ n - 2 ) ; if ( $ index != -1 ) echo $ arr [ $ index ] ; ? >"}
{"text": "Cari satu -satunya elemen berulang dalam pelbagai saiz saiz n | Mengembalikan indeks penampilan kedua elemen berulang. Fungsi ini mengandaikan bahawa unsur -unsur array berada dalam jarak dari 1 hingga n - 1; rendah = 0, tinggi = n - 1; ; Semak jika elemen pertengahan adalah pengulangan; Jika elemen pertengahan tidak berada di kedudukannya yang bermaksud elemen berulang di sebelah kiri; Sekiranya pertengahan berada pada kedudukan yang betul maka diulangi ada yang betul. ; Kod pemacu", "code": "< ? php function findRepeatingElement ( $ arr , $ low , $ high ) { if ( $ low > $ high ) return -1 ; $ mid = floor ( ( $ low + $ high ) / 2 ) ; if ( $ arr [ $ mid ] != $ mid + 1 ) { if ( $ mid > 0 && $ arr [ $ mid ] == $ arr [ $ mid - 1 ] ) return $ mid ; return findRepeatingElement ( $ arr , $ low , $ mid - 1 ) ; } return findRepeatingElement ( $ arr , $ mid + 1 , $ high ) ; } $ arr = array ( 1 , 2 , 3 , 3 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; $ index = findRepeatingElement ( $ arr , 0 , $ n - 1 ) ; if ( $ index != -1 ) echo $ arr [ $ index ] ; ? >"}
{"text": "Cari akar kubik nombor | Mengembalikan nilai mutlak N - pertengahan * pertengahan * pertengahan; Mengembalikan akar kiub no n; Tetapkan permulaan dan tamat untuk carian binari; Tetapkan ketepatan; Jika kesilapan kurang daripada E maka pertengahan adalah jawapan kami sehingga kembali pertengahan; Jika pertengahan * pertengahan * pertengahan lebih besar daripada n set end = pertengahan; Jika pertengahan * pertengahan * pertengahan kurang daripada n set start = mid; Kod pemacu", "code": "< ? php function diff ( $ n , $ mid ) { if ( $ n > ( $ mid * $ mid * $ mid ) ) return ( $ n - ( $ mid * $ mid * $ mid ) ) ; else return ( ( $ mid * $ mid * $ mid ) - $ n ) ; } function cubicRoot ( $ n ) { $ start = 0 ; $ end = $ n ; $ e = 0.0000001 ; while ( true ) { $ mid = ( ( $ start + $ end ) / 2 ) ; $ error = diff ( $ n , $ mid ) ; if ( $ error <= $ e ) return $ mid ; if ( ( $ mid * $ mid * $ mid ) > $ n ) $ end = $ mid ; else $ start = $ mid ; } } $ n = 3 ; echo ( \" Cubic ▁ root ▁ of ▁ $ n ▁ is ▁ \" ) ; echo ( cubicRoot ( $ n ) ) ; ? >"}
{"text": "Akar persegi integer | Mengembalikan lantai akar persegi x; Kes asas; Bermula dari 1, cuba semua nombor sehingga saya * saya lebih besar daripada atau sama dengan x. ; Kod pemacu", "code": "< ? php function floorSqrt ( $ x ) { if ( $ x == 0 $ x == 1 ) return $ x ; $ i = 1 ; $ result = 1 ; while ( $ result <= $ x ) { $ i ++ ; $ result = $ i * $ i ; } return $ i - 1 ; } $ x = 11 ; echo floorSqrt ( $ x ) , \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah sudut dalaman poligon | Berfungsi untuk mengembalikan jumlah sudut dalaman poligon n - sisi; Kod pemacu", "code": "< ? php function sumOfInternalAngles ( $ n ) { if ( $ n < 3 ) return 0 ; return ( ( $ n - 2 ) * 180 ) ; } $ n = 5 ; echo ( sumOfInternalAngles ( $ n ) ) ; ? >"}
{"text": "Cari pepenjuru kiub | Berfungsi untuk mencari panjang pepenjuru kiub; Formula untuk mencari panjang pepenjuru kiub; Kod pemacu; Panggilan fungsi", "code": "< ? php function diagonal_length ( $ a ) { $ L ; $ L = $ a * sqrt ( 3 ) ; return $ L ; } $ a = 5 ; echo diagonal_length ( $ a ) ; ? >"}
{"text": "Cari kawasan bulatan yang lebih besar apabila jejari bulatan yang lebih kecil dan perbezaan di kawasan diberikan | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan kawasan bulatan yang lebih besar; Cari jejari bulatan yang lebih besar; Kirakan kawasan bulatan yang lebih besar; Kod pemacu", "code": "< ? php const PI = 3.14 ; function find_area ( $ r , $ d ) { $ R = $ d / PI ; $ R += pow ( $ r , 2 ) ; $ R = sqrt ( $ R ) ; $ area = PI * pow ( $ R , 2 ) ; return $ area ; } $ r = 4 ; $ d = 5 ; echo ( find_area ( $ r , $ d ) ) ; ? >"}
{"text": "Semak sama ada segiempat adalah sah atau tidak jika sudut diberikan | Fungsi untuk memeriksa sama ada segiempat yang diberikan adalah sah atau tidak; Periksa keadaan; Kod pemacu", "code": "< ? php function Valid ( $ a , $ b , $ c , $ d ) { if ( $ a + $ b + $ c + $ d == 360 ) return true ; return false ; } $ a = 80 ; $ b = 70 ; $ c = 100 ; $ d = 110 ; if ( Valid ( $ a , $ b , $ c , $ d ) ) echo ( \" Valid ▁ quadrilateral \" ) ; else echo ( \" Invalid ▁ quadrilateral \" ) ; ? >"}
{"text": "Bilangan tangen biasa antara dua kalangan jika pusat dan jejari mereka diberikan | Program PHP untuk mencari bilangan tangen biasa antara kedua -dua kalangan; Kod pemacu", "code": "< ? php function circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) { $ distSq = ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ; $ radSumSq = ( $ r1 + $ r2 ) * ( $ r1 + $ r2 ) ; if ( $ distSq == $ radSumSq ) return 1 ; else if ( $ distSq > $ radSumSq ) return -1 ; else return 0 ; } $ x1 = -10 ; $ y1 = 8 ; $ x2 = 14 ; $ y2 = -24 ; $ r1 = 30 ; $ r2 = 10 ; $ t = circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) ; if ( $ t == 1 ) echo \" There ▁ are ▁ 3 ▁ common ▁ tangents \" , \" ▁ between ▁ the ▁ circles . \" ; else if ( $ t < 0 ) echo \" There ▁ are ▁ 4 ▁ common ▁ tangents \" , \" ▁ between ▁ the ▁ circles . \" ; else echo \" There ▁ are ▁ 2 ▁ common ▁ tangents \" , \" ▁ between ▁ the ▁ circles . \" ; ? >"}
{"text": "Nisbah jarak antara pusat -pusat bulatan dan titik persimpangan dua tangen umum melintang ke lingkaran | Program PHP untuk mencari nisbah jarak antara pusat -pusat bulatan dan titik persimpangan dua tangen umum melintang ke kalangan yang tidak menyentuh satu sama lain; Fungsi untuk mencari nisbah; Kod pemacu", "code": "< ? php function GCD ( $ a , $ b ) { return ( $ b != 0 ? GCD ( $ b , $ a % $ b ) : $ a ) ; } function ratiotang ( $ r1 , $ r2 ) { echo \" The ▁ ratio ▁ is ▁ \" , $ r1 / GCD ( $ r1 , $ r2 ) , \" : \" , $ r2 / GCD ( $ r1 , $ r2 ) ; } $ r1 = 4 ; $ r2 = 8 ; ratiotang ( $ r1 , $ r2 ) ; ? >"}
{"text": "Program untuk mencari bilangan rantau dalam graf planar | Berfungsi untuk mengembalikan bilangan wilayah dalam graf planar; Kod pemacu", "code": "< ? php function Regions ( $ Vertices , $ Edges ) { $ R = $ Edges + 2 - $ Vertices ; return $ R ; } $ V = 5 ; $ E = 7 ; echo ( Regions ( $ V , $ E ) ) ; ? >"}
{"text": "Nisbah jarak antara pusat -pusat bulatan dan titik persimpangan dua tangen umum langsung ke lingkaran | Fungsi untuk mencari GCD; Fungsi untuk mencari nisbah; Kod pemacu", "code": "< ? php function GCD ( $ a , $ b ) { return ( $ b != 0 ? GCD ( $ b , $ a % $ b ) : $ a ) ; } function ratiotang ( $ r1 , $ r2 ) { echo \" The ▁ ratio ▁ is ▁ \" , $ r1 / GCD ( $ r1 , $ r2 ) , \" ▁ : ▁ \" , $ r2 / GCD ( $ r1 , $ r2 ) ; } $ r1 = 4 ; $ r2 = 6 ; ratiotang ( $ r1 , $ r2 ) ; ? >"}
{"text": "Panjang tangen biasa melintang antara dua lingkaran yang tidak bersilang | Berfungsi untuk mencari panjang tangen biasa melintang; Kod pemacu", "code": "< ? php function lengthOfTangent ( $ r1 , $ r2 , $ d ) { echo \" The ▁ length ▁ of ▁ the ▁ transverse ▁ common ▁ tangent ▁ is ▁ \" , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 + $ r2 ) , 2 ) ) ; } $ r1 = 4 ; $ r2 = 6 ; $ d = 12 ; lengthOfTangent ( $ r1 , $ r2 , $ d ) ; ? >"}
{"text": "Kawasan plot yang tinggal di akhir | Berfungsi untuk mengembalikan kawasan plot yang tinggal; Teruskan sementara plot mempunyai kawasan positif dan ada orang yang tersisa; Jika panjang> keluasan kemudian tolak keluasan dari panjang; Lain tolak panjang dari lebar; Kod pemacu", "code": "< ? php function remainingArea ( $ N , $ M , $ K ) { while ( $ K -- && $ N && $ M ) { if ( $ N > $ M ) $ N = $ N - $ M ; else $ M = $ M - $ N ; } if ( $ N > 0 && $ M > 0 ) return $ N * $ M ; else return 0 ; } $ N = 5 ; $ M = 3 ; $ K = 2 ; echo remainingArea ( $ N , $ M , $ K ) ; ? >"}
{"text": "Panjang tangen biasa langsung antara dua lingkaran menyentuh luaran | Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "< ? php function lengtang ( $ r1 , $ r2 ) { echo \" The ▁ length ▁ of ▁ the ▁ \" , \" direct ▁ common ▁ tangent ▁ is ▁ \" , 2 * sqrt ( $ r1 * $ r2 ) ; } $ r1 = 5 ; $ r2 = 9 ; lengtang ( $ r1 , $ r2 ) ; ? >"}
{"text": "Jarak terpendek antara satu titik dan bulatan | Berfungsi untuk mencari jarak terpendek; Kod pemacu", "code": "< ? php function dist ( $ x1 , $ y1 , $ x2 , $ y2 , $ r ) { echo \" The ▁ shortest ▁ distance ▁ between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ \" , sqrt ( ( pow ( ( $ x2 - $ x1 ) , 2 ) ) + ( pow ( ( $ y2 - $ y1 ) , 2 ) ) ) - $ r ; } $ x1 = 4 ; $ y1 = 6 ; $ x2 = 35 ; $ y2 = 42 ; $ r = 5 ; dist ( $ x1 , $ y1 , $ x2 , $ y2 , $ r ) ; ? >"}
{"text": "Jarak antara dua baris selari | Berfungsi untuk mencari jarak antara garis selari; Kod pemacu", "code": "< ? php function dist ( $ m , $ b1 , $ b2 ) { $ d = abs ( $ b2 - $ b1 ) / ( ( $ m * $ m ) - 1 ) ; return $ d ; } $ m = 2 ; $ b1 = 4 ; $ b2 = 3 ; echo dist ( $ m , $ b1 , $ b2 ) ; ? >"}
{"text": "Panjang normal dari asal pada garis lurus yang pemintasnya diberikan | Berfungsi untuk mencari normal garis lurus; Panjang normal; Kod pemacu", "code": "< ? php function normal ( $ m , $ n ) { $ N = ( abs ( $ m ) * abs ( $ n ) ) / sqrt ( ( abs ( $ m ) * abs ( $ m ) ) + ( abs ( $ n ) * abs ( $ n ) ) ) ; return $ N ; } $ m = -5 ; $ n = 3 ; echo normal ( $ m , $ n ) ; ? >"}
{"text": "Semak sama ada mungkin untuk membuat poligon dengan sisi N yang diberikan | Fungsi yang mengembalikan benar jika mungkin untuk membentuk poligon dengan sisi yang diberikan; Jumlah menyimpan jumlah semua sisi dan maxs menyimpan panjang bahagian terbesar; Jika panjang bahagian terbesar adalah kurang daripada jumlah yang lain yang tersisa; Kod pemacu", "code": "< ? php function isPossible ( $ a , $ n ) { $ sum = 0 ; $ maxS = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; $ maxS = max ( $ a [ $ i ] , $ maxS ) ; } if ( ( $ sum - $ maxS ) > $ maxS ) return true ; return false ; } $ a = array ( 2 , 3 , 4 ) ; $ n = count ( $ a ) ; if ( isPossible ( $ a , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cari kawasan rantau yang teduh yang dibentuk oleh persimpangan empat separuh bulatan dalam persegi | Berfungsi untuk mengembalikan kawasan rantau yang berlorek; Kawasan dataran; Kawasan separuh bulatan; Terdapat 4 separuh bulatan Shadedarea = kawasan 4 separuh bulatan - kawasan persegi; Kod pemacu", "code": "< ? php function findAreaShaded ( $ a ) { $ sqArea = $ a * $ a ; $ semiCircleArea = ( 3.14 * ( $ a * $ a ) / 8 ) ; $ ShadedArea = 4 * $ semiCircleArea - $ sqArea ; return $ ShadedArea ; } $ a = 10 ; echo findAreaShaded ( $ a ) ; ? >"}
{"text": "Bilangan langkah yang diperlukan untuk mencapai titik (x, y) dari (0, 0) menggunakan zig | Berfungsi untuk mengembalikan kedudukan yang diperlukan; Kod pemacu", "code": "< ? php function countSteps ( $ x , $ y ) { if ( $ x < $ y ) { return $ x + $ y + 2 * ( ( $ y - $ x ) / 2 ) ; } else { return $ x + $ y + 2 * ( ( ( $ x - $ y ) + 1 ) / 2 ) ; } } $ x = 4 ; $ y = 3 ; echo ( countSteps ( $ x , $ y ) ) ; ? >"}
{"text": "Cari sama ada hanya dua baris selari yang mengandungi semua titik koordinat atau tidak | Cari jika cerun baik dengan hanya dua pemintas; Jika set garis hanya mempunyai dua pemintas yang berbeza; Fungsi untuk memeriksa sama ada penyelesaian yang diperlukan wujud; Semak hasilnya dengan memproses cerun dengan memulakan tiga mata; Kod pemacu", "code": "< ? php function isSlopeGood ( $ slope , $ arr , $ n ) { $ setOfLines = array_fill ( 0 , max ( $ arr ) * $ n , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ setOfLines [ $ arr [ $ i ] - $ slope * $ i ] = 1 ; $ setOfLines = array_unique ( $ setOfLines ) ; return ( count ( $ setOfLines ) == 2 ) ; } function checkForParallel ( $ arr , $ n ) { $ slope1 = isSlopeGood ( $ arr [ 1 ] - $ arr [ 0 ] , $ arr , $ n ) ; $ slope2 = isSlopeGood ( $ arr [ 2 ] - $ arr [ 1 ] , $ arr , $ n ) ; $ slope3 = isSlopeGood ( ( int ) ( ( $ arr [ 2 ] - $ arr [ 0 ] ) / 2 ) , $ arr , $ n ) ; return ( $ slope1 $ slope2 $ slope3 ) ; } $ arr = array ( 1 , 6 , 3 , 8 , 5 ) ; $ n = count ( $ arr ) ; echo ( int ) checkForParallel ( $ arr , $ n ) . \" \" ; ? >"}
{"text": "Semak sama ada titik (x, y) terletak pada baris tertentu | Fungsi yang kembali benar jika titik yang diberikan terletak pada baris yang diberikan; Jika (x, y) memenuhi persamaan garis; Kod pemacu", "code": "< ? php function pointIsOnLine ( $ m , $ c , $ x , $ y ) { if ( $ y == ( ( $ m * $ x ) + $ c ) ) return true ; return false ; } $ m = 3 ; $ c = 2 ; $ x = 1 ; $ y = 5 ; if ( pointIsOnLine ( $ m , $ c , $ x , $ y ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Segitiga Reuleaux Terbesar yang ditulis dalam satu persegi yang tertulis dalam elips | Berfungsi untuk mencari segitiga Reuleaux terbesar; Panjang paksi tidak boleh negatif; ketinggian segitiga Reuleaux; kawasan segitiga Reuleaux; Kod pemacu", "code": "< ? php function Area ( $ a , $ b ) { if ( $ a < 0 && $ b < 0 ) return -1 ; $ h = sqrt ( ( ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) / ( pow ( $ a , 2 ) * pow ( $ b , 2 ) ) ) ) ; $ A = 0.70477 * pow ( $ h , 2 ) ; return $ A ; } $ a = 5 ; $ b = 4 ; echo round ( Area ( $ a , $ b ) , 7 ) ; ? >"}
{"text": "Maksimum yang diberikan segi empat tepat yang boleh dipotong dari sekeping kertas | Berfungsi untuk mengembalikan segi empat maksimum yang mungkin; Potong segi empat tepat secara mendatar jika boleh; Satu segi empat tepat adalah sel tunggal; Jumlah segi empat tepat = jumlah sel; Potong segi empat tepat jika boleh; Mengembalikan segi empat tepat maksimum; Kod pemacu", "code": "< ? php function maxRectangles ( $ L , $ B , $ l , $ b ) { $ horizontal = 0 ; $ vertical = 0 ; if ( $ l <= $ L && $ b <= $ B ) { $ columns = ( int ) ( $ B / $ b ) ; $ rows = ( int ) ( $ L / $ l ) ; $ horizontal = $ rows * $ columns ; } if ( $ l <= $ B && $ b <= $ L ) { $ columns = ( int ) ( $ L / $ b ) ; $ rows = ( int ) ( $ B / $ l ) ; $ vertical = $ rows * $ columns ; } return max ( $ horizontal , $ vertical ) ; } $ L = 10 ; $ B = 7 ; $ l = 4 ; $ b = 3 ; print ( maxRectangles ( $ L , $ B , $ l , $ b ) ) ; ? >"}
{"text": "Kon Pekeliling Kanan Terbesar yang boleh ditulis dalam sfera yang tertulis dalam kiub | Berfungsi untuk mencari kerucut pekeliling kanan terbesar; sisi tidak boleh negatif; jejari kerucut pekeliling kanan; ketinggian kerucut pekeliling kanan; kelantangan kerucut pekeliling kanan; Kod pemacu", "code": "< ? php function cone ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( $ a * sqrt ( 2 ) ) / 3 ; $ h = ( 2 * $ a ) / 3 ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; } $ a = 5 ; echo round ( cone ( $ a ) , 4 ) ; ? >"}
{"text": "Segitiga Reuleaux Terbesar yang tertulis dalam satu persegi yang tertulis dalam Hexagon | Berfungsi untuk mencari segitiga Reuleaux terbesar; sisi tidak boleh negatif; ketinggian segitiga Reuleaux; kawasan segitiga Reuleaux; Kod pemacu", "code": "< ? php function Area ( $ a ) { if ( $ a < 0 ) return -1 ; $ h = 1.268 * $ a ; $ A = 0.70477 * pow ( $ h , 2 ) ; return $ A ; } $ a = 5 ; echo round ( Area ( $ a ) , 4 ) ; ? >"}
{"text": "Segitiga Reuleaux terbesar di dalam persegi yang tertulis dalam separuh bulatan | Berfungsi untuk mencari segitiga Reuleaux terbesar; Radius tidak boleh negatif; ketinggian segitiga Reuleaux; kawasan segitiga Reuleaux; Kod pemacu", "code": "< ? php function Area ( $ r ) { if ( $ r < 0 ) return -1 ; $ x = ( 2 * $ r ) / sqrt ( 5 ) ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; } $ r = 5 ; echo Area ( $ r ) ; ? >"}
{"text": "Segitiga Reuleaux Terbesar yang ditulis dalam satu persegi yang tertulis dalam segitiga sama rata | Berfungsi untuk mencari segitiga Reuleaux terbesar; sisi tidak boleh negatif; ketinggian segitiga Reuleaux; kawasan segitiga Reuleaux; Kod pemacu", "code": "< ? php function Area ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.464 * $ a ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; } $ a = 5 ; echo Area ( $ a ) . \" STRNEWLINE \" ;"}
{"text": "Program untuk kawasan persegi selepas n | Fungsi untuk mengira kawasan persegi selepas diberi bilangan lipatan; Kod pemacu", "code": "< ? php function areaSquare ( $ side , $ fold ) { $ area = $ side * $ side ; return $ area * 1.0 / pow ( 2 , $ fold ) ; } $ side = 4 ; $ fold = 2 ; echo areaSquare ( $ side , $ fold ) ; ? >"}
{"text": "Segitiga Reuleaux Terbesar dalam Dataran yang Ditulis dalam Lingkaran | Berfungsi untuk mencari kawasan segitiga Reuleaux; Radius tidak boleh negatif; Kawasan segitiga Reuleaux; Kod pemacu", "code": "< ? php function ReuleauxArea ( $ r ) { if ( $ r < 0 ) return -1 ; $ A = 0.70477 * 2 * pow ( $ r , 2 ) ; return $ A ; } $ r = 6 ; echo ReuleauxArea ( $ r ) . \" STRNEWLINE \" ; ? >"}
{"text": "Silinder bulat kanan terbesar yang boleh ditulis dalam kerucut yang pada gilirannya tertulis dalam kiub | Berfungsi untuk mencari silinder bulat kanan terbesar; sisi tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "< ? php function cyl ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( 2 * $ a * sqrt ( 2 ) ) / 3 ; $ h = ( 2 * $ a ) / 3 ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; } $ a = 5 ; echo cyl ( $ a ) ; ? >"}
{"text": "Segitiga Reuleaux Terbesar dalam Dataran yang Ditulis dalam Segitiga Sudut Kanan | Berfungsi untuk mencari segitiga Reuleaux terbesar; Ketinggian atau asas atau hipotenus tidak boleh negatif; ketinggian segitiga Reuleaux; kawasan segitiga Reuleaux; Kod pemacu", "code": "< ? php function Area ( $ l , $ b , $ h ) { if ( $ l < 0 or $ b < 0 or $ h < 0 ) return -1 ; $ x = ( $ l * $ b ) / ( $ l + $ b ) ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; } $ l = 5 ; $ b = 12 ; $ h = 13 ; echo Area ( $ l , $ b , $ h ) ; ? >"}
{"text": "Dataran terbesar yang boleh ditulis dalam segi enam yang tertulis dalam segitiga sama rata | Berfungsi untuk mencari sisi dataran; Sisi tidak boleh negatif; sisi dataran; Kod pemacu", "code": "< ? php function squareSide ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.423 * $ a ; return $ x ; } $ a = 8 ; echo squareSide ( $ a ) ; ? >"}
{"text": "Semak sama ada mungkin untuk melukis garis lurus dengan Cosines Arah yang diberikan | Fungsi yang mengembalikan benar jika garis lurus mungkin; Kod pemacu", "code": "< ? php function isPossible ( $ x , $ y , $ z ) { $ a = round ( $ x * $ x + $ y * $ y + $ z * $ z ) ; if ( ceil ( $ a ) == 1 && floor ( $ a ) == 1 ) return true ; return false ; } $ l = 0.70710678 ; $ m = 0.5 ; $ n = 0.5 ; if ( isPossible ( $ l , $ m , $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ;"}
{"text": "Panjang pepenjuru n | Berfungsi untuk mencari pepenjuru poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah pepenjuru ditukar kepada radian; Kod pemacu", "code": "< ? php function polydiagonal ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; return 2 * $ a * sin ( ( ( ( $ n - 2 ) * 180 ) / ( 2 * $ n ) ) * 3.14159 / 180 ) ; } $ a = 9 ; $ n = 10 ; echo polydiagonal ( $ n , $ a ) ; ? >"}
{"text": "Diagonal Decagon biasa | Berfungsi untuk mengembalikan pepenjuru decagon biasa; Sisi tidak boleh negatif; Panjang pepenjuru; Kod pemacu", "code": "< ? php function decdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.902 * $ a ; return $ d ; } $ a = 9 ; echo decdiagonal ( $ a ) ; ? >"}
{"text": "Diagonal Heptagon biasa | Berfungsi untuk mengembalikan pepenjuru heptagon biasa; Sisi tidak boleh negatif; Panjang pepenjuru; Kod pemacu", "code": "< ? php function heptdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.802 * $ a ; return $ d ; } $ a = 6 ; echo heptdiagonal ( $ a ) ;"}
{"text": "Diagonal Hexagon biasa | Berfungsi untuk mencari pepenjuru heksagon biasa; Sisi tidak boleh negatif; Panjang pepenjuru; Kod pemacu", "code": "< ? php function hexDiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.73 * $ a ; return $ d ; } $ a = 9 ; echo hexDiagonal ( $ a ) , \" STRNEWLINE \" ; ? >"}
{"text": "Kawasan Segitiga Reuleaux | Berfungsi untuk mencari kawasan segitiga Reuleaux; Sisi tidak boleh negatif; Kawasan segitiga Reuleaux; Kod pemacu", "code": "< ? php function ReuleauxArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ A = 0.70477 * pow ( $ a , 2 ) ; return $ A ; } $ a = 6 ; echo ReuleauxArea ( $ a ) ;"}
{"text": "Dataran terbesar yang boleh ditulis dalam segi enam | Berfungsi untuk mencari kawasan dataran; Sisi tidak boleh negatif; Kawasan dataran; Kod pemacu", "code": "< ? php function squareArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = pow ( 1.268 , 2 ) * pow ( $ a , 2 ) ; return $ area ; } $ a = 6 ; echo squareArea ( $ a ) , \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah kiub menggunakan ruang diagonal | Berfungsi untuk mengira kelantangan; Formula untuk mencari kelantangan; ruang pepenjuru ruang", "code": "< ? php function CubeVolume ( $ d ) { $ Volume ; $ Volume = ( sqrt ( 3 ) * pow ( $ d , 3 ) ) / 9 ; return $ Volume ; } $ d = 5 ; echo \" Volume ▁ of ▁ Cube : ▁ \" , CubeVolume ( $ d ) ; ? >"}
{"text": "Perimeter dan kawasan paralelogram Varignon | Berfungsi untuk mencari perimeter; Berfungsi untuk mencari kawasan; Kod pemacu", "code": "< ? php function per ( $ a , $ b ) { return ( $ a + $ b ) ; } function area ( $ s ) { return ( $ s / 2 ) ; } $ a = 7 ; $ b = 8 ; $ s = 10 ; echo ( per ( $ a , $ b ) \" \" ) ; echo \" STRNEWLINE \" ; echo ( area ( $ s ) ) ; ? >"}
{"text": "Kawasan daun di dalam persegi | Program PHP untuk mencari kawasan daun di dalam persegi; Fungsi untuk mencari kawasan daun; Kod pemacu", "code": "< ? php $ PI = 3.14159265 ; function area_leaf ( $ a ) { global $ PI ; return ( $ a * $ a * ( $ PI / 2 - 1 ) ) ; } $ a = 7 ; echo ( area_leaf ( $ a ) ) ; ? >"}
{"text": "Panjang tali yang diikat sekitar tiga bulatan yang sama menyentuh satu sama lain | Program PHP untuk mencari panjang tali; Berfungsi untuk mencari panjang tali; Kod pemacu", "code": "< ? php $ PI = 3.14159265 ; function length_rope ( $ r ) { global $ PI ; return ( ( 2 * $ PI * $ r ) + 6 * $ r ) ; } $ r = 7 ; echo ( length_rope ( $ r ) ) ; ? >"}
{"text": "Kawasan Incircle dari Segitiga Bersudut Kanan | Program PHP untuk mencari kawasan lingkaran yang ditulis dari segi tiga bersudut kanan; Berfungsi untuk mencari kawasan bulatan tertulis; Kod pemacu", "code": "< ? php $ PI = 3.14159265 ; function area_inscribed ( $ P , $ B , $ H ) { global $ PI ; return ( ( $ P + $ B - $ H ) * ( $ P + $ B - $ H ) * ( $ PI / 4 ) ) ; } $ P = 3 ; $ B = 4 ; $ H = 5 ; echo ( area_inscribed ( $ P , $ B , $ H ) ) ; ? >"}
{"text": "Kawasan Circumcircle dari Segitiga Bersudut Kanan | Program PHP untuk mencari kawasan lingkaran cicumscribed segitiga bersudut kanan; Fungsi untuk mencari kawasan bulatan yang dilampirkan; Kod pemacu", "code": "< ? php $ PI = 3.14159265 ; function area_circumscribed ( $ c ) { global $ PI ; return ( $ c * $ c * ( $ PI / 4 ) ) ; } $ c = 8 ; echo ( area_circumscribed ( $ c ) ) ; ? >"}
{"text": "Silinder bulat kanan terbesar yang boleh ditulis dalam kon | Berfungsi untuk mencari silinder bulat kanan terbesar; Radius dan ketinggian tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "< ? php function cyl ( $ r , $ h ) { if ( $ r < 0 && $ h < 0 ) return -1 ; $ R = ( int ) ( 2 * $ r ) / 3 ; $ H = ( int ) ( 2 * $ h ) / 3 ; $ V = 3.14 * pow ( $ R , 2 ) * $ H ; return $ V ; } $ r = 4 ; $ h = 8 ; echo cyl ( $ r , $ h ) ; ? >"}
{"text": "Kubus terbesar yang boleh ditulis dalam silinder pekeliling yang betul | Berfungsi untuk mencari kelantangan kiub; Ketinggian dan jejari tidak boleh negatif; jumlah kiub; Kod pemacu", "code": "< ? php function cube ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ a = pow ( $ h , 3 ) ; return $ a ; } $ h = 5 ; $ r = 4 ; echo cube ( $ h , $ r ) ; ? >"}
{"text": "Jumlah sfera terbesar dalam silinder bulat yang betul | Berfungsi untuk mencari sfera terbesar; Radius dan ketinggian tidak boleh negatif; jejari sfera; Kod pemacu", "code": "< ? php function sph ( $ r , $ h ) { if ( $ r < 0 && $ h < 0 ) return -1 ; $ R = $ r ; return $ R ; } $ r = 4 ; $ h = 8 ; echo sph ( $ r , $ h ) ; ? >"}
{"text": "Jumlah silinder bulat kanan terbesar dalam sfera | Berfungsi untuk mencari silinder bulat kanan terbesar; Radius tidak boleh negatif; jumlah silinder; Kod pemacu", "code": "< ? php function cyl ( $ R ) { if ( $ R < 0 ) return -1 ; $ V = ( 2 * 3.14 * pow ( $ R , 3 ) ) / ( 3 * sqrt ( 3 ) ) ; return $ V ; } $ R = 4 ; echo cyl ( $ R ) ; ? >"}
{"text": "Batang terpanjang yang boleh dimasukkan ke dalam silinder bulat yang betul | Berfungsi untuk mencari sisi kiub; Ketinggian dan jejari tidak boleh negatif; panjang batang; Kod pemacu", "code": "< ? php function rod ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ l = sqrt ( pow ( $ h , 2 ) + 4 * pow ( $ r , 2 ) ) ; return $ l ; } $ h = 4 ; $ r = 1.5 ; echo rod ( $ h , $ r ) . \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mengira kawasan dan perimeter dari segitiga sama rata | Program PHP untuk mencari kawasan bulatan segitiga sama rata; berfungsi untuk mencari kawasan bulatan tertulis; berfungsi untuk mencari perimeter bulatan tertulis; Kod pemacu", "code": "< ? php $ PI = 3.14159265 ; function area_inscribed ( $ a ) { global $ PI ; return ( $ a * $ a * ( $ PI / 12 ) ) ; } function perm_inscribed ( $ a ) { global $ PI ; return ( $ PI * ( $ a / sqrt ( 3 ) ) ) ; } $ a = 6 ; echo ( \" Area ▁ of ▁ inscribed ▁ circle ▁ is ▁ : \" ) ; echo ( area_inscribed ( $ a ) ) ; echo ( \" Perimeter ▁ of ▁ inscribed ▁ circle ▁ is ▁ : \" ) ; echo ( perm_inscribed ( $ a ) ) ; ? >"}
{"text": "Kubus terbesar yang boleh ditulis dalam kerucut pekeliling yang betul | Berfungsi untuk mencari sisi kiub; Ketinggian dan jejari tidak boleh negatif; sisi kiub; Kod pemacu", "code": "< ? php function cubeSide ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ a = ( $ h * $ r * sqrt ( 2 ) ) / ( $ h + sqrt ( 2 ) * $ r ) ; return $ a ; } $ h = 5 ; $ r = 6 ; echo cubeSide ( $ h , $ r ) ; ? >"}
{"text": "Kon pekeliling kanan terbesar yang boleh ditulis dalam sfera | Berfungsi untuk mencari jejari kerucut; Radius tidak boleh negatif; jejari kerucut; Berfungsi untuk mencari ketinggian kerucut; sisi tidak boleh negatif; ketinggian kerucut; Kod pemacu", "code": "< ? php function coner ( $ R ) { if ( $ R < 0 ) return -1 ; $ r = ( 2 * sqrt ( 2 ) * $ R ) / 3 ; return $ r ; } function coneh ( $ R ) { if ( $ R < 0 ) return -1 ; $ h = ( 4 * $ R ) / 3 ; return $ h ; } $ R = 10 ; echo ( \" r ▁ = ▁ \" ) ; echo coner ( $ R ) ; echo ( \" , ▁ \" ) ; echo ( \" h ▁ = ▁ \" ) ; echo ( coneh ( $ R ) ) ; ? >"}
{"text": "Kerucut terbesar yang boleh ditulis dalam kiub | Berfungsi untuk mencari jejari kerucut; sisi tidak boleh negatif; jejari kerucut; Berfungsi untuk mencari ketinggian kerucut; sisi tidak boleh negatif; ketinggian kerucut; Kod pemacu", "code": "< ? php function coneRadius ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = $ a / sqrt ( 2 ) ; return $ r ; } function coneHeight ( $ a ) { if ( $ a < 0 ) return -1 ; $ h = $ a ; return $ h ; } $ a = 6 ; echo ( \" r ▁ = ▁ \" ) ; echo coneRadius ( $ a ) ; echo ( \" , ▁ \" ) ; echo ( \" h ▁ = ▁ \" ) ; echo ( coneHeight ( $ a ) ) ; ? >"}
{"text": "Kubus terbesar yang boleh ditulis dalam sfera | Berfungsi untuk mencari sisi kiub; Radius tidak boleh negatif; sisi kiub; Kod pemacu", "code": "< ? php function largestCube ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( float ) ( ( 2 * $ r ) / sqrt ( 3 ) ) ; return $ a ; } $ r = 5 ; echo largestCube ( $ r ) ; ? >"}
{"text": "Sfera terbesar yang boleh ditulis di dalam kiub | Berfungsi untuk mencari jejari sfera; sisi tidak boleh negatif; jejari sfera; Kod pemacu", "code": "< ? php function sphere ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( $ a / 2 ) ; return $ r ; } $ a = 5 ; echo sphere ( $ a ) ; ? >"}
{"text": "Potongan minimum boleh dibuat di papan catur supaya ia tidak dibahagikan kepada 2 bahagian | fungsi yang mengira maksimum no. pemotongan; Kod pemacu; Fungsi panggilan.", "code": "< ? php function numberOfCuts ( $ M , $ N ) { $ result = 0 ; $ result = ( $ M - 1 ) * ( $ N - 1 ) ; return $ result ; } $ M = 4 ; $ N = 4 ; $ Cuts = numberOfCuts ( $ M , $ N ) ; echo \" Maximum ▁ cuts ▁ = ▁ \" , $ Cuts ; ? >"}
{"text": "Cari jumlah maksimum cuboid dari perimeter dan kawasan yang diberikan | berfungsi untuk mengembalikan jumlah maksimum; mengira panjang; hitung kelantangan; hasil pulangan; Kod pemacu; Panggilan fungsi", "code": "< ? php function maxVol ( $ P , $ A ) { $ l = ( $ P - sqrt ( $ P * $ P - 24 * $ A ) ) / 12 ; $ V = $ l * ( $ A / 2.0 - $ l * ( $ P / 4.0 - $ l ) ) ; return $ V ; } $ P = 20 ; $ A = 16 ; echo maxVol ( $ P , $ A ) ; ? >"}
{"text": "Program untuk mengira kawasan dan perimeter rombus yang diagonalnya diberikan | hitung kawasan dan perimeter rombus; Kod pemacu", "code": "< ? php function rhombusAreaPeri ( $ d1 , $ d2 ) { $ area = ( $ d1 * $ d2 ) / 2 ; $ perimeter = 2 * sqrt ( pow ( $ d1 , 2 ) + pow ( $ d2 , 2 ) ) ; echo \" The ▁ area ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ \" . $ d1 . \" ▁ and ▁ \" . $ d2 . \" ▁ is ▁ \" . $ area . \" . \" . \" STRNEWLINE \" ; echo \" The ▁ perimeter ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ \" . $ d1 . \" ▁ and ▁ \" . $ d2 . \" ▁ is ▁ \" . $ perimeter . \" . \" . \" STRNEWLINE \" ; } $ d1 = 2 ; $ d2 = 4 ; rhombusAreaPeri ( $ d1 , $ d2 ) ; ? >"}
{"text": "Kawasan Decagon yang ditulis dalam Lingkaran | Berfungsi untuk mencari kawasan Decagon; Radius tidak boleh negatif; kawasan decagon; Kod pemacu", "code": "< ? php function area ( $ r ) { if ( $ r < 0 ) return -1 ; $ area = ( 5 * pow ( $ r , 2 ) * ( 3 - sqrt ( 5 ) ) * ( sqrt ( 5 ) + ( 2 * sqrt ( 5 ) ) ) ) / 4 ; return $ area ; } $ r = 8 ; echo area ( $ r ) . \" STRNEWLINE \" ; ? >"}
{"text": "Kawasan maksimum segi empat tepat mungkin dengan perimeter yang diberikan | Berfungsi untuk mencari kawasan maks; Kawasan pulangan; Kod pemacu", "code": "< ? php function maxArea ( $ perimeter ) { $ length = ( int ) ceil ( $ perimeter / 4 ) ; $ breadth = ( int ) floor ( $ perimeter / 4 ) ; return ( $ length * $ breadth ) ; } $ n = 38 ; echo \" Maximum ▁ Area ▁ = ▁ \" , maxArea ( $ n ) ; ? >"}
{"text": "Cari kaki tegak lurus titik dalam pesawat 3 d | Berfungsi untuk mencari kaki tegak lurus; Kod pemacu; panggilan fungsi", "code": "< ? php function foot ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) { $ k = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 - $ d ) / ( $ a * $ a + $ b * $ b + $ c * $ c ) ; $ x2 = $ a * $ k + $ x1 ; $ y2 = $ b * $ k + $ y1 ; $ z2 = $ c * $ k + $ z1 ; echo \" x2 = \" ▁ . ▁ round ( $ x2 , ▁ 1 ) ; STRNEWLINE TABSYMBOL echo ▁ \" y2 = \" ▁ . ▁ round ( $ y2 , ▁ 1 ) ; STRNEWLINE TABSYMBOL echo ▁ \" z2 = \" } $ a = 1 ; $ b = -2 ; $ c = 0 ; $ d = 0 ; $ x1 = -1 ; $ y1 = 3 ; $ z1 = 4 ; foot ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) ; ? >"}
{"text": "Squares minimum untuk merata Rectangle | Program PHP untuk mencari bilangan minimum kotak untuk membuat segi empat tepat yang diberikan. ; Jika kita mengambil GCD (L, W), ini akan menjadi sisi terbesar untuk persegi, maka bilangan minimum persegi. ; Bilangan kotak. ; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { return $ b ? gcd ( $ b , $ a % $ b ) : $ a ; } function countRectangles ( $ l , $ w ) { $ squareSide = gcd ( $ l , $ w ) ; return ( $ l * $ w ) / ( $ squareSide * $ squareSide ) ; } $ l = 4 ; $ w = 6 ; echo countRectangles ( $ l , $ w ) . \" STRNEWLINE \" ; ? >"}
{"text": "Persamaan bulatan dari pusat dan jejari | Berfungsi untuk mencari persamaan bulatan; Hasil percetakan; Kod pemacu", "code": "< ? php function circle_equation ( $ x1 , $ y1 , $ r ) { $ a = -2 * $ x1 ; $ b = -2 * $ y1 ; $ c = ( $ r * $ r ) - ( $ x1 * $ x1 ) - ( $ y1 * $ y1 ) ; echo \" x ^ 2 + ( \" ▁ . ▁ $ a ▁ . ▁ \" x ) + \" echo \" y ^ 2 ▁ + ▁ ( \" . $ b . \" ▁ y ) ▁ = ▁ \" ; echo $ c . \" . \" . \" STRNEWLINE \" ; } $ x1 = 2 ; $ y1 = -3 ; $ r = 8 ; circle_equation ( $ x1 , $ y1 , $ r ) ; ? >"}
{"text": "Program untuk mencari kawasan dan perimeter separuh bulatan | Fungsi untuk mengira kawasan tersebut; Formula untuk mencari kawasan; Fungsi untuk mengira perimeter; Formula untuk mencari perimeter; Dapatkan jejari; Cari kawasan itu; Cari perimeter", "code": "< ? php function area ( $ r ) { return ( 0.5 ) * ( 3.14 ) * ( $ r * $ r ) ; } function perimeter ( $ r ) { return ( 3.14 ) * ( $ r ) ; } $ r = 10 ; echo \" The ▁ Area ▁ of ▁ Semicircle : ▁ \" , area ( $ r ) , \" STRNEWLINE \" ; echo \" The ▁ Perimeter ▁ of ▁ Semicircle : ▁ \" , perimeter ( $ r ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika vektor yang diberikan berada pada keseimbangan atau tidak | Berfungsi untuk memeriksa keseimbangan tiga vektor; menjumlahkan koordinat X; menjumlahkan koordinat Y; menjumlahkan koordinat Z; Memeriksa keadaan untuk keseimbangan; Kod pemacu; Memeriksa keseimbangan", "code": "< ? php function checkEquilibrium ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) { $ resx = $ x1 + $ x2 + $ x3 ; $ resy = $ y1 + $ y2 + $ y3 ; $ resz = $ z1 + $ z2 + $ z3 ; if ( $ resx == 0 and $ resy == 0 and $ resz == 0 ) return true ; else return false ; } $ x1 = -2 ; $ y1 = -7 ; $ z1 = -9 ; $ x2 = 5 ; $ y2 = -14 ; $ z2 = 14 ; $ x3 = -3 ; $ y3 = 21 ; $ z3 = -5 ; if ( checkEquilibrium ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) ) echo \" The ▁ vectors ▁ are ▁ at ▁ equilibrium . \" ; else echo \" The ▁ vectors ▁ are ▁ not ▁ at ▁ equilibrium . \" ; ? >"}
{"text": "Cari tangen pada titik tertentu pada lengkung | fungsi untuk mencari tangen; membezakan persamaan yang diberikan; Semak titik pada lengkung atau tidak; Jika membezakan adalah negatif; Membezakan adalah positif; Membezakan adalah sifar; mengisytiharkan pembolehubah; Fungsi Call FindTangent", "code": "< ? php function findTangent ( $ A , $ x , $ y ) { $ dif = $ A - $ x * 2 ; if ( $ y == ( 2 * $ x - $ x * $ x ) ) { if ( $ dif < 0 ) echo \" y = \" , ▁ $ dif ▁ , ▁ \" x \" ( $ x * $ dif ) + ( $ y ) ; else if ( $ dif > 0 ) echo \" y ▁ = ▁ \" , $ dif , \" x + \" , - $ x * $ dif + $ y ; else echo \" Not ▁ possible \" ; } } $ A = 2 ; $ x = 2 ; $ y = 0 ; findTangent ( $ A , $ x , $ y ) ; ? >"}
{"text": "Cari Panjang Pepenjuru Hexagon | Berfungsi untuk mencari pepenjuru segi enam; sisi tidak boleh negatif; pepenjuru heksagon; Kod pemacu", "code": "< ? php function hexadiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; return 2 * $ a ; } $ a = 4 ; echo hexadiagonal ( $ a ) ; ? >"}
{"text": "Program untuk mencari sisi oktagon yang tertulis di dalam dataran | Berfungsi untuk mencari sisi oktagon; sisi tidak boleh negatif; sisi oktagon; Dapatkan dia persegi; Cari panjang sisi dataran", "code": "< ? php function octaside ( $ a ) { if ( $ a < 0 ) return -1 ; $ s = $ a / ( sqrt ( 2 ) + 1 ) ; return $ s ; } $ a = 4 ; echo octaside ( $ a ) ; ? >"}
{"text": "Semak sama ada mungkin untuk bergerak dari (0, 0) ke (x, y) dalam langkah n | Berfungsi untuk memeriksa sama ada mungkin atau tidak untuk bergerak dari (0, 0) ke (x, y) dalam langkah -langkah yang tepat; Kod pemacu", "code": "< ? php function Arrive ( $ a , $ b , $ n ) { if ( $ n >= abs ( $ a ) + abs ( $ b ) and ( $ n - ( abs ( $ a ) + abs ( $ b ) ) ) % 2 == 0 ) return true ; return false ; } $ a = 5 ; $ b = 5 ; $ n = 11 ; if ( Arrive ( $ a , $ b , $ n ) ) echo \" Yes \" ; else echo \" No \" ;"}
{"text": "Semak sama ada mungkin untuk bergerak dari (a, 0) ke (b, 0) dengan lompatan yang diberikan | Fungsi untuk memeriksa sama ada mungkin; Kod pemacu; panggilan fungsi", "code": "< ? php function Move ( $ a , $ x , $ b ) { if ( ( ( ( $ b - $ a ) % $ x == 0 ) || ( ( $ b - $ a - 1 ) % $ x == 0 ) && $ a + 1 != $ b ) && $ b >= $ a ) return true ; return false ; } $ a = 3 ; $ x = 2 ; $ b = 7 ; if ( Move ( $ a , $ x , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Kawasan segitiga yang tertulis dalam segi empat tepat yang tertulis dalam elips | Berfungsi untuk mencari kawasan segitiga; Panjang A dan B tidak boleh negatif; kawasan segitiga; Kod pemacu", "code": "< ? php function area ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ A = $ a * $ b ; return $ A ; } $ a = 5 ; $ b = 2 ; echo area ( $ a , $ b ) ; ? >"}
{"text": "Circumradius dari segi empat tepat | Berfungsi untuk mencari jejari lingkaran; Sisi tidak boleh negatif; Jejari circumcircle; Mengembalikan jejari; Dapatkan sisi segitiga; Cari jejari lingkaran", "code": "< ? php function findRadiusOfcircumcircle ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ radius = sqrt ( pow ( $ l , 2 ) + pow ( $ b , 2 ) ) / 2 ; return $ radius ; } $ l = 4 ; $ b = 3 ; echo findRadiusOfcircumcircle ( $ l , $ b ) ; ? >"}
{"text": "Kawasan lingkaran mana -mana segitiga dengan sisi yang diberikan | Fungsi untuk mencari kawasan circumcircle; Sisi tidak boleh negatif; Semi - perimeter bulatan; kawasan segitiga; kawasan bulatan; Dapatkan sisi segitiga; Cari dan cetak kawasan Circumcircle", "code": "< ? php function circlearea ( $ a , $ b , $ c ) { if ( $ a < 0 $ b < 0 $ c < 0 ) return -1 ; $ p = ( $ a + $ b + $ c ) / 2 ; $ At = sqrt ( $ p * ( $ p - $ a ) * ( $ p - $ b ) * ( $ p - $ c ) ) ; $ A = 3.14 * pow ( ( ( $ a * $ b * $ c ) / ( 4 * $ At ) ) , 2 ) ; return $ A ; } $ a = 4 ; $ b = 5 ; $ c = 3 ; echo circlearea ( $ a , $ b , $ c ) ; ? >"}
{"text": "Cari ketinggian dan kawasan segitiga isosceles | berfungsi untuk mencari ketinggian; kembali ketinggian; berfungsi untuk mencari kawasan; Kawasan pulangan; Kod pemacu", "code": "< ? php function altitude ( $ a , $ b ) { return sqrt ( pow ( $ a , 2 ) - ( pow ( $ b , 2 ) / 4 ) ) ; } function area ( $ b , $ h ) { return ( 1 * $ b * $ h ) / 2 ; } $ a = 2 ; $ b = 3 ; $ h = altitude ( $ a , $ b ) ; echo \" Altitude = \" ▁ , ▁ $ h ▁ , ▁ \" , \" echo \" Area ▁ = ▁ \" , area ( $ b , $ h ) ; ? >"}
{"text": "Program untuk mencari kawasan permukaan piramid persegi | berfungsi untuk mencari kawasan permukaan; Kod pemacu; kawasan permukaan piramid persegi", "code": "< ? php function surfaceArea ( $ b , $ s ) { return 2 * $ b * $ s + pow ( $ b , 2 ) ; } $ b = 3 ; $ s = 4 ; echo surfaceArea ( $ b , $ s ) ; ? >"}
{"text": "Kawasan segitiga terbesar yang boleh ditulis dalam segi empat tepat | Berfungsi untuk mencari kawasan segitiga; A dan B tidak boleh negatif; kawasan segitiga; Kod pemacu", "code": "< ? php function trianglearea ( $ l , $ b ) { if ( $ l < 0 or $ b < 0 ) return -1 ; $ area = ( $ l * $ b ) / 2 ; return $ area ; } $ l = 5 ; $ b = 4 ; echo trianglearea ( $ l , $ b ) ; ? >"}
{"text": "Semak jika mana -mana persegi (dengan satu sel berwarna) boleh dibahagikan kepada dua bahagian yang sama | berfungsi untuk memeriksa sama ada ia mungkin untuk membahagikan dataran dalam dua bahagian yang sama; Sekiranya persegi dicat dikaitkan dengan pusat persegi maka ia tidak mungkin; lain ya mungkin; memulakan saiz dataran; memulakan dimensi dataran dicat", "code": "< ? php function halfsquare ( $ n , $ x , $ y ) { $ half = $ n / 2 ; if ( ( $ half == $ x $ half == $ x - 1 ) && ( $ half == $ y $ half == $ y - 1 ) ) echo \" NO \" ; else echo \" YES \" ; } $ n = 100 ; $ x = 51 ; $ y = 100 ; halfsquare ( $ n , $ x , $ y ) ; ? >"}
{"text": "Semak sama ada mungkin untuk mencapai vektor B dengan berputar vektor A dan menambah vektor c ke sana | fungsi untuk memeriksa sama ada vektor B mungkin dari vektor A; Jika d = 0, maka anda perlu menambah apa -apa kepada vektor a; Bagi semua empat kuadran; Inisialisasi ketiga -tiga koordinat vektor", "code": "< ? php function check ( $ a , $ b , $ p , $ q ) { $ d = $ p * $ p + $ q * $ q ; if ( $ d == 0 ) return ( $ a == 0 && $ b == 0 ) ; else return ( ( $ a * $ p + $ b * $ q ) % $ d == 0 && ( $ b * $ p - $ a * $ q ) % $ d == 0 ) ; } function check1 ( $ a , $ b , $ x , $ y , $ p , $ q ) { if ( check ( $ a - $ x , $ b - $ y , $ p , $ q ) || check ( $ a + $ x , $ b + $ y , $ p , $ q ) || check ( $ a - $ y , $ b + $ x , $ p , $ q ) || check ( $ a + $ y , $ b - $ x , $ p , $ q ) ) return true ; else return false ; } $ a = -4 ; $ b = -2 ; $ x = 0 ; $ y = 0 ; $ p = -2 ; $ q = -1 ; if ( check1 ( $ a , $ b , $ x , $ y , $ p , $ q ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Segitiga terbesar yang boleh ditulis dalam elips | Berfungsi untuk mencari kawasan segitiga; A dan B tidak boleh negatif; kawasan segitiga; Kod pemacu", "code": "< ? php function trianglearea ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ area = ( 3 * sqrt ( 3 ) * pow ( $ a , 2 ) ) / ( 4 * $ b ) ; return $ area ; } $ a = 4 ; $ b = 2 ; echo trianglearea ( $ a , $ b ) ; ? >"}
{"text": "Kawasan dataran terbesar yang boleh ditulis dalam elips | Berfungsi untuk mencari kawasan dataran; A dan B tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "< ? php function squarearea ( $ a , $ b ) { if ( $ a < 0 or $ b < 0 ) return -1 ; $ area = 4 * ( ( ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) / ( pow ( $ a , 2 ) * pow ( $ b , 2 ) ) ) ) ; return $ area ; } $ a = 4 ; $ b = 2 ; print ( squarearea ( $ a , $ b ) ) ; ? >"}
{"text": "Segitiga terbesar yang boleh ditulis dalam separuh bulatan | Berfungsi untuk mencari kawasan segitiga; Radius tidak boleh negatif; kawasan segitiga; Kod pemacu", "code": "< ? php function trianglearea ( $ r ) { if ( $ r < 0 ) return -1 ; return $ r * $ r ; } $ r = 5 ; echo trianglearea ( $ r ) ; ? >"}
{"text": "Dataran terbesar yang boleh ditulis dalam separuh bulatan | Berfungsi untuk mencari kawasan dataran; Radius tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "< ? php function squarearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = 4 * ( pow ( $ r , 2 ) / 5 ) ; return $ a ; } $ r = 5 ; echo squarearea ( $ r ) ; ? >"}
{"text": "Kawasan segi empat tepat terbesar yang boleh ditulis dalam elips | Berfungsi untuk mencari kawasan segi empat tepat; A dan B tidak boleh negatif; kawasan segi empat tepat; Kod pemacu", "code": "< ? php function rectanglearea ( $ a , $ b ) { if ( $ a < 0 or $ b < 0 ) return -1 ; return 2 * $ a * $ b ; } $ a = 10 ; $ b = 8 ; echo rectanglearea ( $ a , $ b ) ; ? >"}
{"text": "Kawasan persegi terbesar di segi tiga sudut kanan | Berfungsi untuk mencari kawasan dataran terbesar; Ketinggian atau asas atau hipotenus tidak boleh negatif; sisi dataran; Squaring untuk mendapatkan kawasan itu; Kod pemacu", "code": "< ? php function squareArea ( $ l , $ b , $ h ) { if ( $ l < 0 $ b < 0 $ h < 0 ) return -1 ; $ a = ( $ l * $ b ) / ( $ l + $ b ) ; return $ a * $ a ; } $ l = 5 ; $ b = 12 ; $ h = 13 ; echo round ( squareArea ( $ l , $ b , $ h ) , 4 ) ; ? >"}
{"text": "Pertanyaan untuk memeriksa sama ada mungkin untuk menyertai kotak dalam bulatan | Pelaksanaan PHP pendekatan di atas; Cetak jawapan untuk setiap pertanyaan; menetapkan bendera untuk pengecualian; menggantikan elemen yang lebih besar dalam I dan J; Memeriksa jika kotak itu tidak digunakan dalam pertanyaan sebelumnya. ; Memeriksa jika menyambung ke kotak yang sama; Kes 1: x <i dan y terletak di antara i dan j; Kes 2: X terletak di antara i dan j dan y> j; Jika bendera tidak diset semula. ; Kod pemacu", "code": "< ? php $ MAX = 50 ; function solveQuery ( $ n , $ q , & $ qi , & $ qj ) { global $ MAX ; $ arr = array_fill ( 0 , $ MAX , NULL ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ arr [ $ i ] = 0 ; for ( $ k = 0 ; $ k < $ q ; $ k ++ ) { $ flag = 0 ; if ( $ qj [ $ k ] < $ qi [ $ k ] ) { $ temp = $ qi [ $ k ] ; $ qi [ $ k ] = $ qj [ $ k ] ; $ qj [ $ k ] = $ temp ; } if ( $ arr [ $ qi [ $ k ] ] != 0 $ arr [ $ qj [ $ k ] ] != 0 ) $ flag = 1 ; else if ( $ qi [ $ k ] == $ qj [ $ k ] ) $ flag = 1 ; else { for ( $ i = 1 ; $ i < $ qi [ $ k ] ; $ i ++ ) { if ( $ arr [ $ i ] != 0 && $ arr [ $ i ] < $ qj [ $ k ] && $ qi [ $ k ] < $ arr [ $ i ] ) { $ flag = 1 ; break ; } } if ( $ flag == 0 ) { for ( $ i = $ qi [ $ k ] + 1 ; $ i < $ qj [ $ k ] ; $ i ++ ) { if ( $ arr [ $ i ] != 0 && $ arr [ $ i ] > $ qj [ $ k ] ) { $ flag = 1 ; break ; } } } } if ( $ flag == 0 ) { echo \" YES STRNEWLINE \" ; $ arr [ $ qi [ $ k ] ] = $ qj [ $ k ] ; $ arr [ $ qj [ $ k ] ] = $ qi [ $ k ] ; } else echo \" NO STRNEWLINE \" ; } } $ n = 10 ; $ q = 7 ; $ qi = array ( 1 , 2 , 2 , 2 , 9 , 10 , 8 ) ; $ qj = array ( 5 , 7 , 3 , 4 , 9 , 9 , 6 ) ; solveQuery ( $ n , $ q , $ qi , $ qj ) ; ? >"}
{"text": "Squares minimum untuk menampung segi empat tepat | Program PHP untuk mencari bilangan minimum kotak untuk menutup permukaan segi empat tepat dengan dimensi yang diberikan; berfungsi untuk mengira bilangan dataran yang boleh menutup permukaan segi empat tepat; Kod pemacu", "code": "< ? php function squares ( $ l , $ b , $ a ) { return ceil ( $ l / ( double ) $ a ) * ceil ( $ b / ( double ) $ a ) ; } $ l = 11 ; $ b = 23 ; $ a = 14 ; echo squares ( $ l , $ b , $ a ) ; ? >"}
{"text": "Dataran terkecil dibentuk dengan segi empat tepat yang diberikan | Fungsi rekursif untuk mengembalikan GCD A dan B; Semuanya membahagikan 0; Kes asas; A lebih besar; Berfungsi untuk mencari kawasan dataran terkecil; Panjang atau lebar atau sisi tidak boleh negatif; Lcm panjang dan lebar; Squaring untuk mendapatkan kawasan itu; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 $ b == 0 ) return 0 ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; } function squarearea ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ n = ( $ l * $ b ) / gcd ( $ l , $ b ) ; return $ n * $ n ; } $ l = 6 ; $ b = 4 ; echo squarearea ( $ l , $ b ) . \" STRNEWLINE \" ; ? >"}
{"text": "Cari semua sudut segitiga dalam 3D | fungsi untuk mencari sudut; Kod pemacu", "code": "< ? php function angle_triangle ( $ x1 , $ x2 , $ x3 , $ y1 , $ y2 , $ y3 , $ z1 , $ z2 , $ z3 ) { $ num = ( $ x2 - $ x1 ) * ( $ x3 - $ x1 ) + ( $ y2 - $ y1 ) * ( $ y3 - $ y1 ) + ( $ z2 - $ z1 ) * ( $ z3 - $ z1 ) ; $ den = sqrt ( pow ( ( $ x2 - $ x1 ) , 2 ) + pow ( ( $ y2 - $ y1 ) , 2 ) + pow ( ( $ z2 - $ z1 ) , 2 ) ) * sqrt ( pow ( ( $ x3 - $ x1 ) , 2 ) + pow ( ( $ y3 - $ y1 ) , 2 ) + pow ( ( $ z3 - $ z1 ) , 2 ) ) ; $ angle = acos ( $ num / $ den ) * ( 180.0 / 3.141592653589793238463 ) ; return $ angle ; } $ x1 = -1 ; $ y1 = 3 ; $ z1 = 2 ; $ x2 = 2 ; $ y2 = 3 ; $ z2 = 5 ; $ x3 = 3 ; $ y3 = 5 ; $ z3 = -2 ; $ angle_A = angle_triangle ( $ x1 , $ x2 , $ x3 , $ y1 , $ y2 , $ y3 , $ z1 , $ z2 , $ z3 ) ; $ angle_B = angle_triangle ( $ x2 , $ x3 , $ x1 , $ y2 , $ y3 , $ y1 , $ z2 , $ z3 , $ z1 ) ; $ angle_C = angle_triangle ( $ x3 , $ x2 , $ x1 , $ y3 , $ y2 , $ y1 , $ z3 , $ z2 , $ z1 ) ; echo \" Angles ▁ are ▁ : STRNEWLINE \" ; echo \" angle A = \" ▁ . ▁ round ( $ angle _ A , ▁ 3 ) ▁ . ▁ \" degree \" ; STRNEWLINE echo ▁ \" angle B = \" ▁ . ▁ round ( $ angle _ B , ▁ 3 ) ▁ . ▁ \" degree \" ; STRNEWLINE echo ▁ \" angle C = \" ▁ . ▁ round ( $ angle _ C , ▁ 3 ) ▁ . ▁ \" degree \" ? >"}
{"text": "Bilangan minimum jubin persegi yang diperlukan untuk mengisi lantai segi empat tepat | Berfungsi untuk mencari bilangan jubin; jika keluasan boleh dibahagikan dengan sisi persegi; jubin yang diperlukan adalah n / s; Satu lagi jubin diperlukan; jika panjang dibahagikan dengan sisi persegi; jubin yang diperlukan adalah m / s; Satu lagi jubin diperlukan; Panjang input dan keluasan segi empat tepat dan sisi persegi", "code": "< ? php function solve ( $ M , $ N , $ s ) { if ( $ N % $ s == 0 ) { $ N = $ N / $ s ; } else { $ N = ( $ N / $ s ) + 1 ; } if ( $ M % $ s == 0 ) { $ M = $ M / $ s ; } else { $ M = ( $ M / $ s ) + 1 ; } return ( int ) $ M * $ N ; } $ N = 12 ; $ M = 13 ; $ s = 4 ; echo solve ( $ M , $ N , $ s ) ; ? >"}
{"text": "Bilangan minimum jubin persegi yang diperlukan untuk mengisi lantai segi empat tepat | Berfungsi untuk mencari bilangan jubin; tiada jubin; Panjang input dan keluasan segi empat tepat dan sisi persegi", "code": "< ? php function solve ( $ M , $ N , $ s ) { $ ans = ( ( int ) ( ceil ( $ M / $ s ) ) * ( int ) ( ceil ( $ N / $ s ) ) ) ; return $ ans ; } $ N = 12 ; $ M = 13 ; $ s = 4 ; echo solve ( $ M , $ N , $ s ) ; ? >"}
{"text": "Program untuk mencari persamaan pesawat yang melalui 3 mata | Fungsi untuk mencari persamaan satah. ; Kod pemacu", "code": "< ? php function equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) { $ a1 = $ x2 - $ x1 ; $ b1 = $ y2 - $ y1 ; $ c1 = $ z2 - $ z1 ; $ a2 = $ x3 - $ x1 ; $ b2 = $ y3 - $ y1 ; $ c2 = $ z3 - $ z1 ; $ a = $ b1 * $ c2 - $ b2 * $ c1 ; $ b = $ a2 * $ c1 - $ a1 * $ c2 ; $ c = $ a1 * $ b2 - $ b1 * $ a2 ; $ d = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 ) ; echo sprintf ( \" equation ▁ of ▁ the ▁ plane ▁ is ▁ % .2fx \" . \" ▁ + ▁ % .2fy ▁ + ▁ % .2fz ▁ + ▁ % .2f ▁ = ▁ 0\" , $ a , $ b , $ c , $ d ) ; } $ x1 = -1 ; $ y1 = 2 ; $ z1 = 1 ; $ x2 = 0 ; $ y2 = -3 ; $ z2 = 2 ; $ x3 = 1 ; $ y3 = 1 ; $ z3 = -4 ; equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) ; ? >"}
{"text": "Jarak tegak antara satu titik dan garis dalam 2 D | Berfungsi untuk mencari jarak; Kod pemacu", "code": "< ? php function shortest_distance ( $ x1 , $ y1 , $ a , $ b , $ c ) { $ d = abs ( ( $ a * $ x1 + $ b * $ y1 + $ c ) ) / ( sqrt ( $ a * $ a + $ b * $ b ) ) ; echo \" Perpendicular ▁ distance ▁ is ▁ \" , $ d ; } $ x1 = 5 ; $ y1 = 6 ; $ a = -2 ; $ b = 3 ; $ c = 4 ; shortest_distance ( $ x1 , $ y1 , $ a , $ b , $ c ) ; ? >"}
{"text": "Program untuk menentukan oktan satah paksi | Berfungsi untuk mencetak oktan; Kod pemacu", "code": "< ? php function octant ( $ x , $ y , $ z ) { if ( $ x >= 0 && $ y >= 0 && $ z >= 0 ) echo \" Point ▁ lies ▁ in ▁ 1st ▁ octant STRNEWLINE \" ; else if ( $ x < 0 && $ y >= 0 && $ z >= 0 ) echo \" Point ▁ lies ▁ in ▁ 2nd ▁ octant STRNEWLINE \" ; else if ( $ x < 0 && $ y < 0 && $ z >= 0 ) echo \" Point ▁ lies ▁ in ▁ 3rd ▁ octant STRNEWLINE \" ; else if ( $ x >= 0 && $ y < 0 && $ z >= 0 ) echo \" Point ▁ lies ▁ in ▁ 4th ▁ octant STRNEWLINE \" ; else if ( $ x >= 0 && $ y >= 0 && $ z < 0 ) echo \" Point ▁ lies ▁ in ▁ 5th ▁ octant STRNEWLINE \" ; else if ( $ x < 0 && $ y >= 0 && $ z < 0 ) echo \" Point ▁ lies ▁ in ▁ 6th ▁ octant STRNEWLINE \" ; else if ( $ x < 0 && $ y < 0 && $ z < 0 ) echo \" Point ▁ lies ▁ in ▁ 7th ▁ octant STRNEWLINE \" ; else if ( $ x >= 0 && $ y < 0 && $ z < 0 ) echo \" Point ▁ lies ▁ in ▁ 8th ▁ octant STRNEWLINE \" ; } $ x = 2 ; $ y = 3 ; $ z = 4 ; octant ( $ x , $ y , $ z ) ; $ x = -4 ; $ y = 2 ; $ z = -8 ; octant ( $ x , $ y , $ z ) ; $ x = -6 ; $ y = -2 ; $ z = 8 ; octant ( $ x , $ y , $ z ) ; ? >"}
{"text": "Bilangan segitiga dalam satah jika tidak lebih daripada dua mata adalah collinear | Fungsi untuk mencari bilangan segitiga dalam satah. ; Formula untuk mencari bilangan segitiga nc3 = n * (n - 1) * (n - 2) / 6; Kod pemacu", "code": "< ? php function countNumberOfTriangles ( $ n ) { return $ n * ( $ n - 1 ) * ( $ n - 2 ) / 6 ; } $ n = 4 ; echo countNumberOfTriangles ( $ n ) ; ? >"}
{"text": "Nombor TrideCagonal yang berpusat | Berfungsi untuk mencari nombor tridecagonal yang berpusat di nth; Formula untuk mengira nombor tridecagonal yang berpusat di nth; Kod pemacu", "code": "< ? php function centeredTridecagonalNum ( $ n ) { return ( 13 * $ n * ( $ n - 1 ) + 2 ) / 2 ; } $ n = 3 ; echo centeredTridecagonalNum ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 10 ; echo centeredTridecagonalNum ( $ n ) ; ? >"}
{"text": "Nombor Pyramidal Pentagonal | Fungsi untuk mendapatkan nombor piramidal pentagonal nth. ; Running Loop dari 1 hingga N; Dapatkan nombor pentagonal nth; tambah kepada jumlah; Kod pemacu", "code": "< ? php function pentagon_pyramidal ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ p = ( 3 * $ i * $ i - $ i ) / 2 ; $ sum = $ sum + $ p ; } return $ sum ; } $ n = 4 ; echo pentagon_pyramidal ( $ n ) ; ? >"}
{"text": "Nombor Pyramidal Pentagonal | Fungsi untuk mendapatkan nombor piramidal pentagonal nth. ; Kod pemacu", "code": "< ? php function pentagon_pyramidal ( $ n ) { return $ n * $ n * ( $ n + 1 ) / 2 ; } $ n = 4 ; echo pentagon_pyramidal ( $ n ) ; ? >"}
{"text": "Semak jika tiga garis lurus bersekutu atau tidak | Kembali benar jika tiga baris bersekutu, lain -lain palsu. ; Kod pemacu", "code": "< ? php function checkConcurrent ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 , $ a3 , $ b3 , $ c3 ) { return ( $ a3 * ( $ b1 * $ c2 - $ b2 * $ c1 ) + $ b3 * ( $ c1 * $ a2 - $ c2 * $ a1 ) + $ c3 * ( $ a1 * $ b2 - $ a2 * $ b1 ) == 0 ) ; } $ a1 = 2 ; $ b1 = -3 ; $ c1 = 5 ; $ a2 = 3 ; $ b2 = 4 ; $ c2 = -7 ; $ a3 = 9 ; $ b3 = -5 ; $ c3 = 8 ; if ( checkConcurrent ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 , $ a3 , $ b3 , $ c3 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Nombor Octadecagonal yang berpusat | fungsi octadecagon yang berpusat; Formula untuk mengira nombor oktadecagonal yang berpusat di NTH; Kod pemacu", "code": "< ? php function center_octadecagon_num ( $ n ) { return ( 9 * $ n * $ n - 9 * $ n + 1 ) ; } $ n = 3 ; echo $ n , \" th ▁ centered ▁ octadecagonal ▁ \" . \" number ▁ : ▁ \" , center_octadecagon_num ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 13 ; echo $ n , \" th ▁ centered ▁ octadecagonal ▁ \" . \" number ▁ : ▁ \" , center_octadecagon_num ( $ n ) ; ? >"}
{"text": "Nombor Decagonal Berpusat | Fungsi nombor decagonal yang berpusat; Formula untuk mengira nombor decagonal yang berpusat di NTH & mengembalikannya ke dalam fungsi utama. ; Kod pemacu", "code": "< ? php function centereddecagonalnum ( $ n ) { return ( 5 * $ n * $ n + 5 * $ n + 1 ) ; } $ n = 5 ; echo $ n , \" th ▁ centered ▁ decagonal \" , \" number : ▁ \" ; echo centereddecagonalnum ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 9 ; echo $ n , \" th ▁ centered ▁ decagonal \" , \" number : ▁ \" ; echo centereddecagonalnum ( $ n ) ; ? >"}
{"text": "Lexicographically kth cara terkecil untuk mencapai koordinat yang diberikan dari asal | Kembali (a + b)! / A! B! ; Mencari (A + B)! ; Mencari (A + B)! / A! ; Mencari (A + B)! / b! ; Mengembalikan cara terkecil kth untuk mencapai koordinat yang diberikan dari asal; jika pada asalnya; jika pada y - paksi; pengurangan y. ; Bergerak menegak; Panggilan rekursif untuk mengambil langkah seterusnya. ; Jika pada x - paksi; pengurangan x. ; Bergerak mendatar. ; Panggilan rekursif untuk mengambil langkah seterusnya. ; Jika x + y c x lebih besar daripada k; Bergerak mendatar; Panggilan rekursif untuk mengambil langkah seterusnya. ; Bergerak menegak; Panggilan rekursif untuk mengambil langkah seterusnya. ; Kod pemacu", "code": "< ? php function factorial ( $ a , $ b ) { $ res = 1 ; for ( $ i = 1 ; $ i <= ( $ a + $ b ) ; $ i ++ ) $ res = $ res * $ i ; for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) $ res = $ res / $ i ; for ( $ i = 1 ; $ i <= $ b ; $ i ++ ) $ res = $ res / $ i ; return $ res ; } function Ksmallest ( $ x , $ y , $ k ) { if ( $ x == 0 && $ y == 0 ) return ; else if ( $ x == 0 ) { $ y -- ; echo ( \" V \" ) ; Ksmallest ( $ x , $ y , $ k ) ; } else if ( $ y == 0 ) { $ x -- ; echo ( \" H \" ) ; Ksmallest ( $ x , $ y , $ k ) ; } else { if ( factorial ( $ x - 1 , $ y ) > $ k ) { echo ( \" H \" ) ; Ksmallest ( $ x - 1 , $ y , $ k ) ; } else { echo ( \" V \" ) ; Ksmallest ( $ x , $ y - 1 , $ k - factorial ( $ x - 1 , $ y ) ) ; } } } $ x = 2 ; $ y = 2 ; $ k = 2 ; Ksmallest ( $ x , $ y , $ k ) ; ? >"}
{"text": "Nombor Pentagonal yang berpusat | Fungsi nombor pentagonal yang berpusat; Formula untuk mengira nombor pentagonal yang berpusat dan mengembalikannya ke dalam fungsi utama. ; Kod pemacu", "code": "< ? php function centered_pentagonal_Num ( $ n ) { return ( 5 * $ n * $ n - 5 * $ n + 2 ) / 2 ; } $ n = 7 ; echo $ n , \" th ▁ Centered ▁ pentagonal ▁ number : ▁ \" ; echo centered_pentagonal_Num ( $ n ) ; ? >"}
{"text": "Cari jarak maksimum dan minimum antara magnet | Fungsi untuk mencari jarak antara pivot; Berfungsi untuk jarak minimum; Berfungsi untuk jarak maksimum; Kod pemacu", "code": "< ? php function pivotDis ( $ x0 , $ y0 , $ x1 , $ y1 ) { return sqrt ( ( $ x1 - $ x0 ) * ( $ x1 - $ x0 ) + ( $ y1 - $ y0 ) * ( $ y1 - $ y0 ) ) ; } function minDis ( $ D , $ r1 , $ r2 ) { return max ( ( $ D - $ r1 - $ r2 ) , 0 ) ; } function maxDis ( $ D , $ r1 , $ r2 ) { return $ D + $ r1 + $ r2 ; } $ x0 = 0 ; $ y0 = 0 ; $ x1 = 8 ; $ y1 = 0 ; $ r1 = 4 ; $ r2 = 5 ; $ D = pivotDis ( $ x0 , $ y0 , $ x1 , $ y1 ) ; echo \" Distance ▁ while ▁ repulsion ▁ = ▁ \" , maxDis ( $ D , $ r1 , $ r2 ) ; echo \" Distance while attraction = \" , minDis ( $ D , $ r1 , $ r2 ) ; ? >"}
{"text": "Memaksimumkan nilai untuk separuh bulatan radius yang diberikan | Berfungsi untuk mencari nilai maksimum f; menggunakan formula yang diperolehi untuk mendapatkan nilai maksimum F; Kod pemandu", "code": "< ? php function maximumValueOfF ( $ R ) { return 4 * $ R * $ R + 0.25 ; } $ R = 3 ; echo maximumValueOfF ( $ R ) ; ? >"}
{"text": "Cari titik akhir yang lain dengan satu hujung dan pertengahan | Fungsi PHP untuk mencari titik akhir garis; Cari titik akhir untuk koordinat x; Cari titik akhir untuk koordinat Y; Program yang didorong", "code": "< ? php function otherEndPoint ( $ x1 , $ y1 , $ m1 , $ m2 ) { $ x2 = ( 2 * $ m1 - $ x1 ) ; $ y2 = ( 2 * $ m2 - $ y1 ) ; echo \" x2 ▁ = ▁ \" . $ x2 . \" , ▁ y2 ▁ = ▁ \" . $ y2 ; } $ x1 = -4 ; $ y1 = -1 ; $ m1 = 3 ; $ m2 = 5 ; otherEndPoint ( $ x1 , $ y1 , $ m1 , $ m2 ) ; ? >"}
{"text": "Koordinat Rectangle dengan mata yang diberikan terletak di dalam | berfungsi untuk mencetak koordinat segi empat tepat terkecil; Cari Xmax dan Xmin; Cari ymax dan ymin; Cetak semua empat koordinat; Kod pemacu", "code": "< ? php function printRect ( $ X , $ Y , $ n ) { $ Xmax = max ( $ X ) ; $ Xmin = min ( $ X ) ; $ Ymax = max ( $ Y ) ; $ Ymin = min ( $ Y ) ; echo \" { \" , $ Xmin , \" , ▁ \" , $ Ymin , \" } \" , \" STRNEWLINE \" ; echo \" { \" , $ Xmin , \" , ▁ \" , $ Ymax , \" } \" , \" STRNEWLINE \" ; echo \" { \" , $ Xmax , \" , ▁ \" , $ Ymax , \" } \" , \" STRNEWLINE \" ; echo \" { \" , $ Xmax , \" , ▁ \" , $ Ymin , \" } \" ; } $ X = array ( 4 , 3 , 6 , 1 , -1 , 12 ) ; $ Y = array ( 4 , 1 , 10 , 3 , 7 , -1 ) ; $ n = count ( $ X ) ; printRect ( $ X , $ Y , $ n ) ; ? >"}
{"text": "Semak jika garis melewati asal usul | Program PHP untuk mencari jika garis melalui dua koordinat juga melalui asal atau tidak; Kod pemacu", "code": "< ? php function checkOrigin ( $ x1 , $ y1 , $ x2 , $ y2 ) { return ( $ x1 * ( $ y2 - $ y1 ) == $ y1 * ( $ x2 - $ x1 ) ) ; } if ( checkOrigin ( 1 , 28 , 2 , 56 ) == true ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Bilangan segmen garis mendatar atau menegak untuk menyambungkan 3 mata | Berfungsi untuk memeriksa sama ada titik ketiga membentuk segi empat tepat dengan dua mata lain di sudut; Pulangan benar jika titik k boleh digunakan sebagai titik penyertaan untuk menyambung menggunakan segmen dua baris; Semak polyline yang sah dengan dua segmen; Semak sama ada koordinat x atau y - cocordinates adalah sama. ; Melangkah ke atas semua pasangan untuk memeriksa dua segmen baris; Jika tidak, jawapan adalah tiga. ; Kod pemacu", "code": "< ? php function isBetween ( $ a , $ b , $ c ) { return min ( $ a , $ b ) <= $ c and $ c <= max ( $ a , $ b ) ; } function canJoin ( $ x , $ y , $ i , $ j , $ k ) { return ( $ x [ $ k ] == $ x [ $ i ] or $ x [ $ k ] == $ x [ $ j ] ) and isBetween ( $ y [ $ i ] , $ y [ $ j ] , $ y [ $ k ] ) or ( $ y [ $ k ] == $ y [ $ i ] or $ y [ $ k ] == $ y [ $ j ] ) and isBetween ( $ x [ $ i ] , $ x [ $ j ] , $ x [ $ k ] ) ; } function countLineSegments ( $ x , $ y ) { if ( ( $ x [ 0 ] == $ x [ 1 ] and $ x [ 1 ] == $ x [ 2 ] ) or ( $ y [ 0 ] == $ y [ 1 ] and $ y [ 1 ] == $ y [ 2 ] ) ) return 1 ; else if ( canJoin ( $ x , $ y , 0 , 1 , 2 ) or canJoin ( $ x , $ y , 0 , 2 , 1 ) || canJoin ( $ x , $ y , 1 , 2 , 0 ) ) return 2 ; else return 3 ; } $ x = array ( ) ; $ y = array ( ) ; $ x [ 0 ] = -1 ; $ y [ 0 ] = -1 ; $ x [ 1 ] = -1 ; $ y [ 1 ] = 3 ; $ x [ 2 ] = 4 ; $ y [ 2 ] = 3 ; echo countLineSegments ( $ x , $ y ) ; ? >"}
{"text": "Pythagorean Quadruple | fungsi untuk memeriksa; Kod pemacu", "code": "< ? php function pythagorean_quadruple ( $ a , $ b , $ c , $ d ) { $ sum = $ a * $ a + $ b * $ b + $ c * $ c ; if ( $ d * $ d == $ sum ) return true ; else return false ; } $ a = 1 ; $ b = 2 ; $ c = 2 ; $ d = 3 ; if ( pythagorean_quadruple ( $ a , $ b , $ c , $ d ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Program untuk kelantangan dan kawasan permukaan frustum kon | Berfungsi untuk mengira jumlah frustum kon; Berfungsi untuk mengira kawasan permukaan melengkung frustum kon; Berfungsi untuk mengira luas permukaan frustum kerucut; Kod pemacu; Nilai percetakan kelantangan dan kawasan permukaan", "code": "< ? php function volume ( $ r , $ R , $ h ) { $ pi = 3.14159 ; return ( 1 / ( 3 ) ) * $ pi * $ h * ( $ r * $ r + $ R * $ R + $ r * $ R ) ; } function curved_surface_area ( $ r , $ R , $ l ) { $ pi = 3.14159 ; return $ pi * $ l * ( $ R + $ r ) ; } function total_surface_area ( $ r , $ R , $ l , $ h ) { $ pi = 3.14159 ; return ( $ pi * $ l * ( $ R + $ r ) + $ pi * ( $ r * $ r + $ R * $ R ) ) ; } $ small_radius = 3 ; $ big_radius = 8 ; $ slant_height = 13 ; $ height = 12 ; echo ( \" Volume ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ \" ) ; echo ( volume ( $ small_radius , $ big_radius , $ height ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Curved ▁ Surface ▁ Area ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ \" ) ; echo ( curved_surface_area ( $ small_radius , $ big_radius , $ slant_height ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Total ▁ Surface ▁ Area ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ \" ) ; echo ( total_surface_area ( $ small_radius , $ big_radius , $ slant_height , $ height ) ) ; ? >"}
{"text": "Program untuk mencari perimeter / lilitan persegi dan segi empat tepat | Program PHP untuk mencari lilitan persegi; Kod pemacu", "code": "< ? php function Circumference ( $ a ) { return 4 * $ a ; } $ a = 5 ; echo \" Circumference ▁ of ▁ a ▁ \" . \" square ▁ is ▁ \" , Circumference ( $ a ) ; ? >"}
{"text": "Kawasan Maksimum Kuadrilateral | Program PHP untuk mencari maksimum adalah segi empat segi; Mengira separuh perimeter dari segi empat yang diberikan; Memohon formula Brahmagupta untuk mendapatkan kawasan maksimum kuadrilateral; Kod pemacu", "code": "< ? php function maxArea ( $ a , $ b , $ c , $ d ) { $ semiperimeter = ( $ a + $ b + $ c + $ d ) / 2 ; return sqrt ( ( $ semiperimeter - $ a ) * ( $ semiperimeter - $ b ) * ( $ semiperimeter - $ c ) * ( $ semiperimeter - $ d ) ) ; } $ a = 1 ; $ b = 2 ; $ c = 1 ; $ d = 2 ; echo ( maxArea ( $ a , $ b , $ c , $ d ) ) ; ? >"}
{"text": "Cari jejari minimum sehingga atleast k point terletak di dalam bulatan | Kembali jarak minimum yang diperlukan supaya aleast k point terletak di dalam bulatan. ; Mencari jarak antara setiap titik dari asal; Menyusun jarak; Kod pemacu", "code": "< ? php function minRadius ( $ k , $ x , $ y , $ n ) { $ dis = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dis [ $ i ] = $ x [ $ i ] * $ x [ $ i ] + $ y [ $ i ] * $ y [ $ i ] ; sort ( $ dis ) ; return $ dis [ $ k - 1 ] ; } $ k = 3 ; $ x = array ( 1 , -1 , 1 ) ; $ y = array ( 1 , -1 , -1 ) ; $ n = count ( $ x ) ; echo minRadius ( $ k , $ x , $ y , $ n ) ; ? >"}
{"text": "Program untuk kawasan dan perimeter segi empat tepat | Fungsi utiliti; Program Pemandu", "code": "< ? php function areaRectangle ( $ a , $ b ) { $ area = $ a * $ b ; return $ area ; } function perimeterRectangle ( $ a , $ b ) { $ perimeter = 2 * ( $ a + $ b ) ; return $ perimeter ; } $ a = 5 ; $ b = 6 ; echo ( \" Area ▁ = ▁ \" ) ; echo ( areaRectangle ( $ a , $ b ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Perimeter ▁ = ▁ \" ) ; echo ( perimeterRectangle ( $ a , $ b ) ) ; ? >"}
{"text": "Program untuk Kawasan Square | Program PHP untuk mencari ARIA of the Square; Kod pemacu", "code": "< ? php function areaSquare ( $ side ) { $ area = $ side * $ side ; return $ area ; } $ side = 4 ; echo ( areaSquare ( $ side ) ) ; ? >"}
{"text": "Perimeter minimum blok N | Program PHP untuk mencari perimeter minimum menggunakan blok N. ; Jika n adalah persegi yang sempurna; Bilangan baris; perimeter grid segi empat tepat; Sekiranya terdapat blok yang tersisa; Kod pemacu", "code": "< ? php function minPerimeter ( $ n ) { $ l = floor ( sqrt ( $ n ) ) ; $ sq = $ l * $ l ; if ( $ sq == $ n ) return $ l * 4 ; else { $ row = floor ( $ n / $ l ) ; $ perimeter = 2 * ( $ l + $ row ) ; if ( $ n % $ l != 0 ) $ perimeter += 2 ; return $ perimeter ; } } $ n = 10 ; echo minPerimeter ( $ n ) ; ? >"}
{"text": "Cari jika mungkin untuk memutar halaman dengan sudut atau tidak. | berfungsi untuk mencari sama ada mungkin untuk memutar halaman atau tidak; Mengira jarak b / w mata; Jika jarak tidak sama; Jika mata berada dalam baris yang sama; Mata A, B, dan C", "code": "< ? php function possibleOrNot ( $ a1 , $ a2 , $ b1 , $ b2 , $ c1 , $ c2 ) { $ dis1 = pow ( $ b1 - $ a1 , 2 ) + pow ( $ b2 - $ a2 , 2 ) ; $ dis2 = pow ( $ c1 - $ b1 , 2 ) + pow ( $ c2 - $ b2 , 2 ) ; if ( $ dis1 != $ dis2 ) echo \" No \" ; else if ( $ b1 == ( ( $ a1 + $ c1 ) / 2.0 ) && $ b2 == ( ( $ a2 + $ c2 ) / 2.0 ) ) echo \" No \" ; else echo \" Yes \" ; } $ a1 = 1 ; $ a2 = 0 ; $ b1 = 2 ; $ b2 = 0 ; $ c1 = 3 ; $ c2 = 0 ; possibleOrNot ( $ a1 , $ a2 , $ b1 , $ b2 , $ c1 , $ c2 ) ; ? >"}
{"text": "Semak jika dua lingkaran yang diberikan menyentuh atau bersilang antara satu sama lain | Program PHP untuk memeriksa sama ada dua lingkaran menyentuh satu sama lain atau tidak. ; Kod pemacu", "code": "< ? php function circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) { $ distSq = ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ; $ radSumSq = ( $ r1 + $ r2 ) * ( $ r1 + $ r2 ) ; if ( $ distSq == $ radSumSq ) return 1 ; else if ( $ distSq > $ radSumSq ) return -1 ; else return 0 ; } $ x1 = -10 ; $ y1 = 8 ; $ x2 = 14 ; $ y2 = -24 ; $ r1 = 30 ; $ r2 = 10 ; $ t = circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) ; if ( $ t == 1 ) echo \" Circle ▁ touch ▁ to ▁ each ▁ other . \" ; else if ( $ t < 0 ) echo \" Circle ▁ not ▁ touch ▁ to ▁ each ▁ other . \" ; else echo \" Circle ▁ intersect ▁ to ▁ each ▁ other . \" ; ? >"}
{"text": "Count of Stuste Sudut dalam bulatan dengan 'k' titik sama antara 2 mata yang diberikan | Program PHP untuk mengira bilangan sudut bodoh untuk diberi dua mata. ; Terdapat dua arka yang menghubungkan A dan B. Marilah kita mengira mata pada kedua -dua arka. ; Kedua -dua arka mempunyai bilangan mata yang sama; Mata pada arka yang lebih kecil adalah jawapan; Kod pemacu", "code": "< ? php function countObtuseAngles ( $ a , $ b , $ k ) { $ c1 = ( $ b - $ a ) - 1 ; $ c2 = ( $ k - $ b ) + ( $ a - 1 ) ; if ( $ c1 == $ c2 ) return 0 ; return min ( $ c1 , $ c2 ) ; } $ k = 6 ; $ a = 1 ; $ b = 3 ; echo countObtuseAngles ( $ a , $ b , $ k ) ; ? >"}
{"text": "Mengira segitiga akut, bodoh dan kanan dengan sisi yang diberikan | Cari bilangan segitiga yang akut, betul, bodoh yang boleh dibentuk dari array yang diberikan. ; Mencari kuadrat setiap elemen array. ; Susun sisi array dan dataran mereka. ; x untuk segitiga akut y untuk segitiga kanan z untuk segitiga bodoh; Mencari titik paling jauh p di mana a ^ 2 + b ^ 2> = c ^ 2 .; Mencari titik terjauh Q di mana A + B> c. ; Jika titik p membuat segitiga yang betul. ; Semua segitiga antara J dan P adalah segitiga akut. Jadi tambah p - j - 1 dalam x. ; Kenaikan y oleh 1 .; Semua segitiga antara Q dan P adalah segitiga akut. Jadi tambah Q - p dalam z. ; Jika tiada segitiga yang betul; Semua segitiga antara J dan P adalah segitiga akut. Jadi tambah p - j dalam x. ; Semua segitiga antara Q dan P adalah segitiga akut. Jadi tambah Q - p dalam z. ; Kod pemacu", "code": "< ? php function findTriangle ( $ a , $ n ) { $ b [ $ n + 2 ] = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ b [ $ i ] = $ a [ $ i ] * $ a [ $ i ] ; sort ( $ a ) ; sort ( $ b ) ; $ x = 0 ; $ y = 0 ; $ z = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ p = $ i + 1 ; $ q = $ i + 1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { while ( $ p < $ n - 1 && $ b [ $ i ] + $ b [ $ j ] >= $ b [ $ p + 1 ] ) $ p ++ ; $ q = max ( $ q , $ p ) ; while ( $ q < $ n - 1 && $ a [ $ i ] + $ a [ $ j ] > $ a [ $ q + 1 ] ) $ q ++ ; if ( $ b [ $ i ] + $ b [ $ j ] == $ b [ $ p ] ) { $ x += max ( $ p - $ j - 1 , 0 ) ; $ y ++ ; $ z += $ q - $ p ; } else { $ x += max ( $ p - $ j , 0 ) ; $ z += $ q - $ p ; } } } echo \" Acute ▁ Triangle : ▁ \" , $ x , \" STRNEWLINE \" ; echo \" Right ▁ Triangle : ▁ \" , $ y , \" STRNEWLINE \" ; echo \" Obtuse ▁ Triangle : ▁ \" , $ z , \" STRNEWLINE \" ; } $ arr = array ( 2 , 3 , 9 , 10 , 12 , 15 ) ; $ n = sizeof ( $ arr ) ; findTriangle ( $ arr , $ n ) ; ? >"}
{"text": "Kawasan poligon dengan vertices yang diperintahkan n yang diberikan | (X [i], y [i]) adalah koordinat titik saya. ; Memulakan kawasan; Hitung nilai formula kasut; J adalah puncak sebelumnya kepada i; Kembali nilai mutlak; Kod pemacu", "code": "< ? php function polygonArea ( $ X , $ Y , $ n ) { $ area = 0.0 ; $ j = $ n - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ area += ( $ X [ $ j ] + $ X [ $ i ] ) * ( $ Y [ $ j ] - $ Y [ $ i ] ) ; $ j = $ i ; } return abs ( $ area / 2.0 ) ; } $ X = array ( 0 , 2 , 4 ) ; $ Y = array ( 1 , 3 , 7 ) ; $ n = sizeof ( $ X ) ; echo polygonArea ( $ X , $ Y , $ n ) ; ? >"}
{"text": "Program untuk mencari digit terakhir x dalam asas y | Berfungsi untuk mencari digit terakhir x dalam asas y; Kod pemacu", "code": "< ? php function last_digit ( $ X , $ Y ) { echo ( $ X % $ Y ) ; } $ X = 55 ; $ Y = 3 ; last_digit ( $ X , $ Y ) ; ? >"}
{"text": "Akar persamaan kuadratik apabila A + B + C = 0 tanpa menggunakan formula Shridharacharya | Berfungsi untuk mencetak akar persamaan kuadratik apabila A + B + C = 0; Kod pemacu", "code": "< ? php function printRoots ( $ a , $ b , $ c ) { echo \"1\" ; echo \" , ▁ \" ; echo $ c / ( $ a * 1.0 ) ; } $ a = 2 ; $ b = 3 ; $ c = -5 ; printRoots ( $ a , $ b , $ c ) ; ? >"}
{"text": "Pasangan quadruplet dengan sifar XOR dalam array yang diberikan | Pelaksanaan PHP pendekatan; Fungsi yang kembali benar jika array mengandungi pasangan quadruplet yang sah; Kami sentiasa dapat mencari pasangan quadruplet yang sah untuk saiz array yang lebih besar daripada max; Untuk susunan saiz yang lebih kecil, lakukan kekerasan; Kod pemacu", "code": "< ? php const MAX = 130 ; function validQuadruple ( $ arr , $ n ) { if ( $ n >= MAX ) return true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) { if ( ( $ arr [ $ i ] ^ $ arr [ $ j ] ^ $ arr [ $ k ] ^ $ arr [ $ l ] ) == 0 ) { return true ; } } return false ; } $ arr = array ( 1 , 0 , 2 , 3 , 7 ) ; $ n = count ( $ arr ) ; if ( validQuadruple ( $ arr , $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Semak sama ada nombor boleh diwakili sebagai jumlah kirum positif K yang berbeza | Fungsi yang kembali benar jika n boleh diwakili sebagai jumlah integer positif yang jelas; Jika n boleh diwakili sebagai 1 + 2 + 3 + ... + (k - 1) + (k + x); Kod pemacu", "code": "< ? php function solve ( $ n , $ k ) { if ( $ n >= ( $ k * ( $ k + 1 ) ) / 2 ) { return true ; } return false ; } $ n = 12 ; $ k = 4 ; if ( solve ( $ n , $ k ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Bitwise dan sub | Berfungsi untuk mengembalikan nilai minimum kemungkinan | | K - X | di mana x adalah bitwise dan unsur -unsur beberapa sub - array; Semak semua kemungkinan sub - array; Cari minimum keseluruhan; Kod pemacu", "code": "< ? php function closetAND ( & $ arr , $ n , $ k ) { $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ X = $ arr [ $ i ] ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ X &= $ arr [ $ j ] ; $ ans = min ( $ ans , abs ( $ k - $ X ) ) ; } } return $ ans ; } $ arr = array ( 4 , 7 , 10 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; $ k = 2 ; echo closetAND ( $ arr , $ n , $ k ) ; return 0 ; ? >"}
{"text": "Program untuk mencari peratusan kadar dari kepentingan kompaun tahun berturut -turut | Fungsi untuk mengembalikan peratusan kadar yang diperlukan; Kod pemacu", "code": "< ? php function Rate ( $ N1 , $ N2 ) { $ rate = ( $ N2 - $ N1 ) * 100 / $ N1 ; return $ rate ; } $ N1 = 100 ; $ N2 = 120 ; echo Rate ( $ N1 , $ N2 ) , \" % \" ; ? >"}
{"text": "Cari nombor utama k dalam array seperti itu (a [i] % k) adalah maksimum | Berfungsi untuk mengembalikan kiraan prima dalam array yang diberikan; Cari nilai maksimum dalam array; Gunakan ayak untuk mencari semua nombor perdana kurang daripada atau sama dengan max_val Buat array boolean \"Perdana [0 ... N]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Baki bahagian Sieve; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Untuk menyimpan nombor perdana maksimum; Jika elemen semasa adalah perdana maka kemas kini perdana maksimum; Mengembalikan nombor perdana maksimum dari array; Kod pemacu", "code": "< ? php function getPrime ( $ arr , $ n ) { $ max_val = max ( $ arr ) ; $ prime = array_fill ( 0 , $ max_val + 1 , true ) ; $ prime [ 0 ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ max_val ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ max_val ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ maximum = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ prime [ $ arr [ $ i ] ] ) $ maximum = max ( $ maximum , $ arr [ $ i ] ) ; } return $ maximum ; } $ arr = array ( 2 , 10 , 15 , 7 , 6 , 8 , 13 ) ; $ n = count ( $ arr ) ; echo getPrime ( $ arr , $ n ) ; ? >"}
{"text": "Integer minimum supaya ia meninggalkan selebihnya 1 untuk membahagikan dengan mana -mana elemen dari julat [2, n] | Berfungsi untuk mengembalikan nombor terkecil yang dibahagikan dengan mana -mana elemen dari julat [2, n] meninggalkan selebihnya 1; Cari LCM unsur -unsur dari julat [2, n]; Mengembalikan nombor yang diperlukan; Kod pemacu", "code": "< ? php function getMinNum ( $ N ) { $ lcm = 1 ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) $ lcm = ( ( $ i * $ lcm ) / ( __gcd ( $ i , $ lcm ) ) ) ; return ( $ lcm + 1 ) ; } function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } $ N = 5 ; echo ( getMinNum ( $ N ) ) ; ? >"}
{"text": "Bilangan maksimum tepi dalam graf bipartite | Berfungsi untuk mengembalikan bilangan maksimum tepi yang mungkin dalam graf bipartite dengan n vertices; Kod pemacu", "code": "< ? php function maxEdges ( $ N ) { $ edges = 0 ; $ edges = floor ( ( $ N * $ N ) / 4 ) ; return $ edges ; } $ N = 5 ; echo maxEdges ( $ N ) ; ? >"}
{"text": "Cari permutasi nombor semulajadi n pertama yang memenuhi syarat yang diberikan | Fungsi untuk mencari permutasi (p) nombor semulajadi n pertama supaya terdapat unsur -unsur permutasi yang betul -betul seperti GCD (p [i], i)> 1; Tempat pertama semua nombor di tempat masing -masing; Ubah suai untuk integer n - k pertama; Di tempat indeks pertama n - k; Cetak permutasi; Kod pemacu", "code": "< ? php function Permutation ( $ n , $ k ) { $ p = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ p [ $ i ] = $ i ; for ( $ i = 1 ; $ i < $ n - $ k ; $ i ++ ) $ p [ $ i + 1 ] = $ i ; $ p [ 1 ] = $ n - $ k ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ p [ $ i ] , \" ▁ \" ; } $ n = 5 ; $ k = 2 ; Permutation ( $ n , $ k ) ; ? >"}
{"text": "Bilangan kedudukan yang menambahkan k ke elemen adalah lebih besar daripada jumlah semua elemen lain | Fungsi yang akan mengetahui kedudukan yang sah; Cari jumlah semua elemen; Menambah K ke elemen dan periksa sama ada ia lebih besar daripada jumlah semua elemen lain; Kod pemacu", "code": "< ? php function validPosition ( $ arr , $ N , $ K ) { $ count = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ sum += $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( ( $ arr [ $ i ] + $ K ) > ( $ sum - $ arr [ $ i ] ) ) $ count ++ ; } return $ count ; } $ arr = array ( 2 , 1 , 6 , 7 ) ; $ K = 4 ; $ N = count ( $ arr ) ; echo validPosition ( $ arr , $ N , $ K ) ; ? >"}
{"text": "Cari elemen dengan bit set maksimum dalam array | Berfungsi untuk mengembalikan elemen dari array yang mempunyai bit set maksimum; Untuk menyimpan elemen yang diperlukan dan bit set maksimum setakat ini; Kiraan bit set dalam elemen semasa; Kemas kini maksimum; Kod pemacu", "code": "< ? php function maxBitElement ( $ arr , $ n ) { $ num = 0 ; $ max = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ cnt = BitCount ( $ arr [ $ i ] ) ; if ( $ cnt > $ max ) { $ max = $ cnt ; $ num = $ arr [ $ i ] ; } } return $ num ; } function BitCount ( $ n ) { $ count = 0 ; while ( $ n != 0 ) { $ count ++ ; $ n &= ( $ n - 1 ) ; } return $ count ; } $ arr = array ( 3 , 2 , 4 , 7 , 1 , 10 , 5 , 8 , 9 , 6 ) ; $ n = count ( $ arr ) ; echo ( maxBitElement ( $ arr , $ n ) ) ; ? >"}
{"text": "Jumlah terkecil dan terbesar dua n | Berfungsi untuk mengembalikan jumlah terkecil 2 N - nombor digit; Berfungsi untuk mengembalikan jumlah terbesar 2 N - nombor digit; Kod pemacu", "code": "< ? php function smallestSum ( $ n ) { if ( $ n == 1 ) return 0 ; return ( 2 * pow ( 10 , $ n - 1 ) ) ; } function largestSum ( $ n ) { return 2 * ( pow ( 10 , $ n ) - 1 ) ; } $ n = 4 ; echo \" Largest = \" ▁ . ▁ largestSum ( $ n ) ▁ . ▁ \" \" ; STRNEWLINE echo ▁ \" Smallest = \" ? >"}
{"text": "Memandangkan dua array mengira semua pasangan yang jumlahnya adalah nombor ganjil | Fungsi yang mengembalikan bilangan pasangan; Kiraan angka ganjil dan bahkan; Melintasi array pertama dan mengira bilangan nombor ganjil dan evene di dalamnya; Melintasi array kedua dan mengira bilangan nombor ganjil dan evene di dalamnya; Mengira bilangan pasangan; Mengembalikan bilangan pasangan; Kod pemacu", "code": "< ? php function count_pairs ( $ a , $ b , $ n , $ m ) { $ odd1 = 0 ; $ even1 = 0 ; $ odd2 = 0 ; $ even2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 ) $ odd1 ++ ; else $ even1 ++ ; } for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ b [ $ i ] % 2 ) $ odd2 ++ ; else $ even2 ++ ; } $ pairs = min ( $ odd1 , $ even2 ) + min ( $ odd2 , $ even1 ) ; return $ pairs ; } $ a = array ( 9 , 14 , 6 , 2 , 11 ) ; $ b = array ( 8 , 4 , 7 , 20 ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; echo count_pairs ( $ a , $ b , $ n , $ m ) ; ? >"}
{"text": "Cetak langkah untuk membuat nombor dalam bentuk 2 ^ x | Berfungsi untuk mencari bit paling tidak tersendiri dalam nombor. ; Fungsi yang melaksanakan langkah; Cari bit paling tidak tersendiri; Jika nombor tidak mempunyai sedikit tidak jelas, ia bermakna ia berada dalam Borang 2 ^ x - 1; Mengira langkah -langkah; Iterat sehingga nombor adalah Borang 2 ^ x - 1; Walaupun peningkatan langkah sebanyak 1; Langkah ganjil xor dengan mana -mana 2 ^ m - 1; Cari bit paling tidak tersendiri; 2 ^ m - 1; Melakukan langkah; Meningkatkan langkah -langkah; Kod pemacu", "code": "< ? php function find_leftmost_unsetbit ( $ n ) { $ ind = -1 ; $ i = 1 ; while ( $ n ) { if ( ! ( $ n & 1 ) ) $ ind = $ i ; $ i ++ ; $ n >>= 1 ; } return $ ind ; } function perform_steps ( $ n ) { $ left = find_leftmost_unsetbit ( $ n ) ; if ( $ left == -1 ) { echo \" No ▁ steps ▁ required \" ; return ; } $ step = 1 ; while ( find_leftmost_unsetbit ( $ n ) != -1 ) { if ( $ step % 2 == 0 ) { $ n += 1 ; echo \" Step \" , $ step , \" : ▁ Increase ▁ by ▁ 1 STRNEWLINE \" ; } else { $ m = find_leftmost_unsetbit ( $ n ) ; $ num = pow ( 2 , $ m ) - 1 ; $ n = $ n ^ $ num ; echo \" Step \" , $ step , \" : ▁ Xor ▁ with ▁ \" , $ num , \" STRNEWLINE \" ; } $ step += 1 ; } } $ n = 39 ; perform_steps ( $ n ) ; ? >"}
{"text": "Tentukan kedudukan orang ketiga pada poligon n biasa | Berfungsi untuk mengetahui bilangan simpang itu; Orang lain tidak boleh berdiri di puncak di mana 2 kanak -kanak berdiri. ; Mengira lompatan minimum dari setiap puncak. ; Kirakan jumlah lompatan. ; Kod pemacu; Fungsi panggilan", "code": "< ? php function vertices ( $ N , $ A , $ B ) { $ position = 0 ; $ minisum = PHP_INT_MAX ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i == $ A $ i == $ B ) continue ; else { $ x = abs ( $ i - $ A ) ; $ y = abs ( $ i - $ B ) ; $ sum = $ x + $ y ; if ( $ sum < $ minisum ) { $ minisum = $ sum ; $ position = $ i ; } } } return $ position ; } $ N = 3 ; $ A = 1 ; $ B = 2 ; echo \" Vertex = \" ? >"}
{"text": "Cari jumlah faktorial dalam array | Berfungsi untuk mengembalikan faktorial n; Berfungsi untuk mengembalikan jumlah faktorial unsur -unsur array; Untuk menyimpan jumlah yang diperlukan; Tambah faktorial semua elemen; Kod pemacu", "code": "< ? php function factorial ( $ n ) { $ f = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ f *= $ i ; } return $ f ; } function sumFactorial ( $ arr , $ n ) { $ s = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ s += factorial ( $ arr [ $ i ] ) ; } return $ s ; } $ arr = array ( 7 , 3 , 5 , 4 , 8 ) ; $ n = sizeof ( $ arr ) ; echo sumFactorial ( $ arr , $ n ) ; ? >"}
{"text": "Kuasa tertinggi 2 yang membahagikan nombor yang diwakili dalam binari | Berfungsi untuk mengembalikan kuasa tertinggi 2 yang membahagikan nombor binari yang diberikan; Untuk menyimpan kuasa tertinggi yang diperlukan 2; Mengira bilangan sifar berturut -turut dari hujung dalam rentetan binari yang diberikan; Kod pemacu", "code": "< ? php function highestPower ( $ str , $ len ) { $ ans = 0 ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] == '0' ) $ ans ++ ; else break ; } return $ ans ; } $ str = \"100100\" ; $ len = strlen ( $ str ) ; echo highestPower ( $ str , $ len ) ; ? >"}
{"text": "Bilangan cara untuk mengatur ob objek yang berbeza mengambil objek n pada satu masa | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan n! % p; $ res = 1; Memulakan hasil; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); $ x = $ x % $ p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; Mengembalikan n ^ ( - 1) mod p; Mengembalikan NCR % P menggunakan teorem kecil Fermat. ; Kes asas; Isi pelbagai faktorial supaya kita dapat mencari semua faktorial r, n dan n - r; Berfungsi untuk mengembalikan bilangan cara untuk mengatur objek yang berbeza mengambil objek N pada satu masa; Kod pemacu; Panggilan fungsi", "code": "< ? php $ mod = ( 1e9 + 7 ) ; function factorial ( $ n , $ p ) { for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = ( $ res * $ i ) % $ p ; return $ res ; } function power ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( ( $ y & 1 ) == 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function modInverse ( $ n , $ p ) { return power ( $ n , $ p - 2 , $ p ) ; } function nCrModP ( $ n , $ r , $ p ) { if ( $ r == 0 ) return 1 ; $ fac = array ( ( int ) $ n + 1 ) ; $ fac [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ fac [ $ i ] = $ fac [ $ i - 1 ] * $ i % $ p ; return ( $ fac [ ( int ) $ n ] * modInverse ( $ fac [ ( int ) $ r ] , $ p ) % $ p * modInverse ( $ fac [ ( int ) $ n - ( int ) $ r ] , $ p ) % $ p ) % $ p ; } function countArrangements ( $ n , $ k , $ p ) { return ( factorial ( $ n , $ p ) * nCrModP ( $ k , $ n , $ p ) ) % $ p ; } { $ N = 5 ; $ K = 8 ; echo ( countArrangements ( $ N , $ K , $ mod ) ) ; }"}
{"text": "Cari produk maksimum digit di antara nombor kurang daripada atau sama dengan N | Fungsi yang mengembalikan produk maksimum digit di antara nombor kurang daripada atau sama dengan n; Kod pemacu", "code": "< ? php function maxProd ( $ N ) { if ( $ N == 0 ) return 1 ; if ( $ N < 10 ) return $ N ; return max ( maxProd ( ( int ) ( $ N / 10 ) ) * ( $ N % 10 ) , maxProd ( ( int ) ( $ N / 10 ) - 1 ) * 9 ) ; } $ N = 390 ; echo maxProd ( $ N ) ; ? >"}
{"text": "Semak sama ada nombor dari setiap baris boleh dipilih sedemikian rupa sehingga xor nombor lebih besar daripada sifar | Program PHP untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada nombor dari setiap baris boleh dipilih supaya xor nombor lebih besar daripada sifar; Cari XOR lajur pertama untuk setiap baris; Jika xorr adalah 0; Melintasi matriks; Semak adalah atleast 2 elemen yang berbeza; Kod pemacu", "code": "< ? php $ N = 2 ; $ M = 3 ; function check ( $ mat ) { global $ N ; global $ M ; $ xorr = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ xorr = $ xorr ^ $ mat [ $ i ] [ 0 ] ; } if ( $ xorr != 0 ) return true ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j < $ M ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ i ] [ 0 ] ) return true ; } } return false ; } $ mat = array ( array ( 7 , 7 , 7 ) , array ( 10 , 10 , 7 ) ) ; if ( check ( $ mat ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Jumlah siri 1, 2, 4, 3, 5, 7, 9, 6, 8, 10, 11, 13. sehingga n | Berfungsi untuk mencari jumlah nombor pertama yang pertama; Berfungsi untuk mencari jumlah nombor n pertama; Fungsi untuk secara keseluruhan mencari jumlah siri; Nombor ganjil awal; Nombor awal walaupun; Kuasa pertama 2; Semak pariti untuk ganjil / walaupun; Mengira jumlahnya; Dapatkan minimum daripada baki bilangan atau kuasa 2; Mengurangkan jumlah yang banyak dari NUM; Jika segmen mempunyai nombor ganjil; Summate nombor ganjil dengan pengecualian; Meningkatkan bilangan nombor ganjil; Jika segmen mempunyai nombor; Merumuskan nombor juga dengan pengecualian; Meningkatkan bilangan nombor walaupun; Set nombor seterusnya; Tukar pariti untuk ganjil / walaupun; Kod pemacu", "code": "< ? php function sumodd ( $ n ) { return ( $ n * $ n ) ; } function sumeven ( $ n ) { return ( $ n * ( $ n + 1 ) ) ; } function findSum ( $ num ) { $ sumo = 0 ; $ sume = 0 ; $ x = 1 ; $ cur = 0 ; $ ans = 0 ; while ( $ num > 0 ) { $ inc = min ( $ x , $ num ) ; $ num -= $ inc ; if ( $ cur == 0 ) { $ ans = $ ans + sumodd ( $ sumo + $ inc ) - sumodd ( $ sumo ) ; $ sumo += $ inc ; } else { $ ans = $ ans + sumeven ( $ sume + $ inc ) - sumeven ( $ sume ) ; $ sume += $ inc ; } $ x *= 2 ; $ cur ^= 1 ; } return $ ans ; } $ n = 4 ; echo findSum ( $ n ) ; ? >"}
{"text": "Cari istilah ke siri yang diberikan | Berfungsi untuk mengembalikan istilah ke siri yang diberikan; Kod pemacu", "code": "< ? php function oddTriangularNumber ( $ N ) { return ( $ N * ( ( 2 * $ N ) - 1 ) ) ; } $ N = 3 ; echo oddTriangularNumber ( $ N ) ; ? >"}
{"text": "Semak jika diberi dua baris lurus adalah sama atau tidak | Fungsi untuk memeriksa sama ada mereka sama; Kod pemacu", "code": "< ? php function idstrt ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) { if ( ( $ a1 / $ a2 == $ b1 / $ b2 ) && ( $ a1 / $ a2 == $ c1 / $ c2 ) && ( $ b1 / $ b2 == $ c1 / $ c2 ) ) echo \" The ▁ given ▁ straight ▁ lines ▁ are ▁ identical \" , \" STRNEWLINE \" ; else echo \" The ▁ given ▁ straight ▁ lines ▁ are ▁ not ▁ identical \" , \" STRNEWLINE \" ; } $ a1 = -2 ; $ b1 = 4 ; $ c1 = 3 ; $ a2 = -6 ; $ b2 = 12 ; $ c2 = 9 ; idstrt ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) ; ? >"}
{"text": "Persamaan garis lurus yang melalui titik tertentu yang membelahnya menjadi dua segmen garis yang sama | Berfungsi untuk mencetak persamaan garis yang diperlukan; Kod pemacu", "code": "< ? php function line ( $ x0 , $ y0 ) { $ c = 2 * $ y0 * $ x0 ; echo $ y0 , \" x \" , \" ▁ + ▁ \" , $ x0 , \" y ▁ = ▁ \" , $ c ; } $ x0 = 4 ; $ y0 = 3 ; line ( $ x0 , $ y0 ) ; ? >"}
{"text": "Cari matriks asal apabila elemen terbesar berturut -turut dan lajur diberikan | Pelaksanaan PHP pendekatan; Fungsi yang mencetak matriks asal; Melangkah dalam baris; Melangkah dalam lajur; Jika sebelum ini wujud elemen; Kod pemacu", "code": "< ? php $ N = 3 ; $ M = 7 ; function printOriginalMatrix ( $ a , $ b , $ mat ) { for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) { for ( $ j = 0 ; $ j < $ GLOBALS [ ' M ' ] ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == 1 ) echo min ( $ a [ $ i ] , $ b [ $ j ] ) . \" ▁ \" ; else echo \"0\" . \" ▁ \" ; } echo \" \\r STRNEWLINE \" ; } } $ a = array ( 2 , 1 , 3 ) ; $ b = array ( 2 , 3 , 0 , 0 , 2 , 0 , 1 ) ; $ mat = array ( array ( 1 , 0 , 0 , 0 , 1 , 0 , 0 ) , array ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ) , array ( 1 , 1 , 0 , 0 , 0 , 0 , 0 ) ) ; printOriginalMatrix ( $ a , $ b , $ mat ) ; ? >"}
{"text": "Kirakan kerugian yang ditanggung dalam menjual barang -barang yang diberikan pada harga diskaun | Berfungsi untuk mengembalikan x % n; Berfungsi untuk mengembalikan jumlah kerugian; Untuk menyimpan jumlah kerugian; Harga asal item; Harga di mana item itu akan dijual; Harga diskaun item tersebut; Kerugian yang ditanggung; Kod pemacu; Jumlah item", "code": "< ? php function percent ( $ n , $ x ) { $ p = ( int ) ( $ n ) * $ x ; $ p /= 100 ; return $ p ; } function getLoss ( $ price , $ quantity , $ X , $ n ) { $ loss = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ originalPrice = $ price [ $ i ] ; $ sellingPrice = $ originalPrice + percent ( $ originalPrice , $ X [ $ i ] ) ; $ afterDiscount = $ sellingPrice - percent ( $ sellingPrice , $ X [ $ i ] ) ; $ loss += ( ( $ originalPrice - $ afterDiscount ) * $ quantity [ $ i ] ) ; } return $ loss ; } $ price = array ( 20 , 48 , 200 , 100 ) ; $ quantity = array ( 20 , 48 , 1 , 1 ) ; $ X = array ( 0 , 48 , 200 , 5 ) ; $ n = count ( $ X ) ; echo getLoss ( $ price , $ quantity , $ X , $ n ) ; ? >"}
{"text": "Perbezaan maksimum antara dua elemen dalam array | Berfungsi untuk mengembalikan perbezaan mutlak maksimum antara mana -mana dua elemen array; Untuk menyimpan minimum dan elemen maksimum dari array; Kod pemacu", "code": "< ? php function maxAbsDiff ( $ arr , $ n ) { $ minEle = $ arr [ 0 ] ; $ maxEle = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ minEle = min ( $ minEle , $ arr [ $ i ] ) ; $ maxEle = max ( $ maxEle , $ arr [ $ i ] ) ; } return ( $ maxEle - $ minEle ) ; } $ arr = array ( 2 , 1 , 5 , 3 ) ; $ n = sizeof ( $ arr ) ; echo maxAbsDiff ( $ arr , $ n ) ;"}
{"text": "Memaksimumkan jumlah subarray maksimum selepas mengeluarkan satu elemen atmost | Berfungsi untuk mengembalikan jumlah maksimum - jumlah array; Diasaskan; Melintasi array; Meningkatkan jumlah; Jika jumlah sub -array lebih daripada sebelumnya; Jika jumlah negatif; Fungsi yang mengembalikan jumlah maksimum sub -array selepas mengeluarkan elemen dari sub - array yang sama; Sub maksimum - jumlah array menggunakan algoritma Kadane; Re - memohon Kadane dengan perubahan kecil; Meningkatkan jumlah; Jika jumlah sub -array lebih besar daripada sebelumnya; Jika elemen 0, tiada penyingkiran; Jika elemen lebih banyak, maka simpan nilai minimum dalam sub - array yang diperoleh sehingga sekarang; Jika jumlah negatif; Re - memulakan segala -galanya; Kod pemacu", "code": "< ? php function maxSubArraySum ( $ a , $ size ) { $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; } return $ max_so_far ; } function maximizeSum ( $ a , $ n ) { $ cnt = 0 ; $ mini = PHP_INT_MAX ; $ minSubarray = PHP_INT_MAX ; $ sum = maxSubArraySum ( $ a , $ n ) ; $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; $ cnt ++ ; $ minSubarray = min ( $ a [ $ i ] , $ minSubarray ) ; if ( $ sum == $ max_ending_here ) { if ( $ cnt == 1 ) $ mini = min ( $ mini , 0 ) ; else $ mini = min ( $ mini , $ minSubarray ) ; } if ( $ max_ending_here < 0 ) { $ max_ending_here = 0 ; $ cnt = 0 ; $ minSubarray = PHP_INT_MAX ; } } return $ sum - $ mini ; } $ a = array ( 1 , 2 , 3 , -2 , 3 ) ; $ n = sizeof ( $ a ) / sizeof ( $ a [ 0 ] ) ; echo maximizeSum ( $ a , $ n ) ; ? >"}
{"text": "3 | Fungsi yang pulih benar jika n adalah nombor Osiris; 3 rd digit; 2 digit; 1 st digit; Periksa keadaan yang diperlukan; Kod pemacu", "code": "< ? php function isOsiris ( $ n ) { $ a = $ n % 10 ; $ b = floor ( $ n / 10 ) % 10 ; $ c = floor ( $ n / 100 ) ; $ digit_sum = $ a + $ b + $ c ; if ( $ n == ( 2 * ( $ digit_sum ) * 11 ) ) { return true ; } return false ; } $ n = 132 ; if ( isOsiris ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Nombor Dudeney | Fungsi yang pulih benar jika n adalah nombor Dudeney; Jika n bukan kiub yang sempurna; Digit terakhir; Kemas kini jumlah digit; Keluarkan digit terakhir; Jika akar kiub n tidak sama dengan jumlah digitnya; Kod pemacu", "code": "< ? php function isDudeney ( $ n ) { $ cube_rt = floor ( round ( ( pow ( $ n , 1.0 / 3.0 ) ) ) ) ; if ( $ cube_rt * $ cube_rt * $ cube_rt != $ n ) return false ; $ dig_sum = 0 ; $ temp = $ n ; while ( $ temp > 0 ) { $ rem = $ temp % 10 ; $ dig_sum += $ rem ; $ temp = $ temp / 10 ; } if ( $ cube_rt != $ dig_sum ) return false ; return true ; } $ n = 17576 ; if ( isDudeney ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Bilangan segitiga yang mungkin dengan panjang tongkat yang diberikan kuasa 2 | Berfungsi untuk mengembalikan bilangan segitiga kawasan positif; Untuk menyimpan kiraan jumlah segitiga; Untuk menyimpan kiraan pasang tongkat dengan panjang yang sama; Kembali - melintasi dan mengira bilangan segitiga; Mengira bilangan pasangan; Jika kita mempunyai satu lagi tongkat dan kita mempunyai pasangan; Mengira 1 segitiga; Mengurangkan satu pasangan; Mengira segitiga yang tinggal yang boleh dibentuk; Kod pemacu", "code": "< ? php Function countTriangles ( $ a , $ n ) { $ cnt = 0 ; $ pairs = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ pairs += $ a [ $ i ] / 2 ; if ( $ a [ $ i ] % 2 == 1 && $ pairs > 0 ) { $ cnt += 1 ; $ pairs -= 1 ; } } $ cnt += ( int ) ( ( 2 * $ pairs ) / 3 ) ; return $ cnt ; } $ a = array ( 1 , 2 , 2 , 2 , 2 ) ; $ n = sizeof ( $ a ) ; echo ( countTriangles ( $ a , $ n ) ) ; ? >"}
{"text": "Nombor digit terkecil yang merupakan pelbagai 5 | Berfungsi untuk mengembalikan nombor N digit terkecil yang merupakan pelbagai 5; Kod pemacu", "code": "< ? php function smallestMultiple ( $ n ) { if ( $ n == 1 ) return 5 ; return pow ( 10 , $ n - 1 ) ; } $ n = 4 ; echo smallestMultiple ( $ n ) ; ? >"}
{"text": "Cari HCF dua nombor tanpa menggunakan algoritma rekursi atau Euclidean | Berfungsi untuk mengembalikan HCF X dan Y; Minimum dua nombor; Jika kedua -dua nombor itu boleh dibahagikan dengan minimum kedua -dua maka HCF adalah sama dengan minimum; Nombor tertinggi antara 2 dan minimum / 2 yang boleh membahagikan kedua -dua nombor adalah HCF yang diperlukan; Jika kedua -dua nombor itu boleh dibahagikan dengan i; 1 membahagikan setiap nombor; Kod pemacu", "code": "< ? php function getHCF ( $ x , $ y ) { $ minimum = min ( $ x , $ y ) ; if ( $ x % $ minimum == 0 && $ y % $ minimum == 0 ) return $ minimum ; for ( $ i = $ minimum / 2 ; $ i >= 2 ; $ i -- ) { if ( $ x % $ i == 0 && $ y % $ i == 0 ) return $ i ; } return 1 ; } $ x = 16 ; $ y = 32 ; echo ( getHCF ( $ x , $ y ) ) ; ? >"}
{"text": "Periksa sama ada produk nombor semulajadi n pertama boleh dibahagikan dengan jumlah mereka | Fungsi yang pulih benar jika n adalah perdana; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika produk nombor semulajadi N pertama boleh dibahagikan dengan jumlah nombor semulajadi n pertama; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function isDivisible ( $ n ) { if ( isPrime ( $ n + 1 ) ) return false ; return true ; } $ n = 6 ; if ( isDivisible ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Jumlah maksimum kaca koktel dalam matriks 2D | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan jumlah maksimum kaca koktel; Jika tiada kaca koktel yang mungkin; Memulakan max_sum dengan mini; Di sini gelung berjalan (r - 2) * (c - 2) kali mempertimbangkan sel kiri atas gelas koktel yang berbeza; Memandangkan Mat [i] [j] sebagai sel kiri atas kaca koktel; Kemas kini max_sum; Kod pemacu", "code": "< ? php $ R = 5 ; $ C = 5 ; function findMaxCock ( $ ar ) { global $ R , $ C ; if ( $ R < 3 $ C < 3 ) return -1 ; $ max_sum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ R - 2 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C - 2 ; $ j ++ ) { $ sum = ( $ ar [ $ i ] [ $ j ] + $ ar [ $ i ] [ $ j + 2 ] ) + ( $ ar [ $ i + 1 ] [ $ j + 1 ] ) + ( $ ar [ $ i + 2 ] [ $ j ] + $ ar [ $ i + 2 ] [ $ j + 1 ] + $ ar [ $ i + 2 ] [ $ j + 2 ] ) ; $ max_sum = max ( $ max_sum , $ sum ) ; } } return $ max_sum ; } $ ar = array ( array ( 0 , 3 , 0 , 6 , 0 ) , array ( 0 , 1 , 1 , 0 , 0 ) , array ( 1 , 1 , 1 , 0 , 0 ) , array ( 0 , 0 , 2 , 0 , 1 ) , array ( 0 , 2 , 0 , 1 , 3 ) ) ; echo ( findMaxCock ( $ ar ) ) ; ? >"}
{"text": "Cari bilangan sub susunan dalam permutasi nombor semulajadi n pertama supaya median mereka adalah m | Fungsi untuk mengembalikan kiraan sub -tatasusunan dalam permutasi yang diberikan bagi nombor semulajadi n pertama supaya median mereka adalah m; Jika elemen kurang daripada m; Jika elemen lebih besar daripada m; Jika m dijumpai; Mengira jawapannya; Jumlah kenaikan; Kod pemacu", "code": "< ? php function segments ( $ n , $ p , $ m ) { $ c = array ( ) ; $ c [ 0 ] = 1 ; $ has = false ; $ sum = 0 ; $ ans = 0 ; for ( $ r = 0 ; $ r < $ n ; $ r ++ ) { if ( $ p [ $ r ] < $ m ) $ sum -- ; else if ( $ p [ $ r ] > $ m ) $ sum ++ ; if ( $ p [ $ r ] == $ m ) $ has = true ; if ( $ has ) $ ans += $ c [ $ sum ] + $ c [ $ sum - 1 ] ; else $ c [ $ sum ] ++ ; } return $ ans ; } $ a = array ( 2 , 4 , 5 , 3 , 1 ) ; $ n = count ( $ a ) ; $ m = 4 ; echo segments ( $ n , $ a , $ m ) ; ? >"}
{"text": "Program untuk mengira bilangan hari ganjil dalam bilangan tahun yang diberikan | Berfungsi untuk mengembalikan kiraan hari ganjil; Kiraan tahun dibahagikan dengan 100 dan 400; Setiap tahun ke -4 adalah tahun lompat; Setiap tahun ke -100 boleh dibahagikan dengan 4 tetapi bukan tahun lompat; Setiap tahun ke -400 boleh dibahagikan dengan 100 tetapi merupakan tahun lompat; Jumlah hari tambahan; Modulo (7) untuk jawapan akhir; Bilangan hari", "code": "< ? php function oddDays ( $ N ) { $ hund1 = floor ( $ N / 100 ) ; $ hund4 = floor ( $ N / 400 ) ; $ leap = $ N >> 2 ; $ ord = $ N - $ leap ; if ( $ hund1 ) { $ ord += $ hund1 ; $ leap -= $ hund1 ; } if ( $ hund4 ) { $ ord -= $ hund4 ; $ leap += $ hund4 ; } $ days = $ ord + $ leap * 2 ; $ odd = $ days % 7 ; return $ odd ; } $ N = 100 ; echo oddDays ( $ N ) ; ? >"}
{"text": "Ellips terbesar yang boleh ditulis dalam segi empat tepat yang seterusnya ditulis dalam separuh bulatan | Berfungsi untuk mencari kawasan elips terbesar; Radius tidak boleh negatif; kawasan elips; Kod pemacu", "code": "< ? php function ellipsearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( 3.14 * $ r * $ r ) / 4 ; return $ a ; } $ r = 5 ; echo ellipsearea ( $ r ) . \" STRNEWLINE \" ; ? >"}
{"text": "Kira semua awalan array binari yang diberikan yang boleh dibahagikan dengan x | Fungsi untuk mengembalikan kiraan awalan binari total yang boleh dibahagikan dengan x; Inisialisasi dengan sifar; Tukar semua awalan ke perpuluhan; Jika nombor dibahagikan dengan x maka tambah kiraan; Kod pemacu", "code": "< ? php function CntDivbyX ( $ arr , $ n , $ x ) { $ number = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ number = $ number * 2 + $ arr [ $ i ] ; if ( ( $ number % $ x == 0 ) ) $ count += 1 ; } return $ count ; } $ arr = array ( 1 , 0 , 1 , 0 , 1 , 1 , 0 ) ; $ n = sizeof ( $ arr ) ; $ x = 2 ; echo CntDivbyX ( $ arr , $ n , $ x ) ;"}
{"text": "Kira pasangan berturut -turut elemen yang sama | Berfungsi untuk mengembalikan kiraan unsur berturut -turut dalam array yang sama; Jika elemen berturut -turut adalah sama; Kod pemacu", "code": "< ? php function countCon ( $ ar , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ ar [ $ i ] == $ ar [ $ i + 1 ] ) $ cnt ++ ; } return $ cnt ; } $ ar = array ( 1 , 2 , 2 , 3 , 4 , 4 , 5 , 5 , 5 , 5 ) ; $ n = sizeof ( $ ar ) ; echo countCon ( $ ar , $ n ) ; ? >"}
{"text": "Kurangkan pecahan ke bentuk terendahnya | Berfungsi untuk mengurangkan pecahan ke bentuk terendahnya; Kod pemacu", "code": "< ? php function reduceFraction ( $ x , $ y ) { $ d ; $ d = __gcd ( $ x , $ y ) ; $ x = $ x / $ d ; $ y = $ y / $ d ; echo ( \" x ▁ = ▁ \" . $ x . \" , y = \" } function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } $ x = 16 ; $ y = 10 ; reduceFraction ( $ x , $ y ) ; ? >"}
{"text": "Masa yang diperlukan oleh minat mudah untuk prinsipal untuk menjadi masa y sendiri | Berfungsi untuk mengembalikan no. tahun; Kod pemacu", "code": "< ? php function noOfYears ( $ t1 , $ n1 , $ t2 ) { $ years = ( ( $ t2 - 1 ) * $ n1 / ( $ t1 - 1 ) ) ; return $ years ; } $ T1 = 3 ; $ N1 = 5 ; $ T2 = 6 ; print ( noOfYears ( $ T1 , $ N1 , $ T2 ) ) ; ? >"}
{"text": "Semak jika nombor tertentu membahagikan jumlah faktorial digitnya | Fungsi yang kembali benar jika n membahagikan jumlah faktorial digitnya; Untuk menyimpan faktorial digit; Untuk menyimpan jumlah faktorial digit; Simpan salinan nombor yang diberikan; Simpan jumlah faktorial digit; Jika ia boleh dibahagikan; Kod pemacu", "code": "< ? php function isPossible ( $ n ) { $ fac = array ( ) ; $ fac [ 0 ] = $ fac [ 1 ] = 1 ; for ( $ i = 2 ; $ i < 10 ; $ i ++ ) $ fac [ $ i ] = $ fac [ $ i - 1 ] * $ i ; $ sum = 0 ; $ x = $ n ; while ( $ x ) { $ sum += $ fac [ $ x % 10 ] ; $ x /= 10 ; } if ( $ sum % $ n == 0 ) return true ; return false ; } $ n = 19 ; if ( isPossible ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cari seterusnya yang paling lama dari array yang mempunyai LCM paling banyak k | Berfungsi untuk mencari berikutnya yang paling lama yang mempunyai LCM kurang daripada atau sama dengan k; Peta untuk menyimpan elemen unik dan frekuensi mereka; Mengemas kini frekuensi; Array untuk menyimpan kiraan nombor yang 1 <= x <= k adalah pelbagai; Semak setiap elemen unik; Cari semua gandaannya <= k; Menyimpan kekerapannya; Dapatkan nombor yang mempunyai kiraan maksimum; Keadaan untuk memeriksa sama ada jawapan tidak wujud; Cetak jawapannya; Kod pemacu", "code": "< ? php function findSubsequence ( $ arr , $ n , $ k ) { $ M = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ M [ $ arr [ $ i ] ] = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) ++ $ M [ $ arr [ $ i ] ] ; $ numCount = array ( ) ; for ( $ i = 0 ; $ i <= $ k ; ++ $ i ) $ numCount [ $ i ] = 0 ; foreach ( $ M as $ key = > $ value ) { if ( $ key <= $ k ) { for ( $ i = 1 ; ; ++ $ i ) { if ( $ key * $ i > $ k ) break ; $ numCount [ $ key * $ i ] += $ value ; } } else break ; } $ lcm = 0 ; $ length = 0 ; for ( $ i = 1 ; $ i <= $ k ; ++ $ i ) { if ( $ numCount [ $ i ] > $ length ) { $ length = $ numCount [ $ i ] ; $ lcm = $ i ; } } if ( $ lcm == 0 ) echo - 1 << \" STRNEWLINE \" ; else { echo \" LCM = \" , ▁ $ lcm , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" , Length = \" , ▁ $ length , ▁ \" \" ; STRNEWLINE TABSYMBOL TABSYMBOL echo ▁ \" Indexes = \" for ( $ i = 0 ; $ i < $ n ; ++ $ i ) if ( $ lcm % $ arr [ $ i ] == 0 ) echo $ i , \" ▁ \" ; } } $ k = 14 ; $ arr = array ( 2 , 3 , 4 , 5 ) ; $ n = count ( $ arr ) ; findSubsequence ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Kiraan bilangan rentetan binari panjang n yang mempunyai hanya 0 dan 1 's | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); $ x = $ x % $ p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; Fungsi untuk mengira bilangan rentetan binari panjang n yang mempunyai hanya 0 dan 1 's; Kod pemacu", "code": "< ? php function power ( $ x , $ y ) { $ p = 1000000007 ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function findCount ( $ N ) { $ count = power ( 2 , $ N ) ; return $ count ; } $ N = 25 ; echo findCount ( $ N ) ; ? >"}
{"text": "Xor semua elemen dalam julat yang diberikan [l, r] | Berfungsi untuk mengembalikan bit yang paling penting; Berfungsi untuk mengembalikan XOR yang diperlukan; Mencari MSB; Nilai bit semasa yang akan ditambah; Untuk menyimpan jawapan terakhir; Gelung untuk kes 1; Kes kelebihan apabila kedua -dua bilangan bulat terletak dalam segmen yang sama 1 s; Untuk menyimpan sama ada pariti kiraan adalah ganjil; Mengemas kini jawapan jika pariti ganjil; Mengemas kini nombor yang akan ditambah; Kes 2; Kod pemacu; Jawapan terakhir", "code": "< ? php function msb ( $ x ) { $ ret = 0 ; while ( ( $ x >> ( $ ret + 1 ) ) != 0 ) $ ret ++ ; return $ ret ; } function xorRange ( $ l , $ r ) { $ max_bit = msb ( $ r ) ; $ mul = 2 ; $ ans = 0 ; for ( $ i = 1 ; $ i <= $ max_bit ; $ i ++ ) { if ( ( int ) ( ( $ l / $ mul ) * $ mul ) == ( int ) ( ( $ r / $ mul ) * $ mul ) ) { if ( ( ( $ l & ( 1 << $ i ) ) != 0 ) && ( $ r - $ l + 1 ) % 2 == 1 ) $ ans += $ mul ; $ mul *= 2 ; continue ; } $ odd_c = 0 ; if ( ( ( $ l & ( 1 << $ i ) ) != 0 ) && $ l % 2 == 1 ) $ odd_c = ( $ odd_c ^ 1 ) ; if ( ( ( $ r & ( 1 << $ i ) ) != 0 ) && $ r % 2 == 0 ) $ odd_c = ( $ odd_c ^ 1 ) ; if ( $ odd_c ) $ ans += $ mul ; $ mul *= 2 ; } $ zero_bit_cnt = ( int ) ( ( $ r - $ l + 1 ) / 2 ) ; if ( $ l % 2 == 1 && $ r % 2 == 1 ) $ zero_bit_cnt ++ ; if ( $ zero_bit_cnt % 2 == 1 ) $ ans ++ ; return $ ans ; } $ l = 1 ; $ r = 4 ; echo xorRange ( $ l , $ r ) ; ? >"}
{"text": "Xor semua elemen dalam julat yang diberikan [l, r] | Berfungsi untuk mengembalikan XOR yang diperlukan; Operator modulus mahal di kebanyakan komputer. N & 3 akan bersamaan dengan N % 4 N % 4; Jika n adalah pelbagai 4; Jika n % 4 memberikan selebihnya 1; Jika n % 4 memberikan sisa 2; Jika n % 4 memberikan selebihnya 3; Kod pemacu", "code": "< ? php function computeXOR ( $ n ) { $ x = $ n & 3 ; switch ( $ x ) { case 0 : return $ n ; case 1 : return 1 ; case 2 : return $ n + 1 ; case 3 : return 0 ; } return 0 ; } $ l = 1 ; $ r = 4 ; echo ( computeXOR ( $ r ) ^ computeXOR ( $ l - 1 ) ) ; ? >"}
{"text": "Cari bilangan bilangan bulat dari 1 hingga n yang mengandungi digit 0 dan 1 's sahaja | Fungsi untuk mencari bilangan bilangan bulat dari 1 hingga n yang mengandungi 0 dan 1 's sahaja; Jika nombor lebih besar daripada n; Jika tidak, tambah kiraan nombor ini dan hubungi dua fungsi; Kod pemacu", "code": "< ? php function countNumbers ( $ x , $ n ) { if ( $ x > $ n ) return 0 ; return 1 + countNumbers ( $ x * 10 , $ n ) + countNumbers ( $ x * 10 + 1 , $ n ) ; } $ n = 120 ; echo ( countNumbers ( 1 , $ n ) ) ; ? >"}
{"text": "Semak jika faktorial n boleh dibahagikan dengan jumlah kuadrat nombor semulajadi n pertama | Berfungsi untuk mengira bilangan kali utama p membahagikan faktorial n; Formula Lengendre; Fungsi untuk mencari bilangan kiraan semua PRIME P BAHAWA SUMMATION; Formula untuk penjumlahan persegi selepas mengeluarkan N dan tetap 6; Gelung untuk melintasi semua perdana p yang membahagikan penjumlahan; Jika nombor itu sendiri adalah nombor perdana; Kod pemacu", "code": "< ? php function checkfact ( $ N , $ countprime , $ prime ) { $ countfact = 0 ; if ( $ prime == 2 $ prime == 3 ) $ countfact ++ ; $ divide = $ prime ; while ( ( int ) ( $ N / $ divide ) != 0 ) { $ countfact += ( int ) ( $ N / $ divide ) ; $ divide = $ divide * $ divide ; } if ( $ countfact >= $ countprime ) return true ; else return false ; } function check ( $ N ) { $ sumsquares = ( $ N + 1 ) * ( 2 * $ N + 1 ) ; $ countprime = 0 ; for ( $ i = 2 ; $ i <= sqrt ( $ sumsquares ) ; $ i ++ ) { $ flag = 0 ; while ( $ sumsquares % $ i == 0 ) { $ flag = 1 ; $ countprime ++ ; $ sumsquares = ( int ) ( $ sumsquares / $ i ) ; } if ( $ flag == 1 ) { if ( checkfact ( $ N - 1 , $ countprime , $ i ) ) return false ; $ countprime = 0 ; } } if ( $ sumsquares != 1 ) if ( checkfact ( $ N - 1 , 1 , $ sumsquares ) ) return false ; return true ; } $ N = 5 ; if ( check ( $ N ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Kira bilangan bukan | Program PHP untuk mengira bilangan subarrays yang tidak meningkat; Memulakan hasil; Memulakan panjang subarray yang tidak meningkat semasa; Melintasi array; Jika arr [i + 1] kurang daripada atau sama dengan arr [i], maka panjang kenaikan; Lain mengemas kini kiraan dan set semula; Jika panjang terakhir adalah lebih daripada 1; Kod pemacu", "code": "< ? php function countNonIncreasing ( $ arr , $ n ) { $ cnt = 0 ; $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ arr [ $ i + 1 ] <= $ arr [ $ i ] ) $ len ++ ; else { $ cnt += ( ( $ len + 1 ) * $ len ) / 2 ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( $ len + 1 ) * $ len ) / 2 ; return $ cnt ; } $ arr = array ( 5 , 2 , 3 , 7 , 1 , 1 ) ; $ n = sizeof ( $ arr ) ; echo countNonIncreasing ( $ arr , $ n ) ; ? >"}
{"text": "Cari permutasi yang baik dari nombor semulajadi n pertama | Berfungsi untuk mencetak permutasi yang baik bagi nombor semulajadi n pertama; Jika n adalah ganjil; Jika tidak; Kod pemacu", "code": "< ? php function printPermutation ( $ n ) { if ( $ n % 2 != 0 ) { echo ( \" - 1\" ) ; } else for ( $ i = 1 ; $ i <= $ n / 2 ; $ i ++ ) { echo ( 2 * $ i . \" ▁ \" . ( ( 2 * $ i ) - 1 ) . \" ▁ \" ) ; } return $ n ; } $ n = 4 ; printPermutation ( $ n ) ; ? >"}
{"text": "Operasi bilangan minimum diperlukan untuk menukar n ke m | Set | Pelaksanaan PHP pendekatan di atas; Berfungsi untuk mencari bilangan langkah minimum; Jika n melebihi m; Jika n mencapai sasaran; Minimum kedua -dua negeri akan menjadi jawapannya; Kod pemacu", "code": "< ? php $ MAXN = 10000000 ; function minimumSteps ( $ n , $ m , $ a , $ b ) { global $ MAXN ; if ( $ n > $ m ) return $ MAXN ; if ( $ n == $ m ) return 0 ; return min ( 1 + minimumSteps ( $ n * $ a , $ m , $ a , $ b ) , 1 + minimumSteps ( $ n * $ b , $ m , $ a , $ b ) ) ; } $ n = 120 ; $ m = 51840 ; $ a = 2 ; $ b = 3 ; echo minimumSteps ( $ n , $ m , $ a , $ b ) ; ? >"}
{"text": "Bilangan minimum operasi yang diberikan diperlukan untuk menukar n ke m | Berfungsi untuk mengembalikan operasi minimum yang diperlukan; Mengira semua 2 s; Mengira semua 3 s; Jika Q mengandungi hanya 2 dan 3 sebagai satu -satunya faktor utama maka ia mestilah 1 sekarang; Kod pemacu", "code": "< ? php function minOperations ( $ n , $ m ) { if ( $ m % $ n != 0 ) return -1 ; $ minOperations = 0 ; $ q = $ m / $ n ; while ( $ q % 2 == 0 ) { $ q = $ q / 2 ; $ minOperations ++ ; } while ( $ q % 3 == 0 ) { $ q = $ q / 3 ; $ minOperations ++ ; } if ( $ q == 1 ) return $ minOperations ; return -1 ; } $ n = 120 ; $ m = 51840 ; echo ( minOperations ( $ n , $ m ) ) ; ? >"}
{"text": "Jumlah nombor Fibonacci dalam julat | Berfungsi untuk mengembalikan nombor Nth Fibonacci; Berfungsi untuk mengembalikan jumlah yang diperlukan; Untuk menyimpan jumlahnya; Kirakan jumlahnya; Kod pemacu", "code": "< ? php function fib ( $ n ) { $ phi = ( 1 + sqrt ( 5 ) ) / 2 ; return ( int ) round ( pow ( $ phi , $ n ) / sqrt ( 5 ) ) ; } function calculateSum ( $ l , $ r ) { $ sum = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) $ sum += fib ( $ i ) ; return $ sum ; } $ l = 4 ; $ r = 8 ; echo calculateSum ( $ l , $ r ) ; ? >"}
{"text": "Sfera terbesar yang boleh ditulis dalam kiub yang pada gilirannya tertulis dalam kerucut pekeliling yang betul | Berfungsi untuk mencari jejari sfera; Ketinggian dan jejari tidak boleh negatif; jejari sfera; Kod pemacu", "code": "< ? php function sphereSide ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ R = ( ( $ h * $ r * sqrt ( 2 ) ) / ( $ h + sqrt ( 2 ) * $ r ) ) / 2 ; return $ R ; } $ h = 5 ; $ r = 6 ; echo ( sphereSide ( $ h , $ r ) ) ; ? >"}
{"text": "Cari bilangan cara untuk membahagikan nombor ke dalam empat bahagian supaya A = C dan B = D | Fungsi untuk mencari bilangan cara untuk membahagikan n ke dalam empat bahagian sehingga A = C dan B = D; Kod pemacu", "code": "< ? php function possibleways ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; else if ( $ n % 4 == 0 ) return $ n / 4 - 1 ; else return $ n / 4 ; } $ n = 20 ; echo possibleways ( $ n ) ; ? >"}
{"text": "Count sub | Fungsi untuk mengira sub -tatasus yang produknya boleh dibahagikan oleh k; Kirakan produk sub -array semasa; Jika produk sub -array semasa boleh dibahagikan oleh k; Kod pemacu", "code": "< ? php function countSubarrays ( $ arr , $ n , $ K ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ product = 1 ; for ( $ x = $ i ; $ x <= $ j ; $ x ++ ) $ product *= $ arr [ $ x ] ; if ( $ product % $ K == 0 ) $ count ++ ; } } return $ count ; } $ arr = array ( 6 , 2 , 8 ) ; $ n = count ( $ arr ) ; $ K = 4 ; echo countSubarrays ( $ arr , $ n , $ K ) ; ? >"}
{"text": "Cari pasangan dari array yang diberikan dengan nilai NCR maksimum | Fungsi untuk mencetak pasangan yang memberikan NCR maksimum; Ini memberikan nilai N dalam NCR; Kes 1: Apabila N adalah ganjil; Kes 2: Apabila N adalah walaupun; Kod pemacu", "code": "< ? php function printMaxValPair ( $ v , $ n ) { sort ( $ v ) ; $ N = $ v [ $ n - 1 ] ; if ( $ N % 2 == 1 ) { $ first_maxima = $ N / 2 ; $ second_maxima = $ first_maxima + 1 ; $ ans1 = 3e18 ; $ ans2 = 3e18 ; $ from_left = -1 ; $ from_right = -1 ; $ from = -1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ v [ $ i ] > $ first_maxima ) { $ from = $ i ; break ; } else { $ diff = $ first_maxima - $ v [ $ i ] ; if ( $ diff < $ ans1 ) { $ ans1 = $ diff ; $ from_left = $ v [ $ i ] ; } } } $ from_right = $ v [ $ from ] ; $ diff1 = $ first_maxima - $ from_left ; $ diff2 = $ from_right - $ second_maxima ; if ( $ diff1 < $ diff2 ) echo $ N . \" ▁ \" . $ from_left ; else echo $ N . \" ▁ \" . $ from_right ; } else { $ maxima = $ N / 2 ; $ ans1 = 3e18 ; $ R = -1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { $ diff = abs ( $ v [ $ i ] - $ maxima ) ; if ( $ diff < $ ans1 ) { $ ans1 = $ diff ; $ R = $ v [ $ i ] ; } } echo $ N . \" ▁ \" . $ R ; } } $ v = array ( 1 , 1 , 2 , 3 , 6 , 1 ) ; $ n = count ( $ v ) ; printMaxValPair ( $ v , $ n ) ; ? >"}
{"text": "Cari bilangan permutasi yang baik | Berfungsi untuk mengembalikan kiraan permutasi yang baik; Untuk m = 0, ANS adalah 1; Jika k lebih besar daripada 1; Jika k lebih besar daripada 2; Jika k lebih besar daripada 3; Kod pemacu", "code": "< ? php function Permutations ( $ n , $ k ) { $ ans = 1 ; if ( $ k >= 2 ) $ ans += ( $ n ) * ( $ n - 1 ) / 2 ; if ( $ k >= 3 ) $ ans += ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * 2 / 6 ; if ( $ k >= 4 ) $ ans += ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) * 9 / 24 ; return $ ans ; } $ n = 5 ; $ k = 2 ; echo ( Permutations ( $ n , $ k ) ) ; ? >"}
{"text": "Hitung bilangan bulat dalam julat yang boleh dibahagikan dengan nilai tat uler mereka | Berfungsi untuk mengembalikan A ^ n; Fungsi untuk mengembalikan kiraan bilangan bulat yang memenuhi n % phi (n) = 0; Kod pemacu", "code": "< ? php function power ( $ a , $ n ) { if ( $ n == 0 ) return 1 ; $ p = power ( $ a , $ n / 2 ) ; $ p = $ p * $ p ; if ( $ n & 1 ) $ p = $ p * $ a ; return $ p ; } function countIntegers ( $ l , $ r ) { $ ans = 0 ; $ i = 1 ; $ v = power ( 2 , $ i ) ; while ( $ v <= $ r ) { while ( $ v <= $ r ) { if ( $ v >= $ l ) $ ans ++ ; $ v = $ v * 3 ; } $ i ++ ; $ v = power ( 2 , $ i ) ; } if ( $ l == 1 ) $ ans ++ ; return $ ans ; } $ l = 12 ; $ r = 21 ; echo countIntegers ( $ l , $ r ) ; ? >"}
{"text": "Bilangan pasangan dari nombor semulajadi n pertama yang jumlahnya boleh dibahagikan dengan k | Fungsi untuk mencari bilangan pasangan dari set nombor semulajadi sehingga N yang jumlahnya dapat dibahagikan dengan k; Mengisytiharkan hash untuk menyimpan kiraan; Menyimpan kiraan bilangan bulat dengan selebihnya dalam pelbagai hash; Semak sama ada k ada; Count pasangan apabila kedua -dua bilangan bulat boleh dibahagikan dengan k; Count pasangan apabila satu baki adalah R dan selebihnya adalah k - r; Kiraan pasangan apabila kedua -dua baki adalah k / 2; Count pasangan apabila kedua -dua bilangan bulat boleh dibahagikan dengan k; Count pasangan apabila satu baki adalah R dan selebihnya adalah k - r; Kod pemacu; Cetak kiraan pasangan", "code": "< ? php function findPairCount ( $ N , $ K ) { $ count = 0 ; $ rem = array ( 0 , $ K , NULL ) ; $ rem [ 0 ] = intval ( $ N / $ K ) ; for ( $ i = 1 ; $ i < $ K ; $ i ++ ) $ rem [ $ i ] = intval ( ( $ N - $ i ) / $ K ) + 1 ; if ( $ K % 2 == 0 ) { $ count += ( $ rem [ 0 ] * intval ( ( $ rem [ 0 ] - 1 ) ) / 2 ) ; for ( $ i = 1 ; $ i < intval ( $ K / 2 ) ; $ i ++ ) $ count += $ rem [ $ i ] * $ rem [ $ K - $ i ] ; $ count += ( $ rem [ intval ( $ K / 2 ) ] * intval ( ( $ rem [ intval ( $ K / 2 ) ] - 1 ) ) / 2 ) ; } else { $ count += ( $ rem [ 0 ] * intval ( ( $ rem [ 0 ] - 1 ) ) / 2 ) ; for ( $ i = 1 ; $ i <= intval ( $ K / 2 ) ; $ i ++ ) $ count += $ rem [ $ i ] * $ rem [ $ K - $ i ] ; } return $ count ; } $ N = 10 ; $ K = 4 ; echo findPairCount ( $ N , $ K ) ; ? >"}
{"text": "Cari jumlah semua prima yang boleh dipotong di bawah n | Pelaksanaan PHP pendekatan; Untuk memeriksa sama ada nombor adalah perdana atau tidak; Sieve of Eratosthenes berfungsi untuk mencari semua nombor utama; Berfungsi untuk mengembalikan jumlah semua prima yang boleh dipotong di bawah n; Untuk menyimpan jumlah yang diperlukan; Semak setiap nombor di bawah n; Semak dari kanan ke kiri; Jika nombor tidak perdana di mana -mana peringkat; Semak dari kiri ke kanan; Jika nombor tidak perdana di mana -mana peringkat; Jika bendera masih benar; Mengembalikan jumlah yang diperlukan; Kod pemacu", "code": "< ? php $ N = 10005 ; $ prime = array_fill ( 0 , $ N , true ) ; function sieve ( ) { global $ prime , $ N ; $ prime [ 1 ] = false ; $ prime [ 0 ] = false ; for ( $ i = 2 ; $ i < $ N ; $ i ++ ) if ( $ prime [ $ i ] ) for ( $ j = $ i * 2 ; $ j < $ N ; $ j += $ i ) $ prime [ $ j ] = false ; } function sumTruncatablePrimes ( $ n ) { global $ prime , $ N ; $ sum = 0 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ num = $ i ; $ flag = true ; while ( $ num ) { if ( ! $ prime [ $ num ] ) { $ flag = false ; break ; } $ num = ( int ) ( $ num / 10 ) ; } $ num = $ i ; $ power = 10 ; while ( ( int ) ( $ num / $ power ) ) { if ( ! $ prime [ $ num % $ power ] ) { $ flag = false ; break ; } $ power *= 10 ; } if ( $ flag ) $ sum += $ i ; } return $ sum ; } $ n = 25 ; sieve ( ) ; echo sumTruncatablePrimes ( $ n ) ; ? >"}
{"text": "Terkecil dan terbesar n | Berfungsi untuk mencetak dataran sempurna N - terkecil N - terkecil; N - Digit Sempurna Sempurna Square; N - Digit Perfect Square terbesar; Kod pemacu", "code": "< ? php function nDigitPerfectSquares ( $ n ) { echo pow ( ceil ( sqrt ( pow ( 10 , $ n - 1 ) ) ) , 2 ) , \" \" ; echo pow ( ceil ( sqrt ( pow ( 10 , $ n ) ) ) - 1 , 2 ) ; } $ n = 4 ; nDigitPerfectSquares ( $ n ) ; ? >"}
{"text": "Jejak maksimum mungkin untuk mana -mana sub | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan jejak maksimum yang mungkin untuk sub -matriks matriks yang diberikan; Kirakan jejak untuk setiap sub -matriks dengan sudut kiri atas di sel (r, s); Mengemas kini jejak maksimum; Mengembalikan jejak maksimum; Kod pemacu", "code": "< ? php $ N = 3 ; function MaxTraceSub ( $ mat ) { global $ N ; $ max_trace = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ r = $ i ; $ s = $ j ; $ trace = 0 ; while ( $ r < $ N && $ s < $ N ) { $ trace += $ mat [ $ r ] [ $ s ] ; $ r ++ ; $ s ++ ; $ max_trace = max ( $ trace , $ max_trace ) ; } } } return $ max_trace ; } $ mat = array ( array ( 10 , 2 , 5 ) , array ( 6 , 10 , 4 ) , array ( 2 , 7 , -10 ) ) ; print ( MaxTraceSub ( $ mat ) ) ; ? >"}
{"text": "Semak jika matriks boleh ditukar ke matriks lain dengan memindahkan sub persegi | Pelaksanaan PHP pendekatan; Fungsi yang dikembalikan jika Matrix1 boleh ditukar kepada Matrix2 dengan operasi yang diberikan; Melintasi semua pepenjuru bermula pada lajur pertama; Melintasi pepenjuru; Simpan unsur -unsur pepenjuru; Bergerak ke atas; Menyusun unsur -unsur; Semak jika mereka sama; Melintasi semua pepenjuru bermula pada baris terakhir; Melintasi pepenjuru; Menyimpan unsur pepenjuru; Menyusun semua elemen; Semak sama; Jika setiap elemen sepadan; Kod pemacu", "code": "< ? php $ n = 3 ; $ m = 3 ; function check ( $ a , $ b ) { global $ n , $ m ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ v1 = array ( ) ; $ v2 = array ( ) ; $ r = $ i ; $ col = 0 ; while ( $ r >= 0 && $ col < $ m ) { array_push ( $ v1 , $ a [ $ r ] [ $ col ] ) ; array_push ( $ v2 , $ b [ $ r ] [ $ col ] ) ; $ r -- ; $ col ++ ; } sort ( $ v1 ) ; sort ( $ v2 ) ; for ( $ i = 0 ; $ i < count ( $ v1 ) ; $ i ++ ) { if ( $ v1 [ $ i ] != $ v2 [ $ i ] ) return false ; } } for ( $ j = 1 ; $ j < $ m ; $ j ++ ) { $ v1 = array ( ) ; $ v2 = array ( ) ; $ r = $ n - 1 ; $ col = $ j ; while ( $ r >= 0 && $ col < $ m ) { array_push ( $ v1 , $ a [ $ r ] [ $ col ] ) ; array_push ( $ v2 , $ b [ $ r ] [ $ col ] ) ; $ r -- ; $ col ++ ; } sort ( $ v1 ) ; sort ( $ v2 ) ; for ( $ i = 0 ; $ i < count ( $ v1 ) ; $ i ++ ) { if ( $ v1 [ $ i ] != $ v2 [ $ i ] ) return false ; } } return true ; } $ a = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; $ b = array ( array ( 1 , 4 , 7 ) , array ( 2 , 5 , 6 ) , array ( 3 , 8 , 9 ) ) ; if ( check ( $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Digit terakhir produk dua nombor besar atau kecil (a * b) | Berfungsi untuk mencetak digit terakhir produk A * b; Kod pemacu", "code": "< ? php function lastDigit ( $ a , $ b ) { $ lastDig = ( ord ( $ a [ strlen ( $ a ) - 1 ] ) - 48 ) * ( ord ( $ b [ strlen ( $ b ) - 1 ] ) - 48 ) ; echo $ lastDig % 10 ; } $ a = \"1234567891233\" ; $ b = \"1234567891233156\" ; lastDigit ( $ a , $ b ) ; ? >"}
{"text": "Palindrome terkecil dan terbesar dengan digit N | Berfungsi untuk mencetak palindrome terkecil dan terbesar dengan digit N; Kod pemacu", "code": "< ? php function printPalindrome ( $ n ) { if ( $ n == 1 ) { echo \" Smallest ▁ Palindrome : ▁ 0 STRNEWLINE \" ; echo \" Largest ▁ Palindrome : ▁ 9\" ; } else { echo \" Smallest ▁ Palindrome : ▁ \" , pow ( 10 , $ n - 1 ) + 1 ; echo \" Largest Palindrome : \" pow ( 10 , $ n ) - 1 ; } } $ n = 4 ; printPalindrome ( $ n ) ; ? >"}
{"text": "Penambahan dua nombor tanpa penyebaran dibawa | Berfungsi untuk mencetak jumlah 2 nombor tanpa menyebarkan bawa; Terbalik a; Terbalik b; Menjana jumlah sejak panjang A dan B adalah sama, ambil salah satu daripada mereka. ; Ekstrak digit dari A dan B dan tambah; Sekiranya jumlah adalah digit tunggal; Jika jumlah bukan satu digit terbalik jumlah; Ekstrak digit dari jumlah dan tambah hasil; Kod pemacu", "code": "< ? php function printSum ( $ a , $ b ) { $ res = 0 ; $ temp1 = 0 ; $ temp2 = 0 ; while ( $ a != 0 ) { $ temp1 = $ temp1 * 10 + ( $ a % 10 ) ; $ a = ( int ) ( $ a / 10 ) ; } $ a = $ temp1 ; while ( $ b != 0 ) { $ temp2 = $ temp2 * 10 + ( $ b % 10 ) ; $ b = ( int ) ( $ b / 10 ) ; } $ b = $ temp2 ; while ( $ a != 0 ) { $ sum = ( $ a % 10 + $ b % 10 ) ; if ( ( int ) ( $ sum / 10 ) == 0 ) { $ res = $ res * 10 + $ sum ; } else { $ temp1 = 0 ; while ( $ sum != 0 ) { $ temp1 = $ temp1 * 10 + ( $ sum % 10 ) ; $ sum = ( int ) ( $ sum / 10 ) ; } $ sum = $ temp1 ; while ( $ sum != 0 ) { $ res = $ res * 10 + ( $ sum % 10 ) ; $ sum = ( int ) ( $ sum / 10 ) ; } } $ a = ( int ) ( $ a / 10 ) ; $ b = ( int ) ( $ b / 10 ) ; } return $ res ; } $ a = 7752 ; $ b = 8834 ; echo ( printSum ( $ a , $ b ) ) ; ? >"}
{"text": "Bilangan digit sebelum titik perpuluhan dalam pembahagian dua nombor | Berfungsi untuk mengembalikan bilangan digit sebelum perpuluhan dalam A / B; Nilai mutlak A / B; Jika keputusan adalah 0; Kiraan nombor digit dalam hasilnya; Mengembalikan kiraan digit yang diperlukan; Kod pemacu", "code": "< ? php function countDigits ( $ a , $ b ) { $ count = 0 ; $ p = abs ( $ a / $ b ) ; if ( $ p == 0 ) return 1 ; while ( $ p > 0 ) { $ count ++ ; $ p = ( int ) ( $ p / 10 ) ; } return $ count ; } $ a = 100 ; $ b = 10 ; echo countDigits ( $ a , $ b ) ; ? >"}
{"text": "Bilangan digit sebelum titik perpuluhan dalam pembahagian dua nombor | Berfungsi untuk mengembalikan bilangan digit sebelum perpuluhan dalam A / B; Mengembalikan kiraan digit yang diperlukan; Kod pemacu", "code": "< ? php function countDigits ( $ a , $ b ) { return floor ( log10 ( abs ( $ a ) ) - log10 ( abs ( $ b ) ) ) + 1 ; } $ a = 100 ; $ b = 10 ; echo countDigits ( $ a , $ b ) ; ? >"}
{"text": "Nombor ganjil terkecil dengan N digit | Berfungsi untuk mengembalikan nombor terkecil walaupun dengan digit N; Kod pemacu", "code": "< ? php function smallestOdd ( $ n ) { if ( $ n == 1 ) return 1 ; return pow ( 10 , $ n - 1 ) + 1 ; } $ n = 4 ; echo smallestOdd ( $ n ) ; ? >"}
{"text": "Terbesar dan ganjil n | Berfungsi untuk mencetak nombor N - digit terbesar dan ganjil; Kod pemacu", "code": "< ? php function findNumbers ( $ n ) { $ odd = pow ( 10 , $ n ) - 1 ; $ even = $ odd - 1 ; echo \" Even ▁ = ▁ $ even ▁ STRNEWLINE \" ; echo \" Odd ▁ = ▁ $ odd \" ; } $ n = 4 ; findNumbers ( $ n ) ; ? >"}
{"text": "Sub terpanjang | Berfungsi untuk mengembalikan panjang sub -panjang sub - array yang produk elemennya adalah 0; Kod pemacu", "code": "< ? php function longestSubArray ( $ arr , $ n ) { $ isZeroPresent = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == 0 ) { $ isZeroPresent = true ; break ; } } if ( $ isZeroPresent ) return $ n ; return 0 ; } $ arr = array ( 1 , 2 , 3 , 0 , 1 , 2 , 0 ) ; $ n = sizeof ( $ arr ) ; echo longestSubArray ( $ arr , $ n ) ; ? >"}
{"text": "Nombor terkecil dengan digit N | Berfungsi untuk mengembalikan nombor terkecil walaupun dengan digit N; Kod pemacu", "code": "< ? php function smallestEven ( $ n ) { if ( $ n == 1 ) return 0 ; return pow ( 10 , $ n - 1 ) ; } $ n = 4 ; echo smallestEven ( $ n ) ; ? >"}
{"text": "Memaksimumkan keuntungan apabila divisi oleh dua nombor mempunyai keuntungan yang berkaitan | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan keuntungan maksimum; min (x, y) * n / lcm (a, b); Kod pemacu", "code": "< ? php function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } function maxProfit ( $ n , $ a , $ b , $ x , $ y ) { $ res = $ x * ( $ n / $ a ) ; $ res += $ y * ( $ n / $ b ) ; $ res -= min ( $ x , $ y ) * ( $ n / ( ( $ a * $ b ) / __gcd ( $ a , $ b ) ) ) ; return $ res ; } $ n = 6 ; $ a = 6 ; $ b = 2 ; $ x = 8 ; $ y = 2 ; print ( maxProfit ( $ n , $ a , $ b , $ x , $ y ) ) ; ? >"}
{"text": "Summation Series Jika t (n) diberikan dan n sangat besar | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan jumlah siri yang diberikan; Kod pemacu", "code": "< ? php $ GLOBALS [ ' MOD ' ] = 1000000007 ; function sumOfSeries ( $ n ) { $ ans = pow ( $ n % $ GLOBALS [ ' MOD ' ] , 2 ) ; return ( $ ans % $ GLOBALS [ ' MOD ' ] ) ; } $ n = 10 ; echo sumOfSeries ( $ n ) ; ? >"}
{"text": "Nombor ganjil kth dalam array | Berfungsi untuk mengembalikan elemen ganjil kth dari array; Melintasi array; Jika elemen semasa ganjil; Jika elemen ganjil kth dijumpai; Jumlah elemen ganjil dalam array adalah <k; Kod pemacu", "code": "< ? php function kthOdd ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % 2 == 1 ) $ k -- ; if ( $ k == 0 ) return $ arr [ $ i ] ; } return -1 ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; echo ( kthOdd ( $ arr , $ n , $ k ) ) ; ? >"}
{"text": "Cari lima digit terakhir nombor lima digit yang dibangkitkan kepada Power Five | Berfungsi untuk mencari lima digit terakhir nombor lima digit yang dibangkitkan kepada Power Five; Kod pemacu", "code": "< ? php function lastFiveDigits ( $ n ) { $ n = ( int ) ( $ n / 10000 ) * 10000 + ( ( int ) ( $ n / 100 ) % 10 ) * 1000 + ( $ n % 10 ) * 100 + ( ( int ) ( $ n / 10 ) % 10 ) * 10 + ( int ) ( $ n / 1000 ) % 10 ; $ ans = 1 ; for ( $ i = 0 ; $ i < 5 ; $ i ++ ) { $ ans *= $ n ; $ ans %= 100000 ; } echo $ ans ; } $ n = 12345 ; lastFiveDigits ( $ n ) ; ? >"}
{"text": "Jumlah (elemen maksimum | PHP pelaksanaan pendekatan di atas; berfungsi untuk mengembalikan mod a ^ n %; mengira jumlah max (a) - min (a) untuk semua subset; sort array.; Maxs = 2 ^ i - 1; mins = 2 ^ (n - 1 - i) - 1;", "code": "< ? php $ mod = 1000000007 ; function power ( $ a , $ n ) { global $ mod ; if ( $ n == 0 ) return 1 ; $ p = power ( $ a , $ n / 2 ) % $ mod ; $ p = ( $ p * $ p ) % $ mod ; if ( $ n & 1 ) { $ p = ( $ p * $ a ) % $ mod ; } return $ p ; } function computeSum ( & $ arr , $ n ) { global $ mod ; sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ maxs = ( power ( 2 , $ i ) - 1 + $ mod ) % $ mod ; $ maxs = ( $ maxs * $ arr [ $ i ] ) % $ mod ; $ mins = ( power ( 2 , $ n - 1 - $ i ) - 1 + $ mod ) % $ mod ; $ mins = ( $ mins * $ arr [ $ i ] ) % $ mod ; $ V = ( $ maxs - $ mins + $ mod ) % $ mod ; $ sum = ( $ sum + $ V ) % $ mod ; } return $ sum ; } $ arr = array ( 4 , 3 , 1 ) ; $ n = sizeof ( $ arr ) ; echo computeSum ( $ arr , $ n ) ; ? >"}
{"text": "Kiraan semua nombor digit seperti num + rev (num) = 10 ^ n | Berfungsi untuk mengembalikan kiraan nombor tersebut; Jika n adalah ganjil; Kod pemacu", "code": "< ? php function countNumbers ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; return ( 9 * ( int ) pow ( 10 , $ n / 2 - 1 ) ) ; } $ n = 2 ; echo ( countNumbers ( $ n ) ) ;"}
{"text": "Kira nombor yang mempunyai hanya 1 set bit dalam julat [0, n] | Berfungsi untuk mengembalikan kiraan yang diperlukan; Untuk menyimpan kiraan nombor; Setiap kuasa 2 mengandungi hanya 1 set bit; Kod pemacu", "code": "< ? php function count_t ( $ n ) { $ cnt = 0 ; $ p = 1 ; while ( $ p <= $ n ) { $ cnt ++ ; $ p *= 2 ; } return $ cnt ; } $ n = 7 ; echo count_t ( $ n ) ; ? >"}
{"text": "Cari k | Fungsi untuk mencari elemen minimum k - th dari array concatenated m kali; Menyusun unsur -unsur dalam urutan menaik; Kembalikan elemen k 'th min yang hadir di indeks ((k-1) / m); Kod pemacu", "code": "< ? php function KthMinValAfterMconcatenate ( $ A , $ N , $ M , $ K ) { sort ( $ A ) ; return ( $ A [ ( ( $ K - 1 ) / $ M ) ] ) ; } $ A = array ( 3 , 1 , 2 ) ; $ M = 3 ; $ K = 4 ; $ N = sizeof ( $ A ) ; echo ( KthMinValAfterMconcatenate ( $ A , $ N , $ M , $ K ) ) ; ? >"}
{"text": "Jumlah semua saya seperti itu (2 ^ i + 1) % 3 = 0 di mana saya berada dalam julat [1, n] | Berfungsi untuk mengembalikan jumlah yang diperlukan; Jumlah nombor ganjil dari 1 hingga n; Jumlah nombor pertama yang pertama; Kod pemacu", "code": "< ? php function sumN ( $ n ) { $ n = ( int ) ( ( $ n + 1 ) / 2 ) ; return ( $ n * $ n ) ; } $ n = 3 ; echo sumN ( $ n ) ; ? >"}
{"text": "Nombor yang tidak dapat dibahagikan dengan mana -mana nombor dalam julat [2, 10] | Berfungsi untuk mengembalikan kiraan nombor dari 1 hingga N yang tidak dapat dibahagikan dengan mana -mana nombor dalam julat [2, 10]; Kod pemacu", "code": "< ? php function countNumbers ( $ n ) { return ( int ) ( $ n - $ n / 2 ) - ( int ) ( $ n / 3 ) - ( int ) ( $ n / 5 ) - ( int ) ( $ n / 7 ) + ( int ) ( $ n / 6 ) + ( int ) ( $ n / 10 ) + ( int ) ( $ n / 14 ) + ( int ) ( $ n / 15 ) + ( int ) ( $ n / 21 ) + ( int ) ( $ n / 35 ) - ( int ) ( $ n / 30 ) - ( int ) ( $ n / 42 ) - ( int ) ( $ n / 70 ) - ( int ) ( $ n / 105 ) + ( int ) ( $ n / 210 ) ; } $ n = 20 ; echo ( countNumbers ( $ n ) ) ; ? >"}
{"text": "Prima maksimum yang jumlahnya sama dengan diberikan n | Berfungsi untuk mencari kiraan maksimum prima; Jika n adalah n / 2 diperlukan jawapan jika n adalah lantai ganjil (n / 2) = (int) (n / 2) diperlukan jawapan; Kod pemacu", "code": "< ? php function maxPrimes ( $ n ) { return ( int ) ( $ n / 2 ) ; } $ n = 17 ; echo maxPrimes ( $ n ) ; ? >"}
{"text": "Jumlah siri (1 * 2) + (2 * 3) + (3 * 4) + ... ... sehingga terma | Berfungsi untuk mengembalikan jumlah; Kod pemacu", "code": "< ? php function sum ( $ n ) { return $ n * ( $ n + 1 ) * ( $ n + 2 ) / 3 ; } $ n = 2 ; echo sum ( $ n ) ; ? >"}
{"text": "Pembahagi terkecil d dari N sedemikian rupa sehingga GCD (d, m) lebih besar daripada 1 | Pelaksanaan PHP pendekatan di atas; Berfungsi untuk mencari pembahagi minimum; Berulang untuk semua faktor n; Semak GCD> 1; Semak GCD> 1; Jika GCD adalah m sendiri; Kod pemacu", "code": "< ? php function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } function findMinimum ( $ n , $ m ) { $ mini = $ m ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ sec = $ n / $ i ; if ( __gcd ( $ m , $ i ) > 1 ) { return $ i ; } else if ( __gcd ( $ sec , $ m ) > 1 ) { $ mini = min ( $ sec , $ mini ) ; } } } if ( $ mini == $ m ) return -1 ; else return $ mini ; } $ n = 8 ; $ m = 10 ; echo ( findMinimum ( $ n , $ m ) ) ;"}
{"text": "Cari istilah n Siri 1, 5, 32, 288 ... | Berfungsi untuk menjana nombor tetap; Mencari istilah n; Kod pemacu", "code": "< ? php function nthTerm ( $ N ) { $ nth = 0 ; $ i ; for ( $ i = $ N ; $ i > 0 ; $ i -- ) { $ nth += pow ( $ i , $ i ) ; } return $ nth ; } $ N = 3 ; echo ( nthTerm ( $ N ) ) ; ? >"}
{"text": "Cari kth bilangan terkecil dalam julat [1, n] apabila semua nombor ganjil dipadam | Berfungsi untuk mengembalikan elemen terkecil kth dari julat [1, n] selepas mengeluarkan semua elemen ganjil; Kod pemacu", "code": "< ? php function kthSmallest ( $ n , $ k ) { return ( 2 * $ k ) ; } $ n = 8 ; $ k = 4 ; echo ( kthSmallest ( $ n , $ k ) ) ; ? >"}
{"text": "Semak jika nombor boleh diwakili sebagai jumlah kuasa bukan sifar 2 | Fungsi yang kembali benar jika n boleh diwakili sebagai jumlah kuasa 2 tanpa menggunakan 2 ^ 0; Kod pemacu", "code": "< ? php function isSumOfPowersOfTwo ( $ n ) { if ( $ n % 2 == 1 ) return false ; else return true ; } $ n = 10 ; if ( isSumOfPowersOfTwo ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Kurangkan jumlah perbezaan bersebelahan dengan penyingkiran satu elemen dari array | Berfungsi untuk mencari elemen; Pembolehubah nilai untuk menyimpan jumlah nilai; Mengisytiharkan nilai maksimum sebagai sifar; Jika array mengandungi elemen; Menyimpan nilai maksimum dalam pembolehubah temp; Menambah nilai modulus perbezaan bersebelahan elemen yang dikeluarkan. Mengeluarkan nilai modulus perbezaan bersebelahan selepas mengeluarkan elemen; Kembalinya jumlah nilai - nilai maksimum; Kod pemandu", "code": "< ? php function findMinRemoval ( $ arr , $ n ) { $ value = 0 ; $ maximum = 0 ; if ( $ n == 1 ) return 0 ; $ temp = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i != 0 && $ i != $ n - 1 ) { $ value = $ value + abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; $ temp = abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) + abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) - abs ( $ arr [ $ i - 1 ] - $ arr [ $ i + 1 ] ) ; } else if ( $ i == 0 ) { $ value = $ value + abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; $ temp = abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; } else $ temp = abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ; $ maximum = max ( $ maximum , $ temp ) ; } return ( $ value - $ maximum ) ; } $ arr = array ( 1 , 5 , 3 , 2 , 10 ) ; $ n = count ( $ arr ) ; echo findMinRemoval ( $ arr , $ n ) ; ? >"}
{"text": "Masa sehingga jarak menjadi sama dengan x antara dua objek yang bergerak ke arah yang bertentangan | Berfungsi untuk mengembalikan masa yang mana kedua anggota polis dapat berkomunikasi; masa = jarak / kelajuan; Kod pemacu", "code": "< ? php function getTime ( $ u , $ v , $ x ) { $ speed = $ u + $ v ; $ time = $ x / $ speed ; return $ time ; } $ u = 3 ; $ v = 3 ; $ x = 3 ; echo getTime ( $ u , $ v , $ x ) ; ? >"}
{"text": "Memandangkan bilangan perlawanan yang dimainkan, cari bilangan pasukan dalam kejohanan | Berfungsi untuk mengembalikan bilangan pasukan; sqrt (b ^ 2 - 4 ac); Akar pertama ( - b + sqrt (b ^ 2 - 4 ac)) / 2 a; Akar kedua ( - b - sqrt (b ^ 2 - 4 ac)) / 2 a; Mengembalikan akar positif; Kod pemacu", "code": "< ? php function number_of_teams ( $ M ) { $ sqr = sqrt ( 1 + ( 8 * $ M ) ) ; $ N1 = ( 1 + $ sqr ) / 2 ; $ N2 = ( 1 - $ sqr ) / 2 ; if ( $ N1 > 0 ) return $ N1 ; return $ N2 ; } $ M = 45 ; echo number_of_teams ( $ M ) ; ? >"}
{"text": "Jumlah nombor dari 1 hingga N yang berada dalam urutan Lucas | Berfungsi untuk mengembalikan jumlah yang diperlukan; Menjana nombor Lucas dan terus menambahkannya; Kod pemacu", "code": "< ? php function LucasSum ( $ N ) { $ sum = 0 ; $ a = 2 ; $ b = 1 ; $ c ; $ sum += $ a ; while ( $ b <= $ N ) { $ sum += $ b ; $ c = $ a + $ b ; $ a = $ b ; $ b = $ c ; } return $ sum ; } $ N = 20 ; echo ( LucasSum ( $ N ) ) ; ? >"}
{"text": "Kira semua nombor dalam julat [l, r] yang jumlah digitnya boleh dibahagikan dengan 3 | Berfungsi untuk mengembalikan kiraan nombor yang diperlukan; Kiraan nombor dalam julat yang boleh dibahagikan dengan 6; Kod pemacu", "code": "< ? php function countNumbers ( $ l , $ r ) { return ( ( int ) ( $ r / 6 ) - ( int ) ( ( $ l - 1 ) / 6 ) ) ; } $ l = 1000 ; $ r = 6000 ; echo ( countNumbers ( $ l , $ r ) ) ; ? >"}
{"text": "Jumlah elemen minimum semua sub | Berfungsi untuk mencari jumlah minimum semua berikutnya; Kod pemacu", "code": "< ? php function findMinSum ( $ arr , $ n ) { $ occ1 = ( $ n ) ; $ occ = $ occ1 - 1 ; $ Sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ Sum += $ arr [ $ i ] * pow ( 2 , $ occ ) ; $ occ -= 1 ; } return $ Sum ; } $ arr = array ( 1 , 2 , 4 , 5 ) ; $ n = count ( $ arr ) ; echo findMinSum ( $ arr , $ n ) ; ? >"}
{"text": "Kira nombor dalam julat 1 hingga n yang boleh dibahagikan dengan x tetapi bukan oleh y | Fungsi untuk mengira jumlah jumlah yang boleh dibahagi dengan x tetapi tidak y dalam julat 1 hingga n; Semak jika nombor dibahagikan dengan x tetapi tidak y jika ya, kiraan kenaikan; Kod pemacu", "code": "< ? php function countNumbers ( $ X , $ Y , $ N ) { $ count = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( ( $ i % $ X == 0 ) && ( $ i % $ Y != 0 ) ) $ count ++ ; } return $ count ; } $ X = 2 ; $ Y = 3 ; $ N = 10 ; echo ( countNumbers ( $ X , $ Y , $ N ) ) ; ? >"}
{"text": "Kedudukan seseorang yang bertentangan dengan bulatan | Berfungsi untuk mengembalikan kedudukan yang diperlukan; Kod pemacu", "code": "< ? php function getPosition ( $ n , $ m ) { if ( $ m > ( $ n / 2 ) ) return ( $ m - ( $ n / 2 ) ) ; return ( $ m + ( $ n / 2 ) ) ; } $ n = 8 ; $ m = 5 ; echo getPosition ( $ n , $ m ) ; ? >"}
{"text": "Operasi minimum yang diperlukan untuk mengubah suai array supaya pariti unsur -unsur bersebelahan adalah berbeza | Berfungsi untuk mengembalikan pariti nombor; Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan; Operasi perlu dilakukan; Pariti elemen sebelumnya; Pariti elemen seterusnya; Mengemas kini pariti elemen semasa menjadi selain daripada pariti sebelumnya dan nombor seterusnya; Kod pemacu", "code": "< ? php function parity ( $ a ) { return $ a % 3 ; } function solve ( $ array , $ size ) { $ operations = 0 ; for ( $ i = 0 ; $ i < $ size - 1 ; $ i ++ ) { if ( parity ( $ array [ $ i ] ) == parity ( $ array [ $ i + 1 ] ) ) { $ operations ++ ; if ( $ i + 2 < $ size ) { $ pari1 = parity ( $ array [ $ i ] ) ; $ pari2 = parity ( $ array [ $ i + 2 ] ) ; if ( $ pari1 == $ pari2 ) { if ( $ pari1 == 0 ) $ array [ $ i + 1 ] = 1 ; else if ( $ pari1 == 1 ) $ array [ $ i + 1 ] = 0 ; else $ array [ $ i + 1 ] = 1 ; } else { if ( ( $ pari1 == 0 && $ pari2 == 1 ) || ( $ pari1 == 1 && $ pari2 == 0 ) ) $ array [ $ i + 1 ] = 2 ; if ( ( $ pari1 == 1 && $ pari2 == 2 ) || ( $ pari1 == 2 && $ pari2 == 1 ) ) $ array [ $ i + 1 ] = 0 ; if ( ( $ pari1 == 2 && $ pari2 == 0 ) || ( $ pari1 == 0 && $ pari2 == 2 ) ) $ array [ $ i + 1 ] = 1 ; } } } } return $ operations ; } $ array = array ( 2 , 1 , 3 , 0 ) ; $ size = count ( $ array ) ; echo solve ( $ array , $ size ) ; ? >"}
{"text": "Xor xors semua sub | Fungsi untuk mencari nilai XOR yang diperlukan; Gelung bersarang untuk mencari bilangan sub - matriks setiap indeks milik; Bilangan cara untuk memilih dari elemen kiri - kiri; Bilangan cara untuk memilih dari elemen bawah - kanan; Kod pemacu", "code": "< ? php function submatrixXor ( $ arr ) { $ ans = 0 ; $ n = 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ top_left = ( $ i + 1 ) * ( $ j + 1 ) ; $ bottom_right = ( $ n - $ i ) * ( $ n - $ j ) ; if ( ( $ top_left % 2 == 1 ) && ( $ bottom_right % 2 == 1 ) ) $ ans = ( $ ans ^ $ arr [ $ i ] [ $ j ] ) ; } } return $ ans ; } $ arr = array ( array ( 6 , 7 , 13 ) , array ( 8 , 3 , 4 ) , array ( 9 , 7 , 6 ) ) ; echo submatrixXor ( $ arr ) ; # This  code is contributed by Ryuga NEW_LINE ? >"}
{"text": "Cari nombor positif n yang akar digital adalah x | Berfungsi untuk mencari akar digital nombor; Berfungsi untuk mencari nombor nth dengan akar digital sebagai x; Pemboleh ubah kaunter untuk menyimpan kiraan nombor yang sah; Cari akar digital; Periksa sama ada jawapan yang diperlukan atau tidak; Cetak jawapan jika anda telah menemukannya dan pelarian gelung; Kod pemacu", "code": "< ? php function findDigitalRoot ( $ num ) { $ sum = PHP_INT_MAX ; $ tempNum = $ num ; while ( $ sum >= 10 ) { $ sum = 0 ; while ( $ tempNum > 0 ) { $ sum += $ tempNum % 10 ; $ tempNum /= 10 ; } $ tempNum = $ sum ; } return $ sum ; } function findAnswer ( $ X , $ N ) { $ counter = 0 ; for ( $ i = 1 ; $ counter < $ N ; ++ $ i ) { $ digitalRoot = findDigitalRoot ( $ i ) ; if ( $ digitalRoot == $ X ) { ++ $ counter ; } if ( $ counter == $ N ) { echo ( $ i ) ; break ; } } } $ X = 1 ; $ N = 3 ; findAnswer ( $ X , $ N ) ;"}
{"text": "Cari nombor positif n yang akar digital adalah x | Berfungsi untuk mencari nombor n - th dengan akar digital sebagai x; Kod pemacu", "code": "< ? php function findAnswer ( $ X , $ N ) { return ( $ N - 1 ) * 9 + $ X ; } $ X = 7 ; $ N = 43 ; echo ( findAnswer ( $ X , $ N ) ) ; ? >"}
{"text": "Jumlah nombor semulajadi (sehingga n) yang modulo dengan k yield r | Berfungsi untuk mengembalikan jumlah; Jika nombor semasa memberikan r sebagai selebihnya dibahagikan dengan k; Mengemas kini jumlah; Mengembalikan jumlahnya; Kod pemacu", "code": "< ? php function count1 ( $ N , $ K , $ R ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i % $ K == $ R ) $ sum += $ i ; } return $ sum ; } $ N = 20 ; $ K = 4 ; $ R = 3 ; echo count1 ( $ N , $ K , $ R ) ; ? >"}
{"text": "Cari bilangan penyelesaian kepada persamaan yang diberikan | Fungsi untuk mengembalikan kiraan nilai yang sah x; Berulang melalui semua jumlah digit x; Dapatkan nilai semasa x untuk jumlah digit I; Cari jumlah digit Cr; Jika CR adalah pilihan yang sah untuk x; Mengembalikan kiraan; Kod pemacu", "code": "< ? php function getCount ( $ a , $ b , $ c ) { $ count = 0 ; for ( $ i = 1 ; $ i <= 81 ; $ i ++ ) { $ cr = $ b * ( int ) pow ( $ i , $ a ) + $ c ; $ tmp = $ cr ; $ sm = 0 ; while ( $ tmp != 0 ) { $ sm += $ tmp % 10 ; $ tmp /= 10 ; } if ( $ sm == $ i && $ cr < 1e9 ) $ count ++ ; } return $ count ; } { $ a = 3 ; $ b = 2 ; $ c = 8 ; echo ( getCount ( $ a , $ b , $ c ) ) ; }"}
{"text": "Semak jika pelbagai 1 s dan 2 s boleh dibahagikan kepada 2 bahagian dengan jumlah yang sama | Fungsi untuk memeriksa sama ada mungkin untuk memecah array dalam dua bahagian dengan jumlah yang sama; Hitung jumlah elemen dan kiraan 1; Jika jumlah jumlahnya ganjil, kembali palsu; Jika jumlah setiap bahagian adalah, kembali benar; Jika jumlah setiap bahagian adalah tetapi ada atleast satu 1; Kod pemacu", "code": "< ? php function isSpiltPossible ( $ n , $ a ) { $ sum = 0 ; $ c1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; if ( $ a [ $ i ] == 1 ) { $ c1 ++ ; } } if ( $ sum % 2 != 0 ) return false ; if ( ( $ sum / 2 ) % 2 == 0 ) return true ; if ( $ c1 > 0 ) return true ; else return false ; } $ n = 3 ; $ a = array ( 1 , 1 , 2 ) ; if ( isSpiltPossible ( $ n , $ a ) ) echo ( \" YES \" ) ; else echo ( \" NO \" ) ; ? >"}
{"text": "Jumlah semua submatrik matriks yang diberikan | Berfungsi untuk mencari jumlah semua submatrik yang mungkin dari matriks yang diberikan; Pembolehubah untuk menyimpan jumlah yang diperlukan; Gelung bersarang untuk mencari bilangan submatrik, setiap nombor milik; Bilangan cara untuk memilih dari elemen kiri - kiri; Bilangan cara untuk memilih dari elemen bawah - kanan; Kod pemacu", "code": "< ? php function matrixSum ( $ arr ) { $ n = 3 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ top_left = ( $ i + 1 ) * ( $ j + 1 ) ; $ bottom_right = ( $ n - $ i ) * ( $ n - $ j ) ; $ sum += ( $ top_left * $ bottom_right * $ arr [ $ i ] [ $ j ] ) ; } return $ sum ; } $ arr = array ( array ( 1 , 1 , 1 ) , array ( 1 , 1 , 1 ) , array ( 1 , 1 , 1 ) ) ; echo matrixSum ( $ arr ) ; ? >"}
{"text": "Maksimum bitwise dan pasangan dari julat yang diberikan | Berfungsi untuk mengembalikan bitwise maksimum dan mungkin di antara semua pasangan yang mungkin; Maksimum di antara semua (i, j) pasangan; Kod pemacu", "code": "< ? php function maxAND ( $ L , $ R ) { $ maximum = $ L & $ R ; for ( $ i = $ L ; $ i < $ R ; $ i ++ ) for ( $ j = $ i + 1 ; $ j <= $ R ; $ j ++ ) $ maximum = max ( $ maximum , ( $ i & $ j ) ) ; return $ maximum ; } $ L = 1 ; $ R = 632 ; echo ( maxAND ( $ L , $ R ) ) ; ? >"}
{"text": "Pecahkan array ke dalam segmen segmen panjang ganjil | Berfungsi untuk memeriksa; Semak hasilnya dengan memproses elemen dan saiz pertama & terakhir; Kod pemacu", "code": "< ? php function checkArray ( $ arr , $ n ) { return ( $ arr [ 0 ] % 2 ) && ( $ arr [ $ n - 1 ] % 2 ) && ( $ n % 2 ) ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; echo checkArray ( $ arr , $ n ) ; ? >"}
{"text": "Penyingkiran minimum untuk membuat jumlah array ganjil | Fungsi untuk mencari penyingkiran minimum; Mengira nombor ganjil; Jika kaunter adalah pulangan ganjil 0 sebaliknya kembali 1; Kod pemacu", "code": "< ? php function findCount ( $ arr , $ n ) { $ countOdd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 == 1 ) $ countOdd ++ ; if ( $ countOdd % 2 == 0 ) return 1 ; else return 0 ; } $ arr = array ( 1 , 2 , 3 , 5 , 1 ) ; $ n = sizeof ( $ arr ) ; echo ( findCount ( $ arr , $ n ) ) ; ? >"}
{"text": "Semak sama ada nombor itu boleh dibuat persegi sempurna selepas menambah 1 | Fungsi yang kembali benar jika x adalah persegi yang sempurna; Cari nilai titik terapung akar persegi x; Jika akar persegi adalah integer; Fungsi yang pulih benar jika n adalah nombor yang cerah; Jika (n + 1) adalah persegi yang sempurna; Kod pemacu", "code": "< ? php function isPerfectSquare ( $ x ) { $ sr = sqrt ( $ x ) ; return ( ( $ sr - floor ( $ sr ) ) == 0 ) ; } function isSunnyNum ( $ n ) { if ( isPerfectSquare ( $ n + 1 ) ) return true ; return false ; } $ n = 3 ; if ( isSunnyNum ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Kira prima yang boleh dinyatakan sebagai jumlah dua prima berturut -turut dan 1 | Pelaksanaan PHP pendekatan; Untuk memeriksa sama ada nombor adalah perdana atau tidak; Untuk menyimpan nombor yang mungkin; Berfungsi untuk mengembalikan semua nombor perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat nombor IT yang berganda p dan kurang daripada p ^ 2 telah ditandakan. ; Fungsi untuk mengira semua kemungkinan nombor perdana yang boleh dinyatakan sebagai jumlah dua prima berturut -turut dan satu; Semua kemungkinan nombor perdana di bawah n; Kod pemacu", "code": "< ? php $ N = 10005 ; $ isprime = array_fill ( 0 , $ N , true ) ; $ can = array_fill ( 0 , $ N , false ) ; function SieveOfEratosthenes ( ) { global $ N , $ isprime ; for ( $ p = 2 ; $ p * $ p < $ N ; $ p ++ ) { if ( $ isprime [ $ p ] == true ) { for ( $ i = $ p * $ p ; $ i < $ N ; $ i += $ p ) $ isprime [ $ i ] = false ; } } $ primes = array ( ) ; for ( $ i = 2 ; $ i < $ N ; $ i ++ ) if ( $ isprime [ $ i ] ) array_push ( $ primes , $ i ) ; return $ primes ; } function Prime_Numbers ( $ n ) { global $ N , $ can , $ isprime ; $ primes = SieveOfEratosthenes ( ) ; for ( $ i = 0 ; $ i < count ( $ primes ) - 1 ; $ i ++ ) if ( $ primes [ $ i ] + $ primes [ $ i + 1 ] + 1 < $ N ) $ can [ $ primes [ $ i ] + $ primes [ $ i + 1 ] + 1 ] = true ; $ ans = 0 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ can [ $ i ] and $ isprime [ $ i ] ) { $ ans ++ ; } } return $ ans ; } $ n = 50 ; echo Prime_Numbers ( $ n ) ; ? >"}
{"text": "Jumlah bitwise dan semua subarrays | Berfungsi untuk mencari jumlah bitwise dan semua subarray; pembolehubah untuk menyimpan jumlah akhir; pengganda; Pembolehubah untuk memeriksa sama ada menghitung dihidupkan; pembolehubah untuk menyimpan panjang subarray; gelung untuk mencari segmen bersebelahan; mengemas kini pengganda; mengembalikan jumlah; Kod pemacu", "code": "< ? php function findAndSum ( $ arr , $ n ) { $ sum = 0 ; $ mul = 1 ; for ( $ i = 0 ; $ i < 30 ; $ i ++ ) { $ count_on = 0 ; $ l = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) > 0 ) if ( $ count_on ) $ l ++ ; else { $ count_on = 1 ; $ l ++ ; } else if ( $ count_on ) { $ sum += ( ( $ mul * $ l * ( $ l + 1 ) ) / 2 ) ; $ count_on = 0 ; $ l = 0 ; } } if ( $ count_on ) { $ sum += ( ( $ mul * $ l * ( $ l + 1 ) ) / 2 ) ; $ count_on = 0 ; $ l = 0 ; } $ mul *= 2 ; } return $ sum ; } $ arr = array ( 7 , 1 , 1 , 5 ) ; $ n = sizeof ( $ arr ) ; echo findAndSum ( $ arr , $ n ) ; ? >"}
{"text": "Sumber ke destinasi dalam 2 | Fungsi yang mengembalikan benar jika mungkin untuk bergerak dari sumber ke destinasi dengan langkah yang diberikan; Kod pemacu", "code": "< ? php function isPossible ( $ Sx , $ Sy , $ Dx , $ Dy , $ x , $ y ) { if ( abs ( $ Sx - $ Dx ) % $ x == 0 && abs ( $ Sy - $ Dy ) % $ y == 0 && ( abs ( $ Sx - $ Dx ) / $ x ) % 2 == ( abs ( $ Sy - $ Dy ) / $ y ) % 2 ) return true ; return false ; } $ Sx = 0 ; $ Sy = 0 ; $ Dx = 0 ; $ Dy = 0 ; $ x = 3 ; $ y = 4 ; if ( isPossible ( $ Sx , $ Sy , $ Dx , $ Dy , $ x , $ y ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Count pasangan (x, y) dalam array sedemikian rupa sehingga x <y | Berfungsi untuk mengembalikan bilangan pasangan (x, y) supaya x <y; Untuk menyimpan bilangan pasangan yang sah; Jika pasangan yang sah dijumpai; Mengembalikan kiraan pasangan yang sah; Kod pemacu", "code": "< ? php function getPairs ( $ a ) { $ count = 0 ; for ( $ i = 0 ; $ i < sizeof ( $ a ) ; $ i ++ ) { for ( $ j = 0 ; $ j < sizeof ( $ a ) ; $ j ++ ) { if ( $ a [ $ i ] < $ a [ $ j ] ) $ count ++ ; } } return $ count ; } $ a = array ( 2 , 4 , 3 , 1 ) ; echo getPairs ( $ a ) ; ? >"}
{"text": "Nombor komposit dengan jumlah digit 1 | Fungsi yang pulangan benar jika nombor n adalah nombor komposit; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang mengembalikan benar jika jumlah nombor angka nm adalah 1; Gelung sehingga jumlahnya bukan nombor digit tunggal; Intitialize jumlah sebagai sifar; Cari jumlah digit; Jika jumlahnya akhirnya 1; Fungsi untuk mencetak nombor yang diperlukan dari julat yang diberikan; Jika saya adalah salah satu nombor yang diperlukan; Kod pemacu", "code": "< ? php function isComposite ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return false ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return true ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return true ; return false ; } function isDigitSumOne ( $ nm ) { while ( $ nm > 9 ) { $ sum_digit = 0 ; while ( $ nm > 0 ) { $ digit = $ nm % 10 ; $ sum_digit = $ sum_digit + $ digit ; $ nm = floor ( $ nm / 10 ) ; } $ nm = $ sum_digit ; } if ( $ nm == 1 ) return true ; else return false ; } function printValidNums ( $ l , $ r ) { for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( isComposite ( $ i ) && isDigitSumOne ( $ i ) ) echo $ i , \" ▁ \" ; } } $ l = 10 ; $ r = 100 ; printValidNums ( $ l , $ r ) ; ? >"}
{"text": "Tentukan kiraan nod daun dalam n | Berfungsi untuk mengira nod daun dalam pokok n - ary; Kod pemacu", "code": "< ? php function calcNodes ( $ N , $ I ) { $ result = 0 ; $ result = $ I * ( $ N - 1 ) + 1 ; return $ result ; } $ N = 5 ; $ I = 2 ; echo \" Leaf ▁ nodes ▁ = ▁ \" . calcNodes ( $ N , $ I ) ; ? >"}
{"text": "Permohonan pada Teorem Undian Bertrand | Pelaksanaan PHP pendekatan; Berfungsi untuk mengira faktorial mod MOD 1000000007; Faktorial i = faktorial (i - 1) * i; ; Mengambil mod tidak dengan pengiraan. ; Fungsi untuk eksponensi modular; Jika p adalah ganjil; Jika p juga; Berfungsi untuk mengembalikan kiraan permutasi yang diperlukan; Mengira songsang modular berbilang untuk x! dan mendarab dengan ANS; Mengira songsang modular berbilang untuk y! dan mendarab dengan ANS; Pra - mengira faktorial", "code": "< ? php $ mod = 1000000007 ; $ arr = array_fill ( 0 , 10001 , 0 ) ; function cal_factorial ( ) { global $ arr , $ mod ; $ arr [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= 10000 ; $ i ++ ) { $ arr [ $ i ] = ( $ arr [ $ i - 1 ] * $ i ) % $ mod ; } } function mod_exponent ( $ num , $ p ) { global $ mod ; if ( $ p == 0 ) return 1 ; if ( ( $ p & 1 ) ) { return ( ( $ num % $ mod ) * ( mod_exponent ( ( $ num * $ num ) % $ mod , $ p / 2 ) ) % $ mod ) % $ mod ; } else if ( ! ( $ p & 1 ) ) return ( mod_exponent ( ( $ num * $ num ) % $ mod , $ p / 2 ) ) % $ mod ; } function getCount ( $ x , $ y ) { global $ arr , $ mod ; $ ans = $ arr [ $ x + $ y - 1 ] ; $ ans *= mod_exponent ( $ arr [ $ x ] , $ mod - 2 ) ; $ ans %= $ mod ; $ ans *= mod_exponent ( $ arr [ $ y ] , $ mod - 2 ) ; $ ans %= $ mod ; $ ans *= ( $ x - $ y ) ; $ ans %= $ mod ; return $ ans ; } cal_factorial ( ) ; $ x = 3 ; $ y = 1 ; print ( getCount ( $ x , $ y ) ) ; ? >"}
{"text": "Cari nilai x dan y dalam persamaan yang diberikan | Fungsi untuk mencari nilai x dan y; keadaan asas; jawapan yang diperlukan; Kod pemacu", "code": "< ? php function findValues ( $ a , $ b ) { if ( ( $ a - $ b ) % 2 == 1 ) { echo \" - 1\" ; return ; } echo ( $ a - $ b ) / 2 , \" ▁ \" , ( $ a + $ b ) / 2 ; } $ a = 12 ; $ b = 8 ; findValues ( $ a , $ b ) ; ? >"}
{"text": "Kira pasangan triplet (a, b, c) mata dalam 2 | Berfungsi untuk mengembalikan kiraan mungkin tiga kali ganda; Masukkan semua mata dalam satu set; Jika titik pertengahan wujud dalam set; Mengembalikan kiraan triplet yang sah; Kod pemacu", "code": "< ? php function countTriplets ( $ n , $ points ) { $ pts = array ( ) ; $ ct = 0 ; for ( $ i = 0 ; $ i < count ( $ points ) ; $ i ++ ) { for ( $ j = 0 ; $ j < count ( $ points [ $ i ] ) ; $ j ++ ) { $ pts [ ] = $ points [ $ i ] [ $ j ] ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ x = $ points [ $ i ] [ 0 ] + $ points [ $ j ] [ 0 ] ; $ y = $ points [ $ i ] [ 1 ] + $ points [ $ j ] [ 1 ] ; if ( $ x % 2 == 0 and $ y % 2 == 0 ) if ( in_array ( ( int ) ( $ x / 2 ) , $ pts ) and in_array ( ( int ) ( $ y / 2 ) , $ pts ) ) $ ct += 1 ; } return $ ct ; } $ points = array ( array ( 1 , 1 ) , array ( 2 , 2 ) , array ( 3 , 3 ) ) ; $ n = count ( $ points ) ; print ( countTriplets ( $ n , $ points ) ) ; ? >"}
{"text": "Konsentrasi jus selepas mencampurkan gelas N dalam perkadaran yang sama | Berfungsi untuk mengembalikan kepekatan campuran yang dihasilkan; Kod pemacu", "code": "< ? php function mixtureConcentration ( $ n , $ p ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res += $ p [ $ i ] ; $ res /= $ n ; return $ res ; } $ arr = array ( 0 , 20 , 20 ) ; $ n = count ( $ arr ) ; print ( round ( mixtureConcentration ( $ n , $ arr ) , 4 ) ) ; ? >"}
{"text": "Bilangan elemen dengan faktor -faktor yang walaupun dalam julat yang diberikan | Berfungsi untuk mengira dataran yang sempurna; Kod pemacu", "code": "< ? php function countOddSquares ( $ n , $ m ) { return ( int ) pow ( $ m , 0.5 ) - ( int ) pow ( $ n - 1 , 0.5 ) ; } $ n = 5 ; $ m = 100 ; echo \" Count ▁ is ▁ \" , ( $ m - $ n + 1 ) - countOddSquares ( $ n , $ m ) ; ? >"}
{"text": "Jumlah kedudukan di mana raja boleh sampai di papan catur dengan tepat m bergerak | Berfungsi untuk mengembalikan bilangan dataran yang dapat dicapai oleh raja dalam bilangan langkah yang diberikan; Mengira koordinat awal dan akhir; Kerana papan catur adalah saiz 8 x8 jadi jika ada koordinat kurang dari 1 atau lebih besar daripada 8 menjadikannya 1 atau 8 .; Mengira jumlah kedudukan; Kod pemacu", "code": "< ? php function Square ( $ row , $ column , $ moves ) { $ a = 0 ; $ b = 0 ; $ c = 0 ; $ d = 0 ; $ total = 0 ; $ a = $ row - $ moves ; $ b = $ row + $ moves ; $ c = $ column - $ moves ; $ d = $ column + $ moves ; if ( $ a < 1 ) $ a = 1 ; if ( $ c < 1 ) $ c = 1 ; if ( $ b > 8 ) $ b = 8 ; if ( $ d > 8 ) $ d = 8 ; $ total = ( $ b - $ a + 1 ) * ( $ d - $ c + 1 ) - 1 ; return $ total ; } $ R = 4 ; $ C = 5 ; $ M = 2 ; echo Square ( $ R , $ C , $ M ) ; ? >"}
{"text": "Cari m | nombor whosesum sehingga satu digit adalah n; Kod pemacu", "code": "< ? php function findNumber ( $ n , $ m ) { $ num = ( $ m - 1 ) * 9 + $ n ; return $ num ; } $ n = 2 ; $ m = 5 ; echo findNumber ( $ n , $ m ) ; ? >"}
{"text": "Semak jika nombor boleh diwakili sebagai jumlah 2 nombor segi tiga | Berfungsi untuk memeriksa sama ada mungkin atau tidak; Simpan semua nombor segi tiga sehingga n dalam satu set; Periksa sama ada pasangan wujud; Kod pemacu", "code": "< ? php function checkTriangularSumRepresentation ( $ n ) { $ tri = array ( ) ; $ i = 1 ; while ( true ) { $ x = $ i * ( $ i + 1 ) ; if ( $ x >= $ n ) break ; array_push ( $ tri , $ x ) ; $ i += 1 ; } foreach ( $ tri as $ tm ) if ( in_array ( $ n - $ tm , $ tri ) ) return true ; return false ; } $ n = 24 ; if ( checkTriangularSumRepresentation ( $ n ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; ? >"}
{"text": "Perbezaan mutlak antara x pertama dan digit x terakhir n | Berfungsi untuk mencari bilangan digit dalam integer; Fungsi untuk mencari perbezaan mutlak; Simpan digit X terakhir yang terakhir; Hitung no. daripada digit dalam n; Keluarkan digit kecuali x pertama; Simpan digit X pertama yang pertama; Kembalikan perbezaan mutlak antara yang pertama dan terakhir; Kod pemacu", "code": "< ? php function digitsCount ( $ n ) { $ len = 0 ; while ( $ n > 0 ) { $ len ++ ; $ n = ( int ) ( $ n / 10 ) ; } return $ len ; } function absoluteFirstLast ( $ n , $ x ) { $ i = 0 ; $ mod = 1 ; while ( $ i < $ x ) { $ mod *= 10 ; $ i ++ ; } $ last = $ n % $ mod ; $ len = digitsCount ( $ n ) ; while ( $ len != $ x ) { $ n = ( int ) ( $ n / 10 ) ; $ len -- ; } $ first = $ n ; return abs ( $ first - $ last ) ; } $ n = 21546 ; $ x = 2 ; echo absoluteFirstLast ( $ n , $ x ) ; ? >"}
{"text": "Menjana urutan minimum integer dengan unsur -unsur yang lebih besar | Berfungsi untuk mencetak urutan yang diperlukan; ARR [] akan memegang pembolehubah jumlah urutan akan menyimpan jumlah urutan; Jika jumlah urutan adalah ganjil; Cetak urutan; Kod pemacu", "code": "< ? php function make_sequence ( $ N ) { $ arr = array ( ) ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i % 2 == 1 ) $ arr [ $ i ] = 1 ; else $ arr [ $ i ] = 2 ; $ sum += $ arr [ $ i ] ; } if ( $ sum % 2 == 1 ) $ arr [ 2 ] = 3 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; } $ N = 9 ; make_sequence ( $ N ) ; ? >"}
{"text": "Kira ganjil dan bahkan nombor dalam julat dari L ke R | Kembalikan bilangan nombor ganjil dalam julat [l, r]; Jika sama ada R atau L adalah ganjil; Kod pemacu", "code": "< ? php function countOdd ( $ L , $ R ) { $ N = ( $ R - $ L ) / 2 ; if ( $ R % 2 != 0 $ L % 2 != 0 ) $ N ++ ; return $ N ; } $ L = 3 ; $ R = 7 ; $ odds = countOdd ( $ L , $ R ) ; $ evens = ( $ R - $ L + 1 ) - $ odds ; echo \" Count ▁ of ▁ odd ▁ numbers ▁ is ▁ \" . $ odds . \" STRNEWLINE \" ; echo \" Count ▁ of ▁ even ▁ numbers ▁ is ▁ \" . $ evens ; ? >"}
{"text": "Kos lukisan n * m grid | Berfungsi untuk mengembalikan kos minimum; Kod pemacu", "code": "< ? php function getMinCost ( $ n , $ m ) { $ cost = ( $ n - 1 ) * $ m + ( $ m - 1 ) * $ n ; return $ cost ; } $ n = 4 ; $ m = 5 ; echo getMinCost ( $ n , $ m ) ; ? >"}
{"text": "Operasi minimum diperlukan untuk menjadikan semua elemen array sama | Berfungsi untuk mengembalikan bilangan minimum operasi yang diberikan untuk membuat semua elemen array sama; Semak sama ada semua elemen dari indeks kth hingga yang terakhir adalah sama; Mencari elemen 1 yang tidak sama dengan elemen kth; Kod pemacu", "code": "< ? php function minOperation ( $ n , $ k , & $ a ) { for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] != $ a [ $ k - 1 ] ) return -1 ; } for ( $ i = $ k - 2 ; $ i > -1 ; $ i -- ) { if ( $ a [ $ i ] != $ a [ $ k - 1 ] ) return ( $ i + 1 ) ; } } $ n = 5 ; $ k = 3 ; $ a = array ( 2 , 1 , 1 , 1 , 1 ) ; echo ( minOperation ( $ n , $ k , $ a ) ) ; ? >"}
{"text": "Bilangan graf mudah dengan verti n dan tepi m | Berfungsi untuk mengembalikan nilai pekali binomial C (n, k); Kerana c (n, k) = c (n, n - k); Kirakan nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * ... * 1]; Kod pemacu", "code": "< ? php function binomialCoeff ( $ n , $ k ) { if ( $ k > $ n ) return 0 ; $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; } $ N = 5 ; $ M = 1 ; $ P = floor ( ( $ N * ( $ N - 1 ) ) / 2 ) ; echo binomialCoeff ( $ P , $ M ) ; ? >"}
{"text": "Meningkatkan urutan dengan GCD yang diberikan | Berfungsi untuk mencetak urutan yang diperlukan; Kod pemacu", "code": "< ? php function generateSequence ( $ n , $ g ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ i * $ g . \" ▁ \" ; } $ n = 6 ; $ g = 5 ; generateSequence ( $ n , $ g ) ; ? >"}
{"text": "Program untuk mencari LCM dua nombor Fibonnaci | Program PHP untuk mencari LCM FIB (A) dan FIB (B); Buat array untuk memoisasi; Fungsi untuk mengembalikan nombor Fibonacci N 'menggunakan Jadual F []. ; Kes asas; Jika FIB (n) sudah dikira; Memohon nilai nota formula rekursif n & 1 adalah 1 jika n adalah ganjil, lain 0 .; Berfungsi untuk mengembalikan GCD A dan B; Berfungsi untuk mengembalikan LCM FIB (A) dan FIB (A); Kod pemacu", "code": "< ? php $ GLOBALS [ ' MAX ' ] = 1000 ; $ GLOBALS [ ' f ' ] = array ( ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' MAX ' ] ; $ i ++ ) $ GLOBALS [ ' f ' ] [ $ i ] = 0 ; function fib ( $ n ) { if ( $ n == 0 ) return 0 ; if ( $ n == 1 $ n == 2 ) return ( $ GLOBALS [ ' f ' ] [ $ n ] = 1 ) ; if ( $ GLOBALS [ ' f ' ] [ $ n ] ) return $ GLOBALS [ ' f ' ] [ $ n ] ; $ k = ( $ n & 1 ) ? ( $ n + 1 ) / 2 : $ n / 2 ; $ GLOBALS [ ' f ' ] [ $ n ] = ( $ n & 1 ) ? ( fib ( $ k ) * fib ( $ k ) + fib ( $ k - 1 ) * fib ( $ k - 1 ) ) : ( 2 * fib ( $ k - 1 ) + fib ( $ k ) ) * fib ( $ k ) ; return $ GLOBALS [ ' f ' ] [ $ n ] ; } function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function findLCMFibonacci ( $ a , $ b ) { return ( fib ( $ a ) * fib ( $ b ) ) / fib ( gcd ( $ a , $ b ) ) ; } $ a = 3 ; $ b = 12 ; echo findLCMFibonacci ( $ a , $ b ) ; ? >"}
{"text": "Semak sama ada XOR dari semua nombor dalam julat yang diberikan adalah atau ganjil | Fungsi untuk memeriksa sama ada xor semua nombor dalam julat [l, r] adalah atau ganjil; Mengira nombor ganjil dalam julat [l, r]; Semak sama ada kiraan nombor ganjil adalah atau ganjil; Kod pemacu", "code": "< ? php function isEvenOrOdd ( $ L , $ R ) { $ oddCount = floor ( ( $ R - $ L ) / 2 ) ; if ( $ R % 2 == 1 $ L % 2 == 1 ) $ oddCount ++ ; if ( $ oddCount % 2 == 0 ) return \" Even \" ; else return \" Odd \" ; } $ L = 5 ; $ R = 15 ; echo isEvenOrOdd ( $ L , $ R ) ; ? >"}
{"text": "Bilangan bilangan sifar trailing dalam (1 ^ 1) * (2 ^ 2) * (3 ^ 3) * (4 ^ 4) *. . | Berfungsi untuk mengembalikan bilangan sifar trailing; Untuk menyimpan bilangan 2 s dan 5 s; Jika kita mendapat faktor 2 maka kita mempunyai jumlah 2 s kerana kuasa nombor itu dibangkitkan kepada i; Jika kita mendapat faktor 5 maka kita mempunyai jumlah 5 s kerana kuasa nombor itu dibangkitkan kepada i; Ambil minimum mereka; Kod pemacu", "code": "< ? php function trailing_zeros ( $ N ) { $ count_of_two = 0 ; $ count_of_five = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ val = $ i ; while ( $ val % 2 == 0 && $ val > 0 ) { $ val /= 2 ; $ count_of_two += $ i ; } while ( $ val % 5 == 0 && $ val > 0 ) { $ val /= 5 ; $ count_of_five += $ i ; } } $ ans = min ( $ count_of_two , $ count_of_five ) ; return $ ans ; } $ N = 12 ; echo trailing_zeros ( $ N ) ; ? >"}
{"text": "Algoritma Lukisan Ellipse Midpoint | Program PHP untuk melaksanakan algoritma lukisan MID - Point Ellipse; Parameter keputusan awal Wilayah 1; Untuk Wilayah 1; Titik cetak berdasarkan simetri 4 - cara; Memeriksa dan mengemas kini nilai parameter keputusan berdasarkan algoritma; Parameter keputusan Wilayah 2; Merancang titik rantau 2; titik percetakan berdasarkan simetri 4 - cara; Memeriksa dan mengemas kini nilai parameter berdasarkan algoritma; Untuk menarik elips jejari utama dan kecil 15, 10 berpusat pada (50, 50)", "code": "< ? php function midptellipse ( $ rx , $ ry , $ xc , $ yc ) { $ x = 0 ; $ y = $ ry ; $ d1 = ( $ ry * $ ry ) - ( $ rx * $ rx * $ ry ) + ( 0.25 * $ rx * $ rx ) ; $ dx = 2 * $ ry * $ ry * $ x ; $ dy = 2 * $ rx * $ rx * $ y ; while ( $ dx < $ dy ) { echo \" ( ▁ \" , $ x + $ xc , \" , ▁ \" , $ y + $ yc , \" ▁ ) STRNEWLINE \" ; echo \" ( ▁ \" , - $ x + $ xc , \" , ▁ \" , $ y + $ yc , \" ▁ ) STRNEWLINE \" ; echo \" ( ▁ \" , $ x + $ xc , \" , ▁ \" , - $ y + $ yc , \" ▁ ) STRNEWLINE \" ; echo \" ( ▁ \" , - $ x + $ xc , \" , ▁ \" , - $ y + $ yc , \" ▁ ) STRNEWLINE \" ; if ( $ d1 < 0 ) { $ x ++ ; $ dx = $ dx + ( 2 * $ ry * $ ry ) ; $ d1 = $ d1 + $ dx + ( $ ry * $ ry ) ; } else { $ x ++ ; $ y -- ; $ dx = $ dx + ( 2 * $ ry * $ ry ) ; $ dy = $ dy - ( 2 * $ rx * $ rx ) ; $ d1 = $ d1 + $ dx - $ dy + ( $ ry * $ ry ) ; } } $ d2 = ( ( $ ry * $ ry ) * ( ( $ x + 0.5 ) * ( $ x + 0.5 ) ) ) + ( ( $ rx * $ rx ) * ( ( $ y - 1 ) * ( $ y - 1 ) ) ) - ( $ rx * $ rx * $ ry * $ ry ) ; while ( $ y >= 0 ) { echo \" ( ▁ \" , $ x + $ xc , \" , ▁ \" , $ y + $ yc , \" ▁ ) STRNEWLINE \" ; echo \" ( ▁ \" , - $ x + $ xc , \" , ▁ \" , $ y + $ yc , \" ▁ ) STRNEWLINE \" ; echo \" ( ▁ \" , $ x + $ xc , \" , ▁ \" , - $ y + $ yc , \" ▁ ) STRNEWLINE \" ; echo \" ( ▁ \" , - $ x + $ xc , \" , ▁ \" , - $ y + $ yc , \" ▁ ) STRNEWLINE \" ; if ( $ d2 > 0 ) { $ y -- ; $ dy = $ dy - ( 2 * $ rx * $ rx ) ; $ d2 = $ d2 + ( $ rx * $ rx ) - $ dy ; } else { $ y -- ; $ x ++ ; $ dx = $ dx + ( 2 * $ ry * $ ry ) ; $ dy = $ dy - ( 2 * $ rx * $ rx ) ; $ d2 = $ d2 + $ dx - $ dy + ( $ rx * $ rx ) ; } } } midptellipse ( 10 , 15 , 50 , 50 ) ; ? >"}
{"text": "Program untuk memeriksa sama ada nombor dibahagikan dengan jumlah digitnya | Fungsi untuk memeriksa sama ada nombor yang diberikan dapat dibahagikan dengan jumlah digitnya; Cari jumlah digit; Semak sama ada jumlah digit membahagikan n; Kod pemacu", "code": "< ? php function isDivisible ( $ n ) { $ temp = $ n ; $ sum = 0 ; while ( $ n ) { $ k = $ n % 10 ; $ sum += $ k ; $ n = ( int ) ( $ n / 10 ) ; } if ( $ temp % $ sum == 0 ) return \" YES \" ; return \" NO \" ; } $ n = 123 ; print ( isDivisible ( $ n ) ) ; ? >"}
{"text": "Cari X dan Y akhir apabila mereka berubah di bawah keadaan yang diberikan | Fungsi untuk mendapatkan nilai akhir x dan y; Berikutan urutan tetapi dengan menggantikan tolak dengan modulo; Langkah 1; Langkah 2; Langkah 3; Sebaliknya menamatkan; Dapatkan nilai X dan Y awal; Cari hasilnya", "code": "< ? php function alter ( $ x , $ y ) { while ( true ) { if ( $ x == 0 $ y == 0 ) break ; if ( $ x >= 2 * $ y ) $ x = $ x % ( 2 * $ y ) ; else if ( $ y >= 2 * $ x ) $ y = $ y % ( 2 * $ x ) ; else break ; } echo \" X = \" , ▁ $ x , ▁ \" , \" , ▁ \" Y = \" } $ x = 12 ; $ y = 5 ; alter ( $ x , $ y ) ; ? >"}
{"text": "Cetak semua prima berbilang <= n | Berfungsi untuk mengembalikan produk digit n; Berfungsi untuk mencetak semua prima berbilang <= n; Buat array Boolean \"Prime [0.. N + 1]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Jika saya adalah perdana dan jumlah digitnya juga utama i. e. Saya adalah Perdana Multiplicative; Kod pemacu", "code": "< ? php function digitProduct ( $ n ) { $ prod = 1 ; while ( $ n ) { $ prod = $ prod * ( $ n % 10 ) ; $ n = floor ( $ n / 10 ) ; } return $ prod ; } function printMultiplicativePrimes ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; $ prime [ 0 ] = $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ prime [ $ i ] && $ prime [ digitProduct ( $ i ) ] ) echo $ i , \" ▁ \" ; } } $ n = 10 ; printMultiplicativePrimes ( $ n ) ; ? >"}
{"text": "Nombor terbesar kurang daripada atau sama dengan n / 2 yang merupakan coprime kepada n | Berfungsi untuk mengira GCD dua nombor; Berfungsi untuk memeriksa sama ada dua nombor adalah coprime atau tidak; Dua nombor adalah coprime jika GCD mereka adalah 1; Berfungsi untuk mencari integer terbesar kurang daripada atau sama dengan n / 2 dan coprime dengan n; Semak satu demi satu semua nombor kurang daripada atau sama dengan n / 2; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; else return gcd ( $ b , $ a % $ b ) ; } function coPrime ( $ n1 , $ n2 ) { if ( gcd ( $ n1 , $ n2 ) == 1 ) return true ; else return false ; } function largestCoprime ( $ N ) { $ half = floor ( $ N / 2 ) ; while ( coPrime ( $ N , $ half ) == false ) $ half -- ; return $ half ; } $ n = 50 ; echo largestCoprime ( $ n ) ;"}
{"text": "Nombor terbesar kurang daripada atau sama dengan n / 2 yang merupakan coprime kepada n | Berfungsi untuk mencari integer terbesar kurang daripada atau sama dengan n / 2 dan coprime dengan n; Mengendalikan kes untuk n = 6; Kod pemacu", "code": "< ? php function largestCoprime ( $ N ) { if ( $ N == 6 ) return 1 ; else if ( $ N % 4 == 0 ) return ( $ N / 2 ) - 1 ; else if ( $ N % 2 == 0 ) return ( $ N / 2 ) - 2 ; else return ( ( $ N - 1 ) / 2 ) ; } $ n = 50 ; echo largestCoprime ( $ n ) ; ? >"}
{"text": "Cetak semua prima selamat di bawah n | Berfungsi untuk mencetak prima selamat pertama n; Memulakan semua penyertaan array integer sebagai 1. Nilai dalam Perdana [i] akhirnya akan menjadi 0 jika saya bukan perdana, lain 1; 0 dan 1 bukan prima; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Sekiranya saya adalah perdana; 2 p + 1; Jika 2 p + 1 juga merupakan perdana kemudian tetapkan perdana [2 p + 1] = 2; Saya adalah perdana yang selamat; Kod pemacu", "code": "< ? php function printSafePrimes ( $ n ) { $ prime = array ( ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ prime [ $ i ] = 1 ; $ prime [ 0 ] = $ prime [ 1 ] = 0 ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == 1 ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = 0 ; } } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ prime [ $ i ] != 0 ) { $ temp = ( 2 * $ i ) + 1 ; if ( $ temp <= $ n && $ prime [ $ temp ] != 0 ) $ prime [ $ temp ] = 2 ; } } for ( $ i = 5 ; $ i <= $ n ; $ i ++ ) if ( $ prime [ $ i ] == 2 ) echo $ i , \" ▁ \" ; } $ n = 20 ; printSafePrimes ( $ n ) ; ? >"}
{"text": "Pendaraban minimum dengan {2, 3, 7} untuk membuat dua nombor sama | Berfungsi untuk mencari kuasa 2, 3 dan 7 dalam x; Untuk menyimpan kiraan setiap pembahagi; Untuk menyimpan hasilnya; Mengira kuasa 2 dalam x; Mengira kuasa 3 dalam x; Mengira kuasa 7 dalam x; Bilangan baki yang tidak dapat dibahagikan dengan 2, 3 atau 7; Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan untuk membuat A dan B sama; a = x * 2 ^ a1 * 3 ^ a2 * 7 ^ a3 va [0] = a1 va [1] = a2 va [2] = a3 va [3] = x; Begitu juga untuk B; Jika A dan B tidak boleh dibuat sama dengan operasi yang diberikan. Perhatikan bahawa VA [3] dan VB [3] mengandungi nombor yang tinggal selepas bahagian berulang dengan 2, 3 dan 7. Jika bilangan baki tidak sama maka kita tidak boleh menjadikannya sama. ; Bilangan minimum operasi yang diperlukan; Kod pemacu", "code": "< ? php function Divisors ( $ x ) { $ c = 0 ; $ v = array ( ) ; while ( $ x % 2 == 0 ) { $ c ++ ; $ x = floor ( $ x / 2 ) ; } array_push ( $ v , $ c ) ; $ c = 0 ; while ( $ x % 3 == 0 ) { $ c ++ ; $ x = floor ( $ x / 3 ) ; } array_push ( $ v , $ c ) ; $ c = 0 ; while ( $ x % 7 == 0 ) { $ c ++ ; $ x = floor ( $ x / 7 ) ; } array_push ( $ v , $ c ) ; array_push ( $ v , $ x ) ; return $ v ; } function MinOperations ( $ a , $ b ) { $ va = Divisors ( $ a ) ; $ vb = Divisors ( $ b ) ; if ( $ va [ 3 ] != $ vb [ 3 ] ) return -1 ; $ minOperations = abs ( $ va [ 0 ] - $ vb [ 0 ] ) + abs ( $ va [ 1 ] - $ vb [ 1 ] ) + abs ( $ va [ 2 ] - $ vb [ 2 ] ) ; return $ minOperations ; } $ a = 14 ; $ b = 28 ; echo MinOperations ( $ a , $ b ) ; ? >"}
{"text": "Produk n dengan digit ganjil terbesar | Berfungsi untuk mengembalikan digit ganjil terbesar di N; Jika semua digit adalah walaupun - 1 akan dikembalikan; Digit terakhir dari N; Jika digit semasa adalah ganjil dan> maxodd; Keluarkan digit terakhir; Kembalikan digit ganjil maksimum; Berfungsi untuk mengembalikan produk n dengan digit ganjil terbesarnya; Sekiranya tidak ada digit ganjil dalam N; Produk n dengan digit ganjil terbesar; Kod pemacu", "code": "< ? php function largestOddDigit ( $ n ) { $ maxOdd = -1 ; while ( $ n > 0 ) { $ digit = $ n % 10 ; if ( $ digit % 2 == 1 && $ digit > $ maxOdd ) $ maxOdd = $ digit ; $ n = $ n / 10 ; } return $ maxOdd ; } function getProduct ( $ n ) { $ maxOdd = largestOddDigit ( $ n ) ; if ( $ maxOdd == -1 ) return -1 ; return ( $ n * $ maxOdd ) ; } $ n = 12345 ; echo getProduct ( $ n ) ; ? >"}
{"text": "Jumlah LCM (1, N), LCM (2, N), LCM (3, N), ..., LCM (N, N) | Pelaksanaan PHP pendekatan; Fungsi Euler Totient; Berfungsi untuk mengembalikan jumlah LCM yang diperlukan; Penjumlahan d * etf (d) di mana d tergolong dalam set pembahagi n; Kod pemacu", "code": "< ? php $ n = 10002 ; $ phi = array_fill ( 0 , $ n + 2 , 0 ) ; $ ans = array_fill ( 0 , $ n + 2 , 0 ) ; function ETF ( ) { global $ phi , $ n ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ phi [ $ i ] = $ i ; } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ phi [ $ i ] == $ i ) { $ phi [ $ i ] = $ i - 1 ; for ( $ j = 2 * $ i ; $ j <= $ n ; $ j += $ i ) { $ phi [ $ j ] = ( int ) ( ( $ phi [ $ j ] * ( $ i - 1 ) ) / $ i ) ; } } } } function LcmSum ( $ m ) { ETF ( ) ; global $ ans , $ n , $ phi ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = $ i ; $ j <= $ n ; $ j += $ i ) { $ ans [ $ j ] += ( $ i * $ phi [ $ i ] ) ; } } $ answer = $ ans [ $ m ] ; $ answer = ( $ answer + 1 ) * $ m ; $ answer = ( int ) ( $ answer / 2 ) ; return $ answer ; } $ m = 5 ; echo LcmSum ( $ m ) ; ? >"}
{"text": "Permutasi rentetan supaya tiada dua vokal bersebelahan | Faktorial nombor; Fungsi untuk mencari C (n, r); Fungsi untuk mengira permutasi rentetan supaya tidak ada dua vokal bersebelahan; Mencari frekuensi watak -watak; Mencari no. vokal dan konsonan dalam perkataan yang diberikan; mencari tempat untuk vokal; Cara Mengisi Konsonan 6! / 2! ; Cara untuk meletakkan vokal 7 C5 x 5! ; Kod pemacu", "code": "< ? php function factorial ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ fact = $ fact * $ i ; return $ fact ; } function ncr ( $ n , $ r ) { return factorial ( $ n ) / ( factorial ( $ r ) * factorial ( $ n - $ r ) ) ; } function countWays ( $ str ) { $ freq = array_fill ( 0 , 26 , NULL ) ; $ nvowels = 0 ; $ nconsonants = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) ++ $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ i == 0 $ i == 4 $ i == 8 $ i == 14 $ i == 20 ) $ nvowels += $ freq [ $ i ] ; else $ nconsonants += $ freq [ $ i ] ; } $ vplaces = $ nconsonants + 1 ; $ cways = factorial ( $ nconsonants ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ i != 0 && $ i != 4 && $ i != 8 && $ i != 14 && $ i != 20 && $ freq [ $ i ] > 1 ) { $ cways = $ cways / factorial ( $ freq [ $ i ] ) ; } } $ vways = ncr ( $ vplaces , $ nvowels ) * factorial ( $ nvowels ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ i == 0 $ i == 4 $ i == 8 $ i == 14 $ i == 20 && $ freq [ $ i ] > 1 ) { $ vways = $ vways / factorial ( $ freq [ $ i ] ) ; } } return $ cways * $ vways ; } $ str = \" permutation \" ; echo countWays ( $ str ) . \" STRNEWLINE \" ; return 0 ; ? >"}
{"text": "Pasangan dari array yang memenuhi syarat yang diberikan | Berfungsi untuk mengembalikan bilangan bit set dalam n; Berfungsi untuk mengembalikan kiraan pasangan yang diperlukan; Tetapkan bit untuk elemen pertama pasangan; Tetapkan bit untuk elemen kedua pasangan; Menetapkan bit nombor hasil yang merupakan XOR dari kedua -dua unsur pasangan itu; Sekiranya keadaan itu berpuas hati; Kenaikan kiraan; Mengembalikan jumlah jumlah; Kod pemacu", "code": "< ? php function setBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ n = $ n & ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function countPairs ( & $ a , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ setbits_x = setBits ( $ a [ $ i ] ) ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ setbits_y = setBits ( $ a [ $ j ] ) ; $ setbits_xor_xy = setBits ( $ a [ $ i ] ^ $ a [ $ j ] ) ; if ( $ setbits_x + $ setbits_y == $ setbits_xor_xy ) $ count ++ ; } } return $ count ; } $ a = array ( 2 , 3 , 4 , 5 , 6 ) ; $ n = sizeof ( $ a ) / sizeof ( $ a [ 0 ] ) ; echo countPairs ( $ a , $ n ) ; ? >"}
{"text": "Bilangan elemen array yang boleh diturunkan dari D Setelah melaksanakan operasi tertentu | Berfungsi untuk mengembalikan GCD A dan B; Berfungsi untuk mengembalikan bilangan elemen arr [] yang boleh diperoleh dari d dengan melakukan ( + a, - a, + b, - b); Cari GCD A dan B; Kaunter menyimpan bilangan elemen array yang boleh diperolehi dari D; arr [i] boleh diperoleh dari d hanya jika | arr [i] - D | boleh dibahagikan dengan GCD A dan B; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function findPossibleDerivables ( $ arr , $ n , $ D , $ A , $ B ) { $ gcdAB = gcd ( $ A , $ B ) ; $ counter = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( abs ( $ arr [ $ i ] - $ D ) % $ gcdAB ) == 0 ) { $ counter ++ ; } } return $ counter ; } $ arr = array ( 1 , 2 , 3 , 4 , 7 , 13 ) ; $ n = sizeof ( $ arr ) ; $ D = 5 ; $ A = 4 ; $ B = 2 ; echo findPossibleDerivables ( $ arr , $ n , $ D , $ A , $ B ) , \" \" ; $ a = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ a ) ; $ D = 6 ; $ A = 3 ; $ B = 2 ; echo findPossibleDerivables ( $ arr , $ n , $ D , $ A , $ B ) , \" \" ; ? >"}
{"text": "Cari jumlah terma pertama N Siri 2 * 3 * 5, 3 * 5 * 7, 4 * 7 * 9, ... | Berfungsi untuk mengembalikan jumlah terma pertama N siri yang diberikan; Seperti yang diterangkan dalam pendekatan; Kod pemacu", "code": "< ? php function calculateSum ( $ n ) { return ( $ n * ( 2 * $ n * $ n * $ n + 12 * $ n * $ n + 25 * $ n + 21 ) ) / 2 ; } $ n = 3 ; echo calculateSum ( $ n ) ; ? >"}
{"text": "Cari Unsur Array Menggunakan XOR Elemen berturut -turut | Berfungsi untuk mencari elemen array menggunakan XOR unsur berturut -turut; elemen pertama i. E elemen [0] = a; Untuk mendapatkan unsur -unsur seterusnya, kita perlu mengira XOR unsur -unsur terdahulu dengan XOR yang diberikan 2 elemen berturut -turut. e. g. Jika a ^ b = k1 jadi untuk mendapatkan b xor kedua -dua belah. b = k1 ^ a; Mencetak elemen array asal; Kod pemacu", "code": "< ? php function getElements ( $ a , & $ arr , & $ n ) { $ elements [ 0 ] = $ a ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ elements [ $ i + 1 ] = $ arr [ $ i ] ^ $ elements [ $ i ] ; } for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) { echo ( $ elements [ $ i ] . \" \" ) ; } } $ arr = array ( 13 , 2 , 6 , 1 ) ; $ n = sizeof ( $ arr ) ; $ a = 5 ; getElements ( $ a , $ arr , $ n ) ; ? >"}
{"text": "Semak jika jumlah digit yang berbeza dari dua bilangan bulat adalah sama | Berfungsi untuk mengembalikan jumlah digit yang berbeza dari nombor; Ambil digit terakhir; Jika digit belum digunakan sebelum ini; Tetapkan digit seperti yang digunakan; Keluarkan digit terakhir; Berfungsi untuk memeriksa sama ada jumlah digit yang berbeza dari dua nombor adalah sama; Kod pemacu", "code": "< ? php function distinctDigitSum ( $ n ) { $ used [ 10 ] = array ( ) ; $ sum = 0 ; while ( $ n > 0 ) { $ digit = $ n % 10 ; if ( $ used > 0 ) { $ used [ $ digit ] = true ; $ sum += $ digit ; } $ n = ( int ) $ n / 10 ; } return $ sum ; } function checkSum ( $ m , $ n ) { $ sumM = distinctDigitSum ( $ m ) ; $ sumN = distinctDigitSum ( $ n ) ; if ( $ sumM != $ sumN ) return \" YES \" ; return \" NO \" ; } $ m = 2452 ; $ n = 9222 ; echo ( checkSum ( $ m , $ n ) ) ; ? >"}
{"text": "Cari Nth Hermite Number | Fungsi utiliti untuk mengira faktorial ganda nombor; Berfungsi untuk mengembalikan nombor hermite nth; Jika n walaupun kemudian kembali 0; Jika n adalah ganjil; Kirakan faktorial ganda (n - 1) dan kalikan dengan 2 ^ (n / 2); Jika n / 2 adalah ganjil maka nombor hermite n akan menjadi negatif; Kembali nombor Hermite nth; Kod pemacu; Cetak nombor Hermite n", "code": "< ? php function doubleFactorial ( $ n ) { $ fact = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i = $ i + 2 ) { $ fact = $ fact * $ i ; } return $ fact ; } function hermiteNumber ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; else { $ number = ( pow ( 2 , $ n / 2 ) ) * doubleFactorial ( $ n - 1 ) ; if ( ( $ n / 2 ) % 2 == 1 ) $ number = $ number * -1 ; return $ number ; } } $ n = 6 ; echo hermiteNumber ( $ n ) ; ? >"}
{"text": "Jumlah integer sehingga n dengan digit unit yang diberikan | Berfungsi untuk mengembalikan jumlah yang diperlukan; Jika digit unit adalah d; Kod pemacu", "code": "< ? php function getSum ( $ n , $ d ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 10 == $ d ) $ sum += $ i ; } return $ sum ; } $ n = 30 ; $ d = 3 ; echo getSum ( $ n , $ d ) ; ? >"}
{"text": "Pecahkan nombor ke dalam 3 bahagian supaya tidak ada bahagian yang boleh dibahagikan dengan 3 | Program PHP untuk memecah nombor ke dalam tiga bahagian seperti yang tidak dapat dibahagikan dengan 3 .; Cetak x = 1, y = 1 dan z = n - 2; Jika tidak, cetak x = 1, y = 2 dan z = n - 3; Kod pemacu", "code": "< ? php function printThreeParts ( $ N ) { if ( $ N % 3 == 0 ) echo \" ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ \" . ( $ N - 2 ) . \" STRNEWLINE \" ; else echo \" ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ \" . ( $ N - 3 ) . \" STRNEWLINE \" ; } $ N = 10 ; printThreeParts ( $ N ) ; ? >"}
{"text": "Perbezaan mutlak minimum nombor dan perdana terdekatnya | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Berfungsi untuk mencari perbezaan mutlak minimum antara nombor dan perdana terdekatnya; Pembolehubah untuk menyimpan perdana pertama di atas dan di bawah n; Mencari nombor perdana pertama yang lebih besar daripada n; Mencari nombor perdana pertama yang kurang daripada n; Pembolehubah untuk menyimpan perbezaan; Kod pemacu", "code": "< ? php function isPrime ( $ N ) { for ( $ i = 2 ; $ i <= sqrt ( $ N ) ; $ i ++ ) { if ( $ N % $ i == 0 ) return false ; } return true ; } function getDifference ( $ N ) { if ( $ N == 0 ) return 2 ; else if ( $ N == 1 ) return 1 ; else if ( isPrime ( $ N ) ) return 0 ; $ aboveN = -1 ; $ belowN = -1 ; $ n1 = $ N + 1 ; while ( true ) { if ( isPrime ( $ n1 ) ) { $ aboveN = $ n1 ; break ; } else $ n1 ++ ; } $ n1 = $ N - 1 ; while ( true ) { if ( isPrime ( $ n1 ) ) { $ belowN = $ n1 ; break ; } else $ n1 -- ; } $ diff1 = $ aboveN - $ N ; $ diff2 = $ N - $ belowN ; return min ( $ diff1 , $ diff2 ) ; } $ N = 25 ; echo getDifference ( $ N ) . \" STRNEWLINE \" ;"}
{"text": "Semak sama ada jumlah kotak yang sempurna dalam array boleh dibahagikan dengan x | Fungsi yang kembali benar jika jumlah semua dataran sempurna dari array yang diberikan dapat dibahagikan dengan x; Jika Arr [i] adalah persegi yang sempurna; Kod pemacu", "code": "< ? php function check ( $ arr , $ x , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = sqrt ( $ arr [ $ i ] ) ; if ( floor ( $ x ) == ceil ( $ x ) ) { $ sum += $ arr [ $ i ] ; } } if ( ( $ sum % $ x ) == 0 ) return true ; else return false ; } $ arr = array ( 2 , 3 , 4 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; $ x = 13 ; if ( ! check ( $ arr , $ x , $ n ) ) { echo \" Yes \" ; } else { echo \" No \" ; } ? >"}
{"text": "Minimum dan maksimum pasangan dalam pasukan M People | Program PHP untuk mencari minimum dan maksimum no. pasangan; Kod pemacu", "code": "< ? php function MinimumMaximumPairs ( $ n , $ m ) { $ max_pairs = ( ( $ n - $ m + 1 ) * ( $ n - $ m ) ) / 2 ; $ min_pairs = $ m * ( int ) ( ( ( ( int ) ( $ n - $ m ) / $ m + 1 ) * ( ( int ) ( $ n - $ m ) / $ m ) ) / 2 ) + ( int ) ceil ( ( $ n - $ m ) / $ m ) * ( ( $ n - $ m ) % $ m ) ; echo ( \" Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ \" . \" $ min _ pairs \" . \" STRNEWLINE \" ) ; echo ( \" Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ \" . \" $ max _ pairs \" ) ; } $ n = 5 ; $ m = 2 ; MinimumMaximumPairs ( $ n , $ m ) ; ? >"}
{"text": "Lebih besar daripada a ^ b atau b ^ a (yang dibangkitkan kepada kuasa b atau b yang dinaikkan untuk kuasa a) | Fungsi untuk mencari nilai yang lebih besar; Kod pemacu", "code": "< ? php function findGreater ( $ a , $ b ) { $ x = ( double ) $ a * ( double ) ( log ( ( double ) ( $ b ) ) ) ; $ y = ( double ) $ b * ( double ) ( log ( ( double ) ( $ a ) ) ) ; if ( $ y > $ x ) { echo \" a ^ b ▁ is ▁ greater \" , \" STRNEWLINE \" ; } else if ( $ y < $ x ) { echo \" b ^ a ▁ is ▁ greater \" , \" STRNEWLINE \" ; } else { echo \" Both ▁ are ▁ equal \" , \" STRNEWLINE \" ; } } $ a = 3 ; $ b = 5 ; $ c = 2 ; $ d = 4 ; findGreater ( $ a , $ b ) ; findGreater ( $ c , $ d ) ; ? >"}
{"text": "Menyatakan pecahan sebagai nombor semulajadi di bawah Modulo 'M' | Berfungsi untuk mengembalikan GCD nombor yang diberikan; Fungsi rekursif untuk kembali (x ^ n) % m; Berfungsi untuk mengembalikan mod modulo pecahan; (B ^ m - 2) % m; Jawapan terakhir; Kod pemacu", "code": "< ? php function abc ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return abc ( $ b % $ a , $ a ) ; } function modexp ( $ x , $ n ) { $ m = 1000000007 ; if ( $ n == 0 ) { return 1 ; } else if ( $ n % 2 == 0 ) { return modexp ( ( $ x * $ x ) % $ m , $ n / 2 ) ; } else { return ( $ x * modexp ( ( $ x * $ x ) % $ m , ( $ n - 1 ) / 2 ) % $ m ) ; } } function getFractionModulo ( $ a , $ b ) { $ m = 1000000007 ; $ c = abc ( $ a , $ b ) ; $ a = $ a / $ c ; $ b = $ b / $ c ; $ d = modexp ( $ b , $ m - 2 ) ; $ ans = ( ( $ a % $ m ) * ( $ d % $ m ) ) % $ m ; return $ ans ; } $ a = 2 ; $ b = 6 ; echo ( getFractionModulo ( $ a , $ b ) ) ; ? >"}
{"text": "Cari jumlah nombor dan faktor utama maksimum | Berfungsi untuk mengembalikan jumlah N dan faktor utama terbesar; Inisiasi MaxPrime ke - 1 .; n mesti ganjil pada ketika ini, dengan itu melangkau nombor -nombor bahkan dan berulang hanya nombor ganjil; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Akhirnya kembali jumlahnya. ; Kod pemacu", "code": "< ? php function maxPrimeFactors ( $ n ) { $ num = $ n ; $ maxPrime = -1 ; while ( $ n % 2 == 0 ) { $ maxPrime = 2 ; $ n /= 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i += 2 ) { while ( $ n % $ i == 0 ) { $ maxPrime = $ i ; $ n = $ n / $ i ; } } if ( $ n > 2 ) $ maxPrime = $ n ; $ sum = $ maxPrime + $ num ; return $ sum ; } $ n = 19 ; echo maxPrimeFactors ( $ n ) ; ? >"}
{"text": "Nombor terbesar kurang daripada n dengan jumlah digit yang lebih besar daripada jumlah digit n | Berfungsi untuk mengembalikan jumlah digit n; Gelung untuk setiap digit nombor; Berfungsi untuk mengembalikan bilangan terbesar yang kurang daripada n sedemikian rupa sehingga jumlah digitnya lebih besar daripada jumlah digit n; Bermula dari n - 1; Periksa sehingga 1; Jika saya memenuhi syarat yang diberikan; Jika keadaan tidak berpuas hati; Kod pemacu", "code": "< ? php function sumOfDigits ( $ n ) { $ res = 0 ; while ( $ n > 0 ) { $ res += $ n % 10 ; $ n /= 10 ; } return $ res ; } function findNumber ( $ n ) { $ i = $ n - 1 ; while ( $ i > 0 ) { if ( sumOfDigits ( $ i ) > sumOfDigits ( $ n ) ) return $ i ; $ i -- ; } return -1 ; } $ n = 824 ; echo findNumber ( $ n ) ; ? >"}
{"text": "Cari istilah n Siri 14, 28, 20, 40, .... . | Fungsi untuk mencari istilah n - th; memulakan nombor 1 st; gelung dari istilah 2 nd hingga nth; Sekiranya saya berada, dua kali ganda nombor sebelumnya; Jika saya ganjil, tolak 8 dari nombor sebelumnya; Kod pemacu", "code": "< ? php function findNth ( $ N ) { $ b = 14 ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { if ( $ i % 2 == 0 ) $ b = $ b * 2 ; else $ b = $ b - 8 ; } return $ b ; } $ N = 6 ; echo findNth ( $ N ) ; ? >"}
{"text": "Masalah 8 jiran elemen dalam 2 | Dimensi array; Kiraan 1 s; Mengira semua jiran 1 s; Membandingkan bilangan jiran 1 s dengan julat yang diberikan; Menyalin perubahan pada matriks utama; Kod pemacu; Panggilan fungsi untuk mengira matriks yang dihasilkan selepas lelaran 'k'. ; Hasil percetakan", "code": "< ? php #define N  4 NEW_LINE function predictMatrix ( $ arr , $ range1a , $ range1b , $ range0a , $ range0b , $ K , $ b ) { $ N = 4 ; $ c = 0 ; while ( $ K -- ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ c = 0 ; if ( $ i > 0 && $ arr [ $ i - 1 ] [ $ j ] == 1 ) $ c ++ ; if ( $ j > 0 && $ arr [ $ i ] [ $ j - 1 ] == 1 ) $ c ++ ; if ( $ i > 0 && $ j > 0 && $ arr [ $ i - 1 ] [ $ j - 1 ] == 1 ) $ c ++ ; if ( $ i < $ N - 1 && $ arr [ $ i + 1 ] [ $ j ] == 1 ) $ c ++ ; if ( $ j < $ N - 1 && $ arr [ $ i ] [ $ j + 1 ] == 1 ) $ c ++ ; if ( $ i < $ N - 1 && $ j < $ N - 1 && $ arr [ $ i + 1 ] [ $ j + 1 ] == 1 ) $ c ++ ; if ( $ i < $ N - 1 && $ j > 0 && $ arr [ $ i + 1 ] [ $ j - 1 ] == 1 ) $ c ++ ; if ( $ i > 0 && $ j < $ N - 1 && $ arr [ $ i - 1 ] [ $ j + 1 ] == 1 ) $ c ++ ; if ( $ arr [ $ i ] [ $ j ] == 1 ) { if ( $ c >= $ range1a && $ c <= $ range1b ) $ b [ $ i ] [ $ j ] = 1 ; else $ b [ $ i ] [ $ j ] = 0 ; } if ( $ arr [ $ i ] [ $ j ] == 0 ) { if ( $ c >= $ range0a && $ c <= $ range0b ) $ b [ $ i ] [ $ j ] = 1 ; else $ b [ $ i ] [ $ j ] = 0 ; } } } for ( $ k = 0 ; $ k < $ N ; $ k ++ ) for ( $ m = 0 ; $ m < $ N ; $ m ++ ) $ arr [ $ k ] [ $ m ] = $ b [ $ k ] [ $ m ] ; } return $ b ; } $ N = 4 ; $ arr = array ( array ( 0 , 0 , 0 , 0 ) , array ( 0 , 1 , 1 , 0 ) , array ( 0 , 0 , 1 , 0 ) , array ( 0 , 1 , 0 , 1 ) ) ; $ range1a = 2 ; $ range1b = 2 ; $ range0a = 2 ; $ range0b = 3 ; $ K = 3 ; $ b = array ( array ( 0 ) ) ; $ b1 = predictMatrix ( $ arr , $ range1a , $ range1b , $ range0a , $ range0b , $ K , $ b ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { echo \" STRNEWLINE \" ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) echo $ b1 [ $ i ] [ $ j ] . \" ▁ \" ; }"}
{"text": "Bilangan langkah yang diperlukan untuk meneka permutasi. | Fungsi yang mengembalikan langkah yang diperlukan; Langkah terakhir; Kod pemacu", "code": "< ? php function countMoves ( $ n ) { $ ct = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ct += $ i * ( $ n - $ i ) ; $ ct += $ n ; return $ ct ; } $ n = 3 ; echo countMoves ( $ n ) ; ? >"}
{"text": "Kira nombor dengan digit N yang terdiri daripada bilangan 0 's | Berfungsi untuk mengira nombor dengan digit N yang terdiri daripada nombor ganjil 0; Kod pemacu", "code": "< ? php function countNumbers ( $ N ) { return ( pow ( 10 , $ N ) - 1 ) - ( pow ( 10 , $ N ) - pow ( 8 , $ N ) ) / 2 ; } $ n = 2 ; echo countNumbers ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari penentu matriks yang dihasilkan oleh putaran array | Program PHP untuk mencari penentu matriks yang dihasilkan; Fungsi untuk mengira penentu; Kod pemacu", "code": "< ? php $ N = 3 ; function calcDeterminant ( $ arr ) { global $ N ; $ determinant = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ determinant += pow ( $ arr [ $ i ] , 3 ) ; } $ determinant -= 3 * $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ 2 ] ; return $ determinant ; } $ arr = array ( 4 , 5 , 3 ) ; echo calcDeterminant ( $ arr ) ; ? >"}
{"text": "Unsur -unsur minimum yang akan ditambah dalam julat supaya kiraan elemen dapat dibahagikan dengan k | Pelaksanaan PHP pendekatan; Jumlah elemen dalam julat; Jika jumlah elemen sudah dibahagikan dengan k; Nilai yang mesti ditambah untuk dikira untuk menjadikannya dibahagikan dengan k; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function minimumMoves ( $ k , $ l , $ r ) { $ count = $ r - $ l + 1 ; if ( $ count % $ k == 0 ) return 0 ; return ( $ k - ( $ count % $ k ) ) ; } $ k = 3 ; $ l = 10 ; $ r = 10 ; echo minimumMoves ( $ k , $ l , $ r ) ; ? >"}
{"text": "Jumlah semua nombor dalam julat l dan r | Berfungsi untuk mengembalikan jumlah semua nombor semula jadi; Berfungsi untuk mengembalikan jumlah nombor walaupun dalam julat l dan r; Kod pemacu", "code": "< ? php function sumNatural ( $ n ) { $ sum = ( $ n * ( $ n + 1 ) ) ; return $ sum ; } function sumEven ( $ l , $ r ) { return sumNatural ( ( int ) ( $ r / 2 ) ) - sumNatural ( ( int ) ( ( $ l - 1 ) / 2 ) ) ; } $ l = 2 ; $ r = 5 ; echo \" Sum ▁ of ▁ Natural ▁ numbers ▁ \" . \" from ▁ L ▁ to ▁ R ▁ is ▁ \" . sumEven ( $ l , $ r ) ; ? >"}
{"text": "Semak jika n boleh dibahagikan dengan nombor yang terdiri daripada digit dari set {a, b} | Fungsi untuk memeriksa sama ada n boleh dibahagikan dengan nombor yang digitnya sama ada A atau B; keadaan asas; panggilan rekursif; Semak semua nombor yang bermula dengan 'A' atau 'B'; Kod pemacu", "code": "< ? php function isDivisibleRec ( $ x , $ a , $ b , $ n ) { if ( $ x > $ n ) return false ; if ( $ n % $ x == 0 ) return true ; return ( isDivisibleRec ( $ x * 10 + $ a , $ a , $ b , $ n ) || isDivisibleRec ( $ x * 10 + $ b , $ a , $ b , $ n ) ) ; } function isDivisible ( $ a , $ b , $ n ) { return isDivisibleRec ( $ a , $ a , $ b , $ n ) || isDivisibleRec ( $ b , $ a , $ b , $ n ) ; } $ a = 3 ; $ b = 5 ; $ n = 53 ; if ( isDivisible ( $ a , $ b , $ n ) ) echo \" Yes \" ; else echo \" No \" ;"}
{"text": "Bilangan minimum bergerak yang diperlukan untuk mencapai destinasi oleh raja di papan catur | berfungsi untuk mencari bilangan minimum langkah yang diperlukan untuk mencapai destinasi oleh raja di papan catur; bilangan langkah minimum; Walaupun raja tidak berada dalam barisan atau lajur yang sama sebagai destinasi; Naik; Turun; Pergi ke kiri; Pergi ke kanan; Kod pemacu", "code": "< ? php function MinSteps ( $ SourceX , $ SourceY , $ DestX , $ DestY ) { echo max ( abs ( $ SourceX - $ DestX ) , abs ( $ SourceY - $ DestY ) ) . \" \" ; while ( ( $ SourceX != $ DestX ) || ( $ SourceY != $ DestY ) ) { if ( $ SourceX < $ DestX ) { echo ' U ' ; $ SourceX ++ ; } if ( $ SourceX > $ DestX ) { echo ' D ' ; $ SourceX -- ; } if ( $ SourceY > $ DestY ) { echo ' L ' ; $ SourceY -- ; } if ( $ SourceY < $ DestY ) { echo ' R ' ; $ SourceY ++ ; } echo \" STRNEWLINE \" ; } } $ sourceX = 4 ; $ sourceY = 4 ; $ destinationX = 7 ; $ destinationY = 0 ; MinSteps ( $ sourceX , $ sourceY , $ destinationX , $ destinationY ) ; ? >"}
{"text": "Count pasangan dalam array yang jumlahnya adalah persegi yang sempurna | Berfungsi untuk mengembalikan arraylist yang mengandungi semua dataran sempurna sehingga n; manakala persegi sempurna semasa kurang daripada atau sama dengan n; Berfungsi untuk mencetak jumlah maksimum dua elemen dari array; Berfungsi untuk mengembalikan kiraan nombor yang apabila ditambah dengan n memberikan persegi yang sempurna; Temp> n diperiksa supaya pasangan (x, y) dan (y, x) tidak dapat dikira dua kali; Fungsi untuk mengira pasangan yang jumlahnya adalah persegi yang sempurna; Jumlah maksimum dua elemen dari array; Senarai dataran sempurna sehingga max; Mengandungi semua elemen array; Tambah kiraan unsur -unsur yang ditambah dengan arr [i] memberikan persegi yang sempurna; Kod pemacu", "code": "< ? php function getPerfectSquares ( $ n ) { $ perfectSquares = array ( ) ; $ current = 1 ; $ i = 1 ; while ( $ current <= $ n ) { array_push ( $ perfectSquares , $ current ) ; $ current = ( int ) pow ( ++ $ i , 2 ) ; } return $ perfectSquares ; } function maxPairSum ( $ arr ) { $ n = count ( $ arr ) ; $ max ; $ secondMax ; if ( $ arr [ 0 ] > $ arr [ 1 ] ) { $ max = $ arr [ 0 ] ; $ secondMax = $ arr [ 1 ] ; } else { $ max = $ arr [ 1 ] ; $ secondMax = $ arr [ 0 ] ; } for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) { $ secondMax = $ max ; $ max = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ secondMax ) { $ secondMax = $ arr [ $ i ] ; } } return ( $ max + $ secondMax ) ; } function countPairsWith ( $ n , $ perfectSquares , $ nums ) { $ count = 0 ; for ( $ i = 0 ; $ i < count ( $ perfectSquares ) ; $ i ++ ) { $ temp = $ perfectSquares [ $ i ] - $ n ; if ( $ temp > $ n && in_array ( $ temp , $ nums ) ) $ count ++ ; } return $ count ; } function countPairs ( $ arr ) { $ n = count ( $ arr ) ; $ max = maxPairSum ( $ arr ) ; $ perfectSquares = getPerfectSquares ( $ max ) ; $ nums = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) array_push ( $ nums , $ arr [ $ i ] ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count += countPairsWith ( $ arr [ $ i ] , $ perfectSquares , $ nums ) ; } return $ count ; } $ arr = array ( 2 , 3 , 6 , 9 , 10 , 20 ) ; echo countPairs ( $ arr ) ; ? >"}
{"text": "Elemen sama dengan jumlah semua elemen yang tinggal | Berfungsi untuk mencari elemen; Jumlah digunakan untuk menyimpan jumlah semua elemen array; melangkah ke atas semua elemen; Kod pemacu", "code": "< ? php function findEle ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ sum - $ arr [ $ i ] ) return $ arr [ $ i ] ; return -1 ; } $ arr = array ( 1 , 2 , 3 , 6 ) ; $ n = sizeof ( $ arr ) ; echo findEle ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah semua nombor semulajadi dalam julat l ke r | Berfungsi untuk mengembalikan jumlah semua nombor semula jadi; Berfungsi untuk mengembalikan jumlah semua nombor dalam julat l dan r; Kod pemacu", "code": "< ? php function sumNatural ( $ n ) { $ sum = ( $ n * ( $ n + 1 ) ) / 2 ; return $ sum ; } function suminRange ( $ l , $ r ) { return sumNatural ( $ r ) - sumNatural ( $ l - 1 ) ; } $ l = 2 ; $ r = 5 ; echo \" Sum ▁ of ▁ Natural ▁ numbers ▁ \" . \" from ▁ L ▁ to ▁ R ▁ is ▁ \" , suminRange ( $ l , $ r ) ; ? >"}
{"text": "Semak jika sebilangan besar boleh dibahagikan dengan 75 atau tidak | semak divisibleBy3; untuk menyimpan jumlah digit; melintasi setiap digit; menjumlahkan digit; Semak sama ada sumofdigit adalah divisibleBy3; semak divisibleBy25; Sekiranya nombor satu digit; panjang nombor; mengambil dua digit terakhir; Memeriksa jika digit LastTwo adalah divisibleBy25; Berfungsi untuk memeriksa divisibleBy75 atau tidak; Semak jika DivisibleBy3 dan DivisibleBy25; Kod pemacu; boleh dibahagikan; Jika divisibleBy75", "code": "< ? php function divisibleBy3 ( $ number ) { $ sumOfDigit = 0 ; for ( $ i = 0 ; $ i < strlen ( $ number ) ; $ i ++ ) $ sumOfDigit += $ number [ $ i ] - '0' ; if ( $ sumOfDigit % 3 == 0 ) return true ; return false ; } function divisibleBy25 ( $ number ) { if ( strlen ( $ number ) < 2 ) return false ; $ length = strlen ( $ number ) ; $ lastTwo = ( $ number [ $ length - 2 ] - '0' ) * 10 + ( $ number [ $ length - 1 ] - '0' ) ; if ( $ lastTwo % 25 == 0 ) return true ; return false ; } function divisibleBy75 ( $ number ) { if ( divisibleBy3 ( $ number ) && divisibleBy25 ( $ number ) ) return true ; return false ; } $ number = \"754586672150\" ; $ divisible = divisibleBy75 ( $ number ) ; if ( $ divisible ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cari nombor lain apabila LCM dan HCF diberikan | Fungsi yang akan mengira sifar pada akhir; Kod pemacu; Fungsi panggilan.", "code": "< ? php function otherNumber ( $ A , $ Lcm , $ Hcf ) { return ( $ Lcm * $ Hcf ) / $ A ; } $ A = 8 ; $ Lcm = 8 ; $ Hcf = 1 ; $ result = otherNumber ( $ A , $ Lcm , $ Hcf ) ; echo \" B = \""}
{"text": "Peratusan keseluruhan perubahan daripada perubahan berturut -turut | Pelaksanaan PHP pendekatan di atas; Kirakan perubahan berturut -turut 1 ST 2 perubahan; Kirakan perubahan berturut -turut untuk sisa nilai; Kod pemacu; Fungsi panggilan", "code": "< ? php function successiveChange ( $ arr , $ N ) { $ result = 0 ; $ var1 = $ arr [ 0 ] ; $ var2 = $ arr [ 1 ] ; $ result = $ var1 + $ var2 + ( ( $ var1 * $ var2 ) / 100 ) ; for ( $ i = 2 ; $ i < $ N ; $ i ++ ) $ result = $ result + $ arr [ $ i ] + ( ( $ result * $ arr [ $ i ] ) / 100 ) ; return $ result ; } $ arr = array ( 10 , 20 , 30 , 10 ) ; $ N = count ( $ arr ) ; $ result = successiveChange ( $ arr , $ N ) ; echo \" Percentage ▁ change ▁ is ▁ = ▁ \" , $ result , \" ▁ % \" ; ? >"}
{"text": "Nombor minimum (lebih kecil daripada atau sama dengan n) dengan jumlah s | Fungsi untuk mencari nombor minimum yang diperlukan untuk sampai ke S; Kod pemacu", "code": "< ? php function minimumNumbers ( $ n , $ s ) { if ( $ s % $ n ) return round ( $ s / $ n + 1 ) ; else return round ( $ s / $ n ) ; } $ n = 5 ; $ s = 11 ; echo minimumNumbers ( $ n , $ s ) ; ? >"}
{"text": "Jumlah gandaan a dan b kurang daripada n | Program PHP untuk mencari jumlah semua gandaan A dan B di bawah n; Fungsi untuk mencari jumlah siri AP; Bilangan istilah; Berfungsi untuk mencari jumlah semua gandaan a dan b di bawah n; Oleh kerana, kita memerlukan jumlah gandaan kurang daripada n; faktor umum A dan B; Kod pemacu", "code": "< ? php function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } function sumAP ( $ n , $ d ) { $ n = ( int ) ( $ n / $ d ) ; return ( $ n ) * ( 1 + $ n ) * $ d / 2 ; } function sumMultiples ( $ A , $ B , $ n ) { $ n -- ; $ common = ( int ) ( ( $ A * $ B ) / __gcd ( $ A , $ B ) ) ; return sumAP ( $ n , $ A ) + sumAP ( $ n , $ B ) - sumAP ( $ n , $ common ) ; } $ n = 100 ; $ A = 5 ; $ B = 10 ; echo \" Sum = \" ? >"}
{"text": "Semak jika nombor perdana boleh dinyatakan sebagai jumlah dua nombor utama | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Berfungsi untuk memeriksa sama ada nombor perdana boleh dinyatakan sebagai jumlah dua nombor utama; Jika nombor itu adalah perdana, dan nombor - 2 juga utama; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) return false ; } return true ; } function isPossible ( $ N ) { if ( isPrime ( $ N ) && isPrime ( $ N - 2 ) ) return true ; else return false ; } $ n = 13 ; if ( isPossible ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Sub terbesar | berfungsi untuk mengembalikan panjang sub -sub - pelbagai array setiap elemen yang merupakan persegi yang sempurna; Jika kedua -dua A dan B adalah sama maka Arr [i] adalah persegi yang sempurna; Kod pemacu", "code": "< ? php function contiguousPerfectSquare ( $ arr , $ n ) { $ current_length = 0 ; $ max_length = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ b = ( float ) sqrt ( $ arr [ $ i ] ) ; $ a = ( int ) $ b ; if ( $ a == $ b ) $ current_length = $ current_length + 1 ; else $ current_length = 0 ; $ max_length = max ( $ max_length , $ current_length ) ; } return $ max_length ; } $ arr = array ( 9 , 75 , 4 , 64 , 121 , 25 ) ; $ n = sizeof ( $ arr ) ; echo contiguousPerfectSquare ( $ arr , $ n ) ; ? >"}
{"text": "Kira pasangan nombor dari 1 hingga n dengan produk yang boleh dibahagi dengan jumlah mereka | Berfungsi untuk mengira pasangan; pembolehubah untuk menyimpan kiraan; Menjana semua pasangan yang mungkin supaya 1 <= x <y <n; Kod pemacu", "code": "< ? php function countPairs ( $ n ) { $ count = 0 ; for ( $ x = 1 ; $ x < $ n ; $ x ++ ) { for ( $ y = $ x + 1 ; $ y <= $ n ; $ y ++ ) { if ( ( $ y * $ x ) % ( $ y + $ x ) == 0 ) $ count ++ ; } } return $ count ; } $ n = 15 ; echo countPairs ( $ n ) ; ? >"}
{"text": "Cari indeks penunjuk kiri selepas mungkin bergerak dalam array | Fungsi yang mengembalikan indeks penunjuk kiri; Terdapat hanya satu elemen dalam array; Pada mulanya kedua -duanya berada di akhir; Kod pemacu", "code": "< ? php function getIndex ( $ a , $ n ) { if ( $ n == 1 ) return 0 ; $ ptrL = 0 ; $ ptrR = $ n - 1 ; $ sumL = $ a [ 0 ] ; $ sumR = $ a [ $ n - 1 ] ; while ( $ ptrR - $ ptrL > 1 ) { if ( $ sumL < $ sumR ) { $ ptrL ++ ; $ sumL += $ a [ $ ptrL ] ; } else if ( $ sumL > $ sumR ) { $ ptrR -- ; $ sumR += $ a [ $ ptrR ] ; } else { break ; } } return $ ptrL ; } $ a = array ( 2 , 7 , 9 , 8 , 7 ) ; $ n = count ( $ a ) ; echo getIndex ( $ a , $ n ) ; ? >"}
{"text": "Cari kedudukan elemen terakhir yang dikeluarkan dari array | Berfungsi untuk mencari kedudukan asal elemen yang akan dikeluarkan terakhir; Ambil ceil setiap nombor; Kerana kedudukan adalah indeks + 1; Kod pemacu", "code": "< ? php function getPosition ( $ a , $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = ( $ a [ $ i ] / $ m + ( $ a [ $ i ] % $ m != 0 ) ) ; } $ ans = -1 ; $ max = -1 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ max < $ a [ $ i ] ) { $ max = $ a [ $ i ] ; $ ans = $ i ; } } return $ ans + 1 ; } $ a = array ( 2 , 5 , 4 ) ; $ n = sizeof ( $ a ) ; $ m = 2 ; echo getPosition ( $ a , $ n , $ m ) ; ? >"}
{"text": "Cari nilai f (n) / f (r) * f (n | berfungsi untuk mencari nilai yang diberikan f (n); berulang ke atas n; hitung hasil; kembalikan hasil;", "code": "< ? php function calcFunction ( $ n , $ r ) { $ finalDenominator = 1 ; $ mx = max ( $ r , $ n - $ r ) ; for ( $ i = $ mx + 1 ; $ i <= $ n ; $ i ++ ) { $ denominator = pow ( $ i , $ i ) ; $ numerator = pow ( $ i - $ mx , $ i - $ mx ) ; $ finalDenominator = ( $ finalDenominator * $ denominator ) / $ numerator ; } return $ finalDenominator ; } $ n = 6 ; $ r = 2 ; echo \"1 / \" , calcFunction ( $ n , $ r ) ; ? >"}
{"text": "Cari nombor selepas bahagian berturut -turut | Berfungsi untuk mencari nombor; Kod pemacu", "code": "< ? php function findNum ( $ div , $ rem , $ N ) { $ num = $ rem [ $ N - 1 ] ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { $ num = $ num * $ div [ $ i ] + $ rem [ $ i ] ; } return $ num ; } $ div = array ( 8 , 3 ) ; $ rem = array ( 2 , 2 ) ; $ N = sizeof ( $ div ) ; echo findNum ( $ div , $ rem , $ N ) ; ? >"}
{"text": "Program untuk mencari keuntungan atau kerugian apabila CP of N item adalah sama dengan SP of M Item | Berfungsi untuk mengira keuntungan atau kerugian; Kod pemacu", "code": "< ? php function profitLoss ( $ N , $ M ) { if ( $ N == $ M ) echo \" No ▁ Profit ▁ nor ▁ Loss \" ; else { $ result = 0.0 ; $ result = ( abs ( $ N - $ M ) ) / $ M ; if ( $ N - $ M < 0 ) echo \" Loss ▁ = ▁ - \" , $ result * 100 , \" % \" ; else echo \" Profit ▁ = ▁ \" , $ result * 100 , \" % \" ; } } $ N = 8 ; $ M = 9 ; profitLoss ( $ N , $ M ) ; ? >"}
{"text": "Mengira kepingan bulatan selepas pemotongan n | Berfungsi untuk mencari bilangan kepingan bulatan selepas pemotongan n; Kod pemacu", "code": "< ? php function countPieces ( $ N ) { return 2 * $ N ; } $ N = 100 ; echo countPieces ( $ N ) ; ? >"}
{"text": "Jumlah semua gandaan 3 dan 7 di bawah n | Fungsi untuk mencari jumlah siri AP; Bilangan istilah; Berfungsi untuk mencari jumlah semua gandaan 3 dan 7 di bawah n; Oleh kerana, kita memerlukan jumlah gandaan kurang daripada n; Kod pemacu", "code": "< ? php function sumAP ( $ n , $ d ) { $ n = ( int ) ( $ n / $ d ) ; return ( $ n ) * ( 1 + $ n ) * ( $ d / 2 ) ; } function sumMultiples ( $ n ) { $ n -- ; return sumAP ( $ n , 3 ) + sumAP ( $ n , 7 ) - sumAP ( $ n , 21 ) ; } $ n = 24 ; echo sumMultiples ( $ n ) ; ? >"}
{"text": "Semak sama ada produk digit di tempat -tempat yang boleh dibahagikan dengan jumlah digit di tempat ganjil nombor | Di bawah fungsi memeriksa sama ada produk digit di tempat -tempat yang boleh dibahagikan dengan jumlah digit di tempat yang ganjil; jika saiznya juga; jika saiz ganjil; Kod pemacu", "code": "< ? php function productSumDivisible ( $ n , $ size ) { $ sum = 0 ; $ product = 1 ; while ( $ n > 0 ) { if ( $ size % 2 == 0 ) { $ product *= $ n % 10 ; } else { $ sum += $ n % 10 ; } $ n = $ n / 10 ; $ size -- ; } if ( $ product % $ sum == 0 ) return true ; return false ; } $ n = 1234 ; $ len = 4 ; if ( productSumDivisible ( $ n , $ len ) ) echo \" TRUE \" ; else echo \" FALSE \" ; ? >"}
{"text": "GCD nombor yang dibangkitkan kepada beberapa kuasa dan nombor lain | Program PHP untuk mencari GCD A ^ n dan B; Mengembalikan GCD A ^ n dan b. ; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function powGCD ( $ a , $ n , $ b ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ a = $ a * $ a ; return gcd ( $ a , $ b ) ; } $ a = 10 ; $ b = 5 ; $ n = 2 ; echo powGCD ( $ a , $ n , $ b ) ; ? >"}
{"text": "Kedudukan selepas mengambil langkah N ke kanan dan kiri dengan cara alternatif | Berfungsi untuk mengembalikan destinasi terakhir; Kod pemacu", "code": "< ? php function lastCoordinate ( $ n , $ a , $ b ) { return ( ( $ n + 1 ) / 2 ) * $ a - ( int ) ( $ n / 2 ) * $ b ; } $ n = 3 ; $ a = 5 ; $ b = 2 ; echo lastCoordinate ( $ n , $ a , $ b ) ; ? >"}
{"text": "Nombor terkecil lebih besar daripada atau sama dengan n dibahagi oleh k | Berfungsi untuk mencari nombor terkecil yang lebih besar daripada atau sama dengan n yang boleh dibahagikan oleh k; Kod pemacu", "code": "< ? php function findNum ( $ N , $ K ) { $ rem = ( $ N + $ K ) % $ K ; if ( $ rem == 0 ) return $ N ; else return $ N + $ K - $ rem ; } $ N = 45 ; $ K = 6 ; echo \" Smallest ▁ number ▁ greater ▁ than ▁ \" . \" or ▁ equal ▁ to ▁ \" , $ N ; echo \" that is divisible by \" ▁ , ▁ $ K ▁ , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" is \" ? >"}
{"text": "Jumlah dan produk digit dalam nombor yang membahagikan nombor | Cetak jumlah dan produk digit yang membahagikan nombor. ; Mengambil setiap digit nombor; Memeriksa jika digit lebih besar daripada 0 dan boleh membahagikan n. ; Kod pemacu", "code": "< ? php function countDigit ( $ n ) { $ temp = $ n ; $ sum = 0 ; $ product = 1 ; while ( $ temp != 0 ) { $ d = $ temp % 10 ; $ temp = ( int ) ( $ temp / 10 ) ; if ( $ d > 0 && $ n % $ d == 0 ) { $ sum += $ d ; $ product *= $ d ; } } echo \" Sum = \" . $ sum ; STRNEWLINE TABSYMBOL echo ▁ \" Product = \" } $ n = 1012 ; countDigit ( $ n ) ; ? >"}
{"text": "Nombor terbesar yang lebih kecil daripada atau sama dengan N dibahagi dengan k | Berfungsi untuk mencari bilangan terbesar yang lebih kecil daripada atau sama dengan n yang boleh dibahagikan oleh k; Kod pemacu", "code": "< ? php function findNum ( $ N , $ K ) { $ rem = $ N % $ K ; if ( $ rem == 0 ) return $ N ; else return $ N - $ rem ; } $ N = 45 ; $ K = 6 ; echo \" Largest ▁ number ▁ smaller ▁ than ▁ or ▁ equal ▁ to ▁ \" , $ N , \" that is divisible by \" , ▁ $ K , ▁ \" is \" findNum ( $ N , $ K ) ; ? >"}
{"text": "Semak jika ada permutasi nombor yang boleh dibahagikan dengan 3 dan Palindromic | Berfungsi untuk memeriksa sama ada sebarang permutasi nombor boleh dibahagikan dengan 3 dan adalah palindromik; Arahan hash untuk menyimpan kekerapan digit N; melintasi digit integer dan menyimpan kekerapan mereka; Kirakan jumlah digit secara serentak; Periksa sama ada nombor tidak dapat dibahagikan dengan 3; Jika lebih daripada satu digit mempunyai kekerapan ganjil, permutasi palindromik tidak mungkin; Kod pemacu", "code": "< ? php function isDivisiblePalindrome ( $ n ) { $ hash = array ( 0 ) ; $ digitSum = 0 ; while ( $ n ) { $ digitSum += $ n % 10 ; $ hash ++ ; $ n /= 10 ; } if ( $ digitSum % 3 != 0 ) return false ; $ oddCount = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { if ( $ hash % 2 != 0 ) $ oddCount ++ ; } if ( $ oddCount > 1 ) return true ; else return false ; } $ n = 34734 ; if ( isDivisiblePalindrome ( $ n ) ) echo \" True \" ; else echo \" False \" ; # This  Code is contributed by Tushill. NEW_LINE ? >"}
{"text": "Semak sama ada produk digit di tempat -tempat nombor boleh dibahagikan dengan k | Di bawah fungsi pemeriksaan sama ada produk digit di tempat -tempat yang boleh dibahagikan oleh k; jika kedudukannya juga; Kod pemacu", "code": "< ? php function productDivisible ( $ n , $ k ) { $ product = 1 ; $ position = 1 ; while ( $ n > 0 ) { if ( $ position % 2 == 0 ) $ product *= $ n % 10 ; $ n = ( int ) ( $ n / 10 ) ; $ position ++ ; } if ( $ product % $ k == 0 ) return true ; return false ; } $ n = 321922 ; $ k = 3 ; if ( productDivisible ( $ n , $ k ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Permutasi perkara n diambil pada satu masa dengan perkara bersama -sama | Berfungsi untuk mencari faktorial nombor; Berfungsi untuk mengira p (n, r); Fungsi untuk mencari bilangan permutasi n perkara yang berbeza yang diambil pada satu masa dengan perkara -perkara yang dikumpulkan bersama; Kod pemacu", "code": "< ? php function factorial ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ fact = $ fact * $ i ; return $ fact ; } function npr ( $ n , $ r ) { $ pnr = factorial ( $ n ) / factorial ( $ n - $ r ) ; return $ pnr ; } function countPermutations ( $ n , $ r , $ k ) { return factorial ( $ k ) * ( $ r - $ k + 1 ) * npr ( $ n - $ k , $ r - $ k ) ; } $ n = 8 ; $ r = 5 ; $ k = 2 ; echo countPermutations ( $ n , $ r , $ k ) ; ? >"}
{"text": "Fungsi Integer Terhebat | Fungsi untuk mengira nilai gif nombor; GIF adalah lantai nombor; Kod pemacu", "code": "< ? php function GIF ( $ n ) { return floor ( $ n ) ; } $ n = 2.3 ; echo GIF ( $ n ) ; ? >"}
{"text": "Bilangan segitiga terbentuk dari satu set mata pada tiga baris | Mengembalikan faktorial nombor; hitung c (n, r); Kod pemacu", "code": "< ? php function factorial ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ fact = $ fact * $ i ; return $ fact ; } function ncr ( $ n , $ r ) { return factorial ( $ n ) / ( factorial ( $ r ) * factorial ( $ n - $ r ) ) ; } $ m = 3 ; $ n = 4 ; $ k = 5 ; $ totalTriangles = ncr ( $ m + $ n + $ k , 3 ) - ncr ( $ m , 3 ) - ncr ( $ n , 3 ) - ncr ( $ k , 3 ) ; echo $ totalTriangles . \" STRNEWLINE \" ;"}
{"text": "Semak sama ada jumlah digit di tempat ganjil nombor boleh dibahagikan dengan k | Fungsi yang memeriksa pembahagian jumlah digit di tempat ganjil nombor yang diberikan; Jika kedudukan ganjil; Kod pemacu", "code": "< ? php function SumDivisible ( $ n , $ k ) { $ sum = 0 ; $ position = 1 ; while ( $ n > 0 ) { if ( $ position % 2 == 1 ) $ sum += $ n % 10 ; $ n = ( int ) $ n / 10 ; $ position ++ ; } if ( $ sum % $ k == 0 ) return true ; return false ; } $ n = 592452 ; $ k = 3 ; if ( SumDivisible ( $ n , $ k ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Semak jika segitiga kawasan positif mungkin dengan sudut yang diberikan | Program PHP untuk memeriksa sama ada segitiga kawasan positif mungkin dengan sudut yang diberikan; Memeriksa jika jumlah tiga sudut adalah 180 dan tidak ada sudut yang sifar; Memeriksa jika jumlah mana -mana dua sudut lebih besar daripada yang sama dengan yang ketiga; Kod pemacu", "code": "< ? php function isTriangleExists ( $ a , $ b , $ c ) { if ( $ a != 0 && $ b != 0 && $ c != 0 && ( $ a + $ b + $ c ) == 180 ) if ( ( $ a + $ b ) >= $ c || ( $ b + $ c ) >= $ a || ( $ a + $ c ) >= $ b ) return \" YES \" ; else return \" NO \" ; else return \" NO \" ; } $ a = 50 ; $ b = 60 ; $ c = 70 ; echo isTriangleExists ( $ a , $ b , $ c ) ; ? >"}
{"text": "Cari nilai maksimum x seperti n! % (k ^ x) = 0 | Berfungsi untuk memaksimumkan nilai x seperti n! % (k ^ x) = 0; Cari akar persegi k dan tambah 1 kepadanya; Jalankan gelung dari 2 hingga m dan k hendaklah lebih besar daripada 1; Mengoptimumkan nilai k; Kedai minimum; Kod pemacu", "code": "< ? php function findX ( $ n , $ k ) { $ r = $ n ; $ m = ( int ) sqrt ( $ k ) + 1 ; for ( $ i = 2 ; $ i <= $ m && $ k > 1 ; $ i ++ ) { if ( $ i == $ m ) { $ i = $ k ; } for ( $ u = $ v = 0 ; $ k % $ i == 0 ; $ v ++ ) { $ k = ( int ) ( $ k / $ i ) ; } if ( $ v > 0 ) { $ t = $ n ; while ( $ t > 0 ) { $ t = ( int ) ( $ t / $ i ) ; $ u = $ u + $ t ; } $ r = min ( $ r , ( int ) ( $ u / $ v ) ) ; } } return $ r ; } $ n = 5 ; $ k = 2 ; echo findX ( $ n , $ k ) ; ? >"}
{"text": "Cara Memilih Lelaki dan Wanita dari Kumpulan Untuk Membuat Pasukan | Mengembalikan faktorial nombor; Fungsi untuk mengira NCR; Fungsi untuk mengira jumlah cara yang mungkin; Kod pemacu", "code": "< ? php function fact ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ fact *= $ i ; return $ fact ; } function ncr ( $ n , $ r ) { $ ncr = ( int ) ( fact ( $ n ) / ( fact ( $ r ) * fact ( $ n - $ r ) ) ) ; return $ ncr ; } function ways ( $ m , $ w , $ n , $ k ) { $ ans = 0 ; while ( $ m >= $ k ) { $ ans += ncr ( $ m , $ k ) * ncr ( $ w , $ n - $ k ) ; $ k += 1 ; } return $ ans ; } $ m = 7 ; $ w = 6 ; $ n = 5 ; $ k = 3 ; echo ways ( $ m , $ w , $ n , $ k ) ;"}
{"text": "Jumlah pembahagi ganjil yang paling hebat dalam julat yang diberikan | Berfungsi untuk mengembalikan jumlah nombor pertama yang pertama; Fungsi rekursif untuk mengembalikan jumlah pembahagi ganjil yang paling besar dalam julat [1, n]; {Odd n; {Walaupun n; Berfungsi untuk mengembalikan jumlah pembahagi ganjil yang paling besar dalam julat [a, b]; Kod pemacu", "code": "< ? php function square ( $ n ) { return $ n * $ n ; } function sum ( $ n ) { if ( $ n == 0 ) return 0 ; if ( $ n % 2 == 1 ) return square ( ( int ) ( ( $ n + 1 ) / 2 ) ) + sum ( ( int ) ( $ n / 2 ) ) ; } else return square ( ( int ) ( $ n / 2 ) ) + sum ( ( int ) ( $ n / 2 ) ) ; } } function oddDivSum ( $ a , $ b ) { return sum ( $ b ) - sum ( $ a - 1 ) ; } $ a = 3 ; $ b = 9 ; echo oddDivSum ( $ a , $ b ) ; ? >"}
{"text": "Nombor minimum yang diperlukan untuk menyatakan setiap integer di bawah n sebagai jumlah | fungsi untuk mengira panjang ekspresi binari n; Kod pemacu", "code": "< ? php function countBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count ++ ; $ n >>= 1 ; } return $ count ; } $ n = 32 ; echo \" Minimum ▁ value ▁ of ▁ K ▁ is ▁ = ▁ \" , countBits ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak sama ada nombor adalah nombor Achilles atau tidak | Berfungsi untuk memeriksa sama ada nombor itu adalah nombor yang kuat; Pertama membahagikan nombor berulang kali dengan 2; Jika hanya 2 ^ 1 membahagikan n (tidak kuasa yang lebih tinggi), maka kembali palsu; Jika n bukan kuasa 2 maka gelung ini akan melaksanakan proses ulangi di atas; Cari kuasa tertinggi \"faktor\" yang membahagikan n; Jika hanya faktor ^ 1 membahagikan n (tidak kuasa yang lebih tinggi), maka kembali palsu; n mestilah 1 sekarang jika bukan nombor utama. Oleh kerana nombor perdana tidak berkuasa, kita kembali palsu jika n tidak 1 .; Fungsi utiliti untuk memeriksa sama ada nombor adalah kuasa yang sempurna atau tidak; Berfungsi untuk memeriksa nombor achilles; Kod pemacu", "code": "< ? php function isPowerful ( $ n ) { while ( $ n % 2 == 0 ) { $ power = 0 ; while ( $ n % 2 == 0 ) { $ n /= 2 ; $ power ++ ; } if ( $ power == 1 ) return false ; } for ( $ factor = 3 ; $ factor <= sqrt ( $ n ) ; $ factor += 2 ) { $ power = 0 ; while ( $ n % $ factor == 0 ) { $ n = $ n / $ factor ; $ power ++ ; } if ( $ power == 1 ) return false ; } return ( $ n == 1 ) ; } function isPower ( $ a ) { if ( $ a == 1 ) return true ; for ( $ i = 2 ; $ i * $ i <= $ a ; $ i ++ ) { $ val = log ( $ a ) / log ( $ i ) ; if ( ( $ val - ( int ) $ val ) < 0.00000001 ) return true ; } return false ; } function isAchillesNumber ( $ n ) { if ( isPowerful ( $ n ) && ! isPower ( $ n ) ) return true ; else return false ; } $ n = 72 ; if ( isAchillesNumber ( $ n ) ) echo \" YES \" , \" STRNEWLINE \" ; else echo \" NO \" , \" STRNEWLINE \" ; $ n = 36 ; if ( isAchillesNumber ( $ n ) ) echo \" YES \" , \" STRNEWLINE \" ; else echo \" NO \" , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari kiraan nombor yang mempunyai bilangan pembahagi ganjil dalam julat yang diberikan | Fungsi untuk mengira nombor yang mempunyai bilangan pembahagi yang ganjil dalam julat [a, b]; pemboleh ubah kepada kiraan pembahagi ganjil; berulang dari A ke B dan mengira jumlah pembahagi mereka; pemboleh ubah kepada kiraan pembahagi; Jika Count of Devisor adalah ganjil maka tambah res dengan 1; Kod pemacu", "code": "< ? php function OddDivCount ( $ a , $ b ) { $ res = 0 ; for ( $ i = $ a ; $ i <= $ b ; ++ $ i ) { $ divCount = 0 ; for ( $ j = 1 ; $ j <= $ i ; ++ $ j ) { if ( $ i % $ j == 0 ) { ++ $ divCount ; } } if ( $ divCount % 2 ) { ++ $ res ; } } return $ res ; } $ a = 1 ; $ b = 10 ; echo OddDivCount ( $ a , $ b ) ; ? >"}
{"text": "Faktor terbesar nombor tertentu yang merupakan persegi yang sempurna | Berfungsi untuk mencari faktor terbesar nombor tertentu yang merupakan persegi yang sempurna; Memulakan jawapan kepada 1; Mencari faktor utama sehingga sqrt (num); Kekerapan faktor utama dalam faktorisasi yang dimulakan kepada 0; Jika kekerapan adalah ganjil maka darabkan frekuensi saya - 1 kali untuk jawapannya; Lain jika walaupun, kalikan masa kekerapannya; Kod pemacu", "code": "< ? php function largestSquareFactor ( $ num ) { $ answer = 1 ; for ( $ i = 2 ; $ i < sqrt ( $ num ) ; ++ $ i ) { $ cnt = 0 ; $ j = $ i ; while ( $ num % $ j == 0 ) { $ cnt ++ ; $ j *= $ i ; } if ( $ cnt & 1 ) { $ cnt -- ; $ answer *= pow ( $ i , $ cnt ) ; } else { $ answer *= pow ( $ i , $ cnt ) ; } } return $ answer ; } $ N = 420 ; echo largestSquareFactor ( $ N ) ; ? >"}
{"text": "Cari istilah n Siri 2 + 6 + 13 + 23 +. . . | Hitung istilah n siri yang diberikan; Kod pemacu", "code": "< ? php function Nth_Term ( $ n ) { return ( 3 * pow ( $ n , 2 ) - $ n + 2 ) / ( 2 ) ; } $ N = 5 ; echo ( Nth_Term ( $ N ) ) ; ? >"}
{"text": "Semua kemungkinan nombor N digit dan Base B tanpa nol utama | berfungsi untuk mengira semua permutasi; mengira semua permutasi; mengira permutasi dengan sifar terkemuka; Mengembalikan permutasi tanpa nol utama; Kod pemacu", "code": "< ? php function countPermutations ( $ N , $ B ) { $ x = pow ( $ B , $ N ) ; $ y = pow ( $ B , $ N - 1 ) ; echo ( $ x - $ y ) , \" STRNEWLINE \" ; } $ N = 6 ; $ B = 4 ; countPermutations ( $ N , $ B ) ; ? >"}
{"text": "Perbezaan mutlak antara produk bukan | Berfungsi untuk mencari perbezaan antara produk bukan prima dan produk prima array. ; Cari nilai maksimum dalam array; Gunakan ayak untuk mencari semua nombor perdana kurang daripada atau sama dengan max_val Buat array boolean \"Perdana [0 ... N]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Baki bahagian Sieve; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Simpan produk prima dalam P1 dan produk bukan prima dalam P2; Nombor itu adalah perdana; Nombor itu bukan perdana; Mengembalikan perbezaan mutlak; Kod pemacu; Cari perbezaan mutlak", "code": "< ? php function calculateDifference ( $ arr , $ n ) { $ max_val = max ( $ arr ) ; $ prime = array_fill ( 0 , $ max_val , true ) ; $ prime [ 0 ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ max_val ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ max_val ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ P1 = 1 ; $ P2 = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ prime [ $ arr [ $ i ] ] ) { $ P1 *= $ arr [ $ i ] ; } else if ( $ arr [ $ i ] != 1 ) { $ P2 *= $ arr [ $ i ] ; } } return abs ( $ P2 - $ P1 ) ; } $ arr = array ( 1 , 3 , 5 , 10 , 15 , 7 ) ; $ n = count ( $ arr , COUNT_NORMAL ) ; echo CalculateDifference ( $ arr , $ n ) ; ? >"}
{"text": "Kiraan maksimum nombor yang sama dalam array selepas melakukan operasi yang diberikan | Berfungsi untuk mencari bilangan maksimum nombor yang sama dalam array; untuk menyimpan jumlah elemen; Jika jumlah nombor tidak dapat dibahagikan dengan n; Kod pemacu; saiz array", "code": "< ? php function EqualNumbers ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; if ( $ sum % $ n ) return $ n - 1 ; return $ n ; } $ a = array ( 1 , 4 , 1 ) ; $ n = sizeof ( $ a ) ; echo EqualNumbers ( $ a , $ n ) ;"}
{"text": "Kira bilangan pasangan yang diperintahkan dengan jumlah yang lebih baik dan ganjil | berfungsi untuk mengira pasangan jumlah ganjil; jika nombor juga; jika nombor ganjil; kiraan pasangan yang diperintahkan; berfungsi untuk mengira pasangan jumlah; Kod pemacu", "code": "< ? php function count_odd_pair ( $ n , $ a ) { $ odd = 0 ; $ even = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 == 0 ) $ even ++ ; else $ odd ++ ; } $ ans = $ odd * $ even * 2 ; return $ ans ; } function count_even_pair ( $ odd_sum_pairs , $ n ) { $ total_pairs = ( $ n * ( $ n - 1 ) ) ; $ ans = $ total_pairs - $ odd_sum_pairs ; return $ ans ; } $ n = 6 ; $ a = array ( 2 , 4 , 5 , 9 , 1 , 8 ) ; $ odd_sum_pairs = count_odd_pair ( $ n , $ a ) ; $ even_sum_pairs = count_even_pair ( $ odd_sum_pairs , $ n ) ; echo \" Even ▁ Sum ▁ Pairs ▁ = ▁ $ even _ sum _ pairs ▁ STRNEWLINE \" ; echo \" Odd ▁ Sum ▁ Pairs = ▁ $ odd _ sum _ pairs ▁ STRNEWLINE \" ; ? >"}
{"text": "Langkah -langkah yang diperlukan untuk melawat mata M dalam rangka pada cincin bulat N Points | Fungsi untuk mengira langkah -langkah yang diperlukan; Bermula pada 1; Memulakan langkah; Jika NXT lebih besar daripada CUR; Sekarang kita berada di [i]; Kod pemacu", "code": "< ? php function findSteps ( $ n , $ m , $ a ) { $ cur = 1 ; $ steps = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ a [ $ i ] >= $ cur ) $ steps += ( $ a [ $ i ] - $ cur ) ; else $ steps += ( $ n - $ cur + $ a [ $ i ] ) ; $ cur = $ a [ $ i ] ; } return $ steps ; } $ n = 3 ; $ m = 3 ; $ a = array ( 2 , 1 , 2 ) ; echo findSteps ( $ n , $ m , $ a ) ; ? >"}
{"text": "Program untuk menukar nombor heksadesimal kepada binari | berfungsi untuk menukar heksadesimal kepada nombor binari; Dapatkan nombor heksadesimal; Menukar heksadesimal ke binari", "code": "< ? php function HexToBin ( $ hexdec ) { $ i = 0 ; while ( $ hexdec [ $ i ] ) { switch ( $ hexdec [ $ i ] ) { case '0' : echo \"0000\" ; break ; case '1' : echo \"0001\" ; break ; case '2' : echo \"0010\" ; break ; case '3' : echo \"0011\" ; break ; case '4' : echo \"0100\" ; break ; case '5' : echo \"0101\" ; break ; case '6' : echo \"0110\" ; break ; case '7' : echo \"0111\" ; break ; case '8' : echo \"1000\" ; break ; case '9' : echo \"1001\" ; break ; case ' A ' : case ' a ' : echo \"1010\" ; break ; case ' B ' : case ' b ' : echo \"1011\" ; break ; case ' C ' : case ' c ' : echo \"1100\" ; break ; case ' D ' : case ' d ' : echo \"1101\" ; break ; case ' E ' : case ' e ' : echo \"1110\" ; break ; case ' F ' : case ' f ' : echo \"1111\" ; break ; default : echo \" Invalid hexadecimal digit \" $ hexdec [ $ i ] ; } $ i ++ ; } } $ hexdec = \"1AC5\" ; echo \" Equivalent Binary value is : \" HexToBin ( $ hexdec ) ;"}
{"text": "Kira pasangan yang tidak teratur (i, j) seperti produk [i] dan a [j] adalah kuasa dua | Fungsi untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Berfungsi untuk mengira pasangan yang tidak teratur; adalah nombor boleh dinyatakan sebagai kuasa dua; mengira jumlah pasangan yang tidak teratur; Kod pemacu", "code": "< ? php function isPowerOfTwo ( $ x ) { return ( $ x && ( ! ( $ x & ( $ x - 1 ) ) ) ) ; } function Count_pairs ( $ a , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( isPowerOfTwo ( $ a [ $ i ] ) ) $ count ++ ; } $ ans = ( $ count * ( $ count - 1 ) ) / 2 ; echo $ ans , \" STRNEWLINE \" ; } $ a = array ( 2 , 5 , 8 , 16 , 128 ) ; $ n = sizeof ( $ a ) ; Count_pairs ( $ a , $ n ) ; ? >"}
{"text": "Cara membahagikan kumpulan menjadi dua bahagian sedemikian rupa sehingga dua elemen berada dalam kumpulan yang berbeza | Fungsi ini akan mengembalikan faktorial nombor tertentu; Fungsi ini akan mengira NCR diberikan N dan R; Fungsi ini akan mengira bilangan cara; Kod pemacu", "code": "< ? php function factorial ( $ n ) { $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ result = $ result * $ i ; return $ result ; } function nCr ( $ n , $ r ) { return factorial ( $ n ) / ( factorial ( $ r ) * factorial ( $ n - $ r ) ) ; } function calculate_result ( $ n ) { $ result = 2 * nCr ( ( $ n - 2 ) , ( $ n / 2 - 1 ) ) ; return $ result ; } $ a = 2 ; $ b = 4 ; echo calculate_result ( 2 * $ a ) . \" STRNEWLINE \" ; echo calculate_result ( 2 * $ b ) . \" STRNEWLINE \" ; ? >"}
{"text": "Cetak Nilai 'A' dalam Persamaan (A + B) <= N dan A + B boleh dibahagikan dengan x | Fungsi untuk mencari nilai a, dalam persamaan (a + b) <= n dan a + b boleh dibahagikan dengan x. ; paling tidak mungkin yang boleh dibahagikan dengan x; Jalankan gelung untuk mendapatkan jawapan yang diperlukan; Meningkatkan nilai dengan x; jawapan adalah mungkin; Kod pemacu; panggilan fungsi", "code": "< ? php function PossibleValues ( $ b , $ x , $ n ) { $ leastdivisible = ( intval ( $ b / $ x ) + 1 ) * $ x ; $ flag = 1 ; while ( $ leastdivisible <= $ n ) { if ( $ leastdivisible - $ b >= 1 ) { echo $ leastdivisible - $ b . \" \" ; $ leastdivisible += $ x ; $ flag = 0 ; } else break ; } if ( $ flag ) echo \" - 1\" ; } $ b = 10 ; $ x = 6 ; $ n = 40 ; PossibleValues ( $ b , $ x , $ n ) ; ? >"}
{"text": "Semak jika semua sub | Fungsi untuk mengira produk digit antara indeks yang diberikan; Berfungsi untuk memeriksa sama ada semua sub -nombor mempunyai produk digit yang berbeza; Panjang nombor n; Pelbagai digit; untuk mengekalkan produk digit; Mencari semua subarray yang mungkin; Kod pemacu", "code": "< ? php function digitProduct ( $ digits , $ start , $ end ) { $ pro = 1 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { $ pro *= $ digits [ $ i ] ; } return $ pro ; } function isDistinct ( $ N ) { $ s = \" $ N \" ; $ len = sizeof ( $ s ) ; $ digits = array ( ) ; $ products = array ( ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ digits [ $ i ] = $ s [ $ i ] - '0' ; } for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { for ( $ j = $ i ; $ j < $ len ; $ j ++ ) { $ val = digitProduct ( $ digits , $ i , $ j ) ; if ( in_array ( $ val , $ products ) ) return false ; else array_push ( $ products , $ val ) ; } } return true ; } $ N = 324 ; if ( isDistinct ( $ N ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Hilbert Number | Fungsi utiliti untuk mengembalikan nombor Hilbert n; Kod pemacu", "code": "< ? php function nthHilbertNumber ( $ n ) { return 4 * ( $ n - 1 ) + 1 ; } $ n = 5 ; echo nthHilbertNumber ( $ n ) ; ? >"}
{"text": "Program untuk mencari nombor nth kynea | Berfungsi untuk mengira nombor kynea nth; Pertama hitung 2 ^ n + 1; Sekarang hitung (2 ^ n + 1) ^ 2; Sekarang hitung ((2 ^ n + 1) ^ 2) - 2; kembali nombor kynea nth; Kod pemacu; Cetak nombor kynea nth", "code": "< ? php function nthKyneaNumber ( $ n ) { $ n = ( 1 << $ n ) + 1 ; $ n = $ n * $ n ; $ n = $ n - 2 ; return $ n ; } $ n = 8 ; echo nthKyneaNumber ( $ n ) ;"}
{"text": "Program untuk mencari nombor nth kynea | Berfungsi untuk mengira nombor kynea nth; Hitung nombor kynea nth; Kod pemacu; Cetak nombor kynea nth", "code": "< ? php function nthKyneaNumber ( $ n ) { return ( ( 1 << ( 2 * $ n ) ) + ( 1 << ( $ n + 1 ) ) - 1 ) ; } $ n = 2 ; echo nthKyneaNumber ( $ n ) ; ? >"}
{"text": "Program untuk memeriksa sama ada nombor adalah nombor proth atau tidak | Fungsi utiliti untuk memeriksa kuasa dua; Berfungsi untuk memeriksa sama ada nombor yang diberikan adalah nombor proth atau tidak; periksa sama ada k membahagikan n atau tidak; Periksa sama ada N / K adalah kuasa 2 atau tidak; Kemas kini K ke nombor ganjil seterusnya; Sekiranya kita sampai di sini bermakna tidak ada nilai k sedemikian rupa sehingga k adalah nombor ganjil dan n / k adalah kuasa 2 lebih besar daripada k; Dapatkan n; Periksa n untuk nombor proth", "code": "< ? php function isPowerOfTwo ( $ n ) { return ( $ n && ! ( $ n & ( $ n - 1 ) ) ) ; } function isProthNumber ( $ n ) { $ k = 1 ; while ( $ k < ( $ n / $ k ) ) { if ( $ n % $ k == 0 ) { if ( isPowerOfTwo ( $ n / $ k ) ) return true ; } $ k = $ k + 2 ; } return false ; } $ n = 25 ; if ( isProthNumber ( $ n - 1 ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Cari dua digit terakhir jumlah N Factorials | Berfungsi untuk mencari unit tempat angka unit; Marilah kita tulis untuk kes apabila n lebih kecil daripada atau sama dengan 10 .; Kami tahu berikut (1! + 2! + 3! + 4! ... + 10!) % 100 = 13 lain (n> = 10); Kod pemacu", "code": "< ? php function get_last_two_digit ( $ N ) { if ( $ N <= 10 ) { $ ans = 0 ; $ fac = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ fac = $ fac * $ i ; $ ans += $ fac ; } return $ ans % 100 ; } return 13 ; } $ N = 1 ; for ( $ N = 1 ; $ N <= 10 ; $ N ++ ) echo \" For ▁ N ▁ = ▁ \" . $ N . \" ▁ : ▁ \" . get_last_two_digit ( $ N ) . \" STRNEWLINE \" ;"}
{"text": "Semak sama ada produk 'N' nombor adalah atau ganjil | berfungsi untuk memeriksa sama ada produk 'n' nombor adalah atau ganjil; Sekiranya nombor tunggal dijumpai, maka produk akhir akan menjadi nombor yang sama; Produk adalah nombor ganjil; Kod pemacu", "code": "< ? php function isProductEven ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( ( $ arr [ $ i ] & 1 ) == 0 ) return true ; return false ; } $ arr = array ( 2 , 4 , 3 , 5 ) ; $ n = sizeof ( $ arr ) ; if ( isProductEven ( $ arr , $ n ) ) echo \" Even \" ; else echo \" Odd \" ; ? >"}
{"text": "Jumlah Squares of Fibonacci Numbers | Berfungsi untuk mengira jumlah kuadrat nombor Fibonacci; Memulakan hasil; Tambah istilah yang tinggal; Kod pemacu", "code": "< ? php function calculateSquareSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = ( $ fibo [ 0 ] * $ fibo [ 0 ] ) + ( $ fibo [ 1 ] * $ fibo [ 1 ] ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; $ sum += ( $ fibo [ $ i ] * $ fibo [ $ i ] ) ; } return $ sum ; } $ n = 6 ; echo \" Sum ▁ of ▁ squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ \" , calculateSquareSum ( $ n ) ; ? >"}
{"text": "Nilai siri (1 ^ 3 + 2 ^ 3 + 3 ^ 3 + ... + n ^ 3) Mod 4 untuk n | fungsi untuk mendapatkan nilai f (n) mod 4; Cari baki n apabila dibahagikan dengan 4; Jika n adalah bentuk 4 k atau 4 k + 3; Jika n adalah bentuk 4 k + 1 atau 4 k + 2; Kod pemacu", "code": "< ? php function fnMod ( $ n ) { $ rem = $ n % 4 ; if ( $ rem == 0 or $ rem == 3 ) return 0 ; else if ( $ rem == 1 or $ rem == 2 ) return 1 ; } $ n = 6 ; echo fnMod ( $ n ) ; ? >"}
{"text": "Operasi kenaikan minimum untuk membuat array dalam peningkatan pesanan | fungsi untuk mencari langkah minimum yang diperlukan untuk membuat array dalam peningkatan urutan; untuk menyimpan jawapan; melangkah ke atas array; perintah yang tidak meningkat; tambah bergerak untuk menjawab; meningkatkan elemen; mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "< ? php function MinimumMoves ( & $ a , $ n , $ x ) { $ ans = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] <= $ a [ $ i - 1 ] ) { $ p = ( $ a [ $ i - 1 ] - $ a [ $ i ] ) / $ x + 1 ; $ ans += $ p ; $ a [ $ i ] += $ p * $ x ; } } return $ ans ; } $ arr = array ( 1 , 3 , 3 , 2 ) ; $ x = 2 ; $ n = sizeof ( $ arr ) ; echo ( ( int ) MinimumMoves ( $ arr , $ n , $ x ) ) ; ? >"}
{"text": "Semak jika sebilangan besar boleh dibahagikan dengan 2, 3 dan 5 atau tidak | berfungsi untuk mengembalikan jumlah digit nombor; berfungsi untuk memeriksa sama ada sebilangan besar boleh dibahagikan dengan 2, 3 dan 5 atau tidak; Kod pemacu", "code": "< ? php function SumOfDigits ( $ str , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( int ) ( $ str [ $ i ] - '0' ) ; return $ sum ; } function Divisible ( $ str , $ n ) { if ( SumOfDigits ( $ str , $ n ) % 3 == 0 and $ str [ $ n - 1 ] == '0' ) return true ; return false ; } $ str = \"263730746028908374890\" ; $ n = strlen ( $ str ) ; if ( Divisible ( $ str , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Kira semua nombor dalam julat dengan faktor terkecil seperti k | Berfungsi untuk memeriksa sama ada k adalah nombor utama atau tidak; Kes sudut; Semak dari 2 hingga n - 1; Fungsi untuk memeriksa sama ada nombor tidak dapat dibahagikan dengan nombor antara 2 dan k - 1; Untuk memeriksa sama ada NUM dibahagikan dengan sebarang nombor antara 2 dan k - 1; jika tidak dibahagikan dengan nombor antara 2 dan k - 1 tetapi dibahagikan oleh k; Fungsi untuk mencari kiraan nombor dalam julat [a, b] dengan faktor terkecil seperti k; Nombor boleh dibahagikan hanya oleh k dan bukan oleh mana -mana nombor kurang daripada k hanya jika k adalah perdana; Untuk memeriksa sama ada nombor mempunyai faktor terkecil seperti k; Kod pemacu", "code": "< ? php function isPrime ( $ k ) { if ( $ k <= 1 ) return false ; for ( $ i = 2 ; $ i < $ k ; $ i ++ ) if ( $ k % $ i == 0 ) return false ; return true ; } function check ( $ num , $ k ) { $ flag = 1 ; for ( $ i = 2 ; $ i < $ k ; $ i ++ ) { if ( $ num % $ i == 0 ) $ flag = 0 ; } if ( $ flag == 1 ) { if ( $ num % $ k == 0 ) return 1 ; else return 0 ; } else return 0 ; } function findCount ( $ a , $ b , $ k ) { $ count = 0 ; if ( ! isPrime ( $ k ) ) return 0 ; else { for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) { $ ans = check ( $ i , $ k ) ; if ( $ ans == 1 ) $ count ++ ; else continue ; } } return $ count ; } $ a = 2020 ; $ b = 6300 ; $ k = 29 ; echo ( findCount ( $ a , $ b , $ k ) ) ; ? >"}
{"text": "Bilangan penyelesaian untuk x <y, di mana <= x <= b dan c <= y <= d dan x, y adalah bilangan bulat | Fungsi untuk mencari bilangan penyelesaian untuk x <y, di mana A <= x <= b dan c <= y <= d dan x, bitar bilangan. ; untuk menyimpan jawapan; melangkah secara eksplisit ke atas semua nilai x yang mungkin; jawapan kembali; Kod pemacu; panggilan fungsi", "code": "< ? php function NumberOfSolutions ( $ a , $ b , $ c , $ d ) { $ ans = 0 ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) if ( $ d >= max ( $ c , $ i + 1 ) ) $ ans += $ d - max ( $ c , $ i + 1 ) + 1 ; return $ ans ; } $ a = 2 ; $ b = 3 ; $ c = 3 ; $ d = 4 ; echo NumberOfSolutions ( $ a , $ b , $ c , $ d ) ; ? >"}
{"text": "Nilai minimum kemungkinan fungsi yang diberikan dari set yang diberikan | Fungsi untuk mencari nilai f (n); Kod pemacu", "code": "< ? php function findF_N ( $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans += ( $ i + 1 ) * ( $ n - $ i - 1 ) ; return $ ans ; } $ n = 3 ; echo findF_N ( $ n ) ;"}
{"text": "Cari nombor digit yang boleh dibahagikan dengan D | Berfungsi untuk mengembalikan nombor digit n yang boleh dibahagikan dengan d; untuk menyimpan jawapan; Kod pemacu", "code": "< ? php function findNumber ( $ n , $ d ) { $ ans = \" \" ; if ( $ d != 10 ) { $ ans . = strval ( $ d ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans . = '0' ; } else { if ( n == 1 ) $ ans . = \" Impossible \" ; else $ ans . = '1' ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans . = '0' ; } return $ ans ; } $ n = 12 ; $ d = 3 ; print ( findNumber ( $ n , $ d ) ) ;"}
{"text": "Kira semua nombor kurang daripada 10 ^ 6 yang faktor utama minimum adalah n | Pelaksanaan PHP pendekatan di atas; penyaring nombor perdana dan kiraan faktor utama minimum; membentuk penapis utama; 1 bukan nombor perdana; membentuk ayak; Sekiranya saya adalah perdana; Jika saya adalah faktor utama; Tandakan nombor J sebagai bukan perdana; Hitung nombor yang paling rendah faktor saya; membentuk ayak; paparan; paparan", "code": "< ? php $ MAX = 1000000 ; $ sieve_Prime = array_fill ( 0 , $ MAX + 4 , NULL ) ; $ sieve_count = array_fill ( 0 , $ MAX + 4 , NULL ) ; function form_sieve ( ) { global $ sieve_Prime , $ sieve_count , $ MAX ; $ sieve_Prime [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ MAX ; $ i ++ ) { if ( $ sieve_Prime [ $ i ] == 0 ) { for ( $ j = $ i * 2 ; $ j <= $ MAX ; $ j += $ i ) { if ( $ sieve_Prime [ $ j ] == 0 ) { $ sieve_Prime [ $ j ] = 1 ; $ sieve_count [ $ i ] ++ ; } } } } } form_sieve ( ) ; $ n = 2 ; echo \" Count = \" ▁ . ▁ ( $ sieve _ count [ $ n ] ▁ + ▁ 1 ) ▁ . ▁ \" \" $ n = 3 ; echo \" Count = \" ▁ . ▁ ( $ sieve _ count [ $ n ] ▁ + ▁ 1 ) ▁ . ▁ \" \" ? >"}
{"text": "Cari nombor baik terbesar dalam pembahagi nombor yang diberikan n | berfungsi untuk mengembalikan faktor utama yang berbeza; untuk menyimpan faktor utama yang berbeza; Jalankan gelung sehingga sqrt (n); Letakkan faktor utama ini dalam vektor; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor perdana yang lebih besar daripada 1; fungsi yang mengembalikan nombor yang baik; faktor utama yang berbeza; untuk menyimpan jawapan; Produk semua faktor utama yang berbeza diperlukan jawapan; Kod pemacu; panggilan fungsi", "code": "< ? php function PrimeFactors ( $ n ) { $ v = array ( ) ; $ x = $ n ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ x % $ i == 0 ) { array_push ( $ v , $ i ) ; while ( $ x % $ i == 0 ) $ x /= $ i ; } } if ( $ x > 1 ) array_push ( $ v , $ x ) ; return $ v ; } function GoodNumber ( $ n ) { $ v = PrimeFactors ( $ n ) ; $ ans = 1 ; for ( $ i = 0 ; $ i < count ( $ v ) ; $ i ++ ) $ ans *= $ v [ $ i ] ; return $ ans ; } $ n = 12 ; echo GoodNumber ( $ n ) ; ? >"}
{"text": "Cari Perdana Khas terbesar yang kurang daripada atau sama dengan nombor tertentu | Berfungsi untuk memeriksa sama ada nombor itu adalah perdana khas atau tidak; Walaupun nombor tidak sama dengan sifar; Jika nombor itu bukan pulangan utama palsu. ; Lain keluarkan digit terakhir dengan membahagikan nombor dengan 10 .; Sekiranya nombor itu menjadi sifar maka nombor itu adalah perdana khas, maka kembali benar; Berfungsi untuk mencari perdana khas terbesar yang kurang daripada atau sama dengan nombor tertentu; Pada mulanya semua nombor dianggap prima. ; Selalu ada jawapan yang mungkin; Memeriksa sama ada nombor itu adalah perdana khas atau tidak; Jika ya cetak nombor dan pecahkan gelung. ; Lain menurunkan nombor. ; Kod pemacu", "code": "< ? php function checkSpecialPrime ( & $ sieve , $ num ) { while ( $ num ) { if ( ! $ sieve [ $ num ] ) { return false ; } $ num = ( int ) ( $ num / 10 ) ; } return true ; } function findSpecialPrime ( $ N ) { $ sieve = array_fill ( 0 , $ N + 10 , true ) ; $ sieve [ 0 ] = $ sieve [ 1 ] = false ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { if ( $ sieve [ $ i ] ) { for ( $ j = $ i * $ i ; $ j <= $ N ; $ j += $ i ) { $ sieve [ $ j ] = false ; } } } while ( true ) { if ( checkSpecialPrime ( $ sieve , $ N ) ) { echo $ N . \" STRNEWLINE \" ; break ; } else $ N -- ; } } findSpecialPrime ( 379 ) ; findSpecialPrime ( 100 ) ; ? >"}
{"text": "Semak jika nombor adalah perdana Pythagorean atau tidak | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Kod pemacu; Periksa sama ada nombor adalah perdana dan borang 4 * n + 1", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 or $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) { if ( $ n % $ i == 0 or $ n % ( $ i + 2 ) == 0 ) { return false ; } } return true ; } $ n = 13 ; if ( isPrime ( $ n ) && ( $ n % 4 == 1 ) ) { echo \" YES \" ; } else { echo \" NO \" ; } ? >"}
{"text": "Bahagikan segitiga isosceles dalam dua bahagian dengan nisbah kawasan sebagai n: m | Berfungsi untuk mengembalikan ketinggian; Taipkan N, M ke dalam terapung; Kirakan ketinggian untuk dipotong; Kod pemacu", "code": "< ? php function heightCalculate ( $ H , $ n , $ m ) { $ N = $ n * 1.0 ; $ M = $ m * 1.0 ; $ h = $ H * sqrt ( $ N / ( $ N + $ M ) ) ; return $ h ; } $ H = 10 ; $ n = 3 ; $ m = 4 ; echo heightCalculate ( $ H , $ n , $ m ) ; ? >"}
{"text": "Semak n ^ 2 | Semak nombor adalah perdana atau tidak; Jalankan gelung sehingga persegi nombor yang diberikan; Semak jika n ^ 2 - m ^ 2 adalah perdana; Kod pemacu", "code": "< ? php function isprime ( $ x ) { for ( $ i = 2 ; $ i * $ i <= $ x ; $ i ++ ) if ( $ x % i == 0 ) return false ; return true ; } function isNSqMinusnMSqPrime ( $ m , $ n ) { if ( $ n - $ m == 1 and isprime ( $ m + $ n ) ) return true ; else return false ; } $ m = 13 ; $ n = 16 ; if ( isNSqMinusnMSqPrime ( $ m , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Cari 'n' bilangan penyelesaian dengan persamaan ketidaksamaan yang diberikan | Berfungsi untuk mengira semua penyelesaian; Tiada penyelesaian; Cetak elemen pertama sebagai y - n + 1; Cetak rehat n - 1 elemen sebagai 1; memulakan bilangan elemen dan nilai x an y", "code": "< ? php function findsolution ( $ n , $ x , $ y ) { if ( ( $ y - $ n + 1 ) * ( $ y - $ n + 1 ) + $ n - 1 < $ x $ y < $ n ) { echo \" No ▁ solution \" ; return ; } echo $ y - $ n + 1 ; while ( $ n -- > 1 ) echo \" STRNEWLINE \" . 1 ; } $ n = 5 ; $ x = 15 ; $ y = 15 ; findsolution ( $ n , $ x , $ y ) ;"}
{"text": "Bilangan kedudukan yang berbeza di mana seseorang boleh berdiri | Berfungsi untuk mencari kedudukan; Kod pemacu", "code": "< ? php function findPosition ( $ n , $ f , $ b ) { return $ n - max ( $ f + 1 , $ n - $ b ) + 1 ; } $ n = 5 ; $ f = 2 ; $ b = 3 ; echo findPosition ( $ n , $ f , $ b ) ; ? >"}
{"text": "Program untuk n | Berfungsi untuk mencari nombor ganjil nth; Kod pemacu", "code": "< ? php function nthOdd ( $ n ) { return ( 2 * $ n - 1 ) ; } $ n = 10 ; echo nthOdd ( $ n ) ; ? >"}
{"text": "Program untuk n | Berfungsi untuk mencari nombor nth walaupun; Kod pemacu", "code": "< ? php function nthEven ( $ n ) { return ( 2 * $ n ) ; } $ n = 10 ; echo nthEven ( $ n ) ; ? >"}
{"text": "Program untuk mencari nombor harmonik nth | Berfungsi untuk mencari nombor harmonik n - tH; H1 = 1; gelung untuk memohon forumula hn = h1 + h2 + h3 ... + hn - 1 + hn - 1 + 1 / n; Kod pemacu", "code": "< ? php function nthHarmonic ( $ N ) { $ harmonic = 1.00 ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { $ harmonic += ( float ) 1 / $ i ; } return $ harmonic ; } $ N = 8 ; echo nthHarmonic ( $ N ) ; ? >"}
{"text": "Program untuk mencari istilah n Siri 0, 7, 18, 33, 51, 75, 102, 133, .... . | mengira istilah siri nth; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + $ n - 3 ; } $ N = 4 ; echo nthTerm ( $ N ) + \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari istilah n Siri 0, 10, 30, 60, 99, 150, 210, 280 ... ... ... .... | mengira istilah siri nth; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return 5 * pow ( $ n , 2 ) - 5 * $ n ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Program untuk mencari istilah n Siri 2, 12, 28, 50, 77, 112, 152, 198, .... . | mengira istilah siri nth; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) + $ n - 2 ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Program untuk mencari istilah n Siri 4, 14, 28, 46, 68, 94, 124, 158, .... . | mengira istilah siri nth; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + 4 * $ n - 2 ; } $ N = 4 ; echo nthTerm ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari istilah n Siri 0, 11, 28, 51, 79, 115, 156, 203, .... | mengira istilah siri nth; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) + 2 * $ n - 5 ; } $ N = 4 ; echo nthTerm ( $ N ) . \" STRNEWLINE \" ;"}
{"text": "Program untuk mencari istilah siri 0, 9, 22, 39, 60, 85, 114, 147, .... . | mengira istilah siri nth; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + 3 * $ n - 5 ; } $ N = 4 ; echo nthTerm ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari istilah n Siri 3, 12, 29, 54, 86, 128, 177, 234, .... . | mengira istilah siri nth; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return 4 * pow ( $ n , 2 ) - 3 * $ n + 2 ; } $ N = 4 ; echo nthTerm ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text": "Cari dua sisi lain dan sudut segitiga sudut kanan | Program PHP untuk mencetak semua sisi dan sudut segitiga sudut kanan yang diberikan satu sisi; Berfungsi untuk mencari sudut sudut di hadapan sisi A; peraturan kosinus yang digunakan; Tukar menjadi darjah; Berfungsi untuk mencari sudut B sudut di hadapan sisi B; peraturan kosinus yang digunakan; menukar ke darjah dan kembali; Berfungsi untuk mencetak semua sudut segitiga bersudut kanan; untuk mengira sudut a; untuk mengira sudut b; Berfungsi untuk mencari dua sisi lain segitiga bersudut kanan; jika n adalah ganjil; kes n = 1 dikendalikan secara berasingan; kes n = 2 dikendalikan secara berasingan; Cetak sudut segitiga; Kod pemacu", "code": "< ? php $ PI = 3.1415926535 ; function findAnglesA ( $ a , $ b , $ c ) { global $ PI ; $ A = acos ( ( $ b * $ b + $ c * $ c - $ a * $ a ) / ( 2 * $ b * $ c ) ) ; return $ A * 180 / $ PI ; } function findAnglesB ( $ a , $ b , $ c ) { global $ PI ; $ B = acos ( ( $ a * $ a + $ c * $ c - $ b * $ b ) / ( 2 * $ a * $ c ) ) ; return $ B * 180 / $ PI ; } function printAngles ( $ a , $ b , $ c ) { $ x = ( double ) $ a ; $ y = ( double ) $ b ; $ z = ( double ) $ c ; $ A = findAnglesA ( $ x , $ y , $ z ) ; $ B = findAnglesB ( $ x , $ y , $ z ) ; echo \" Angles ▁ are ▁ A ▁ = ▁ \" . $ A . \" , B = \" ▁ . ▁ $ B ▁ . ▁ \" , C = 90 \" ; } function printOtherSides ( $ n ) { if ( $ n & 1 ) { if ( $ n == 1 ) echo \" - 1 STRNEWLINE \" ; else { $ b = ( $ n * $ n - 1 ) / 2 ; $ c = ( $ n * $ n + 1 ) / 2 ; echo \" Side ▁ b ▁ = ▁ \" . $ b . \" , ▁ Side ▁ c ▁ = ▁ \" . $ c . \" STRNEWLINE \" ; } } else { if ( $ n == 2 ) echo \" - 1 STRNEWLINE \" ; else { $ b = $ n * $ n / 4 - 1 ; $ c = $ n * $ n / 4 + 1 ; echo \" Side ▁ b ▁ = ▁ \" . $ b . \" , ▁ Side ▁ c ▁ = ▁ \" . $ c . \" STRNEWLINE \" ; } } printAngles ( $ n , $ b , $ c ) ; } $ a = 12 ; printOtherSides ( $ a ) ; ? >"}
{"text": "Jumlah terma pertama N Siri 2, 6, 12, 20, 30 ... | Berfungsi untuk mengira jumlah; bilangan syarat yang akan dimasukkan dalam jumlah; Cari SN", "code": "< ? php function calculateSum ( $ n ) { return $ n * ( $ n + 1 ) / 2 + $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 6 ; } $ n = 3 ; echo \" Sum = \" ? >"}
{"text": "Program untuk mencari istilah n Siri 0, 5, 14, 27, 44, ... .... . | Mengira istilah siri nth; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) - $ n - 1 ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Program untuk mencari istilah n Siri 0, 5, 18, 39, 67, 105, 150, 203, ... | mengira istilah siri nth; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return 4 * pow ( $ n , 2 ) - 7 * $ n + 3 ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Semak sama ada nombor tertentu adalah kuasa | Program PHP untuk mencari sama ada nombor adalah kuasa - terpencil atau tidak; untuk 2 sebagai faktor utama; untuk faktor utama yang ganjil; mengira produk kuasa dan faktor utama; Hasil semak untuk kuasa - pengasingan; kod pemacu", "code": "< ? php function checkIfPowerIsolated ( $ num ) { $ input = $ num ; $ count = 0 ; $ factor = array ( ) ; if ( $ num % 2 == 0 ) { while ( $ num % 2 == 0 ) { ++ $ count ; $ num /= 2 ; } $ factor [ 2 ] = $ count ; } for ( $ i = 3 ; $ i * $ i <= $ num ; $ i += 2 ) { $ count = 0 ; while ( $ num % $ i == 0 ) { ++ $ count ; $ num /= $ i ; } if ( $ count ) $ factor [ $ i ] = $ count ; } if ( $ num > 1 ) $ factor [ $ num ] = 1 ; $ product = 1 ; foreach ( $ factor as $ primefactor = > $ power ) { $ product = $ product * $ primefactor * $ power ; } if ( $ product == $ input ) print_r ( \" Power - isolated ▁ Integer STRNEWLINE \" ) ; else print_r ( \" Not ▁ a ▁ Power - isolated ▁ Integer STRNEWLINE \" ) ; } checkIfPowerIsolated ( 12 ) ; checkIfPowerIsolated ( 18 ) ; checkIfPowerIsolated ( 35 ) ; ? >"}
{"text": "Program untuk mencari istilah n Siri 3, 7, 13, 21, 31. .... | Fungsi untuk mengira jumlah; Kembali istilah n; pengisytiharan bilangan istilah; Dapatkan istilah n", "code": "< ? php function getNthTerm ( $ N ) { return ( pow ( $ N , 2 ) + $ N + 1 ) ; } $ N = 11 ; echo getNthTerm ( $ N ) ; ? >"}
{"text": "Jumlah nombor sehingga n yang boleh dibahagikan dengan 2 atau 5 | Berfungsi untuk mencari jumlah; SUM2 adalah jumlah nombor yang boleh dibahagi dengan 2; SUM5 adalah jumlah nombor yang boleh dibahagi dengan 5; SUM10 nombor yang boleh dibahagi dengan 2 dan 5; Kod pemacu", "code": "< ? php function findSum ( $ n ) { $ sum2 = ( ( int ) ( $ n / 2 ) * ( 4 + ( ( int ) ( $ n / 2 ) - 1 ) * 2 ) ) / 2 ; $ sum5 = ( ( int ) ( $ n / 5 ) * ( 10 + ( $ n / 5 - 1 ) * 5 ) ) / 2 ; $ sum10 = ( ( int ) ( $ n / 10 ) * ( 20 + ( $ n / 10 - 1 ) * 10 ) ) / 2 ; return $ sum2 + $ sum5 - $ sum10 ; } $ n = 5 ; echo findSum ( $ n ) ; ? >"}
{"text": "Nisbah istilah mth dan nth a. P. dengan nisbah jumlah wang | fungsi untuk mengira nisbah istilah mth dan nth; nisbah akan TM / Tn = (2 * m - 1) / (2 * n - 1); Kod pemacu", "code": "< ? php function CalculateRatio ( $ m , $ n ) { return ( 2 * $ m - 1 ) / ( 2 * $ n - 1 ) ; } $ m = 6 ; $ n = 2 ; echo CalculateRatio ( $ m , $ n ) ; ? >"}
{"text": "Cari jumlah N Syarat Siri 1, 8, 27, 64 .... | Berfungsi untuk mengira jumlah; Mengembalikan jumlah keseluruhan; Kod pemacu", "code": "< ? php function calculateSum ( $ n ) { return pow ( $ n * ( $ n + 1 ) / 2 , 2 ) ; } $ n = 4 ; echo calculateSum ( $ n ) ; ? >"}
{"text": "Jumlah digit dalam A ^ n hingga satu digit | Fungsi ini mendapati jumlah angka tunggal n. ; Mengembalikan jumlah digit tunggal dari a ^ n. Kami menggunakan teknik eksponensi modular. ; Kod pemacu", "code": "< ? php function digSum ( $ n ) { if ( $ n == 0 ) return 0 ; return ( $ n % 9 == 0 ) ? 9 : ( $ n % 9 ) ; } function powerDigitSum ( $ a , $ n ) { $ res = 1 ; while ( $ n ) { if ( $ n % 2 == 1 ) { $ res = $ res * digSum ( $ a ) ; $ res = digSum ( $ res ) ; } $ a = digSum ( digSum ( $ a ) * digSum ( $ a ) ) ; $ n /= 2 ; } return $ res ; } $ a = 9 ; $ n = 4 ; echo powerDigitSum ( $ a , $ n ) ; ? >"}
{"text": "Program untuk mencari jumlah tepi dalam graf lengkap | Berfungsi untuk mencari jumlah tepi dalam graf lengkap dengan verit n; Kod pemacu", "code": "< ? php function totEdge ( $ n ) { $ result = 0 ; $ result = ( $ n * ( $ n - 1 ) ) / 2 ; return $ result ; } $ n = 6 ; echo totEdge ( $ n ) ; ? >"}
{"text": "Program untuk mencari kiraan syiling setiap jenis dari nisbah yang diberikan | fungsi untuk mengira duit syiling; Menukar setiap mereka dalam rupee. Seperti yang kita diberi totalrupees = 1800; Kod pemacu", "code": "< ? php function coin ( $ totalRupees , $ X , $ Y , $ Z ) { $ one = 0 ; $ fifty = 0 ; $ twentyfive = 0 ; $ result = 0 ; $ total = 0 ; $ one = $ X * 1 ; $ fifty = ( ( $ Y * 1 ) / 2.0 ) ; $ twentyfive = ( ( $ Z * 1 ) / 4.0 ) ; $ total = $ one + $ fifty + $ twentyfive ; $ result = ( ( $ totalRupees ) / $ total ) ; return $ result ; } $ totalRupees = 1800 ; $ X = 1 ; $ Y = 2 ; $ Z = 4 ; $ Rupees = coin ( $ totalRupees , $ X , $ Y , $ Z ) ; echo \"1 ▁ rupess ▁ coins ▁ = ▁ \" , $ Rupees * 1 , \" STRNEWLINE \" ; echo \"50 ▁ paisa ▁ coins ▁ = ▁ \" , $ Rupees * 2 , \" STRNEWLINE \" ; echo \"25 ▁ paisa ▁ coins ▁ = ▁ \" , $ Rupees * 4 , \" STRNEWLINE \" ; ? >"}
{"text": "Cari jumlah siri 0. X + 0. Xx + 0. Xxx + ... upto k terma | fungsi yang mengembalikan jumlah siri; Kod pemacu", "code": "< ? php function sumOfSeries ( $ x , $ k ) { return ( ( $ x ) / 81 ) * ( 9 * $ k - 1 + pow ( 10 , ( -1 ) * $ k ) ) ; } $ x = 9 ; $ k = 20 ; echo sumOfSeries ( $ x , $ k ) ; ? >"}
{"text": "Memaksimumkan produk empat faktor nombor | Untuk pengiraan A ^ b; Berfungsi untuk memeriksa; setiap ganjil dan nombor kurang daripada 3 .; setiap nombor dibahagikan dengan 4 .; setiap nombor dibahagikan dengan 6 .; setiap nombor dibahagikan dengan 10 .; untuk setiap nombor yang tidak dapat dibahagikan dengan nilai di atas. ; Kod pemacu", "code": "< ? php function modExp ( $ a , $ b ) { $ result = 1 ; while ( $ b > 0 ) { if ( $ b & 1 ) $ result = $ result * $ a ; $ a = $ a * $ a ; $ b /= 2 ; } return $ result ; } function check ( $ num ) { if ( $ num & 1 $ num < 3 ) return -1 ; else if ( $ num % 4 == 0 ) return modExp ( $ num / 4 , 4 ) ; else if ( $ num % 6 == 0 ) return modExp ( $ num / 3 , 2 ) * modExp ( $ num / 6 , 2 ) ; else if ( $ num % 10 == 0 ) return modExp ( $ num / 5 , 2 ) * ( $ num / 10 ) * ( $ num / 2 ) ; else return -1 ; } $ num = 10 ; echo check ( $ num ) ; ? >"}
{"text": "Semak sama ada bilangan besar boleh dibahagikan dengan 17 atau tidak | Berfungsi untuk memeriksa sama ada nombor itu boleh dibahagikan dengan 17 atau tidak; Mengekstrak digit terakhir; Memotong nombor; Mengurangkan lima kali digit terakhir dari bilangan yang tinggal; Pulangan n boleh dibahagikan dengan 17; Kod pemacu", "code": "< ? php function isDivisible ( $ n ) { while ( $ n / 100 != 0 ) { $ d = ( int ) $ n % 10 ; $ n /= 10 ; $ n -= $ d * 5 ; } return ( $ n % 17 == 0 ) ; } $ n = 19877658 ; if ( isDivisible ( $ n ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; ? >"}
{"text": "Bilangan elemen minimum yang akan dikeluarkan untuk membuat maksimum XOR | Pelaksanaan PHP untuk mencari bilangan elemen minimum untuk dikeluarkan untuk mendapatkan nilai XOR maksimum; Pertama n dalam keadaan di bawah adalah untuk kes di mana n adalah 0; Fungsi untuk mencari bilangan elemen minimum yang akan dikeluarkan. ; Kod pemacu; Cetak bilangan elemen minimum yang akan dikeluarkan", "code": "< ? php function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; } function removeElement ( $ n ) { if ( $ n == 1 $ n == 2 ) return 0 ; $ a = nextPowerOf2 ( $ n ) ; if ( $ n == $ a $ n == $ a - 1 ) return 1 ; else if ( $ n == $ a - 2 ) return 0 ; else if ( $ n % 2 == 0 ) return 1 ; else return 2 ; } $ n = 5 ; echo removeElement ( $ n ) ; ? >"}
{"text": "Program untuk mencari panjang jambatan menggunakan kelajuan dan panjang kereta api | berfungsi untuk mengira panjang jambatan; Dengan mengandaikan pembolehubah input", "code": "< ? php function bridge_length ( $ trainLength , $ Speed , $ Time ) { return ( ( $ Time * $ Speed ) - $ trainLength ) ; } $ trainLength = 120 ; $ Speed = 30 ; $ Time = 18 ; echo \" Length ▁ of ▁ bridge ▁ = ▁ \" . bridge_length ( $ trainLength , $ Speed , $ Time ) . \" ▁ meters \" ; ? >"}
{"text": "Program untuk mencari jumlah urutan yang diberikan | fungsi untuk mencari Moudulo songsang di bawah 10 ^ 9 + 7; Fungsi untuk mencari jumlah urutan yang diberikan; Kod pemacu", "code": "< ? php function modInv ( $ x ) { $ MOD = 1000000007 ; $ n = $ MOD - 2 ; $ result = 1 ; while ( $ n ) { if ( $ n & 1 ) $ result = $ result * $ x % $ MOD ; $ x = $ x * $ x % $ MOD ; $ n = $ n / 2 ; } return $ result ; } function getSum ( $ n , $ k ) { $ MOD = 1000000007 ; $ ans = 1 ; for ( $ i = $ n + 1 ; $ i > $ n - $ k ; $ i -- ) $ ans = $ ans * $ i % $ MOD ; $ ans = $ ans * modInv ( $ k + 1 ) % $ MOD ; return $ ans ; } $ n = 3 ; $ k = 2 ; echo getSum ( $ n , $ k ) ; ? >"}
{"text": "Triplet tanpa unsur yang boleh dibahagikan dengan 3 dan jumlah n | Berfungsi untuk mencetak A, B dan C; Semak jika n - 2 boleh dibahagikan dengan 3 atau tidak; Kod pemacu", "code": "< ? php function printCombination ( $ n ) { echo \"1 ▁ \" ; if ( ( $ n - 2 ) % 3 == 0 ) echo \"2 ▁ \" . ( $ n - 3 ) ; else echo \"1 ▁ \" . ( $ n - 2 ) ; } $ n = 233 ; printCombination ( $ n ) ; ? >"}
{"text": "Pasangan dengan GCD sama dengan satu dalam julat yang diberikan | Berfungsi untuk mencetak semua pasangan; Semak sama ada; Kita boleh mencetak semua pasangan bersebelahan untuk (int i = l; i <r; i + = 2) {cout << \"{\" << i << \",\" << i + 1 << \"},»; }; Kod pemacu", "code": "< ? php function checkPairs ( $ l , $ r ) { if ( ( $ l - $ r ) % 2 == 0 ) return false ; return true ; } $ l = 1 ; $ r = 8 ; if ( checkPairs ( $ l , $ r ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Semak sama ada nombor dengan bilangan digit adalah palindrome atau tidak | Berfungsi untuk memeriksa sama ada nombor itu adalah palindrome; jika dibahagikan dengan 11 maka benar; jika tidak dibahagikan dengan 11; Kod pemacu", "code": "< ? php function isPalindrome ( $ n ) { if ( $ n % 11 == 0 ) { return true ; } return false ; } echo isPalindrome ( 123321 ) ? \" Palindrome \" : \" Not ▁ Palindrome \" ; ? >"}
{"text": "Kira bilangan tiga kali ganda dengan produk yang sama dengan nombor yang diberikan dengan pendua yang dibenarkan | Nilai sasaran yang kita perlu mencari penyelesaian; Pembolehubah ini mengandungi jumlah kiraan tiga kali ganda yang dijumpai; Gelung dari integer terakhir ke ketiga dalam senarai; Semak jika ARR [i] adalah faktor sasaran atau tidak. Jika tidak, langkau ke elemen seterusnya; Semak jika pasangan (arr [i], arr [j]) boleh menjadi sebahagian daripada triplet yang produknya sama dengan sasaran; Cari elemen triplet; Jika elemen dijumpai. Meningkatkan jumlah kiraan tiga", "code": "< ? php $ target = 93 ; $ arr = array ( 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ) ; $ length = sizeof ( $ arr ) ; $ totalCount = 0 ; for ( $ i = 0 ; $ i < $ length - 2 ; $ i ++ ) { if ( $ target % $ arr [ $ i ] == 0 ) { for ( $ j = $ i + 1 ; $ j < $ length - 1 ; $ j ++ ) { if ( $ target % ( $ arr [ $ i ] * $ arr [ $ j ] ) == 0 ) { $ toFind = $ target / ( $ arr [ $ i ] * $ arr [ $ j ] ) ; for ( $ k = $ j + 1 ; $ k < $ length ; $ k ++ ) { if ( $ arr [ $ k ] == $ toFind ) { $ totalCount ++ ; } } } } } } echo ( \" Total ▁ number ▁ of ▁ triplets ▁ found ▁ : ▁ \" ) ; echo ( $ totalCount ) ; ? >"}
{"text": "Bilangan permutasi sedemikian rupa sehingga tiada tiga istilah membentuk peningkatan berikutnya | Pulangan nilai pekali binomial c (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] [k * (k - 1) * - - * 1]; Fungsi berasaskan pekali binomial untuk mencari nombor catalan n dalam masa O (n); Hitung nilai 2 ncn; kembali 2 ncn / (n + 1); Kod pemacu", "code": "< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ res = $ res * ( $ n - $ i ) ; $ res = $ res / ( $ i + 1 ) ; } return $ res ; } function catalan ( $ n ) { $ c = binomialCoeff ( 2 * $ n , $ n ) ; return $ c / ( $ n + 1 ) ; } $ n = 3 ; print ( catalan ( $ n ) ) ; ? >"}
{"text": "Nombor menarik | berfungsi untuk memeriksa sama ada nombor menarik atau tidak; Arahan kiraan kekerapan menggunakan 1 pengindeksan; mendapatkan nombor yang dihasilkan menggunakan penyambungan rentetan; Melintasi watak rentetan dengan watak; memberikan nilai integer angka watak; Untuk memeriksa sama ada mana -mana digit telah muncul beberapa kali; Melintasi array freq untuk memeriksa sama ada mana -mana digit hilang; Nombor input; Bukan nombor yang sah; Memanggil fungsi untuk memeriksa sama ada nombor input menarik atau tidak", "code": "< ? php function isFascinating ( $ num ) { $ freq = array_fill ( 0 , 10 , NULL ) ; $ val = \" \" . $ num . ( $ num * 2 ) . ( $ num * 3 ) ; for ( $ i = 0 ; $ i < strlen ( $ val ) ; $ i ++ ) { $ digit = $ val [ $ i ] - '0' ; if ( $ freq [ $ digit ] > 0 && $ digit != 0 ) return false ; else $ freq [ $ digit ] ++ ; } for ( $ i = 1 ; $ i < 10 ; $ i ++ ) { if ( $ freq [ $ i ] == 0 ) return false ; } return true ; } $ num = 192 ; if ( $ num < 100 ) echo \" No \" ; else { $ ans = isFascinating ( $ num ) ; if ( $ ans ) echo \" Yes \" ; else echo \" No \" ; } ? >"}
{"text": "Kira cara untuk mengedarkan item M di kalangan orang n | fungsi yang digunakan untuk menghasilkan kerumitan masa pekali binomial o (m); Fungsi penolong untuk menjana tidak ada cara untuk mengedarkan m. mangga di kalangan orang; tidak cukup mangga untuk diedarkan; cara -> (n + m - 1) c (n - 1); m mewakili bilangan mangga n mewakili bilangan orang", "code": "< ? php function binomial_coefficient ( $ n , $ m ) { $ res = 1 ; if ( $ m > $ n - $ m ) $ m = $ n - $ m ; for ( $ i = 0 ; $ i < $ m ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; } function calculate_ways ( $ m , $ n ) { if ( $ m < $ n ) return 0 ; $ ways = binomial_coefficient ( $ n + $ m - 1 , $ n - 1 ) ; return $ ways ; } $ m = 7 ; $ n = 5 ; $ result = calculate_ways ( $ m , $ n ) ; echo $ result ; ? >"}
{"text": "Pertanyaan untuk mengira bilangan co yang tidak teratur | Program PHP untuk mencari bilangan pasangan coprime yang tidak teratur dari 1 hingga n; untuk menyimpan fungsi ketat Euler; untuk menyimpan jawapan yang diperlukan; Mengira dan mencetak semua nombor yang lebih kecil daripada atau sama dengan n. ; Memulakan phi [] dengan 1; Mengira nilai phi lain; Jika phi [p] tidak dikira sudah, maka nombor p adalah perdana; Phi nombor utama p sentiasa sama dengan p - 1 .; Mengemas kini nilai phi semua gandaan p; Tambah sumbangan p kepada pelbagai i dengan mendarab dengan (1 - 1 / p); berfungsi untuk mengira nombor pasangan coprime; Panggilan fungsi untuk mengira fungsi Euler Totient; Awalan Jumlah semua nilai fungsi Euler; panggilan fungsi", "code": "< ? php $ N = 100005 ; $ phi = array_fill ( 0 , $ N , 0 ) ; $ S = array_fill ( 0 , $ N , 0 ) ; function computeTotient ( ) { global $ N , $ phi , $ S ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ phi [ $ i ] = $ i ; for ( $ p = 2 ; $ p < $ N ; $ p ++ ) { if ( $ phi [ $ p ] == $ p ) { $ phi [ $ p ] = $ p - 1 ; for ( $ i = 2 * $ p ; $ i < $ N ; $ i += $ p ) { $ phi [ $ i ] = ( int ) ( ( $ phi [ $ i ] / $ p ) * ( $ p - 1 ) ) ; } } } } function CoPrimes ( ) { global $ N , $ phi , $ S ; computeTotient ( ) ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ S [ $ i ] = $ S [ $ i - 1 ] + $ phi [ $ i ] ; } CoPrimes ( ) ; $ q = array ( 3 , 4 ) ; $ n = sizeof ( $ q ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo \" Number ▁ of ▁ unordered ▁ coprime STRNEWLINE \" . \" pairs ▁ of ▁ integers ▁ from ▁ 1 ▁ to ▁ \" . $ q [ $ i ] . \" ▁ are ▁ \" . $ S [ $ q [ $ i ] ] . \" STRNEWLINE \" ; ? >"}
{"text": "N | Berfungsi untuk mengembalikan nilai perpuluhan nombor binari; Inisialisasi nilai asas kepada 1, i. e 2 ^ 0; Cari perwakilan binari nombor n - th dalam urutan; Kes asas; jawab rentetan; tambah n - 1 1 s; tambah 0; tambah n 1 pada akhir; Kod pemacu", "code": "< ? php function binaryToDecimal ( $ n ) { $ num = $ n ; $ dec_value = 0 ; $ base = 1 ; $ len = strlen ( $ num ) ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { if ( $ num [ $ i ] == '1' ) $ dec_value += $ base ; $ base = $ base * 2 ; } return $ dec_value ; } function numberSequence ( $ n ) { if ( $ n == 1 ) return 1 ; $ s = \" \" ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ s . = '1' ; $ s . = '0' ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ s . = '1' ; $ num = binaryToDecimal ( $ s ) ; return $ num ; } $ n = 4 ; echo numberSequence ( $ n ) ; ? >"}
{"text": "N | Fungsi untuk mencari istilah n - th; mengira istilah n; Kod pemacu", "code": "< ? php function numberSequence ( $ n ) { $ num = pow ( 4 , $ n ) - pow ( 2 , $ n ) - 1 ; return $ num ; } $ n = 4 ; echo numberSequence ( $ n ) ; ? >"}
{"text": "Prima alternatif sehingga n | Fungsi untuk nombor semak adalah perdana atau tidak; jika bendera = 0 maka nombor adalah perdana dan pulangan 1 jika tidak pulangan 0; Berfungsi untuk mencetak nombor perdana alternatif; Kaunter dimulakan dengan 0; gelung melalui 2 hingga n - 1; fungsi memanggil bersama -sama dengan keadaan; Jika kaunter adalah berganda 2 maka hanya cetak nombor perdana; Kod pemacu; Fungsi panggilan", "code": "< ? php function prime ( $ num ) { $ flag = 0 ; for ( $ i = 2 ; $ i <= $ num / 2 ; $ i ++ ) { if ( $ num % $ i == 0 ) { $ flag = 1 ; break ; } } if ( $ flag == 0 ) return 1 ; else return 0 ; } function print_alternate_prime ( $ n ) { $ counter = 0 ; for ( $ num = 2 ; $ num < $ n ; $ num ++ ) { if ( prime ( $ num ) == 1 ) { if ( $ counter % 2 == 0 ) echo $ num . \" \" ; $ counter += 1 ; } } } $ n = 15 ; echo \" Following ▁ are ▁ the ▁ alternate ▁ prime ▁ \" . \" number ▁ smaller ▁ than ▁ or ▁ equal ▁ to ▁ \" . $ n . \" STRNEWLINE \" ; print_alternate_prime ( $ n ) ; ? >"}
{"text": "Prima alternatif sehingga n | Program PHP untuk mencetak semua prima yang lebih kecil daripada atau sama dengan N menggunakan penapis eratosthenes; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cetak semua nombor utama; untuk perdana seterusnya untuk dicetak; Kod pemacu", "code": "< ? php function SieveOfEratosthenes ( $ n ) { $ prime = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ prime [ $ i ] = true ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ flag = true ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] ) { if ( $ flag ) { echo $ p . \" \" ; $ flag = false ; } else { $ flag = true ; } } } } $ n = 15 ; echo \" Following ▁ are ▁ the ▁ alternate \" . \" ▁ prime ▁ numbers ▁ smaller ▁ \" . \" than ▁ or ▁ equal ▁ to ▁ \" . $ n . \" STRNEWLINE \" ; SieveOfEratosthenes ( $ n ) ; ? >"}
{"text": "Cari maksimum di antara x ^ (y ^ 2) atau y ^ (x ^ 2) di mana x dan y diberikan | Berfungsi untuk mencari maksimum; Kes 1; Kes 2; Kod pemacu", "code": "< ? php function findGreater ( $ x , $ y ) { if ( $ x > $ y ) { return false ; } else { return true ; } } $ x = 4 ; $ y = 9 ; if ( findGreater ( $ x , $ y ) == true ) echo ( \"1 STRNEWLINE \" ) ; else echo ( \"2 STRNEWLINE \" ) ; ? >"}
{"text": "Keuntungan maksimum selepas membeli dan menjual stok dengan yuran transaksi | Pelaksanaan PHP pendekatan di atas; B [0] akan mengandungi keuntungan maksimum; B [1] akan mengandungi hari di mana kita mendapat keuntungan maksimum; Di sini mencari keuntungan maksimum; Sekiranya kita kurang atau sama dengan sifar, ia bermakna kita tidak mendapat keuntungan; Semak sama ada jumlahnya lebih besar maka maksimum kemudian simpan maksimum baru; Kod pemacu", "code": "< ? php function max_profit ( & $ a , & $ b , $ n , $ fee ) { $ diff_day = 1 ; $ sum = 0 ; $ b [ 0 ] = 0 ; $ b [ 1 ] = $ diff_day ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ l = 0 ; $ r = $ diff_day ; $ sum = 0 ; for ( $ j = $ n - 1 ; $ j >= $ i ; $ j -- ) { $ profit = ( $ a [ $ r ] - $ a [ $ l ] ) - $ fee ; if ( $ profit > 0 ) { $ sum = $ sum + $ profit ; } $ l ++ ; $ r ++ ; } if ( $ b [ 0 ] < $ sum ) { $ b [ 0 ] = $ sum ; $ b [ 1 ] = $ diff_day ; } $ diff_day ++ ; } } $ arr = array ( 6 , 1 , 7 , 2 , 8 , 4 ) ; $ n = sizeof ( $ arr ) ; $ b = array ( ) ; $ tranFee = 2 ; max_profit ( $ arr , $ b , $ n , $ tranFee ) ; echo ( $ b [ 0 ] ) ; echo ( \" , ▁ \" ) ; echo ( $ b [ 1 ] ) ; ? >"}
{"text": "Telur menjatuhkan teka -teki (pekali binomial dan penyelesaian carian binari) | Cari jumlah koefisien binomial XCI (di mana saya bervariasi dari 1 hingga n). Jika jumlahnya menjadi lebih daripada k; Adakah carian binari untuk mencari bilangan percubaan minimum dalam kes terburuk. ; Memulakan rendah dan tinggi sebagai 1 st dan lantai terakhir; Adakah carian binari, untuk setiap pertengahan, cari jumlah pekali binomial dan periksa sama ada jumlahnya lebih besar daripada k atau tidak. ; Kod pemacu", "code": "< ? php function binomialCoeff ( $ x , $ n , $ k ) { $ sum = 0 ; $ term = 1 ; for ( $ i = 1 ; $ i <= $ n && $ sum < $ k ; ++ $ i ) { $ term *= $ x - $ i + 1 ; $ term /= $ i ; $ sum += $ term ; } return $ sum ; } function minTrials ( $ n , $ k ) { $ low = 1 ; $ high = $ k ; while ( $ low < $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( binomialCoeff ( $ mid , $ n , $ k ) < $ k ) $ low = $ mid + 1 ; else $ high = $ mid ; } return ( int ) $ low ; } echo minTrials ( 2 , 10 ) ; ? >"}
{"text": "Cari Palindrome Prime seterusnya | Program PHP untuk mencari Palindromic Prime seterusnya untuk nombor tertentu. ; jika (8 <= n <= 11) kembali 11; menjana nombor palindrome panjang yang akan meliputi kekangan yang diberikan. ; Jika y> = n dan ia adalah nombor utama kemudian kembali. ; Kod pemacu", "code": "< ? php function isPrime ( $ num ) { if ( $ num < 2 $ num % 2 == 0 ) return $ num == 2 ; for ( $ i = 3 ; $ i * $ i <= $ num ; $ i += 2 ) if ( $ num % $ i == 0 ) return false ; return true ; } function primePalindrome ( $ N ) { if ( 8 <= $ N && $ N <= 11 ) return 11 ; for ( $ x = 1 ; $ x < 100000 ; ++ $ x ) { $ s = strval ( $ x ) ; $ r = strrev ( $ s ) ; $ y = intval ( $ s . substr ( $ r , 1 ) ) ; if ( $ y >= $ N && isPrime ( $ y ) == true ) return $ y ; } return -1 ; } print ( primePalindrome ( 112 ) ) ; ? >"}
{"text": "Bilangan penyelesaian integral untuk persamaan x = b * (sumofdigits (x) ^ a) + c | Fungsi ini mengembalikan jumlah digit nombor; Fungsi ini mewujudkan pelbagai nombor yang sah; Ini mengira s (x) ^ a; Ini memberikan hasil persamaan; Memeriksa jika jumlahnya sama seperti i; kaunter untuk menjejaki nombor; array yang dihasilkan; mencetak nombor; Kod pemacu; hitung nilai x mana yang mungkin", "code": "< ? php function getsum ( $ a ) { $ r = 0 ; $ sum = 0 ; while ( $ a > 0 ) { $ r = $ a % 10 ; $ sum = $ sum + $ r ; $ a = ( int ) ( $ a / 10 ) ; } return $ sum ; } function value ( $ a , $ b , $ c ) { $ co = 0 ; $ p = 0 ; $ no ; $ r = 0 ; $ x = 0 ; $ q = 0 ; $ w = 0 ; $ v = array ( ) ; $ u = 0 ; for ( $ i = 1 ; $ i < 82 ; $ i ++ ) { $ no = pow ( $ i , $ a ) ; $ no = $ b * $ no + $ c ; if ( $ no > 0 && $ no < 1000000000 ) { $ x = getsum ( $ no ) ; if ( $ x == $ i ) { $ q ++ ; $ v [ $ u ++ ] = $ no ; $ w ++ ; } } } for ( $ i = 0 ; $ i < $ u ; $ i ++ ) { echo $ v [ $ i ] . \" \" ; } } $ a = 2 ; $ b = 2 ; $ c = -1 ; value ( $ a , $ b , $ c ) ; ? >"}
{"text": "Rantai Cunningham | Berfungsi untuk mencetak rantai Cunningham jenis kedua; Iterat sehingga semua elemen dicetak; periksa perdana atau tidak; Kod pemacu", "code": "< ? php function print_t ( $ p0 ) { $ p1 ; $ i = 0 ; $ x ; $ flag ; $ k ; while ( 1 ) { $ flag = 1 ; $ x = pow ( 2 , $ i ) ; $ p1 = $ x * $ p0 - ( $ x - 1 ) ; for ( $ k = 2 ; $ k < $ p1 ; $ k ++ ) { if ( $ p1 % $ k == 0 ) { $ flag = 0 ; break ; } } if ( $ flag == 0 ) break ; echo $ p1 . \" \" ; $ i ++ ; } } $ p0 = 19 ; print_t ( $ p0 ) ;"}
{"text": "Kira pasangan dengan bitwise dan sebagai nombor ganjil | Program PHP untuk mengira pasangan dengan ganjil dan; Mengira jumlah nombor ganjil; kembali kiraan pasangan; Kod pemacu; Fungsi panggilan findoddpair dan cetak nombor pasangan ganjil", "code": "< ? php function findOddPair ( & $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ( $ A [ $ i ] % 2 == 1 ) ) $ count ++ ; return $ count * ( $ count - 1 ) / 2 ; } $ a = array ( 5 , 1 , 3 , 2 ) ; $ n = sizeof ( $ a ) ; echo ( findOddPair ( $ a , $ n ) ) ; ? >"}
{"text": "SURD NOMBOR | Pulangan benar jika x adalah nombor surd; Cuba semua kuasa i; Kod pemacu", "code": "< ? php function isSurd ( $ n ) { for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { $ j = $ i ; while ( $ j < $ n ) $ j = $ j * $ i ; if ( $ j == $ n ) return false ; } return true ; } $ n = 15 ; if ( isSurd ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Program untuk mencari dua digit terakhir 2 ^ n | Cari digit pertama; Dapatkan digit terakhir dari nombor itu; Keluarkan digit terakhir dari nombor; Dapatkan digit terakhir dari nombor (kedua terakhir NUM); Ambil digit terakhir ke kedudukan sepuluh iaitu digit kedua terakhir; Tambah nilai dan puluhan untuk menjadikannya nombor 2 digit lengkap; Kembalikan angka pertama; Kod pemacu; Fungsi POW digunakan", "code": "< ? php function LastTwoDigit ( $ num ) { $ one = $ num % 10 ; $ num /= 10 ; $ tens = $ num % 10 ; $ tens *= 10 ; $ num = $ tens + $ one ; return $ num ; } $ n = 10 ; $ num = 1 ; $ num = pow ( 2 , $ n ) ; echo ( \" Last ▁ \" . 2 ) ; echo ( \" ▁ digits ▁ of ▁ \" . 2 ) ; echo ( \" ^ \" . $ n . \" ▁ = ▁ \" ) ; echo ( LastTwoDigit ( $ num ) ) ; ? >"}
{"text": "Program untuk mencari dua digit terakhir 2 ^ n | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); $ x = $ x % $ p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; Fungsi PHP untuk mengira bilangan digit dalam x; Fungsi php untuk mencetak 2 digit terakhir 2 ^ n; Menjana 10 ^ 2; Memanggil eksponensi modular; Mencetak sifar paling kiri. Oleh kerana (2 ^ n) % 2 boleh mempunyai digit kurang kemudian 2. Dalam hal ini kita perlu mencetak sifar; Jika temp tidak sifar maka cetak temp. Jika temp adalah sifar maka sudah dicetak; Kod pemacu", "code": "< ? php function power ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function numberOfDigits ( $ x ) { $ i = 0 ; while ( $ x ) { $ x /= 10 ; $ i ++ ; } return $ i ; } function LastTwoDigit ( $ n ) { echo ( \" Last ▁ \" . 2 ) ; echo ( \" ▁ digits ▁ of ▁ \" . 2 ) ; echo ( \" ^ \" . $ n . \" ▁ = ▁ \" ) ; $ temp = 1 ; for ( $ i = 1 ; $ i <= 2 ; $ i ++ ) $ temp *= 10 ; $ temp = power ( 2 , $ n , $ temp ) ; for ( $ i = 0 ; $ i < 2 - numberOfDigits ( $ temp ) ; $ i ++ ) echo ( 0 ) ; if ( $ temp ) echo ( $ temp ) ; } $ n = 72 ; LastTwoDigit ( $ n ) ; ? >"}
{"text": "Cari gcd (a ^ n, c) di mana a, n dan c boleh bervariasi dari 1 hingga 10 ^ 9 | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); $ x = $ x % $ p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; Mencari GCD A dan B; Cari GCD A ^ n dan C; Semak jika C adalah pembahagi A; Komput pertama (a ^ n) % c; Sekarang hanya mengembalikan GCD Modulo Power dan c. ; Kod pemacu", "code": "< ? php function modPower ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } function gcdPow ( $ a , $ n , $ c ) { if ( $ a % $ c == 0 ) return $ c ; $ modexpo = modPower ( $ a , $ n , $ c ) ; return gcd ( $ modexpo , $ c ) ; } $ a = 10248585 ; $ n = 1000000 ; $ c = 12564 ; echo gcdPow ( $ a , $ n , $ c ) ; ? >"}
{"text": "Bilangan sub susunan dengan jumlah ganjil | Kod PHP untuk mencari kiraan sub - array dengan jumlah ganjil; Cari jumlah semua subarrays dan hasil kenaikan jika jumlahnya ganjil; Kod pemacu", "code": "< ? php function countOddSum ( & $ ar , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ val = 0 ; for ( $ j = $ i ; $ j <= $ n - 1 ; $ j ++ ) { $ val = $ val + $ ar [ $ j ] ; if ( $ val % 2 != 0 ) $ result ++ ; } } return ( $ result ) ; } $ ar = array ( 5 , 4 , 4 , 5 , 1 , 3 ) ; $ n = sizeof ( $ ar ) ; echo \" The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ odd ▁ \" ; echo \" sum ▁ is ▁ \" . countOddSum ( $ ar , $ n ) ; ? >"}
{"text": "Bilangan sub susunan dengan jumlah ganjil | PHP Proggram untuk mencari kiraan sub - tatasusunan dengan jumlah ganjil; Arahan sementara saiz 2. Temp [0] akan menyimpan kiraan walaupun subarrays dan temp [1] kiraan ganjil. Temp [0] diasaskan sebagai 1 kerana terdapat satu elemen ganjil juga dikira sebagai subarray; Menghitung kiraan. Jumlah adalah jumlah elemen di bawah modulo 2 dan berakhir dengan arr [i]. ; Saya 'mengira u arr [0. . i] »» Modulo u dan kenaikan u u u u u u u u u u u u u u u u u u u u u u u u u u u u '' '' '' '' \" 2 ditambah untuk mengendalikan nombor negatif; Kenaikan kiraan / ganjil; Ganjil boleh dibentuk oleh pasangan yang ganjil; Kod pemacu", "code": "< ? php function countOddSum ( $ ar , $ n ) { $ temp = array ( 1 , 0 ) ; $ result = 0 ; $ val = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ val = ( ( $ val + $ ar [ $ i ] ) % 2 + 2 ) % 2 ; $ temp [ $ val ] ++ ; } $ result = ( $ temp [ 0 ] * $ temp [ 1 ] ) ; return ( $ result ) ; } $ ar = array ( 5 , 4 , 4 , 5 , 1 , 3 ) ; $ n = sizeof ( $ ar ) ; echo \" The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ odd \" . \" ▁ sum ▁ is ▁ \" . countOddSum ( $ ar , $ n ) ; ? >"}
{"text": "Program untuk mencetak faktor nombor berpasangan | Program PHP untuk mencetak faktor utama berpasangan. ; Kod pemacu", "code": "< ? php function printPFsInPairs ( $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) echo $ i . \" * \" . ▁ $ n ▁ / ▁ $ i ▁ . \" \" } $ n = 24 ; printPFsInPairs ( $ n ) ; return 0 ; ? >"}
{"text": "Jumlah elemen dalam julat l | Berfungsi untuk mencari jumlah antara L dan R; array dicipta; Isi separuh pertama array; Isi separuh kedua array; Cari jumlah antara julat; Kod pemacu", "code": "< ? php function rangesum ( $ n , $ l , $ r ) { $ arr = array_fill ( 0 , $ n , 0 ) ; $ c = 1 ; $ i = 0 ; while ( $ c <= $ n ) { $ arr [ $ i ++ ] = $ c ; $ c += 2 ; } $ c = 2 ; while ( $ c <= $ n ) { $ arr [ $ i ++ ] = $ c ; $ c += 2 ; } $ sum = 0 ; for ( $ i = $ l - 1 ; $ i < $ r ; $ i ++ ) { $ sum += $ arr [ $ i ] ; } return $ sum ; } $ n = 12 ; $ l = 1 ; $ r = 11 ; echo ( rangesum ( $ n , $ l , $ r ) ) ; ? >"}
{"text": "Program untuk mencari sudut dalaman dan luaran poligon biasa | berfungsi untuk mencari sudut dalaman dan luaran; formula untuk mencari sudut dalaman; formula untuk mencari sudut luaran; Memaparkan output; Kod pemacu; Fungsi panggilan", "code": "< ? php function findAngle ( $ n ) { $ interiorAngle ; $ exteriorAngle ; $ interiorAngle = ( $ n - 2 ) * 180 / $ n ; $ exteriorAngle = 360 / $ n ; echo \" Interior ▁ angle : ▁ \" , $ interiorAngle , \" STRNEWLINE \" ; echo \" Exterior ▁ angle : ▁ \" , $ exteriorAngle ; } $ n = 10 ; findAngle ( $ n ) ; ? >"}
{"text": "Program untuk mengira jarak antara dua mata dalam 3 D | berfungsi untuk mencetak jarak; Kod pemacu; fungsi panggilan untuk jarak", "code": "< ? php function distance ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) { $ d = sqrt ( pow ( $ x2 - $ x1 , 2 ) + pow ( $ y2 - $ y1 , 2 ) + pow ( $ z2 - $ z1 , 2 ) * 1.0 ) ; echo \" Distance ▁ is ▁ \" . $ d ; } $ x1 = 2 ; $ y1 = -5 ; $ z1 = 7 ; $ x2 = 3 ; $ y2 = 4 ; $ z2 = 5 ; distance ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) ; ? >"}
{"text": "Semak jika bilangan besar yang terbentuk boleh dibahagikan dengan 41 atau tidak | Semak sama ada nombor dibahagikan dengan 41 atau tidak; array untuk menyimpan semua digit; nilai asas; hitung angka yang tinggal; hitung jawapan; semak untuk pembahagian; Kod pemacu", "code": "< ? php function DivisibleBy41 ( $ first , $ second , $ c , $ n ) { $ digit [ $ n ] = range ( 1 , $ n ) ; $ digit [ 0 ] = $ first ; $ digit [ 1 ] = $ second ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ digit [ $ i ] = ( $ digit [ $ i - 1 ] * $ c + $ digit [ $ i - 2 ] ) % 10 ; $ ans = $ digit [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans = ( $ ans * 10 + $ digit [ $ i ] ) % 41 ; if ( $ ans % 41 == 0 ) return true ; else return false ; } $ first = 1 ; $ second = 2 ; $ c = 1 ; $ n = 3 ; if ( DivisibleBy41 ( $ first , $ second , $ c , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Program untuk mencetak nombor pentatope sehingga istilah nth | Berfungsi untuk menghasilkan nombor tetrahedral nth; Berfungsi untuk mencetak siri nombor pentatope sehingga istilah n. ; Memulakan prev sebagai 0. Ia menyimpan jumlah semua nombor pentatope yang dihasilkan sebelum ini; Gelung untuk mencetak siri pentatope; Cari nombor tetrahedral; Tambah nombor tetrahedral kepada jumlah semua nombor tetrahedral yang dihasilkan sebelum ini untuk mendapatkan nombor pentatope ith; Kemas kini jumlah semua nombor tetrahedral yang dihasilkan sebelum ini; Kod pemacu; Fungsi panggilan untuk mencetak siri nombor pentatope", "code": "< ? php function findTetrahedralNumber ( $ n ) { return ( ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) / 6 ) ; } function printSeries ( $ n ) { $ prev = 0 ; $ curr ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ curr = findTetrahedralNumber ( $ i ) ; $ curr = $ curr + $ prev ; echo ( $ curr . \" \" ) ; $ prev = $ curr ; } } $ n = 10 ; printSeries ( $ n ) ; ? >"}
{"text": "Program untuk mencetak nombor pentatope sehingga istilah nth | Berfungsi untuk mencetak siri pentatope sehingga istilah n; Gelung untuk mencetak siri nombor pentatope; Hitung dan cetak nombor pentatope; Kod pemacu; Fungsi panggilan untuk mencetak siri nombor pentatope", "code": "< ? php function printSeries ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ num = ( $ i * ( $ i + 1 ) * ( $ i + 2 ) * ( $ i + 3 ) / 24 ) ; echo ( $ num . \" \" ) ; } } $ n = 10 ; printSeries ( $ n ) ; ? >"}
{"text": "Cari pasangan yang unik supaya setiap elemen kurang daripada atau sama dengan n | Mencari bilangan pasangan yang unik; Menggunakan formula yang diperolehi; Mencetak pasangan yang unik; Kod pemacu", "code": "< ? php function No_Of_Pairs ( $ N ) { $ i = 1 ; while ( ( $ i * $ i * $ i ) + ( 2 * $ i * $ i ) + $ i <= $ N ) $ i ++ ; return ( $ i - 1 ) ; } function print_pairs ( $ pairs ) { $ i = 1 ; $ mul ; for ( $ i = 1 ; $ i <= $ pairs ; $ i ++ ) { $ mul = $ i * ( $ i + 1 ) ; echo \" Pair ▁ no . \" , $ i , \" ▁ - - > ▁ ( \" , ( $ mul * $ i ) , \" , ▁ \" , $ mul * ( $ i + 1 ) , \" ) ▁ STRNEWLINE \" ; } } $ N = 500 ; $ pairs ; $ mul ; $ i = 1 ; $ pairs = No_Of_Pairs ( $ N ) ; echo \" No . ▁ of ▁ pairs ▁ = ▁ \" , $ pairs , \" ▁ STRNEWLINE \" ; print_pairs ( $ pairs ) ; ? >"}
{"text": "Program untuk mencetak nombor tetrahedral sehingga istilah nth | berfungsi untuk menjana nombor segi tiga n; berfungsi untuk mencetak siri nombor tetrahedral sehingga n; Inisialisasi sebelum 0. Ia menyimpan jumlah semua nombor segitiga yang dihasilkan sebelum ini; Gelung untuk mencetak siri; Cari nombor segi tiga; Tambah nombor segi tiga ke jumlah semua nombor segi tiga yang dihasilkan sebelum ini untuk mendapatkan nombor tetrahedral; Kemas kini jumlah semua nombor segitiga yang dihasilkan sebelum ini; Kod pemacu; fungsi panggilan untuk mencetak siri", "code": "< ? php function findTriangularNumber ( $ n ) { return ( $ n * ( $ n + 1 ) ) / 2 ; } function printSeries ( $ n ) { $ prev = 0 ; $ curr ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ curr = findTriangularNumber ( $ i ) ; $ curr = $ curr + $ prev ; echo ( $ curr . \" \" ) ; $ prev = $ curr ; } } $ n = 10 ; printSeries ( $ n ) ; ? >"}
{"text": "Program untuk mencetak nombor tetrahedral sehingga istilah nth | berfungsi untuk mencetak siri nombor tetrahedral sehingga n; gelung untuk mencetak siri; Hitung dan cetak nombor tetrahedral; Kod pemacu; fungsi panggilan untuk mencetak siri", "code": "< ? php function printSeries ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ num = $ i * ( $ i + 1 ) * ( $ i + 2 ) / 6 ; echo ( $ num . \" \" ) ; } } $ n = 10 ; printSeries ( $ n ) ; ? >"}
{"text": "Bilangan ganjil dan juga hasil untuk setiap nilai x dalam julat [min, max] selepas melakukan n langkah | Fungsi yang mencetak bilangan ganjil dan juga hasil; Sekiranya tetap pada lapisan saya, Beven adalah benar, jika tidak palsu. Jika pekali x pada lapisan saya walaupun, Aeven adalah benar, jika tidak palsu. ; Jika mana -mana pekali di mana -mana lapisan didapati walaupun, maka produk dari semua pekali akan sentiasa menjadi walaupun. ; Memeriksa sama ada pemalar ditambah selepas semua lapisan adalah atau ganjil. ; Dengan mengandaikan input X adalah juga. ; Dengan mengandaikan input x adalah ganjil. ; Memaparkan kiraan. ; Kod pemacu", "code": "< ? php function count_even_odd ( $ min , $ max , $ steps ) { $ beven = true ; $ aeven = false ; $ n = 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a = $ steps [ $ i ] [ 0 ] ; $ b = $ steps [ $ i ] [ 1 ] ; if ( ! ( $ aeven $ a & 1 ) ) $ aeven = true ; if ( $ beven ) { if ( $ b & 1 ) $ beven = false ; } else if ( ! ( $ a & 1 ) ) { if ( ! ( $ b & 1 ) ) $ beven = true ; } else { if ( $ b & 1 ) $ beven = true ; } } if ( $ beven ) { $ even = ( int ) $ max / 2 - ( int ) ( $ min - 1 ) / 2 ; $ odd = 0 ; } else { $ even = ( int ) $ max / 2 - ( int ) ( $ min - 1 ) / 2 ; $ odd = 0 ; } if ( ! ( $ beven ^ $ aeven ) ) $ even += $ max - $ min + 1 - ( int ) $ max / 2 + ( int ) ( $ min - 1 ) / 2 ; else $ odd += $ max - $ min + 1 - ( int ) $ max / 2 + ( int ) ( $ min - 1 ) / 2 ; echo \" even = \" ▁ , ▁ $ even , STRNEWLINE TABSYMBOL TABSYMBOL \" , odd = \" , ▁ $ odd , ▁ \" \" } $ min = 1 ; $ max = 4 ; $ steps = array ( array ( 1 , 2 ) , array ( 3 , 4 ) ) ; count_even_odd ( $ min , $ max , $ steps ) ; ? >"}
{"text": "Bilangan maksimum dalam matriks n * n dengan kekangan yang diberikan | Fungsi yang mengembalikan bilangan maksimum yang; Bilangan minimum sifar; Sel totol = persegi saiz matriks; Memulakan jawapannya; Memulakan pembolehubah", "code": "< ? php function getMaxOnes ( $ n , $ x ) { $ zeroes = ( int ) ( $ n / $ x ) ; $ zeroes = $ zeroes * $ zeroes ; $ total = $ n * $ n ; $ ans = $ total - $ zeroes ; return $ ans ; } $ n = 5 ; $ x = 2 ; echo getMaxOnes ( $ n , $ x ) ; ? >"}
{"text": "Semak jika m | Program PHP untuk memeriksa sama ada M - Th Fibonacci membahagikan n - th fibonacci; Kes luar biasa untuk F (2); jika tiada kes di atas, oleh itu tidak boleh dibahagikan; Kod pemacu", "code": "< ? php function check ( $ n , $ m ) { if ( $ n == 2 $ m == 2 $ n % $ m == 0 ) { echo \" Yes \" , \" STRNEWLINE \" ; } else { echo \" No \" , \" ▁ STRNEWLINE \" ; } } $ m = 3 ; $ n = 9 ; check ( $ n , $ m ) ; ? >"}
{"text": "Kawasan permukaan dan jumlah prisma heksagon | Berfungsi untuk mengira kawasan permukaan; Formula untuk mengira kawasan permukaan; Paparan kawasan permukaan; Berfungsi untuk mengira kelantangan; formula untuk mengira kelantangan; Jumlah paparan; Kod pemacu; panggilan fungsi kawasan permukaan; panggilan fungsi kelantangan", "code": "< ? php function findSurfaceArea ( $ a , $ h ) { $ Area ; $ Area = 6 * $ a * $ h + 3 * sqrt ( 3 ) * $ a * $ a ; echo \" Surface ▁ Area : ▁ \" , $ Area , \" STRNEWLINE \" ; } function findVolume ( $ a , $ h ) { $ Volume ; $ Volume = 3 * sqrt ( 3 ) * $ a * $ a * $ h / 2 ; echo \" Volume : ▁ \" , $ Volume ; } $ a = 5 ; $ h = 10 ; findSurfaceArea ( $ a , $ h ) ; findVolume ( $ a , $ h ) ; ? >"}
{"text": "Bilangan minimum surat yang diperlukan untuk mengedarkan semua soalan | Fungsi mengembalikan min tidak diperlukan surat; Menggunakan formula yang diperolehi di atas; tidak ada soalan; tidak ada pelajar; maksimum tidak ada soalan yang boleh dipegang oleh mel; Fungsi panggilan", "code": "< ? php function MinimumMail ( $ n , $ k , $ x ) { $ m = ( $ n - 1 ) + ceil ( ( $ n - 1 ) * 1.0 / $ x ) * ( $ n - 1 ) + ceil ( $ n * 1.0 / $ x ) * ( $ k - $ n ) ; return $ m ; } $ N = 4 ; $ K = 9 ; $ X = 2 ; echo MinimumMail ( $ N , $ K , $ X ) , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari kawasan elips | Berfungsi untuk mencari kawasan elips. ; Formula untuk mencari kawasan elips. ; Memaparkan hasilnya; Kod pemacu", "code": "< ? php function findArea ( $ a , $ b ) { $ Area ; $ Area = 3.142 * $ a * $ b ; echo \" Area : ▁ \" . $ Area ; } $ a = 5 ; $ b = 4 ; findArea ( $ a , $ b ) ; ? >"}
{"text": "Kirakan kuasa kuasa k kali % m | Fungsi untuk mengira nilai yang diberikan; mengira kuasa k; Kod pemacu; Fungsi panggilan", "code": "< ? php function calculate ( $ x , $ k , $ m ) { $ result = $ x ; $ k -- ; while ( $ k -- ) { $ result = pow ( $ result , $ x ) ; if ( $ result > $ m ) $ result %= $ m ; } return $ result ; } $ x = 5 ; $ k = 2 ; $ m = 3 ; echo calculate ( $ x , $ k , $ m ) ; ? >"}
{"text": "Program rekursif untuk memeriksa sama ada nombor adalah palindrome atau tidak | Fungsi rekursif yang mengembalikan sebaliknya digit; Kes asas; menyimpan sebaliknya nombor; Kod pemacu", "code": "< ? php function rev ( $ n , $ temp ) { if ( $ n == 0 ) return $ temp ; $ temp = ( $ temp * 10 ) + ( $ n % 10 ) ; return rev ( $ n / 10 , $ temp ) ; } $ n = 121 ; $ temp = rev ( $ n , 0 ) ; if ( $ temp != $ n ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text": "Program untuk mencari nilai yang lebih besar antara a ^ n dan b ^ n | Fungsi untuk mencari nilai yang lebih besar; Jika n juga; Kod pemacu", "code": "< ? php function findGreater ( $ a , $ b , $ n ) { if ( ! ( $ n & 1 ) ) { $ a = abs ( $ a ) ; $ b = abs ( $ b ) ; } if ( $ a == $ b ) echo \" a ^ n ▁ is ▁ equal ▁ to ▁ b ^ n \" ; else if ( $ a > $ b ) echo \" a ^ n ▁ is ▁ greater ▁ than ▁ b ^ n \" ; else echo \" b ^ n ▁ is ▁ greater ▁ than ▁ a ^ n \" ; } $ a = 12 ; $ b = 24 ; $ n = 5 ; findGreater ( $ a , $ b , $ n ) ; ? >"}
{"text": "Cetak Nombor N First N Fibonacci Menggunakan Formula Langsung | Fungsi untuk mengira fibonacci menggunakan formula hubungan berulang; Menggunakan formula langsung; Kod pemacu", "code": "< ? php function fibonacci ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ fib = ( pow ( ( 1 + sqrt ( 5 ) ) , $ i ) - pow ( ( 1 - sqrt ( 5 ) ) , $ i ) ) / ( pow ( 2 , $ i ) * sqrt ( 5 ) ) ; echo $ fib , \" \" ; } } $ n = 8 ; fibonacci ( $ n ) ; ? >"}
{"text": "Nombor hexadecagonal yang berpusat | fungsi hexadecagonal yang berpusat; Formula untuk mengira nombor hexadecagonal yang berpusat di NTH; Kod pemacu", "code": "< ? php function center_hexadecagonal_num ( $ n ) { return 8 * $ n * $ n - 8 * $ n + 1 ; } $ n = 2 ; echo $ n , \" th ▁ centered ▁ hexadecagonal ▁ number ▁ : ▁ \" , center_hexadecagonal_num ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 12 ; echo $ n , \" th ▁ centered ▁ hexadecagonal ▁ numbe ▁ : ▁ \" , center_hexadecagonal_num ( $ n ) ; ? >"}
{"text": "Semak jika n | Program PHP untuk memeriksa sama ada Nth adalah ganjil atau bahkan dalam urutan di mana setiap istilah adalah jumlah dua istilah sebelumnya; Kembali jika istilah nth adalah walaupun atau ganjil. ; Kembali benar jika ganjil; Kod pemacu", "code": "< ? php $ MAX = 100 ; function findNature ( $ a , $ b , $ n ) { global $ MAX ; $ seq = array_fill ( 0 , $ MAX , 0 ) ; $ seq [ 0 ] = $ a ; $ seq [ 1 ] = $ b ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ seq [ $ i ] = $ seq [ $ i - 1 ] + $ seq [ $ i - 2 ] ; return ( $ seq [ $ n ] & 1 ) ; } $ a = 2 ; $ b = 4 ; $ n = 3 ; if ( findNature ( $ a , $ b , $ n ) ) echo \" Odd \" ; else echo \" Even \" ; ? >"}
{"text": "Program untuk membandingkan m ^ n dan n ^ m | fungsi untuk membandingkan m ^ n dan n ^ m; m ^ n; n ^ m; Kod pemacu; fungsi panggilan untuk membandingkan m ^ n dan n ^ m", "code": "< ? php function check ( $ m , $ n ) { $ RHS = $ m * log ( $ n ) ; $ LHS = $ n * log ( $ m ) ; if ( $ LHS > $ RHS ) echo \" m ^ n ▁ > ▁ n ^ m \" ; else if ( $ LHS < $ RHS ) echo \" m ^ n ▁ < ▁ n ^ m \" ; else echo \" m ^ n ▁ = ▁ n ^ m \" ; } $ m = 987654321 ; $ n = 123456987 ; check ( $ m , $ n ) ; ? >"}
{"text": "Cari GCD yang terletak dalam julat yang diberikan | Mengembalikan pembahagi biasa dua nombor; Kembalikan pembahagi biasa A dan B yang terletak dalam julat yang diberikan. ; Gelung dari 1 hingga sqrt (GCD (a, b) .; Jika saya membahagikan GCD (a, b), kemudian cari maksimum tiga nombor res, i dan g / i;", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } function maxDivisorRange ( $ a , $ b , $ l , $ h ) { $ g = gcd ( $ a , $ b ) ; $ res = -1 ; for ( $ i = $ l ; $ i * $ i <= $ g and $ i <= $ h ; $ i ++ ) if ( $ g % $ i == 0 ) $ res = max ( $ res , max ( $ i , $ g / $ i ) ) ; return $ res ; } $ a = 3 ; $ b = 27 ; $ l = 1 ; $ h = 5 ; echo maxDivisorRange ( $ a , $ b , $ l , $ h ) ; ? >"}
{"text": "Nombor yang dinyatakan sebagai jumlah lima bilangan bulat berturut -turut | Fungsi untuk memeriksa sama ada nombor boleh dinyatakan sebagai jumlah lima bilangan bulat berturut -turut. ; jika n adalah 0; Jika n positif, gelung kenaikan sebanyak 1 .; Jika n adalah negatif, gelung penurunan sebanyak 1 .; Running Loop dari 0 hingga N - 4; Semak jika jumlah lima integer berturut -turut adalah sama dengan n. ; Kod pemacu", "code": "< ? php function checksum ( $ n ) { if ( $ n == 0 ) { echo \" - 2 ▁ - 1 ▁ 0 ▁ 1 ▁ 2\" , \" STRNEWLINE \" ; return ; } $ inc ; if ( $ n > 0 ) $ inc = 1 ; else $ inc = -1 ; for ( $ i = 0 ; $ i <= $ n - 4 ; $ i += $ inc ) { if ( $ i + $ i + 1 + $ i + 2 + $ i + 3 + $ i + 4 == $ n ) { echo $ i , \" \" ▁ , ▁ $ i ▁ + ▁ 1 , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL \" \" ▁ , ▁ $ i ▁ + ▁ 2 , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL \" \" ▁ , ▁ $ i ▁ + ▁ 3 , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL \" \" return ; } } echo \" - 1\" ; } $ n = 15 ; checksum ( $ n ) ; ? >"}
{"text": "Nombor yang dinyatakan sebagai jumlah lima bilangan bulat berturut -turut | Fungsi untuk memeriksa sama ada nombor boleh dinyatakan sebagai jumlah lima bilangan bulat berturut -turut. ; jika n adalah pelbagai daripada 5; lain cetak \" - 1\". ; Kod pemacu", "code": "< ? php function checksum ( $ n ) { if ( $ n % 5 == 0 ) echo $ n / 5 - 2 , \" ▁ \" , $ n / 5 - 1 , \" ▁ \" , $ n / 5 , \" ▁ \" , $ n / 5 + 1 , \" ▁ \" , $ n / 5 + 2 ; else echo \" - 1\" ; } $ n = 15 ; checksum ( $ n ) ; ? >"}
{"text": "N | Fungsi untuk mencari istilah siri nth; Gelung untuk menambah kuasa ke -4; Kod pemacu", "code": "< ? php function sumOfSeries ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += $ i * $ i * $ i * $ i ; return $ ans ; } $ n = 4 ; echo sumOfSeries ( $ n ) ; ? >"}
{"text": "Bilangan bilangan bulat yang tidak bertanda dalam penapis khas | Program PHP untuk menentukan bilangan bilangan bulat yang tidak bertanda dalam penapis khas; Kod pemacu", "code": "< ? php function countUnmarked ( $ N ) { if ( $ N % 2 == 0 ) return $ N / 2 ; else return $ N / 2 + 1 ; } $ N = 4 ; echo \" Number ▁ of ▁ unmarked ▁ elements : ▁ \" , countUnmarked ( $ N ) ; ? >"}
{"text": "Jumlah Siri 1 * 1! + 2 * 2! + ……. . + n * n! | Program PHP untuk mencari jumlah siri. ; Fungsi untuk mengira siri yang diperlukan; Kod pemacu", "code": "< ? php function factorial ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } function calculateSeries ( $ n ) { return factorial ( $ n + 1 ) - 1 ; } $ n = 3 ; echo calculateSeries ( $ n ) ; ? >"}
{"text": "Jumlah Siri 1 * 1 * 2! + 2 * 2 * 3! + ……. . + n * n * (n + 1)! | Program PHP untuk mencari jumlah siri. ; Fungsi untuk mengira siri yang diperlukan; Kod pemacu", "code": "< ? php function factorial ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } function calculateSeries ( $ n ) { return 2 + ( $ n * $ n + $ n - 2 ) * factorial ( $ n + 1 ) ; } $ n = 3 ; echo calculateSeries ( $ n ) ; ? >"}
{"text": "Membentuk pelbagai terkecil dengan kekangan yang diberikan | Kembalikan saiz array terkecil dengan kekangan yang diberikan. ; Kod pemacu", "code": "< ? php function minimumLength ( $ x , $ y , $ z ) { return 1 + abs ( $ x - $ y ) + abs ( $ y - $ z ) ; } $ x = 3 ; $ y = 1 ; $ z = 2 ; echo minimumLength ( $ x , $ y , $ z ) ; ? >"}
{"text": "Cari yang lain | berfungsi untuk mencari titik akhir yang lain - diameter; Cari titik akhir untuk koordinat x; Cari titik akhir untuk koordinat Y; Program yang didorong", "code": "< ? php function endPointOfDiameterofCircle ( $ x1 , $ y1 , $ c1 , $ c2 ) { echo \" x2 = \" , (2 ▁ * ▁ $ c1 ▁ - ▁ $ x1 ) , \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" y2 = \" } $ x1 = -4 ; $ y1 = -1 ; $ c1 = 3 ; $ c2 = 5 ; endPointOfDiameterofCircle ( $ x1 , $ y1 , $ c1 , $ c2 ) ; ? >"}
{"text": "Formula Interpolasi Perbezaan Newton dibahagikan | Berfungsi untuk mencari istilah produk; Fungsi untuk mengira jadual perbezaan dibahagikan; Fungsi untuk memohon formula perbezaan dibahagikan Newton; Fungsi untuk memaparkan jadual perbezaan dibahagikan; bilangan input yang diberikan; y [] [] digunakan untuk jadual perbezaan dibahagikan di mana y [] [0] digunakan untuk input; mengira jadual perbezaan dibahagikan; memaparkan jadual perbezaan dibahagikan; nilai yang akan diinterpolasi; Mencetak nilai", "code": "< ? php function proterm ( $ i , $ value , $ x ) { $ pro = 1 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { $ pro = $ pro * ( $ value - $ x [ $ j ] ) ; } return $ pro ; } function dividedDiffTable ( $ x , & $ y , $ n ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - $ i ; $ j ++ ) { $ y [ $ j ] [ $ i ] = ( $ y [ $ j ] [ $ i - 1 ] - $ y [ $ j + 1 ] [ $ i - 1 ] ) / ( $ x [ $ j ] - $ x [ $ i + $ j ] ) ; } } } function applyFormula ( $ value , $ x , $ y , $ n ) { $ sum = $ y [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( proterm ( $ i , $ value , $ x ) * $ y [ 0 ] [ $ i ] ) ; } return $ sum ; } function printDiffTable ( $ y , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - $ i ; $ j ++ ) { echo round ( $ y [ $ i ] [ $ j ] , 4 ) . \" \" ; } echo \" \" ; } } $ n = 4 ; $ y = array_fill ( 0 , 10 , array_fill ( 0 , 10 , 0 ) ) ; $ x = array ( 5 , 6 , 9 , 11 ) ; $ y [ 0 ] [ 0 ] = 12 ; $ y [ 1 ] [ 0 ] = 13 ; $ y [ 2 ] [ 0 ] = 14 ; $ y [ 3 ] [ 0 ] = 16 ; dividedDiffTable ( $ x , $ y , $ n ) ; printDiffTable ( $ y , $ n ) ; $ value = 7 ; echo \" Value at \" ▁ . ▁ $ value ▁ . ▁ \" is \" round ( applyFormula ( $ value , $ x , $ y , $ n ) , 2 ) . \" STRNEWLINE \" ? >"}
{"text": "Nombor heptagon yang berpusat | Fungsi untuk mencari nombor heptagon yang berpusat; Formula untuk mengira nombor heptagon yang berpusat di Nth; Kod pemacu", "code": "< ? php function centered_heptagonal_num ( $ n ) { return ( 7 * $ n * $ n - 7 * $ n + 2 ) / 2 ; } $ n = 5 ; echo $ n , \" th ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ \" ; echo centered_heptagonal_num ( $ n ) ; ? >"}
{"text": "Jumlah Square | Berfungsi untuk mencari jumlah jumlah persegi nombor semulajadi n pertama; Kod pemacu", "code": "< ? php function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( ( $ i * ( $ i + 1 ) * ( 2 * $ i + 1 ) ) / 6 ) ; return $ sum ; } $ n = 3 ; echo findSum ( $ n ) ; ? >"}
{"text": "Semak jika matriks yang diberikan adalah hankel atau tidak | Program PHP untuk memeriksa jika diberi matriks adalah Hankel Matrix atau tidak. ; Fungsi untuk memeriksa jika diberi matriks adalah Hankel Matrix atau tidak. ; untuk setiap baris; untuk setiap lajur; Memeriksa jika i + j kurang daripada n; Memeriksa jika elemen adalah sama dengan pemalar pepenjuru yang sepadan; Memeriksa jika elemen adalah sama dengan pemalar pepenjuru yang sepadan; Kod pemacu", "code": "< ? php $ N = 4 ; function checkHankelMatrix ( $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i + $ j < $ n ) { if ( $ m [ $ i ] [ $ j ] != $ m [ $ i + $ j ] [ 0 ] ) return false ; } else { if ( $ m [ $ i ] [ $ j ] != $ m [ $ i + $ j - $ n + 1 ] [ $ n - 1 ] ) return false ; } } } return true ; } $ n = 4 ; $ m = array ( array ( 1 , 2 , 3 , 5 ) , array ( 2 , 3 , 5 , 8 ) , array ( 3 , 5 , 8 , 0 ) , array ( 5 , 8 , 0 , 9 ) ) ; if ( checkHankelMatrix ( $ n , $ m ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak jika nombor boleh dinyatakan sebagai kuasa | Tetapkan 2 (menggunakan log) | Program PHP untuk mencari jika nombor boleh dinyatakan sebagai x yang dinaikkan ke kuasa y. ; Cari log n di pangkalan yang berbeza dan periksa sama ada nilai adalah integer; Kod pemacu", "code": "< ? php function isPower ( $ n ) { for ( $ x = 2 ; $ x <= sqrt ( $ n ) ; $ x ++ ) { $ f = log ( $ n ) / log ( $ x ) ; if ( ( $ f - ( int ) $ f ) == 0.0 ) return true ; } return false ; } for ( $ i = 2 ; $ i < 100 ; $ i ++ ) if ( isPower ( ( int ) $ i ) ) echo $ i . \" \" ; ? >"}
{"text": "Pertanyaan pada jumlah nombor digit nombor ganjil dari semua faktor nombor | Program PHP untuk menjawab pertanyaan mengenai jumlah jumlah digit nombor ganjil dari semua faktor nombor; Mencari jumlah nombor angka ganjil dalam setiap integer. ; untuk setiap nombor; Menggunakan jumlah nombor sebelumnya, mencari nombor nombor semasa angka ganjil juga, menambah digit terakhir jika ia ganjil. ; Mencari jumlah jumlah digit ganjil dari semua faktor nombor. ; untuk setiap faktor yang mungkin; Menambah sumbangan. ; Fungsi pembalut; Kod pemacu", "code": "< ? php $ N = 1000005 ; function sumOddDigit ( & $ digitSum ) { global $ N ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ digitSum [ $ i ] = $ digitSum [ intval ( $ i / 10 ) ] + intval ( $ i & 1 ) * ( $ i % 10 ) ; } } function sumFactor ( $ digitSum , & $ factorDigitSum ) { global $ N ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) { $ factorDigitSum [ $ j ] += $ digitSum [ $ i ] ; } } } function wrapper ( $ q , $ n ) { global $ N ; $ digitSum = array ( ) ; $ factorDigitSum = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ digitSum [ $ i ] = 0 ; $ factorDigitSum [ $ i ] = 0 ; } sumOddDigit ( $ digitSum ) ; sumFactor ( $ digitSum , $ factorDigitSum ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo ( $ factorDigitSum [ $ n [ $ i ] ] . \" ▁ \" ) ; } $ q = 2 ; $ n = array ( 10 , 36 ) ; wrapper ( $ q , $ n ) ; ? >"}
{"text": "Bilangan digit dalam nombor nth yang diperbuat daripada empat digit yang diberikan | Fungsi yang cekap untuk mengira bilangan digit dalam nombor nth yang dibina dengan menggunakan 6, 1, 4 dan 9 sebagai digit dalam urutan menaik. ; Bilangan digit meningkat selepas setiap nombor i - th di mana saya meningkatkan kuasa 4 .; Kod pemacu", "code": "< ? php function number_of_digits ( $ n ) { $ i ; $ res ; $ sum = 0 ; for ( $ i = 4 , $ res = 1 ; ; $ i *= 4 , $ res ++ ) { $ sum += $ i ; if ( $ sum >= $ n ) break ; } return $ res ; } $ n = 21 ; echo number_of_digits ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cetak nombor perdana dari 1 hingga n dalam urutan terbalik | Program PHP untuk mencetak semua prima antara 1 hingga N dalam urutan terbalik menggunakan penapis eratosthenes; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cetak semua nombor utama dalam urutan terbalik; input statik; untuk memaparkan; ReverseOrder ($ n); memanggil fungsi", "code": "< ? php function Reverseorder ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ p = $ n ; $ p >= 2 ; $ p -- ) if ( $ prime [ $ p ] ) echo $ p . \" \" ; } $ N = 25 ; echo \" Prime ▁ number ▁ in ▁ reverse ▁ order STRNEWLINE \" ; if ( $ N == 1 ) echo \" No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range \" ; else ? >"}
{"text": "Mencari n | Berfungsi untuk menghasilkan nombor tetap; Kaedah Pemandu", "code": "< ? php function magicOfSequence ( $ N ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ sum += ( $ i * $ i * $ i + $ i * 2 ) ; return $ sum ; } $ N = 4 ; echo magicOfSequence ( $ N ) ; ? >"}
{"text": "Mengekspresikan nombor sebagai jumlah berturut -turut | Tetapkan 2 (menggunakan faktor ganjil) | Mengembalikan bilangan faktor ganjil; Jika saya adalah faktor yang ganjil dan n adalah persegi yang sempurna; Jika n tidak sempurna persegi; N sebagai jumlah nombor berturut -turut", "code": "< ? php function countOddFactors ( $ n ) { $ odd_factors = 0 ; for ( $ i = 1 ; 1 * $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( 1 * $ i * $ i == $ n ) { if ( $ i & 1 ) $ odd_factors ++ ; } else { if ( $ i & 1 ) $ odd_factors ++ ; $ factor = $ n / $ i ; if ( $ factor & 1 ) $ odd_factors ++ ; } } } return $ odd_factors - 1 ; } $ N = 15 ; echo ( countOddFactors ( $ N ) . ( \" \" ) ) ; $ N = 10 ; echo ( countOddFactors ( $ N ) ) ; ? >"}
{"text": "Membuat pelbagai sifar dengan menurunkan pasangan bersebelahan | Program PHP untuk mencari sama ada mungkin untuk membuat semua elemen array 0 dengan operasi penurunan. ; Digunakan untuk menyimpan jumlah elemen kedudukan yang lebih baik dan ganjil dalam array. ; Jika kedudukan ganjil, simpan nilai jumlah kedudukan ganjil dalam ganjil; Sekiranya kedudukan adalah, simpan nilai jumlah kedudukan walaupun dalam walaupun; Kod pemacu", "code": "< ? php function isPossibleToZero ( $ a , $ n ) { $ even = 0 ; $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i & 1 ) $ odd += $ a [ $ i ] ; else $ even += $ a [ $ i ] ; } return ( $ odd == $ even ) ; } $ arr = array ( 0 , 1 , 1 , 0 ) ; $ n = sizeof ( $ arr ) ; if ( isPossibleToZero ( $ arr , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Program untuk Jumlah Siri COS (X) | Program PHP untuk mencari jumlah siri COS (X); Di sini X adalah ijazah. Kita perlu menukarnya kepada Radian untuk menggunakannya dengan formula siri, seperti dalam sudut pengembangan siri adalah dalam Radian; Kod pemacu", "code": "< ? php $ PI = 3.142 ; function cosXSertiesSum ( $ x , $ n ) { global $ PI ; $ x = $ x * ( $ PI / 180.0 ) ; $ res = 1 ; $ sign = 1 ; $ fact = 1 ; $ pow = 1 ; for ( $ i = 1 ; $ i < 5 ; $ i ++ ) { $ sign = $ sign * -1 ; $ fact = $ fact * ( 2 * $ i - 1 ) * ( 2 * $ i ) ; $ pow = $ pow * $ x * $ x ; $ res = $ res + $ sign * $ pow / $ fact ; } return $ res ; } $ x = 50 ; $ n = 5 ; echo cosXSertiesSum ( $ x , 5 ) ; ? >"}
{"text": "Jumlah digit yang ditulis di pangkalan yang berbeza dari 2 hingga n | fungsi untuk mengira jumlah digit untuk asas tertentu; Jumlah digit; Mengira nombor (n) dengan mengambil MOD dengan asas dan menambahkan selebihnya kepada hasil dan parallelly mengurangkan nilai NUM. ; mengembalikan hasilnya; fungsi memanggil pelbagai pangkalan; Kod pemacu", "code": "< ? php function solve ( $ n , $ base ) { $ result = 0 ; while ( $ n > 0 ) { $ remainder = $ n % $ base ; $ result = $ result + $ remainder ; $ n = $ n / $ base ; } return $ result ; } function printSumsOfDigits ( $ n ) { for ( $ base = 2 ; $ base < $ n ; ++ $ base ) { echo ( solve ( $ n , $ base ) ) ; echo ( \" ▁ \" ) ; } } $ n = 8 ; printSumsOfDigits ( $ n ) ; ? >"}
{"text": "Kemungkinan dua set dari perbezaan nombor semulajadi n pertama sebagai d | Fungsi pulangan benar jika mungkin untuk berpecah kepada dua set sebaliknya mengembalikan palsu; Kod pemacu", "code": "< ? php function check ( $ N , $ D ) { $ temp = ( $ N * ( $ N + 1 ) ) / 2 + $ D ; return ( $ temp % 2 == 0 ) ; } $ N = 5 ; $ M = 7 ; if ( check ( $ N , $ M ) ) echo ( \" yes \" ) ; else echo ( \" no \" ) ;"}
{"text": "Digit minimum untuk dibuang untuk membuat nombor persegi sempurna | Fungsi untuk memeriksa bilangan minimum digit hendaklah dikeluarkan untuk menjadikan nombor ini persegi yang sempurna; saiz rentetan; jawapan terakhir kami; Untuk menyimpan rentetan yang sempurna persegi. ; Kami membuat semua kemungkinan yang mungkin; Untuk memeriksa bit jth ditetapkan atau tidak. ; Kami tidak menganggap nombor dengan sifar terkemuka; Tukar rentetan sementara kami menjadi integer; Memeriksa temp adalah persegi sempurna atau tidak. ; mengambil rentetan bersaiz maksimum; cetak sempurna; Kod pemacu", "code": "< ? php function perfectSquare ( $ s ) { $ n = strlen ( $ s ) ; $ ans = -1 ; $ num = \" \" ; for ( $ i = 1 ; $ i < ( 1 << $ n ) ; $ i ++ ) { $ str = \" \" ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( $ i >> $ j ) & 1 ) { $ str = $ str . $ s [ $ j ] ; } } if ( $ str [ 0 ] != '0' ) { $ temp = 0 ; for ( $ j = 0 ; $ j < strlen ( $ str ) ; $ j ++ ) $ temp = $ temp * 10 + ( ord ( $ str [ $ j ] ) - ord ( '0' ) ) ; $ k = ( int ) ( sqrt ( $ temp ) ) ; if ( ( $ k * $ k ) == $ temp ) { if ( $ ans < strlen ( $ str ) ) { $ ans = strlen ( $ str ) ; $ num = $ str ; } } } } if ( $ ans == -1 ) return $ ans ; else { echo ( $ num . \" \" ) ; return ( $ n - $ ans ) ; } } echo ( perfectSquare ( \"8314\" ) . \" STRNEWLINE \" ) ; echo ( perfectSquare ( \"753\" ) . \" STRNEWLINE \" ) ; ? >"}
{"text": "LaGrange's Four Square Theorem | Mencetak semua kemungkinan kombinasi 4 nombor yang jumlahnya sama dengan tidak. ; gelung memeriksa jumlah kotak; Jika jumlah empat dataran sama dengan yang diberikan. ; mencetak nombor; Kod pemacu; 74 = 0 * 0 + 0 * 0 + 5 * 5 + 7 * 7 74 = 0 * 0 + 1 * 1 + 3 * 3 + 8 * 8 74 = 0 * 0 + 3 * 3 + 4 * 4 + 7 * 7 74 = 1 * 1 + 1 * 1 + 6 + 6 * 6 74 = 2 * 2 + 3 *", "code": "< ? php function printFourSquares ( $ a ) { for ( $ i = 0 ; $ i * $ i <= $ a ; $ i ++ ) { for ( $ j = $ i ; $ j * $ j <= $ a ; $ j ++ ) { for ( $ k = $ j ; $ k * $ k <= $ a ; $ k ++ ) { for ( $ l = $ k ; $ l * $ l <= $ a ; $ l ++ ) { if ( $ i * $ i + $ j * $ j + $ k * $ k + $ l * $ l == $ a ) { echo $ a , \" = \" ▁ , ▁ $ i ▁ , ▁ \" * \" ▁ , $ i , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL \" + \" ▁ , ▁ $ j ▁ , ▁ \" * \" ▁ , ▁ $ j ▁ , ▁ \" + \" echo $ k , \" * \" ▁ , ▁ $ k ▁ , ▁ \" + \" $ l , \" * \" , $ l , \" STRNEWLINE \" ; } } } } } } $ a = 74 ; printFourSquares ( $ a ) ; ? >"}
{"text": "Hardy | Fungsi untuk mengira faktor utama nombor n tertentu; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Kod pemacu", "code": "< ? php function exactPrimeFactorCount ( $ n ) { $ count = 0 ; if ( $ n % 2 == 0 ) { $ count ++ ; while ( $ n % 2 == 0 ) $ n = $ n / 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { $ count ++ ; while ( $ n % $ i == 0 ) $ n = $ n / $ i ; } } if ( $ n > 2 ) $ count ++ ; return $ count ; } $ n = 51242183 ; echo \" The ▁ number ▁ of ▁ distinct ▁ prime \" . \" ▁ factors ▁ is / are ▁ \" , exactPrimeFactorCount ( $ n ) , \" STRNEWLINE \" ; echo \" The ▁ value ▁ of ▁ log ( log ( n ) ) ▁ \" . \" is ▁ \" , log ( log ( $ n ) ) , \" STRNEWLINE \" ; ? >"}
{"text": "Bilangan digit dalam A ^ B | fungsi untuk mengira bilangan digit dalam A ^ B; Kod pemacu", "code": "< ? php function no_of_digit ( $ a , $ b ) { return ( ( int ) ( $ b * log10 ( $ a ) ) + 1 ) ; } $ a = 2 ; $ b = 100 ; echo ( \" no . ▁ of ▁ digits ▁ = ▁ \" . no_of_digit ( $ a , $ b ) ) ; ? >"}
{"text": "Semak sama ada nombor adalah emirpimes atau tidak | Memeriksa sama ada nombor adalah separuh atau tidak; Kenaikan kiraan nombor perdana; Jika nombor masih lebih besar daripada 1, selepas keluar untuk gelung menambahnya ke pemboleh ubah kiraan kerana ia menunjukkan nombor itu adalah nombor utama; Kembali '1' jika kiraan adalah sama dengan '2' lain kembali '0'; Memeriksa sama ada nombor adalah emirpimes atau tidak; Nombor itu sendiri bukan semiprime. ; Mencari terbalik n. ; Takrif emirpimes tidak termasuk palindromes, oleh itu kita tidak menyemak lebih lanjut, jika nombor yang dimasukkan adalah palindrome; Memeriksa sama ada sebaliknya nombor separuh utama yang dimasukkan juga merupakan nombor separuh utama atau tidak; Kod pemacu", "code": "< ? php function checkSemiprime ( $ num ) { $ cnt = 0 ; for ( $ i = 2 ; $ cnt < 2 && $ i * $ i <= $ num ; ++ $ i ) { while ( $ num % $ i == 0 ) { $ num /= $ i ; ++ $ cnt ; } } if ( $ num > 1 ) ++ $ cnt ; return $ cnt == 2 ; } function isEmirpimes ( $ n ) { if ( checkSemiprime ( $ n ) == false ) return false ; $ r = 0 ; for ( $ t = $ n ; $ t != 0 ; $ t = $ t / $ n ) $ r = $ r * 10 + $ t % 10 ; if ( $ r == $ n ) return false ; return ( checkSemiprime ( $ r ) ) ; } $ n = 15 ; if ( isEmirpimes ( $ n ) ) echo \" No \" ; else echo \" Yes \" ; ? >"}
{"text": "Menjana senarai nombor komposit berturut -turut (kaedah yang menarik) | fungsi untuk mencari faktorial nombor yang diberikan; Mencetak nombor berturut -turut. ; Kod pemacu", "code": "< ? php function factorial ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res *= $ i ; return $ res ; } function printNComposite ( int $ n ) { $ fact = factorial ( $ n + 1 ) ; for ( $ i = 2 ; $ i <= $ n + 1 ; ++ $ i ) echo $ fact + $ i , \" ▁ \" ; } $ n = 4 ; printNComposite ( $ n ) ; ? >"}
{"text": "Nombor berjimat | Mencari prima sehingga masuk nombor; Mencari prima dengan penapis kaedah Eratosthenes; Jika Perdana [i] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Membentuk pelbagai nombor perdana yang dijumpai; Mengembalikan bilangan digit dalam n; Memeriksa sama ada nombor adalah berjimat atau tidak; Mencari bilangan digit dalam pemfaktoran utama nombor; Eksponen untuk faktor semasa; Mengira bilangan kali faktor utama ini membahagikan (mencari eksponen); Mencari bilangan digit dalam eksponen mengelakkan eksponen nilai 1; Memeriksa keadaan untuk nombor berjimat; Kod pemacu", "code": "< ? php function primes ( $ n ) { $ prime = array ( ) ; for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) $ prime [ $ i ] = true ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ prime [ $ i ] == true ) { for ( $ j = $ i * 2 ; $ j <= $ n ; $ j += $ i ) $ prime [ $ j ] = false ; } } $ arr = array ( ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ prime [ $ i ] ) array_push ( $ arr , $ i ) ; return $ arr ; } function countDigits ( $ n ) { $ temp = $ n ; $ c = 0 ; while ( $ temp != 0 ) { $ temp = intval ( $ temp / 10 ) ; $ c ++ ; } return $ c ; } function frugal ( $ n ) { $ r = primes ( $ n ) ; $ t = $ n ; $ s = 0 ; for ( $ i = 0 ; $ i < count ( $ r ) ; $ i ++ ) { if ( $ t % $ r [ $ i ] == 0 ) { $ k = 0 ; while ( $ t % $ r [ $ i ] == 0 ) { $ t = intval ( $ t / $ r [ $ i ] ) ; $ k ++ ; } if ( $ k == 1 ) $ s = $ s + countDigits ( $ r [ $ i ] ) ; else if ( $ k != 1 ) $ s = $ s + countDigits ( $ r [ $ i ] ) + countDigits ( $ k ) ; } } return ( countDigits ( $ n ) > $ s && $ s != 0 ) ; } $ n = 343 ; if ( frugal ( $ n ) ) echo ( \" A ▁ Frugal ▁ number STRNEWLINE \" ) ; else echo ( \" Not ▁ a ▁ frugal ▁ number STRNEWLINE \" ) ; ? >"}
{"text": "N | Program PHP untuk mencari nombor N - yang kedua -dua persegi dan kiub. ; Kod pemacu", "code": "< ? php function nthSquareCube ( $ n ) { return $ n * $ n * $ n * $ n * $ n * $ n ; } $ n = 5 ; echo ( nthSquareCube ( $ n ) ) ; ? >"}
{"text": "Nombor segi tiga kuadrat (jumlah kiub) | Fungsi untuk mencari jika nombor yang diberikan adalah jumlah kiub nombor semulajadi n pertama; Mula menambah kiub nombor dari 1; Jika jumlah menjadi sama dengan s pulangan n; Kod pemacu", "code": "< ? php function findS ( $ s ) { $ sum = 0 ; for ( $ n = 1 ; $ sum < $ s ; $ n ++ ) { $ sum += $ n * $ n * $ n ; if ( $ sum == $ s ) return $ n ; } return -1 ; } $ s = 9 ; $ n = findS ( $ s ) ; if ( $ n == -1 ) echo ( \" - 1\" ) ; else echo ( $ n ) ; ? >"}
{"text": "Nombor dengan jumlah digit | Berfungsi untuk mencari nombor kth yang baik. ; Cari digit terakhir n. ; Jika digit terakhir antara 0 hingga 4 maka kembali 2 * n. ; Jika digit terakhir antara 5 hingga 9 kemudian kembali 2 * n + 1 .; Kod pemacu", "code": "< ? php function findKthGoodNo ( $ n ) { $ lastDig = $ n % 10 ; if ( $ lastDig >= 0 && $ lastDig <= 4 ) return $ n << 1 ; else return ( $ n << 1 ) + 1 ; } $ n = 10 ; echo ( findKthGoodNo ( $ n ) ) ; ? >"}
{"text": "Teorem Nicomachu | Program PHP untuk mengesahkan teorem Nicomachu; Mengira jumlah kiub; Semak sama ada jumlahnya sama dengan formula yang diberikan. ; Kod pemacu", "code": "< ? php function NicomachuTheorum_sum ( $ n ) { $ sum = 0 ; for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) $ sum += $ k * $ k * $ k ; $ triNo = $ n * ( $ n + 1 ) / 2 ; if ( $ sum == $ triNo * $ triNo ) echo \" Yes \" ; else echo \" No \" ; } $ n = 5 ; NicomachuTheorum_sum ( $ n ) ; ? >"}
{"text": "Nombor digit terbesar tidak lebih besar daripada n | berfungsi untuk memeriksa sama ada semua digit adalah nombor tertentu; melangkah untuk semua digit; Jika digit adalah ganjil; Semua digit adalah walaupun; berfungsi untuk mengembalikan nombor terbesar dengan semua digit walaupun; Iterat sehingga kita dapati nombor dengan semua digit walaupun; Kod pemacu", "code": "< ? php function checkDigits ( $ n ) { while ( $ n ) { if ( ( $ n % 10 ) % 2 ) return 0 ; $ n /= 10 ; } return 1 ; } function largestNumber ( $ n ) { for ( $ i = $ n ; ; $ i -- ) if ( checkDigits ( $ i ) ) return $ i ; } $ N = 23 ; echo ( largestNumber ( $ N ) ) ; ? >"}
{"text": "Nombor digit terbesar tidak lebih besar daripada n | berfungsi untuk mengembalikan nombor terbesar dengan semua digit walaupun; Tukar nombor ke rentetan untuk operasi mudah; Cari digit ganjil pertama; Jika tiada digit, maka n adalah jawapannya; Sehingga angka ganjil pertama, tambahkan semua nombor walaupun; Kurangkan 1 dari digit ganjil; Tambah 0 di seluruh digit; Kod pemacu", "code": "< ? php function largestNumber ( $ n ) { $ s = \" \" ; $ duplicate = $ n ; while ( $ n ) { $ s = chr ( $ n % 10 + 48 ) . $ s ; $ n = ( int ) ( $ n / 10 ) ; } $ index = -1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ s [ $ i ] - '0' ) % 2 & 1 ) { $ index = $ i ; break ; } } if ( $ index == -1 ) return $ duplicate ; $ num = 0 ; for ( $ i = 0 ; $ i < $ index ; $ i ++ ) $ num = $ num * 10 + ( ord ( $ s [ $ i ] ) - ord ( '0' ) ) ; $ num = $ num * 10 + ( ( ord ( $ s [ $ i ] ) - ord ( '0' ) ) - 1 ) ; for ( $ i = $ index + 1 ; $ i < strlen ( $ s ) ; $ i ++ ) $ num = $ num * 10 + 8 ; return $ num ; } $ N = 24578 ; echo largestNumber ( $ N ) ; ? >"}
{"text": "Bilangan digit dalam 2 yang dibangkitkan ke kuasa n | Fungsi untuk mencari bilangan digit dalam 2 ^ n; Kod pemacu", "code": "< ? php function countDigits ( $ n ) { return intval ( $ n * log10 ( 2 ) + 1 ) ; } $ n = 5 ; echo ( countDigits ( $ n ) ) ; ? >"}
{"text": "Terkecil walaupun nombor digit tidak kurang daripada n | berfungsi untuk memeriksa sama ada semua digit adalah nombor tertentu; melangkah untuk semua digit; Jika digit adalah ganjil; Semua digit adalah walaupun; berfungsi untuk mengembalikan nombor terkecil dengan semua digit walaupun; Iterat sehingga kita dapati nombor dengan semua digit walaupun; Kod pemacu", "code": "< ? php function check_digits ( $ n ) { while ( $ n ) { if ( ( $ n % 10 ) % 2 ) return 0 ; $ n /= 10 ; } return 1 ; } function smallest_number ( $ n ) { for ( $ i = $ n ; ; $ i ++ ) if ( check_digits ( $ i ) ) return $ i ; } $ N = 2397 ; echo smallest_number ( $ N ) ; ? >"}
{"text": "Nombor segitiga terkecil lebih besar daripada p | Kod PHP untuk mencari baldi untuk memilih untuk memilih bunga daripada itu; Kod pemacu", "code": "< ? php function findBucketNo ( $ p ) { return ceil ( ( sqrt ( 8 * $ p + 1 ) - 1 ) / 2 ) ; } $ p = 10 ; echo ( findBucketNo ( $ p ) ) ; ? >"}
{"text": "Lcm factorial dan jirannya | fungsi untuk mengira faktorial; mengembalikan faktorial nombor terbesar dalam tiga nombor berturut -turut; Kod pemacu", "code": "< ? php function factorial ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * factorial ( $ n - 1 ) ; } function LCMOfNeighbourFact ( $ n ) { return factorial ( $ n + 1 ) ; } $ N = 5 ; echo ( LCMOfNeighbourFact ( $ N ) ) ; ? >"}
{"text": "Semak jika dua nombor yang diberikan adalah pasangan yang mesra atau tidak | Mengembalikan jumlah semua faktor n. ; Melintasi semua faktor utama. ; Kenyataan di bawah menjadikannya lebih baik daripada kaedah di atas kerana kami mengurangkan nilai n. ; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor perdana yang lebih besar daripada 2 .; Berfungsi untuk mengembalikan GCD A dan B; Fungsi untuk memeriksa sama ada dua nombor yang diberikan adalah pasangan yang mesra atau tidak. ; Mencari jumlah faktor N dan M; Mencari GCD N dan Jumlah faktornya. ; Mencari GCD M dan Jumlah faktornya. ; Pemeriksaan adalah pengangka dan penyebut indeks kelimpahan kedua -dua nombor adalah sama atau tidak. ; Kod pemacu", "code": "< ? php function sumofFactors ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = $ n / $ i ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; } function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function checkFriendly ( $ n , $ m ) { $ sumFactors_n = sumofFactors ( $ n ) ; $ sumFactors_m = sumofFactors ( $ m ) ; $ gcd_n = gcd ( $ n , $ sumFactors_n ) ; $ gcd_m = gcd ( $ m , $ sumFactors_m ) ; if ( $ n / $ gcd_n == $ m / $ gcd_m and $ sumFactors_n / $ gcd_n == $ sumFactors_m / $ gcd_m ) return true ; else return false ; } $ n = 6 ; $ m = 28 ; if ( checkFriendly ( $ n , $ m ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cari n | Program PHP untuk mencari nombor yang bernasib baik; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi untuk mencari primorial pesanan n (produk nombor utama n pertama). ; Berfungsi untuk mencari nombor perdana seterusnya lebih besar daripada n; Perhatikan bahawa perbezaan (atau m) hendaklah lebih besar daripada 1; gelung secara berterusan sehingga isprime kembali benar untuk nombor di atas n; Mengabaikan nombor utama yang lebih besar daripada n; Mengembalikan nombor n - th yang bernasib baik; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function primorial ( $ n ) { $ p = 2 ; $ n -- ; for ( $ i = 3 ; $ n != 0 ; $ i ++ ) { if ( isPrime ( $ i ) ) { $ p = $ p * $ i ; $ n -- ; } $ i ++ ; } return $ p ; } function findNextPrime ( $ n ) { $ nextPrime = $ n + 2 ; while ( true ) { if ( isPrime ( $ nextPrime ) ) break ; $ nextPrime ++ ; } return $ nextPrime ; } function fortunateNumber ( $ n ) { $ p = primorial ( $ n ) ; return findNextPrime ( $ p ) - $ p ; } $ n = 5 ; echo fortunateNumber ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Kebarangkalian untuk tiga nombor yang dipilih secara rawak untuk berada di AP | fungsi untuk mengira kebarangkalian; Kod pemacu", "code": "< ? php function procal ( $ n ) { return ( 3.0 * $ n ) / ( 4.0 * ( $ n * $ n ) - 1 ) ; } $ a = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = sizeof ( $ a ) ; echo procal ( $ n ) ; ? >"}
{"text": "Teorem Terakhir Fermat | Program PHP untuk mengesahkan teorem terakhir Fermat untuk julat tertentu dan n. ; Semak sama ada terdapat triplet sedemikian rupa sehingga a ^ n + b ^ n = c ^ n; Kod pemacu", "code": "< ? php function testSomeNumbers ( $ limit , $ n ) { if ( $ n < 3 ) for ( $ a = 1 ; $ a <= $ limit ; $ a ++ ) for ( $ b = $ a ; $ b <= $ limit ; $ b ++ ) { $ pow_sum = pow ( $ a , $ n ) + pow ( $ b , $ n ) ; $ c = pow ( $ pow_sum , 1.0 / $ n ) ; $ c_pow = pow ( $ c , $ n ) ; if ( $ c_pow != $ pow_sum ) { echo \" Count ▁ example ▁ found \" ; return ; } } echo \" No ▁ counter ▁ example ▁ within ▁ \" . \" given ▁ range ▁ and ▁ data \" ; } testSomeNumbers ( 10 , 3 ) ; ? >"}
{"text": "Produk pecahan n yang diberikan dalam bentuk yang dikurangkan | Berfungsi untuk mengembalikan GCD A dan B; Cetak produk pecahan N dalam bentuk yang dikurangkan. ; Mencari produk semua pengangka dan penyebut N. ; Mencari GCD pengangka dan penyebut baru; Menukar ke dalam bentuk yang dikurangkan. ; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function productReduce ( $ n , $ num , $ den ) { $ new_num = 1 ; $ new_den = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ new_num *= $ num [ $ i ] ; $ new_den *= $ den [ $ i ] ; } $ GCD = gcd ( $ new_num , $ new_den ) ; $ new_num /= $ GCD ; $ new_den /= $ GCD ; echo $ new_num , \" / \" , $ new_den , \" STRNEWLINE \" ; } $ n = 3 ; $ num = array ( 1 , 2 , 5 ) ; $ den = array ( 2 , 1 , 6 ) ; productReduce ( $ n , $ num , $ den ) ; ? >"}
{"text": "Cari nilai (n ^ 1 + n ^ 2 + n ^ 3 + n ^ 4) mod 5 untuk diberikan n | fungsi untuk f (n) mod 5; jika n % 5 == 1 pulangan 4; lain kembali 0; Kod pemacu", "code": "< ? php function fnMod ( $ n ) { if ( $ n % 5 == 1 ) return 4 ; else return 0 ; } $ n = 10 ; echo fnMod ( $ n ) , \" STRNEWLINE \" ; $ n = 11 ; echo fnMod ( $ n ) ; ? >"}
{"text": "Jumlah angka rekursif nombor yang dibentuk oleh tambahan yang diulang | Kembalikan jumlah nombor satu nombor. ; Mengembalikan jumlah digit rekursif nombor yang dibentuk dengan mengulangi bilangan bilangan x kali sehingga jumlah menjadi digit tunggal. ; Kod pemacu", "code": "< ? php function digSum ( $ n ) { if ( $ n == 0 ) return 0 ; return ( $ n % 9 == 0 ) ? 9 : ( $ n % 9 ) ; } function repeatedNumberSum ( $ n , $ x ) { $ sum = $ x * digSum ( $ n ) ; return digSum ( $ sum ) ; } $ n = 24 ; $ x = 3 ; echo repeatedNumberSum ( $ n , $ x ) ; ? >"}
{"text": "Jumlah nombor digit N dibahagi dengan nombor tertentu | Mengembalikan jumlah nombor digit N yang boleh dibahagikan dengan 'nombor'; Kirakan istilah pertama dan terakhir; jumlah nombor yang mempunyai n digit dan dibahagikan dengan nombor; Kod pemacu", "code": "< ? php function totalSumDivisibleByNum ( $ n , $ number ) { $ firstnum = pow ( 10 , $ n - 1 ) ; $ lastnum = pow ( 10 , $ n ) ; $ sum = 0 ; for ( $ i = $ firstnum ; $ i < $ lastnum ; $ i ++ ) if ( $ i % $ number == 0 ) $ sum += $ i ; return $ sum ; } $ n = 3 ; $ num = 7 ; echo totalSumDivisibleByNum ( $ n , $ num ) , \" \" ; ? >"}
{"text": "Count n digit nombor dibahagikan dengan nombor yang diberikan | Mengembalikan kiraan nombor digit N dibahagi dengan 'nombor'; Kirakan istilah pertama dan terakhir; kiraan jumlah yang mempunyai n digit dan dibahagikan dengan nombor; Kod pemacu", "code": "< ? php function numberofterm ( $ n , $ number ) { $ firstnum = pow ( 10 , $ n - 1 ) ; $ lastnum = pow ( 10 , $ n ) ; $ count = 0 ; for ( $ i = $ firstnum ; $ i < $ lastnum ; $ i ++ ) if ( $ i % $ number == 0 ) $ count ++ ; return $ count ; } $ n = 3 ; $ num = 7 ; echo numberofterm ( $ n , $ num ) ; ? >"}
{"text": "N | Program PHP untuk mencari istilah n - di George Cantor set nombor rasional; Biarkan i = pengangka; biarkan j = penyebut; Untuk memastikan cek tidak. istilah; gelung sehingga k tidak sama dengan n; Semak jika k sudah sama dengan n maka istilah pertama adalah nombor rasional yang diperlukan; gelung untuk melintasi kanan ke kiri ke bawah secara menyerong; gelung untuk melintasi dari kiri ke kanan ke atas secara menyerong; Kod pemacu", "code": "< ? php function georgeCantor ( $ n ) { $ i = 1 ; $ j = 1 ; $ k = 1 ; while ( $ k < $ n ) { $ j ++ ; $ k ++ ; if ( $ k == $ n ) break ; while ( $ j > 1 && $ k < $ n ) { $ i ++ ; $ j -- ; $ k ++ ; } if ( $ k == $ n ) break ; $ i ++ ; $ k ++ ; if ( $ k == $ n ) break ; while ( $ i > 1 && $ k < $ n ) { $ i -- ; $ j ++ ; $ k ++ ; } } echo \" N - th ▁ term ▁ : ▁ \" , $ i , \" / \" , $ j ; } $ n = 15 ; georgeCantor ( $ n ) ; ? >"}
{"text": "Nombor boleh dibahagikan dengan 29 atau tidak | Pulangan benar jika n boleh dibahagikan dengan 29 orang lain mengembalikan palsu. ; Tambah LastDigit * 3 untuk baki nombor sehingga nombor menjadi hanya 2 digit; kembali benar jika nombor boleh dibahagikan dengan 29 yang lain; Kod pemacu", "code": "< ? php function isDivisible ( $ n ) { while ( intval ( $ n / 100 ) ) { $ last_digit = $ n % 10 ; $ n = intval ( $ n / 10 ) ; $ n += $ last_digit * 3 ; } return ( $ n % 29 == 0 ) ; } $ n = 348 ; if ( isDivisible ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Selesaikan persamaan linear pembolehubah tunggal | Fungsi untuk menyelesaikan persamaan yang diberikan; Melintasi persamaan; Untuk kes seperti: x, - x, + x; Tanda flip sekali '=' dilihat; Mungkin terdapat nombor yang tersisa pada akhirnya; Untuk penyelesaian tak terhingga; Untuk tiada penyelesaian; X = Jumlah Jumlah / Coeff of X ' -' Tanda menunjukkan nilai angka bergerak ke sebelah kanan; Kod pemacu", "code": "< ? php function solveEquation ( $ equation ) { $ n = strlen ( $ equation ) ; $ sign = 1 ; $ coeff = 0 ; $ total = 0 ; $ i = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ equation [ $ j ] == ' + ' $ equation [ $ j ] == ' - ' ) { if ( $ j > $ i ) $ total += $ sign * intval ( substr ( $ equation , $ i , $ j - $ i ) ) ; $ i = $ j ; } else if ( $ equation [ $ j ] == ' x ' ) { if ( ( $ i == $ j ) $ equation [ $ j - 1 ] == ' + ' ) $ coeff += $ sign ; else if ( $ equation [ $ j - 1 ] == ' - ' ) $ coeff -= $ sign ; else $ coeff += $ sign * intval ( substr ( $ equation , $ i , $ j - $ i ) ) ; $ i = $ j + 1 ; } else if ( $ equation [ $ j ] == ' = ' ) { if ( $ j > $ i ) $ total += $ sign * intval ( substr ( $ equation , $ i , $ j - $ i ) ) ; $ sign = -1 ; $ i = $ j + 1 ; } } if ( $ i < $ n ) $ total += $ sign * intval ( substr ( $ equation , $ i ) ) ; if ( $ coeff == 0 && $ total == 0 ) return \" Infinite ▁ solutions \" ; if ( $ coeff == 0 && $ total ) return \" No ▁ solution \" ; $ ans = - $ total / $ coeff ; return \" x ▁ = ▁ \" . $ ans ; } $ equation = \" x + 5-3 + x = 6 + x - 2\" ; echo ( solveEquation ( $ equation ) ) ; ? >"}
{"text": "Semak jika nombor tertentu adalah pronic | Pendekatan yang cekap | berfungsi untuk memeriksa nombor pronic; Memeriksa nombor pronic dengan mengalikan nombor berturut -turut; Kod pemacu", "code": "< ? php function pronic_check ( $ n ) { $ x = floor ( sqrt ( $ n ) ) ; if ( $ x * ( $ x + 1 ) == $ n ) return true ; else return false ; } $ n = 56 ; if ( pronic_check ( $ n ) == true ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Fungsi Kuasa Menulis Untuk Bilangan Besar | Fungsi ini didarabkan x dengan nombor yang diwakili oleh RES []. Res_size adalah saiz res [] atau bilangan digit dalam nombor yang diwakili oleh res []. Fungsi ini menggunakan matematik sekolah mudah untuk pendaraban. Fungsi ini boleh menghargai res_size dan mengembalikan nilai baru res_size; Memulakan bawa; Satu demi satu membiak n dengan digit individu res []; Simpan digit terakhir 'prod' dalam res []; Berehat di bawa; Letakkan membawa res dan meningkatkan saiz hasil; Fungsi ini mendapati kuasa nombor x; Nilai percetakan \"1\" untuk kuasa = 0; Memulakan hasil; Multiply x n kali (x ^ n = x * x * x .... n kali); Kod pemacu", "code": "< ? php function multiply ( $ x , $ res ) { $ carry = 0 ; $ res_size = count ( $ res ) ; for ( $ i = 0 ; $ i < $ res_size ; $ i ++ ) { $ prod = $ res [ $ i ] * $ x + $ carry ; $ res [ $ i ] = $ prod % 10 ; $ carry = ( int ) ( $ prod / 10 ) ; } while ( $ carry ) { if ( $ carry % 10 ) $ res [ $ res_size ++ ] = $ carry % 10 ; $ carry = ( int ) ( $ carry / 10 ) ; } return $ res ; } function power ( $ x , $ n ) { if ( $ n == 0 ) { echo \"1\" ; return ; } $ res_size = 0 ; $ res = array ( ) ; $ temp = $ x ; while ( $ temp != 0 ) { $ res [ $ res_size ++ ] = $ temp % 10 ; $ temp = $ temp / 10 ; } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = multiply ( $ x , $ res ) ; echo $ x . \" ^ \" . $ n . \" ▁ = ▁ \" ; $ O = 0 ; for ( $ i = count ( $ res ) - 1 ; $ i >= 0 ; $ i -- , $ O ++ ) if ( $ res [ $ i ] ) break ; for ( $ i = count ( $ res ) - $ O - 1 ; $ i >= 0 ; $ i -- ) echo $ res [ $ i ] ; } $ exponent = 100 ; $ base = 2 ; power ( $ base , $ exponent ) ; ? >"}
{"text": "P | berfungsi untuk memeriksa sama ada nombor n ialah nombor lancar atau tidak; Perdana Faktorise oleh 2; jika nombor itu boleh dibahagikan dengan 2; Semak semua nombor yang mungkin boleh membahagikannya; Perdana Faktornya oleh i; menyimpan maksimum jika maksimum dan saya, jika saya membahagikan nombor; Jika n pada akhirnya adalah nombor utama, maka pembahagi itu sendiri; Kod pemacu", "code": "< ? php function check ( $ n , $ p ) { $ maximum = -1 ; while ( ! ( $ n % 2 ) ) { $ maximum = max ( $ maximum , 2 ) ; $ n = $ n / 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i += 2 ) { while ( $ n % $ i == 0 ) { $ maximum = max ( $ maximum , $ i ) ; $ n = $ n / $ i ; } } if ( $ n > 2 ) $ maximum = max ( $ maximum , $ n ) ; return ( $ maximum <= $ p ) ; } $ n = 24 ; $ p = 7 ; if ( check ( $ n , $ p ) ) echo ( \" yes \" ) ; else echo ( \" no \" ) ; ? >"}
{"text": "Masa Apabila Tangan Minit dan Jam Bertepatan | berfungsi untuk mencari minit; mencari sudut antara tangan minit dan tangan jam pertama; Kod pemacu", "code": "< ? php function find_time ( $ h1 ) { $ theta = 30 * $ h1 ; echo ( \" ( \" . ( $ theta * 2 ) . \" / \" ▁ . ▁ \" 11 \" ▁ . ▁ \" ) \" ▁ . ▁ \" minutes \" } $ h1 = 3 ; find_time ( $ h1 ) ; ? >"}
{"text": "Jumlah siri (n ^ 2 | fungsi yang mengira jumlah siri nth; menggunakan formula istilah n; kod pemacu", "code": "< ? php function sum_series ( $ n ) { $ nSquare = $ n * $ n ; return $ nSquare * ( $ nSquare - 1 ) / 4 ; } $ n = 2 ; echo ( sum_series ( $ n ) ) ; ? >"}
{"text": "Semak jika nombor diapit di antara prima | pulangan benar jika nombor n adalah perdana; 0 dan 1 kedua -duanya bukan prima; mencari akar persegi n; Memeriksa jika n mempunyai faktor sehingga akar persegi n jika ya tidak perdana; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n == 0 $ n == 1 ) return false ; $ root = sqrt ( $ n ) ; for ( $ i = 2 ; $ i <= $ root ; $ i ++ ) if ( $ n % $ i == 0 ) return false ; return true ; } function isSandwitched ( $ n ) { return ( isPrime ( $ n - 1 ) && isPrime ( $ n + 1 ) ) ; } $ n = 642 ; echo $ n , \" ▁ : ▁ \" ; if ( isSandwitched ( $ n ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; $ n = 9 ; echo $ n , \" ▁ : ▁ \" ; if ( isSandwitched ( $ n ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Algoritma Tomohiko Sakamoto | berfungsi untuk melaksanakan algoritma Tomohiko Sakamoto; array dengan nilai utama nilai hari; jika bulan kurang daripada 3 mengurangkan tahun dengan 1; Kod pemacu", "code": "< ? php function day_of_the_week ( $ y , $ m , $ d ) { $ t = array ( 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ) ; if ( $ m < 3 ) $ y -= 1 ; return ( ( $ y + $ y / 4 - $ y / 100 + $ y / 400 + $ t [ $ m - 1 ] + $ d ) % 7 ) ; } $ day = 13 ; $ month = 7 ; $ year = 2017 ; echo day_of_the_week ( $ year , $ month , $ day ) ; ? >"}
{"text": "Program Rekursif untuk Nombor Perdana | Pulangan benar jika n adalah perdana, lain kembali palsu. Saya adalah pembahagi semasa untuk memeriksa. ; Kes asas; Semak pembahagi seterusnya; Kod pemacu", "code": "< ? php function isPrime ( $ n , $ i = 2 ) { if ( $ n <= 2 ) return ( $ n == 2 ) ? true : false ; if ( $ n % $ i == 0 ) return false ; if ( $ i * $ i > $ n ) return true ; return isPrime ( $ n , $ i + 1 ) ; } $ n = 15 ; if ( isPrime ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Nombor percuma persegi | Pulangan benar jika n adalah nombor percuma persegi, lain mengembalikan palsu. ; Jika 2 lagi membahagikan n, maka n bukan nombor percuma persegi. ; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Semak jika saya adalah faktor utama; Jika saya sekali lagi membahagikan, maka n tidak bebas persegi; Kod pemacu", "code": "< ? php function isSquareFree ( $ n ) { if ( $ n % 2 == 0 ) $ n = $ n / 2 ; if ( $ n % 2 == 0 ) return false ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { $ n = $ n / $ i ; if ( $ n % $ i == 0 ) return false ; } } return true ; } $ n = 10 ; if ( isSquareFree ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Kawasan persegi dari panjang pepenjuru | Mengembalikan kawasan persegi dari pepenjuru yang diberikan; Kod pemacu", "code": "< ? php function findArea ( $ d ) { return ( $ d * $ d ) / 2 ; } $ d = 10 ; echo ( findArea ( $ d ) ) ; ? >"}
{"text": "Jumlah siri 1 ^ 2 + 3 ^ 2 + 5 ^ 2 +. . . + (2 * n | berfungsi untuk mencari jumlah siri.; Kod pemacu", "code": "< ? php function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + ( 2 * $ i - 1 ) * ( 2 * $ i - 1 ) ; return $ sum ; } $ n = 10 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text": "Jumlah siri 1 ^ 2 + 3 ^ 2 + 5 ^ 2 +. . . + (2 * n | fungsi yang mencari jumlah siri.; Formula untuk mencari jumlah siri.; Kod Pemandu", "code": "< ? php function sumOfSeries ( $ n ) { return ( $ n * ( 2 * $ n - 1 ) * ( 2 * $ n + 1 ) ) / 3 ; } $ n = 10 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text": "Program untuk melaksanakan kesilapan standard min | Fungsi untuk mencari sampel min. ; gelung untuk mengira jumlah elemen array. ; Fungsi untuk mengira sisihan piawai sampel. ; Fungsi untuk mengira ralat sampel. ; Formula untuk mencari ralat sampel. ; Kod pemacu", "code": "< ? php function mean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + $ arr [ $ i ] ; return $ sum / $ n ; } function SSD ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + ( $ arr [ $ i ] - mean ( $ arr , $ n ) ) * ( $ arr [ $ i ] - mean ( $ arr , $ n ) ) ; return sqrt ( $ sum / ( $ n - 1 ) ) ; } function sampleError ( $ arr , $ n ) { return SSD ( $ arr , $ n ) / sqrt ( $ n ) ; } { $ arr = array ( 78.53 , 79.62 , 80.25 , 81.05 , 83.21 , 83.46 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo sampleError ( $ arr , $ n ) ; return 0 ; } ? >"}
{"text": "Pergerakan minimum untuk mencapai sasaran pada garis tak terhingga | Tetapkan 2 | Berfungsi untuk mencari langkah minimum untuk mencapai sasaran; Mengendalikan negatif $ oleh simetri $; Terus bergerak sementara jumlahnya lebih kecil i. e mengira n; Kes 1: D juga; D adalah ganjil; Kod pemacu; Panggilan fungsi", "code": "< ? php function StepstoReachTarget ( $ target ) { $ target = abs ( $ target ) ; $ n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * $ target ) ) / 2 ) ; $ sum = $ n * ( $ n + 1 ) / 2 ; if ( $ sum == $ target ) return $ n ; $ d = $ sum - $ target ; if ( ( $ d & 1 ) == 0 ) return n ; else return $ n + ( ( $ n & 1 ) ? 2 : 1 ) ; } $ target = 5 ; echo StepstoReachTarget ( $ target ) ; ? >"}
{"text": "Jumlah Siri 2/3 | Berfungsi untuk mencari jumlah siri - ke n terma; Inisialisasi kaunter oleh 1; pembolehubah untuk mengira hasil; sementara gelung sehingga tempoh n tidak tercapai; Pembolehubah jenis boolean untuk memeriksa pengesahan; Kod pemacu", "code": "< ? php function seriesSum ( $ n ) { $ i = 1 ; $ res = 0.0 ; $ sign = true ; while ( $ n > 0 ) { $ n -- ; if ( $ sign ) { $ sign = ! $ sign ; $ res = $ res + ( double ) ++ $ i / ++ $ i ; } else { $ sign = ! $ sign ; $ res = $ res - ( double ) ++ $ i / ++ $ i ; } } return $ res ; } $ n = 5 ; echo ( seriesSum ( $ n ) ) ; ? >"}
{"text": "Bilangan hubungan simetri pada set | Fungsi Cari kuadrat n; Kes asas; Kembali 2 ^ (n (n + 1) / 2); Kod pemacu", "code": "< ? php function countSymmetric ( $ n ) { if ( $ n == 0 ) return 1 ; return 1 << ( ( $ n * ( $ n + 1 ) ) / 2 ) ; } $ n = 3 ; echo ( countSymmetric ( $ n ) ) ; ? >"}
{"text": "Program untuk Nombor Tidak Berpusat | Fungsi untuk mencari nombor nonagon yang berpusat. ; Formula untuk mencari nombor nonagon yang berpusat di Nth. ; Kod pemacu", "code": "< ? php function centeredNonagonal ( $ n ) { return ( 3 * $ n - 2 ) * ( 3 * $ n - 1 ) / 2 ; } $ n = 10 ; echo centeredNonagonal ( $ n ) ; ? >"}
{"text": "Program untuk sisihan mutlak min | Fungsi untuk mencari min dari unsur -unsur array. ; Kirakan jumlah semua elemen. ; Fungsi untuk mencari sisihan mutlak unsur -unsur yang diberikan. ; Kirakan jumlah sisihan mutlak mengenai min. ; Pulangan bermakna sisihan mutlak mengenai min. ; Kod pemacu", "code": "< ? php function Mean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + $ arr [ $ i ] ; return $ sum / $ n ; } function meanAbsoluteDeviation ( $ arr , $ n ) { $ absSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ absSum = $ absSum + abs ( $ arr [ $ i ] - Mean ( $ arr , $ n ) ) ; return $ absSum / $ n ; } $ arr = array ( 10 , 15 , 15 , 17 , 18 , 21 ) ; $ n = sizeof ( $ arr ) ; echo meanAbsoluteDeviation ( $ arr , $ n ) ; ? >"}
{"text": "Cari jika mungkin untuk mendapatkan nisbah dari julat kos dan kuantiti yang diberikan | Pulangan benar jika mungkin untuk mendapatkan nisbah r dari julat kos dan kuantiti yang diberikan. ; Mengira kos yang sepadan dengan nilai i; Kod pemacu", "code": "< ? php function isRatioPossible ( $ lowCost , $ upCost , $ lowQuant , $ upQuant , $ r ) { for ( $ i = $ lowQuant ; $ i <= $ upQuant ; $ i ++ ) { $ ans = $ i * $ r ; if ( $ lowCost <= $ ans && $ ans <= $ upCost ) return true ; } return false ; } $ lowCost = 14 ; $ upCost = 30 ; $ lowQuant = 5 ; $ upQuant = 12 ; $ r = 9 ; if ( isRatioPossible ( $ lowCost , $ upCost , $ lowQuant , $ upQuant , $ r ) ) echo \" Yes \" ; else echo \" No \" ; # This  code is contributed by ajit NEW_LINE ? >"}
{"text": "Cari n bilangan bulat dengan perbezaan yang diberikan antara produk dan jumlah | Berfungsi untuk melaksanakan pengiraan; Kod pemacu", "code": "< ? php function findNumbers ( $ n , $ d ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) echo \"1\" , \" ▁ \" ; echo \"2\" , \" ▁ \" ; echo $ n + $ d , \" STRNEWLINE \" ; } $ N = 3 ; $ D = 5 ; findNumbers ( $ N , $ D ) ; ? >"}
{"text": "Jumlah kuasa keempat nombor semulajadi yang pertama | Kirakan jumlah kuasa keempat nombor semulajadi yang pertama; Kod pemacu", "code": "< ? php function oddNumSum ( $ n ) { return ( $ n * ( 2 * $ n + 1 ) * ( 24 * $ n * $ n * $ n - 12 * $ n * $ n - 14 * $ n + 7 ) ) / 15 ; } $ n = 4 ; echo ( oddNumSum ( $ n ) ) ; ? >"}
{"text": "Nombor trailing 0 s dalam produk dua faktorial | Mengembalikan bilangan sifar dalam faktorial n; membahagikan x dengan kuasa 5 dan kiraan kemas kini; Mengembalikan Count of Trailing Zeros di M! X N! ; Kod pemacu", "code": "< ? php function trailingZero ( $ x ) { $ i = 5 ; $ count = 0 ; while ( $ x > $ i ) { $ count = $ count + ( int ) ( $ x / $ i ) ; $ i = $ i * 5 ; } return $ count ; } function countProductTrailing ( $ M , $ N ) { return trailingZero ( $ N ) + trailingZero ( $ M ) ; } $ N = 67 ; $ M = 98 ; echo ( countProductTrailing ( $ N , $ M ) ) ; ? >"}
{"text": "Nombor Trimorphic | Berfungsi untuk memeriksa nombor trimorfik; Simpan kiub; Mula membandingkan digit; Kembali palsu, jika mana -mana digit n tidak sesuai dengan angka angka yang terakhir; Mengurangkan N dan kiub; Kod pemacu", "code": "< ? php function isTrimorphic ( $ N ) { $ cube = $ N * $ N * $ N ; while ( $ N > 0 ) { if ( $ N % 10 != $ cube % 10 ) return -1 ; $ N /= 10 ; $ cube /= 10 ; } return 1 ; } $ N = 24 ; $ r = isTrimorphic ( $ N ) ? \" trimorphic \" : \" not ▁ trimporphic \" ; echo $ r ; ? >"}
{"text": "Nombor Trimorphic | Fungsi untuk mencari nombor trimorfik n; Membandingkan digit; Kembali palsu, jika mana -mana digit dari num tidak sesuai dengan angka angka yang terakhir; Kurangkan Num dan Cube; Semak saiz max int; Nombor cek adalah trimorfik atau tidak; jika kaunter sama dengan n maka kembali nombor n; Kod pemacu", "code": "< ? php function checkTrimorphic ( $ num ) { $ cube = $ num * $ num * $ num ; while ( $ num > 0 ) { if ( $ num % 10 != $ cube % 10 ) return false ; $ num = ( int ) ( $ num / 10 ) ; $ cube = ( int ) ( $ cube / 10 ) ; } return true ; } function nthTrimorphic ( $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < PHP_INT_MAX ; $ i ++ ) { if ( checkTrimorphic ( $ i ) ) $ count ++ ; if ( $ count == $ n ) return $ i ; } } $ n = 9 ; echo nthTrimorphic ( $ n ) ; ? >"}
{"text": "Cari langkah minimum untuk mencapai sasaran pada garis tak terhingga | Program php untuk mencari langkah minimum untuk mencapai sasaran jika kita boleh memindahkan langkah -langkah saya dalam langkah saya. ; Mengendalikan negatif oleh simetri; Terus bergerak sementara jumlahnya lebih kecil atau perbezaan adalah ganjil. ; Kod pemacu", "code": "< ? php function reachTarget ( $ target ) { $ target = abs ( $ target ) ; $ sum = 0 ; $ step = 0 ; while ( $ sum < $ target or ( $ sum - $ target ) % 2 != 0 ) { $ step ++ ; $ sum += $ step ; } return $ step ; } $ target = 5 ; echo reachTarget ( $ target ) ; ? >"}
{"text": "Jumlah Kuasa Kelima Nombor Semulajadi N Pertama | Kirakan jumlah kuasa kelima nombor Natural N First; Kod pemacu", "code": "< ? php function fifthPowerSum ( $ n ) { return ( ( 2 * $ n * $ n * $ n * $ n * $ n * $ n ) + ( 6 * $ n * $ n * $ n * $ n * $ n ) + ( 5 * $ n * $ n * $ n * $ n ) - ( $ n * $ n ) ) / 12 ; } $ n = 5 ; echo ( fifthPowerSum ( $ n ) ) ; ? >"}
{"text": "Cari Digit Unit X yang dibangkitkan ke Power Y | Mengembalikan digit unit X yang dibangkitkan kepada kuasa y; Inisialisasi hasil sebagai 1 untuk mengendalikan kes apabila y adalah 0 .; Satu demi satu membiak dengan X Mod 10 untuk mengelakkan limpahan. ; Kod pemacu", "code": "< ? php function unitDigitXRaisedY ( $ x , $ y ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ y ; $ i ++ ) $ res = ( $ res * $ x ) % 10 ; return $ res ; } echo ( unitDigitXRaisedY ( 4 , 2 ) ) ; ? >"}
{"text": "Max berlaku pembahagi dalam selang | fungsi untuk mencari selang pembahagian maksimum [x, y]; Sekiranya terdapat hanya satu nombor dalam selang waktu, kembalikan nombor itu; Jika tidak, 2 adalah pembahagi maksimum; Kod pemacu", "code": "< ? php function findDivisor ( $ x , $ y ) { if ( $ x == $ y ) return $ y ; return 2 ; } $ x = 3 ; $ y = 16 ; echo findDivisor ( $ x , $ y ) ; ? >"}
{"text": "Purata Squares of Natural Number | Berfungsi untuk mengira purata nombor persegi; Kod pemacu", "code": "< ? php function AvgofSquareN ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum / $ n ; } $ n = 2 ; echo ( AvgofSquareN ( $ n ) ) ; ? >"}
{"text": "Cari jumlah faktor nombor | Mengembalikan jumlah semua faktor n. ; Jika n adalah ganjil, maka tidak ada faktor. ; Melintasi semua faktor utama. ; Walaupun saya membahagikan n, cetak saya dan membahagikan n; Di sini kita mengeluarkan 2 ^ 0 iaitu 1. Semua faktor lain; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama. ; Kod pemacu", "code": "< ? php function sumofFactors ( $ n ) { if ( $ n % 2 != 0 ) return 0 ; $ res = 1 ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = floor ( $ n / $ i ) ; if ( $ i == 2 && $ count == 1 ) $ curr_sum = 0 ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; } $ n = 18 ; echo sumofFactors ( $ n ) ; ? >"}
{"text": "Program untuk menentukan panjang fokus cermin sfera | Menentukan panjang fokus cermin cekung sfera; Menentukan panjang fokus cermin sfera sfera; Fungsi pemacu", "code": "< ? php function focal_length_concave ( $ R ) { return $ R / 2 ; } function focal_length_convex ( $ R ) { return - ( $ R / 2 ) ; } $ R = 30 ; echo \" Focal ▁ length ▁ of ▁ spherical \" , \" concave ▁ mirror ▁ is ▁ : ▁ \" , focal_length_concave ( $ R ) , \" ▁ units STRNEWLINE \" ; echo \" Focal ▁ length ▁ of ▁ spherical \" , \" ▁ convex ▁ mirror ▁ is ▁ : ▁ \" , focal_length_convex ( $ R ) , \" ▁ units \" ; ? >"}
{"text": "Cari jumlah faktor ganjil nombor | Mengembalikan jumlah semua faktor n. ; Melintasi semua faktor utama. ; Abaikan faktor walaupun dengan mengeluarkan semua kuasa 2; Walaupun saya membahagikan n, cetak saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama. ; Kod pemacu", "code": "< ? php function sumofoddFactors ( $ n ) { $ res = 1 ; while ( $ n % 2 == 0 ) $ n = $ n / 2 ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = $ n / $ i ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; } $ n = 30 ; echo sumofoddFactors ( $ n ) ; ? >"}
{"text": "Bilangan bukan | pulangan bilangan penyelesaian integral yang tidak negatif; Inisialisasi total = 0; Kes asas jika n = 1 dan val> = 0 maka ia harus kembali 1; melelehkan gelung sehingga sama dengan val; Jumlah penyelesaian persamaan dan sekali lagi memanggil penyelesaian fungsi rekursif (pembolehubah, nilai); mengembalikan jumlah penyelesaian yang tidak mungkin; Kod pemacu", "code": "< ? php function countSolutions ( $ n , $ val ) { $ total = 0 ; if ( $ n == 1 && $ val >= 0 ) return 1 ; for ( $ i = 0 ; $ i <= $ val ; $ i ++ ) { $ total += countSolutions ( $ n - 1 , $ val - $ i ) ; } return $ total ; } $ n = 5 ; $ val = 20 ; echo countSolutions ( $ n , $ val ) ; ? >"}
{"text": "Koefisien Fibonomi dan Segitiga Fibonomi | Program PHP untuk mencetak segitiga fibonomi ketinggian n. ; Berfungsi untuk menghasilkan siri Fibonacci. ; Nombor 0 dan 1 siri adalah 0 dan 1; Tambah nombor 2 sebelumnya dalam siri ini dan simpannya; Berfungsi untuk menghasilkan pekali fibonomi; Berfungsi untuk mencetak segitiga fibonomi. ; Mencari siri Fibonacci. ; Untuk menyimpan nilai segitiga. ; memulakan elemen ke -0 setiap baris dan elemen pepenjuru sama dengan 0 .; untuk setiap baris. ; untuk setiap lajur. ; Mencari setiap elemen menggunakan hubungan berulang. ; Mencetak segitiga fibonomi. ; Program yang didorong", "code": "< ? php $ N = 6 ; function fib ( & $ f , $ n ) { $ f [ 0 ] = 0 ; $ f [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ f [ $ i ] = $ f [ $ i - 1 ] + $ f [ $ i - 2 ] ; } function fibcoef ( $ fc , $ f , $ n ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ fc [ $ i ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ k = $ j ; while ( $ k -- ) $ fc [ $ i ] [ $ j ] *= $ f [ $ k ] ; $ k = 1 ; while ( ( $ j + 1 ) != $ k ) $ fc [ $ i ] [ $ j ] /= $ f [ $ k ++ ] ; } } } function printFibonomialTriangle ( $ n ) { global $ N ; $ f = array_fill ( 0 , $ N + 1 , 0 ) ; fib ( $ f , $ n ) ; $ dp = array_fill ( 0 , $ N + 1 , array_fill ( 0 , $ N + 1 , 0 ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ dp [ $ i ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j < $ i ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ f [ $ i - $ j + 1 ] * $ dp [ $ i - 1 ] [ $ j - 1 ] + $ f [ $ j - 1 ] * $ dp [ $ i - 1 ] [ $ j ] ; } for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) echo $ dp [ $ i ] [ $ j ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } } $ n = 6 ; printFibonomialTriangle ( $ n ) ; ? >"}
{"text": "Jumlah urutan geometri aritmetik | Mengembalikan jumlah terma pertama N AGP; Mencari setiap istilah AGP dan menambahnya kepada jumlah. ; Kod pemacu", "code": "< ? php function sumofNterm ( $ a , $ d , $ b , $ r , $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( ( $ a + ( $ i - 1 ) * $ d ) * ( $ b * pow ( $ r , $ i - 1 ) ) ) ; return $ sum ; } $ a = 1 ; $ d = 1 ; $ b = 2 ; $ r = 2 ; $ n = 3 ; echo ( sumofNterm ( $ a , $ d , $ b , $ r , $ n ) ) ; ? >"}
{"text": "Jumlah siri 2 + (2 + 4) + (2 + 4 + 6) + (2 + 4 + 6 + 8) + ...... + (2 + 4 + 6 + 8 + .... + 2 n) | fungsi untuk mencari jumlah siri yang diberikan; istilah pertama setiap istilah i - th; istilah seterusnya; Jumlah yang diperlukan; Program Pemandu untuk diuji di atas", "code": "< ? php function sumOfTheSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ k = 2 ; for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ sum += $ k ; $ k += 2 ; } } return $ sum ; } $ n = 5 ; echo \" Sum = \" ? >"}
{"text": "Program untuk mencari jumlah siri 1 * 2 * 3 + 2 * 3 * 4 + 3 * 4 * 5 +. . . + n * (n + 1) * (n + 2) | Fungsi untuk mengira jumlah siri. ; Kod pemacu", "code": "< ? php function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + $ i * ( $ i + 1 ) * ( $ i + 2 ) ; return $ sum ; } $ n = 10 ; echo sumOfSeries ( $ n ) ; ? >"}
{"text": "Program untuk mendapatkan jumlah siri: 1 | Fungsi untuk mendapatkan siri; Jumlah n - 1 istilah bermula dari tempoh 2 nd; Kod pemacu", "code": "< ? php function Series ( $ x , $ n ) { $ sum = 1 ; $ term = 1 ; $ fct ; $ j ; $ y = 2 ; $ m ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ fct = 1 ; for ( $ j = 1 ; $ j <= $ y ; $ j ++ ) { $ fct = $ fct * $ j ; } $ term = $ term * ( -1 ) ; $ m = $ term * pow ( $ x , $ y ) / $ fct ; $ sum = $ sum + $ m ; $ y += 2 ; } return $ sum ; } $ x = 9 ; $ n = 10 ; $ precision = 4 ; echo substr ( number_format ( Series ( $ x , $ n ) , $ precision + 1 , ' . ' , ' ' ) , 0 , -1 ) ; ? >"}
{"text": "Program untuk mendapatkan jumlah siri: 1 | Fungsi untuk mendapatkan siri; Pengkomputeran jumlah baki n - 1 istilah. ; Kod pemacu", "code": "< ? php function Series ( $ x , $ n ) { $ sum = 1 ; $ term = 1 ; $ fct = 1 ; $ p = 1 ; $ multi = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ fct = $ fct * $ multi * ( $ multi + 1 ) ; $ p = $ p * $ x * $ x ; $ term = ( -1 ) * $ term ; $ multi += 2 ; $ sum = $ sum + ( $ term * $ p ) / $ fct ; } return $ sum ; } $ x = 9 ; $ n = 10 ; $ precision = 4 ; echo substr ( number_format ( Series ( $ x , $ n ) , $ precision + 1 , ' . ' , ' ' ) , 0 , -1 ) ; ? >"}
{"text": "Cari bilangan sifar berturut -turut pada akhir selepas mengalikan nombor N | Fungsi untuk mengira dua faktor; Kiraan nombor 2 s yang ada dalam n; Fungsi untuk mengira faktor lima; Berfungsi untuk mengira bilangan sifar; Hitung faktor nombor N dua; Mengira faktor lima nombor N; Mengembalikan minimum; Kod pemacu", "code": "< ? php function two_factor ( $ n ) { $ twocount = 0 ; while ( $ n % 2 == 0 ) { $ twocount ++ ; $ n = ( int ) ( $ n / 2 ) ; } return $ twocount ; } function five_factor ( $ n ) { $ fivecount = 0 ; while ( $ n % 5 == 0 ) { $ fivecount ++ ; $ n = ( int ) ( $ n / 5 ) ; } return $ fivecount ; } function find_con_zero ( $ arr , $ n ) { $ twocount = 0 ; $ fivecount = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ twocount += two_factor ( $ arr [ $ i ] ) ; $ fivecount += five_factor ( $ arr [ $ i ] ) ; } if ( $ twocount < $ fivecount ) return $ twocount ; else return $ fivecount ; } $ arr = array ( 100 , 10 , 5 , 25 , 35 , 14 ) ; $ n = 6 ; echo find_con_zero ( $ arr , $ n ) ; ? >"}
{"text": "Kejadian pertama digit dalam pecahan yang diberikan | berfungsi untuk mencetak digit pertama; mengurangkan nombor ke modnya; melintasi setiap tempat perpuluhan; Dapatkan setiap tempat pecahan apabila (a * 10 / b) / c; Semak sama ada ia sama dengan integer yang diperlukan; mod nombor; Kod pemacu", "code": "< ? php function first ( $ a , $ b , $ c ) { $ a %= $ b ; for ( $ i = 1 ; $ i <= $ b ; $ i ++ ) { $ a = $ a * 10 ; if ( $ a / $ b == $ c ) return $ i ; $ a %= $ b ; } return -1 ; } $ a = 1 ; $ b = 4 ; $ c = 5 ; echo first ( $ a , $ b , $ c ) ; ? >"}
{"text": "Kurangkan perbezaan mutlak jumlah dua subset | berfungsi untuk mencetak perbezaan; penjumlahan elemen n; jika dibahagikan dengan 4; Jika baki 1 atau 2. Sekiranya selebihnya 2, kita membahagikan unsur -unsur dari 3 hingga N dalam kumpulan saiz 4 dan meletakkan 1 dalam satu kumpulan dan 2 dalam kumpulan. Ini juga membuat perbezaan 1 .; Kami meletakkan unsur -unsur dari 4 hingga N dalam kumpulan saiz 4. Elemen yang tinggal 1, 2 dan 3 boleh dibahagikan sebagai (1, 2) dan (3). ; Kod pemacu", "code": "< ? php function subsetDifference ( $ n ) { $ s = $ n * ( $ n + 1 ) / 2 ; if ( $ n % 4 == 0 ) { echo \" First ▁ subset ▁ sum ▁ = ▁ \" , floor ( $ s / 2 ) ; echo \" Second subset sum = \" , floor ( $ s / 2 ) ; echo \" Difference = \" } else { if ( $ n % 4 == 1 $ n % 4 == 2 ) { echo \" First ▁ subset ▁ sum ▁ = ▁ \" , floor ( $ s / 2 ) ; echo \" Second subset sum = \" , floor ( $ s / 2 + 1 ) ; echo \" Difference = \" } else { echo \" First ▁ subset ▁ sum ▁ = ▁ \" , floor ( $ s / 2 ) ; echo \" Second subset sum = \" , floor ( $ s / 2 ) ; echo \" Difference = \" ▁ , ▁ 0 ; } } } $ n = 6 ; subsetDifference ( $ n ) ; ? >"}
{"text": "Masa yang diperlukan untuk bertemu dalam segitiga sama rata | berfungsi untuk mengira masa untuk bertemu; Kod pemacu", "code": "< ? php function timeToMeet ( $ s , $ v ) { $ V = 3 * $ v / 2 ; $ time = $ s / $ V ; echo $ time ; } $ s = 25 ; $ v = 56 ; timeToMeet ( $ s , $ v ) ; ? >"}
{"text": "Semak jika nombor boleh ditulis sebagai jumlah tiga bilangan bulat berturut -turut | Fungsi untuk memeriksa sama ada nombor boleh ditulis sebagai jumlah tiga integer berturut -turut. ; jika n adalah 0; Jika n positif, gelung kenaikan sebanyak 1 .; Jika n adalah negatif, gelung penurunan sebanyak 1 .; Running Loop dari 0 hingga N - 2; Semak sama ada jumlah tiga integer berturut -turut adalah sama dengan n. ; Kod pemacu", "code": "< ? php function checksum ( $ n ) { if ( $ n == 0 ) { echo \" - 1 ▁ 0 ▁ 1\" ; return ; } $ inc ; if ( $ n > 0 ) $ inc = 1 ; else $ inc = -1 ; for ( $ i = 0 ; $ i <= $ n - 2 ; $ i += $ inc ) { if ( $ i + $ i + 1 + $ i + 2 == $ n ) { echo $ i , \" ▁ \" , $ i + 1 , \" ▁ \" , $ i + 2 ; return ; } } echo \" - 1\" ; } $ n = 6 ; checksum ( $ n ) ; ? >"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | Fungsi utiliti untuk mencari jumlah semua pembahagi nombor sehingga 'n'; Cari semua pembahagi saya dan tambahkannya; Kod pemacu", "code": "< ? php function divisorSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j * $ j <= $ i ; ++ $ j ) { if ( $ i % $ j == 0 ) { if ( $ i / $ j == $ j ) $ sum += $ j ; else $ sum += $ j + $ i / $ j ; } } } return $ sum ; } $ n = 4 ; echo \" \" , ▁ divisorSum ( $ n ) , ▁ \" \" $ n = 5 ; echo divisorSum ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk Koefisien Binomial Jadual | Berfungsi untuk mencetak jadual binomial; B (m, x) adalah 1 jika sama ada m atau x adalah 0.; Jika tidak menggunakan formula rekursif B (m, x) = b (m, x - 1) * (m - x + 1) / x; Kod pemacu", "code": "< ? php function printbinomial ( $ max ) { for ( $ m = 0 ; $ m <= $ max ; $ m ++ ) { echo $ m ; $ binom = 1 ; for ( $ x = 0 ; $ x <= $ m ; $ x ++ ) { if ( $ m != 0 && $ x != 0 ) $ binom = $ binom * ( $ m - $ x + 1 ) / $ x ; echo \" ▁ \" , $ binom , \" ▁ \" ; } echo \" STRNEWLINE \" ; } } $ max = 10 ; printbinomial ( $ max ) ; ? >"}
{"text": "Cari faktor utama terbesar nombor | Fungsi untuk mencari faktor utama terbesar; Memulakan pemboleh ubah faktor utama maksimum dengan yang paling rendah; Cetak bilangan 2 s yang membahagikan n; bersamaan dengan n /= 2; n mesti ganjil pada ketika ini; Sekarang kita perlu melangkah hanya untuk bilangan bulat yang tidak mempunyai Faktor Perdana 2 dan 3; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor perdana yang lebih besar daripada 4; Kod pemacu", "code": "< ? php function maxPrimeFactors ( $ n ) { $ maxPrime = -1 ; while ( $ n % 2 == 0 ) { $ maxPrime = 2 ; $ n >>= 1 ; } while ( $ n % 3 == 0 ) { $ maxPrime = 3 ; $ n = $ n / 3 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i += 2 ) { while ( $ n % $ i == 0 ) { $ maxPrime = $ i ; $ n = $ n / $ i ; } while ( $ n % ( $ i + 2 ) == 0 ) { $ maxPrime = $ i + 2 ; $ n = $ n / ( $ i + 2 ) ; } } if ( $ n > 4 ) $ maxPrime = $ n ; return $ maxPrime ; } $ n = 15 ; echo maxPrimeFactors ( $ n ) , \" STRNEWLINE \" ; $ n = 25698751364526 ; echo maxPrimeFactors ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Kira bit yang tidak tersembunyi dalam julat | Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari 'n'; berfungsi untuk mengira bit yang tidak tersembunyi dalam julat yang diberikan; Mengira nombor 'num' mempunyai bilangan bit dan bit dalam julat L ke r adalah satu -satunya bit yang ditetapkan; Mengembalikan bilangan bit yang tidak disetkan dalam julat 'l' ke 'r' dalam 'n'; Kod pemacu", "code": "< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ n &= ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function countUnsetBitsInGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; return ( $ r - $ l + 1 ) - countSetBits ( $ n & $ num ) ; } $ n = 80 ; $ l = 1 ; $ r = 4 ; echo countUnsetBitsInGivenRange ( $ n , $ l , $ r ) ; ? >"}
{"text": "Jumlah Kuasa Keempat Pertama N bahkan Nombor Semulajadi | Kirakan jumlah kuasa keempat Nirt N bahkan nombor semulajadi; dibuat nombor juga; Kod pemacu", "code": "< ? php function evenPowerSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ j = 2 * $ i ; $ sum = $ sum + ( $ j * $ j * $ j * $ j ) ; } return $ sum ; } $ n = 5 ; echo ( evenPowerSum ( $ n ) ) ; ? >"}
{"text": "Jumlah Kuasa Keempat Pertama N bahkan Nombor Semulajadi | Kirakan jumlah kuasa keempat Nirt N bahkan nombor semulajadi; Kod pemacu", "code": "< ? php function evenPowerSum ( $ n ) { return ( 8 * $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) * ( 3 * $ n * $ n + 3 * $ n - 1 ) ) / 15 ; } $ n = 4 ; echo ( evenPowerSum ( $ n ) ) ; ? >"}
{"text": "Balanced Prime | Program PHP untuk mencari Nth Balanced Prime; Kembalikan perdana seimbang nth. ; Ayak eratosthenes; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; menyimpan semua prima; Mencari perdana seimbang nth; Program yang didorong", "code": "< ? php $ MAX = 501 ; function balancedprime ( $ n ) { global $ MAX ; $ prime = array_fill ( 0 , $ MAX + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ MAX ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ MAX ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ v = array ( ) ; for ( $ p = 3 ; $ p <= $ MAX ; $ p += 2 ) if ( $ prime [ $ p ] ) array_push ( $ v , $ p ) ; $ count = 0 ; for ( $ i = 1 ; $ i < count ( $ v ) ; $ i ++ ) { if ( $ v [ $ i ] == ( $ v [ $ i + 1 ] + $ v [ $ i - 1 ] ) / 2 ) $ count ++ ; if ( $ count == $ n ) return $ v [ $ i ] ; } } $ n = 4 ; echo balancedprime ( $ n ) ; ? >"}
{"text": "Integer terkecil yang mempunyai faktor n atau lebih | Program PHP untuk mencetak integer terkecil dengan faktor N atau lebih; array untuk menyimpan faktor utama; berfungsi untuk menjana semua faktor utama nombor dari 1 hingga 10 ^ 6; Memulakan semua kedudukan dengan nilai mereka. ; Memulakan semua gandaan 2 dengan 2; Versi Sieve of Eratosthenes yang diubahsuai untuk menyimpan faktor utama terkecil yang membahagikan setiap nombor. ; Semak sama ada ia tidak mempunyai faktor utama. ; Memulakan j bermula dari i * i; Jika ia tidak mempunyai faktor utama sebelum ini, maka menyimpan pembahagi utama terkecil; berfungsi untuk mengira bilangan faktor; menyimpan nombor utama terkecil yang membahagikan n; menyimpan kiraan bilangan kali nombor utama membahagikan n. ; mengurangkan kepada nombor seterusnya selepas pemfaktoran utama N; palsu apabila pemfaktoran utama dilakukan; Jika nombor perdana yang sama membahagikan n, maka kami meningkatkan kiraan; Jika faktor utama yang baru yang mempraktikkan n, maka kami sekali lagi menetapkan c = 1 dan menukar DUP ke faktor utama yang baru, dan memohon formula yang dijelaskan di atas. ; Perdana mempengaruhi nombor; untuk faktor utama yang terakhir; berfungsi untuk mencari integer terkecil dengan faktor N atau lebih. ; Periksa sama ada faktor tidak lebih daripada n atau tidak; menjana faktor utama nombor sehingga 10 ^ 6", "code": "< ? php $ MAX = 100001 ; $ factor = array_fill ( 0 , $ MAX , 0 ) ; function generatePrimeFactors ( ) { global $ MAX ; global $ factor ; $ factor [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) $ factor [ $ i ] = $ i ; for ( $ i = 4 ; $ i < $ MAX ; $ i += 2 ) $ factor [ $ i ] = 2 ; for ( $ i = 3 ; $ i * $ i < $ MAX ; $ i ++ ) { if ( $ factor [ $ i ] == $ i ) { for ( $ j = $ i * $ i ; $ j < $ MAX ; $ j += $ i ) { if ( $ factor [ $ j ] == $ j ) $ factor [ $ j ] = $ i ; } } } } function calculateNoOFactors ( $ n ) { global $ factor ; if ( $ n == 1 ) return 1 ; $ ans = 1 ; $ dup = $ factor [ $ n ] ; $ c = 1 ; $ j = ( int ) ( $ n / $ factor [ $ n ] ) ; while ( $ j != 1 ) { if ( $ factor [ $ j ] == $ dup ) $ c += 1 ; else { $ dup = $ factor [ $ j ] ; $ ans = $ ans * ( $ c + 1 ) ; $ c = 1 ; } $ j = ( int ) ( $ j / $ factor [ $ j ] ) ; } $ ans = $ ans * ( $ c + 1 ) ; return $ ans ; } function smallest ( $ n ) { for ( $ i = 1 ; ; $ i ++ ) if ( calculateNoOFactors ( $ i ) >= $ n ) return $ i ; } generatePrimeFactors ( ) ; $ n = 4 ; echo smallest ( $ n ) ; ? >"}
{"text": "Jumlah Squares of First N Natural Number | Mengembalikan jumlah kuadrat nombor semulajadi n pertama; I -IREAT I dari 1 dan N mencari persegi saya dan tambah kepada jumlah. ; Kod yang didorong", "code": "< ? php function squaresum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; } $ n = 4 ; echo ( squaresum ( $ n ) ) ; ? >"}
{"text": "Memecahkan nombor sedemikian rupa sehingga jumlah pembahagi maksimum semua bahagian adalah minimum | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak. ; Jika n adalah nombor yang sama (kita boleh menulisnya sebagai jumlah dua prima); Jika n adalah ganjil dan n - 2 adalah perdana. ; Jika n adalah ganjil, n - 3 mestilah walaupun. ; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { $ i = 2 ; while ( $ i * $ i <= $ n ) { if ( $ n % $ i == 0 ) return false ; $ i ++ ; } return true ; } function minimumSum ( $ n ) { if ( isPrime ( $ n ) ) return 1 ; if ( $ n % 2 == 0 ) return 2 ; if ( isPrime ( $ n - 2 ) ) return 2 ; return 3 ; } $ n = 27 ; echo minimumSum ( $ n ) ; ? >"}
{"text": "Cari digit pertama dan terakhir nombor | Cari digit pertama; Keluarkan digit terakhir dari nombor sehingga hanya satu digit yang tersisa; Kembalikan angka pertama; Cari digit terakhir; kembalikan angka terakhir; Kod pemacu", "code": "< ? php function firstDigit ( $ n ) { while ( $ n >= 10 ) $ n /= 10 ; return ( int ) $ n ; } function lastDigit ( $ n ) { return ( ( int ) $ n % 10 ) ; } $ n = 98562 ; echo firstDigit ( $ n ) . \" ▁ \" . lastDigit ( $ n ) . \" STRNEWLINE \" ;"}
{"text": "Cari digit pertama dan terakhir nombor | Cari digit pertama; Cari jumlah digit - 1; Cari digit pertama; Kembali digit pertama; Cari digit terakhir; kembalikan angka terakhir; Kod pemacu", "code": "< ? php function firstDigit ( $ n ) { $ digits = ( int ) log10 ( $ n ) ; $ n = ( int ) ( $ n / pow ( 10 , $ digits ) ) ; return $ n ; } function lastDigit ( $ n ) { return ( $ n % 10 ) ; } $ n = 98562 ; echo firstDigit ( $ n ) , \" \" , lastDigit ( $ n ) , \" \" ; ? >"}
{"text": "Ekspresikan nombor ganjil sebagai jumlah nombor utama | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak. ; Cetakan paling banyak tiga nombor perdana yang jumlahnya adalah n. ; Kes - i; Kes - ii; Kes - iii; Kod pemacu", "code": "< ? php function isPrime ( $ x ) { if ( $ x == 0 $ x == 1 ) return false ; for ( $ i = 2 ; $ i * $ i <= $ x ; ++ $ i ) if ( $ x % $ i == 0 ) return false ; return true ; } function findPrimes ( $ n ) { if ( isPrime ( $ n ) ) echo ( $ n ) ; else if ( isPrime ( $ n - 2 ) ) echo ( 2 . \" ▁ \" . ( $ n - 2 ) ) ; else { echo ( 3 . \" ▁ \" ) ; $ n = $ n - 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( isPrime ( $ i ) && isPrime ( $ n - $ i ) ) { echo ( $ i . \" \" . ( $ n - $ i ) ) ; break ; } } } } $ n = 27 ; findPrimes ( $ n ) ; ? >"}
{"text": "Ujian Primal AKS | Array digunakan untuk menyimpan koefisien. ; Fungsi untuk mengira koefisien (x - 1) ^ n - (x ^ n - 1) dengan bantuan segitiga Pascal. ; berfungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak; Mengira semua koefisien oleh Coef Fungsi dan menyimpan semua pekali dalam array C. ; Memeriksa semua pekali sama ada mereka boleh dibahagikan dengan N atau tidak. Jika n tidak perdana, maka gelung pecah dan (i> 0). ; Kembali benar jika semua pekali boleh dibahagikan dengan n. ; Kod pemacu", "code": "< ? php global $ c ; function coef ( $ n ) { $ c [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ c [ 0 ] = - $ c [ 0 ] , $ i ++ ) { $ c [ 1 + $ i ] = 1 ; for ( $ j = $ i ; $ j > 0 ; $ j -- ) $ c [ $ j ] = $ c [ $ j - 1 ] - $ c [ $ j ] ; } } function isPrime ( $ n ) { global $ c ; coef ( $ n ) ; $ i = $ n ; while ( $ i -- && $ c [ $ i ] % $ n == 0 ) return $ i < 0 ; } $ n = 37 ; if ( isPrime ( $ n ) ) echo \" Not ▁ Prime \" , \" STRNEWLINE \" ; else echo \" Prime \" , \" STRNEWLINE \" ; ? >"}
{"text": "Nombor Motzkin | Kembalikan nombor Nth Motzkin. ; Kes asas; Langkah rekursif; Kod yang didorong", "code": "< ? php function motzkin ( $ n ) { if ( $ n == 0 $ n == 1 ) return 1 ; return ( ( 2 * $ n + 1 ) * motzkin ( $ n - 1 ) + ( 3 * $ n - 3 ) * motzkin ( $ n - 2 ) ) / ( $ n + 2 ) ; } $ n = 8 ; echo ( motzkin ( $ n ) ) ; ? >"}
{"text": "Jumlah siri 0.6, 0.06, 0.006, 0.0006, ... kepada n terma | fungsi yang mengembalikan jumlah siri; Kod pemacu", "code": "< ? php function sumOfSeries ( $ n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , $ n ) ) ; } $ n = 2 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text": "Nombor Narcissistic | Fungsi untuk mengira digit; Pulangan benar jika n adalah nombor narsisistik; mengira bilangan digit; mengira jumlah digit yang dibangkitkan kepada kuasa; Kod pemacu", "code": "< ? php function countDigit ( $ n ) { if ( $ n == 0 ) return 0 ; return ( 1 + countDigit ( $ n / 10 ) ) ; } function check ( $ n ) { $ l = countDigit ( $ n ) ; $ dup = $ n ; $ sum = 0 ; while ( $ dup ) { $ sum += pow ( $ dup % 10 , $ l ) ; $ dup = ( int ) $ dup / 10 ; } return ( $ n == $ sum ) ; } $ n = 1634 ; if ( check ( ! $ n ) ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text": "Jumlah Squares of First N Natural Number | Fungsi untuk mengira jumlah; Kod pemacu", "code": "< ? php function summation ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; } $ n = 2 ; echo summation ( $ n ) ; ? >"}
{"text": "Nombor Leyland | Program PHP untuk mencetak nombor pertama n Leyland. ; Cetak nombor pertama n Leyland. ; Gelung luar untuk x dari 2 hingga n. ; Gelung dalaman untuk y dari 2 hingga x. ; Mengira x ^ y + y ^ x; Menyusun semua nombor Leyland. ; Percetakan nombor pertama n Leyland. ; Kod pemacu", "code": "< ? php $ MAX = 100 ; function leyland ( $ n ) { $ ans ; $ index = 0 ; for ( $ x = 2 ; $ x <= $ n ; $ x ++ ) { for ( $ y = 2 ; $ y <= $ x ; $ y ++ ) { $ temp = pow ( $ x , $ y ) + pow ( $ y , $ x ) ; $ ans [ $ index ] = $ temp ; $ index ++ ; } } sort ( $ ans ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ ans [ $ i ] . \" ▁ \" ; } $ n = 6 ; leyland ( $ n ) ; ? >"}
{"text": "Teorem Nicomachus (Jumlah K | Kembalikan Jumlah Kumpulan K - Th Positif Integer .; Mencari Elemen Pertama Kumpulan Kth.", "code": "< ? php function kthgroupsum ( $ k ) { $ cur = ( $ k * ( $ k - 1 ) ) + 1 ; $ sum = 0 ; while ( $ k -- ) { $ sum += $ cur ; $ cur += 2 ; } return $ sum ; } $ k = 3 ; echo kthgroupsum ( $ k ) ; ? >"}
{"text": "N | Pulangan n - th terma 2, 12, 36, 80, 150; kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return ( $ n * $ n ) + ( $ n * $ n * $ n ) ; } $ n = 4 ; echo ( nthTerm ( $ n ) ) ; ? >"}
{"text": "Sum of the series 1 , 3 , 6 , 10. . . ( Triangular Numbers ) | Function to find the sum of series ; Kod pemacu", "code": "< ? php function seriesSum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) / 6 ; } $ n = 4 ; echo ( seriesSum ( $ n ) ) ; ? >"}
{"text": "Kirakan kelajuan, jarak dan masa | Berfungsi untuk mengira kelajuan; Fungsi untuk mengira jarak perjalanan; Fungsi untuk mengira masa yang diambil; Memanggil fungsi cal_speed (); Memanggil fungsi cal_dis (); Fungsi Call Cal_time ()", "code": "< ? php function cal_speed ( $ dist , $ time ) { echo \" Distance ( km ) : \" echo \" Time ( hr ) : \" return $ dist / $ time ; } function cal_dis ( $ speed , $ time ) { echo \" Time ( hr ) : \" echo \" Speed ( km / hr ) : \" return $ speed * $ time ; } function cal_time ( $ dist , $ speed ) { echo \" Distance ( km ) : \" echo \" Speed ( km / hr ) : \" return $ speed * $ dist ; } echo \" ▁ The ▁ calculated ▁ Speed ( km ▁ / ▁ hr ) ▁ is ▁ : ▁ \" . cal_speed ( 45.9 , 2.0 ) . \" STRNEWLINE \" ; echo \" The calculated Distance ( km ) : \" . cal_dis ( 62.9 , 2.5 ) . \" \" ; echo \" The calculated Time ( hr ) : \" . cal_time ( 48.0 , 4.5 ) . \" \" ; ? >"}
{"text": "Factorial cetak julat dalam format sejajar yang betul | Program PHP untuk mencetak format faktorial; vektor untuk menyimpan hasilnya; pembolehubah untuk menyimpan setiap faktorial nombor; salinan nombor pertama; didapati faktorial nombor pertama; Tolak nombor pertama dalam vektor hasil; Memeriksa nombor pertama; mendapati semua gelung faktorial nombor reaming berfungsi sehingga semua faktorial nombor yang diperlukan diasaskan; Simpan hasil faktorial; Memeriksa nombor pertama; mengembalikan hasilnya; fungsi untuk mencetak hasilnya; setW () digunakan untuk mengisi hak kosong digunakan untuk justifikasi data yang betul; nombor yang mendapati faktorial antara julat; Simpan hasil faktorial; fungsi untuk faktorial yang dijumpai; berfungsi untuk format cetak", "code": "< ? php function find_factorial ( $ num1 , $ num2 ) { $ vec ; $ t = 0 ; $ fac = 1 ; $ temp = $ num1 ; while ( 1 ) { if ( $ temp == 1 ) break ; $ fac *= $ temp ; $ temp -- ; } $ vec [ $ t ++ ] = $ fac ; $ num1 ++ ; while ( $ num1 <= $ num2 ) { $ fac *= $ num1 ; $ vec [ $ t ++ ] = $ fac ; $ num1 ++ ; } return ( $ vec ) ; } function print_format ( $ result ) { $ x = count ( $ result ) ; $ digits = strlen ( ( string ) $ result [ $ x - 1 ] ) ; for ( $ i = 0 ; $ i < $ x ; $ i ++ ) { echo str_pad ( $ result [ $ i ] , ( $ digits + 1 ) , \" \" , ▁ STR _ PAD _ LEFT ) ▁ . ▁ \" \" } } $ m = 10 ; $ n = 20 ; $ result_fac ; $ result_fac = find_factorial ( $ m , $ n ) ; print_format ( $ result_fac ) ; ? >"}
{"text": "Cari n | Fungsi untuk mencari istilah siri nth; Gelung untuk menambah nombor; Kod pemacu", "code": "< ? php function term ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += $ i ; return $ ans ; } $ n = 4 ; echo ( term ( $ n ) ) ; ? >"}
{"text": "Cari purata nombor semula jadi n pertama | Mengembalikan purata nombor semulajadi N pertama; Kod pemacu", "code": "< ? php function avgOfFirstN ( $ n ) { return ( float ) ( 1 + $ n ) / 2 ; } $ n = 20 ; echo ( avgOfFirstN ( $ n ) ) ; ? >"}
{"text": "Cari jumlah siri 1 + 11 + 111 + 1111 + .... . Terma -terma N syarat | Fungsi untuk mencari penjumlahan; Kod pemacu", "code": "< ? php function summation ( $ n ) { $ sum ; $ sum = ( pow ( 10 , $ n + 1 ) - 10 - ( 9 * $ n ) ) / 81 ; return $ sum ; } $ n = 5 ; echo summation ( $ n ) ; ? >"}
{"text": "Jumlah siri 1 + x / 1 + x ^ 2/2 + x ^ 3/3 +. . + x ^ n / n | kod untuk mencetak jumlah siri; Kod pemacu", "code": "< ? php function sum ( $ x , $ n ) { $ i ; $ total = 1.0 ; $ multi = $ x ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ total = $ total + $ multi / $ i ; $ multi = $ multi * $ x ; } return $ total ; } $ x = 2 ; $ n = 5 ; echo ( sum ( $ x , $ n ) ) ; ? >"}
{"text": "Cari n | berfungsi untuk menyelesaikan persamaan kuadrat; mengira istilah nth; Kod pemacu", "code": "< ? php function term ( $ n ) { $ x = ( ( ( 1 ) + ( double ) sqrt ( 1 + ( 8 * $ n ) ) ) / 2 ) ; return $ x ; } $ n = 5 ; echo ( ( int ) term ( $ n ) ) ; ? >"}
{"text": "Nombor Deserium | Mengembalikan kiraan digit dalam n. ; Pulangan benar jika x adalah diserium; Kirakan kuasa digit dari kanan ke kiri. ; Jika jumlah kuasa sama dengan nombor yang diberikan. ; Kod pemacu", "code": "< ? php function countDigits ( $ n ) { $ c = 0 ; do { $ c ++ ; $ n = $ n / 10 ; } while ( $ n != 0 ) ; return $ c ; } function isDeserium ( $ x ) { $ temp = $ x ; $ p = countDigits ( $ x ) ; $ sum = 0 ; while ( $ x != 0 ) { $ digit = $ x % 10 ; $ sum += pow ( $ digit , $ p ) ; $ p -- ; $ x = $ x / 10 ; } return ( $ sum == $ temp ) ; } $ x = 135 ; if ( isDeserium ( $ x ) ) echo \" No \" ; else echo \" Yes \" ; ? >"}
{"text": "Nombor terbesar yang diberikan 3 nombor harus dibahagikan sehingga mereka meninggalkan sisa yang sama | __GCD Fungsi; Nombor pulangan fungsi yang membahagikan ketiga -tiga nombor ini dan meninggalkan selebihnya yang sama. ; Kami mendapati perbezaan ketiga -tiga pasangan; Kembalikan GCD tiga perbezaan. ; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function sameRemainder ( $ a , $ b , $ c ) { $ a1 = ( $ b - $ a ) ; $ b1 = ( $ c - $ b ) ; $ c1 = ( $ c - $ a ) ; return gcd ( $ a1 , gcd ( $ b1 , $ c1 ) ) ; } $ a = 62 ; $ b = 132 ; $ c = 237 ; echo sameRemainder ( $ a , $ b , $ c ) ; ? >"}
{"text": "Cari gabungan min dan varians dua siri | Fungsi untuk mencari min siri. ; Berfungsi untuk mencari sisihan piawai siri. ; Fungsi untuk mencari varians gabungan dua siri yang berbeza. ; Mean1 dan Mean2 adalah min dua tatasusunan. ; SD1 dan SD2 adalah sisihan piawai dua array. ; CombinedMean adalah berubah -ubah untuk menyimpan min gabungan kedua -dua array. ; D1_Square dan D2_Square adalah sisihan min gabungan. ; CombinedVar adalah berubah -ubah untuk menyimpan varians gabungan kedua -dua array. ; Kod pemacu; Fungsi panggilan ke gabungan min.", "code": "< ? php function mean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + $ arr [ $ i ] ; $ mean = ( float ) ( $ sum / $ n ) ; return $ mean ; } function sd ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + ( $ arr [ $ i ] - mean ( $ arr , $ n ) ) * ( $ arr [ $ i ] - mean ( $ arr , $ n ) ) ; $ sdd = $ sum / $ n ; return $ sdd ; } function combinedVariance ( $ arr1 , $ arr2 , $ n , $ m ) { $ mean1 = mean ( $ arr1 , $ n ) ; $ mean2 = mean ( $ arr2 , $ m ) ; echo ( \" Mean1 : ▁ \" . round ( $ mean1 , 2 ) . \" \" ▁ . STRNEWLINE TABSYMBOL TABSYMBOL \" mean2 : \" $ sd1 = sd ( $ arr1 , $ n ) ; $ sd2 = sd ( $ arr2 , $ m ) ; echo ( \" StandardDeviation1 : \" ▁ . ▁ round ( $ sd1 , ▁ 2 ) ▁ . ▁ \" \" STRNEWLINE TABSYMBOL TABSYMBOL . ▁ \" StandardDeviation2 : \" $ combinedMean = ( float ) ( $ n * $ mean1 + $ m * $ mean2 ) / ( $ n + $ m ) ; echo ( \" Combined Mean : \" round ( $ combinedMean , 2 ) ) ; $ d1_square = ( $ mean1 - $ combinedMean ) * ( $ mean1 - $ combinedMean ) ; $ d2_square = ( $ mean2 - $ combinedMean ) * ( $ mean2 - $ combinedMean ) ; echo ( \" d1 square : \" ▁ . ▁ round ( $ d1 _ square , ▁ 2 ) ▁ . ▁ \" \" STRNEWLINE TABSYMBOL TABSYMBOL . ▁ \" d2_square : \" $ combinedVar = ( $ n * ( $ sd1 + $ d1_square ) + $ m * ( $ sd2 + $ d2_square ) ) / ( $ n + $ m ) ; return $ combinedVar ; } $ arr1 = array ( 23 , 45 , 34 , 78 , 12 , 76 , 34 ) ; $ arr2 = array ( 65 , 67 , 34 , 23 , 45 ) ; $ n = sizeof ( $ arr1 ) ; $ m = sizeof ( $ arr2 ) ; echo ( \" Combined Variance : \" . round ( combinedVariance ( $ arr1 , $ arr2 , $ n , $ m ) , 2 ) ) ; ? >"}
{"text": "Semak jika sebilangan besar boleh dibahagikan dengan 13 atau tidak | Pulangan benar jika nombor boleh dibahagikan dengan 13 pulangan palsu; Tambah diperlukan 0 s pada mulanya. ; Sama seperti strcat (num, \"00\"); dalam c. ; Sama seperti strcat (num, \"0\"); dalam c. ; Sebagai alternatif tambah / tolak digit dalam kumpulan tiga untuk keputusan. ; Simpan kumpulan tiga nombor dalam pembolehubah kumpulan. ; Menjana siri alternatif tambah dan tolak; Kod pemacu", "code": "< ? php function checkDivisibility ( $ num ) { $ length = strlen ( $ num ) ; if ( $ length == 1 && $ num [ 0 ] == '0' ) return true ; if ( $ length % 3 == 1 ) { $ num += \"00\" ; $ length += 2 ; } else if ( $ length % 3 == 2 ) { $ num += \"0\" ; $ length += 1 ; } $ sum = 0 ; $ p = 1 ; for ( $ i = $ length - 1 ; $ i >= 0 ; $ i -- ) { $ group = 0 ; $ group += $ num [ $ i -- ] - '0' ; $ group += ( $ num [ $ i -- ] - '0' ) * 10 ; $ group += ( $ num [ $ i ] - '0' ) * 100 ; $ sum = $ sum + $ group * $ p ; $ p *= ( -1 ) ; } $ sum = abs ( $ sum ) ; return ( $ sum % 13 == 0 ) ; } $ number = \"83959092724\" ; if ( checkDivisibility ( $ number ) ) echo ( $ number . \" ▁ is ▁ divisible ▁ by ▁ 13 . \" ) ; else echo ( $ number . \" ▁ is ▁ not ▁ divisible ▁ by ▁ 13 . \" ) ; ? >"}
{"text": "Diberikan dua nombor a dan b mencari semua x sedemikian rupa sehingga % x = b | Program PHP untuk mencari x supaya % x sama dengan b. ; jika A kurang daripada b maka tiada penyelesaian; jika A adalah sama dengan B maka setiap nombor lebih besar daripada A akan menjadi penyelesaian sehingga tak terhingga; Mengira Variable Store Bilangan nilai yang mungkin; Memeriksa kedua -dua pembahagi dan kuota sama ada mereka membahagikan (a - b) sepenuhnya dan lebih besar daripada b. ; Di sini y ditambah dua kali dalam lelaran terakhir supaya 1 y harus diturunkan untuk mendapatkan penyelesaian yang betul; Kod pemacu", "code": "< ? php function modularEquation ( $ a , $ b ) { if ( $ a < $ b ) { echo \" No ▁ solution ▁ possible ▁ \" ; return ; } if ( $ a == $ b ) { echo \" Infinite ▁ Solution ▁ possible ▁ \" ; return ; } $ count = 0 ; $ n = $ a - $ b ; $ y = sqrt ( $ a - $ b ) ; for ( $ i = 1 ; $ i <= $ y ; ++ $ i ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i > $ b ) $ count ++ ; if ( $ i > $ b ) $ count ++ ; } } if ( $ y * $ y == $ n && $ y > $ b ) $ count -- ; echo $ count ; } $ a = 21 ; $ b = 5 ; modularEquation ( $ a , $ b ) ; ? >"}
{"text": "Kira nombor yang berbeza yang boleh dihasilkan sehingga terdapat jumlah digit adalah sama dengan 'n' | Fungsi untuk mengira 'num' sebagai jumlah digit (1, 2, 3, 4); Memulakan array dp []; Kes asas; Memulakan array DP [] semasa sebagai '0'; jika i == J maka hanya ada satu cara untuk menulis dengan elemen itu sendiri 'i'; Jika j == 1, maka ada dua cara, satu dari '1' dan lain -lain dari '4'; Jika saya - j positif maka pilih elemen dari 'i - j' elemen array dp []; Semak modulas; kembalikan jawapan terakhir; Kod pemacu", "code": "< ? php function countWays ( $ num ) { $ dp [ $ num + 1 ] = array ( ) ; $ MOD = 100000000 + 7 ; $ dp [ 1 ] = 2 ; for ( $ i = 2 ; $ i <= $ num ; ++ $ i ) { $ dp [ $ i ] = 0 ; for ( $ j = 1 ; $ j <= 3 ; ++ $ j ) { if ( $ i - $ j == 0 ) $ dp [ $ i ] += 1 ; else if ( $ j == 1 ) $ dp [ $ i ] += $ dp [ $ i - $ j ] * 2 ; else if ( $ i - $ j > 0 ) $ dp [ $ i ] += $ dp [ $ i - $ j ] ; if ( $ dp [ $ i ] >= $ MOD ) $ dp [ $ i ] %= $ MOD ; } } return $ dp [ $ num ] ; } $ n = 3 ; echo countWays ( $ n ) ; ? >"}
{"text": "Semak sama ada nombor boleh diwakili oleh jumlah dua dataran | Semak sama ada nombor boleh diwakili oleh jumlah dua kotak menggunakan teorem fermat. ; Kira semua faktor utama. ; Ifany Faktor Perdana Borang (4 K + 3) (4 K + 3) berlaku beberapa kali ganjil. ; Jika N sendiri adalah nombor X Perdana dan boleh dinyatakan dalam bentuk 4 K + 3 kita kembali palsu. ; Kod pemacu", "code": "< ? php function judgeSquareSum ( $ n ) { for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { $ count = 0 ; if ( $ n % $ i == 0 ) { while ( $ n % $ i == 0 ) { $ count ++ ; $ n = ( int ) $ n / $ i ; } if ( $ i % 4 == 3 && $ count % 2 != 0 ) return false ; } } return $ n % 4 != 3 ; } $ n = 17 ; if ( judgeSquareSum ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Jumlah No 1 dalam nombor | fungsi untuk mengira kekerapan 1 .; Kod pemacu", "code": "< ? php function countDigitOne ( $ n ) { $ countr = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i *= 10 ) { $ divider = $ i * 10 ; $ countr += ( int ) ( $ n / $ divider ) * $ i + min ( max ( $ n % $ divider - $ i + 1 , 0 ) , $ i ) ; } return $ countr ; } $ n = 13 ; echo countDigitOne ( $ n ) , \" STRNEWLINE \" ; $ n = 113 ; echo countDigitOne ( $ n ) , \" STRNEWLINE \" ; $ n = 205 ; echo countDigitOne ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Nombor terbesar dengan digit utama | Semak jika watak adalah perdana; Gantikan dengan watak utama sebelumnya; jika 2 memadam s [i] dan gantikan seterusnya dengan 7; Cari char bukan perdana pertama; Cari char pertama lebih besar daripada 2; seperti 20; seperti 7721; menggantikan baki dengan 7; Kod pemacu", "code": "< ? php function isPrime ( $ c ) { return ( $ c == '2' $ c == '3' $ c == '5' $ c == '7' ) ? 1 : 0 ; } function decrease ( $ s , $ i ) { if ( $ s [ $ i ] <= '2' ) { $ s [ $ i ] = ' * ' ; $ a = str_split ( $ s ) ; $ s = \" \" ; for ( $ h = 0 ; $ h < count ( $ a ) ; $ h ++ ) if ( $ a [ $ h ] != ' * ' ) $ s = $ s . $ a [ $ h ] ; $ s [ $ i ] = '7' ; } else if ( $ s [ $ i ] == '3' ) $ s [ $ i ] = '2' ; else if ( $ s [ $ i ] <= '5' ) $ s [ $ i ] = '3' ; else if ( $ s [ $ i ] <= '7' ) $ s [ $ i ] = '5' ; else $ s [ $ i ] = '7' ; return $ s ; } function primeDigits ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( isPrime ( $ s [ $ i ] ) == 0 ) { while ( $ i >= 0 && $ s [ $ i ] <= '2' ) -- $ i ; if ( $ i < 0 ) { $ i = 0 ; $ s = decrease ( $ s , $ i ) ; } else $ s = decrease ( $ s , $ i ) ; for ( $ j = $ i + 1 ; $ j < strlen ( $ s ) ; $ j ++ ) $ s [ $ j ] = '7' ; break ; } } return $ s ; } $ s = \"45\" ; echo primeDigits ( $ s ) . \" STRNEWLINE \" ; $ s = \"1000\" ; echo primeDigits ( $ s ) . \" STRNEWLINE \" ; $ s = \"7721\" ; echo primeDigits ( $ s ) . \" STRNEWLINE \" ; $ s = \"7221\" ; echo primeDigits ( $ s ) . \" STRNEWLINE \" ; $ s = \"74545678912345689748593275897894708927680\" ; echo primeDigits ( $ s ) ; ? >"}
{"text": "Posisi Cetak Digit untuk dikeluarkan untuk membuat nombor yang boleh dibahagi dengan 6 | Berfungsi untuk mencetak nombor yang boleh dibahagikan dengan 6 selepas betul -betul mengeluarkan digit; menyimpan jumlah semua elemen; melintasi rentetan dan menukar rentetan ke array nombor dan menyimpulkan; jika ($ a [$ n - 1] % 2) cek ganjil; Jika kedua terakhir adalah ganjil atau jumlah unsur N - 1 tidak dapat dibahagikan dengan 3 .; Kedua terakhir adalah dan cetak n - 1 elemen mengeluarkan digit terakhir; digit terakhir dikeluarkan; kaunter untuk memeriksa sama ada unsur selepas mengeluarkan, jumlahnya 3 == 0; melintasi elemen terakhir kedua; Untuk memeriksa sama ada elemen selepas mengeluarkan, jumlahnya 3 == 0; elemen paling kiri; Pecah di elemen paling kiri; menyimpan elemen yang paling tepat; jika tiada elemen telah dijumpai sebagai [i + 1]> a [i]; Jika kedua terakhir adalah, maka keluarkan terakhir jika (jumlah - terakhir) % 3 == 0; jika tiada elemen yang dikeluarkan memberikan jumlah % 3 == 0; Kod pemacu", "code": "< ? php function greatest ( $ s ) { $ n = strlen ( $ s ) ; $ a [ $ n ] = array ( ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = $ s [ $ i ] - '0' ; $ sum += $ a [ $ i ] ; } { if ( $ a [ $ n - 2 ] % 2 != 0 or ( $ sum - $ a [ $ n - 1 ] ) % 3 != 0 ) { echo \" - 1\" , \" STRNEWLINE \" ; } else { echo $ n , \" STRNEWLINE \" ; } } else { $ re = $ sum % 3 ; $ del = -1 ; $ flag = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( ( $ a [ $ i ] ) % 3 == $ re ) { if ( $ a [ $ i + 1 ] > $ a [ $ i ] ) { $ del = $ i ; $ flag = 1 ; break ; } else { $ del = $ i ; } } } if ( $ flag == 0 ) { if ( $ a [ $ n - 2 ] % 2 == 0 and $ re == $ a [ $ n - 1 ] % 3 ) $ del = $ n - 1 ; } if ( $ del == -1 ) echo - 1 , \" STRNEWLINE \" ; else { echo $ del + 1 , \" STRNEWLINE \" ; } } } $ s = \"7510222\" ; greatest ( $ s ) ; ? >"}
{"text": "Perwakilan nombor dalam kuasa lain | Program PHP untuk memeriksa sama ada M boleh diwakili sebagai kuasa w. ; rehat; Tiada 3 bekerja. ; Jika m tidak sifar bermakna, ia tidak boleh diwakili dari segi kuasa w. ; Kod pemacu", "code": "< ? php function asPowerSum ( $ w , $ m ) { while ( $ m ) { if ( ( $ m - 1 ) % $ w == 0 ) $ m = ( $ m - 1 ) / $ w ; else if ( ( $ m + 1 ) % $ w == 0 ) $ m = ( $ m + 1 ) / $ w ; else if ( $ m % $ w == 0 ) $ m = $ m / $ w ; else } return ( $ m == 0 ) ; } $ w = 3 ; $ m = 7 ; if ( asPowerSum ( $ w , $ m ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Bilangan digit yang akan dikeluarkan untuk membuat nombor dibahagikan dengan 3 | berfungsi untuk mengira tiada penyingkiran digit untuk membuat nombor yang sangat besar dibahagikan dengan 3; Tambah semua digit NUM; Jika NUM sudah dibahagikan dengan 3 maka tidak ada digit yang akan dikeluarkan; Sekiranya terdapat satu digit, maka tidak mungkin untuk mengeluarkan satu digit. ; melintasi nombor dan mengetahui sama ada mana -mana nombor pada penyingkiran membuat jumlah yang boleh dibahagikan dengan 3; Sekiranya terdapat dua nombor maka tidak mungkin untuk mengeluarkan dua digit. ; Jika tidak, kita boleh membuat nombor berganda 2 dengan mengeluarkan 2 digit. ; Kod pemacu", "code": "< ? php function divisible ( $ num ) { $ n = strlen ( $ num ) ; $ sum = ( $ num ) ; ( $ num ) ; 0 - '0' ; if ( $ sum % 3 == 0 ) return 0 ; if ( $ n == 1 ) return -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ sum % 3 == ( $ num [ $ i ] - '0' ) % 3 ) return 1 ; if ( $ n == 2 ) return -1 ; return 2 ; } $ num = \"1234\" ; echo divisible ( $ num ) ; ? >"}
{"text": "Program untuk produk dot dan produk silang dua vektor | Pelaksanaan PHP untuk produk DOT dan produk silang dua vektor. ; Fungsi yang mengembalikan produk titik dua array vektor. ; Gelung untuk mengira produk katil; Fungsi untuk mencari produk silang dua array vektor. ; Kod pemacu; panggilan fungsi dotproduct; panggilan fungsi silang produk; Gelung yang mencetak produk silang dua array vektor.", "code": "< ? php $ n = 3 ; function dotproduct ( $ vect_A , $ vect_B ) { global $ n ; $ product = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product = $ product + $ vect_A [ $ i ] * $ vect_B [ $ i ] ; return $ product ; } function crossproduct ( $ vect_A , $ vect_B , $ cross_P ) { $ cross_P [ 0 ] = $ vect_A [ 1 ] * $ vect_B [ 2 ] - $ vect_A [ 2 ] * $ vect_B [ 1 ] ; $ cross_P [ 1 ] = $ vect_A [ 2 ] * $ vect_B [ 0 ] - $ vect_A [ 0 ] * $ vect_B [ 2 ] ; $ cross_P [ 2 ] = $ vect_A [ 0 ] * $ vect_B [ 1 ] - $ vect_A [ 1 ] * $ vect_B [ 0 ] ; return $ cross_P ; } $ vect_A = array ( 3 , -5 , 4 ) ; $ vect_B = array ( 2 , 6 , 5 ) ; $ cross_P = array_fill ( 0 , $ n , 0 ) ; echo \" Dot ▁ product : \" ; echo dotproduct ( $ vect_A , $ vect_B ) ; echo \" Cross product : \" $ cross_P = crossproduct ( $ vect_A , $ vect_B , $ cross_P ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ cross_P [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Kira cara untuk menyatakan bilangan â € ~ nâ € ™ sebagai jumlah bilangan bilangan bulat | Memulakan pembolehubah mod sebagai malar; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; Mengembalikan bilangan cara untuk menulis 'n' sebagai jumlah bilangan bulat; Kod pemacu", "code": "< ? php $ MOD = 1000000000.0 ; function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( 1 * $ res * $ x ) % $ p ; $ x = ( 1 * $ x * $ x ) % $ p ; } return $ res ; } function countEvenWays ( $ n ) { global $ MOD ; return power ( 2 , $ n / 2 - 1 , $ MOD ) ; } $ n = 6 ; echo countEvenWays ( $ n ) , \" STRNEWLINE \" ; $ n = 8 ; echo countEvenWays ( $ n ) ; ? >"}
{"text": "Bilangan langkah untuk menukar kepada faktor utama | Program PHP untuk mengira bilangan langkah yang diperlukan untuk menukar array integer ke pelbagai faktor. ; array untuk menyimpan faktor utama; berfungsi untuk menjana semua faktor utama nombor dari 1 hingga 10 ^ 6; Memulakan semua kedudukan dengan nilai mereka. ; Memulakan semua gandaan 2 dengan 2; Versi Sieve of Eratosthenes yang diubahsuai untuk menyimpan faktor utama terkecil yang membahagikan setiap nombor. ; Semak sama ada ia tidak mempunyai faktor utama. ; Memulakan j bermula dari i * i; Jika ia tidak mempunyai faktor utama sebelum ini, maka menyimpan pembahagi utama terkecil; berfungsi untuk mengira bilangan perwakilan; Simpan kiraan faktor utama; melintasi setiap elemen; mengira tidak ada faktor; tolak 1 jika AI tidak 1 sebagai langkah terakhir tidak akan diambil ke dalam hitung; Panggil ayak untuk mengira faktor", "code": "< ? php $ MAX = 100001 ; $ factor = array_fill ( 0 , $ MAX + 1 , 0 ) ; function cal_factor ( ) { global $ factor , $ MAX ; $ factor [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) $ factor [ $ i ] = $ i ; for ( $ i = 4 ; $ i < $ MAX ; $ i += 2 ) $ factor [ $ i ] = 2 ; for ( $ i = 3 ; $ i * $ i < $ MAX ; $ i ++ ) { if ( $ factor [ $ i ] == $ i ) { for ( $ j = $ i * $ i ; $ j < $ MAX ; $ j += $ i ) { if ( $ factor [ $ j ] == $ j ) $ factor [ $ j ] = $ i ; } } } } function no_of_representations ( $ a , $ n ) { global $ factor , $ MAX ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp = $ a [ $ i ] ; $ flag = 0 ; while ( $ factor [ $ temp ] != 1 ) { $ flag = -1 ; $ count ++ ; $ temp = ( int ) ( $ temp / $ factor [ $ temp ] ) ; } $ count += $ flag ; } return $ count ; } cal_factor ( ) ; $ a = array ( 4 , 4 , 4 ) ; $ n = count ( $ a ) ; echo no_of_representations ( $ a , $ n ) ; ? >"}
{"text": "Seterusnya saiz tiga dalam array yang jumlahnya dapat dibahagikan dengan m | Pelaksanaan Pasukan Brute (Kompleks Masa: O (N ^ 3)) Program PHP untuk mencari kiraan berikutnya saiz tiga yang boleh dibahagi oleh m. ; Tiga gelung bersarang untuk mencari semua sub urutan panjang tiga dalam array yang diberikan []. ; Memeriksa jika jumlah tiga nombor yang dipilih boleh dibahagikan dengan m. ; Kod pemacu", "code": "< ? php function coutSubSeq ( $ A , $ N , $ M ) { $ sum = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ N ; $ k ++ ) { $ sum = $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] ; if ( $ sum % $ M == 0 ) $ ans ++ ; } } } return $ ans ; } $ M = 3 ; $ A = array ( 1 , 2 , 4 , 3 ) ; $ N = count ( $ A ) ; echo coutSubSeq ( $ A , $ N , $ M ) ; ? >"}
{"text": "Seterusnya saiz tiga dalam array yang jumlahnya dapat dibahagikan dengan m | O (M ^ 2) Program PHP Kerumitan Masa Untuk mencari kiraan seterusnya saiz tiga yang boleh dibahagi dengan m. ; Menyimpan frekuensi semua sisa apabila dibahagikan dengan m. ; termasuk i dan j dalam jumlah rem mengira baki yang diperlukan untuk membuat jumlah yang boleh dibahagikan oleh m; Jika nombor yang diperlukan kurang daripada J, kami melangkau seperti yang telah kami kirakan untuk nilai itu sebelum ini. Seperti J di sini bermula dengan saya dan REM kurang daripada j. ; Jika memenuhi kes pertama. ; jika memenuhi kes kedua; jika memenuhi kes ketiga; Kod pemacu", "code": "< ? php function countSubSeq ( $ A , $ N , $ M ) { $ ans = 0 ; $ h = array_fill ( 0 , $ M , 0 ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ A [ $ i ] = $ A [ $ i ] % $ M ; $ h [ $ A [ $ i ] ] ++ ; } for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = $ i ; $ j < $ M ; $ j ++ ) { $ rem = ( $ M - ( $ i + $ j ) % $ M ) % $ M ; if ( $ rem < $ j ) continue ; if ( $ i == $ j && $ rem == $ j ) $ ans += $ h [ $ i ] * ( $ h [ $ i ] - 1 ) * ( $ h [ $ i ] - 2 ) / 6 ; else if ( $ i == $ j ) $ ans += $ h [ $ i ] * ( $ h [ $ i ] - 1 ) * $ h [ $ rem ] / 2 ; else if ( $ i == $ rem ) $ ans += $ h [ $ i ] * ( $ h [ $ i ] - 1 ) * $ h [ $ j ] / 2 ; else if ( $ rem == $ j ) $ ans += $ h [ $ j ] * ( $ h [ $ j ] - 1 ) * $ h [ $ i ] / 2 ; else $ ans = $ ans + $ h [ $ i ] * $ h [ $ j ] * $ h [ $ rem ] ; } } return $ ans ; } $ M = 3 ; $ A = array ( 1 , 2 , 4 , 3 ) ; $ N = count ( $ A ) ; echo countSubSeq ( $ A , $ N , $ M ) ; ? >"}
{"text": "Cari n | fungsi utiliti; Oleh kerana elemen pertama siri ini adalah 7, kita memulakan pembolehubah dengan 7; Menggunakan lelaran untuk mencari istilah n; Kod pemacu", "code": "< ? php function findTerm ( $ n ) { if ( $ n == 1 ) return $ n ; else { $ term = 7 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ term = $ term * 2 + ( $ i - 1 ) ; return $ term ; } } $ n = 5 ; echo ( findTerm ( $ n ) ) ; ? >"}
{"text": "Cari n | Pulangan N - TH dalam urutan 1, 1, 2, 1, 2, 3, 1, 2, 4, ...; Satu demi satu tolak mengira elemen dalam blok yang berbeza; Kod pemacu", "code": "< ? php function findNumber ( $ n ) { $ n -- ; $ i = 1 ; while ( $ n >= 0 ) { $ n -= $ i ; ++ $ i ; } return ( $ n + $ i ) ; } $ n = 3 ; echo findNumber ( $ n ) ; ? >"}
{"text": "Program untuk mencari pekali korelasi | fungsi yang mengembalikan pekali korelasi. ; Jumlah elemen array x. ; Jumlah elemen array y. ; Jumlah x [i] * y [i]. ; Jumlah persegi elemen array. ; Gunakan formula untuk mengira pekali korelasi. ; Kod pemacu; Cari saiz array. ; Fungsi panggilan ke correlationcoefficient.", "code": "< ? php function correlationCoefficient ( $ X , $ Y , $ n ) { $ sum_X = 0 ; $ sum_Y = 0 ; $ sum_XY = 0 ; $ squareSum_X = 0 ; $ squareSum_Y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum_X = $ sum_X + $ X [ $ i ] ; $ sum_Y = $ sum_Y + $ Y [ $ i ] ; $ sum_XY = $ sum_XY + $ X [ $ i ] * $ Y [ $ i ] ; $ squareSum_X = $ squareSum_X + $ X [ $ i ] * $ X [ $ i ] ; $ squareSum_Y = $ squareSum_Y + $ Y [ $ i ] * $ Y [ $ i ] ; } $ corr = ( float ) ( $ n * $ sum_XY - $ sum_X * $ sum_Y ) / sqrt ( ( $ n * $ squareSum_X - $ sum_X * $ sum_X ) * ( $ n * $ squareSum_Y - $ sum_Y * $ sum_Y ) ) ; return $ corr ; } $ X = array ( 15 , 18 , 21 , 24 , 27 ) ; $ Y = array ( 25 , 25 , 27 , 31 , 32 ) ; $ n = sizeof ( $ X ) ; echo correlationCoefficient ( $ X , $ Y , $ n ) ; ? >"}
{"text": "Cari bilangan penonton yang berdiri di stadium pada masa t | Program PHP untuk mencari bilangan penonton yang berdiri pada satu masa; Sekiranya masa kurang daripada k maka kita boleh mencetak secara langsung masa. ; Jika masa adalah n maka penonton K berdiri. ; Jika tidak, kami mengira penonton berdiri. ; Menyimpan nilai n, k dan t t adalah masa n & k adalah bilangan spesies", "code": "< ? php function result ( $ n , $ k , $ t ) { if ( $ t <= $ k ) echo t ; else if ( $ t <= $ n ) echo k ; else { $ temp = $ t - $ n ; $ temp = $ k - $ temp ; echo $ temp ; } } $ n = 10 ; $ k = 5 ; $ t = 12 ; result ( $ n , $ k , $ t ) ; ? >"}
{"text": "Program untuk purata berat bilangan semula jadi. | Fungsi untuk mengira min yang berwajaran. ; Ambil array Num dan array berat yang sepadan dan mulakannya. ; Kirakan saiz array. ; Semak saiz kedua -dua array adalah sama atau tidak.", "code": "< ? php function weightedMean ( $ X , $ W , $ n ) { $ sum = 0 ; $ numWeight = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ numWeight = $ numWeight + $ X [ $ i ] * $ W [ $ i ] ; $ sum = $ sum + $ W [ $ i ] ; } return ( float ) ( $ numWeight / $ sum ) ; } $ X = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; $ W = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; $ n = sizeof ( $ X ) ; $ m = sizeof ( $ W ) ; if ( $ n == $ m ) echo ( weightedMean ( $ X , $ W , $ n ) ) ; else echo ( \" - 1\" ) ; ? >"}
{"text": "Program untuk mencari GCD nombor titik terapung | Fungsi rekursif untuk mengembalikan GCD A dan B; Kes asas; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a < $ b ) return gcd ( $ b , $ a ) ; if ( abs ( $ b ) < 0.001 ) return $ a ; else return ( gcd ( $ b , $ a - floor ( $ a / $ b ) * $ b ) ) ; } $ a = 1.20 ; $ b = 22.5 ; echo gcd ( $ a , $ b ) ; ? >"}
{"text": "Program untuk harmonik Maksud nombor | Fungsi yang mengembalikan purata harmonik. ; Mengisytiharkan jumlah pembolehubah dan permulaan dengan sifar; Kod pemacu", "code": "< ? php function harmonicMean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + ( float ) ( 1 / $ arr [ $ i ] ) ; return ( float ) ( $ n / $ sum ) ; } $ arr = array ( 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ) ; $ n = sizeof ( $ arr ) ; echo ( harmonicMean ( $ arr , $ n ) ) ; ? >"}
{"text": "Program untuk harmonik Maksud nombor | Fungsi yang mengembalikan purata harmonik. ; Kod pemacu", "code": "< ? php function harmonicMean ( $ arr , $ freq , $ n ) { $ sum = 0 ; $ frequency_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( float ) ( $ freq [ $ i ] / $ arr [ $ i ] ) ; $ frequency_sum = $ frequency_sum + $ freq [ $ i ] ; } return ( $ frequency_sum / $ sum ) ; } $ num = array ( 13 , 14 , 15 , 16 , 17 ) ; $ freq = array ( 2 , 5 , 13 , 7 , 3 ) ; $ n = sizeof ( $ num ) ; echo ( harmonicMean ( $ num , $ freq , $ n ) ) ; ? >"}
{"text": "Titik perlanggaran pertama dua siri | Program PHP untuk mengira titik berlanggar dua siri; Melangkah melalui terma s siri pertama; X adalah istilah siri pertama; D adalah elemen pertama siri kedua dan C adalah perbezaan biasa untuk siri kedua. ; Jika tiada istilah siri pertama dijumpai; Kod pemacu", "code": "< ? php function point ( $ a , $ b , $ c , $ d , $ n ) { $ x ; $ flag = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = $ b + $ i * $ a ; if ( ( $ x - $ d ) % $ c == 0 and $ x - $ d >= 0 ) { echo $ x ; $ flag = 1 ; break ; } } if ( $ flag == 0 ) { echo \" No ▁ collision ▁ po $ \" ; } } $ a = 20 ; $ b = 2 ; $ c = 9 ; $ d = 19 ; $ n = 20 ; point ( $ a , $ b , $ c , $ d , $ n ) ; ? >"}
{"text": "Bilangan Armstrong antara dua bilangan bulat | Mencetak nombor Armstrong dalam julat yang diberikan; bilangan pengiraan digit; mengira jumlah kuasa nth digitnya; cek jika nombor saya sama dengan jumlah kuasa nth digitnya; Kod pemacu", "code": "< ? php function findArmstrong ( $ low , $ high ) { for ( $ i = $ low + 1 ; $ i < $ high ; ++ $ i ) { $ x = $ i ; $ n = 0 ; while ( $ x != 0 ) { $ x = ( int ) ( $ x / 10 ) ; ++ $ n ; } $ pow_sum = 0 ; $ x = $ i ; while ( $ x != 0 ) { $ digit = $ x % 10 ; $ pow_sum += ( int ) ( pow ( $ digit , $ n ) ) ; $ x = ( int ) ( $ x / 10 ) ; } if ( $ pow_sum == $ i ) echo $ i . \" \" ; } } $ num1 = 100 ; $ num2 = 400 ; findArmstrong ( $ num1 , $ num2 ) ; ? >"}
{"text": "Sepasang dengan GCD maksimum dari dua tatasusunan | Cari pasangan GCD maksimum dengan jumlah maksimum; array untuk menyimpan kiraan unsur -unsur yang ada; Pertama [i] dan kedua [i] akan menyimpan gandaan maksimum I dalam [] dan B [] masing -masing. ; melintasi array pertama untuk menandakan unsur -unsur dalam CNT; Cari pelbagai maksimum setiap nombor dalam array pertama; Cari pelbagai maksimum setiap nombor dalam array kedua yang kita semula - inisial CNT [] dan melintasi array kedua untuk menandakan unsur -unsur dalam CNT; Jika berbilang hadir dalam array kedua kemudian simpan maksimum nombor atau elemen pra - sedia ada; melintasi setiap elemen dan memeriksa maksimum n yang terdapat dalam kedua -dua tatasusunan; Kod pemacu; Nilai maksimum elemen dalam kedua -dua tatasusunan.", "code": "< ? php function gcdMax ( $ a , $ b , $ n , $ N ) { $ cnt = array_fill ( 0 , $ N , 0 ) ; $ first = array_fill ( 0 , $ N , 0 ) ; $ second = array_fill ( 0 , $ N , 0 ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cnt [ $ a [ $ i ] ] = 1 ; for ( $ i = 1 ; $ i < $ N ; ++ $ i ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) if ( $ cnt [ $ j ] ) $ first [ $ i ] = max ( $ first [ $ i ] , $ j ) ; $ cnt = array_fill ( 0 , $ N , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ cnt [ $ b [ $ i ] ] = 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) if ( $ cnt [ $ j ] ) $ second [ $ i ] = max ( $ second [ $ i ] , $ j ) ; $ x = $ N - 1 ; for ( ; $ x >= 0 ; $ x -- ) if ( $ first [ $ x ] && $ second [ $ x ] ) break ; echo $ first [ $ x ] . \" ▁ \" . $ second [ $ x ] . \" STRNEWLINE \" ; } $ a = array ( 3 , 1 , 4 , 2 , 8 ) ; $ b = array ( 5 , 2 , 12 , 8 , 3 ) ; $ n = sizeof ( $ a ) ; $ N = 20 ; gcdMax ( $ a , $ b , $ n , $ N ) ; ? >"}
{"text": "Pierpont Prime | Program PHP untuk mencetak nombor perdana Pierpont lebih kecil daripada n. ; Mencari semua nombor yang mempunyai kuasa faktor 2 dan 3 menggunakan ayak; Menyimpan bilangan borang 2 ^ i. 3 ^ K + 1 .; Mencari nombor utama menggunakan SIEVE OF ERATOSTHENES. Menggunakan semula array yang sama sebagai hasil pengiraan di atas dalam v. ; Percetakan n Pierpont Prima lebih kecil daripada N; Kod pemacu", "code": "< ? php function printPierpont ( $ n ) { $ arr = array_fill ( 0 , $ n + 1 , false ) ; $ two = 1 ; $ three = 1 ; while ( $ two + 1 < $ n ) { $ arr [ $ two ] = true ; while ( $ two * $ three + 1 < $ n ) { $ arr [ $ three ] = true ; $ arr [ $ two * $ three ] = true ; $ three *= 3 ; } $ three = 1 ; $ two *= 2 ; } $ v ; $ x = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] ) $ v [ $ x ++ ] = $ i + 1 ; $ arr1 = array_fill ( 0 , count ( $ arr ) , false ) ; for ( $ p = 2 ; $ p * $ p < $ n ; $ p ++ ) { if ( $ arr1 [ $ p ] == false ) for ( $ i = $ p * 2 ; $ i < $ n ; $ i += $ p ) $ arr1 [ $ i ] = true ; } for ( $ i = 0 ; $ i < $ x ; $ i ++ ) if ( ! $ arr1 [ $ v [ $ i ] ] ) echo $ v [ $ i ] . \" ▁ \" ; } $ n = 200 ; printPierpont ( $ n ) ; ? >"}
{"text": "Nombor Woodall | Program PHP untuk memeriksa sama ada nombor adalah Woodball atau tidak. ; Sekiranya nombor adalah, kembali palsu. ; Jika x adalah 1, kembali benar. ; Tambah 1 untuk membuat x walaupun; Manakala X boleh dibahagikan dengan 2; Bahagikan x oleh 2; Mengira kuasa; Jika pada mana -mana kuasa dan X menjadi sama, kembali benar. ; Kod pemacu", "code": "< ? php function isWoodall ( $ x ) { if ( $ x % 2 == 0 ) return false ; if ( $ x == 1 ) return true ; $ x ++ ; $ p = 0 ; while ( $ x % 2 == 0 ) { $ x = $ x / 2 ; $ p ++ ; if ( $ p == $ x ) return true ; } return false ; } $ x = 383 ; if ( isWoodall ( $ x ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cetak K nombor di mana semua pasangan boleh dibahagikan dengan m | berfungsi untuk menjana nombor k yang perbezaannya dapat dibahagikan dengan m; Menggunakan senarai adjacency seperti perwakilan untuk menyimpan nombor yang membawa kepada sisa yang sama. ; menyimpan modulus apabila dibahagikan dengan m; Jika kita dapati elemen K yang mempunyai selebihnya. ; Jika kita tidak dapat mencari elemen K; Kod pemacu", "code": "< ? php function print_result ( $ a , $ n , $ k , $ m ) { $ v = array_fill ( 0 , $ m + 1 , array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ rem = $ a [ $ i ] % $ m ; array_push ( $ v [ $ rem ] , $ a [ $ i ] ) ; if ( count ( $ v [ $ rem ] ) == $ k ) { for ( $ j = 0 ; $ j < $ k ; $ j ++ ) echo $ v [ $ rem ] [ $ j ] . \" ▁ \" ; return ; } } echo \" - 1\" ; } $ a = array ( 1 , 8 , 4 ) ; $ n = count ( $ a ) ; print_result ( $ a , $ n , 2 , 3 ) ; ? >"}
{"text": "Terkecil x sedemikian rupa sehingga 1 * n, 2 * n, ... x * n mempunyai semua digit dari 1 hingga 9 | Mengembalikan nilai terkecil x sedemikian rupa sehingga 1 * n, 2 * n, 3 * n ... x * n mempunyai semua digit dari 1 hingga 9 sekurang -kurangnya sekali; mengambil pelbagai sementara dan pemboleh ubah. ; melangkah sehingga kita mendapat semua 10 digit sekurang -kurangnya sekali; memeriksa semua digit; Kod pemacu", "code": "< ? php function smallestX ( $ n ) { $ temp = array_fill ( 0 , 10 , false ) ; if ( $ n == 0 ) return -1 ; $ count = 0 ; $ x = 0 ; for ( $ x = 1 ; $ count < 10 ; $ x ++ ) { $ y = $ x * $ n ; while ( $ y ) { if ( $ temp [ $ y % 10 ] == false ) { $ count ++ ; $ temp [ $ y % 10 ] = true ; } $ y = ( int ) ( $ y / 10 ) ; } } return $ x - 1 ; } $ n = 5 ; echo smallestX ( $ n ) ; ? >"}
{"text": "Cari nombor x sedemikian rupa sehingga jumlah x dan digitnya sama dengan n. | fungsi utiliti untuk jumlah digit; fungsi untuk mencari x; berulang dari 1 hingga n. Untuk setiap tidak. Semak sama ada jumlah digit dengannya adalah sama dengan n. ; jika tidak seperti itu saya dapati kembali - 1; Kod pemacu", "code": "< ? php function digSum ( $ n ) { $ sum = 0 ; $ rem = 0 ; while ( $ n ) { $ rem = $ n % 10 ; $ sum += $ rem ; $ n /= 10 ; } return $ sum ; } function findX ( $ n ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( $ i + digSum ( $ i ) == $ n ) return $ i ; return -1 ; } $ n = 43 ; echo \" x = \" ? >"}
{"text": "9 's pelengkap nombor perpuluhan | Program PHP untuk mencari pelengkap nombor 9. ; Kod pemacu", "code": "< ? php function complement ( $ number ) { for ( $ i = 0 ; $ i < strlen ( $ number ) ; $ i ++ ) if ( $ number [ $ i ] != ' . ' ) $ number [ $ i ] = '9' - $ number [ $ i ] + '0' ; echo \"9 ' s ▁ complement ▁ is ▁ : ▁ \" , $ number ; } $ number = \"345.45\" ; complement ( $ number ) ; ? >"}
{"text": "Cara untuk mengekspresikan nombor sebagai produk daripada dua faktor yang berbeza | Untuk mengira bilangan cara di mana nombor yang dinyatakan sebagai produk dari dua nombor yang berbeza; Untuk menyimpan kiraan pasangan itu; Mengira bilangan pasangan sehingga sqrt (n) - 1; Untuk mengembalikan kiraan pasangan; Kod pemacu", "code": "< ? php function countWays ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i * $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ count ++ ; return $ count ; } $ n = 12 ; echo countWays ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Count pembahagi n yang ada di | Fungsi untuk kembali benar jika mana -mana digit M ada dalam hash []. ; Semak sehingga digit terakhir; Jika nombor juga terdapat dalam nombor asal maka kembali benar; jika tiada nombor sepadan maka kembali 1; Kira tidak ada pembahagi yang mempunyai sekurang -kurangnya 1 digit sama; Menyimpan digit yang terdapat dalam n dalam hash []; menandakan bahawa nombor itu ada; digit terakhir dikeluarkan; gelung untuk melintasi 1 ke sqrt (n) untuk mengira pembahagi; Jika saya adalah faktor; Hubungi fungsi untuk memeriksa sama ada mana -mana digit sepadan atau tidak; Jika n / i! = Saya kemudian nombor yang berbeza, maka periksa juga; kembalikan jawapannya; Kod pemacu", "code": "< ? php function isDigitPresent ( $ m , $ hash ) { while ( $ m ) { if ( $ hash [ $ m % 10 ] ) return true ; $ m = ( int ) ( $ m / 10 ) ; } return false ; } function countDivisibles ( $ n ) { $ hash = array_fill ( 0 , 10 , false ) ; $ m = $ n ; while ( $ m ) { $ hash [ $ m % 10 ] = true ; $ m = ( int ) ( $ m / 10 ) ; } $ ans = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( isDigitPresent ( $ i , $ hash ) ) $ ans ++ ; if ( ( int ) ( $ n / $ i ) != $ i ) { if ( isDigitPresent ( ( int ) ( $ n / $ i ) , $ hash ) ) $ ans ++ ; } } } return $ ans ; } $ n = 15 ; echo countDivisibles ( $ n ) ; ? >"}
{"text": "Algoritma Doolittle: Penguraian LU | Program PHP untuk menguraikan matriks ke dalam matriks segi tiga dan atas; Menusuk matriks ke dalam matriks segi tiga atas dan bawah; Segitiga atas; Penjumlahan l (i, j) * u (j, k); Menilai u (i, k); Rendah segi tiga; $ lebih rendah [$ i] [$ i] = 1; Diagonal sebagai 1; Penjumlahan l (k, j) * u (j, i); Menilai l (k, i); SETW adalah untuk memaparkan dengan baik; Memaparkan hasilnya :; Lebih rendah; Atas; Kod pemacu", "code": "< ? php $ MAX = 100 ; function luDecomposition ( $ mat , $ n ) { $ lower ; $ upper ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ lower [ $ i ] [ $ j ] = 0 ; $ upper [ $ i ] [ $ j ] = 0 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ k = $ i ; $ k < $ n ; $ k ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ sum += ( $ lower [ $ i ] [ $ j ] * $ upper [ $ j ] [ $ k ] ) ; $ upper [ $ i ] [ $ k ] = $ mat [ $ i ] [ $ k ] - $ sum ; } for ( $ k = $ i ; $ k < $ n ; $ k ++ ) { if ( $ i == $ k ) else { $ sum = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ sum += ( $ lower [ $ k ] [ $ j ] * $ upper [ $ j ] [ $ i ] ) ; $ lower [ $ k ] [ $ i ] = ( int ) ( ( $ mat [ $ k ] [ $ i ] - $ sum ) / $ upper [ $ i ] [ $ i ] ) ; } } } echo \" TABSYMBOL TABSYMBOL Lower ▁ Triangular \" ; echo \" TABSYMBOL TABSYMBOL TABSYMBOL Upper ▁ Triangular STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo \" TABSYMBOL \" . $ lower [ $ i ] [ $ j ] . \" TABSYMBOL \" ; echo \" TABSYMBOL \" ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo $ upper [ $ i ] [ $ j ] . \" TABSYMBOL \" ; echo \" STRNEWLINE \" ; } } $ mat = array ( array ( 2 , -1 , -2 ) , array ( -4 , 6 , 3 ) , array ( -4 , -2 , 8 ) ) ; luDecomposition ( $ mat , 3 ) ; ? >"}
{"text": "Bahagikan nombor ke dalam dua bahagian yang boleh dibahagikan dengan nombor yang diberikan | Kaedah mencetak bahagian yang boleh dibahagi jika boleh, jika tidak dicetak 'tidak mungkin'; mewujudkan tatasusunan untuk menyimpan peringatan; gelung di atas semua akhiran dan menyimpan peringatan dengan F; Mendapatkan peringatan akhiran dari peringatan akhiran sebelumnya; gelung ke atas semua awalan dan menyimpan peringatan dengan S; Mendapatkan peringatan awalan dari peringatan awalan seterusnya; mengemas kini nilai asas; Sekarang melengkapkan semua peringatan untuk memeriksa keadaan partition; Jika kedua -dua peringatan adalah 0 dan digit sendiri bukan 0, maka cetak hasil dan kembali; Jika kita sampai di sini, maka rentetan boleh 'dibahagikan di bawah kekangan; Kod pemacu", "code": "< ? php function printTwoDivisibleParts ( $ num , $ f , $ s ) { $ N = strlen ( $ num ) ; $ prefixReminder = array_fill ( 0 , $ N + 1 , 0 ) ; $ suffixReminder = array_fill ( 0 , $ N + 1 , 0 ) ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ suffixReminder [ $ i ] = ( $ suffixReminder [ $ i - 1 ] * 10 + ( ord ( $ num [ $ i - 1 ] ) - 48 ) ) % $ f ; $ base = 1 ; for ( $ i = $ N - 1 ; $ i >= 0 ; $ i -- ) { $ prefixReminder [ $ i ] = ( $ prefixReminder [ $ i + 1 ] + ( ord ( $ num [ $ i ] ) - 48 ) * $ base ) % $ s ; $ base = ( $ base * 10 ) % $ s ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ prefixReminder [ $ i ] == 0 && $ suffixReminder [ $ i ] == 0 && $ num [ $ i ] != '0' ) { echo substr ( $ num , 0 , $ i ) . \" ▁ \" . substr ( $ num , $ i ) . \" STRNEWLINE \" ; return ; } } echo \" Not ▁ Possible STRNEWLINE \" ; } $ num = \"246904096\" ; $ f = 12345 ; $ s = 1024 ; printTwoDivisibleParts ( $ num , $ f , $ s ) ; ? >"}
{"text": "Bilangan subarray yang minimum dan maksimum adalah sama | Hitung tidak ada subarray bersebelahan yang mempunyai minimum dan maksimum yang sama; menyimpan jawapannya; gelung untuk melintasi 0 - n; Mula memeriksa subarray dari elemen seterusnya; melintasi untuk mencari subarray; Jika unsur -unsur adalah sama maka kita periksa lebih lanjut dan menyimpan kiraan nombor yang sama dalam 'r'; Tidak ada unsur -unsur di antara R dan I dengan unsur yang sama. ; Tidak ada subarray yang boleh dibentuk antara I dan R; Sekali lagi mula memeriksa dari indeks seterusnya; mengembalikan jawapan; Kod pemacu", "code": "< ? php function calculate ( $ a , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ r = $ i + 1 ; for ( $ j = $ r ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ i ] == $ a [ $ j ] ) $ r += 1 ; else break ; } $ d = $ r - $ i ; $ ans += ( $ d * ( $ d + 1 ) / 2 ) ; $ i = $ r - 1 ; } return $ ans ; } $ a = array ( 2 , 4 , 5 , 3 , 3 , 3 ) ; $ n = count ( $ a ) ; echo calculate ( $ a , $ n ) ; ? >"}
{"text": "Kira nombor yang memuaskan m + jumlah (m) + jumlah (jumlah (m)) = n | fungsi yang mengembalikan jumlah digit dalam nombor; Pada mulanya jumlah digit ialah 0; Loop berjalan sehingga semua digit telah diekstrak; Digit terakhir dari belakang; merangkumi digit; Nombor itu dikurangkan kepada nombor yang mengeluarkan digit terakhir; Mengembalikan jumlah digit dalam nombor; fungsi untuk mengira kiraan kejadian tersebut; kaunter untuk mengira kejadian; gelung untuk melintasi n - 97 ke n; memanggil fungsi untuk mengira jumlah digit i; memanggil fungsi untuk mengira jumlah digit A; Jika penjumlahan sama dengan n maka tingkatkan kaunter dengan 1; Mengembalikan kiraan; Kod pemacu; memanggil fungsi untuk mendapatkan jawapan", "code": "< ? php function sum ( $ n ) { $ rem = 0 ; $ sum_of_digits = 0 ; while ( $ n > 0 ) { $ rem = $ n % 10 ; $ sum_of_digits += $ rem ; $ n = $ n / 10 ; } return $ sum_of_digits ; } function countt ( $ n ) { $ c = 0 ; for ( $ i = $ n - 97 ; $ i <= $ n ; $ i ++ ) { $ a = sum ( $ i ) ; $ b = sum ( $ a ) ; if ( ( $ i + $ a + $ b ) == $ n ) { $ c += 1 ; } } return $ c ; } $ n = 9939 ; echo countt ( $ n ) ; ? >"}
{"text": "Semak jika nombor adalah kuasa k menggunakan kaedah perubahan asas | Program PHP untuk memeriksa sama ada nombor boleh dibangkitkan kepada k; gelung untuk menukar asas n ke asas = k; Cari digit semasa dalam asas k; Jika digit tidak 0 atau 1; Pastikan hanya satu 1 yang hadir. ; Kod pemacu", "code": "< ? php function isPowerOfK ( $ n , $ k ) { $ oneSeen = false ; while ( $ n > 0 ) { $ digit = $ n % $ k ; if ( $ digit > 1 ) return false ; if ( $ digit == 1 ) { if ( $ oneSeen ) return false ; $ oneSeen = true ; } $ n = ( int ) $ n / $ k ; } return true ; } $ n = 64 ; $ k = 4 ; if ( isPowerOfK ( $ n , $ k ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak jika nombor adalah palindrome atau tidak dalam oktal | Program PHP untuk memeriksa sama ada perwakilan oktal nombor adalah perdana; Berfungsi untuk memeriksa tidak ada dalam oktal atau tidak; Fungsi untuk memeriksa tidak adalah palindrome atau tidak; Jika nombor sudah berada di Octal, kami melintasi digit menggunakan bahagian berulang dengan 10. Lain -lain kami melintasi digit menggunakan bahagian berulang dengan 8; Untuk menyimpan digit individu; Melintasi semua digit; Memeriksa jika Octal No adalah palindrome; Kod pemacu", "code": "< ? php $ MAX_DIGITS = 20 ; function isOctal ( $ n ) { while ( $ n ) { if ( ( $ n % 10 ) >= 8 ) return false ; else $ n = ( int ) $ n / 10 ; } return true ; } function isPalindrome ( $ n ) { global $ MAX_DIGITS ; $ divide = ( isOctal ( $ n ) == false ) ? 8 : 10 ; $ octal ; $ i = 0 ; while ( $ n != 0 ) { $ octal [ $ i ++ ] = $ n % $ divide ; $ n = ( int ) $ n / $ divide ; } for ( $ j = $ i - 1 , $ k = 0 ; $ k <= $ j ; $ j -- , $ k ++ ) if ( $ octal [ $ j ] != $ octal [ $ k ] ) return -1 ; return 0 ; } $ n = 97 ; if ( isPalindrome ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cari semua nombor faktorial kurang daripada atau sama dengan n | Program PHP untuk mencari semua nombor faktorial yang lebih kecil daripada atau sama dengan n. ; Kirakan faktorial seterusnya menggunakan sebelumnya; Kod pemacu", "code": "< ? php function printFactorialNums ( $ n ) { $ fact = 1 ; $ x = 2 ; while ( $ fact <= $ n ) { echo $ fact , \" \" ; $ fact = $ fact * $ x ; $ x ++ ; } } $ n = 100 ; echo printFactorialNums ( $ n ) ; ? >"}
{"text": "Semak sama ada nombor mempunyai tiga faktor yang berbeza atau tidak | Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi untuk memeriksa sama ada nombor yang diberikan mempunyai tiga faktor yang berbeza atau tidak; Cari akar kuadrat nombor; Semak sama ada nombor adalah persegi sempurna atau tidak; Jika nombor adalah persegi sempurna, periksa sama ada akar persegi adalah perdana atau tidak; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function isThreeDisctFactors ( $ n ) { $ sq = sqrt ( $ n ) ; if ( $ sq * $ sq != $ n ) return false ; return isPrime ( $ sq ) ? true : false ; } $ num = 9 ; if ( isThreeDisctFactors ( $ num ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; $ num = 15 ; if ( isThreeDisctFactors ( $ num ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; $ num = 12397923568441 ; if ( isThreeDisctFactors ( $ num ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Cari digit terakhir apabila faktorial faktorial yang membahagikan b | Fungsi yang mengira digit terakhir hasil B! / A! ; Jika A = B, B! = A! dan B! / A! = 1; Jika perbezaan (b - a)> = 5, jawab = 0; Sekiranya bukan syarat adalah benar, kita berulang dari A + 1 hingga B dan membiaknya. Kami hanya prihatin untuk digit terakhir, oleh itu kami mengambil modulus 10; Kod pemacu", "code": "< ? php function computeLastDigit ( $ A , $ B ) { $ variable = 1 ; if ( $ A == $ B ) return 1 ; else if ( ( $ B - $ A ) >= 5 ) return 0 ; else { for ( $ i = $ A + 1 ; $ i <= $ B ; $ i ++ ) $ variable = ( $ variable * ( $ i % 10 ) ) % 10 ; return $ variable % 10 ; } } echo computeLastDigit ( 2632 , 2634 ) ; ? >"}
{"text": "Program untuk jumlah siri aritmetik | Fungsi untuk mencari jumlah siri. ; Kod pemacu", "code": "< ? php function sumOfAP ( $ a , $ d , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ a ; $ a = $ a + $ d ; } return $ sum ; } $ n = 20 ; $ a = 2.5 ; $ d = 1.5 ; echo ( sumOfAP ( $ a , $ d , $ n ) ) ; ? >"}
{"text": "Produk Faktor Nombor | Program PHP untuk mengira produk faktor nombor; berfungsi untuk produk faktor; Jika faktor adalah sama, kalikan hanya sekali; Jika tidak, kedua -duanya; Kod pemacu", "code": "< ? php $ M = 1000000007 ; function multiplyFactors ( $ n ) { global $ M ; $ prod = 1 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ prod = ( $ prod * $ i ) % $ M ; else { $ prod = ( $ prod * $ i ) % $ M ; $ prod = ( $ prod * $ n / $ i ) % $ M ; } } } return $ prod ; } $ n = 12 ; echo multiplyFactors ( $ n ) ; ? >"}
{"text": "Produk Faktor Nombor | Program PHP untuk mengira produk faktor nombor; Fungsi iteratif untuk mengira (x ^ y) dalam o (log y); fungsi untuk mengira faktor; Jika faktor sama, hitung hanya sekali; Jika tidak, kiraan kedua -duanya; Mengira produk faktor; Jika numfactor adalah kuasa pulangan ganjil (n, numfactor / 2) * sqrt (n); Kod pemacu", "code": "< ? php $ M = 1000000007 ; function power ( $ x , $ y ) { global $ M ; $ res = 1 ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ M ; $ y = ( $ y >> 1 ) % $ M ; $ x = ( $ x * $ x ) % $ M ; } return $ res ; } function countFactors ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ count ++ ; else $ count += 2 ; } } return $ count ; } function multiplyFactors ( $ n ) { $ numFactor = countFactors ( $ n ) ; $ product = power ( $ n , $ numFactor / 2 ) ; if ( $ numFactor & 1 ) $ product = ( $ product * sqrt ( $ n ) ) % $ M ; return $ product ; } $ n = 12 ; echo multiplyFactors ( $ n ) ; ? >"}
{"text": "Perwakilan perpuluhan rentetan binari yang diberikan dapat dibahagikan dengan 10 atau tidak | fungsi untuk memeriksa sama ada perwakilan perpuluhan nombor binari yang diberikan dapat dibahagikan dengan 10 atau tidak; Jika digit terakhir adalah '1', maka nombor tidak dapat dibahagikan dengan 10; untuk mengumpulkan jumlah digit terakhir dalam kuasa sempurna 2; melintasi dari 2 nd yang terakhir sehingga 1 st digit dalam 'bin'; jika digit dalam '1'; Hitung kedudukan digit dari kanan; Menurut kedudukan digit, dapatkan digit terakhir kuasa sempurna yang berkenaan 2; jika digit terakhir adalah 0, maka dibahagikan dengan 10; tidak boleh dibahagikan dengan 10; Kod pemacu", "code": "< ? php function isDivisibleBy10 ( $ bin ) { $ n = strlen ( $ bin ) ; if ( $ bin [ $ n - 1 ] == '1' ) return false ; $ sum = 0 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ bin [ $ i ] == '1' ) { $ posFromRight = $ n - $ i - 1 ; if ( $ posFromRight % 4 == 1 ) $ sum = $ sum + 2 ; else if ( $ posFromRight % 4 == 2 ) $ sum = $ sum + 4 ; else if ( $ posFromRight % 4 == 3 ) $ sum = $ sum + 8 ; else if ( $ posFromRight % 4 == 0 ) $ sum = $ sum + 6 ; } } if ( $ sum % 10 == 0 ) return true ; return false ; } $ bin = \"11000111001110\" ; if ( isDivisibleBy10 ( $ bin ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Nombor Tribonacci | Program PHP yang dioptimumkan ruang untuk mencetak nombor N First N Tribinocci. | ; Memulakan tiga nombor pertama; Gelung untuk menambah tiga nombor sebelumnya untuk setiap nombor bermula dari 3 dan kemudian berikan pertama, kedua, ketiga hingga kedua, ketiga, dan curr masing -masing; Kod pemacu", "code": "< ? php function printTrib ( $ n ) { if ( $ n < 1 ) return ; $ first = 0 ; $ second = 0 ; $ third = 1 ; echo $ first , \" \" ; if ( $ n > 1 ) echo $ second , \" ▁ \" ; if ( $ n > 2 ) echo $ second , \" ▁ \" ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) { $ curr = $ first + $ second + $ third ; $ first = $ second ; $ second = $ third ; $ third = $ curr ; echo $ curr , \" \" ; } } $ n = 10 ; printTrib ( $ n ) ; ? >"}
{"text": "Nombor Perdana Bit Set dalam Perwakilan Binari | Tetapkan 2 | Berfungsi untuk membuat pelbagai nombor utama sehingga nombor 'n'; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Tambah semua nombor utama ke senarai; Fungsi utiliti untuk mengira bilangan bit yang ditetapkan; Program pemacu; Di sini nombor perdana diperiksa sehingga bilangan maksimum bit mungkin kerana jumlah bit maksimum mungkin adalah bilangan bit itu sendiri.", "code": "< ? php function SieveOfEratosthenes ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) for ( $ i = $ p * 2 ; $ i < $ n + 1 ; $ i += $ p ) $ prime [ $ i ] = false ; } $ lis = array ( ) ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) if ( $ prime [ $ p ] ) array_push ( $ lis , $ p ) ; return $ lis ; } function setBits ( $ n ) { $ cnt = 0 ; while ( $ n ) { if ( $ n & 1 ) $ cnt ++ ; $ n >>= 1 ; } ; return $ cnt ; } $ x = 4 ; $ y = 8 ; $ count = 0 ; $ primeArr = SieveOfEratosthenes ( ceil ( log ( $ y , 2 ) ) ) ; for ( $ i = $ x ; $ i < $ y + 1 ; $ i ++ ) { $ temp = setBits ( $ i ) ; if ( in_array ( $ temp , $ primeArr ) ) $ count += 1 ; } print ( $ count ) ; ? >"}
{"text": "Count Squares dengan Panjang Bahagian Ganjil di Papan Catur | Berfungsi untuk mengembalikan kiraan kuadrat panjang ganjil yang mungkin; Untuk menyimpan kiraan yang diperlukan; Untuk semua nilai ganjil i; Tambah kiraan kemungkinan panjang panjang i; Mengembalikan kiraan yang diperlukan; Kod pemacu", "code": "< ? php function count_square ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i = $ i + 2 ) { $ k = $ n - $ i + 1 ; $ count += ( $ k * $ k ) ; } return $ count ; } $ N = 8 ; echo count_square ( $ N ) ; ? >"}
{"text": "Count of elements yang perbezaan mutlak dengan jumlah semua elemen lain adalah lebih besar daripada k | Berfungsi untuk mengembalikan bilangan anomali; Untuk menyimpan kiraan anomali; Untuk menyimpan jumlah elemen array; Cari jumlah elemen array; Mengira anomali; Kod pemacu", "code": "< ? php function countAnomalies ( $ arr , $ n , $ k ) { $ cnt = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( abs ( $ arr [ $ i ] - ( $ sum - $ arr [ $ i ] ) ) > $ k ) $ cnt ++ ; return $ cnt ; } $ arr = array ( 1 , 3 , 5 ) ; $ n = count ( $ arr ) ; $ k = 1 ; echo countAnomalies ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Cari bilangan integer x dalam julat (1, n) yang mana x dan x + 1 mempunyai bilangan pembahagi yang sama | Pelaksanaan PHP pendekatan; Untuk menyimpan bilangan pembahagi dan awalan jumlah nombor tersebut; Fungsi untuk mencari bilangan integer 1 <x <n yang mana x dan x + 1 mempunyai bilangan pembahagi positif yang sama; Mengira bilangan pembahagi; Jalankan gelung sehingga sqrt (i); Jika J adalah pembahagi i; Jika ia sempurna persegi; X dan X + 1 mempunyai bilangan pembahagi positif yang sama; Panggilan fungsi; Jawapan yang diperlukan", "code": "< ? php $ N = 100005 ; $ d = array_fill ( 0 , $ N , NULL ) ; $ pre = array_fill ( 0 , $ N , NULL ) ; function Positive_Divisors ( ) { global $ N , $ d , $ pre ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j * $ j <= $ i ; $ j ++ ) { if ( $ i % $ j == 0 ) { if ( $ j * $ j == $ i ) $ d [ $ i ] ++ ; else $ d [ $ i ] += 2 ; } } } $ ans = 0 ; for ( $ i = 2 ; $ i < $ N ; $ i ++ ) { if ( $ d [ $ i ] == $ d [ $ i - 1 ] ) $ ans ++ ; $ pre [ $ i ] = $ ans ; } } Positive_Divisors ( ) ; $ n = 15 ; echo $ pre [ $ n ] ; return 0 ; ? >"}
{"text": "Panjang bilangan terkecil yang boleh dibahagikan dengan k dan dibentuk dengan menggunakan 1 's sahaja | Berfungsi untuk mengembalikan panjang nombor yang dihasilkan; Jika k adalah pelbagai 2 atau 5; Menjana semua nombor yang mungkin 1, 11, 111, 111, ..., k 1 's; Jika nombor dibahagikan dengan k maka kembalikan panjang; Kod pemacu", "code": "< ? php function numLen ( $ K ) { if ( $ K % 2 == 0 $ K % 5 == 0 ) return -1 ; $ number = 0 ; $ len = 1 ; for ( $ len = 1 ; $ len <= $ K ; $ len ++ ) { $ number = $ number * 10 + 1 ; if ( ( $ number % $ K == 0 ) ) return $ len ; } return -1 ; } $ K = 7 ; echo numLen ( $ K ) ; ? >"}
{"text": "Cari jika nombor yang diberikan hadir dalam urutan tak terhingga atau tidak | Fungsi yang mengembalikan benar jika urutan akan mengandungi b; Kod pemacu", "code": "< ? php function doesContainB ( $ a , $ b , $ c ) { if ( $ a == $ b ) return true ; if ( ( $ b - $ a ) * $ c > 0 && ( $ b - $ a ) % $ c == 0 ) return true ; return false ; } $ a = 1 ; $ b = 7 ; $ c = 3 ; if ( doesContainB ( $ a , $ b , $ c ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cari permutasi 2 N nombor supaya hasil ekspresi yang diberikan adalah tepat 2 k | Berfungsi untuk mencari permutasi yang diperlukan bagi nombor semulajadi 2 * n pertama; Berulang dalam blok 2; Kami memerlukan lebih banyak kenaikan, jadi cetak dalam urutan terbalik; Kami mempunyai kenaikan yang mencukupi, jadi cetak dalam urutan yang sama; Kod pemacu", "code": "< ? php function printPermutation ( $ n , $ k ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ x = 2 * $ i - 1 ; $ y = 2 * $ i ; if ( $ i <= $ k ) echo $ y . \" \" ▁ . ▁ $ x ▁ . ▁ \" \" else echo $ x . \" ▁ \" . $ y . \" ▁ \" ; } } $ n = 2 ; $ k = 1 ; printPermutation ( $ n , $ k ) ; ? >"}
{"text": "Memaksimumkan jumlah produk darjah antara mana -mana dua simpang pokok | Berfungsi untuk mengembalikan jumlah maksimum yang mungkin; Memulakan ijazah untuk nod u hingga 2; Jika anda adalah nod daun atau nod akar; Memulakan ijazah untuk nod V hingga 2; Jika V adalah nod daun atau nod akar; Mengemas kini jumlah; Kod pemacu", "code": "< ? php function maxSum ( $ N ) { $ ans = 0 ; for ( $ u = 1 ; $ u <= $ N ; $ u ++ ) { for ( $ v = 1 ; $ v <= $ N ; $ v ++ ) { if ( $ u == $ v ) continue ; $ degreeU = 2 ; if ( $ u == 1 $ u == $ N ) $ degreeU = 1 ; $ degreeV = 2 ; if ( $ v == 1 $ v == $ N ) $ degreeV = 1 ; $ ans += ( $ degreeU * $ degreeV ) ; } } return $ ans ; } $ N = 6 ; echo maxSum ( $ N ) ; ? >"}
{"text": "Cari bilangan bulat yang membahagikan bilangan maksimum elemen array | Berfungsi untuk mencetak bilangan bulat yang membahagikan bilangan maksimum elemen dari array; Memulakan dua senarai untuk menyimpan pangkat dan faktor; Bermula dari 2 hingga elemen maksimum dalam ARR; Memulakan pembolehubah untuk mengira bilangan elemen yang merupakan faktor; Pangkat maksimum dalam senarai pangkat; Cetak semua elemen dengan pangkat m; Kod pemacu", "code": "< ? php function maximumFactor ( $ arr ) { $ rank = array ( ) ; $ factors = array ( ) ; for ( $ i = 2 ; $ i <= max ( $ arr ) ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < sizeof ( $ arr ) ; $ j ++ ) if ( $ arr [ $ j ] % $ i == 0 ) $ count += 1 ; array_push ( $ rank , $ count ) ; array_push ( $ factors , $ i ) ; } $ m = max ( $ rank ) ; for ( $ i = 0 ; $ i < sizeof ( $ rank ) ; $ i ++ ) { if ( $ rank [ $ i ] == $ m ) echo $ factors [ $ i ] , \" ▁ \" ; } } $ arr = array ( 120 , 15 , 24 , 63 , 18 ) ; maximumFactor ( $ arr ) ? >"}
{"text": "Nombor semulajadi | Mengembalikan jumlah nombor semulajadi n pertama; Kod pemacu", "code": "< ? php function findSum ( $ n ) { $ sum = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) $ sum = $ sum + $ x ; return $ sum ; } $ n = 5 ; echo findSum ( $ n ) ; ? >"}
{"text": "Median | Fungsi untuk mengira median; Pertama kita menyusun array; Semak kes walaupun; Kod pemacu", "code": "< ? php function findMedian ( & $ a , $ n ) { sort ( $ a ) ; if ( $ n % 2 != 0 ) return ( double ) $ a [ $ n / 2 ] ; return ( double ) ( $ a [ ( $ n - 1 ) / 2 ] + $ a [ $ n / 2 ] ) / 2.0 ; } $ a = array ( 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 ) ; $ n = sizeof ( $ a ) ; echo \" Median ▁ = ▁ \" . findMedian ( $ a , $ n ) ; ? >"}
{"text": "Min | Fungsi untuk mengira min; Kod pemacu", "code": "< ? php function findMean ( & $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; return ( double ) $ sum / ( double ) $ n ; } $ a = array ( 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 ) ; $ n = sizeof ( $ a ) ; echo \" Mean ▁ = ▁ \" . findMean ( $ a , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika array mempunyai elemen yang sama dengan produk elemen yang tinggal | Fungsi untuk memeriksa sama ada array mempunyai elemen yang sama dengan produk semua elemen yang tinggal; Menyimpan kekerapan dalam peta; Kirakan produk semua elemen; Jika prod adalah persegi yang sempurna; Kemudian periksa sama ada akarnya ada dalam array atau tidak; Kod pemacu", "code": "< ? php function CheckArray ( $ arr , $ n ) { $ prod = 1 ; $ freq = array ( ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { array_push ( $ freq , $ arr [ $ i ] ) ; $ prod *= $ arr [ $ i ] ; } $ freq = array_unique ( $ freq ) ; $ root = ( int ) ( sqrt ( $ prod ) ) ; if ( $ root * $ root == $ prod ) if ( in_array ( $ root , $ freq ) ) return true ; return false ; } $ arr = array ( 1 , 2 , 12 , 3 , 2 ) ; $ n = count ( $ arr ) ; if ( CheckArray ( $ arr , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Semak sama ada nombor mempunyai 0 's berturut -turut di pangkalan yang diberikan atau tidak | Kami mula -mula menukar ke pangkalan yang diberikan, kemudian periksa sama ada nombor yang ditukar mempunyai dua 0 s atau tidak; Berfungsi untuk menukar n ke asas k; Berat setiap digit; Berfungsi untuk memeriksa berturut -turut 0; Bendera untuk memeriksa sama ada terdapat sifar berturut -turut atau tidak; Sekiranya terdapat dua sifar berturut -turut maka kembali palsu; Kod pemacu", "code": "< ? php function hasConsecutiveZeroes ( $ N , $ K ) { $ z = toK ( $ N , $ K ) ; if ( check ( $ z ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; } function toK ( $ N , $ K ) { $ w = 1 ; $ s = 0 ; while ( $ N != 0 ) { $ r = $ N % $ K ; $ N = ( int ) ( $ N / $ K ) ; $ s = $ r * $ w + $ s ; $ w *= 10 ; } return $ s ; } function check ( $ N ) { $ fl = false ; while ( $ N != 0 ) { $ r = $ N % 10 ; $ N = ( int ) ( $ N / 10 ) ; if ( $ fl == true and $ r == 0 ) return false ; if ( $ r > 0 ) { $ fl = false ; continue ; } $ fl = true ; } return true ; } $ N = 15 ; $ K = 8 ; hasConsecutiveZeroes ( $ N , $ K ) ; ? >"}
{"text": "Jumlah setiap nombor utama dalam array | Pelaksanaan PHP pendekatan; 0 dan 1 bukan nombor perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; mengira jawapannya; Count of prima; jumlah prima; melintasi array; Jika nombor itu adalah perdana; meningkatkan kiraan; jika ia adalah perdana k 'th; buat penapis", "code": "< ? php $ MAX = 100000 ; $ prime = array_fill ( 0 , $ MAX + 1 , true ) ; function SieveOfEratosthenes ( ) { global $ MAX , $ prime ; $ prime [ 1 ] = false ; $ prime [ 0 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ MAX ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ MAX ; $ i += $ p ) $ prime [ $ i ] = false ; } } } function SumOfKthPrimes ( $ arr , $ n , $ k ) { global $ MAX , $ prime ; $ c = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ prime [ $ arr [ $ i ] ] ) { $ c ++ ; if ( $ c % $ k == 0 ) { $ sum += $ arr [ $ i ] ; $ c = 0 ; } } } echo $ sum . \" STRNEWLINE \" ; } SieveOfEratosthenes ( ) ; $ arr = array ( 2 , 3 , 5 , 7 , 11 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; SumOfKthPrimes ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Cari kuasa super nombor tertentu | PHP untuk mencari kuasa super n; hash global untuk perdana; kaedah ayak untuk menyimpan senarai perdana; berfungsi untuk mengembalikan kuasa super; Cari kuasa super; Kod pemacu", "code": "< ? php $ MAX = 100000 ; $ prime = array_fill ( 0 , 100002 , true ) ; function SieveOfEratosthenes ( ) { global $ MAX , $ prime ; for ( $ p = 2 ; $ p * $ p <= $ MAX ; $ p ++ ) if ( $ prime [ $ p ] == true ) for ( $ i = $ p * 2 ; $ i <= $ MAX ; $ i += $ p ) $ prime [ $ i ] = false ; } function superpower ( $ n ) { SieveOfEratosthenes ( ) ; global $ MAX , $ prime ; $ superPower = 0 ; $ factor = 0 ; $ i = 2 ; while ( $ n > 1 && $ i <= $ MAX ) { if ( $ prime [ $ i ] ) { $ factor = 0 ; while ( $ n % $ i == 0 && $ n > 1 ) { $ factor ++ ; $ n = $ n / $ i ; } if ( $ superPower < $ factor ) $ superPower = $ factor ; } $ i ++ ; } return $ superPower ; } $ n = 256 ; echo superpower ( $ n ) ; ? >"}
{"text": "Pembahagi utama terkecil nombor | Berfungsi untuk mencari pembahagi terkecil; jika dibahagikan dengan 2; berulang dari 3 hingga sqrt (n); Kod pemacu", "code": "< ? php function smallestDivisor ( $ n ) { if ( $ n % 2 == 0 ) return 2 ; for ( $ i = 3 ; $ i * $ i <= $ n ; $ i += 2 ) { if ( $ n % $ i == 0 ) return $ i ; } return $ n ; } $ n = 31 ; echo smallestDivisor ( $ n ) ; ? >"}
{"text": "Kira bilangan haiwan di zoo dari bilangan kepala dan kaki yang diberikan | Fungsi yang mengira arnab; Kod pemacu", "code": "< ? php function countRabbits ( $ Heads , $ Legs ) { $ count = 0 ; $ count = ( $ Legs ) - 2 * ( $ Heads ) ; $ count = ( int ) $ count / 2 ; return $ count ; } $ Heads = 100 ; $ Legs = 300 ; $ Rabbits = countRabbits ( $ Heads , $ Legs ) ; echo \" Rabbits = \" ▁ , ▁ $ Rabbits ▁ , ▁ \" \" ; STRNEWLINE echo ▁ \" Pigeons = \" $ Rabbits , \" STRNEWLINE \" ; ? >"}
{"text": "Program to evaluate the expression ( ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢ ÃƒÆ ’ Ã ¢ â ‚¬ Ãƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢ ÃƒÆ ’ Ã † â €™ Ãƒ ¢ Ã ¢ â € š ¬ Ãƒæ '¢ Ãƒ ¢ Ã ¢ Â, Å ¡¡¬ Ãƒ ¢ Ã ¢ â € œ ¢ ¢ ¢ Ãƒæ' Â € ™ â € œ œ Â € ¢ â € œ Â € ¢ â € ¢ Â € ¢ â € Ãƒæ 'Ã † â € ™ ¢ Ãƒæ' ¢ Ãƒ ¢ Ã ¢ â € Š ¬ Ã ... ¡¬ Ãƒæ '¢ Ãƒ ¢ â € Ãƒæ 'Ã ¢ â, ¬ Ãƒ ¢ Ã ¢ â € š š â € ž ¢ Ãƒæ' Ã † â € ™ ¢ â € , ¬ Å ¾ ¢ Ãƒæ 'Ã † â € ™ ÃƒÂ € ¢ â € œ â € œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ ¬ † ° ¬ ¬ † ° ¬ ¬ † ° ¬ † ° ¬ † † ° ¬ † † ° ¬ † † ° ¬ † ° ¬ † ° ¬ † € ™ ÃƒÂ € ¢ â, ¬ â \"¢ Ãƒæ 'Ã ¢ Â' â € ¢ ¢ â € š â € ¢ ¢ Â Â € œ œ œ œ œ œ œ œ œ œ œ œ œ ¢ Â € œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ ¢ Â € œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ œ ' â € ™ ¢ Ãƒæ '¢ Ãƒ ¢ Ã ¢ â € Š ¬ Ã ... ¡¡Ã ~ ¢ â € œ œ œ œ ¢ â €' â € Š ¬ Ã ¢ â € ž ¢ Ãƒæ 'Ã † â € ™ ™ ¢ Ã ¢ â € Š ¬ Ãƒæ' ¢ Ã ¢ â € ™ Â Â € œ œ œ œ œ ¬ † € œ œ œ œ ¬ † † € ™ † Â € ÃƒÂ € ¢ â, ¬ â \"¢ ¢ Ãƒæ 'Ã † â € ™ ¢ Ã ¢ ¢ Ãƒ ¢ Ã ¢ â, ¬ ¡¡Â € ¬ â \"¢ Ãƒæ 'Ã ¢ â, ¬ Ãƒ ¢ Ã ¢ â € Š ¬ Ã ¢ â € ž ¢ Ãƒæ' † ¢ Ã ¢ â, ¬ Å ¾ ¢ Ãƒæ 'Ã † â € ™ ™ € € ¢ â, â \" € Š ¬ Ã ... ¡¡¬ Ãƒæ '¢ Ãƒ ¢ ¢ â € Š ¬ Ã ... ¾ ¢ Ãƒæ' Ã † ™ â € â € Ž ¢ Ãƒæ 'Ã † â € ™ ™ ¢ Ã ¢ â € š š ¬ Ãƒæ' ¢ Ãƒ ¢ Ã ¢ â, å ¡ ¬ â \"¢ ¢ Ãƒæ 'Ã † â € ™ ¢ Ãƒæ' ¢ Ãƒ ¢ Ã ¢ â, ¬ Å ¡¡¬ Ãƒâ € | , ¬ Ãƒ ¢ â € š š ¬ ¢ â € Ž ¢ ¢ Ãƒæ 'Ã † € ™ â € œ ... ¡¬ Ãƒæ 'Ã ¢ â, ¬ | ¡¬ Ãƒæ' Ã † â € ™ ™ € ¢ â, â € œ Â € œ Â € œ Â € ¢ Â € œ Â € ¢ Â € ¢ Â € ¢ â € ¢ â € ¢ â € ¢ â € ¢ â € ¢ â € € ™ Ãƒ ¢ Ã ¢ â € Š ¬ Ãƒæ '¢ Ãƒ ¢ Ã ¢ â € œ å ¡¡Ã ¢ Ã ¢ â ¢ â ¢ â ¢ ¬ Å ¢ ¢ ¢' â € ™ ¢ Ãƒæ '¢ Ãƒ ¢ Ã ¢ Â, ¬ Å ¡¬ ÃƒÂ € |", "code": "< ? php function calculateSum ( $ n ) { $ a = ( int ) $ n ; return ( 2 * ( pow ( $ n , 6 ) + 15 * pow ( $ n , 4 ) + 15 * pow ( $ n , 2 ) + 1 ) ) ; } $ n = 1.4142 ; echo ceil ( calculateSum ( $ n ) ) ; ? >"}
{"text": "Cari jumlah siri 3, | Kirakan jumlah siri siri siri; Kod pemacu", "code": "< ? php function Sum_upto_nth_Term ( $ n ) { return ( 1 - pow ( -2 , $ n ) ) ; } $ N = 5 ; echo ( Sum_upto_nth_Term ( $ N ) ) ; ? >"}
{"text": "Kira nombor yang XOR dengan n adalah sama dengan atau dengan n | Berfungsi untuk mengira kiraan nombor dengan XOR sama dengan atau; pembolehubah untuk menyimpan kiraan bit yang tidak terset; Kod pemacu", "code": "< ? php function xorEqualsOrCount ( $ N ) { $ count = 0 ; while ( $ N > 0 ) { $ bit = $ N % 2 ; if ( $ bit == 0 ) $ count ++ ; $ N = intval ( $ N / 2 ) ; } return pow ( 2 , $ count ) ; } $ N = 7 ; echo xorEqualsOrCount ( $ N ) ; ? >"}
{"text": "Program untuk mencari jumlah 1 + x / 2! + x ^ 2/3! + ... + x ^ n / (n + 1)! | Berfungsi untuk mencari faktorial nombor; Berfungsi untuk mengira jumlah; Melelehkan gelung sehingga n dan hitung formula; Dapatkan X dan N; Output cetak", "code": "< ? php function fact ( $ n ) { if ( $ n == 1 ) return 1 ; return $ n * fact ( $ n - 1 ) ; } function sum ( $ x , $ n ) { $ total = 1.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ total = $ total + ( pow ( $ x , $ i ) / fact ( $ i + 1 ) ) ; } return $ total ; } $ x = 5 ; $ n = 4 ; echo \" Sum ▁ is : ▁ \" , sum ( $ x , $ n ) ; ? >"}
{"text": "Cari Jumlah Siri 1 ^ 2 | Program PHP untuk mencari jumlah siri 1 ^ 2 - 2 ^ 2 + 3 ^ 3 - 4 ^ 4 + ... berfungsi untuk mencari jumlah siri; Sekiranya saya juga; Sekiranya saya ganjil; mengembalikan hasilnya; Dapatkan n; Cari jumlahnya; Dapatkan n; Cari jumlahnya; Kod ini disumbangkan oleh ANUJ_67", "code": "< ? php function sum_of_series ( $ n ) { $ result = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ result = $ result - pow ( $ i , 2 ) ; else $ result = $ result + pow ( $ i , 2 ) ; } return $ result ; } $ n = 3 ; echo sum_of_series ( $ n ) , \" STRNEWLINE \" ; $ n = 10 ; echo sum_of_series ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari jumlah siri 23 + 45 + 75 + .... . Terma -terma N syarat | mengira istilah siri nth; Dapatkan nilai n; Dapatkan jumlah siri", "code": "< ? php function findSum ( $ N ) { return ( 2 * $ N * ( $ N + 1 ) * ( 4 * $ N + 17 ) + 54 * $ N ) / 6 ; } $ N = 4 ; echo findSum ( $ N ) ; ? >"}
{"text": "Program untuk mencari nilai dosa (nÃƒæ 'Ã † â € ™ ÃƒÂ € Ã ¢ â € œ â € œ Â € œ œ œ œ œ œ œ œ œ œ œ œ œ Â Â Â ° ¢ â € ¢ â € Š ¬ Ã ...", "code": "< ? php $ MAX = 16 ; $ nCr = array_fill ( 0 , $ MAX , array_fill ( 0 , $ MAX , 0 ) ) ; function binomial ( ) { global $ MAX , $ nCr ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ nCr [ $ i ] [ $ j ] = 1 ; else $ nCr [ $ i ] [ $ j ] = $ nCr [ $ i - 1 ] [ $ j ] + $ nCr [ $ i - 1 ] [ $ j - 1 ] ; } } } function findCosNTheta ( $ sinTheta , $ n ) { global $ MAX , $ nCr ; $ cosTheta = sqrt ( 1 - $ sinTheta * $ sinTheta ) ; $ ans = 0 ; $ toggle = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i += 2 ) { $ ans = $ ans + $ nCr [ $ n ] [ $ i ] * pow ( $ cosTheta , $ n - $ i ) * pow ( $ sinTheta , $ i ) * $ toggle ; $ toggle = $ toggle * -1 ; } return $ ans ; } binomial ( ) ; $ sinTheta = 0.5 ; $ n = 10 ; echo findCosNTheta ( $ sinTheta , $ n ) ; ? >"}
{"text": "Program untuk mencari istilah n Siri 9, 23, 45, 75, 113. . | mengira istilah siri nth; Dapatkan nilai n; Cari istilah n dan cetaknya", "code": "< ? php function nthTerm ( $ N ) { return ( 2 * $ N + 3 ) * ( 2 * $ N + 3 ) - 2 * $ N ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Cari Jumlah Siri 1 + 22 + 333 + 4444 + ... ... Upto n Terma | Fungsi untuk mengira jumlah; Kembali jumlah; Kod pemacu", "code": "< ? php function findSum ( $ n ) { return ( pow ( 10 , $ n + 1 ) * ( 9 * $ n - 1 ) + 10 ) / pow ( 9 , 3 ) - $ n * ( $ n + 1 ) / 18 ; } $ n = 3 ; echo findSum ( $ n ) ; ? >"}
{"text": "Cari Jumlah Siri 1 | Fungsi untuk mengira jumlah; Apabila n adalah ganjil; Apabila n tidak ganjil; Kod pemacu", "code": "< ? php function solve_sum ( $ n ) { if ( $ n % 2 == 1 ) return ( $ n + 1 ) / 2 ; return - $ n / 2 ; } $ n = 8 ; echo solve_sum ( $ n ) ; ? >"}
{"text": "Semak jika nombor boleh dinyatakan sebagai A ^ B | Tetapkan 2 | Program PHP untuk memeriksa sama ada nombor boleh dinyatakan sebagai ^ B. ; Kod pemacu", "code": "< ? php function isPower ( $ a ) { if ( $ a == 1 ) return true ; for ( $ i = 2 ; $ i * $ i <= $ a ; $ i ++ ) { $ val = log ( $ a ) / log ( $ i ) ; if ( ( $ val - $ val ) < 0.00000001 ) return true ; } return false ; } $ n = 16 ; echo ( isPower ( $ n ) ? \" Yes \" : \" No \" ) ;"}
{"text": "Program untuk mengira purata akar Square | Fungsi yang mengira purata persegi akar; Kirakan persegi. ; Hitung min. ; Kirakan akar. ; Kod pemacu", "code": "< ? php function rmsValue ( $ arr , $ n ) { $ square = 0 ; $ mean = 0.0 ; $ root = 0.0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ square += pow ( $ arr [ $ i ] , 2 ) ; } $ mean = ( $ square / ( float ) ( $ n ) ) ; $ root = sqrt ( $ mean ) ; return $ root ; } $ arr = array ( 10 , 4 , 6 , 8 ) ; $ n = sizeof ( $ arr ) ; echo rmsValue ( $ arr , $ n ) ; ? >"}
{"text": "Program untuk mencari kuantiti selepas penggantian campuran | Fungsi untuk mengira jumlah yang tinggal. ; Kirakan sebelah kanan (RHS). ; Kirakan jumlah yang ditinggalkan dengan kalikan dengan nilai asal. ; Kod pemacu", "code": "< ? php function Mixture ( $ X , $ Y , $ Z ) { $ result = 0.0 ; $ result1 = 0.0 ; $ result1 = ( ( $ X - $ Y ) / $ X ) ; $ result = pow ( $ result1 , $ Z ) ; $ result = $ result * $ X ; return $ result ; } $ X = 10 ; $ Y = 2 ; $ Z = 2 ; echo Mixture ( $ X , $ Y , $ Z ) , \" ▁ litres \" ; ? >"}
{"text": "Jumlah jumlah semua subset set yang dibentuk oleh nombor semulajadi n Pertama | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); $ x = $ x % $ p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasilnya; y mestilah sekarang $ y = $ y >> 1; y = y / 2; berfungsi untuk mencari ff (n); Dalam Formula N bermula dari sifar; Kirakan jawapan menggunakan formula 2 ^ n * (n ^ 2 + n + 2) - 1; Setiap kali jawapan adalah lebih besar daripada atau sama dengan mod maka modulo itu. ; Menambah modulo sementara penolakan sangat diperlukan jika tidak, ia akan menyebabkan jawapan yang salah; Kod pemacu; panggilan fungsi", "code": "< ? php function power ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function check ( $ n ) { $ mod = 1e9 + 7 ; $ n -- ; $ ans = $ n * $ n ; if ( $ ans >= $ mod ) $ ans %= $ mod ; $ ans += $ n + 2 ; if ( $ ans >= $ mod ) $ ans %= $ mod ; $ ans = ( power ( 2 , $ n , $ mod ) % $ mod * $ ans % $ mod ) % $ mod ; $ ans = ( $ ans - 1 + $ mod ) % $ mod ; return $ ans ; } $ n = 4 ; echo check ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari LCM sebanyak 2 nombor tanpa menggunakan GCD | Berfungsi untuk mengembalikan LCM dua nombor; Kod pemacu", "code": "< ? php function findLCM ( $ a , $ b ) { $ lar = max ( $ a , $ b ) ; $ small = min ( $ a , $ b ) ; for ( $ i = $ lar ; ; $ i += $ lar ) { if ( $ i % $ small == 0 ) return $ i ; } } $ a = 5 ; $ b = 7 ; echo \" LCM ▁ of ▁ \" , $ a , \" ▁ and ▁ \" , $ b , \" ▁ is ▁ \" , findLCM ( $ a , $ b ) ; ? >"}
{"text": "Smarandache | Berfungsi untuk mengumpul nombor perdana 'n' pertama; Senaraikan untuk menyimpan primes 'n' pertama; Berfungsi untuk menjana smarandache - urutan WELLIN; Menyimpan nombor utama 'n' dalam senarai; Kod pemacu", "code": "< ? php function primes ( $ n ) { $ i = 2 ; $ j = 0 ; $ result ; $ z = 0 ; while ( $ j < $ n ) { $ flag = true ; for ( $ item = 2 ; $ item <= ( int ) ( $ i * 1 / 2 ) ; $ item ++ ) if ( $ i % $ item == 0 && $ i != $ item ) { $ flag = false ; break ; } if ( $ flag ) { $ result [ $ z ++ ] = $ i ; $ j += 1 ; } $ i += 1 ; } return $ result ; } function smar_wln ( $ n ) { $ arr = primes ( $ n ) ; for ( $ i = 0 ; $ i < count ( $ arr ) ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) echo $ arr [ $ j ] ; echo \" ▁ \" ; } } $ n = 5 ; echo \" First ▁ $ n ▁ terms ▁ of ▁ the \" . \" ▁ Sequence ▁ are STRNEWLINE \" ; smar_wln ( $ n ) ; ? >"}
{"text": "Nombor pentatope | fungsi untuk nombor pentatope; formula untuk mencari pentatope nth istilah; Kod pemacu", "code": "< ? php function Pentatope_number ( $ n ) { return $ n * ( $ n + 1 ) * ( $ n + 2 ) * ( $ n + 3 ) / 24 ; } $ n = 7 ; echo $ n , \" th ▁ Pentatope ▁ number ▁ : \" , Pentatope_number ( $ n ) , \" STRNEWLINE \" ; $ n = 12 ; echo $ n , \" th ▁ Pentatope ▁ number ▁ : \" , Pentatope_number ( $ n ) ; ? >"}
{"text": "Program untuk nombor icosahedral berpusat | Fungsi untuk mencari nombor icosahedral berpusat; Formula untuk mengira nombor icosahedral yang berpusat dan mengembalikannya ke dalam fungsi utama. ; Kod pemacu", "code": "< ? php function centeredIcosahedralNum ( $ n ) { return ( 2 * $ n + 1 ) * ( 5 * $ n * $ n + 5 * $ n + 3 ) / 3 ; } $ n = 10 ; echo centeredIcosahedralNum ( $ n ) , \" STRNEWLINE \" ; $ n = 12 ; echo centeredIcosahedralNum ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Nombor persegi berpusat | Fungsi untuk mengira fungsi nombor persegi berpusat; Formula untuk mengira nombor persegi berpusat nth; Kod pemacu", "code": "< ? php function centered_square_num ( $ n ) { return $ n * $ n + ( ( $ n - 1 ) * ( $ n - 1 ) ) ; } $ n = 7 ; echo $ n , \" th ▁ Centered ▁ square ▁ number : ▁ \" ; echo centered_square_num ( $ n ) ; ? >"}
{"text": "Jumlah nombor semulajadi n Pertama | Berfungsi untuk mencari jumlah siri; Kod pemacu", "code": "< ? php function seriesSum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) / 6 ; } $ n = 4 ; echo ( seriesSum ( $ n ) ) ; ? >"}
{"text": "Nombor Dodecagonal | fungsi untuk nombor dodecagonal; formula untuk mencari istilah nth dodecagonal; Kod pemacu", "code": "< ? php function Dodecagonal_number ( $ n ) { return 5 * $ n * $ n - 4 * $ n ; } $ n = 7 ; echo Dodecagonal_number ( $ n ) , \" STRNEWLINE \" ; $ n = 12 ; echo Dodecagonal_number ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Nombor Aritmetik | Ayak eratosthenes; 1 bukan nombor perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Menyimpan prima dalam pelbagai; Kemas kini nilai dalam primesquare [p * p], jika p adalah perdana. ; Berfungsi untuk mengira pembahagi; Jika nombor adalah 1, maka ia hanya akan mempunyai 1 sebagai faktor. Jadi, jumlah faktor akan menjadi 1 .; untuk menyimpan prima sehingga n; Memanggil Sieveoferatosthenes untuk menyimpan faktor utama N dan menyimpan persegi faktor utama N; Ans akan mengandungi jumlah pembahagi yang berbeza; Gelung untuk mengira faktor n; A [i] tidak kurang daripada akar kiub n; Mengira kuasa [i] dalam n. CNT adalah kuasa perdana [i] dalam n. ; jika [i] adalah faktor n; Kekuatan kenaikan; Mengira bilangan pembahagi. Jika n = a ^ p * b ^ q maka jumlah pembahagi n adalah (p + 1) * (q + 1); Kes pertama; Kes kedua; Casse Ketiga; kembali $ ans; Jumlah pembahagi; Mengembalikan jumlah semua faktor n. ; Melintasi semua faktor utama. ; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor perdana yang lebih besar daripada 2 .; Semak jika nombor adalah nombor aritmetik atau tidak. ; Kod pemacu", "code": "< ? php function SieveOfEratosthenes ( $ n , & $ prime , & $ primesquare , & $ a ) { for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ prime [ $ i ] = true ; for ( $ i = 0 ; $ i <= ( $ n * $ n + 1 ) ; $ i ++ ) $ primesquare [ $ i ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ j = 0 ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] ) { $ a [ $ j ] = $ p ; $ primesquare [ $ p * $ p ] = true ; $ j ++ ; } } } function countDivisors ( $ n ) { if ( $ n == 1 ) return 1 ; $ prime = array_fill ( 0 , ( $ n + 1 ) , false ) ; $ primesquare = array_fill ( 0 , ( $ n * $ n + 1 ) , false ) ; $ a = array_fill ( 0 , $ n , 0 ) ; SieveOfEratosthenes ( $ n , $ prime , $ primesquare , $ a ) ; $ ans = 1 ; for ( $ i = 0 ; ; $ i ++ ) { if ( $ a [ $ i ] * $ a [ $ i ] * $ a [ $ i ] > $ n ) break ; $ cnt = 1 ; while ( $ n % $ a [ $ i ] == 0 ) { $ n = ( int ) ( $ n / $ a [ $ i ] ) ; $ cnt = $ cnt + 1 ; } $ ans = $ ans * $ cnt ; } if ( $ prime [ $ n ] ) $ ans = $ ans * 2 ; else if ( $ primesquare [ $ n ] ) $ ans = $ ans * 3 ; else if ( $ n != 1 ) $ ans = $ ans * 4 ; } function sumofFactors ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = ( int ) ( $ n / $ i ) ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; } function checkArithmetic ( $ n ) { $ count = countDivisors ( $ n ) ; $ sum = sumofFactors ( $ n ) ; return ( $ sum % $ count == 0 ) ; } $ n = 6 ; echo ( checkArithmetic ( $ n ) ) ? \" Yes \" : \" No \" ; ? >"}
{"text": "Mencari n | Program php berasaskan formula untuk mencari jumlah siri dengan kiub nombor semulajadi n pertama; Kod pemacu", "code": "< ? php function magicOfSequence ( $ N ) { return ( $ N * ( $ N + 1 ) / 2 ) + 2 * $ N ; } $ N = 6 ; echo magicOfSequence ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text": "Bentuk nombor menggunakan digit sudut kuasa | Cari kuasa seterusnya dengan mengalikan n dengan kuasa semasa; Simpan digit kuasa satu demi satu. ; Hitung membawa. ; Store Carry In Power Array. ; Cetak nombor yang dibentuk oleh digit sudut kuasa n. ; Menyimpan n dibangkitkan ke kuasa 0; Memulakan hasil kosong; Satu demi satu mengira kuasa seterusnya dan menambah digit sudut mereka. ; Fungsi panggilan yang menyimpan kuasa dalam array kuasa. ; Unit Simpan dan Digit Kuasa Terakhir di Res. ; Kod pemacu", "code": "< ? php function nextPower ( $ N , & $ power ) { $ carry = 0 ; for ( $ i = 0 ; $ i < count ( $ power ) ; $ i ++ ) { $ prod = ( $ power [ $ i ] * $ N ) + $ carry ; $ power [ $ i ] = $ prod % 10 ; $ carry = ( int ) ( $ prod / 10 ) ; } while ( $ carry ) { array_push ( $ power , $ carry % 10 ) ; $ carry = ( int ) ( $ carry / 10 ) ; } } function printPowerNumber ( $ X , $ N ) { $ power = array ( ) ; array_push ( $ power , 1 ) ; $ res = array ( ) ; for ( $ i = 1 ; $ i <= $ X ; $ i ++ ) { nextPower ( $ N , $ power ) ; array_push ( $ res , $ power [ count ( $ power ) - 1 ] ) ; array_push ( $ res , $ power [ 0 ] ) ; } for ( $ i = 0 ; $ i < count ( $ res ) ; $ i ++ ) echo ( $ res [ $ i ] ) ; } $ N = 19 ; $ X = 4 ; printPowerNumber ( $ X , $ N ) ; ? >"}
{"text": "Digit pertama dalam faktorial nombor | Program PHP untuk mencari digit pertama nombor faktorial yang besar; Mengeluarkan trailing 0 s kerana ini tidak mengubah digit pertama. ; Gelung untuk membahagikan fakta sehingga menjadi digit tunggal dan mengembalikan fakta; Kod pemacu", "code": "< ? php function firstDigit ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fact = $ fact * $ i ; while ( $ fact % 10 == 0 ) $ fact = $ fact / 10 ; } while ( $ fact >= 10 ) $ fact = $ fact / 10 ; return floor ( $ fact ) ; } $ n = 5 ; echo firstDigit ( $ n ) ; ? >"}
{"text": "Jumlah Siri 1.2. 3 + 2.3. 4 + ... + n (n + 1) (n + 2) | Program PHP untuk mencari jumlah siri 1.2. 3 + 2.3. 4 + 3.4. 5 + ...; Kod pemacu", "code": "< ? php function sumofseries ( $ n ) { $ res = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ res += ( $ i ) * ( $ i + 1 ) * ( $ i + 2 ) ; return $ res ; } echo sumofseries ( 3 ) ; ? >"}
{"text": "Cari n bermakna geometri antara a dan b | PR $ S N Geometric bermakna antara a dan b. ; Hitung nisbah biasa (r); untuk mencari n mine geometri antara a dan b; Kod pemacu", "code": "< ? php function printGMeans ( $ A , $ B , $ N ) { $ R = pow ( ( $ B / $ A ) , 1.0 / ( $ N + 1 ) ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ A * pow ( $ R , $ i ) , \" ▁ \" ; } $ A = 3 ; $ B = 81 ; $ N = 2 ; printGMeans ( $ A , $ B , $ N ) ; ? >"}
{"text": "Nombor yang mempunyai perbezaan dengan jumlah digit lebih daripada s | fungsi untuk jumlah digit; fungsi untuk mengira kiraan integer s. t. Integer - Digsum> s; jika tidak ada integer yang mungkin; ITERATE FOR S RANGE dan kemudian mengira jumlah kiraan integer tersebut jika memulakan integer ditemui; jika tiada integer dijumpai pulangan 0; Kod pemacu", "code": "< ? php function digitSum ( $ n ) { $ digSum = 0 ; while ( $ n ) { $ digSum += $ n % 10 ; $ n /= 10 ; } return $ digSum ; } function countInteger ( $ n , $ s ) { if ( $ n < $ s ) return 0 ; for ( $ i = $ s ; $ i <= min ( $ n , $ s + 163 ) ; $ i ++ ) if ( ( $ i - digitSum ( $ i ) ) > $ s ) return ( $ n - $ i + 1 ) ; return 0 ; } $ n = 1000 ; $ s = 100 ; echo countInteger ( $ n , $ s ) ; ? >"}
{"text": "Bahagian Tanpa Menggunakan ' /' Operator | Berfungsi untuk mencari pembahagian tanpa menggunakan ' /' pengendali; Mengendalikan nombor negatif; Jika num1 lebih besar daripada sama dengan num2 tolak num2 dari num1 dan tambah quotient oleh satu. ; Memeriksa jika neg sama dengan 1 kemudian membuat negatif quotient; Program Pemandu", "code": "< ? php function division ( $ num1 , $ num2 ) { if ( $ num1 == 0 ) return 0 ; if ( $ num2 == 0 ) return INT_MAX ; $ negResult = false ; if ( $ num1 < 0 ) { $ num1 = - $ num1 ; if ( $ num2 < 0 ) $ num2 = - $ num2 ; else $ negResult = true ; } else if ( $ num2 < 0 ) { $ num2 = - $ num2 ; $ negResult = true ; } $ quotient = 0 ; while ( $ num1 >= $ num2 ) { $ num1 = $ num1 - $ num2 ; $ quotient ++ ; } if ( $ negResult ) $ quotient = - $ quotient ; return $ quotient ; } $ num1 = 13 ; $ num2 = 2 ; echo division ( $ num1 , $ num2 ) ; ? >"}
{"text": "Nombor Nonagonal | Berfungsi untuk mencari siri nombor nonagon. ; Kod pemacu", "code": "< ? php function Nonagonal ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo $ i * ( 7 * $ i - 5 ) / 2 ; echo \" ▁ \" ; } } $ n = 10 ; Nonagonal ( $ n ) ; ? >"}
{"text": "Cari n | Func untuk Calualtion; untuk penjumlahan persegi not natural nothwat. ; penjumlahan natur natural pertama. ; hasil pulangan; Kod pemacu", "code": "< ? php function seriesFunc ( $ n ) { $ sumSquare = ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; $ sumNatural = ( $ n * ( $ n + 1 ) / 2 ) ; return ( $ sumSquare + $ sumNatural + 1 ) ; } $ n = 8 ; echo ( seriesFunc ( $ n ) . \" \" ) ; $ n = 13 ; echo ( seriesFunc ( $ n ) . \" \" ) ; ? >"}
{"text": "Program untuk menyemak Nombor Sempurna | berfungsi untuk memeriksa nombor yang sempurna; mengira bilangan digit; mengira ditambah nombor sempurna; memeriksa sama ada nombor ditambah sempurna atau tidak; Kod pemacu", "code": "< ? php function checkplusperfect ( $ x ) { $ temp = $ x ; $ n = 0 ; while ( $ x != 0 ) { $ x /= 10 ; $ n ++ ; } $ x = $ temp ; $ sum = 0 ; while ( $ x != 0 ) { $ sum += pow ( $ x % 10 , $ n ) ; $ x /= 10 ; } return ( $ sum == $ temp ) ; } $ x = 9474 ; if ( checkplusperfect ( ! $ x ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Bilangan subset yang berbeza dari satu set | Pulangan 2 ^ n; Kod pemacu", "code": "< ? php function subsetCount ( $ arr , $ n ) { return 1 << $ n ; } $ A = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ A ) ; echo ( subsetCount ( $ A , $ n ) ) ; ? >"}
{"text": "Program untuk mengira GST dari harga asal dan bersih | Program PHP untuk mengira GST dari harga asal dan bersih. ; nilai pulangan selepas mengira GST %; Kod pemacu", "code": "< ? php function Calculate_GST ( $ org_cost , $ N_price ) { return ( ( ( $ N_price - $ org_cost ) * 100 ) / $ org_cost ) ; } $ org_cost = 100 ; $ N_price = 120 ; echo ( \" GST ▁ = ▁ \" ) ; echo ( Calculate_GST ( $ org_cost , $ N_price ) ) ; echo ( \" ▁ % ▁ \" ) ; ? >"}
{"text": "Nombor heksagon yang berpusat | Fungsi untuk mencari nombor heksadesimal yang berpusat. ; Formula untuk mengira nombor heksadesimal yang berpusat dan mengembalikannya ke dalam fungsi utama. ; Kod pemacu", "code": "< ? php function centeredHexagonalNumber ( $ n ) { return 3 * $ n * ( $ n - 1 ) + 1 ; } $ n = 10 ; echo $ n , \" th ▁ centered ▁ hexagonal ▁ number : ▁ \" ; echo centeredHexagonalNumber ( $ n ) ; ? >"}
{"text": "Cari jarak yang dilindungi untuk mengumpul item pada jarak yang sama | berfungsi untuk mengira jarak; Program Pemandu", "code": "< ? php function find_distance ( $ n ) { return $ n * ( ( 3 * $ n ) + 7 ) ; } $ n = 5 ; echo \" Distance = \" ? >"}
{"text": "Nombor Perdana Twin | Sila rujuk di bawah siaran untuk butiran fungsi ini https: goo. GL / WV3FGV; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Pulangan benar jika N1 dan N2 adalah prima berkembar; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function twinPrime ( $ n1 , $ n2 ) { return ( isPrime ( $ n1 ) && isPrime ( $ n2 ) && abs ( $ n1 - $ n2 ) == 2 ) ; } $ n1 = 11 ; $ n2 = 13 ; if ( twinPrime ( $ n1 , $ n2 ) ) echo \" Twin ▁ Prime \" , \" STRNEWLINE \" ; else echo \" STRNEWLINE \" , \" Not ▁ Twin ▁ Prime \" , \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah urutan 2, 22, 222, ... ... ... | fungsi yang mengembalikan jumlah siri; Kod pemacu", "code": "< ? php function sumOfSeries ( $ n ) { return 0.0246 * ( pow ( 10 , $ n ) - 1 - ( 9 * $ n ) ) ; } $ n = 3 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text": "Cari jumlah pekali binomial indeks walaupun | Pulangan nilai pekali binomial yang diindeks yang diindeks yang 2 dinaikkan kepada kuasa n - 1 .; Kod pemacu", "code": "< ? php function evenbinomialCoeffSum ( $ n ) { return ( 1 << ( $ n - 1 ) ) ; } $ n = 4 ; echo evenbinomialCoeffSum ( $ n ) ; ? >"}
{"text": "Program untuk mencetak siri nombor segitiga sehingga n | Berfungsi untuk mencari nombor segi tiga; Untuk setiap lelaran meningkat j sebanyak 1 dan masukkannya ke k; Meningkat j oleh 1; Tambah nilai j ke k dan kemas kini k; Kod pemacu", "code": "< ? php function triangular_series ( $ n ) { $ i ; $ j = 1 ; $ k = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo ( \" ▁ \" . $ k . \" ▁ \" ) ; $ j = $ j + 1 ; $ k = $ k + $ j ; } } $ n = 5 ; triangular_series ( $ n ) ; ? >"}
{"text": "Jumlah siri 1 + (1 + 3) + (1 + 3 + 5) + (1 + 3 + 5 + 7) + Ã ¢ Â 'â € |", "code": "< ? php function sumOfTheSeries ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; } $ n = 5 ; echo \" Sum ▁ = ▁ \" . sumOfTheSeries ( $ n ) ; ? >"}
{"text": "Jumlah siri 1 + (1 + 2) + (1 + 2 + 3) + (1 + 2 + 3 + 4) + ... ... + (1 + 2 + 3 + 4 + ... + n) | Fungsi untuk mencari jumlah siri yang diberikan; Kod pemacu", "code": "< ? php function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ sum += $ j ; return $ sum ; } $ n = 10 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text": "Bilangan segitiga selepas n bergerak | berfungsi untuk mengira bilangan segitiga dalam langkah nth; Kod pemacu", "code": "< ? php function numberOfTriangles ( $ n ) { $ ans = 2 * ( pow ( 3 , $ n ) ) - 1 ; return $ ans ; } $ n = 2 ; echo numberOfTriangles ( $ n ) ; ? >"}
{"text": "Nombor Motzkin | Kembalikan nombor Nth Motzkin. ; Kes asas; Mencari nombor Motzkin. ; Kod yang didorong", "code": "< ? php function motzkin ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = ( ( 2 * $ i + 1 ) * $ dp [ $ i - 1 ] + ( 3 * $ i - 3 ) * $ dp [ $ i - 2 ] ) / ( $ i + 2 ) ; return $ dp [ $ n ] ; } $ n = 8 ; echo ( motzkin ( $ n ) ) ; ? >"}
{"text": "NicomachusÃƒæ 'Ã † â € ™ ÃƒÂ € ¢ â, ¬ â \"¢ ¢ Ãƒæ' Ã † â € ™ ¢ Ãƒ ¢ ¢ ¢ ¢ Â '¢ Ãƒ ¢ Ã ¢ Â, Å ¡¡¬ ÃƒÂ € | | ¾ ¢ s teorem (jumlah k | kembali jumlah kumpulan kth dari integer ganjil positif.", "code": "< ? php function kthgroupsum ( $ k ) { return $ k * $ k * $ k ; } $ k = 3 ; echo kthgroupsum ( $ k ) ; ? >"}
{"text": "Cari x, y, z yang memuaskan 2 / n = 1 / x + 1 / y + 1 / z | fungsi untuk mencari x y dan z yang memenuhi persamaan yang diberikan. ; Kod pemacu", "code": "< ? php function printXYZ ( $ n ) { if ( $ n == 1 ) echo - 1 ; else echo \" x ▁ is ▁ \" , $ n , \" STRNEWLINE y ▁ is ▁ \" , $ n + 1 , \" STRNEWLINE z ▁ is ▁ \" , $ n * ( $ n + 1 ) ; } $ n = 7 ; printXYZ ( $ n ) ; ? >"}
{"text": "Cari n | Fungsi untuk mencari istilah n; Kod pemacu", "code": "< ? php function term ( $ n ) { return $ n * ( $ n + 1 ) / 2 ; } $ n = 4 ; echo ( term ( $ n ) ) ; ? >"}
{"text": "Cari min harmonik menggunakan min aritmetik dan geometri min | Fungsi untuk mengira min aritmetik, min geometri dan harmonik; Kod pemacu", "code": "< ? php function compute ( $ a , $ b ) { $ AM ; $ GM ; $ HM ; $ AM = ( $ a + $ b ) / 2 ; $ GM = sqrt ( $ a * $ b ) ; $ HM = ( $ GM * $ GM ) / $ AM ; return $ HM ; } $ a = 5 ; $ b = 15 ; $ HM = compute ( $ a , $ b ) ; echo \" Harmonic ▁ Mean ▁ between ▁ \" . $ a . \" ▁ and ▁ \" . $ b . \" ▁ is ▁ \" . $ HM ; return 0 ; ? >"}
{"text": "Cari n | Mengembalikan elemen siri ini; Kod pemacu", "code": "< ? php function series ( $ n ) { return ( 8 * $ n * $ n ) + 1 ; } $ n = 5 ; echo ( series ( $ n ) ) ; ? >"}
{"text": "Semak jika nombor boleh dibahagikan oleh semua pembahagi utama nombor lain | Program PHP untuk mencari sama ada semua faktor utama Y membahagikan x. ; Mengembalikan benar jika semua faktor utama y membahagikan x. ; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { return $ b == 0 ? $ a : gcd ( $ b , $ a % $ b ) ; } function isDivisible ( $ x , $ y ) { if ( $ y == 1 ) return true ; $ z = gcd ( $ x , $ y ) ; if ( $ z == 1 ) return false ; return isDivisible ( $ x , $ y / $ z ) ; } $ x = 18 ; $ y = 12 ; if ( isDivisible ( $ x , $ y ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Program untuk mencari jumlah siri A ^ 1/1! + A ^ 2/2! + A ^ 3/3! + A ^ 4/4! + Ã ¢ Â, ¬ | Ã ¢ Â '¬ |. + a ^ n / n! | Fungsi untuk mengira jumlah siri yang diberikan; Multiply (a / i) hingga istilah sebelumnya; Kedai Hasil dalam RES; Kod pemacu", "code": "< ? php function sumOfSeries ( $ a , $ num ) { $ res = 0 ; $ prev = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { $ prev *= ( $ a / $ i ) ; $ res = $ res + $ prev ; } return ( $ res ) ; } $ n = 5 ; $ a = 2 ; echo ( sumOfSeries ( $ a , $ n ) ) ; ? >"}
{"text": "Program untuk Celsius untuk Penukaran Fahrenheit | berfungsi untuk menukar skala Celsius ke skala Fahrenheit; Kod pemacu", "code": "< ? php function Cel_To_Fah ( $ n ) { return ( ( $ n * 9.0 / 5.0 ) + 32.0 ) ; } $ n = 20.0 ; echo Cel_To_Fah ( $ n ) ; ? >"}
{"text": "Siri dengan GCD dan jumlah terbesar sama dengan N | berfungsi untuk menjana dan mencetak urutan; menyimpan GCD maksimum yang boleh dilakukan dengan urutan. ; Jika GCD maksimum keluar menjadi sifar maka tidak mungkin; GCD terkecil mungkin ialah 1; melintasi array untuk mengetahui maksimum GCD; memeriksa jika nombor itu boleh dibahagikan atau tidak; cek jika x lebih kecil maka maksimum GCD mungkin dan x lebih besar maka GCD yang dihasilkan sehingga sekarang, maka r = x; Cek jika N / X lebih kecil daripada Max GCD mungkin dan N / X lebih besar maka GCD yang dihasilkan sehingga sekarang, maka r = x; melintasi dan mencetak d, 2d, 3d, ..., (k - 1) d ,; Mengira elemen terakhir urutan n - s. ; mencetak elemen terakhir; Kod pemacu", "code": "< ? php function print_sequence ( $ n , $ k ) { $ b = ( int ) ( $ n / ( $ k * ( $ k + 1 ) / 2 ) ) ; if ( $ b == 0 ) { echo ( -1 ) ; } else { $ r = 1 ; for ( $ x = 1 ; $ x * $ x <= $ n ; $ x ++ ) { if ( $ n % $ x != 0 ) continue ; if ( $ x <= $ b && $ x > $ r ) $ r = $ x ; if ( $ n / $ x <= $ b && $ n / $ x > $ r ) $ r = $ n / $ x ; } for ( $ i = 1 ; $ i < $ k ; $ i ++ ) echo ( $ r * $ i . \" ▁ \" ) ; $ res = $ n - ( $ r * ( $ k * ( $ k - 1 ) / 2 ) ) ; echo ( $ res . \" \" ) ; } } $ n = 24 ; $ k = 4 ; print_sequence ( $ n , $ k ) ; $ n = 24 ; $ k = 5 ; print_sequence ( $ n , $ k ) ; $ n = 6 ; $ k = 4 ; print_sequence ( $ n , $ k ) ; ? >"}
{"text": "Bilangan komposisi nombor semula jadi | Program PHP untuk mencari jumlah komposisi nombor semula jadi; Kembali 2 dibangkitkan kepada kuasa (n - 1); Kod pemacu", "code": "< ? php function countCompositions ( $ n ) { return ( ( 1 ) << ( $ n - 1 ) ) ; } $ n = 4 ; echo countCompositions ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mengira digit dalam integer (4 kaedah yang berbeza) | Program PHP rekursif untuk mengira bilangan digit dalam nombor; Kod pemacu", "code": "< ? php function countDigit ( $ n ) { if ( $ n / 10 == 0 ) return 1 ; return 1 + countDigit ( ( int ) ( $ n / 10 ) ) ; } $ n = 345289467 ; print ( \" Number ▁ of ▁ digits ▁ : ▁ \" . ( countDigit ( $ n ) ) ) ; ? >"}
{"text": "Nombor Tribonacci | Program PHP berasaskan DP untuk mencetak nombor N First N Tribonacci. ; Kod pemacu", "code": "< ? php function printTrib ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 0 ; $ dp [ 2 ] = 1 ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] + $ dp [ $ i - 3 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ dp [ $ i ] , \" ▁ \" ; } $ n = 10 ; printTrib ( $ n ) ; ? >"}
{"text": "Nombor Tribonacci | Program untuk mencetak fungsi Nombor N First N Tribonacci Matriks untuk 3 * 3 matriks; Fungsi rekursif untuk meningkatkan matriks t ke kuasa n; keadaan asas. ; panggilan secara rekursif untuk mengasyikkan matriks; mengira persegi matriks T; Jika n ganjil membiaknya satu kali dengan m; keadaan asas; $ T [0] [0] mengandungi nombor tribonacci supaya mengembalikannya; Kod pemacu", "code": "< ? php function multiply ( & $ T , $ M ) { $ a = $ T [ 0 ] [ 0 ] * $ M [ 0 ] [ 0 ] + $ T [ 0 ] [ 1 ] * $ M [ 1 ] [ 0 ] + $ T [ 0 ] [ 2 ] * $ M [ 2 ] [ 0 ] ; $ b = $ T [ 0 ] [ 0 ] * $ M [ 0 ] [ 1 ] + $ T [ 0 ] [ 1 ] * $ M [ 1 ] [ 1 ] + $ T [ 0 ] [ 2 ] * $ M [ 2 ] [ 1 ] ; $ c = $ T [ 0 ] [ 0 ] * $ M [ 0 ] [ 2 ] + $ T [ 0 ] [ 1 ] * $ M [ 1 ] [ 2 ] + $ T [ 0 ] [ 2 ] * $ M [ 2 ] [ 2 ] ; $ d = $ T [ 1 ] [ 0 ] * $ M [ 0 ] [ 0 ] + $ T [ 1 ] [ 1 ] * $ M [ 1 ] [ 0 ] + $ T [ 1 ] [ 2 ] * $ M [ 2 ] [ 0 ] ; $ e = $ T [ 1 ] [ 0 ] * $ M [ 0 ] [ 1 ] + $ T [ 1 ] [ 1 ] * $ M [ 1 ] [ 1 ] + $ T [ 1 ] [ 2 ] * $ M [ 2 ] [ 1 ] ; $ f = $ T [ 1 ] [ 0 ] * $ M [ 0 ] [ 2 ] + $ T [ 1 ] [ 1 ] * $ M [ 1 ] [ 2 ] + $ T [ 1 ] [ 2 ] * $ M [ 2 ] [ 2 ] ; $ g = $ T [ 2 ] [ 0 ] * $ M [ 0 ] [ 0 ] + $ T [ 2 ] [ 1 ] * $ M [ 1 ] [ 0 ] + $ T [ 2 ] [ 2 ] * $ M [ 2 ] [ 0 ] ; $ h = $ T [ 2 ] [ 0 ] * $ M [ 0 ] [ 1 ] + $ T [ 2 ] [ 1 ] * $ M [ 1 ] [ 1 ] + $ T [ 2 ] [ 2 ] * $ M [ 2 ] [ 1 ] ; $ i = $ T [ 2 ] [ 0 ] * $ M [ 0 ] [ 2 ] + $ T [ 2 ] [ 1 ] * $ M [ 1 ] [ 2 ] + $ T [ 2 ] [ 2 ] * $ M [ 2 ] [ 2 ] ; $ T [ 0 ] [ 0 ] = $ a ; $ T [ 0 ] [ 1 ] = $ b ; $ T [ 0 ] [ 2 ] = $ c ; $ T [ 1 ] [ 0 ] = $ d ; $ T [ 1 ] [ 1 ] = $ e ; $ T [ 1 ] [ 2 ] = $ f ; $ T [ 2 ] [ 0 ] = $ g ; $ T [ 2 ] [ 1 ] = $ h ; $ T [ 2 ] [ 2 ] = $ i ; } function power ( & $ T , $ n ) { if ( $ n == 0 $ n == 1 ) return ; $ M = array ( array ( 1 , 1 , 1 ) , array ( 1 , 0 , 0 ) , array ( 0 , 1 , 0 ) ) ; power ( $ T , ( int ) ( $ n / 2 ) ) ; multiply ( $ T , $ T ) ; if ( $ n % 2 ) multiply ( $ T , $ M ) ; } function tribonacci ( $ n ) { $ T = array ( array ( 1 , 1 , 1 ) , array ( 1 , 0 , 0 ) , array ( 0 , 1 , 0 ) ) ; if ( $ n == 0 $ n == 1 ) return 0 ; else power ( $ T , $ n - 2 ) ; return $ T [ 0 ] [ 0 ] ; } $ n = 10 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo tribonacci ( $ i ) . \" ▁ \" ; echo \" STRNEWLINE \" ; ? >"}
{"text": "Geometric min (dua kaedah) | Fungsi untuk mengira min geometri dan pulangan nilai terapung. ; mengisytiharkan pembolehubah jumlah dan memulakannya kepada 1 .; Kirakan jumlah semua elemen dalam array. ; Kirakan Geometrik Maksud melalui Formula Antilog (((Log (1) + Log (2) + ... Log (N)) / N) dan kembalikan nilai;", "code": "< ? php function geometricMean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + log ( $ arr [ $ i ] ) ; $ sum = $ sum / $ n ; return exp ( $ sum ) ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ) ; $ n = count ( $ arr ) ; echo geometricMean ( $ arr , $ n ) ; ? >"}
{"text": "Bilangan terkecil k sedemikian rupa sehingga produk digit k adalah sama dengan n | berfungsi untuk mencari bilangan terkecil k supaya produk digit k adalah sama dengan n; Jika 'n' adalah nombor digit tunggal, maka itu adalah nombor yang diperlukan; Tumpukan kedai digit; berulang kali membahagikan 'n' dengan nombor dari 9 hingga 2 sehingga semua nombor digunakan atau 'n' 1; Simpan digit 'I' yang membahagikan 'n' ke timbunan; Jika benar, maka tiada nombor 'k' boleh dibentuk; digit pop dari stack 'digit' dan tambahkannya ke 'k'; bilangan terkecil yang diperlukan; Kod pemacu", "code": "< ? php function smallestNumber ( $ n ) { if ( $ n >= 0 && $ n <= 9 ) return $ n ; $ digits = array ( ) ; for ( $ i = 9 ; $ i >= 2 && $ n > 1 ; $ i -- ) { while ( $ n % $ i == 0 ) { array_push ( $ digits , $ i ) ; $ n = ( int ) ( $ n / $ i ) ; } } if ( $ n != 1 ) return -1 ; $ k = 0 ; while ( ! empty ( $ digits ) ) $ k = $ k * 10 + array_pop ( $ digits ) ; return $ k ; } $ n = 100 ; echo smallestNumber ( $ n ) ; ? >"}
{"text": "Semak jika nombor adalah sihir (jumlah digit rekursif ialah 1) | Program PHP untuk memeriksa sama ada nombor adalah nombor sihir. ; Perhatikan bahawa gelung berterusan jika n adalah 0 dan jumlahnya bukan sifar. Ia berhenti apabila n menjadi 0 dan jumlah menjadi digit tunggal. ; Kembali benar jika jumlah menjadi 1 .; Kod pemacu", "code": "< ? php function isMagic ( $ n ) { $ sum = 0 ; while ( $ n > 0 $ sum > 9 ) { if ( $ n == 0 ) { $ n = $ sum ; $ sum = 0 ; } $ sum += $ n % 10 ; $ n /= 10 ; } return ( $ sum == 1 ) ; } $ n = 1234 ; if ( isMagic ( $ n ) ) echo \" Magic ▁ Number \" ; else echo \" Not ▁ a ▁ magic ▁ Number \" ; ? >"}
{"text": "Urutan Sylvester | Program PHP untuk mencetak istilah urutan Sylvester; Untuk menyimpan produk. ; Untuk menyimpan nombor semasa. ; Gelung hingga n. ; Kod pemacu", "code": "< ? php $ N = 1000000007 ; function printSequence ( $ n ) { global $ N ; $ a = 1 ; $ ans = 2 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo $ ans , \" \" ; $ ans = ( ( $ a % $ N ) * ( $ ans % $ N ) ) % $ N ; $ a = $ ans ; $ ans = ( $ ans + 1 ) % $ N ; } } $ n = 6 ; printSequence ( $ n ) ; ? >"}
{"text": "Program untuk mencari jumlah nombor natural pertama | Mengembalikan jumlah nombor semulajadi n pertama; Kod pemacu", "code": "< ? php function findSum ( $ n ) { $ sum = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) $ sum = $ sum + $ x ; return $ sum ; } $ n = 5 ; echo findSum ( $ n ) ; ? >"}
{"text": "Hailstone Number | berfungsi untuk mencetak nombor batu hujan dan untuk mengira bilangan langkah yang diperlukan; N pada mulanya 1 .; N dikurangkan kepada 1 .; Jika n adalah juga. ; N adalah ganjil. ; Kod pemacu; Berfungsi untuk menjana nombor batu hujan; Output: Bilangan langkah", "code": "< ? php function HailstoneNumbers ( $ N ) { static $ c ; echo $ N . \" \" ; if ( $ N == 1 && $ c == 0 ) { return $ c ; } else if ( $ N == 1 && $ c != 0 ) { $ c ++ ; return $ c ; } else if ( $ N % 2 == 0 ) { $ c ++ ; HailstoneNumbers ( ( int ) ( $ N / 2 ) ) ; } else if ( $ N % 2 != 0 ) { $ c ++ ; HailstoneNumbers ( 3 * $ N + 1 ) ; } return $ c ; } $ N = 7 ; $ x = HailstoneNumbers ( $ N ) ; echo \" Number of Steps : \" ? >"}
{"text": "Cari m | Berfungsi untuk mengembalikan penjumlahan mth; Kes asas; Kod pemacu", "code": "< ? php function SUM ( $ n , $ m ) { if ( $ m == 1 ) return ( $ n * ( $ n + 1 ) / 2 ) ; $ sum = SUM ( $ n , $ m - 1 ) ; return ( $ sum * ( $ sum + 1 ) / 2 ) ; } $ n = 5 ; $ m = 3 ; echo \" SUM ( \" , $ n , \" , ▁ \" , $ m , \" ) : ▁ \" , SUM ( $ n , $ m ) ; ? >"}
{"text": "Cari nombor terkecil n seperti n xor n + 1 sama dengan k. | berfungsi untuk mengembalikan n yang diperlukan; jika k adalah bentuk 2 ^ i - 1; Kod pemacu", "code": "< ? php function xorCalc ( $ k ) { if ( $ k == 1 ) return 2 ; if ( ( ( $ k + 1 ) & $ k ) == 0 ) return floor ( $ k / 2 ) ; return 1 ; } $ k = 31 ; echo xorCalc ( $ k ) ; ? >"}
{"text": "Cari n | Program PHP untuk mencari nombor N - tH yang mengandungi hanya 4 dan 7 .; Jika n adalah ganjil, tambah 4 dan pindah ke ibu bapa; Jika n adalah, tambah 7 dan pindah ke ibu bapa; Reverse Res dan kembali. ; Kod pemacu", "code": "< ? php function findNthNo ( $ n ) { $ res = \" \" ; while ( $ n >= 1 ) { if ( $ n & 1 ) { $ res = $ res . \"4\" ; $ n = ( int ) ( ( $ n - 1 ) / 2 ) ; } else { $ res = $ res . \"7\" ; $ n = ( int ) ( ( $ n - 2 ) / 2 ) ; } } return strrev ( $ res ) ; } $ n = 13 ; echo findNthNo ( $ n ) ; ? >"}
{"text": "Jumlah bilangan pembahagi untuk nombor tertentu | program untuk mencari tidak. pembahagi; kaedah ayak untuk pengiraan utama; Melintasi semua nombor perdana; Kirakan bilangan pembahagi dengan formula total div = (p1 + 1) * (p2 + 1) * .... . * (pn + 1) di mana n = (a1 ^ p1) * (a2 ^ p2). ... * (An ^ pn) Ai yang menjadi pembahagi utama untuk n dan pi adalah kuasa masing -masing dalam pemfaktoran; Kod pemacu", "code": "< ? php function divCount ( $ n ) { $ hash = array_fill ( 0 , $ n + 1 , 1 ) ; for ( $ p = 2 ; ( $ p * $ p ) < $ n ; $ p ++ ) if ( $ hash [ $ p ] == 1 ) for ( $ i = ( $ p * 2 ) ; $ i < $ n ; $ i = ( $ i + $ p ) ) $ hash [ $ i ] = 0 ; $ total = 1 ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ hash [ $ p ] == 1 ) { $ count = 0 ; if ( $ n % $ p == 0 ) { while ( $ n % $ p == 0 ) { $ n = ( $ n / $ p ) ; $ count ++ ; } $ total = $ total * ( $ count + 1 ) ; } } } return $ total ; } $ n = 24 ; echo divCount ( $ n ) ; ? >"}
{"text": "Bilangan Maksimum Faktor Perdana yang unik | Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Sieve kaedah Eratosthenes untuk mengira bilangan faktor utama yang unik. ; Mengembalikan elemen maksimum dalam arr []; Kod pemacu", "code": "< ? php function maxPrimefactorNum ( $ N ) { $ arr = array_fill ( 0 , $ N + 1 , 0 ) ; for ( $ i = 2 ; $ i * $ i <= $ N ; $ i ++ ) { if ( ! $ arr [ $ i ] ) for ( $ j = 2 * $ i ; $ j <= $ N ; $ j += $ i ) $ arr [ $ j ] ++ ; $ arr [ $ i ] = 1 ; } return max ( $ arr ) ; } $ N = 40 ; echo maxPrimefactorNum ( $ N ) ; ? >"}
{"text": "Perpuluhan kepada penukaran binari tanpa menggunakan pengendali aritmetik | berfungsi untuk perpuluhan kepada penukaran binari tanpa menggunakan pengendali aritmetik; untuk menyimpan persamaan binari perpuluhan; untuk mendapatkan angka binari terakhir nombor 'n' dan mengumpulnya pada permulaan 'bin'; shift kanan 'n' oleh 1; nombor binari yang diperlukan; Kod pemacu", "code": "< ? php function decToBin ( $ n ) { if ( $ n == 0 ) return \"0\" ; $ bin = \" \" ; while ( $ n > 0 ) { $ bin = ( ( $ n & 1 ) == 0 ? '0' : '1' ) . $ bin ; $ n >>= 1 ; } return $ bin ; } $ n = 38 ; echo decToBin ( $ n ) ; ? >"}
{"text": "Jumlah elemen array yang mula -mula terus meningkat kemudian berkurangan | Kaedah PHP yang cekap untuk mencari jumlah unsur -unsur array yang semakin meningkat dan kemudian menurun separuh jalan; Kod pemacu", "code": "< ? php function arraySum ( $ arr , $ n ) { $ x = ( $ n + 1 ) / 2 ; return ( $ arr [ 0 ] - 1 ) * $ n + $ x * $ x ; } $ arr = array ( 10 , 11 , 12 , 13 , 12 , 11 , 10 ) ; $ n = sizeof ( $ arr ) ; echo ( arraySum ( $ arr , $ n ) ) ; ? >"}
{"text": "Kuali baki menggunakan berat yang diberikan kuasa nombor | Kaedah mengembalikan benar jika mengimbangi skala adalah mungkin; Vektor BaseForm akan menyimpan perwakilan T pada asas A dalam urutan terbalik; Tukar t ke perwakilan pada asas A; Buat angka pertama perwakilan sebagai 0; gelung atas perwakilan asas t; Jika mana -mana digit tidak 0, 1, (a - 1) atau A maka keseimbangan tidak mungkin; jika digit adalah atau (a - 1) maka tambah indeks kiri 'mengira / (kes, apabila ini ~' dipindahkan ke sisi); Jika perwakilan diproses maka pengimbangan adalah mungkin; Kod pemacu", "code": "< ? php function isBalancePossible ( $ T , $ a ) { $ baseForm = array ( ) ; while ( $ T ) { array_push ( $ baseForm , $ T % $ a ) ; $ T = ( int ) ( $ T / $ a ) ; } array_push ( $ baseForm , 0 ) ; for ( $ i = 0 ; $ i < count ( $ baseForm ) ; $ i ++ ) { if ( $ baseForm [ $ i ] != 0 && $ baseForm [ $ i ] != 1 && $ baseForm [ $ i ] != ( $ a - 1 ) && $ baseForm [ $ i ] != $ a ) return false ; if ( $ baseForm [ $ i ] == $ a || $ baseForm [ $ i ] == ( $ a - 1 ) ) $ baseForm [ $ i + 1 ] += 1 ; } return true ; } $ T = 11 ; $ a = 4 ; $ balancePossible = isBalancePossible ( $ T , $ a ) ; if ( $ balancePossible ) echo \" Balance ▁ is ▁ possible STRNEWLINE \" ; else echo \" Balance ▁ is ▁ not ▁ possible STRNEWLINE \" ; ? >"}
{"text": "Bilangan digit dalam produk dua nombor | berfungsi untuk mengira bilangan digit dalam produk dua nombor; Jika salah satu daripada nombor itu 0, maka produk akan menjadi 0; kiraan digit yang diperlukan; Kod pemacu", "code": "< ? php function countDigits ( $ a , $ b ) { if ( $ a == 0 or $ b == 0 ) return 1 ; return floor ( log10 ( abs ( $ a ) ) + log10 ( abs ( $ b ) ) ) + 1 ; } $ a = 33 ; $ b = -24 ; echo countDigits ( $ a , $ b ) ; ? >"}
{"text": "Mengedarkan item M dalam lingkaran saiz n bermula dari k | n ==> saiz bulatan m ==> bilangan item k ==> kedudukan awal; N - K + 1 adalah bilangan kedudukan sebelum kita mencapai permulaan bulatan. Jika m kurang daripada nilai ini, maka kita boleh kembali (m - 1) kedudukan; Marilah kita mengira barang -barang yang tinggal sebelum kita mencapai permulaan. ; Kami mengira M % N untuk melangkau semua pusingan lengkap. Sekiranya kita mencapai akhir, kita kembali n lain kita kembali m % n; Kod pemacu", "code": "< ? php function lastPosition ( $ n , $ m , $ k ) { if ( $ m <= $ n - $ k + 1 ) return $ m + $ k - 1 ; $ m = $ m - ( $ n - $ k + 1 ) ; return ( $ m % $ n == 0 ) ? $ n : ( $ m % $ n ) ; } $ n = 5 ; $ m = 8 ; $ k = 2 ; echo lastPosition ( $ n , $ m , $ k ) ; ? >"}
{"text": "Penyelesaian yang menarik untuk mendapatkan semua nombor perdana yang lebih kecil daripada N | Program PHP untuk mencetak nombor perdana yang lebih kecil daripada N; Kirakan faktorial dan gunakan teorem Wilson. ; Kod pemacu", "code": "< ? php function primesInRange ( $ n ) { $ fact = 1 ; for ( $ k = 2 ; $ k < $ n ; $ k ++ ) { $ fact = $ fact * ( $ k - 1 ) ; if ( ( $ fact + 1 ) % $ k == 0 ) print ( $ k . \" STRNEWLINE \" ) ; } } $ n = 15 ; primesInRange ( $ n ) ; ? >"}
{"text": "Teka -teki Arus Produk | Tetapkan 2 (o (1) ruang) | Nilai Epsilon untuk mengekalkan ketepatan; untuk memegang jumlah semua nilai; produk output untuk setiap antilog indeks untuk mencari nilai produk asal; Kod pemacu", "code": "< ? php $ EPS = 1e-9 ; function productPuzzle ( $ a , $ n ) { global $ EPS ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( double ) log10 ( $ a [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( int ) ( $ EPS + pow ( ( double ) 10.00 , $ sum - log10 ( $ a [ $ i ] ) ) ) . \" ▁ \" ; } $ a = array ( 10 , 3 , 5 , 6 , 2 ) ; $ n = count ( $ a ) ; echo \" The ▁ product ▁ array ▁ is : ▁ STRNEWLINE \" ; productPuzzle ( $ a , $ n ) ; ? >"}
{"text": "Tukar semua bit dalam nombor ke 0 | Mengembalikan nombor yang diubah suai dengan semua bit 0 .; Untuk menyimpan jumlah bit di jawatan walaupun. ; Untuk menyimpan bit untuk beralih; Satu demi satu meletakkan semua bit untuk berakhir; Jika bit terakhir semasa ditetapkan, tambahkannya ke Ans; Kedudukan peralihan seterusnya; Kod pemacu", "code": "< ? php function changeEvenBits ( $ n ) { $ to_subtract = 0 ; $ m = 0 ; for ( $ x = $ n ; $ x ; $ x >>= 2 ) { if ( $ x & 1 ) $ to_subtract += ( 1 << $ m ) ; $ m += 2 ; } return $ n - $ to_subtract ; } $ n = 30 ; echo changeEvenBits ( $ n ) ; ? >"}
{"text": "Cari nombor yang paling dekat dengan n dan dibahagikan dengan m | berfungsi untuk mencari nombor yang paling dekat dengan n dan dibahagikan dengan m; Cari kuil; 1 kemungkinan nombor terdekat; 2 dan kemungkinan nombor terdekat; Jika benar, maka N1 adalah nombor terdekat yang diperlukan; lain n2 adalah nombor terdekat yang diperlukan; Kod pemacu", "code": "< ? php function closestNumber ( $ n , $ m ) { $ q = ( int ) ( $ n / $ m ) ; $ n1 = $ m * $ q ; $ n2 = ( $ n * $ m ) > 0 ? ( $ m * ( $ q + 1 ) ) : ( $ m * ( $ q - 1 ) ) ; if ( abs ( $ n - $ n1 ) < abs ( $ n - $ n2 ) ) return $ n1 ; return $ n2 ; } $ n = 13 ; $ m = 4 ; echo closestNumber ( $ n , $ m ) , \" STRNEWLINE \" ; $ n = -15 ; $ m = 6 ; echo closestNumber ( $ n , $ m ) , \" STRNEWLINE \" ; $ n = 0 ; $ m = 8 ; echo closestNumber ( $ n , $ m ) , \" STRNEWLINE \" ; $ n = 18 ; $ m = -7 ; echo closestNumber ( $ n , $ m ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika nombor tertentu adalah pronic | berfungsi untuk memeriksa nombor pronic; Memeriksa nombor pronic dengan mengalikan nombor berturut -turut; Mencetak nombor pronic sehingga 200", "code": "< ? php function checkPronic ( $ x ) { for ( $ i = 0 ; $ i <= ( sqrt ( $ x ) ) ; $ i ++ ) if ( $ x == $ i * ( $ i + 1 ) ) return true ; return false ; } for ( $ i = 0 ; $ i <= 200 ; $ i ++ ) if ( checkPronic ( $ i ) ) echo $ i , \" ▁ \" ; ? >"}
{"text": "Cari Jumlah Minimum Faktor Nombor | Untuk mencari jumlah produk bilangan minimum; Cari faktor nombor dan tambah kepada jumlah; Mengembalikan jumlah nombor yang mempunyai produk minimum; Kod pemacu", "code": "< ? php function findMinSum ( $ num ) { $ sum = 0 ; for ( $ i = 2 ; $ i * $ i <= $ num ; $ i ++ ) { while ( $ num % $ i == 0 ) { $ sum += $ i ; $ num /= $ i ; } } $ sum += $ num ; return $ sum ; } $ num = 12 ; echo ( findMinSum ( $ num ) ) ; ? >"}
{"text": "Nombor minimum dengan digit sebagai 4 dan 7 sahaja dan diberikan jumlah | Mencetak nombor minimum dengan jumlah digit yang diberikan dan hanya dibenarkan digit sebagai 4 dan 7 .; Kes di mana semua digit yang tinggal adalah 4 atau 7 (jumlah angka yang tinggal harus berganda dari 4 atau 7); Jika kedua -dua 4 s dan 7 s ada dalam jumlah digit, kita tolak 4 .; Kod pemacu", "code": "< ? php function findMin ( $ sum ) { $ a = 0 ; $ b = 0 ; while ( $ sum > 0 ) { if ( $ sum % 7 == 0 ) { $ b ++ ; $ sum -= 7 ; } else if ( $ sum % 4 == 0 ) { $ a ++ ; $ sum -= 4 ; } else { $ a ++ ; $ sum -= 4 ; } } if ( $ sum < 0 ) { echo ( \" - 1n \" ) ; return ; } for ( $ i = 0 ; $ i < $ a ; $ i ++ ) echo ( \"4\" ) ; for ( $ i = 0 ; $ i < $ b ; $ i ++ ) echo ( \"7\" ) ; echo ( \" STRNEWLINE \" ) ; } findMin ( 15 ) ; ? >"}
{"text": "Tambah nombor minimum ke array supaya jumlahnya menjadi bahkan | Berfungsi untuk mengetahui nombor minimum; Mengira jumlah terma dalam array; Kod pemacu", "code": "< ? php function minNum ( $ arr , $ n ) { $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 ) $ odd += 1 ; return ( $ odd % 2 ) ? 1 : 2 ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; $ n = count ( $ arr ) ; echo minNum ( $ arr , $ n ) ; ? >"}
{"text": "Cari nombor maksimum yang boleh dibentuk menggunakan digit nombor tertentu | Berfungsi untuk mencetak nombor maksimum; array hashed untuk menyimpan kiraan digit; Menukar nombor yang diberikan kepada rentetan; Mengemas kini array kiraan; Hasilnya adalah untuk menyimpan nombor akhir; Melintasi array kiraan untuk mengira nombor maksimum; mengembalikan hasilnya; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function printMaxNum ( $ num ) { $ count = array_fill ( 0 , 10 , NULL ) ; $ str = ( string ) $ num ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) - ord ( '0' ) ] ++ ; $ result = 0 ; $ multiplier = 1 ; for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { while ( $ count [ $ i ] > 0 ) { $ result = $ result + ( $ i * $ multiplier ) ; $ count [ $ i ] -- ; $ multiplier = $ multiplier * 10 ; } } return $ result ; } $ num = 38293367 ; echo printMaxNum ( $ num ) ; ? >"}
{"text": "Bentuk nombor terbesar menggunakan paling banyak satu operasi swap | berfungsi untuk membentuk nombor terbesar dengan menggunakan operasi swap atmost; Untuk digit paling kanan, tidak akan ada digit yang lebih besar; Indeks digit kanan terbesar sehingga indeks semasa dari arah yang betul; melintasi array dari elemen kanan kedua hingga ke elemen kiri; jika 'num [i]' kurang daripada digit terbesar yang dihadapi setakat ini; lain; Tidak ada digit yang lebih besar untuk 'num [i]'; Kemas kini indeks 'kanan'; melintasi array 'rightmax []' dari kiri ke kanan; Jika untuk digit semasa, angka kanan yang lebih besar wujud kemudian menukarnya dengan digit kanan yang lebih besar dan pecah; melaksanakan operasi swap yang diperlukan; bilangan terbesar yang diperlukan; Kod pemacu", "code": "< ? php function largestNumber ( $ num ) { $ n = strlen ( $ num ) ; $ rightMax [ $ n ] = array ( 0 ) ; $ right ; $ rightMax [ $ n - 1 ] = -1 ; $ right = $ n - 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ num [ $ i ] < $ num [ $ right ] ) $ rightMax [ $ i ] = $ right ; else { $ rightMax [ $ i ] = -1 ; $ right = $ i ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ rightMax [ $ i ] != -1 ) { list ( $ num [ $ i ] , $ num [ $ rightMax [ $ i ] ] ) = array ( $ num [ $ rightMax [ $ i ] ] , $ num [ $ i ] ) ; break ; } } return $ num ; } $ num = \"8725634\" ; echo \" Largest ▁ number : ▁ \" , largestNumber ( $ num ) ; ? >"}
{"text": "Pembolehubah rawak binomial | berfungsi untuk mengira NCR i. e. , bilangan cara untuk memilih r dari objek N; Kerana NCR adalah sama dengan NC (N - R) untuk mengurangkan bilangan lelaran; Fungsi untuk mengira Binomial r. v. kebarangkalian; Kod pemacu", "code": "< ? php function nCr ( $ n , $ r ) { if ( $ r > $ n / 2 ) $ r = $ n - $ r ; $ answer = 1 ; for ( $ i = 1 ; $ i <= $ r ; $ i ++ ) { $ answer *= ( $ n - $ r + $ i ) ; $ answer /= $ i ; } return $ answer ; } function binomialProbability ( $ n , $ k , $ p ) { return nCr ( $ n , $ k ) * pow ( $ p , $ k ) * pow ( 1 - $ p , $ n - $ k ) ; } $ n = 10 ; $ k = 5 ; $ p = 1.0 / 3 ; $ probability = binomialProbability ( $ n , $ k , $ p ) ; echo \" Probability ▁ of ▁ \" . $ k ; echo \" ▁ heads ▁ when ▁ a ▁ coin ▁ is ▁ tossed ▁ \" . $ n ; echo \" ▁ times ▁ where ▁ probability ▁ of ▁ \" . \" each ▁ head ▁ is ▁ \" . $ p ; echo \" is = \" ? >"}
{"text": "Cari pasangan dengan GCD maksimum dalam array | Berfungsi untuk mencari GCD pasangan dengan Max GCD dalam array; Pengkomputeran elemen tertinggi; Array untuk menyimpan kiraan pembahagi i. e. GCD yang berpotensi; Melangkah ke atas setiap elemen; Mengira semua pembahagi; Pembahagi dijumpai; Kenaikan kiraan untuk pembahagi; Elemen / pembahagi juga merupakan pemeriksaan pembahagi jika kedua -dua pembahagi tidak sama; Memeriksa GCD berpotensi tertinggi; Jika pembahagi ini boleh membahagikan sekurang -kurangnya 2 nombor, ia adalah GCD sekurang -kurangnya 1 pasangan; Array di mana pasangan dengan Max GCD dapat dijumpai; Saiz array", "code": "< ? php function findMaxGCD ( $ arr , $ n ) { $ high = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ high = max ( $ high , $ arr [ $ i ] ) ; $ divisors = array_fill ( 0 , $ high + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= ( int ) ( sqrt ( $ arr [ $ i ] ) ) ; $ j ++ ) { if ( $ arr [ $ i ] % $ j == 0 ) { $ divisors [ $ j ] ++ ; if ( $ j != ( int ) ( $ arr [ $ i ] / $ j ) ) $ divisors [ ( int ) ( $ arr [ $ i ] / $ j ) ] ++ ; } } } for ( $ i = $ high ; $ i >= 1 ; $ i -- ) if ( $ divisors [ $ i ] > 1 ) return $ i ; } $ arr = array ( 1 , 2 , 4 , 8 , 8 , 12 ) ; $ n = sizeof ( $ arr ) ; echo findMaxGCD ( $ arr , $ n ) ; ? >"}
{"text": "Cari pasangan dengan GCD maksimum dalam array | berfungsi untuk mencari GCD pasangan dengan Max GCD dalam array; Mengira max dalam array; Mengekalkan array kiraan; Pembolehubah untuk menyimpan gandaan nombor; Melangkah dari max hingga 1 GCD sentiasa antara max dan 1. GCD pertama yang dijumpai akan menjadi yang tertinggi kerana kita menurunkan potensi GCD; Melangkah dari potensi GCD semasa sehingga ia kurang daripada maksimum; Pelbagai dijumpai; Meningkatkan potensi GCD dengan sendirinya untuk memeriksa saya, 2 i, 3 ​​i .... ; 2 gandaan dijumpai, Max GCD dijumpai; Array di mana pasangan dengan Max GCD dapat dijumpai; Saiz array", "code": "< ? php function findMaxGCD ( $ arr , $ n ) { $ high = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ high = max ( $ high , $ arr [ $ i ] ) ; $ count = array_fill ( 0 , $ high + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ $ arr [ $ i ] ] ++ ; $ counter = 0 ; for ( $ i = $ high ; $ i >= 1 ; $ i -- ) { $ j = $ i ; $ counter = 0 ; while ( $ j <= $ high ) { if ( $ count [ $ j ] >= 2 ) return $ j ; else if ( $ count [ $ j ] == 1 ) $ counter ++ ; $ j += $ i ; if ( $ counter == 2 ) return $ i ; } } } $ arr = array ( 1 , 2 , 4 , 8 , 8 , 12 ) ; $ n = count ( $ arr ) ; print ( findMaxGCD ( $ arr , $ n ) ) ; ? >"}
{"text": "Nombor jahat | mengembalikan nombor 1 s dari nombor binari; mengira 1 s; Periksa sama ada nombor jahat atau tidak; menukar n ke bentuk binari; mengira baki; menyimpan sisa dalam bentuk binari sebagai nombor; Memanggil fungsi count_one untuk mengira dan mengembalikan nombor 1 s dalam bin; Kod pemacu", "code": "< ? php function count_one ( $ n ) { $ c_one = 0 ; while ( $ n != 0 ) { $ rem = $ n % 10 ; if ( $ rem == 1 ) $ c_one = $ c_one + 1 ; $ n = $ n / 10 ; } return $ c_one ; } function checkEvil ( $ n ) { $ i = 0 ; $ bin = 0 ; $ n_one = 0 ; while ( $ n != 0 ) { $ r = $ n % 2 ; $ bin = $ bin + $ r * ( pow ( 10 , $ i ) ) ; $ n = $ n / 2 ; } $ n_one = count_one ( $ bin ) ; if ( $ n_one % 2 == 0 ) return 1 ; else return 0 ; } $ i ; $ check ; $ num ; $ num = 32 ; $ check = checkEvil ( $ num ) ; if ( $ check == 1 ) echo $ num , \" ▁ is ▁ Evil ▁ Number STRNEWLINE \" ; else echo $ num , \" ▁ is ▁ Odious ▁ Number STRNEWLINE \" ; ? >"}
{"text": "Kiraan bilangan pasangan (a <= n, b <= n) sedemikian rupa sehingga GCD (a, b) adalah b | Mengembalikan bilangan pasangan yang sah; memulakan k; gelung sehingga imin <= n; Memulakan hasil; Max I dengan lantai K yang diberikan (n / k); Menambah k * (bilangan saya dengan lantai (n / i) = k ke ans; set imin = iMax + 1 dan k = n / imin; kod pemandu", "code": "< ? php function CountPairs ( $ n ) { $ k = $ n ; $ imin = 1 ; $ ans = 0 ; while ( $ imin <= $ n ) { $ imax = $ n / $ k ; $ ans += $ k * ( $ imax - $ imin + 1 ) ; $ imin = $ imax + 1 ; $ k = ( int ) ( $ n / $ imin ) ; } return $ ans ; } echo ( CountPairs ( 1 ) . \" STRNEWLINE \" ) ; echo ( CountPairs ( 2 ) . \" STRNEWLINE \" ) ; echo ( CountPairs ( 3 ) . \" STRNEWLINE \" ) ; ? >"}
{"text": "Cari digit terakhir siri yang diberikan | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); $ x = $ x % $ p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang $ y = $ y >> 1; y = y / 2; Mengembalikan modulo songsang dengan m menggunakan algoritma euclid yang dilanjutkan; Q adalah Quotient; M adalah selebihnya sekarang, proses sama seperti algo Euclid; Buat x1 positif; Fungsi untuk mengira ungkapan di atas; Memulakan hasilnya; Hitung bahagian pertama ungkapan; Kirakan bahagian kedua ungkapan i. e. , ((4 ^ (n + 1) - 1) / 3) Mod 10 Sejak pembahagian 3 dalam modulo boleh dilakukan secara langsung. Kod pemacu", "code": "< ? php function powermod ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( ( $ y & 1 ) > 0 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function modInverse ( $ a , $ m ) { $ m0 = $ m ; $ x0 = 0 ; $ x1 = 1 ; if ( $ m == 1 ) return 0 ; while ( $ a > 1 ) { $ q = ( int ) ( $ a / $ m ) ; $ t = $ m ; $ m = $ a % $ m ; $ a = $ t ; $ t = $ x0 ; $ x0 = $ x1 - $ q * $ x0 ; $ x1 = $ t ; } if ( $ x1 < 0 ) $ x1 += $ m0 ; return $ x1 ; } function evaluteExpression ( $ n ) { $ firstsum = 0 ; $ mod = 10 ; for ( $ i = 2 , $ j = 0 ; ( 1 << $ j ) <= $ n ; $ i *= $ i , ++ $ j ) $ firstsum = ( $ firstsum + $ i ) % $ mod ; $ secondsum = ( powermod ( 4 , $ n + 1 , $ mod ) - 1 ) * modInverse ( 3 , $ mod ) ; return ( $ firstsum * $ secondsum ) % $ mod ; } $ n = 3 ; echo evaluteExpression ( $ n ) . \" STRNEWLINE \" ; $ n = 10 ; echo evaluteExpression ( $ n ) ; ? >"}
{"text": "Mencari Kuasa Nombor Perdana P dalam N! | Mengembalikan kuasa P dalam N! ; memulakan jawapan; memulakan; gelung sehingga temp <= n; Tambah bilangan nombor yang boleh dibahagikan dengan n; Setiap kali melipatgandakan temp oleh p; Fungsi pemacu", "code": "< ? php function PowerOFPINnfactorial ( $ n , $ p ) { $ ans = 0 ; $ temp = $ p ; while ( $ temp <= $ n ) { $ ans += $ n / $ temp ; $ temp = $ temp * $ p ; } return $ ans ; } echo PowerOFPINnfactorial ( 4 , 2 ) . \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk binari untuk penukaran perpuluhan | Berfungsi untuk menukar binari ke perpuluhan; Inisialisasi nilai asas kepada 1, i. e 2 ^ 0; Kod pemacu", "code": "< ? php function binaryToDecimal ( $ n ) { $ num = $ n ; $ dec_value = 0 ; $ base = 1 ; $ temp = $ num ; while ( $ temp ) { $ last_digit = $ temp % 10 ; $ temp = $ temp / 10 ; $ dec_value += $ last_digit * $ base ; $ base = $ base * 2 ; } return $ dec_value ; } $ num = 10101001 ; echo binaryToDecimal ( $ num ) , \" STRNEWLINE \" ; ? >"}
{"text": "Mengira Factorials Menggunakan Penghampiran Stirling | Fungsi untuk mengira faktorial; nilai semulajadi e; menilai faktorial menggunakan penghampiran stirling; Kod pemacu", "code": "< ? php function stirlingFactorial ( $ n ) { if ( $ n == 1 ) return 1 ; $ z ; $ e = 2.71 ; $ z = sqrt ( 2 * 3.14 * $ n ) * pow ( ( $ n / $ e ) , $ n ) ; return floor ( $ z ) ; } echo stirlingFactorial ( 1 ) , \" STRNEWLINE \" ; echo stirlingFactorial ( 2 ) , \" STRNEWLINE \" ; echo stirlingFactorial ( 3 ) , \" STRNEWLINE \" ; echo stirlingFactorial ( 4 ) , \" STRNEWLINE \" ; echo stirlingFactorial ( 5 ) , \" STRNEWLINE \" ; echo stirlingFactorial ( 6 ) , \" ▁ STRNEWLINE \" ; echo stirlingFactorial ( 7 ) , \" ▁ STRNEWLINE \" ; ? >"}
{"text": "Kira pasangan dengan XOR ganjil | Fungsi akan mengembalikan bilangan pasangan yang XOR adalah ganjil; Untuk menyimpan kiraan ganjil dan bahkan nombor; Meningkatkan walaupun bilangannya juga meningkat ganjil; Pulangan bilangan pasangan; Kod pemacu", "code": "< ? php function countXorPair ( $ arr , $ n ) { $ odd = 0 ; $ even = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % 2 == 0 ) $ even ++ ; else $ odd ++ ; } return $ odd * $ even ; } $ arr = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; echo countXorPair ( $ arr , $ n ) ; ? >"}
{"text": "Pelaksanaan Nombor Lychrel | Maksimum maksimum; Berfungsi untuk memeriksa sama ada nombor adalah nombor lychrel; Berfungsi untuk memeriksa sama ada nombor itu adalah palindrome; Berfungsi untuk membalikkan nombor; Kod pemacu", "code": "< ? php $ MAX_ITERATIONS = 20 ; function isLychrel ( $ number ) { global $ MAX_ITERATIONS ; for ( $ i = 0 ; $ i < $ MAX_ITERATIONS ; $ i ++ ) { $ number = $ number + reverse ( $ number ) ; if ( isPalindrome ( $ number ) ) return \" false \" ; } return \" true \" ; } function isPalindrome ( $ number ) { return $ number == reverse ( $ number ) ; } function reverse ( $ number ) { $ reverse = 0 ; while ( $ number > 0 ) { $ remainder = $ number % 10 ; $ reverse = ( $ reverse * 10 ) + $ remainder ; $ number = ( int ) ( $ number / 10 ) ; } return $ reverse ; } $ number = 295 ; echo $ number . \" ▁ is ▁ lychrel ? ▁ \" . isLychrel ( $ number ) ; ? >"}
{"text": "Nombor Rectangular (atau Pronic) | Mengembalikan nombor segi empat tepat n; Kod pemacu", "code": "< ? php function findRectNum ( $ n ) { return $ n * ( $ n + 1 ) ; } $ n = 6 ; echo findRectNum ( $ n ) ; ? >"}
{"text": "Program untuk kaedah Muller | Program PHP untuk mencari akar fungsi, f (x); Fungsi untuk mengira f (x); Mengambil f (x) = x ^ 3 + 2 x ^ 2 + 10 x - 20; Mengira pelbagai pemalar yang diperlukan untuk mengira x3; Mengambil akar yang lebih dekat dengan x2; Memeriksa persamaan x3 dengan x2 hingga dua tempat perpuluhan; Fungsi utama pemandu", "code": "< ? php $ MAX_ITERATIONS = 10000 ; function f ( $ x ) { return 1 * pow ( $ x , 3 ) + 2 * $ x * $ x + 10 * $ x - 20 ; } function Muller ( $ a , $ b , $ c ) { global $ MAX_ITERATIONS ; $ res = 0 ; for ( $ i = 0 ; ; ++ $ i ) { $ f1 = f ( $ a ) ; $ f2 = f ( $ b ) ; $ f3 = f ( $ c ) ; $ d1 = $ f1 - $ f3 ; $ d2 = $ f2 - $ f3 ; $ h1 = $ a - $ c ; $ h2 = $ b - $ c ; $ a0 = $ f3 ; $ a1 = ( ( ( $ d2 * pow ( $ h1 , 2 ) ) - ( $ d1 * pow ( $ h2 , 2 ) ) ) / ( ( $ h1 * $ h2 ) * ( $ h1 - $ h2 ) ) ) ; $ a2 = ( ( ( $ d1 * $ h2 ) - ( $ d2 * $ h1 ) ) / ( ( $ h1 * $ h2 ) * ( $ h1 - $ h2 ) ) ) ; $ x = ( ( -2 * $ a0 ) / ( $ a1 + abs ( sqrt ( $ a1 * $ a1 - 4 * $ a0 * $ a2 ) ) ) ) ; $ y = ( ( -2 * $ a0 ) / ( $ a1 - abs ( sqrt ( $ a1 * $ a1 - 4 * $ a0 * $ a2 ) ) ) ) ; if ( $ x >= $ y ) $ res = $ x + $ c ; else $ res = $ y + $ c ; $ m = $ res * 100 ; $ n = $ c * 100 ; $ m = floor ( $ m ) ; $ n = floor ( $ n ) ; if ( $ m == $ n ) break ; $ a = $ b ; $ b = $ c ; $ c = $ res ; if ( $ i > $ MAX_ITERATIONS ) { echo \" Root ▁ cannot ▁ be ▁ found ▁ using ▁ Muller ' s ▁ method \" ; break ; } } if ( $ i <= $ MAX_ITERATIONS ) echo \" The ▁ value ▁ of ▁ the ▁ root ▁ is ▁ \" . round ( $ res , 4 ) ; } $ a = 0 ; $ b = 1 ; $ c = 2 ; Muller ( $ a , $ b , $ c ) ; ? >"}
{"text": "Fungsi Euler Totient yang Dioptimumkan Untuk Pelbagai Penilaian | Program PHP untuk mengira nilai -nilai Euler Totient dengan cekap untuk pelbagai input. ; Menyimpan nombor perdana sehingga max - 1 nilai; Cari nombor utama sehingga max - 1 dan menyimpannya dalam vektor p; Jika Perdana [i] tidak ditandakan sebelum ini; Isi vektor untuk setiap perdana yang baru ditemui; Jalankan gelung ini hingga akar persegi max, tandakan indeks i * j sebagai bukan perdana; fungsi untuk mencari nada n; Gelung ini berjalan sqrt (n / ln (n)) kali; tolak gandaan p [i] dari r; Keluarkan semua kejadian p [i] dalam n; apabila n mempunyai faktor utama yang lebih besar daripada sqrt (n); Preprocess Semua Nombor Perdana sehingga 10 ^ 5", "code": "< ? php $ MAX = 100001 ; $ p = array ( ) ; function sieve ( ) { global $ MAX , $ p ; $ isPrime = array_fill ( 0 , $ MAX + 1 , 0 ) ; for ( $ i = 2 ; $ i <= $ MAX ; $ i ++ ) { if ( $ isPrime [ $ i ] == 0 ) { array_push ( $ p , $ i ) ; for ( $ j = 2 ; $ i * $ j <= $ MAX ; $ j ++ ) $ isPrime [ $ i * $ j ] = 1 ; } } } function phi ( $ n ) { global $ p ; $ res = $ n ; for ( $ i = 0 ; $ p [ $ i ] * $ p [ $ i ] <= $ n ; $ i ++ ) { if ( $ n % $ p [ $ i ] == 0 ) { $ res -= ( int ) ( $ res / $ p [ $ i ] ) ; while ( $ n % $ p [ $ i ] == 0 ) $ n = ( int ) ( $ n / $ p [ $ i ] ) ; } } if ( $ n > 1 ) $ res -= ( int ) ( $ res / $ n ) ; return $ res ; } sieve ( ) ; print ( phi ( 11 ) . \" STRNEWLINE \" ) ; print ( phi ( 21 ) . \" STRNEWLINE \" ) ; print ( phi ( 31 ) . \" STRNEWLINE \" ) ; print ( phi ( 41 ) . \" STRNEWLINE \" ) ; print ( phi ( 51 ) . \" STRNEWLINE \" ) ; print ( phi ( 61 ) . \" STRNEWLINE \" ) ; print ( phi ( 91 ) . \" STRNEWLINE \" ) ; print ( phi ( 101 ) . \" STRNEWLINE \" ) ; ? >"}
{"text": "Mencari n | Cetak N - TH Nombor di mana setiap digit adalah nombor utama; Mencari panjang nombor n - th; Kiraan nombor dengan len - 1 digit; Kiraan nombor dengan saya digit; jika saya adalah panjang nombor tersebut maka n <4 * (4 ^ (i - 1) - 1) / 3 dan n> = 4 * (4 ^ i - 1) / 3 jika sah saya dijumpai memecahkan gelung; Semak i + 1; Mencari digit di tempat itu; j = 1 bermaksud 2 j = 2 bermaksud ... j = 4 bermaksud 7; jika prev_count + 4 ^ (len - i) kurang daripada n, tambah prev_count oleh 4 ^ (x - i); lain mencetak digit ith dan pecah; Kod pemacu", "code": "< ? php function nthprimedigitsnumber ( $ n ) { $ len = 1 ; $ prev_count = 0 ; while ( true ) { $ curr_count = $ prev_count + pow ( 4 , $ len ) ; if ( $ prev_count < $ n && $ curr_count >= $ n ) break ; $ len ++ ; $ prev_count = $ curr_count ; } for ( $ i = 1 ; $ i <= $ len ; $ i ++ ) { for ( $ j = 1 ; $ j <= 4 ; $ j ++ ) { if ( $ prev_count + pow ( 4 , $ len - $ i ) < $ n ) $ prev_count += pow ( 4 , $ len - $ i ) ; else { if ( $ j == 1 ) echo \"2\" ; else if ( $ j == 2 ) echo \"3\" ; else if ( $ j == 3 ) echo \"5\" ; else if ( $ j == 4 ) echo \"7\" ; break ; } } } echo \" STRNEWLINE \" ; } nthprimedigitsnumber ( 10 ) ; nthprimedigitsnumber ( 21 ) ; ? >"}
{"text": "Identiti Cassini | Pulangan ( - 1) ^ n; Kod pemacu", "code": "< ? php function cassini ( $ n ) { return ( $ n & 1 ) ? -1 : 1 ; } $ n = 5 ; echo ( cassini ( $ n ) ) ; ? >"}
{"text": "Cari jika nombor boleh dibahagikan dengan setiap nombor dalam senarai | Fungsi yang cek adalah nombor yang dibahagikan dengan setiap elemen dalam senarai atau tidak; Kod pemacu", "code": "< ? php function findNoIsDivisibleOrNot ( $ a , $ n , $ l ) { for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ a [ $ i ] % $ n != 0 ) return false ; } return true ; } $ a = array ( 14 , 12 , 4 , 18 ) ; $ n = 2 ; $ l = sizeof ( $ a ) ; if ( findNoIsDivisibleOrNot ( $ a , $ n , $ l ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cari pelbagai nombor komposit panjang yang diberikan | kaedah untuk mencari faktorial nombor yang diberikan; untuk mencetak julat panjang n mempunyai semua bilangan bulat komposit; Kod pemacu", "code": "< ? php function factorial ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * factorial ( $ n - 1 ) ; } function printRange ( $ n ) { $ a = factorial ( $ n + 2 ) + 2 ; $ b = $ a + $ n - 1 ; echo \" [ \" , $ a , \" , ▁ \" , $ b , \" ] \" ; return 0 ; } $ n = 3 ; printRange ( $ n ) ; ? >"}
{"text": "Cari nilai minimum untuk menetapkan semua elemen array supaya produk array menjadi lebih besar | Program PHP untuk mencari nilai minimum yang boleh diberikan kepada semua elemen supaya produk menjadi lebih besar daripada produk semasa. ; Susun array untuk memohon carian binari; Menggunakan harta log Tambah setiap nilai logaritma elemen ke val $ val = 0; di mana LD adalah dua kali ganda; Tetapkan kaki kiri dan kanan untuk mencari nilai min; Mengalikan N hingga pertengahan, untuk mencari nilai min yang betul; Kod pemacu", "code": "< ? php function findMinValue ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ val += ( log ( $ arr [ $ i ] ) ) ; $ left = $ arr [ 0 ] ; $ right = $ arr [ $ n - 1 ] + 1 ; $ ans = 0 ; while ( $ left <= $ right ) { $ mid = ( int ) ( $ left + $ right ) / 2 ; $ temp = $ n * ( log ( $ mid ) ) ; if ( $ val < $ temp ) { $ ans = $ mid ; $ right = $ mid - 1 ; } else $ left = $ mid + 1 ; } return ( floor ( $ ans ) ) ; } $ arr = array ( 4 , 2 , 1 , 10 , 6 ) ; $ n = sizeof ( $ arr ) ; echo findMinValue ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari jumlah semua terma dalam n | fungsi untuk mencari jumlah yang diperlukan; sum = n * (2 * n ^ 2 + 1); Kod pemacu", "code": "< ? php function sumOfTermsInNthRow ( $ n ) { $ sum = $ n * ( 2 * pow ( $ n , 2 ) + 1 ) ; return $ sum ; } $ n = 4 ; echo \" Sum ▁ of ▁ all ▁ the ▁ terms ▁ in ▁ nth ▁ row ▁ = ▁ \" , sumOfTermsInNthRow ( $ n ) ; ? >"}
{"text": "Digit pertama dalam produk pelbagai nombor | Pelaksanaan PHP untuk mencari digit pertama nombor tunggal; Terus membahagikan 10 sehingga ia lebih besar daripada sama dengan 10; Kod pemacu", "code": "< ? php function firstDigit ( $ x ) { while ( $ x >= 10 ) $ x = $ x / 10 ; return floor ( $ x ) ; } echo firstDigit ( 12345 ) , \" STRNEWLINE \" ; echo firstDigit ( 5432 ) ; ? >"}
{"text": "Cari kejadian digit D dalam julat [0 .. n] | Program PHP untuk mengira penampilan 'D' dalam julat dari [0 .. n]; Memulakan hasil; Kira penampilan dalam jumlah bermula dari d. ; Apabila digit terakhir adalah sama dengan D; Apabila digit pertama adalah sama dengan D kemudian; hasil kenaikan serta bilangan; Sekiranya terbalik bilangan seperti 12 dan 21; Kod pemacu", "code": "< ? php function getOccurence ( $ n , $ d ) { $ result = 0 ; $ itr = $ d ; while ( $ itr <= $ n ) { if ( $ itr % 10 == $ d ) $ result ++ ; if ( $ itr != 0 && floor ( $ itr / 10 ) == $ d ) { $ result ++ ; $ itr ++ ; } else if ( floor ( $ itr / 10 ) == $ d - 1 ) $ itr = $ itr + ( 10 - $ d ) ; else $ itr = $ itr + 10 ; } return $ result ; } $ n = 11 ; $ d = 1 ; echo getOccurence ( $ n , $ d ) ; ? >"}
{"text": "Program untuk mengira nilai dosa (x) dan cos (x) menggunakan pengembangan | Fungsi untuk pengiraan; Menukar darjah kepada Radian; peta jumlah sepanjang siri; memegang nilai sebenar dosa (n); Kod pemacu", "code": "< ? php function cal_cos ( $ n ) { $ accuracy = 0.0001 ; $ n = $ n * ( 3.142 / 180.0 ) ; $ x1 = 1 ; $ cosx = $ x1 ; $ cosval = cos ( $ n ) ; $ i = 1 ; do { $ denominator = 2 * $ i * ( 2 * $ i - 1 ) ; $ x1 = - $ x1 * $ n * $ n / $ denominator ; $ cosx = $ cosx + $ x1 ; $ i = $ i + 1 ; } while ( $ accuracy <= abs ( $ cosval - $ cosx ) ) ; echo round ( $ cosx , 6 ) ; } $ n = 30 ; cal_cos ( $ n ) ; ? >"}
{"text": "Cari jumlah digit dalam faktorial nombor | Berfungsi untuk membiak x dengan bilangan besar yang disimpan dalam vektor v. Keputusan disimpan dalam v. ; Kirakan res + prev membawa; Kemas kini di kedudukan ith; Mengembalikan jumlah digit dalam N! ; Satu demi satu membiak saya ke vektor semasa dan mengemas kini vektor. ; Cari jumlah digit dalam vektor v []; Kod pemacu", "code": "< ? php function multiply ( & $ v , $ x ) { $ carry = 0 ; $ size = count ( $ v ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ res = $ carry + $ v [ $ i ] * $ x ; $ v [ $ i ] = $ res % 10 ; $ carry = ( int ) ( $ res / 10 ) ; } while ( $ carry != 0 ) { array_push ( $ v , $ carry % 10 ) ; $ carry = ( int ) ( $ carry / 10 ) ; } } function findSumOfDigits ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) multiply ( $ v , $ i ) ; $ sum = 0 ; $ size = count ( $ v ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) $ sum += $ v [ $ i ] ; return $ sum ; } $ n = 1000 ; print ( findSumOfDigits ( $ n ) ) ; ? >"}
{"text": "Cari dua sisi segitiga sudut kanan | Cari dua sisi segitiga sudut kanan jika ia wujud. ; jika n adalah ganjil; kes n = 1 dikendalikan secara berasingan; kes n = 2 dikendalikan secara berasingan; Kod pemacu", "code": "< ? php function printOtherSides ( $ n ) { if ( $ n & 1 ) { if ( $ n == 1 ) echo - 1 ; else { $ b = ( $ n * $ n - 1 ) / 2 ; $ c = ( $ n * $ n + 1 ) / 2 ; echo \" b ▁ = ▁ \" , $ b , \" , ▁ c ▁ = ▁ \" , $ c ; } } else { if ( $ n == 2 ) echo - 1 ; else { $ b = $ n * $ n / 4 - 1 ; $ c = $ n * $ n / 4 + 1 ; echo \" b ▁ = ▁ \" , $ b , \" , ▁ c ▁ = ▁ \" , $ c ; } } } $ a = 3 ; printOtherSides ( $ a ) ; return 0 ; ? >"}
{"text": "Integer positif minimum untuk membahagikan nombor supaya hasilnya adalah ganjil | Program PHP untuk membuat nombor ganjil; Kembali 1 jika sudah ganjil; Semak membahagikan dengan nombor apabila hasilnya menjadi pulangan ganjil nombor itu; Jika n dibahagikan dengan i dan n / i adalah ganjil maka kembali i; Kod pemacu", "code": "< ? php function makeOdd ( $ n ) { if ( $ n % 2 != 0 ) return 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) if ( ( $ n % $ i == 0 ) && ( ( $ n / $ i ) % 2 == 1 ) ) return $ i ; } $ n = 36 ; echo makeOdd ( $ n ) ; ? >"}
{"text": "XOR Semua Subarray Xors | Tetapkan 2 | Mengembalikan xor semua subarray xors; Sekiranya bilangan istilah ada di sana, semua nombor akan muncul walaupun bilangan kali. Jadi hasilnya ialah 0.; lain memulakan hasil oleh 0 sebagai (A XOR 0 = A); Kod pemacu", "code": "< ? php function getTotalXorOfSubarrayXors ( $ arr , $ N ) { if ( $ N % 2 == 0 ) return 0 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i += 2 ) $ res ^= $ arr [ $ i ] ; return $ res ; } $ arr = array ( 3 , 5 , 2 , 4 , 6 ) ; $ N = count ( $ arr ) ; echo getTotalXorOfSubarrayXors ( $ arr , $ N ) ; ? >"}
{"text": "Isi array dengan 1 menggunakan lelaran minimum pengisian jiran | Mengembalikan kiraan lelaran untuk mengisi ARR [] dengan 1 s. ; Mula melintasi array; Melintasi sehingga 0 dijumpai; Mengira bersebelahan 0 s; Keadaan untuk kes 3; Keadaan untuk memeriksa sama ada kes 1 memenuhi :; Jika count_zero juga; Jika count_zero ganjil; Menetapkan semula count_zero; Kes 2; Kemas kini res; Kod pemacu", "code": "< ? php function countIterations ( $ arr , $ n ) { $ oneFound = false ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; ) { if ( $ arr [ $ i ] == 1 ) $ oneFound = true ; while ( $ i < $ n && $ arr [ $ i ] == 1 ) $ i ++ ; $ count_zero = 0 ; while ( $ i < $ n && $ arr [ $ i ] == 0 ) { $ count_zero ++ ; $ i ++ ; } if ( $ oneFound == false && $ i == $ n ) return -1 ; $ curr_count ; if ( $ i < $ n && $ oneFound == true ) { if ( $ count_zero & 1 == 0 ) $ curr_count = $ count_zero / 2 ; else $ curr_count = ( $ count_zero + 1 ) / 2 ; $ count_zero = 0 ; } else { $ curr_count = $ count_zero ; $ count_zero = 0 ; } $ res = max ( $ res , $ curr_count ) ; } return $ res ; } $ arr = array ( 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo countIterations ( $ arr , $ n ) ; ? >"}
{"text": "Ekspreskan nombor sebagai jumlah nombor berturut -turut | Cetak nombor berturut -turut dari yang terakhir hingga pertama; Kod pemacu", "code": "< ? php function printConsecutive ( $ last , $ first ) { echo $ first ++ ; for ( $ x = $ first ; $ x <= $ last ; $ x ++ ) echo \" + \" } function findConsecutive ( $ N ) { for ( $ last = 1 ; $ last < $ N ; $ last ++ ) { for ( $ first = 0 ; $ first < $ last ; $ first ++ ) { if ( 2 * $ N == ( $ last - $ first ) * ( $ last + $ first + 1 ) ) { echo $ N , \" ▁ = ▁ \" ; printConsecutive ( $ last , $ first + 1 ) ; return ; } } } echo \" - 1\" ; } $ n = 12 ; findConsecutive ( $ n ) ; ? >"}
{"text": "Cari n | Kembali nombor n - th dalam siri yang diperbuat daripada 4 dan 7; Buat pelbagai saiz (n + 1); Sekiranya saya ganjil; Kod pemacu", "code": "< ? php function printNthElement ( $ n ) { $ arr [ 1 ] = 4 ; $ arr [ 2 ] = 7 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 != 0 ) $ arr [ $ i ] = $ arr [ $ i / 2 ] * 10 + 4 ; else $ arr [ $ i ] = $ arr [ ( $ i / 2 ) - 1 ] * 10 + 7 ; } return $ arr [ $ n ] ; } $ n = 6 ; echo ( printNthElement ( $ n ) ) ; ? >"}
{"text": "Jumlah maksimum nombor yang berbeza seperti LCM nombor -nombor ini adalah n | Mengembalikan jumlah maksimum nombor dengan LCM sebagai n; Memulakan hasil; Mencari pembahagi n dan menambahkannya ke max_sum; Kod pemacu", "code": "< ? php function maxSumLCM ( $ n ) { $ max_sum = 0 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ max_sum += $ i ; if ( $ n / $ i != $ i ) $ max_sum += ( $ n / $ i ) ; } } return $ max_sum ; } $ n = 2 ; echo MaxSumLCM ( $ n ) ; ? >"}
{"text": "Akar persegi nombor menggunakan log | Program PHP untuk menunjukkan mencari akar kuadrat nombor menggunakan sqrt ()", "code": "< ? php $ n = 12 ; echo sqrt ( $ n ) ; ? >"}
{"text": "Nilai maksimum integer yang faktorial boleh dikira pada mesin | Program PHP untuk mencari nilai maksimum integer yang faktorial boleh dikira pada sistem anda; Apabila fakta melintasi saiznya, ia memberikan nilai negatif; Kod pemacu", "code": "< ? php function findMaxValue ( ) { $ res = 2 ; $ fact = 2 ; $ pos = -1 ; while ( true ) { $ mystring = $ fact ; $ pos = strpos ( $ mystring , ' E ' ) ; if ( $ pos > 0 ) break ; $ res ++ ; $ fact = $ fact * $ res ; } return $ res - 1 ; } echo \" Maximum ▁ value ▁ of \" . \" ▁ integer ▁ \" . findMaxValue ( ) ; ? >"}
{"text": "Semak jika LCM unsur array boleh dibahagikan dengan nombor utama atau tidak | Fungsi untuk memeriksa bilangan array yang boleh dibahagikan dengan k atau tidak; Jika mana -mana elemen array boleh dibahagikan dengan k, maka LCM keseluruhan array juga harus dibahagikan. ; Kod pemacu", "code": "< ? php function func ( $ a , $ k , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] % $ k == 0 ) return true ; return false ; } $ a = array ( 14 , 27 , 38 , 76 , 84 ) ; $ k = 19 ; $ res = func ( $ a , $ k , 5 ) ; if ( $ res ) echo \" true \" ; else echo \" false \" ; ? >"}
{"text": "Cari nombor rapi yang paling dekat dan lebih kecil | Program PHP untuk mencari nombor rapi yang paling kecil daripada nombor yang diberikan; Semak sama ada rentetan melanggar harta yang kemas; Jika rentetan melanggar harta yang kemas, kemudian mengurangkan nilai yang disimpan pada indeks itu dengan 1 dan gantikan semua nilai yang disimpan hak ke indeks tersebut dengan 9; Kod pemacu; Num akan menyimpan nombor kemas yang paling dekat", "code": "< ? php function tidyNum ( $ str , $ len ) { for ( $ i = $ len - 2 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] > $ str [ $ i + 1 ] ) { $ x = ord ( $ str [ $ i ] ) ; $ x -- ; $ str [ $ i ] = chr ( $ x ) ; for ( $ j = $ i + 1 ; $ j < $ len ; $ j ++ ) $ str [ $ j ] = '9' ; } } return $ str ; } $ str = \"11333445538\" ; $ len = strlen ( $ str ) ; $ num = tidyNum ( $ str , $ len ) ; echo $ num ; ? >"}
{"text": "Count of M digit integer yang boleh dibahagikan dengan integer n | Mengembalikan kiraan nombor digit yang mempunyai n sebagai pembahagi; menjana bilangan terbesar M digit; menjana bilangan terbesar M - 1 digit; mengembalikan bilangan dividen; Kod pemacu", "code": "< ? php function findCount ( $ m , $ n ) { $ num1 = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ num1 = ( $ num1 * 10 ) + 9 ; $ num2 = 0 ; for ( $ i = 0 ; $ i < ( $ m - 1 ) ; $ i ++ ) $ num2 = ( $ num2 * 10 ) + 9 ; return ( ( $ num1 / $ n ) - ( $ num2 / $ n ) ) ; } $ m = 2 ; $ n = 6 ; echo findCount ( $ m , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari n | fungsi untuk mengira nombor nth yang diperbuat daripada digit sahaja; Pembolehubah untuk perhatikan berapa banyak nombor sedemikian telah dijumpai sehingga sekarang; Pembolehubah bool untuk memeriksa sama ada 1, 3, 5, 7, 9 ada atau tidak; memeriksa setiap digit nombor; Jika 1, 3, 5, 7, 9 didapati temp ditukar kepada palsu; Temp adalah benar ia bermakna bahawa ia tidak mempunyai 1, 3, 5, 7, 9; Jika nombor tersebut didapati mengembalikannya; Kod pemacu", "code": "< ? php function findNthEvenDigitNumber ( $ n ) { $ count = 0 ; for ( $ i = 0 ; ; $ i ++ ) { $ curr = $ i ; $ isCurrEvenDigit = true ; while ( $ curr != 0 ) { if ( $ curr % 10 == 1 $ curr % 10 == 3 $ curr % 10 == 5 $ curr % 10 == 7 $ curr % 10 == 9 ) $ isCurrEvenDigit = false ; $ curr = $ curr / 10 ; } if ( $ isCurrEvenDigit == true ) $ count ++ ; if ( $ count == $ n ) return $ i ; } } echo findNthEvenDigitNumber ( 2 ) , \" STRNEWLINE \" ; echo findNthEvenDigitNumber ( 10 ) ; ? >"}
{"text": "Cari n | berfungsi untuk mencari nombor nth yang diperbuat daripada digit walaupun sahaja; Jika n = 1 kembali 0; vektor untuk menyimpan digit apabila ditukar menjadi asas 5; Kurangkan N ke N - 1 untuk mengecualikan 0; Kurangkan N ke Base 5 nombor dan angka kedai; menolak digit ke dalam vektor; pembolehubah untuk mewakili nombor selepas menukarnya ke pangkalan 5. Oleh kerana digit berada dalam urutan terbalik, kami melintasi vektor dari belakang; Kembali 2 * Hasil (untuk menukar digit 0, 1, 2, 3, 4 hingga 0, 2, 4, 6, 8.; Kod Pemandu", "code": "< ? php function findNthEvenDigitNumber ( $ n ) { if ( $ n == 1 ) return 0 ; $ v = array ( ) ; $ n = $ n - 1 ; while ( $ n > 0 ) { array_push ( $ v , $ n % 5 ) ; $ n = ( int ) ( $ n / 5 ) ; } $ result = 0 ; for ( $ i = count ( $ v ) - 1 ; $ i >= 0 ; $ i -- ) { $ result = $ result * 10 ; $ result = $ result + $ v [ $ i ] ; } return 2 * $ result ; } echo findNthEvenDigitNumber ( 2 ) . \" STRNEWLINE \" ; echo findNthEvenDigitNumber ( 10 ) . \" STRNEWLINE \" ? >"}
{"text": "Semak jika sebilangan besar boleh dibahagikan dengan 25 atau tidak | Berfungsi untuk mencari nombor yang boleh dibahagikan dengan 25 atau tidak. ; Jika panjang rentetan adalah satu digit maka ia tidak boleh dibahagikan dengan 25; Kod pemacu", "code": "< ? php function isDivisibleBy25 ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 1 ) return false ; return ( ( $ str [ $ n - 1 ] - '0' == 0 && $ str [ $ n - 2 ] - '0' == 0 ) || ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 25 == 0 ) ; } $ str = \"76955\" ; $ x = isDivisibleBy25 ( $ str ) ? \" Yes \" : \" No ▁ \" ; echo ( $ x ) ; ? >"}
{"text": "Semak sebilangan besar boleh dibahagikan dengan 16 atau tidak | Berfungsi untuk mencari nombor yang boleh dibahagikan dengan 16 atau tidak; Rentetan kosong; Sekiranya terdapat dua digit; Sekiranya terdapat digit tiga; Jika nombor yang dibentuk oleh empat digit terakhir boleh dibahagikan dengan 16 .; Kod pemacu", "code": "< ? php function check ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 0 && $ n == 1 ) return false ; if ( $ n == 2 ) return ( ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 16 == 0 ) ; if ( $ n == 3 ) return ( ( ( $ str [ $ n - 3 ] - '0' ) * 100 + ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 16 == 0 ) ; $ last = $ str [ $ n - 1 ] - '0' ; $ second_last = $ str [ $ n - 2 ] - '0' ; $ third_last = $ str [ $ n - 3 ] - '0' ; $ fourth_last = $ str [ $ n - 4 ] - '0' ; return ( ( $ fourth_last * 1000 + $ third_last * 100 + $ second_last * 10 + $ last ) % 16 == 0 ) ; } $ str = \"769528\" ; $ x = check ( $ str ) ? \" Yes \" : \" No ▁ \" ; echo ( $ x ) ; ? >"}
{"text": "Cari Indeks Nombor Fibonacci yang diberikan dalam masa yang berterusan | Program PHP yang mudah untuk mencari indeks nombor Fibonacci yang diberikan. ; Jika nombor Fibonacci kurang daripada 2, indeksnya akan sama dengan nombor; ITERATE sehingga dihasilkan nombor Fibonacci kurang daripada yang diberikan nombor Fibonacci; Res menjejaki bilangan nombor Fibonacci yang dihasilkan; Kod pemacu", "code": "< ? php function findIndex ( $ n ) { if ( $ n <= 1 ) return $ n ; $ a = 0 ; $ b = 1 ; $ c = 1 ; $ res = 1 ; while ( $ c < $ n ) { $ c = $ a + $ b ; $ res ++ ; $ a = $ b ; $ b = $ c ; } return $ res ; } $ result = findIndex ( 21 ) ; echo ( $ result ) ; ? >"}
{"text": "Tentukan sama ada nombor tertentu adalah nombor hyperperfect | berfungsi untuk mencari jumlah semua pembahagi yang betul (tidak termasuk 1 dan n); Hanya berulang sehingga sqrt n kerana kita akan menjana pasangan untuk menghasilkan pembahagi; Apabila pembahagi berlaku secara berpasangan, kita boleh mengambil nilai -nilai i dan n / i selagi saya membahagikan n; Fungsi untuk memeriksa sama ada nombor yang diberikan adalah perdana; kes asas dan sudut; Oleh kerana bilangan bulat boleh diwakili sebagai 6 * k + y di mana y> = 0, kita boleh menghapuskan semua bilangan bulat yang boleh dinyatakan dalam bentuk ini; Mulakan dari 5 kerana ini adalah nombor perdana seterusnya; Pulangan benar jika n adalah nombor k - hyperperfect lain yang kembali palsu. ; Keadaan dari definisi hyperperfect; Kod pemacu; Ujian dua pernyataan pertama terhadap keadaan n = 1 + k * (jumlah (pembahagi yang betul))", "code": "< ? php function divisorSum ( $ N , $ K ) { $ sum = 0 ; for ( $ i = 2 ; $ i <= ceil ( sqrt ( $ N ) ) ; $ i ++ ) if ( $ N % $ i == 0 ) $ sum += ( $ i + $ N / $ i ) ; return $ sum ; } function isPrime ( $ n ) { if ( $ n == 1 $ n == 0 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function isHyperPerfect ( $ N , $ K ) { $ sum = divisorSum ( $ N , $ K ) ; if ( ( 1 + $ K * ( $ sum ) ) == $ N ) return true ; else return false ; } $ N1 = 1570153 ; $ K1 = 12 ; $ N2 = 321 ; $ K2 = 3 ; if ( isHyperPerfect ( $ N1 , $ K1 ) ) echo $ N1 , \" ▁ is ▁ \" , $ K1 , \" - HyperPerfect \" , \" STRNEWLINE \" ; else echo $ N1 , \" ▁ is ▁ not ▁ \" , $ K1 , \" - HyperPerfect \" , \" STRNEWLINE \" ; if ( isHyperPerfect ( $ N2 , $ K2 ) ) echo $ N2 , \" ▁ is ▁ \" , K2 , \" - HyperPerfect \" , \" STRNEWLINE \" ; else echo $ N2 , \" ▁ is ▁ not ▁ \" , $ K2 , \" - HyperPerfect \" , \" STRNEWLINE \" ; ? >"}
{"text": "Memandangkan nombor n, cari digit k pertama n ^ n | fungsi untuk mengira digit pertama n ^ n; Ambil log10 n ^ n. log10 (n ^ n) = n * log10 (n); Kami kini cuba memisahkan bahagian perpuluhan dan integral dari / produk. Fungsi lantai mengembalikan integer terkecil kurang daripada atau sama dengan hujah. Oleh itu, dalam kes ini, lantai produk (produk) akan memberi kita bahagian perpuluhan produk; Kami kini mengeksplorasi ini dengan menaikkan 10 ke dalam kuasa perpuluhan; Kami kini cuba mencari kuasa 10 yang mana kita perlu membiak bahagian perpuluhan untuk mendapatkan jawapan terakhir kami; Kod pemacu", "code": "< ? php function firstkdigits ( $ n , $ k ) { $ product = $ n * log10 ( $ n ) ; $ decimal_part = $ product - floor ( $ product ) ; $ decimal_part = pow ( 10 , $ decimal_part ) ; $ digits = pow ( 10 , $ k - 1 ) ; $ i = 0 ; return floor ( $ decimal_part * $ digits ) ; } $ n = 1450 ; $ k = 6 ; echo firstkdigits ( $ n , $ k ) ; ? >"}
{"text": "Menjana nombor digit k dengan digit dalam ketat yang semakin meningkat | Nombor -> Nilai Nombor Semasa. x -> digit semasa dianggap k -> bilangan digit yang tinggal; Cuba semua mungkin digit yang lebih besar; Menjana semua bilangan panjang yang diperintahkan dengan baik; Kod pemacu", "code": "< ? php function printWellOrdered ( $ number , $ x , $ k ) { if ( $ k == 0 ) { echo $ number , \" \" ; return ; } for ( $ i = ( $ x + 1 ) ; $ i < 10 ; $ i ++ ) printWellOrdered ( $ number * 10 + $ i , $ i , $ k - 1 ) ; } function generateWellOrdered ( $ k ) { printWellOrdered ( 0 , 0 , $ k ) ; } $ k = 3 ; generateWellOrdered ( $ k ) ; ? >"}
{"text": "Multiply integer besar di bawah modulo besar | Pulangan (a * b) % mod; Kemas kini A jika lebih daripada atau sama dengan MOD; Jika B adalah ganjil, tambahkan dengan hasil; Di sini kita mengandaikan bahawa melakukan 2 * A tidak menyebabkan limpahan; $ b >> = 1; B = B / 2; Kod pemacu", "code": "< ? php function moduloMultiplication ( $ a , $ b , $ mod ) { $ a %= $ mod ; while ( $ b ) { if ( $ b & 1 ) $ res = ( $ res + $ a ) % $ mod ; $ a = ( 2 * $ a ) % $ mod ; } return $ res ; } $ a = 10123465234878998 ; $ b = 65746311545646431 ; $ m = 10005412336548794 ; echo moduloMultiplication ( $ a , $ b , $ m ) ; ? >"}
{"text": "Bilangan kejadian 2 sebagai digit dalam nombor dari 0 hingga n | Mengira bilangan 2 s dalam nombor di D - tH angka; Jika digit di tempat digit adalah; Mengira bilangan digit '2' antara 0 dan n; Tukar integer ke rentetan untuk mencari panjangnya; Melintasi setiap digit dan dikira untuk setiap digit; Kod pemacu", "code": "< ? php function count2sinRangeAtDigit ( $ number , $ d ) { $ powerOf10 = ( int ) pow ( 10 , $ d ) ; $ nextPowerOf10 = $ powerOf10 * 10 ; $ right = $ number % $ powerOf10 ; $ roundDown = $ number - $ number % $ nextPowerOf10 ; $ roundup = $ roundDown + $ nextPowerOf10 ; $ digit = ( $ number / $ powerOf10 ) % 10 ; if ( $ digit < 2 ) return $ roundDown / 10 ; if ( $ digit == 2 ) return $ roundDown / 10 + $ right + 1 ; return $ roundup / 10 ; } function numberOf2sinRange ( $ number ) { $ s = strval ( $ number ) ; $ len = strlen ( $ s ) ; $ count = 0 ; for ( $ digit = 0 ; $ digit < $ len ; $ digit ++ ) $ count += count2sinRangeAtDigit ( $ number , $ digit ) ; return $ count ; } print ( numberOf2sinRange ( 22 ) . \" STRNEWLINE \" ) ; print ( numberOf2sinRange ( 100 ) . \" STRNEWLINE \" ) ; ? >"}
{"text": "Program untuk mencari nombor bintang | Mengembalikan nombor bintang n - ke; Kod pemacu", "code": "< ? php function findStarNum ( $ n ) { return ( 6 * $ n * ( $ n - 1 ) + 1 ) ; } $ n = 3 ; echo findStarNum ( $ n ) ; ? >"}
{"text": "Semak jika sebilangan besar boleh dibahagikan dengan 5 atau tidak | Berfungsi untuk mencari nombor yang boleh dibahagikan dengan 5 atau tidak. Fungsi ini mengandaikan bahawa panjang rentetan sekurang -kurangnya satu. ; Kod pemacu", "code": "< ? php function isDivisibleBy5 ( $ str ) { $ n = strlen ( $ str ) ; return ( ( ( $ str [ $ n - 1 ] - '0' ) == 0 ) || ( ( $ str [ $ n - 1 ] - '0' ) == 5 ) ) ; } $ str = \"76955\" ; $ x = isDivisibleBy5 ( $ str ) ? \" Yes \" : \" No \" ; echo ( $ x ) ; ? >"}
{"text": "Nombor kemas (digit dalam bukan | pulangan benar jika num rapi; untuk menyimpan digit sebelumnya (memberikan nilai awal yang lebih daripada mana -mana digit); melintasi semua digit dari kanan ke kiri dan periksa sama ada angka lebih kecil daripada sebelumnya.", "code": "< ? php function isTidy ( $ num ) { $ prev = 10 ; while ( $ num ) { $ rem = $ num % 10 ; $ num = ( int ) $ num / 10 ; if ( $ rem > $ prev ) return false ; $ prev = $ rem ; } return true ; } $ num = 1556 ; if ( isTidy ( $ num ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Nth Square Free Number | Berfungsi untuk mencari nombor percuma nth persegi; Untuk mengekalkan kiraan nombor bebas persegi; Gelung untuk nombor percuma persegi; Memeriksa sama ada persegi nombor boleh dibahagikan dengan mana -mana nombor yang merupakan persegi yang sempurna; Jika nombor adalah persegi percuma; Jika CNT menjadi n, kembalikan nombor; Kod pemacu", "code": "< ? php function squareFree ( $ n ) { $ cnt = 0 ; for ( $ i = 1 ; ; $ i ++ ) { $ isSqFree = true ; for ( $ j = 2 ; $ j * $ j <= $ i ; $ j ++ ) { if ( $ i % ( $ j * $ j ) == 0 ) { $ isSqFree = false ; break ; } } if ( $ isSqFree == true ) { $ cnt ++ ; if ( $ cnt == $ n ) return $ i ; } } return 0 ; } $ n = 10 ; echo ( squareFree ( $ n ) ) ; ? >"}
{"text": "Cari jika n boleh ditulis sebagai produk nombor k | Cetak K Faktor N Jika n boleh ditulis sebagai pelbagai nombor k. Cetakan lain - 1 .; Vektor untuk menyimpan semua faktor utama n; Masukkan semua 2 dalam vektor; n mesti ganjil pada ketika ini supaya kita melangkau satu elemen (i = i + 2); Ini adalah untuk mengendalikan apabila n> 2 dan n adalah perdana; Jika saiz (p) <k, k faktor tidak mungkin; Percetakan pertama k - 1 faktor; mengira dan mencetak produk bilangan bilangan; Kod pemacu", "code": "< ? php function kFactors ( $ n , $ k ) { $ P = array ( ) ; while ( $ n % 2 == 0 ) { array_push ( $ P , 2 ) ; $ n = ( int ) ( $ n / 2 ) ; } for ( $ i = 3 ; $ i * $ i <= $ n ; $ i = $ i + 2 ) { while ( $ n % $ i == 0 ) { $ n = ( int ) ( $ n / $ i ) ; array_push ( $ P , $ i ) ; } } if ( $ n > 2 ) array_push ( $ P , $ n ) ; if ( count ( $ P ) < $ k ) { echo \" - 1 STRNEWLINE \" ; return ; } for ( $ i = 0 ; $ i < $ k - 1 ; $ i ++ ) echo $ P [ $ i ] . \" , \" $ product = 1 ; for ( $ i = $ k - 1 ; $ i < count ( $ P ) ; $ i ++ ) $ product = $ product * $ P [ $ i ] ; echo $ product ; } $ n = 54 ; $ k = 3 ; kFactors ( $ n , $ k ) ; ? >"}
{"text": "Nombor terbesar lebih kecil daripada atau sama dengan N dan digit dalam bukan | Mengembalikan nombor yang diperlukan; gelung untuk memeriksa semula nombor yang kurang daripada atau sama dengan nombor yang diberikan; Terus melintasi digit dari kanan ke kiri. Untuk setiap pemeriksaan digit jika ia lebih kecil daripada prev_dig; Kami mendapati nombor yang diperlukan; Kod pemacu", "code": "< ? php function nondecdigits ( $ n ) { $ x = 0 ; for ( $ x = $ n ; $ x >= 1 ; $ x -- ) { $ no = $ x ; $ prev_dig = 11 ; $ flag = true ; while ( $ no != 0 ) { if ( $ prev_dig < $ no % 10 ) { $ flag = false ; break ; } $ prev_dig = $ no % 10 ; $ no /= 10 ; } if ( $ flag == true ) break ; } return $ x ; } $ n = 200 ; echo nondecdigits ( $ n ) ; ? >"}
{"text": "Nombor terbesar lebih kecil daripada atau sama dengan N dan digit dalam bukan | Mencetak bilangan terbesar yang lebih kecil daripada S dan digit dalam urutan yang tidak menurun. ; array untuk menyimpan nombor nombor; Penukaran aksara nombor int rentetan; Variabel memegang nilai indeks selepas itu semua digit ditetapkan 9; Memeriksa keadaan jika digit kurang daripada digit kirinya; Jika digit pertama adalah 0 tidak perlu mencetaknya; Kod pemacu", "code": "< ? php function nondecdigits ( $ s ) { $ m = strlen ( $ s ) ; $ a [ $ m ] = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ a [ $ i ] = $ s [ $ i ] - '0' ; $ level = $ m - 1 ; for ( $ i = $ m - 1 ; $ i > 0 ; $ i -- ) { if ( $ a [ $ i ] < $ a [ $ i - 1 ] ) { $ a [ $ i - 1 ] -- ; $ level = $ i - 1 ; } } if ( $ a [ 0 ] != 0 ) { for ( $ i = 0 ; $ i <= $ level ; $ i ++ ) echo $ a [ $ i ] ; for ( $ i = $ level + 1 ; $ i < $ m ; $ i ++ ) echo \"9\" ; } else { for ( $ i = 1 ; $ i < $ level ; $ i ++ ) echo $ a [ $ i ] ; for ( $ i = $ level + 1 ; $ i < $ m ; $ i ++ ) echo \"9\" ; } } $ n = \"200\" ; nondecdigits ( $ n ) ; ? >"}
{"text": "Count divisor N in O (n ^ 1/3) | berfungsi untuk mengira pembahagi; Jika pembahagi adalah sama, hitung hanya satu; Jika tidak, kiraan kedua -duanya; Kod pemacu", "code": "< ? php function countDivisors ( $ n ) { $ cnt = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ cnt ++ ; else $ cnt = $ cnt + 2 ; } } return $ cnt ; } echo \" Total ▁ distinct ▁ divisors ▁ of ▁ 100 ▁ are ▁ : ▁ \" , countDivisors ( 100 ) ; ? >"}
{"text": "Semak jika pintu dibuka atau ditutup | Berfungsi untuk memeriksa sama ada 'n' mempunyai bilangan faktor atau tidak; Jika 'n' adalah persegi yang sempurna, ia mempunyai jumlah faktor yang ganjil; lain 'n' mempunyai bilangan faktor; Berfungsi untuk mencari dan mencetak status setiap pintu; Sekiranya terdapat beberapa faktor status akhir ditutup; Bilangan lain yang ganjil status akhir dibuka; Kod pemacu", "code": "< ? php function hasEvenNumberOfFactors ( $ n ) { $ root_n = sqrt ( $ n ) ; if ( ( $ root_n * $ root_n ) == $ n ) return false ; return true ; } function printStatusOfDoors ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( hasEvenNumberOfFactors ( $ i ) ) echo \" closed \" , \" ▁ \" ; else echo \" open \" , \" ▁ \" ; } } $ n = 5 ; printStatusOfDoors ( $ n ) ; ? >"}
{"text": "Semak jika kekerapan setiap digit kurang daripada digit | Fungsi untuk mengesahkan nombor (periksa jika kekerapan adigit kurang daripada thedigit sendiri atau tidak); Jika digit semasa temp adalah sama seperti i; Jika kekerapan lebih besar daripada nilai digit, pulih palsu; Kod pemacu", "code": "< ? php function validate ( $ n ) { for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ temp = $ n ; $ count = 0 ; while ( $ temp ) { if ( $ temp % 10 == $ i ) $ count ++ ; if ( $ count > $ i ) return -1 ; $ temp /= 10 ; } } return 1 ; } $ n = 1552793 ; $ geek = validate ( $ n ) ? \" True \" : \" False \" ; echo ( $ geek ) ; ? >"}
{"text": "Semak jika nombor yang lebih besar dibahagikan dengan 36 | Berfungsi untuk memeriksa sama ada nombor boleh dibahagikan dengan 36 atau tidak; nombor null tidak boleh dibahagikan dengan 36; nombor digit tunggal selain 0 tidak boleh dibahagikan dengan 36; nombor yang dibentuk oleh 2 digit terakhir; jika nombor tidak dapat dibahagikan dengan 4; Nombor boleh dibahagikan dengan 4 hitung jumlah digit; Jumlah digit tidak boleh dibahagikan dengan 9; Nombor boleh dibahagikan dengan 4 dan 9, maka nombor boleh dibahagikan dengan 36; Kod pemacu", "code": "< ? php function divisibleBy36 ( $ num ) { $ l = strlen ( $ num ) ; if ( $ l == 0 ) return \" No \" ; if ( $ l == 1 && $ num [ 0 ] != '0' ) return \" No \" ; $ two_digit_num = ( $ num [ $ l - 2 ] - '0' ) * 10 + ( $ num [ $ l - 1 ] - '0' ) ; if ( $ two_digit_num % 4 != 0 ) return \" No \" ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ sum += ( $ num [ $ i ] - '0' ) ; if ( $ sum % 9 != 0 ) return \" No \" ; return \" Yes \" ; } $ num = \"92567812197966231384\" ; echo ( divisibleBy36 ( $ num ) ) ; ? >"}
{"text": "Semak jika sebilangan besar boleh dibahagikan dengan 8 atau tidak | Berfungsi untuk mencari nombor yang boleh dibahagikan dengan 8 atau tidak; Rentetan kosong; Sekiranya terdapat satu digit; Sekiranya terdapat dua digit; Jika nombor yang dibentuk oleh tiga digit terakhir boleh dibahagikan dengan 8 .; Kod pemacu", "code": "< ? php function check ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 0 ) return false ; if ( $ n == 1 ) return ( ( $ str [ 0 ] - '0' ) % 8 == 0 ) ; if ( $ n == 2 ) return ( ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 8 == 0 ) ; $ last = $ str [ $ n - 1 ] - '0' ; $ second_last = $ str [ $ n - 2 ] - '0' ; $ third_last = $ str [ $ n - 3 ] - '0' ; return ( ( $ third_last * 100 + $ second_last * 10 + $ last ) % 8 == 0 ) ; } $ str = \"76952\" ; $ x = check ( $ str ) ? \" Yes \" : \" No ▁ \" ; echo ( $ x ) ; ? >"}
{"text": "Mata Perdana (mata yang memecah nombor menjadi dua prima) | Berfungsi untuk mengira bilangan digit; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak. Pulangan 0 jika Perdana lain - 1; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Berfungsi untuk mencetak mata perdana; mengira digit; Sebagai nombor digit tunggal dan dua tidak mempunyai pasangan nombor kiri dan kanan; Mencari semua pasangan kiri dan kanan. Mencetak titik utama dengan sewajarnya. Membuang titik indeks pertama dan terakhir; Mengira nombor kiri; Mengira nombor yang betul; Keadaan titik utama; Tiada titik utama yang dijumpai; Kod pemacu", "code": "< ? php function countDigits ( $ n ) { $ count = 0 ; while ( $ n > 0 ) { $ count ++ ; $ n = ( int ) ( $ n / 10 ) ; } return $ count ; } function checkPrime ( $ n ) { if ( $ n <= 1 ) return -1 ; if ( $ n <= 3 ) return 0 ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return -1 ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return -1 ; return 0 ; } function printPrimePoints ( $ n ) { $ count = countDigits ( $ n ) ; if ( $ count == 1 $ count == 2 ) { echo \" - 1\" ; return ; } $ found = false ; for ( $ i = 1 ; $ i < ( $ count - 1 ) ; $ i ++ ) { $ left = ( int ) ( $ n / ( ( int ) pow ( 10 , $ count - $ i ) ) ) ; $ right = $ n % ( ( int ) pow ( 10 , $ count - $ i - 1 ) ) ; if ( checkPrime ( $ left ) == 0 && checkPrime ( $ right ) == 0 ) { echo $ i , \" \" ; $ found = true ; } } if ( $ found == false ) echo \" - 1\" ; } $ n = 2317 ; printPrimePoints ( $ n ) ; ? >"}
{"text": "Cari cara integer boleh dinyatakan sebagai jumlah n | Berfungsi untuk mengira dan mengembalikan kuasa mana -mana nombor tertentu; Berfungsi untuk memeriksa perwakilan kuasa secara rekursif; Memulakan bilangan cara untuk mengekspresikan x sebagai kuasa n - th dari nombor semula jadi yang berbeza; Memanggil kuasa 'Saya' dibesarkan kepada 'n'; Periksa semula semua nilai yang lebih besar i; Jika jumlah kuasa adalah sama dengan x maka tingkatkan nilai hasil. ; Mengembalikan hasil akhir; Kod pemacu.", "code": "< ? php function power ( $ num , $ n ) { if ( $ n == 0 ) return 1 ; else if ( $ n % 2 == 0 ) return power ( $ num , ( int ) ( $ n / 2 ) ) * power ( $ num , ( int ) ( $ n / 2 ) ) ; else return $ num * power ( $ num , ( int ) ( $ n / 2 ) ) * power ( $ num , ( int ) ( $ n / 2 ) ) ; } function checkRecursive ( $ x , $ n , $ curr_num = 1 , $ curr_sum = 0 ) { $ results = 0 ; $ p = power ( $ curr_num , $ n ) ; while ( $ p + $ curr_sum < $ x ) { $ results += checkRecursive ( $ x , $ n , $ curr_num + 1 , $ p + $ curr_sum ) ; $ curr_num ++ ; $ p = power ( $ curr_num , $ n ) ; } if ( $ p + $ curr_sum == $ x ) $ results ++ ; return $ results ; } $ x = 10 ; $ n = 2 ; echo ( checkRecursive ( $ x , $ n ) ) ; ? >"}
{"text": "Teori Nombor | Penjana kumpulan kitaran terhingga di bawah tambahan | Berfungsi untuk mengembalikan GCD A dan B; Cetak penjana n; 1 selalu menjadi penjana; Nombor X adalah penjana GCD ialah 1; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function printGenerators ( $ n ) { echo \"1 ▁ \" ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( gcd ( $ i , $ n ) == 1 ) echo $ i , \" ▁ \" ; } $ n = 10 ; printGenerators ( $ n ) ; ? >"}
{"text": "Semak jika sebilangan besar boleh dibahagikan dengan 3 atau tidak | Berfungsi untuk mencari nombor yang boleh dibahagikan dengan 3 atau tidak; Mengira jumlah digit; Semak sama ada jumlah digit boleh dibahagikan dengan 3 .; Kod pemacu", "code": "< ? php function check ( $ str ) { $ n = strlen ( $ str ) ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 3 == 0 ) ; } $ str = \"1332\" ; $ x = check ( $ str ) ? \" Yes \" : \" No ▁ \" ; echo ( $ x ) ; ? >"}
{"text": "Kira semua pembahagi sempurna nombor | Berikut adalah kod PHP untuk mengira jumlah pembahagi sempurna; Pra - Mengira kiraan semua pembahagi sempurna dari semua nombor sehingga maksimum. ; Melewati semua gandaan i * i; Kenaikan semua gandaan sedemikian sebanyak 1; Mengembalikan kiraan pembahagi sempurna n. ; Kod pemacu", "code": "< ? php $ MAX = 10001 ; $ perfectDiv = array_fill ( 0 , $ MAX , 0 ) ; function precomputeCounts ( ) { global $ MAX , $ perfectDiv ; for ( $ i = 1 ; $ i * $ i < $ MAX ; ++ $ i ) { for ( $ j = $ i * $ i ; $ j < $ MAX ; $ j += $ i * $ i ) ++ $ perfectDiv [ $ j ] ; } } function countPerfectDivisors ( $ n ) { global $ perfectDiv ; return $ perfectDiv [ $ n ] ; } precomputeCounts ( ) ; $ n = 16 ; echo \" Total ▁ perfect ▁ divisors ▁ of ▁ \" . $ n . \" ▁ = ▁ \" . countPerfectDivisors ( $ n ) . \" STRNEWLINE \" ; $ n = 12 ; echo \" Total ▁ perfect ▁ divisors ▁ of ▁ \" . $ n . \" ▁ = ▁ \" . countPerfectDivisors ( $ n ) ; ? >"}
{"text": "Pemfaktoran Perdana Menggunakan SIEVE O (LOG N) untuk pelbagai pertanyaan | Program PHP untuk mencari pemfaktoran utama nombor N dalam O (log n) masa dengan precomputation dibenarkan. ; menyimpan faktor utama terkecil untuk setiap nombor; Mengira SPF (faktor utama terkecil) untuk setiap nombor sehingga maxn. Kerumitan masa: o (nloglogn); Menandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri. ; secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Memeriksa jika saya adalah perdana; menandakan SPF untuk semua nombor yang boleh dibahagi oleh i; menandakan SPF [J] jika ia tidak ditandakan sebelum ini; Fungsi o (log n) yang kembali ke primefactorization dengan membahagikan dengan faktor utama terkecil pada setiap langkah; faktor utama yang paling kecil; Memanggil fungsi getFactorization", "code": "< ? php $ MAXN = 19999 ; $ spf = array_fill ( 0 , $ MAXN , 0 ) ; function sieve ( ) { global $ MAXN , $ spf ; $ spf [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ MAXN ; $ i ++ ) $ spf [ $ i ] = $ i ; for ( $ i = 4 ; $ i < $ MAXN ; $ i += 2 ) $ spf [ $ i ] = 2 ; for ( $ i = 3 ; $ i * $ i < $ MAXN ; $ i ++ ) { if ( $ spf [ $ i ] == $ i ) { for ( $ j = $ i * $ i ; $ j < $ MAXN ; $ j += $ i ) if ( $ spf [ $ j ] == $ j ) $ spf [ $ j ] = $ i ; } } } function getFactorization ( $ x ) { global $ spf ; $ ret = array ( ) ; while ( $ x != 1 ) { array_push ( $ ret , $ spf [ $ x ] ) ; if ( $ spf [ $ x ] ) $ x = ( int ) ( $ x / $ spf [ $ x ] ) ; } return $ ret ; } sieve ( ) ; $ x = 12246 ; echo \" prime ▁ factorization ▁ for ▁ \" . $ x . \" ▁ : ▁ \" ; $ p = getFactorization ( $ x ) ; for ( $ i = 0 ; $ i < count ( $ p ) ; $ i ++ ) echo $ p [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Susunan terbesar yang mempunyai GCD lebih besar daripada 1 | Mengembalikan panjang berikutnya dengan GCD lebih daripada 1 .; Mencari nilai maksimum dalam arr []; Berulang dari 2 hingga maksimum pembahagi yang mungkin memberi nilai; Jika kita mendapati pembahagi, kiraan kenaikan; Kod pemacu", "code": "< ? php function largestGCDSubsequence ( $ arr , $ n ) { $ ans = 0 ; $ maxele = max ( $ arr ) ; for ( $ i = 2 ; $ i <= $ maxele ; ++ $ i ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; ++ $ j ) { if ( $ arr [ $ j ] % $ i == 0 ) ++ $ count ; } $ ans = max ( $ ans , $ count ) ; } return $ ans ; } $ arr = array ( 3 , 6 , 2 , 5 , 4 ) ; $ size = count ( $ arr ) ; echo largestGCDSubsequence ( $ arr , $ size ) ; ? >"}
{"text": "Pertanyaan pada jumlah faktor utama dalam julat | Program PHP untuk mencari faktor utama dalam julat yang diberikan. ; menggunakan kaedah SIEVE untuk menilai faktor utama nombor; Sekiranya saya adalah perdana; menetapkan bilangan faktor utama nombor perdana. ; Mengembalikan jumlah jumlah faktor utama dalam julat dari L ke R. Fungsi ini terutamanya menggunakan kiraan [] yang diisi oleh ayak (); Mencari jumlah bilangan faktor utama nombor dalam julat. ; Kod pemacu", "code": "< ? php $ MAX = 100006 ; function sieve ( & $ count ) { global $ MAX ; for ( $ i = 2 ; $ i * $ i <= $ MAX ; $ i ++ ) { if ( $ count [ $ i ] == 0 ) { for ( $ j = 2 * $ i ; $ j < $ MAX ; $ j += $ i ) $ count [ $ j ] ++ ; $ count [ $ i ] = 1 ; } } } function query ( $ count , $ l , $ r ) { $ sum = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) $ sum += $ count [ $ i ] ; return $ sum ; } $ count = array_fill ( 0 , $ MAX , 0 ) ; sieve ( $ count ) ; echo query ( $ count , 6 , 10 ) . \" \" . query ( $ count , 1 , 5 ) ; ? >"}
{"text": "Penjanaan Nombor N dengan set faktor yang diberikan | Menjana nombor n dengan faktor dalam faktor []; pelbagai k untuk menyimpan gandaan seterusnya faktor yang diberikan; Cetak n nombor $ output = 0; Nombor seterusnya untuk dicetak sebagai output; Cari pelbagai terkecil seterusnya; Percetakan minimum dalam setiap lelaran Cetak nilai jika output tidak sama dengan nilai semasa (untuk mengelakkan pendua); Meningkatkan nilai semasa dengan faktor masing -masing; Kod pemacu", "code": "< ? php function generateNumbers ( $ factor , $ n , $ k ) { $ next = array_fill ( 0 , $ k , 0 ) ; for ( $ i = 0 ; $ i < $ n ; ) { $ toincrement = 0 ; for ( $ j = 0 ; $ j < $ k ; $ j ++ ) if ( $ next [ $ j ] < $ next [ $ toincrement ] ) $ toincrement = $ j ; if ( $ output != $ next [ $ toincrement ] ) { $ output = $ next [ $ toincrement ] ; echo $ next [ $ toincrement ] . \" \" ; $ i ++ ; } $ next [ $ toincrement ] += $ factor [ $ toincrement ] ; } } $ factor = array ( 3 , 5 , 7 ) ; $ n = 10 ; $ k = count ( $ factor ) ; generateNumbers ( $ factor , $ n , $ k ) ; ? >"}
{"text": "Perintah Multiplicative | fungsi untuk GCD; Fungsi kembali terkecil + ve integer yang memegang keadaan a ^ k (mod n) = 1; hasil simpan kuasa A yang naik ke kuasa n - 1; aritmetik modular; kembali terkecil + ve integer; kuasa kenaikan; Kod pemacu", "code": "< ? php function GCD ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return GCD ( $ b , $ a % $ b ) ; } function multiplicativeOrder ( $ A , $ N ) { if ( GCD ( $ A , $ N ) != 1 ) return -1 ; $ result = 1 ; $ K = 1 ; while ( $ K < $ N ) { $ result = ( $ result * $ A ) % $ N ; if ( $ result == 1 ) return $ K ; $ K ++ ; } return -1 ; } $ A = 4 ; $ N = 7 ; echo ( multiplicativeOrder ( $ A , $ N ) ) ; ? >"}
{"text": "Jumlah produk x dan y seperti lantai (n / x) = y | Kembalikan jumlah nombor semulajadi dalam julat. ; n * (n + 1) / 2 .; Kembalikan jumlah produk x * y. ; Melangkah dari 1 hingga sqrt (n); Mencari had atas. ; Mencari had yang lebih rendah. ; Kod yang didorong", "code": "< ? php function sumOfRange ( $ a , $ b ) { $ i = ( $ a * ( $ a + 1 ) ) >> 1 ; $ j = ( $ b * ( $ b + 1 ) ) >> 1 ; return ( $ i - $ j ) ; } function sumofproduct ( $ n ) { $ sum = 0 ; $ root = sqrt ( $ n ) ; for ( $ i = 1 ; $ i <= $ root ; $ i ++ ) { $ up = ( int ) ( $ n / $ i ) ; $ low = max ( ( int ) ( $ n / ( $ i + 1 ) ) , $ root ) ; $ sum += ( $ i * sumOfRange ( $ up , $ low ) ) ; $ sum += ( $ i * ( int ) ( $ n / $ i ) ) ; } return $ sum ; } $ n = 10 ; echo sumofproduct ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Bilangan minimum terma kuasa dengan jumlah yang sama dengan n | Pulangan terma kuasa minimum X diperlukan; Jika x adalah 1, kembalikan n kerana kuasa 1 adalah 1 sahaja. ; Pertimbangkan n = a * x + b di mana a = n / x dan b = n % x. ; Kemas kini kiraan kuasa untuk ditambah 1; Ulangi proses untuk dikurangkan n; Kod pemacu", "code": "< ? php function minPower ( $ n , $ x ) { if ( $ x == 1 ) return $ n ; $ ans = 0 ; while ( $ n > 0 ) { $ ans += ( $ n % $ x ) ; $ n /= $ x ; } return $ ans ; } $ n = 5 ; $ x = 3 ; echo ( minPower ( $ n , $ x ) ) ; ? >"}
{"text": "Jumlah nombor Perrin | Fungsi untuk jumlah nombor pertama N Perrin. ; jika ($ n == 0) n = 0; jika ($ n == 1) n = 1; jika ($ n == 2) n = 2; Kirakan k = 5 jumlah tiga langkah sebelumnya. ; Jumlah bilangan baki; Kirakan istilah seterusnya; Kod pemacu", "code": "< ? php function calSum ( $ n ) { $ a = 3 ; $ b = 0 ; $ c = 2 ; return 3 ; return 3 ; return 5 ; $ sum = 5 ; while ( $ n > 2 ) { $ d = $ a + $ b ; $ sum += $ d ; $ a = $ b ; $ b = $ c ; $ c = $ d ; $ n -- ; } return $ sum ; } $ n = 9 ; echo calSum ( $ n ) ; ? >"}
{"text": "Cetak faktor umum KTH dua nombor | Mengembalikan faktor umum x dan y. ; Cari lebih kecil daripada dua nombor; Kira faktor umum sehingga kita mencapai kecil atau kiraan menjadi k. ; Jika kita mencapai kecil; Kod pemacu", "code": "< ? php function findKCF ( $ x , $ y , $ k ) { $ small = min ( $ x , $ y ) ; $ count = 1 ; for ( $ i = 2 ; $ i <= $ small ; $ i ++ ) { if ( $ x % $ i == 0 && $ y % $ i == 0 ) $ count ++ ; if ( $ count == $ k ) return $ i ; } return -1 ; } $ x = 4 ; $ y = 24 ; $ k = 3 ; echo findKCF ( $ x , $ y , $ k ) ; ? >"}
{"text": "Cari nombor minimum untuk dibahagikan untuk membuat nombor persegi yang sempurna | Kembalikan nombor minimum untuk dibahagikan untuk menjadikan N persegi yang sempurna. ; Oleh kerana 2 hanya perdana, hitung kuasa secara berasingan. ; Jika kiraan ganjil, ia mesti dikeluarkan dengan membahagikan n oleh nombor perdana. ; Jika kiraan ganjil, ia mesti dikeluarkan dengan membahagikan n oleh nombor perdana. ; Kod pemacu", "code": "< ? php function findMinNumber ( $ n ) { $ count = 0 ; $ ans = 1 ; while ( $ n % 2 == 0 ) { $ count ++ ; $ n /= 2 ; } if ( $ count % 2 ) $ ans *= 2 ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i += 2 ) { $ count = 0 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n /= $ i ; } if ( $ count % 2 ) $ ans *= $ i ; } if ( $ n > 2 ) $ ans *= $ n ; return $ ans ; } $ n = 72 ; echo findMinNumber ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk melaksanakan Collatz Sonjecture | Berfungsi untuk mencari jika n mencapai 1 atau tidak. ; Kembali benar jika n positif; Kod pemacu", "code": "< ? php function isToOne ( $ n ) { if ( $ n > 0 ) return true ; return false ; } $ n = 5 ; isToOne ( $ n ) ? print ( \" Yes \" ) : print ( \" No \" ) ; ? >"}
{"text": "GCD dua nombor yang dibentuk oleh N mengulangi X dan Y kali | Kembalikan pembahagi biasa dua nombor. ; Mencetak pembahagi biasa nombor yang dibentuk oleh n mengulangi masa x dan y kali. ; Mencari GCD X dan Y. ; Cetak n, g kali. ; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function findgcd ( $ n , $ x , $ y ) { $ g = gcd ( $ x , $ y ) ; for ( $ i = 0 ; $ i < $ g ; $ i ++ ) echo ( $ n ) ; } $ n = 123 ; $ x = 5 ; $ y = 2 ; findgcd ( $ n , $ x , $ y ) ; ? >"}
{"text": "Kira nombor semulajadi yang faktorialnya boleh dibahagikan dengan x tetapi tidak y | Fungsi GCD untuk mengira pembahagi terbesar di kalangan A dan B; Mengembalikan nombor pertama yang faktorialnya boleh dibahagikan dengan x. ; Hasil; Keluarkan faktor biasa; Kami menjumpai pertama i. ; Count Nombor Semulajadi yang faktorialnya boleh dibahagikan dengan x tetapi tidak y. ; Perbezaan pulangan antara nombor semulajadi yang pertama yang faktorial dapat dibahagikan dengan y dan nombor semulajadi yang faktorialnya boleh dibahagikan dengan x. ; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( ( $ a % $ b ) == 0 ) return $ b ; return gcd ( $ b , $ a % $ b ) ; } function firstFactorialDivisibleNumber ( $ x ) { $ i = 1 ; $ new_x = $ x ; for ( $ i = 1 ; $ i < $ x ; $ i ++ ) { $ new_x /= gcd ( $ i , $ new_x ) ; if ( $ new_x == 1 ) break ; } return $ i ; } function countFactorialXNotY ( $ x , $ y ) { return ( firstFactorialDivisibleNumber ( $ y ) - firstFactorialDivisibleNumber ( $ x ) ) ; } $ x = 15 ; $ y = 25 ; echo ( countFactorialXNotY ( $ x , $ y ) ) ; ? >"}
{"text": "Cari nombor semulajadi pertama yang faktorial dapat dibahagikan dengan x | Mengembalikan nombor pertama yang faktorial membahagikan x. ; Hasil; Kod pemacu", "code": "< ? php function firstFactorialDivisibleNumber ( $ x ) { $ i = 1 ; $ fact = 1 ; for ( $ i = 1 ; $ i < $ x ; $ i ++ ) { $ fact = $ fact * $ i ; if ( $ fact % $ x == 0 ) break ; } return $ i ; } $ x = 16 ; echo ( firstFactorialDivisibleNumber ( $ x ) ) ; ? >"}
{"text": "Cari dua nombor utama dengan jumlah yang diberikan | Menjana semua nombor perdana kurang daripada n. ; Inisialisasi semua penyertaan array Boolean sebagai benar. Nilai dalam Isprime [i] akhirnya akan palsu jika saya bukan perdana, lain -lain bool isprime [n + 1]; ; Jika Isprime [p] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Mencetak pasangan utama dengan jumlah yang diberikan; Menjana prima menggunakan ayak; Melintasi semua nombor untuk mencari pasangan pertama; Kod pemacu", "code": "< ? php function SieveOfEratosthenes ( $ n , & $ isPrime ) { $ isPrime [ 0 ] = $ isPrime [ 1 ] = false ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ isPrime [ $ i ] = true ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ isPrime [ $ p ] == true ) { for ( $ i = $ p * $ p ; $ i <= $ n ; $ i += $ p ) $ isPrime [ $ i ] = false ; } } } function findPrimePair ( $ n ) { $ isPrime = array_fill ( 0 , $ n + 1 , NULL ) ; SieveOfEratosthenes ( $ n , $ isPrime ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ isPrime [ $ i ] && $ isPrime [ $ n - $ i ] ) { echo $ i . \" ▁ \" . ( $ n - $ i ) ; return ; } } } $ n = 74 ; findPrimePair ( $ n ) ; ? >"}
{"text": "Kira nombor dengan digit pertama dan terakhir yang sama | kaedah untuk mendapatkan digit pertama x; Kaedah untuk mengembalikan kiraan nombor dengan permulaan yang sama dan berakhir digit dari 1 sehingga X; Dapatkan sepuluh - rentang dari 1 hingga x; Tambah 9 untuk mempertimbangkan semua nombor 1 digit; Cari digit pertama dan terakhir; Jika digit terakhir lebih besar daripada digit pertama maka penurunan kiraan dengan 1; Kaedah untuk mengembalikan kiraan nombor dengan permulaan yang sama dan menamatkan digit antara permulaan dan akhir; Kod pemacu", "code": "< ? php function getFirstDigit ( $ x ) { while ( $ x >= 10 ) $ x /= 10 ; return $ x ; } function getCountWithSameStartAndEndFrom1 ( $ x ) { if ( $ x < 10 ) return $ x ; $ tens = $ x / 10 ; $ res = $ tens + 9 ; $ firstDigit = getFirstDigit ( $ x ) ; $ lastDigit = $ x % 10 ; if ( $ lastDigit < $ firstDigit ) $ res -- ; return $ res ; } function getCountWithSameStartAndEnd ( $ start , $ end ) { return getCountWithSameStartAndEndFrom1 ( $ end ) - getCountWithSameStartAndEndFrom1 ( $ start - 1 ) ; } $ start = 5 ; $ end = 40 ; echo getCountWithSameStartAndEnd ( $ start , $ end ) ; ? >"}
{"text": "Kanan | Menjana semua nombor perdana kurang daripada n. ; Inisialisasi semua penyertaan array Boolean sebagai benar. Nilai dalam Isprime [i] akhirnya akan palsu jika saya bukan perdana, lain -lain bool isprime [n + 1]; ; Jika Isprime [p] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Pulangan benar jika n betul - dipotong, lain palsu; Menjana prima menggunakan ayak; Memeriksa sama ada nombor itu tetap menjadi perdana apabila digit terakhir (\"betul\") secara berturut -turut dikeluarkan; Kod pemacu", "code": "< ? php function sieveOfEratosthenes ( $ n , & $ isPrime ) { $ isPrime [ 0 ] = $ isPrime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ isPrime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ isPrime [ $ i ] = false ; } } } function rightTruPrime ( $ n ) { $ isPrime = array_fill ( 0 , $ n + 1 , true ) ; sieveOfEratosthenes ( $ n , $ isPrime ) ; while ( $ n ) { if ( $ isPrime [ $ n ] ) $ n = ( int ) ( $ n / 10 ) ; else return false ; } return true ; } $ n = 59399 ; if ( rightTruPrime ( $ n ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Mersenne Prime | Menjana semua nombor perdana kurang daripada n. ; Inisialisasi semua penyertaan array Boolean sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Berfungsi untuk menjana prima Mersenne kurang daripada atau sama dengan N; Menjana prima menggunakan ayak; Menjana semua nombor bentuk 2 ^ k - 1 dan lebih kecil daripada atau sama dengan n. ; Memeriksa sama ada nombor adalah perdana dan kurang dari kuasa 2; Kod pemacu", "code": "< ? php function SieveOf ( $ n ) { $ prime = array ( $ n + 1 ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ prime [ $ i ] = true ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } return $ prime ; } function mersennePrimes ( $ n ) { $ prime = SieveOf ( $ n ) ; for ( $ k = 2 ; ( ( 1 << $ k ) - 1 ) <= $ n ; $ k ++ ) { $ num = ( 1 << $ k ) - 1 ; if ( $ prime [ $ num ] ) echo $ num . \" \" ; } } $ n = 31 ; echo \" Mersenne ▁ prime ▁ numbers ▁ smaller ▁ \" . \" than ▁ or ▁ equal ▁ to ▁ $ n ▁ \" . mersennePrimes ( $ n ) ; ? >"}
{"text": "Cari Jumlah Modulo K Nombor Alam Pertama N Pertama | Kembali Jumlah Modulo k nombor semulajadi n Pertama. ; Beralih dari 1 hingga n && menilai dan menambah i % k. ; Kod pemacu", "code": "< ? php function findSum ( $ N , $ K ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ ans += ( $ i % $ K ) ; return $ ans ; } $ N = 10 ; $ K = 2 ; echo findSum ( $ N , $ K ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari Jumlah Modulo K Nombor Alam Pertama N Pertama | Kembali Jumlah Modulo k nombor semulajadi n Pertama. ; Mengira bilangan kali 1, 2 ,. . , K - 1, 0 urutan berlaku. ; Mencari bilangan elemen yang tersisa yang tidak lengkap dari urutan membawa kepada jenis kes 1. ; Menambah pendaraban bilangan kali 1, 2 ,. . , K - 1, 0 urutan berlaku dan jumlah nombor pertama k dan urutan pertama dari kes 1 .; Program Pemandu", "code": "< ? php function findSum ( $ N , $ K ) { $ ans = 0 ; $ y = $ N / $ K ; $ x = $ N % $ K ; $ ans = ( $ K * ( $ K - 1 ) / 2 ) * $ y + ( $ x * ( $ x + 1 ) ) / 2 ; return $ ans ; } $ N = 10 ; $ K = 2 ; echo findSum ( $ N , $ K ) ; ? >"}
{"text": "Nombor terkecil untuk membiak untuk menukar titik terapung ke semula jadi | Mencari GCD dua nombor; Mengembalikan integer terkecil k sehingga k * str menjadi semula jadi. STR adalah nombor titik terapung input; Cari saiz rentetan yang mewakili nombor titik terapung. ; Di bawah ini digunakan untuk mencari penyebut dalam bentuk pecahan. ; Digunakan untuk mencari nilai count_after_dot; Untuk mencari pengangka dalam bentuk pecahan nombor yang diberikan. Sebagai contoh, untuk 30.25, pengangka akan menjadi 3025; Sekiranya tidak ada titik, maka nombor sudah semulajadi. ; Cari penyebut dalam bentuk pecahan. Sebagai contoh, untuk 30.25, penyebut adalah 100; Hasilnya adalah penyebut yang dibahagikan dengan GCD - dari - pengangka - dan - penyebut. Sebagai contoh, untuk 30.25, hasilnya ialah 100 / GCD (3025, 100) = 100/25 = 4; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } function findnum ( $ str ) { $ n = strlen ( $ str ) ; $ count_after_dot = 0 ; $ dot_seen = false ; $ num = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] != ' . ' ) { $ num = $ num * 10 + ( $ str [ $ i ] - '0' ) ; if ( $ dot_seen == true ) $ count_after_dot ++ ; } else $ dot_seen = true ; } if ( $ dot_seen == false ) return 1 ; $ dem = pow ( 10 , $ count_after_dot ) ; return ( $ dem / gcd ( $ num , $ dem ) ) ; } { $ str = \"5.125\" ; echo findnum ( $ str ) ; return 0 ; } ? >"}
{"text": "Cari bilangan maksimum jabat tangan | Mengira bilangan maksimum jabat tangan menggunakan formula yang diperolehi. ; Kod pemacu", "code": "< ? php function maxHandshake ( $ n ) { return ( $ n * ( $ n - 1 ) ) / 2 ; } $ n = 10 ; echo maxHandshake ( $ n ) ; ? >"}
{"text": "Mengira digit dalam nombor yang diberikan n yang membahagikan n | Fungsi utiliti untuk memeriksa kebolehpasaran dengan digit; (N [i] - '0') memberikan nilai digit dan membentuk nombor; Fungsi untuk mengira digit yang muncul dalam n dan membahagikan n membahagikan [10] -> array yang memberitahu bahawa digit tertentu membahagikan n atau tidak mengira [10] -> mengira kekerapan digit yang membahagikan n; Kami memulakan semua digit n sebagai tidak boleh dibahagikan oleh n. ; Mula memeriksa pembahagian n oleh digit 2 hingga 9; Jika digit membahagikan n maka tandakannya sebagai benar; Sekarang melintasi rentetan nombor untuk mencari dan hasil kenaikan apabila digit membahagikan n. ; Kod pemacu", "code": "< ? php function divisible ( $ N , $ digit ) { $ ans = 0 ; for ( $ i = 0 ; $ i < strlen ( $ N ) ; $ i ++ ) { $ ans = ( $ ans * 10 + ( int ) ( $ N [ $ i ] - '0' ) ) ; $ ans %= $ digit ; } return ( $ ans == 0 ) ; } function allDigits ( $ N ) { $ divide = array_fill ( 0 , 10 , false ) ; for ( $ digit = 2 ; $ digit <= 9 ; $ digit ++ ) { if ( divisible ( $ N , $ digit ) ) $ divide [ $ digit ] = true ; } $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ N ) ; $ i ++ ) { if ( $ divide [ ( int ) ( $ N [ $ i ] - '0' ) ] == true ) $ result ++ ; } return $ result ; } $ N = \"122324\" ; echo allDigits ( $ N ) ; ? >"}
{"text": "Nombor kiraan yang boleh dibina menggunakan dua nombor | Mengembalikan kiraan nombor dari 1 hingga N yang boleh dibentuk menggunakan x dan y. ; Buat array tambahan dan mulakannya sebagai palsu. Entri entri [i] = benar akan bermakna saya boleh dibentuk menggunakan x dan y; x dan y boleh dibentuk menggunakan x dan y. ; Memulakan hasil; Melintasi semua nombor dan hasil kenaikan jika nombor boleh dibentuk menggunakan x dan y. ; Jika saya boleh dibentuk menggunakan x dan y; Kemudian i + x dan i + y juga boleh dibentuk menggunakan x dan y. ; Hasil kenaikan; Kod pemacu", "code": "< ? php function countNums ( $ n , $ x , $ y ) { $ arr = array_fill ( 0 , $ n + 1 , false ) ; if ( $ x <= $ n ) $ arr [ $ x ] = true ; if ( $ y <= $ n ) $ arr [ $ y ] = true ; $ result = 0 ; for ( $ i = min ( $ x , $ y ) ; $ i <= $ n ; $ i ++ ) { if ( $ arr [ $ i ] ) { if ( $ i + $ x <= $ n ) $ arr [ $ i + $ x ] = true ; if ( $ i + $ y <= $ n ) $ arr [ $ i + $ y ] = true ; $ result ++ ; } } return $ result ; } $ n = 15 ; $ x = 5 ; $ y = 7 ; echo countNums ( $ n , $ x , $ y ) ; ? >"}
{"text": "Nombor Emirp | Berfungsi untuk mencari sebaliknya nombor; Kaedah ayak yang digunakan untuk menjana nombor emirp (penggunaan ayak oferatosthenes); Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Melintasi semua nombor perdana; Cari nombor terbalik; Nombor adalah emrip jika ia bukan nombor palindrome dan sebaliknya juga utama. ; Mark Reverse Prime sebagai palsu supaya ia tidak dicetak lagi; Kod pemacu", "code": "< ? php function reverse ( $ x ) { $ rev = 0 ; while ( $ x > 0 ) { $ rev = ( $ rev * 10 ) + $ x % 10 ; $ x = ( int ) ( $ x / 10 ) ; } return $ rev ; } function printEmirp ( $ n ) { $ prime = array_fill ( 0 , ( $ n + 1 ) , 1 ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == 1 ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = 0 ; } } for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == 1 ) { $ rev = reverse ( $ p ) ; if ( $ p != $ rev && $ rev <= $ n && $ prime [ $ rev ] == 1 ) { echo $ p . \" \" ▁ . ▁ $ rev ▁ . ▁ \" \" $ prime [ $ rev ] = 0 ; } } } } $ n = 100 ; printEmirp ( $ n ) ; ? >"}
{"text": "Nombor yang banyak | Berfungsi untuk mengira jumlah pembahagi; Perhatikan bahawa gelung ini berjalan sehingga akar persegi N; Jika pembahagi adalah sama, ambil hanya satu daripada mereka; Jika tidak, ambil kedua -duanya; Hitung jumlah semua pembahagi yang betul sahaja; Berfungsi untuk memeriksa nombor yang banyak; Kembali benar jika jumlah pembahagi lebih besar daripada n. ; Kod pemacu", "code": "< ? php function getSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ sum = $ sum + $ i ; else { $ sum = $ sum + $ i ; $ sum = $ sum + ( $ n / $ i ) ; } } } $ sum = $ sum - $ n ; return $ sum ; } function checkAbundant ( $ n ) { return ( getSum ( $ n ) > $ n ) ; } $ k = checkAbundant ( 12 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ; echo ( $ k ) ; $ k = checkAbundant ( 15 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ; echo ( $ k ) ; ? >"}
{"text": "Nombor yang kuat | berfungsi untuk memeriksa sama ada nombor itu berkuasa; Pertama membahagikan nombor berulang kali dengan 2; Jika hanya 2 ^ 1 membahagikan n (tidak kuasa yang lebih tinggi), maka kembali palsu; Jika n bukan kuasa 2 maka gelung ini akan melaksanakan proses ulangi di atas; Cari kuasa tertinggi \"faktor\" yang membahagikan n; Jika hanya faktor ^ 1 membahagikan n (tidak kuasa yang lebih tinggi), maka kembali palsu; n mestilah 1 sekarang jika bukan nombor utama. Oleh kerana nombor perdana tidak berkuasa, kita kembali palsu jika n tidak 1 .; Kod pemacu", "code": "< ? php function isPowerful ( $ n ) { while ( $ n % 2 == 0 ) { $ power = 0 ; while ( $ n % 2 == 0 ) { $ n /= 2 ; $ power ++ ; } if ( $ power == 1 ) return false ; } for ( $ factor = 3 ; $ factor <= sqrt ( $ n ) ; $ factor += 2 ) { $ power = 0 ; while ( $ n % $ factor == 0 ) { $ n = $ n / $ factor ; $ power ++ ; } if ( $ power == 1 ) return false ; } return ( $ n == 1 ) ; } $ d = isPowerful ( 20 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ; echo $ d ; $ d = isPowerful ( 27 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ; echo $ d ; ? >"}
{"text": "Nombor kekurangan | Berfungsi untuk mengira jumlah pembahagi; Memulakan jumlah faktor utama; Perhatikan bahawa gelung ini berjalan sehingga akar persegi N; Jika pembahagi adalah sama, ambil hanya satu daripada mereka; Jika tidak, ambil kedua -duanya; Berfungsi untuk memeriksa nombor kekurangan; Semak jika jumlah (n) <2 * n; Kod pemacu", "code": "< ? php function divisorsSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) { $ sum = $ sum + $ i ; } else { $ sum = $ sum + $ i ; $ sum = $ sum + ( $ n / $ i ) ; } } } return $ sum ; } function isDeficient ( $ n ) { return ( divisorsSum ( $ n ) < ( 2 * $ n ) ) ; } $ ds = isDeficient ( 12 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ; echo ( $ ds ) ; $ ds = isDeficient ( 15 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ; echo ( $ ds ) ; ? >"}
{"text": "Smith Number | Program PHP untuk memeriksa sama ada nombor adalah nombor Smith atau tidak. ; array untuk menyimpan semua perdana kurang daripada dan sama dengan 10 ^ 6; fungsi utiliti untuk Sieve of Sundaram; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahukan prima yang lebih kecil daripada Max, kita mengurangkan max hingga separuh. Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j; Logik utama Sundaram. Tandakan semua nombor yang tidak menjana nombor perdana dengan melakukan 2 * i + 1; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Pulangan benar jika n adalah nombor smith, lain -lain palsu. ; Cari jumlah digit faktor utama n; Jika prima [i] adalah faktor utama, tambahkan digitnya ke pdigitsum. ; Jika n! = 1 maka satu faktor utama masih akan disimpulkan; ; Semua faktor utama digit disimpulkan sekarang jumlah digit nombor asal; Jika jumlah digit dalam faktor utama dan jumlah digit dalam nombor asal adalah sama, maka kembali benar. Lain kembali palsu. ; Mencari semua nombor perdana sebelum had. Nombor ini digunakan untuk mencari faktor utama.", "code": "< ? php $ MAX = 10000 ; $ primes = array ( ) ; function sieveSundaram ( ) { global $ MAX , $ primes ; $ marked = array_fill ( 0 , ( $ MAX / 2 + 100 ) , false ) ; for ( $ i = 1 ; $ i <= ( sqrt ( $ MAX ) - 1 ) / 2 ; $ i ++ ) for ( $ j = ( $ i * ( $ i + 1 ) ) << 1 ; $ j <= $ MAX / 2 ; $ j = $ j + 2 * $ i + 1 ) $ marked [ $ j ] = true ; array_push ( $ primes , 2 ) ; for ( $ i = 1 ; $ i <= $ MAX / 2 ; $ i ++ ) if ( $ marked [ $ i ] == false ) array_push ( $ primes , 2 * $ i + 1 ) ; } function isSmith ( $ n ) { global $ MAX , $ primes ; $ original_no = $ n ; $ pDigitSum = 0 ; for ( $ i = 0 ; $ primes [ $ i ] <= $ n / 2 ; $ i ++ ) { while ( $ n % $ primes [ $ i ] == 0 ) { $ p = $ primes [ $ i ] ; $ n = $ n / $ p ; while ( $ p > 0 ) { $ pDigitSum += ( $ p % 10 ) ; $ p = $ p / 10 ; } } } if ( $ n != 1 && $ n != $ original_no ) { while ( $ n > 0 ) { $ pDigitSum = $ pDigitSum + $ n % 10 ; $ n = $ n / 10 ; } } $ sumDigits = 0 ; while ( $ original_no > 0 ) { $ sumDigits = $ sumDigits + $ original_no % 10 ; $ original_no = $ original_no / 10 ; } return ( $ pDigitSum == $ sumDigits ) ; } sieveSundaram ( ) ; echo \" Printing ▁ first ▁ few ▁ Smith ▁ Numbers \" . \" ▁ using ▁ isSmith ( ) STRNEWLINE \" ; for ( $ i = 1 ; $ i < 500 ; $ i ++ ) if ( isSmith ( $ i ) ) echo $ i . \" \" ; ? >"}
{"text": "Kaprekar Number | Pulangan benar jika n adalah nombor Kaprekar, lain -lain palsu; Kiraan nombor digit di persegi; Pecahkan persegi pada titik yang berbeza dan lihat jika jumlah mana -mana pasangan nombor yang dipisahkan adalah sama dengan n. ; Untuk mengelakkan nombor seperti 10, 100, 1000 (ini bukan nombor karprekar; cari jumlah bahagian semasa dan bandingkan dengan n; bandingkan dengan nombor asal; kod pemacu", "code": "< ? php function iskaprekar ( $ n ) { if ( $ n == 1 ) return true ; $ sq_n = $ n * $ n ; $ count_digits = 0 ; while ( $ sq_n ) { $ count_digits ++ ; $ sq_n = ( int ) ( $ sq_n / 10 ) ; } for ( $ r_digits = 1 ; $ r_digits < $ count_digits ; $ r_digits ++ ) { $ eq_parts = pow ( 10 , $ r_digits ) ; if ( $ eq_parts == $ n ) continue ; $ sum = ( int ) ( $ sq_n1 / $ eq_parts ) + $ sq_n1 % $ eq_parts ; if ( $ sum == $ n ) return true ; } return false ; } echo \" Printing ▁ first ▁ few ▁ Kaprekar ▁ \" . \" Numbers ▁ using ▁ iskaprekar ( ) STRNEWLINE \" ; for ( $ i = 1 ; $ i < 10000 ; $ i ++ ) if ( iskaprekar ( $ i ) ) echo $ i . \" \" ; ? >"}
{"text": "Keith Number | Pulangan benar jika x adalah Keith, lain -lain palsu. ; Simpan semua digit X dalam \"Terma\" vektor juga mencari bilangan digit dan simpan dalam \"N\". ; $ n = 0; n ialah bilangan digit dalam x; Untuk mendapatkan digit dalam urutan yang betul (dari MSB ke LSB); Teruskan mencari TRM seterusnya urutan yang dihasilkan menggunakan digit X sehingga kita sama ada mencapai X atau nombor Greate daripada X; Istilah seterusnya adalah jumlah istilah N sebelumnya; Apabila kawalan keluar dari gelung sementara, sama ada next_term adalah sama dengan nombor atau lebih besar daripada itu. Jika next_term sama dengan x, maka x adalah nombor Keith, tidak lain; Kod pemacu", "code": "< ? php function isKeith ( $ x ) { $ terms = array ( ) ; $ temp = $ x ; while ( $ temp > 0 ) { array_push ( $ terms , $ temp % 10 ) ; $ temp = ( int ) ( $ temp / 10 ) ; $ n ++ ; } $ terms = array_reverse ( $ terms ) ; $ next_term = 0 ; $ i = $ n ; while ( $ next_term < $ x ) { $ next_term = 0 ; for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) $ next_term += $ terms [ $ i - $ j ] ; array_push ( $ terms , $ next_term ) ; $ i ++ ; } return ( $ next_term == $ x ) ; } isKeith ( 14 ) ? print ( \" Yes STRNEWLINE \" ) : print ( \" No STRNEWLINE \" ) ; isKeith ( 12 ) ? print ( \" Yes STRNEWLINE \" ) : print ( \" No STRNEWLINE \" ) ; isKeith ( 197 ) ? print ( \" Yes STRNEWLINE \" ) : print ( \" No STRNEWLINE \" ) ; ? >"}
{"text": "Semak jika nombor boleh dinyatakan sebagai jumlah nombor berturut -turut | Fungsi ini kembali benar jika n boleh dinyatakan jumlah berturut -turut. ; Kami pada dasarnya kembali benar jika n adalah kuasa dua; Kod pemacu", "code": "< ? php function canBeSumofConsec ( $ n ) { return ( ( $ n & ( $ n - 1 ) ) && $ n ) ; } $ n = 15 ; if ( canBeSumofConsec ( $ n ) ) echo \" true \" ; else echo \" false \" ; ? >"}
{"text": "Malah nombor Fibonacci jumlah | Mengembalikan jumlah nombor Fibonacci yang kurang daripada atau sama dengan had yang diberikan. ; Memulakan dua pertama walaupun nombor perdana dan jumlah mereka; mengira jumlah nilai Fibonacci walaupun; Dapatkan seterusnya walaupun nilai urutan Fibonacci; Jika kita melampaui batas, kita memecahkan gelung; Pindah ke nombor seterusnya dan mengemas kini jumlah; Kod pemacu", "code": "< ? php function evenFibSum ( $ limit ) { if ( $ limit < 2 ) return 0 ; $ ef1 = 0 ; $ ef2 = 2 ; $ sum = $ ef1 + $ ef2 ; while ( $ ef2 <= $ limit ) { $ ef3 = 4 * $ ef2 + $ ef1 ; if ( $ ef3 > $ limit ) break ; $ ef1 = $ ef2 ; $ ef2 = $ ef3 ; $ sum += $ ef2 ; } return $ sum ; } $ limit = 400 ; echo ( evenFibSum ( $ limit ) ) ; ? >"}
{"text": "Cari nombor dengan pembahagi k ganjil dalam julat yang diberikan | berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Berfungsi untuk mengembalikan kiraan pembahagi nombor; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi adalah sama, hitung hanya sekali; Jika tidak cetak kedua -duanya; Fungsi untuk mengira semua pembahagi yang mempunyai persamaan di antara a dan b; Memulakan hasil; Hitung hanya untuk nombor persegi yang sempurna; Semak sama ada nombor persegi sempurna atau tidak; jumlah pembahagi nombor bersamaan dengan k atau tidak; Kod pemacu", "code": "< ? php function isPerfect ( $ n ) { $ s = sqrt ( $ n ) ; return ( $ s * $ s == $ n ) ; } function divisorsCount ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) + 1 ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ count += 1 ; else $ count += 2 ; } } return $ count ; } function kDivisors ( $ a , $ b , $ k ) { $ count = 0 ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) { if ( isPerfect ( $ i ) ) if ( divisorsCount ( $ i ) == $ k ) $ count ++ ; } return $ count ; } $ a = 2 ; $ b = 49 ; $ k = 3 ; echo kDivisors ( $ a , $ b , $ k ) ; ? >"}
{"text": "Nth walaupun nombor Fibonacci | Fungsi yang mengembalikan nth walaupun nombor fibonnaci; Pengiraan Fn = 4 * (Fn - 1) + Fn - 2; Kod pemacu", "code": "< ? php function evenFib ( $ n ) { if ( $ n < 1 ) return $ n ; if ( $ n == 1 ) return 2 ; return ( ( 4 * evenFib ( $ n - 1 ) ) + evenFib ( $ n - 2 ) ) ; } $ n = 7 ; echo ( evenFib ( $ n ) ) ; ? >"}
{"text": "N 'TH SMART NOMBOR | Had hasil; Berfungsi untuk mengira nombor pintar n '; Memulakan semua nombor sebagai tidak perdana; berulang untuk menandakan semua prima dan nombor pintar; Melintasi semua nombor sehingga had maksimum; 'Saya' dibuat sebagai nombor perdana kerana ia tidak berganda dari mana -mana perdana lain; Tandakan semua gandaan 'I' sebagai bukan Perdana; Jika saya adalah faktor utama ketiga j maka tambahkannya untuk menghasilkan kerana ia mempunyai sekurang -kurangnya tiga faktor utama. ; Menyusun semua nombor pintar; kembali nombor pintar n '; Program pemacu untuk menjalankan kes itu", "code": "< ? php $ MAX = 3000 ; function smartNumber ( $ n ) { global $ MAX ; $ primes = array_fill ( 0 , $ MAX , 0 ) ; $ result = array ( ) ; for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) { if ( $ primes [ $ i ] == 0 ) { $ primes [ $ i ] = 1 ; for ( $ j = $ i * 2 ; $ j < $ MAX ; $ j = $ j + $ i ) { $ primes [ $ j ] -= 1 ; if ( ( $ primes [ $ j ] + 3 ) == 0 ) array_push ( $ result , $ j ) ; } } } sort ( $ result ) ; return $ result [ $ n - 1 ] ; } $ n = 50 ; echo smartNumber ( $ n ) ; ? >"}
{"text": "Pengurangan berulang di antara dua nombor | Mengembalikan kiraan langkah sebelum salah satu daripada nombor menjadi 0 selepas penolakan berulang. ; Jika y membahagikan x, maka hanya kembali x / y. ; Lain berulang. Perhatikan bahawa fungsi ini berfungsi walaupun x lebih kecil daripada y kerana dalam hal ini pertama rekursif panggilan pertukaran peranan x dan y. ; Kod pemacu", "code": "< ? php function countSteps ( $ x , $ y ) { if ( $ x % $ y == 0 ) return floor ( ( ( int ) $ x / $ y ) ) ; return floor ( ( ( int ) $ x / $ y ) + countSteps ( $ y , $ x % $ y ) ) ; } $ x = 100 ; $ y = 19 ; echo countSteps ( $ x , $ y ) ; ? >"}
{"text": "Bilangan bilangan penyelesaian x ^ 2 = 1 (mod p) dalam julat yang diberikan | Program untuk mengira bilangan nilai yang memenuhi x ^ 2 = 1 mod p di mana x terletak dalam julat [1, n]; Memulakan hasil; Melintasi semua nombor yang lebih kecil daripada bilangan yang diberikan p. Perhatikan bahawa kita tidak melintasi 1 hingga n, tetapi 1 hingga p; Jika x adalah penyelesaian, maka hitung semua nombor bentuk x + i * p sedemikian rupa sehingga x + i * p berada dalam julat [1, n]; Bilangan terbesar dalam bentuk x + p * i dalam julat [1, n]; Tambah kiraan nombor borang x + p * i. 1 ditambah untuk X sendiri. ; Kod pemacu", "code": "< ? php function findCountOfSolutions ( $ n , $ p ) { $ ans = 0 ; for ( $ x = 1 ; $ x < $ p ; $ x ++ ) { if ( ( $ x * $ x ) % $ p == 1 ) { $ last = $ x + $ p * ( $ n / $ p ) ; if ( $ last > $ n ) $ last -= $ p ; $ ans += ( ( $ last - $ x ) / $ p + 1 ) ; } } return $ ans ; } $ n = 10 ; $ p = 5 ; echo findCountOfSolutions ( $ n , $ p ) ; ? >"}
{"text": "Kaprekar Constant | Fungsi ini menyemak kesahihan Kaprekar 's constant. Its ~ Returns 'Kaprekar' s constant untuk mana -mana empat digit nombor \"n\" supaya semua digit n tidak sama. ; Simpan semasa n sebagai nombor sebelumnya; Dapatkan empat digit nombor yang diberikan; Menyusun semua empat DGITS dalam urutan menaik dan giet dalam bentuk nombor \"ASC\"; Dapatkan semua empat DGIT dalam urutan menurun dalam bentuk nombor \"DESC\"; Dapatkan perbezaan dua nombor; Jika perbezaan sama seperti sebelumnya, kami telah mencapai pemalar Kaprekar; Lain berulang; Pembungkus ke atas Kaprkrec (); Mencuba beberapa nombor empat digit, kami selalu mendapat 6174", "code": "< ? php function kaprekarRec ( $ n , $ prev ) { if ( $ n == 0 ) return 0 ; $ prev = $ n ; $ digits = array_fill ( 0 , 4 , 0 ) ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ digits [ $ i ] = $ n % 10 ; $ n = ( int ) ( $ n / 10 ) ; } sort ( $ digits ) ; $ asc = 0 ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) $ asc = $ asc * 10 + $ digits [ $ i ] ; rsort ( $ digits ) ; $ desc = 0 ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) $ desc = $ desc * 10 + $ digits [ $ i ] ; $ diff = abs ( $ asc - $ desc ) ; if ( $ diff == $ prev ) return $ diff ; return kaprekarRec ( $ diff , $ prev ) ; } function kaprekar ( $ n ) { $ rev = 0 ; return kaprekarRec ( $ n , $ rev ) ; } echo kaprekar ( 1000 ) . \" STRNEWLINE \" ; echo kaprekar ( 1112 ) . \" STRNEWLINE \" ; echo kaprekar ( 9812 ) . \" STRNEWLINE \" ; ? >"}
{"text": "Penghampiran Bakhshali untuk pengkomputeran akar persegi | Program PHP ini memberikan hasil yang dianggarkan kepada 5 tempat perpuluhan. ; Ini akan menjadi persegi yang paling dekat dengan S; Ini adalah SQRT PSQ; Cari persegi sempurna terdekat untuk s; hitung d; hitung p; hitung a; Kirakan Sqrt (s). ; Kod pemacu", "code": "< ? php function sqroot ( $ s ) { $ pSq = 0 ; $ N = 0 ; for ( $ i = intval ( $ s ) ; $ i > 0 ; $ i -- ) { for ( $ j = 1 ; $ j < $ i ; $ j ++ ) { if ( $ j * $ j == $ i ) { $ pSq = $ i ; $ N = $ j ; break ; } } if ( $ pSq > 0 ) break ; } $ d = $ s - $ pSq ; $ P = $ d / ( 2.0 * $ N ) ; $ A = $ N + $ P ; $ sqrt_of_s = $ A - ( ( $ P * $ P ) / ( 2.0 * $ A ) ) ; return $ sqrt_of_s ; } $ num = 9.2345 ; $ sqroot_of_num = sqroot ( $ num ) ; echo \" Square ▁ root ▁ of ▁ \" . $ num . \" ▁ = ▁ \" . round ( ( $ sqroot_of_num * 100000.0 ) / 100000.0 , 5 ) ; ? >"}
{"text": "Memecahkan integer untuk mendapatkan produk maksimum | kaedah pulangan x ^ a dalam log (a) masa; Kaedah mengembalikan produk maksimum yang diperolehi dengan melanggar N; Kes asas 2 = 1 + 1; Kes asas 3 = 2 + 1; pecah berdasarkan mod dengan 3; Jika membahagikan secara merata, maka masuk ke dalam semua 3; Jika pembahagian memberikan mod sebagai 1, maka pecahkan sebagai 4 + kuasa 3 untuk baki bahagian; Jika pembahagian memberikan mod sebagai 2, maka pecahkan sebagai 2 + kuasa 3 untuk baki bahagian; Kod pemacu untuk menguji kaedah di atas", "code": "< ? php function power ( $ x , $ a ) { $ res = 1 ; while ( $ a ) { if ( $ a & 1 ) $ res = $ res * $ x ; $ x = $ x * $ x ; $ a >>= 1 ; } return $ res ; } function breakInteger ( $ N ) { if ( $ N == 2 ) return 1 ; if ( $ N == 3 ) return 2 ; $ maxProduct = 0 ; switch ( $ N % 3 ) { case 0 : $ maxProduct = power ( 3 , $ N / 3 ) ; break ; case 1 : $ maxProduct = 2 * 2 * power ( 3 , ( $ N / 3 ) - 1 ) ; break ; case 2 : $ maxProduct = 2 * power ( 3 , $ N / 3 ) ; break ; } return $ maxProduct ; } $ maxProduct = breakInteger ( 10 ) ; echo $ maxProduct ; ? >"}
{"text": "Mencari jumlah digit nombor sehingga jumlah menjadi digit tunggal | Program PHP untuk mencari jumlah digit nombor sehingga jumlah menjadi digit tunggal. ; Gelung untuk melakukan jumlah sementara jumlah tidak kurang dari atau sama dengan 9; Kod pemacu", "code": "< ? php function digSum ( $ n ) { $ sum = 0 ; while ( $ n > 0 $ sum > 9 ) { if ( $ n == 0 ) { $ n = $ sum ; $ sum = 0 ; } $ sum += $ n % 10 ; $ n = ( int ) $ n / 10 ; } return $ sum ; } $ n = 1234 ; echo digSum ( $ n ) ; ? >"}
{"text": "Mencari jumlah digit nombor sehingga jumlah menjadi digit tunggal | Program pemacu untuk menguji fungsi di atas", "code": "< ? php function digSum ( $ n ) { if ( $ n == 0 ) return 0 ; return ( $ n % 9 == 0 ) ? 9 : ( $ n % 9 ) ; } $ n = 9999 ; echo digSum ( $ n ) ; ? >"}
{"text": "Gandaan 3 atau 7 | Mengembalikan kiraan semua nombor yang lebih kecil daripada atau sama dengan N dan gandaan 3 atau 7 atau kedua -duanya; Kod pemacu", "code": "< ? php function countMultiples ( $ n ) { return floor ( $ n / 3 + $ n / 7 - $ n / 21 ) ; } echo \" Count = \" ? >"}
{"text": "Cari digit terakhir A ^ B untuk nombor besar | Fungsi untuk mencari B % A; Memulakan hasil; mengira mod B dengan A untuk membuat b seperti 0 <= b <a; pulangan $ mod; kembali modulo; berfungsi untuk mencari digit terakhir A ^ B; Jika A dan B kedua -duanya adalah 0; jika eksponen adalah 0; jika asas adalah 0; Jika eksponen dibahagikan dengan 4 yang bermaksud digit terakhir akan menjadi POW (a, 4) % 10. Jika eksponen tidak dapat dibahagikan dengan 4 yang bermaksud digit terakhir akan menjadi POW (a, b % 4) % 10; Cari digit terakhir dalam 'A' dan hitung eksponennya; Mengembalikan angka terakhir hasil; Program pemacu untuk menjalankan kes ujian", "code": "< ? php function Modulo ( $ a , $ b ) { $ mod = 0 ; for ( $ i = 0 ; $ i < strlen ( $ b ) ; $ i ++ ) $ mod = ( $ mod * 10 + $ b [ $ i ] - '0' ) % $ a ; } function LastDigit ( $ a , $ b ) { $ len_a = strlen ( $ a ) ; $ len_b = strlen ( $ b ) ; if ( $ len_a == 1 && $ len_b == 1 && $ b [ 0 ] == '0' && $ a [ 0 ] == '0' ) return 1 ; if ( $ len_b == 1 && $ b [ 0 ] == '0' ) return 1 ; if ( $ len_a == 1 && $ a [ 0 ] == '0' ) return 0 ; $ exp = ( Modulo ( 4 , $ b ) == 0 ) ? 4 : Modulo ( 4 , $ b ) ; $ res = pow ( $ a [ $ len_a - 1 ] - '0' , $ exp ) ; return $ res % 10 ; } $ a = \"117\" ; $ b = \"3\" ; echo LastDigit ( $ a , $ b ) ; ? >"}
{"text": "Balik dan Tambah Fungsi | Fungsi berulang untuk membalikkan digit NUM; Berfungsi untuk memeriksa sama ada nombor dia adalah palindrome atau tidak; Terbalik dan tambah fungsi; Membalikkan digit nombor; Menambah nombor terbalik dengan asal; Memeriksa sama ada nombor itu adalah palindrome atau tidak; Kod pemacu", "code": "< ? php function reversDigits ( $ num ) { $ rev_num = 0 ; while ( $ num > 0 ) { $ rev_num = $ rev_num * 10 + $ num % 10 ; $ num = ( int ) ( $ num / 10 ) ; } return $ rev_num ; } function isPalindrome ( $ num ) { return ( reversDigits ( $ num ) == $ num ) ; } function ReverseandAdd ( $ num ) { $ rev_num = 0 ; while ( $ num <= 4294967295 ) { $ rev_num = reversDigits ( $ num ) ; $ num = $ num + $ rev_num ; if ( isPalindrome ( $ num ) ) { print ( $ num . \" \" ) ; break ; } else if ( $ num > 4294967295 ) { print ( \" No ▁ palindrome ▁ exist \" ) ; } } } ReverseandAdd ( 195 ) ; ReverseandAdd ( 265 ) ; ? >"}
{"text": "Algoritma Stein untuk Mencari GCD | Berfungsi untuk melaksanakan algoritma Stein; GCD (0, b) == B; Gcd (a, 0) == a, gcd (0, 0) == 0; Cari faktor 2 jika (~ $ a & 1) A adalah walaupun; jika ($ b & 1) b adalah ganjil; Lain -lain kedua -dua A dan B juga; jika (~ $ b & 1) A adalah ganjil, B juga; mengurangkan bilangan yang lebih besar; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == $ b ) return $ a ; if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; { return gcd ( $ a >> 1 , $ b ) ; return gcd ( $ a >> 1 , $ b >> 1 ) << 1 ; } return gcd ( $ a , $ b >> 1 ) ; if ( $ a > $ b ) return gcd ( ( $ a - $ b ) >> 1 , $ b ) ; return gcd ( ( $ b - $ a ) >> 1 , $ a ) ; } $ a = 34 ; $ b = 17 ; echo \" Gcd ▁ of ▁ given ▁ numbers ▁ is : ▁ \" , gcd ( $ a , $ b ) ; ? >"}
{"text": "Cetak semua n | N, SUM -> Nilai Input Out -> Output Array Index -> Indeks Digit Seterusnya untuk diisi dalam pelbagai output; Kes asas; Jika nombor menjadi n - digit; Jika jumlah digitnya sama dengan jumlah yang diberikan, cetaknya; Melintasi setiap digit. Perhatikan bahawa di sini kita akan mempertimbangkan untuk memimpin sebagai digit; tambah digit semasa ke nombor; berulang untuk digit seterusnya dengan jumlah yang dikurangkan; Ini terutamanya pembungkus atas findndigitnumsutil. Ia secara eksplisit mengendalikan digit utama; Arahan output untuk menyimpan nombor N - digit; Isi kedudukan 1 st oleh setiap digit dari 1 hingga 9 dan panggilan findnDigitNumsUtil () untuk kedudukan yang tinggal; Kod pemacu", "code": "< ? php function findNDigitNumsUtil ( $ n , $ sum , $ out , $ index ) { if ( $ index > $ n $ sum < 0 ) return ; if ( $ index == $ n ) { if ( $ sum == 0 ) { $ out [ $ index ] = ' ' ; foreach ( $ out as & $ value ) print ( $ value ) ; print ( \" ▁ \" ) ; } return ; } for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { $ out [ $ index ] = chr ( $ i + ord ( '0' ) ) ; findNDigitNumsUtil ( $ n , $ sum - $ i , $ out , $ index + 1 ) ; } } function findNDigitNums ( $ n , $ sum ) { $ out = array_fill ( 0 , $ n + 1 , false ) ; for ( $ i = 1 ; $ i <= 9 ; $ i ++ ) { $ out [ 0 ] = chr ( $ i + ord ( '0' ) ) ; findNDigitNumsUtil ( $ n , $ sum - $ i , $ out , 1 ) ; } } $ n = 2 ; $ sum = 3 ; findNDigitNums ( $ n , $ sum ) ; ? >"}
{"text": "Palindromic Prima | Fungsi yang mengembalikan hanya jika NUM mengandungi satu digit; Operasi perbandingan lebih cepat daripada operasi pembahagian. Jadi menggunakan berikut dan bukannya \"kembali ~» u 10 = ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ »; Fungsi rekursif untuk mengetahui sama ada NUM adalah palindrome atau tidak. Pada mulanya, Dupnum mengandungi alamat salinan NUM. ; Kes asas (diperlukan untuk penamatan rekursi): Pernyataan ini / terutamanya membandingkan digit pertama dengan digit terakhir; Ini adalah garis utama dalam kaedah ini. Perhatikan bahawa semua rekursif / panggilan mempunyai salinan NUM yang berasingan, tetapi mereka semua berkongsi salinan Dupnum yang sama. Kami membahagikan NUM sambil bergerak ke atas pokok rekursi; Kenyataan berikut dilaksanakan apabila kita bergerak ke atas pokok panggilan rekursi; Pada ketika ini, jika Num % 10 mengandungi digit ith dari awal, maka (dupnum) % 10 mengandungi digit ith dari akhir; Fungsi utama yang menggunakan fungsi rekursif ispalutil () untuk mengetahui sama ada NUM adalah palindrome atau tidak; Jika num negatif, menjadikannya positif; Buat salinan NUM yang berasingan, supaya pengubahsuaian dibuat untuk menangani Dupnum Don 't menukar nombor input.  $ dupnum = $ num; dupnum = num; Berfungsi untuk menjana semua prima dan memeriksa sama ada nombor adalah palindromic atau tidak; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cetak semua nombor perdana palindromik; Memeriksa sama ada nombor yang diberikan adalah Palindromic Perdana atau tidak; Kod pemacu", "code": "< ? php function oneDigit ( $ num ) { return ( $ num >= 0 && $ num < 10 ) ; } function isPalUtil ( $ num , $ dupNum ) { if ( oneDigit ( $ num ) ) return ( $ num == ( $ dupNum ) % 10 ) ; if ( ! isPalUtil ( ( int ) ( $ num / 10 ) , $ dupNum ) ) return false ; $ dupNum = ( int ) ( $ dupNum / 10 ) ; return ( $ num % 10 == ( $ dupNum ) % 10 ) ; } function isPal ( $ num ) { if ( $ num < 0 ) $ num = - $ num ; return isPalUtil ( $ num , $ dupNum ) ; } function printPalPrimesLessThanN ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) { $ prime [ $ i ] = false ; } } } for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] && isPal ( $ p ) ) { print ( $ p . \" \" ) ; } } } $ n = 100 ; print ( \" Palindromic ▁ primes ▁ smaller ▁ \" . \" than ▁ or ▁ equal ▁ to ▁ \" . $ n . \" ▁ are ▁ : STRNEWLINE \" ) ; printPalPrimesLessThanN ( $ n ) ; ? >"}
{"text": "Hampir Nombor Perdana | Fungsi untuk mengira semua faktor utama nombor tertentu; Kira bilangan 2 s yang membahagikan n; n mesti ganjil pada ketika ini. Jadi kita boleh melangkau satu elemen (nota i = i + 2); Walaupun saya membahagikan n, kiraan saya dan membahagikan n; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Fungsi untuk mencetak nombor N pertama yang k - hampir prima. ; Cetak nombor ini jika ia adalah K - Perdana; Kiraan kenaikan k - prima dicetak setakat ini; Kod pemacu", "code": "< ? php function countPrimeFactors ( $ n ) { $ count = 0 ; while ( $ n % 2 == 0 ) { $ n = $ n / 2 ; $ count ++ ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { while ( $ n % $ i == 0 ) { $ n = $ n / $ i ; $ count ++ ; } } if ( $ n > 2 ) $ count ++ ; return ( $ count ) ; } function printKAlmostPrimes ( $ k , $ n ) { for ( $ i = 1 , $ num = 2 ; $ i <= $ n ; $ num ++ ) { if ( countPrimeFactors ( $ num ) == $ k ) { echo ( $ num ) ; echo ( \" ▁ \" ) ; $ i ++ ; } } return ; } $ n = 10 ; $ k = 2 ; echo \" First ▁ $ n ▁ $ k - almost ▁ prime ▁ numbers : STRNEWLINE \" ; printKAlmostPrimes ( $ k , $ n ) ; ? >"}
{"text": "Program untuk menambah dua pecahan | Berfungsi untuk mengembalikan GCD A dan B; Berfungsi untuk menukar pecahan yang diperolehi ke dalam bentuk yang paling mudah; Mencari GCD kedua -dua istilah; Menukar kedua -dua istilah ke dalam istilah yang lebih mudah dengan membahagikannya dengan faktor umum; Berfungsi untuk menambah dua pecahan; Mencari GCD DEN1 dan DEN2; Penyebut pecahan akhir diperolehi mencari LCM DEN1 dan DEN2 LCM * GCD = A * B; Menukar pecahan untuk mempunyai pengangka penyebut yang sama dari pecahan akhir yang diperolehi; Fungsi memanggil untuk menukar pecahan akhir ke dalam bentuk yang paling mudah; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function lowest ( & $ den3 , & $ num3 ) { $ common_factor = gcd ( $ num3 , $ den3 ) ; $ den3 = ( int ) $ den3 / $ common_factor ; $ num3 = ( int ) $ num3 / $ common_factor ; } function addFraction ( $ num1 , $ den1 , $ num2 , $ den2 , & $ num3 , & $ den3 ) { $ den3 = gcd ( $ den1 , $ den2 ) ; $ den3 = ( $ den1 * $ den2 ) / $ den3 ; $ num3 = ( $ num1 ) * ( $ den3 / $ den1 ) + ( $ num2 ) * ( $ den3 / $ den2 ) ; lowest ( $ den3 , $ num3 ) ; } $ num1 = 1 ; $ den1 = 500 ; $ num2 = 2 ; $ den2 = 1500 ; $ den3 ; $ num3 ; addFraction ( $ num1 , $ den1 , $ num2 , $ den2 , $ num3 , $ den3 ) ; echo $ num1 , \" / \" , $ den1 , \" ▁ + ▁ \" , $ num2 , \" / \" , $ den2 , \" ▁ is ▁ equal ▁ to ▁ \" , $ num3 , \" / \" , $ den3 , \" STRNEWLINE \" ; ? >"}
{"text": "Masalah Lazy Caterer | Fungsi ini menerima integer n dan mengembalikan bilangan maksimum kepingan yang boleh dibuat sebagai pancake menggunakan pemotongan N; Gunakan formula; Kod pemacu", "code": "< ? php function findPieces ( $ n ) { return ( $ n * ( $ n + 1 ) ) / 2 + 1 ; } echo findPieces ( 1 ) , \" STRNEWLINE \" ; echo findPieces ( 2 ) , \" STRNEWLINE \" ; echo findPieces ( 3 ) , \" STRNEWLINE \" ; echo findPieces ( 50 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Mengira digit dalam faktorial | Tetapkan 2 | Mengembalikan bilangan digit yang hadir di N! Oleh kerana hasilnya boleh lama panjang digunakan sebagai jenis pulangan; faktorial nombor tidak ada; Kes asas; Gunakan formula Kamenetsky untuk mengira bilangan digit; Kod pemacu", "code": "< ? php function findDigits ( $ n ) { if ( $ n < 0 ) return 0 ; if ( $ n <= 1 ) return 1 ; $ x = ( ( $ n * log10 ( $ n / M_E ) + log10 ( 2 * M_PI * $ n ) / 2.0 ) ) ; return floor ( $ x ) + 1 ; } echo findDigits ( 1 ) . \" STRNEWLINE \" ; echo findDigits ( 50000000 ) . \" STRNEWLINE \" ; echo findDigits ( 1000000000 ) . \" STRNEWLINE \" ; echo findDigits ( 120 ) ; ? >"}
{"text": "Mengira digit dalam faktorial | Tetapkan 1 | Fungsi ini menerima integer n, dan mengembalikan bilangan digit yang ada di N! ; Faktorial wujud hanya untuk n> = 0; Kes asas; Lain -lain melewati n dan hitung nilai; Kod pemacu", "code": "< ? php function findDigits ( $ n ) { if ( $ n < 0 ) return 0 ; if ( $ n <= 1 ) return 1 ; $ digits = 0 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ digits += log10 ( $ i ) ; return floor ( $ digits ) + 1 ; } echo findDigits ( 1 ) , \" STRNEWLINE \" ; echo findDigits ( 5 ) , \" STRNEWLINE \" ; echo findDigits ( 10 ) , \" STRNEWLINE \" ; echo findDigits ( 120 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari Bilangan Subarrays Dengan Jumlah Jumlah | Program PHP untuk mengira bilangan sub -susunan yang jumlahnya juga menggunakan kerumitan masa kekerasan - O (n ^ 2) kerumitan ruang - O (1); Cari jumlah semua subarrays dan hasil kenaikan jika jumlahnya juga; Kod pemacu", "code": "< ? php function countEvenSum ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ sum = 0 ; for ( $ j = $ i ; $ j <= $ n - 1 ; $ j ++ ) { $ sum = $ sum + $ arr [ $ j ] ; if ( $ sum % 2 == 0 ) $ result ++ ; } } return ( $ result ) ; } $ arr = array ( 1 , 2 , 2 , 3 , 4 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" The ▁ Number ▁ of ▁ Subarrays ▁ \" , \" with ▁ even ▁ sum ▁ is ▁ \" , countEvenSum ( $ arr , $ n ) ; ? >"}
{"text": "Cari Bilangan Subarrays Dengan Jumlah Jumlah | Program PHP untuk mengira bilangan sub -tatasusunan dengan jumlah keseluruhan menggunakan kerumitan masa algoritma yang cekap - o (n) kerumitan ruang - O (1); Arahan sementara saiz 2. Temp [0] akan menyimpan kiraan walaupun subarrays dan temp [1] kiraan ganjil. Temp [0] diasaskan sebagai 1 kerana terdapat satu elemen walaupun juga dikira sebagai subarray; Menghitung kiraan. Jumlah adalah jumlah elemen di bawah modulo 2 dan berakhir dengan arr [i]. ; Saya 'mengira »' u ur [0. . i] »» Modulo u dan kenaikan ~ walaupun / ganjil ~ Menurut nilai 'ke nilai; 2 ditambah untuk mengendalikan nombor negatif; Kenaikan kiraan / ganjil; Gunakan Lemma Handshake untuk mengira walaupun subarrays (perhatikan bahawa walaupun boleh dibentuk oleh dua atau dua ganjil); Kod pemacu", "code": "< ? php function countEvenSum ( $ arr , $ n ) { $ temp = array ( 1 , 0 ) ; $ result = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ sum = ( ( $ sum + $ arr [ $ i ] ) % 2 + 2 ) % 2 ; $ temp [ $ sum ] ++ ; } $ result = $ result + ( int ) ( $ temp [ 0 ] * ( $ temp [ 0 ] - 1 ) / 2 ) ; $ result = $ result + ( int ) ( $ temp [ 1 ] * ( $ temp [ 1 ] - 1 ) / 2 ) ; return ( $ result ) ; } $ arr = array ( 1 , 2 , 2 , 3 , 4 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" The ▁ Number ▁ of ▁ Subarrays ▁ \" . \" with ▁ even \" , \" ▁ sum ▁ is ▁ \" , countEvenSum ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah nombor Fibonacci | Mengira nilai nombor Fibonacci pertama; Memulakan hasil; Tambah istilah yang tinggal; Kod pemacu", "code": "< ? php function calculateSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = $ fibo [ 0 ] + $ fibo [ 1 ] ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; $ sum += $ fibo [ $ i ] ; } return $ sum ; } $ n = 4 ; echo \" Sum ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ \" , calculateSum ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah nombor Fibonacci | Program PHP untuk mencari jumlah nombor Fibonacci dalam masa O (log n). ; Buat array untuk memoisasi; Mengembalikan nombor fibonacci n 'th menggunakan jadual f []; Kes asas; Jika FIB (n) sudah dikira; Memohon formula di atas [Nota Nota N & 1 adalah 1 jika n adalah ganjil, lain 0]. ; Mengira nilai nombor Fibonacci pertama; Kod pemacu", "code": "< ? php $ MAX = 1000 ; $ f = array_fill ( 0 , $ MAX , 0 ) ; function fib ( $ n ) { global $ f ; if ( $ n == 0 ) return 0 ; if ( $ n == 1 $ n == 2 ) return ( $ f [ $ n ] = 1 ) ; if ( $ f [ $ n ] ) return $ f [ $ n ] ; $ k = ( $ n & 1 ) ? ( $ n + 1 ) / 2 : $ n / 2 ; $ f [ $ n ] = ( $ n & 1 ) ? ( fib ( $ k ) * fib ( $ k ) + fib ( $ k - 1 ) * fib ( $ k - 1 ) ) : ( 2 * fib ( $ k - 1 ) + fib ( $ k ) ) * fib ( $ k ) ; return $ f [ $ n ] ; } function calculateSum ( $ n ) { return fib ( $ n + 2 ) - 1 ; } $ n = 4 ; print ( \" Sum ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ \" . calculateSum ( $ n ) ) ; ? >"}
{"text": "Cari semua kombinasi yang menambah nombor diberikan sehingga | Arr - Array Untuk menyimpan indeks gabungan - lokasi seterusnya dalam array num - bilangan yang diberikan dikurangkanNum - bilangan yang dikurangkan; Keadaan asas; Jika gabungan dijumpai, cetaknya; Cari nombor sebelumnya yang disimpan dalam arr [] ia membantu dalam mengekalkan perintah yang semakin meningkat; Nota Loop bermula dari nombor sebelumnya i. e. pada Indeks Lokasi Array - 1; Elemen seterusnya adalah k; Panggil secara rekursif dengan bilangan yang dikurangkan; Fungsi untuk mengetahui semua kombinasi nombor positif yang menambah nombor yang diberikan. Ia menggunakan findCombinationsUtil (); array untuk menyimpan kombinasi ia boleh mengandungi elemen maksimum; Cari semua kombinasi; Kod pemacu", "code": "< ? php function findCombinationsUtil ( $ arr , $ index , $ num , $ reducedNum ) { if ( $ reducedNum < 0 ) return ; if ( $ reducedNum == 0 ) { for ( $ i = 0 ; $ i < $ index ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; echo \" STRNEWLINE \" ; return ; } $ prev = ( $ index == 0 ) ? 1 : $ arr [ $ index - 1 ] ; for ( $ k = $ prev ; $ k <= $ num ; $ k ++ ) { $ arr [ $ index ] = $ k ; findCombinationsUtil ( $ arr , $ index + 1 , $ num , $ reducedNum - $ k ) ; } } function findCombinations ( $ n ) { $ arr = array ( ) ; findCombinationsUtil ( $ arr , 0 , $ n , $ n ) ; } $ n = 5 ; findCombinations ( $ n ) ; ? >"}
{"text": "Cari akar persegi di bawah modulo p | Tetapkan 2 (Shanks Algoritma Tonelli) | fungsi utiliti untuk mencari modulus POW (asas, eksponen) %; fungsi utiliti untuk mencari GCD; Mengembalikan k sedemikian rupa sehingga b ^ k = 1 (mod p); Memulakan k dengan nombor perdana ganjil pertama; fungsi kembali p - 1 (= x argumen) sebagai x * 2 ^ e, di mana x akan menghantar ganjil e sebagai rujukan kerana pengemaskinian diperlukan dalam e sebenar; Fungsi utama untuk mencari akar persegi modular; A dan P harus menjadi coprime untuk mencari akar persegi modular; Jika di bawah ekspresi pulangan (p - 1) maka akar persegi modular tidak mungkin; menyatakan p - 1, dari segi s * 2 ^ e, di mana s adalah nombor ganjil; mencari q terkecil sedemikian rupa sehingga q ^ ((p - 1) / 2) (mod p) = p - 1; Q - 1 berada di tempat ( - 1 % p); Memulakan pembolehubah x, b dan g; teruskan gelung sehingga b menjadi 1 atau m menjadi 0; mencari m seperti B ^ (2 ^ m) = 1; mengemas kini nilai x, g dan b mengikut algoritma; Kod pemacu; P harus menjadi perdana", "code": "< ? php function pow1 ( $ base , $ exponent , $ modulus ) { $ result = 1 ; $ base = $ base % $ modulus ; while ( $ exponent > 0 ) { if ( $ exponent % 2 == 1 ) $ result = ( $ result * $ base ) % $ modulus ; $ exponent = $ exponent >> 1 ; $ base = ( $ base * $ base ) % $ modulus ; } return $ result ; } function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; else return gcd ( $ b , $ a % $ b ) ; } function order ( $ p , $ b ) { if ( gcd ( $ p , $ b ) != 1 ) { print ( \" p ▁ and ▁ b ▁ are ▁ not ▁ co - prime . STRNEWLINE \" ) ; return -1 ; } $ k = 3 ; while ( 1 ) { if ( pow1 ( $ b , $ k , $ p ) == 1 ) return $ k ; $ k ++ ; } } function convertx2e ( $ x , & $ e ) { $ e = 0 ; while ( $ x % 2 == 0 ) { $ x = ( int ) ( $ x / 2 ) ; $ e ++ ; } return $ x ; } function STonelli ( $ n , $ p ) { if ( gcd ( $ n , $ p ) != 1 ) { print ( \" a ▁ and ▁ p ▁ are ▁ not ▁ coprime STRNEWLINE \" ) ; return -1 ; } if ( pow1 ( $ n , ( $ p - 1 ) / 2 , $ p ) == ( $ p - 1 ) ) { printf ( \" no ▁ sqrt ▁ possible STRNEWLINE \" ) ; return -1 ; } $ e = 0 ; $ s = convertx2e ( $ p - 1 , $ e ) ; $ q = 2 ; for ( ; ; $ q ++ ) { if ( pow1 ( $ q , ( $ p - 1 ) / 2 , $ p ) == ( $ p - 1 ) ) break ; } $ x = pow1 ( $ n , ( $ s + 1 ) / 2 , $ p ) ; $ b = pow1 ( $ n , $ s , $ p ) ; $ g = pow1 ( $ q , $ s , $ p ) ; $ r = $ e ; while ( 1 ) { $ m = 0 ; for ( ; $ m < $ r ; $ m ++ ) { if ( order ( $ p , $ b ) == -1 ) return -1 ; if ( order ( $ p , $ b ) == pow ( 2 , $ m ) ) break ; } if ( $ m == 0 ) return $ x ; $ x = ( $ x * pow1 ( $ g , pow ( 2 , $ r - $ m - 1 ) , $ p ) ) % $ p ; $ g = pow1 ( $ g , pow ( 2 , $ r - $ m ) , $ p ) ; $ b = ( $ b * $ g ) % $ p ; if ( $ b == 1 ) return $ x ; $ r = $ m ; } } $ n = 2 ; $ p = 113 ; $ x = STonelli ( $ n , $ p ) ; if ( $ x == -1 ) print ( \" Modular ▁ square ▁ root ▁ is ▁ not ▁ exist STRNEWLINE \" ) ; else print ( \" Modular ▁ square ▁ root ▁ of ▁ \" . \" $ n ▁ and ▁ $ p ▁ is ▁ $ x STRNEWLINE \" ) ; ? >"}
{"text": "Semak jika nombor adalah kuasa nombor lain | Program PHP untuk menyemak nombor nombor Y; fungsi logaritma untuk mengira nilai; Nota: Ini adalah dua kali ganda; Bandingkan dengan hasil1 atau hasil2 kedua -duanya adalah sama; Kod pemacu", "code": "< ? php function isPower ( $ x , $ y ) { $ res1 = log ( $ y ) / log ( $ x ) ; $ res2 = log ( $ y ) / log ( $ x ) ; return ( $ res1 == $ res2 ) ; } echo isPower ( 27 , 729 ) ; ? >"}
{"text": "Program untuk mencari akar persamaan kuadrat | Cetak akar persamaan kuadratik kapak * 2 + bx + x; Jika A adalah 0, maka persamaan tidak kuadratik, tetapi linear; d <0; Kod pemacu; Panggilan fungsi", "code": "< ? php function findRoots ( $ a , $ b , $ c ) { if ( $ a == 0 ) { echo \" Invalid \" ; return ; } $ d = $ b * $ b - 4 * $ a * $ c ; $ sqrt_val = sqrt ( abs ( $ d ) ) ; if ( $ d > 0 ) { echo \" Roots ▁ are ▁ real ▁ and ▁ \" . \" different ▁ STRNEWLINE \" ; echo ( - $ b + $ sqrt_val ) / ( 2 * $ a ) , \" STRNEWLINE \" , ( - $ b - $ sqrt_val ) / ( 2 * $ a ) ; } else if ( $ d == 0 ) { echo \" Roots ▁ are ▁ real ▁ and ▁ same ▁ STRNEWLINE \" ; echo - $ b / ( 2 * $ a ) ; } else { echo \" Roots ▁ are ▁ complex ▁ STRNEWLINE \" ; echo - $ b / ( 2 * $ a ) , \" ▁ + ▁ i \" , $ sqrt_val , \" STRNEWLINE \" , - $ b / ( 2 * $ a ) , \" ▁ - ▁ i \" , $ sqrt_val ; } } $ a = 1 ; $ b = -7 ; $ c = 12 ; findRoots ( $ a , $ b , $ c ) ; ? >"}
{"text": "Semak Square Square Menggunakan Tambahan / Penolakan | Fungsi ini kembali benar jika n adalah persegi sempurna, lain -lain palsu; Jumlah adalah jumlah semua nombor ganjil. Saya digunakan satu demi satu memegang nombor ganjil; Kod pemacu", "code": "< ? php function isPerfectSquare ( $ n ) { for ( $ sum = 0 , $ i = 1 ; $ sum < $ n ; $ i += 2 ) { $ sum += $ i ; if ( $ sum == $ n ) return true ; } return false ; } if ( isPerfectSquare ( 35 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; if ( isPerfectSquare ( 49 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Count 'd' digit positif positif dengan 0 sebagai digit | Mengembalikan kiraan integer digit 'D' mempunyai 0 sebagai digit; Kod pemacu", "code": "< ? php function findCount ( $ d ) { return 9 * ( pow ( 10 , $ d - 1 ) - pow ( 9 , $ d - 1 ) ) ; } { $ d = 1 ; echo findCount ( $ d ) , \" STRNEWLINE \" ; $ d = 2 ; echo findCount ( $ d ) , \" STRNEWLINE \" ; $ d = 4 ; echo findCount ( $ d ) , \" STRNEWLINE \" ; return 0 ; } ? >"}
{"text": "Laluan Dyck | Mengembalikan kiraan laluan Dyck dalam grid n x n; Nilai pengiraan 2 ncn; kembali 2 ncn / (n + 1); Kod pemacu", "code": "< ? php function countDyckPaths ( $ n ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ res *= ( 2 * $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res / ( $ n + 1 ) ; } $ n = 4 ; echo \" Number ▁ of ▁ Dyck ▁ Paths ▁ is ▁ \" , countDyckPaths ( $ n ) ; ? >"}
{"text": "Nombor segi tiga | Pulangan benar jika 'num' adalah segi tiga, lain -lain palsu; Kes asas; Nombor segi tiga mestilah jumlah nombor semulajadi n pertama; Kod pemacu", "code": "< ? php function isTriangular ( $ num ) { if ( $ num < 0 ) return false ; $ sum = 0 ; for ( $ n = 1 ; $ sum <= $ num ; $ n ++ ) { $ sum = $ sum + $ n ; if ( $ sum == $ num ) return true ; } return false ; } $ n = 55 ; if ( isTriangular ( $ n ) ) echo \" The ▁ number ▁ is ▁ a ▁ triangular ▁ number \" ; else echo \" The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number \" ; ? >"}
{"text": "Nombor segi tiga | Pulangan benar jika Num adalah segi tiga; Memandangkan persamaan n * (n + 1) / 2 = num persamaan adalah: a (n ^ 2) + bn + c = 0 \";; cari akar persamaan; memeriksa jika root1 adalah semula jadi; memeriksa jika root2 adalah semula jadi; kod pemacu", "code": "< ? php function isTriangular ( $ num ) { if ( $ num < 0 ) return false ; $ c = ( -2 * $ num ) ; $ b = 1 ; $ a = 1 ; $ d = ( $ b * $ b ) - ( 4 * $ a * $ c ) ; if ( $ d < 0 ) return false ; $ root1 = ( - $ b + ( float ) sqrt ( $ d ) ) / ( 2 * $ a ) ; $ root2 = ( - $ b - ( float ) sqrt ( $ d ) ) / ( 2 * $ a ) ; if ( $ root1 > 0 && floor ( $ root1 ) == $ root1 ) return true ; if ( $ root2 > 0 && floor ( $ root2 ) == $ root2 ) return true ; return false ; } $ num = 55 ; if ( isTriangular ( $ num ) ) echo ( \" The ▁ number ▁ is \" . \" ▁ a ▁ triangular ▁ number \" ) ; else echo ( \" The ▁ number ▁ \" . \" is ▁ NOT ▁ a ▁ triangular ▁ number \" ) ; ? >"}
{"text": "Tukar dari mana -mana pangkalan ke perpuluhan dan sebaliknya | Untuk mengembalikan nilai char. Sebagai contoh, 2 dikembalikan untuk '2'. 10 dikembalikan untuk 'A', 11 untuk 'B'; Berfungsi untuk menukar nombor dari asas 'b' yang diberikan kepada perpuluhan; Memulakan kuasa asas; Memulakan hasil; Bersamaan perpuluhan adalah str [len - 1] * 1 + str [len - 2] * asas + str [len - 3] * (asas ^ 2) + ...; Digit dalam nombor input mestilah kurang daripada asas nombor; Kod pemacu", "code": "< ? php function val ( $ c ) { if ( $ c >= '0' && $ c <= '9' ) return ord ( $ c ) - ord ( '0' ) ; else return ord ( $ c ) - ord ( ' A ' ) + 10 ; } function toDeci ( $ str , $ base ) { $ len = strlen ( $ str ) ; $ power = 1 ; $ num = 0 ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { if ( val ( $ str [ $ i ] ) >= $ base ) { print ( \" Invalid ▁ Number \" ) ; return -1 ; } $ num += val ( $ str [ $ i ] ) * $ power ; $ power = $ power * $ base ; } return $ num ; } $ str = \"11A \" ; $ base = 16 ; print ( \" Decimal ▁ equivalent ▁ of ▁ $ str ▁ \" . \" in ▁ base ▁ $ base ▁ is ▁ \" . toDeci ( $ str , $ base ) ) ; ? >"}
{"text": "Masalah Koin Frobenius | Fungsi utiliti untuk mencari GCD; Berfungsi untuk mencetak output yang dikehendaki; Penyelesaian tidak wujud jika GCD tidak 1; Lain memohon formula; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { $ c ; while ( $ a != 0 ) { $ c = $ a ; $ a = $ b % $ a ; $ b = $ c ; } return $ b ; } function forbenius ( $ X , $ Y ) { if ( gcd ( $ X , $ Y ) != 1 ) { echo \" NA STRNEWLINE \" ; return ; } $ A = ( $ X * $ Y ) - ( $ X + $ Y ) ; $ N = ( $ X - 1 ) * ( $ Y - 1 ) / 2 ; echo \" Largest Amount = \" , ▁ $ A , ▁ \" \" ; STRNEWLINE TABSYMBOL echo ▁ \" Total Count = \" , ▁ $ N , ▁ \" \" } $ X = 2 ; $ Y = 5 ; forbenius ( $ X , $ Y ) ; $ X = 5 ; $ Y = 10 ; echo \" STRNEWLINE \" ; forbenius ( $ X , $ Y ) ; ? >"}
{"text": "Kelabu ke Perduaan dan Perduaan kepada Penukaran Kelabu | Fungsi penolong kepada XOR dua aksara; Fungsi penolong untuk membalikkan bit; berfungsi untuk menukar rentetan binari ke rentetan kelabu; MSB kod kelabu adalah sama dengan kod binari; Mengira baki baki, bit seterusnya dikira dengan melakukan XOR sebelumnya dan semasa dalam binari; Concatenate xor bit sebelumnya dengan bit semasa; berfungsi untuk menukar rentetan kod kelabu ke rentetan binari; MSB kod binari adalah sama dengan kod kelabu; Mengira bit yang tinggal; Jika bit semasa adalah 0, concatenate bit sebelumnya; Lain, concatenate terbalik sedikit sebelumnya; Kod pemacu", "code": "< ? php function xor_c ( $ a , $ b ) { return ( $ a == $ b ) ? '0' : '1' ; } function flip ( $ c ) { return ( $ c == '0' ) ? '1' : '0' ; } function binarytoGray ( $ binary ) { $ gray = \" \" ; $ gray . = $ binary [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ binary ) ; $ i ++ ) { $ gray . = xor_c ( $ binary [ $ i - 1 ] , $ binary [ $ i ] ) ; } return $ gray ; } function graytoBinary ( $ gray ) { $ binary = \" \" ; $ binary . = $ gray [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ gray ) ; $ i ++ ) { if ( $ gray [ $ i ] == '0' ) $ binary . = $ binary [ $ i - 1 ] ; else $ binary . = flip ( $ binary [ $ i - 1 ] ) ; } return $ binary ; } $ binary = \"01001\" ; print ( \" Gray ▁ code ▁ of ▁ \" . $ binary . \" ▁ is ▁ \" . binarytoGray ( $ binary ) . \" STRNEWLINE \" ) ; $ gray = \"01101\" ; print ( \" Binary ▁ code ▁ of ▁ \" . $ gray . \" ▁ is ▁ \" . graytoBinary ( $ gray ) ) ; ? >"}
{"text": "Penyelesaian f (n) = (1) + (2 * 3) + (4 * 5 * 6). . . n Menggunakan rekursi | Fungsi rekursif untuk mencari jumlah siri yang dikira - bilangan terma sehingga jumlah terma telah dikira semasa - bilangan istilah yang mana jumlahnya harus dikira n - bilangan istilah dalam fungsi yang akan dikira; Memeriksa keadaan penamatan; produk terma sehingga semasa; Panggilan rekursif untuk menambahkan istilah seterusnya dalam siri ini; nombor input istilah dalam siri ini; memohon fungsi untuk mengira jumlah", "code": "< ? php function seriesSum ( $ calculated , $ current , $ N ) { $ i ; $ cur = 1 ; if ( $ current == $ N + 1 ) return 0 ; for ( $ i = $ calculated ; $ i < $ calculated + $ current ; $ i ++ ) $ cur *= $ i ; return $ cur + seriesSum ( $ i , $ current + 1 , $ N ) ; } $ N = 5 ; echo ( seriesSum ( 1 , 1 , $ N ) ) ; ? >"}
{"text": "Kirakan N! di bawah modulo p | Pulangan nilai n! % p; Kod pemacu", "code": "< ? php function modFact ( $ n , $ p ) { if ( $ n >= $ p ) return 0 ; $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ result = ( $ result * $ i ) % $ p ; return $ result ; } $ n = 25 ; $ p = 29 ; echo modFact ( $ n , $ p ) ; ? >"}
{"text": "Teorem Sisa Cina | Tetapkan 2 (Pelaksanaan Berasaskan Modulo songsang) | Mengembalikan modulo songsang dengan m menggunakan algoritma euclid yang dilanjutkan. Rujuk di bawah posting untuk butiran: https: www. Geeksforgeeks. org / multiplicative - songsang - bawah - modulo - m /; Memohon algoritma euclid yang dilanjutkan; Q adalah Quotient; M adalah selebihnya sekarang, proses sama seperti algo Euclid; Buat x1 positif; k adalah saiz num [] dan rem []. Mengembalikan nombor terkecil x seperti itu: x % num [0] = rem [0], x % num [1] = rem [1], ... ... ... ... ... ... ... x % num [k - 2] = Rem [k - 1] asumsi: nombor dalam num [] adalah pasangan coprime (pasangan gcd adalah 1); Mengira produk semua nombor; Memulakan hasil; Memohon formula di atas; Kod pemacu", "code": "< ? php function inv ( $ a , $ m ) { $ m0 = $ m ; $ x0 = 0 ; $ x1 = 1 ; if ( $ m == 1 ) return 0 ; while ( $ a > 1 ) { $ q = ( int ) ( $ a / $ m ) ; $ t = $ m ; $ m = $ a % $ m ; $ a = $ t ; $ t = $ x0 ; $ x0 = $ x1 - $ q * $ x0 ; $ x1 = $ t ; } if ( $ x1 < 0 ) $ x1 += $ m0 ; return $ x1 ; } function findMinX ( $ num , $ rem , $ k ) { $ prod = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ prod *= $ num [ $ i ] ; $ result = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ pp = ( int ) $ prod / $ num [ $ i ] ; $ result += $ rem [ $ i ] * inv ( $ pp , $ num [ $ i ] ) * $ pp ; } return $ result % $ prod ; } $ num = array ( 3 , 4 , 5 ) ; $ rem = array ( 2 , 3 , 1 ) ; $ k = sizeof ( $ num ) ; echo \" x ▁ is ▁ \" . findMinX ( $ num , $ rem , $ k ) ; ? >"}
{"text": "Teorem Sisa Cina | Tetapkan 1 (Pengenalan) | k adalah saiz num [] dan rem []. Mengembalikan nombor terkecil x seperti itu: x % num [0] = rem [0], x % num [1] = rem [1], ... ... ... ... ... ... ... x % num [k - 2] = Rem [k - 1] asumsi: nombor dalam num [] adalah pasangan coprime (pasangan gcd adalah 1); Seperti teorem sisa chinise, gelung ini akan sentiasa pecah. ; Semak sama ada baki X % Num [j] adalah Rem [J] atau tidak (untuk semua J dari 0 hingga K - 1); Jika semua yang tersisa dipadankan, kami dapati X; Lain cuba nombor seterusnya; Kod pemacu", "code": "< ? php function findMinX ( $ num , $ rem , $ k ) { while ( true ) { $ j ; for ( $ j = 0 ; $ j < $ k ; $ j ++ ) if ( $ x % $ num [ $ j ] != $ rem [ $ j ] ) break ; if ( $ j == $ k ) return $ x ; $ x ++ ; } return $ x ; } $ num = array ( 3 , 4 , 5 ) ; $ rem = array ( 2 , 3 , 1 ) ; $ k = sizeof ( $ num ) ; echo \" x ▁ is ▁ \" , findMinX ( $ num , $ rem , $ k ) ; ? >"}
{"text": "Kirakan NCR % P | Tetapkan 2 (Lucas Theorem) | Mengembalikan NCR % p. Dalam program berasaskan teorem Lucas ini, fungsi ini hanya dipanggil untuk n <p dan r <p. ; Arus C akan menyimpan baris terakhir Pascal Triangle pada akhir. Dan kemasukan terakhir baris terakhir ialah NCR; Baris atas segitiga Pascal; Satu dengan membina baris segitiga Pascal dari atas ke bawah; Isi penyertaan baris semasa menggunakan nilai baris sebelumnya; Fungsi berasaskan teorem Lucas yang mengembalikan NCR % p. Fungsi ini berfungsi seperti perpuluhan kepada fungsi rekursif penukaran binari. Mula -mula kita mengira digit terakhir N dan R dalam asas P, kemudian berulang untuk angka yang tinggal; Kes asas; Kirakan digit terakhir N dan R dalam asas P; Hasil hitung untuk digit terakhir yang dikira di atas, dan untuk baki digit. Gongangkan kedua -dua keputusan dan hitung hasil pendaraban dalam modulo p. ; $ r / $ p, $ p) * Digit terakhir n dan r ncrmodpdp ($ ni, $ ri, $ p)) % $ p; Baki digit; Kod pemacu", "code": "< ? php function nCrModpDP ( $ n , $ r , $ p ) { $ C = array_fill ( 0 , $ n + 1 , false ) ; $ C [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ r ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = ( $ C [ $ j ] + $ C [ $ j - 1 ] ) % $ p ; } return $ C [ $ r ] ; } function nCrModpLucas ( $ n , $ r , $ p ) { if ( $ r == 0 ) return 1 ; $ ni = $ n % $ p ; $ ri = $ r % $ p ; return ( nCrModpLucas ( $ n / $ p , } $ n = 1000 ; $ r = 900 ; $ p = 13 ; echo \" Value ▁ of ▁ nCr ▁ % ▁ p ▁ is ▁ \" , nCrModpLucas ( $ n , $ r , $ p ) ; ? >"}
{"text": "Cetak semua nombor yang baik dalam julat yang diberikan | Untuk memeriksa sama ada n adalah nombor yang baik dan tidak mengandungi 'digit' d '. ; Dapatkan digit terakhir dan mulakan jumlah dari sebelah kanan; Jika digit terakhir adalah d, kembali; Melintasi digit yang tersisa; Digit semasa; Jika digit adalah d atau digit kurang daripada atau sama dengan jumlah digit di sebelah kanan; Kemas kini jumlah dan n; Cetak nombor yang baik dalam julat [l, r]; Melintasi semua nombor dalam julat yang diberikan; Jika nombor semasa adalah baik, cetaknya. ; Kod pemacu; Cetak nombor yang baik di [l, r]", "code": "< ? php function isValid ( $ n , $ d ) { $ digit = $ n % 10 ; $ sum = $ digit ; if ( $ digit == $ d ) return false ; $ n = ( int ) ( $ n / 10 ) ; while ( $ n ) { $ digit = $ n % 10 ; if ( $ digit == $ d $ digit <= $ sum ) return false ; else { $ sum += $ digit ; $ n = ( int ) ( $ n / 10 ) ; } } return 1 ; } function printGoodNumbers ( $ L , $ R , $ d ) { for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { if ( isValid ( $ i , $ d ) ) echo $ i . \" \" ; } } $ L = 410 ; $ R = 520 ; $ d = 3 ; printGoodNumbers ( $ L , $ R , $ d ) ; ? >"}
{"text": "Teorem Zeckendorf (bukan | mengembalikan nombor fibonacci terbesar lebih kecil daripada atau sama dengan n.", "code": "< ? php function nearestSmallerEqFib ( $ n ) { if ( $ n == 0 $ n == 1 ) return $ n ; $ f1 = 0 ; $ f2 = 1 ; $ f3 = 1 ; while ( $ f3 <= $ n ) { $ f1 = $ f2 ; $ f2 = $ f3 ; $ f3 = $ f1 + $ f2 ; } return $ f2 ; } function printFibRepresntation ( $ n ) { while ( $ n > 0 ) { $ f = nearestSmallerEqFib ( $ n ) ; echo $ f , \" \" ; $ n = $ n - $ f ; } } $ n = 30 ; echo \" Non - neighbouring ▁ Fibonacci ▁ Representation ▁ of ▁ \" , $ n , \" ▁ is ▁ STRNEWLINE \" ; printFibRepresntation ( $ n ) ; ? >"}
{"text": "Mengira bilangan cara untuk membahagikan nombor dalam 4 bahagian | Penyelesaian berasaskan pengaturcaraan dinamik untuk mengira bilangan cara untuk mewakili N sebagai jumlah empat nombor; \"Bahagian\" adalah bilangan bahagian yang tersisa, n ialah nilai yang tersisa \"NextPart\" adalah titik permulaan dari mana kita mula cuba untuk bahagian seterusnya. ; Kes asas; Jika subproblem ini sudah diselesaikan; Kiraan bilangan cara untuk baki nombor n - saya tinggal bahagian \"bahagian - 1\", dan untuk semua bahagian yang berbeza dari 'NextPart' ke 'N'; Menyimpan jawapan yang dikira dalam jadual dan hasil kembali; Fungsi ini terutamanya memulakan jadual DP dan memanggil CountwaysUtil (); Kod pemacu", "code": "< ? php $ dp = array_fill ( 0 , 501 , array_fill ( 0 , 501 , array_fill ( 0 , 5 , -1 ) ) ) ; function countWaysUtil ( $ n , $ parts , $ nextPart ) { global $ dp ; if ( $ parts == 0 && $ n == 0 ) return 1 ; if ( $ n <= 0 $ parts <= 0 ) return 0 ; if ( $ dp [ $ n ] [ $ nextPart ] [ $ parts ] != -1 ) return $ dp [ $ n ] [ $ nextPart ] [ $ parts ] ; for ( $ i = $ nextPart ; $ i <= $ n ; $ i ++ ) $ ans += countWaysUtil ( $ n - $ i , $ parts - 1 , $ i ) ; return ( $ dp [ $ n ] [ $ nextPart ] [ $ parts ] = $ ans ) ; } function countWays ( $ n ) { return countWaysUtil ( $ n , 4 , 1 ) ; } $ n = 8 ; echo countWays ( $ n ) ; ? >"}
{"text": "Cari kembar terkecil dalam julat yang diberikan | Program PHP untuk mencari kembar terkecil dalam julat yang diberikan; Buat array Boolean \"Perdana [0 ... tinggi]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Cari kembar terkecil; Jika p tidak ditandakan, maka ia adalah perdana; Kemas kini semua gandaan P; Sekarang cetak kembar terkecil dalam julat; Kod pemacu", "code": "< ? php function printTwins ( $ low , $ high ) { $ prime = array_fill ( 0 , $ high + 1 , true ) ; $ twin = false ; $ prime [ 0 ] = $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p <= floor ( sqrt ( $ high ) ) + 1 ; $ p ++ ) { if ( $ prime [ $ p ] ) { for ( $ i = $ p * 2 ; $ i <= $ high ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ i = $ low ; $ i <= $ high ; $ i ++ ) { if ( $ prime [ $ i ] && $ prime [ $ i + 2 ] ) { print ( \" Smallest ▁ twins ▁ in ▁ given ▁ range : ▁ ( $ i , ▁ \" . ( $ i + 2 ) . \" ) \" ) ; $ twin = true ; break ; } } if ( $ twin == false ) print ( \" No ▁ such ▁ pair ▁ exists STRNEWLINE \" ) ; } printTwins ( 10 , 100 ) ; ? >"}
{"text": "Cari nombor jarang seterusnya | Program PHP untuk mencari nombor jarang seterusnya; Cari perwakilan binari X dan simpan dalam bin []. Bin [0] mengandungi bit paling tidak penting (LSB), bit seterusnya adalah dalam bin [1], dan sebagainya. ; Terdapat sedikit hasil saya, jadi tambah satu tambahan sedikit; Kedudukan sehingga semua bit dimuktamadkan; Bermula dari bit kedua (di sebelah LSB); Jika bit semasa dan bit sebelumnya adalah 1, tetapi bit seterusnya tidak 1.; Buat bit seterusnya 1; Buat semua bit sebelum bit semasa sebagai 0 untuk memastikan bahawa kita mendapat nombor seterusnya yang paling kecil; Kedudukan kedudukan set bit supaya bit dan bit ini sebelum ia tidak berubah pada masa akan datang. ; Cari setara perpuluhan bin []; Kod pemacu", "code": "< ? php function nextSparse ( $ x ) { $ bin = array ( ) ; while ( $ x != 0 ) { array_push ( $ bin , $ x & 1 ) ; $ x >>= 1 ; } array_push ( $ bin , 0 ) ; $ last_final = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ bin [ $ i ] == 1 && $ bin [ $ i - 1 ] == 1 && $ bin [ $ i + 1 ] != 1 ) { $ bin [ $ i + 1 ] = 1 ; for ( $ j = $ i ; $ j >= $ last_final ; $ j -- ) $ bin [ $ j ] = 0 ; $ last_final = $ i + 1 ; } } $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ ans += $ bin [ $ i ] * ( 1 << $ i ) ; return $ ans ; } $ x = 38 ; echo \" Next ▁ Sparse ▁ Number ▁ is ▁ \" . nextSparse ( $ x ) ; ? >"}
{"text": "Jumlah perbezaan bit di kalangan semua pasangan | Program PHP untuk mengira jumlah perbezaan bit pasangan; Memulakan hasil; melintasi semua bit; kiraan bilangan elemen dengan set bit i 'th; Tambah \"kiraan ~ ~ ~ ~ ~ u count) ~ ~ 2\" kepada jawapannya; Kod pemacu", "code": "< ? php function sumBitDifferences ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) ) $ count ++ ; $ ans += ( $ count * ( $ n - $ count ) * 2 ) ; } return $ ans ; } $ arr = array ( 1 , 3 , 5 ) ; $ n = sizeof ( $ arr ) ; echo sumBitDifferences ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cetak semua bukan | Fungsi untuk mencetak array arr [0. .. n - 1]; Fungsi rekursif untuk menjana semua urutan yang tidak meningkat dengan jumlah x arr [] -> unsur -unsur urutan semasa curr_sum -> sum curr_idx semasa -> indeks semasa dalam arr []; Jika jumlah semasa adalah sama dengan x, maka kami mendapati urutan; Cuba letakkan semua nombor dari 1 hingga x - curr_sum pada indeks semasa; Nombor yang diletakkan juga mesti lebih kecil daripada nombor yang diletakkan sebelumnya dan mungkin sama dengan nilai yang disimpan sebelumnya, i. e. , arr [curr_idx - 1] jika terdapat nombor sebelumnya; Nombor tempat di curr_idx; Berulang; Cuba nombor seterusnya; Pembungkus lebih daripada penjana (); Array untuk menyimpan urutan oleh satu; Kod pemacu", "code": "< ? php function printArr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; echo \" ▁ STRNEWLINE \" ; } function generateUtil ( $ x , $ arr , $ curr_sum , $ curr_idx ) { if ( $ curr_sum == $ x ) { printArr ( $ arr , $ curr_idx ) ; return ; } $ num = 1 ; while ( $ num <= $ x - $ curr_sum and ( $ curr_idx == 0 or $ num <= $ arr [ $ curr_idx - 1 ] ) ) { $ arr [ $ curr_idx ] = $ num ; generateUtil ( $ x , $ arr , $ curr_sum + $ num , $ curr_idx + 1 ) ; $ num ++ ; } } function generate ( $ x ) { $ arr = array ( ) ; generateUtil ( $ x , $ arr , 0 , 0 ) ; } $ x = 5 ; generate ( $ x ) ; ? >"}
{"text": "Nombor sempurna | Pulangan benar jika n sempurna; Untuk menyimpan jumlah pembahagi; Cari semua pembahagi dan tambahkannya; Jika jumlah pembahagi sama dengan n, maka n adalah nombor yang sempurna; Kod pemacu", "code": "< ? php function isPerfect ( $ n ) { $ sum = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ i * $ i != $ n ) $ sum = $ sum + $ i + ( int ) ( $ n / $ i ) ; else $ sum = $ sum + $ i ; } } if ( $ sum == $ n && $ n != 1 ) return true ; return false ; } echo \" Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000 STRNEWLINE \" ; for ( $ n = 2 ; $ n < 10000 ; $ n ++ ) if ( isPerfect ( $ n ) ) echo \" $ n ▁ is ▁ a ▁ perfect ▁ number STRNEWLINE \" ; ? >"}
{"text": "Semak jika nombor tertentu boleh diwakili dalam diberikan no. Digit di mana -mana asas | Pulangan benar jika 'num' boleh diwakili usind 'digit' digit dalam 'asas'; Kes asas; Sekiranya terdapat lebih daripada 1 digit kiri dan nombor lebih daripada asas, maka keluarkan digit terakhir dengan melakukan NUM / BASE, mengurangkan bilangan digit dan berulang; Kembali benar NUM boleh diwakili dalam digit 'Dig' di mana -mana pangkalan dari 2 hingga 32; Semak semua pangkalan satu demi satu; Kod pemacu", "code": "< ? php function checkUtil ( $ num , $ dig , $ base ) { if ( $ dig == 1 && $ num < $ base ) return true ; if ( $ dig > 1 && $ num >= $ base ) return checkUtil ( $ num / $ base , -- $ dig , $ base ) ; return false ; } function check ( $ num , $ dig ) { for ( $ base = 2 ; $ base <= 32 ; $ base ++ ) if ( checkUtil ( $ num , $ dig , $ base ) ) return true ; return false ; } $ num = 8 ; $ dig = 3 ; if ( check ( $ num , $ dig ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Bagaimana cara mengira mod sebilangan besar? | Berfungsi untuk mengira NUM (mod A); Memulakan hasil; Satu demi satu proses semua digit 'num'; Kod pemacu", "code": "< ? php function mod ( $ num , $ a ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ r = strlen ( $ num ) ; $ i ++ ) $ res = ( $ res * 10 + $ num [ $ i ] - '0' ) % $ a ; return $ res ; } $ num = \"12316767678678\" ; echo mod ( $ num , 10 ) ; ? >"}
{"text": "Modular Multiplicative Inverse | Kaedah naif untuk mencari modulor multiplikasi terbalik 'a' di bawah modulo 'm'; Kod pemacu; Panggilan fungsi", "code": "< ? php function modInverse ( $ a , $ m ) { for ( $ x = 1 ; $ x < $ m ; $ x ++ ) if ( ( ( $ a % $ m ) * ( $ x % $ m ) ) % $ m == 1 ) return $ x ; } $ a = 3 ; $ m = 11 ; echo modInverse ( $ a , $ m ) ; a . . . >"}
{"text": "Modular Multiplicative Inverse | Mengembalikan modulo songsang dengan m menggunakan asumsi algoritma euclid yang dilanjutkan: a dan m adalah coprimes, i. e. , GCD (a, m) = 1; Q adalah Quotient; M adalah selebihnya sekarang, proses sama seperti algo Euclid; Kemas kini Y dan X; Buat x positif; Kod pemacu; Panggilan fungsi", "code": "< ? php function modInverse ( $ a , $ m ) { $ m0 = $ m ; $ y = 0 ; $ x = 1 ; if ( $ m == 1 ) return 0 ; while ( $ a > 1 ) { $ q = ( int ) ( $ a / $ m ) ; $ t = $ m ; $ m = $ a % $ m ; $ a = $ t ; $ t = $ y ; $ y = $ x - $ q * $ y ; $ x = $ t ; } if ( $ x < 0 ) $ x += $ m0 ; return $ x ; } $ a = 3 ; $ m = 11 ; echo \" Modular ▁ multiplicative ▁ inverse ▁ is STRNEWLINE \" , modInverse ( $ a , $ m ) ; a . . . >"}
{"text": "Fungsi Totient Euler | Berfungsi untuk mengembalikan GCD A dan B; Kaedah mudah untuk menilai fungsi Euler Totient; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function phi ( $ n ) { $ result = 1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( gcd ( $ i , $ n ) == 1 ) $ result ++ ; return $ result ; } for ( $ n = 1 ; $ n <= 10 ; $ n ++ ) echo \" phi ( \" . $ n . \" ) ▁ = \" . phi ( $ n ) . \" STRNEWLINE \" ; I >"}
{"text": "Fungsi Totient Euler | Program PHP untuk mengira Euler 's quient »Function» menggunakan formula produk uLer; Memulakan hasil sebagai n; Pertimbangkan semua faktor utama n dan untuk setiap faktor utama p, menghasilkan hasil dengan (1 - 1 / p); Semak sama ada P adalah faktor utama. ; Jika ya, kemudian kemas kini n dan hasil; Jika n mempunyai faktor utama yang lebih besar daripada sqrt (n) (boleh ada - kebanyakan faktor utama seperti itu); Kod pemacu", "code": "< ? php function phi ( $ n ) { $ result = $ n ; for ( $ p = 2 ; $ p * $ p <= $ n ; ++ $ p ) { if ( $ n % $ p == 0 ) { while ( $ n % $ p == 0 ) $ n /= $ p ; $ result *= ( 1.0 - ( 1.0 / $ p ) ) ; } } if ( $ n > 1 ) $ result *= ( 1.0 - ( 1.0 / $ n ) ) ; return intval ( $ result ) ; } for ( $ n = 1 ; $ n <= 10 ; $ n ++ ) echo \" phi ( \" . $ n . \" ) ▁ = \" . phi ( $ n ) . \" STRNEWLINE \" ; I >"}
{"text": "Program yang cekap untuk mengira jumlah siri 1/1! + 1/2! + 1/3! + 1/4! +. . + 1 / n! | Fungsi utiliti untuk mencari; Fungsi mudah untuk mengembalikan nilai 1/1! + 1/2! +. . + 1 / n! ; Kod pemacu", "code": "< ? php function factorial ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res *= $ i ; return $ res ; } function sum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 1.0 / factorial ( $ i ) ; return $ sum ; } $ n = 5 ; echo ( sum ( $ n ) ) ; ? >"}
{"text": "Cari bilangan tanda tangan yang sah dari panjang yang diberikan | Pulangan nilai pekali binomial c (n, k); Kerana c (n, k) = c (n, n - k); Hitung nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Fungsi berasaskan pekali binomial untuk mencari nombor catalan n dalam masa O (n); Hitung nilai 2 ncn; kembali 2 ncn / (n + 1); Fungsi untuk mencari cara yang mungkin untuk meletakkan kurungan seimbang dalam ekspresi panjang n; Jika n adalah ganjil, tidak mungkin untuk membuat sebarang tanda kurung yang sah; Jika tidak, pulangan nombor catalan n / 2 '; Kod pemacu", "code": "< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; } function catalan ( $ n ) { $ c = binomialCoeff ( 2 * $ n , $ n ) ; return $ c / ( $ n + 1 ) ; } function findWays ( $ n ) { if ( $ n & 1 ) return 0 ; return catalan ( $ n / 2 ) ; } $ n = 6 ; echo \" Total ▁ possible ▁ expressions ▁ of ▁ length ▁ \" , $ n , \" ▁ is ▁ \" , findWays ( 6 ) ; ? >"}
{"text": "Program untuk menilai ekspresi mudah | Fungsi utiliti untuk memeriksa sama ada watak tertentu adalah operan; fungsi utiliti untuk mencari nilai dan operan; Fungsi ini menilai ungkapan mudah. Ia kembali - 1 jika ungkapan yang diberikan tidak sah. ; Kes asas: Ekspresi yang diberikan adalah kosong; Watak pertama mestilah operan, mencari nilainya; Melintasi watak -watak yang tersisa secara berpasangan; Watak seterusnya mestilah pengendali, dan seterusnya seterusnya sebuah operan; Jika seterusnya watak seterusnya bukanlah sebuah operan; Keputusan kemas kini mengikut pengendali; Jika bukan pengendali yang sah; Kod pemacu", "code": "< ? php function isOperand ( $ c ) { return ( $ c >= '0' && $ c <= '9' ) ; } function value ( $ c ) { return ( $ c - '0' ) ; } function evaluate ( $ exp ) { $ len = strlen ( $ exp ) ; if ( $ len == 0 ) return -1 ; $ res = ( int ) ( value ( $ exp [ 0 ] ) ) ; for ( $ i = 1 ; $ i < $ len ; $ i += 2 ) { $ opr = $ exp [ $ i ] ; $ opd = $ exp [ $ i + 1 ] ; if ( ! isOperand ( $ opd ) ) return -1 ; if ( $ opr == ' + ' ) $ res += value ( $ opd ) ; else if ( $ opr == ' - ' ) $ res -= ( int ) ( value ( $ opd ) ) ; else if ( $ opr == ' * ' ) $ res *= ( int ) ( value ( $ opd ) ) ; else if ( $ opr == ' / ' ) $ res /= ( int ) ( value ( $ opd ) ) ; else return -1 ; } return $ res ; } $ expr1 = \"1 + 2*5 + 3\" ; $ res = evaluate ( $ expr1 ) ; ( $ res == -1 ) ? print ( $ expr1 . \" ▁ is ▁ Invalid STRNEWLINE \" ) : print ( \" Value ▁ of ▁ \" . $ expr1 . \" ▁ is ▁ \" . $ res . \" STRNEWLINE \" ) ; $ expr2 = \"1 + 2*3\" ; $ res = evaluate ( $ expr2 ) ; ( $ res == -1 ) ? print ( $ expr2 . \" ▁ is ▁ Invalid STRNEWLINE \" ) : print ( \" Value ▁ of ▁ \" . $ expr2 . \" ▁ is ▁ \" . $ res . \" STRNEWLINE \" ) ; $ expr3 = \"4-2 + 6*3\" ; $ res = evaluate ( $ expr3 ) ; ( $ res == -1 ) ? print ( $ expr3 . \" ▁ is ▁ Invalid STRNEWLINE \" ) : print ( \" Value ▁ of ▁ \" . $ expr3 . \" ▁ is ▁ \" . $ res . \" STRNEWLINE \" ) ; $ expr4 = \"1 + + 2\" ; $ res = evaluate ( $ expr4 ) ; ( $ res == -1 ) ? print ( $ expr4 . \" ▁ is ▁ Invalid STRNEWLINE \" ) : print ( \" Value ▁ of ▁ \" . $ expr4 . \" ▁ is ▁ \" . $ res . \" STRNEWLINE \" ) ; ? >"}
{"text": "Program untuk mencetak nombor N First N Fibonacci | Tetapkan 1 | Berfungsi untuk mencetak nombor F FIBONACCI FIRST; Kod pemacu", "code": "< ? php function printFibonacciNumbers ( $ n ) { $ f1 = 0 ; $ f2 = 1 ; $ i ; if ( $ n < 1 ) return ; echo ( $ f1 ) ; echo ( \" ▁ \" ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { echo ( $ f2 ) ; echo ( \" ▁ \" ) ; $ next = $ f1 + $ f2 ; $ f1 = $ f2 ; $ f2 = $ next ; } } printFibonacciNumbers ( 7 ) ; ? >"}
{"text": "Program untuk mencari LCM dua nombor | Fungsi rekursif untuk mengembalikan GCD A dan B; Berfungsi untuk mengembalikan LCM dua nombor; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function lcm ( $ a , $ b ) { return ( $ a / gcd ( $ a , $ b ) ) * $ b ; } $ a = 15 ; $ b = 20 ; echo \" LCM ▁ of ▁ \" , $ a , \" ▁ and ▁ \" , $ b , \" ▁ is ▁ \" , lcm ( $ a , $ b ) ; ? >"}
{"text": "Program untuk menukar nombor yang diberikan kepada perkataan | Fungsi yang mencetak nombor yang diberikan dalam kata -kata; Dapatkan nombor digit dalam nombor tertentu; Kes asas; Rentetan pertama tidak digunakan, ia adalah untuk membuat pengindeksan array mudah; Rentetan pertama tidak digunakan, ia adalah untuk membuat pengindeksan array mudah; Dua rentetan pertama tidak digunakan, mereka membuat pengindeksan array mudah; Digunakan untuk tujuan debug sahaja; Untuk nombor digit tunggal; Iterate manakala num tidak '\\ 0'; Laluan kod untuk 2 digit pertama; Di sini len boleh menjadi 3 atau 4; Laluan kod untuk 2 digit terakhir; Perlu mengendalikan 10 - 19. Jumlah dua digit digunakan sebagai indeks \"dua _ digit\" pelbagai rentetan; Perlu mengendalikan 20; Selebihnya dua nombor digit i. e. , 21 hingga 99; Kod pemacu", "code": "< ? php function convert_to_words ( $ num ) { $ len = strlen ( $ num ) ; if ( $ len == 0 ) { echo \" empty ▁ string STRNEWLINE \" ; return ; } if ( $ len > 4 ) { echo \" Length ▁ more ▁ than ▁ 4 ▁ \" . \" is ▁ not ▁ supported STRNEWLINE \" ; return ; } $ single_digits = array ( \" zero \" , \" one \" , \" two \" , \" three \" , \" four \" , \" five \" , \" six \" , \" seven \" , \" eight \" , \" nine \" ) ; $ two_digits = array ( \" \" , \" ten \" , \" eleven \" , \" twelve \" , \" thirteen \" , \" fourteen \" , \" fifteen \" , \" sixteen \" , \" seventeen \" , \" eighteen \" , \" nineteen \" ) ; $ tens_multiple = array ( \" \" , \" \" , \" twenty \" , \" thirty \" , \" forty \" , \" fifty \" , \" sixty \" , \" seventy \" , \" eighty \" , \" ninety \" ) ; $ tens_power = array ( \" hundred \" , \" thousand \" ) ; echo $ num . \" : ▁ \" ; if ( $ len == 1 ) { echo $ single_digits [ $ num [ 0 ] - '0' ] . \" ▁ STRNEWLINE \" ; return ; } $ x = 0 ; while ( $ x < strlen ( $ num ) ) { if ( $ len >= 3 ) { if ( $ num [ $ x ] - '0' != 0 ) { echo $ single_digits [ $ num [ $ x ] - '0' ] . \" \" ; echo $ tens_power [ $ len - 3 ] . \" \" ; } -- $ len ; } else { if ( $ num [ $ x ] - '0' == 1 ) { $ sum = $ num [ $ x ] - '0' + $ num [ $ x ] - '0' ; echo $ two_digits [ $ sum ] . \" ▁ STRNEWLINE \" ; return ; } else if ( $ num [ $ x ] - '0' == 2 && $ num [ $ x + 1 ] - '0' == 0 ) { echo \" twenty STRNEWLINE \" ; return ; } else { $ i = $ num [ $ x ] - '0' ; if ( $ i > 0 ) echo $ tens_multiple [ $ i ] . \" ▁ \" ; else echo \" \" ; ++ $ x ; if ( $ num [ $ x ] - '0' != 0 ) echo $ single_digits [ $ num [ $ x ] - '0' ] . \" ▁ STRNEWLINE \" ; } } ++ $ x ; } } convert_to_words ( \"9923\" ) ; convert_to_words ( \"523\" ) ; convert_to_words ( \"89\" ) ; convert_to_words ( \"8\" ) ; ? >"}
{"text": "Semak jika nombor adalah berganda 5 tanpa menggunakan / dan % operator | Dengan mengandaikan bahawa Integre mengambil 4 bait, terdapat maksimum 10 digit dalam integer; Semak watak terakhir rentetan; Kod pemacu", "code": "< ? php $ MAX = 11 ; function isMultipleof5 ( $ n ) { global $ MAX ; $ str = ( string ) $ n ; $ len = strlen ( $ str ) ; if ( $ str [ $ len - 1 ] == '5' $ str [ $ len - 1 ] == '0' ) return true ; return false ; } $ n = 19 ; if ( isMultipleof5 ( $ n ) == true ) echo \" $ n ▁ is ▁ multiple ▁ of ▁ 5\" ; else echo \" $ n ▁ is ▁ not ▁ a ▁ multiple ▁ of ▁ 5\" ; ? >"}
{"text": "[TRANSLATION_FAILED]", "code": "< ? php function pairORSum ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ ans += $ arr [ $ i ] | $ arr [ $ j ] ; return $ ans ; } $ arr = array ( 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo pairORSum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Masukkan nombor sebanyak 15 tanpa menggunakan * dan / pengendali | Berfungsi untuk kembali (15 * n) tanpa menggunakan pengendali ' *' atau ' /'; prod = 16 * n; ((16 * n) - n) = 15 * n; Kod pemacu", "code": "< ? php function multiplyByFifteen ( $ n ) { $ prod = ( $ n << 4 ) ; $ prod = $ prod - $ n ; return $ prod ; } $ n = 7 ; echo multiplyByFifteen ( $ n ) ; ? >"}
{"text": "Nilai minimum di antara dan unsur -unsur setiap subset array | Program PHP untuk pendekatan di atas; Cari dan keseluruhan array; Cetak jawapannya; Kod pemacu", "code": "< ? php function minAND ( $ arr , $ n ) { $ s = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ s = $ s & $ arr [ $ i ] ; } print ( $ s . \" \" ) ; } $ arr = array ( 1 , 2 , 3 ) ; $ n = count ( $ arr ) ; minAND ( $ arr , $ n ) ; ? >"}
{"text": "Ubah suai array binari ke bitwise dan semua elemen sebagai 1 | Berfungsi untuk memeriksa sama ada mungkin atau tidak; Kod pemacu", "code": "< ? php function check ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] ) return true ; return false ; } $ a = array ( 0 , 1 , 0 , 1 ) ; $ n = sizeof ( $ a ) ; if ( check ( $ a , $ n ) ) echo \" YES STRNEWLINE \" ; else echo \" NO STRNEWLINE \" ; ? >"}
{"text": "Cari Array Menggunakan Xors Unsur yang Berbeza Dalam Kumpulan Saiz 4 | Fungsi utiliti untuk mencetak kandungan array; Fungsi untuk mencari array yang diperlukan; Cetak array; Kod pemacu", "code": "< ? php function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ $ i ] . \" ▁ \" ) ; } function findArray ( $ q , $ n ) { $ ans ; $ arr = array ( $ n ) ; for ( $ k = 0 , $ j = 0 ; $ j < $ n / 4 ; $ j ++ ) { $ ans = $ q [ $ k ] ^ $ q [ $ k + 3 ] ; $ arr [ $ k + 1 ] = $ q [ $ k + 1 ] ^ $ ans ; $ arr [ $ k + 2 ] = $ q [ $ k + 2 ] ^ $ ans ; $ arr [ $ k ] = $ q [ $ k ] ^ ( ( $ arr [ $ k + 1 ] ) ^ ( $ arr [ $ k + 2 ] ) ) ; $ arr [ $ k + 3 ] = $ q [ $ k + 3 ] ^ ( $ arr [ $ k + 1 ] ^ $ arr [ $ k + 2 ] ) ; $ k += 4 ; } printArray ( $ arr , $ n ) ; } { $ q = array ( 4 , 1 , 7 , 0 ) ; $ n = sizeof ( $ q ) ; findArray ( $ q , $ n ) ; }"}
{"text": "Semak jika perwakilan binari nombor mempunyai bilangan yang sama 0 s dan 1 s dalam blok | berfungsi untuk menukar perpuluhan kepada binari; Mengira bit yang sama di blok terakhir; Jika n adalah 0 atau ia mempunyai semua 1 s, maka ia tidak dianggap mempunyai bilangan yang sama 0 s dan 1 s dalam blok. ; Kira bit yang sama di semua blok yang tinggal. ; Kod pemacu", "code": "< ? php function isEqualBlock ( $ n ) { $ first_bit = $ n % 2 ; $ first_count = 1 ; $ n = ( int ) ( $ n / 2 ) ; while ( $ n % 2 == $ first_bit && $ n > 0 ) { $ n = ( int ) ( $ n / 2 ) ; $ first_count ++ ; } if ( $ n == 0 ) return false ; while ( $ n > 0 ) { $ first_bit = $ n % 2 ; $ curr_count = 1 ; $ n = ( int ) ( $ n / 2 ) ; while ( $ n % 2 == $ first_bit ) { $ n = ( int ) ( $ n / 2 ) ; $ curr_count ++ ; } if ( $ curr_count != $ first_count ) return false ; } return true ; } $ n = 51 ; if ( isEqualBlock ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Tiga bit pertama dan terakhir | Berfungsi untuk mencetak nombor perpuluhan bersamaan 3 bit pertama dan terakhir; Nombor yang dibentuk dari tiga bit terakhir; Marilah kita dapatkan tiga bit pertama di N; Nombor yang dibentuk dari tiga bit pertama; Hasil percetakan; Kod pemacu", "code": "< ? php function binToDecimal3 ( $ n ) { $ last_3 = ( ( $ n & 4 ) + ( $ n & 2 ) + ( $ n & 1 ) ) ; $ n = $ n >> 3 ; while ( $ n > 7 ) $ n = $ n >> 1 ; $ first_3 = ( ( $ n & 4 ) + ( $ n & 2 ) + ( $ n & 1 ) ) ; echo ( $ first_3 ) ; echo ( \" ▁ \" ) ; echo ( $ last_3 ) ; } $ n = 86 ; binToDecimal3 ( $ n ) ; ? >"}
{"text": "Kira nombor yang boleh dijadikan kuasa 2 dengan operasi yang diberikan | Fungsi yang kembali benar jika x adalah kuasa 2; Jika x & (x - 1) = 0 maka x adalah kuasa 2; Berfungsi untuk mengembalikan kiraan yang diperlukan; Jika a [i] atau (a [i] + 1) adalah kuasa 2; Kod pemacu", "code": "< ? php function isPowerOfTwo ( $ x ) { if ( $ x == 0 ) return false ; if ( ! ( $ x & ( $ x - 1 ) ) ) return true ; else return false ; } function countNum ( $ a , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( isPowerOfTwo ( $ a [ $ i ] ) || isPowerOfTwo ( $ a [ $ i ] + 1 ) ) $ cnt ++ ; } return $ cnt ; } $ arr = array ( 5 , 6 , 9 , 3 , 1 ) ; $ n = count ( $ arr ) ; echo countNum ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah elemen dari array yang mempunyai pariti bahkan | Fungsi yang pulih benar jika x mempunyai pariti bahkan; Kami pada dasarnya mengira set bit https: www. Geeksforgeeks. org / count - set - bit - in - an - integer /; Berfungsi untuk mengembalikan jumlah unsur -unsur dari array yang mempunyai pariti; Jika [i] mempunyai pariti; Kod pemacu", "code": "< ? php function checkEvenParity ( $ x ) { $ parity = 0 ; while ( $ x != 0 ) { $ x = ( $ x & ( $ x - 1 ) ) ; $ parity ++ ; } if ( $ parity % 2 == 0 ) return true ; else return false ; } function sumlist ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( checkEvenParity ( $ a [ $ i ] ) ) $ sum += $ a [ $ i ] ; } return $ sum ; } $ arr = array ( 2 , 4 , 3 , 5 , 9 ) ; $ n = sizeof ( $ arr ) ; echo sumlist ( $ arr , $ n ) ; ? >"}
{"text": "Bilangan pasangan dengan bitwise atau sebagai nombor ganjil | Berfungsi untuk mengira pasangan dengan ganjil atau; Cari atau operasi periksa ganjil atau ganjil; Kembali kiraan pasangan ganjil; Kod pemacu", "code": "< ? php function findOddPair ( $ A , $ N ) { $ oddPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] $ A [ $ j ] ) % 2 != 0 ) $ oddPair ++ ; } } return $ oddPair ; } $ A = array ( 5 , 6 , 2 , 8 ) ; $ N = sizeof ( $ A ) / sizeof ( $ A [ 0 ] ) ; echo findOddPair ( $ A , $ N ) , \" STRNEWLINE \" ; #This  code is contributed by ajit NEW_LINE ? >"}
{"text": "Kira pasangan dengan bitwise xor sebagai nombor bahkan | Berfungsi untuk mengira bilangan pasangan walaupun; Pembolehubah untuk mengira walaupun pasangan; Cari semua pasangan; Cari semakan operasi XOR walaupun atau bahkan; pulangan bilangan pasangan; Kod pemacu; fungsi panggilan findevenpair dan cetak nombor walaupun pasangan", "code": "< ? php function findevenPair ( & $ A , $ N ) { $ evenPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] ^ $ A [ $ j ] ) % 2 == 0 ) $ evenPair ++ ; } } return $ evenPair ; } $ A = array ( 5 , 4 , 7 , 2 , 1 ) ; $ N = sizeof ( $ A ) ; echo ( findevenPair ( $ A , $ N ) ) ; ? >"}
{"text": "Kira pasangan dengan bitwise xor sebagai nombor bahkan | Berfungsi untuk mengira bilangan pasangan walaupun; Cari semua pasangan; pulangan bilangan pasangan; Kod pemacu; fungsi panggilan findevenpair dan cetak nombor walaupun pasangan", "code": "< ? php function findEvenPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ A [ $ i ] % 2 != 0 ) $ count ++ ; } $ totalPairs = ( $ N * ( $ N - 1 ) / 2 ) ; $ oddEvenPairs = $ count * ( $ N - $ count ) ; return $ totalPairs - $ oddEvenPairs ; } $ a = array ( 5 , 4 , 7 , 2 , 1 ) ; $ n = sizeof ( $ a ) ; echo findEvenPair ( $ a , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Kira pasangan dengan bitwise | Berfungsi untuk mengira bilangan pasangan walaupun bitwise dan; Pembolehubah untuk mengira walaupun pasangan; Cari semua pasangan; Cari dan beroperasi untuk memeriksa Evenpair; pulangan bilangan pasangan; Kod pemacu", "code": "< ? php function findevenPair ( $ A , $ N ) { $ evenPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] & $ A [ $ j ] ) % 2 == 0 ) $ evenPair ++ ; } } return $ evenPair ; } $ a = array ( 5 , 1 , 3 , 2 ) ; $ n = sizeof ( $ a ) ; echo findevenPair ( $ a , $ n ) ; ? >"}
{"text": "Kira pasangan dengan bitwise | Berfungsi untuk mengira bilangan pasangan dengan bitwise dan; mengira nombor ganjil; mengira pasangan ganjil; pulangan bilangan pasangan; Kod pemacu", "code": "< ? php function findevenPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ A [ $ i ] % 2 != 0 ) $ count ++ ; $ oddCount = $ count * ( $ count - 1 ) / 2 ; return ( $ N * ( $ N - 1 ) / 2 ) - $ oddCount ; } $ a = array ( 5 , 1 , 3 , 2 ) ; $ n = sizeof ( $ a ) ; echo findevenPair ( $ a , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Cari nilai yang XOR dengan nombor yang diberikan adalah maksimum | Berfungsi untuk mengira jawapan; Cari bilangan bit dalam integer yang diberikan; Xor integer yang diberikan dengan poe (2, number_of_bits - 1 dan cetak hasilnya; kod pemacu", "code": "< ? php function calculate ( $ X ) { $ number_of_bits = 8 ; return ( ( 1 << $ number_of_bits ) - 1 ) ^ $ X ; } $ X = 4 ; echo \" Required ▁ Number ▁ is ▁ : ▁ \" . calculate ( $ X ) . \" STRNEWLINE \" ; ? >"}
{"text": "Gantikan setiap elemen array dengan bitwise xor semua yang lain | Berfungsi untuk menggantikan unsur -unsur; Kirakan XOR semua elemen; Menggantikan setiap elemen oleh XOR dari semua elemen lain; Kod pemacu; Cetak array yang diubahsuai.", "code": "< ? php function ReplaceElements ( $ arr , $ n ) { $ X = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ X ^= $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ arr [ $ i ] = $ X ^ $ arr [ $ i ] ; } return $ arr ; } $ arr = array ( 2 , 3 , 3 , 5 , 5 ) ; $ n = sizeof ( $ arr ) ; $ arr1 = ReplaceElements ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { echo ( $ arr1 [ $ i ] . \" \" ) ; } ? >"}
{"text": "Berikan nilai lain kepada pembolehubah dari dua nilai yang mungkin | Berfungsi untuk menggantikan nilai; Kod pemacu", "code": "< ? php function alternate ( & $ a , & $ b , & $ x ) { $ x = $ a ^ $ b ^ $ x ; } $ a = -10 ; $ b = 15 ; $ x = $ a ; echo \" x ▁ is ▁ : ▁ \" , $ x ; alternate ( $ a , $ b , $ x ) ; echo \" After exchange \" ; echo \" x is : \" ? >"}
{"text": "Bilangan sifar terkemuka dalam perwakilan binari nombor tertentu | Fungsi untuk mengira no. nol terkemuka; Kod pemacu", "code": "< ? php function countZeros ( $ x ) { $ y ; $ n = 32 ; $ y = $ x >> 16 ; if ( $ y != 0 ) { $ n = $ n - 16 ; $ x = $ y ; } $ y = $ x >> 8 ; if ( $ y != 0 ) { $ n = $ n - 8 ; $ x = $ y ; } $ y = $ x >> 4 ; if ( $ y != 0 ) { $ n = $ n - 4 ; $ x = $ y ; } $ y = $ x >> 2 ; if ( $ y != 0 ) { $ n = $ n - 2 ; $ x = $ y ; } $ y = $ x >> 1 ; if ( $ y != 0 ) return $ n - 2 ; return $ n - $ x ; } $ x = 101 ; echo countZeros ( $ x ) ;"}
{"text": "Membandingkan sifar terkemuka dalam perwakilan binari dua nombor | Berfungsi untuk membandingkan no. nol terkemuka; Jika kedua -duanya tidak sama. nol terkemuka; Jika Y mempunyai lebih banyak nol utama; Kod pemacu", "code": "< ? php function LeadingZeros ( $ x , $ y ) { if ( ( $ x ^ $ y ) <= ( $ x & $ y ) ) echo \" Equal \" else if ( ( $ x & ( ~ $ y ) ) > $ y ) echo $ y ; else echo $ x ; } $ x = 10 ; $ y = 16 ; LeadingZeros ( $ x , $ y ) ; ? >"}
{"text": "Bilangan bit yang tidak sepadan dalam perwakilan binari dua bilangan bulat | mengira bilangan bit yang berbeza; Oleh kerana, angka -angka itu kurang daripada 2 ^ 31 menjalankan gelung dari '0' hingga '31' sahaja; Pergeseran kanan kedua -dua nombor dengan 'i' dan periksa sama ada bit pada kedudukan ke -0 adalah berbeza; Kod pemacu; Cari bilangan bit yang berbeza", "code": "< ? php function solve ( $ A , $ B ) { $ count = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { if ( ( ( $ A >> $ i ) & 1 ) != ( ( $ B >> $ i ) & 1 ) ) { $ count ++ ; } } echo \" Number ▁ of ▁ different ▁ bits ▁ : ▁ $ count \" ; } $ A = 12 ; $ B = 15 ; solve ( $ A , $ B ) ; ? >"}
{"text": "Tetapkan Bit Off Bit | Program PHP untuk menetapkan bit yang paling tidak betul; Jika semua bit ditetapkan; Tetapkan kanan 0 bit; Kod pemacu", "code": "< ? php function setRightmostUnsetBit ( $ n ) { if ( ( $ n & ( $ n + 1 ) ) == 0 ) return $ n ; return $ n | ( $ n + 1 ) ; } $ n = 21 ; echo setRightmostUnsetBit ( $ n ) ; ? >"}
{"text": "Cari bitwise dan (&) dari semua sub | berfungsi untuk kembali dan sub -tatasusunan; Kod pemacu; saiz array; Cetak dan semua subarrays", "code": "< ? php function ANDS ( & $ a , $ n ) { $ ans = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans &= $ a [ $ i ] ; return $ ans ; } $ a = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ a ) ; echo ANDS ( $ a , $ n ) ; ? >"}
{"text": "Pelengkap 2 untuk rentetan givin menggunakan XOR | Program PHP untuk mencari pelengkap 2 menggunakan XOR. ; Bendera yang digunakan untuk mencari jika 1 bit dilihat atau tidak. ; Operator XOR digunakan untuk membalikkan; bit selepas menukar nilai ASCII; Sekiranya tidak ada 1 dalam rentetan jadi tambah 1 dalam permulaan rentetan dan kembali; Kod pemacu", "code": "< ? php function TwoscomplementbyXOR ( $ str ) { $ n = strlen ( $ str ) ; $ check_bit = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] == '0' && $ check_bit == 0 ) { continue ; } else { if ( $ check_bit == 1 ) $ str [ $ i ] = ( $ str [ $ i ] - '0' ) ^ 1 + '0' ; $ check_bit = 1 ; } } if ( $ check_bit == 0 ) return \"1\" + $ str ; else return $ str ; } $ str = \"101\" ; echo TwoscomplementbyXOR ( $ str ) ; ? >"}
{"text": "Semak sama ada bit berada dalam corak alternatif dalam julat yang diberikan | berfungsi untuk memeriksa sama ada bit berada dalam corak alternatif dalam julat yang diberikan; shift kanan n oleh (l - 1) bit; Dapatkan sedikit pada kedudukan terakhir dalam 'Num'; shift kanan 'num' oleh 1; gelung sehingga terdapat bit dalam julat yang diberikan; Dapatkan sedikit pada kedudukan terakhir dalam 'Num'; Jika benar, maka bit tidak berada dalam corak alternatif; Kemas kini 'Prev'; shift kanan 'num' oleh 1; Bit berada dalam corak alternatif dalam julat yang diberikan; Kod pemacu", "code": "< ? php function bitsAreInAltPatrnInGivenTRange ( $ n , $ l , $ r ) { $ num = $ n >> ( $ l - 1 ) ; $ prev = $ num & 1 ; $ num = $ num >> 1 ; for ( $ i = 1 ; $ i <= ( $ r - $ l ) ; $ i ++ ) { $ curr = $ num & 1 ; if ( $ curr == $ prev ) return false ; $ prev = $ curr ; $ num = $ num >> 1 ; } return true ; } $ n = 18 ; $ l = 1 ; $ r = 3 ; if ( bitsAreInAltPatrnInGivenTRange ( $ n , $ l , $ r ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Kenaikan nombor tanpa menggunakan ++ atau + | fungsi yang meningkatkan nilai. ; Membalikkan bit dan memohon tanda negatif; Kod pemacu", "code": "< ? php function increment ( $ i ) { $ i = - ( ~ $ i ) ; return $ i ; } $ n = 3 ; echo increment ( $ n ) ; ? >"}
{"text": "Jumlah maksimum dengan menambahkan nombor dengan bilangan bit set yang sama | Kira bilangan bit untuk setiap elemen array; Kira bilangan bit yang ditetapkan; Berfungsi untuk mengembalikan jumlah maksimum; Hitung; Dengan mengandaikan nombor itu menjadi maksimum 32 bit; Tambah nombor ke bilangan bit yang ditetapkan; Cari jumlah maksimum; Kod pemacu", "code": "< ? php function bit_count ( $ n ) { $ count = 0 ; while ( $ n ) { $ count ++ ; $ n = $ n & ( $ n - 1 ) ; } return $ count ; } function maxsum ( $ arr , $ n ) { $ bits = array ( $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ bits [ $ i ] = bit_count ( $ arr [ $ i ] ) ; } $ sum = array_fill ( 0 , 32 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum [ $ bits [ $ i ] ] += $ arr [ $ i ] ; } $ maximum = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { $ maximum = max ( $ sum [ $ i ] , $ maximum ) ; } return $ maximum ; } $ arr = array ( 2 , 3 , 8 , 5 , 6 , 7 ) ; $ n = sizeof ( $ arr ) ; echo maxsum ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah xor jumlah semua pasangan dalam array | Program PHP untuk mencari XOR jumlah pasangan. ; Kod pemacu", "code": "< ? php function xor_pair_sum ( $ ar , $ n ) { $ total = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ total = $ total ^ $ ar [ $ i ] ; return ( 2 * $ total ) ; } $ data = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ data ) ; echo xor_pair_sum ( $ data , $ n ) ; ? >"}
{"text": "Kira pasangan dengan bitwise atau sebagai nombor juga | Program PHP untuk mengira pasangan dengan walaupun atau; Kira jumlah nombor walaupun dalam array. ; kembali kiraan pasangan; Kod pemacu", "code": "< ? php function findEvenPair ( & $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ! ( $ A [ $ i ] & 1 ) ) $ count ++ ; return $ count * ( $ count - 1 ) / 2 ; } $ A = array ( 5 , 6 , 2 , 8 ) ; $ N = sizeof ( $ A ) ; echo findEvenPair ( $ A , $ N ) . \" STRNEWLINE \" ; ? >"}
{"text": "Semak sama ada semua bit tidak tersendiri dalam julat yang diberikan | berfungsi untuk memeriksa sama ada semua bit tidak tersendiri dalam julat yang diberikan atau tidak; Mengira nombor 'num' mempunyai bilangan bit dan bit dalam julat L ke r adalah satu -satunya bit yang ditetapkan; Nombor baru yang hanya boleh mempunyai satu atau lebih bit set dalam julat L ke R dan tempat lain; Jika benar, maka semua bit tidak tersendiri dalam julat yang diberikan; Selain itu semua bit tidak tersembunyi dalam julat yang diberikan; Kod pemacu", "code": "< ? php function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ new_num == 0 ) return true ; return false ; } $ n = 17 ; $ l = 2 ; $ r = 4 ; if ( allBitsSetInTheGivenRange ( $ n , $ l , $ r ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak jika nombor mempunyai bilangan set dan bit yang sama yang sama | Fungsi untuk memeriksa sama ada nombor mempunyai setbit yang sama dan bit yang tidak tersendiri; berulang untuk semua bit nombor; jika ditetapkan; jika tidak jelas; nombor peralihan kanan dengan 1; adalah bilangan bit yang ditetapkan adalah sama dengan bit yang tidak disetkan; Kod pemacu; berfungsi untuk memeriksa", "code": "< ? php function checkSame ( $ n ) { $ set = 0 ; $ unset = 0 ; while ( $ n ) { if ( $ n & 1 ) $ set ++ ; else $ unset ++ ; $ n = $ n >> 1 ; } if ( $ set == $ unset ) return true ; else return false ; } $ n = 12 ; if ( checkSame ( $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Cari Karakter Indeks Saya dalam rentetan binari yang diperolehi selepas n Penyelarasan | Tetapkan 2 | Fungsi untuk mencari watak i - th; Jarak antara dua elemen berturut -turut selepas lelaran N; Perwakilan binari M; KTH digit akan diperolehi dari akar pasti; Semak sama ada perlu flip root atau tidak; Kod pemacu", "code": "< ? php function KthCharacter ( $ m , $ n , $ k ) { $ distance = pow ( 2 , $ n ) ; $ Block_number = intval ( $ k / $ distance ) ; $ remaining = $ k % $ distance ; $ s = array ( 32 ) ; $ x = 0 ; for ( ; $ m > 0 ; $ x ++ ) { $ s [ $ x ] = $ m % 2 ; $ m = intval ( $ m / 2 ) ; } $ root = $ s [ $ x - 1 - $ Block_number ] ; if ( $ remaining == 0 ) { echo $ root . \" STRNEWLINE \" ; return ; } $ flip = true ; while ( $ remaining > 1 ) { if ( $ remaining & 1 ) { $ flip = ! $ flip ; } $ remaining = $ remaining >> 1 ; } if ( $ flip ) { echo ! $ root . \" STRNEWLINE \" ; } else { echo $ root . \" STRNEWLINE \" ; } } $ m = 5 ; $ k = 5 ; $ n = 3 ; KthCharacter ( $ m , $ n , $ k ) ; ? >"}
{"text": "Semak sama ada nombor itu hanya set bit pertama dan terakhir | Tetapkan 2 | berfungsi untuk memeriksa sama ada nombor itu hanya set bit pertama dan terakhir; Kod pemacu", "code": "< ? php function onlyFirstAndLastAreSet ( $ n ) { if ( $ n == 1 ) return true ; if ( $ n == 2 ) return false ; return ( ( ( $ n - 1 ) & ( $ n - 2 ) ) == 0 ) ; } $ n = 9 ; if ( onlyFirstAndLastAreSet ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Nombor dengan bit set hanya antara L | Berfungsi untuk mengembalikan integer dengan semua bit yang ditetapkan dalam julat l - r; beralih dari L ke R dan tambah semua kuasa 2; Kod pemacu", "code": "< ? php function getInteger ( $ L , $ R ) { $ number = 0 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) $ number += pow ( 2 , $ i ) ; return $ number ; } $ L = 2 ; $ R = 5 ; echo getInteger ( $ L , $ R ) ; ? >"}
{"text": "Nombor dengan bit set hanya antara L | Berfungsi untuk mengembalikan integer dengan semua bit yang ditetapkan dalam julat l - r; Kod pemacu", "code": "< ? php function setbitsfromLtoR ( $ L , $ R ) { return ( 1 << ( $ R + 1 ) ) - ( 1 << $ L ) ; } $ L = 2 ; $ R = 5 ; echo setbitsfromLtoR ( $ L , $ R ) ; ? >"}
{"text": "Xor jumlah setiap pasangan yang mungkin dari array | Berfungsi untuk mencari xor jumlah semua pasangan; Hitung Xor semua elemen; Kembali dua kali nilai XOR; Kod pemacu", "code": "< ? php function findXor ( $ arr , $ n ) { $ xoR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ xoR = $ xoR ^ $ arr [ $ i ] ; } return $ xoR * 2 ; } $ arr = array ( 1 , 5 , 6 ) ; $ n = count ( $ arr ) ; echo findXor ( $ arr , $ n ) ; ? >"}
{"text": "Dua elemen yang ganjil dalam array di mana semua yang lain berlaku walaupun masa | Kod PHP untuk mencari dua elemen yang ganjil dalam array di mana semua elemen lain muncul walaupun bilangan kali. ; Cari xor semua nombor; Cari bit set dalam XOR (kami dapati set kanan di sini); Melintasi semua nombor dan membahagikannya dalam dua kumpulan (i) yang set bit ditetapkan pada kedudukan yang sama sebagai satu -satunya set bit dalam set_bit (ii) yang mempunyai 0 bit pada kedudukan yang sama sebagai satu -satunya set bit dalam set_bit; XOR dari dua set yang berbeza adalah nombor yang diperlukan. ; Kod pemacu", "code": "< ? php function printOdds ( $ arr , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = $ res ^ $ arr [ $ i ] ; $ set_bit = $ res & ( ~ ( $ res - 1 ) ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo ( $ x . \" ▁ \" . $ y ) ; } $ arr = array ( 2 , 3 , 3 , 4 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; printOdds ( $ arr , $ n ) ; ? >"}
{"text": "Subset maksimum dengan bitwise atau sama dengan k | berfungsi untuk mencari subset maksimum dengan bitwise atau sama dengan k; Jika bitwise atau k dan elemen sama dengan k, maka masukkan elemen itu dalam subset; Simpan bitwise atau elemen dalam v; Sekiranya ANS tidak sama dengan k, subset tidak wujud; Kod pemacu", "code": "< ? php function subsetBitwiseORk ( $ arr , $ n , $ k ) { $ v = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ arr [ $ i ] $ k ) == $ k ) array_push ( $ v , $ arr [ $ i ] ) ; } $ ans = 0 ; for ( $ i = 0 ; $ i < count ( $ v ) ; $ i ++ ) $ ans |= $ v [ $ i ] ; if ( $ ans != $ k ) { echo ( \" Subset ▁ does ▁ not ▁ exist STRNEWLINE \" ) ; return ; } for ( $ i = 0 ; $ i < count ( $ v ) ; $ i ++ ) echo ( $ v [ $ i ] . \" ▁ \" ) ; } $ k = 3 ; $ arr = array ( 1 , 4 , 2 ) ; $ n = count ( $ arr ) ; subsetBitwiseORk ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Nombor yang jumlahnya XOR dengan array yang diberikan adalah nombor yang diberikan k | Fungsi ini mengembalikan nombor yang akan dimasukkan dalam array yang diberikan; memulakan jawapan dengan k; Xor semua elemen dalam array; Kod pemacu", "code": "< ? php function findEletobeInserted ( $ A , $ n , $ k ) { $ ans = $ k ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ ans ^= $ A [ $ i ] ; return $ ans ; } $ A = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = count ( $ A ) ; $ k = 10 ; echo findEletobeInserted ( $ A , $ n , $ k ) ; echo \" ▁ has ▁ to ▁ be ▁ inserted \" ; echo \" ▁ in ▁ the ▁ given ▁ array ▁ to ▁ make ▁ xor ▁ sum ▁ of ▁ \" ; echo $ k , \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah bitwise dan semua subset yang mungkin dari set yang diberikan | Program PHP untuk mengira jumlah bit - bijak dan jumlah semua subset array; Dengan mengandaikan perwakilan setiap elemen adalah dalam 32 bit; elemen array; Mengira sedikit set array dalam kedudukan ITH; Mengira subset yang menghasilkan jumlah apabila kedudukan bit tertentu ditetapkan. ; Mengalikan setiap subset kedudukan dengan 2 ^ i untuk mengira jumlahnya. ; Kod pemacu", "code": "< ? php $ BITS = 32 ; function andSum ( $ arr , $ n ) { global $ BITS ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ BITS ; $ i ++ ) { $ countSetBits = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] & ( 1 << $ i ) ) $ countSetBits ++ ; } $ subset = ( 1 << $ countSetBits ) - 1 ; $ subset = ( $ subset * ( 1 << $ i ) ) ; $ ans += $ subset ; } return $ ans ; } $ arr = array ( 1 , 2 , 3 ) ; $ size = count ( $ arr ) ; echo andSum ( $ arr , $ size ) ; ? >"}
{"text": "Memaksimumkan nombor dengan menyusun semula bit | Program Java yang cekap untuk mencari nombor minimum yang dibentuk oleh bit nombor tertentu. ; Mengembalikan nombor maksimum yang dibentuk oleh bit nombor tertentu. ; _popcnt32 (a) Memberi bilangan 1 yang hadir dalam perwakilan binari a. ; Jika $ 32 bit ditetapkan. ; Cari nombor bit yang paling penting. ; Sekarang keputusan peralihan oleh 32 - n; Kod pemacu", "code": "< ? php function _popcnt32 ( $ n ) { $ count = 0 ; while ( $ n != 0 ) { $ n = $ n & ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function maximize ( $ a ) { $ n = _popcnt32 ( $ a ) ; if ( $ n == 32 ) return $ a ; $ res = ( 1 << $ n ) - 1 ; return ( $ res << ( 32 - $ n ) ) ; } $ a = 3 ; echo ( maximize ( $ a ) ) ; ? >"}
{"text": "Langkah maksimum untuk mengubah 0 ke x dengan bitwise dan | Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Kod pemacu", "code": "< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += $ n & 1 ; $ n >>= 1 ; } return $ count ; } $ i = 3 ; echo ( countSetBits ( $ i ) ) ; ? >"}
{"text": "Semak nombor adalah ganjil atau bahkan tanpa pengendali modulus | Pulangan benar jika n adalah walaupun, lain -lain ganjil; Kod pemacu", "code": "< ? php function isEven ( $ n ) { $ isEven = true ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ isEven = ! $ isEven ; return $ isEven ; } $ n = 101 ; $ is = isEven ( $ n ) ? \" Even \" : \" Odd \" ; echo \" $ is \" ? >"}
{"text": "Semak nombor adalah ganjil atau bahkan tanpa pengendali modulus | Pulangan benar jika n adalah walaupun, lain -lain ganjil; Kembali benar jika n / 2 tidak menghasilkan nilai terapung. ; Kod pemacu", "code": "< ? php function isEven ( $ n ) { return ( ( int ) ( $ n / 2 ) * 2 == $ n ) ; } $ n = 101 ; if ( isEven ( $ n ) ) echo ( \" Even \" ) ; else echo ( \" Odd \" ) ; ? >"}
{"text": "Penambahan Rekursif Bitwise Dua Integer | Program PHP untuk melakukan penambahan rekursif dua bilangan bulat; Jika Bitwise & adalah 0, maka tidak akan ada apa -apa bawa. Oleh itu, hasil XOR adalah tambahan. ; Kod pemacu", "code": "< ? php function add ( $ x , $ y ) { $ keep = ( $ x & $ y ) << 1 ; $ res = $ x ^ $ y ; if ( $ keep == 0 ) { echo $ res ; exit ( 0 ) ; } add ( $ keep , $ res ) ; } $ k = add ( 15 , 38 ) ; ? >"}
{"text": "Kira pasangan dalam array yang mempunyai sekurang -kurangnya satu digit biasa | Pulangan benar jika pasangan itu sah, jika tidak palsu; menukar bilangan bulat ke rentetan; Melangkah ke atas rentetan dan periksa sama ada watak dalam rentetan pertama juga terdapat dalam rentetan kedua, kembali benar; Tiada digit biasa dijumpai; Mengembalikan bilangan pasangan yang sah; Melangkah ke atas semua pasangan yang mungkin; Kod pemacu", "code": "< ? php function checkValidPair ( $ num1 , $ num2 ) { $ s1 = ( string ) $ num1 ; $ s2 = ( string ) $ num2 ; for ( $ i = 0 ; $ i < strlen ( $ s1 ) ; $ i ++ ) for ( $ j = 0 ; $ j < strlen ( $ s2 ) ; $ j ++ ) if ( $ s1 [ $ i ] == $ s2 [ $ j ] ) return true ; return false ; } function countPairs ( & $ arr , $ n ) { $ numberOfPairs = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( checkValidPair ( $ arr [ $ i ] , $ arr [ $ j ] ) ) $ numberOfPairs ++ ; return $ numberOfPairs ; } $ arr = array ( 10 , 12 , 24 ) ; $ n = sizeof ( $ arr ) ; echo ( countPairs ( $ arr , $ n ) ) ; ? >"}
{"text": "Semak jika Bitwise dan mana -mana subset adalah kuasa dua | Periksa kuasa 2 atau tidak; Semak jika terdapat subset yang bitwise dan kuasa 2 .; Sekiranya terdapat hanya satu elemen dalam set. ; Mencari nombor dengan semua set bit. ; Semak semua kedudukan di mana bit ditetapkan. ; Sertakan semua unsur -unsur yang bit saya ditetapkan; Semak set mengandungi elemen membuat kuasa 2 atau tidak; Kod pemacu", "code": "< ? php function isPowerOf2 ( $ num ) { return ( $ num && ! ( $ num & ( $ num - 1 ) ) ) ; } function checkSubsequence ( $ arr , $ n ) { $ NUM_BITS = 32 ; if ( $ n == 1 ) return isPowerOf2 ( $ arr [ 0 ] ) ; $ total = 0 ; for ( $ i = 0 ; $ i < $ NUM_BITS ; $ i ++ ) $ total = $ total | ( 1 << $ i ) ; for ( $ i = 0 ; $ i < $ NUM_BITS ; $ i ++ ) { $ ans = $ total ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] & ( 1 << $ i ) ) $ ans = $ ans & $ arr [ $ j ] ; } if ( isPowerOf2 ( $ ans ) ) return true ; } return false ; } $ arr = array ( 12 , 13 , 7 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; if ( checkSubsequence ( $ arr , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Cari pemenang di Nim | berfungsi untuk mencari pemenang permainan NIM; kes apabila Alice adalah pemenang; Apabila Bob adalah pemenang; Kod pemacu", "code": "< ? php function findWinner ( $ A , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res ^= $ A [ $ i ] ; if ( $ res == 0 or $ n % 2 == 0 ) return \" Alice \" ; else return \" Bob \" ; } $ A = array ( 1 , 4 , 3 , 5 ) ; $ n = count ( $ A ) ; echo \" Winner = \" ? >"}
{"text": "Nombor Fibbinary (tidak berturut -turut 1 s dalam binari) | berfungsi untuk memeriksa sama ada nombor adalah fibbinary atau tidak; Jika nombor itu tidak mengandungi hasil operasi yang bersebelahan (n & (n >> 1)) kepada 0; bukan nombor fibbinary; Kod pemacu", "code": "< ? php function isFibbinaryNum ( $ n ) { if ( ( $ n & ( $ n >> 1 ) ) == 0 ) return true ; return false ; } $ n = 10 ; if ( isFibbinaryNum ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Maksimum xor | fungsi untuk mengira nilai XOR maksimum; Kembali (2 ^ c - 1); Kod pemacu", "code": "< ? php function maxXOR ( $ n , $ k ) { $ c = log ( $ n , 2 ) + 1 ; return ( ( 1 << $ c ) - 1 ) ; } $ n = 12 ; $ k = 3 ; echo maxXOR ( $ n , $ k ) ; ? >"}
{"text": "Bahagikan dua bilangan bulat tanpa menggunakan pendaraban, pembahagian dan pengendali mod | Berfungsi untuk membahagikan A b oleh B dan mengembalikan nilai lantai; Kirakan tanda pembahagi i. e. , tanda akan menjadi negatif sama ada salah satu daripada mereka adalah negatif hanya iff jika tidak, ia akan menjadi positif; keluarkan tanda operan; Memulakan kota; Uji turun dari bit tertinggi dan mengumpul nilai tentatif untuk bit yang sah; Jika nilai tanda yang dikira lebih awal adalah - 1 kemudian menafikan nilai kuota; Kod pemacu", "code": "< ? php function divide ( $ dividend , $ divisor ) { $ sign = ( ( $ dividend < 0 ) ^ ( $ divisor < 0 ) ) ? -1 : 1 ; $ dividend = abs ( $ dividend ) ; $ divisor = abs ( $ divisor ) ; $ quotient = 0 ; $ temp = 0 ; for ( $ i = 31 ; $ i >= 0 ; -- $ i ) { if ( $ temp + ( $ divisor << $ i ) <= $ dividend ) { $ temp += $ divisor << $ i ; $ quotient |= ( double ) ( 1 ) << $ i ; } } if ( $ sign == -1 ) $ quotient = - $ quotient ; return $ quotient ; } $ a = 10 ; $ b = 3 ; echo divide ( $ a , $ b ) . \" STRNEWLINE \" ; $ a = 43 ; $ b = -8 ; echo divide ( $ a , $ b ) ; ? >"}
{"text": "Xor dua nombor selepas membuat panjang perwakilan binari mereka sama | berfungsi untuk mengira bilangan bit dalam perwakilan binari integer; mengira kiraan; kiraan sehingga n bukan sifar; Peralihan kanan dengan 1 i. e, bahagikan dengan 2; Fungsi untuk mengira XOR dua nombor dengan menambahkan sifar trailing ke nombor yang mempunyai bilangan bit yang kurang dalam perwakilan binari. ; menyimpan minimum dan maksimum; Peralihan kiri jika bilangan bit kurang dalam perwakilan binari; Kod pemacu", "code": "< ? php function count1 ( $ n ) { $ c = 0 ; while ( $ n ) { $ c ++ ; $ n = $ n >> 1 ; } return $ c ; } function XOR1 ( $ a , $ b ) { $ c = min ( $ a , $ b ) ; $ d = max ( $ a , $ b ) ; if ( count1 ( $ c ) < count1 ( $ d ) ) $ c = $ c << ( count1 ( $ d ) - count1 ( $ c ) ) ; return ( $ c ^ $ d ) ; } $ a = 13 ; $ b = 5 ; echo XOR1 ( $ a , $ b ) ; ? >"}
{"text": "Tukar setiap dua bit dalam bait | Program PHP untuk menukar setiap dua bit dalam bait. ; Mengekstrak peralihan bit yang tinggi ke pengekstrakan lowbit yang rendah beralih ke highbit; Kod pemacu", "code": "< ? php function swapBitsInPair ( $ x ) { return ( ( $ x & 0b10101010 ) >> 1 ) | ( ( $ x & 0b01010101 ) << 1 ) ; } $ x = 4 ; echo swapBitsInPair ( $ x ) ; ? >"}
{"text": "Bit alternatif dua nombor untuk membuat nombor baru | Tetapkan sedikit nombor n; Res untuk kedai 101010.. nombor; menjana borang nombor 101010. .. ... Hingga saiz temp; jika bit bahkan kemudian menghasilkan nombor dan atau dengan res; pulangan set bit bit walaupun; Tetapkan bit ganjil M; Res untuk kedai 101010.. nombor; menjana borang nombor 101010. .. . . Hingga saiz temp; jika bit bahkan kemudian menghasilkan nombor dan atau dengan res; pulangan set bit ganjil; Tetapkan sedikit nombor n; Tetapkan bit ganjil M; mengambil atau dengan nombor ini; Kod pemacu; n = 1 0 1 0 ^ ^ m = 1 0 1 1 ^ ^ Hasil = 1 0 1 1", "code": "< ? php function setevenbits ( $ n ) { $ temp = $ n ; $ count = 0 ; $ res = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ n & $ res ) ; } function setoddbits ( $ m ) { $ count = 0 ; $ res = 0 ; for ( $ temp = $ m ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 0 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ m & $ res ) ; } function getAlternateBits ( $ n , $ m ) { $ tempn = setevenbits ( $ n ) ; $ tempm = setoddbits ( $ m ) ; return ( $ tempn $ tempm ) ; } $ n = 10 ; $ m = 11 ; echo getAlternateBits ( $ n , $ m ) ; ? >"}
{"text": "Perwakilan perpuluhan rentetan binari yang diberikan dapat dibahagikan dengan 20 atau tidak | fungsi untuk memeriksa sama ada perwakilan perpuluhan nombor binari yang diberikan dapat dibahagikan dengan 10 atau tidak; Jika digit terakhir adalah '1', maka nombor tidak dapat dibahagikan dengan 10; untuk mengumpulkan jumlah digit terakhir dalam kuasa sempurna 2; melintasi dari 2 nd yang terakhir sehingga 1 st digit dalam 'bin'; jika digit dalam '1'; Hitung kedudukan digit dari kanan; Menurut kedudukan digit, dapatkan digit terakhir kuasa sempurna yang berkenaan 2; jika digit terakhir adalah 0, maka dibahagikan dengan 10; tidak boleh dibahagikan dengan 10; fungsi untuk memeriksa sama ada perwakilan perpuluhan nombor binari yang diberikan dapat dibahagikan dengan 20 atau tidak; jika 'bin' adalah nombor ganjil; Semak jika bin (0 ... n - 2) boleh dibahagikan dengan 10 atau tidak; Kod pemacu", "code": "< ? php function isDivisibleBy10 ( $ bin , $ n ) { if ( $ bin [ $ n - 1 ] == '1' ) return false ; $ sum = 0 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ bin [ $ i ] == '1' ) { $ posFromRight = $ n - $ i - 1 ; if ( $ posFromRight % 4 == 1 ) $ sum = $ sum + 2 ; else if ( $ posFromRight % 4 == 2 ) $ sum = $ sum + 4 ; else if ( $ posFromRight % 4 == 3 ) $ sum = $ sum + 8 ; else if ( $ posFromRight % 4 == 0 ) $ sum = $ sum + 6 ; } } if ( $ sum % 10 == 0 ) return true ; return false ; } function isDivisibleBy20 ( $ bin , $ n ) { if ( $ bin [ $ n - 1 ] == '1' ) return false ; return isDivisibleBy10 ( $ bin , $ n - 1 ) ; } $ bin = \"101000\" ; $ n = strlen ( $ bin ) ; if ( isDivisibleBy20 ( $ bin , $ n - 1 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Untuk setiap set bit nombor togol bit lain | fungsi untuk nega_bit; Kod pemacu", "code": "< ? php function toggleBits ( $ n1 , $ n2 ) { return $ n1 ^ $ n2 ; } $ n1 = 2 ; $ n2 = 5 ; echo toggleBits ( $ n1 , $ n2 ) . \" STRNEWLINE \" ; ? >"}
{"text": "Togol semua bit nombor | Mengembalikan nombor yang mempunyai semua bit N bertukar. ; Menjana borang nombor 101010. . sehingga perintah yang sama seperti n; jika bit bahkan kemudian menghasilkan nombor dan atau dengan res; kembali nombor toggled; Kod pemacu", "code": "< ? php function evenbittogglenumber ( $ n ) { $ res = 0 ; $ count = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return $ n ^ $ res ; } $ n = 11 ; echo evenbittogglenumber ( $ n ) ; ? >"}
{"text": "Togol bit pertama dan terakhir nombor | Mengembalikan nombor yang mempunyai kiraan bit yang sama seperti n dan hanya mempunyai bit pertama dan terakhir seperti yang ditetapkan. ; Tetapkan semua bit nombor; Menambah satu hingga n kini tidak menentu semua bit dan bergerak MSB ke satu tempat. Sekarang kita mengalihkan nombor dengan 1 dan tambah 1 .; jika nombor adalah 1; Ambil XOR dengan nombor bit set pertama dan terakhir; Kod pemacu", "code": "< ? php function takeLandFsetbits ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; return ( ( $ n + 1 ) >> 1 ) + 1 ; } function toggleFandLbits ( int $ n ) { if ( $ n == 1 ) return 0 ; return $ n ^ takeLandFsetbits ( $ n ) ; } $ n = 10 ; echo toggleFandLbits ( $ n ) ; ? >"}
{"text": "Nombor Odious | Berfungsi untuk mendapatkan bit yang ditetapkan dalam binari; Periksa sama ada nombor adalah keburukan atau tidak; Kod pemacu", "code": "< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ n &= ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function checkOdious ( $ n ) { return ( countSetBits ( $ n ) % 2 == 1 ) ; } $ num = 32 ; if ( checkOdious ( $ num ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Tetapkan Bit Paling Tinggal Kiri | Tetapkan bit paling tidak tersendiri; Jika nombor mengandungi semua 1 maka kembali n; Cari kedudukan bit paling tidak tersisa. ; jika temp l. S. B adalah sifar maka POS bit tidak berubah adalah perubahan; pulangan atau nombor dan pos bit yang tidak tersendiri; Kod pemacu", "code": "< ? php function setleftmostunsetbit ( $ n ) { if ( ( $ n & ( $ n + 1 ) ) == 0 ) return $ n ; $ pos = 0 ; for ( $ temp = $ n , $ count = 0 ; $ temp > 0 ; $ temp >>= 1 , $ count ++ ) if ( ( $ temp & 1 ) == 0 ) $ pos = $ count ; return ( $ n | ( 1 << ( $ pos ) ) ) ; } $ n = 10 ; echo setleftmostunsetbit ( $ n ) ; ? >"}
{"text": "XOR maksimum menggunakan nombor k dari 1 hingga n | Untuk mengembalikan jumlah max xor 1 hingga n menggunakan kebanyakan nombor k; Jika k adalah 1 maka jumlah maksimum yang mungkin adalah n; Mencari nombor yang lebih besar daripada atau sama dengan n dengan sedikit yang sama sama dengan n. Sebagai contoh, jika n adalah 4, hasilnya adalah 7. Jika n adalah 5 atau 6, hasilnya adalah 7; Return Res - 1 yang menandakan nombor dengan semua bit ditetapkan kepada 1; Kod pemacu", "code": "< ? php function maxXorSum ( $ n , $ k ) { if ( $ k == 1 ) return $ n ; $ res = 1 ; while ( $ res <= $ n ) $ res <<= 1 ; return $ res - 1 ; } $ n = 4 ; $ k = 3 ; echo maxXorSum ( $ n , $ k ) ; ? >"}
{"text": "Kenaikan nombor dengan satu dengan memanipulasi bit | berfungsi untuk mencari kedudukan bit set kanan; fungsi untuk bertukar -tukar bit m yang terakhir; Mengira nombor 'num' mempunyai bit 'm' dan semua ditetapkan; Togol bit terakhir dan kembalikan nombor; berfungsi untuk meningkatkan nombor dengan satu dengan memanipulasi bit; Dapatkan kedudukan paling tidak paling tepat jika semua bit 'n' ditetapkan, maka sedikit yang ditinggalkan ke MSB adalah bit paling tidak paling tepat; KTH bit n sedang ditetapkan oleh operasi ini; Dari kanan togol semua bit sebelum k - th; nombor yang diperlukan; Kod pemacu", "code": "< ? php function getPosOfRightmostSetBit ( $ n ) { $ t = $ n & - $ n ; return log ( $ t , 2 ) ; } function toggleLastKBits ( $ n , $ k ) { $ num = ( 1 << $ k ) - 1 ; return ( $ n ^ $ num ) ; } function incrementByOne ( $ n ) { $ k = getPosOfRightmostSetBit ( ~ $ n ) ; $ n = ( ( 1 << $ k ) $ n ) ; if ( $ k != 0 ) $ n = toggleLastKBits ( $ n , $ k ) ; return $ n ; } $ n = 15 ; echo incrementByOne ( $ n ) ; ? >"}
{"text": "Xnor Dua Nombor | penyelesaian log (n); Pastikan A lebih besar; Untuk sedikit terakhir; untuk bit terakhir B; kaunter untuk bit hitung dan set bit di xnornum; untuk membuat nombor Xnor baru; untuk set bit dalam nombor Xnor baru; Dapatkan sedikit terakhir; dapatkan bit terakhir B; Semak sama ada dua bit semasa adalah sama; kaunter untuk bit Count; Kod pemacu", "code": "< ? php function xnor ( $ a , $ b ) { if ( $ a < $ b ) list ( $ a , $ b ) = array ( $ b , $ a ) ; if ( $ a == 0 && $ b == 0 ) return 1 ; $ a_rem = 0 ; $ b_rem = 0 ; $ count = 0 ; $ xnornum = 0 ; while ( $ a ) { $ a_rem = $ a & 1 ; $ b_rem = $ b & 1 ; if ( $ a_rem == $ b_rem ) $ xnornum |= ( 1 << $ count ) ; $ count ++ ; $ a = $ a >> 1 ; $ b = $ b >> 1 ; } return $ xnornum ; } $ a = 10 ; $ b = 50 ; echo xnor ( $ a , $ b ) ; ? >"}
{"text": "Xnor Dua Nombor | Sila rujuk di bawah siaran untuk butiran fungsi ini https: www. Geeksforgeeks. org / toggle - bit - signifikan - bit /; Buat salinan N kerana kami akan mengubahnya. ; Katakan N ialah 273 (binari ialah 100010001). Ia mengikuti 100010001 | 010001000 = 110011001; Ini memastikan 4 bit (dari MSB dan termasuk MSB) ditetapkan. Ia mengikuti 110011001 | 001100110 = 111111111; Mengembalikan xnor num1 dan num2; Jika NUM2 lebih besar maka kita menukar nombor ini dalam NUM1; Kod pemacu", "code": "< ? php function togglebit ( $ n ) { if ( $ n == 0 ) return 1 ; $ i = $ n ; $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; return $ i ^ $ n ; } function XNOR ( $ num1 , $ num2 ) { if ( $ num1 < $ num2 ) list ( $ num1 , $ num2 ) = array ( $ num2 , $ num1 ) ; $ num1 = togglebit ( $ num1 ) ; return $ num1 ^ $ num2 ; } $ num1 = 10 ; $ num2 = 20 ; echo XNOR ( $ num1 , $ num2 ) ; ? >"}
{"text": "Maksimum atau jumlah sub | berfungsi untuk mencari maksimum atau jumlah; Atau jumlah semua elemen dalam kedua -dua tatasusunan; Kod pemacu", "code": "< ? php function MaximumSum ( $ a , $ b , $ n ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 |= $ a [ $ i ] ; $ sum2 |= $ b [ $ i ] ; } echo ( $ sum1 + $ sum2 ) . \" STRNEWLINE \" ; } $ A = array ( 1 , 2 , 4 , 3 , 2 ) ; $ B = array ( 2 , 3 , 3 , 12 , 1 ) ; $ n = sizeof ( $ A ) / sizeof ( $ A [ 0 ] ) ; MaximumSum ( $ A , $ B , $ n ) ; ? >"}
{"text": "Semak sama ada kedua -dua nombor berbeza pada satu kedudukan bit sahaja | fungsi untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; berfungsi untuk memeriksa sama ada kedua -dua nombor berbeza pada satu kedudukan bit sahaja; Kod pemacu", "code": "< ? php function isPowerOfTwo ( $ x ) { $ y = 0 ; if ( $ x && ( ! ( $ x & ( $ x - 1 ) ) ) ) $ y = 1 ; return $ y ; } function differAtOneBitPos ( $ a , $ b ) { return isPowerOfTwo ( $ a ^ $ b ) ; } $ a = 13 ; $ b = 9 ; if ( differAtOneBitPos ( $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Pendaraban dengan kuasa 2 | Pulangan 2 dibangkitkan kepada kuasa n; Kod pemacu", "code": "< ? php function power2 ( $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n == 1 ) return 2 ; return power2 ( $ n / 2 ) * power2 ( $ n / 2 ) ; } function multiply ( $ x , $ n ) { return $ x * power2 ( $ n ) ; } $ x = 70 ; $ n = 2 ; echo multiply ( $ x , $ n ) ; ? >"}
{"text": "Pendaraban dengan kuasa 2 | Program php yang cekap untuk mengira x * (2 ^ n); Kod pemacu", "code": "< ? php function multiply ( $ x , $ n ) { return $ x << $ n ; } $ x = 70 ; $ n = 2 ; echo multiply ( $ x , $ n ) ; ? >"}
{"text": "Semak jika n boleh dibahagikan dengan kuasa 2 tanpa menggunakan pengendali aritmetik | fungsi untuk memeriksa sama ada n boleh dibahagikan dengan pow (2, m); Jika hasil ekspresi kepada 0, maka n boleh dibahagikan dengan pow (2, m); n tidak boleh dibahagikan; Kod pemacu", "code": "< ? php function isDivBy2PowerM ( $ n , $ m ) { if ( ( $ n & ( ( 1 << $ m ) - 1 ) ) == 0 ) return true ; return false ; } $ n = 8 ; $ m = 2 ; if ( isDivBy2PowerM ( $ n , $ m ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Permainan Nim dengan penyingkiran satu batu dibenarkan | Kembali benar jika pemain A menang, kembali palsu jika pemain B menang. ; Memeriksa bit terakhir n. ; Kod pemacu", "code": "< ? php function findWinner ( $ N ) { return $ N & 1 ; } $ N = 15 ; if ( findWinner ( $ N ) ) echo \" Player ▁ A \" ; else echo \" Player ▁ B \" ; ? >"}
{"text": "Togol semua bit ganjil nombor | Mengembalikan nombor yang mempunyai semua bit ganjil N bertukar. ; Menjana borang nombor 101010. .. . . . sehingga perintah yang sama seperti n; Jika bit adalah ganjil, maka menjana nombor dan atau dengan res; kembali nombor toggled; Kod pemacu", "code": "< ? php function evenbittogglenumber ( $ n ) { $ res = 0 ; $ count = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 0 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return $ n ^ $ res ; } $ n = 11 ; echo evenbittogglenumber ( $ n ) ; ? >"}
{"text": "Quotient and Remainder Dividing by 2 ^ K (A Power of 2) | berfungsi untuk mencetak baki dan kuota; cetak sisa oleh n dan (m - 1); Cetak quotient oleh peralihan kanan n oleh (log (m, 2)) kali 2 adalah asas; Kod pemacu", "code": "< ? php function divide ( $ n , $ m ) { echo \" Remainder = \" . ▁ ( ( $ n ) ▁ & ( $ m ▁ - ▁ 1 ) ) ; STRNEWLINE TABSYMBOL echo ▁ \" Quotient = \" } $ n = 43 ; $ m = 8 ; divide ( $ n , $ m ) ; ? >"}
{"text": "Maksimum dan nilai pasangan dalam array | Fungsi untuk mencari pasangan maksimum dan nilai; Kod pemacu", "code": "< ? php function maxAND ( $ arr , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ res = max ( $ res , $ arr [ $ i ] & $ arr [ $ j ] ) ; return $ res ; } $ arr = array ( 4 , 8 , 6 , 2 ) ; $ n = count ( $ arr ) ; echo \" Maximum ▁ AND ▁ Value ▁ = ▁ \" , maxAND ( $ arr , $ n ) ; ? >"}
{"text": "Semak sama ada nombor positif, negatif atau sifar menggunakan pengendali bit | fungsi untuk mengembalikan 1 jika ia adalah sifar pulangan 0 jika ia adalah pulangan negatif 2 jika ia positif; array rentetan untuk menyimpan semua jenis nombor; panggilan fungsi untuk memeriksa tanda nombor; Kod pemacu", "code": "< ? php function index ( $ i ) { return 1 + ( $ i >> 31 ) - ( - $ i >> 31 ) ; } function check ( $ n ) { $ s = array ( \" negative \" , \" zero \" , \" positive \" ) ; $ val = index ( $ n ) ; echo $ n , \" ▁ is ▁ \" , $ s [ $ val ] , \" STRNEWLINE \" ; } check ( 30 ) ; check ( -20 ) ; check ( 0 ) ; ? >"}
{"text": "Divisibility oleh 64 dengan penyingkiran bit dibenarkan | fungsi untuk memeriksa sama ada mungkin untuk menjadikannya pelbagai 64 .; kaunter untuk mengira 0; panjang rentetan; gelung yang melintasi ke kiri dan mengira bilangan sifar sebelum 1 .; Kod pemacu", "code": "< ? php function checking ( $ s ) { $ c = 0 ; $ n = strlen ( $ s ) ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ s [ $ i ] == '0' ) $ c ++ ; if ( $ c >= 6 and $ s [ $ i ] == '1' ) return true ; } return false ; } $ s = \"100010001\" ; if ( checking ( $ s ) ) echo \" Possible \" ; else echo \" Not ▁ possible \" ; ? >"}
{"text": "Ubah suai sedikit pada kedudukan tertentu | Pulangan diubah suai n. ; Kod pemacu", "code": "< ? php function modifyBit ( $ n , $ p , $ b ) { $ mask = 1 << $ p ; return ( $ n & ~ $ mask ) | ( ( $ b << $ p ) & $ mask ) ; } echo modifyBit ( 6 , 2 , 0 ) , \" STRNEWLINE \" ; echo modifyBit ( 6 , 5 , 1 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Count set bit dalam julat | Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari 'n'; fungsi untuk mengira set bit dalam julat yang diberikan; Mengira nombor 'num' mempunyai bilangan bit dan bit dalam julat L ke r adalah satu -satunya bit yang ditetapkan; Mengembalikan bilangan bit set dalam julat 'l' ke 'r' dalam 'n'; Kod pemacu", "code": "< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ n &= ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function countSetBitsInGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; return countSetBits ( $ n & $ num ) ; } $ n = 42 ; $ l = 2 ; $ r = 5 ; echo countSetBitsInGivenRange ( $ n , $ l , $ r ) ; ? >"}
{"text": "Semak jika salah satu daripada nombor adalah pelengkap yang lain | fungsi untuk memeriksa sama ada semua bit ditetapkan atau tidak dalam perwakilan binari 'n'; Semua bit tidak ditetapkan; Jika benar, maka semua bit ditetapkan; lain semua bit tidak ditetapkan; berfungsi untuk memeriksa sama ada salah satu daripada dua nombor adalah pelengkap yang lain; Kod pemacu", "code": "< ? php function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return false ; if ( ( ( $ n + 1 ) & $ n ) == 0 ) return true ; return false ; } function isOnesComplementOfOther ( $ a , $ b ) { return areAllBitsSet ( $ a ^ $ b ) ; } $ a = 10 ; $ b = 5 ; if ( isOnesComplementOfOther ( $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Unsur unik dalam array di mana semua elemen berlaku k kali kecuali satu | Program PHP untuk mencari elemen yang unik di mana setiap elemen muncul kali Kecuali satu; Buat array kiraan untuk menyimpan kiraan nombor yang mempunyai set bit tertentu. Kira [i] menyimpan kiraan elemen array dengan set bit i - th. ; Dan (bitwise) setiap elemen array dengan setiap digit set (satu demi satu) untuk mendapatkan kiraan bit set pada setiap kedudukan; Sekarang pertimbangkan semua bit yang kiraannya tidak berbilang k untuk membentuk nombor yang diperlukan. ; Kod pemacu", "code": "< ? php function findUnique ( $ a , $ n , $ k ) { $ INT_SIZE = 8 * PHP_INT_SIZE ; $ count = array ( ) ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) $ count [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ a [ $ j ] & ( 1 << $ i ) ) != 0 ) $ count [ $ i ] += 1 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) $ res += ( $ count [ $ i ] % $ k ) * ( 1 << $ i ) ; return $ res ; } $ a = array ( 6 , 2 , 5 , 2 , 2 , 6 , 6 ) ; $ n = count ( $ a ) ; $ k = 3 ; echo findUnique ( $ a , $ n , $ k ) ; ? >"}
{"text": "Semak sama ada nombor itu hanya set bit pertama dan terakhir | fungsi untuk memeriksa sama ada 'n' adalah kuasa 2 atau tidak; berfungsi untuk memeriksa sama ada nombor itu hanya set bit pertama dan terakhir; Kod pemacu", "code": "< ? php function powerOfTwo ( $ n ) { return ( ! ( $ n & $ n - 1 ) ) ; } function onlyFirstAndLastAreSet ( $ n ) { if ( $ n == 1 ) return true ; if ( $ n == 2 ) return false ; return powerOfTwo ( $ n - 1 ) ; } $ n = 9 ; if ( onlyFirstAndLastAreSet ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak jika nombor mempunyai bit dalam corak alternatif | Set | fungsi untuk memeriksa sama ada semua bit ditetapkan atau tidak dalam perwakilan binari 'n'; Jika benar, maka semua bit ditetapkan; lain semua bit tidak ditetapkan; berfungsi untuk memeriksa sama ada nombor mempunyai bit dalam corak alternatif; Untuk memeriksa sama ada semua bit ditetapkan dalam 'num'; Kod pemacu", "code": "< ? php function allBitsAreSet ( $ n ) { if ( ( ( $ n + 1 ) & $ n ) == 0 ) return true ; return false ; } function bitsAreInAltOrder ( $ n ) { $ num = $ n ^ ( $ n >> 1 ) ; return allBitsAreSet ( $ num ) ; } $ n = 10 ; if ( bitsAreInAltOrder ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Flip minimum yang diperlukan untuk memaksimumkan nombor dengan k set set | Fungsi untuk mencari set bit; Kembali kiraan set bit; fungsi untuk mencari min flip; bilangan bit dalam n; Cari bilangan terbesar saiz yang sama dengan bit set k; Mengira sedikit perbezaan untuk mencari pembatalan yang diperlukan. ; Kod pemacu", "code": "< ? php function setBit ( $ xorValue ) { $ count = 0 ; while ( $ xorValue ) { if ( $ xorValue % 2 ) $ count ++ ; $ xorValue /= 2 ; } return $ count ; } function minFlip ( $ n , $ k ) { $ size = log ( $ n ) + 1 ; $ max = pow ( 2 , $ k ) - 1 ; $ max = $ max << ( $ size - $ k ) ; $ xorValue = ( $ n ^ $ max ) ; return ( setBit ( $ xorValue ) ) ; } $ n = 27 ; $ k = 3 ; echo \" Min ▁ Flips ▁ = ▁ \" , minFlip ( $ n , $ k ) ; ? >"}
{"text": "Tetapkan semua bit dalam julat nombor yang diberikan | berfungsi untuk bertukar -tukar bit dalam julat yang diberikan; Mengira nombor 'julat' yang telah menetapkan bit dalam julat dari L ke R dan semua bit lain sebagai 0 (atau Unset). ; Kod pemacu", "code": "< ? php function setallbitgivenrange ( $ n , $ l , $ r ) { $ range = ( ( ( 1 << ( $ l - 1 ) ) - 1 ) ^ ( ( 1 << ( $ r ) ) - 1 ) ) ; return ( $ n $ range ) ; } $ n = 17 ; $ l = 2 ; $ r = 3 ; echo setallbitgivenrange ( $ n , $ l , $ r ) ; ? >"}
{"text": "Kira jumlah bit dalam nombor | Program PHP untuk mencari jumlah bit dalam nombor tertentu; Fungsi log di pangkalan 2 hanya mengambil bahagian integer; Kod pemacu", "code": "< ? php function countBits ( $ number ) { return ( int ) ( log ( $ number ) / log ( 2 ) ) + 1 ; } $ num = 65 ; echo ( countBits ( $ num ) ) ; ? >"}
{"text": "Semak sama ada semua bit tidak tersendiri dalam julat yang diberikan atau tidak | berfungsi untuk memeriksa sama ada semua bit tidak tersendiri dalam julat yang diberikan atau tidak; Mengira nombor 'num' mempunyai bilangan bit dan bit dalam julat L ke r adalah satu -satunya bit yang ditetapkan; Nombor baru yang hanya akan mempunyai satu atau lebih bit set dalam julat L ke R dan tempat lain; Jika num baru adalah 0, maka semua bit tidak tersendiri dalam julat yang diberikan; Selain itu semua bit tidak tidak tersendiri; Kod pemacu", "code": "< ? php function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ new_num == 0 ) return \" Yes \" ; return \" No \" ; } $ n = 17 ; $ l = 2 ; $ r = 4 ; echo allBitsSetInTheGivenRange ( $ n , $ l , $ r ) ; ? >"}
{"text": "Togol semua bit selepas bit yang paling penting | Mengembalikan nombor yang mempunyai semua bit set bermula dari MSB N; Ini memastikan dua bit (dari MSB dan termasuk MSB) ditetapkan; Ini memastikan 4 bit (dari MSB dan termasuk MSB) ditetapkan; Kod pemacu", "code": "< ? php function setAllBitsAfterMSB ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; return $ n ; } function toggle ( & $ n ) { $ n = $ n ^ setAllBitsAfterMSB ( $ n ) ; } $ n = 10 ; toggle ( $ n ) ; echo $ n ; ? >"}
{"text": "Kedudukan Bit paling umum dalam dua nombor | Fungsi untuk mencari kedudukan set paling kanan dalam 'n'; Fungsi untuk mencari kedudukan paling tepat yang sama dalam perwakilan binari 'M' dan 'N'; kedudukan paling tepat sama; Kod pemacu", "code": "< ? php function getRightMostSetBit ( $ n ) { return log ( $ n & - $ n ) + 1 ; } function posOfRightMostSameBit ( $ m , $ n ) { return getRightMostSetBit ( ~ ( $ m ^ $ n ) ) ; } $ m = 16 ; $ n = 7 ; echo \" Position ▁ = ▁ \" , ceil ( posOfRightMostSameBit ( $ m , $ n ) ) ; ? >"}
{"text": "Semak sama ada semua bit ditetapkan dalam julat yang diberikan | fungsi untuk memeriksa sama ada semua bit ditetapkan dalam julat yang diberikan atau tidak; Mengira nombor 'num' mempunyai bilangan bit dan bit dalam julat L ke r adalah satu -satunya bit yang ditetapkan; Nombor baru yang hanya akan mempunyai satu atau lebih bit set dalam julat L ke R dan tempat lain; Jika kedua -duanya sama, maka semua bit ditetapkan dalam julat yang diberikan; lain semua bit tidak ditetapkan; Kod pemacu", "code": "< ? php function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ num == $ new_num ) return \" Yes \" ; return \" No \" ; } $ n = 22 ; $ l = 2 ; $ r = 3 ; echo allBitsSetInTheGivenRange ( $ n , $ l , $ r ) ; ? >"}
{"text": "1 hingga n bit nombor tanpa berturut -turut 1 s dalam perwakilan binari | Cetak semua nombor sehingga n bit tanpa bit set berturut -turut. ; Marilah kita mengira pertama 2 dibangkitkan kepada kuasa n. ; gelung 1 hingga n untuk memeriksa semua nombor; Nombor yang saya tidak mempunyai ~ consecutive »set u bit f '» bitwise dan u u u u u u u u. ; Kod pemacu", "code": "< ? php function printNonConsecutive ( $ n ) { $ p = ( 1 << $ n ) ; for ( $ i = 1 ; $ i < $ p ; $ i ++ ) if ( ( $ i & ( $ i << 1 ) ) == 0 ) echo $ i . \" \" ; } $ n = 3 ; printNonConsecutive ( $ n ) ; ? >"}
{"text": "Cari n | Program php yang cekap untuk mencari palindrome n - th; Bina palindrome binari n dengan nombor kumpulan yang diberikan, aux_number dan jenis operasi; Tidak perlu memasukkan bit di tengah; Panjang perwakilan binari terakhir; Isi bit pertama dan terakhir sebagai 1; Mula mengisi A [] dari tengah, dengan perwakilan binari Aux_num; Dapatkan bit nombor tambahan dan isi tengah; Masukkan bit 0 di tengah; Panjang perwakilan binari terakhir; Isi bit pertama dan terakhir sebagai 1; Mula mengisi A [] dari tengah, dengan perwakilan binari Aux_num; Dapatkan bit nombor tambahan dan isi tengah; lain masukkan bit 1 di tengah; Panjang perwakilan binari terakhir; Isi bit pertama dan terakhir sebagai 1; Mula mengisi A [] dari tengah, dengan perwakilan binari Aux_num; Dapatkan bit nombor tambahan dan isi tengah; Tukar nombor kepada perpuluhan dari binari; Akan mengembalikan nombor palindrome binari n; Tambah bilangan elemen dalam semua kumpulan, sehingga kumpulan nombor n dijumpai; Jumlah bilangan elemen sehingga kumpulan ini; Kedudukan mengimbangi elemen dalam kumpulan; Mencari yang sedikit yang akan diletakkan di tengah dan mencari nombor, yang akan kami isi dari tengah ke kedua -dua arah; Kita perlu mengisi nombor tambahan ini dalam bentuk binari tengah di kedua -dua arah; $ op = 0; Perlu memasukkan 0 di tengah; $ op = 1; Perlu memasukkan 1 di tengah; Kod pemacu; Panggilan fungsi", "code": "< ? php $ INT_SIZE = 32 ; function constructNthNumber ( $ group_no , $ aux_num , $ op ) { global $ INT_SIZE ; $ a = array_fill ( 0 , $ INT_SIZE , 0 ) ; $ num = 0 ; $ i = 0 ; $ len_f = 0 ; if ( $ op == 2 ) { $ len_f = 2 * $ group_no ; $ a [ $ len_f - 1 ] = $ a [ 0 ] = 1 ; while ( $ aux_num ) { $ a [ $ group_no + i ] = $ a [ $ group_no - 1 - $ i ] = $ aux_num & 1 ; $ aux_num = $ aux_num >> 1 ; $ i ++ ; } } else if ( $ op == 0 ) { $ len_f = 2 * $ group_no + 1 ; $ a [ $ len_f - 1 ] = $ a [ 0 ] = 1 ; $ a [ $ group_no ] = 0 ; while ( $ aux_num ) { $ a [ $ group_no + 1 + $ i ] = $ a [ $ group_no - 1 - $ i ] = $ aux_num & 1 ; $ aux_num = $ aux_num >> 1 ; $ i ++ ; } } { $ len_f = 2 * $ group_no + 1 ; $ a [ $ len_f - 1 ] = $ a [ 0 ] = 1 ; $ a [ $ group_no ] = 1 ; while ( $ aux_num ) { $ a [ $ group_no + 1 + $ i ] = $ a [ $ group_no - 1 - $ i ] = $ aux_num & 1 ; $ aux_num = $ aux_num >> 1 ; $ i ++ ; } } for ( $ i = 0 ; $ i < $ len_f ; $ i ++ ) $ num += ( 1 << $ i ) * $ a [ $ i ] ; return $ num ; } function getNthNumber ( $ n ) { $ group_no = 0 ; $ count_upto_group = 0 ; $ count_temp = 1 ; $ op = $ aux_num = 0 ; while ( $ count_temp < $ n ) { $ group_no ++ ; $ count_upto_group = $ count_temp ; $ count_temp += 3 * ( 1 << ( $ group_no - 1 ) ) ; } $ group_offset = $ n - $ count_upto_group - 1 ; if ( ( $ group_offset + 1 ) <= ( 1 << ( $ group_no - 1 ) ) ) { $ aux_num = $ group_offset ; } else { if ( ( ( $ group_offset + 1 ) - ( 1 << ( $ group_no - 1 ) ) ) % 2 ) else $ aux_num = ( int ) ( ( ( $ group_offset ) - ( 1 << ( $ group_no - 1 ) ) ) / 2 ) ; } return constructNthNumber ( $ group_no , $ aux_num , $ op ) ; } $ n = 9 ; print ( getNthNumber ( $ n ) ) ; ? >"}
{"text": "Jumlah nombor dengan tepat 2 bit set | Untuk mengira bilangan bit yang ditetapkan; Untuk mengira jumlah nombor; Untuk mengira jumlah nombor yang 2 bit ditetapkan; Kod pemacu", "code": "< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ n &= ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) if ( countSetBits ( $ i ) == 2 ) $ sum += $ i ; return $ sum ; } $ n = 10 ; echo findSum ( $ n ) ; ? >"}
{"text": "Togol bit terakhir | | fungsi untuk bertukar -tukar bit m yang terakhir; Mengira nombor 'num' mempunyai bit 'm' dan semua ditetapkan. ; Togol bit terakhir dan kembalikan nombor; Kod pemacu", "code": "< ? php function toggleLastMBits ( $ n , $ m ) { $ num = ( 1 << $ m ) - 1 ; return ( $ n ^ $ num ) ; } { $ n = 107 ; $ m = 4 ; echo toggleLastMBits ( $ n , $ m ) ; return 0 ; } ? >"}
{"text": "Integer yang lebih kecil sebelum ini mempunyai satu bilangan bit set yang kurang | Fungsi untuk mencari kedudukan bit set kanan. ; berfungsi untuk mencari integer yang lebih kecil sebelumnya; Kedudukan set paling kanan N; matikan atau tidak tersendiri bit pada kedudukan 'pos'; Kod pemacu", "code": "< ? php function getFirstSetBitPos ( $ n ) { return log ( $ n & - $ n ) + 1 ; } function previousSmallerInteger ( $ n ) { $ pos = getFirstSetBitPos ( $ n ) ; return ( $ n & ~ ( 1 << ( $ pos - 1 ) ) ) ; } $ n = 25 ; echo \" Previous ▁ smaller ▁ Integer ▁ = ▁ \" , previousSmallerInteger ( $ n ) ; ? >"}
{"text": "Semak jika semua bit nombor ditetapkan | fungsi untuk memeriksa sama ada semua bit ditetapkan atau tidak dalam perwakilan binari 'n'; Semua bit tidak ditetapkan; gelung sehingga n menjadi '0'; Jika bit terakhir tidak ditetapkan; shift kanan 'n' oleh 1; Semua bit ditetapkan; Kod pemacu", "code": "< ? php function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return \" No \" ; while ( $ n > 0 ) { if ( ( $ n & 1 ) == 0 ) return \" No \" ; $ n = $ n >> 1 ; } return \" Yes \" ; } $ n = 7 ; echo areAllBitsSet ( $ n ) ; ? >"}
{"text": "Semak jika semua bit nombor ditetapkan | fungsi untuk memeriksa sama ada semua bit ditetapkan atau tidak dalam perwakilan binari 'n'; Semua bit tidak ditetapkan; Jika benar, maka semua bit ditetapkan; lain semua bit tidak ditetapkan; Kod pemacu", "code": "< ? php function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return \" No \" ; if ( ( ( $ n + 1 ) & $ n ) == 0 ) return \" Yes \" ; return \" No \" ; } $ n = 7 ; echo areAllBitsSet ( $ n ) ; ? >"}
{"text": "Integer yang lebih besar seterusnya mempunyai satu lagi bit set | Fungsi untuk mencari kedudukan bit set kanan. Pulangan - 1 jika tiada bit set; berfungsi untuk mencari integer yang lebih besar seterusnya; Kedudukan bit yang paling tidak tersendiri n dengan lulus ~ n sebagai argumen; Jika n terdiri daripada bit yang tidak tersembunyi, kemudian tetapkan bit paling tidak paling tepat; n tidak terdiri daripada bit yang tidak tersembunyi; Kod pemacu", "code": "< ? php function getFirstSetBitPos ( $ n ) { return ( log ( $ n & - $ n + 1 ) ) - 1 ; } function nextGreaterWithOneMoreSetBit ( $ n ) { $ pos = getFirstSetBitPos ( ~ $ n ) ; if ( $ pos > -1 ) return ( 1 << $ pos ) | $ n ; return ( ( $ n << 1 ) + 1 ) ; } $ n = 10 ; echo \" Next ▁ greater ▁ integer ▁ = ▁ \" , nextGreaterWithOneMoreSetBit ( $ n ) ; ? >"}
{"text": "Kira nombor yang jumlahnya dengan x sama dengan xor dengan x | Berfungsi untuk mencari jumlah 0 bit dalam nombor; Fungsi untuk mencari kiraan nombor bukan negatif kurang daripada atau sama dengan x, yang bitwise XOR dan jumlah dengan x adalah sama. ; kiraan bilangan sifar bit dalam x; kuasa 2 untuk dikira; Kod pemacu; Panggilan fungsi", "code": "< ? php function CountZeroBit ( $ x ) { $ count = 0 ; while ( $ x ) { if ( ! ( $ x & 1 ) ) $ count ++ ; $ x >>= 1 ; } return $ count ; } function CountXORandSumEqual ( $ x ) { $ count = CountZeroBit ( $ x ) ; return ( 1 << $ count ) ; } $ x = 10 ; echo CountXORandSumEqual ( $ x ) ; ? >"}
{"text": "Cari nombor yang hilang dalam array lain yang disalurkan salinan | Mengembalikan saiz nombor yang hilang dari ARR2 [] adalah n - 1; Kehilangan nombor 'mnum'; Arahan 1 adalah saiz 'n'; 2 nd array adalah saiz 'n' »~ 1 '; Nombor yang hilang yang diperlukan; Kod pemacu", "code": "< ? php function missingNumber ( $ arr1 , $ arr2 , $ n ) { $ mnum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mnum = $ mnum ^ $ arr1 [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ mnum = $ mnum ^ $ arr2 [ $ i ] ; return $ mnum ; } $ arr1 = array ( 4 , 8 , 1 , 3 , 7 ) ; $ arr2 = array ( 7 , 4 , 3 , 1 ) ; $ n = count ( $ arr1 ) ; echo \" Missing ▁ number ▁ = ▁ \" , missingNumber ( $ arr1 , $ arr2 , $ n ) ; ? >"}
{"text": "Tukar bit untuk membuat spesifik atau nilai | Mengembalikan max tiga nombor; Mengembalikan kiraan bit dalam n; Mengembalikan sedikit pada kedudukan 'pos'; Kaedah utiliti untuk bertukar sedikit pada kedudukan 'pos'; kaedah mengembalikan bilangan minimum bit flip untuk mendapatkan T sebagai atau nilai A dan B; Gelung ke atas bilangan maksimum bit di antara A, B dan T; T 's bit ditetapkan, cuba togol sedikit b, jika belum lagi; Jika bit A ditetapkan, flip itu; Jika bit b ditetapkan, flip itu; Jika k kurang daripada 0 maka kita boleh membuat | B == t; Gelung ke atas bit sekali lagi untuk meminimumkan lagi; Jika kedua -dua bit ditetapkan, maka tidak jelas sedikit untuk meminimumkannya; Jika A 's' 'u' dan bit adalah 0, bertukar -tukar kedua -duanya; Output berubah nilai a dan b; Kod pemacu", "code": "< ? php function maxDD ( $ a , $ b , $ c ) { return max ( $ a , ( max ( $ b , $ c ) ) ) ; } function bitCount ( $ N ) { $ cnt = 0 ; while ( $ N ) { $ cnt ++ ; $ N >>= 1 ; } return $ cnt ; } function at_position ( $ num , $ pos ) { $ bit = $ num & ( 1 << $ pos ) ; return $ bit ; } function toggle ( & $ num , $ pos ) { $ num ^= ( 1 << $ pos ) ; } function minChangeToReachTaregetOR ( $ A , $ B , $ K , $ T ) { $ maxlen = max ( bitCount ( $ A ) , bitCount ( $ B ) , bitCount ( $ T ) ) ; for ( $ i = $ maxlen - 1 ; $ i >= 0 ; $ i -- ) { $ bitA = at_position ( $ A , $ i ) ; $ bitB = at_position ( $ B , $ i ) ; $ bitT = at_position ( $ T , $ i ) ; if ( $ bitT ) { if ( ! $ bitA && ! $ bitB ) { toggle ( $ B , $ i ) ; $ K -- ; } } else { if ( $ bitA ) { toggle ( $ A , $ i ) ; $ K -- ; } if ( $ bitB ) { toggle ( $ B , $ i ) ; $ K -- ; } } } if ( $ K < 0 ) { echo \" Not ▁ possible STRNEWLINE \" ; return ; } for ( $ i = $ maxlen - 1 ; $ K > 0 && $ i >= 0 ; -- $ i ) { $ bitA = at_position ( $ A , $ i ) ; $ bitB = at_position ( $ B , $ i ) ; $ bitT = at_position ( $ T , $ i ) ; if ( $ bitT ) { if ( $ bitA && $ bitB ) { toggle ( $ A , $ i ) ; $ K -- ; } } if ( $ bitA && ! $ bitB && $ K >= 2 ) { toggle ( $ A , $ i ) ; toggle ( $ B , $ i ) ; $ K -= 2 ; } } echo $ A , \" \" ▁ , ▁ $ B ▁ , ▁ \" \" } $ A = 175 ; $ B = 66 ; $ K = 5 ; $ T = 100 ; minChangeToReachTaregetOR ( $ A , $ B , $ K , $ T ) ; ? >"}
{"text": "Kira nilai yang lebih kecil yang XOR dengan x lebih besar daripada x | Program PHP untuk mencari kiraan nilai yang XOR dengan x lebih besar daripada x dan nilai lebih kecil daripada x; Memulakan hasil; Melintasi semua bit x; Jika bit terakhir X semasa ditetapkan maka kiraan kenaikan oleh n. Di sini n adalah kuasa 2 yang sepadan dengan kedudukan bit; Secara serentak mengira 2 ^ n; Ganti x dengan x / 2; ; Kod pemacu", "code": "< ? php function countValues ( $ x ) { $ count = 0 ; $ n = 1 ; while ( $ x != 0 ) { if ( $ x % 2 == 0 ) $ count += $ n ; $ n *= 2 ; $ x /= 2 ; $ x = ( int ) $ x ; } return $ count ; } $ x = 10 ; echo countValues ( $ x ) ; ? >"}
{"text": "Membina array dari xor semua elemen array kecuali elemen pada indeks yang sama | berfungsi untuk membina array baru; Kirakan XOR array; Arahan kemas kini; Kod pemacu; hasil cetak", "code": "< ? php function constructXOR ( & $ A , $ n ) { $ XOR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ XOR ^= $ A [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ A [ $ i ] = $ XOR ^ $ A [ $ i ] ; } $ A = array ( 2 , 4 , 1 , 3 , 5 ) ; $ n = sizeof ( $ A ) ; constructXOR ( $ A , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ A [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Kira semua pasang array yang berbeza dalam k bit | Fungsi utiliti untuk mengira jumlahnya dalam nombor; Berfungsi untuk mengira pasangan k bit yang berbeza; memulakan jawapan akhir; Semak k berbeza bit; Kod pemacu", "code": "< ? php function bitCount ( $ n ) { $ count = 0 ; while ( $ n ) { if ( $ n & 1 ) ++ $ count ; $ n >>= 1 ; } return $ count ; } function countPairsWithKDiff ( $ arr , $ n , $ k ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { for ( $ j = $ i + 1 ; $ j < $ n ; ++ $ j ) { $ xoredNum = $ arr [ $ i ] ^ $ arr [ $ j ] ; if ( $ k == bitCount ( $ xoredNum ) ) ++ $ ans ; } } return $ ans ; } $ k = 2 ; $ arr = array ( 2 , 4 , 1 , 3 , 1 ) ; $ n = count ( $ arr ) ; echo \" Total ▁ pairs ▁ for ▁ k ▁ = ▁ \" , $ k , \" ▁ are ▁ \" , countPairsWithKDiff ( $ arr , $ n , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text": "Pendaraban dua nombor dengan pengendali peralihan | Fungsi untuk pendaraban; Semak set bit dan shift kiri N, kiraan masa; kenaikan nilai tempat (kiraan); Kod pemacu", "code": "< ? php function multiply ( $ n , $ m ) { $ ans = 0 ; $ count = 0 ; while ( $ m ) { if ( $ m % 2 == 1 ) $ ans += $ n << $ count ; $ count ++ ; $ m /= 2 ; } return $ ans ; } $ n = 20 ; $ m = 13 ; echo multiply ( $ n , $ m ) ; ? >"}
{"text": "Bandingkan dua bilangan bulat tanpa menggunakan sebarang pengendali perbandingan | fungsi kembali benar jika a ^ b> 0 lain palsu; Kod pemacu", "code": "< ? php function EqualNumber ( $ A , $ B ) { return ( $ A ^ $ B ) ; } $ A = 5 ; $ B = 6 ; echo ( ( int ) ! ( EqualNumber ( $ A , $ B ) ) ) . \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika bit nombor mempunyai kiraan bit set berturut -turut dalam peningkatan urutan | Pulangan benar jika N mempunyai tuduhan berturut -turut 1 adalah perintah yang semakin meningkat. ; Memulakan kiraan sebelumnya; Kami melintasi bit dari kanan ke kiri dan periksa sama ada kiraan penurunan pesanan. ; Abaikan 0 s sehingga kita mencapai sedikit set. ; Mengira bit set semasa; Bandingkan semasa dengan sebelumnya dan kemas kini sebelumnya. ; Kod pemacu", "code": "< ? php function areSetBitsIncreasing ( $ n ) { $ prev_count = PHP_INT_MAX ; while ( $ n > 0 ) { while ( $ n > 0 && $ n % 2 == 0 ) $ n = $ n / 2 ; $ curr_count = 1 ; while ( $ n > 0 and $ n % 2 == 1 ) { $ n = $ n / 2 ; $ curr_count ++ ; } if ( $ curr_count >= $ prev_count ) return false ; $ prev_count = $ curr_count ; } return true ; } $ n = 10 ; if ( areSetBitsIncreasing ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak jika nombor mempunyai bit dalam corak alternatif | Tetapkan 1 | Pulangan benar jika n mempunyai corak bit alternatif lain palsu; Simpan sedikit terakhir; Melintasi bit yang tersisa; Jika bit semasa adalah sama seperti sebelumnya; Kod pemacu", "code": "< ? php function findPattern ( $ n ) { $ prev = $ n % 2 ; $ n = $ n / 2 ; while ( $ n > 0 ) { $ curr = $ n % 2 ; if ( $ curr == $ prev ) return false ; $ prev = $ curr ; $ n = floor ( $ n / 2 ) ; } return true ; } $ n = 10 ; if ( findPattern ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; return 0 ; ? >"}
{"text": "Kiraan XOR 0 S dan 1 S dalam Perwakilan Perduaan | Mengembalikan xor Counts 0 s dan 1 s dalam perwakilan binari n. ; mengira kiraan sifar dan yang; Kod pemacu", "code": "< ? php function countXOR ( $ n ) { $ count0 = 0 ; $ count1 = 0 ; while ( $ n ) { ( $ n % 2 == 0 ) ? $ count0 ++ : $ count1 ++ ; $ n = intval ( $ n / 2 ) ; } return ( $ count0 ^ $ count1 ) ; } $ n = 31 ; echo countXOR ( $ n ) ; ? >"}
{"text": "Bitwise dan (atau &) pelbagai | Cari kedudukan MSB dalam n. Sebagai contoh jika n = 17, maka kedudukan MSB adalah 4. Jika n = 7, nilai MSB adalah 3; Berfungsi untuk mencari bit - bijak & semua nombor dari x ke y. ; $ res = 0; Memulakan hasil; Cari kedudukan MSB dalam X dan Y; Jika kedudukan tidak sama, kembali; Tambah 2 ^ MSB_P1 untuk menghasilkan; Kurangkan 2 ^ msb_p1 dari x dan y. ; Kod pemacu", "code": "< ? php function msbPos ( $ n ) { $ msb_p = -1 ; while ( $ n > 0 ) { $ n = $ n >> 1 ; $ msb_p ++ ; } return $ msb_p ; } function andOperator ( $ x , $ y ) { while ( $ x > 0 && $ y > 0 ) { $ msb_p1 = msbPos ( $ x ) ; $ msb_p2 = msbPos ( $ y ) ; if ( $ msb_p1 != $ msb_p2 ) break ; $ msb_val = ( 1 << $ msb_p1 ) ; $ res = $ res + $ msb_val ; $ x = $ x - $ msb_val ; $ y = $ y - $ msb_val ; } return $ res ; } $ x = 10 ; $ y = 15 ; echo andOperator ( $ x , $ y ) ; ? >"}
{"text": "Masukkan nombor dengan 10 tanpa menggunakan pengendali pendaraban | Berfungsi untuk mencari pendaraban n dengan 10 tanpa menggunakan pengendali pendaraban; Kod pemacu", "code": "< ? php function multiplyTen ( $ n ) { return ( $ n << 1 ) + ( $ n << 3 ) ; } $ n = 50 ; echo multiplyTen ( $ n ) ; ? >"}
{"text": "SUMPLE SUM DAN XOR | fungsi untuk mengira bilangan nilai kurang daripada sama dengan n yang memenuhi syarat yang diberikan; Melintasi semua nombor dari 0 hingga N dan hasil kenaikan hanya apabila keadaan diberikan berpuas hati. ; Kod pemacu", "code": "< ? php function countValues ( $ n ) { $ countV = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( ( $ n + $ i ) == ( $ n ^ $ i ) ) $ countV ++ ; return $ countV ; } $ n = 12 ; echo countValues ( $ n ) ; ? >"}
{"text": "SUMPLE SUM DAN XOR | fungsi untuk mengira bilangan nilai kurang daripada sama dengan n yang memenuhi syarat yang diberikan; UNSET_BITS Menjejaki kiraan bit set - set dalam perwakilan binari n; Kembali 2 ^ unset_bits; Kod pemacu", "code": "< ? php function countValues ( $ n ) { $ unset_bits = 0 ; while ( $ n ) { if ( ( $ n & 1 ) == 0 ) $ unset_bits ++ ; $ n = $ n >> 1 ; } return 1 << $ unset_bits ; } $ n = 12 ; echo countValues ( $ n ) ; ? >"}
{"text": "Cari Profesion dalam Keluarga Khas | Mengembalikan 'E' jika profesion nod pada tahap dan kedudukan tertentu adalah jurutera. Lain doktor. Fungsi ini menganggap bahawa kedudukan dan tahap yang diberikan mempunyai nilai yang sah. ; Kes asas; Recursif mencari profesion ibu bapa. Jika ibu bapa adalah doktor, nod ini akan menjadi doktor jika berada di kedudukan ganjil dan seorang jurutera jika berada di kedudukan yang sama; Jika ibu bapa adalah jurutera, maka nod semasa akan menjadi jurutera jika pada kedudukan ganjil dan doktor jika kedudukannya. ; Kod pemacu", "code": "< ? php function findProffesion ( $ level , $ pos ) { if ( $ level == 1 ) return ' e ' ; if ( findProffesion ( $ level - 1 , ( $ pos + 1 ) / 2 ) == ' d ' ) return ( $ pos % 2 ) ? ' d ' : ' e ' ; return ( $ pos % 2 ) ? ' e ' : ' d ' ; } $ level = 4 ; $ pos = 2 ; if ( ( findProffesion ( $ level , $ pos ) == ' e ' ) == true ) echo \" Engineer \" ; else echo \" Doctor \" ; ? >"}
{"text": "Cetak nombor n pertama dengan tepat dua set bit | Mencetak nombor n pertama dengan dua set bit; Memulakan lebih tinggi daripada dua set bit; Terus mengurangkan N untuk setiap nombor dengan dua set bit. ; Pertimbangkan semua bit set yang lebih rendah untuk bit set yang lebih tinggi semasa; Cetak nombor semasa; Jika kita telah menemui nombor n; Pertimbangkan bit seterusnya seterusnya untuk bit yang lebih tinggi semasa. ; Kenaikan bit set yang lebih tinggi; Kod pemacu", "code": "< ? php function printTwoSetBitNums ( $ n ) { $ x = 1 ; while ( $ n > 0 ) { $ y = 0 ; while ( $ y < $ x ) { echo ( 1 << $ x ) + ( 1 << $ y ) , \" ▁ \" ; $ n -- ; if ( $ n == 0 ) return ; $ y ++ ; } $ x ++ ; } } printTwoSetBitNums ( 4 ) ; ? >"}
{"text": "Menjana 0 dan 1 dengan kebarangkalian 25 % dan 75 % | Fungsi rawak untuk pulangan 0 atau 1 dengan kebarangkalian yang sama; Fungsi rand () akan menjana ganjil atau bilangan yang sama dengan kebarangkalian yang sama. Jika Rand () menjana nombor ganjil, fungsi akan kembali 1, ia akan kembali 0 .; Fungsi rawak untuk pulangan 1 dengan kebarangkalian 75 % dan 0 dengan kebarangkalian 25 % menggunakan bitwise atau; Kod pemacu memulakan penjana nombor rawak; Kod ini disumbangkan m_kit", "code": "< ? php function rand50 ( ) { return rand ( ) & 1 ; } function rand75 ( ) { return rand50 ( ) | rand50 ( ) ; } srand ( time ( NULL ) ) ; for ( $ i = 0 ; $ i < 50 ; $ i ++ ) echo rand75 ( ) ; ? >"}
{"text": "Cari walaupun unsur -unsur yang berlaku dalam pelbagai jenis terhad | Berfungsi untuk mencari unsur -unsur yang berlaku dalam pelbagai yang diberikan; lakukan untuk setiap elemen array; kiri - shift 1 dengan nilai elemen semasa; Togol bit setiap kali elemen akan diulang; Arus melintasi sekali lagi dan gunakan _xor untuk mencari unsur -unsur yang berlaku; kiri - shift 1 dengan nilai elemen semasa; Setiap 0 dalam _xor mewakili kejadian yang sama; Cetak nombor yang berlaku walaupun; Tetapkan bit sebagai 1 untuk mengelakkan pencetakan pendua; Kod pemacu", "code": "< ? php function printRepeatingEven ( $ arr , $ n ) { $ _xor = 0 ; $ pos ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ pos = 1 << $ arr [ $ i ] ; $ _xor ^= $ pos ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ pos = 1 << $ arr [ $ i ] ; if ( ! ( $ pos & $ _xor ) ) { echo $ arr [ $ i ] , \" \" ; $ _xor ^= $ pos ; } } } $ arr = array ( 9 , 12 , 23 , 10 , 12 , 12 , 15 , 23 , 14 , 12 , 15 ) ; $ n = sizeof ( $ arr ) ; printRepeatingEven ( $ arr , $ n ) ; ? >"}
{"text": "Semak jika nombor adalah suram | Fungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari lulus no binari. ; Pulangan benar jika n adalah suram; Semak semua nombor 'x' lebih kecil daripada n. Jika x + countsetBits (x) menjadi n, maka n tidak boleh menjadi suram; Kod pemacu", "code": "< ? php function countSetBits ( $ x ) { $ count = 0 ; while ( $ x ) { $ x &= ( $ x - 1 ) ; $ count ++ ; } return $ count ; } function isBleak ( $ n ) { for ( $ x = 1 ; $ x < $ n ; $ x ++ ) if ( $ x + countSetBits ( $ x ) == $ n ) return false ; return true ; } if ( isBleak ( 3 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; if ( isBleak ( 4 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Cari subset maksimum xor set yang diberikan | Bilangan bit untuk mewakili int; Berfungsi untuk mengembalikan subset XOR maksimum dalam set []; Memulakan indeks elemen yang dipilih; Melintasi semua bit integer bermula dari bit yang paling penting (MSB); Memulakan indeks elemen maksimum dan elemen maksimum; Jika saya 'set bit [j] ditetapkan dan ditetapkan [j] lebih besar daripada max setakat ini. ; Sekiranya tidak ada elemen dengan set bit saya, pindah ke lebih kecil i; Letakkan elemen maksimum dengan i 'th u' set »indeks 'indeks'; Mengemas kini indeks maxind dan kenaikan; Lakukan xor set [maxIndex] dengan semua nombor yang mempunyai bit saya sebagai set. ; XOR set [maxind] nombor -nombor yang mempunyai set bit i 'th; Indeks kenaikan elemen yang dipilih; Hasil akhir adalah XOR dari semua elemen; Kod pemacu", "code": "< ? php $ INT_BITS = 32 ; function maxSubarrayXOR ( & $ set , $ n ) { global $ INT_BITS ; $ index = 0 ; for ( $ i = $ INT_BITS - 1 ; $ i >= 0 ; $ i -- ) { $ maxInd = $ index ; $ maxEle = 0 ; for ( $ j = $ index ; $ j < $ n ; $ j ++ ) { if ( ( $ set [ $ j ] & ( 1 << $ i ) ) != 0 && $ set [ $ j ] > $ maxEle ) { $ maxEle = $ set [ $ j ] ; $ maxInd = $ j ; } } if ( $ maxEle == 0 ) continue ; $ t = $ set [ $ index ] ; $ set [ $ index ] = $ set [ $ maxInd ] ; $ set [ $ maxInd ] = $ t ; $ maxInd = $ index ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ j != $ maxInd && ( $ set [ $ j ] & ( 1 << $ i ) ) != 0 ) $ set [ $ j ] = $ set [ $ j ] ^ $ set [ $ maxInd ] ; } $ index ++ ; } $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res ^= $ set [ $ i ] ; return $ res ; } $ set = array ( 9 , 8 , 5 ) ; $ n = sizeof ( $ set ) ; echo \" Max ▁ subset ▁ XOR ▁ is ▁ \" ; echo maxSubarrayXOR ( $ set , $ n ) ; ? >"}
{"text": "Memandangkan satu set, cari Xor dari semua subset. | Mengembalikan xor semua subset yang diberikan XOR; XOR adalah 1 hanya apabila n ialah 1, lain 0; Kod pemacu", "code": "< ? php function findXOR ( $ Set , $ n ) { if ( $ n == 1 ) return $ Set [ 0 ] ; else return 0 ; } $ Set = array ( 1 , 2 , 3 ) ; $ n = count ( $ Set ) ; echo \" XOR ▁ of ▁ XOR ' s ▁ of ▁ all ▁ subsets ▁ is ▁ \" , findXOR ( $ Set , $ n ) ; ? >"}
{"text": "Cari XOR dua nombor tanpa menggunakan Operator XOR | Mengembalikan Xor X dan Y; Kod pemacu", "code": "< ? php function myXOR ( $ x , $ y ) { return ( $ x $ y ) & ( ~ $ x ~ $ y ) ; } $ x = 3 ; $ y = 5 ; echo \" XOR ▁ is ▁ \" , myXOR ( $ x , $ y ) ; ? >"}
{"text": "Algoritma Freivald untuk memeriksa sama ada matriks adalah produk dua | Kod PHP untuk melaksanakan algoritma FreivalDatms; Fungsi untuk memeriksa sama ada abx = cx; Menjana vektor rawak; Sekarang comput b * r untuk menilai ungkapan a * (b * r) - (c * r); Sekarang comput c * r untuk menilai ungkapan a * (b * r) - (c * r); Sekarang comput a * (b * r) untuk menilai ungkapan a * (b * r) - (c * r); Akhirnya periksa sama ada nilai ungkapan a * (b * r) - (c * r) adalah 0 atau tidak; Menjalankan Kreald Freivald. Nilai k menentukan ketepatan. Nilai yang lebih tinggi bermakna ketepatan yang lebih tinggi. ; Kod pemacu", "code": "< ? php $ N = 2 ; function freivald ( $ a , $ b , $ c ) { global $ N ; $ r = array ( ) ; $ br = array ( ) ; $ cr = array ( ) ; $ axbr = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ r [ $ i ] = mt_rand ( ) % 2 ; $ br [ $ i ] = 0 ; $ cr [ $ i ] = 0 ; $ axbr [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ br [ $ i ] = $ br [ $ i ] + $ b [ $ i ] [ $ j ] * $ r [ $ j ] ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ cr [ $ i ] = $ cr [ $ i ] + $ c [ $ i ] [ $ j ] * $ r [ $ j ] ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ axbr [ $ i ] = $ axbr [ $ i ] + $ a [ $ i ] [ $ j ] * $ br [ $ j ] ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ axbr [ $ i ] - $ cr [ $ i ] != 0 ) return false ; return true ; } function isProduct ( $ a , $ b , $ c , $ k ) { for ( $ i = 0 ; $ i < $ k ; $ i ++ ) if ( freivald ( $ a , $ b , $ c ) == false ) return false ; return true ; } $ a = array ( array ( 1 , 1 ) , array ( 1 , 1 ) ) ; $ b = array ( array ( 1 , 1 ) , array ( 1 , 1 ) ) ; $ c = array ( array ( 2 , 2 ) , array ( 2 , 2 ) ) ; $ k = 2 ; if ( isProduct ( $ a , $ b , $ c , $ k ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Jangkaan atau nilai jangkaan array | Fungsi untuk mengira jangkaan; PRB berubah adalah untuk kebarangkalian setiap elemen yang sama untuk setiap elemen; mengira jangkaan secara keseluruhan; Mengembalikan jangkaan sebagai jumlah; Kod pemacu; Fungsi untuk mengira jangkaan; Paparkan jangkaan array yang diberikan", "code": "< ? php function calc_Expectation ( $ a , $ n ) { $ prb = ( 1 / $ n ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] * $ prb ; return $ sum ; } $ n = 6.0 ; $ a = array ( 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 ) ; $ expect = calc_Expectation ( $ a , $ n ) ; echo \" Expectation ▁ of ▁ array ▁ E ( X ) ▁ is ▁ : ▁ \" . $ expect . \" STRNEWLINE \" ; ? >"}
{"text": "Pilih mata dari dua julat supaya tidak ada titik terletak di kedua -dua julat | Fungsi untuk mencari titik yang diperlukan; Kod pemacu", "code": "< ? php function findPoints ( $ l1 , $ r1 , $ l2 , $ r2 ) { $ x = ( $ l1 != $ l2 ) ? min ( $ l1 , $ l2 ) : -1 ; $ y = ( $ r1 != $ r2 ) ? max ( $ r1 , $ r2 ) : -1 ; echo $ x , \" \" , $ y ; } $ l1 = 5 ; $ r1 = 10 ; $ l2 = 1 ; $ r2 = 7 ; findPoints ( $ l1 , $ r1 , $ l2 , $ r2 ) ; ? >"}
{"text": "Rekursi Tail | Fungsi bukan ekor - ekor. Fungsi ini bukan rekursif ekor kerana nilai yang dikembalikan oleh fakta (n - 1) digunakan sebenarnya (n) dan panggilan kepada fakta (n - 1) bukanlah perkara terakhir yang dilakukan oleh fakta (n); Kod pemacu", "code": "< ? php function fact ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * fact ( $ n - 1 ) ; } echo fact ( 5 ) ; ? >"}
{"text": "Cetak nombor dalam urutan menurun bersama dengan frekuensi mereka | Berfungsi untuk mencetak unsur -unsur dalam turun bersama dengan frekuensi mereka; Menyusun elemen dalam penurunan urutan; melintasi unsur -unsur array; Mencetak nombor dan kiraan; Mencetak langkah terakhir; Kod pemacu", "code": "< ? php function printElements ( & $ a , $ n ) { rsort ( $ a ) ; $ cnt = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ a [ $ i ] != $ a [ $ i + 1 ] ) { echo ( $ a [ $ i ] ) ; echo ( \" ▁ occurs ▁ \" ) ; echo $ cnt ; echo ( \" ▁ times STRNEWLINE \" ) ; $ cnt = 1 ; } else $ cnt += 1 ; } echo ( $ a [ $ n - 1 ] ) ; echo ( \" ▁ occurs ▁ \" ) ; echo $ cnt ; echo ( \" ▁ times STRNEWLINE \" ) ; } $ a = array ( 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 ) ; $ n = sizeof ( $ a ) ; printElements ( $ a , $ n ) ; ? >"}
{"text": "Cari kedudukan elemen dalam urutan monotonik yang diberikan | Pelaksanaan PHP pendekatan dari log2 import matematik, lantai; Berfungsi untuk mengembalikan nilai f (n) untuk nilai yang diberikan dari A, B, C, N; Jika c adalah 0, maka nilai n boleh dalam urutan 10 ^ 15. Jika c! = 0, maka nilai n ^ 3 harus dalam urutan 10 ^ 18 sehingga nilai maksimum n dapat 10 ^ 6; Untuk mencari yang cekap, gunakan carian binari. ; Kod pemacu", "code": "< ? php $ SMALL_N = 1000000 ; $ LARGE_N = 1000000000000000 ; function func ( $ a , $ b , $ c , $ n ) { $ res = $ a * $ n ; $ logVlaue = floor ( log ( $ n , 2 ) ) ; $ res += $ b * $ n * $ logVlaue ; $ res += $ c * ( $ n * $ n * $ n ) ; return $ res ; } function getPositionInSeries ( $ a , $ b , $ c , $ k ) { global $ SMALL_N , $ LARGE_N ; $ start = 1 ; $ end = $ SMALL_N ; if ( $ c == 0 ) $ end = $ LARGE_N ; $ ans = 0 ; while ( $ start <= $ end ) { $ mid = ( int ) ( ( $ start + $ end ) / 2 ) ; $ val = func ( $ a , $ b , $ c , $ mid ) ; if ( $ val == $ k ) { $ ans = $ mid ; break ; } else if ( $ val > $ k ) $ end = $ mid - 1 ; else $ start = $ mid + 1 ; } return $ ans ; } $ a = 2 ; $ b = 1 ; $ c = 1 ; $ k = 12168587437017 ; print ( getPositionInSeries ( $ a , $ b , $ c , $ k ) ) ; ? >"}
{"text": "Semak sama ada (i, j) wujud sedemikian rupa sehingga arr [i]! = Arr [j] dan arr [arr [i]] sama dengan arr [ar [j]] | Fungsi yang akan memberitahu sama ada indeks tersebut hadir atau tidak. ; Memeriksa keadaan 1 ST i. e sama ada arr [i] sama dengan arr [j] atau tidak; Memeriksa keadaan 2 nd i. e sama ada arr [arr [i]] sama dengan arr [arr [j]] atau tidak. ; Kod pemacu; Fungsi panggilan.", "code": "< ? php function checkIndices ( $ Arr , $ N ) { for ( $ i = 0 ; $ i < $ N - 1 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( $ Arr [ $ i ] != $ Arr [ $ j ] ) { if ( $ Arr [ $ Arr [ $ i ] - 1 ] == $ Arr [ $ Arr [ $ j ] - 1 ] ) return true ; } } } return false ; } $ Arr = array ( 3 , 2 , 1 , 1 , 4 ) ; $ N = sizeof ( $ Arr ) ; if ( checkIndices ( $ Arr , $ N ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cetak semua pasangan dengan jumlah yang diberikan | Mengembalikan bilangan pasangan dalam arr [0. n - 1] dengan jumlah yang sama dengan 'jumlah'; Memulakan hasil; Pertimbangkan semua pasangan yang mungkin dan periksa jumlah mereka; Kod pemacu", "code": "< ? php function printPairs ( $ arr , $ n , $ sum ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] == $ sum ) echo \" ( \" , $ arr [ $ i ] , \" , ▁ \" , $ arr [ $ j ] , \" ) \" , \" STRNEWLINE \" ; } $ arr = array ( 1 , 5 , 7 , -1 , 5 ) ; $ n = sizeof ( $ arr ) ; $ sum = 6 ; printPairs ( $ arr , $ n , $ sum ) ; ? >"}
{"text": "Membuat unsur -unsur yang berbeza dalam array yang disusun dengan kenaikan minimum | Untuk mencari jumlah minimum elemen unik. ; Walaupun elemen semasa adalah sama seperti sebelumnya atau telah menjadi lebih kecil daripada sebelumnya. ; Kod pemacu", "code": "< ? php function minSum ( $ arr , $ n ) { $ sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) { $ j = $ i ; while ( $ j < $ n && $ arr [ $ j ] <= $ arr [ $ j - 1 ] ) { $ arr [ $ j ] = $ arr [ $ j ] + 1 ; $ j ++ ; } } $ sum = $ sum + $ arr [ $ i ] ; } return $ sum ; } $ arr = array ( 2 , 2 , 3 , 5 , 6 ) ; $ n = sizeof ( $ arr ) ; echo minSum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Membuat unsur -unsur yang berbeza dalam array yang disusun dengan kenaikan minimum | Untuk mencari jumlah minimum elemen unik. ; Jika pelanggaran berlaku, buat nilai semasa sebagai 1 ditambah nilai sebelumnya dan tambah kepada jumlah. ; Tiada pelanggaran. ; Kod pemacu", "code": "< ? php function minSum ( $ arr , $ n ) { $ sum = $ arr [ 0 ] ; $ prev = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] <= $ prev ) { $ prev = $ prev + 1 ; $ sum = $ sum + $ prev ; } else { $ sum = $ sum + $ arr [ $ i ] ; $ prev = $ arr [ $ i ] ; } } return $ sum ; } $ arr = array ( 2 , 2 , 3 , 5 , 6 ) ; $ n = count ( $ arr ) ; echo minSum ( $ arr , $ n ) ; ? >"}
{"text": "Produk Pandigital | Untuk memeriksa rentetan yang terbentuk dari multiplicand, pengganda dan produk adalah pandigital; Kirakan multiplicand, pengganda, dan produk yang layak untuk pandigital; Kod pemacu", "code": "< ? php function isPandigital ( $ str ) { if ( strlen ( $ str ) != 9 ) return false ; $ x = str_split ( $ str ) ; sort ( $ x ) ; $ x = implode ( $ x ) ; return strcmp ( $ x , \"123456789\" ) ; } function PandigitalProduct_1_9 ( $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 && isPandigital ( strval ( $ n ) . strval ( $ i ) . strval ( ( int ) ( $ n / $ i ) ) ) ) return true ; return false ; } $ n = 6050 ; if ( PandigitalProduct_1_9 ( $ n ) ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text": "Median dan Mod Menggunakan Pengiraan Sort | Fungsi yang jenis input array a [] dan hitung mod dan median menggunakan jenis pengiraan. ; Arahan output B [] akan menyusun array; pembolehubah untuk menyimpan maksimum array input yang akan mempunyai saiz array kiraan; Auxiliary (Count) Array untuk menyimpan kiraan. Inisialisasi Array Count sebagai 0. Saiz Array Count akan sama dengan (Max + 1). ; Kiraan simpan setiap elemen array input; mod adalah indeks dengan kiraan maksimum; Kemas kini kiraan [] array dengan jumlah; Arahan output yang disusun b [] untuk mengira median; Median mengikut saiz ganjil dan juga saiz array. ; Output hasilnya; Kod pemacu", "code": "< ? php function printModeMedian ( $ a , $ n ) { $ b [ $ n ] = array ( ) ; $ max = max ( $ a ) ; $ t = $ max + 1 ; $ count [ $ t ] = array ( ) ; for ( $ i = 0 ; $ i < $ t ; $ i ++ ) $ count [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ $ a [ $ i ] ] ++ ; $ mode = 0 ; $ k = $ count [ 0 ] ; for ( $ i = 1 ; $ i < $ t ; $ i ++ ) { if ( $ count [ $ i ] > $ k ) { $ k = $ count [ $ i ] ; $ mode = $ i ; } } for ( $ i = 1 ; $ i < $ t ; $ i ++ ) $ count [ $ i ] = $ count [ $ i ] + $ count [ $ i - 1 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ b [ $ count [ $ a [ $ i ] ] - 1 ] = $ a [ $ i ] ; $ count [ $ a [ $ i ] ] -- ; } $ median ; if ( $ n % 2 != 0 ) $ median = $ b [ $ n / 2 ] ; else $ median = ( $ b [ ( $ n - 1 ) / 2 ] + $ b [ ( $ n / 2 ) ] ) / 2.0 ; echo \" median = \" , ▁ $ median , ▁ \" \" ▁ ; STRNEWLINE TABSYMBOL echo ▁ \" mode = \" } $ a = array ( 1 , 4 , 1 , 2 , 7 , 1 , 2 , 5 , 3 , 6 ) ; $ n = sizeof ( $ a ) ; printModeMedian ( $ a , $ n ) ; ? >"}
{"text": "Semak jika kedua -dua bahagian rentetan mempunyai sekurang -kurangnya satu watak yang berbeza | Pelaksanaan PHP untuk memeriksa sama ada kedua -dua bahagian rentetan mempunyai sekurang -kurangnya satu watak yang berbeza; Fungsi yang memecahkan rentetan ke dalam dua bahagian mengira kekerapan aksara dalam setiap separuh membandingkan dua array kaunter dan mengembalikan benar jika tatasusunan kaunter ini berbeza; Pengisytiharan dan permulaan array kaunter; Fungsi pemacu", "code": "< ? php $ MAX = 26 ; function function_1 ( $ str ) { global $ MAX ; $ l = strlen ( $ str ) ; $ counter1 = array_fill ( 0 , $ MAX , NULL ) ; $ counter2 = array_fill ( 0 , $ MAX , NULL ) ; for ( $ i = 0 ; $ i < $ l / 2 ; $ i ++ ) $ counter1 [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = $ l / 2 ; $ i < $ l ; $ i ++ ) $ counter2 [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) if ( $ counter2 [ $ i ] != $ counter1 [ $ i ] ) return true ; return false ; } $ str = \" abcasdsabcae \" ; if ( function_1 ( $ str ) ) echo \" Yes , ▁ both ▁ halves ▁ differ \" . \" ▁ by ▁ at ▁ least ▁ one ▁ character \" ; else echo \" No , ▁ both ▁ halves ▁ do ▁ \" . \" not ▁ differ ▁ at ▁ all \" ; return 0 ; ? >"}
{"text": "Perbezaan minimum antara max dan min semua k | Mengembalikan perbezaan min antara max dan min dari mana -mana subset saiz K; Susun array supaya unsur -unsur dekat bersatu. ; memulakan hasil dengan nombor integer besar; gelung ke atas unsur -unsur pertama (n - k) hanya; Dapatkan perbezaan antara max dan min segmen bersaiz K - semasa; Kod pemacu", "code": "< ? php function minDifferenceAmongMaxMin ( $ arr , $ N , $ K ) { $ INT_MAX = 2 ; sort ( $ arr ) ; sort ( $ arr , $ N ) ; $ res = $ INT_MAX ; for ( $ i = 0 ; $ i <= ( $ N - $ K ) ; $ i ++ ) { $ curSeqDiff = $ arr [ $ i + $ K - 1 ] - $ arr [ $ i ] ; $ res = min ( $ res , $ curSeqDiff ) ; } return $ res ; } $ arr = array ( 10 , 20 , 30 , 100 , 101 , 102 ) ; $ N = sizeof ( $ arr ) ; $ K = 3 ; echo minDifferenceAmongMaxMin ( $ arr , $ N , $ K ) ; ? >"}
{"text": "Kedudukan elemen selepas jenis stabil | Kaedah Mengembalikan kedudukan ARR [IDX] selepas melakukan stabil - menyusun pada array; Kiraan elemen yang lebih kecil daripada elemen semasa ditambah dengan elemen yang sama yang berlaku sebelum indeks yang diberikan; Jika elemen lebih kecil maka tingkatkan kiraan yang lebih kecil; Jika elemen adalah sama maka tambah kiraan hanya jika ia berlaku sebelum ini; Kod pemacu", "code": "< ? php function getIndexInSortedArray ( $ arr , $ n , $ idx ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ arr [ $ idx ] ) $ result ++ ; if ( $ arr [ $ i ] == $ arr [ $ idx ] and $ i < $ idx ) $ result ++ ; } return $ result ; } $ arr = array ( 3 , 4 , 3 , 5 , 2 , 3 , 4 , 3 , 1 , 5 ) ; $ n = count ( $ arr ) ; $ idxOfEle = 5 ; echo getIndexInSortedArray ( $ arr , $ n , $ idxOfEle ) ; ? >"}
{"text": "Cari nilai maksimum yang mungkin [i] % a [j] ke atas semua pasang i dan j | Fungsi yang mengembalikan elemen kedua terbesar dalam array jika ada, lain 0; Harus ada sekurang -kurangnya dua elemen; Untuk menyimpan maksimum dan elemen maksimum kedua dari array; Jika elemen semasa lebih besar daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Tiada maksimum kedua yang dijumpai; Kod pemacu", "code": "< ? php function getMaxValue ( $ arr , $ arr_size ) { if ( $ arr_size < 2 ) { return 0 ; } $ first = $ second = - ( PHP_INT_MAX - 1 ) ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { if ( $ arr [ $ i ] > $ first ) { $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ second && $ arr [ $ i ] != $ first ) $ second = $ arr [ $ i ] ; } if ( $ second == - ( PHP_INT_MAX - 1 ) ) return 0 ; else return $ second ; } $ arr = array ( 4 , 5 , 1 , 8 ) ; $ n = count ( $ arr ) ; echo getMaxValue ( $ arr , $ n ) ; ? >"}
{"text": "Memaksimumkan nilai ungkapan yang diberikan | Berfungsi untuk mengembalikan hasil maksimum; Untuk menyimpan kiraan bilangan bulat negatif; Jumlah ketiga -tiga bilangan bulat; Produk dari ketiga -tiga bilangan bulat; Untuk menyimpan yang terkecil dan yang terbesar di antara ketiga -tiga bilangan bulat; Hitung kiraan bilangan bulat negatif; Bergantung kepada kiraan negatif; Apabila ketiga -tiga adalah bilangan bulat positif; Untuk integer negatif tunggal; Untuk dua bilangan bulat negatif; Untuk tiga bilangan bulat negatif; Kod pemacu", "code": "< ? php function maximumResult ( $ a , $ b , $ c ) { $ countOfNegative = 0 ; $ sum = $ a + $ b + $ c ; $ product = $ a * $ b * $ c ; $ largest = max ( $ a , $ b , $ c ) ; $ smallest = min ( $ a , $ b , $ c ) ; if ( $ a < 0 ) $ countOfNegative ++ ; if ( $ b < 0 ) $ countOfNegative ++ ; if ( $ c < 0 ) $ countOfNegative ++ ; switch ( $ countOfNegative ) { case 0 : return ( $ sum - $ largest ) * $ largest ; case 1 : return ( $ product / $ smallest ) + $ smallest ; case 2 : return ( $ product / $ largest ) + $ largest ; case 3 : return ( $ sum - $ smallest ) * $ smallest ; } } $ a = -2 ; $ b = -1 ; $ c = -4 ; echo maximumResult ( $ a , $ b , $ c ) ; ? >"}
{"text": "Pelajar maksimum untuk lulus selepas memberikan bonus kepada semua orang dan tidak melebihi 100 markah | Berfungsi untuk mengembalikan bilangan pelajar yang boleh lulus; markah maksimum; tanda bonus maksimum yang boleh diberikan; Mengira bilangan pelajar yang boleh lulus; Kod pemacu", "code": "< ? php function check ( $ n , $ marks ) { $ x = max ( $ marks ) ; $ bonus = 100 - $ x ; $ c = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ marks [ $ i ] + $ bonus >= 50 ) $ c += 1 ; } return $ c ; } $ n = 5 ; $ marks = array ( 0 , 21 , 83 , 45 , 64 ) ; echo check ( $ n , $ marks ) ;"}
{"text": "Jumlah nombor semulajadi n pertama yang bukan kuasa k | Berfungsi untuk mengembalikan jumlah nombor semulajadi n pertama yang bukan kuasa positif k; jumlah nombor semulajadi n pertama; tolak semua kuasa positif k yang kurang daripada n; Kuasa seterusnya K; Kod pemacu", "code": "< ? php function find_sum ( $ n , $ k ) { $ total_sum = ( $ n * ( $ n + 1 ) ) / 2 ; $ power = $ k ; while ( $ power <= $ n ) { $ total_sum -= $ power ; $ power *= $ k ; } return $ total_sum ; } $ n = 11 ; $ k = 2 ; echo find_sum ( $ n , $ k ) ; ? >"}
{"text": "Bilangan minimum operasi yang diperlukan untuk memadam semua elemen array | berfungsi untuk mencari operasi minimum; Susun array; Sediakan hash array; Kod pemacu", "code": "< ? php function minOperations ( & $ arr , $ n ) { $ hashTable = array ( ) ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ hashTable [ $ arr [ $ i ] ] ++ ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ hashTable [ $ arr [ $ i ] ] ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ j ] % $ arr [ $ i ] == 0 ) $ hashTable [ $ arr [ $ j ] ] = 0 ; $ res ++ ; } } return $ res ; } $ arr = array ( 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ) ; $ n = sizeof ( $ arr ) ; echo minOperations ( $ arr , $ n ) ; ? >"}
{"text": "Sorting array dengan terbalik sekitar tengah | Program PHP untuk mencari kemungkinan untuk disusun dengan pelbagai subarray reverse operarion; membuat salinan array asal; menyusun array yang disalin; Memeriksa imej cermin unsur -unsur salinan salinan yang disusun dan elemen setara dengan array asal; Kod pemacu", "code": "< ? php function ifPossible ( & $ arr , $ n ) { $ cp = array ( ) ; $ cp = $ arr ; sort ( $ cp ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ! ( $ arr [ $ i ] == $ cp [ $ i ] ) && ! ( $ arr [ $ n - 1 - $ i ] == $ cp [ $ i ] ) ) return false ; } return true ; } $ arr = array ( 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 ) ; $ n = sizeof ( $ arr ) ; if ( ifPossible ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Kos minimum untuk mencapai akhir array array apabila lompatan maksimum indeks k dibenarkan | Berfungsi untuk mengembalikan kos minimum untuk mencapai indeks terakhir; Jika kita mencapai indeks terakhir; Sudah melawat negeri; Pada mulanya maksimum; Lawati semua indeks yang boleh dicapai; Jika di dalam julat; Kita tidak boleh bergerak lebih jauh; Memoize; Kod pemacu", "code": "< ? php function FindMinimumCost ( $ ind , $ a , $ n , $ k , $ dp ) { if ( $ ind == ( $ n - 1 ) ) return 0 ; else if ( $ dp [ $ ind ] != -1 ) return $ dp [ $ ind ] ; else { $ ans = PHP_INT_MAX ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( $ ind + $ i < $ n ) $ ans = min ( $ ans , abs ( $ a [ $ ind + $ i ] - $ a [ $ ind ] ) + FindMinimumCost ( $ ind + $ i , $ a , $ n , $ k , $ dp ) ) ; else break ; } return $ dp [ $ ind ] = $ ans ; } } $ a = array ( 10 , 30 , 40 , 50 , 20 ) ; $ k = 3 ; $ n = sizeof ( $ a ) ; $ dp = array ( ) ; $ dp = array_fill ( 0 , $ n , -1 ) ; echo ( FindMinimumCost ( 0 , $ a , $ n , $ k , $ dp ) ) ; ? >"}
{"text": "Jumlah semua faktor nombor dalam julat [l, r] | Pelaksanaan PHP pendekatan; Berfungsi untuk mengira jumlah awalan semua faktor walaupun; Tambah saya kepada semua gandaan i; Mengemas kini jumlah awalan; Berfungsi untuk mengembalikan jumlah semua faktor walaupun nombor dalam julat yang diberikan; Kod pemacu", "code": "< ? php $ MAX = 10000 ; $ prefix = array_fill ( 0 , $ MAX , 0 ) ; function sieve_modified ( ) { global $ MAX , $ prefix ; for ( $ i = 2 ; $ i < $ MAX ; $ i += 2 ) { for ( $ j = $ i ; $ j < $ MAX ; $ j += $ i ) $ prefix [ $ j ] += $ i ; } for ( $ i = 1 ; $ i < $ MAX ; $ i ++ ) $ prefix [ $ i ] += $ prefix [ $ i - 1 ] ; } function sumEvenFactors ( $ L , $ R ) { global $ MAX , $ prefix ; return ( $ prefix [ $ R ] - $ prefix [ $ L - 1 ] ) ; } sieve_modified ( ) ; $ l = 6 ; $ r = 10 ; echo sumEvenFactors ( $ l , $ r ) ; ? >"}
{"text": "Ekspresi seimbang seperti yang diberikan kedudukan telah membuka kurungan | Tetapkan 2 | Berfungsi untuk mencari bilangan ekspresi kurungan yang betul; Jika terbuka - kurungan tertutup <0; Jika indeks mencapai akhir ekspresi; Jika kurungan seimbang; Jika sudah disimpan dalam DP; Jika indeks semasa telah memberikan pendakap terbuka; Bergerak ke hadapan meningkatkan panjang kurungan terbuka; Bergerak ke hadapan dengan memasukkan kurungan terbuka dan tertutup pada indeks itu; kembalikan jawapannya; Array DP untuk precompute jawapannya; Kurungan terbuka pada kedudukan 1; Memanggil fungsi mencari untuk mengira jawapannya", "code": "< ? php function find ( $ index , $ openbrk , $ n , & $ dp , & $ adj ) { if ( $ openbrk < 0 ) return 0 ; if ( $ index == $ n ) { if ( $ openbrk == 0 ) return 1 ; else return 0 ; } if ( $ dp [ $ index ] [ $ openbrk ] != -1 ) return $ dp [ $ index ] [ $ openbrk ] ; if ( $ adj [ $ index ] == 1 ) { $ dp [ $ index ] [ $ openbrk ] = find ( $ index + 1 , $ openbrk + 1 , $ n , $ dp , $ adj ) ; } else { $ dp [ $ index ] [ $ openbrk ] = find ( $ index + 1 , $ openbrk + 1 , $ n , $ dp , $ adj ) + find ( $ index + 1 , $ openbrk - 1 , $ n , $ dp , $ adj ) ; } return $ dp [ $ index ] [ $ openbrk ] ; } $ N = 1000 ; $ dp = array ( array ( ) ) ; $ n = 2 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ dp [ $ i ] [ $ j ] = -1 ; } } $ adj = array ( 1 , 0 , 0 , 0 ) ; echo find ( 0 , 0 , 2 * $ n , $ dp , $ adj ) . \" STRNEWLINE \" ; ? >"}
{"text": "Memaksimumkan Elemen Array sehingga Nombor Diberikan | Fungsi utiliti untuk mencari nilai maksimum yang mungkin; Jika keseluruhan array dilalui, maka bandingkan nilai semasa dalam NUM hingga keseluruhan maksimum yang diperoleh setakat ini. ; Kes 1: Kurangkan elemen semasa dari nilai setakat ini jika hasilnya lebih besar daripada atau sama dengan sifar. ; Kes 2: Tambah elemen semasa ke nilai setakat ini jika hasilnya kurang daripada atau sama dengan maxlimit. ; Fungsi untuk mencari nilai maksimum yang boleh diperolehi menggunakan elemen array dan nombor yang diberikan. ; Pembolehubah untuk menyimpan nilai maksimum yang boleh diperolehi. ; Pembolehubah untuk menyimpan kedudukan indeks semasa. ; Panggilan ke fungsi utiliti untuk mencari nilai maksimum yang boleh diperolehi. ; Kod pemacu", "code": "< ? php function findMaxValUtil ( $ arr , $ n , $ num , $ maxLimit , $ ind , & $ ans ) { if ( $ ind == $ n ) { $ ans = max ( $ ans , $ num ) ; return ; } if ( $ num - $ arr [ $ ind ] >= 0 ) { findMaxValUtil ( $ arr , $ n , $ num - $ arr [ $ ind ] , $ maxLimit , $ ind + 1 , $ ans ) ; } if ( $ num + $ arr [ $ ind ] <= $ maxLimit ) { findMaxValUtil ( $ arr , $ n , $ num + $ arr [ $ ind ] , $ maxLimit , $ ind + 1 , $ ans ) ; } } function findMaxVal ( $ arr , $ n , $ num , $ maxLimit ) { $ ans = 0 ; $ ind = 0 ; findMaxValUtil ( $ arr , $ n , $ num , $ maxLimit , $ ind , $ ans ) ; return $ ans ; } $ num = 1 ; $ arr = array ( 3 , 10 , 6 , 4 , 5 ) ; $ n = count ( $ arr ) ; $ maxLimit = 15 ; echo ( findMaxVal ( $ arr , $ n , $ num , $ maxLimit ) ) ; ? >"}
{"text": "Cetak set jumlah array yang sama (masalah partition) | Tetapkan 1 | Fungsi untuk mencetak set jumlah yang sama dari array. ; Cetak set 1 .; Cetak set 2 .; Fungsi utiliti untuk mencari set array yang mempunyai jumlah yang sama. ; Jika keseluruhan array dilalui, bandingkan kedua -dua jumlah itu. ; Sekiranya jumlahnya adalah cetak yang sama kedua -dua set dan kembali benar untuk menunjukkan set ditemui. ; Jika jumlah tidak sama maka set pulangan tidak dijumpai. ; Tambah elemen semasa untuk menetapkan 1 .; Panggilan rekursif selepas menambahkan elemen semasa untuk menetapkan 1 .; Jika kemasukan ini menghasilkan jumlah yang sama set partition maka kembali benar untuk menunjukkan set yang dikehendaki dijumpai. ; Jika tidak kemudian mundur dengan mengeluarkan elemen semasa dari SET1 dan masukkannya dalam set 2; Panggilan rekursif selepas termasuk elemen semasa untuk menetapkan 2 .; Kembali benar jika array arr boleh dibahagikan kepada dua set jumlah yang sama atau tidak. ; Kirakan jumlah elemen dalam array. ; Jika jumlahnya ganjil maka array tidak boleh dibahagikan. ; Mengisytiharkan vektor untuk menyimpan kedua -dua set. ; Cari kedua -dua set. ; Kod pemacu", "code": "< ? php function printSets ( $ set1 , $ set2 ) { $ i = 0 ; for ( $ i = 0 ; $ i < count ( $ set1 ) ; $ i ++ ) { echo ( $ set1 [ $ i ] . \" \" ) ; } echo ( \" STRNEWLINE \" ) ; for ( $ i = 0 ; $ i < count ( $ set2 ) ; $ i ++ ) { echo ( $ set2 [ $ i ] . \" \" ) ; } } function findSets ( $ arr , $ n , & $ set1 , & $ set2 , $ sum1 , $ sum2 , $ pos ) { if ( $ pos == $ n ) { if ( $ sum1 == $ sum2 ) { printSets ( $ set1 , $ set2 ) ; return true ; } else return false ; } array_push ( $ set1 , $ arr [ $ pos ] ) ; $ res = findSets ( $ arr , $ n , $ set1 , $ set2 , $ sum1 + $ arr [ $ pos ] , $ sum2 , $ pos + 1 ) ; if ( $ res ) return $ res ; array_pop ( $ set1 ) ; array_push ( $ set2 , $ arr [ $ pos ] ) ; return findSets ( $ arr , $ n , $ set1 , $ set2 , $ sum1 , $ sum2 + $ arr [ $ pos ] , $ pos + 1 ) ; } function isPartitionPoss ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; if ( $ sum % 2 != 0 ) return false ; $ set1 = array ( ) ; $ set2 = array ( ) ; return findSets ( $ arr , $ n , $ set1 , $ set2 , 0 , 0 , 0 ) ; } $ arr = array ( 5 , 5 , 1 , 11 ) ; $ n = count ( $ arr ) ; if ( isPartitionPoss ( $ arr , $ n ) == false ) echo ( \" - 1\" ) ; ? >"}
{"text": "Maksimum subarray dalam O (n) Menggunakan Awalan Sum | Fungsi untuk mengira jumlah subarray maksimum dalam masa linear. ; Inisialisasi jumlah awalan minimum hingga 0 .; Inisialisasi jumlah subarray maksimum setakat ini - Infinity. ; Inisialisasi dan hitung array Jumlah awalan. ; Gelung melalui array, menjejaki jumlah awalan minimum setakat ini dan jumlah subarray maksimum. ; Kes ujian 1; Kes ujian 2", "code": "< ? php function maximumSumSubarray ( $ arr , $ n ) { $ min_prefix_sum = 0 ; $ res = PHP_INT_MIN ; $ prefix_sum = array ( ) ; $ prefix_sum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ prefix_sum [ $ i ] = $ prefix_sum [ $ i - 1 ] + $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ res = max ( $ res , $ prefix_sum [ $ i ] - $ min_prefix_sum ) ; $ min_prefix_sum = min ( $ min_prefix_sum , $ prefix_sum [ $ i ] ) ; } return $ res ; } $ arr1 = array ( -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 ) ; $ n1 = count ( $ arr1 ) ; echo maximumSumSubarray ( $ arr1 , $ n1 ) , \" \" ; $ arr2 = array ( 4 , -8 , 9 , -4 , 1 , -8 , -1 , 6 ) ; $ n2 = count ( $ arr2 ) ; echo maximumSumSubarray ( $ arr2 , $ n2 ) ; ? >"}
{"text": "Mengira nombor N digit yang monoton | Program PHP untuk mengira nombor N digit yang monoton. ; Memandangkan semua digit yang mungkin sebagai {1, 2, 3 ,. .9}; Dp [i] [j] akan menyimpan nombor monoton panjang i + 1 memandangkan J + 1 digit. ; Nombor panjang unit; Nombor digit tunggal; Mengisi selebihnya penyertaan dengan cara bawah. ; Kod pemacu", "code": "< ? php function getNumMonotone ( $ len ) { $ DP_s = 9 ; $ DP = array ( array_fill ( 0 , $ len , 0 ) , array_fill ( 0 , $ len , 0 ) ) ; for ( $ i = 0 ; $ i < $ DP_s ; ++ $ i ) $ DP [ 0 ] [ $ i ] = $ i + 1 ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) $ DP [ $ i ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ len ; ++ $ i ) for ( $ j = 1 ; $ j < $ DP_s ; ++ $ j ) $ DP [ $ i ] [ $ j ] = $ DP [ $ i - 1 ] [ $ j ] + $ DP [ $ i ] [ $ j - 1 ] ; return $ DP [ $ len - 1 ] [ $ DP_s - 1 ] ; } echo getNumMonotone ( 10 ) ; ? >"}
{"text": "Newman | Berfungsi untuk mencari elemen n - th; Mengisytiharkan array untuk menyimpan urutan; Kod pemacu", "code": "< ? php function sequence ( $ n ) { $ i ; $ f [ 0 ] = 0 ; $ f [ 1 ] = 1 ; $ f [ 2 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ f [ $ i ] = $ f [ $ f [ $ i - 1 ] ] + $ f [ $ i - $ f [ $ i - 1 ] ] ; return $ f [ $ n ] ; } $ n = 10 ; echo ( sequence ( $ n ) ) ; ? >"}
{"text": "Produk maksimum peningkatan berikutnya | Mengembalikan produk produk maksimum yang semakin meningkat. ; Memulakan nilai MPI; Mengira nilai MPI yang dioptimumkan memandangkan setiap elemen sebagai elemen urutan urutan; Pilih maksimum semua nilai produk; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function lis ( & $ arr , $ n ) { $ mpis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mpis [ $ i ] = $ arr [ $ i ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ mpis [ $ i ] < ( $ mpis [ $ j ] * $ arr [ $ i ] ) ) $ mpis [ $ i ] = $ mpis [ $ j ] * $ arr [ $ i ] ; return max ( $ mpis ) ; } $ arr = array ( 3 , 100 , 4 , 5 , 150 , 6 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo lis ( $ arr , $ n ) ; return 0 ; ? >"}
{"text": "Segitiga Hosoya | Program PHP untuk mencetak segitiga ketinggian Hosoya n. ; Kes asas; Langkah rekursif; Cetak segitiga Hosoya ketinggian n. ; Kod yang didorong", "code": "< ? php function Hosoya ( int $ n , int $ m ) { if ( ( $ n == 0 && $ m == 0 ) || ( $ n == 1 && $ m == 0 ) || ( $ n == 1 && $ m == 1 ) || ( $ n == 2 && $ m == 1 ) ) return 1 ; if ( $ n > $ m ) return Hosoya ( $ n - 1 , $ m ) + Hosoya ( $ n - 2 , $ m ) ; else if ( $ m == $ n ) return Hosoya ( $ n - 1 , $ m - 1 ) + Hosoya ( $ n - 2 , $ m - 2 ) ; else return 0 ; } function printHosoya ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) echo Hosoya ( $ i , $ j ) , \" ▁ \" ; echo \" STRNEWLINE \" ; } } $ n = 5 ; printHosoya ( $ n ) ; ? >"}
{"text": "Nombor Eulerian | Kembali eulerianNumber a (n, m); Kod yang didorong", "code": "< ? php function eulerian ( $ n , $ m ) { if ( $ m >= $ n $ n == 0 ) return 0 ; if ( $ m == 0 ) return 1 ; return ( $ n - $ m ) * eulerian ( $ n - 1 , $ m - 1 ) + ( $ m + 1 ) * eulerian ( $ n - 1 , $ m ) ; } $ n = 3 ; $ m = 1 ; echo eulerian ( $ n , $ m ) ; ? >"}
{"text": "Subset Pasangan Terbesar Terbesar | berfungsi untuk mencari berikutnya terpanjang; DP [i] akan menyimpan saiz subset terbesar yang boleh dibahagikan dengan [i]. ; Oleh kerana elemen terakhir adalah terbesar, d [n - 1] adalah 1; Isi nilai untuk elemen yang lebih kecil. ; Cari semua gandaan [i] dan pertimbangkan pelbagai yang mempunyai subset terbesar bermula dengannya. ; Mengembalikan nilai maksimum dari DP []; Kod pemacu", "code": "< ? php function largestSubset ( $ a , $ n ) { $ dp = array ( ) ; $ dp [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ mxm = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ j ] % $ a [ $ i ] == 0 or $ a [ $ i ] % $ a [ $ j ] == 0 ) $ mxm = max ( $ mxm , $ dp [ $ j ] ) ; $ dp [ $ i ] = 1 + $ mxm ; } return max ( $ dp ) ; } $ a = array ( 1 , 3 , 6 , 13 , 17 , 18 ) ; $ n = count ( $ a ) ; echo largestSubset ( $ a , $ n ) ; ? >"}
{"text": "Masalah Pasangan Kawan | Mengembalikan kiraan cara n orang boleh kekal bujang atau dipasangkan. ; Mengisi DP [] dengan cara bawah menggunakan formula rekursif yang dijelaskan di atas. ; Kod pemacu", "code": "< ? php function countFriendsPairings ( $ n ) { $ dp [ $ n + 1 ] = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { if ( $ i <= 2 ) $ dp [ $ i ] = $ i ; else $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; } return $ dp [ $ n ] ; } $ n = 4 ; echo countFriendsPairings ( $ n ) ; ? >"}
{"text": "Masalah Pasangan Kawan | Mengembalikan kiraan cara n orang boleh kekal bujang atau dipasangkan. ; Kod pemacu", "code": "< ? php function countFriendsPairings ( $ n ) { $ a = 1 ; $ b = 2 ; $ c = 0 ; if ( $ n <= 2 ) { return $ n ; } for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ c = $ b + ( $ i - 1 ) * $ a ; $ a = $ b ; $ b = $ c ; } return $ c ; } $ n = 4 ; print ( countFriendsPairings ( $ n ) ) ; ? >"}
{"text": "LCS (selaras biasa terpanjang) dari tiga rentetan | Mengembalikan panjang LCS untuk x [0 .. m - 1], y [0 .. n - 1] dan z [0 .. o - 1]; Langkah -langkah berikut membina l [m + 1] [n + 1] [o + 1] dalam fesyen bawah. Perhatikan bahawa l [i] [j] [k] mengandungi panjang LCs x [0 .. i - 1] dan y [0. .. J - 1] dan Z [0 .. ... k - 1]; L [m] [n] [o] mengandungi panjang LCS untuk x [0. .. n - 1] dan y [0 .. M - 1] dan Z [0 .. o - 1]; Kod pemacu", "code": "< ? php function lcsOf3 ( $ X , $ Y , $ Z , $ m , $ n , $ o ) { $ L [ $ m + 1 ] [ $ n + 1 ] [ $ o + 1 ] = array ( array ( array ( ) ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { for ( $ k = 0 ; $ k <= $ o ; $ k ++ ) { if ( $ i == 0 $ j == 0 $ k == 0 ) $ L [ $ i ] [ $ j ] [ $ k ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] && $ X [ $ i - 1 ] == $ Z [ $ k - 1 ] ) $ L [ $ i ] [ $ j ] [ $ k ] = $ L [ $ i - 1 ] [ $ j - 1 ] [ $ k - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] [ $ k ] = max ( max ( $ L [ $ i - 1 ] [ $ j ] [ $ k ] , $ L [ $ i ] [ $ j - 1 ] [ $ k ] ) , $ L [ $ i ] [ $ j ] [ $ k - 1 ] ) ; } } } return $ L [ $ m ] [ $ n ] [ $ o ] ; } $ X = \" AGGT12\" ; $ Y = \"12TXAYB \" ; $ Z = \"12XBA \" ; $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ o = strlen ( $ Z ) ; echo \" Length ▁ of ▁ LCS ▁ is ▁ \" . lcsOf3 ( $ X , $ Y , $ Z , $ m , $ n , $ o ) ; ? >"}
{"text": "Susunan berulang terpanjang | Fungsi ini terutamanya mengembalikan LCS (STR, STR) dengan syarat bahawa aksara yang sama pada indeks yang sama tidak dipertimbangkan. ; Buat dan memulakan jadual DP; Mengisi jadual DP (serupa dengan gelung LCS); Jika watak sepadan dan indeks tidak sama; Sekiranya watak tidak sepadan; Kod pemacu", "code": "< ? php function findLongestRepeatingSubSeq ( $ str ) { $ n = strlen ( $ str ) ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ str [ $ i - 1 ] == $ str [ $ j - 1 ] && $ i != $ j ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } } return $ dp [ $ n ] [ $ n ] ; } $ str = \" aabb \" ; echo \" The ▁ length ▁ of ▁ the ▁ largest ▁ \" . \" subsequence ▁ that ▁ repeats ▁ itself ▁ is ▁ : ▁ \" , findLongestRepeatingSubSeq ( $ str ) ; ? >"}
{"text": "Kira semua jalan yang mungkin dari kiri ke bawah kanan kanan matriks MXN | Mengembalikan kiraan laluan yang mungkin untuk mencapai sel pada nombor baris m dan nombor lajur n dari sel paling kiri (sel pada 1, 1); Buat array 1D untuk menyimpan hasil subproblem; Kod pemacu", "code": "< ? php function numberOfPaths ( $ m , $ n ) { $ dp = array ( ) ; $ dp [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { $ dp [ $ j ] += $ dp [ $ j - 1 ] ; } } return $ dp [ $ n - 1 ] ; } echo numberOfPaths ( 3 , 3 ) ; ? >"}
{"text": "Cari istilah n Siri 1, 4, 15, 72, 420. . | Fungsi untuk mencari faktorial n dengan rekursi; keadaan asas; gunakan rekursi; mengira istilah siri nth; Kod pemacu", "code": "< ? php function factorial ( $ N ) { if ( $ N == 0 or $ N == 1 ) return 1 ; return $ N * factorial ( $ N - 1 ) ; } function nthTerm ( $ N ) { return ( factorial ( $ N ) * ( $ N + 2 ) / 2 ) ; } $ N = 6 ; echo nthTerm ( $ N ) ; ? >"}
{"text": "Watak yang kekerapannya sama dengan jumlah frekuensi aksara lain dari rentetan yang diberikan | Fungsi yang mengembalikan benar jika ada watak yang wujud dalam rentetan yang diberikan kekerapannya sama dengan frekuensi jumlah aksara lain dari rentetan; Jika rentetan panjang ganjil; Untuk menyimpan kekerapan setiap watak rentetan; Mengemas kini frekuensi watak -watak; Tidak ada watak seperti itu; Kod pemacu", "code": "< ? php function isFrequencyEqual ( $ str , $ len ) { if ( $ len % 2 == 1 ) return false ; $ freq = array ( ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ freq [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ freq [ ord ( $ str [ $ i ] ) - 97 ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( $ freq [ $ i ] == $ len / 2 ) return true ; return false ; } $ str = \" geeksforgeeks \" ; $ len = strlen ( $ str ) ; if ( isFrequencyEqual ( $ str , $ len ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Penggantian minimum untuk membuat aksara bersebelahan tidak sama rata dalam rentetan ternary | Berfungsi untuk mengira bilangan penggantian minimum; Cari panjang rentetan; Iterat dalam rentetan; Semak jika bersebelahan adalah sama; Jika bukan pasangan terakhir; Semak watak yang tidak sama dalam i + 1 dan i - 1; lain pasangan terakhir; Semak watak yang tidak sama dalam indeks i - 1; Kod pemacu", "code": "< ? php function countMinimalReplacements ( $ s ) { $ n = strlen ( $ s ) ; $ cnt = 0 ; $ str = \"012\" ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { $ cnt += 1 ; if ( $ i != ( $ n - 1 ) ) { for ( $ it = 0 ; $ it < strlen ( $ str ) ; $ it ++ ) { if ( $ str [ $ it ] != $ s [ $ i + 1 ] && $ str [ $ it ] != $ s [ $ i - 1 ] ) { $ s [ $ i ] = $ str [ $ it ] ; break ; } } } { for ( $ it = 0 ; $ it < strlen ( $ str ) ; $ it ++ ) { if ( $ str [ $ it ] != $ s [ $ i - 1 ] ) { $ s [ $ i ] = $ str [ $ it ] ; break ; } } } } } return $ cnt ; } $ s = \"201220211\" ; echo countMinimalReplacements ( $ s ) ; ? >"}
{"text": "Sub | Fungsi yang mengembalikan indeks kejadian seterusnya watak C dalam string str bermula dari permulaan indeks; Bermula dari permulaan; Jika aksara semasa = c; Tidak dijumpai; Berfungsi untuk mengembalikan kiraan sub -rentetan yang diperlukan; Kedai yang menjalankan kiraan 'X' bermula dari akhir; Indeks seterusnya 'X' bermula dari Indeks 0; Indeks seterusnya 'Y' bermula dari Indeks 0; Untuk menyimpan kiraan sub -rentetan yang diperlukan; Jika 'y' muncul sebelum 'x' ia tidak akan menyumbang kepada sub-string yang sah; Cari kejadian seterusnya 'Y'; Jika 'y' muncul selepas 'x' setiap sub -rentetan yang berakhir pada 'x' yang muncul selepas 'y' ini dan bermula dengan 'x' semasa adalah sub -rentetan yang sah; Cari kejadian seterusnya 'X'; Mengembalikan kiraan; Kod pemacu", "code": "< ? php function nextIndex ( $ str , $ start , $ c ) { for ( $ i = $ start ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == $ c ) return $ i ; } return -1 ; } function countSubStrings ( $ str ) { $ n = strlen ( $ str ) ; $ countX = array ( 0 , $ n , NULL ) ; $ count = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] == ' x ' ) $ count ++ ; $ countX [ $ i ] = $ count ; } $ nextIndexX = nextIndex ( $ str , 0 , ' x ' ) ; $ nextIndexY = nextIndex ( $ str , 0 , ' y ' ) ; $ count = 0 ; while ( $ nextIndexX != -1 && $ nextIndexY != -1 ) { if ( $ nextIndexX > $ nextIndexY ) { $ nextIndexY = nextIndex ( $ str , $ nextIndexY + 1 , ' y ' ) ; continue ; } else { $ count += $ countX [ $ nextIndexY ] ; $ nextIndexX = nextIndex ( $ str , $ nextIndexX + 1 , ' x ' ) ; } } return $ count ; } $ s = \" xyyxx \" ; echo countSubStrings ( $ s ) ; ? >"}
{"text": "Penggantian watak selepas mengeluarkan pendua dari rentetan | Berfungsi untuk meminimumkan rentetan; watak pendua dikeluarkan; Cek jika watak sebelum ini berlaku atau tidak jika tidak kemudian menambahnya ke rentetan 'MSTR' yang diminimumkan; kembali $ mstr; rentetan yang diminimumkan; Fungsi utiliti untuk mencetak rentetan yang diminimumkan, diganti; Mewujudkan rentetan akhir dengan menggantikan watak; pengiraan indeks; echo \"Final» String: ». $ finalstr; rentetan akhir; Kod pemacu", "code": "< ? php function minimize ( $ str ) { $ mstr = \" ▁ \" ; $ flagchar = array_fill ( 0 , 26 , 0 ) ; $ l = strlen ( $ str ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ ch = $ str [ $ i ] ; if ( $ flagchar [ ord ( $ ch ) - 97 ] == 0 ) { $ mstr . = $ ch ; $ flagchar [ ord ( $ ch ) - 97 ] = 1 ; } } } function replaceMinimizeUtil ( $ str ) { $ finalStr = \" \" ; $ l = strlen ( $ str ) ; for ( $ i = 0 ; $ i < strlen ( $ minimizedStr ) ; $ i ++ ) { $ ch = $ minimizedStr [ $ i ] ; $ index = ( ord ( $ ch ) * ord ( $ ch ) ) % $ l ; $ finalStr = $ finalStr . $ str [ $ index ] ; } } $ str = \" geeks \" ; replaceMinimizeUtil ( $ str ) ; ? >"}
{"text": "Cipher Alphabet Latin | fungsi untuk mengira penyulitan; Kod pemacu", "code": "< ? php function cipher ( $ str ) { if ( ! ctype_alpha ( $ str ) ) { printf ( \" Enter ▁ only ▁ \" + \" alphabets ▁ and ▁ space STRNEWLINE \" ) ; return ; } printf ( \" Encrypted ▁ Code ▁ using ▁ \" ) ; printf ( \" Latin ▁ Alphabet STRNEWLINE \" ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) echo ( ord ( $ str [ $ i ] ) - 65 + 1 ) . \" ▁ \" ; else if ( $ str [ $ i ] >= ' a ' && $ str [ $ i ] <= ' z ' ) echo ( ord ( $ str [ $ i ] ) - 97 + 1 ) . \" ▁ \" ; } echo \" STRNEWLINE \" ; } $ str = \" geeksforgeeks \" ; cipher ( $ str ) ; ? >"}
{"text": "Pusingan nombor yang diberikan kepada pelbagai terdekat 10 | berfungsi untuk mengelilingi nombor; Lebih kecil; Lebih besar; Pulangan paling dekat dengan dua; Kod pemacu", "code": "< ? php function roundFunation ( $ n ) { $ a = ( int ) ( $ n / 10 ) * 10 ; $ b = ( $ a + 10 ) ; return ( $ n - $ a > $ b - $ n ) ? $ b : $ a ; } $ n = 4722 ; echo roundFunation ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Bilangan berikutnya sebagai \"ab\" dalam rentetan kimas kaum k | Kod PHP untuk mencari bilangan berikutnya \"ab\" dalam rentetan s yang diulang kali k. ; Count 'a' s; Kiraan 'b' s; kejadian \"ab\" s dalam rentetan s; Tambah berikut dua: 1) k * (kejadian \"ab\" dalam rentetan tunggal) 2) A adalah dari satu rentetan dan b adalah dari yang lain. ; Kod pemacu", "code": "< ? php function countOccurrences ( $ s , $ K ) { $ n = strlen ( $ s ) ; $ C = 0 ; $ c1 = 0 ; $ c2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' ) $ c1 ++ ; if ( $ s [ $ i ] == ' b ' ) { $ c2 ++ ; $ C = $ C + $ c1 ; } } return $ C * $ K + ( $ K * ( $ K - 1 ) / 2 ) * $ c1 * $ c2 ; } $ S = \" abcb \" ; $ k = 2 ; echo countOccurrences ( $ S , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text": "String dengan Kara Kekedut K dan tiada watak yang sama bersebelahan | Fungsi untuk mencari rentetan panjang n dengan aksara k yang berbeza. ; Memulakan hasil dengan huruf latin pertama; Isi baki surat n - k dengan mengulangi huruf k lagi dan lagi. ; Kod pemacu", "code": "< ? php function findString ( $ n , $ k ) { $ res = \" \" ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ res = $ res . chr ( ord ( ' a ' ) + $ i ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n - $ k ; $ i ++ ) { $ res = $ res . chr ( ord ( ' a ' ) + $ count ) ; $ count ++ ; if ( $ count == $ k ) $ count = 0 ; } return $ res ; } $ n = 5 ; $ k = 2 ; echo findString ( $ n , $ k ) ; ? >"}
{"text": "Program untuk mengira vokal dalam rentetan (berulang dan rekursif) | Fungsi untuk memeriksa vokal; untuk mengira jumlah vokal dari 0 hingga n; objek rentetan; Jumlah bilangan vokal", "code": "< ? php function isVowel ( $ ch ) { $ ch = strtoupper ( $ ch ) ; return ( $ ch == ' A ' $ ch == ' E ' $ ch == ' I ' $ ch == ' O ' $ ch == ' U ' ) ; } function countVovels ( $ str , $ n ) { if ( $ n == 1 ) return isVowel ( $ str [ $ n - 1 ] ) ; return countVovels ( $ str , $ n - 1 ) + isVowel ( $ str [ $ n - 1 ] ) ; } $ str = \" abc ▁ de \" ; echo countVovels ( $ str , strlen ( $ str ) ) . \" \" ; ? >"}
{"text": "Menjana semua putaran rentetan yang diberikan | Cetak semua rentetan yang diputar. ; Concatenate str dengan dirinya sendiri; Cetak semua substring saiz n. Perhatikan bahawa saiz temp adalah 2 n; Kod pemacu", "code": "< ? php function printRotatedString ( $ str ) { $ n = strlen ( $ str ) ; $ temp = $ str . $ str ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j != $ n ; $ j ++ ) print ( $ temp [ $ i + $ j ] ) ; print ( \" STRNEWLINE \" ) ; } } $ str = \" geeks \" ; printRotatedString ( $ str ) ; ? >"}
{"text": "Semak jika kekerapan semua aksara boleh menjadi sama dengan satu penyingkiran | Program PHP untuk mendapatkan rentetan aksara frekuensi yang sama dengan mengeluarkan paling banyak satu char; Kaedah utiliti untuk mendapatkan indeks watak CH dalam aksara abjad yang lebih rendah; Pulangan benar jika semua nilai elemen bukan sifar adalah sama; Dapatkan elemen bukan sifar pertama; Semak kesamaan setiap elemen dengan pembolehubah yang sama; Pulangan benar jika kita boleh membuat semua frekuensi watak sama; mengisi frekuensi frekuensi; Jika semua frekuensi adalah sama, maka kembali benar; Cuba penurunan kekerapan semua watak dengan satu dan kemudian periksa semua kesamaan semua frekuensi bukan sifar; Semak watak hanya jika ia berlaku dalam STR; Kod pemacu", "code": "< ? php $ M = 26 ; function getIdx ( $ ch ) { return ( $ ch - ' a ' ) ; } function allSame ( & $ freq , $ N ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ freq [ $ i ] > 0 ) { $ same = $ freq [ $ i ] ; break ; } } for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) if ( $ freq [ $ j ] > 0 && $ freq [ $ j ] != $ same ) return false ; return true ; } function possibleSameCharFreqByOneRemoval ( $ str ) { global $ M ; $ l = strlen ( $ str ) ; $ freq = array_fill ( 0 , $ M , NULL ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ freq [ getIdx ( $ str [ $ i ] ) ] ++ ; if ( allSame ( $ freq , $ M ) ) return true ; for ( $ c = ' a ' ; $ c <= ' z ' ; $ c ++ ) { $ i = getIdx ( $ c ) ; if ( $ freq [ $ i ] > 0 ) { $ freq [ $ i ] -- ; if ( allSame ( $ freq , $ M ) ) return true ; $ freq [ $ i ] ++ ; } } return false ; } $ str = \" xyyzz \" ; if ( possibleSameCharFreqByOneRemoval ( $ str ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Semak jika sebilangan besar boleh dibahagikan dengan 11 atau tidak | Berfungsi untuk mencari nombor yang boleh dibahagikan dengan 11 atau tidak; Mengira jumlah wang angka yang lebih baik dan ganjil; Apabila saya berada, kedudukan digit adalah ganjil; Periksa perbezaannya boleh dibahagikan dengan 11 atau tidak; Kod pemacu", "code": "< ? php function check ( $ str ) { $ n = strlen ( $ str ) ; $ oddDigSum = 0 ; $ evenDigSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ oddDigSum += ( $ str [ $ i ] - '0' ) ; else $ evenDigSum += ( $ str [ $ i ] - '0' ) ; } return ( ( $ oddDigSum - $ evenDigSum ) % 11 == 0 ) ; } $ str = \"76945\" ; $ x = check ( $ str ) ? \" Yes \" : \" No ▁ \" ; echo ( $ x ) ; ? >"}
{"text": "Hamming jarak antara dua rentetan | fungsi untuk mengira jarak Hamming; Kod pemacu; panggilan fungsi", "code": "< ? php function hammingDist ( $ str1 , $ str2 ) { $ i = 0 ; $ count = 0 ; while ( isset ( $ str1 [ $ i ] ) != ' ' ) { if ( $ str1 [ $ i ] != $ str2 [ $ i ] ) $ count ++ ; $ i ++ ; } return $ count ; } $ str1 = \" geekspractice \" ; $ str2 = \" nerdspractise \" ; echo hammingDist ( $ str1 , $ str2 ) ; ? >"}
{"text": "Semak jika dua rentetan adalah k | Program PHP untuk memeriksa sama ada dua rentetan adalah k anagram atau tidak. ; Berfungsi untuk memeriksa rentetan itu adalah k - anagram atau tidak; Jika kedua -dua rentetan tidak sama panjang maka kembali palsu; Simpan kejadian semua aksara dalam hash_array; Mengira bilangan aksara yang berbeza dalam kedua -dua rentetan; Kembali benar jika kiraan kurang daripada atau sama dengan k; Kod pemacu", "code": "< ? php $ MAX_CHAR = 26 ; function arekAnagrams ( $ str1 , $ str2 , $ k ) { global $ MAX_CHAR ; $ n = strlen ( $ str1 ) ; if ( strlen ( $ str2 ) != $ n ) return false ; $ count1 = ( 0 ) ; $ count2 = ( 0 ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) if ( $ count1 [ $ i ] > $ count2 [ $ i ] ) $ count = $ count + abs ( $ count1 [ $ i ] - $ count2 [ $ i ] ) ; return ( $ count <= $ k ) ; } $ str1 = \" anagram \" ; $ str2 = \" grammar \" ; $ k = 2 ; if ( arekAnagrams ( $ str1 , $ str2 , $ k ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Memandangkan rentetan binari, bilangan substrings yang bermula dan berakhir dengan 1. | Program PHP yang mudah untuk mengira bilangan substrings bermula dan berakhir dengan 1; Pilih titik permulaan; Mengembalikan kiraan pasangan yang mungkin di antara M 1; Kod pemacu", "code": "< ? php function countSubStr ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) { $ m ++ ; } } return $ m * ( $ m - 1 ) / 2 ; } $ str = \"00100101\" ; echo countSubStr ( $ str ) ; ? >"}
{"text": "Memandangkan nombor sebagai rentetan, cari bilangan berikutnya yang bersebelahan yang secara rekursif menambah sehingga 9 | Program PHP untuk mengira substrings dengan jumlah rekursif sama dengan 9; Untuk menyimpan hasil; Pertimbangkan setiap watak sebagai permulaan substring; jumlah digit dalam substring semasa; Satu demi satu memilih setiap watak sebagai watak yang berakhir; Tambah digit semasa ke jumlah, jika jumlah menjadi berbilang daripada 5 maka kiraan kenaikan. Marilah kita melakukan aritmetik modular untuk mengelakkan limpahan untuk rentetan besar; Kod pemacu", "code": "< ? php function count9s ( $ number ) { $ count = 0 ; $ n = strlen ( $ number ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ number [ $ i ] - '0' ; if ( $ number [ $ i ] == '9' ) $ count ++ ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ sum = ( $ sum + $ number [ $ j ] - '0' ) % 9 ; if ( $ sum == 0 ) $ count ++ ; } } return $ count ; } echo count9s ( \" 4189 \" ) , \" STRNEWLINE \" ; echo count9s ( \" 1809 \" ) ; ? >"}
{"text": "Kumpulkan semua syiling dalam bilangan langkah minimum | Kaedah rekursif untuk mengumpul duit syiling dari array ketinggian L ke r, dengan ketinggian H sudah dikumpulkan; Jika L lebih daripada R, tiada langkah yang diperlukan; Gelung di atas ketinggian untuk mendapatkan indeks ketinggian minimum; Pilih minimum dari, 1) mengumpul duit syiling menggunakan semua garis menegak (jumlah R - l) 2) mengumpul duit syiling menggunakan garis mendatar yang lebih rendah dan rekursif di segmen kiri dan kanan; kaedah mengembalikan bilangan langkah minimum untuk mengumpul duit syiling dari timbunan, dengan ketinggian ketinggian [] array; Kod pemacu", "code": "< ? php function minStepsRecur ( $ height , $ l , $ r , $ h ) { if ( $ l >= $ r ) return 0 ; $ m = $ l ; for ( $ i = $ l ; $ i < $ r ; $ i ++ ) if ( $ height [ $ i ] < $ height [ $ m ] ) $ m = $ i ; return min ( $ r - $ l , minStepsRecur ( $ height , $ l , $ m , $ height [ $ m ] ) + minStepsRecur ( $ height , $ m + 1 , $ r , $ height [ $ m ] ) + $ height [ $ m ] - $ h ) ; } function minSteps ( $ height , $ N ) { return minStepsRecur ( $ height , 0 , $ N , 0 ) ; } $ height = array ( 2 , 1 , 2 , 5 , 1 ) ; $ N = sizeof ( $ height ) ; echo minSteps ( $ height , $ N ) ; ? >"}
{"text": "Segitiga Reuleaux Terbesar Dalam Dataran | Berfungsi untuk mencari kawasan segitiga Reuleaux; Sisi tidak boleh negatif; Kawasan segitiga Reuleaux; Kod pemacu", "code": "< ? php function ReuleauxArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ A = 0.70477 * pow ( $ a , 2 ) ; return $ A ; } $ a = 6 ; echo ReuleauxArea ( $ a ) . \" STRNEWLINE \" ; ? >"}
{"text": "Hexagon terbesar yang boleh ditulis dalam persegi | Berfungsi untuk mengembalikan sisi segi enam; Sisi tidak boleh negatif; Sisi segi enam; Kod pemacu", "code": "< ? php function hexagonside ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.5176 * $ a ; return $ x ; } $ a = 6 ; echo hexagonside ( $ a ) ; ? >"}
{"text": "Hexagon terbesar yang boleh ditulis dalam segitiga sama rata | Fungsi untuk mencari sisi segi enam; Sisi tidak boleh negatif; Sisi segi enam; Kod pemacu", "code": "< ? php function hexagonside ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = $ a / 3 ; return $ x ; } $ a = 6 ; echo hexagonside ( $ a ) ; ? >"}
{"text": "Cari segmen titik tengah dari panjang segmen yang diberikan | Fungsi yang mengembalikan segmen untuk titik tengah; titik tengah; menyimpan indeks segmen; jumlah kenaikan dengan panjang segmen; Jika pertengahan berada di antara dua segmen; Jika jumlah lebih besar daripada titik tengah; Kod pemacu", "code": "< ? php function findSegment ( $ n , $ m , $ segment_length ) { $ meet_point = ( 1.0 * $ n ) / 2.0 ; $ sum = 0 ; $ segment_number = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ sum += $ segment_length [ $ i ] ; if ( ( double ) $ sum == $ meet_point ) { $ segment_number = -1 ; break ; } if ( $ sum > $ meet_point ) { $ segment_number = $ i + 1 ; break ; } } return $ segment_number ; } $ n = 13 ; $ m = 3 ; $ segment_length = array ( 3 , 2 , 8 ) ; $ ans = findSegment ( $ n , $ m , $ segment_length ) ; echo ( $ ans ) ; ? >"}
{"text": "Titik maksimum persimpangan n baris | nc2 = (n) * (n - 1) / 2; ; n adalah bilangan baris", "code": "< ? php function countMaxIntersect ( $ n ) { return ( $ n ) * ( $ n - 1 ) / 2 ; } $ n = 8 ; echo countMaxIntersect ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari kelantangan dan permukaan kawasan prisma pentagonal | fungsi untuk kawasan permukaan; fungsi untuk kelantangan; Kod pemacu", "code": "< ? php function surfaceArea ( $ a , $ b , $ h ) { return 5 * $ a * $ b + 5 * $ b * $ h ; } function volume ( $ b , $ h ) { return ( 5 * $ b * $ h ) / 2 ; } $ a = 5 ; $ b = 3 ; $ h = 7 ; echo \" surface ▁ area ▁ = ▁ \" , surfaceArea ( $ a , $ b , $ h ) , \" , ▁ \" ; echo \" volume = \" ? >"}
{"text": "Semak sama ada titik di dalam, di luar atau di Parabola | Berfungsi untuk memeriksa titik; memeriksa persamaan parabola dengan titik yang diberikan; Kod pemacu", "code": "< ? php function checkpoint ( $ h , $ k , $ x , $ y , $ a ) { $ p = pow ( ( $ y - $ k ) , 2 ) - 4 * $ a * ( $ x - $ h ) ; return $ p ; } $ h = 0 ; $ k = 0 ; $ x = 2 ; $ y = 1 ; $ a = 4 ; if ( checkpoint ( $ h , $ k , $ x , $ y , $ a ) > 0 ) echo \" Outside \" ; else if ( checkpoint ( $ h , $ k , $ x , $ y , $ a ) == 0 ) echo \" On ▁ the ▁ parabola \" ; else echo \" Inside \" ; ? >"}
{"text": "Semak sama ada titik di dalam, di luar atau di Ellipse | Berfungsi untuk memeriksa titik; memeriksa persamaan elips dengan titik yang diberikan; Kod pemacu", "code": "< ? php function checkpoint ( $ h , $ k , $ x , $ y , $ a , $ b ) { $ p = ( pow ( ( $ x - $ h ) , 2 ) / pow ( $ a , 2 ) ) + ( pow ( ( $ y - $ k ) , 2 ) / pow ( $ b , 2 ) ) ; return $ p ; } $ h = 0 ; $ k = 0 ; $ x = 2 ; $ y = 1 ; $ a = 4 ; $ b = 5 ; if ( checkpoint ( $ h , $ k , $ x , $ y , $ a , $ b ) > 1 ) echo ( \" Outside \" ) ; else if ( checkpoint ( $ h , $ k , $ x , $ y , $ a , $ b ) == 1 ) echo ( \" On ▁ the ▁ ellipse \" ) ; else echo ( \" Inside \" ) ; ? >"}
{"text": "Kawasan bulatan yang ditulis dalam Rhombus | Berfungsi untuk mencari kawasan bulatan tertulis; Diagonal tidak boleh negatif; kawasan bulatan; Kod pemacu", "code": "< ? php function circlearea ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ A = ( 3.14 * pow ( $ a , 2 ) * pow ( $ b , 2 ) ) / ( 4 * ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) ) ; return $ A ; } $ a = 8 ; $ b = 10 ; echo circlearea ( $ a , $ b ) ; ? >"}
{"text": "Lingkaran terbesar yang boleh ditulis dalam segi empat tepat | Berfungsi untuk mencari kawasan bulatan terbesar; Panjang dan keluasan tidak boleh negatif; kawasan bulatan; Kod pemacu", "code": "< ? php function circlearea ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; if ( $ l < $ b ) return 3.14 * pow ( $ l / 2 , 2 ) ; else return 3.14 * pow ( $ b / 2 , 2 ) ; } $ l = 4 ; $ b = 8 ; echo circlearea ( $ l , $ b ) . \" STRNEWLINE \" ; ? >"}
{"text": "Nombor kiub berpusat | Berfungsi untuk mencari nombor kiub yang berpusat; Formula untuk mengira nombor kiub yang berpusat di Nth & mengembalikannya ke dalam fungsi utama. ; Kod pemacu", "code": "< ? php function centered_cube ( $ n ) { return ( 2 * $ n + 1 ) * ( $ n * $ n + $ n + 1 ) ; } $ n = 3 ; echo $ n , \" th ▁ Centered ▁ cube ▁ number : ▁ \" ; echo centered_cube ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 10 ; echo $ n , \" th ▁ Centered ▁ cube ▁ number : ▁ \" ; echo centered_cube ( $ n ) ; ? >"}
{"text": "Cari pusat bulatan menggunakan titik akhir diameter | berfungsi untuk mencari pusat bulatan; Kod yang didorong", "code": "< ? php function center ( $ x1 , $ x2 , $ y1 , $ y2 ) { echo ( ( float ) ( $ x1 + $ x2 ) / 2 . \" , ▁ \" . ( float ) ( $ y1 + $ y2 ) / 2 ) ; } $ x1 = -9 ; $ y1 = 3 ; $ x2 = 5 ; $ y2 = -7 ; center ( $ x1 , $ x2 , $ y1 , $ y2 ) ; ? >"}
{"text": "Program untuk mengira jumlah octahedron | fungsi utiliti; Fungsi pemacu", "code": "< ? php function vol_of_octahedron ( $ side ) { return ( ( $ side * $ side * $ side ) * ( sqrt ( 2 ) / 3 ) ) ; } $ side = 3 ; echo ( \" Volume ▁ of ▁ octahedron ▁ = \" ) ; echo ( vol_of_octahedron ( $ side ) ) ; ? >"}
{"text": "Program untuk mengira jumlah ellipsoid | Berfungsi untuk mencari kelantangan; Kod pemacu", "code": "< ? php function volumeOfEllipsoid ( $ r1 , $ r2 , $ r3 ) { $ pi = 3.14 ; return 1.33 * $ pi * $ r1 * $ r2 * $ r3 ; } $ r1 = 2.3 ; $ r2 = 3.4 ; $ r3 = 5.7 ; echo ( \" volume ▁ of ▁ ellipsoid ▁ is ▁ : ▁ \" ) ; echo ( volumeOfEllipsoid ( $ r1 , $ r2 , $ r3 ) ) ; ? >"}
{"text": "Program untuk mengira kawasan oktagon | Fungsi utiliti; Kod pemacu", "code": "< ? php function areaOctagon ( $ side ) { return ( 2 * ( 1 + sqrt ( 2 ) ) * $ side * $ side ) ; } $ side = 4 ; echo ( \" Area ▁ of ▁ Regular ▁ Octagon ▁ = ▁ \" ) ; echo ( areaOctagon ( $ side ) ) ; ? >"}
{"text": "Program untuk kelantangan dan kawasan permukaan kiub | fungsi utiliti; fungsi pemacu", "code": "< ? php function areaCube ( $ a ) { return ( $ a * $ a * $ a ) ; } function surfaceCube ( $ a ) { return ( 6 * $ a * $ a ) ; } $ a = 5 ; echo ( \" Area ▁ = ▁ \" ) ; echo ( areaCube ( $ a ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Total ▁ surface ▁ area ▁ = ▁ \" ) ; echo ( surfaceCube ( $ a ) ) ; ? >"}
{"text": "Revolusi minimum untuk memindahkan pusat bulatan ke sasaran | Revolusi minimum untuk memindahkan pusat dari (x1, y1) hingga (x2, y2); Kod pemacu", "code": "< ? php function minRevolutions ( $ r , $ x1 , $ y1 , $ x2 , $ y2 ) { $ d = sqrt ( ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ) ; return ceil ( $ d / ( 2 * $ r ) ) ; } $ r = 2 ; $ x1 = 0 ; $ y1 = 0 ; $ x2 = 0 ; $ y2 = 4 ; echo minRevolutions ( $ r , $ x1 , $ y1 , $ x2 , $ y2 ) ; ? >"}
{"text": "Cari semua sisi segitiga bersudut kanan dari Hypotenuse dan Kawasan yang diberikan | Tetapkan 1 | had untuk perbandingan terapung; Kaedah utiliti untuk mendapatkan kawasan segi tiga sudut kanan, diberi asas dan hipotenus; Mencetak asas dan ketinggian segitiga menggunakan maklumat hipotenus dan kawasan; Kawasan maksimum akan diperoleh apabila asas dan ketinggian adalah sama (= sqrt (h * h / 2)); Sekiranya kawasan yang diberikan itu lebih besar daripada MaxArea maka tiada penyelesaian yang mungkin; Carian binari untuk asas; Dapatkan ketinggian oleh peraturan Pythagorean; Kod pemacu", "code": "< ? php $ eps = .0000001 ; function getArea ( $ base , $ hypotenuse ) { $ height = sqrt ( $ hypotenuse * $ hypotenuse - $ base * $ base ) ; return 0.5 * $ base * $ height ; } function printRightAngleTriangle ( $ hypotenuse , $ area ) { global $ eps ; $ hsquare = $ hypotenuse * $ hypotenuse ; $ sideForMaxArea = sqrt ( $ hsquare / 2.0 ) ; $ maxArea = getArea ( $ sideForMaxArea , $ hypotenuse ) ; if ( $ area > $ maxArea ) { echo \" Not ▁ possiblen \" ; return ; } $ low = 0.0 ; $ high = $ sideForMaxArea ; $ base ; while ( abs ( $ high - $ low ) > $ eps ) { $ base = ( $ low + $ high ) / 2.0 ; if ( getArea ( $ base , $ hypotenuse ) >= $ area ) $ high = $ base ; else $ low = $ base ; } $ height = sqrt ( $ hsquare - $ base * $ base ) ; echo ( ceil ( $ base ) ) , \" ▁ \" , ( floor ( $ height ) ) , \" STRNEWLINE \" ; } $ hypotenuse = 5 ; $ area = 6 ; printRightAngleTriangle ( $ hypotenuse , $ area ) ; ? >"}
{"text": "Lingkaran dan Poin Kekisi | Berfungsi untuk mengira titik kekisi pada bulatan; Memulakan hasil sebagai 4 untuk (r, 0), ( - r 0), (0, r) dan (0, - r); Semak setiap nilai yang boleh menjadi potensi x; Cari potensi y; Memeriksa sama ada akar persegi adalah integer atau tidak. Kira kenaikan sebanyak 4 untuk empat nilai kuadran yang berbeza; Kod pemacu", "code": "< ? php function countLattice ( $ r ) { if ( $ r <= 0 ) return 0 ; $ result = 4 ; for ( $ x = 1 ; $ x < $ r ; $ x ++ ) { $ ySquare = $ r * $ r - $ x * $ x ; $ y = ceil ( sqrt ( $ ySquare ) ) ; if ( $ y * $ y == $ ySquare ) $ result += 4 ; } return $ result ; } $ r = 5 ; echo countLattice ( $ r ) ; ? >"}
{"text": "Cari bilangan pasangan ajaib rentetan panjang l | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini x jika ia> = p; Jika y adalah ganjil, kalikan x dengan hasil; Y mestilah sekarang $ y = $ y >> 1; y = y / 2; Kod pemacu", "code": "< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } $ L = 2 ; $ P = pow ( 10 , 9 ) ; $ ans = power ( 325 , $ L , $ P ) ; echo $ ans , \" STRNEWLINE \" ; ? >"}
{"text": "Substring terpanjang hanya 4 dari aksara N pertama dari rentetan tak terhingga | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan panjang rentetan bersebelahan terpanjang yang mengandungi hanya 4 ATM dari aksara N pertama rentetan; Memulakan hasil; Mulakan Awalan Jumlah Watak dan Pembolehubah Produk; Preprocessing array jumlah awalan; Memulakan pembolehubah untuk menyimpan panjang rentetan di mana n dimiliki; Mencari panjang rentetan di mana n dimiliki; Kod pemacu", "code": "< ? php $ MAXN = 30 ; function countMaxLength ( $ N ) { $ res = 0 ; $ pre = array ( ) ; $ p = 1 ; $ pre [ 0 ] = 0 ; for ( $ i = 1 ; $ i < $ GLOBALS [ ' AXN ' ; $ i ++ ) { $ p *= 2 ; $ pre [ $ i ] = $ pre [ $ i - 1 ] + $ i * $ p ; } $ ind = 0 ; for ( $ i = 1 ; $ i < $ GLOBALS [ ' AXN ' ; $ i ++ ) { if ( $ pre [ $ i ] >= $ N ) { $ ind = $ i ; break ; } } $ x = $ N - $ pre [ $ ind - 1 ] ; $ y = 2 * $ ind - 1 ; if ( $ x >= $ y ) $ res = min ( $ x , $ y ) ; else $ res = max ( $ x , 2 * ( $ ind - 2 ) + 1 ) ; return $ res ; } $ N = 25 ; echo countMaxLength ( $ N ) ; ? >"}
{"text": "Perbezaan antara rekursi dan lelaran | - - - rekursi - - - Kaedah untuk mencari faktorial nombor yang diberikan; panggilan rekursi; - - - lelaran - - - Kaedah untuk mencari faktorial nombor tertentu; menggunakan lelaran; Kaedah Pemandu", "code": "< ? php function factorialUsingRecursion ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * factorialUsingRecursion ( $ n - 1 ) ; } function factorialUsingIteration ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res *= $ i ; return $ res ; } $ num = 5 ; print ( \" Factorial ▁ of ▁ \" . $ num . \" ▁ using ▁ Recursion ▁ is : ▁ \" . factorialUsingRecursion ( 5 ) . \" STRNEWLINE \" ) ; print ( \" Factorial ▁ of ▁ \" . $ num . \" ▁ using ▁ Iteration ▁ is : ▁ \" . factorialUsingIteration ( 5 ) . \" STRNEWLINE \" ) ; ? >"}
{"text": "Cari jumlah maksimum yang mengambil setiap elemen kth dalam array | Fungsi untuk mengembalikan jumlah maksimum untuk setiap urutan yang mungkin supaya [i] + a [i + k] + a [i + 2 k] + ... + a [i + qk] dimaksimumkan; Memulakan maksimum dengan nilai terkecil; Memulakan array jumlah dengan sifar; Berulang dari kanan; Mengemas kini jumlah bermula pada elemen semasa; Mengemas kini maksimum setakat ini; Kod pemacu", "code": "< ? php function maxSum ( $ arr , $ n , $ K ) { $ maximum = PHP_INT_MIN ; $ sum = array ( $ n ) ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ i + $ K < $ n ) $ sum [ $ i ] = $ sum [ $ i + $ K ] + $ arr [ $ i ] ; else $ sum [ $ i ] = $ arr [ $ i ] ; $ maximum = max ( $ maximum , $ sum [ $ i ] ) ; } return $ maximum ; } { $ arr = array ( 3 , 6 , 4 , 7 , 2 ) ; $ n = sizeof ( $ arr ) ; $ K = 2 ; echo ( maxSum ( $ arr , $ n , $ K ) ) ; }"}
{"text": "Cari pasangan yang berbeza (x, y) dalam julat yang diberikan supaya x membahagikan y | Pelaksanaan PHP pendekatan; Kod pemacu", "code": "< ? php function findpair ( $ l , $ r ) { $ c = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j <= $ r ; $ j ++ ) { if ( $ j % $ i == 0 && $ j != $ i ) { echo ( $ i . \" , ▁ \" . $ j ) ; $ c = 1 ; break ; } } if ( $ c == 1 ) break ; } } $ l = 1 ; $ r = 10 ; findpair ( $ l , $ r ) ; ? >"}
{"text": "Semak jika array yang diberikan dapat dikurangkan kepada sifar dengan operasi yang diberikan dilakukan bilangan kali | Fungsi yang mengembalikan benar jika array dapat dikurangkan kepada 0 s dengan operasi yang diberikan dilakukan beberapa kali; Tambah dalam set hanya elemen unik; Mengira semua elemen unik dalam array; Kod pemacu", "code": "< ? php function check ( & $ arr , $ N , $ K ) { $ unique = array_unique ( $ arr ) ; if ( count ( $ unique ) == $ K ) return true ; return false ; } $ arr = array ( 1 , 1 , 2 , 3 ) ; $ N = count ( $ arr ) ; $ K = 3 ; if ( check ( $ arr , $ N , $ K ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Indeks minimum i sedemikian rupa sehingga semua elemen dari indeks I ke indeks yang diberikan adalah sama | Berfungsi untuk mengembalikan indeks minimum yang diperlukan; Bermula dari arr [pos - 1]; Semua elemen adalah sama dari arr [i + 1] ke arr [pos]; Kod pemacu; Panggilan fungsi", "code": "< ? php function minIndex ( $ arr , $ n , $ pos ) { $ num = $ arr [ $ pos ] ; $ i = $ pos - 1 ; while ( $ i >= 0 ) { if ( $ arr [ $ i ] != $ num ) break ; $ i -- ; } return $ i + 1 ; } $ arr = array ( 2 , 1 , 1 , 1 , 5 , 2 ) ; $ n = sizeof ( $ arr ) ; $ pos = 4 ; echo minIndex ( $ arr , $ n , $ pos ) ; ? >"}
{"text": "Count of Strings yang menjadi sama dengan salah satu daripada dua rentetan selepas satu penyingkiran | Berfungsi untuk mengembalikan kiraan rentetan yang diperlukan; Indeks mencari selepas awalan biasa terpanjang; Indeks mencari sebelum akhiran biasa terpanjang; Jika str1 = str2; Jika hanya 1 watak yang berbeza dalam kedua -dua rentetan; Memeriksa baki bahagian rentetan untuk kesamaan; Mencari di sebelah kanan rentetan H (G ke H); Kod pemacu", "code": "< ? php function findAnswer ( $ str1 , $ str2 , $ n ) { $ ans = 2 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ str1 [ $ i ] != $ str2 [ $ i ] ) { $ l = $ i ; break ; } } for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ str1 [ $ i ] != $ str2 [ $ i ] ) { $ r = $ i ; break ; } } if ( $ r < $ l ) return 26 * ( $ n + 1 ) ; else if ( $ l == $ r ) return $ ans ; else { for ( $ i = $ l + 1 ; $ i <= $ r ; $ i ++ ) { if ( $ str1 [ $ i ] != $ str2 [ $ i - 1 ] ) { $ ans -- ; break ; } } for ( $ i = $ l + 1 ; $ i <= $ r ; $ i ++ ) { if ( $ str1 [ $ i - 1 ] != $ str2 [ $ i ] ) { $ ans -- ; break ; } } return $ ans ; } } $ str1 = \" toy \" ; $ str2 = \" try \" ; $ n = strlen ( $ str1 ) ; echo findAnswer ( $ str1 , $ str2 , $ n ) ; ? >"}
{"text": "Kurangkan perbezaan minimum maksimum selepas satu penyingkiran dari array | Berfungsi untuk mengembalikan perbezaan minimum yang diperlukan; Susun array yang diberikan; Apabila elemen minimum dikeluarkan; Apabila elemen maksimum dikeluarkan; Mengembalikan minimum diff1 dan diff2; Kod pemacu", "code": "< ? php function findMinDifference ( $ arr , $ n ) { sort ( $ arr , 0 ) ; $ diff1 = $ arr [ $ n - 1 ] - $ arr [ 1 ] ; $ diff2 = $ arr [ $ n - 2 ] - $ arr [ 0 ] ; return min ( $ diff1 , $ diff2 ) ; } $ arr = array ( 1 , 2 , 4 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo findMinDifference ( $ arr , $ n ) ;"}
{"text": "Kurangkan perbezaan minimum maksimum selepas satu penyingkiran dari array | Berfungsi untuk mengembalikan perbezaan minimum yang diperlukan; Jika elemen semasa lebih besar daripada maks; Max akan menjadi SecondMax; Kemas kini maksimum; Jika elemen semasa lebih besar daripada SecondMax tetapi lebih kecil daripada Max; Kemas kini SecondMax; Jika elemen semasa lebih kecil daripada min; Min akan menjadi Secondmin; Mengemas kini min; Jika elemen semasa lebih kecil daripada kedua -dua kedua tetapi lebih besar daripada min; Kemas kini Secondmin; Minimum dua perbezaan yang mungkin; Kod pemacu", "code": "< ? php function findMinDifference ( $ arr , $ n ) { $ min__ = $ secondMax = ( $ arr [ 0 ] < $ arr [ 1 ] ) ? $ arr [ 0 ] : $ arr [ 1 ] ; $ max__ = $ secondMin = ( $ arr [ 0 ] < $ arr [ 1 ] ) ? $ arr [ 1 ] : $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ max__ ) { $ secondMax = $ max__ ; $ max__ = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ secondMax ) { $ secondMax = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] < $ min__ ) { $ secondMin = $ min__ ; $ min__ = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] < $ secondMin ) { $ secondMin = $ arr [ $ i ] ; } } $ diff = min ( $ max__ - $ secondMin , $ secondMax - $ min__ ) ; return $ diff ; } $ arr = array ( 1 , 2 , 4 , 3 , 4 ) ; $ n = count ( $ arr ) ; print ( findMinDifference ( $ arr , $ n ) ) ; ? >"}
{"text": "Integer dari julat yang terdiri daripada satu digit yang berbeza | Fungsi Boolean untuk memeriksa digit yang berbeza dari nombor; Ambil digit terakhir; Semak sama ada semua digit lain sama seperti digit terakhir; Keluarkan digit terakhir; Berfungsi untuk mengembalikan kiraan bilangan bulat yang terdiri daripada satu digit yang berbeza sahaja; Sekiranya saya mempunyai satu digit yang berbeza; Kod pemacu", "code": "< ? php function checkDistinct ( $ x ) { $ last = $ x % 10 ; while ( $ x ) { if ( $ x % 10 != $ last ) return false ; $ x = floor ( $ x / 10 ) ; } return true ; } function findCount ( $ L , $ R ) { $ count = 0 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { if ( checkDistinct ( $ i ) ) $ count += 1 ; } return $ count ; } $ L = 10 ; $ R = 50 ; echo findCount ( $ L , $ R ) ; ? >"}
{"text": "Jumlah pasangan terkecil dalam array | Berfungsi untuk mengembalikan jumlah pasangan minimum dari array; Jika didapati minimum baru; Minimum kini menjadi minimum kedua; Mengemas kini minimum; Jika elemen semasa adalah> min dan <secondmin; Kemas kini Secondmin; Mengembalikan jumlah pasangan minimum; Kod pemacu", "code": "< ? php function smallest_pair ( $ a , $ n ) { $ min = PHP_INT_MAX ; $ secondMin = PHP_INT_MAX ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ j ] < $ min ) { $ secondMin = $ min ; $ min = $ a [ $ j ] ; } else if ( ( $ a [ $ j ] < $ secondMin ) && $ a [ $ j ] != $ min ) $ secondMin = $ a [ $ j ] ; } return ( $ secondMin + $ min ) ; } $ arr = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; echo smallest_pair ( $ arr , $ n ) ; ? >"}
{"text": "Subarray terpanjang dengan unsur -unsur yang boleh dibahagikan oleh k | berfungsi untuk mencari subarray terpanjang; Ini akan mengandungi panjang subarray terpanjang yang dijumpai; Kod pemacu", "code": "< ? php function longestsubarray ( $ arr , $ n , $ k ) { $ current_count = 0 ; $ max_count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % $ k == 0 ) $ current_count ++ ; else $ current_count = 0 ; $ max_count = max ( $ current_count , $ max_count ) ; } return $ max_count ; } $ arr = array ( 2 , 5 , 11 , 32 , 64 , 88 ) ; $ n = sizeof ( $ arr ) ; $ k = 8 ; echo longestsubarray ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Semak jika rentetan mengandungi sub Palindromic | fungsi untuk memeriksa sama ada dua watak yang sama berturut -turut hadir; Kod pemacu", "code": "< ? php function check ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) - 1 ; $ i ++ ) if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) return true ; return false ; } $ s = \" xzyyz \" ; if ( check ( $ s ) ) echo \" YES \" , \" STRNEWLINE \" ; else echo \" NO \" , \" STRNEWLINE \" ; ? >"}
{"text": "Bilangan anomali dalam array | Penyelesaian PHP yang mudah untuk mengira anomali dalam array. ; Kod pemacu", "code": "< ? php function countAnomalies ( & $ arr , $ n , $ k ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ i != $ j && abs ( $ arr [ $ i ] - $ arr [ $ j ] ) <= $ k ) break ; if ( $ j == $ n ) $ res ++ ; } return $ res ; } $ arr = array ( 7 , 1 , 8 ) ; $ k = 5 ; $ n = sizeof ( $ arr ) ; echo countAnomalies ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Cari pasangan dengan perbezaan maksimum dalam mana -mana lajur matriks | Berfungsi untuk mencari lajur dengan perbezaan maksimum; Lajur Matriks Traverse bijak; Masukkan elemen lajur ke vektor; mengira perbezaan antara maksimum dan minimum; kod pemacu", "code": "< ? php function colMaxDiff ( $ mat ) { $ N = 5 ; $ max_diff = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ max_val = $ mat [ 0 ] [ $ i ] ; $ min_val = $ mat [ 0 ] [ $ i ] ; for ( $ j = 1 ; $ j < $ N ; $ j ++ ) { $ max_val = max ( $ max_val , $ mat [ $ j ] [ $ i ] ) ; $ min_val = min ( $ min_val , $ mat [ $ j ] [ $ i ] ) ; } $ max_diff = max ( $ max_diff , $ max_val - $ min_val ) ; } return $ max_diff ; } $ mat = array ( array ( 1 , 2 , 3 , 4 , 5 ) , array ( 5 , 3 , 5 , 4 , 0 ) , array ( 5 , 6 , 7 , 8 , 9 ) , array ( 0 , 6 , 3 , 4 , 12 ) , array ( 9 , 7 , 12 , 4 , 3 ) ) ; echo \" Max ▁ difference ▁ : ▁ \" . colMaxDiff ( $ mat ) . \" STRNEWLINE \" ;"}
{"text": "Cari nombor yang hilang dalam array yang disusun | Program berasaskan carian binari untuk mencari satu -satunya nombor yang hilang dalam pelbagai elemen yang disusun dalam julat terhad. ; Kod pemacu", "code": "< ? php function search ( $ ar , $ size ) { $ a = 0 ; $ b = $ size - 1 ; $ mid ; while ( ( $ b - $ a ) > 1 ) { $ mid = ( int ) ( ( $ a + $ b ) / 2 ) ; if ( ( $ ar [ $ a ] - $ a ) != ( $ ar [ $ mid ] - $ mid ) ) $ b = $ mid ; else if ( ( $ ar [ $ b ] - $ b ) != ( $ ar [ $ mid ] - $ mid ) ) $ a = $ mid ; } return ( $ ar [ $ a ] + 1 ) ; } $ ar = array ( 1 , 2 , 3 , 4 , 5 , 6 , 8 ) ; $ size = sizeof ( $ ar ) ; echo \" Missing ▁ number : ▁ \" , search ( $ ar , $ size ) ; ? >"}
{"text": "Padam elemen array dalam julat indeks yang diberikan [L | Padam l unsur -unsur; Saiz kembali array selepas padam elemen; Kod pemacu", "code": "< ? php function deleteElement ( & $ A , $ L , $ R , $ N ) { $ i = 0 ; $ j = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ i <= $ L $ i >= $ R ) { $ A [ $ j ] = $ A [ $ i ] ; $ j ++ ; } } return $ j ; } $ A = array ( 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 ) ; $ L = 2 ; $ R = 7 ; $ n = sizeof ( $ A ) ; $ res_size = deleteElement ( $ A , $ L , $ R , $ n ) ; for ( $ i = 0 ; $ i < $ res_size ; $ i ++ ) { echo ( $ A [ $ i ] ) ; echo ( \" ▁ \" ) ; } ? >"}
{"text": "Cari satu -satunya nombor yang hilang dalam array yang disusun | Program PHP untuk mencari satu -satunya elemen yang hilang. ; Jika ini adalah elemen pertama yang bukan indeks + 1, maka elemen yang hilang adalah pertengahan + 1; Jika ini bukan carian elemen pertama yang hilang di sebelah kiri; Jika ia mengikuti indeks + 1 harta maka cari di sebelah kanan; Sekiranya tiada elemen hilang; Kod pemacu", "code": "< ? php function findmissing ( & $ ar , $ N ) { $ r = $ N - 1 ; $ l = 0 ; while ( $ l <= $ r ) { $ mid = ( $ l + $ r ) / 2 ; if ( $ ar [ $ mid ] != $ mid + 1 && $ ar [ $ mid - 1 ] == $ mid ) return ( $ mid + 1 ) ; if ( $ ar [ $ mid ] != $ mid + 1 ) $ r = $ mid - 1 ; else $ l = $ mid + 1 ; } return ( -1 ) ; } $ ar = array ( 1 , 2 , 3 , 4 , 5 , 7 , 8 ) ; $ N = sizeof ( $ ar ) ; echo ( findmissing ( $ ar , $ N ) ) ; ? >"}
{"text": "Cari indeks kejadian pertama apabila array yang tidak disusun disusun | Program PHP untuk mencari indeks kejadian pertama X apabila array disusun. ; Lower_bound mengembalikan iterator menunjuk ke elemen pertama yang tidak membandingkan kurang dengan x. ; Jika x tidak hadir kembali - 1 .; Kod didorong", "code": "< ? php function findFirst ( $ arr , $ n , $ x ) { sort ( $ arr ) ; $ ptr = floor ( $ arr ) ; return ( $ ptr != $ x ) ? 1 : ( $ ptr - $ arr ) ; } $ x = 20 ; $ arr = array ( 10 , 30 , 20 , 50 , 20 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo findFirst ( $ arr , $ n , $ x ) ; #This  code is contributed by Tushil. NEW_LINE ? >"}
{"text": "Cari indeks kejadian pertama apabila array yang tidak disusun disusun | Program PHP untuk mencari indeks kejadian pertama X apabila array disusun. ; Kod pemacu", "code": "< ? php function findFirst ( $ arr , $ n , $ x ) { $ count = 0 ; $ isX = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) $ isX = true ; else if ( $ arr [ $ i ] < $ x ) $ count ++ ; } return ( $ isX == false ) ? -1 : $ count ; } $ x = 20 ; $ arr = array ( 10 , 30 , 20 , 50 , 20 ) ; $ n = sizeof ( $ arr ) ; echo findFirst ( $ arr , $ n , $ x ) ; ? >"}
{"text": "Cari pendua dalam array dalam O (n) dan dengan menggunakan O (1) ruang tambahan | Berfungsi untuk mencari pendua; Cari titik persimpangan perlahan dan cepat. ; Cari \"pintu masuk\" ke kitaran. ; Kod pemacu", "code": "< ? php function findDuplicate ( & $ arr ) { $ slow = $ arr [ 0 ] ; $ fast = $ arr [ 0 ] ; do { $ slow = $ arr [ $ slow ] ; $ fast = $ arr [ $ arr [ $ fast ] ] ; } while ( $ slow != $ fast ) ; $ ptr1 = $ arr [ 0 ] ; $ ptr2 = $ slow ; while ( $ ptr1 != $ ptr2 ) { $ ptr1 = $ arr [ $ ptr1 ] ; $ ptr2 = $ arr [ $ ptr2 ] ; } return $ ptr1 ; } $ arr = array ( 1 , 3 , 2 , 1 ) ; echo \" ▁ \" . findDuplicate ( $ arr ) ; ? >"}
{"text": "Bilangan elemen yang lebih besar di sebelah kanan dalam rentetan | Program PHP untuk mengira watak yang lebih besar di sebelah kanan setiap watak. ; Array untuk menyimpan hasil dan kiraan watak. ; Mula dari sebelah kanan rentetan; Kod pemacu", "code": "< ? php $ MAX_CHAR = 26 ; function printGreaterCount ( $ str ) { global $ MAX_CHAR ; $ len = strlen ( $ str ) ; $ ans = array_fill ( 0 , $ len , 0 ) ; $ count = array_fill ( 0 , $ MAX_CHAR , 0 ) ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { $ count [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ j = ord ( $ str [ $ i ] ) - ord ( ' a ' ) + 1 ; $ j < $ MAX_CHAR ; $ j ++ ) $ ans [ $ i ] += $ count [ $ j ] ; } for ( $ i = 0 ; $ i < $ len ; $ i ++ ) echo $ ans [ $ i ] . \" ▁ \" ; } $ str = \" abcd \" ; printGreaterCount ( $ str ) ; ? >"}
{"text": "Produk maksimum empat kali ganda (sub | berfungsi untuk mencari produk maksimum kuadruple dalam pelbagai integer saiz n; jika saiz kurang daripada 4, tiada kuadruple wujud; Maksimum maksimum maksimum dan maksimum maksimum maksimum dan maksimum maksimum keempat, maksimum maksimum maksimum keempat, minimum, minimum dan elemen minimum keempat;", "code": "< ? php function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; $ maxA = -2147483648 ; $ maxB = -2147483648 ; $ maxC = -2147483648 ; $ maxD = -2147483648 ; $ minA = 2147483647 ; $ minB = 2147483647 ; $ minC = 2147483647 ; $ minD = 2147483647 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ maxA ) { $ maxD = $ maxC ; $ maxC = $ maxB ; $ maxB = $ maxA ; $ maxA = $ arr [ $ i ] ; } elseif ( $ arr [ $ i ] > $ maxB ) { $ maxD = $ maxC ; $ maxC = $ maxB ; $ maxB = $ arr [ $ i ] ; } elseif ( $ arr [ $ i ] > $ maxC ) { $ maxD = $ maxC ; $ maxC = $ arr [ $ i ] ; } elseif ( $ arr [ $ i ] > $ maxD ) $ maxD = $ arr [ $ i ] ; if ( $ arr [ $ i ] < $ minA ) { $ minD = $ minC ; $ minC = $ minB ; $ minB = $ minA ; $ minA = $ arr [ $ i ] ; } elseif ( $ arr [ $ i ] < $ minB ) { $ minD = $ minC ; $ minC = $ minB ; $ minB = $ arr [ $ i ] ; } elseif ( $ arr [ $ i ] < $ minC ) { $ minD = $ minC ; $ minC = $ arr [ $ i ] ; } elseif ( $ arr [ $ i ] < $ minD ) $ minD = $ arr [ $ i ] ; } $ x = $ maxA * $ maxB * $ maxC * $ maxD ; $ y = $ minA * $ minB * $ minC * $ minD ; $ z = $ minA * $ minB * $ maxA * $ maxB ; return max ( $ x , max ( $ y , $ z ) ) ; } $ arr = array ( 1 , -4 , 3 , -6 , 7 , 0 ) ; $ n = count ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) echo \" No ▁ Quadruple ▁ Exists \" ; else echo \" Maximum ▁ product ▁ is ▁ \" . $ max ; ? >"}
{"text": "Cara memilih tiga mata dengan jarak antara titik paling jauh <= l | Mengembalikan bilangan tiga kali ganda dengan jarak antara titik paling jauh <= l; Susun untuk mendapatkan triplet yang diperintahkan supaya kita dapat mencari jarak antara titik paling jauh milik triplet; Menjana dan periksa semua kemungkinan tiga kali ganda: {arr [i], arr [j], arr [k]}; Oleh kerana array disusun, titik terjauh akan menjadi [i] dan a [k]; ; set N mata pada paksi x", "code": "< ? php function countTripletsLessThanL ( $ n , $ L , $ arr ) { sort ( $ arr ) ; $ ways = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { $ mostDistantDistance = $ arr [ $ k ] - $ arr [ $ i ] ; if ( $ mostDistantDistance <= $ L ) { $ ways ++ ; } } } } return $ ways ; } $ arr = array ( 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; $ L = 3 ; $ ans = countTripletsLessThanL ( $ n , $ L , $ arr ) ; echo \" Total ▁ Number ▁ of ▁ ways ▁ = ▁ \" , $ ans , \" STRNEWLINE \" ; ? >"}
{"text": "Cari nombor yang hilang dalam julat | Cari nombor yang hilang dalam julat; Di sini kita xor semua nombor; XOR nombor terakhir; Kod pemacu", "code": "< ? php function missingNum ( $ arr , $ n ) { $ minvalue = min ( $ arr ) ; $ xornum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ xornum ^= ( $ minvalue ) ^ $ arr [ $ i ] ; $ minvalue ++ ; } return $ xornum ^ $ minvalue ; } $ arr = array ( 13 , 12 , 11 , 15 ) ; $ n = sizeof ( $ arr ) ; echo missingNum ( $ arr , $ n ) ; ? >"}
{"text": "Cari indeks terakhir watak dalam rentetan | Mengembalikan indeks terakhir X jika ada. Lain kembali - 1 .; Rentetan di mana char dapat dijumpai; char yang indeksnya dijumpai", "code": "< ? php function findLastIndex ( $ str , $ x ) { $ index = -1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ str [ $ i ] == $ x ) $ index = $ i ; return $ index ; } $ str = \" geeksforgeeks \" ; $ x = ' e ' ; $ index = findLastIndex ( $ str , $ x ) ; if ( $ index == -1 ) echo ( \" Character ▁ not ▁ found \" ) ; else echo ( \" Last ▁ index ▁ is ▁ \" . $ index ) ; ? >"}
{"text": "Cari indeks terakhir watak dalam rentetan | Mengembalikan indeks terakhir X jika ada. Lain kembali - 1 .; Melintasi dari kanan; Kod pemacu", "code": "< ? php function findLastIndex ( $ str , $ x ) { for ( $ i = strlen ( $ str ) - 1 ; $ i >= 0 ; $ i -- ) if ( $ str [ $ i ] == $ x ) return $ i ; return -1 ; } $ str = \" geeksforgeeks \" ; $ x = ' e ' ; $ index = findLastIndex ( $ str , $ x ) ; if ( $ index == -1 ) echo ( \" Character ▁ not ▁ found \" ) ; else echo ( \" Last ▁ index ▁ is ▁ \" . $ index ) ; ? >"}
{"text": "Nombor terkecil yang bit yang ditetapkan adalah maksimum dalam julat tertentu | Mengembalikan nombor terkecil yang bit set adalah maksimum dalam julat yang diberikan. ; Kod pemacu", "code": "< ? php function countMaxSetBits ( $ left , $ right ) { while ( ( $ left | ( $ left + 1 ) ) <= $ right ) $ left |= $ left + 1 ; return $ left ; } $ l = 1 ; $ r = 5 ; echo countMaxSetBits ( $ l , $ r ) , \" STRNEWLINE \" ; $ l = 1 ; $ r = 10 ; echo countMaxSetBits ( $ l , $ r ) ; ? >"}
{"text": "Cari jika nombor yang diberikan adalah jumlah nombor semulajadi n pertama | Berfungsi untuk mencari tidak. unsur -unsur yang akan ditambah untuk mendapatkan s; Memohon carian binari; Cari pertengahan; Cari jumlah 1 hingga pertengahan nombor semulajadi menggunakan formula; Jika jumlahnya sama dengan N kembali pertengahan; Jika lebih besar daripada n r = pertengahan - 1; lain lakukan l = pertengahan + 1; Jika tidak mungkin, kembali - 1; Kod pemandu", "code": "< ? php function findS ( $ s ) { $ l = 1 ; $ r = 1 + ( int ) $ s / 2 ; while ( $ l <= $ r ) { $ mid = ( int ) ( ( $ l + $ r ) / 2 ) ; $ sum = ( int ) ( $ mid * ( $ mid + 1 ) / 2 ) ; if ( $ sum == $ s ) return $ mid ; else if ( $ sum > $ s ) $ r = $ mid - 1 ; else $ l = $ mid + 1 ; } return -1 ; } $ s = 15 ; $ n = findS ( $ s ) ; if ( $ n == -1 ) echo \" - 1\" ; else echo $ n ; ? >"}
{"text": "Program untuk mencetak array dalam susunan pendulum dengan ruang tetap | Berfungsi untuk mencetak susunan pendulum array yang diberikan; Susun array; POS menyimpan indeks elemen terakhir array; Ganjil menyimpan indeks ganjil terakhir dalam array; Gerakkan semua elemen kedudukan indeks ganjil ke kanan; Mengalihkan unsur -unsur dengan satu kedudukan dari ganjil ke pos; Membalikkan elemen dari 0 hingga (n - 1) / 2; Mencetak susunan pendulum; Kod pemacu", "code": "< ? php function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr ) ; $ pos = $ n - 1 ; if ( $ n % 2 == 0 ) $ odd = $ n - 1 ; else $ odd = $ n - 2 ; while ( $ odd > 0 ) { $ temp = $ arr [ $ odd ] ; $ in = $ odd ; while ( $ in != $ pos ) { $ arr [ $ in ] = $ arr [ $ in + 1 ] ; $ in ++ ; } $ arr [ $ in ] = $ temp ; $ odd = $ odd - 2 ; $ pos = $ pos - 1 ; } $ start = 0 ; $ end = floor ( ( $ n - 1 ) / 2 ) ; for ( ; $ start < $ end ; $ start ++ , $ end -- ) { $ temp = $ arr [ $ start ] ; $ arr [ $ start ] = $ arr [ $ end ] ; $ arr [ $ end ] = $ temp ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; } $ arr = array ( 11 , 2 , 4 , 55 , 6 , 8 ) ; $ n = count ( $ arr ) ; pendulumArrangement ( $ arr , $ n ) ; ? >"}
{"text": "Nombor minimum lebih besar daripada maksimum array yang tidak dapat dibentuk menggunakan nombor dalam array | Fungsi yang mengembalikan nombor minimum yang lebih besar daripada maksimum array yang tidak dapat dibentuk menggunakan unsur -unsur array; Susun array yang diberikan; Nombor maksimum dalam array; Jadual [i] akan menyimpan bilangan elemen minimum dari array ke Borang I; Kirakan bilangan elemen minimum dari array yang diperlukan untuk membentuk nombor dari 1 hingga (2 * max); Sekiranya terdapat nombor yang lebih besar daripada elemen maksimum array yang boleh dibentuk menggunakan bilangan array; Kod pemacu", "code": "< ? php function findNumber ( $ arr , $ n ) { sort ( $ arr ) ; $ max = $ arr [ $ n - 1 ] ; $ table = array ( ( 2 * $ max ) + 1 ) ; $ table [ 0 ] = 0 ; for ( $ i = 1 ; $ i < ( 2 * $ max ) + 1 ; $ i ++ ) $ table [ $ i ] = PHP_INT_MAX ; $ ans = -1 ; for ( $ i = 1 ; $ i < ( 2 * $ max ) + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] <= $ i ) { $ res = $ table [ $ i - $ arr [ $ j ] ] ; if ( $ res != PHP_INT_MAX && $ res + 1 < $ table [ $ i ] ) $ table [ $ i ] = $ res + 1 ; } } if ( $ i > $ arr [ $ n - 1 ] && $ table [ $ i ] == PHP_INT_MAX ) { $ ans = $ i ; break ; } } return $ ans ; } { $ arr = array ( 6 , 7 , 15 ) ; $ n = sizeof ( $ arr ) ; echo ( findNumber ( $ arr , $ n ) ) ; }"}
{"text": "Bilangan maksimum segmen yang boleh mengandungi mata yang diberikan | Berfungsi untuk mengembalikan bilangan maksimum segmen; Menyusun kedua -dua vektor; Pada mulanya menunjuk kepada elemen pertama B []; Cuba cari perlawanan di B []; Segmen ini berakhir sebelum B [J]; Titik terletak di dalam segmen; Segmen bermula selepas B [J]; Mengembalikan kiraan yang diperlukan; Kod pemacu", "code": "< ? php function countPoints ( $ n , $ m , $ a , $ b , $ x , $ y ) { sort ( $ a ) ; sort ( $ b ) ; $ j = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ j < $ m ) { if ( $ a [ $ i ] + $ y < $ b [ $ j ] ) break ; if ( $ b [ $ j ] >= $ a [ $ i ] - $ x && $ b [ $ j ] <= $ a [ $ i ] + $ y ) { $ count ++ ; $ j ++ ; break ; } else $ j ++ ; } } return $ count ; } $ x = 1 ; $ y = 4 ; $ a = array ( 1 , 5 ) ; $ n = count ( $ a ) ; $ b = array ( 1 , 1 , 2 ) ; $ m = count ( $ b ) ; echo countPoints ( $ n , $ m , $ a , $ b , $ x , $ y ) ; ? >"}
{"text": "Subarray terkecil yang mengandungi nilai minimum dan maksimum | Berfungsi untuk mengembalikan panjang subarray terkecil yang mengandungi nilai maksimum dan minimum; Cari nilai maksimum dan minimum dalam array; melangkah ke atas array dan tetapkan jawapan kepada perbezaan terkecil antara kedudukan maksimum dan kedudukan nilai minimum; kejadian terakhir minvalue; Kejadian terakhir MaxValue; Kod pemacu", "code": "< ? php function minSubarray ( $ A , $ n ) { $ minValue = min ( $ A ) ; $ maxValue = max ( $ A ) ; $ pos_min = -1 ; $ pos_max = -1 ; $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ A [ $ i ] == $ minValue ) $ pos_min = $ i ; if ( $ A [ $ i ] == $ maxValue ) $ pos_max = $ i ; if ( $ pos_max != -1 and $ pos_min != -1 ) $ ans = min ( $ ans , abs ( $ pos_min - $ pos_max ) + 1 ) ; } return $ ans ; } $ A = array ( 1 , 5 , 9 , 7 , 1 , 9 , 4 ) ; $ n = sizeof ( $ A ) ; echo minSubarray ( $ A , $ n ) ; ? >"}
{"text": "Bilangan minimum urutan berturut -turut yang boleh dibentuk dalam array | Program PHP Cari bilangan minimum urutan berturut -turut dalam array; Kod pemacu; fungsi panggilan untuk mencetak jawapan yang diperlukan", "code": "< ? php function countSequences ( $ arr , $ n ) { $ count = 1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] + 1 != $ arr [ $ i + 1 ] ) $ count ++ ; return $ count ; } $ arr = array ( 1 , 7 , 3 , 5 , 10 ) ; $ n = count ( $ arr ) ; echo countSequences ( $ arr , $ n ) ; ? >"}
{"text": "Bilangan minimum operasi kenaikan / penurunan sedemikian rupa sehingga array mengandungi semua elemen dari 1 hingga n | Berfungsi untuk mencari operasi minimum; Susun array yang diberikan; Mengira operasi dengan memberikan [i] = i + 1; Kod pemacu", "code": "< ? php function minimumMoves ( $ a , $ n ) { $ operations = 0 ; sort ( $ a ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ operations += abs ( $ a [ $ i ] - ( $ i + 1 ) ) ; return $ operations ; } $ arr = array ( 5 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; echo minimumMoves ( $ arr , $ n ) ; ? >"}
{"text": "Cetak kes di mana algoritma penyortiran yang diberikan gagal | Berfungsi untuk mencetak kes di mana algoritma penyortiran yang diberikan gagal; Hanya kes di mana ia gagal; Kod pemacu", "code": "< ? php function printCase ( $ n ) { if ( $ n <= 2 ) { echo ( -1 ) ; return ; } for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { echo ( $ i ) ; echo ( \" ▁ \" ) ; } } $ n = 3 ; printCase ( $ n ) ; ? >"}
{"text": "Cari unsur -unsur yang hilang dari 1 hingga m dalam julat n yang diberikan | Fungsi untuk mencari unsur -unsur yang hilang dari julat yang diberikan; Pertama sekali, semua julat yang diberikan; Simpan Ans dalam vektor yang berbeza; Prev digunakan untuk menyimpan akhir julat terakhir; J digunakan sebagai kaunter untuk julat; untuk segmen terakhir; Akhirnya cetak semua jawapan; Kod pemacu; Menyimpan julat dalam vektor pasangan", "code": "< ? php function findMissingNumber ( $ ranges , $ m ) { sort ( $ ranges ) ; $ ans = [ ] ; $ prev = 0 ; for ( $ j = 0 ; $ j < count ( $ ranges ) ; $ j ++ ) { $ start = $ ranges [ $ j ] [ 0 ] ; $ end = $ ranges [ $ j ] [ 1 ] ; for ( $ i = $ prev + 1 ; $ i < $ start ; $ i ++ ) array_push ( $ ans , $ i ) ; $ prev = $ end ; } for ( $ i = $ prev + 1 ; $ i < $ m + 1 ; $ i ++ ) array_push ( $ ans , $ i ) ; for ( $ i = 0 ; $ i < count ( $ ans ) ; $ i ++ ) { if ( $ ans [ $ i ] <= $ m ) echo \" $ ans [ $ i ] ▁ \" ; } } $ N = 2 ; $ M = 6 ; $ ranges = [ ] ; array_push ( $ ranges , [ 1 , 2 ] ) ; array_push ( $ ranges , [ 4 , 5 ] ) ; findMissingNumber ( $ ranges , $ M ) ? >"}
{"text": "Semak sama ada mungkin untuk membuat kedua -dua array sama dengan mengubahsuai satu elemen | Fungsi untuk memeriksa sama ada kedua -dua urutan boleh dibuat sama; Menyusun kedua -dua tatasusunan; Bendera untuk memberitahu jika terdapat lebih daripada satu ketidakcocokan; Untuk menyimpan indeks unsur yang tidak sesuai; Sekiranya terdapat lebih daripada satu ketidakcocokan maka kembali palsu; Sekiranya tidak ada ketidakcocokan atau perbezaan antara unsur -unsur yang tidak sepadan adalah <= k maka kembali benar; Kod pemacu", "code": "< ? php function check ( $ n , $ k , & $ a , & $ b ) { sort ( $ a ) ; sort ( $ b ) ; $ fl = False ; $ ind = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] != $ b [ $ i ] ) { if ( $ fl == True ) return False ; $ fl = True ; $ ind = $ i ; } } if ( $ ind == -1 || abs ( $ a [ $ ind ] - $ b [ $ ind ] ) <= $ k ) return True ; return False ; } $ n = 2 ; $ k = 4 ; $ a = array ( 1 , 5 ) ; $ b = array ( 1 , 1 ) ; if ( check ( $ n , $ k , $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Jumlah lebar (max dan min diff) dari semua berikutnya | Pelaksanaan PHP pendekatan di atas; Berfungsi untuk mengembalikan jumlah lebar semua subset; Susun array; Kod pemacu", "code": "< ? php $ MOD = 1000000007 ; function SubseqWidths ( & $ A , $ n ) { global $ MOD ; sort ( $ A ) ; $ pow2 = array_fill ( 0 , $ n , NULL ) ; $ pow2 [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) $ pow2 [ $ i ] = ( $ pow2 [ $ i - 1 ] * 2 ) % $ MOD ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans = ( $ ans + ( $ pow2 [ $ i ] - $ pow2 [ $ n - 1 - $ i ] ) * $ A [ $ i ] ) % $ MOD ; return $ ans ; } $ A = array ( 5 , 6 , 4 , 3 , 8 ) ; $ n = sizeof ( $ A ) ; echo SubseqWidths ( $ A , $ n ) ; ? >"}
{"text": "Meliputi elemen array maksimum dengan nilai yang diberikan | Fungsi untuk mencari nilai untuk meliputi elemen array maksimum; menyusun pelajar dalam menaik berdasarkan gula -gula; Untuk menyimpan bilangan pelajar yang gembira; Untuk menyimpan jumlah yang berjalan; Sekiranya pelajar semasa tidak dapat dibahagikan; Meningkatkan kiraan jika kita boleh membuat pelajar Ith gembira; Jika jumlah = x maka jawapannya adalah n; Jika kiraannya sama dengan n maka jawapannya ialah n - 1; kod pemacu", "code": "< ? php function maxArrayCover ( $ a , $ n , $ x ) { sort ( $ a ) ; $ cc = 0 ; $ s = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ s += $ a [ $ i ] ; if ( $ s > $ x ) { break ; } $ cc += 1 ; } if ( array_sum ( $ a ) == $ x ) { return $ n ; } else { if ( $ cc == $ n ) { return $ n - 1 ; } else { return $ cc ; } } } $ n = 3 ; $ x = 70 ; $ a = array ( 10 , 20 , 30 ) ; echo maxArrayCover ( $ a , $ n , $ x ) ; ? >"}
{"text": "Jumlah produk maksimum dua tatasusunan | Fungsi yang mengira jumlah maksimum produk dua tatasusunan; Pemboleh ubah untuk menyimpan jumlah produk unsur array; panjang tatasusunan; Menyusun kedua -dua tatasusunan; Melintasi kedua -dua tatasusunan dan mengira jumlah produk; Kod pemacu", "code": "< ? php function maximumSOP ( & $ a , & $ b ) { $ sop = 0 ; $ n = sizeof ( $ a ) ; sort ( $ a ) ; sort ( $ b ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sop = $ sop + ( $ a [ $ i ] * $ b [ $ i ] ) ; } return $ sop ; } $ A = array ( 1 , 2 , 3 ) ; $ B = array ( 4 , 5 , 1 ) ; echo maximumSOP ( $ A , $ B ) ; ? >"}
{"text": "Kira bilangan tiga kali ganda dengan produk yang sama dengan nombor yang diberikan | Tetapkan 2 | Berfungsi untuk mengira tiga kali ganda; Susun array; teknik tiga penunjuk; Kirakan produk triplet; Semak sama ada produk itu lebih besar daripada m, pengurangan pertengahan; Semak sama ada produk itu lebih kecil daripada m, permulaan kenaikan; Semak sama ada produk itu sama dengan m, penurunan pertengahan, permulaan kenaikan dan kenaikan kiraan pasangan; Kod pemandu", "code": "< ? php function countTriplets ( $ arr , $ n , $ m ) { $ count = 0 ; sort ( $ arr ) ; $ end ; $ start ; $ mid ; for ( $ end = $ n - 1 ; $ end >= 2 ; $ end -- ) { $ start = 0 ; $ mid = $ end - 1 ; while ( $ start < $ mid ) { $ prod = $ arr [ $ end ] * $ arr [ $ start ] * $ arr [ $ mid ] ; if ( $ prod > $ m ) $ mid -- ; else if ( $ prod < $ m ) $ start ++ ; else if ( $ prod == $ m ) { $ count ++ ; $ mid -- ; $ start ++ ; } } } return $ count ; } $ arr = array ( 1 , 1 , 1 , 1 , 1 , 1 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; $ m = 1 ; echo countTriplets ( $ arr , $ n , $ m ) ; #This  Code is Contributed by ajit NEW_LINE ? >"}
{"text": "Susun 3 nombor | Program PHP untuk menyusun pelbagai saiz 3; Masukkan arr [1]; Masukkan arr [2]; Kod pemacu", "code": "< ? php function sort3 ( & $ arr , $ temp ) { if ( $ arr [ 1 ] < $ arr [ 0 ] ) { $ temp [ 0 ] = $ arr [ 0 ] ; $ arr [ 0 ] = $ arr [ 1 ] ; $ arr [ 1 ] = $ temp [ 0 ] ; } if ( $ arr [ 2 ] < $ arr [ 1 ] ) { $ temp [ 0 ] = $ arr [ 1 ] ; $ arr [ 1 ] = $ arr [ 2 ] ; $ arr [ 2 ] = $ temp [ 0 ] ; } if ( $ arr [ 1 ] < $ arr [ 0 ] ) { $ temp [ 0 ] = $ arr [ 0 ] ; $ arr [ 0 ] = $ arr [ 1 ] ; $ arr [ 1 ] = $ temp [ 0 ] ; } } $ a = array ( 10 , 12 , 5 ) ; $ temp1 = array ( 10 ) ; sort3 ( $ a , $ temp1 ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) echo ( $ a [ $ i ] . \" ▁ \" ) ; ? >"}
{"text": "Cetak tiga kali ganda dengan jumlah kurang daripada k | Program PHP untuk mencetak tiga dengan jumlah yang lebih kecil daripada nilai tertentu; Susun array input; Setiap lelaran gelung mengira triplet dengan elemen pertama sebagai arr [i]. ; Mulakan dua elemen lain sebagai elemen sudut Subarray Arr [J + 1. k]; Gunakan bertemu dalam konsep tengah; Jika jumlah triplet semasa lebih atau sama, gerakkan sudut kanan untuk mencari nilai yang lebih kecil; Lain bergerak sudut kiri; Ini penting. Untuk semasa I dan J, terdapat jumlah elemen ketiga k - J. ; Kod pemacu", "code": "< ? php function printTriplets ( $ arr , $ n , $ sum ) { sort ( $ arr , 0 ) ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { $ j = $ i + 1 ; $ k = $ n - 1 ; while ( $ j < $ k ) { if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] >= $ sum ) $ k -- ; else { for ( $ x = $ j + 1 ; $ x <= $ k ; $ x ++ ) echo $ arr [ $ i ] . \" , \" ▁ . ▁ $ arr [ $ j ] ▁ . STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL \" , \" ▁ . ▁ $ arr [ $ x ] ▁ . ▁ \" \" $ j ++ ; } } } } $ arr = array ( 5 , 1 , 3 , 4 , 7 ) ; $ n = sizeof ( $ arr ) ; $ sum = 12 ; printTriplets ( $ arr , $ n , $ sum ) ; ? >"}
{"text": "Semak sama ada array boleh dimuatkan ke dalam array lain yang menyusun semula unsur -unsur dalam array | Pulangan benar jika array boleh masuk ke dalam array b, jika tidak palsu; Menyusun kedua -dua tatasusunan; Melangkah ke atas gelung dan periksa sama ada setiap elemen array A adalah kurang daripada atau sama dengan elemen array yang sepadan dengan B; Kod pemacu", "code": "< ? php function checkFittingArrays ( $ A , $ B , $ N ) { sort ( $ A ) ; sort ( $ B ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ A [ $ i ] > $ B [ $ i ] ) return false ; return true ; } $ A = array ( 7 , 5 , 3 , 2 ) ; $ B = array ( 5 , 4 , 8 , 7 ) ; $ N = count ( $ A ) ; if ( checkFittingArrays ( $ A , $ B , $ N ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Memaksimumkan bilangan mainan yang boleh dibeli dengan jumlah k | Fungsi ini mengembalikan bilangan mainan yang diperlukan; Susun array kos; Semak jika kita boleh membeli mainan ith atau tidak; Kenaikan pembolehubah kiraan; Kod pemacu", "code": "< ? php function maximum_toys ( $ cost , $ N , $ K ) { $ count = 0 ; $ sum = 0 ; sort ( $ cost ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ sum + $ cost [ $ i ] <= $ K ) { $ sum = $ sum + $ cost [ $ i ] ; $ count ++ ; } } return $ count ; } $ K = 50 ; $ cost = array ( 1 , 12 , 5 , 111 , 200 , 1000 , 10 , 9 , 12 , 15 ) ; $ N = count ( $ cost ) ; echo maximum_toys ( $ cost , $ N , $ K ) , \" STRNEWLINE \" ; ? >"}
{"text": "Semak jika array yang diberikan hampir disusun (unsur -unsur berada di | berfungsi untuk memeriksa hampir semacam; satu demi satu membandingkan selebaran", "code": "< ? php function almostSort ( $ A , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ A [ $ i ] > $ A [ $ i + 1 ] ) { list ( $ A [ $ i ] , $ A [ $ i + 1 ] ) = array ( $ A [ $ i + 1 ] , $ A [ $ i ] ) ; $ i ++ ; } } for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ A [ $ i ] > $ A [ $ i + 1 ] ) return false ; return true ; } $ A = array ( 1 , 3 , 2 , 4 , 6 , 5 ) ; $ n = sizeof ( $ A ) ; if ( almostSort ( $ A , $ n ) ) echo \" Yes \" , \" STRNEWLINE \" ; else echo \" Yes \" , \" STRNEWLINE \" ; ? >"}
{"text": "Dengan cekap menggabungkan dua susunan yang disusun dengan O (1) ruang tambahan | Fungsi untuk mencari jurang seterusnya. ; Membandingkan unsur -unsur dalam array pertama. ; Membandingkan elemen dalam kedua -dua tatasusunan. ; Membandingkan unsur -unsur dalam array kedua. ; Kod pemacu; Panggilan fungsi", "code": "< ? php function nextGap ( $ gap ) { if ( $ gap <= 1 ) return 0 ; return ( $ gap / 2 ) + ( $ gap % 2 ) ; } function merge ( $ arr1 , $ arr2 , $ n , $ m ) { $ i ; $ j ; $ gap = $ n + $ m ; for ( $ gap = nextGap ( $ gap ) ; $ gap > 0 ; $ gap = nextGap ( $ gap ) ) { for ( $ i = 0 ; $ i + $ gap < $ n ; $ i ++ ) if ( $ arr1 [ $ i ] > $ arr1 [ $ i + $ gap ] ) { $ tmp = $ arr1 [ $ i ] ; $ arr1 [ $ i ] = $ arr1 [ $ i + $ gap ] ; $ arr1 [ $ i + $ gap ] = $ tmp ; } for ( $ j = $ gap > $ n ? $ gap - $ n : 0 ; $ i < $ n && $ j < $ m ; $ i ++ , $ j ++ ) if ( $ arr1 [ $ i ] > $ arr2 [ $ j ] ) { $ tmp = $ arr1 [ $ i ] ; $ arr1 [ $ i ] = $ arr2 [ $ j ] ; $ arr2 [ $ j ] = $ tmp ; } if ( $ j < $ m ) { for ( $ j = 0 ; $ j + $ gap < $ m ; $ j ++ ) if ( $ arr2 [ $ j ] > $ arr2 [ $ j + $ gap ] ) { $ tmp = $ arr2 [ $ j ] ; $ arr2 [ $ j ] = $ arr2 [ $ j + $ gap ] ; $ arr2 [ $ j + $ gap ] = $ tmp ; } } } echo \" First ▁ Array : ▁ \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr1 [ $ i ] . \" ▁ \" ; echo \" Second Array : \" for ( $ i = 0 ; $ i < $ m ; $ i ++ ) echo $ arr2 [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } $ a1 = array ( 10 , 27 , 38 , 43 , 82 ) ; $ a2 = array ( 3 , 9 ) ; $ n = sizeof ( $ a1 ) ; $ m = sizeof ( $ a2 ) ; merge ( $ a1 , $ a2 , $ n , $ m ) ; ? >"}
{"text": "Gabungkan dua susunan yang disusun | Gabungkan $ ARR1 [0. .. $ n1 - 1] dan $ ARR2 [0. .. $ n2 - 1] ke $ ARR3 [0. .. $ n1 + $ n2 - 1]; Melintasi kedua -dua array; Semak jika elemen semasa array pertama lebih kecil daripada elemen semasa array kedua. Jika ya, simpan elemen array pertama dan indeks array pertama kenaikan. Jika tidak, lakukan sama dengan array kedua; Menyimpan elemen baki array pertama; Menyimpan elemen baki array kedua; Kod pemacu", "code": "< ? php function mergeArrays ( & $ arr1 , & $ arr2 , $ n1 , $ n2 , & $ arr3 ) { $ i = 0 ; $ j = 0 ; $ k = 0 ; while ( $ i < $ n1 && $ j < $ n2 ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) $ arr3 [ $ k ++ ] = $ arr1 [ $ i ++ ] ; else $ arr3 [ $ k ++ ] = $ arr2 [ $ j ++ ] ; } while ( $ i < $ n1 ) $ arr3 [ $ k ++ ] = $ arr1 [ $ i ++ ] ; while ( $ j < $ n2 ) $ arr3 [ $ k ++ ] = $ arr2 [ $ j ++ ] ; } $ arr1 = array ( 1 , 3 , 5 , 7 ) ; $ n1 = sizeof ( $ arr1 ) ; $ arr2 = array ( 2 , 4 , 6 , 8 ) ; $ n2 = sizeof ( $ arr2 ) ; $ arr3 [ $ n1 + $ n2 ] = array ( ) ; mergeArrays ( $ arr1 , $ arr2 , $ n1 , $ n2 , $ arr3 ) ; echo \" Array ▁ after ▁ merging ▁ STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n1 + $ n2 ; $ i ++ ) echo $ arr3 [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Masalah Pengedaran Coklat | Arr [0.. N - 1] mewakili saiz paket m adalah bilangan pelajar. Mengembalikan perbezaan minimum antara nilai maksimum dan minimum pengedaran. ; Sekiranya tidak ada coklat atau bilangan pelajar ialah 0; Menyusun paket yang diberikan; Bilangan pelajar tidak boleh lebih daripada bilangan paket; Bilangan coklat terbesar; Cari subarray saiz m seperti perbezaan antara yang terakhir (maksimum dalam kes disusun) dan pertama (minimum dalam kes disusun) unsur -unsur subarray adalah minimum. ; Kod pemacu; $ m = 7; Bilangan pelajar", "code": "< ? php function findMinDiff ( $ arr , $ n , $ m ) { if ( $ m == 0 $ n == 0 ) return 0 ; sort ( $ arr ) ; if ( $ n < $ m ) return -1 ; $ min_diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i + $ m - 1 < $ n ; $ i ++ ) { $ diff = $ arr [ $ i + $ m - 1 ] - $ arr [ $ i ] ; if ( $ diff < $ min_diff ) $ min_diff = $ diff ; } return $ min_diff ; } $ arr = array ( 12 , 4 , 7 , 9 , 2 , 23 , 25 , 41 , 30 , 40 , 28 , 42 , 30 , 44 , 48 , 43 , 50 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum ▁ difference ▁ is ▁ \" , findMinDiff ( $ arr , $ n , $ m ) ; ? >"}
{"text": "Kiraan mutlak yang berbeza dalam array yang disusun | Fungsi ini mengembalikan bilangan nilai mutlak yang berbeza di antara unsur -unsur array; memulakan kiraan sebagai bilangan elemen; Keluarkan elemen pendua dari sebelah kiri tetingkap semasa (i, j) dan juga mengurangkan kiraan; Keluarkan elemen pendua dari kanan tetingkap semasa (i, j) dan juga mengurangkan kiraan; Break jika hanya satu elemen yang tersisa; Sekarang cari pasangan sifar dalam tetingkap semasa (i, j); mengurangkan kiraan jika pasangan (positif, negatif) ditemui; Kod pemacu", "code": "< ? php function distinctCount ( $ arr , $ n ) { $ count = $ n ; $ i = 0 ; $ j = $ n - 1 ; $ sum = 0 ; while ( $ i < $ j ) { while ( $ i != $ j && $ arr [ $ i ] == $ arr [ $ i + 1 ] ) { $ count -- ; $ i ++ ; } while ( $ i != $ j && $ arr [ $ j ] == $ arr [ $ j - 1 ] ) { $ count -- ; $ j -- ; } if ( $ i == $ j ) break ; $ sum = $ arr [ $ i ] + $ arr [ $ j ] ; if ( $ sum == 0 ) { $ count -- ; $ i ++ ; $ j -- ; } else if ( $ sum < 0 ) $ i ++ ; else $ j -- ; } return $ count ; } $ arr = array ( -2 , -1 , 0 , 1 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Count ▁ of ▁ absolute ▁ distinct ▁ values ▁ : ▁ \" . distinctCount ( $ arr , $ n ) ; ? >"}
{"text": "Sort array yang hampir disusun di mana hanya dua elemen yang ditukar | Fungsi ini menyusun array yang boleh disusun dengan swap tunggal; Melintasi array yang diberikan dari sebelah kanan; Semak jika Arr [i] tidak teratur; Cari elemen lain untuk ditukar dengan arr [i]; Tukar pasangan; Fungsi utiliti untuk mencetak pelbagai saiz n; Kod pemacu", "code": "< ? php function sortByOneSwap ( & $ arr , $ n ) { for ( $ i = $ n - 1 ; $ i > 0 ; $ i -- ) { if ( $ arr [ $ i ] < $ arr [ $ i - 1 ] ) { $ j = $ i - 1 ; while ( $ j >= 0 && $ arr [ $ i ] < $ arr [ $ j ] ) $ j -- ; $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j + 1 ] ; $ arr [ $ j + 1 ] = $ temp ; break ; } } } function printArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 10 , 30 , 20 , 40 , 50 , 60 , 70 ) ; $ n = sizeof ( $ arr ) ; echo \" Given ▁ array ▁ is ▁ \" . \" STRNEWLINE \" ; printArray ( $ arr , $ n ) ; sortByOneSwap ( $ arr , $ n ) ; echo \" Sorted ▁ array ▁ is ▁ \" . \" STRNEWLINE \" ; printArray ( $ arr , $ n ) ;"}
{"text": "Penyusunan Pancake | Membalikkan ARR [0 .. i]; Mengembalikan indeks elemen maksimum dalam ARR [0 .. n - 1]; Fungsi utama yang disusun dengan pelbagai menggunakan operasi flip; Mulakan dari array lengkap dan satu demi satu mengurangkan saiz semasa dengan satu; Cari indeks elemen maksimum dalam ARR [0 .. curr_size - 1]; Gerakkan elemen maksimum ke hujung array semasa jika ia belum selesai; Untuk bergerak pada akhir, gerakkan nombor maksimum pertama ke permulaan; Sekarang gerakkan nombor maksimum hingga berakhir dengan membalikkan array semasa; Fungsi utiliti untuk mencetak nasi saiz n; Kod pemacu", "code": "< ? php function flip ( & $ arr , $ i ) { $ start = 0 ; while ( $ start < $ i ) { $ temp = $ arr [ $ start ] ; $ arr [ $ start ] = $ arr [ $ i ] ; $ arr [ $ i ] = $ temp ; $ start ++ ; $ i -- ; } } function findMax ( $ arr , $ n ) { $ mi = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) if ( $ arr [ $ i ] > $ arr [ $ mi ] ) $ mi = $ i ; return $ mi ; } function pancakeSort ( & $ arr , $ n ) { for ( $ curr_size = $ n ; $ curr_size > 1 ; -- $ curr_size ) { $ mi = findMax ( $ arr , $ curr_size ) ; if ( $ mi != $ curr_size - 1 ) { flip ( $ arr , $ mi ) ; flip ( $ arr , $ curr_size -1 ) ; } } } function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) print ( $ arr [ $ i ] . \" ▁ \" ) ; } $ arr = array ( 23 , 10 , 20 , 11 , 12 , 6 , 7 ) ; $ n = count ( $ arr ) ; pancakeSort ( $ arr , $ n ) ; echo ( \" Sorted ▁ Array ▁ STRNEWLINE \" ) ; printArray ( $ arr , $ n ) ; return 0 ; ? >"}
{"text": "Memaksimumkan nombor yang diberikan dengan menggantikan segmen digit dengan digit alternatif yang diberikan | Pelaksanaan PHP fungsi pendekatan untuk mengembalikan nombor yang dimaksimumkan; Iterat hingga akhir rentetan; Periksa sama ada ia lebih besar atau tidak; Gantikan dengan ganti sehingga lebih kecil; Mengembalikan asal S sekiranya tiada perubahan berlaku; Kod pemacu; Kod ini disumbangkan adalah tushill.", "code": "< ? php function get_maximum ( $ s , $ a ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] - '0' < $ a [ $ s [ $ i ] - '0' ] ) { $ j = $ i ; while ( $ j < $ n && ( $ s [ $ j ] - '0' <= $ a [ $ s [ $ j ] - '0' ] ) ) { $ s [ $ j ] = '0' + $ a [ $ s [ $ j ] - '0' ] ; $ j ++ ; } return $ s ; } } return $ s ; } $ s = \"1337\" ; $ a = array ( 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 ) ; echo get_maximum ( $ s , $ a ) ; ? >"}
{"text": "Bilangan kali nombor persegi sempurna terbesar boleh dikurangkan dari n | Berfungsi untuk mengembalikan kiraan langkah; Pembolehubah untuk menyimpan kiraan langkah; Berulang sementara n> 0; Dapatkan persegi sempurna terbesar dan tolaknya dari N; Langkah kenaikan; Mengembalikan kiraan yang diperlukan; Kod pemacu", "code": "< ? php function countSteps ( $ n ) { $ steps = 0 ; while ( $ n ) { $ largest = ( int ) sqrt ( $ n ) ; $ n -= ( $ largest * $ largest ) ; $ steps ++ ; } return $ steps ; } $ n = 85 ; echo countSteps ( $ n ) ; ? >"}
{"text": "Jumlah array maksimum yang boleh diperolehi selepas perubahan tepat k | Fungsi utiliti untuk mengembalikan jumlah elemen array; Berfungsi untuk mengembalikan jumlah yang dimaksimumkan array selepas melakukan operasi yang diberikan tepat kali K; Susun unsur -unsur array; Tukar tanda -tanda unsur -unsur negatif bermula dari yang terkecil; Sekiranya satu operasi perlu dilakukan maka ia mesti dilakukan pada elemen positif terkecil; Untuk menyimpan indeks elemen minimum; Mengemas kini indeks minimum; Melakukan operasi yang tinggal pada elemen terkecil; Kembalikan jumlah array yang dikemas kini; Kod pemacu", "code": "< ? php function sumArr ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; return $ sum ; } function maxSum ( $ arr , $ n , $ k ) { sort ( $ arr ) ; $ i = 0 ; while ( $ i < $ n && $ k > 0 && $ arr [ $ i ] < 0 ) { $ arr [ $ i ] *= -1 ; $ k -- ; $ i ++ ; } if ( $ k % 2 == 1 ) { $ min = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ min ] > $ arr [ $ i ] ) $ min = $ i ; $ arr [ $ min ] *= -1 ; } return sumArr ( $ arr , $ n ) ; } $ arr = array ( -5 , 4 , 1 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; $ k = 4 ; echo maxSum ( $ arr , $ n , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text": "Memandangkan kiraan digit 1, 2, 3, 4, cari jumlah maksimum yang mungkin | Berfungsi untuk mencari jumlah maksimum yang mungkin; Untuk menyimpan jumlah yang diperlukan; Bilangan 234 boleh dibentuk; Jumlah yang diperoleh dengan 234 s; Baki 2 s; Jumlah yang diperoleh dengan 12 s; Mengembalikan jumlah yang diperlukan; Kod pemacu", "code": "< ? php function Maxsum ( $ c1 , $ c2 , $ c3 , $ c4 ) { $ sum = 0 ; $ two34 = min ( $ c2 , min ( $ c3 , $ c4 ) ) ; $ sum = $ two34 * 234 ; $ c2 -= $ two34 ; $ sum += min ( $ c2 , $ c1 ) * 12 ; return $ sum ; } $ c1 = 5 ; $ c2 = 2 ; $ c3 = 3 ; $ c4 = 4 ; echo Maxsum ( $ c1 , $ c2 , $ c3 , $ c4 ) ; ? >"}
{"text": "Count pasangan dari 1 hingga a dan 1 hingga b yang jumlahnya boleh dibahagikan dengan n | Fungsi untuk mencari pasangan yang berbeza dari 1 - A & 1 - B supaya jumlahnya dapat dibahagikan dengan n. ; pasangan dari 1 hingga n * (a / n) dan 1 hingga n * (b / n); pasangan dari 1 hingga n * (a / n) dan n * (b / n) hingga b; pasangan dari n * (a / n) hingga a dan 1 hingga n * (b / n); pasangan dari n * (a / n) ke a dan n * (b / n) ke b; Jawapan kembali; Kod pemacu", "code": "< ? php function findCountOfPairs ( $ a , $ b , $ n ) { $ ans = 0 ; $ ans += $ n * ( int ) ( $ a / $ n ) * ( int ) ( $ b / $ n ) ; $ ans += ( int ) ( $ a / $ n ) * ( $ b % $ n ) ; $ ans += ( $ a % $ n ) * ( int ) ( $ b / $ n ) ; $ ans += ( ( $ a % $ n ) + ( int ) ( $ b % $ n ) ) / $ n ; return $ ans ; } $ a = 5 ; $ b = 13 ; $ n = 3 ; echo findCountOfPairs ( $ a , $ b , $ n ) ; ? >"}
{"text": "Menjana array dengan jumlah minimum yang boleh dipadam dalam langkah p | Fungsi untuk mencari array yang diperlukan; mengira jumlah minimum yang mungkin; Array; Letakkan unsur -unsur semulajadi pertama; Isi unsur -unsur dengan 1; Kod pemacu", "code": "< ? php function findArray ( $ N , $ P ) { $ ans = ( $ P * ( $ P + 1 ) ) / 2 + ( $ N - $ P ) ; $ arr [ $ N + 1 ] = array ( ) ; for ( $ i = 1 ; $ i <= $ P ; $ i ++ ) $ arr [ $ i ] = $ i ; for ( $ i = $ P + 1 ; $ i <= $ N ; $ i ++ ) $ arr [ $ i ] = 1 ; echo \" The ▁ Minimum ▁ Possible ▁ Sum ▁ is : ▁ \" , $ ans , \" STRNEWLINE \" ; echo \" The ▁ Array ▁ Elements ▁ are : ▁ STRNEWLINE \" ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ arr [ $ i ] , ' ▁ ' ; } $ N = 5 ; $ P = 3 ; findArray ( $ N , $ P ) ; ? >"}
{"text": "Cari persimpangan semua selang | Berfungsi untuk mencetak persimpangan; Selang pertama; Semak selang selang dan cari persimpangan; Jika tiada persimpangan; Lain mengemas kini persimpangan; Kod pemacu", "code": "< ? php function findIntersection ( $ intervals , $ N ) { $ l = $ intervals [ 0 ] [ 0 ] ; $ r = $ intervals [ 0 ] [ 1 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { if ( $ intervals [ $ i ] [ 0 ] > $ r $ intervals [ $ i ] [ 1 ] < $ l ) { echo - 1 ; return ; } else { $ l = max ( $ l , $ intervals [ $ i ] [ 0 ] ) ; $ r = min ( $ r , $ intervals [ $ i ] [ 1 ] ) ; } } echo \" [ \" ▁ . ▁ $ l ▁ . ▁ \" , \" ▁ . ▁ $ r ▁ . ▁ \" ] \" ; } $ intervals = array ( array ( 1 , 6 ) , array ( 2 , 8 ) , array ( 3 , 10 ) , array ( 5 , 8 ) ) ; $ N = sizeof ( $ intervals ) ; findIntersection ( $ intervals , $ N ) ; ? >"}
{"text": "Saiz maksimum sub | Fungsi yang membandingkan A dan B; Berfungsi untuk mengembalikan panjang subarray terpanjang yang memenuhi salah satu syarat yang diberikan; Kod pemacu; Cetak jawapan yang diperlukan", "code": "< ? php function cmp ( $ a , $ b ) { return ( $ a > $ b ) - ( $ a < $ b ) ; } function maxSubarraySize ( $ arr ) { $ N = sizeof ( $ arr ) ; $ ans = 1 ; $ anchor = 0 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ c = cmp ( $ arr [ $ i - 1 ] , $ arr [ $ i ] ) ; if ( $ c == 0 ) $ anchor = $ i ; else if ( $ i == $ N - 1 or $ c * cmp ( $ arr [ $ i ] , $ arr [ $ i + 1 ] ) != -1 ) { $ ans = max ( $ ans , $ i - $ anchor + 1 ) ; $ anchor = $ i ; } } return $ ans ; } $ arr = array ( 9 , 4 , 2 , 10 , 7 , 8 , 8 , 1 , 9 ) ; echo maxSubarraySize ( $ arr ) ; ? >"}
{"text": "Kira pasangan yang sah dalam pelbagai keadaan yang memuaskan | Berfungsi untuk mengembalikan jumlah pasangan yang sah; Memulakan kiraan semua elemen; kiraan kekerapan semua elemen; Tambah jumlah pasangan yang sah; Tidak termasuk pasangan yang dibuat dengan satu elemen i. e. (x, x); Kod pemacu; Fungsi panggilan untuk mencetak jawapan yang diperlukan", "code": "< ? php function ValidPairs ( $ arr , $ n ) { $ count = array_fill ( 0 , 121 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ $ arr [ $ i ] ] += 1 ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) continue ; if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) % 2 == 1 ) continue ; $ ans += $ count [ $ arr [ $ i ] ] * $ count [ $ arr [ $ j ] ] ; if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ ans -= $ count [ $ arr [ $ i ] ] ; } return $ ans ; } $ arr = array ( 16 , 17 , 18 ) ; $ n = count ( $ arr ) ; echo ( ValidPairs ( $ arr , $ n ) ) ; ? >"}
{"text": "Bilangan minimum 1 akan digantikan dalam array binari | Fungsi untuk mencari bilangan minimum 1 s '»digantikan ~ ~» s; kembali jawapan akhir; Kod pemacu", "code": "< ? php function minChanges ( $ A , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; ++ $ i ) { if ( ( $ i - 1 >= 0 ) && $ A [ $ i - 1 ] == 1 && $ A [ $ i + 1 ] == 1 && $ A [ $ i ] == 0 ) { $ A [ $ i + 1 ] = 0 ; $ cnt ++ ; } } return $ cnt ; } $ A = array ( 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ) ; $ n = sizeof ( $ A ) ; echo minChanges ( $ A , $ n ) ; ? >"}
{"text": "Bilangan kurungan penutup yang diperlukan untuk melengkapkan urutan kurungan biasa | Berfungsi untuk mencari bilangan kurungan penutup dan melengkapkan urutan kurungan biasa; Mencari panjang urutan; Mengira kurungan pembukaan; Mengira kurungan penutup; Memeriksa jika di mana -mana kedudukan bilangan pendakap penutup lebih banyak maka jawapannya adalah mustahil; Jika boleh, cetak 'dan memerlukan kurungan penutupan. ; Kod pemacu", "code": "< ? php function completeSequence ( $ s ) { $ n = strlen ( $ s ) ; $ open = 0 ; $ close = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' ( ' ) $ open ++ ; else $ close ++ ; if ( $ close > $ open ) { echo ( \" IMPOSSIBLE \" ) ; return ; } } echo ( $ s ) ; for ( $ i = 0 ; $ i < $ open - $ close ; $ i ++ ) echo ( \" ) \" ) ; } $ s = \" ( ( ) ( ( ) ( \" ; completeSequence ( $ s ) ; ? >"}
{"text": "Permutasi terkecil lexicographically tanpa digit pada indeks asal | Berfungsi untuk mencetak permutasi terkecil; Apabila n adalah walaupun; Apabila n adalah ganjil; mengendalikan 3 digit terakhir; Tambah EOL dan hasil cetak; Kod pemacu", "code": "< ? php function smallestPermute ( $ n ) { $ res = array_fill ( 0 , $ n + 1 , \" \" ) ; if ( $ n % 2 == 0 ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ res [ $ i ] = chr ( 48 + $ i + 2 ) ; else $ res [ $ i ] = chr ( 48 + $ i ) ; } } else { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { if ( $ i % 2 == 0 ) $ res [ $ i ] = chr ( 48 + $ i + 2 ) ; else $ res [ $ i ] = chr ( 48 + $ i ) ; } $ res [ $ n - 1 ] = chr ( 48 + $ n - 2 ) ; $ res [ $ n - 2 ] = chr ( 48 + $ n ) ; $ res [ $ n - 3 ] = chr ( 48 + $ n - 1 ) ; } $ res [ $ n ] = ' \\0' ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ res [ $ i ] ; } } $ n = 7 ; smallestPermute ( $ n ) ; ? >"}
{"text": "Sisipan array minimum diperlukan untuk membuat perbezaan berturut -turut <= k | Berfungsi untuk mengembalikan bilangan sisipan minimum yang diperlukan; Memulakan penyisipan ke 0; mengembalikan jumlah penyisipan; Kod pemacu", "code": "< ? php function minInsertions ( $ H , $ n , $ K ) { $ inser = 0 ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) { $ diff = abs ( $ H [ $ i ] - $ H [ $ i - 1 ] ) ; if ( $ diff <= $ K ) continue ; else $ inser += ceil ( $ diff / $ K ) - 1 ; } return $ inser ; } $ H = array ( 2 , 4 , 8 , 16 ) ; $ K = 3 ; $ n = sizeof ( $ H ) ; echo minInsertions ( $ H , $ n , $ K ) ; ? >"}
{"text": "Bilangan minimum operasi yang diperlukan untuk mengurangkan n hingga 1 | Fungsi yang mengembalikan bilangan minimum operasi yang akan dilakukan untuk mengurangkan nombor kepada 1; Untuk menyimpan jumlah operasi yang akan dilakukan; Jika n boleh dibahagikan dengan 3 maka kurangkannya kepada n / 3; Jika n modulo 3 adalah 1 penurunannya dengan 1; Jika n Modulo 3 adalah 2 maka kenaikannya dengan 1; mengemas kini kaunter; Kod pemacu", "code": "< ? php function count_minimum_operations ( $ n ) { $ count = 0 ; while ( $ n > 1 ) { if ( $ n % 3 == 0 ) $ n /= 3 ; else if ( $ n % 3 == 1 ) $ n -- ; else { if ( $ n == 2 ) $ n -- ; else $ n ++ ; } $ count ++ ; } return $ count ; } $ n = 4 ; $ ans = count_minimum_operations ( $ n ) ; echo $ ans , \" STRNEWLINE \" ; ? >"}
{"text": "Memaksimumkan jumlah array dengan mengalikan awalan array dengan | Pelaksanaan PHP pendekatan; Untuk menyimpan jumlah; Untuk menyimpan indeks akhir tatasusunan awalan yang dipilih; Menambah nilai mutlak [i]; Jika i == 0 maka tidak ada indeks yang akan dibalikkan (i - 1) kedudukan; Cetak jumlah yang dimaksimumkan; Cetak indeks akhir tatasusunan awalan yang dipilih; Kod pemacu", "code": "< ? php function maxSum ( $ a , $ n ) { $ s = 0 ; $ l = array ( ) ; for ( $ i = 0 ; $ i < count ( $ a ) ; $ i ++ ) { $ s += abs ( $ a [ $ i ] ) ; if ( $ a [ $ i ] >= 0 ) continue ; if ( $ i == 0 ) array_push ( $ l , $ i + 1 ) ; else { array_push ( $ l , $ i + 1 ) ; array_push ( $ l , $ i ) ; } } echo $ s . \" STRNEWLINE \" ; for ( $ i = 0 ; $ i < count ( $ l ) ; $ i ++ ) echo $ l [ $ i ] . \" ▁ \" ; } $ n = 4 ; $ a = array ( 1 , -2 , -3 , 4 ) ; maxSum ( $ a , $ n ) ; ? >"}
{"text": "Cari awalan biasa terpanjang antara dua rentetan selepas melakukan swap pada rentetan kedua | Program PHP untuk mencari awalan umum terpanjang antara dua rentetan selepas melakukan swap pada rentetan kedua; $ a = strlen ($ x); panjang x $ b = strlen ($ y); panjang y; mewujudkan pelbagai frekuensi aksara y; menyimpan panjang awalan biasa terpanjang; Memeriksa jika kekerapan aksara pada kedudukan i dalam x dalam b adalah lebih besar daripada sifar atau tidak jika sifar kita meningkatkan kiraan awalan sebanyak 1; Kod pemacu", "code": "< ? php function LengthLCP ( $ x , $ y ) { $ fr = array_fill ( 0 , 26 , NULL ) ; for ( $ i = 0 ; $ i < $ b ; $ i ++ ) { $ fr [ ord ( $ y [ $ i ] ) - 97 ] += 1 ; } $ c = 0 ; for ( $ i = 0 ; $ i < $ a ; $ i ++ ) { if ( $ fr [ ord ( $ x [ $ i ] ) - 97 ] > 0 ) { $ c += 1 ; $ fr [ ord ( $ x [ $ i ] ) - 97 ] -= 1 ; } else break ; } echo $ c ; } $ x = \" here \" ; $ y = \" there \" ; LengthLCP ( $ x , $ y ) ; return 0 ; ? >"}
{"text": "Semua kemungkinan Co | Fungsi untuk mengira pasangan yang mungkin; Jumlah kiraan nombor dalam julat; mencetak kiraan pasangan; Kod pemacu", "code": "< ? php function CountPair ( $ L , $ R ) { $ x = ( $ R - $ L + 1 ) ; echo $ x / 2 , \" STRNEWLINE \" ; } $ L = 1 ; $ R = 8 ; CountPair ( $ L , $ R ) ; ? >"}
{"text": "Masalah tidak diselesaikan pada akhir hari n | Fungsi untuk mencari masalah yang tidak diselesaikan pada akhir hari ke hari; Kod pemacu", "code": "< ? php function problemsLeft ( $ K , $ P , $ N ) { if ( $ K <= $ P ) return 0 ; else return ( $ K - $ P ) * $ N ; } $ K = 4 ; $ P = 1 ; $ N = 10 ; echo problemsLeft ( $ K , $ P , $ N ) ; ? >"}
{"text": "Bilangan coklat yang ditinggalkan selepas k -lelaran | Berfungsi untuk mencari coklat yang tersisa; Kod pemacu", "code": "< ? php function results ( $ n , $ k ) { return round ( pow ( $ n , ( 1.0 / pow ( 2 , $ k ) ) ) ) ; } $ k = 3 ; $ n = 100000000 ; echo ( \" Chocolates ▁ left ▁ after ▁ \" ) ; echo ( $ k ) ; echo ( \" ▁ iterations ▁ are ▁ \" ) ; echo ( results ( $ n , $ k ) ) ; ? >"}
{"text": "Buat elemen array sama dengan langkah minimum | Mengembalikan langkah -langkah minimum yang diperlukan untuk membuat pelbagai elemen N sama, di mana elemen array pertama sama dengan m; Sudut Kes 1: Apabila n = 1; Sudut Kasus 2: Apabila N = 2 Lain Jika ($ n == 2) Corner Case 2; Kod pemacu", "code": "< ? php function steps ( $ N , $ M ) { if ( $ N == 1 ) return 0 ; return $ M ; return 2 * $ M + ( $ N - 3 ) ; } $ N = 4 ; $ M = 4 ; echo steps ( $ N , $ M ) ; ? >"}
{"text": "Semak jika mungkin untuk bertahan di Pulau | Berfungsi untuk mencari minimum $ hari; Sekiranya kita tidak dapat membeli sekurang -kurangnya seminggu bekalan makanan pada minggu pertama atau kita tidak dapat membeli bekalan makanan pada hari pertama maka kita tidak dapat bertahan. ; Jika kita dapat bertahan maka kita boleh membeli ceil (a / n) kali di mana A adalah jumlah unit makanan yang diperlukan. ; Kod pemacu", "code": "< ? php function survival ( $ S , $ N , $ M ) { if ( ( ( $ N * 6 ) < ( $ M * 7 ) && $ S > 6 ) $ M > $ N ) echo \" No \" ; else { $ days = ( $ M * $ S ) / $ N ; if ( ( ( $ M * $ S ) % $ N ) != 0 ) $ days ++ ; echo \" Yes ▁ \" , floor ( $ days ) ; } } $ S = 10 ; $ N = 16 ; $ M = 2 ; survival ( $ S , $ N , $ M ) ; ? >"}
