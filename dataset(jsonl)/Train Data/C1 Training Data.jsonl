{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengira bit set dalam n", "code": "void count_setbit ( int N ) {"}
{"text": "Kedai kiraan bit set di n", "code": "int result = 0 ;"}
{"text": "Melangkah ke julat [0, 31]", "code": "for ( int i = 0 ; i < 32 ; i ++ ) {"}
{"text": "Sekiranya bit semasa ditetapkan", "code": "if ( ( 1 << i ) & N ) {"}
{"text": "Hasil kemas kini", "code": "result ++ ; } } printf ( \" % d STRNEWLINE \" , result ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int N = 43 ; count_setbit ( N ) ; return 0 ; }"}
{"text": "Pelaksanaan c untuk memeriksa bahawa integer adalah kuasa dua", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Berfungsi untuk memeriksa sama ada nombor itu adalah kuasa dua", "code": "_Bool isPowerOfTwo ( int n ) { return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int N = 8 ; if ( isPowerOfTwo ( N ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } }"}
{"text": "Pelaksanaan c untuk mencari set cantor untuk tahap n dan untuk start_num dan end_num yang diberikan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h>"}
{"text": "Struktur senarai yang dipautkan untuk set cantor", "code": "typedef struct cantor { double start , end ; struct cantor * next ; } Cantor ;"}
{"text": "Berfungsi untuk memulakan senarai set cantor", "code": "Cantor * startList ( Cantor * head , double start_num , double end_num ) { if ( head == NULL ) { head = ( Cantor * ) malloc ( sizeof ( Cantor ) ) ; head -> start = start_num ; head -> end = end_num ; head -> next = NULL ; } return head ; }"}
{"text": "Berfungsi untuk menopang senarai dengan menambahkan nod baru untuk tahap seterusnya", "code": "Cantor * propagate ( Cantor * head ) { Cantor * temp = head ; if ( temp != NULL ) { Cantor * newNode = ( Cantor * ) malloc ( sizeof ( Cantor ) ) ; double diff = ( ( ( temp -> end ) - ( temp -> start ) ) / 3 ) ;"}
{"text": "Mengubah nilai permulaan dan akhir untuk tahap seterusnya", "code": "newNode -> end = temp -> end ; temp -> end = ( ( temp -> start ) + diff ) ; newNode -> start = ( newNode -> end ) - diff ;"}
{"text": "Menukar petunjuk ke nod seterusnya", "code": "newNode -> next = temp -> next ; temp -> next = newNode ;"}
{"text": "Recursif memanggil fungsi untuk menjana set cantor untuk keseluruhan tahap", "code": "propagate ( temp -> next -> next ) ; } return head ; }"}
{"text": "Berfungsi untuk mencetak tahap set", "code": "void print ( Cantor * temp ) { while ( temp != NULL ) { printf ( \" [ % lf ] ▁ - - ▁ [ % lf ] TABSYMBOL \" , temp -> start , temp -> end ) ; temp = temp -> next ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Berfungsi untuk membina dan memaparkan set cantor untuk setiap peringkat", "code": "void buildCantorSet ( int A , int B , int L ) { Cantor * head = NULL ; head = startList ( head , A , B ) ; for ( int i = 0 ; i < L ; i ++ ) { printf ( \" Level _ % d ▁ : ▁ \" , i ) ; print ( head ) ; propagate ( head ) ; } printf ( \" Level _ % d ▁ : ▁ \" , L ) ; print ( head ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int A = 0 ; int B = 9 ; int L = 2 ; buildCantorSet ( A , B , L ) ; return 0 ; }"}
{"text": "Program C untuk algoritma mencari corak naif yang diubahsuai yang dioptimumkan untuk kes apabila semua watak corak berbeza", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Algoritma corak corak naif yang diubah suai yang dioptimumkan untuk kes apabila semua watak corak berbeza", "code": "void search ( char pat [ ] , char txt [ ] ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i = 0 ; while ( i <= N - M ) { int j ;"}
{"text": "Untuk indeks semasa I, periksa perlawanan corak", "code": "for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ;"}
{"text": "jika (j == m) Jika pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]", "code": "{ printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else"}
{"text": "luncurkan corak oleh j", "code": "i = i + j ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char txt [ ] = \" ABCEABCDABCEABCD \" ; char pat [ ] = \" ABCD \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Program C untuk menyulitkan rentetan menggunakan! dan @", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Berfungsi untuk menyulitkan rentetan", "code": "void encrypt ( char input [ 100 ] ) {"}
{"text": "EvenPos adalah untuk menyimpan enkripsi char di onnya oddpos adalah untuk menyimpan enkripsi char pada oddposition", "code": "char evenPos = ' @ ' , oddPos = ' ! ' ; int repeat , ascii ; for ( int i = 0 ; i <= strlen ( input ) ; i ++ ) {"}
{"text": "Dapatkan bilangan kali watak itu akan diulang", "code": "ascii = input [ i ] ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( int j = 0 ; j < repeat ; j ++ ) {"}
{"text": "Jika saya ganjil, cetak '! 'cetak lain' @ '", "code": "if ( i % 2 == 0 ) printf ( \" % c \" , oddPos ) ; else printf ( \" % c \" , evenPos ) ; } } }"}
{"text": "Kod pemacu", "code": "void main ( ) { char input [ 100 ] = { ' A ' , ' b ' , ' C ' , ' d ' } ;"}
{"text": "Menyulitkan rentetan", "code": "encrypt ( input ) ; }"}
{"text": "Program C Rekursif untuk memeriksa sama ada nombor tertentu adalah palindrome atau tidak", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #include <stdbool.h>"}
{"text": "Fungsi rekursif yang memeriksa str [s. . e] adalah palindrome atau tidak.", "code": "bool isPalRec ( char str [ ] , int s , int e ) {"}
{"text": "Sekiranya hanya ada satu watak", "code": "if ( s == e ) return true ;"}
{"text": "Sekiranya watak pertama dan terakhir tidak sepadan", "code": "if ( str [ s ] != str [ e ] ) return false ;"}
{"text": "Sekiranya terdapat lebih daripada dua aksara, periksa sama ada substring tengah juga palindrome atau tidak.", "code": "if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; } bool isPalindrome ( char str [ ] ) { int n = strlen ( str ) ;"}
{"text": "Rentetan kosong dianggap sebagai palindrome", "code": "if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { char str [ ] = \" geeg \" ; if ( isPalindrome ( str ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Program C ++ yang mudah untuk pelaksanaan atoi", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int myAtoi ( const char * str ) { int sign = 1 , base = 0 , i = 0 ;"}
{"text": "Jika ruang putih maka abaikan.", "code": "while ( str [ i ] == ' ▁ ' ) { i ++ ; }"}
{"text": "tanda nombor", "code": "if ( str [ i ] == ' - ' str [ i ] == ' + ' ) { sign = 1 - 2 * ( str [ i ++ ] == ' - ' ) ; }"}
{"text": "Memeriksa input yang sah", "code": "while ( str [ i ] >= '0' && str [ i ] <= '9' ) {"}
{"text": "mengendalikan kes ujian limpahan", "code": "if ( base > INT_MAX / 10 || ( base == INT_MAX / 10 && str [ i ] - '0' > 7 ) ) { if ( sign == 1 ) return INT_MAX ; else return INT_MIN ; } base = 10 * base + ( str [ i ++ ] - '0' ) ; } return base * sign ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { char str [ ] = \" ▁ - 123\" ;"}
{"text": "Kod fungsional", "code": "int val = myAtoi ( str ) ; printf ( \" % d ▁ \" , val ) ; return 0 ; }"}
{"text": "Program C berasaskan mundur untuk mengisi dua contoh semua nombor dari 1 hingga n dengan cara tertentu", "code": "#include <stdio.h> NEW_LINE #include <stdbool.h>"}
{"text": "Fungsi utiliti rekursif untuk mengisi dua contoh nombor dari 1 hingga n dalam res [0 .2 n - 1]. 'curr' adalah nilai semasa n.", "code": "bool fillUtil ( int res [ ] , int curr , int n ) {"}
{"text": "Sekiranya nombor semasa menjadi 0, maka semua nombor diisi", "code": "if ( curr == 0 ) return true ;"}
{"text": "Cuba letakkan dua contoh 'curr' di semua lokasi yang mungkin sehingga penyelesaian dijumpai", "code": "int i ; for ( i = 0 ; i < 2 * n - curr - 1 ; i ++ ) {"}
{"text": "Dua 'curr' harus diletakkan pada jarak 'curr + 1'", "code": "if ( res [ i ] == 0 && res [ i + curr + 1 ] == 0 ) {"}
{"text": "Juara Dua Contoh 'Curr'", "code": "res [ i ] = res [ i + curr + 1 ] = curr ;"}
{"text": "Berulang untuk memeriksa sama ada penempatan di atas membawa kepada penyelesaian", "code": "if ( fillUtil ( res , curr - 1 , n ) ) return true ;"}
{"text": "Sekiranya penyelesaian tidak mungkin, maka mundur", "code": "res [ i ] = res [ i + curr + 1 ] = 0 ; } } return false ; }"}
{"text": "Fungsi ini mencetak hasil untuk nombor input 'n' menggunakan fillutil ()", "code": "void fill ( int n ) {"}
{"text": "Buat pelbagai saiz 2 n dan mulakan semua elemen di dalamnya sebagai 0", "code": "int res [ 2 * n ] , i ; for ( i = 0 ; i < 2 * n ; i ++ ) res [ i ] = 0 ;"}
{"text": "Jika penyelesaian mungkin, kemudian cetaknya.", "code": "if ( fillUtil ( res , n , n ) ) { for ( i = 0 ; i < 2 * n ; i ++ ) printf ( \" % d ▁ \" , res [ i ] ) ; } else puts ( \" Not ▁ Possible \" ) ; }"}
{"text": "Program Pemandu", "code": "int main ( ) { fill ( 7 ) ; return 0 ; }"}
{"text": "C pelaksanaan pendekatan", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Berfungsi untuk mencetak bilangan digit", "code": "int findNumberOfDigits ( int n , int base ) {"}
{"text": "Hitung log menggunakan harta perubahan asas dan kemudian ambil lantai dan kemudian tambahkan 1", "code": "int dig = ( floor ( log ( n ) / log ( base ) ) + 1 ) ;"}
{"text": "Kembalikan output", "code": "return ( dig ) ; }"}
{"text": "Fungsi yang pulih benar jika n mengandungi semua satu dalam asas b", "code": "int isAllKs ( int n , int b , int k ) { int len = findNumberOfDigits ( n , b ) ;"}
{"text": "Kirakan jumlahnya", "code": "int sum = k * ( 1 - pow ( b , len ) ) / ( 1 - b ) ; if ( sum == n ) { return ( sum ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( void ) {"}
{"text": "Diberi nombor n", "code": "int N = 13 ;"}
{"text": "Diberi asas b", "code": "int B = 3 ;"}
{"text": "Diberi digit k", "code": "int K = 1 ;"}
{"text": "Panggilan fungsi", "code": "if ( isAllKs ( N , B , K ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } return 0 ; }"}
{"text": "Program c untuk mengira perimeter decagon", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencari perimeter", "code": "void CalPeri ( ) { int s = 5 , Perimeter ; Perimeter = 10 * s ; printf ( \" The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ % d \" , Perimeter ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { CalPeri ( ) ; return 0 ; }"}
{"text": "Program C untuk mencari sudut antara dua pesawat dalam 3 d.", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Berfungsi untuk mencari sudut", "code": "void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = 3.14159 ; float A = ( 180 / pi ) * ( acos ( d ) ) ; printf ( \" Angle ▁ is ▁ % .2f ▁ degree \" , A ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float a1 = 1 ; float b1 = 1 ; float c1 = 2 ; float d1 = 1 ; float a2 = 2 ; float b2 = -1 ; float c2 = 1 ; float d2 = -4 ; distance ( a1 , b1 , c1 , a2 , b2 , c2 ) ; return 0 ; }"}
{"text": "Program c untuk mencari cermin titik melalui pesawat 3 d", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencerminkan gambar", "code": "void mirror_point ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; printf ( \" x3 ▁ = ▁ % .1f ▁ \" , x3 ) ; printf ( \" y3 ▁ = ▁ % .1f ▁ \" , y3 ) ; printf ( \" z3 ▁ = ▁ % .1f ▁ \" , z3 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float a = 1 ; float b = -2 ; float c = 0 ; float d = 0 ; float x1 = -1 ; float y1 = 3 ; float z1 = 4 ;"}
{"text": "panggilan fungsi", "code": "mirror_point ( a , b , c , d , x1 , y1 , z1 ) ; }"}
{"text": "Program C untuk menyimpan jumlah nod di subtree kiri di setiap nod", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "Nod pokok", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Berfungsi untuk mengubahsuai pokok binari supaya setiap nod menyimpan jumlah nilai pada anak kirinya termasuk nilai sendiri", "code": "int updatetree ( node * root ) {"}
{"text": "Kes asas", "code": "if ( ! root ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return root -> data ;"}
{"text": "Kemas kini subtrees kiri dan kanan", "code": "int leftsum = updatetree ( root -> left ) ; int rightsum = updatetree ( root -> right ) ;"}
{"text": "Masukkan leftsum ke nod semasa", "code": "root -> data += leftsum ;"}
{"text": "Mengembalikan jumlah nilai di bawah akar", "code": "return root -> data + rightsum ; }"}
{"text": "Fungsi utiliti untuk melakukan traversal inorder", "code": "void inorder ( struct node * node ) { if ( node == NULL ) return ; inorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; inorder ( node -> right ) ; }"}
{"text": "Fungsi utiliti untuk membuat nod baru", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Program Pemandu", "code": "int main ( ) {"}
{"text": "Mari kita bina di bawah pokok 1 / \\ 2 3 / \\ 4 5 6", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; updatetree ( root ) ; cout << \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ is ▁ STRNEWLINE \" ; inorder ( root ) ; return 0 ; }"}
{"text": "Program C untuk kaedah kekerasan untuk mengira nilai rentang stok", "code": "#include <stdio.h>"}
{"text": "Mengisi array s [] dengan nilai rentang", "code": "void calculateSpan ( int price [ ] , int n , int S [ ] ) {"}
{"text": "Nilai rentang hari pertama selalu 1", "code": "S [ 0 ] = 1 ;"}
{"text": "Kirakan nilai rentang hari baki dengan memeriksa secara linear hari -hari sebelumnya", "code": "for ( int i = 1 ; i < n ; i ++ ) {"}
{"text": "Inisialisasi nilai span", "code": "S [ i ] = 1 ;"}
{"text": "Traverse kiri manakala elemen seterusnya di sebelah kiri lebih kecil daripada harga [i]", "code": "for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } }"}
{"text": "Fungsi utiliti untuk mencetak elemen array", "code": "void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int S [ n ] ;"}
{"text": "Isi nilai rentang dalam array s []", "code": "calculateSpan ( price , n , S ) ;"}
{"text": "Cetak nilai rentang yang dikira", "code": "printArray ( S , n ) ; return 0 ; }"}
{"text": "Program C Mudah untuk mencetak elemen seterusnya yang lebih besar dalam array yang diberikan", "code": "#include <stdio.h>"}
{"text": "Cetak elemen dan pasangan NGE untuk semua elemen arr [] saiz n", "code": "void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } printf ( \" % d ▁ - - ▁ % dn \" , arr [ i ] , next ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNGE ( arr , n ) ; return 0 ; }"}
{"text": "Program c untuk menukar pokok binari ke cerminnya", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct Node { int data ; struct Node * left ; struct Node * right ; } ;"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Tukar pokok supaya peranan penunjuk kiri dan kanan ditukar pada setiap nod. Jadi pokok ... 4 / \\ 2 5 / \\ 1 3 diubah menjadi ... 4 / \\ 5 2 / \\ 3 1", "code": "void mirror ( struct Node * node ) { if ( node == NULL ) return ; else { struct Node * temp ;"}
{"text": "Lakukan subtrees", "code": "mirror ( node -> left ) ; mirror ( node -> right ) ;"}
{"text": "Tukar petunjuk dalam nod ini", "code": "temp = node -> left ; node -> left = node -> right ; node -> right = temp ; } }"}
{"text": "Fungsi penolong untuk mencetak traversal inorder.", "code": "void inOrder ( struct Node * node ) { if ( node == NULL ) return ; inOrder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; inOrder ( node -> right ) ; }"}
{"text": "Program Pemandu untuk Menguji Cermin ()", "code": "int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ;"}
{"text": "Cetak inorder traversal pokok input", "code": "printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ constructed \" \" ▁ tree ▁ is ▁ STRNEWLINE \" ) ; inOrder ( root ) ;"}
{"text": "Tukar pokok ke cerminnya", "code": "mirror ( root ) ;"}
{"text": "Cetak inorder traversal pokok cermin", "code": "printf ( \" Inorder traversal of the mirror tree \" ▁ \" is \" inOrder ( root ) ; return 0 ; }"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi utiliti yang memeriksa jika pokok dengan akar sebagai n1 dan n2 adalah cermin antara satu sama lain", "code": "bool IsFoldableUtil ( struct node * n1 , struct node * n2 ) ;"}
{"text": "Pulangan benar jika pokok yang diberikan dapat dilipat", "code": "bool IsFoldable ( struct node * root ) { if ( root == NULL ) { return true ; } return IsFoldableUtil ( root -> left , root -> right ) ; }"}
{"text": "Fungsi utiliti yang memeriksa jika pokok dengan akar sebagai n1 dan n2 adalah cermin antara satu sama lain", "code": "bool IsFoldableUtil ( struct node * n1 , struct node * n2 ) {"}
{"text": "Sekiranya kedua -dua subtrees kiri dan kanan adalah batal, maka kembali benar", "code": "if ( n1 == NULL && n2 == NULL ) { return true ; }"}
{"text": "Sekiranya salah satu pokok adalah batal dan yang lain tidak, maka kembali palsu", "code": "if ( n1 == NULL n2 == NULL ) { return false ; }"}
{"text": "Jika tidak, periksa sama ada subtrees kiri dan kanan adalah cermin rakan mereka", "code": "return IsFoldableUtil ( n1 -> left , n2 -> right ) && IsFoldableUtil ( n1 -> right , n2 -> left ) ; }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Program Pemandu untuk Menguji Cermin ()", "code": "int main ( void ) {"}
{"text": "Pokok binari yang dibina ialah 1 / \\ 2 3 \\ / 4 5", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; if ( IsFoldable ( root ) == true ) { printf ( \" tree is foldable \" } else { printf ( \" tree is not foldable \" } getchar ( ) ; return 0 ; }"}
{"text": "Program untuk memeriksa harta benda kanak -kanak", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, anak kiri dan anak kanan", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Mengembalikan 1 jika kanak -kanak jumlah harta tanah memegang nod yang diberikan dan kedua -dua anaknya", "code": "int isSumProperty ( struct node * node ) {"}
{"text": "left_data dibiarkan data kanak -kanak dan right_data adalah untuk data anak yang betul", "code": "int left_data = 0 , right_data = 0 ;"}
{"text": "Sekiranya nod adalah batal atau ia adalah nod daun maka kembali benar", "code": "if ( node == NULL || ( node -> left == NULL && node -> right == NULL ) ) return 1 ; else {"}
{"text": "Sekiranya anak kiri tidak hadir maka 0 digunakan sebagai data anak kiri", "code": "if ( node -> left != NULL ) left_data = node -> left -> data ;"}
{"text": "Sekiranya anak yang betul tidak hadir maka 0 digunakan sebagai data anak yang betul", "code": "if ( node -> right != NULL ) right_data = node -> right -> data ;"}
{"text": "Sekiranya nod dan kedua -dua anaknya memuaskan harta itu pulangan 1 lain 0", "code": "if ( ( node -> data == left_data + right_data ) && isSumProperty ( node -> left ) && isSumProperty ( node -> right ) ) return 1 ; else return 0 ; } }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct node * root = newNode ( 10 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 2 ) ; if ( isSumProperty ( root ) ) printf ( \" The ▁ given ▁ tree ▁ satisfies ▁ the ▁ children ▁ sum ▁ property ▁ \" ) ; else printf ( \" The ▁ given ▁ tree ▁ does ▁ not ▁ satisfy ▁ the ▁ children ▁ sum ▁ property ▁ \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program C untuk mencari GCD daripada dua nombor", "code": "#include <stdio.h>"}
{"text": "Fungsi rekursif untuk mengembalikan GCD a dan b", "code": "int gcd ( int a , int b ) {"}
{"text": "Semuanya membahagikan 0", "code": "if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ;"}
{"text": "Kes asas", "code": "if ( a == b ) return a ;"}
{"text": "A lebih besar", "code": "if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int a = 0 , b = 56 ; printf ( \" GCD ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "Program C untuk masalah Josephus", "code": "#include <stdio.h>"}
{"text": "berfungsi untuk mencari kedudukan bit yang paling penting", "code": "int msbPos ( int n ) { int pos = 0 ; while ( n != 0 ) { pos ++ ;"}
{"text": "terus beralih bit ke kanan sehingga kita ditinggalkan dengan 0", "code": "n = n >> 1 ; } return pos ; }"}
{"text": "berfungsi untuk kembali di tempat Josephus harus duduk untuk mengelakkan dibunuh", "code": "int josephify ( int n ) {"}
{"text": "Mendapatkan kedudukan Bit Paling Penting (MSB). Yang paling kiri '1'. Jika nombor itu '41' maka binari adalah '101001'. Jadi MSBPOS (41) = 6", "code": "int position = msbPos ( n ) ;"}
{"text": "'J' menyimpan nombor yang mana untuk xor nombor 'n'. Oleh kerana kita memerlukan '100000' kita akan melakukan 1 << 6 - 1 untuk mendapatkan '100000'", "code": "int j = 1 << ( position - 1 ) ;"}
{"text": "Mengubah sedikit yang paling ketara. Menukar '1' paling kiri hingga '0'. 101001 ^ 100000 = 001001 (9)", "code": "n = n ^ j ;"}
{"text": "Kiri - Pergeseran sekali untuk menambah '0' tambahan ke hujung kanan nombor binari 001001 = 010010 (18)", "code": "n = n << 1 ;"}
{"text": "Mengubah '0' pada akhir hingga '1' yang pada dasarnya sama seperti meletakkan MSB di tempat paling kanan. 010010 | 1 = 010011 (19)", "code": "n = n | 1 ; return n ; }"}
{"text": "fungsi utama pemacu berkod keras untuk menjalankan program", "code": "int main ( ) { int n = 41 ; printf ( \" % d STRNEWLINE \" , josephify ( n ) ) ; return 0 ; }"}
{"text": "Program C ++ yang cekap untuk mengira jumlah bitwise dan semua pasangan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "Mengembalikan nilai \"arr [0] u arr [0] [0] [2] [2].", "code": "int pairAndSum ( int arr [ ] , int n ) {"}
{"text": "Melintasi semua bit", "code": "for ( int i = 0 ; i < 32 ; i ++ ) {"}
{"text": "Kiraan bilangan elemen dengan bit i 'th bit int k = 0; Mulakan kiraan", "code": "for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) k ++ ;"}
{"text": "Terdapat bit set k, bermakna k (k - 1) / 2 pasang. Setiap pasangan menambah 2 ^ i ke jawapannya. Oleh itu, kami menambah \"2 ^ i u u '(K * (K - 1) / 2]\" kepada jawapannya.", "code": "ans += ( 1 << i ) * ( k * ( k - 1 ) / 2 ) ; } return ans ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 5 , 10 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << pairAndSum ( arr , n ) << endl ; return 0 ; }"}
{"text": "Berfungsi untuk mengembalikan kiraan kuadrat;", "code": "function countSquares ( n ) {"}
{"text": "Cara yang lebih baik untuk menulis n * (n + 1) * (2 n + 1) / 6", "code": "return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }"}
{"text": "Kod pemacu", "code": "let n = 4 ; document . write ( \" Count ▁ of ▁ squares ▁ is ▁ \" + countSquares ( n ) ) ;"}
{"text": "Program C untuk mencari GCD daripada dua nombor", "code": "#include <stdio.h>"}
{"text": "Fungsi rekursif untuk mengembalikan GCD a dan b", "code": "int gcd ( int a , int b ) {"}
{"text": "Semuanya membahagikan 0", "code": "if ( a == 0 ) return b ; if ( b == 0 ) return a ;"}
{"text": "Kes asas", "code": "if ( a == b ) return a ;"}
{"text": "A lebih besar", "code": "if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int a = 98 , b = 56 ; printf ( \" GCD ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "Program C untuk membina pokok xor dengan nod daun pokok binari yang sempurna dan nilai nod akar pokok", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Saiz maksimum untuk pokok xor", "code": "#define maxsize  10005"}
{"text": "Memperuntukkan ruang ke pokok xor", "code": "int xortree [ maxsize ] ;"}
{"text": "Fungsi rekursif yang membina pokok XOR untuk array [Mula ..... . akhir]. x adalah indeks nod semasa di xor pokok st", "code": "void construct_Xor_Tree_Util ( int current [ ] , int start , int end , int x ) {"}
{"text": "Sekiranya terdapat satu elemen dalam array, simpannya dalam nod semasa pokok xor dan kembalikan", "code": "if ( start == end ) { xortree [ x ] = current [ start ] ;"}
{"text": "printf (\" % d\", xortree [x]);", "code": "return ; }"}
{"text": "untuk subtree kiri", "code": "int left = x * 2 + 1 ;"}
{"text": "untuk subtree yang betul", "code": "int right = x * 2 + 2 ;"}
{"text": "untuk mendapatkan indeks pertengahan dari indeks sudut.", "code": "int mid = start + ( end - start ) / 2 ;"}
{"text": "Bina kiri dan subtrees kanan dengan operasi XOR", "code": "construct_Xor_Tree_Util ( current , start , mid , left ) ; construct_Xor_Tree_Util ( current , mid + 1 , end , right ) ;"}
{"text": "Gabungkan subtrees kiri dan kanan dengan operasi XOR", "code": "xortree [ x ] = ( xortree [ left ] ^ xortree [ right ] ) ; }"}
{"text": "Fungsi untuk membina pokok XOR dari array yang diberikan. Fungsi ini memanggil Construct_XOR_TREE_UTIL () untuk mengisi memori yang diperuntukkan bagi array Xort", "code": "void construct_Xor_Tree ( int arr [ ] , int n ) { int i = 0 ; for ( i = 0 ; i < maxsize ; i ++ ) xortree [ i ] = 0 ; construct_Xor_Tree_Util ( arr , 0 , n - 1 , 0 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "nod daun pokok binari", "code": "int leaf_nodes [ ] = { 40 , 32 , 12 , 1 , 4 , 3 , 2 , 7 } , i = 0 ; int n = sizeof ( leaf_nodes ) / sizeof ( leaf_nodes [ 0 ] ) ;"}
{"text": "Bina pokok xor", "code": "construct_Xor_Tree ( leaf_nodes , n ) ;"}
{"text": "Ketinggian pokok xor", "code": "int x = ( int ) ( ceil ( log2 ( n ) ) ) ;"}
{"text": "Saiz maksimum pokok xor", "code": "int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; printf ( \" Nodes ▁ of ▁ the ▁ XOR ▁ tree STRNEWLINE \" ) ; for ( i = 0 ; i < max_size ; i ++ ) { printf ( \" % d ▁ \" , xortree [ i ] ) ; }"}
{"text": "Nod Root berada di Indeks 0 Memandangkan Pengindeksan Berasaskan 0 di Pokok XOR", "code": "int root = 0 ;"}
{"text": "Nilai cetak pada nod root", "code": "printf ( \" Root : % d \" }"}
{"text": "Kod c untuk bertukar bit yang diberikan nombor", "code": "#include <stdio.h> NEW_LINE int swapBits ( int n , int p1 , int p2 ) {"}
{"text": "Kiri - Shift 1 P1 dan P2 kali dan menggunakan XOR", "code": "n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { printf ( \" Result ▁ = ▁ % d \" , swapBits ( 28 , 0 , 3 ) ) ; return 0 ; }"}
{"text": "Program C untuk memeriksa sama ada dua nod di pokok binari adalah sepupu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "Fungsi utiliti untuk membuat nod pokok binari baru", "code": "struct Node * newNode ( int item ) { struct Node * temp = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Fungsi rekursif untuk memeriksa sama ada dua nod adalah adik beradik", "code": "int isSibling ( struct Node * root , struct Node * a , struct Node * b ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return 0 ; return ( ( root -> left == a && root -> right == b ) || ( root -> left == b && root -> right == a ) || isSibling ( root -> left , a , b ) || isSibling ( root -> right , a , b ) ) ; }"}
{"text": "Fungsi rekursif untuk mencari tahap node 'ptr' di pokok binari", "code": "int level ( struct Node * root , struct Node * ptr , int lev ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return 0 ; if ( root == ptr ) return lev ;"}
{"text": "Tahap pulangan jika nod hadir di subtree kiri", "code": "int l = level ( root -> left , ptr , lev + 1 ) ; if ( l != 0 ) return l ;"}
{"text": "Lain cari di subtree yang betul", "code": "return level ( root -> right , ptr , lev + 1 ) ; }"}
{"text": "Pulangan 1 jika a dan b adalah sepupu, jika tidak 0", "code": "int isCousin ( struct Node * root , struct Node * a , struct Node * b ) {"}
{"text": "1. Kedua -dua nod harus berada pada tahap yang sama di dalam pokok binari. 2. Kedua -dua nod tidak boleh menjadi adik -beradik (bermakna mereka tidak sepatutnya mempunyai nod induk yang sama).", "code": "if ( ( level ( root , a , 1 ) == level ( root , b , 1 ) ) && ! ( isSibling ( root , a , b ) ) ) return 1 ; else return 0 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> right -> right = newNode ( 15 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; struct Node * Node1 , * Node2 ; Node1 = root -> left -> left ; Node2 = root -> right -> right ; isCousin ( root , Node1 , Node2 ) ? puts ( \" Yes \" ) : puts ( \" No \" ) ; return 0 ; }"}
{"text": "Program C untuk memeriksa sama ada semua daun berada pada tahap yang sama", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "Fungsi utiliti untuk memperuntukkan nod pokok baru", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; }"}
{"text": "Fungsi rekursif yang memeriksa sama ada semua daun berada pada tahap yang sama", "code": "bool checkUtil ( struct Node * root , int level , int * leafLevel ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return true ;"}
{"text": "Sekiranya nod daun ditemui", "code": "if ( root -> left == NULL && root -> right == NULL ) {"}
{"text": "Apabila nod daun dijumpai kali pertama", "code": "if ( * leafLevel == 0 ) {"}
{"text": "Tetapkan Tahap Daun Pertama", "code": "* leafLevel = level ; return true ; }"}
{"text": "Sekiranya ini bukan nod daun pertama, bandingkan tahapnya dengan tahap daun pertama", "code": "return ( level == * leafLevel ) ; }"}
{"text": "Sekiranya nod ini tidak daun, periksa semula subtrees kiri dan kanan secara rekursif", "code": "return checkUtil ( root -> left , level + 1 , leafLevel ) && checkUtil ( root -> right , level + 1 , leafLevel ) ; }"}
{"text": "Fungsi utama untuk memeriksa sama ada semua daun berada pada tahap yang sama. Ia terutamanya menggunakan checkUtil ()", "code": "bool check ( struct Node * root ) { int level = 0 , leafLevel = 0 ; return checkUtil ( root , level , & leafLevel ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Mari kita buat pokok yang ditunjukkan dalam contoh ketiga", "code": "struct Node * root = newNode ( 12 ) ; root -> left = newNode ( 5 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 9 ) ; root -> left -> left -> left = newNode ( 1 ) ; root -> left -> right -> left = newNode ( 1 ) ; if ( check ( root ) ) printf ( \" Leaves ▁ are ▁ at ▁ same ▁ level STRNEWLINE \" ) ; else printf ( \" Leaves ▁ are ▁ not ▁ at ▁ same ▁ level STRNEWLINE \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program C untuk memeriksa sama ada pokok binari yang diberikan penuh atau tidak", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h>"}
{"text": "Struktur nod pokok", "code": "struct Node { int key ; struct Node * left , * right ; } ;"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan penunjuk kiri dan null kiri dan kanan.", "code": "struct Node * newNode ( char k ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> key = k ; node -> right = node -> left = NULL ; return node ; }"}
{"text": "Fungsi ini ujian jika pokok binari adalah pokok binari penuh.", "code": "bool isFullTree ( struct Node * root ) {"}
{"text": "Sekiranya pokok kosong", "code": "if ( root == NULL ) return true ;"}
{"text": "Jika nod daun", "code": "if ( root -> left == NULL && root -> right == NULL ) return true ;"}
{"text": "Sekiranya kedua -dua kiri dan kanan tidak batal, dan subtrees kiri & kanan penuh", "code": "if ( ( root -> left ) && ( root -> right ) ) return ( isFullTree ( root -> left ) && isFullTree ( root -> right ) ) ;"}
{"text": "Kami sampai di sini apabila tidak ada keadaan di atas jika keadaan berfungsi", "code": "return false ; }"}
{"text": "Program Pemandu", "code": "int main ( ) { struct Node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( 20 ) ; root -> right = newNode ( 30 ) ; root -> left -> right = newNode ( 40 ) ; root -> left -> left = newNode ( 50 ) ; root -> right -> left = newNode ( 60 ) ; root -> right -> right = newNode ( 70 ) ; root -> left -> left -> left = newNode ( 80 ) ; root -> left -> left -> right = newNode ( 90 ) ; root -> left -> right -> left = newNode ( 80 ) ; root -> left -> right -> right = newNode ( 90 ) ; root -> right -> left -> left = newNode ( 80 ) ; root -> right -> left -> right = newNode ( 90 ) ; root -> right -> right -> left = newNode ( 80 ) ; root -> right -> right -> right = newNode ( 90 ) ; if ( isFullTree ( root ) ) printf ( \" The ▁ Binary ▁ Tree ▁ is ▁ full STRNEWLINE \" ) ; else printf ( \" The ▁ Binary ▁ Tree ▁ is ▁ not ▁ full STRNEWLINE \" ) ; return ( 0 ) ; }"}
{"text": "Program c untuk melaksanakan pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencetak elemen alternatif dari array yang diberikan", "code": "void printAlter ( int arr [ ] , int N ) {"}
{"text": "Elemen cetak di kedudukan ganjil", "code": "for ( int currIndex = 0 ; currIndex < N ; currIndex += 2 ) {"}
{"text": "Cetak elemen array", "code": "printf ( \" % d ▁ \" , arr [ currIndex ] ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAlter ( arr , N ) ; }"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Diberikan dua pokok, kembali benar jika mereka sama strukturnya", "code": "int identicalTrees ( struct node * a , struct node * b ) {"}
{"text": "1. Kedua -duanya kosong", "code": "if ( a == NULL && b == NULL ) return 1 ;"}
{"text": "2. Kedua -dua tidak - kosong -> Bandingkan mereka", "code": "if ( a != NULL && b != NULL ) { return ( a -> data == b -> data && identicalTrees ( a -> left , b -> left ) && identicalTrees ( a -> right , b -> right ) ) ; }"}
{"text": "3. Satu kosong, tidak -> palsu", "code": "return 0 ; }"}
{"text": "Program pemacu untuk menguji fungsi identiti", "code": "int main ( ) { struct node * root1 = newNode ( 1 ) ; struct node * root2 = newNode ( 1 ) ; root1 -> left = newNode ( 2 ) ; root1 -> right = newNode ( 3 ) ; root1 -> left -> left = newNode ( 4 ) ; root1 -> left -> right = newNode ( 5 ) ; root2 -> left = newNode ( 2 ) ; root2 -> right = newNode ( 3 ) ; root2 -> left -> left = newNode ( 4 ) ; root2 -> left -> right = newNode ( 5 ) ; if ( identicalTrees ( root1 , root2 ) ) printf ( \" Both ▁ tree ▁ are ▁ identical . \" ) ; else printf ( \" Trees ▁ are ▁ not ▁ identical . \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mencetak sepupu nod", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari", "code": "struct Node { int data ; Node * left , * right ; } ;"}
{"text": "Fungsi utiliti untuk membuat nod pokok binari baru", "code": "Node * newNode ( int item ) { Node * temp = new Node ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Ia mengembalikan tahap nod jika ada di dalam pokok, jika tidak, pulangan 0.", "code": "int getLevel ( Node * root , Node * node , int level ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return 0 ; if ( root == node ) return level ;"}
{"text": "Sekiranya nod hadir di subtree kiri", "code": "int downlevel = getLevel ( root -> left , node , level + 1 ) ; if ( downlevel != 0 ) return downlevel ;"}
{"text": "Sekiranya nod tidak terdapat di subtree kiri", "code": "return getLevel ( root -> right , node , level + 1 ) ; }"}
{"text": "Cetak nod pada tahap tertentu supaya adik nod tidak dicetak jika ada", "code": "void printGivenLevel ( Node * root , Node * node , int level ) {"}
{"text": "Kes asas", "code": "if ( root == NULL level < 2 ) return ;"}
{"text": "Sekiranya nod semasa adalah ibu bapa nod dengan tahap tertentu", "code": "if ( level == 2 ) { if ( root -> left == node root -> right == node ) return ; if ( root -> left ) printf ( \" % d ▁ \" , root -> left -> data ) ; if ( root -> right ) printf ( \" % d ▁ \" , root -> right -> data ) ; }"}
{"text": "Berulang untuk subtrees kiri dan kanan", "code": "else if ( level > 2 ) { printGivenLevel ( root -> left , node , level - 1 ) ; printGivenLevel ( root -> right , node , level - 1 ) ; } }"}
{"text": "Fungsi ini mencetak sepupu nod yang diberikan", "code": "void printCousins ( Node * root , Node * node ) {"}
{"text": "Dapatkan tahap nod yang diberikan", "code": "int level = getLevel ( root , node , 1 ) ;"}
{"text": "Cetak nod tahap yang diberikan.", "code": "printGivenLevel ( root , node , level ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> right -> right = newNode ( 15 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; printCousins ( root , root -> left -> right ) ; return 0 ; }"}
{"text": "program untuk mencetak semua laluan akarnya - ke daun untuk pokok", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Prototaip fungsi", "code": "void printArray ( int [ ] , int ) ; void printPathsRecur ( struct node * , int [ ] , int ) ; struct node * newNode ( int ) ; void printPaths ( struct node * ) ;"}
{"text": "Memandangkan pokok binari, cetak semua laluan akarnya - ke daun, satu setiap baris. Menggunakan pembantu rekursif untuk melakukan kerja.", "code": "void printPaths ( struct node * node ) { int path [ 1000 ] ; printPathsRecur ( node , path , 0 ) ; }"}
{"text": "Fungsi pembantu rekursif - diberi nod, dan array yang mengandungi laluan dari nod akar sehingga tetapi tidak termasuk nod ini, cetak semua laluan daun akar.", "code": "void printPathsRecur ( struct node * node , int path [ ] , int pathLen ) { if ( node == NULL ) return ;"}
{"text": "tambah nod ini ke array jalan", "code": "path [ pathLen ] = node -> data ; pathLen ++ ;"}
{"text": "Ia adalah daun, jadi cetak jalan yang membawa ke sini", "code": "if ( node -> left == NULL && node -> right == NULL ) { printArray ( path , pathLen ) ; } else {"}
{"text": "Jika tidak, cuba kedua -dua subtrees", "code": "printPathsRecur ( node -> left , path , pathLen ) ; printPathsRecur ( node -> right , path , pathLen ) ; } }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Utiliti yang mencetak array pada baris", "code": "void printArray ( int ints [ ] , int len ) { int i ; for ( i = 0 ; i < len ; i ++ ) { printf ( \" % d ▁ \" , ints [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Program Pemandu untuk Menguji Cermin ()", "code": "int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ;"}
{"text": "Cetak semua root - ke - jalur daun pokok input", "code": "printPaths ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Mewujudkan array integer yang dinamakan ARR dari saiz 10.", "code": "int arr [ 10 ] ;"}
{"text": "Mengakses elemen pada indeks 0 dan menetapkan nilainya kepada 5.", "code": "arr [ 0 ] = 5 ;"}
{"text": "Akses dan nilai cetak pada 0 indeks kita mendapat output sebagai 5.", "code": "printf ( \" % d \" , arr [ 0 ] ) ; return 0 ; }"}
{"text": "Prototaip untuk fungsi utiliti", "code": "void printArray ( int arr [ ] , int size ) ; void swap ( int arr [ ] , int fi , int si , int d ) ; void leftRotate ( int arr [ ] , int d , int n ) {"}
{"text": "Kembali jika bilangan elemen diputar adalah sifar atau sama dengan saiz array", "code": "if ( d == 0 d == n ) return ;"}
{"text": "Sekiranya bilangan elemen diputar adalah separuh daripada saiz array", "code": "if ( n - d == d ) { swap ( arr , 0 , n - d , d ) ; return ; }"}
{"text": "Sekiranya A lebih pendek", "code": "if ( d < n - d ) { swap ( arr , 0 , n - d , d ) ; leftRotate ( arr , d , n - d ) ; }"}
{"text": "Sekiranya B lebih pendek", "code": "else { swap ( arr , 0 , d , n - d ) ; leftRotate ( arr + n - d , 2 * d - n , d ) ; } }"}
{"text": "berfungsi untuk mencetak array", "code": "void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE ▁ \" ) ; }"}
{"text": "Fungsi ini bertukar elemen D bermula pada indeks fi dengan elemen d bermula pada indeks Si", "code": "void swap ( int arr [ ] , int fi , int si , int d ) { int i , temp ; for ( i = 0 ; i < d ; i ++ ) { temp = arr [ fi + i ] ; arr [ fi + i ] = arr [ si + i ] ; arr [ si + i ] = temp ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; leftRotate ( arr , 2 , 7 ) ; printArray ( arr , 7 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Code C untuk pelaksanaan di atas", "code": "void leftRotate ( int arr [ ] , int d , int n ) { int i , j ; if ( d == 0 d == n ) return ; i = d ; j = n - d ; while ( i != j ) {"}
{"text": "A adalah lebih pendek", "code": "if ( i < j ) { swap ( arr , d - i , d + j - i , i ) ; j -= i ; }"}
{"text": "B lebih pendek", "code": "else { swap ( arr , d - i , d , j ) ; i -= j ; } }"}
{"text": "Akhirnya, blok swap a dan b", "code": "swap ( arr , d - i , d , i ) ; }"}
{"text": "bertukar", "code": "void swap ( int * x , int * y ) { int temp = * x ; * x = * y ; * y = temp ; }"}
{"text": "Saya dan J menunjuk ke elemen pertama dan terakhir", "code": "void rotate ( int arr [ ] , int n ) { int i = 0 , j = n - 1 ; while ( i != j ) { swap ( & arr [ i ] , & arr [ j ] ) ; i ++ ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } , i ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given ▁ array ▁ is STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; rotate ( arr , n ) ; printf ( \" Rotated array is \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }"}
{"text": "Program C untuk melaksanakan jenis pemilihan untuk pelbagai rentetan.", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define MAX_LEN  100"}
{"text": "Menyusun pelbagai rentetan di mana panjang setiap rentetan harus lebih kecil daripada max_len", "code": "void selectionSort ( char arr [ ] [ MAX_LEN ] , int n ) { int i , j , min_idx ;"}
{"text": "Satu demi satu langkah sempadan subarray yang tidak disusun", "code": "char minStr [ MAX_LEN ] ; for ( i = 0 ; i < n - 1 ; i ++ ) {"}
{"text": "Cari elemen minimum dalam array yang tidak disusun", "code": "int min_idx = i ; strcpy ( minStr , arr [ i ] ) ; for ( j = i + 1 ; j < n ; j ++ ) {"}
{"text": "Sekiranya min lebih besar daripada arr [j]", "code": "if ( strcmp ( minStr , arr [ j ] ) > 0 ) {"}
{"text": "Buat arr [j] sebagai minstr dan kemas kini min_idx", "code": "strcpy ( minStr , arr [ j ] ) ; min_idx = j ; } }"}
{"text": "Tukar elemen minimum yang dijumpai dengan elemen pertama", "code": "if ( min_idx != i ) { char temp [ MAX_LEN ] ; strcpy ( temp , arr [ i ] ) ; strcpy ( arr [ i ] , arr [ min_idx ] ) ; strcpy ( arr [ min_idx ] , temp ) ; } } }"}
{"text": "Kod pemacu", "code": "int main ( ) { char arr [ ] [ MAX_LEN ] = { \" GeeksforGeeks \" , \" Practice . GeeksforGeeks \" , \" GeeksQuiz \" } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int i ; printf ( \" Given ▁ array ▁ is STRNEWLINE \" ) ;"}
{"text": "Mencetak Array Sebelum Menyusun", "code": "for ( i = 0 ; i < n ; i ++ ) printf ( \" % d : ▁ % s ▁ STRNEWLINE \" , i , arr [ i ] ) ; selectionSort ( arr , n ) ; printf ( \" Sorted array is \""}
{"text": "Mencetak array selepas menyusun", "code": "for ( i = 0 ; i < n ; i ++ ) printf ( \" % d : ▁ % s ▁ STRNEWLINE \" , i , arr [ i ] ) ; return 0 ; }"}
{"text": "Program c yang mudah untuk menyusun semula kandungan arr [] seperti yang arr [j] menjadi J jika arr [i] adalah j", "code": "#include <stdio.h>"}
{"text": "Kaedah mudah untuk menyusun semula 'arr [0. . n - 1] 'jadi' arr [j] 'menjadi' i 'if' arr [i] 'adalah' j '", "code": "void rearrangeNaive ( int arr [ ] , int n ) {"}
{"text": "Buat pelbagai saiz yang sama", "code": "int temp [ n ] , i ;"}
{"text": "Kedai Hasil dalam temp []", "code": "for ( i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] = i ;"}
{"text": "Salin temp kembali ke arr []", "code": "for ( i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }"}
{"text": "Fungsi utiliti untuk mencetak kandungan ARR [0 .. n - 1]", "code": "void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Program Pemandu", "code": "int main ( ) { int arr [ ] = { 1 , 3 , 0 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given ▁ array ▁ is ▁ STRNEWLINE \" ) ; printArray ( arr , n ) ; rearrangeNaive ( arr , n ) ; printf ( \" Modified ▁ array ▁ is ▁ STRNEWLINE \" ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Program c untuk mencari maksimum dalam arr [] saiz n", "code": "#include <stdio.h>"}
{"text": "C Fungsi untuk mencari maksimum dalam arr [] saiz n", "code": "int largest ( int arr [ ] , int n ) { int i ;"}
{"text": "Memulakan elemen maksimum", "code": "int max = arr [ 0 ] ;"}
{"text": "Elemen Array Traverse dari Kedua dan Bandingkan Setiap Elemen Dengan Maksimum Semasa", "code": "for ( i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 10 , 324 , 45 , 90 , 9808 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Largest ▁ in ▁ given ▁ array ▁ is ▁ % d \" , largest ( arr , n ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari elemen kedua terbesar dalam pelbagai", "code": "#include <limits.h> NEW_LINE #include <stdio.h>"}
{"text": "Berfungsi untuk mencetak elemen kedua terbesar", "code": "void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ;"}
{"text": "Harus ada dua elemen", "code": "if ( arr_size < 2 ) { printf ( \" ▁ Invalid ▁ Input ▁ \" ) ; return ; } first = second = INT_MIN ; for ( i = 0 ; i < arr_size ; i ++ ) {"}
{"text": "Sekiranya elemen semasa lebih besar daripada yang pertama maka kemas kini kedua -dua dan kedua", "code": "if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; }"}
{"text": "Sekiranya Arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua", "code": "else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MIN ) printf ( \" There ▁ is ▁ no ▁ second ▁ largest ▁ element STRNEWLINE \" ) ; else printf ( \" The ▁ second ▁ largest ▁ element ▁ is ▁ % dn \" , second ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2largest ( arr , n ) ; return 0 ; }"}
{"text": "Struktur digunakan untuk mengembalikan dua nilai dari Minmax ()", "code": "#include <stdio.h> NEW_LINE struct pair { int min ; int max ; } ; struct pair getMinMax ( int arr [ ] , int n ) { struct pair minmax ; int i ;"}
{"text": "Sekiranya hanya ada satu elemen maka kembali sebagai min dan max kedua -duanya", "code": "if ( n == 1 ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 0 ] ; return minmax ; }"}
{"text": "Sekiranya terdapat lebih daripada satu elemen, maka mulakan min dan max", "code": "if ( arr [ 0 ] > arr [ 1 ] ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 1 ] ; } else { minmax . max = arr [ 1 ] ; minmax . min = arr [ 0 ] ; } for ( i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > minmax . max ) minmax . max = arr [ i ] ; else if ( arr [ i ] < minmax . min ) minmax . min = arr [ i ] ; } return minmax ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1000 , 11 , 445 , 1 , 330 , 3000 } ; int arr_size = 6 ; struct pair minmax = getMinMax ( arr , arr_size ) ; printf ( \" nMinimum ▁ element ▁ is ▁ % d \" , minmax . min ) ; printf ( \" nMaximum ▁ element ▁ is ▁ % d \" , minmax . max ) ; getchar ( ) ; }"}
{"text": "Struktur digunakan untuk mengembalikan dua nilai dari Minmax ()", "code": "struct pair { int min ; int max ; } ; struct pair getMinMax ( int arr [ ] , int n ) { struct pair minmax ; int i ;"}
{"text": "Sekiranya array mempunyai bilangan elemen, maka mulakan dua elemen pertama sebagai minimum dan maksimum", "code": "if ( n % 2 == 0 ) { if ( arr [ 0 ] > arr [ 1 ] ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 1 ] ; } else { minmax . min = arr [ 0 ] ; minmax . max = arr [ 1 ] ; }"}
{"text": "Tetapkan indeks permulaan untuk gelung", "code": "i = 2 ; }"}
{"text": "Sekiranya array mempunyai bilangan elemen yang ganjil maka mulakan elemen pertama sebagai minimum dan maksimum", "code": "else { minmax . min = arr [ 0 ] ; minmax . max = arr [ 0 ] ;"}
{"text": "Tetapkan indeks permulaan untuk gelung", "code": "i = 1 ; }"}
{"text": "Dalam gelung sementara, pilih elemen dalam pasangan dan bandingkan pasangan dengan max dan min setakat ini", "code": "while ( i < n - 1 ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] > minmax . max ) minmax . max = arr [ i ] ; if ( arr [ i + 1 ] < minmax . min ) minmax . min = arr [ i + 1 ] ; } else { if ( arr [ i + 1 ] > minmax . max ) minmax . max = arr [ i + 1 ] ; if ( arr [ i ] < minmax . min ) minmax . min = arr [ i ] ; } i += 2 ;"}
{"text": "Kenaikan indeks sebanyak 2 kerana dua elemen diproses dalam gelung", "code": "} return minmax ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1000 , 11 , 445 , 1 , 330 , 3000 } ; int arr_size = 6 ; struct pair minmax = getMinMax ( arr , arr_size ) ; printf ( \" nMinimum ▁ element ▁ is ▁ % d \" , minmax . min ) ; printf ( \" nMaximum ▁ element ▁ is ▁ % d \" , minmax . max ) ; getchar ( ) ; }"}
{"text": "Program c untuk mencari bilangan lompatan minimum untuk mencapai hujung", "code": "#include <limits.h> NEW_LINE #include <stdio.h>"}
{"text": "Mengembalikan bilangan lompatan minimum untuk mencapai arr [h] dari arr [l]", "code": "int minJumps ( int arr [ ] , int l , int h ) {"}
{"text": "Kes asas: Apabila sumber dan destinasi sama", "code": "if ( h == l ) return 0 ;"}
{"text": "Apabila tiada yang dapat dicapai dari sumber yang diberikan", "code": "if ( arr [ l ] == 0 ) return INT_MAX ;"}
{"text": "Melintasi semua mata yang dapat dicapai dari arr [l]. Recursif Dapatkan bilangan lompatan minimum yang diperlukan untuk mencapai arr [H] dari titik -titik yang dapat dicapai ini.", "code": "int min = INT_MAX ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != INT_MAX && jumps + 1 < min ) min = jumps + 1 ; } return min ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach ▁ end ▁ is ▁ % d ▁ \" , minJumps ( arr , 0 , n - 1 ) ) ; return 0 ; }"}
{"text": "Mengembalikan panjang subarray terkecil dengan jumlah yang lebih besar daripada x. Sekiranya tidak ada subarray dengan jumlah yang diberikan, maka kembali n + 1", "code": "int smallestSubWithSum ( int arr [ ] , int n , int x ) {"}
{"text": "Memulakan panjang subarray terkecil seperti n + 1", "code": "int min_len = n + 1 ;"}
{"text": "Pilih setiap elemen sebagai titik permulaan", "code": "for ( int start = 0 ; start < n ; start ++ ) {"}
{"text": "Inisialisasi Jumlah Bermula Dengan Permulaan Semasa", "code": "int curr_sum = arr [ start ] ;"}
{"text": "Sekiranya elemen pertama itu lebih besar", "code": "if ( curr_sum > x ) return 1 ;"}
{"text": "Cuba titik akhir yang berbeza untuk permulaan curremt", "code": "for ( int end = start + 1 ; end < n ; end ++ ) {"}
{"text": "Tambahkan elemen terakhir ke jumlah semasa", "code": "curr_sum += arr [ end ] ;"}
{"text": "Sekiranya jumlah menjadi lebih daripada x dan panjang subarray ini lebih kecil daripada panjang terkecil semasa, kemas kini panjang terkecil (atau hasilnya)", "code": "if ( curr_sum > x && ( end - start + 1 ) < min_len ) min_len = ( end - start + 1 ) ; } } return min_len ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr1 [ ] = { 1 , 4 , 45 , 6 , 10 , 19 } ; int x = 51 ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int res1 = smallestSubWithSum ( arr1 , n1 , x ) ; ( res1 == n1 + 1 ) ? cout << \" Not ▁ possible STRNEWLINE \" : cout << res1 << endl ; int arr2 [ ] = { 1 , 10 , 5 , 2 , 7 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; x = 9 ; int res2 = smallestSubWithSum ( arr2 , n2 , x ) ; ( res2 == n2 + 1 ) ? cout << \" Not ▁ possible STRNEWLINE \" : cout << res2 << endl ; int arr3 [ ] = { 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; x = 280 ; int res3 = smallestSubWithSum ( arr3 , n3 , x ) ; ( res3 == n3 + 1 ) ? cout << \" Not ▁ possible STRNEWLINE \" : cout << res3 << endl ; return 0 ; }"}
{"text": "Program c untuk traversals pokok yang berbeza", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Memandangkan pokok binari, cetak nodnya mengikut traversal postorder \"bawah\".", "code": "void printPostorder ( struct node * node ) { if ( node == NULL ) return ;"}
{"text": "Mula -mula berulang di subtree kiri", "code": "printPostorder ( node -> left ) ;"}
{"text": "Kemudian berulang pada subtree yang betul", "code": "printPostorder ( node -> right ) ;"}
{"text": "sekarang berurusan dengan nod", "code": "printf ( \" % d ▁ \" , node -> data ) ; }"}
{"text": "Diberi pokok binari, cetak nodnya dalam inorder", "code": "void printInorder ( struct node * node ) { if ( node == NULL ) return ;"}
{"text": "Pertama berulang pada anak kiri", "code": "printInorder ( node -> left ) ;"}
{"text": "kemudian cetak data nod", "code": "printf ( \" % d ▁ \" , node -> data ) ;"}
{"text": "sekarang berulang pada anak yang betul", "code": "printInorder ( node -> right ) ; }"}
{"text": "Memandangkan pokok binari, cetak nodnya dalam preorder", "code": "void printPreorder ( struct node * node ) { if ( node == NULL ) return ;"}
{"text": "data cetak pertama nod", "code": "printf ( \" % d ▁ \" , node -> data ) ;"}
{"text": "kemudian berulang di sutree kiri", "code": "printPreorder ( node -> left ) ;"}
{"text": "sekarang berulang pada subtree yang betul", "code": "printPreorder ( node -> right ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Preorder traversal of binary tree is \" printPreorder ( root ) ; printf ( \" Inorder traversal of binary tree is \" printInorder ( root ) ; printf ( \" Postorder traversal of binary tree is \" printPostorder ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Nod pokok binari", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "Fungsi utiliti untuk membuat nod pokok binari baru dengan data yang diberikan", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; }"}
{"text": "Cetak pokok dalam cara LVR (inorder traversal).", "code": "void print ( struct Node * root ) { if ( root != NULL ) { print ( root -> left ) ; printf ( \" % d ▁ \" , root -> data ) ; print ( root -> right ) ; } }"}
{"text": "Fungsi utama yang memotong pokok binari.", "code": "struct Node * prune ( struct Node * root , int sum ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return NULL ;"}
{"text": "Berulang untuk subtrees kiri dan kanan", "code": "root -> left = prune ( root -> left , sum - root -> data ) ; root -> right = prune ( root -> right , sum - root -> data ) ;"}
{"text": "Jika kita mencapai daun yang datanya lebih kecil daripada jumlah, kita memadam daun. Satu perkara penting yang perlu diperhatikan ialah nod daun bukan boleh menjadi daun apabila chilrennya dipadam.", "code": "if ( root -> left == NULL && root -> right == NULL ) { if ( root -> data < sum ) { free ( root ) ; return NULL ; } } return root ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int k = 45 ; struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 12 ) ; root -> right -> right -> left = newNode ( 10 ) ; root -> right -> right -> left -> right = newNode ( 11 ) ; root -> left -> left -> right -> left = newNode ( 13 ) ; root -> left -> left -> right -> right = newNode ( 14 ) ; root -> left -> left -> right -> right -> left = newNode ( 15 ) ; printf ( \" Tree ▁ before ▁ truncation STRNEWLINE \" ) ; print ( root ) ;"}
{"text": "Program c untuk menggabungkan pelbagai saiz n ke dalam pelbagai saiz m + n yang lain", "code": "#include <stdio.h>"}
{"text": "Dengan asumsi - 1 dipenuhi untuk tempat di mana elemen tidak tersedia", "code": "#define NA  -1"}
{"text": "Berfungsi untuk memindahkan elemen m pada akhir array mplusn []", "code": "void moveToEnd ( int mPlusN [ ] , int size ) { int i = 0 , j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) if ( mPlusN [ i ] != NA ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } }"}
{"text": "Menggabungkan array n [] saiz n ke dalam array mplusn [] saiz m + n", "code": "int merge ( int mPlusN [ ] , int N [ ] , int m , int n ) { int i = n ;"}
{"text": "Indeks semasa I / P bahagian MPLUSN []", "code": "int j = 0 ;"}
{"text": "Indeks semasa n []", "code": "int k = 0 ;"}
{"text": "Indeks semasa output mplusn []", "code": "while ( k < ( m + n ) ) {"}
{"text": "Ambil elemen dari mplusn [] jika a) nilai elemen yang dipilih lebih kecil dan kami belum sampai ke akhir b) Kami telah mencapai akhir n []", "code": "if ( ( j == n ) || ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; }"}
{"text": "Jika tidak, ambil elemen dari n []", "code": "else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } }"}
{"text": "Utiliti yang mencetak array pada baris", "code": "void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Memulakan susunan", "code": "int mPlusN [ ] = { 2 , 8 , NA , NA , NA , 13 , NA , 15 , 20 } ; int N [ ] = { 5 , 7 , 9 , 25 } ; int n = sizeof ( N ) / sizeof ( N [ 0 ] ) ; int m = sizeof ( mPlusN ) / sizeof ( mPlusN [ 0 ] ) - n ;"}
{"text": "Gerakkan elemen m pada akhir mplusn", "code": "moveToEnd ( mPlusN , m + n ) ;"}
{"text": "Gabungkan n [] ke mplusn []", "code": "merge ( mPlusN , N , m , n ) ;"}
{"text": "Cetak mplusn yang dihasilkan", "code": "printArray ( mPlusN , m + n ) ; return 0 ; }"}
{"text": "Program c untuk melaksanakan pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencari maksimum antara dua nombor", "code": "int max ( int num1 , int num2 ) { return ( num1 > num2 ) ? num1 : num2 ; }"}
{"text": "Berfungsi untuk mencari minimum antara dua nombor", "code": "int min ( int num1 , int num2 ) { return ( num1 > num2 ) ? num2 : num1 ; }"}
{"text": "Berfungsi untuk mengembalikan kiraan nombor tersebut", "code": "int getCount ( int n , int k ) {"}
{"text": "Untuk nombor 1 - digit, kiraannya adalah 10 tanpa mengira k", "code": "if ( n == 1 ) return 10 ;"}
{"text": "DP [J] menyimpan bilangan nombor I - angka yang berakhir dengan j", "code": "int dp [ 11 ] = { 0 } ;"}
{"text": "Menyimpan hasil panjang i", "code": "int next [ 11 ] = { 0 } ;"}
{"text": "Mulakan kiraan untuk nombor 1 - digit", "code": "for ( int i = 1 ; i <= 9 ; i ++ ) dp [ i ] = 1 ;"}
{"text": "Mengira nilai untuk mengira digit lebih besar daripada 1", "code": "for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) {"}
{"text": "Cari julat nombor yang dibenarkan jika digit terakhir adalah j", "code": "int l = max ( 0 , ( j - k ) ) ; int r = min ( 9 , ( j + k ) ) ;"}
{"text": "Lakukan kemas kini pelbagai", "code": "next [ l ] += dp [ j ] ; next [ r + 1 ] -= dp [ j ] ; }"}
{"text": "Jumlah awalan untuk mencari kiraan sebenar nombor angka i yang berakhir dengan j", "code": "for ( int j = 1 ; j <= 9 ; j ++ ) next [ j ] += next [ j - 1 ] ;"}
{"text": "Kemas kini DP []", "code": "for ( int j = 0 ; j < 10 ; j ++ ) { dp [ j ] = next [ j ] ; next [ j ] = 0 ; } }"}
{"text": "Menyimpan jawapan terakhir", "code": "int count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ i ] ;"}
{"text": "Kembalikan jawapan terakhir", "code": "return count ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 2 , k = 1 ; printf ( \" % d \" , getCount ( n , k ) ) ; }"}
{"text": "Program c untuk mengira inversi dalam pelbagai", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" ▁ Number ▁ of ▁ inversions ▁ are ▁ % d ▁ STRNEWLINE \" , getInvCount ( arr , n ) ) ; return 0 ; }"}
{"text": "C kod untuk mencari dua elemen yang jumlahnya paling dekat dengan sifar", "code": "# include <stdio.h> NEW_LINE # include <stdlib.h> NEW_LINE # include <math.h> NEW_LINE void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ;"}
{"text": "Array harus mempunyai sekurang -kurangnya dua elemen", "code": "if ( arr_size < 2 ) { printf ( \" Invalid ▁ Input \" ) ; return ; }"}
{"text": "Inisialisasi nilai", "code": "min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( abs ( min_sum ) > abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } printf ( \" ▁ The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are ▁ % d ▁ and ▁ % d \" , arr [ min_l ] , arr [ min_r ] ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 60 , -10 , 70 , -80 , 85 } ; minAbsSumPair ( arr , 6 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mencari kesatuan dua tatasusunan yang disusun", "code": "#include <stdio.h>"}
{"text": "Fungsi cetakan kesatuan arr1 [] dan arr2 [] m ialah bilangan elemen dalam arr1 [] n ialah bilangan elemen dalam arr2 []", "code": "void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) printf ( \" ▁ % d ▁ \" , arr1 [ i ++ ] ) ; else if ( arr2 [ j ] < arr1 [ i ] ) printf ( \" ▁ % d ▁ \" , arr2 [ j ++ ] ) ; else { printf ( \" ▁ % d ▁ \" , arr2 [ j ++ ] ) ; i ++ ; } }"}
{"text": "Cetak elemen baki array yang lebih besar", "code": "while ( i < m ) printf ( \" ▁ % d ▁ \" , arr1 [ i ++ ] ) ; while ( j < n ) printf ( \" ▁ % d ▁ \" , arr2 [ j ++ ] ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printUnion ( arr1 , arr2 , m , n ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program C untuk mencari persimpangan dua tatasusunan yang disusun", "code": "#include <stdio.h>"}
{"text": "Fungsi Prints persimpangan arr1 [] dan arr2 [] m ialah bilangan elemen dalam arr1 [] n ialah bilangan elemen dalam arr2 []", "code": "void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else { printf ( \" ▁ % d ▁ \" , arr2 [ j ++ ] ) ; i ++ ; } } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ;"}
{"text": "Fungsi panggilan", "code": "printIntersection ( arr1 , arr2 , m , n ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mencari daun jumlah maksimum ke laluan akar di pokok binari", "code": "#include <limits.h> NEW_LINE #include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Struktur nod pokok", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi utiliti yang mencetak semua nod di jalan dari akar ke sasaran_leaf", "code": "bool printPath ( struct node * root , struct node * target_leaf ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return false ;"}
{"text": "kembali benar jika nod ini adalah sasaran_leaf atau daun sasaran hadir di salah satu keturunannya", "code": "if ( root == target_leaf || printPath ( root -> left , target_leaf ) || printPath ( root -> right , target_leaf ) ) { printf ( \" % d ▁ \" , root -> data ) ; return true ; } return false ; }"}
{"text": "Fungsi ini menetapkan target_leaf_ref untuk merujuk nod daun jumlah laluan maksimum. Juga, mengembalikan max_sum menggunakan max_sum_ref", "code": "void getTargetLeaf ( struct node * node , int * max_sum_ref , int curr_sum , struct node * * target_leaf_ref ) { if ( node == NULL ) return ;"}
{"text": "Kemas kini jumlah semasa untuk memegang jumlah nod pada jalan dari akar ke nod ini", "code": "curr_sum = curr_sum + node -> data ;"}
{"text": "Sekiranya ini adalah nod daun dan jalan ke nod ini mempunyai jumlah maksimum setakat ini, maka buat nod ini sasaran_leaf", "code": "if ( node -> left == NULL && node -> right == NULL ) { if ( curr_sum > * max_sum_ref ) { * max_sum_ref = curr_sum ; * target_leaf_ref = node ; } }"}
{"text": "Sekiranya ini bukan nod daun, kemudian berulang untuk mencari target_leaf", "code": "getTargetLeaf ( node -> left , max_sum_ref , curr_sum , target_leaf_ref ) ; getTargetLeaf ( node -> right , max_sum_ref , curr_sum , target_leaf_ref ) ; }"}
{"text": "Mengembalikan jumlah maksimum dan mencetak nod pada laluan jumlah maksimum", "code": "int maxSumPath ( struct node * node ) {"}
{"text": "Kes asas", "code": "if ( node == NULL ) return 0 ; struct node * target_leaf ; int max_sum = INT_MIN ;"}
{"text": "cari daun sasaran dan jumlah maksimum", "code": "getTargetLeaf ( node , & max_sum , 0 , & target_leaf ) ;"}
{"text": "Cetak jalan dari akar ke daun sasaran", "code": "printPath ( node , target_leaf ) ;"}
{"text": "Kembalikan jumlah maksimum", "code": "return max_sum ; }"}
{"text": "Fungsi utiliti untuk membuat nod pokok binari baru", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; }"}
{"text": "Fungsi pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( -2 ) ; root -> right = newNode ( 7 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( -4 ) ; printf ( \" Following ▁ are ▁ the ▁ nodes ▁ on ▁ the ▁ maximum ▁ \" \" sum ▁ path ▁ STRNEWLINE \" ) ; int sum = maxSumPath ( root ) ; printf ( \" Sum of the nodes is % d \" , sum ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk menyusun array dengan 0, 1 dan 2 dalam satu pas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk menukar * a dan * b", "code": "void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; }"}
{"text": "Sort Array Input, array diandaikan mempunyai nilai dalam {0, 1, 2}", "code": "void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : swap ( & a [ lo ++ ] , & a [ mid ++ ] ) ; break ; case 1 : mid ++ ; break ; case 2 : swap ( & a [ mid ] , & a [ hi -- ] ) ; break ; } } }"}
{"text": "Fungsi utiliti untuk mencetak array arr []", "code": "void printArray ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" n \" ) ; }"}
{"text": "Program Pemandu untuk Menguji", "code": "int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int i ; sort012 ( arr , arr_size ) ; printf ( \" array ▁ after ▁ segregation ▁ \" ) ; printArray ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program C Untuk mencari subarray yang tidak disusun panjang minimum, menyusun yang menjadikan array lengkap disusun", "code": "#include <stdio.h> NEW_LINE void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ;"}
{"text": "Langkah 1 (a) Algo di atas", "code": "for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { printf ( \" The ▁ complete ▁ array ▁ is ▁ sorted \" ) ; return ; }"}
{"text": "Langkah 1 (b) Algo di atas", "code": "for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; }"}
{"text": "Langkah 2 (a) Algo di atas", "code": "max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; }"}
{"text": "Langkah 2 (b) Algo di atas", "code": "for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } }"}
{"text": "Langkah 2 (c) Algo di atas", "code": "for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } }"}
{"text": "Langkah 3 dari algo di atas", "code": "printf ( \" ▁ The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ the ▁ given ▁ array ▁ \" \" ▁ sorted ▁ lies ▁ between ▁ the ▁ indees ▁ % d ▁ and ▁ % d \" , s , e ) ; return ; } int main ( ) { int arr [ ] = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printUnsorted ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mengira bilangan segitiga yang boleh dibentuk dari array yang diberikan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Fungsi berikut diperlukan untuk fungsi perpustakaan QSORT (). Rujuk www. cplusplus. com / rujukan / clibrary / cstdlib / qsort /", "code": "http : int comp ( const void * a , const void * b ) { return * ( int * ) a > * ( int * ) b ; }"}
{"text": "Berfungsi untuk mengira semua segi tiga yang mungkin dengan elemen arr []", "code": "int findNumberOfTriangles ( int arr [ ] , int n ) {"}
{"text": "Susunkan elemen array dalam urutan yang tidak menurun", "code": "qsort ( arr , n , sizeof ( arr [ 0 ] ) , comp ) ;"}
{"text": "Memulakan kiraan segitiga", "code": "int count = 0 ;"}
{"text": "Betulkan elemen pertama. Kita perlu berjalan sehingga n - 3 kerana dua elemen lain dipilih dari arr [i + 1. . n - 1]", "code": "for ( int i = 0 ; i < n - 2 ; ++ i ) {"}
{"text": "Inisialisasi indeks elemen ketiga paling tepat", "code": "int k = i + 2 ;"}
{"text": "Betulkan elemen kedua", "code": "for ( int j = i + 1 ; j < n ; ++ j ) {"}
{"text": "Cari elemen paling kanan yang lebih kecil daripada jumlah dua elemen tetap yang penting untuk diperhatikan di sini, kami menggunakan nilai sebelumnya k. Jika nilai arr [i] + arr [j - 1] lebih besar daripada arr [k], maka arr [i] + arr [j] mestilah lebih besar daripada k, kerana array disusun.", "code": "while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ;"}
{"text": "Jumlah bilangan segitiga yang mungkin boleh dibentuk dengan dua elemen tetap adalah k - j - 1. Kedua -dua elemen tetap adalah arr [i] dan arr [j]. Semua elemen antara arr [j + 1] / ke arr [k - 1] boleh membentuk segitiga dengan arr [i] dan arr [j]. Satu dikurangkan dari k kerana k ditingkatkan satu tambahan di atas sementara gelung. k akan sentiasa lebih besar daripada j. Jika j menjadi sama dengan k, maka di atas gelung akan meningkat k, kerana arr [k] + arr [i] selalu lebih besar daripada arr [k]", "code": "if ( k > j ) count += k - j - 1 ; } } return count ; }"}
{"text": "Program pemacu untuk menguji di atas fungsiarr [J + 1]", "code": "int main ( ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Total ▁ number ▁ of ▁ triangles ▁ possible ▁ is ▁ % d ▁ \" , findNumberOfTriangles ( arr , size ) ) ; return 0 ; }"}
{"text": "Program C untuk melaksanakan carian linear dalam array yang tidak disusun", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk melaksanakan operasi carian", "code": "int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return -1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 12 , 34 , 10 , 6 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Menggunakan elemen terakhir sebagai elemen carian", "code": "int key = 40 ; int position = findElement ( arr , n , key ) ; if ( position == - 1 ) printf ( \" Element ▁ not ▁ found \" ) ; else printf ( \" Element ▁ Found ▁ at ▁ Position : ▁ % d \" , position + 1 ) ; return 0 ; }"}
{"text": "Program C untuk melaksanakan operasi sisipan dalam array yang tidak disusun.", "code": "#include <stdio.h>"}
{"text": "Masukkan kunci dalam ARR [] kapasiti yang diberikan. n ialah saiz semasa ARR []. Fungsi ini mengembalikan n + 1 jika penyisipan berjaya, lain n.", "code": "int insertSorted ( int arr [ ] , int n , int key , int capacity ) {"}
{"text": "Tidak dapat memasukkan lebih banyak elemen jika n sudah lebih daripada atau sama dengan kapcity", "code": "if ( n >= capacity ) return n ; arr [ n ] = key ; return ( n + 1 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ 20 ] = { 12 , 16 , 20 , 40 , 50 , 70 } ; int capacity = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 6 ; int i , key = 26 ; printf ( \" Before Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ;"}
{"text": "Memasukkan kekunci", "code": "n = insertSorted ( arr , n , key , capacity ) ; printf ( \" After Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }"}
{"text": "Program c untuk melaksanakan operasi memadam dalam pelbagai yang tidak disusun", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk melaksanakan operasi carian", "code": "int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }"}
{"text": "Berfungsi untuk memadam elemen", "code": "int deleteElement ( int arr [ ] , int n , int key ) {"}
{"text": "Cari kedudukan elemen yang hendak dipadam", "code": "int pos = findElement ( arr , n , key ) ; if ( pos == - 1 ) { printf ( \" Element ▁ not ▁ found \" ) ; return n ; }"}
{"text": "Memadam elemen", "code": "int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int i ; int arr [ ] = { 10 , 50 , 30 , 40 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 30 ; printf ( \" Array ▁ before ▁ deletion STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; n = deleteElement ( arr , n , key ) ; printf ( \" Array after deletion \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }"}
{"text": "Program C untuk melaksanakan carian binari dalam array yang disusun", "code": "#include <stdio.h>"}
{"text": "berfungsi untuk melaksanakan carian binari", "code": "int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ;"}
{"text": "rendah + (tinggi - rendah) / 2;", "code": "if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }"}
{"text": "Kod pemacu biarkan kami mencari 3 di bawah array", "code": "int main ( ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n , key ; n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; key = 10 ; printf ( \" Index : ▁ % d STRNEWLINE \" , binarySearch ( arr , 0 , n - 1 , key ) ) ; return 0 ; }"}
{"text": "Program C untuk melaksanakan operasi sisipan dalam pelbagai disusun.", "code": "#include <stdio.h>"}
{"text": "Masukkan kunci dalam ARR [] kapasiti yang diberikan. n ialah saiz semasa ARR []. Fungsi ini mengembalikan n + 1 jika penyisipan berjaya, lain n.", "code": "int insertSorted ( int arr [ ] , int n , int key , int capacity ) {"}
{"text": "Tidak dapat memasukkan lebih banyak elemen jika n sudah lebih daripada atau sama dengan kapcity", "code": "if ( n >= capacity ) return n ; int i ; for ( i = n - 1 ; ( i >= 0 && arr [ i ] > key ) ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ 20 ] = { 12 , 16 , 20 , 40 , 50 , 70 } ; int capacity = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 6 ; int i , key = 26 ; printf ( \" Before Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ;"}
{"text": "Memasukkan kekunci", "code": "n = insertSorted ( arr , n , key , capacity ) ; printf ( \" After Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }"}
{"text": "Program c untuk melaksanakan operasi memadam dalam pelbagai disusun", "code": "#include <stdio.h>"}
{"text": "Untuk mencari ley untuk dipadam", "code": "int binarySearch ( int arr [ ] , int low , int high , int key ) ; int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }"}
{"text": "Berfungsi untuk memadam elemen", "code": "int deleteElement ( int arr [ ] , int n , int key ) {"}
{"text": "Cari kedudukan elemen yang hendak dipadam", "code": "int pos = binarySearch ( arr , 0 , n - 1 , key ) ; if ( pos == -1 ) { printf ( \" Element ▁ not ▁ found \" ) ; return n ; }"}
{"text": "Memadam elemen", "code": "int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int i ; int arr [ ] = { 10 , 20 , 30 , 40 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 30 ; printf ( \" Array ▁ before ▁ deletion STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; n = deleteElement ( arr , n , key ) ; printf ( \" Array after deletion \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Program c untuk mencari indeks keseimbangan pelbagai", "code": "#include <stdio.h>"}
{"text": "berfungsi untuk mencari indeks keseimbangan", "code": "int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ;"}
{"text": "Periksa indeks satu demi satu sehingga indeks keseimbangan dijumpai", "code": "for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ;"}
{"text": "Dapatkan jumlah kiri", "code": "for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ;"}
{"text": "Dapatkan jumlah yang betul", "code": "for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ;"}
{"text": "Sekiranya leftsum dan rightsum sama, maka kita sudah selesai", "code": "if ( leftsum == rightsum ) return i ; }"}
{"text": "Pulangan - 1 Sekiranya tiada indeks keseimbangan dijumpai", "code": "return -1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d \" , equilibrium ( arr , arr_size ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mencari indeks keseimbangan pelbagai", "code": "#include <stdio.h>"}
{"text": "berfungsi untuk mencari indeks keseimbangan", "code": "int equilibrium ( int arr [ ] , int n ) {"}
{"text": "memulakan jumlah keseluruhan array", "code": "int sum = 0 ;"}
{"text": "Inisialisasi kiri", "code": "int leftsum = 0 ;"}
{"text": "Cari jumlah keseluruhan array", "code": "for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) {"}
{"text": "Jumlah sekarang Jumlah Jumlah untuk Indeks i", "code": "sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; }"}
{"text": "Sekiranya tiada indeks keseimbangan dijumpai, maka kembali 0", "code": "return -1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" First ▁ equilibrium ▁ index ▁ is ▁ % d \" , equilibrium ( arr , arr_size ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Fungsi untuk mendapatkan indeks siling x dalam arr [rendah. . tinggi]", "code": "int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ;"}
{"text": "Sekiranya x lebih kecil daripada atau sama dengan elemen pertama, maka kembalikan elemen pertama", "code": "if ( x <= arr [ low ] ) return low ;"}
{"text": "Jika tidak, cari nilai linear secara linear", "code": "for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ;"}
{"text": "jika x terletak di antara arr [i] dan arr [i + 1] termasuk arr [i + 1], kemudian kembali arr [i + 1]", "code": "if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; }"}
{"text": "Sekiranya kita sampai di sini maka x lebih besar daripada elemen terakhir array, kembali - 1 dalam kes ini", "code": "return -1 ; }"}
{"text": "Program pemacu untuk menyemak fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) printf ( \" Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ \" , x ) ; else printf ( \" ceiling ▁ of ▁ % d ▁ is ▁ % d \" , x , arr [ index ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Fungsi untuk mendapatkan indeks siling x dalam arr [rendah. . tinggi]", "code": "int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ;"}
{"text": "Sekiranya x lebih kecil daripada atau sama dengan elemen pertama, maka kembalikan elemen pertama", "code": "if ( x <= arr [ low ] ) return low ;"}
{"text": "Sekiranya x lebih besar daripada elemen terakhir, maka kembali - 1", "code": "if ( x > arr [ high ] ) return -1 ;"}
{"text": "Dapatkan indeks elemen tengah ARR [rendah. . tinggi]", "code": "mid = ( low + high ) / 2 ;"}
{"text": "Sekiranya x sama dengan elemen tengah, maka kembali pertengahan", "code": "if ( arr [ mid ] == x ) return mid ;"}
{"text": "Jika x lebih besar daripada arr [pertengahan], maka sama ada arr [pertengahan + 1] adalah siling x atau siling terletak pada arr [pertengahan + 1. . tinggi]", "code": "else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; }"}
{"text": "Jika x lebih kecil daripada arr [pertengahan], maka sama ada arr [pertengahan] adalah siling x atau siling terletak pada arr [rendah ... pertengahan - 1]", "code": "else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }"}
{"text": "Program pemacu untuk menyemak fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 20 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) printf ( \" Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ \" , x ) ; else printf ( \" ceiling ▁ of ▁ % d ▁ is ▁ % d \" , x , arr [ index ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Penyelesaian naif untuk mencari jika terdapat pasangan dalam [0. N - 1] dengan jumlah yang diberikan.", "code": "#include <stdio.h> NEW_LINE int isPairSum ( int A [ ] , int N , int X ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) {"}
{"text": "sama dengan i dan j bermaksud elemen yang sama", "code": "if ( i == j ) continue ;"}
{"text": "pasangan ada", "code": "if ( A [ i ] + A [ j ] == X ) return true ;"}
{"text": "kerana array disusun", "code": "if ( A [ i ] + A [ j ] > X ) break ; } }"}
{"text": "Tiada pasangan yang dijumpai dengan jumlah yang diberikan.", "code": "return 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 3 , 5 , 9 , 2 , 8 , 10 , 11 } ; int val = 17 ; int arrSize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" % d \" , isPairSum ( arr , arrSize , val ) ) ; return 0 ; }"}
{"text": "Penyelesaian berasaskan teknik dua penunjuk untuk mencari jika terdapat pasangan dalam [0. N - 1] dengan jumlah yang diberikan.", "code": "int isPairSum ( int A [ ] , int N , int X ) {"}
{"text": "mewakili penunjuk pertama", "code": "int i = 0 ;"}
{"text": "mewakili penunjuk kedua", "code": "int j = N - 1 ; while ( i < j ) {"}
{"text": "Sekiranya kita menjumpai pasangan", "code": "if ( A [ i ] + A [ j ] == X ) return 1 ;"}
{"text": "Sekiranya jumlah elemen pada petunjuk semasa kurang, kita bergerak ke arah nilai yang lebih tinggi dengan melakukan i ++", "code": "else if ( A [ i ] + A [ j ] < X ) i ++ ;"}
{"text": "Sekiranya jumlah elemen pada petunjuk semasa lebih banyak, kita bergerak ke arah nilai yang lebih rendah dengan melakukan j -", "code": "else j -- ; } return 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Perisytiharan Array", "code": "int arr [ ] = { 3 , 5 , 9 , 2 , 8 , 10 , 11 } ;"}
{"text": "nilai untuk dicari", "code": "int val = 17 ;"}
{"text": "saiz array", "code": "int arrSize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" % d \" , isPairSum ( arr , arrSize , val ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari masa minimum yang mungkin oleh casis kereta untuk disiapkan", "code": "#include <stdio.h> NEW_LINE #define NUM_LINE  2 NEW_LINE #define NUM_STATION  4"}
{"text": "Fungsi utiliti untuk mencari minimum dua nombor", "code": "int min ( int a , int b ) { return a < b ? a : b ; } int carAssembly ( int a [ ] [ NUM_STATION ] , int t [ ] [ NUM_STATION ] , int * e , int * x ) { int T1 [ NUM_STATION ] , T2 [ NUM_STATION ] , i ;"}
{"text": "masa yang diambil untuk meninggalkan stesen pertama dalam baris 1", "code": "T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;"}
{"text": "masa yang diambil untuk meninggalkan stesen pertama dalam baris 2", "code": "T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;"}
{"text": "Isi Jadual T1 [] dan T2 [] menggunakan hubungan rekursif di atas", "code": "for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; }"}
{"text": "Pertimbangkan masa keluar dan minimum retutn", "code": "return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int a [ ] [ NUM_STATION ] = { { 4 , 5 , 3 , 2 } , { 2 , 10 , 1 , 4 } } ; int t [ ] [ NUM_STATION ] = { { 0 , 7 , 4 , 5 } , { 0 , 9 , 2 , 8 } } ; int e [ ] = { 10 , 12 } , x [ ] = { 18 , 7 } ; printf ( \" % d \" , carAssembly ( a , t , e , x ) ) ; return 0 ; }"}
{"text": "Program berasaskan pengaturcaraan yang dinamik untuk mencari sisipan nombor minimum yang diperlukan untuk membuat palindrom rentetan", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Fungsi utiliti untuk mencari minimum dua bilangan bulat", "code": "int min ( int a , int b ) { return a < b ? a : b ; }"}
{"text": "Fungsi DP untuk mencari bilangan sisipan minimum", "code": "int findMinInsertionsDP ( char str [ ] , int n ) {"}
{"text": "Buat jadual saiz n * n. Jadual [i] [j] akan menyimpan bilangan sisipan minimum yang diperlukan untuk menukar str [i. . J] kepada palindrome.", "code": "int table [ n ] [ n ] , l , h , gap ; memset ( table , 0 , sizeof ( table ) ) ;"}
{"text": "Isi jadual", "code": "for ( gap = 1 ; gap < n ; ++ gap ) for ( l = 0 , h = gap ; h < n ; ++ l , ++ h ) table [ l ] [ h ] = ( str [ l ] == str [ h ] ) ? table [ l + 1 ] [ h - 1 ] : ( min ( table [ l ] [ h - 1 ] , table [ l + 1 ] [ h ] ) + 1 ) ;"}
{"text": "Kembalikan bilangan sisipan minimum untuk STR [0 .. n - 1]", "code": "return table [ 0 ] [ n - 1 ] ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas.", "code": "int main ( ) { char str [ ] = \" geeks \" ; printf ( \" % d \" , findMinInsertionsDP ( str , strlen ( str ) ) ) ; return 0 ; }"}
{"text": "Pelaksanaan rekursi naif masalah set bebas terbesar", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Fungsi utiliti untuk mencari maksimum dua bilangan bulat", "code": "int max ( int x , int y ) { return ( x > y ) ? x : y ; }"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Fungsi mengembalikan saiz set bebas terbesar dalam pokok binari yang diberikan", "code": "int LISS ( struct node * root ) { if ( root == NULL ) return 0 ;"}
{"text": "Hitung saiz tidak termasuk nod semasa", "code": "int size_excl = LISS ( root -> left ) + LISS ( root -> right ) ;"}
{"text": "Hitung saiz termasuk nod semasa", "code": "int size_incl = 1 ; if ( root -> left ) size_incl += LISS ( root -> left -> left ) + LISS ( root -> left -> right ) ; if ( root -> right ) size_incl += LISS ( root -> right -> left ) + LISS ( root -> right -> right ) ;"}
{"text": "Kembalikan maksimum dua saiz", "code": "return max ( size_incl , size_excl ) ; }"}
{"text": "Fungsi utiliti untuk membuat nod", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Mari kita buat pokok yang diberikan dalam rajah di atas", "code": "struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printf ( \" Size ▁ of ▁ the ▁ Largest ▁ Independent ▁ Set ▁ is ▁ % d ▁ \" , LISS ( root ) ) ; return 0 ; }"}
{"text": "Fungsi ini mengandaikan bahawa ARR [] disusun dalam peningkatan urutan mengikut nilai pertama (atau lebih kecil) secara berpasangan.", "code": "int maxChainLength ( struct pair arr [ ] , int n ) { int i , j , max = 0 ; int * mcl = ( int * ) malloc ( sizeof ( int ) * n ) ;"}
{"text": "Mulakan nilai MCL (panjang rantai maksimum) untuk semua indeks", "code": "for ( i = 0 ; i < n ; i ++ ) mcl [ i ] = 1 ;"}
{"text": "Kirakan nilai panjang rantai yang dioptimumkan dengan cara bawah", "code": "for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] . a > arr [ j ] . b && mcl [ i ] < mcl [ j ] + 1 ) mcl [ i ] = mcl [ j ] + 1 ;"}
{"text": "Pilih maksimum semua nilai MCL", "code": "for ( i = 0 ; i < n ; i ++ ) if ( max < mcl [ i ] ) max = mcl [ i ] ; free ( mcl ) ; return max ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct pair arr [ ] = { { 5 , 24 } , { 15 , 25 } , { 27 , 40 } , { 50 , 60 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Length ▁ of ▁ maximum ▁ size ▁ chain ▁ is ▁ % d STRNEWLINE \" , maxChainLength ( arr , n ) ) ; return 0 ; }"}
{"text": "Penyelesaian pengaturcaraan dinamik untuk masalah pembahagian palindrome", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return ( a < b ) ? a : b ; }"}
{"text": "Mengembalikan bilangan minimum pemotongan yang diperlukan untuk memisahkan rentetan supaya setiap bahagian adalah palindrome", "code": "int minPalPartion ( char * str ) {"}
{"text": "Dapatkan panjang tali", "code": "int n = strlen ( str ) ;"}
{"text": "Buat dua tatasusunan untuk membina penyelesaian dengan cara bawah C [i] [j] = bilangan minimum pemotongan yang diperlukan untuk pembahagian palindrome substring str [i. . j] p [i] [j] = Benar jika substring str [i. . j] adalah palindrome, lain -lain nota palsu bahawa c [i] [j] adalah 0 jika p [i] [j] adalah benar", "code": "int C [ n ] [ n ] ; bool P [ n ] [ n ] ;"}
{"text": "Pembolehubah gelung yang berbeza", "code": "int i , j , k , L ;"}
{"text": "Setiap substring panjang 1 adalah palindrome", "code": "for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; }"}
{"text": "L adalah panjang substring. Bina penyelesaian dengan cara bawah dengan mempertimbangkan semua substrings panjang bermula dari 2 hingga n. Struktur gelung sama seperti masalah pendaraban rantai matriks (lihat https: www. Geeksforgeeks.", "code": "for ( L = 2 ; L <= n ; L ++ ) {"}
{"text": "Untuk substring panjang L, tetapkan indeks permulaan yang mungkin berbeza", "code": "for ( i = 0 ; i < n - L + 1 ; i ++ ) {"}
{"text": "Tetapkan indeks akhir", "code": "j = i + L - 1 ;"}
{"text": "Jika L adalah 2, maka kita hanya perlu membandingkan dua aksara. Lain perlu memeriksa dua aksara sudut dan nilai p [i + 1] [j - 1]", "code": "if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] ) ; else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ] ;"}
{"text": "Jika str [i. . J] adalah palindrome, maka C [i] [j] adalah 0", "code": "if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else {"}
{"text": "Buat potongan di setiap lokasi yang mungkin bermula dari saya ke J, dan dapatkan potongan kos minimum.", "code": "C [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } }"}
{"text": "Kembalikan nilai potong min untuk rentetan lengkap. i. e. , str [0 .. n - 1]", "code": "return C [ 0 ] [ n - 1 ] ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char str [ ] = \" ababbbabbababa \" ; printf ( \" Min ▁ cuts ▁ needed ▁ for ▁ Palindrome ▁ Partitioning ▁ is ▁ % d \" , minPalPartion ( str ) ) ; return 0 ; }"}
{"text": "Program C untuk Heuristik Bad Heuristik Boyer Moore String Algoritma", "code": "# include <limits.h> NEW_LINE # include <string.h> NEW_LINE # include <stdio.h> NEW_LINE # define NO_OF_CHARS  256"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Fungsi pra -proses untuk heuristik watak buruk Boyer Moore", "code": "void badCharHeuristic ( char * str , int size , int badchar [ NO_OF_CHARS ] ) { int i ;"}
{"text": "Memulakan semua kejadian sebagai - 1", "code": "for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) badchar [ i ] = -1 ;"}
{"text": "Isi nilai sebenar kejadian terakhir watak", "code": "for ( i = 0 ; i < size ; i ++ ) badchar [ ( int ) str [ i ] ] = i ; }"}
{"text": "Fungsi carian corak yang menggunakan heuristik watak buruk dari algoritma Boyer Moore", "code": "void search ( char * txt , char * pat ) { int m = strlen ( pat ) ; int n = strlen ( txt ) ; int badchar [ NO_OF_CHARS ] ;"}
{"text": "Isi pelbagai watak buruk dengan memanggil fungsi preprocessing badcharheuristik () untuk corak yang diberikan", "code": "badCharHeuristic ( pat , m , badchar ) ;"}
{"text": "s adalah peralihan corak berkenaan dengan teks", "code": "int s = 0 ; while ( s <= ( n - m ) ) { int j = m - 1 ;"}
{"text": "Terus mengurangkan indeks j corak manakala watak corak dan teks sepadan dengan shift ini", "code": "while ( j >= 0 && pat [ j ] == txt [ s + j ] ) j -- ;"}
{"text": "Sekiranya corak hadir pada peralihan semasa, maka indeks j akan menjadi - 1 selepas gelung di atas", "code": "if ( j < 0 ) { printf ( \" pattern occurs at shift = % d \""}
{"text": "Peralih corak supaya watak seterusnya dalam teks sejajar dengan kejadian terakhir dalam coraknya. Keadaan s + m <n diperlukan untuk kes apabila corak berlaku pada akhir teks", "code": "s += ( s + m < n ) ? m - badchar [ txt [ s + m ] ] : 1 ; } else"}
{"text": "Pergeseran corak supaya watak buruk dalam teks sejajar dengan kejadian terakhir dalam coraknya. Fungsi maksimum digunakan untuk memastikan kita mendapat peralihan positif. Kita mungkin mendapat peralihan negatif jika kejadian terakhir yang buruk dalam corak berada di sebelah kanan watak semasa.", "code": "s += max ( 1 , j - badchar [ txt [ s + j ] ] ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char txt [ ] = \" ABAAABCD \" ; char pat [ ] = \" ABC \" ; search ( txt , pat ) ; return 0 ; }"}
{"text": "Program rekursif untuk mencari perbezaan antara jumlah nod pada tahap ganjil dan jumlah pada tahap bahkan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Fungsi utiliti untuk memperuntukkan nod pokok baru dengan data yang diberikan", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; }"}
{"text": "Fungsi utama yang mengembalikan perbezaan antara nod yang ganjil dan bahkan tahap", "code": "int getLevelDiff ( struct node * root ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return 0 ;"}
{"text": "Perbezaan untuk root adalah data root - perbezaan untuk subtree kiri - perbezaan untuk subtree kanan", "code": "return root -> data - getLevelDiff ( root -> left ) - getLevelDiff ( root -> right ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct node * root = newNode ( 5 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; root -> left -> right -> left = newNode ( 3 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 7 ) ; printf ( \" % d ▁ is ▁ the ▁ required ▁ difference STRNEWLINE \" , getLevelDiff ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Memandangkan pokok dan jumlah, kembali benar jika terdapat jalan dari akar ke daun, sehingga menambah semua nilai di sepanjang jalan sama dengan jumlah yang diberikan. Strategi: Kurangkan nilai nod dari jumlah semasa berulang, dan periksa untuk melihat apakah jumlahnya adalah 0 apabila anda kehabisan pokok.", "code": "bool hasPathSum ( struct node * node , int sum ) { if ( node == NULL ) { return ( sum == 0 ) ; } else { bool ans = 0 ; int subSum = sum - node -> data ; if ( subSum == 0 && node -> left == NULL && node -> right == NULL ) return 1 ; if ( node -> left ) ans = ans || hasPathSum ( node -> left , subSum ) ; if ( node -> right ) ans = ans || hasPathSum ( node -> right , subSum ) ; return ans ; } }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int sum = 21 ;"}
{"text": "Pokok binari yang dibina adalah 10 / \\ 8 2 / \\ / 3 5 2", "code": "struct node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ; root -> left -> right = newnode ( 5 ) ; root -> right -> left = newnode ( 2 ) ; if ( hasPathSum ( root , sum ) ) printf ( \" There ▁ is ▁ a ▁ root - to - leaf ▁ path ▁ with ▁ sum ▁ % d \" , sum ) ; else printf ( \" There ▁ is ▁ no ▁ root - to - leaf ▁ path ▁ with ▁ sum ▁ % d \" , sum ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mencari jumlah semua laluan dari akar ke daun", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ;"}
{"text": "berfungsi untuk memperuntukkan nod baru dengan data yang diberikan", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; }"}
{"text": "Mengembalikan jumlah semua akar ke laluan daun. Parameter pertama adalah akar subtree semasa, parameter kedua adalah nilai bilangan yang dibentuk oleh nod dari akar ke nod ini", "code": "int treePathsSumUtil ( struct node * root , int val ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return 0 ;"}
{"text": "Kemas kini Val", "code": "val = ( val * 10 + root -> data ) ;"}
{"text": "Sekiranya nod semasa adalah daun, kembalikan nilai semasa val", "code": "if ( root -> left == NULL && root -> right == NULL ) return val ;"}
{"text": "jumlah nilai untuk subtree kiri dan kanan", "code": "return treePathsSumUtil ( root -> left , val ) + treePathsSumUtil ( root -> right , val ) ; }"}
{"text": "Fungsi pembalut di atas Treepathssumutil ()", "code": "int treePathsSum ( struct node * root ) {"}
{"text": "Lulus nilai awal sebagai 0 kerana tidak ada akar di atas", "code": "return treePathsSumUtil ( root , 0 ) ; }"}
{"text": "Fungsi pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct node * root = newNode ( 6 ) ; root -> left = newNode ( 3 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 2 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 4 ) ; root -> left -> right -> left = newNode ( 7 ) ; root -> left -> right -> right = newNode ( 4 ) ; printf ( \" Sum ▁ of ▁ all ▁ paths ▁ is ▁ % d \" , treePathsSum ( root ) ) ; return 0 ; }"}
{"text": "Program C ++ untuk mencari nenek moyang yang paling rendah menggunakan penunjuk induk", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "Nod pokok", "code": "struct Node { Node * left , * right , * parent ; int key ; } ;"}
{"text": "Fungsi utiliti untuk membuat nod BST baru", "code": "Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> parent = temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Fungsi utiliti untuk memasukkan nod baru dengan kunci yang diberikan dalam pokok carian binari", "code": "Node * insert ( Node * node , int key ) {"}
{"text": "Sekiranya pokok itu kosong, kembalikan nod baru", "code": "if ( node == NULL ) return newNode ( key ) ;"}
{"text": "Jika tidak, mengulangi pokok itu", "code": "if ( key < node -> key ) { node -> left = insert ( node -> left , key ) ; node -> left -> parent = node ; } else if ( key > node -> key ) { node -> right = insert ( node -> right , key ) ; node -> right -> parent = node ; }"}
{"text": "Kembalikan penunjuk nod (tidak berubah)", "code": "return node ; }"}
{"text": "Untuk mencari LCA nod N1 dan N2 di pokok binari", "code": "Node * LCA ( Node * n1 , Node * n2 ) {"}
{"text": "Cipta peta untuk menyimpan nenek moyang n1", "code": "map < Node * , bool > ancestors ;"}
{"text": "Masukkan N1 dan semua nenek moyangnya dalam peta", "code": "while ( n1 != NULL ) { ancestors [ n1 ] = true ; n1 = n1 -> parent ; }"}
{"text": "Semak jika N2 atau mana -mana nenek moyangnya berada dalam peta.", "code": "while ( n2 != NULL ) { if ( ancestors . find ( n2 ) != ancestors . end ( ) ) return n2 ; n2 = n2 -> parent ; } return NULL ; }"}
{"text": "Kaedah pemacu untuk menguji fungsi di atas", "code": "int main ( void ) { Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 8 ) ; root = insert ( root , 22 ) ; root = insert ( root , 4 ) ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 14 ) ; Node * n1 = root -> left -> right -> left ; Node * n2 = root -> left ; Node * lca = LCA ( n1 , n2 ) ; printf ( \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , n1 -> key , n2 -> key , lca -> key ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengembalikan bilangan minimum coklat", "code": "int minChocolates ( int a [ ] , int n ) { int i = 0 , j = 0 ; int res = 0 , val = 1 ; while ( j < n - 1 ) { if ( a [ j ] > a [ j + 1 ] ) {"}
{"text": "Mengurangkan urutan", "code": "j += 1 ; continue ; } if ( i == j )"}
{"text": "Tambahkan coklat yang diterima oleh orang itu", "code": "res += val ; else {"}
{"text": "titik akhir penurunan urutan", "code": "res += get_sum ( val , i , j ) ;"}
{"text": "val = 1; Tetapkan semula nilai pada indeks itu", "code": "} if ( a [ j ] < a [ j + 1 ] )"}
{"text": "Meningkatkan urutan", "code": "val += 1 ; else"}
{"text": "urutan rata", "code": "val = 1 ; j += 1 ; i = j ; }"}
{"text": "Tambahkan nilai coklat pada kedudukan n - 1", "code": "if ( i == j ) res += val ; else res += get_sum ( val , i , j ) ; return res ; }"}
{"text": "Fungsi penolong untuk mendapatkan jumlah urutan penurunan", "code": "int get_sum ( int peak , int start , int end ) {"}
{"text": "Nilai yang diperoleh dari penurunan urutan juga kiraan nilai dalam urutan", "code": "int count = end - start + 1 ;"}
{"text": "Menetapkan nilai maksimum yang diperoleh daripada peningkatan dan penurunan urutan", "code": "peak = ( peak > count ) ? peak : count ;"}
{"text": "Jumlah kiraan - 1 nilai & nilai puncak jumlah nombor semula jadi: (n * (n + 1)) / 2", "code": "int s = peak + ( ( ( count - 1 ) * count ) >> 1 ) ; return s ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int a [ ] = { 5 , 5 , 4 , 3 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printf ( \" Minimum ▁ number ▁ of ▁ chocolates ▁ = ▁ % d \" , minChocolates ( a , n ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari jumlah siri harmonik", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengembalikan jumlah siri harmonik", "code": "double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 5 ; printf ( \" Sum ▁ is ▁ % f \" , sum ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari tempoh n Siri 5 2 13 41", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "berfungsi untuk mengira istilah ke siri", "code": "int nthTermOfTheSeries ( int n ) {"}
{"text": "Untuk menyimpan istilah siri ke -n", "code": "int nthTerm ;"}
{"text": "Sekiranya N adalah nombor juga", "code": "if ( n % 2 == 0 ) nthTerm = pow ( n - 1 , 2 ) + n ;"}
{"text": "Sekiranya N adalah nombor ganjil", "code": "else nthTerm = pow ( n + 1 , 2 ) + n ;"}
{"text": "Kembalikan istilah n", "code": "return nthTerm ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n ; n = 8 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 12 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 102 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 999 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 9999 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari log (n) menggunakan rekursi", "code": "#include <stdio.h> NEW_LINE unsigned int Log2n ( unsigned int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { unsigned int n = 32 ; printf ( \" % u \" , Log2n ( n ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program C untuk mencari jumlah air yang akan ditambah untuk mencapai nisbah sasaran yang diberikan.", "code": "#include <stdio.h> NEW_LINE float findAmount ( float X , float W , float Y ) { return ( X * ( Y - W ) ) / ( 100 - Y ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float X = 100 , W = 50 , Y = 60 ; printf ( \" Water ▁ to ▁ be ▁ added ▁ = ▁ % .2f ▁ \" , findAmount ( X , W , Y ) ) ; return 0 ; }"}
{"text": "Program C untuk mendapatkan purata kuadrat nombor semulajadi n pertama", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mendapatkan purata", "code": "float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 10 ; printf ( \" % f \" , AvgofSquareN ( n ) ) ; return 0 ; }"}
{"text": "Program C untuk mencari siri nombor segi tiga", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencari nombor segi tiga", "code": "void triangular_series ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) printf ( \" ▁ % d ▁ \" , i * ( i + 1 ) / 2 ) ; }"}
{"text": "Fungsi yang didorong", "code": "int main ( ) { int n = 5 ; triangular_series ( n ) ; return 0 ; }"}
{"text": "Program c untuk mencari jumlah semua pembahagi nombor sehingga 'n'", "code": "#include <stdio.h>"}
{"text": "Fungsi utiliti untuk mencari jumlah semua pembahagi nombor sehingga 'n'", "code": "int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 4 ; printf ( \" % d STRNEWLINE \" , divisorSum ( n ) ) ; n = 5 ; printf ( \" % d \" , divisorSum ( n ) ) ; return 0 ; }"}
{"text": "C Program untuk mencari jumlah siri 1 + x / 1 + x ^ 2/2 + x ^ 3/3 + .... + x ^ n / n", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Kod untuk mencetak jumlah siri", "code": "double sum ( int x , int n ) { double i , total = 1.0 ; for ( i = 1 ; i <= n ; i ++ ) total = total + ( pow ( x , i ) / i ) ; return total ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int x = 2 ; int n = 5 ; printf ( \" % .2f \" , sum ( x , n ) ) ; return 0 ; }"}
{"text": "Program C ++ untuk memeriksa sama ada nombor adalah kuasa 3 atau tidak.", "code": "#include <stdio.h> NEW_LINE #include <stdbool.h>"}
{"text": "Pulangan benar jika n adalah kuasa 3, yang lain palsu", "code": "bool check ( int n ) { if ( n <= 0 ) return false ;"}
{"text": "Kuasa maksimum 3 nilai yang dapat dipegang integer ialah 1162261467 (3 ^ 19).", "code": "return 1162261467 % n == 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 9 ; if ( check ( n ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Program C Dioptimumkan untuk N 'Th Perrin Nombor", "code": "#include <stdio.h> NEW_LINE int per ( int n ) { int a = 3 , b = 0 , c = 2 , i ; int m ; if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return c ; while ( n > 2 ) { m = a + b ; a = b ; b = c ; c = m ; n -- ; } return m ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 9 ; printf ( \" % d \" , per ( n ) ) ; return 0 ; }"}
{"text": "Penyelesaian naif untuk mencari sama ada Count of Divisors malah atau ganjil", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Berfungsi untuk mengira pembahagi", "code": "void countDivisors ( int n ) {"}
{"text": "Memulakan kiraan pembahagi", "code": "int count = 0 ;"}
{"text": "Perhatikan bahawa gelung ini berjalan hingga akar persegi", "code": "for ( int i = 1 ; i <= sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 )"}
{"text": "Sekiranya pembahagi adalah kiraan kenaikan yang sama dengan satu kiraan kenaikan sebaliknya sebanyak 2", "code": "count += ( n / i == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) printf ( \" Even STRNEWLINE \" ) ; else printf ( \" Odd STRNEWLINE \" ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { printf ( \" The ▁ count ▁ of ▁ divisor : ▁ \" ) ; countDivisors ( 10 ) ; return 0 ; }"}
{"text": "Penyelesaian mudah yang menyebabkan limpahan apabila nilai (mod %) * (mod B %) menjadi lebih daripada nilai maksimum int yang panjang", "code": "#define ll  long long NEW_LINE ll multiply ( ll a , ll b , ll mod ) { return ( ( a % mod ) * ( b % mod ) ) % mod ; }"}
{"text": "Program C untuk mengira dataran dalam segi empat tepat saiz m x n", "code": "#include <stdio.h>"}
{"text": "Mengembalikan kiraan semua dataran dalam segi empat tepat saiz m x n", "code": "int countSquares ( int m , int n ) { int temp ;"}
{"text": "Jika n lebih kecil, swap m dan n", "code": "if ( n < m ) { temp = n ; n = m ; m = temp ; }"}
{"text": "Sekarang n adalah dimensi yang lebih besar, gunakan formula", "code": "return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int m = 4 , n = 3 ; printf ( \" Count ▁ of ▁ squares ▁ is ▁ % d \" , countSquares ( m , n ) ) ; }"}
{"text": "Program c untuk mencari jumlah siri", "code": "#include <stdio.h>"}
{"text": "Fungsi untuk mengembalikan jumlah 1/1 + 1/2 + 1/3 +. . + 1 / n", "code": "double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 5 ; printf ( \" Sum ▁ is ▁ % f \" , sum ( n ) ) ; return 0 ; }"}
{"text": "Program C untuk mencari GCD daripada dua nombor", "code": "#include <stdio.h>"}
{"text": "Fungsi rekursif untuk mengembalikan GCD a dan b", "code": "int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int a = 98 , b = 56 ; printf ( \" GCD ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "C ++ program pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Fungsi utiliti yang mencetak saiz panjang yang diberikan", "code": "void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; return ; }"}
{"text": "Fungsi teras yang menghasilkan dan mencetak semua urutan panjang k", "code": "void printSequencesRecur ( int arr [ ] , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } }"}
{"text": "Fungsi yang menggunakan PrintSeSeenceRecur () untuk mencetak semua urutan dari 1, 1 ,. .1 hingga n, n ,. . n", "code": "void printSequences ( int n , int k ) { int * arr = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 3 ; int k = 2 ; printSequences ( n , k ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "mengandaikan bahawa n adalah integer positif", "code": "bool isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) printf ( \" % d ▁ is ▁ multiple ▁ of ▁ 5 STRNEWLINE \" , n ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ multiple ▁ of ▁ 5 STRNEWLINE \" , n ) ; return 0 ; }"}
{"text": "Berfungsi untuk tidak mendapat bit dalam perwakilan binari integer positif", "code": "#include <stdio.h> NEW_LINE unsigned int countBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }"}
{"text": "Program Pemandu", "code": "int main ( ) { int i = 65 ; printf ( \" % d \" , countBits ( i ) ) ; return 0 ; }"}
{"text": "Program C untuk mencari nombor n - yang perwakilan binari adalah palindrome.", "code": "#include <stdio.h> NEW_LINE #define INT_MAX  2147483647"}
{"text": "Cari jika bit kth ditetapkan dalam perwakilan binari", "code": "int isKthBitSet ( int x , int k ) { return ( x & ( 1 << ( k - 1 ) ) ) ? 1 : 0 ; }"}
{"text": "Mengembalikan kedudukan bit set kiri dalam perwakilan binari", "code": "int leftmostSetBit ( int x ) { int count = 0 ; while ( x ) { count ++ ; x = x >> 1 ; } return count ; }"}
{"text": "Cari sama ada integer dalam perwakilan binari adalah palindrome atau tidak", "code": "int isBinPalindrome ( int x ) { int l = leftmostSetBit ( x ) ; int r = 1 ;"}
{"text": "Satu demi satu membandingkan bit", "code": "while ( l > r ) {"}
{"text": "Bandingkan bit kiri dan kanan dan berkumpul", "code": "if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; } int findNthPalindrome ( int n ) { int pal_count = 0 ;"}
{"text": "Mulakan dari 1, melintasi semua bilangan bulat", "code": "int i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) ) { pal_count ++ ; }"}
{"text": "Sekiranya kita sampai ke n, pecahkan gelung", "code": "if ( pal_count == n ) break ; } return i ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 9 ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" % d \" , findNthPalindrome ( n ) ) ; }"}
{"text": "Program c untuk menunjukkan penggunaan pengendali bitwise", "code": "#include <stdio.h> NEW_LINE int main ( ) {"}
{"text": "A = 5 (00000101), b = 9 (00001001)", "code": "unsigned char a = 5 , b = 9 ;"}
{"text": "Hasilnya ialah 00000001", "code": "printf ( \" a ▁ = ▁ % d , ▁ b ▁ = ▁ % d STRNEWLINE \" , a , b ) ; printf ( \" a & b ▁ = ▁ % d STRNEWLINE \" , a & b ) ;"}
{"text": "Hasilnya ialah 00001101", "code": "printf ( \" a ▁ b ▁ = ▁ % d STRNEWLINE \" , a b ) ;"}
{"text": "Hasilnya ialah 00001100", "code": "printf ( \" a ^ b ▁ = ▁ % d STRNEWLINE \" , a ^ b ) ;"}
{"text": "Hasilnya ialah 11111010", "code": "printf ( \" ~ a ▁ = ▁ % d STRNEWLINE \" , a = ~ a ) ;"}
{"text": "Hasilnya ialah 00010010", "code": "printf ( \" b < < 1 ▁ = ▁ % d STRNEWLINE \" , b << 1 ) ;"}
{"text": "Hasilnya ialah 00000100", "code": "printf ( \" b > > 1 ▁ = ▁ % d STRNEWLINE \" , b >> 1 ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengembalikan suhu di termometer kedua", "code": "double temp_convert ( int F1 , int B1 , int F2 , int B2 , int T ) { float t2 ;"}
{"text": "Kirakan suhu", "code": "t2 = F2 + ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int F1 = 0 , B1 = 100 ; int F2 = 32 , B2 = 212 ; int T = 37 ; float t2 ; printf ( \" % .2f \" , temp_convert ( F1 , B1 , F2 , B2 , T ) ) ; return 0 ; }"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Kirakan \"maxdepth\" pokok - bilangan nod di sepanjang jalan terpanjang dari nod akar ke nod daun terjauh.", "code": "int maxDepth ( struct node * node ) { if ( node == NULL ) return 0 ; else {"}
{"text": "Kirakan kedalaman setiap subtree", "code": "int lDepth = maxDepth ( node -> left ) ; int rDepth = maxDepth ( node -> right ) ;"}
{"text": "Gunakan yang lebih besar", "code": "if ( lDepth > rDepth ) return ( lDepth + 1 ) ; else return ( rDepth + 1 ) ; } }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Height ▁ of ▁ tree ▁ is ▁ % d \" , maxDepth ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk memeriksa sama ada pokok adalah ketinggian - seimbang atau tidak", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define bool  int"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Mengembalikan ketinggian pokok binari", "code": "int height ( struct node * node ) ;"}
{"text": "Pulangan benar jika pokok binari dengan akar sebagai akar adalah ketinggian - seimbang", "code": "bool isBalanced ( struct node * root ) {"}
{"text": "untuk ketinggian subtree kiri", "code": "int lh ;"}
{"text": "untuk ketinggian subtree kanan", "code": "int rh ;"}
{"text": "Sekiranya pokok kosong maka kembali benar", "code": "if ( root == NULL ) return 1 ;"}
{"text": "Dapatkan ketinggian pokok sub kiri dan kanan", "code": "lh = height ( root -> left ) ; rh = height ( root -> right ) ; if ( abs ( lh - rh ) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ) ) return 1 ;"}
{"text": "Sekiranya kita sampai di sini maka pokok tidak ketinggian - seimbang", "code": "return 0 ; }"}
{"text": "Mengembalikan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a >= b ) ? a : b ; }"}
{"text": "Fungsi ini mengira \"ketinggian\" pokok. Ketinggian adalah bilangan nod di sepanjang jalan terpanjang dari nod akar ke nod daun terjauh.", "code": "int height ( struct node * node ) {"}
{"text": "Pokok kes asas kosong", "code": "if ( node == NULL ) return 0 ;"}
{"text": "Sekiranya pokok tidak kosong maka ketinggian = 1 + maksimum ketinggian kiri dan ketinggian kanan", "code": "return 1 + max ( height ( node -> left ) , height ( node -> right ) ) ; }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> left -> left = newNode ( 8 ) ; if ( isBalanced ( root ) ) printf ( \" Tree ▁ is ▁ balanced \" ) ; else printf ( \" Tree ▁ is ▁ not ▁ balanced \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program C dioptimumkan Rekursif untuk mencari diameter pokok binari", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "mengembalikan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Fungsi ini mengira \"ketinggian\" pokok. Ketinggian adalah nombor f nod di sepanjang laluan terpanjang dari nod akar ke nod daun terjauh.", "code": "int height ( struct node * node ) {"}
{"text": "Pokok kes asas kosong", "code": "if ( node == NULL ) return 0 ;"}
{"text": "Sekiranya pokok tidak kosong maka ketinggian = 1 + maksimum ketinggian kiri dan ketinggian kanan", "code": "return 1 + max ( height ( node -> left ) , height ( node -> right ) ) ; }"}
{"text": "Berfungsi untuk mendapatkan diameter pokok binari", "code": "int diameter ( struct node * tree ) {"}
{"text": "Kes asas di mana pokok kosong", "code": "if ( tree == NULL ) return 0 ;"}
{"text": "Dapatkan ketinggian pokok kiri dan kanan", "code": "int lheight = height ( tree -> left ) ; int rheight = height ( tree -> right ) ;"}
{"text": "Dapatkan diameter sub - pokok kiri dan kanan", "code": "int ldiameter = diameter ( tree -> left ) ; int rdiameter = diameter ( tree -> right ) ;"}
{"text": "Kembali maksimum berikut tiga 1) diameter subtree kiri 2) diameter subtree kanan 3) ketinggian subtree kiri + ketinggian subtree kanan + 1", "code": "return max ( lheight + rheight + 1 , max ( ldiameter , rdiameter ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Pokok binari yang dibina adalah 1 / \\ 2 3 /4 5", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" Diameter ▁ of ▁ the ▁ given ▁ binary ▁ tree ▁ is ▁ % d STRNEWLINE \" , diameter ( root ) ) ; return 0 ; }"}
{"text": "Program C ++ untuk pendekatan di atas.", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "Berfungsi untuk mencari jalan cetak", "code": "void findpath ( int N , int a [ ] ) {"}
{"text": "Sekiranya [0] adalah 1", "code": "if ( a [ 0 ] ) {"}
{"text": "Jalan percetakan", "code": "printf ( \" % d ▁ \" , N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , i ) ; return ; }"}
{"text": "Mencari [i] = 0 dan [i + 1] = 1", "code": "for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ! a [ i ] && a [ i + 1 ] ) {"}
{"text": "Jalan percetakan", "code": "for ( int j = 1 ; j <= i ; j ++ ) printf ( \" % d ▁ \" , j ) ; printf ( \" % d ▁ \" , N + 1 ) ; for ( int j = i + 1 ; j <= N ; j ++ ) printf ( \" % d ▁ \" , j ) ; return ; } }"}
{"text": "Jika a [n - 1] = 0", "code": "for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , i ) ; printf ( \" % d ▁ \" , N + 1 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberikan input", "code": "int N = 3 , arr [ ] = { 0 , 1 , 0 } ;"}
{"text": "Panggilan fungsi", "code": "findpath ( N , arr ) ; }"}
{"text": "Program c untuk mencari kedalaman nod daun tahap ganjil yang paling dalam", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Fungsi utiliti untuk mencari maksimum dua bilangan bulat", "code": "int max ( int x , int y ) { return ( x > y ) ? x : y ; }"}
{"text": "Nod pokok binari", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "Fungsi utiliti untuk memperuntukkan nod pokok baru", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; }"}
{"text": "Fungsi rekursif untuk mencari kedalaman daun tahap ganjil yang paling dalam", "code": "int depthOfOddLeafUtil ( struct Node * root , int level ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return 0 ;"}
{"text": "Sekiranya nod ini adalah daun dan tahapnya ganjil, kembalikan tahapnya", "code": "if ( root -> left == NULL && root -> right == NULL && level & 1 ) return level ;"}
{"text": "Sekiranya tidak daun, kembalikan nilai maksimum dari subtrees kiri dan kanan", "code": "return max ( depthOfOddLeafUtil ( root -> left , level + 1 ) , depthOfOddLeafUtil ( root -> right , level + 1 ) ) ; }"}
{"text": "Fungsi utama yang mengira kedalaman daun tahap ganjil yang paling dalam. Fungsi ini terutamanya menggunakan Depthofoddleafutil ()", "code": "int depthOfOddLeaf ( struct Node * root ) { int level = 1 , depth = 0 ; return depthOfOddLeafUtil ( root , level ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 8 ) ; root -> right -> left -> right -> left = newNode ( 9 ) ; root -> right -> right -> right -> right = newNode ( 10 ) ; root -> right -> right -> right -> right -> left = newNode ( 11 ) ; printf ( \" % d ▁ is ▁ the ▁ required ▁ depth STRNEWLINE \" , depthOfOddLeaf ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Fungsi komparator yang digunakan oleh QSORT", "code": "int compare ( const void * a , const void * b ) { return ( * ( int * ) a - * ( int * ) b ) ; }"}
{"text": "Berfungsi untuk mencetak penyusunan semula susunan yang diperlukan jika boleh", "code": "void printArr ( int arr [ ] , int n ) {"}
{"text": "Susun array dalam peningkatan urutan", "code": "qsort ( arr , n , sizeof ( int ) , compare ) ;"}
{"text": "Sekiranya semua elemen sama, maka tidak mungkin", "code": "if ( arr [ 0 ] == arr [ n - 1 ] ) { printf ( \" No STRNEWLINE \" ) ; }"}
{"text": "Lain mencetak arr array yang disusun []", "code": "else { printf ( \" Yes STRNEWLINE \" ) ; for ( int i = 0 ; i < n ; i ++ ) { printf ( \" % d ▁ \" , arr [ i ] ) ; } } }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberikan array", "code": "int arr [ ] = { 1 , 2 , 2 , 1 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Panggilan fungsi", "code": "printArr ( arr , N ) ; return 0 ; }"}
{"text": "Program c untuk mengira lebar pokok binari", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi protoypes", "code": "int getWidth ( struct node * root , int level ) ; int height ( struct node * node ) ; struct node * newNode ( int data ) ;"}
{"text": "Berfungsi untuk mendapatkan lebar maksimum pokok binari", "code": "int getMaxWidth ( struct node * root ) { int maxWidth = 0 ; int width ; int h = height ( root ) ; int i ;"}
{"text": "Dapatkan lebar setiap peringkat dan bandingkan lebar dengan lebar maksimum setakat ini", "code": "for ( i = 1 ; i <= h ; i ++ ) { width = getWidth ( root , i ) ; if ( width > maxWidth ) maxWidth = width ; } return maxWidth ; }"}
{"text": "Dapatkan lebar tahap tertentu", "code": "int getWidth ( struct node * root , int level ) { if ( root == NULL ) return 0 ; if ( level == 1 ) return 1 ; else if ( level > 1 ) return getWidth ( root -> left , level - 1 ) + getWidth ( root -> right , level - 1 ) ; }"}
{"text": "Kirakan \"ketinggian\" pokok - bilangan nod di sepanjang laluan terpanjang dari nod akar ke nod daun terjauh.", "code": "int height ( struct node * node ) { if ( node == NULL ) return 0 ; else {"}
{"text": "Kirakan ketinggian setiap subtree", "code": "int lHeight = height ( node -> left ) ; int rHeight = height ( node -> right ) ;"}
{"text": "Gunakan yang lebih besar", "code": "return ( lHeight > rHeight ) ? ( lHeight + 1 ) : ( rHeight + 1 ) ; } }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Pokok binari yang dibina ialah: 1 / \\ 2 3 / \\ 4 5 8 / \\ 6 7", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 6 ) ; root -> right -> right -> right = newNode ( 7 ) ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" Maximum ▁ width ▁ is ▁ % d ▁ STRNEWLINE \" , getMaxWidth ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mengira lebar pokok binari", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi utiliti untuk mendapatkan ketinggian pokok binari", "code": "int height ( struct node * node ) ; struct node * newNode ( int data ) ; int getMax ( int arr [ ] , int n ) ; void getMaxWidthRecur ( struct node * root , int count [ ] , int level ) ;"}
{"text": "Berfungsi untuk mendapatkan lebar maksimum pokok binari", "code": "int getMaxWidth ( struct node * root ) { int width ; int h = height ( root ) ;"}
{"text": "Buat array yang akan menyimpan kiraan nod di setiap peringkat", "code": "int * count = ( int * ) calloc ( sizeof ( int ) , h ) ; int level = 0 ;"}
{"text": "Isi array kiraan menggunakan preorder traversal", "code": "getMaxWidthRecur ( root , count , level ) ;"}
{"text": "Kembalikan nilai maksimum dari array kiraan", "code": "return getMax ( count , h ) ; }"}
{"text": "Fungsi yang mengisi array Count dengan mengira nod di setiap peringkat pokok binari yang diberikan", "code": "void getMaxWidthRecur ( struct node * root , int count [ ] , int level ) { if ( root ) { count [ level ] ++ ; getMaxWidthRecur ( root -> left , count , level + 1 ) ; getMaxWidthRecur ( root -> right , count , level + 1 ) ; } }"}
{"text": "Kirakan \"ketinggian\" pokok - bilangan nod di sepanjang laluan terpanjang dari nod akar ke nod daun terjauh.", "code": "int height ( struct node * node ) { if ( node == NULL ) return 0 ; else {"}
{"text": "Kirakan ketinggian setiap subtree", "code": "int lHeight = height ( node -> left ) ; int rHeight = height ( node -> right ) ;"}
{"text": "Gunakan yang lebih besar", "code": "return ( lHeight > rHeight ) ? ( lHeight + 1 ) : ( rHeight + 1 ) ; } }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Kembalikan nilai maksimum dari array kiraan", "code": "int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Pokok Bunary yang dibina adalah: 1 / \\ 2 3 / \\ 4 5 8 / \\ 6 7", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 6 ) ; root -> right -> right -> right = newNode ( 7 ) ; printf ( \" Maximum ▁ width ▁ is ▁ % d ▁ STRNEWLINE \" , getMaxWidth ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Pelaksanaan c untuk mencari kiraan daun pokok binari yang diberikan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Berfungsi untuk mendapatkan kiraan nod daun di pokok binari", "code": "unsigned int getLeafCount ( struct node * node ) { if ( node == NULL ) return 0 ; if ( node -> left == NULL && node -> right == NULL ) return 1 ; else return getLeafCount ( node -> left ) + getLeafCount ( node -> right ) ; }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "buat pokok", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ;"}
{"text": "Dapatkan kiraan daun pokok yang dibuat di atas", "code": "printf ( \" Leaf ▁ count ▁ of ▁ the ▁ tree ▁ is ▁ % d \" , getLeafCount ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mencari bilangan denominasi minimum", "code": "#include <stdio.h> NEW_LINE #define COINS  9 NEW_LINE #define MAX  20"}
{"text": "Semua denominasi mata wang India", "code": "int coins [ COINS ] = { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 , 2000 } ; void findMin ( int cost ) {"}
{"text": "Memulakan hasil", "code": "int coinList [ MAX ] = { 0 } ;"}
{"text": "Melintasi semua denominasi", "code": "int i , k = 0 ; for ( i = COINS - 1 ; i >= 0 ; i -- ) {"}
{"text": "Cari denominasi", "code": "while ( cost >= coins [ i ] ) { cost -= coins [ i ] ; coinList [ k ++ ] = coins [ i ] ; } }"}
{"text": "Hasil cetak", "code": "for ( i = 0 ; i < k ; i ++ ) { printf ( \" % d ▁ \" , coinList [ i ] ) ; } return ; }"}
{"text": "Kod pemacu", "code": "int main ( void ) { int n = 93 ; printf ( \" Following ▁ is ▁ minimal ▁ number \" \" of ▁ change ▁ for ▁ % d : ▁ \" , n ) ; findMin ( n ) ; return 0 ; }"}
{"text": "Program Cerative C untuk menyambungkan nod pada tahap yang sama menggunakan ruang tambahan yang berterusan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Pembina yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node { int data ; struct node * left ; struct node * right ; struct node * nextRight ; } ; struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> nextRight = NULL ; return ( node ) ; }"}
{"text": "Fungsi ini mengembalikan anak paling kiri nod pada tahap yang sama seperti p. Fungsi ini digunakan untuk mendapatkan hak anak lelaki yang betul jika anak yang betul adalah null maka ini juga boleh digunakan untuk anak kiri", "code": "struct node * getNextRight ( struct node * p ) { struct node * temp = p -> nextRight ;"}
{"text": "Nod melintasi pada tahap p 'dan u dan u kembali", "code": "while ( temp != NULL ) { if ( temp -> left != NULL ) return temp -> left ; if ( temp -> right != NULL ) return temp -> right ; temp = temp -> nextRight ; }"}
{"text": "Sekiranya semua nod pada tahap P adalah nod daun maka kembali null", "code": "return NULL ; }"}
{"text": "Menetapkan ketegangan semua nod pokok dengan akar sebagai p", "code": "void connect ( struct node * p ) { struct node * temp ; if ( ! p ) return ;"}
{"text": "Tetapkan Nextright untuk Root", "code": "p -> nextRight = NULL ;"}
{"text": "Tetapkan ketegangan dari semua peringkat satu demi satu", "code": "while ( p != NULL ) { struct node * q = p ;"}
{"text": "Sambungkan semua nod kanak -kanak P dan kanak -kanak nod semua nod lain pada tahap yang sama seperti p", "code": "while ( q != NULL ) {"}
{"text": "Tetapkan penunjuk nextright untuk anak kiri P", "code": "if ( q -> left ) {"}
{"text": "Sekiranya q mempunyai anak yang betul, maka anak yang betul adalah tidak jelas P dan kita juga perlu menetapkan anak lelaki yang betul", "code": "if ( q -> right ) q -> left -> nextRight = q -> right ; else q -> left -> nextRight = getNextRight ( q ) ; } if ( q -> right ) q -> right -> nextRight = getNextRight ( q ) ;"}
{"text": "Tetapkan nextright untuk nod lain dalam fesyen pra -pesanan", "code": "q = q -> nextRight ; }"}
{"text": "Mulakan dari nod pertama tahap seterusnya", "code": "if ( p -> left ) p = p -> left ; else if ( p -> right ) p = p -> right ; else p = getNextRight ( p ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Pokok binari yang dibina ialah 10 / \\ 8 2 / \\ 3 90", "code": "struct node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ; root -> right -> right = newnode ( 90 ) ;"}
{"text": "Populates Nextright Pointer dalam semua nod", "code": "connect ( root ) ;"}
{"text": "Marilah kita periksa nilai penunjuk nextright", "code": "printf ( \" Following ▁ are ▁ populated ▁ nextRight ▁ pointers ▁ in ▁ the ▁ tree ▁ \" \" ( -1 ▁ is ▁ printed ▁ if ▁ there ▁ is ▁ no ▁ nextRight ) ▁ STRNEWLINE \" ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> data , root -> nextRight ? root -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> left -> data , root -> left -> nextRight ? root -> left -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> right -> data , root -> right -> nextRight ? root -> right -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> left -> left -> data , root -> left -> left -> nextRight ? root -> left -> left -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> right -> right -> data , root -> right -> right -> nextRight ? root -> right -> right -> nextRight -> data : -1 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program C untuk menyambungkan nod pada tahap yang sama menggunakan traversal pra - urutan lanjutan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void connectRecur ( struct node * p ) ;"}
{"text": "Nod pokok binari", "code": "struct node { int data ; struct node * left ; struct node * right ; struct node * nextRight ; } ;"}
{"text": "Menetapkan root dan panggilan ConnectRecur () untuk nod lain", "code": "void connect ( struct node * p ) {"}
{"text": "Tetapkan Nextright untuk Root", "code": "p -> nextRight = NULL ;"}
{"text": "Tetapkan hak seterusnya untuk sisa nod (selain akar)", "code": "connectRecur ( p ) ; }"}
{"text": "Tetapkan hak seterusnya dari semua keturunan p. Asumsi: P adalah pokok binari bersaing", "code": "void connectRecur ( struct node * p ) {"}
{"text": "Kes asas", "code": "if ( ! p ) return ;"}
{"text": "Tetapkan penunjuk nextright untuk anak kiri P", "code": "if ( p -> left ) p -> left -> nextRight = p -> right ;"}
{"text": "Tetapkan penunjuk nextright untuk anak kanan p-> nextright akan menjadi batal jika p adalah anak yang paling tepat di peringkatnya", "code": "if ( p -> right ) p -> right -> nextRight = ( p -> nextRight ) ? p -> nextRight -> left : NULL ;"}
{"text": "Tetapkan nextright untuk nod lain dalam fesyen pra -pesanan", "code": "connectRecur ( p -> left ) ; connectRecur ( p -> right ) ; }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> nextRight = NULL ; return ( node ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Pokok binari yang dibina ialah 10 / \\ 8 2/3", "code": "struct node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ;"}
{"text": "Populates Nextright Pointer dalam semua nod", "code": "connect ( root ) ;"}
{"text": "Marilah kita periksa nilai penunjuk nextright", "code": "printf ( \" Following ▁ are ▁ populated ▁ nextRight ▁ pointers ▁ in ▁ the ▁ tree ▁ \" \" ( -1 ▁ is ▁ printed ▁ if ▁ there ▁ is ▁ no ▁ nextRight ) ▁ STRNEWLINE \" ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> data , root -> nextRight ? root -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> left -> data , root -> left -> nextRight ? root -> left -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> right -> data , root -> right -> nextRight ? root -> right -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> left -> left -> data , root -> left -> left -> nextRight ? root -> left -> left -> nextRight -> data : -1 ) ; return 0 ; }"}
{"text": "Program rekursif naif untuk mencari sisipan nombor minimum yang diperlukan untuk membuat palindrom rentetan", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #include <string.h>"}
{"text": "Fungsi utiliti untuk mencari minimum dua nombor", "code": "int min ( int a , int b ) { return a < b ? a : b ; }"}
{"text": "Fungsi rekursif untuk mencari bilangan sisipan minimum", "code": "int findMinInsertions ( char str [ ] , int l , int h ) {"}
{"text": "Kes asas", "code": "if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ;"}
{"text": "Semak sama ada aksara pertama dan terakhir adalah sama. Berdasarkan hasil perbandingan, tentukan subrpoplem mana yang hendak dipanggil", "code": "return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char str [ ] = \" geeks \" ; printf ( \" % d \" , findMinInsertions ( str , 0 , strlen ( str ) - 1 ) ) ; return 0 ; }"}
{"text": "C Program pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat", "code": "int max ( int x , int y ) { return ( x > y ) ? x : y ; }"}
{"text": "Mengembalikan panjang Palindromik Terpanjang di SEQ", "code": "int lps ( char * seq , int i , int j ) {"}
{"text": "Kes Base 1: Sekiranya hanya ada 1 watak", "code": "if ( i == j ) return 1 ;"}
{"text": "Kes Base 2: Sekiranya terdapat hanya 2 aksara dan kedua -duanya sama", "code": "if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ;"}
{"text": "Sekiranya watak pertama dan terakhir sepadan", "code": "if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ;"}
{"text": "Sekiranya watak pertama dan terakhir tidak sepadan", "code": "return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char seq [ ] = \" GEEKSFORGEEKS \" ; int n = strlen ( seq ) ; printf ( \" The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d \" , lps ( seq , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mendapatkan tahap nod di pokok binari", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Struktur nod pokok", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi penolong untuk getLevel (). Ia mengembalikan tahap data jika data ada di dalam pokok, jika tidak pulangan 0.", "code": "int getLevelUtil ( struct node * node , int data , int level ) { if ( node == NULL ) return 0 ; if ( node -> data == data ) return level ; int downlevel = getLevelUtil ( node -> left , data , level + 1 ) ; if ( downlevel != 0 ) return downlevel ; downlevel = getLevelUtil ( node -> right , data , level + 1 ) ; return downlevel ; }"}
{"text": "Pulangan tahap nilai data yang diberikan", "code": "int getLevel ( struct node * node , int data ) { return getLevelUtil ( node , data , 1 ) ; }"}
{"text": "Fungsi utiliti untuk membuat nod pokok binari baru", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { struct node * root ; int x ;"}
{"text": "Membina pokok yang diberikan dalam angka di atas", "code": "root = newNode ( 3 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; for ( x = 1 ; x <= 5 ; x ++ ) { int level = getLevel ( root , x ) ; if ( level ) printf ( \" ▁ Level ▁ of ▁ % d ▁ is ▁ % d STRNEWLINE \" , x , getLevel ( root , x ) ) ; else printf ( \" ▁ % d ▁ is ▁ not ▁ present ▁ in ▁ tree ▁ STRNEWLINE \" , x ) ; } getchar ( ) ; return 0 ; }"}
{"text": "Program C untuk Algoritma Mencari Corak Automata terhingga", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE int getNextState ( char * pat , int M , int state , int x ) {"}
{"text": "Sekiranya watak C sama dengan watak seterusnya dalam corak, maka hanya kenaikan keadaan", "code": "if ( state < M && x == pat [ state ] ) return state + 1 ;"}
{"text": "NS menyimpan hasil yang seterusnya", "code": "int ns , i ;"}
{"text": "Mulakan dari nilai terbesar dan berhenti apabila anda mencari awalan yang juga akhiran", "code": "for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] == x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) if ( pat [ i ] != pat [ state - ns + 1 + i ] ) break ; if ( i == ns - 1 ) return ns ; } } return 0 ; }"}
{"text": "Fungsi ini membina jadual TF yang mewakili 4 automata terhingga untuk corak yang diberikan", "code": "void computeTF ( char * pat , int M , int TF [ ] [ NO_OF_CHARS ] ) { int state , x ; for ( state = 0 ; state <= M ; ++ state ) for ( x = 0 ; x < NO_OF_CHARS ; ++ x ) TF [ state ] [ x ] = getNextState ( pat , M , state , x ) ; }"}
{"text": "Mencetak semua kejadian pat dalam txt", "code": "void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int TF [ M + 1 ] [ NO_OF_CHARS ] ; computeTF ( pat , M , TF ) ;"}
{"text": "Proses txt ke atas FA.", "code": "int i , state = 0 ; for ( i = 0 ; i < N ; i ++ ) { state = TF [ state ] [ txt [ i ] ] ; if ( state == M ) printf ( \" Pattern found at index % d \" , i - M + 1 ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char * txt = \" AABAACAADAABAAABAA \" ; char * pat = \" AABA \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Program c untuk mencari nod cermin di pokok binari", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct Node { int key ; struct Node * left , * right ; } ;"}
{"text": "buat nod baru dan mulakannya", "code": "struct Node * newNode ( int key ) { struct Node * n = ( struct Node * ) malloc ( sizeof ( struct Node * ) ) ; if ( n != NULL ) { n -> key = key ; n -> left = NULL ; n -> right = NULL ; return n ; } else { printf ( \" Memory ▁ allocation ▁ failed ! \" ) ; exit ( 1 ) ; } }"}
{"text": "fungsi rekursif untuk mencari cermin nod", "code": "int findMirrorRec ( int target , struct Node * left , struct Node * right ) {"}
{"text": "Sekiranya mana -mana nod itu tidak ada nod sendiri dan lantang tidak mempunyai cermin, jadi kembali, tidak perlu lagi meneroka!", "code": "if ( left == NULL right == NULL ) return 0 ;"}
{"text": "Sekiranya nod kiri adalah nod sasaran, maka kembali kunci kanan (iaitu cermin) dan sebaliknya", "code": "if ( left -> key == target ) return right -> key ; if ( right -> key == target ) return left -> key ;"}
{"text": "Nod luaran yang pertama berulang", "code": "int mirror_val = findMirrorRec ( target , left -> left , right -> right ) ; if ( mirror_val ) return mirror_val ;"}
{"text": "Sekiranya tiada cermin dijumpai, nod dalaman berulang", "code": "findMirrorRec ( target , left -> right , right -> left ) ; }"}
{"text": "antara muka untuk carian cermin", "code": "int findMirror ( struct Node * root , int target ) { if ( root == NULL ) return 0 ; if ( root -> key == target ) return target ; return findMirrorRec ( target , root -> left , root -> right ) ; }"}
{"text": "Pemandu", "code": "int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> left -> right = newNode ( 7 ) ; root -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> left = newNode ( 8 ) ; root -> right -> left -> right = newNode ( 9 ) ;"}
{"text": "nod sasaran yang cermin mesti dicari", "code": "int target = root -> left -> left -> key ; int mirror = findMirror ( root , target ) ; if ( mirror ) printf ( \" Mirror ▁ of ▁ Node ▁ % d ▁ is ▁ Node ▁ % d STRNEWLINE \" , target , mirror ) ; else printf ( \" Mirror ▁ of ▁ Node ▁ % d ▁ is ▁ NULL ! STRNEWLINE \" , target ) ; }"}
{"text": "Kaedah berasaskan Perintah Tahap Iteratif untuk mencari di pokok binari", "code": "#include <iostream> NEW_LINE #include <queue> NEW_LINE using namespace std ;"}
{"text": "Nod pokok binari mempunyai data, anak kiri dan anak kanan", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = new struct node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; }"}
{"text": "Proses berulang untuk mencari elemen x dalam pokok binari yang diberikan", "code": "bool iterativeSearch ( node * root , int x ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return false ;"}
{"text": "Buat barisan kosong untuk perintah peringkat traversal", "code": "queue < node * > q ;"}
{"text": "Akar enqueue dan memulakan ketinggian", "code": "q . push ( root ) ;"}
{"text": "Perintah Tahap Berasaskan Peringkat Traversal", "code": "while ( q . empty ( ) == false ) {"}
{"text": "Lihat jika nod semasa sama dengan x", "code": "node * node = q . front ( ) ; if ( node -> data == x ) return true ;"}
{"text": "Keluarkan nod semasa dan enqueue anak -anaknya", "code": "q . pop ( ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; } return false ; }"}
{"text": "Program Pemandu", "code": "int main ( void ) { struct node * NewRoot = NULL ; struct node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; iterativeSearch ( root , 6 ) ? cout << \" Found STRNEWLINE \" : cout << \" Not ▁ Found STRNEWLINE \" ; iterativeSearch ( root , 12 ) ? cout << \" Found STRNEWLINE \" : cout << \" Not ▁ Found STRNEWLINE \" ; return 0 ; }"}
{"text": "C # Program untuk mengisi inorder traversal dari semua nod", "code": "struct node { int data ; struct node * left ; struct node * right ; struct node * next ; }"}
{"text": "Pelaksanaan yang tidak menggunakan pembolehubah statik pembalut ke atas populatenextrecur", "code": "void populateNext ( struct node * root ) {"}
{"text": "Nod pertama yang dikunjungi akan menjadi nod paling kanan di sebelah nod paling kanan akan menjadi batal", "code": "struct node * next = NULL ; populateNextRecur ( root , & next ) ; }"}
{"text": "Tetapkan seterusnya dari semua keturunan P dengan melintasi mereka dalam Inorder Reverse", "code": "void populateNextRecur ( struct node * p , struct node * * next_ref ) { if ( p ) {"}
{"text": "Pertama tetapkan penunjuk seterusnya di subtree kanan", "code": "populateNextRecur ( p -> right , next_ref ) ;"}
{"text": "Tetapkan seterusnya seperti nod yang dilawati sebelumnya dalam inorder terbalik", "code": "p -> next = * next_ref ;"}
{"text": "Tukar sebelumnya untuk nod berikutnya", "code": "* next_ref = p ;"}
{"text": "Akhirnya, tetapkan penunjuk seterusnya di subtree kanan", "code": "populateNextRecur ( p -> left , next_ref ) ; } }"}
{"text": "Program C untuk membuang semua separuh nod", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Untuk traversal inorder", "code": "void printInoder ( struct node * root ) { if ( root != NULL ) { printInoder ( root -> left ) ; printf ( \" % d ▁ \" , root -> data ) ; printInoder ( root -> right ) ; } }"}
{"text": "Mengeluarkan semua nod dengan hanya satu anak dan mengembalikan akar baru (perhatikan bahawa akar mungkin berubah)", "code": "struct node * RemoveHalfNodes ( struct node * root ) { if ( root == NULL ) return NULL ; root -> left = RemoveHalfNodes ( root -> left ) ; root -> right = RemoveHalfNodes ( root -> right ) ; if ( root -> left == NULL && root -> right == NULL ) return root ;"}
{"text": "Sekiranya nod semasa adalah setengah nod dengan anak kiri kiri kiri, maka anak kanannya dikembalikan dan menggantinya di pokok yang diberikan", "code": "if ( root -> left == NULL ) { struct node * new_root = root -> right ; free ( root ) ; return new_root ; }"}
{"text": "Sekiranya nod semasa adalah setengah nod dengan anak yang betul null betul, maka anak yang betul itu dikembalikan dan menggantinya di pokok yang diberikan", "code": "if ( root -> right == NULL ) { struct node * new_root = root -> left ; free ( root ) ; return new_root ; } return root ; }"}
{"text": "Program Pemandu", "code": "int main ( void ) { struct node * NewRoot = NULL ; struct node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ given ▁ tree ▁ STRNEWLINE \" ) ; printInoder ( root ) ; NewRoot = RemoveHalfNodes ( root ) ; printf ( \" Inorder traversal of the modified tree \" printInoder ( NewRoot ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE void printSubstrings ( char str [ ] ) {"}
{"text": "paling luar untuk gelung ini adalah untuk pemilihan titik permulaan", "code": "for ( int start = 0 ; str [ start ] != ' \\0' ; start ++ ) {"}
{"text": "2 nd untuk gelung adalah untuk pemilihan titik akhir", "code": "for ( int end = start ; str [ end ] != ' \\0' ; end ++ ) {"}
{"text": "3 RD Loop adalah untuk mencetak dari titik permulaan ke titik akhir", "code": "for ( int i = start ; i <= end ; i ++ ) { printf ( \" % c \" , str [ i ] ) ; }"}
{"text": "Menukar garis selepas mencetak dari titik permulaan ke titik akhir", "code": "printf ( \" STRNEWLINE \" ) ; } } }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Memanggil kaedah untuk mencetak substring", "code": "char str [ ] = { ' a ' , ' b ' , ' c ' , ' d ' , ' \\0' } ; printSubstrings ( str ) ; return 0 ; }"}
{"text": "N ialah saiz matriks 2d n * n", "code": "#define N  9"}
{"text": "Fungsi utiliti untuk mencetak grid", "code": "void print ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( \" % d ▁ \" , arr [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Memeriksa sama ada ia akan sah untuk memberikan num kepada baris yang diberikan, col", "code": "int isSafe ( int grid [ N ] [ N ] , int row , int col , int num ) {"}
{"text": "Semak jika kita dapati nombor yang sama dalam baris yang sama, kita kembali 0", "code": "for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ row ] [ x ] == num ) return 0 ;"}
{"text": "Semak jika kita dapati nombor yang sama dalam lajur yang sama, kita kembali 0", "code": "for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ x ] [ col ] == num ) return 0 ;"}
{"text": "Semak jika kita dapati nombor yang sama dalam matriks 3 * 3 tertentu, kita kembali 0", "code": "int startRow = row - row % 3 , startCol = col - col % 3 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow ] [ j + startCol ] == num ) return 0 ; return 1 ; }"}
{"text": "Mengambil sebahagiannya diisi - dalam grid dan cuba memberikan nilai kepada semua lokasi yang tidak ditugaskan sedemikian rupa untuk memenuhi syarat untuk penyelesaian Sudoku (bukan duplikasi di seluruh baris, lajur, dan kotak)", "code": "int solveSuduko ( int grid [ N ] [ N ] , int row , int col ) {"}
{"text": "Periksa sama ada kami telah mencapai baris ke -8 dan lajur ke -9 (0 matriks diindeks), kami kembali benar untuk mengelakkan mundur lebih lanjut", "code": "if ( row == N - 1 && col == N ) return 1 ;"}
{"text": "Semak jika nilai lajur menjadi 9, kami bergerak ke baris dan lajur seterusnya bermula dari 0", "code": "if ( col == N ) { row ++ ; col = 0 ; }"}
{"text": "Periksa sama ada kedudukan semasa grid sudah mengandungi nilai> 0, kami melangkah untuk lajur seterusnya", "code": "if ( grid [ row ] [ col ] > 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( int num = 1 ; num <= N ; num ++ ) {"}
{"text": "Periksa sama ada selamat untuk meletakkan num (1 - 9) dalam baris yang diberikan, col -> kami berpindah ke lajur seterusnya", "code": "if ( isSafe ( grid , row , col , num ) == 1 ) {"}
{"text": "Menetapkan NUM dalam kedudukan semasa (baris, col) grid dan mengandaikan NUM kami yang ditugaskan dalam kedudukan itu betul", "code": "grid [ row ] [ col ] = num ;"}
{"text": "Memeriksa kemungkinan seterusnya dengan lajur seterusnya", "code": "if ( solveSuduko ( grid , row , col + 1 ) == 1 ) return 1 ; }"}
{"text": "Mengeluarkan Num yang diberikan, kerana andaian kami salah, dan kami pergi untuk andaian seterusnya dengan nilai diff Num", "code": "grid [ row ] [ col ] = 0 ; } return 0 ; } int main ( ) {"}
{"text": "0 bermaksud sel yang tidak ditetapkan", "code": "int grid [ N ] [ N ] = { { 3 , 0 , 6 , 5 , 0 , 8 , 4 , 0 , 0 } , { 5 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 8 , 7 , 0 , 0 , 0 , 0 , 3 , 1 } , { 0 , 0 , 3 , 0 , 1 , 0 , 0 , 8 , 0 } , { 9 , 0 , 0 , 8 , 6 , 3 , 0 , 0 , 5 } , { 0 , 5 , 0 , 0 , 9 , 0 , 6 , 0 , 0 } , { 1 , 3 , 0 , 0 , 0 , 0 , 2 , 5 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 4 } , { 0 , 0 , 5 , 2 , 0 , 6 , 3 , 0 , 0 } } ; if ( solveSuduko ( grid , 0 , 0 ) == 1 ) print ( grid ) ; else printf ( \" No ▁ solution ▁ exists \" ) ; return 0 ; }"}
{"text": "Cetak subset dijumpai", "code": "void printSubset ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { printf ( \" % * d \" , 5 , A [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "QSORT Bandingkan fungsi", "code": "int comparator ( const void * pLhs , const void * pRhs ) { int * lhs = ( int * ) pLhs ; int * rhs = ( int * ) pRhs ; return * lhs > * rhs ; }"}
{"text": "input s - set vektor t - tuplet vektor s_size - set saiz t_size - saiz tuplet setakat ini jumlahnya", "code": "void subset_sum ( int s [ ] , int t [ ] , int s_size , int t_size , int sum , int ite , int const target_sum ) { total_nodes ++ ; if ( target_sum == sum ) {"}
{"text": "Kami menjumpai jumlah", "code": "printSubset ( t , t_size ) ;"}
{"text": "Cek Kekangan", "code": "if ( ite + 1 < s_size && sum - s [ ite ] + s [ ite + 1 ] <= target_sum ) {"}
{"text": "Tidak termasuk item tambahan sebelumnya dan pertimbangkan calon seterusnya", "code": "subset_sum ( s , t , s_size , t_size - 1 , sum - s [ ite ] , ite + 1 , target_sum ) ; } return ; } else {"}
{"text": "Cek Kekangan", "code": "if ( ite < s_size && sum + s [ ite ] <= target_sum ) {"}
{"text": "menjana nod sepanjang keluasan", "code": "for ( int i = ite ; i < s_size ; i ++ ) { t [ t_size ] = s [ i ] ; if ( sum + s [ i ] <= target_sum ) {"}
{"text": "Pertimbangkan nod tahap seterusnya (sepanjang kedalaman)", "code": "subset_sum ( s , t , s_size , t_size + 1 , sum + s [ i ] , i + 1 , target_sum ) ; } } } } }"}
{"text": "Pembalut yang mencetak subset yang jumlahnya ke target_sum", "code": "void generateSubsets ( int s [ ] , int size , int target_sum ) { int * tuplet_vector = ( int * ) malloc ( size * sizeof ( int ) ) ; int total = 0 ;"}
{"text": "Susun set", "code": "qsort ( s , size , sizeof ( int ) , & comparator ) ; for ( int i = 0 ; i < size ; i ++ ) { total += s [ i ] ; } if ( s [ 0 ] <= target_sum && total >= target_sum ) { subset_sum ( s , tuplet_vector , size , 0 , 0 , 0 , target_sum ) ; } free ( tuplet_vector ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int weights [ ] = { 15 , 22 , 14 , 26 , 32 , 9 , 16 , 8 } ; int target = 53 ; int size = ARRAYSIZE ( weights ) ; generateSubsets ( weights , size , target ) ; printf ( \" Nodes ▁ generated ▁ % d STRNEWLINE \" , total_nodes ) ; return 0 ; }"}
{"text": "Program c untuk memeriksa sama ada array yang diberikan mempunyai 2 elemen yang jumlahnya sama dengan nilai yang diberikan", "code": "#include <stdio.h> NEW_LINE #define MAX  100000"}
{"text": "berfungsi untuk memeriksa jumlah yang diberikan dalam array", "code": "void printPairs ( int arr [ ] , int arr_size , int sum ) { int i , temp ; bool s [ MAX ] = { 0 } ; for ( i = 0 ; i < arr_size ; i ++ ) { temp = sum - arr [ i ] ;"}
{"text": "Memeriksa keadaan", "code": "if ( s [ temp ] == 1 ) printf ( \" Pair ▁ with ▁ given ▁ sum ▁ % d ▁ is ▁ ( % d , ▁ % d ) ▁ n \" , sum , arr [ i ] , temp ) ; s [ arr [ i ] ] = 1 ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int n = 16 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; printPairs ( A , arr_size , n ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c rekursif untuk mengira kuasa modular", "code": "#include <stdio.h> NEW_LINE int exponentMod ( int A , int B , int C ) {"}
{"text": "Kes asas", "code": "if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ;"}
{"text": "Sekiranya B juga", "code": "long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; }"}
{"text": "Sekiranya B adalah ganjil", "code": "else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int A = 2 , B = 5 , C = 13 ; printf ( \" Power ▁ is ▁ % d \" , exponentMod ( A , B , C ) ) ; return 0 ; }"}
{"text": "Fungsi berulang untuk mengira (x ^ y) dalam o (log y)", "code": "int power ( int x , unsigned int y ) {"}
{"text": "Memulakan hasil", "code": "int res = 1 ; while ( y > 0 ) {"}
{"text": "Sekiranya Y adalah ganjil, kalikan x dengan hasil", "code": "if ( y & 1 ) res = res * x ;"}
{"text": "y mestilah sekarang y = y / 2", "code": "y = y >> 1 ;"}
{"text": "Tukar X ke X ^ 2", "code": "x = x * x ; } return res ; }"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Berfungsi untuk mendapatkan bilangan percubaan minimum yang diperlukan dalam kes terburuk dengan telur n dan l lantai", "code": "int eggDrop ( int n , int k ) {"}
{"text": "Sekiranya tiada lantai, maka tiada ujian diperlukan. Atau jika terdapat satu lantai, satu percubaan diperlukan.", "code": "if ( k == 1 k == 0 ) return k ;"}
{"text": "Kami memerlukan ujian k untuk satu lantai telur dan k", "code": "if ( n == 1 ) return k ; int min = INT_MAX , x , res ;"}
{"text": "Pertimbangkan semua kotoran dari lantai 1 ke lantai kth dan kembalikan minimum nilai -nilai ini ditambah 1.", "code": "for ( x = 1 ; x <= k ; x ++ ) { res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 2 , k = 10 ; printf ( \" nMinimum ▁ number ▁ of ▁ trials ▁ in ▁ \" \" worst ▁ case ▁ with ▁ % d ▁ eggs ▁ and ▁ \" \" % d ▁ floors ▁ is ▁ % d ▁ STRNEWLINE \" , n , k , eggDrop ( n , k ) ) ; return 0 ; }"}
{"text": "struct yang mengandungi anak kiri dan kanan nod semasa dan nilai utama", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "newNode () memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mencari maksimum dan minimum di pokok binari", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "Fungsi utiliti untuk membuat nod baru", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; }"}
{"text": "Mengembalikan nilai maksimum dalam pokok binari yang diberikan", "code": "int findMax ( struct Node * root ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return INT_MIN ;"}
{"text": "Pulangan maksimum 3 nilai: 1) Data Root 2) maksimum di subtree kiri 3) maksimum di subtree kanan", "code": "int res = root -> data ; int lres = findMax ( root -> left ) ; int rres = findMax ( root -> right ) ; if ( lres > res ) res = lres ; if ( rres > res ) res = rres ; return res ; }"}
{"text": "Kod pemacu", "code": "int main ( void ) { struct Node * NewRoot = NULL ; struct Node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" Maximum ▁ element ▁ is ▁ % d ▁ STRNEWLINE \" , findMax ( root ) ) ; return 0 ; }"}
{"text": "Mengembalikan nilai minimum dalam pokok binari yang diberikan", "code": "int findMin ( struct Node * root ) { if ( root == NULL ) return INT_MAX ; int res = root -> data ; int lres = findMin ( root -> left ) ; int rres = findMin ( root -> right ) ; if ( lres < res ) res = lres ; if ( rres < res ) res = rres ; return res ; }"}
{"text": "Program C untuk mengekstrak daun pokok binari dalam senarai dikaitkan dua kali", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Struktur untuk senarai pokok dan dikaitkan", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "Fungsi utama yang mengekstrak semua daun dari pokok binari yang diberikan. Fungsi ini mengembalikan akar baru pokok binari (perhatikan bahawa akar boleh menukar pokok binari hanya mempunyai satu nod). Fungsi ini juga menetapkan * head_ref sebagai ketua senarai dikaitkan. penunjuk pokok kiri digunakan seperti sebelumnya di DLL dan penunjuk kanan digunakan sebagai seterusnya", "code": "struct Node * extractLeafList ( struct Node * root , struct Node * * head_ref ) { if ( root == NULL ) return NULL ; if ( root -> left == NULL && root -> right == NULL ) { root -> right = * head_ref ; if ( * head_ref != NULL ) ( * head_ref ) -> left = root ; return NULL ; } root -> right = extractLeafList ( root -> right , head_ref ) ; root -> left = extractLeafList ( root -> left , head_ref ) ; return root ; }"}
{"text": "Fungsi utiliti untuk memperuntukkan nod untuk pokok binari.", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; }"}
{"text": "Fungsi utiliti untuk mencetak pokok di dalam - pesanan.", "code": "void print ( struct Node * root ) { if ( root != NULL ) { print ( root -> left ) ; printf ( \" % d ▁ \" , root -> data ) ; print ( root -> right ) ; } }"}
{"text": "Fungsi utiliti untuk mencetak senarai dikaitkan berganda.", "code": "void printList ( struct Node * head ) { while ( head ) { printf ( \" % d ▁ \" , head -> data ) ; head = head -> right ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct Node * head = NULL ; struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> left -> left -> left = newNode ( 7 ) ; root -> left -> left -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 9 ) ; root -> right -> right -> right = newNode ( 10 ) ; printf ( \" Inorder ▁ Trvaersal ▁ of ▁ given ▁ Tree ▁ is : STRNEWLINE \" ) ; print ( root ) ; root = extractLeafList ( root , & head ) ; printf ( \" Extracted Double Linked list is : \" printList ( head ) ; printf ( \" Inorder traversal of modified tree is : \" print ( root ) ; return 0 ; }"}
{"text": "Program c untuk nod nth dari traversals inorder", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct Node { int data ; struct Node * left ; struct Node * right ; } ;"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Memandangkan pokok binari, cetak nod nthennya", "code": "void NthInorder ( struct Node * node , int n ) { static int count = 0 ; if ( node == NULL ) return ; if ( count <= n ) {"}
{"text": "Pertama berulang pada anak kiri", "code": "NthInorder ( node -> left , n ) ; count ++ ;"}
{"text": "Apabila kiraan = n kemudian cetak elemen", "code": "if ( count == n ) printf ( \" % d ▁ \" , node -> data ) ;"}
{"text": "sekarang berulang pada anak yang betul", "code": "NthInorder ( node -> right , n ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct Node * root = newNode ( 10 ) ; root -> left = newNode ( 20 ) ; root -> right = newNode ( 30 ) ; root -> left -> left = newNode ( 40 ) ; root -> left -> right = newNode ( 50 ) ; int n = 4 ; NthInorder ( root , n ) ; return 0 ; }"}
{"text": "Pelaksanaan ringkas QuickSort yang menjadikan dua dua panggilan rekursif.", "code": "void quickSort ( int arr [ ] , int low , int high ) { if ( low < high ) {"}
{"text": "PI adalah indeks pembahagian, arr [p] kini berada di tempat yang betul", "code": "int pi = partition ( arr , low , high ) ;"}
{"text": "Secara berasingan menyusun elemen sebelum partition dan selepas partition", "code": "quickSort ( arr , low , pi - 1 ) ; quickSort ( arr , pi + 1 , high ) ; } }"}
{"text": "Program c untuk melaksanakan pendekatan di atas", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Berfungsi untuk mengira bilangan rentetan yang boleh dihasilkan dengan meletakkan ruang antara sepasang aksara bersebelahan", "code": "long long int countNumberOfStrings ( char * s ) {"}
{"text": "Panjang tali", "code": "int length = strlen ( s ) ;"}
{"text": "Kiraan kedudukan untuk ruang", "code": "int n = length - 1 ;"}
{"text": "Mengira kemungkinan rentetan", "code": "long long int count = pow ( 2 , n ) ; return count ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { char S [ ] = \" ABCD \" ; printf ( \" % lld \" , countNumberOfStrings ( S ) ) ; return 0 ; }"}
{"text": "Program c ++ untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengubah suai array untuk membuat jumlah elemen ganjil dan bahkan diindeks sama", "code": "void makeArraySumEqual ( int a [ ] , int N ) {"}
{"text": "Menyimpan kiraan 0 s, 1 s", "code": "int count_0 = 0 , count_1 = 0 ;"}
{"text": "Kedai Jumlah Elemen Ganjil dan Diindeks masing -masing", "code": "int odd_sum = 0 , even_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) {"}
{"text": "Kira 0 s", "code": "if ( a [ i ] == 0 ) count_0 ++ ;"}
{"text": "Kira 1 s", "code": "else count_1 ++ ;"}
{"text": "Kirakan odd_sum dan Even_sum", "code": "if ( ( i + 1 ) % 2 == 0 ) even_sum += a [ i ] ; else if ( ( i + 1 ) % 2 > 0 ) odd_sum += a [ i ] ; }"}
{"text": "Sekiranya kedua -duanya sama", "code": "if ( odd_sum == even_sum ) {"}
{"text": "Cetak array asal", "code": "for ( int i = 0 ; i < N ; i ++ ) printf ( \" % d ▁ \" , a [ i ] ) ; }"}
{"text": "Jika tidak", "code": "else { if ( count_0 >= N / 2 ) {"}
{"text": "Cetak semua 0 s", "code": "for ( int i = 0 ; i < count_0 ; i ++ ) printf ( \"0 ▁ \" ) ; } else {"}
{"text": "Untuk memeriksa walaupun atau ganjil", "code": "int is_Odd = count_1 % 2 ;"}
{"text": "Kemas kini jumlah kiraan 1 s", "code": "count_1 -= is_Odd ;"}
{"text": "Cetak semua 1 s", "code": "for ( int i = 0 ; i < count_1 ; i ++ ) printf ( \"1 ▁ \" ) ; } } }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberikan array arr []", "code": "int arr [ ] = { 1 , 1 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Panggilan fungsi", "code": "makeArraySumEqual ( arr , N ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Berfungsi untuk mengira bilangan nombor n - digit sedemikian rupa sehingga jumlah setiap digit berturut -turut adalah sama", "code": "int countDigitSum ( int N , int K ) {"}
{"text": "Julat nombor", "code": "int l = ( int ) pow ( 10 , N - 1 ) , r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ;"}
{"text": "Ekstrak digit nombor", "code": "int digits [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ;"}
{"text": "Simpan jumlah digit pertama K", "code": "for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ;"}
{"text": "Semak setiap digit K - berturut -turut menggunakan tetingkap gelongsor", "code": "for ( int j = K ; j < N ; j ++ ) { if ( sum - digits [ j - K ] + digits [ j ] != sum ) { flag = 1 ; break ; } } if ( flag == 0 ) count ++ ; } return count ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberikan integer n dan k", "code": "int N = 2 , K = 1 ; printf ( \" % d \" , countDigitSum ( N , K ) ) ; return 0 ; }"}
{"text": "Program C ++ untuk pendekatan di atas.", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "Berfungsi untuk mencari jalan cetak", "code": "void findpath ( int N , int a [ ] ) {"}
{"text": "Sekiranya [0] adalah 1", "code": "if ( a [ 0 ] ) {"}
{"text": "Jalan percetakan", "code": "printf ( \" % d ▁ \" , N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , i ) ; return ; }"}
{"text": "Mencari [i] = 0 dan [i + 1] = 1", "code": "for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ! a [ i ] && a [ i + 1 ] ) {"}
{"text": "Jalan percetakan", "code": "for ( int j = 1 ; j <= i ; j ++ ) printf ( \" % d ▁ \" , j ) ; printf ( \" % d ▁ \" , N + 1 ) ; for ( int j = i + 1 ; j <= N ; j ++ ) printf ( \" % d ▁ \" , j ) ; return ; } }"}
{"text": "Jika a [n - 1] = 0", "code": "for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , i ) ; printf ( \" % d ▁ \" , N + 1 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberikan input", "code": "int N = 3 , arr [ ] = { 0 , 1 , 0 } ;"}
{"text": "Panggilan fungsi", "code": "findpath ( N , arr ) ; }"}
{"text": "Kod CPP untuk Penyelesaian Berdasarkan Pengaturcaraan Dinamik untuk Masalah Knapsack 0 - 1", "code": "#include <stdio.h>"}
{"text": "Fungsi utiliti yang mengembalikan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Mencetak item yang dimasukkan ke dalam kapasiti kapasiti w", "code": "void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ;"}
{"text": "Bina Jadual K [] [] dengan cara bawah", "code": "for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } }"}
{"text": "menyimpan hasil knapsack", "code": "int res = K [ n ] [ W ] ; printf ( \" % d STRNEWLINE \" , res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) {"}
{"text": "Sama ada hasilnya datang dari bahagian atas (k [i - 1] [w]) atau dari (val [i - 1] + k [i - 1] [w - wt [i - 1]]) seperti dalam jadual knapsack. Jika ia datang dari yang terakhir / ia bermakna item itu dimasukkan.", "code": "if ( res == K [ i - 1 ] [ w ] ) continue ; else {"}
{"text": "Item ini dimasukkan.", "code": "printf ( \" % d ▁ \" , wt [ i - 1 ] ) ;"}
{"text": "Oleh kerana berat ini dimasukkan nilainya ditolak", "code": "res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printknapSack ( W , wt , val , n ) ; return 0 ; }"}
{"text": "Pelaksanaan rekursi naif masalah pokok carian binari yang optimum", "code": "#include <stdio.h> NEW_LINE #include <limits.h>"}
{"text": "Fungsi rekursif untuk mengira kos pokok carian binari yang optimum", "code": "int optCost ( int freq [ ] , int i , int j ) {"}
{"text": "Kes Asas Jika (J <i) Tiada unsur dalam subarray ini", "code": "return 0 ;"}
{"text": "Satu elemen dalam subarray ini", "code": "if ( j == i ) return freq [ i ] ;"}
{"text": "Dapatkan jumlah freq [i], freq [i + 1], ... freq [j]", "code": "int fsum = sum ( freq , i , j ) ;"}
{"text": "Mulakan nilai minimum", "code": "int min = INT_MAX ;"}
{"text": "Satu demi satu menganggap semua elemen sebagai akar dan rekursif mencari kos BST, bandingkan kos dengan min dan kemas kini min jika diperlukan", "code": "for ( int r = i ; r <= j ; ++ r ) { int cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; }"}
{"text": "Pulangan nilai minimum", "code": "return min + fsum ; }"}
{"text": "Fungsi utama yang mengira kos minimum pokok carian binari. Ia terutamanya menggunakan OptCost () untuk mencari kos yang optimum.", "code": "int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) {"}
{"text": "Di sini kunci array [] diandaikan disusun dalam peningkatan urutan. Jika kekunci [] tidak disusun, kemudian tambahkan kod untuk menyusun kekunci, dan menyusun semula Freq [] dengan sewajarnya.", "code": "return optCost ( freq , 0 , n - 1 ) ; }"}
{"text": "Fungsi utiliti untuk mendapatkan jumlah unsur array freq [i] ke freq [j]", "code": "int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; printf ( \" Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ % d ▁ \" , optimalSearchTree ( keys , freq , n ) ) ; return 0 ; }"}
{"text": "Penyelesaian pengaturcaraan yang dinamik untuk masalah bungkus perkataan", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #define INF  INT_MAX"}
{"text": "Fungsi utiliti untuk mencetak penyelesaian", "code": "int printSolution ( int p [ ] , int n ) ;"}
{"text": "L [] mewakili panjang perkataan yang berbeza dalam urutan input. Sebagai contoh, l [] = {3, 2, 2, 5} adalah untuk ayat seperti \"aaa u u u u ddddd\". n adalah saiz l [] dan m adalah lebar garis (maksimum no aksara yang boleh muat dalam garis)", "code": "void solveWordWrap ( int l [ ] , int n , int M ) {"}
{"text": "Tambahan [i] [j] akan mempunyai bilangan ruang tambahan jika kata -kata dari saya ke j diletakkan dalam satu baris", "code": "int extras [ n + 1 ] [ n + 1 ] ;"}
{"text": "LC [i] [j] akan mempunyai kos garis yang mempunyai kata -kata dari saya ke j", "code": "int lc [ n + 1 ] [ n + 1 ] ;"}
{"text": "C [i] akan mempunyai jumlah kos susunan kata yang optimum dari 1 hingga i", "code": "int c [ n + 1 ] ;"}
{"text": "P [] digunakan untuk mencetak penyelesaian.", "code": "int p [ n + 1 ] ; int i , j ;"}
{"text": "Kirakan ruang tambahan dalam satu baris. Nilai tambahan [i] [j] menunjukkan ruang tambahan jika perkataan dari nombor perkataan i ke j diletakkan dalam satu baris", "code": "for ( i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; }"}
{"text": "Kirakan kos garis yang sepadan dengan ruang tambahan yang dikira di atas. Nilai lc [i] [j] menunjukkan kos meletakkan kata -kata dari nombor perkataan i ke j dalam satu baris", "code": "for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = INF ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } }"}
{"text": "Kirakan kos minimum dan cari susunan kos minimum. Nilai C [j] menunjukkan kos yang dioptimumkan untuk mengatur perkataan dari nombor perkataan 1 hingga j.", "code": "c [ 0 ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { c [ j ] = INF ; for ( i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != INF && lc [ i ] [ j ] != INF && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; } int printSolution ( int p [ ] , int n ) { int k ; if ( p [ n ] == 1 ) k = 1 ; else k = printSolution ( p , p [ n ] - 1 ) + 1 ; printf ( \" Line ▁ number ▁ % d : ▁ From ▁ word ▁ no . ▁ % d ▁ to ▁ % d ▁ STRNEWLINE \" , k , p [ n ] , n ) ; return k ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int l [ ] = { 3 , 2 , 2 , 5 } ; int n = sizeof ( l ) / sizeof ( l [ 0 ] ) ; int M = 6 ; solveWordWrap ( l , n , M ) ; return 0 ; }"}
{"text": "Pengaturcaraan dinamik berdasarkan teka -teki menjatuhkan telur", "code": "#include <limits.h> NEW_LINE #include <stdio.h>"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Berfungsi untuk mendapatkan bilangan percubaan minimum yang diperlukan dalam kes terburuk dengan telur n dan l lantai", "code": "int eggDrop ( int n , int k ) {"}
{"text": "Jadual 2D di mana kemasukan urgfloor [i] [j] akan mewakili bilangan minimum ujian yang diperlukan untuk saya telur dan lantai j.", "code": "int eggFloor [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ;"}
{"text": "Kami memerlukan satu percubaan untuk satu tingkat dan 0 ujian untuk 0 tingkat", "code": "for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; }"}
{"text": "Kami sentiasa memerlukan ujian untuk satu lantai telur dan J.", "code": "for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ;"}
{"text": "Isi sisa penyertaan dalam jadual menggunakan harta substruktur yang optimum", "code": "for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = INT_MAX ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } }"}
{"text": "urgfloor [n] [k] memegang hasilnya", "code": "return eggFloor [ n ] [ k ] ; }"}
{"text": "Program Pemandu untuk Menguji ProntDups", "code": "int main ( ) { int n = 2 , k = 36 ; printf ( \" Minimum number of trials \" STRNEWLINE \" in worst case with % d eggs and \" STRNEWLINE \" % d floors is % d \" , n , k , eggDrop ( n , k ) ) ; return 0 ; }"}
{"text": "Pelaksanaan rekursif naif masalah 0 - 1 Knapsack", "code": "#include <stdio.h>"}
{"text": "Fungsi utiliti yang mengembalikan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Mengembalikan nilai maksimum yang boleh dimasukkan ke dalam kapasiti kapasiti w", "code": "int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {"}
{"text": "Kes asas", "code": "if ( n == 0 W == 0 ) return 0 ;"}
{"text": "Sekiranya berat item nth lebih daripada kapasiti knapsack w, maka item ini tidak dapat dimasukkan dalam penyelesaian yang optimum", "code": "if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ;"}
{"text": "Kembalikan maksimum dua kes: (1) item nth termasuk (2) tidak termasuk", "code": "else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printf ( \" % d \" , knapSack ( W , wt , val , n ) ) ; return 0 ; }"}
{"text": "Pelaksanaan Rekursif Naive masalah LIS", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "menyimpan lis", "code": "let max_ref ;"}
{"text": "Untuk menggunakan panggilan rekursif, fungsi ini mesti mengembalikan dua perkara: 1) panjang lis yang berakhir dengan elemen arr [n - 1]. Kami menggunakan max_ending_here untuk tujuan ini2) maksimum maksimum kerana LIS mungkin berakhir dengan elemen sebelum arr [n - 1] max_ref digunakan tujuan ini. Nilai LIS pelbagai saiz n disimpan dalam * max_ref yang merupakan hasil akhir kami", "code": "int _lis ( int arr [ ] , int n , int * max_ref ) {"}
{"text": "Kes asas", "code": "if ( n == 1 ) return 1 ;"}
{"text": "'max _ ending _ here' adalah panjang lis yang berakhir dengan arr [n - 1]", "code": "int res , max_ending_here = 1 ;"}
{"text": "Recursively mendapatkan semua lis yang berakhir dengan arr [0], arr [1] ... arr [n - 2]. Jika arr [i - 1] lebih kecil daripada arr [n - 1], dan max berakhir dengan arr [n - 1] perlu dikemas kini, kemudian kemas kini", "code": "for ( int i = 1 ; i < n ; i ++ ) { res = _lis ( arr , i , max_ref ) ; if ( arr [ i - 1 ] < arr [ n - 1 ] && res + 1 > max_ending_here ) max_ending_here = res + 1 ; }"}
{"text": "Bandingkan max_ending_here dengan keseluruhan maks. Dan mengemas kini max keseluruhan jika diperlukan", "code": "if ( * max_ref < max_ending_here ) * max_ref = max_ending_here ;"}
{"text": "Panjang kembali lis yang berakhir dengan arr [n - 1]", "code": "return max_ending_here ; }"}
{"text": "Fungsi pembalut untuk _lis ()", "code": "int lis ( int arr [ ] , int n ) {"}
{"text": "Pemboleh ubah max memegang hasilnya", "code": "int max = 1 ;"}
{"text": "Fungsi _lis () menyimpan hasilnya dalam maksimum", "code": "_lis ( arr , n , & max ) ;"}
{"text": "mengembalikan max", "code": "return max ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Length ▁ of ▁ lis ▁ is ▁ % d \" , lis ( arr , n ) ) ; return 0 ; }"}
{"text": "Berikut program adalah pelaksanaan algoritma Rabin Karp yang diberikan dalam Buku CLRS", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "D adalah bilangan aksara dalam abjad input", "code": "#define d  256"}
{"text": "Pat -> Corak Txt -> Teks Q -> Nombor Perdana", "code": "void search ( char pat [ ] , char txt [ ] , int q ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i , j ;"}
{"text": "int p = 0; nilai hash untuk corak int t = 0; nilai hash untuk txt", "code": "int h = 1 ;"}
{"text": "Nilai H ialah \"pow (d, u, 1) % q\"", "code": "for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ;"}
{"text": "Kirakan nilai hash corak dan tetingkap teks pertama", "code": "for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; }"}
{"text": "Luncurkan corak ke atas teks satu demi satu", "code": "for ( i = 0 ; i <= N - M ; i ++ ) {"}
{"text": "Semak nilai hash tetingkap semasa teks dan corak. Sekiranya nilai hash sepadan maka hanya periksa aksara oleh satu", "code": "if ( p == t ) {"}
{"text": "Periksa watak satu demi satu", "code": "for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; }"}
{"text": "jika p == t dan pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]", "code": "if ( j == M ) printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; }"}
{"text": "Hitung nilai hash untuk tetingkap teks seterusnya: Keluarkan digit terkemuka, tambahkan digit trailing", "code": "if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ;"}
{"text": "Kita mungkin mendapat nilai negatif t, menukarnya kepada positif", "code": "if ( t < 0 ) t = ( t + q ) ; } } }"}
{"text": "Kod pemacu", "code": "int main ( ) { char txt [ ] = \" GEEKS ▁ FOR ▁ GEEKS \" ; char pat [ ] = \" GEEK \" ;"}
{"text": "Nombor perdana", "code": "int q = 101 ;"}
{"text": "panggilan fungsi", "code": "search ( pat , txt , q ) ; return 0 ; }"}
{"text": "Program C untuk masalah lawatan ksatria", "code": "#include <stdio.h> NEW_LINE #define N  8 NEW_LINE int solveKTUtil ( int x , int y , int movei , int sol [ N ] [ N ] , int xMove [ ] , int yMove [ ] ) ;"}
{"text": "Fungsi utiliti untuk memeriksa sama ada saya, j adalah indeks yang sah untuk n * n catursboard", "code": "int isSafe ( int x , int y , int sol [ N ] [ N ] ) { return ( x >= 0 && x < N && y >= 0 && y < N && sol [ x ] [ y ] == -1 ) ; }"}
{"text": "Fungsi utiliti untuk mencetak penyelesaian matriks sol [n] [n]", "code": "void printSolution ( int sol [ N ] [ N ] ) { for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < N ; y ++ ) printf ( \" ▁ % 2d ▁ \" , sol [ x ] [ y ] ) ; printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Fungsi ini menyelesaikan masalah Tour Knight menggunakan backtracking. Fungsi ini terutamanya menggunakan Solvektutil () untuk menyelesaikan masalah. Ia mengembalikan palsu jika tiada lawatan lengkap mungkin, jika tidak, kembali benar dan mencetak lawatan. Sila ambil perhatian bahawa mungkin terdapat lebih daripada satu penyelesaian, fungsi ini mencetak salah satu penyelesaian yang boleh dilaksanakan.", "code": "int solveKT ( ) { int sol [ N ] [ N ] ;"}
{"text": "Permulaan matriks penyelesaian", "code": "for ( int x = 0 ; x < N ; x ++ ) for ( int y = 0 ; y < N ; y ++ ) sol [ x ] [ y ] = -1 ;"}
{"text": "Xmove [] dan YMove [] Tentukan langkah seterusnya Knight. xmove [] adalah untuk nilai seterusnya x koordinat ymove [] adalah untuk nilai seterusnya koordinat y", "code": "int xMove [ 8 ] = { 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 } ; int yMove [ 8 ] = { 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 } ;"}
{"text": "Sejak Knight pada mulanya di blok pertama", "code": "sol [ 0 ] [ 0 ] = 0 ;"}
{"text": "Mulakan dari 0, 0 dan terokai semua lawatan menggunakan Solvektutil ()", "code": "if ( solveKTUtil ( 0 , 0 , 1 , sol , xMove , yMove ) == 0 ) { printf ( \" Solution ▁ does ▁ not ▁ exist \" ) ; return 0 ; } else printSolution ( sol ) ; return 1 ; }"}
{"text": "Fungsi utiliti rekursif untuk menyelesaikan masalah lawatan ksatria", "code": "int solveKTUtil ( int x , int y , int movei , int sol [ N ] [ N ] , int xMove [ N ] , int yMove [ N ] ) { int k , next_x , next_y ; if ( movei == N * N ) return 1 ;"}
{"text": "Cuba semua langkah seterusnya dari koordinat semasa x, y", "code": "for ( k = 0 ; k < 8 ; k ++ ) { next_x = x + xMove [ k ] ; next_y = y + yMove [ k ] ; if ( isSafe ( next_x , next_y , sol ) ) { sol [ next_x ] [ next_y ] = movei ; if ( solveKTUtil ( next_x , next_y , movei + 1 , sol , xMove , yMove ) == 1 ) return 1 ; else"}
{"text": "mundur", "code": "sol [ next_x ] [ next_y ] = -1 ; } } return 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Panggilan fungsi", "code": "solveKT ( ) ; return 0 ; }"}
{"text": "Bilangan simpang dalam graf", "code": "#define V  4 NEW_LINE void printSolution ( int color [ ] ) ;"}
{"text": "Fungsi utiliti untuk mencetak penyelesaian", "code": "void printSolution ( int color [ ] ) { printf ( \" Solution ▁ Exists : \" \" ▁ Following ▁ are ▁ the ▁ assigned ▁ colors ▁ STRNEWLINE \" ) ; for ( int i = 0 ; i < V ; i ++ ) printf ( \" ▁ % d ▁ \" , color [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "periksa sama ada graf berwarna selamat atau tidak", "code": "bool isSafe ( bool graph [ V ] [ V ] , int color [ ] ) {"}
{"text": "Periksa setiap kelebihan", "code": "for ( int i = 0 ; i < V ; i ++ ) for ( int j = i + 1 ; j < V ; j ++ ) if ( graph [ i ] [ j ] && color [ j ] == color [ i ] ) return false ; return true ; }"}
{"text": "Fungsi ini menyelesaikan masalah pewarna M menggunakan rekursi. Ia mengembalikan palsu jika warna M tidak dapat diberikan, jika tidak, pulangkan semula dan mencetak tugasan warna ke semua simpul. Sila ambil perhatian bahawa mungkin terdapat lebih daripada satu penyelesaian, fungsi ini mencetak salah satu penyelesaian yang boleh dilaksanakan.", "code": "bool graphColoring ( bool graph [ V ] [ V ] , int m , int i , int color [ V ] ) {"}
{"text": "Sekiranya indeks semasa mencapai akhir", "code": "if ( i == V ) {"}
{"text": "Sekiranya pewarna selamat", "code": "if ( isSafe ( graph , color ) ) {"}
{"text": "Cetak penyelesaiannya", "code": "printSolution ( color ) ; return true ; } return false ; }"}
{"text": "Tetapkan setiap warna dari 1 hingga m", "code": "for ( int j = 1 ; j <= m ; j ++ ) { color [ i ] = j ;"}
{"text": "Berulang dari simpul selebihnya", "code": "if ( graphColoring ( graph , m , i + 1 , color ) ) return true ; color [ i ] = 0 ; } return false ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Buat grafik berikut dan ujian sama ada 3 boleh berwarna (3) - - (2) | / | | / | | / | (0) - - (1)", "code": "bool graph [ V ] [ V ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 1 } , { 1 , 0 , 1 , 0 } , } ;"}
{"text": "Bilangan warna", "code": "int m = 3 ;"}
{"text": "Inisialisasi semua nilai warna sebagai 0. Inisialisasi ini diperlukan fungsi yang betul dari Issafe ()", "code": "int color [ V ] ; for ( int i = 0 ; i < V ; i ++ ) color [ i ] = 0 ; if ( ! graphColoring ( graph , m , 0 , color ) ) printf ( \" Solution ▁ does ▁ not ▁ exist \" ) ; return 0 ; }"}
{"text": "C pelaksanaan untuk mencari kuasa sebelumnya dan seterusnya k", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Berfungsi untuk mengembalikan kuasa tertinggi k kurang daripada atau sama dengan n", "code": "int prevPowerofK ( int n , int k ) { int p = ( int ) ( log ( n ) / log ( k ) ) ; return ( int ) pow ( k , p ) ; }"}
{"text": "Berfungsi untuk mengembalikan kuasa terkecil k lebih besar daripada atau sama dengan n", "code": "int nextPowerOfK ( int n , int k ) { return prevPowerofK ( n , k ) * k ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int N = 7 ; int K = 2 ; printf ( \" % d ▁ \" , prevPowerofK ( N , K ) ) ; printf ( \" % d STRNEWLINE \" , nextPowerOfK ( N , K ) ) ; return 0 ; }"}
{"text": "Program C untuk mencari GCD daripada dua nombor", "code": "#include <stdio.h>"}
{"text": "Fungsi rekursif untuk mengembalikan GCD a dan b", "code": "int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int a = 98 , b = 56 ; printf ( \" GCD ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "C Program untuk memeriksa sama ada nombor adalah semiprime atau tidak", "code": "#include <stdio.h>"}
{"text": "Fungsi utiliti untuk memeriksa sama ada nombor adalah semiprime atau tidak", "code": "int checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) while ( num % i == 0 ) num /= i , ++ cnt ;"}
{"text": "Sekiranya nombor lebih besar daripada 1, tambahkannya ke pemboleh ubah kiraan kerana ia menunjukkan bilangan yang kekal adalah nombor utama", "code": "if ( num > 1 ) ++ cnt ;"}
{"text": "Kembali '1' jika kiraan sama dengan '2' lain kembali '0'", "code": "return cnt == 2 ; }"}
{"text": "Berfungsi untuk mencetak 'benar' atau 'palsu' mengikut keadaan semiprime", "code": "void semiprime ( int n ) { if ( checkSemiprime ( n ) ) printf ( \" True STRNEWLINE \" ) ; else printf ( \" False STRNEWLINE \" ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 6 ; semiprime ( n ) ; n = 8 ; semiprime ( n ) ; return 0 ; }"}
{"text": "Program C Rekursif untuk mencetak Pesanan Tahap Terbalik", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk ke anak kiri dan kanan", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi protoypes", "code": "void printGivenLevel ( struct node * root , int level ) ; int height ( struct node * node ) ; struct node * newNode ( int data ) ;"}
{"text": "Berfungsi untuk mencetak pesanan tahap terbalik traversal pokok", "code": "void reverseLevelOrder ( struct node * root ) { int h = height ( root ) ; int i ; for ( i = h ; i >= 1 ; i -- ) printGivenLevel ( root , i ) ; }"}
{"text": "Cetak nod pada tahap tertentu", "code": "void printGivenLevel ( struct node * root , int level ) { if ( root == NULL ) return ; if ( level == 1 ) printf ( \" % d ▁ \" , root -> data ) ; else if ( level > 1 ) { printGivenLevel ( root -> left , level - 1 ) ; printGivenLevel ( root -> right , level - 1 ) ; } }"}
{"text": "Kirakan \"ketinggian\" pokok - bilangan nod di sepanjang laluan terpanjang dari nod akar ke nod daun terjauh.", "code": "int height ( struct node * node ) { if ( node == NULL ) return 0 ; else {"}
{"text": "Kirakan ketinggian setiap subtree", "code": "int lheight = height ( node -> left ) ; int rheight = height ( node -> right ) ;"}
{"text": "Gunakan yang lebih besar", "code": "if ( lheight > rheight ) return ( lheight + 1 ) ; else return ( rheight + 1 ) ; } }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Mari kita buat pokok yang ditunjukkan dalam rajah di atas", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ tree ▁ is ▁ STRNEWLINE \" ) ; reverseLevelOrder ( root ) ; return 0 ; }"}
{"text": "Program c untuk carian berurutan yang diindeks", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void indexedSequentialSearch ( int arr [ ] , int n , int k ) { int elements [ 20 ] , indices [ 20 ] , temp , i , set = 0 ; int j = 0 , ind = 0 , start , end ; for ( i = 0 ; i < n ; i += 3 ) {"}
{"text": "Menyimpan elemen", "code": "elements [ ind ] = arr [ i ] ;"}
{"text": "Menyimpan indeks", "code": "indices [ ind ] = i ; ind ++ ; } if ( k < elements [ 0 ] ) { printf ( \" Not ▁ found \" ) ; exit ( 0 ) ; } else { for ( i = 1 ; i <= ind ; i ++ ) if ( k <= elements [ i ] ) { start = indices [ i - 1 ] ; end = indices [ i ] ; set = 1 ; break ; } } if ( set == 0 ) { start = indices [ i - 1 ] ; end = n ; } for ( i = start ; i <= end ; i ++ ) { if ( k == arr [ i ] ) { j = 1 ; break ; } } if ( j == 1 ) printf ( \" Found ▁ at ▁ index ▁ % d \" , i ) ; else printf ( \" Not ▁ found \" ) ; }"}
{"text": "Kod pemacu", "code": "void main ( ) { int arr [ ] = { 6 , 7 , 8 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Elemen untuk mencari", "code": "int k = 8 ;"}
{"text": "Panggilan fungsi", "code": "indexedSequentialSearch ( arr , n , k ) ; }"}
{"text": "Program C Mudah untuk mencetak unsur -unsur kecil seterusnya dalam array yang diberikan", "code": "#include <stdio.h>"}
{"text": "Cetak elemen dan pasangan NSE untuk semua elemen arr [] saiz n", "code": "void printNSE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } printf ( \" % d ▁ - - ▁ % d STRNEWLINE \" , arr [ i ] , next ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNSE ( arr , n ) ; return 0 ; }"}
{"text": "Program C untuk pelaksanaan jenis radix MSD menggunakan sort counting ()", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h>"}
{"text": "Fungsi utiliti untuk mencetak array", "code": "void print ( int * arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { printf ( \" % d , ▁ \" , arr [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Fungsi utiliti untuk mendapatkan digit di indeks d dalam integer", "code": "int digit_at ( int x , int d ) { return ( int ) ( x / pow ( 10 , d - 1 ) ) % 10 ; }"}
{"text": "berfungsi untuk menyusun array menggunakan jenis radix msd secara rekursif", "code": "void MSD_sort ( int * arr , int lo , int hi , int d ) {"}
{"text": "keadaan rehat rekursi", "code": "if ( hi <= lo d < 1 ) { return ; } int count [ 10 + 2 ] = { 0 } ;"}
{"text": "Temp dicipta dengan mudah menukar tali di arr []", "code": "int temp [ n ] ;"}
{"text": "Simpan kejadian watak yang paling penting dari setiap integer dalam kiraan []", "code": "for ( int i = lo ; i <= hi ; i ++ ) { int c = digit_at ( arr [ i ] , d ) ; count ++ ; }"}
{"text": "Tukar kiraan [] supaya kiraan [] kini mengandungi kedudukan sebenar digit ini dalam temp []", "code": "for ( int r = 0 ; r < 10 + 1 ; r ++ ) count [ r + 1 ] += count [ r ] ;"}
{"text": "Bina temp", "code": "for ( int i = lo ; i <= hi ; i ++ ) { int c = digit_at ( arr [ i ] , d ) ; temp [ count ++ ] = arr [ i ] ; }"}
{"text": "Salin semua integer temp ke arr [], supaya arr [] kini mengandungi bilangan bulat yang disusun sebahagiannya", "code": "for ( int i = lo ; i <= hi ; i ++ ) { arr [ i ] = temp [ i - lo ] ; }"}
{"text": "Rekursif msd_sort () pada setiap bilangan bulat yang disusun sebahagiannya ditetapkan untuk menyusunnya dengan digit seterusnya", "code": "for ( int r = 0 ; r < 10 ; r ++ ) MSD_sort ( arr , lo + count [ r ] , lo + count [ r + 1 ] - 1 , d - 1 ) ; }"}
{"text": "Fungsi Cari integer terbesar", "code": "int getMax ( int arr [ ] , int n ) { int mx = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > mx ) mx = arr [ i ] ; return mx ; }"}
{"text": "Fungsi Utama Untuk Memanggil MSD_SORT", "code": "void radixsort ( int * arr , int n ) {"}
{"text": "Cari nombor maksimum untuk mengetahui bilangan digit", "code": "int m = getMax ( arr , n ) ;"}
{"text": "Dapatkan panjang integer terbesar", "code": "int d = floor ( log10 ( abs ( m ) ) ) + 1 ;"}
{"text": "panggilan fungsi", "code": "MSD_sort ( arr , 0 , n - 1 , d ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Arahan input", "code": "int arr [ ] = { 9330 , 9950 , 718 , 8977 , 6790 , 95 , 9807 , 741 , 8586 , 5710 } ;"}
{"text": "Saiz array", "code": "n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Unsorted ▁ array ▁ : ▁ \" ) ;"}
{"text": "Cetak array yang tidak disusun", "code": "print ( arr , n ) ;"}
{"text": "Panggilan fungsi", "code": "radixsort ( arr , n ) ; printf ( \" Sorted ▁ array ▁ : ▁ \" ) ;"}
{"text": "Cetak array yang disusun", "code": "print ( arr , n ) ; return 0 ; }"}
{"text": "Bergabung di tempat C", "code": "#include <stddef.h> NEW_LINE #include <stdio.h> NEW_LINE #define __INSERT_THRESH  5 NEW_LINE #define __swap ( x , y )  (t = *(x), *(x) = *(y), *(y) = t)"}
{"text": "Kedua -dua sub -tatasusunan yang disusun mesti bersebelahan dengan 'a' 'an' adalah panjang seksyen yang disusun pertama dalam 'a' 'bn' adalah panjang seksyen yang disusun kedua dalam 'a'", "code": "static void merge ( int * a , size_t an , size_t bn ) { int * b = a + an , * e = b + bn , * s , t ;"}
{"text": "Kembali sekarang jika kita selesai", "code": "if ( an == 0 || bn == 0 || ! ( * b < * ( b - 1 ) ) ) return ;"}
{"text": "Adakah penyisipan sort untuk bergabung jika saiz sub - array cukup kecil", "code": "if ( an < __INSERT_THRESH && an <= bn ) { for ( int * p = b , * v ; p > a ;"}
{"text": "p -) masukkan Sort A ke b", "code": "for ( v = p , s = p - 1 ; v < e && * v < * s ; s = v , v ++ ) __swap ( s , v ) ; return ; } if ( bn < __INSERT_THRESH ) { for ( int * p = b , * v ; p < e ;"}
{"text": "p ++) masukkan sort b ke dalam a", "code": "for ( s = p , v = p - 1 ; s > a && * s < * v ; s = v , v -- ) __swap ( s , v ) ; return ; }"}
{"text": "Cari mata pivot. Pada dasarnya ini hanya mencari titik dalam 'A' di mana kita boleh menukar di bahagian pertama 'B' sehingga selepas swap elemen terakhir dalam 'A' akan kurang dari atau sama dengan elemen paling sedikit dalam 'B'", "code": "int * pa = a , * pb = b ; for ( s = a ; s < b && pb < e ; s ++ ) if ( * pb < * pa ) pb ++ ; else pa ++ ; pa += b - s ;"}
{"text": "Tukar bahagian pertama B dengan bahagian terakhir a", "code": "for ( int * la = pa , * fb = b ; la < b ; la ++ , fb ++ ) __swap ( la , fb ) ;"}
{"text": "Sekarang gabungkan dua pasangan sub - array", "code": "merge ( a , pa - a , pb - b ) ; merge ( b , pb - b , e - pb ) ;"}
{"text": "} Merge_array_inplace", "code": "#undef  __swap NEW_LINE #undef  __INSERT_THRESH"}
{"text": "Gabungkan pelaksanaan jenis", "code": "void merge_sort ( int * a , size_t n ) { size_t m = ( n + 1 ) / 2 ;"}
{"text": "Susun bahagian pertama dan kedua", "code": "if ( m > 1 ) merge_sort ( a , m ) ; if ( n - m > 1 ) merge_sort ( a + m , n - m ) ;"}
{"text": "Sekarang gabungkan dua sub - tatasusunan yang disusun bersama", "code": "merge ( a , m , n - m ) ; }"}
{"text": "Berfungsi untuk mencetak array", "code": "void print_array ( int a [ ] , size_t n ) { if ( n > 0 ) { printf ( \" % d \" , a [ 0 ] ) ; for ( size_t i = 1 ; i < n ; i ++ ) printf ( \" ▁ % d \" , a [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Program pemacu untuk menguji jenis utiliyy", "code": "int main ( ) { int a [ ] = { 3 , 16 , 5 , 14 , 8 , 10 , 7 , 15 , 1 , 13 , 4 , 9 , 12 , 11 , 6 , 2 } ; size_t n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; merge_sort ( a , n ) ; print_array ( a , n ) ; return 0 ; }"}
{"text": "Fungsi rekursif berasaskan carian pertama yang mendalam yang mengembalikan benar jika padanan untuk puncak u mungkin", "code": "bool bpm ( int table [ M ] [ N ] , int u , bool seen [ ] , int matchR [ ] ) {"}
{"text": "Cuba setiap penerima satu persatu", "code": "for ( int v = 0 ; v < N ; v ++ ) {"}
{"text": "Sekiranya Pengirim U mempunyai paket untuk dihantar ke penerima v dan penerima v belum dipetakan ke mana -mana penghantar lain, semak jika bilangan paket lebih besar daripada '0' kerana hanya satu paket yang boleh dihantar dalam jangka masa", "code": "if ( table [ u ] [ v ] > 0 && ! seen [ v ] ) {"}
{"text": "Mark V Seperti yang dikunjungi", "code": "seen [ v ] = true ;"}
{"text": "Jika penerima 'V' tidak diberikan kepada mana -mana penghantar atau pengirim yang ditugaskan sebelum ini untuk penerima V (yang matchr [v]) mempunyai penerima alternatif yang tersedia. Oleh kerana v ditandakan seperti yang dikunjungi dalam baris di atas, Matchr [v] dalam panggilan rekursif berikut tidak akan mendapat penerima 'V' lagi", "code": "if ( matchR [ v ] < 0 || bpm ( table , matchR [ v ] , seen , matchR ) ) { matchR [ v ] = u ; return true ; } } } return false ; }"}
{"text": "Mengembalikan bilangan maksimum paket yang boleh dihantar secara selalunya dalam slot 1 masa dari pengirim ke penerima", "code": "int maxBPM ( int table [ M ] [ N ] ) {"}
{"text": "Arahan untuk menjejaki penerima yang diberikan kepada pengirim. Nilai matchr [i] adalah ID pengirim yang diberikan kepada penerima i. Nilai - 1 menunjukkan tiada siapa yang diberikan.", "code": "int matchR [ N ] ;"}
{"text": "Pada mulanya semua penerima tidak dipetakan ke mana -mana penghantar", "code": "memset ( matchR , -1 , sizeof ( matchR ) ) ;"}
{"text": "Kiraan penerima yang diberikan kepada pengirim", "code": "int result = 0 ; for ( int u = 0 ; u < M ; u ++ ) {"}
{"text": "Tandakan semua penerima seperti yang tidak dilihat untuk pengirim seterusnya", "code": "bool seen [ N ] ; memset ( seen , 0 , sizeof ( seen ) ) ;"}
{"text": "Cari jika pengirim 'u' dapat diberikan kepada penerima", "code": "if ( bpm ( table , u , seen , matchR ) ) result ++ ; } cout << \" The ▁ number ▁ of ▁ maximum ▁ packets ▁ sent ▁ in ▁ the ▁ time ▁ slot ▁ is ▁ \" << result << \" STRNEWLINE \" ; for ( int x = 0 ; x < N ; x ++ ) if ( matchR [ x ] + 1 != 0 ) cout << \" T \" << matchR [ x ] + 1 << \" - > ▁ R \" << x + 1 << \" STRNEWLINE \" ; return result ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int table [ M ] [ N ] = { { 0 , 2 , 0 } , { 3 , 0 , 1 } , { 2 , 4 , 0 } } ; int max_flow = maxBPM ( table ) ; return 0 ; }"}
{"text": "Program C untuk menyahkodkan rentetan yang dikodkan Base64 kembali ke rentetan ASCII", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define SIZE  100"}
{"text": "char_set = \"abcdefghijklmnopqrstuvwxyz dalam abcdefghijklmnopqrstuvwxyz0123456789 + /\"", "code": "char * base64Decoder ( char encoded [ ] , int len_str ) { char * decoded_string ; decoded_string = ( char * ) malloc ( sizeof ( char ) * SIZE ) ; int i , j , k = 0 ;"}
{"text": "menyimpan bitstream.", "code": "int num = 0 ;"}
{"text": "Count_bits menyimpan bilangan bit semasa dalam NUM.", "code": "int count_bits = 0 ;"}
{"text": "Memilih 4 aksara dari rentetan yang dikodkan pada satu masa. Cari kedudukan setiap watak yang dikodkan dalam char_set dan kedai di NUM.", "code": "for ( i = 0 ; i < len_str ; i += 4 ) { num = 0 , count_bits = 0 ; for ( j = 0 ; j < 4 ; j ++ ) {"}
{"text": "Buat ruang untuk 6 bit.", "code": "if ( encoded [ i + j ] != ' = ' ) { num = num << 6 ; count_bits += 6 ; }"}
{"text": "Dikodkan [i + j] = 'e', ​​'e' - 'a' = 5 'e' mempunyai kedudukan ke -5 dalam char_set.", "code": "if ( encoded [ i + j ] >= ' A ' && encoded [ i + j ] <= ' Z ' ) num = num | ( encoded [ i + j ] - ' A ' ) ;"}
{"text": "dikodkan [i + j] = 'e', ​​'e' - 'a' = 5, 5 + 26 = 31, 'e' mempunyai kedudukan 31 st dalam char_set.", "code": "else if ( encoded [ i + j ] >= ' a ' && encoded [ i + j ] <= ' z ' ) num = num | ( encoded [ i + j ] - ' a ' + 26 ) ;"}
{"text": "Dikodkan [i + j] = '8', '8' - '0' = 8 8 + 52 = 60, '8' mempunyai kedudukan ke -60 dalam char_set.", "code": "else if ( encoded [ i + j ] >= '0' && encoded [ i + j ] <= '9' ) num = num | ( encoded [ i + j ] - '0' + 52 ) ;"}
{"text": "' +' berlaku dalam kedudukan 62 nd dalam char_set.", "code": "else if ( encoded [ i + j ] == ' + ' ) num = num | 62 ;"}
{"text": "' /' berlaku dalam kedudukan 63 rd dalam char_set.", "code": "else if ( encoded [ i + j ] == ' / ' ) num = num | 63 ;"}
{"text": "(str [i + j] == '=') Keluarkan 2 bit untuk memadam bit yang dilampirkan semasa pengekodan.", "code": "else { num = num >> 2 ; count_bits -= 2 ; } } while ( count_bits != 0 ) { count_bits -= 8 ;"}
{"text": "255 dalam binari ialah 11111111", "code": "decoded_string [ k ++ ] = ( num >> count_bits ) & 255 ; } } decoded_string [ k ] = ' \\0' ; return decoded_string ; }"}
{"text": "Fungsi pemacu", "code": "int main ( ) { char encoded_string [ ] = \" TUVOT04 = \" ; int len_str = sizeof ( encoded_string ) / sizeof ( encoded_string [ 0 ] ) ;"}
{"text": "Jangan mengira watak null terakhir.", "code": "len_str -= 1 ; printf ( \" Encoded ▁ string ▁ : ▁ % s STRNEWLINE \" , encoded_string ) ; printf ( \" Decoded _ string ▁ : ▁ % s STRNEWLINE \" , base64Decoder ( encoded_string , len_str ) ) ; return 0 ; }"}
{"text": "Program c untuk mencetak semua rentetan yang mengandungi semua watak perkataan", "code": "# include <stdio.h> NEW_LINE # include <stdlib.h> NEW_LINE # include <string.h> NEW_LINE # define NO_OF_CHARS  256"}
{"text": "Senarai cetakan item yang mempunyai semua watak perkataan", "code": "void print ( char * list [ ] , char * word , int list_size ) {"}
{"text": "Oleh kerana calloc digunakan, peta [] diasaskan sebagai 0", "code": "int * map = ( int * ) calloc ( sizeof ( int ) , NO_OF_CHARS ) ; int i , j , count , word_size ;"}
{"text": "Tetapkan nilai dalam peta", "code": "for ( i = 0 ; * ( word + i ) ; i ++ ) map [ * ( word + i ) ] = 1 ;"}
{"text": "Dapatkan panjang perkataan yang diberikan", "code": "word_size = strlen ( word ) ;"}
{"text": "Periksa setiap item senarai jika mempunyai semua watak perkataan", "code": "for ( i = 0 ; i < list_size ; i ++ ) { for ( j = 0 , count = 0 ; * ( list [ i ] + j ) ; j ++ ) { if ( map [ * ( list [ i ] + j ) ] ) { count ++ ;"}
{"text": "tidak tersendiri sehingga rentetan seperti SSS tidak dicetak", "code": "map [ * ( list [ i ] + j ) ] = 0 ; } } if ( count == word_size ) printf ( \" % s \" , list [ i ] ) ;"}
{"text": "Tetapkan nilai dalam peta untuk item seterusnya", "code": "for ( j = 0 ; * ( word + j ) ; j ++ ) map [ * ( word + j ) ] = 1 ; } }"}
{"text": "Program Pemandu untuk Menguji ProntDups", "code": "int main ( ) { char str [ ] = \" sun \" ; char * list [ ] = { \" geeksforgeeks \" , \" unsorted \" , \" sunday \" , \" just \" , \" sss \" } ; print ( list , str , 5 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program C untuk mencari watak pertama bukan berulang", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define NO_OF_CHARS  256"}
{"text": "Mengembalikan pelbagai saiz 256 yang mengandungi kiraan aksara dalam array char yang diluluskan", "code": "int * getCharCountArray ( char * str ) { int * count = ( int * ) calloc ( sizeof ( int ) , NO_OF_CHARS ) ; int i ; for ( i = 0 ; * ( str + i ) ; i ++ ) count [ * ( str + i ) ] ++ ; return count ; }"}
{"text": "Fungsi mengembalikan indeks watak bukan berulang pertama dalam rentetan. Sekiranya semua watak mengulangi maka kembali - 1", "code": "int firstNonRepeating ( char * str ) { int * count = getCharCountArray ( str ) ; int index = -1 , i ; for ( i = 0 ; * ( str + i ) ; i ++ ) { if ( count [ * ( str + i ) ] == 1 ) { index = i ; break ; } }"}
{"text": "Untuk mengelakkan kebocoran ingatan", "code": "free ( count ) ; return index ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char str [ ] = \" geeksforgeeks \" ; int index = firstNonRepeating ( str ) ; if ( index == -1 ) printf ( \" Either ▁ all ▁ characters ▁ are ▁ repeating ▁ or ▁ \" \" string ▁ is ▁ empty \" ) ; else printf ( \" First ▁ non - repeating ▁ character ▁ is ▁ % c \" , str [ index ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk membahagikan rentetan di bahagian yang sama", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Berfungsi untuk mencetak bahagian yang sama str striam", "code": "void divideString ( char * str , int n ) { int str_size = strlen ( str ) ; int i ; int part_size ;"}
{"text": "Periksa sama ada rentetan boleh dibahagikan kepada bahagian yang sama", "code": "if ( str_size % n != 0 ) { printf ( \" Invalid ▁ Input : ▁ String ▁ size \" ) ; printf ( \" ▁ is ▁ not ▁ divisible ▁ by ▁ n \" ) ; return ; }"}
{"text": "Kirakan saiz bahagian untuk mencari mata bahagian", "code": "part_size = str_size / n ; for ( i = 0 ; i < str_size ; i ++ ) { if ( i % part_size == 0 ) printf ( \" STRNEWLINE \" ) ; printf ( \" % c \" , str [ i ] ) ; } } int main ( ) {"}
{"text": "panjang rentetan OD ialah 28", "code": "char * str = \" a _ simple _ divide _ string _ quest \" ;"}
{"text": "Cetak 4 bahagian yang sama dari rentetan", "code": "divideString ( str , 4 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Penyelesaian berasaskan cerun untuk memeriksa sama ada tiga mata adalah collinear.", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "berfungsi untuk memeriksa sama ada titik collinear atau tidak", "code": "void collinear ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { if ( ( y3 - y2 ) * ( x2 - x1 ) == ( y2 - y1 ) * ( x3 - x2 ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int x1 = 1 , x2 = 1 , x3 = 0 , y1 = 1 , y2 = 6 , y3 = 9 ; collinear ( x1 , y1 , x2 , y2 , x3 , y3 ) ; return 0 ; }"}
{"text": "Program C untuk mencari m dan c untuk garis lurus yang diberikan, x dan y", "code": "#include <stdio.h>"}
{"text": "berfungsi untuk mengira m dan c yang paling sesuai dengan titik yang diwakili oleh x [] dan y []", "code": "void bestApproximate ( int x [ ] , int y [ ] , int n ) { int i , j ; float m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += ( x [ i ] * x [ i ] ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - ( sum_x * sum_x ) ) ; c = ( sum_y - m * sum_x ) / n ; printf ( \" m ▁ = % ▁ f \" , m ) ; printf ( \" c = % f \" , c ) ; }"}
{"text": "Fungsi utama pemandu", "code": "int main ( ) { int x [ ] = { 1 , 2 , 3 , 4 , 5 } ; int y [ ] = { 14 , 27 , 40 , 55 , 68 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; bestApproximate ( x , y , n ) ; return 0 ; }"}
{"text": "Program rekursif naif untuk mencari sisipan nombor minimum yang diperlukan untuk membuat palindrom rentetan", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; }"}
{"text": "Fungsi rekursif untuk mencari bilangan sisipan minimum", "code": "int findMinInsertions ( char str [ ] , int l , int h ) {"}
{"text": "Kes asas", "code": "if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ;"}
{"text": "Semak sama ada aksara pertama dan terakhir adalah sama. Berdasarkan hasil perbandingan, tentukan subrpoplem mana yang hendak dipanggil", "code": "return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char str [ ] = \" geeks \" ; printf ( \" % d \" , findMinInsertions ( str , 0 , strlen ( str ) - 1 ) ) ; return 0 ; }"}
{"text": "Program C untuk Morris Preorder Traversal", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Preorder traversal tanpa rekursi dan tanpa timbunan", "code": "void morrisTraversalPreorder ( struct node * root ) { while ( root ) {"}
{"text": "Jika anak kiri adalah batal, cetak data nod semasa. Pindah ke anak yang betul.", "code": "if ( root -> left == NULL ) { printf ( \" % d ▁ \" , root -> data ) ; root = root -> right ; } else {"}
{"text": "Cari Inorderororor", "code": "struct node * current = root -> left ; while ( current -> right && current -> right != root ) current = current -> right ;"}
{"text": "Sekiranya anak yang tepat dari pendahuluan inorder sudah menunjuk ke nod ini", "code": "if ( current -> right == root ) { current -> right = NULL ; root = root -> right ; }"}
{"text": "Sekiranya anak yang betul tidak menunjuk ke nod ini, maka cetak nod ini dan buatlah anak yang betul ke nod ini", "code": "else { printf ( \" % d ▁ \" , root -> data ) ; current -> right = root ; root = root -> left ; } } } }"}
{"text": "Berfungsi untuk traversal preordard silamard", "code": "void preorder ( struct node * root ) { if ( root ) { printf ( \" % d ▁ \" , root -> data ) ; preorder ( root -> left ) ; preorder ( root -> right ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct node * root = NULL ; root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 11 ) ; morrisTraversalPreorder ( root ) ; printf ( \" STRNEWLINE \" ) ; preorder ( root ) ; return 0 ; }"}
{"text": "Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala senarai dan int, memasukkan nod baru di bahagian depan senarai.", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "1 & 2: memperuntukkan nod & masukkan data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "3. Buat nod baru seterusnya sebagai kepala", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "4. Gerakkan kepala untuk menunjuk ke nod baru", "code": "( * head_ref ) = new_node ; }"}
{"text": "Memandangkan nod prev_node, masukkan nod baru selepas prev_node yang diberikan", "code": "void insertAfter ( struct Node * prev_node , int new_data ) {"}
{"text": "1. Periksa sama ada prev_node yang diberikan adalah batal", "code": "if ( prev_node == NULL ) { printf ( \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" ) ; return ; }"}
{"text": "2. Peruntukkan nod & 3. Masukkan data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "4. Buat nod baru seterusnya sebagai prev_node yang berikutnya", "code": "new_node -> next = prev_node -> next ;"}
{"text": "5. Gerakkan prev_node seterusnya sebagai new_node", "code": "prev_node -> next = new_node ; }"}
{"text": "Program c untuk mengesan gelung dalam senarai yang dipautkan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod senarai pautan", "code": "struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "memperuntukkan nod", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "masukkan data", "code": "new_node -> data = new_data ;"}
{"text": "Pautan senarai lama dari nod baru", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "Gerakkan kepala untuk menunjuk ke nod baru", "code": "( * head_ref ) = new_node ; } int detectLoop ( struct Node * list ) { struct Node * slow_p = list , * fast_p = list ; while ( slow_p && fast_p && fast_p -> next ) { slow_p = slow_p -> next ; fast_p = fast_p -> next -> next ; if ( slow_p == fast_p ) { return 1 ; } } return 0 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Mulakan dengan senarai kosong", "code": "struct Node * head = NULL ; push ( & head , 20 ) ; push ( & head , 4 ) ; push ( & head , 15 ) ; push ( & head , 10 ) ;"}
{"text": "Buat gelung untuk ujian", "code": "head -> next -> next -> next -> next = head ; if ( detectLoop ( head ) ) printf ( \" Loop ▁ found \" ) ; else printf ( \" No ▁ Loop \" ) ; return 0 ; }"}
{"text": "Program untuk memeriksa sama ada senarai yang dipautkan adalah palindrome", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod senarai pautan", "code": "struct Node { char data ; struct Node * next ; } ; void reverse ( struct Node * * ) ; bool compareLists ( struct Node * , struct Node * ) ;"}
{"text": "Berfungsi untuk memeriksa sama ada senarai yang dipautkan adalah palindrome atau tidak", "code": "bool isPalindrome ( struct Node * head ) { struct Node * slow_ptr = head , * fast_ptr = head ; struct Node * second_half , * prev_of_slow_ptr = head ;"}
{"text": "Untuk mengendalikan senarai saiz ganjil", "code": "struct Node * midnode = NULL ;"}
{"text": "memulakan hasil", "code": "bool res = true ; if ( head != NULL && head -> next != NULL ) {"}
{"text": "Dapatkan tengah senarai. Pindahkan SLOW_PTR oleh 1 dan FAST_PTRR oleh 2, SLOW_PTR akan mempunyai nod tengah", "code": "while ( fast_ptr != NULL && fast_ptr -> next != NULL ) { fast_ptr = fast_ptr -> next -> next ;"}
{"text": "Kami memerlukan sebelumnya dari SLOW_PTR untuk senarai yang dipautkan dengan elemen ganjil", "code": "prev_of_slow_ptr = slow_ptr ; slow_ptr = slow_ptr -> next ; }"}
{"text": "FAST_PTR akan menjadi batal apabila terdapat unsur -unsur dalam senarai. Dan tidak batal untuk elemen ganjil. Kita perlu melangkau nod tengah untuk kes ganjil dan menyimpannya di suatu tempat supaya kita dapat memulihkan senarai asal", "code": "if ( fast_ptr != NULL ) { midnode = slow_ptr ; slow_ptr = slow_ptr -> next ; }"}
{"text": "Sekarang terbalik separuh kedua dan bandingkan dengan separuh pertama", "code": "second_half = slow_ptr ;"}
{"text": "Null menamatkan separuh pertama", "code": "prev_of_slow_ptr -> next = NULL ;"}
{"text": "Membalikkan separuh kedua", "code": "reverse ( & second_half ) ;"}
{"text": "Bandingkan", "code": "res = compareLists ( head , second_half ) ;"}
{"text": "Membalikkan separuh kedua lagi", "code": "reverse ( & second_half ) ;"}
{"text": "Sekiranya terdapat nod pertengahan (kes saiz ganjil) yang bukan sebahagian daripada separuh pertama atau separuh kedua.", "code": "if ( midnode != NULL ) { prev_of_slow_ptr -> next = midnode ; midnode -> next = second_half ; } else prev_of_slow_ptr -> next = second_half ; } return res ; }"}
{"text": "Berfungsi untuk membalikkan senarai yang dipautkan nota bahawa fungsi ini boleh mengubah kepala", "code": "void reverse ( struct Node * * head_ref ) { struct Node * prev = NULL ; struct Node * current = * head_ref ; struct Node * next ; while ( current != NULL ) { next = current -> next ; current -> next = prev ; prev = current ; current = next ; } * head_ref = prev ; }"}
{"text": "Berfungsi untuk memeriksa sama ada dua senarai input mempunyai data yang sama", "code": "bool compareLists ( struct Node * head1 , struct Node * head2 ) { struct Node * temp1 = head1 ; struct Node * temp2 = head2 ; while ( temp1 && temp2 ) { if ( temp1 -> data == temp2 -> data ) { temp1 = temp1 -> next ; temp2 = temp2 -> next ; } else return 0 ; }"}
{"text": "Kedua -duanya adalah kosong kosong 1", "code": "if ( temp1 == NULL && temp2 == NULL ) return 1 ;"}
{"text": "Akan sampai ke sini ketika seseorang itu batal dan yang lain tidak", "code": "return 0 ; }"}
{"text": "Tolak nod ke senarai yang dipautkan. Perhatikan bahawa fungsi ini mengubah kepala", "code": "void push ( struct Node * * head_ref , char new_data ) {"}
{"text": "memperuntukkan nod", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "Pautan senarai lama dari nod baru", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "Gerakkan kepala ke Pochar ke nod baru", "code": "( * head_ref ) = new_node ; }"}
{"text": "Fungsi utiliti untuk mencetak senarai yang dipautkan", "code": "void printList ( struct Node * ptr ) { while ( ptr != NULL ) { printf ( \" % c - > \" , ptr -> data ) ; ptr = ptr -> next ; } printf ( \" NULL STRNEWLINE \" ) ; }"}
{"text": "Program kering untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Mulakan dengan senarai kosong", "code": "struct Node * head = NULL ; char str [ ] = \" abacaba \" ; int i ; for ( i = 0 ; str [ i ] != ' \\0' ; i ++ ) { push ( & head , str [ i ] ) ; printList ( head ) ; isPalindrome ( head ) ? printf ( \" Is ▁ Palindrome STRNEWLINE STRNEWLINE \" ) : printf ( \" Not ▁ Palindrome STRNEWLINE STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "Program ini menukar nod senarai yang dipautkan dan bukannya menukar medan dari nod.", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ;"}
{"text": "Berfungsi untuk menukar nod x dan y dalam senarai yang dipautkan dengan menukar pautan", "code": "void swapNodes ( struct Node * * head_ref , int x , int y ) {"}
{"text": "Tidak ada kaitan jika x dan y sama", "code": "if ( x == y ) return ;"}
{"text": "Cari X (menjejaki prevx dan currx", "code": "struct Node * prevX = NULL , * currX = * head_ref ; while ( currX && currX -> data != x ) { prevX = currX ; currX = currX -> next ; }"}
{"text": "Cari Y (menjejaki prevy dan kari", "code": "struct Node * prevY = NULL , * currY = * head_ref ; while ( currY && currY -> data != y ) { prevY = currY ; currY = currY -> next ; }"}
{"text": "Sekiranya X atau Y tidak hadir, tidak ada kaitan", "code": "if ( currX == NULL currY == NULL ) return ;"}
{"text": "Sekiranya x bukan ketua senarai yang dipautkan", "code": "if ( prevX != NULL ) prevX -> next = currY ;"}
{"text": "Lain menjadikan Y sebagai kepala baru", "code": "else * head_ref = currY ;"}
{"text": "Sekiranya y bukan ketua senarai yang dipautkan", "code": "if ( prevY != NULL ) prevY -> next = currX ;"}
{"text": "Lain menjadikan X sebagai kepala baru", "code": "else * head_ref = currX ;"}
{"text": "Tukar penunjuk seterusnya", "code": "struct Node * temp = currY -> next ; currY -> next = currX -> next ; currX -> next = temp ; }"}
{"text": "Berfungsi untuk menambah nod pada permulaan senarai", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "memperuntukkan nod dan masukkan data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "Pautan senarai lama dari nod baru", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "Gerakkan kepala untuk menunjuk ke nod baru", "code": "( * head_ref ) = new_node ; }"}
{"text": "Berfungsi untuk mencetak nod dalam senarai yang dipautkan", "code": "void printList ( struct Node * node ) { while ( node != NULL ) { printf ( \" % d ▁ \" , node -> data ) ; node = node -> next ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct Node * start = NULL ;"}
{"text": "Senarai yang dipautkan yang dibina ialah: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7", "code": "push ( & start , 7 ) ; push ( & start , 6 ) ; push ( & start , 5 ) ; push ( & start , 4 ) ; push ( & start , 3 ) ; push ( & start , 2 ) ; push ( & start , 1 ) ; printf ( \" Linked list before calling swapNodes ( ) \" printList ( start ) ; swapNodes ( & start , 4 , 3 ) ; printf ( \" Linked list after calling swapNodes ( ) \" printList ( start ) ; return 0 ; }"}
{"text": "Fungsi rekursif ke elemen swap berpasangan dari senarai yang dipautkan", "code": "void pairWiseSwap ( struct node * head ) {"}
{"text": "Mesti ada sekurang -kurangnya dua nod dalam senarai", "code": "if ( head != NULL && head -> next != NULL ) {"}
{"text": "Tukar data nod dengan data nod seterusnya", "code": "swap ( & head -> data , & head -> next -> data ) ;"}
{"text": "Hubungi PairWisesWap () untuk sisa senarai", "code": "pairWiseSwap ( head -> next -> next ) ; } }"}
{"text": "Kes 2 algo di atas", "code": "else if ( current -> data >= new_node -> data ) {"}
{"text": "Tukar bahagian data nod kepala dan nod baru dengan mengandaikan bahawa kita mempunyai swap fungsi (int *, int *)", "code": "swap ( & ( current -> data ) , & ( new_node -> data ) ) ; new_node -> next = ( * head_ref ) -> next ; ( * head_ref ) -> next = new_node ; }"}
{"text": "Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala senarai dan int, memasukkan nod baru di bahagian depan senarai.", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "1. Alokkan simpul * 2. Masukkan data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "3. Buat nod baru seterusnya sebagai kepala dan sebelumnya sebagai null", "code": "new_node -> next = ( * head_ref ) ; new_node -> prev = NULL ;"}
{"text": "4. Tukar Node kepala ke nod baru", "code": "if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ;"}
{"text": "5. Gerakkan kepala ke arah nod baru", "code": "( * head_ref ) = new_node ; }"}
{"text": "Diberikan nod sebagai prev_node, masukkan nod baru selepas nod yang diberikan", "code": "void insertAfter ( struct Node * prev_node , int new_data ) {"}
{"text": "1. Periksa sama ada prev_node yang diberikan adalah batal", "code": "if ( prev_node == NULL ) { printf ( \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" ) ; return ; }"}
{"text": "2. Alokkan nod * 3. Masukkan data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "4. Buat nod baru seterusnya sebagai prev_node yang berikutnya", "code": "new_node -> next = prev_node -> next ;"}
{"text": "5. Buat yang seterusnya dari prev_node sebagai new_node", "code": "prev_node -> next = new_node ;"}
{"text": "6. Buat prev_node seperti sebelumnya dari new_node", "code": "new_node -> prev = prev_node ;"}
{"text": "7. Tukar sebelumnya dari nod seterusnya New_node", "code": "if ( new_node -> next != NULL ) new_node -> next -> prev = new_node ; }"}
{"text": "Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala dll dan int, tambah nod baru pada akhir", "code": "void append ( struct Node * * head_ref , int new_data ) {"}
{"text": "1. Peruntukkan nod 2. Masukkan data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * last = * head_ref ; new_node -> data = new_data ;"}
{"text": "3. Nod baru ini akan menjadi nod terakhir, jadi buatlah seterusnya sebagai batal", "code": "new_node -> next = NULL ;"}
{"text": "4. Sekiranya senarai yang dipautkan kosong, maka buat nod baru sebagai kepala", "code": "if ( * head_ref == NULL ) { new_node -> prev = NULL ; * head_ref = new_node ; return ; }"}
{"text": "5. Lain melintasi sehingga nod terakhir", "code": "while ( last -> next != NULL ) last = last -> next ;"}
{"text": "6. Tukar nod terakhir yang berikutnya", "code": "last -> next = new_node ;"}
{"text": "7. Buat nod terakhir seperti sebelumnya dari nod baru", "code": "new_node -> prev = last ; return ; }"}
{"text": "Program C ke node yang menggembirakan dalam senarai dikaitkan dua kali ganda sehingga senarai itu tetap dalam urutan menaik pada percetakan dari kiri ke kanan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod senarai yang dipautkan", "code": "struct Node { struct Node * prev ; int info ; struct Node * next ; } ;"}
{"text": "Berfungsi untuk menggembirakan nod baru", "code": "void nodeInsetail ( struct Node * * head , struct Node * * tail , int key ) { struct Node * p = new Node ; p -> info = key ; p -> next = NULL ;"}
{"text": "Sekiranya nod pertama dimasukkan dalam senarai dikaitkan dua kali", "code": "if ( ( * head ) == NULL ) { ( * head ) = p ; ( * tail ) = p ; ( * head ) -> prev = NULL ; return ; }"}
{"text": "Sekiranya nod dimasukkan mempunyai nilai kurang daripada nod pertama", "code": "if ( ( p -> info ) < ( ( * head ) -> info ) ) { p -> prev = NULL ; ( * head ) -> prev = p ; p -> next = ( * head ) ; ( * head ) = p ; return ; }"}
{"text": "Sekiranya nod dimasukkan mempunyai nilai lebih daripada nod terakhir", "code": "if ( ( p -> info ) > ( ( * tail ) -> info ) ) { p -> prev = ( * tail ) ; ( * tail ) -> next = p ; ( * tail ) = p ; return ; }"}
{"text": "Cari nod yang sebelum ini kita perlu memasukkan p.", "code": "temp = ( * head ) -> next ; while ( ( temp -> info ) < ( p -> info ) ) temp = temp -> next ;"}
{"text": "Masukkan nod baru sebelum temp", "code": "( temp -> prev ) -> next = p ; p -> prev = temp -> prev ; temp -> prev = p ; p -> next = temp ; }"}
{"text": "Berfungsi untuk mencetak nod dari kiri ke kanan", "code": "void printList ( struct Node * temp ) { while ( temp != NULL ) { printf ( \" % d ▁ \" , temp -> info ) ; temp = temp -> next ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct Node * left = NULL , * right = NULL ; nodeInsetail ( & left , & right , 30 ) ; nodeInsetail ( & left , & right , 50 ) ; nodeInsetail ( & left , & right , 90 ) ; nodeInsetail ( & left , & right , 10 ) ; nodeInsetail ( & left , & right , 40 ) ; nodeInsetail ( & left , & right , 110 ) ; nodeInsetail ( & left , & right , 60 ) ; nodeInsetail ( & left , & right , 95 ) ; nodeInsetail ( & left , & right , 23 ) ; printf ( \" Doubly linked list on printing \" ▁ \" from left to right \" printList ( left ) ; return 0 ; }"}
{"text": "Nod senarai yang dipautkan", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Mencetak senarai yang dipautkan secara terbalik", "code": "void fun1 ( struct Node * head ) { if ( head == NULL ) return ; fun1 ( head -> next ) ; printf ( \" % d ▁ \" , head -> data ) ; }"}
{"text": "Cetak nod alternatif senarai yang dipautkan, pertama dari kepala ke hujung, dan kemudian dari hujung ke kepala.", "code": "void fun2 ( struct Node * start ) { if ( start == NULL ) return ; printf ( \" % d ▁ \" , start -> data ) ; if ( start -> next != NULL ) fun2 ( start -> next -> next ) ; printf ( \" % d ▁ \" , start -> data ) ; }"}
{"text": "Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala senarai dan int, tolak nod baru di hadapan senarai.", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "memperuntukkan nod", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "masukkan data", "code": "new_node -> data = new_data ;"}
{"text": "Pautan senarai lama dari nod baru", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "Gerakkan kepala untuk menunjuk ke nod baru", "code": "( * head_ref ) = new_node ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Mulakan dengan senarai kosong", "code": "struct Node * head = NULL ;"}
{"text": "Menggunakan PUSH () untuk membina di bawah Senarai 1 -> 2 -> 3 -> 4 -> 5", "code": "push ( & head , 5 ) ; push ( & head , 4 ) ; push ( & head , 3 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; printf ( \" Output ▁ of ▁ fun1 ( ) ▁ for ▁ list ▁ 1 - > 2 - > 3 - > 4 - > 5 ▁ STRNEWLINE \" ) ; fun1 ( head ) ; printf ( \" Output of fun2 ( ) for list 1 -> 2 -> 3 -> 4 -> 5 \" fun2 ( head ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mencari nod sqrt (n) 'th senarai yang dipautkan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod senarai yang dipautkan", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Berfungsi untuk mendapatkan nod sqrt (n) dari senarai yang dipautkan", "code": "int printsqrtn ( struct Node * head ) { struct Node * sqrtn = NULL ; int i = 1 , j = 1 ;"}
{"text": "Melintasi senarai", "code": "while ( head != NULL ) {"}
{"text": "Semak jika j = sqrt (i)", "code": "if ( i == j * j ) {"}
{"text": "untuk nod pertama", "code": "if ( sqrtn == NULL ) sqrtn = head ; else sqrtn = sqrtn -> next ;"}
{"text": "kenaikan j jika j = sqrt (i)", "code": "j ++ ; } i ++ ; head = head -> next ; }"}
{"text": "Data Node Kembali", "code": "return sqrtn -> data ; } void print ( struct Node * head ) { while ( head != NULL ) { printf ( \" % d ▁ \" , head -> data ) ; head = head -> next ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "berfungsi untuk menambah nod baru pada permulaan senarai", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "memperuntukkan nod", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "masukkan data", "code": "new_node -> data = new_data ;"}
{"text": "Pautan senarai lama dari nod baru", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "Gerakkan kepala untuk menunjuk ke nod baru", "code": "( * head_ref ) = new_node ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Mulakan dengan senarai kosong", "code": "struct Node * head = NULL ; push ( & head , 40 ) ; push ( & head , 30 ) ; push ( & head , 20 ) ; push ( & head , 10 ) ; printf ( \" Given ▁ linked ▁ list ▁ is : \" ) ; print ( head ) ; printf ( \" sqrt ( n ) th ▁ node ▁ is ▁ % d ▁ \" , printsqrtn ( head ) ) ; return 0 ; }"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Berikan pokok carian binari dan nombor, masukkan nod baru dengan nombor yang diberikan di tempat yang betul di dalam pokok. Mengembalikan penunjuk akar baru yang kemudiannya pemanggil harus menggunakan (helah standard untuk mengelakkan menggunakan parameter rujukan).", "code": "struct node * insert ( struct node * node , int data ) {"}
{"text": "1. Sekiranya pokok itu kosong, kembalikan nod baru", "code": "if ( node == NULL ) return ( newNode ( data ) ) ; else {"}
{"text": "2. Jika tidak, berulang pokok", "code": "if ( data <= node -> data ) node -> left = insert ( node -> left , data ) ; else node -> right = insert ( node -> right , data ) ;"}
{"text": "Kembalikan penunjuk nod (tidak berubah)", "code": "return node ; } }"}
{"text": "Memandangkan pokok carian binari yang tidak kosong, kembalikan nilai data minimum yang terdapat di dalam pokok itu. Perhatikan bahawa seluruh pokok tidak perlu dicari.", "code": "int minValue ( struct node * node ) { struct node * current = node ;"}
{"text": "gelung ke bawah untuk mencari daun paling kiri", "code": "while ( current -> left != NULL ) { current = current -> left ; } return ( current -> data ) ; }"}
{"text": "Program pemacu untuk menguji fungsi sametree", "code": "int main ( ) { struct node * root = NULL ; root = insert ( root , 4 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 6 ) ; insert ( root , 5 ) ; printf ( \" Minimum value in BST is % d \" , minValue ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "program untuk membina pokok menggunakan traversals inorder dan preorder", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { char data ; struct node * left ; struct node * right ; } ;"}
{"text": "Prototaip untuk fungsi utiliti", "code": "int search ( char arr [ ] , int strt , int end , char value ) ; struct node * newNode ( char data ) ;"}
{"text": "Fungsi rekursif untuk membina binari saiz len dari inorder traversal dalam [] dan preorder traversal pre []. Nilai awal instruk dan inend mestilah 0 dan len - 1. Fungsi tidak melakukan apa -apa ralat memeriksa kes di mana inorder dan preorder tidak membentuk pokok", "code": "struct node * buildTree ( char in [ ] , char pre [ ] , int inStrt , int inEnd ) { static int preIndex = 0 ; if ( inStrt > inEnd ) return NULL ;"}
{"text": "Pilih nod semasa dari preorder traversal menggunakan preindex dan preindex kenaikan", "code": "struct node * tNode = newNode ( pre [ preIndex ++ ] ) ;"}
{"text": "Sekiranya nod ini tidak mempunyai anak, maka kembali", "code": "if ( inStrt == inEnd ) return tNode ;"}
{"text": "Lain cari indeks nod ini dalam traversal inorder", "code": "int inIndex = search ( in , inStrt , inEnd , tNode -> data ) ;"}
{"text": "Menggunakan Indeks dalam Inorder Traversal, Bina Subtrek Kiri dan Kanan", "code": "tNode -> left = buildTree ( in , pre , inStrt , inIndex - 1 ) ; tNode -> right = buildTree ( in , pre , inIndex + 1 , inEnd ) ; return tNode ; }"}
{"text": "Fungsi untuk mencari indeks nilai dalam arr [mula ... akhir] Fungsi mengandaikan bahawa nilai ada di dalam []", "code": "int search ( char arr [ ] , int strt , int end , char value ) { int i ; for ( i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) return i ; } }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( char data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Funtcion ini ada di sini hanya untuk menguji BuildTree ()", "code": "void printInorder ( struct node * node ) { if ( node == NULL ) return ;"}
{"text": "Pertama berulang pada anak kiri", "code": "printInorder ( node -> left ) ;"}
{"text": "kemudian cetak data nod", "code": "printf ( \" % c ▁ \" , node -> data ) ;"}
{"text": "sekarang berulang pada anak yang betul", "code": "printInorder ( node -> right ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char in [ ] = { ' D ' , ' B ' , ' E ' , ' A ' , ' F ' , ' C ' } ; char pre [ ] = { ' A ' , ' B ' , ' D ' , ' E ' , ' C ' , ' F ' } ; int len = sizeof ( in ) / sizeof ( in [ 0 ] ) ; struct node * root = buildTree ( in , pre , 0 , len - 1 ) ;"}
{"text": "Mari kita uji pokok yang dibina dengan mencetak Traversal Insorder", "code": "printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ constructed ▁ tree ▁ is ▁ STRNEWLINE \" ) ; printInorder ( root ) ; getchar ( ) ; }"}
{"text": "Program C Rekursif untuk mencari LCA dua nod N1 dan N2.", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Fungsi untuk mencari LCA N1 dan N2. Fungsi ini mengandaikan bahawa kedua -dua N1 dan N2 hadir di BST", "code": "struct node * lca ( struct node * root , int n1 , int n2 ) { while ( root != NULL ) {"}
{"text": "Jika kedua -dua N1 dan N2 lebih kecil daripada akar, maka LCA terletak di sebelah kiri", "code": "if ( root -> data > n1 && root -> data > n2 ) root = root -> left ;"}
{"text": "Jika kedua -dua N1 dan N2 lebih besar daripada akar, maka LCA terletak di sebelah kanan", "code": "else if ( root -> data < n1 && root -> data < n2 ) root = root -> right ; else break ; } return root ; }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; }"}
{"text": "Program Pemandu untuk Menguji LCA ()", "code": "int main ( ) {"}
{"text": "Mari kita buat BST yang ditunjukkan dalam angka di atas", "code": "struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 22 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; int n1 = 10 , n2 = 14 ; struct node * t = lca ( root , n1 , n2 ) ; printf ( \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , n1 , n2 , t -> data ) ; n1 = 14 , n2 = 8 ; t = lca ( root , n1 , n2 ) ; printf ( \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , n1 , n2 , t -> data ) ; n1 = 10 , n2 = 22 ; t = lca ( root , n1 , n2 ) ; printf ( \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , n1 , n2 , t -> data ) ; getchar ( ) ; return 0 ; }"}
{"text": "palsu jika ditinggalkan adalah> daripada nod", "code": "if ( node -> left != NULL && node -> left -> data > node -> data ) return 0 ;"}
{"text": "palsu jika betul adalah <daripada nod", "code": "if ( node -> right != NULL && node -> right -> data < node -> data ) return 0 ;"}
{"text": "palsu jika, secara rekursif, kiri atau kanan bukan BST", "code": "if ( ! isBST ( node -> left ) || ! isBST ( node -> right ) ) return 0 ;"}
{"text": "melewati semua itu, ia adalah bst", "code": "return 1 ; }"}
{"text": "Pulangan benar jika pokok binari adalah pokok carian binari", "code": "int isBST ( struct node * node ) { if ( node == NULL ) return 1 ;"}
{"text": "palsu jika max di sebelah kiri adalah> daripada kita", "code": "if ( node -> left != NULL && maxValue ( node -> left ) > node -> data ) return 0 ;"}
{"text": "palsu jika min dari kanan adalah <= daripada kita", "code": "if ( node -> right != NULL && minValue ( node -> right ) < node -> data ) return 0 ;"}
{"text": "palsu jika, secara rekursif, kiri atau kanan bukan BST", "code": "if ( ! isBST ( node -> left ) || ! isBST ( node -> right ) ) return 0 ;"}
{"text": "melewati semua itu, ia adalah bst", "code": "return 1 ; }"}
{"text": "Periksa sama ada setiap nod dalaman BST mempunyai hanya satu anak", "code": "#include <stdio.h> NEW_LINE bool hasOnlyOneChild ( int pre [ ] , int size ) { int nextDiff , lastDiff ; for ( int i = 0 ; i < size - 1 ; i ++ ) { nextDiff = pre [ i ] - pre [ i + 1 ] ; lastDiff = pre [ i ] - pre [ size - 1 ] ; if ( nextDiff * lastDiff < 0 ) return false ; ; } return true ; }"}
{"text": "program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int pre [ ] = { 8 , 3 , 5 , 7 , 6 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; if ( hasOnlyOneChild ( pre , size ) == true ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Periksa sama ada setiap nod dalaman BST mempunyai hanya satu anak", "code": "#include <stdio.h> NEW_LINE int hasOnlyOneChild ( int pre [ ] , int size ) {"}
{"text": "Memulakan min dan max menggunakan dua elemen terakhir", "code": "int min , max ; if ( pre [ size - 1 ] > pre [ size - 2 ] ) { max = pre [ size - 1 ] ; min = pre [ size - 2 ] ) : else { max = pre [ size - 2 ] ; min = pre [ size - 1 ] ; }"}
{"text": "Setiap elemen mestilah lebih kecil daripada min atau lebih besar daripada maksimum", "code": "for ( int i = size - 3 ; i >= 0 ; i -- ) { if ( pre [ i ] < min ) min = pre [ i ] ; else if ( pre [ i ] > max ) max = pre [ i ] ; else return false ; } return true ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int pre [ ] = { 8 , 3 , 5 , 7 , 6 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; if ( hasOnlyOneChild ( pre , size ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "C ++ Program Pokok AVL yang mengendalikan pendua", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok avl", "code": "struct node { int key ; struct node * left ; struct node * right ; int height ; int count ; } ;"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) ;"}
{"text": "Fungsi utiliti untuk mendapatkan ketinggian pokok", "code": "int height ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> height ; }"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Fungsi pembantu yang memperuntukkan nod baru dengan kunci yang diberikan dan null kiri dan kanan.", "code": "struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ;"}
{"text": "nod baru pada mulanya ditambah pada daun", "code": "node -> height = 1 ; node -> count = 1 ; return ( node ) ; }"}
{"text": "Fungsi utiliti ke kanan berputar subtree yang berakar dengan y lihat rajah yang diberikan di atas.", "code": "struct node * rightRotate ( struct node * y ) { struct node * x = y -> left ; struct node * T2 = x -> right ;"}
{"text": "Melakukan putaran", "code": "x -> right = y ; y -> left = T2 ;"}
{"text": "Kemas kini ketinggian", "code": "y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ;"}
{"text": "Kembalikan akar baru", "code": "return x ; }"}
{"text": "Fungsi utiliti ke kiri berputar subtree yang berakar dengan x lihat rajah yang diberikan di atas.", "code": "struct node * leftRotate ( struct node * x ) { struct node * y = x -> right ; struct node * T2 = y -> left ;"}
{"text": "Melakukan putaran", "code": "y -> left = x ; x -> right = T2 ;"}
{"text": "Kemas kini ketinggian", "code": "x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ;"}
{"text": "Kembalikan akar baru", "code": "return y ; }"}
{"text": "Dapatkan faktor keseimbangan nod n", "code": "int getBalance ( struct node * N ) { if ( N == NULL ) return 0 ; return height ( N -> left ) - height ( N -> right ) ; } struct node * insert ( struct node * node , int key ) {"}
{"text": "1. Lakukan putaran BST biasa", "code": "if ( node == NULL ) return ( newNode ( key ) ) ;"}
{"text": "Sekiranya kunci sudah ada di BST, kiraan kenaikan dan pulangan", "code": "if ( key == node -> key ) { ( node -> count ) ++ ; return node ; }"}
{"text": "Jika tidak, mengulangi pokok itu", "code": "if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ;"}
{"text": "2. Kemas kini ketinggian nod nenek moyang ini", "code": "node -> height = max ( height ( node -> left ) , height ( node -> right ) ) + 1 ;"}
{"text": "3. Dapatkan faktor keseimbangan nod nenek moyang ini untuk memeriksa sama ada nod ini menjadi tidak seimbang", "code": "int balance = getBalance ( node ) ;"}
{"text": "Sekiranya nod ini menjadi tidak seimbang, maka terdapat 4 kes kiri kes kiri", "code": "if ( balance > 1 && key < node -> left -> key ) return rightRotate ( node ) ;"}
{"text": "Kes yang betul", "code": "if ( balance < -1 && key > node -> right -> key ) return leftRotate ( node ) ;"}
{"text": "Kes Kiri Kiri", "code": "if ( balance > 1 && key > node -> left -> key ) { node -> left = leftRotate ( node -> left ) ; return rightRotate ( node ) ; }"}
{"text": "Kes kiri kanan", "code": "if ( balance < -1 && key < node -> right -> key ) { node -> right = rightRotate ( node -> right ) ; return leftRotate ( node ) ; }"}
{"text": "Kembalikan penunjuk nod (tidak berubah)", "code": "return node ; }"}
{"text": "Memandangkan pokok carian binari yang tidak kosong, kembalikan nod dengan nilai kunci minimum yang terdapat di dalam pokok itu. Perhatikan bahawa seluruh pokok tidak perlu dicari.", "code": "struct node * minValueNode ( struct node * node ) { struct node * current = node ;"}
{"text": "gelung ke bawah untuk mencari daun paling kiri", "code": "while ( current -> left != NULL ) current = current -> left ; return current ; } struct node * deleteNode ( struct node * root , int key ) {"}
{"text": "Langkah 1: Lakukan Padam BST Standard", "code": "if ( root == NULL ) return root ;"}
{"text": "Sekiranya kunci yang akan dipadam lebih kecil daripada kunci akar, maka ia terletak di subtree kiri", "code": "if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ;"}
{"text": "Sekiranya kunci untuk dipadam lebih besar daripada kunci akar, maka ia terletak pada subtree yang betul", "code": "else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ;"}
{"text": "Sekiranya kunci sama dengan kunci root, maka ini adalah nod yang akan dipadam", "code": "else {"}
{"text": "Sekiranya kunci hadir lebih dari sekali, hanya pengurangan dan pulangan", "code": "if ( root -> count > 1 ) { ( root -> count ) -- ; return ; }"}
{"text": "Lain, padamkan nod nod dengan hanya satu kanak -kanak atau tiada anak", "code": "if ( ( root -> left == NULL ) || ( root -> right == NULL ) ) { struct node * temp = root -> left ? root -> left : root -> right ;"}
{"text": "Tiada kes kanak -kanak", "code": "if ( temp == NULL ) { temp = root ; root = NULL ; }"}
{"text": "Satu kes kanak -kanak", "code": "else"}
{"text": "Salin kandungan anak yang tidak kosong", "code": "* root = * temp ; free ( temp ) ; } else {"}
{"text": "Node dengan Dua Kanak -kanak: Dapatkan Pengganti Inorder (Terkecil di Subtree Kanan)", "code": "struct node * temp = minValueNode ( root -> right ) ;"}
{"text": "Salin data pengganti Inorder ke nod ini dan kemas kini kiraan", "code": "root -> key = temp -> key ; root -> count = temp -> count ; temp -> count = 1 ;"}
{"text": "Padamkan pengganti inorder", "code": "root -> right = deleteNode ( root -> right , temp -> key ) ; } }"}
{"text": "Sekiranya pokok itu hanya mempunyai satu nod maka kembali", "code": "if ( root == NULL ) return root ;"}
{"text": "Langkah 2: Kemas kini ketinggian nod semasa", "code": "root -> height = max ( height ( root -> left ) , height ( root -> right ) ) + 1 ;"}
{"text": "Langkah 3: Dapatkan faktor keseimbangan nod ini (untuk memeriksa sama ada nod ini menjadi tidak seimbang)", "code": "int balance = getBalance ( root ) ;"}
{"text": "Sekiranya nod ini menjadi tidak seimbang, maka terdapat 4 kes kiri kes kiri", "code": "if ( balance > 1 && getBalance ( root -> left ) >= 0 ) return rightRotate ( root ) ;"}
{"text": "Kes Kiri Kiri", "code": "if ( balance > 1 && getBalance ( root -> left ) < 0 ) { root -> left = leftRotate ( root -> left ) ; return rightRotate ( root ) ; }"}
{"text": "Kes yang betul", "code": "if ( balance < -1 && getBalance ( root -> right ) <= 0 ) return leftRotate ( root ) ;"}
{"text": "Kes kiri kanan", "code": "if ( balance < -1 && getBalance ( root -> right ) > 0 ) { root -> right = rightRotate ( root -> right ) ; return leftRotate ( root ) ; } return root ; }"}
{"text": "Fungsi utiliti untuk mencetak preorder traversal pokok. Fungsi ini juga mencetak ketinggian setiap nod", "code": "void preOrder ( struct node * root ) { if ( root != NULL ) { printf ( \" % d ( % d ) ▁ \" , root -> key , root -> count ) ; preOrder ( root -> left ) ; preOrder ( root -> right ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct node * root = NULL ;"}
{"text": "Membina pokok yang diberikan dalam angka di atas", "code": "root = insert ( root , 9 ) ; root = insert ( root , 5 ) ; root = insert ( root , 10 ) ; root = insert ( root , 5 ) ; root = insert ( root , 9 ) ; root = insert ( root , 7 ) ; root = insert ( root , 17 ) ; printf ( \" Pre ▁ order ▁ traversal ▁ of ▁ the ▁ constructed ▁ AVL ▁ tree ▁ is ▁ STRNEWLINE \" ) ; preOrder ( root ) ; root = deleteNode ( root , 9 ) ; printf ( \" Pre order traversal after deletion of 9 \" preOrder ( root ) ; return 0 ; }"}
{"text": "Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; struct node * parent ; } ; struct node * minValue ( struct node * node ) ;"}
{"text": "Berikan pokok carian binari dan nombor, masukkan nod baru dengan nombor yang diberikan di tempat yang betul di dalam pokok. Mengembalikan penunjuk akar baru yang kemudiannya pemanggil harus menggunakan (helah standard untuk mengelakkan menggunakan parameter rujukan).", "code": "struct node * insert ( struct node * node , int data ) {"}
{"text": "1. Sekiranya pokok itu kosong, kembalikan nod baru", "code": "if ( node == NULL ) return ( newNode ( data ) ) ; else { struct node * temp ;"}
{"text": "2. Jika tidak, berulang pokok", "code": "if ( data <= node -> data ) { temp = insert ( node -> left , data ) ; node -> left = temp ; temp -> parent = node ; } else { temp = insert ( node -> right , data ) ; node -> right = temp ; temp -> parent = node ; }"}
{"text": "Kembalikan penunjuk nod (tidak berubah)", "code": "return node ; } } struct node * inOrderSuccessor ( struct node * root , struct node * n ) {"}
{"text": "Langkah 1 dari algoritma di atas", "code": "if ( n -> right != NULL ) return minValue ( n -> right ) ;"}
{"text": "Langkah 2 algoritma di atas", "code": "struct node * p = n -> parent ; while ( p != NULL && n == p -> right ) { n = p ; p = p -> parent ; } return p ; }"}
{"text": "Memandangkan pokok carian binari yang tidak kosong, kembalikan nilai data minimum yang terdapat di dalam pokok itu. Perhatikan bahawa seluruh pokok tidak perlu dicari.", "code": "struct node * minValue ( struct node * node ) { struct node * current = node ;"}
{"text": "gelung ke bawah untuk mencari daun paling kiri", "code": "while ( current -> left != NULL ) { current = current -> left ; } return current ; }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> parent = NULL ; return ( node ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct node * root = NULL , * temp , * succ , * min ; root = insert ( root , 20 ) ; root = insert ( root , 8 ) ; root = insert ( root , 22 ) ; root = insert ( root , 4 ) ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 14 ) ; temp = root -> left -> right -> right ; succ = inOrderSuccessor ( root , temp ) ; if ( succ != NULL ) printf ( \" Inorder Successor of % d is % d \" , temp -> data , succ -> data ) ; else printf ( \" Inorder Successor doesn ' exit \" getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk memeriksa sama ada terdapat triplet dengan jumlah yang sama dengan 0 dalam BST yang diberikan", "code": "#include <stdio.h>"}
{"text": "Nod BST mempunyai kunci, dan petunjuk kiri dan kanan", "code": "struct node { int key ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi untuk menukar BST diberikan kepada senarai dikaitkan dua kali ganda. Penunjuk kiri digunakan sebagai penunjuk sebelumnya dan penunjuk kanan digunakan sebagai penunjuk seterusnya. Fungsi menetapkan * kepala ke arah pertama dan * ekor ke arah nod terakhir DLL yang ditukar", "code": "void convertBSTtoDLL ( node * root , node * * head , node * * tail ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return ;"}
{"text": "Mula -mula menukar subtree kiri", "code": "if ( root -> left ) convertBSTtoDLL ( root -> left , head , tail ) ;"}
{"text": "Kemudian ubah kiri akar semasa sebagai nod terakhir subtree kiri", "code": "root -> left = * tail ;"}
{"text": "Sekiranya ekor tidak batal, maka tetapkan kanan ekor sebagai akar, nod semasa lain adalah kepala", "code": "if ( * tail ) ( * tail ) -> right = root ; else * head = root ;"}
{"text": "Kemas kini ekor", "code": "* tail = root ;"}
{"text": "Akhirnya, tukar subtree kanan", "code": "if ( root -> right ) convertBSTtoDLL ( root -> right , head , tail ) ; }"}
{"text": "Fungsi ini kembali benar jika terdapat pasangan dalam DLL dengan jumlah yang sama dengan jumlah yang diberikan. Algoritma ini serupa dengan HasArrayTWocandIdates () TinyUrl. com / dy6palr dalam kaedah 1 http:", "code": "bool isPresentInDLL ( node * head , node * tail , int sum ) { while ( head != tail ) { int curr = head -> key + tail -> key ; if ( curr == sum ) return true ; else if ( curr > sum ) tail = tail -> left ; else head = head -> right ; } return false ; }"}
{"text": "Fungsi utama yang kembali benar jika terdapat triplet 0 jumlah di BST sebaliknya mengembalikan palsu", "code": "bool isTripletPresent ( node * root ) {"}
{"text": "Periksa sama ada BST yang diberikan kosong", "code": "if ( root == NULL ) return false ;"}
{"text": "Tukar diberikan BST ke senarai dikaitkan dua kali ganda. kepala dan ekor menyimpan petunjuk ke nod pertama dan terakhir di DLLL", "code": "node * head = NULL ; node * tail = NULL ; convertBSTtoDLL ( root , & head , & tail ) ;"}
{"text": "Sekarang berulang melalui setiap nod dan cari jika ada pasangan dengan jumlah sama dengan - 1 * heaf -> kekunci di mana kepala adalah nod semasa", "code": "while ( ( head -> right != tail ) && ( head -> key < 0 ) ) {"}
{"text": "Sekiranya ada sepasang dengan jumlah yang sama dengan - 1 * kepala -> kunci, maka kembali lagi, bergerak ke hadapan", "code": "if ( isPresentInDLL ( head -> right , tail , -1 * head -> key ) ) return true ; else head = head -> right ; }"}
{"text": "Sekiranya kita sampai di sini, maka tidak ada triplet 0 jumlah", "code": "return false ; }"}
{"text": "Fungsi utiliti untuk membuat nod BST baru dengan kunci seperti yang diberikan NUM", "code": "node * newNode ( int num ) { node * temp = new node ; temp -> key = num ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Fungsi utiliti untuk memasukkan kunci yang diberikan kepada BST", "code": "node * insert ( node * root , int key ) { if ( root == NULL ) return newNode ( key ) ; if ( root -> key > key ) root -> left = insert ( root -> left , key ) ; else root -> right = insert ( root -> right , key ) ; return root ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { node * root = NULL ; root = insert ( root , 6 ) ; root = insert ( root , -13 ) ; root = insert ( root , 14 ) ; root = insert ( root , -8 ) ; root = insert ( root , 15 ) ; root = insert ( root , 13 ) ; root = insert ( root , 7 ) ; if ( isTripletPresent ( root ) ) printf ( \" Present \" ) ; else printf ( \" Not ▁ Present \" ) ; return 0 ; }"}
{"text": "Dalam pokok carian binari yang seimbang ispairpresent dua elemen yang merangkumi masa nilai tertentu o (n) ruang o (logn)", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define MAX_SIZE  100"}
{"text": "Nod BST", "code": "struct node { int val ; struct node * left , * right ; } ;"}
{"text": "Jenis Stack", "code": "struct Stack { int size ; int top ; struct node * * array ; } ;"}
{"text": "Fungsi utiliti untuk membuat timbunan saiz yang diberikan", "code": "struct Stack * createStack ( int size ) { struct Stack * stack = ( struct Stack * ) malloc ( sizeof ( struct Stack ) ) ; stack -> size = size ; stack -> top = -1 ; stack -> array = ( struct node * * ) malloc ( stack -> size * sizeof ( struct node * ) ) ; return stack ; }"}
{"text": "Operasi asas timbunan", "code": "int isFull ( struct Stack * stack ) { return stack -> top - 1 == stack -> size ; } int isEmpty ( struct Stack * stack ) { return stack -> top == -1 ; } void push ( struct Stack * stack , struct node * node ) { if ( isFull ( stack ) ) return ; stack -> array [ ++ stack -> top ] = node ; } struct node * pop ( struct Stack * stack ) { if ( isEmpty ( stack ) ) return NULL ; return stack -> array [ stack -> top -- ] ; }"}
{"text": "Pulangan benar jika pasangan dengan jumlah sasaran wujud di BST, jika tidak palsu", "code": "bool isPairPresent ( struct node * root , int target ) {"}
{"text": "Buat dua susunan. S1 digunakan untuk traversal inorder biasa dan S2 digunakan untuk traversal inorder terbalik", "code": "struct Stack * s1 = createStack ( MAX_SIZE ) ; struct Stack * s2 = createStack ( MAX_SIZE ) ;"}
{"text": "Perhatikan saiz susunan adalah max_size, kita dapat mencari saiz pokok dan menetapkan saiz timbunan sebagai o (logn) untuk pokok seimbang seperti AVL dan pokok hitam merah. Kami telah menggunakan max_size untuk memastikan kod mudah dilakukan1, val1 dan curr1 digunakan untuk traversal inorder biasa menggunakan S1 DONSE2, VAL2 dan CURR2 digunakan untuk traversal inorder terbalik menggunakan S2", "code": "bool done1 = false , done2 = false ; int val1 = 0 , val2 = 0 ; struct node * curr1 = root , * curr2 = root ;"}
{"text": "Gelung akan pecah ketika kita mencari pasangan atau salah satu daripada dua traversals selesai", "code": "while ( 1 ) {"}
{"text": "Cari nod seterusnya dalam traversal inorder biasa. Lihat Posting berikut www. Geeksforgeeks. org / inorder - pokok - traversal - tanpa - rekursi / https:", "code": "while ( done1 == false ) { if ( curr1 != NULL ) { push ( s1 , curr1 ) ; curr1 = curr1 -> left ; } else { if ( isEmpty ( s1 ) ) done1 = 1 ; else { curr1 = pop ( s1 ) ; val1 = curr1 -> val ; curr1 = curr1 -> right ; done1 = 1 ; } } }"}
{"text": "Cari nod seterusnya dalam traversal inorder terbalik. Satu -satunya perbezaan antara gelung di atas dan di bawah adalah, di bawah bawah gelung kanan subtree dilalui sebelum kiri subtree", "code": "while ( done2 == false ) { if ( curr2 != NULL ) { push ( s2 , curr2 ) ; curr2 = curr2 -> right ; } else { if ( isEmpty ( s2 ) ) done2 = 1 ; else { curr2 = pop ( s2 ) ; val2 = curr2 -> val ; curr2 = curr2 -> left ; done2 = 1 ; } } }"}
{"text": "Jika kita mencari pasangan, kemudian cetak pasangan dan kembali. Keadaan pertama memastikan bahawa dua nilai yang sama tidak ditambah", "code": "if ( ( val1 != val2 ) && ( val1 + val2 ) == target ) { printf ( \" Pair Found : % d + % d = % d \" , val1 , val2 , target ) ; return true ; }"}
{"text": "Sekiranya jumlah nilai semasa lebih kecil, maka bergerak ke nod seterusnya dalam traversal inorder biasa", "code": "else if ( ( val1 + val2 ) < target ) done1 = false ;"}
{"text": "Sekiranya jumlah nilai semasa lebih besar, maka bergerak ke nod seterusnya dalam traversal terbalik", "code": "else if ( ( val1 + val2 ) > target ) done2 = false ;"}
{"text": "Sekiranya mana -mana traversals inorder berakhir, maka tidak ada pasangan sehingga kembali palsu", "code": "if ( val1 >= val2 ) return false ; } }"}
{"text": "Fungsi utiliti untuk membuat nod BST", "code": "struct node * NewNode ( int val ) { struct node * tmp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; tmp -> val = val ; tmp -> right = tmp -> left = NULL ; return tmp ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "15 / \\ 10 20 / \\ / \\ 8 12 16 25", "code": "struct node * root = NewNode ( 15 ) ; root -> left = NewNode ( 10 ) ; root -> right = NewNode ( 20 ) ; root -> left -> left = NewNode ( 8 ) ; root -> left -> right = NewNode ( 12 ) ; root -> right -> left = NewNode ( 16 ) ; root -> right -> right = NewNode ( 25 ) ; int target = 33 ; if ( isPairPresent ( root , target ) == false ) printf ( \" No such values are found \" getchar ( ) ; return 0 ; }"}
{"text": "Program C untuk melaksanakan operasi sisipan dalam pokok hitam merah.", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE typedef struct node { struct node * left , * right ; int data ;"}
{"text": "merah ==> benar, hitam ==> palsu", "code": "bool color ; } node ; node * createNode ( int data , bool color ) { node * myNode = ( node * ) malloc ( sizeof ( node ) ) ; myNode -> left = myNode -> right = NULL ; myNode -> data = data ;"}
{"text": "Nod baru yang dicipta sentiasa berwarna merah.", "code": "myNode -> color = true ; return myNode ; }"}
{"text": "Fungsi utiliti untuk memutar nod anti -lawan jam.", "code": "node * rotateLeft ( node * myNode ) { printf ( \" left ▁ rotation ! ! STRNEWLINE \" ) ; node * child = myNode -> right ; node * childLeft = child -> left ; child -> left = myNode ; myNode -> right = childLeft ; return child ; }"}
{"text": "fungsi utiliti untuk memutar nod mengikut arah jam.", "code": "node * rotateRight ( node * myNode ) { printf ( \" right ▁ rotation STRNEWLINE \" ) ; node * child = myNode -> left ; node * childRight = child -> right ; child -> right = myNode ; myNode -> left = childRight ; return child ; }"}
{"text": "Fungsi utiliti untuk memeriksa sama ada nod berwarna merah atau tidak.", "code": "int isRed ( node * myNode ) { if ( myNode == NULL ) return 0 ; return ( myNode -> color == true ) ; }"}
{"text": "Fungsi utiliti untuk menukar warna dua nod.", "code": "void swapColors ( node * node1 , node * node2 ) { bool temp = node1 -> color ; node1 -> color = node2 -> color ; node2 -> color = temp ; }"}
{"text": "Sisipan ke dalam pokok hitam merah yang bersandar kiri.", "code": "node * insert ( node * myNode , int data ) {"}
{"text": "Kod penyisipan biasa untuk mana -mana pokok carian binari.", "code": "if ( myNode == NULL ) return createNode ( data , false ) ; if ( data < myNode -> data ) myNode -> left = insert ( myNode -> left , data ) ; else if ( data > myNode -> data ) myNode -> right = insert ( myNode -> right , data ) ; else return myNode ;"}
{"text": "Kes 1. Apabila anak yang betul merah tetapi anak kiri adalah hitam atau tidak ada.", "code": "if ( isRed ( myNode -> right ) && ! isRed ( myNode -> left ) ) {"}
{"text": "Kiri berputar nod untuk menjadikannya struktur yang sah.", "code": "myNode = rotateLeft ( myNode ) ;"}
{"text": "Tukar warna kerana nod kanak -kanak harus selalu merah", "code": "swapColors ( myNode , myNode -> left ) ; }"}
{"text": "kes 2 ketika anak kiri dan juga anak besar yang merah dalam warna merah", "code": "if ( isRed ( myNode -> left ) && isRed ( myNode -> left -> left ) ) {"}
{"text": "Putar kanan nod semasa untuk menjadikannya struktur yang sah.", "code": "myNode = rotateRight ( myNode ) ; swapColors ( myNode , myNode -> right ) ; }"}
{"text": "Kes 3 Apabila kedua -dua anak kiri dan kanan berwarna merah.", "code": "if ( isRed ( myNode -> left ) && isRed ( myNode -> right ) ) {"}
{"text": "Balikkan warna nod serta anak kiri dan kanan.", "code": "myNode -> color = ! myNode -> color ;"}
{"text": "Tukar warna menjadi hitam.", "code": "myNode -> left -> color = false ; myNode -> right -> color = false ; } return myNode ; }"}
{"text": "Inorder traversal", "code": "void inorder ( node * node ) { if ( node ) { inorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; inorder ( node -> right ) ; } }"}
{"text": "Fungsi pemacu", "code": "int main ( ) { node * root = NULL ;"}
{"text": "LLRB Tree dibuat selepas semua penyisipan dibuat. 1. Nod yang mempunyai kelebihan masuk dua kali ganda bermakna warna merah. 2. Nod yang mempunyai kelebihan masuk tunggal bermakna bahawa mereka berwarna hitam. akar | 40 \\ 20 50 / \\ 10 30 25 25", "code": "root = insert ( root , 10 ) ;"}
{"text": "untuk memastikan bahawa akar kekal hitam berwarna", "code": "root -> color = false ; root = insert ( root , 20 ) ; root -> color = false ; root = insert ( root , 30 ) ; root -> color = false ; root = insert ( root , 40 ) ; root -> color = false ; root = insert ( root , 50 ) ; root -> color = false ; root = insert ( root , 25 ) ; root -> color = false ;"}
{"text": "Paparkan pokok melalui traversal inorder.", "code": "inorder ( root ) ; return 0 ; }"}
{"text": "Fungsi utiliti untuk mencari nod paling kiri di pokok yang berakar dengan n", "code": "struct Node * leftMost ( struct Node * n ) { if ( n == NULL ) return NULL ; while ( n -> left != NULL ) n = n -> left ; return n ; }"}
{"text": "Code code untuk melakukan inorder traversal di pokok binari berulir", "code": "void inOrder ( struct Node * root ) { struct Node * cur = leftMost ( root ) ; while ( cur != NULL ) { printf ( \" % d ▁ \" , cur -> data ) ;"}
{"text": "Sekiranya nod ini adalah nod benang, maka pergi ke pengganti inorder", "code": "if ( cur -> rightThread ) cur = cur -> right ;"}
{"text": "Lain pergi ke anak paling kiri di sebelah kanan", "code": "else"}
{"text": "subtree", "code": "cur = leftmost ( cur -> right ) ; } }"}
{"text": "program untuk pembinaan pokok binari penuh", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi utiliti untuk membuat nod", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Fungsi rekursif untuk membina penuh dari pra [] dan pos []. PreIndex digunakan untuk menjejaki indeks dalam pra []. L adalah indeks rendah dan h adalah indeks tinggi untuk subarray semasa dalam pos []", "code": "struct node * constructTreeUtil ( int pre [ ] , int post [ ] , int * preIndex , int l , int h , int size ) {"}
{"text": "Kes asas", "code": "if ( * preIndex >= size l > h ) return NULL ;"}
{"text": "Nod pertama dalam preorder traversal adalah akar. Oleh itu, ambil nod pada preindex dari preorder dan menjadikannya akar, dan preindex kenaikan", "code": "struct node * root = newNode ( pre [ * preIndex ] ) ; ++ * preIndex ;"}
{"text": "Sekiranya subarry semasa hanya mempunyai satu elemen, tidak perlu berulang", "code": "if ( l == h ) return root ;"}
{"text": "Cari elemen seterusnya pra [] dalam pos []", "code": "int i ; for ( i = l ; i <= h ; ++ i ) if ( pre [ * preIndex ] == post [ i ] ) break ;"}
{"text": "Gunakan indeks elemen yang terdapat dalam postorder untuk membahagikan array postorder dalam dua bahagian. Subtree kiri dan kanan", "code": "if ( i <= h ) { root -> left = constructTreeUtil ( pre , post , preIndex , l , i , size ) ; root -> right = constructTreeUtil ( pre , post , preIndex , i + 1 , h , size ) ; } return root ; }"}
{"text": "Fungsi utama untuk membina pokok binari penuh dari preorder dan postorder yang diberikan. Fungsi ini terutamanya menggunakan ConstructTreeUtil ()", "code": "struct node * constructTree ( int pre [ ] , int post [ ] , int size ) { int preIndex = 0 ; return constructTreeUtil ( pre , post , & preIndex , 0 , size - 1 , size ) ; }"}
{"text": "Fungsi utiliti untuk mencetak inorder traversal pokok binari", "code": "void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; printInorder ( node -> right ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int pre [ ] = { 1 , 2 , 4 , 8 , 9 , 5 , 3 , 6 , 7 } ; int post [ ] = { 8 , 9 , 4 , 5 , 2 , 6 , 7 , 3 , 1 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; struct node * root = constructTree ( pre , post , size ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ constructed ▁ tree : ▁ STRNEWLINE \" ) ; printInorder ( root ) ; return 0 ; }"}
{"text": "Kod c untuk percetakan pesanan disusun dari array yang diberikan yang mewakili BST", "code": "#include <stdio.h> NEW_LINE void printSorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ;"}
{"text": "Cetak subtree kiri", "code": "printSorted ( arr , start * 2 + 1 , end ) ;"}
{"text": "cetak akar", "code": "printf ( \" % d ▁ \" , arr [ start ] ) ;"}
{"text": "Cetak subtree kanan", "code": "printSorted ( arr , start * 2 + 2 , end ) ; }"}
{"text": "program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 } ; int arr_size = sizeof ( arr ) / sizeof ( int ) ; printSorted ( arr , 0 , arr_size - 1 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program untuk mencari ceil nilai tertentu di BST", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai kunci, anak kiri dan anak kanan", "code": "struct node { int key ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi pembantu yang memperuntukkan nod baru dengan kunci yang diberikan dan null kiri dan kanan.", "code": "struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Fungsi untuk mencari ceil input yang diberikan dalam BST. Sekiranya input lebih daripada kekunci maksimum di BST, kembali - 1", "code": "int Ceil ( struct node * root , int input ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return -1 ;"}
{"text": "Kami menjumpai kunci yang sama", "code": "if ( root -> key == input ) return root -> key ;"}
{"text": "Sekiranya kekunci Root lebih kecil, Ceil mesti berada di Subtree Kanan", "code": "if ( root -> key < input ) return Ceil ( root -> right , input ) ;"}
{"text": "Lain, sama ada subtree kiri atau akar mempunyai nilai seil", "code": "int ceil = Ceil ( root -> left , input ) ; return ( ceil >= input ) ? ceil : root -> key ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct node * root = newNode ( 8 ) ; root -> left = newNode ( 4 ) ; root -> right = newNode ( 12 ) ; root -> left -> left = newNode ( 2 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> left = newNode ( 10 ) ; root -> right -> right = newNode ( 14 ) ; for ( int i = 0 ; i < 16 ; i ++ ) printf ( \" % d ▁ % d STRNEWLINE \" , i , Ceil ( root , i ) ) ; return 0 ; }"}
{"text": "Program C untuk melaksanakan operasi asas (cari, masukkan dan padamkan) pada BST yang mengendalikan pendua dengan menyimpan kiraan dengan setiap nod", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; int count ; struct node * left , * right ; } ;"}
{"text": "Fungsi utiliti untuk membuat nod BST baru", "code": "struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> left = temp -> right = NULL ; temp -> count = 1 ; return temp ; }"}
{"text": "Fungsi utiliti untuk melakukan inorder traversal bst", "code": "void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( \" % d ( % d ) ▁ \" , root -> key , root -> count ) ; inorder ( root -> right ) ; } }"}
{"text": "Fungsi utiliti untuk memasukkan nod baru dengan kunci yang diberikan di BST", "code": "struct node * insert ( struct node * node , int key ) {"}
{"text": "Sekiranya pokok itu kosong, kembalikan nod baru", "code": "if ( node == NULL ) return newNode ( key ) ;"}
{"text": "Sekiranya kunci sudah ada di BST, kiraan dan kembali icnrement", "code": "if ( key == node -> key ) { ( node -> count ) ++ ; return node ; }"}
{"text": "Jika tidak, mengulangi pokok itu", "code": "if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ;"}
{"text": "Kembalikan penunjuk nod (tidak berubah)", "code": "return node ; }"}
{"text": "Memandangkan pokok carian binari yang tidak kosong, kembalikan nod dengan nilai kunci minimum yang terdapat di dalam pokok itu. Perhatikan bahawa seluruh pokok tidak perlu dicari.", "code": "struct node * minValueNode ( struct node * node ) { struct node * current = node ;"}
{"text": "gelung ke bawah untuk mencari daun paling kiri", "code": "while ( current -> left != NULL ) current = current -> left ; return current ; }"}
{"text": "Memandangkan pokok carian binari dan kunci, fungsi ini memadamkan kunci yang diberikan dan mengembalikan akar pokok yang diubah suai", "code": "struct node * deleteNode ( struct node * root , int key ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return root ;"}
{"text": "Sekiranya kunci yang akan dipadam lebih kecil daripada kunci akar, maka ia terletak di subtree kiri", "code": "if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ;"}
{"text": "Sekiranya kunci untuk dipadam lebih besar daripada kunci akar, maka ia terletak pada subtree yang betul", "code": "else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ;"}
{"text": "Sekiranya kunci sama dengan kunci root", "code": "else {"}
{"text": "Sekiranya kunci hadir lebih dari sekali, hanya pengurangan dan pulangan", "code": "if ( root -> count > 1 ) { ( root -> count ) -- ; return root ; }"}
{"text": "Lain, padamkan nod nod dengan hanya satu kanak -kanak atau tiada anak", "code": "if ( root -> left == NULL ) { struct node * temp = root -> right ; free ( root ) ; return temp ; } else if ( root -> right == NULL ) { struct node * temp = root -> left ; free ( root ) ; return temp ; }"}
{"text": "Node dengan Dua Kanak -kanak: Dapatkan Pengganti Inorder (Terkecil di Subtree Kanan)", "code": "struct node * temp = minValueNode ( root -> right ) ;"}
{"text": "Salin kandungan pengganti Inorder ke nod ini", "code": "root -> key = temp -> key ;"}
{"text": "Padamkan pengganti inorder", "code": "root -> right = deleteNode ( root -> right , temp -> key ) ; } return root ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Marilah kita buat berikut BST 12 (3) / \\ 10 (2) 20 (1) / \\ 9 (1) 11 (1)", "code": "struct node * root = NULL ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 20 ) ; root = insert ( root , 9 ) ; root = insert ( root , 11 ) ; root = insert ( root , 10 ) ; root = insert ( root , 12 ) ; root = insert ( root , 12 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ given ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; printf ( \" Delete 20 \" root = deleteNode ( root , 20 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; printf ( \" Delete 12 \" root = deleteNode ( root , 12 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; printf ( \" Delete 9 \" root = deleteNode ( root , 9 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; return 0 ; }"}
{"text": "Program C untuk menunjukkan mengurangkan operasi utama pada pokok carian binari", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; struct node * left , * right ; } ;"}
{"text": "Fungsi utiliti untuk membuat nod BST baru", "code": "struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Fungsi utiliti untuk melakukan inorder traversal bst", "code": "void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( \" % d ▁ \" , root -> key ) ; inorder ( root -> right ) ; } }"}
{"text": "Fungsi utiliti untuk memasukkan nod baru dengan kunci yang diberikan di BST", "code": "struct node * insert ( struct node * node , int key ) {"}
{"text": "Sekiranya pokok itu kosong, kembalikan nod baru", "code": "if ( node == NULL ) return newNode ( key ) ;"}
{"text": "Jika tidak, mengulangi pokok itu", "code": "if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ;"}
{"text": "Kembalikan penunjuk nod (tidak berubah)", "code": "return node ; }"}
{"text": "Memandangkan pokok carian binari yang tidak kosong, kembalikan nod dengan nilai kunci minimum yang terdapat di dalam pokok itu. Perhatikan bahawa seluruh pokok tidak perlu dicari.", "code": "struct node * minValueNode ( struct node * node ) { struct node * current = node ;"}
{"text": "gelung ke bawah untuk mencari daun paling kiri", "code": "while ( current -> left != NULL ) current = current -> left ; return current ; }"}
{"text": "Memandangkan pokok carian binari dan kunci, fungsi ini memadamkan kunci dan mengembalikan akar baru", "code": "struct node * deleteNode ( struct node * root , int key ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return root ;"}
{"text": "Sekiranya kunci yang akan dipadam lebih kecil daripada kunci akar, maka ia terletak di subtree kiri", "code": "if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ;"}
{"text": "Sekiranya kunci untuk dipadam lebih besar daripada kunci akar, maka ia terletak pada subtree yang betul", "code": "else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ;"}
{"text": "Sekiranya kunci sama dengan kunci root, maka ini adalah nod yang akan dipadam", "code": "else {"}
{"text": "nod dengan hanya satu kanak -kanak atau tiada anak", "code": "if ( root -> left == NULL ) { struct node * temp = root -> right ; free ( root ) ; return temp ; } else if ( root -> right == NULL ) { struct node * temp = root -> left ; free ( root ) ; return temp ; }"}
{"text": "Node dengan Dua Kanak -kanak: Dapatkan Pengganti Inorder (Terkecil di Subtree Kanan)", "code": "struct node * temp = minValueNode ( root -> right ) ;"}
{"text": "Salin kandungan pengganti Inorder ke nod ini", "code": "root -> key = temp -> key ;"}
{"text": "Padamkan pengganti inorder", "code": "root -> right = deleteNode ( root -> right , temp -> key ) ; } return root ; }"}
{"text": "Berfungsi untuk mengurangkan nilai utama dalam pokok carian binari", "code": "struct node * changeKey ( struct node * root , int oldVal , int newVal ) {"}
{"text": "Padam pertama nilai kunci lama", "code": "root = deleteNode ( root , oldVal ) ;"}
{"text": "Kemudian masukkan nilai kunci baru", "code": "root = insert ( root , newVal ) ;"}
{"text": "Kembalikan akar baru", "code": "return root ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Mari kita buat berikut BST 50 / \\ 30 70 / \\ / \\ 20 40 60 80", "code": "struct node * root = NULL ; root = insert ( root , 50 ) ; root = insert ( root , 30 ) ; root = insert ( root , 20 ) ; root = insert ( root , 40 ) ; root = insert ( root , 70 ) ; root = insert ( root , 60 ) ; root = insert ( root , 80 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ given ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; root = changeKey ( root , 40 , 10 ) ;"}
{"text": "BST diubah suai kepada 50 / \\ 30 70 / / \\ 20 60 80/10", "code": "printf ( \" Inorder traversal of the modified tree \" inorder ( root ) ; return 0 ; }"}
{"text": "Program C untuk mengira bilangan nod di BST yang mengandungi dua digit nombor khas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok", "code": "struct Node { struct Node * left ; int info ; struct Node * right ; } ;"}
{"text": "Berfungsi untuk membuat nod baru", "code": "void insert ( struct Node * * rt , int key ) {"}
{"text": "Sekiranya pokok itu kosong, kembalikan nod tunggal yang baru", "code": "if ( * rt == NULL ) { ( * rt ) = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; ( * rt ) -> left = NULL ; ( * rt ) -> right = NULL ; ( * rt ) -> info = key ; }"}
{"text": "Jika tidak, mengulangi pokok itu", "code": "else if ( key < ( ( * rt ) -> info ) ) insert ( & ( ( * rt ) -> left ) , key ) ; else insert ( & ( * rt ) -> right , key ) ; }"}
{"text": "Berfungsi untuk mencari jika nombor adalah istimewa atau tidak", "code": "int check ( int num ) { int sum = 0 , i = num , sum_of_digits , prod_of_digits ;"}
{"text": "Periksa sama ada nombor dua digit atau tidak", "code": "if ( num < 10 num > 99 ) return 0 ; else { sum_of_digits = ( i % 10 ) + ( i / 10 ) ; prod_of_digits = ( i % 10 ) * ( i / 10 ) ; sum = sum_of_digits + prod_of_digits ; } if ( sum == num ) return 1 ; else return 0 ; }"}
{"text": "Berfungsi untuk mengira bilangan nombor dua digit khas", "code": "void countSpecialDigit ( struct Node * rt , int * c ) { int x ; if ( rt == NULL ) return ; else { x = check ( rt -> info ) ; if ( x == 1 ) * c = * c + 1 ; countSpecialDigit ( rt -> left , c ) ; countSpecialDigit ( rt -> right , c ) ; } }"}
{"text": "Program Pemandu untuk Menguji", "code": "int main ( ) { struct Node * root = NULL ; int count = 0 ; insert ( & root , 50 ) ; insert ( & root , 29 ) ; insert ( & root , 59 ) ; insert ( & root , 19 ) ; insert ( & root , 53 ) ; insert ( & root , 556 ) ; insert ( & root , 56 ) ; insert ( & root , 94 ) ; insert ( & root , 13 ) ;"}
{"text": "Fungsi panggilan, untuk memeriksa setiap nod untuk nombor dua digit khas", "code": "countSpecialDigit ( root , & count ) ; printf ( \" % d \" , count ) ; return 0 ; }"}
{"text": "program untuk membina pokok dari inorder traversal", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Prototaip fungsi utiliti untuk mendapatkan nilai maksimum dalam inorder [Mula. . berakhir]", "code": "int max ( int inorder [ ] , int strt , int end ) ; struct node * newNode ( int data ) ;"}
{"text": "Fungsi rekursif untuk membina binari saiz len dari inorder inorder inorder []. Nilai awal permulaan dan akhir hendaklah 0 dan len - 1.", "code": "struct node * buildTree ( int inorder [ ] , int start , int end ) { if ( start > end ) return NULL ;"}
{"text": "Cari indeks elemen maksimum dari pokok binari", "code": "int i = max ( inorder , start , end ) ;"}
{"text": "Pilih nilai maksimum dan menjadikannya akar", "code": "struct node * root = newNode ( inorder [ i ] ) ;"}
{"text": "Jika ini adalah satu -satunya elemen dalam inorder [Mula. . akhir], kemudian kembalikan", "code": "if ( start == end ) return root ;"}
{"text": "Menggunakan Indeks dalam Inorder Traversal, Bina Subtrek Kiri dan Kanan", "code": "root -> left = buildTree ( inorder , start , i - 1 ) ; root -> right = buildTree ( inorder , i + 1 , end ) ; return root ; }"}
{"text": "Berfungsi untuk mencari indeks nilai maksimum di arr [mula ... akhir]", "code": "int max ( int arr [ ] , int strt , int end ) { int i , max = arr [ strt ] , maxind = strt ; for ( i = strt + 1 ; i <= end ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; maxind = i ; } } return maxind ; }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return node ; }"}
{"text": "Funtcion ini ada di sini hanya untuk menguji BuildTree ()", "code": "void printInorder ( struct node * node ) { if ( node == NULL ) return ;"}
{"text": "Pertama berulang pada anak kiri", "code": "printInorder ( node -> left ) ;"}
{"text": "kemudian cetak data nod", "code": "printf ( \" % d ▁ \" , node -> data ) ;"}
{"text": "sekarang berulang pada anak yang betul", "code": "printInorder ( node -> right ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Anggapkan bahawa traversal inorder dari pokok berikut diberikan 40 / \\ 10 30 / \\ 5 28", "code": "int inorder [ ] = { 5 , 10 , 40 , 30 , 28 } ; int len = sizeof ( inorder ) / sizeof ( inorder [ 0 ] ) ; struct node * root = buildTree ( inorder , 0 , len - 1 ) ;"}
{"text": "Mari kita uji pokok yang dibina dengan mencetak Traversal Insorder", "code": "printf ( \" Inorder traversal of the constructed tree is \" printInorder ( root ) ; return 0 ; }"}
{"text": "Program C untuk mencetak matriks identiti", "code": "#include <stdio.h> NEW_LINE int Identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) {"}
{"text": "Memeriksa jika baris sama dengan lajur", "code": "if ( row == col ) printf ( \" % d ▁ \" , 1 ) ; else printf ( \" % d ▁ \" , 0 ) ; } printf ( \" STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int size = 5 ; identity ( size ) ; return 0 ; }"}
{"text": "Program C untuk mencari elemen dalam baris - bijak dan lajur - matriks yang disusun bijak", "code": "#include <stdio.h>"}
{"text": "Mencari elemen x dalam tikar [] []. Sekiranya elemen itu dijumpai, maka mencetak kedudukannya dan mengembalikan benar, jika tidak, cetak \"tidak ada\" dan pulih palsu", "code": "int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return -1 ; int smallest = mat [ 0 ] [ 0 ] , largest = mat [ n - 1 ] [ n - 1 ] ; if ( x < smallest x > largest ) return -1 ;"}
{"text": "Tetapkan indeks untuk elemen kanan atas", "code": "int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { printf ( \" Found at % d , % d \" , i , j ) ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ;"}
{"text": "jika tikar [i] [j] <x", "code": "else i ++ ; } printf ( \" n ▁ Element ▁ not ▁ found \" ) ;"}
{"text": "jika (i == n j == - 1)", "code": "return 0 ; }"}
{"text": "program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int mat [ 4 ] [ 4 ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } , } ; search ( mat , 4 , 29 ) ; return 0 ; }"}
{"text": "Berfungsi untuk mencetak segi empat tepat berganti 0 dan x", "code": "void fill0X ( int m , int n ) {"}
{"text": "K - Indeks baris permulaan m - Indeks baris akhir l - Indeks lajur permulaan n - Indeks lajur berakhir i - iterator", "code": "int i , k = 0 , l = 0 ;"}
{"text": "Simpan bilangan baris dan lajur yang diberikan untuk kegunaan kemudian", "code": "int r = m , c = n ;"}
{"text": "Arahan 2D untuk menyimpan output untuk dicetak", "code": "char a [ m ] [ n ] ;"}
{"text": "Ini akan menjadi watak yang akan ditangkap dalam [] []", "code": "char x = ' X ' ;"}
{"text": "Isi aksara dalam [] [] dalam bentuk lingkaran. Setiap lelaran memenuhi satu segi empat tepat sama ada xs atau os", "code": "while ( k < m && l < n ) {"}
{"text": "Isi baris pertama dari baki baris", "code": "for ( i = l ; i < n ; ++ i ) a [ k ] [ i ] = x ; k ++ ;"}
{"text": "Isi lajur terakhir dari lajur yang tinggal", "code": "for ( i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = x ; n -- ;"}
{"text": "Isi baris terakhir dari barisan yang tinggal", "code": "if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; }"}
{"text": "Cetak lajur pertama dari lajur yang tinggal", "code": "if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = x ; l ++ ; }"}
{"text": "Watak Flip untuk lelaran seterusnya", "code": "x = ( x == '0' ) ? ' X ' : '0' ; }"}
{"text": "Cetak matriks yang diisi", "code": "for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) printf ( \" % c ▁ \" , a [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { puts ( \" Output ▁ for ▁ m ▁ = ▁ 5 , ▁ n ▁ = ▁ 6\" ) ; fill0X ( 5 , 6 ) ; puts ( \" Output for m = 4 , n = 4 \" ) ; fill0X ( 4 , 4 ) ; puts ( \" Output for m = 3 , n = 4 \" ) ; fill0X ( 3 , 4 ) ; return 0 ; }"}
{"text": "Program C Untuk Menukar Diagonal Matriks", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3"}
{"text": "Berfungsi untuk bertukar pepenjuru", "code": "void interchangeDiagonals ( int array [ ] [ N ] ) {"}
{"text": "elemen pertukaran pepenjuru", "code": "for ( int i = 0 ; i < N ; ++ i ) if ( i != N / 2 ) swap ( array [ i ] [ i ] , array [ i ] [ N - i - 1 ] ) ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) printf ( \" ▁ % d \" , array [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int array [ N ] [ N ] = { 4 , 5 , 6 , 1 , 2 , 3 , 7 , 8 , 9 } ; interchangeDiagonals ( array ) ; return 0 ; }"}
{"text": "Program untuk melaksanakan pelaksanaan pokok binari yang lengkap", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Untuk saiz giliran", "code": "#define SIZE  50"}
{"text": "Nod pokok", "code": "struct node { int data ; struct node * right , * left ; } ;"}
{"text": "Nod giliran", "code": "struct Queue { int front , rear ; int size ; struct node * * array ; } ;"}
{"text": "Fungsi utiliti untuk membuat nod pokok baru", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Fungsi utiliti untuk membuat barisan baru", "code": "struct Queue * createQueue ( int size ) { struct Queue * queue = ( struct Queue * ) malloc ( sizeof ( struct Queue ) ) ; queue -> front = queue -> rear = -1 ; queue -> size = size ; queue -> array = ( struct node * * ) malloc ( queue -> size * sizeof ( struct node * ) ) ; int i ; for ( i = 0 ; i < size ; ++ i ) queue -> array [ i ] = NULL ; return queue ; }"}
{"text": "Fungsi giliran standard", "code": "int isEmpty ( struct Queue * queue ) { return queue -> front == -1 ; } int isFull ( struct Queue * queue ) { return queue -> rear == queue -> size - 1 ; } int hasOnlyOneItem ( struct Queue * queue ) { return queue -> front == queue -> rear ; } void Enqueue ( struct node * root , struct Queue * queue ) { if ( isFull ( queue ) ) return ; queue -> array [ ++ queue -> rear ] = root ; if ( isEmpty ( queue ) ) ++ queue -> front ; } struct node * Dequeue ( struct Queue * queue ) { if ( isEmpty ( queue ) ) return NULL ; struct node * temp = queue -> array [ queue -> front ] ; if ( hasOnlyOneItem ( queue ) ) queue -> front = queue -> rear = -1 ; else ++ queue -> front ; return temp ; } struct node * getFront ( struct Queue * queue ) { return queue -> array [ queue -> front ] ; }"}
{"text": "Fungsi utiliti untuk memeriksa sama ada nod pokok mempunyai anak kiri dan kanan", "code": "int hasBothChild ( struct node * temp ) { return temp && temp -> left && temp -> right ; }"}
{"text": "Berfungsi untuk memasukkan nod baru dalam pokok binari lengkap", "code": "void insert ( struct node * * root , int data , struct Queue * queue ) {"}
{"text": "Buat nod baru untuk data yang diberikan", "code": "struct node * temp = newNode ( data ) ;"}
{"text": "Jika pokok itu kosong, mulakan akar dengan nod baru.", "code": "if ( ! * root ) * root = temp ; else {"}
{"text": "Dapatkan nod depan barisan.", "code": "struct node * front = getFront ( queue ) ;"}
{"text": "Sekiranya anak kiri nod depan ini tidak wujud, tetapkan anak kiri sebagai nod baru", "code": "if ( ! front -> left ) front -> left = temp ;"}
{"text": "Sekiranya anak yang betul dari nod depan ini tidak wujud, tetapkan anak yang tepat sebagai nod baru", "code": "else if ( ! front -> right ) front -> right = temp ;"}
{"text": "Jika nod depan mempunyai anak kiri dan anak kanan, dequeue () itu.", "code": "if ( hasBothChild ( front ) ) Dequeue ( queue ) ; }"}
{"text": "Enqueue () nod baru untuk sisipan kemudian", "code": "Enqueue ( temp , queue ) ; }"}
{"text": "Perintah Tahap Standard Traversal untuk Menguji Fungsi Di atas", "code": "void levelOrder ( struct node * root ) { struct Queue * queue = createQueue ( SIZE ) ; Enqueue ( root , queue ) ; while ( ! isEmpty ( queue ) ) { struct node * temp = Dequeue ( queue ) ; printf ( \" % d ▁ \" , temp -> data ) ; if ( temp -> left ) Enqueue ( temp -> left , queue ) ; if ( temp -> right ) Enqueue ( temp -> right , queue ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct node * root = NULL ; struct Queue * queue = createQueue ( SIZE ) ; int i ; for ( i = 1 ; i <= 12 ; ++ i ) insert ( & root , i , queue ) ; levelOrder ( root ) ; return 0 ; }"}
{"text": "Program C untuk penukaran pokok binari ke DLL", "code": "#include <stdio.h>"}
{"text": "Nod pokok binari mempunyai data, dan petunjuk kiri dan kanan", "code": "struct node { int data ; node * left ; node * right ; } ;"}
{"text": "Ini adalah fungsi teras untuk menukar pokok ke senarai. Fungsi ini mengikuti Langkah 1 dan 2 algoritma di atas", "code": "node * bintree2listUtil ( node * root ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return root ;"}
{"text": "Tukar subtree kiri dan pautan ke root", "code": "if ( root -> left != NULL ) {"}
{"text": "Tukar subtree kiri", "code": "node * left = bintree2listUtil ( root -> left ) ;"}
{"text": "Cari Inorderororor. Selepas gelung ini, kiri akan menunjuk kepada pendahuluan inorder", "code": "for ( ; left -> right != NULL ; left = left -> right ) ;"}
{"text": "Buat akar sebagai pendahuluan yang terdahulu", "code": "left -> right = root ;"}
{"text": "Buat predecssor seperti sebelumnya akar", "code": "root -> left = left ; }"}
{"text": "Tukar subtree kanan dan pautan ke root", "code": "if ( root -> right != NULL ) {"}
{"text": "Tukar subtree yang betul", "code": "node * right = bintree2listUtil ( root -> right ) ;"}
{"text": "Cari pengganti inorder. Selepas gelung ini, betul akan menunjuk kepada pengganti inorder", "code": "for ( ; right -> left != NULL ; right = right -> left ) ;"}
{"text": "Membuat akar seperti sebelumnya pengganti", "code": "right -> left = root ;"}
{"text": "Buat pengganti sebagai akar seterusnya", "code": "root -> right = right ; } return root ; }"}
{"text": "Fungsi utama yang pertama kali memanggil Bintree2ListUtil (), kemudian mengikuti Langkah 3 dari algoritma di atas", "code": "node * bintree2list ( node * root ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return root ;"}
{"text": "Tukar ke DLL Menggunakan Bintree2ListUtil ()", "code": "root = bintree2listUtil ( root ) ;"}
{"text": "bintree2listutil () mengembalikan nod akar DLL yang ditukar. Kami memerlukan penunjuk ke nod paling kiri yang merupakan ketua DLL yang dibina, jadi pindah ke nod paling kiri", "code": "while ( root -> left != NULL ) root = root -> left ; return ( root ) ; }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "node * newNode ( int data ) { node * new_node = new node ; new_node -> data = data ; new_node -> left = new_node -> right = NULL ; return ( new_node ) ; }"}
{"text": "Berfungsi untuk mencetak nod dalam senarai dikaitkan dua kali ganda", "code": "void printList ( node * node ) { while ( node != NULL ) { printf ( \" % d ▁ \" , node -> data ) ; node = node -> right ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Marilah kita buat pokok yang ditunjukkan dalam rajah di atas", "code": "node * root = newNode ( 10 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 15 ) ; root -> left -> left = newNode ( 25 ) ; root -> left -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 36 ) ;"}
{"text": "Tukar ke DLL", "code": "node * head = bintree2list ( root ) ;"}
{"text": "Cetak senarai yang ditukar", "code": "printList ( head ) ; return 0 ; }"}
{"text": "Memandangkan matriks binari m x n bilangan bulat, anda perlu mengembalikan hanya baris unik dari array binari", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE #define ROW  4 NEW_LINE #define COL  5"}
{"text": "Node trie", "code": "typedef struct Node { bool isEndOfCol ;"}
{"text": "Hanya dua kanak -kanak yang diperlukan untuk 0 dan 1", "code": "struct Node * child [ 2 ] ; } Node ;"}
{"text": "Fungsi utiliti untuk memperuntukkan memori untuk nod trie baru", "code": "Node * newNode ( ) { Node * temp = ( Node * ) malloc ( sizeof ( Node ) ) ; temp -> isEndOfCol = 0 ; temp -> child [ 0 ] = temp -> child [ 1 ] = NULL ; return temp ; }"}
{"text": "Masukkan baris matriks baru ke Trie. Sekiranya baris sudah ada, maka kembali 0, jika tidak, anda akan kembali berturut -turut dan kembali 1", "code": "bool insert ( Node * * root , int ( * M ) [ COL ] , int row , int col ) {"}
{"text": "Kes asas", "code": "if ( * root == NULL ) * root = newNode ( ) ;"}
{"text": "Berulang jika terdapat lebih banyak penyertaan dalam baris ini", "code": "if ( col < COL ) return insert ( & ( ( * root ) -> child [ M [ row ] [ col ] ] ) , M , row , col + 1 ) ;"}
{"text": "Sekiranya semua penyertaan baris ini diproses", "code": "else {"}
{"text": "baris unik dijumpai, kembali 1", "code": "if ( ! ( ( * root ) -> isEndOfCol ) ) return ( * root ) -> isEndOfCol = 1 ;"}
{"text": "baris pendua dijumpai, kembali 0", "code": "return 0 ; } }"}
{"text": "Fungsi utiliti untuk mencetak baris", "code": "void printRow ( int ( * M ) [ COL ] , int row ) { int i ; for ( i = 0 ; i < COL ; ++ i ) printf ( \" % d ▁ \" , M [ row ] [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Fungsi utama yang mencetak semua baris unik dalam matriks yang diberikan.", "code": "void findUniqueRows ( int ( * M ) [ COL ] ) {"}
{"text": "buat trie kosong", "code": "Node * root = NULL ; int i ;"}
{"text": "Melewati semua baris", "code": "for ( i = 0 ; i < ROW ; ++ i )"}
{"text": "masukkan baris ke trie", "code": "if ( insert ( & root , M , i , 0 ) )"}
{"text": "baris unik dijumpai, cetaknya", "code": "printRow ( M , i ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int M [ ROW ] [ COL ] = { { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 0 , 0 } } ; findUniqueRows ( M ) ; return 0 ; }"}
{"text": "Program c untuk mencari elemen yang sama dalam semua baris array yang disusun dengan bijak", "code": "#include <stdio.h>"}
{"text": "Nyatakan bilangan baris dan lajur", "code": "#define M  4 NEW_LINE #define N  5"}
{"text": "Mengembalikan elemen biasa dalam semua baris Mat [M] [n]. Sekiranya tidak ada elemen biasa, maka - 1 dikembalikan", "code": "int findCommon ( int mat [ M ] [ N ] ) {"}
{"text": "Arahan untuk menyimpan indeks lajur terakhir semasa", "code": "int column [ M ] ;"}
{"text": "Untuk menyimpan indeks baris yang elemen terakhirnya adalah minimum", "code": "int min_row ;"}
{"text": "Memulakan elemen terakhir semasa semua baris", "code": "int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ;"}
{"text": "Memulakan min_row sebagai baris pertama", "code": "min_row = 0 ;"}
{"text": "Teruskan mencari min_row dalam lajur terakhir semasa, sehingga sama ada semua elemen lajur terakhir menjadi sama atau kami memukul lajur pertama.", "code": "while ( column [ min_row ] >= 0 ) {"}
{"text": "Cari minimum dalam lajur terakhir semasa", "code": "for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ; }"}
{"text": "eq_count adalah kiraan elemen yang sama dengan minimum dalam lajur terakhir semasa.", "code": "int eq_count = 0 ;"}
{"text": "Melintasi elemen lajur terakhir semasa sekali lagi untuk mengemas kini", "code": "for ( i = 0 ; i < M ; i ++ ) {"}
{"text": "Kurangkan indeks lajur terakhir baris yang nilainya lebih minimum.", "code": "if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return -1 ;"}
{"text": "Kurangkan indeks lajur terakhir dengan 1", "code": "column [ i ] -= 1 ; } else eq_count ++ ; }"}
{"text": "Sekiranya kiraan yang sama menjadi m, kembalikan nilai", "code": "if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } return -1 ; }"}
{"text": "program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int mat [ M ] [ N ] = { { 1 , 2 , 3 , 4 , 5 } , { 2 , 4 , 5 , 8 , 10 } , { 3 , 5 , 7 , 9 , 11 } , { 1 , 3 , 5 , 7 , 9 } , } ; int result = findCommon ( mat ) ; if ( result == -1 ) printf ( \" No ▁ common ▁ element \" ) ; else printf ( \" Common ▁ element ▁ is ▁ % d \" , result ) ; return 0 ; }"}
{"text": "Program berasaskan traversal inorder yang mudah untuk menukar pokok binari ke dll", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Fungsi utiliti untuk membuat nod pokok baru", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; }"}
{"text": "Traversal inorder standard", "code": "void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( \" TABSYMBOL % d \" , root -> data ) ; inorder ( root -> right ) ; } }"}
{"text": "Perubahan petunjuk kiri berfungsi sebagai petunjuk sebelumnya dalam dll yang ditukar fungsi hanya melakukan inorder traversal pokok binari dan mengemas kini penunjuk kiri menggunakan nod yang telah dikunjungi sebelumnya", "code": "void fixPrevPtr ( struct node * root ) { static struct node * pre = NULL ; if ( root != NULL ) { fixPrevPtr ( root -> left ) ; root -> left = pre ; pre = root ; fixPrevPtr ( root -> right ) ; } }"}
{"text": "Perubahan petunjuk yang betul untuk berfungsi sebagai petunjuk seterusnya dalam DLL yang ditukar", "code": "struct node * fixNextPtr ( struct node * root ) { struct node * prev = NULL ;"}
{"text": "Cari nod paling tepat di BT atau nod terakhir di DLL", "code": "while ( root && root -> right != NULL ) root = root -> right ;"}
{"text": "Mulakan dari nod paling kanan, melintasi kembali menggunakan petunjuk kiri. Semasa melintasi, tukar penunjuk kanan nod.", "code": "while ( root && root -> left != NULL ) { prev = root ; root = root -> left ; root -> right = prev ; }"}
{"text": "Node paling kiri adalah ketua senarai yang dipautkan, kembalikan", "code": "return ( root ) ; }"}
{"text": "Fungsi utama yang menukarkan BST ke DLL dan mengembalikan kepala DLL", "code": "struct node * BTToDLL ( struct node * root ) {"}
{"text": "Tetapkan penunjuk sebelumnya", "code": "fixPrevPtr ( root ) ;"}
{"text": "Tetapkan penunjuk seterusnya dan kembali kepala DLL", "code": "return fixNextPtr ( root ) ; }"}
{"text": "Melintasi dll dari kiri ke kanan", "code": "void printList ( struct node * root ) { while ( root != NULL ) { printf ( \" TABSYMBOL % d \" , root -> data ) ; root = root -> right ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( void ) {"}
{"text": "Marilah kita buat pokok yang ditunjukkan dalam rajah di atas", "code": "struct node * root = newNode ( 10 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 15 ) ; root -> left -> left = newNode ( 25 ) ; root -> left -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 36 ) ; printf ( \" Inorder Tree Traversal \" inorder ( root ) ; struct node * head = BTToDLL ( root ) ; printf ( \" DLL Traversal \" printList ( head ) ; return 0 ; }"}
{"text": "Program untuk menukar pokok binari Aribiter ke pokok yang memegang harta benda kanak -kanak", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod pokok binari", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Fungsi ini digunakan untuk meningkatkan subtree kiri", "code": "void increment ( struct node * node , int diff ) ;"}
{"text": "Fungsi ini mengubah pokok untuk memegang harta benda kanak -kanak", "code": "void convertTree ( struct node * node ) { int left_data = 0 , right_data = 0 , diff ;"}
{"text": "Sekiranya pokok kosong atau ia adalah nod daun maka kembali benar", "code": "if ( node == NULL || ( node -> left == NULL && node -> right == NULL ) ) return ; else {"}
{"text": "Tukar subtrees kiri dan kanan", "code": "convertTree ( node -> left ) ; convertTree ( node -> right ) ;"}
{"text": "Sekiranya anak kiri tidak hadir maka 0 digunakan sebagai data anak kiri", "code": "if ( node -> left != NULL ) left_data = node -> left -> data ;"}
{"text": "Sekiranya anak yang betul tidak hadir maka 0 digunakan sebagai data anak yang betul", "code": "if ( node -> right != NULL ) right_data = node -> right -> data ;"}
{"text": "Dapatkan Data Data dan Kanak -kanak Node", "code": "diff = left_data + right_data - node -> data ;"}
{"text": "Jika node 's u u u u u' lebih besar daripada data node", "code": "if ( diff > 0 ) node -> data = node -> data + diff ;"}
{"text": "Ini rumit -> jika data nod lebih besar daripada jumlah kanak -kanak, maka subtree kenaikan dengan diff", "code": "if ( diff < 0 )"}
{"text": "- diff digunakan untuk membuat perbezaan positif", "code": "increment ( node , - diff ) ; } }"}
{"text": "Fungsi ini digunakan untuk meningkatkan subtree dengan diff", "code": "void increment ( struct node * node , int diff ) {"}
{"text": "Sekiranya anak kiri tidak batal maka tambahnya", "code": "if ( node -> left != NULL ) { node -> left -> data = node -> left -> data + diff ;"}
{"text": "Panggilan secara berulang untuk memperbaiki keturunan nod -> kiri", "code": "increment ( node -> left , diff ) ; }"}
{"text": "Lain -lain Peningkatan Anak", "code": "else if ( node -> right != NULL ) { node -> right -> data = node -> right -> data + diff ;"}
{"text": "Panggilan berulang untuk memperbaiki keturunan nod -> betul", "code": "increment ( node -> right , diff ) ; } }"}
{"text": "Memandangkan pokok binari, printInorder () mencetak traversal inordernya", "code": "void printInorder ( struct node * node ) { if ( node == NULL ) return ;"}
{"text": "Pertama berulang pada anak kiri", "code": "printInorder ( node -> left ) ;"}
{"text": "kemudian cetak data nod", "code": "printf ( \" % d ▁ \" , node -> data ) ;"}
{"text": "sekarang berulang pada anak yang betul", "code": "printInorder ( node -> right ) ; }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct node * root = newNode ( 50 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 1 ) ; root -> right -> right = newNode ( 30 ) ; printf ( \" Inorder traversal before conversion \" printInorder ( root ) ; convertTree ( root ) ; printf ( \" Inorder traversal after conversion \" printInorder ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Struktur nod pokok", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Tukar pokok yang diberikan ke pokok di mana setiap nod mengandungi jumlah nilai nod di subtrees kiri dan kanan di pokok asal", "code": "int toSumTree ( struct node * node ) {"}
{"text": "Kes asas", "code": "if ( node == NULL ) return 0 ;"}
{"text": "Simpan nilai lama", "code": "int old_val = node -> data ;"}
{"text": "Panggilan secara rekursif untuk subtrees kiri dan kanan dan simpan jumlahnya sebagai nilai baru nod ini", "code": "node -> data = toSumTree ( node -> left ) + toSumTree ( node -> right ) ;"}
{"text": "Kembalikan jumlah nilai nod di subtrees kiri dan kanan dan Old_value nod ini", "code": "return node -> data + old_val ; }"}
{"text": "Fungsi utiliti untuk mencetak inorder traversal pokok binari", "code": "void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; printInorder ( node -> right ) ; }"}
{"text": "Fungsi utiliti untuk membuat nod pokok binari baru", "code": "struct node * newNode ( int data ) { struct node * temp = new struct node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; }"}
{"text": "Fungsi pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct node * root = NULL ; int x ;"}
{"text": "Membina pokok yang diberikan dalam angka di atas", "code": "root = newNode ( 10 ) ; root -> left = newNode ( -2 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( -4 ) ; root -> right -> left = newNode ( 7 ) ; root -> right -> right = newNode ( 5 ) ; toSumTree ( root ) ;"}
{"text": "Cetak inorder traversal pokok yang ditukar untuk menguji hasil tosumtree ()", "code": "printf ( \" Inorder ▁ Traversal ▁ of ▁ the ▁ resultant ▁ tree ▁ is : ▁ STRNEWLINE \" ) ; printInorder ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mencari elemen puncak menggunakan membahagikan dan menakluki", "code": "#include <stdio.h>"}
{"text": "Fungsi berasaskan carian binari yang mengembalikan indeks elemen puncak", "code": "int findPeakUtil ( int arr [ ] , int low , int high , int n ) {"}
{"text": "Cari Indeks Elemen Tengah (Rendah + Tinggi) / 2", "code": "int mid = low + ( high - low ) / 2 ;"}
{"text": "Bandingkan elemen tengah dengan jirannya (jika jiran wujud)", "code": "if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ;"}
{"text": "Sekiranya elemen tengah tidak puncak dan jiran kiri lebih besar daripada itu, maka separuh kiri mesti mempunyai elemen puncak", "code": "else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ;"}
{"text": "Sekiranya elemen tengah tidak puncak dan jiran kanannya lebih besar daripada itu, maka separuh kanan mesti mempunyai elemen puncak", "code": "else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; }"}
{"text": "Pembungkus mengenai fungsi rekursif findpeakutil ()", "code": "int findPeak ( int arr [ ] , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; }"}
{"text": "Program pemacu untuk menyemak fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Index ▁ of ▁ a ▁ peak ▁ point ▁ is ▁ % d \" , findPeak ( arr , n ) ) ; return 0 ; }"}
{"text": "Cetak fungsi berulang", "code": "void printRepeating ( int arr [ ] , int size ) { int i , j ; printf ( \" ▁ Repeating ▁ elements ▁ are ▁ \" ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) printf ( \" ▁ % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Fungsi", "code": "void printRepeating ( int arr [ ] , int size ) { int * count = ( int * ) calloc ( sizeof ( int ) , ( size - 2 ) ) ; int i ; printf ( \" ▁ Repeating ▁ elements ▁ are ▁ \" ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) printf ( \" ▁ % d ▁ \" , arr [ i ] ) ; else count [ arr [ i ] ] ++ ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Fungsi PrintRepeating", "code": "int fact ( int n ) ; void printRepeating ( int arr [ ] , int size ) {"}
{"text": "S adalah untuk jumlah elemen di arr []", "code": "int S = 0 ;"}
{"text": "P adalah untuk produk elemen di arr []", "code": "int P = 1 ;"}
{"text": "x dan y adalah dua elemen berulang", "code": "int x , y ;"}
{"text": "D adalah untuk perbezaan x dan y, i. e. , x - y", "code": "int D ; int n = size - 2 , i ;"}
{"text": "Kirakan jumlah dan produk semua elemen di arr []", "code": "for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; }"}
{"text": "S adalah x + y sekarang", "code": "S = S - n * ( n + 1 ) / 2 ;"}
{"text": "P adalah x * y sekarang", "code": "P = P / fact ( n ) ;"}
{"text": "D adalah x - y sekarang", "code": "D = sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; printf ( \" The ▁ two ▁ Repeating ▁ elements ▁ are ▁ % d ▁ & ▁ % d \" , x , y ) ; }"}
{"text": "Faktorial n", "code": "int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; }"}
{"text": "kod pemacu", "code": "int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "COD C untuk mencari dua elemen berulang dalam array yang diberikan", "code": "void printRepeating ( int arr [ ] , int size ) {"}
{"text": "Akan memegang xor semua elemen", "code": "int xor = arr [ 0 ] ;"}
{"text": "Hanya mempunyai satu set bit xor", "code": "int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ;"}
{"text": "Dapatkan xor semua elemen dalam arr [] dan {1, 2. . n}", "code": "for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ;"}
{"text": "Dapatkan bit set paling kanan di set_bit_no", "code": "set_bit_no = xor & ~ ( xor - 1 ) ;"}
{"text": "Sekarang bahagikan unsur -unsur dalam dua set dengan membandingkan bit XOR set paling kanan dengan bit pada kedudukan yang sama dalam setiap elemen.", "code": "for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ;"}
{"text": "Xor set pertama di arr []", "code": "else y = y ^ arr [ i ] ;"}
{"text": "Xor set kedua di arr []", "code": "} for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ;"}
{"text": "Xor set pertama di arr [] dan {1, 2, ... n}", "code": "else y = y ^ i ;"}
{"text": "Xor set kedua dalam arr [] dan {1, 2, ... n}", "code": "} printf ( \" n ▁ The ▁ two ▁ repeating ▁ elements ▁ are ▁ % d ▁ & ▁ % d ▁ \" , x , y ) ; }"}
{"text": "kod pemacu", "code": "int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Berfungsi untuk mencetak berulang", "code": "void printRepeating ( int arr [ ] , int size ) { int i ; printf ( \" The repeating elements are \" for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; else printf ( \" ▁ % d ▁ \" , abs ( arr [ i ] ) ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program mudah untuk mencetak subarray dengan jumlah yang diberikan", "code": "#include <stdio.h>"}
{"text": "Pulangan benar jika ada subarray arr [] dengan jumlah yang sama dengan 'jumlah' sebaliknya mengembalikan palsu. Juga, mencetak hasilnya", "code": "int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ;"}
{"text": "Pilih titik permulaan", "code": "for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ;"}
{"text": "Cuba semua subarray bermula dengan 'I'", "code": "for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { printf ( \" Sum ▁ found ▁ between ▁ indexes ▁ % d ▁ and ▁ % d \" , i , j - 1 ) ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } printf ( \" No ▁ subarray ▁ found \" ) ; return 0 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; subArraySum ( arr , n , sum ) ; return 0 ; }"}
{"text": "Program yang cekap untuk mencetak subarray dengan jumlah yang diberikan", "code": "#include <stdio.h>"}
{"text": "Pulangan benar jika ada subarray arr [] dengan jumlah yang sama dengan 'jumlah' sebaliknya mengembalikan palsu. Juga, mencetak hasilnya", "code": "int subArraySum ( int arr [ ] , int n , int sum ) {"}
{"text": "Inisialisasi curr_sum sebagai nilai elemen pertama dan titik permulaan sebagai 0", "code": "int curr_sum = arr [ 0 ] , start = 0 , i ;"}
{"text": "Tambahkan elemen satu demi satu ke curr_sum dan jika curr_sum melebihi jumlah, kemudian keluarkan elemen permulaan", "code": "for ( i = 1 ; i <= n ; i ++ ) {"}
{"text": "Sekiranya curr_sum melebihi jumlah, keluarkan elemen permulaan", "code": "while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; }"}
{"text": "Sekiranya curr_sum menjadi sama dengan jumlah, maka kembali benar", "code": "if ( curr_sum == sum ) { printf ( \" Sum ▁ found ▁ between ▁ indexes ▁ % d ▁ and ▁ % d \" , start , i - 1 ) ; return 1 ; }"}
{"text": "Tambahkan elemen ini ke curr_sum", "code": "if ( i < n ) curr_sum = curr_sum + arr [ i ] ; }"}
{"text": "Sekiranya kita sampai di sini, maka tidak ada subarray", "code": "printf ( \" No ▁ subarray ▁ found \" ) ; return 0 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; subArraySum ( arr , n , sum ) ; return 0 ; }"}
{"text": "pulangan benar jika terdapat triplet dengan jumlah yang sama dengan 'jumlah' yang ada dalam []. Juga, mencetak triplet", "code": "bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ;"}
{"text": "Betulkan elemen pertama sebagai [i]", "code": "for ( int i = 0 ; i < arr_size - 2 ; i ++ ) {"}
{"text": "Betulkan elemen kedua sebagai [j]", "code": "for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) {"}
{"text": "Sekarang cari nombor ketiga", "code": "for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { printf ( \" Triplet ▁ is ▁ % d , ▁ % d , ▁ % d \" , A [ i ] , A [ j ] , A [ k ] ) ; return true ; } } } }"}
{"text": "Sekiranya kita sampai di sini, maka tiada triplet dijumpai", "code": "return false ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; find3Numbers ( A , arr_size , sum ) ; return 0 ; }"}
{"text": "C pelaksanaan pendekatan", "code": "#include <stdio.h>"}
{"text": "Linearly cari x dalam arr []. Sekiranya x hadir maka kembalikan indeks, jika tidak, pulangan - 1", "code": "int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return -1 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 10 , 30 , 15 } ; int x = 30 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d ▁ is ▁ present ▁ at ▁ index ▁ % d \" , x , search ( arr , n , x ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk melaksanakan carian binari rekursif", "code": "#include <stdio.h>"}
{"text": "Fungsi carian binari rekursif. Ia mengembalikan lokasi x dalam array yang diberikan [l. . r] hadir, jika tidak - 1", "code": "int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ;"}
{"text": "Sekiranya elemen hadir di tengah -tengahnya sendiri", "code": "if ( arr [ mid ] == x ) return mid ;"}
{"text": "Sekiranya elemen lebih kecil daripada pertengahan, maka ia hanya boleh hadir di subarray kiri", "code": "if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ;"}
{"text": "Lain elemen hanya boleh hadir di subarray kanan", "code": "return binarySearch ( arr , mid + 1 , r , x ) ; }"}
{"text": "Kami sampai di sini apabila elemen tidak hadir dalam pelbagai", "code": "return -1 ; }"}
{"text": "Kaedah pemacu untuk diuji di atas", "code": "int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ) : printf ( \" Element ▁ is ▁ present ▁ at ▁ index ▁ % d \" , result ) ; return 0 ; }"}
{"text": "Program c untuk melaksanakan carian binari berulang", "code": "#include <stdio.h>"}
{"text": "Fungsi carian binari berulang. Ia mengembalikan lokasi x dalam array yang diberikan [l. . r] jika hadir, jika tidak - 1", "code": "int binarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = l + ( r - l ) / 2 ;"}
{"text": "Periksa sama ada x hadir pada pertengahan", "code": "if ( arr [ m ] == x ) return m ;"}
{"text": "Jika x lebih besar, abaikan separuh kiri", "code": "if ( arr [ m ] < x ) l = m + 1 ;"}
{"text": "Sekiranya x lebih kecil, abaikan separuh kanan", "code": "else r = m - 1 ; }"}
{"text": "Sekiranya kita sampai di sini, maka elemen tidak hadir", "code": "return -1 ; }"}
{"text": "Kaedah pemacu untuk diuji di atas", "code": "int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( \" Element ▁ is ▁ not ▁ present \" \" ▁ in ▁ array \" ) : printf ( \" Element ▁ is ▁ present ▁ at ▁ \" \" index ▁ % d \" , result ) ; return 0 ; }"}
{"text": "Program C untuk melaksanakan carian interpolasi dengan rekursi", "code": "#include <stdio.h>"}
{"text": "Jika x hadir dalam arr [0 .. n - 1], kemudian mengembalikan indeksnya, lain kembali - 1.", "code": "int interpolationSearch ( int arr [ ] , int lo , int hi , int x ) { int pos ;"}
{"text": "Oleh kerana array disusun, elemen yang terdapat dalam array mesti berada dalam julat yang ditakrifkan oleh sudut", "code": "if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) {"}
{"text": "Meneliti kedudukan dengan menjaga pengedaran seragam dalam fikiran.", "code": "pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ;"}
{"text": "Keadaan sasaran yang dijumpai", "code": "if ( arr [ pos ] == x ) return pos ;"}
{"text": "Sekiranya x lebih besar, x berada dalam pelbagai sub kanan", "code": "if ( arr [ pos ] < x ) return interpolationSearch ( arr , pos + 1 , hi , x ) ;"}
{"text": "Sekiranya x lebih kecil, x berada di sub pelbagai kiri", "code": "if ( arr [ pos ] > x ) return interpolationSearch ( arr , lo , pos - 1 , x ) ; } return -1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Pelbagai item di mana carian akan dijalankan.", "code": "int arr [ ] = { 10 , 12 , 13 , 16 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 33 , 35 , 42 , 47 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Elemen yang akan dicari", "code": "int x = 18 ; int index = interpolationSearch ( arr , 0 , n - 1 , x ) ;"}
{"text": "Sekiranya elemen dijumpai", "code": "if ( index != -1 ) printf ( \" Element ▁ found ▁ at ▁ index ▁ % d \" , index ) ; else printf ( \" Element ▁ not ▁ found . \" ) ; return 0 ; }"}
{"text": "Program c untuk jenis gabungan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Menggabungkan dua subarray ARR []. Subarray pertama adalah arr [l. . m] subarray kedua adalah arr [m + 1. r]", "code": "void merge ( int arr [ ] , int l , int m , int r ) { int i , j , k ;"}
{"text": "Cari saiz dua subarray yang akan digabungkan", "code": "int n1 = m - l + 1 ; int n2 = r - m ;"}
{"text": "Buat tatasusunan temp", "code": "int L [ n1 ] , R [ n2 ] ;"}
{"text": "Salin data ke Temp Arrays L [] dan R []", "code": "for ( i = 0 ; i < n1 ; i ++ ) L [ i ] = arr [ l + i ] ; for ( j = 0 ; j < n2 ; j ++ ) R [ j ] = arr [ m + 1 + j ] ;"}
{"text": "Gabungkan Temp Array Indeks Awal Subarray Pertama dan Kedua", "code": "i = 0 ; j = 0 ;"}
{"text": "Indeks awal subarray yang digabungkan", "code": "k = l ; while ( i < n1 && j < n2 ) { if ( L [ i ] <= R [ j ] ) { arr [ k ] = L [ i ] ; i ++ ; } else { arr [ k ] = R [ j ] ; j ++ ; } k ++ ; }"}
{"text": "Salin unsur -unsur L [], jika ada", "code": "while ( i < n1 ) { arr [ k ] = L [ i ] ; i ++ ; k ++ ; }"}
{"text": "Salin unsur -unsur R [], jika ada", "code": "while ( j < n2 ) { arr [ k ] = R [ j ] ; j ++ ; k ++ ; } }"}
{"text": "L adalah untuk indeks kiri dan r adalah indeks kanan sub -pelbagai ARR yang akan disusun", "code": "void mergeSort ( int arr [ ] , int l , int r ) { if ( l < r ) {"}
{"text": "Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H besar", "code": "int m = l + ( r - l ) / 2 ;"}
{"text": "Susun bahagian pertama dan kedua", "code": "mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ;"}
{"text": "Gabungkan bahagian yang disusun", "code": "merge ( arr , l , m , r ) ; } }"}
{"text": "Berfungsi untuk mencetak array", "code": "void printArray ( int A [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , A [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given ▁ array ▁ is ▁ STRNEWLINE \" ) ; printArray ( arr , arr_size ) ; mergeSort ( arr , 0 , arr_size - 1 ) ; printf ( \" Sorted array is \" printArray ( arr , arr_size ) ; return 0 ; }"}
{"text": "Pelaksanaan berulang dengan cepat", "code": "#include <stdio.h>"}
{"text": "Fungsi utiliti untuk menukar dua elemen", "code": "void swap ( int * a , int * b ) { int t = * a ; * a = * b ; * b = t ; }"}
{"text": "Fungsi ini sama dalam kedua -dua berulang dan rekursif", "code": "int partition ( int arr [ ] , int l , int h ) { int x = arr [ h ] ; int i = ( l - 1 ) ; for ( int j = l ; j <= h - 1 ; j ++ ) { if ( arr [ j ] <= x ) { i ++ ; swap ( & arr [ i ] , & arr [ j ] ) ; } } swap ( & arr [ i + 1 ] , & arr [ h ] ) ; return ( i + 1 ) ; }"}
{"text": "A [] -> array yang akan disusun, l -> indeks permulaan, h -> indeks akhir", "code": "void quickSortIterative ( int arr [ ] , int l , int h ) {"}
{"text": "Buat timbunan tambahan", "code": "int stack [ h - l + 1 ] ;"}
{"text": "Memulakan bahagian atas timbunan", "code": "int top = -1 ;"}
{"text": "Tolak nilai awal L dan H ke timbunan", "code": "stack [ ++ top ] = l ; stack [ ++ top ] = h ;"}
{"text": "Terus muncul dari timbunan sementara tidak kosong", "code": "while ( top >= 0 ) {"}
{"text": "Pop h dan l", "code": "h = stack [ top -- ] ; l = stack [ top -- ] ;"}
{"text": "Tetapkan elemen pivot pada kedudukan yang betul dalam pelbagai disusun", "code": "int p = partition ( arr , l , h ) ;"}
{"text": "Sekiranya terdapat unsur -unsur di sebelah kiri pivot, maka tekan sebelah kiri ke timbunan", "code": "if ( p - 1 > l ) { stack [ ++ top ] = l ; stack [ ++ top ] = p - 1 ; }"}
{"text": "Sekiranya terdapat unsur -unsur di sebelah kanan pivot, maka tekan sebelah kanan untuk menyusun", "code": "if ( p + 1 < h ) { stack [ ++ top ] = p + 1 ; stack [ ++ top ] = h ; } } }"}
{"text": "Fungsi utiliti untuk mencetak kandungan arr", "code": "void printArr ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 4 , 3 , 5 , 2 , 1 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( * arr ) ;"}
{"text": "Fungsi panggilan", "code": "quickSortIterative ( arr , 0 , n - 1 ) ; printArr ( arr , n ) ; return 0 ; }"}
{"text": "Program C untuk masalah pemilihan aktiviti. Pelaksanaan berikut mengandaikan bahawa aktiviti telah disusun mengikut masa penamat mereka", "code": "#include <stdio.h>"}
{"text": "Mencetak set maksimum aktiviti yang boleh dilakukan oleh satu orang, satu demi satu. n -> Jumlah aktiviti s [] -> array yang mengandungi masa mula semua aktiviti f [] -> array yang mengandungi masa selesai semua aktiviti", "code": "void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; printf ( \" Following ▁ activities ▁ are ▁ selected ▁ n \" ) ;"}
{"text": "Aktiviti pertama selalu dipilih", "code": "i = 0 ; printf ( \" % d ▁ \" , i ) ;"}
{"text": "Pertimbangkan sisa aktiviti", "code": "for ( j = 1 ; j < n ; j ++ ) {"}
{"text": "Sekiranya aktiviti ini mempunyai masa yang lebih besar daripada atau sama dengan masa penamat aktiviti yang dipilih sebelumnya, maka pilihnya", "code": "if ( s [ j ] >= f [ i ] ) { printf ( \" % d ▁ \" , j ) ; i = j ; } } }"}
{"text": "program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int s [ ] = { 1 , 3 , 0 , 5 , 8 , 5 } ; int f [ ] = { 2 , 4 , 6 , 7 , 9 , 9 } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; printMaxActivities ( s , f , n ) ; return 0 ; }"}
{"text": "Program C untuk pengekodan Huffman yang cekap untuk input yang disusun", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Pemalar ini dapat dielakkan dengan mengira ketinggian pokok Huffman secara eksplisit", "code": "#define MAX_TREE_HT  100"}
{"text": "Nod pokok Huffman", "code": "struct QueueNode { char data ; unsigned freq ; struct QueueNode * left , * right ; } ;"}
{"text": "Struktur untuk barisan: Koleksi nod pokok Huffman (Orqueuenodes)", "code": "struct Queue { int front , rear ; int capacity ; struct QueueNode * * array ; } ;"}
{"text": "Fungsi utiliti untuk membuat queuenode baru", "code": "struct QueueNode * newNode ( char data , unsigned freq ) { struct QueueNode * temp = ( struct QueueNode * ) malloc ( sizeof ( struct QueueNode ) ) ; temp -> left = temp -> right = NULL ; temp -> data = data ; temp -> freq = freq ; return temp ; }"}
{"text": "Fungsi utiliti untuk mencipta giliran kapasiti yang diberikan", "code": "struct Queue * createQueue ( int capacity ) { struct Queue * queue = ( struct Queue * ) malloc ( sizeof ( struct Queue ) ) ; queue -> front = queue -> rear = -1 ; queue -> capacity = capacity ; queue -> array = ( struct QueueNode * * ) malloc ( queue -> capacity * sizeof ( struct QueueNode * ) ) ; return queue ; }"}
{"text": "Fungsi utiliti untuk memeriksa sama ada saiz barisan yang diberikan ialah 1", "code": "int isSizeOne ( struct Queue * queue ) { return queue -> front == queue -> rear && queue -> front != -1 ; }"}
{"text": "Fungsi utiliti untuk memeriksa sama ada giliran yang diberikan kosong", "code": "int isEmpty ( struct Queue * queue ) { return queue -> front == -1 ; }"}
{"text": "Fungsi utiliti untuk memeriksa sama ada giliran yang diberikan penuh", "code": "int isFull ( struct Queue * queue ) { return queue -> rear == queue -> capacity - 1 ; }"}
{"text": "Fungsi utiliti untuk menambah item ke barisan", "code": "void enQueue ( struct Queue * queue , struct QueueNode * item ) { if ( isFull ( queue ) ) return ; queue -> array [ ++ queue -> rear ] = item ; if ( queue -> front == -1 ) ++ queue -> front ; }"}
{"text": "Fungsi utiliti untuk mengeluarkan item dari barisan", "code": "struct QueueNode * deQueue ( struct Queue * queue ) { if ( isEmpty ( queue ) ) return NULL ; struct QueueNode * temp = queue -> array [ queue -> front ] ; if ( queue -> front == queue"}
{"text": "Sekiranya terdapat hanya satu item dalam barisan", "code": "- > rear ) queue -> front = queue -> rear = -1 ; else ++ queue -> front ; return temp ; }"}
{"text": "Fungsi utiliti untuk mendapatkan dari barisan", "code": "struct QueueNode * getFront ( struct Queue * queue ) { if ( isEmpty ( queue ) ) return NULL ; return queue -> array [ queue -> front ] ; }"}
{"text": "Fungsi untuk mendapatkan item minimum dari dua beratur", "code": "struct QueueNode * findMin ( struct Queue * firstQueue , struct Queue * secondQueue ) {"}
{"text": "Langkah 3. A: Sekiranya barisan pertama kosong, dequeue dari barisan kedua", "code": "if ( isEmpty ( firstQueue ) ) return deQueue ( secondQueue ) ;"}
{"text": "Langkah 3. B: Sekiranya barisan kedua kosong, dequeue dari barisan pertama", "code": "if ( isEmpty ( secondQueue ) ) return deQueue ( firstQueue ) ;"}
{"text": "Langkah 3. C: Selain itu, bandingkan bahagian depan dua beratur dan minimum dequeue", "code": "if ( getFront ( firstQueue ) -> freq < getFront ( secondQueue ) -> freq ) return deQueue ( firstQueue ) ; return deQueue ( secondQueue ) ; }"}
{"text": "Fungsi utiliti untuk memeriksa sama ada nod ini adalah daun", "code": "int isLeaf ( struct QueueNode * root ) { return ! ( root -> left ) && ! ( root -> right ) ; }"}
{"text": "Fungsi utiliti untuk mencetak pelbagai saiz n", "code": "void printArr ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) printf ( \" % d \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Fungsi utama yang membina pokok Huffman", "code": "struct QueueNode * buildHuffmanTree ( char data [ ] , int freq [ ] , int size ) { struct QueueNode * left , * right , * top ;"}
{"text": "Langkah 1: Buat dua barisan kosong", "code": "struct Queue * firstQueue = createQueue ( size ) ; struct Queue * secondQueue = createQueue ( size ) ;"}
{"text": "Langkah 2: Buat nod daun untuk setiap watak yang unik dan enqueue ke barisan pertama dalam urutan kekerapan yang tidak menurun. Pada mulanya giliran kedua kosong", "code": "for ( int i = 0 ; i < size ; ++ i ) enQueue ( firstQueue , newNode ( data [ i ] , freq [ i ] ) ) ;"}
{"text": "Jalankan semasa beratur mengandungi lebih daripada satu nod. Akhirnya, barisan pertama akan kosong dan giliran kedua hanya mengandungi satu nod", "code": "while ( ! ( isEmpty ( firstQueue ) && isSizeOne ( secondQueue ) ) ) {"}
{"text": "Langkah 3: Meninggalkan dua nod dengan kekerapan minimum dengan memeriksa bahagian depan kedua -dua beratur", "code": "left = findMin ( firstQueue , secondQueue ) ; right = findMin ( firstQueue , secondQueue ) ;"}
{"text": "Langkah 4: Buat nod dalaman baru dengan kekerapan sama dengan jumlah frekuensi dua nod. Enqueue nod ini ke barisan kedua.", "code": "top = newNode ( ' $ ' , left -> freq + right -> freq ) ; top -> left = left ; top -> right = right ; enQueue ( secondQueue , top ) ; } return deQueue ( secondQueue ) ; }"}
{"text": "Cetak kod Huffman dari akar pokok Huffman. Ia menggunakan arr [] untuk menyimpan kod", "code": "void printCodes ( struct QueueNode * root , int arr [ ] , int top ) {"}
{"text": "Berikan 0 ke pinggir kiri dan berulang", "code": "if ( root -> left ) { arr [ top ] = 0 ; printCodes ( root -> left , arr , top + 1 ) ; }"}
{"text": "Berikan 1 ke tepi kanan dan berulang", "code": "if ( root -> right ) { arr [ top ] = 1 ; printCodes ( root -> right , arr , top + 1 ) ; }"}
{"text": "Jika ini adalah nod daun, maka ia mengandungi salah satu aksara input, cetak watak dan kodnya dari arr []", "code": "if ( isLeaf ( root ) ) { printf ( \" % c : ▁ \" , root -> data ) ; printArr ( arr , top ) ; } }"}
{"text": "Fungsi utama yang membina pokok Huffman dan kod cetak dengan melintasi pokok Huffman yang dibina", "code": "void HuffmanCodes ( char data [ ] , int freq [ ] , int size ) {"}
{"text": "Membina pokok Huffman", "code": "struct QueueNode * root = buildHuffmanTree ( data , freq , size ) ;"}
{"text": "Cetak kod Huffman menggunakan pokok Huffman yang dibina di atas", "code": "int arr [ MAX_TREE_HT ] , top = 0 ; printCodes ( root , arr , top ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char arr [ ] = { ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' } ; int freq [ ] = { 5 , 9 , 12 , 13 , 16 , 45 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; HuffmanCodes ( arr , freq , size ) ; return 0 ; }"}
{"text": "Pelaksanaan masalah LCS yang rekursif naif", "code": "#include <bits/stdc++.h> NEW_LINE int max ( int a , int b ) ;"}
{"text": "Mengembalikan panjang LCS untuk x [0 .. m - 1], y [0 .. n - 1]", "code": "int lcs ( char * X , char * Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum 2 bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char X [ ] = \" AGGTAB \" ; char Y [ ] = \" GXTXAYB \" ; int m = strlen ( X ) ; int n = strlen ( Y ) ; printf ( \" Length ▁ of ▁ LCS ▁ is ▁ % d \" , lcs ( X , Y , m , n ) ) ; return 0 ; }"}
{"text": "Pengaturcaraan Dinamik C Pelaksanaan Masalah LCS", "code": "#include <bits/stdc++.h> NEW_LINE int max ( int a , int b ) ;"}
{"text": "Mengembalikan panjang LCS untuk x [0 .. m - 1], y [0 .. n - 1]", "code": "int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; int i , j ;"}
{"text": "Langkah -langkah berikut membina l [m + 1] [n + 1] dalam fesyen bawah. Perhatikan bahawa l [i] [j] mengandungi panjang LCs x [0 .. i - 1] dan y [0. .. J - 1]", "code": "for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } }"}
{"text": "L [M] [n] mengandungi panjang LCS untuk x [0 .. n - 1] dan y [0 .. m - 1]", "code": "return L [ m ] [ n ] ; }"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum 2 bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char X [ ] = \" AGGTAB \" ; char Y [ ] = \" GXTXAYB \" ; int m = strlen ( X ) ; int n = strlen ( Y ) ; printf ( \" Length ▁ of ▁ LCS ▁ is ▁ % d \" , lcs ( X , Y , m , n ) ) ; return 0 ; }"}
{"text": "Pelaksanaan rekursif naif MCP (laluan kos minimum)", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE int min ( int x , int y , int z ) ;"}
{"text": "Fungsi utiliti yang mengembalikan minimum 3 bilangan bulat", "code": "int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; }"}
{"text": "Mengembalikan kos laluan kos minimum dari (0, 0) hingga (m, n) dalam tikar [r] [c]", "code": "int minCost ( int cost [ R ] [ C ] , int m , int n ) { if ( n < 0 m < 0 ) return INT_MAX ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; printf ( \" ▁ % d ▁ \" , minCost ( cost , 2 , 2 ) ) ; return 0 ; }"}
{"text": "Pelaksanaan pengaturcaraan dinamik masalah MCP", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE int min ( int x , int y , int z ) ; int minCost ( int cost [ R ] [ C ] , int m , int n ) { int i , j ;"}
{"text": "Daripada baris berikut, kita boleh menggunakan Int Tc [M + 1] [n + 1] atau secara dinamik memperuntukkan memori untuk menjimatkan ruang. Baris berikut digunakan untuk memastikan program ini mudah dan menjadikannya berfungsi pada semua penyusun.", "code": "int tc [ R ] [ C ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;"}
{"text": "Mulakan lajur pertama jumlah kos (TC)", "code": "for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ;"}
{"text": "Memulakan baris pertama tc array", "code": "for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ;"}
{"text": "Bina sisa array TC", "code": "for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; }"}
{"text": "Fungsi utiliti yang mengembalikan minimum 3 bilangan bulat", "code": "int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; printf ( \" ▁ % d ▁ \" , minCost ( cost , 2 , 2 ) ) ; return 0 ; }"}
{"text": "Pelaksanaan rekursif naif masalah 0 - 1 Knapsack", "code": "#include <stdio.h>"}
{"text": "Fungsi utiliti yang mengembalikan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Mengembalikan nilai maksimum yang boleh dimasukkan ke dalam kapasiti kapasiti w", "code": "int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {"}
{"text": "Kes asas", "code": "if ( n == 0 W == 0 ) return 0 ;"}
{"text": "Sekiranya berat item nth lebih daripada kapasiti knapsack w, maka item ini tidak dapat dimasukkan dalam penyelesaian yang optimum", "code": "if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ;"}
{"text": "Kembalikan maksimum dua kes: (1) item nth termasuk (2) tidak termasuk", "code": "else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printf ( \" % d \" , knapSack ( W , wt , val , n ) ) ; return 0 ; }"}
{"text": "Penyelesaian berasaskan pengaturcaraan yang dinamik untuk masalah 0 - 1 Knapsack", "code": "#include <stdio.h>"}
{"text": "Fungsi utiliti yang mengembalikan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Mengembalikan nilai maksimum yang boleh dimasukkan ke dalam kapasiti kapasiti w", "code": "int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ;"}
{"text": "Bina Jadual K [] [] dengan cara bawah", "code": "for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printf ( \" % d \" , knapSack ( W , wt , val , n ) ) ; return 0 ; }"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Berfungsi untuk mendapatkan bilangan percubaan minimum yang diperlukan dalam kes terburuk dengan telur n dan l lantai", "code": "int eggDrop ( int n , int k ) {"}
{"text": "Sekiranya tiada lantai, maka tiada ujian diperlukan. Atau jika terdapat satu lantai, satu percubaan diperlukan.", "code": "if ( k == 1 k == 0 ) return k ;"}
{"text": "Kami memerlukan ujian k untuk satu lantai telur dan k", "code": "if ( n == 1 ) return k ; int min = INT_MAX , x , res ;"}
{"text": "Pertimbangkan semua kotoran dari lantai 1 ke lantai kth dan kembalikan minimum nilai -nilai ini ditambah 1.", "code": "for ( x = 1 ; x <= k ; x ++ ) { res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }"}
{"text": "Program Pemandu untuk Menguji ProntDups", "code": "int main ( ) { int n = 2 , k = 10 ; printf ( \" nMinimum ▁ number ▁ of ▁ trials ▁ in ▁ \" \" worst ▁ case ▁ with ▁ % d ▁ eggs ▁ and ▁ \" \" % d ▁ floors ▁ is ▁ % d ▁ STRNEWLINE \" , n , k , eggDrop ( n , k ) ) ; return 0 ; }"}
{"text": "C Program pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat", "code": "int max ( int x , int y ) { return ( x > y ) ? x : y ; }"}
{"text": "Mengembalikan panjang Palindromik Terpanjang di SEQ", "code": "int lps ( char * seq , int i , int j ) {"}
{"text": "Kes Base 1: Sekiranya hanya ada 1 watak", "code": "if ( i == j ) return 1 ;"}
{"text": "Kes Base 2: Sekiranya terdapat hanya 2 aksara dan kedua -duanya sama", "code": "if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ;"}
{"text": "Sekiranya watak pertama dan terakhir sepadan", "code": "if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ;"}
{"text": "Sekiranya watak pertama dan terakhir tidak sepadan", "code": "return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char seq [ ] = \" GEEKSFORGEEKS \" ; int n = strlen ( seq ) ; printf ( \" The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d \" , lps ( seq , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Penyelesaian pengaturcaraan yang dinamik untuk masalah bungkus perkataan", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #define INF  INT_MAX"}
{"text": "Fungsi utiliti untuk mencetak penyelesaian", "code": "int printSolution ( int p [ ] , int n ) ; int printSolution ( int p [ ] , int n ) { int k ; if ( p [ n ] == 1 ) k = 1 ; else k = printSolution ( p , p [ n ] - 1 ) + 1 ; printf ( \" Line ▁ number ▁ % d : ▁ From ▁ word ▁ no . ▁ % d ▁ to ▁ % d ▁ STRNEWLINE \" , k , p [ n ] , n ) ; return k ; }"}
{"text": "L [] mewakili panjang perkataan yang berbeza dalam urutan input. Sebagai contoh, l [] = {3, 2, 2, 5} adalah untuk ayat seperti \"aaa u u u u ddddd\". n adalah saiz l [] dan m adalah lebar garis (maksimum no aksara yang boleh muat dalam garis)", "code": "void solveWordWrap ( int l [ ] , int n , int M ) {"}
{"text": "Untuk kesederhanaan, 1 ruang tambahan digunakan dalam semua tatasusunan di bawah [i] [j] akan mempunyai bilangan ruang tambahan jika kata -kata dari saya ke j dimasukkan ke dalam satu baris", "code": "int extras [ n + 1 ] [ n + 1 ] ;"}
{"text": "LC [i] [j] akan mempunyai kos garis yang mempunyai kata -kata dari saya ke j", "code": "int lc [ n + 1 ] [ n + 1 ] ;"}
{"text": "C [i] akan mempunyai jumlah kos susunan kata yang optimum dari 1 hingga i", "code": "int c [ n + 1 ] ;"}
{"text": "P [] digunakan untuk mencetak penyelesaian.", "code": "int p [ n + 1 ] ; int i , j ;"}
{"text": "Kirakan ruang tambahan dalam satu baris. Nilai tambahan [i] [j] menunjukkan ruang tambahan jika perkataan dari nombor perkataan i ke j diletakkan dalam satu baris", "code": "for ( i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; }"}
{"text": "Kirakan kos garis yang sepadan dengan ruang tambahan yang dikira di atas. Nilai lc [i] [j] menunjukkan kos meletakkan kata -kata dari nombor perkataan i ke j dalam satu baris", "code": "for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = INF ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } }"}
{"text": "Kirakan kos minimum dan cari susunan kos minimum. Nilai C [j] menunjukkan kos yang dioptimumkan untuk mengatur perkataan dari nombor perkataan 1 hingga j.", "code": "c [ 0 ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { c [ j ] = INF ; for ( i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != INF && lc [ i ] [ j ] != INF && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int l [ ] = { 3 , 2 , 2 , 5 } ; int n = sizeof ( l ) / sizeof ( l [ 0 ] ) ; int M = 6 ; solveWordWrap ( l , n , M ) ; return 0 ; }"}
{"text": "Pelaksanaan rekursi naif masalah pokok carian binari yang optimum", "code": "#include <stdio.h> NEW_LINE #include <limits.h>"}
{"text": "Fungsi utiliti untuk mendapatkan jumlah unsur array freq [i] ke freq [j]", "code": "int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; }"}
{"text": "Fungsi rekursif untuk mengira kos pokok carian binari yang optimum", "code": "int optCost ( int freq [ ] , int i , int j ) {"}
{"text": "Kes asas tiada elemen dalam subarray ini", "code": "if ( j < i ) return 0 ;"}
{"text": "Satu elemen dalam subarray ini", "code": "if ( j == i ) return freq [ i ] ;"}
{"text": "Dapatkan jumlah freq [i], freq [i + 1], ... freq [j]", "code": "int fsum = sum ( freq , i , j ) ;"}
{"text": "Mulakan nilai minimum", "code": "int min = INT_MAX ;"}
{"text": "Satu demi satu menganggap semua elemen sebagai akar dan rekursif mencari kos BST, bandingkan kos dengan min dan kemas kini min jika diperlukan", "code": "for ( int r = i ; r <= j ; ++ r ) { int cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; }"}
{"text": "Pulangan nilai minimum", "code": "return min + fsum ; }"}
{"text": "Fungsi utama yang mengira kos minimum pokok carian binari. Ia terutamanya menggunakan OptCost () untuk mencari kos yang optimum.", "code": "int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) {"}
{"text": "Di sini kunci array [] diandaikan disusun dalam peningkatan urutan. Jika kekunci [] tidak disusun, kemudian tambahkan kod untuk menyusun kekunci, dan menyusun semula Freq [] dengan sewajarnya.", "code": "return optCost ( freq , 0 , n - 1 ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; printf ( \" Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ % d ▁ \" , optimalSearchTree ( keys , freq , n ) ) ; return 0 ; }"}
{"text": "Kod pengaturcaraan dinamik untuk masalah pokok carian binari yang optimum", "code": "#include <stdio.h> NEW_LINE #include <limits.h>"}
{"text": "Fungsi utiliti untuk mendapatkan jumlah unsur array freq [i] ke freq [j]", "code": "int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; }"}
{"text": "Fungsi berasaskan pengaturcaraan dinamik yang mengira kos minimum pokok carian binari.", "code": "int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) {"}
{"text": "Buat matriks 2D tambahan untuk menyimpan hasil subproblem", "code": "int cost [ n ] [ n ] ;"}
{"text": "Untuk satu kunci, kos adalah sama dengan kekerapan kunci", "code": "for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = freq [ i ] ;"}
{"text": "Sekarang kita perlu mempertimbangkan rantai panjang 2, 3, .... L adalah panjang rantai.", "code": "for ( int L = 2 ; L <= n ; L ++ ) {"}
{"text": "Saya adalah nombor baris dalam kos [] []", "code": "for ( int i = 0 ; i <= n - L + 1 ; i ++ ) {"}
{"text": "Dapatkan nombor lajur j dari baris nombor i dan panjang rantai l", "code": "int j = i + L - 1 ; cost [ i ] [ j ] = INT_MAX ;"}
{"text": "Cuba buat semua kunci dalam kekunci selang [i. . j] sebagai akar", "code": "for ( int r = i ; r <= j ; r ++ ) {"}
{"text": "c = kos apabila kunci [r] menjadi akar subtree ini", "code": "int c = ( ( r > i ) ? cost [ i ] [ r - 1 ] : 0 ) + ( ( r < j ) ? cost [ r + 1 ] [ j ] : 0 ) + sum ( freq , i , j ) ; if ( c < cost [ i ] [ j ] ) cost [ i ] [ j ] = c ; } } } return cost [ 0 ] [ n - 1 ] ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; printf ( \" Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ % d ▁ \" , optimalSearchTree ( keys , freq , n ) ) ; return 0 ; }"}
{"text": "Pelaksanaan rekursi naif masalah set bebas terbesar", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Fungsi utiliti untuk mencari maksimum dua bilangan bulat", "code": "int max ( int x , int y ) { return ( x > y ) ? x : y ; }"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Fungsi mengembalikan saiz set bebas terbesar dalam pokok binari yang diberikan", "code": "int LISS ( struct node * root ) { if ( root == NULL ) return 0 ;"}
{"text": "Saiz cacing tidak termasuk nod semasa", "code": "int size_excl = LISS ( root -> left ) + LISS ( root -> right ) ;"}
{"text": "Hitung saiz termasuk nod semasa", "code": "int size_incl = 1 ; if ( root -> left ) size_incl += LISS ( root -> left -> left ) + LISS ( root -> left -> right ) ; if ( root -> right ) size_incl += LISS ( root -> right -> left ) + LISS ( root -> right -> right ) ;"}
{"text": "Kembalikan maksimum dua saiz", "code": "return max ( size_incl , size_excl ) ; }"}
{"text": "Fungsi utiliti untuk membuat nod", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Mari kita buat pokok yang diberikan dalam rajah di atas", "code": "struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printf ( \" Size ▁ of ▁ the ▁ Largest ▁ Independent ▁ Set ▁ is ▁ % d ▁ \" , LISS ( root ) ) ; return 0 ; }"}
{"text": "Program C dioptimumkan ruang untuk mengira bilangan bilangan yang mungkin panjang", "code": "#include <stdio.h>"}
{"text": "Kembalikan kiraan semua kemungkinan panjang N dalam papan kekunci angka yang diberikan", "code": "int getCount ( char keypad [ ] [ 3 ] , int n ) { if ( keypad == NULL n <= 0 ) return 0 ; if ( n == 1 ) return 10 ;"}
{"text": "Ganjil [i], walaupun [i] array mewakili kiraan nombor bermula dengan digit i untuk apa -apa panjang j", "code": "int odd [ 10 ] , even [ 10 ] ; int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ )"}
{"text": "untuk j = 1", "code": "odd [ i ] = 1 ;"}
{"text": "Pengiraan bawah dari j = 2 hingga n", "code": "for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ;"}
{"text": "Di sini kita secara eksplisit menulis baris untuk setiap nombor 0 hingga 9. Tetapi ia sentiasa boleh ditulis sebagai DFS pada 4 x3 grid menggunakan baris, gerakan array lajur", "code": "if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } }"}
{"text": "Dapatkan kiraan semua kemungkinan bilangan panjang \"n\" bermula dengan digit 0, 1, 2, ..., 9", "code": "totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char keypad [ 4 ] [ 3 ] = { { '1' , '2' , '3' } , { '4' , '5' , '6' } , { '7' , '8' , '9' } , { ' * ' , '0' , ' # ' } } ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 1 , getCount ( keypad , 1 ) ) ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 2 , getCount ( keypad , 2 ) ) ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 3 , getCount ( keypad , 3 ) ) ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 4 , getCount ( keypad , 4 ) ) ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 5 , getCount ( keypad , 5 ) ) ; return 0 ; }"}
{"text": "Program berasaskan pengaturcaraan dinamik untuk masalah penutup puncak untuk pokok binari", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Fungsi utiliti untuk mencari min dua bilangan bulat", "code": "int min ( int x , int y ) { return ( x < y ) ? x : y ; }"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; int vc ; struct node * left , * right ; } ;"}
{"text": "Fungsi berasaskan memoisasi yang mengembalikan saiz penutup puncak minimum.", "code": "int vCover ( struct node * root ) {"}
{"text": "Saiz penutup puncak minimum adalah sifar jika pokok kosong atau hanya ada satu nod", "code": "if ( root == NULL ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return 0 ;"}
{"text": "Jika penutup vertex untuk nod ini sudah dinilai, maka kembalikannya untuk menyelamatkan rekomputasi subproblem yang sama sekali lagi.", "code": "if ( root -> vc != 0 ) return root -> vc ;"}
{"text": "Hitung saiz penutup puncak apabila akar adalah sebahagian daripadanya", "code": "int size_incl = 1 + vCover ( root -> left ) + vCover ( root -> right ) ;"}
{"text": "Hitung saiz penutup puncak apabila akar bukan sebahagian daripadanya", "code": "int size_excl = 0 ; if ( root -> left ) size_excl += 1 + vCover ( root -> left -> left ) + vCover ( root -> left -> right ) ; if ( root -> right ) size_excl += 1 + vCover ( root -> right -> left ) + vCover ( root -> right -> right ) ;"}
{"text": "Minimum dua nilai adalah penutup puncak, simpan sebelum kembali", "code": "root -> vc = min ( size_incl , size_excl ) ; return root -> vc ; }"}
{"text": "Fungsi utiliti untuk membuat nod", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ;"}
{"text": "Tetapkan penutup puncak sebagai 0", "code": "temp -> vc = 0 ; return temp ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Mari kita buat pokok yang diberikan dalam rajah di atas", "code": "struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printf ( \" Size ▁ of ▁ the ▁ smallest ▁ vertex ▁ cover ▁ is ▁ % d ▁ \" , vCover ( root ) ) ; return 0 ; }"}
{"text": "Program C untuk mengira bilangan cara yang mungkin untuk skor tertentu dapat dicapai dalam permainan di mana langkah dapat memperoleh 3 atau 5 atau 10", "code": "#include <stdio.h>"}
{"text": "Mengembalikan bilangan cara untuk mencapai skor n", "code": "int count ( int n ) {"}
{"text": "Jadual [i] akan menyimpan kiraan penyelesaian untuk nilai i.", "code": "int table [ n + 1 ] , i ;"}
{"text": "Mulakan semua nilai jadual sebagai 0", "code": "memset ( table , 0 , sizeof ( table ) ) ;"}
{"text": "Kes asas (jika nilai yang diberikan ialah 0)", "code": "table [ 0 ] = 1 ;"}
{"text": "Satu demi satu mempertimbangkan diberikan 3 langkah dan mengemas kini nilai jadual [] selepas indeks lebih besar daripada atau sama dengan nilai langkah yang dipilih", "code": "for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }"}
{"text": "Program Pemandu", "code": "int main ( void ) { int n = 20 ; printf ( \" Count ▁ for ▁ % d ▁ is ▁ % d STRNEWLINE \" , n , count ( n ) ) ; n = 13 ; printf ( \" Count ▁ for ▁ % d ▁ is ▁ % d \" , n , count ( n ) ) ; return 0 ; }"}
{"text": "Program C untuk Algoritma Mencari Corak Naive", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ;"}
{"text": "Gelung untuk meluncur pat [] satu demi satu", "code": "for ( int i = 0 ; i <= N - M ; i ++ ) { int j ;"}
{"text": "Untuk indeks semasa I, periksa perlawanan corak", "code": "for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ;"}
{"text": "Jika Pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]", "code": "if ( j == M ) printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char txt [ ] = \" AABAACAADAABAAABAA \" ; char pat [ ] = \" AABA \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Berikut program adalah pelaksanaan algoritma Rabin Karp yang diberikan dalam Buku CLRS", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "D adalah bilangan aksara dalam abjad input", "code": "#define d  256"}
{"text": "Pat -> Corak Txt -> Teks Q -> Nombor Perdana", "code": "void search ( char pat [ ] , char txt [ ] , int q ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i , j ;"}
{"text": "nilai hash untuk corak", "code": "int p = 0 ;"}
{"text": "nilai hash untuk txt", "code": "int t = 0 ; int h = 1 ;"}
{"text": "Nilai H ialah \"pow (d, u, 1) % q\"", "code": "for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ;"}
{"text": "Kirakan nilai hash corak dan tetingkap teks pertama", "code": "for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; }"}
{"text": "Luncurkan corak ke atas teks satu demi satu", "code": "for ( i = 0 ; i <= N - M ; i ++ ) {"}
{"text": "Semak nilai hash tetingkap semasa teks dan corak. Sekiranya nilai hash sepadan maka hanya periksa aksara oleh satu", "code": "if ( p == t ) {"}
{"text": "Periksa watak satu demi satu", "code": "for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; }"}
{"text": "jika p == t dan pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]", "code": "if ( j == M ) printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; }"}
{"text": "Hitung nilai hash untuk tetingkap teks seterusnya: Keluarkan digit terkemuka, tambahkan digit trailing", "code": "if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ;"}
{"text": "Kita mungkin mendapat nilai negatif t, menukarnya kepada positif", "code": "if ( t < 0 ) t = ( t + q ) ; } } }"}
{"text": "Kod pemacu", "code": "int main ( ) { char txt [ ] = \" GEEKS ▁ FOR ▁ GEEKS \" ; char pat [ ] = \" GEEK \" ;"}
{"text": "Nombor perdana", "code": "int q = 101 ;"}
{"text": "panggilan fungsi", "code": "search ( pat , txt , q ) ; return 0 ; }"}
{"text": "Program C untuk algoritma mencari corak naif yang diubahsuai yang dioptimumkan untuk kes apabila semua watak corak berbeza", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Algorithn mencari Pettern yang diubahsuai yang dioptimumkan untuk kes -kes apabila semua watak corak berbeza", "code": "void search ( char pat [ ] , char txt [ ] ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i = 0 ; while ( i <= N - M ) { int j ;"}
{"text": "Untuk indeks semasa I, periksa perlawanan corak", "code": "for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ;"}
{"text": "Jika Pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]", "code": "if ( j == M ) { printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else"}
{"text": "luncurkan corak oleh j", "code": "i = i + j ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char txt [ ] = \" ABCEABCDABCEABCD \" ; char pat [ ] = \" ABCD \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Program C untuk Algoritma Mencari Corak Automata terhingga", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE int getNextState ( char * pat , int M , int state , int x ) {"}
{"text": "Sekiranya watak C sama dengan watak seterusnya dalam corak, maka hanya kenaikan keadaan", "code": "if ( state < M && x == pat [ state ] ) return state + 1 ;"}
{"text": "NS menyimpan hasil yang seterusnya", "code": "int ns , i ;"}
{"text": "NS akhirnya mengandungi awalan terpanjang yang juga akhiran dalam \"Pat [0.", "code": "for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] == x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) if ( pat [ i ] != pat [ state - ns + 1 + i ] ) break ; if ( i == ns - 1 ) return ns ; } } return 0 ; }"}
{"text": "Fungsi ini membina jadual TF yang mewakili 4 automata terhingga untuk corak yang diberikan", "code": "void computeTF ( char * pat , int M , int TF [ ] [ NO_OF_CHARS ] ) { int state , x ; for ( state = 0 ; state <= M ; ++ state ) for ( x = 0 ; x < NO_OF_CHARS ; ++ x ) TF [ state ] [ x ] = getNextState ( pat , M , state , x ) ; }"}
{"text": "Mencetak semua kejadian pat dalam txt", "code": "void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int TF [ M + 1 ] [ NO_OF_CHARS ] ; computeTF ( pat , M , TF ) ;"}
{"text": "Proses txt ke atas FA.", "code": "int i , state = 0 ; for ( i = 0 ; i < N ; i ++ ) { state = TF [ state ] [ txt [ i ] ] ; if ( state == M ) printf ( \" Pattern found at index % d \" , i - M + 1 ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char * txt = \" AABAACAADAABAAABAA \" ; char * pat = \" AABA \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Program C untuk Heuristik Bad Heuristik Boyer Moore String Algoritma", "code": "# include <limits.h> NEW_LINE # include <string.h> NEW_LINE # include <stdio.h> NEW_LINE # define NO_OF_CHARS  256"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Fungsi pra -proses untuk heuristik watak buruk Boyer Moore", "code": "void badCharHeuristic ( char * str , int size , int badchar [ NO_OF_CHARS ] ) { int i ;"}
{"text": "Memulakan semua kejadian sebagai - 1", "code": "for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) badchar [ i ] = -1 ;"}
{"text": "Isi nilai sebenar kejadian terakhir watak", "code": "for ( i = 0 ; i < size ; i ++ ) badchar [ ( int ) str [ i ] ] = i ; }"}
{"text": "Fungsi carian corak yang menggunakan heuristik watak buruk dari algoritma Boyer Moore", "code": "void search ( char * txt , char * pat ) { int m = strlen ( pat ) ; int n = strlen ( txt ) ; int badchar [ NO_OF_CHARS ] ;"}
{"text": "Isi pelbagai watak buruk dengan memanggil fungsi preprocessing badcharheuristik () untuk corak yang diberikan", "code": "badCharHeuristic ( pat , m , badchar ) ;"}
{"text": "s adalah peralihan corak berkenaan dengan teks", "code": "int s = 0 ;"}
{"text": "Terdapat n - m + 1 yang berpotensi menyusun", "code": "while ( s <= ( n - m ) ) { int j = m - 1 ;"}
{"text": "Terus mengurangkan indeks j corak manakala watak corak dan teks sepadan dengan shift ini", "code": "while ( j >= 0 && pat [ j ] == txt [ s + j ] ) j -- ;"}
{"text": "Sekiranya corak hadir pada peralihan semasa, maka indeks j akan menjadi - 1 selepas gelung di atas", "code": "if ( j < 0 ) { printf ( \" pattern occurs at shift = % d \""}
{"text": "Peralih corak supaya watak seterusnya dalam teks sejajar dengan kejadian terakhir dalam coraknya. Keadaan s + m <n diperlukan untuk kes apabila corak berlaku pada akhir teks", "code": "s += ( s + m < n ) ? m - badchar [ txt [ s + m ] ] : 1 ; } else"}
{"text": "Pergeseran corak supaya watak buruk dalam teks sejajar dengan kejadian terakhir dalam coraknya. Fungsi maksimum digunakan untuk memastikan kita mendapat peralihan positif. Kita mungkin mendapat peralihan negatif jika kejadian terakhir yang buruk dalam corak berada di sebelah kanan watak semasa.", "code": "s += max ( 1 , j - badchar [ txt [ s + j ] ] ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char txt [ ] = \" ABAAABCD \" ; char pat [ ] = \" ABC \" ; search ( txt , pat ) ; return 0 ; }"}
{"text": "Cetak subset dijumpai", "code": "void printSubset ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { printf ( \" % * d \" , 5 , A [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "input s - set vektor t - tuplet vektor s_size - set saiz t_size - saiz tuplet setakat ini jumlahnya", "code": "void subset_sum ( int s [ ] , int t [ ] , int s_size , int t_size , int sum , int ite , int const target_sum ) { total_nodes ++ ; if ( target_sum == sum ) {"}
{"text": "Kami mendapati subset", "code": "printSubset ( t , t_size ) ;"}
{"text": "Tidak termasuk item yang ditambah sebelumnya dan pertimbangkan calon seterusnya", "code": "subset_sum ( s , t , s_size , t_size - 1 , sum - s [ ite ] , ite + 1 , target_sum ) ; return ; } else {"}
{"text": "menjana nod sepanjang keluasan", "code": "for ( int i = ite ; i < s_size ; i ++ ) { t [ t_size ] = s [ i ] ;"}
{"text": "Pertimbangkan nod tahap seterusnya (sepanjang kedalaman)", "code": "subset_sum ( s , t , s_size , t_size + 1 , sum + s [ i ] , i + 1 , target_sum ) ; } } }"}
{"text": "Pembungkus untuk mencetak subset yang jumlahnya ke input target_sum adalah vektor berat dan target_sum", "code": "void generateSubsets ( int s [ ] , int size , int target_sum ) { int * tuplet_vector = ( int * ) malloc ( size * sizeof ( int ) ) ; subset_sum ( s , tuplet_vector , size , 0 , 0 , 0 , target_sum ) ; free ( tuplet_vector ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int weights [ ] = { 10 , 7 , 5 , 18 , 12 , 20 , 15 } ; int size = ARRAYSIZE ( weights ) ; generateSubsets ( weights , size , 35 ) ; printf ( \" Nodes ▁ generated ▁ % d ▁ STRNEWLINE \" , total_nodes ) ; return 0 ; }"}
{"text": "Cetak subset dijumpai", "code": "void printSubset ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { printf ( \" % * d \" , 5 , A [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "QSORT Bandingkan fungsi", "code": "int comparator ( const void * pLhs , const void * pRhs ) { int * lhs = ( int * ) pLhs ; int * rhs = ( int * ) pRhs ; return * lhs > * rhs ; }"}
{"text": "input s - set vektor t - tuplet vektor s_size - set saiz t_size - saiz tuplet setakat ini jumlahnya setakat ini - nod mengira sasaran_sum - jumlah yang dapat dijumpai", "code": "void subset_sum ( int s [ ] , int t [ ] , int s_size , int t_size , int sum , int ite , int const target_sum ) { total_nodes ++ ; if ( target_sum == sum ) {"}
{"text": "Kami menjumpai jumlah", "code": "printSubset ( t , t_size ) ;"}
{"text": "Cek Kekangan", "code": "if ( ite + 1 < s_size && sum - s [ ite ] + s [ ite + 1 ] <= target_sum ) {"}
{"text": "Tidak termasuk item tambahan sebelumnya dan pertimbangkan calon seterusnya", "code": "subset_sum ( s , t , s_size , t_size - 1 , sum - s [ ite ] , ite + 1 , target_sum ) ; } return ; } else {"}
{"text": "Cek Kekangan", "code": "if ( ite < s_size && sum + s [ ite ] <= target_sum ) {"}
{"text": "menjana nod sepanjang keluasan", "code": "for ( int i = ite ; i < s_size ; i ++ ) { t [ t_size ] = s [ i ] ; if ( sum + s [ i ] <= target_sum ) {"}
{"text": "Pertimbangkan nod tahap seterusnya (sepanjang kedalaman)", "code": "subset_sum ( s , t , s_size , t_size + 1 , sum + s [ i ] , i + 1 , target_sum ) ; } } } } }"}
{"text": "Pembalut yang mencetak subset yang jumlahnya ke target_sum", "code": "void generateSubsets ( int s [ ] , int size , int target_sum ) { int * tuplet_vector = ( int * ) malloc ( size * sizeof ( int ) ) ; int total = 0 ;"}
{"text": "Susun set", "code": "qsort ( s , size , sizeof ( int ) , & comparator ) ; for ( int i = 0 ; i < size ; i ++ ) { total += s [ i ] ; } if ( s [ 0 ] <= target_sum && total >= target_sum ) { subset_sum ( s , tuplet_vector , size , 0 , 0 , 0 , target_sum ) ; } free ( tuplet_vector ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int weights [ ] = { 15 , 22 , 14 , 26 , 32 , 9 , 16 , 8 } ; int target = 53 ; int size = ARRAYSIZE ( weights ) ; generateSubsets ( weights , size , target ) ; printf ( \" Nodes ▁ generated ▁ % d STRNEWLINE \" , total_nodes ) ; return 0 ; }"}
{"text": "N ialah saiz matriks 2d n * n", "code": "#define N  9"}
{"text": "Fungsi utiliti untuk mencetak grid", "code": "void print ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( \" % d ▁ \" , arr [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Memeriksa sama ada ia akan sah untuk memberikan num kepada baris yang diberikan, col", "code": "int isSafe ( int grid [ N ] [ N ] , int row , int col , int num ) {"}
{"text": "Semak jika kita dapati nombor yang sama dalam baris yang sama, kita kembali 0", "code": "for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ row ] [ x ] == num ) return 0 ;"}
{"text": "Semak jika kita dapati nombor yang sama dalam lajur yang sama, kita kembali 0", "code": "for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ x ] [ col ] == num ) return 0 ;"}
{"text": "Semak jika kita dapati nombor yang sama dalam matriks 3 * 3 tertentu, kita kembali 0", "code": "int startRow = row - row % 3 , startCol = col - col % 3 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow ] [ j + startCol ] == num ) return 0 ; return 1 ; }"}
{"text": "Mengambil sebahagiannya diisi - dalam grid dan cuba memberikan nilai kepada semua lokasi yang tidak ditugaskan sedemikian rupa untuk memenuhi syarat untuk penyelesaian Sudoku (bukan duplikasi di seluruh baris, lajur, dan kotak)", "code": "int solveSuduko ( int grid [ N ] [ N ] , int row , int col ) {"}
{"text": "Periksa sama ada kami telah mencapai baris ke -8 dan lajur ke -9 (0 matriks diindeks), kami kembali benar untuk mengelakkan mundur lebih lanjut", "code": "if ( row == N - 1 && col == N ) return 1 ;"}
{"text": "Semak jika nilai lajur menjadi 9, kami bergerak ke baris dan lajur seterusnya bermula dari 0", "code": "if ( col == N ) { row ++ ; col = 0 ; }"}
{"text": "Periksa sama ada kedudukan semasa grid sudah mengandungi nilai> 0, kami melangkah untuk lajur seterusnya", "code": "if ( grid [ row ] [ col ] > 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( int num = 1 ; num <= N ; num ++ ) {"}
{"text": "Periksa sama ada selamat untuk meletakkan num (1 - 9) dalam baris yang diberikan, col -> kami berpindah ke lajur seterusnya", "code": "if ( isSafe ( grid , row , col , num ) == 1 ) {"}
{"text": "Menetapkan NUM dalam kedudukan semasa (baris, col) grid dan mengandaikan NUM kami yang dipersembahkan dalam kedudukan itu betul", "code": "grid [ row ] [ col ] = num ;"}
{"text": "Memeriksa kemungkinan seterusnya dengan lajur seterusnya", "code": "if ( solveSuduko ( grid , row , col + 1 ) == 1 ) return 1 ; }"}
{"text": "Mengeluarkan Num yang diberikan, kerana andaian kami salah, dan kami pergi untuk andaian seterusnya dengan nilai diff Num", "code": "grid [ row ] [ col ] = 0 ; } return 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int grid [ N ] [ N ] = { { 3 , 0 , 6 , 5 , 0 , 8 , 4 , 0 , 0 } , { 5 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 8 , 7 , 0 , 0 , 0 , 0 , 3 , 1 } , { 0 , 0 , 3 , 0 , 1 , 0 , 0 , 8 , 0 } , { 9 , 0 , 0 , 8 , 6 , 3 , 0 , 0 , 5 } , { 0 , 5 , 0 , 0 , 9 , 0 , 6 , 0 , 0 } , { 1 , 3 , 0 , 0 , 0 , 0 , 2 , 5 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 4 } , { 0 , 0 , 5 , 2 , 0 , 6 , 3 , 0 , 0 } } ; if ( solveSuduko ( grid , 0 , 0 ) == 1 ) print ( grid ) ; else printf ( \" No ▁ solution ▁ exists \" ) ; return 0 ; }"}
{"text": "Penyelesaian O (n) Berdasarkan Gabungan Mudah untuk mencari median dari dua tatasusunan yang disusun", "code": "#include <stdio.h>"}
{"text": "Fungsi ini mengembalikan median AR1 [] dan AR2 []. Andaian dalam fungsi ini: kedua -dua ar1 [] dan ar2 [] disusun susunan kedua -duanya mempunyai elemen n", "code": "int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = -1 , m2 = -1 ;"}
{"text": "Oleh kerana terdapat 2 elemen, median akan menjadi purata elemen pada indeks n - 1 dan n dalam array yang diperolehi setelah menggabungkan AR1 dan AR2", "code": "for ( count = 0 ; count <= n ; count ++ ) {"}
{"text": "Di bawah adalah untuk mengendalikan kes di mana semua elemen AR1 [] lebih kecil daripada elemen terkecil (atau pertama) AR2 []", "code": "if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; }"}
{"text": "Di bawah adalah untuk mengendalikan kes di mana semua elemen AR2 [] lebih kecil daripada elemen terkecil (atau pertama) AR1 []", "code": "else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; }"}
{"text": "sama dengan tanda kerana jika dua array mempunyai beberapa elemen biasa", "code": "if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ;"}
{"text": "Simpan median sebelumnya", "code": "m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ;"}
{"text": "Simpan median sebelumnya", "code": "m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int ar1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; if ( n1 == n2 ) printf ( \" Median ▁ is ▁ % d \" , getMedian ( ar1 , ar2 , n1 ) ) ; else printf ( \" Doesn ' t ▁ work ▁ for ▁ arrays ▁ of ▁ unequal ▁ size \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Satu penyelesaian yang berpusat dan menaklukkan berasaskan untuk mencari median dua susunan yang disusun dengan saiz yang sama.", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "untuk mendapatkan median pelbagai jenis", "code": "int median ( int [ ] , int ) ;"}
{"text": "Fungsi ini mengembalikan median AR1 [] dan AR2 []. Andaian dalam fungsi ini: kedua -dua ar1 [] dan ar2 [] disusun susunan kedua -duanya mempunyai elemen n", "code": "int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { if ( n <= 0 ) return -1 ; if ( n == 1 ) return ( ar1 [ 0 ] + ar2 [ 0 ] ) / 2 ; if ( n == 2 ) return ( max ( ar1 [ 0 ] , ar2 [ 0 ] ) + min ( ar1 [ 1 ] , ar2 [ 1 ] ) ) / 2 ;"}
{"text": "Dapatkan median array pertama", "code": "int m1 = median ( ar1 , n ) ;"}
{"text": "Dapatkan median array kedua", "code": "int m2 = median ( ar2 , n ) ;"}
{"text": "Sekiranya median sama maka kembali sama ada M1 atau M2", "code": "if ( m1 == m2 ) return m1 ;"}
{"text": "Jika m1 <m2 maka median mesti wujud dalam ar1 [m1 .... ] dan ar2 [.... m2]", "code": "if ( m1 < m2 ) { if ( n % 2 == 0 ) return getMedian ( ar1 + n / 2 - 1 , ar2 , n - n / 2 + 1 ) ; return getMedian ( ar1 + n / 2 , ar2 , n - n / 2 ) ; }"}
{"text": "Jika m1> m2 maka median mesti wujud di AR1 [.... m1] dan ar2 [m2 ...]", "code": "if ( n % 2 == 0 ) return getMedian ( ar2 + n / 2 - 1 , ar1 , n - n / 2 + 1 ) ; return getMedian ( ar2 + n / 2 , ar1 , n - n / 2 ) ; }"}
{"text": "Berfungsi untuk mendapatkan median pelbagai disusun", "code": "int median ( int arr [ ] , int n ) { if ( n % 2 == 0 ) return ( arr [ n / 2 ] + arr [ n / 2 - 1 ] ) / 2 ; else return arr [ n / 2 ] ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int ar1 [ ] = { 1 , 2 , 3 , 6 } ; int ar2 [ ] = { 4 , 6 , 8 , 10 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; if ( n1 == n2 ) printf ( \" Median ▁ is ▁ % d \" , getMedian ( ar1 , ar2 , n1 ) ) ; else printf ( \" Doesn ' t ▁ work ▁ for ▁ arrays ▁ of ▁ unequal ▁ size \" ) ; return 0 ; }"}
{"text": "Program membahagikan dan menaklukkan dalam C / C ++ untuk mencari jarak terkecil dari satu set mata yang diberikan.", "code": "#include <stdio.h> NEW_LINE #include <float.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <math.h>"}
{"text": "Struktur untuk mewakili titik dalam satah 2d", "code": "struct Point { int x , y ; } ;"}
{"text": "Diperlukan untuk menyusun pelbagai mata mengikut koordinat x", "code": "int compareX ( const void * a , const void * b ) { Point * p1 = ( Point * ) a , * p2 = ( Point * ) b ; return ( p1 -> x - p2 -> x ) ; }"}
{"text": "Diperlukan untuk menyusun pelbagai mata mengikut koordinat y", "code": "int compareY ( const void * a , const void * b ) { Point * p1 = ( Point * ) a , * p2 = ( Point * ) b ; return ( p1 -> y - p2 -> y ) ; }"}
{"text": "Fungsi utiliti untuk mencari jarak antara dua mata", "code": "float dist ( Point p1 , Point p2 ) { return sqrt ( ( p1 . x - p2 . x ) * ( p1 . x - p2 . x ) + ( p1 . y - p2 . y ) * ( p1 . y - p2 . y ) ) ; }"}
{"text": "Kaedah kekerasan untuk mengembalikan jarak terkecil antara dua mata dalam p [] saiz n", "code": "float bruteForce ( Point P [ ] , int n ) { float min = FLT_MAX ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i + 1 ; j < n ; ++ j ) if ( dist ( P [ i ] , P [ j ] ) < min ) min = dist ( P [ i ] , P [ j ] ) ; return min ; }"}
{"text": "Fungsi utiliti untuk mencari sekurang -kurangnya dua nilai apungan", "code": "float min ( float x , float y ) { return ( x < y ) ? x : y ; }"}
{"text": "Fungsi utiliti untuk mencari jarak antara titik terdekat jalur saiz yang diberikan. Semua mata dalam jalur [] disusun mengikut koordinat y. Mereka semua mempunyai terikat atas pada jarak minimum sebagai d. Perhatikan bahawa kaedah ini seolah -olah menjadi kaedah O (n ^ 2), tetapi ia 's a o (n) kaedah sebagai gelung dalaman berjalan paling 6 kali", "code": "float stripClosest ( Point strip [ ] , int size , float d ) {"}
{"text": "Memulakan jarak minimum sebagai d", "code": "float min = d ; qsort ( strip , size , sizeof ( Point ) , compareY ) ;"}
{"text": "Pilih semua mata satu demi satu dan cuba titik seterusnya sehingga perbezaan antara koordinat Y adalah lebih kecil daripada d. Ini adalah fakta yang terbukti bahawa gelung ini paling banyak berjalan 6 kali", "code": "for ( int i = 0 ; i < size ; ++ i ) for ( int j = i + 1 ; j < size && ( strip [ j ] . y - strip [ i ] . y ) < min ; ++ j ) if ( dist ( strip [ i ] , strip [ j ] ) < min ) min = dist ( strip [ i ] , strip [ j ] ) ; return min ; }"}
{"text": "Fungsi rekursif untuk mencari jarak terkecil. Array P mengandungi semua mata yang disusun mengikut koordinat x", "code": "float closestUtil ( Point P [ ] , int n ) {"}
{"text": "Sekiranya terdapat 2 atau 3 mata, maka gunakan kekerasan", "code": "if ( n <= 3 ) return bruteForce ( P , n ) ;"}
{"text": "Cari titik tengah", "code": "int mid = n / 2 ; Point midPoint = P [ mid ] ;"}
{"text": "Pertimbangkan garis menegak melalui titik tengah Kirakan jarak terkecil DL di sebelah kiri titik tengah dan DR di sebelah kanan", "code": "float dl = closestUtil ( P , mid ) ; float dr = closestUtil ( P + mid , n - mid ) ;"}
{"text": "Cari lebih kecil daripada dua jarak", "code": "float d = min ( dl , dr ) ;"}
{"text": "Bina jalur array [] yang mengandungi titik dekat (lebih dekat daripada d) ke garisan melalui titik tengah", "code": "Point strip [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( abs ( P [ i ] . x - midPoint . x ) < d ) strip [ j ] = P [ i ] , j ++ ;"}
{"text": "Cari mata terdekat dalam jalur. Kembalikan minimum d dan jarak terdekat adalah jalur []", "code": "return min ( d , stripClosest ( strip , j , d ) ) ; }"}
{"text": "Fungsi utama yang mendapati jarak terkecil kaedah ini terutamanya menggunakan CloseStutil ()", "code": "float closest ( Point P [ ] , int n ) { qsort ( P , n , sizeof ( Point ) , compareX ) ;"}
{"text": "Gunakan fungsi rekursif CloseStUtil () untuk mencari jarak terkecil", "code": "return closestUtil ( P , n ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { Point P [ ] = { { 2 , 3 } , { 12 , 30 } , { 40 , 50 } , { 5 , 1 } , { 12 , 10 } , { 3 , 4 } } ; int n = sizeof ( P ) / sizeof ( P [ 0 ] ) ; printf ( \" The ▁ smallest ▁ distance ▁ is ▁ % f ▁ \" , closest ( P , n ) ) ; return 0 ; }"}
{"text": "Pulangan 1 Jika n adalah tidak bertuah. Ohterwise kembali 0", "code": "bool isLucky ( int n ) { static int counter = 2 ;"}
{"text": "variable next_position hanya untuk kebolehbacaan program yang kita dapat mengeluarkannya dan menggunakan n sahaja", "code": "int next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ;"}
{"text": "Kirakan kedudukan input tidak seterusnya", "code": "next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }"}
{"text": "Fungsi pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int x = 5 ; if ( isLucky ( x ) ) printf ( \" % d ▁ is ▁ a ▁ lucky ▁ no . \" , x ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ lucky ▁ no . \" , x ) ; getchar ( ) ; }"}
{"text": "Berfungsi hanya jika a> = 0 dan b> = 0", "code": "int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }"}
{"text": "program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { printf ( \" % d \" , pow ( 5 , 3 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Fungsi rekursif untuk mendapatkan x * y", "code": "int multiply ( int x , int y ) { if ( y ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; }"}
{"text": "Fungsi rekursif untuk mendapatkan A ^ B berfungsi hanya jika a> = 0 dan b> = 0", "code": "int pow ( int a , int b ) { if ( b ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; }"}
{"text": "program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { printf ( \" % d \" , pow ( 5 , 3 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Mengembalikan kiraan nombor yang berada dalam jarak dari 1 hingga n dan tidak mengandungi 3 sebagai digit", "code": "int count ( int n ) {"}
{"text": "Kes asas (dengan asumsi n tidak negatif)", "code": "if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ;"}
{"text": "Kirakan 10 ^ (d - 1) (10 Raise ke kuasa d - 1) di mana d adalah bilangan digit dalam n. PO akan menjadi 100 untuk n = 578", "code": "int po = 1 ; while ( n / po > 9 ) po = po * 10 ;"}
{"text": "Cari digit yang paling penting (MSD ialah 5 untuk 578)", "code": "int msd = n / po ; if ( msd != 3 )"}
{"text": "Untuk 578, jumlahnya akan menjadi 4 * kiraan (10 ^ 2 - 1) + 4 + kiraan (78)", "code": "return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else"}
{"text": "Untuk 35, jumlah akan sama dengan dikira (29)", "code": "return count ( msd * po - 1 ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { printf ( \" % d ▁ \" , count ( 578 ) ) ; return 0 ; }"}
{"text": "Program C untuk mencari pangkat leksikografi rentetan", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Fungsi utiliti untuk mencari faktorial n", "code": "int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; }"}
{"text": "Fungsi utiliti untuk mengira aksara yang lebih kecil di sebelah kanan ARR [rendah]", "code": "int findSmallerInRight ( char * str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str [ i ] < str [ low ] ) ++ countRight ; return countRight ; }"}
{"text": "Fungsi untuk mencari pangkat rentetan dalam semua permutasi aksara", "code": "int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; int i ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ;"}
{"text": "kiraan bilangan chars lebih kecil daripada str [i] fron str [i + 1] ke str [len - 1]", "code": "countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char str [ ] = \" string \" ; printf ( \" % d \" , findRank ( str ) ) ; return 0 ; }"}
{"text": "Penyelesaian O (N) untuk mencari pangkat rentetan", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define MAX_CHAR  256"}
{"text": "Semua elemen kiraan [] diasaskan dengan 0", "code": "int count [ MAX_CHAR ] = { 0 } ;"}
{"text": "Fungsi utiliti untuk mencari faktorial n", "code": "int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; }"}
{"text": "Bina pelbagai kiraan di mana nilai di setiap indeks mengandungi kiraan aksara yang lebih kecil dalam rentetan keseluruhan", "code": "void populateAndIncreaseCount ( int * count , char * str ) { int i ; for ( i = 0 ; str [ i ] ; ++ i ) ++ count [ str [ i ] ] ; for ( i = 1 ; i < MAX_CHAR ; ++ i ) count [ i ] += count [ i - 1 ] ; }"}
{"text": "Mengeluarkan watak CH dari Count [] array yang dibina oleh populateandIncreaseCount ()", "code": "void updatecount ( int * count , char ch ) { int i ; for ( i = ch ; i < MAX_CHAR ; ++ i ) -- count [ i ] ; }"}
{"text": "Fungsi untuk mencari pangkat rentetan dalam semua permutasi aksara", "code": "int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 , i ;"}
{"text": "Mengisi array kiraan seperti yang dikira [i] mengandungi kiraan aksara yang terdapat di str dan lebih kecil daripada i", "code": "populateAndIncreaseCount ( count , str ) ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ;"}
{"text": "kiraan bilangan chars lebih kecil daripada str [i] fron str [i + 1] ke str [len - 1]", "code": "rank += count [ str [ i ] - 1 ] * mul ;"}
{"text": "Kurangkan kiraan aksara lebih besar daripada str [i]", "code": "updatecount ( count , str [ i ] ) ; } return rank ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char str [ ] = \" string \" ; printf ( \" % d \" , findRank ( str ) ) ; return 0 ; }"}
{"text": "Program untuk mencetak semua permutasi rentetan dalam urutan yang disusun.", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h>"}
{"text": "Fungsi berikut diperlukan untuk fungsi perpustakaan QSORT (). Rujuk http: www. cplusplus. com / rujukan / clibrary / cstdlib / qsort /", "code": "int compare ( const void * a , const void * b ) { return ( * ( char * ) a - * ( char * ) b ) ; }"}
{"text": "Fungsi utiliti dua swap dua aksara a dan b", "code": "void swap ( char * a , char * b ) { char t = * a ; * a = * b ; * b = t ; }"}
{"text": "Fungsi ini mendapati indeks watak terkecil yang lebih besar daripada 'pertama' dan terdapat dalam str [l. . H]", "code": "int findCeil ( char str [ ] , char first , int l , int h ) {"}
{"text": "Inisialisasi Indeks Elemen Siling", "code": "int ceilIndex = l ;"}
{"text": "Sekarang berulang melalui unsur -unsur yang lain dan dapatkan watak terkecil lebih besar daripada 'pertama'", "code": "for ( int i = l + 1 ; i <= h ; i ++ ) if ( str [ i ] > first && str [ i ] < str [ ceilIndex ] ) ceilIndex = i ; return ceilIndex ; }"}
{"text": "Cetak semua permutasi STR dalam urutan yang disusun", "code": "void sortedPermutations ( char str [ ] ) {"}
{"text": "Dapatkan saiz tali", "code": "int size = strlen ( str ) ;"}
{"text": "Susunkan rentetan dalam peningkatan urutan", "code": "qsort ( str , size , sizeof ( str [ 0 ] ) , compare ) ;"}
{"text": "Cetak permutasi satu demi satu", "code": "bool isFinished = false ; while ( ! isFinished ) {"}
{"text": "Cetak permutasi ini", "code": "printf ( \" % s ▁ STRNEWLINE \" , str ) ;"}
{"text": "Cari watak paling kanan yang lebih kecil daripada watak seterusnya. Mari kita namakan 'Pertama ~ Char'", "code": "int i ; for ( i = size - 2 ; i >= 0 ; -- i ) if ( str [ i ] < str [ i + 1 ] ) break ;"}
{"text": "Sekiranya tidak ada watak sedemikian, semuanya disusun dalam penurunan urutan, bermakna kita hanya mencetak permutasi terakhir dan kita sudah selesai.", "code": "if ( i == -1 ) isFinished = true ; else {"}
{"text": "Cari ceil 'Pertama' Char 'di sebelah kanan watak pertama. Ceil of a Watak adalah watak terkecil yang lebih besar daripada itu", "code": "int ceilIndex = findCeil ( str , str [ i ] , i + 1 , size - 1 ) ;"}
{"text": "Bertukar watak pertama dan kedua", "code": "swap ( & str [ i ] , & str [ ceilIndex ] ) ;"}
{"text": "Susun tali di sebelah kanan 'Pertama ~ Char'", "code": "qsort ( str + i + 1 , size - i - 1 , sizeof ( str [ 0 ] ) , compare ) ; } } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char str [ ] = \" ABCD \" ; sortedPermutations ( str ) ; return 0 ; }"}
{"text": "Versi yang dioptimumkan yang menggunakan sebaliknya dan bukannya untuk mencari permutasi seterusnya fungsi utiliti untuk membalikkan string str [l. . H]", "code": "void reverse ( char str [ ] , int l , int h ) { while ( l < h ) { swap ( & str [ l ] , & str [ h ] ) ; l ++ ; h -- ; } }"}
{"text": "Cetak semua permutasi STR dalam urutan yang disusun", "code": "void sortedPermutations ( char str [ ] ) {"}
{"text": "Dapatkan saiz tali", "code": "int size = strlen ( str ) ;"}
{"text": "Susunkan rentetan dalam peningkatan urutan", "code": "qsort ( str , size , sizeof ( str [ 0 ] ) , compare ) ;"}
{"text": "Cetak permutasi satu demi satu", "code": "bool isFinished = false ; while ( ! isFinished ) {"}
{"text": "Cetak permutasi ini", "code": "printf ( \" % s ▁ STRNEWLINE \" , str ) ;"}
{"text": "Cari watak paling kanan yang lebih kecil daripada watak seterusnya. Marilah kita menyebutnya 'Pertama' Char '", "code": "int i ; for ( i = size - 2 ; i >= 0 ; -- i ) if ( str [ i ] < str [ i + 1 ] ) break ;"}
{"text": "Sekiranya tidak ada watak sedemikian, semuanya disusun dalam penurunan urutan, bermakna kita hanya mencetak permutasi terakhir dan kita sudah selesai.", "code": "if ( i == -1 ) isFinished = true ; else {"}
{"text": "Cari ceil 'Pertama' Char 'di sebelah kanan watak pertama. Ceil of a Watak adalah watak terkecil yang lebih besar daripada itu", "code": "int ceilIndex = findCeil ( str , str [ i ] , i + 1 , size - 1 ) ;"}
{"text": "Bertukar watak pertama dan kedua", "code": "swap ( & str [ i ] , & str [ ceilIndex ] ) ;"}
{"text": "membalikkan rentetan di sebelah kanan 'Pertama ~ Char'", "code": "reverse ( str , i + 1 , size - 1 ) ; } } }"}
{"text": "C Program yang cekap untuk mengira E menaikkan kuasa x", "code": "#include <stdio.h>"}
{"text": "Mengembalikan nilai anggaran e ^ x menggunakan jumlah syarat pertama n siri Taylor", "code": "float exponential ( int n , float x ) {"}
{"text": "memulakan jumlah siri", "code": "float sum = 1.0f ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 10 ; float x = 1.0f ; printf ( \" e ^ x ▁ = ▁ % f \" , exponential ( n , x ) ) ; return 0 ; }"}
{"text": "Program C untuk menjana nombor rawak mengikut taburan frekuensi yang diberikan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Fungsi utiliti untuk mencari siling r dalam arr [l. . H]", "code": "int findCeil ( int arr [ ] , int r , int l , int h ) { int mid ; while ( l < h ) {"}
{"text": "Sama seperti pertengahan = (l + h) / 2", "code": "mid = l + ( ( h - l ) >> 1 ) ; ( r > arr [ mid ] ) ? ( l = mid + 1 ) : ( h = mid ) ; } return ( arr [ l ] >= r ) ? l : -1 ; }"}
{"text": "Fungsi utama yang mengembalikan nombor rawak dari ARR [] mengikut array pengedaran yang ditakrifkan oleh Freq []. n adalah saiz tatasusunan.", "code": "int myRand ( int arr [ ] , int freq [ ] , int n ) {"}
{"text": "Buat dan isi array awalan", "code": "int prefix [ n ] , i ; prefix [ 0 ] = freq [ 0 ] ; for ( i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] + freq [ i ] ;"}
{"text": "Awalan [n - 1] adalah jumlah semua frekuensi. Menjana nombor rawak dengan nilai dari 1 hingga jumlah ini", "code": "int r = ( rand ( ) % prefix [ n - 1 ] ) + 1 ;"}
{"text": "Cari indeks siling r dalam awalan arrat", "code": "int indexc = findCeil ( prefix , r , 0 , n - 1 ) ; return arr [ indexc ] ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int freq [ ] = { 10 , 5 , 20 , 100 } ; int i , n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Gunakan nilai benih yang berbeza untuk setiap larian.", "code": "srand ( time ( NULL ) ) ;"}
{"text": "Marilah kita menjana 10 nombor rawak yang menanggung pengedaran yang diberikan", "code": "for ( i = 0 ; i < 5 ; i ++ ) printf ( \" % d STRNEWLINE \" , myRand ( arr , freq , n ) ) ; return 0 ; }"}
{"text": "Fungsi ini menjana 'x' dengan kebarangkalian px / 100, 'y' dengan kebarangkalian py / 100 dan 'z' dengan kebarangkalian pz / 100: asumsi: px + py + pz = 100 di mana px, py dan pz terletak antara 0 hingga 100", "code": "int random ( int x , int y , int z , int px , int py , int pz ) {"}
{"text": "Menjana nombor dari 1 hingga 100", "code": "int r = rand ( 1 , 100 ) ;"}
{"text": "r lebih kecil daripada px dengan kebarangkalian px / 100", "code": "if ( r <= px ) return x ;"}
{"text": "r lebih besar daripada px dan lebih kecil daripada atau sama dengan px + py dengan kebarangkalian py / 100", "code": "if ( r <= ( px + py ) ) return y ;"}
{"text": "r lebih besar daripada px + py dan lebih kecil daripada atau sama dengan 100 dengan kebarangkalian PZ / 100", "code": "else return z ; }"}
{"text": "Program c untuk mencari sudut antara jam dan minit", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Fungsi utiliti untuk mencari minimum dua bilangan bulat", "code": "int min ( int x , int y ) { return ( x < y ) ? x : y ; }"}
{"text": "Berfungsi untuk mengira sudut", "code": "int calcAngle ( double h , double m ) {"}
{"text": "Mengesahkan input", "code": "if ( h < 0 m < 0 h > 12 m > 60 ) printf ( \" Wrong ▁ input \" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; }"}
{"text": "Kirakan sudut yang dipindahkan mengikut jam dan minit dengan merujuk kepada 12: 00", "code": "int hour_angle = 0.5 * ( h * 60 + m ) ; int minute_angle = 6 * m ;"}
{"text": "Cari perbezaan antara dua sudut", "code": "int angle = abs ( hour_angle - minute_angle ) ;"}
{"text": "Kembalikan sudut yang lebih kecil daripada dua sudut yang mungkin", "code": "angle = min ( 360 - angle , angle ) ; return angle ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { printf ( \" % d ▁ n \" , calcAngle ( 9 , 60 ) ) ; printf ( \" % d ▁ n \" , calcAngle ( 3 , 30 ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari elemen yang berlaku sekali sahaja", "code": "#include <stdio.h>"}
{"text": "Kaedah untuk mencari elemen yang berlaku sekali sahaja", "code": "int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text": "Ungkapan \"Satu & ur [i]\" memberikan bit yang ada di kedua -dua 'Ones' dan elemen baru dari ARR []. Kami menambah bit ini ke 'twos' menggunakan bitwise atau nilai 'twos' akan ditetapkan sebagai 0, 3, 3 dan 1 selepas 1 st, 2 nd, 3 rd dan 4 iterations masing -masing", "code": "twos = twos | ( ones & arr [ i ] ) ;"}
{"text": "Xor bit baru dengan 'yang terdahulu' untuk mendapatkan semua bit yang muncul bilangan ganjil kali nilai 'Ones' akan ditetapkan sebagai 3, 0, 2 dan 3 selepas 1 st, 2 nd, 3 rd dan ke -4 lelaran masing -masing", "code": "ones = ones ^ arr [ i ] ;"}
{"text": "Bit biasa adalah bit yang muncul kali ketiga supaya bit ini tidak boleh berada di kedua -dua 'Ones' dan 'Twos'. Common_bit_mask mengandungi semua bit ini sebagai 0, supaya bit dapat dikeluarkan dari nilai 'Ones' dan 'Twos' dari 'Common _ Bit _ Mask' akan ditetapkan sebagai 00, 00, 01 dan 10 selepas 1 st, 2 nd, 3 rd dan 4 ke 4", "code": "common_bit_mask = ~ ( ones & twos ) ;"}
{"text": "Keluarkan bit biasa (bit yang muncul kali ketiga) dari nilai 'Ones' dari 'Ones' akan ditetapkan sebagai 3, 0, 0 dan 2 selepas 1 st, 2 nd, 3 rd dan 4 iterations masing -masing", "code": "ones &= common_bit_mask ;"}
{"text": "Keluarkan bit biasa (bit yang muncul kali ketiga) dari nilai 'twos' dari 'twos' akan ditetapkan sebagai 0, 3, 1 dan 0 selepas 1 st, 2 nd, 3 rd dan 4 itearations masing -masing", "code": "twos &= common_bit_mask ; } return ones ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ % d ▁ \" , getSingle ( arr , n ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari elemen yang berlaku sekali sahaja", "code": "#include <stdio.h> NEW_LINE #define INT_SIZE  32 NEW_LINE int getSingle ( int arr [ ] , int n ) {"}
{"text": "Memulakan hasil", "code": "int result = 0 ; int x , sum ;"}
{"text": "Berulang melalui setiap bit", "code": "for ( int i = 0 ; i < INT_SIZE ; i ++ ) {"}
{"text": "Cari jumlah bit yang ditetapkan pada kedudukan ith dalam semua elemen array", "code": "sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; }"}
{"text": "Bit dengan jumlah tidak berganda 3, adalah bit elemen dengan kejadian tunggal.", "code": "if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ % d ▁ \" , getSingle ( arr , n ) ) ; return 0 ; }"}
{"text": "Program kerumitan o (logn) untuk mengira set bit dalam semua nombor dari 1 hingga n", "code": "#include <stdio.h>"}
{"text": "Mengembalikan kedudukan bit set paling kiri. Kedudukan paling kanan dianggap sebagai 0", "code": "unsigned int getLeftmostBit ( int n ) { int m = 0 ; while ( n > 1 ) { n = n >> 1 ; m ++ ; } return m ; }"}
{"text": "Memandangkan kedudukan set bit paling kiri sebelumnya dalam n (atau terikat atas pada kedudukan paling kiri) mengembalikan kedudukan baru set bit paling kiri dalam n", "code": "unsigned int getNextLeftmostBit ( int n , int m ) { unsigned int temp = 1 << m ; while ( n < temp ) { temp = temp >> 1 ; m -- ; } return m ; }"}
{"text": "Fungsi rekursif utama yang digunakan oleh countsetbits ()", "code": "unsigned int _countSetBits ( unsigned int n , int m ) ; unsigned int countSetBits ( unsigned int n ) {"}
{"text": "Dapatkan kedudukan bit set kiri dalam n. Ini akan digunakan sebagai terikat atas untuk fungsi bit set seterusnya", "code": "int m = getLeftmostBit ( n ) ;"}
{"text": "Gunakan kedudukan", "code": "return _countSetBits ( n , m ) ; } unsigned int _countSetBits ( unsigned int n , int m ) {"}
{"text": "Kes asas: jika n adalah 0, maka tetapkan bit bit ialah 0", "code": "if ( n == 0 ) return 0 ;"}
{"text": "Dapatkan kedudukan bit set kiri seterusnya", "code": "m = getNextLeftmostBit ( n , m ) ;"}
{"text": "Jika n adalah bentuk 2 ^ x - 1, i. e. , jika n seperti 1, 3, 7, 15, 31 ,. . dan lain -lain, maka kita sudah selesai. Oleh kerana kedudukan dianggap bermula dari 0, 1 ditambah kepada m", "code": "if ( n == ( ( unsigned int ) 1 << ( m + 1 ) ) - 1 ) return ( unsigned int ) ( m + 1 ) * ( 1 << m ) ;"}
{"text": "Kemas kini n untuk panggilan rekursif seterusnya", "code": "n = n - ( 1 << m ) ; return ( n + 1 ) + countSetBits ( n ) + m * ( 1 << ( m - 1 ) ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 17 ; printf ( \" Total ▁ set ▁ bit ▁ count ▁ is ▁ % d \" , countSetBits ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk menukar bit dalam nombor tertentu", "code": "#include <stdio.h> NEW_LINE int swapBits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) {"}
{"text": "Pindahkan semua bit set pertama ke sebelah kanan", "code": "unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ;"}
{"text": "Pindahkan semua bit set kedua ke sebelah kanan", "code": "unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ;"}
{"text": "Xor dua set", "code": "unsigned int xor = ( set1 ^ set2 ) ;"}
{"text": "Letakkan bit XOR kembali ke kedudukan asalnya", "code": "xor = ( xor << p1 ) | ( xor << p2 ) ;"}
{"text": "Xor 'xor' dengan nombor asal supaya kedua -dua set itu ditukar", "code": "unsigned int result = x ^ xor ; return result ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int res = swapBits ( 28 , 0 , 3 , 2 ) ; printf ( \" Result = % d \" , res ) ; return 0 ; }"}
{"text": "C Program untuk mencari terkecil daripada tiga bilangan bulat tanpa pengendali perbandingan", "code": "#include <stdio.h> NEW_LINE int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int x = 12 , y = 15 , z = 5 ; printf ( \" Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ % d \" , smallest ( x , y , z ) ) ; return 0 ; }"}
{"text": "C pelaksanaan pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #define CHAR_BIT  8"}
{"text": "Berfungsi untuk mencari minimum x dan y", "code": "int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; }"}
{"text": "Berfungsi untuk mencari minimum 3 nombor x, y dan z", "code": "int smallest ( int x , int y , int z ) { return min ( x , min ( y , z ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int x = 12 , y = 15 , z = 5 ; printf ( \" Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ % d \" , smallest ( x , y , z ) ) ; return 0 ; }"}
{"text": "Menggunakan pengendali bahagian untuk mencari minimum tiga nombor", "code": "int smallest ( int x , int y , int z ) {"}
{"text": "Sama seperti \"jika (y u u)\"", "code": "if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ; return ( ! ( x / z ) ) ? x : z ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int x = 78 , y = 88 , z = 68 ; printf ( \" Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ % d \" , smallest ( x , y , z ) ) ; return 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int a [ ] = { 1 , 0 } ; changeToZero ( a ) ; printf ( \" ▁ arr [ 0 ] ▁ = ▁ % d ▁ STRNEWLINE \" , a [ 0 ] ) ; printf ( \" ▁ arr [ 1 ] ▁ = ▁ % d ▁ \" , a [ 1 ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Saiz array 64 k", "code": "#define SIZE  (1 << 16)"}
{"text": "Group_a - Apabila digabungkan dengan meta_look_up menjana kiraan untuk 4 x4 elemen", "code": "#define GROUP_A ( x )  x, x + 1, x + 1, x + 2"}
{"text": "Kumpulan_b - apabila digabungkan dengan meta_look_up menjana kiraan untuk elemen 4 x4x4", "code": "#define GROUP_B ( x )  GROUP_A(x), GROUP_A(x+1), GROUP_A(x+1), GROUP_A(x+2)"}
{"text": "Group_c - Apabila digabungkan dengan meta_look_up menjana kiraan untuk elemen 4 x4x4x4", "code": "#define GROUP_C ( x )  GROUP_B(x), GROUP_B(x+1), GROUP_B(x+1), GROUP_B(x+2)"}
{"text": "Berikan surat yang sesuai untuk menjana jadual", "code": "#define META_LOOK_UP ( PARAMETER )  \\NEW_LINE GROUP_##PARAMETER(0), \\NEW_LINE GROUP_##PARAMETER(1), \\NEW_LINE GROUP_##PARAMETER(1), \\NEW_LINE GROUP_##PARAMETER(2) \\NEW_LINEint countSetBits(int array[], size_t array_size) NEW_LINE { int count = 0 ;"}
{"text": "Jadual statik akan lebih pantas untuk diakses", "code": "static unsigned char const look_up [ ] = { META_LOOK_UP ( C ) } ;"}
{"text": "Tiada Peralihan Funda (untuk kebolehbacaan yang lebih baik)", "code": "unsigned char * pData = NULL ; for ( size_t index = 0 ; index < array_size ; index ++ ) {"}
{"text": "Baik -baik saja, memintas sistem jenis", "code": "pData = ( unsigned char * ) & array [ index ] ;"}
{"text": "Kiraan bit set dalam bait individu", "code": "count += look_up [ pData [ 0 ] ] ; count += look_up [ pData [ 1 ] ] ; count += look_up [ pData [ 2 ] ] ; count += look_up [ pData [ 3 ] ] ; } return count ; }"}
{"text": "Program pemacu, menghasilkan jadual nombor 64 k rawak", "code": "int main ( ) { int index ; int random [ SIZE ] ;"}
{"text": "Benih ke penjana nombor rawak", "code": "srand ( ( unsigned ) time ( 0 ) ) ;"}
{"text": "Menjana nombor rawak.", "code": "for ( index = 0 ; index < SIZE ; index ++ ) { random [ index ] = rand ( ) ; } printf ( \" Total ▁ number ▁ of ▁ bits ▁ = ▁ % d STRNEWLINE \" , countSetBits ( random , SIZE ) ) ; return 0 ; }"}
{"text": "Kod c ++ untuk menambah tambah satu ke nombor tertentu", "code": "#include <stdio.h> NEW_LINE int addOne ( int x ) { int m = 1 ;"}
{"text": "Flip semua bit set sehingga kita dapati 0", "code": "while ( x & m ) { x = x ^ m ; m <<= 1 ; }"}
{"text": "Flip paling tepat 0 bit", "code": "x = x ^ m ; return x ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { printf ( \" % d \" , addOne ( 13 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { printf ( \" % d \" , addOne ( 13 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "tidak menetapkan bit set yang paling tepat dan mengembalikan hasilnya", "code": "int fun ( unsigned int n ) { return n & ( n - 1 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 7 ; printf ( \" The ▁ number ▁ after ▁ unsetting ▁ the \" ) ; printf ( \" ▁ rightmost ▁ set ▁ bit ▁ % d \" , fun ( n ) ) ; return 0 ; }"}
{"text": "Berfungsi untuk memeriksa sama ada x adalah kuasa 4", "code": "bool isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) printf ( \" % d ▁ is ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; getchar ( ) ; }"}
{"text": "Berfungsi untuk memeriksa sama ada x adalah kuasa 4", "code": "bool isPowerOfFour ( unsigned int n ) { int count = 0 ;"}
{"text": "Periksa sama ada hanya satu set bit di n", "code": "if ( n && ! ( n & ( n - 1 ) ) ) {"}
{"text": "Kira 0 bit sebelum ditetapkan sedikit", "code": "while ( n > 1 ) { n >>= 1 ; count += 1 ; }"}
{"text": "Sekiranya kiraan itu, maka kembali lagi yang lain palsu", "code": "return ( count % 2 == 0 ) ? 1 : 0 ; }"}
{"text": "Sekiranya terdapat lebih daripada 1 bit set maka n bukan kuasa 4", "code": "return 0 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) printf ( \" % d ▁ is ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; getchar ( ) ; }"}
{"text": "Program C untuk memeriksa sama ada nombor yang diberikan adalah kuasa 4 atau tidak", "code": "#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isPowerOfFour ( unsigned int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) printf ( \" % d ▁ is ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; getchar ( ) ; }"}
{"text": "Program c untuk mengira minimum atau maksimum dua bilangan bulat tanpa bercabang", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencari minimum x dan y", "code": "int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x < y ) ) ; }"}
{"text": "Berfungsi untuk mencari maksimum x dan y", "code": "int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x < y ) ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int x = 15 ; int y = 6 ; printf ( \" Minimum ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ \" , x , y ) ; printf ( \" % d \" , min ( x , y ) ) ; printf ( \" Maximum of % d and % d is \" printf ( \" % d \" , max ( x , y ) ) ; getchar ( ) ; }"}
{"text": "Berfungsi untuk mencari minimum x dan y", "code": "int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; }"}
{"text": "Berfungsi untuk mencari maksimum x dan y", "code": "int max ( int x , int y ) { return x - ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int x = 15 ; int y = 6 ; printf ( \" Minimum ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ \" , x , y ) ; printf ( \" % d \" , min ( x , y ) ) ; printf ( \" Maximum of % d and % d is \" printf ( \" % d \" , max ( x , y ) ) ; getchar ( ) ; }"}
{"text": "Mengambil penunjuk untuk keputusan dan dua nombor sebagai hujah. Sekiranya tidak ada limpahan, fungsi meletakkan hasil = jumlah a + b hasil dan pulangan 0, jika tidak ia kembali - 1", "code": "int addOvf ( int * result , int a , int b ) { * result = a + b ; if ( a > 0 && b > 0 && * result < 0 ) return -1 ; if ( a < 0 && b < 0 && * result > 0 ) return -1 ; return 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int * res = ( int * ) malloc ( sizeof ( int ) ) ; int x = 2147483640 ; int y = 10 ; printf ( \" % d \" , addOvf ( res , x , y ) ) ; printf ( \" % d \" , * res ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk kedudukan bit set kanan", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE unsigned int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 12 ; printf ( \" % u \" , getFirstSetBitPos ( n ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "fungsi bin", "code": "void bin ( unsigned n ) { unsigned i ; for ( i = 1 << 31 ; i > 0 ; i = i / 2 ) ( n & i ) ? printf ( \"1\" ) : printf ( \"0\" ) ; }"}
{"text": "Kod pemacu", "code": "int main ( void ) { bin ( 7 ) ; printf ( \" STRNEWLINE \" ) ; bin ( 4 ) ; }"}
{"text": "Program C untuk menukar bit yang lebih baik dan ganjil dari nombor tertentu", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk menukar bit walaupun dan ganjil", "code": "unsigned int swapBits ( unsigned int x ) {"}
{"text": "Dapatkan semua bit x", "code": "unsigned int even_bits = x & 0xAAAAAAAA ;"}
{"text": "Dapatkan semua bit ganjil x", "code": "unsigned int odd_bits = x & 0x55555555 ;"}
{"text": "Peralihan kanan walaupun bit", "code": "even_bits >>= 1 ;"}
{"text": "Bit beralih kiri", "code": "odd_bits <<= 1 ;"}
{"text": "Menggabungkan bit walaupun dan ganjil", "code": "return ( even_bits odd_bits ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "00010111", "code": "unsigned int x = 23 ;"}
{"text": "Output adalah 43 (00101011)", "code": "printf ( \" % u ▁ \" , swapBits ( x ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari kedudukan hanya set bit dalam nombor tertentu", "code": "#include <stdio.h>"}
{"text": "Fungsi utiliti untuk memeriksa sama ada n adalah kuasa 2 atau tidak. goo. gl / 17 arj lihat http:", "code": "int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; }"}
{"text": "Mengembalikan kedudukan satu -satunya set bit dalam 'n'", "code": "int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned i = 1 , pos = 1 ;"}
{"text": "Melewati bit n hingga kita dapati set bit i & n akan bukan sifar hanya apabila 'i' dan 'n' mempunyai bit set pada kedudukan yang sama", "code": "while ( ! ( i & n ) ) {"}
{"text": "Bit semasa yang tidak ditetapkan dan tetapkan bit seterusnya dalam 'I'", "code": "i = i << 1 ;"}
{"text": "kedudukan kenaikan", "code": "++ pos ; } return pos ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( void ) { int n = 16 ; int pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; n = 12 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; n = 128 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; return 0 ; }"}
{"text": "Program c untuk mencari kedudukan hanya set bit dalam nombor tertentu", "code": "#include <stdio.h>"}
{"text": "Fungsi utiliti untuk memeriksa sama ada n adalah kuasa 2 atau tidak", "code": "int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; }"}
{"text": "Mengembalikan kedudukan satu -satunya set bit dalam 'n'", "code": "int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned count = 0 ;"}
{"text": "Satu demi satu bergerak satu -satunya set bit ke kanan sehingga sampai ke hujungnya", "code": "while ( n ) { n = n >> 1 ;"}
{"text": "Peningkatan kiraan peralihan", "code": "++ count ; } return count ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( void ) { int n = 0 ; int pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; n = 12 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; n = 128 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; return 0 ; }"}
{"text": "Program c untuk menukar dua nombor tanpa menggunakan pemboleh ubah sementara", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 10 , y = 5 ;"}
{"text": "Kod untuk menukar 'x' dan 'y' x sekarang menjadi 50", "code": "x = x * y ;"}
{"text": "Y menjadi 10", "code": "y = x / y ;"}
{"text": "x menjadi 5", "code": "x = x / y ; printf ( \" After ▁ Swapping : ▁ x ▁ = ▁ % d , ▁ y ▁ = ▁ % d \" , x , y ) ; return 0 ; }"}
{"text": "C Kod untuk menukar menggunakan XOR", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 10 , y = 5 ;"}
{"text": "Kod untuk menukar 'x' (1010) dan 'y' (0101) x sekarang menjadi 15 (1111)", "code": "x = x ^ y ;"}
{"text": "y menjadi 10 (1010)", "code": "y = x ^ y ;"}
{"text": "x menjadi 5 (0101)", "code": "x = x ^ y ; printf ( \" After ▁ Swapping : ▁ x ▁ = ▁ % d , ▁ y ▁ = ▁ % d \" , x , y ) ; return 0 ; }"}
{"text": "Program c untuk melaksanakan pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Fungsi swap", "code": "void swap ( int * xp , int * yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; * xp = * xp ^ * yp ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int x = 10 ; swap ( & x , & x ) ; printf ( \" After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ % d \" , x ) ; return 0 ; }"}
{"text": "Program c untuk menggantikan setiap elemen dengan elemen terbesar di sebelah kanan", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk menggantikan setiap elemen dengan elemen terbesar seterusnya", "code": "void nextGreatest ( int arr [ ] , int size ) {"}
{"text": "Memulakan elemen terbesar seterusnya", "code": "int max_from_right = arr [ size - 1 ] ;"}
{"text": "Elemen terbesar seterusnya untuk elemen paling kanan selalu - 1", "code": "arr [ size - 1 ] = -1 ;"}
{"text": "Ganti semua elemen lain dengan yang paling besar seterusnya", "code": "for ( int i = size - 2 ; i >= 0 ; i -- ) {"}
{"text": "Simpan elemen semasa (diperlukan kemudian untuk mengemas kini elemen terbesar seterusnya)", "code": "int temp = arr [ i ] ;"}
{"text": "Ganti elemen semasa dengan yang paling besar seterusnya", "code": "arr [ i ] = max_from_right ;"}
{"text": "Kemas kini elemen terbesar, jika diperlukan", "code": "if ( max_from_right < temp ) max_from_right = temp ; } }"}
{"text": "Fungsi utiliti yang mencetak array", "code": "void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nextGreatest ( arr , size ) ; printf ( \" The ▁ modified ▁ array ▁ is : ▁ STRNEWLINE \" ) ; printArray ( arr , size ) ; return ( 0 ) ; }"}
{"text": "Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya dua elemen dalam array. Fungsi ini mengembalikan nilai negatif jika array disusun dalam penurunan urutan. Pulangan 0 jika elemen sama", "code": "int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_size ; i ++ ) { for ( j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ;"}
{"text": "Fungsi panggilan", "code": "printf ( \" Maximum ▁ difference ▁ is ▁ % d \" , maxDiff ( arr , 5 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program c untuk mencari elemen maksimum", "code": "#include <stdio.h>"}
{"text": "berfungsi untuk mencari elemen maksimum", "code": "int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }"}
{"text": "Program pemacu untuk menyemak fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ maximum ▁ element ▁ is ▁ % d \" , findMaximum ( arr , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Kes asas: Hanya satu elemen yang terdapat dalam ARR [rendah. . tinggi]", "code": "if ( low == high ) return arr [ low ] ;"}
{"text": "Sekiranya terdapat dua elemen dan pertama lebih besar maka elemen pertama adalah maksimum", "code": "if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ;"}
{"text": "Sekiranya terdapat dua elemen dan kedua lebih besar maka elemen kedua adalah maksimum", "code": "if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ;"}
{"text": "Sekiranya kita mencapai titik di mana arr [pertengahan] lebih besar daripada kedua -dua elemen bersebelahannya arr [pertengahan - 1] dan arr [pertengahan + 1], maka arr [pertengahan] adalah elemen maksimum", "code": "if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ;"}
{"text": "Sekiranya ARR [pertengahan] lebih besar daripada elemen seterusnya dan lebih kecil daripada elemen sebelumnya maka maksimum terletak di sebelah kiri pertengahan", "code": "if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ;"}
{"text": "Apabila arr [pertengahan] lebih besar daripada arr [pertengahan - 1] dan lebih kecil daripada arr [pertengahan + 1]", "code": "else return findMaximum ( arr , mid + 1 , high ) ; }"}
{"text": "Program pemacu untuk menyemak fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 3 , 50 , 10 , 9 , 7 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ maximum ▁ element ▁ is ▁ % d \" , findMaximum ( arr , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Inisialisasi semua tuduhan dalam array countsmaller sebagai 0", "code": "for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ i ] ) countSmaller [ i ] ++ ; } } }"}
{"text": "Fungsi utiliti yang mencetak array pada baris", "code": "void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 12 , 10 , 5 , 4 , 2 , 20 , 6 , 1 , 0 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * low = ( int * ) malloc ( sizeof ( int ) * n ) ; constructLowerArray ( arr , low , n ) ; printArray ( low , n ) ; return 0 ; }"}
{"text": "Nod pokok avl", "code": "struct node { int key ; struct node * left ; struct node * right ; int height ;"}
{"text": "saiz pokok yang berakar dengan nod ini", "code": "int size ; } ;"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) ;"}
{"text": "Fungsi utiliti untuk mendapatkan ketinggian pokok yang berakar dengan n", "code": "int height ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> height ; }"}
{"text": "Fungsi utiliti hingga saiz pokok yang berakar dengan n", "code": "int size ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> size ; }"}
{"text": "Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Fungsi pembantu yang memperuntukkan nod baru dengan kunci yang diberikan dan null kiri dan kanan.", "code": "struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ;"}
{"text": "nod baru pada mulanya ditambah pada daun", "code": "node -> height = 1 ; node -> size = 1 ; return ( node ) ; }"}
{"text": "Fungsi utiliti ke kanan berputar subtree berakar dengan y", "code": "struct node * rightRotate ( struct node * y ) { struct node * x = y -> left ; struct node * T2 = x -> right ;"}
{"text": "Melakukan putaran", "code": "x -> right = y ; y -> left = T2 ;"}
{"text": "Kemas kini ketinggian", "code": "y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ;"}
{"text": "Saiz kemas kini", "code": "y -> size = size ( y -> left ) + size ( y -> right ) + 1 ; x -> size = size ( x -> left ) + size ( x -> right ) + 1 ;"}
{"text": "Kembalikan akar baru", "code": "return x ; }"}
{"text": "Fungsi utiliti ke kiri berputar subtree berakar dengan x", "code": "struct node * leftRotate ( struct node * x ) { struct node * y = x -> right ; struct node * T2 = y -> left ;"}
{"text": "Melakukan putaran", "code": "y -> left = x ; x -> right = T2 ;"}
{"text": "Kemas kini ketinggian", "code": "x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ;"}
{"text": "Saiz kemas kini", "code": "x -> size = size ( x -> left ) + size ( x -> right ) + 1 ; y -> size = size ( y -> left ) + size ( y -> right ) + 1 ;"}
{"text": "Kembalikan akar baru", "code": "return y ; }"}
{"text": "Dapatkan faktor keseimbangan nod n", "code": "int getBalance ( struct node * N ) { if ( N == NULL ) return 0 ; return height ( N -> left ) - height ( N -> right ) ; }"}
{"text": "Masukkan kunci baru ke pokok yang dibuang dengan nod. Juga, kemas kini * kiraan untuk mengandungi kiraan elemen yang lebih kecil untuk kunci baru", "code": "struct node * insert ( struct node * node , int key , int * count ) {"}
{"text": "1. Lakukan putaran BST biasa", "code": "if ( node == NULL ) return ( newNode ( key ) ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key , count ) ; else { node -> right = insert ( node -> right , key , count ) ;"}
{"text": "Kemas kini kiraan elemen yang lebih kecil untuk kunci", "code": "* count = * count + size ( node -> left ) + 1 ; }"}
{"text": "2. Kemas kini ketinggian dan saiz nod nenek moyang ini", "code": "node -> height = max ( height ( node -> left ) , height ( node -> right ) ) + 1 ; node -> size = size ( node -> left ) + size ( node -> right ) + 1 ;"}
{"text": "3. Dapatkan faktor keseimbangan nod nenek moyang ini untuk memeriksa sama ada nod ini menjadi tidak seimbang", "code": "int balance = getBalance ( node ) ;"}
{"text": "Kes kiri kiri", "code": "if ( balance > 1 && key < node -> left -> key ) return rightRotate ( node ) ;"}
{"text": "Kes yang betul", "code": "if ( balance < -1 && key > node -> right -> key ) return leftRotate ( node ) ;"}
{"text": "Kes Kiri Kiri", "code": "if ( balance > 1 && key > node -> left -> key ) { node -> left = leftRotate ( node -> left ) ; return rightRotate ( node ) ; }"}
{"text": "Kes kiri kanan", "code": "if ( balance < -1 && key < node -> right -> key ) { node -> right = rightRotate ( node -> right ) ; return leftRotate ( node ) ; }"}
{"text": "Kembalikan penunjuk nod (tidak berubah)", "code": "return node ; }"}
{"text": "Fungsi berikut mengemas kini array Countsmaller untuk mengandungi kiraan elemen yang lebih kecil di sebelah kanan.", "code": "void constructLowerArray ( int arr [ ] , int countSmaller [ ] , int n ) { int i , j ; struct node * root = NULL ;"}
{"text": "Inisialisasi semua tuduhan dalam array countsmaller sebagai 0", "code": "for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ;"}
{"text": "Bermula dari elemen paling kanan, masukkan semua elemen satu demi satu dalam pokok AVL dan dapatkan kiraan elemen yang lebih kecil", "code": "for ( i = n - 1 ; i >= 0 ; i -- ) { root = insert ( root , arr [ i ] , & countSmaller [ i ] ) ; } }"}
{"text": "Fungsi utiliti yang mencetak array pada baris", "code": "void printArray ( int arr [ ] , int size ) { int i ; printf ( \" STRNEWLINE \" ) ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 10 , 6 , 15 , 20 , 30 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * low = ( int * ) malloc ( sizeof ( int ) * n ) ; constructLowerArray ( arr , low , n ) ; printf ( \" Following ▁ is ▁ the ▁ constructed ▁ smaller ▁ count ▁ array \" ) ; printArray ( low , n ) ; return 0 ; }"}
{"text": "Program c untuk mencari nombor hilang positif terkecil", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Utiliti untuk bertukar kepada bilangan bulat", "code": "void swap ( int * a , int * b ) { int temp ; temp = * a ; * a = * b ; * b = temp ; }"}
{"text": "Fungsi utiliti yang meletakkan semua nombor positif (0 dan negatif) di sebelah kiri ARR [] dan mengembalikan kiraan nombor tersebut", "code": "int segregate ( int arr [ ] , int size ) { int j = 0 , i ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] <= 0 ) { swap ( & arr [ i ] , & arr [ j ] ) ;"}
{"text": "Kiraan kenaikan bilangan bulat yang tidak positif", "code": "j ++ ; } } return j ; }"}
{"text": "Cari nombor positif terkecil dalam array yang mengandungi semua bilangan bulat positif", "code": "int findMissingPositive ( int arr [ ] , int size ) { int i ;"}
{"text": "Mark Arr [i] seperti yang dikunjungi dengan membuat arr [arr [i] - 1] negatif. Perhatikan bahawa 1 dikurangkan kerana indeks bermula dari 0 dan nombor positif bermula dari 1", "code": "for ( i = 0 ; i < size ; i ++ ) { if ( abs ( arr [ i ] ) - 1 < size && arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; }"}
{"text": "Kembalikan nilai indeks pertama di mana positif", "code": "for ( i = 0 ; i < size ; i ++ ) if ( arr [ i ] > 0 )"}
{"text": "1 ditambah kerana indeks bermula dari 0", "code": "return i + 1 ; return size + 1 ; }"}
{"text": "Cari nombor positif terkecil dalam array yang mengandungi bilangan bulat positif dan negatif", "code": "int findMissing ( int arr [ ] , int size ) {"}
{"text": "Nombor positif dan negatif yang berasingan pertama", "code": "int shift = segregate ( arr , size ) ;"}
{"text": "Menghapuskan array dan hubungi findmissingpositive untuk bahagian positif", "code": "return findMissingPositive ( arr + shift , size - shift ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 0 , 10 , 2 , -10 , -20 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int missing = findMissing ( arr , arr_size ) ; printf ( \" The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ % d ▁ \" , missing ) ; getchar ( ) ; return 0 ; }"}
{"text": "getmissingno mengambil array dan saiz array sebagai hujah", "code": "int getMissingNo ( int a [ ] , int n ) { int i , total ; total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; }"}
{"text": "program untuk menguji fungsi di atas", "code": "int main ( ) { int a [ ] = { 1 , 2 , 4 , 5 , 6 } ; int miss = getMissingNo ( a , 5 ) ; printf ( \" % d \" , miss ) ; getchar ( ) ; }"}
{"text": "Program c untuk mencari unsur berulang dan hilang", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void printTwoElements ( int arr [ ] , int size ) { int i ; printf ( \" The repeating element is \" for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else printf ( \" ▁ % d ▁ \" , abs ( arr [ i ] ) ) ; } printf ( \" and the missing element is \" for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) printf ( \" % d \" , i + 1 ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 7 , 3 , 4 , 5 , 5 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoElements ( arr , n ) ; return 0 ; }"}
{"text": "Program c untuk mencari unsur berulang dan hilang", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Output fungsi ini disimpan pada * x dan * y", "code": "void getTwoElements ( int arr [ ] , int n , int * x , int * y ) {"}
{"text": "Akan memegang xor semua elemen dan nombor dari 1 hingga n", "code": "int xor1 ;"}
{"text": "Hanya mempunyai bit satu set XOR1", "code": "int set_bit_no ; int i ; * x = 0 ; * y = 0 ; xor1 = arr [ 0 ] ;"}
{"text": "Dapatkan xor semua elemen array", "code": "for ( i = 1 ; i < n ; i ++ ) xor1 = xor1 ^ arr [ i ] ;"}
{"text": "Xor hasil sebelumnya dengan nombor dari 1 hingga n", "code": "for ( i = 1 ; i <= n ; i ++ ) xor1 = xor1 ^ i ;"}
{"text": "Dapatkan bit set paling kanan di set_bit_no", "code": "set_bit_no = xor1 & ~ ( xor1 - 1 ) ;"}
{"text": "Sekarang bahagikan unsur -unsur dalam dua set dengan membandingkan bit set kanan XOR1 dengan bit pada kedudukan yang sama dalam setiap elemen. Juga, dapatkan Xors dua set. Kedua -dua XOR adalah elemen output. Dua berikut untuk gelung berfungsi dengan tujuan", "code": "for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit_no )"}
{"text": "arr [i] tergolong dalam set pertama", "code": "* x = * x ^ arr [ i ] ; else"}
{"text": "arr [i] tergolong dalam set kedua", "code": "* y = * y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no )"}
{"text": "Saya tergolong dalam set pertama", "code": "* x = * x ^ i ; else"}
{"text": "Saya tergolong dalam set kedua", "code": "* y = * y ^ i ; }"}
{"text": "* x dan * y memegang elemen output yang dikehendaki", "code": "}"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 , 6 , 2 } ; int * x = ( int * ) malloc ( sizeof ( int ) ) ; int * y = ( int * ) malloc ( sizeof ( int ) ) ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getTwoElements ( arr , n , x , y ) ; printf ( \" ▁ The ▁ missing ▁ element ▁ is ▁ % d \" \" ▁ and ▁ the ▁ repeating ▁ number \" \" ▁ is ▁ % d \" , * x , * y ) ; getchar ( ) ; }"}
{"text": "Penyelesaian naif untuk mencetak semua gabungan 4 elemen dalam [] dengan jumlah yang sama dengan x", "code": "void findFourElements ( int A [ ] , int n , int X ) {"}
{"text": "Betulkan elemen pertama dan cari tiga yang lain", "code": "for ( int i = 0 ; i < n - 3 ; i ++ ) {"}
{"text": "Betulkan elemen kedua dan cari dua yang lain", "code": "for ( int j = i + 1 ; j < n - 2 ; j ++ ) {"}
{"text": "Betulkan elemen ketiga dan cari keempat", "code": "for ( int k = j + 1 ; k < n - 1 ; k ++ ) {"}
{"text": "Cari keempat", "code": "for ( int l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) printf ( \" % d , ▁ % d , ▁ % d , ▁ % d \" , A [ i ] , A [ j ] , A [ k ] , A [ l ] ) ; } } } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int A [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int X = 91 ; findFourElements ( A , n , X ) ; return 0 ; }"}
{"text": "Program c untuk mencari 4 elemen dengan jumlah yang diberikan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Struktur berikut diperlukan untuk menyimpan jumlah pasangan di Aux []", "code": "struct pairSum {"}
{"text": "indeks (int a []) elemen pertama dalam pasangan", "code": "int first ;"}
{"text": "Indeks elemen kedua dalam pasangan", "code": "int sec ;"}
{"text": "Jumlah pasangan", "code": "int sum ; } ;"}
{"text": "Fungsi berikut diperlukan untuk fungsi perpustakaan qsort ()", "code": "int compare ( const void * a , const void * b ) { return ( ( * ( pairSum * ) a ) . sum - ( * ( pairSum * ) b ) . sum ) ; }"}
{"text": "Berfungsi untuk memeriksa sama ada dua pasangan yang diberikan mempunyai unsur biasa atau tidak", "code": "bool noCommon ( struct pairSum a , struct pairSum b ) { if ( a . first == b . first a . first == b . sec a . sec == b . first a . sec == b . sec ) return false ; return true ; }"}
{"text": "Fungsi ini menemui empat elemen dengan jumlah x yang diberikan", "code": "void findFourElements ( int arr [ ] , int n , int X ) { int i , j ;"}
{"text": "Buat array tambahan untuk menyimpan semua jumlah wang", "code": "int size = ( n * ( n - 1 ) ) / 2 ; struct pairSum aux [ size ] ;"}
{"text": "Menjana semua pasangan yang mungkin dari [] dan menyimpan jumlah semua pasangan yang mungkin di Aux []", "code": "int k = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { aux [ k ] . sum = arr [ i ] + arr [ j ] ; aux [ k ] . first = i ; aux [ k ] . sec = j ; k ++ ; } }"}
{"text": "Susun array aux [] menggunakan fungsi perpustakaan untuk menyusun", "code": "qsort ( aux , size , sizeof ( aux [ 0 ] ) , compare ) ;"}
{"text": "Sekarang mulakan dua pembolehubah indeks dari dua sudut array dan gerakkannya ke arah satu sama lain.", "code": "i = 0 ; j = size - 1 ; while ( i < size && j >= 0 ) { if ( ( aux [ i ] . sum + aux [ j ] . sum == X ) && noCommon ( aux [ i ] , aux [ j ] ) ) { printf ( \" % d , ▁ % d , ▁ % d , ▁ % d STRNEWLINE \" , arr [ aux [ i ] . first ] , arr [ aux [ i ] . sec ] , arr [ aux [ j ] . first ] , arr [ aux [ j ] . sec ] ) ; return ; } else if ( aux [ i ] . sum + aux [ j ] . sum < X ) i ++ ; else j -- ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 91 ;"}
{"text": "Panggilan fungsi", "code": "findFourElements ( arr , n , X ) ; return 0 ; }"}
{"text": "Program c untuk mencari jarak min elemen maksimum", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "berfungsi untuk mengembalikan jarak min", "code": "int minDistance ( int arr [ ] , int n ) { int maximum_element = arr [ 0 ] ; int min_dis = n ; int index = 0 ; for ( int i = 1 ; i < n ; i ++ ) {"}
{"text": "kes a", "code": "if ( maximum_element == arr [ i ] ) { min_dis = min ( min_dis , ( i - index ) ) ; index = i ; }"}
{"text": "kes b", "code": "else if ( maximum_element < arr [ i ] ) { maximum_element = arr [ i ] ; min_dis = n ; index = i ; }"}
{"text": "Kes c", "code": "else continue ; } return min_dis ; }"}
{"text": "Program Pemandu", "code": "int main ( ) { int arr [ ] = { 6 , 3 , 1 , 3 , 6 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Minimum ▁ distance ▁ = ▁ \" << minDistance ( arr , n ) ; return 0 ; }"}
{"text": "Program C Rekursif untuk mencari elemen dalam senarai yang dipautkan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h>"}
{"text": "Nod senarai pautan", "code": "struct Node { int key ; struct Node * next ; } ;"}
{"text": "Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala senarai dan int, tolak nod baru di hadapan senarai.", "code": "void push ( struct Node * * head_ref , int new_key ) {"}
{"text": "memperuntukkan nod dimasukkan ke dalam kunci", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> key = new_key ;"}
{"text": "Pautan senarai lama dari nod baru", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "Gerakkan kepala untuk menunjuk ke nod baru", "code": "( * head_ref ) = new_node ; }"}
{"text": "Memeriksa sama ada nilai x ada dalam senarai yang dipautkan", "code": "bool search ( struct Node * head , int x ) {"}
{"text": "Kes asas", "code": "if ( head == NULL ) return false ;"}
{"text": "Sekiranya kunci hadir dalam nod semasa, kembali benar", "code": "if ( head -> key == x ) return true ;"}
{"text": "Berulang untuk senarai baki", "code": "return search ( head -> next , x ) ; }"}
{"text": "Program pemacu untuk menguji fungsi kiraan", "code": "int main ( ) {"}
{"text": "Mulakan dengan senarai kosong", "code": "struct Node * head = NULL ; int x = 21 ;"}
{"text": "Gunakan tolak () untuk membina senarai di bawah 14 -> 21 -> 11 -> 30 -> 10", "code": "push ( & head , 10 ) ; push ( & head , 30 ) ; push ( & head , 11 ) ; push ( & head , 21 ) ; push ( & head , 14 ) ; search ( head , 21 ) ? printf ( \" Yes \" ) : printf ( \" No \" ) ; return 0 ; }"}
{"text": "Memadam nod alternatif senarai bermula dengan kepala", "code": "void deleteAlt ( struct Node * head ) { if ( head == NULL ) return ; struct Node * node = head -> next ; if ( node == NULL ) return ;"}
{"text": "Tukar pautan kepala seterusnya", "code": "head -> next = node -> next ;"}
{"text": "memori percuma yang diperuntukkan untuk nod", "code": "free ( node ) ;"}
{"text": "Secara rekursif memanggil kepala yang baru", "code": "deleteAlt ( head -> next ) ; }"}
{"text": "menunjuk ke nod terakhir dalam 'A'", "code": "struct Node bDummy ; struct Node * bTail = & bDummy ;"}
{"text": "menunjuk ke nod terakhir dalam 'b'", "code": "struct Node * current = source ; aDummy . next = NULL ; bDummy . next = NULL ; while ( current != NULL ) { MoveNode ( & ( aTail -> next ) , t ) ;"}
{"text": "tambah pada ekor 'a'", "code": "aTail = aTail -> next ;"}
{"text": "memajukan ekor 'a'", "code": "if ( current != NULL ) { MoveNode ( & ( bTail -> next ) , t ) ; bTail = bTail -> next ; } } * aRef = aDummy . next ; * bRef = bDummy . next ; }"}
{"text": "Program Ceratif C untuk memeriksa sama ada dua senarai yang dipautkan adalah sama atau tidak", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h>"}
{"text": "Struktur untuk nod senarai yang dipautkan", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Pulangan benar jika senarai dikaitkan a dan b adalah sama, jika tidak palsu", "code": "bool areIdentical ( struct Node * a , struct Node * b ) { while ( a != NULL && b != NULL ) { if ( a -> data != b -> data ) return false ;"}
{"text": "Sekiranya kita sampai di sini, maka A dan B tidak batal dan data mereka sama, jadi pindah ke nod seterusnya dalam kedua -dua senarai", "code": "a = a -> next ; b = b -> next ; }"}
{"text": "Jika senarai yang dipautkan adalah sama, maka 'A' dan 'B' mesti dibatalkan pada ketika ini.", "code": "return ( a == NULL && b == NULL ) ; }"}
{"text": "Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala senarai dan int, tolak nod baru di hadapan senarai.", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "Peruntukkan nod dimasukkan ke dalam data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "Pautan senarai lama dari nod baru", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "Gerakkan kepala untuk menunjuk ke nod baru", "code": "( * head_ref ) = new_node ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Senarai yang dipautkan yang dibina ialah: A: 3 -> 2 -> 1 B: 3 -> 2 -> 1", "code": "struct Node * a = NULL ; struct Node * b = NULL ; push ( & a , 1 ) ; push ( & a , 2 ) ; push ( & a , 3 ) ; push ( & b , 1 ) ; push ( & b , 2 ) ; push ( & b , 3 ) ; areIdentical ( a , b ) ? printf ( \" Identical \" ) : printf ( \" Not ▁ identical \" ) ; return 0 ; }"}
{"text": "Fungsi C Rekursif untuk memeriksa sama ada dua senarai yang dipautkan adalah sama atau tidak", "code": "bool areIdentical ( struct Node * a , struct Node * b ) {"}
{"text": "Sekiranya kedua -dua senarai kosong", "code": "if ( a == NULL && b == NULL ) return true ;"}
{"text": "Jika kedua -dua senarai tidak kosong, maka data nod semasa mesti sepadan, dan sama harus rekursif benar untuk nod lain.", "code": "if ( a != NULL && b != NULL ) return ( a -> data == b -> data ) && areIdentical ( a -> next , b -> next ) ;"}
{"text": "Sekiranya kita sampai di sini, maka salah satu senarai kosong dan lain -lain tidak", "code": "return false ; }"}
{"text": "Program C untuk menyusun senarai yang dipautkan 0 s, 1 s atau 2 s", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod senarai pautan", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Berfungsi untuk menyusun senarai terikat 0 s, 1 s dan 2 s", "code": "void sortList ( struct Node * head ) {"}
{"text": "Mulakan kiraan '0', '1' dan '2' sebagai 0", "code": "int count [ 3 ] = { 0 , 0 , 0 } ; struct Node * ptr = head ;"}
{"text": "Kira Jumlah '0', '1' dan '2' * Count [0] akan menyimpan jumlah bilangan '0' s * kiraan [1] akan menyimpan jumlah '1' s * Count [2] akan menyimpan jumlah '2'", "code": "while ( ptr != NULL ) { count [ ptr -> data ] += 1 ; ptr = ptr -> next ; } int i = 0 ; ptr = head ;"}
{"text": "Katakanlah kiraan [0] = n1, hitung [1] = n2 dan hitung [2] = n3 * Sekarang mulakan senarai melintasi dari nod kepala, * 1) isi senarai dengan 0, sehingga n1> 0 * 2) Isi senarai dengan 1, sehingga n2> 0 * 3) Isi senarai dengan 2, sehingga n3> 0", "code": "while ( ptr != NULL ) { if ( count [ i ] == 0 ) ++ i ; else { ptr -> data = i ; -- count [ i ] ; ptr = ptr -> next ; } } }"}
{"text": "Berfungsi untuk menolak nod", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "Peruntukkan nod dimasukkan ke dalam data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "Pautan senarai lama dari nod baru", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "Gerakkan kepala untuk menunjuk ke nod baru", "code": "( * head_ref ) = new_node ; }"}
{"text": "Berfungsi untuk mencetak senarai yang dipautkan", "code": "void printList ( struct Node * node ) { while ( node != NULL ) { printf ( \" % d ▁ \" , node -> data ) ; node = node -> next ; } printf ( \" n \" ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( void ) {"}
{"text": "Senarai yang dipautkan yang dibina ialah 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 8 -> 9 -> Null", "code": "struct Node * head = NULL ; push ( & head , 0 ) ; push ( & head , 1 ) ; push ( & head , 0 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; printf ( \" Linked ▁ List ▁ Before ▁ Sorting STRNEWLINE \" ) ; printList ( head ) ; sortList ( head ) ; printf ( \" Linked ▁ List ▁ After ▁ Sorting STRNEWLINE \" ) ; printList ( head ) ; return 0 ; }"}
{"text": "Program c untuk menyusun semula senarai yang dipautkan sedemikian", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "Nod senarai yang dipautkan", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Fungsi utiliti untuk membuat nod baru", "code": "Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; }"}
{"text": "REARRANGES Diberi senarai yang dipautkan supaya semua nod yang diposisikan adalah sebelum kedudukan ganjil. Mengembalikan ketua senarai baru yang dipautkan.", "code": "Node * rearrangeEvenOdd ( Node * head ) {"}
{"text": "Kes sudut", "code": "if ( head == NULL ) return NULL ;"}
{"text": "Memulakan nod pertama senarai walaupun dan ganjil", "code": "Node * odd = head ; Node * even = head -> next ;"}
{"text": "Ingat nod pertama senarai walaupun supaya kami dapat menyambungkan senarai walaupun pada akhir senarai ganjil.", "code": "Node * evenFirst = even ; while ( 1 ) {"}
{"text": "Sekiranya tidak ada lagi nod, maka sambungkan nod pertama senarai bahkan ke nod terakhir senarai ganjil", "code": "if ( ! odd || ! even || ! ( even -> next ) ) { odd -> next = evenFirst ; break ; }"}
{"text": "Menghubungkan nod ganjil", "code": "odd -> next = even -> next ; odd = even -> next ;"}
{"text": "Sekiranya tidak ada lagi nod selepas ganjil semasa.", "code": "if ( odd -> next == NULL ) { even -> next = NULL ; odd -> next = evenFirst ; break ; }"}
{"text": "Menyambung walaupun nod", "code": "even -> next = odd -> next ; even = odd -> next ; } return head ; }"}
{"text": "Fungsi utiliti untuk mencetak senarai yang dipautkan", "code": "void printlist ( Node * node ) { while ( node != NULL ) { cout << node -> data << \" - > \" ; node = node -> next ; } cout << \" NULL \" << endl ; }"}
{"text": "Kod pemacu", "code": "int main ( void ) { Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; cout << \" Given ▁ Linked ▁ List STRNEWLINE \" ; printlist ( head ) ; head = rearrangeEvenOdd ( head ) ; cout << \" Modified Linked List \" ; printlist ( head ) ; return 0 ; }"}
{"text": "Program c untuk menunjukkan penghapusan nod terakhir dalam senarai yang berkaitan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod senarai yang dipautkan", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Berfungsi untuk memadam kejadian terakhir", "code": "void deleteLast ( struct Node * head , int x ) { struct Node * temp = head , * ptr = NULL ; while ( temp ) {"}
{"text": "Sekiranya dijumpai kunci, kemas kini", "code": "if ( temp -> data == x ) ptr = temp ; temp = temp -> next ; }"}
{"text": "Sekiranya kejadian terakhir adalah nod terakhir", "code": "if ( ptr != NULL && ptr -> next == NULL ) { temp = head ; while ( temp -> next != ptr ) temp = temp -> next ; temp -> next = NULL ; }"}
{"text": "Sekiranya bukan nod terakhir", "code": "if ( ptr != NULL && ptr -> next != NULL ) { ptr -> data = ptr -> next -> data ; temp = ptr -> next ; ptr -> next = ptr -> next -> next ; free ( temp ) ; } }"}
{"text": "Fungsi utiliti untuk membuat nod baru dengan kunci yang diberikan", "code": "struct Node * newNode ( int x ) { struct Node * node = malloc ( sizeof ( struct Node * ) ) ; node -> data = x ; node -> next = NULL ; return node ; }"}
{"text": "Fungsi ini mencetak kandungan senarai yang dipautkan bermula dari nod yang diberikan", "code": "void display ( struct Node * head ) { struct Node * temp = head ; if ( head == NULL ) { printf ( \" NULL STRNEWLINE \" ) ; return ; } while ( temp != NULL ) { printf ( \" % d ▁ - - > ▁ \" , temp -> data ) ; temp = temp -> next ; } printf ( \" NULL STRNEWLINE \" ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; head -> next -> next -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next -> next -> next = newNode ( 4 ) ; printf ( \" Created ▁ Linked ▁ list : ▁ \" ) ; display ( head ) ; deleteLast ( head , 4 ) ; printf ( \" List ▁ after ▁ deletion ▁ of ▁ 4 : ▁ \" ) ; display ( head ) ; return 0 ; }"}
{"text": "Program C untuk memeriksa panjang senarai pautan yang diberikan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Menentukan struktur", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Berfungsi untuk memeriksa panjang senarai pautan", "code": "int LinkedListLength ( struct Node * head ) { while ( head && head -> next ) { head = head -> next -> next ; } if ( ! head ) return 0 ; return 1 ; }"}
{"text": "Fungsi tolak", "code": "void push ( struct Node * * head , int info ) {"}
{"text": "Peruntukan nod", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Maklumat ke dalam nod", "code": "node -> data = info ;"}
{"text": "Seterusnya nod baru ke kepala", "code": "node -> next = ( * head ) ;"}
{"text": "kepala titik ke nod baru", "code": "( * head ) = node ; }"}
{"text": "Fungsi pemacu", "code": "int main ( void ) { struct Node * head = NULL ;"}
{"text": "Menambah elemen ke senarai yang dipautkan", "code": "push ( & head , 4 ) ; push ( & head , 5 ) ; push ( & head , 7 ) ; push ( & head , 2 ) ; push ( & head , 9 ) ; push ( & head , 6 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 0 ) ; push ( & head , 5 ) ; push ( & head , 5 ) ; int check = LinkedListLength ( head ) ;"}
{"text": "Memeriksa panjang senarai pautan", "code": "if ( check == 0 ) { printf ( \" Even STRNEWLINE \" ) ; } else { printf ( \" Odd STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "menunjuk kepada penunjuk hasil terakhir", "code": "struct Node * * lastPtrRef = & result ; while ( 1 ) { if ( a == NULL ) { * lastPtrRef = b ; break ; } else if ( b == NULL ) { * lastPtrRef = a ; break ; } if ( a -> data <= b -> data ) { MoveNode ( lastPtrRef , & a ) ; } else { MoveNode ( lastPtrRef , & b ) ; }"}
{"text": "rumit: maju ke medan seterusnya \". Seterusnya\" medan", "code": "lastPtrRef = & ( ( * lastPtrRef ) -> next ) ; } return ( result ) ; }"}
{"text": "C Program untuk membuat nod tengah sebagai ketua senarai yang dipautkan.", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod senarai pautan", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Berfungsi untuk mendapatkan pertengahan dan ditetapkan pada permulaan senarai yang dipautkan", "code": "void setMiddleHead ( struct Node * * head ) { if ( * head == NULL ) return ;"}
{"text": "Untuk melintasi senarai nod satu demi satu", "code": "struct Node * one_node = ( * head ) ;"}
{"text": "Untuk melintasi senarai nod dengan melangkau satu.", "code": "struct Node * two_node = ( * head ) ;"}
{"text": "Untuk menjejaki sebelumnya", "code": "struct Node * prev = NULL ; while ( two_node != NULL && two_node -> next != NULL ) {"}
{"text": "untuk nod sebelumnya nod tengah", "code": "prev = one_node ;"}
{"text": "gerakkan satu nod setiap kali", "code": "two_node = two_node -> next -> next ;"}
{"text": "gerakkan dua nod setiap kali", "code": "one_node = one_node -> next ; }"}
{"text": "Tetapkan nod tengah di kepala", "code": "prev -> next = prev -> next -> next ; one_node -> next = ( * head ) ; ( * head ) = one_node ; }"}
{"text": "Untuk memasukkan nod pada permulaan senarai yang dipautkan.", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "memperuntukkan nod", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "Pautan senarai lama dari nod baru", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "Gerakkan kepala untuk menunjuk ke nod baru", "code": "( * head_ref ) = new_node ; }"}
{"text": "Fungsi untuk mencetak senarai yang dipautkan", "code": "void printList ( struct Node * ptr ) { while ( ptr != NULL ) { printf ( \" % d ▁ \" , ptr -> data ) ; ptr = ptr -> next ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Fungsi pemacu", "code": "int main ( ) {"}
{"text": "Buat senarai 5 nod", "code": "struct Node * head = NULL ; int i ; for ( i = 5 ; i > 0 ; i -- ) push ( & head , i ) ; printf ( \" ▁ list ▁ before : ▁ \" ) ; printList ( head ) ; setMiddleHead ( & head ) ; printf ( \" ▁ list ▁ After : ▁ \" ) ; printList ( head ) ; return 0 ; }"}
{"text": "Diberikan nod sebagai prev_node, masukkan nod baru selepas nod yang diberikan", "code": "void insertAfter ( struct Node * prev_node , int new_data ) {"}
{"text": "1. Periksa sama ada prev_node yang diberikan adalah batal", "code": "if ( prev_node == NULL ) { printf ( \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" ) ; return ; }"}
{"text": "2. memperuntukkan nod baru 3. Masukkan data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "4. Buat nod baru seterusnya sebagai prev_node yang berikutnya", "code": "new_node -> next = prev_node -> next ;"}
{"text": "5. Buat yang seterusnya dari prev_node sebagai new_node", "code": "prev_node -> next = new_node ;"}
{"text": "6. Buat prev_node seperti sebelumnya dari new_node", "code": "new_node -> prev = prev_node ;"}
{"text": "7. Tukar sebelumnya dari nod seterusnya New_node", "code": "if ( new_node -> next != NULL ) new_node -> next -> prev = new_node ; }"}
{"text": "C Pelaksanaan senarai dikaitkan dengan efisien memori", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <inttypes.h>"}
{"text": "Struktur nod dari senarai dikaitkan dua kali ganda memori", "code": "struct Node { int data ; struct Node * npx ;"}
{"text": "Xor nod seterusnya dan sebelumnya", "code": "} ;"}
{"text": "Mengembalikan nilai xored alamat nod", "code": "struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; }"}
{"text": "Masukkan nod pada permulaan senarai berkaitan xored dan menjadikan nod yang baru dimasukkan sebagai kepala", "code": "void insert ( struct Node * * head_ref , int data ) {"}
{"text": "Memperuntukkan memori untuk nod baru", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = data ;"}
{"text": "Oleh kerana nod baru dimasukkan pada mulanya, npx nod baru akan sentiasa menjadi XOR kepala semasa dan null", "code": "new_node -> npx = * head_ref ;"}
{"text": "Sekiranya senarai yang dipautkan tidak kosong, maka npx nod kepala semasa akan menjadi xor nod baru dan nod di sebelah kepala semasa", "code": "if ( * head_ref != NULL ) {"}
{"text": "* (head_ref) -> npx adalah xor null dan seterusnya. Oleh itu, jika kita melakukannya dengan null, kita dapatkan seterusnya", "code": "( * head_ref ) -> npx = XOR ( new_node , ( * head_ref ) -> npx ) ; }"}
{"text": "Tukar kepala", "code": "* head_ref = new_node ; }"}
{"text": "Cetakan kandungan senarai dikaitkan dua kali ke arah hadapan", "code": "void printList ( struct Node * head ) { struct Node * curr = head ; struct Node * prev = NULL ; struct Node * next ; printf ( \" Following ▁ are ▁ the ▁ nodes ▁ of ▁ Linked ▁ List : ▁ STRNEWLINE \" ) ; while ( curr != NULL ) {"}
{"text": "Cetak nod semasa", "code": "printf ( \" % d ▁ \" , curr -> data ) ;"}
{"text": "Dapatkan alamat nod seterusnya: curr -> npx seterusnya ^ prev, jadi curr -> npx ^ prev akan seterusnya ^ prev ^ prev yang seterusnya", "code": "next = XOR ( prev , curr -> npx ) ;"}
{"text": "Kemas kini Prev dan Curr untuk lelaran seterusnya", "code": "prev = curr ; curr = next ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Buat Ketua Senarai Berkaitan Berikut:> 40 <--> 20 <--> 10 <--> 10 <-->", "code": "struct Node * head = NULL ; insert ( & head , 10 ) ; insert ( & head , 20 ) ; insert ( & head , 30 ) ; insert ( & head , 40 ) ;"}
{"text": "Cetak senarai yang dibuat", "code": "printList ( head ) ; return ( 0 ) ; }"}
{"text": "Nod pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul", "code": "struct node { int data ; struct node * left ; struct node * right ; } ; void printKDistant ( struct node * root , int k ) { if ( root == NULL k < 0 ) return ; if ( k == 0 ) { printf ( \" % d ▁ \" , root -> data ) ; return ; } printKDistant ( root -> left , k - 1 ) ; printKDistant ( root -> right , k - 1 ) ; }"}
{"text": "Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null.", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Pokok binari yang dibina ialah 1 / \\ 2 3 / \\ / 4 5 8 8", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 8 ) ; printKDistant ( root , 2 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program untuk mencetak pokok binari dalam 2D", "code": "#include <stdio.h> NEW_LINE #include <malloc.h> NEW_LINE #define COUNT  10"}
{"text": "Nod pokok binari", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "Fungsi penolong untuk memperuntukkan nod baru", "code": "struct Node * newNode ( int data ) { struct Node * node = malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; }"}
{"text": "Berfungsi untuk mencetak pokok binari di 2D ia melakukan traversal inorder terbalik", "code": "void print2DUtil ( struct Node * root , int space ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return ;"}
{"text": "Meningkatkan Jarak Antara Tahap", "code": "space += COUNT ;"}
{"text": "Proses anak yang betul terlebih dahulu", "code": "print2DUtil ( root -> right , space ) ;"}
{"text": "Cetak nod semasa selepas dikira ruang", "code": "printf ( \" STRNEWLINE \" ) ; for ( int i = COUNT ; i < space ; i ++ ) printf ( \" ▁ \" ) ; printf ( \" % d STRNEWLINE \" , root -> data ) ;"}
{"text": "Proses kiri anak", "code": "print2DUtil ( root -> left , space ) ; }"}
{"text": "Wrapper Over Print2Dutil ()", "code": "void print2D ( struct Node * root ) {"}
{"text": "Lulus kiraan ruang awal sebagai 0", "code": "print2DUtil ( root , 0 ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> left -> left = newNode ( 12 ) ; root -> right -> left -> right = newNode ( 13 ) ; root -> right -> right -> left = newNode ( 14 ) ; root -> right -> right -> right = newNode ( 15 ) ; print2D ( root ) ; return 0 ; }"}
{"text": "Program c untuk mencetak pandangan kiri pokok binari", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Fungsi utiliti untuk membuat nod pokok binari baru", "code": "struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Fungsi rekursif untuk mencetak pandangan kiri pokok binari.", "code": "void leftViewUtil ( struct node * root , int level , int * max_level ) {"}
{"text": "Kes asas", "code": "if ( root == NULL ) return ;"}
{"text": "Sekiranya ini adalah nod pertama tahapnya", "code": "if ( * max_level < level ) { printf ( \" % d TABSYMBOL \" , root -> data ) ; * max_level = level ; }"}
{"text": "Berulang untuk subtrees kiri dan kanan", "code": "leftViewUtil ( root -> left , level + 1 , max_level ) ; leftViewUtil ( root -> right , level + 1 , max_level ) ; }"}
{"text": "Pembungkus di LeftViewUtil ()", "code": "void leftView ( struct node * root ) { int max_level = 0 ; leftViewUtil ( root , 1 , & max_level ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { struct node * root = newNode ( 12 ) ; root -> left = newNode ( 10 ) ; root -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 25 ) ; root -> right -> right = newNode ( 40 ) ; leftView ( root ) ; return 0 ; }"}
{"text": "C pelaksanaan pendekatan", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Berfungsi untuk mengembalikan kiraan rentetan berputar yang mempunyai lebih banyak vokal pada separuh pertama daripada separuh kedua", "code": "int cntRotations ( char s [ ] , int n ) { int lh = 0 , rh = 0 , i , ans = 0 ;"}
{"text": "Kirakan bilangan vokal pada separuh pertama", "code": "for ( i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { lh ++ ; }"}
{"text": "Kirakan bilangan vokal pada separuh kedua", "code": "for ( i = n / 2 ; i < n ; ++ i ) if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { rh ++ ; }"}
{"text": "Periksa apakah yang pertama - separuh mempunyai lebih banyak vokal", "code": "if ( lh > rh ) ans ++ ;"}
{"text": "Periksa semua putaran yang mungkin", "code": "for ( i = 1 ; i < n ; ++ i ) { if ( s [ i - 1 ] == ' a ' s [ i - 1 ] == ' e ' s [ i - 1 ] == ' i ' s [ i - 1 ] == ' o ' s [ i - 1 ] == ' u ' ) { rh ++ ; lh -- ; } if ( s [ ( i - 1 + n / 2 ) % n ] == ' a ' || s [ ( i - 1 + n / 2 ) % n ] == ' e ' || s [ ( i - 1 + n / 2 ) % n ] == ' i ' || s [ ( i - 1 + n / 2 ) % n ] == ' o ' || s [ ( i - 1 + n / 2 ) % n ] == ' u ' ) { rh -- ; lh ++ ; } if ( lh > rh ) ans ++ ; }"}
{"text": "Kembalikan jawapannya", "code": "return ans ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { char s [ ] = \" abecidft \" ; int n = strlen ( s ) ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" % d \" , cntRotations ( s , n ) ) ; return 0 ; }"}
{"text": "Program c untuk memutar blok senarai yang dipautkan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Nod senarai pautan", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Fungsi rekursif untuk memutar satu blok", "code": "struct Node * rotateHelper ( struct Node * blockHead , struct Node * blockTail , int d , struct Node * * tail , int k ) { if ( d == 0 ) return blockHead ;"}
{"text": "Putar mengikut arah jam", "code": "if ( d > 0 ) { struct Node * temp = blockHead ; for ( int i = 1 ; temp -> next -> next && i < k - 1 ; i ++ ) temp = temp -> next ; blockTail -> next = blockHead ; * tail = temp ; return rotateHelper ( blockTail , temp , d - 1 , tail , k ) ; }"}
{"text": "Putar anti - mengikut arah jam", "code": "if ( d < 0 ) { blockTail -> next = blockHead ; * tail = blockHead ; return rotateHelper ( blockHead -> next , blockHead , d + 1 , tail , k ) ; } }"}
{"text": "Berfungsi untuk memutar blok senarai yang dipautkan", "code": "struct Node * rotateByBlocks ( struct Node * head , int k , int d ) {"}
{"text": "Sekiranya panjang adalah 0 atau 1 kepala kembali", "code": "if ( ! head ! head -> next ) return head ;"}
{"text": "Sekiranya ijazah putaran adalah 0, kembali kepala", "code": "if ( d == 0 ) return head ; struct Node * temp = head , * tail = NULL ;"}
{"text": "Melintasi elemen terakhir blok ini", "code": "int i ; for ( i = 1 ; temp -> next && i < k ; i ++ ) temp = temp -> next ;"}
{"text": "menyimpan nod pertama blok seterusnya", "code": "struct Node * nextBlock = temp -> next ;"}
{"text": "Jika nod blok ini kurang daripada k. Putar blok ini juga", "code": "if ( i < k ) head = rotateHelper ( head , temp , d % k , & tail , i ) ; else head = rotateHelper ( head , temp , d % k , & tail , k ) ;"}
{"text": "Tambahkan kepala baru blok seterusnya ke ekor blok ini", "code": "tail -> next = rotateByBlocks ( nextBlock , k , d % k ) ;"}
{"text": "Kembali Ketua Senarai Terkait Dikemaskini", "code": "return head ; }"}
{"text": "Berfungsi untuk menolak nod", "code": "void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; }"}
{"text": "Berfungsi untuk mencetak senarai yang dipautkan", "code": "void printList ( struct Node * node ) { while ( node != NULL ) { printf ( \" % d ▁ \" , node -> data ) ; node = node -> next ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Mulakan dengan senarai kosong", "code": "struct Node * head = NULL ;"}
{"text": "Buat Senarai 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> Null", "code": "for ( int i = 9 ; i > 0 ; i -= 1 ) push ( & head , i ) ; printf ( \" Given ▁ linked ▁ list ▁ STRNEWLINE \" ) ; printList ( head ) ;"}
{"text": "K ialah saiz blok dan d adalah bilangan putaran di setiap blok.", "code": "int k = 3 , d = 2 ; head = rotateByBlocks ( head , k , d ) ; printf ( \" Rotated by blocks Linked list \" printList ( head ) ; return ( 0 ) ; }"}
{"text": "Berfungsi untuk memadam nod pertama senarai yang dipautkan bulat", "code": "void DeleteFirst ( struct Node * * head ) { struct Node * previous = * head , * firstNode = * head ;"}
{"text": "periksa sama ada senarai tidak mempunyai nod jika tidak kemudian kembali", "code": "if ( * head == NULL ) { printf ( \" List is empty \" return ; }"}
{"text": "Semak sama ada senarai mempunyai nod tunggal jika ya kemudian padamkannya dan kembali", "code": "if ( previous -> next == previous ) { * head = NULL ; return ; }"}
{"text": "melintasi nod kedua ke yang pertama", "code": "while ( previous -> next != * head ) { previous = previous -> next ; }"}
{"text": "sekarang sebelumnya adalah alamat pautan nod terakhir dan nod pertama (firstNode) dimasukkan ke dalam pautan nod terakhir (sebelumnya)", "code": "previous -> next = firstNode -> next ;"}
{"text": "buat nod kedua sebagai nod kepala", "code": "* head = previous -> next ; free ( firstNode ) ; return ; }"}
{"text": "Fungsi Padam nod terakhir senarai yang dipautkan bulat", "code": "void DeleteLast ( struct Node * * head ) { struct Node * current = * head , * temp = * head , * previous ;"}
{"text": "periksa sama ada senarai tidak mempunyai nod jika tidak kemudian kembali", "code": "if ( * head == NULL ) { printf ( \" List is empty \" return ; }"}
{"text": "Semak sama ada senarai mempunyai nod tunggal jika ya kemudian padamkannya dan kembali", "code": "if ( current -> next == current ) { * head = NULL ; return ; }"}
{"text": "gerakkan nod pertama ke terakhir sebelumnya", "code": "while ( current -> next != * head ) { previous = current ; current = current -> next ; } previous -> next = current -> next ; * head = previous -> next ; free ( current ) ; return ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Dimensi matriks", "code": "const int N = 5 ;"}
{"text": "Struktur matriks efisien memori", "code": "struct Matrix { int * A ; int size ; } ;"}
{"text": "Berfungsi untuk menetapkan nilai dalam matriks", "code": "void Set ( struct Matrix * m , int i , int j , int x ) { if ( i >= j ) m -> A [ ( ( m -> size ) * ( j - 1 ) - ( ( ( j - 2 ) * ( j - 1 ) ) / 2 ) + ( i - j ) ) ] = x ; }"}
{"text": "Berfungsi untuk menyimpan nilai dalam matriks", "code": "int Get ( struct Matrix m , int i , int j ) { if ( i >= j ) return m . A [ ( ( m . size ) * ( j - 1 ) - ( ( ( j - 2 ) * ( j - 1 ) ) / 2 ) + ( i - j ) ) ] ; else return 0 ; }"}
{"text": "Berfungsi untuk memaparkan unsur -unsur matriks", "code": "void Display ( struct Matrix m ) {"}
{"text": "Melintasi matriks", "code": "for ( int i = 1 ; i <= m . size ; i ++ ) { for ( int j = 1 ; j <= m . size ; j ++ ) { if ( i >= j ) printf ( \" % d ▁ \" , m . A [ ( ( m . size ) * ( j - 1 ) - ( ( ( j - 2 ) * ( j - 1 ) ) / 2 ) + ( i - j ) ) ] ) ; else printf ( \"0 ▁ \" ) ; } printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Berfungsi untuk menghasilkan matriks yang cekap", "code": "struct Matrix createMat ( int Mat [ N ] [ N ] ) {"}
{"text": "Mengisytiharkan matriks yang cekap", "code": "struct Matrix mat ;"}
{"text": "Inisialisasi matriks", "code": "mat . size = N ; mat . A = ( int * ) malloc ( mat . size * ( mat . size + 1 ) / 2 * sizeof ( int ) ) ;"}
{"text": "Tetapkan nilai dalam matriks", "code": "for ( int i = 1 ; i <= mat . size ; i ++ ) { for ( int j = 1 ; j <= mat . size ; j ++ ) { Set ( & mat , i , j , Mat [ i - 1 ] [ j - 1 ] ) ; } }"}
{"text": "Kembalikan matriks", "code": "return mat ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberikan input", "code": "int Mat [ 5 ] [ 5 ] = { { 1 , 0 , 0 , 0 , 0 } , { 1 , 2 , 0 , 0 , 0 } , { 1 , 2 , 3 , 0 , 0 } , { 1 , 2 , 3 , 4 , 0 } , { 1 , 2 , 3 , 4 , 5 } } ;"}
{"text": "Fungsi panggilan untuk membuat matriks yang cekap memori", "code": "struct Matrix mat = createMat ( Mat ) ;"}
{"text": "Fungsi panggilan untuk mencetak matriks", "code": "Display ( mat ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengira subarrays di mana jumlah elemen pada kedudukan walaupun dan ganjil adalah sama", "code": "void countSubarrays ( int arr [ ] , int n ) {"}
{"text": "Memulakan pembolehubah", "code": "int count = 0 ;"}
{"text": "Melangkah ke atas array", "code": "for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) {"}
{"text": "Periksa sama ada kedudukannya kemudian tambah ke jumlah kemudian tambahkannya ke jumlah", "code": "if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ;"}
{"text": "Lain tolak ke Jumlah", "code": "else sum -= arr [ j ] ;"}
{"text": "Kenaikan kiraan jika jumlahnya sama dengan 0", "code": "if ( sum == 0 ) count ++ ; } }"}
{"text": "Cetak kiraan subarrays", "code": "printf ( \" % d \" , count ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberikan array arr []", "code": "int arr [ ] = { 2 , 4 , 6 , 4 , 2 } ;"}
{"text": "Saiz array", "code": "int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Panggilan fungsi", "code": "countSubarrays ( arr , n ) ; return 0 ; }"}
{"text": "Contoh fungsi rekursif ekor", "code": "void print ( int n ) { if ( n < 0 ) return ; cout << \" ▁ \" << n ;"}
{"text": "Kenyataan yang dilaksanakan terakhir adalah panggilan rekursif", "code": "print ( n - 1 ) ; }"}
{"text": "Program c untuk melaksanakan pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencetak elemen alternatif dari array yang diberikan", "code": "void printAlter ( int arr [ ] , int N ) {"}
{"text": "Elemen cetak di kedudukan ganjil", "code": "for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) {"}
{"text": "Sekiranya Currindex menyimpan indeks atau kedudukan ganjil", "code": "if ( currIndex % 2 == 0 ) { printf ( \" % d ▁ \" , arr [ currIndex ] ) ; } } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAlter ( arr , N ) ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk membalikkan array dari kedudukan 'mula' ke kedudukan 'akhir'", "code": "void reverse ( int arr [ ] , int start , int end ) {"}
{"text": "Kedai pertengahan permulaan dan akhir", "code": "int mid = ( end - start + 1 ) / 2 ;"}
{"text": "Melintasi array dalam julat [permulaan, akhir]", "code": "for ( int i = 0 ; i < mid ; i ++ ) {"}
{"text": "Kedai ARR [Mula + I]", "code": "int temp = arr [ start + i ] ;"}
{"text": "Kemas kini ARR [Mula + I]", "code": "arr [ start + i ] = arr [ end - i ] ;"}
{"text": "Kemas kini ARR [Akhir - I]", "code": "arr [ end - i ] = temp ; } return ; }"}
{"text": "Fungsi utiliti untuk mengosongkan array yang diberikan dalam bentuk {a1, b1, a2, b2, .... an, bn}", "code": "void shuffleArrayUtil ( int arr [ ] , int start , int end ) { int i ;"}
{"text": "Menyimpan panjang array", "code": "int l = end - start + 1 ;"}
{"text": "Sekiranya panjang array adalah 2", "code": "if ( l == 2 ) return ;"}
{"text": "Kedai pertengahan {start, end}", "code": "int mid = start + l / 2 ;"}
{"text": "Bahagikan array menjadi dua bahagian panjang", "code": "if ( l % 4 ) {"}
{"text": "Kemas kini pertengahan", "code": "mid -= 1 ; }"}
{"text": "Kirakan titik pertengahan kedua -dua bahagian array", "code": "int mid1 = start + ( mid - start ) / 2 ; int mid2 = mid + ( end + 1 - mid ) / 2 ;"}
{"text": "Membalikkan subarray yang dibuat dari pertengahan hingga pertengahan2", "code": "reverse ( arr , mid1 , mid2 - 1 ) ;"}
{"text": "Membalikkan subarray yang dibuat dari pertengahan hingga pertengahan", "code": "reverse ( arr , mid1 , mid - 1 ) ;"}
{"text": "Membalikkan subarray yang dibuat dari pertengahan hingga pertengahan2", "code": "reverse ( arr , mid , mid2 - 1 ) ;"}
{"text": "Panggilan secara rekursif untuk kedua -dua bahagian array", "code": "shuffleArrayUtil ( arr , start , mid - 1 ) ; shuffleArrayUtil ( arr , mid , end ) ; }"}
{"text": "Fungsi untuk mengosongkan array yang diberikan dalam bentuk {A1, B1, A2, B2, .... an, bn}", "code": "void shuffleArray ( int arr [ ] , int N , int start , int end ) {"}
{"text": "Panggilan fungsi", "code": "shuffleArrayUtil ( arr , start , end ) ;"}
{"text": "Cetak array yang diubah suai", "code": "for ( int i = 0 ; i < N ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberikan array", "code": "int arr [ ] = { 1 , 3 , 5 , 2 , 4 , 6 } ;"}
{"text": "Saiz array", "code": "int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Shuffles array yang diberikan ke permutasi yang diperlukan", "code": "shuffleArray ( arr , N , 0 , N - 1 ) ; return 0 ; }"}
{"text": "Pelaksanaan c untuk memeriksa sama ada dua array boleh dibuat sama", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE int sort ( int a [ ] , int n ) { int i , j , tmp ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] < a [ i ] ) { tmp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tmp ; } } } return 0 ; }"}
{"text": "Berfungsi untuk memeriksa sama ada array b boleh dibuat sama dengan array a", "code": "int canMadeEqual ( int A [ ] , int B [ ] , int n ) { int i ;"}
{"text": "Susun kedua -dua tatasusunan", "code": "sort ( A , n ) ; sort ( B , n ) ;"}
{"text": "Periksa kedua -dua tatasusunan sama atau tidak", "code": "for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != B [ i ] ) { return ( 0 ) ; } } return ( 1 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int n ; int B [ ] = { 1 , 3 , 2 } ; n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( canMadeEqual ( A , B , n ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } return 0 ; }"}
{"text": "Program C untuk menyusun senarai yang dipautkan menggunakan jenis gelembung dengan menukar nod", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "struktur untuk nod", "code": "struct Node { int data ; struct Node * next ; } Node ;"}
{"text": "Berfungsi untuk menukar nod", "code": "struct Node * swap ( struct Node * ptr1 , struct Node * ptr2 ) { struct Node * tmp = ptr2 -> next ; ptr2 -> next = ptr1 ; ptr1 -> next = tmp ; return ptr2 ; }"}
{"text": "Berfungsi untuk menyusun senarai", "code": "int bubbleSort ( struct Node * * head , int count ) { struct Node * * h ; int i , j , swapped ; for ( i = 0 ; i <= count ; i ++ ) { h = head ; swapped = 0 ; for ( j = 0 ; j < count - i - 1 ; j ++ ) { struct Node * p1 = * h ; struct Node * p2 = p1 -> next ; if ( p1 -> data > p2 -> data ) {"}
{"text": "Kemas kini pautan selepas bertukar", "code": "* h = swap ( p1 , p2 ) ; swapped = 1 ; } h = & ( * h ) -> next ; }"}
{"text": "Cuti jika gelung berakhir tanpa swap", "code": "if ( swapped == 0 ) break ; } }"}
{"text": "Berfungsi untuk mencetak senarai", "code": "void printList ( struct Node * n ) { while ( n != NULL ) { printf ( \" % d ▁ - > ▁ \" , n -> data ) ; n = n -> next ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Berfungsi untuk memasukkan nod struct pada permulaan senarai yang dipautkan", "code": "void insertAtTheBegin ( struct Node * * start_ref , int data ) { struct Node * ptr1 = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; ptr1 -> data = data ; ptr1 -> next = * start_ref ; * start_ref = ptr1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 78 , 20 , 10 , 32 , 1 , 5 } ; int list_size , i ;"}
{"text": "Mulakan dengan senarai yang dipautkan kosong", "code": "struct Node * start = NULL ; list_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Buat senarai yang dipautkan dari array arr []", "code": "for ( i = 0 ; i < list_size ; i ++ ) insertAtTheBegin ( & start , arr [ i ] ) ;"}
{"text": "Senarai Cetak Sebelum Menyusun", "code": "printf ( \" Linked ▁ list ▁ before ▁ sorting STRNEWLINE \" ) ; printList ( start ) ;"}
{"text": "Susun senarai yang dipautkan", "code": "bubbleSort ( & start , list_size ) ;"}
{"text": "Senarai Cetak Setelah Menyusun", "code": "printf ( \" Linked ▁ list ▁ after ▁ sorting STRNEWLINE \" ) ; printList ( start ) ; return 0 ; }"}
{"text": "Program C ++ di - tempat gabungan", "code": "#include <stdio.h>"}
{"text": "Menggabungkan dua subarray ARR []. Subarray pertama adalah arr [l. . m] subarray kedua adalah arr [m + 1. r] pelaksanaan inplace", "code": "void merge ( int arr [ ] , int start , int mid , int end ) { int start2 = mid + 1 ;"}
{"text": "Sekiranya gabungan langsung sudah disusun", "code": "if ( arr [ mid ] <= arr [ start2 ] ) { return ; }"}
{"text": "Dua petunjuk untuk mengekalkan permulaan kedua -dua tatasusunan untuk bergabung", "code": "while ( start <= mid && start2 <= end ) {"}
{"text": "Sekiranya elemen 1 berada di tempat yang betul", "code": "if ( arr [ start ] <= arr [ start2 ] ) { start ++ ; } else { int value = arr [ start2 ] ; int index = start2 ;"}
{"text": "Pergeseran semua elemen antara elemen 1 elemen 2, betul -betul dengan 1.", "code": "while ( index != start ) { arr [ index ] = arr [ index - 1 ] ; index -- ; } arr [ start ] = value ;"}
{"text": "Kemas kini semua petunjuk", "code": "start ++ ; mid ++ ; start2 ++ ; } } }"}
{"text": "L adalah untuk indeks kiri dan r adalah indeks kanan sub -pelbagai ARR yang akan disusun", "code": "void mergeSort ( int arr [ ] , int l , int r ) { if ( l < r ) {"}
{"text": "Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan R yang besar", "code": "int m = l + ( r - l ) / 2 ;"}
{"text": "Susun bahagian pertama dan kedua", "code": "mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } }"}
{"text": "Berfungsi untuk mencetak array", "code": "void printArray ( int A [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , A [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; mergeSort ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; return 0 ; }"}
{"text": "Program C untuk melaksanakan dual pivot Quicksort", "code": "#include <stdio.h> NEW_LINE int partition ( int * arr , int low , int high , int * lp ) ; void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } void DualPivotQuickSort ( int * arr , int low , int high ) { if ( low < high ) {"}
{"text": "LP bermaksud pivot kiri, dan RP bermaksud pivot kanan.", "code": "int lp , rp ; rp = partition ( arr , low , high , & lp ) ; DualPivotQuickSort ( arr , low , lp - 1 ) ; DualPivotQuickSort ( arr , lp + 1 , rp - 1 ) ; DualPivotQuickSort ( arr , rp + 1 , high ) ; } } int partition ( int * arr , int low , int high , int * lp ) { if ( arr [ low ] > arr [ high ] ) swap ( & arr [ low ] , & arr [ high ] ) ;"}
{"text": "P ialah pivot kiri, dan Q adalah pivot yang betul.", "code": "int j = low + 1 ; int g = high - 1 , k = low + 1 , p = arr [ low ] , q = arr [ high ] ; while ( k <= g ) {"}
{"text": "Sekiranya unsur kurang dari pivot kiri", "code": "if ( arr [ k ] < p ) { swap ( & arr [ k ] , & arr [ j ] ) ; j ++ ; }"}
{"text": "Sekiranya elemen lebih besar daripada atau sama dengan pivot yang betul", "code": "else if ( arr [ k ] >= q ) { while ( arr [ g ] > q && k < g ) g -- ; swap ( & arr [ k ] , & arr [ g ] ) ; g -- ; if ( arr [ k ] < p ) { swap ( & arr [ k ] , & arr [ j ] ) ; j ++ ; } } k ++ ; } j -- ; g ++ ;"}
{"text": "Bawa pivot ke kedudukan yang sesuai.", "code": "swap ( & arr [ low ] , & arr [ j ] ) ; swap ( & arr [ high ] , & arr [ g ] ) ;"}
{"text": "Mengembalikan indeks pivots. * lp = j; Kerana kita tidak dapat mengembalikan dua elemen dari fungsi.", "code": "return g ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 24 , 8 , 42 , 75 , 29 , 77 , 38 , 57 } ; DualPivotQuickSort ( arr , 0 , 7 ) ; printf ( \" Sorted ▁ array : ▁ \" ) ; for ( int i = 0 ; i < 8 ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Program c untuk melaksanakan pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk membina graf yang mudah dan disambungkan supaya jarak antara pasang sentuhan tepat adalah 2", "code": "void constGraphWithCon ( int N , int K ) {"}
{"text": "Kedai maksimum mungkin kiraan tepi dalam graf", "code": "int Max = ( ( N - 1 ) * ( N - 2 ) ) / 2 ;"}
{"text": "Kes asas", "code": "if ( K > Max ) { printf ( \" - 1\" ) ; return ; }"}
{"text": "Kedai kiraan tepi dalam graf", "code": "int count = 0 ;"}
{"text": "Sambungkan semua simpang pasangan (i, j)", "code": "for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { printf ( \" % d ▁ % d STRNEWLINE \" , i , j ) ;"}
{"text": "Kemas kini", "code": "count ++ ; if ( count == N * ( N - 1 ) / 2 - K ) break ; } if ( count == N * ( N - 1 ) / 2 - K ) break ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int N = 5 , K = 3 ; constGraphWithCon ( N , K ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencari bilangan bitwise yang mempunyai bitwise xor sama dengan k", "code": "void findArray ( int N , int K ) {"}
{"text": "Kes asas", "code": "if ( N == 1 ) { printf ( \" % d \" , K ) ; return ; } if ( N == 2 ) { printf ( \" % d ▁ % d \" , 0 , K ) ; return ; }"}
{"text": "Berikan nilai kepada p dan q", "code": "int P = N - 2 ; int Q = N - 1 ;"}
{"text": "Menyimpan bitwise xor unsur pertama (n - 3)", "code": "int VAL = 0 ;"}
{"text": "Cetak elemen n - 3 pertama", "code": "for ( int i = 1 ; i <= ( N - 3 ) ; i ++ ) { printf ( \" % d ▁ \" , i ) ;"}
{"text": "Hitung bitwise xor unsur pertama (n - 3)", "code": "VAL ^= i ; } if ( VAL == K ) { printf ( \" % d ▁ % d ▁ % d \" , P , Q , P ^ Q ) ; } else { printf ( \" % d ▁ % d ▁ % d \" , 0 , P , P ^ K ^ VAL ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int N = 4 , X = 6 ;"}
{"text": "Panggilan fungsi", "code": "findArray ( N , X ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Berfungsi untuk mengira bilangan nombor n - digit sedemikian rupa sehingga jumlah setiap digit berturut -turut adalah sama", "code": "int countDigitSum ( int N , int K ) {"}
{"text": "Julat nombor", "code": "int l = ( int ) pow ( 10 , N - 1 ) , r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ;"}
{"text": "Ekstrak digit nombor", "code": "int digits [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ;"}
{"text": "Simpan jumlah digit pertama K", "code": "for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ;"}
{"text": "Periksa setiap digit berturut -turut K -", "code": "for ( int j = 1 ; j < N - K + 1 ; j ++ ) { int curr_sum = 0 ; for ( int m = j ; m < j + K ; m ++ ) curr_sum += digits [ m ] ;"}
{"text": "Sekiranya jumlahnya tidak sama maka hancurkan gelung", "code": "if ( sum != curr_sum ) { flag = 1 ; break ; } }"}
{"text": "Kenaikan kiraan jika memenuhi syarat yang diberikan", "code": "if ( flag == 0 ) { count ++ ; } } return count ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberikan n dan k", "code": "int N = 2 , K = 1 ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" % d \" , countDigitSum ( N , K ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Berfungsi untuk menukar rentetan ke integer tanpa menggunakan fungsi", "code": "void convert ( char s [ ] ) {"}
{"text": "Memulakan pembolehubah", "code": "int num = 0 ; int n = strlen ( s ) ;"}
{"text": "Berulang sehingga panjang tali", "code": "for ( int i = 0 ; i < n ; i ++ )"}
{"text": "Tolak 48 dari digit semasa", "code": "num = num * 10 + ( s [ i ] - 48 ) ;"}
{"text": "Cetak jawapannya", "code": "printf ( \" % d \" , num ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberi nombor nombor", "code": "char s [ ] = \"123\" ;"}
{"text": "Panggilan fungsi", "code": "convert ( s ) ; return 0 ; }"}
{"text": "Fungsi ini kembali benar jika terdapat tiga elemen dalam asumsi AP: Tetapkan [0 .. N - 1] disusun. Kod ini dengan tegas melaksanakan algoritma yang disediakan dalam rujukan.", "code": "bool arithmeticThree ( int set [ ] , int n ) {"}
{"text": "Satu dengan memperbaiki setiap elemen sebagai elemen tengah", "code": "for ( int j = 1 ; j < n - 1 ; j ++ ) {"}
{"text": "Inisialisasi I dan K untuk J semasa", "code": "int i = j - 1 , k = j + 1 ;"}
{"text": "Cari jika ada i dan k yang membentuk ap dengan j sebagai elemen tengah", "code": "while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] == 2 * set [ j ] ) return true ; ( set [ i ] + set [ k ] < 2 * set [ j ] ) ? k ++ : i -- ; } } return false ; }"}
{"text": "Pelaksanaan pengaturcaraan dinamik jumlah maksimum yang meningkatkan masalah berikutnya (MSIS)", "code": "#include <stdio.h>"}
{"text": "maxsumis () mengembalikan jumlah maksimum peningkatan seterusnya dalam arr [] saiz n", "code": "int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ n ] ;"}
{"text": "Mulakan nilai MSIS untuk semua indeks", "code": "for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ;"}
{"text": "Kirakan nilai jumlah maksimum dengan cara bawah", "code": "for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ;"}
{"text": "Pilih maksimum semua nilai MSIS", "code": "for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Sum ▁ of ▁ maximum ▁ sum ▁ increasing ▁ \" \" subsequence ▁ is ▁ % d STRNEWLINE \" , maxSumIS ( arr , n ) ) ; return 0 ; }"}
{"text": "Pelaksanaan Rekursif Naive masalah LIS", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Untuk menggunakan panggilan rekursif, fungsi ini mesti mengembalikan dua perkara: 1) panjang lis yang berakhir dengan elemen arr [n - 1]. Kami menggunakan max_ending_here untuk tujuan ini 2) Keseluruhan maksimum kerana LIS mungkin berakhir dengan elemen sebelum arr [n - 1] max_ref digunakan tujuan ini. Nilai LIS pelbagai saiz n disimpan dalam * max_ref yang merupakan hasil akhir kami", "code": "int _lis ( int arr [ ] , int n , int * max_ref ) {"}
{"text": "Kes asas", "code": "if ( n == 1 ) return 1 ;"}
{"text": "'max _ ending _ here' adalah panjang lis yang berakhir dengan arr [n - 1]", "code": "int res , max_ending_here = 1 ;"}
{"text": "Recursively mendapatkan semua lis yang berakhir dengan arr [0], arr [1] ... arr [n - 2]. Jika arr [i - 1] lebih kecil daripada arr [n - 1], dan max berakhir dengan arr [n - 1] perlu dikemas kini, kemudian kemas kini", "code": "for ( int i = 1 ; i < n ; i ++ ) { res = _lis ( arr , i , max_ref ) ; if ( arr [ i - 1 ] < arr [ n - 1 ] && res + 1 > max_ending_here ) max_ending_here = res + 1 ; }"}
{"text": "Bandingkan max_ending_here dengan keseluruhan maks. Dan mengemas kini max keseluruhan jika diperlukan", "code": "if ( * max_ref < max_ending_here ) * max_ref = max_ending_here ;"}
{"text": "Panjang kembali lis yang berakhir dengan arr [n - 1]", "code": "return max_ending_here ; }"}
{"text": "Fungsi pembalut untuk _lis ()", "code": "int lis ( int arr [ ] , int n ) {"}
{"text": "Pemboleh ubah max memegang hasilnya", "code": "int max = 1 ;"}
{"text": "Fungsi _lis () menyimpan hasilnya dalam maksimum", "code": "_lis ( arr , n , & max ) ;"}
{"text": "mengembalikan max", "code": "return max ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Length ▁ of ▁ lis ▁ is ▁ % d STRNEWLINE \" , lis ( arr , n ) ) ; return 0 ; }"}
{"text": "program rekursif mudah untuk nombor Fibonacci", "code": "int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }"}
{"text": "C Kod untuk mencari kiraan rentetan dalam array aksara 2D yang diberikan.", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #include <stdlib.h> NEW_LINE #define ARRAY_SIZE ( a )  (sizeof(a) / sizeof(*a))"}
{"text": "fungsi utiliti untuk mencari rentetan lengkap dari mana -mana indeks yang diberikan 2D Char Array", "code": "int internalSearch ( char * needle , int row , int col , char * * hay , int row_max , int col_max ) { int found = 0 ; if ( row >= 0 && row <= row_max && col >= 0 && col <= col_max && * needle == hay [ row ] [ col ] ) { char match = * needle ++ ; hay [ row ] [ col ] = 0 ; if ( * needle == 0 ) { found = 1 ; } else {"}
{"text": "Melalui Backtrack mencari di setiap arah", "code": "found += internalSearch ( needle , row , col + 1 , hay , row_max , col_max ) ; found += internalSearch ( needle , row , col - 1 , hay , row_max , col_max ) ; found += internalSearch ( needle , row + 1 , col , hay , row_max , col_max ) ; found += internalSearch ( needle , row - 1 , col , hay , row_max , col_max ) ; } hay [ row ] [ col ] = match ; } return found ; }"}
{"text": "Berfungsi untuk mencari rentetan dalam array 2D", "code": "int searchString ( char * needle , int row , int col , char * * str , int row_count , int col_count ) { int found = 0 ; int r , c ; for ( r = 0 ; r < row_count ; ++ r ) { for ( c = 0 ; c < col_count ; ++ c ) { found += internalSearch ( needle , r , c , str , row_count - 1 , col_count - 1 ) ; } } return found ; }"}
{"text": "Kod pemacu", "code": "int main ( void ) { char needle [ ] = \" MAGIC \" ; char * input [ ] = { \" BBABBM \" , \" CBMBBA \" , \" IBABBG \" , \" GOZBBI \" , \" ABBBBC \" , \" MCIGAM \" } ; char * str [ ARRAY_SIZE ( input ) ] ; int i ; for ( i = 0 ; i < ARRAY_SIZE ( input ) ; ++ i ) { str [ i ] = malloc ( strlen ( input [ i ] ) ) ; strcpy ( str [ i ] , input [ i ] ) ; } printf ( \" count : ▁ % d STRNEWLINE \" , searchString ( needle , 0 , 0 , str , ARRAY_SIZE ( str ) , strlen ( str [ 0 ] ) ) ) ; return 0 ; }"}
{"text": "C Program pendekatan di atas", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h>"}
{"text": "Berfungsi untuk memeriksa sama ada kurungan seimbang", "code": "bool isBalanced ( char exp [ ] ) {"}
{"text": "Pembolehubah permulaan", "code": "bool flag = true ; int count = 0 ;"}
{"text": "Melintasi ungkapan", "code": "for ( int i = 0 ; exp [ i ] != ' \\0' ; i ++ ) { if ( exp [ i ] == ' ( ' ) { count ++ ; } else {"}
{"text": "Ia adalah kurungan penutup", "code": "count -- ; } if ( count < 0 ) {"}
{"text": "Ini bermakna terdapat lebih banyak tanda kurungan penutup daripada pembukaan", "code": "flag = false ; break ; } }"}
{"text": "Sekiranya kiraan tidak sifar, ini bermakna terdapat lebih banyak kurungan pembukaan", "code": "if ( count != 0 ) { flag = false ; } return flag ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { char exp1 [ ] = \" ( ( ( ) ) ) ( ) ( ) \" ; if ( isBalanced ( exp1 ) ) printf ( \" Balanced ▁ STRNEWLINE \" ) ; else printf ( \" Not ▁ Balanced ▁ STRNEWLINE \" ) ; char exp2 [ ] = \" ( ) ) ( ( ( ) ) \" ; if ( isBalanced ( exp2 ) ) printf ( \" Balanced ▁ STRNEWLINE \" ) ; else printf ( \" Not ▁ Balanced ▁ STRNEWLINE \" ) ; return 0 ; }"}
{"text": "C pelaksanaan pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #define MAX_SIZE  100"}
{"text": "Berfungsi untuk mengembalikan vektor jarak yang diperlukan", "code": "void shortestToChar ( char s [ ] , char c , int * res ) {"}
{"text": "Senaraikan untuk memegang kedudukan C dalam s", "code": "int list [ MAX_SIZE ] ;"}
{"text": "panjang rentetan", "code": "int len = 0 ;"}
{"text": "Untuk memegang saiz senarai", "code": "int l = 0 ;"}
{"text": "Melangkah ke atas rentetan untuk membuat senarai", "code": "while ( s [ len ] != ' \\0' ) { if ( s [ len ] == c ) { list [ l ] = len ; l ++ ; } len ++ ; } int p1 , p2 , v1 , v2 ;"}
{"text": "Nilai maksimum p2", "code": "l = l - 1 ;"}
{"text": "Inisialisasi petunjuk", "code": "p1 = 0 ; p2 = l > 0 ? 1 : 0 ;"}
{"text": "Buat hasil hasil", "code": "for ( int i = 0 ; i < len ; i ++ ) {"}
{"text": "Nilai pada petunjuk semasa", "code": "v1 = list [ p1 ] ; v2 = list [ p2 ] ;"}
{"text": "Indeks semasa sebelum ini daripada P1", "code": "if ( i <= v1 ) { res [ i ] = ( v1 - i ) ; }"}
{"text": "Indeks semasa adalah antara P1 dan P2", "code": "else if ( i <= v2 ) {"}
{"text": "Indeks semasa lebih dekat dengan P1", "code": "if ( i - v1 < v2 - i ) { res [ i ] = ( i - v1 ) ; }"}
{"text": "Indeks semasa lebih dekat dengan P2", "code": "else { res [ i ] = ( v2 - i ) ;"}
{"text": "Pindahkan penunjuk 1 langkah ke hadapan", "code": "p1 = p2 ; p2 = p2 < l ? ( p2 + 1 ) : p2 ; } }"}
{"text": "Indeks semasa adalah selepas P2", "code": "else { res [ i ] = ( i - v2 ) ; } } }"}
{"text": "Kod pemacu", "code": "int main ( ) { char s [ ] = \" geeksforgeeks \" ; char c = ' e ' ; int res [ MAX_SIZE ] ; shortestToChar ( s , c , res ) ; int i = 0 ; while ( s [ i ] != ' \\0' ) printf ( \" % d ▁ \" , res [ i ++ ] ) ; return 0 ; }"}
{"text": "Program c untuk membalikkan rentetan mengikut bilangan perkataan", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Membalikkan huruf perkataan", "code": "void reverse ( char str [ ] , int start , int end ) {"}
{"text": "Pemboleh ubah sementara untuk menyimpan watak", "code": "char temp ; while ( start <= end ) {"}
{"text": "Menukar watak pertama dan terakhir", "code": "temp = str [ start ] ; str [ start ] = str [ end ] ; str [ end ] = temp ; start ++ ; end -- ; } }"}
{"text": "Fungsi ini membentuk rentetan yang diperlukan", "code": "void reverseletter ( char str [ ] , int start , int end ) { int wstart , wend ; for ( wstart = wend = start ; wend < end ; wend ++ ) { if ( str [ wend ] == ' ▁ ' ) continue ;"}
{"text": "Memeriksa bilangan perkataan yang ada dalam rentetan untuk terbalik", "code": "while ( str [ wend ] != ' ▁ ' && wend <= end ) wend ++ ; wend -- ;"}
{"text": "Membalikkan huruf perkataan", "code": "reverse ( str , wstart , wend ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { char str [ 1000 ] = \" Ashish ▁ Yadav ▁ Abhishek ▁ Rajput ▁ Sunil ▁ Pundir \" ; reverseletter ( str , 0 , strlen ( str ) - 1 ) ; printf ( \" % s \" , str ) ; return 0 ; }"}
{"text": "Program c untuk mendapatkan togol kes rentetan", "code": "#include <stdio.h>"}
{"text": "Toggle Case = swap topi ke kes yang lebih rendah dan kes yang lebih rendah ke topi", "code": "char * toggleCase ( char * a ) { for ( int i = 0 ; a [ i ] != ' \\0' ; i ++ ) {"}
{"text": "Bitwise exor dengan 32", "code": "a [ i ] ^= 32 ; } return a ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { char str [ ] = \" CheRrY \" ; printf ( \" Toggle ▁ case : ▁ % s STRNEWLINE \" , toggleCase ( str ) ) ; printf ( \" Original ▁ string : ▁ % s \" , toggleCase ( str ) ) ; return 0 ; }"}
{"text": "pelaksanaan strcmp yang mengabaikan kes -kes", "code": "int ic_strcmp ( char * s1 , char * s2 ) { int i ; for ( i = 0 ; s1 [ i ] && s2 [ i ] ; ++ i ) {"}
{"text": "Sekiranya aksara sama atau membalikkan bit ke -6 menjadikannya sama", "code": "if ( s1 [ i ] == s2 [ i ] || ( s1 [ i ] ^ 32 ) == s2 [ i ] ) continue ; else break ; }"}
{"text": "Bandingkan watak terakhir (atau pertama dalam kes tidak sama)", "code": "if ( s1 [ i ] == s2 [ i ] ) return 0 ;"}
{"text": "Tetapkan bit ke -6 dalam kedua -duanya, kemudian bandingkan", "code": "if ( ( s1 [ i ] 32 ) < ( s2 [ i ] 32 ) ) return -1 ; return 1 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( void ) { printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" Geeks \" , \" apple \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" \" , \" ABCD \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" ABCD \" , \" z \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" ABCD \" , \" abcdEghe \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" GeeksForGeeks \" , \" gEEksFORGeEKs \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" GeeksForGeeks \" , \" geeksForGeeks \" ) ) ; return 0 ; }"}
{"text": "Program c untuk memeriksa sama ada dua rentetan adalah anagram antara satu sama lain", "code": "#include <stdio.h> NEW_LINE #define NO_OF_CHARS  256"}
{"text": "berfungsi untuk memeriksa sama ada dua rentetan adalah anagram antara satu sama lain", "code": "bool areAnagram ( char * str1 , char * str2 ) {"}
{"text": "Buat 2 susunan kiraan dan mulakan semua nilai sebagai 0", "code": "int count1 [ NO_OF_CHARS ] = { 0 } ; int count2 [ NO_OF_CHARS ] = { 0 } ; int i ;"}
{"text": "Untuk setiap aksara dalam rentetan input, kiraan kenaikan dalam array kiraan yang sepadan", "code": "for ( i = 0 ; str1 [ i ] && str2 [ i ] ; i ++ ) { count1 [ str1 [ i ] ] ++ ; count2 [ str2 [ i ] ] ++ ; }"}
{"text": "Jika kedua -dua rentetan adalah panjang yang berbeza. Mengeluarkan keadaan ini akan menjadikan program gagal untuk rentetan seperti \"AACA\" dan \"ACA\"", "code": "if ( str1 [ i ] str2 [ i ] ) return false ;"}
{"text": "Bandingkan susunan kiraan", "code": "for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { char str1 [ ] = \" geeksforgeeks \" ; char str2 [ ] = \" forgeeksgeeks \" ;"}
{"text": "Panggilan fungsi", "code": "if ( areAnagram ( str1 , str2 ) ) printf ( \" The ▁ two ▁ strings ▁ are ▁ anagram ▁ of ▁ each ▁ other \" ) ; else printf ( \" The ▁ two ▁ strings ▁ are ▁ not ▁ anagram ▁ of ▁ each ▁ \" \" other \" ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari nombor heptacontagon nth", "code": "int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int N = 3 ; printf ( \"3rd ▁ heptacontagon ▁ Number ▁ is ▁ = ▁ % d \" , heptacontagonNum ( N ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencari nombor terbesar", "code": "int findMax ( int a , int b ) { int z , i , max ;"}
{"text": "Melakukan penolakan", "code": "z = a - b ;"}
{"text": "Peralihan kanan dan bitwise dan", "code": "i = ( z >> 31 ) & 1 ;"}
{"text": "Cari nombor maksimum", "code": "max = a - ( i * z ) ;"}
{"text": "Kembalikan nilai maksimum", "code": "return max ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int A = 40 , B = 54 ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" % d \" , findMax ( A , B ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari nombor Armstrong", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengira n yang dinaikkan kepada kuasa d", "code": "int power ( int N , unsigned int D ) { if ( D == 0 ) return 1 ; if ( D % 2 == 0 ) return power ( N , D / 2 ) * power ( N , D / 2 ) ; return N * power ( N , D / 2 ) * power ( N , D / 2 ) ; }"}
{"text": "Berfungsi untuk mengira urutan nombor", "code": "int order ( int N ) { int r = 0 ;"}
{"text": "Untuk setiap digit", "code": "while ( N ) { r ++ ; N = N / 10 ; } return r ; }"}
{"text": "Berfungsi untuk memeriksa sama ada nombor yang diberikan adalah nombor Armstrong atau tidak", "code": "int isArmstrong ( int N ) {"}
{"text": "Fungsi pesanan panggilan", "code": "int D = order ( N ) ; int temp = N , sum = 0 ;"}
{"text": "Untuk setiap digit", "code": "while ( temp ) { int Ni = temp % 10 ; sum += power ( Ni , D ) ; temp = temp / 10 ; }"}
{"text": "Sekiranya memenuhi keadaan Armstrong", "code": "if ( sum == N ) return 1 ; else return 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberi nombor n", "code": "int N = 153 ;"}
{"text": "Panggilan fungsi", "code": "if ( isArmstrong ( N ) == 1 ) printf ( \" True STRNEWLINE \" ) ; else printf ( \" False STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Program c untuk mencari nombor utama antara selang waktu yang diberikan", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk nombor perdana cetak dalam julat yang diberikan", "code": "void primeInRange ( int L , int R ) { int i , j , flag ;"}
{"text": "Melintasi setiap nombor dalam selang waktu dengan bantuan untuk gelung", "code": "for ( i = L ; i <= R ; i ++ ) {"}
{"text": "Langkau 0 dan 1 kerana mereka bukan Perdana atau Komposit", "code": "if ( i == 1 i == 0 ) continue ;"}
{"text": "pemboleh ubah bendera untuk memberitahu sama ada saya adalah perdana atau tidak", "code": "flag = 1 ;"}
{"text": "Berulang untuk memeriksa sama ada saya adalah perdana atau tidak", "code": "for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } }"}
{"text": "bendera = 1 bermaksud saya adalah perdana dan bendera = 0 bermaksud saya bukan perdana", "code": "if ( flag == 1 ) printf ( \" % d ▁ \" , i ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Julat yang diberikan", "code": "int L = 1 ; int R = 10 ;"}
{"text": "Panggilan fungsi", "code": "primeInRange ( L , R ) ; return 0 ; }"}
{"text": "Kod c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #define lli  long long int"}
{"text": "Berfungsi untuk memeriksa keadaan", "code": "void isEqualFactors ( lli N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) printf ( \" YES STRNEWLINE \" ) ; else printf ( \" NO STRNEWLINE \" ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { lli N = 10 ; isEqualFactors ( N ) ; N = 125 ; isEqualFactors ( N ) ; return 0 ; }"}
{"text": "Pelaksanaan c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Fungsi untuk memeriksa pembahagian nombor dengan digitnya.", "code": "int checkDivisibility ( int n , int digit ) {"}
{"text": "Jika digit membahagikan nombor maka kembali benar lain kembali palsu.", "code": "return ( digit != 0 && n % digit == 0 ) ; }"}
{"text": "Berfungsi untuk memeriksa sama ada semua digit n membahagikannya atau tidak", "code": "int isAllDigitsDivide ( int n ) { int temp = n ; while ( temp > 0 ) {"}
{"text": "Mengambil digit nombor ke dalam digit var.", "code": "int digit = temp % 10 ; if ( ! ( checkDivisibility ( n , digit ) ) ) return 0 ; temp /= 10 ; } return 1 ; }"}
{"text": "Berfungsi untuk memeriksa sama ada n mempunyai semua digit yang berbeza", "code": "int isAllDigitsDistinct ( int n ) {"}
{"text": "Buat pelbagai saiz 10 dan mulakan semua elemen sebagai palsu. Arahan ini digunakan untuk memeriksa sama ada digit sudah dilihat atau tidak.", "code": "int arr [ 10 ] , i , digit ; for ( i = 0 ; i < 10 ; i ++ ) arr [ i ] = 0 ;"}
{"text": "Melintasi semua digit nombor yang diberikan", "code": "while ( n > 0 ) {"}
{"text": "Cari digit terakhir", "code": "digit = n % 10 ;"}
{"text": "Sekiranya digit sudah dilihat, kembali palsu", "code": "if ( arr [ digit ] ) return 0 ;"}
{"text": "Tandakan digit ini seperti yang dilihat", "code": "arr [ digit ] = 1 ;"}
{"text": "Keluarkan digit terakhir dari nombor", "code": "n = n / 10 ; } return 1 ; }"}
{"text": "Berfungsi untuk memeriksa lynch - nombor loceng", "code": "int isLynchBell ( int n ) { return isAllDigitsDivide ( n ) && isAllDigitsDistinct ( n ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberi nombor n", "code": "int N = 12 ;"}
{"text": "Panggilan fungsi", "code": "if ( isLynchBell ( N ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Pelaksanaan c untuk mencari bitwise maksimum dan pasangan (x, y) dari julat yang diberikan supaya x dan y boleh menjadi sama", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengembalikan bitwise maksimum dan", "code": "int maximumAND ( int L , int R ) { return R ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int l = 3 ; int r = 7 ; printf ( \" % d \" , maximumAND ( l , r ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencari purata kiub", "code": "double findAverageOfCube ( int n ) {"}
{"text": "Simpan jumlah kiub nombor dalam jumlah", "code": "double sum = 0 ;"}
{"text": "Kirakan jumlah kiub", "code": "int i ; for ( i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; }"}
{"text": "Pulangan purata", "code": "return sum / n ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Nombor yang diberikan", "code": "int n = 3 ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" % lf \" , findAverageOfCube ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include \" stdio . h \""}
{"text": "Struct ditakrifkan untuk sistem kaki inci", "code": "struct InchFeet {"}
{"text": "Pemboleh ubah untuk menyimpan inci - kaki", "code": "int feet ; float inch ; } ;"}
{"text": "Berfungsi untuk mencari jumlah semua jarak kaki inci N", "code": "void findSum ( struct InchFeet arr [ ] , int N ) {"}
{"text": "Pemboleh ubah untuk menyimpan jumlah", "code": "int feet_sum = 0 ; float inch_sum = 0.0 ; int x ;"}
{"text": "Melintasi array inchfeet", "code": "for ( int i = 0 ; i < N ; i ++ ) {"}
{"text": "Cari jumlah kaki dan inci", "code": "feet_sum += arr [ i ] . feet ; inch_sum += arr [ i ] . inch ; }"}
{"text": "Sekiranya jumlah inci lebih besar daripada 11 menukarnya menjadi kaki sebagai 1 kaki = 12 inci", "code": "if ( inch_sum >= 12 ) {"}
{"text": "Cari bahagian penting dalam inch_sum", "code": "x = ( int ) inch_sum ;"}
{"text": "Padamkan Bahagian Integral X", "code": "inch_sum -= x ;"}
{"text": "Tambahkan x % 12 ke inch_sum", "code": "inch_sum += x % 12 ;"}
{"text": "Tambah x / 12 ke kaki_sum", "code": "feet_sum += x / 12 ; }"}
{"text": "Cetak jumlah kaki_sum dan inch_sum yang sepadan", "code": "printf ( \" Feet ▁ Sum : ▁ % d STRNEWLINE \" , feet_sum ) ; printf ( \" Inch ▁ Sum : ▁ % .2f \" , inch_sum ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Diberi set kaki - kaki", "code": "struct InchFeet arr [ ] = { { 10 , 3.7 } , { 10 , 5.5 } , { 6 , 8.0 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Panggilan fungsi", "code": "findSum ( arr , N ) ; return 0 ; }"}
{"text": "C pelaksanaan untuk memeriksa sama ada nombor adalah kuasa k", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Berfungsi untuk memeriksa sama ada nombor kuasa k", "code": "_Bool isPower ( int N , int K ) {"}
{"text": "Fungsi logaritma untuk mengira nilai", "code": "int res1 = log ( N ) / log ( K ) ; double res2 = log ( N ) / log ( K ) ;"}
{"text": "Bandingkan dengan hasil1 atau hasil2 kedua -duanya sama", "code": "return ( res1 == res2 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int N = 8 ; int K = 2 ; if ( isPower ( N , K ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } return 0 ; }"}
{"text": "Program c untuk melaksanakan peraturan Boole pada fungsi yang diberikan", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Berfungsi untuk mengembalikan nilai f (x) untuk nilai yang diberikan x", "code": "float y ( float x ) { return ( 1 / ( 1 + x ) ) ; }"}
{"text": "Berfungsi untuk mengira integrand y pada selang masa x yang diberikan dengan saiz langkah H dan had awal a dan had akhir b", "code": "float BooleRule ( float a , float b ) {"}
{"text": "Bilangan selang", "code": "int n = 4 ; int h ;"}
{"text": "Mengira saiz langkah", "code": "h = ( ( b - a ) / n ) ; float sum = 0 ;"}
{"text": "Menggantikan a = 0, b = 4 dan h = 1", "code": "float bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ; sum = sum + bl ; return sum ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float lowlimit = 0 ; float upplimit = 4 ; printf ( \" f ( x ) ▁ = ▁ % .4f \" , BooleRule ( 0 , 4 ) ) ; return 0 ; }"}
{"text": "Program c untuk melaksanakan peraturan Weedle", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Fungsi sampel f (x) = 1 / (1 + x ^ 2)", "code": "float y ( float x ) { float num = 1 ; float denom = 1.0 + x * x ; return num / denom ; }"}
{"text": "Berfungsi untuk mencari nilai integral f (x) dengan saiz langkah h, dengan had bawah awal dan had atas a dan b", "code": "float WeedleRule ( float a , float b ) {"}
{"text": "Cari saiz langkah h", "code": "double h = ( b - a ) / 6 ;"}
{"text": "Untuk menyimpan jumlah akhir", "code": "float sum = 0 ;"}
{"text": "Cari jumlah menggunakan formula Weedle", "code": "sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) ;"}
{"text": "Kembalikan jumlah akhir", "code": "return sum ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "had bawah dan had atas", "code": "float a = 0 , b = 6 ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" f ( x ) ▁ = ▁ % f \" , WeedleRule ( a , b ) ) ; return 0 ; }"}
{"text": "Program C untuk melaksanakan kaedah runge kutta", "code": "#include <stdio.h>"}
{"text": "Persamaan pembezaan sampel \"dy / dx = ~ (x ~ u) / 2\"", "code": "float dydx ( float x , float y ) { return ( x + y - 2 ) ; }"}
{"text": "Cari nilai y untuk x yang diberikan menggunakan saiz langkah H dan nilai awal y0 pada x0.", "code": "float rungeKutta ( float x0 , float y0 , float x , float h ) {"}
{"text": "Kira bilangan lelaran menggunakan saiz langkah atau ketinggian langkah h", "code": "int n = ( int ) ( ( x - x0 ) / h ) ; float k1 , k2 ;"}
{"text": "Berulang untuk bilangan lelaran", "code": "float y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text": "Sapukan Formula Runge Kutta untuk mencari nilai seterusnya y", "code": "k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ;"}
{"text": "Kemas kini nilai seterusnya y", "code": "y = y + ( 1.0 / 6.0 ) * ( k1 + 2 * k2 ) ;"}
{"text": "Kemas kini nilai seterusnya x", "code": "x0 = x0 + h ; } return y ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float x0 = 0 , y = 1 , x = 2 , h = 0.2 ; printf ( \" y ( x ) ▁ = ▁ % f \" , rungeKutta ( x0 , y , x , h ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari perimeter dan kawasan", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencari perimeter", "code": "float per ( float a , float b ) { return ( a + b ) ; }"}
{"text": "Berfungsi untuk mencari kawasan", "code": "float area ( float s ) { return ( s / 2 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float a = 7 , b = 8 , s = 10 ; printf ( \" % f STRNEWLINE \" , per ( a , b ) ) ; printf ( \" % f \" , area ( s ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari kawasan daun di dalam persegi", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265"}
{"text": "Berfungsi untuk mencari kawasan daun", "code": "float area_leaf ( float a ) { return ( a * a * ( PI / 2 - 1 ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float a = 7 ; printf ( \" % f \" , area_leaf ( a ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari panjang tali", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265"}
{"text": "Berfungsi untuk mencari panjang tali", "code": "float length_rope ( float r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float r = 7 ; printf ( \" % f \" , length_rope ( r ) ) ; return 0 ; }"}
{"text": "Program C untuk mencari kawasan selang segitiga bersudut kanan", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265"}
{"text": "Berfungsi untuk mencari kawasan yang tidak bulat", "code": "float area_inscribed ( float P , float B , float H ) { return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float P = 3 , B = 4 , H = 5 ; printf ( \" % f \" , area_inscribed ( P , B , H ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari kawasan bulatan cicumscribed segitiga bersudut kanan", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265"}
{"text": "Berfungsi untuk mencari kawasan lingkaran yang dilampirkan", "code": "float area_circumscribed ( float c ) { return ( c * c * ( PI / 4 ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float c = 8 ; printf ( \" % f \" , area_circumscribed ( c ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari kawasan lingkaran segi tiga yang tertulis", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #define PI  3.14159265"}
{"text": "berfungsi untuk mencari kawasan bulatan tertulis", "code": "float area_inscribed ( float a ) { return ( a * a * ( PI / 12 ) ) ; }"}
{"text": "berfungsi untuk mencari perimeter bulatan tertulis", "code": "float perm_inscribed ( float a ) { return ( PI * ( a / sqrt ( 3 ) ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float a = 6 ; printf ( \" Area ▁ of ▁ inscribed ▁ circle ▁ is ▁ : % f STRNEWLINE \" , area_inscribed ( a ) ) ; printf ( \" Perimeter ▁ of ▁ inscribed ▁ circle ▁ is ▁ : % f \" , perm_inscribed ( a ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari kawasan dan perimeter separuh bulatan", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengira kawasan tersebut", "code": "float area ( float r ) {"}
{"text": "Formula untuk mencari kawasan tersebut", "code": "return ( 0.5 ) * ( 3.14 ) * ( r * r ) ; }"}
{"text": "Berfungsi untuk mengira perimeter", "code": "float perimeter ( float r ) {"}
{"text": "Formula untuk mencari perimeter", "code": "return ( 3.14 ) * ( r ) ; }"}
{"text": "kod pemacu", "code": "int main ( ) {"}
{"text": "Dapatkan jejari", "code": "float r = 10 ;"}
{"text": "Cari kawasan itu", "code": "printf ( \" The ▁ Area ▁ of ▁ Semicircle : ▁ % f STRNEWLINE \" , area ( r ) ) ;"}
{"text": "Cari perimeter", "code": "printf ( \" The ▁ Perimeter ▁ of ▁ Semicircle : ▁ % f STRNEWLINE \" , perimeter ( r ) ) ; return 0 ; }"}
{"text": "Program C untuk mencari persamaan pesawat yang melalui 3 mata.", "code": "#include <stdio.h>"}
{"text": "Fungsi untuk mencari persamaan satah.", "code": "void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; printf ( \" equation ▁ of ▁ plane ▁ is ▁ % .2f ▁ x ▁ + ▁ % .2f \" \" ▁ y ▁ + ▁ % .2f ▁ z ▁ + ▁ % .2f ▁ = ▁ 0 . \" , a , b , c , d ) ; return ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float x1 = -1 ; float y1 = 2 ; float z1 = 1 ; float x2 = 0 ; float y2 = -3 ; float z2 = 2 ; float x3 = 1 ; float y3 = 1 ; float z3 = -4 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; return 0 ; }"}
{"text": "Program C untuk mencari jarak antara titik tertentu dan garis tertentu dalam 2 d.", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Berfungsi untuk mencari jarak", "code": "void shortest_distance ( float x1 , float y1 , float a , float b , float c ) { float d = fabs ( ( a * x1 + b * y1 + c ) ) / ( sqrt ( a * a + b * b ) ) ; printf ( \" Perpendicular ▁ distance ▁ is ▁ % f STRNEWLINE \" , d ) ; return ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float x1 = 5 ; float y1 = 6 ; float a = -2 ; float b = 3 ; float c = 4 ; shortest_distance ( x1 , y1 , a , b , c ) ; return 0 ; }"}
{"text": "Program C untuk mencetak Octant titik tertentu.", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencetak oktan", "code": "void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) printf ( \" Point ▁ lies ▁ in ▁ 1st ▁ octant STRNEWLINE \" ) ; else if ( x < 0 && y >= 0 && z >= 0 ) printf ( \" Point ▁ lies ▁ in ▁ 2nd ▁ octant STRNEWLINE \" ) ; else if ( x < 0 && y < 0 && z >= 0 ) printf ( \" Point ▁ lies ▁ in ▁ 3rd ▁ octant STRNEWLINE \" ) ; else if ( x >= 0 && y < 0 && z >= 0 ) printf ( \" Point ▁ lies ▁ in ▁ 4th ▁ octant STRNEWLINE \" ) ; else if ( x >= 0 && y >= 0 && z < 0 ) printf ( \" Point ▁ lies ▁ in ▁ 5th ▁ octant STRNEWLINE \" ) ; else if ( x < 0 && y >= 0 && z < 0 ) printf ( \" Point ▁ lies ▁ in ▁ 6th ▁ octant STRNEWLINE \" ) ; else if ( x < 0 && y < 0 && z < 0 ) printf ( \" Point ▁ lies ▁ in ▁ 7th ▁ octant STRNEWLINE \" ) ; else if ( x >= 0 && y < 0 && z < 0 ) printf ( \" Point ▁ lies ▁ in ▁ 8th ▁ octant STRNEWLINE \" ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float x = 2 , y = 3 , z = 4 ; octant ( x , y , z ) ; x = -4 , y = 2 , z = -8 ; octant ( x , y , z ) ; x = -6 , y = -2 , z = 8 ; octant ( x , y , z ) ; }"}
{"text": "Program CPP untuk mencari maksimum adalah segiempat", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE double maxArea ( double a , double b , double c , double d ) {"}
{"text": "Mengira separuh - perimeter kuadrilater yang diberikan", "code": "double semiperimeter = ( a + b + c + d ) / 2 ;"}
{"text": "Memohon formula Brahmagupta untuk mendapatkan kawasan maksimum segiempat", "code": "return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { double a = 1 , b = 2 , c = 1 , d = 2 ; printf ( \" % .2f STRNEWLINE \" , maxArea ( a , b , c , d ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencari array setelah melakukan pertanyaan yang diberikan kepada elemen array", "code": "void addAP ( int A [ ] , int Q , int operations [ 2 ] [ 4 ] ) {"}
{"text": "Melintasi pertanyaan yang diberikan", "code": "for ( int j = 0 ; j < 2 ; ++ j ) { int L = operations [ j ] [ 0 ] , R = operations [ j ] [ 1 ] , a = operations [ j ] [ 2 ] , d = operations [ j ] [ 3 ] ; int curr = a ;"}
{"text": "Melintasi array yang diberikan", "code": "for ( int i = L - 1 ; i < R ; i ++ ) {"}
{"text": "Kemas kini nilai [i]", "code": "A [ i ] += curr ;"}
{"text": "Kemas kini nilai curr", "code": "curr += d ; } }"}
{"text": "Cetak elemen array", "code": "for ( int i = 0 ; i < 4 ; ++ i ) printf ( \" % d ▁ \" , A [ i ] ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int A [ ] = { 5 , 4 , 2 , 8 } ; int Q = 2 ; int Query [ 2 ] [ 4 ] = { { 1 , 2 , 1 , 3 } , { 1 , 4 , 4 , 1 } } ;"}
{"text": "Panggilan fungsi", "code": "addAP ( A , Q , Query ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <omp.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <time.h>"}
{"text": "Berfungsi untuk mencari nilai anggaran PI menggunakan algoritma Monte Carlo", "code": "void monteCarlo ( int N , int K ) {"}
{"text": "Kedai Koordinat X dan Y dari titik rawak", "code": "double x , y ;"}
{"text": "Kedai Jarak dari titik rawak dari asal", "code": "double d ;"}
{"text": "Menyimpan bilangan mata yang terletak di dalam bulatan", "code": "int pCircle = 0 ;"}
{"text": "Menyimpan bilangan mata yang terletak di dalam persegi", "code": "int pSquare = 0 ; int i = 0 ;"}
{"text": "Pengiraan selari titik rawak yang terletak di dalam bulatan", "code": "#pragma  omp parallel firstprivate(x, y, d, i) reduction(+ : pCircle, pSquare) num_threads(K) NEW_LINE {"}
{"text": "Memulakan mata rawak dengan benih", "code": "srand48 ( ( int ) time ( NULL ) ) ; for ( i = 0 ; i < N ; i ++ ) {"}
{"text": "Cari Random X Co - Ordinate", "code": "x = ( double ) drand48 ( ) ;"}
{"text": "Cari Random X Co - Ordinate", "code": "y = ( double ) drand48 ( ) ;"}
{"text": "Cari kuadrat jarak titik (x, y) dari asal", "code": "d = ( ( x * x ) + ( y * y ) ) ;"}
{"text": "Sekiranya D kurang daripada atau sama dengan 1", "code": "if ( d <= 1 ) {"}
{"text": "Kenaikan pcircle sebanyak 1", "code": "pCircle ++ ; }"}
{"text": "Kenaikan psquare sebanyak 1", "code": "pSquare ++ ; } }"}
{"text": "Menyimpan nilai anggaran pi", "code": "double pi = 4.0 * ( ( double ) pCircle / ( double ) ( pSquare ) ) ;"}
{"text": "Mencetak nilai dalam pi", "code": "printf ( \" Final ▁ Estimation ▁ of ▁ Pi ▁ = ▁ % f STRNEWLINE \" , pi ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Input", "code": "int N = 100000 ; int K = 8 ;"}
{"text": "Panggilan fungsi", "code": "monteCarlo ( N , K ) ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Dimensi matriks", "code": "const int N = 5 ;"}
{"text": "Struktur matriks yang cekap", "code": "struct Matrix { int * A ; int size ; } ;"}
{"text": "Berfungsi untuk menetapkan nilai dalam matriks", "code": "void Set ( struct Matrix * mat , int i , int j , int x ) { if ( i >= j ) mat -> A [ i * ( i - 1 ) / 2 + j - 1 ] = x ; }"}
{"text": "Berfungsi untuk menyimpan nilai dalam matriks", "code": "int Get ( struct Matrix mat , int i , int j ) { if ( i >= j ) { return mat . A [ i * ( i - 1 ) / 2 + j - 1 ] ; } else { return 0 ; } }"}
{"text": "Berfungsi untuk memaparkan unsur -unsur matriks", "code": "void Display ( struct Matrix mat ) { int i , j ;"}
{"text": "Melintasi matriks", "code": "for ( i = 1 ; i <= mat . size ; i ++ ) { for ( j = 1 ; j <= mat . size ; j ++ ) { if ( i >= j ) { printf ( \" % d ▁ \" , mat . A [ i * ( i - 1 ) / 2 + j - 1 ] ) ; } else { printf ( \"0 ▁ \" ) ; } } printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Berfungsi untuk menghasilkan matriks yang cekap", "code": "struct Matrix createMat ( int Mat [ N ] [ N ] ) {"}
{"text": "Mengisytiharkan matriks yang cekap", "code": "struct Matrix mat ;"}
{"text": "Inisialisasi matriks", "code": "mat . size = N ; mat . A = ( int * ) malloc ( mat . size * ( mat . size + 1 ) / 2 * sizeof ( int ) ) ; int i , j ;"}
{"text": "Tetapkan nilai dalam matriks", "code": "for ( i = 1 ; i <= mat . size ; i ++ ) { for ( j = 1 ; j <= mat . size ; j ++ ) { Set ( & mat , i , j , Mat [ i - 1 ] [ j - 1 ] ) ; } }"}
{"text": "Kembalikan matriks", "code": "return mat ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int Mat [ 5 ] [ 5 ] = { { 1 , 0 , 0 , 0 , 0 } , { 1 , 2 , 0 , 0 , 0 } , { 1 , 2 , 3 , 0 , 0 } , { 1 , 2 , 3 , 4 , 0 } , { 1 , 2 , 3 , 4 , 5 } } ;"}
{"text": "Menyimpan matriks yang cekap", "code": "struct Matrix mat = createMat ( Mat ) ;"}
{"text": "Cetak matriks", "code": "Display ( mat ) ; return 0 ; }"}
{"text": "Program untuk menggambarkan kerja pengendali modulo", "code": "#include <stdio.h> NEW_LINE int main ( void ) {"}
{"text": "Untuk menyimpan dua nilai integer", "code": "int x , y ;"}
{"text": "Untuk menyimpan hasil ungkapan modulo", "code": "int result ; x = -3 ; y = 4 ; result = x % y ; printf ( \" % d \" , result ) ; x = 4 ; y = -2 ; result = x % y ; printf ( \" % d \" , result ) ; x = -3 ; y = -4 ; result = x % y ; printf ( \" % d \" , result ) ; return 0 ; }"}
{"text": "Program c untuk mencari log (a) di mana -mana asas b", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE int log_a_to_base_b ( int a , int b ) { return log ( a ) / log ( b ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int a = 3 ; int b = 2 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; a = 256 ; b = 4 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari log (a) di mana -mana asas b menggunakan rekursi", "code": "#include <stdio.h>"}
{"text": "Fungsi rekursif untuk mengira log A ke pangkalan b", "code": "int log_a_to_base_b ( int a , int b ) { return ( a > b - 1 ) ? 1 + log_a_to_base_b ( a / b , b ) : 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int a = 3 ; int b = 2 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; a = 256 ; b = 4 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari maksimum dan minimum menggunakan fungsi mutlak", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Berfungsi untuk kembali maksimum di antara kedua -dua nombor", "code": "int maximum ( int x , int y ) { return ( ( x + y + abs ( x - y ) ) / 2 ) ; }"}
{"text": "Berfungsi untuk mengembalikan minimum di antara kedua -dua nombor", "code": "int minimum ( int x , int y ) { return ( ( x + y - abs ( x - y ) ) / 2 ) ; }"}
{"text": "Kod pemacu", "code": "void main ( ) { int x = 99 , y = 18 ;"}
{"text": "Memaparkan nilai maksimum", "code": "printf ( \" Maximum : ▁ % d STRNEWLINE \" , maximum ( x , y ) ) ;"}
{"text": "Memaparkan nilai minimum", "code": "printf ( \" Minimum : ▁ % d STRNEWLINE \" , minimum ( x , y ) ) ; }"}
{"text": "C pelaksanaan pendekatan", "code": "#include <stdio.h>"}
{"text": "Fungsi rekursif dengan pembolehubah statik p dan f", "code": "double e ( int x , int n ) { static double p = 1 , f = 1 ; double r ;"}
{"text": "Keadaan penamatan", "code": "if ( n == 0 ) return 1 ;"}
{"text": "Panggilan rekursif", "code": "r = e ( x , n - 1 ) ;"}
{"text": "Kemas kini kuasa x", "code": "p = p * x ;"}
{"text": "Faktorial", "code": "f = f * n ; return ( r + p / f ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int x = 4 , n = 15 ; printf ( \" % lf ▁ STRNEWLINE \" , e ( x , n ) ) ; return 0 ; }"}
{"text": "Program C untuk melaksanakan algoritma lukisan elips Mid - Point", "code": "#include <stdio.h> NEW_LINE void midptellipse ( int rx , int ry , int xc , int yc ) { float dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ;"}
{"text": "Parameter keputusan awal Wilayah 1", "code": "d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25 * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ;"}
{"text": "Untuk Wilayah 1", "code": "while ( dx < dy ) {"}
{"text": "Titik cetak berdasarkan simetri 4 - cara", "code": "printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , x + xc , y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , - x + xc , y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , x + xc , - y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , - x + xc , - y + yc ) ;"}
{"text": "Memeriksa dan mengemas kini nilai parameter keputusan berdasarkan algoritma", "code": "if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } }"}
{"text": "Parameter Keputusan Wilayah 2", "code": "d2 = ( ( ry * ry ) * ( ( x + 0.5 ) * ( x + 0.5 ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ;"}
{"text": "Merancang titik rantau 2", "code": "while ( y >= 0 ) {"}
{"text": "Mata Percetakan Berdasarkan Simetri 4 - Jalan", "code": "printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , x + xc , y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , - x + xc , y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , x + xc , - y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , - x + xc , - y + yc ) ;"}
{"text": "Memeriksa dan mengemas kini nilai parameter berdasarkan algoritma", "code": "if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Untuk menarik elips jejari utama dan kecil 15, 10 berpusat pada (50, 50)", "code": "midptellipse ( 10 , 15 , 50 , 50 ) ; return 0 ; }"}
{"text": "Program c untuk menukar nombor heksadesimal ke binari", "code": "#include <stdio.h>"}
{"text": "berfungsi untuk menukar heksadesimal ke nombor binari", "code": "void HexToBin ( char * hexdec ) { long int i = 0 ; while ( hexdec [ i ] ) { switch ( hexdec [ i ] ) { case '0' : printf ( \"0000\" ) ; break ; case '1' : printf ( \"0001\" ) ; break ; case '2' : printf ( \"0010\" ) ; break ; case '3' : printf ( \"0011\" ) ; break ; case '4' : printf ( \"0100\" ) ; break ; case '5' : printf ( \"0101\" ) ; break ; case '6' : printf ( \"0110\" ) ; break ; case '7' : printf ( \"0111\" ) ; break ; case '8' : printf ( \"1000\" ) ; break ; case '9' : printf ( \"1001\" ) ; break ; case ' A ' : case ' a ' : printf ( \"1010\" ) ; break ; case ' B ' : case ' b ' : printf ( \"1011\" ) ; break ; case ' C ' : case ' c ' : printf ( \"1100\" ) ; break ; case ' D ' : case ' d ' : printf ( \"1101\" ) ; break ; case ' E ' : case ' e ' : printf ( \"1110\" ) ; break ; case ' F ' : case ' f ' : printf ( \"1111\" ) ; break ; default : printf ( \" Invalid hexadecimal digit % c \" , hexdec [ i ] ) ; } i ++ ; } }"}
{"text": "kod pemacu", "code": "int main ( ) {"}
{"text": "Dapatkan nombor heksadesimal", "code": "char hexdec [ 100 ] = \"1AC5\" ;"}
{"text": "Menukar heksadesimal ke binari", "code": "printf ( \" Equivalent Binary value is : \" HexToBin ( hexdec ) ; }"}
{"text": "Program C untuk membaca matriks persegi dan mencetak unsur -unsur di pepenjuru sekunder", "code": "#include <stdio.h> NEW_LINE int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ;"}
{"text": "Dapatkan Matriks Square", "code": "for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } }"}
{"text": "Paparkan matriks", "code": "printf ( \" The ▁ matrix ▁ is STRNEWLINE \" ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { printf ( \" % d TABSYMBOL \" , matrix [ row_index ] [ column_index ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Cetak elemen di pepenjuru sekunder", "code": "printf ( \" Elements on Secondary diagonal : \" for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) {"}
{"text": "Periksa unsur -unsur di pepenjuru sekunder", "code": "if ( ( row_index + column_index ) == size - 1 ) printf ( \" % d , ▁ \" , matrix [ row_index ] [ column_index ] ) ; } } return 0 ; }"}
{"text": "Program C untuk membaca matriks persegi dan mencetak unsur -unsur di atas pepenjuru sekunder", "code": "#include <stdio.h> NEW_LINE int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ;"}
{"text": "Dapatkan Matriks Square", "code": "for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } }"}
{"text": "Paparkan matriks", "code": "printf ( \" The ▁ matrix ▁ is STRNEWLINE \" ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { printf ( \" % d TABSYMBOL \" , matrix [ row_index ] [ column_index ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Cetak elemen di atas pepenjuru sekunder", "code": "printf ( \" Elements above Secondary diagonal are : \" for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) {"}
{"text": "Periksa unsur -unsur di atas pepenjuru sekunder", "code": "if ( ( row_index + column_index ) < size - 1 ) printf ( \" % d , ▁ \" , matrix [ row_index ] [ column_index ] ) ; } } return 0 ; }"}
{"text": "Program C untuk membaca matriks persegi dan mencetak elemen sudut", "code": "#include <stdio.h> NEW_LINE int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ;"}
{"text": "Dapatkan Matriks Square", "code": "for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } }"}
{"text": "Paparkan matriks", "code": "printf ( \" The ▁ matrix ▁ is STRNEWLINE \" ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { printf ( \" % d TABSYMBOL \" , matrix [ row_index ] [ column_index ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Cetak Elemen Sudut", "code": "printf ( \" Corner Elements are : \" for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) {"}
{"text": "Periksa elemen sudut", "code": "if ( ( row_index == 0 row_index == size - 1 ) && ( column_index == 0 column_index == size - 1 ) ) printf ( \" % d , ▁ \" , matrix [ row_index ] [ column_index ] ) ; } } return 0 ; }"}
{"text": "Program C untuk mencari jarak antara dua mata dalam 3 d.", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "berfungsi untuk mencetak jarak", "code": "void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float d = sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) + pow ( z2 - z1 , 2 ) * 1.0 ) ; printf ( \" Distance ▁ is ▁ % f \" , d ) ; return ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { float x1 = 2 ; float y1 = -5 ; float z1 = 7 ; float x2 = 3 ; float y2 = 4 ; float z2 = 5 ;"}
{"text": "fungsi panggilan untuk jarak", "code": "distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ; return 0 ; }"}
{"text": "Program c untuk mencari pasangan yang diperlukan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari bilangan pasangan yang unik", "code": "int No_Of_Pairs ( int N ) { int i = 1 ;"}
{"text": "Menggunakan formula yang diperolehi", "code": "while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) i ++ ; return ( i - 1 ) ; }"}
{"text": "Mencetak pasangan yang unik", "code": "void print_pairs ( int pairs ) { int i = 1 , mul ; for ( i = 1 ; i <= pairs ; i ++ ) { mul = i * ( i + 1 ) ; printf ( \" Pair ▁ no . ▁ % d ▁ - - > ▁ ( % d , ▁ % d ) STRNEWLINE \" , i , ( mul * i ) , mul * ( i + 1 ) ) ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int N = 500 , pairs , mul , i = 1 ; pairs = No_Of_Pairs ( N ) ; printf ( \" No . ▁ of ▁ pairs ▁ = ▁ % d ▁ STRNEWLINE \" , pairs ) ; print_pairs ( pairs ) ; return 0 ; }"}
{"text": "Program c untuk membahagikan nombor besar menjadi dua bahagian", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define MAX  100"}
{"text": "Fungsi untuk menambah dua nombor yang diwakili sebagai pelbagai watak.", "code": "void add ( char v1 [ ] , char v2 [ ] ) { int i , d , c = 0 ;"}
{"text": "panjang rentetan", "code": "int l1 = strlen ( v1 ) ; int l2 = strlen ( v2 ) ;"}
{"text": "memulakan kedudukan watak tambahan hingga 0", "code": "for ( i = l1 ; i < l2 ; i ++ ) v1 [ i ] = '0' ; for ( i = l2 ; i < l1 ; i ++ ) v2 [ i ] = '0' ;"}
{"text": "Menambah setiap elemen watak dan menyimpan bawa.", "code": "for ( i = 0 ; i < l1 i < l2 ; i ++ ) { d = ( v1 [ i ] - '0' ) + ( v2 [ i ] - '0' ) + c ; c = d / 10 ; d %= 10 ; v1 [ i ] = '0' + d ; }"}
{"text": "Jika sisa kekal.", "code": "while ( c ) { v1 [ i ] = '0' + ( c % 10 ) ; c /= 10 ; i ++ ; } v1 [ i ] = ' \\0' ; v2 [ l2 ] = ' \\0' ; }"}
{"text": "Fungsi untuk menolak dua nombor yang diwakili oleh rentetan.", "code": "void subs ( char v1 [ ] , char v2 [ ] ) { int i , d , c = 0 ;"}
{"text": "Mencari panjang rentetan.", "code": "int l1 = strlen ( v1 ) ; int l2 = strlen ( v2 ) ;"}
{"text": "Memulakan kedudukan watak tambahan kepada 0.", "code": "for ( i = l2 ; i < l1 ; i ++ ) v2 [ i ] = '0' ;"}
{"text": "Substrat setiap elemen watak.", "code": "for ( i = 0 ; i < l1 ; i ++ ) { d = ( v1 [ i ] - '0' - c ) - ( v2 [ i ] - '0' ) ; if ( d < 0 ) { d += 10 ; c = 1 ; } else c = 0 ; v1 [ i ] = '0' + d ; } v2 [ l2 ] = ' \\0' ; i = l1 - 1 ; while ( i > 0 && v1 [ i ] == '0' ) i -- ; v1 [ i + 1 ] = ' \\0' ; }"}
{"text": "Fungsi membahagikan nombor yang diwakili oleh array karakter yang tetap.", "code": "int divi ( char v [ ] , int q ) { int i , l = strlen ( v ) ; int c = 0 , d ;"}
{"text": "Membahagikan setiap elemen aksara dengan tetap.", "code": "for ( i = l - 1 ; i >= 0 ; i -- ) { d = c * 10 + ( v [ i ] - '0' ) ; c = d % q ; d /= q ; v [ i ] = '0' + d ; } i = l - 1 ; while ( i > 0 && v [ i ] == '0' ) i -- ; v [ i + 1 ] = ' \\0' ; return c ; }"}
{"text": "Fungsi untuk membalikkan array watak.", "code": "void rev ( char v [ ] ) { int l = strlen ( v ) ; int i ; char cc ;"}
{"text": "Membalikkan array.", "code": "for ( i = 0 ; i < l - 1 - i ; i ++ ) { cc = v [ i ] ; v [ i ] = v [ l - 1 - i ] ; v [ l - i - 1 ] = cc ; } }"}
{"text": "Fungsi Wrapper", "code": "void divideWithDiffK ( char a [ ] , char k [ ] ) {"}
{"text": "Membalikkan array watak.", "code": "rev ( a ) ; rev ( k ) ;"}
{"text": "Menambah setiap elemen kedua -dua array dan menyimpan jumlah dalam array a [].", "code": "add ( a , k ) ;"}
{"text": "Membahagikan array A [] oleh 2.", "code": "divi ( a , 2 ) ;"}
{"text": "Membalikkan array watak untuk mendapatkan output.", "code": "rev ( a ) ; printf ( \" % s ▁ \" , a ) ;"}
{"text": "Substrak setiap elemen array i. e mengira a = a - b", "code": "rev ( a ) ; subs ( a , k ) ;"}
{"text": "Membalikkan array watak untuk mendapatkan output.", "code": "rev ( a ) ; printf ( \" % s \" , a ) ; }"}
{"text": "Program yang didorong", "code": "int main ( ) { char a [ MAX ] = \"100\" , k [ MAX ] = \"20\" ; divideWithDiffK ( a , k ) ; return 0 ; }"}
{"text": "Program C untuk mencari kawasan persegi apabila pepenjuru diberikan.", "code": "#include <stdio.h>"}
{"text": "Mengembalikan kawasan persegi dari pepenjuru yang diberikan", "code": "double findArea ( double d ) { return ( d * d ) / 2 ; }"}
{"text": "Fungsi pemacu.", "code": "int main ( ) { double d = 10 ; printf ( \" % .2f \" , findArea ( d ) ) ; return 0 ; }"}
{"text": "Program c untuk mengira 1 ^ 2 + 2 ^ 2 + 3 ^ 2 + ... purata nombor persegi", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengira purata nombor persegi", "code": "float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 2 ; printf ( \" % f \" , AvgofSquareN ( n ) ) ; return 0 ; }"}
{"text": "Program C untuk mendapatkan jumlah siri", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Berfungsi untuk mendapatkan siri ini", "code": "double Series ( double x , int n ) { double sum = 1 , term = 1 , fct , j , y = 2 , m ;"}
{"text": "Jumlah n - 1 istilah bermula dari tempoh 2 nd", "code": "int i ; for ( i = 1 ; i < n ; i ++ ) { fct = 1 ; for ( j = 1 ; j <= y ; j ++ ) { fct = fct * j ; } term = term * ( -1 ) ; m = term * pow ( x , y ) / fct ; sum = sum + m ; y += 2 ; } return sum ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { double x = 9 ; int n = 10 ; printf ( \" % .4f \" , Series ( x , n ) ) ; return 0 ; }"}
{"text": "Program C untuk mencari nombor utama terbesar", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Fungsi untuk mencari faktor utama terbesar", "code": "long long maxPrimeFactors ( long long n ) {"}
{"text": "Memulakan pemboleh ubah faktor utama maksimum dengan yang paling rendah", "code": "long long maxPrime = -1 ;"}
{"text": "Cetak bilangan 2 s yang membahagikan n", "code": "while ( n % 2 == 0 ) { maxPrime = 2 ;"}
{"text": "n >> = 1; bersamaan dengan n /= 2", "code": "}"}
{"text": "n mesti ganjil pada ketika ini", "code": "while ( n % 3 == 0 ) { maxPrime = 3 ; n = n / 3 ; }"}
{"text": "Sekarang kita hanya perlu berulang untuk bilangan bulat yang tidak mempunyai faktor utama 2 dan 3", "code": "for ( int i = 5 ; i <= sqrt ( n ) ; i += 6 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } while ( n % ( i + 2 ) == 0 ) { maxPrime = i + 2 ; n = n / ( i + 2 ) ; } }"}
{"text": "Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor perdana yang lebih besar daripada 4", "code": "if ( n > 4 ) maxPrime = n ; return maxPrime ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { long long n = 15 ; printf ( \" % lld STRNEWLINE \" , maxPrimeFactors ( n ) ) ; n = 25698751364526 ; printf ( \" % lld \" , maxPrimeFactors ( n ) ) ; return 0 ; }"}
{"text": "C Program untuk mencari jumlah siri 1 + x ^ 2/2 + x ^ 3/3 + .... + x ^ n / n", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "C kod untuk mencetak jumlah siri", "code": "double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int x = 2 ; int n = 5 ; printf ( \" % .2f \" , sum ( x , n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari nombor Chiliagon Nth", "code": "int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ chiliagon ▁ Number ▁ is ▁ = ▁ % d \" , chiliagonNum ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari nombor pentacontagon nth", "code": "int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ pentacontagon ▁ Number ▁ is ▁ = ▁ % d \" , pentacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Program c ++ untuk mencari nilai array dengan berulang kali menggantikan elemen max 2 dengan perbezaan mutlak mereka", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "berfungsi yang mengembalikan nilai terakhir array", "code": "int lastElement ( vector < int > & arr ) {"}
{"text": "Bina max_heap binari.", "code": "priority_queue < int > pq ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { pq . push ( arr [ i ] ) ; }"}
{"text": "Untuk elemen max 2", "code": "int m1 , m2 ;"}
{"text": "Berulang sehingga giliran tidak kosong", "code": "while ( ! pq . empty ( ) ) {"}
{"text": "Sekiranya hanya 1 elemen yang tersisa", "code": "if ( pq . size ( ) == 1 )"}
{"text": "Kembalikan nilai baki terakhir", "code": "return pq . top ( ) ; m1 = pq . top ( ) ; pq . pop ( ) ; m2 = pq . top ( ) ; pq . pop ( ) ;"}
{"text": "periksa perbezaan itu bukan sifar", "code": "if ( m1 != m2 ) pq . push ( m1 - m2 ) ; }"}
{"text": "akhirnya kembali 0", "code": "return 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { vector < int > arr = { 2 , 7 , 4 , 1 , 8 , 1 , 1 } ; cout << lastElement ( arr ) << endl ; return 0 ; }"}
{"text": "C Pelaksanaan mengira bilangan digit dalam nombor", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Berfungsi untuk mengira bilangan digit dalam nombor", "code": "int countDigit ( long long n ) { return ( floor ( log10 ( n ) + 1 ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { double N = 80 ; printf ( \" % d \" , countDigit ( N ) ) ; return 0 ; }"}
{"text": "C Pelaksanaan untuk mencari jumlah siri 1 + x ^ 2 + x ^ 3 + .... + x ^ n", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Berfungsi untuk mencetak jumlah siri", "code": "double sum ( int x , int n ) { double i , total = 1.0 , multi = x ;"}
{"text": "Tempoh Siri Pertama", "code": "printf ( \"1 ▁ \" ) ;"}
{"text": "Gelung untuk mencari terma n siri", "code": "for ( i = 1 ; i < n ; i ++ ) { total = total + multi ; printf ( \" % .1f ▁ \" , multi ) ; multi = multi * x ; } printf ( \" STRNEWLINE \" ) ; return total ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int x = 2 ; int n = 5 ; printf ( \" % .2f \" , sum ( x , n ) ) ; return 0 ; }"}
{"text": "Pelaksanaan C untuk mencari N Modulo 4 menggunakan bitwise dan operator", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencari selebihnya", "code": "int findRemainder ( int n ) {"}
{"text": "Bitwise dan dengan 3", "code": "int x = n & 3 ;"}
{"text": "kembali x", "code": "return x ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int N = 43 ; int ans = findRemainder ( N ) ; printf ( \" % d \" , ans ) ; return 0 ; }"}
{"text": "Program C untuk mencari siri nombor segi tiga", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencari nombor segi tiga", "code": "void triangular_series ( int n ) { int i , j = 1 , k = 1 ;"}
{"text": "Untuk setiap lelaran meningkat j sebanyak 1 dan masukkannya ke k", "code": "for ( i = 1 ; i <= n ; i ++ ) { printf ( \" ▁ % d ▁ \" , k ) ;"}
{"text": "Meningkatkan J sebanyak 1", "code": "j = j + 1 ;"}
{"text": "Tambahkan nilai j ke k dan kemas kini k", "code": "k = k + j ; } }"}
{"text": "Fungsi yang didorong", "code": "int main ( ) { int n = 5 ; triangular_series ( n ) ; return 0 ; }"}
{"text": "Program C Rekursif untuk mengira bilangan digit dalam nombor", "code": "#include <stdio.h> NEW_LINE int countDigit ( long long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; }"}
{"text": "Kod pemacu", "code": "int main ( void ) { long long n = 345289467 ; printf ( \" Number ▁ of ▁ digits ▁ : ▁ % d \" , countDigit ( n ) ) ; return 0 ; }"}
{"text": "Program C Untuk memeriksa sama ada nombor itu adalah sihir atau tidak.", "code": "#include <stdio.h> NEW_LINE int main ( ) {"}
{"text": "Menerima input sampel", "code": "int x = 1234 ;"}
{"text": "Keadaan untuk memeriksa nombor sihir", "code": "if ( x % 9 == 1 ) printf ( \" Magic ▁ Number \" ) ; else printf ( \" Not ▁ a ▁ Magic ▁ Number \" ) ; return 0 ; }"}
{"text": "Program C Untuk menunjukkan bahawa nombor Fibonacci yang boleh dibahagikan dengan indeks mereka mempunyai indeks sebagai kuasa 5 atau berganda 12.", "code": "#include <stdio.h> NEW_LINE #define MAX  100 NEW_LINE int main ( ) {"}
{"text": "Menyimpan nombor Fibonacci", "code": "long long int arr [ MAX ] ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] ; printf ( \" Fibonacci ▁ numbers ▁ divisible ▁ by ▁ \" \" their ▁ indexes ▁ are ▁ : STRNEWLINE \" ) ; for ( int i = 1 ; i < MAX ; i ++ ) if ( arr [ i ] % i == 0 ) printf ( \" % d ▁ \" , i ) ; }"}
{"text": "Program c untuk mencari nilai maksimum integer yang faktorial boleh dikira pada sistem anda", "code": "#include <stdio.h> NEW_LINE int findMaxValue ( ) { int res = 2 ; long long int fact = 2 ; while ( 1 ) {"}
{"text": "Apabila fakta melintasi saiznya, ia memberikan nilai negatif", "code": "if ( fact < 0 ) break ; res ++ ; fact = fact * res ; } return res - 1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { printf ( \" Maximum ▁ value ▁ of ▁ integer ▁ : ▁ % d STRNEWLINE \" , findMaxValue ( ) ) ; return 0 ; }"}
{"text": "Program c ++ untuk menjana digit k pertama n ^ n", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "berfungsi untuk mengira digit k pertama n ^ n", "code": "long long firstkdigits ( int n , int k ) {"}
{"text": "Ambil log10 n ^ n. log10 (n ^ n) = n * log10 (n)", "code": "long double product = n * log10 ( n ) ;"}
{"text": "Kami kini cuba memisahkan bahagian perpuluhan dan integral dari / produk. Fungsi lantai mengembalikan integer terkecil kurang daripada atau sama dengan hujah. Jadi dalam kes ini, lantai produk (produk) akan memberi kita bahagian perpuluhan produk", "code": "long double decimal_part = product - floor ( product ) ;"}
{"text": "Kami kini mengeksplorasi ini dengan menaikkan 10 ke dalam kuasa perpuluhan", "code": "decimal_part = pow ( 10 , decimal_part ) ;"}
{"text": "Kami kini cuba mencari kuasa 10 yang mana kita perlu membiak bahagian perpuluhan untuk mendapatkan jawapan terakhir kami", "code": "long long digits = pow ( 10 , k - 1 ) , i = 0 ; return decimal_part * digits ; }"}
{"text": "fungsi pemacu", "code": "int main ( ) { int n = 1450 ; int k = 6 ; cout << firstkdigits ( n , k ) ; return 0 ; }"}
{"text": "C Program mencari pendaraban modulo", "code": "#include <stdio.h>"}
{"text": "Pulangan (a * b) % mod", "code": "long long moduloMultiplication ( long long a , long long b , long long mod ) {"}
{"text": "Kemas kini A jika lebih daripada atau sama dengan mod", "code": "a %= mod ; while ( b ) {"}
{"text": "Sekiranya B adalah ganjil, tambahkan dengan hasil", "code": "if ( b & 1 ) res = ( res + a ) % mod ;"}
{"text": "Di sini kita menganggap bahawa melakukan 2 * A tidak menyebabkan limpahan", "code": "a = ( 2 * a ) % mod ;"}
{"text": "b >> = 1; b = b / 2", "code": "} return res ; }"}
{"text": "Program Pemandu", "code": "int main ( ) { long long a = 10123465234878998 ; long long b = 65746311545646431 ; long long m = 10005412336548794 ; printf ( \" % lld \" , moduloMultiplication ( a , b , m ) ) ; return 0 ; }"}
{"text": "Mengemas kini n dengan 2 n", "code": "n = 2 * n ;"}
{"text": "(n & (n - 1)) => Memeriksa sama ada kita boleh menulis 2 n sebagai 2^k jika ya (tidak boleh mewakili 2n sebagai 2^k) maka jawab 1 jika tidak (boleh mewakili 2n sebagai 2^k) kemudian jawab 0", "code": "return ( ( n & ( n - 1 ) ) != 0 ) ; } int main ( ) { long long int n = 10 ; printf ( \" % lld \" , canBeSumofConsec ( n ) ) ; }"}
{"text": "Program C untuk melaksanakan Game of NIM. Program ini mengandaikan bahawa kedua -dua pemain bermain secara optimum", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE #define COMPUTER  1 NEW_LINE #define HUMAN  2"}
{"text": "Struktur untuk memegang dua parameter langkah bergerak mempunyai dua parameter - 1) pile_index = indeks longgokan dari batu mana akan dikeluarkan 2) batu_removed = bilangan batu yang dikeluarkan dari longgokan diindeks = pile_index", "code": "struct move { int pile_index ; int stones_removed ; } ;"}
{"text": "Fungsi C untuk mengeluarkan keadaan permainan semasa.", "code": "void showPiles ( int piles [ ] , int n ) { int i ; printf ( \" Current ▁ Game ▁ Status ▁ - > ▁ \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , piles [ i ] ) ; printf ( \" STRNEWLINE \" ) ; return ; }"}
{"text": "Fungsi C yang kembali benar jika permainan telah berakhir dan palsu jika permainan belum berakhir", "code": "bool gameOver ( int piles [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( piles [ i ] != 0 ) return ( false ) ; return ( true ) ; }"}
{"text": "Fungsi C untuk mengisytiharkan pemenang permainan", "code": "void declareWinner ( int whoseTurn ) { if ( whoseTurn == COMPUTER ) printf ( \" HUMAN won \" else printf ( \" COMPUTER won \" return ; }"}
{"text": "Fungsi C untuk mengira jumlah NIM di mana -mana titik permainan.", "code": "int calculateNimSum ( int piles [ ] , int n ) { int i , nimsum = piles [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) nimsum = nimsum ^ piles [ i ] ; return ( nimsum ) ; }"}
{"text": "Fungsi C untuk membuat langkah permainan NIM", "code": "void makeMove ( int piles [ ] , int n , struct move * moves ) { int i , nim_sum = calculateNimSum ( piles , n ) ;"}
{"text": "Pemain yang mempunyai giliran semasa berada pada kedudukan yang menang. Oleh itu, dia / dia bermain secara optimum dan cuba membuat Nim - jumlahnya sebagai 0", "code": "if ( nim_sum != 0 ) { for ( i = 0 ; i < n ; i ++ ) {"}
{"text": "Jika ini bukan langkah yang menyalahi undang -undang maka membuat langkah ini.", "code": "if ( ( piles [ i ] ^ nim_sum ) < piles [ i ] ) { ( * moves ) . pile_index = i ; ( * moves ) . stones_removed = piles [ i ] - ( piles [ i ] ^ nim_sum ) ; piles [ i ] = ( piles [ i ] ^ nim_sum ) ; break ; } } }"}
{"text": "Jika anda ingin memasukkan diri anda kemudian keluarkan fungsi rand () dan ubah kod untuk mengambil input. Tetapi ingat, anda masih tidak dapat mengubah nasib/ramalan anda.", "code": "else {"}
{"text": "Buat array untuk memegang indeks buasir bukan kosong", "code": "int non_zero_indices [ n ] , count ; for ( i = 0 , count = 0 ; i < n ; i ++ ) if ( piles [ i ] > 0 ) non_zero_indices [ count ++ ] = i ; ( * moves ) . pile_index = ( rand ( ) % ( count ) ) ; ( * moves ) . stones_removed = 1 + ( rand ( ) % ( piles [ ( * moves ) . pile_index ] ) ) ; piles [ ( * moves ) . pile_index ] = piles [ ( * moves ) . pile_index ] - ( * moves ) . stones_removed ; if ( piles [ ( * moves ) . pile_index ] < 0 ) piles [ ( * moves ) . pile_index ] = 0 ; } return ; }"}
{"text": "Fungsi C untuk memainkan permainan Nim", "code": "void playGame ( int piles [ ] , int n , int whoseTurn ) { printf ( \" GAME STARTS \" struct move moves ; while ( gameOver ( piles , n ) == false ) { showPiles ( piles , n ) ; makeMove ( piles , n , & moves ) ; if ( whoseTurn == COMPUTER ) { printf ( \" COMPUTER ▁ removes ▁ % d ▁ stones ▁ from ▁ pile ▁ \" \" at ▁ index ▁ % d STRNEWLINE \" , moves . stones_removed , moves . pile_index ) ; whoseTurn = HUMAN ; } else { printf ( \" HUMAN ▁ removes ▁ % d ▁ stones ▁ from ▁ pile ▁ at ▁ \" \" index ▁ % d STRNEWLINE \" , moves . stones_removed , moves . pile_index ) ; whoseTurn = COMPUTER ; } } showPiles ( piles , n ) ; declareWinner ( whoseTurn ) ; return ; } void knowWinnerBeforePlaying ( int piles [ ] , int n , int whoseTurn ) { printf ( \" Prediction ▁ before ▁ playing ▁ the ▁ game ▁ - > ▁ \" ) ; if ( calculateNimSum ( piles , n ) != 0 ) { if ( whoseTurn == COMPUTER ) printf ( \" COMPUTER ▁ will ▁ win STRNEWLINE \" ) ; else printf ( \" HUMAN ▁ will ▁ win STRNEWLINE \" ) ; } else { if ( whoseTurn == COMPUTER ) printf ( \" HUMAN ▁ will ▁ win STRNEWLINE \" ) ; else printf ( \" COMPUTER ▁ will ▁ win STRNEWLINE \" ) ; } return ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) {"}
{"text": "Kes ujian 1", "code": "int piles [ ] = { 3 , 4 , 5 } ; int n = sizeof ( piles ) / sizeof ( piles [ 0 ] ) ;"}
{"text": "Kami akan meramalkan keputusan sebelum bermain komputer bermula dahulu", "code": "knowWinnerBeforePlaying ( piles , n , COMPUTER ) ;"}
{"text": "Marilah kita bermain permainan dengan komputer bermula dahulu dan periksa sama ada ramalan kita betul atau tidak", "code": "playGame ( piles , n , COMPUTER ) ;"}
{"text": "Kes ujian 2 Int Piles [] = {3, 4, 7}; int n = sizeof (buasir) / sizeof (buasir [0]); Kami akan meramalkan keputusan sebelum bermain manusia (anda) bermula dahulu", "code": "knowWinnerBeforePlaying ( piles , n , COMPUTER ) ;"}
{"text": "Marilah kita bermain permainan dengan komputer bermula dahulu dan periksa sama ada ramalan kita betul atau tidak Playgame (Piles, N, Manusia);", "code": "return ( 0 ) ; }"}
{"text": "Program c untuk mencari akar persamaan kuadrat", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Cetak Akar Persamaan Kuadratik kapak * 2 + bx + x", "code": "void findRoots ( int a , int b , int c ) {"}
{"text": "Sekiranya A adalah 0, maka persamaan tidak kuadrat, tetapi linear", "code": "if ( a == 0 ) { printf ( \" Invalid \" ) ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { printf ( \" Roots ▁ are ▁ real ▁ and ▁ different ▁ STRNEWLINE \" ) ; printf ( \" % f % f \" , ( double ) ( - b + sqrt_val ) / ( 2 * a ) , ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ; } else if ( d == 0 ) { printf ( \" Roots ▁ are ▁ real ▁ and ▁ same ▁ STRNEWLINE \" ) ; printf ( \" % f \" , - ( double ) b / ( 2 * a ) ) ; }"}
{"text": "lain d <0", "code": "{ printf ( \" Roots ▁ are ▁ complex ▁ STRNEWLINE \" ) ; printf ( \" % f ▁ + ▁ i % f % f - i % f \" , - ( double ) b / ( 2 * a ) , sqrt_val / ( 2 * a ) , - ( double ) b / ( 2 * a ) , sqrt_val / ( 2 * a ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { int a = 1 , b = -7 , c = 12 ;"}
{"text": "Panggilan fungsi", "code": "findRoots ( a , b , c ) ; return 0 ; }"}
{"text": "Program c untuk menukar nombor dari mana -mana pangkalan ke perpuluhan", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Untuk mengembalikan nilai char. Sebagai contoh, 2 dikembalikan untuk '2'. 10 dikembalikan untuk 'A', 11 untuk 'B'", "code": "int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; }"}
{"text": "Berfungsi untuk menukar nombor dari asas 'b' yang diberikan kepada perpuluhan", "code": "int toDeci ( char * str , int base ) { int len = strlen ( str ) ;"}
{"text": "Memulakan kuasa asas", "code": "int power = 1 ;"}
{"text": "Memulakan hasil", "code": "int num = 0 ; int i ;"}
{"text": "Setara perpuluhan adalah str [len - 1] * 1 + str [len - 2] * asas + str [len - 3] * (asas ^ 2) + ...", "code": "for ( i = len - 1 ; i >= 0 ; i -- ) {"}
{"text": "Digit dalam nombor input mestilah kurang daripada asas nombor", "code": "if ( val ( str [ i ] ) >= base ) { printf ( \" Invalid ▁ Number \" ) ; return -1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { char str [ ] = \"11A \" ; int base = 16 ; printf ( \" Decimal ▁ equivalent ▁ of ▁ % s ▁ in ▁ base ▁ % d ▁ is ▁ \" \" ▁ % d STRNEWLINE \" , str , base , toDeci ( str , base ) ) ; return 0 ; }"}
{"text": "C Program untuk mencetak penyelesaian siri F (n) = (1) + (2 * 3) + (4 * 5 * 6). . . n Menggunakan rekursi", "code": "#include <stdio.h>"}
{"text": "Fungsi rekursif untuk mencari jumlah siri yang dikira - bilangan terma sehingga jumlah terma telah dikira semasa - bilangan istilah yang mana jumlahnya harus dikalkulasi n - bilangan istilah dalam fungsi yang akan dikira", "code": "int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ;"}
{"text": "Memeriksa keadaan penamatan", "code": "if ( current == N + 1 ) return 0 ;"}
{"text": "produk terma hingga semasa", "code": "for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ;"}
{"text": "Panggilan rekursif untuk menambahkan istilah seterusnya dalam siri ini", "code": "return cur + seriesSum ( i , current + 1 , N ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Bilangan istilah input dalam siri ini", "code": "int N = 5 ;"}
{"text": "memohon fungsi untuk mengira jumlah", "code": "printf ( \" % d STRNEWLINE \" , seriesSum ( 1 , 1 , N ) ) ; return 0 ; }"}
{"text": "Program c untuk pengekodan fibonacci dari integer positif n", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Untuk mengehadkan nombor Fibonacci terbesar untuk digunakan", "code": "#define N  30"}
{"text": "Array untuk menyimpan nombor Fibonacci. Fib [i] akan menyimpan (i + 2) 'nombor fibonacci", "code": "int fib [ N ] ;"}
{"text": "Nilai menyimpan dalam FIB dan pulangan indeks nombor Fibonacci terbesar lebih kecil daripada n.", "code": "int largestFiboLessOrEqual ( int n ) {"}
{"text": "FIB [0] Kedai 2 nd Fibonacci no.", "code": "fib [ 0 ] = 1 ;"}
{"text": "FIB [1] menyimpan 3 rd Fibonacci no.", "code": "fib [ 1 ] = 2 ;"}
{"text": "Terus menjana bilangan baki sementara nombor yang dihasilkan sebelumnya lebih kecil", "code": "int i ; for ( i = 2 ; fib [ i - 1 ] <= n ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ;"}
{"text": "Indeks pulangan nombor Fibonacci terbesar lebih kecil daripada atau sama dengan n. Perhatikan bahawa gelung di atas berhenti apabila FIB [i - 1] menjadi lebih besar.", "code": "return ( i - 2 ) ; }"}
{"text": "Mengembalikan penunjuk ke rentetan char yang sepadan dengan kod untuk n", "code": "char * fibonacciEncoding ( int n ) { int index = largestFiboLessOrEqual ( n ) ;"}
{"text": "memperuntukkan memori untuk codeword", "code": "char * codeword = ( char * ) malloc ( sizeof ( char ) * ( index + 3 ) ) ;"}
{"text": "Indeks fibonacci terbesar f <= n", "code": "int i = index ; while ( n ) {"}
{"text": "Tandakan penggunaan Fibonacci F (1 bit)", "code": "codeword [ i ] = '1' ;"}
{"text": "Tolak f dari n", "code": "n = n - fib [ i ] ;"}
{"text": "Pindah ke Fibonacci hanya lebih kecil daripada f", "code": "i = i - 1 ;"}
{"text": "Tandakan semua fibonacci> n seperti yang tidak digunakan (0 bit), maju ke belakang", "code": "while ( i >= 0 && fib [ i ] > n ) { codeword [ i ] = '0' ; i = i - 1 ; } }"}
{"text": "tambahan '1' bit", "code": "codeword [ index + 1 ] = '1' ; codeword [ index + 2 ] = ' \\0' ;"}
{"text": "Pointer Pointer ke Codeword", "code": "return codeword ; }"}
{"text": "fungsi pemacu", "code": "int main ( ) { int n = 143 ; printf ( \" Fibonacci ▁ code ▁ word ▁ for ▁ % d ▁ is ▁ % s STRNEWLINE \" , n , fibonacciEncoding ( n ) ) ; return 0 ; }"}
{"text": "Program C untuk mengira dataran dalam segi empat tepat saiz m x n", "code": "#include <stdio.h>"}
{"text": "Mengembalikan kiraan semua dataran dalam segi empat tepat saiz m x n", "code": "int countSquares ( int m , int n ) {"}
{"text": "Jika n lebih kecil, swap m dan n", "code": "if ( n < m ) { int temp = m ; m = n ; n = temp ; }"}
{"text": "Sekarang n adalah dimensi yang lebih besar, gunakan formula", "code": "return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int m = 4 , n = 3 ; printf ( \" Count ▁ of ▁ squares ▁ is ▁ % d \" , countSquares ( m , n ) ) ; }"}
{"text": "Fungsi ini mendapati semua prima yang lebih kecil daripada 'had' menggunakan penapis mudah Eratosthenes.", "code": "void simpleSieve ( int limit ) {"}
{"text": "Buat array boolean \"Mark [0. Limit - 1]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Mark [P] akhirnya akan palsu jika 'P' bukanlah perdana, yang lain benar.", "code": "bool mark [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) { mark [ i ] = true ; }"}
{"text": "Satu demi satu melintasi semua nombor supaya gandaan mereka dapat ditandakan sebagai komposit.", "code": "for ( int p = 2 ; p * p < limit ; p ++ ) {"}
{"text": "Sekiranya p tidak berubah, maka itu adalah perdana", "code": "if ( mark [ p ] == true ) {"}
{"text": "Kemas kini semua gandaan p", "code": "for ( int i = p * p ; i < limit ; i += p ) mark [ i ] = false ; } }"}
{"text": "Cetak semua nombor perdana dan simpannya di Perdana", "code": "for ( int p = 2 ; p < limit ; p ++ ) if ( mark [ p ] == true ) cout << p << \" ▁ \" ; }"}
{"text": "Program Ieratif C untuk mencari songsang modular menggunakan algoritma euclid yang dilanjutkan", "code": "#include <stdio.h>"}
{"text": "Mengembalikan modulo songsang dengan m menggunakan asumsi algoritma euclid yang dilanjutkan: a dan m adalah coprimes, i. e. , GCD (a, m) = 1", "code": "int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) {"}
{"text": "Q adalah kota", "code": "int q = a / m ; int t = m ;"}
{"text": "m selebihnya sekarang, proses sama dengan algo Euclid", "code": "m = a % m , a = t ; t = y ;"}
{"text": "Kemas kini Y dan X", "code": "y = x - q * y ; x = t ; }"}
{"text": "Buat x positif", "code": "if ( x < 0 ) x += m0 ; return x ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int a = 3 , m = 11 ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" Modular ▁ multiplicative ▁ inverse ▁ is ▁ % d STRNEWLINE \" , modInverse ( a , m ) ) ; return 0 ; }"}
{"text": "Program C Ringkas untuk Mengira Fungsi Tatent Euler", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mengembalikan GCD a dan b", "code": "int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }"}
{"text": "Kaedah mudah untuk menilai fungsi Euler Totient", "code": "int phi ( unsigned int n ) { unsigned int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) printf ( \" phi ( % d ) ▁ = ▁ % d STRNEWLINE \" , n , phi ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk mengira fungsi Euler »menggunakan formula produk uuler", "code": "#include <stdio.h> NEW_LINE int phi ( int n ) {"}
{"text": "Pertimbangkan semua faktor utama n dan untuk setiap faktor utama p, membiak hasil dengan (1 - 1 / p)", "code": "for ( int p = 2 ; p * p <= n ; ++ p ) {"}
{"text": "Semak sama ada P adalah faktor utama.", "code": "if ( n % p == 0 ) {"}
{"text": "Jika ya, maka kemas kini n dan hasil", "code": "while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } }"}
{"text": "Sekiranya n mempunyai faktor utama yang lebih besar daripada sqrt (n) (boleh ada - kebanyakan faktor utama seperti itu)", "code": "if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) printf ( \" phi ( % d ) ▁ = ▁ % d STRNEWLINE \" , n , phi ( n ) ) ; return 0 ; }"}
{"text": "Program C untuk mencetak nombor N Fibonacci pertama", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencetak nombor fibonacci pertama", "code": "void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; printf ( \" % d ▁ \" , f1 ) ; for ( i = 1 ; i < n ; i ++ ) { printf ( \" % d ▁ \" , f2 ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) { printFibonacciNumbers ( 7 ) ; return 0 ; }"}
{"text": "Program C untuk mencari LCM sebanyak dua nombor", "code": "#include <stdio.h>"}
{"text": "Fungsi rekursif untuk mengembalikan GCD a dan b", "code": "int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }"}
{"text": "Berfungsi untuk mengembalikan LCM dua nombor", "code": "int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int a = 15 , b = 20 ; printf ( \" LCM ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , lcm ( a , b ) ) ; return 0 ; }"}
{"text": "Program C untuk mencetak nombor tertentu dalam kata -kata. Program ini mengendalikan nombor dari 0 hingga 9999", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h>"}
{"text": "Fungsi yang mencetak nombor yang diberikan dalam perkataan", "code": "void convert_to_words ( char * num ) { int len = strlen ("}
{"text": "Kes asas", "code": "if ( len == 0 ) { fprintf ( stderr , \" empty ▁ string STRNEWLINE \" ) ; return ; } if ( len > 4 ) { fprintf ( stderr , \" Length ▁ more ▁ than ▁ 4 ▁ is ▁ not ▁ supported STRNEWLINE \" ) ; return ; }"}
{"text": "Rentetan pertama tidak digunakan, ia adalah untuk membuat pengindeksan array mudah", "code": "char * single_digits [ ] = { \" zero \" , \" one \" , \" two \" , \" three \" , \" four \" , \" five \" , \" six \" , \" seven \" , \" eight \" , \" nine \" } ;"}
{"text": "Rentetan pertama tidak digunakan, ia adalah untuk membuat pengindeksan array mudah", "code": "char * two_digits [ ] = { \" \" , \" ten \" , \" eleven \" , \" twelve \" , \" thirteen \" , \" fourteen \" , \" fifteen \" , \" sixteen \" , \" seventeen \" , \" eighteen \" , \" nineteen \" } ;"}
{"text": "Dua rentetan pertama tidak digunakan, mereka membuat pengindeksan array mudah", "code": "char * tens_multiple [ ] = { \" \" , \" \" , \" twenty \" , \" thirty \" , \" forty \" , \" fifty \" , \" sixty \" , \" seventy \" , \" eighty \" , \" ninety \" } ; char * tens_power [ ] = { \" hundred \" , \" thousand \" } ;"}
{"text": "Digunakan untuk tujuan debug sahaja", "code": "printf ( \" % s : \" , num ) ;"}
{"text": "Untuk nombor digit tunggal", "code": "if ( len == 1 ) { printf ( \" % s STRNEWLINE \" , single_digits [ * num - '0' ] ) ; return ; }"}
{"text": "Iterate sementara num tidak '\\ 0'", "code": "while ( * num != ' \\0' ) {"}
{"text": "Laluan kod untuk 2 digit pertama", "code": "if ( len >= 3 ) { if ( * num - '0' != 0 ) { printf ( \" % s ▁ \" , single_digits [ * num - '0' ] ) ; printf ( \" % s ▁ \" ,"}
{"text": "tens_power [len - 3]); di sini boleh menjadi 3 atau 4", "code": "} -- len ; }"}
{"text": "Laluan kod untuk 2 digit terakhir", "code": "else {"}
{"text": "Perlu mengendalikan 10 - 19. Jumlah dua digit digunakan sebagai indeks \"dua _ digit\" pelbagai rentetan", "code": "if ( * num == '1' ) { int sum = * num - '0' + * ( num + 1 ) - '0' ; printf ( \" % s STRNEWLINE \" , two_digits [ sum ] ) ; return ; }"}
{"text": "Perlu mengendalikan 20 dengan jelas", "code": "else if ( * num = = '2' && * ( num + 1 ) == '0' ) { printf ( \" twenty STRNEWLINE \" ) ; return ; }"}
{"text": "Selebihnya dua nombor digit i. e. , 21 hingga 99", "code": "else { int i = * num - '0' ; printf ( \" % s ▁ \" , i ? tens_multiple [ i ] : \" \" ) ; ++ num ; if ( * num != '0' ) printf ( \" % s ▁ \" , single_digits [ * num - '0' ] ) ; } } ++ num ; } }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( void ) { convert_to_words ( \"9923\" ) ; convert_to_words ( \"523\" ) ; convert_to_words ( \"89\" ) ; convert_to_words ( \"8\" ) ; return 0 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { printf ( \" Sum ▁ = ▁ % d \" , add ( 3 , 4 ) ) ; return 0 ; }"}
{"text": "Dengan mengandaikan bahawa integer mengambil 4 bait, boleh ada maksimum 10 digit dalam integer", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE # define MAX  11 NEW_LINE bool isMultipleof5 ( int n ) { char str [ MAX ] ; int len = strlen ( str ) ;"}
{"text": "Periksa watak terakhir rentetan", "code": "if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) printf ( \" % d ▁ is ▁ multiple ▁ of ▁ 5 STRNEWLINE \" , n ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ multiple ▁ of ▁ 5 STRNEWLINE \" , n ) ; return 0 ; }"}
{"text": "Program c untuk melaksanakan pendekatan di atas", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Struktur nod dalam senarai berkaitan XOR", "code": "struct Node {"}
{"text": "Menyimpan nilai data nod", "code": "int data ;"}
{"text": "Kedai xor penunjuk sebelumnya dan penunjuk seterusnya", "code": "struct Node * nxp ; } ;"}
{"text": "Berfungsi untuk mencari xor alamat dua nod", "code": "struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; }"}
{"text": "Berfungsi untuk memasukkan nod dengan nilai yang diberikan pada kedudukan yang diberikan", "code": "struct Node * insert ( struct Node * * head , int value ) {"}
{"text": "Sekiranya senarai yang dipautkan XOR kosong", "code": "if ( * head == NULL ) {"}
{"text": "Memulakan nod baru", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Menyimpan nilai data dalam nod", "code": "node -> data = value ;"}
{"text": "Kedai xor penunjuk sebelumnya dan seterusnya", "code": "node -> nxp = XOR ( NULL , NULL ) ;"}
{"text": "Kemas kini penunjuk nod kepala", "code": "* head = node ; }"}
{"text": "Sekiranya senarai yang dipautkan XOR tidak kosong", "code": "else {"}
{"text": "Menyimpan alamat nod semasa", "code": "struct Node * curr = * head ;"}
{"text": "Menyimpan alamat nod sebelumnya", "code": "struct Node * prev = NULL ;"}
{"text": "Memulakan nod baru", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Kemas kini alamat nod curr", "code": "curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ;"}
{"text": "Kemas kini alamat nod baru", "code": "node -> nxp = XOR ( NULL , curr ) ;"}
{"text": "Kemas kini kepala", "code": "* head = node ;"}
{"text": "Kemas kini nilai data nod semasa", "code": "node -> data = value ; } return * head ; }"}
{"text": "Berfungsi untuk mencetak elemen senarai yang dipautkan XOR", "code": "void printList ( struct Node * * head ) {"}
{"text": "Kedai penunjuk xor dalam nod semasa", "code": "struct Node * curr = * head ;"}
{"text": "Kedai penunjuk xor dalam nod sebelumnya", "code": "struct Node * prev = NULL ;"}
{"text": "Kedai penunjuk xor dalam nod seterusnya", "code": "struct Node * next ;"}
{"text": "Senarai Linked Traverse XOR", "code": "while ( curr != NULL ) {"}
{"text": "Cetak nod semasa", "code": "printf ( \" % d ▁ \" , curr -> data ) ;"}
{"text": "Ke hadapan traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Kemas kini sebelum ini", "code": "prev = curr ;"}
{"text": "Kemas kini Curr", "code": "curr = next ; } }"}
{"text": "Membalikkan senarai yang dipautkan dalam kumpulan k", "code": "struct Node * RevInGrp ( struct Node * * head , int K , int len ) {"}
{"text": "Kedai kepala nod", "code": "struct Node * curr = * head ;"}
{"text": "Sekiranya senarai yang dipautkan XOR kosong", "code": "if ( curr == NULL ) return NULL ;"}
{"text": "Kedai -kedai Node dibalikkan dalam kumpulan semasa", "code": "int count = 0 ;"}
{"text": "Kedai penunjuk xor dalam nod sebelumnya", "code": "struct Node * prev = NULL ;"}
{"text": "Kedai penunjuk xor dalam nod seterusnya", "code": "struct Node * next ;"}
{"text": "Nod terbalik dalam kumpulan semasa", "code": "while ( count < K && count < len ) {"}
{"text": "Ke hadapan traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Kemas kini sebelum ini", "code": "prev = curr ;"}
{"text": "Kemas kini Curr", "code": "curr = next ;"}
{"text": "Kiraan kemas kini", "code": "count ++ ; }"}
{"text": "Putuskan sambungan nod sebelumnya dari nod seterusnya", "code": "prev -> nxp = XOR ( NULL , XOR ( prev -> nxp , curr ) ) ;"}
{"text": "Putuskan sambungan dari nod sebelumnya", "code": "if ( curr != NULL ) curr -> nxp = XOR ( XOR ( curr -> nxp , prev ) , NULL ) ;"}
{"text": "Sekiranya kiraan nod yang tinggal kurang daripada k", "code": "if ( len < K ) { return prev ; } else {"}
{"text": "Kemas kini Len", "code": "len -= K ;"}
{"text": "Memproses secara rekursif nod seterusnya", "code": "struct Node * dummy = RevInGrp ( & curr , K , len ) ;"}
{"text": "Sambungkan penunjuk kepala dengan sebelumnya", "code": "( * head ) -> nxp = XOR ( XOR ( NULL , ( * head ) -> nxp ) , dummy ) ;"}
{"text": "Sambung dengan kepala", "code": "if ( dummy != NULL ) dummy -> nxp = XOR ( XOR ( dummy -> nxp , NULL ) , * head ) ; return prev ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Buat Ketua Senarai Berkaitan XOR berikut -> 7 <A> 6 <A> 8 <A> 11 <A> 3 <A> 1 <A> 2 <A> 0", "code": "struct Node * head = NULL ; insert ( & head , 0 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; insert ( & head , 3 ) ; insert ( & head , 11 ) ; insert ( & head , 8 ) ; insert ( & head , 6 ) ; insert ( & head , 7 ) ;"}
{"text": "Panggilan fungsi", "code": "head = RevInGrp ( & head , 3 , 8 ) ;"}
{"text": "Cetak senarai terbalik", "code": "printList ( & head ) ; return ( 0 ) ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Struktur nod dalam senarai berkaitan XOR", "code": "struct Node {"}
{"text": "Menyimpan nilai data nod", "code": "int data ;"}
{"text": "Kedai xor penunjuk sebelumnya dan penunjuk seterusnya", "code": "struct Node * nxp ; } ;"}
{"text": "Berfungsi untuk mencari XOR dari dua nod", "code": "struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; }"}
{"text": "Berfungsi untuk memasukkan nod dengan nilai yang diberikan pada kedudukan permulaan", "code": "struct Node * insert ( struct Node * * head , int value ) {"}
{"text": "Sekiranya senarai yang dipautkan XOR kosong", "code": "if ( * head == NULL ) {"}
{"text": "Memulakan nod baru", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Menyimpan nilai data dalam nod", "code": "node -> data = value ;"}
{"text": "Kedai xor penunjuk sebelumnya dan seterusnya", "code": "node -> nxp = XOR ( NULL , NULL ) ;"}
{"text": "Kemas kini penunjuk nod kepala", "code": "* head = node ; }"}
{"text": "Sekiranya senarai yang dipautkan XOR tidak kosong", "code": "else {"}
{"text": "Menyimpan alamat nod semasa", "code": "struct Node * curr = * head ;"}
{"text": "Menyimpan alamat nod sebelumnya", "code": "struct Node * prev = NULL ;"}
{"text": "Memulakan nod baru", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Kemas kini alamat nod curr", "code": "curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ;"}
{"text": "Kemas kini alamat nod baru", "code": "node -> nxp = XOR ( NULL , curr ) ;"}
{"text": "Kemas kini kepala", "code": "* head = node ;"}
{"text": "Kemas kini nilai data nod semasa", "code": "node -> data = value ; } return * head ; }"}
{"text": "Berfungsi untuk mencetak elemen senarai yang dipautkan XOR", "code": "void printList ( struct Node * * head ) {"}
{"text": "Kedai penunjuk xor dalam nod semasa", "code": "struct Node * curr = * head ;"}
{"text": "Kedai penunjuk xor dalam nod sebelumnya", "code": "struct Node * prev = NULL ;"}
{"text": "Kedai penunjuk xor dalam nod seterusnya", "code": "struct Node * next ;"}
{"text": "Senarai Linked Traverse XOR", "code": "while ( curr != NULL ) {"}
{"text": "Cetak nod semasa", "code": "printf ( \" % d ▁ \" , curr -> data ) ;"}
{"text": "Ke hadapan traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Kemas kini sebelum ini", "code": "prev = curr ;"}
{"text": "Kemas kini Curr", "code": "curr = next ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Berfungsi untuk membalikkan senarai berkaitan XOR", "code": "struct Node * reverse ( struct Node * * head ) {"}
{"text": "Kedai penunjuk xor dalam nod semasa", "code": "struct Node * curr = * head ; if ( curr == NULL ) return NULL ; else {"}
{"text": "Kedai penunjuk xor dalam nod sebelumnya", "code": "struct Node * prev = NULL ;"}
{"text": "Kedai penunjuk xor dalam nod seterusnya", "code": "struct Node * next ; while ( XOR ( prev , curr -> nxp ) != NULL ) {"}
{"text": "Ke hadapan traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Kemas kini sebelum ini", "code": "prev = curr ;"}
{"text": "Kemas kini Curr", "code": "curr = next ; }"}
{"text": "Kemas kini penunjuk kepala", "code": "* head = curr ; return * head ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Buat Ketua Senarai Berkaitan XOR berikut -> 40 <--> 30 <--> 20 <--> 10", "code": "struct Node * head = NULL ; insert ( & head , 10 ) ; insert ( & head , 20 ) ; insert ( & head , 30 ) ; insert ( & head , 40 ) ;"}
{"text": "Balikkan senarai yang dipautkan XOR untuk memberi kepala -> 10 <--> 20 <--> 30 <--> 40", "code": "printf ( \" XOR ▁ linked ▁ list : ▁ \" ) ; printList ( & head ) ; reverse ( & head ) ; printf ( \" Reversed ▁ XOR ▁ linked ▁ list : ▁ \" ) ; printList ( & head ) ; return ( 0 ) ; }"}
{"text": "Program c untuk melaksanakan pendekatan di atas", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Struktur nod dalam senarai berkaitan XOR", "code": "struct Node {"}
{"text": "Menyimpan nilai data nod", "code": "int data ;"}
{"text": "Kedai xor penunjuk sebelumnya dan penunjuk seterusnya", "code": "struct Node * nxp ; } ;"}
{"text": "Berfungsi untuk mencari XOR dari dua nod", "code": "struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; }"}
{"text": "Berfungsi untuk memasukkan nod dengan nilai yang diberikan pada kedudukan yang diberikan", "code": "struct Node * insert ( struct Node * * head , int value ) {"}
{"text": "Sekiranya senarai yang dipautkan XOR kosong", "code": "if ( * head == NULL ) {"}
{"text": "Memulakan nod baru", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Menyimpan nilai data dalam nod", "code": "node -> data = value ;"}
{"text": "Kedai xor penunjuk sebelumnya dan seterusnya", "code": "node -> nxp = XOR ( NULL , NULL ) ;"}
{"text": "Kemas kini penunjuk nod kepala", "code": "* head = node ; }"}
{"text": "Sekiranya senarai yang dipautkan XOR tidak kosong", "code": "else {"}
{"text": "Menyimpan alamat nod semasa", "code": "struct Node * curr = * head ;"}
{"text": "Menyimpan alamat nod sebelumnya", "code": "struct Node * prev = NULL ;"}
{"text": "Memulakan nod baru", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Kemas kini alamat nod curr", "code": "curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ;"}
{"text": "Kemas kini alamat nod baru", "code": "node -> nxp = XOR ( NULL , curr ) ;"}
{"text": "Kemas kini kepala", "code": "* head = node ;"}
{"text": "Kemas kini nilai data nod semasa", "code": "node -> data = value ; } return * head ; }"}
{"text": "Berfungsi untuk mencetak elemen senarai yang dipautkan XOR", "code": "void printList ( struct Node * * head ) {"}
{"text": "Kedai penunjuk xor dalam nod semasa", "code": "struct Node * curr = * head ;"}
{"text": "Kedai penunjuk xor dalam nod sebelumnya", "code": "struct Node * prev = NULL ;"}
{"text": "Kedai penunjuk xor dalam nod seterusnya", "code": "struct Node * next ;"}
{"text": "Senarai Linked Traverse XOR", "code": "while ( curr != NULL ) {"}
{"text": "Cetak nod semasa", "code": "printf ( \" % d ▁ \" , curr -> data ) ;"}
{"text": "Ke hadapan traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Kemas kini sebelum ini", "code": "prev = curr ;"}
{"text": "Kemas kini Curr", "code": "curr = next ; } } struct Node * NthNode ( struct Node * * head , int N ) { int count = 0 ;"}
{"text": "Kedai penunjuk xor dalam nod semasa", "code": "struct Node * curr = * head ; struct Node * curr1 = * head ;"}
{"text": "Kedai penunjuk xor dalam nod sebelumnya", "code": "struct Node * prev = NULL ; struct Node * prev1 = NULL ;"}
{"text": "Kedai penunjuk xor dalam nod seterusnya", "code": "struct Node * next ; struct Node * next1 ; while ( count < N && curr != NULL ) {"}
{"text": "Ke hadapan traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Kemas kini sebelum ini", "code": "prev = curr ;"}
{"text": "Kemas kini Curr", "code": "curr = next ; count ++ ; } if ( curr == NULL && count < N ) { printf ( \" Wrong ▁ Input \" ) ; return ( uintptr_t ) 0 ; } else { while ( curr != NULL ) {"}
{"text": "Ke hadapan traversal", "code": "next = XOR ( prev , curr -> nxp ) ; next1 = XOR ( prev1 , curr1 -> nxp ) ;"}
{"text": "Kemas kini sebelum ini", "code": "prev = curr ; prev1 = curr1 ;"}
{"text": "Kemas kini Curr", "code": "curr = next ; curr1 = next1 ; } printf ( \" % d \" , curr1 -> data ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Buat kepala senarai terpaut XOR berikut -> 7 a> 6 a> 8 a> 11 a> 3 a> 1 a> 2 a> 0", "code": "struct Node * head = NULL ; insert ( & head , 0 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; insert ( & head , 3 ) ; insert ( & head , 11 ) ; insert ( & head , 8 ) ; insert ( & head , 6 ) ; insert ( & head , 7 ) ; NthNode ( & head , 3 ) ; return ( 0 ) ; }"}
{"text": "Program c untuk melaksanakan pendekatan di atas", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Struktur nod dalam senarai berkaitan XOR", "code": "struct Node {"}
{"text": "Menyimpan nilai data nod", "code": "int data ;"}
{"text": "Kedai xor penunjuk sebelumnya dan penunjuk seterusnya", "code": "struct Node * nxp ; } ;"}
{"text": "Berfungsi untuk mencari XOR dari dua nod", "code": "struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; }"}
{"text": "Berfungsi untuk memasukkan nod dengan nilai yang diberikan pada kedudukan yang diberikan", "code": "struct Node * insert ( struct Node * * head , int value ) {"}
{"text": "Sekiranya senarai yang dipautkan XOR kosong", "code": "if ( * head == NULL ) {"}
{"text": "Memulakan nod baru", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Menyimpan nilai data dalam nod", "code": "node -> data = value ;"}
{"text": "Kedai xor penunjuk sebelumnya dan seterusnya", "code": "node -> nxp = XOR ( NULL , NULL ) ;"}
{"text": "Kemas kini penunjuk nod kepala", "code": "* head = node ; }"}
{"text": "Sekiranya senarai yang dipautkan XOR tidak kosong", "code": "else {"}
{"text": "Menyimpan alamat nod semasa", "code": "struct Node * curr = * head ;"}
{"text": "Menyimpan alamat nod sebelumnya", "code": "struct Node * prev = NULL ;"}
{"text": "Memulakan nod baru", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Kemas kini alamat nod curr", "code": "curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ;"}
{"text": "Kemas kini alamat nod baru", "code": "node -> nxp = XOR ( NULL , curr ) ;"}
{"text": "Kemas kini kepala", "code": "* head = node ;"}
{"text": "Kemas kini nilai data nod semasa", "code": "node -> data = value ; } return * head ; }"}
{"text": "Berfungsi untuk mencetak nod tengah", "code": "int printMiddle ( struct Node * * head , int len ) { int count = 0 ;"}
{"text": "Kedai penunjuk xor dalam nod semasa", "code": "struct Node * curr = * head ;"}
{"text": "Kedai penunjuk xor dalam nod sebelumnya", "code": "struct Node * prev = NULL ;"}
{"text": "Kedai penunjuk xor dalam nod seterusnya", "code": "struct Node * next ; int middle = ( int ) len / 2 ;"}
{"text": "Senarai Linked Traverse XOR", "code": "while ( count != middle ) {"}
{"text": "Ke hadapan traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Kemas kini sebelum ini", "code": "prev = curr ;"}
{"text": "Kemas kini Curr", "code": "curr = next ; count ++ ; }"}
{"text": "Sekiranya panjang senarai yang dipautkan adalah ganjil", "code": "if ( len & 1 ) { printf ( \" % d \" , curr -> data ) ; }"}
{"text": "Sekiranya panjang senarai yang dipautkan", "code": "else { printf ( \" % d ▁ % d \" , prev -> data , curr -> data ) ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Buat Ketua Senarai Berkaitan XOR berikut -> 4 A> 7 A> 5", "code": "struct Node * head = NULL ; insert ( & head , 4 ) ; insert ( & head , 7 ) ; insert ( & head , 5 ) ; printMiddle ( & head , 3 ) ; return ( 0 ) ; }"}
{"text": "Program c ++ untuk melaksanakan pendekatan di atas", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Struktur nod dalam senarai berkaitan XOR", "code": "struct Node {"}
{"text": "Menyimpan nilai data nod", "code": "int data ;"}
{"text": "Kedai xor penunjuk sebelumnya dan penunjuk seterusnya", "code": "struct Node * nxp ; } ;"}
{"text": "Berfungsi untuk mencari XOR dari dua nod", "code": "struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; }"}
{"text": "Berfungsi untuk memasukkan nod dengan nilai yang diberikan pada kedudukan yang diberikan", "code": "struct Node * insert ( struct Node * * head , int value , int position ) {"}
{"text": "Sekiranya senarai yang dipautkan XOR kosong", "code": "if ( * head == NULL ) {"}
{"text": "Sekiranya kedudukan diberikan sama dengan 1", "code": "if ( position == 1 ) {"}
{"text": "Memulakan nod baru", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Menyimpan nilai data dalam nod", "code": "node -> data = value ;"}
{"text": "Kedai xor penunjuk sebelumnya dan seterusnya", "code": "node -> nxp = XOR ( NULL , NULL ) ;"}
{"text": "Kemas kini penunjuk nod kepala", "code": "* head = node ; }"}
{"text": "Sekiranya kedudukan yang diperlukan tidak dijumpai", "code": "else { printf ( \" Invalid ▁ Position STRNEWLINE \" ) ; } }"}
{"text": "Sekiranya senarai yang dipautkan XOR tidak kosong", "code": "else {"}
{"text": "Kedai kedudukan nod dalam senarai yang dipautkan XOR", "code": "int Pos = 1 ;"}
{"text": "Menyimpan alamat nod semasa", "code": "struct Node * curr = * head ;"}
{"text": "Menyimpan alamat nod sebelumnya", "code": "struct Node * prev = NULL ;"}
{"text": "Menyimpan xor nod seterusnya dan nod sebelumnya", "code": "struct Node * next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Melintasi senarai yang dipautkan XOR", "code": "while ( next != NULL && Pos < position - 1 ) {"}
{"text": "Kemas kini sebelum ini", "code": "prev = curr ;"}
{"text": "Kemas kini Curr", "code": "curr = next ;"}
{"text": "Kemas kini Seterusnya", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Kemas kini POS", "code": "Pos ++ ; }"}
{"text": "Sekiranya kedudukan nod semasa adalah sama dengan kedudukan yang diberikan", "code": "if ( Pos == position - 1 ) {"}
{"text": "Memulakan nod baru", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Kedai penunjuk ke nod sebelumnya sebagai (prev ^ next ^ next) = prever", "code": "struct Node * temp = XOR ( curr -> nxp , next ) ;"}
{"text": "Kedai xor prev dan nod baru", "code": "curr -> nxp = XOR ( temp , node ) ;"}
{"text": "Menghubungkan nod baru dengan seterusnya", "code": "if ( next != NULL ) {"}
{"text": "Kemas kini penunjuk seterusnya", "code": "next -> nxp = XOR ( node , XOR ( next -> nxp , curr ) ) ; }"}
{"text": "Sambungkan nod dengan curr dan curr seterusnya < - node -> Seterusnya", "code": "node -> nxp = XOR ( curr , next ) ; node -> data = value ; }"}
{"text": "Nod penyisipan pada permulaan", "code": "else if ( position == 1 ) {"}
{"text": "Memulakan nod baru", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Kemas kini alamat nod curr", "code": "curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ;"}
{"text": "Kemas kini alamat nod baru", "code": "node -> nxp = XOR ( NULL , curr ) ;"}
{"text": "Kemas kini kepala", "code": "* head = node ;"}
{"text": "Kemas kini nilai data nod semasa", "code": "node -> data = value ; } else { printf ( \" Invalid ▁ Position STRNEWLINE \" ) ; } } return * head ; }"}
{"text": "Berfungsi untuk mencetak elemen senarai yang dipautkan XOR", "code": "void printList ( struct Node * * head ) {"}
{"text": "Kedai penunjuk xor dalam nod semasa", "code": "struct Node * curr = * head ;"}
{"text": "Kedai penunjuk xor dalam nod sebelumnya", "code": "struct Node * prev = NULL ;"}
{"text": "Kedai penunjuk xor dalam nod seterusnya", "code": "struct Node * next ;"}
{"text": "Senarai Linked Traverse XOR", "code": "while ( curr != NULL ) {"}
{"text": "Cetak nod semasa", "code": "printf ( \" % d ▁ \" , curr -> data ) ;"}
{"text": "Ke hadapan traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Kemas kini sebelum ini", "code": "prev = curr ;"}
{"text": "Kemas kini Curr", "code": "curr = next ; } }"}
{"text": "Kod pemacu", "code": "int main ( ) {"}
{"text": "Buat Ketua Senarai Berkaitan XOR berikut -> 20 <--> 40 <--> 10 <--> 30", "code": "struct Node * head = NULL ; insert ( & head , 10 , 1 ) ; insert ( & head , 20 , 1 ) ; insert ( & head , 30 , 3 ) ; insert ( & head , 40 , 2 ) ;"}
{"text": "Cetak senarai baru", "code": "printList ( & head ) ; return ( 0 ) ; }"}
{"text": "Program c untuk bertukar -tukar k - bit nombor n", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk bertukar bit kth n", "code": "int toggleBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 5 , k = 2 ; printf ( \" % d STRNEWLINE \" , toggleBit ( n , k ) ) ; return 0 ; }"}
{"text": "Program c untuk membersihkan k - bit nombor n", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk membersihkan bit kth n", "code": "int clearBit ( int n , int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 5 , k = 1 ; printf ( \" % d STRNEWLINE \" , clearBit ( n , k ) ) ; return 0 ; }"}
{"text": "Program C ++ untuk menunjukkan penggunaan pengendali peralihan kanan", "code": "#include <stdio.h> NEW_LINE using namespace std ; int main ( ) {"}
{"text": "A = 5 (00000101), b = 9 (00001001)", "code": "unsigned char a = 5 , b = 9 ;"}
{"text": "Hasilnya ialah 00000010", "code": "printf ( \" a > > 1 ▁ = ▁ % d STRNEWLINE \" , a >> 1 ) ;"}
{"text": "Hasilnya ialah 00000100", "code": "printf ( \" b > > 1 ▁ = ▁ % d STRNEWLINE \" , b >> 1 ) ; return 0 ; }"}
{"text": "shift y oleh 61 bit kiri", "code": "printf ( \" y ▁ < < ▁ 61 ▁ = ▁ % lld STRNEWLINE \" , y << 61 ) ; return 0 ; }"}
{"text": "Program c untuk melakukan penambahan rekursif dua bilangan bulat", "code": "#include <stdio.h> NEW_LINE int add ( int x , int y ) { int keep = ( x & y ) << 1 ; int res = x ^ y ;"}
{"text": "Jika Bitwise & adalah 0, maka tidak akan ada apa -apa bawa. Oleh itu, hasil XOR adalah tambahan.", "code": "if ( keep == 0 ) return res ; add ( keep , res ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { printf ( \" % d \" , add ( 15 , 38 ) ) ; return 0 ; }"}
{"text": "Program c untuk mencari jumlah bit dalam nombor tertentu", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE unsigned countBits ( unsigned int number ) {"}
{"text": "Fungsi log di pangkalan 2 hanya mengambil bahagian integer", "code": "return ( int ) log2 ( number ) + 1 ; }"}
{"text": "Program yang didorong", "code": "int main ( ) { unsigned int num = 65 ; printf ( \" % d STRNEWLINE \" , countBits ( num ) ) ; return 0 ; }"}
{"text": "Program C yang cekap untuk mencari Palindrome N -", "code": "#include <stdio.h> NEW_LINE #define INT_SIZE  32"}
{"text": "Bina palindrome binari n dengan nombor kumpulan, aux_number dan jenis operasi", "code": "int constructNthNumber ( int group_no , int aux_num , int op ) { int a [ INT_SIZE ] = { 0 } ; int num = 0 , len_f ; int i = 0 ;"}
{"text": "Tidak perlu memasukkan bit di tengah", "code": "if ( op == 2 ) {"}
{"text": "Panjang perwakilan binari terakhir", "code": "len_f = 2 * group_no ;"}
{"text": "Isi bit pertama dan terakhir sebagai 1", "code": "a [ len_f - 1 ] = a [ 0 ] = 1 ;"}
{"text": "Mula mengisi A [] dari tengah, dengan perwakilan binari aux_num", "code": "while ( aux_num ) {"}
{"text": "Dapatkan bit nombor tambahan dan isi tengah", "code": "a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } }"}
{"text": "Masukkan bit 0 di tengah", "code": "else if ( op == 0 ) {"}
{"text": "Panjang perwakilan binari terakhir", "code": "len_f = 2 * group_no + 1 ;"}
{"text": "Isi bit pertama dan terakhir sebagai 1", "code": "a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ;"}
{"text": "Mula mengisi A [] dari tengah, dengan perwakilan binari aux_num", "code": "while ( aux_num ) {"}
{"text": "Dapatkan bit nombor tambahan dan isi tengah", "code": "a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } }"}
{"text": "lain masukkan bit 1 di tengah", "code": "{"}
{"text": "Panjang perwakilan binari terakhir", "code": "len_f = 2 * group_no + 1 ;"}
{"text": "Isi bit pertama dan terakhir sebagai 1", "code": "a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ;"}
{"text": "Mula mengisi A [] dari tengah, dengan perwakilan binari aux_num", "code": "while ( aux_num ) {"}
{"text": "Dapatkan bit nombor tambahan dan isi tengah", "code": "a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } }"}
{"text": "Tukar nombor ke perpuluhan dari binari", "code": "for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; }"}
{"text": "Akan mengembalikan nombor palindrome binari n", "code": "int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ;"}
{"text": "Tambahkan bilangan elemen dalam semua kumpulan, sehingga kumpulan nombor n dijumpai", "code": "while ( count_temp < n ) { group_no ++ ;"}
{"text": "Jumlah elemen sehingga kumpulan ini", "code": "count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; }"}
{"text": "Kedudukan mengimbangi elemen dalam kumpulan", "code": "group_offset = n - count_upto_group - 1 ;"}
{"text": "Mencari sedikit yang akan diletakkan di tengah dan mencari nombor, yang akan kami isi dari tengah ke kedua -dua arah", "code": "if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) {"}
{"text": "Kita perlu mengisi nombor tambahan ini dalam bentuk binari tengah di kedua -dua arah", "code": "aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 )"}
{"text": "op = 0; Perlu memasukkan 0 di tengah", "code": "else"}
{"text": "op = 1; Perlu memasukkan 1 di tengah", "code": "aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int n = 9 ;"}
{"text": "Panggilan fungsi", "code": "printf ( \" % d \" , getNthNumber ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk bertukar semua bit kecuali kth bit", "code": "#include <stdio.h>"}
{"text": "Mengembalikan nombor dengan semua bit bertukar dalam n kecuali k - th bit", "code": "unsigned int toggleAllExceptK ( unsigned int n , unsigned int k ) {"}
{"text": "1) togol k - th bit dengan melakukan n ^ (1 << k) 2) togol semua bit nombor yang diubah suai", "code": "return ~ ( n ^ ( 1 << k ) ) ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { unsigned int n = 4294967295 ; unsigned int k = 0 ; printf ( \" % u \" , toggleAllExceptK ( n , k ) ) ; return 0 ; }"}
{"text": "Program c untuk menunjukkan kerja pengendali relasi", "code": "#include <stdio.h> NEW_LINE int main ( ) { int a = 10 , b = 4 ;"}
{"text": "lebih besar daripada contoh", "code": "if ( a > b ) printf ( \" a ▁ is ▁ greater ▁ than ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ less ▁ than ▁ or ▁ equal ▁ to ▁ b STRNEWLINE \" ) ;"}
{"text": "lebih besar daripada sama dengan", "code": "if ( a >= b ) printf ( \" a ▁ is ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ lesser ▁ than ▁ b STRNEWLINE \" ) ;"}
{"text": "kurang daripada contoh", "code": "if ( a < b ) printf ( \" a ▁ is ▁ less ▁ than ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ b STRNEWLINE \" ) ;"}
{"text": "lebih rendah daripada sama dengan", "code": "if ( a <= b ) printf ( \" a ▁ is ▁ lesser ▁ than ▁ or ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ greater ▁ than ▁ b STRNEWLINE \" ) ;"}
{"text": "sama dengan", "code": "if ( a == b ) printf ( \" a ▁ is ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ and ▁ b ▁ are ▁ not ▁ equal STRNEWLINE \" ) ;"}
{"text": "tidak sama dengan", "code": "if ( a != b ) printf ( \" a ▁ is ▁ not ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ equal ▁ b STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Program c untuk menunjukkan kerja pengendali logik", "code": "#include <stdio.h> NEW_LINE int main ( ) { int a = 10 , b = 4 , c = 10 , d = 20 ;"}
{"text": "logik dan contoh", "code": "if ( a > b && c == d ) printf ( \" a ▁ is ▁ greater ▁ than ▁ b ▁ AND ▁ c ▁ is ▁ equal ▁ to ▁ d STRNEWLINE \" ) ; else printf ( \" AND ▁ condition ▁ not ▁ satisfied STRNEWLINE \" ) ;"}
{"text": "logik atau contoh", "code": "if ( a > b c == d ) printf ( \" a ▁ is ▁ greater ▁ than ▁ b ▁ OR ▁ c ▁ is ▁ equal ▁ to ▁ d STRNEWLINE \" ) ; else printf ( \" Neither ▁ a ▁ is ▁ greater ▁ than ▁ b ▁ nor ▁ c ▁ is ▁ equal ▁ \" \" ▁ to ▁ d STRNEWLINE \" ) ;"}
{"text": "Logik tidak contoh", "code": "if ( ! a ) printf ( \" a ▁ is ▁ zero STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ not ▁ zero \" ) ; return 0 ; }"}
{"text": "Program C untuk menukar bit dalam integer", "code": "#include <stdio.h>"}
{"text": "Fungsi ini bertukar sedikit pada kedudukan P1 dan P2 dalam integer n", "code": "int swapBits ( unsigned int n , unsigned int p1 , unsigned int p2 ) {"}
{"text": "Gerakkan p1 'th ke sebelah kanan", "code": "unsigned int bit1 = ( n >> p1 ) & 1 ;"}
{"text": "Gerakkan p2 'th ke sebelah kanan", "code": "unsigned int bit2 = ( n >> p2 ) & 1 ;"}
{"text": "Xor dua bit", "code": "unsigned int x = ( bit1 ^ bit2 ) ;"}
{"text": "Letakkan sedikit XOR kembali ke kedudukan asal mereka", "code": "x = ( x << p1 ) | ( x << p2 ) ;"}
{"text": "Xor 'x' dengan nombor asal supaya kedua -dua set itu ditukar", "code": "unsigned int result = n ^ x ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int res = swapBits ( 28 , 0 , 3 ) ; printf ( \" Result ▁ = ▁ % d ▁ \" , res ) ; return 0 ; }"}
{"text": "Berfungsi untuk mengembalikan satu -satunya elemen yang ganjil", "code": "int findOdd ( int arr [ ] , int n ) { int res = 0 , i ; for ( i = 0 ; i < n ; i ++ ) res ^= arr [ i ] ; return res ; }"}
{"text": "Kaedah Pemandu", "code": "int main ( void ) { int arr [ ] = { 12 , 12 , 14 , 90 , 14 , 14 , 14 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ odd ▁ occurring ▁ element ▁ is ▁ % d ▁ \" , findOdd ( arr , n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Simpan bit input", "code": "int input [ 32 ] ;"}
{"text": "Simpan kod Hamming", "code": "int code [ 32 ] ; int ham_calc ( int , int ) ; void solve ( int input [ ] , int ) ;"}
{"text": "Berfungsi untuk mengira bit untuk kedudukan ith", "code": "int ham_calc ( int position , int c_l ) { int count = 0 , i , j ; i = position - 1 ;"}
{"text": "Melintasi menyimpan kod hamming", "code": "while ( i < c_l ) { for ( j = i ; j < i + position ; j ++ ) {"}
{"text": "Sekiranya boit semasa adalah 1", "code": "if ( code [ j ] == 1 ) count ++ ; }"}
{"text": "Kemas kini i", "code": "i = i + 2 * position ; } if ( count % 2 == 0 ) return 0 ; else return 1 ; }"}
{"text": "Berfungsi untuk mengira kod Hamming", "code": "void solve ( int input [ ] , int n ) { int i , p_n = 0 , c_l , j , k ; i = 0 ;"}
{"text": "Cari bit msg yang telah ditetapkan bit pada kedudukan nombor x 'th", "code": "while ( n > ( int ) pow ( 2 , i ) - ( i + 1 ) ) { p_n ++ ; i ++ ; } c_l = p_n + n ; j = k = 0 ;"}
{"text": "Melintasi msgbits", "code": "for ( i = 0 ; i < c_l ; i ++ ) {"}
{"text": "Kemas kini kod", "code": "if ( i == ( ( int ) pow ( 2 , k ) - 1 ) ) { code [ i ] = 0 ; k ++ ; }"}
{"text": "Kemas kini kod [i] ke aksara input di indeks j", "code": "else { code [ i ] = input [ j ] ; j ++ ; } }"}
{"text": "Melintasi dan mengemas kini kod Hamming", "code": "for ( i = 0 ; i < p_n ; i ++ ) {"}
{"text": "Cari kedudukan semasa", "code": "int position = ( int ) pow ( 2 , i ) ;"}
{"text": "Cari nilai pada kedudukan semasa", "code": "int value = ham_calc ( position , c_l ) ;"}
{"text": "Kemas kini kod", "code": "code [ position - 1 ] = value ; }"}
{"text": "Cetak kod Hamming", "code": "printf ( \" The generated Code Word is : \" for ( i = 0 ; i < c_l ; i ++ ) { printf ( \" % d \" , code [ i ] ) ; } }"}
{"text": "Kod pemacu", "code": "void main ( ) {"}
{"text": "Diberi sedikit mesej input", "code": "input [ 0 ] = 0 ; input [ 1 ] = 1 ; input [ 2 ] = 1 ; input [ 3 ] = 1 ; int N = 4 ;"}
{"text": "Panggilan fungsi", "code": "solve ( input , N ) ; }"}
{"text": "Program CPP untuk mencari watak pertama bukan berulang menggunakan array 1D dan satu traversal.", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <math.h> NEW_LINE #define NO_OF_CHARS  256"}
{"text": "Fungsi mengembalikan indeks watak bukan berulang yang pertama dalam rentetan. Sekiranya semua watak mengulangi maka kembali int_max", "code": "int firstNonRepeating ( char * str ) {"}
{"text": "Memulakan semua aksara sebagai tidak hadir.", "code": "int arr [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = -1 ;"}
{"text": "Selepas di bawah gelung, nilai ARR [x] akan menjadi indeks x jika x muncul hanya sekali. Lain nilai akan sama ada - 1 atau - 2.", "code": "for ( int i = 0 ; str [ i ] ; i ++ ) { if ( arr [ str [ i ] ] == -1 ) arr [ str [ i ] ] = i ; else arr [ str [ i ] ] = -2 ; } int res = INT_MAX ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ )"}
{"text": "Sekiranya watak ini berlaku sekali sahaja dan muncul sebelum hasil semasa, maka kemas kini hasilnya", "code": "if ( arr [ i ] >= 0 ) res = min ( res , arr [ i ] ) ; return res ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { char str [ ] = \" geeksforgeeks \" ; int index = firstNonRepeating ( str ) ; if ( index == INT_MAX ) printf ( \" Either ▁ all ▁ characters ▁ are ▁ \" \" repeating ▁ or ▁ string ▁ is ▁ empty \" ) ; else printf ( \" First ▁ non - repeating ▁ character \" \" ▁ is ▁ % c \" , str [ index ] ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari nombor triacontagonal n", "code": "int triacontagonalNum ( int n ) { return ( 28 * n * n - 26 * n ) / 2 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ triacontagonal ▁ Number ▁ is ▁ = ▁ % d \" , triacontagonalNum ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari nombor hexacontagon nth", "code": "int hexacontagonNum ( int n ) { return ( 58 * n * n - 56 * n ) / 2 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ hexacontagon ▁ Number ▁ is ▁ = ▁ % d \" , hexacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari nombor enneacontagon nth", "code": "int enneacontagonNum ( int n ) { return ( 88 * n * n - 86 * n ) / 2 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ enneacontagon ▁ Number ▁ is ▁ = ▁ % d \" , enneacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari nombor triacontakaidigon n", "code": "int triacontakaidigonNum ( int n ) { return ( 30 * n * n - 28 * n ) / 2 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ triacontakaidigon ▁ Number ▁ is ▁ = ▁ % d \" , triacontakaidigonNum ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari nombor icosihexagonal nth", "code": "int IcosihexagonalNum ( int n ) { return ( 24 * n * n - 22 * n ) / 2 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ Icosihexagonal ▁ Number ▁ is ▁ = ▁ % d \" , IcosihexagonalNum ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari nombor icosikaioctagonal nth", "code": "int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ icosikaioctagonal ▁ Number ▁ is ▁ = ▁ % d \" , icosikaioctagonalNum ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari nombor octacontagon nth", "code": "int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ octacontagon ▁ Number ▁ is ▁ = ▁ % d \" , octacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari nombor hektagon nth", "code": "int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ hectagon ▁ Number ▁ is ▁ = ▁ % d \" , hectagonNum ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Mencari nombor tetracontagon nth", "code": "int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ tetracontagon ▁ Number ▁ is ▁ = ▁ % d \" , tetracontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Program c untuk pendekatan di atas", "code": "#include <stdio.h>"}
{"text": "Berfungsi untuk mencari jika elemen x hadir dalam pelbagai disusun terbalik", "code": "int binarySearch ( int arr [ ] , int N , int X ) {"}
{"text": "Simpan indeks pertama subarray di mana x terletak", "code": "int start = 0 ;"}
{"text": "Simpan indeks terakhir subarray di mana x terletak", "code": "int end = N ; while ( start <= end ) {"}
{"text": "Simpan indeks tengah subarray", "code": "int mid = start + ( end - start ) / 2 ;"}
{"text": "Periksa sama ada nilai di indeks tengah subarray sama dengan x", "code": "if ( X == arr [ mid ] ) {"}
{"text": "Elemen dijumpai", "code": "return mid ; }"}
{"text": "Sekiranya x lebih kecil daripada nilai pada indeks pertengahan subarray", "code": "else if ( X < arr [ mid ] ) {"}
{"text": "Cari di separuh kanan subarray", "code": "start = mid + 1 ; } else {"}
{"text": "Cari di separuh kiri subarray", "code": "end = mid - 1 ; } }"}
{"text": "Sekiranya x tidak dijumpai", "code": "return -1 ; }"}
{"text": "Kod pemacu", "code": "int main ( ) { int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 4 ; int res = binarySearch ( arr , N , X ) ; printf ( \" ▁ % d ▁ \" , res ) ; return 0 ; }"}
{"text": "Program c untuk menyusun array menggunakan jenis pancake", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Membalikkan ARR [0 .. saya]", "code": "void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } }"}
{"text": "Mengembalikan indeks elemen maksimum dalam ARR [0 .. n - 1]", "code": "int findMax ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; }"}
{"text": "Fungsi utama yang disusun dengan pelbagai menggunakan operasi Flip", "code": "void pancakeSort ( int * arr , int n ) {"}
{"text": "Mulakan dari array lengkap dan satu demi satu mengurangkan saiz semasa dengan satu", "code": "for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) {"}
{"text": "Cari indeks elemen maksimum dalam ARR [0 .. curr_size - 1]", "code": "int mi = findMax ( arr , curr_size ) ;"}
{"text": "Gerakkan elemen maksimum ke hujung array semasa jika ia belum selesai", "code": "if ( mi != curr_size - 1 ) {"}
{"text": "Untuk bergerak pada akhirnya, gerakkan nombor maksimum pertama ke permulaan", "code": "flip ( arr , mi ) ;"}
{"text": "Sekarang gerakkan nombor maksimum hingga berakhir dengan membalikkan array semasa", "code": "flip ( arr , curr_size - 1 ) ; } } }"}
{"text": "Fungsi utiliti untuk mencetak saiz n saiz n", "code": "void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Program pemacu untuk menguji fungsi di atas", "code": "int main ( ) { int arr [ ] = { 23 , 10 , 20 , 11 , 12 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pancakeSort ( arr , n ) ; puts ( \" Sorted ▁ Array ▁ \" ) ; printArray ( arr , n ) ; return 0 ; }"}
