{"text": "Bilangan minimum syiling yang mempunyai nilai sama dengan kuasa 2 yang diperlukan untuk mendapatkan n | Program C untuk pendekatan di atas; Fungsi untuk mengira bit set dalam n; Kedai kiraan bit set dalam n; Melangkah ke atas julat [0, 31]; Jika bit semasa ditetapkan; Hasil kemas kini; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void count_setbit ( int N ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( 1 << i ) & N ) { result ++ ; } } printf ( \" % d STRNEWLINE \" , result ) ; } int main ( ) { int N = 43 ; count_setbit ( N ) ; return 0 ; }"}
{"text": "Trik Logaritma untuk Pengaturcaraan Kompetitif | C pelaksanaan untuk memeriksa bahawa integer adalah kuasa dua; Fungsi untuk memeriksa sama ada nombor itu adalah kuasa dua; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE _Bool isPowerOfTwo ( int n ) { return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } int main ( ) { int N = 8 ; if ( isPowerOfTwo ( N ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } }"}
{"text": "Perwakilan Ternary Set Cantor | C pelaksanaan untuk mencari cantor ditetapkan untuk tahap n dan untuk start_num dan end_num yang diberikan; Struktur senarai yang dipautkan untuk set cantor; Berfungsi untuk memulakan senarai set Cantor; Berfungsi untuk mengemukakan senarai dengan menambah nod baru untuk tahap seterusnya; Mengubah nilai permulaan dan akhir untuk tahap seterusnya; Menukar petunjuk ke nod seterusnya; Recursif memanggil fungsi untuk menjana set cantor untuk keseluruhan tahap; Berfungsi untuk mencetak tahap set; Berfungsi untuk membina dan memaparkan set cantor untuk setiap peringkat; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE typedef struct cantor { double start , end ; struct cantor * next ; } Cantor ; Cantor * startList ( Cantor * head , double start_num , double end_num ) { if ( head == NULL ) { head = ( Cantor * ) malloc ( sizeof ( Cantor ) ) ; head -> start = start_num ; head -> end = end_num ; head -> next = NULL ; } return head ; } Cantor * propagate ( Cantor * head ) { Cantor * temp = head ; if ( temp != NULL ) { Cantor * newNode = ( Cantor * ) malloc ( sizeof ( Cantor ) ) ; double diff = ( ( ( temp -> end ) - ( temp -> start ) ) / 3 ) ; newNode -> end = temp -> end ; temp -> end = ( ( temp -> start ) + diff ) ; newNode -> start = ( newNode -> end ) - diff ; newNode -> next = temp -> next ; temp -> next = newNode ; propagate ( temp -> next -> next ) ; } return head ; } void print ( Cantor * temp ) { while ( temp != NULL ) { printf ( \" [ % lf ] ▁ - - ▁ [ % lf ] TABSYMBOL \" , temp -> start , temp -> end ) ; temp = temp -> next ; } printf ( \" STRNEWLINE \" ) ; } void buildCantorSet ( int A , int B , int L ) { Cantor * head = NULL ; head = startList ( head , A , B ) ; for ( int i = 0 ; i < L ; i ++ ) { printf ( \" Level _ % d ▁ : ▁ \" , i ) ; print ( head ) ; propagate ( head ) ; } printf ( \" Level _ % d ▁ : ▁ \" , L ) ; print ( head ) ; } int main ( ) { int A = 0 ; int B = 9 ; int L = 2 ; buildCantorSet ( A , B , L ) ; return 0 ; }"}
{"text": "Algoritma naif yang dioptimumkan untuk mencari corak | Program C untuk algoritma mencari corak naif yang diubahsuai yang dioptimumkan untuk kes -kes apabila semua watak corak adalah berbeza; Algoritma corak corak naif yang diubahsuai yang dioptimumkan untuk kes -kes apabila semua aksara corak adalah berbeza; Untuk indeks semasa I, periksa perlawanan corak; jika (j == m) Jika pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]; Luncurkan corak oleh J; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void search ( char pat [ ] , char txt [ ] ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; { printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } int main ( ) { char txt [ ] = \" ABCEABCDABCEABCD \" ; char pat [ ] = \" ABCD \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Program untuk menyulitkan rentetan menggunakan! dan @ | Program C untuk menyulitkan rentetan menggunakan! dan @; Berfungsi untuk menyulitkan rentetan; EvenPOS adalah untuk menyimpan enkripsi char pada oddpos evenposition adalah untuk menyimpan enkripsi char pada oddposition; Dapatkan bilangan kali watak itu akan diulang; Jika saya ganjil, cetak '! 'lain cetak' @ '; Kod pemacu; Menyulitkan rentetan", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void encrypt ( char input [ 100 ] ) { char evenPos = ' @ ' , oddPos = ' ! ' ; int repeat , ascii ; for ( int i = 0 ; i <= strlen ( input ) ; i ++ ) { ascii = input [ i ] ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( int j = 0 ; j < repeat ; j ++ ) { if ( i % 2 == 0 ) printf ( \" % c \" , oddPos ) ; else printf ( \" % c \" , evenPos ) ; } } } void main ( ) { char input [ 100 ] = { ' A ' , ' b ' , ' C ' , ' d ' } ; encrypt ( input ) ; }"}
{"text": "Fungsi rekursif untuk memeriksa sama ada rentetan adalah palindrome | Program C Rekursif untuk memeriksa sama ada nombor tertentu adalah palindrome atau tidak; Fungsi rekursif yang memeriksa str [s. . e] adalah palindrome atau tidak. ; Jika hanya ada satu watak; Jika watak pertama dan terakhir tidak sepadan; Sekiranya terdapat lebih daripada dua aksara, periksa sama ada substring tengah juga palindrome atau tidak. ; Rentetan kosong dianggap sebagai palindrome; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #include <stdbool.h> NEW_LINE bool isPalRec ( char str [ ] , int s , int e ) { if ( s == e ) return true ; if ( str [ s ] != str [ e ] ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; } bool isPalindrome ( char str [ ] ) { int n = strlen ( str ) ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; } int main ( ) { char str [ ] = \" geeg \" ; if ( isPalindrome ( str ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Tulis Atoi anda sendiri () | Program C ++ mudah untuk pelaksanaan ATOI; Jika ruang putih maka abaikan. ; tanda nombor; Memeriksa input yang sah; mengendalikan kes ujian limpahan; Kod pemacu; Kod fungsional", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int myAtoi ( const char * str ) { int sign = 1 , base = 0 , i = 0 ; while ( str [ i ] == ' ▁ ' ) { i ++ ; } if ( str [ i ] == ' - ' str [ i ] == ' + ' ) { sign = 1 - 2 * ( str [ i ++ ] == ' - ' ) ; } while ( str [ i ] >= '0' && str [ i ] <= '9' ) { if ( base > INT_MAX / 10 || ( base == INT_MAX / 10 && str [ i ] - '0' > 7 ) ) { if ( sign == 1 ) return INT_MAX ; else return INT_MIN ; } base = 10 * base + ( str [ i ++ ] - '0' ) ; } return base * sign ; } int main ( ) { char str [ ] = \" ▁ - 123\" ; int val = myAtoi ( str ) ; printf ( \" % d ▁ \" , val ) ; return 0 ; }"}
{"text": "Isi dua contoh semua nombor dari 1 hingga n dengan cara tertentu | Program C berasaskan backtracking untuk mengisi dua contoh semua nombor dari 1 hingga n dengan cara tertentu; Fungsi utiliti rekursif untuk mengisi dua contoh nombor dari 1 hingga n dalam res [0 .2 n - 1]. 'curr' adalah nilai semasa n. ; Jika nombor semasa menjadi 0, maka semua nombor diisi; Cuba letakkan dua contoh 'curr' di semua lokasi yang mungkin sehingga penyelesaian dijumpai; Dua 'curr' harus diletakkan pada jarak 'curr + 1'; Plave dua contoh 'curr'; Berulang untuk memeriksa sama ada penempatan di atas membawa kepada penyelesaian; Jika penyelesaian tidak mungkin, maka mundur; Fungsi ini mencetak hasil untuk nombor input 'n' menggunakan fillUtil (); Buat pelbagai saiz 2 n dan mulakan semua elemen di dalamnya sebagai 0; Jika penyelesaian mungkin, kemudian cetaknya. ; Program Pemandu", "code": "#include <stdio.h> NEW_LINE #include <stdbool.h> NEW_LINE bool fillUtil ( int res [ ] , int curr , int n ) { if ( curr == 0 ) return true ; int i ; for ( i = 0 ; i < 2 * n - curr - 1 ; i ++ ) { if ( res [ i ] == 0 && res [ i + curr + 1 ] == 0 ) { res [ i ] = res [ i + curr + 1 ] = curr ; if ( fillUtil ( res , curr - 1 , n ) ) return true ; res [ i ] = res [ i + curr + 1 ] = 0 ; } } return false ; } void fill ( int n ) { int res [ 2 * n ] , i ; for ( i = 0 ; i < 2 * n ; i ++ ) res [ i ] = 0 ; if ( fillUtil ( res , n , n ) ) { for ( i = 0 ; i < 2 * n ; i ++ ) printf ( \" % d ▁ \" , res [ i ] ) ; } else puts ( \" Not ▁ Possible \" ) ; } int main ( ) { fill ( 7 ) ; return 0 ; }"}
{"text": "Semak jika n mengandungi semua digit sebagai k dalam asas b | C pelaksanaan pendekatan; Berfungsi untuk mencetak bilangan digit; Kirakan log menggunakan harta perubahan asas dan kemudian ambil lantai dan kemudian tambah 1; Mengembalikan output; Fungsi yang kembali benar jika n mengandungi semua satu dalam asas B; Kirakan jumlahnya; Kod pemacu; Diberi nombor n; Diberi asas B; Diberikan digit k; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE int findNumberOfDigits ( int n , int base ) { int dig = ( floor ( log ( n ) / log ( base ) ) + 1 ) ; return ( dig ) ; } int isAllKs ( int n , int b , int k ) { int len = findNumberOfDigits ( n , b ) ; int sum = k * ( 1 - pow ( b , len ) ) / ( 1 - b ) ; if ( sum == n ) { return ( sum ) ; } } int main ( void ) { int N = 13 ; int B = 3 ; int K = 1 ; if ( isAllKs ( N , B , K ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } return 0 ; }"}
{"text": "Program untuk mengira perimeter decagon | Program C untuk mengira perimeter decagon; Fungsi untuk mencari perimeter; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void CalPeri ( ) { int s = 5 , Perimeter ; Perimeter = 10 * s ; printf ( \" The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ % d \" , Perimeter ) ; } int main ( ) { CalPeri ( ) ; return 0 ; }"}
{"text": "Sudut antara dua pesawat dalam 3D | Program C untuk mencari sudut antara dua pesawat dalam 3 d. ; Berfungsi untuk mencari sudut; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = 3.14159 ; float A = ( 180 / pi ) * ( acos ( d ) ) ; printf ( \" Angle ▁ is ▁ % .2f ▁ degree \" , A ) ; } int main ( ) { float a1 = 1 ; float b1 = 1 ; float c1 = 2 ; float d1 = 1 ; float a2 = 2 ; float b2 = -1 ; float c2 = 1 ; float d2 = -4 ; distance ( a1 , b1 , c1 , a2 , b2 , c2 ) ; return 0 ; }"}
{"text": "Cermin titik melalui pesawat 3 d | Program C untuk mencari cermin titik melalui satah 3 d; Berfungsi untuk mencerminkan imej; Kod pemacu; panggilan fungsi", "code": "#include <stdio.h> NEW_LINE void mirror_point ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; printf ( \" x3 ▁ = ▁ % .1f ▁ \" , x3 ) ; printf ( \" y3 ▁ = ▁ % .1f ▁ \" , y3 ) ; printf ( \" z3 ▁ = ▁ % .1f ▁ \" , z3 ) ; } int main ( ) { float a = 1 ; float b = -2 ; float c = 0 ; float d = 0 ; float x1 = -1 ; float y1 = 3 ; float z1 = 4 ; mirror_point ( a , b , c , d , x1 , y1 , z1 ) ; }"}
{"text": "Tukar pokok binari supaya setiap nod menyimpan jumlah semua nod di subtree kiri | Program C untuk menyimpan jumlah nod di subtree kiri dalam setiap nod; Nod pokok; Berfungsi untuk mengubahsuai pokok binari supaya setiap nod menyimpan jumlah nilai di kalangan anaknya termasuk nilai sendiri; Kes asas; Mengemas kini subtrees kiri dan kanan; Masukkan leftsum ke nod semasa; Mengembalikan jumlah nilai di bawah akar; Fungsi utiliti untuk melakukan traversal inorder; Fungsi utiliti untuk membuat nod baru; Program pemacu; Mari kita bina di bawah pokok 1 / \\ 2 3 / \\ 4 5 6", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; int updatetree ( node * root ) { if ( ! root ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return root -> data ; int leftsum = updatetree ( root -> left ) ; int rightsum = updatetree ( root -> right ) ; root -> data += leftsum ; return root -> data + rightsum ; } void inorder ( struct node * node ) { if ( node == NULL ) return ; inorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; inorder ( node -> right ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; updatetree ( root ) ; cout << \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ is ▁ STRNEWLINE \" ; inorder ( root ) ; return 0 ; }"}
{"text": "Masalah Saham Saham | Program C untuk kaedah kekerasan untuk mengira nilai rentang stok; Mengisi array s [] dengan nilai span; Nilai span hari pertama sentiasa 1; Hitung nilai span hari yang tinggal dengan memeriksa secara linear hari sebelumnya; Memulakan nilai span; Traverse kiri manakala elemen seterusnya di sebelah kiri adalah lebih kecil daripada harga [i]; Fungsi utiliti untuk mencetak elemen array; Program pemacu untuk menguji fungsi di atas; Isi nilai span dalam array s []; Cetak nilai rentang yang dikira", "code": "#include <stdio.h> NEW_LINE void calculateSpan ( int price [ ] , int n , int S [ ] ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; } int main ( ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int S [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S , n ) ; return 0 ; }"}
{"text": "Elemen yang lebih besar seterusnya | Program C Mudah untuk mencetak elemen yang lebih besar seterusnya dalam array yang diberikan; Cetak elemen dan pasangan NGE untuk semua elemen arr [] saiz n; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } printf ( \" % d ▁ - - ▁ % dn \" , arr [ i ] , next ) ; } } int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNGE ( arr , n ) ; return 0 ; }"}
{"text": "Tukar pokok binari ke dalam pokok cerminnya | C program untuk menukar pokok binari ke cerminnya; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Tukar pokok supaya peranan penunjuk kiri dan kanan ditukar pada setiap nod. Jadi pokok ... 4 / \\ 2 5 / \\ 1 3 ditukar kepada ... 4 / \\ 5 2 / \\ 3 1; melakukan subtrees; Tukar petunjuk dalam nod ini; Fungsi penolong untuk mencetak traversal inorder. ; Program pemandu untuk menguji cermin (); Cetak inorder traversal pokok input; Menukar pokok ke cerminnya; Cetak inorder traversal pokok cermin", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void mirror ( struct Node * node ) { if ( node == NULL ) return ; else { struct Node * temp ; mirror ( node -> left ) ; mirror ( node -> right ) ; temp = node -> left ; node -> left = node -> right ; node -> right = temp ; } } void inOrder ( struct Node * node ) { if ( node == NULL ) return ; inOrder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; inOrder ( node -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ constructed \" \" ▁ tree ▁ is ▁ STRNEWLINE \" ) ; inOrder ( root ) ; mirror ( root ) ; printf ( \" Inorder traversal of the mirror tree \" ▁ \" is \" inOrder ( root ) ; return 0 ; }"}
{"text": "Pokok binari yang boleh dilipat |  ; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi utiliti yang memeriksa jika pokok dengan akar sebagai N1 dan N2 adalah cermin antara satu sama lain; Pulangan benar jika pokok yang diberikan boleh dilipat; Fungsi utiliti yang memeriksa jika pokok dengan akar sebagai N1 dan N2 adalah cermin antara satu sama lain; Jika kedua -dua subtrees kiri dan kanan adalah batal, maka kembali benar; Jika salah satu pokok adalah batal dan yang lain tidak, maka kembali palsu; Jika tidak, periksa jika subtrees kiri dan kanan adalah cermin rakan -rakan mereka; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Program pemandu untuk menguji cermin (); Pokok binari yang dibina ialah 1 / \\ 2 3 \\ / 4 5", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define bool  int NEW_LINE #define true  1 NEW_LINE #define false  0 NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; bool IsFoldableUtil ( struct node * n1 , struct node * n2 ) ; bool IsFoldable ( struct node * root ) { if ( root == NULL ) { return true ; } return IsFoldableUtil ( root -> left , root -> right ) ; } bool IsFoldableUtil ( struct node * n1 , struct node * n2 ) { if ( n1 == NULL && n2 == NULL ) { return true ; } if ( n1 == NULL n2 == NULL ) { return false ; } return IsFoldableUtil ( n1 -> left , n2 -> right ) && IsFoldableUtil ( n1 -> right , n2 -> left ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( void ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; if ( IsFoldable ( root ) == true ) { printf ( \" tree is foldable \" } else { printf ( \" tree is not foldable \" } getchar ( ) ; return 0 ; }"}
{"text": "Semak harta benda kanak -kanak di pokok binari | Program untuk memeriksa harta benda kanak -kanak; Node pokok binari mempunyai data, anak kiri dan anak kanan; mengembalikan 1 jika kanak -kanak jumlah harta memegang nod yang diberikan dan kedua -dua anaknya; left_data adalah data kanak -kanak yang tersisa dan kanan_data adalah untuk data kanak -kanak yang betul; Jika nod adalah batal atau ia adalah nod daun maka kembali benar; Jika anak kiri tidak hadir maka 0 digunakan sebagai data anak kiri; Jika anak yang betul tidak hadir maka 0 digunakan sebagai data anak yang betul; jika nod dan kedua -dua anaknya memenuhi harta pulangan 1 lain 0; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int isSumProperty ( struct node * node ) { int left_data = 0 , right_data = 0 ; if ( node == NULL || ( node -> left == NULL && node -> right == NULL ) ) return 1 ; else { if ( node -> left != NULL ) left_data = node -> left -> data ; if ( node -> right != NULL ) right_data = node -> right -> data ; if ( ( node -> data == left_data + right_data ) && isSumProperty ( node -> left ) && isSumProperty ( node -> right ) ) return 1 ; else return 0 ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 10 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 2 ) ; if ( isSumProperty ( root ) ) printf ( \" The ▁ given ▁ tree ▁ satisfies ▁ the ▁ children ▁ sum ▁ property ▁ \" ) ; else printf ( \" The ▁ given ▁ tree ▁ does ▁ not ▁ satisfy ▁ the ▁ children ▁ sum ▁ property ▁ \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program untuk mencari HCF (faktor umum tertinggi) daripada 2 nombor | C program untuk mencari GCD dua nombor; Fungsi rekursif untuk mengembalikan GCD A dan B; Semuanya membahagikan 0; Kes asas; A lebih besar; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } int main ( ) { int a = 0 , b = 56 ; printf ( \" GCD ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "Masalah Josephus Menggunakan Bit Magic | Program C untuk masalah Josephus; fungsi untuk mencari kedudukan bit yang paling penting; menyimpan bit beralih ke kanan sehingga kita ditinggalkan dengan 0; berfungsi untuk kembali ke tempat Josephus harus duduk untuk mengelakkan dibunuh; Mendapatkan kedudukan Bit Paling Penting (MSB). Yang paling kiri '1'. Jika nombor itu '41' maka binari adalah '101001'. Jadi MSBPOS (41) = 6; 'J' menyimpan nombor yang mana untuk xor nombor 'n'. Oleh kerana kita memerlukan '100000' kita akan melakukan 1 << 6 - 1 untuk mendapatkan '100000'; Mengubah sedikit yang paling ketara. Menukar '1' paling kiri hingga '0'. 101001 ^ 100000 = 001001 (9); Kiri - beralih sekali untuk menambah '0' tambahan ke hujung kanan nombor binari 001001 = 010010 (18); Mengubah '0' pada akhir hingga '1' yang pada dasarnya sama seperti meletakkan MSB di tempat paling kanan. 010010 | 1 = 010011 (19); fungsi utama pemacu berkod keras untuk menjalankan program", "code": "#include <stdio.h> NEW_LINE int msbPos ( int n ) { int pos = 0 ; while ( n != 0 ) { pos ++ ; n = n >> 1 ; } return pos ; } int josephify ( int n ) { int position = msbPos ( n ) ; int j = 1 << ( position - 1 ) ; n = n ^ j ; n = n << 1 ; n = n | 1 ; return n ; } int main ( ) { int n = 41 ; printf ( \" % d STRNEWLINE \" , josephify ( n ) ) ; return 0 ; }"}
{"text": "Jumlah bitwise dan semua pasangan dalam array yang diberikan | Program C ++ yang cekap untuk mengira jumlah bitwise dan semua pasangan; Pulangan nilai \"arr [0] u arr [0] [0] [2] ur [2]. Melintasi semua bit; Kiraan bilangan elemen dengan bit i 'th bit int k = 0; Memulakan kiraan; Terdapat bit set k, bermakna k (k - 1) / 2 pasang. Setiap pasangan menambah 2 ^ i ke jawapannya. Oleh itu, kami menambah \"2 ^ i u u '(K * (K - 1) / 2]\" kepada jawapannya. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int pairAndSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) k ++ ; ans += ( 1 << i ) * ( k * ( k - 1 ) / 2 ) ; } return ans ; } int main ( ) { int arr [ ] = { 5 , 10 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << pairAndSum ( arr , n ) << endl ; return 0 ; }"}
{"text": "Teka -teki | Program untuk mencari bilangan kotak di papan catur | Berfungsi untuk mengembalikan kiraan kuadrat; ; Cara yang lebih baik untuk menulis n * (n + 1) * (2 n + 1) / 6; Kod pemacu", "code": "function countSquares ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } let n = 4 ; document . write ( \" Count ▁ of ▁ squares ▁ is ▁ \" + countSquares ( n ) ) ;"}
{"text": "Program untuk mencari GCD atau HCF dua nombor | C program untuk mencari GCD dua nombor; Fungsi rekursif untuk mengembalikan GCD A dan B; Semuanya membahagikan 0; Kes asas; A lebih besar; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } int main ( ) { int a = 98 , b = 56 ; printf ( \" GCD ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "Membina pokok xor dengan diberikan nod daun pokok binari yang sempurna | Program C untuk membina pokok xor dengan nod daun pokok binari yang sempurna dan nilai nod akar pokok; saiz maksimum untuk pokok xor; Memperuntukkan ruang ke pokok XOR; Fungsi rekursif yang membina pokok XOR untuk array [Mula ..... . akhir]. X adalah indeks nod semasa dalam XOR Tree St; Sekiranya terdapat satu elemen dalam array, simpannya dalam nod semasa pokok xor dan kembali; printf (\" % d\", xortree [x]); ; untuk subtree kiri; untuk subtree yang betul; untuk mendapatkan indeks pertengahan dari indeks sudut. ; Membina subtrees kiri dan kanan dengan operasi XOR; menggabungkan subtrees kiri dan kanan dengan operasi XOR; Fungsi untuk membina pokok XOR dari array yang diberikan. Fungsi ini memanggil Construct_XOR_TREE_UTIL () untuk mengisi memori yang diperuntukkan dari array Xort; Kod pemacu; nod daun pokok binari; Membina pokok xor; Ketinggian pokok xor; Saiz maksimum pokok xor; Node root berada pada indeks 0 memandangkan pengindeksan berasaskan 0 dalam pokok xor; Nilai cetak pada nod root", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #define maxsize  10005 NEW_LINE int xortree [ maxsize ] ; void construct_Xor_Tree_Util ( int current [ ] , int start , int end , int x ) { if ( start == end ) { xortree [ x ] = current [ start ] ; return ; } int left = x * 2 + 1 ; int right = x * 2 + 2 ; int mid = start + ( end - start ) / 2 ; construct_Xor_Tree_Util ( current , start , mid , left ) ; construct_Xor_Tree_Util ( current , mid + 1 , end , right ) ; xortree [ x ] = ( xortree [ left ] ^ xortree [ right ] ) ; } void construct_Xor_Tree ( int arr [ ] , int n ) { int i = 0 ; for ( i = 0 ; i < maxsize ; i ++ ) xortree [ i ] = 0 ; construct_Xor_Tree_Util ( arr , 0 , n - 1 , 0 ) ; } int main ( ) { int leaf_nodes [ ] = { 40 , 32 , 12 , 1 , 4 , 3 , 2 , 7 } , i = 0 ; int n = sizeof ( leaf_nodes ) / sizeof ( leaf_nodes [ 0 ] ) ; construct_Xor_Tree ( leaf_nodes , n ) ; int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; printf ( \" Nodes ▁ of ▁ the ▁ XOR ▁ tree STRNEWLINE \" ) ; for ( i = 0 ; i < max_size ; i ++ ) { printf ( \" % d ▁ \" , xortree [ i ] ) ; } int root = 0 ; printf ( \" Root : % d \" , xortree [ root ] ) ; }"}
{"text": "Bagaimana untuk menukar dua bit dalam integer yang diberikan? | Code C untuk bertukar diberikan bit nombor; Kiri - Shift 1 P1 dan P2 kali dan menggunakan XOR; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int swapBits ( int n , int p1 , int p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; } int main ( ) { printf ( \" Result ▁ = ▁ % d \" , swapBits ( 28 , 0 , 3 ) ) ; return 0 ; }"}
{"text": "Semak jika dua nod adalah sepupu di pokok binari | Program C untuk memeriksa sama ada dua nod dalam pokok binari adalah sepupu; Nod pokok binari; Fungsi utiliti untuk membuat nod pokok binari baru; Fungsi rekursif untuk memeriksa sama ada dua nod adalah adik -beradik; Kes asas; Fungsi rekursif untuk mencari tahap node 'ptr' dalam pokok binari; kes asas; Tahap pulangan jika nod hadir di subtree kiri; Lain mencari di subtree yang betul; Pulangan 1 jika a dan b adalah sepupu, jika tidak 0; 1. Kedua -dua nod harus berada pada tahap yang sama di dalam pokok binari. 2. Kedua -dua nod tidak boleh menjadi adik -beradik (bermakna mereka tidak sepatutnya mempunyai nod induk yang sama). ; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int item ) { struct Node * temp = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; } int isSibling ( struct Node * root , struct Node * a , struct Node * b ) { if ( root == NULL ) return 0 ; return ( ( root -> left == a && root -> right == b ) || ( root -> left == b && root -> right == a ) || isSibling ( root -> left , a , b ) || isSibling ( root -> right , a , b ) ) ; } int level ( struct Node * root , struct Node * ptr , int lev ) { if ( root == NULL ) return 0 ; if ( root == ptr ) return lev ; int l = level ( root -> left , ptr , lev + 1 ) ; if ( l != 0 ) return l ; return level ( root -> right , ptr , lev + 1 ) ; } int isCousin ( struct Node * root , struct Node * a , struct Node * b ) { if ( ( level ( root , a , 1 ) == level ( root , b , 1 ) ) && ! ( isSibling ( root , a , b ) ) ) return 1 ; else return 0 ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> right -> right = newNode ( 15 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; struct Node * Node1 , * Node2 ; Node1 = root -> left -> left ; Node2 = root -> right -> right ; isCousin ( root , Node1 , Node2 ) ? puts ( \" Yes \" ) : puts ( \" No \" ) ; return 0 ; }"}
{"text": "Semak jika semua daun berada pada tahap yang sama | Program C untuk memeriksa sama ada semua daun berada pada tahap yang sama; Nod pokok binari; Fungsi utiliti untuk memperuntukkan nod pokok baru; Fungsi rekursif yang memeriksa sama ada semua daun berada pada tahap yang sama; Kes asas; Jika nod daun ditemui; Apabila nod daun dijumpai kali pertama; Tetapkan tahap pertama yang dijumpai; Jika ini bukan nod daun pertama, bandingkan tahapnya dengan tahap Leaf pertama; Jika nod ini tidak daun, periksa secara rekursif subtrees kiri dan kanan; Fungsi utama untuk memeriksa sama ada semua daun berada pada tahap yang sama. Ia terutamanya menggunakan checkUtil (); Program pemacu untuk menguji fungsi di atas; Mari kita buat pokok yang ditunjukkan dalam contoh ketiga", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } bool checkUtil ( struct Node * root , int level , int * leafLevel ) { if ( root == NULL ) return true ; if ( root -> left == NULL && root -> right == NULL ) { if ( * leafLevel == 0 ) { * leafLevel = level ; return true ; } return ( level == * leafLevel ) ; } return checkUtil ( root -> left , level + 1 , leafLevel ) && checkUtil ( root -> right , level + 1 , leafLevel ) ; } bool check ( struct Node * root ) { int level = 0 , leafLevel = 0 ; return checkUtil ( root , level , & leafLevel ) ; } int main ( ) { struct Node * root = newNode ( 12 ) ; root -> left = newNode ( 5 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 9 ) ; root -> left -> left -> left = newNode ( 1 ) ; root -> left -> right -> left = newNode ( 1 ) ; if ( check ( root ) ) printf ( \" Leaves ▁ are ▁ at ▁ same ▁ level STRNEWLINE \" ) ; else printf ( \" Leaves ▁ are ▁ not ▁ at ▁ same ▁ level STRNEWLINE \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Semak sama ada pokok binari adalah pokok binari penuh atau tidak | Program C untuk memeriksa sama ada pokok binari yang diberikan penuh atau tidak; Struktur nod pokok; Fungsi penolong yang memperuntukkan nod baru dengan penunjuk kiri dan null kiri dan kanan. ; Fungsi ini ujian jika pokok binari adalah pokok binari penuh. ; Jika pokok kosong; Jika nod daun; Jika kedua -dua kiri dan kanan tidak batal, dan subtrees kiri & kanan penuh; Kami sampai di sini apabila tidak ada di atas jika keadaan berfungsi; Program Pemandu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE struct Node { int key ; struct Node * left , * right ; } ; struct Node * newNode ( char k ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> key = k ; node -> right = node -> left = NULL ; return node ; } bool isFullTree ( struct Node * root ) { if ( root == NULL ) return true ; if ( root -> left == NULL && root -> right == NULL ) return true ; if ( ( root -> left ) && ( root -> right ) ) return ( isFullTree ( root -> left ) && isFullTree ( root -> right ) ) ; return false ; } int main ( ) { struct Node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( 20 ) ; root -> right = newNode ( 30 ) ; root -> left -> right = newNode ( 40 ) ; root -> left -> left = newNode ( 50 ) ; root -> right -> left = newNode ( 60 ) ; root -> right -> right = newNode ( 70 ) ; root -> left -> left -> left = newNode ( 80 ) ; root -> left -> left -> right = newNode ( 90 ) ; root -> left -> right -> left = newNode ( 80 ) ; root -> left -> right -> right = newNode ( 90 ) ; root -> right -> left -> left = newNode ( 80 ) ; root -> right -> left -> right = newNode ( 90 ) ; root -> right -> right -> left = newNode ( 80 ) ; root -> right -> right -> right = newNode ( 90 ) ; if ( isFullTree ( root ) ) printf ( \" The ▁ Binary ▁ Tree ▁ is ▁ full STRNEWLINE \" ) ; else printf ( \" The ▁ Binary ▁ Tree ▁ is ▁ not ▁ full STRNEWLINE \" ) ; return ( 0 ) ; }"}
{"text": "Cetak Elemen Alternatif Array | Program C untuk melaksanakan pendekatan di atas; Berfungsi untuk mencetak elemen alternatif dari array yang diberikan; Elemen cetak pada kedudukan ganjil; Cetak elemen array; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void printAlter ( int arr [ ] , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex += 2 ) { printf ( \" % d ▁ \" , arr [ currIndex ] ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAlter ( arr , N ) ; }"}
{"text": "Tulis kod untuk menentukan sama ada dua pokok adalah sama |  ; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Memandangkan dua pokok, kembali benar jika mereka sama dengan struktur; 1. Kedua -duanya kosong; 2. Kedua -dua tidak - kosong -> Bandingkan mereka; 3. Satu kosong, tidak -> palsu; Program pemacu untuk menguji fungsi identiti", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int identicalTrees ( struct node * a , struct node * b ) { if ( a == NULL && b == NULL ) return 1 ; if ( a != NULL && b != NULL ) { return ( a -> data == b -> data && identicalTrees ( a -> left , b -> left ) && identicalTrees ( a -> right , b -> right ) ) ; } return 0 ; } int main ( ) { struct node * root1 = newNode ( 1 ) ; struct node * root2 = newNode ( 1 ) ; root1 -> left = newNode ( 2 ) ; root1 -> right = newNode ( 3 ) ; root1 -> left -> left = newNode ( 4 ) ; root1 -> left -> right = newNode ( 5 ) ; root2 -> left = newNode ( 2 ) ; root2 -> right = newNode ( 3 ) ; root2 -> left -> left = newNode ( 4 ) ; root2 -> left -> right = newNode ( 5 ) ; if ( identicalTrees ( root1 , root2 ) ) printf ( \" Both ▁ tree ▁ are ▁ identical . \" ) ; else printf ( \" Trees ▁ are ▁ not ▁ identical . \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cetak sepupu nod yang diberikan dalam pokok binari | Program c untuk mencetak sepupu nod; Nod pokok binari; Fungsi utiliti untuk membuat nod pokok binari baru; Ia mengembalikan tahap nod jika ada di dalam pokok, jika tidak pulangan 0 .; kes asas; Jika nod hadir di subtree kiri; Jika nod tidak hadir di subtree kiri; Cetak nod pada tahap tertentu supaya adik nod tidak dicetak jika ia wujud; Kes asas; Jika nod semasa adalah induk nod dengan tahap tertentu; Berulang untuk subtrees kiri dan kanan; Fungsi ini mencetak sepupu nod yang diberikan; Dapatkan tahap nod yang diberikan; Cetak nod tahap yang diberikan. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; } int getLevel ( Node * root , Node * node , int level ) { if ( root == NULL ) return 0 ; if ( root == node ) return level ; int downlevel = getLevel ( root -> left , node , level + 1 ) ; if ( downlevel != 0 ) return downlevel ; return getLevel ( root -> right , node , level + 1 ) ; } void printGivenLevel ( Node * root , Node * node , int level ) { if ( root == NULL level < 2 ) return ; if ( level == 2 ) { if ( root -> left == node root -> right == node ) return ; if ( root -> left ) printf ( \" % d ▁ \" , root -> left -> data ) ; if ( root -> right ) printf ( \" % d ▁ \" , root -> right -> data ) ; } else if ( level > 2 ) { printGivenLevel ( root -> left , node , level - 1 ) ; printGivenLevel ( root -> right , node , level - 1 ) ; } } void printCousins ( Node * root , Node * node ) { int level = getLevel ( root , node , 1 ) ; printGivenLevel ( root , node , level ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> right -> right = newNode ( 15 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; printCousins ( root , root -> left -> right ) ; return 0 ; }"}
{"text": "Memandangkan pokok binari, cetak semua akarnya | program untuk mencetak semua laluan akarnya - ke daun untuk pokok; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Prototaip fungsi; Memandangkan pokok binari, cetak semua laluan akarnya - ke daun, satu setiap baris. Menggunakan pembantu rekursif untuk melakukan kerja. ; Fungsi pembantu rekursif - diberi nod, dan array yang mengandungi laluan dari nod akar sehingga tetapi tidak termasuk nod ini, cetak semua laluan daun akar. ; tambah nod ini ke array jalan; Ia adalah daun, jadi cetak jalan yang membawa ke sini; Jika tidak, cuba kedua -dua subtrees; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Utiliti yang mencetak array pada baris; Program pemandu untuk menguji cermin (); Cetak semua root - ke - jalur daun pokok input", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; void printArray ( int [ ] , int ) ; void printPathsRecur ( struct node * , int [ ] , int ) ; struct node * newNode ( int ) ; void printPaths ( struct node * ) ; void printPaths ( struct node * node ) { int path [ 1000 ] ; printPathsRecur ( node , path , 0 ) ; } void printPathsRecur ( struct node * node , int path [ ] , int pathLen ) { if ( node == NULL ) return ; path [ pathLen ] = node -> data ; pathLen ++ ; if ( node -> left == NULL && node -> right == NULL ) { printArray ( path , pathLen ) ; } else { printPathsRecur ( node -> left , path , pathLen ) ; printPathsRecur ( node -> right , path , pathLen ) ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void printArray ( int ints [ ] , int len ) { int i ; for ( i = 0 ; i < len ; i ++ ) { printf ( \" % d ▁ \" , ints [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printPaths ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Pengenalan kepada Array |  ; Mewujudkan array integer bernama arr dari saiz 10 .; mengakses elemen pada 0 indeks dan menetapkan nilainya kepada 5 .; Akses dan nilai cetak pada 0 indeks kita mendapat output sebagai 5.", "code": "#include <stdio.h> NEW_LINE int main ( ) { int arr [ 10 ] ; arr [ 0 ] = 5 ; printf ( \" % d \" , arr [ 0 ] ) ; return 0 ; }"}
{"text": "Algoritma swap blok untuk putaran array |  ; Prototaip untuk fungsi utiliti; Kembali jika bilangan elemen diputar adalah sifar atau sama dengan saiz array; Jika bilangan elemen diputar adalah tepat separuh daripada saiz array; Jika A adalah lebih pendek; Jika B lebih pendek; berfungsi untuk mencetak array; Fungsi ini menukar elemen D bermula pada indeks fi dengan elemen D bermula pada indeks Si; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void printArray ( int arr [ ] , int size ) ; void swap ( int arr [ ] , int fi , int si , int d ) ; void leftRotate ( int arr [ ] , int d , int n ) { if ( d == 0 d == n ) return ; if ( n - d == d ) { swap ( arr , 0 , n - d , d ) ; return ; } if ( d < n - d ) { swap ( arr , 0 , n - d , d ) ; leftRotate ( arr , d , n - d ) ; } else { swap ( arr , 0 , d , n - d ) ; leftRotate ( arr + n - d , 2 * d - n , d ) ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE ▁ \" ) ; } void swap ( int arr [ ] , int fi , int si , int d ) { int i , temp ; for ( i = 0 ; i < d ; i ++ ) { temp = arr [ fi + i ] ; arr [ fi + i ] = arr [ si + i ] ; arr [ si + i ] = temp ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; leftRotate ( arr , 2 , 7 ) ; printArray ( arr , 7 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Algoritma swap blok untuk putaran array | C Kod untuk pelaksanaan di atas; A adalah lebih pendek; B adalah lebih pendek; Akhirnya, blok swap a dan b", "code": "void leftRotate ( int arr [ ] , int d , int n ) { int i , j ; if ( d == 0 d == n ) return ; i = d ; j = n - d ; while ( i != j ) { if ( i < j ) { swap ( arr , d - i , d + j - i , i ) ; j -= i ; } else { swap ( arr , d - i , d , j ) ; i -= j ; } } swap ( arr , d - i , d , i ) ; }"}
{"text": "Program untuk berputar secara kitaran dengan satu | |  ; swap; Saya dan J menunjuk kepada elemen pertama dan terakhir; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void swap ( int * x , int * y ) { int temp = * x ; * x = * y ; * y = temp ; } void rotate ( int arr [ ] , int n ) { int i = 0 , j = n - 1 ; while ( i != j ) { swap ( & arr [ i ] , & arr [ j ] ) ; i ++ ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } , i ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given ▁ array ▁ is STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; rotate ( arr , n ) ; printf ( \" Rotated array is \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }"}
{"text": "Program untuk menyusun pelbagai rentetan menggunakan pilihan pilihan | Program C untuk melaksanakan jenis pemilihan untuk pelbagai rentetan. ; Menyusun pelbagai rentetan di mana panjang setiap rentetan harus lebih kecil daripada max_len; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Jika min lebih besar daripada arr [j]; Membuat arr [j] sebagai minstr dan kemas kini min_idx; Tukar elemen minimum yang dijumpai dengan elemen pertama; Kod pemacu; Mencetak array sebelum menyusun; Mencetak array selepas menyusun", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define MAX_LEN  100 NEW_LINE void selectionSort ( char arr [ ] [ MAX_LEN ] , int n ) { int i , j , min_idx ; char minStr [ MAX_LEN ] ; for ( i = 0 ; i < n - 1 ; i ++ ) { int min_idx = i ; strcpy ( minStr , arr [ i ] ) ; for ( j = i + 1 ; j < n ; j ++ ) { if ( strcmp ( minStr , arr [ j ] ) > 0 ) { strcpy ( minStr , arr [ j ] ) ; min_idx = j ; } } if ( min_idx != i ) { char temp [ MAX_LEN ] ; strcpy ( temp , arr [ i ] ) ; strcpy ( arr [ i ] , arr [ min_idx ] ) ; strcpy ( arr [ min_idx ] , temp ) ; } } } int main ( ) { char arr [ ] [ MAX_LEN ] = { \" GeeksforGeeks \" , \" Practice . GeeksforGeeks \" , \" GeeksQuiz \" } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int i ; printf ( \" Given ▁ array ▁ is STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d : ▁ % s ▁ STRNEWLINE \" , i , arr [ i ] ) ; selectionSort ( arr , n ) ; printf ( \" Sorted array is \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d : ▁ % s ▁ STRNEWLINE \" , i , arr [ i ] ) ; return 0 ; }"}
{"text": "Susun semula array sedemikian rupa sehingga 'arr [j]' menjadi 'i' if 'arr [i]' adalah 'j' | Tetapkan 1 | Program c yang mudah untuk menyusun semula kandungan arr [] supaya arr [j] menjadi J jika arr [i] adalah j; Kaedah mudah untuk menyusun semula 'arr [0. . n - 1] 'jadi' arr [j] 'menjadi' i 'if' arr [i] 'adalah' j '; Buat pelbagai tambahan dengan saiz yang sama; Kedai menghasilkan temp []; Salin temp kembali ke arr []; Fungsi utiliti untuk mencetak kandungan ARR [0 .. n - 1]; Program Pemandu", "code": "#include <stdio.h> NEW_LINE void rearrangeNaive ( int arr [ ] , int n ) { int temp [ n ] , i ; for ( i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] = i ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 0 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given ▁ array ▁ is ▁ STRNEWLINE \" ) ; printArray ( arr , n ) ; rearrangeNaive ( arr , n ) ; printf ( \" Modified ▁ array ▁ is ▁ STRNEWLINE \" ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Program untuk mencari elemen terbesar dalam array | Program c untuk mencari maksimum dalam arr [] saiz n; C berfungsi untuk mencari maksimum dalam arr [] saiz n; Memulakan elemen maksimum; Melintasi unsur -unsur array dari kedua dan bandingkan setiap elemen dengan max semasa; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int largest ( int arr [ ] , int n ) { int i ; int max = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; } int main ( ) { int arr [ ] = { 10 , 324 , 45 , 90 , 9808 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Largest ▁ in ▁ given ▁ array ▁ is ▁ % d \" , largest ( arr , n ) ) ; return 0 ; }"}
{"text": "Cari elemen kedua terbesar dalam array | Program C untuk mencari elemen kedua terbesar dalam array; Berfungsi untuk mencetak elemen kedua terbesar; Harus ada dua elemen; Jika elemen semasa lebih besar daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Program pemacu untuk menguji fungsi di atas", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { printf ( \" ▁ Invalid ▁ Input ▁ \" ) ; return ; } first = second = INT_MIN ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MIN ) printf ( \" There ▁ is ▁ no ▁ second ▁ largest ▁ element STRNEWLINE \" ) ; else printf ( \" The ▁ second ▁ largest ▁ element ▁ is ▁ % dn \" , second ) ; } int main ( ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2largest ( arr , n ) ; return 0 ; }"}
{"text": "Maksimum dan minimum array menggunakan bilangan perbandingan minimum | struktur digunakan untuk mengembalikan dua nilai dari Minmax (); Jika hanya ada satu elemen maka kembali sebagai min dan max kedua -duanya; Sekiranya terdapat lebih daripada satu elemen, maka mulakan min dan max; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE struct pair { int min ; int max ; } ; struct pair getMinMax ( int arr [ ] , int n ) { struct pair minmax ; int i ; if ( n == 1 ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 0 ] ; return minmax ; } if ( arr [ 0 ] > arr [ 1 ] ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 1 ] ; } else { minmax . max = arr [ 1 ] ; minmax . min = arr [ 0 ] ; } for ( i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > minmax . max ) minmax . max = arr [ i ] ; else if ( arr [ i ] < minmax . min ) minmax . min = arr [ i ] ; } return minmax ; } int main ( ) { int arr [ ] = { 1000 , 11 , 445 , 1 , 330 , 3000 } ; int arr_size = 6 ; struct pair minmax = getMinMax ( arr , arr_size ) ; printf ( \" nMinimum ▁ element ▁ is ▁ % d \" , minmax . min ) ; printf ( \" nMaximum ▁ element ▁ is ▁ % d \" , minmax . max ) ; getchar ( ) ; }"}
{"text": "Maksimum dan minimum array menggunakan bilangan perbandingan minimum |  ; struktur digunakan untuk mengembalikan dua nilai dari Minmax (); Jika Array mempunyai bilangan elemen, maka memulakan dua elemen pertama sebagai minimum dan maksimum; Tetapkan indeks permulaan untuk gelung; Jika array mempunyai bilangan elemen yang ganjil maka memulakan elemen pertama sebagai minimum dan maksimum; Tetapkan indeks permulaan untuk gelung; Dalam gelung sementara, pilih elemen dalam pasangan dan bandingkan pasangan dengan Max dan Min setakat ini; Meningkatkan indeks sebanyak 2 kerana dua elemen diproses dalam gelung; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE struct pair { int min ; int max ; } ; struct pair getMinMax ( int arr [ ] , int n ) { struct pair minmax ; int i ; if ( n % 2 == 0 ) { if ( arr [ 0 ] > arr [ 1 ] ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 1 ] ; } else { minmax . min = arr [ 0 ] ; minmax . max = arr [ 1 ] ; } i = 2 ; } else { minmax . min = arr [ 0 ] ; minmax . max = arr [ 0 ] ; i = 1 ; } while ( i < n - 1 ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] > minmax . max ) minmax . max = arr [ i ] ; if ( arr [ i + 1 ] < minmax . min ) minmax . min = arr [ i + 1 ] ; } else { if ( arr [ i + 1 ] > minmax . max ) minmax . max = arr [ i + 1 ] ; if ( arr [ i ] < minmax . min ) minmax . min = arr [ i ] ; } i += 2 ; } return minmax ; } int main ( ) { int arr [ ] = { 1000 , 11 , 445 , 1 , 330 , 3000 } ; int arr_size = 6 ; struct pair minmax = getMinMax ( arr , arr_size ) ; printf ( \" nMinimum ▁ element ▁ is ▁ % d \" , minmax . min ) ; printf ( \" nMaximum ▁ element ▁ is ▁ % d \" , minmax . max ) ; getchar ( ) ; }"}
{"text": "Bilangan lompat minimum untuk mencapai hujung | Program C untuk mencari bilangan lompatan minimum untuk mencapai hujung; Mengembalikan bilangan lompatan minimum untuk mencapai arr [h] dari arr [l]; Kes asas: Apabila sumber dan destinasi sama; Apabila tiada apa yang dapat dicapai dari sumber yang diberikan; Melintasi semua mata yang dapat dicapai dari arr [l]. Recursif Dapatkan bilangan lompatan minimum yang diperlukan untuk mencapai arr [H] dari titik -titik yang dapat dicapai ini. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int minJumps ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return INT_MAX ; int min = INT_MAX ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != INT_MAX && jumps + 1 < min ) min = jumps + 1 ; } return min ; } int main ( ) { int arr [ ] = { 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach ▁ end ▁ is ▁ % d ▁ \" , minJumps ( arr , 0 , n - 1 ) ) ; return 0 ; }"}
{"text": "Subarray terkecil dengan jumlah yang lebih besar daripada nilai tertentu |  ; Mengembalikan panjang subarray terkecil dengan jumlah yang lebih besar daripada x. Sekiranya tidak ada subarray dengan jumlah yang diberikan, maka pulangan n + 1; Memulakan panjang subarray terkecil sebagai n + 1; Pilih setiap elemen sebagai titik permulaan; Memulakan jumlah bermula dengan permulaan semasa; Jika elemen pertama itu sendiri lebih besar; Cuba titik akhir yang berbeza untuk permulaan Curremt; Tambah elemen terakhir kepada jumlah semasa; Jika jumlah menjadi lebih daripada x dan panjang subarray ini lebih kecil daripada panjang terkecil semasa, kemas kini panjang terkecil (atau hasil); Program pemacu untuk menguji fungsi di atas", "code": "# include <iostream> NEW_LINE using namespace std ; int smallestSubWithSum ( int arr [ ] , int n , int x ) { int min_len = n + 1 ; for ( int start = 0 ; start < n ; start ++ ) { int curr_sum = arr [ start ] ; if ( curr_sum > x ) return 1 ; for ( int end = start + 1 ; end < n ; end ++ ) { curr_sum += arr [ end ] ; if ( curr_sum > x && ( end - start + 1 ) < min_len ) min_len = ( end - start + 1 ) ; } } return min_len ; } int main ( ) { int arr1 [ ] = { 1 , 4 , 45 , 6 , 10 , 19 } ; int x = 51 ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int res1 = smallestSubWithSum ( arr1 , n1 , x ) ; ( res1 == n1 + 1 ) ? cout << \" Not ▁ possible STRNEWLINE \" : cout << res1 << endl ; int arr2 [ ] = { 1 , 10 , 5 , 2 , 7 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; x = 9 ; int res2 = smallestSubWithSum ( arr2 , n2 , x ) ; ( res2 == n2 + 1 ) ? cout << \" Not ▁ possible STRNEWLINE \" : cout << res2 << endl ; int arr3 [ ] = { 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; x = 280 ; int res3 = smallestSubWithSum ( arr3 , n3 , x ) ; ( res3 == n3 + 1 ) ? cout << \" Not ▁ possible STRNEWLINE \" : cout << res3 << endl ; return 0 ; }"}
{"text": "Traversals Tree (inorder, preorder dan postorder) | Program c untuk traversals pokok yang berbeza; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Memandangkan pokok binari, cetak nodnya mengikut traversal postorder \"bawah\". ; pertama berulang di subtree kiri; kemudian berulang pada subtree kanan; Sekarang berurusan dengan nod; Memandangkan pokok binari, cetak nodnya dalam inorder; pertama berulang pada anak kiri; kemudian cetak data nod; sekarang berulang pada anak yang betul; Memandangkan pokok binari, cetak nodnya dalam preorder; data cetak pertama nod; kemudian berulang di Sutree kiri; kini berulang pada subtree yang betul; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void printPostorder ( struct node * node ) { if ( node == NULL ) return ; printPostorder ( node -> left ) ; printPostorder ( node -> right ) ; printf ( \" % d ▁ \" , node -> data ) ; } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; printInorder ( node -> right ) ; } void printPreorder ( struct node * node ) { if ( node == NULL ) return ; printf ( \" % d ▁ \" , node -> data ) ; printPreorder ( node -> left ) ; printPreorder ( node -> right ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Preorder traversal of binary tree is \" printPreorder ( root ) ; printf ( \" Inorder traversal of binary tree is \" printInorder ( root ) ; printf ( \" Postorder traversal of binary tree is \" printPostorder ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Keluarkan semua nod yang tidak terletak di mana -mana jalan dengan jumlah> = k |  ; Nod pokok binari; Fungsi utiliti untuk membuat nod pokok binari baru dengan data yang diberikan; Cetak pokok dalam cara LVR (inorder traversal). ; Fungsi utama yang memotong pokok binari. ; Kes asas; Berulang untuk subtrees kiri dan kanan; Jika kita mencapai daun yang datanya lebih kecil daripada jumlah, kita memadam daun. Satu perkara penting yang perlu diperhatikan ialah nod daun bukan boleh menjadi daun apabila chilrennya dipadam. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } void print ( struct Node * root ) { if ( root != NULL ) { print ( root -> left ) ; printf ( \" % d ▁ \" , root -> data ) ; print ( root -> right ) ; } } struct Node * prune ( struct Node * root , int sum ) { if ( root == NULL ) return NULL ; root -> left = prune ( root -> left , sum - root -> data ) ; root -> right = prune ( root -> right , sum - root -> data ) ; if ( root -> left == NULL && root -> right == NULL ) { if ( root -> data < sum ) { free ( root ) ; return NULL ; } } return root ; } int main ( ) { int k = 45 ; struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 12 ) ; root -> right -> right -> left = newNode ( 10 ) ; root -> right -> right -> left -> right = newNode ( 11 ) ; root -> left -> left -> right -> left = newNode ( 13 ) ; root -> left -> left -> right -> right = newNode ( 14 ) ; root -> left -> left -> right -> right -> left = newNode ( 15 ) ; printf ( \" Tree ▁ before ▁ truncation STRNEWLINE \" ) ; print ( root ) ;"}
{"text": "Gabungkan pelbagai saiz n ke dalam pelbagai saiz m + n | Program C untuk menggabungkan pelbagai saiz N ke dalam pelbagai saiz m + n; Dengan asumsi - 1 dipenuhi untuk tempat -tempat di mana elemen tidak tersedia; Berfungsi untuk memindahkan elemen m pada akhir array mplusn []; Menggabungkan array n [] saiz n ke dalam array mplusn [] saiz m + n; Indeks semasa I / P bahagian MPLUSN []; Indeks semasa N []; Indeks semasa output mplusn []; Ambil elemen dari mplusn [] jika a) nilai elemen yang dipilih lebih kecil dan kami belum sampai ke akhir b) Kami telah mencapai akhir n []; Jika tidak, ambil elemen dari n []; Utiliti yang mencetak array pada baris; Kod pemacu; Memulakan susunan; Gerakkan elemen M pada akhir Mplusn; Gabungan n [] ke mplusn []; Cetak mplusn yang dihasilkan", "code": "#include <stdio.h> NEW_LINE #define NA  -1 NEW_LINE void moveToEnd ( int mPlusN [ ] , int size ) { int i = 0 , j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) if ( mPlusN [ i ] != NA ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } } int merge ( int mPlusN [ ] , int N [ ] , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( j == n ) || ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int mPlusN [ ] = { 2 , 8 , NA , NA , NA , 13 , NA , 15 , 20 } ; int N [ ] = { 5 , 7 , 9 , 25 } ; int n = sizeof ( N ) / sizeof ( N [ 0 ] ) ; int m = sizeof ( mPlusN ) / sizeof ( mPlusN [ 0 ] ) - n ; moveToEnd ( mPlusN , m + n ) ; merge ( mPlusN , N , m , n ) ; printArray ( mPlusN , m + n ) ; return 0 ; }"}
{"text": "Count of N | Program C untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari maksimum antara dua nombor; Berfungsi untuk mencari minimum antara dua nombor; Berfungsi untuk mengembalikan kiraan nombor tersebut; Untuk nombor 1 - digit, kiraan adalah 10 tanpa mengira k; DP [J] menyimpan bilangan nombor I - digit yang berakhir dengan J; Menyimpan hasil panjang i; Inisialisasi kiraan untuk nombor 1 - digit; Mengira nilai untuk mengira digit lebih besar daripada 1; Cari julat nombor yang dibenarkan jika digit terakhir ialah J; Melakukan kemas kini pelbagai; Jumlah awalan untuk mencari kiraan sebenar nombor angka i yang berakhir dengan j; Kemas kini DP []; Menyimpan jawapan terakhir; Kembalikan jawapan terakhir; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int max ( int num1 , int num2 ) { return ( num1 > num2 ) ? num1 : num2 ; } int min ( int num1 , int num2 ) { return ( num1 > num2 ) ? num2 : num1 ; } int getCount ( int n , int k ) { if ( n == 1 ) return 10 ; int dp [ 11 ] = { 0 } ; int next [ 11 ] = { 0 } ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int l = max ( 0 , ( j - k ) ) ; int r = min ( 9 , ( j + k ) ) ; next [ l ] += dp [ j ] ; next [ r + 1 ] -= dp [ j ] ; } for ( int j = 1 ; j <= 9 ; j ++ ) next [ j ] += next [ j - 1 ] ; for ( int j = 0 ; j < 10 ; j ++ ) { dp [ j ] = next [ j ] ; next [ j ] = 0 ; } } int count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ i ] ; return count ; } int main ( ) { int n = 2 , k = 1 ; printf ( \" % d \" , getCount ( n , k ) ) ; }"}
{"text": "Kira Inversions dalam Array | Tetapkan 1 (menggunakan jenis gabungan) | Program C untuk mengira inversi dalam array; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; } int main ( ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" ▁ Number ▁ of ▁ inversions ▁ are ▁ % d ▁ STRNEWLINE \" , getInvCount ( arr , n ) ) ; return 0 ; }"}
{"text": "Dua elemen yang jumlahnya paling dekat dengan Zero | C Kod untuk mencari dua elemen yang jumlahnya paling dekat dengan sifar; Array harus mempunyai sekurang -kurangnya dua elemen; Permulaan nilai; Program pemacu untuk menguji fungsi di atas", "code": "# include <stdio.h> NEW_LINE # include <stdlib.h> NEW_LINE # include <math.h> NEW_LINE void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ; if ( arr_size < 2 ) { printf ( \" Invalid ▁ Input \" ) ; return ; } min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( abs ( min_sum ) > abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } printf ( \" ▁ The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are ▁ % d ▁ and ▁ % d \" , arr [ min_l ] , arr [ min_r ] ) ; } int main ( ) { int arr [ ] = { 1 , 60 , -10 , 70 , -80 , 85 } ; minAbsSumPair ( arr , 6 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Kesatuan dan persimpangan dua susunan yang disusun | Program C untuk mencari kesatuan dua susunan yang disusun; Fungsi cetakan kesatuan arr1 [] dan arr2 [] m ialah bilangan elemen dalam arr1 [] n ialah bilangan elemen dalam arr2 []; Cetak elemen baki array yang lebih besar; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) printf ( \" ▁ % d ▁ \" , arr1 [ i ++ ] ) ; else if ( arr2 [ j ] < arr1 [ i ] ) printf ( \" ▁ % d ▁ \" , arr2 [ j ++ ] ) ; else { printf ( \" ▁ % d ▁ \" , arr2 [ j ++ ] ) ; i ++ ; } } while ( i < m ) printf ( \" ▁ % d ▁ \" , arr1 [ i ++ ] ) ; while ( j < n ) printf ( \" ▁ % d ▁ \" , arr2 [ j ++ ] ) ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printUnion ( arr1 , arr2 , m , n ) ; getchar ( ) ; return 0 ; }"}
{"text": "Kesatuan dan persimpangan dua susunan yang disusun | Program C untuk mencari persimpangan dua susunan yang disusun; Fungsi cetakan persimpangan arr1 [] dan arr2 [] m ialah bilangan elemen dalam arr1 [] n ialah bilangan elemen dalam arr2 []; Program pemacu untuk menguji fungsi di atas; Fungsi panggilan", "code": "#include <stdio.h> NEW_LINE void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else { printf ( \" ▁ % d ▁ \" , arr2 [ j ++ ] ) ; i ++ ; } } } int main ( ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printIntersection ( arr1 , arr2 , m , n ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari daun jumlah maksimum ke laluan akar dalam pokok binari | Program C untuk mencari daun jumlah maksimum ke laluan akar dalam pokok binari; Struktur nod pokok; Fungsi utiliti yang mencetak semua nod pada jalan dari akar ke sasaran_leaf; Kes asas; kembali benar jika nod ini adalah sasaran_leaf atau daun sasaran hadir di salah satu keturunannya; Fungsi ini menetapkan target_leaf_ref untuk merujuk nod daun jumlah laluan maksimum. Juga, mengembalikan max_sum menggunakan max_sum_ref; Kemas kini jumlah semasa untuk memegang jumlah nod pada laluan dari akar ke nod ini; Jika ini adalah nod daun dan laluan ke nod ini mempunyai jumlah maksimum setakat ini, maka buat nod ini target_leaf; Jika ini bukan nod daun, kemudian berulang untuk mencari target_leaf; Mengembalikan jumlah maksimum dan mencetak nod pada laluan maksimum; Kes asas; Cari daun sasaran dan jumlah maksimum; Cetak jalan dari akar ke daun sasaran; kembali jumlah maksimum; Fungsi utiliti untuk membuat nod pokok binari baru; Fungsi pemacu untuk menguji fungsi di atas", "code": "#include <limits.h> NEW_LINE #include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; bool printPath ( struct node * root , struct node * target_leaf ) { if ( root == NULL ) return false ; if ( root == target_leaf || printPath ( root -> left , target_leaf ) || printPath ( root -> right , target_leaf ) ) { printf ( \" % d ▁ \" , root -> data ) ; return true ; } return false ; } void getTargetLeaf ( struct node * node , int * max_sum_ref , int curr_sum , struct node * * target_leaf_ref ) { if ( node == NULL ) return ; curr_sum = curr_sum + node -> data ; if ( node -> left == NULL && node -> right == NULL ) { if ( curr_sum > * max_sum_ref ) { * max_sum_ref = curr_sum ; * target_leaf_ref = node ; } } getTargetLeaf ( node -> left , max_sum_ref , curr_sum , target_leaf_ref ) ; getTargetLeaf ( node -> right , max_sum_ref , curr_sum , target_leaf_ref ) ; } int maxSumPath ( struct node * node ) { if ( node == NULL ) return 0 ; struct node * target_leaf ; int max_sum = INT_MIN ; getTargetLeaf ( node , & max_sum , 0 , & target_leaf ) ; printPath ( node , target_leaf ) ; return max_sum ; } struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int main ( ) { struct node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( -2 ) ; root -> right = newNode ( 7 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( -4 ) ; printf ( \" Following ▁ are ▁ the ▁ nodes ▁ on ▁ the ▁ maximum ▁ \" \" sum ▁ path ▁ STRNEWLINE \" ) ; int sum = maxSumPath ( root ) ; printf ( \" Sum of the nodes is % d \" , sum ) ; getchar ( ) ; return 0 ; }"}
{"text": "Susun pelbagai 0 s, 1 s dan 2 s | Program C untuk menyusun array dengan 0, 1 dan 2 dalam satu pas; Berfungsi untuk menukar * a dan * b; Susun array input, array diandaikan mempunyai nilai dalam {0, 1, 2}; Fungsi utiliti untuk mencetak array arr []; Program Pemandu untuk Menguji", "code": "#include <stdio.h> NEW_LINE void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : swap ( & a [ lo ++ ] , & a [ mid ++ ] ) ; break ; case 1 : mid ++ ; break ; case 2 : swap ( & a [ mid ] , & a [ hi -- ] ) ; break ; } } } void printArray ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" n \" ) ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int i ; sort012 ( arr , arr_size ) ; printf ( \" array ▁ after ▁ segregation ▁ \" ) ; printArray ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari subarray yang tidak disusun panjang minimum, menyusun yang menjadikan array lengkap disusun | Program C Untuk mencari subarray yang tidak disusun panjang minimum, menyusun yang menjadikan array lengkap disusun; Langkah 1 (a) Algo di atas; Langkah 1 (b) di atas algo; Langkah 2 (a) Algo di atas; Langkah 2 (b) di atas algo; Langkah 2 (c) Algo di atas; Langkah 3 dari algo di atas", "code": "#include <stdio.h> NEW_LINE void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { printf ( \" The ▁ complete ▁ array ▁ is ▁ sorted \" ) ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } printf ( \" ▁ The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ the ▁ given ▁ array ▁ \" \" ▁ sorted ▁ lies ▁ between ▁ the ▁ indees ▁ % d ▁ and ▁ % d \" , s , e ) ; return ; } int main ( ) { int arr [ ] = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printUnsorted ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Kira bilangan segitiga yang mungkin | Program C untuk mengira bilangan segitiga yang boleh dibentuk dari array yang diberikan; Fungsi berikut diperlukan untuk fungsi perpustakaan QSORT (). Rujuk www. cplusplus. com / rujukan / clibrary / cstdlib / qsort /; Berfungsi untuk mengira semua segi tiga yang mungkin dengan elemen ARR []; Susun unsur -unsur array dalam perintah yang tidak menurun; Memulakan kiraan segitiga; Betulkan elemen pertama. Kita perlu berjalan sehingga n - 3 kerana dua elemen lain dipilih dari arr [i + 1. . n - 1]; Memulakan indeks elemen ketiga paling kanan; Betulkan elemen kedua; Cari elemen paling kanan yang lebih kecil daripada jumlah dua elemen tetap yang penting untuk diperhatikan di sini, kami menggunakan nilai sebelumnya k. Jika nilai arr [i] + arr [j - 1] lebih besar daripada arr [k], maka arr [i] + arr [j] mestilah lebih besar daripada k, kerana array disusun. ; Jumlah bilangan segitiga yang mungkin boleh dibentuk dengan dua elemen tetap adalah k - j - 1. Kedua -dua elemen tetap adalah arr [i] dan arr [j]. Semua elemen antara arr [j + 1] / ke arr [k - 1] boleh membentuk segitiga dengan arr [i] dan arr [j]. Satu dikurangkan dari k kerana k ditingkatkan satu tambahan di atas sementara gelung. k akan sentiasa lebih besar daripada j. Jika j menjadi sama dengan k, maka di atas gelung akan meningkat k, kerana arr [k] + arr [i] sentiasa lebih besar daripada arr [k]; Program pemacu untuk menguji di atas fungsiarr [J + 1]", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE http : int comp ( const void * a , const void * b ) { return * ( int * ) a > * ( int * ) b ; } int findNumberOfTriangles ( int arr [ ] , int n ) { qsort ( arr , n , sizeof ( arr [ 0 ] ) , comp ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; } int main ( ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Total ▁ number ▁ of ▁ triangles ▁ possible ▁ is ▁ % d ▁ \" , findNumberOfTriangles ( arr , size ) ) ; return 0 ; }"}
{"text": "Cari, masukkan dan padamkan dalam array yang tidak disusun | Program C untuk melaksanakan carian linear dalam array yang tidak disusun; Berfungsi untuk melaksanakan operasi carian; Kod pemacu; Menggunakan elemen terakhir sebagai elemen carian", "code": "#include <stdio.h> NEW_LINE int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return -1 ; } int main ( ) { int arr [ ] = { 12 , 34 , 10 , 6 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 40 ; int position = findElement ( arr , n , key ) ; if ( position == - 1 ) printf ( \" Element ▁ not ▁ found \" ) ; else printf ( \" Element ▁ Found ▁ at ▁ Position : ▁ % d \" , position + 1 ) ; return 0 ; }"}
{"text": "Cari, masukkan dan padamkan dalam array yang tidak disusun | Program C untuk melaksanakan operasi sisipan dalam array yang tidak disusun. ; Masukkan kunci dalam ARR [] kapasiti yang diberikan. n ialah saiz semasa ARR []. Fungsi ini mengembalikan n + 1 jika penyisipan berjaya, lain n. ; Tidak boleh memasukkan lebih banyak elemen jika n sudah lebih daripada atau sama dengan capcity; Kod pemacu; Memasukkan kekunci", "code": "#include <stdio.h> NEW_LINE int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; arr [ n ] = key ; return ( n + 1 ) ; } int main ( ) { int arr [ 20 ] = { 12 , 16 , 20 , 40 , 50 , 70 } ; int capacity = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 6 ; int i , key = 26 ; printf ( \" Before Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; n = insertSorted ( arr , n , key , capacity ) ; printf ( \" After Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }"}
{"text": "Cari, masukkan dan padamkan dalam array yang tidak disusun | Program C untuk melaksanakan operasi memadam dalam pelbagai yang tidak disusun; Berfungsi untuk melaksanakan operasi carian; Berfungsi untuk memadam elemen; Cari kedudukan elemen untuk dipadamkan; Memadam elemen; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; } int deleteElement ( int arr [ ] , int n , int key ) { int pos = findElement ( arr , n , key ) ; if ( pos == - 1 ) { printf ( \" Element ▁ not ▁ found \" ) ; return n ; } int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; } int main ( ) { int i ; int arr [ ] = { 10 , 50 , 30 , 40 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 30 ; printf ( \" Array ▁ before ▁ deletion STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; n = deleteElement ( arr , n , key ) ; printf ( \" Array after deletion \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }"}
{"text": "Cari, masukkan dan padamkan dalam array yang disusun | Program c untuk melaksanakan carian binari dalam array yang disusun; berfungsi untuk melaksanakan carian binari; rendah + (tinggi - rendah) / 2; ; Kod pemacu biarkan kami mencari 3 di bawah array", "code": "#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } int main ( ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n , key ; n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; key = 10 ; printf ( \" Index : ▁ % d STRNEWLINE \" , binarySearch ( arr , 0 , n - 1 , key ) ) ; return 0 ; }"}
{"text": "Cari, masukkan dan padamkan dalam array yang disusun | Program C untuk melaksanakan operasi sisipan dalam pelbagai disusun. ; Masukkan kunci dalam ARR [] kapasiti yang diberikan. n ialah saiz semasa ARR []. Fungsi ini mengembalikan n + 1 jika penyisipan berjaya, lain n. ; Tidak boleh memasukkan lebih banyak elemen jika n sudah lebih daripada atau sama dengan capcity; Program pemacu untuk menguji fungsi di atas; Memasukkan kekunci", "code": "#include <stdio.h> NEW_LINE int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; int i ; for ( i = n - 1 ; ( i >= 0 && arr [ i ] > key ) ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; } int main ( ) { int arr [ 20 ] = { 12 , 16 , 20 , 40 , 50 , 70 } ; int capacity = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 6 ; int i , key = 26 ; printf ( \" Before Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; n = insertSorted ( arr , n , key , capacity ) ; printf ( \" After Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }"}
{"text": "Cari, masukkan dan padamkan dalam array yang disusun | Program C untuk melaksanakan operasi memadam dalam pelbagai disusun; Untuk mencari ley untuk dipadamkan; Berfungsi untuk memadam elemen; Cari kedudukan elemen untuk dipadamkan; Memadam elemen; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int low , int high , int key ) ; int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } int deleteElement ( int arr [ ] , int n , int key ) { int pos = binarySearch ( arr , 0 , n - 1 , key ) ; if ( pos == -1 ) { printf ( \" Element ▁ not ▁ found \" ) ; return n ; } int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; } int main ( ) { int i ; int arr [ ] = { 10 , 20 , 30 , 40 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 30 ; printf ( \" Array ▁ before ▁ deletion STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; n = deleteElement ( arr , n , key ) ; printf ( \" Array after deletion \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Indeks Keseimbangan Array | Program C untuk mencari indeks keseimbangan array; berfungsi untuk mencari indeks keseimbangan; Semak indeks satu demi satu sehingga indeks keseimbangan dijumpai; Dapatkan jumlah kiri; Dapatkan jumlah yang betul; Jika Leftsum dan Rightsum sama, maka kita sudah selesai; Pulangan - 1 Jika tiada indeks keseimbangan dijumpai; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d \" , equilibrium ( arr , arr_size ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Indeks Keseimbangan Array | Program C untuk mencari indeks keseimbangan array; berfungsi untuk mencari indeks keseimbangan; memulakan jumlah keseluruhan array; memulakan leftsum; Cari jumlah keseluruhan array; Jumlah kini Jumlah Jumlah untuk Indeks I; Jika tiada indeks keseimbangan dijumpai, maka kembali 0; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return -1 ; } int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" First ▁ equilibrium ▁ index ▁ is ▁ % d \" , equilibrium ( arr , arr_size ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Siling dalam array yang disusun |  ; Fungsi untuk mendapatkan indeks siling x dalam arr [rendah. . tinggi]; Jika x lebih kecil daripada atau sama dengan elemen pertama, maka kembalikan elemen pertama; Jika tidak, linear cari nilai ceil; jika x terletak di antara arr [i] dan arr [i + 1] termasuk arr [i + 1], kemudian kembali arr [i + 1]; Jika kita sampai di sini maka x lebih besar daripada elemen terakhir array, kembali - 1 dalam kes ini; Program pemacu untuk menyemak fungsi di atas", "code": "#include <stdio.h> NEW_LINE int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return -1 ; } int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) printf ( \" Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ \" , x ) ; else printf ( \" ceiling ▁ of ▁ % d ▁ is ▁ % d \" , x , arr [ index ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Siling dalam array yang disusun |  ; Fungsi untuk mendapatkan indeks siling x dalam arr [rendah. . tinggi]; Jika x lebih kecil daripada atau sama dengan elemen pertama, maka kembalikan elemen pertama; Jika x lebih besar daripada elemen terakhir, maka kembali - 1; Dapatkan indeks elemen tengah ARR [rendah. . tinggi]; Jika x sama dengan elemen tengah, maka kembali pertengahan; Jika x lebih besar daripada arr [pertengahan], maka sama ada arr [pertengahan + 1] adalah siling x atau siling terletak pada arr [pertengahan + 1. . tinggi]; Jika x lebih kecil daripada arr [pertengahan], maka sama ada arr [pertengahan] adalah siling x atau siling terletak pada arr [rendah ... pertengahan - 1]; Program pemacu untuk menyemak fungsi di atas", "code": "#include <stdio.h> NEW_LINE int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return -1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 20 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) printf ( \" Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ \" , x ) ; else printf ( \" ceiling ▁ of ▁ % d ▁ is ▁ % d \" , x , arr [ index ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Teknik Dua Pointers | Penyelesaian naif untuk mencari jika terdapat pasangan dalam [0. N - 1] dengan jumlah yang diberikan. ; sama dengan I dan J bermaksud elemen yang sama; pasangan wujud; kerana array disusun; Tiada pasangan yang dijumpai dengan jumlah yang diberikan. ; Kod pemacu; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE int isPairSum ( int A [ ] , int N , int X ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; if ( A [ i ] + A [ j ] == X ) return true ; if ( A [ i ] + A [ j ] > X ) break ; } } return 0 ; } int main ( ) { int arr [ ] = { 3 , 5 , 9 , 2 , 8 , 10 , 11 } ; int val = 17 ; int arrSize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d \" , isPairSum ( arr , arrSize , val ) ) ; return 0 ; }"}
{"text": "Teknik Dua Pointers |  ; Penyelesaian berasaskan teknik dua penunjuk untuk mencari jika terdapat pasangan dalam [0. N - 1] dengan jumlah yang diberikan. ; mewakili penunjuk pertama; mewakili penunjuk kedua; Jika kita mencari pasangan; Jika jumlah elemen pada penunjuk semasa kurang, kita bergerak ke arah nilai yang lebih tinggi dengan melakukan i ++; Jika jumlah elemen pada penunjuk semasa lebih banyak, kita bergerak ke arah nilai yang lebih rendah dengan melakukan j -; Kod pemacu; perisytiharan array; nilai untuk mencari; saiz array; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE int isPairSum ( int A [ ] , int N , int X ) { int i = 0 ; int j = N - 1 ; while ( i < j ) { if ( A [ i ] + A [ j ] == X ) return 1 ; else if ( A [ i ] + A [ j ] < X ) i ++ ; else j -- ; } return 0 ; } int main ( ) { int arr [ ] = { 3 , 5 , 9 , 2 , 8 , 10 , 11 } ; int val = 17 ; int arrSize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d \" , isPairSum ( arr , arrSize , val ) ) ; return 0 ; }"}
{"text": "Penjadualan baris pemasangan | DP | Program C untuk mencari masa minimum yang mungkin oleh casis kereta untuk diselesaikan; Fungsi utiliti untuk mencari minimum dua nombor; masa yang diambil untuk meninggalkan stesen pertama dalam baris 1; masa yang diambil untuk meninggalkan stesen pertama dalam baris 2; Mengisi jadual t1 [] dan t2 [] menggunakan hubungan rekursif yang diberikan di atas; Pertimbangkan masa keluar dan minimum retutn; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define NUM_LINE  2 NEW_LINE #define NUM_STATION  4 NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; } int carAssembly ( int a [ ] [ NUM_STATION ] , int t [ ] [ NUM_STATION ] , int * e , int * x ) { int T1 [ NUM_STATION ] , T2 [ NUM_STATION ] , i ; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; } int main ( ) { int a [ ] [ NUM_STATION ] = { { 4 , 5 , 3 , 2 } , { 2 , 10 , 1 , 4 } } ; int t [ ] [ NUM_STATION ] = { { 0 , 7 , 4 , 5 } , { 0 , 9 , 2 , 8 } } ; int e [ ] = { 10 , 12 } , x [ ] = { 18 , 7 } ; printf ( \" % d \" , carAssembly ( a , t , e , x ) ) ; return 0 ; }"}
{"text": "Sisipan minimum untuk membentuk palindrome | DP | Program berasaskan pengaturcaraan dinamik untuk mencari sisipan nombor minimum yang diperlukan untuk membuat palindrome rentetan; Fungsi utiliti untuk mencari minimum dua bilangan bulat; Fungsi DP untuk mencari bilangan sisipan minimum; Buat jadual saiz n * n. Jadual [i] [j] akan menyimpan bilangan sisipan minimum yang diperlukan untuk menukar str [i. . J] kepada palindrome. ; Isi jadual; Kembalikan bilangan sisipan minimum untuk STR [0 .. n - 1]; Program pemacu untuk menguji fungsi di atas.", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; } int findMinInsertionsDP ( char str [ ] , int n ) { int table [ n ] [ n ] , l , h , gap ; memset ( table , 0 , sizeof ( table ) ) ; for ( gap = 1 ; gap < n ; ++ gap ) for ( l = 0 , h = gap ; h < n ; ++ l , ++ h ) table [ l ] [ h ] = ( str [ l ] == str [ h ] ) ? table [ l + 1 ] [ h - 1 ] : ( min ( table [ l ] [ h - 1 ] , table [ l + 1 ] [ h ] ) + 1 ) ; return table [ 0 ] [ n - 1 ] ; } int main ( ) { char str [ ] = \" geeks \" ; printf ( \" % d \" , findMinInsertionsDP ( str , strlen ( str ) ) ) ; return 0 ; }"}
{"text": "Masalah Set Bebas Terbesar | DP | Pelaksanaan rekursif naif masalah set bebas terbesar; Fungsi utiliti untuk mencari maksimum dua bilangan bulat; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi ini mengembalikan saiz set bebas terbesar dalam pokok binari yang diberikan; Kirakan saiz tidak termasuk nod semasa; Hitung saiz termasuk nod semasa; Mengembalikan maksimum dua saiz; Fungsi utiliti untuk membuat nod; Program pemacu untuk menguji fungsi di atas; Mari kita buat pokok yang diberikan dalam rajah di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int max ( int x , int y ) { return ( x > y ) ? x : y ; } struct node { int data ; struct node * left , * right ; } ; int LISS ( struct node * root ) { if ( root == NULL ) return 0 ; int size_excl = LISS ( root -> left ) + LISS ( root -> right ) ; int size_incl = 1 ; if ( root -> left ) size_incl += LISS ( root -> left -> left ) + LISS ( root -> left -> right ) ; if ( root -> right ) size_incl += LISS ( root -> right -> left ) + LISS ( root -> right -> right ) ; return max ( size_incl , size_excl ) ; } struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printf ( \" Size ▁ of ▁ the ▁ Largest ▁ Independent ▁ Set ▁ is ▁ % d ▁ \" , LISS ( root ) ) ; return 0 ; }"}
{"text": "Rantaian Panjang Maksimum Pasangan | DP |  ; Fungsi ini mengandaikan bahawa ARR [] disusun dalam peningkatan urutan mengikut nilai pertama (atau lebih kecil) secara berpasangan. ; Inisialisasi nilai MCL (panjang rantai max) untuk semua indeks; Mengira nilai panjang rantai yang dioptimumkan dengan cara bawah; Pilih maksimum semua nilai MCL; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct pair { int a ; int b ; } ; int maxChainLength ( struct pair arr [ ] , int n ) { int i , j , max = 0 ; int * mcl = ( int * ) malloc ( sizeof ( int ) * n ) ; for ( i = 0 ; i < n ; i ++ ) mcl [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] . a > arr [ j ] . b && mcl [ i ] < mcl [ j ] + 1 ) mcl [ i ] = mcl [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < mcl [ i ] ) max = mcl [ i ] ; free ( mcl ) ; return max ; } int main ( ) { struct pair arr [ ] = { { 5 , 24 } , { 15 , 25 } , { 27 , 40 } , { 50 , 60 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Length ▁ of ▁ maximum ▁ size ▁ chain ▁ is ▁ % d STRNEWLINE \" , maxChainLength ( arr , n ) ) ; return 0 ; }"}
{"text": "Partitioning Palindrome | DP | Penyelesaian pengaturcaraan dinamik untuk masalah partisi palindrome; Mengembalikan bilangan minimum pemotongan yang diperlukan untuk memisahkan rentetan supaya setiap bahagian adalah palindrome; Dapatkan panjang rentetan; Buat dua tatasusunan untuk membina penyelesaian dengan cara bawah C [i] [j] = bilangan minimum pemotongan yang diperlukan untuk pembahagian palindrome substring str [i. . j] p [i] [j] = Benar jika substring str [i. . J] adalah palindrome, lain -lain yang salah nota bahawa C [i] [j] adalah 0 jika p [i] [j] adalah benar; pembolehubah gelung yang berbeza; Setiap substring panjang 1 adalah palindrome; L adalah panjang substring. Bina penyelesaian dengan cara bawah dengan mempertimbangkan semua substrings panjang bermula dari 2 hingga n. Struktur gelung adalah sama seperti masalah pendaraban rantai matriks (lihat https: www Geeksforgeeks. Org / matriks - rantai - pendaraban - dp - 8 /); Untuk substring panjang L, tetapkan indeks permulaan yang berbeza; Tetapkan indeks akhir; Jika L adalah 2, maka kita hanya perlu membandingkan dua aksara. Lain perlu menyemak dua aksara sudut dan nilai p [i + 1] [j - 1]; Jika str [i. . J] adalah palindrome, maka C [i] [j] adalah 0; Buat potongan di setiap lokasi yang mungkin bermula dari saya ke J, dan dapatkan potongan kos minimum. ; Kembalikan nilai potong min untuk rentetan lengkap. i. e. , str [0 .. n - 1]; Program pemacu untuk menguji fungsi di atas", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return ( a < b ) ? a : b ; } int minPalPartion ( char * str ) { int n = strlen ( str ) ; int C [ n ] [ n ] ; bool P [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] ) ; else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; } int main ( ) { char str [ ] = \" ababbbabbababa \" ; printf ( \" Min ▁ cuts ▁ needed ▁ for ▁ Palindrome ▁ Partitioning ▁ is ▁ % d \" , minPalPartion ( str ) ) ; return 0 ; }"}
{"text": "Algoritma Boyer Moore untuk Pencarian Corak | Program C untuk Heuristik Bad Heuristik Boyer Moore String Algoritma yang sepadan; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Fungsi pra -proses untuk heuristik watak buruk Boyer Moore; Memulakan semua kejadian sebagai - 1; Isi nilai sebenar kejadian terakhir watak; Fungsi carian corak yang menggunakan heuristik watak buruk dari algoritma Boyer Moore; Isi pelbagai watak yang buruk dengan memanggil fungsi preprocessing badcharheuristic () untuk corak yang diberikan; s adalah peralihan corak berkenaan dengan teks; Terus mengurangkan indeks j corak manakala watak -watak corak dan teks sepadan dengan peralihan ini; Jika corak hadir pada peralihan semasa, maka indeks j akan menjadi - 1 selepas gelung di atas; Peralih corak supaya watak seterusnya dalam teks sejajar dengan kejadian terakhir dalam coraknya. Keadaan s + m <n diperlukan untuk kes apabila corak berlaku pada akhir teks; Pergeseran corak supaya watak buruk dalam teks sejajar dengan kejadian terakhir dalam coraknya. Fungsi maksimum digunakan untuk memastikan kita mendapat peralihan positif. Kita mungkin mendapat peralihan negatif jika kejadian terakhir yang buruk dalam corak berada di sebelah kanan watak semasa. ; Program pemacu untuk menguji fungsi di atas", "code": "# include <limits.h> NEW_LINE # include <string.h> NEW_LINE # include <stdio.h> NEW_LINE # define NO_OF_CHARS  256 NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } void badCharHeuristic ( char * str , int size , int badchar [ NO_OF_CHARS ] ) { int i ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) badchar [ i ] = -1 ; for ( i = 0 ; i < size ; i ++ ) badchar [ ( int ) str [ i ] ] = i ; } void search ( char * txt , char * pat ) { int m = strlen ( pat ) ; int n = strlen ( txt ) ; int badchar [ NO_OF_CHARS ] ; badCharHeuristic ( pat , m , badchar ) ; int s = 0 ; while ( s <= ( n - m ) ) { int j = m - 1 ; while ( j >= 0 && pat [ j ] == txt [ s + j ] ) j -- ; if ( j < 0 ) { printf ( \" pattern occurs at shift = % d \" , s ) ; s += ( s + m < n ) ? m - badchar [ txt [ s + m ] ] : 1 ; } else s += max ( 1 , j - badchar [ txt [ s + j ] ] ) ; } } int main ( ) { char txt [ ] = \" ABAAABCD \" ; char pat [ ] = \" ABC \" ; search ( txt , pat ) ; return 0 ; }"}
{"text": "Perbezaan antara jumlah tahap ganjil dan juga nod tahap pokok binari | Program rekursif untuk mencari perbezaan antara jumlah nod pada tahap ganjil dan jumlah pada tahap bahkan; Nod pokok binari; Fungsi utiliti untuk memperuntukkan nod pokok baru dengan data yang diberikan; Fungsi utama yang mengembalikan perbezaan antara nod yang ganjil dan bahkan tahap; Kes asas; Perbezaan untuk akar adalah data akar - perbezaan untuk subtree kiri - perbezaan untuk subtree kanan; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int getLevelDiff ( struct node * root ) { if ( root == NULL ) return 0 ; return root -> data - getLevelDiff ( root -> left ) - getLevelDiff ( root -> right ) ; } int main ( ) { struct node * root = newNode ( 5 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; root -> left -> right -> left = newNode ( 3 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 7 ) ; printf ( \" % d ▁ is ▁ the ▁ required ▁ difference STRNEWLINE \" , getLevelDiff ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Akar ke jalur daun sama dengan nombor tertentu |  ; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Memandangkan pokok dan jumlah, kembali benar jika terdapat jalan dari akar ke daun, sehingga menambah semua nilai di sepanjang jalan sama dengan jumlah yang diberikan. Strategi: Kurangkan nilai nod dari jumlah semasa berulang, dan periksa untuk melihat apakah jumlahnya adalah 0 apabila anda kehabisan pokok. ; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Kod pemacu; Pokok binari yang dibina adalah 10 / \\ 8 2 / \\ / 3 5 2", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define bool  int NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; bool hasPathSum ( struct node * node , int sum ) { if ( node == NULL ) { return ( sum == 0 ) ; } else { bool ans = 0 ; int subSum = sum - node -> data ; if ( subSum == 0 && node -> left == NULL && node -> right == NULL ) return 1 ; if ( node -> left ) ans = ans || hasPathSum ( node -> left , subSum ) ; if ( node -> right ) ans = ans || hasPathSum ( node -> right , subSum ) ; return ans ; } } struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { int sum = 21 ; struct node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ; root -> left -> right = newnode ( 5 ) ; root -> right -> left = newnode ( 2 ) ; if ( hasPathSum ( root , sum ) ) printf ( \" There ▁ is ▁ a ▁ root - to - leaf ▁ path ▁ with ▁ sum ▁ % d \" , sum ) ; else printf ( \" There ▁ is ▁ no ▁ root - to - leaf ▁ path ▁ with ▁ sum ▁ % d \" , sum ) ; getchar ( ) ; return 0 ; }"}
{"text": "Jumlah semua nombor yang terbentuk dari akar ke laluan daun | Program C untuk mencari jumlah semua laluan dari akar ke daun; berfungsi untuk memperuntukkan nod baru dengan data yang diberikan; Mengembalikan jumlah semua akar ke laluan daun. Parameter pertama adalah akar subtree semasa, parameter kedua adalah nilai nombor yang dibentuk oleh nod dari akar ke nod ini; Kes asas; Kemas kini Val; Jika nod semasa adalah daun, kembalikan nilai semasa val; jumlah nilai untuk subtree kiri dan kanan; Fungsi pembalut ke atas Treepathssumutil (); Lulus nilai awal sebagai 0 kerana tiada apa -apa di atas akar; Fungsi pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int treePathsSumUtil ( struct node * root , int val ) { if ( root == NULL ) return 0 ; val = ( val * 10 + root -> data ) ; if ( root -> left == NULL && root -> right == NULL ) return val ; return treePathsSumUtil ( root -> left , val ) + treePathsSumUtil ( root -> right , val ) ; } int treePathsSum ( struct node * root ) { return treePathsSumUtil ( root , 0 ) ; } int main ( ) { struct node * root = newNode ( 6 ) ; root -> left = newNode ( 3 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 2 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 4 ) ; root -> left -> right -> left = newNode ( 7 ) ; root -> left -> right -> right = newNode ( 4 ) ; printf ( \" Sum ▁ of ▁ all ▁ paths ▁ is ▁ % d \" , treePathsSum ( root ) ) ; return 0 ; }"}
{"text": "Nenek moyang yang paling rendah dalam pokok binari | Tetapkan 2 (menggunakan penunjuk induk) | Program C ++ untuk mencari nenek moyang yang paling rendah menggunakan penunjuk induk; Nod pokok; Fungsi utiliti untuk membuat nod BST baru; Fungsi utiliti untuk memasukkan nod baru dengan kunci yang diberikan dalam pokok carian binari; Jika pokok itu kosong, kembalikan nod baru; Jika tidak, mengulangi pokok itu; Kembalikan penunjuk nod (tidak berubah); Untuk mencari LCA nod N1 dan N2 dalam pokok binari; Cipta peta untuk menyimpan nenek moyang N1; Masukkan N1 dan semua nenek moyangnya dalam peta; Semak jika N2 atau mana -mana nenek moyangnya berada dalam peta. ; Kaedah pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { Node * left , * right , * parent ; int key ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> parent = temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) { node -> left = insert ( node -> left , key ) ; node -> left -> parent = node ; } else if ( key > node -> key ) { node -> right = insert ( node -> right , key ) ; node -> right -> parent = node ; } return node ; } Node * LCA ( Node * n1 , Node * n2 ) { map < Node * , bool > ancestors ; while ( n1 != NULL ) { ancestors [ n1 ] = true ; n1 = n1 -> parent ; } while ( n2 != NULL ) { if ( ancestors . find ( n2 ) != ancestors . end ( ) ) return n2 ; n2 = n2 -> parent ; } return NULL ; } int main ( void ) { Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 8 ) ; root = insert ( root , 22 ) ; root = insert ( root , 4 ) ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 14 ) ; Node * n1 = root -> left -> right -> left ; Node * n2 = root -> left ; Node * lca = LCA ( n1 , n2 ) ; printf ( \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , n1 -> key , n2 -> key , lca -> key ) ; return 0 ; }"}
{"text": "Masalah Pengedaran Coklat | Tetapkan 2 | Program C untuk pendekatan di atas; Berfungsi untuk mengembalikan bilangan minimum coklat; mengurangkan urutan; Tambah coklat yang diterima oleh orang itu; titik akhir penurunan urutan; val = 1; Nilai tetapkan semula pada indeks itu; peningkatan urutan; urutan rata; Tambah nilai coklat pada kedudukan n - 1; Fungsi penolong untuk mendapatkan jumlah urutan yang berkurangan; Nilai yang diperoleh daripada penurunan urutan juga kiraan nilai dalam urutan; Menetapkan maksimum nilai yang diperoleh daripada urutan yang semakin meningkat dan menurun; Jumlah kiraan - 1 nilai & nilai puncak jumlah nombor semulajadi: (n * (n + 1)) / 2; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int minChocolates ( int a [ ] , int n ) { int i = 0 , j = 0 ; int res = 0 , val = 1 ; while ( j < n - 1 ) { if ( a [ j ] > a [ j + 1 ] ) { j += 1 ; continue ; } if ( i == j ) res += val ; else { res += get_sum ( val , i , j ) ; } if ( a [ j ] < a [ j + 1 ] ) val += 1 ; else val = 1 ; j += 1 ; i = j ; } if ( i == j ) res += val ; else res += get_sum ( val , i , j ) ; return res ; } int get_sum ( int peak , int start , int end ) { int count = end - start + 1 ; peak = ( peak > count ) ? peak : count ; int s = peak + ( ( ( count - 1 ) * count ) >> 1 ) ; return s ; } int main ( ) { int a [ ] = { 5 , 5 , 4 , 3 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printf ( \" Minimum ▁ number ▁ of ▁ chocolates ▁ = ▁ % d \" , minChocolates ( a , n ) ) ; return 0 ; }"}
{"text": "Program untuk mencari jumlah siri harmonik | Program C untuk mencari jumlah siri harmonik; Fungsi untuk mengembalikan jumlah siri harmonik; Kod pemacu", "code": "#include <stdio.h> NEW_LINE double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } int main ( ) { int n = 5 ; printf ( \" Sum ▁ is ▁ % f \" , sum ( n ) ) ; return 0 ; }"}
{"text": "Cari istilah n Siri 5 2 13 41 | Program c untuk mencari istilah n Siri 5 2 13 41; fungsi untuk mengira istilah ke siri; untuk menyimpan istilah siri nth; jika n adalah nombor juga; jika n adalah nombor ganjil; kembali istilah n; Kod pemacu", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE int nthTermOfTheSeries ( int n ) { int nthTerm ; if ( n % 2 == 0 ) nthTerm = pow ( n - 1 , 2 ) + n ; else nthTerm = pow ( n + 1 , 2 ) + n ; return nthTerm ; } int main ( ) { int n ; n = 8 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 12 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 102 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 999 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 9999 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; return 0 ; }"}
{"text": "Logaritma | Program c untuk mencari log (n) menggunakan rekursi; Kod pemacu", "code": "#include <stdio.h> NEW_LINE unsigned int Log2n ( unsigned int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; } int main ( ) { unsigned int n = 32 ; printf ( \" % u \" , Log2n ( n ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari jumlah yang akan ditambah untuk mencapai nisbah sasaran dalam campuran yang diberikan | Program C untuk mencari jumlah air yang akan ditambah untuk mencapai nisbah sasaran yang diberikan. ; Kod pemacu", "code": "#include <stdio.h> NEW_LINE float findAmount ( float X , float W , float Y ) { return ( X * ( Y - W ) ) / ( 100 - Y ) ; } int main ( ) { float X = 100 , W = 50 , Y = 60 ; printf ( \" Water ▁ to ▁ be ▁ added ▁ = ▁ % .2f ▁ \" , findAmount ( X , W , Y ) ) ; return 0 ; }"}
{"text": "Purata Squares of Natural Number | Program C untuk mendapatkan purata kuadrat nombor semulajadi N pertama; Berfungsi untuk mendapatkan purata; Kod pemacu", "code": "#include <stdio.h> NEW_LINE float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } int main ( ) { int n = 10 ; printf ( \" % f \" , AvgofSquareN ( n ) ) ; return 0 ; }"}
{"text": "Program untuk mencetak siri nombor segitiga sehingga n | C program untuk mencari siri nombor segi tiga; Berfungsi untuk mencari nombor segi tiga; Fungsi yang didorong", "code": "#include <stdio.h> NEW_LINE void triangular_series ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) printf ( \" ▁ % d ▁ \" , i * ( i + 1 ) / 2 ) ; } int main ( ) { int n = 5 ; triangular_series ( n ) ; return 0 ; }"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | C program untuk mencari jumlah semua pembahagi nombor sehingga 'n'; Fungsi utiliti untuk mencari jumlah semua pembahagi nombor sehingga 'n'; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; } int main ( ) { int n = 4 ; printf ( \" % d STRNEWLINE \" , divisorSum ( n ) ) ; n = 5 ; printf ( \" % d \" , divisorSum ( n ) ) ; return 0 ; }"}
{"text": "Jumlah siri 1 + x / 1 + x ^ 2/2 + x ^ 3/3 +. . + x ^ n / n | C Program untuk mencari jumlah siri 1 + x / 1 + x ^ 2/2 + x ^ 3/3 + .... + x ^ n / n; Kod untuk mencetak jumlah siri; Kod pemacu", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE double sum ( int x , int n ) { double i , total = 1.0 ; for ( i = 1 ; i <= n ; i ++ ) total = total + ( pow ( x , i ) / i ) ; return total ; } int main ( ) { int x = 2 ; int n = 5 ; printf ( \" % .2f \" , sum ( x , n ) ) ; return 0 ; }"}
{"text": "Cari sama ada integer yang diberikan adalah kuasa 3 atau tidak | Program C ++ untuk memeriksa sama ada nombor adalah kuasa 3 atau tidak. ; Pulangan benar jika n adalah kuasa 3, lain -lain palsu; Kuasa maksimum 3 nilai yang dapat dipegang integer ialah 1162261467 (3 ^ 19). ; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdbool.h> NEW_LINE bool check ( int n ) { if ( n <= 0 ) return false ; return 1162261467 % n == 0 ; } int main ( ) { int n = 9 ; if ( check ( n ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Program untuk nombor Perrin | Program C dioptimumkan untuk nombor n 'th Perrin; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int per ( int n ) { int a = 3 , b = 0 , c = 2 , i ; int m ; if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return c ; while ( n > 2 ) { m = a + b ; a = b ; b = c ; c = m ; n -- ; } return m ; } int main ( ) { int n = 9 ; printf ( \" % d \" , per ( n ) ) ; return 0 ; }"}
{"text": "Semak sama ada Count of Divisors adalah atau ganjil | Penyelesaian naif untuk mencari sama ada Count of Divisors bahkan atau ganjil; Berfungsi untuk mengira pembahagi; Memulakan kiraan pembahagi; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi adalah jumlah kenaikan yang sama dengan satu kiraan kenaikan sebaliknya sebanyak 2; Kod pemacu", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE void countDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i <= sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) count += ( n / i == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) printf ( \" Even STRNEWLINE \" ) ; else printf ( \" Odd STRNEWLINE \" ) ; } int main ( ) { printf ( \" The ▁ count ▁ of ▁ divisor : ▁ \" ) ; countDivisors ( 10 ) ; return 0 ; }"}
{"text": "Bagaimana untuk mengelakkan limpahan dalam pendaraban modular? | Penyelesaian mudah yang menyebabkan limpahan apabila nilai (mod %) * (mod B %) menjadi lebih daripada nilai maksimum int yang panjang", "code": "#define ll  long long NEW_LINE ll multiply ( ll a , ll b , ll mod ) { return ( ( a % mod ) * ( b % mod ) ) % mod ; }"}
{"text": "Kira nombor kuadrat dalam segi empat tepat | Program C untuk mengira dataran dalam segi empat tepat saiz m x n; Mengembalikan kiraan semua dataran dalam segi empat tepat saiz m x n; Jika n lebih kecil, swap m dan n; Sekarang n adalah dimensi yang lebih besar, gunakan formula; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int countSquares ( int m , int n ) { int temp ; if ( n < m ) { temp = n ; n = m ; m = temp ; } return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; } int main ( ) { int m = 4 , n = 3 ; printf ( \" Count ▁ of ▁ squares ▁ is ▁ % d \" , countSquares ( m , n ) ) ; }"}
{"text": "Program untuk mencari jumlah siri 1 + 1/2 + 1/3 + 1/4 +. . + 1 / n | Program C untuk mencari jumlah siri; Fungsi untuk mengembalikan jumlah 1/1 + 1/2 + 1/3 +. . + 1 / n; Kod pemacu", "code": "#include <stdio.h> NEW_LINE double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } int main ( ) { int n = 5 ; printf ( \" Sum ▁ is ▁ % f \" , sum ( n ) ) ; return 0 ; }"}
{"text": "Program untuk mencari GCD atau HCF dua nombor | C program untuk mencari GCD dua nombor; Fungsi rekursif untuk mengembalikan GCD A dan B; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int main ( ) { int a = 98 , b = 56 ; printf ( \" GCD ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "Cetak semua urutan panjang yang diberikan | C ++ program pendekatan di atas; Fungsi utiliti yang mencetak saiz panjang yang diberikan; Fungsi teras yang menghasilkan dan mencetak semua urutan panjang k; Fungsi yang menggunakan PrintSeSeenceRecur () untuk mencetak semua urutan dari 1, 1 ,. .1 hingga n, n ,. . n; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; return ; } void printSequencesRecur ( int arr [ ] , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } } void printSequences ( int n , int k ) { int * arr = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; } int main ( ) { int n = 3 ; int k = 2 ; printSequences ( n , k ) ; return 0 ; }"}
{"text": "Semak jika nombor adalah berganda 5 tanpa menggunakan / dan % operator | Program C untuk pendekatan di atas; menganggap bahawa n adalah integer positif; Kod pemacu", "code": "#include <stdio.h> NEW_LINE bool isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; } int main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) printf ( \" % d ▁ is ▁ multiple ▁ of ▁ 5 STRNEWLINE \" , n ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ multiple ▁ of ▁ 5 STRNEWLINE \" , n ) ; return 0 ; }"}
{"text": "Kira jumlah bit dalam nombor | Berfungsi untuk mendapatkan bit dalam perwakilan binari integer positif; Program Pemandu", "code": "#include <stdio.h> NEW_LINE unsigned int countBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; } int main ( ) { int i = 65 ; printf ( \" % d \" , countBits ( i ) ) ; return 0 ; }"}
{"text": "Cari n | Program C untuk mencari nombor n - yang perwakilan binari adalah palindrome. ; Cari jika bit kth ditetapkan dalam perwakilan binari; Mengembalikan kedudukan bit set kiri dalam perwakilan binari; Mendapati sama ada integer dalam perwakilan binari adalah palindrome atau tidak; Satu demi satu membandingkan bit; Bandingkan bit kiri dan kanan dan berkumpul; Bermula dari 1, melintasi semua bilangan bulat; Jika kita mencapai n, pecahkan gelung; Kod pemacu; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #define INT_MAX  2147483647 NEW_LINE int isKthBitSet ( int x , int k ) { return ( x & ( 1 << ( k - 1 ) ) ) ? 1 : 0 ; } int leftmostSetBit ( int x ) { int count = 0 ; while ( x ) { count ++ ; x = x >> 1 ; } return count ; } int isBinPalindrome ( int x ) { int l = leftmostSetBit ( x ) ; int r = 1 ; while ( l > r ) { if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; } int findNthPalindrome ( int n ) { int pal_count = 0 ; int i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) ) { pal_count ++ ; } if ( pal_count == n ) break ; } return i ; } int main ( ) { int n = 9 ; printf ( \" % d \" , findNthPalindrome ( n ) ) ; }"}
{"text": "Pengendali Bitwise dalam C / C ++ | Program C untuk menunjukkan penggunaan pengendali bitwise; A = 5 (00000101), b = 9 (00001001); Hasilnya ialah 00000001; Hasilnya ialah 00001101; Hasilnya ialah 00001100; Hasilnya ialah 11111010; Hasilnya ialah 00010010; Hasilnya ialah 00000100", "code": "#include <stdio.h> NEW_LINE int main ( ) { unsigned char a = 5 , b = 9 ; printf ( \" a ▁ = ▁ % d , ▁ b ▁ = ▁ % d STRNEWLINE \" , a , b ) ; printf ( \" a & b ▁ = ▁ % d STRNEWLINE \" , a & b ) ; printf ( \" a ▁ b ▁ = ▁ % d STRNEWLINE \" , a b ) ; printf ( \" a ^ b ▁ = ▁ % d STRNEWLINE \" , a ^ b ) ; printf ( \" ~ a ▁ = ▁ % d STRNEWLINE \" , a = ~ a ) ; printf ( \" b < < 1 ▁ = ▁ % d STRNEWLINE \" , b << 1 ) ; printf ( \" b > > 1 ▁ = ▁ % d STRNEWLINE \" , b >> 1 ) ; return 0 ; }"}
{"text": "Tukar suhu yang diberikan kepada sistem lain berdasarkan titik mendidih dan pembekuan yang diberikan | Program C untuk pendekatan di atas; Berfungsi untuk mengembalikan suhu di termometer kedua; Hitung suhu; Kod pemacu", "code": "#include <stdio.h> NEW_LINE double temp_convert ( int F1 , int B1 , int F2 , int B2 , int T ) { float t2 ; t2 = F2 + ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; } int main ( ) { int F1 = 0 , B1 = 100 ; int F2 = 32 , B2 = 212 ; int T = 37 ; float t2 ; printf ( \" % .2f \" , temp_convert ( F1 , B1 , F2 , B2 , T ) ) ; return 0 ; }"}
{"text": "Tulis program untuk mencari kedalaman maksimum atau ketinggian pokok |  ; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Kirakan \"maxdepth\" pokok - bilangan nod di sepanjang jalan terpanjang dari nod akar ke nod daun terjauh. ; Kirakan kedalaman setiap subtree; gunakan yang lebih besar; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int maxDepth ( struct node * node ) { if ( node == NULL ) return 0 ; else { int lDepth = maxDepth ( node -> left ) ; int rDepth = maxDepth ( node -> right ) ; if ( lDepth > rDepth ) return ( lDepth + 1 ) ; else return ( rDepth + 1 ) ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Height ▁ of ▁ tree ▁ is ▁ % d \" , maxDepth ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Bagaimana untuk menentukan sama ada pokok binari adalah ketinggian | Program C untuk memeriksa sama ada pokok adalah ketinggian - seimbang atau tidak; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Mengembalikan ketinggian pokok binari; Pulangan benar jika pokok binari dengan akar sebagai akar adalah ketinggian - seimbang; untuk ketinggian subtree kiri; untuk ketinggian subtree kanan; Jika pokok kosong maka kembali benar; Dapatkan ketinggian pokok sub kiri dan kanan; Jika kita sampai di sini maka pokok tidak ketinggian - seimbang; mengembalikan maksimum dua bilangan bulat; Fungsi ini mengira \"ketinggian\" pokok. Ketinggian adalah bilangan nod di sepanjang jalan terpanjang dari nod akar ke nod daun terjauh. ; Pokok kes asas kosong; Jika pokok tidak kosong maka ketinggian = 1 + maksimum ketinggian kiri dan ketinggian kanan; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define bool  int NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int height ( struct node * node ) ; bool isBalanced ( struct node * root ) { int lh ; int rh ; if ( root == NULL ) return 1 ; lh = height ( root -> left ) ; rh = height ( root -> right ) ; if ( abs ( lh - rh ) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ) ) return 1 ; return 0 ; } int max ( int a , int b ) { return ( a >= b ) ? a : b ; } int height ( struct node * node ) { if ( node == NULL ) return 0 ; return 1 + max ( height ( node -> left ) , height ( node -> right ) ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> left -> left = newNode ( 8 ) ; if ( isBalanced ( root ) ) printf ( \" Tree ▁ is ▁ balanced \" ) ; else printf ( \" Tree ▁ is ▁ not ▁ balanced \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Diameter pokok binari | Program C dioptimumkan Rekursif untuk mencari diameter pokok binari; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; mengembalikan maksimum dua bilangan bulat; Fungsi ini mengira \"ketinggian\" pokok. Ketinggian adalah nombor f nod di sepanjang laluan terpanjang dari nod akar ke nod daun terjauh. ; Pokok kes asas kosong; Jika pokok tidak kosong maka ketinggian = 1 + maksimum ketinggian kiri dan ketinggian kanan; Berfungsi untuk mendapatkan diameter pokok binari; Kes asas di mana pokok kosong; Dapatkan ketinggian pokok kiri dan kanan; Dapatkan diameter sub -pokok kiri dan kanan; Kembali max berikut tiga 1) diameter subtree kiri 2) diameter subtree kanan 3) ketinggian subtree kiri + ketinggian subtree kanan + 1; Kod pemacu; Pokok binari yang dibina ialah 1 / \\ 2 3 / \\ 4 5; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } int height ( struct node * node ) { if ( node == NULL ) return 0 ; return 1 + max ( height ( node -> left ) , height ( node -> right ) ) ; } int diameter ( struct node * tree ) { if ( tree == NULL ) return 0 ; int lheight = height ( tree -> left ) ; int rheight = height ( tree -> right ) ; int ldiameter = diameter ( tree -> left ) ; int rdiameter = diameter ( tree -> right ) ; return max ( lheight + rheight + 1 , max ( ldiameter , rdiameter ) ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Diameter ▁ of ▁ the ▁ given ▁ binary ▁ tree ▁ is ▁ % d STRNEWLINE \" , diameter ( root ) ) ; return 0 ; }"}
{"text": "Cari jika mungkin untuk melawat setiap nod dalam graf yang diberikan tepat sekali berdasarkan syarat -syarat yang diberikan | Program C ++ untuk pendekatan di atas. ; Berfungsi untuk mencari jalan cetak; Jika a [0] adalah 1; Jalan percetakan; Mencari [i] = 0 dan A [i + 1] = 1; Jalan percetakan; Jika a [n - 1] = 0; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findpath ( int N , int a [ ] ) { if ( a [ 0 ] ) { printf ( \" % d ▁ \" , N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , i ) ; return ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ! a [ i ] && a [ i + 1 ] ) { for ( int j = 1 ; j <= i ; j ++ ) printf ( \" % d ▁ \" , j ) ; printf ( \" % d ▁ \" , N + 1 ) ; for ( int j = i + 1 ; j <= N ; j ++ ) printf ( \" % d ▁ \" , j ) ; return ; } } for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , i ) ; printf ( \" % d ▁ \" , N + 1 ) ; } int main ( ) { int N = 3 , arr [ ] = { 0 , 1 , 0 } ; findpath ( N , arr ) ; }"}
{"text": "Cari kedalaman nod daun tahap ganjil yang paling dalam | Program C untuk mencari kedalaman nod daun tahap ganjil yang paling dalam; Fungsi utiliti untuk mencari maksimum dua bilangan bulat; Nod pokok binari; Fungsi utiliti untuk memperuntukkan nod pokok baru; Fungsi rekursif untuk mencari kedalaman daun tahap ganjil yang paling dalam; Kes asas; Jika nod ini adalah daun dan tahapnya ganjil, kembalikan tahapnya; Jika tidak daun, kembalikan nilai maksimum dari subtrees kiri dan kanan; Fungsi utama yang mengira kedalaman daun tahap ganjil yang paling dalam. Fungsi ini terutamanya menggunakan Depthofoddleafutil (); Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int max ( int x , int y ) { return ( x > y ) ? x : y ; } struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } int depthOfOddLeafUtil ( struct Node * root , int level ) { if ( root == NULL ) return 0 ; if ( root -> left == NULL && root -> right == NULL && level & 1 ) return level ; return max ( depthOfOddLeafUtil ( root -> left , level + 1 ) , depthOfOddLeafUtil ( root -> right , level + 1 ) ) ; } int depthOfOddLeaf ( struct Node * root ) { int level = 1 , depth = 0 ; return depthOfOddLeafUtil ( root , level ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 8 ) ; root -> right -> left -> right -> left = newNode ( 9 ) ; root -> right -> right -> right -> right = newNode ( 10 ) ; root -> right -> right -> right -> right -> left = newNode ( 11 ) ; printf ( \" % d ▁ is ▁ the ▁ required ▁ depth STRNEWLINE \" , depthOfOddLeaf ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Menyusun semula array sedemikian rupa sehingga jumlah separuh kiri tidak sama dengan jumlah separuh kanan | Program C untuk pendekatan di atas; Fungsi komparator yang digunakan oleh QSORT; Berfungsi untuk mencetak penyusunan semula susunan yang diperlukan jika boleh; Menyusun array dalam peningkatan urutan; Jika semua elemen adalah sama, maka tidak mungkin; Lain cetak array yang disusun arr []; Kod pemacu; Diberikan array; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int compare ( const void * a , const void * b ) { return ( * ( int * ) a - * ( int * ) b ) ; } void printArr ( int arr [ ] , int n ) { qsort ( arr , n , sizeof ( int ) , compare ) ; if ( arr [ 0 ] == arr [ n - 1 ] ) { printf ( \" No STRNEWLINE \" ) ; } else { printf ( \" Yes STRNEWLINE \" ) ; for ( int i = 0 ; i < n ; i ++ ) { printf ( \" % d ▁ \" , arr [ i ] ) ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 1 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printArr ( arr , N ) ; return 0 ; }"}
{"text": "Lebar maksimum pokok binari | Program C untuk mengira lebar pokok binari; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi protoypes; Berfungsi untuk mendapatkan lebar maksimum pokok binari; Dapatkan lebar setiap peringkat dan bandingkan lebar dengan lebar maksimum setakat ini; Dapatkan lebar tahap tertentu; Kirakan \"ketinggian\" pokok - bilangan nod di sepanjang laluan terpanjang dari nod akar ke nod daun terjauh. ; Kirakan ketinggian setiap subtree; gunakan yang lebih besar; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Kod pemacu; Pokok binari yang dibina adalah: 1 / \\ 2 3 / \\ 4 5 8 / \\ 6 7; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int getWidth ( struct node * root , int level ) ; int height ( struct node * node ) ; struct node * newNode ( int data ) ; int getMaxWidth ( struct node * root ) { int maxWidth = 0 ; int width ; int h = height ( root ) ; int i ; for ( i = 1 ; i <= h ; i ++ ) { width = getWidth ( root , i ) ; if ( width > maxWidth ) maxWidth = width ; } return maxWidth ; } int getWidth ( struct node * root , int level ) { if ( root == NULL ) return 0 ; if ( level == 1 ) return 1 ; else if ( level > 1 ) return getWidth ( root -> left , level - 1 ) + getWidth ( root -> right , level - 1 ) ; } int height ( struct node * node ) { if ( node == NULL ) return 0 ; else { int lHeight = height ( node -> left ) ; int rHeight = height ( node -> right ) ; return ( lHeight > rHeight ) ? ( lHeight + 1 ) : ( rHeight + 1 ) ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 6 ) ; root -> right -> right -> right = newNode ( 7 ) ; printf ( \" Maximum ▁ width ▁ is ▁ % d ▁ STRNEWLINE \" , getMaxWidth ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Lebar maksimum pokok binari | Program C untuk mengira lebar pokok binari; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi utiliti untuk mendapatkan ketinggian pokok binari; Berfungsi untuk mendapatkan lebar maksimum pokok binari; Buat array yang akan menyimpan kiraan nod di setiap peringkat; Isi array kiraan menggunakan preorder traversal; Mengembalikan nilai maksimum dari array kiraan; Fungsi yang mengisi array kiraan dengan kiraan nod di setiap peringkat pokok binari yang diberikan; Kirakan \"ketinggian\" pokok - bilangan nod di sepanjang laluan terpanjang dari nod akar ke nod daun terjauh. ; Kirakan ketinggian setiap subtree; gunakan yang lebih besar; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Mengembalikan nilai maksimum dari array kiraan; Program pemacu untuk menguji fungsi di atas; Pokok Bunary yang dibina adalah: 1 / \\ 2 3 / \\ 4 5 8 / \\ 6 7", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int height ( struct node * node ) ; struct node * newNode ( int data ) ; int getMax ( int arr [ ] , int n ) ; void getMaxWidthRecur ( struct node * root , int count [ ] , int level ) ; int getMaxWidth ( struct node * root ) { int width ; int h = height ( root ) ; int * count = ( int * ) calloc ( sizeof ( int ) , h ) ; int level = 0 ; getMaxWidthRecur ( root , count , level ) ; return getMax ( count , h ) ; } void getMaxWidthRecur ( struct node * root , int count [ ] , int level ) { if ( root ) { count [ level ] ++ ; getMaxWidthRecur ( root -> left , count , level + 1 ) ; getMaxWidthRecur ( root -> right , count , level + 1 ) ; } } int height ( struct node * node ) { if ( node == NULL ) return 0 ; else { int lHeight = height ( node -> left ) ; int rHeight = height ( node -> right ) ; return ( lHeight > rHeight ) ? ( lHeight + 1 ) : ( rHeight + 1 ) ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 6 ) ; root -> right -> right -> right = newNode ( 7 ) ; printf ( \" Maximum ▁ width ▁ is ▁ % d ▁ STRNEWLINE \" , getMaxWidth ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program untuk mengira nod daun dalam pokok binari | C pelaksanaan untuk mencari kiraan daun pokok binari yang diberikan; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Berfungsi untuk mendapatkan kiraan nod daun dalam pokok binari; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Program pemacu untuk menguji fungsi di atas; buat pokok; Dapatkan kiraan daun pokok yang dibuat di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; unsigned int getLeafCount ( struct node * node ) { if ( node == NULL ) return 0 ; if ( node -> left == NULL && node -> right == NULL ) return 1 ; else return getLeafCount ( node -> left ) + getLeafCount ( node -> right ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Leaf ▁ count ▁ of ▁ the ▁ tree ▁ is ▁ % d \" , getLeafCount ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Algoritma tamak untuk mencari bilangan syiling minimum | Program C untuk mencari bilangan denominasi minimum; Semua denominasi mata wang India; Memulakan hasil; Melintasi semua denominasi; Cari denominasi; Hasil cetak; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define COINS  9 NEW_LINE #define MAX  20 NEW_LINE int coins [ COINS ] = { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 , 2000 } ; void findMin ( int cost ) { int coinList [ MAX ] = { 0 } ; int i , k = 0 ; for ( i = COINS - 1 ; i >= 0 ; i -- ) { while ( cost >= coins [ i ] ) { cost -= coins [ i ] ; coinList [ k ++ ] = coins [ i ] ; } } for ( i = 0 ; i < k ; i ++ ) { printf ( \" % d ▁ \" , coinList [ i ] ) ; } return ; } int main ( void ) { int n = 93 ; printf ( \" Following ▁ is ▁ minimal ▁ number \" \" of ▁ change ▁ for ▁ % d : ▁ \" , n ) ; findMin ( n ) ; return 0 ; }"}
{"text": "Sambungkan nod pada tahap yang sama menggunakan ruang tambahan yang berterusan | Program Cerative C untuk menyambungkan nod pada tahap yang sama menggunakan ruang tambahan yang berterusan; Pembina yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Fungsi ini mengembalikan anak paling kiri nod pada tahap yang sama seperti p. Fungsi ini digunakan untuk mendapatkan hak anak yang betul jika anak yang betul adalah null maka ini juga boleh digunakan untuk anak kiri; Melintasi nod pada tahap p 'dan »mencari» kembali ~ »» »anak pertama yang pertama; Jika semua nod pada tahap P adalah nod daun maka kembali null; Menetapkan ketetapan semua nod pokok dengan akar sebagai p; Tetapkan nextright untuk root; Tetapkan ketetapan semua peringkat satu demi satu; Sambungkan semua nod kanak -kanak P dan kanak -kanak nod dari semua nod lain pada tahap yang sama seperti P; Tetapkan penunjuk nextright untuk anak kiri P; Sekiranya Q mempunyai anak yang betul, maka anak yang betul adalah ketat p dan kita juga perlu menetapkan anak -anak yang betul; Tetapkan nextright untuk nod lain dalam fesyen pra -pesanan; bermula dari nod pertama tahap seterusnya; Program pemacu untuk menguji fungsi di atas; Pokok binari yang dibina ialah 10 / \\ 8 2 / \\ 3 90; Populates penunjuk nextright dalam semua nod; Marilah kita periksa nilai penunjuk nextright", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; struct node * nextRight ; } ; struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> nextRight = NULL ; return ( node ) ; } struct node * getNextRight ( struct node * p ) { struct node * temp = p -> nextRight ; while ( temp != NULL ) { if ( temp -> left != NULL ) return temp -> left ; if ( temp -> right != NULL ) return temp -> right ; temp = temp -> nextRight ; } return NULL ; } void connect ( struct node * p ) { struct node * temp ; if ( ! p ) return ; p -> nextRight = NULL ; while ( p != NULL ) { struct node * q = p ; while ( q != NULL ) { if ( q -> left ) { if ( q -> right ) q -> left -> nextRight = q -> right ; else q -> left -> nextRight = getNextRight ( q ) ; } if ( q -> right ) q -> right -> nextRight = getNextRight ( q ) ; q = q -> nextRight ; } if ( p -> left ) p = p -> left ; else if ( p -> right ) p = p -> right ; else p = getNextRight ( p ) ; } } int main ( ) { struct node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ; root -> right -> right = newnode ( 90 ) ; connect ( root ) ; printf ( \" Following ▁ are ▁ populated ▁ nextRight ▁ pointers ▁ in ▁ the ▁ tree ▁ \" \" ( -1 ▁ is ▁ printed ▁ if ▁ there ▁ is ▁ no ▁ nextRight ) ▁ STRNEWLINE \" ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> data , root -> nextRight ? root -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> left -> data , root -> left -> nextRight ? root -> left -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> right -> data , root -> right -> nextRight ? root -> right -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> left -> left -> data , root -> left -> left -> nextRight ? root -> left -> left -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> right -> right -> data , root -> right -> right -> nextRight ? root -> right -> right -> nextRight -> data : -1 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Sambungkan nod pada tahap yang sama | Program C untuk menyambungkan nod pada tahap yang sama menggunakan traversal pra -perintah yang dilanjutkan; Nod pokok binari; Menetapkan ketetapan akar dan panggilan ConnectRecur () untuk nod lain; Tetapkan Nextright untuk Root; Tetapkan hak seterusnya untuk selebihnya nod (selain akar); Tetapkan hak seterusnya dari semua keturunan p. Asumsi: P adalah pokok binari bersaing; Kes asas; Tetapkan penunjuk nextright untuk anak kiri P; Tetapkan penunjuk nextright untuk kanak-kanak kanan p-> nextright akan menjadi batal jika p adalah anak yang paling tepat pada tahapnya; Tetapkan nextright untuk nod lain dalam fesyen pra -pesanan; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Program pemacu untuk menguji fungsi di atas; Pokok binari yang dibina ialah 10 / \\ 8 2/3; Populates penunjuk nextright dalam semua nod; Marilah kita periksa nilai penunjuk nextright", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void connectRecur ( struct node * p ) ; struct node { int data ; struct node * left ; struct node * right ; struct node * nextRight ; } ; void connect ( struct node * p ) { p -> nextRight = NULL ; connectRecur ( p ) ; } void connectRecur ( struct node * p ) { if ( ! p ) return ; if ( p -> left ) p -> left -> nextRight = p -> right ; if ( p -> right ) p -> right -> nextRight = ( p -> nextRight ) ? p -> nextRight -> left : NULL ; connectRecur ( p -> left ) ; connectRecur ( p -> right ) ; } struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> nextRight = NULL ; return ( node ) ; } int main ( ) { struct node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ; connect ( root ) ; printf ( \" Following ▁ are ▁ populated ▁ nextRight ▁ pointers ▁ in ▁ the ▁ tree ▁ \" \" ( -1 ▁ is ▁ printed ▁ if ▁ there ▁ is ▁ no ▁ nextRight ) ▁ STRNEWLINE \" ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> data , root -> nextRight ? root -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> left -> data , root -> left -> nextRight ? root -> left -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> right -> data , root -> right -> nextRight ? root -> right -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> left -> left -> data , root -> left -> left -> nextRight ? root -> left -> left -> nextRight -> data : -1 ) ; return 0 ; }"}
{"text": "Sisipan minimum untuk membentuk palindrome | DP | Program rekursif naif untuk mencari sisipan nombor minimum yang diperlukan untuk membuat palindrome rentetan; Fungsi utiliti untuk mencari minimum dua nombor; Fungsi rekursif untuk mencari bilangan sisipan minimum; Kes asas; Semak sama ada aksara pertama dan terakhir adalah sama. Berdasarkan hasil perbandingan, tentukan subrpoplem mana yang hendak dipanggil; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; } int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; } int main ( ) { char str [ ] = \" geeks \" ; printf ( \" % d \" , findMinInsertions ( str , 0 , strlen ( str ) - 1 ) ) ; return 0 ; }"}
{"text": "Palindromik Palindromik Terpanjang | DP | C Program pendekatan di atas; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Mengembalikan panjang Palindromic yang paling lama di SEQ; Kes asas 1: Jika hanya ada 1 aksara; Kes asas 2: Jika hanya terdapat 2 aksara dan kedua -duanya sama; Jika watak pertama dan terakhir sepadan; Jika watak pertama dan terakhir tidak sepadan; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int max ( int x , int y ) { return ( x > y ) ? x : y ; } int lps ( char * seq , int i , int j ) { if ( i == j ) return 1 ; if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ; if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ; return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } int main ( ) { char seq [ ] = \" GEEKSFORGEEKS \" ; int n = strlen ( seq ) ; printf ( \" The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d \" , lps ( seq , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Dapatkan tahap nod dalam pokok binari | Program C untuk mendapatkan tahap nod dalam pokok binari; Struktur nod pokok; Fungsi penolong untuk getLevel (). Ia mengembalikan tahap data jika data hadir di dalam pokok, jika tidak pulangan 0 .; Pulangan tahap nilai data yang diberikan; Fungsi utiliti untuk membuat nod pokok binari baru; Kod pemacu; Membina pokok yang diberikan dalam angka di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int getLevelUtil ( struct node * node , int data , int level ) { if ( node == NULL ) return 0 ; if ( node -> data == data ) return level ; int downlevel = getLevelUtil ( node -> left , data , level + 1 ) ; if ( downlevel != 0 ) return downlevel ; downlevel = getLevelUtil ( node -> right , data , level + 1 ) ; return downlevel ; } int getLevel ( struct node * node , int data ) { return getLevelUtil ( node , data , 1 ) ; } struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int main ( ) { struct node * root ; int x ; root = newNode ( 3 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; for ( x = 1 ; x <= 5 ; x ++ ) { int level = getLevel ( root , x ) ; if ( level ) printf ( \" ▁ Level ▁ of ▁ % d ▁ is ▁ % d STRNEWLINE \" , x , getLevel ( root , x ) ) ; else printf ( \" ▁ % d ▁ is ▁ not ▁ present ▁ in ▁ tree ▁ STRNEWLINE \" , x ) ; } getchar ( ) ; return 0 ; }"}
{"text": "Algoritma automata terhingga untuk carian corak | Program C untuk algoritma corak corak automata terhingga; Jika watak C adalah sama dengan watak seterusnya dalam corak, maka hanya keadaan kenaikan; NS menyimpan hasil yang seterusnya; Mulakan dari nilai yang mungkin terbesar dan berhenti apabila anda mencari awalan yang juga akhiran; Fungsi ini membina jadual TF yang mewakili 4 automata terhingga untuk corak yang diberikan; Cetak semua kejadian Pat dalam TXT; Proses txt ke atas FA. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE int getNextState ( char * pat , int M , int state , int x ) { if ( state < M && x == pat [ state ] ) return state + 1 ; int ns , i ; for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] == x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) if ( pat [ i ] != pat [ state - ns + 1 + i ] ) break ; if ( i == ns - 1 ) return ns ; } } return 0 ; } void computeTF ( char * pat , int M , int TF [ ] [ NO_OF_CHARS ] ) { int state , x ; for ( state = 0 ; state <= M ; ++ state ) for ( x = 0 ; x < NO_OF_CHARS ; ++ x ) TF [ state ] [ x ] = getNextState ( pat , M , state , x ) ; } void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int TF [ M + 1 ] [ NO_OF_CHARS ] ; computeTF ( pat , M , TF ) ; int i , state = 0 ; for ( i = 0 ; i < N ; i ++ ) { state = TF [ state ] [ txt [ i ] ] ; if ( state == M ) printf ( \" Pattern found at index % d \" , i - M + 1 ) ; } } int main ( ) { char * txt = \" AABAACAADAABAAABAA \" ; char * pat = \" AABA \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Cari cermin nod yang diberikan dalam pokok binari | Program C untuk mencari nod cermin dalam pokok binari; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Buat nod baru dan mulakannya; fungsi rekursif untuk mencari cermin nod; Sekiranya mana -mana nod itu tidak ada nod sendiri dan lantang tidak mempunyai cermin, jadi kembali, tidak perlu lagi meneroka! ; Jika nod kiri adalah nod sasaran, maka kembali kunci kanan (iaitu cermin) dan sebaliknya; pertama berulang nod luar; Jika tiada cermin dijumpai, nod dalaman berulang; antara muka untuk carian cermin; Pemandu; nod sasaran yang cermin mesti dicari", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int key ; struct Node * left , * right ; } ; struct Node * newNode ( int key ) { struct Node * n = ( struct Node * ) malloc ( sizeof ( struct Node * ) ) ; if ( n != NULL ) { n -> key = key ; n -> left = NULL ; n -> right = NULL ; return n ; } else { printf ( \" Memory ▁ allocation ▁ failed ! \" ) ; exit ( 1 ) ; } } int findMirrorRec ( int target , struct Node * left , struct Node * right ) { if ( left == NULL right == NULL ) return 0 ; if ( left -> key == target ) return right -> key ; if ( right -> key == target ) return left -> key ; int mirror_val = findMirrorRec ( target , left -> left , right -> right ) ; if ( mirror_val ) return mirror_val ; findMirrorRec ( target , left -> right , right -> left ) ; } int findMirror ( struct Node * root , int target ) { if ( root == NULL ) return 0 ; if ( root -> key == target ) return target ; return findMirrorRec ( target , root -> left , root -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> left -> right = newNode ( 7 ) ; root -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> left = newNode ( 8 ) ; root -> right -> left -> right = newNode ( 9 ) ; int target = root -> left -> left -> key ; int mirror = findMirror ( root , target ) ; if ( mirror ) printf ( \" Mirror ▁ of ▁ Node ▁ % d ▁ is ▁ Node ▁ % d STRNEWLINE \" , target , mirror ) ; else printf ( \" Mirror ▁ of ▁ Node ▁ % d ▁ is ▁ NULL ! STRNEWLINE \" , target ) ; }"}
{"text": "Iteratif Mencari Kunci 'X' dalam Pokok Binari | Kaedah berasaskan Perintah Tahap Iteratif untuk mencari di pokok binari; Node pokok binari mempunyai data, anak kiri dan anak kanan; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Proses berulang untuk mencari elemen x dalam pokok binari yang diberikan; Kes asas; Buat giliran kosong untuk perintah tahap traversal; Akar enqueue dan memulakan ketinggian; Perintah Tahap Berdasarkan Perintah Traversal; Lihat jika nod semasa sama dengan x; Keluarkan nod semasa dan enqueue anak -anaknya; Program Pemandu", "code": "#include <iostream> NEW_LINE #include <queue> NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = new struct node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } bool iterativeSearch ( node * root , int x ) { if ( root == NULL ) return false ; queue < node * > q ; q . push ( root ) ; while ( q . empty ( ) == false ) { node * node = q . front ( ) ; if ( node -> data == x ) return true ; q . pop ( ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; } return false ; } int main ( void ) { struct node * NewRoot = NULL ; struct node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; iterativeSearch ( root , 6 ) ? cout << \" Found STRNEWLINE \" : cout << \" Not ▁ Found STRNEWLINE \" ; iterativeSearch ( root , 12 ) ? cout << \" Found STRNEWLINE \" : cout << \" Not ▁ Found STRNEWLINE \" ; return 0 ; }"}
{"text": "Populasi pengganti inorder untuk semua nod | C # Program untuk mengisi inorder traversal semua nod; Pelaksanaan yang tidak menggunakan pembolehubah statik pembungkus ke atas Populatenextrecur; Node pertama yang dilawati akan menjadi nod paling kanan di sebelah nod paling kanan akan menjadi batal; Tetapkan seterusnya dari semua keturunan P dengan melintasi mereka dalam inorder terbalik; Pertama tetapkan penunjuk seterusnya di subtree kanan; Tetapkan seterusnya seperti nod yang dilawati sebelumnya dalam inorder terbalik; Tukar sebelumnya untuk nod berikutnya; Akhirnya, tetapkan penunjuk seterusnya di subtree kanan", "code": "struct node { int data ; struct node * left ; struct node * right ; struct node * next ; } void populateNext ( struct node * root ) { struct node * next = NULL ; populateNextRecur ( root , & next ) ; } void populateNextRecur ( struct node * p , struct node * * next_ref ) { if ( p ) { populateNextRecur ( p -> right , next_ref ) ; p -> next = * next_ref ; * next_ref = p ; populateNextRecur ( p -> left , next_ref ) ; } }"}
{"text": "Memandangkan pokok binari, bagaimana anda mengeluarkan semua separuh nod? | C program untuk mengeluarkan semua separuh nod; Nod pokok binari;  ; Untuk traversal inorder; Membuang semua nod dengan hanya satu kanak -kanak dan mengembalikan akar baru (perhatikan bahawa akar boleh berubah); Jika nod semasa adalah setengah nod dengan anak kiri kiri kiri, maka anak kanannya dikembalikan dan menggantikannya di dalam pokok yang diberikan; Jika nod semasa adalah setengah nod dengan anak yang betul null kanan, maka anak yang betul itu dikembalikan dan menggantikannya di dalam pokok yang diberikan; Program Pemandu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void printInoder ( struct node * root ) { if ( root != NULL ) { printInoder ( root -> left ) ; printf ( \" % d ▁ \" , root -> data ) ; printInoder ( root -> right ) ; } } struct node * RemoveHalfNodes ( struct node * root ) { if ( root == NULL ) return NULL ; root -> left = RemoveHalfNodes ( root -> left ) ; root -> right = RemoveHalfNodes ( root -> right ) ; if ( root -> left == NULL && root -> right == NULL ) return root ; if ( root -> left == NULL ) { struct node * new_root = root -> right ; free ( root ) ; return new_root ; } if ( root -> right == NULL ) { struct node * new_root = root -> left ; free ( root ) ; return new_root ; } return root ; } int main ( void ) { struct node * NewRoot = NULL ; struct node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ given ▁ tree ▁ STRNEWLINE \" ) ; printInoder ( root ) ; NewRoot = RemoveHalfNodes ( root ) ; printf ( \" Inorder traversal of the modified tree \" printInoder ( NewRoot ) ; return 0 ; }"}
{"text": "Program untuk mencetak semua substrings rentetan yang diberikan | Program C untuk pendekatan di atas; OUTermalt untuk Loop Ini adalah untuk pemilihan titik permulaan; 2 nd untuk gelung adalah untuk pemilihan titik akhir; 3 RD Loop adalah untuk mencetak dari titik permulaan ke titik akhir; Menukar garis selepas mencetak dari titik permulaan ke titik akhir; Kod pemacu; Memanggil kaedah untuk mencetak substring", "code": "#include <stdio.h> NEW_LINE void printSubstrings ( char str [ ] ) { for ( int start = 0 ; str [ start ] != ' \\0' ; start ++ ) { for ( int end = start ; str [ end ] != ' \\0' ; end ++ ) { for ( int i = start ; i <= end ; i ++ ) { printf ( \" % c \" , str [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } } } int main ( ) { char str [ ] = { ' a ' , ' b ' , ' c ' , ' d ' , ' \\0' } ; printSubstrings ( str ) ; return 0 ; }"}
{"text": "Sudoku | Backtracking |  ; N ialah saiz matriks 2d n * n; Fungsi utiliti untuk mencetak grid; Memeriksa sama ada ia akan sah untuk memberikan NUM kepada baris yang diberikan, col; Semak jika kita dapati nombor yang sama dalam baris yang sama, kita kembali 0; Semak jika kita dapati NUM yang sama dalam lajur yang sama, kita kembali 0; Semak jika kita dapati NUM yang sama dalam matriks 3 * 3 tertentu, kita kembali 0; Mengambil sebahagiannya diisi - dalam grid dan cuba memberikan nilai kepada semua lokasi yang tidak ditugaskan sedemikian rupa untuk memenuhi keperluan untuk penyelesaian Sudoku (bukan duplikasi di seluruh baris, lajur, dan kotak); Semak jika kami telah mencapai baris ke -8 dan lajur ke -9 (0 Matriks diindeks), kami kembali benar untuk mengelakkan mundur lebih lanjut; Semak jika nilai lajur menjadi 9, kami bergerak ke baris dan lajur seterusnya bermula dari 0; Semak sama ada kedudukan semasa grid sudah mengandungi nilai> 0, kami melangkah untuk lajur seterusnya; Semak sama ada selamat untuk meletakkan NUM (1 - 9) dalam baris yang diberikan, col -> kami berpindah ke lajur seterusnya; Menetapkan NUM dalam kedudukan semasa (baris, col) grid dan mengandaikan NUM kami yang ditugaskan dalam kedudukan adalah betul; Memeriksa kemungkinan seterusnya dengan lajur seterusnya; Mengeluarkan NUM yang diberikan, kerana andaian kami salah, dan kami pergi untuk andaian seterusnya dengan nilai diff Num; 0 bermaksud sel yang tidak ditetapkan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define N  9 NEW_LINE void print ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( \" % d ▁ \" , arr [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } } int isSafe ( int grid [ N ] [ N ] , int row , int col , int num ) { for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ row ] [ x ] == num ) return 0 ; for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ x ] [ col ] == num ) return 0 ; int startRow = row - row % 3 , startCol = col - col % 3 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow ] [ j + startCol ] == num ) return 0 ; return 1 ; } int solveSuduko ( int grid [ N ] [ N ] , int row , int col ) { if ( row == N - 1 && col == N ) return 1 ; if ( col == N ) { row ++ ; col = 0 ; } if ( grid [ row ] [ col ] > 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( int num = 1 ; num <= N ; num ++ ) { if ( isSafe ( grid , row , col , num ) == 1 ) { grid [ row ] [ col ] = num ; if ( solveSuduko ( grid , row , col + 1 ) == 1 ) return 1 ; } grid [ row ] [ col ] = 0 ; } return 0 ; } int main ( ) { int grid [ N ] [ N ] = { { 3 , 0 , 6 , 5 , 0 , 8 , 4 , 0 , 0 } , { 5 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 8 , 7 , 0 , 0 , 0 , 0 , 3 , 1 } , { 0 , 0 , 3 , 0 , 1 , 0 , 0 , 8 , 0 } , { 9 , 0 , 0 , 8 , 6 , 3 , 0 , 0 , 5 } , { 0 , 5 , 0 , 0 , 9 , 0 , 6 , 0 , 0 } , { 1 , 3 , 0 , 0 , 0 , 0 , 2 , 5 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 4 } , { 0 , 0 , 5 , 2 , 0 , 6 , 3 , 0 , 0 } } ; if ( solveSuduko ( grid , 0 , 0 ) == 1 ) print ( grid ) ; else printf ( \" No ▁ solution ▁ exists \" ) ; return 0 ; }"}
{"text": "Subset Sum | Backtracking |  ; cetakan subset yang dijumpai; QSORT Bandingkan fungsi; input s - set vektor t - tuplet vector s_size - set saiz t_size - saiz tuplet setakat ini jumlahnya setakat ini - nod mengira sasaran_sum - jumlah yang dapat dijumpai; Kami menjumpai jumlah; pemeriksaan kekangan; Kecualikan item tambahan sebelumnya dan pertimbangkan calon seterusnya; pemeriksaan kekangan; menjana nod sepanjang keluasan; Pertimbangkan nod tahap seterusnya (sepanjang kedalaman); Pembalut yang mencetak subset yang jumlahnya ke target_sum; Susun set; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define ARRAYSIZE ( a )  (sizeof(a))/(sizeof(a[0])) NEW_LINE static int total_nodes ; void printSubset ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { printf ( \" % * d \" , 5 , A [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } int comparator ( const void * pLhs , const void * pRhs ) { int * lhs = ( int * ) pLhs ; int * rhs = ( int * ) pRhs ; return * lhs > * rhs ; } void subset_sum ( int s [ ] , int t [ ] , int s_size , int t_size , int sum , int ite , int const target_sum ) { total_nodes ++ ; if ( target_sum == sum ) { printSubset ( t , t_size ) ; if ( ite + 1 < s_size && sum - s [ ite ] + s [ ite + 1 ] <= target_sum ) { subset_sum ( s , t , s_size , t_size - 1 , sum - s [ ite ] , ite + 1 , target_sum ) ; } return ; } else { if ( ite < s_size && sum + s [ ite ] <= target_sum ) { for ( int i = ite ; i < s_size ; i ++ ) { t [ t_size ] = s [ i ] ; if ( sum + s [ i ] <= target_sum ) { subset_sum ( s , t , s_size , t_size + 1 , sum + s [ i ] , i + 1 , target_sum ) ; } } } } } void generateSubsets ( int s [ ] , int size , int target_sum ) { int * tuplet_vector = ( int * ) malloc ( size * sizeof ( int ) ) ; int total = 0 ; qsort ( s , size , sizeof ( int ) , & comparator ) ; for ( int i = 0 ; i < size ; i ++ ) { total += s [ i ] ; } if ( s [ 0 ] <= target_sum && total >= target_sum ) { subset_sum ( s , tuplet_vector , size , 0 , 0 , 0 , target_sum ) ; } free ( tuplet_vector ) ; } int main ( ) { int weights [ ] = { 15 , 22 , 14 , 26 , 32 , 9 , 16 , 8 } ; int target = 53 ; int size = ARRAYSIZE ( weights ) ; generateSubsets ( weights , size , target ) ; printf ( \" Nodes ▁ generated ▁ % d STRNEWLINE \" , total_nodes ) ; return 0 ; }"}
{"text": "Memandangkan array A [] dan nombor x, periksa pasangan dalam [] dengan jumlah sebagai x | Program C untuk memeriksa sama ada array yang diberikan mempunyai 2 elemen yang jumlahnya sama dengan nilai yang diberikan; berfungsi untuk memeriksa jumlah yang diberikan dalam array; memeriksa keadaan; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define MAX  100000 NEW_LINE void printPairs ( int arr [ ] , int arr_size , int sum ) { int i , temp ; bool s [ MAX ] = { 0 } ; for ( i = 0 ; i < arr_size ; i ++ ) { temp = sum - arr [ i ] ; if ( s [ temp ] == 1 ) printf ( \" Pair ▁ with ▁ given ▁ sum ▁ % d ▁ is ▁ ( % d , ▁ % d ) ▁ n \" , sum , arr [ i ] , temp ) ; s [ arr [ i ] ] = 1 ; } } int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int n = 16 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; printPairs ( A , arr_size , n ) ; getchar ( ) ; return 0 ; }"}
{"text": "Exponentiation Modular (Recursive) | Program C Rekursif untuk mengira kuasa modular; Kes asas; Jika B juga; Jika B adalah ganjil; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; } int main ( ) { int A = 2 , B = 5 , C = 13 ; printf ( \" Power ▁ is ▁ % d \" , exponentMod ( A , B , C ) ) ; return 0 ; }"}
{"text": "Exponentiation Modular (Kuasa dalam Aritmetik Modular) | Fungsi iteratif untuk mengira (x ^ y) dalam O (log y); Memulakan hasil; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y / 2; Tukar X ke X ^ 2", "code": "int power ( int x , unsigned int y ) { int res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }"}
{"text": "Teka -teki menjatuhkan telur | DP |  ; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Berfungsi untuk mendapatkan bilangan minimum ujian yang diperlukan dalam kes terburuk dengan telur N dan l lantai; Sekiranya tiada lantai, maka tiada ujian diperlukan. Atau jika terdapat satu lantai, satu percubaan diperlukan. ; Kami memerlukan ujian k untuk satu lantai telur dan k; Pertimbangkan semua kotoran dari lantai 1 ke lantai kth dan kembalikan minimum nilai -nilai ini ditambah 1 .; Kod pemacu", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int eggDrop ( int n , int k ) { if ( k == 1 k == 0 ) return k ; if ( n == 1 ) return k ; int min = INT_MAX , x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; } int main ( ) { int n = 2 , k = 10 ; printf ( \" nMinimum ▁ number ▁ of ▁ trials ▁ in ▁ \" \" worst ▁ case ▁ with ▁ % d ▁ eggs ▁ and ▁ \" \" % d ▁ floors ▁ is ▁ % d ▁ STRNEWLINE \" , n , k , eggDrop ( n , k ) ) ; return 0 ; }"}
{"text": "Pokok binari | Tetapkan 1 (Pengenalan) |  ; struct yang mengandungi anak kiri dan kanan nod semasa dan nilai utama; newNode () memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari maksimum (atau minimum) dalam pokok binari | Program C untuk mencari maksimum dan minimum dalam pokok binari; Nod pokok; Fungsi utiliti untuk membuat nod baru; Mengembalikan nilai maksimum dalam pokok binari yang diberikan; Kes asas; Pulangan maksimum 3 nilai: 1) Data Root 2) maksimum di subtree kiri 3) max di subtree kanan; Kod pemacu; Panggilan fungsi", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int findMax ( struct Node * root ) { if ( root == NULL ) return INT_MIN ; int res = root -> data ; int lres = findMax ( root -> left ) ; int rres = findMax ( root -> right ) ; if ( lres > res ) res = lres ; if ( rres > res ) res = rres ; return res ; } int main ( void ) { struct Node * NewRoot = NULL ; struct Node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; printf ( \" Maximum ▁ element ▁ is ▁ % d ▁ STRNEWLINE \" , findMax ( root ) ) ; return 0 ; }"}
{"text": "Cari maksimum (atau minimum) dalam pokok binari | Mengembalikan nilai minimum dalam pokok binari yang diberikan", "code": "int findMin ( struct Node * root ) { if ( root == NULL ) return INT_MAX ; int res = root -> data ; int lres = findMin ( root -> left ) ; int rres = findMin ( root -> right ) ; if ( lres < res ) res = lres ; if ( rres < res ) res = rres ; return res ; }"}
{"text": "Ekstrak daun pokok binari dalam senarai dikaitkan berganda | Program C untuk mengekstrak daun pokok binari dalam senarai dikaitkan dua kali ganda; Struktur untuk pokok dan senarai yang dipautkan; Fungsi utama yang mengekstrak semua daun dari pokok binari yang diberikan. Fungsi ini mengembalikan akar baru pokok binari (perhatikan bahawa akar boleh menukar pokok binari hanya mempunyai satu nod). Fungsi ini juga menetapkan * head_ref sebagai ketua senarai dikaitkan. Penunjuk kiri pokok digunakan seperti sebelumnya dalam DLL dan penunjuk kanan digunakan sebagai seterusnya; Fungsi utiliti untuk memperuntukkan nod untuk pokok binari. ; Fungsi utiliti untuk mencetak pokok di dalam - pesanan. ; Fungsi utiliti untuk mencetak senarai dikaitkan berganda. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * extractLeafList ( struct Node * root , struct Node * * head_ref ) { if ( root == NULL ) return NULL ; if ( root -> left == NULL && root -> right == NULL ) { root -> right = * head_ref ; if ( * head_ref != NULL ) ( * head_ref ) -> left = root ; return NULL ; } root -> right = extractLeafList ( root -> right , head_ref ) ; root -> left = extractLeafList ( root -> left , head_ref ) ; return root ; } struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } void print ( struct Node * root ) { if ( root != NULL ) { print ( root -> left ) ; printf ( \" % d ▁ \" , root -> data ) ; print ( root -> right ) ; } } void printList ( struct Node * head ) { while ( head ) { printf ( \" % d ▁ \" , head -> data ) ; head = head -> right ; } } int main ( ) { struct Node * head = NULL ; struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> left -> left -> left = newNode ( 7 ) ; root -> left -> left -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 9 ) ; root -> right -> right -> right = newNode ( 10 ) ; printf ( \" Inorder ▁ Trvaersal ▁ of ▁ given ▁ Tree ▁ is : STRNEWLINE \" ) ; print ( root ) ; root = extractLeafList ( root , & head ) ; printf ( \" Extracted Double Linked list is : \" printList ( head ) ; printf ( \" Inorder traversal of modified tree is : \" print ( root ) ; return 0 ; }"}
{"text": "Cari n | Program c untuk nod nth inorder traversals; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Memandangkan pokok binari, cetak node nod inorder; pertama berulang pada anak kiri; apabila kiraan = n kemudian cetak elemen; sekarang berulang pada anak yang betul; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void NthInorder ( struct Node * node , int n ) { static int count = 0 ; if ( node == NULL ) return ; if ( count <= n ) { NthInorder ( node -> left , n ) ; count ++ ; if ( count == n ) printf ( \" % d ▁ \" , node -> data ) ; NthInorder ( node -> right , n ) ; } } int main ( ) { struct Node * root = newNode ( 10 ) ; root -> left = newNode ( 20 ) ; root -> right = newNode ( 30 ) ; root -> left -> left = newNode ( 40 ) ; root -> left -> right = newNode ( 50 ) ; int n = 4 ; NthInorder ( root , n ) ; return 0 ; }"}
{"text": "Pengoptimuman panggilan ekor QuickSort (mengurangkan ruang kes terburuk untuk log n) | Pelaksanaan ringkas QuickSort yang menjadikan dua dua panggilan rekursif. ; PI adalah Indeks Partitioning, ARR [P] kini berada di tempat yang betul; Secara berasingan menyusun elemen sebelum partition dan selepas partition", "code": "void quickSort ( int arr [ ] , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; quickSort ( arr , low , pi - 1 ) ; quickSort ( arr , pi + 1 , high ) ; } }"}
{"text": "Kira semua rentetan yang mungkin dihasilkan dengan meletakkan ruang | Program C untuk melaksanakan pendekatan di atas; Fungsi untuk mengira bilangan rentetan yang boleh dihasilkan dengan meletakkan ruang antara sepasang aksara bersebelahan; Panjang rentetan; Kiraan kedudukan untuk ruang; Mengira kemungkinan rentetan; Kod pemacu", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #include <string.h> NEW_LINE long long int countNumberOfStrings ( char * s ) { int length = strlen ( s ) ; int n = length - 1 ; long long int count = pow ( 2 , n ) ; return count ; } int main ( ) { char S [ ] = \" ABCD \" ; printf ( \" % lld \" , countNumberOfStrings ( S ) ) ; return 0 ; }"}
{"text": "Ubah suai array yang diberikan untuk membuat jumlah elemen ganjil dan bahkan diindeks sama | Program C ++ untuk pendekatan di atas; Fungsi untuk mengubah suai array untuk membuat jumlah elemen ganjil dan bahkan diindeks sama; Menyimpan kiraan 0 s, 1 s; Kedai jumlah elemen ganjil dan juga diindeks; Kiraan 0 s; Kiraan 1 s; Kirakan ODD_SUM dan EVER_SUM; Jika kedua -duanya sama; Cetak array asal; Jika tidak; Cetak semua 0 s; Untuk memeriksa walaupun atau ganjil; Kemas kini jumlah kiraan 1 s; Cetak semua 1 s; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE void makeArraySumEqual ( int a [ ] , int N ) { int count_0 = 0 , count_1 = 0 ; int odd_sum = 0 , even_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; if ( ( i + 1 ) % 2 == 0 ) even_sum += a [ i ] ; else if ( ( i + 1 ) % 2 > 0 ) odd_sum += a [ i ] ; } if ( odd_sum == even_sum ) { for ( int i = 0 ; i < N ; i ++ ) printf ( \" % d ▁ \" , a [ i ] ) ; } else { if ( count_0 >= N / 2 ) { for ( int i = 0 ; i < count_0 ; i ++ ) printf ( \"0 ▁ \" ) ; } else { int is_Odd = count_1 % 2 ; count_1 -= is_Odd ; for ( int i = 0 ; i < count_1 ; i ++ ) printf ( \"1 ▁ \" ) ; } } } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; makeArraySumEqual ( arr , N ) ; return 0 ; }"}
{"text": "Count of N digit nombor yang jumlahnya setiap digit berturut -turut adalah sama | Program C untuk pendekatan di atas; Fungsi untuk mengira bilangan nombor n - digit sedemikian rupa sehingga jumlah setiap digit berturut -turut adalah sama; Pelbagai nombor; Ekstrak digit nombor; Simpan jumlah digit pertama; Semak setiap digit K - berturut -turut menggunakan tetingkap gelongsor; Kod pemacu; Diberikan integer n dan k", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE int countDigitSum ( int N , int K ) { int l = ( int ) pow ( 10 , N - 1 ) , r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; int digits [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ; for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( int j = K ; j < N ; j ++ ) { if ( sum - digits [ j - K ] + digits [ j ] != sum ) { flag = 1 ; break ; } } if ( flag == 0 ) count ++ ; } return count ; } int main ( ) { int N = 2 , K = 1 ; printf ( \" % d \" , countDigitSum ( N , K ) ) ; return 0 ; }"}
{"text": "Cari jika mungkin untuk melawat setiap nod dalam graf yang diberikan tepat sekali berdasarkan syarat -syarat yang diberikan | Program C ++ untuk pendekatan di atas. ; Berfungsi untuk mencari jalan cetak; Jika a [0] adalah 1; Jalan percetakan; Mencari [i] = 0 dan A [i + 1] = 1; Jalan percetakan; Jika a [n - 1] = 0; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findpath ( int N , int a [ ] ) { if ( a [ 0 ] ) { printf ( \" % d ▁ \" , N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , i ) ; return ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ! a [ i ] && a [ i + 1 ] ) { for ( int j = 1 ; j <= i ; j ++ ) printf ( \" % d ▁ \" , j ) ; printf ( \" % d ▁ \" , N + 1 ) ; for ( int j = i + 1 ; j <= N ; j ++ ) printf ( \" % d ▁ \" , j ) ; return ; } } for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , i ) ; printf ( \" % d ▁ \" , N + 1 ) ; } int main ( ) { int N = 3 , arr [ ] = { 0 , 1 , 0 } ; findpath ( N , arr ) ; }"}
{"text": "Percetakan Item dalam 0/1 Knapsack | Kod CPP untuk penyelesaian berasaskan pengaturcaraan dinamik untuk masalah 0 - 1 knapsack; Fungsi utiliti yang mengembalikan maksimum dua bilangan bulat; Mencetak item yang dimasukkan ke dalam kapasiti kapasiti w; Membina jadual k [] [] dengan cara bawah; menyimpan hasil knapsack; Sama ada hasilnya datang dari bahagian atas (k [i - 1] [w]) atau dari (val [i - 1] + k [i - 1] [w - wt [i - 1]]) seperti dalam jadual knapsack. Jika ia datang dari yang terakhir / ia bermakna item itu dimasukkan. ; Item ini dimasukkan. ; Oleh kerana berat ini dimasukkan nilainya ditolak; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; printf ( \" % d STRNEWLINE \" , res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { printf ( \" % d ▁ \" , wt [ i - 1 ] ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } } int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printknapSack ( W , wt , val , n ) ; return 0 ; }"}
{"text": "Pokok carian binari optimum | DP | Pelaksanaan rekursif naif masalah pokok carian binari yang optimum; Fungsi rekursif untuk mengira kos pokok carian binari yang optimum; Kes asas jika (j <i) tiada elemen dalam subarray ini; Satu elemen dalam subarray ini; Dapatkan jumlah freq [i], freq [i + 1], ... freq [j]; Memulakan nilai minimum; Satu demi satu menganggap semua elemen sebagai akar dan rekursif mencari kos BST, bandingkan kos dengan min dan kemas kini min jika diperlukan; Mengembalikan nilai minimum; Fungsi utama yang mengira kos minimum pokok carian binari. Ia terutamanya menggunakan OptCost () untuk mencari kos yang optimum. ; Di sini kunci array [] diandaikan disusun dalam peningkatan urutan. Jika kekunci [] tidak disusun, kemudian tambahkan kod untuk menyusun kekunci, dan menyusun semula Freq [] dengan sewajarnya. ; Fungsi utiliti untuk mendapatkan jumlah unsur array freq [i] ke freq [j]; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int optCost ( int freq [ ] , int i , int j ) { return 0 ; if ( j == i ) return freq [ i ] ; int fsum = sum ( freq , i , j ) ; int min = INT_MAX ; for ( int r = i ; r <= j ; ++ r ) { int cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; } return min + fsum ; } int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { return optCost ( freq , 0 , n - 1 ) ; } int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; } int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; printf ( \" Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ % d ▁ \" , optimalSearchTree ( keys , freq , n ) ) ; return 0 ; }"}
{"text": "Masalah Bungkus Word | DP | Penyelesaian pengaturcaraan dinamik untuk masalah bungkus perkataan; Fungsi utiliti untuk mencetak penyelesaian; L [] mewakili panjang perkataan yang berbeza dalam urutan input. Sebagai contoh, l [] = {3, 2, 2, 5} adalah untuk ayat seperti \"aaa u u u u ddddd\". n ialah saiz L [] dan m adalah lebar garis (maksimum no aksara yang boleh dimuatkan dalam garis); Ekstra [i] [j] akan mempunyai bilangan ruang tambahan jika kata -kata dari saya ke j diletakkan dalam satu baris; Lc [i] [j] akan mempunyai kos garis yang mempunyai kata -kata dari saya ke j; C [i] akan mempunyai jumlah kos susunan kata -kata yang optimum dari 1 hingga i; P [] digunakan untuk mencetak penyelesaian. ; Kirakan ruang tambahan dalam satu baris. Nilai tambahan [i] [j] menunjukkan ruang tambahan jika kata -kata dari nombor perkataan i ke j diletakkan dalam satu baris; Kirakan kos garis yang sepadan dengan ruang tambahan yang dikira di atas. Nilai LC [i] [j] menunjukkan kos meletakkan kata -kata dari nombor perkataan i ke j dalam satu baris; Kirakan kos minimum dan cari susunan kos minimum. Nilai C [j] menunjukkan kos yang dioptimumkan untuk mengatur perkataan dari nombor perkataan 1 hingga j. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #define INF  INT_MAX NEW_LINE int printSolution ( int p [ ] , int n ) ; void solveWordWrap ( int l [ ] , int n , int M ) { int extras [ n + 1 ] [ n + 1 ] ; int lc [ n + 1 ] [ n + 1 ] ; int c [ n + 1 ] ; int p [ n + 1 ] ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; } for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = INF ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } } c [ 0 ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { c [ j ] = INF ; for ( i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != INF && lc [ i ] [ j ] != INF && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; } int printSolution ( int p [ ] , int n ) { int k ; if ( p [ n ] == 1 ) k = 1 ; else k = printSolution ( p , p [ n ] - 1 ) + 1 ; printf ( \" Line ▁ number ▁ % d : ▁ From ▁ word ▁ no . ▁ % d ▁ to ▁ % d ▁ STRNEWLINE \" , k , p [ n ] , n ) ; return k ; } int main ( ) { int l [ ] = { 3 , 2 , 2 , 5 } ; int n = sizeof ( l ) / sizeof ( l [ 0 ] ) ; int M = 6 ; solveWordWrap ( l , n , M ) ; return 0 ; }"}
{"text": "Teka -teki menjatuhkan telur | DP | Pengaturcaraan dinamik berdasarkan teka -teki yang menjatuhkan telur; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Berfungsi untuk mendapatkan bilangan minimum ujian yang diperlukan dalam kes terburuk dengan telur N dan l lantai; Jadual 2D di mana kemasukan urgfloor [i] [j] akan mewakili bilangan minimum ujian yang diperlukan untuk saya telur dan lantai j. ; Kami memerlukan satu percubaan untuk satu tingkat dan 0 ujian untuk 0 tingkat; Kami sentiasa memerlukan ujian untuk satu lantai telur dan J. ; Isi sisa penyertaan dalam jadual menggunakan harta substruktur yang optimum; Eggfloor [n] [k] memegang hasilnya; Program Pemandu untuk Menguji ProntDups", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int eggDrop ( int n , int k ) { int eggFloor [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = INT_MAX ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; } int main ( ) { int n = 2 , k = 36 ; printf ( \" Minimum number of trials \" STRNEWLINE TABSYMBOL TABSYMBOL \" in worst case with % d eggs and \" STRNEWLINE TABSYMBOL TABSYMBOL \" % d floors is % d \" , n , k , eggDrop ( n , k ) ) ; return 0 ; }"}
{"text": "0 | Pelaksanaan rekursif naif masalah 0 - 1 Knapsack; Fungsi utiliti yang mengembalikan maksimum dua bilangan bulat; Mengembalikan nilai maksimum yang boleh dimasukkan ke dalam kapasiti kapasiti w; Kes asas; Jika berat item nth lebih daripada kapasiti knapsack W, maka item ini tidak dapat dimasukkan ke dalam penyelesaian optimum; Kembalikan maksimum dua kes: (1) item Nth termasuk (2) tidak termasuk; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printf ( \" % d \" , knapSack ( W , wt , val , n ) ) ; return 0 ; }"}
{"text": "Susunan yang paling lama meningkat | DP | Pelaksanaan rekursif naif masalah LIS; menyimpan lis; Untuk menggunakan panggilan rekursif, fungsi ini mesti mengembalikan dua perkara: 1) panjang lis yang berakhir dengan elemen arr [n - 1]. Kami menggunakan max_ending_here untuk tujuan ini2) maksimum maksimum kerana LIS mungkin berakhir dengan elemen sebelum arr [n - 1] max_ref digunakan tujuan ini. Nilai LIS pelbagai saiz n disimpan dalam * max_ref yang merupakan hasil akhir kami; Kes asas; 'max _ ending _ here' adalah panjang lis yang berakhir dengan arr [n - 1]; Recursively mendapatkan semua lis yang berakhir dengan arr [0], arr [1] ... arr [n - 2]. Jika arr [i - 1] lebih kecil daripada arr [n - 1], dan max berakhir dengan arr [n - 1] perlu dikemas kini, kemudian mengemas kini; Bandingkan max_ending_here dengan keseluruhan maks. Dan mengemas kini max keseluruhan jika diperlukan; Pulangan panjang lis yang berakhir dengan arr [n - 1]; Fungsi pembalut untuk _lis (); Pembolehubah max memegang hasilnya; Fungsi _lis () menyimpan hasilnya dalam max; mengembalikan max; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE let max_ref ; int _lis ( int arr [ ] , int n , int * max_ref ) { if ( n == 1 ) return 1 ; int res , max_ending_here = 1 ; for ( int i = 1 ; i < n ; i ++ ) { res = _lis ( arr , i , max_ref ) ; if ( arr [ i - 1 ] < arr [ n - 1 ] && res + 1 > max_ending_here ) max_ending_here = res + 1 ; } if ( * max_ref < max_ending_here ) * max_ref = max_ending_here ; return max_ending_here ; } int lis ( int arr [ ] , int n ) { int max = 1 ; _lis ( arr , n , & max ) ; return max ; } int main ( ) { int arr [ ] = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Length ▁ of ▁ lis ▁ is ▁ % d \" , lis ( arr , n ) ) ; return 0 ; }"}
{"text": "Rabin | Berikutan program adalah pelaksanaan algoritma Rabin Karp yang diberikan dalam buku CLRS; D ialah bilangan aksara dalam abjad input; Pat -> Corak Txt -> Teks Q -> Nombor Perdana; int p = 0; nilai hash untuk corak int t = 0; nilai hash untuk txt; Nilai H ialah \"pow (d, u, 1) % q\"; Kirakan nilai hash corak dan tetingkap pertama teks; Luncurkan corak ke atas teks satu demi satu; Semak nilai hash tetingkap semasa teks dan corak. Jika nilai hash sepadan maka hanya periksa aksara oleh satu; Semak watak satu demi satu; jika p == t dan pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]; Kirakan nilai hash untuk tetingkap teks seterusnya: Keluarkan digit terkemuka, tambah digit trailing; Kami mungkin mendapat nilai negatif T, menukarnya kepada positif; Kod pemacu; Nombor perdana; panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define d  256 NEW_LINE void search ( char pat [ ] , char txt [ ] , int q ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i , j ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; } if ( j == M ) printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; } if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } int main ( ) { char txt [ ] = \" GEEKS ▁ FOR ▁ GEEKS \" ; char pat [ ] = \" GEEK \" ; int q = 101 ; search ( pat , txt , q ) ; return 0 ; }"}
{"text": "Masalah Jelajah Knight | Backtracking | Program C untuk masalah lawatan Knight; Fungsi utiliti untuk memeriksa sama ada saya, j adalah indeks yang sah untuk n * n catur; Fungsi utiliti untuk mencetak penyelesaian matriks sol [n] [n]; Fungsi ini menyelesaikan masalah Tour Knight menggunakan backtracking. Fungsi ini terutamanya menggunakan Solvektutil () untuk menyelesaikan masalah. Ia mengembalikan palsu jika tiada lawatan lengkap mungkin, jika tidak, kembali benar dan mencetak lawatan. Sila ambil perhatian bahawa mungkin terdapat lebih daripada satu penyelesaian, fungsi ini mencetak salah satu penyelesaian yang boleh dilaksanakan. ; Permulaan matriks penyelesaian; Xmove [] dan YMove [] Tentukan langkah seterusnya Knight. Xmove [] adalah untuk nilai seterusnya x koordinat ymove [] adalah untuk nilai seterusnya koordinat y; Sejak Knight pada mulanya di blok pertama; Mula dari 0, 0 dan terokai semua lawatan menggunakan Solvektutil (); Fungsi utiliti rekursif untuk menyelesaikan masalah lawatan ksatria; Cuba semua langkah seterusnya dari koordinat semasa x, y; mundur; Kod pemacu; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #define N  8 NEW_LINE int solveKTUtil ( int x , int y , int movei , int sol [ N ] [ N ] , int xMove [ ] , int yMove [ ] ) ; int isSafe ( int x , int y , int sol [ N ] [ N ] ) { return ( x >= 0 && x < N && y >= 0 && y < N && sol [ x ] [ y ] == -1 ) ; } void printSolution ( int sol [ N ] [ N ] ) { for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < N ; y ++ ) printf ( \" ▁ % 2d ▁ \" , sol [ x ] [ y ] ) ; printf ( \" STRNEWLINE \" ) ; } } int solveKT ( ) { int sol [ N ] [ N ] ; for ( int x = 0 ; x < N ; x ++ ) for ( int y = 0 ; y < N ; y ++ ) sol [ x ] [ y ] = -1 ; int xMove [ 8 ] = { 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 } ; int yMove [ 8 ] = { 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 } ; sol [ 0 ] [ 0 ] = 0 ; if ( solveKTUtil ( 0 , 0 , 1 , sol , xMove , yMove ) == 0 ) { printf ( \" Solution ▁ does ▁ not ▁ exist \" ) ; return 0 ; } else printSolution ( sol ) ; return 1 ; } int solveKTUtil ( int x , int y , int movei , int sol [ N ] [ N ] , int xMove [ N ] , int yMove [ N ] ) { int k , next_x , next_y ; if ( movei == N * N ) return 1 ; for ( k = 0 ; k < 8 ; k ++ ) { next_x = x + xMove [ k ] ; next_y = y + yMove [ k ] ; if ( isSafe ( next_x , next_y , sol ) ) { sol [ next_x ] [ next_y ] = movei ; if ( solveKTUtil ( next_x , next_y , movei + 1 , sol , xMove , yMove ) == 1 ) return 1 ; else sol [ next_x ] [ next_y ] = -1 ; } } return 0 ; } int main ( ) { solveKT ( ) ; return 0 ; }"}
{"text": "M PELBAGAI PENYIMPANAN | Backtracking |  ; Bilangan simpang dalam graf; Fungsi utiliti untuk mencetak penyelesaian; Semak sama ada graf berwarna selamat atau tidak; Periksa setiap kelebihan; Fungsi ini menyelesaikan masalah pewarna M menggunakan rekursi. Ia mengembalikan palsu jika warna M tidak dapat diberikan, jika tidak, pulangkan semula dan mencetak tugasan warna ke semua simpul. Sila ambil perhatian bahawa mungkin terdapat lebih daripada satu penyelesaian, fungsi ini mencetak salah satu penyelesaian yang boleh dilaksanakan. ; jika indeks semasa mencapai akhir; Jika pewarna selamat; Cetak penyelesaian; Berikan setiap warna dari 1 hingga m; Berulang dari simpang lain; Program pemacu untuk menguji fungsi di atas; Buat grafik berikut dan ujian sama ada 3 boleh berwarna (3) - - (2) | / | | / | | / | (0) - - (1); Bilangan warna; Inisialisasi semua nilai warna sebagai 0. Inisialisasi ini diperlukan fungsi yang betul dari Issafe ()", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE #define V  4 NEW_LINE void printSolution ( int color [ ] ) ; void printSolution ( int color [ ] ) { printf ( \" Solution ▁ Exists : \" \" ▁ Following ▁ are ▁ the ▁ assigned ▁ colors ▁ STRNEWLINE \" ) ; for ( int i = 0 ; i < V ; i ++ ) printf ( \" ▁ % d ▁ \" , color [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } bool isSafe ( bool graph [ V ] [ V ] , int color [ ] ) { for ( int i = 0 ; i < V ; i ++ ) for ( int j = i + 1 ; j < V ; j ++ ) if ( graph [ i ] [ j ] && color [ j ] == color [ i ] ) return false ; return true ; } bool graphColoring ( bool graph [ V ] [ V ] , int m , int i , int color [ V ] ) { if ( i == V ) { if ( isSafe ( graph , color ) ) { printSolution ( color ) ; return true ; } return false ; } for ( int j = 1 ; j <= m ; j ++ ) { color [ i ] = j ; if ( graphColoring ( graph , m , i + 1 , color ) ) return true ; color [ i ] = 0 ; } return false ; } int main ( ) { bool graph [ V ] [ V ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 1 } , { 1 , 0 , 1 , 0 } , } ; int m = 3 ; int color [ V ] ; for ( int i = 0 ; i < V ; i ++ ) color [ i ] = 0 ; if ( ! graphColoring ( graph , m , 0 , color ) ) printf ( \" Solution ▁ does ▁ not ▁ exist \" ) ; return 0 ; }"}
{"text": "Trik Logaritma untuk Pengaturcaraan Kompetitif | C pelaksanaan untuk mencari kuasa sebelumnya dan seterusnya K; Berfungsi untuk mengembalikan kuasa tertinggi k kurang daripada atau sama dengan n; Berfungsi untuk mengembalikan kuasa terkecil k lebih besar daripada atau sama dengan n; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE int prevPowerofK ( int n , int k ) { int p = ( int ) ( log ( n ) / log ( k ) ) ; return ( int ) pow ( k , p ) ; } int nextPowerOfK ( int n , int k ) { return prevPowerofK ( n , k ) * k ; } int main ( ) { int N = 7 ; int K = 2 ; printf ( \" % d ▁ \" , prevPowerofK ( N , K ) ) ; printf ( \" % d STRNEWLINE \" , nextPowerOfK ( N , K ) ) ; return 0 ; }"}
{"text": "Program untuk mencari HCF (faktor umum tertinggi) daripada 2 nombor | C program untuk mencari GCD dua nombor; Fungsi rekursif untuk mengembalikan GCD A dan B; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int main ( ) { int a = 98 , b = 56 ; printf ( \" GCD ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "Semak sama ada nombor semiprime atau tidak | C program untuk memeriksa sama ada nombor adalah semiprime atau tidak; Fungsi utiliti untuk memeriksa sama ada nombor adalah semiprime atau tidak; Jika nombor lebih besar daripada 1, tambahkannya ke pemboleh ubah kiraan kerana ia menunjukkan bilangan yang kekal adalah nombor utama; Kembali '1' jika kiraan adalah sama dengan '2' lain kembali '0'; Berfungsi untuk mencetak 'benar' atau 'palsu' mengikut keadaan semiprim; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) while ( num % i == 0 ) num /= i , ++ cnt ; if ( num > 1 ) ++ cnt ; return cnt == 2 ; } void semiprime ( int n ) { if ( checkSemiprime ( n ) ) printf ( \" True STRNEWLINE \" ) ; else printf ( \" False STRNEWLINE \" ) ; } int main ( ) { int n = 6 ; semiprime ( n ) ; n = 8 ; semiprime ( n ) ; return 0 ; }"}
{"text": "Perintah Tahap Berbalik Traversal | Program C rekursif untuk mencetak perintah peringkat terbalik; Nod pokok binari mempunyai data, penunjuk ke anak kiri dan kanan; Fungsi protoypes; Berfungsi untuk mencetak perintah tahap terbalik traversal pokok; Cetak nod pada tahap tertentu; Kirakan \"ketinggian\" pokok - bilangan nod di sepanjang laluan terpanjang dari nod akar ke nod daun terjauh. ; Kirakan ketinggian setiap subtree; gunakan yang lebih besar; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Program pemacu untuk menguji fungsi di atas; Mari kita buat pokok yang ditunjukkan dalam rajah di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; void printGivenLevel ( struct node * root , int level ) ; int height ( struct node * node ) ; struct node * newNode ( int data ) ; void reverseLevelOrder ( struct node * root ) { int h = height ( root ) ; int i ; for ( i = h ; i >= 1 ; i -- ) printGivenLevel ( root , i ) ; } void printGivenLevel ( struct node * root , int level ) { if ( root == NULL ) return ; if ( level == 1 ) printf ( \" % d ▁ \" , root -> data ) ; else if ( level > 1 ) { printGivenLevel ( root -> left , level - 1 ) ; printGivenLevel ( root -> right , level - 1 ) ; } } int height ( struct node * node ) { if ( node == NULL ) return 0 ; else { int lheight = height ( node -> left ) ; int rheight = height ( node -> right ) ; if ( lheight > rheight ) return ( lheight + 1 ) ; else return ( rheight + 1 ) ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ tree ▁ is ▁ STRNEWLINE \" ) ; reverseLevelOrder ( root ) ; return 0 ; }"}
{"text": "Carian Sequential Diindeks | Program C untuk carian berurutan yang diindeks; Menyimpan elemen; Menyimpan indeks; Kod pemacu; Elemen untuk mencari; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void indexedSequentialSearch ( int arr [ ] , int n , int k ) { int elements [ 20 ] , indices [ 20 ] , temp , i , set = 0 ; int j = 0 , ind = 0 , start , end ; for ( i = 0 ; i < n ; i += 3 ) { elements [ ind ] = arr [ i ] ; indices [ ind ] = i ; ind ++ ; } if ( k < elements [ 0 ] ) { printf ( \" Not ▁ found \" ) ; exit ( 0 ) ; } else { for ( i = 1 ; i <= ind ; i ++ ) if ( k <= elements [ i ] ) { start = indices [ i - 1 ] ; end = indices [ i ] ; set = 1 ; break ; } } if ( set == 0 ) { start = indices [ i - 1 ] ; end = n ; } for ( i = start ; i <= end ; i ++ ) { if ( k == arr [ i ] ) { j = 1 ; break ; } } if ( j == 1 ) printf ( \" Found ▁ at ▁ index ▁ % d \" , i ) ; else printf ( \" Not ▁ found \" ) ; } void main ( ) { int arr [ ] = { 6 , 7 , 8 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 8 ; indexedSequentialSearch ( arr , n , k ) ; }"}
{"text": "Elemen yang lebih kecil seterusnya | Program C Mudah untuk mencetak elemen yang lebih kecil seterusnya dalam array yang diberikan; cetak elemen dan pasangan NSE untuk semua elemen arr [] saiz n; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void printNSE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } printf ( \" % d ▁ - - ▁ % d STRNEWLINE \" , arr [ i ] , next ) ; } } int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNSE ( arr , n ) ; return 0 ; }"}
{"text": "MSD (Digit Paling Penting) Radix Sort | Program C untuk pelaksanaan jenis radix MSD menggunakan sort countting (); Fungsi utiliti untuk mencetak array; Fungsi utiliti untuk mendapatkan digit pada indeks D dalam integer; Fungsi untuk menyusun array menggunakan msd radix jenis rekursif; keadaan rehat rekursi; Temp dicipta dengan mudah menukar tali di arr []; Menyimpan kejadian yang paling penting dari setiap integer dalam kiraan []; Perubahan kiraan [] supaya kiraan [] kini mengandungi kedudukan sebenar digit ini dalam temp []; Membina temp; Salin semua integer temp ke arr [], supaya arr [] kini mengandungi bilangan bulat yang disusun sebahagiannya; Rekursif msd_sort () pada setiap bilangan bulat yang disusun sebahagiannya ditetapkan untuk menyusunnya dengan digit seterusnya; fungsi mencari integer terbesar; Fungsi utama untuk menghubungi MSD_SORT; Cari nombor maksimum untuk mengetahui bilangan digit; Dapatkan panjang integer terbesar; panggilan fungsi; Kod pemacu; Arahan input; Saiz array; Cetak array yang tidak disusun; Panggilan fungsi; Cetak array yang disusun", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE void print ( int * arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { printf ( \" % d , ▁ \" , arr [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } int digit_at ( int x , int d ) { return ( int ) ( x / pow ( 10 , d - 1 ) ) % 10 ; } void MSD_sort ( int * arr , int lo , int hi , int d ) { if ( hi <= lo d < 1 ) { return ; } int count [ 10 + 2 ] = { 0 } ; int temp [ n ] ; for ( int i = lo ; i <= hi ; i ++ ) { int c = digit_at ( arr [ i ] , d ) ; count ++ ; } for ( int r = 0 ; r < 10 + 1 ; r ++ ) count [ r + 1 ] += count [ r ] ; for ( int i = lo ; i <= hi ; i ++ ) { int c = digit_at ( arr [ i ] , d ) ; temp [ count ++ ] = arr [ i ] ; } for ( int i = lo ; i <= hi ; i ++ ) { arr [ i ] = temp [ i - lo ] ; } for ( int r = 0 ; r < 10 ; r ++ ) MSD_sort ( arr , lo + count [ r ] , lo + count [ r + 1 ] - 1 , d - 1 ) ; } int getMax ( int arr [ ] , int n ) { int mx = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > mx ) mx = arr [ i ] ; return mx ; } void radixsort ( int * arr , int n ) { int m = getMax ( arr , n ) ; int d = floor ( log10 ( abs ( m ) ) ) + 1 ; MSD_sort ( arr , 0 , n - 1 , d ) ; } int main ( ) { int arr [ ] = { 9330 , 9950 , 718 , 8977 , 6790 , 95 , 9807 , 741 , 8586 , 5710 } ; n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Unsorted ▁ array ▁ : ▁ \" ) ; print ( arr , n ) ; radixsort ( arr , n ) ; printf ( \" Sorted ▁ array ▁ : ▁ \" ) ; print ( arr , n ) ; return 0 ; }"}
{"text": "Dalam | Gabungkan di C; Kedua -dua sub -tatasusunan yang disusun mesti bersebelahan dengan 'a' 'an' adalah panjang seksyen yang disusun pertama dalam 'a' 'bn' adalah panjang seksyen yang disusun kedua dalam 'a'; Kembali sekarang jika kita selesai; Adakah penyisipan sort untuk bergabung jika saiz sub - tatasusunan cukup kecil; p -) masukkan Sort A ke B; P ++) masukkan Sort B ke dalam A; Cari mata pivot. Pada dasarnya ini hanya mencari titik dalam 'A' di mana kita boleh menukar di bahagian pertama 'B' supaya selepas swap elemen terakhir dalam 'A' akan kurang daripada atau sama dengan elemen paling sedikit dalam 'B'; Tukar bahagian pertama B dengan bahagian terakhir A; Sekarang gabungkan dua pasangan sub - array; } Merge_array_inplace; Gabungkan pelaksanaan jenis; Menyusun bahagian pertama dan kedua; Sekarang gabungkan dua sub - susunan bersama -sama; Berfungsi untuk mencetak array; Program pemacu untuk menguji jenis utiliyy", "code": "#include <stddef.h> NEW_LINE #include <stdio.h> NEW_LINE #define __INSERT_THRESH  5 NEW_LINE #define __swap ( x , y )  (t = *(x), *(x) = *(y), *(y) = t) NEW_LINE static void merge ( int * a , size_t an , size_t bn ) { int * b = a + an , * e = b + bn , * s , t ; if ( an == 0 || bn == 0 || ! ( * b < * ( b - 1 ) ) ) return ; if ( an < __INSERT_THRESH && an <= bn ) { for ( int * p = b , * v ; p > a ; for ( v = p , s = p - 1 ; v < e && * v < * s ; s = v , v ++ ) __swap ( s , v ) ; return ; } if ( bn < __INSERT_THRESH ) { for ( int * p = b , * v ; p < e ; for ( s = p , v = p - 1 ; s > a && * s < * v ; s = v , v -- ) __swap ( s , v ) ; return ; } int * pa = a , * pb = b ; for ( s = a ; s < b && pb < e ; s ++ ) if ( * pb < * pa ) pb ++ ; else pa ++ ; pa += b - s ; for ( int * la = pa , * fb = b ; la < b ; la ++ , fb ++ ) __swap ( la , fb ) ; merge ( a , pa - a , pb - b ) ; merge ( b , pb - b , e - pb ) ; #undef __swap #undef __INSERT_THRESH void merge_sort ( int * a , size_t n ) { size_t m = ( n + 1 ) / 2 ; if ( m > 1 ) merge_sort ( a , m ) ; if ( n - m > 1 ) merge_sort ( a + m , n - m ) ; merge ( a , m , n - m ) ; } void print_array ( int a [ ] , size_t n ) { if ( n > 0 ) { printf ( \" % d \" , a [ 0 ] ) ; for ( size_t i = 1 ; i < n ; i ++ ) printf ( \" ▁ % d \" , a [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } int main ( ) { int a [ ] = { 3 , 16 , 5 , 14 , 8 , 10 , 7 , 15 , 1 , 13 , 4 , 9 , 12 , 11 , 6 , 2 } ; size_t n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; merge_sort ( a , n ) ; print_array ( a , n ) ; return 0 ; }"}
{"text": "Masalah tugasan saluran |  ; Fungsi rekursif berasaskan carian yang pertama yang kembali benar jika padanan untuk puncak u mungkin; Cuba setiap penerima satu demi satu; Jika pengirim U mempunyai paket untuk dihantar ke penerima v dan penerima v belum dipetakan ke mana -mana pengirim lain, semak jika bilangan paket lebih besar daripada '0' kerana hanya satu paket yang boleh dihantar dalam jangka masa anyways; Mark V seperti yang dikunjungi; Jika penerima 'V' tidak diberikan kepada mana -mana penghantar atau pengirim yang ditugaskan sebelum ini untuk penerima V (iaitu Matchr [v]) mempunyai penerima alternatif yang tersedia. Oleh kerana V ditandakan seperti yang dikunjungi dalam baris di atas, Matchr [v] dalam panggilan rekursif berikut tidak akan mendapat 'V' lagi; Mengembalikan bilangan maksimum paket yang boleh dihantar secara selalunya dalam slot 1 masa dari penghantar ke penerima; Arahan untuk menjejaki penerima yang diberikan kepada pengirim. Nilai matchr [i] adalah ID pengirim yang diberikan kepada penerima i. Nilai - 1 menunjukkan tiada siapa yang diberikan. ; Pada mulanya semua penerima tidak dipetakan ke mana -mana penghantar; Kiraan penerima yang diberikan kepada pengirim; Tandakan semua penerima seperti yang tidak dilihat untuk pengirim seterusnya; Cari jika pengirim 'U' boleh diberikan kepada penerima; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE #include <string.h> NEW_LINE #include <vector> NEW_LINE #define M  3 NEW_LINE #define N  4 NEW_LINE using namespace std ; bool bpm ( int table [ M ] [ N ] , int u , bool seen [ ] , int matchR [ ] ) { for ( int v = 0 ; v < N ; v ++ ) { if ( table [ u ] [ v ] > 0 && ! seen [ v ] ) { seen [ v ] = true ; if ( matchR [ v ] < 0 || bpm ( table , matchR [ v ] , seen , matchR ) ) { matchR [ v ] = u ; return true ; } } } return false ; } int maxBPM ( int table [ M ] [ N ] ) { int matchR [ N ] ; memset ( matchR , -1 , sizeof ( matchR ) ) ; int result = 0 ; for ( int u = 0 ; u < M ; u ++ ) { bool seen [ N ] ; memset ( seen , 0 , sizeof ( seen ) ) ; if ( bpm ( table , u , seen , matchR ) ) result ++ ; } cout << \" The ▁ number ▁ of ▁ maximum ▁ packets ▁ sent ▁ in ▁ the ▁ time ▁ slot ▁ is ▁ \" << result << \" STRNEWLINE \" ; for ( int x = 0 ; x < N ; x ++ ) if ( matchR [ x ] + 1 != 0 ) cout << \" T \" << matchR [ x ] + 1 << \" - > ▁ R \" << x + 1 << \" STRNEWLINE \" ; return result ; } int main ( ) { int table [ M ] [ N ] = { { 0 , 2 , 0 } , { 3 , 0 , 1 } , { 2 , 4 , 0 } } ; int max_flow = maxBPM ( table ) ; return 0 ; }"}
{"text": "Decode asas yang dikodkan 64 String ke ASCII String | C program untuk menyahkodkan rentetan yang dikodkan Base64 kembali ke rentetan ASCII; char_set = \"abcdefghijklmnopqrstuvwxyz» abcdefghijklmnopqrstuvwxyz0123456789 + / \"; menyimpan bitstream. ; Count_bits menyimpan bilangan bit semasa dalam NUM. ; Memilih 4 aksara dari rentetan yang dikodkan pada satu masa. Cari kedudukan setiap watak yang dikodkan dalam char_set dan kedai di NUM. ; Buat ruang untuk 6 bit. ; Dikodkan [i + j] = 'e', ​​'e' - 'a' = 5 'e' mempunyai kedudukan ke -5 dalam char_set. ; dikodkan [i + j] = 'e', ​​'e' - 'a' = 5, 5 + 26 = 31, 'e' mempunyai kedudukan 31 st dalam char_set. ; Dikodkan [i + j] = '8', '8' - '0' = 8 8 + 52 = 60, '8' mempunyai kedudukan ke -60 dalam char_set. ; ' +' berlaku dalam kedudukan 62 nd dalam char_set. ; ' /' berlaku dalam kedudukan 63 rd dalam char_set. ; (str [i + j] == '=') Keluarkan 2 bit untuk memadam bit yang dilampirkan semasa pengekodan. ; 255 dalam binari ialah 11111111; Fungsi pemacu; Jangan mengira watak null terakhir.", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define SIZE  100 NEW_LINE char * base64Decoder ( char encoded [ ] , int len_str ) { char * decoded_string ; decoded_string = ( char * ) malloc ( sizeof ( char ) * SIZE ) ; int i , j , k = 0 ; int num = 0 ; int count_bits = 0 ; for ( i = 0 ; i < len_str ; i += 4 ) { num = 0 , count_bits = 0 ; for ( j = 0 ; j < 4 ; j ++ ) { if ( encoded [ i + j ] != ' = ' ) { num = num << 6 ; count_bits += 6 ; } if ( encoded [ i + j ] >= ' A ' && encoded [ i + j ] <= ' Z ' ) num = num | ( encoded [ i + j ] - ' A ' ) ; else if ( encoded [ i + j ] >= ' a ' && encoded [ i + j ] <= ' z ' ) num = num | ( encoded [ i + j ] - ' a ' + 26 ) ; else if ( encoded [ i + j ] >= '0' && encoded [ i + j ] <= '9' ) num = num | ( encoded [ i + j ] - '0' + 52 ) ; else if ( encoded [ i + j ] == ' + ' ) num = num | 62 ; else if ( encoded [ i + j ] == ' / ' ) num = num | 63 ; else { num = num >> 2 ; count_bits -= 2 ; } } while ( count_bits != 0 ) { count_bits -= 8 ; decoded_string [ k ++ ] = ( num >> count_bits ) & 255 ; } } decoded_string [ k ] = ' \\0' ; return decoded_string ; } int main ( ) { char encoded_string [ ] = \" TUVOT04 = \" ; int len_str = sizeof ( encoded_string ) / sizeof ( encoded_string [ 0 ] ) ; len_str -= 1 ; printf ( \" Encoded ▁ string ▁ : ▁ % s STRNEWLINE \" , encoded_string ) ; printf ( \" Decoded _ string ▁ : ▁ % s STRNEWLINE \" , base64Decoder ( encoded_string , len_str ) ) ; return 0 ; }"}
{"text": "Item Senarai Cetak yang mengandungi semua aksara perkataan yang diberikan | Program C untuk mencetak semua rentetan yang mengandungi semua aksara perkataan; Senarai cetakan item yang mempunyai semua aksara perkataan; Oleh kerana calloc digunakan, peta [] diasaskan sebagai 0; Tetapkan nilai dalam peta; Dapatkan panjang perkataan yang diberikan; Semak setiap item senarai jika mempunyai semua aksara perkataan; Tidak tersendiri sehingga rentetan seperti SSS tidak dicetak; Tetapkan nilai dalam peta untuk item seterusnya; Program Pemandu untuk Menguji ProntDups", "code": "# include <stdio.h> NEW_LINE # include <stdlib.h> NEW_LINE # include <string.h> NEW_LINE # define NO_OF_CHARS  256 NEW_LINE void print ( char * list [ ] , char * word , int list_size ) { int * map = ( int * ) calloc ( sizeof ( int ) , NO_OF_CHARS ) ; int i , j , count , word_size ; for ( i = 0 ; * ( word + i ) ; i ++ ) map [ * ( word + i ) ] = 1 ; word_size = strlen ( word ) ; for ( i = 0 ; i < list_size ; i ++ ) { for ( j = 0 , count = 0 ; * ( list [ i ] + j ) ; j ++ ) { if ( map [ * ( list [ i ] + j ) ] ) { count ++ ; map [ * ( list [ i ] + j ) ] = 0 ; } } if ( count == word_size ) printf ( \" % s \" , list [ i ] ) ; for ( j = 0 ; * ( word + j ) ; j ++ ) map [ * ( word + j ) ] = 1 ; } } int main ( ) { char str [ ] = \" sun \" ; char * list [ ] = { \" geeksforgeeks \" , \" unsorted \" , \" sunday \" , \" just \" , \" sss \" } ; print ( list , str , 5 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Memandangkan rentetan, cari yang pertama bukan | Program C untuk mencari watak pertama bukan berulang; Mengembalikan pelbagai saiz 256 yang mengandungi kiraan aksara dalam array char yang diluluskan; Fungsi mengembalikan indeks watak bukan berulang pertama dalam rentetan. Jika semua aksara mengulangi maka kembali - 1; Untuk mengelakkan kebocoran ingatan; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE int * getCharCountArray ( char * str ) { int * count = ( int * ) calloc ( sizeof ( int ) , NO_OF_CHARS ) ; int i ; for ( i = 0 ; * ( str + i ) ; i ++ ) count [ * ( str + i ) ] ++ ; return count ; } int firstNonRepeating ( char * str ) { int * count = getCharCountArray ( str ) ; int index = -1 , i ; for ( i = 0 ; * ( str + i ) ; i ++ ) { if ( count [ * ( str + i ) ] == 1 ) { index = i ; break ; } } free ( count ) ; return index ; } int main ( ) { char str [ ] = \" geeksforgeeks \" ; int index = firstNonRepeating ( str ) ; if ( index == -1 ) printf ( \" Either ▁ all ▁ characters ▁ are ▁ repeating ▁ or ▁ \" \" string ▁ is ▁ empty \" ) ; else printf ( \" First ▁ non - repeating ▁ character ▁ is ▁ % c \" , str [ index ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Bahagikan rentetan dalam bahagian yang sama | Program C untuk membahagikan rentetan dalam bahagian yang sama; Berfungsi untuk mencetak bahagian yang sama str; Semak jika rentetan boleh dibahagikan kepada bahagian yang sama; Kirakan saiz bahagian untuk mencari titik bahagian; panjang rentetan OD ialah 28; Cetak 4 bahagian yang sama dari rentetan", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void divideString ( char * str , int n ) { int str_size = strlen ( str ) ; int i ; int part_size ; if ( str_size % n != 0 ) { printf ( \" Invalid ▁ Input : ▁ String ▁ size \" ) ; printf ( \" ▁ is ▁ not ▁ divisible ▁ by ▁ n \" ) ; return ; } part_size = str_size / n ; for ( i = 0 ; i < str_size ; i ++ ) { if ( i % part_size == 0 ) printf ( \" STRNEWLINE \" ) ; printf ( \" % c \" , str [ i ] ) ; } } int main ( ) { char * str = \" a _ simple _ divide _ string _ quest \" ; divideString ( str , 4 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program untuk memeriksa sama ada tiga mata adalah collinear | Penyelesaian berasaskan cerun untuk memeriksa sama ada tiga mata adalah collinear. ; berfungsi untuk memeriksa sama ada titik collinear atau tidak; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void collinear ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { if ( ( y3 - y2 ) * ( x2 - x1 ) == ( y2 - y1 ) * ( x3 - x2 ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; } int main ( ) { int x1 = 1 , x2 = 1 , x3 = 0 , y1 = 1 , y2 = 6 , y3 = 9 ; collinear ( x1 , y1 , x2 , y2 , x3 , y3 ) ; return 0 ; }"}
{"text": "Mewakili satu set mata yang diberikan oleh garis lurus yang terbaik | Program C untuk mencari m dan c untuk garis lurus yang diberikan, x dan y; berfungsi untuk mengira m dan c yang paling sesuai dengan titik yang diwakili oleh x [] dan y []; Fungsi utama pemandu", "code": "#include <stdio.h> NEW_LINE void bestApproximate ( int x [ ] , int y [ ] , int n ) { int i , j ; float m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += ( x [ i ] * x [ i ] ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - ( sum_x * sum_x ) ) ; c = ( sum_y - m * sum_x ) / n ; printf ( \" m ▁ = % ▁ f \" , m ) ; printf ( \" c = % f \" , c ) ; } int main ( ) { int x [ ] = { 1 , 2 , 3 , 4 , 5 } ; int y [ ] = { 14 , 27 , 40 , 55 , 68 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; bestApproximate ( x , y , n ) ; return 0 ; }"}
{"text": "Sisipan minimum untuk membentuk palindrome | DP | Program rekursif naif untuk mencari sisipan nombor minimum yang diperlukan untuk membuat palindrome rentetan; Fungsi rekursif untuk mencari bilangan sisipan minimum; Kes asas; Semak sama ada aksara pertama dan terakhir adalah sama. Berdasarkan hasil perbandingan, tentukan subrpoplem mana yang hendak dipanggil; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; } int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; } int main ( ) { char str [ ] = \" geeks \" ; printf ( \" % d \" , findMinInsertions ( str , 0 , strlen ( str ) - 1 ) ) ; return 0 ; }"}
{"text": "Morris Traversal untuk Preorder | Program C untuk Morris Preorder Traversal; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Preorder traversal tanpa rekursi dan tanpa timbunan; Jika anak kiri adalah batal, cetak data nod semasa. Pindah ke anak yang betul. ; Cari Inorderororor; Jika anak yang tepat dari pendahuluan inorder sudah menunjuk ke nod ini; Jika anak yang betul tidak menunjuk ke nod ini, kemudian cetak nod ini dan buatlah anak yang betul menunjuk ke nod ini; Fungsi untuk traversal preorder Sstandard; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void morrisTraversalPreorder ( struct node * root ) { while ( root ) { if ( root -> left == NULL ) { printf ( \" % d ▁ \" , root -> data ) ; root = root -> right ; } else { struct node * current = root -> left ; while ( current -> right && current -> right != root ) current = current -> right ; if ( current -> right == root ) { current -> right = NULL ; root = root -> right ; } else { printf ( \" % d ▁ \" , root -> data ) ; current -> right = root ; root = root -> left ; } } } } void preorder ( struct node * root ) { if ( root ) { printf ( \" % d ▁ \" , root -> data ) ; preorder ( root -> left ) ; preorder ( root -> right ) ; } } int main ( ) { struct node * root = NULL ; root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 11 ) ; morrisTraversalPreorder ( root ) ; printf ( \" STRNEWLINE \" ) ; preorder ( root ) ; return 0 ; }"}
{"text": "Senarai Terkait | Tetapkan 2 (memasukkan nod) | Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala senarai dan int, memasukkan nod baru di bahagian depan senarai. ; 1 & 2: memperuntukkan nod & dimasukkan ke dalam data; 3. Buat nod baru sebagai kepala; 4. Gerakkan kepala untuk menunjuk ke nod baru", "code": "void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; }"}
{"text": "Senarai Terkait | Tetapkan 2 (memasukkan nod) | Memandangkan node prev_node, masukkan nod baru selepas prev_node yang diberikan; 1. Semak jika prev_node yang diberikan adalah null; 2. Peruntukkan nod & 3. Masukkan data; 4. Buat nod baru seterusnya sebagai prev_node berikutnya; 5. Gerakkan prev_node seterusnya sebagai new_node", "code": "void insertAfter ( struct Node * prev_node , int new_data ) { if ( prev_node == NULL ) { printf ( \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" ) ; return ; } struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = prev_node -> next ; prev_node -> next = new_node ; }"}
{"text": "Program untuk n 'th node dari akhir senarai yang dipautkan |", "code": "void printNthFromLast ( struct Node * head , int n ) { static int i = 0 ; if ( head == NULL ) return ; printNthFromLast ( head -> next , n ) ; if ( ++ i == n ) printf ( \" % d \" , head -> data ) ; }"}
{"text": "Mengesan gelung dalam senarai yang dipautkan | C program untuk mengesan gelung dalam senarai yang dipautkan; Nod senarai pautan; memperuntukkan nod; masukkan data; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Program pemacu untuk menguji fungsi di atas; Mulakan dengan senarai kosong; Buat gelung untuk ujian", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int detectLoop ( struct Node * list ) { struct Node * slow_p = list , * fast_p = list ; while ( slow_p && fast_p && fast_p -> next ) { slow_p = slow_p -> next ; fast_p = fast_p -> next -> next ; if ( slow_p == fast_p ) { return 1 ; } } return 0 ; } int main ( ) { struct Node * head = NULL ; push ( & head , 20 ) ; push ( & head , 4 ) ; push ( & head , 15 ) ; push ( & head , 10 ) ; head -> next -> next -> next -> next = head ; if ( detectLoop ( head ) ) printf ( \" Loop ▁ found \" ) ; else printf ( \" No ▁ Loop \" ) ; return 0 ; }"}
{"text": "Fungsi untuk memeriksa sama ada senarai yang berkaitan dengan Palindrome | Program untuk memeriksa sama ada senarai yang dipautkan adalah palindrome; Nod senarai pautan; Fungsi untuk memeriksa sama ada senarai yang dipautkan adalah palindrome atau tidak; Untuk mengendalikan senarai saiz ganjil; memulakan hasil; Dapatkan tengah senarai. Pindahkan SLOW_PTR oleh 1 dan FAST_PTRR oleh 2, SLOW_PTR akan mempunyai nod tengah; Kami memerlukan sebelumnya dari SLOW_PTR untuk senarai yang dipautkan dengan elemen ganjil; FAST_PTR akan menjadi batal apabila terdapat unsur -unsur dalam senarai. Dan tidak batal untuk elemen ganjil. Kita perlu melangkau nod tengah untuk kes ganjil dan menyimpannya di suatu tempat supaya kita dapat memulihkan senarai asal; Sekarang terbalik separuh kedua dan bandingkan dengan separuh pertama; Null menamatkan separuh pertama; Membalikkan separuh kedua; Bandingkan; Membalikkan babak kedua sekali lagi; Sekiranya terdapat nod pertengahan (kes saiz ganjil) yang bukan sebahagian daripada separuh pertama atau separuh kedua. ; Berfungsi untuk membalikkan senarai yang dipautkan nota bahawa fungsi ini boleh mengubah kepala; Fungsi untuk memeriksa sama ada dua senarai input mempunyai data yang sama; Kedua -duanya adalah kosong kosong 1; Akan sampai ke sini apabila seseorang itu tidak sah dan yang lain tidak; Tolak nod ke senarai yang dipautkan. Perhatikan bahawa fungsi ini mengubah kepala; memperuntukkan nod; Pautan senarai lama dari nod baru; Gerakkan kepala ke Pochar ke nod baru; Fungsi utiliti untuk mencetak senarai yang dipautkan; Program kering untuk menguji fungsi di atas; Mulakan dengan senarai kosong", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { char data ; struct Node * next ; } ; void reverse ( struct Node * * ) ; bool compareLists ( struct Node * , struct Node * ) ; bool isPalindrome ( struct Node * head ) { struct Node * slow_ptr = head , * fast_ptr = head ; struct Node * second_half , * prev_of_slow_ptr = head ; struct Node * midnode = NULL ; bool res = true ; if ( head != NULL && head -> next != NULL ) { while ( fast_ptr != NULL && fast_ptr -> next != NULL ) { fast_ptr = fast_ptr -> next -> next ; prev_of_slow_ptr = slow_ptr ; slow_ptr = slow_ptr -> next ; } if ( fast_ptr != NULL ) { midnode = slow_ptr ; slow_ptr = slow_ptr -> next ; } second_half = slow_ptr ; prev_of_slow_ptr -> next = NULL ; reverse ( & second_half ) ; res = compareLists ( head , second_half ) ; reverse ( & second_half ) ; if ( midnode != NULL ) { prev_of_slow_ptr -> next = midnode ; midnode -> next = second_half ; } else prev_of_slow_ptr -> next = second_half ; } return res ; } void reverse ( struct Node * * head_ref ) { struct Node * prev = NULL ; struct Node * current = * head_ref ; struct Node * next ; while ( current != NULL ) { next = current -> next ; current -> next = prev ; prev = current ; current = next ; } * head_ref = prev ; } bool compareLists ( struct Node * head1 , struct Node * head2 ) { struct Node * temp1 = head1 ; struct Node * temp2 = head2 ; while ( temp1 && temp2 ) { if ( temp1 -> data == temp2 -> data ) { temp1 = temp1 -> next ; temp2 = temp2 -> next ; } else return 0 ; } if ( temp1 == NULL && temp2 == NULL ) return 1 ; return 0 ; } void push ( struct Node * * head_ref , char new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * ptr ) { while ( ptr != NULL ) { printf ( \" % c - > \" , ptr -> data ) ; ptr = ptr -> next ; } printf ( \" NULL STRNEWLINE \" ) ; } int main ( ) { struct Node * head = NULL ; char str [ ] = \" abacaba \" ; int i ; for ( i = 0 ; str [ i ] != ' \\0' ; i ++ ) { push ( & head , str [ i ] ) ; printList ( head ) ; isPalindrome ( head ) ? printf ( \" Is ▁ Palindrome STRNEWLINE STRNEWLINE \" ) : printf ( \" Not ▁ Palindrome STRNEWLINE STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "Swap nod dalam senarai yang dipautkan tanpa menukar data | Program ini menukar nod senarai yang dipautkan dan bukannya menukar medan dari nod. ; Berfungsi untuk menukar nod x dan y dalam senarai yang dipautkan dengan menukar pautan; Tiada apa -apa kaitan jika X dan Y adalah sama; Cari x (menjejaki prevx dan currx; cari y (menjejaki prevy dan kari; jika sama ada x atau y tidak hadir, tiada apa -apa yang perlu dilakukan; jika x bukan ketua senarai yang dipautkan; nod baru;", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void swapNodes ( struct Node * * head_ref , int x , int y ) { if ( x == y ) return ; struct Node * prevX = NULL , * currX = * head_ref ; while ( currX && currX -> data != x ) { prevX = currX ; currX = currX -> next ; } struct Node * prevY = NULL , * currY = * head_ref ; while ( currY && currY -> data != y ) { prevY = currY ; currY = currY -> next ; } if ( currX == NULL currY == NULL ) return ; if ( prevX != NULL ) prevX -> next = currY ; else * head_ref = currY ; if ( prevY != NULL ) prevY -> next = currX ; else * head_ref = currX ; struct Node * temp = currY -> next ; currY -> next = currX -> next ; currX -> next = temp ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * node ) { while ( node != NULL ) { printf ( \" % d ▁ \" , node -> data ) ; node = node -> next ; } } int main ( ) { struct Node * start = NULL ; push ( & start , 7 ) ; push ( & start , 6 ) ; push ( & start , 5 ) ; push ( & start , 4 ) ; push ( & start , 3 ) ; push ( & start , 2 ) ; push ( & start , 1 ) ; printf ( \" Linked list before calling swapNodes ( ) \" printList ( start ) ; swapNodes ( & start , 4 , 3 ) ; printf ( \" Linked list after calling swapNodes ( ) \" printList ( start ) ; return 0 ; }"}
{"text": "Elemen swap pasangan senarai yang dipautkan | Fungsi rekursif kepada elemen swap pasangan dari senarai yang dipautkan; Harus ada sekurang -kurangnya dua nod dalam senarai; Tukar data nod dengan data nod seterusnya; Hubungi PairWisesWap () untuk sisa senarai", "code": "void pairWiseSwap ( struct node * head ) { if ( head != NULL && head -> next != NULL ) { swap ( & head -> data , & head -> next -> data ) ; pairWiseSwap ( head -> next -> next ) ; } }"}
{"text": "Sisipan Sisipan untuk Senarai Berkaitan Pekeliling | Kes 2 dari algo di atas; Tukar bahagian data nod kepala dan nod baru dengan mengandaikan bahawa kita mempunyai swap fungsi (int *, int *)", "code": "else if ( current -> data >= new_node -> data ) { swap ( & ( current -> data ) , & ( new_node -> data ) ) ; new_node -> next = ( * head_ref ) -> next ; ( * head_ref ) -> next = new_node ; }"}
{"text": "Senarai Double Linked | Tetapkan 1 (Pengenalan dan Penyisipan) | Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala senarai dan int, memasukkan nod baru di bahagian depan senarai. ; 1. Peruntukkan nod * 2. Masukkan data; 3. Buat nod baru sebagai kepala dan sebelumnya sebagai batal; 4. Tukar Node kepala ke nod baru; 5. Gerakkan kepala ke arah nod baru", "code": "void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; new_node -> prev = NULL ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ; ( * head_ref ) = new_node ; }"}
{"text": "Senarai Double Linked | Tetapkan 1 (Pengenalan dan Penyisipan) | Memandangkan nod sebagai prev_node, masukkan nod baru selepas nod yang diberikan; 1. Semak jika prev_node yang diberikan adalah null; 2. Peruntukkan nod * 3. Masukkan data; 4. Buat nod baru seterusnya sebagai prev_node berikutnya; 5. Buat yang seterusnya dari prev_node sebagai new_node; 6. Buat prev_node seperti sebelumnya dari new_node; 7. Tukar sebelumnya dari nod seterusnya New_node", "code": "void insertAfter ( struct Node * prev_node , int new_data ) { if ( prev_node == NULL ) { printf ( \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" ) ; return ; } struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = prev_node -> next ; prev_node -> next = new_node ; new_node -> prev = prev_node ; if ( new_node -> next != NULL ) new_node -> next -> prev = new_node ; }"}
{"text": "Senarai Double Linked | Tetapkan 1 (Pengenalan dan Penyisipan) | Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala DLL dan int, tambah nod baru pada akhir; 1. Peruntukkan nod 2. Masukkan data; 3. Nod baru ini akan menjadi nod terakhir, jadi buatlah seterusnya sebagai batal; 4. Jika senarai yang dipautkan kosong, maka buat nod baru sebagai kepala; 5. Lain -lain melintasi sehingga nod terakhir; 6. Tukar nod terakhir yang berikutnya; 7. Buat nod terakhir seperti sebelumnya dari nod baru", "code": "void append ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * last = * head_ref ; new_node -> data = new_data ; new_node -> next = NULL ; if ( * head_ref == NULL ) { new_node -> prev = NULL ; * head_ref = new_node ; return ; } while ( last -> next != NULL ) last = last -> next ; last -> next = new_node ; new_node -> prev = last ; return ; }"}
{"text": "Sisipan Sisipan dalam Senarai Terkait Dipable dengan Pointers Head and Tail | Program C ke Node Insetail dalam senarai yang dikaitkan dua kali ganda supaya senarai itu tetap dalam urutan menaik pada percetakan dari kiri ke kanan; Nod senarai yang dipautkan; Berfungsi untuk menggembirakan nod baru; Jika nod pertama disesuaikan dalam senarai dikaitkan dua kali ganda; Jika nod yang dimasukkan mempunyai nilai kurang daripada nod pertama; Jika nod yang dimasukkan mempunyai nilai lebih daripada nod terakhir; Cari nod yang sebelum ini kita perlu memasukkan p. ; Masukkan nod baru sebelum temp; Berfungsi untuk mencetak nod dari kiri ke kanan; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { struct Node * prev ; int info ; struct Node * next ; } ; void nodeInsetail ( struct Node * * head , struct Node * * tail , int key ) { struct Node * p = new Node ; p -> info = key ; p -> next = NULL ; if ( ( * head ) == NULL ) { ( * head ) = p ; ( * tail ) = p ; ( * head ) -> prev = NULL ; return ; } if ( ( p -> info ) < ( ( * head ) -> info ) ) { p -> prev = NULL ; ( * head ) -> prev = p ; p -> next = ( * head ) ; ( * head ) = p ; return ; } if ( ( p -> info ) > ( ( * tail ) -> info ) ) { p -> prev = ( * tail ) ; ( * tail ) -> next = p ; ( * tail ) = p ; return ; } temp = ( * head ) -> next ; while ( ( temp -> info ) < ( p -> info ) ) temp = temp -> next ; ( temp -> prev ) -> next = p ; p -> prev = temp -> prev ; temp -> prev = p ; p -> next = temp ; } void printList ( struct Node * temp ) { while ( temp != NULL ) { printf ( \" % d ▁ \" , temp -> info ) ; temp = temp -> next ; } } int main ( ) { struct Node * left = NULL , * right = NULL ; nodeInsetail ( & left , & right , 30 ) ; nodeInsetail ( & left , & right , 50 ) ; nodeInsetail ( & left , & right , 90 ) ; nodeInsetail ( & left , & right , 10 ) ; nodeInsetail ( & left , & right , 40 ) ; nodeInsetail ( & left , & right , 110 ) ; nodeInsetail ( & left , & right , 60 ) ; nodeInsetail ( & left , & right , 95 ) ; nodeInsetail ( & left , & right , 23 ) ; printf ( \" Doubly linked list on printing \" ▁ \" from left to right \" printList ( left ) ; return 0 ; }"}
{"text": "Amalan Soalan untuk Senarai dan Rekursi Berkaitan |", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Amalan Soalan untuk Senarai dan Rekursi Berkaitan |", "code": "void fun1 ( struct Node * head ) { if ( head == NULL ) return ; fun1 ( head -> next ) ; printf ( \" % d ▁ \" , head -> data ) ; }"}
{"text": "Amalan Soalan untuk Senarai dan Rekursi Berkaitan |", "code": "void fun2 ( struct Node * head ) { if ( head == NULL ) return ; printf ( \" % d ▁ \" , head -> data ) ; if ( head -> next != NULL ) fun2 ( head -> next -> next ) ; printf ( \" % d ▁ \" , head -> data ) ; }"}
{"text": "Amalan Soalan untuk Senarai dan Rekursi Berkaitan |  ; Nod senarai yang dipautkan; Mencetak senarai yang dipautkan secara terbalik; Cetak nod alternatif senarai yang dipautkan, pertama dari kepala ke hujung, dan kemudian dari hujung ke kepala. ; Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala senarai dan int, tolak nod baru di hadapan senarai. ; memperuntukkan nod; masukkan data; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Program pemacu untuk menguji fungsi di atas; Mulakan dengan senarai kosong; Menggunakan PUSH () untuk membina di bawah Senarai 1 -> 2 -> 3 -> 4 -> 5", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void fun1 ( struct Node * head ) { if ( head == NULL ) return ; fun1 ( head -> next ) ; printf ( \" % d ▁ \" , head -> data ) ; } void fun2 ( struct Node * start ) { if ( start == NULL ) return ; printf ( \" % d ▁ \" , start -> data ) ; if ( start -> next != NULL ) fun2 ( start -> next -> next ) ; printf ( \" % d ▁ \" , start -> data ) ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * head = NULL ; push ( & head , 5 ) ; push ( & head , 4 ) ; push ( & head , 3 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; printf ( \" Output ▁ of ▁ fun1 ( ) ▁ for ▁ list ▁ 1 - > 2 - > 3 - > 4 - > 5 ▁ STRNEWLINE \" ) ; fun1 ( head ) ; printf ( \" Output of fun2 ( ) for list 1 -> 2 -> 3 -> 4 -> 5 \" fun2 ( head ) ; getchar ( ) ; return 0 ; }"}
{"text": "Squareroot (n) | Program c untuk mencari nod sqrt (n) 'th senarai yang dipautkan; Nod senarai yang dipautkan; Berfungsi untuk mendapatkan nod sqrt (n) dari senarai yang dipautkan; Melintasi senarai; Semak jika j = sqrt (i); untuk nod pertama; kenaikan j jika j = sqrt (i); Data Node kembali; berfungsi untuk menambah nod baru pada permulaan senarai; memperuntukkan nod; masukkan data; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Program pemacu untuk menguji fungsi di atas; Mulakan dengan senarai kosong", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; int printsqrtn ( struct Node * head ) { struct Node * sqrtn = NULL ; int i = 1 , j = 1 ; while ( head != NULL ) { if ( i == j * j ) { if ( sqrtn == NULL ) sqrtn = head ; else sqrtn = sqrtn -> next ; j ++ ; } i ++ ; head = head -> next ; } return sqrtn -> data ; } void print ( struct Node * head ) { while ( head != NULL ) { printf ( \" % d ▁ \" , head -> data ) ; head = head -> next ; } printf ( \" STRNEWLINE \" ) ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * head = NULL ; push ( & head , 40 ) ; push ( & head , 30 ) ; push ( & head , 20 ) ; push ( & head , 10 ) ; printf ( \" Given ▁ linked ▁ list ▁ is : \" ) ; print ( head ) ; printf ( \" sqrt ( n ) th ▁ node ▁ is ▁ % d ▁ \" , printsqrtn ( head ) ) ; return 0 ; }"}
{"text": "Cari nod dengan nilai minimum dalam pokok carian binari |  ; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Berikan pokok carian binari dan nombor, masukkan nod baru dengan nombor yang diberikan di tempat yang betul di dalam pokok. Mengembalikan penunjuk akar baru yang kemudiannya pemanggil harus menggunakan (helah standard untuk mengelakkan menggunakan parameter rujukan). ; 1. Jika pokok itu kosong, kembalikan nod tunggal baru; 2. Jika tidak, berulang pokok; Kembalikan penunjuk nod (tidak berubah); Memandangkan pokok carian binari yang tidak kosong, kembalikan nilai data minimum yang terdapat di dalam pokok itu. Perhatikan bahawa seluruh pokok tidak perlu dicari. ; gelung ke bawah untuk mencari daun paling kiri; Program pemacu untuk menguji fungsi sametree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } struct node * insert ( struct node * node , int data ) { if ( node == NULL ) return ( newNode ( data ) ) ; else { if ( data <= node -> data ) node -> left = insert ( node -> left , data ) ; else node -> right = insert ( node -> right , data ) ; return node ; } } int minValue ( struct node * node ) { struct node * current = node ; while ( current -> left != NULL ) { current = current -> left ; } return ( current -> data ) ; } int main ( ) { struct node * root = NULL ; root = insert ( root , 4 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 6 ) ; insert ( root , 5 ) ; printf ( \" Minimum value in BST is % d \" , minValue ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Membina pokok dari Inorder dan Preorder Traversals | program untuk membina pokok menggunakan inorder dan preorder traversals; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Prototaip untuk fungsi utiliti; Fungsi rekursif untuk membina binari saiz len dari inorder traversal dalam [] dan preorder traversal pre []. Nilai awal instruk dan inend hendaklah 0 dan len - 1. Fungsi tidak melakukan apa -apa ralat untuk kes di mana inorder dan preorder tidak membentuk pokok; Pilih nod semasa dari preorder traversal menggunakan preindex dan preindex kenaikan; Jika nod ini tidak mempunyai anak, maka kembali; Lain mencari indeks nod ini dalam traversal inorder; Menggunakan indeks dalam traversal inorder, membina substruktur kiri dan kanan; Fungsi untuk mencari indeks nilai dalam arr [mula ... akhir] Fungsi mengandaikan bahawa nilai ada di dalam []; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Funtcion ini di sini hanya untuk menguji BuildTree (); pertama berulang pada anak kiri; kemudian cetak data nod; sekarang berulang pada anak yang betul; Program pemacu untuk menguji fungsi di atas; Mari kita uji pokok yang dibina dengan mencetak Traversal Insorder", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { char data ; struct node * left ; struct node * right ; } ; int search ( char arr [ ] , int strt , int end , char value ) ; struct node * newNode ( char data ) ; struct node * buildTree ( char in [ ] , char pre [ ] , int inStrt , int inEnd ) { static int preIndex = 0 ; if ( inStrt > inEnd ) return NULL ; struct node * tNode = newNode ( pre [ preIndex ++ ] ) ; if ( inStrt == inEnd ) return tNode ; int inIndex = search ( in , inStrt , inEnd , tNode -> data ) ; tNode -> left = buildTree ( in , pre , inStrt , inIndex - 1 ) ; tNode -> right = buildTree ( in , pre , inIndex + 1 , inEnd ) ; return tNode ; } int search ( char arr [ ] , int strt , int end , char value ) { int i ; for ( i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) return i ; } } struct node * newNode ( char data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % c ▁ \" , node -> data ) ; printInorder ( node -> right ) ; } int main ( ) { char in [ ] = { ' D ' , ' B ' , ' E ' , ' A ' , ' F ' , ' C ' } ; char pre [ ] = { ' A ' , ' B ' , ' D ' , ' E ' , ' C ' , ' F ' } ; int len = sizeof ( in ) / sizeof ( in [ 0 ] ) ; struct node * root = buildTree ( in , pre , 0 , len - 1 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ constructed ▁ tree ▁ is ▁ STRNEWLINE \" ) ; printInorder ( root ) ; getchar ( ) ; }"}
{"text": "Nenek moyang yang paling rendah dalam pokok carian binari. | Program C Rekursif untuk mencari LCA dua nod N1 dan N2. ; Fungsi untuk mencari LCA N1 dan N2. Fungsi ini mengandaikan bahawa kedua -dua N1 dan N2 hadir di BST; Jika kedua -dua N1 dan N2 lebih kecil daripada akar, maka LCA terletak di sebelah kiri; Jika kedua -dua N1 dan N2 lebih besar daripada akar, maka LCA terletak di sebelah kanan; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan. ; Program pemandu untuk menguji LCA (); Mari kita buat BST yang ditunjukkan dalam angka di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * lca ( struct node * root , int n1 , int n2 ) { while ( root != NULL ) { if ( root -> data > n1 && root -> data > n2 ) root = root -> left ; else if ( root -> data < n1 && root -> data < n2 ) root = root -> right ; else break ; } return root ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 22 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; int n1 = 10 , n2 = 14 ; struct node * t = lca ( root , n1 , n2 ) ; printf ( \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , n1 , n2 , t -> data ) ; n1 = 14 , n2 = 8 ; t = lca ( root , n1 , n2 ) ; printf ( \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , n1 , n2 , t -> data ) ; n1 = 10 , n2 = 22 ; t = lca ( root , n1 , n2 ) ; printf ( \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , n1 , n2 , t -> data ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program untuk memeriksa sama ada pokok binari adalah bst atau tidak |  ; palsu jika dibiarkan adalah> daripada nod; palsu jika betul adalah <daripada nod; palsu jika, secara rekursif, kiri atau kanan bukan BST; melewati semua itu, ia adalah bst", "code": "int isBST ( struct node * node ) { if ( node == NULL ) return 1 ; if ( node -> left != NULL && node -> left -> data > node -> data ) return 0 ; if ( node -> right != NULL && node -> right -> data < node -> data ) return 0 ; if ( ! isBST ( node -> left ) || ! isBST ( node -> right ) ) return 0 ; return 1 ; }"}
{"text": "Program untuk memeriksa sama ada pokok binari adalah bst atau tidak | Mengembalikan benar jika pokok binari adalah pokok carian binari; palsu jika max di sebelah kiri adalah> daripada kita; palsu jika min dari kanan adalah <= daripada kita; palsu jika, secara rekursif, kiri atau kanan bukan BST; melewati semua itu, ia adalah bst", "code": "int isBST ( struct node * node ) { if ( node == NULL ) return 1 ; if ( node -> left != NULL && maxValue ( node -> left ) > node -> data ) return 0 ; if ( node -> right != NULL && minValue ( node -> right ) < node -> data ) return 0 ; if ( ! isBST ( node -> left ) || ! isBST ( node -> right ) ) return 0 ; return 1 ; }"}
{"text": "Semak jika setiap nod dalaman BST mempunyai satu anak yang betul | Semak jika setiap nod dalaman BST hanya mempunyai satu anak; program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE bool hasOnlyOneChild ( int pre [ ] , int size ) { int nextDiff , lastDiff ; for ( int i = 0 ; i < size - 1 ; i ++ ) { nextDiff = pre [ i ] - pre [ i + 1 ] ; lastDiff = pre [ i ] - pre [ size - 1 ] ; if ( nextDiff * lastDiff < 0 ) return false ; ; } return true ; } int main ( ) { int pre [ ] = { 8 , 3 , 5 , 7 , 6 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; if ( hasOnlyOneChild ( pre , size ) == true ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Semak jika setiap nod dalaman BST mempunyai satu anak yang betul | Semak jika setiap nod dalaman BST hanya mempunyai satu anak; Memulakan min dan max menggunakan dua elemen terakhir; Setiap elemen mestilah lebih kecil daripada min atau lebih besar daripada max; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int hasOnlyOneChild ( int pre [ ] , int size ) { int min , max ; if ( pre [ size - 1 ] > pre [ size - 2 ] ) { max = pre [ size - 1 ] ; min = pre [ size - 2 ] ) : else { max = pre [ size - 2 ] ; min = pre [ size - 1 ] ; } for ( int i = size - 3 ; i >= 0 ; i -- ) { if ( pre [ i ] < min ) min = pre [ i ] ; else if ( pre [ i ] > max ) max = pre [ i ] ; else return false ; } return true ; } int main ( ) { int pre [ ] = { 8 , 3 , 5 , 7 , 6 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; if ( hasOnlyOneChild ( pre , size ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "AVL dengan kunci pendua | C ++ Program Pokok AVL yang mengendalikan pendua; Nod pokok AVL; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Fungsi utiliti untuk mendapatkan ketinggian pokok; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Fungsi pembantu yang memperuntukkan nod baru dengan kunci yang diberikan dan null kiri dan kanan. ; Nod baru pada mulanya ditambah pada daun; Fungsi utiliti ke kanan berputar subtree yang berakar dengan y lihat rajah yang diberikan di atas. ; Melakukan putaran; Mengemas kini ketinggian; Mengembalikan akar baru; Fungsi utiliti ke kiri berputar subtree yang berakar dengan x lihat rajah yang diberikan di atas. ; Melakukan putaran; Mengemas kini ketinggian; Mengembalikan akar baru; Dapatkan faktor keseimbangan nod n; 1. Melaksanakan putaran BST biasa; Jika kunci sudah ada di BST, kiraan kenaikan dan pulangan; Jika tidak, mengulangi pokok itu; 2. Kemas kini ketinggian nod nenek moyang ini; 3. Dapatkan faktor keseimbangan nod nenek moyang ini untuk memeriksa sama ada nod ini menjadi tidak seimbang; Jika nod ini menjadi tidak seimbang, maka terdapat 4 kes kiri kes kiri; Kes yang betul; Kes Kanan Kiri; Kes kiri kanan; Kembalikan penunjuk nod (tidak berubah); Memandangkan pokok carian binari yang tidak kosong, kembalikan nod dengan nilai kunci minimum yang terdapat di dalam pokok itu. Perhatikan bahawa seluruh pokok tidak perlu dicari. ; gelung ke bawah untuk mencari daun paling kiri; Langkah 1: Lakukan Padam BST Standard; Jika kunci untuk dipadam lebih kecil daripada kekunci akar, maka ia terletak di subtree kiri; Jika kunci untuk dipadam adalah lebih besar daripada kunci akar, maka ia terletak pada subtree kanan; Jika kunci adalah sama dengan kunci Root, maka ini adalah nod yang akan dipadam; Jika kunci hadir lebih dari sekali, hanya pengurangan kiraan dan pulangan; Lain, padamkan nod nod dengan hanya satu kanak -kanak atau tiada anak; Tiada kes kanak -kanak; Satu kes kanak -kanak; Salin kandungan kanak -kanak yang tidak kosong; Node dengan dua kanak -kanak: Dapatkan pengganti inorder (terkecil di subtree kanan); Salin data pengganti Inorder ke nod ini dan mengemas kini kiraan; Padam pengganti inorder; Jika pokok itu hanya mempunyai satu nod maka kembali; Langkah 2: Kemas kini ketinggian nod semasa; Langkah 3: Dapatkan faktor keseimbangan nod ini (untuk memeriksa sama ada nod ini menjadi tidak seimbang); Jika nod ini menjadi tidak seimbang, maka terdapat 4 kes kiri kes kiri; Kes Kanan Kiri; Kes yang betul; Kes kiri kanan; Fungsi utiliti untuk mencetak preorder traversal pokok. Fungsi ini juga mencetak ketinggian setiap nod; Program pemacu untuk menguji fungsi di atas; Membina pokok yang diberikan dalam angka di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; struct node * left ; struct node * right ; int height ; int count ; } ; int max ( int a , int b ) ; int height ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> height ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ; node -> height = 1 ; node -> count = 1 ; return ( node ) ; } struct node * rightRotate ( struct node * y ) { struct node * x = y -> left ; struct node * T2 = x -> right ; x -> right = y ; y -> left = T2 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; return x ; } struct node * leftRotate ( struct node * x ) { struct node * y = x -> right ; struct node * T2 = y -> left ; y -> left = x ; x -> right = T2 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; return y ; } int getBalance ( struct node * N ) { if ( N == NULL ) return 0 ; return height ( N -> left ) - height ( N -> right ) ; } struct node * insert ( struct node * node , int key ) { if ( node == NULL ) return ( newNode ( key ) ) ; if ( key == node -> key ) { ( node -> count ) ++ ; return node ; } if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ; node -> height = max ( height ( node -> left ) , height ( node -> right ) ) + 1 ; int balance = getBalance ( node ) ; if ( balance > 1 && key < node -> left -> key ) return rightRotate ( node ) ; if ( balance < -1 && key > node -> right -> key ) return leftRotate ( node ) ; if ( balance > 1 && key > node -> left -> key ) { node -> left = leftRotate ( node -> left ) ; return rightRotate ( node ) ; } if ( balance < -1 && key < node -> right -> key ) { node -> right = rightRotate ( node -> right ) ; return leftRotate ( node ) ; } return node ; } struct node * minValueNode ( struct node * node ) { struct node * current = node ; while ( current -> left != NULL ) current = current -> left ; return current ; } struct node * deleteNode ( struct node * root , int key ) { if ( root == NULL ) return root ; if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ; else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ; else { if ( root -> count > 1 ) { ( root -> count ) -- ; return ; } if ( ( root -> left == NULL ) || ( root -> right == NULL ) ) { struct node * temp = root -> left ? root -> left : root -> right ; if ( temp == NULL ) { temp = root ; root = NULL ; } else * root = * temp ; free ( temp ) ; } else { struct node * temp = minValueNode ( root -> right ) ; root -> key = temp -> key ; root -> count = temp -> count ; temp -> count = 1 ; root -> right = deleteNode ( root -> right , temp -> key ) ; } } if ( root == NULL ) return root ; root -> height = max ( height ( root -> left ) , height ( root -> right ) ) + 1 ; int balance = getBalance ( root ) ; if ( balance > 1 && getBalance ( root -> left ) >= 0 ) return rightRotate ( root ) ; if ( balance > 1 && getBalance ( root -> left ) < 0 ) { root -> left = leftRotate ( root -> left ) ; return rightRotate ( root ) ; } if ( balance < -1 && getBalance ( root -> right ) <= 0 ) return leftRotate ( root ) ; if ( balance < -1 && getBalance ( root -> right ) > 0 ) { root -> right = rightRotate ( root -> right ) ; return leftRotate ( root ) ; } return root ; } void preOrder ( struct node * root ) { if ( root != NULL ) { printf ( \" % d ( % d ) ▁ \" , root -> key , root -> count ) ; preOrder ( root -> left ) ; preOrder ( root -> right ) ; } } int main ( ) { struct node * root = NULL ; root = insert ( root , 9 ) ; root = insert ( root , 5 ) ; root = insert ( root , 10 ) ; root = insert ( root , 5 ) ; root = insert ( root , 9 ) ; root = insert ( root , 7 ) ; root = insert ( root , 17 ) ; printf ( \" Pre ▁ order ▁ traversal ▁ of ▁ the ▁ constructed ▁ AVL ▁ tree ▁ is ▁ STRNEWLINE \" ) ; preOrder ( root ) ; root = deleteNode ( root , 9 ) ; printf ( \" Pre order traversal after deletion of 9 \" preOrder ( root ) ; return 0 ; }"}
{"text": "Pengganti Inorder dalam Pokok Carian Binari |  ; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Berikan pokok carian binari dan nombor, masukkan nod baru dengan nombor yang diberikan di tempat yang betul di dalam pokok. Mengembalikan penunjuk akar baru yang kemudiannya pemanggil harus menggunakan (helah standard untuk mengelakkan menggunakan parameter rujukan). ; 1. Jika pokok itu kosong, kembalikan nod tunggal baru; 2. Jika tidak, berulang pokok; Kembalikan penunjuk nod (tidak berubah); Langkah 1 algoritma di atas; Langkah 2 algoritma di atas; Memandangkan pokok carian binari yang tidak kosong, kembalikan nilai data minimum yang terdapat di dalam pokok itu. Perhatikan bahawa seluruh pokok tidak perlu dicari. ; gelung ke bawah untuk mencari daun paling kiri; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; struct node * parent ; } ; struct node * minValue ( struct node * node ) ; struct node * insert ( struct node * node , int data ) { if ( node == NULL ) return ( newNode ( data ) ) ; else { struct node * temp ; if ( data <= node -> data ) { temp = insert ( node -> left , data ) ; node -> left = temp ; temp -> parent = node ; } else { temp = insert ( node -> right , data ) ; node -> right = temp ; temp -> parent = node ; } return node ; } } struct node * inOrderSuccessor ( struct node * root , struct node * n ) { if ( n -> right != NULL ) return minValue ( n -> right ) ; struct node * p = n -> parent ; while ( p != NULL && n == p -> right ) { n = p ; p = p -> parent ; } return p ; } struct node * minValue ( struct node * node ) { struct node * current = node ; while ( current -> left != NULL ) { current = current -> left ; } return current ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> parent = NULL ; return ( node ) ; } int main ( ) { struct node * root = NULL , * temp , * succ , * min ; root = insert ( root , 20 ) ; root = insert ( root , 8 ) ; root = insert ( root , 22 ) ; root = insert ( root , 4 ) ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 14 ) ; temp = root -> left -> right -> right ; succ = inOrderSuccessor ( root , temp ) ; if ( succ != NULL ) printf ( \" Inorder Successor of % d is % d \" , temp -> data , succ -> data ) ; else printf ( \" Inorder Successor doesn ' exit \" getchar ( ) ; return 0 ; }"}
{"text": "Tiga nombor dalam BST yang menambah sehingga sifar | Program C untuk memeriksa sama ada terdapat triplet dengan jumlah yang sama dengan 0 dalam BST yang diberikan; Nod BST mempunyai kunci, dan penunjuk kiri dan kanan; Fungsi untuk menukar BST diberikan kepada senarai dikaitkan dua kali ganda. Penunjuk kiri digunakan sebagai penunjuk sebelumnya dan penunjuk kanan digunakan sebagai penunjuk seterusnya. Fungsi menetapkan * kepala ke arah pertama dan * ekor untuk menunjuk ke nod terakhir DLL yang ditukar; Kes asas; Pertama menukar subtree kiri; Kemudian tukar kiri akar semasa sebagai nod terakhir subtree kiri; Jika ekor tidak null, kemudian tetapkan kanan ekor sebagai akar, nod semasa yang lain adalah kepala; Kemas kini ekor; Akhirnya, tukar subtree kanan; Fungsi ini kembali benar jika terdapat pasangan dalam DLL dengan jumlah yang sama dengan jumlah yang diberikan. Algoritma ini serupa dengan HasArrayTWocandIdates () TinyUrl. com / dy6palr dalam kaedah 1 http :; Fungsi utama yang kembali benar jika terdapat triplet 0 jumlah di BST sebaliknya mengembalikan palsu; Semak sama ada BST yang diberikan kosong; Tukar diberikan BST ke senarai dikaitkan dua kali ganda. kepala dan ekor menyimpan petunjuk ke nod pertama dan terakhir di DLLL; Sekarang berulang melalui setiap nod dan dapatkan jika ada pasangan dengan jumlah yang sama dengan - 1 * HEAF -> Kunci di mana kepala adalah nod semasa; Sekiranya terdapat pasangan dengan jumlah yang sama dengan - 1 * kepala -> kunci, maka kembali benar lain bergerak ke hadapan; Jika kita sampai di sini, maka tidak ada triplet 0 jumlah; Fungsi utiliti untuk membuat nod BST baru dengan kunci seperti yang diberikan NUM; Fungsi utiliti untuk memasukkan kunci yang diberikan kepada BST; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE struct node { int key ; struct node * left ; struct node * right ; } ; void convertBSTtoDLL ( node * root , node * * head , node * * tail ) { if ( root == NULL ) return ; if ( root -> left ) convertBSTtoDLL ( root -> left , head , tail ) ; root -> left = * tail ; if ( * tail ) ( * tail ) -> right = root ; else * head = root ; * tail = root ; if ( root -> right ) convertBSTtoDLL ( root -> right , head , tail ) ; } bool isPresentInDLL ( node * head , node * tail , int sum ) { while ( head != tail ) { int curr = head -> key + tail -> key ; if ( curr == sum ) return true ; else if ( curr > sum ) tail = tail -> left ; else head = head -> right ; } return false ; } bool isTripletPresent ( node * root ) { if ( root == NULL ) return false ; node * head = NULL ; node * tail = NULL ; convertBSTtoDLL ( root , & head , & tail ) ; while ( ( head -> right != tail ) && ( head -> key < 0 ) ) { if ( isPresentInDLL ( head -> right , tail , -1 * head -> key ) ) return true ; else head = head -> right ; } return false ; } node * newNode ( int num ) { node * temp = new node ; temp -> key = num ; temp -> left = temp -> right = NULL ; return temp ; } node * insert ( node * root , int key ) { if ( root == NULL ) return newNode ( key ) ; if ( root -> key > key ) root -> left = insert ( root -> left , key ) ; else root -> right = insert ( root -> right , key ) ; return root ; } int main ( ) { node * root = NULL ; root = insert ( root , 6 ) ; root = insert ( root , -13 ) ; root = insert ( root , 14 ) ; root = insert ( root , -8 ) ; root = insert ( root , 15 ) ; root = insert ( root , 13 ) ; root = insert ( root , 7 ) ; if ( isTripletPresent ( root ) ) printf ( \" Present \" ) ; else printf ( \" Not ▁ Present \" ) ; return 0 ; }"}
{"text": "Cari pasangan dengan jumlah yang diberikan dalam BST yang seimbang | Dalam pokok carian binari yang seimbang ispairpresent dua elemen yang merangkumi masa nilai tertentu o (n) ruang o (logn); Nod BST; Jenis stack; Fungsi utiliti untuk membuat timbunan saiz yang diberikan; Operasi asas timbunan; Pulangan benar jika pasangan dengan jumlah sasaran wujud di BST, jika tidak palsu; Buat dua susunan. S1 digunakan untuk traversal inorder biasa dan S2 digunakan untuk traversal inorder terbalik; Perhatikan saiz susunan adalah max_size, kita dapat mencari saiz pokok dan menetapkan saiz timbunan sebagai o (logn) untuk pokok seimbang seperti AVL dan pokok hitam merah. Kami telah menggunakan max_size untuk memastikan kod mudah dilakukan1, val1 dan curr1 digunakan untuk traversal inorder biasa menggunakan S1 DONSE2, VAL2 dan CURR2 digunakan untuk traversal inorder terbalik menggunakan S2; Gelung akan pecah apabila kita sama ada mencari pasangan atau salah satu daripada dua traversals selesai; Cari nod seterusnya dalam traversal inorder biasa. Lihat Posting berikut www. Geeksforgeeks. org / inorder - pokok - traversal - tanpa - rekursi / https :; Cari nod seterusnya dalam traversal inorder terbalik. Satu -satunya perbezaan di antara gelung di atas dan di bawah adalah, di bawah gelung kanan subtree dilalui sebelum subtree kiri; Jika kita mencari pasangan, kemudian cetak pasangan dan kembali. Keadaan pertama memastikan bahawa dua nilai yang sama tidak ditambah; Jika jumlah nilai semasa lebih kecil, maka bergerak ke nod seterusnya dalam traversal inorder biasa; Jika jumlah nilai semasa lebih besar, maka bergerak ke nod seterusnya dalam traversal inorder terbalik; Jika mana -mana traversals inorder berakhir, maka tidak ada pasangan sehingga kembali palsu; Fungsi utiliti untuk membuat nod BST; Program pemacu untuk menguji fungsi di atas; 15 / \\ 10 20 / \\ / \\ 8 12 16 25", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define MAX_SIZE  100 NEW_LINE struct node { int val ; struct node * left , * right ; } ; struct Stack { int size ; int top ; struct node * * array ; } ; struct Stack * createStack ( int size ) { struct Stack * stack = ( struct Stack * ) malloc ( sizeof ( struct Stack ) ) ; stack -> size = size ; stack -> top = -1 ; stack -> array = ( struct node * * ) malloc ( stack -> size * sizeof ( struct node * ) ) ; return stack ; } int isFull ( struct Stack * stack ) { return stack -> top - 1 == stack -> size ; } int isEmpty ( struct Stack * stack ) { return stack -> top == -1 ; } void push ( struct Stack * stack , struct node * node ) { if ( isFull ( stack ) ) return ; stack -> array [ ++ stack -> top ] = node ; } struct node * pop ( struct Stack * stack ) { if ( isEmpty ( stack ) ) return NULL ; return stack -> array [ stack -> top -- ] ; } bool isPairPresent ( struct node * root , int target ) { struct Stack * s1 = createStack ( MAX_SIZE ) ; struct Stack * s2 = createStack ( MAX_SIZE ) ; bool done1 = false , done2 = false ; int val1 = 0 , val2 = 0 ; struct node * curr1 = root , * curr2 = root ; while ( 1 ) { while ( done1 == false ) { if ( curr1 != NULL ) { push ( s1 , curr1 ) ; curr1 = curr1 -> left ; } else { if ( isEmpty ( s1 ) ) done1 = 1 ; else { curr1 = pop ( s1 ) ; val1 = curr1 -> val ; curr1 = curr1 -> right ; done1 = 1 ; } } } while ( done2 == false ) { if ( curr2 != NULL ) { push ( s2 , curr2 ) ; curr2 = curr2 -> right ; } else { if ( isEmpty ( s2 ) ) done2 = 1 ; else { curr2 = pop ( s2 ) ; val2 = curr2 -> val ; curr2 = curr2 -> left ; done2 = 1 ; } } } if ( ( val1 != val2 ) && ( val1 + val2 ) == target ) { printf ( \" Pair Found : % d + % d = % d \" , val1 , val2 , target ) ; return true ; } else if ( ( val1 + val2 ) < target ) done1 = false ; else if ( ( val1 + val2 ) > target ) done2 = false ; if ( val1 >= val2 ) return false ; } } struct node * NewNode ( int val ) { struct node * tmp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; tmp -> val = val ; tmp -> right = tmp -> left = NULL ; return tmp ; } int main ( ) { struct node * root = NewNode ( 15 ) ; root -> left = NewNode ( 10 ) ; root -> right = NewNode ( 20 ) ; root -> left -> left = NewNode ( 8 ) ; root -> left -> right = NewNode ( 12 ) ; root -> right -> left = NewNode ( 16 ) ; root -> right -> right = NewNode ( 25 ) ; int target = 33 ; if ( isPairPresent ( root , target ) == false ) printf ( \" No such values are found \" getchar ( ) ; return 0 ; }"}
{"text": "Left Leaning Pokok Hitam Merah (Sisipan) | Program C untuk melaksanakan operasi sisipan dalam pokok hitam merah. ; merah ==> benar, hitam ==> palsu; Nod baru yang dicipta sentiasa berwarna merah. ; Fungsi utiliti untuk memutar nod anti -lawan jam. ; fungsi utiliti untuk memutar nod mengikut arah jam. ; Fungsi utiliti untuk memeriksa sama ada nod berwarna merah atau tidak. ; Fungsi utiliti untuk menukar warna dua nod. ; Sisipan ke dalam pokok hitam merah yang bersandar kiri. ; Kod penyisipan biasa untuk mana -mana pokok carian binari. ; Kes 1. Apabila anak yang betul merah tetapi anak kiri adalah hitam atau tidak ada. ; Kiri berputar nod untuk menjadikannya struktur yang sah. ; Tukar warna sebagai nod kanak -kanak harus selalu merah; kes 2 apabila anak kiri serta anak kecil kiri merah; Putar kanan nod semasa untuk menjadikannya struktur yang sah. ; Kes 3 Apabila kedua -dua anak kiri dan kanan berwarna merah. ; Balikkan warna nod serta anak kiri dan kanan. ; Tukar warna menjadi hitam. ; Inorder traversal; Fungsi pemacu; LLRB Tree dibuat selepas semua penyisipan dibuat. 1. Nod yang mempunyai kelebihan masuk dua kali ganda bermakna warna merah. 2. Nod yang mempunyai kelebihan masuk tunggal bermakna bahawa mereka berwarna hitam. akar | 40 \\ 20 50 / \\ 10 30 25; Untuk memastikan bahawa akar kekal hitam adalah warna; Paparkan pokok melalui traversal inorder.", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE typedef struct node { struct node * left , * right ; int data ; bool color ; } node ; node * createNode ( int data , bool color ) { node * myNode = ( node * ) malloc ( sizeof ( node ) ) ; myNode -> left = myNode -> right = NULL ; myNode -> data = data ; myNode -> color = true ; return myNode ; } node * rotateLeft ( node * myNode ) { printf ( \" left ▁ rotation ! ! STRNEWLINE \" ) ; node * child = myNode -> right ; node * childLeft = child -> left ; child -> left = myNode ; myNode -> right = childLeft ; return child ; } node * rotateRight ( node * myNode ) { printf ( \" right ▁ rotation STRNEWLINE \" ) ; node * child = myNode -> left ; node * childRight = child -> right ; child -> right = myNode ; myNode -> left = childRight ; return child ; } int isRed ( node * myNode ) { if ( myNode == NULL ) return 0 ; return ( myNode -> color == true ) ; } void swapColors ( node * node1 , node * node2 ) { bool temp = node1 -> color ; node1 -> color = node2 -> color ; node2 -> color = temp ; } node * insert ( node * myNode , int data ) { if ( myNode == NULL ) return createNode ( data , false ) ; if ( data < myNode -> data ) myNode -> left = insert ( myNode -> left , data ) ; else if ( data > myNode -> data ) myNode -> right = insert ( myNode -> right , data ) ; else return myNode ; if ( isRed ( myNode -> right ) && ! isRed ( myNode -> left ) ) { myNode = rotateLeft ( myNode ) ; swapColors ( myNode , myNode -> left ) ; } if ( isRed ( myNode -> left ) && isRed ( myNode -> left -> left ) ) { myNode = rotateRight ( myNode ) ; swapColors ( myNode , myNode -> right ) ; } if ( isRed ( myNode -> left ) && isRed ( myNode -> right ) ) { myNode -> color = ! myNode -> color ; myNode -> left -> color = false ; myNode -> right -> color = false ; } return myNode ; } void inorder ( node * node ) { if ( node ) { inorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; inorder ( node -> right ) ; } } int main ( ) { node * root = NULL ; root = insert ( root , 10 ) ; root -> color = false ; root = insert ( root , 20 ) ; root -> color = false ; root = insert ( root , 30 ) ; root -> color = false ; root = insert ( root , 40 ) ; root -> color = false ; root = insert ( root , 50 ) ; root -> color = false ; root = insert ( root , 25 ) ; root -> color = false ; inorder ( root ) ; return 0 ; }"}
{"text": "Pokok binari yang diulurkan | Fungsi utiliti untuk mencari nod paling kiri dalam pokok yang berakar dengan n; C Kod untuk melakukan inorder traversal dalam pokok binari berulir; Jika nod ini adalah nod benang, maka pergi ke pengganti inorder; Lain pergi ke anak paling kiri di sebelah kanan; subtree", "code": "struct Node * leftMost ( struct Node * n ) { if ( n == NULL ) return NULL ; while ( n -> left != NULL ) n = n -> left ; return n ; } void inOrder ( struct Node * root ) { struct Node * cur = leftMost ( root ) ; while ( cur != NULL ) { printf ( \" % d ▁ \" , cur -> data ) ; if ( cur -> rightThread ) cur = cur -> right ; else cur = leftmost ( cur -> right ) ; } }"}
{"text": "Bina pokok binari penuh dari preorder dan postorder traversals | program untuk pembinaan pokok binari penuh; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi utiliti untuk membuat nod; Fungsi rekursif untuk membina penuh dari pra [] dan pos []. PreIndex digunakan untuk menjejaki indeks dalam pra []. L adalah indeks rendah dan H adalah indeks tinggi untuk subarray semasa dalam pos []; Kes asas; Nod pertama dalam preorder traversal adalah akar. Jadi ambil nod pada preindex dari preorder dan menjadikannya akar, dan preindex kenaikan; Jika subarry semasa hanya mempunyai satu elemen, tidak perlu berulang; Cari elemen seterusnya pra [] dalam pos []; Gunakan indeks elemen yang terdapat dalam postorder untuk membahagikan array postorder dalam dua bahagian. Subtree kiri dan subtree kanan; Fungsi utama untuk membina pokok binari penuh dari preorder dan postorder yang diberikan. Fungsi ini terutamanya menggunakan ConstructTreeUtil (); Fungsi utiliti untuk mencetak inorder traversal pokok binari; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } struct node * constructTreeUtil ( int pre [ ] , int post [ ] , int * preIndex , int l , int h , int size ) { if ( * preIndex >= size l > h ) return NULL ; struct node * root = newNode ( pre [ * preIndex ] ) ; ++ * preIndex ; if ( l == h ) return root ; int i ; for ( i = l ; i <= h ; ++ i ) if ( pre [ * preIndex ] == post [ i ] ) break ; if ( i <= h ) { root -> left = constructTreeUtil ( pre , post , preIndex , l , i , size ) ; root -> right = constructTreeUtil ( pre , post , preIndex , i + 1 , h , size ) ; } return root ; } struct node * constructTree ( int pre [ ] , int post [ ] , int size ) { int preIndex = 0 ; return constructTreeUtil ( pre , post , & preIndex , 0 , size - 1 , size ) ; } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; printInorder ( node -> right ) ; } int main ( ) { int pre [ ] = { 1 , 2 , 4 , 8 , 9 , 5 , 3 , 6 , 7 } ; int post [ ] = { 8 , 9 , 4 , 5 , 2 , 6 , 7 , 3 , 1 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; struct node * root = constructTree ( pre , post , size ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ constructed ▁ tree : ▁ STRNEWLINE \" ) ; printInorder ( root ) ; return 0 ; }"}
{"text": "Percetakan pesanan yang disusun dari array yang diberikan yang mewakili BST | Code C untuk Percetakan Pesanan Diisih dari pelbagai yang mewakili BST; cetak subtree kiri; cetak akar; cetak subtree kanan; program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void printSorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; printf ( \" % d ▁ \" , arr [ start ] ) ; printSorted ( arr , start * 2 + 2 , end ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 } ; int arr_size = sizeof ( arr ) / sizeof ( int ) ; printSorted ( arr , 0 , arr_size - 1 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Lantai dan Ceil dari BST | Program untuk mencari ceil nilai tertentu di BST; Node pokok binari mempunyai kunci, anak kiri dan anak kanan; Fungsi pembantu yang memperuntukkan nod baru dengan kunci yang diberikan dan null kiri dan kanan. ; Fungsi untuk mencari ceil input yang diberikan dalam BST. Jika input lebih daripada kekunci maksimum dalam BST, kembali - 1; Kes asas; Kami mendapati kunci yang sama; Jika kekunci Root lebih kecil, Ceil mestilah berada di subtree yang betul; Lain, sama ada subtree kiri atau akar mempunyai nilai seil; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; struct node * left ; struct node * right ; } ; struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int Ceil ( struct node * root , int input ) { if ( root == NULL ) return -1 ; if ( root -> key == input ) return root -> key ; if ( root -> key < input ) return Ceil ( root -> right , input ) ; int ceil = Ceil ( root -> left , input ) ; return ( ceil >= input ) ? ceil : root -> key ; } int main ( ) { struct node * root = newNode ( 8 ) ; root -> left = newNode ( 4 ) ; root -> right = newNode ( 12 ) ; root -> left -> left = newNode ( 2 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> left = newNode ( 10 ) ; root -> right -> right = newNode ( 14 ) ; for ( int i = 0 ; i < 16 ; i ++ ) printf ( \" % d ▁ % d STRNEWLINE \" , i , Ceil ( root , i ) ) ; return 0 ; }"}
{"text": "Bagaimana cara mengendalikan pendua dalam pokok carian binari? | Program C untuk melaksanakan operasi asas (cari, masukkan dan padamkan) pada BST yang mengendalikan pendua dengan menyimpan kiraan dengan setiap nod; Fungsi utiliti untuk membuat nod BST baru; Fungsi utiliti untuk melakukan traversal inorder BST; Fungsi utiliti untuk memasukkan nod baru dengan kunci yang diberikan dalam BST; Jika pokok itu kosong, kembalikan nod baru; Jika kunci sudah ada di BST, kiraan dan pulangan Icnrement; Jika tidak, mengulangi pokok itu; Kembalikan penunjuk nod (tidak berubah); Memandangkan pokok carian binari yang tidak kosong, kembalikan nod dengan nilai kunci minimum yang terdapat di dalam pokok itu. Perhatikan bahawa seluruh pokok tidak perlu dicari. ; gelung ke bawah untuk mencari daun paling kiri; Memandangkan pokok carian binari dan kunci, fungsi ini memadamkan kunci yang diberikan dan pulangan akar pokok yang diubah suai; Kes asas; Jika kunci untuk dipadam lebih kecil daripada kekunci akar, maka ia terletak di subtree kiri; Jika kunci untuk dipadam adalah lebih besar daripada kunci akar, maka ia terletak pada subtree kanan; Jika kunci adalah sama dengan kunci Root; Jika kunci hadir lebih dari sekali, hanya pengurangan kiraan dan pulangan; Lain, padamkan nod nod dengan hanya satu kanak -kanak atau tiada anak; Node dengan dua kanak -kanak: Dapatkan pengganti inorder (terkecil di subtree kanan); Salin kandungan pengganti Inorder ke nod ini; Padam pengganti inorder; Program pemacu untuk menguji fungsi di atas; Marilah kita buat berikut BST 12 (3) / \\ 10 (2) 20 (1) / \\ 9 (1) 11 (1)", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; int count ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> left = temp -> right = NULL ; temp -> count = 1 ; return temp ; } void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( \" % d ( % d ) ▁ \" , root -> key , root -> count ) ; inorder ( root -> right ) ; } } struct node * insert ( struct node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key == node -> key ) { ( node -> count ) ++ ; return node ; } if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ; return node ; } struct node * minValueNode ( struct node * node ) { struct node * current = node ; while ( current -> left != NULL ) current = current -> left ; return current ; } struct node * deleteNode ( struct node * root , int key ) { if ( root == NULL ) return root ; if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ; else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ; else { if ( root -> count > 1 ) { ( root -> count ) -- ; return root ; } if ( root -> left == NULL ) { struct node * temp = root -> right ; free ( root ) ; return temp ; } else if ( root -> right == NULL ) { struct node * temp = root -> left ; free ( root ) ; return temp ; } struct node * temp = minValueNode ( root -> right ) ; root -> key = temp -> key ; root -> right = deleteNode ( root -> right , temp -> key ) ; } return root ; } int main ( ) { struct node * root = NULL ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 20 ) ; root = insert ( root , 9 ) ; root = insert ( root , 11 ) ; root = insert ( root , 10 ) ; root = insert ( root , 12 ) ; root = insert ( root , 12 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ given ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; printf ( \" Delete 20 \" root = deleteNode ( root , 20 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; printf ( \" Delete 12 \" root = deleteNode ( root , 12 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; printf ( \" Delete 9 \" root = deleteNode ( root , 9 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; return 0 ; }"}
{"text": "Bagaimana untuk melaksanakan pengurangan kekunci atau perubahan kekunci dalam pokok carian binari? | Program C untuk menunjukkan mengurangkan operasi utama pada pokok carian binari; Fungsi utiliti untuk membuat nod BST baru; Fungsi utiliti untuk melakukan traversal inorder BST; Fungsi utiliti untuk memasukkan nod baru dengan kunci yang diberikan dalam BST; Jika pokok itu kosong, kembalikan nod baru; Jika tidak, mengulangi pokok itu; Kembalikan penunjuk nod (tidak berubah); Memandangkan pokok carian binari yang tidak kosong, kembalikan nod dengan nilai kunci minimum yang terdapat di dalam pokok itu. Perhatikan bahawa seluruh pokok tidak perlu dicari. ; gelung ke bawah untuk mencari daun paling kiri; Memandangkan pokok carian binari dan kunci, fungsi ini memadamkan kunci dan mengembalikan akar baru; Kes asas; Jika kunci untuk dipadam lebih kecil daripada kekunci akar, maka ia terletak di subtree kiri; Jika kunci untuk dipadam adalah lebih besar daripada kunci akar, maka ia terletak pada subtree kanan; Jika kunci adalah sama dengan kunci Root, maka ini adalah nod yang akan dipadam; nod dengan hanya satu kanak -kanak atau tiada anak; Node dengan dua kanak -kanak: Dapatkan pengganti inorder (terkecil di subtree kanan); Salin kandungan pengganti Inorder ke nod ini; Padam pengganti inorder; Berfungsi untuk mengurangkan nilai utama dalam pokok carian binari; Mula -mula padam nilai kunci lama; Kemudian masukkan nilai kunci baru; Mengembalikan akar baru; Program pemacu untuk menguji fungsi di atas; Marilah kita buat berikut BST 50 / \\ 30 70 / \\ / \\ 20 40 60 80; BST diubah suai kepada 50 / \\ 30 70 / / \\ 20 60 80/10", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( \" % d ▁ \" , root -> key ) ; inorder ( root -> right ) ; } } struct node * insert ( struct node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ; return node ; } struct node * minValueNode ( struct node * node ) { struct node * current = node ; while ( current -> left != NULL ) current = current -> left ; return current ; } struct node * deleteNode ( struct node * root , int key ) { if ( root == NULL ) return root ; if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ; else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ; else { if ( root -> left == NULL ) { struct node * temp = root -> right ; free ( root ) ; return temp ; } else if ( root -> right == NULL ) { struct node * temp = root -> left ; free ( root ) ; return temp ; } struct node * temp = minValueNode ( root -> right ) ; root -> key = temp -> key ; root -> right = deleteNode ( root -> right , temp -> key ) ; } return root ; } struct node * changeKey ( struct node * root , int oldVal , int newVal ) { root = deleteNode ( root , oldVal ) ; root = insert ( root , newVal ) ; return root ; } int main ( ) { struct node * root = NULL ; root = insert ( root , 50 ) ; root = insert ( root , 30 ) ; root = insert ( root , 20 ) ; root = insert ( root , 40 ) ; root = insert ( root , 70 ) ; root = insert ( root , 60 ) ; root = insert ( root , 80 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ given ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; root = changeKey ( root , 40 , 10 ) ; printf ( \" Inorder traversal of the modified tree \" inorder ( root ) ; return 0 ; }"}
{"text": "Nombor dua digit khas dalam pokok carian binari | C program untuk mengira bilangan nod dalam BST yang mengandungi dua digit nombor khas; Nod pokok; Berfungsi untuk membuat nod baru; Jika pokok itu kosong, kembalikan nod tunggal yang baru; Jika tidak, mengulangi pokok itu; Berfungsi untuk mencari jika nombor adalah istimewa atau tidak; Periksa sama ada nombor dua digit atau tidak; Berfungsi untuk mengira bilangan nombor dua digit khas; Program pemandu untuk menguji; Fungsi panggilan, untuk memeriksa setiap nod untuk nombor dua digit khas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { struct Node * left ; int info ; struct Node * right ; } ; void insert ( struct Node * * rt , int key ) { if ( * rt == NULL ) { ( * rt ) = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; ( * rt ) -> left = NULL ; ( * rt ) -> right = NULL ; ( * rt ) -> info = key ; } else if ( key < ( ( * rt ) -> info ) ) insert ( & ( ( * rt ) -> left ) , key ) ; else insert ( & ( * rt ) -> right , key ) ; } int check ( int num ) { int sum = 0 , i = num , sum_of_digits , prod_of_digits ; if ( num < 10 num > 99 ) return 0 ; else { sum_of_digits = ( i % 10 ) + ( i / 10 ) ; prod_of_digits = ( i % 10 ) * ( i / 10 ) ; sum = sum_of_digits + prod_of_digits ; } if ( sum == num ) return 1 ; else return 0 ; } void countSpecialDigit ( struct Node * rt , int * c ) { int x ; if ( rt == NULL ) return ; else { x = check ( rt -> info ) ; if ( x == 1 ) * c = * c + 1 ; countSpecialDigit ( rt -> left , c ) ; countSpecialDigit ( rt -> right , c ) ; } } int main ( ) { struct Node * root = NULL ; int count = 0 ; insert ( & root , 50 ) ; insert ( & root , 29 ) ; insert ( & root , 59 ) ; insert ( & root , 19 ) ; insert ( & root , 53 ) ; insert ( & root , 556 ) ; insert ( & root , 56 ) ; insert ( & root , 94 ) ; insert ( & root , 13 ) ; countSpecialDigit ( root , & count ) ; printf ( \" % d \" , count ) ; return 0 ; }"}
{"text": "Bina pokok binari khas dari traversal inorder yang diberikan | program untuk membina pokok dari inorder traversal; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Prototaip fungsi utiliti untuk mendapatkan nilai maksimum dalam inorder [Mula. . akhir]; Fungsi rekursif untuk membina binari saiz len dari inorder inorder inorder []. Nilai awal permulaan dan akhir hendaklah 0 dan len - 1 .; Cari indeks elemen maksimum dari pokok binari; Pilih nilai maksimum dan menjadikannya akar; Jika ini adalah satu -satunya elemen dalam inorder [Mula. . akhir], kemudian kembalikan; Menggunakan indeks dalam traversal inorder, membina substruktur kiri dan kanan; Fungsi untuk mencari indeks nilai maksimum dalam arr [start ... end]; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Funtcion ini di sini hanya untuk menguji BuildTree (); pertama berulang pada anak kiri; kemudian cetak data nod; sekarang berulang pada anak yang betul; Program pemacu untuk menguji fungsi di atas; Anggapkan bahawa inorder traversal pokok berikut diberikan 40 / \\ 10 30 / \\ 5 28; Mari kita uji pokok yang dibina dengan mencetak Traversal Insorder", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int max ( int inorder [ ] , int strt , int end ) ; struct node * newNode ( int data ) ; struct node * buildTree ( int inorder [ ] , int start , int end ) { if ( start > end ) return NULL ; int i = max ( inorder , start , end ) ; struct node * root = newNode ( inorder [ i ] ) ; if ( start == end ) return root ; root -> left = buildTree ( inorder , start , i - 1 ) ; root -> right = buildTree ( inorder , i + 1 , end ) ; return root ; } int max ( int arr [ ] , int strt , int end ) { int i , max = arr [ strt ] , maxind = strt ; for ( i = strt + 1 ; i <= end ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; maxind = i ; } } return maxind ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return node ; } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; printInorder ( node -> right ) ; } int main ( ) { int inorder [ ] = { 5 , 10 , 40 , 30 , 28 } ; int len = sizeof ( inorder ) / sizeof ( inorder [ 0 ] ) ; struct node * root = buildTree ( inorder , 0 , len - 1 ) ; printf ( \" Inorder traversal of the constructed tree is \" printInorder ( root ) ; return 0 ; }"}
{"text": "Program untuk Matriks Identiti | C program untuk mencetak matriks identiti; Memeriksa jika baris adalah sama dengan lajur; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int Identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) printf ( \" % d ▁ \" , 1 ) ; else printf ( \" % d ▁ \" , 0 ) ; } printf ( \" STRNEWLINE \" ) ; } return 0 ; } int main ( ) { int size = 5 ; identity ( size ) ; return 0 ; }"}
{"text": "Cari berturut -turut dan lajur yang bijak matriks disusun | C program untuk mencari elemen dalam baris - bijak dan lajur - matriks yang disusun bijak; Mencari elemen x dalam tikar [] []. Jika elemen dijumpai, maka mencetak kedudukannya dan mengembalikan benar, jika tidak, cetak \"tidak» dijumpai \"dan mengembalikan palsu; Tetapkan indeks untuk elemen kanan atas; jika mat [i] [j] <x; jika (i == n j == - 1); program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return -1 ; int smallest = mat [ 0 ] [ 0 ] , largest = mat [ n - 1 ] [ n - 1 ] ; if ( x < smallest x > largest ) return -1 ; int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { printf ( \" Found at % d , % d \" , i , j ) ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } printf ( \" n ▁ Element ▁ not ▁ found \" ) ; return 0 ; } int main ( ) { int mat [ 4 ] [ 4 ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } , } ; search ( mat , 4 , 29 ) ; return 0 ; }"}
{"text": "Buat matriks dengan segi empat tepat berganti O dan X |  ; Berfungsi untuk mencetak segi empat tepat berganti 0 dan x; K - Indeks baris permulaan m - Indeks baris akhir l - Indeks lajur bermula n - Ending Column Index I - Iterator; Simpan bilangan baris dan lajur yang diberikan untuk kegunaan kemudian; Array 2D untuk menyimpan output untuk dicetak; Ini akan menjadi watak yang akan ditangkap dalam [] []; Isi aksara dalam [] [] dalam bentuk lingkaran. Setiap lelaran mengisi satu segi empat tepat sama ada XS atau OS; Isi baris pertama dari baris yang tinggal; Isi lajur terakhir dari lajur yang tinggal; Isi baris terakhir dari baris yang tinggal; Cetak lajur pertama dari lajur yang tinggal; Watak flip untuk lelaran seterusnya; Cetak matriks yang diisi; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void fill0X ( int m , int n ) { int i , k = 0 , l = 0 ; int r = m , c = n ; char a [ m ] [ n ] ; char x = ' X ' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) a [ k ] [ i ] = x ; k ++ ; for ( i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = x ; n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = x ; l ++ ; } x = ( x == '0' ) ? ' X ' : '0' ; } for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) printf ( \" % c ▁ \" , a [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } } int main ( ) { puts ( \" Output ▁ for ▁ m ▁ = ▁ 5 , ▁ n ▁ = ▁ 6\" ) ; fill0X ( 5 , 6 ) ; puts ( \" Output for m = 4 , n = 4 \" ) ; fill0X ( 4 , 4 ) ; puts ( \" Output for m = 3 , n = 4 \" ) ; fill0X ( 3 , 4 ) ; return 0 ; }"}
{"text": "Program untuk bertukar pepenjuru matriks | Program C untuk menukar pepenjuru matriks; Berfungsi untuk bertukar pepenjuru; elemen swap pepenjuru; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE void interchangeDiagonals ( int array [ ] [ N ] ) { for ( int i = 0 ; i < N ; ++ i ) if ( i != N / 2 ) swap ( array [ i ] [ i ] , array [ i ] [ N - i - 1 ] ) ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) printf ( \" ▁ % d \" , array [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } } int main ( ) { int array [ N ] [ N ] = { 4 , 5 , 6 , 1 , 2 , 3 , 7 , 8 , 9 } ; interchangeDiagonals ( array ) ; return 0 ; }"}
{"text": "Pokok Binari Lengkap Lengkap & Penciptaannya | Program untuk melaksanakan pelaksanaan pokok binari lengkap; Untuk saiz giliran; Nod pokok; Nod giliran; Fungsi utiliti untuk membuat nod pokok baru; Fungsi utiliti untuk membuat barisan baru; Fungsi giliran standard; Fungsi utiliti untuk memeriksa sama ada nod pokok mempunyai kanak -kanak kiri dan kanan; Berfungsi untuk memasukkan nod baru dalam pokok binari lengkap; Buat nod baru untuk data yang diberikan; Jika pokok itu kosong, mulakan akar dengan nod baru. ; Dapatkan nod depan barisan. ; Jika anak kiri nod depan ini tidak wujud, tetapkan anak kiri sebagai nod baru; Jika anak yang betul dari nod depan ini tidak wujud, tetapkan anak yang tepat sebagai nod baru; Jika nod depan mempunyai anak kiri dan anak kanan, dequeue () itu. ; Enqueue () nod baru untuk penyisipan kemudian; Perintah Tahap Standard Traversal untuk menguji fungsi di atas; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define SIZE  50 NEW_LINE struct node { int data ; struct node * right , * left ; } ; struct Queue { int front , rear ; int size ; struct node * * array ; } ; struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } struct Queue * createQueue ( int size ) { struct Queue * queue = ( struct Queue * ) malloc ( sizeof ( struct Queue ) ) ; queue -> front = queue -> rear = -1 ; queue -> size = size ; queue -> array = ( struct node * * ) malloc ( queue -> size * sizeof ( struct node * ) ) ; int i ; for ( i = 0 ; i < size ; ++ i ) queue -> array [ i ] = NULL ; return queue ; } int isEmpty ( struct Queue * queue ) { return queue -> front == -1 ; } int isFull ( struct Queue * queue ) { return queue -> rear == queue -> size - 1 ; } int hasOnlyOneItem ( struct Queue * queue ) { return queue -> front == queue -> rear ; } void Enqueue ( struct node * root , struct Queue * queue ) { if ( isFull ( queue ) ) return ; queue -> array [ ++ queue -> rear ] = root ; if ( isEmpty ( queue ) ) ++ queue -> front ; } struct node * Dequeue ( struct Queue * queue ) { if ( isEmpty ( queue ) ) return NULL ; struct node * temp = queue -> array [ queue -> front ] ; if ( hasOnlyOneItem ( queue ) ) queue -> front = queue -> rear = -1 ; else ++ queue -> front ; return temp ; } struct node * getFront ( struct Queue * queue ) { return queue -> array [ queue -> front ] ; } int hasBothChild ( struct node * temp ) { return temp && temp -> left && temp -> right ; } void insert ( struct node * * root , int data , struct Queue * queue ) { struct node * temp = newNode ( data ) ; if ( ! * root ) * root = temp ; else { struct node * front = getFront ( queue ) ; if ( ! front -> left ) front -> left = temp ; else if ( ! front -> right ) front -> right = temp ; if ( hasBothChild ( front ) ) Dequeue ( queue ) ; } Enqueue ( temp , queue ) ; } void levelOrder ( struct node * root ) { struct Queue * queue = createQueue ( SIZE ) ; Enqueue ( root , queue ) ; while ( ! isEmpty ( queue ) ) { struct node * temp = Dequeue ( queue ) ; printf ( \" % d ▁ \" , temp -> data ) ; if ( temp -> left ) Enqueue ( temp -> left , queue ) ; if ( temp -> right ) Enqueue ( temp -> right , queue ) ; } } int main ( ) { struct node * root = NULL ; struct Queue * queue = createQueue ( SIZE ) ; int i ; for ( i = 1 ; i <= 12 ; ++ i ) insert ( & root , i , queue ) ; levelOrder ( root ) ; return 0 ; }"}
{"text": "Tukar pokok binari yang diberikan kepada senarai dikaitkan berganda | Tetapkan 1 | Program c untuk penukaran pokok binari ke dll; Nod pokok binari mempunyai data, dan petunjuk kiri dan kanan; Ini adalah fungsi teras untuk menukar pokok ke senarai. Fungsi ini mengikuti langkah 1 dan 2 algoritma di atas; Kes asas; Tukar subtree kiri dan pautan ke akar; Tukar subtree kiri; Cari Inorderororor. Selepas gelung ini, kiri akan menunjuk kepada pendahuluan inorder; Buat akar sebagai berikutnya pendahuluan; Membuat predecssor seperti sebelumnya akar; Menukar subtree kanan dan pautan ke akar; Tukar subtree yang betul; Cari pengganti inorder. Selepas gelung ini, hak akan menunjuk kepada pengganti inorder; Membuat akar seperti sebelumnya pengganti; Membuat pengganti sebagai akar seterusnya; Fungsi utama yang pertama kali memanggil Bintree2ListUtil (), kemudian mengikuti Langkah 3 algoritma di atas; Kes asas; Tukar ke DLL menggunakan BintRee2ListUtil (); bintree2listutil () mengembalikan nod akar DLL yang ditukar. Kami memerlukan penunjuk ke nod paling kiri yang merupakan ketua DLL yang dibina, jadi bergerak ke nod paling kiri; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Berfungsi untuk mencetak nod dalam senarai dikaitkan dua kali ganda; Program pemacu untuk menguji fungsi di atas; Marilah kita buat pokok yang ditunjukkan dalam rajah di atas; Tukar ke DLL; Cetak senarai yang ditukar", "code": "#include <stdio.h> NEW_LINE struct node { int data ; node * left ; node * right ; } ; node * bintree2listUtil ( node * root ) { if ( root == NULL ) return root ; if ( root -> left != NULL ) { node * left = bintree2listUtil ( root -> left ) ; for ( ; left -> right != NULL ; left = left -> right ) ; left -> right = root ; root -> left = left ; } if ( root -> right != NULL ) { node * right = bintree2listUtil ( root -> right ) ; for ( ; right -> left != NULL ; right = right -> left ) ; right -> left = root ; root -> right = right ; } return root ; } node * bintree2list ( node * root ) { if ( root == NULL ) return root ; root = bintree2listUtil ( root ) ; while ( root -> left != NULL ) root = root -> left ; return ( root ) ; } node * newNode ( int data ) { node * new_node = new node ; new_node -> data = data ; new_node -> left = new_node -> right = NULL ; return ( new_node ) ; } void printList ( node * node ) { while ( node != NULL ) { printf ( \" % d ▁ \" , node -> data ) ; node = node -> right ; } } int main ( ) { node * root = newNode ( 10 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 15 ) ; root -> left -> left = newNode ( 25 ) ; root -> left -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 36 ) ; node * head = bintree2list ( root ) ; printList ( head ) ; return 0 ; }"}
{"text": "Cetak baris unik dalam matriks Boolean yang diberikan | Memandangkan matriks binari m x n bilangan bulat, anda perlu mengembalikan hanya baris unik dari array binari; Node trie; Hanya dua kanak -kanak yang diperlukan untuk 0 dan 1; Fungsi utiliti untuk memperuntukkan memori untuk nod trie baru; Masukkan baris matriks baru ke Trie. Jika baris sudah ada, maka pulih 0, jika tidak, masukkan baris dan kembali 1; Kes asas; Berulang jika terdapat lebih banyak penyertaan dalam baris ini; Jika semua penyertaan baris ini diproses; Baris unik dijumpai, kembali 1; Duplicate Row dijumpai, kembali 0; Fungsi utiliti untuk mencetak baris; Fungsi utama yang mencetak semua baris unik dalam matriks yang diberikan. ; Buat trie kosong; Melangkah melalui semua baris; Masukkan baris ke trie; Baris unik dijumpai, mencetaknya; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE #define ROW  4 NEW_LINE #define COL  5 NEW_LINE typedef struct Node { bool isEndOfCol ; struct Node * child [ 2 ] ; } Node ; Node * newNode ( ) { Node * temp = ( Node * ) malloc ( sizeof ( Node ) ) ; temp -> isEndOfCol = 0 ; temp -> child [ 0 ] = temp -> child [ 1 ] = NULL ; return temp ; } bool insert ( Node * * root , int ( * M ) [ COL ] , int row , int col ) { if ( * root == NULL ) * root = newNode ( ) ; if ( col < COL ) return insert ( & ( ( * root ) -> child [ M [ row ] [ col ] ] ) , M , row , col + 1 ) ; else { if ( ! ( ( * root ) -> isEndOfCol ) ) return ( * root ) -> isEndOfCol = 1 ; return 0 ; } } void printRow ( int ( * M ) [ COL ] , int row ) { int i ; for ( i = 0 ; i < COL ; ++ i ) printf ( \" % d ▁ \" , M [ row ] [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } void findUniqueRows ( int ( * M ) [ COL ] ) { Node * root = NULL ; int i ; for ( i = 0 ; i < ROW ; ++ i ) if ( insert ( & root , M , i , 0 ) ) printRow ( M , i ) ; } int main ( ) { int M [ ROW ] [ COL ] = { { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 0 , 0 } } ; findUniqueRows ( M ) ; return 0 ; }"}
{"text": "Cari elemen biasa dalam semua baris baris yang diberikan | Program C untuk mencari elemen yang sama dalam semua baris array yang disusun dengan bijak; Tentukan bilangan baris dan lajur; Mengembalikan elemen biasa dalam semua baris Mat [M] [n]. Sekiranya tidak ada elemen yang sama, maka - 1 dikembalikan; Array untuk menyimpan indeks lajur terakhir semasa; Untuk menyimpan indeks baris yang elemen terakhirnya adalah minimum; Memulakan elemen terakhir semasa semua baris; Inisialisasi min_row sebagai baris pertama; Teruskan mencari min_row dalam lajur terakhir semasa, sehingga sama ada semua elemen lajur terakhir menjadi sama atau kami memukul lajur pertama. ; Cari minimum dalam lajur terakhir semasa; eq_count adalah kiraan elemen yang sama dengan minimum dalam lajur terakhir semasa. ; Melintasi elemen lajur terakhir semasa sekali lagi untuk mengemas kini; Kurangkan indeks lajur terakhir baris yang nilainya lebih minimum. ; Mengurangkan indeks lajur terakhir dengan 1; Jika kiraan yang sama menjadi m, kembalikan nilai; program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #define M  4 NEW_LINE #define N  5 NEW_LINE int findCommon ( int mat [ M ] [ N ] ) { int column [ M ] ; int min_row ; int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ; min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ; } int eq_count = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return -1 ; column [ i ] -= 1 ; } else eq_count ++ ; } if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } return -1 ; } int main ( ) { int mat [ M ] [ N ] = { { 1 , 2 , 3 , 4 , 5 } , { 2 , 4 , 5 , 8 , 10 } , { 3 , 5 , 7 , 9 , 11 } , { 1 , 3 , 5 , 7 , 9 } , } ; int result = findCommon ( mat ) ; if ( result == -1 ) printf ( \" No ▁ common ▁ element \" ) ; else printf ( \" Common ▁ element ▁ is ▁ % d \" , result ) ; return 0 ; }"}
{"text": "Tukar pokok binari yang diberikan kepada senarai dikaitkan berganda | Tetapkan 2 | Program berasaskan traversal inorder yang mudah untuk menukar pokok binari ke DLL; Nod pokok; Fungsi utiliti untuk membuat nod pokok baru; Traversal traversal standard; Perubahan petunjuk kiri untuk berfungsi sebagai petunjuk sebelumnya dalam DLL yang ditukar fungsi hanya melakukan inorder traversal pokok binari dan mengemas kini penunjuk kiri menggunakan nod yang telah dikunjungi sebelumnya; Perubahan petunjuk yang betul untuk berfungsi sebagai petunjuk seterusnya dalam DLL yang ditukar; Cari nod yang paling tepat di BT atau nod terakhir di DLL; Mulakan dari nod paling kanan, melintasi kembali menggunakan petunjuk kiri. Semasa melintasi, tukar penunjuk kanan nod. ; Node paling kiri adalah ketua senarai yang dipautkan, mengembalikannya; Fungsi utama yang menukarkan BST ke DLL dan mengembalikan kepala DLL; Tetapkan penunjuk sebelumnya; Tetapkan penunjuk seterusnya dan kembali kepala DLL; Melintasi DLL dari kiri kanan; Program pemacu untuk menguji fungsi di atas; Marilah kita buat pokok yang ditunjukkan dalam rajah di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( \" TABSYMBOL % d \" , root -> data ) ; inorder ( root -> right ) ; } } void fixPrevPtr ( struct node * root ) { static struct node * pre = NULL ; if ( root != NULL ) { fixPrevPtr ( root -> left ) ; root -> left = pre ; pre = root ; fixPrevPtr ( root -> right ) ; } } struct node * fixNextPtr ( struct node * root ) { struct node * prev = NULL ; while ( root && root -> right != NULL ) root = root -> right ; while ( root && root -> left != NULL ) { prev = root ; root = root -> left ; root -> right = prev ; } return ( root ) ; } struct node * BTToDLL ( struct node * root ) { fixPrevPtr ( root ) ; return fixNextPtr ( root ) ; } void printList ( struct node * root ) { while ( root != NULL ) { printf ( \" TABSYMBOL % d \" , root -> data ) ; root = root -> right ; } } int main ( void ) { struct node * root = newNode ( 10 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 15 ) ; root -> left -> left = newNode ( 25 ) ; root -> left -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 36 ) ; printf ( \" Inorder Tree Traversal \" inorder ( root ) ; struct node * head = BTToDLL ( root ) ; printf ( \" DLL Traversal \" printList ( head ) ; return 0 ; }"}
{"text": "Tukar pokok binari sewenang -wenang ke pokok yang memegang harta benda kanak -kanak | Program untuk menukar pokok binari Aribitary ke pokok yang memegang harta benda kanak -kanak; Nod pokok binari; Fungsi ini digunakan untuk meningkatkan subtree kiri; Fungsi ini mengubah pokok untuk memegang harta benda kanak -kanak; Jika pokok kosong atau ia adalah nod daun maka kembali benar; menukar subtrees kiri dan kanan; Jika anak kiri tidak hadir maka 0 digunakan sebagai data anak kiri; Jika anak yang betul tidak hadir maka 0 digunakan sebagai data anak yang betul; Dapatkan perbezaan data nod dan jumlah kanak -kanak; Jika node 's kanak -kanak adalah lebih besar daripada data node; Ini adalah rumit -> jika data node lebih besar daripada jumlah kanak -kanak, maka subtree kenaikan dengan diff; - Diff digunakan untuk membuat diff positif; Fungsi ini digunakan untuk meningkatkan subtree oleh diff; Jika anak kiri tidak batal maka tambahnya; Panggilan rekursif untuk menetapkan keturunan nod -> kiri; Lain -lain kenaikan kanak -kanak yang betul; Panggilan rekursif untuk menetapkan keturunan nod -> betul; Memandangkan pokok binari, printInorder () mencetak traversal inordernya; pertama berulang pada anak kiri; kemudian cetak data nod; sekarang berulang pada anak yang betul; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; void increment ( struct node * node , int diff ) ; void convertTree ( struct node * node ) { int left_data = 0 , right_data = 0 , diff ; if ( node == NULL || ( node -> left == NULL && node -> right == NULL ) ) return ; else { convertTree ( node -> left ) ; convertTree ( node -> right ) ; if ( node -> left != NULL ) left_data = node -> left -> data ; if ( node -> right != NULL ) right_data = node -> right -> data ; diff = left_data + right_data - node -> data ; if ( diff > 0 ) node -> data = node -> data + diff ; if ( diff < 0 ) increment ( node , - diff ) ; } } void increment ( struct node * node , int diff ) { if ( node -> left != NULL ) { node -> left -> data = node -> left -> data + diff ; increment ( node -> left , diff ) ; } else if ( node -> right != NULL ) { node -> right -> data = node -> right -> data + diff ; increment ( node -> right , diff ) ; } } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; printInorder ( node -> right ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 50 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 1 ) ; root -> right -> right = newNode ( 30 ) ; printf ( \" Inorder traversal before conversion \" printInorder ( root ) ; convertTree ( root ) ; printf ( \" Inorder traversal after conversion \" printInorder ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Tukar pokok yang diberikan ke pokok jumlahnya |  ; Struktur nod pokok; Tukar pokok yang diberikan ke pokok di mana setiap nod mengandungi jumlah nilai nod di subtrees kiri dan kanan di pokok asal; Kes asas; Simpan nilai lama; Recursif memanggil subtrees kiri dan kanan dan menyimpan jumlah sebagai nilai baru nod ini; Kembalikan jumlah nilai nod di subtrees kiri dan kanan dan Old_value nod ini; Fungsi utiliti untuk mencetak inorder traversal pokok binari; Fungsi utiliti untuk membuat nod pokok binari baru; Fungsi pemacu untuk menguji fungsi di atas; Membina pokok yang diberikan dalam angka di atas; Cetak inorder traversal pokok yang ditukar untuk menguji hasil tosumtree ()", "code": "#include <stdio.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int toSumTree ( struct node * node ) { if ( node == NULL ) return 0 ; int old_val = node -> data ; node -> data = toSumTree ( node -> left ) + toSumTree ( node -> right ) ; return node -> data + old_val ; } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; printInorder ( node -> right ) ; } struct node * newNode ( int data ) { struct node * temp = new struct node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int main ( ) { struct node * root = NULL ; int x ; root = newNode ( 10 ) ; root -> left = newNode ( -2 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( -4 ) ; root -> right -> left = newNode ( 7 ) ; root -> right -> right = newNode ( 5 ) ; toSumTree ( root ) ; printf ( \" Inorder ▁ Traversal ▁ of ▁ the ▁ resultant ▁ tree ▁ is : ▁ STRNEWLINE \" ) ; printInorder ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari Elemen Puncak | Program C untuk mencari elemen puncak menggunakan membahagikan dan menaklukkan; Fungsi berasaskan carian binari yang mengembalikan indeks elemen puncak; Cari indeks elemen pertengahan (rendah + tinggi) / 2; Bandingkan elemen pertengahan dengan jirannya (jika jiran wujud); Jika elemen tengah tidak puncak dan jiran kiri lebih besar daripada itu, maka separuh kiri mesti mempunyai elemen puncak; Jika elemen tengah tidak puncak dan jiran kanannya lebih besar daripada itu, maka separuh kanan mesti mempunyai elemen puncak; Pembungkus ke atas fungsi rekursif findpeakutil (); Program pemacu untuk menyemak fungsi di atas", "code": "#include <stdio.h> NEW_LINE int findPeakUtil ( int arr [ ] , int low , int high , int n ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ; else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; } int findPeak ( int arr [ ] , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Index ▁ of ▁ a ▁ peak ▁ point ▁ is ▁ % d \" , findPeak ( arr , n ) ) ; return 0 ; }"}
{"text": "Cari dua elemen berulang dalam array yang diberikan |  ; Cetak fungsi berulang; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void printRepeating ( int arr [ ] , int size ) { int i , j ; printf ( \" ▁ Repeating ▁ elements ▁ are ▁ \" ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) printf ( \" ▁ % d ▁ \" , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari dua elemen berulang dalam array yang diberikan |  ; Fungsi; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void printRepeating ( int arr [ ] , int size ) { int * count = ( int * ) calloc ( sizeof ( int ) , ( size - 2 ) ) ; int i ; printf ( \" ▁ Repeating ▁ elements ▁ are ▁ \" ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) printf ( \" ▁ % d ▁ \" , arr [ i ] ) ; else count [ arr [ i ] ] ++ ; } } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari dua elemen berulang dalam array yang diberikan |  ; fungsi printRepeating; S adalah untuk jumlah elemen dalam arr []; P adalah untuk produk elemen dalam arr []; X dan Y adalah dua elemen berulang; D adalah untuk perbezaan x dan y, i. e. , x - y; Hitung jumlah dan produk semua elemen dalam arr []; S adalah x + y sekarang; P adalah x * y sekarang; D adalah x - y sekarang; faktorial n; kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <math.h> NEW_LINE int fact ( int n ) ; void printRepeating ( int arr [ ] , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; printf ( \" The ▁ two ▁ Repeating ▁ elements ▁ are ▁ % d ▁ & ▁ % d \" , x , y ) ; } int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari dua elemen berulang dalam array yang diberikan | C kod untuk mencari dua elemen berulang dalam array yang diberikan; Akan memegang xor semua elemen; Hanya mempunyai satu set bit XOR; Dapatkan xor semua elemen dalam arr [] dan {1, 2. . n}; Dapatkan bit set kanan dalam set_bit_no; Sekarang bahagikan unsur -unsur dalam dua set dengan membandingkan bit XOR set paling kanan dengan bit pada kedudukan yang sama dalam setiap elemen. ; Xor set pertama di arr []; Xor set kedua dalam arr []; Xor set pertama dalam arr [] dan {1, 2, ... n}; Xor set kedua dalam arr [] dan {1, 2, ... n}; kod pemacu", "code": "void printRepeating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_bit_no = xor & ~ ( xor - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ; else y = y ^ i ; } printf ( \" n ▁ The ▁ two ▁ repeating ▁ elements ▁ are ▁ % d ▁ & ▁ % d ▁ \" , x , y ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari dua elemen berulang dalam array yang diberikan |  ; Berfungsi untuk mencetak berulang; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void printRepeating ( int arr [ ] , int size ) { int i ; printf ( \" The repeating elements are \" for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; else printf ( \" ▁ % d ▁ \" , abs ( arr [ i ] ) ) ; } } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari subarray dengan jumlah yang diberikan | Tetapkan 1 (Nombor Nonnegative) | Program mudah untuk mencetak subarray dengan jumlah yang diberikan; Pulangan benar jika ada subarray arr [] dengan jumlah yang sama dengan 'jumlah' sebaliknya mengembalikan palsu. Juga, mencetak hasilnya; Pilih titik permulaan; Cuba semua subarrays bermula dengan 'I'; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { printf ( \" Sum ▁ found ▁ between ▁ indexes ▁ % d ▁ and ▁ % d \" , i , j - 1 ) ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } printf ( \" No ▁ subarray ▁ found \" ) ; return 0 ; } int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; subArraySum ( arr , n , sum ) ; return 0 ; }"}
{"text": "Cari subarray dengan jumlah yang diberikan | Tetapkan 1 (Nombor Nonnegative) | Program yang cekap untuk mencetak subarray dengan jumlah yang diberikan; Pulangan benar jika ada subarray arr [] dengan jumlah yang sama dengan 'jumlah' sebaliknya mengembalikan palsu. Juga, mencetak hasilnya; Memulakan curr_sum sebagai nilai elemen pertama dan titik permulaan sebagai 0; Tambah elemen satu demi satu ke curr_sum dan jika curr_sum melebihi jumlah, kemudian keluarkan elemen permulaan; Jika curr_sum melebihi jumlah, maka keluarkan elemen permulaan; Jika curr_sum menjadi sama dengan jumlah, maka kembali benar; Tambah elemen ini ke curr_sum; Jika kita sampai di sini, maka tidak ada subarray; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { printf ( \" Sum ▁ found ▁ between ▁ indexes ▁ % d ▁ and ▁ % d \" , start , i - 1 ) ; return 1 ; } if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } printf ( \" No ▁ subarray ▁ found \" ) ; return 0 ; } int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; subArraySum ( arr , n , sum ) ; return 0 ; }"}
{"text": "Cari triplet yang Jumlah kepada nilai tertentu |  ; pulangan benar jika terdapat triplet dengan jumlah yang sama dengan 'jumlah' yang ada dalam []. Juga, mencetak triplet; Betulkan elemen pertama sebagai [i]; Betulkan elemen kedua sebagai [J]; Sekarang cari nombor ketiga; Jika kita sampai di sini, maka tiada triplet ditemui; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { printf ( \" Triplet ▁ is ▁ % d , ▁ % d , ▁ % d \" , A [ i ] , A [ j ] , A [ k ] ) ; return true ; } } } } return false ; } int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; find3Numbers ( A , arr_size , sum ) ; return 0 ; }"}
{"text": "Analisis Algoritma | Tetapkan 2 (kes terburuk, purata dan terbaik) | C pelaksanaan pendekatan; Linearly cari x dalam arr []. Jika x hadir kemudian kembalikan indeks, jika tidak, pulangan - 1; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { 1 , 10 , 30 , 15 } ; int x = 30 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d ▁ is ▁ present ▁ at ▁ index ▁ % d \" , x , search ( arr , n , x ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Carian binari | Program C untuk melaksanakan carian binari rekursif; Fungsi carian binari rekursif. Ia mengembalikan lokasi x dalam array yang diberikan [l. . r] hadir, jika tidak - 1; Jika elemen hadir di tengah -tengahnya sendiri; Jika elemen lebih kecil daripada pertengahan, maka ia hanya boleh hadir di subarray kiri; Lain elemen hanya boleh hadir di subarray kanan; Kami sampai di sini apabila elemen tidak hadir dalam pelbagai; Kaedah pemacu untuk diuji di atas", "code": "#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ) : printf ( \" Element ▁ is ▁ present ▁ at ▁ index ▁ % d \" , result ) ; return 0 ; }"}
{"text": "Carian binari | Program C untuk melaksanakan carian binari berulang; Fungsi carian binari berulang. Ia mengembalikan lokasi x dalam array yang diberikan [l. . r] jika hadir, jika tidak - 1; Semak sama ada X hadir pada pertengahan; Jika x lebih besar, abaikan separuh kiri; Jika x lebih kecil, abaikan separuh kanan; Jika kita sampai di sini, maka elemen tidak hadir; Kaedah pemacu untuk diuji di atas", "code": "#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( \" Element ▁ is ▁ not ▁ present \" \" ▁ in ▁ array \" ) : printf ( \" Element ▁ is ▁ present ▁ at ▁ \" \" index ▁ % d \" , result ) ; return 0 ; }"}
{"text": "Carian Interpolasi | Program C untuk melaksanakan carian interpolasi dengan rekursi; Jika x hadir dalam arr [0 .. n - 1], kemudian mengembalikan indeksnya, lain kembali - 1 .; Oleh kerana array disusun, elemen yang terdapat dalam array mestilah berada dalam julat yang ditakrifkan oleh sudut; Meneliti kedudukan dengan menjaga pengedaran seragam dalam fikiran. ; Keadaan sasaran yang dijumpai; Jika x lebih besar, x berada dalam sub sub kanan; Jika x lebih kecil, x berada dalam sub sub kiri; Kod pemacu; Pelbagai item di mana carian akan dijalankan. ; Elemen yang akan dicari; Sekiranya elemen dijumpai", "code": "#include <stdio.h> NEW_LINE int interpolationSearch ( int arr [ ] , int lo , int hi , int x ) { int pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) return interpolationSearch ( arr , pos + 1 , hi , x ) ; if ( arr [ pos ] > x ) return interpolationSearch ( arr , lo , pos - 1 , x ) ; } return -1 ; } int main ( ) { int arr [ ] = { 10 , 12 , 13 , 16 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 33 , 35 , 42 , 47 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 18 ; int index = interpolationSearch ( arr , 0 , n - 1 , x ) ; if ( index != -1 ) printf ( \" Element ▁ found ▁ at ▁ index ▁ % d \" , index ) ; else printf ( \" Element ▁ not ▁ found . \" ) ; return 0 ; }"}
{"text": "Gabungan sort | C program untuk gabungan; Menggabungkan dua subarray ARR []. Subarray pertama adalah arr [l. . m] subarray kedua adalah arr [m + 1. r]; Cari saiz dua subarray yang akan digabungkan; Buat tatasusunan temp; Salin data ke Temp Arrays L [] dan R []; Gabungkan Temp Arrays Indeks Awal Subarrays Pertama dan Kedua; Indeks awal subarray yang digabungkan; Salin unsur -unsur L [], jika ada; Salin unsur -unsur R [], jika ada; L adalah untuk indeks kiri dan r adalah indeks kanan sub -pelbagai ARR untuk disusun; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Menggabungkan bahagian yang disusun; Berfungsi untuk mencetak array; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void merge ( int arr [ ] , int l , int m , int r ) { int i , j , k ; int n1 = m - l + 1 ; int n2 = r - m ; int L [ n1 ] , R [ n2 ] ; for ( i = 0 ; i < n1 ; i ++ ) L [ i ] = arr [ l + i ] ; for ( j = 0 ; j < n2 ; j ++ ) R [ j ] = arr [ m + 1 + j ] ; i = 0 ; j = 0 ; k = l ; while ( i < n1 && j < n2 ) { if ( L [ i ] <= R [ j ] ) { arr [ k ] = L [ i ] ; i ++ ; } else { arr [ k ] = R [ j ] ; j ++ ; } k ++ ; } while ( i < n1 ) { arr [ k ] = L [ i ] ; i ++ ; k ++ ; } while ( j < n2 ) { arr [ k ] = R [ j ] ; j ++ ; k ++ ; } } void mergeSort ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } void printArray ( int A [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , A [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given ▁ array ▁ is ▁ STRNEWLINE \" ) ; printArray ( arr , arr_size ) ; mergeSort ( arr , 0 , arr_size - 1 ) ; printf ( \" Sorted array is \" printArray ( arr , arr_size ) ; return 0 ; }"}
{"text": "SENARAI ITERATIVE SENDIRI | Pelaksanaan berulang dengan cepat; Fungsi utiliti untuk menukar dua elemen; Fungsi ini sama dalam kedua -dua berulang dan rekursif; A [] -> array untuk disusun, l -> indeks permulaan, h -> indeks akhir; Buat timbunan tambahan; memulakan bahagian atas timbunan; tolak nilai awal L dan H ke timbunan; Terus muncul dari timbunan sementara tidak kosong; Pop H dan L; Tetapkan elemen pivot pada kedudukan yang betul dalam array yang disusun; Sekiranya terdapat unsur -unsur di sebelah kiri pivot, maka tekan sebelah kiri untuk disusun; Sekiranya terdapat unsur -unsur di sebelah kanan pivot, maka tekan sebelah kanan untuk disusun; Fungsi utiliti untuk mencetak kandungan ARR; Program pemacu untuk menguji fungsi di atas; Fungsi panggilan", "code": "#include <stdio.h> NEW_LINE void swap ( int * a , int * b ) { int t = * a ; * a = * b ; * b = t ; } int partition ( int arr [ ] , int l , int h ) { int x = arr [ h ] ; int i = ( l - 1 ) ; for ( int j = l ; j <= h - 1 ; j ++ ) { if ( arr [ j ] <= x ) { i ++ ; swap ( & arr [ i ] , & arr [ j ] ) ; } } swap ( & arr [ i + 1 ] , & arr [ h ] ) ; return ( i + 1 ) ; } void quickSortIterative ( int arr [ ] , int l , int h ) { int stack [ h - l + 1 ] ; int top = -1 ; stack [ ++ top ] = l ; stack [ ++ top ] = h ; while ( top >= 0 ) { h = stack [ top -- ] ; l = stack [ top -- ] ; int p = partition ( arr , l , h ) ; if ( p - 1 > l ) { stack [ ++ top ] = l ; stack [ ++ top ] = p - 1 ; } if ( p + 1 < h ) { stack [ ++ top ] = p + 1 ; stack [ ++ top ] = h ; } } } void printArr ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) printf ( \" % d ▁ \" , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 4 , 3 , 5 , 2 , 1 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( * arr ) ; quickSortIterative ( arr , 0 , n - 1 ) ; printArr ( arr , n ) ; return 0 ; }"}
{"text": "Masalah Pemilihan Aktiviti | Algo Greedy | Program C untuk masalah pemilihan aktiviti. Pelaksanaan berikut mengandaikan bahawa aktiviti telah disusun mengikut masa penamat mereka; Mencetak set maksimum aktiviti yang boleh dilakukan oleh satu orang, satu demi satu. n -> Jumlah bilangan aktiviti s [] -> array yang mengandungi masa mula semua aktiviti f [] -> array yang mengandungi masa selesai semua aktiviti; Aktiviti pertama sentiasa dipilih; Pertimbangkan sisa aktiviti; Jika aktiviti ini telah memulakan masa lebih besar daripada atau sama dengan masa penamat aktiviti yang dipilih sebelum ini, kemudian pilihnya; program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; printf ( \" Following ▁ activities ▁ are ▁ selected ▁ n \" ) ; i = 0 ; printf ( \" % d ▁ \" , i ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { printf ( \" % d ▁ \" , j ) ; i = j ; } } } int main ( ) { int s [ ] = { 1 , 3 , 0 , 5 , 8 , 5 } ; int f [ ] = { 2 , 4 , 6 , 7 , 9 , 9 } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; printMaxActivities ( s , f , n ) ; return 0 ; }"}
{"text": "Pengekodan Huffman Cekap untuk Input Sisin | Algo Greedy | Program C untuk pengekodan Huffman yang cekap untuk input yang disusun; Pemalar ini boleh dielakkan dengan mengira ketinggian pokok Huffman secara eksplisit; Node pokok Huffman; Struktur untuk giliran: pengumpulan nod pokok Huffman (Orqueuenodes); Fungsi utiliti untuk membuat queenode baru; Fungsi utiliti untuk mewujudkan giliran kapasiti yang diberikan; Fungsi utiliti untuk memeriksa sama ada saiz barisan yang diberikan ialah 1; Fungsi utiliti untuk memeriksa sama ada giliran diberikan kosong; Fungsi utiliti untuk memeriksa sama ada giliran yang diberikan penuh; Fungsi utiliti untuk menambah item ke barisan; Fungsi utiliti untuk mengeluarkan item dari barisan; Sekiranya terdapat hanya satu item dalam barisan; Fungsi utiliti untuk mendapatkan dari barisan; Fungsi untuk mendapatkan item minimum dari dua beratur; Langkah 3. A: Jika barisan pertama kosong, dequeue dari barisan kedua; Langkah 3. B: Jika barisan kedua kosong, dequeue dari barisan pertama; Langkah 3. C: Selain itu, bandingkan bahagian depan dua beratur dan minimum; Fungsi utiliti untuk memeriksa sama ada nod ini adalah daun; Fungsi utiliti untuk mencetak pelbagai saiz n; Fungsi utama yang membina pokok Huffman; Langkah 1: Buat dua beratur kosong; Langkah 2: Buat nod daun untuk setiap watak yang unik dan enqueue ke barisan pertama dalam urutan kekerapan yang tidak menurun. Pada mulanya barisan kedua kosong; Jalankan semasa beratur mengandungi lebih daripada satu nod. Akhirnya, giliran pertama akan menjadi kosong dan giliran kedua akan mengandungi hanya satu nod; Langkah 3: Dequeue dua nod dengan kekerapan minimum dengan memeriksa bahagian depan kedua -dua beratur; Langkah 4: Buat nod dalaman baru dengan kekerapan sama dengan jumlah frekuensi dua nod. Enqueue nod ini ke barisan kedua. ; Cetak kod Huffman dari akar pokok Huffman. Ia menggunakan ARR [] untuk menyimpan kod; Berikan 0 ke tepi kiri dan berulang; Berikan 1 ke tepi kanan dan berulang; Jika ini adalah nod daun, maka ia mengandungi salah satu aksara input, mencetak watak dan kodnya dari ARR []; Fungsi utama yang membina pokok Huffman dan kod cetak dengan melintasi pokok Huffman yang dibina; Membina pokok Huffman; Cetak kod Huffman menggunakan pokok Huffman yang dibina di atas; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define MAX_TREE_HT  100 NEW_LINE struct QueueNode { char data ; unsigned freq ; struct QueueNode * left , * right ; } ; struct Queue { int front , rear ; int capacity ; struct QueueNode * * array ; } ; struct QueueNode * newNode ( char data , unsigned freq ) { struct QueueNode * temp = ( struct QueueNode * ) malloc ( sizeof ( struct QueueNode ) ) ; temp -> left = temp -> right = NULL ; temp -> data = data ; temp -> freq = freq ; return temp ; } struct Queue * createQueue ( int capacity ) { struct Queue * queue = ( struct Queue * ) malloc ( sizeof ( struct Queue ) ) ; queue -> front = queue -> rear = -1 ; queue -> capacity = capacity ; queue -> array = ( struct QueueNode * * ) malloc ( queue -> capacity * sizeof ( struct QueueNode * ) ) ; return queue ; } int isSizeOne ( struct Queue * queue ) { return queue -> front == queue -> rear && queue -> front != -1 ; } int isEmpty ( struct Queue * queue ) { return queue -> front == -1 ; } int isFull ( struct Queue * queue ) { return queue -> rear == queue -> capacity - 1 ; } void enQueue ( struct Queue * queue , struct QueueNode * item ) { if ( isFull ( queue ) ) return ; queue -> array [ ++ queue -> rear ] = item ; if ( queue -> front == -1 ) ++ queue -> front ; } struct QueueNode * deQueue ( struct Queue * queue ) { if ( isEmpty ( queue ) ) return NULL ; struct QueueNode * temp = queue -> array [ queue -> front ] ; if ( queue -> front == queue -> rear ) queue -> front = queue -> rear = -1 ; else ++ queue -> front ; return temp ; } struct QueueNode * getFront ( struct Queue * queue ) { if ( isEmpty ( queue ) ) return NULL ; return queue -> array [ queue -> front ] ; } struct QueueNode * findMin ( struct Queue * firstQueue , struct Queue * secondQueue ) { if ( isEmpty ( firstQueue ) ) return deQueue ( secondQueue ) ; if ( isEmpty ( secondQueue ) ) return deQueue ( firstQueue ) ; if ( getFront ( firstQueue ) -> freq < getFront ( secondQueue ) -> freq ) return deQueue ( firstQueue ) ; return deQueue ( secondQueue ) ; } int isLeaf ( struct QueueNode * root ) { return ! ( root -> left ) && ! ( root -> right ) ; } void printArr ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) printf ( \" % d \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } struct QueueNode * buildHuffmanTree ( char data [ ] , int freq [ ] , int size ) { struct QueueNode * left , * right , * top ; struct Queue * firstQueue = createQueue ( size ) ; struct Queue * secondQueue = createQueue ( size ) ; for ( int i = 0 ; i < size ; ++ i ) enQueue ( firstQueue , newNode ( data [ i ] , freq [ i ] ) ) ; while ( ! ( isEmpty ( firstQueue ) && isSizeOne ( secondQueue ) ) ) { left = findMin ( firstQueue , secondQueue ) ; right = findMin ( firstQueue , secondQueue ) ; top = newNode ( ' $ ' , left -> freq + right -> freq ) ; top -> left = left ; top -> right = right ; enQueue ( secondQueue , top ) ; } return deQueue ( secondQueue ) ; } void printCodes ( struct QueueNode * root , int arr [ ] , int top ) { if ( root -> left ) { arr [ top ] = 0 ; printCodes ( root -> left , arr , top + 1 ) ; } if ( root -> right ) { arr [ top ] = 1 ; printCodes ( root -> right , arr , top + 1 ) ; } if ( isLeaf ( root ) ) { printf ( \" % c : ▁ \" , root -> data ) ; printArr ( arr , top ) ; } } void HuffmanCodes ( char data [ ] , int freq [ ] , int size ) { struct QueueNode * root = buildHuffmanTree ( data , freq , size ) ; int arr [ MAX_TREE_HT ] , top = 0 ; printCodes ( root , arr , top ) ; } int main ( ) { char arr [ ] = { ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' } ; int freq [ ] = { 5 , 9 , 12 , 13 , 16 , 45 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; HuffmanCodes ( arr , freq , size ) ; return 0 ; }"}
{"text": "Susunan Umum Terpanjang | DP | Pelaksanaan rekursif naif masalah LCS; Mengembalikan panjang LCS untuk x [0 .. m - 1], y [0 .. n - 1]; Fungsi utiliti untuk mendapatkan maksimum 2 bilangan bulat; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE int max ( int a , int b ) ; int lcs ( char * X , char * Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } int main ( ) { char X [ ] = \" AGGTAB \" ; char Y [ ] = \" GXTXAYB \" ; int m = strlen ( X ) ; int n = strlen ( Y ) ; printf ( \" Length ▁ of ▁ LCS ▁ is ▁ % d \" , lcs ( X , Y , m , n ) ) ; return 0 ; }"}
{"text": "Susunan Umum Terpanjang | DP | Pengaturcaraan dinamik C pelaksanaan masalah LCS; Mengembalikan panjang LCS untuk x [0 .. m - 1], y [0 .. n - 1]; Langkah -langkah berikut membina l [m + 1] [n + 1] dalam fesyen bawah. Perhatikan bahawa l [i] [j] mengandungi panjang LCs x [0 .. i - 1] dan y [0. .. J - 1]; L [M] [n] mengandungi panjang LCS untuk x [0 .. n - 1] dan y [0 .. m - 1]; Fungsi utiliti untuk mendapatkan maksimum 2 bilangan bulat; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE int max ( int a , int b ) ; int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } int main ( ) { char X [ ] = \" AGGTAB \" ; char Y [ ] = \" GXTXAYB \" ; int m = strlen ( X ) ; int n = strlen ( Y ) ; printf ( \" Length ▁ of ▁ LCS ▁ is ▁ % d \" , lcs ( X , Y , m , n ) ) ; return 0 ; }"}
{"text": "Laluan Kos Min | DP | Pelaksanaan rekursif naif MCP (laluan kos minimum); Fungsi utiliti yang mengembalikan minimum 3 bilangan bulat; Mengembalikan kos laluan kos minimum dari (0, 0) hingga (m, n) dalam tikar [r] [c]; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE int min ( int x , int y , int z ) ; int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } int minCost ( int cost [ R ] [ C ] , int m , int n ) { if ( n < 0 m < 0 ) return INT_MAX ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; printf ( \" ▁ % d ▁ \" , minCost ( cost , 2 , 2 ) ) ; return 0 ; }"}
{"text": "Laluan Kos Min | DP | Pelaksanaan pengaturcaraan dinamik masalah MCP; Daripada baris berikut, kita boleh menggunakan Int Tc [M + 1] [n + 1] atau secara dinamik memperuntukkan memori untuk menjimatkan ruang. Baris berikut digunakan untuk memastikan program ini mudah dan menjadikannya berfungsi pada semua penyusun. ; Memulakan lajur pertama jumlah kos (TC); Memulakan baris pertama tc array; Membina selebihnya dari array TC; Fungsi utiliti yang mengembalikan minimum 3 bilangan bulat; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE int min ( int x , int y , int z ) ; int minCost ( int cost [ R ] [ C ] , int m , int n ) { int i , j ; int tc [ R ] [ C ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; } int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; printf ( \" ▁ % d ▁ \" , minCost ( cost , 2 , 2 ) ) ; return 0 ; }"}
{"text": "0 | Pelaksanaan rekursif naif masalah 0 - 1 Knapsack; Fungsi utiliti yang mengembalikan maksimum dua bilangan bulat; Mengembalikan nilai maksimum yang boleh dimasukkan ke dalam kapasiti kapasiti w; Kes asas; Jika berat item nth lebih daripada kapasiti knapsack W, maka item ini tidak dapat dimasukkan ke dalam penyelesaian optimum; Kembalikan maksimum dua kes: (1) item Nth termasuk (2) tidak termasuk; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printf ( \" % d \" , knapSack ( W , wt , val , n ) ) ; return 0 ; }"}
{"text": "0 | Penyelesaian berasaskan pengaturcaraan dinamik untuk masalah 0 - 1 Knapsack; Fungsi utiliti yang mengembalikan maksimum dua bilangan bulat; Mengembalikan nilai maksimum yang boleh dimasukkan ke dalam kapasiti kapasiti w; Membina jadual k [] [] dengan cara bawah; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; } int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printf ( \" % d \" , knapSack ( W , wt , val , n ) ) ; return 0 ; }"}
{"text": "Teka -teki menjatuhkan telur | DP |  ; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Berfungsi untuk mendapatkan bilangan minimum ujian yang diperlukan dalam kes terburuk dengan telur N dan l lantai; Sekiranya tiada lantai, maka tiada ujian diperlukan. Atau jika terdapat satu lantai, satu percubaan diperlukan. ; Kami memerlukan ujian k untuk satu lantai telur dan k; Pertimbangkan semua kotoran dari lantai 1 ke lantai kth dan kembalikan minimum nilai -nilai ini ditambah 1 .; Program Pemandu untuk Menguji ProntDups", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int eggDrop ( int n , int k ) { if ( k == 1 k == 0 ) return k ; if ( n == 1 ) return k ; int min = INT_MAX , x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; } int main ( ) { int n = 2 , k = 10 ; printf ( \" nMinimum ▁ number ▁ of ▁ trials ▁ in ▁ \" \" worst ▁ case ▁ with ▁ % d ▁ eggs ▁ and ▁ \" \" % d ▁ floors ▁ is ▁ % d ▁ STRNEWLINE \" , n , k , eggDrop ( n , k ) ) ; return 0 ; }"}
{"text": "Palindromik Palindromik Terpanjang | DP | C Program pendekatan di atas; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Mengembalikan panjang Palindromic yang paling lama di SEQ; Kes asas 1: Jika hanya ada 1 aksara; Kes asas 2: Jika hanya terdapat 2 aksara dan kedua -duanya sama; Jika watak pertama dan terakhir sepadan; Jika watak pertama dan terakhir tidak sepadan; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int max ( int x , int y ) { return ( x > y ) ? x : y ; } int lps ( char * seq , int i , int j ) { if ( i == j ) return 1 ; if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ; if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ; return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } int main ( ) { char seq [ ] = \" GEEKSFORGEEKS \" ; int n = strlen ( seq ) ; printf ( \" The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d \" , lps ( seq , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Masalah Bungkus Word | DP | Penyelesaian pengaturcaraan dinamik untuk masalah bungkus perkataan; Fungsi utiliti untuk mencetak penyelesaian; L [] mewakili panjang perkataan yang berbeza dalam urutan input. Sebagai contoh, l [] = {3, 2, 2, 5} adalah untuk ayat seperti \"aaa u u u u ddddd\". n ialah saiz L [] dan m adalah lebar garis (maksimum no aksara yang boleh dimuatkan dalam garis); Untuk kesederhanaan, 1 ruang tambahan digunakan dalam semua di bawah tatasusunan tambahan [i] [j] akan mempunyai bilangan ruang tambahan jika kata -kata dari i ke j dimasukkan ke dalam satu baris; Lc [i] [j] akan mempunyai kos garis yang mempunyai kata -kata dari saya ke j; C [i] akan mempunyai jumlah kos susunan kata -kata yang optimum dari 1 hingga i; P [] digunakan untuk mencetak penyelesaian. ; Kirakan ruang tambahan dalam satu baris. Nilai tambahan [i] [j] menunjukkan ruang tambahan jika kata -kata dari nombor perkataan i ke j diletakkan dalam satu baris; Kirakan kos garis yang sepadan dengan ruang tambahan yang dikira di atas. Nilai LC [i] [j] menunjukkan kos meletakkan kata -kata dari nombor perkataan i ke j dalam satu baris; Kirakan kos minimum dan cari susunan kos minimum. Nilai C [j] menunjukkan kos yang dioptimumkan untuk mengatur perkataan dari nombor perkataan 1 hingga j. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #define INF  INT_MAX NEW_LINE int printSolution ( int p [ ] , int n ) ; int printSolution ( int p [ ] , int n ) { int k ; if ( p [ n ] == 1 ) k = 1 ; else k = printSolution ( p , p [ n ] - 1 ) + 1 ; printf ( \" Line ▁ number ▁ % d : ▁ From ▁ word ▁ no . ▁ % d ▁ to ▁ % d ▁ STRNEWLINE \" , k , p [ n ] , n ) ; return k ; } void solveWordWrap ( int l [ ] , int n , int M ) { int extras [ n + 1 ] [ n + 1 ] ; int lc [ n + 1 ] [ n + 1 ] ; int c [ n + 1 ] ; int p [ n + 1 ] ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; } for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = INF ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } } c [ 0 ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { c [ j ] = INF ; for ( i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != INF && lc [ i ] [ j ] != INF && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; } int main ( ) { int l [ ] = { 3 , 2 , 2 , 5 } ; int n = sizeof ( l ) / sizeof ( l [ 0 ] ) ; int M = 6 ; solveWordWrap ( l , n , M ) ; return 0 ; }"}
{"text": "Pokok carian binari optimum | DP | Pelaksanaan rekursif naif masalah pokok carian binari yang optimum; Fungsi utiliti untuk mendapatkan jumlah unsur array freq [i] ke freq [j]; Fungsi rekursif untuk mengira kos pokok carian binari yang optimum; Kes asas tiada unsur dalam subarray ini; Satu elemen dalam subarray ini; Dapatkan jumlah freq [i], freq [i + 1], ... freq [j]; Memulakan nilai minimum; Satu demi satu menganggap semua elemen sebagai akar dan rekursif mencari kos BST, bandingkan kos dengan min dan kemas kini min jika diperlukan; Mengembalikan nilai minimum; Fungsi utama yang mengira kos minimum pokok carian binari. Ia terutamanya menggunakan OptCost () untuk mencari kos yang optimum. ; Di sini kunci array [] diandaikan disusun dalam peningkatan urutan. Jika kekunci [] tidak disusun, kemudian tambahkan kod untuk menyusun kekunci, dan menyusun semula Freq [] dengan sewajarnya. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; } int optCost ( int freq [ ] , int i , int j ) { if ( j < i ) return 0 ; if ( j == i ) return freq [ i ] ; int fsum = sum ( freq , i , j ) ; int min = INT_MAX ; for ( int r = i ; r <= j ; ++ r ) { int cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; } return min + fsum ; } int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { return optCost ( freq , 0 , n - 1 ) ; } int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; printf ( \" Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ % d ▁ \" , optimalSearchTree ( keys , freq , n ) ) ; return 0 ; }"}
{"text": "Pokok carian binari optimum | DP | Kod pengaturcaraan dinamik untuk masalah pokok carian binari yang optimum; Fungsi utiliti untuk mendapatkan jumlah unsur array freq [i] ke freq [j]; Fungsi berasaskan pengaturcaraan dinamik yang mengira kos minimum pokok carian binari. ; Buat matriks 2D tambahan untuk menyimpan hasil subproblem; Untuk satu kunci, kos adalah sama dengan kekerapan kunci; Sekarang kita perlu mempertimbangkan rantai panjang 2, 3, .... L adalah panjang rantai. ; Saya adalah nombor baris dalam kos [] []; Dapatkan nombor lajur J dari Nombor Baris I dan panjang rantai L; Cuba buat semua kunci dalam kekunci selang [i. . j] sebagai akar; c = kos apabila kunci [r] menjadi akar subtree ini; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; } int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { int cost [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = freq [ i ] ; for ( int L = 2 ; L <= n ; L ++ ) { for ( int i = 0 ; i <= n - L + 1 ; i ++ ) { int j = i + L - 1 ; cost [ i ] [ j ] = INT_MAX ; for ( int r = i ; r <= j ; r ++ ) { int c = ( ( r > i ) ? cost [ i ] [ r - 1 ] : 0 ) + ( ( r < j ) ? cost [ r + 1 ] [ j ] : 0 ) + sum ( freq , i , j ) ; if ( c < cost [ i ] [ j ] ) cost [ i ] [ j ] = c ; } } } return cost [ 0 ] [ n - 1 ] ; } int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; printf ( \" Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ % d ▁ \" , optimalSearchTree ( keys , freq , n ) ) ; return 0 ; }"}
{"text": "Masalah Set Bebas Terbesar | DP | Pelaksanaan rekursif naif masalah set bebas terbesar; Fungsi utiliti untuk mencari maksimum dua bilangan bulat; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi ini mengembalikan saiz set bebas terbesar dalam pokok binari yang diberikan; Saiz cacing tidak termasuk nod semasa; Hitung saiz termasuk nod semasa; Mengembalikan maksimum dua saiz; Fungsi utiliti untuk membuat nod; Program pemacu untuk menguji fungsi di atas; Mari kita buat pokok yang diberikan dalam rajah di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int max ( int x , int y ) { return ( x > y ) ? x : y ; } struct node { int data ; struct node * left , * right ; } ; int LISS ( struct node * root ) { if ( root == NULL ) return 0 ; int size_excl = LISS ( root -> left ) + LISS ( root -> right ) ; int size_incl = 1 ; if ( root -> left ) size_incl += LISS ( root -> left -> left ) + LISS ( root -> left -> right ) ; if ( root -> right ) size_incl += LISS ( root -> right -> left ) + LISS ( root -> right -> right ) ; return max ( size_incl , size_excl ) ; } struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printf ( \" Size ▁ of ▁ the ▁ Largest ▁ Independent ▁ Set ▁ is ▁ % d ▁ \" , LISS ( root ) ) ; return 0 ; }"}
{"text": "Masalah Keypad Numerik Mudah Alih | Ruang yang dioptimumkan C untuk mengira bilangan bilangan yang mungkin panjang; Kembalikan kiraan semua kemungkinan bilangan panjang n dalam papan kekunci angka yang diberikan; Ganjil [i], walaupun [i] array mewakili kiraan nombor bermula dengan digit i untuk apa -apa panjang j; untuk j = 1; Pengiraan bawah dari j = 2 hingga n; Di sini kita secara eksplisit menulis baris untuk setiap nombor 0 hingga 9. Tetapi ia sentiasa boleh ditulis sebagai DFS pada 4 x3 grid menggunakan baris, lajur array yang sah bergerak; Dapatkan kiraan semua kemungkinan bilangan panjang \"n\" bermula dengan digit 0, 1, 2, ..., 9; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int getCount ( char keypad [ ] [ 3 ] , int n ) { if ( keypad == NULL n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int odd [ 10 ] , even [ 10 ] ; int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; } int main ( ) { char keypad [ 4 ] [ 3 ] = { { '1' , '2' , '3' } , { '4' , '5' , '6' } , { '7' , '8' , '9' } , { ' * ' , '0' , ' # ' } } ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 1 , getCount ( keypad , 1 ) ) ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 2 , getCount ( keypad , 2 ) ) ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 3 , getCount ( keypad , 3 ) ) ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 4 , getCount ( keypad , 4 ) ) ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 5 , getCount ( keypad , 5 ) ) ; return 0 ; }"}
{"text": "Masalah penutup puncak | Tetapkan 2 (penyelesaian pengaturcaraan dinamik untuk pokok) | Program berasaskan pengaturcaraan dinamik untuk masalah penutup puncak untuk pokok binari; Fungsi utiliti untuk mencari min dua bilangan bulat; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi berasaskan memoisasi yang mengembalikan saiz penutup puncak minimum. ; Saiz penutup puncak minimum adalah sifar jika pokok kosong atau hanya ada satu nod; Jika penutup vertex untuk nod ini sudah dinilai, maka kembalikannya untuk menyelamatkan rekomputasi subproblem yang sama sekali lagi. ; Hitung saiz penutup puncak apabila akar adalah sebahagian daripadanya; Kirakan saiz penutup puncak apabila akar bukan sebahagian daripadanya; Minimum dua nilai adalah penutup puncak, simpan sebelum kembali; Fungsi utiliti untuk membuat nod; Tetapkan penutup puncak sebagai 0; Program pemacu untuk menguji fungsi di atas; Mari kita buat pokok yang diberikan dalam rajah di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int min ( int x , int y ) { return ( x < y ) ? x : y ; } struct node { int data ; int vc ; struct node * left , * right ; } ; int vCover ( struct node * root ) { if ( root == NULL ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return 0 ; if ( root -> vc != 0 ) return root -> vc ; int size_incl = 1 + vCover ( root -> left ) + vCover ( root -> right ) ; int size_excl = 0 ; if ( root -> left ) size_excl += 1 + vCover ( root -> left -> left ) + vCover ( root -> left -> right ) ; if ( root -> right ) size_excl += 1 + vCover ( root -> right -> left ) + vCover ( root -> right -> right ) ; root -> vc = min ( size_incl , size_excl ) ; return root -> vc ; } struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; temp -> vc = 0 ; return temp ; } int main ( ) { struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printf ( \" Size ▁ of ▁ the ▁ smallest ▁ vertex ▁ cover ▁ is ▁ % d ▁ \" , vCover ( root ) ) ; return 0 ; }"}
{"text": "Mengira jumlah cara untuk mencapai skor yang diberikan dalam permainan | Program C untuk mengira bilangan cara yang mungkin untuk skor tertentu boleh dicapai dalam permainan di mana langkah boleh mendapat 3 atau 5 atau 10; Mengembalikan bilangan cara untuk mencapai skor n; Jadual [i] akan menyimpan kiraan penyelesaian untuk nilai i. ; Memulakan semua nilai jadual sebagai 0; Kes asas (jika diberi nilai adalah 0); Satu demi satu mempertimbangkan diberikan 3 langkah dan mengemas kini nilai [] nilai selepas indeks lebih besar daripada atau sama dengan nilai langkah yang dipilih; Program Pemandu", "code": "#include <stdio.h> NEW_LINE int count ( int n ) { int table [ n + 1 ] , i ; memset ( table , 0 , sizeof ( table ) ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; } int main ( void ) { int n = 20 ; printf ( \" Count ▁ for ▁ % d ▁ is ▁ % d STRNEWLINE \" , n , count ( n ) ) ; n = 13 ; printf ( \" Count ▁ for ▁ % d ▁ is ▁ % d \" , n , count ( n ) ) ; return 0 ; }"}
{"text": "Algoritma naif untuk mencari corak | Program c untuk algoritma corak corak naif; Gelung untuk meluncur pat [] satu demi satu; Untuk indeks semasa I, periksa perlawanan corak; Jika Pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; } } int main ( ) { char txt [ ] = \" AABAACAADAABAAABAA \" ; char pat [ ] = \" AABA \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Rabin | Berikutan program adalah pelaksanaan algoritma Rabin Karp yang diberikan dalam buku CLRS; D ialah bilangan aksara dalam abjad input; Pat -> Corak Txt -> Teks Q -> Nombor Perdana; nilai hash untuk corak; nilai hash untuk txt; Nilai H ialah \"pow (d, u, 1) % q\"; Kirakan nilai hash corak dan tetingkap pertama teks; Luncurkan corak ke atas teks satu demi satu; Semak nilai hash tetingkap semasa teks dan corak. Jika nilai hash sepadan maka hanya periksa aksara oleh satu; Semak watak satu demi satu; jika p == t dan pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]; Kirakan nilai hash untuk tetingkap teks seterusnya: Keluarkan digit terkemuka, tambah digit trailing; Kami mungkin mendapat nilai negatif T, menukarnya kepada positif; Kod pemacu; Nombor perdana; panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define d  256 NEW_LINE void search ( char pat [ ] , char txt [ ] , int q ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i , j ; int p = 0 ; int t = 0 ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; } if ( j == M ) printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; } if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } int main ( ) { char txt [ ] = \" GEEKS ▁ FOR ▁ GEEKS \" ; char pat [ ] = \" GEEK \" ; int q = 101 ; search ( pat , txt , q ) ; return 0 ; }"}
{"text": "Algoritma naif yang dioptimumkan untuk mencari corak | Program C untuk algoritma mencari corak naif yang diubahsuai yang dioptimumkan untuk kes -kes apabila semua watak corak adalah berbeza; Algorithn mencari Pettern Naive yang dioptimumkan untuk kes -kes apabila semua watak corak adalah berbeza; Untuk indeks semasa I, periksa perlawanan corak; Jika Pat [0 .. . M - 1] = txt [i, i + 1, ... i + m - 1]; Luncurkan corak oleh J; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void search ( char pat [ ] , char txt [ ] ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } int main ( ) { char txt [ ] = \" ABCEABCDABCEABCD \" ; char pat [ ] = \" ABCD \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Algoritma automata terhingga untuk carian corak | Program C untuk algoritma corak corak automata terhingga; Jika watak C adalah sama dengan watak seterusnya dalam corak, maka hanya keadaan kenaikan; NS menyimpan hasil yang seterusnya; NS akhirnya mengandungi awalan terpanjang yang juga akhiran dalam \"Pat [0. Fungsi ini membina jadual TF yang mewakili 4 automata terhingga untuk corak yang diberikan; Cetak semua kejadian Pat dalam TXT; Proses txt ke atas FA. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE int getNextState ( char * pat , int M , int state , int x ) { if ( state < M && x == pat [ state ] ) return state + 1 ; int ns , i ; for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] == x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) if ( pat [ i ] != pat [ state - ns + 1 + i ] ) break ; if ( i == ns - 1 ) return ns ; } } return 0 ; } void computeTF ( char * pat , int M , int TF [ ] [ NO_OF_CHARS ] ) { int state , x ; for ( state = 0 ; state <= M ; ++ state ) for ( x = 0 ; x < NO_OF_CHARS ; ++ x ) TF [ state ] [ x ] = getNextState ( pat , M , state , x ) ; } void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int TF [ M + 1 ] [ NO_OF_CHARS ] ; computeTF ( pat , M , TF ) ; int i , state = 0 ; for ( i = 0 ; i < N ; i ++ ) { state = TF [ state ] [ txt [ i ] ] ; if ( state == M ) printf ( \" Pattern found at index % d \" , i - M + 1 ) ; } } int main ( ) { char * txt = \" AABAACAADAABAAABAA \" ; char * pat = \" AABA \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Algoritma Boyer Moore untuk Pencarian Corak | Program C untuk Heuristik Bad Heuristik Boyer Moore String Algoritma yang sepadan; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Fungsi pra -proses untuk heuristik watak buruk Boyer Moore; Memulakan semua kejadian sebagai - 1; Isi nilai sebenar kejadian terakhir watak; Fungsi carian corak yang menggunakan heuristik watak buruk dari algoritma Boyer Moore; Isi pelbagai watak yang buruk dengan memanggil fungsi preprocessing badcharheuristic () untuk corak yang diberikan; s adalah peralihan corak berkenaan dengan teks; Terdapat n - m + 1 yang berpotensi untuk memotret; Terus mengurangkan indeks j corak manakala watak -watak corak dan teks sepadan dengan peralihan ini; Jika corak hadir pada peralihan semasa, maka indeks j akan menjadi - 1 selepas gelung di atas; Peralih corak supaya watak seterusnya dalam teks sejajar dengan kejadian terakhir dalam coraknya. Keadaan s + m <n diperlukan untuk kes apabila corak berlaku pada akhir teks; Pergeseran corak supaya watak buruk dalam teks sejajar dengan kejadian terakhir dalam coraknya. Fungsi maksimum digunakan untuk memastikan kita mendapat peralihan positif. Kita mungkin mendapat peralihan negatif jika kejadian terakhir yang buruk dalam corak berada di sebelah kanan watak semasa. ; Program pemacu untuk menguji fungsi di atas", "code": "# include <limits.h> NEW_LINE # include <string.h> NEW_LINE # include <stdio.h> NEW_LINE # define NO_OF_CHARS  256 NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } void badCharHeuristic ( char * str , int size , int badchar [ NO_OF_CHARS ] ) { int i ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) badchar [ i ] = -1 ; for ( i = 0 ; i < size ; i ++ ) badchar [ ( int ) str [ i ] ] = i ; } void search ( char * txt , char * pat ) { int m = strlen ( pat ) ; int n = strlen ( txt ) ; int badchar [ NO_OF_CHARS ] ; badCharHeuristic ( pat , m , badchar ) ; int s = 0 ; while ( s <= ( n - m ) ) { int j = m - 1 ; while ( j >= 0 && pat [ j ] == txt [ s + j ] ) j -- ; if ( j < 0 ) { printf ( \" pattern occurs at shift = % d \" , s ) ; s += ( s + m < n ) ? m - badchar [ txt [ s + m ] ] : 1 ; } else s += max ( 1 , j - badchar [ txt [ s + j ] ] ) ; } } int main ( ) { char txt [ ] = \" ABAAABCD \" ; char pat [ ] = \" ABC \" ; search ( txt , pat ) ; return 0 ; }"}
{"text": "Subset Sum | Backtracking |  ; cetakan subset yang dijumpai; input s - set vektor t - tuplet vector s_size - set saiz t_size - saiz tuplet setakat ini jumlahnya setakat ini - nod mengira sasaran_sum - jumlah yang dapat dijumpai; Kami mendapati subset; Kecualikan item yang ditambah sebelum ini dan pertimbangkan calon seterusnya; menjana nod sepanjang keluasan; Pertimbangkan nod tahap seterusnya (sepanjang kedalaman); Pembalut untuk mencetak subset yang jumlahnya ke input target_sum adalah vektor berat dan target_sum; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define ARRAYSIZE ( a )  (sizeof(a))/(sizeof(a[0])) NEW_LINE static int total_nodes ; void printSubset ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { printf ( \" % * d \" , 5 , A [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } void subset_sum ( int s [ ] , int t [ ] , int s_size , int t_size , int sum , int ite , int const target_sum ) { total_nodes ++ ; if ( target_sum == sum ) { printSubset ( t , t_size ) ; subset_sum ( s , t , s_size , t_size - 1 , sum - s [ ite ] , ite + 1 , target_sum ) ; return ; } else { for ( int i = ite ; i < s_size ; i ++ ) { t [ t_size ] = s [ i ] ; subset_sum ( s , t , s_size , t_size + 1 , sum + s [ i ] , i + 1 , target_sum ) ; } } } void generateSubsets ( int s [ ] , int size , int target_sum ) { int * tuplet_vector = ( int * ) malloc ( size * sizeof ( int ) ) ; subset_sum ( s , tuplet_vector , size , 0 , 0 , 0 , target_sum ) ; free ( tuplet_vector ) ; } int main ( ) { int weights [ ] = { 10 , 7 , 5 , 18 , 12 , 20 , 15 } ; int size = ARRAYSIZE ( weights ) ; generateSubsets ( weights , size , 35 ) ; printf ( \" Nodes ▁ generated ▁ % d ▁ STRNEWLINE \" , total_nodes ) ; return 0 ; }"}
{"text": "Subset Sum | Backtracking |  ; cetakan subset yang dijumpai; QSORT Bandingkan fungsi; input s - set vektor t - tuplet vector s_size - set saiz t_size - saiz tuplet setakat ini jumlahnya setakat ini - nod mengira sasaran_sum - jumlah yang dapat dijumpai; Kami menjumpai jumlah; pemeriksaan kekangan; Kecualikan item tambahan sebelumnya dan pertimbangkan calon seterusnya; pemeriksaan kekangan; menjana nod sepanjang keluasan; Pertimbangkan nod tahap seterusnya (sepanjang kedalaman); Pembalut yang mencetak subset yang jumlahnya ke target_sum; Susun set; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define ARRAYSIZE ( a )  (sizeof(a))/(sizeof(a[0])) NEW_LINE static int total_nodes ; void printSubset ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { printf ( \" % * d \" , 5 , A [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } int comparator ( const void * pLhs , const void * pRhs ) { int * lhs = ( int * ) pLhs ; int * rhs = ( int * ) pRhs ; return * lhs > * rhs ; } void subset_sum ( int s [ ] , int t [ ] , int s_size , int t_size , int sum , int ite , int const target_sum ) { total_nodes ++ ; if ( target_sum == sum ) { printSubset ( t , t_size ) ; if ( ite + 1 < s_size && sum - s [ ite ] + s [ ite + 1 ] <= target_sum ) { subset_sum ( s , t , s_size , t_size - 1 , sum - s [ ite ] , ite + 1 , target_sum ) ; } return ; } else { if ( ite < s_size && sum + s [ ite ] <= target_sum ) { for ( int i = ite ; i < s_size ; i ++ ) { t [ t_size ] = s [ i ] ; if ( sum + s [ i ] <= target_sum ) { subset_sum ( s , t , s_size , t_size + 1 , sum + s [ i ] , i + 1 , target_sum ) ; } } } } } void generateSubsets ( int s [ ] , int size , int target_sum ) { int * tuplet_vector = ( int * ) malloc ( size * sizeof ( int ) ) ; int total = 0 ; qsort ( s , size , sizeof ( int ) , & comparator ) ; for ( int i = 0 ; i < size ; i ++ ) { total += s [ i ] ; } if ( s [ 0 ] <= target_sum && total >= target_sum ) { subset_sum ( s , tuplet_vector , size , 0 , 0 , 0 , target_sum ) ; } free ( tuplet_vector ) ; } int main ( ) { int weights [ ] = { 15 , 22 , 14 , 26 , 32 , 9 , 16 , 8 } ; int target = 53 ; int size = ARRAYSIZE ( weights ) ; generateSubsets ( weights , size , target ) ; printf ( \" Nodes ▁ generated ▁ % d STRNEWLINE \" , total_nodes ) ; return 0 ; }"}
{"text": "Sudoku | Backtracking |  ; N ialah saiz matriks 2d n * n; Fungsi utiliti untuk mencetak grid; Memeriksa sama ada ia akan sah untuk memberikan NUM kepada baris yang diberikan, col; Semak jika kita dapati nombor yang sama dalam baris yang sama, kita kembali 0; Semak jika kita dapati NUM yang sama dalam lajur yang sama, kita kembali 0; Semak jika kita dapati NUM yang sama dalam matriks 3 * 3 tertentu, kita kembali 0; Mengambil sebahagiannya diisi - dalam grid dan cuba memberikan nilai kepada semua lokasi yang tidak ditugaskan sedemikian rupa untuk memenuhi keperluan untuk penyelesaian Sudoku (bukan duplikasi di seluruh baris, lajur, dan kotak); Semak jika kami telah mencapai baris ke -8 dan lajur ke -9 (0 Matriks diindeks), kami kembali benar untuk mengelakkan mundur lebih lanjut; Semak jika nilai lajur menjadi 9, kami bergerak ke baris dan lajur seterusnya bermula dari 0; Semak sama ada kedudukan semasa grid sudah mengandungi nilai> 0, kami melangkah untuk lajur seterusnya; Semak sama ada selamat untuk meletakkan NUM (1 - 9) dalam baris yang diberikan, col -> kami berpindah ke lajur seterusnya; Menetapkan NUM dalam kedudukan semasa (baris, col) grid dan mengandaikan NUM kami yang dipersembahkan dalam kedudukan adalah betul; Memeriksa kemungkinan seterusnya dengan lajur seterusnya; Mengeluarkan NUM yang diberikan, kerana andaian kami salah, dan kami pergi untuk andaian seterusnya dengan nilai diff Num; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define N  9 NEW_LINE void print ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( \" % d ▁ \" , arr [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } } int isSafe ( int grid [ N ] [ N ] , int row , int col , int num ) { for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ row ] [ x ] == num ) return 0 ; for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ x ] [ col ] == num ) return 0 ; int startRow = row - row % 3 , startCol = col - col % 3 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow ] [ j + startCol ] == num ) return 0 ; return 1 ; } int solveSuduko ( int grid [ N ] [ N ] , int row , int col ) { if ( row == N - 1 && col == N ) return 1 ; if ( col == N ) { row ++ ; col = 0 ; } if ( grid [ row ] [ col ] > 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( int num = 1 ; num <= N ; num ++ ) { if ( isSafe ( grid , row , col , num ) == 1 ) { grid [ row ] [ col ] = num ; if ( solveSuduko ( grid , row , col + 1 ) == 1 ) return 1 ; } grid [ row ] [ col ] = 0 ; } return 0 ; } int main ( ) { int grid [ N ] [ N ] = { { 3 , 0 , 6 , 5 , 0 , 8 , 4 , 0 , 0 } , { 5 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 8 , 7 , 0 , 0 , 0 , 0 , 3 , 1 } , { 0 , 0 , 3 , 0 , 1 , 0 , 0 , 8 , 0 } , { 9 , 0 , 0 , 8 , 6 , 3 , 0 , 0 , 5 } , { 0 , 5 , 0 , 0 , 9 , 0 , 6 , 0 , 0 } , { 1 , 3 , 0 , 0 , 0 , 0 , 2 , 5 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 4 } , { 0 , 0 , 5 , 2 , 0 , 6 , 3 , 0 , 0 } } ; if ( solveSuduko ( grid , 0 , 0 ) == 1 ) print ( grid ) ; else printf ( \" No ▁ solution ▁ exists \" ) ; return 0 ; }"}
{"text": "Median dari dua susunan yang disusun dengan saiz yang sama | Penyelesaian O (n) yang mudah digabungkan untuk mencari median dua susunan yang disusun; Fungsi ini mengembalikan median AR1 [] dan AR2 []. Andaian dalam fungsi ini: kedua -dua Ar1 [] dan Ar2 [] disusun susunan kedua -duanya mempunyai unsur N; Oleh kerana terdapat 2 elemen, median akan menjadi purata elemen pada indeks n - 1 dan n dalam array yang diperolehi selepas menggabungkan AR1 dan AR2; Di bawah ini adalah untuk mengendalikan kes di mana semua elemen AR1 [] lebih kecil daripada elemen terkecil (atau pertama) AR2 []; Di bawah ini adalah untuk mengendalikan kes di mana semua elemen AR2 [] lebih kecil daripada elemen terkecil (atau pertama) AR1 []; sama dengan tanda kerana jika dua tatasusunan mempunyai beberapa elemen biasa; Simpan median sebelumnya; Simpan median sebelumnya; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = -1 , m2 = -1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; } int main ( ) { int ar1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; if ( n1 == n2 ) printf ( \" Median ▁ is ▁ % d \" , getMedian ( ar1 , ar2 , n1 ) ) ; else printf ( \" Doesn ' t ▁ work ▁ for ▁ arrays ▁ of ▁ unequal ▁ size \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Median dari dua susunan yang disusun dengan saiz yang sama | Satu penyelesaian yang berpusat dan menaklukkan berasaskan untuk mencari median dua susunan yang disusun dengan saiz yang sama. ; untuk mendapatkan median array yang disusun; Fungsi ini mengembalikan median AR1 [] dan AR2 []. Andaian dalam fungsi ini: kedua -dua Ar1 [] dan Ar2 [] disusun susunan kedua -duanya mempunyai unsur N; Dapatkan median array pertama; Dapatkan median array kedua; Jika median sama maka kembali sama ada M1 atau M2; Jika m1 <m2 maka median mesti wujud dalam ar1 [m1 .... ] dan ar2 [.... m2]; Jika m1> m2 maka median mesti wujud di AR1 [.... m1] dan ar2 [m2 ...]; Berfungsi untuk mendapatkan median array yang disusun; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int median ( int [ ] , int ) ; int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { if ( n <= 0 ) return -1 ; if ( n == 1 ) return ( ar1 [ 0 ] + ar2 [ 0 ] ) / 2 ; if ( n == 2 ) return ( max ( ar1 [ 0 ] , ar2 [ 0 ] ) + min ( ar1 [ 1 ] , ar2 [ 1 ] ) ) / 2 ; int m1 = median ( ar1 , n ) ; int m2 = median ( ar2 , n ) ; if ( m1 == m2 ) return m1 ; if ( m1 < m2 ) { if ( n % 2 == 0 ) return getMedian ( ar1 + n / 2 - 1 , ar2 , n - n / 2 + 1 ) ; return getMedian ( ar1 + n / 2 , ar2 , n - n / 2 ) ; } if ( n % 2 == 0 ) return getMedian ( ar2 + n / 2 - 1 , ar1 , n - n / 2 + 1 ) ; return getMedian ( ar2 + n / 2 , ar1 , n - n / 2 ) ; } int median ( int arr [ ] , int n ) { if ( n % 2 == 0 ) return ( arr [ n / 2 ] + arr [ n / 2 - 1 ] ) / 2 ; else return arr [ n / 2 ] ; } int main ( ) { int ar1 [ ] = { 1 , 2 , 3 , 6 } ; int ar2 [ ] = { 4 , 6 , 8 , 10 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; if ( n1 == n2 ) printf ( \" Median ▁ is ▁ % d \" , getMedian ( ar1 , ar2 , n1 ) ) ; else printf ( \" Doesn ' t ▁ work ▁ for ▁ arrays ▁ of ▁ unequal ▁ size \" ) ; return 0 ; }"}
{"text": "Sepasang mata terdekat menggunakan algoritma membahagikan dan menaklukkan | Program membahagikan dan menaklukkan dalam C / C ++ untuk mencari jarak terkecil dari satu set mata yang diberikan. ; Struktur untuk mewakili titik dalam satah 2d; Diperlukan untuk menyusun pelbagai mata mengikut koordinat x; Diperlukan untuk menyusun pelbagai mata mengikut koordinat Y; Fungsi utiliti untuk mencari jarak antara dua mata; Kaedah kekerasan untuk mengembalikan jarak terkecil antara dua mata dalam p [] saiz n; Fungsi utiliti untuk mencari sekurang -kurangnya dua nilai terapung; Fungsi utiliti untuk mencari jarak antara titik terdekat jalur saiz yang diberikan. Semua mata dalam jalur [] disusun mengikut koordinat y. Mereka semua mempunyai terikat atas pada jarak minimum sebagai d. Perhatikan bahawa kaedah ini seolah -olah menjadi kaedah O (n ^ 2), tetapi ia 's a o (n) kaedah sebagai gelung dalaman berjalan paling 6 kali; Memulakan jarak minimum sebagai d; Pilih semua mata satu demi satu dan cuba titik seterusnya sehingga perbezaan antara koordinat Y adalah lebih kecil daripada d. Ini adalah fakta yang terbukti bahawa gelung ini berjalan paling banyak 6 kali; Fungsi rekursif untuk mencari jarak terkecil. Arus P mengandungi semua mata yang disusun mengikut koordinat x; Sekiranya terdapat 2 atau 3 mata, maka gunakan kekerasan; Cari titik tengah; Pertimbangkan garis menegak melalui titik tengah Kirakan jarak terkecil DL di sebelah kiri titik tengah dan DR di sebelah kanan; Cari lebih kecil daripada dua jarak; Membina jalur array [] yang mengandungi titik dekat (lebih dekat daripada d) ke garisan melalui titik tengah; Cari mata terdekat dalam jalur. Kembali minimum d dan jarak terdekat adalah jalur []; Fungsi utama yang mendapati jarak terkecil kaedah ini terutamanya menggunakan CloseStUtil (); Gunakan fungsi rekursif CloseStUtil () untuk mencari jarak terkecil; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <float.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <math.h> NEW_LINE struct Point { int x , y ; } ; int compareX ( const void * a , const void * b ) { Point * p1 = ( Point * ) a , * p2 = ( Point * ) b ; return ( p1 -> x - p2 -> x ) ; } int compareY ( const void * a , const void * b ) { Point * p1 = ( Point * ) a , * p2 = ( Point * ) b ; return ( p1 -> y - p2 -> y ) ; } float dist ( Point p1 , Point p2 ) { return sqrt ( ( p1 . x - p2 . x ) * ( p1 . x - p2 . x ) + ( p1 . y - p2 . y ) * ( p1 . y - p2 . y ) ) ; } float bruteForce ( Point P [ ] , int n ) { float min = FLT_MAX ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i + 1 ; j < n ; ++ j ) if ( dist ( P [ i ] , P [ j ] ) < min ) min = dist ( P [ i ] , P [ j ] ) ; return min ; } float min ( float x , float y ) { return ( x < y ) ? x : y ; } float stripClosest ( Point strip [ ] , int size , float d ) { float min = d ; qsort ( strip , size , sizeof ( Point ) , compareY ) ; for ( int i = 0 ; i < size ; ++ i ) for ( int j = i + 1 ; j < size && ( strip [ j ] . y - strip [ i ] . y ) < min ; ++ j ) if ( dist ( strip [ i ] , strip [ j ] ) < min ) min = dist ( strip [ i ] , strip [ j ] ) ; return min ; } float closestUtil ( Point P [ ] , int n ) { if ( n <= 3 ) return bruteForce ( P , n ) ; int mid = n / 2 ; Point midPoint = P [ mid ] ; float dl = closestUtil ( P , mid ) ; float dr = closestUtil ( P + mid , n - mid ) ; float d = min ( dl , dr ) ; Point strip [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( abs ( P [ i ] . x - midPoint . x ) < d ) strip [ j ] = P [ i ] , j ++ ; return min ( d , stripClosest ( strip , j , d ) ) ; } float closest ( Point P [ ] , int n ) { qsort ( P , n , sizeof ( Point ) , compareX ) ; return closestUtil ( P , n ) ; } int main ( ) { Point P [ ] = { { 2 , 3 } , { 12 , 30 } , { 40 , 50 } , { 5 , 1 } , { 12 , 10 } , { 3 , 4 } } ; int n = sizeof ( P ) / sizeof ( P [ 0 ] ) ; printf ( \" The ▁ smallest ▁ distance ▁ is ▁ % f ▁ \" , closest ( P , n ) ) ; return 0 ; }"}
{"text": "Nombor bertuah |  ; Pulangan 1 Jika n adalah tidak bertuah. Ohterwise pulangan 0; Variable next_position hanya untuk kebolehbacaan program yang kita boleh mengeluarkannya dan menggunakan n sahaja; Kirakan kedudukan input No yang seterusnya; Fungsi pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isLucky ( int n ) { static int counter = 2 ; int next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; } int main ( ) { int x = 5 ; if ( isLucky ( x ) ) printf ( \" % d ▁ is ▁ a ▁ lucky ▁ no . \" , x ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ lucky ▁ no . \" , x ) ; getchar ( ) ; }"}
{"text": "Tulis kuasa anda sendiri tanpa menggunakan pengendali pendaraban ( *) dan pembahagian ( /) |  ; Berfungsi hanya jika a> = 0 dan b> = 0; program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; } int main ( ) { printf ( \" % d \" , pow ( 5 , 3 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Tulis kuasa anda sendiri tanpa menggunakan pengendali pendaraban ( *) dan pembahagian ( /) |  ; Fungsi rekursif untuk mendapatkan x * y; Fungsi rekursif untuk mendapatkan A ^ B berfungsi hanya jika a> = 0 dan b> = 0; program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int multiply ( int x , int y ) { if ( y ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; } int pow ( int a , int b ) { if ( b ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; } int main ( ) { printf ( \" % d \" , pow ( 5 , 3 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Kira nombor yang tidak mengandungi 3 |  ; Mengembalikan kiraan nombor yang berada dalam jarak dari 1 hingga N dan Don 't mengandungi 3 sebagai digit; Kes asas (dengan asumsi n tidak negatif); Kirakan 10 ^ (d - 1) (10 Raise ke kuasa d - 1) di mana d adalah bilangan digit dalam n. PO akan menjadi 100 untuk n = 578; Cari digit yang paling penting (MSD ialah 5 untuk 578); Untuk 578, jumlahnya akan menjadi 4 * kiraan (10 ^ 2 - 1) + 4 + kiraan (78); Untuk 35, jumlah akan sama dengan kiraan (29); Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; } int main ( ) { printf ( \" % d ▁ \" , count ( 578 ) ) ; return 0 ; }"}
{"text": "Kedudukan Lexicographic rentetan | C program untuk mencari pangkat lexicographic rentetan; Fungsi utiliti untuk mencari faktorial n; Fungsi utiliti untuk mengira aksara yang lebih kecil di sebelah kanan ARR [rendah]; Fungsi untuk mencari pangkat rentetan dalam semua permutasi aksara; kiraan bilangan chars lebih kecil daripada str [i] fron str [i + 1] ke str [len - 1]; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } int findSmallerInRight ( char * str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str [ i ] < str [ low ] ) ++ countRight ; return countRight ; } int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; int i ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ; countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; } int main ( ) { char str [ ] = \" string \" ; printf ( \" % d \" , findRank ( str ) ) ; return 0 ; }"}
{"text": "Kedudukan Lexicographic rentetan | Penyelesaian o (n) untuk mencari pangkat rentetan; Semua elemen kiraan [] diasaskan dengan 0; Fungsi utiliti untuk mencari faktorial n; Membina array kiraan di mana nilai pada setiap indeks mengandungi kiraan aksara yang lebih kecil dalam keseluruhan rentetan; Membuang watak ch dari Count [] array yang dibina oleh populateAndIncreaseCount (); Fungsi untuk mencari pangkat rentetan dalam semua permutasi aksara; Mengisi array kiraan seperti yang dikira [i] mengandungi kiraan aksara yang terdapat di STR dan lebih kecil daripada saya; kiraan bilangan chars lebih kecil daripada str [i] fron str [i + 1] ke str [len - 1]; Mengurangkan kiraan watak yang lebih besar daripada STR [i]; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define MAX_CHAR  256 NEW_LINE int count [ MAX_CHAR ] = { 0 } ; int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } void populateAndIncreaseCount ( int * count , char * str ) { int i ; for ( i = 0 ; str [ i ] ; ++ i ) ++ count [ str [ i ] ] ; for ( i = 1 ; i < MAX_CHAR ; ++ i ) count [ i ] += count [ i - 1 ] ; } void updatecount ( int * count , char ch ) { int i ; for ( i = ch ; i < MAX_CHAR ; ++ i ) -- count [ i ] ; } int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 , i ; populateAndIncreaseCount ( count , str ) ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ; rank += count [ str [ i ] - 1 ] * mul ; updatecount ( count , str [ i ] ) ; } return rank ; } int main ( ) { char str [ ] = \" string \" ; printf ( \" % d \" , findRank ( str ) ) ; return 0 ; }"}
{"text": "Cetak semua permutasi dalam susunan (lexicographic) yang disusun | Program untuk mencetak semua permutasi rentetan dalam urutan yang disusun. ; Fungsi berikut diperlukan untuk fungsi perpustakaan QSORT (). Rujuk http: www. cplusplus. com / rujukan / clibrary / cstdlib / qsort /; Fungsi utiliti dua swap dua aksara A dan B; Fungsi ini mendapati indeks watak terkecil yang lebih besar daripada 'pertama' dan terdapat dalam str [l. . h]; memulakan indeks elemen siling; Sekarang berulang melalui unsur -unsur yang lain dan cari watak terkecil lebih besar daripada 'pertama'; Cetak semua permutasi STR dalam urutan yang disusun; Dapatkan saiz rentetan; Menyusun rentetan dalam peningkatan urutan; Cetak permutasi satu demi satu; Cetak permutasi ini; Cari watak paling kanan yang lebih kecil daripada watak seterusnya. Marilah kita menyebutnya 'pertama ~ char'; Sekiranya tidak ada watak sedemikian, semuanya disusun dalam penurunan urutan, bermakna kita hanya mencetak permutasi terakhir dan kita sudah selesai. ; Cari ceil 'Pertama' Char 'di sebelah kanan watak pertama. Ceil of a Watak adalah watak terkecil yang lebih besar daripada itu; Bertukar watak pertama dan kedua; Susun rentetan di sebelah kanan 'Pertama ~ Char'; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE int compare ( const void * a , const void * b ) { return ( * ( char * ) a - * ( char * ) b ) ; } void swap ( char * a , char * b ) { char t = * a ; * a = * b ; * b = t ; } int findCeil ( char str [ ] , char first , int l , int h ) { int ceilIndex = l ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( str [ i ] > first && str [ i ] < str [ ceilIndex ] ) ceilIndex = i ; return ceilIndex ; } void sortedPermutations ( char str [ ] ) { int size = strlen ( str ) ; qsort ( str , size , sizeof ( str [ 0 ] ) , compare ) ; bool isFinished = false ; while ( ! isFinished ) { printf ( \" % s ▁ STRNEWLINE \" , str ) ; int i ; for ( i = size - 2 ; i >= 0 ; -- i ) if ( str [ i ] < str [ i + 1 ] ) break ; if ( i == -1 ) isFinished = true ; else { int ceilIndex = findCeil ( str , str [ i ] , i + 1 , size - 1 ) ; swap ( & str [ i ] , & str [ ceilIndex ] ) ; qsort ( str + i + 1 , size - i - 1 , sizeof ( str [ 0 ] ) , compare ) ; } } } int main ( ) { char str [ ] = \" ABCD \" ; sortedPermutations ( str ) ; return 0 ; }"}
{"text": "Cetak semua permutasi dalam susunan (lexicographic) yang disusun | Versi yang dioptimumkan yang menggunakan sebaliknya dan bukannya untuk mencari permutasi seterusnya fungsi utiliti untuk membalikkan string str [l. . h];  ;  ; Cetak semua permutasi STR dalam urutan yang disusun; Dapatkan saiz rentetan; Menyusun rentetan dalam peningkatan urutan; Cetak permutasi satu demi satu; Cetak permutasi ini; Cari watak paling kanan yang lebih kecil daripada watak seterusnya. Marilah kita menyebutnya 'pertama ~ char'; Sekiranya tidak ada watak sedemikian, semuanya disusun dalam penurunan urutan, bermakna kita hanya mencetak permutasi terakhir dan kita sudah selesai. ; Cari ceil 'Pertama' Char 'di sebelah kanan watak pertama. Ceil of a Watak adalah watak terkecil yang lebih besar daripada itu; Bertukar watak pertama dan kedua; membalikkan rentetan di sebelah kanan 'Pertama ~ Char'", "code": "void reverse ( char str [ ] , int l , int h ) { while ( l < h ) { swap ( & str [ l ] , & str [ h ] ) ; l ++ ; h -- ; } } void swap ( char * a , char * b ) { char t = * a ; * a = * b ; * b = t ; } int compare ( const void * a , const void * b ) { return ( * ( char * ) a - * ( char * ) b ) ; } int findCeil ( char str [ ] , char first , int l , int h ) { int ceilIndex = l ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( str [ i ] > first && str [ i ] < str [ ceilIndex ] ) ceilIndex = i ; return ceilIndex ; } void sortedPermutations ( char str [ ] ) { int size = strlen ( str ) ; qsort ( str , size , sizeof ( str [ 0 ] ) , compare ) ; bool isFinished = false ; while ( ! isFinished ) { printf ( \" % s ▁ STRNEWLINE \" , str ) ; int i ; for ( i = size - 2 ; i >= 0 ; -- i ) if ( str [ i ] < str [ i + 1 ] ) break ; if ( i == -1 ) isFinished = true ; else { int ceilIndex = findCeil ( str , str [ i ] , i + 1 , size - 1 ) ; swap ( & str [ i ] , & str [ ceilIndex ] ) ; reverse ( str , i + 1 , size - 1 ) ; } } }"}
{"text": "Program yang cekap untuk mengira e ^ x | C Program yang cekap untuk mengira E Raise ke Power X; Mengembalikan nilai anggaran e ^ x menggunakan jumlah terma pertama n siri Taylor; memulakan jumlah siri; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE float exponential ( int n , float x ) { float sum = 1.0f ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; } int main ( ) { int n = 10 ; float x = 1.0f ; printf ( \" e ^ x ▁ = ▁ % f \" , exponential ( n , x ) ) ; return 0 ; }"}
{"text": "Penjana Nombor Rawak dalam Fesyen Pengagihan Kebarangkalian Swasta | Program C untuk menjana nombor rawak mengikut taburan frekuensi yang diberikan; Fungsi utiliti untuk mencari siling r dalam arr [l. . h]; Sama seperti pertengahan = (l + h) / 2; Fungsi utama yang mengembalikan nombor rawak dari ARR [] mengikut array pengedaran yang ditakrifkan oleh Freq []. n adalah saiz tatasusunan. ; Buat dan isi array awalan; Awalan [n - 1] adalah jumlah semua frekuensi. Menjana nombor rawak dengan nilai dari 1 hingga jumlah ini; Cari indeks siling r dalam arrat awalan; Program pemacu untuk menguji fungsi di atas; Gunakan nilai benih yang berbeza untuk setiap larian. ; Marilah kita menjana 10 nombor rawak yang menanggung pengedaran yang diberikan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int findCeil ( int arr [ ] , int r , int l , int h ) { int mid ; while ( l < h ) { mid = l + ( ( h - l ) >> 1 ) ; ( r > arr [ mid ] ) ? ( l = mid + 1 ) : ( h = mid ) ; } return ( arr [ l ] >= r ) ? l : -1 ; } int myRand ( int arr [ ] , int freq [ ] , int n ) { int prefix [ n ] , i ; prefix [ 0 ] = freq [ 0 ] ; for ( i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] + freq [ i ] ; int r = ( rand ( ) % prefix [ n - 1 ] ) + 1 ; int indexc = findCeil ( prefix , r , 0 , n - 1 ) ; return arr [ indexc ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int freq [ ] = { 10 , 5 , 20 , 100 } ; int i , n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; srand ( time ( NULL ) ) ; for ( i = 0 ; i < 5 ; i ++ ) printf ( \" % d STRNEWLINE \" , myRand ( arr , freq , n ) ) ; return 0 ; }"}
{"text": "Tulis fungsi yang menghasilkan satu daripada 3 nombor mengikut kebarangkalian yang diberikan | Fungsi ini menjana 'x' dengan kebarangkalian px / 100, 'y' dengan kebarangkalian py / 100 dan 'z' dengan kebarangkalian pz / 100: asumsi: px + py + pz = 100 di mana px, py dan pz terletak antara 0 hingga 100; Menjana nombor dari 1 hingga 100; R lebih kecil daripada PX dengan kebarangkalian PX / 100; R lebih besar daripada Px dan lebih kecil daripada atau sama dengan Px + Py dengan kebarangkalian Py / 100; r lebih besar daripada px + py dan lebih kecil daripada atau sama dengan 100 dengan kebarangkalian PZ / 100", "code": "int random ( int x , int y , int z , int px , int py , int pz ) { int r = rand ( 1 , 100 ) ; if ( r <= px ) return x ; if ( r <= ( px + py ) ) return y ; else return z ; }"}
{"text": "Kirakan sudut antara tangan dan tangan minit | Program c untuk mencari sudut antara jam dan minit; Fungsi utiliti untuk mencari minimum dua bilangan bulat; Berfungsi untuk mengira sudut; mengesahkan input; Kirakan sudut yang dipindahkan mengikut jam dan minit dengan merujuk kepada 12: 00; Cari perbezaan antara dua sudut; Mengembalikan sudut yang lebih kecil daripada dua sudut yang mungkin; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int min ( int x , int y ) { return ( x < y ) ? x : y ; } int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) printf ( \" Wrong ▁ input \" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } int hour_angle = 0.5 * ( h * 60 + m ) ; int minute_angle = 6 * m ; int angle = abs ( hour_angle - minute_angle ) ; angle = min ( 360 - angle , angle ) ; return angle ; } int main ( ) { printf ( \" % d ▁ n \" , calcAngle ( 9 , 60 ) ) ; printf ( \" % d ▁ n \" , calcAngle ( 3 , 30 ) ) ; return 0 ; }"}
{"text": "Cari elemen yang muncul sekali | Program C untuk mencari elemen yang berlaku sekali sahaja; Kaedah untuk mencari elemen yang berlaku sekali sahaja; Ungkapan \"Satu & ur [i]\" memberikan bit yang ada di kedua -dua 'Ones' dan elemen baru dari ARR []. Kami menambah bit ini kepada 'twos' menggunakan bitwise atau nilai 'twos' akan ditetapkan sebagai 0, 3, 3 dan 1 selepas 1 st, 2 nd, 3 rd dan 4 lelaran masing -masing; Xor bit baru dengan 'yang terdahulu' untuk mendapatkan semua bit yang muncul bilangan ganjil kali nilai 'Ones' akan ditetapkan sebagai 3, 0, 2 dan 3 selepas 1 st, 2 nd, 3 rd dan ke -4 lelaran masing -masing; Bit biasa adalah bit yang muncul kali ketiga supaya bit ini tidak boleh berada di kedua -dua 'Ones' dan 'Twos'. Common_bit_mask mengandungi semua bit ini sebagai 0, supaya bit dapat dikeluarkan dari nilai 'Ones' dan 'Twos' dari 'Common _ Bit _ Mask' akan ditetapkan sebagai 00, 00, 01 dan 10 selepas 1 ST, 2 ND, 3 RD dan 4 ITERASI masing -masing; Keluarkan bit biasa (bit yang muncul kali ketiga) dari nilai 'Ones' dari 'Ones' akan ditetapkan sebagai 3, 0, 0 dan 2 selepas 1 st, 2 nd, 3 rd dan 4 lelaran masing -masing; Keluarkan bit biasa (bit yang muncul kali ketiga) dari nilai 'twos' dari 'twos' akan ditetapkan sebagai 0, 3, 1 dan 0 selepas 1 st, 2 nd, 3 rd dan ke -4 masing -masing; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; } int main ( ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ % d ▁ \" , getSingle ( arr , n ) ) ; return 0 ; }"}
{"text": "Cari elemen yang muncul sekali | Program C untuk mencari elemen yang berlaku sekali sahaja; Memulakan hasil; Melangkah melalui setiap bit; Cari jumlah bit set pada kedudukan ith dalam semua elemen array; Bit dengan jumlah tidak berganda 3, adalah bit elemen dengan kejadian tunggal. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #define INT_SIZE  32 NEW_LINE int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; } int main ( ) { int arr [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ % d ▁ \" , getSingle ( arr , n ) ) ; return 0 ; }"}
{"text": "Kira jumlah set bit dalam semua nombor dari 1 hingga n | Program kerumitan o (logn) untuk mengira set bit dalam semua nombor dari 1 hingga n; Mengembalikan kedudukan bit set paling kiri. Kedudukan paling kanan dianggap sebagai 0; Memandangkan kedudukan bit set kiri sebelumnya dalam N (atau terikat atas pada kedudukan paling kiri) mengembalikan kedudukan baru set bit paling kiri dalam N; Fungsi rekursif utama yang digunakan oleh countsetBits (); Dapatkan kedudukan bit set kiri dalam n. Ini akan digunakan sebagai terikat atas untuk fungsi bit set seterusnya; Gunakan kedudukan; Kes asas: Jika n adalah 0, maka tetapkan bit bit ialah 0; Dapatkan kedudukan bit set kiri seterusnya; Jika n adalah bentuk 2 ^ x - 1, i. e. , jika n seperti 1, 3, 7, 15, 31 ,. . dan lain -lain, maka kita sudah selesai. Oleh kerana kedudukan dianggap bermula dari 0, 1 ditambah kepada M; Kemas kini N untuk panggilan rekursif seterusnya; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE unsigned int getLeftmostBit ( int n ) { int m = 0 ; while ( n > 1 ) { n = n >> 1 ; m ++ ; } return m ; } unsigned int getNextLeftmostBit ( int n , int m ) { unsigned int temp = 1 << m ; while ( n < temp ) { temp = temp >> 1 ; m -- ; } return m ; } unsigned int _countSetBits ( unsigned int n , int m ) ; unsigned int countSetBits ( unsigned int n ) { int m = getLeftmostBit ( n ) ; return _countSetBits ( n , m ) ; } unsigned int _countSetBits ( unsigned int n , int m ) { if ( n == 0 ) return 0 ; m = getNextLeftmostBit ( n , m ) ; if ( n == ( ( unsigned int ) 1 << ( m + 1 ) ) - 1 ) return ( unsigned int ) ( m + 1 ) * ( 1 << m ) ; n = n - ( 1 << m ) ; return ( n + 1 ) + countSetBits ( n ) + m * ( 1 << ( m - 1 ) ) ; } int main ( ) { int n = 17 ; printf ( \" Total ▁ set ▁ bit ▁ count ▁ is ▁ % d \" , countSetBits ( n ) ) ; return 0 ; }"}
{"text": "Swap bit dalam nombor tertentu | Program C untuk menukar bit dalam nombor tertentu; Gerakkan semua bit set pertama ke sebelah kanan; Gerakkan semua bit set kedua ke sebelah kanan; Xor dua set; Letakkan bit XOR kembali ke kedudukan asal mereka; Xor 'xor' dengan nombor asal supaya kedua -dua set itu ditukar; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int swapBits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) { unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ; unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ; unsigned int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; unsigned int result = x ^ xor ; return result ; } int main ( ) { int res = swapBits ( 28 , 0 , 3 , 2 ) ; printf ( \" Result = % d \" , res ) ; return 0 ; }"}
{"text": "Terkecil daripada tiga bilangan bulat tanpa pengendali perbandingan | C program untuk mencari terkecil daripada tiga bilangan bulat tanpa pengendali perbandingan; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; } int main ( ) { int x = 12 , y = 15 , z = 5 ; printf ( \" Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ % d \" , smallest ( x , y , z ) ) ; return 0 ; }"}
{"text": "Terkecil daripada tiga bilangan bulat tanpa pengendali perbandingan | C pelaksanaan pendekatan di atas; Berfungsi untuk mencari minimum x dan y; Berfungsi untuk mencari minimum 3 nombor x, y dan z; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define CHAR_BIT  8 NEW_LINE int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; } int smallest ( int x , int y , int z ) { return min ( x , min ( y , z ) ) ; } int main ( ) { int x = 12 , y = 15 , z = 5 ; printf ( \" Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ % d \" , smallest ( x , y , z ) ) ; return 0 ; }"}
{"text": "Terkecil daripada tiga bilangan bulat tanpa pengendali perbandingan |  ; Menggunakan pengendali bahagian untuk mencari minimum tiga nombor; Sama seperti \"jika (y ~ ~ x)\"; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int smallest ( int x , int y , int z ) { if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ; return ( ! ( x / z ) ) ? x : z ; } int main ( ) { int x = 78 , y = 88 , z = 68 ; printf ( \" Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ % d \" , smallest ( x , y , z ) ) ; return 0 ; }"}
{"text": "Teka -teki Array Boolean |  ; Kod pemacu", "code": "void changeToZero ( int a [ 2 ] ) { a [ a [ 1 ] ] = a [ ! a [ 1 ] ] ; } int main ( ) { int a [ ] = { 1 , 0 } ; changeToZero ( a ) ; printf ( \" ▁ arr [ 0 ] ▁ = ▁ % d ▁ STRNEWLINE \" , a [ 0 ] ) ; printf ( \" ▁ arr [ 1 ] ▁ = ▁ % d ▁ \" , a [ 1 ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program untuk mengira bilangan bit set dalam array (besar) |  ; Saiz array 64 k; Kumpulan_A - apabila digabungkan dengan meta_look_up menjana kiraan untuk 4 x4 elemen; Kumpulan_b - apabila digabungkan dengan meta_look_up menjana kiraan untuk elemen 4 x4x4; Kumpulan_c - apabila digabungkan dengan meta_look_up menjana kiraan untuk elemen 4 x4x4x4; Menyediakan surat yang sesuai untuk menjana jadual; Jadual statik akan lebih cepat untuk diakses; Tiada peralihan funda (untuk kebolehbacaan yang lebih baik); Ia baik -baik saja, memintas sistem jenis; Kiraan set bit dalam bait individu; Program pemacu, menjana jadual nombor 64 K rawak; Benih ke penjana nombor rawak; Menjana nombor rawak.", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <time.h> NEW_LINE #define SIZE  (1 << 16) NEW_LINE #define GROUP_A ( x )  x, x + 1, x + 1, x + 2 NEW_LINE #define GROUP_B ( x )  GROUP_A(x), GROUP_A(x+1), GROUP_A(x+1), GROUP_A(x+2) NEW_LINE #define GROUP_C ( x )  GROUP_B(x), GROUP_B(x+1), GROUP_B(x+1), GROUP_B(x+2) NEW_LINE #define META_LOOK_UP ( PARAMETER )  \\NEW_LINE GROUP_##PARAMETER(0), \\NEW_LINE GROUP_##PARAMETER(1), \\NEW_LINE GROUP_##PARAMETER(1), \\NEW_LINE GROUP_##PARAMETER(2) \\NEW_LINEint countSetBits(int array[], size_t array_size) NEW_LINE { int count = 0 ; static unsigned char const look_up [ ] = { META_LOOK_UP ( C ) } ; unsigned char * pData = NULL ; for ( size_t index = 0 ; index < array_size ; index ++ ) { pData = ( unsigned char * ) & array [ index ] ; count += look_up [ pData [ 0 ] ] ; count += look_up [ pData [ 1 ] ] ; count += look_up [ pData [ 2 ] ] ; count += look_up [ pData [ 3 ] ] ; } return count ; } int main ( ) { int index ; int random [ SIZE ] ; srand ( ( unsigned ) time ( 0 ) ) ; for ( index = 0 ; index < SIZE ; index ++ ) { random [ index ] = rand ( ) ; } printf ( \" Total ▁ number ▁ of ▁ bits ▁ = ▁ % d STRNEWLINE \" , countSetBits ( random , SIZE ) ) ; return 0 ; }"}
{"text": "Tambah 1 ke nombor tertentu | C ++ kod untuk menambah Tambah satu ke nombor tertentu; Flip semua bit set sehingga kita dapati 0; Flip paling tepat 0 bit; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int addOne ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } int main ( ) { printf ( \" % d \" , addOne ( 13 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Tambah 1 ke nombor tertentu |  ; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int addOne ( int x ) { return ( - ( ~ x ) ) ; } int main ( ) { printf ( \" % d \" , addOne ( 13 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Matikan Bit Set Bit |  ; tidak menetapkan bit set yang paling kanan dan mengembalikan hasilnya; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int fun ( unsigned int n ) { return n & ( n - 1 ) ; } int main ( ) { int n = 7 ; printf ( \" The ▁ number ▁ after ▁ unsetting ▁ the \" ) ; printf ( \" ▁ rightmost ▁ set ▁ bit ▁ % d \" , fun ( n ) ) ; return 0 ; }"}
{"text": "Cari sama ada nombor tertentu adalah kuasa 4 atau tidak |  ; Fungsi untuk memeriksa sama ada x adalah kuasa 4; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; } int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) printf ( \" % d ▁ is ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; getchar ( ) ; }"}
{"text": "Cari sama ada nombor tertentu adalah kuasa 4 atau tidak |  ; Fungsi untuk memeriksa sama ada x adalah kuasa 4; Semak sama ada hanya satu set bit dalam n; Kira 0 bit sebelum ditetapkan bit; Sekiranya kiraannya, maka kembali lagi yang lain palsu; Sekiranya terdapat lebih daripada 1 bit set maka n bukan kuasa 4; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isPowerOfFour ( unsigned int n ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; } int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) printf ( \" % d ▁ is ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; getchar ( ) ; }"}
{"text": "Cari sama ada nombor tertentu adalah kuasa 4 atau tidak | Program C untuk memeriksa sama ada nombor yang diberikan adalah kuasa 4 atau tidak; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isPowerOfFour ( unsigned int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ; } int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) printf ( \" % d ▁ is ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; getchar ( ) ; }"}
{"text": "Kirakan minimum atau maksimum dua bilangan bulat tanpa bercabang | Program C untuk mengira minimum atau maksimum dua bilangan bulat tanpa cawangan; Berfungsi untuk mencari minimum x dan y; Fungsi untuk mencari maksimum x dan y; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x < y ) ) ; } int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x < y ) ) ; } int main ( ) { int x = 15 ; int y = 6 ; printf ( \" Minimum ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ \" , x , y ) ; printf ( \" % d \" , min ( x , y ) ) ; printf ( \" Maximum of % d and % d is \" printf ( \" % d \" , max ( x , y ) ) ; getchar ( ) ; }"}
{"text": "Kirakan minimum atau maksimum dua bilangan bulat tanpa bercabang |  ; Berfungsi untuk mencari minimum x dan y; Fungsi untuk mencari maksimum x dan y; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #define CHAR_BIT  8 NEW_LINE int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; } int max ( int x , int y ) { return x - ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; } int main ( ) { int x = 15 ; int y = 6 ; printf ( \" Minimum ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ \" , x , y ) ; printf ( \" % d \" , min ( x , y ) ) ; printf ( \" Maximum of % d and % d is \" printf ( \" % d \" , max ( x , y ) ) ; getchar ( ) ; }"}
{"text": "Semak Integer Overflow |  ; Mengambil penunjuk untuk keputusan dan dua nombor sebagai hujah. Sekiranya tidak ada limpahan, fungsi meletakkan hasil = jumlah a + b dalam hasil dan pulangan 0, jika tidak ia kembali - 1; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int addOvf ( int * result , int a , int b ) { * result = a + b ; if ( a > 0 && b > 0 && * result < 0 ) return -1 ; if ( a < 0 && b < 0 && * result > 0 ) return -1 ; return 0 ; } int main ( ) { int * res = ( int * ) malloc ( sizeof ( int ) ) ; int x = 2147483640 ; int y = 10 ; printf ( \" % d \" , addOvf ( res , x , y ) ) ; printf ( \" % d \" , * res ) ; getchar ( ) ; return 0 ; }"}
{"text": "Semak Integer Overflow |", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #include <stdlib.h> NEW_LINE int addOvf ( int * result , int a , int b ) { if ( a > INT_MAX - b ) return -1 ; else { * result = a + b ; return 0 ; } } int main ( ) { int * res = ( int * ) malloc ( sizeof ( int ) ) ; int x = 2147483640 ; int y = 10 ; printf ( \" % d \" , addOvf ( res , x , y ) ) ; printf ( \" % d \" , * res ) ; getchar ( ) ; return 0 ; }"}
{"text": "Little and Big Endian Mystery |", "code": "#include <stdio.h> NEW_LINE int main ( ) { unsigned int i = 1 ; char * c = ( char * ) & i ; if ( * c ) printf ( \" Little ▁ endian \" ) ; else printf ( \" Big ▁ endian \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Kedudukan Bit Set Bit | Program c untuk kedudukan bit set kanan; Kod pemacu", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE unsigned int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; } int main ( ) { int n = 12 ; printf ( \" % u \" , getFirstSetBitPos ( n ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Perwakilan binari nombor tertentu |  ; fungsi bin; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void bin ( unsigned n ) { unsigned i ; for ( i = 1 << 31 ; i > 0 ; i = i / 2 ) ( n & i ) ? printf ( \"1\" ) : printf ( \"0\" ) ; } int main ( void ) { bin ( 7 ) ; printf ( \" STRNEWLINE \" ) ; bin ( 4 ) ; }"}
{"text": "Tukar semua ganjil dan juga bit | Program C untuk menukar bit yang lebih baik dan ganjil dari nombor tertentu; Berfungsi untuk menukar bit walaupun dan ganjil; Dapatkan semua bit x; Dapatkan semua bit ganjil X; Peralihan kanan walaupun bit; Shift kiri bit ganjil; Menggabungkan bit walaupun dan ganjil; Program pemacu untuk menguji fungsi di atas; 00010111; Output adalah 43 (00101011)", "code": "#include <stdio.h> NEW_LINE unsigned int swapBits ( unsigned int x ) { unsigned int even_bits = x & 0xAAAAAAAA ; unsigned int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; } int main ( ) { unsigned int x = 23 ; printf ( \" % u ▁ \" , swapBits ( x ) ) ; return 0 ; }"}
{"text": "Cari kedudukan satu -satunya set bit | Program C untuk mencari kedudukan hanya set bit dalam nombor tertentu; Fungsi utiliti untuk memeriksa sama ada n adalah kuasa 2 atau tidak. goo. gl / 17 arj lihat http :; Mengembalikan kedudukan satu -satunya set bit dalam 'n'; Melangkah melalui bit n sehingga kita dapati set bit i & n akan bukan sifar hanya apabila 'i' dan 'n' mempunyai bit set pada kedudukan yang sama; Bit semasa yang tidak tersendiri dan tetapkan bit seterusnya dalam 'I'; kedudukan kenaikan; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; } int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned i = 1 , pos = 1 ; while ( ! ( i & n ) ) { i = i << 1 ; ++ pos ; } return pos ; } int main ( void ) { int n = 16 ; int pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; n = 12 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; n = 128 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; return 0 ; }"}
{"text": "Cari kedudukan satu -satunya set bit | Program C untuk mencari kedudukan hanya set bit dalam nombor tertentu; Fungsi utiliti untuk memeriksa sama ada n adalah kuasa 2 atau tidak; Mengembalikan kedudukan satu -satunya set bit dalam 'n'; Satu demi satu bergerak satu -satunya set bit ke kanan sehingga ia mencapai akhir; kiraan kenaikan peralihan; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; } int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned count = 0 ; while ( n ) { n = n >> 1 ; ++ count ; } return count ; } int main ( void ) { int n = 0 ; int pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; n = 12 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; n = 128 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; return 0 ; }"}
{"text": "Bagaimana cara menukar dua nombor tanpa menggunakan pemboleh ubah sementara? | Program C untuk menukar dua nombor tanpa menggunakan pembolehubah sementara; Kod untuk menukar 'x' dan 'y' x kini menjadi 50; y menjadi 10; x menjadi 5", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 10 , y = 5 ; x = x * y ; y = x / y ; x = x / y ; printf ( \" After ▁ Swapping : ▁ x ▁ = ▁ % d , ▁ y ▁ = ▁ % d \" , x , y ) ; return 0 ; }"}
{"text": "Bagaimana cara menukar dua nombor tanpa menggunakan pemboleh ubah sementara? | C Kod untuk menukar menggunakan XOR; Kod untuk menukar 'x' (1010) dan 'y' (0101) x kini menjadi 15 (1111); y menjadi 10 (1010); x menjadi 5 (0101)", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 10 , y = 5 ; x = x ^ y ; y = x ^ y ; x = x ^ y ; printf ( \" After ▁ Swapping : ▁ x ▁ = ▁ % d , ▁ y ▁ = ▁ % d \" , x , y ) ; return 0 ; }"}
{"text": "Bagaimana cara menukar dua nombor tanpa menggunakan pemboleh ubah sementara? | Program C untuk melaksanakan pendekatan di atas; Fungsi swap; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void swap ( int * xp , int * yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; * xp = * xp ^ * yp ; } int main ( ) { int x = 10 ; swap ( & x , & x ) ; printf ( \" After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ % d \" , x ) ; return 0 ; }"}
{"text": "Gantikan setiap elemen dengan elemen terbesar di sebelah kanan | Program C untuk menggantikan setiap elemen dengan elemen terbesar di sebelah kanan; Berfungsi untuk menggantikan setiap elemen dengan elemen terbesar seterusnya; Memulakan elemen terbesar seterusnya; Elemen terbesar seterusnya untuk elemen paling kanan adalah sentiasa - 1; Menggantikan semua elemen lain dengan yang paling besar; Simpan elemen semasa (diperlukan kemudian untuk mengemas kini elemen terbesar seterusnya); Menggantikan elemen semasa dengan yang paling besar seterusnya; Mengemas kini elemen terbesar, jika diperlukan; Fungsi utiliti yang mencetak array; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void nextGreatest ( int arr [ ] , int size ) { int max_from_right = arr [ size - 1 ] ; arr [ size - 1 ] = -1 ; for ( int i = size - 2 ; i >= 0 ; i -- ) { int temp = arr [ i ] ; arr [ i ] = max_from_right ; if ( max_from_right < temp ) max_from_right = temp ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nextGreatest ( arr , size ) ; printf ( \" The ▁ modified ▁ array ▁ is : ▁ STRNEWLINE \" ) ; printArray ( arr , size ) ; return ( 0 ) ; }"}
{"text": "Perbezaan maksimum antara dua elemen sehingga elemen yang lebih besar muncul selepas nombor yang lebih kecil |  ; Fungsi ini mengandaikan bahawa terdapat sekurang -kurangnya dua elemen dalam array. Fungsi ini mengembalikan nilai negatif jika array disusun dalam penurunan urutan. Pulangan 0 jika elemen adalah sama; Program pemacu untuk menguji fungsi di atas; Fungsi panggilan", "code": "#include <stdio.h> NEW_LINE int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_size ; i ++ ) { for ( j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; } int main ( ) { int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ; printf ( \" Maximum ▁ difference ▁ is ▁ % d \" , maxDiff ( arr , 5 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari elemen maksimum dalam array yang mula -mula meningkat dan kemudian berkurangan | Program C untuk mencari elemen maksimum; berfungsi untuk mencari elemen maksimum; Program pemacu untuk menyemak fungsi di atas", "code": "#include <stdio.h> NEW_LINE int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; } int main ( ) { int arr [ ] = { 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ maximum ▁ element ▁ is ▁ % d \" , findMaximum ( arr , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari elemen maksimum dalam array yang mula -mula meningkat dan kemudian berkurangan |  ; Kes asas: Hanya satu elemen yang terdapat dalam ARR [rendah. . tinggi]; Sekiranya terdapat dua elemen dan pertama lebih besar maka elemen pertama adalah maksimum; Sekiranya terdapat dua elemen dan kedua adalah lebih besar maka elemen kedua adalah maksimum; Sekiranya kita mencapai titik di mana arr [pertengahan] lebih besar daripada kedua -dua unsur -unsur bersebelahannya arr [pertengahan - 1] dan arr [pertengahan + 1], maka arr [pertengahan] adalah elemen maksimum; Jika arr [pertengahan] lebih besar daripada elemen seterusnya dan lebih kecil daripada elemen sebelumnya maka maksimum terletak di sebelah kiri pertengahan; apabila arr [pertengahan] lebih besar daripada arr [pertengahan - 1] dan lebih kecil daripada arr [pertengahan + 1]; Program pemacu untuk menyemak fungsi di atas", "code": "#include <stdio.h> NEW_LINE int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 50 , 10 , 9 , 7 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ maximum ▁ element ▁ is ▁ % d \" , findMaximum ( arr , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Kira elemen yang lebih kecil di sebelah kanan |  ; memulakan semua tuduhan dalam array countsmaller sebagai 0; Fungsi utiliti yang mencetak array pada baris; Program pemacu untuk menguji fungsi di atas", "code": "void constructLowerArray ( int * arr [ ] , int * countSmaller , int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ i ] ) countSmaller [ i ] ++ ; } } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 12 , 10 , 5 , 4 , 2 , 20 , 6 , 1 , 0 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * low = ( int * ) malloc ( sizeof ( int ) * n ) ; constructLowerArray ( arr , low , n ) ; printArray ( low , n ) ; return 0 ; }"}
{"text": "Kira elemen yang lebih kecil di sebelah kanan |  ; Nod pokok AVL; saiz pokok yang berakar dengan nod ini; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Fungsi utiliti untuk mendapatkan ketinggian pokok yang berakar dengan n; Fungsi utiliti untuk saiz pokok yang berakar dengan n; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Fungsi pembantu yang memperuntukkan nod baru dengan kunci yang diberikan dan null kiri dan kanan. ; Nod baru pada mulanya ditambah pada daun; Fungsi utiliti ke kanan berputar subtree yang berakar dengan y; Melakukan putaran; Mengemas kini ketinggian; Saiz kemas kini; Mengembalikan akar baru; Fungsi utiliti ke kiri berputar subtree berakar dengan x; Melakukan putaran; Mengemas kini ketinggian; Saiz kemas kini; Mengembalikan akar baru; Dapatkan faktor keseimbangan nod n; Masukkan kunci baru ke pokok yang dibuang dengan nod. Juga, kemas kini * kiraan untuk mengandungi kiraan elemen yang lebih kecil untuk kunci baru; 1. Melaksanakan putaran BST biasa; Kemas kini kiraan elemen yang lebih kecil untuk kunci; 2. Kemas kini ketinggian dan saiz nod nenek moyang ini; 3. Dapatkan faktor keseimbangan nod nenek moyang ini untuk memeriksa sama ada nod ini menjadi tidak seimbang; Kes kiri kiri; Kes yang betul; Kes Kanan Kiri; Kes kiri kanan; Kembalikan penunjuk nod (tidak berubah); Fungsi berikut mengemas kini array Countsmaller untuk mengandungi kiraan elemen yang lebih kecil di sebelah kanan. ; memulakan semua tuduhan dalam array countsmaller sebagai 0; Bermula dari elemen paling kanan, masukkan semua elemen satu demi satu dalam pokok AVL dan dapatkan kiraan unsur -unsur yang lebih kecil; Fungsi utiliti yang mencetak array pada baris; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; struct node * left ; struct node * right ; int height ; int size ; } ; int max ( int a , int b ) ; int height ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> height ; } int size ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> size ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ; node -> height = 1 ; node -> size = 1 ; return ( node ) ; } struct node * rightRotate ( struct node * y ) { struct node * x = y -> left ; struct node * T2 = x -> right ; x -> right = y ; y -> left = T2 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; y -> size = size ( y -> left ) + size ( y -> right ) + 1 ; x -> size = size ( x -> left ) + size ( x -> right ) + 1 ; return x ; } struct node * leftRotate ( struct node * x ) { struct node * y = x -> right ; struct node * T2 = y -> left ; y -> left = x ; x -> right = T2 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; x -> size = size ( x -> left ) + size ( x -> right ) + 1 ; y -> size = size ( y -> left ) + size ( y -> right ) + 1 ; return y ; } int getBalance ( struct node * N ) { if ( N == NULL ) return 0 ; return height ( N -> left ) - height ( N -> right ) ; } struct node * insert ( struct node * node , int key , int * count ) { if ( node == NULL ) return ( newNode ( key ) ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key , count ) ; else { node -> right = insert ( node -> right , key , count ) ; * count = * count + size ( node -> left ) + 1 ; } node -> height = max ( height ( node -> left ) , height ( node -> right ) ) + 1 ; node -> size = size ( node -> left ) + size ( node -> right ) + 1 ; int balance = getBalance ( node ) ; if ( balance > 1 && key < node -> left -> key ) return rightRotate ( node ) ; if ( balance < -1 && key > node -> right -> key ) return leftRotate ( node ) ; if ( balance > 1 && key > node -> left -> key ) { node -> left = leftRotate ( node -> left ) ; return rightRotate ( node ) ; } if ( balance < -1 && key < node -> right -> key ) { node -> right = rightRotate ( node -> right ) ; return leftRotate ( node ) ; } return node ; } void constructLowerArray ( int arr [ ] , int countSmaller [ ] , int n ) { int i , j ; struct node * root = NULL ; for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { root = insert ( root , arr [ i ] , & countSmaller [ i ] ) ; } } void printArray ( int arr [ ] , int size ) { int i ; printf ( \" STRNEWLINE \" ) ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 10 , 6 , 15 , 20 , 30 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * low = ( int * ) malloc ( sizeof ( int ) * n ) ; constructLowerArray ( arr , low , n ) ; printf ( \" Following ▁ is ▁ the ▁ constructed ▁ smaller ▁ count ▁ array \" ) ; printArray ( low , n ) ; return 0 ; }"}
{"text": "Cari nombor positif terkecil yang hilang dari array yang tidak disusun | Tetapkan 1 | Program C untuk mencari nombor positif yang paling kecil; Utiliti untuk bertukar kepada bilangan bulat; Fungsi utiliti yang meletakkan semua nombor positif (0 dan negatif) di sebelah kiri ARR [] dan mengembalikan kiraan nombor tersebut; kiraan kenaikan integer bukan positif; Cari nombor positif yang paling kecil dalam array yang mengandungi semua bilangan bulat positif; Mark Arr [i] seperti yang dikunjungi dengan membuat arr [arr [i] - 1] negatif. Perhatikan bahawa 1 dikurangkan kerana indeks bermula dari 0 dan nombor positif bermula dari 1; Kembalikan nilai indeks pertama di mana positif; 1 ditambah kerana indeks bermula dari 0; Cari nombor positif yang paling kecil dalam array yang mengandungi kedua -dua bilangan bulat positif dan negatif; Nombor positif dan negatif yang terpisah pertama; Mengalihkan array dan call findmissingpositive untuk bahagian positif; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void swap ( int * a , int * b ) { int temp ; temp = * a ; * a = * b ; * b = temp ; } int segregate ( int arr [ ] , int size ) { int j = 0 , i ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] <= 0 ) { swap ( & arr [ i ] , & arr [ j ] ) ; j ++ ; } } return j ; } int findMissingPositive ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { if ( abs ( arr [ i ] ) - 1 < size && arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; } for ( i = 0 ; i < size ; i ++ ) if ( arr [ i ] > 0 ) return i + 1 ; return size + 1 ; } int findMissing ( int arr [ ] , int size ) { int shift = segregate ( arr , size ) ; return findMissingPositive ( arr + shift , size - shift ) ; } int main ( ) { int arr [ ] = { 0 , 10 , 2 , -10 , -20 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int missing = findMissing ( arr , arr_size ) ; printf ( \" The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ % d ▁ \" , missing ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari nombor yang hilang |  ; getmissingno mengambil array dan saiz array sebagai argumen; program untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int getMissingNo ( int a [ ] , int n ) { int i , total ; total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; } int main ( ) { int a [ ] = { 1 , 2 , 4 , 5 , 6 } ; int miss = getMissingNo ( a , 5 ) ; printf ( \" % d \" , miss ) ; getchar ( ) ; }"}
{"text": "Cari pengulangan dan yang hilang | Menambah 3 Kaedah Baru | Program C untuk mencari unsur -unsur berulang dan hilang; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void printTwoElements ( int arr [ ] , int size ) { int i ; printf ( \" The repeating element is \" for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else printf ( \" ▁ % d ▁ \" , abs ( arr [ i ] ) ) ; } printf ( \" and the missing element is \" for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) printf ( \" % d \" , i + 1 ) ; } } int main ( ) { int arr [ ] = { 7 , 3 , 4 , 5 , 5 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoElements ( arr , n ) ; return 0 ; }"}
{"text": "Cari pengulangan dan yang hilang | Menambah 3 Kaedah Baru | Program C untuk mencari unsur -unsur berulang dan hilang; Output fungsi ini disimpan pada * x dan * y; Akan memegang xor semua elemen dan nombor dari 1 hingga n; Hanya akan mempunyai bit satu set XOR1; Dapatkan XOR semua elemen array; Xor hasil sebelumnya dengan nombor dari 1 hingga n; Dapatkan bit set kanan dalam set_bit_no; Sekarang bahagikan unsur -unsur dalam dua set dengan membandingkan bit set kanan XOR1 dengan bit pada kedudukan yang sama dalam setiap elemen. Juga, dapatkan Xors dua set. Kedua -dua XOR adalah elemen output. Dua berikut untuk gelung berfungsi dengan tujuan; arr [i] tergolong dalam set pertama; Arr [i] tergolong dalam set kedua; Saya tergolong dalam set pertama; Saya tergolong dalam set kedua; * x dan * y memegang elemen output yang dikehendaki; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void getTwoElements ( int arr [ ] , int n , int * x , int * y ) { int xor1 ; int set_bit_no ; int i ; * x = 0 ; * y = 0 ; xor1 = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) xor1 = xor1 ^ arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor1 = xor1 ^ i ; set_bit_no = xor1 & ~ ( xor1 - 1 ) ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit_no ) * x = * x ^ arr [ i ] ; else * y = * y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) * x = * x ^ i ; else * y = * y ^ i ; } } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 , 6 , 2 } ; int * x = ( int * ) malloc ( sizeof ( int ) ) ; int * y = ( int * ) malloc ( sizeof ( int ) ) ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getTwoElements ( arr , n , x , y ) ; printf ( \" ▁ The ▁ missing ▁ element ▁ is ▁ % d \" \" ▁ and ▁ the ▁ repeating ▁ number \" \" ▁ is ▁ % d \" , * x , * y ) ; getchar ( ) ; }"}
{"text": "Cari empat elemen yang Jumlah kepada nilai tertentu | Tetapkan 1 (N ^ 3 Penyelesaian) |  ; Penyelesaian naif untuk mencetak semua gabungan 4 elemen dalam [] dengan jumlah yang sama dengan x; Betulkan elemen pertama dan cari tiga yang lain; Betulkan elemen kedua dan cari dua yang lain; Betulkan elemen ketiga dan cari keempat; Cari keempat; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void findFourElements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) printf ( \" % d , ▁ % d , ▁ % d , ▁ % d \" , A [ i ] , A [ j ] , A [ k ] , A [ l ] ) ; } } } } int main ( ) { int A [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int X = 91 ; findFourElements ( A , n , X ) ; return 0 ; }"}
{"text": "Cari empat elemen yang Jumlah kepada nilai tertentu | Tetapkan 2 | Program C untuk mencari 4 elemen dengan jumlah yang diberikan; Struktur berikut diperlukan untuk menyimpan jumlah pasangan di Aux []; indeks (int a []) elemen pertama dalam pasangan; Indeks elemen kedua dalam pasangan; Jumlah pasangan; Fungsi berikut diperlukan untuk fungsi perpustakaan qsort (); Fungsi untuk memeriksa sama ada dua pasangan yang diberikan mempunyai unsur biasa atau tidak; Fungsi ini menemui empat elemen dengan jumlah x yang diberikan; Buat array tambahan untuk menyimpan semua jumlah wang; Menjana semua pasangan yang mungkin dari [] dan menyimpan jumlah semua pasangan yang mungkin di Aux []; Susun array aux [] menggunakan fungsi perpustakaan untuk menyusun; Sekarang mulakan dua pembolehubah indeks dari dua sudut array dan gerakkannya ke arah satu sama lain. ; Kod pemacu; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct pairSum { int first ; int sec ; int sum ; } ; int compare ( const void * a , const void * b ) { return ( ( * ( pairSum * ) a ) . sum - ( * ( pairSum * ) b ) . sum ) ; } bool noCommon ( struct pairSum a , struct pairSum b ) { if ( a . first == b . first a . first == b . sec a . sec == b . first a . sec == b . sec ) return false ; return true ; } void findFourElements ( int arr [ ] , int n , int X ) { int i , j ; int size = ( n * ( n - 1 ) ) / 2 ; struct pairSum aux [ size ] ; int k = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { aux [ k ] . sum = arr [ i ] + arr [ j ] ; aux [ k ] . first = i ; aux [ k ] . sec = j ; k ++ ; } } qsort ( aux , size , sizeof ( aux [ 0 ] ) , compare ) ; i = 0 ; j = size - 1 ; while ( i < size && j >= 0 ) { if ( ( aux [ i ] . sum + aux [ j ] . sum == X ) && noCommon ( aux [ i ] , aux [ j ] ) ) { printf ( \" % d , ▁ % d , ▁ % d , ▁ % d STRNEWLINE \" , arr [ aux [ i ] . first ] , arr [ aux [ i ] . sec ] , arr [ aux [ j ] . first ] , arr [ aux [ j ] . sec ] ) ; return ; } else if ( aux [ i ] . sum + aux [ j ] . sum < X ) i ++ ; else j -- ; } } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 91 ; findFourElements ( arr , n , X ) ; return 0 ; }"}
{"text": "Jarak minimum antara dua kejadian maksimum | Program C untuk mencari jarak min elemen maksimum; berfungsi untuk mengembalikan jarak min; kes a; kes b; kes c; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDistance ( int arr [ ] , int n ) { int maximum_element = arr [ 0 ] ; int min_dis = n ; int index = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( maximum_element == arr [ i ] ) { min_dis = min ( min_dis , ( i - index ) ) ; index = i ; } else if ( maximum_element < arr [ i ] ) { maximum_element = arr [ i ] ; min_dis = n ; index = i ; } else continue ; } return min_dis ; } int main ( ) { int arr [ ] = { 6 , 3 , 1 , 3 , 6 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Minimum ▁ distance ▁ = ▁ \" << minDistance ( arr , n ) ; return 0 ; }"}
{"text": "Cari elemen dalam senarai yang dipautkan (berulang dan rekursif) | Program C Rekursif untuk mencari elemen dalam senarai yang dipautkan; Nod senarai pautan; Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala senarai dan int, tolak nod baru di hadapan senarai. ; memperuntukkan nod dimasukkan ke dalam kunci; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Memeriksa sama ada nilai X hadir dalam senarai yang dipautkan; Kes asas; Jika kunci hadir dalam nod semasa, kembali benar; Berulang untuk senarai yang tinggal; Program pemacu untuk menguji fungsi kiraan; Mulakan dengan senarai kosong; Gunakan tolak () untuk membina senarai di bawah 14 -> 21 -> 11 -> 30 -> 10", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE struct Node { int key ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_key ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> key = new_key ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } bool search ( struct Node * head , int x ) { if ( head == NULL ) return false ; if ( head -> key == x ) return true ; return search ( head -> next , x ) ; } int main ( ) { struct Node * head = NULL ; int x = 21 ; push ( & head , 10 ) ; push ( & head , 30 ) ; push ( & head , 11 ) ; push ( & head , 21 ) ; push ( & head , 14 ) ; search ( head , 21 ) ? printf ( \" Yes \" ) : printf ( \" No \" ) ; return 0 ; }"}
{"text": "Padam nod alternatif senarai yang dipautkan | Memadam nod alternatif senarai bermula dengan kepala; Tukar pautan kepala seterusnya; memori percuma yang diperuntukkan untuk nod; Secara rekursif memanggil kepala yang baru", "code": "void deleteAlt ( struct Node * head ) { if ( head == NULL ) return ; struct Node * node = head -> next ; if ( node == NULL ) return ; head -> next = node -> next ; free ( node ) ; deleteAlt ( head -> next ) ; }"}
{"text": "Perpecahan berselang dengan senarai dikaitkan tunggal yang diberikan | Tetapkan 1 |  ; titik ke nod terakhir dalam 'A'; titik ke nod terakhir dalam 'B'; Tambah pada 'A' ekor; memajukan ekor 'a'", "code": "void AlternatingSplit ( struct Node * source , struct Node * * aRef , struct Node * * bRef ) { struct Node aDummy ; struct Node * aTail = & aDummy ; struct Node bDummy ; struct Node * bTail = & bDummy ; struct Node * current = source ; aDummy . next = NULL ; bDummy . next = NULL ; while ( current != NULL ) { MoveNode ( & ( aTail -> next ) , t ) ; aTail = aTail -> next ; if ( current != NULL ) { MoveNode ( & ( bTail -> next ) , t ) ; bTail = bTail -> next ; } } * aRef = aDummy . next ; * bRef = bDummy . next ; }"}
{"text": "Senarai Berkaitan yang sama | Program berulang C untuk memeriksa sama ada dua senarai yang dipautkan adalah sama atau tidak; Struktur untuk nod senarai yang dipautkan; Pulangan benar jika senarai yang dipautkan a dan b adalah sama, jika tidak palsu; Jika kita sampai di sini, maka A dan B tidak batal dan data mereka sama, jadi bergerak ke nod seterusnya dalam kedua -dua senarai; Jika senarai yang dipautkan adalah sama, maka 'A' dan 'B' mesti dibatalkan pada ketika ini. ; Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala senarai dan int, tolak nod baru di hadapan senarai. ; memperuntukkan nod dimasukkan ke dalam data; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Program pemacu untuk menguji fungsi di atas; Senarai yang dipautkan yang dibina ialah: A: 3 -> 2 -> 1 B: 3 -> 2 -> 1", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; bool areIdentical ( struct Node * a , struct Node * b ) { while ( a != NULL && b != NULL ) { if ( a -> data != b -> data ) return false ; a = a -> next ; b = b -> next ; } return ( a == NULL && b == NULL ) ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * a = NULL ; struct Node * b = NULL ; push ( & a , 1 ) ; push ( & a , 2 ) ; push ( & a , 3 ) ; push ( & b , 1 ) ; push ( & b , 2 ) ; push ( & b , 3 ) ; areIdentical ( a , b ) ? printf ( \" Identical \" ) : printf ( \" Not ▁ identical \" ) ; return 0 ; }"}
{"text": "Senarai Berkaitan yang sama | Fungsi C Rekursif untuk memeriksa sama ada dua senarai yang dipautkan adalah sama atau tidak; Jika kedua -dua senarai kosong; Jika kedua -dua senarai tidak kosong, maka data nod semasa mesti sepadan, dan sama harus rekursif benar untuk nod lain. ; Sekiranya kita sampai di sini, maka salah satu senarai kosong dan lain -lain tidak", "code": "bool areIdentical ( struct Node * a , struct Node * b ) { if ( a == NULL && b == NULL ) return true ; if ( a != NULL && b != NULL ) return ( a -> data == b -> data ) && areIdentical ( a -> next , b -> next ) ; return false ; }"}
{"text": "Susun senarai yang dipautkan 0 s, 1 s dan 2 s | C program untuk menyusun senarai yang dipautkan 0 s, 1 s atau 2 s; Nod senarai pautan; Berfungsi untuk menyusun senarai yang dipautkan 0 s, 1 s dan 2 s; Memulakan kiraan '0', '1' dan '2' sebagai 0; Jumlah jumlah '0', '1' dan '2' * Count [0] akan menyimpan jumlah bilangan '0' s * kiraan [1] akan menyimpan jumlah '1' s * Count [2] akan menyimpan jumlah '2' s; Katakanlah kiraan [0] = n1, hitung [1] = n2 dan hitung [2] = n3 * Sekarang mulakan senarai melintasi dari nod kepala, * 1) isi senarai dengan 0, sehingga n1> 0 * 2) Isikan senarai dengan 1, sehingga n2> 0 * 3) Isi senarai dengan 2, sehingga n3> 0; Berfungsi untuk menolak nod; memperuntukkan nod dimasukkan ke dalam data; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Berfungsi untuk mencetak senarai yang dipautkan; Program pemacu untuk menguji fungsi di atas; Senarai yang dipautkan yang dibina ialah 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 8 -> 9 -> Null", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void sortList ( struct Node * head ) { int count [ 3 ] = { 0 , 0 , 0 } ; struct Node * ptr = head ; while ( ptr != NULL ) { count [ ptr -> data ] += 1 ; ptr = ptr -> next ; } int i = 0 ; ptr = head ; while ( ptr != NULL ) { if ( count [ i ] == 0 ) ++ i ; else { ptr -> data = i ; -- count [ i ] ; ptr = ptr -> next ; } } } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * node ) { while ( node != NULL ) { printf ( \" % d ▁ \" , node -> data ) ; node = node -> next ; } printf ( \" n \" ) ; } int main ( void ) { struct Node * head = NULL ; push ( & head , 0 ) ; push ( & head , 1 ) ; push ( & head , 0 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; printf ( \" Linked ▁ List ▁ Before ▁ Sorting STRNEWLINE \" ) ; printList ( head ) ; sortList ( head ) ; printf ( \" Linked ▁ List ▁ After ▁ Sorting STRNEWLINE \" ) ; printList ( head ) ; return 0 ; }"}
{"text": "Memperbaiki Senarai Berkaitan Multilevel |", "code": "struct List { int data ; struct List * next ; struct List * child ; } ;"}
{"text": "Susun semula senarai yang dipautkan supaya semua nod yang diposisikan dan ganjil bersama -sama | Program C untuk menyusun semula senarai yang dipautkan sedemikian rupa sehingga semua nod kedudukan ganjil disimpan sebelum semua nod yang diposisikan; Nod senarai yang dipautkan; Fungsi utiliti untuk membuat nod baru; REARRANGES Diberi senarai yang dipautkan supaya semua nod yang diposisikan adalah sebelum kedudukan ganjil. Mengembalikan ketua senarai baru yang dipautkan. ; Kes sudut; Memulakan nod pertama senarai walaupun dan ganjil; Ingat nod pertama senarai walaupun supaya kami dapat menyambungkan senarai walaupun pada akhir senarai ganjil. ; Sekiranya tidak ada lagi nod, maka sambungkan nod pertama senarai bahkan ke nod terakhir senarai ganjil; Menyambungkan nod ganjil; Sekiranya tidak ada lagi nod selepas ganjil semasa. ; Menyambung walaupun nod; Fungsi utiliti untuk mencetak senarai yang dipautkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } Node * rearrangeEvenOdd ( Node * head ) { if ( head == NULL ) return NULL ; Node * odd = head ; Node * even = head -> next ; Node * evenFirst = even ; while ( 1 ) { if ( ! odd || ! even || ! ( even -> next ) ) { odd -> next = evenFirst ; break ; } odd -> next = even -> next ; odd = even -> next ; if ( odd -> next == NULL ) { even -> next = NULL ; odd -> next = evenFirst ; break ; } even -> next = odd -> next ; even = odd -> next ; } return head ; } void printlist ( Node * node ) { while ( node != NULL ) { cout << node -> data << \" - > \" ; node = node -> next ; } cout << \" NULL \" << endl ; } int main ( void ) { Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; cout << \" Given ▁ Linked ▁ List STRNEWLINE \" ; printlist ( head ) ; head = rearrangeEvenOdd ( head ) ; cout << \" Modified Linked List \" ; printlist ( head ) ; return 0 ; }"}
{"text": "Padam kejadian terakhir item dari senarai yang dipautkan | Program C untuk menunjukkan penghapusan nod terakhir dalam senarai yang berkaitan dengan tunggal; Nod senarai yang dipautkan; Berfungsi untuk memadam kejadian terakhir; Jika dijumpai kunci, kemas kini; Jika kejadian terakhir adalah nod terakhir; Jika bukan nod terakhir; Fungsi utiliti untuk membuat nod baru dengan kunci yang diberikan; Fungsi ini mencetak kandungan senarai yang dipautkan bermula dari nod yang diberikan; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void deleteLast ( struct Node * head , int x ) { struct Node * temp = head , * ptr = NULL ; while ( temp ) { if ( temp -> data == x ) ptr = temp ; temp = temp -> next ; } if ( ptr != NULL && ptr -> next == NULL ) { temp = head ; while ( temp -> next != ptr ) temp = temp -> next ; temp -> next = NULL ; } if ( ptr != NULL && ptr -> next != NULL ) { ptr -> data = ptr -> next -> data ; temp = ptr -> next ; ptr -> next = ptr -> next -> next ; free ( temp ) ; } } struct Node * newNode ( int x ) { struct Node * node = malloc ( sizeof ( struct Node * ) ) ; node -> data = x ; node -> next = NULL ; return node ; } void display ( struct Node * head ) { struct Node * temp = head ; if ( head == NULL ) { printf ( \" NULL STRNEWLINE \" ) ; return ; } while ( temp != NULL ) { printf ( \" % d ▁ - - > ▁ \" , temp -> data ) ; temp = temp -> next ; } printf ( \" NULL STRNEWLINE \" ) ; } int main ( ) { struct Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; head -> next -> next -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next -> next -> next = newNode ( 4 ) ; printf ( \" Created ▁ Linked ▁ list : ▁ \" ) ; display ( head ) ; deleteLast ( head , 4 ) ; printf ( \" List ▁ after ▁ deletion ▁ of ▁ 4 : ▁ \" ) ; display ( head ) ; return 0 ; }"}
{"text": "Semak sama ada panjang senarai yang dipautkan adalah walaupun atau ganjil | Program c untuk memeriksa panjang senarai pautan yang diberikan; Struktur yang menentukan; Berfungsi untuk memeriksa panjang LinkList; Fungsi tolak; Memperuntukkan nod; Maklumat ke dalam nod; Seterusnya nod baru ke kepala; kepala titik ke nod baru; Fungsi pemacu; Menambah elemen ke senarai yang dipautkan; Memeriksa panjang senarai pautan", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; int LinkedListLength ( struct Node * head ) { while ( head && head -> next ) { head = head -> next -> next ; } if ( ! head ) return 0 ; return 1 ; } void push ( struct Node * * head , int info ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = info ; node -> next = ( * head ) ; ( * head ) = node ; } int main ( void ) { struct Node * head = NULL ; push ( & head , 4 ) ; push ( & head , 5 ) ; push ( & head , 7 ) ; push ( & head , 2 ) ; push ( & head , 9 ) ; push ( & head , 6 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 0 ) ; push ( & head , 5 ) ; push ( & head , 5 ) ; int check = LinkedListLength ( head ) ; if ( check == 0 ) { printf ( \" Even STRNEWLINE \" ) ; } else { printf ( \" Odd STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "Gabungkan Dua Senarai Berkaitan Susun |  ; menunjuk kepada penunjuk hasil terakhir; rumit: maju ke medan seterusnya \". Seterusnya\" medan", "code": "struct Node * SortedMerge ( struct Node * a , struct Node * b ) { struct Node * result = NULL ; struct Node * * lastPtrRef = & result ; while ( 1 ) { if ( a == NULL ) { * lastPtrRef = b ; break ; } else if ( b == NULL ) { * lastPtrRef = a ; break ; } if ( a -> data <= b -> data ) { MoveNode ( lastPtrRef , & a ) ; } else { MoveNode ( lastPtrRef , & b ) ; } lastPtrRef = & ( ( * lastPtrRef ) -> next ) ; } return ( result ) ; }"}
{"text": "Buat kepala nod tengah dalam senarai yang dipautkan | C Program untuk membuat nod tengah sebagai ketua senarai yang dipautkan. ; Nod senarai pautan; Berfungsi untuk mendapatkan pertengahan dan ditetapkan pada permulaan senarai yang dipautkan; Untuk melintasi senarai nod satu demi satu; Untuk melintasi senarai nod dengan melangkau satu. ; Untuk menjejaki sebelumnya di tengah; untuk nod sebelumnya nod tengah; gerakkan satu nod setiap kali; gerakkan dua nod setiap kali; Tetapkan nod tengah di kepala; Untuk memasukkan nod pada permulaan senarai yang dipautkan. ; memperuntukkan nod; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Fungsi untuk mencetak senarai yang dipautkan; Fungsi pemacu; Buat senarai 5 nod", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void setMiddleHead ( struct Node * * head ) { if ( * head == NULL ) return ; struct Node * one_node = ( * head ) ; struct Node * two_node = ( * head ) ; struct Node * prev = NULL ; while ( two_node != NULL && two_node -> next != NULL ) { prev = one_node ; two_node = two_node -> next -> next ; one_node = one_node -> next ; } prev -> next = prev -> next -> next ; one_node -> next = ( * head ) ; ( * head ) = one_node ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * ptr ) { while ( ptr != NULL ) { printf ( \" % d ▁ \" , ptr -> data ) ; ptr = ptr -> next ; } printf ( \" STRNEWLINE \" ) ; } int main ( ) { struct Node * head = NULL ; int i ; for ( i = 5 ; i > 0 ; i -- ) push ( & head , i ) ; printf ( \" ▁ list ▁ before : ▁ \" ) ; printList ( head ) ; setMiddleHead ( & head ) ; printf ( \" ▁ list ▁ After : ▁ \" ) ; printList ( head ) ; return 0 ; }"}
{"text": "Senarai Double Linked | Tetapkan 1 (Pengenalan dan Penyisipan) | Memandangkan nod sebagai prev_node, masukkan nod baru selepas nod yang diberikan; 1. Semak jika prev_node yang diberikan adalah null; 2. Memperuntukkan nod baru 3. Masukkan data; 4. Buat nod baru seterusnya sebagai prev_node berikutnya; 5. Buat yang seterusnya dari prev_node sebagai new_node; 6. Buat prev_node seperti sebelumnya dari new_node; 7. Tukar sebelumnya dari nod seterusnya New_node", "code": "void insertAfter ( struct Node * prev_node , int new_data ) { if ( prev_node == NULL ) { printf ( \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" ) ; return ; } struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = prev_node -> next ; prev_node -> next = new_node ; new_node -> prev = prev_node ; if ( new_node -> next != NULL ) new_node -> next -> prev = new_node ; }"}
{"text": "Senarai yang dipautkan oleh XOR â € \"Senarai yang dikaitkan dengan efisien memori | Set 2 | NPX node baru akan menjadi XOR kepala semasa dan null; curr -> npx adalah seterusnya, jadi curr -> npx ^ prev akan menjadi ^ preval yang seterusnya;", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <inttypes.h> NEW_LINE struct Node { int data ; struct Node * npx ; } ; struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; } void insert ( struct Node * * head_ref , int data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = data ; new_node -> npx = * head_ref ; if ( * head_ref != NULL ) { ( * head_ref ) -> npx = XOR ( new_node , ( * head_ref ) -> npx ) ; } * head_ref = new_node ; } void printList ( struct Node * head ) { struct Node * curr = head ; struct Node * prev = NULL ; struct Node * next ; printf ( \" Following ▁ are ▁ the ▁ nodes ▁ of ▁ Linked ▁ List : ▁ STRNEWLINE \" ) ; while ( curr != NULL ) { printf ( \" % d ▁ \" , curr -> data ) ; next = XOR ( prev , curr -> npx ) ; prev = curr ; curr = next ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 10 ) ; insert ( & head , 20 ) ; insert ( & head , 30 ) ; insert ( & head , 40 ) ; printList ( head ) ; return ( 0 ) ; }"}
{"text": "Cetak nod pada jarak K dari akar |  ; Node pokok binari mempunyai data, penunjuk kepada anak kiri dan penunjuk kepada anak yang betul; Fungsi penolong yang memperuntukkan nod baru dengan data yang diberikan dan penunjuk kiri dan kanan null. ; Program pemacu untuk menguji fungsi di atas; Pokok binari yang dibina ialah 1 / \\ 2 3 / \\ / 4 5 8 8", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; void printKDistant ( struct node * root , int k ) { if ( root == NULL k < 0 ) return ; if ( k == 0 ) { printf ( \" % d ▁ \" , root -> data ) ; return ; } printKDistant ( root -> left , k - 1 ) ; printKDistant ( root -> right , k - 1 ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 8 ) ; printKDistant ( root , 2 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cetak pokok binari dalam 2 | Program untuk mencetak pokok binari dalam 2d; Nod pokok binari; Fungsi penolong untuk memperuntukkan nod baru; Berfungsi untuk mencetak pokok binari dalam 2D ​​ia melakukan traversal inorder terbalik; Kes asas; Meningkatkan jarak antara tahap; Proses anak yang betul terlebih dahulu; Cetak nod semasa selepas kiraan ruang; Proses kiri anak; Pembalut atas print2dutil (); Lulus kiraan ruang awal sebagai 0; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <malloc.h> NEW_LINE #define COUNT  10 NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } void print2DUtil ( struct Node * root , int space ) { if ( root == NULL ) return ; space += COUNT ; print2DUtil ( root -> right , space ) ; printf ( \" STRNEWLINE \" ) ; for ( int i = COUNT ; i < space ; i ++ ) printf ( \" ▁ \" ) ; printf ( \" % d STRNEWLINE \" , root -> data ) ; print2DUtil ( root -> left , space ) ; } void print2D ( struct Node * root ) { print2DUtil ( root , 0 ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> left -> left = newNode ( 12 ) ; root -> right -> left -> right = newNode ( 13 ) ; root -> right -> right -> left = newNode ( 14 ) ; root -> right -> right -> right = newNode ( 15 ) ; print2D ( root ) ; return 0 ; }"}
{"text": "Cetak Pandangan Kiri Pokok Binari | Program C untuk mencetak pandangan kiri pokok binari; Fungsi utiliti untuk membuat nod pokok binari baru; Fungsi rekursif untuk mencetak pandangan kiri pokok binari. ; Kes asas; Jika ini adalah nod pertama tahapnya; Berulang untuk subtrees kiri dan kanan; Pembungkus atas leftViewUtil (); Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; } void leftViewUtil ( struct node * root , int level , int * max_level ) { if ( root == NULL ) return ; if ( * max_level < level ) { printf ( \" % d TABSYMBOL \" , root -> data ) ; * max_level = level ; } leftViewUtil ( root -> left , level + 1 , max_level ) ; leftViewUtil ( root -> right , level + 1 , max_level ) ; } void leftView ( struct node * root ) { int max_level = 0 ; leftViewUtil ( root , 1 , & max_level ) ; } int main ( ) { struct node * root = newNode ( 12 ) ; root -> left = newNode ( 10 ) ; root -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 25 ) ; root -> right -> right = newNode ( 40 ) ; leftView ( root ) ; return 0 ; }"}
{"text": "Kira bilangan rentetan berputar yang mempunyai lebih banyak vokal pada separuh pertama daripada separuh kedua | C pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan rentetan berputar yang mempunyai lebih banyak vokal pada separuh pertama daripada babak kedua; Kirakan bilangan vokal pada separuh pertama; Kirakan bilangan vokal dalam separuh kedua; Semak jika pertama - separuh mempunyai lebih banyak vokal; Semak semua putaran yang mungkin; Kembalikan jawapannya; Kod pemacu; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int cntRotations ( char s [ ] , int n ) { int lh = 0 , rh = 0 , i , ans = 0 ; for ( i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { lh ++ ; } for ( i = n / 2 ; i < n ; ++ i ) if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { rh ++ ; } if ( lh > rh ) ans ++ ; for ( i = 1 ; i < n ; ++ i ) { if ( s [ i - 1 ] == ' a ' s [ i - 1 ] == ' e ' s [ i - 1 ] == ' i ' s [ i - 1 ] == ' o ' s [ i - 1 ] == ' u ' ) { rh ++ ; lh -- ; } if ( s [ ( i - 1 + n / 2 ) % n ] == ' a ' || s [ ( i - 1 + n / 2 ) % n ] == ' e ' || s [ ( i - 1 + n / 2 ) % n ] == ' i ' || s [ ( i - 1 + n / 2 ) % n ] == ' o ' || s [ ( i - 1 + n / 2 ) % n ] == ' u ' ) { rh -- ; lh ++ ; } if ( lh > rh ) ans ++ ; } return ans ; } int main ( ) { char s [ ] = \" abecidft \" ; int n = strlen ( s ) ; printf ( \" % d \" , cntRotations ( s , n ) ) ; return 0 ; }"}
{"text": "Putar Blok Senarai Berkaitan Bijaksana | Program C untuk memutar blok senarai yang dipautkan; Nod senarai pautan; Fungsi rekursif untuk memutar satu blok; Berputar mengikut arah jam; Putar anti - mengikut arah jam; Berfungsi untuk memutar blok senarai yang dipautkan bijak; Jika panjang adalah 0 atau 1 kepala kembali; Jika ijazah putaran adalah 0, kembali kepala; Melintasi elemen terakhir blok ini; menyimpan nod pertama blok seterusnya; Jika nod blok ini kurang daripada k. Putar blok ini juga; Tambah kepala baru blok seterusnya ke ekor blok ini; kembali ketua senarai yang dipautkan yang dikemas kini; Berfungsi untuk menolak nod; Berfungsi untuk mencetak senarai yang dipautkan; Program pemacu untuk menguji fungsi di atas; Mulakan dengan senarai kosong; Buat senarai 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> NULL; K ialah saiz blok dan d adalah bilangan putaran di setiap blok.", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; struct Node * rotateHelper ( struct Node * blockHead , struct Node * blockTail , int d , struct Node * * tail , int k ) { if ( d == 0 ) return blockHead ; if ( d > 0 ) { struct Node * temp = blockHead ; for ( int i = 1 ; temp -> next -> next && i < k - 1 ; i ++ ) temp = temp -> next ; blockTail -> next = blockHead ; * tail = temp ; return rotateHelper ( blockTail , temp , d - 1 , tail , k ) ; } if ( d < 0 ) { blockTail -> next = blockHead ; * tail = blockHead ; return rotateHelper ( blockHead -> next , blockHead , d + 1 , tail , k ) ; } } struct Node * rotateByBlocks ( struct Node * head , int k , int d ) { if ( ! head ! head -> next ) return head ; if ( d == 0 ) return head ; struct Node * temp = head , * tail = NULL ; int i ; for ( i = 1 ; temp -> next && i < k ; i ++ ) temp = temp -> next ; struct Node * nextBlock = temp -> next ; if ( i < k ) head = rotateHelper ( head , temp , d % k , & tail , i ) ; else head = rotateHelper ( head , temp , d % k , & tail , k ) ; tail -> next = rotateByBlocks ( nextBlock , k , d % k ) ; return head ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * node ) { while ( node != NULL ) { printf ( \" % d ▁ \" , node -> data ) ; node = node -> next ; } } int main ( ) { struct Node * head = NULL ; for ( int i = 9 ; i > 0 ; i -= 1 ) push ( & head , i ) ; printf ( \" Given ▁ linked ▁ list ▁ STRNEWLINE \" ) ; printList ( head ) ; int k = 3 , d = 2 ; head = rotateByBlocks ( head , k , d ) ; printf ( \" Rotated by blocks Linked list \" printList ( head ) ; return ( 0 ) ; }"}
{"text": "Penghapusan pada kedudukan yang berbeza dalam Senarai Berkaitan Pekeliling | Berfungsi untuk memadam nod pertama senarai yang dipautkan bulat; Semak sama ada senarai tidak mempunyai nod jika tidak kemudian kembali; Semak sama ada senarai mempunyai nod tunggal jika ya kemudian padamkannya dan kembali; melintasi nod kedua ke dulu; Sekarang sebelumnya adalah nod terakhir dan nod pertama (firstNode) alamat pautan dimasukkan ke dalam pautan nod terakhir (sebelumnya); buat nod kedua sebagai nod kepala", "code": "void DeleteFirst ( struct Node * * head ) { struct Node * previous = * head , * firstNode = * head ; if ( * head == NULL ) { printf ( \" List is empty \" return ; } if ( previous -> next == previous ) { * head = NULL ; return ; } while ( previous -> next != * head ) { previous = previous -> next ; } previous -> next = firstNode -> next ; * head = previous -> next ; free ( firstNode ) ; return ; }"}
{"text": "Penghapusan pada kedudukan yang berbeza dalam Senarai Berkaitan Pekeliling | Fungsi padam nod terakhir senarai yang dipautkan bulat; Semak sama ada senarai tidak mempunyai nod jika tidak kemudian kembali; Semak sama ada senarai mempunyai nod tunggal jika ya kemudian padamkannya dan kembali; gerakkan nod pertama ke terakhir sebelumnya", "code": "void DeleteLast ( struct Node * * head ) { struct Node * current = * head , * temp = * head , * previous ; if ( * head == NULL ) { printf ( \" List is empty \" return ; } if ( current -> next == current ) { * head = NULL ; return ; } while ( current -> next != * head ) { previous = current ; current = current -> next ; } previous -> next = current -> next ; * head = previous -> next ; free ( current ) ; return ; }"}
{"text": "Kaedah yang cekap untuk menyimpan matriks segi tiga yang lebih rendah menggunakan lajur | Program C untuk pendekatan di atas; Dimensi matriks; Struktur matriks efisien memori; Fungsi untuk menetapkan nilai dalam matriks; Berfungsi untuk menyimpan nilai dalam matriks; Berfungsi untuk memaparkan unsur -unsur matriks; Melintasi matriks; Berfungsi untuk menghasilkan matriks yang cekap; Mengisytiharkan matriks yang cekap; Memulakan matriks; Tetapkan nilai dalam matriks; Mengembalikan matriks; Kod pemacu; Diberikan input; Fungsi panggilan untuk membuat matriks yang cekap memori; Fungsi panggilan untuk mencetak matriks", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE const int N = 5 ; struct Matrix { int * A ; int size ; } ; void Set ( struct Matrix * m , int i , int j , int x ) { if ( i >= j ) m -> A [ ( ( m -> size ) * ( j - 1 ) - ( ( ( j - 2 ) * ( j - 1 ) ) / 2 ) + ( i - j ) ) ] = x ; } int Get ( struct Matrix m , int i , int j ) { if ( i >= j ) return m . A [ ( ( m . size ) * ( j - 1 ) - ( ( ( j - 2 ) * ( j - 1 ) ) / 2 ) + ( i - j ) ) ] ; else return 0 ; } void Display ( struct Matrix m ) { for ( int i = 1 ; i <= m . size ; i ++ ) { for ( int j = 1 ; j <= m . size ; j ++ ) { if ( i >= j ) printf ( \" % d ▁ \" , m . A [ ( ( m . size ) * ( j - 1 ) - ( ( ( j - 2 ) * ( j - 1 ) ) / 2 ) + ( i - j ) ) ] ) ; else printf ( \"0 ▁ \" ) ; } printf ( \" STRNEWLINE \" ) ; } } struct Matrix createMat ( int Mat [ N ] [ N ] ) { struct Matrix mat ; mat . size = N ; mat . A = ( int * ) malloc ( mat . size * ( mat . size + 1 ) / 2 * sizeof ( int ) ) ; for ( int i = 1 ; i <= mat . size ; i ++ ) { for ( int j = 1 ; j <= mat . size ; j ++ ) { Set ( & mat , i , j , Mat [ i - 1 ] [ j - 1 ] ) ; } } return mat ; } int main ( ) { int Mat [ 5 ] [ 5 ] = { { 1 , 0 , 0 , 0 , 0 } , { 1 , 2 , 0 , 0 , 0 } , { 1 , 2 , 3 , 0 , 0 } , { 1 , 2 , 3 , 4 , 0 } , { 1 , 2 , 3 , 4 , 5 } } ; struct Matrix mat = createMat ( Mat ) ; Display ( mat ) ; return 0 ; }"}
{"text": "Count Subarrays yang mempunyai jumlah elemen di kedudukan walaupun dan ganjil sama | Program C untuk pendekatan di atas; Fungsi untuk mengira subarrays di mana jumlah unsur di kedudukan walaupun dan ganjil adalah sama; Memulakan pembolehubah; Melangkah ke atas array; Semak sama ada kedudukannya kemudian tambah ke jumlah kemudian tambahkannya ke jumlah; Lain tolaknya kepada jumlah; Kenaikan kiraan jika jumlah sama dengan 0; Cetak kiraan subarray; Kod pemacu; Diberikan array arr []; Saiz array; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE void countSubarrays ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ; else sum -= arr [ j ] ; if ( sum == 0 ) count ++ ; } } printf ( \" % d \" , count ) ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarrays ( arr , n ) ; return 0 ; }"}
{"text": "Rekursi Tail | Contoh fungsi rekursif ekor; Kenyataan yang dilaksanakan terakhir adalah panggilan rekursif", "code": "void print ( int n ) { if ( n < 0 ) return ; cout << \" ▁ \" << n ; print ( n - 1 ) ; }"}
{"text": "Cetak Elemen Alternatif Array | Program C untuk melaksanakan pendekatan di atas; Berfungsi untuk mencetak elemen alternatif dari array yang diberikan; Elemen cetak pada kedudukan ganjil; Jika Currindex menyimpan indeks atau kedudukan ganjil; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void printAlter ( int arr [ ] , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { printf ( \" % d ▁ \" , arr [ currIndex ] ) ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAlter ( arr , N ) ; }"}
{"text": "Shuffle 2 n bilangan bulat sebagai a1 | Program C untuk pendekatan di atas; Fungsi untuk membalikkan array dari kedudukan 'mula' ke kedudukan 'akhir'; Kedai pertengahan permulaan dan akhir; Melintasi array dalam julat [permulaan, akhir]; Kedai arr [start + i]; UPDATE ARR [Mula + I]; UPDATE ARR [END - I]; Fungsi utiliti untuk mengosongkan array yang diberikan dalam bentuk {a1, b1, a2, b2, .... an, bn}; Menyimpan panjang array; Jika panjang array adalah 2; Kedai pertengahan {start, end}; Bahagikan array menjadi dua bahagian panjang; Kemas kini pertengahan; Kirakan titik pertengahan kedua -dua bahagian array; Membalikkan subarray yang dibuat dari Mid1 hingga Mid2; Membalikkan subarray yang dibuat dari pertengahan hingga pertengahan; Membalikkan subarray yang dibuat dari pertengahan hingga pertengahan2; Panggilan secara rekursif untuk kedua -dua bahagian array; Fungsi untuk mengosongkan array yang diberikan dalam bentuk {A1, B1, A2, B2, .... an, bn}; Panggilan fungsi; Cetak array yang diubah suai; Kod pemacu; Diberikan array; Saiz array; Shuffles array yang diberikan ke permutasi yang diperlukan", "code": "#include <stdio.h> NEW_LINE void reverse ( int arr [ ] , int start , int end ) { int mid = ( end - start + 1 ) / 2 ; for ( int i = 0 ; i < mid ; i ++ ) { int temp = arr [ start + i ] ; arr [ start + i ] = arr [ end - i ] ; arr [ end - i ] = temp ; } return ; } void shuffleArrayUtil ( int arr [ ] , int start , int end ) { int i ; int l = end - start + 1 ; if ( l == 2 ) return ; int mid = start + l / 2 ; if ( l % 4 ) { mid -= 1 ; } int mid1 = start + ( mid - start ) / 2 ; int mid2 = mid + ( end + 1 - mid ) / 2 ; reverse ( arr , mid1 , mid2 - 1 ) ; reverse ( arr , mid1 , mid - 1 ) ; reverse ( arr , mid , mid2 - 1 ) ; shuffleArrayUtil ( arr , start , mid - 1 ) ; shuffleArrayUtil ( arr , mid , end ) ; } void shuffleArray ( int arr [ ] , int N , int start , int end ) { shuffleArrayUtil ( arr , start , end ) ; for ( int i = 0 ; i < N ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 2 , 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; shuffleArray ( arr , N , 0 , N - 1 ) ; return 0 ; }"}
{"text": "Semak jika dua tatasusunan boleh dibuat sama dengan membalikkan subarrays beberapa kali | Pelaksanaan c untuk memeriksa sama ada dua tatasusunan boleh dibuat sama; Fungsi untuk memeriksa sama ada array b boleh dibuat sama dengan array A; Menyusun kedua -dua tatasusunan; Semak kedua -dua array sama atau tidak; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE int sort ( int a [ ] , int n ) { int i , j , tmp ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] < a [ i ] ) { tmp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tmp ; } } } return 0 ; } int canMadeEqual ( int A [ ] , int B [ ] , int n ) { int i ; sort ( A , n ) ; sort ( B , n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != B [ i ] ) { return ( 0 ) ; } } return ( 1 ) ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int n ; int B [ ] = { 1 , 3 , 2 } ; n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( canMadeEqual ( A , B , n ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } return 0 ; }"}
{"text": "Susun Bubble untuk senarai yang dipautkan dengan menukar nod | Program C untuk menyusun senarai yang dipautkan menggunakan jenis gelembung dengan menukar nod; struktur untuk nod; Berfungsi untuk menukar nod; Berfungsi untuk menyusun senarai; Kemas kini pautan selepas bertukar; pecah jika gelung berakhir tanpa swap; Berfungsi untuk mencetak senarai; Berfungsi untuk memasukkan nod struct pada permulaan senarai yang dipautkan; Kod pemacu; Mulakan dengan senarai yang dipautkan kosong; Buat senarai yang dipautkan dari array arr []; Senarai cetak sebelum menyusun; Susun senarai yang dipautkan; Senarai Cetak Setelah Menyusun", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } Node ; struct Node * swap ( struct Node * ptr1 , struct Node * ptr2 ) { struct Node * tmp = ptr2 -> next ; ptr2 -> next = ptr1 ; ptr1 -> next = tmp ; return ptr2 ; } int bubbleSort ( struct Node * * head , int count ) { struct Node * * h ; int i , j , swapped ; for ( i = 0 ; i <= count ; i ++ ) { h = head ; swapped = 0 ; for ( j = 0 ; j < count - i - 1 ; j ++ ) { struct Node * p1 = * h ; struct Node * p2 = p1 -> next ; if ( p1 -> data > p2 -> data ) { * h = swap ( p1 , p2 ) ; swapped = 1 ; } h = & ( * h ) -> next ; } if ( swapped == 0 ) break ; } } void printList ( struct Node * n ) { while ( n != NULL ) { printf ( \" % d ▁ - > ▁ \" , n -> data ) ; n = n -> next ; } printf ( \" STRNEWLINE \" ) ; } void insertAtTheBegin ( struct Node * * start_ref , int data ) { struct Node * ptr1 = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; ptr1 -> data = data ; ptr1 -> next = * start_ref ; * start_ref = ptr1 ; } int main ( ) { int arr [ ] = { 78 , 20 , 10 , 32 , 1 , 5 } ; int list_size , i ; struct Node * start = NULL ; list_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( i = 0 ; i < list_size ; i ++ ) insertAtTheBegin ( & start , arr [ i ] ) ; printf ( \" Linked ▁ list ▁ before ▁ sorting STRNEWLINE \" ) ; printList ( start ) ; bubbleSort ( & start , list_size ) ; printf ( \" Linked ▁ list ▁ after ▁ sorting STRNEWLINE \" ) ; printList ( start ) ; return 0 ; }"}
{"text": "Dalam | C ++ Program dalam - tempat gabungan jenis; Menggabungkan dua subarray ARR []. Subarray pertama adalah arr [l. . m] subarray kedua adalah arr [m + 1. r] pelaksanaan inplace; Jika penggabungan langsung sudah disusun; Dua petunjuk untuk mengekalkan permulaan kedua -dua tatasusunan untuk bergabung; Jika elemen 1 berada di tempat yang betul; Beralih semua elemen antara elemen 1 elemen 2, betul dengan 1 .; Kemas kini semua petunjuk; L adalah untuk indeks kiri dan r adalah indeks kanan sub -pelbagai ARR untuk disusun; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan R yang besar; Menyusun bahagian pertama dan kedua; Berfungsi untuk mencetak array; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void merge ( int arr [ ] , int start , int mid , int end ) { int start2 = mid + 1 ; if ( arr [ mid ] <= arr [ start2 ] ) { return ; } while ( start <= mid && start2 <= end ) { if ( arr [ start ] <= arr [ start2 ] ) { start ++ ; } else { int value = arr [ start2 ] ; int index = start2 ; while ( index != start ) { arr [ index ] = arr [ index - 1 ] ; index -- ; } arr [ start ] = value ; start ++ ; mid ++ ; start2 ++ ; } } } void mergeSort ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } void printArray ( int A [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , A [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; mergeSort ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; return 0 ; }"}
{"text": "Dual Pivot Quicksort | C program untuk melaksanakan dual pivot Quicksort; LP bermaksud pivot kiri, dan RP bermaksud pivot kanan. ; P ialah pivot kiri, dan Q adalah pivot yang betul. ; Jika unsur -unsur kurang daripada pivot kiri; Jika unsur -unsur lebih besar daripada atau sama dengan pivot yang betul; Bawa pivot ke kedudukan yang sesuai. ; Mengembalikan indeks pivots. * lp = j; Kerana kita tidak dapat mengembalikan dua elemen dari fungsi. ; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int partition ( int * arr , int low , int high , int * lp ) ; void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } void DualPivotQuickSort ( int * arr , int low , int high ) { if ( low < high ) { int lp , rp ; rp = partition ( arr , low , high , & lp ) ; DualPivotQuickSort ( arr , low , lp - 1 ) ; DualPivotQuickSort ( arr , lp + 1 , rp - 1 ) ; DualPivotQuickSort ( arr , rp + 1 , high ) ; } } int partition ( int * arr , int low , int high , int * lp ) { if ( arr [ low ] > arr [ high ] ) swap ( & arr [ low ] , & arr [ high ] ) ; int j = low + 1 ; int g = high - 1 , k = low + 1 , p = arr [ low ] , q = arr [ high ] ; while ( k <= g ) { if ( arr [ k ] < p ) { swap ( & arr [ k ] , & arr [ j ] ) ; j ++ ; } else if ( arr [ k ] >= q ) { while ( arr [ g ] > q && k < g ) g -- ; swap ( & arr [ k ] , & arr [ g ] ) ; g -- ; if ( arr [ k ] < p ) { swap ( & arr [ k ] , & arr [ j ] ) ; j ++ ; } } k ++ ; } j -- ; g ++ ; swap ( & arr [ low ] , & arr [ j ] ) ; swap ( & arr [ high ] , & arr [ g ] ) ; return g ; } int main ( ) { int arr [ ] = { 24 , 8 , 42 , 75 , 29 , 77 , 38 , 57 } ; DualPivotQuickSort ( arr , 0 , 7 ) ; printf ( \" Sorted ▁ array : ▁ \" ) ; for ( int i = 0 ; i < 8 ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Membina graf menggunakan n vertices yang jarak terpendek antara k -sepasang simpul adalah 2 | Program C untuk melaksanakan pendekatan di atas; Fungsi untuk membina graf yang mudah dan disambungkan supaya jarak antara pas pasangan kiriman adalah 2; Kedai maksimum mungkin kiraan tepi dalam graf; Kes asas; Kedai kiraan tepi dalam graf; Sambungkan semua simpang pasangan (i, j); Kemas kini; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void constGraphWithCon ( int N , int K ) { int Max = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; if ( K > Max ) { printf ( \" - 1\" ) ; return ; } int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { printf ( \" % d ▁ % d STRNEWLINE \" , i , j ) ; count ++ ; if ( count == N * ( N - 1 ) / 2 - K ) break ; } if ( count == N * ( N - 1 ) / 2 - K ) break ; } } int main ( ) { int N = 5 , K = 3 ; constGraphWithCon ( N , K ) ; return 0 ; }"}
{"text": "Cari n nombor yang berbeza yang bitwise xor sama dengan k | Program C untuk pendekatan di atas; Fungsi untuk mencari n bilangan bilangan yang mempunyai bitwise xor sama dengan k; Kes asas; Berikan nilai kepada p dan q; Menyimpan bitwise xor unsur pertama (n - 3); Cetak elemen n - 3 pertama; Hitung bitwise xor unsur pertama (n - 3); Kod pemacu; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE void findArray ( int N , int K ) { if ( N == 1 ) { printf ( \" % d \" , K ) ; return ; } if ( N == 2 ) { printf ( \" % d ▁ % d \" , 0 , K ) ; return ; } int P = N - 2 ; int Q = N - 1 ; int VAL = 0 ; for ( int i = 1 ; i <= ( N - 3 ) ; i ++ ) { printf ( \" % d ▁ \" , i ) ; VAL ^= i ; } if ( VAL == K ) { printf ( \" % d ▁ % d ▁ % d \" , P , Q , P ^ Q ) ; } else { printf ( \" % d ▁ % d ▁ % d \" , 0 , P , P ^ K ^ VAL ) ; } } int main ( ) { int N = 4 , X = 6 ; findArray ( N , X ) ; return 0 ; }"}
{"text": "Count of N digit nombor yang jumlahnya setiap digit berturut -turut adalah sama | Program C untuk pendekatan di atas; Fungsi untuk mengira bilangan nombor n - digit sedemikian rupa sehingga jumlah setiap digit berturut -turut adalah sama; Pelbagai nombor; Ekstrak digit nombor; Simpan jumlah digit pertama; Semak setiap digit K - berturut -turut; Jika jumlah tidak sama maka hancurkan gelung; Kenaikan kiraan jika ia memenuhi syarat yang diberikan; Kod pemacu; Diberikan n dan k; Panggilan fungsi", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE int countDigitSum ( int N , int K ) { int l = ( int ) pow ( 10 , N - 1 ) , r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; int digits [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ; for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( int j = 1 ; j < N - K + 1 ; j ++ ) { int curr_sum = 0 ; for ( int m = j ; m < j + K ; m ++ ) curr_sum += digits [ m ] ; if ( sum != curr_sum ) { flag = 1 ; break ; } } if ( flag == 0 ) { count ++ ; } } return count ; } int main ( ) { int N = 2 , K = 1 ; printf ( \" % d \" , countDigitSum ( N , K ) ) ; return 0 ; }"}
{"text": "Tukar rentetan ke integer tanpa menggunakan apa -apa dalam | Program C untuk pendekatan di atas; Berfungsi untuk menukar rentetan ke integer tanpa menggunakan fungsi; Memulakan pembolehubah; Berulang sehingga panjang rentetan; Tolak 48 dari digit semasa; Cetak jawapannya; Kod pemacu; Diberikan rentetan nombor; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void convert ( char s [ ] ) { int num = 0 ; int n = strlen ( s ) ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + ( s [ i ] - 48 ) ; printf ( \" % d \" , num ) ; } int main ( ) { char s [ ] = \"123\" ; convert ( s ) ; return 0 ; }"}
{"text": "Kemajuan Aritmetik Terpanjang | DP | Fungsi ini kembali benar jika terdapat tiga elemen dalam asumsi AP: Tetapkan [0 .. N - 1] disusun. Kod ini dengan tegas melaksanakan algoritma yang disediakan dalam rujukan. ; Satu dengan menetapkan setiap elemen sebagai elemen tengah; Inisialisasi I dan K untuk J semasa; Cari jika ada i dan k yang membentuk ap dengan j sebagai elemen tengah", "code": "bool arithmeticThree ( int set [ ] , int n ) { for ( int j = 1 ; j < n - 1 ; j ++ ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] == 2 * set [ j ] ) return true ; ( set [ i ] + set [ k ] < 2 * set [ j ] ) ? k ++ : i -- ; } } return false ; }"}
{"text": "Jumlah maksimum Peningkatan seterusnya | DP | Pelaksanaan pengaturcaraan dinamik jumlah maksimum peningkatan masalah berikutnya (MSIS); maxSumis () mengembalikan jumlah maksimum peningkatan seterusnya dalam arr [] saiz n; Memulakan nilai MSIS untuk semua indeks; Kirakan nilai jumlah maksimum dengan cara bawah; Pilih maksimum semua nilai MSIS; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; } int main ( ) { int arr [ ] = { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Sum ▁ of ▁ maximum ▁ sum ▁ increasing ▁ \" \" subsequence ▁ is ▁ % d STRNEWLINE \" , maxSumIS ( arr , n ) ) ; return 0 ; }"}
{"text": "C / C ++ Program untuk peningkatan terpanjang yang paling lama | Pelaksanaan rekursif naif masalah LIS; Untuk menggunakan panggilan rekursif, fungsi ini mesti mengembalikan dua perkara: 1) panjang lis yang berakhir dengan elemen arr [n - 1]. Kami menggunakan max_ending_here untuk tujuan ini 2) Keseluruhan maksimum kerana LIS mungkin berakhir dengan elemen sebelum arr [n - 1] max_ref digunakan tujuan ini. Nilai LIS pelbagai saiz n disimpan dalam * max_ref yang merupakan hasil akhir kami; Kes asas; 'max _ ending _ here' adalah panjang lis yang berakhir dengan arr [n - 1]; Recursively mendapatkan semua lis yang berakhir dengan arr [0], arr [1] ... arr [n - 2]. Jika arr [i - 1] lebih kecil daripada arr [n - 1], dan max berakhir dengan arr [n - 1] perlu dikemas kini, kemudian mengemas kini; Bandingkan max_ending_here dengan keseluruhan maks. Dan mengemas kini max keseluruhan jika diperlukan; Pulangan panjang lis yang berakhir dengan arr [n - 1]; Fungsi pembalut untuk _lis (); Pembolehubah max memegang hasilnya; Fungsi _lis () menyimpan hasilnya dalam max; mengembalikan max; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int _lis ( int arr [ ] , int n , int * max_ref ) { if ( n == 1 ) return 1 ; int res , max_ending_here = 1 ; for ( int i = 1 ; i < n ; i ++ ) { res = _lis ( arr , i , max_ref ) ; if ( arr [ i - 1 ] < arr [ n - 1 ] && res + 1 > max_ending_here ) max_ending_here = res + 1 ; } if ( * max_ref < max_ending_here ) * max_ref = max_ending_here ; return max_ending_here ; } int lis ( int arr [ ] , int n ) { int max = 1 ; _lis ( arr , n , & max ) ; return max ; } int main ( ) { int arr [ ] = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Length ▁ of ▁ lis ▁ is ▁ % d STRNEWLINE \" , lis ( arr , n ) ) ; return 0 ; }"}
{"text": "Subproblem bertindih dalam pengaturcaraan dinamik | DP | program rekursif mudah untuk nombor Fibonacci", "code": "int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }"}
{"text": "Count bilangan rentetan yang diberikan dalam array aksara 2D | C Kod untuk mencari kiraan rentetan dalam array aksara 2D yang diberikan. ; fungsi utiliti untuk mencari rentetan lengkap dari mana -mana indeks yang diberikan 2D Char Array; Melalui Backtrack mencari di setiap arah; Berfungsi untuk mencari rentetan dalam array 2D; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #include <stdlib.h> NEW_LINE #define ARRAY_SIZE ( a )  (sizeof(a) / sizeof(*a)) NEW_LINE int internalSearch ( char * needle , int row , int col , char * * hay , int row_max , int col_max ) { int found = 0 ; if ( row >= 0 && row <= row_max && col >= 0 && col <= col_max && * needle == hay [ row ] [ col ] ) { char match = * needle ++ ; hay [ row ] [ col ] = 0 ; if ( * needle == 0 ) { found = 1 ; } else { found += internalSearch ( needle , row , col + 1 , hay , row_max , col_max ) ; found += internalSearch ( needle , row , col - 1 , hay , row_max , col_max ) ; found += internalSearch ( needle , row + 1 , col , hay , row_max , col_max ) ; found += internalSearch ( needle , row - 1 , col , hay , row_max , col_max ) ; } hay [ row ] [ col ] = match ; } return found ; } int searchString ( char * needle , int row , int col , char * * str , int row_count , int col_count ) { int found = 0 ; int r , c ; for ( r = 0 ; r < row_count ; ++ r ) { for ( c = 0 ; c < col_count ; ++ c ) { found += internalSearch ( needle , r , c , str , row_count - 1 , col_count - 1 ) ; } } return found ; } int main ( void ) { char needle [ ] = \" MAGIC \" ; char * input [ ] = { \" BBABBM \" , \" CBMBBA \" , \" IBABBG \" , \" GOZBBI \" , \" ABBBBC \" , \" MCIGAM \" } ; char * str [ ARRAY_SIZE ( input ) ] ; int i ; for ( i = 0 ; i < ARRAY_SIZE ( input ) ; ++ i ) { str [ i ] = malloc ( strlen ( input [ i ] ) ) ; strcpy ( str [ i ] , input [ i ] ) ; } printf ( \" count : ▁ % d STRNEWLINE \" , searchString ( needle , 0 , 0 , str , ARRAY_SIZE ( str ) , strlen ( str [ 0 ] ) ) ) ; return 0 ; }"}
{"text": "Semak jika ekspresi tanda kurung yang diberikan adalah seimbang atau tidak | C Program pendekatan di atas; Fungsi untuk memeriksa sama ada tanda kurung seimbang; Pembolehubah permulaan; Melintasi ungkapan; Ia adalah kurungan penutup; Ini bermakna terdapat lebih banyak tanda kurungan daripada pembukaan; Sekiranya kiraan tidak sifar, ini bermakna terdapat lebih banyak kurungan pembukaan; Kod pemacu", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE bool isBalanced ( char exp [ ] ) { bool flag = true ; int count = 0 ; for ( int i = 0 ; exp [ i ] != ' \\0' ; i ++ ) { if ( exp [ i ] == ' ( ' ) { count ++ ; } else { count -- ; } if ( count < 0 ) { flag = false ; break ; } } if ( count != 0 ) { flag = false ; } return flag ; } int main ( ) { char exp1 [ ] = \" ( ( ( ) ) ) ( ) ( ) \" ; if ( isBalanced ( exp1 ) ) printf ( \" Balanced ▁ STRNEWLINE \" ) ; else printf ( \" Not ▁ Balanced ▁ STRNEWLINE \" ) ; char exp2 [ ] = \" ( ) ) ( ( ( ) ) \" ; if ( isBalanced ( exp2 ) ) printf ( \" Balanced ▁ STRNEWLINE \" ) ; else printf ( \" Not ▁ Balanced ▁ STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Jarak terpendek kepada setiap watak lain dari watak yang diberikan | C pelaksanaan pendekatan di atas; Fungsi untuk mengembalikan vektor jarak yang diperlukan; Senarai untuk memegang kedudukan C dalam S; panjang rentetan; Untuk memegang saiz senarai; Melangkah ke atas rentetan untuk membuat senarai; nilai maksimum P2; Memulakan petunjuk; Membuat pelbagai hasil; Nilai pada penunjuk semasa; Indeks semasa sebelum ini daripada P1; Indeks semasa adalah antara P1 dan P2; Indeks semasa lebih dekat dengan P1; Indeks semasa lebih dekat dengan P2; Bergerak penunjuk 1 langkah ke hadapan; Indeks semasa adalah selepas P2; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define MAX_SIZE  100 NEW_LINE void shortestToChar ( char s [ ] , char c , int * res ) { int list [ MAX_SIZE ] ; int len = 0 ; int l = 0 ; while ( s [ len ] != ' \\0' ) { if ( s [ len ] == c ) { list [ l ] = len ; l ++ ; } len ++ ; } int p1 , p2 , v1 , v2 ; l = l - 1 ; p1 = 0 ; p2 = l > 0 ? 1 : 0 ; for ( int i = 0 ; i < len ; i ++ ) { v1 = list [ p1 ] ; v2 = list [ p2 ] ; if ( i <= v1 ) { res [ i ] = ( v1 - i ) ; } else if ( i <= v2 ) { if ( i - v1 < v2 - i ) { res [ i ] = ( i - v1 ) ; } else { res [ i ] = ( v2 - i ) ; p1 = p2 ; p2 = p2 < l ? ( p2 + 1 ) : p2 ; } } else { res [ i ] = ( i - v2 ) ; } } } int main ( ) { char s [ ] = \" geeksforgeeks \" ; char c = ' e ' ; int res [ MAX_SIZE ] ; shortestToChar ( s , c , res ) ; int i = 0 ; while ( s [ i ] != ' \\0' ) printf ( \" % d ▁ \" , res [ i ++ ] ) ; return 0 ; }"}
{"text": "Rentetan terbalik mengikut bilangan perkataan | C program untuk membalikkan rentetan mengikut bilangan perkataan; Membalikkan huruf perkataan; Pembolehubah sementara untuk menyimpan watak; Menukar watak pertama dan terakhir; Fungsi ini membentuk rentetan yang diperlukan; Memeriksa bilangan perkataan yang ada dalam rentetan untuk terbalik; Membalikkan huruf perkataan; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void reverse ( char str [ ] , int start , int end ) { char temp ; while ( start <= end ) { temp = str [ start ] ; str [ start ] = str [ end ] ; str [ end ] = temp ; start ++ ; end -- ; } } void reverseletter ( char str [ ] , int start , int end ) { int wstart , wend ; for ( wstart = wend = start ; wend < end ; wend ++ ) { if ( str [ wend ] == ' ▁ ' ) continue ; while ( str [ wend ] != ' ▁ ' && wend <= end ) wend ++ ; wend -- ; reverse ( str , wstart , wend ) ; } } int main ( ) { char str [ 1000 ] = \" Ashish ▁ Yadav ▁ Abhishek ▁ Rajput ▁ Sunil ▁ Pundir \" ; reverseletter ( str , 0 , strlen ( str ) - 1 ) ; printf ( \" % s \" , str ) ; return 0 ; }"}
{"text": "Bilangan substrings dengan kiraan setiap watak sebagai k |", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; } bool have_same_frequency ( int freq [ ] , int k ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] != 0 && freq [ i ] != k ) { return false ; } } return true ; } int count_substrings ( char * s , int n , int k ) { int count = 0 ; int distinct = 0 ; bool have [ 26 ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) { have [ s [ i ] - ' a ' ] = true ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( have [ i ] ) { distinct ++ ; } } for ( int length = 1 ; length <= distinct ; length ++ ) { int window_length = length * k ; int freq [ 26 ] = { 0 } ; int window_start = 0 ; int window_end = window_start + window_length - 1 ; for ( int i = window_start ; i <= min ( window_end , n - 1 ) ; i ++ ) { freq [ s [ i ] - ' a ' ] ++ ; } while ( window_end < n ) { if ( have_same_frequency ( freq , k ) ) { count ++ ; } freq [ s [ window_start ] - ' a ' ] -- ; window_start ++ ; window_end ++ ; if ( window_end < n ) { freq [ s [ window_end ] - ' a ' ] ++ ; } } } return count ; } int main ( ) { char * s = \" aabbcc \" ; int k = 2 ; printf ( \" % d STRNEWLINE \" , count_substrings ( s , 6 , k ) ) ; s = \" aabbc \" ; k = 2 ; printf ( \" % d STRNEWLINE \" , count_substrings ( s , 5 , k ) ) ; return 0 ; }"}
{"text": "Togol kes rentetan menggunakan pengendali bitwise | C program untuk mendapatkan kes togol rentetan; togol kes = swap topi ke kes yang lebih rendah dan kes yang lebih rendah ke topi; Bitwise exor dengan 32; Kod pemacu", "code": "#include <stdio.h> NEW_LINE char * toggleCase ( char * a ) { for ( int i = 0 ; a [ i ] != ' \\0' ; i ++ ) { a [ i ] ^= 32 ; } return a ; } int main ( ) { char str [ ] = \" CheRrY \" ; printf ( \" Toggle ▁ case : ▁ % s STRNEWLINE \" , toggleCase ( str ) ) ; printf ( \" Original ▁ string : ▁ % s \" , toggleCase ( str ) ) ; return 0 ; }"}
{"text": "Tulis Atoi anda sendiri () |", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE int main ( ) { int val ; char strn1 [ ] = \"12546\" ; val = atoi ( strn1 ) ; printf ( \" String ▁ value ▁ = ▁ % s STRNEWLINE \" , strn1 ) ; printf ( \" Integer ▁ value ▁ = ▁ % d STRNEWLINE \" , val ) ; char strn2 [ ] = \" GeeksforGeeks \" ; val = atoi ( strn2 ) ; printf ( \" String ▁ value ▁ = ▁ % s STRNEWLINE \" , strn2 ) ; printf ( \" Integer ▁ value ▁ = ▁ % d STRNEWLINE \" , val ) ; return ( 0 ) ; }"}
{"text": "Tulis STRCMP anda sendiri yang mengabaikan Kes |  ; pelaksanaan STRCMP yang mengabaikan kes; Jika watak sama atau membalikkan bit ke -6 menjadikannya sama; Bandingkan watak terakhir (atau pertama dalam kes tidak sama) aksara; Tetapkan bit ke -6 dalam kedua -duanya, kemudian bandingkan; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int ic_strcmp ( char * s1 , char * s2 ) { int i ; for ( i = 0 ; s1 [ i ] && s2 [ i ] ; ++ i ) { if ( s1 [ i ] == s2 [ i ] || ( s1 [ i ] ^ 32 ) == s2 [ i ] ) continue ; else break ; } if ( s1 [ i ] == s2 [ i ] ) return 0 ; if ( ( s1 [ i ] 32 ) < ( s2 [ i ] 32 ) ) return -1 ; return 1 ; } int main ( void ) { printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" Geeks \" , \" apple \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" \" , \" ABCD \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" ABCD \" , \" z \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" ABCD \" , \" abcdEghe \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" GeeksForGeeks \" , \" gEEksFORGeEKs \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" GeeksForGeeks \" , \" geeksForGeeks \" ) ) ; return 0 ; }"}
{"text": "Semak sama ada dua rentetan adalah anagram antara satu sama lain | Program C untuk memeriksa sama ada dua rentetan adalah anagram antara satu sama lain; berfungsi untuk memeriksa sama ada dua rentetan adalah anagram antara satu sama lain; Buat 2 kiraan susunan dan mulakan semua nilai sebagai 0; Bagi setiap aksara dalam rentetan input, kiraan kenaikan dalam array kiraan yang sepadan; Jika kedua -dua rentetan adalah panjang yang berbeza. Mengeluarkan keadaan ini akan menjadikan program itu gagal untuk rentetan seperti \"AACA\" dan \"ACA\"; Bandingkan susunan kiraan; Kod pemacu; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE bool areAnagram ( char * str1 , char * str2 ) { int count1 [ NO_OF_CHARS ] = { 0 } ; int count2 [ NO_OF_CHARS ] = { 0 } ; int i ; for ( i = 0 ; str1 [ i ] && str2 [ i ] ; i ++ ) { count1 [ str1 [ i ] ] ++ ; count2 [ str2 [ i ] ] ++ ; } if ( str1 [ i ] str2 [ i ] ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; } int main ( ) { char str1 [ ] = \" geeksforgeeks \" ; char str2 [ ] = \" forgeeksgeeks \" ; if ( areAnagram ( str1 , str2 ) ) printf ( \" The ▁ two ▁ strings ▁ are ▁ anagram ▁ of ▁ each ▁ other \" ) ; else printf ( \" The ▁ two ▁ strings ▁ are ▁ not ▁ anagram ▁ of ▁ each ▁ \" \" other \" ) ; return 0 ; }"}
{"text": "Nombor Heptacontagon | Program C untuk pendekatan di atas; Mencari nombor heptacontagon nth; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; } int main ( ) { int N = 3 ; printf ( \"3rd ▁ heptacontagon ▁ Number ▁ is ▁ = ▁ % d \" , heptacontagonNum ( N ) ) ; return 0 ; }"}
{"text": "Kirakan maksimum dua integer dalam C / C ++ menggunakan pengendali bitwise | Program C untuk pendekatan di atas; Berfungsi untuk mencari nombor terbesar; Melakukan penolakan; Peralihan kanan dan bitwise dan; Cari nombor maksimum; Mengembalikan nilai maksimum; Kod pemacu; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE int findMax ( int a , int b ) { int z , i , max ; z = a - b ; i = ( z >> 31 ) & 1 ; max = a - ( i * z ) ; return max ; } int main ( ) { int A = 40 , B = 54 ; printf ( \" % d \" , findMax ( A , B ) ) ; return 0 ; }"}
{"text": "C / C ++ Program untuk Nombor Armstrong | Program C untuk mencari nombor Armstrong; Fungsi untuk mengira n yang dibangkitkan kepada kuasa d; Berfungsi untuk mengira urutan nombor; Untuk setiap digit; Berfungsi untuk memeriksa sama ada nombor yang diberikan adalah nombor Armstrong atau tidak; Fungsi pesanan panggilan; Untuk setiap digit; Jika memenuhi keadaan Armstrong; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE int power ( int N , unsigned int D ) { if ( D == 0 ) return 1 ; if ( D % 2 == 0 ) return power ( N , D / 2 ) * power ( N , D / 2 ) ; return N * power ( N , D / 2 ) * power ( N , D / 2 ) ; } int order ( int N ) { int r = 0 ; while ( N ) { r ++ ; N = N / 10 ; } return r ; } int isArmstrong ( int N ) { int D = order ( N ) ; int temp = N , sum = 0 ; while ( temp ) { int Ni = temp % 10 ; sum += power ( Ni , D ) ; temp = temp / 10 ; } if ( sum == N ) return 1 ; else return 0 ; } int main ( ) { int N = 153 ; if ( isArmstrong ( N ) == 1 ) printf ( \" True STRNEWLINE \" ) ; else printf ( \" False STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Program C / C ++ untuk mencari nombor utama antara julat yang diberikan | Program C untuk mencari nombor utama antara selang tertentu; Berfungsi untuk nombor utama cetak dalam julat yang diberikan; Melintasi setiap nombor dalam selang waktu dengan bantuan untuk gelung; Langkau 0 dan 1 kerana mereka bukan Perdana atau Komposit; pembolehubah bendera untuk memberitahu jika saya adalah perdana atau tidak; Berulang -ulang untuk memeriksa sama ada saya adalah perdana atau tidak; Bendera = 1 bermakna saya adalah perdana dan bendera = 0 bermakna saya bukan perdana; Kod pemacu; Julat yang diberikan; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE void primeInRange ( int L , int R ) { int i , j , flag ; for ( i = L ; i <= R ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) printf ( \" % d ▁ \" , i ) ; } } int main ( ) { int L = 1 ; int R = 10 ; primeInRange ( L , R ) ; return 0 ; }"}
{"text": "Semak sama ada kiraan ganjil dan juga faktor nombor adalah sama | C kod untuk pendekatan di atas; Berfungsi untuk memeriksa keadaan; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define lli  long long int NEW_LINE void isEqualFactors ( lli N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) printf ( \" YES STRNEWLINE \" ) ; else printf ( \" NO STRNEWLINE \" ) ; } int main ( ) { lli N = 10 ; isEqualFactors ( N ) ; N = 125 ; isEqualFactors ( N ) ; return 0 ; }"}
{"text": "Lynch | C pelaksanaan untuk pendekatan di atas; Fungsi untuk memeriksa pembahagian nombor dengan digitnya. ; Jika digit membahagikan nombor maka kembali benar lain kembali palsu. ; Berfungsi untuk memeriksa sama ada semua digit N membahagikannya atau tidak; Mengambil digit nombor ke dalam digit var. ; Fungsi untuk memeriksa sama ada n mempunyai semua digit yang berbeza; Buat pelbagai saiz 10 dan mulakan semua elemen sebagai palsu. Arahan ini digunakan untuk memeriksa sama ada digit sudah dilihat atau tidak. ; Melintasi semua digit nombor yang diberikan; Cari digit terakhir; Jika digit sudah dilihat, kembali palsu; Tandakan digit ini seperti yang dilihat; Keluarkan digit terakhir dari nombor; Berfungsi untuk memeriksa lynch - nombor loceng; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE int checkDivisibility ( int n , int digit ) { return ( digit != 0 && n % digit == 0 ) ; } int isAllDigitsDivide ( int n ) { int temp = n ; while ( temp > 0 ) { int digit = temp % 10 ; if ( ! ( checkDivisibility ( n , digit ) ) ) return 0 ; temp /= 10 ; } return 1 ; } int isAllDigitsDistinct ( int n ) { int arr [ 10 ] , i , digit ; for ( i = 0 ; i < 10 ; i ++ ) arr [ i ] = 0 ; while ( n > 0 ) { digit = n % 10 ; if ( arr [ digit ] ) return 0 ; arr [ digit ] = 1 ; n = n / 10 ; } return 1 ; } int isLynchBell ( int n ) { return isAllDigitsDivide ( n ) && isAllDigitsDistinct ( n ) ; } int main ( ) { int N = 12 ; if ( isLynchBell ( N ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Maksimum bitwise dan pasangan (x, y) dari julat yang diberikan supaya x dan y boleh sama | Pelaksanaan c untuk mencari bitwise maksimum dan pasangan (x, y) dari julat yang diberikan supaya x dan y boleh sama; Berfungsi untuk mengembalikan bitwise maksimum dan; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int maximumAND ( int L , int R ) { return R ; } int main ( ) { int l = 3 ; int r = 7 ; printf ( \" % d \" , maximumAND ( l , r ) ) ; return 0 ; }"}
{"text": "Rata -rata kiub nombor semulajadi n pertama | Program C untuk pendekatan di atas; Fungsi untuk mencari purata kiub; Simpan jumlah kiub nombor dalam jumlah; Hitung jumlah kiub; Pulangan purata; Kod pemacu; Nombor yang diberikan; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE double findAverageOfCube ( int n ) { double sum = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; } int main ( ) { int n = 3 ; printf ( \" % lf \" , findAverageOfCube ( n ) ) ; return 0 ; }"}
{"text": "Program C / C ++ untuk menambah jarak N yang diberikan dalam inci | Program C untuk pendekatan di atas; Struct yang ditakrifkan untuk sistem kaki inci; Pembolehubah untuk menyimpan kaki inci; Fungsi untuk mencari jumlah semua jarak N inci jarak inci; Pembolehubah untuk menyimpan jumlah; Melintasi array inchfeet; Cari jumlah jumlah kaki dan inci; Jika jumlah inci lebih besar daripada 11 menukarnya menjadi kaki sebagai 1 kaki = 12 inci; Cari bahagian integral inch_sum; Padam bahagian integral X; Tambah x % 12 ke inch_sum; Tambah x / 12 ke feet_sum; Cetak jumlah yang sama kaki_sum dan inch_sum; Kod pemacu; Diberikan set kaki inci; Panggilan fungsi", "code": "#include \" stdio . h \" NEW_LINE struct InchFeet { int feet ; float inch ; } ; void findSum ( struct InchFeet arr [ ] , int N ) { int feet_sum = 0 ; float inch_sum = 0.0 ; int x ; for ( int i = 0 ; i < N ; i ++ ) { feet_sum += arr [ i ] . feet ; inch_sum += arr [ i ] . inch ; } if ( inch_sum >= 12 ) { x = ( int ) inch_sum ; inch_sum -= x ; inch_sum += x % 12 ; feet_sum += x / 12 ; } printf ( \" Feet ▁ Sum : ▁ % d STRNEWLINE \" , feet_sum ) ; printf ( \" Inch ▁ Sum : ▁ % .2f \" , inch_sum ) ; } int main ( ) { struct InchFeet arr [ ] = { { 10 , 3.7 } , { 10 , 5.5 } , { 6 , 8.0 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSum ( arr , N ) ; return 0 ; }"}
{"text": "Trik Logaritma untuk Pengaturcaraan Kompetitif | C pelaksanaan untuk memeriksa sama ada nombor adalah kuasa k; Fungsi untuk memeriksa sama ada nombor kuasa k; Fungsi logaritma untuk mengira nilai; Bandingkan dengan hasil1 atau hasil2 kedua -duanya adalah sama; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE _Bool isPower ( int N , int K ) { int res1 = log ( N ) / log ( K ) ; double res2 = log ( N ) / log ( K ) ; return ( res1 == res2 ) ; } int main ( ) { int N = 8 ; int K = 2 ; if ( isPower ( N , K ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } return 0 ; }"}
{"text": "Program untuk mencari integral fungsi tertentu menggunakan peraturan Boole | Program C untuk melaksanakan peraturan Boole pada fungsi yang diberikan; Fungsi untuk mengembalikan nilai f (x) untuk nilai yang diberikan x; Berfungsi untuk mengira integrand y pada selang masa x yang diberikan dengan saiz langkah H dan had awal A dan had akhir b; Bilangan selang; Pengkomputeran saiz langkah; Menggantikan a = 0, b = 4 dan h = 1; Kod pemacu", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE float y ( float x ) { return ( 1 / ( 1 + x ) ) ; } float BooleRule ( float a , float b ) { int n = 4 ; int h ; h = ( ( b - a ) / n ) ; float sum = 0 ; float bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ; sum = sum + bl ; return sum ; } int main ( ) { float lowlimit = 0 ; float upplimit = 4 ; printf ( \" f ( x ) ▁ = ▁ % .4f \" , BooleRule ( 0 , 4 ) ) ; return 0 ; }"}
{"text": "Mencari Integrand menggunakan Peraturan Weedle | Program C untuk melaksanakan peraturan Weedle; Fungsi sampel f (x) = 1 / (1 + x ^ 2); Berfungsi untuk mencari nilai integral f (x) dengan saiz langkah H, dengan had bawah awal dan had atas a dan b; Cari saiz langkah H; Untuk menyimpan jumlah akhir; Cari jumlah menggunakan formula Weedle; Mengembalikan jumlah akhir; Kod pemacu; had bawah dan had atas; Panggilan fungsi", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE float y ( float x ) { float num = 1 ; float denom = 1.0 + x * x ; return num / denom ; } float WeedleRule ( float a , float b ) { double h = ( b - a ) / 6 ; float sum = 0 ; sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) ; return sum ; } int main ( ) { float a = 0 , b = 6 ; printf ( \" f ( x ) ▁ = ▁ % f \" , WeedleRule ( a , b ) ) ; return 0 ; }"}
{"text": "Runge | Program C untuk melaksanakan kaedah Runge Kutta; Persamaan pembezaan sampel \"dy / dx = ~ (x ~ u) / 2\"; Cari nilai y untuk x yang diberikan menggunakan saiz langkah H dan nilai awal y0 pada x0. ; Kiraan bilangan lelaran menggunakan saiz langkah atau ketinggian langkah h; Berulang untuk bilangan lelaran; Sapukan formula runge kutta untuk mencari nilai seterusnya y; Kemas kini nilai seterusnya Y; Kemas kini nilai seterusnya x; Kod pemacu", "code": "#include <stdio.h> NEW_LINE float dydx ( float x , float y ) { return ( x + y - 2 ) ; } float rungeKutta ( float x0 , float y0 , float x , float h ) { int n = ( int ) ( ( x - x0 ) / h ) ; float k1 , k2 ; float y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; y = y + ( 1.0 / 6.0 ) * ( k1 + 2 * k2 ) ; x0 = x0 + h ; } return y ; } int main ( ) { float x0 = 0 , y = 1 , x = 2 , h = 0.2 ; printf ( \" y ( x ) ▁ = ▁ % f \" , rungeKutta ( x0 , y , x , h ) ) ; return 0 ; }"}
{"text": "Perimeter dan kawasan paralelogram Varignon | Program C untuk mencari perimeter dan kawasan; Berfungsi untuk mencari perimeter; Berfungsi untuk mencari kawasan; Kod pemacu", "code": "#include <stdio.h> NEW_LINE float per ( float a , float b ) { return ( a + b ) ; } float area ( float s ) { return ( s / 2 ) ; } int main ( ) { float a = 7 , b = 8 , s = 10 ; printf ( \" % f STRNEWLINE \" , per ( a , b ) ) ; printf ( \" % f \" , area ( s ) ) ; return 0 ; }"}
{"text": "Kawasan daun di dalam persegi | C program untuk mencari kawasan daun di dalam persegi; Fungsi untuk mencari kawasan daun; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float area_leaf ( float a ) { return ( a * a * ( PI / 2 - 1 ) ) ; } int main ( ) { float a = 7 ; printf ( \" % f \" , area_leaf ( a ) ) ; return 0 ; }"}
{"text": "Panjang tali yang diikat sekitar tiga bulatan yang sama menyentuh satu sama lain | Program C untuk mencari panjang tali; Berfungsi untuk mencari panjang tali; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float length_rope ( float r ) { return ( ( 2 * PI * r ) + 6 * r ) ; } int main ( ) { float r = 7 ; printf ( \" % f \" , length_rope ( r ) ) ; return 0 ; }"}
{"text": "Kawasan Incircle dari Segitiga Bersudut Kanan | Program C untuk mencari kawasan selang segitiga bersudut kanan; Fungsi untuk mencari kawasan incircle; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float area_inscribed ( float P , float B , float H ) { return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) ; } int main ( ) { float P = 3 , B = 4 , H = 5 ; printf ( \" % f \" , area_inscribed ( P , B , H ) ) ; return 0 ; }"}
{"text": "Kawasan Circumcircle dari Segitiga Bersudut Kanan | Program c untuk mencari kawasan lingkaran cicumscribed segitiga bersudut kanan; Fungsi untuk mencari kawasan bulatan yang dilampirkan; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float area_circumscribed ( float c ) { return ( c * c * ( PI / 4 ) ) ; } int main ( ) { float c = 8 ; printf ( \" % f \" , area_circumscribed ( c ) ) ; return 0 ; }"}
{"text": "Program untuk mengira kawasan dan perimeter dari segitiga sama rata | Program C untuk mencari kawasan lingkaran segitiga sama rata; berfungsi untuk mencari kawasan bulatan tertulis; berfungsi untuk mencari perimeter bulatan tertulis; Kod pemacu", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float area_inscribed ( float a ) { return ( a * a * ( PI / 12 ) ) ; } float perm_inscribed ( float a ) { return ( PI * ( a / sqrt ( 3 ) ) ) ; } int main ( ) { float a = 6 ; printf ( \" Area ▁ of ▁ inscribed ▁ circle ▁ is ▁ : % f STRNEWLINE \" , area_inscribed ( a ) ) ; printf ( \" Perimeter ▁ of ▁ inscribed ▁ circle ▁ is ▁ : % f \" , perm_inscribed ( a ) ) ; return 0 ; }"}
{"text": "Program untuk mencari kawasan dan perimeter separuh bulatan | Program C untuk mencari kawasan dan perimeter separuh bulatan; Fungsi untuk mengira kawasan tersebut; Formula untuk mencari kawasan; Fungsi untuk mengira perimeter; Formula untuk mencari perimeter; kod pemacu; Dapatkan jejari; Cari kawasan itu; Cari perimeter", "code": "#include <stdio.h> NEW_LINE float area ( float r ) { return ( 0.5 ) * ( 3.14 ) * ( r * r ) ; } float perimeter ( float r ) { return ( 3.14 ) * ( r ) ; } int main ( ) { float r = 10 ; printf ( \" The ▁ Area ▁ of ▁ Semicircle : ▁ % f STRNEWLINE \" , area ( r ) ) ; printf ( \" The ▁ Perimeter ▁ of ▁ Semicircle : ▁ % f STRNEWLINE \" , perimeter ( r ) ) ; return 0 ; }"}
{"text": "Program untuk mencari persamaan pesawat yang melalui 3 mata | Program C untuk mencari persamaan pesawat yang melalui 3 mata. ; Fungsi untuk mencari persamaan satah. ; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; printf ( \" equation ▁ of ▁ plane ▁ is ▁ % .2f ▁ x ▁ + ▁ % .2f \" \" ▁ y ▁ + ▁ % .2f ▁ z ▁ + ▁ % .2f ▁ = ▁ 0 . \" , a , b , c , d ) ; return ; } int main ( ) { float x1 = -1 ; float y1 = 2 ; float z1 = 1 ; float x2 = 0 ; float y2 = -3 ; float z2 = 2 ; float x3 = 1 ; float y3 = 1 ; float z3 = -4 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; return 0 ; }"}
{"text": "Jarak tegak antara satu titik dan garis dalam 2 D | Program C untuk mencari jarak antara titik tertentu dan garis tertentu dalam 2 d. ; Berfungsi untuk mencari jarak; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void shortest_distance ( float x1 , float y1 , float a , float b , float c ) { float d = fabs ( ( a * x1 + b * y1 + c ) ) / ( sqrt ( a * a + b * b ) ) ; printf ( \" Perpendicular ▁ distance ▁ is ▁ % f STRNEWLINE \" , d ) ; return ; } int main ( ) { float x1 = 5 ; float y1 = 6 ; float a = -2 ; float b = 3 ; float c = 4 ; shortest_distance ( x1 , y1 , a , b , c ) ; return 0 ; }"}
{"text": "Program untuk menentukan oktan satah paksi | Program C untuk mencetak Octant titik tertentu. ; Berfungsi untuk mencetak oktan; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) printf ( \" Point ▁ lies ▁ in ▁ 1st ▁ octant STRNEWLINE \" ) ; else if ( x < 0 && y >= 0 && z >= 0 ) printf ( \" Point ▁ lies ▁ in ▁ 2nd ▁ octant STRNEWLINE \" ) ; else if ( x < 0 && y < 0 && z >= 0 ) printf ( \" Point ▁ lies ▁ in ▁ 3rd ▁ octant STRNEWLINE \" ) ; else if ( x >= 0 && y < 0 && z >= 0 ) printf ( \" Point ▁ lies ▁ in ▁ 4th ▁ octant STRNEWLINE \" ) ; else if ( x >= 0 && y >= 0 && z < 0 ) printf ( \" Point ▁ lies ▁ in ▁ 5th ▁ octant STRNEWLINE \" ) ; else if ( x < 0 && y >= 0 && z < 0 ) printf ( \" Point ▁ lies ▁ in ▁ 6th ▁ octant STRNEWLINE \" ) ; else if ( x < 0 && y < 0 && z < 0 ) printf ( \" Point ▁ lies ▁ in ▁ 7th ▁ octant STRNEWLINE \" ) ; else if ( x >= 0 && y < 0 && z < 0 ) printf ( \" Point ▁ lies ▁ in ▁ 8th ▁ octant STRNEWLINE \" ) ; } int main ( ) { float x = 2 , y = 3 , z = 4 ; octant ( x , y , z ) ; x = -4 , y = 2 , z = -8 ; octant ( x , y , z ) ; x = -6 , y = -2 , z = 8 ; octant ( x , y , z ) ; }"}
{"text": "Kawasan Maksimum Kuadrilateral | Program CPP untuk mencari maksimum adalah segi empat segi; Mengira separuh perimeter dari segi empat yang diberikan; Memohon formula Brahmagupta untuk mendapatkan kawasan maksimum kuadrilateral; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; } int main ( ) { double a = 1 , b = 2 , c = 1 , d = 2 ; printf ( \" % .2f STRNEWLINE \" , maxArea ( a , b , c , d ) ) ; return 0 ; }"}
{"text": "Cari array yang diperolehi selepas menambahkan syarat AP untuk pertanyaan q | Program C untuk pendekatan di atas; Fungsi untuk mencari array selepas melakukan pertanyaan yang diberikan kepada elemen array; Melintasi pertanyaan yang diberikan; Melintasi array yang diberikan; Kemas kini nilai [i]; Mengemas kini nilai curr; Cetak elemen array; Kod pemacu; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE void addAP ( int A [ ] , int Q , int operations [ 2 ] [ 4 ] ) { for ( int j = 0 ; j < 2 ; ++ j ) { int L = operations [ j ] [ 0 ] , R = operations [ j ] [ 1 ] , a = operations [ j ] [ 2 ] , d = operations [ j ] [ 3 ] ; int curr = a ; for ( int i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr ; curr += d ; } } for ( int i = 0 ; i < 4 ; ++ i ) printf ( \" % d ▁ \" , A [ i ] ) ; } int main ( ) { int A [ ] = { 5 , 4 , 2 , 8 } ; int Q = 2 ; int Query [ 2 ] [ 4 ] = { { 1 , 2 , 1 , 3 } , { 1 , 4 , 4 , 1 } } ; addAP ( A , Q , Query ) ; return 0 ; }"}
{"text": "Anggarkan nilai PI menggunakan Monte Carlo | Kaedah Pengkomputeran Selari | Program C untuk pendekatan di atas; Fungsi untuk mencari nilai anggaran PI menggunakan algoritma Monte Carlo; Kedai x dan y koordinat titik rawak; Kedai jarak titik rawak dari asal; Kedai bilangan mata yang terletak di dalam bulatan; Kedai bilangan mata yang terletak di dalam persegi; Pengiraan selari titik rawak yang terletak di dalam bulatan; Memulakan mata rawak dengan benih; Cari Random X Co - Ordinate; Cari Random X Co - Ordinate; Mencari kuadrat jarak titik (x, y) dari asal; Jika d kurang daripada atau sama dengan 1; PCircle kenaikan sebanyak 1; Kenaikan psquare sebanyak 1; Menyimpan nilai anggaran pi; Mencetak nilai dalam pi; Kod pemacu; Input; Panggilan fungsi", "code": "#include <omp.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <time.h> NEW_LINE void monteCarlo ( int N , int K ) { double x , y ; double d ; int pCircle = 0 ; int pSquare = 0 ; int i = 0 ; #pragma  omp parallel firstprivate(x, y, d, i) reduction(+ : pCircle, pSquare) num_threads(K) NEW_LINE { srand48 ( ( int ) time ( NULL ) ) ; for ( i = 0 ; i < N ; i ++ ) { x = ( double ) drand48 ( ) ; y = ( double ) drand48 ( ) ; d = ( ( x * x ) + ( y * y ) ) ; if ( d <= 1 ) { pCircle ++ ; } pSquare ++ ; } } double pi = 4.0 * ( ( double ) pCircle / ( double ) ( pSquare ) ) ; printf ( \" Final ▁ Estimation ▁ of ▁ Pi ▁ = ▁ % f STRNEWLINE \" , pi ) ; } int main ( ) { int N = 100000 ; int K = 8 ; monteCarlo ( N , K ) ; }"}
{"text": "Kaedah yang cekap untuk menyimpan matriks segi tiga yang lebih rendah menggunakan baris | Program C untuk pendekatan di atas; Dimensi matriks; Struktur matriks yang cekap; Fungsi untuk menetapkan nilai dalam matriks; Berfungsi untuk menyimpan nilai dalam matriks; Berfungsi untuk memaparkan unsur -unsur matriks; Melintasi matriks; Berfungsi untuk menghasilkan matriks yang cekap; Mengisytiharkan matriks yang cekap; Memulakan matriks; Tetapkan nilai dalam matriks; Mengembalikan matriks; Kod pemacu; Menyimpan matriks yang cekap; Cetak matriks", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE const int N = 5 ; struct Matrix { int * A ; int size ; } ; void Set ( struct Matrix * mat , int i , int j , int x ) { if ( i >= j ) mat -> A [ i * ( i - 1 ) / 2 + j - 1 ] = x ; } int Get ( struct Matrix mat , int i , int j ) { if ( i >= j ) { return mat . A [ i * ( i - 1 ) / 2 + j - 1 ] ; } else { return 0 ; } } void Display ( struct Matrix mat ) { int i , j ; for ( i = 1 ; i <= mat . size ; i ++ ) { for ( j = 1 ; j <= mat . size ; j ++ ) { if ( i >= j ) { printf ( \" % d ▁ \" , mat . A [ i * ( i - 1 ) / 2 + j - 1 ] ) ; } else { printf ( \"0 ▁ \" ) ; } } printf ( \" STRNEWLINE \" ) ; } } struct Matrix createMat ( int Mat [ N ] [ N ] ) { struct Matrix mat ; mat . size = N ; mat . A = ( int * ) malloc ( mat . size * ( mat . size + 1 ) / 2 * sizeof ( int ) ) ; int i , j ; for ( i = 1 ; i <= mat . size ; i ++ ) { for ( j = 1 ; j <= mat . size ; j ++ ) { Set ( & mat , i , j , Mat [ i - 1 ] [ j - 1 ] ) ; } } return mat ; } int main ( ) { int Mat [ 5 ] [ 5 ] = { { 1 , 0 , 0 , 0 , 0 } , { 1 , 2 , 0 , 0 , 0 } , { 1 , 2 , 3 , 0 , 0 } , { 1 , 2 , 3 , 4 , 0 } , { 1 , 2 , 3 , 4 , 5 } } ; struct Matrix mat = createMat ( Mat ) ; Display ( mat ) ; return 0 ; }"}
{"text": "Pengendali modulo ( %) dalam c / c ++ dengan contoh | Program untuk menggambarkan kerja pengendali Modulo; Untuk menyimpan dua nilai integer; Untuk menyimpan hasil ungkapan modulo", "code": "#include <stdio.h> NEW_LINE int main ( void ) { int x , y ; int result ; x = -3 ; y = 4 ; result = x % y ; printf ( \" % d \" , result ) ; x = 4 ; y = -2 ; result = x % y ; printf ( \" % d \" , result ) ; x = -3 ; y = -4 ; result = x % y ; printf ( \" % d \" , result ) ; return 0 ; }"}
{"text": "Program untuk mengira log A ke mana -mana asas b (logb a) | Program c untuk mencari log (a) pada mana -mana asas B; Kod pemacu", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE int log_a_to_base_b ( int a , int b ) { return log ( a ) / log ( b ) ; } int main ( ) { int a = 3 ; int b = 2 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; a = 256 ; b = 4 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; return 0 ; }"}
{"text": "Program untuk mengira log A ke mana -mana asas b (logb a) | Program C untuk mencari log (a) pada mana -mana asas B menggunakan rekursi; Fungsi rekursif untuk mengira log A ke asas B; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int log_a_to_base_b ( int a , int b ) { return ( a > b - 1 ) ? 1 + log_a_to_base_b ( a / b , b ) : 0 ; } int main ( ) { int a = 3 ; int b = 2 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; a = 256 ; b = 4 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; return 0 ; }"}
{"text": "Cari maksimum dan minimum dua nombor menggunakan fungsi mutlak | Program C untuk mencari maksimum dan minimum menggunakan fungsi mutlak; Berfungsi untuk mengembalikan maksimum di antara kedua -dua nombor; Berfungsi untuk mengembalikan minimum di antara kedua -dua nombor; Kod pemacu; Memaparkan nilai maksimum; Memaparkan nilai minimum", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int maximum ( int x , int y ) { return ( ( x + y + abs ( x - y ) ) / 2 ) ; } int minimum ( int x , int y ) { return ( ( x + y - abs ( x - y ) ) / 2 ) ; } void main ( ) { int x = 99 , y = 18 ; printf ( \" Maximum : ▁ % d STRNEWLINE \" , maximum ( x , y ) ) ; printf ( \" Minimum : ▁ % d STRNEWLINE \" , minimum ( x , y ) ) ; }"}
{"text": "Program untuk mengira e ^ x dengan rekursi (menggunakan siri Taylor) | C pelaksanaan pendekatan; Fungsi rekursif dengan pembolehubah statik p dan f; Keadaan penamatan; Panggilan rekursif; Kemas kini kuasa x; Faktorial; Kod pemacu", "code": "#include <stdio.h> NEW_LINE double e ( int x , int n ) { static double p = 1 , f = 1 ; double r ; if ( n == 0 ) return 1 ; r = e ( x , n - 1 ) ; p = p * x ; f = f * n ; return ( r + p / f ) ; } int main ( ) { int x = 4 , n = 15 ; printf ( \" % lf ▁ STRNEWLINE \" , e ( x , n ) ) ; return 0 ; }"}
{"text": "Algoritma Lukisan Ellipse Midpoint | Program C untuk melaksanakan algoritma lukisan elips MID - Point; Parameter keputusan awal Wilayah 1; Untuk Wilayah 1; Titik cetak berdasarkan simetri 4 - cara; Memeriksa dan mengemas kini nilai parameter keputusan berdasarkan algoritma; Parameter keputusan Wilayah 2; Merancang titik rantau 2; titik percetakan berdasarkan simetri 4 - cara; Memeriksa dan mengemas kini nilai parameter berdasarkan algoritma; Kod pemacu; Untuk menarik elips jejari utama dan kecil 15, 10 berpusat pada (50, 50)", "code": "#include <stdio.h> NEW_LINE void midptellipse ( int rx , int ry , int xc , int yc ) { float dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ; d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25 * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ; while ( dx < dy ) { printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , x + xc , y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , - x + xc , y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , x + xc , - y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , - x + xc , - y + yc ) ; if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } } d2 = ( ( ry * ry ) * ( ( x + 0.5 ) * ( x + 0.5 ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ; while ( y >= 0 ) { printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , x + xc , y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , - x + xc , y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , x + xc , - y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , - x + xc , - y + yc ) ; if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } } int main ( ) { midptellipse ( 10 , 15 , 50 , 50 ) ; return 0 ; }"}
{"text": "Program untuk menukar nombor heksadesimal kepada binari | C program untuk menukar nombor heksadesimal kepada binari; berfungsi untuk menukar heksadesimal kepada nombor binari; kod pemacu; Dapatkan nombor heksadesimal; Menukar heksadesimal ke binari", "code": "#include <stdio.h> NEW_LINE void HexToBin ( char * hexdec ) { long int i = 0 ; while ( hexdec [ i ] ) { switch ( hexdec [ i ] ) { case '0' : printf ( \"0000\" ) ; break ; case '1' : printf ( \"0001\" ) ; break ; case '2' : printf ( \"0010\" ) ; break ; case '3' : printf ( \"0011\" ) ; break ; case '4' : printf ( \"0100\" ) ; break ; case '5' : printf ( \"0101\" ) ; break ; case '6' : printf ( \"0110\" ) ; break ; case '7' : printf ( \"0111\" ) ; break ; case '8' : printf ( \"1000\" ) ; break ; case '9' : printf ( \"1001\" ) ; break ; case ' A ' : case ' a ' : printf ( \"1010\" ) ; break ; case ' B ' : case ' b ' : printf ( \"1011\" ) ; break ; case ' C ' : case ' c ' : printf ( \"1100\" ) ; break ; case ' D ' : case ' d ' : printf ( \"1101\" ) ; break ; case ' E ' : case ' e ' : printf ( \"1110\" ) ; break ; case ' F ' : case ' f ' : printf ( \"1111\" ) ; break ; default : printf ( \" Invalid hexadecimal digit % c \" , hexdec [ i ] ) ; } i ++ ; } } int main ( ) { char hexdec [ 100 ] = \"1AC5\" ; printf ( \" Equivalent Binary value is : \" HexToBin ( hexdec ) ; }"}
{"text": "Cara mengakses unsur -unsur matriks persegi | Program C untuk membaca matriks persegi dan mencetak unsur -unsur di pepenjuru sekunder; Dapatkan matriks persegi; Paparkan matriks; Cetak elemen pada pepenjuru sekunder; Periksa unsur -unsur di pepenjuru sekunder", "code": "#include <stdio.h> NEW_LINE int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } } printf ( \" The ▁ matrix ▁ is STRNEWLINE \" ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { printf ( \" % d TABSYMBOL \" , matrix [ row_index ] [ column_index ] ) ; } printf ( \" STRNEWLINE \" ) ; } printf ( \" Elements on Secondary diagonal : \" for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { if ( ( row_index + column_index ) == size - 1 ) printf ( \" % d , ▁ \" , matrix [ row_index ] [ column_index ] ) ; } } return 0 ; }"}
{"text": "Cara mengakses unsur -unsur matriks persegi | C program untuk membaca matriks persegi dan mencetak unsur -unsur di atas pepenjuru sekunder; Dapatkan matriks persegi; Paparkan matriks; Cetak unsur -unsur di atas pepenjuru sekunder; Periksa unsur -unsur di atas pepenjuru sekunder", "code": "#include <stdio.h> NEW_LINE int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } } printf ( \" The ▁ matrix ▁ is STRNEWLINE \" ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { printf ( \" % d TABSYMBOL \" , matrix [ row_index ] [ column_index ] ) ; } printf ( \" STRNEWLINE \" ) ; } printf ( \" Elements above Secondary diagonal are : \" for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { if ( ( row_index + column_index ) < size - 1 ) printf ( \" % d , ▁ \" , matrix [ row_index ] [ column_index ] ) ; } } return 0 ; }"}
{"text": "Cara mengakses unsur -unsur matriks persegi | Program C untuk membaca matriks persegi dan mencetak elemen sudut; Dapatkan matriks persegi; Paparkan matriks; Cetak elemen sudut; Periksa elemen sudut", "code": "#include <stdio.h> NEW_LINE int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } } printf ( \" The ▁ matrix ▁ is STRNEWLINE \" ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { printf ( \" % d TABSYMBOL \" , matrix [ row_index ] [ column_index ] ) ; } printf ( \" STRNEWLINE \" ) ; } printf ( \" Corner Elements are : \" for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { if ( ( row_index == 0 row_index == size - 1 ) && ( column_index == 0 column_index == size - 1 ) ) printf ( \" % d , ▁ \" , matrix [ row_index ] [ column_index ] ) ; } } return 0 ; }"}
{"text": "Program untuk mengira jarak antara dua mata dalam 3 D | Program C untuk mencari jarak antara dua mata dalam 3 d. ; berfungsi untuk mencetak jarak; Kod pemacu; fungsi panggilan untuk jarak", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float d = sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) + pow ( z2 - z1 , 2 ) * 1.0 ) ; printf ( \" Distance ▁ is ▁ % f \" , d ) ; return ; } int main ( ) { float x1 = 2 ; float y1 = -5 ; float z1 = 7 ; float x2 = 3 ; float y2 = 4 ; float z2 = 5 ; distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ; return 0 ; }"}
{"text": "Cari pasangan yang unik supaya setiap elemen kurang daripada atau sama dengan n | Program C untuk mencari pasangan yang diperlukan; Mencari bilangan pasangan yang unik; Menggunakan formula yang diperolehi; Mencetak pasangan yang unik; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int No_Of_Pairs ( int N ) { int i = 1 ; while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) i ++ ; return ( i - 1 ) ; } void print_pairs ( int pairs ) { int i = 1 , mul ; for ( i = 1 ; i <= pairs ; i ++ ) { mul = i * ( i + 1 ) ; printf ( \" Pair ▁ no . ▁ % d ▁ - - > ▁ ( % d , ▁ % d ) STRNEWLINE \" , i , ( mul * i ) , mul * ( i + 1 ) ) ; } } int main ( ) { int N = 500 , pairs , mul , i = 1 ; pairs = No_Of_Pairs ( N ) ; printf ( \" No . ▁ of ▁ pairs ▁ = ▁ % d ▁ STRNEWLINE \" , pairs ) ; print_pairs ( pairs ) ; return 0 ; }"}
{"text": "Bahagikan sejumlah besar ke dalam dua bahagian yang berbeza dengan k | Program C untuk membahagikan nombor besar ke dalam dua bahagian; Fungsi untuk menambah dua nombor yang diwakili sebagai pelbagai watak. ; panjang rentetan; memulakan kedudukan watak tambahan kepada 0; Menambah setiap elemen watak dan menyimpan bawa. ; Jika sisa kekal. ; Fungsi untuk menolak dua nombor yang diwakili oleh rentetan. ; Mencari panjang rentetan. ; memulakan kedudukan watak tambahan kepada 0 .; Substrat setiap elemen watak. ; Fungsi membahagikan nombor yang diwakili oleh array karakter yang tetap. ; Membahagikan setiap elemen aksara dengan tetap. ; Fungsi untuk membalikkan array watak. ; Membalikkan array. ; Fungsi pembalut; Membalikkan array watak. ; Menambah setiap elemen kedua -dua array dan menyimpan jumlah dalam array a []. ; Membahagikan array a [] oleh 2 .; Membalikkan array watak untuk mendapatkan output. ; Substrak setiap elemen array i. e mengira a = a - b; Membalikkan array watak untuk mendapatkan output. ; Program yang didorong", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define MAX  100 NEW_LINE void add ( char v1 [ ] , char v2 [ ] ) { int i , d , c = 0 ; int l1 = strlen ( v1 ) ; int l2 = strlen ( v2 ) ; for ( i = l1 ; i < l2 ; i ++ ) v1 [ i ] = '0' ; for ( i = l2 ; i < l1 ; i ++ ) v2 [ i ] = '0' ; for ( i = 0 ; i < l1 i < l2 ; i ++ ) { d = ( v1 [ i ] - '0' ) + ( v2 [ i ] - '0' ) + c ; c = d / 10 ; d %= 10 ; v1 [ i ] = '0' + d ; } while ( c ) { v1 [ i ] = '0' + ( c % 10 ) ; c /= 10 ; i ++ ; } v1 [ i ] = ' \\0' ; v2 [ l2 ] = ' \\0' ; } void subs ( char v1 [ ] , char v2 [ ] ) { int i , d , c = 0 ; int l1 = strlen ( v1 ) ; int l2 = strlen ( v2 ) ; for ( i = l2 ; i < l1 ; i ++ ) v2 [ i ] = '0' ; for ( i = 0 ; i < l1 ; i ++ ) { d = ( v1 [ i ] - '0' - c ) - ( v2 [ i ] - '0' ) ; if ( d < 0 ) { d += 10 ; c = 1 ; } else c = 0 ; v1 [ i ] = '0' + d ; } v2 [ l2 ] = ' \\0' ; i = l1 - 1 ; while ( i > 0 && v1 [ i ] == '0' ) i -- ; v1 [ i + 1 ] = ' \\0' ; } int divi ( char v [ ] , int q ) { int i , l = strlen ( v ) ; int c = 0 , d ; for ( i = l - 1 ; i >= 0 ; i -- ) { d = c * 10 + ( v [ i ] - '0' ) ; c = d % q ; d /= q ; v [ i ] = '0' + d ; } i = l - 1 ; while ( i > 0 && v [ i ] == '0' ) i -- ; v [ i + 1 ] = ' \\0' ; return c ; } void rev ( char v [ ] ) { int l = strlen ( v ) ; int i ; char cc ; for ( i = 0 ; i < l - 1 - i ; i ++ ) { cc = v [ i ] ; v [ i ] = v [ l - 1 - i ] ; v [ l - i - 1 ] = cc ; } } void divideWithDiffK ( char a [ ] , char k [ ] ) { rev ( a ) ; rev ( k ) ; add ( a , k ) ; divi ( a , 2 ) ; rev ( a ) ; printf ( \" % s ▁ \" , a ) ; rev ( a ) ; subs ( a , k ) ; rev ( a ) ; printf ( \" % s \" , a ) ; } int main ( ) { char a [ MAX ] = \"100\" , k [ MAX ] = \"20\" ; divideWithDiffK ( a , k ) ; return 0 ; }"}
{"text": "Kawasan persegi dari panjang pepenjuru | Program C untuk mencari kawasan persegi apabila pepenjuru diberikan. ; Mengembalikan kawasan persegi dari pepenjuru yang diberikan; Fungsi pemacu.", "code": "#include <stdio.h> NEW_LINE double findArea ( double d ) { return ( d * d ) / 2 ; } int main ( ) { double d = 10 ; printf ( \" % .2f \" , findArea ( d ) ) ; return 0 ; }"}
{"text": "Purata Squares of Natural Number | C program untuk mengira 1 ^ 2 + 2 ^ 2 + 3 ^ 2 + ... purata nombor persegi; Berfungsi untuk mengira purata nombor persegi; Kod pemacu", "code": "#include <stdio.h> NEW_LINE float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; } int main ( ) { int n = 2 ; printf ( \" % f \" , AvgofSquareN ( n ) ) ; return 0 ; }"}
{"text": "Program untuk mendapatkan jumlah siri: 1 | Program C untuk mendapatkan jumlah siri; Fungsi untuk mendapatkan siri; Jumlah n - 1 istilah bermula dari tempoh 2 nd; Kod pemacu", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE double Series ( double x , int n ) { double sum = 1 , term = 1 , fct , j , y = 2 , m ; int i ; for ( i = 1 ; i < n ; i ++ ) { fct = 1 ; for ( j = 1 ; j <= y ; j ++ ) { fct = fct * j ; } term = term * ( -1 ) ; m = term * pow ( x , y ) / fct ; sum = sum + m ; y += 2 ; } return sum ; } int main ( ) { double x = 9 ; int n = 10 ; printf ( \" % .4f \" , Series ( x , n ) ) ; return 0 ; }"}
{"text": "Cari faktor utama terbesar nombor | Program C untuk mencari faktor utama terbesar; Fungsi untuk mencari faktor utama terbesar; Memulakan pemboleh ubah faktor utama maksimum dengan yang paling rendah; Cetak bilangan 2 s yang membahagikan n; n >> = 1; bersamaan dengan n /= 2; n mesti ganjil pada ketika ini; Sekarang kita perlu melangkah hanya untuk bilangan bulat yang tidak mempunyai Faktor Perdana 2 dan 3; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor perdana yang lebih besar daripada 4; Program pemacu untuk menguji fungsi di atas", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE long long maxPrimeFactors ( long long n ) { long long maxPrime = -1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; } while ( n % 3 == 0 ) { maxPrime = 3 ; n = n / 3 ; } for ( int i = 5 ; i <= sqrt ( n ) ; i += 6 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } while ( n % ( i + 2 ) == 0 ) { maxPrime = i + 2 ; n = n / ( i + 2 ) ; } } if ( n > 4 ) maxPrime = n ; return maxPrime ; } int main ( ) { long long n = 15 ; printf ( \" % lld STRNEWLINE \" , maxPrimeFactors ( n ) ) ; n = 25698751364526 ; printf ( \" % lld \" , maxPrimeFactors ( n ) ) ; return 0 ; }"}
{"text": "Jumlah siri 1 + x / 1 + x ^ 2/2 + x ^ 3/3 +. . + x ^ n / n | C Program untuk mencari jumlah siri 1 + x ^ 2/2 + x ^ 3/3 + .... + x ^ n / n; C kod untuk mencetak jumlah siri; Kod pemacu", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; } int main ( ) { int x = 2 ; int n = 5 ; printf ( \" % .2f \" , sum ( x , n ) ) ; return 0 ; }"}
{"text": "Nombor Chiliagon | Program C untuk pendekatan di atas; Mencari nombor Chiliagon nth; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd ▁ chiliagon ▁ Number ▁ is ▁ = ▁ % d \" , chiliagonNum ( n ) ) ; return 0 ; }"}
{"text": "Nombor Pentacontagon | Program C untuk pendekatan di atas; Mencari nombor pentacontagon nth; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd ▁ pentacontagon ▁ Number ▁ is ▁ = ▁ % d \" , pentacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Nilai array dengan berulang kali menggantikan elemen max 2 dengan perbezaan mutlak mereka | Program C ++ untuk mencari nilai array dengan berulang kali menggantikan elemen Max 2 dengan perbezaan mutlak mereka; fungsi yang mengembalikan nilai terakhir array; Bina max_heap binari. ; Untuk elemen Max 2; Berulang sehingga giliran tidak kosong; Jika hanya 1 elemen yang tersisa; mengembalikan nilai yang terakhir; Periksa perbezaan itu bukan sifar; akhirnya kembali 0; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int lastElement ( vector < int > & arr ) { priority_queue < int > pq ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { pq . push ( arr [ i ] ) ; } int m1 , m2 ; while ( ! pq . empty ( ) ) { if ( pq . size ( ) == 1 ) return pq . top ( ) ; m1 = pq . top ( ) ; pq . pop ( ) ; m2 = pq . top ( ) ; pq . pop ( ) ; if ( m1 != m2 ) pq . push ( m1 - m2 ) ; } return 0 ; } int main ( ) { vector < int > arr = { 2 , 7 , 4 , 1 , 8 , 1 , 1 } ; cout << lastElement ( arr ) << endl ; return 0 ; }"}
{"text": "Trik Logaritma untuk Pengaturcaraan Kompetitif | C Pelaksanaan mengira bilangan digit dalam nombor; Berfungsi untuk mengira bilangan digit dalam nombor; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE int countDigit ( long long n ) { return ( floor ( log10 ( n ) + 1 ) ) ; } int main ( ) { double N = 80 ; printf ( \" % d \" , countDigit ( N ) ) ; return 0 ; }"}
{"text": "Program untuk mencari jumlah siri 1 + x + x ^ 2 + x ^ 3 +. . + x ^ n | C Pelaksanaan untuk mencari jumlah siri 1 + x ^ 2 + x ^ 3 + .... + x ^ n; Berfungsi untuk mencetak jumlah siri; Istilah siri pertama; Gelung untuk mencari terma n siri; Kod pemacu", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; printf ( \"1 ▁ \" ) ; for ( i = 1 ; i < n ; i ++ ) { total = total + multi ; printf ( \" % .1f ▁ \" , multi ) ; multi = multi * x ; } printf ( \" STRNEWLINE \" ) ; return total ; } int main ( ) { int x = 2 ; int n = 5 ; printf ( \" % .2f \" , sum ( x , n ) ) ; return 0 ; }"}
{"text": "Cari selebihnya apabila n dibahagikan dengan 4 menggunakan bitwise dan pengendali | C pelaksanaan untuk mencari N Modulo 4 menggunakan bitwise dan pengendali; Berfungsi untuk mencari selebihnya; Bitwise dan dengan 3; kembali x; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int findRemainder ( int n ) { int x = n & 3 ; return x ; } int main ( ) { int N = 43 ; int ans = findRemainder ( N ) ; printf ( \" % d \" , ans ) ; return 0 ; }"}
{"text": "Program untuk mencetak siri nombor segitiga sehingga n | C program untuk mencari siri nombor segi tiga; Berfungsi untuk mencari nombor segi tiga; Untuk setiap lelaran meningkat j sebanyak 1 dan masukkannya ke k; Meningkat j oleh 1; Tambah nilai j ke k dan kemas kini k; Fungsi yang didorong", "code": "#include <stdio.h> NEW_LINE void triangular_series ( int n ) { int i , j = 1 , k = 1 ; for ( i = 1 ; i <= n ; i ++ ) { printf ( \" ▁ % d ▁ \" , k ) ; j = j + 1 ; k = k + j ; } } int main ( ) { int n = 5 ; triangular_series ( n ) ; return 0 ; }"}
{"text": "Program untuk mengira digit dalam integer (4 kaedah yang berbeza) | Program C rekursif untuk mengira bilangan digit dalam nombor; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int countDigit ( long long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; } int main ( void ) { long long n = 345289467 ; printf ( \" Number ▁ of ▁ digits ▁ : ▁ % d \" , countDigit ( n ) ) ; return 0 ; }"}
{"text": "Semak jika nombor adalah sihir (jumlah digit rekursif ialah 1) | Program C Untuk memeriksa sama ada nombor itu adalah sihir atau tidak. ; Menerima input sampel; Keadaan untuk memeriksa nombor sihir", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 1234 ; if ( x % 9 == 1 ) printf ( \" Magic ▁ Number \" ) ; else printf ( \" Not ▁ a ▁ Magic ▁ Number \" ) ; return 0 ; }"}
{"text": "Fakta menarik mengenai nombor Fibonacci | Program C Untuk menunjukkan bahawa nombor Fibonacci yang boleh dibahagikan dengan indeks mereka mempunyai indeks sebagai kuasa 5 atau berganda 12 .; Menyimpan nombor Fibonacci", "code": "#include <stdio.h> NEW_LINE #define MAX  100 NEW_LINE int main ( ) { long long int arr [ MAX ] ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] ; printf ( \" Fibonacci ▁ numbers ▁ divisible ▁ by ▁ \" \" their ▁ indexes ▁ are ▁ : STRNEWLINE \" ) ; for ( int i = 1 ; i < MAX ; i ++ ) if ( arr [ i ] % i == 0 ) printf ( \" % d ▁ \" , i ) ; }"}
{"text": "Nilai maksimum integer yang faktorial boleh dikira pada mesin | Program C untuk mencari nilai maksimum integer yang faktorial boleh dikira pada sistem anda; Apabila fakta melintasi saiznya, ia memberikan nilai negatif; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int findMaxValue ( ) { int res = 2 ; long long int fact = 2 ; while ( 1 ) { if ( fact < 0 ) break ; res ++ ; fact = fact * res ; } return res - 1 ; } int main ( ) { printf ( \" Maximum ▁ value ▁ of ▁ integer ▁ : ▁ % d STRNEWLINE \" , findMaxValue ( ) ) ; return 0 ; }"}
{"text": "Memandangkan nombor n, cari digit k pertama n ^ n | C ++ program untuk menjana digit pertama n ^ n; fungsi untuk mengira digit pertama n ^ n; Ambil log10 n ^ n. log10 (n ^ n) = n * log10 (n); Kami kini cuba memisahkan bahagian perpuluhan dan integral dari / produk. Fungsi lantai mengembalikan integer terkecil kurang daripada atau sama dengan hujah. Oleh itu, dalam kes ini, lantai produk (produk) akan memberi kita bahagian perpuluhan produk; Kami kini mengeksplorasi ini dengan menaikkan 10 ke dalam kuasa perpuluhan; Kami kini cuba mencari kuasa 10 yang mana kita perlu membiak bahagian perpuluhan untuk mendapatkan jawapan terakhir kami; fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long firstkdigits ( int n , int k ) { long double product = n * log10 ( n ) ; long double decimal_part = product - floor ( product ) ; decimal_part = pow ( 10 , decimal_part ) ; long long digits = pow ( 10 , k - 1 ) , i = 0 ; return decimal_part * digits ; } int main ( ) { int n = 1450 ; int k = 6 ; cout << firstkdigits ( n , k ) ; return 0 ; }"}
{"text": "Multiply integer besar di bawah modulo besar | C Program mencari pendaraban modulo; Pulangan (a * b) % mod; Kemas kini A jika lebih daripada atau sama dengan MOD; Jika B adalah ganjil, tambahkan dengan hasil; Di sini kita mengandaikan bahawa melakukan 2 * A tidak menyebabkan limpahan; b >> = 1; B = B / 2; Program Pemandu", "code": "#include <stdio.h> NEW_LINE long long moduloMultiplication ( long long a , long long b , long long mod ) { a %= mod ; while ( b ) { if ( b & 1 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; } return res ; } int main ( ) { long long a = 10123465234878998 ; long long b = 65746311545646431 ; long long m = 10005412336548794 ; printf ( \" % lld \" , moduloMultiplication ( a , b , m ) ) ; return 0 ; }"}
{"text": "Semak jika nombor boleh dinyatakan sebagai jumlah nombor berturut -turut |  ; Mengemas kini n dengan 2 n; (n & (n - 1)) => Memeriksa sama ada kita boleh menulis 2 n sebagai 2^k jika ya (tidak boleh mewakili 2n sebagai 2^k) maka jawab 1 jika tidak (boleh mewakili 2n sebagai 2^k) kemudian jawab 0", "code": "#include <stdio.h> NEW_LINE long long int canBeSumofConsec ( long long int n ) { n = 2 * n ; return ( ( n & ( n - 1 ) ) != 0 ) ; } int main ( ) { long long int n = 10 ; printf ( \" % lld \" , canBeSumofConsec ( n ) ) ; }"}
{"text": "Teori Permainan Gabungan | Tetapkan 2 (Game of Nim) | Program C untuk melaksanakan Game of NIM. Program ini menganggap bahawa kedua -dua pemain bermain secara optimum; Struktur untuk memegang dua parameter langkah bergerak mempunyai dua parameter - 1) pile_index = indeks tumpukan dari mana batu akan dikeluarkan 2) batu_removed = bilangan batu yang dikeluarkan dari longgokan diindeks = pile_index; Fungsi C untuk mengeluarkan keadaan permainan semasa. ; Fungsi C yang kembali benar jika permainan telah berakhir dan palsu jika permainan belum berakhir; Fungsi C untuk mengisytiharkan pemenang permainan; Fungsi C untuk mengira jumlah NIM di mana -mana titik permainan. ; Fungsi C untuk membuat langkah permainan NIM; Pemain yang mempunyai giliran semasa berada pada kedudukan yang menang. Jadi dia / dia bermain secara optimum dan cuba membuat Nim - jumlahnya sebagai 0; Jika ini bukan langkah yang menyalahi undang -undang maka membuat langkah ini. ; Jika anda ingin memasukkan diri anda kemudian keluarkan fungsi rand () dan ubah kod untuk mengambil input. Tetapi ingat, anda masih tidak dapat mengubah nasib/ramalan anda. ; Buat array untuk memegang indeks buasir bukan kosong; Fungsi C untuk memainkan permainan NIM; Program pemacu untuk menguji fungsi di atas; Kes ujian 1; Kami akan meramalkan keputusan sebelum bermain komputer bermula dahulu; Marilah kita bermain permainan dengan komputer bermula dahulu dan periksa sama ada ramalan kita betul atau tidak; Kes ujian 2 Int Piles [] = {3, 4, 7}; int n = sizeof (buasir) / sizeof (buasir [0]); Kami akan meramalkan keputusan sebelum bermain manusia (anda) bermula dahulu; Marilah kita bermain permainan dengan komputer bermula dahulu dan periksa sama ada ramalan kita betul atau tidak Playgame (Piles, N, Manusia);", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE #define COMPUTER  1 NEW_LINE #define HUMAN  2 NEW_LINE struct move { int pile_index ; int stones_removed ; } ; void showPiles ( int piles [ ] , int n ) { int i ; printf ( \" Current ▁ Game ▁ Status ▁ - > ▁ \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , piles [ i ] ) ; printf ( \" STRNEWLINE \" ) ; return ; } bool gameOver ( int piles [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( piles [ i ] != 0 ) return ( false ) ; return ( true ) ; } void declareWinner ( int whoseTurn ) { if ( whoseTurn == COMPUTER ) printf ( \" HUMAN won \" else printf ( \" COMPUTER won \" return ; } int calculateNimSum ( int piles [ ] , int n ) { int i , nimsum = piles [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) nimsum = nimsum ^ piles [ i ] ; return ( nimsum ) ; } void makeMove ( int piles [ ] , int n , struct move * moves ) { int i , nim_sum = calculateNimSum ( piles , n ) ; if ( nim_sum != 0 ) { for ( i = 0 ; i < n ; i ++ ) { if ( ( piles [ i ] ^ nim_sum ) < piles [ i ] ) { ( * moves ) . pile_index = i ; ( * moves ) . stones_removed = piles [ i ] - ( piles [ i ] ^ nim_sum ) ; piles [ i ] = ( piles [ i ] ^ nim_sum ) ; break ; } } } else { int non_zero_indices [ n ] , count ; for ( i = 0 , count = 0 ; i < n ; i ++ ) if ( piles [ i ] > 0 ) non_zero_indices [ count ++ ] = i ; ( * moves ) . pile_index = ( rand ( ) % ( count ) ) ; ( * moves ) . stones_removed = 1 + ( rand ( ) % ( piles [ ( * moves ) . pile_index ] ) ) ; piles [ ( * moves ) . pile_index ] = piles [ ( * moves ) . pile_index ] - ( * moves ) . stones_removed ; if ( piles [ ( * moves ) . pile_index ] < 0 ) piles [ ( * moves ) . pile_index ] = 0 ; } return ; } void playGame ( int piles [ ] , int n , int whoseTurn ) { printf ( \" GAME STARTS \" struct move moves ; while ( gameOver ( piles , n ) == false ) { showPiles ( piles , n ) ; makeMove ( piles , n , & moves ) ; if ( whoseTurn == COMPUTER ) { printf ( \" COMPUTER ▁ removes ▁ % d ▁ stones ▁ from ▁ pile ▁ \" \" at ▁ index ▁ % d STRNEWLINE \" , moves . stones_removed , moves . pile_index ) ; whoseTurn = HUMAN ; } else { printf ( \" HUMAN ▁ removes ▁ % d ▁ stones ▁ from ▁ pile ▁ at ▁ \" \" index ▁ % d STRNEWLINE \" , moves . stones_removed , moves . pile_index ) ; whoseTurn = COMPUTER ; } } showPiles ( piles , n ) ; declareWinner ( whoseTurn ) ; return ; } void knowWinnerBeforePlaying ( int piles [ ] , int n , int whoseTurn ) { printf ( \" Prediction ▁ before ▁ playing ▁ the ▁ game ▁ - > ▁ \" ) ; if ( calculateNimSum ( piles , n ) != 0 ) { if ( whoseTurn == COMPUTER ) printf ( \" COMPUTER ▁ will ▁ win STRNEWLINE \" ) ; else printf ( \" HUMAN ▁ will ▁ win STRNEWLINE \" ) ; } else { if ( whoseTurn == COMPUTER ) printf ( \" HUMAN ▁ will ▁ win STRNEWLINE \" ) ; else printf ( \" COMPUTER ▁ will ▁ win STRNEWLINE \" ) ; } return ; } int main ( ) { int piles [ ] = { 3 , 4 , 5 } ; int n = sizeof ( piles ) / sizeof ( piles [ 0 ] ) ; knowWinnerBeforePlaying ( piles , n , COMPUTER ) ; playGame ( piles , n , COMPUTER ) ; knowWinnerBeforePlaying ( piles , n , COMPUTER ) ; return ( 0 ) ; }"}
{"text": "Program untuk mencari akar persamaan kuadrat | Program C untuk mencari akar persamaan kuadrat; Cetak akar persamaan kuadratik kapak * 2 + bx + x; Jika A adalah 0, maka persamaan tidak kuadratik, tetapi linear; lain d <0; Kod pemacu; Panggilan fungsi", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void findRoots ( int a , int b , int c ) { if ( a == 0 ) { printf ( \" Invalid \" ) ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { printf ( \" Roots ▁ are ▁ real ▁ and ▁ different ▁ STRNEWLINE \" ) ; printf ( \" % f % f \" , ( double ) ( - b + sqrt_val ) / ( 2 * a ) , ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ; } else if ( d == 0 ) { printf ( \" Roots ▁ are ▁ real ▁ and ▁ same ▁ STRNEWLINE \" ) ; printf ( \" % f \" , - ( double ) b / ( 2 * a ) ) ; } { printf ( \" Roots ▁ are ▁ complex ▁ STRNEWLINE \" ) ; printf ( \" % f ▁ + ▁ i % f % f - i % f \" , - ( double ) b / ( 2 * a ) , sqrt_val / ( 2 * a ) , - ( double ) b / ( 2 * a ) , sqrt_val / ( 2 * a ) ; } } int main ( ) { int a = 1 , b = -7 , c = 12 ; findRoots ( a , b , c ) ; return 0 ; }"}
{"text": "Tukar dari mana -mana pangkalan ke perpuluhan dan sebaliknya | Program C untuk menukar nombor dari mana -mana pangkalan ke perpuluhan; Untuk mengembalikan nilai char. Sebagai contoh, 2 dikembalikan untuk '2'. 10 dikembalikan untuk 'A', 11 untuk 'B'; Berfungsi untuk menukar nombor dari asas 'b' yang diberikan kepada perpuluhan; Memulakan kuasa asas; Memulakan hasil; Bersamaan perpuluhan adalah str [len - 1] * 1 + str [len - 2] * asas + str [len - 3] * (asas ^ 2) + ...; Digit dalam nombor input mestilah kurang daripada asas nombor; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; } int toDeci ( char * str , int base ) { int len = strlen ( str ) ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { printf ( \" Invalid ▁ Number \" ) ; return -1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; } int main ( ) { char str [ ] = \"11A \" ; int base = 16 ; printf ( \" Decimal ▁ equivalent ▁ of ▁ % s ▁ in ▁ base ▁ % d ▁ is ▁ \" \" ▁ % d STRNEWLINE \" , str , base , toDeci ( str , base ) ) ; return 0 ; }"}
{"text": "Penyelesaian f (n) = (1) + (2 * 3) + (4 * 5 * 6). . . n Menggunakan rekursi | C Program untuk mencetak penyelesaian siri F (n) = (1) + (2 * 3) + (4 * 5 * 6). . . n menggunakan rekursi; Fungsi rekursif untuk mencari jumlah siri yang dikira - bilangan terma sehingga jumlah terma telah dikira semasa - bilangan istilah yang mana jumlahnya harus dikalkulasi n - bilangan istilah dalam fungsi yang akan dikira; Memeriksa keadaan penamatan; produk terma sehingga semasa; Panggilan rekursif untuk menambahkan istilah seterusnya dalam siri ini; Kod pemacu; nombor input istilah dalam siri ini; memohon fungsi untuk mengira jumlah", "code": "#include <stdio.h> NEW_LINE int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; } int main ( ) { int N = 5 ; printf ( \" % d STRNEWLINE \" , seriesSum ( 1 , 1 , N ) ) ; return 0 ; }"}
{"text": "Fibonacci Coding | Program C untuk pengekodan fibonacci dari integer positif n; Untuk mengehadkan nombor Fibonacci terbesar untuk digunakan; Array untuk menyimpan nombor Fibonacci. FIB [i] akan menyimpan (i + 2) 'Nombor Fibonacci; Nilai menyimpan dalam FIB dan pulangan indeks nombor Fibonacci terbesar lebih kecil daripada n. ; FIB [0] Kedai 2 nd Fibonacci no. ; FIB [1] menyimpan 3 rd Fibonacci no. ; Terus menjana bilangan baki manakala nombor yang dihasilkan sebelum ini lebih kecil; Indeks pulangan nombor Fibonacci terbesar lebih kecil daripada atau sama dengan n. Perhatikan bahawa gelung di atas berhenti apabila FIB [i - 1] menjadi lebih besar. ; Mengembalikan penunjuk ke rentetan char yang sepadan dengan kod untuk n; memperuntukkan memori untuk Codeword; Indeks fibonacci terbesar f <= n; Tandakan penggunaan Fibonacci F (1 bit); Tolak f dari n; Pindah ke Fibonacci hanya lebih kecil daripada F; Tandakan semua fibonacci> n seperti yang tidak digunakan (0 bit), kemajuan ke belakang; tambahan '1' bit; pulangan penunjuk ke Codeword; fungsi pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define N  30 NEW_LINE int fib [ N ] ; int largestFiboLessOrEqual ( int n ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; int i ; for ( i = 2 ; fib [ i - 1 ] <= n ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; return ( i - 2 ) ; } char * fibonacciEncoding ( int n ) { int index = largestFiboLessOrEqual ( n ) ; char * codeword = ( char * ) malloc ( sizeof ( char ) * ( index + 3 ) ) ; int i = index ; while ( n ) { codeword [ i ] = '1' ; n = n - fib [ i ] ; i = i - 1 ; while ( i >= 0 && fib [ i ] > n ) { codeword [ i ] = '0' ; i = i - 1 ; } } codeword [ index + 1 ] = '1' ; codeword [ index + 2 ] = ' \\0' ; return codeword ; } int main ( ) { int n = 143 ; printf ( \" Fibonacci ▁ code ▁ word ▁ for ▁ % d ▁ is ▁ % s STRNEWLINE \" , n , fibonacciEncoding ( n ) ) ; return 0 ; }"}
{"text": "Kira nombor kuadrat dalam segi empat tepat | Program C untuk mengira dataran dalam segi empat tepat saiz m x n; Mengembalikan kiraan semua dataran dalam segi empat tepat saiz m x n; Jika n lebih kecil, swap m dan n; Sekarang n adalah dimensi yang lebih besar, gunakan formula; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; } int main ( ) { int m = 4 , n = 3 ; printf ( \" Count ▁ of ▁ squares ▁ is ▁ % d \" , countSquares ( m , n ) ) ; }"}
{"text": "SIEVE Segmen | Fungsi ini mendapati semua prima yang lebih kecil daripada 'had' menggunakan penapis mudah Eratosthenes. ; Buat array boolean \"Mark [0. Limit - 1]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Mark [P] akhirnya akan palsu jika 'P' bukanlah perdana, yang lain benar. ; Satu demi satu melintasi semua nombor supaya gandaan mereka dapat ditandakan sebagai komposit. ; Jika p tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cetak semua nombor perdana dan simpannya di Perdana", "code": "void simpleSieve ( int limit ) { bool mark [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) { mark [ i ] = true ; } for ( int p = 2 ; p * p < limit ; p ++ ) { if ( mark [ p ] == true ) { for ( int i = p * p ; i < limit ; i += p ) mark [ i ] = false ; } } for ( int p = 2 ; p < limit ; p ++ ) if ( mark [ p ] == true ) cout << p << \" ▁ \" ; }"}
{"text": "Modular Multiplicative Inverse | Program Cerative C untuk mencari songsang modular menggunakan algoritma euclid yang dilanjutkan; Mengembalikan modulo songsang dengan m menggunakan asumsi algoritma euclid yang dilanjutkan: a dan m adalah coprimes, i. e. , GCD (a, m) = 1; Q adalah Quotient; M adalah selebihnya sekarang, proses sama seperti algo Euclid; Kemas kini Y dan X; Buat x positif; Kod pemacu; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m , a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } int main ( ) { int a = 3 , m = 11 ; printf ( \" Modular ▁ multiplicative ▁ inverse ▁ is ▁ % d STRNEWLINE \" , modInverse ( a , m ) ) ; return 0 ; }"}
{"text": "Fungsi Totient Euler | Program C yang mudah untuk mengira fungsi Tatent Euler; Berfungsi untuk mengembalikan GCD A dan B; Kaedah mudah untuk menilai fungsi Euler Totient; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int phi ( unsigned int n ) { unsigned int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; } int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) printf ( \" phi ( % d ) ▁ = ▁ % d STRNEWLINE \" , n , phi ( n ) ) ; return 0 ; }"}
{"text": "Fungsi Totient Euler | Program c untuk mengira fungsi Euler »menggunakan formula produk uuler; Pertimbangkan semua faktor utama n dan untuk setiap faktor utama p, menghasilkan hasil dengan (1 - 1 / p); Semak sama ada P adalah faktor utama. ; Jika ya, kemudian kemas kini n dan hasil; Jika n mempunyai faktor utama yang lebih besar daripada sqrt (n) (boleh ada - kebanyakan faktor utama seperti itu); Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int phi ( int n ) { for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; } int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) printf ( \" phi ( % d ) ▁ = ▁ % d STRNEWLINE \" , n , phi ( n ) ) ; return 0 ; }"}
{"text": "Program untuk mencetak nombor N First N Fibonacci | Tetapkan 1 | Program C untuk mencetak nombor F First n Fibonacci; Berfungsi untuk mencetak nombor F FIBONACCI FIRST; Kod pemacu", "code": "#include <stdio.h> NEW_LINE void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; printf ( \" % d ▁ \" , f1 ) ; for ( i = 1 ; i < n ; i ++ ) { printf ( \" % d ▁ \" , f2 ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } } int main ( ) { printFibonacciNumbers ( 7 ) ; return 0 ; }"}
{"text": "Program untuk mencari LCM dua nombor | C program untuk mencari LCM dua nombor; Fungsi rekursif untuk mengembalikan GCD A dan B; Berfungsi untuk mengembalikan LCM dua nombor; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; } int main ( ) { int a = 15 , b = 20 ; printf ( \" LCM ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , lcm ( a , b ) ) ; return 0 ; }"}
{"text": "Program untuk menukar nombor yang diberikan kepada perkataan | Program C untuk mencetak nombor tertentu dalam kata -kata. Program ini mengendalikan nombor dari 0 hingga 9999; Fungsi yang mencetak nombor yang diberikan dalam kata -kata; Kes asas; Rentetan pertama tidak digunakan, ia adalah untuk membuat pengindeksan array mudah; Rentetan pertama tidak digunakan, ia adalah untuk membuat pengindeksan array mudah; Dua rentetan pertama tidak digunakan, mereka membuat pengindeksan array mudah; Digunakan untuk tujuan debug sahaja; Untuk nombor digit tunggal; Iterate manakala num tidak '\\ 0'; Laluan kod untuk 2 digit pertama; tens_power [len - 3]); Di sini len boleh menjadi 3 atau 4; Laluan kod untuk 2 digit terakhir; Perlu mengendalikan 10 - 19. Jumlah dua digit digunakan sebagai indeks \"dua _ digit\" pelbagai rentetan; Perlu mengendalikan 20; Selebihnya dua nombor digit i. e. , 21 hingga 99; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE void convert_to_words ( char * num ) { int len = strlen ( if ( len == 0 ) { fprintf ( stderr , \" empty ▁ string STRNEWLINE \" ) ; return ; } if ( len > 4 ) { fprintf ( stderr , \" Length ▁ more ▁ than ▁ 4 ▁ is ▁ not ▁ supported STRNEWLINE \" ) ; return ; } char * single_digits [ ] = { \" zero \" , \" one \" , \" two \" , \" three \" , \" four \" , \" five \" , \" six \" , \" seven \" , \" eight \" , \" nine \" } ; char * two_digits [ ] = { \" \" , \" ten \" , \" eleven \" , \" twelve \" , \" thirteen \" , \" fourteen \" , \" fifteen \" , \" sixteen \" , \" seventeen \" , \" eighteen \" , \" nineteen \" } ; char * tens_multiple [ ] = { \" \" , \" \" , \" twenty \" , \" thirty \" , \" forty \" , \" fifty \" , \" sixty \" , \" seventy \" , \" eighty \" , \" ninety \" } ; char * tens_power [ ] = { \" hundred \" , \" thousand \" } ; printf ( \" % s : \" , num ) ; if ( len == 1 ) { printf ( \" % s STRNEWLINE \" , single_digits [ * num - '0' ] ) ; return ; } while ( * num != ' \\0' ) { if ( len >= 3 ) { if ( * num - '0' != 0 ) { printf ( \" % s ▁ \" , single_digits [ * num - '0' ] ) ; printf ( \" % s ▁ \" , } -- len ; } else { if ( * num == '1' ) { int sum = * num - '0' + * ( num + 1 ) - '0' ; printf ( \" % s STRNEWLINE \" , two_digits [ sum ] ) ; return ; } else if ( * num == '2' && * ( num + 1 ) == '0' ) { printf ( \" twenty STRNEWLINE \" ) ; return ; } else { int i = * num - '0' ; printf ( \" % s ▁ \" , i ? tens_multiple [ i ] : \" \" ) ; ++ num ; if ( * num != '0' ) printf ( \" % s ▁ \" , single_digits [ * num - '0' ] ) ; } } ++ num ; } } int main ( void ) { convert_to_words ( \"9923\" ) ; convert_to_words ( \"523\" ) ; convert_to_words ( \"89\" ) ; convert_to_words ( \"8\" ) ; return 0 ; }"}
{"text": "Untuk mencari jumlah dua nombor tanpa menggunakan mana -mana pengendali |  ; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int add ( int x , int y ) { return printf ( \" % * c % * c \" , x , ' ▁ ' , y , ' ▁ ' ) ; } int main ( ) { printf ( \" Sum ▁ = ▁ % d \" , add ( 3 , 4 ) ) ; return 0 ; }"}
{"text": "Semak jika nombor adalah berganda 5 tanpa menggunakan / dan % operator | Dengan mengandaikan bahawa integer mengambil 4 bait, terdapat maksimum 10 digit dalam integer; Semak watak terakhir rentetan; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE # define MAX  11 NEW_LINE bool isMultipleof5 ( int n ) { char str [ MAX ] ; int len = strlen ( str ) ; if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; } int main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) printf ( \" % d ▁ is ▁ multiple ▁ of ▁ 5 STRNEWLINE \" , n ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ multiple ▁ of ▁ 5 STRNEWLINE \" , n ) ; return 0 ; }"}
{"text": "Senarai Linked XOR | Program C untuk melaksanakan pendekatan di atas; Struktur nod dalam senarai berkaitan XOR; Menyimpan nilai data nod; Kedai xor penunjuk sebelumnya dan penunjuk seterusnya; Berfungsi untuk mencari XOR alamat dua nod; Fungsi untuk memasukkan nod dengan nilai yang diberikan pada kedudukan yang diberikan; Jika senarai yang dipautkan XOR kosong; Memulakan nod baru; Menyimpan nilai data dalam nod; Kedai xor penunjuk sebelumnya dan seterusnya; Kemas kini penunjuk nod kepala; Jika senarai berkaitan XOR tidak kosong; Menyimpan alamat nod semasa; Menyimpan alamat nod sebelumnya; Memulakan nod baru; Kemas kini alamat nod curr; Mengemas kini alamat nod baru; Kemas kini kepala; Kemas kini nilai data nod semasa; Berfungsi untuk mencetak unsur -unsur senarai yang dipautkan XOR; Kedai penunjuk XOR dalam nod semasa; Kedai penunjuk xor dalam nod sebelumnya; Kedai penunjuk XOR dalam nod seterusnya; Traverse XOR Linked List; Cetak nod semasa; Ke hadapan traversal; UPDATE PREV; Kemas kini curr; Membalikkan senarai yang dipautkan dalam kumpulan K; Kedai kepala nod; Jika senarai yang dipautkan XOR kosong; Kedai kiraan nod yang dibalikkan dalam kumpulan semasa; Kedai penunjuk xor dalam nod sebelumnya; Kedai penunjuk XOR dalam nod seterusnya; Nod terbalik dalam kumpulan semasa; Ke hadapan traversal; UPDATE PREV; Kemas kini curr; Kiraan kemas kini; Putuskan sambungan node dari nod seterusnya; Putuskan CUR dari nod sebelumnya; Jika kiraan nod yang tinggal kurang daripada k; Mengemas kini len; Memproses secara rekursif nod seterusnya; Sambungkan penunjuk kepala dengan sebelumnya; Sambung dengan kepala; Kod pemacu; Buat Ketua Senarai Berkaitan XOR berikut -> 7 <A> 6 <A> 8 <A> 11 <A> 3 <A> 1 <A> 2 <A> 0; Panggilan fungsi; Cetak senarai terbalik", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * nxp ; } ; struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; } struct Node * insert ( struct Node * * head , int value ) { if ( * head == NULL ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = value ; node -> nxp = XOR ( NULL , NULL ) ; * head = node ; } else { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ; node -> nxp = XOR ( NULL , curr ) ; * head = node ; node -> data = value ; } return * head ; } void printList ( struct Node * * head ) { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * next ; while ( curr != NULL ) { printf ( \" % d ▁ \" , curr -> data ) ; next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; } } struct Node * RevInGrp ( struct Node * * head , int K , int len ) { struct Node * curr = * head ; if ( curr == NULL ) return NULL ; int count = 0 ; struct Node * prev = NULL ; struct Node * next ; while ( count < K && count < len ) { next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; count ++ ; } prev -> nxp = XOR ( NULL , XOR ( prev -> nxp , curr ) ) ; if ( curr != NULL ) curr -> nxp = XOR ( XOR ( curr -> nxp , prev ) , NULL ) ; if ( len < K ) { return prev ; } else { len -= K ; struct Node * dummy = RevInGrp ( & curr , K , len ) ; ( * head ) -> nxp = XOR ( XOR ( NULL , ( * head ) -> nxp ) , dummy ) ; if ( dummy != NULL ) dummy -> nxp = XOR ( XOR ( dummy -> nxp , NULL ) , * head ) ; return prev ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 0 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; insert ( & head , 3 ) ; insert ( & head , 11 ) ; insert ( & head , 8 ) ; insert ( & head , 6 ) ; insert ( & head , 7 ) ; head = RevInGrp ( & head , 3 , 8 ) ; printList ( & head ) ; return ( 0 ) ; }"}
{"text": "Senarai Linked XOR | Program C untuk pendekatan di atas; Struktur nod dalam senarai berkaitan XOR; Menyimpan nilai data nod; Kedai xor penunjuk sebelumnya dan penunjuk seterusnya; Berfungsi untuk mencari XOR dua nod; Berfungsi untuk memasukkan nod dengan nilai yang diberikan pada kedudukan permulaan; Jika senarai yang dipautkan XOR kosong; Memulakan nod baru; Menyimpan nilai data dalam nod; Kedai xor penunjuk sebelumnya dan seterusnya; Kemas kini penunjuk nod kepala; Jika senarai berkaitan XOR tidak kosong; Menyimpan alamat nod semasa; Menyimpan alamat nod sebelumnya; Memulakan nod baru; Kemas kini alamat nod curr; Mengemas kini alamat nod baru; Kemas kini kepala; Kemas kini nilai data nod semasa; Berfungsi untuk mencetak unsur -unsur senarai yang dipautkan XOR; Kedai penunjuk XOR dalam nod semasa; Kedai penunjuk xor dalam nod sebelumnya; Kedai penunjuk XOR dalam nod seterusnya; Traverse XOR Linked List; Cetak nod semasa; Ke hadapan traversal; UPDATE PREV; Kemas kini curr; Berfungsi untuk membalikkan senarai yang dipautkan XOR; Kedai penunjuk XOR dalam nod semasa; Kedai penunjuk xor dalam nod sebelumnya; Kedai penunjuk XOR dalam nod seterusnya; Ke hadapan traversal; UPDATE PREV; Kemas kini curr; Kemas kini penunjuk kepala; Kod pemacu; Buat Ketua Senarai Berkaitan XOR berikut -> 40 <--> 30 <--> 20 <--> 10; Balikkan senarai yang dipautkan XOR untuk memberi kepala -> 10 <--> 20 <--> 30 <--> 40", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * nxp ; } ; struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; } struct Node * insert ( struct Node * * head , int value ) { if ( * head == NULL ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = value ; node -> nxp = XOR ( NULL , NULL ) ; * head = node ; } else { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ; node -> nxp = XOR ( NULL , curr ) ; * head = node ; node -> data = value ; } return * head ; } void printList ( struct Node * * head ) { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * next ; while ( curr != NULL ) { printf ( \" % d ▁ \" , curr -> data ) ; next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; } printf ( \" STRNEWLINE \" ) ; } struct Node * reverse ( struct Node * * head ) { struct Node * curr = * head ; if ( curr == NULL ) return NULL ; else { struct Node * prev = NULL ; struct Node * next ; while ( XOR ( prev , curr -> nxp ) != NULL ) { next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; } * head = curr ; return * head ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 10 ) ; insert ( & head , 20 ) ; insert ( & head , 30 ) ; insert ( & head , 40 ) ; printf ( \" XOR ▁ linked ▁ list : ▁ \" ) ; printList ( & head ) ; reverse ( & head ) ; printf ( \" Reversed ▁ XOR ▁ linked ▁ list : ▁ \" ) ; printList ( & head ) ; return ( 0 ) ; }"}
{"text": "Senarai Linked XOR | Program C untuk melaksanakan pendekatan di atas; Struktur nod dalam senarai berkaitan XOR; Menyimpan nilai data nod; Kedai xor penunjuk sebelumnya dan penunjuk seterusnya; Berfungsi untuk mencari XOR dua nod; Fungsi untuk memasukkan nod dengan nilai yang diberikan pada kedudukan yang diberikan; Jika senarai yang dipautkan XOR kosong; Memulakan nod baru; Menyimpan nilai data dalam nod; Kedai xor penunjuk sebelumnya dan seterusnya; Kemas kini penunjuk nod kepala; Jika senarai berkaitan XOR tidak kosong; Menyimpan alamat nod semasa; Menyimpan alamat nod sebelumnya; Memulakan nod baru; Kemas kini alamat nod curr; Mengemas kini alamat nod baru; Kemas kini kepala; Kemas kini nilai data nod semasa; Berfungsi untuk mencetak unsur -unsur senarai yang dipautkan XOR; Kedai penunjuk XOR dalam nod semasa; Kedai penunjuk xor dalam nod sebelumnya; Kedai penunjuk XOR dalam nod seterusnya; Traverse XOR Linked List; Cetak nod semasa; Ke hadapan traversal; UPDATE PREV; Kemas kini curr; Kedai penunjuk XOR dalam nod semasa; Kedai penunjuk xor dalam nod sebelumnya; Kedai penunjuk XOR dalam nod seterusnya; Ke hadapan traversal; UPDATE PREV; Kemas kini curr; Ke hadapan traversal; UPDATE PREV; Kemas kini curr; Kod pemacu; Buat kepala senarai terpaut XOR berikut -> 7 a> 6 a> 8 a> 11 a> 3 a> 1 a> 2 a> 0", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * nxp ; } ; struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; } struct Node * insert ( struct Node * * head , int value ) { if ( * head == NULL ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = value ; node -> nxp = XOR ( NULL , NULL ) ; * head = node ; } else { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ; node -> nxp = XOR ( NULL , curr ) ; * head = node ; node -> data = value ; } return * head ; } void printList ( struct Node * * head ) { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * next ; while ( curr != NULL ) { printf ( \" % d ▁ \" , curr -> data ) ; next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; } } struct Node * NthNode ( struct Node * * head , int N ) { int count = 0 ; struct Node * curr = * head ; struct Node * curr1 = * head ; struct Node * prev = NULL ; struct Node * prev1 = NULL ; struct Node * next ; struct Node * next1 ; while ( count < N && curr != NULL ) { next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; count ++ ; } if ( curr == NULL && count < N ) { printf ( \" Wrong ▁ Input \" ) ; return ( uintptr_t ) 0 ; } else { while ( curr != NULL ) { next = XOR ( prev , curr -> nxp ) ; next1 = XOR ( prev1 , curr1 -> nxp ) ; prev = curr ; prev1 = curr1 ; curr = next ; curr1 = next1 ; } printf ( \" % d \" , curr1 -> data ) ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 0 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; insert ( & head , 3 ) ; insert ( & head , 11 ) ; insert ( & head , 8 ) ; insert ( & head , 6 ) ; insert ( & head , 7 ) ; NthNode ( & head , 3 ) ; return ( 0 ) ; }"}
{"text": "Senarai Linked XOR | Program C untuk melaksanakan pendekatan di atas; Struktur nod dalam senarai berkaitan XOR; Menyimpan nilai data nod; Kedai xor penunjuk sebelumnya dan penunjuk seterusnya; Berfungsi untuk mencari XOR dua nod; Fungsi untuk memasukkan nod dengan nilai yang diberikan pada kedudukan yang diberikan; Jika senarai yang dipautkan XOR kosong; Memulakan nod baru; Menyimpan nilai data dalam nod; Kedai xor penunjuk sebelumnya dan seterusnya; Kemas kini penunjuk nod kepala; Jika senarai berkaitan XOR tidak kosong; Menyimpan alamat nod semasa; Menyimpan alamat nod sebelumnya; Memulakan nod baru; Kemas kini alamat nod curr; Mengemas kini alamat nod baru; Kemas kini kepala; Kemas kini nilai data nod semasa; Berfungsi untuk mencetak nod tengah; Kedai penunjuk XOR dalam nod semasa; Kedai penunjuk xor dalam nod sebelumnya; Kedai penunjuk XOR dalam nod seterusnya; Traverse XOR Linked List; Ke hadapan traversal; UPDATE PREV; Kemas kini curr; Jika panjang senarai yang dipautkan adalah ganjil; Jika panjang senarai yang dipautkan itu; Kod pemacu; Buat Ketua Senarai Berkaitan XOR berikut -> 4 A> 7 A> 5", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * nxp ; } ; struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; } struct Node * insert ( struct Node * * head , int value ) { if ( * head == NULL ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = value ; node -> nxp = XOR ( NULL , NULL ) ; * head = node ; } else { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ; node -> nxp = XOR ( NULL , curr ) ; * head = node ; node -> data = value ; } return * head ; } int printMiddle ( struct Node * * head , int len ) { int count = 0 ; struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * next ; int middle = ( int ) len / 2 ; while ( count != middle ) { next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; count ++ ; } if ( len & 1 ) { printf ( \" % d \" , curr -> data ) ; } else { printf ( \" % d ▁ % d \" , prev -> data , curr -> data ) ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 4 ) ; insert ( & head , 7 ) ; insert ( & head , 5 ) ; printMiddle ( & head , 3 ) ; return ( 0 ) ; }"}
{"text": "Senarai Linked XOR | Program C ++ untuk melaksanakan pendekatan di atas; Struktur nod dalam senarai berkaitan XOR; Menyimpan nilai data nod; Kedai xor penunjuk sebelumnya dan penunjuk seterusnya; Berfungsi untuk mencari XOR dua nod; Fungsi untuk memasukkan nod dengan nilai yang diberikan pada kedudukan yang diberikan; Jika senarai yang dipautkan XOR kosong; Jika kedudukan yang diberikan adalah sama dengan 1; Memulakan nod baru; Menyimpan nilai data dalam nod; Kedai xor penunjuk sebelumnya dan seterusnya; Kemas kini penunjuk nod kepala; Sekiranya kedudukan yang diperlukan tidak dijumpai; Jika senarai berkaitan XOR tidak kosong; Kedai kedudukan nod dalam senarai yang dipautkan XOR; Menyimpan alamat nod semasa; Menyimpan alamat nod sebelumnya; Menyimpan xor nod seterusnya dan nod sebelumnya; Melintasi senarai yang dipautkan XOR; UPDATE PREV; Kemas kini curr; Kemas kini Seterusnya; Kemas kini POS; Jika kedudukan nod semasa adalah sama dengan kedudukan yang diberikan; Memulakan nod baru; Kedai penunjuk ke nod sebelumnya sebagai (prev ^ next ^ next) = prev; Kedai xor prev dan nod baru; Menghubungkan nod baru dengan seterusnya; Kemas kini penunjuk seterusnya; Sambungkan nod dengan curr dan curr seterusnya < - node -> seterusnya; Nod penyisipan pada permulaan; Memulakan nod baru; Kemas kini alamat nod curr; Mengemas kini alamat nod baru; Kemas kini kepala; Kemas kini nilai data nod semasa; Berfungsi untuk mencetak unsur -unsur senarai yang dipautkan XOR; Kedai penunjuk XOR dalam nod semasa; Kedai penunjuk xor dalam nod sebelumnya; Kedai penunjuk XOR dalam nod seterusnya; Traverse XOR Linked List; Cetak nod semasa; Ke hadapan traversal; UPDATE PREV; Kemas kini curr; Kod pemacu; Buat berikut XOR Linked List Head -> 20 <--> 40 <--> 10 <--> 30; Cetak senarai baru", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * nxp ; } ; struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; } struct Node * insert ( struct Node * * head , int value , int position ) { if ( * head == NULL ) { if ( position == 1 ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = value ; node -> nxp = XOR ( NULL , NULL ) ; * head = node ; } else { printf ( \" Invalid ▁ Position STRNEWLINE \" ) ; } } else { int Pos = 1 ; struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * next = XOR ( prev , curr -> nxp ) ; while ( next != NULL && Pos < position - 1 ) { prev = curr ; curr = next ; next = XOR ( prev , curr -> nxp ) ; Pos ++ ; } if ( Pos == position - 1 ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * temp = XOR ( curr -> nxp , next ) ; curr -> nxp = XOR ( temp , node ) ; if ( next != NULL ) { next -> nxp = XOR ( node , XOR ( next -> nxp , curr ) ) ; } node -> nxp = XOR ( curr , next ) ; node -> data = value ; } else if ( position == 1 ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ; node -> nxp = XOR ( NULL , curr ) ; * head = node ; node -> data = value ; } else { printf ( \" Invalid ▁ Position STRNEWLINE \" ) ; } } return * head ; } void printList ( struct Node * * head ) { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * next ; while ( curr != NULL ) { printf ( \" % d ▁ \" , curr -> data ) ; next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 10 , 1 ) ; insert ( & head , 20 , 1 ) ; insert ( & head , 30 , 3 ) ; insert ( & head , 40 , 2 ) ; printList ( & head ) ; return ( 0 ) ; }"}
{"text": "Program untuk bertukar k | C program untuk togol k - th bit nombor n; Berfungsi untuk bertukar -tukar sedikit n; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int toggleBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; } int main ( ) { int n = 5 , k = 2 ; printf ( \" % d STRNEWLINE \" , toggleBit ( n , k ) ) ; return 0 ; }"}
{"text": "Program untuk membersihkan k | C program untuk membersihkan k - bit nombor n; Berfungsi untuk membersihkan bit kth n; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int clearBit ( int n , int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; } int main ( ) { int n = 5 , k = 1 ; printf ( \" % d STRNEWLINE \" , clearBit ( n , k ) ) ; return 0 ; }"}
{"text": "Peralihan kiri dan pengendali peralihan kanan dalam C / C ++ | Program C ++ untuk menunjukkan penggunaan pengendali peralihan kanan; A = 5 (00000101), b = 9 (00001001); Hasilnya ialah 00000010; Hasilnya ialah 00000100", "code": "#include <stdio.h> NEW_LINE using namespace std ; int main ( ) { unsigned char a = 5 , b = 9 ; printf ( \" a > > 1 ▁ = ▁ % d STRNEWLINE \" , a >> 1 ) ; printf ( \" b > > 1 ▁ = ▁ % d STRNEWLINE \" , b >> 1 ) ; return 0 ; }"}
{"text": "Peralihan kiri dan pengendali peralihan kanan dalam C / C ++ |  ; shift y oleh 61 bit kiri", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 19 ; unsigned long long y = 19 ; printf ( \" x ▁ < < ▁ 1 ▁ = ▁ % d STRNEWLINE \" , x << 1 ) ; printf ( \" x ▁ > > ▁ 1 ▁ = ▁ % d STRNEWLINE \" , x >> 1 ) ; printf ( \" y ▁ < < ▁ 61 ▁ = ▁ % lld STRNEWLINE \" , y << 61 ) ; return 0 ; }"}
{"text": "Peralihan kiri dan pengendali peralihan kanan dalam C / C ++ |", "code": "#include <stdio.h> NEW_LINE int main ( ) { int i = 3 ; printf ( \" pow ( 2 , ▁ % d ) ▁ = ▁ % d STRNEWLINE \" , i , 1 << i ) ; i = 4 ; printf ( \" pow ( 2 , ▁ % d ) ▁ = ▁ % d STRNEWLINE \" , i , 1 << i ) ; return 0 ; }"}
{"text": "Penambahan Rekursif Bitwise Dua Integer | Program C untuk melakukan penambahan rekursif dua bilangan bulat; Jika Bitwise & adalah 0, maka tidak akan ada apa -apa bawa. Oleh itu, hasil XOR adalah tambahan. ; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int add ( int x , int y ) { int keep = ( x & y ) << 1 ; int res = x ^ y ; if ( keep == 0 ) return res ; add ( keep , res ) ; } int main ( ) { printf ( \" % d \" , add ( 15 , 38 ) ) ; return 0 ; }"}
{"text": "Kira jumlah bit dalam nombor | Program C untuk mencari jumlah bit dalam nombor tertentu; Fungsi log di pangkalan 2 hanya mengambil bahagian integer; Program yang didorong", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE unsigned countBits ( unsigned int number ) { return ( int ) log2 ( number ) + 1 ; } int main ( ) { unsigned int num = 65 ; printf ( \" % d STRNEWLINE \" , countBits ( num ) ) ; return 0 ; }"}
{"text": "Cari n | Program C yang cekap untuk mencari palindrome n; Bina palindrome binari n dengan nombor kumpulan yang diberikan, aux_number dan jenis operasi; Tidak perlu memasukkan bit di tengah; Panjang perwakilan binari terakhir; Isi bit pertama dan terakhir sebagai 1; Mula mengisi A [] dari tengah, dengan perwakilan binari Aux_num; Dapatkan bit nombor tambahan dan isi tengah; Masukkan bit 0 di tengah; Panjang perwakilan binari terakhir; Isi bit pertama dan terakhir sebagai 1; Mula mengisi A [] dari tengah, dengan perwakilan binari Aux_num; Dapatkan bit nombor tambahan dan isi tengah; lain masukkan bit 1 di tengah; Panjang perwakilan binari terakhir; Isi bit pertama dan terakhir sebagai 1; Mula mengisi A [] dari tengah, dengan perwakilan binari Aux_num; Dapatkan bit nombor tambahan dan isi tengah; Tukar nombor kepada perpuluhan dari binari; Akan mengembalikan nombor palindrome binari n; Tambah bilangan elemen dalam semua kumpulan, sehingga kumpulan nombor n dijumpai; Jumlah bilangan elemen sehingga kumpulan ini; Kedudukan mengimbangi elemen dalam kumpulan; Mencari yang sedikit yang akan diletakkan di tengah dan mencari nombor, yang akan kami isi dari tengah ke kedua -dua arah; Kita perlu mengisi nombor tambahan ini dalam bentuk binari tengah di kedua -dua arah; op = 0; Perlu memasukkan 0 di tengah; op = 1; Perlu memasukkan 1 di tengah; Kod pemacu; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #define INT_SIZE  32 NEW_LINE int constructNthNumber ( int group_no , int aux_num , int op ) { int a [ INT_SIZE ] = { 0 } ; int num = 0 , len_f ; int i = 0 ; if ( op == 2 ) { len_f = 2 * group_no ; a [ len_f - 1 ] = a [ 0 ] = 1 ; while ( aux_num ) { a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ; while ( aux_num ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ; while ( aux_num ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; } int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ; while ( count_temp < n ) { group_no ++ ; count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; } group_offset = n - count_upto_group - 1 ; if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) { aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 ) else aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; } int main ( ) { int n = 9 ; printf ( \" % d \" , getNthNumber ( n ) ) ; return 0 ; }"}
{"text": "Togol semua bit nombor kecuali k | C program untuk bertukar semua bit kecuali kth bit; Mengembalikan nombor dengan semua bit bertukar dalam n kecuali k - th bit; 1) togol k - th bit dengan melakukan n ^ (1 << k) 2) togol semua bit nombor yang diubah suai; Kod pemacu", "code": "#include <stdio.h> NEW_LINE unsigned int toggleAllExceptK ( unsigned int n , unsigned int k ) { return ~ ( n ^ ( 1 << k ) ) ; } int main ( ) { unsigned int n = 4294967295 ; unsigned int k = 0 ; printf ( \" % u \" , toggleAllExceptK ( n , k ) ) ; return 0 ; }"}
{"text": "Pengendali di C | Tetapkan 2 (Operator Relasi dan Logik) | Program C untuk menunjukkan kerja pengendali relasi; lebih besar daripada contoh; lebih besar daripada sama dengan; kurang daripada contoh; lebih rendah daripada sama dengan; sama dengan; tidak sama dengan", "code": "#include <stdio.h> NEW_LINE int main ( ) { int a = 10 , b = 4 ; if ( a > b ) printf ( \" a ▁ is ▁ greater ▁ than ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ less ▁ than ▁ or ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; if ( a >= b ) printf ( \" a ▁ is ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ lesser ▁ than ▁ b STRNEWLINE \" ) ; if ( a < b ) printf ( \" a ▁ is ▁ less ▁ than ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; if ( a <= b ) printf ( \" a ▁ is ▁ lesser ▁ than ▁ or ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ greater ▁ than ▁ b STRNEWLINE \" ) ; if ( a == b ) printf ( \" a ▁ is ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ and ▁ b ▁ are ▁ not ▁ equal STRNEWLINE \" ) ; if ( a != b ) printf ( \" a ▁ is ▁ not ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ equal ▁ b STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Pengendali di C | Tetapkan 2 (Operator Relasi dan Logik) | Program C untuk menunjukkan kerja pengendali logik; logik dan contoh; logik atau contoh; Logik tidak contoh", "code": "#include <stdio.h> NEW_LINE int main ( ) { int a = 10 , b = 4 , c = 10 , d = 20 ; if ( a > b && c == d ) printf ( \" a ▁ is ▁ greater ▁ than ▁ b ▁ AND ▁ c ▁ is ▁ equal ▁ to ▁ d STRNEWLINE \" ) ; else printf ( \" AND ▁ condition ▁ not ▁ satisfied STRNEWLINE \" ) ; if ( a > b c == d ) printf ( \" a ▁ is ▁ greater ▁ than ▁ b ▁ OR ▁ c ▁ is ▁ equal ▁ to ▁ d STRNEWLINE \" ) ; else printf ( \" Neither ▁ a ▁ is ▁ greater ▁ than ▁ b ▁ nor ▁ c ▁ is ▁ equal ▁ \" \" ▁ to ▁ d STRNEWLINE \" ) ; if ( ! a ) printf ( \" a ▁ is ▁ zero STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ not ▁ zero \" ) ; return 0 ; }"}
{"text": "Pengendali di C | Tetapkan 2 (Operator Relasi dan Logik) |", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE int main ( ) { int a = 10 , b = 4 ; bool res = ( ( a != b ) || printf ( \" GeeksQuiz \" ) ) ; return 0 ; }"}
{"text": "Bagaimana untuk menukar dua bit dalam integer yang diberikan? | Program C untuk menukar bit dalam integer; Fungsi ini bertukar sedikit pada kedudukan P1 dan P2 dalam integer n; Gerakkan p1 'th ke sebelah kanan; Gerakkan p2 'th ke sebelah kanan; Xor dua bit; Letakkan sedikit XOR kembali ke kedudukan asal mereka; Xor 'X' dengan nombor asal supaya kedua -dua set itu ditukar; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int swapBits ( unsigned int n , unsigned int p1 , unsigned int p2 ) { unsigned int bit1 = ( n >> p1 ) & 1 ; unsigned int bit2 = ( n >> p2 ) & 1 ; unsigned int x = ( bit1 ^ bit2 ) ; x = ( x << p1 ) | ( x << p2 ) ; unsigned int result = n ^ x ; } int main ( ) { int res = swapBits ( 28 , 0 , 3 ) ; printf ( \" Result ▁ = ▁ % d ▁ \" , res ) ; return 0 ; }"}
{"text": "Tulis fungsi yang kembali 2 untuk input 1 dan pulangan 1 untuk 2 |", "code": "int invert ( int x ) { if ( x == 1 ) return 2 ; else return 1 ; }"}
{"text": "Tulis fungsi yang kembali 2 untuk input 1 dan pulangan 1 untuk 2 |", "code": "int invertSub ( int x ) { return ( 3 - x ) ; }"}
{"text": "Pengendali Bitwise dalam C / C ++ |  ; Berfungsi untuk mengembalikan satu -satunya elemen yang ganjil; Kaedah Pemandu", "code": "#include <stdio.h> NEW_LINE int findOdd ( int arr [ ] , int n ) { int res = 0 , i ; for ( i = 0 ; i < n ; i ++ ) res ^= arr [ i ] ; return res ; } int main ( void ) { int arr [ ] = { 12 , 12 , 14 , 90 , 14 , 14 , 14 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ odd ▁ occurring ▁ element ▁ is ▁ % d ▁ \" , findOdd ( arr , n ) ) ; return 0 ; }"}
{"text": "Pengendali Bitwise dalam C / C ++ |", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 2 , y = 5 ; ( x & y ) ? printf ( \" True ▁ \" ) : printf ( \" False ▁ \" ) ; ( x && y ) ? printf ( \" True ▁ \" ) : printf ( \" False ▁ \" ) ; return 0 ; }"}
{"text": "Pelaksanaan kod Hamming dalam C / C ++ | Program C untuk pendekatan di atas; Menyimpan bit input; Menyimpan kod Hamming; Berfungsi untuk mengira bit untuk kedudukan ith; Traverse untuk menyimpan kod Hamming; Jika boit semasa adalah 1; Kemas kini i; Berfungsi untuk mengira kod Hamming; Cari bit MSG yang telah ditetapkan bit pada kedudukan X 'th nombor; Melintasi msgbits; Mengemas kini kod; Kemas kini kod [i] ke aksara input pada indeks j; Melintasi dan mengemas kini kod Hamming; Cari kedudukan semasa; Cari nilai pada kedudukan semasa; Mengemas kini kod; Cetak kod Hamming; Kod pemacu; Diberi sedikit mesej input; Panggilan fungsi", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE int input [ 32 ] ; int code [ 32 ] ; int ham_calc ( int , int ) ; void solve ( int input [ ] , int ) ; int ham_calc ( int position , int c_l ) { int count = 0 , i , j ; i = position - 1 ; while ( i < c_l ) { for ( j = i ; j < i + position ; j ++ ) { if ( code [ j ] == 1 ) count ++ ; } i = i + 2 * position ; } if ( count % 2 == 0 ) return 0 ; else return 1 ; } void solve ( int input [ ] , int n ) { int i , p_n = 0 , c_l , j , k ; i = 0 ; while ( n > ( int ) pow ( 2 , i ) - ( i + 1 ) ) { p_n ++ ; i ++ ; } c_l = p_n + n ; j = k = 0 ; for ( i = 0 ; i < c_l ; i ++ ) { if ( i == ( ( int ) pow ( 2 , k ) - 1 ) ) { code [ i ] = 0 ; k ++ ; } else { code [ i ] = input [ j ] ; j ++ ; } } for ( i = 0 ; i < p_n ; i ++ ) { int position = ( int ) pow ( 2 , i ) ; int value = ham_calc ( position , c_l ) ; code [ position - 1 ] = value ; } printf ( \" The generated Code Word is : \" for ( i = 0 ; i < c_l ; i ++ ) { printf ( \" % d \" , code [ i ] ) ; } } void main ( ) { input [ 0 ] = 0 ; input [ 1 ] = 1 ; input [ 2 ] = 1 ; input [ 3 ] = 1 ; int N = 4 ; solve ( input , N ) ; }"}
{"text": "Pertama bukan | Program CPP untuk mencari watak pertama bukan berulang menggunakan array 1D dan satu traversal. ; Fungsi mengembalikan indeks watak bukan berulang yang pertama dalam rentetan. Jika semua aksara mengulangi maka mengembalikan int_max; Memulakan semua aksara sebagai tidak hadir. ; Selepas di bawah gelung, nilai ARR [x] akan menjadi indeks x jika x muncul hanya sekali. Lain nilai akan sama ada - 1 atau - 2 .; Jika watak ini berlaku sekali sahaja dan muncul sebelum hasil semasa, maka kemas kini hasilnya; Program pemacu untuk menguji fungsi di atas", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <math.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE int firstNonRepeating ( char * str ) { int arr [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = -1 ; for ( int i = 0 ; str [ i ] ; i ++ ) { if ( arr [ str [ i ] ] == -1 ) arr [ str [ i ] ] = i ; else arr [ str [ i ] ] = -2 ; } int res = INT_MAX ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = min ( res , arr [ i ] ) ; return res ; } int main ( ) { char str [ ] = \" geeksforgeeks \" ; int index = firstNonRepeating ( str ) ; if ( index == INT_MAX ) printf ( \" Either ▁ all ▁ characters ▁ are ▁ \" \" repeating ▁ or ▁ string ▁ is ▁ empty \" ) ; else printf ( \" First ▁ non - repeating ▁ character \" \" ▁ is ▁ % c \" , str [ index ] ) ; return 0 ; }"}
{"text": "Nombor Triacontagon | Program C untuk pendekatan di atas; Mencari nombor triacontagonal nth; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int triacontagonalNum ( int n ) { return ( 28 * n * n - 26 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd ▁ triacontagonal ▁ Number ▁ is ▁ = ▁ % d \" , triacontagonalNum ( n ) ) ; return 0 ; }"}
{"text": "Nombor Hexacontagon | Program C untuk pendekatan di atas; Mencari nombor hexacontagon nth; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int hexacontagonNum ( int n ) { return ( 58 * n * n - 56 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd ▁ hexacontagon ▁ Number ▁ is ▁ = ▁ % d \" , hexacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Nombor EnneAcontagon | Program C untuk pendekatan di atas; Mencari nombor enneacontagon nth; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int enneacontagonNum ( int n ) { return ( 88 * n * n - 86 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd ▁ enneacontagon ▁ Number ▁ is ▁ = ▁ % d \" , enneacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Nombor Triacontakaidigon | Program C untuk pendekatan di atas; Mencari nombor triacontakaidigon n; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int triacontakaidigonNum ( int n ) { return ( 30 * n * n - 28 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd ▁ triacontakaidigon ▁ Number ▁ is ▁ = ▁ % d \" , triacontakaidigonNum ( n ) ) ; return 0 ; }"}
{"text": "Nombor Icosihexagonal | Program C untuk pendekatan di atas; Mencari nombor icosihexagonal nth; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int IcosihexagonalNum ( int n ) { return ( 24 * n * n - 22 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd ▁ Icosihexagonal ▁ Number ▁ is ▁ = ▁ % d \" , IcosihexagonalNum ( n ) ) ; return 0 ; }"}
{"text": "ICOSIKAIOCTAGON atau NOMBOR ICOSIOCTAGON | Program C untuk pendekatan di atas; Mencari nombor icosikaioctagonal nth; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd ▁ icosikaioctagonal ▁ Number ▁ is ▁ = ▁ % d \" , icosikaioctagonalNum ( n ) ) ; return 0 ; }"}
{"text": "Nombor OctaContagon | Program C untuk pendekatan di atas; Mencari nombor OctaContagon Nth; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd ▁ octacontagon ▁ Number ▁ is ▁ = ▁ % d \" , octacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Nombor Hektagon | Program C untuk pendekatan di atas; Mencari nombor hektagon nth; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd ▁ hectagon ▁ Number ▁ is ▁ = ▁ % d \" , hectagonNum ( n ) ) ; return 0 ; }"}
{"text": "Nombor Tetracontagon | Program C untuk pendekatan di atas; Mencari nombor tetracontagon nth; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd ▁ tetracontagon ▁ Number ▁ is ▁ = ▁ % d \" , tetracontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Cari elemen dalam array yang disusun terbalik | Program C untuk pendekatan di atas; Fungsi untuk mencari jika elemen X hadir dalam array yang disusun terbalik; Simpan indeks pertama subarray di mana X terletak; Simpan indeks terakhir subarray di mana X terletak; Simpan indeks tengah subarray; Semak sama ada nilai pada indeks tengah subarray sama dengan x; Elemen dijumpai; Jika x lebih kecil daripada nilai pada indeks tengah subarray; Cari di separuh kanan subarray; Cari di separuh kiri subarray; Jika x tidak dijumpai; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int N , int X ) { int start = 0 ; int end = N ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( X == arr [ mid ] ) { return mid ; } else if ( X < arr [ mid ] ) { start = mid + 1 ; } else { end = mid - 1 ; } } return -1 ; } int main ( ) { int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 4 ; int res = binarySearch ( arr , N , X ) ; printf ( \" ▁ % d ▁ \" , res ) ; return 0 ; }"}
{"text": "Penyusunan Pancake | C program untuk menyusun array menggunakan jenis pancake; Membalikkan ARR [0 .. i]; Mengembalikan indeks elemen maksimum dalam ARR [0 .. n - 1]; Fungsi utama yang disusun dengan pelbagai menggunakan operasi flip; Mulakan dari array lengkap dan satu demi satu mengurangkan saiz semasa dengan satu; Cari indeks elemen maksimum dalam ARR [0 .. curr_size - 1]; Gerakkan elemen maksimum ke hujung array semasa jika ia belum selesai; Untuk bergerak pada akhir, gerakkan nombor maksimum pertama ke permulaan; Sekarang gerakkan nombor maksimum hingga berakhir dengan membalikkan array semasa; Fungsi utiliti untuk mencetak nasi saiz n; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } } int findMax ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; } void pancakeSort ( int * arr , int n ) { for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) { int mi = findMax ( arr , curr_size ) ; if ( mi != curr_size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_size - 1 ) ; } } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) printf ( \" % d ▁ \" , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 23 , 10 , 20 , 11 , 12 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pancakeSort ( arr , n ) ; puts ( \" Sorted ▁ Array ▁ \" ) ; printArray ( arr , n ) ; return 0 ; }"}
