{"text": "C program for above approach", "code": "#include <stdio.h>"}
{"text": "Function to count of set bit in N", "code": "void count_setbit ( int N ) {"}
{"text": "Stores count of set bit in N", "code": "int result = 0 ;"}
{"text": "Iterate over the range [ 0 , 31 ]", "code": "for ( int i = 0 ; i < 32 ; i ++ ) {"}
{"text": "If current bit is set", "code": "if ( ( 1 << i ) & N ) {"}
{"text": "Update result", "code": "result ++ ; } } printf ( \" % d STRNEWLINE \" , result ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int N = 43 ; count_setbit ( N ) ; return 0 ; }"}
{"text": "C implementation to check that a integer is a power of Two", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Function to check if the number is a power of two", "code": "_Bool isPowerOfTwo ( int n ) { return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int N = 8 ; if ( isPowerOfTwo ( N ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } }"}
{"text": "C implementation to find the cantor set for n levels and for a given start_num and end_num", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h>"}
{"text": "The Linked List Structure for the Cantor Set", "code": "typedef struct cantor { double start , end ; struct cantor * next ; } Cantor ;"}
{"text": "Function to initialize the Cantor Set List", "code": "Cantor * startList ( Cantor * head , double start_num , double end_num ) { if ( head == NULL ) { head = ( Cantor * ) malloc ( sizeof ( Cantor ) ) ; head -> start = start_num ; head -> end = end_num ; head -> next = NULL ; } return head ; }"}
{"text": "Function to propogate the list by adding new nodes for the next levels", "code": "Cantor * propagate ( Cantor * head ) { Cantor * temp = head ; if ( temp != NULL ) { Cantor * newNode = ( Cantor * ) malloc ( sizeof ( Cantor ) ) ; double diff = ( ( ( temp -> end ) - ( temp -> start ) ) / 3 ) ;"}
{"text": "Modifying the start and end values for the next level", "code": "newNode -> end = temp -> end ; temp -> end = ( ( temp -> start ) + diff ) ; newNode -> start = ( newNode -> end ) - diff ;"}
{"text": "Changing the pointers to the next node", "code": "newNode -> next = temp -> next ; temp -> next = newNode ;"}
{"text": "Recursively call the function to generate the Cantor Set for the entire level", "code": "propagate ( temp -> next -> next ) ; } return head ; }"}
{"text": "Function to print a level of the Set", "code": "void print ( Cantor * temp ) { while ( temp != NULL ) { printf ( \" [ % lf ] ▁ - - ▁ [ % lf ] TABSYMBOL \" , temp -> start , temp -> end ) ; temp = temp -> next ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Function to build and display the Cantor Set for each level", "code": "void buildCantorSet ( int A , int B , int L ) { Cantor * head = NULL ; head = startList ( head , A , B ) ; for ( int i = 0 ; i < L ; i ++ ) { printf ( \" Level _ % d ▁ : ▁ \" , i ) ; print ( head ) ; propagate ( head ) ; } printf ( \" Level _ % d ▁ : ▁ \" , L ) ; print ( head ) ; }"}
{"text": "Driver code", "code": "int main ( ) { int A = 0 ; int B = 9 ; int L = 2 ; buildCantorSet ( A , B , L ) ; return 0 ; }"}
{"text": "C program for A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different", "code": "void search ( char pat [ ] , char txt [ ] ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i = 0 ; while ( i <= N - M ) { int j ;"}
{"text": "For current index i , check for pattern match", "code": "for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ;"}
{"text": "if ( j == M ) if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ]", "code": "{ printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else"}
{"text": "slide the pattern by j", "code": "i = i + j ; } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char txt [ ] = \" ABCEABCDABCEABCD \" ; char pat [ ] = \" ABCD \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "C program to Encrypt the String using ! and @", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Function to encrypt the string", "code": "void encrypt ( char input [ 100 ] ) {"}
{"text": "evenPos is for storing encrypting char at evenPosition oddPos is for storing encrypting char at oddPosition", "code": "char evenPos = ' @ ' , oddPos = ' ! ' ; int repeat , ascii ; for ( int i = 0 ; i <= strlen ( input ) ; i ++ ) {"}
{"text": "Get the number of times the character is to be repeated", "code": "ascii = input [ i ] ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( int j = 0 ; j < repeat ; j ++ ) {"}
{"text": "if i is odd , print ' ! ' else print ' @ '", "code": "if ( i % 2 == 0 ) printf ( \" % c \" , oddPos ) ; else printf ( \" % c \" , evenPos ) ; } } }"}
{"text": "Driver code", "code": "void main ( ) { char input [ 100 ] = { ' A ' , ' b ' , ' C ' , ' d ' } ;"}
{"text": "Encrypt the String", "code": "encrypt ( input ) ; }"}
{"text": "A recursive C program to check whether a given number is palindrome or not", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #include <stdbool.h>"}
{"text": "A recursive function that check a str [ s . . e ] is palindrome or not .", "code": "bool isPalRec ( char str [ ] , int s , int e ) {"}
{"text": "If there is only one character", "code": "if ( s == e ) return true ;"}
{"text": "If first and last characters do not match", "code": "if ( str [ s ] != str [ e ] ) return false ;"}
{"text": "If there are more than two characters , check if middle substring is also palindrome or not .", "code": "if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; } bool isPalindrome ( char str [ ] ) { int n = strlen ( str ) ;"}
{"text": "An empty string is considered as palindrome", "code": "if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { char str [ ] = \" geeg \" ; if ( isPalindrome ( str ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "A simple C ++ program for implementation of atoi", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int myAtoi ( const char * str ) { int sign = 1 , base = 0 , i = 0 ;"}
{"text": "if whitespaces then ignore .", "code": "while ( str [ i ] == ' ▁ ' ) { i ++ ; }"}
{"text": "sign of number", "code": "if ( str [ i ] == ' - ' str [ i ] == ' + ' ) { sign = 1 - 2 * ( str [ i ++ ] == ' - ' ) ; }"}
{"text": "checking for valid input", "code": "while ( str [ i ] >= '0' && str [ i ] <= '9' ) {"}
{"text": "handling overflow test case", "code": "if ( base > INT_MAX / 10 || ( base == INT_MAX / 10 && str [ i ] - '0' > 7 ) ) { if ( sign == 1 ) return INT_MAX ; else return INT_MIN ; } base = 10 * base + ( str [ i ++ ] - '0' ) ; } return base * sign ; }"}
{"text": "Driver Code", "code": "int main ( ) { char str [ ] = \" ▁ - 123\" ;"}
{"text": "Functional Code", "code": "int val = myAtoi ( str ) ; printf ( \" % d ▁ \" , val ) ; return 0 ; }"}
{"text": "A backtracking based C Program to fill two instances of all numbers from 1 to n in a specific way", "code": "#include <stdio.h> NEW_LINE #include <stdbool.h>"}
{"text": "A recursive utility function to fill two instances of numbers from 1 to n in res [ 0. .2 n - 1 ] . ' curr ' is current value of n .", "code": "bool fillUtil ( int res [ ] , int curr , int n ) {"}
{"text": "If current number becomes 0 , then all numbers are filled", "code": "if ( curr == 0 ) return true ;"}
{"text": "Try placing two instances of ' curr ' at all possible locations till solution is found", "code": "int i ; for ( i = 0 ; i < 2 * n - curr - 1 ; i ++ ) {"}
{"text": "Two ' curr ' should be placed at ' curr + 1' distance", "code": "if ( res [ i ] == 0 && res [ i + curr + 1 ] == 0 ) {"}
{"text": "Plave two instances of ' curr '", "code": "res [ i ] = res [ i + curr + 1 ] = curr ;"}
{"text": "Recur to check if the above placement leads to a solution", "code": "if ( fillUtil ( res , curr - 1 , n ) ) return true ;"}
{"text": "If solution is not possible , then backtrack", "code": "res [ i ] = res [ i + curr + 1 ] = 0 ; } } return false ; }"}
{"text": "This function prints the result for input number ' n ' using fillUtil ( )", "code": "void fill ( int n ) {"}
{"text": "Create an array of size 2 n and initialize all elements in it as 0", "code": "int res [ 2 * n ] , i ; for ( i = 0 ; i < 2 * n ; i ++ ) res [ i ] = 0 ;"}
{"text": "If solution is possible , then print it .", "code": "if ( fillUtil ( res , n , n ) ) { for ( i = 0 ; i < 2 * n ; i ++ ) printf ( \" % d ▁ \" , res [ i ] ) ; } else puts ( \" Not ▁ Possible \" ) ; }"}
{"text": "Driver program", "code": "int main ( ) { fill ( 7 ) ; return 0 ; }"}
{"text": "C implementation of the approach", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Function to print the number of digits", "code": "int findNumberOfDigits ( int n , int base ) {"}
{"text": "Calculate log using base change property and then take its floor and then add 1", "code": "int dig = ( floor ( log ( n ) / log ( base ) ) + 1 ) ;"}
{"text": "Return the output", "code": "return ( dig ) ; }"}
{"text": "Function that returns true if n contains all one 's in base b", "code": "int isAllKs ( int n , int b , int k ) { int len = findNumberOfDigits ( n , b ) ;"}
{"text": "Calculate the sum", "code": "int sum = k * ( 1 - pow ( b , len ) ) / ( 1 - b ) ; if ( sum == n ) { return ( sum ) ; } }"}
{"text": "Driver code", "code": "int main ( void ) {"}
{"text": "Given number N", "code": "int N = 13 ;"}
{"text": "Given base B", "code": "int B = 3 ;"}
{"text": "Given digit K", "code": "int K = 1 ;"}
{"text": "Function call", "code": "if ( isAllKs ( N , B , K ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } return 0 ; }"}
{"text": "C program to Calculate the Perimeter of a Decagon", "code": "#include <stdio.h>"}
{"text": "Function for finding the perimeter", "code": "void CalPeri ( ) { int s = 5 , Perimeter ; Perimeter = 10 * s ; printf ( \" The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ % d \" , Perimeter ) ; }"}
{"text": "Driver code", "code": "int main ( ) { CalPeri ( ) ; return 0 ; }"}
{"text": "C program to find the Angle between two Planes in 3 D .", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Function to find Angle", "code": "void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = 3.14159 ; float A = ( 180 / pi ) * ( acos ( d ) ) ; printf ( \" Angle ▁ is ▁ % .2f ▁ degree \" , A ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { float a1 = 1 ; float b1 = 1 ; float c1 = 2 ; float d1 = 1 ; float a2 = 2 ; float b2 = -1 ; float c2 = 1 ; float d2 = -4 ; distance ( a1 , b1 , c1 , a2 , b2 , c2 ) ; return 0 ; }"}
{"text": "C program to find Mirror of a point through a 3 D plane", "code": "#include <stdio.h>"}
{"text": "Function to mirror image", "code": "void mirror_point ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; printf ( \" x3 ▁ = ▁ % .1f ▁ \" , x3 ) ; printf ( \" y3 ▁ = ▁ % .1f ▁ \" , y3 ) ; printf ( \" z3 ▁ = ▁ % .1f ▁ \" , z3 ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { float a = 1 ; float b = -2 ; float c = 0 ; float d = 0 ; float x1 = -1 ; float y1 = 3 ; float z1 = 4 ;"}
{"text": "function call", "code": "mirror_point ( a , b , c , d , x1 , y1 , z1 ) ; }"}
{"text": "C program to store sum of nodes in left subtree in every node", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "A tree node", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Function to modify a Binary Tree so that every node stores sum of values in its left child including its own value", "code": "int updatetree ( node * root ) {"}
{"text": "Base cases", "code": "if ( ! root ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return root -> data ;"}
{"text": "Update left and right subtrees", "code": "int leftsum = updatetree ( root -> left ) ; int rightsum = updatetree ( root -> right ) ;"}
{"text": "Add leftsum to current node", "code": "root -> data += leftsum ;"}
{"text": "Return sum of values under root", "code": "return root -> data + rightsum ; }"}
{"text": "Utility function to do inorder traversal", "code": "void inorder ( struct node * node ) { if ( node == NULL ) return ; inorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; inorder ( node -> right ) ; }"}
{"text": "Utility function to create a new node", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver program", "code": "int main ( ) {"}
{"text": "Let us construct below tree 1 / \\ 2 3 / \\ \\ 4 5 6", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; updatetree ( root ) ; cout << \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ is ▁ STRNEWLINE \" ; inorder ( root ) ; return 0 ; }"}
{"text": "C program for brute force method to calculate stock span values", "code": "#include <stdio.h>"}
{"text": "Fills array S [ ] with span values", "code": "void calculateSpan ( int price [ ] , int n , int S [ ] ) {"}
{"text": "Span value of first day is always 1", "code": "S [ 0 ] = 1 ;"}
{"text": "Calculate span value of remaining days by linearly checking previous days", "code": "for ( int i = 1 ; i < n ; i ++ ) {"}
{"text": "Initialize span value", "code": "S [ i ] = 1 ;"}
{"text": "Traverse left while the next element on left is smaller than price [ i ]", "code": "for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } }"}
{"text": "A utility function to print elements of array", "code": "void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int S [ n ] ;"}
{"text": "Fill the span values in array S [ ]", "code": "calculateSpan ( price , n , S ) ;"}
{"text": "print the calculated span values", "code": "printArray ( S , n ) ; return 0 ; }"}
{"text": "Simple C program to print next greater elements in a given array", "code": "#include <stdio.h>"}
{"text": "prints element and NGE pair for all elements of arr [ ] of size n", "code": "void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } printf ( \" % d ▁ - - ▁ % dn \" , arr [ i ] , next ) ; } }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNGE ( arr , n ) ; return 0 ; }"}
{"text": "C program to convert a binary tree to its mirror", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct Node { int data ; struct Node * left ; struct Node * right ; } ;"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Change a tree so that the roles of the left and right pointers are swapped at every node . So the tree ... 4 / \\ 2 5 / \\ 1 3 is changed to ... 4 / \\ 5 2 / \\ 3 1", "code": "void mirror ( struct Node * node ) { if ( node == NULL ) return ; else { struct Node * temp ;"}
{"text": "do the subtrees", "code": "mirror ( node -> left ) ; mirror ( node -> right ) ;"}
{"text": "swap the pointers in this node", "code": "temp = node -> left ; node -> left = node -> right ; node -> right = temp ; } }"}
{"text": "Helper function to print Inorder traversal .", "code": "void inOrder ( struct Node * node ) { if ( node == NULL ) return ; inOrder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; inOrder ( node -> right ) ; }"}
{"text": "Driver program to test mirror ( )", "code": "int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ;"}
{"text": "Print inorder traversal of the input tree", "code": "printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ constructed \" \" ▁ tree ▁ is ▁ STRNEWLINE \" ) ; inOrder ( root ) ;"}
{"text": "Convert tree to its mirror", "code": "mirror ( root ) ;"}
{"text": "Print inorder traversal of the mirror tree", "code": "printf ( \" Inorder traversal of the mirror tree \" ▁ \" is \" inOrder ( root ) ; return 0 ; }"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "A utility function that checks if trees with roots as n1 and n2 are mirror of each other", "code": "bool IsFoldableUtil ( struct node * n1 , struct node * n2 ) ;"}
{"text": "Returns true if the given tree can be folded", "code": "bool IsFoldable ( struct node * root ) { if ( root == NULL ) { return true ; } return IsFoldableUtil ( root -> left , root -> right ) ; }"}
{"text": "A utility function that checks if trees with roots as n1 and n2 are mirror of each other", "code": "bool IsFoldableUtil ( struct node * n1 , struct node * n2 ) {"}
{"text": "If both left and right subtrees are NULL , then return true", "code": "if ( n1 == NULL && n2 == NULL ) { return true ; }"}
{"text": "If one of the trees is NULL and other is not , then return false", "code": "if ( n1 == NULL n2 == NULL ) { return false ; }"}
{"text": "Otherwise check if left and right subtrees are mirrors of their counterparts", "code": "return IsFoldableUtil ( n1 -> left , n2 -> right ) && IsFoldableUtil ( n1 -> right , n2 -> left ) ; }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver program to test mirror ( )", "code": "int main ( void ) {"}
{"text": "The constructed binary tree is 1 / \\ 2 3 \\ / 4 5", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; if ( IsFoldable ( root ) == true ) { printf ( \" tree is foldable \" } else { printf ( \" tree is not foldable \" } getchar ( ) ; return 0 ; }"}
{"text": "Program to check children sum property", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , left child and right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "returns 1 if children sum property holds for the given node and both of its children", "code": "int isSumProperty ( struct node * node ) {"}
{"text": "left_data is left child data and right_data is for right child data", "code": "int left_data = 0 , right_data = 0 ;"}
{"text": "If node is NULL or it 's a leaf node then  return true", "code": "if ( node == NULL || ( node -> left == NULL && node -> right == NULL ) ) return 1 ; else {"}
{"text": "If left child is not present then 0 is used as data of left child", "code": "if ( node -> left != NULL ) left_data = node -> left -> data ;"}
{"text": "If right child is not present then 0 is used as data of right child", "code": "if ( node -> right != NULL ) right_data = node -> right -> data ;"}
{"text": "if the node and both of its children satisfy the property return 1 else 0", "code": "if ( ( node -> data == left_data + right_data ) && isSumProperty ( node -> left ) && isSumProperty ( node -> right ) ) return 1 ; else return 0 ; } }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { struct node * root = newNode ( 10 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 2 ) ; if ( isSumProperty ( root ) ) printf ( \" The ▁ given ▁ tree ▁ satisfies ▁ the ▁ children ▁ sum ▁ property ▁ \" ) ; else printf ( \" The ▁ given ▁ tree ▁ does ▁ not ▁ satisfy ▁ the ▁ children ▁ sum ▁ property ▁ \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find GCD of two numbers", "code": "#include <stdio.h>"}
{"text": "Recursive function to return gcd of a and b", "code": "int gcd ( int a , int b ) {"}
{"text": "Everything divides 0", "code": "if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ;"}
{"text": "base case", "code": "if ( a == b ) return a ;"}
{"text": "a is greater", "code": "if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int a = 0 , b = 56 ; printf ( \" GCD ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "C program for josephus problem", "code": "#include <stdio.h>"}
{"text": "function to find the position of the Most Significant Bit", "code": "int msbPos ( int n ) { int pos = 0 ; while ( n != 0 ) { pos ++ ;"}
{"text": "keeps shifting bits to the right until we are left with 0", "code": "n = n >> 1 ; } return pos ; }"}
{"text": "function to return at which place Josephus should sit to avoid being killed", "code": "int josephify ( int n ) {"}
{"text": "Getting the position of the Most Significant Bit ( MSB ) . The leftmost '1' . If the number is '41' then its binary is '101001' . So msbPos ( 41 ) = 6", "code": "int position = msbPos ( n ) ;"}
{"text": "' j ' stores the number with which to XOR the number ' n ' . Since we need '100000' We will do 1 << 6 - 1 to get '100000'", "code": "int j = 1 << ( position - 1 ) ;"}
{"text": "Toggling the Most Significant Bit . Changing the leftmost '1' to '0' . 101001 ^ 100000 = 001001 ( 9 )", "code": "n = n ^ j ;"}
{"text": "Left - shifting once to add an extra '0' to the right end of the binary number 001001 = 010010 ( 18 )", "code": "n = n << 1 ;"}
{"text": "Toggling the '0' at the end to '1' which is essentially the same as putting the MSB at the rightmost place . 010010 | 1 = 010011 ( 19 )", "code": "n = n | 1 ; return n ; }"}
{"text": "hard coded driver main function to run the program", "code": "int main ( ) { int n = 41 ; printf ( \" % d STRNEWLINE \" , josephify ( n ) ) ; return 0 ; }"}
{"text": "An efficient C ++ program to compute sum of bitwise AND of all pairs", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "Returns value of \" arr [ 0 ] ▁ & ▁ arr [ 1 ] ▁ + ▁ arr [ 0 ] ▁ & ▁ arr [ 2 ] ▁ + ▁ . . . ▁ arr [ i ] ▁ & ▁ arr [ j ] ▁ + ▁ . . . . . ▁ arr [ n - 2 ] ▁ & ▁ arr [ n - 1 ] \"", "code": "int pairAndSum ( int arr [ ] , int n ) {"}
{"text": "Traverse over all bits", "code": "for ( int i = 0 ; i < 32 ; i ++ ) {"}
{"text": "Count number of elements with i 'th bit set  int k = 0; Initialize the count", "code": "for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) k ++ ;"}
{"text": "There are k set bits , means k ( k - 1 ) / 2 pairs . Every pair adds 2 ^ i to the answer . Therefore , we add \"2 ^ i ▁ * ▁ [ k * ( k - 1 ) / 2 ] \" to the answer .", "code": "ans += ( 1 << i ) * ( k * ( k - 1 ) / 2 ) ; } return ans ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 5 , 10 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << pairAndSum ( arr , n ) << endl ; return 0 ; }"}
{"text": "Function to return count of squares ;", "code": "function countSquares ( n ) {"}
{"text": "A better way to write n * ( n + 1 ) * ( 2 n + 1 ) / 6", "code": "return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }"}
{"text": "Driver Code", "code": "let n = 4 ; document . write ( \" Count ▁ of ▁ squares ▁ is ▁ \" + countSquares ( n ) ) ;"}
{"text": "C program to find GCD of two numbers", "code": "#include <stdio.h>"}
{"text": "Recursive function to return gcd of a and b", "code": "int gcd ( int a , int b ) {"}
{"text": "Everything divides 0", "code": "if ( a == 0 ) return b ; if ( b == 0 ) return a ;"}
{"text": "base case", "code": "if ( a == b ) return a ;"}
{"text": "a is greater", "code": "if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int a = 98 , b = 56 ; printf ( \" GCD ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "C program to build xor tree by leaf nodes of perfect binary tree and root node value of tree", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "maximum size for xor tree", "code": "#define maxsize  10005"}
{"text": "Allocating space to xor tree", "code": "int xortree [ maxsize ] ;"}
{"text": "A recursive function that constructs xor tree for array [ start ... . . end ] . x is index of current node in xor tree st", "code": "void construct_Xor_Tree_Util ( int current [ ] , int start , int end , int x ) {"}
{"text": "If there is one element in array , store it in current node of xor tree and return", "code": "if ( start == end ) { xortree [ x ] = current [ start ] ;"}
{"text": "printf ( \" % d ▁ \" , xortree [ x ] ) ;", "code": "return ; }"}
{"text": "for left subtree", "code": "int left = x * 2 + 1 ;"}
{"text": "for right subtree", "code": "int right = x * 2 + 2 ;"}
{"text": "for getting the middle index from corner indexes .", "code": "int mid = start + ( end - start ) / 2 ;"}
{"text": "Build the left and the right subtrees by xor operation", "code": "construct_Xor_Tree_Util ( current , start , mid , left ) ; construct_Xor_Tree_Util ( current , mid + 1 , end , right ) ;"}
{"text": "merge the left and right subtrees by XOR operation", "code": "xortree [ x ] = ( xortree [ left ] ^ xortree [ right ] ) ; }"}
{"text": "Function to construct XOR tree from given array . This function calls construct_Xor_Tree_Util ( ) to fill the allocated memory of xort array", "code": "void construct_Xor_Tree ( int arr [ ] , int n ) { int i = 0 ; for ( i = 0 ; i < maxsize ; i ++ ) xortree [ i ] = 0 ; construct_Xor_Tree_Util ( arr , 0 , n - 1 , 0 ) ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "leaf nodes of Binary Tree", "code": "int leaf_nodes [ ] = { 40 , 32 , 12 , 1 , 4 , 3 , 2 , 7 } , i = 0 ; int n = sizeof ( leaf_nodes ) / sizeof ( leaf_nodes [ 0 ] ) ;"}
{"text": "Build the xor tree", "code": "construct_Xor_Tree ( leaf_nodes , n ) ;"}
{"text": "Height of xor tree", "code": "int x = ( int ) ( ceil ( log2 ( n ) ) ) ;"}
{"text": "Maximum size of xor tree", "code": "int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; printf ( \" Nodes ▁ of ▁ the ▁ XOR ▁ tree STRNEWLINE \" ) ; for ( i = 0 ; i < max_size ; i ++ ) { printf ( \" % d ▁ \" , xortree [ i ] ) ; }"}
{"text": "Root node is at index 0 considering 0 - based indexing in XOR Tree", "code": "int root = 0 ;"}
{"text": "print value at root node", "code": "printf ( \" Root : % d \" }"}
{"text": "C code for swapping given bits of a number", "code": "#include <stdio.h> NEW_LINE int swapBits ( int n , int p1 , int p2 ) {"}
{"text": "left - shift 1 p1 and p2 times and using XOR", "code": "n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }"}
{"text": "Driver Code", "code": "int main ( ) { printf ( \" Result ▁ = ▁ % d \" , swapBits ( 28 , 0 , 3 ) ) ; return 0 ; }"}
{"text": "C program to check if two Nodes in a binary tree are cousins", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A Binary Tree Node", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "A utility function to create a new Binary Tree Node", "code": "struct Node * newNode ( int item ) { struct Node * temp = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Recursive function to check if two Nodes are siblings", "code": "int isSibling ( struct Node * root , struct Node * a , struct Node * b ) {"}
{"text": "Base case", "code": "if ( root == NULL ) return 0 ; return ( ( root -> left == a && root -> right == b ) || ( root -> left == b && root -> right == a ) || isSibling ( root -> left , a , b ) || isSibling ( root -> right , a , b ) ) ; }"}
{"text": "Recursive function to find level of Node ' ptr ' in a binary tree", "code": "int level ( struct Node * root , struct Node * ptr , int lev ) {"}
{"text": "base cases", "code": "if ( root == NULL ) return 0 ; if ( root == ptr ) return lev ;"}
{"text": "Return level if Node is present in left subtree", "code": "int l = level ( root -> left , ptr , lev + 1 ) ; if ( l != 0 ) return l ;"}
{"text": "Else search in right subtree", "code": "return level ( root -> right , ptr , lev + 1 ) ; }"}
{"text": "Returns 1 if a and b are cousins , otherwise 0", "code": "int isCousin ( struct Node * root , struct Node * a , struct Node * b ) {"}
{"text": "1. The two Nodes should be on the same level in the binary tree . 2. The two Nodes should not be siblings ( means that they should not have the same parent Node ) .", "code": "if ( ( level ( root , a , 1 ) == level ( root , b , 1 ) ) && ! ( isSibling ( root , a , b ) ) ) return 1 ; else return 0 ; }"}
{"text": "Driver Program to test above functions", "code": "int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> right -> right = newNode ( 15 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; struct Node * Node1 , * Node2 ; Node1 = root -> left -> left ; Node2 = root -> right -> right ; isCousin ( root , Node1 , Node2 ) ? puts ( \" Yes \" ) : puts ( \" No \" ) ; return 0 ; }"}
{"text": "C program to check if all leaves are at same level", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "A utility function to allocate a new tree node", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; }"}
{"text": "Recursive function which checks whether all leaves are at same level", "code": "bool checkUtil ( struct Node * root , int level , int * leafLevel ) {"}
{"text": "Base case", "code": "if ( root == NULL ) return true ;"}
{"text": "If a leaf node is encountered", "code": "if ( root -> left == NULL && root -> right == NULL ) {"}
{"text": "When a leaf node is found first time", "code": "if ( * leafLevel == 0 ) {"}
{"text": "Set first found leaf 's level", "code": "* leafLevel = level ; return true ; }"}
{"text": "If this is not first leaf node , compare its level with first leaf 's level", "code": "return ( level == * leafLevel ) ; }"}
{"text": "If this node is not leaf , recursively check left and right subtrees", "code": "return checkUtil ( root -> left , level + 1 , leafLevel ) && checkUtil ( root -> right , level + 1 , leafLevel ) ; }"}
{"text": "The main function to check if all leafs are at same level . It mainly uses checkUtil ( )", "code": "bool check ( struct Node * root ) { int level = 0 , leafLevel = 0 ; return checkUtil ( root , level , & leafLevel ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) {"}
{"text": "Let us create tree shown in thirdt example", "code": "struct Node * root = newNode ( 12 ) ; root -> left = newNode ( 5 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 9 ) ; root -> left -> left -> left = newNode ( 1 ) ; root -> left -> right -> left = newNode ( 1 ) ; if ( check ( root ) ) printf ( \" Leaves ▁ are ▁ at ▁ same ▁ level STRNEWLINE \" ) ; else printf ( \" Leaves ▁ are ▁ not ▁ at ▁ same ▁ level STRNEWLINE \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to check whether a given Binary Tree is full or not", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h>"}
{"text": "Tree node structure", "code": "struct Node { int key ; struct Node * left , * right ; } ;"}
{"text": "Helper function that allocates a new node with the given key and NULL left and right pointer .", "code": "struct Node * newNode ( char k ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> key = k ; node -> right = node -> left = NULL ; return node ; }"}
{"text": "This function tests if a binary tree is a full binary tree .", "code": "bool isFullTree ( struct Node * root ) {"}
{"text": "If empty tree", "code": "if ( root == NULL ) return true ;"}
{"text": "If leaf node", "code": "if ( root -> left == NULL && root -> right == NULL ) return true ;"}
{"text": "If both left and right are not NULL , and left & right subtrees are full", "code": "if ( ( root -> left ) && ( root -> right ) ) return ( isFullTree ( root -> left ) && isFullTree ( root -> right ) ) ;"}
{"text": "We reach here when none of the above if conditions work", "code": "return false ; }"}
{"text": "Driver Program", "code": "int main ( ) { struct Node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( 20 ) ; root -> right = newNode ( 30 ) ; root -> left -> right = newNode ( 40 ) ; root -> left -> left = newNode ( 50 ) ; root -> right -> left = newNode ( 60 ) ; root -> right -> right = newNode ( 70 ) ; root -> left -> left -> left = newNode ( 80 ) ; root -> left -> left -> right = newNode ( 90 ) ; root -> left -> right -> left = newNode ( 80 ) ; root -> left -> right -> right = newNode ( 90 ) ; root -> right -> left -> left = newNode ( 80 ) ; root -> right -> left -> right = newNode ( 90 ) ; root -> right -> right -> left = newNode ( 80 ) ; root -> right -> right -> right = newNode ( 90 ) ; if ( isFullTree ( root ) ) printf ( \" The ▁ Binary ▁ Tree ▁ is ▁ full STRNEWLINE \" ) ; else printf ( \" The ▁ Binary ▁ Tree ▁ is ▁ not ▁ full STRNEWLINE \" ) ; return ( 0 ) ; }"}
{"text": "C program to implement the above approach", "code": "#include <stdio.h>"}
{"text": "Function to print Alternate elements of the given array", "code": "void printAlter ( int arr [ ] , int N ) {"}
{"text": "Print elements at odd positions", "code": "for ( int currIndex = 0 ; currIndex < N ; currIndex += 2 ) {"}
{"text": "Print elements of array", "code": "printf ( \" % d ▁ \" , arr [ currIndex ] ) ; } }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAlter ( arr , N ) ; }"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Given two trees , return true if they are structurally identical", "code": "int identicalTrees ( struct node * a , struct node * b ) {"}
{"text": "1. both empty", "code": "if ( a == NULL && b == NULL ) return 1 ;"}
{"text": "2. both non - empty -> compare them", "code": "if ( a != NULL && b != NULL ) { return ( a -> data == b -> data && identicalTrees ( a -> left , b -> left ) && identicalTrees ( a -> right , b -> right ) ) ; }"}
{"text": "3. one empty , one not -> false", "code": "return 0 ; }"}
{"text": "Driver program to test identicalTrees function", "code": "int main ( ) { struct node * root1 = newNode ( 1 ) ; struct node * root2 = newNode ( 1 ) ; root1 -> left = newNode ( 2 ) ; root1 -> right = newNode ( 3 ) ; root1 -> left -> left = newNode ( 4 ) ; root1 -> left -> right = newNode ( 5 ) ; root2 -> left = newNode ( 2 ) ; root2 -> right = newNode ( 3 ) ; root2 -> left -> left = newNode ( 4 ) ; root2 -> left -> right = newNode ( 5 ) ; if ( identicalTrees ( root1 , root2 ) ) printf ( \" Both ▁ tree ▁ are ▁ identical . \" ) ; else printf ( \" Trees ▁ are ▁ not ▁ identical . \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to print cousins of a node", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A Binary Tree Node", "code": "struct Node { int data ; Node * left , * right ; } ;"}
{"text": "A utility function to create a new Binary Tree Node", "code": "Node * newNode ( int item ) { Node * temp = new Node ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "It returns level of the node if it is present in tree , otherwise returns 0.", "code": "int getLevel ( Node * root , Node * node , int level ) {"}
{"text": "base cases", "code": "if ( root == NULL ) return 0 ; if ( root == node ) return level ;"}
{"text": "If node is present in left subtree", "code": "int downlevel = getLevel ( root -> left , node , level + 1 ) ; if ( downlevel != 0 ) return downlevel ;"}
{"text": "If node is not present in left subtree", "code": "return getLevel ( root -> right , node , level + 1 ) ; }"}
{"text": "Print nodes at a given level such that sibling of node is not printed if it exists", "code": "void printGivenLevel ( Node * root , Node * node , int level ) {"}
{"text": "Base cases", "code": "if ( root == NULL level < 2 ) return ;"}
{"text": "If current node is parent of a node with given level", "code": "if ( level == 2 ) { if ( root -> left == node root -> right == node ) return ; if ( root -> left ) printf ( \" % d ▁ \" , root -> left -> data ) ; if ( root -> right ) printf ( \" % d ▁ \" , root -> right -> data ) ; }"}
{"text": "Recur for left and right subtrees", "code": "else if ( level > 2 ) { printGivenLevel ( root -> left , node , level - 1 ) ; printGivenLevel ( root -> right , node , level - 1 ) ; } }"}
{"text": "This function prints cousins of a given node", "code": "void printCousins ( Node * root , Node * node ) {"}
{"text": "Get level of given node", "code": "int level = getLevel ( root , node , 1 ) ;"}
{"text": "Print nodes of given level .", "code": "printGivenLevel ( root , node , level ) ; }"}
{"text": "Driver Program to test above functions", "code": "int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> right -> right = newNode ( 15 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; printCousins ( root , root -> left -> right ) ; return 0 ; }"}
{"text": "program to print all of its root - to - leaf paths for a tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Function prototypes", "code": "void printArray ( int [ ] , int ) ; void printPathsRecur ( struct node * , int [ ] , int ) ; struct node * newNode ( int ) ; void printPaths ( struct node * ) ;"}
{"text": "Given a binary tree , print out all of its root - to - leaf paths , one per line . Uses a recursive helper to do the work .", "code": "void printPaths ( struct node * node ) { int path [ 1000 ] ; printPathsRecur ( node , path , 0 ) ; }"}
{"text": "Recursive helper function -- given a node , and an array containing the path from the root node up to but not including this node , print out all the root - leaf paths .", "code": "void printPathsRecur ( struct node * node , int path [ ] , int pathLen ) { if ( node == NULL ) return ;"}
{"text": "append this node to the path array", "code": "path [ pathLen ] = node -> data ; pathLen ++ ;"}
{"text": "it 's a leaf, so print the path that led to here", "code": "if ( node -> left == NULL && node -> right == NULL ) { printArray ( path , pathLen ) ; } else {"}
{"text": "otherwise try both subtrees", "code": "printPathsRecur ( node -> left , path , pathLen ) ; printPathsRecur ( node -> right , path , pathLen ) ; } }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Utility that prints out an array on a line", "code": "void printArray ( int ints [ ] , int len ) { int i ; for ( i = 0 ; i < len ; i ++ ) { printf ( \" % d ▁ \" , ints [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Driver program to test mirror ( )", "code": "int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ;"}
{"text": "Print all root - to - leaf paths of the input tree", "code": "printPaths ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Creating an integer array named arr of size 10.", "code": "int arr [ 10 ] ;"}
{"text": "accessing element at 0 index and setting its value to 5.", "code": "arr [ 0 ] = 5 ;"}
{"text": "access and print value at 0 index we get the output as 5.", "code": "printf ( \" % d \" , arr [ 0 ] ) ; return 0 ; }"}
{"text": "Prototype for utility functions", "code": "void printArray ( int arr [ ] , int size ) ; void swap ( int arr [ ] , int fi , int si , int d ) ; void leftRotate ( int arr [ ] , int d , int n ) {"}
{"text": "Return If number of elements to be rotated is zero or equal to array size", "code": "if ( d == 0 d == n ) return ;"}
{"text": "If number of elements to be rotated is exactly half of array size", "code": "if ( n - d == d ) { swap ( arr , 0 , n - d , d ) ; return ; }"}
{"text": "If A is shorter", "code": "if ( d < n - d ) { swap ( arr , 0 , n - d , d ) ; leftRotate ( arr , d , n - d ) ; }"}
{"text": "If B is shorter", "code": "else { swap ( arr , 0 , d , n - d ) ; leftRotate ( arr + n - d , 2 * d - n , d ) ; } }"}
{"text": "function to print an array", "code": "void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE ▁ \" ) ; }"}
{"text": "This function swaps d elements starting at index fi with d elements starting at index si", "code": "void swap ( int arr [ ] , int fi , int si , int d ) { int i , temp ; for ( i = 0 ; i < d ; i ++ ) { temp = arr [ fi + i ] ; arr [ fi + i ] = arr [ si + i ] ; arr [ si + i ] = temp ; } }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; leftRotate ( arr , 2 , 7 ) ; printArray ( arr , 7 ) ; getchar ( ) ; return 0 ; }"}
{"text": "C code for above implementation", "code": "void leftRotate ( int arr [ ] , int d , int n ) { int i , j ; if ( d == 0 d == n ) return ; i = d ; j = n - d ; while ( i != j ) {"}
{"text": "A is shorter", "code": "if ( i < j ) { swap ( arr , d - i , d + j - i , i ) ; j -= i ; }"}
{"text": "B is shorter", "code": "else { swap ( arr , d - i , d , j ) ; i -= j ; } }"}
{"text": "Finally , block swap A and B", "code": "swap ( arr , d - i , d , i ) ; }"}
{"text": "swap", "code": "void swap ( int * x , int * y ) { int temp = * x ; * x = * y ; * y = temp ; }"}
{"text": "i and j pointing to first and last element respectively", "code": "void rotate ( int arr [ ] , int n ) { int i = 0 , j = n - 1 ; while ( i != j ) { swap ( & arr [ i ] , & arr [ j ] ) ; i ++ ; } }"}
{"text": "Driver code", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } , i ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given ▁ array ▁ is STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; rotate ( arr , n ) ; printf ( \" Rotated array is \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }"}
{"text": "C program to implement selection sort for array of strings .", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define MAX_LEN  100"}
{"text": "Sorts an array of strings where length of every string should be smaller than MAX_LEN", "code": "void selectionSort ( char arr [ ] [ MAX_LEN ] , int n ) { int i , j , min_idx ;"}
{"text": "One by one move boundary of unsorted subarray", "code": "char minStr [ MAX_LEN ] ; for ( i = 0 ; i < n - 1 ; i ++ ) {"}
{"text": "Find the minimum element in unsorted array", "code": "int min_idx = i ; strcpy ( minStr , arr [ i ] ) ; for ( j = i + 1 ; j < n ; j ++ ) {"}
{"text": "If min is greater than arr [ j ]", "code": "if ( strcmp ( minStr , arr [ j ] ) > 0 ) {"}
{"text": "Make arr [ j ] as minStr and update min_idx", "code": "strcpy ( minStr , arr [ j ] ) ; min_idx = j ; } }"}
{"text": "Swap the found minimum element with the first element", "code": "if ( min_idx != i ) { char temp [ MAX_LEN ] ; strcpy ( temp , arr [ i ] ) ; strcpy ( arr [ i ] , arr [ min_idx ] ) ; strcpy ( arr [ min_idx ] , temp ) ; } } }"}
{"text": "Driver code", "code": "int main ( ) { char arr [ ] [ MAX_LEN ] = { \" GeeksforGeeks \" , \" Practice . GeeksforGeeks \" , \" GeeksQuiz \" } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int i ; printf ( \" Given ▁ array ▁ is STRNEWLINE \" ) ;"}
{"text": "Printing the array before sorting", "code": "for ( i = 0 ; i < n ; i ++ ) printf ( \" % d : ▁ % s ▁ STRNEWLINE \" , i , arr [ i ] ) ; selectionSort ( arr , n ) ; printf ( \" Sorted array is \""}
{"text": "Printing the array after sorting", "code": "for ( i = 0 ; i < n ; i ++ ) printf ( \" % d : ▁ % s ▁ STRNEWLINE \" , i , arr [ i ] ) ; return 0 ; }"}
{"text": "A simple C program to rearrange contents of arr [ ] such that arr [ j ] becomes j if arr [ i ] is j", "code": "#include <stdio.h>"}
{"text": "A simple method to rearrange ' arr [ 0 . . n - 1 ] ' so that ' arr [ j ] ' becomes ' i ' if ' arr [ i ] ' is ' j '", "code": "void rearrangeNaive ( int arr [ ] , int n ) {"}
{"text": "Create an auxiliary array of same size", "code": "int temp [ n ] , i ;"}
{"text": "Store result in temp [ ]", "code": "for ( i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] = i ;"}
{"text": "Copy temp back to arr [ ]", "code": "for ( i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }"}
{"text": "A utility function to print contents of arr [ 0. . n - 1 ]", "code": "void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Driver program", "code": "int main ( ) { int arr [ ] = { 1 , 3 , 0 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given ▁ array ▁ is ▁ STRNEWLINE \" ) ; printArray ( arr , n ) ; rearrangeNaive ( arr , n ) ; printf ( \" Modified ▁ array ▁ is ▁ STRNEWLINE \" ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "C program to find maximum in arr [ ] of size n", "code": "#include <stdio.h>"}
{"text": "C function to find maximum in arr [ ] of size n", "code": "int largest ( int arr [ ] , int n ) { int i ;"}
{"text": "Initialize maximum element", "code": "int max = arr [ 0 ] ;"}
{"text": "Traverse array elements from second and compare every element with current max", "code": "for ( i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ ] = { 10 , 324 , 45 , 90 , 9808 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Largest ▁ in ▁ given ▁ array ▁ is ▁ % d \" , largest ( arr , n ) ) ; return 0 ; }"}
{"text": "C program to find second largest element in an array", "code": "#include <limits.h> NEW_LINE #include <stdio.h>"}
{"text": "Function to print the second largest elements", "code": "void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ;"}
{"text": "There should be atleast two elements", "code": "if ( arr_size < 2 ) { printf ( \" ▁ Invalid ▁ Input ▁ \" ) ; return ; } first = second = INT_MIN ; for ( i = 0 ; i < arr_size ; i ++ ) {"}
{"text": "If current element is greater than first then update both first and second", "code": "if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; }"}
{"text": "If arr [ i ] is in between first and second then update second", "code": "else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MIN ) printf ( \" There ▁ is ▁ no ▁ second ▁ largest ▁ element STRNEWLINE \" ) ; else printf ( \" The ▁ second ▁ largest ▁ element ▁ is ▁ % dn \" , second ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2largest ( arr , n ) ; return 0 ; }"}
{"text": "structure is used to return two values from minMax ( )", "code": "#include <stdio.h> NEW_LINE struct pair { int min ; int max ; } ; struct pair getMinMax ( int arr [ ] , int n ) { struct pair minmax ; int i ;"}
{"text": "If there is only one element then return it as min and max both", "code": "if ( n == 1 ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 0 ] ; return minmax ; }"}
{"text": "If there are more than one elements , then initialize min and max", "code": "if ( arr [ 0 ] > arr [ 1 ] ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 1 ] ; } else { minmax . max = arr [ 1 ] ; minmax . min = arr [ 0 ] ; } for ( i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > minmax . max ) minmax . max = arr [ i ] ; else if ( arr [ i ] < minmax . min ) minmax . min = arr [ i ] ; } return minmax ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 1000 , 11 , 445 , 1 , 330 , 3000 } ; int arr_size = 6 ; struct pair minmax = getMinMax ( arr , arr_size ) ; printf ( \" nMinimum ▁ element ▁ is ▁ % d \" , minmax . min ) ; printf ( \" nMaximum ▁ element ▁ is ▁ % d \" , minmax . max ) ; getchar ( ) ; }"}
{"text": "structure is used to return two values from minMax ( )", "code": "struct pair { int min ; int max ; } ; struct pair getMinMax ( int arr [ ] , int n ) { struct pair minmax ; int i ;"}
{"text": "If array has even number of elements then initialize the first two elements as minimum and maximum", "code": "if ( n % 2 == 0 ) { if ( arr [ 0 ] > arr [ 1 ] ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 1 ] ; } else { minmax . min = arr [ 0 ] ; minmax . max = arr [ 1 ] ; }"}
{"text": "set the starting index for loop", "code": "i = 2 ; }"}
{"text": "If array has odd number of elements then initialize the first element as minimum and maximum", "code": "else { minmax . min = arr [ 0 ] ; minmax . max = arr [ 0 ] ;"}
{"text": "set the starting index for loop", "code": "i = 1 ; }"}
{"text": "In the while loop , pick elements in pair and compare the pair with max and min so far", "code": "while ( i < n - 1 ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] > minmax . max ) minmax . max = arr [ i ] ; if ( arr [ i + 1 ] < minmax . min ) minmax . min = arr [ i + 1 ] ; } else { if ( arr [ i + 1 ] > minmax . max ) minmax . max = arr [ i + 1 ] ; if ( arr [ i ] < minmax . min ) minmax . min = arr [ i ] ; } i += 2 ;"}
{"text": "Increment the index by 2 as two elements are processed in loop", "code": "} return minmax ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 1000 , 11 , 445 , 1 , 330 , 3000 } ; int arr_size = 6 ; struct pair minmax = getMinMax ( arr , arr_size ) ; printf ( \" nMinimum ▁ element ▁ is ▁ % d \" , minmax . min ) ; printf ( \" nMaximum ▁ element ▁ is ▁ % d \" , minmax . max ) ; getchar ( ) ; }"}
{"text": "C program to find Minimum number of jumps to reach end", "code": "#include <limits.h> NEW_LINE #include <stdio.h>"}
{"text": "Returns minimum number of jumps to reach arr [ h ] from arr [ l ]", "code": "int minJumps ( int arr [ ] , int l , int h ) {"}
{"text": "Base case : when source and destination are same", "code": "if ( h == l ) return 0 ;"}
{"text": "When nothing is reachable from the given source", "code": "if ( arr [ l ] == 0 ) return INT_MAX ;"}
{"text": "Traverse through all the points reachable from arr [ l ] . Recursively get the minimum number of jumps needed to reach arr [ h ] from these reachable points .", "code": "int min = INT_MAX ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != INT_MAX && jumps + 1 < min ) min = jumps + 1 ; } return min ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach ▁ end ▁ is ▁ % d ▁ \" , minJumps ( arr , 0 , n - 1 ) ) ; return 0 ; }"}
{"text": "Returns length of smallest subarray with sum greater than x . If there is no subarray with given sum , then returns n + 1", "code": "int smallestSubWithSum ( int arr [ ] , int n , int x ) {"}
{"text": "Initialize length of smallest subarray as n + 1", "code": "int min_len = n + 1 ;"}
{"text": "Pick every element as starting point", "code": "for ( int start = 0 ; start < n ; start ++ ) {"}
{"text": "Initialize sum starting with current start", "code": "int curr_sum = arr [ start ] ;"}
{"text": "If first element itself is greater", "code": "if ( curr_sum > x ) return 1 ;"}
{"text": "Try different ending points for curremt start", "code": "for ( int end = start + 1 ; end < n ; end ++ ) {"}
{"text": "add last element to current sum", "code": "curr_sum += arr [ end ] ;"}
{"text": "If sum becomes more than x and length of this subarray is smaller than current smallest length , update the smallest length ( or result )", "code": "if ( curr_sum > x && ( end - start + 1 ) < min_len ) min_len = ( end - start + 1 ) ; } } return min_len ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr1 [ ] = { 1 , 4 , 45 , 6 , 10 , 19 } ; int x = 51 ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int res1 = smallestSubWithSum ( arr1 , n1 , x ) ; ( res1 == n1 + 1 ) ? cout << \" Not ▁ possible STRNEWLINE \" : cout << res1 << endl ; int arr2 [ ] = { 1 , 10 , 5 , 2 , 7 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; x = 9 ; int res2 = smallestSubWithSum ( arr2 , n2 , x ) ; ( res2 == n2 + 1 ) ? cout << \" Not ▁ possible STRNEWLINE \" : cout << res2 << endl ; int arr3 [ ] = { 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; x = 280 ; int res3 = smallestSubWithSum ( arr3 , n3 , x ) ; ( res3 == n3 + 1 ) ? cout << \" Not ▁ possible STRNEWLINE \" : cout << res3 << endl ; return 0 ; }"}
{"text": "C program for different tree traversals", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Given a binary tree , print its nodes according to the \" bottom - up \" postorder traversal .", "code": "void printPostorder ( struct node * node ) { if ( node == NULL ) return ;"}
{"text": "first recur on left subtree", "code": "printPostorder ( node -> left ) ;"}
{"text": "then recur on right subtree", "code": "printPostorder ( node -> right ) ;"}
{"text": "now deal with the node", "code": "printf ( \" % d ▁ \" , node -> data ) ; }"}
{"text": "Given a binary tree , print its nodes in inorder", "code": "void printInorder ( struct node * node ) { if ( node == NULL ) return ;"}
{"text": "first recur on left child", "code": "printInorder ( node -> left ) ;"}
{"text": "then print the data of node", "code": "printf ( \" % d ▁ \" , node -> data ) ;"}
{"text": "now recur on right child", "code": "printInorder ( node -> right ) ; }"}
{"text": "Given a binary tree , print its nodes in preorder", "code": "void printPreorder ( struct node * node ) { if ( node == NULL ) return ;"}
{"text": "first print data of node", "code": "printf ( \" % d ▁ \" , node -> data ) ;"}
{"text": "then recur on left sutree", "code": "printPreorder ( node -> left ) ;"}
{"text": "now recur on right subtree", "code": "printPreorder ( node -> right ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Preorder traversal of binary tree is \" printPreorder ( root ) ; printf ( \" Inorder traversal of binary tree is \" printInorder ( root ) ; printf ( \" Postorder traversal of binary tree is \" printPostorder ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "A Binary Tree Node", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "A utility function to create a new Binary Tree node with given data", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; }"}
{"text": "print the tree in LVR ( Inorder traversal ) way .", "code": "void print ( struct Node * root ) { if ( root != NULL ) { print ( root -> left ) ; printf ( \" % d ▁ \" , root -> data ) ; print ( root -> right ) ; } }"}
{"text": "Main function which truncates the binary tree .", "code": "struct Node * prune ( struct Node * root , int sum ) {"}
{"text": "Base Case", "code": "if ( root == NULL ) return NULL ;"}
{"text": "Recur for left and right subtrees", "code": "root -> left = prune ( root -> left , sum - root -> data ) ; root -> right = prune ( root -> right , sum - root -> data ) ;"}
{"text": "If we reach leaf whose data is smaller than sum , we delete the leaf . An important thing to note is a non - leaf node can become leaf when its chilren are deleted .", "code": "if ( root -> left == NULL && root -> right == NULL ) { if ( root -> data < sum ) { free ( root ) ; return NULL ; } } return root ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int k = 45 ; struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 12 ) ; root -> right -> right -> left = newNode ( 10 ) ; root -> right -> right -> left -> right = newNode ( 11 ) ; root -> left -> left -> right -> left = newNode ( 13 ) ; root -> left -> left -> right -> right = newNode ( 14 ) ; root -> left -> left -> right -> right -> left = newNode ( 15 ) ; printf ( \" Tree ▁ before ▁ truncation STRNEWLINE \" ) ; print ( root ) ;"}
{"text": "C program to Merge an array of size n into another array of size m + n", "code": "#include <stdio.h>"}
{"text": "Assuming - 1 is filled for the places where element is not available", "code": "#define NA  -1"}
{"text": "Function to move m elements at the end of array mPlusN [ ]", "code": "void moveToEnd ( int mPlusN [ ] , int size ) { int i = 0 , j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) if ( mPlusN [ i ] != NA ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } }"}
{"text": "Merges array N [ ] of size n into array mPlusN [ ] of size m + n", "code": "int merge ( int mPlusN [ ] , int N [ ] , int m , int n ) { int i = n ;"}
{"text": "Current index of i / p part of mPlusN [ ]", "code": "int j = 0 ;"}
{"text": "Current index of N [ ]", "code": "int k = 0 ;"}
{"text": "Current index of output mPlusN [ ]", "code": "while ( k < ( m + n ) ) {"}
{"text": "Take an element from mPlusN [ ] if a ) value of the picked element is smaller and we have not reached end of it b ) We have reached end of N [ ]", "code": "if ( ( j == n ) || ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; }"}
{"text": "Otherwise take element from N [ ]", "code": "else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } }"}
{"text": "Utility that prints out an array on a line", "code": "void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Driver code", "code": "int main ( ) {"}
{"text": "Initialize arrays", "code": "int mPlusN [ ] = { 2 , 8 , NA , NA , NA , 13 , NA , 15 , 20 } ; int N [ ] = { 5 , 7 , 9 , 25 } ; int n = sizeof ( N ) / sizeof ( N [ 0 ] ) ; int m = sizeof ( mPlusN ) / sizeof ( mPlusN [ 0 ] ) - n ;"}
{"text": "Move the m elements at the end of mPlusN", "code": "moveToEnd ( mPlusN , m + n ) ;"}
{"text": "Merge N [ ] into mPlusN [ ]", "code": "merge ( mPlusN , N , m , n ) ;"}
{"text": "Print the resultant mPlusN", "code": "printArray ( mPlusN , m + n ) ; return 0 ; }"}
{"text": "C program to implement the above approach", "code": "#include <stdio.h>"}
{"text": "Function to find maximum between two numbers", "code": "int max ( int num1 , int num2 ) { return ( num1 > num2 ) ? num1 : num2 ; }"}
{"text": "Function to find minimum between two numbers", "code": "int min ( int num1 , int num2 ) { return ( num1 > num2 ) ? num2 : num1 ; }"}
{"text": "Function to return the count of such numbers", "code": "int getCount ( int n , int k ) {"}
{"text": "For 1 - digit numbers , the count is 10 irrespective of K", "code": "if ( n == 1 ) return 10 ;"}
{"text": "dp [ j ] stores the number of such i - digit numbers ending with j", "code": "int dp [ 11 ] = { 0 } ;"}
{"text": "Stores the results of length i", "code": "int next [ 11 ] = { 0 } ;"}
{"text": "Initialize count for 1 - digit numbers", "code": "for ( int i = 1 ; i <= 9 ; i ++ ) dp [ i ] = 1 ;"}
{"text": "Compute values for count of digits greater than 1", "code": "for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) {"}
{"text": "Find the range of allowed numbers if last digit is j", "code": "int l = max ( 0 , ( j - k ) ) ; int r = min ( 9 , ( j + k ) ) ;"}
{"text": "Perform Range update", "code": "next [ l ] += dp [ j ] ; next [ r + 1 ] -= dp [ j ] ; }"}
{"text": "Prefix sum to find actual count of i - digit numbers ending with j", "code": "for ( int j = 1 ; j <= 9 ; j ++ ) next [ j ] += next [ j - 1 ] ;"}
{"text": "Update dp [ ]", "code": "for ( int j = 0 ; j < 10 ; j ++ ) { dp [ j ] = next [ j ] ; next [ j ] = 0 ; } }"}
{"text": "Stores the final answer", "code": "int count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ i ] ;"}
{"text": "Return the final answer", "code": "return count ; }"}
{"text": "Driver Code", "code": "int main ( ) { int n = 2 , k = 1 ; printf ( \" % d \" , getCount ( n , k ) ) ; }"}
{"text": "C program to Count Inversions in an array", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" ▁ Number ▁ of ▁ inversions ▁ are ▁ % d ▁ STRNEWLINE \" , getInvCount ( arr , n ) ) ; return 0 ; }"}
{"text": "C code to find Two elements whose sum is closest to zero", "code": "# include <stdio.h> NEW_LINE # include <stdlib.h> NEW_LINE # include <math.h> NEW_LINE void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ;"}
{"text": "Array should have at least two elements", "code": "if ( arr_size < 2 ) { printf ( \" Invalid ▁ Input \" ) ; return ; }"}
{"text": "Initialization of values", "code": "min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( abs ( min_sum ) > abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } printf ( \" ▁ The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are ▁ % d ▁ and ▁ % d \" , arr [ min_l ] , arr [ min_r ] ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 1 , 60 , -10 , 70 , -80 , 85 } ; minAbsSumPair ( arr , 6 ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find union of two sorted arrays", "code": "#include <stdio.h>"}
{"text": "Function prints union of arr1 [ ] and arr2 [ ] m is the number of elements in arr1 [ ] n is the number of elements in arr2 [ ]", "code": "void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) printf ( \" ▁ % d ▁ \" , arr1 [ i ++ ] ) ; else if ( arr2 [ j ] < arr1 [ i ] ) printf ( \" ▁ % d ▁ \" , arr2 [ j ++ ] ) ; else { printf ( \" ▁ % d ▁ \" , arr2 [ j ++ ] ) ; i ++ ; } }"}
{"text": "Print remaining elements of the larger array", "code": "while ( i < m ) printf ( \" ▁ % d ▁ \" , arr1 [ i ++ ] ) ; while ( j < n ) printf ( \" ▁ % d ▁ \" , arr2 [ j ++ ] ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printUnion ( arr1 , arr2 , m , n ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find intersection of two sorted arrays", "code": "#include <stdio.h>"}
{"text": "Function prints Intersection of arr1 [ ] and arr2 [ ] m is the number of elements in arr1 [ ] n is the number of elements in arr2 [ ]", "code": "void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else { printf ( \" ▁ % d ▁ \" , arr2 [ j ++ ] ) ; i ++ ; } } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ;"}
{"text": "Function calling", "code": "printIntersection ( arr1 , arr2 , m , n ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find maximum sum leaf to root path in Binary Tree", "code": "#include <limits.h> NEW_LINE #include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A tree node structure", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "A utility function that prints all nodes on the path from root to target_leaf", "code": "bool printPath ( struct node * root , struct node * target_leaf ) {"}
{"text": "base case", "code": "if ( root == NULL ) return false ;"}
{"text": "return true if this node is the target_leaf or target leaf is present in one of its descendants", "code": "if ( root == target_leaf || printPath ( root -> left , target_leaf ) || printPath ( root -> right , target_leaf ) ) { printf ( \" % d ▁ \" , root -> data ) ; return true ; } return false ; }"}
{"text": "This function Sets the target_leaf_ref to refer the leaf node of the maximum path sum . Also , returns the max_sum using max_sum_ref", "code": "void getTargetLeaf ( struct node * node , int * max_sum_ref , int curr_sum , struct node * * target_leaf_ref ) { if ( node == NULL ) return ;"}
{"text": "Update current sum to hold sum of nodes on path from root to this node", "code": "curr_sum = curr_sum + node -> data ;"}
{"text": "If this is a leaf node and path to this node has maximum sum so far , then make this node target_leaf", "code": "if ( node -> left == NULL && node -> right == NULL ) { if ( curr_sum > * max_sum_ref ) { * max_sum_ref = curr_sum ; * target_leaf_ref = node ; } }"}
{"text": "If this is not a leaf node , then recur down to find the target_leaf", "code": "getTargetLeaf ( node -> left , max_sum_ref , curr_sum , target_leaf_ref ) ; getTargetLeaf ( node -> right , max_sum_ref , curr_sum , target_leaf_ref ) ; }"}
{"text": "Returns the maximum sum and prints the nodes on max sum path", "code": "int maxSumPath ( struct node * node ) {"}
{"text": "base case", "code": "if ( node == NULL ) return 0 ; struct node * target_leaf ; int max_sum = INT_MIN ;"}
{"text": "find the target leaf and maximum sum", "code": "getTargetLeaf ( node , & max_sum , 0 , & target_leaf ) ;"}
{"text": "print the path from root to the target leaf", "code": "printPath ( node , target_leaf ) ;"}
{"text": "return maximum sum", "code": "return max_sum ; }"}
{"text": "Utility function to create a new Binary Tree node", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; }"}
{"text": "Driver function to test above functions", "code": "int main ( ) { struct node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( -2 ) ; root -> right = newNode ( 7 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( -4 ) ; printf ( \" Following ▁ are ▁ the ▁ nodes ▁ on ▁ the ▁ maximum ▁ \" \" sum ▁ path ▁ STRNEWLINE \" ) ; int sum = maxSumPath ( root ) ; printf ( \" Sum of the nodes is % d \" , sum ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to sort an array with 0 , 1 and 2 in a single pass", "code": "#include <stdio.h>"}
{"text": "Function to swap * a and * b", "code": "void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; }"}
{"text": "Sort the input array , the array is assumed to have values in { 0 , 1 , 2 }", "code": "void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : swap ( & a [ lo ++ ] , & a [ mid ++ ] ) ; break ; case 1 : mid ++ ; break ; case 2 : swap ( & a [ mid ] , & a [ hi -- ] ) ; break ; } } }"}
{"text": "Utility function to print array arr [ ]", "code": "void printArray ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" n \" ) ; }"}
{"text": "driver program to test", "code": "int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int i ; sort012 ( arr , arr_size ) ; printf ( \" array ▁ after ▁ segregation ▁ \" ) ; printArray ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find the Minimum length Unsorted Subarray , sorting which makes the complete array sorted", "code": "#include <stdio.h> NEW_LINE void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ;"}
{"text": "step 1 ( a ) of above algo", "code": "for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { printf ( \" The ▁ complete ▁ array ▁ is ▁ sorted \" ) ; return ; }"}
{"text": "step 1 ( b ) of above algo", "code": "for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; }"}
{"text": "step 2 ( a ) of above algo", "code": "max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; }"}
{"text": "step 2 ( b ) of above algo", "code": "for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } }"}
{"text": "step 2 ( c ) of above algo", "code": "for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } }"}
{"text": "step 3 of above algo", "code": "printf ( \" ▁ The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ the ▁ given ▁ array ▁ \" \" ▁ sorted ▁ lies ▁ between ▁ the ▁ indees ▁ % d ▁ and ▁ % d \" , s , e ) ; return ; } int main ( ) { int arr [ ] = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printUnsorted ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to count number of triangles that can be formed from given array", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Following function is needed for library function qsort ( ) . Refer www . cplusplus . com / reference / clibrary / cstdlib / qsort /", "code": "http : int comp ( const void * a , const void * b ) { return * ( int * ) a > * ( int * ) b ; }"}
{"text": "Function to count all possible triangles with arr [ ] elements", "code": "int findNumberOfTriangles ( int arr [ ] , int n ) {"}
{"text": "Sort the array elements in non - decreasing order", "code": "qsort ( arr , n , sizeof ( arr [ 0 ] ) , comp ) ;"}
{"text": "Initialize count of triangles", "code": "int count = 0 ;"}
{"text": "Fix the first element . We need to run till n - 3 as the other two elements are selected from arr [ i + 1. . . n - 1 ]", "code": "for ( int i = 0 ; i < n - 2 ; ++ i ) {"}
{"text": "Initialize index of the rightmost third element", "code": "int k = i + 2 ;"}
{"text": "Fix the second element", "code": "for ( int j = i + 1 ; j < n ; ++ j ) {"}
{"text": "Find the rightmost element which is smaller than the sum of two fixed elements The important thing to note here is , we use the previous value of k . If value of arr [ i ] + arr [ j - 1 ] was greater than arr [ k ] , then arr [ i ] + arr [ j ] must be greater than k , because the array is sorted .", "code": "while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ;"}
{"text": "Total number of possible triangles that can be formed with the two fixed elements is k - j - 1. The two fixed elements are arr [ i ] and arr [ j ] . All elements between arr [ j + 1 ] / to arr [ k - 1 ] can form a triangle with arr [ i ] and arr [ j ] . One is subtracted from k because k is incremented one extra in above while loop . k will always be greater than j . If j becomes equal to k , then above loop will increment k , because arr [ k ] + arr [ i ] is always greater than arr [ k ]", "code": "if ( k > j ) count += k - j - 1 ; } } return count ; }"}
{"text": "Driver program to test above functionarr [ j + 1 ]", "code": "int main ( ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Total ▁ number ▁ of ▁ triangles ▁ possible ▁ is ▁ % d ▁ \" , findNumberOfTriangles ( arr , size ) ) ; return 0 ; }"}
{"text": "C program to implement linear search in unsorted array", "code": "#include <stdio.h>"}
{"text": "Function to implement search operation", "code": "int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return -1 ; }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ ] = { 12 , 34 , 10 , 6 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Using a last element as search element", "code": "int key = 40 ; int position = findElement ( arr , n , key ) ; if ( position == - 1 ) printf ( \" Element ▁ not ▁ found \" ) ; else printf ( \" Element ▁ Found ▁ at ▁ Position : ▁ % d \" , position + 1 ) ; return 0 ; }"}
{"text": "C program to implement insert operation in an unsorted array .", "code": "#include <stdio.h>"}
{"text": "Inserts a key in arr [ ] of given capacity . n is current size of arr [ ] . This function returns n + 1 if insertion is successful , else n .", "code": "int insertSorted ( int arr [ ] , int n , int key , int capacity ) {"}
{"text": "Cannot insert more elements if n is already more than or equal to capcity", "code": "if ( n >= capacity ) return n ; arr [ n ] = key ; return ( n + 1 ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ 20 ] = { 12 , 16 , 20 , 40 , 50 , 70 } ; int capacity = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 6 ; int i , key = 26 ; printf ( \" Before Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ;"}
{"text": "Inserting key", "code": "n = insertSorted ( arr , n , key , capacity ) ; printf ( \" After Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }"}
{"text": "C program to implement delete operation in a unsorted array", "code": "#include <stdio.h>"}
{"text": "Function to implement search operation", "code": "int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }"}
{"text": "Function to delete an element", "code": "int deleteElement ( int arr [ ] , int n , int key ) {"}
{"text": "Find position of element to be deleted", "code": "int pos = findElement ( arr , n , key ) ; if ( pos == - 1 ) { printf ( \" Element ▁ not ▁ found \" ) ; return n ; }"}
{"text": "Deleting element", "code": "int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; }"}
{"text": "Driver code", "code": "int main ( ) { int i ; int arr [ ] = { 10 , 50 , 30 , 40 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 30 ; printf ( \" Array ▁ before ▁ deletion STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; n = deleteElement ( arr , n , key ) ; printf ( \" Array after deletion \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }"}
{"text": "C program to implement binary search in sorted array", "code": "#include <stdio.h>"}
{"text": "function to implement binary search", "code": "int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ;"}
{"text": "low + ( high - low ) / 2 ;", "code": "if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }"}
{"text": "Driver Code Let us search 3 in below array", "code": "int main ( ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n , key ; n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; key = 10 ; printf ( \" Index : ▁ % d STRNEWLINE \" , binarySearch ( arr , 0 , n - 1 , key ) ) ; return 0 ; }"}
{"text": "C program to implement insert operation in an sorted array .", "code": "#include <stdio.h>"}
{"text": "Inserts a key in arr [ ] of given capacity . n is current size of arr [ ] . This function returns n + 1 if insertion is successful , else n .", "code": "int insertSorted ( int arr [ ] , int n , int key , int capacity ) {"}
{"text": "Cannot insert more elements if n is already more than or equal to capcity", "code": "if ( n >= capacity ) return n ; int i ; for ( i = n - 1 ; ( i >= 0 && arr [ i ] > key ) ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ 20 ] = { 12 , 16 , 20 , 40 , 50 , 70 } ; int capacity = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 6 ; int i , key = 26 ; printf ( \" Before Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ;"}
{"text": "Inserting key", "code": "n = insertSorted ( arr , n , key , capacity ) ; printf ( \" After Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }"}
{"text": "C program to implement delete operation in a sorted array", "code": "#include <stdio.h>"}
{"text": "To search a ley to be deleted", "code": "int binarySearch ( int arr [ ] , int low , int high , int key ) ; int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }"}
{"text": "Function to delete an element", "code": "int deleteElement ( int arr [ ] , int n , int key ) {"}
{"text": "Find position of element to be deleted", "code": "int pos = binarySearch ( arr , 0 , n - 1 , key ) ; if ( pos == -1 ) { printf ( \" Element ▁ not ▁ found \" ) ; return n ; }"}
{"text": "Deleting element", "code": "int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; }"}
{"text": "Driver code", "code": "int main ( ) { int i ; int arr [ ] = { 10 , 20 , 30 , 40 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 30 ; printf ( \" Array ▁ before ▁ deletion STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; n = deleteElement ( arr , n , key ) ; printf ( \" Array after deletion \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "C program to find equilibrium index of an array", "code": "#include <stdio.h>"}
{"text": "function to find the equilibrium index", "code": "int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ;"}
{"text": "Check for indexes one by one until an equilibrium index is found", "code": "for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ;"}
{"text": "get left sum", "code": "for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ;"}
{"text": "get right sum", "code": "for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ;"}
{"text": "if leftsum and rightsum are same , then we are done", "code": "if ( leftsum == rightsum ) return i ; }"}
{"text": "return - 1 if no equilibrium index is found", "code": "return -1 ; }"}
{"text": "Driver code", "code": "int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d \" , equilibrium ( arr , arr_size ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find equilibrium index of an array", "code": "#include <stdio.h>"}
{"text": "function to find the equilibrium index", "code": "int equilibrium ( int arr [ ] , int n ) {"}
{"text": "initialize sum of whole array", "code": "int sum = 0 ;"}
{"text": "initialize leftsum", "code": "int leftsum = 0 ;"}
{"text": "Find sum of the whole array", "code": "for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) {"}
{"text": "sum is now right sum for index i", "code": "sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; }"}
{"text": "If no equilibrium index found , then return 0", "code": "return -1 ; }"}
{"text": "Driver code", "code": "int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" First ▁ equilibrium ▁ index ▁ is ▁ % d \" , equilibrium ( arr , arr_size ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Function to get index of ceiling of x in arr [ low . . high ]", "code": "int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ;"}
{"text": "If x is smaller than or equal to first element , then return the first element", "code": "if ( x <= arr [ low ] ) return low ;"}
{"text": "Otherwise , linearly search for ceil value", "code": "for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ;"}
{"text": "if x lies between arr [ i ] and arr [ i + 1 ] including arr [ i + 1 ] , then return arr [ i + 1 ]", "code": "if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; }"}
{"text": "If we reach here then x is greater than the last element of the array , return - 1 in this case", "code": "return -1 ; }"}
{"text": "Driver program to check above functions", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) printf ( \" Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ \" , x ) ; else printf ( \" ceiling ▁ of ▁ % d ▁ is ▁ % d \" , x , arr [ index ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Function to get index of ceiling of x in arr [ low . . high ]", "code": "int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ;"}
{"text": "If x is smaller than or equal to the first element , then return the first element", "code": "if ( x <= arr [ low ] ) return low ;"}
{"text": "If x is greater than the last element , then return - 1", "code": "if ( x > arr [ high ] ) return -1 ;"}
{"text": "get the index of middle element of arr [ low . . high ]", "code": "mid = ( low + high ) / 2 ;"}
{"text": "If x is same as middle element , then return mid", "code": "if ( arr [ mid ] == x ) return mid ;"}
{"text": "If x is greater than arr [ mid ] , then either arr [ mid + 1 ] is ceiling of x or ceiling lies in arr [ mid + 1. . . high ]", "code": "else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; }"}
{"text": "If x is smaller than arr [ mid ] , then either arr [ mid ] is ceiling of x or ceiling lies in arr [ low ... mid - 1 ]", "code": "else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }"}
{"text": "Driver program to check above functions", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 20 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) printf ( \" Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ \" , x ) ; else printf ( \" ceiling ▁ of ▁ % d ▁ is ▁ % d \" , x , arr [ index ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Naive solution to find if there is a pair in A [ 0. . N - 1 ] with given sum .", "code": "#include <stdio.h> NEW_LINE int isPairSum ( int A [ ] , int N , int X ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) {"}
{"text": "as equal i and j means same element", "code": "if ( i == j ) continue ;"}
{"text": "pair exists", "code": "if ( A [ i ] + A [ j ] == X ) return true ;"}
{"text": "as the array is sorted", "code": "if ( A [ i ] + A [ j ] > X ) break ; } }"}
{"text": "No pair found with given sum .", "code": "return 0 ; }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ ] = { 3 , 5 , 9 , 2 , 8 , 10 , 11 } ; int val = 17 ; int arrSize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Function call", "code": "printf ( \" % d \" , isPairSum ( arr , arrSize , val ) ) ; return 0 ; }"}
{"text": "Two pointer technique based solution to find if there is a pair in A [ 0. . N - 1 ] with a given sum .", "code": "int isPairSum ( int A [ ] , int N , int X ) {"}
{"text": "represents first pointer", "code": "int i = 0 ;"}
{"text": "represents second pointer", "code": "int j = N - 1 ; while ( i < j ) {"}
{"text": "If we find a pair", "code": "if ( A [ i ] + A [ j ] == X ) return 1 ;"}
{"text": "If sum of elements at current pointers is less , we move towards higher values by doing i ++", "code": "else if ( A [ i ] + A [ j ] < X ) i ++ ;"}
{"text": "If sum of elements at current pointers is more , we move towards lower values by doing j --", "code": "else j -- ; } return 0 ; }"}
{"text": "Driver code", "code": "int main ( ) {"}
{"text": "array declaration", "code": "int arr [ ] = { 3 , 5 , 9 , 2 , 8 , 10 , 11 } ;"}
{"text": "value to search", "code": "int val = 17 ;"}
{"text": "size of the array", "code": "int arrSize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Function call", "code": "printf ( \" % d \" , isPairSum ( arr , arrSize , val ) ) ; return 0 ; }"}
{"text": "A C program to find minimum possible time by the car chassis to complete", "code": "#include <stdio.h> NEW_LINE #define NUM_LINE  2 NEW_LINE #define NUM_STATION  4"}
{"text": "Utility function to find minimum of two numbers", "code": "int min ( int a , int b ) { return a < b ? a : b ; } int carAssembly ( int a [ ] [ NUM_STATION ] , int t [ ] [ NUM_STATION ] , int * e , int * x ) { int T1 [ NUM_STATION ] , T2 [ NUM_STATION ] , i ;"}
{"text": "time taken to leave first station in line 1", "code": "T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;"}
{"text": "time taken to leave first station in line 2", "code": "T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;"}
{"text": "Fill tables T1 [ ] and T2 [ ] using the above given recursive relations", "code": "for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; }"}
{"text": "Consider exit times and retutn minimum", "code": "return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int a [ ] [ NUM_STATION ] = { { 4 , 5 , 3 , 2 } , { 2 , 10 , 1 , 4 } } ; int t [ ] [ NUM_STATION ] = { { 0 , 7 , 4 , 5 } , { 0 , 9 , 2 , 8 } } ; int e [ ] = { 10 , 12 } , x [ ] = { 18 , 7 } ; printf ( \" % d \" , carAssembly ( a , t , e , x ) ) ; return 0 ; }"}
{"text": "A Dynamic Programming based program to find minimum number insertions needed to make a string palindrome", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "A utility function to find minimum of two integers", "code": "int min ( int a , int b ) { return a < b ? a : b ; }"}
{"text": "A DP function to find minimum number of insertions", "code": "int findMinInsertionsDP ( char str [ ] , int n ) {"}
{"text": "Create a table of size n * n . table [ i ] [ j ] will store minimum number of insertions needed to convert str [ i . . j ] to a palindrome .", "code": "int table [ n ] [ n ] , l , h , gap ; memset ( table , 0 , sizeof ( table ) ) ;"}
{"text": "Fill the table", "code": "for ( gap = 1 ; gap < n ; ++ gap ) for ( l = 0 , h = gap ; h < n ; ++ l , ++ h ) table [ l ] [ h ] = ( str [ l ] == str [ h ] ) ? table [ l + 1 ] [ h - 1 ] : ( min ( table [ l ] [ h - 1 ] , table [ l + 1 ] [ h ] ) + 1 ) ;"}
{"text": "Return minimum number of insertions for str [ 0. . n - 1 ]", "code": "return table [ 0 ] [ n - 1 ] ; }"}
{"text": "Driver program to test above function .", "code": "int main ( ) { char str [ ] = \" geeks \" ; printf ( \" % d \" , findMinInsertionsDP ( str , strlen ( str ) ) ) ; return 0 ; }"}
{"text": "A naive recursive implementation of Largest Independent Set problem", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A utility function to find max of two integers", "code": "int max ( int x , int y ) { return ( x > y ) ? x : y ; }"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "The function returns size of the largest independent set in a given binary tree", "code": "int LISS ( struct node * root ) { if ( root == NULL ) return 0 ;"}
{"text": "Calculate size excluding the current node", "code": "int size_excl = LISS ( root -> left ) + LISS ( root -> right ) ;"}
{"text": "Calculate size including the current node", "code": "int size_incl = 1 ; if ( root -> left ) size_incl += LISS ( root -> left -> left ) + LISS ( root -> left -> right ) ; if ( root -> right ) size_incl += LISS ( root -> right -> left ) + LISS ( root -> right -> right ) ;"}
{"text": "Return the maximum of two sizes", "code": "return max ( size_incl , size_excl ) ; }"}
{"text": "A utility function to create a node", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Let us construct the tree given in the above diagram", "code": "struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printf ( \" Size ▁ of ▁ the ▁ Largest ▁ Independent ▁ Set ▁ is ▁ % d ▁ \" , LISS ( root ) ) ; return 0 ; }"}
{"text": "This function assumes that arr [ ] is sorted in increasing order according the first ( or smaller ) values in pairs .", "code": "int maxChainLength ( struct pair arr [ ] , int n ) { int i , j , max = 0 ; int * mcl = ( int * ) malloc ( sizeof ( int ) * n ) ;"}
{"text": "Initialize MCL ( max chain length ) values for all indexes", "code": "for ( i = 0 ; i < n ; i ++ ) mcl [ i ] = 1 ;"}
{"text": "Compute optimized chain length values in bottom up manner", "code": "for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] . a > arr [ j ] . b && mcl [ i ] < mcl [ j ] + 1 ) mcl [ i ] = mcl [ j ] + 1 ;"}
{"text": "Pick maximum of all MCL values", "code": "for ( i = 0 ; i < n ; i ++ ) if ( max < mcl [ i ] ) max = mcl [ i ] ; free ( mcl ) ; return max ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { struct pair arr [ ] = { { 5 , 24 } , { 15 , 25 } , { 27 , 40 } , { 50 , 60 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Length ▁ of ▁ maximum ▁ size ▁ chain ▁ is ▁ % d STRNEWLINE \" , maxChainLength ( arr , n ) ) ; return 0 ; }"}
{"text": "Dynamic Programming Solution for Palindrome Partitioning Problem", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return ( a < b ) ? a : b ; }"}
{"text": "Returns the minimum number of cuts needed to partition a string such that every part is a palindrome", "code": "int minPalPartion ( char * str ) {"}
{"text": "Get the length of the string", "code": "int n = strlen ( str ) ;"}
{"text": "Create two arrays to build the solution in bottom up manner C [ i ] [ j ] = Minimum number of cuts needed for palindrome partitioning of substring str [ i . . j ] P [ i ] [ j ] = true if substring str [ i . . j ] is palindrome , else false Note that C [ i ] [ j ] is 0 if P [ i ] [ j ] is true", "code": "int C [ n ] [ n ] ; bool P [ n ] [ n ] ;"}
{"text": "different looping variables", "code": "int i , j , k , L ;"}
{"text": "Every substring of length 1 is a palindrome", "code": "for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; }"}
{"text": "L is substring length . Build the solution in bottom up manner by considering all substrings of length starting from 2 to n . The loop structure is same as Matrix Chain Multiplication problem ( See https : www . geeksforgeeks . org / matrix - chain - multiplication - dp - 8 / )", "code": "for ( L = 2 ; L <= n ; L ++ ) {"}
{"text": "For substring of length L , set different possible starting indexes", "code": "for ( i = 0 ; i < n - L + 1 ; i ++ ) {"}
{"text": "Set ending index", "code": "j = i + L - 1 ;"}
{"text": "If L is 2 , then we just need to compare two characters . Else need to check two corner characters and value of P [ i + 1 ] [ j - 1 ]", "code": "if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] ) ; else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ] ;"}
{"text": "IF str [ i . . j ] is palindrome , then C [ i ] [ j ] is 0", "code": "if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else {"}
{"text": "Make a cut at every possible location starting from i to j , and get the minimum cost cut .", "code": "C [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } }"}
{"text": "Return the min cut value for complete string . i . e . , str [ 0. . n - 1 ]", "code": "return C [ 0 ] [ n - 1 ] ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char str [ ] = \" ababbbabbababa \" ; printf ( \" Min ▁ cuts ▁ needed ▁ for ▁ Palindrome ▁ Partitioning ▁ is ▁ % d \" , minPalPartion ( str ) ) ; return 0 ; }"}
{"text": "C Program for Bad Character Heuristic of Boyer Moore String Matching Algorithm", "code": "# include <limits.h> NEW_LINE # include <string.h> NEW_LINE # include <stdio.h> NEW_LINE # define NO_OF_CHARS  256"}
{"text": "A utility function to get maximum of two integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "The preprocessing function for Boyer Moore 's bad character heuristic", "code": "void badCharHeuristic ( char * str , int size , int badchar [ NO_OF_CHARS ] ) { int i ;"}
{"text": "Initialize all occurrences as - 1", "code": "for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) badchar [ i ] = -1 ;"}
{"text": "Fill the actual value of last occurrence of a character", "code": "for ( i = 0 ; i < size ; i ++ ) badchar [ ( int ) str [ i ] ] = i ; }"}
{"text": "A pattern searching function that uses Bad Character Heuristic of Boyer Moore Algorithm", "code": "void search ( char * txt , char * pat ) { int m = strlen ( pat ) ; int n = strlen ( txt ) ; int badchar [ NO_OF_CHARS ] ;"}
{"text": "Fill the bad character array by calling the preprocessing function badCharHeuristic ( ) for given pattern", "code": "badCharHeuristic ( pat , m , badchar ) ;"}
{"text": "s is shift of the pattern with respect to text", "code": "int s = 0 ; while ( s <= ( n - m ) ) { int j = m - 1 ;"}
{"text": "Keep reducing index j of pattern while characters of pattern and text are matching at this shift s", "code": "while ( j >= 0 && pat [ j ] == txt [ s + j ] ) j -- ;"}
{"text": "If the pattern is present at current shift , then index j will become - 1 after the above loop", "code": "if ( j < 0 ) { printf ( \" pattern occurs at shift = % d \""}
{"text": "Shift the pattern so that the next character in text aligns with the last occurrence of it in pattern . The condition s + m < n is necessary for the case when pattern occurs at the end of text", "code": "s += ( s + m < n ) ? m - badchar [ txt [ s + m ] ] : 1 ; } else"}
{"text": "Shift the pattern so that the bad character in text aligns with the last occurrence of it in pattern . The max function is used to make sure that we get a positive shift . We may get a negative shift if the last occurrence of bad character in pattern is on the right side of the current character .", "code": "s += max ( 1 , j - badchar [ txt [ s + j ] ] ) ; } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char txt [ ] = \" ABAAABCD \" ; char pat [ ] = \" ABC \" ; search ( txt , pat ) ; return 0 ; }"}
{"text": "A recursive program to find difference between sum of nodes at odd level and sum at even level", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Binary Tree node", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "A utility function to allocate a new tree node with given data", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; }"}
{"text": "The main function that return difference between odd and even level nodes", "code": "int getLevelDiff ( struct node * root ) {"}
{"text": "Base case", "code": "if ( root == NULL ) return 0 ;"}
{"text": "Difference for root is root 's data - difference for  left subtree - difference for right subtree", "code": "return root -> data - getLevelDiff ( root -> left ) - getLevelDiff ( root -> right ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { struct node * root = newNode ( 5 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; root -> left -> right -> left = newNode ( 3 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 7 ) ; printf ( \" % d ▁ is ▁ the ▁ required ▁ difference STRNEWLINE \" , getLevelDiff ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Given a tree and a sum , return true if there is a path from the root down to a leaf , such that adding up all the values along the path equals the given sum . Strategy : subtract the node value from the sum when recurring down , and check to see if the sum is 0 when you run out of tree .", "code": "bool hasPathSum ( struct node * node , int sum ) { if ( node == NULL ) { return ( sum == 0 ) ; } else { bool ans = 0 ; int subSum = sum - node -> data ; if ( subSum == 0 && node -> left == NULL && node -> right == NULL ) return 1 ; if ( node -> left ) ans = ans || hasPathSum ( node -> left , subSum ) ; if ( node -> right ) ans = ans || hasPathSum ( node -> right , subSum ) ; return ans ; } }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int sum = 21 ;"}
{"text": "Constructed binary tree is 10 / \\ 8 2 / \\ / 3 5 2", "code": "struct node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ; root -> left -> right = newnode ( 5 ) ; root -> right -> left = newnode ( 2 ) ; if ( hasPathSum ( root , sum ) ) printf ( \" There ▁ is ▁ a ▁ root - to - leaf ▁ path ▁ with ▁ sum ▁ % d \" , sum ) ; else printf ( \" There ▁ is ▁ no ▁ root - to - leaf ▁ path ▁ with ▁ sum ▁ % d \" , sum ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find sum of all paths from root to leaves", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ;"}
{"text": "function to allocate new node with given data", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; }"}
{"text": "Returns sum of all root to leaf paths . The first parameter is root of current subtree , the second parameter is value of the number formed by nodes from root to this node", "code": "int treePathsSumUtil ( struct node * root , int val ) {"}
{"text": "Base case", "code": "if ( root == NULL ) return 0 ;"}
{"text": "Update val", "code": "val = ( val * 10 + root -> data ) ;"}
{"text": "if current node is leaf , return the current value of val", "code": "if ( root -> left == NULL && root -> right == NULL ) return val ;"}
{"text": "recur sum of values for left and right subtree", "code": "return treePathsSumUtil ( root -> left , val ) + treePathsSumUtil ( root -> right , val ) ; }"}
{"text": "A wrapper function over treePathsSumUtil ( )", "code": "int treePathsSum ( struct node * root ) {"}
{"text": "Pass the initial value as 0 as there is nothing above root", "code": "return treePathsSumUtil ( root , 0 ) ; }"}
{"text": "Driver function to test the above functions", "code": "int main ( ) { struct node * root = newNode ( 6 ) ; root -> left = newNode ( 3 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 2 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 4 ) ; root -> left -> right -> left = newNode ( 7 ) ; root -> left -> right -> right = newNode ( 4 ) ; printf ( \" Sum ▁ of ▁ all ▁ paths ▁ is ▁ % d \" , treePathsSum ( root ) ) ; return 0 ; }"}
{"text": "C ++ program to find lowest common ancestor using parent pointer", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "A Tree Node", "code": "struct Node { Node * left , * right , * parent ; int key ; } ;"}
{"text": "A utility function to create a new BST node", "code": "Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> parent = temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "A utility function to insert a new node with given key in Binary Search Tree", "code": "Node * insert ( Node * node , int key ) {"}
{"text": "If the tree is empty , return a new node", "code": "if ( node == NULL ) return newNode ( key ) ;"}
{"text": "Otherwise , recur down the tree", "code": "if ( key < node -> key ) { node -> left = insert ( node -> left , key ) ; node -> left -> parent = node ; } else if ( key > node -> key ) { node -> right = insert ( node -> right , key ) ; node -> right -> parent = node ; }"}
{"text": "return the ( unchanged ) node pointer", "code": "return node ; }"}
{"text": "To find LCA of nodes n1 and n2 in Binary Tree", "code": "Node * LCA ( Node * n1 , Node * n2 ) {"}
{"text": "Creata a map to store ancestors of n1", "code": "map < Node * , bool > ancestors ;"}
{"text": "Insert n1 and all its ancestors in map", "code": "while ( n1 != NULL ) { ancestors [ n1 ] = true ; n1 = n1 -> parent ; }"}
{"text": "Check if n2 or any of its ancestors is in map .", "code": "while ( n2 != NULL ) { if ( ancestors . find ( n2 ) != ancestors . end ( ) ) return n2 ; n2 = n2 -> parent ; } return NULL ; }"}
{"text": "Driver method to test above functions", "code": "int main ( void ) { Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 8 ) ; root = insert ( root , 22 ) ; root = insert ( root , 4 ) ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 14 ) ; Node * n1 = root -> left -> right -> left ; Node * n2 = root -> left ; Node * lca = LCA ( n1 , n2 ) ; printf ( \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , n1 -> key , n2 -> key , lca -> key ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h>"}
{"text": "Function to return minimum number of chocolates", "code": "int minChocolates ( int a [ ] , int n ) { int i = 0 , j = 0 ; int res = 0 , val = 1 ; while ( j < n - 1 ) { if ( a [ j ] > a [ j + 1 ] ) {"}
{"text": "decreasing sequence", "code": "j += 1 ; continue ; } if ( i == j )"}
{"text": "add the chocolates received by that person", "code": "res += val ; else {"}
{"text": "end point of decreasing sequence", "code": "res += get_sum ( val , i , j ) ;"}
{"text": "val = 1 ; reset value at that index", "code": "} if ( a [ j ] < a [ j + 1 ] )"}
{"text": "increasing sequence", "code": "val += 1 ; else"}
{"text": "flat sequence", "code": "val = 1 ; j += 1 ; i = j ; }"}
{"text": "add value of chocolates at position n - 1", "code": "if ( i == j ) res += val ; else res += get_sum ( val , i , j ) ; return res ; }"}
{"text": "Helper function to get sum of decreasing sequence", "code": "int get_sum ( int peak , int start , int end ) {"}
{"text": "value obtained from decreasing sequence also the count of values in the sequence", "code": "int count = end - start + 1 ;"}
{"text": "assigning max of values obtained from increasing and decreasing sequences", "code": "peak = ( peak > count ) ? peak : count ;"}
{"text": "sum of count - 1 values & peak value sum of natural numbers : ( n * ( n + 1 ) ) / 2", "code": "int s = peak + ( ( ( count - 1 ) * count ) >> 1 ) ; return s ; }"}
{"text": "Driver code", "code": "int main ( ) { int a [ ] = { 5 , 5 , 4 , 3 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printf ( \" Minimum ▁ number ▁ of ▁ chocolates ▁ = ▁ % d \" , minChocolates ( a , n ) ) ; return 0 ; }"}
{"text": "C program to find sum of harmonic series", "code": "#include <stdio.h>"}
{"text": "Function to return sum of harmonic series", "code": "double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 5 ; printf ( \" Sum ▁ is ▁ % f \" , sum ( n ) ) ; return 0 ; }"}
{"text": "C program to find nth term of the series 5 2 13 41", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "function to calculate nth term of the series", "code": "int nthTermOfTheSeries ( int n ) {"}
{"text": "to store the nth term of series", "code": "int nthTerm ;"}
{"text": "if n is even number", "code": "if ( n % 2 == 0 ) nthTerm = pow ( n - 1 , 2 ) + n ;"}
{"text": "if n is odd number", "code": "else nthTerm = pow ( n + 1 , 2 ) + n ;"}
{"text": "return nth term", "code": "return nthTerm ; }"}
{"text": "Driver code", "code": "int main ( ) { int n ; n = 8 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 12 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 102 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 999 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 9999 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; return 0 ; }"}
{"text": "C program to find log ( n ) using Recursion", "code": "#include <stdio.h> NEW_LINE unsigned int Log2n ( unsigned int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; }"}
{"text": "Driver code", "code": "int main ( ) { unsigned int n = 32 ; printf ( \" % u \" , Log2n ( n ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find amount of water to be added to achieve given target ratio .", "code": "#include <stdio.h> NEW_LINE float findAmount ( float X , float W , float Y ) { return ( X * ( Y - W ) ) / ( 100 - Y ) ; }"}
{"text": "Driver code", "code": "int main ( ) { float X = 100 , W = 50 , Y = 60 ; printf ( \" Water ▁ to ▁ be ▁ added ▁ = ▁ % .2f ▁ \" , findAmount ( X , W , Y ) ) ; return 0 ; }"}
{"text": "C program to get the Average of Square of first n natural numbers", "code": "#include <stdio.h>"}
{"text": "Function to get the average", "code": "float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }"}
{"text": "Driver Code", "code": "int main ( ) { int n = 10 ; printf ( \" % f \" , AvgofSquareN ( n ) ) ; return 0 ; }"}
{"text": "C Program to find Triangular Number Series", "code": "#include <stdio.h>"}
{"text": "Function to find triangular number", "code": "void triangular_series ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) printf ( \" ▁ % d ▁ \" , i * ( i + 1 ) / 2 ) ; }"}
{"text": "Driven Function", "code": "int main ( ) { int n = 5 ; triangular_series ( n ) ; return 0 ; }"}
{"text": "C program to find sum of all divisor of number up to ' n '", "code": "#include <stdio.h>"}
{"text": "Utility function to find sum of all divisor of number up to ' n '", "code": "int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 4 ; printf ( \" % d STRNEWLINE \" , divisorSum ( n ) ) ; n = 5 ; printf ( \" % d \" , divisorSum ( n ) ) ; return 0 ; }"}
{"text": "C program to find sum of series 1 + x / 1 + x ^ 2 / 2 + x ^ 3 / 3 + ... . + x ^ n / n", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Code to print the sum of the series", "code": "double sum ( int x , int n ) { double i , total = 1.0 ; for ( i = 1 ; i <= n ; i ++ ) total = total + ( pow ( x , i ) / i ) ; return total ; }"}
{"text": "Driver code", "code": "int main ( ) { int x = 2 ; int n = 5 ; printf ( \" % .2f \" , sum ( x , n ) ) ; return 0 ; }"}
{"text": "C ++ program to check if a number is power of 3 or not .", "code": "#include <stdio.h> NEW_LINE #include <stdbool.h>"}
{"text": "Returns true if n is power of 3 , else false", "code": "bool check ( int n ) { if ( n <= 0 ) return false ;"}
{"text": "The maximum power of 3 value that integer can hold is 1162261467 ( 3 ^ 19 ) .", "code": "return 1162261467 % n == 0 ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 9 ; if ( check ( n ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Optimized C program for n 'th perrin number", "code": "#include <stdio.h> NEW_LINE int per ( int n ) { int a = 3 , b = 0 , c = 2 , i ; int m ; if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return c ; while ( n > 2 ) { m = a + b ; a = b ; b = c ; c = m ; n -- ; } return m ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 9 ; printf ( \" % d \" , per ( n ) ) ; return 0 ; }"}
{"text": "Naive Solution to find if count of divisors is even or odd", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Function to count the divisors", "code": "void countDivisors ( int n ) {"}
{"text": "Initialize count of divisors", "code": "int count = 0 ;"}
{"text": "Note that this loop runs till square root", "code": "for ( int i = 1 ; i <= sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 )"}
{"text": "If divisors are equal increment count by one Otherwise increment count by 2", "code": "count += ( n / i == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) printf ( \" Even STRNEWLINE \" ) ; else printf ( \" Odd STRNEWLINE \" ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { printf ( \" The ▁ count ▁ of ▁ divisor : ▁ \" ) ; countDivisors ( 10 ) ; return 0 ; }"}
{"text": "A Simple solution that causes overflow when value of ( a % mod ) * ( b % mod ) becomes more than maximum value of long long int", "code": "#define ll  long long NEW_LINE ll multiply ( ll a , ll b , ll mod ) { return ( ( a % mod ) * ( b % mod ) ) % mod ; }"}
{"text": "C program to count squares in a rectangle of size m x n", "code": "#include <stdio.h>"}
{"text": "Returns count of all squares in a rectangle of size m x n", "code": "int countSquares ( int m , int n ) { int temp ;"}
{"text": "If n is smaller , swap m and n", "code": "if ( n < m ) { temp = n ; n = m ; m = temp ; }"}
{"text": "Now n is greater dimension , apply formula", "code": "return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }"}
{"text": "Driver Code", "code": "int main ( ) { int m = 4 , n = 3 ; printf ( \" Count ▁ of ▁ squares ▁ is ▁ % d \" , countSquares ( m , n ) ) ; }"}
{"text": "C program to find sum of series", "code": "#include <stdio.h>"}
{"text": "Function to return sum of 1 / 1 + 1 / 2 + 1 / 3 + . . + 1 / n", "code": "double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 5 ; printf ( \" Sum ▁ is ▁ % f \" , sum ( n ) ) ; return 0 ; }"}
{"text": "C program to find GCD of two numbers", "code": "#include <stdio.h>"}
{"text": "Recursive function to return gcd of a and b", "code": "int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int a = 98 , b = 56 ; printf ( \" GCD ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "C ++ program of above approach", "code": "#include <stdio.h>"}
{"text": "A utility function that prints a given arr [ ] of length size", "code": "void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; return ; }"}
{"text": "The core function that recursively generates and prints all sequences of length k", "code": "void printSequencesRecur ( int arr [ ] , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } }"}
{"text": "A function that uses printSequencesRecur ( ) to prints all sequences from 1 , 1 , . .1 to n , n , . . n", "code": "void printSequences ( int n , int k ) { int * arr = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; }"}
{"text": "Driver Program to test above functions", "code": "int main ( ) { int n = 3 ; int k = 2 ; printSequences ( n , k ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h>"}
{"text": "assumes that n is a positive integer", "code": "bool isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }"}
{"text": "Driver Code", "code": "int main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) printf ( \" % d ▁ is ▁ multiple ▁ of ▁ 5 STRNEWLINE \" , n ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ multiple ▁ of ▁ 5 STRNEWLINE \" , n ) ; return 0 ; }"}
{"text": "Function to get no of bits in binary representation of positive integer", "code": "#include <stdio.h> NEW_LINE unsigned int countBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }"}
{"text": "Driver program", "code": "int main ( ) { int i = 65 ; printf ( \" % d \" , countBits ( i ) ) ; return 0 ; }"}
{"text": "C program to find n - th number whose binary representation is palindrome .", "code": "#include <stdio.h> NEW_LINE #define INT_MAX  2147483647"}
{"text": "Finds if the kth bit is set in the binary representation", "code": "int isKthBitSet ( int x , int k ) { return ( x & ( 1 << ( k - 1 ) ) ) ? 1 : 0 ; }"}
{"text": "Returns the position of leftmost set bit in the binary representation", "code": "int leftmostSetBit ( int x ) { int count = 0 ; while ( x ) { count ++ ; x = x >> 1 ; } return count ; }"}
{"text": "Finds whether the integer in binary representation is palindrome or not", "code": "int isBinPalindrome ( int x ) { int l = leftmostSetBit ( x ) ; int r = 1 ;"}
{"text": "One by one compare bits", "code": "while ( l > r ) {"}
{"text": "Compare left and right bits and converge", "code": "if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; } int findNthPalindrome ( int n ) { int pal_count = 0 ;"}
{"text": "Start from 1 , traverse through all the integers", "code": "int i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) ) { pal_count ++ ; }"}
{"text": "If we reach n , break the loop", "code": "if ( pal_count == n ) break ; } return i ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 9 ;"}
{"text": "Function Call", "code": "printf ( \" % d \" , findNthPalindrome ( n ) ) ; }"}
{"text": "C Program to demonstrate use of bitwise operators", "code": "#include <stdio.h> NEW_LINE int main ( ) {"}
{"text": "a = 5 ( 00000101 ) , b = 9 ( 00001001 )", "code": "unsigned char a = 5 , b = 9 ;"}
{"text": "The result is 00000001", "code": "printf ( \" a ▁ = ▁ % d , ▁ b ▁ = ▁ % d STRNEWLINE \" , a , b ) ; printf ( \" a & b ▁ = ▁ % d STRNEWLINE \" , a & b ) ;"}
{"text": "The result is 00001101", "code": "printf ( \" a ▁ b ▁ = ▁ % d STRNEWLINE \" , a b ) ;"}
{"text": "The result is 00001100", "code": "printf ( \" a ^ b ▁ = ▁ % d STRNEWLINE \" , a ^ b ) ;"}
{"text": "The result is 11111010", "code": "printf ( \" ~ a ▁ = ▁ % d STRNEWLINE \" , a = ~ a ) ;"}
{"text": "The result is 00010010", "code": "printf ( \" b < < 1 ▁ = ▁ % d STRNEWLINE \" , b << 1 ) ;"}
{"text": "The result is 00000100", "code": "printf ( \" b > > 1 ▁ = ▁ % d STRNEWLINE \" , b >> 1 ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h>"}
{"text": "Function to return temperature in the second thermometer", "code": "double temp_convert ( int F1 , int B1 , int F2 , int B2 , int T ) { float t2 ;"}
{"text": "Calculate the temperature", "code": "t2 = F2 + ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }"}
{"text": "Driver Code", "code": "int main ( ) { int F1 = 0 , B1 = 100 ; int F2 = 32 , B2 = 212 ; int T = 37 ; float t2 ; printf ( \" % .2f \" , temp_convert ( F1 , B1 , F2 , B2 , T ) ) ; return 0 ; }"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Compute the \" maxDepth \" of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node .", "code": "int maxDepth ( struct node * node ) { if ( node == NULL ) return 0 ; else {"}
{"text": "compute the depth of each subtree", "code": "int lDepth = maxDepth ( node -> left ) ; int rDepth = maxDepth ( node -> right ) ;"}
{"text": "use the larger one", "code": "if ( lDepth > rDepth ) return ( lDepth + 1 ) ; else return ( rDepth + 1 ) ; } }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver code", "code": "int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Height ▁ of ▁ tree ▁ is ▁ % d \" , maxDepth ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to check if a tree is height - balanced or not", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define bool  int"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Returns the height of a binary tree", "code": "int height ( struct node * node ) ;"}
{"text": "Returns true if binary tree with root as root is height - balanced", "code": "bool isBalanced ( struct node * root ) {"}
{"text": "for height of left subtree", "code": "int lh ;"}
{"text": "for height of right subtree", "code": "int rh ;"}
{"text": "If tree is empty then return true", "code": "if ( root == NULL ) return 1 ;"}
{"text": "Get the height of left and right sub trees", "code": "lh = height ( root -> left ) ; rh = height ( root -> right ) ; if ( abs ( lh - rh ) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ) ) return 1 ;"}
{"text": "If we reach here then tree is not height - balanced", "code": "return 0 ; }"}
{"text": "returns maximum of two integers", "code": "int max ( int a , int b ) { return ( a >= b ) ? a : b ; }"}
{"text": "The function Compute the \" height \" of a tree . Height is the number of nodes along the longest path from the root node down to the farthest leaf node .", "code": "int height ( struct node * node ) {"}
{"text": "base case tree is empty", "code": "if ( node == NULL ) return 0 ;"}
{"text": "If tree is not empty then height = 1 + max of left height and right heights", "code": "return 1 + max ( height ( node -> left ) , height ( node -> right ) ) ; }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver code", "code": "int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> left -> left = newNode ( 8 ) ; if ( isBalanced ( root ) ) printf ( \" Tree ▁ is ▁ balanced \" ) ; else printf ( \" Tree ▁ is ▁ not ▁ balanced \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Recursive optimized C program to find the diameter of a Binary Tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "returns max of two integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "The function Compute the \" height \" of a tree . Height is the number f nodes along the longest path from the root node down to the farthest leaf node .", "code": "int height ( struct node * node ) {"}
{"text": "base case tree is empty", "code": "if ( node == NULL ) return 0 ;"}
{"text": "If tree is not empty then height = 1 + max of left height and right heights", "code": "return 1 + max ( height ( node -> left ) , height ( node -> right ) ) ; }"}
{"text": "Function to get diameter of a binary tree", "code": "int diameter ( struct node * tree ) {"}
{"text": "base case where tree is empty", "code": "if ( tree == NULL ) return 0 ;"}
{"text": "get the height of left and right sub - trees", "code": "int lheight = height ( tree -> left ) ; int rheight = height ( tree -> right ) ;"}
{"text": "get the diameter of left and right sub - trees", "code": "int ldiameter = diameter ( tree -> left ) ; int rdiameter = diameter ( tree -> right ) ;"}
{"text": "Return max of following three 1 ) Diameter of left subtree 2 ) Diameter of right subtree 3 ) Height of left subtree + height of right subtree + 1", "code": "return max ( lheight + rheight + 1 , max ( ldiameter , rdiameter ) ) ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Constructed binary tree is 1 / \\ 2 3 / \\ 4 5", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ;"}
{"text": "Function Call", "code": "printf ( \" Diameter ▁ of ▁ the ▁ given ▁ binary ▁ tree ▁ is ▁ % d STRNEWLINE \" , diameter ( root ) ) ; return 0 ; }"}
{"text": "C ++ program for above approach .", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "Function to find print path", "code": "void findpath ( int N , int a [ ] ) {"}
{"text": "If a [ 0 ] is 1", "code": "if ( a [ 0 ] ) {"}
{"text": "Printing path", "code": "printf ( \" % d ▁ \" , N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , i ) ; return ; }"}
{"text": "Seeking for a [ i ] = 0 and a [ i + 1 ] = 1", "code": "for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ! a [ i ] && a [ i + 1 ] ) {"}
{"text": "Printing path", "code": "for ( int j = 1 ; j <= i ; j ++ ) printf ( \" % d ▁ \" , j ) ; printf ( \" % d ▁ \" , N + 1 ) ; for ( int j = i + 1 ; j <= N ; j ++ ) printf ( \" % d ▁ \" , j ) ; return ; } }"}
{"text": "If a [ N - 1 ] = 0", "code": "for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , i ) ; printf ( \" % d ▁ \" , N + 1 ) ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given Input", "code": "int N = 3 , arr [ ] = { 0 , 1 , 0 } ;"}
{"text": "Function Call", "code": "findpath ( N , arr ) ; }"}
{"text": "C program to find depth of the deepest odd level leaf node", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A utility function to find maximum of two integers", "code": "int max ( int x , int y ) { return ( x > y ) ? x : y ; }"}
{"text": "A Binary Tree node", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "A utility function to allocate a new tree node", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; }"}
{"text": "A recursive function to find depth of the deepest odd level leaf", "code": "int depthOfOddLeafUtil ( struct Node * root , int level ) {"}
{"text": "Base Case", "code": "if ( root == NULL ) return 0 ;"}
{"text": "If this node is a leaf and its level is odd , return its level", "code": "if ( root -> left == NULL && root -> right == NULL && level & 1 ) return level ;"}
{"text": "If not leaf , return the maximum value from left and right subtrees", "code": "return max ( depthOfOddLeafUtil ( root -> left , level + 1 ) , depthOfOddLeafUtil ( root -> right , level + 1 ) ) ; }"}
{"text": "Main function which calculates the depth of deepest odd level leaf . This function mainly uses depthOfOddLeafUtil ( )", "code": "int depthOfOddLeaf ( struct Node * root ) { int level = 1 , depth = 0 ; return depthOfOddLeafUtil ( root , level ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 8 ) ; root -> right -> left -> right -> left = newNode ( 9 ) ; root -> right -> right -> right -> right = newNode ( 10 ) ; root -> right -> right -> right -> right -> left = newNode ( 11 ) ; printf ( \" % d ▁ is ▁ the ▁ required ▁ depth STRNEWLINE \" , depthOfOddLeaf ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A comparator function used by qsort", "code": "int compare ( const void * a , const void * b ) { return ( * ( int * ) a - * ( int * ) b ) ; }"}
{"text": "Function to print the required reordering of array if possible", "code": "void printArr ( int arr [ ] , int n ) {"}
{"text": "Sort the array in increasing order", "code": "qsort ( arr , n , sizeof ( int ) , compare ) ;"}
{"text": "If all elements are equal , then it is not possible", "code": "if ( arr [ 0 ] == arr [ n - 1 ] ) { printf ( \" No STRNEWLINE \" ) ; }"}
{"text": "Else print the sorted array arr [ ]", "code": "else { printf ( \" Yes STRNEWLINE \" ) ; for ( int i = 0 ; i < n ; i ++ ) { printf ( \" % d ▁ \" , arr [ i ] ) ; } } }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given array", "code": "int arr [ ] = { 1 , 2 , 2 , 1 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Function call", "code": "printArr ( arr , N ) ; return 0 ; }"}
{"text": "C program to calculate width of binary tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Function protoypes", "code": "int getWidth ( struct node * root , int level ) ; int height ( struct node * node ) ; struct node * newNode ( int data ) ;"}
{"text": "Function to get the maximum width of a binary tree", "code": "int getMaxWidth ( struct node * root ) { int maxWidth = 0 ; int width ; int h = height ( root ) ; int i ;"}
{"text": "Get width of each level and compare the width with maximum width so far", "code": "for ( i = 1 ; i <= h ; i ++ ) { width = getWidth ( root , i ) ; if ( width > maxWidth ) maxWidth = width ; } return maxWidth ; }"}
{"text": "Get width of a given level", "code": "int getWidth ( struct node * root , int level ) { if ( root == NULL ) return 0 ; if ( level == 1 ) return 1 ; else if ( level > 1 ) return getWidth ( root -> left , level - 1 ) + getWidth ( root -> right , level - 1 ) ; }"}
{"text": "Compute the \" height \" of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node .", "code": "int height ( struct node * node ) { if ( node == NULL ) return 0 ; else {"}
{"text": "compute the height of each subtree", "code": "int lHeight = height ( node -> left ) ; int rHeight = height ( node -> right ) ;"}
{"text": "use the larger one", "code": "return ( lHeight > rHeight ) ? ( lHeight + 1 ) : ( rHeight + 1 ) ; } }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver code", "code": "int main ( ) {"}
{"text": "Constructed binary tree is : 1 / \\ 2 3 / \\ \\ 4 5 8 / \\ 6 7", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 6 ) ; root -> right -> right -> right = newNode ( 7 ) ;"}
{"text": "Function call", "code": "printf ( \" Maximum ▁ width ▁ is ▁ % d ▁ STRNEWLINE \" , getMaxWidth ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to calculate width of binary tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "A utility function to get height of a binary tree", "code": "int height ( struct node * node ) ; struct node * newNode ( int data ) ; int getMax ( int arr [ ] , int n ) ; void getMaxWidthRecur ( struct node * root , int count [ ] , int level ) ;"}
{"text": "Function to get the maximum width of a binary tree", "code": "int getMaxWidth ( struct node * root ) { int width ; int h = height ( root ) ;"}
{"text": "Create an array that will store count of nodes at each level", "code": "int * count = ( int * ) calloc ( sizeof ( int ) , h ) ; int level = 0 ;"}
{"text": "Fill the count array using preorder traversal", "code": "getMaxWidthRecur ( root , count , level ) ;"}
{"text": "Return the maximum value from count array", "code": "return getMax ( count , h ) ; }"}
{"text": "A function that fills count array with count of nodes at every level of given binary tree", "code": "void getMaxWidthRecur ( struct node * root , int count [ ] , int level ) { if ( root ) { count [ level ] ++ ; getMaxWidthRecur ( root -> left , count , level + 1 ) ; getMaxWidthRecur ( root -> right , count , level + 1 ) ; } }"}
{"text": "Compute the \" height \" of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node .", "code": "int height ( struct node * node ) { if ( node == NULL ) return 0 ; else {"}
{"text": "compute the height of each subtree", "code": "int lHeight = height ( node -> left ) ; int rHeight = height ( node -> right ) ;"}
{"text": "use the larger one", "code": "return ( lHeight > rHeight ) ? ( lHeight + 1 ) : ( rHeight + 1 ) ; } }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Return the maximum value from count array", "code": "int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Constructed bunary tree is : 1 / \\ 2 3 / \\ \\ 4 5 8 / \\ 6 7", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 6 ) ; root -> right -> right -> right = newNode ( 7 ) ; printf ( \" Maximum ▁ width ▁ is ▁ % d ▁ STRNEWLINE \" , getMaxWidth ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "C implementation to find leaf count of a given Binary tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Function to get the count of leaf nodes in a binary tree", "code": "unsigned int getLeafCount ( struct node * node ) { if ( node == NULL ) return 0 ; if ( node -> left == NULL && node -> right == NULL ) return 1 ; else return getLeafCount ( node -> left ) + getLeafCount ( node -> right ) ; }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "create a tree", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ;"}
{"text": "get leaf count of the above created tree", "code": "printf ( \" Leaf ▁ count ▁ of ▁ the ▁ tree ▁ is ▁ % d \" , getLeafCount ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find minimum number of denominations", "code": "#include <stdio.h> NEW_LINE #define COINS  9 NEW_LINE #define MAX  20"}
{"text": "All denominations of Indian Currency", "code": "int coins [ COINS ] = { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 , 2000 } ; void findMin ( int cost ) {"}
{"text": "Initialize result", "code": "int coinList [ MAX ] = { 0 } ;"}
{"text": "Traverse through all denomination", "code": "int i , k = 0 ; for ( i = COINS - 1 ; i >= 0 ; i -- ) {"}
{"text": "Find denominations", "code": "while ( cost >= coins [ i ] ) { cost -= coins [ i ] ; coinList [ k ++ ] = coins [ i ] ; } }"}
{"text": "Print result", "code": "for ( i = 0 ; i < k ; i ++ ) { printf ( \" % d ▁ \" , coinList [ i ] ) ; } return ; }"}
{"text": "Driver Code", "code": "int main ( void ) { int n = 93 ; printf ( \" Following ▁ is ▁ minimal ▁ number \" \" of ▁ change ▁ for ▁ % d : ▁ \" , n ) ; findMin ( n ) ; return 0 ; }"}
{"text": "Iterative C program to connect nodes at same level using constant extra space", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Constructor that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node { int data ; struct node * left ; struct node * right ; struct node * nextRight ; } ; struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> nextRight = NULL ; return ( node ) ; }"}
{"text": "This function returns the leftmost child of nodes at the same level as p . This function is used to getNExt right of p 's right child  If right child of is NULL then this can also be used for the left child", "code": "struct node * getNextRight ( struct node * p ) { struct node * temp = p -> nextRight ;"}
{"text": "Traverse nodes at p ' s ▁ level ▁ and ▁ find ▁ and ▁ return ▁ ▁ the ▁ first ▁ node ' s first child", "code": "while ( temp != NULL ) { if ( temp -> left != NULL ) return temp -> left ; if ( temp -> right != NULL ) return temp -> right ; temp = temp -> nextRight ; }"}
{"text": "If all the nodes at p 's level are leaf nodes then return NULL", "code": "return NULL ; }"}
{"text": "Sets nextRight of all nodes of a tree with root as p", "code": "void connect ( struct node * p ) { struct node * temp ; if ( ! p ) return ;"}
{"text": "Set nextRight for root", "code": "p -> nextRight = NULL ;"}
{"text": "set nextRight of all levels one by one", "code": "while ( p != NULL ) { struct node * q = p ;"}
{"text": "Connect all childrem nodes of p and children nodes of all other nodes at same level as p", "code": "while ( q != NULL ) {"}
{"text": "Set the nextRight pointer for p 's left child", "code": "if ( q -> left ) {"}
{"text": "If q has right child , then right child is nextRight of p and we also need to set nextRight of right child", "code": "if ( q -> right ) q -> left -> nextRight = q -> right ; else q -> left -> nextRight = getNextRight ( q ) ; } if ( q -> right ) q -> right -> nextRight = getNextRight ( q ) ;"}
{"text": "Set nextRight for other nodes in pre order fashion", "code": "q = q -> nextRight ; }"}
{"text": "start from the first node of next level", "code": "if ( p -> left ) p = p -> left ; else if ( p -> right ) p = p -> right ; else p = getNextRight ( p ) ; } }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Constructed binary tree is 10 / \\ 8 2 / \\ 3 90", "code": "struct node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ; root -> right -> right = newnode ( 90 ) ;"}
{"text": "Populates nextRight pointer in all nodes", "code": "connect ( root ) ;"}
{"text": "Let us check the values of nextRight pointers", "code": "printf ( \" Following ▁ are ▁ populated ▁ nextRight ▁ pointers ▁ in ▁ the ▁ tree ▁ \" \" ( -1 ▁ is ▁ printed ▁ if ▁ there ▁ is ▁ no ▁ nextRight ) ▁ STRNEWLINE \" ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> data , root -> nextRight ? root -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> left -> data , root -> left -> nextRight ? root -> left -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> right -> data , root -> right -> nextRight ? root -> right -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> left -> left -> data , root -> left -> left -> nextRight ? root -> left -> left -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> right -> right -> data , root -> right -> right -> nextRight ? root -> right -> right -> nextRight -> data : -1 ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to connect nodes at same level using extended pre - order traversal", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void connectRecur ( struct node * p ) ;"}
{"text": "A binary tree node", "code": "struct node { int data ; struct node * left ; struct node * right ; struct node * nextRight ; } ;"}
{"text": "Sets the nextRight of root and calls connectRecur ( ) for other nodes", "code": "void connect ( struct node * p ) {"}
{"text": "Set the nextRight for root", "code": "p -> nextRight = NULL ;"}
{"text": "Set the next right for rest of the nodes ( other than root )", "code": "connectRecur ( p ) ; }"}
{"text": "Set next right of all descendents of p . Assumption : p is a compete binary tree", "code": "void connectRecur ( struct node * p ) {"}
{"text": "Base case", "code": "if ( ! p ) return ;"}
{"text": "Set the nextRight pointer for p 's left child", "code": "if ( p -> left ) p -> left -> nextRight = p -> right ;"}
{"text": "Set the nextRight pointer for p 's right child  p->nextRight will be NULL if p is the right  most child at its level", "code": "if ( p -> right ) p -> right -> nextRight = ( p -> nextRight ) ? p -> nextRight -> left : NULL ;"}
{"text": "Set nextRight for other nodes in pre order fashion", "code": "connectRecur ( p -> left ) ; connectRecur ( p -> right ) ; }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> nextRight = NULL ; return ( node ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Constructed binary tree is 10 / \\ 8 2 / 3", "code": "struct node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ;"}
{"text": "Populates nextRight pointer in all nodes", "code": "connect ( root ) ;"}
{"text": "Let us check the values of nextRight pointers", "code": "printf ( \" Following ▁ are ▁ populated ▁ nextRight ▁ pointers ▁ in ▁ the ▁ tree ▁ \" \" ( -1 ▁ is ▁ printed ▁ if ▁ there ▁ is ▁ no ▁ nextRight ) ▁ STRNEWLINE \" ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> data , root -> nextRight ? root -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> left -> data , root -> left -> nextRight ? root -> left -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> right -> data , root -> right -> nextRight ? root -> right -> nextRight -> data : -1 ) ; printf ( \" nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , root -> left -> left -> data , root -> left -> left -> nextRight ? root -> left -> left -> nextRight -> data : -1 ) ; return 0 ; }"}
{"text": "A Naive recursive program to find minimum number insertions needed to make a string palindrome", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #include <string.h>"}
{"text": "A utility function to find minimum of two numbers", "code": "int min ( int a , int b ) { return a < b ? a : b ; }"}
{"text": "Recursive function to find minimum number of insertions", "code": "int findMinInsertions ( char str [ ] , int l , int h ) {"}
{"text": "Base Cases", "code": "if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ;"}
{"text": "Check if the first and last characters are same . On the basis of the comparison result , decide which subrpoblem ( s ) to call", "code": "return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { char str [ ] = \" geeks \" ; printf ( \" % d \" , findMinInsertions ( str , 0 , strlen ( str ) - 1 ) ) ; return 0 ; }"}
{"text": "C program of above approach", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "A utility function to get max of two integers", "code": "int max ( int x , int y ) { return ( x > y ) ? x : y ; }"}
{"text": "Returns the length of the longest palindromic subsequence in seq", "code": "int lps ( char * seq , int i , int j ) {"}
{"text": "Base Case 1 : If there is only 1 character", "code": "if ( i == j ) return 1 ;"}
{"text": "Base Case 2 : If there are only 2 characters and both are same", "code": "if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ;"}
{"text": "If the first and last characters match", "code": "if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ;"}
{"text": "If the first and last characters do not match", "code": "return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { char seq [ ] = \" GEEKSFORGEEKS \" ; int n = strlen ( seq ) ; printf ( \" The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d \" , lps ( seq , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to Get Level of a node in a Binary Tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A tree node structure", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Helper function for getLevel ( ) . It returns level of the data if data is present in tree , otherwise returns 0.", "code": "int getLevelUtil ( struct node * node , int data , int level ) { if ( node == NULL ) return 0 ; if ( node -> data == data ) return level ; int downlevel = getLevelUtil ( node -> left , data , level + 1 ) ; if ( downlevel != 0 ) return downlevel ; downlevel = getLevelUtil ( node -> right , data , level + 1 ) ; return downlevel ; }"}
{"text": "Returns level of given data value", "code": "int getLevel ( struct node * node , int data ) { return getLevelUtil ( node , data , 1 ) ; }"}
{"text": "Utility function to create a new Binary Tree node", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; }"}
{"text": "Driver code", "code": "int main ( ) { struct node * root ; int x ;"}
{"text": "Constructing tree given in the above figure", "code": "root = newNode ( 3 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; for ( x = 1 ; x <= 5 ; x ++ ) { int level = getLevel ( root , x ) ; if ( level ) printf ( \" ▁ Level ▁ of ▁ % d ▁ is ▁ % d STRNEWLINE \" , x , getLevel ( root , x ) ) ; else printf ( \" ▁ % d ▁ is ▁ not ▁ present ▁ in ▁ tree ▁ STRNEWLINE \" , x ) ; } getchar ( ) ; return 0 ; }"}
{"text": "C program for Finite Automata Pattern searching Algorithm", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE int getNextState ( char * pat , int M , int state , int x ) {"}
{"text": "If the character c is same as next character in pattern , then simply increment state", "code": "if ( state < M && x == pat [ state ] ) return state + 1 ;"}
{"text": "ns stores the result which is next state", "code": "int ns , i ;"}
{"text": "Start from the largest possible value and stop when you find a prefix which is also suffix", "code": "for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] == x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) if ( pat [ i ] != pat [ state - ns + 1 + i ] ) break ; if ( i == ns - 1 ) return ns ; } } return 0 ; }"}
{"text": "This function builds the TF table which represents4 Finite Automata for a given pattern", "code": "void computeTF ( char * pat , int M , int TF [ ] [ NO_OF_CHARS ] ) { int state , x ; for ( state = 0 ; state <= M ; ++ state ) for ( x = 0 ; x < NO_OF_CHARS ; ++ x ) TF [ state ] [ x ] = getNextState ( pat , M , state , x ) ; }"}
{"text": "Prints all occurrences of pat in txt", "code": "void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int TF [ M + 1 ] [ NO_OF_CHARS ] ; computeTF ( pat , M , TF ) ;"}
{"text": "Process txt over FA .", "code": "int i , state = 0 ; for ( i = 0 ; i < N ; i ++ ) { state = TF [ state ] [ txt [ i ] ] ; if ( state == M ) printf ( \" Pattern found at index % d \" , i - M + 1 ) ; } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char * txt = \" AABAACAADAABAAABAA \" ; char * pat = \" AABA \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "C program to find the mirror Node in Binary tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree Node has data , pointer to left child and a pointer to right child", "code": "struct Node { int key ; struct Node * left , * right ; } ;"}
{"text": "create new Node and initialize it", "code": "struct Node * newNode ( int key ) { struct Node * n = ( struct Node * ) malloc ( sizeof ( struct Node * ) ) ; if ( n != NULL ) { n -> key = key ; n -> left = NULL ; n -> right = NULL ; return n ; } else { printf ( \" Memory ▁ allocation ▁ failed ! \" ) ; exit ( 1 ) ; } }"}
{"text": "recursive function to find mirror of Node", "code": "int findMirrorRec ( int target , struct Node * left , struct Node * right ) {"}
{"text": "if any of the Node is none then Node itself and decendent have no mirror , so return none , no need to further explore !", "code": "if ( left == NULL right == NULL ) return 0 ;"}
{"text": "if left Node is target Node , then return right 's key (that is mirror) and vice  versa", "code": "if ( left -> key == target ) return right -> key ; if ( right -> key == target ) return left -> key ;"}
{"text": "first recur external Nodes", "code": "int mirror_val = findMirrorRec ( target , left -> left , right -> right ) ; if ( mirror_val ) return mirror_val ;"}
{"text": "if no mirror found , recur internal Nodes", "code": "findMirrorRec ( target , left -> right , right -> left ) ; }"}
{"text": "interface for mirror search", "code": "int findMirror ( struct Node * root , int target ) { if ( root == NULL ) return 0 ; if ( root -> key == target ) return target ; return findMirrorRec ( target , root -> left , root -> right ) ; }"}
{"text": "Driver", "code": "int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> left -> right = newNode ( 7 ) ; root -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> left = newNode ( 8 ) ; root -> right -> left -> right = newNode ( 9 ) ;"}
{"text": "target Node whose mirror have to be searched", "code": "int target = root -> left -> left -> key ; int mirror = findMirror ( root , target ) ; if ( mirror ) printf ( \" Mirror ▁ of ▁ Node ▁ % d ▁ is ▁ Node ▁ % d STRNEWLINE \" , target , mirror ) ; else printf ( \" Mirror ▁ of ▁ Node ▁ % d ▁ is ▁ NULL ! STRNEWLINE \" , target ) ; }"}
{"text": "Iterative level order traversal based method to search in Binary Tree", "code": "#include <iostream> NEW_LINE #include <queue> NEW_LINE using namespace std ;"}
{"text": "A binary tree node has data , left child and right child", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = new struct node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; }"}
{"text": "An iterative process to search an element x in a given binary tree", "code": "bool iterativeSearch ( node * root , int x ) {"}
{"text": "Base Case", "code": "if ( root == NULL ) return false ;"}
{"text": "Create an empty queue for level order traversal", "code": "queue < node * > q ;"}
{"text": "Enqueue Root and initialize height", "code": "q . push ( root ) ;"}
{"text": "Queue based level order traversal", "code": "while ( q . empty ( ) == false ) {"}
{"text": "See if current node is same as x", "code": "node * node = q . front ( ) ; if ( node -> data == x ) return true ;"}
{"text": "Remove current node and enqueue its children", "code": "q . pop ( ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; } return false ; }"}
{"text": "Driver program", "code": "int main ( void ) { struct node * NewRoot = NULL ; struct node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; iterativeSearch ( root , 6 ) ? cout << \" Found STRNEWLINE \" : cout << \" Not ▁ Found STRNEWLINE \" ; iterativeSearch ( root , 12 ) ? cout << \" Found STRNEWLINE \" : cout << \" Not ▁ Found STRNEWLINE \" ; return 0 ; }"}
{"text": "C # program to populate inorder traversal of all nodes", "code": "struct node { int data ; struct node * left ; struct node * right ; struct node * next ; }"}
{"text": "An implementation that doesn 't use static variable A wrapper over populateNextRecur", "code": "void populateNext ( struct node * root ) {"}
{"text": "The first visited node will be the rightmost node next of the rightmost node will be NULL", "code": "struct node * next = NULL ; populateNextRecur ( root , & next ) ; }"}
{"text": "Set next of all descendants of p by traversing them in reverse Inorder", "code": "void populateNextRecur ( struct node * p , struct node * * next_ref ) { if ( p ) {"}
{"text": "First set the next pointer in right subtree", "code": "populateNextRecur ( p -> right , next_ref ) ;"}
{"text": "Set the next as previously visited node in reverse Inorder", "code": "p -> next = * next_ref ;"}
{"text": "Change the prev for subsequent node", "code": "* next_ref = p ;"}
{"text": "Finally , set the next pointer in right subtree", "code": "populateNextRecur ( p -> left , next_ref ) ; } }"}
{"text": "C program to remove all half nodes", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Binary tree node", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "For inorder traversal", "code": "void printInoder ( struct node * root ) { if ( root != NULL ) { printInoder ( root -> left ) ; printf ( \" % d ▁ \" , root -> data ) ; printInoder ( root -> right ) ; } }"}
{"text": "Removes all nodes with only one child and returns new root ( note that root may change )", "code": "struct node * RemoveHalfNodes ( struct node * root ) { if ( root == NULL ) return NULL ; root -> left = RemoveHalfNodes ( root -> left ) ; root -> right = RemoveHalfNodes ( root -> right ) ; if ( root -> left == NULL && root -> right == NULL ) return root ;"}
{"text": "if current nodes is a half node with left child NULL left , then it 's right child is  returned and replaces it in the given tree", "code": "if ( root -> left == NULL ) { struct node * new_root = root -> right ; free ( root ) ; return new_root ; }"}
{"text": "if current nodes is a half node with right child NULL right , then it 's right child is  returned and replaces it in the given tree", "code": "if ( root -> right == NULL ) { struct node * new_root = root -> left ; free ( root ) ; return new_root ; } return root ; }"}
{"text": "Driver program", "code": "int main ( void ) { struct node * NewRoot = NULL ; struct node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ given ▁ tree ▁ STRNEWLINE \" ) ; printInoder ( root ) ; NewRoot = RemoveHalfNodes ( root ) ; printf ( \" Inorder traversal of the modified tree \" printInoder ( NewRoot ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h> NEW_LINE void printSubstrings ( char str [ ] ) {"}
{"text": "outermost for loop this is for the selection of starting point", "code": "for ( int start = 0 ; str [ start ] != ' \\0' ; start ++ ) {"}
{"text": "2 nd for loop is for selection of ending point", "code": "for ( int end = start ; str [ end ] != ' \\0' ; end ++ ) {"}
{"text": "3 rd loop is for printing from starting point to ending point", "code": "for ( int i = start ; i <= end ; i ++ ) { printf ( \" % c \" , str [ i ] ) ; }"}
{"text": "changing the line after printing from starting point to ending point", "code": "printf ( \" STRNEWLINE \" ) ; } } }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "calling the method to print the substring", "code": "char str [ ] = { ' a ' , ' b ' , ' c ' , ' d ' , ' \\0' } ; printSubstrings ( str ) ; return 0 ; }"}
{"text": "N is the size of the 2D matrix N * N", "code": "#define N  9"}
{"text": "A utility function to print grid", "code": "void print ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( \" % d ▁ \" , arr [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Checks whether it will be legal to assign num to the given row , col", "code": "int isSafe ( int grid [ N ] [ N ] , int row , int col , int num ) {"}
{"text": "Check if we find the same num in the similar row , we return 0", "code": "for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ row ] [ x ] == num ) return 0 ;"}
{"text": "Check if we find the same num in the similar column , we return 0", "code": "for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ x ] [ col ] == num ) return 0 ;"}
{"text": "Check if we find the same num in the particular 3 * 3 matrix , we return 0", "code": "int startRow = row - row % 3 , startCol = col - col % 3 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow ] [ j + startCol ] == num ) return 0 ; return 1 ; }"}
{"text": "Takes a partially filled - in grid and attempts to assign values to all unassigned locations in such a way to meet the requirements for Sudoku solution ( non - duplication across rows , columns , and boxes )", "code": "int solveSuduko ( int grid [ N ] [ N ] , int row , int col ) {"}
{"text": "Check if we have reached the 8 th row and 9 th column ( 0 indexed matrix ) , we are returning true to avoid further backtracking", "code": "if ( row == N - 1 && col == N ) return 1 ;"}
{"text": "Check if column value becomes 9 , we move to next row and column start from 0", "code": "if ( col == N ) { row ++ ; col = 0 ; }"}
{"text": "Check if the current position of the grid already contains value > 0 , we iterate for next column", "code": "if ( grid [ row ] [ col ] > 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( int num = 1 ; num <= N ; num ++ ) {"}
{"text": "Check if it is safe to place the num ( 1 - 9 ) in the given row , col -> we move to next column", "code": "if ( isSafe ( grid , row , col , num ) == 1 ) {"}
{"text": "assigning the num in the current ( row , col ) position of the grid and assuming our assigned num in the position is correct", "code": "grid [ row ] [ col ] = num ;"}
{"text": "Checking for next possibility with next column", "code": "if ( solveSuduko ( grid , row , col + 1 ) == 1 ) return 1 ; }"}
{"text": "Removing the assigned num , since our assumption was wrong , and we go for next assumption with diff num value", "code": "grid [ row ] [ col ] = 0 ; } return 0 ; } int main ( ) {"}
{"text": "0 means unassigned cells", "code": "int grid [ N ] [ N ] = { { 3 , 0 , 6 , 5 , 0 , 8 , 4 , 0 , 0 } , { 5 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 8 , 7 , 0 , 0 , 0 , 0 , 3 , 1 } , { 0 , 0 , 3 , 0 , 1 , 0 , 0 , 8 , 0 } , { 9 , 0 , 0 , 8 , 6 , 3 , 0 , 0 , 5 } , { 0 , 5 , 0 , 0 , 9 , 0 , 6 , 0 , 0 } , { 1 , 3 , 0 , 0 , 0 , 0 , 2 , 5 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 4 } , { 0 , 0 , 5 , 2 , 0 , 6 , 3 , 0 , 0 } } ; if ( solveSuduko ( grid , 0 , 0 ) == 1 ) print ( grid ) ; else printf ( \" No ▁ solution ▁ exists \" ) ; return 0 ; }"}
{"text": "prints subset found", "code": "void printSubset ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { printf ( \" % * d \" , 5 , A [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "qsort compare function", "code": "int comparator ( const void * pLhs , const void * pRhs ) { int * lhs = ( int * ) pLhs ; int * rhs = ( int * ) pRhs ; return * lhs > * rhs ; }"}
{"text": "inputs s - set vector t - tuplet vector s_size - set size t_size - tuplet size so far sum - sum so far ite - nodes count target_sum - sum to be found", "code": "void subset_sum ( int s [ ] , int t [ ] , int s_size , int t_size , int sum , int ite , int const target_sum ) { total_nodes ++ ; if ( target_sum == sum ) {"}
{"text": "We found sum", "code": "printSubset ( t , t_size ) ;"}
{"text": "constraint check", "code": "if ( ite + 1 < s_size && sum - s [ ite ] + s [ ite + 1 ] <= target_sum ) {"}
{"text": "Exclude previous added item and consider next candidate", "code": "subset_sum ( s , t , s_size , t_size - 1 , sum - s [ ite ] , ite + 1 , target_sum ) ; } return ; } else {"}
{"text": "constraint check", "code": "if ( ite < s_size && sum + s [ ite ] <= target_sum ) {"}
{"text": "generate nodes along the breadth", "code": "for ( int i = ite ; i < s_size ; i ++ ) { t [ t_size ] = s [ i ] ; if ( sum + s [ i ] <= target_sum ) {"}
{"text": "consider next level node ( along depth )", "code": "subset_sum ( s , t , s_size , t_size + 1 , sum + s [ i ] , i + 1 , target_sum ) ; } } } } }"}
{"text": "Wrapper that prints subsets that sum to target_sum", "code": "void generateSubsets ( int s [ ] , int size , int target_sum ) { int * tuplet_vector = ( int * ) malloc ( size * sizeof ( int ) ) ; int total = 0 ;"}
{"text": "sort the set", "code": "qsort ( s , size , sizeof ( int ) , & comparator ) ; for ( int i = 0 ; i < size ; i ++ ) { total += s [ i ] ; } if ( s [ 0 ] <= target_sum && total >= target_sum ) { subset_sum ( s , tuplet_vector , size , 0 , 0 , 0 , target_sum ) ; } free ( tuplet_vector ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int weights [ ] = { 15 , 22 , 14 , 26 , 32 , 9 , 16 , 8 } ; int target = 53 ; int size = ARRAYSIZE ( weights ) ; generateSubsets ( weights , size , target ) ; printf ( \" Nodes ▁ generated ▁ % d STRNEWLINE \" , total_nodes ) ; return 0 ; }"}
{"text": "C program to check if given array has 2 elements whose sum is equal to the given value", "code": "#include <stdio.h> NEW_LINE #define MAX  100000"}
{"text": "function to check for the given sum in the array", "code": "void printPairs ( int arr [ ] , int arr_size , int sum ) { int i , temp ; bool s [ MAX ] = { 0 } ; for ( i = 0 ; i < arr_size ; i ++ ) { temp = sum - arr [ i ] ;"}
{"text": "checking for condition", "code": "if ( s [ temp ] == 1 ) printf ( \" Pair ▁ with ▁ given ▁ sum ▁ % d ▁ is ▁ ( % d , ▁ % d ) ▁ n \" , sum , arr [ i ] , temp ) ; s [ arr [ i ] ] = 1 ; } }"}
{"text": "Driver Code", "code": "int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int n = 16 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; printPairs ( A , arr_size , n ) ; getchar ( ) ; return 0 ; }"}
{"text": "Recursive C program to compute modular power", "code": "#include <stdio.h> NEW_LINE int exponentMod ( int A , int B , int C ) {"}
{"text": "Base cases", "code": "if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ;"}
{"text": "If B is even", "code": "long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; }"}
{"text": "If B is odd", "code": "else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int A = 2 , B = 5 , C = 13 ; printf ( \" Power ▁ is ▁ % d \" , exponentMod ( A , B , C ) ) ; return 0 ; }"}
{"text": "Iterative Function to calculate ( x ^ y ) in O ( log y )", "code": "int power ( int x , unsigned int y ) {"}
{"text": "Initialize result", "code": "int res = 1 ; while ( y > 0 ) {"}
{"text": "If y is odd , multiply x with result", "code": "if ( y & 1 ) res = res * x ;"}
{"text": "y must be even now y = y / 2", "code": "y = y >> 1 ;"}
{"text": "Change x to x ^ 2", "code": "x = x * x ; } return res ; }"}
{"text": "A utility function to get maximum of two integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Function to get minimum number of trials needed in worst case with n eggs and k floors", "code": "int eggDrop ( int n , int k ) {"}
{"text": "If there are no floors , then no trials needed . OR if there is one floor , one trial needed .", "code": "if ( k == 1 k == 0 ) return k ;"}
{"text": "We need k trials for one egg and k floors", "code": "if ( n == 1 ) return k ; int min = INT_MAX , x , res ;"}
{"text": "Consider all droppings from 1 st floor to kth floor and return the minimum of these values plus 1.", "code": "for ( x = 1 ; x <= k ; x ++ ) { res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 2 , k = 10 ; printf ( \" nMinimum ▁ number ▁ of ▁ trials ▁ in ▁ \" \" worst ▁ case ▁ with ▁ % d ▁ eggs ▁ and ▁ \" \" % d ▁ floors ▁ is ▁ % d ▁ STRNEWLINE \" , n , k , eggDrop ( n , k ) ) ; return 0 ; }"}
{"text": "struct containing left and right child of current node and key value", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "newNode ( ) allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver code", "code": "int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find maximum and minimum in a Binary Tree", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A tree node", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "A utility function to create a new node", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; }"}
{"text": "Returns maximum value in a given Binary Tree", "code": "int findMax ( struct Node * root ) {"}
{"text": "Base case", "code": "if ( root == NULL ) return INT_MIN ;"}
{"text": "Return maximum of 3 values : 1 ) Root 's data 2) Max in Left Subtree 3) Max in right subtree", "code": "int res = root -> data ; int lres = findMax ( root -> left ) ; int rres = findMax ( root -> right ) ; if ( lres > res ) res = lres ; if ( rres > res ) res = rres ; return res ; }"}
{"text": "Driver code", "code": "int main ( void ) { struct Node * NewRoot = NULL ; struct Node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ;"}
{"text": "Function call", "code": "printf ( \" Maximum ▁ element ▁ is ▁ % d ▁ STRNEWLINE \" , findMax ( root ) ) ; return 0 ; }"}
{"text": "Returns minimum value in a given Binary Tree", "code": "int findMin ( struct Node * root ) { if ( root == NULL ) return INT_MAX ; int res = root -> data ; int lres = findMin ( root -> left ) ; int rres = findMin ( root -> right ) ; if ( lres < res ) res = lres ; if ( rres < res ) res = rres ; return res ; }"}
{"text": "C program to extract leaves of a Binary Tree in a Doubly Linked List", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Structure for tree and linked list", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "Main function which extracts all leaves from given Binary Tree . The function returns new root of Binary Tree ( Note that root may changeif Binary Tree has only one node ) . The function also sets * head_ref as head of doubly linked list . left pointer of tree is used as prev in DLL and right pointer is used as next", "code": "struct Node * extractLeafList ( struct Node * root , struct Node * * head_ref ) { if ( root == NULL ) return NULL ; if ( root -> left == NULL && root -> right == NULL ) { root -> right = * head_ref ; if ( * head_ref != NULL ) ( * head_ref ) -> left = root ; return NULL ; } root -> right = extractLeafList ( root -> right , head_ref ) ; root -> left = extractLeafList ( root -> left , head_ref ) ; return root ; }"}
{"text": "Utility function for allocating node for Binary Tree .", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; }"}
{"text": "Utility function for printing tree in In - Order .", "code": "void print ( struct Node * root ) { if ( root != NULL ) { print ( root -> left ) ; printf ( \" % d ▁ \" , root -> data ) ; print ( root -> right ) ; } }"}
{"text": "Utility function for printing double linked list .", "code": "void printList ( struct Node * head ) { while ( head ) { printf ( \" % d ▁ \" , head -> data ) ; head = head -> right ; } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { struct Node * head = NULL ; struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> left -> left -> left = newNode ( 7 ) ; root -> left -> left -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 9 ) ; root -> right -> right -> right = newNode ( 10 ) ; printf ( \" Inorder ▁ Trvaersal ▁ of ▁ given ▁ Tree ▁ is : STRNEWLINE \" ) ; print ( root ) ; root = extractLeafList ( root , & head ) ; printf ( \" Extracted Double Linked list is : \" printList ( head ) ; printf ( \" Inorder traversal of modified tree is : \" print ( root ) ; return 0 ; }"}
{"text": "C program for nth nodes of inorder traversals", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct Node { int data ; struct Node * left ; struct Node * right ; } ;"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Given a binary tree , print its nth nodes of inorder", "code": "void NthInorder ( struct Node * node , int n ) { static int count = 0 ; if ( node == NULL ) return ; if ( count <= n ) {"}
{"text": "first recur on left child", "code": "NthInorder ( node -> left , n ) ; count ++ ;"}
{"text": "when count = n then print element", "code": "if ( count == n ) printf ( \" % d ▁ \" , node -> data ) ;"}
{"text": "now recur on right child", "code": "NthInorder ( node -> right , n ) ; } }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { struct Node * root = newNode ( 10 ) ; root -> left = newNode ( 20 ) ; root -> right = newNode ( 30 ) ; root -> left -> left = newNode ( 40 ) ; root -> left -> right = newNode ( 50 ) ; int n = 4 ; NthInorder ( root , n ) ; return 0 ; }"}
{"text": "A Simple implementation of QuickSort that makes two two recursive calls .", "code": "void quickSort ( int arr [ ] , int low , int high ) { if ( low < high ) {"}
{"text": "pi is partitioning index , arr [ p ] is now at right place", "code": "int pi = partition ( arr , low , high ) ;"}
{"text": "Separately sort elements before partition and after partition", "code": "quickSort ( arr , low , pi - 1 ) ; quickSort ( arr , pi + 1 , high ) ; } }"}
{"text": "C program to implement the above approach", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Function to count the number of strings that can be generated by placing spaces between pair of adjacent characters", "code": "long long int countNumberOfStrings ( char * s ) {"}
{"text": "Length of the string", "code": "int length = strlen ( s ) ;"}
{"text": "Count of positions for spaces", "code": "int n = length - 1 ;"}
{"text": "Count of possible strings", "code": "long long int count = pow ( 2 , n ) ; return count ; }"}
{"text": "Driver Code", "code": "int main ( ) { char S [ ] = \" ABCD \" ; printf ( \" % lld \" , countNumberOfStrings ( S ) ) ; return 0 ; }"}
{"text": "C ++ program for the above approach", "code": "#include <stdio.h>"}
{"text": "Function to modify array to make sum of odd and even indexed elements equal", "code": "void makeArraySumEqual ( int a [ ] , int N ) {"}
{"text": "Stores the count of 0 s , 1 s", "code": "int count_0 = 0 , count_1 = 0 ;"}
{"text": "Stores sum of odd and even indexed elements respectively", "code": "int odd_sum = 0 , even_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) {"}
{"text": "Count 0 s", "code": "if ( a [ i ] == 0 ) count_0 ++ ;"}
{"text": "Count 1 s", "code": "else count_1 ++ ;"}
{"text": "Calculate odd_sum and even_sum", "code": "if ( ( i + 1 ) % 2 == 0 ) even_sum += a [ i ] ; else if ( ( i + 1 ) % 2 > 0 ) odd_sum += a [ i ] ; }"}
{"text": "If both are equal", "code": "if ( odd_sum == even_sum ) {"}
{"text": "Print the original array", "code": "for ( int i = 0 ; i < N ; i ++ ) printf ( \" % d ▁ \" , a [ i ] ) ; }"}
{"text": "Otherwise", "code": "else { if ( count_0 >= N / 2 ) {"}
{"text": "Print all the 0 s", "code": "for ( int i = 0 ; i < count_0 ; i ++ ) printf ( \"0 ▁ \" ) ; } else {"}
{"text": "For checking even or odd", "code": "int is_Odd = count_1 % 2 ;"}
{"text": "Update total count of 1 s", "code": "count_1 -= is_Odd ;"}
{"text": "Print all 1 s", "code": "for ( int i = 0 ; i < count_1 ; i ++ ) printf ( \"1 ▁ \" ) ; } } }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given array arr [ ]", "code": "int arr [ ] = { 1 , 1 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Function Call", "code": "makeArraySumEqual ( arr , N ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Function to count the number of N - digit numbers such that sum of every k consecutive digits are equal", "code": "int countDigitSum ( int N , int K ) {"}
{"text": "Range of numbers", "code": "int l = ( int ) pow ( 10 , N - 1 ) , r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ;"}
{"text": "Extract digits of the number", "code": "int digits [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ;"}
{"text": "Store the sum of first K digits", "code": "for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ;"}
{"text": "Check for every k - consecutive digits using sliding window", "code": "for ( int j = K ; j < N ; j ++ ) { if ( sum - digits [ j - K ] + digits [ j ] != sum ) { flag = 1 ; break ; } } if ( flag == 0 ) count ++ ; } return count ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given integer N and K", "code": "int N = 2 , K = 1 ; printf ( \" % d \" , countDigitSum ( N , K ) ) ; return 0 ; }"}
{"text": "C ++ program for above approach .", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "Function to find print path", "code": "void findpath ( int N , int a [ ] ) {"}
{"text": "If a [ 0 ] is 1", "code": "if ( a [ 0 ] ) {"}
{"text": "Printing path", "code": "printf ( \" % d ▁ \" , N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , i ) ; return ; }"}
{"text": "Seeking for a [ i ] = 0 and a [ i + 1 ] = 1", "code": "for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ! a [ i ] && a [ i + 1 ] ) {"}
{"text": "Printing path", "code": "for ( int j = 1 ; j <= i ; j ++ ) printf ( \" % d ▁ \" , j ) ; printf ( \" % d ▁ \" , N + 1 ) ; for ( int j = i + 1 ; j <= N ; j ++ ) printf ( \" % d ▁ \" , j ) ; return ; } }"}
{"text": "If a [ N - 1 ] = 0", "code": "for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , i ) ; printf ( \" % d ▁ \" , N + 1 ) ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given Input", "code": "int N = 3 , arr [ ] = { 0 , 1 , 0 } ;"}
{"text": "Function Call", "code": "findpath ( N , arr ) ; }"}
{"text": "CPP code for Dynamic Programming based solution for 0 - 1 Knapsack problem", "code": "#include <stdio.h>"}
{"text": "A utility function that returns maximum of two integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Prints the items which are put in a knapsack of capacity W", "code": "void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ;"}
{"text": "Build table K [ ] [ ] in bottom up manner", "code": "for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } }"}
{"text": "stores the result of Knapsack", "code": "int res = K [ n ] [ W ] ; printf ( \" % d STRNEWLINE \" , res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) {"}
{"text": "either the result comes from the top ( K [ i - 1 ] [ w ] ) or from ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] ) as in Knapsack table . If it comes from the latter one / it means the item is included .", "code": "if ( res == K [ i - 1 ] [ w ] ) continue ; else {"}
{"text": "This item is included .", "code": "printf ( \" % d ▁ \" , wt [ i - 1 ] ) ;"}
{"text": "Since this weight is included its value is deducted", "code": "res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } }"}
{"text": "Driver code", "code": "int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printknapSack ( W , wt , val , n ) ; return 0 ; }"}
{"text": "A naive recursive implementation of optimal binary search tree problem", "code": "#include <stdio.h> NEW_LINE #include <limits.h>"}
{"text": "A recursive function to calculate cost of optimal binary search tree", "code": "int optCost ( int freq [ ] , int i , int j ) {"}
{"text": "Base cases if ( j < i ) no elements in this subarray", "code": "return 0 ;"}
{"text": "one element in this subarray", "code": "if ( j == i ) return freq [ i ] ;"}
{"text": "Get sum of freq [ i ] , freq [ i + 1 ] , ... freq [ j ]", "code": "int fsum = sum ( freq , i , j ) ;"}
{"text": "Initialize minimum value", "code": "int min = INT_MAX ;"}
{"text": "One by one consider all elements as root and recursively find cost of the BST , compare the cost with min and update min if needed", "code": "for ( int r = i ; r <= j ; ++ r ) { int cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; }"}
{"text": "Return minimum value", "code": "return min + fsum ; }"}
{"text": "The main function that calculates minimum cost of a Binary Search Tree . It mainly uses optCost ( ) to find the optimal cost .", "code": "int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) {"}
{"text": "Here array keys [ ] is assumed to be sorted in increasing order . If keys [ ] is not sorted , then add code to sort keys , and rearrange freq [ ] accordingly .", "code": "return optCost ( freq , 0 , n - 1 ) ; }"}
{"text": "A utility function to get sum of array elements freq [ i ] to freq [ j ]", "code": "int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; printf ( \" Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ % d ▁ \" , optimalSearchTree ( keys , freq , n ) ) ; return 0 ; }"}
{"text": "A Dynamic programming solution for Word Wrap Problem", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #define INF  INT_MAX"}
{"text": "A utility function to print the solution", "code": "int printSolution ( int p [ ] , int n ) ;"}
{"text": "l [ ] represents lengths of different words in input sequence . For example , l [ ] = { 3 , 2 , 2 , 5 } is for a sentence like \" aaa ▁ bb ▁ cc ▁ ddddd \" . n is size of l [ ] and M is line width ( maximum no . of characters that can fit in a line )", "code": "void solveWordWrap ( int l [ ] , int n , int M ) {"}
{"text": "extras [ i ] [ j ] will have number of extra spaces if words from i to j are put in a single line", "code": "int extras [ n + 1 ] [ n + 1 ] ;"}
{"text": "lc [ i ] [ j ] will have cost of a line which has words from i to j", "code": "int lc [ n + 1 ] [ n + 1 ] ;"}
{"text": "c [ i ] will have total cost of optimal arrangement of words from 1 to i", "code": "int c [ n + 1 ] ;"}
{"text": "p [ ] is used to print the solution .", "code": "int p [ n + 1 ] ; int i , j ;"}
{"text": "calculate extra spaces in a single line . The value extra [ i ] [ j ] indicates extra spaces if words from word number i to j are placed in a single line", "code": "for ( i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; }"}
{"text": "Calculate line cost corresponding to the above calculated extra spaces . The value lc [ i ] [ j ] indicates cost of putting words from word number i to j in a single line", "code": "for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = INF ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } }"}
{"text": "Calculate minimum cost and find minimum cost arrangement . The value c [ j ] indicates optimized cost to arrange words from word number 1 to j .", "code": "c [ 0 ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { c [ j ] = INF ; for ( i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != INF && lc [ i ] [ j ] != INF && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; } int printSolution ( int p [ ] , int n ) { int k ; if ( p [ n ] == 1 ) k = 1 ; else k = printSolution ( p , p [ n ] - 1 ) + 1 ; printf ( \" Line ▁ number ▁ % d : ▁ From ▁ word ▁ no . ▁ % d ▁ to ▁ % d ▁ STRNEWLINE \" , k , p [ n ] , n ) ; return k ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int l [ ] = { 3 , 2 , 2 , 5 } ; int n = sizeof ( l ) / sizeof ( l [ 0 ] ) ; int M = 6 ; solveWordWrap ( l , n , M ) ; return 0 ; }"}
{"text": "A Dynamic Programming based for the Egg Dropping Puzzle", "code": "#include <limits.h> NEW_LINE #include <stdio.h>"}
{"text": "A utility function to get maximum of two integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Function to get minimum number of trials needed in worst case with n eggs and k floors", "code": "int eggDrop ( int n , int k ) {"}
{"text": "A 2D table where entry eggFloor [ i ] [ j ] will represent minimum number of trials needed for i eggs and j floors .", "code": "int eggFloor [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ;"}
{"text": "We need one trial for one floor and 0 trials for 0 floors", "code": "for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; }"}
{"text": "We always need j trials for one egg and j floors .", "code": "for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ;"}
{"text": "Fill rest of the entries in table using optimal substructure property", "code": "for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = INT_MAX ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } }"}
{"text": "eggFloor [ n ] [ k ] holds the result", "code": "return eggFloor [ n ] [ k ] ; }"}
{"text": "Driver program to test to pront printDups", "code": "int main ( ) { int n = 2 , k = 36 ; printf ( \" Minimum number of trials \" STRNEWLINE \" in worst case with % d eggs and \" STRNEWLINE \" % d floors is % d \" , n , k , eggDrop ( n , k ) ) ; return 0 ; }"}
{"text": "A Naive recursive implementation of 0 - 1 Knapsack problem", "code": "#include <stdio.h>"}
{"text": "A utility function that returns maximum of two integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Returns the maximum value that can be put in a knapsack of capacity W", "code": "int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {"}
{"text": "Base Case", "code": "if ( n == 0 W == 0 ) return 0 ;"}
{"text": "If weight of the nth item is more than Knapsack capacity W , then this item cannot be included in the optimal solution", "code": "if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ;"}
{"text": "Return the maximum of two cases : ( 1 ) nth item included ( 2 ) not included", "code": "else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printf ( \" % d \" , knapSack ( W , wt , val , n ) ) ; return 0 ; }"}
{"text": "A Naive C recursive implementation of LIS problem", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "stores the LIS", "code": "let max_ref ;"}
{"text": "To make use of recursive calls , thisfunction must return two things : 1 ) Length of LIS ending with element arr [ n - 1 ] . We use max_ending_here for this purpose2 ) Overall maximum as the LIS may end with an element before arr [ n - 1 ] max_ref is used this purpose . The value of LIS of full array of size n is stored in * max_ref which is our final result", "code": "int _lis ( int arr [ ] , int n , int * max_ref ) {"}
{"text": "Base case", "code": "if ( n == 1 ) return 1 ;"}
{"text": "' max _ ending _ here ' is length of LIS ending with arr [ n - 1 ]", "code": "int res , max_ending_here = 1 ;"}
{"text": "Recursively get all LIS ending with arr [ 0 ] , arr [ 1 ] ... arr [ n - 2 ] . If arr [ i - 1 ] is smaller than arr [ n - 1 ] , and max ending with arr [ n - 1 ] needs to be updated , then update it", "code": "for ( int i = 1 ; i < n ; i ++ ) { res = _lis ( arr , i , max_ref ) ; if ( arr [ i - 1 ] < arr [ n - 1 ] && res + 1 > max_ending_here ) max_ending_here = res + 1 ; }"}
{"text": "Compare max_ending_here with the overall max . And update the overall max if needed", "code": "if ( * max_ref < max_ending_here ) * max_ref = max_ending_here ;"}
{"text": "Return length of LIS ending with arr [ n - 1 ]", "code": "return max_ending_here ; }"}
{"text": "The wrapper function for _lis ( )", "code": "int lis ( int arr [ ] , int n ) {"}
{"text": "The max variable holds the result", "code": "int max = 1 ;"}
{"text": "The function _lis ( ) stores its result in max", "code": "_lis ( arr , n , & max ) ;"}
{"text": "returns max", "code": "return max ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Length ▁ of ▁ lis ▁ is ▁ % d \" , lis ( arr , n ) ) ; return 0 ; }"}
{"text": "Following program is a C implementation of Rabin Karp Algorithm given in the CLRS book", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "d is the number of characters in the input alphabet", "code": "#define d  256"}
{"text": "pat -> pattern txt -> text q -> A prime number", "code": "void search ( char pat [ ] , char txt [ ] , int q ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i , j ;"}
{"text": "int p = 0 ; hash value for pattern int t = 0 ; hash value for txt", "code": "int h = 1 ;"}
{"text": "The value of h would be \" pow ( d , ▁ M - 1 ) % q \"", "code": "for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ;"}
{"text": "Calculate the hash value of pattern and first window of text", "code": "for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; }"}
{"text": "Slide the pattern over text one by one", "code": "for ( i = 0 ; i <= N - M ; i ++ ) {"}
{"text": "Check the hash values of current window of text and pattern . If the hash values match then only check for characters on by one", "code": "if ( p == t ) {"}
{"text": "Check for characters one by one", "code": "for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; }"}
{"text": "if p == t and pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ]", "code": "if ( j == M ) printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; }"}
{"text": "Calculate hash value for next window of text : Remove leading digit , add trailing digit", "code": "if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ;"}
{"text": "We might get negative value of t , converting it to positive", "code": "if ( t < 0 ) t = ( t + q ) ; } } }"}
{"text": "Driver Code", "code": "int main ( ) { char txt [ ] = \" GEEKS ▁ FOR ▁ GEEKS \" ; char pat [ ] = \" GEEK \" ;"}
{"text": "A prime number", "code": "int q = 101 ;"}
{"text": "function call", "code": "search ( pat , txt , q ) ; return 0 ; }"}
{"text": "C program for Knight Tour problem", "code": "#include <stdio.h> NEW_LINE #define N  8 NEW_LINE int solveKTUtil ( int x , int y , int movei , int sol [ N ] [ N ] , int xMove [ ] , int yMove [ ] ) ;"}
{"text": "A utility function to check if i , j are valid indexes for N * N chessboard", "code": "int isSafe ( int x , int y , int sol [ N ] [ N ] ) { return ( x >= 0 && x < N && y >= 0 && y < N && sol [ x ] [ y ] == -1 ) ; }"}
{"text": "A utility function to print solution matrix sol [ N ] [ N ]", "code": "void printSolution ( int sol [ N ] [ N ] ) { for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < N ; y ++ ) printf ( \" ▁ % 2d ▁ \" , sol [ x ] [ y ] ) ; printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "This function solves the Knight Tour problem using Backtracking . This function mainly uses solveKTUtil ( ) to solve the problem . It returns false if no complete tour is possible , otherwise return true and prints the tour . Please note that there may be more than one solutions , this function prints one of the feasible solutions .", "code": "int solveKT ( ) { int sol [ N ] [ N ] ;"}
{"text": "Initialization of solution matrix", "code": "for ( int x = 0 ; x < N ; x ++ ) for ( int y = 0 ; y < N ; y ++ ) sol [ x ] [ y ] = -1 ;"}
{"text": "xMove [ ] and yMove [ ] define next move of Knight . xMove [ ] is for next value of x coordinate yMove [ ] is for next value of y coordinate", "code": "int xMove [ 8 ] = { 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 } ; int yMove [ 8 ] = { 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 } ;"}
{"text": "Since the Knight is initially at the first block", "code": "sol [ 0 ] [ 0 ] = 0 ;"}
{"text": "Start from 0 , 0 and explore all tours using solveKTUtil ( )", "code": "if ( solveKTUtil ( 0 , 0 , 1 , sol , xMove , yMove ) == 0 ) { printf ( \" Solution ▁ does ▁ not ▁ exist \" ) ; return 0 ; } else printSolution ( sol ) ; return 1 ; }"}
{"text": "A recursive utility function to solve Knight Tour problem", "code": "int solveKTUtil ( int x , int y , int movei , int sol [ N ] [ N ] , int xMove [ N ] , int yMove [ N ] ) { int k , next_x , next_y ; if ( movei == N * N ) return 1 ;"}
{"text": "Try all next moves from the current coordinate x , y", "code": "for ( k = 0 ; k < 8 ; k ++ ) { next_x = x + xMove [ k ] ; next_y = y + yMove [ k ] ; if ( isSafe ( next_x , next_y , sol ) ) { sol [ next_x ] [ next_y ] = movei ; if ( solveKTUtil ( next_x , next_y , movei + 1 , sol , xMove , yMove ) == 1 ) return 1 ; else"}
{"text": "backtracking", "code": "sol [ next_x ] [ next_y ] = -1 ; } } return 0 ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Function Call", "code": "solveKT ( ) ; return 0 ; }"}
{"text": "Number of vertices in the graph", "code": "#define V  4 NEW_LINE void printSolution ( int color [ ] ) ;"}
{"text": "A utility function to print solution", "code": "void printSolution ( int color [ ] ) { printf ( \" Solution ▁ Exists : \" \" ▁ Following ▁ are ▁ the ▁ assigned ▁ colors ▁ STRNEWLINE \" ) ; for ( int i = 0 ; i < V ; i ++ ) printf ( \" ▁ % d ▁ \" , color [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "check if the colored graph is safe or not", "code": "bool isSafe ( bool graph [ V ] [ V ] , int color [ ] ) {"}
{"text": "check for every edge", "code": "for ( int i = 0 ; i < V ; i ++ ) for ( int j = i + 1 ; j < V ; j ++ ) if ( graph [ i ] [ j ] && color [ j ] == color [ i ] ) return false ; return true ; }"}
{"text": "This function solves the m Coloring problem using recursion . It returns false if the m colours cannot be assigned , otherwise , return true and prints assignments of colours to all vertices . Please note that there may be more than one solutions , this function prints one of the feasible solutions .", "code": "bool graphColoring ( bool graph [ V ] [ V ] , int m , int i , int color [ V ] ) {"}
{"text": "if current index reached end", "code": "if ( i == V ) {"}
{"text": "if coloring is safe", "code": "if ( isSafe ( graph , color ) ) {"}
{"text": "Print the solution", "code": "printSolution ( color ) ; return true ; } return false ; }"}
{"text": "Assign each color from 1 to m", "code": "for ( int j = 1 ; j <= m ; j ++ ) { color [ i ] = j ;"}
{"text": "Recur of the rest vertices", "code": "if ( graphColoring ( graph , m , i + 1 , color ) ) return true ; color [ i ] = 0 ; } return false ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) {"}
{"text": "Create following graph and test whether it is 3 colorable ( 3 ) -- - ( 2 ) | / | | / | | / | ( 0 ) -- - ( 1 )", "code": "bool graph [ V ] [ V ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 1 } , { 1 , 0 , 1 , 0 } , } ;"}
{"text": "Number of colors", "code": "int m = 3 ;"}
{"text": "Initialize all color values as 0. This initialization is needed correct functioning of isSafe ( )", "code": "int color [ V ] ; for ( int i = 0 ; i < V ; i ++ ) color [ i ] = 0 ; if ( ! graphColoring ( graph , m , 0 , color ) ) printf ( \" Solution ▁ does ▁ not ▁ exist \" ) ; return 0 ; }"}
{"text": "C implementation to find the previous and next power of K", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Function to return the highest power of k less than or equal to n", "code": "int prevPowerofK ( int n , int k ) { int p = ( int ) ( log ( n ) / log ( k ) ) ; return ( int ) pow ( k , p ) ; }"}
{"text": "Function to return the smallest power of k greater than or equal to n", "code": "int nextPowerOfK ( int n , int k ) { return prevPowerofK ( n , k ) * k ; }"}
{"text": "Driver Code", "code": "int main ( ) { int N = 7 ; int K = 2 ; printf ( \" % d ▁ \" , prevPowerofK ( N , K ) ) ; printf ( \" % d STRNEWLINE \" , nextPowerOfK ( N , K ) ) ; return 0 ; }"}
{"text": "C program to find GCD of two numbers", "code": "#include <stdio.h>"}
{"text": "Recursive function to return gcd of a and b", "code": "int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int a = 98 , b = 56 ; printf ( \" GCD ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "C Program to check whether number is semiprime or not", "code": "#include <stdio.h>"}
{"text": "Utility function to check whether number is semiprime or not", "code": "int checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) while ( num % i == 0 ) num /= i , ++ cnt ;"}
{"text": "If number is greater than 1 , add it to the count variable as it indicates the number remain is prime number", "code": "if ( num > 1 ) ++ cnt ;"}
{"text": "Return '1' if count is equal to '2' else return '0'", "code": "return cnt == 2 ; }"}
{"text": "Function to print ' True ' or ' False ' according to condition of semiprime", "code": "void semiprime ( int n ) { if ( checkSemiprime ( n ) ) printf ( \" True STRNEWLINE \" ) ; else printf ( \" False STRNEWLINE \" ) ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 6 ; semiprime ( n ) ; n = 8 ; semiprime ( n ) ; return 0 ; }"}
{"text": "A recursive C program to print REVERSE level order traversal", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , pointer to left and right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Function protoypes", "code": "void printGivenLevel ( struct node * root , int level ) ; int height ( struct node * node ) ; struct node * newNode ( int data ) ;"}
{"text": "Function to print REVERSE level order traversal a tree", "code": "void reverseLevelOrder ( struct node * root ) { int h = height ( root ) ; int i ; for ( i = h ; i >= 1 ; i -- ) printGivenLevel ( root , i ) ; }"}
{"text": "Print nodes at a given level", "code": "void printGivenLevel ( struct node * root , int level ) { if ( root == NULL ) return ; if ( level == 1 ) printf ( \" % d ▁ \" , root -> data ) ; else if ( level > 1 ) { printGivenLevel ( root -> left , level - 1 ) ; printGivenLevel ( root -> right , level - 1 ) ; } }"}
{"text": "Compute the \" height \" of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node .", "code": "int height ( struct node * node ) { if ( node == NULL ) return 0 ; else {"}
{"text": "compute the height of each subtree", "code": "int lheight = height ( node -> left ) ; int rheight = height ( node -> right ) ;"}
{"text": "use the larger one", "code": "if ( lheight > rheight ) return ( lheight + 1 ) ; else return ( rheight + 1 ) ; } }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Let us create trees shown in above diagram", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ tree ▁ is ▁ STRNEWLINE \" ) ; reverseLevelOrder ( root ) ; return 0 ; }"}
{"text": "C program for Indexed Sequential Search", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void indexedSequentialSearch ( int arr [ ] , int n , int k ) { int elements [ 20 ] , indices [ 20 ] , temp , i , set = 0 ; int j = 0 , ind = 0 , start , end ; for ( i = 0 ; i < n ; i += 3 ) {"}
{"text": "Storing element", "code": "elements [ ind ] = arr [ i ] ;"}
{"text": "Storing the index", "code": "indices [ ind ] = i ; ind ++ ; } if ( k < elements [ 0 ] ) { printf ( \" Not ▁ found \" ) ; exit ( 0 ) ; } else { for ( i = 1 ; i <= ind ; i ++ ) if ( k <= elements [ i ] ) { start = indices [ i - 1 ] ; end = indices [ i ] ; set = 1 ; break ; } } if ( set == 0 ) { start = indices [ i - 1 ] ; end = n ; } for ( i = start ; i <= end ; i ++ ) { if ( k == arr [ i ] ) { j = 1 ; break ; } } if ( j == 1 ) printf ( \" Found ▁ at ▁ index ▁ % d \" , i ) ; else printf ( \" Not ▁ found \" ) ; }"}
{"text": "Driver code", "code": "void main ( ) { int arr [ ] = { 6 , 7 , 8 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Element to search", "code": "int k = 8 ;"}
{"text": "Function call", "code": "indexedSequentialSearch ( arr , n , k ) ; }"}
{"text": "Simple C program to print next smaller elements in a given array", "code": "#include <stdio.h>"}
{"text": "prints element and NSE pair for all elements of arr [ ] of size n", "code": "void printNSE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } printf ( \" % d ▁ - - ▁ % d STRNEWLINE \" , arr [ i ] , next ) ; } }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNSE ( arr , n ) ; return 0 ; }"}
{"text": "C program for the implementation of MSD Radix Sort using counting sort ( )", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h>"}
{"text": "A utility function to print an array", "code": "void print ( int * arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { printf ( \" % d , ▁ \" , arr [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "A utility function to get the digit at index d in a integer", "code": "int digit_at ( int x , int d ) { return ( int ) ( x / pow ( 10 , d - 1 ) ) % 10 ; }"}
{"text": "function to sort array using MSD Radix Sort recursively", "code": "void MSD_sort ( int * arr , int lo , int hi , int d ) {"}
{"text": "recursion break condition", "code": "if ( hi <= lo d < 1 ) { return ; } int count [ 10 + 2 ] = { 0 } ;"}
{"text": "temp is created to easily swap strings in arr [ ]", "code": "int temp [ n ] ;"}
{"text": "Store occurrences of most significant character from each integer in count [ ]", "code": "for ( int i = lo ; i <= hi ; i ++ ) { int c = digit_at ( arr [ i ] , d ) ; count ++ ; }"}
{"text": "Change count [ ] so that count [ ] now contains actual position of this digits in temp [ ]", "code": "for ( int r = 0 ; r < 10 + 1 ; r ++ ) count [ r + 1 ] += count [ r ] ;"}
{"text": "Build the temp", "code": "for ( int i = lo ; i <= hi ; i ++ ) { int c = digit_at ( arr [ i ] , d ) ; temp [ count ++ ] = arr [ i ] ; }"}
{"text": "Copy all integer of temp to arr [ ] , so that arr [ ] now contains partially sorted integers", "code": "for ( int i = lo ; i <= hi ; i ++ ) { arr [ i ] = temp [ i - lo ] ; }"}
{"text": "Recursively MSD_sort ( ) on each partially sorted integers set to sort them by their next digit", "code": "for ( int r = 0 ; r < 10 ; r ++ ) MSD_sort ( arr , lo + count [ r ] , lo + count [ r + 1 ] - 1 , d - 1 ) ; }"}
{"text": "function find the largest integer", "code": "int getMax ( int arr [ ] , int n ) { int mx = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > mx ) mx = arr [ i ] ; return mx ; }"}
{"text": "Main function to call MSD_sort", "code": "void radixsort ( int * arr , int n ) {"}
{"text": "Find the maximum number to know number of digits", "code": "int m = getMax ( arr , n ) ;"}
{"text": "get the length of the largest integer", "code": "int d = floor ( log10 ( abs ( m ) ) ) + 1 ;"}
{"text": "function call", "code": "MSD_sort ( arr , 0 , n - 1 , d ) ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Input array", "code": "int arr [ ] = { 9330 , 9950 , 718 , 8977 , 6790 , 95 , 9807 , 741 , 8586 , 5710 } ;"}
{"text": "Size of the array", "code": "n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Unsorted ▁ array ▁ : ▁ \" ) ;"}
{"text": "Print the unsorted array", "code": "print ( arr , n ) ;"}
{"text": "Function Call", "code": "radixsort ( arr , n ) ; printf ( \" Sorted ▁ array ▁ : ▁ \" ) ;"}
{"text": "Print the sorted array", "code": "print ( arr , n ) ; return 0 ; }"}
{"text": "Merge In Place in C", "code": "#include <stddef.h> NEW_LINE #include <stdio.h> NEW_LINE #define __INSERT_THRESH  5 NEW_LINE #define __swap ( x , y )  (t = *(x), *(x) = *(y), *(y) = t)"}
{"text": "Both sorted sub - arrays must be adjacent in ' a ' ' an ' is the length of the first sorted section in ' a ' ' bn ' is the length of the second sorted section in ' a '", "code": "static void merge ( int * a , size_t an , size_t bn ) { int * b = a + an , * e = b + bn , * s , t ;"}
{"text": "Return right now if we 're done", "code": "if ( an == 0 || bn == 0 || ! ( * b < * ( b - 1 ) ) ) return ;"}
{"text": "Do insertion sort to merge if size of sub - arrays are small enough", "code": "if ( an < __INSERT_THRESH && an <= bn ) { for ( int * p = b , * v ; p > a ;"}
{"text": "p -- ) Insert Sort A into B", "code": "for ( v = p , s = p - 1 ; v < e && * v < * s ; s = v , v ++ ) __swap ( s , v ) ; return ; } if ( bn < __INSERT_THRESH ) { for ( int * p = b , * v ; p < e ;"}
{"text": "p ++ ) Insert Sort B into A", "code": "for ( s = p , v = p - 1 ; s > a && * s < * v ; s = v , v -- ) __swap ( s , v ) ; return ; }"}
{"text": "Find the pivot points . Basically this is just finding the point in ' a ' where we can swap in the first part of ' b ' such that after the swap the last element in ' a ' will be less than or equal to the least element in ' b '", "code": "int * pa = a , * pb = b ; for ( s = a ; s < b && pb < e ; s ++ ) if ( * pb < * pa ) pb ++ ; else pa ++ ; pa += b - s ;"}
{"text": "Swap first part of b with last part of a", "code": "for ( int * la = pa , * fb = b ; la < b ; la ++ , fb ++ ) __swap ( la , fb ) ;"}
{"text": "Now merge the two sub - array pairings", "code": "merge ( a , pa - a , pb - b ) ; merge ( b , pb - b , e - pb ) ;"}
{"text": "} merge_array_inplace", "code": "#undef  __swap NEW_LINE #undef  __INSERT_THRESH"}
{"text": "Merge Sort Implementation", "code": "void merge_sort ( int * a , size_t n ) { size_t m = ( n + 1 ) / 2 ;"}
{"text": "Sort first and second halves", "code": "if ( m > 1 ) merge_sort ( a , m ) ; if ( n - m > 1 ) merge_sort ( a + m , n - m ) ;"}
{"text": "Now merge the two sorted sub - arrays together", "code": "merge ( a , m , n - m ) ; }"}
{"text": "Function to print an array", "code": "void print_array ( int a [ ] , size_t n ) { if ( n > 0 ) { printf ( \" % d \" , a [ 0 ] ) ; for ( size_t i = 1 ; i < n ; i ++ ) printf ( \" ▁ % d \" , a [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Driver program to test sort utiliyy", "code": "int main ( ) { int a [ ] = { 3 , 16 , 5 , 14 , 8 , 10 , 7 , 15 , 1 , 13 , 4 , 9 , 12 , 11 , 6 , 2 } ; size_t n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; merge_sort ( a , n ) ; print_array ( a , n ) ; return 0 ; }"}
{"text": "A Depth First Search based recursive function that returns true if a matching for vertex u is possible", "code": "bool bpm ( int table [ M ] [ N ] , int u , bool seen [ ] , int matchR [ ] ) {"}
{"text": "Try every receiver one by one", "code": "for ( int v = 0 ; v < N ; v ++ ) {"}
{"text": "If sender u has packets to send to receiver v and receiver v is not already mapped to any other sender just check if the number of packets is greater than '0' because only one packet can be sent in a time frame anyways", "code": "if ( table [ u ] [ v ] > 0 && ! seen [ v ] ) {"}
{"text": "Mark v as visited", "code": "seen [ v ] = true ;"}
{"text": "If receiver ' v ' is not assigned to any sender OR previously assigned sender for receiver v ( which is matchR [ v ] ) has an alternate receiver available . Since v is marked as visited in the above line , matchR [ v ] in the following recursive call will not get receiver ' v ' again", "code": "if ( matchR [ v ] < 0 || bpm ( table , matchR [ v ] , seen , matchR ) ) { matchR [ v ] = u ; return true ; } } } return false ; }"}
{"text": "Returns maximum number of packets that can be sent parallely in 1 time slot from sender to receiver", "code": "int maxBPM ( int table [ M ] [ N ] ) {"}
{"text": "An array to keep track of the receivers assigned to the senders . The value of matchR [ i ] is the sender ID assigned to receiver i . the value - 1 indicates nobody is assigned .", "code": "int matchR [ N ] ;"}
{"text": "Initially all receivers are not mapped to any senders", "code": "memset ( matchR , -1 , sizeof ( matchR ) ) ;"}
{"text": "Count of receivers assigned to senders", "code": "int result = 0 ; for ( int u = 0 ; u < M ; u ++ ) {"}
{"text": "Mark all receivers as not seen for next sender", "code": "bool seen [ N ] ; memset ( seen , 0 , sizeof ( seen ) ) ;"}
{"text": "Find if the sender ' u ' can be assigned to the receiver", "code": "if ( bpm ( table , u , seen , matchR ) ) result ++ ; } cout << \" The ▁ number ▁ of ▁ maximum ▁ packets ▁ sent ▁ in ▁ the ▁ time ▁ slot ▁ is ▁ \" << result << \" STRNEWLINE \" ; for ( int x = 0 ; x < N ; x ++ ) if ( matchR [ x ] + 1 != 0 ) cout << \" T \" << matchR [ x ] + 1 << \" - > ▁ R \" << x + 1 << \" STRNEWLINE \" ; return result ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int table [ M ] [ N ] = { { 0 , 2 , 0 } , { 3 , 0 , 1 } , { 2 , 4 , 0 } } ; int max_flow = maxBPM ( table ) ; return 0 ; }"}
{"text": "C Program to decode a base64 Encoded string back to ASCII string", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define SIZE  100"}
{"text": "char_set = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ ▁ abcdefghijklmnopqrstuvwxyz0123456789 + / \"", "code": "char * base64Decoder ( char encoded [ ] , int len_str ) { char * decoded_string ; decoded_string = ( char * ) malloc ( sizeof ( char ) * SIZE ) ; int i , j , k = 0 ;"}
{"text": "stores the bitstream .", "code": "int num = 0 ;"}
{"text": "count_bits stores current number of bits in num .", "code": "int count_bits = 0 ;"}
{"text": "selects 4 characters from encoded string at a time . find the position of each encoded character in char_set and stores in num .", "code": "for ( i = 0 ; i < len_str ; i += 4 ) { num = 0 , count_bits = 0 ; for ( j = 0 ; j < 4 ; j ++ ) {"}
{"text": "make space for 6 bits .", "code": "if ( encoded [ i + j ] != ' = ' ) { num = num << 6 ; count_bits += 6 ; }"}
{"text": "encoded [ i + j ] = ' E ' , ' E ' - ' A ' = 5 ' E ' has 5 th position in char_set .", "code": "if ( encoded [ i + j ] >= ' A ' && encoded [ i + j ] <= ' Z ' ) num = num | ( encoded [ i + j ] - ' A ' ) ;"}
{"text": "encoded [ i + j ] = ' e ' , ' e ' - ' a ' = 5 , 5 + 26 = 31 , ' e ' has 31 st position in char_set .", "code": "else if ( encoded [ i + j ] >= ' a ' && encoded [ i + j ] <= ' z ' ) num = num | ( encoded [ i + j ] - ' a ' + 26 ) ;"}
{"text": "encoded [ i + j ] = '8' , '8' - '0' = 8 8 + 52 = 60 , '8' has 60 th position in char_set .", "code": "else if ( encoded [ i + j ] >= '0' && encoded [ i + j ] <= '9' ) num = num | ( encoded [ i + j ] - '0' + 52 ) ;"}
{"text": "' + ' occurs in 62 nd position in char_set .", "code": "else if ( encoded [ i + j ] == ' + ' ) num = num | 62 ;"}
{"text": "' / ' occurs in 63 rd position in char_set .", "code": "else if ( encoded [ i + j ] == ' / ' ) num = num | 63 ;"}
{"text": "( str [ i + j ] == ' = ' ) remove 2 bits to delete appended bits during encoding .", "code": "else { num = num >> 2 ; count_bits -= 2 ; } } while ( count_bits != 0 ) { count_bits -= 8 ;"}
{"text": "255 in binary is 11111111", "code": "decoded_string [ k ++ ] = ( num >> count_bits ) & 255 ; } } decoded_string [ k ] = ' \\0' ; return decoded_string ; }"}
{"text": "Driver function", "code": "int main ( ) { char encoded_string [ ] = \" TUVOT04 = \" ; int len_str = sizeof ( encoded_string ) / sizeof ( encoded_string [ 0 ] ) ;"}
{"text": "Do not count last NULL character .", "code": "len_str -= 1 ; printf ( \" Encoded ▁ string ▁ : ▁ % s STRNEWLINE \" , encoded_string ) ; printf ( \" Decoded _ string ▁ : ▁ % s STRNEWLINE \" , base64Decoder ( encoded_string , len_str ) ) ; return 0 ; }"}
{"text": "C program to print all strings that contain all characters of a word", "code": "# include <stdio.h> NEW_LINE # include <stdlib.h> NEW_LINE # include <string.h> NEW_LINE # define NO_OF_CHARS  256"}
{"text": "prints list items having all characters of word", "code": "void print ( char * list [ ] , char * word , int list_size ) {"}
{"text": "Since calloc is used , map [ ] is initialized as 0", "code": "int * map = ( int * ) calloc ( sizeof ( int ) , NO_OF_CHARS ) ; int i , j , count , word_size ;"}
{"text": "Set the values in map", "code": "for ( i = 0 ; * ( word + i ) ; i ++ ) map [ * ( word + i ) ] = 1 ;"}
{"text": "Get the length of given word", "code": "word_size = strlen ( word ) ;"}
{"text": "Check each item of list if has all characters of word", "code": "for ( i = 0 ; i < list_size ; i ++ ) { for ( j = 0 , count = 0 ; * ( list [ i ] + j ) ; j ++ ) { if ( map [ * ( list [ i ] + j ) ] ) { count ++ ;"}
{"text": "unset the bit so that strings like sss not printed", "code": "map [ * ( list [ i ] + j ) ] = 0 ; } } if ( count == word_size ) printf ( \" % s \" , list [ i ] ) ;"}
{"text": "Set the values in map for next item", "code": "for ( j = 0 ; * ( word + j ) ; j ++ ) map [ * ( word + j ) ] = 1 ; } }"}
{"text": "Driver program to test to pront printDups", "code": "int main ( ) { char str [ ] = \" sun \" ; char * list [ ] = { \" geeksforgeeks \" , \" unsorted \" , \" sunday \" , \" just \" , \" sss \" } ; print ( list , str , 5 ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find first non - repeating character", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define NO_OF_CHARS  256"}
{"text": "Returns an array of size 256 containing count of characters in the passed char array", "code": "int * getCharCountArray ( char * str ) { int * count = ( int * ) calloc ( sizeof ( int ) , NO_OF_CHARS ) ; int i ; for ( i = 0 ; * ( str + i ) ; i ++ ) count [ * ( str + i ) ] ++ ; return count ; }"}
{"text": "The function returns index of first non - repeating character in a string . If all characters are repeating then returns - 1", "code": "int firstNonRepeating ( char * str ) { int * count = getCharCountArray ( str ) ; int index = -1 , i ; for ( i = 0 ; * ( str + i ) ; i ++ ) { if ( count [ * ( str + i ) ] == 1 ) { index = i ; break ; } }"}
{"text": "To avoid memory leak", "code": "free ( count ) ; return index ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char str [ ] = \" geeksforgeeks \" ; int index = firstNonRepeating ( str ) ; if ( index == -1 ) printf ( \" Either ▁ all ▁ characters ▁ are ▁ repeating ▁ or ▁ \" \" string ▁ is ▁ empty \" ) ; else printf ( \" First ▁ non - repeating ▁ character ▁ is ▁ % c \" , str [ index ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to divide a string in n equal parts", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Function to print n equal parts of str", "code": "void divideString ( char * str , int n ) { int str_size = strlen ( str ) ; int i ; int part_size ;"}
{"text": "Check if string can be divided in n equal parts", "code": "if ( str_size % n != 0 ) { printf ( \" Invalid ▁ Input : ▁ String ▁ size \" ) ; printf ( \" ▁ is ▁ not ▁ divisible ▁ by ▁ n \" ) ; return ; }"}
{"text": "Calculate the size of parts to find the division points", "code": "part_size = str_size / n ; for ( i = 0 ; i < str_size ; i ++ ) { if ( i % part_size == 0 ) printf ( \" STRNEWLINE \" ) ; printf ( \" % c \" , str [ i ] ) ; } } int main ( ) {"}
{"text": "length od string is 28", "code": "char * str = \" a _ simple _ divide _ string _ quest \" ;"}
{"text": "Print 4 equal parts of the string", "code": "divideString ( str , 4 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Slope based solution to check if three points are collinear .", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "function to check if point collinear or not", "code": "void collinear ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { if ( ( y3 - y2 ) * ( x2 - x1 ) == ( y2 - y1 ) * ( x3 - x2 ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int x1 = 1 , x2 = 1 , x3 = 0 , y1 = 1 , y2 = 6 , y3 = 9 ; collinear ( x1 , y1 , x2 , y2 , x3 , y3 ) ; return 0 ; }"}
{"text": "C Program to find m and c for a straight line given , x and y", "code": "#include <stdio.h>"}
{"text": "function to calculate m and c that best fit points represented by x [ ] and y [ ]", "code": "void bestApproximate ( int x [ ] , int y [ ] , int n ) { int i , j ; float m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += ( x [ i ] * x [ i ] ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - ( sum_x * sum_x ) ) ; c = ( sum_y - m * sum_x ) / n ; printf ( \" m ▁ = % ▁ f \" , m ) ; printf ( \" c = % f \" , c ) ; }"}
{"text": "Driver main function", "code": "int main ( ) { int x [ ] = { 1 , 2 , 3 , 4 , 5 } ; int y [ ] = { 14 , 27 , 40 , 55 , 68 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; bestApproximate ( x , y , n ) ; return 0 ; }"}
{"text": "A Naive recursive program to find minimum number insertions needed to make a string palindrome", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; }"}
{"text": "Recursive function to find minimum number of insertions", "code": "int findMinInsertions ( char str [ ] , int l , int h ) {"}
{"text": "Base Cases", "code": "if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ;"}
{"text": "Check if the first and last characters are same . On the basis of the comparison result , decide which subrpoblem ( s ) to call", "code": "return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { char str [ ] = \" geeks \" ; printf ( \" % d \" , findMinInsertions ( str , 0 , strlen ( str ) - 1 ) ) ; return 0 ; }"}
{"text": "C program for Morris Preorder traversal", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Preorder traversal without recursion and without stack", "code": "void morrisTraversalPreorder ( struct node * root ) { while ( root ) {"}
{"text": "If left child is null , print the current node data . Move to right child .", "code": "if ( root -> left == NULL ) { printf ( \" % d ▁ \" , root -> data ) ; root = root -> right ; } else {"}
{"text": "Find inorder predecessor", "code": "struct node * current = root -> left ; while ( current -> right && current -> right != root ) current = current -> right ;"}
{"text": "If the right child of inorder predecessor already points to this node", "code": "if ( current -> right == root ) { current -> right = NULL ; root = root -> right ; }"}
{"text": "If right child doesn 't point to this node, then print this  node and make right child point to this node", "code": "else { printf ( \" % d ▁ \" , root -> data ) ; current -> right = root ; root = root -> left ; } } } }"}
{"text": "Function for sStandard preorder traversal", "code": "void preorder ( struct node * root ) { if ( root ) { printf ( \" % d ▁ \" , root -> data ) ; preorder ( root -> left ) ; preorder ( root -> right ) ; } }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { struct node * root = NULL ; root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 11 ) ; morrisTraversalPreorder ( root ) ; printf ( \" STRNEWLINE \" ) ; preorder ( root ) ; return 0 ; }"}
{"text": "Given a reference ( pointer to pointer ) to the head of a list and an int , inserts a new node on the front of the list .", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "1 & 2 : Allocate the Node & Put in the data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "3. Make next of new node as head", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "4. move the head to point to the new node", "code": "( * head_ref ) = new_node ; }"}
{"text": "Given a node prev_node , insert a new node after the given prev_node", "code": "void insertAfter ( struct Node * prev_node , int new_data ) {"}
{"text": "1. check if the given prev_node is NULL", "code": "if ( prev_node == NULL ) { printf ( \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" ) ; return ; }"}
{"text": "2. Allocate the Node & 3. Put in the data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "4. Make next of new node as next of prev_node", "code": "new_node -> next = prev_node -> next ;"}
{"text": "5. move the next of prev_node as new_node", "code": "prev_node -> next = new_node ; }"}
{"text": "C program to detect loop in a linked list", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Link list node", "code": "struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "allocate node", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "put in the data", "code": "new_node -> data = new_data ;"}
{"text": "link the old list off the new node", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "move the head to point to the new node", "code": "( * head_ref ) = new_node ; } int detectLoop ( struct Node * list ) { struct Node * slow_p = list , * fast_p = list ; while ( slow_p && fast_p && fast_p -> next ) { slow_p = slow_p -> next ; fast_p = fast_p -> next -> next ; if ( slow_p == fast_p ) { return 1 ; } } return 0 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) {"}
{"text": "Start with the empty list", "code": "struct Node * head = NULL ; push ( & head , 20 ) ; push ( & head , 4 ) ; push ( & head , 15 ) ; push ( & head , 10 ) ;"}
{"text": "Create a loop for testing", "code": "head -> next -> next -> next -> next = head ; if ( detectLoop ( head ) ) printf ( \" Loop ▁ found \" ) ; else printf ( \" No ▁ Loop \" ) ; return 0 ; }"}
{"text": "Program to check if a linked list is palindrome", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Link list node", "code": "struct Node { char data ; struct Node * next ; } ; void reverse ( struct Node * * ) ; bool compareLists ( struct Node * , struct Node * ) ;"}
{"text": "Function to check if given linked list is palindrome or not", "code": "bool isPalindrome ( struct Node * head ) { struct Node * slow_ptr = head , * fast_ptr = head ; struct Node * second_half , * prev_of_slow_ptr = head ;"}
{"text": "To handle odd size list", "code": "struct Node * midnode = NULL ;"}
{"text": "initialize result", "code": "bool res = true ; if ( head != NULL && head -> next != NULL ) {"}
{"text": "Get the middle of the list . Move slow_ptr by 1 and fast_ptrr by 2 , slow_ptr will have the middle node", "code": "while ( fast_ptr != NULL && fast_ptr -> next != NULL ) { fast_ptr = fast_ptr -> next -> next ;"}
{"text": "We need previous of the slow_ptr for linked lists with odd elements", "code": "prev_of_slow_ptr = slow_ptr ; slow_ptr = slow_ptr -> next ; }"}
{"text": "fast_ptr would become NULL when there are even elements in list . And not NULL for odd elements . We need to skip the middle node for odd case and store it somewhere so that we can restore the original list", "code": "if ( fast_ptr != NULL ) { midnode = slow_ptr ; slow_ptr = slow_ptr -> next ; }"}
{"text": "Now reverse the second half and compare it with first half", "code": "second_half = slow_ptr ;"}
{"text": "NULL terminate first half", "code": "prev_of_slow_ptr -> next = NULL ;"}
{"text": "Reverse the second half", "code": "reverse ( & second_half ) ;"}
{"text": "compare", "code": "res = compareLists ( head , second_half ) ;"}
{"text": "Reverse the second half again", "code": "reverse ( & second_half ) ;"}
{"text": "If there was a mid node ( odd size case ) which was not part of either first half or second half .", "code": "if ( midnode != NULL ) { prev_of_slow_ptr -> next = midnode ; midnode -> next = second_half ; } else prev_of_slow_ptr -> next = second_half ; } return res ; }"}
{"text": "Function to reverse the linked list Note that this function may change the head", "code": "void reverse ( struct Node * * head_ref ) { struct Node * prev = NULL ; struct Node * current = * head_ref ; struct Node * next ; while ( current != NULL ) { next = current -> next ; current -> next = prev ; prev = current ; current = next ; } * head_ref = prev ; }"}
{"text": "Function to check if two input lists have same data", "code": "bool compareLists ( struct Node * head1 , struct Node * head2 ) { struct Node * temp1 = head1 ; struct Node * temp2 = head2 ; while ( temp1 && temp2 ) { if ( temp1 -> data == temp2 -> data ) { temp1 = temp1 -> next ; temp2 = temp2 -> next ; } else return 0 ; }"}
{"text": "Both are empty reurn 1", "code": "if ( temp1 == NULL && temp2 == NULL ) return 1 ;"}
{"text": "Will reach here when one is NULL and other is not", "code": "return 0 ; }"}
{"text": "Push a node to linked list . Note that this function changes the head", "code": "void push ( struct Node * * head_ref , char new_data ) {"}
{"text": "allocate node", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "link the old list off the new node", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "move the head to pochar to the new node", "code": "( * head_ref ) = new_node ; }"}
{"text": "A utility function to print a given linked list", "code": "void printList ( struct Node * ptr ) { while ( ptr != NULL ) { printf ( \" % c - > \" , ptr -> data ) ; ptr = ptr -> next ; } printf ( \" NULL STRNEWLINE \" ) ; }"}
{"text": "Drier program to test above function", "code": "int main ( ) {"}
{"text": "Start with the empty list", "code": "struct Node * head = NULL ; char str [ ] = \" abacaba \" ; int i ; for ( i = 0 ; str [ i ] != ' \\0' ; i ++ ) { push ( & head , str [ i ] ) ; printList ( head ) ; isPalindrome ( head ) ? printf ( \" Is ▁ Palindrome STRNEWLINE STRNEWLINE \" ) : printf ( \" Not ▁ Palindrome STRNEWLINE STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "This program swaps the nodes of linked list rather than swapping the field from the nodes .", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ;"}
{"text": "Function to swap nodes x and y in linked list by changing links", "code": "void swapNodes ( struct Node * * head_ref , int x , int y ) {"}
{"text": "Nothing to do if x and y are same", "code": "if ( x == y ) return ;"}
{"text": "Search for x ( keep track of prevX and CurrX", "code": "struct Node * prevX = NULL , * currX = * head_ref ; while ( currX && currX -> data != x ) { prevX = currX ; currX = currX -> next ; }"}
{"text": "Search for y ( keep track of prevY and CurrY", "code": "struct Node * prevY = NULL , * currY = * head_ref ; while ( currY && currY -> data != y ) { prevY = currY ; currY = currY -> next ; }"}
{"text": "If either x or y is not present , nothing to do", "code": "if ( currX == NULL currY == NULL ) return ;"}
{"text": "If x is not head of linked list", "code": "if ( prevX != NULL ) prevX -> next = currY ;"}
{"text": "Else make y as new head", "code": "else * head_ref = currY ;"}
{"text": "If y is not head of linked list", "code": "if ( prevY != NULL ) prevY -> next = currX ;"}
{"text": "Else make x as new head", "code": "else * head_ref = currX ;"}
{"text": "Swap next pointers", "code": "struct Node * temp = currY -> next ; currY -> next = currX -> next ; currX -> next = temp ; }"}
{"text": "Function to add a node at the beginning of List", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "allocate node and put in the data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "link the old list off the new node", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "move the head to point to the new node", "code": "( * head_ref ) = new_node ; }"}
{"text": "Function to print nodes in a given linked list", "code": "void printList ( struct Node * node ) { while ( node != NULL ) { printf ( \" % d ▁ \" , node -> data ) ; node = node -> next ; } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { struct Node * start = NULL ;"}
{"text": "The constructed linked list is : 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7", "code": "push ( & start , 7 ) ; push ( & start , 6 ) ; push ( & start , 5 ) ; push ( & start , 4 ) ; push ( & start , 3 ) ; push ( & start , 2 ) ; push ( & start , 1 ) ; printf ( \" Linked list before calling swapNodes ( ) \" printList ( start ) ; swapNodes ( & start , 4 , 3 ) ; printf ( \" Linked list after calling swapNodes ( ) \" printList ( start ) ; return 0 ; }"}
{"text": "Recursive function to pairwise swap elements of a linked list", "code": "void pairWiseSwap ( struct node * head ) {"}
{"text": "There must be at - least two nodes in the list", "code": "if ( head != NULL && head -> next != NULL ) {"}
{"text": "Swap the node 's data with data of next node", "code": "swap ( & head -> data , & head -> next -> data ) ;"}
{"text": "Call pairWiseSwap ( ) for rest of the list", "code": "pairWiseSwap ( head -> next -> next ) ; } }"}
{"text": "Case 2 of the above algo", "code": "else if ( current -> data >= new_node -> data ) {"}
{"text": "swap the data part of head node and new node assuming that we have a function swap ( int * , int * )", "code": "swap ( & ( current -> data ) , & ( new_node -> data ) ) ; new_node -> next = ( * head_ref ) -> next ; ( * head_ref ) -> next = new_node ; }"}
{"text": "Given a reference ( pointer to pointer ) to the head of a list and an int , inserts a new node on the front of the list .", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "1. allocate node * 2. put in the data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "3. Make next of new node as head and previous as NULL", "code": "new_node -> next = ( * head_ref ) ; new_node -> prev = NULL ;"}
{"text": "4. change prev of head node to new node", "code": "if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ;"}
{"text": "5. move the head to point to the new node", "code": "( * head_ref ) = new_node ; }"}
{"text": "Given a node as prev_node , insert a new node after the given node", "code": "void insertAfter ( struct Node * prev_node , int new_data ) {"}
{"text": "1. check if the given prev_node is NULL", "code": "if ( prev_node == NULL ) { printf ( \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" ) ; return ; }"}
{"text": "2. allocate node * 3. put in the data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "4. Make next of new node as next of prev_node", "code": "new_node -> next = prev_node -> next ;"}
{"text": "5. Make the next of prev_node as new_node", "code": "prev_node -> next = new_node ;"}
{"text": "6. Make prev_node as previous of new_node", "code": "new_node -> prev = prev_node ;"}
{"text": "7. Change previous of new_node 's next node", "code": "if ( new_node -> next != NULL ) new_node -> next -> prev = new_node ; }"}
{"text": "Given a reference ( pointer to pointer ) to the head of a DLL and an int , appends a new node at the end", "code": "void append ( struct Node * * head_ref , int new_data ) {"}
{"text": "1. allocate node 2. put in the data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * last = * head_ref ; new_node -> data = new_data ;"}
{"text": "3. This new node is going to be the last node , so make next of it as NULL", "code": "new_node -> next = NULL ;"}
{"text": "4. If the Linked List is empty , then make the new node as head", "code": "if ( * head_ref == NULL ) { new_node -> prev = NULL ; * head_ref = new_node ; return ; }"}
{"text": "5. Else traverse till the last node", "code": "while ( last -> next != NULL ) last = last -> next ;"}
{"text": "6. Change the next of last node", "code": "last -> next = new_node ;"}
{"text": "7. Make last node as previous of new node", "code": "new_node -> prev = last ; return ; }"}
{"text": "C program to insetail nodes in doubly linked list such that list remains in ascending order on printing from left to right", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A linked list node", "code": "struct Node { struct Node * prev ; int info ; struct Node * next ; } ;"}
{"text": "Function to insetail new node", "code": "void nodeInsetail ( struct Node * * head , struct Node * * tail , int key ) { struct Node * p = new Node ; p -> info = key ; p -> next = NULL ;"}
{"text": "If first node to be insetailed in doubly linked list", "code": "if ( ( * head ) == NULL ) { ( * head ) = p ; ( * tail ) = p ; ( * head ) -> prev = NULL ; return ; }"}
{"text": "If node to be insetailed has value less than first node", "code": "if ( ( p -> info ) < ( ( * head ) -> info ) ) { p -> prev = NULL ; ( * head ) -> prev = p ; p -> next = ( * head ) ; ( * head ) = p ; return ; }"}
{"text": "If node to be insetailed has value more than last node", "code": "if ( ( p -> info ) > ( ( * tail ) -> info ) ) { p -> prev = ( * tail ) ; ( * tail ) -> next = p ; ( * tail ) = p ; return ; }"}
{"text": "Find the node before which we need to insert p .", "code": "temp = ( * head ) -> next ; while ( ( temp -> info ) < ( p -> info ) ) temp = temp -> next ;"}
{"text": "Insert new node before temp", "code": "( temp -> prev ) -> next = p ; p -> prev = temp -> prev ; temp -> prev = p ; p -> next = temp ; }"}
{"text": "Function to print nodes in from left to right", "code": "void printList ( struct Node * temp ) { while ( temp != NULL ) { printf ( \" % d ▁ \" , temp -> info ) ; temp = temp -> next ; } }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { struct Node * left = NULL , * right = NULL ; nodeInsetail ( & left , & right , 30 ) ; nodeInsetail ( & left , & right , 50 ) ; nodeInsetail ( & left , & right , 90 ) ; nodeInsetail ( & left , & right , 10 ) ; nodeInsetail ( & left , & right , 40 ) ; nodeInsetail ( & left , & right , 110 ) ; nodeInsetail ( & left , & right , 60 ) ; nodeInsetail ( & left , & right , 95 ) ; nodeInsetail ( & left , & right , 23 ) ; printf ( \" Doubly linked list on printing \" ▁ \" from left to right \" printList ( left ) ; return 0 ; }"}
{"text": "A linked list node", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Prints a linked list in reverse manner", "code": "void fun1 ( struct Node * head ) { if ( head == NULL ) return ; fun1 ( head -> next ) ; printf ( \" % d ▁ \" , head -> data ) ; }"}
{"text": "prints alternate nodes of a Linked List , first from head to end , and then from end to head .", "code": "void fun2 ( struct Node * start ) { if ( start == NULL ) return ; printf ( \" % d ▁ \" , start -> data ) ; if ( start -> next != NULL ) fun2 ( start -> next -> next ) ; printf ( \" % d ▁ \" , start -> data ) ; }"}
{"text": "Given a reference ( pointer to pointer ) to the head of a list and an int , push a new node on the front of the list .", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "allocate node", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "put in the data", "code": "new_node -> data = new_data ;"}
{"text": "link the old list off the new node", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "move the head to point to the new node", "code": "( * head_ref ) = new_node ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Start with the empty list", "code": "struct Node * head = NULL ;"}
{"text": "Using push ( ) to construct below list 1 -> 2 -> 3 -> 4 -> 5", "code": "push ( & head , 5 ) ; push ( & head , 4 ) ; push ( & head , 3 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; printf ( \" Output ▁ of ▁ fun1 ( ) ▁ for ▁ list ▁ 1 - > 2 - > 3 - > 4 - > 5 ▁ STRNEWLINE \" ) ; fun1 ( head ) ; printf ( \" Output of fun2 ( ) for list 1 -> 2 -> 3 -> 4 -> 5 \" fun2 ( head ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find sqrt ( n ) 'th node  of a linked list", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Linked list node", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Function to get the sqrt ( n ) th node of a linked list", "code": "int printsqrtn ( struct Node * head ) { struct Node * sqrtn = NULL ; int i = 1 , j = 1 ;"}
{"text": "Traverse the list", "code": "while ( head != NULL ) {"}
{"text": "check if j = sqrt ( i )", "code": "if ( i == j * j ) {"}
{"text": "for first node", "code": "if ( sqrtn == NULL ) sqrtn = head ; else sqrtn = sqrtn -> next ;"}
{"text": "increment j if j = sqrt ( i )", "code": "j ++ ; } i ++ ; head = head -> next ; }"}
{"text": "return node 's data", "code": "return sqrtn -> data ; } void print ( struct Node * head ) { while ( head != NULL ) { printf ( \" % d ▁ \" , head -> data ) ; head = head -> next ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "function to add a new node at the beginning of the list", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "allocate node", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "put in the data", "code": "new_node -> data = new_data ;"}
{"text": "link the old list off the new node", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "move the head to point to the new node", "code": "( * head_ref ) = new_node ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) {"}
{"text": "Start with the empty list", "code": "struct Node * head = NULL ; push ( & head , 40 ) ; push ( & head , 30 ) ; push ( & head , 20 ) ; push ( & head , 10 ) ; printf ( \" Given ▁ linked ▁ list ▁ is : \" ) ; print ( head ) ; printf ( \" sqrt ( n ) th ▁ node ▁ is ▁ % d ▁ \" , printsqrtn ( head ) ) ; return 0 ; }"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Give a binary search tree and a number , inserts a new node with the given number in the correct place in the tree . Returns the new root pointer which the caller should then use ( the standard trick to avoid using reference parameters ) .", "code": "struct node * insert ( struct node * node , int data ) {"}
{"text": "1. If the tree is empty , return a new , single node", "code": "if ( node == NULL ) return ( newNode ( data ) ) ; else {"}
{"text": "2. Otherwise , recur down the tree", "code": "if ( data <= node -> data ) node -> left = insert ( node -> left , data ) ; else node -> right = insert ( node -> right , data ) ;"}
{"text": "return the ( unchanged ) node pointer", "code": "return node ; } }"}
{"text": "Given a non - empty binary search tree , return the minimum data value found in that tree . Note that the entire tree does not need to be searched .", "code": "int minValue ( struct node * node ) { struct node * current = node ;"}
{"text": "loop down to find the leftmost leaf", "code": "while ( current -> left != NULL ) { current = current -> left ; } return ( current -> data ) ; }"}
{"text": "Driver program to test sameTree function", "code": "int main ( ) { struct node * root = NULL ; root = insert ( root , 4 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 6 ) ; insert ( root , 5 ) ; printf ( \" Minimum value in BST is % d \" , minValue ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "program to construct tree using inorder and preorder traversals", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { char data ; struct node * left ; struct node * right ; } ;"}
{"text": "Prototypes for utility functions", "code": "int search ( char arr [ ] , int strt , int end , char value ) ; struct node * newNode ( char data ) ;"}
{"text": "Recursive function to construct binary of size len from Inorder traversal in [ ] and Preorder traversal pre [ ] . Initial values of inStrt and inEnd should be 0 and len - 1. The function doesn 't  do any error checking for cases where inorder and preorder  do not form a tree", "code": "struct node * buildTree ( char in [ ] , char pre [ ] , int inStrt , int inEnd ) { static int preIndex = 0 ; if ( inStrt > inEnd ) return NULL ;"}
{"text": "Pick current node from Preorder traversal using preIndex and increment preIndex", "code": "struct node * tNode = newNode ( pre [ preIndex ++ ] ) ;"}
{"text": "If this node has no children then return", "code": "if ( inStrt == inEnd ) return tNode ;"}
{"text": "Else find the index of this node in Inorder traversal", "code": "int inIndex = search ( in , inStrt , inEnd , tNode -> data ) ;"}
{"text": "Using index in Inorder traversal , construct left and right subtress", "code": "tNode -> left = buildTree ( in , pre , inStrt , inIndex - 1 ) ; tNode -> right = buildTree ( in , pre , inIndex + 1 , inEnd ) ; return tNode ; }"}
{"text": "Function to find index of value in arr [ start ... end ] The function assumes that value is present in in [ ]", "code": "int search ( char arr [ ] , int strt , int end , char value ) { int i ; for ( i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) return i ; } }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( char data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "This funtcion is here just to test buildTree ( )", "code": "void printInorder ( struct node * node ) { if ( node == NULL ) return ;"}
{"text": "first recur on left child", "code": "printInorder ( node -> left ) ;"}
{"text": "then print the data of node", "code": "printf ( \" % c ▁ \" , node -> data ) ;"}
{"text": "now recur on right child", "code": "printInorder ( node -> right ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { char in [ ] = { ' D ' , ' B ' , ' E ' , ' A ' , ' F ' , ' C ' } ; char pre [ ] = { ' A ' , ' B ' , ' D ' , ' E ' , ' C ' , ' F ' } ; int len = sizeof ( in ) / sizeof ( in [ 0 ] ) ; struct node * root = buildTree ( in , pre , 0 , len - 1 ) ;"}
{"text": "Let us test the built tree by printing Insorder traversal", "code": "printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ constructed ▁ tree ▁ is ▁ STRNEWLINE \" ) ; printInorder ( root ) ; getchar ( ) ; }"}
{"text": "A recursive C program to find LCA of two nodes n1 and n2 .", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ;"}
{"text": "Function to find LCA of n1 and n2 . The function assumes that both n1 and n2 are present in BST", "code": "struct node * lca ( struct node * root , int n1 , int n2 ) { while ( root != NULL ) {"}
{"text": "If both n1 and n2 are smaller than root , then LCA lies in left", "code": "if ( root -> data > n1 && root -> data > n2 ) root = root -> left ;"}
{"text": "If both n1 and n2 are greater than root , then LCA lies in right", "code": "else if ( root -> data < n1 && root -> data < n2 ) root = root -> right ; else break ; } return root ; }"}
{"text": "Helper function that allocates a new node with the given data .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver program to test lca ( )", "code": "int main ( ) {"}
{"text": "Let us construct the BST shown in the above figure", "code": "struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 22 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; int n1 = 10 , n2 = 14 ; struct node * t = lca ( root , n1 , n2 ) ; printf ( \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , n1 , n2 , t -> data ) ; n1 = 14 , n2 = 8 ; t = lca ( root , n1 , n2 ) ; printf ( \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , n1 , n2 , t -> data ) ; n1 = 10 , n2 = 22 ; t = lca ( root , n1 , n2 ) ; printf ( \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE \" , n1 , n2 , t -> data ) ; getchar ( ) ; return 0 ; }"}
{"text": "false if left is > than node", "code": "if ( node -> left != NULL && node -> left -> data > node -> data ) return 0 ;"}
{"text": "false if right is < than node", "code": "if ( node -> right != NULL && node -> right -> data < node -> data ) return 0 ;"}
{"text": "false if , recursively , the left or right is not a BST", "code": "if ( ! isBST ( node -> left ) || ! isBST ( node -> right ) ) return 0 ;"}
{"text": "passing all that , it 's a BST", "code": "return 1 ; }"}
{"text": "Returns true if a binary tree is a binary search tree", "code": "int isBST ( struct node * node ) { if ( node == NULL ) return 1 ;"}
{"text": "false if the max of the left is > than us", "code": "if ( node -> left != NULL && maxValue ( node -> left ) > node -> data ) return 0 ;"}
{"text": "false if the min of the right is <= than us", "code": "if ( node -> right != NULL && minValue ( node -> right ) < node -> data ) return 0 ;"}
{"text": "false if , recursively , the left or right is not a BST", "code": "if ( ! isBST ( node -> left ) || ! isBST ( node -> right ) ) return 0 ;"}
{"text": "passing all that , it 's a BST", "code": "return 1 ; }"}
{"text": "Check if each internal node of BST has only one child", "code": "#include <stdio.h> NEW_LINE bool hasOnlyOneChild ( int pre [ ] , int size ) { int nextDiff , lastDiff ; for ( int i = 0 ; i < size - 1 ; i ++ ) { nextDiff = pre [ i ] - pre [ i + 1 ] ; lastDiff = pre [ i ] - pre [ size - 1 ] ; if ( nextDiff * lastDiff < 0 ) return false ; ; } return true ; }"}
{"text": "driver program to test above function", "code": "int main ( ) { int pre [ ] = { 8 , 3 , 5 , 7 , 6 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; if ( hasOnlyOneChild ( pre , size ) == true ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Check if each internal node of BST has only one child", "code": "#include <stdio.h> NEW_LINE int hasOnlyOneChild ( int pre [ ] , int size ) {"}
{"text": "Initialize min and max using last two elements", "code": "int min , max ; if ( pre [ size - 1 ] > pre [ size - 2 ] ) { max = pre [ size - 1 ] ; min = pre [ size - 2 ] ) : else { max = pre [ size - 2 ] ; min = pre [ size - 1 ] ; }"}
{"text": "Every element must be either smaller than min or greater than max", "code": "for ( int i = size - 3 ; i >= 0 ; i -- ) { if ( pre [ i ] < min ) min = pre [ i ] ; else if ( pre [ i ] > max ) max = pre [ i ] ; else return false ; } return true ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int pre [ ] = { 8 , 3 , 5 , 7 , 6 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; if ( hasOnlyOneChild ( pre , size ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "C ++ program of AVL tree that handles duplicates", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "An AVL tree node", "code": "struct node { int key ; struct node * left ; struct node * right ; int height ; int count ; } ;"}
{"text": "A utility function to get maximum of two integers", "code": "int max ( int a , int b ) ;"}
{"text": "A utility function to get height of the tree", "code": "int height ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> height ; }"}
{"text": "A utility function to get maximum of two integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Helper function that allocates a new node with the given key and NULL left and right pointers .", "code": "struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ;"}
{"text": "new node is initially added at leaf", "code": "node -> height = 1 ; node -> count = 1 ; return ( node ) ; }"}
{"text": "A utility function to right rotate subtree rooted with y See the diagram given above .", "code": "struct node * rightRotate ( struct node * y ) { struct node * x = y -> left ; struct node * T2 = x -> right ;"}
{"text": "Perform rotation", "code": "x -> right = y ; y -> left = T2 ;"}
{"text": "Update heights", "code": "y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ;"}
{"text": "Return new root", "code": "return x ; }"}
{"text": "A utility function to left rotate subtree rooted with x See the diagram given above .", "code": "struct node * leftRotate ( struct node * x ) { struct node * y = x -> right ; struct node * T2 = y -> left ;"}
{"text": "Perform rotation", "code": "y -> left = x ; x -> right = T2 ;"}
{"text": "Update heights", "code": "x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ;"}
{"text": "Return new root", "code": "return y ; }"}
{"text": "Get Balance factor of node N", "code": "int getBalance ( struct node * N ) { if ( N == NULL ) return 0 ; return height ( N -> left ) - height ( N -> right ) ; } struct node * insert ( struct node * node , int key ) {"}
{"text": "1. Perform the normal BST rotation", "code": "if ( node == NULL ) return ( newNode ( key ) ) ;"}
{"text": "If key already exists in BST , increment count and return", "code": "if ( key == node -> key ) { ( node -> count ) ++ ; return node ; }"}
{"text": "Otherwise , recur down the tree", "code": "if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ;"}
{"text": "2. Update height of this ancestor node", "code": "node -> height = max ( height ( node -> left ) , height ( node -> right ) ) + 1 ;"}
{"text": "3. Get the balance factor of this ancestor node to check whether this node became unbalanced", "code": "int balance = getBalance ( node ) ;"}
{"text": "If this node becomes unbalanced , then there are 4 cases Left Left Case", "code": "if ( balance > 1 && key < node -> left -> key ) return rightRotate ( node ) ;"}
{"text": "Right Right Case", "code": "if ( balance < -1 && key > node -> right -> key ) return leftRotate ( node ) ;"}
{"text": "Left Right Case", "code": "if ( balance > 1 && key > node -> left -> key ) { node -> left = leftRotate ( node -> left ) ; return rightRotate ( node ) ; }"}
{"text": "Right Left Case", "code": "if ( balance < -1 && key < node -> right -> key ) { node -> right = rightRotate ( node -> right ) ; return leftRotate ( node ) ; }"}
{"text": "return the ( unchanged ) node pointer", "code": "return node ; }"}
{"text": "Given a non - empty binary search tree , return the node with minimum key value found in that tree . Note that the entire tree does not need to be searched .", "code": "struct node * minValueNode ( struct node * node ) { struct node * current = node ;"}
{"text": "loop down to find the leftmost leaf", "code": "while ( current -> left != NULL ) current = current -> left ; return current ; } struct node * deleteNode ( struct node * root , int key ) {"}
{"text": "STEP 1 : PERFORM STANDARD BST DELETE", "code": "if ( root == NULL ) return root ;"}
{"text": "If the key to be deleted is smaller than the root 's key,  then it lies in left subtree", "code": "if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ;"}
{"text": "If the key to be deleted is greater than the root 's key,  then it lies in right subtree", "code": "else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ;"}
{"text": "if key is same as root 's key, then This is the node  to be deleted", "code": "else {"}
{"text": "If key is present more than once , simply decrement count and return", "code": "if ( root -> count > 1 ) { ( root -> count ) -- ; return ; }"}
{"text": "Else , delete the node node with only one child or no child", "code": "if ( ( root -> left == NULL ) || ( root -> right == NULL ) ) { struct node * temp = root -> left ? root -> left : root -> right ;"}
{"text": "No child case", "code": "if ( temp == NULL ) { temp = root ; root = NULL ; }"}
{"text": "One child case", "code": "else"}
{"text": "Copy the contents of the non - empty child", "code": "* root = * temp ; free ( temp ) ; } else {"}
{"text": "node with two children : Get the inorder successor ( smallest in the right subtree )", "code": "struct node * temp = minValueNode ( root -> right ) ;"}
{"text": "Copy the inorder successor 's data to this node and update the count", "code": "root -> key = temp -> key ; root -> count = temp -> count ; temp -> count = 1 ;"}
{"text": "Delete the inorder successor", "code": "root -> right = deleteNode ( root -> right , temp -> key ) ; } }"}
{"text": "If the tree had only one node then return", "code": "if ( root == NULL ) return root ;"}
{"text": "STEP 2 : UPDATE HEIGHT OF THE CURRENT NODE", "code": "root -> height = max ( height ( root -> left ) , height ( root -> right ) ) + 1 ;"}
{"text": "STEP 3 : GET THE BALANCE FACTOR OF THIS NODE ( to check whether this node became unbalanced )", "code": "int balance = getBalance ( root ) ;"}
{"text": "If this node becomes unbalanced , then there are 4 cases Left Left Case", "code": "if ( balance > 1 && getBalance ( root -> left ) >= 0 ) return rightRotate ( root ) ;"}
{"text": "Left Right Case", "code": "if ( balance > 1 && getBalance ( root -> left ) < 0 ) { root -> left = leftRotate ( root -> left ) ; return rightRotate ( root ) ; }"}
{"text": "Right Right Case", "code": "if ( balance < -1 && getBalance ( root -> right ) <= 0 ) return leftRotate ( root ) ;"}
{"text": "Right Left Case", "code": "if ( balance < -1 && getBalance ( root -> right ) > 0 ) { root -> right = rightRotate ( root -> right ) ; return leftRotate ( root ) ; } return root ; }"}
{"text": "A utility function to print preorder traversal of the tree . The function also prints height of every node", "code": "void preOrder ( struct node * root ) { if ( root != NULL ) { printf ( \" % d ( % d ) ▁ \" , root -> key , root -> count ) ; preOrder ( root -> left ) ; preOrder ( root -> right ) ; } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { struct node * root = NULL ;"}
{"text": "Constructing tree given in the above figure", "code": "root = insert ( root , 9 ) ; root = insert ( root , 5 ) ; root = insert ( root , 10 ) ; root = insert ( root , 5 ) ; root = insert ( root , 9 ) ; root = insert ( root , 7 ) ; root = insert ( root , 17 ) ; printf ( \" Pre ▁ order ▁ traversal ▁ of ▁ the ▁ constructed ▁ AVL ▁ tree ▁ is ▁ STRNEWLINE \" ) ; preOrder ( root ) ; root = deleteNode ( root , 9 ) ; printf ( \" Pre order traversal after deletion of 9 \" preOrder ( root ) ; return 0 ; }"}
{"text": "A binary tree node has data , the pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; struct node * parent ; } ; struct node * minValue ( struct node * node ) ;"}
{"text": "Give a binary search tree and a number , inserts a new node with the given number in the correct place in the tree . Returns the new root pointer which the caller should then use ( the standard trick to avoid using reference parameters ) .", "code": "struct node * insert ( struct node * node , int data ) {"}
{"text": "1. If the tree is empty , return a new , single node", "code": "if ( node == NULL ) return ( newNode ( data ) ) ; else { struct node * temp ;"}
{"text": "2. Otherwise , recur down the tree", "code": "if ( data <= node -> data ) { temp = insert ( node -> left , data ) ; node -> left = temp ; temp -> parent = node ; } else { temp = insert ( node -> right , data ) ; node -> right = temp ; temp -> parent = node ; }"}
{"text": "return the ( unchanged ) node pointer", "code": "return node ; } } struct node * inOrderSuccessor ( struct node * root , struct node * n ) {"}
{"text": "step 1 of the above algorithm", "code": "if ( n -> right != NULL ) return minValue ( n -> right ) ;"}
{"text": "step 2 of the above algorithm", "code": "struct node * p = n -> parent ; while ( p != NULL && n == p -> right ) { n = p ; p = p -> parent ; } return p ; }"}
{"text": "Given a non - empty binary search tree , return the minimum data value found in that tree . Note that the entire tree does not need to be searched .", "code": "struct node * minValue ( struct node * node ) { struct node * current = node ;"}
{"text": "loop down to find the leftmost leaf", "code": "while ( current -> left != NULL ) { current = current -> left ; } return current ; }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> parent = NULL ; return ( node ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { struct node * root = NULL , * temp , * succ , * min ; root = insert ( root , 20 ) ; root = insert ( root , 8 ) ; root = insert ( root , 22 ) ; root = insert ( root , 4 ) ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 14 ) ; temp = root -> left -> right -> right ; succ = inOrderSuccessor ( root , temp ) ; if ( succ != NULL ) printf ( \" Inorder Successor of % d is % d \" , temp -> data , succ -> data ) ; else printf ( \" Inorder Successor doesn ' exit \" getchar ( ) ; return 0 ; }"}
{"text": "A C program to check if there is a triplet with sum equal to 0 in a given BST", "code": "#include <stdio.h>"}
{"text": "A BST node has key , and left and right pointers", "code": "struct node { int key ; struct node * left ; struct node * right ; } ;"}
{"text": "A function to convert given BST to Doubly Linked List . left pointer is used as previous pointer and right pointer is used as next pointer . The function sets * head to point to first and * tail to point to last node of converted DLL", "code": "void convertBSTtoDLL ( node * root , node * * head , node * * tail ) {"}
{"text": "Base case", "code": "if ( root == NULL ) return ;"}
{"text": "First convert the left subtree", "code": "if ( root -> left ) convertBSTtoDLL ( root -> left , head , tail ) ;"}
{"text": "Then change left of current root as last node of left subtree", "code": "root -> left = * tail ;"}
{"text": "If tail is not NULL , then set right of tail as root , else current node is head", "code": "if ( * tail ) ( * tail ) -> right = root ; else * head = root ;"}
{"text": "Update tail", "code": "* tail = root ;"}
{"text": "Finally , convert right subtree", "code": "if ( root -> right ) convertBSTtoDLL ( root -> right , head , tail ) ; }"}
{"text": "This function returns true if there is pair in DLL with sum equal to given sum . The algorithm is similar to hasArrayTwoCandidates ( ) tinyurl . com / dy6palr in method 1 of http :", "code": "bool isPresentInDLL ( node * head , node * tail , int sum ) { while ( head != tail ) { int curr = head -> key + tail -> key ; if ( curr == sum ) return true ; else if ( curr > sum ) tail = tail -> left ; else head = head -> right ; } return false ; }"}
{"text": "The main function that returns true if there is a 0 sum triplet in BST otherwise returns false", "code": "bool isTripletPresent ( node * root ) {"}
{"text": "Check if the given BST is empty", "code": "if ( root == NULL ) return false ;"}
{"text": "Convert given BST to doubly linked list . head and tail store the pointers to first and last nodes in DLLL", "code": "node * head = NULL ; node * tail = NULL ; convertBSTtoDLL ( root , & head , & tail ) ;"}
{"text": "Now iterate through every node and find if there is a pair with sum equal to - 1 * heaf -> key where head is current node", "code": "while ( ( head -> right != tail ) && ( head -> key < 0 ) ) {"}
{"text": "If there is a pair with sum equal to - 1 * head -> key , then return true else move forward", "code": "if ( isPresentInDLL ( head -> right , tail , -1 * head -> key ) ) return true ; else head = head -> right ; }"}
{"text": "If we reach here , then there was no 0 sum triplet", "code": "return false ; }"}
{"text": "A utility function to create a new BST node with key as given num", "code": "node * newNode ( int num ) { node * temp = new node ; temp -> key = num ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "A utility function to insert a given key to BST", "code": "node * insert ( node * root , int key ) { if ( root == NULL ) return newNode ( key ) ; if ( root -> key > key ) root -> left = insert ( root -> left , key ) ; else root -> right = insert ( root -> right , key ) ; return root ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { node * root = NULL ; root = insert ( root , 6 ) ; root = insert ( root , -13 ) ; root = insert ( root , 14 ) ; root = insert ( root , -8 ) ; root = insert ( root , 15 ) ; root = insert ( root , 13 ) ; root = insert ( root , 7 ) ; if ( isTripletPresent ( root ) ) printf ( \" Present \" ) ; else printf ( \" Not ▁ Present \" ) ; return 0 ; }"}
{"text": "In a balanced binary search tree isPairPresent two element which sums to a given value time O ( n ) space O ( logn )", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define MAX_SIZE  100"}
{"text": "A BST node", "code": "struct node { int val ; struct node * left , * right ; } ;"}
{"text": "Stack type", "code": "struct Stack { int size ; int top ; struct node * * array ; } ;"}
{"text": "A utility function to create a stack of given size", "code": "struct Stack * createStack ( int size ) { struct Stack * stack = ( struct Stack * ) malloc ( sizeof ( struct Stack ) ) ; stack -> size = size ; stack -> top = -1 ; stack -> array = ( struct node * * ) malloc ( stack -> size * sizeof ( struct node * ) ) ; return stack ; }"}
{"text": "BASIC OPERATIONS OF STACK", "code": "int isFull ( struct Stack * stack ) { return stack -> top - 1 == stack -> size ; } int isEmpty ( struct Stack * stack ) { return stack -> top == -1 ; } void push ( struct Stack * stack , struct node * node ) { if ( isFull ( stack ) ) return ; stack -> array [ ++ stack -> top ] = node ; } struct node * pop ( struct Stack * stack ) { if ( isEmpty ( stack ) ) return NULL ; return stack -> array [ stack -> top -- ] ; }"}
{"text": "Returns true if a pair with target sum exists in BST , otherwise false", "code": "bool isPairPresent ( struct node * root , int target ) {"}
{"text": "Create two stacks . s1 is used for normal inorder traversal and s2 is used for reverse inorder traversal", "code": "struct Stack * s1 = createStack ( MAX_SIZE ) ; struct Stack * s2 = createStack ( MAX_SIZE ) ;"}
{"text": "Note the sizes of stacks is MAX_SIZE , we can find the tree size and fix stack size as O ( Logn ) for balanced trees like AVL and Red Black tree . We have used MAX_SIZE to keep the code simple done1 , val1 and curr1 are used for normal inorder traversal using s1 done2 , val2 and curr2 are used for reverse inorder traversal using s2", "code": "bool done1 = false , done2 = false ; int val1 = 0 , val2 = 0 ; struct node * curr1 = root , * curr2 = root ;"}
{"text": "The loop will break when we either find a pair or one of the two traversals is complete", "code": "while ( 1 ) {"}
{"text": "Find next node in normal Inorder traversal . See following post www . geeksforgeeks . org / inorder - tree - traversal - without - recursion / https :", "code": "while ( done1 == false ) { if ( curr1 != NULL ) { push ( s1 , curr1 ) ; curr1 = curr1 -> left ; } else { if ( isEmpty ( s1 ) ) done1 = 1 ; else { curr1 = pop ( s1 ) ; val1 = curr1 -> val ; curr1 = curr1 -> right ; done1 = 1 ; } } }"}
{"text": "Find next node in REVERSE Inorder traversal . The only difference between above and below loop is , in below loop right subtree is traversed before left subtree", "code": "while ( done2 == false ) { if ( curr2 != NULL ) { push ( s2 , curr2 ) ; curr2 = curr2 -> right ; } else { if ( isEmpty ( s2 ) ) done2 = 1 ; else { curr2 = pop ( s2 ) ; val2 = curr2 -> val ; curr2 = curr2 -> left ; done2 = 1 ; } } }"}
{"text": "If we find a pair , then print the pair and return . The first condition makes sure that two same values are not added", "code": "if ( ( val1 != val2 ) && ( val1 + val2 ) == target ) { printf ( \" Pair Found : % d + % d = % d \" , val1 , val2 , target ) ; return true ; }"}
{"text": "If sum of current values is smaller , then move to next node in normal inorder traversal", "code": "else if ( ( val1 + val2 ) < target ) done1 = false ;"}
{"text": "If sum of current values is greater , then move to next node in reverse inorder traversal", "code": "else if ( ( val1 + val2 ) > target ) done2 = false ;"}
{"text": "If any of the inorder traversals is over , then there is no pair so return false", "code": "if ( val1 >= val2 ) return false ; } }"}
{"text": "A utility function to create BST node", "code": "struct node * NewNode ( int val ) { struct node * tmp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; tmp -> val = val ; tmp -> right = tmp -> left = NULL ; return tmp ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "15 / \\ 10 20 / \\ / \\ 8 12 16 25", "code": "struct node * root = NewNode ( 15 ) ; root -> left = NewNode ( 10 ) ; root -> right = NewNode ( 20 ) ; root -> left -> left = NewNode ( 8 ) ; root -> left -> right = NewNode ( 12 ) ; root -> right -> left = NewNode ( 16 ) ; root -> right -> right = NewNode ( 25 ) ; int target = 33 ; if ( isPairPresent ( root , target ) == false ) printf ( \" No such values are found \" getchar ( ) ; return 0 ; }"}
{"text": "C program to implement insert operation in Red Black Tree .", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE typedef struct node { struct node * left , * right ; int data ;"}
{"text": "red == > true , black == > false", "code": "bool color ; } node ; node * createNode ( int data , bool color ) { node * myNode = ( node * ) malloc ( sizeof ( node ) ) ; myNode -> left = myNode -> right = NULL ; myNode -> data = data ;"}
{"text": "New Node which is created is always red in color .", "code": "myNode -> color = true ; return myNode ; }"}
{"text": "utility function to rotate node anticlockwise .", "code": "node * rotateLeft ( node * myNode ) { printf ( \" left ▁ rotation ! ! STRNEWLINE \" ) ; node * child = myNode -> right ; node * childLeft = child -> left ; child -> left = myNode ; myNode -> right = childLeft ; return child ; }"}
{"text": "utility function to rotate node clockwise .", "code": "node * rotateRight ( node * myNode ) { printf ( \" right ▁ rotation STRNEWLINE \" ) ; node * child = myNode -> left ; node * childRight = child -> right ; child -> right = myNode ; myNode -> left = childRight ; return child ; }"}
{"text": "utility function to check whether node is red in color or not .", "code": "int isRed ( node * myNode ) { if ( myNode == NULL ) return 0 ; return ( myNode -> color == true ) ; }"}
{"text": "utility function to swap color of two nodes .", "code": "void swapColors ( node * node1 , node * node2 ) { bool temp = node1 -> color ; node1 -> color = node2 -> color ; node2 -> color = temp ; }"}
{"text": "insertion into Left Leaning Red Black Tree .", "code": "node * insert ( node * myNode , int data ) {"}
{"text": "Normal insertion code for any Binary Search tree .", "code": "if ( myNode == NULL ) return createNode ( data , false ) ; if ( data < myNode -> data ) myNode -> left = insert ( myNode -> left , data ) ; else if ( data > myNode -> data ) myNode -> right = insert ( myNode -> right , data ) ; else return myNode ;"}
{"text": "case 1. when right child is Red but left child is Black or doesn 't exist.", "code": "if ( isRed ( myNode -> right ) && ! isRed ( myNode -> left ) ) {"}
{"text": "left rotate the node to make it into valid structure .", "code": "myNode = rotateLeft ( myNode ) ;"}
{"text": "swap the colors as the child node should always be red", "code": "swapColors ( myNode , myNode -> left ) ; }"}
{"text": "case 2 when left child as well as left grand child in Red", "code": "if ( isRed ( myNode -> left ) && isRed ( myNode -> left -> left ) ) {"}
{"text": "right rotate the current node to make it into a valid structure .", "code": "myNode = rotateRight ( myNode ) ; swapColors ( myNode , myNode -> right ) ; }"}
{"text": "case 3 when both left and right child are Red in color .", "code": "if ( isRed ( myNode -> left ) && isRed ( myNode -> right ) ) {"}
{"text": "invert the color of node as well it 's left and right child.", "code": "myNode -> color = ! myNode -> color ;"}
{"text": "change the color to black .", "code": "myNode -> left -> color = false ; myNode -> right -> color = false ; } return myNode ; }"}
{"text": "Inorder traversal", "code": "void inorder ( node * node ) { if ( node ) { inorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; inorder ( node -> right ) ; } }"}
{"text": "Driver function", "code": "int main ( ) { node * root = NULL ;"}
{"text": "LLRB tree made after all insertions are made . 1. Nodes which have double INCOMING edge means that they are RED in color . 2. Nodes which have single INCOMING edge means that they are BLACK in color . root | 40 \\ 20 50 / \\ 10 30 25", "code": "root = insert ( root , 10 ) ;"}
{"text": "to make sure that root remains black is color", "code": "root -> color = false ; root = insert ( root , 20 ) ; root -> color = false ; root = insert ( root , 30 ) ; root -> color = false ; root = insert ( root , 40 ) ; root -> color = false ; root = insert ( root , 50 ) ; root -> color = false ; root = insert ( root , 25 ) ; root -> color = false ;"}
{"text": "display the tree through inorder traversal .", "code": "inorder ( root ) ; return 0 ; }"}
{"text": "Utility function to find leftmost node in a tree rooted with n", "code": "struct Node * leftMost ( struct Node * n ) { if ( n == NULL ) return NULL ; while ( n -> left != NULL ) n = n -> left ; return n ; }"}
{"text": "C code to do inorder traversal in a threaded binary tree", "code": "void inOrder ( struct Node * root ) { struct Node * cur = leftMost ( root ) ; while ( cur != NULL ) { printf ( \" % d ▁ \" , cur -> data ) ;"}
{"text": "If this node is a thread node , then go to inorder successor", "code": "if ( cur -> rightThread ) cur = cur -> right ;"}
{"text": "Else go to the leftmost child in right", "code": "else"}
{"text": "subtree", "code": "cur = leftmost ( cur -> right ) ; } }"}
{"text": "program for construction of full binary tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "A utility function to create a node", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "A recursive function to construct Full from pre [ ] and post [ ] . preIndex is used to keep track of index in pre [ ] . l is low index and h is high index for the current subarray in post [ ]", "code": "struct node * constructTreeUtil ( int pre [ ] , int post [ ] , int * preIndex , int l , int h , int size ) {"}
{"text": "Base case", "code": "if ( * preIndex >= size l > h ) return NULL ;"}
{"text": "The first node in preorder traversal is root . So take the node at preIndex from preorder and make it root , and increment preIndex", "code": "struct node * root = newNode ( pre [ * preIndex ] ) ; ++ * preIndex ;"}
{"text": "If the current subarry has only one element , no need to recur", "code": "if ( l == h ) return root ;"}
{"text": "Search the next element of pre [ ] in post [ ]", "code": "int i ; for ( i = l ; i <= h ; ++ i ) if ( pre [ * preIndex ] == post [ i ] ) break ;"}
{"text": "Use the index of element found in postorder to divide postorder array in two parts . Left subtree and right subtree", "code": "if ( i <= h ) { root -> left = constructTreeUtil ( pre , post , preIndex , l , i , size ) ; root -> right = constructTreeUtil ( pre , post , preIndex , i + 1 , h , size ) ; } return root ; }"}
{"text": "The main function to construct Full Binary Tree from given preorder and postorder traversals . This function mainly uses constructTreeUtil ( )", "code": "struct node * constructTree ( int pre [ ] , int post [ ] , int size ) { int preIndex = 0 ; return constructTreeUtil ( pre , post , & preIndex , 0 , size - 1 , size ) ; }"}
{"text": "A utility function to print inorder traversal of a Binary Tree", "code": "void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; printInorder ( node -> right ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int pre [ ] = { 1 , 2 , 4 , 8 , 9 , 5 , 3 , 6 , 7 } ; int post [ ] = { 8 , 9 , 4 , 5 , 2 , 6 , 7 , 3 , 1 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; struct node * root = constructTree ( pre , post , size ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ constructed ▁ tree : ▁ STRNEWLINE \" ) ; printInorder ( root ) ; return 0 ; }"}
{"text": "C Code for Sorted order printing of a given array that represents a BST", "code": "#include <stdio.h> NEW_LINE void printSorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ;"}
{"text": "print left subtree", "code": "printSorted ( arr , start * 2 + 1 , end ) ;"}
{"text": "print root", "code": "printf ( \" % d ▁ \" , arr [ start ] ) ;"}
{"text": "print right subtree", "code": "printSorted ( arr , start * 2 + 2 , end ) ; }"}
{"text": "driver program to test above function", "code": "int main ( ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 } ; int arr_size = sizeof ( arr ) / sizeof ( int ) ; printSorted ( arr , 0 , arr_size - 1 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program to find ceil of a given value in BST", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has key , left child and right child", "code": "struct node { int key ; struct node * left ; struct node * right ; } ;"}
{"text": "Helper function that allocates a new node with the given key and NULL left and right pointers .", "code": "struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Function to find ceil of a given input in BST . If input is more than the max key in BST , return - 1", "code": "int Ceil ( struct node * root , int input ) {"}
{"text": "Base case", "code": "if ( root == NULL ) return -1 ;"}
{"text": "We found equal key", "code": "if ( root -> key == input ) return root -> key ;"}
{"text": "If root 's key is smaller, ceil must be in right subtree", "code": "if ( root -> key < input ) return Ceil ( root -> right , input ) ;"}
{"text": "Else , either left subtree or root has the ceil value", "code": "int ceil = Ceil ( root -> left , input ) ; return ( ceil >= input ) ? ceil : root -> key ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { struct node * root = newNode ( 8 ) ; root -> left = newNode ( 4 ) ; root -> right = newNode ( 12 ) ; root -> left -> left = newNode ( 2 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> left = newNode ( 10 ) ; root -> right -> right = newNode ( 14 ) ; for ( int i = 0 ; i < 16 ; i ++ ) printf ( \" % d ▁ % d STRNEWLINE \" , i , Ceil ( root , i ) ) ; return 0 ; }"}
{"text": "C program to implement basic operations ( search , insert and delete ) on a BST that handles duplicates by storing count with every node", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; int count ; struct node * left , * right ; } ;"}
{"text": "A utility function to create a new BST node", "code": "struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> left = temp -> right = NULL ; temp -> count = 1 ; return temp ; }"}
{"text": "A utility function to do inorder traversal of BST", "code": "void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( \" % d ( % d ) ▁ \" , root -> key , root -> count ) ; inorder ( root -> right ) ; } }"}
{"text": "A utility function to insert a new node with given key in BST", "code": "struct node * insert ( struct node * node , int key ) {"}
{"text": "If the tree is empty , return a new node", "code": "if ( node == NULL ) return newNode ( key ) ;"}
{"text": "If key already exists in BST , icnrement count and return", "code": "if ( key == node -> key ) { ( node -> count ) ++ ; return node ; }"}
{"text": "Otherwise , recur down the tree", "code": "if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ;"}
{"text": "return the ( unchanged ) node pointer", "code": "return node ; }"}
{"text": "Given a non - empty binary search tree , return the node with minimum key value found in that tree . Note that the entire tree does not need to be searched .", "code": "struct node * minValueNode ( struct node * node ) { struct node * current = node ;"}
{"text": "loop down to find the leftmost leaf", "code": "while ( current -> left != NULL ) current = current -> left ; return current ; }"}
{"text": "Given a binary search tree and a key , this function deletes a given key and returns root of modified tree", "code": "struct node * deleteNode ( struct node * root , int key ) {"}
{"text": "base case", "code": "if ( root == NULL ) return root ;"}
{"text": "If the key to be deleted is smaller than the root 's key, then it lies in left subtree", "code": "if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ;"}
{"text": "If the key to be deleted is greater than the root 's key,  then it lies in right subtree", "code": "else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ;"}
{"text": "if key is same as root 's key", "code": "else {"}
{"text": "If key is present more than once , simply decrement count and return", "code": "if ( root -> count > 1 ) { ( root -> count ) -- ; return root ; }"}
{"text": "ElSE , delete the node node with only one child or no child", "code": "if ( root -> left == NULL ) { struct node * temp = root -> right ; free ( root ) ; return temp ; } else if ( root -> right == NULL ) { struct node * temp = root -> left ; free ( root ) ; return temp ; }"}
{"text": "node with two children : Get the inorder successor ( smallest in the right subtree )", "code": "struct node * temp = minValueNode ( root -> right ) ;"}
{"text": "Copy the inorder successor 's content to this node", "code": "root -> key = temp -> key ;"}
{"text": "Delete the inorder successor", "code": "root -> right = deleteNode ( root -> right , temp -> key ) ; } return root ; }"}
{"text": "Driver Program to test above functions", "code": "int main ( ) {"}
{"text": "Let us create following BST 12 ( 3 ) / \\ 10 ( 2 ) 20 ( 1 ) / \\ 9 ( 1 ) 11 ( 1 )", "code": "struct node * root = NULL ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 20 ) ; root = insert ( root , 9 ) ; root = insert ( root , 11 ) ; root = insert ( root , 10 ) ; root = insert ( root , 12 ) ; root = insert ( root , 12 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ given ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; printf ( \" Delete 20 \" root = deleteNode ( root , 20 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; printf ( \" Delete 12 \" root = deleteNode ( root , 12 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; printf ( \" Delete 9 \" root = deleteNode ( root , 9 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; return 0 ; }"}
{"text": "C program to demonstrate decrease key operation on binary search tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; struct node * left , * right ; } ;"}
{"text": "A utility function to create a new BST node", "code": "struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "A utility function to do inorder traversal of BST", "code": "void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( \" % d ▁ \" , root -> key ) ; inorder ( root -> right ) ; } }"}
{"text": "A utility function to insert a new node with given key in BST", "code": "struct node * insert ( struct node * node , int key ) {"}
{"text": "If the tree is empty , return a new node", "code": "if ( node == NULL ) return newNode ( key ) ;"}
{"text": "Otherwise , recur down the tree", "code": "if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ;"}
{"text": "return the ( unchanged ) node pointer", "code": "return node ; }"}
{"text": "Given a non - empty binary search tree , return the node with minimum key value found in that tree . Note that the entire tree does not need to be searched .", "code": "struct node * minValueNode ( struct node * node ) { struct node * current = node ;"}
{"text": "loop down to find the leftmost leaf", "code": "while ( current -> left != NULL ) current = current -> left ; return current ; }"}
{"text": "Given a binary search tree and a key , this function deletes the key and returns the new root", "code": "struct node * deleteNode ( struct node * root , int key ) {"}
{"text": "base case", "code": "if ( root == NULL ) return root ;"}
{"text": "If the key to be deleted is smaller than the root 's key,  then it lies in left subtree", "code": "if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ;"}
{"text": "If the key to be deleted is greater than the root 's key,  then it lies in right subtree", "code": "else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ;"}
{"text": "if key is same as root 's key, then This is the node  to be deleted", "code": "else {"}
{"text": "node with only one child or no child", "code": "if ( root -> left == NULL ) { struct node * temp = root -> right ; free ( root ) ; return temp ; } else if ( root -> right == NULL ) { struct node * temp = root -> left ; free ( root ) ; return temp ; }"}
{"text": "node with two children : Get the inorder successor ( smallest in the right subtree )", "code": "struct node * temp = minValueNode ( root -> right ) ;"}
{"text": "Copy the inorder successor 's content to this node", "code": "root -> key = temp -> key ;"}
{"text": "Delete the inorder successor", "code": "root -> right = deleteNode ( root -> right , temp -> key ) ; } return root ; }"}
{"text": "Function to decrease a key value in Binary Search Tree", "code": "struct node * changeKey ( struct node * root , int oldVal , int newVal ) {"}
{"text": "First delete old key value", "code": "root = deleteNode ( root , oldVal ) ;"}
{"text": "Then insert new key value", "code": "root = insert ( root , newVal ) ;"}
{"text": "Return new root", "code": "return root ; }"}
{"text": "Driver Program to test above functions", "code": "int main ( ) {"}
{"text": "Let us create following BST 50 / \\ 30 70 / \\ / \\ 20 40 60 80", "code": "struct node * root = NULL ; root = insert ( root , 50 ) ; root = insert ( root , 30 ) ; root = insert ( root , 20 ) ; root = insert ( root , 40 ) ; root = insert ( root , 70 ) ; root = insert ( root , 60 ) ; root = insert ( root , 80 ) ; printf ( \" Inorder ▁ traversal ▁ of ▁ the ▁ given ▁ tree ▁ STRNEWLINE \" ) ; inorder ( root ) ; root = changeKey ( root , 40 , 10 ) ;"}
{"text": "BST is modified to 50 / \\ 30 70 / / \\ 20 60 80 / 10", "code": "printf ( \" Inorder traversal of the modified tree \" inorder ( root ) ; return 0 ; }"}
{"text": "C program to count number of nodes in BST containing two digit special number", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A Tree node", "code": "struct Node { struct Node * left ; int info ; struct Node * right ; } ;"}
{"text": "Function to create a new node", "code": "void insert ( struct Node * * rt , int key ) {"}
{"text": "If the tree is empty , return a new , single node", "code": "if ( * rt == NULL ) { ( * rt ) = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; ( * rt ) -> left = NULL ; ( * rt ) -> right = NULL ; ( * rt ) -> info = key ; }"}
{"text": "Otherwise , recur down the tree", "code": "else if ( key < ( ( * rt ) -> info ) ) insert ( & ( ( * rt ) -> left ) , key ) ; else insert ( & ( * rt ) -> right , key ) ; }"}
{"text": "Function to find if number is special or not", "code": "int check ( int num ) { int sum = 0 , i = num , sum_of_digits , prod_of_digits ;"}
{"text": "Check if number is two digit or not", "code": "if ( num < 10 num > 99 ) return 0 ; else { sum_of_digits = ( i % 10 ) + ( i / 10 ) ; prod_of_digits = ( i % 10 ) * ( i / 10 ) ; sum = sum_of_digits + prod_of_digits ; } if ( sum == num ) return 1 ; else return 0 ; }"}
{"text": "Function to count number of special two digit number", "code": "void countSpecialDigit ( struct Node * rt , int * c ) { int x ; if ( rt == NULL ) return ; else { x = check ( rt -> info ) ; if ( x == 1 ) * c = * c + 1 ; countSpecialDigit ( rt -> left , c ) ; countSpecialDigit ( rt -> right , c ) ; } }"}
{"text": "Driver program to test", "code": "int main ( ) { struct Node * root = NULL ; int count = 0 ; insert ( & root , 50 ) ; insert ( & root , 29 ) ; insert ( & root , 59 ) ; insert ( & root , 19 ) ; insert ( & root , 53 ) ; insert ( & root , 556 ) ; insert ( & root , 56 ) ; insert ( & root , 94 ) ; insert ( & root , 13 ) ;"}
{"text": "Function call , to check each node for special two digit number", "code": "countSpecialDigit ( root , & count ) ; printf ( \" % d \" , count ) ; return 0 ; }"}
{"text": "program to construct tree from inorder traversal", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Prototypes of a utility function to get the maximum value in inorder [ start . . end ]", "code": "int max ( int inorder [ ] , int strt , int end ) ; struct node * newNode ( int data ) ;"}
{"text": "Recursive function to construct binary of size len from Inorder traversal inorder [ ] . Initial values of start and end should be 0 and len - 1.", "code": "struct node * buildTree ( int inorder [ ] , int start , int end ) { if ( start > end ) return NULL ;"}
{"text": "Find index of the maximum element from Binary Tree", "code": "int i = max ( inorder , start , end ) ;"}
{"text": "Pick the maximum value and make it root", "code": "struct node * root = newNode ( inorder [ i ] ) ;"}
{"text": "If this is the only element in inorder [ start . . end ] , then return it", "code": "if ( start == end ) return root ;"}
{"text": "Using index in Inorder traversal , construct left and right subtress", "code": "root -> left = buildTree ( inorder , start , i - 1 ) ; root -> right = buildTree ( inorder , i + 1 , end ) ; return root ; }"}
{"text": "Function to find index of the maximum value in arr [ start ... end ]", "code": "int max ( int arr [ ] , int strt , int end ) { int i , max = arr [ strt ] , maxind = strt ; for ( i = strt + 1 ; i <= end ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; maxind = i ; } } return maxind ; }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return node ; }"}
{"text": "This funtcion is here just to test buildTree ( )", "code": "void printInorder ( struct node * node ) { if ( node == NULL ) return ;"}
{"text": "first recur on left child", "code": "printInorder ( node -> left ) ;"}
{"text": "then print the data of node", "code": "printf ( \" % d ▁ \" , node -> data ) ;"}
{"text": "now recur on right child", "code": "printInorder ( node -> right ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Assume that inorder traversal of following tree is given 40 / \\ 10 30 / \\ 5 28", "code": "int inorder [ ] = { 5 , 10 , 40 , 30 , 28 } ; int len = sizeof ( inorder ) / sizeof ( inorder [ 0 ] ) ; struct node * root = buildTree ( inorder , 0 , len - 1 ) ;"}
{"text": "Let us test the built tree by printing Insorder traversal", "code": "printf ( \" Inorder traversal of the constructed tree is \" printInorder ( root ) ; return 0 ; }"}
{"text": "C program to print Identity Matrix", "code": "#include <stdio.h> NEW_LINE int Identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) {"}
{"text": "Checking if row is equal to column", "code": "if ( row == col ) printf ( \" % d ▁ \" , 1 ) ; else printf ( \" % d ▁ \" , 0 ) ; } printf ( \" STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "Driver Code", "code": "int main ( ) { int size = 5 ; identity ( size ) ; return 0 ; }"}
{"text": "C program to search an element in row - wise and column - wise sorted matrix", "code": "#include <stdio.h>"}
{"text": "Searches the element x in mat [ ] [ ] . If the element is found , then prints its position and returns true , otherwise prints \" not ▁ found \" and returns false", "code": "int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return -1 ; int smallest = mat [ 0 ] [ 0 ] , largest = mat [ n - 1 ] [ n - 1 ] ; if ( x < smallest x > largest ) return -1 ;"}
{"text": "set indexes for top right element", "code": "int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { printf ( \" Found at % d , % d \" , i , j ) ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ;"}
{"text": "if mat [ i ] [ j ] < x", "code": "else i ++ ; } printf ( \" n ▁ Element ▁ not ▁ found \" ) ;"}
{"text": "if ( i == n j == - 1 )", "code": "return 0 ; }"}
{"text": "driver program to test above function", "code": "int main ( ) { int mat [ 4 ] [ 4 ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } , } ; search ( mat , 4 , 29 ) ; return 0 ; }"}
{"text": "Function to print alternating rectangles of 0 and X", "code": "void fill0X ( int m , int n ) {"}
{"text": "k - starting row index m - ending row index l - starting column index n - ending column index i - iterator", "code": "int i , k = 0 , l = 0 ;"}
{"text": "Store given number of rows and columns for later use", "code": "int r = m , c = n ;"}
{"text": "A 2D array to store the output to be printed", "code": "char a [ m ] [ n ] ;"}
{"text": "Iniitialize the character to be stoed in a [ ] [ ]", "code": "char x = ' X ' ;"}
{"text": "Fill characters in a [ ] [ ] in spiral form . Every iteration fills one rectangle of either Xs or Os", "code": "while ( k < m && l < n ) {"}
{"text": "Fill the first row from the remaining rows", "code": "for ( i = l ; i < n ; ++ i ) a [ k ] [ i ] = x ; k ++ ;"}
{"text": "Fill the last column from the remaining columns", "code": "for ( i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = x ; n -- ;"}
{"text": "Fill the last row from the remaining rows", "code": "if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; }"}
{"text": "Print the first column from the remaining columns", "code": "if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = x ; l ++ ; }"}
{"text": "Flip character for next iteration", "code": "x = ( x == '0' ) ? ' X ' : '0' ; }"}
{"text": "Print the filled matrix", "code": "for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) printf ( \" % c ▁ \" , a [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { puts ( \" Output ▁ for ▁ m ▁ = ▁ 5 , ▁ n ▁ = ▁ 6\" ) ; fill0X ( 5 , 6 ) ; puts ( \" Output for m = 4 , n = 4 \" ) ; fill0X ( 4 , 4 ) ; puts ( \" Output for m = 3 , n = 4 \" ) ; fill0X ( 3 , 4 ) ; return 0 ; }"}
{"text": "C program to interchange the diagonals of matrix", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3"}
{"text": "Function to interchange diagonals", "code": "void interchangeDiagonals ( int array [ ] [ N ] ) {"}
{"text": "swap elements of diagonal", "code": "for ( int i = 0 ; i < N ; ++ i ) if ( i != N / 2 ) swap ( array [ i ] [ i ] , array [ i ] [ N - i - 1 ] ) ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) printf ( \" ▁ % d \" , array [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Driver Code", "code": "int main ( ) { int array [ N ] [ N ] = { 4 , 5 , 6 , 1 , 2 , 3 , 7 , 8 , 9 } ; interchangeDiagonals ( array ) ; return 0 ; }"}
{"text": "Program for linked implementation of complete binary tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "For Queue Size", "code": "#define SIZE  50"}
{"text": "A tree node", "code": "struct node { int data ; struct node * right , * left ; } ;"}
{"text": "A queue node", "code": "struct Queue { int front , rear ; int size ; struct node * * array ; } ;"}
{"text": "A utility function to create a new tree node", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "A utility function to create a new Queue", "code": "struct Queue * createQueue ( int size ) { struct Queue * queue = ( struct Queue * ) malloc ( sizeof ( struct Queue ) ) ; queue -> front = queue -> rear = -1 ; queue -> size = size ; queue -> array = ( struct node * * ) malloc ( queue -> size * sizeof ( struct node * ) ) ; int i ; for ( i = 0 ; i < size ; ++ i ) queue -> array [ i ] = NULL ; return queue ; }"}
{"text": "Standard Queue Functions", "code": "int isEmpty ( struct Queue * queue ) { return queue -> front == -1 ; } int isFull ( struct Queue * queue ) { return queue -> rear == queue -> size - 1 ; } int hasOnlyOneItem ( struct Queue * queue ) { return queue -> front == queue -> rear ; } void Enqueue ( struct node * root , struct Queue * queue ) { if ( isFull ( queue ) ) return ; queue -> array [ ++ queue -> rear ] = root ; if ( isEmpty ( queue ) ) ++ queue -> front ; } struct node * Dequeue ( struct Queue * queue ) { if ( isEmpty ( queue ) ) return NULL ; struct node * temp = queue -> array [ queue -> front ] ; if ( hasOnlyOneItem ( queue ) ) queue -> front = queue -> rear = -1 ; else ++ queue -> front ; return temp ; } struct node * getFront ( struct Queue * queue ) { return queue -> array [ queue -> front ] ; }"}
{"text": "A utility function to check if a tree node has both left and right children", "code": "int hasBothChild ( struct node * temp ) { return temp && temp -> left && temp -> right ; }"}
{"text": "Function to insert a new node in complete binary tree", "code": "void insert ( struct node * * root , int data , struct Queue * queue ) {"}
{"text": "Create a new node for given data", "code": "struct node * temp = newNode ( data ) ;"}
{"text": "If the tree is empty , initialize the root with new node .", "code": "if ( ! * root ) * root = temp ; else {"}
{"text": "get the front node of the queue .", "code": "struct node * front = getFront ( queue ) ;"}
{"text": "If the left child of this front node doesn t exist , set the left child as the new node", "code": "if ( ! front -> left ) front -> left = temp ;"}
{"text": "If the right child of this front node doesn t exist , set the right child as the new node", "code": "else if ( ! front -> right ) front -> right = temp ;"}
{"text": "If the front node has both the left child and right child , Dequeue ( ) it .", "code": "if ( hasBothChild ( front ) ) Dequeue ( queue ) ; }"}
{"text": "Enqueue ( ) the new node for later insertions", "code": "Enqueue ( temp , queue ) ; }"}
{"text": "Standard level order traversal to test above function", "code": "void levelOrder ( struct node * root ) { struct Queue * queue = createQueue ( SIZE ) ; Enqueue ( root , queue ) ; while ( ! isEmpty ( queue ) ) { struct node * temp = Dequeue ( queue ) ; printf ( \" % d ▁ \" , temp -> data ) ; if ( temp -> left ) Enqueue ( temp -> left , queue ) ; if ( temp -> right ) Enqueue ( temp -> right , queue ) ; } }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { struct node * root = NULL ; struct Queue * queue = createQueue ( SIZE ) ; int i ; for ( i = 1 ; i <= 12 ; ++ i ) insert ( & root , i , queue ) ; levelOrder ( root ) ; return 0 ; }"}
{"text": "A C program for in - place conversion of Binary Tree to DLL", "code": "#include <stdio.h>"}
{"text": "A binary tree node has data , and left and right pointers", "code": "struct node { int data ; node * left ; node * right ; } ;"}
{"text": "This is the core function to convert Tree to list . This function follows steps 1 and 2 of the above algorithm", "code": "node * bintree2listUtil ( node * root ) {"}
{"text": "Base case", "code": "if ( root == NULL ) return root ;"}
{"text": "Convert the left subtree and link to root", "code": "if ( root -> left != NULL ) {"}
{"text": "Convert the left subtree", "code": "node * left = bintree2listUtil ( root -> left ) ;"}
{"text": "Find inorder predecessor . After this loop , left will point to the inorder predecessor", "code": "for ( ; left -> right != NULL ; left = left -> right ) ;"}
{"text": "Make root as next of the predecessor", "code": "left -> right = root ;"}
{"text": "Make predecssor as previous of root", "code": "root -> left = left ; }"}
{"text": "Convert the right subtree and link to root", "code": "if ( root -> right != NULL ) {"}
{"text": "Convert the right subtree", "code": "node * right = bintree2listUtil ( root -> right ) ;"}
{"text": "Find inorder successor . After this loop , right will point to the inorder successor", "code": "for ( ; right -> left != NULL ; right = right -> left ) ;"}
{"text": "Make root as previous of successor", "code": "right -> left = root ;"}
{"text": "Make successor as next of root", "code": "root -> right = right ; } return root ; }"}
{"text": "The main function that first calls bintree2listUtil ( ) , then follows step 3 of the above algorithm", "code": "node * bintree2list ( node * root ) {"}
{"text": "Base case", "code": "if ( root == NULL ) return root ;"}
{"text": "Convert to DLL using bintree2listUtil ( )", "code": "root = bintree2listUtil ( root ) ;"}
{"text": "bintree2listUtil ( ) returns root node of the converted DLL . We need pointer to the leftmost node which is head of the constructed DLL , so move to the leftmost node", "code": "while ( root -> left != NULL ) root = root -> left ; return ( root ) ; }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "node * newNode ( int data ) { node * new_node = new node ; new_node -> data = data ; new_node -> left = new_node -> right = NULL ; return ( new_node ) ; }"}
{"text": "Function to print nodes in a given doubly linked list", "code": "void printList ( node * node ) { while ( node != NULL ) { printf ( \" % d ▁ \" , node -> data ) ; node = node -> right ; } }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Let us create the tree shown in above diagram", "code": "node * root = newNode ( 10 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 15 ) ; root -> left -> left = newNode ( 25 ) ; root -> left -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 36 ) ;"}
{"text": "Convert to DLL", "code": "node * head = bintree2list ( root ) ;"}
{"text": "Print the converted list", "code": "printList ( head ) ; return 0 ; }"}
{"text": "Given a binary matrix of M X N of integers , you need to return only unique rows of binary array", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE #define ROW  4 NEW_LINE #define COL  5"}
{"text": "A Trie node", "code": "typedef struct Node { bool isEndOfCol ;"}
{"text": "Only two children needed for 0 and 1", "code": "struct Node * child [ 2 ] ; } Node ;"}
{"text": "A utility function to allocate memory for a new Trie node", "code": "Node * newNode ( ) { Node * temp = ( Node * ) malloc ( sizeof ( Node ) ) ; temp -> isEndOfCol = 0 ; temp -> child [ 0 ] = temp -> child [ 1 ] = NULL ; return temp ; }"}
{"text": "Inserts a new matrix row to Trie . If row is already present , then returns 0 , otherwise insets the row and return 1", "code": "bool insert ( Node * * root , int ( * M ) [ COL ] , int row , int col ) {"}
{"text": "base case", "code": "if ( * root == NULL ) * root = newNode ( ) ;"}
{"text": "Recur if there are more entries in this row", "code": "if ( col < COL ) return insert ( & ( ( * root ) -> child [ M [ row ] [ col ] ] ) , M , row , col + 1 ) ;"}
{"text": "If all entries of this row are processed", "code": "else {"}
{"text": "unique row found , return 1", "code": "if ( ! ( ( * root ) -> isEndOfCol ) ) return ( * root ) -> isEndOfCol = 1 ;"}
{"text": "duplicate row found , return 0", "code": "return 0 ; } }"}
{"text": "A utility function to print a row", "code": "void printRow ( int ( * M ) [ COL ] , int row ) { int i ; for ( i = 0 ; i < COL ; ++ i ) printf ( \" % d ▁ \" , M [ row ] [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "The main function that prints all unique rows in a given matrix .", "code": "void findUniqueRows ( int ( * M ) [ COL ] ) {"}
{"text": "create an empty Trie", "code": "Node * root = NULL ; int i ;"}
{"text": "Iterate through all rows", "code": "for ( i = 0 ; i < ROW ; ++ i )"}
{"text": "insert row to TRIE", "code": "if ( insert ( & root , M , i , 0 ) )"}
{"text": "unique row found , print it", "code": "printRow ( M , i ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int M [ ROW ] [ COL ] = { { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 0 , 0 } } ; findUniqueRows ( M ) ; return 0 ; }"}
{"text": "A C program to find a common element in all rows of a row wise sorted array", "code": "#include <stdio.h>"}
{"text": "Specify number of rows and columns", "code": "#define M  4 NEW_LINE #define N  5"}
{"text": "Returns common element in all rows of mat [ M ] [ N ] . If there is no common element , then - 1 is returned", "code": "int findCommon ( int mat [ M ] [ N ] ) {"}
{"text": "An array to store indexes of current last column", "code": "int column [ M ] ;"}
{"text": "To store index of row whose current last element is minimum", "code": "int min_row ;"}
{"text": "Initialize current last element of all rows", "code": "int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ;"}
{"text": "Initialize min_row as first row", "code": "min_row = 0 ;"}
{"text": "Keep finding min_row in current last column , till either all elements of last column become same or we hit first column .", "code": "while ( column [ min_row ] >= 0 ) {"}
{"text": "Find minimum in current last column", "code": "for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ; }"}
{"text": "eq_count is count of elements equal to minimum in current last column .", "code": "int eq_count = 0 ;"}
{"text": "Traverse current last column elements again to update it", "code": "for ( i = 0 ; i < M ; i ++ ) {"}
{"text": "Decrease last column index of a row whose value is more than minimum .", "code": "if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return -1 ;"}
{"text": "Reduce last column index by 1", "code": "column [ i ] -= 1 ; } else eq_count ++ ; }"}
{"text": "If equal count becomes M , return the value", "code": "if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } return -1 ; }"}
{"text": "driver program to test above function", "code": "int main ( ) { int mat [ M ] [ N ] = { { 1 , 2 , 3 , 4 , 5 } , { 2 , 4 , 5 , 8 , 10 } , { 3 , 5 , 7 , 9 , 11 } , { 1 , 3 , 5 , 7 , 9 } , } ; int result = findCommon ( mat ) ; if ( result == -1 ) printf ( \" No ▁ common ▁ element \" ) ; else printf ( \" Common ▁ element ▁ is ▁ % d \" , result ) ; return 0 ; }"}
{"text": "A simple inorder traversal based program to convert a Binary Tree to DLL", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A tree node", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "A utility function to create a new tree node", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; }"}
{"text": "Standard Inorder traversal of tree", "code": "void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( \" TABSYMBOL % d \" , root -> data ) ; inorder ( root -> right ) ; } }"}
{"text": "Changes left pointers to work as previous pointers in converted DLL The function simply does inorder traversal of Binary Tree and updates left pointer using previously visited node", "code": "void fixPrevPtr ( struct node * root ) { static struct node * pre = NULL ; if ( root != NULL ) { fixPrevPtr ( root -> left ) ; root -> left = pre ; pre = root ; fixPrevPtr ( root -> right ) ; } }"}
{"text": "Changes right pointers to work as next pointers in converted DLL", "code": "struct node * fixNextPtr ( struct node * root ) { struct node * prev = NULL ;"}
{"text": "Find the right most node in BT or last node in DLL", "code": "while ( root && root -> right != NULL ) root = root -> right ;"}
{"text": "Start from the rightmost node , traverse back using left pointers . While traversing , change right pointer of nodes .", "code": "while ( root && root -> left != NULL ) { prev = root ; root = root -> left ; root -> right = prev ; }"}
{"text": "The leftmost node is head of linked list , return it", "code": "return ( root ) ; }"}
{"text": "The main function that converts BST to DLL and returns head of DLL", "code": "struct node * BTToDLL ( struct node * root ) {"}
{"text": "Set the previous pointer", "code": "fixPrevPtr ( root ) ;"}
{"text": "Set the next pointer and return head of DLL", "code": "return fixNextPtr ( root ) ; }"}
{"text": "Traverses the DLL from left tor right", "code": "void printList ( struct node * root ) { while ( root != NULL ) { printf ( \" TABSYMBOL % d \" , root -> data ) ; root = root -> right ; } }"}
{"text": "Driver program to test above functions", "code": "int main ( void ) {"}
{"text": "Let us create the tree shown in above diagram", "code": "struct node * root = newNode ( 10 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 15 ) ; root -> left -> left = newNode ( 25 ) ; root -> left -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 36 ) ; printf ( \" Inorder Tree Traversal \" inorder ( root ) ; struct node * head = BTToDLL ( root ) ; printf ( \" DLL Traversal \" printList ( head ) ; return 0 ; }"}
{"text": "Program to convert an aribitary binary tree to a tree that holds children sum property", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A binary tree node", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "This function is used to increment left subtree", "code": "void increment ( struct node * node , int diff ) ;"}
{"text": "This function changes a tree to hold children sum property", "code": "void convertTree ( struct node * node ) { int left_data = 0 , right_data = 0 , diff ;"}
{"text": "If tree is empty or it 's a leaf node then  return true", "code": "if ( node == NULL || ( node -> left == NULL && node -> right == NULL ) ) return ; else {"}
{"text": "convert left and right subtrees", "code": "convertTree ( node -> left ) ; convertTree ( node -> right ) ;"}
{"text": "If left child is not present then 0 is used as data of left child", "code": "if ( node -> left != NULL ) left_data = node -> left -> data ;"}
{"text": "If right child is not present then 0 is used as data of right child", "code": "if ( node -> right != NULL ) right_data = node -> right -> data ;"}
{"text": "get the diff of node 's data and children sum", "code": "diff = left_data + right_data - node -> data ;"}
{"text": "If node ' s ▁ children ▁ sum ▁ is ▁ greater ▁ than ▁ the ▁ node ' s data", "code": "if ( diff > 0 ) node -> data = node -> data + diff ;"}
{"text": "THIS IS TRICKY -- > If node 's data is greater than children sum,  then increment subtree by diff", "code": "if ( diff < 0 )"}
{"text": "- diff is used to make diff positive", "code": "increment ( node , - diff ) ; } }"}
{"text": "This function is used to increment subtree by diff", "code": "void increment ( struct node * node , int diff ) {"}
{"text": "IF left child is not NULL then increment it", "code": "if ( node -> left != NULL ) { node -> left -> data = node -> left -> data + diff ;"}
{"text": "Recursively call to fix the descendants of node -> left", "code": "increment ( node -> left , diff ) ; }"}
{"text": "Else increment right child", "code": "else if ( node -> right != NULL ) { node -> right -> data = node -> right -> data + diff ;"}
{"text": "Recursively call to fix the descendants of node -> right", "code": "increment ( node -> right , diff ) ; } }"}
{"text": "Given a binary tree , printInorder ( ) prints out its inorder traversal", "code": "void printInorder ( struct node * node ) { if ( node == NULL ) return ;"}
{"text": "first recur on left child", "code": "printInorder ( node -> left ) ;"}
{"text": "then print the data of node", "code": "printf ( \" % d ▁ \" , node -> data ) ;"}
{"text": "now recur on right child", "code": "printInorder ( node -> right ) ; }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { struct node * root = newNode ( 50 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 1 ) ; root -> right -> right = newNode ( 30 ) ; printf ( \" Inorder traversal before conversion \" printInorder ( root ) ; convertTree ( root ) ; printf ( \" Inorder traversal after conversion \" printInorder ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "A tree node structure", "code": "struct node { int data ; struct node * left ; struct node * right ; } ;"}
{"text": "Convert a given tree to a tree where every node contains sum of values of nodes in left and right subtrees in the original tree", "code": "int toSumTree ( struct node * node ) {"}
{"text": "Base case", "code": "if ( node == NULL ) return 0 ;"}
{"text": "Store the old value", "code": "int old_val = node -> data ;"}
{"text": "Recursively call for left and right subtrees and store the sum as new value of this node", "code": "node -> data = toSumTree ( node -> left ) + toSumTree ( node -> right ) ;"}
{"text": "Return the sum of values of nodes in left and right subtrees and old_value of this node", "code": "return node -> data + old_val ; }"}
{"text": "A utility function to print inorder traversal of a Binary Tree", "code": "void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d ▁ \" , node -> data ) ; printInorder ( node -> right ) ; }"}
{"text": "Utility function to create a new Binary Tree node", "code": "struct node * newNode ( int data ) { struct node * temp = new struct node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; }"}
{"text": "Driver function to test above functions", "code": "int main ( ) { struct node * root = NULL ; int x ;"}
{"text": "Constructing tree given in the above figure", "code": "root = newNode ( 10 ) ; root -> left = newNode ( -2 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( -4 ) ; root -> right -> left = newNode ( 7 ) ; root -> right -> right = newNode ( 5 ) ; toSumTree ( root ) ;"}
{"text": "Print inorder traversal of the converted tree to test result of toSumTree ( )", "code": "printf ( \" Inorder ▁ Traversal ▁ of ▁ the ▁ resultant ▁ tree ▁ is : ▁ STRNEWLINE \" ) ; printInorder ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find a peak element using divide and conquer", "code": "#include <stdio.h>"}
{"text": "A binary search based function that returns index of a peak element", "code": "int findPeakUtil ( int arr [ ] , int low , int high , int n ) {"}
{"text": "Find index of middle element ( low + high ) / 2", "code": "int mid = low + ( high - low ) / 2 ;"}
{"text": "Compare middle element with its neighbours ( if neighbours exist )", "code": "if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ;"}
{"text": "If middle element is not peak and its left neighbour is greater than it , then left half must have a peak element", "code": "else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ;"}
{"text": "If middle element is not peak and its right neighbour is greater than it , then right half must have a peak element", "code": "else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; }"}
{"text": "A wrapper over recursive function findPeakUtil ( )", "code": "int findPeak ( int arr [ ] , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; }"}
{"text": "Driver program to check above functions", "code": "int main ( ) { int arr [ ] = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Index ▁ of ▁ a ▁ peak ▁ point ▁ is ▁ % d \" , findPeak ( arr , n ) ) ; return 0 ; }"}
{"text": "Print Repeating function", "code": "void printRepeating ( int arr [ ] , int size ) { int i , j ; printf ( \" ▁ Repeating ▁ elements ▁ are ▁ \" ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) printf ( \" ▁ % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Function", "code": "void printRepeating ( int arr [ ] , int size ) { int * count = ( int * ) calloc ( sizeof ( int ) , ( size - 2 ) ) ; int i ; printf ( \" ▁ Repeating ▁ elements ▁ are ▁ \" ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) printf ( \" ▁ % d ▁ \" , arr [ i ] ) ; else count [ arr [ i ] ] ++ ; } }"}
{"text": "Driver code", "code": "int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "printRepeating function", "code": "int fact ( int n ) ; void printRepeating ( int arr [ ] , int size ) {"}
{"text": "S is for sum of elements in arr [ ]", "code": "int S = 0 ;"}
{"text": "P is for product of elements in arr [ ]", "code": "int P = 1 ;"}
{"text": "x and y are two repeating elements", "code": "int x , y ;"}
{"text": "D is for difference of x and y , i . e . , x - y", "code": "int D ; int n = size - 2 , i ;"}
{"text": "Calculate Sum and Product of all elements in arr [ ]", "code": "for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; }"}
{"text": "S is x + y now", "code": "S = S - n * ( n + 1 ) / 2 ;"}
{"text": "P is x * y now", "code": "P = P / fact ( n ) ;"}
{"text": "D is x - y now", "code": "D = sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; printf ( \" The ▁ two ▁ Repeating ▁ elements ▁ are ▁ % d ▁ & ▁ % d \" , x , y ) ; }"}
{"text": "factorial of n", "code": "int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; }"}
{"text": "driver code", "code": "int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "C code to Find the two repeating elements in a given array", "code": "void printRepeating ( int arr [ ] , int size ) {"}
{"text": "Will hold xor of all elements", "code": "int xor = arr [ 0 ] ;"}
{"text": "Will have only single set bit of xor", "code": "int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ;"}
{"text": "Get the xor of all elements in arr [ ] and { 1 , 2 . . n }", "code": "for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ;"}
{"text": "Get the rightmost set bit in set_bit_no", "code": "set_bit_no = xor & ~ ( xor - 1 ) ;"}
{"text": "Now divide elements in two sets by comparing rightmost set bit of xor with bit at same position in each element .", "code": "for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ;"}
{"text": "XOR of first set in arr [ ]", "code": "else y = y ^ arr [ i ] ;"}
{"text": "XOR of second set in arr [ ]", "code": "} for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ;"}
{"text": "XOR of first set in arr [ ] and { 1 , 2 , ... n }", "code": "else y = y ^ i ;"}
{"text": "XOR of second set in arr [ ] and { 1 , 2 , ... n }", "code": "} printf ( \" n ▁ The ▁ two ▁ repeating ▁ elements ▁ are ▁ % d ▁ & ▁ % d ▁ \" , x , y ) ; }"}
{"text": "driver code", "code": "int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Function to print repeating", "code": "void printRepeating ( int arr [ ] , int size ) { int i ; printf ( \" The repeating elements are \" for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; else printf ( \" ▁ % d ▁ \" , abs ( arr [ i ] ) ) ; } }"}
{"text": "Driver code", "code": "int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "A simple program to print subarray with sum as given sum", "code": "#include <stdio.h>"}
{"text": "Returns true if the there is a subarray of arr [ ] with a sum equal to ' sum ' otherwise returns false . Also , prints the result", "code": "int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ;"}
{"text": "Pick a starting point", "code": "for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ;"}
{"text": "try all subarrays starting with ' i '", "code": "for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { printf ( \" Sum ▁ found ▁ between ▁ indexes ▁ % d ▁ and ▁ % d \" , i , j - 1 ) ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } printf ( \" No ▁ subarray ▁ found \" ) ; return 0 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; subArraySum ( arr , n , sum ) ; return 0 ; }"}
{"text": "An efficient program to print subarray with sum as given sum", "code": "#include <stdio.h>"}
{"text": "Returns true if the there is a subarray of arr [ ] with a sum equal to ' sum ' otherwise returns false . Also , prints the result", "code": "int subArraySum ( int arr [ ] , int n , int sum ) {"}
{"text": "Initialize curr_sum as value of first element and starting point as 0", "code": "int curr_sum = arr [ 0 ] , start = 0 , i ;"}
{"text": "Add elements one by one to curr_sum and if the curr_sum exceeds the sum , then remove starting element", "code": "for ( i = 1 ; i <= n ; i ++ ) {"}
{"text": "If curr_sum exceeds the sum , then remove the starting elements", "code": "while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; }"}
{"text": "If curr_sum becomes equal to sum , then return true", "code": "if ( curr_sum == sum ) { printf ( \" Sum ▁ found ▁ between ▁ indexes ▁ % d ▁ and ▁ % d \" , start , i - 1 ) ; return 1 ; }"}
{"text": "Add this element to curr_sum", "code": "if ( i < n ) curr_sum = curr_sum + arr [ i ] ; }"}
{"text": "If we reach here , then no subarray", "code": "printf ( \" No ▁ subarray ▁ found \" ) ; return 0 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; subArraySum ( arr , n , sum ) ; return 0 ; }"}
{"text": "returns true if there is triplet with sum equal to ' sum ' present in A [ ] . Also , prints the triplet", "code": "bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ;"}
{"text": "Fix the first element as A [ i ]", "code": "for ( int i = 0 ; i < arr_size - 2 ; i ++ ) {"}
{"text": "Fix the second element as A [ j ]", "code": "for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) {"}
{"text": "Now look for the third number", "code": "for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { printf ( \" Triplet ▁ is ▁ % d , ▁ % d , ▁ % d \" , A [ i ] , A [ j ] , A [ k ] ) ; return true ; } } } }"}
{"text": "If we reach here , then no triplet was found", "code": "return false ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; find3Numbers ( A , arr_size , sum ) ; return 0 ; }"}
{"text": "C implementation of the approach", "code": "#include <stdio.h>"}
{"text": "Linearly search x in arr [ ] . If x is present then return the index , otherwise return - 1", "code": "int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return -1 ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int arr [ ] = { 1 , 10 , 30 , 15 } ; int x = 30 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d ▁ is ▁ present ▁ at ▁ index ▁ % d \" , x , search ( arr , n , x ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to implement recursive Binary Search", "code": "#include <stdio.h>"}
{"text": "A recursive binary search function . It returns location of x in given array arr [ l . . r ] is present , otherwise - 1", "code": "int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ;"}
{"text": "If the element is present at the middle itself", "code": "if ( arr [ mid ] == x ) return mid ;"}
{"text": "If element is smaller than mid , then it can only be present in left subarray", "code": "if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ;"}
{"text": "Else the element can only be present in right subarray", "code": "return binarySearch ( arr , mid + 1 , r , x ) ; }"}
{"text": "We reach here when element is not present in array", "code": "return -1 ; }"}
{"text": "Driver method to test above", "code": "int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( \" Element ▁ is ▁ not ▁ present ▁ in ▁ array \" ) : printf ( \" Element ▁ is ▁ present ▁ at ▁ index ▁ % d \" , result ) ; return 0 ; }"}
{"text": "C program to implement iterative Binary Search", "code": "#include <stdio.h>"}
{"text": "A iterative binary search function . It returns location of x in given array arr [ l . . r ] if present , otherwise - 1", "code": "int binarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = l + ( r - l ) / 2 ;"}
{"text": "Check if x is present at mid", "code": "if ( arr [ m ] == x ) return m ;"}
{"text": "If x greater , ignore left half", "code": "if ( arr [ m ] < x ) l = m + 1 ;"}
{"text": "If x is smaller , ignore right half", "code": "else r = m - 1 ; }"}
{"text": "if we reach here , then element was not present", "code": "return -1 ; }"}
{"text": "Driver method to test above", "code": "int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( \" Element ▁ is ▁ not ▁ present \" \" ▁ in ▁ array \" ) : printf ( \" Element ▁ is ▁ present ▁ at ▁ \" \" index ▁ % d \" , result ) ; return 0 ; }"}
{"text": "C program to implement interpolation search with recursion", "code": "#include <stdio.h>"}
{"text": "If x is present in arr [ 0. . n - 1 ] , then returns index of it , else returns - 1.", "code": "int interpolationSearch ( int arr [ ] , int lo , int hi , int x ) { int pos ;"}
{"text": "Since array is sorted , an element present in array must be in range defined by corner", "code": "if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) {"}
{"text": "Probing the position with keeping uniform distribution in mind .", "code": "pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ;"}
{"text": "Condition of target found", "code": "if ( arr [ pos ] == x ) return pos ;"}
{"text": "If x is larger , x is in right sub array", "code": "if ( arr [ pos ] < x ) return interpolationSearch ( arr , pos + 1 , hi , x ) ;"}
{"text": "If x is smaller , x is in left sub array", "code": "if ( arr [ pos ] > x ) return interpolationSearch ( arr , lo , pos - 1 , x ) ; } return -1 ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Array of items on which search will be conducted .", "code": "int arr [ ] = { 10 , 12 , 13 , 16 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 33 , 35 , 42 , 47 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Element to be searched", "code": "int x = 18 ; int index = interpolationSearch ( arr , 0 , n - 1 , x ) ;"}
{"text": "If element was found", "code": "if ( index != -1 ) printf ( \" Element ▁ found ▁ at ▁ index ▁ % d \" , index ) ; else printf ( \" Element ▁ not ▁ found . \" ) ; return 0 ; }"}
{"text": "C program for Merge Sort", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Merges two subarrays of arr [ ] . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ]", "code": "void merge ( int arr [ ] , int l , int m , int r ) { int i , j , k ;"}
{"text": "Find sizes of two subarrays to be merged", "code": "int n1 = m - l + 1 ; int n2 = r - m ;"}
{"text": "create temp arrays", "code": "int L [ n1 ] , R [ n2 ] ;"}
{"text": "Copy data to temp arrays L [ ] and R [ ]", "code": "for ( i = 0 ; i < n1 ; i ++ ) L [ i ] = arr [ l + i ] ; for ( j = 0 ; j < n2 ; j ++ ) R [ j ] = arr [ m + 1 + j ] ;"}
{"text": "Merge the temp arrays Initial indexes of first and second subarrays", "code": "i = 0 ; j = 0 ;"}
{"text": "Initial index of merged subarray", "code": "k = l ; while ( i < n1 && j < n2 ) { if ( L [ i ] <= R [ j ] ) { arr [ k ] = L [ i ] ; i ++ ; } else { arr [ k ] = R [ j ] ; j ++ ; } k ++ ; }"}
{"text": "Copy the remaining elements of L [ ] , if there are any", "code": "while ( i < n1 ) { arr [ k ] = L [ i ] ; i ++ ; k ++ ; }"}
{"text": "Copy the remaining elements of R [ ] , if there are any", "code": "while ( j < n2 ) { arr [ k ] = R [ j ] ; j ++ ; k ++ ; } }"}
{"text": "l is for left index and r is right index of the sub - array of arr to be sorted", "code": "void mergeSort ( int arr [ ] , int l , int r ) { if ( l < r ) {"}
{"text": "Same as ( l + r ) / 2 , but avoids overflow for large l and h", "code": "int m = l + ( r - l ) / 2 ;"}
{"text": "Sort first and second halves", "code": "mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ;"}
{"text": "Merge the sorted halves", "code": "merge ( arr , l , m , r ) ; } }"}
{"text": "Function to print an array", "code": "void printArray ( int A [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , A [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Driver code", "code": "int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given ▁ array ▁ is ▁ STRNEWLINE \" ) ; printArray ( arr , arr_size ) ; mergeSort ( arr , 0 , arr_size - 1 ) ; printf ( \" Sorted array is \" printArray ( arr , arr_size ) ; return 0 ; }"}
{"text": "An iterative implementation of quick sort", "code": "#include <stdio.h>"}
{"text": "A utility function to swap two elements", "code": "void swap ( int * a , int * b ) { int t = * a ; * a = * b ; * b = t ; }"}
{"text": "This function is same in both iterative and recursive", "code": "int partition ( int arr [ ] , int l , int h ) { int x = arr [ h ] ; int i = ( l - 1 ) ; for ( int j = l ; j <= h - 1 ; j ++ ) { if ( arr [ j ] <= x ) { i ++ ; swap ( & arr [ i ] , & arr [ j ] ) ; } } swap ( & arr [ i + 1 ] , & arr [ h ] ) ; return ( i + 1 ) ; }"}
{"text": "A [ ] -- > Array to be sorted , l -- > Starting index , h -- > Ending index", "code": "void quickSortIterative ( int arr [ ] , int l , int h ) {"}
{"text": "Create an auxiliary stack", "code": "int stack [ h - l + 1 ] ;"}
{"text": "initialize top of stack", "code": "int top = -1 ;"}
{"text": "push initial values of l and h to stack", "code": "stack [ ++ top ] = l ; stack [ ++ top ] = h ;"}
{"text": "Keep popping from stack while is not empty", "code": "while ( top >= 0 ) {"}
{"text": "Pop h and l", "code": "h = stack [ top -- ] ; l = stack [ top -- ] ;"}
{"text": "Set pivot element at its correct position in sorted array", "code": "int p = partition ( arr , l , h ) ;"}
{"text": "If there are elements on left side of pivot , then push left side to stack", "code": "if ( p - 1 > l ) { stack [ ++ top ] = l ; stack [ ++ top ] = p - 1 ; }"}
{"text": "If there are elements on right side of pivot , then push right side to stack", "code": "if ( p + 1 < h ) { stack [ ++ top ] = p + 1 ; stack [ ++ top ] = h ; } } }"}
{"text": "A utility function to print contents of arr", "code": "void printArr ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int arr [ ] = { 4 , 3 , 5 , 2 , 1 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( * arr ) ;"}
{"text": "Function calling", "code": "quickSortIterative ( arr , 0 , n - 1 ) ; printArr ( arr , n ) ; return 0 ; }"}
{"text": "C program for activity selection problem . The following implementation assumes that the activities are already sorted according to their finish time", "code": "#include <stdio.h>"}
{"text": "Prints a maximum set of activities that can be done by a single person , one at a time . n -- > Total number of activities s [ ] -- > An array that contains start time of all activities f [ ] -- > An array that contains finish time of all activities", "code": "void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; printf ( \" Following ▁ activities ▁ are ▁ selected ▁ n \" ) ;"}
{"text": "The first activity always gets selected", "code": "i = 0 ; printf ( \" % d ▁ \" , i ) ;"}
{"text": "Consider rest of the activities", "code": "for ( j = 1 ; j < n ; j ++ ) {"}
{"text": "If this activity has start time greater than or equal to the finish time of previously selected activity , then select it", "code": "if ( s [ j ] >= f [ i ] ) { printf ( \" % d ▁ \" , j ) ; i = j ; } } }"}
{"text": "driver program to test above function", "code": "int main ( ) { int s [ ] = { 1 , 3 , 0 , 5 , 8 , 5 } ; int f [ ] = { 2 , 4 , 6 , 7 , 9 , 9 } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; printMaxActivities ( s , f , n ) ; return 0 ; }"}
{"text": "C Program for Efficient Huffman Coding for Sorted input", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "This constant can be avoided by explicitly calculating height of Huffman Tree", "code": "#define MAX_TREE_HT  100"}
{"text": "A node of huffman tree", "code": "struct QueueNode { char data ; unsigned freq ; struct QueueNode * left , * right ; } ;"}
{"text": "Structure for Queue : collection of Huffman Tree nodes ( orQueueNodes )", "code": "struct Queue { int front , rear ; int capacity ; struct QueueNode * * array ; } ;"}
{"text": "A utility function to create a new Queuenode", "code": "struct QueueNode * newNode ( char data , unsigned freq ) { struct QueueNode * temp = ( struct QueueNode * ) malloc ( sizeof ( struct QueueNode ) ) ; temp -> left = temp -> right = NULL ; temp -> data = data ; temp -> freq = freq ; return temp ; }"}
{"text": "A utility function to create a Queue of given capacity", "code": "struct Queue * createQueue ( int capacity ) { struct Queue * queue = ( struct Queue * ) malloc ( sizeof ( struct Queue ) ) ; queue -> front = queue -> rear = -1 ; queue -> capacity = capacity ; queue -> array = ( struct QueueNode * * ) malloc ( queue -> capacity * sizeof ( struct QueueNode * ) ) ; return queue ; }"}
{"text": "A utility function to check if size of given queue is 1", "code": "int isSizeOne ( struct Queue * queue ) { return queue -> front == queue -> rear && queue -> front != -1 ; }"}
{"text": "A utility function to check if given queue is empty", "code": "int isEmpty ( struct Queue * queue ) { return queue -> front == -1 ; }"}
{"text": "A utility function to check if given queue is full", "code": "int isFull ( struct Queue * queue ) { return queue -> rear == queue -> capacity - 1 ; }"}
{"text": "A utility function to add an item to queue", "code": "void enQueue ( struct Queue * queue , struct QueueNode * item ) { if ( isFull ( queue ) ) return ; queue -> array [ ++ queue -> rear ] = item ; if ( queue -> front == -1 ) ++ queue -> front ; }"}
{"text": "A utility function to remove an item from queue", "code": "struct QueueNode * deQueue ( struct Queue * queue ) { if ( isEmpty ( queue ) ) return NULL ; struct QueueNode * temp = queue -> array [ queue -> front ] ; if ( queue -> front == queue"}
{"text": "If there is only one item in queue", "code": "- > rear ) queue -> front = queue -> rear = -1 ; else ++ queue -> front ; return temp ; }"}
{"text": "A utility function to get from of queue", "code": "struct QueueNode * getFront ( struct Queue * queue ) { if ( isEmpty ( queue ) ) return NULL ; return queue -> array [ queue -> front ] ; }"}
{"text": "A function to get minimum item from two queues", "code": "struct QueueNode * findMin ( struct Queue * firstQueue , struct Queue * secondQueue ) {"}
{"text": "Step 3. a : If first queue is empty , dequeue from second queue", "code": "if ( isEmpty ( firstQueue ) ) return deQueue ( secondQueue ) ;"}
{"text": "Step 3. b : If second queue is empty , dequeue from first queue", "code": "if ( isEmpty ( secondQueue ) ) return deQueue ( firstQueue ) ;"}
{"text": "Step 3. c : Else , compare the front of two queues and dequeue minimum", "code": "if ( getFront ( firstQueue ) -> freq < getFront ( secondQueue ) -> freq ) return deQueue ( firstQueue ) ; return deQueue ( secondQueue ) ; }"}
{"text": "Utility function to check if this node is leaf", "code": "int isLeaf ( struct QueueNode * root ) { return ! ( root -> left ) && ! ( root -> right ) ; }"}
{"text": "A utility function to print an array of size n", "code": "void printArr ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) printf ( \" % d \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "The main function that builds Huffman tree", "code": "struct QueueNode * buildHuffmanTree ( char data [ ] , int freq [ ] , int size ) { struct QueueNode * left , * right , * top ;"}
{"text": "Step 1 : Create two empty queues", "code": "struct Queue * firstQueue = createQueue ( size ) ; struct Queue * secondQueue = createQueue ( size ) ;"}
{"text": "Step 2 : Create a leaf node for each unique character and Enqueue it to the first queue in non - decreasing order of frequency . Initially second queue is empty", "code": "for ( int i = 0 ; i < size ; ++ i ) enQueue ( firstQueue , newNode ( data [ i ] , freq [ i ] ) ) ;"}
{"text": "Run while Queues contain more than one node . Finally , first queue will be empty and second queue will contain only one node", "code": "while ( ! ( isEmpty ( firstQueue ) && isSizeOne ( secondQueue ) ) ) {"}
{"text": "Step 3 : Dequeue two nodes with the minimum frequency by examining the front of both queues", "code": "left = findMin ( firstQueue , secondQueue ) ; right = findMin ( firstQueue , secondQueue ) ;"}
{"text": "Step 4 : Create a new internal node with frequency equal to the sum of the two nodes frequencies . Enqueue this node to second queue .", "code": "top = newNode ( ' $ ' , left -> freq + right -> freq ) ; top -> left = left ; top -> right = right ; enQueue ( secondQueue , top ) ; } return deQueue ( secondQueue ) ; }"}
{"text": "Prints huffman codes from the root of Huffman Tree . It uses arr [ ] to store codes", "code": "void printCodes ( struct QueueNode * root , int arr [ ] , int top ) {"}
{"text": "Assign 0 to left edge and recur", "code": "if ( root -> left ) { arr [ top ] = 0 ; printCodes ( root -> left , arr , top + 1 ) ; }"}
{"text": "Assign 1 to right edge and recur", "code": "if ( root -> right ) { arr [ top ] = 1 ; printCodes ( root -> right , arr , top + 1 ) ; }"}
{"text": "If this is a leaf node , then it contains one of the input characters , print the character and its code from arr [ ]", "code": "if ( isLeaf ( root ) ) { printf ( \" % c : ▁ \" , root -> data ) ; printArr ( arr , top ) ; } }"}
{"text": "The main function that builds a Huffman Tree and print codes by traversing the built Huffman Tree", "code": "void HuffmanCodes ( char data [ ] , int freq [ ] , int size ) {"}
{"text": "Construct Huffman Tree", "code": "struct QueueNode * root = buildHuffmanTree ( data , freq , size ) ;"}
{"text": "Print Huffman codes using the Huffman tree built above", "code": "int arr [ MAX_TREE_HT ] , top = 0 ; printCodes ( root , arr , top ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { char arr [ ] = { ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' } ; int freq [ ] = { 5 , 9 , 12 , 13 , 16 , 45 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; HuffmanCodes ( arr , freq , size ) ; return 0 ; }"}
{"text": "A Naive recursive implementation of LCS problem", "code": "#include <bits/stdc++.h> NEW_LINE int max ( int a , int b ) ;"}
{"text": "Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ]", "code": "int lcs ( char * X , char * Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }"}
{"text": "Utility function to get max of 2 integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char X [ ] = \" AGGTAB \" ; char Y [ ] = \" GXTXAYB \" ; int m = strlen ( X ) ; int n = strlen ( Y ) ; printf ( \" Length ▁ of ▁ LCS ▁ is ▁ % d \" , lcs ( X , Y , m , n ) ) ; return 0 ; }"}
{"text": "Dynamic Programming C implementation of LCS problem", "code": "#include <bits/stdc++.h> NEW_LINE int max ( int a , int b ) ;"}
{"text": "Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ]", "code": "int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; int i , j ;"}
{"text": "Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains length of LCS of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ]", "code": "for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } }"}
{"text": "L [ m ] [ n ] contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ]", "code": "return L [ m ] [ n ] ; }"}
{"text": "Utility function to get max of 2 integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char X [ ] = \" AGGTAB \" ; char Y [ ] = \" GXTXAYB \" ; int m = strlen ( X ) ; int n = strlen ( Y ) ; printf ( \" Length ▁ of ▁ LCS ▁ is ▁ % d \" , lcs ( X , Y , m , n ) ) ; return 0 ; }"}
{"text": "A Naive recursive implementation of MCP ( Minimum Cost Path ) problem", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE int min ( int x , int y , int z ) ;"}
{"text": "A utility function that returns minimum of 3 integers", "code": "int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; }"}
{"text": "Returns cost of minimum cost path from ( 0 , 0 ) to ( m , n ) in mat [ R ] [ C ]", "code": "int minCost ( int cost [ R ] [ C ] , int m , int n ) { if ( n < 0 m < 0 ) return INT_MAX ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; printf ( \" ▁ % d ▁ \" , minCost ( cost , 2 , 2 ) ) ; return 0 ; }"}
{"text": "Dynamic Programming implementation of MCP problem", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE int min ( int x , int y , int z ) ; int minCost ( int cost [ R ] [ C ] , int m , int n ) { int i , j ;"}
{"text": "Instead of following line , we can use int tc [ m + 1 ] [ n + 1 ] or dynamically allocate memory to save space . The following line is used to keep the program simple and make it working on all compilers .", "code": "int tc [ R ] [ C ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;"}
{"text": "Initialize first column of total cost ( tc ) array", "code": "for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ;"}
{"text": "Initialize first row of tc array", "code": "for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ;"}
{"text": "Construct rest of the tc array", "code": "for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; }"}
{"text": "A utility function that returns minimum of 3 integers", "code": "int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; printf ( \" ▁ % d ▁ \" , minCost ( cost , 2 , 2 ) ) ; return 0 ; }"}
{"text": "A Naive recursive implementation of 0 - 1 Knapsack problem", "code": "#include <stdio.h>"}
{"text": "A utility function that returns maximum of two integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Returns the maximum value that can be put in a knapsack of capacity W", "code": "int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {"}
{"text": "Base Case", "code": "if ( n == 0 W == 0 ) return 0 ;"}
{"text": "If weight of the nth item is more than Knapsack capacity W , then this item cannot be included in the optimal solution", "code": "if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ;"}
{"text": "Return the maximum of two cases : ( 1 ) nth item included ( 2 ) not included", "code": "else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printf ( \" % d \" , knapSack ( W , wt , val , n ) ) ; return 0 ; }"}
{"text": "A Dynamic Programming based solution for 0 - 1 Knapsack problem", "code": "#include <stdio.h>"}
{"text": "A utility function that returns maximum of two integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Returns the maximum value that can be put in a knapsack of capacity W", "code": "int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ;"}
{"text": "Build table K [ ] [ ] in bottom up manner", "code": "for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }"}
{"text": "Driver Code", "code": "int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printf ( \" % d \" , knapSack ( W , wt , val , n ) ) ; return 0 ; }"}
{"text": "A utility function to get maximum of two integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Function to get minimum number of trials needed in worst case with n eggs and k floors", "code": "int eggDrop ( int n , int k ) {"}
{"text": "If there are no floors , then no trials needed . OR if there is one floor , one trial needed .", "code": "if ( k == 1 k == 0 ) return k ;"}
{"text": "We need k trials for one egg and k floors", "code": "if ( n == 1 ) return k ; int min = INT_MAX , x , res ;"}
{"text": "Consider all droppings from 1 st floor to kth floor and return the minimum of these values plus 1.", "code": "for ( x = 1 ; x <= k ; x ++ ) { res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }"}
{"text": "Driver program to test to pront printDups", "code": "int main ( ) { int n = 2 , k = 10 ; printf ( \" nMinimum ▁ number ▁ of ▁ trials ▁ in ▁ \" \" worst ▁ case ▁ with ▁ % d ▁ eggs ▁ and ▁ \" \" % d ▁ floors ▁ is ▁ % d ▁ STRNEWLINE \" , n , k , eggDrop ( n , k ) ) ; return 0 ; }"}
{"text": "C program of above approach", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "A utility function to get max of two integers", "code": "int max ( int x , int y ) { return ( x > y ) ? x : y ; }"}
{"text": "Returns the length of the longest palindromic subsequence in seq", "code": "int lps ( char * seq , int i , int j ) {"}
{"text": "Base Case 1 : If there is only 1 character", "code": "if ( i == j ) return 1 ;"}
{"text": "Base Case 2 : If there are only 2 characters and both are same", "code": "if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ;"}
{"text": "If the first and last characters match", "code": "if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ;"}
{"text": "If the first and last characters do not match", "code": "return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { char seq [ ] = \" GEEKSFORGEEKS \" ; int n = strlen ( seq ) ; printf ( \" The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d \" , lps ( seq , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "A Dynamic programming solution for Word Wrap Problem", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #define INF  INT_MAX"}
{"text": "A utility function to print the solution", "code": "int printSolution ( int p [ ] , int n ) ; int printSolution ( int p [ ] , int n ) { int k ; if ( p [ n ] == 1 ) k = 1 ; else k = printSolution ( p , p [ n ] - 1 ) + 1 ; printf ( \" Line ▁ number ▁ % d : ▁ From ▁ word ▁ no . ▁ % d ▁ to ▁ % d ▁ STRNEWLINE \" , k , p [ n ] , n ) ; return k ; }"}
{"text": "l [ ] represents lengths of different words in input sequence . For example , l [ ] = { 3 , 2 , 2 , 5 } is for a sentence like \" aaa ▁ bb ▁ cc ▁ ddddd \" . n is size of l [ ] and M is line width ( maximum no . of characters that can fit in a line )", "code": "void solveWordWrap ( int l [ ] , int n , int M ) {"}
{"text": "For simplicity , 1 extra space is used in all below arrays extras [ i ] [ j ] will have number of extra spaces if words from i to j are put in a single line", "code": "int extras [ n + 1 ] [ n + 1 ] ;"}
{"text": "lc [ i ] [ j ] will have cost of a line which has words from i to j", "code": "int lc [ n + 1 ] [ n + 1 ] ;"}
{"text": "c [ i ] will have total cost of optimal arrangement of words from 1 to i", "code": "int c [ n + 1 ] ;"}
{"text": "p [ ] is used to print the solution .", "code": "int p [ n + 1 ] ; int i , j ;"}
{"text": "calculate extra spaces in a single line . The value extra [ i ] [ j ] indicates extra spaces if words from word number i to j are placed in a single line", "code": "for ( i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; }"}
{"text": "Calculate line cost corresponding to the above calculated extra spaces . The value lc [ i ] [ j ] indicates cost of putting words from word number i to j in a single line", "code": "for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = INF ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } }"}
{"text": "Calculate minimum cost and find minimum cost arrangement . The value c [ j ] indicates optimized cost to arrange words from word number 1 to j .", "code": "c [ 0 ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { c [ j ] = INF ; for ( i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != INF && lc [ i ] [ j ] != INF && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int l [ ] = { 3 , 2 , 2 , 5 } ; int n = sizeof ( l ) / sizeof ( l [ 0 ] ) ; int M = 6 ; solveWordWrap ( l , n , M ) ; return 0 ; }"}
{"text": "A naive recursive implementation of optimal binary search tree problem", "code": "#include <stdio.h> NEW_LINE #include <limits.h>"}
{"text": "A utility function to get sum of array elements freq [ i ] to freq [ j ]", "code": "int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; }"}
{"text": "A recursive function to calculate cost of optimal binary search tree", "code": "int optCost ( int freq [ ] , int i , int j ) {"}
{"text": "Base cases no elements in this subarray", "code": "if ( j < i ) return 0 ;"}
{"text": "one element in this subarray", "code": "if ( j == i ) return freq [ i ] ;"}
{"text": "Get sum of freq [ i ] , freq [ i + 1 ] , ... freq [ j ]", "code": "int fsum = sum ( freq , i , j ) ;"}
{"text": "Initialize minimum value", "code": "int min = INT_MAX ;"}
{"text": "One by one consider all elements as root and recursively find cost of the BST , compare the cost with min and update min if needed", "code": "for ( int r = i ; r <= j ; ++ r ) { int cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; }"}
{"text": "Return minimum value", "code": "return min + fsum ; }"}
{"text": "The main function that calculates minimum cost of a Binary Search Tree . It mainly uses optCost ( ) to find the optimal cost .", "code": "int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) {"}
{"text": "Here array keys [ ] is assumed to be sorted in increasing order . If keys [ ] is not sorted , then add code to sort keys , and rearrange freq [ ] accordingly .", "code": "return optCost ( freq , 0 , n - 1 ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; printf ( \" Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ % d ▁ \" , optimalSearchTree ( keys , freq , n ) ) ; return 0 ; }"}
{"text": "Dynamic Programming code for Optimal Binary Search Tree Problem", "code": "#include <stdio.h> NEW_LINE #include <limits.h>"}
{"text": "A utility function to get sum of array elements freq [ i ] to freq [ j ]", "code": "int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; }"}
{"text": "A Dynamic Programming based function that calculates minimum cost of a Binary Search Tree .", "code": "int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) {"}
{"text": "Create an auxiliary 2D matrix to store results of subproblems", "code": "int cost [ n ] [ n ] ;"}
{"text": "For a single key , cost is equal to frequency of the key", "code": "for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = freq [ i ] ;"}
{"text": "Now we need to consider chains of length 2 , 3 , ... . L is chain length .", "code": "for ( int L = 2 ; L <= n ; L ++ ) {"}
{"text": "i is row number in cost [ ] [ ]", "code": "for ( int i = 0 ; i <= n - L + 1 ; i ++ ) {"}
{"text": "Get column number j from row number i and chain length L", "code": "int j = i + L - 1 ; cost [ i ] [ j ] = INT_MAX ;"}
{"text": "Try making all keys in interval keys [ i . . j ] as root", "code": "for ( int r = i ; r <= j ; r ++ ) {"}
{"text": "c = cost when keys [ r ] becomes root of this subtree", "code": "int c = ( ( r > i ) ? cost [ i ] [ r - 1 ] : 0 ) + ( ( r < j ) ? cost [ r + 1 ] [ j ] : 0 ) + sum ( freq , i , j ) ; if ( c < cost [ i ] [ j ] ) cost [ i ] [ j ] = c ; } } } return cost [ 0 ] [ n - 1 ] ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; printf ( \" Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ % d ▁ \" , optimalSearchTree ( keys , freq , n ) ) ; return 0 ; }"}
{"text": "A naive recursive implementation of Largest Independent Set problem", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A utility function to find max of two integers", "code": "int max ( int x , int y ) { return ( x > y ) ? x : y ; }"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left , * right ; } ;"}
{"text": "The function returns size of the largest independent set in a given binary tree", "code": "int LISS ( struct node * root ) { if ( root == NULL ) return 0 ;"}
{"text": "Caculate size excluding the current node", "code": "int size_excl = LISS ( root -> left ) + LISS ( root -> right ) ;"}
{"text": "Calculate size including the current node", "code": "int size_incl = 1 ; if ( root -> left ) size_incl += LISS ( root -> left -> left ) + LISS ( root -> left -> right ) ; if ( root -> right ) size_incl += LISS ( root -> right -> left ) + LISS ( root -> right -> right ) ;"}
{"text": "Return the maximum of two sizes", "code": "return max ( size_incl , size_excl ) ; }"}
{"text": "A utility function to create a node", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Let us construct the tree given in the above diagram", "code": "struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printf ( \" Size ▁ of ▁ the ▁ Largest ▁ Independent ▁ Set ▁ is ▁ % d ▁ \" , LISS ( root ) ) ; return 0 ; }"}
{"text": "A Space Optimized C program to count number of possible numbers of given length", "code": "#include <stdio.h>"}
{"text": "Return count of all possible numbers of length n in a given numeric keyboard", "code": "int getCount ( char keypad [ ] [ 3 ] , int n ) { if ( keypad == NULL n <= 0 ) return 0 ; if ( n == 1 ) return 10 ;"}
{"text": "odd [ i ] , even [ i ] arrays represent count of numbers starting with digit i for any length j", "code": "int odd [ 10 ] , even [ 10 ] ; int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ )"}
{"text": "for j = 1", "code": "odd [ i ] = 1 ;"}
{"text": "Bottom Up calculation from j = 2 to n", "code": "for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ;"}
{"text": "Here we are explicitly writing lines for each number 0 to 9. But it can always be written as DFS on 4 X3 grid using row , column array valid moves", "code": "if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } }"}
{"text": "Get count of all possible numbers of length \" n \" starting with digit 0 , 1 , 2 , ... , 9", "code": "totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char keypad [ 4 ] [ 3 ] = { { '1' , '2' , '3' } , { '4' , '5' , '6' } , { '7' , '8' , '9' } , { ' * ' , '0' , ' # ' } } ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 1 , getCount ( keypad , 1 ) ) ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 2 , getCount ( keypad , 2 ) ) ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 3 , getCount ( keypad , 3 ) ) ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 4 , getCount ( keypad , 4 ) ) ; printf ( \" Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn \" , 5 , getCount ( keypad , 5 ) ) ; return 0 ; }"}
{"text": "Dynamic programming based program for Vertex Cover problem for a Binary Tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A utility function to find min of two integers", "code": "int min ( int x , int y ) { return ( x < y ) ? x : y ; }"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; int vc ; struct node * left , * right ; } ;"}
{"text": "A memoization based function that returns size of the minimum vertex cover .", "code": "int vCover ( struct node * root ) {"}
{"text": "The size of minimum vertex cover is zero if tree is empty or there is only one node", "code": "if ( root == NULL ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return 0 ;"}
{"text": "If vertex cover for this node is already evaluated , then return it to save recomputation of same subproblem again .", "code": "if ( root -> vc != 0 ) return root -> vc ;"}
{"text": "Calculate size of vertex cover when root is part of it", "code": "int size_incl = 1 + vCover ( root -> left ) + vCover ( root -> right ) ;"}
{"text": "Calculate size of vertex cover when root is not part of it", "code": "int size_excl = 0 ; if ( root -> left ) size_excl += 1 + vCover ( root -> left -> left ) + vCover ( root -> left -> right ) ; if ( root -> right ) size_excl += 1 + vCover ( root -> right -> left ) + vCover ( root -> right -> right ) ;"}
{"text": "Minimum of two values is vertex cover , store it before returning", "code": "root -> vc = min ( size_incl , size_excl ) ; return root -> vc ; }"}
{"text": "A utility function to create a node", "code": "struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ;"}
{"text": "Set the vertex cover as 0", "code": "temp -> vc = 0 ; return temp ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Let us construct the tree given in the above diagram", "code": "struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printf ( \" Size ▁ of ▁ the ▁ smallest ▁ vertex ▁ cover ▁ is ▁ % d ▁ \" , vCover ( root ) ) ; return 0 ; }"}
{"text": "A C program to count number of possible ways to a given score can be reached in a game where a move can earn 3 or 5 or 10", "code": "#include <stdio.h>"}
{"text": "Returns number of ways to reach score n", "code": "int count ( int n ) {"}
{"text": "table [ i ] will store count of solutions for value i .", "code": "int table [ n + 1 ] , i ;"}
{"text": "Initialize all table values as 0", "code": "memset ( table , 0 , sizeof ( table ) ) ;"}
{"text": "Base case ( If given value is 0 )", "code": "table [ 0 ] = 1 ;"}
{"text": "One by one consider given 3 moves and update the table [ ] values after the index greater than or equal to the value of the picked move", "code": "for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }"}
{"text": "Driver program", "code": "int main ( void ) { int n = 20 ; printf ( \" Count ▁ for ▁ % d ▁ is ▁ % d STRNEWLINE \" , n , count ( n ) ) ; n = 13 ; printf ( \" Count ▁ for ▁ % d ▁ is ▁ % d \" , n , count ( n ) ) ; return 0 ; }"}
{"text": "C program for Naive Pattern Searching algorithm", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ;"}
{"text": "A loop to slide pat [ ] one by one", "code": "for ( int i = 0 ; i <= N - M ; i ++ ) { int j ;"}
{"text": "For current index i , check for pattern match", "code": "for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ;"}
{"text": "if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ]", "code": "if ( j == M ) printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char txt [ ] = \" AABAACAADAABAAABAA \" ; char pat [ ] = \" AABA \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Following program is a C implementation of Rabin Karp Algorithm given in the CLRS book", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "d is the number of characters in the input alphabet", "code": "#define d  256"}
{"text": "pat -> pattern txt -> text q -> A prime number", "code": "void search ( char pat [ ] , char txt [ ] , int q ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i , j ;"}
{"text": "hash value for pattern", "code": "int p = 0 ;"}
{"text": "hash value for txt", "code": "int t = 0 ; int h = 1 ;"}
{"text": "The value of h would be \" pow ( d , ▁ M - 1 ) % q \"", "code": "for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ;"}
{"text": "Calculate the hash value of pattern and first window of text", "code": "for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; }"}
{"text": "Slide the pattern over text one by one", "code": "for ( i = 0 ; i <= N - M ; i ++ ) {"}
{"text": "Check the hash values of current window of text and pattern . If the hash values match then only check for characters on by one", "code": "if ( p == t ) {"}
{"text": "Check for characters one by one", "code": "for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; }"}
{"text": "if p == t and pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ]", "code": "if ( j == M ) printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; }"}
{"text": "Calculate hash value for next window of text : Remove leading digit , add trailing digit", "code": "if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ;"}
{"text": "We might get negative value of t , converting it to positive", "code": "if ( t < 0 ) t = ( t + q ) ; } } }"}
{"text": "Driver Code", "code": "int main ( ) { char txt [ ] = \" GEEKS ▁ FOR ▁ GEEKS \" ; char pat [ ] = \" GEEK \" ;"}
{"text": "A prime number", "code": "int q = 101 ;"}
{"text": "function call", "code": "search ( pat , txt , q ) ; return 0 ; }"}
{"text": "C program for A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "A modified Naive Pettern Searching algorithn that is optimized for the cases when all characters of pattern are different", "code": "void search ( char pat [ ] , char txt [ ] ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i = 0 ; while ( i <= N - M ) { int j ;"}
{"text": "For current index i , check for pattern match", "code": "for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ;"}
{"text": "if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ]", "code": "if ( j == M ) { printf ( \" Pattern ▁ found ▁ at ▁ index ▁ % d ▁ STRNEWLINE \" , i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else"}
{"text": "slide the pattern by j", "code": "i = i + j ; } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char txt [ ] = \" ABCEABCDABCEABCD \" ; char pat [ ] = \" ABCD \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "C program for Finite Automata Pattern searching Algorithm", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE int getNextState ( char * pat , int M , int state , int x ) {"}
{"text": "If the character c is same as next character in pattern , then simply increment state", "code": "if ( state < M && x == pat [ state ] ) return state + 1 ;"}
{"text": "ns stores the result which is next state", "code": "int ns , i ;"}
{"text": "ns finally contains the longest prefix which is also suffix in \" pat [ 0 . . state - 1 ] c \" Start from the largest possible value and stop when you find a prefix which is also suffix", "code": "for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] == x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) if ( pat [ i ] != pat [ state - ns + 1 + i ] ) break ; if ( i == ns - 1 ) return ns ; } } return 0 ; }"}
{"text": "This function builds the TF table which represents4 Finite Automata for a given pattern", "code": "void computeTF ( char * pat , int M , int TF [ ] [ NO_OF_CHARS ] ) { int state , x ; for ( state = 0 ; state <= M ; ++ state ) for ( x = 0 ; x < NO_OF_CHARS ; ++ x ) TF [ state ] [ x ] = getNextState ( pat , M , state , x ) ; }"}
{"text": "Prints all occurrences of pat in txt", "code": "void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int TF [ M + 1 ] [ NO_OF_CHARS ] ; computeTF ( pat , M , TF ) ;"}
{"text": "Process txt over FA .", "code": "int i , state = 0 ; for ( i = 0 ; i < N ; i ++ ) { state = TF [ state ] [ txt [ i ] ] ; if ( state == M ) printf ( \" Pattern found at index % d \" , i - M + 1 ) ; } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char * txt = \" AABAACAADAABAAABAA \" ; char * pat = \" AABA \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "C Program for Bad Character Heuristic of Boyer Moore String Matching Algorithm", "code": "# include <limits.h> NEW_LINE # include <string.h> NEW_LINE # include <stdio.h> NEW_LINE # define NO_OF_CHARS  256"}
{"text": "A utility function to get maximum of two integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "The preprocessing function for Boyer Moore 's bad character heuristic", "code": "void badCharHeuristic ( char * str , int size , int badchar [ NO_OF_CHARS ] ) { int i ;"}
{"text": "Initialize all occurrences as - 1", "code": "for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) badchar [ i ] = -1 ;"}
{"text": "Fill the actual value of last occurrence of a character", "code": "for ( i = 0 ; i < size ; i ++ ) badchar [ ( int ) str [ i ] ] = i ; }"}
{"text": "A pattern searching function that uses Bad Character Heuristic of Boyer Moore Algorithm", "code": "void search ( char * txt , char * pat ) { int m = strlen ( pat ) ; int n = strlen ( txt ) ; int badchar [ NO_OF_CHARS ] ;"}
{"text": "Fill the bad character array by calling the preprocessing function badCharHeuristic ( ) for given pattern", "code": "badCharHeuristic ( pat , m , badchar ) ;"}
{"text": "s is shift of the pattern with respect to text", "code": "int s = 0 ;"}
{"text": "there are n - m + 1 potential allignments", "code": "while ( s <= ( n - m ) ) { int j = m - 1 ;"}
{"text": "Keep reducing index j of pattern while characters of pattern and text are matching at this shift s", "code": "while ( j >= 0 && pat [ j ] == txt [ s + j ] ) j -- ;"}
{"text": "If the pattern is present at current shift , then index j will become - 1 after the above loop", "code": "if ( j < 0 ) { printf ( \" pattern occurs at shift = % d \""}
{"text": "Shift the pattern so that the next character in text aligns with the last occurrence of it in pattern . The condition s + m < n is necessary for the case when pattern occurs at the end of text", "code": "s += ( s + m < n ) ? m - badchar [ txt [ s + m ] ] : 1 ; } else"}
{"text": "Shift the pattern so that the bad character in text aligns with the last occurrence of it in pattern . The max function is used to make sure that we get a positive shift . We may get a negative shift if the last occurrence of bad character in pattern is on the right side of the current character .", "code": "s += max ( 1 , j - badchar [ txt [ s + j ] ] ) ; } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char txt [ ] = \" ABAAABCD \" ; char pat [ ] = \" ABC \" ; search ( txt , pat ) ; return 0 ; }"}
{"text": "prints subset found", "code": "void printSubset ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { printf ( \" % * d \" , 5 , A [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "inputs s - set vector t - tuplet vector s_size - set size t_size - tuplet size so far sum - sum so far ite - nodes count target_sum - sum to be found", "code": "void subset_sum ( int s [ ] , int t [ ] , int s_size , int t_size , int sum , int ite , int const target_sum ) { total_nodes ++ ; if ( target_sum == sum ) {"}
{"text": "We found subset", "code": "printSubset ( t , t_size ) ;"}
{"text": "Exclude previously added item and consider next candidate", "code": "subset_sum ( s , t , s_size , t_size - 1 , sum - s [ ite ] , ite + 1 , target_sum ) ; return ; } else {"}
{"text": "generate nodes along the breadth", "code": "for ( int i = ite ; i < s_size ; i ++ ) { t [ t_size ] = s [ i ] ;"}
{"text": "consider next level node ( along depth )", "code": "subset_sum ( s , t , s_size , t_size + 1 , sum + s [ i ] , i + 1 , target_sum ) ; } } }"}
{"text": "Wrapper to print subsets that sum to target_sum input is weights vector and target_sum", "code": "void generateSubsets ( int s [ ] , int size , int target_sum ) { int * tuplet_vector = ( int * ) malloc ( size * sizeof ( int ) ) ; subset_sum ( s , tuplet_vector , size , 0 , 0 , 0 , target_sum ) ; free ( tuplet_vector ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int weights [ ] = { 10 , 7 , 5 , 18 , 12 , 20 , 15 } ; int size = ARRAYSIZE ( weights ) ; generateSubsets ( weights , size , 35 ) ; printf ( \" Nodes ▁ generated ▁ % d ▁ STRNEWLINE \" , total_nodes ) ; return 0 ; }"}
{"text": "prints subset found", "code": "void printSubset ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { printf ( \" % * d \" , 5 , A [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "qsort compare function", "code": "int comparator ( const void * pLhs , const void * pRhs ) { int * lhs = ( int * ) pLhs ; int * rhs = ( int * ) pRhs ; return * lhs > * rhs ; }"}
{"text": "inputs s - set vector t - tuplet vector s_size - set size t_size - tuplet size so far sum - sum so far ite - nodes count target_sum - sum to be found", "code": "void subset_sum ( int s [ ] , int t [ ] , int s_size , int t_size , int sum , int ite , int const target_sum ) { total_nodes ++ ; if ( target_sum == sum ) {"}
{"text": "We found sum", "code": "printSubset ( t , t_size ) ;"}
{"text": "constraint check", "code": "if ( ite + 1 < s_size && sum - s [ ite ] + s [ ite + 1 ] <= target_sum ) {"}
{"text": "Exclude previous added item and consider next candidate", "code": "subset_sum ( s , t , s_size , t_size - 1 , sum - s [ ite ] , ite + 1 , target_sum ) ; } return ; } else {"}
{"text": "constraint check", "code": "if ( ite < s_size && sum + s [ ite ] <= target_sum ) {"}
{"text": "generate nodes along the breadth", "code": "for ( int i = ite ; i < s_size ; i ++ ) { t [ t_size ] = s [ i ] ; if ( sum + s [ i ] <= target_sum ) {"}
{"text": "consider next level node ( along depth )", "code": "subset_sum ( s , t , s_size , t_size + 1 , sum + s [ i ] , i + 1 , target_sum ) ; } } } } }"}
{"text": "Wrapper that prints subsets that sum to target_sum", "code": "void generateSubsets ( int s [ ] , int size , int target_sum ) { int * tuplet_vector = ( int * ) malloc ( size * sizeof ( int ) ) ; int total = 0 ;"}
{"text": "sort the set", "code": "qsort ( s , size , sizeof ( int ) , & comparator ) ; for ( int i = 0 ; i < size ; i ++ ) { total += s [ i ] ; } if ( s [ 0 ] <= target_sum && total >= target_sum ) { subset_sum ( s , tuplet_vector , size , 0 , 0 , 0 , target_sum ) ; } free ( tuplet_vector ) ; }"}
{"text": "Driver code", "code": "int main ( ) { int weights [ ] = { 15 , 22 , 14 , 26 , 32 , 9 , 16 , 8 } ; int target = 53 ; int size = ARRAYSIZE ( weights ) ; generateSubsets ( weights , size , target ) ; printf ( \" Nodes ▁ generated ▁ % d STRNEWLINE \" , total_nodes ) ; return 0 ; }"}
{"text": "N is the size of the 2D matrix N * N", "code": "#define N  9"}
{"text": "A utility function to print grid", "code": "void print ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( \" % d ▁ \" , arr [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Checks whether it will be legal to assign num to the given row , col", "code": "int isSafe ( int grid [ N ] [ N ] , int row , int col , int num ) {"}
{"text": "Check if we find the same num in the similar row , we return 0", "code": "for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ row ] [ x ] == num ) return 0 ;"}
{"text": "Check if we find the same num in the similar column , we return 0", "code": "for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ x ] [ col ] == num ) return 0 ;"}
{"text": "Check if we find the same num in the particular 3 * 3 matrix , we return 0", "code": "int startRow = row - row % 3 , startCol = col - col % 3 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow ] [ j + startCol ] == num ) return 0 ; return 1 ; }"}
{"text": "Takes a partially filled - in grid and attempts to assign values to all unassigned locations in such a way to meet the requirements for Sudoku solution ( non - duplication across rows , columns , and boxes )", "code": "int solveSuduko ( int grid [ N ] [ N ] , int row , int col ) {"}
{"text": "Check if we have reached the 8 th row and 9 th column ( 0 indexed matrix ) , we are returning true to avoid further backtracking", "code": "if ( row == N - 1 && col == N ) return 1 ;"}
{"text": "Check if column value becomes 9 , we move to next row and column start from 0", "code": "if ( col == N ) { row ++ ; col = 0 ; }"}
{"text": "Check if the current position of the grid already contains value > 0 , we iterate for next column", "code": "if ( grid [ row ] [ col ] > 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( int num = 1 ; num <= N ; num ++ ) {"}
{"text": "Check if it is safe to place the num ( 1 - 9 ) in the given row , col -> we move to next column", "code": "if ( isSafe ( grid , row , col , num ) == 1 ) {"}
{"text": "assigning the num in the current ( row , col ) position of the grid and assuming our assined num in the position is correct", "code": "grid [ row ] [ col ] = num ;"}
{"text": "Checking for next possibility with next column", "code": "if ( solveSuduko ( grid , row , col + 1 ) == 1 ) return 1 ; }"}
{"text": "Removing the assigned num , since our assumption was wrong , and we go for next assumption with diff num value", "code": "grid [ row ] [ col ] = 0 ; } return 0 ; }"}
{"text": "Driver code", "code": "int main ( ) { int grid [ N ] [ N ] = { { 3 , 0 , 6 , 5 , 0 , 8 , 4 , 0 , 0 } , { 5 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 8 , 7 , 0 , 0 , 0 , 0 , 3 , 1 } , { 0 , 0 , 3 , 0 , 1 , 0 , 0 , 8 , 0 } , { 9 , 0 , 0 , 8 , 6 , 3 , 0 , 0 , 5 } , { 0 , 5 , 0 , 0 , 9 , 0 , 6 , 0 , 0 } , { 1 , 3 , 0 , 0 , 0 , 0 , 2 , 5 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 4 } , { 0 , 0 , 5 , 2 , 0 , 6 , 3 , 0 , 0 } } ; if ( solveSuduko ( grid , 0 , 0 ) == 1 ) print ( grid ) ; else printf ( \" No ▁ solution ▁ exists \" ) ; return 0 ; }"}
{"text": "A Simple Merge based O ( n ) solution to find median of two sorted arrays", "code": "#include <stdio.h>"}
{"text": "This function returns median of ar1 [ ] and ar2 [ ] . Assumptions in this function : Both ar1 [ ] and ar2 [ ] are sorted arrays Both have n elements", "code": "int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = -1 , m2 = -1 ;"}
{"text": "Since there are 2 n elements , median will be average of elements at index n - 1 and n in the array obtained after merging ar1 and ar2", "code": "for ( count = 0 ; count <= n ; count ++ ) {"}
{"text": "Below is to handle case where all elements of ar1 [ ] are smaller than smallest ( or first ) element of ar2 [ ]", "code": "if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; }"}
{"text": "Below is to handle case where all elements of ar2 [ ] are smaller than smallest ( or first ) element of ar1 [ ]", "code": "else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; }"}
{"text": "equals sign because if two arrays have some common elements", "code": "if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ;"}
{"text": "Store the prev median", "code": "m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ;"}
{"text": "Store the prev median", "code": "m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int ar1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; if ( n1 == n2 ) printf ( \" Median ▁ is ▁ % d \" , getMedian ( ar1 , ar2 , n1 ) ) ; else printf ( \" Doesn ' t ▁ work ▁ for ▁ arrays ▁ of ▁ unequal ▁ size \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "A divide and conquer based efficient solution to find median of two sorted arrays of same size .", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "to get median of a sorted array", "code": "int median ( int [ ] , int ) ;"}
{"text": "This function returns median of ar1 [ ] and ar2 [ ] . Assumptions in this function : Both ar1 [ ] and ar2 [ ] are sorted arrays Both have n elements", "code": "int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { if ( n <= 0 ) return -1 ; if ( n == 1 ) return ( ar1 [ 0 ] + ar2 [ 0 ] ) / 2 ; if ( n == 2 ) return ( max ( ar1 [ 0 ] , ar2 [ 0 ] ) + min ( ar1 [ 1 ] , ar2 [ 1 ] ) ) / 2 ;"}
{"text": "get the median of the first array", "code": "int m1 = median ( ar1 , n ) ;"}
{"text": "get the median of the second array", "code": "int m2 = median ( ar2 , n ) ;"}
{"text": "If medians are equal then return either m1 or m2", "code": "if ( m1 == m2 ) return m1 ;"}
{"text": "if m1 < m2 then median must exist in ar1 [ m1 ... . ] and ar2 [ ... . m2 ]", "code": "if ( m1 < m2 ) { if ( n % 2 == 0 ) return getMedian ( ar1 + n / 2 - 1 , ar2 , n - n / 2 + 1 ) ; return getMedian ( ar1 + n / 2 , ar2 , n - n / 2 ) ; }"}
{"text": "if m1 > m2 then median must exist in ar1 [ ... . m1 ] and ar2 [ m2 ... ]", "code": "if ( n % 2 == 0 ) return getMedian ( ar2 + n / 2 - 1 , ar1 , n - n / 2 + 1 ) ; return getMedian ( ar2 + n / 2 , ar1 , n - n / 2 ) ; }"}
{"text": "Function to get median of a sorted array", "code": "int median ( int arr [ ] , int n ) { if ( n % 2 == 0 ) return ( arr [ n / 2 ] + arr [ n / 2 - 1 ] ) / 2 ; else return arr [ n / 2 ] ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int ar1 [ ] = { 1 , 2 , 3 , 6 } ; int ar2 [ ] = { 4 , 6 , 8 , 10 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; if ( n1 == n2 ) printf ( \" Median ▁ is ▁ % d \" , getMedian ( ar1 , ar2 , n1 ) ) ; else printf ( \" Doesn ' t ▁ work ▁ for ▁ arrays ▁ of ▁ unequal ▁ size \" ) ; return 0 ; }"}
{"text": "A divide and conquer program in C / C ++ to find the smallest distance from a given set of points .", "code": "#include <stdio.h> NEW_LINE #include <float.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <math.h>"}
{"text": "A structure to represent a Point in 2D plane", "code": "struct Point { int x , y ; } ;"}
{"text": "Needed to sort array of points according to X coordinate", "code": "int compareX ( const void * a , const void * b ) { Point * p1 = ( Point * ) a , * p2 = ( Point * ) b ; return ( p1 -> x - p2 -> x ) ; }"}
{"text": "Needed to sort array of points according to Y coordinate", "code": "int compareY ( const void * a , const void * b ) { Point * p1 = ( Point * ) a , * p2 = ( Point * ) b ; return ( p1 -> y - p2 -> y ) ; }"}
{"text": "A utility function to find the distance between two points", "code": "float dist ( Point p1 , Point p2 ) { return sqrt ( ( p1 . x - p2 . x ) * ( p1 . x - p2 . x ) + ( p1 . y - p2 . y ) * ( p1 . y - p2 . y ) ) ; }"}
{"text": "A Brute Force method to return the smallest distance between two points in P [ ] of size n", "code": "float bruteForce ( Point P [ ] , int n ) { float min = FLT_MAX ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i + 1 ; j < n ; ++ j ) if ( dist ( P [ i ] , P [ j ] ) < min ) min = dist ( P [ i ] , P [ j ] ) ; return min ; }"}
{"text": "A utility function to find a minimum of two float values", "code": "float min ( float x , float y ) { return ( x < y ) ? x : y ; }"}
{"text": "A utility function to find the distance between the closest points of strip of a given size . All points in strip [ ] are sorted according to y coordinate . They all have an upper bound on minimum distance as d . Note that this method seems to be a O ( n ^ 2 ) method , but it 's a O(n) method as the inner loop runs at most 6 times", "code": "float stripClosest ( Point strip [ ] , int size , float d ) {"}
{"text": "Initialize the minimum distance as d", "code": "float min = d ; qsort ( strip , size , sizeof ( Point ) , compareY ) ;"}
{"text": "Pick all points one by one and try the next points till the difference between y coordinates is smaller than d . This is a proven fact that this loop runs at most 6 times", "code": "for ( int i = 0 ; i < size ; ++ i ) for ( int j = i + 1 ; j < size && ( strip [ j ] . y - strip [ i ] . y ) < min ; ++ j ) if ( dist ( strip [ i ] , strip [ j ] ) < min ) min = dist ( strip [ i ] , strip [ j ] ) ; return min ; }"}
{"text": "A recursive function to find the smallest distance . The array P contains all points sorted according to x coordinate", "code": "float closestUtil ( Point P [ ] , int n ) {"}
{"text": "If there are 2 or 3 points , then use brute force", "code": "if ( n <= 3 ) return bruteForce ( P , n ) ;"}
{"text": "Find the middle point", "code": "int mid = n / 2 ; Point midPoint = P [ mid ] ;"}
{"text": "Consider the vertical line passing through the middle point calculate the smallest distance dl on left of middle point and dr on right side", "code": "float dl = closestUtil ( P , mid ) ; float dr = closestUtil ( P + mid , n - mid ) ;"}
{"text": "Find the smaller of two distances", "code": "float d = min ( dl , dr ) ;"}
{"text": "Build an array strip [ ] that contains points close ( closer than d ) to the line passing through the middle point", "code": "Point strip [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( abs ( P [ i ] . x - midPoint . x ) < d ) strip [ j ] = P [ i ] , j ++ ;"}
{"text": "Find the closest points in strip . Return the minimum of d and closest distance is strip [ ]", "code": "return min ( d , stripClosest ( strip , j , d ) ) ; }"}
{"text": "The main function that finds the smallest distance This method mainly uses closestUtil ( )", "code": "float closest ( Point P [ ] , int n ) { qsort ( P , n , sizeof ( Point ) , compareX ) ;"}
{"text": "Use recursive function closestUtil ( ) to find the smallest distance", "code": "return closestUtil ( P , n ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { Point P [ ] = { { 2 , 3 } , { 12 , 30 } , { 40 , 50 } , { 5 , 1 } , { 12 , 10 } , { 3 , 4 } } ; int n = sizeof ( P ) / sizeof ( P [ 0 ] ) ; printf ( \" The ▁ smallest ▁ distance ▁ is ▁ % f ▁ \" , closest ( P , n ) ) ; return 0 ; }"}
{"text": "Returns 1 if n is a lucky no . ohterwise returns 0", "code": "bool isLucky ( int n ) { static int counter = 2 ;"}
{"text": "variable next_position is just for readability of the program we can remove it and use n only", "code": "int next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ;"}
{"text": "calculate next position of input no", "code": "next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }"}
{"text": "Driver function to test above function", "code": "int main ( ) { int x = 5 ; if ( isLucky ( x ) ) printf ( \" % d ▁ is ▁ a ▁ lucky ▁ no . \" , x ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ lucky ▁ no . \" , x ) ; getchar ( ) ; }"}
{"text": "Works only if a >= 0 and b >= 0", "code": "int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }"}
{"text": "driver program to test above function", "code": "int main ( ) { printf ( \" % d \" , pow ( 5 , 3 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "A recursive function to get x * y", "code": "int multiply ( int x , int y ) { if ( y ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; }"}
{"text": "A recursive function to get a ^ b Works only if a >= 0 and b >= 0", "code": "int pow ( int a , int b ) { if ( b ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; }"}
{"text": "driver program to test above functions", "code": "int main ( ) { printf ( \" % d \" , pow ( 5 , 3 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "returns count of numbers which are in range from 1 to n and don 't contain 3  as a digit", "code": "int count ( int n ) {"}
{"text": "Base cases ( Assuming n is not negative )", "code": "if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ;"}
{"text": "Calculate 10 ^ ( d - 1 ) ( 10 raise to the power d - 1 ) where d is number of digits in n . po will be 100 for n = 578", "code": "int po = 1 ; while ( n / po > 9 ) po = po * 10 ;"}
{"text": "find the most significant digit ( msd is 5 for 578 )", "code": "int msd = n / po ; if ( msd != 3 )"}
{"text": "For 578 , total will be 4 * count ( 10 ^ 2 - 1 ) + 4 + count ( 78 )", "code": "return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else"}
{"text": "For 35 , total will be equal to count ( 29 )", "code": "return count ( msd * po - 1 ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { printf ( \" % d ▁ \" , count ( 578 ) ) ; return 0 ; }"}
{"text": "C program to find lexicographic rank of a string", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "A utility function to find factorial of n", "code": "int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; }"}
{"text": "A utility function to count smaller characters on right of arr [ low ]", "code": "int findSmallerInRight ( char * str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str [ i ] < str [ low ] ) ++ countRight ; return countRight ; }"}
{"text": "A function to find rank of a string in all permutations of characters", "code": "int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; int i ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ;"}
{"text": "count number of chars smaller than str [ i ] fron str [ i + 1 ] to str [ len - 1 ]", "code": "countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char str [ ] = \" string \" ; printf ( \" % d \" , findRank ( str ) ) ; return 0 ; }"}
{"text": "A O ( n ) solution for finding rank of string", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define MAX_CHAR  256"}
{"text": "all elements of count [ ] are initialized with 0", "code": "int count [ MAX_CHAR ] = { 0 } ;"}
{"text": "A utility function to find factorial of n", "code": "int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; }"}
{"text": "Construct a count array where value at every index contains count of smaller characters in whole string", "code": "void populateAndIncreaseCount ( int * count , char * str ) { int i ; for ( i = 0 ; str [ i ] ; ++ i ) ++ count [ str [ i ] ] ; for ( i = 1 ; i < MAX_CHAR ; ++ i ) count [ i ] += count [ i - 1 ] ; }"}
{"text": "Removes a character ch from count [ ] array constructed by populateAndIncreaseCount ( )", "code": "void updatecount ( int * count , char ch ) { int i ; for ( i = ch ; i < MAX_CHAR ; ++ i ) -- count [ i ] ; }"}
{"text": "A function to find rank of a string in all permutations of characters", "code": "int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 , i ;"}
{"text": "Populate the count array such that count [ i ] contains count of characters which are present in str and are smaller than i", "code": "populateAndIncreaseCount ( count , str ) ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ;"}
{"text": "count number of chars smaller than str [ i ] fron str [ i + 1 ] to str [ len - 1 ]", "code": "rank += count [ str [ i ] - 1 ] * mul ;"}
{"text": "Reduce count of characters greater than str [ i ]", "code": "updatecount ( count , str [ i ] ) ; } return rank ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char str [ ] = \" string \" ; printf ( \" % d \" , findRank ( str ) ) ; return 0 ; }"}
{"text": "Program to print all permutations of a string in sorted order .", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h>"}
{"text": "Following function is needed for library function qsort ( ) . Refer http : www . cplusplus . com / reference / clibrary / cstdlib / qsort /", "code": "int compare ( const void * a , const void * b ) { return ( * ( char * ) a - * ( char * ) b ) ; }"}
{"text": "A utility function two swap two characters a and b", "code": "void swap ( char * a , char * b ) { char t = * a ; * a = * b ; * b = t ; }"}
{"text": "This function finds the index of the smallest character which is greater than ' first ' and is present in str [ l . . h ]", "code": "int findCeil ( char str [ ] , char first , int l , int h ) {"}
{"text": "initialize index of ceiling element", "code": "int ceilIndex = l ;"}
{"text": "Now iterate through rest of the elements and find the smallest character greater than ' first '", "code": "for ( int i = l + 1 ; i <= h ; i ++ ) if ( str [ i ] > first && str [ i ] < str [ ceilIndex ] ) ceilIndex = i ; return ceilIndex ; }"}
{"text": "Print all permutations of str in sorted order", "code": "void sortedPermutations ( char str [ ] ) {"}
{"text": "Get size of string", "code": "int size = strlen ( str ) ;"}
{"text": "Sort the string in increasing order", "code": "qsort ( str , size , sizeof ( str [ 0 ] ) , compare ) ;"}
{"text": "Print permutations one by one", "code": "bool isFinished = false ; while ( ! isFinished ) {"}
{"text": "print this permutation", "code": "printf ( \" % s ▁ STRNEWLINE \" , str ) ;"}
{"text": "Find the rightmost character which is smaller than its next character . Let us call it ' first ▁ char '", "code": "int i ; for ( i = size - 2 ; i >= 0 ; -- i ) if ( str [ i ] < str [ i + 1 ] ) break ;"}
{"text": "If there is no such character , all are sorted in decreasing order , means we just printed the last permutation and we are done .", "code": "if ( i == -1 ) isFinished = true ; else {"}
{"text": "Find the ceil of ' first ▁ char ' in right of first character . Ceil of a character is the smallest character greater than it", "code": "int ceilIndex = findCeil ( str , str [ i ] , i + 1 , size - 1 ) ;"}
{"text": "Swap first and second characters", "code": "swap ( & str [ i ] , & str [ ceilIndex ] ) ;"}
{"text": "Sort the string on right of ' first ▁ char '", "code": "qsort ( str + i + 1 , size - i - 1 , sizeof ( str [ 0 ] ) , compare ) ; } } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char str [ ] = \" ABCD \" ; sortedPermutations ( str ) ; return 0 ; }"}
{"text": "An optimized version that uses reverse instead of sort for finding the next permutation A utility function to reverse a string str [ l . . h ]", "code": "void reverse ( char str [ ] , int l , int h ) { while ( l < h ) { swap ( & str [ l ] , & str [ h ] ) ; l ++ ; h -- ; } }"}
{"text": "Print all permutations of str in sorted order", "code": "void sortedPermutations ( char str [ ] ) {"}
{"text": "Get size of string", "code": "int size = strlen ( str ) ;"}
{"text": "Sort the string in increasing order", "code": "qsort ( str , size , sizeof ( str [ 0 ] ) , compare ) ;"}
{"text": "Print permutations one by one", "code": "bool isFinished = false ; while ( ! isFinished ) {"}
{"text": "print this permutation", "code": "printf ( \" % s ▁ STRNEWLINE \" , str ) ;"}
{"text": "Find the rightmost character which is smaller than its next character . Let us call it ' first ▁ char '", "code": "int i ; for ( i = size - 2 ; i >= 0 ; -- i ) if ( str [ i ] < str [ i + 1 ] ) break ;"}
{"text": "If there is no such character , all are sorted in decreasing order , means we just printed the last permutation and we are done .", "code": "if ( i == -1 ) isFinished = true ; else {"}
{"text": "Find the ceil of ' first ▁ char ' in right of first character . Ceil of a character is the smallest character greater than it", "code": "int ceilIndex = findCeil ( str , str [ i ] , i + 1 , size - 1 ) ;"}
{"text": "Swap first and second characters", "code": "swap ( & str [ i ] , & str [ ceilIndex ] ) ;"}
{"text": "reverse the string on right of ' first ▁ char '", "code": "reverse ( str , i + 1 , size - 1 ) ; } } }"}
{"text": "C Efficient program to calculate e raise to the power x", "code": "#include <stdio.h>"}
{"text": "Returns approximate value of e ^ x using sum of first n terms of Taylor Series", "code": "float exponential ( int n , float x ) {"}
{"text": "initialize sum of series", "code": "float sum = 1.0f ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n = 10 ; float x = 1.0f ; printf ( \" e ^ x ▁ = ▁ % f \" , exponential ( n , x ) ) ; return 0 ; }"}
{"text": "C program to generate random numbers according to given frequency distribution", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Utility function to find ceiling of r in arr [ l . . h ]", "code": "int findCeil ( int arr [ ] , int r , int l , int h ) { int mid ; while ( l < h ) {"}
{"text": "Same as mid = ( l + h ) / 2", "code": "mid = l + ( ( h - l ) >> 1 ) ; ( r > arr [ mid ] ) ? ( l = mid + 1 ) : ( h = mid ) ; } return ( arr [ l ] >= r ) ? l : -1 ; }"}
{"text": "The main function that returns a random number from arr [ ] according to distribution array defined by freq [ ] . n is size of arrays .", "code": "int myRand ( int arr [ ] , int freq [ ] , int n ) {"}
{"text": "Create and fill prefix array", "code": "int prefix [ n ] , i ; prefix [ 0 ] = freq [ 0 ] ; for ( i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] + freq [ i ] ;"}
{"text": "prefix [ n - 1 ] is sum of all frequencies . Generate a random number with value from 1 to this sum", "code": "int r = ( rand ( ) % prefix [ n - 1 ] ) + 1 ;"}
{"text": "Find index of ceiling of r in prefix arrat", "code": "int indexc = findCeil ( prefix , r , 0 , n - 1 ) ; return arr [ indexc ] ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int freq [ ] = { 10 , 5 , 20 , 100 } ; int i , n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Use a different seed value for every run .", "code": "srand ( time ( NULL ) ) ;"}
{"text": "Let us generate 10 random numbers accroding to given distribution", "code": "for ( i = 0 ; i < 5 ; i ++ ) printf ( \" % d STRNEWLINE \" , myRand ( arr , freq , n ) ) ; return 0 ; }"}
{"text": "This function generates ' x ' with probability px / 100 , ' y ' with probability py / 100 and ' z ' with probability pz / 100 : Assumption : px + py + pz = 100 where px , py and pz lie between 0 to 100", "code": "int random ( int x , int y , int z , int px , int py , int pz ) {"}
{"text": "Generate a number from 1 to 100", "code": "int r = rand ( 1 , 100 ) ;"}
{"text": "r is smaller than px with probability px / 100", "code": "if ( r <= px ) return x ;"}
{"text": "r is greater than px and smaller than or equal to px + py with probability py / 100", "code": "if ( r <= ( px + py ) ) return y ;"}
{"text": "r is greater than px + py and smaller than or equal to 100 with probability pz / 100", "code": "else return z ; }"}
{"text": "C program to find angle between hour and minute hands", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Utility function to find minimum of two integers", "code": "int min ( int x , int y ) { return ( x < y ) ? x : y ; }"}
{"text": "Function to calculate the angle", "code": "int calcAngle ( double h , double m ) {"}
{"text": "validate the input", "code": "if ( h < 0 m < 0 h > 12 m > 60 ) printf ( \" Wrong ▁ input \" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; }"}
{"text": "Calculate the angles moved by hour and minute hands with reference to 12 : 00", "code": "int hour_angle = 0.5 * ( h * 60 + m ) ; int minute_angle = 6 * m ;"}
{"text": "Find the difference between two angles", "code": "int angle = abs ( hour_angle - minute_angle ) ;"}
{"text": "Return the smaller angle of two possible angles", "code": "angle = min ( 360 - angle , angle ) ; return angle ; }"}
{"text": "Driver Code", "code": "int main ( ) { printf ( \" % d ▁ n \" , calcAngle ( 9 , 60 ) ) ; printf ( \" % d ▁ n \" , calcAngle ( 3 , 30 ) ) ; return 0 ; }"}
{"text": "C program to find the element that occur only once", "code": "#include <stdio.h>"}
{"text": "Method to find the element that occur only once", "code": "int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text": "The expression \" one ▁ & ▁ arr [ i ] \" gives the bits that are there in both ' ones ' and new element from arr [ ] . We add these bits to ' twos ' using bitwise OR Value of ' twos ' will be set as 0 , 3 , 3 and 1 after 1 st , 2 nd , 3 rd and 4 th iterations respectively", "code": "twos = twos | ( ones & arr [ i ] ) ;"}
{"text": "XOR the new bits with previous ' ones ' to get all bits appearing odd number of times Value of ' ones ' will be set as 3 , 0 , 2 and 3 after 1 st , 2 nd , 3 rd and 4 th iterations respectively", "code": "ones = ones ^ arr [ i ] ;"}
{"text": "The common bits are those bits which appear third time So these bits should not be there in both ' ones ' and ' twos ' . common_bit_mask contains all these bits as 0 , so that the bits can be removed from ' ones ' and ' twos ' Value of ' common _ bit _ mask ' will be set as 00 , 00 , 01 and 10 after 1 st , 2 nd , 3 rd and 4 th iterations respectively", "code": "common_bit_mask = ~ ( ones & twos ) ;"}
{"text": "Remove common bits ( the bits that appear third time ) from ' ones ' Value of ' ones ' will be set as 3 , 0 , 0 and 2 after 1 st , 2 nd , 3 rd and 4 th iterations respectively", "code": "ones &= common_bit_mask ;"}
{"text": "Remove common bits ( the bits that appear third time ) from ' twos ' Value of ' twos ' will be set as 0 , 3 , 1 and 0 after 1 st , 2 nd , 3 rd and 4 th itearations respectively", "code": "twos &= common_bit_mask ; } return ones ; }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ % d ▁ \" , getSingle ( arr , n ) ) ; return 0 ; }"}
{"text": "C program to find the element that occur only once", "code": "#include <stdio.h> NEW_LINE #define INT_SIZE  32 NEW_LINE int getSingle ( int arr [ ] , int n ) {"}
{"text": "Initialize result", "code": "int result = 0 ; int x , sum ;"}
{"text": "Iterate through every bit", "code": "for ( int i = 0 ; i < INT_SIZE ; i ++ ) {"}
{"text": "Find sum of set bits at ith position in all array elements", "code": "sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; }"}
{"text": "The bits with sum not multiple of 3 , are the bits of element with single occurrence .", "code": "if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ % d ▁ \" , getSingle ( arr , n ) ) ; return 0 ; }"}
{"text": "A O ( Logn ) complexity program to count set bits in all numbers from 1 to n", "code": "#include <stdio.h>"}
{"text": "Returns position of leftmost set bit . The rightmost position is considered as 0", "code": "unsigned int getLeftmostBit ( int n ) { int m = 0 ; while ( n > 1 ) { n = n >> 1 ; m ++ ; } return m ; }"}
{"text": "Given the position of previous leftmost set bit in n ( or an upper bound on leftmost position ) returns the new position of leftmost set bit in n", "code": "unsigned int getNextLeftmostBit ( int n , int m ) { unsigned int temp = 1 << m ; while ( n < temp ) { temp = temp >> 1 ; m -- ; } return m ; }"}
{"text": "The main recursive function used by countSetBits ( )", "code": "unsigned int _countSetBits ( unsigned int n , int m ) ; unsigned int countSetBits ( unsigned int n ) {"}
{"text": "Get the position of leftmost set bit in n . This will be used as an upper bound for next set bit function", "code": "int m = getLeftmostBit ( n ) ;"}
{"text": "Use the position", "code": "return _countSetBits ( n , m ) ; } unsigned int _countSetBits ( unsigned int n , int m ) {"}
{"text": "Base Case : if n is 0 , then set bit count is 0", "code": "if ( n == 0 ) return 0 ;"}
{"text": "get position of next leftmost set bit", "code": "m = getNextLeftmostBit ( n , m ) ;"}
{"text": "If n is of the form 2 ^ x - 1 , i . e . , if n is like 1 , 3 , 7 , 15 , 31 , . . etc , then we are done . Since positions are considered starting from 0 , 1 is added to m", "code": "if ( n == ( ( unsigned int ) 1 << ( m + 1 ) ) - 1 ) return ( unsigned int ) ( m + 1 ) * ( 1 << m ) ;"}
{"text": "update n for next recursive call", "code": "n = n - ( 1 << m ) ; return ( n + 1 ) + countSetBits ( n ) + m * ( 1 << ( m - 1 ) ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int n = 17 ; printf ( \" Total ▁ set ▁ bit ▁ count ▁ is ▁ % d \" , countSetBits ( n ) ) ; return 0 ; }"}
{"text": "C Program to swap bits in a given number", "code": "#include <stdio.h> NEW_LINE int swapBits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) {"}
{"text": "Move all bits of first set to rightmost side", "code": "unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ;"}
{"text": "Move all bits of second set to rightmost side", "code": "unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ;"}
{"text": "XOR the two sets", "code": "unsigned int xor = ( set1 ^ set2 ) ;"}
{"text": "Put the xor bits back to their original positions", "code": "xor = ( xor << p1 ) | ( xor << p2 ) ;"}
{"text": "XOR the ' xor ' with the original number so that the two sets are swapped", "code": "unsigned int result = x ^ xor ; return result ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int res = swapBits ( 28 , 0 , 3 , 2 ) ; printf ( \" Result = % d \" , res ) ; return 0 ; }"}
{"text": "C program to find Smallest of three integers without comparison operators", "code": "#include <stdio.h> NEW_LINE int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }"}
{"text": "Driver code", "code": "int main ( ) { int x = 12 , y = 15 , z = 5 ; printf ( \" Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ % d \" , smallest ( x , y , z ) ) ; return 0 ; }"}
{"text": "C implementation of above approach", "code": "#include <stdio.h> NEW_LINE #define CHAR_BIT  8"}
{"text": "Function to find minimum of x and y", "code": "int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; }"}
{"text": "Function to find minimum of 3 numbers x , y and z", "code": "int smallest ( int x , int y , int z ) { return min ( x , min ( y , z ) ) ; }"}
{"text": "Driver code", "code": "int main ( ) { int x = 12 , y = 15 , z = 5 ; printf ( \" Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ % d \" , smallest ( x , y , z ) ) ; return 0 ; }"}
{"text": "Using division operator to find minimum of three numbers", "code": "int smallest ( int x , int y , int z ) {"}
{"text": "Same as \" if ▁ ( y ▁ < ▁ x ) \"", "code": "if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ; return ( ! ( x / z ) ) ? x : z ; }"}
{"text": "Driver code", "code": "int main ( ) { int x = 78 , y = 88 , z = 68 ; printf ( \" Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ % d \" , smallest ( x , y , z ) ) ; return 0 ; }"}
{"text": "Driver code", "code": "int main ( ) { int a [ ] = { 1 , 0 } ; changeToZero ( a ) ; printf ( \" ▁ arr [ 0 ] ▁ = ▁ % d ▁ STRNEWLINE \" , a [ 0 ] ) ; printf ( \" ▁ arr [ 1 ] ▁ = ▁ % d ▁ \" , a [ 1 ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Size of array 64 K", "code": "#define SIZE  (1 << 16)"}
{"text": "GROUP_A - When combined with META_LOOK_UP generates count for 4 x4 elements", "code": "#define GROUP_A ( x )  x, x + 1, x + 1, x + 2"}
{"text": "GROUP_B - When combined with META_LOOK_UP generates count for 4 x4x4 elements", "code": "#define GROUP_B ( x )  GROUP_A(x), GROUP_A(x+1), GROUP_A(x+1), GROUP_A(x+2)"}
{"text": "GROUP_C - When combined with META_LOOK_UP generates count for 4 x4x4x4 elements", "code": "#define GROUP_C ( x )  GROUP_B(x), GROUP_B(x+1), GROUP_B(x+1), GROUP_B(x+2)"}
{"text": "Provide appropriate letter to generate the table", "code": "#define META_LOOK_UP ( PARAMETER )  \\NEW_LINE GROUP_##PARAMETER(0), \\NEW_LINE GROUP_##PARAMETER(1), \\NEW_LINE GROUP_##PARAMETER(1), \\NEW_LINE GROUP_##PARAMETER(2) \\NEW_LINEint countSetBits(int array[], size_t array_size) NEW_LINE { int count = 0 ;"}
{"text": "A static table will be much faster to access", "code": "static unsigned char const look_up [ ] = { META_LOOK_UP ( C ) } ;"}
{"text": "No shifting funda ( for better readability )", "code": "unsigned char * pData = NULL ; for ( size_t index = 0 ; index < array_size ; index ++ ) {"}
{"text": "It is fine , bypass the type system", "code": "pData = ( unsigned char * ) & array [ index ] ;"}
{"text": "Count set bits in individual bytes", "code": "count += look_up [ pData [ 0 ] ] ; count += look_up [ pData [ 1 ] ] ; count += look_up [ pData [ 2 ] ] ; count += look_up [ pData [ 3 ] ] ; } return count ; }"}
{"text": "Driver program , generates table of random 64 K numbers", "code": "int main ( ) { int index ; int random [ SIZE ] ;"}
{"text": "Seed to the random - number generator", "code": "srand ( ( unsigned ) time ( 0 ) ) ;"}
{"text": "Generate random numbers .", "code": "for ( index = 0 ; index < SIZE ; index ++ ) { random [ index ] = rand ( ) ; } printf ( \" Total ▁ number ▁ of ▁ bits ▁ = ▁ % d STRNEWLINE \" , countSetBits ( random , SIZE ) ) ; return 0 ; }"}
{"text": "C ++ code to add add one to a given number", "code": "#include <stdio.h> NEW_LINE int addOne ( int x ) { int m = 1 ;"}
{"text": "Flip all the set bits until we find a 0", "code": "while ( x & m ) { x = x ^ m ; m <<= 1 ; }"}
{"text": "flip the rightmost 0 bit", "code": "x = x ^ m ; return x ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { printf ( \" % d \" , addOne ( 13 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { printf ( \" % d \" , addOne ( 13 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "unsets the rightmost set bit of n and returns the result", "code": "int fun ( unsigned int n ) { return n & ( n - 1 ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int n = 7 ; printf ( \" The ▁ number ▁ after ▁ unsetting ▁ the \" ) ; printf ( \" ▁ rightmost ▁ set ▁ bit ▁ % d \" , fun ( n ) ) ; return 0 ; }"}
{"text": "Function to check if x is power of 4", "code": "bool isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) printf ( \" % d ▁ is ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; getchar ( ) ; }"}
{"text": "Function to check if x is power of 4", "code": "bool isPowerOfFour ( unsigned int n ) { int count = 0 ;"}
{"text": "Check if there is only one bit set in n", "code": "if ( n && ! ( n & ( n - 1 ) ) ) {"}
{"text": "count 0 bits before set bit", "code": "while ( n > 1 ) { n >>= 1 ; count += 1 ; }"}
{"text": "If count is even then return true else false", "code": "return ( count % 2 == 0 ) ? 1 : 0 ; }"}
{"text": "If there are more than 1 bit set then n is not a power of 4", "code": "return 0 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) printf ( \" % d ▁ is ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; getchar ( ) ; }"}
{"text": "C program to check if given number is power of 4 or not", "code": "#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isPowerOfFour ( unsigned int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) printf ( \" % d ▁ is ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4\" , test_no ) ; getchar ( ) ; }"}
{"text": "C program to Compute the minimum or maximum of two integers without branching", "code": "#include <stdio.h>"}
{"text": "Function to find minimum of x and y", "code": "int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x < y ) ) ; }"}
{"text": "Function to find maximum of x and y", "code": "int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x < y ) ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int x = 15 ; int y = 6 ; printf ( \" Minimum ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ \" , x , y ) ; printf ( \" % d \" , min ( x , y ) ) ; printf ( \" Maximum of % d and % d is \" printf ( \" % d \" , max ( x , y ) ) ; getchar ( ) ; }"}
{"text": "Function to find minimum of x and y", "code": "int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; }"}
{"text": "Function to find maximum of x and y", "code": "int max ( int x , int y ) { return x - ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int x = 15 ; int y = 6 ; printf ( \" Minimum ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ \" , x , y ) ; printf ( \" % d \" , min ( x , y ) ) ; printf ( \" Maximum of % d and % d is \" printf ( \" % d \" , max ( x , y ) ) ; getchar ( ) ; }"}
{"text": "Takes pointer to result and two numbers as arguments . If there is no overflow , the function places the resultant = sum a + b in result and returns 0 , otherwise it returns - 1", "code": "int addOvf ( int * result , int a , int b ) { * result = a + b ; if ( a > 0 && b > 0 && * result < 0 ) return -1 ; if ( a < 0 && b < 0 && * result > 0 ) return -1 ; return 0 ; }"}
{"text": "Driver code", "code": "int main ( ) { int * res = ( int * ) malloc ( sizeof ( int ) ) ; int x = 2147483640 ; int y = 10 ; printf ( \" % d \" , addOvf ( res , x , y ) ) ; printf ( \" % d \" , * res ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program for Position of rightmost set bit", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE unsigned int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 12 ; printf ( \" % u \" , getFirstSetBitPos ( n ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "bin function", "code": "void bin ( unsigned n ) { unsigned i ; for ( i = 1 << 31 ; i > 0 ; i = i / 2 ) ( n & i ) ? printf ( \"1\" ) : printf ( \"0\" ) ; }"}
{"text": "Driver Code", "code": "int main ( void ) { bin ( 7 ) ; printf ( \" STRNEWLINE \" ) ; bin ( 4 ) ; }"}
{"text": "C program to swap even and odd bits of a given number", "code": "#include <stdio.h>"}
{"text": "Function to swap even and odd bits", "code": "unsigned int swapBits ( unsigned int x ) {"}
{"text": "Get all even bits of x", "code": "unsigned int even_bits = x & 0xAAAAAAAA ;"}
{"text": "Get all odd bits of x", "code": "unsigned int odd_bits = x & 0x55555555 ;"}
{"text": "Right shift even bits", "code": "even_bits >>= 1 ;"}
{"text": "Left shift odd bits", "code": "odd_bits <<= 1 ;"}
{"text": "Combine even and odd bits", "code": "return ( even_bits odd_bits ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) {"}
{"text": "00010111", "code": "unsigned int x = 23 ;"}
{"text": "Output is 43 ( 00101011 )", "code": "printf ( \" % u ▁ \" , swapBits ( x ) ) ; return 0 ; }"}
{"text": "C program to find position of only set bit in a given number", "code": "#include <stdio.h>"}
{"text": "A utility function to check whether n is a power of 2 or not . goo . gl / 17 Arj See http :", "code": "int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; }"}
{"text": "Returns position of the only set bit in ' n '", "code": "int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned i = 1 , pos = 1 ;"}
{"text": "Iterate through bits of n till we find a set bit i & n will be non - zero only when ' i ' and ' n ' have a set bit at same position", "code": "while ( ! ( i & n ) ) {"}
{"text": "Unset current bit and set the next bit in ' i '", "code": "i = i << 1 ;"}
{"text": "increment position", "code": "++ pos ; } return pos ; }"}
{"text": "Driver program to test above function", "code": "int main ( void ) { int n = 16 ; int pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; n = 12 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; n = 128 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; return 0 ; }"}
{"text": "C program to find position of only set bit in a given number", "code": "#include <stdio.h>"}
{"text": "A utility function to check whether n is power of 2 or not", "code": "int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; }"}
{"text": "Returns position of the only set bit in ' n '", "code": "int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned count = 0 ;"}
{"text": "One by one move the only set bit to right till it reaches end", "code": "while ( n ) { n = n >> 1 ;"}
{"text": "increment count of shifts", "code": "++ count ; } return count ; }"}
{"text": "Driver program to test above function", "code": "int main ( void ) { int n = 0 ; int pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; n = 12 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; n = 128 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n ▁ = ▁ % d , ▁ Invalid ▁ number STRNEWLINE \" , n ) : printf ( \" n ▁ = ▁ % d , ▁ Position ▁ % d ▁ STRNEWLINE \" , n , pos ) ; return 0 ; }"}
{"text": "C Program to swap two numbers without using temporary variable", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 10 , y = 5 ;"}
{"text": "Code to swap ' x ' and ' y ' x now becomes 50", "code": "x = x * y ;"}
{"text": "y becomes 10", "code": "y = x / y ;"}
{"text": "x becomes 5", "code": "x = x / y ; printf ( \" After ▁ Swapping : ▁ x ▁ = ▁ % d , ▁ y ▁ = ▁ % d \" , x , y ) ; return 0 ; }"}
{"text": "C code to swap using XOR", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 10 , y = 5 ;"}
{"text": "Code to swap ' x ' ( 1010 ) and ' y ' ( 0101 ) x now becomes 15 ( 1111 )", "code": "x = x ^ y ;"}
{"text": "y becomes 10 ( 1010 )", "code": "y = x ^ y ;"}
{"text": "x becomes 5 ( 0101 )", "code": "x = x ^ y ; printf ( \" After ▁ Swapping : ▁ x ▁ = ▁ % d , ▁ y ▁ = ▁ % d \" , x , y ) ; return 0 ; }"}
{"text": "C program to implement the above approach", "code": "#include <stdio.h>"}
{"text": "Swap function", "code": "void swap ( int * xp , int * yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; * xp = * xp ^ * yp ; }"}
{"text": "Driver code", "code": "int main ( ) { int x = 10 ; swap ( & x , & x ) ; printf ( \" After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ % d \" , x ) ; return 0 ; }"}
{"text": "C Program to replace every element with the greatest element on right side", "code": "#include <stdio.h>"}
{"text": "Function to replace every element with the next greatest element", "code": "void nextGreatest ( int arr [ ] , int size ) {"}
{"text": "Initialize the next greatest element", "code": "int max_from_right = arr [ size - 1 ] ;"}
{"text": "The next greatest element for the rightmost element is always - 1", "code": "arr [ size - 1 ] = -1 ;"}
{"text": "Replace all other elements with the next greatest", "code": "for ( int i = size - 2 ; i >= 0 ; i -- ) {"}
{"text": "Store the current element ( needed later for updating the next greatest element )", "code": "int temp = arr [ i ] ;"}
{"text": "Replace current element with the next greatest", "code": "arr [ i ] = max_from_right ;"}
{"text": "Update the greatest element , if needed", "code": "if ( max_from_right < temp ) max_from_right = temp ; } }"}
{"text": "A utility Function that prints an array", "code": "void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nextGreatest ( arr , size ) ; printf ( \" The ▁ modified ▁ array ▁ is : ▁ STRNEWLINE \" ) ; printArray ( arr , size ) ; return ( 0 ) ; }"}
{"text": "The function assumes that there are at least two elements in array . The function returns a negative value if the array is sorted in decreasing order . Returns 0 if elements are equal", "code": "int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_size ; i ++ ) { for ( j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ;"}
{"text": "Function calling", "code": "printf ( \" Maximum ▁ difference ▁ is ▁ % d \" , maxDiff ( arr , 5 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "C program to find maximum element", "code": "#include <stdio.h>"}
{"text": "function to find the maximum element", "code": "int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }"}
{"text": "Driver program to check above functions", "code": "int main ( ) { int arr [ ] = { 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ maximum ▁ element ▁ is ▁ % d \" , findMaximum ( arr , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Base Case : Only one element is present in arr [ low . . high ]", "code": "if ( low == high ) return arr [ low ] ;"}
{"text": "If there are two elements and first is greater then the first element is maximum", "code": "if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ;"}
{"text": "If there are two elements and second is greater then the second element is maximum", "code": "if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ;"}
{"text": "If we reach a point where arr [ mid ] is greater than both of its adjacent elements arr [ mid - 1 ] and arr [ mid + 1 ] , then arr [ mid ] is the maximum element", "code": "if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ;"}
{"text": "If arr [ mid ] is greater than the next element and smaller than the previous element then maximum lies on left side of mid", "code": "if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ;"}
{"text": "when arr [ mid ] is greater than arr [ mid - 1 ] and smaller than arr [ mid + 1 ]", "code": "else return findMaximum ( arr , mid + 1 , high ) ; }"}
{"text": "Driver program to check above functions", "code": "int main ( ) { int arr [ ] = { 1 , 3 , 50 , 10 , 9 , 7 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ maximum ▁ element ▁ is ▁ % d \" , findMaximum ( arr , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "initialize all the counts in countSmaller array as 0", "code": "for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ i ] ) countSmaller [ i ] ++ ; } } }"}
{"text": "Utility function that prints out an array on a line", "code": "void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int arr [ ] = { 12 , 10 , 5 , 4 , 2 , 20 , 6 , 1 , 0 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * low = ( int * ) malloc ( sizeof ( int ) * n ) ; constructLowerArray ( arr , low , n ) ; printArray ( low , n ) ; return 0 ; }"}
{"text": "An AVL tree node", "code": "struct node { int key ; struct node * left ; struct node * right ; int height ;"}
{"text": "size of the tree rooted with this node", "code": "int size ; } ;"}
{"text": "A utility function to get maximum of two integers", "code": "int max ( int a , int b ) ;"}
{"text": "A utility function to get height of the tree rooted with N", "code": "int height ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> height ; }"}
{"text": "A utility function to size of the tree of rooted with N", "code": "int size ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> size ; }"}
{"text": "A utility function to get maximum of two integers", "code": "int max ( int a , int b ) { return ( a > b ) ? a : b ; }"}
{"text": "Helper function that allocates a new node with the given key and NULL left and right pointers .", "code": "struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ;"}
{"text": "new node is initially added at leaf", "code": "node -> height = 1 ; node -> size = 1 ; return ( node ) ; }"}
{"text": "A utility function to right rotate subtree rooted with y", "code": "struct node * rightRotate ( struct node * y ) { struct node * x = y -> left ; struct node * T2 = x -> right ;"}
{"text": "Perform rotation", "code": "x -> right = y ; y -> left = T2 ;"}
{"text": "Update heights", "code": "y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ;"}
{"text": "Update sizes", "code": "y -> size = size ( y -> left ) + size ( y -> right ) + 1 ; x -> size = size ( x -> left ) + size ( x -> right ) + 1 ;"}
{"text": "Return new root", "code": "return x ; }"}
{"text": "A utility function to left rotate subtree rooted with x", "code": "struct node * leftRotate ( struct node * x ) { struct node * y = x -> right ; struct node * T2 = y -> left ;"}
{"text": "Perform rotation", "code": "y -> left = x ; x -> right = T2 ;"}
{"text": "Update heights", "code": "x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ;"}
{"text": "Update sizes", "code": "x -> size = size ( x -> left ) + size ( x -> right ) + 1 ; y -> size = size ( y -> left ) + size ( y -> right ) + 1 ;"}
{"text": "Return new root", "code": "return y ; }"}
{"text": "Get Balance factor of node N", "code": "int getBalance ( struct node * N ) { if ( N == NULL ) return 0 ; return height ( N -> left ) - height ( N -> right ) ; }"}
{"text": "Inserts a new key to the tree rotted with node . Also , updates * count to contain count of smaller elements for the new key", "code": "struct node * insert ( struct node * node , int key , int * count ) {"}
{"text": "1. Perform the normal BST rotation", "code": "if ( node == NULL ) return ( newNode ( key ) ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key , count ) ; else { node -> right = insert ( node -> right , key , count ) ;"}
{"text": "UPDATE COUNT OF SMALLER ELEMENTS FOR KEY", "code": "* count = * count + size ( node -> left ) + 1 ; }"}
{"text": "2. Update height and size of this ancestor node", "code": "node -> height = max ( height ( node -> left ) , height ( node -> right ) ) + 1 ; node -> size = size ( node -> left ) + size ( node -> right ) + 1 ;"}
{"text": "3. Get the balance factor of this ancestor node to check whether this node became unbalanced", "code": "int balance = getBalance ( node ) ;"}
{"text": "Left Left Case", "code": "if ( balance > 1 && key < node -> left -> key ) return rightRotate ( node ) ;"}
{"text": "Right Right Case", "code": "if ( balance < -1 && key > node -> right -> key ) return leftRotate ( node ) ;"}
{"text": "Left Right Case", "code": "if ( balance > 1 && key > node -> left -> key ) { node -> left = leftRotate ( node -> left ) ; return rightRotate ( node ) ; }"}
{"text": "Right Left Case", "code": "if ( balance < -1 && key < node -> right -> key ) { node -> right = rightRotate ( node -> right ) ; return leftRotate ( node ) ; }"}
{"text": "return the ( unchanged ) node pointer", "code": "return node ; }"}
{"text": "The following function updates the countSmaller array to contain count of smaller elements on right side .", "code": "void constructLowerArray ( int arr [ ] , int countSmaller [ ] , int n ) { int i , j ; struct node * root = NULL ;"}
{"text": "initialize all the counts in countSmaller array as 0", "code": "for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ;"}
{"text": "Starting from rightmost element , insert all elements one by one in an AVL tree and get the count of smaller elements", "code": "for ( i = n - 1 ; i >= 0 ; i -- ) { root = insert ( root , arr [ i ] , & countSmaller [ i ] ) ; } }"}
{"text": "Utility function that prints out an array on a line", "code": "void printArray ( int arr [ ] , int size ) { int i ; printf ( \" STRNEWLINE \" ) ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int arr [ ] = { 10 , 6 , 15 , 20 , 30 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * low = ( int * ) malloc ( sizeof ( int ) * n ) ; constructLowerArray ( arr , low , n ) ; printf ( \" Following ▁ is ▁ the ▁ constructed ▁ smaller ▁ count ▁ array \" ) ; printArray ( low , n ) ; return 0 ; }"}
{"text": "C program to find the smallest positive missing number", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Utility to swap to integers", "code": "void swap ( int * a , int * b ) { int temp ; temp = * a ; * a = * b ; * b = temp ; }"}
{"text": "Utility function that puts all non - positive ( 0 and negative ) numbers on left side of arr [ ] and return count of such numbers", "code": "int segregate ( int arr [ ] , int size ) { int j = 0 , i ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] <= 0 ) { swap ( & arr [ i ] , & arr [ j ] ) ;"}
{"text": "increment count of non - positive integers", "code": "j ++ ; } } return j ; }"}
{"text": "Find the smallest positive missing number in an array that contains all positive integers", "code": "int findMissingPositive ( int arr [ ] , int size ) { int i ;"}
{"text": "Mark arr [ i ] as visited by making arr [ arr [ i ] - 1 ] negative . Note that 1 is subtracted because index start from 0 and positive numbers start from 1", "code": "for ( i = 0 ; i < size ; i ++ ) { if ( abs ( arr [ i ] ) - 1 < size && arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; }"}
{"text": "Return the first index value at which is positive", "code": "for ( i = 0 ; i < size ; i ++ ) if ( arr [ i ] > 0 )"}
{"text": "1 is added because indexes start from 0", "code": "return i + 1 ; return size + 1 ; }"}
{"text": "Find the smallest positive missing number in an array that contains both positive and negative integers", "code": "int findMissing ( int arr [ ] , int size ) {"}
{"text": "First separate positive and negative numbers", "code": "int shift = segregate ( arr , size ) ;"}
{"text": "Shift the array and call findMissingPositive for positive part", "code": "return findMissingPositive ( arr + shift , size - shift ) ; }"}
{"text": "Driver code", "code": "int main ( ) { int arr [ ] = { 0 , 10 , 2 , -10 , -20 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int missing = findMissing ( arr , arr_size ) ; printf ( \" The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ % d ▁ \" , missing ) ; getchar ( ) ; return 0 ; }"}
{"text": "getMissingNo takes array and size of array as arguments", "code": "int getMissingNo ( int a [ ] , int n ) { int i , total ; total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; }"}
{"text": "program to test above function", "code": "int main ( ) { int a [ ] = { 1 , 2 , 4 , 5 , 6 } ; int miss = getMissingNo ( a , 5 ) ; printf ( \" % d \" , miss ) ; getchar ( ) ; }"}
{"text": "C program to Find the repeating and missing elements", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void printTwoElements ( int arr [ ] , int size ) { int i ; printf ( \" The repeating element is \" for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else printf ( \" ▁ % d ▁ \" , abs ( arr [ i ] ) ) ; } printf ( \" and the missing element is \" for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) printf ( \" % d \" , i + 1 ) ; } }"}
{"text": "Driver code", "code": "int main ( ) { int arr [ ] = { 7 , 3 , 4 , 5 , 5 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoElements ( arr , n ) ; return 0 ; }"}
{"text": "C program to Find the repeating and missing elements", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "The output of this function is stored at * x and * y", "code": "void getTwoElements ( int arr [ ] , int n , int * x , int * y ) {"}
{"text": "Will hold xor of all elements and numbers from 1 to n", "code": "int xor1 ;"}
{"text": "Will have only single set bit of xor1", "code": "int set_bit_no ; int i ; * x = 0 ; * y = 0 ; xor1 = arr [ 0 ] ;"}
{"text": "Get the xor of all array elements", "code": "for ( i = 1 ; i < n ; i ++ ) xor1 = xor1 ^ arr [ i ] ;"}
{"text": "XOR the previous result with numbers from 1 to n", "code": "for ( i = 1 ; i <= n ; i ++ ) xor1 = xor1 ^ i ;"}
{"text": "Get the rightmost set bit in set_bit_no", "code": "set_bit_no = xor1 & ~ ( xor1 - 1 ) ;"}
{"text": "Now divide elements in two sets by comparing rightmost set bit of xor1 with bit at same position in each element . Also , get XORs of two sets . The two XORs are the output elements . The following two for loops serve the purpose", "code": "for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit_no )"}
{"text": "arr [ i ] belongs to first set", "code": "* x = * x ^ arr [ i ] ; else"}
{"text": "arr [ i ] belongs to second set", "code": "* y = * y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no )"}
{"text": "i belongs to first set", "code": "* x = * x ^ i ; else"}
{"text": "i belongs to second set", "code": "* y = * y ^ i ; }"}
{"text": "* x and * y hold the desired output elements", "code": "}"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 , 6 , 2 } ; int * x = ( int * ) malloc ( sizeof ( int ) ) ; int * y = ( int * ) malloc ( sizeof ( int ) ) ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getTwoElements ( arr , n , x , y ) ; printf ( \" ▁ The ▁ missing ▁ element ▁ is ▁ % d \" \" ▁ and ▁ the ▁ repeating ▁ number \" \" ▁ is ▁ % d \" , * x , * y ) ; getchar ( ) ; }"}
{"text": "A naive solution to print all combination of 4 elements in A [ ] with sum equal to X", "code": "void findFourElements ( int A [ ] , int n , int X ) {"}
{"text": "Fix the first element and find other three", "code": "for ( int i = 0 ; i < n - 3 ; i ++ ) {"}
{"text": "Fix the second element and find other two", "code": "for ( int j = i + 1 ; j < n - 2 ; j ++ ) {"}
{"text": "Fix the third element and find the fourth", "code": "for ( int k = j + 1 ; k < n - 1 ; k ++ ) {"}
{"text": "find the fourth", "code": "for ( int l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) printf ( \" % d , ▁ % d , ▁ % d , ▁ % d \" , A [ i ] , A [ j ] , A [ k ] , A [ l ] ) ; } } } }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int A [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int X = 91 ; findFourElements ( A , n , X ) ; return 0 ; }"}
{"text": "C program to find 4 elements with given sum", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "The following structure is needed to store pair sums in aux [ ]", "code": "struct pairSum {"}
{"text": "index ( int A [ ] ) of first element in pair", "code": "int first ;"}
{"text": "index of second element in pair", "code": "int sec ;"}
{"text": "sum of the pair", "code": "int sum ; } ;"}
{"text": "Following function is needed for library function qsort ( )", "code": "int compare ( const void * a , const void * b ) { return ( ( * ( pairSum * ) a ) . sum - ( * ( pairSum * ) b ) . sum ) ; }"}
{"text": "Function to check if two given pairs have any common element or not", "code": "bool noCommon ( struct pairSum a , struct pairSum b ) { if ( a . first == b . first a . first == b . sec a . sec == b . first a . sec == b . sec ) return false ; return true ; }"}
{"text": "The function finds four elements with given sum X", "code": "void findFourElements ( int arr [ ] , int n , int X ) { int i , j ;"}
{"text": "Create an auxiliary array to store all pair sums", "code": "int size = ( n * ( n - 1 ) ) / 2 ; struct pairSum aux [ size ] ;"}
{"text": "Generate all possible pairs from A [ ] and store sums of all possible pairs in aux [ ]", "code": "int k = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { aux [ k ] . sum = arr [ i ] + arr [ j ] ; aux [ k ] . first = i ; aux [ k ] . sec = j ; k ++ ; } }"}
{"text": "Sort the aux [ ] array using library function for sorting", "code": "qsort ( aux , size , sizeof ( aux [ 0 ] ) , compare ) ;"}
{"text": "Now start two index variables from two corners of array and move them toward each other .", "code": "i = 0 ; j = size - 1 ; while ( i < size && j >= 0 ) { if ( ( aux [ i ] . sum + aux [ j ] . sum == X ) && noCommon ( aux [ i ] , aux [ j ] ) ) { printf ( \" % d , ▁ % d , ▁ % d , ▁ % d STRNEWLINE \" , arr [ aux [ i ] . first ] , arr [ aux [ i ] . sec ] , arr [ aux [ j ] . first ] , arr [ aux [ j ] . sec ] ) ; return ; } else if ( aux [ i ] . sum + aux [ j ] . sum < X ) i ++ ; else j -- ; } }"}
{"text": "Driver code", "code": "int main ( ) { int arr [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 91 ;"}
{"text": "Function call", "code": "findFourElements ( arr , n , X ) ; return 0 ; }"}
{"text": "C program to find Min distance of maximum element", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "function to return min distance", "code": "int minDistance ( int arr [ ] , int n ) { int maximum_element = arr [ 0 ] ; int min_dis = n ; int index = 0 ; for ( int i = 1 ; i < n ; i ++ ) {"}
{"text": "case a", "code": "if ( maximum_element == arr [ i ] ) { min_dis = min ( min_dis , ( i - index ) ) ; index = i ; }"}
{"text": "case b", "code": "else if ( maximum_element < arr [ i ] ) { maximum_element = arr [ i ] ; min_dis = n ; index = i ; }"}
{"text": "case c", "code": "else continue ; } return min_dis ; }"}
{"text": "driver program", "code": "int main ( ) { int arr [ ] = { 6 , 3 , 1 , 3 , 6 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Minimum ▁ distance ▁ = ▁ \" << minDistance ( arr , n ) ; return 0 ; }"}
{"text": "Recursive C program to search an element in linked list", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h>"}
{"text": "Link list node", "code": "struct Node { int key ; struct Node * next ; } ;"}
{"text": "Given a reference ( pointer to pointer ) to the head of a list and an int , push a new node on the front of the list .", "code": "void push ( struct Node * * head_ref , int new_key ) {"}
{"text": "allocate node put in the key", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> key = new_key ;"}
{"text": "link the old list off the new node", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "move the head to point to the new node", "code": "( * head_ref ) = new_node ; }"}
{"text": "Checks whether the value x is present in linked list", "code": "bool search ( struct Node * head , int x ) {"}
{"text": "Base case", "code": "if ( head == NULL ) return false ;"}
{"text": "If key is present in current node , return true", "code": "if ( head -> key == x ) return true ;"}
{"text": "Recur for remaining list", "code": "return search ( head -> next , x ) ; }"}
{"text": "Driver program to test count function", "code": "int main ( ) {"}
{"text": "Start with the empty list", "code": "struct Node * head = NULL ; int x = 21 ;"}
{"text": "Use push ( ) to construct below list 14 -> 21 -> 11 -> 30 -> 10", "code": "push ( & head , 10 ) ; push ( & head , 30 ) ; push ( & head , 11 ) ; push ( & head , 21 ) ; push ( & head , 14 ) ; search ( head , 21 ) ? printf ( \" Yes \" ) : printf ( \" No \" ) ; return 0 ; }"}
{"text": "deletes alternate nodes of a list starting with head", "code": "void deleteAlt ( struct Node * head ) { if ( head == NULL ) return ; struct Node * node = head -> next ; if ( node == NULL ) return ;"}
{"text": "Change the next link of head", "code": "head -> next = node -> next ;"}
{"text": "free memory allocated for node", "code": "free ( node ) ;"}
{"text": "Recursively call for the new next of head", "code": "deleteAlt ( head -> next ) ; }"}
{"text": "points to the last node in ' a '", "code": "struct Node bDummy ; struct Node * bTail = & bDummy ;"}
{"text": "points to the last node in ' b '", "code": "struct Node * current = source ; aDummy . next = NULL ; bDummy . next = NULL ; while ( current != NULL ) { MoveNode ( & ( aTail -> next ) , t ) ;"}
{"text": "add at ' a ' tail", "code": "aTail = aTail -> next ;"}
{"text": "advance the ' a ' tail", "code": "if ( current != NULL ) { MoveNode ( & ( bTail -> next ) , t ) ; bTail = bTail -> next ; } } * aRef = aDummy . next ; * bRef = bDummy . next ; }"}
{"text": "An iterative C program to check if two linked lists are identical or not", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h>"}
{"text": "Structure for a linked list node", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Returns true if linked lists a and b are identical , otherwise false", "code": "bool areIdentical ( struct Node * a , struct Node * b ) { while ( a != NULL && b != NULL ) { if ( a -> data != b -> data ) return false ;"}
{"text": "If we reach here , then a and b are not NULL and their data is same , so move to next nodes in both lists", "code": "a = a -> next ; b = b -> next ; }"}
{"text": "If linked lists are identical , then ' a ' and ' b ' must be NULL at this point .", "code": "return ( a == NULL && b == NULL ) ; }"}
{"text": "Given a reference ( pointer to pointer ) to the head of a list and an int , push a new node on the front of the list .", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "allocate node put in the data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "link the old list off the new node", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "move the head to point to the new node", "code": "( * head_ref ) = new_node ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) {"}
{"text": "The constructed linked lists are : a : 3 -> 2 -> 1 b : 3 -> 2 -> 1", "code": "struct Node * a = NULL ; struct Node * b = NULL ; push ( & a , 1 ) ; push ( & a , 2 ) ; push ( & a , 3 ) ; push ( & b , 1 ) ; push ( & b , 2 ) ; push ( & b , 3 ) ; areIdentical ( a , b ) ? printf ( \" Identical \" ) : printf ( \" Not ▁ identical \" ) ; return 0 ; }"}
{"text": "A recursive C function to check if two linked lists are identical or not", "code": "bool areIdentical ( struct Node * a , struct Node * b ) {"}
{"text": "If both lists are empty", "code": "if ( a == NULL && b == NULL ) return true ;"}
{"text": "If both lists are not empty , then data of current nodes must match , and same should be recursively true for rest of the nodes .", "code": "if ( a != NULL && b != NULL ) return ( a -> data == b -> data ) && areIdentical ( a -> next , b -> next ) ;"}
{"text": "If we reach here , then one of the lists is empty and other is not", "code": "return false ; }"}
{"text": "C Program to sort a linked list 0 s , 1 s or 2 s", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Link list node", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Function to sort a linked list of 0 s , 1 s and 2 s", "code": "void sortList ( struct Node * head ) {"}
{"text": "Initialize count of '0' , '1' and '2' as 0", "code": "int count [ 3 ] = { 0 , 0 , 0 } ; struct Node * ptr = head ;"}
{"text": "count total number of '0' , '1' and '2' * count [ 0 ] will store total number of '0' s * count [ 1 ] will store total number of '1' s * count [ 2 ] will store total number of '2' s", "code": "while ( ptr != NULL ) { count [ ptr -> data ] += 1 ; ptr = ptr -> next ; } int i = 0 ; ptr = head ;"}
{"text": "Let say count [ 0 ] = n1 , count [ 1 ] = n2 and count [ 2 ] = n3 * now start traversing list from head node , * 1 ) fill the list with 0 , till n1 > 0 * 2 ) fill the list with 1 , till n2 > 0 * 3 ) fill the list with 2 , till n3 > 0", "code": "while ( ptr != NULL ) { if ( count [ i ] == 0 ) ++ i ; else { ptr -> data = i ; -- count [ i ] ; ptr = ptr -> next ; } } }"}
{"text": "Function to push a node", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "allocate node put in the data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "link the old list off the new node", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "move the head to point to the new node", "code": "( * head_ref ) = new_node ; }"}
{"text": "Function to print linked list", "code": "void printList ( struct Node * node ) { while ( node != NULL ) { printf ( \" % d ▁ \" , node -> data ) ; node = node -> next ; } printf ( \" n \" ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( void ) {"}
{"text": "Constructed Linked List is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 8 -> 9 -> null", "code": "struct Node * head = NULL ; push ( & head , 0 ) ; push ( & head , 1 ) ; push ( & head , 0 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; printf ( \" Linked ▁ List ▁ Before ▁ Sorting STRNEWLINE \" ) ; printList ( head ) ; sortList ( head ) ; printf ( \" Linked ▁ List ▁ After ▁ Sorting STRNEWLINE \" ) ; printList ( head ) ; return 0 ; }"}
{"text": "C program to rearrange a linked list in such a way that all odd positioned node are stored before all even positioned nodes", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "Linked List Node", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "A utility function to create a new node", "code": "Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; }"}
{"text": "Rearranges given linked list such that all even positioned nodes are before odd positioned . Returns new head of linked List .", "code": "Node * rearrangeEvenOdd ( Node * head ) {"}
{"text": "Corner case", "code": "if ( head == NULL ) return NULL ;"}
{"text": "Initialize first nodes of even and odd lists", "code": "Node * odd = head ; Node * even = head -> next ;"}
{"text": "Remember the first node of even list so that we can connect the even list at the end of odd list .", "code": "Node * evenFirst = even ; while ( 1 ) {"}
{"text": "If there are no more nodes , then connect first node of even list to the last node of odd list", "code": "if ( ! odd || ! even || ! ( even -> next ) ) { odd -> next = evenFirst ; break ; }"}
{"text": "Connecting odd nodes", "code": "odd -> next = even -> next ; odd = even -> next ;"}
{"text": "If there are NO more even nodes after current odd .", "code": "if ( odd -> next == NULL ) { even -> next = NULL ; odd -> next = evenFirst ; break ; }"}
{"text": "Connecting even nodes", "code": "even -> next = odd -> next ; even = odd -> next ; } return head ; }"}
{"text": "A utility function to print a linked list", "code": "void printlist ( Node * node ) { while ( node != NULL ) { cout << node -> data << \" - > \" ; node = node -> next ; } cout << \" NULL \" << endl ; }"}
{"text": "Driver code", "code": "int main ( void ) { Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; cout << \" Given ▁ Linked ▁ List STRNEWLINE \" ; printlist ( head ) ; head = rearrangeEvenOdd ( head ) ; cout << \" Modified Linked List \" ; printlist ( head ) ; return 0 ; }"}
{"text": "A C program to demonstrate deletion of last Node in singly linked list", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "A linked list Node", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Function to delete the last occurrence", "code": "void deleteLast ( struct Node * head , int x ) { struct Node * temp = head , * ptr = NULL ; while ( temp ) {"}
{"text": "If found key , update", "code": "if ( temp -> data == x ) ptr = temp ; temp = temp -> next ; }"}
{"text": "If the last occurrence is the last node", "code": "if ( ptr != NULL && ptr -> next == NULL ) { temp = head ; while ( temp -> next != ptr ) temp = temp -> next ; temp -> next = NULL ; }"}
{"text": "If it is not the last node", "code": "if ( ptr != NULL && ptr -> next != NULL ) { ptr -> data = ptr -> next -> data ; temp = ptr -> next ; ptr -> next = ptr -> next -> next ; free ( temp ) ; } }"}
{"text": "Utility function to create a new node with given key", "code": "struct Node * newNode ( int x ) { struct Node * node = malloc ( sizeof ( struct Node * ) ) ; node -> data = x ; node -> next = NULL ; return node ; }"}
{"text": "This function prints contents of linked list starting from the given Node", "code": "void display ( struct Node * head ) { struct Node * temp = head ; if ( head == NULL ) { printf ( \" NULL STRNEWLINE \" ) ; return ; } while ( temp != NULL ) { printf ( \" % d ▁ - - > ▁ \" , temp -> data ) ; temp = temp -> next ; } printf ( \" NULL STRNEWLINE \" ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { struct Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; head -> next -> next -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next -> next -> next = newNode ( 4 ) ; printf ( \" Created ▁ Linked ▁ list : ▁ \" ) ; display ( head ) ; deleteLast ( head , 4 ) ; printf ( \" List ▁ after ▁ deletion ▁ of ▁ 4 : ▁ \" ) ; display ( head ) ; return 0 ; }"}
{"text": "C program to check length of a given linklist", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Defining structure", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Function to check the length of linklist", "code": "int LinkedListLength ( struct Node * head ) { while ( head && head -> next ) { head = head -> next -> next ; } if ( ! head ) return 0 ; return 1 ; }"}
{"text": "Push function", "code": "void push ( struct Node * * head , int info ) {"}
{"text": "Allocating node", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Info into node", "code": "node -> data = info ;"}
{"text": "Next of new node to head", "code": "node -> next = ( * head ) ;"}
{"text": "head points to new node", "code": "( * head ) = node ; }"}
{"text": "Driver function", "code": "int main ( void ) { struct Node * head = NULL ;"}
{"text": "Adding elements to Linked List", "code": "push ( & head , 4 ) ; push ( & head , 5 ) ; push ( & head , 7 ) ; push ( & head , 2 ) ; push ( & head , 9 ) ; push ( & head , 6 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 0 ) ; push ( & head , 5 ) ; push ( & head , 5 ) ; int check = LinkedListLength ( head ) ;"}
{"text": "Checking for length of linklist", "code": "if ( check == 0 ) { printf ( \" Even STRNEWLINE \" ) ; } else { printf ( \" Odd STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "point to the last result pointer", "code": "struct Node * * lastPtrRef = & result ; while ( 1 ) { if ( a == NULL ) { * lastPtrRef = b ; break ; } else if ( b == NULL ) { * lastPtrRef = a ; break ; } if ( a -> data <= b -> data ) { MoveNode ( lastPtrRef , & a ) ; } else { MoveNode ( lastPtrRef , & b ) ; }"}
{"text": "tricky : advance to point to the next \" . next \" field", "code": "lastPtrRef = & ( ( * lastPtrRef ) -> next ) ; } return ( result ) ; }"}
{"text": "C program to make middle node as head of linked list .", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Link list node", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Function to get the middle and set at beginning of the linked list", "code": "void setMiddleHead ( struct Node * * head ) { if ( * head == NULL ) return ;"}
{"text": "To traverse list nodes one by one", "code": "struct Node * one_node = ( * head ) ;"}
{"text": "To traverse list nodes by skipping one .", "code": "struct Node * two_node = ( * head ) ;"}
{"text": "To keep track of previous of middle", "code": "struct Node * prev = NULL ; while ( two_node != NULL && two_node -> next != NULL ) {"}
{"text": "for previous node of middle node", "code": "prev = one_node ;"}
{"text": "move one node each time", "code": "two_node = two_node -> next -> next ;"}
{"text": "move two node each time", "code": "one_node = one_node -> next ; }"}
{"text": "set middle node at head", "code": "prev -> next = prev -> next -> next ; one_node -> next = ( * head ) ; ( * head ) = one_node ; }"}
{"text": "To insert a node at the beginning of linked list .", "code": "void push ( struct Node * * head_ref , int new_data ) {"}
{"text": "allocate node", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "link the old list off the new node", "code": "new_node -> next = ( * head_ref ) ;"}
{"text": "move the head to point to the new node", "code": "( * head_ref ) = new_node ; }"}
{"text": "A function to print a given linked list", "code": "void printList ( struct Node * ptr ) { while ( ptr != NULL ) { printf ( \" % d ▁ \" , ptr -> data ) ; ptr = ptr -> next ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Driver function", "code": "int main ( ) {"}
{"text": "Create a list of 5 nodes", "code": "struct Node * head = NULL ; int i ; for ( i = 5 ; i > 0 ; i -- ) push ( & head , i ) ; printf ( \" ▁ list ▁ before : ▁ \" ) ; printList ( head ) ; setMiddleHead ( & head ) ; printf ( \" ▁ list ▁ After : ▁ \" ) ; printList ( head ) ; return 0 ; }"}
{"text": "Given a node as prev_node , insert a new node after the given node", "code": "void insertAfter ( struct Node * prev_node , int new_data ) {"}
{"text": "1. check if the given prev_node is NULL", "code": "if ( prev_node == NULL ) { printf ( \" the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL \" ) ; return ; }"}
{"text": "2. allocate new node 3. put in the data", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ;"}
{"text": "4. Make next of new node as next of prev_node", "code": "new_node -> next = prev_node -> next ;"}
{"text": "5. Make the next of prev_node as new_node", "code": "prev_node -> next = new_node ;"}
{"text": "6. Make prev_node as previous of new_node", "code": "new_node -> prev = prev_node ;"}
{"text": "7. Change previous of new_node 's next node", "code": "if ( new_node -> next != NULL ) new_node -> next -> prev = new_node ; }"}
{"text": "C Implementation of Memory efficient Doubly Linked List", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <inttypes.h>"}
{"text": "Node structure of a memory efficient doubly linked list", "code": "struct Node { int data ; struct Node * npx ;"}
{"text": "XOR of next and previous node", "code": "} ;"}
{"text": "returns XORed value of the node addresses", "code": "struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; }"}
{"text": "Insert a node at the beginning of the XORed linked list and makes the newly inserted node as head", "code": "void insert ( struct Node * * head_ref , int data ) {"}
{"text": "Allocate memory for new node", "code": "struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = data ;"}
{"text": "Since new node is being inserted at the beginning , npx of new node will always be XOR of current head and NULL", "code": "new_node -> npx = * head_ref ;"}
{"text": "If linked list is not empty , then npx of current head node will be XOR of new node and node next to current head", "code": "if ( * head_ref != NULL ) {"}
{"text": "* ( head_ref ) -> npx is XOR of NULL and next . So if we do XOR of it with NULL , we get next", "code": "( * head_ref ) -> npx = XOR ( new_node , ( * head_ref ) -> npx ) ; }"}
{"text": "Change head", "code": "* head_ref = new_node ; }"}
{"text": "prints contents of doubly linked list in forward direction", "code": "void printList ( struct Node * head ) { struct Node * curr = head ; struct Node * prev = NULL ; struct Node * next ; printf ( \" Following ▁ are ▁ the ▁ nodes ▁ of ▁ Linked ▁ List : ▁ STRNEWLINE \" ) ; while ( curr != NULL ) {"}
{"text": "print current node", "code": "printf ( \" % d ▁ \" , curr -> data ) ;"}
{"text": "get address of next node : curr -> npx is next ^ prev , so curr -> npx ^ prev will be next ^ prev ^ prev which is next", "code": "next = XOR ( prev , curr -> npx ) ;"}
{"text": "update prev and curr for next iteration", "code": "prev = curr ; curr = next ; } }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Create following Doubly Linked List head -- > 40 < -- > 30 < -- > 20 < -- > 10", "code": "struct Node * head = NULL ; insert ( & head , 10 ) ; insert ( & head , 20 ) ; insert ( & head , 30 ) ; insert ( & head , 40 ) ;"}
{"text": "print the created list", "code": "printList ( head ) ; return ( 0 ) ; }"}
{"text": "A binary tree node has data , pointer to left child and a pointer to right child", "code": "struct node { int data ; struct node * left ; struct node * right ; } ; void printKDistant ( struct node * root , int k ) { if ( root == NULL k < 0 ) return ; if ( k == 0 ) { printf ( \" % d ▁ \" , root -> data ) ; return ; } printKDistant ( root -> left , k - 1 ) ; printKDistant ( root -> right , k - 1 ) ; }"}
{"text": "Helper function that allocates a new node with the given data and NULL left and right pointers .", "code": "struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Constructed binary tree is 1 / \\ 2 3 / \\ / 4 5 8", "code": "struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 8 ) ; printKDistant ( root , 2 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program to print binary tree in 2D", "code": "#include <stdio.h> NEW_LINE #include <malloc.h> NEW_LINE #define COUNT  10"}
{"text": "A binary tree node", "code": "struct Node { int data ; struct Node * left , * right ; } ;"}
{"text": "Helper function to allocates a new node", "code": "struct Node * newNode ( int data ) { struct Node * node = malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; }"}
{"text": "Function to print binary tree in 2D It does reverse inorder traversal", "code": "void print2DUtil ( struct Node * root , int space ) {"}
{"text": "Base case", "code": "if ( root == NULL ) return ;"}
{"text": "Increase distance between levels", "code": "space += COUNT ;"}
{"text": "Process right child first", "code": "print2DUtil ( root -> right , space ) ;"}
{"text": "Print current node after space count", "code": "printf ( \" STRNEWLINE \" ) ; for ( int i = COUNT ; i < space ; i ++ ) printf ( \" ▁ \" ) ; printf ( \" % d STRNEWLINE \" , root -> data ) ;"}
{"text": "Process left child", "code": "print2DUtil ( root -> left , space ) ; }"}
{"text": "Wrapper over print2DUtil ( )", "code": "void print2D ( struct Node * root ) {"}
{"text": "Pass initial space count as 0", "code": "print2DUtil ( root , 0 ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> left -> left = newNode ( 12 ) ; root -> right -> left -> right = newNode ( 13 ) ; root -> right -> right -> left = newNode ( 14 ) ; root -> right -> right -> right = newNode ( 15 ) ; print2D ( root ) ; return 0 ; }"}
{"text": "C program to print left view of Binary Tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ;"}
{"text": "A utility function to create a new Binary Tree node", "code": "struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; }"}
{"text": "Recursive function to print left view of a binary tree .", "code": "void leftViewUtil ( struct node * root , int level , int * max_level ) {"}
{"text": "Base Case", "code": "if ( root == NULL ) return ;"}
{"text": "If this is the first node of its level", "code": "if ( * max_level < level ) { printf ( \" % d TABSYMBOL \" , root -> data ) ; * max_level = level ; }"}
{"text": "Recur for left and right subtrees", "code": "leftViewUtil ( root -> left , level + 1 , max_level ) ; leftViewUtil ( root -> right , level + 1 , max_level ) ; }"}
{"text": "A wrapper over leftViewUtil ( )", "code": "void leftView ( struct node * root ) { int max_level = 0 ; leftViewUtil ( root , 1 , & max_level ) ; }"}
{"text": "Driver code", "code": "int main ( ) { struct node * root = newNode ( 12 ) ; root -> left = newNode ( 10 ) ; root -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 25 ) ; root -> right -> right = newNode ( 40 ) ; leftView ( root ) ; return 0 ; }"}
{"text": "C implementation of the approach", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Function to return the count of rotated strings which have more number of vowels in the first half than the second half", "code": "int cntRotations ( char s [ ] , int n ) { int lh = 0 , rh = 0 , i , ans = 0 ;"}
{"text": "Compute the number of vowels in first - half", "code": "for ( i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { lh ++ ; }"}
{"text": "Compute the number of vowels in second - half", "code": "for ( i = n / 2 ; i < n ; ++ i ) if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { rh ++ ; }"}
{"text": "Check if first - half has more vowels", "code": "if ( lh > rh ) ans ++ ;"}
{"text": "Check for all possible rotations", "code": "for ( i = 1 ; i < n ; ++ i ) { if ( s [ i - 1 ] == ' a ' s [ i - 1 ] == ' e ' s [ i - 1 ] == ' i ' s [ i - 1 ] == ' o ' s [ i - 1 ] == ' u ' ) { rh ++ ; lh -- ; } if ( s [ ( i - 1 + n / 2 ) % n ] == ' a ' || s [ ( i - 1 + n / 2 ) % n ] == ' e ' || s [ ( i - 1 + n / 2 ) % n ] == ' i ' || s [ ( i - 1 + n / 2 ) % n ] == ' o ' || s [ ( i - 1 + n / 2 ) % n ] == ' u ' ) { rh -- ; lh ++ ; } if ( lh > rh ) ans ++ ; }"}
{"text": "Return the answer", "code": "return ans ; }"}
{"text": "Driver code", "code": "int main ( ) { char s [ ] = \" abecidft \" ; int n = strlen ( s ) ;"}
{"text": "Function call", "code": "printf ( \" % d \" , cntRotations ( s , n ) ) ; return 0 ; }"}
{"text": "C program to rotate a linked list block wise", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Link list node", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Recursive function to rotate one block", "code": "struct Node * rotateHelper ( struct Node * blockHead , struct Node * blockTail , int d , struct Node * * tail , int k ) { if ( d == 0 ) return blockHead ;"}
{"text": "Rotate Clockwise", "code": "if ( d > 0 ) { struct Node * temp = blockHead ; for ( int i = 1 ; temp -> next -> next && i < k - 1 ; i ++ ) temp = temp -> next ; blockTail -> next = blockHead ; * tail = temp ; return rotateHelper ( blockTail , temp , d - 1 , tail , k ) ; }"}
{"text": "Rotate anti - Clockwise", "code": "if ( d < 0 ) { blockTail -> next = blockHead ; * tail = blockHead ; return rotateHelper ( blockHead -> next , blockHead , d + 1 , tail , k ) ; } }"}
{"text": "Function to rotate the linked list block wise", "code": "struct Node * rotateByBlocks ( struct Node * head , int k , int d ) {"}
{"text": "If length is 0 or 1 return head", "code": "if ( ! head ! head -> next ) return head ;"}
{"text": "if degree of rotation is 0 , return head", "code": "if ( d == 0 ) return head ; struct Node * temp = head , * tail = NULL ;"}
{"text": "Traverse upto last element of this block", "code": "int i ; for ( i = 1 ; temp -> next && i < k ; i ++ ) temp = temp -> next ;"}
{"text": "storing the first node of next block", "code": "struct Node * nextBlock = temp -> next ;"}
{"text": "If nodes of this block are less than k . Rotate this block also", "code": "if ( i < k ) head = rotateHelper ( head , temp , d % k , & tail , i ) ; else head = rotateHelper ( head , temp , d % k , & tail , k ) ;"}
{"text": "Append the new head of next block to the tail of this block", "code": "tail -> next = rotateByBlocks ( nextBlock , k , d % k ) ;"}
{"text": "return head of updated Linked List", "code": "return head ; }"}
{"text": "Function to push a node", "code": "void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; }"}
{"text": "Function to print linked list", "code": "void printList ( struct Node * node ) { while ( node != NULL ) { printf ( \" % d ▁ \" , node -> data ) ; node = node -> next ; } }"}
{"text": "Driver program to test above function", "code": "int main ( ) {"}
{"text": "Start with the empty list", "code": "struct Node * head = NULL ;"}
{"text": "create a list 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> NULL", "code": "for ( int i = 9 ; i > 0 ; i -= 1 ) push ( & head , i ) ; printf ( \" Given ▁ linked ▁ list ▁ STRNEWLINE \" ) ; printList ( head ) ;"}
{"text": "k is block size and d is number of rotations in every block .", "code": "int k = 3 , d = 2 ; head = rotateByBlocks ( head , k , d ) ; printf ( \" Rotated by blocks Linked list \" printList ( head ) ; return ( 0 ) ; }"}
{"text": "Function to delete First node of Circular Linked List", "code": "void DeleteFirst ( struct Node * * head ) { struct Node * previous = * head , * firstNode = * head ;"}
{"text": "check if list doesn 't have any node  if not then return", "code": "if ( * head == NULL ) { printf ( \" List is empty \" return ; }"}
{"text": "check if list have single node if yes then delete it and return", "code": "if ( previous -> next == previous ) { * head = NULL ; return ; }"}
{"text": "traverse second node to first", "code": "while ( previous -> next != * head ) { previous = previous -> next ; }"}
{"text": "now previous is last node and first node ( firstNode ) link address put in last node ( previous ) link", "code": "previous -> next = firstNode -> next ;"}
{"text": "make second node as head node", "code": "* head = previous -> next ; free ( firstNode ) ; return ; }"}
{"text": "Function delete last node of Circular Linked List", "code": "void DeleteLast ( struct Node * * head ) { struct Node * current = * head , * temp = * head , * previous ;"}
{"text": "check if list doesn 't have any node  if not then return", "code": "if ( * head == NULL ) { printf ( \" List is empty \" return ; }"}
{"text": "check if list have single node if yes then delete it and return", "code": "if ( current -> next == current ) { * head = NULL ; return ; }"}
{"text": "move first node to last previous", "code": "while ( current -> next != * head ) { previous = current ; current = current -> next ; } previous -> next = current -> next ; * head = previous -> next ; free ( current ) ; return ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Dimensions of the matrix", "code": "const int N = 5 ;"}
{"text": "Structure of a memory efficient matrix", "code": "struct Matrix { int * A ; int size ; } ;"}
{"text": "Function to set the values in the Matrix", "code": "void Set ( struct Matrix * m , int i , int j , int x ) { if ( i >= j ) m -> A [ ( ( m -> size ) * ( j - 1 ) - ( ( ( j - 2 ) * ( j - 1 ) ) / 2 ) + ( i - j ) ) ] = x ; }"}
{"text": "Function to store the values in the Matrix", "code": "int Get ( struct Matrix m , int i , int j ) { if ( i >= j ) return m . A [ ( ( m . size ) * ( j - 1 ) - ( ( ( j - 2 ) * ( j - 1 ) ) / 2 ) + ( i - j ) ) ] ; else return 0 ; }"}
{"text": "Function to display the elements of the matrix", "code": "void Display ( struct Matrix m ) {"}
{"text": "Traverse the matrix", "code": "for ( int i = 1 ; i <= m . size ; i ++ ) { for ( int j = 1 ; j <= m . size ; j ++ ) { if ( i >= j ) printf ( \" % d ▁ \" , m . A [ ( ( m . size ) * ( j - 1 ) - ( ( ( j - 2 ) * ( j - 1 ) ) / 2 ) + ( i - j ) ) ] ) ; else printf ( \"0 ▁ \" ) ; } printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Function to generate an efficient matrix", "code": "struct Matrix createMat ( int Mat [ N ] [ N ] ) {"}
{"text": "Declare efficient Matrix", "code": "struct Matrix mat ;"}
{"text": "Initialize the Matrix", "code": "mat . size = N ; mat . A = ( int * ) malloc ( mat . size * ( mat . size + 1 ) / 2 * sizeof ( int ) ) ;"}
{"text": "Set the values in matrix", "code": "for ( int i = 1 ; i <= mat . size ; i ++ ) { for ( int j = 1 ; j <= mat . size ; j ++ ) { Set ( & mat , i , j , Mat [ i - 1 ] [ j - 1 ] ) ; } }"}
{"text": "Return the matrix", "code": "return mat ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given Input", "code": "int Mat [ 5 ] [ 5 ] = { { 1 , 0 , 0 , 0 , 0 } , { 1 , 2 , 0 , 0 , 0 } , { 1 , 2 , 3 , 0 , 0 } , { 1 , 2 , 3 , 4 , 0 } , { 1 , 2 , 3 , 4 , 5 } } ;"}
{"text": "Function call to create a memory efficient matrix", "code": "struct Matrix mat = createMat ( Mat ) ;"}
{"text": "Function call to print the Matrix", "code": "Display ( mat ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h>"}
{"text": "Function to count subarrays in which sum of elements at even and odd positions are equal", "code": "void countSubarrays ( int arr [ ] , int n ) {"}
{"text": "Initialize variables", "code": "int count = 0 ;"}
{"text": "Iterate over the array", "code": "for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) {"}
{"text": "Check if position is even then add to sum then add it to sum", "code": "if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ;"}
{"text": "Else subtract it to sum", "code": "else sum -= arr [ j ] ;"}
{"text": "Increment the count if the sum equals 0", "code": "if ( sum == 0 ) count ++ ; } }"}
{"text": "Print the count of subarrays", "code": "printf ( \" % d \" , count ) ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given array arr [ ]", "code": "int arr [ ] = { 2 , 4 , 6 , 4 , 2 } ;"}
{"text": "Size of the array", "code": "int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Function call", "code": "countSubarrays ( arr , n ) ; return 0 ; }"}
{"text": "An example of tail recursive function", "code": "void print ( int n ) { if ( n < 0 ) return ; cout << \" ▁ \" << n ;"}
{"text": "The last executed statement is recursive call", "code": "print ( n - 1 ) ; }"}
{"text": "C program to implement the above approach", "code": "#include <stdio.h>"}
{"text": "Function to print Alternate elements of the given array", "code": "void printAlter ( int arr [ ] , int N ) {"}
{"text": "Print elements at odd positions", "code": "for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) {"}
{"text": "If currIndex stores even index or odd position", "code": "if ( currIndex % 2 == 0 ) { printf ( \" % d ▁ \" , arr [ currIndex ] ) ; } } }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAlter ( arr , N ) ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h>"}
{"text": "Function to reverse the array from the position ' start ' to position ' end '", "code": "void reverse ( int arr [ ] , int start , int end ) {"}
{"text": "Stores mid of start and end", "code": "int mid = ( end - start + 1 ) / 2 ;"}
{"text": "Traverse the array in the range [ start , end ]", "code": "for ( int i = 0 ; i < mid ; i ++ ) {"}
{"text": "Stores arr [ start + i ]", "code": "int temp = arr [ start + i ] ;"}
{"text": "Update arr [ start + i ]", "code": "arr [ start + i ] = arr [ end - i ] ;"}
{"text": "Update arr [ end - i ]", "code": "arr [ end - i ] = temp ; } return ; }"}
{"text": "Utility function to shuffle the given array in the of form { a1 , b1 , a2 , b2 , ... . an , bn }", "code": "void shuffleArrayUtil ( int arr [ ] , int start , int end ) { int i ;"}
{"text": "Stores the length of the array", "code": "int l = end - start + 1 ;"}
{"text": "If length of the array is 2", "code": "if ( l == 2 ) return ;"}
{"text": "Stores mid of the { start , end }", "code": "int mid = start + l / 2 ;"}
{"text": "Divide array into two halves of even length", "code": "if ( l % 4 ) {"}
{"text": "Update mid", "code": "mid -= 1 ; }"}
{"text": "Calculate the mid - points of both halves of the array", "code": "int mid1 = start + ( mid - start ) / 2 ; int mid2 = mid + ( end + 1 - mid ) / 2 ;"}
{"text": "Reverse the subarray made from mid1 to mid2", "code": "reverse ( arr , mid1 , mid2 - 1 ) ;"}
{"text": "Reverse the subarray made from mid1 to mid", "code": "reverse ( arr , mid1 , mid - 1 ) ;"}
{"text": "Reverse the subarray made from mid to mid2", "code": "reverse ( arr , mid , mid2 - 1 ) ;"}
{"text": "Recursively calls for both the halves of the array", "code": "shuffleArrayUtil ( arr , start , mid - 1 ) ; shuffleArrayUtil ( arr , mid , end ) ; }"}
{"text": "Function to shuffle the given array in the form of { a1 , b1 , a2 , b2 , ... . an , bn }", "code": "void shuffleArray ( int arr [ ] , int N , int start , int end ) {"}
{"text": "Function Call", "code": "shuffleArrayUtil ( arr , start , end ) ;"}
{"text": "Print the modified array", "code": "for ( int i = 0 ; i < N ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given array", "code": "int arr [ ] = { 1 , 3 , 5 , 2 , 4 , 6 } ;"}
{"text": "Size of the array", "code": "int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Shuffles the given array to the required permutation", "code": "shuffleArray ( arr , N , 0 , N - 1 ) ; return 0 ; }"}
{"text": "C implementation to check if two arrays can be made equal", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE int sort ( int a [ ] , int n ) { int i , j , tmp ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] < a [ i ] ) { tmp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tmp ; } } } return 0 ; }"}
{"text": "Function to check if array B can be made equal to array A", "code": "int canMadeEqual ( int A [ ] , int B [ ] , int n ) { int i ;"}
{"text": "Sort both arrays", "code": "sort ( A , n ) ; sort ( B , n ) ;"}
{"text": "Check both arrays equal or not", "code": "for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != B [ i ] ) { return ( 0 ) ; } } return ( 1 ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int n ; int B [ ] = { 1 , 3 , 2 } ; n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( canMadeEqual ( A , B , n ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } return 0 ; }"}
{"text": "C program to sort Linked List using Bubble Sort by swapping nodes", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "structure for a node", "code": "struct Node { int data ; struct Node * next ; } Node ;"}
{"text": "Function to swap the nodes", "code": "struct Node * swap ( struct Node * ptr1 , struct Node * ptr2 ) { struct Node * tmp = ptr2 -> next ; ptr2 -> next = ptr1 ; ptr1 -> next = tmp ; return ptr2 ; }"}
{"text": "Function to sort the list", "code": "int bubbleSort ( struct Node * * head , int count ) { struct Node * * h ; int i , j , swapped ; for ( i = 0 ; i <= count ; i ++ ) { h = head ; swapped = 0 ; for ( j = 0 ; j < count - i - 1 ; j ++ ) { struct Node * p1 = * h ; struct Node * p2 = p1 -> next ; if ( p1 -> data > p2 -> data ) {"}
{"text": "update the link after swapping", "code": "* h = swap ( p1 , p2 ) ; swapped = 1 ; } h = & ( * h ) -> next ; }"}
{"text": "break if the loop ended without any swap", "code": "if ( swapped == 0 ) break ; } }"}
{"text": "Function to print the list", "code": "void printList ( struct Node * n ) { while ( n != NULL ) { printf ( \" % d ▁ - > ▁ \" , n -> data ) ; n = n -> next ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Function to insert a struct Node at the beginning of a linked list", "code": "void insertAtTheBegin ( struct Node * * start_ref , int data ) { struct Node * ptr1 = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; ptr1 -> data = data ; ptr1 -> next = * start_ref ; * start_ref = ptr1 ; }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ ] = { 78 , 20 , 10 , 32 , 1 , 5 } ; int list_size , i ;"}
{"text": "start with empty linked list", "code": "struct Node * start = NULL ; list_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Create linked list from the array arr [ ]", "code": "for ( i = 0 ; i < list_size ; i ++ ) insertAtTheBegin ( & start , arr [ i ] ) ;"}
{"text": "print list before sorting", "code": "printf ( \" Linked ▁ list ▁ before ▁ sorting STRNEWLINE \" ) ; printList ( start ) ;"}
{"text": "sort the linked list", "code": "bubbleSort ( & start , list_size ) ;"}
{"text": "print list after sorting", "code": "printf ( \" Linked ▁ list ▁ after ▁ sorting STRNEWLINE \" ) ; printList ( start ) ; return 0 ; }"}
{"text": "C ++ program in - place Merge Sort", "code": "#include <stdio.h>"}
{"text": "Merges two subarrays of arr [ ] . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ] Inplace Implementation", "code": "void merge ( int arr [ ] , int start , int mid , int end ) { int start2 = mid + 1 ;"}
{"text": "If the direct merge is already sorted", "code": "if ( arr [ mid ] <= arr [ start2 ] ) { return ; }"}
{"text": "Two pointers to maintain start of both arrays to merge", "code": "while ( start <= mid && start2 <= end ) {"}
{"text": "If element 1 is in right place", "code": "if ( arr [ start ] <= arr [ start2 ] ) { start ++ ; } else { int value = arr [ start2 ] ; int index = start2 ;"}
{"text": "Shift all the elements between element 1 element 2 , right by 1.", "code": "while ( index != start ) { arr [ index ] = arr [ index - 1 ] ; index -- ; } arr [ start ] = value ;"}
{"text": "Update all the pointers", "code": "start ++ ; mid ++ ; start2 ++ ; } } }"}
{"text": "l is for left index and r is right index of the sub - array of arr to be sorted", "code": "void mergeSort ( int arr [ ] , int l , int r ) { if ( l < r ) {"}
{"text": "Same as ( l + r ) / 2 , but avoids overflow for large l and r", "code": "int m = l + ( r - l ) / 2 ;"}
{"text": "Sort first and second halves", "code": "mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } }"}
{"text": "Function to print an array", "code": "void printArray ( int A [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , A [ i ] ) ; printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; mergeSort ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; return 0 ; }"}
{"text": "C program to implement dual pivot QuickSort", "code": "#include <stdio.h> NEW_LINE int partition ( int * arr , int low , int high , int * lp ) ; void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } void DualPivotQuickSort ( int * arr , int low , int high ) { if ( low < high ) {"}
{"text": "lp means left pivot , and rp means right pivot .", "code": "int lp , rp ; rp = partition ( arr , low , high , & lp ) ; DualPivotQuickSort ( arr , low , lp - 1 ) ; DualPivotQuickSort ( arr , lp + 1 , rp - 1 ) ; DualPivotQuickSort ( arr , rp + 1 , high ) ; } } int partition ( int * arr , int low , int high , int * lp ) { if ( arr [ low ] > arr [ high ] ) swap ( & arr [ low ] , & arr [ high ] ) ;"}
{"text": "p is the left pivot , and q is the right pivot .", "code": "int j = low + 1 ; int g = high - 1 , k = low + 1 , p = arr [ low ] , q = arr [ high ] ; while ( k <= g ) {"}
{"text": "if elements are less than the left pivot", "code": "if ( arr [ k ] < p ) { swap ( & arr [ k ] , & arr [ j ] ) ; j ++ ; }"}
{"text": "if elements are greater than or equal to the right pivot", "code": "else if ( arr [ k ] >= q ) { while ( arr [ g ] > q && k < g ) g -- ; swap ( & arr [ k ] , & arr [ g ] ) ; g -- ; if ( arr [ k ] < p ) { swap ( & arr [ k ] , & arr [ j ] ) ; j ++ ; } } k ++ ; } j -- ; g ++ ;"}
{"text": "bring pivots to their appropriate positions .", "code": "swap ( & arr [ low ] , & arr [ j ] ) ; swap ( & arr [ high ] , & arr [ g ] ) ;"}
{"text": "returning the indices of the pivots . * lp = j ; because we cannot return two elements from a function .", "code": "return g ; }"}
{"text": "Driver code", "code": "int main ( ) { int arr [ ] = { 24 , 8 , 42 , 75 , 29 , 77 , 38 , 57 } ; DualPivotQuickSort ( arr , 0 , 7 ) ; printf ( \" Sorted ▁ array : ▁ \" ) ; for ( int i = 0 ; i < 8 ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; return 0 ; }"}
{"text": "C program to implement the above approach", "code": "#include <stdio.h>"}
{"text": "Function to construct the simple and connected graph such that the distance between exactly K pairs of vertices is 2", "code": "void constGraphWithCon ( int N , int K ) {"}
{"text": "Stores maximum possible count of edges in a graph", "code": "int Max = ( ( N - 1 ) * ( N - 2 ) ) / 2 ;"}
{"text": "Base Case", "code": "if ( K > Max ) { printf ( \" - 1\" ) ; return ; }"}
{"text": "Stores count of edges in a graph", "code": "int count = 0 ;"}
{"text": "Connect all vertices of pairs ( i , j )", "code": "for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { printf ( \" % d ▁ % d STRNEWLINE \" , i , j ) ;"}
{"text": "Update", "code": "count ++ ; if ( count == N * ( N - 1 ) / 2 - K ) break ; } if ( count == N * ( N - 1 ) / 2 - K ) break ; } }"}
{"text": "Driver Code", "code": "int main ( ) { int N = 5 , K = 3 ; constGraphWithCon ( N , K ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h>"}
{"text": "Function to find N integers having Bitwise XOR equal to K", "code": "void findArray ( int N , int K ) {"}
{"text": "Base Cases", "code": "if ( N == 1 ) { printf ( \" % d \" , K ) ; return ; } if ( N == 2 ) { printf ( \" % d ▁ % d \" , 0 , K ) ; return ; }"}
{"text": "Assign values to P and Q", "code": "int P = N - 2 ; int Q = N - 1 ;"}
{"text": "Stores Bitwise XOR of the first ( N - 3 ) elements", "code": "int VAL = 0 ;"}
{"text": "Print the first N - 3 elements", "code": "for ( int i = 1 ; i <= ( N - 3 ) ; i ++ ) { printf ( \" % d ▁ \" , i ) ;"}
{"text": "Calculate Bitwise XOR of first ( N - 3 ) elements", "code": "VAL ^= i ; } if ( VAL == K ) { printf ( \" % d ▁ % d ▁ % d \" , P , Q , P ^ Q ) ; } else { printf ( \" % d ▁ % d ▁ % d \" , 0 , P , P ^ K ^ VAL ) ; } }"}
{"text": "Driver Code", "code": "int main ( ) { int N = 4 , X = 6 ;"}
{"text": "Function Call", "code": "findArray ( N , X ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Function to count the number of N - digit numbers such that sum of every k consecutive digits are equal", "code": "int countDigitSum ( int N , int K ) {"}
{"text": "Range of numbers", "code": "int l = ( int ) pow ( 10 , N - 1 ) , r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ;"}
{"text": "Extract digits of the number", "code": "int digits [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ;"}
{"text": "Store the sum of first K digits", "code": "for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ;"}
{"text": "Check for every k - consecutive digits", "code": "for ( int j = 1 ; j < N - K + 1 ; j ++ ) { int curr_sum = 0 ; for ( int m = j ; m < j + K ; m ++ ) curr_sum += digits [ m ] ;"}
{"text": "If sum is not equal then break the loop", "code": "if ( sum != curr_sum ) { flag = 1 ; break ; } }"}
{"text": "Increment the count if it satisfy the given condition", "code": "if ( flag == 0 ) { count ++ ; } } return count ; }"}
{"text": "Driver code", "code": "int main ( ) {"}
{"text": "Given N and K", "code": "int N = 2 , K = 1 ;"}
{"text": "Function call", "code": "printf ( \" % d \" , countDigitSum ( N , K ) ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Function to convert string to integer without using functions", "code": "void convert ( char s [ ] ) {"}
{"text": "Initialize a variable", "code": "int num = 0 ; int n = strlen ( s ) ;"}
{"text": "Iterate till length of the string", "code": "for ( int i = 0 ; i < n ; i ++ )"}
{"text": "Subtract 48 from the current digit", "code": "num = num * 10 + ( s [ i ] - 48 ) ;"}
{"text": "Print the answer", "code": "printf ( \" % d \" , num ) ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given string of number", "code": "char s [ ] = \"123\" ;"}
{"text": "Function Call", "code": "convert ( s ) ; return 0 ; }"}
{"text": "The function returns true if there exist three elements in AP Assumption : set [ 0. . n - 1 ] is sorted . The code strictly implements the algorithm provided in the reference .", "code": "bool arithmeticThree ( int set [ ] , int n ) {"}
{"text": "One by fix every element as middle element", "code": "for ( int j = 1 ; j < n - 1 ; j ++ ) {"}
{"text": "Initialize i and k for the current j", "code": "int i = j - 1 , k = j + 1 ;"}
{"text": "Find if there exist i and k that form AP with j as middle element", "code": "while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] == 2 * set [ j ] ) return true ; ( set [ i ] + set [ k ] < 2 * set [ j ] ) ? k ++ : i -- ; } } return false ; }"}
{"text": "Dynamic Programming implementation of Maximum Sum Increasing Subsequence ( MSIS ) problem", "code": "#include <stdio.h>"}
{"text": "maxSumIS ( ) returns the maximum sum of increasing subsequence in arr [ ] of size n", "code": "int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ n ] ;"}
{"text": "Initialize msis values for all indexes", "code": "for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ;"}
{"text": "Compute maximum sum values in bottom up manner", "code": "for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ;"}
{"text": "Pick maximum of all msis values", "code": "for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ ] = { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Sum ▁ of ▁ maximum ▁ sum ▁ increasing ▁ \" \" subsequence ▁ is ▁ % d STRNEWLINE \" , maxSumIS ( arr , n ) ) ; return 0 ; }"}
{"text": "A Naive C recursive implementation of LIS problem", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "To make use of recursive calls , this function must return two things : 1 ) Length of LIS ending with element arr [ n - 1 ] . We use max_ending_here for this purpose 2 ) Overall maximum as the LIS may end with an element before arr [ n - 1 ] max_ref is used this purpose . The value of LIS of full array of size n is stored in * max_ref which is our final result", "code": "int _lis ( int arr [ ] , int n , int * max_ref ) {"}
{"text": "Base case", "code": "if ( n == 1 ) return 1 ;"}
{"text": "' max _ ending _ here ' is length of LIS ending with arr [ n - 1 ]", "code": "int res , max_ending_here = 1 ;"}
{"text": "Recursively get all LIS ending with arr [ 0 ] , arr [ 1 ] ... arr [ n - 2 ] . If arr [ i - 1 ] is smaller than arr [ n - 1 ] , and max ending with arr [ n - 1 ] needs to be updated , then update it", "code": "for ( int i = 1 ; i < n ; i ++ ) { res = _lis ( arr , i , max_ref ) ; if ( arr [ i - 1 ] < arr [ n - 1 ] && res + 1 > max_ending_here ) max_ending_here = res + 1 ; }"}
{"text": "Compare max_ending_here with the overall max . And update the overall max if needed", "code": "if ( * max_ref < max_ending_here ) * max_ref = max_ending_here ;"}
{"text": "Return length of LIS ending with arr [ n - 1 ]", "code": "return max_ending_here ; }"}
{"text": "The wrapper function for _lis ( )", "code": "int lis ( int arr [ ] , int n ) {"}
{"text": "The max variable holds the result", "code": "int max = 1 ;"}
{"text": "The function _lis ( ) stores its result in max", "code": "_lis ( arr , n , & max ) ;"}
{"text": "returns max", "code": "return max ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Length ▁ of ▁ lis ▁ is ▁ % d STRNEWLINE \" , lis ( arr , n ) ) ; return 0 ; }"}
{"text": "a simple recursive program for Fibonacci numbers", "code": "int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }"}
{"text": "C code for finding count of string in a given 2D character array .", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #include <stdlib.h> NEW_LINE #define ARRAY_SIZE ( a )  (sizeof(a) / sizeof(*a))"}
{"text": "utility function to search complete string from any given index of 2d char array", "code": "int internalSearch ( char * needle , int row , int col , char * * hay , int row_max , int col_max ) { int found = 0 ; if ( row >= 0 && row <= row_max && col >= 0 && col <= col_max && * needle == hay [ row ] [ col ] ) { char match = * needle ++ ; hay [ row ] [ col ] = 0 ; if ( * needle == 0 ) { found = 1 ; } else {"}
{"text": "through Backtrack searching in every directions", "code": "found += internalSearch ( needle , row , col + 1 , hay , row_max , col_max ) ; found += internalSearch ( needle , row , col - 1 , hay , row_max , col_max ) ; found += internalSearch ( needle , row + 1 , col , hay , row_max , col_max ) ; found += internalSearch ( needle , row - 1 , col , hay , row_max , col_max ) ; } hay [ row ] [ col ] = match ; } return found ; }"}
{"text": "Function to search the string in 2d array", "code": "int searchString ( char * needle , int row , int col , char * * str , int row_count , int col_count ) { int found = 0 ; int r , c ; for ( r = 0 ; r < row_count ; ++ r ) { for ( c = 0 ; c < col_count ; ++ c ) { found += internalSearch ( needle , r , c , str , row_count - 1 , col_count - 1 ) ; } } return found ; }"}
{"text": "Driver code", "code": "int main ( void ) { char needle [ ] = \" MAGIC \" ; char * input [ ] = { \" BBABBM \" , \" CBMBBA \" , \" IBABBG \" , \" GOZBBI \" , \" ABBBBC \" , \" MCIGAM \" } ; char * str [ ARRAY_SIZE ( input ) ] ; int i ; for ( i = 0 ; i < ARRAY_SIZE ( input ) ; ++ i ) { str [ i ] = malloc ( strlen ( input [ i ] ) ) ; strcpy ( str [ i ] , input [ i ] ) ; } printf ( \" count : ▁ % d STRNEWLINE \" , searchString ( needle , 0 , 0 , str , ARRAY_SIZE ( str ) , strlen ( str [ 0 ] ) ) ) ; return 0 ; }"}
{"text": "C program of the above approach", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h>"}
{"text": "Function to check if parentheses are balanced", "code": "bool isBalanced ( char exp [ ] ) {"}
{"text": "Initialising Variables", "code": "bool flag = true ; int count = 0 ;"}
{"text": "Traversing the Expression", "code": "for ( int i = 0 ; exp [ i ] != ' \\0' ; i ++ ) { if ( exp [ i ] == ' ( ' ) { count ++ ; } else {"}
{"text": "It is a closing parenthesis", "code": "count -- ; } if ( count < 0 ) {"}
{"text": "This means there are more Closing parenthesis than opening ones", "code": "flag = false ; break ; } }"}
{"text": "If count is not zero , It means there are more opening parenthesis", "code": "if ( count != 0 ) { flag = false ; } return flag ; }"}
{"text": "Driver code", "code": "int main ( ) { char exp1 [ ] = \" ( ( ( ) ) ) ( ) ( ) \" ; if ( isBalanced ( exp1 ) ) printf ( \" Balanced ▁ STRNEWLINE \" ) ; else printf ( \" Not ▁ Balanced ▁ STRNEWLINE \" ) ; char exp2 [ ] = \" ( ) ) ( ( ( ) ) \" ; if ( isBalanced ( exp2 ) ) printf ( \" Balanced ▁ STRNEWLINE \" ) ; else printf ( \" Not ▁ Balanced ▁ STRNEWLINE \" ) ; return 0 ; }"}
{"text": "C implementation of above approach", "code": "#include <stdio.h> NEW_LINE #define MAX_SIZE  100"}
{"text": "Function to return required vector of distances", "code": "void shortestToChar ( char s [ ] , char c , int * res ) {"}
{"text": "list to hold position of c in s", "code": "int list [ MAX_SIZE ] ;"}
{"text": "length of string", "code": "int len = 0 ;"}
{"text": "To hold size of list", "code": "int l = 0 ;"}
{"text": "Iterate over string to create list", "code": "while ( s [ len ] != ' \\0' ) { if ( s [ len ] == c ) { list [ l ] = len ; l ++ ; } len ++ ; } int p1 , p2 , v1 , v2 ;"}
{"text": "max value of p2", "code": "l = l - 1 ;"}
{"text": "Initialize the pointers", "code": "p1 = 0 ; p2 = l > 0 ? 1 : 0 ;"}
{"text": "Create result array", "code": "for ( int i = 0 ; i < len ; i ++ ) {"}
{"text": "Values at current pointers", "code": "v1 = list [ p1 ] ; v2 = list [ p2 ] ;"}
{"text": "Current Index is before than p1", "code": "if ( i <= v1 ) { res [ i ] = ( v1 - i ) ; }"}
{"text": "Current Index is between p1 and p2", "code": "else if ( i <= v2 ) {"}
{"text": "Current Index is nearer to p1", "code": "if ( i - v1 < v2 - i ) { res [ i ] = ( i - v1 ) ; }"}
{"text": "Current Index is nearer to p2", "code": "else { res [ i ] = ( v2 - i ) ;"}
{"text": "Move pointer 1 step ahead", "code": "p1 = p2 ; p2 = p2 < l ? ( p2 + 1 ) : p2 ; } }"}
{"text": "Current index is after p2", "code": "else { res [ i ] = ( i - v2 ) ; } } }"}
{"text": "Driver code", "code": "int main ( ) { char s [ ] = \" geeksforgeeks \" ; char c = ' e ' ; int res [ MAX_SIZE ] ; shortestToChar ( s , c , res ) ; int i = 0 ; while ( s [ i ] != ' \\0' ) printf ( \" % d ▁ \" , res [ i ++ ] ) ; return 0 ; }"}
{"text": "C program to reverse string according to the number of words", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "Reverse the letters of the word", "code": "void reverse ( char str [ ] , int start , int end ) {"}
{"text": "Temporary variable to store character", "code": "char temp ; while ( start <= end ) {"}
{"text": "Swapping the first and last character", "code": "temp = str [ start ] ; str [ start ] = str [ end ] ; str [ end ] = temp ; start ++ ; end -- ; } }"}
{"text": "This function forms the required string", "code": "void reverseletter ( char str [ ] , int start , int end ) { int wstart , wend ; for ( wstart = wend = start ; wend < end ; wend ++ ) { if ( str [ wend ] == ' ▁ ' ) continue ;"}
{"text": "Checking the number of words present in string to reverse", "code": "while ( str [ wend ] != ' ▁ ' && wend <= end ) wend ++ ; wend -- ;"}
{"text": "Reverse the letter of the words", "code": "reverse ( str , wstart , wend ) ; } }"}
{"text": "Driver Code", "code": "int main ( ) { char str [ 1000 ] = \" Ashish ▁ Yadav ▁ Abhishek ▁ Rajput ▁ Sunil ▁ Pundir \" ; reverseletter ( str , 0 , strlen ( str ) - 1 ) ; printf ( \" % s \" , str ) ; return 0 ; }"}
{"text": "C program to get toggle case of a string", "code": "#include <stdio.h>"}
{"text": "tOGGLE cASE = swaps CAPS to lower case and lower case to CAPS", "code": "char * toggleCase ( char * a ) { for ( int i = 0 ; a [ i ] != ' \\0' ; i ++ ) {"}
{"text": "Bitwise EXOR with 32", "code": "a [ i ] ^= 32 ; } return a ; }"}
{"text": "Driver Code", "code": "int main ( ) { char str [ ] = \" CheRrY \" ; printf ( \" Toggle ▁ case : ▁ % s STRNEWLINE \" , toggleCase ( str ) ) ; printf ( \" Original ▁ string : ▁ % s \" , toggleCase ( str ) ) ; return 0 ; }"}
{"text": "implementation of strcmp that ignores cases", "code": "int ic_strcmp ( char * s1 , char * s2 ) { int i ; for ( i = 0 ; s1 [ i ] && s2 [ i ] ; ++ i ) {"}
{"text": "If characters are same or inverting the 6 th bit makes them same", "code": "if ( s1 [ i ] == s2 [ i ] || ( s1 [ i ] ^ 32 ) == s2 [ i ] ) continue ; else break ; }"}
{"text": "Compare the last ( or first mismatching in case of not same ) characters", "code": "if ( s1 [ i ] == s2 [ i ] ) return 0 ;"}
{"text": "Set the 6 th bit in both , then compare", "code": "if ( ( s1 [ i ] 32 ) < ( s2 [ i ] 32 ) ) return -1 ; return 1 ; }"}
{"text": "Driver program to test above function", "code": "int main ( void ) { printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" Geeks \" , \" apple \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" \" , \" ABCD \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" ABCD \" , \" z \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" ABCD \" , \" abcdEghe \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" GeeksForGeeks \" , \" gEEksFORGeEKs \" ) ) ; printf ( \" ret : ▁ % d STRNEWLINE \" , ic_strcmp ( \" GeeksForGeeks \" , \" geeksForGeeks \" ) ) ; return 0 ; }"}
{"text": "C program to check if two strings are anagrams of each other", "code": "#include <stdio.h> NEW_LINE #define NO_OF_CHARS  256"}
{"text": "function to check whether two strings are anagram of each other", "code": "bool areAnagram ( char * str1 , char * str2 ) {"}
{"text": "Create 2 count arrays and initialize all values as 0", "code": "int count1 [ NO_OF_CHARS ] = { 0 } ; int count2 [ NO_OF_CHARS ] = { 0 } ; int i ;"}
{"text": "For each character in input strings , increment count in the corresponding count array", "code": "for ( i = 0 ; str1 [ i ] && str2 [ i ] ; i ++ ) { count1 [ str1 [ i ] ] ++ ; count2 [ str2 [ i ] ] ++ ; }"}
{"text": "If both strings are of different length . Removing this condition will make the program fail for strings like \" aaca \" and \" aca \"", "code": "if ( str1 [ i ] str2 [ i ] ) return false ;"}
{"text": "Compare count arrays", "code": "for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }"}
{"text": "Driver code", "code": "int main ( ) { char str1 [ ] = \" geeksforgeeks \" ; char str2 [ ] = \" forgeeksgeeks \" ;"}
{"text": "Function Call", "code": "if ( areAnagram ( str1 , str2 ) ) printf ( \" The ▁ two ▁ strings ▁ are ▁ anagram ▁ of ▁ each ▁ other \" ) ; else printf ( \" The ▁ two ▁ strings ▁ are ▁ not ▁ anagram ▁ of ▁ each ▁ \" \" other \" ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the nth heptacontagon Number", "code": "int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; }"}
{"text": "Driver code", "code": "int main ( ) { int N = 3 ; printf ( \"3rd ▁ heptacontagon ▁ Number ▁ is ▁ = ▁ % d \" , heptacontagonNum ( N ) ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h>"}
{"text": "Function to find the largest number", "code": "int findMax ( int a , int b ) { int z , i , max ;"}
{"text": "Perform the subtraction", "code": "z = a - b ;"}
{"text": "Right shift and Bitwise AND", "code": "i = ( z >> 31 ) & 1 ;"}
{"text": "Find the maximum number", "code": "max = a - ( i * z ) ;"}
{"text": "Return the maximum value", "code": "return max ; }"}
{"text": "Driver Code", "code": "int main ( ) { int A = 40 , B = 54 ;"}
{"text": "Function Call", "code": "printf ( \" % d \" , findMax ( A , B ) ) ; return 0 ; }"}
{"text": "C program to find Armstrong number", "code": "#include <stdio.h>"}
{"text": "Function to calculate N raised to the power D", "code": "int power ( int N , unsigned int D ) { if ( D == 0 ) return 1 ; if ( D % 2 == 0 ) return power ( N , D / 2 ) * power ( N , D / 2 ) ; return N * power ( N , D / 2 ) * power ( N , D / 2 ) ; }"}
{"text": "Function to calculate the order of the number", "code": "int order ( int N ) { int r = 0 ;"}
{"text": "For each digit", "code": "while ( N ) { r ++ ; N = N / 10 ; } return r ; }"}
{"text": "Function to check whether the given number is Armstrong number or not", "code": "int isArmstrong ( int N ) {"}
{"text": "Calling order function", "code": "int D = order ( N ) ; int temp = N , sum = 0 ;"}
{"text": "For each digit", "code": "while ( temp ) { int Ni = temp % 10 ; sum += power ( Ni , D ) ; temp = temp / 10 ; }"}
{"text": "If satisfies Armstrong condition", "code": "if ( sum == N ) return 1 ; else return 0 ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given Number N", "code": "int N = 153 ;"}
{"text": "Function Call", "code": "if ( isArmstrong ( N ) == 1 ) printf ( \" True STRNEWLINE \" ) ; else printf ( \" False STRNEWLINE \" ) ; return 0 ; }"}
{"text": "C program to find the prime numbers between a given interval", "code": "#include <stdio.h>"}
{"text": "Function for print prime number in given range", "code": "void primeInRange ( int L , int R ) { int i , j , flag ;"}
{"text": "Traverse each number in the interval with the help of for loop", "code": "for ( i = L ; i <= R ; i ++ ) {"}
{"text": "Skip 0 and 1 as they are neither prime nor composite", "code": "if ( i == 1 i == 0 ) continue ;"}
{"text": "flag variable to tell if i is prime or not", "code": "flag = 1 ;"}
{"text": "Iterate to check if i is prime or not", "code": "for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } }"}
{"text": "flag = 1 means i is prime and flag = 0 means i is not prime", "code": "if ( flag == 1 ) printf ( \" % d ▁ \" , i ) ; } }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given Range", "code": "int L = 1 ; int R = 10 ;"}
{"text": "Function Call", "code": "primeInRange ( L , R ) ; return 0 ; }"}
{"text": "C code for the above approach", "code": "#include <stdio.h> NEW_LINE #define lli  long long int"}
{"text": "Function to check condition", "code": "void isEqualFactors ( lli N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) printf ( \" YES STRNEWLINE \" ) ; else printf ( \" NO STRNEWLINE \" ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { lli N = 10 ; isEqualFactors ( N ) ; N = 125 ; isEqualFactors ( N ) ; return 0 ; }"}
{"text": "C implementation for the above approach", "code": "#include <stdio.h>"}
{"text": "Function to check the divisibility of the number by its digit .", "code": "int checkDivisibility ( int n , int digit ) {"}
{"text": "If the digit divides the number then return true else return false .", "code": "return ( digit != 0 && n % digit == 0 ) ; }"}
{"text": "Function to check if all digits of n divide it or not", "code": "int isAllDigitsDivide ( int n ) { int temp = n ; while ( temp > 0 ) {"}
{"text": "Taking the digit of the number into digit var .", "code": "int digit = temp % 10 ; if ( ! ( checkDivisibility ( n , digit ) ) ) return 0 ; temp /= 10 ; } return 1 ; }"}
{"text": "Function to check if N has all distinct digits", "code": "int isAllDigitsDistinct ( int n ) {"}
{"text": "Create an array of size 10 and initialize all elements as false . This array is used to check if a digit is already seen or not .", "code": "int arr [ 10 ] , i , digit ; for ( i = 0 ; i < 10 ; i ++ ) arr [ i ] = 0 ;"}
{"text": "Traverse through all digits of given number", "code": "while ( n > 0 ) {"}
{"text": "Find the last digit", "code": "digit = n % 10 ;"}
{"text": "If digit is already seen , return false", "code": "if ( arr [ digit ] ) return 0 ;"}
{"text": "Mark this digit as seen", "code": "arr [ digit ] = 1 ;"}
{"text": "Remove the last digit from number", "code": "n = n / 10 ; } return 1 ; }"}
{"text": "Function to check Lynch - Bell numbers", "code": "int isLynchBell ( int n ) { return isAllDigitsDivide ( n ) && isAllDigitsDistinct ( n ) ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given number N", "code": "int N = 12 ;"}
{"text": "Function call", "code": "if ( isLynchBell ( N ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "C implementation to find the Maximum Bitwise AND pair ( X , Y ) from given range such that X and Y can be same", "code": "#include <stdio.h>"}
{"text": "Function to return the maximum bitwise AND", "code": "int maximumAND ( int L , int R ) { return R ; }"}
{"text": "Driver code", "code": "int main ( ) { int l = 3 ; int r = 7 ; printf ( \" % d \" , maximumAND ( l , r ) ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h>"}
{"text": "Function to find average of cubes", "code": "double findAverageOfCube ( int n ) {"}
{"text": "Store sum of cubes of numbers in the sum", "code": "double sum = 0 ;"}
{"text": "Calculate sum of cubes", "code": "int i ; for ( i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; }"}
{"text": "Return average", "code": "return sum / n ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given number", "code": "int n = 3 ;"}
{"text": "Function Call", "code": "printf ( \" % lf \" , findAverageOfCube ( n ) ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include \" stdio . h \""}
{"text": "Struct defined for the inch - feet system", "code": "struct InchFeet {"}
{"text": "Variable to store the inch - feet", "code": "int feet ; float inch ; } ;"}
{"text": "Function to find the sum of all N set of Inch Feet distances", "code": "void findSum ( struct InchFeet arr [ ] , int N ) {"}
{"text": "Variable to store sum", "code": "int feet_sum = 0 ; float inch_sum = 0.0 ; int x ;"}
{"text": "Traverse the InchFeet array", "code": "for ( int i = 0 ; i < N ; i ++ ) {"}
{"text": "Find the total sum of feet and inch", "code": "feet_sum += arr [ i ] . feet ; inch_sum += arr [ i ] . inch ; }"}
{"text": "If inch sum is greater than 11 convert it into feet as 1 feet = 12 inch", "code": "if ( inch_sum >= 12 ) {"}
{"text": "Find integral part of inch_sum", "code": "x = ( int ) inch_sum ;"}
{"text": "Delete the integral part x", "code": "inch_sum -= x ;"}
{"text": "Add x % 12 to inch_sum", "code": "inch_sum += x % 12 ;"}
{"text": "Add x / 12 to feet_sum", "code": "feet_sum += x / 12 ; }"}
{"text": "Print the corresponding sum of feet_sum and inch_sum", "code": "printf ( \" Feet ▁ Sum : ▁ % d STRNEWLINE \" , feet_sum ) ; printf ( \" Inch ▁ Sum : ▁ % .2f \" , inch_sum ) ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Given set of inch - feet", "code": "struct InchFeet arr [ ] = { { 10 , 3.7 } , { 10 , 5.5 } , { 6 , 8.0 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;"}
{"text": "Function Call", "code": "findSum ( arr , N ) ; return 0 ; }"}
{"text": "C implementation to check if the number is power of K", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Function to check if the number is power of K", "code": "_Bool isPower ( int N , int K ) {"}
{"text": "Logarithm function to calculate value", "code": "int res1 = log ( N ) / log ( K ) ; double res2 = log ( N ) / log ( K ) ;"}
{"text": "Compare to the result1 or result2 both are equal", "code": "return ( res1 == res2 ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int N = 8 ; int K = 2 ; if ( isPower ( N , K ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } return 0 ; }"}
{"text": "C program to implement Boole 's Rule on the given function", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Function to return the value of f ( x ) for the given value of x", "code": "float y ( float x ) { return ( 1 / ( 1 + x ) ) ; }"}
{"text": "Function to computes the integrand of y at the given intervals of x with step size h and the initial limit a and final limit b", "code": "float BooleRule ( float a , float b ) {"}
{"text": "Number of intervals", "code": "int n = 4 ; int h ;"}
{"text": "Computing the step size", "code": "h = ( ( b - a ) / n ) ; float sum = 0 ;"}
{"text": "Substituing a = 0 , b = 4 and h = 1", "code": "float bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ; sum = sum + bl ; return sum ; }"}
{"text": "Driver code", "code": "int main ( ) { float lowlimit = 0 ; float upplimit = 4 ; printf ( \" f ( x ) ▁ = ▁ % .4f \" , BooleRule ( 0 , 4 ) ) ; return 0 ; }"}
{"text": "C program to Implement Weedle 's Rule", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "A sample function f ( x ) = 1 / ( 1 + x ^ 2 )", "code": "float y ( float x ) { float num = 1 ; float denom = 1.0 + x * x ; return num / denom ; }"}
{"text": "Function to find the integral value of f ( x ) with step size h , with initial lower limit and upper limit a and b", "code": "float WeedleRule ( float a , float b ) {"}
{"text": "Find step size h", "code": "double h = ( b - a ) / 6 ;"}
{"text": "To store the final sum", "code": "float sum = 0 ;"}
{"text": "Find sum using Weedle 's Formula", "code": "sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) ;"}
{"text": "Return the final sum", "code": "return sum ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "lower limit and upper limit", "code": "float a = 0 , b = 6 ;"}
{"text": "Function Call", "code": "printf ( \" f ( x ) ▁ = ▁ % f \" , WeedleRule ( a , b ) ) ; return 0 ; }"}
{"text": "C program to implement Runge Kutta method", "code": "#include <stdio.h>"}
{"text": "A sample differential equation \" dy / dx ▁ = ▁ ( x ▁ - ▁ y ) /2\"", "code": "float dydx ( float x , float y ) { return ( x + y - 2 ) ; }"}
{"text": "Finds value of y for a given x using step size h and initial value y0 at x0 .", "code": "float rungeKutta ( float x0 , float y0 , float x , float h ) {"}
{"text": "Count number of iterations using step size or step height h", "code": "int n = ( int ) ( ( x - x0 ) / h ) ; float k1 , k2 ;"}
{"text": "Iterate for number of iterations", "code": "float y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text": "Apply Runge Kutta Formulas to find next value of y", "code": "k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ;"}
{"text": "Update next value of y", "code": "y = y + ( 1.0 / 6.0 ) * ( k1 + 2 * k2 ) ;"}
{"text": "Update next value of x", "code": "x0 = x0 + h ; } return y ; }"}
{"text": "Driver Code", "code": "int main ( ) { float x0 = 0 , y = 1 , x = 2 , h = 0.2 ; printf ( \" y ( x ) ▁ = ▁ % f \" , rungeKutta ( x0 , y , x , h ) ) ; return 0 ; }"}
{"text": "C program to find the perimeter and area", "code": "#include <stdio.h>"}
{"text": "Function to find the perimeter", "code": "float per ( float a , float b ) { return ( a + b ) ; }"}
{"text": "Function to find the area", "code": "float area ( float s ) { return ( s / 2 ) ; }"}
{"text": "Driver code", "code": "int main ( ) { float a = 7 , b = 8 , s = 10 ; printf ( \" % f STRNEWLINE \" , per ( a , b ) ) ; printf ( \" % f \" , area ( s ) ) ; return 0 ; }"}
{"text": "C program to find the area of leaf inside a square", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265"}
{"text": "Function to find area of leaf", "code": "float area_leaf ( float a ) { return ( a * a * ( PI / 2 - 1 ) ) ; }"}
{"text": "Driver code", "code": "int main ( ) { float a = 7 ; printf ( \" % f \" , area_leaf ( a ) ) ; return 0 ; }"}
{"text": "C program to find the length of rope", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265"}
{"text": "Function to find the length of rope", "code": "float length_rope ( float r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }"}
{"text": "Driver code", "code": "int main ( ) { float r = 7 ; printf ( \" % f \" , length_rope ( r ) ) ; return 0 ; }"}
{"text": "C program to find the area of incircle of right angled triangle", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265"}
{"text": "Function to find area of incircle", "code": "float area_inscribed ( float P , float B , float H ) { return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) ; }"}
{"text": "Driver code", "code": "int main ( ) { float P = 3 , B = 4 , H = 5 ; printf ( \" % f \" , area_inscribed ( P , B , H ) ) ; return 0 ; }"}
{"text": "C program to find the area of Cicumscribed circle of right angled triangle", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265"}
{"text": "Function to find area of circumscribed circle", "code": "float area_circumscribed ( float c ) { return ( c * c * ( PI / 4 ) ) ; }"}
{"text": "Driver code", "code": "int main ( ) { float c = 8 ; printf ( \" % f \" , area_circumscribed ( c ) ) ; return 0 ; }"}
{"text": "C program to find the area of Inscribed circle of equilateral triangle", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #define PI  3.14159265"}
{"text": "function to find area of inscribed circle", "code": "float area_inscribed ( float a ) { return ( a * a * ( PI / 12 ) ) ; }"}
{"text": "function to find Perimeter of inscribed circle", "code": "float perm_inscribed ( float a ) { return ( PI * ( a / sqrt ( 3 ) ) ) ; }"}
{"text": "Driver code", "code": "int main ( ) { float a = 6 ; printf ( \" Area ▁ of ▁ inscribed ▁ circle ▁ is ▁ : % f STRNEWLINE \" , area_inscribed ( a ) ) ; printf ( \" Perimeter ▁ of ▁ inscribed ▁ circle ▁ is ▁ : % f \" , perm_inscribed ( a ) ) ; return 0 ; }"}
{"text": "C program to find the Area and Perimeter of a Semicircle", "code": "#include <stdio.h>"}
{"text": "Function for calculating the area", "code": "float area ( float r ) {"}
{"text": "Formula for finding the area", "code": "return ( 0.5 ) * ( 3.14 ) * ( r * r ) ; }"}
{"text": "Function for calculating the perimeter", "code": "float perimeter ( float r ) {"}
{"text": "Formula for finding the perimeter", "code": "return ( 3.14 ) * ( r ) ; }"}
{"text": "driver code", "code": "int main ( ) {"}
{"text": "Get the radius", "code": "float r = 10 ;"}
{"text": "Find the area", "code": "printf ( \" The ▁ Area ▁ of ▁ Semicircle : ▁ % f STRNEWLINE \" , area ( r ) ) ;"}
{"text": "Find the perimeter", "code": "printf ( \" The ▁ Perimeter ▁ of ▁ Semicircle : ▁ % f STRNEWLINE \" , perimeter ( r ) ) ; return 0 ; }"}
{"text": "C program to find equation of a plane passing through given 3 points .", "code": "#include <stdio.h>"}
{"text": "Function to find equation of plane .", "code": "void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; printf ( \" equation ▁ of ▁ plane ▁ is ▁ % .2f ▁ x ▁ + ▁ % .2f \" \" ▁ y ▁ + ▁ % .2f ▁ z ▁ + ▁ % .2f ▁ = ▁ 0 . \" , a , b , c , d ) ; return ; }"}
{"text": "Driver Code", "code": "int main ( ) { float x1 = -1 ; float y1 = 2 ; float z1 = 1 ; float x2 = 0 ; float y2 = -3 ; float z2 = 2 ; float x3 = 1 ; float y3 = 1 ; float z3 = -4 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; return 0 ; }"}
{"text": "C program to find the distance between a given point and a given line in 2 D .", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Function to find distance", "code": "void shortest_distance ( float x1 , float y1 , float a , float b , float c ) { float d = fabs ( ( a * x1 + b * y1 + c ) ) / ( sqrt ( a * a + b * b ) ) ; printf ( \" Perpendicular ▁ distance ▁ is ▁ % f STRNEWLINE \" , d ) ; return ; }"}
{"text": "Driver Code", "code": "int main ( ) { float x1 = 5 ; float y1 = 6 ; float a = -2 ; float b = 3 ; float c = 4 ; shortest_distance ( x1 , y1 , a , b , c ) ; return 0 ; }"}
{"text": "C program to print octant of a given point .", "code": "#include <stdio.h>"}
{"text": "Function to print octant", "code": "void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) printf ( \" Point ▁ lies ▁ in ▁ 1st ▁ octant STRNEWLINE \" ) ; else if ( x < 0 && y >= 0 && z >= 0 ) printf ( \" Point ▁ lies ▁ in ▁ 2nd ▁ octant STRNEWLINE \" ) ; else if ( x < 0 && y < 0 && z >= 0 ) printf ( \" Point ▁ lies ▁ in ▁ 3rd ▁ octant STRNEWLINE \" ) ; else if ( x >= 0 && y < 0 && z >= 0 ) printf ( \" Point ▁ lies ▁ in ▁ 4th ▁ octant STRNEWLINE \" ) ; else if ( x >= 0 && y >= 0 && z < 0 ) printf ( \" Point ▁ lies ▁ in ▁ 5th ▁ octant STRNEWLINE \" ) ; else if ( x < 0 && y >= 0 && z < 0 ) printf ( \" Point ▁ lies ▁ in ▁ 6th ▁ octant STRNEWLINE \" ) ; else if ( x < 0 && y < 0 && z < 0 ) printf ( \" Point ▁ lies ▁ in ▁ 7th ▁ octant STRNEWLINE \" ) ; else if ( x >= 0 && y < 0 && z < 0 ) printf ( \" Point ▁ lies ▁ in ▁ 8th ▁ octant STRNEWLINE \" ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { float x = 2 , y = 3 , z = 4 ; octant ( x , y , z ) ; x = -4 , y = 2 , z = -8 ; octant ( x , y , z ) ; x = -6 , y = -2 , z = 8 ; octant ( x , y , z ) ; }"}
{"text": "CPP program to find maximum are of a quadrilateral", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE double maxArea ( double a , double b , double c , double d ) {"}
{"text": "Calculating the semi - perimeter of the given quadrilateral", "code": "double semiperimeter = ( a + b + c + d ) / 2 ;"}
{"text": "Applying Brahmagupta 's formula to  get maximum area of quadrilateral", "code": "return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }"}
{"text": "Driver code", "code": "int main ( ) { double a = 1 , b = 2 , c = 1 , d = 2 ; printf ( \" % .2f STRNEWLINE \" , maxArea ( a , b , c , d ) ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h>"}
{"text": "Function to find array after performing the given query to the array elements", "code": "void addAP ( int A [ ] , int Q , int operations [ 2 ] [ 4 ] ) {"}
{"text": "Traverse the given query", "code": "for ( int j = 0 ; j < 2 ; ++ j ) { int L = operations [ j ] [ 0 ] , R = operations [ j ] [ 1 ] , a = operations [ j ] [ 2 ] , d = operations [ j ] [ 3 ] ; int curr = a ;"}
{"text": "Traverse the given array", "code": "for ( int i = L - 1 ; i < R ; i ++ ) {"}
{"text": "Update the value of A [ i ]", "code": "A [ i ] += curr ;"}
{"text": "Update the value of curr", "code": "curr += d ; } }"}
{"text": "Print the array elements", "code": "for ( int i = 0 ; i < 4 ; ++ i ) printf ( \" % d ▁ \" , A [ i ] ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { int A [ ] = { 5 , 4 , 2 , 8 } ; int Q = 2 ; int Query [ 2 ] [ 4 ] = { { 1 , 2 , 1 , 3 } , { 1 , 4 , 4 , 1 } } ;"}
{"text": "Function Call", "code": "addAP ( A , Q , Query ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <omp.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <time.h>"}
{"text": "Function to find estimated value of PI using Monte Carlo algorithm", "code": "void monteCarlo ( int N , int K ) {"}
{"text": "Stores X and Y coordinates of a random point", "code": "double x , y ;"}
{"text": "Stores distance of a random point from origin", "code": "double d ;"}
{"text": "Stores number of points lying inside circle", "code": "int pCircle = 0 ;"}
{"text": "Stores number of points lying inside square", "code": "int pSquare = 0 ; int i = 0 ;"}
{"text": "Parallel calculation of random points lying inside a circle", "code": "#pragma  omp parallel firstprivate(x, y, d, i) reduction(+ : pCircle, pSquare) num_threads(K) NEW_LINE {"}
{"text": "Initializes random points with a seed", "code": "srand48 ( ( int ) time ( NULL ) ) ; for ( i = 0 ; i < N ; i ++ ) {"}
{"text": "Finds random X co - ordinate", "code": "x = ( double ) drand48 ( ) ;"}
{"text": "Finds random X co - ordinate", "code": "y = ( double ) drand48 ( ) ;"}
{"text": "Finds the square of distance of point ( x , y ) from origin", "code": "d = ( ( x * x ) + ( y * y ) ) ;"}
{"text": "If d is less than or equal to 1", "code": "if ( d <= 1 ) {"}
{"text": "Increment pCircle by 1", "code": "pCircle ++ ; }"}
{"text": "Increment pSquare by 1", "code": "pSquare ++ ; } }"}
{"text": "Stores the estimated value of PI", "code": "double pi = 4.0 * ( ( double ) pCircle / ( double ) ( pSquare ) ) ;"}
{"text": "Prints the value in pi", "code": "printf ( \" Final ▁ Estimation ▁ of ▁ Pi ▁ = ▁ % f STRNEWLINE \" , pi ) ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Input", "code": "int N = 100000 ; int K = 8 ;"}
{"text": "Function call", "code": "monteCarlo ( N , K ) ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Dimensions of a matrix", "code": "const int N = 5 ;"}
{"text": "Structure of the efficient matrix", "code": "struct Matrix { int * A ; int size ; } ;"}
{"text": "Function to set the values in the Matrix", "code": "void Set ( struct Matrix * mat , int i , int j , int x ) { if ( i >= j ) mat -> A [ i * ( i - 1 ) / 2 + j - 1 ] = x ; }"}
{"text": "Function to store the values in the Matrix", "code": "int Get ( struct Matrix mat , int i , int j ) { if ( i >= j ) { return mat . A [ i * ( i - 1 ) / 2 + j - 1 ] ; } else { return 0 ; } }"}
{"text": "Function to display the elements of the matrix", "code": "void Display ( struct Matrix mat ) { int i , j ;"}
{"text": "Traverse the matrix", "code": "for ( i = 1 ; i <= mat . size ; i ++ ) { for ( j = 1 ; j <= mat . size ; j ++ ) { if ( i >= j ) { printf ( \" % d ▁ \" , mat . A [ i * ( i - 1 ) / 2 + j - 1 ] ) ; } else { printf ( \"0 ▁ \" ) ; } } printf ( \" STRNEWLINE \" ) ; } }"}
{"text": "Function to generate an efficient matrix", "code": "struct Matrix createMat ( int Mat [ N ] [ N ] ) {"}
{"text": "Declare efficient Matrix", "code": "struct Matrix mat ;"}
{"text": "Initialize the Matrix", "code": "mat . size = N ; mat . A = ( int * ) malloc ( mat . size * ( mat . size + 1 ) / 2 * sizeof ( int ) ) ; int i , j ;"}
{"text": "Set the values in matrix", "code": "for ( i = 1 ; i <= mat . size ; i ++ ) { for ( j = 1 ; j <= mat . size ; j ++ ) { Set ( & mat , i , j , Mat [ i - 1 ] [ j - 1 ] ) ; } }"}
{"text": "Return the matrix", "code": "return mat ; }"}
{"text": "Driver Code", "code": "int main ( ) { int Mat [ 5 ] [ 5 ] = { { 1 , 0 , 0 , 0 , 0 } , { 1 , 2 , 0 , 0 , 0 } , { 1 , 2 , 3 , 0 , 0 } , { 1 , 2 , 3 , 4 , 0 } , { 1 , 2 , 3 , 4 , 5 } } ;"}
{"text": "Stores the efficient matrix", "code": "struct Matrix mat = createMat ( Mat ) ;"}
{"text": "Print the Matrix", "code": "Display ( mat ) ; return 0 ; }"}
{"text": "Program to illustrate the working of the modulo operator", "code": "#include <stdio.h> NEW_LINE int main ( void ) {"}
{"text": "To store two integer values", "code": "int x , y ;"}
{"text": "To store the result of the modulo expression", "code": "int result ; x = -3 ; y = 4 ; result = x % y ; printf ( \" % d \" , result ) ; x = 4 ; y = -2 ; result = x % y ; printf ( \" % d \" , result ) ; x = -3 ; y = -4 ; result = x % y ; printf ( \" % d \" , result ) ; return 0 ; }"}
{"text": "C program to find log ( a ) on any base b", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE int log_a_to_base_b ( int a , int b ) { return log ( a ) / log ( b ) ; }"}
{"text": "Driver code", "code": "int main ( ) { int a = 3 ; int b = 2 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; a = 256 ; b = 4 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; return 0 ; }"}
{"text": "C program to find log ( a ) on any base b using Recursion", "code": "#include <stdio.h>"}
{"text": "Recursive function to compute log a to the base b", "code": "int log_a_to_base_b ( int a , int b ) { return ( a > b - 1 ) ? 1 + log_a_to_base_b ( a / b , b ) : 0 ; }"}
{"text": "Driver code", "code": "int main ( ) { int a = 3 ; int b = 2 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; a = 256 ; b = 4 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; return 0 ; }"}
{"text": "C program to find maximum and minimum using Absolute function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Function to return maximum among the two numbers", "code": "int maximum ( int x , int y ) { return ( ( x + y + abs ( x - y ) ) / 2 ) ; }"}
{"text": "Function to return minimum among the two numbers", "code": "int minimum ( int x , int y ) { return ( ( x + y - abs ( x - y ) ) / 2 ) ; }"}
{"text": "Driver code", "code": "void main ( ) { int x = 99 , y = 18 ;"}
{"text": "Displaying the maximum value", "code": "printf ( \" Maximum : ▁ % d STRNEWLINE \" , maximum ( x , y ) ) ;"}
{"text": "Displaying the minimum value", "code": "printf ( \" Minimum : ▁ % d STRNEWLINE \" , minimum ( x , y ) ) ; }"}
{"text": "C implementation of the approach", "code": "#include <stdio.h>"}
{"text": "Recursive Function with static variables p and f", "code": "double e ( int x , int n ) { static double p = 1 , f = 1 ; double r ;"}
{"text": "Termination condition", "code": "if ( n == 0 ) return 1 ;"}
{"text": "Recursive call", "code": "r = e ( x , n - 1 ) ;"}
{"text": "Update the power of x", "code": "p = p * x ;"}
{"text": "Factorial", "code": "f = f * n ; return ( r + p / f ) ; }"}
{"text": "Driver code", "code": "int main ( ) { int x = 4 , n = 15 ; printf ( \" % lf ▁ STRNEWLINE \" , e ( x , n ) ) ; return 0 ; }"}
{"text": "C program for implementing Mid - Point Ellipse Drawing Algorithm", "code": "#include <stdio.h> NEW_LINE void midptellipse ( int rx , int ry , int xc , int yc ) { float dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ;"}
{"text": "Initial decision parameter of region 1", "code": "d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25 * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ;"}
{"text": "For region 1", "code": "while ( dx < dy ) {"}
{"text": "Print points based on 4 - way symmetry", "code": "printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , x + xc , y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , - x + xc , y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , x + xc , - y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , - x + xc , - y + yc ) ;"}
{"text": "Checking and updating value of decision parameter based on algorithm", "code": "if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } }"}
{"text": "Decision parameter of region 2", "code": "d2 = ( ( ry * ry ) * ( ( x + 0.5 ) * ( x + 0.5 ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ;"}
{"text": "Plotting points of region 2", "code": "while ( y >= 0 ) {"}
{"text": "printing points based on 4 - way symmetry", "code": "printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , x + xc , y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , - x + xc , y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , x + xc , - y + yc ) ; printf ( \" ( % f , ▁ % f ) STRNEWLINE \" , - x + xc , - y + yc ) ;"}
{"text": "Checking and updating parameter value based on algorithm", "code": "if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } }"}
{"text": "Driver code", "code": "int main ( ) {"}
{"text": "To draw a ellipse of major and minor radius 15 , 10 centred at ( 50 , 50 )", "code": "midptellipse ( 10 , 15 , 50 , 50 ) ; return 0 ; }"}
{"text": "C program to convert Hexadecimal number to Binary", "code": "#include <stdio.h>"}
{"text": "function to convert Hexadecimal to Binary Number", "code": "void HexToBin ( char * hexdec ) { long int i = 0 ; while ( hexdec [ i ] ) { switch ( hexdec [ i ] ) { case '0' : printf ( \"0000\" ) ; break ; case '1' : printf ( \"0001\" ) ; break ; case '2' : printf ( \"0010\" ) ; break ; case '3' : printf ( \"0011\" ) ; break ; case '4' : printf ( \"0100\" ) ; break ; case '5' : printf ( \"0101\" ) ; break ; case '6' : printf ( \"0110\" ) ; break ; case '7' : printf ( \"0111\" ) ; break ; case '8' : printf ( \"1000\" ) ; break ; case '9' : printf ( \"1001\" ) ; break ; case ' A ' : case ' a ' : printf ( \"1010\" ) ; break ; case ' B ' : case ' b ' : printf ( \"1011\" ) ; break ; case ' C ' : case ' c ' : printf ( \"1100\" ) ; break ; case ' D ' : case ' d ' : printf ( \"1101\" ) ; break ; case ' E ' : case ' e ' : printf ( \"1110\" ) ; break ; case ' F ' : case ' f ' : printf ( \"1111\" ) ; break ; default : printf ( \" Invalid hexadecimal digit % c \" , hexdec [ i ] ) ; } i ++ ; } }"}
{"text": "driver code", "code": "int main ( ) {"}
{"text": "Get the Hexadecimal number", "code": "char hexdec [ 100 ] = \"1AC5\" ;"}
{"text": "Convert HexaDecimal to Binary", "code": "printf ( \" Equivalent Binary value is : \" HexToBin ( hexdec ) ; }"}
{"text": "C Program to read a square matrix and print the elements on secondary diagonal", "code": "#include <stdio.h> NEW_LINE int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ;"}
{"text": "Get the square matrix", "code": "for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } }"}
{"text": "Display the matrix", "code": "printf ( \" The ▁ matrix ▁ is STRNEWLINE \" ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { printf ( \" % d TABSYMBOL \" , matrix [ row_index ] [ column_index ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Print the elements on secondary diagonal", "code": "printf ( \" Elements on Secondary diagonal : \" for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) {"}
{"text": "check for elements on secondary diagonal", "code": "if ( ( row_index + column_index ) == size - 1 ) printf ( \" % d , ▁ \" , matrix [ row_index ] [ column_index ] ) ; } } return 0 ; }"}
{"text": "C Program to read a square matrix and print the elements above secondary diagonal", "code": "#include <stdio.h> NEW_LINE int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ;"}
{"text": "Get the square matrix", "code": "for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } }"}
{"text": "Display the matrix", "code": "printf ( \" The ▁ matrix ▁ is STRNEWLINE \" ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { printf ( \" % d TABSYMBOL \" , matrix [ row_index ] [ column_index ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Print the elements above secondary diagonal", "code": "printf ( \" Elements above Secondary diagonal are : \" for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) {"}
{"text": "check for elements above secondary diagonal", "code": "if ( ( row_index + column_index ) < size - 1 ) printf ( \" % d , ▁ \" , matrix [ row_index ] [ column_index ] ) ; } } return 0 ; }"}
{"text": "C Program to read a square matrix and print the Corner Elements", "code": "#include <stdio.h> NEW_LINE int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ;"}
{"text": "Get the square matrix", "code": "for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } }"}
{"text": "Display the matrix", "code": "printf ( \" The ▁ matrix ▁ is STRNEWLINE \" ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { printf ( \" % d TABSYMBOL \" , matrix [ row_index ] [ column_index ] ) ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Print the Corner elements", "code": "printf ( \" Corner Elements are : \" for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) {"}
{"text": "check for corner elements", "code": "if ( ( row_index == 0 row_index == size - 1 ) && ( column_index == 0 column_index == size - 1 ) ) printf ( \" % d , ▁ \" , matrix [ row_index ] [ column_index ] ) ; } } return 0 ; }"}
{"text": "C program to find distance between two points in 3 D .", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "function to print distance", "code": "void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float d = sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) + pow ( z2 - z1 , 2 ) * 1.0 ) ; printf ( \" Distance ▁ is ▁ % f \" , d ) ; return ; }"}
{"text": "Driver Code", "code": "int main ( ) { float x1 = 2 ; float y1 = -5 ; float z1 = 7 ; float x2 = 3 ; float y2 = 4 ; float z2 = 5 ;"}
{"text": "function call for distance", "code": "distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ; return 0 ; }"}
{"text": "C program for finding the required pairs", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the number of unique pairs", "code": "int No_Of_Pairs ( int N ) { int i = 1 ;"}
{"text": "Using the derived formula", "code": "while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) i ++ ; return ( i - 1 ) ; }"}
{"text": "Printing the unique pairs", "code": "void print_pairs ( int pairs ) { int i = 1 , mul ; for ( i = 1 ; i <= pairs ; i ++ ) { mul = i * ( i + 1 ) ; printf ( \" Pair ▁ no . ▁ % d ▁ - - > ▁ ( % d , ▁ % d ) STRNEWLINE \" , i , ( mul * i ) , mul * ( i + 1 ) ) ; } }"}
{"text": "Driver program to test above functions", "code": "int main ( ) { int N = 500 , pairs , mul , i = 1 ; pairs = No_Of_Pairs ( N ) ; printf ( \" No . ▁ of ▁ pairs ▁ = ▁ % d ▁ STRNEWLINE \" , pairs ) ; print_pairs ( pairs ) ; return 0 ; }"}
{"text": "C program to Divide a Big Number into two parts", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define MAX  100"}
{"text": "Function to adds two Numbers represented as array of character .", "code": "void add ( char v1 [ ] , char v2 [ ] ) { int i , d , c = 0 ;"}
{"text": "length of string", "code": "int l1 = strlen ( v1 ) ; int l2 = strlen ( v2 ) ;"}
{"text": "initializing extra character position to 0", "code": "for ( i = l1 ; i < l2 ; i ++ ) v1 [ i ] = '0' ; for ( i = l2 ; i < l1 ; i ++ ) v2 [ i ] = '0' ;"}
{"text": "Adding each element of character and storing the carry .", "code": "for ( i = 0 ; i < l1 i < l2 ; i ++ ) { d = ( v1 [ i ] - '0' ) + ( v2 [ i ] - '0' ) + c ; c = d / 10 ; d %= 10 ; v1 [ i ] = '0' + d ; }"}
{"text": "If remainder remains .", "code": "while ( c ) { v1 [ i ] = '0' + ( c % 10 ) ; c /= 10 ; i ++ ; } v1 [ i ] = ' \\0' ; v2 [ l2 ] = ' \\0' ; }"}
{"text": "Function to subtracts two numbers represented by string .", "code": "void subs ( char v1 [ ] , char v2 [ ] ) { int i , d , c = 0 ;"}
{"text": "Finding the length of the string .", "code": "int l1 = strlen ( v1 ) ; int l2 = strlen ( v2 ) ;"}
{"text": "initializing extra character position to 0.", "code": "for ( i = l2 ; i < l1 ; i ++ ) v2 [ i ] = '0' ;"}
{"text": "Substrating each element of character .", "code": "for ( i = 0 ; i < l1 ; i ++ ) { d = ( v1 [ i ] - '0' - c ) - ( v2 [ i ] - '0' ) ; if ( d < 0 ) { d += 10 ; c = 1 ; } else c = 0 ; v1 [ i ] = '0' + d ; } v2 [ l2 ] = ' \\0' ; i = l1 - 1 ; while ( i > 0 && v1 [ i ] == '0' ) i -- ; v1 [ i + 1 ] = ' \\0' ; }"}
{"text": "Function divides a number represented by character array a constant .", "code": "int divi ( char v [ ] , int q ) { int i , l = strlen ( v ) ; int c = 0 , d ;"}
{"text": "Dividing each character element by constant .", "code": "for ( i = l - 1 ; i >= 0 ; i -- ) { d = c * 10 + ( v [ i ] - '0' ) ; c = d % q ; d /= q ; v [ i ] = '0' + d ; } i = l - 1 ; while ( i > 0 && v [ i ] == '0' ) i -- ; v [ i + 1 ] = ' \\0' ; return c ; }"}
{"text": "Function to reverses the character array .", "code": "void rev ( char v [ ] ) { int l = strlen ( v ) ; int i ; char cc ;"}
{"text": "Reversing the array .", "code": "for ( i = 0 ; i < l - 1 - i ; i ++ ) { cc = v [ i ] ; v [ i ] = v [ l - 1 - i ] ; v [ l - i - 1 ] = cc ; } }"}
{"text": "Wrapper Function", "code": "void divideWithDiffK ( char a [ ] , char k [ ] ) {"}
{"text": "Reversing the character array .", "code": "rev ( a ) ; rev ( k ) ;"}
{"text": "Adding the each element of both array and storing the sum in array a [ ] .", "code": "add ( a , k ) ;"}
{"text": "Dividing the array a [ ] by 2.", "code": "divi ( a , 2 ) ;"}
{"text": "Reversing the character array to get output .", "code": "rev ( a ) ; printf ( \" % s ▁ \" , a ) ;"}
{"text": "Substracting each element of array i . e calculating a = a - b", "code": "rev ( a ) ; subs ( a , k ) ;"}
{"text": "Reversing the character array to get output .", "code": "rev ( a ) ; printf ( \" % s \" , a ) ; }"}
{"text": "Driven Program", "code": "int main ( ) { char a [ MAX ] = \"100\" , k [ MAX ] = \"20\" ; divideWithDiffK ( a , k ) ; return 0 ; }"}
{"text": "C Program to find the area of square when its diagonal is given .", "code": "#include <stdio.h>"}
{"text": "Returns area of square from given diagonal", "code": "double findArea ( double d ) { return ( d * d ) / 2 ; }"}
{"text": "Driver function .", "code": "int main ( ) { double d = 10 ; printf ( \" % .2f \" , findArea ( d ) ) ; return 0 ; }"}
{"text": "C program to calculate 1 ^ 2 + 2 ^ 2 + 3 ^ 2 + ... average of square number", "code": "#include <stdio.h>"}
{"text": "Function to calculate average of square number", "code": "float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 2 ; printf ( \" % f \" , AvgofSquareN ( n ) ) ; return 0 ; }"}
{"text": "C program to get the sum of the series", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Function to get the series", "code": "double Series ( double x , int n ) { double sum = 1 , term = 1 , fct , j , y = 2 , m ;"}
{"text": "Sum of n - 1 terms starting from 2 nd term", "code": "int i ; for ( i = 1 ; i < n ; i ++ ) { fct = 1 ; for ( j = 1 ; j <= y ; j ++ ) { fct = fct * j ; } term = term * ( -1 ) ; m = term * pow ( x , y ) / fct ; sum = sum + m ; y += 2 ; } return sum ; }"}
{"text": "Driver Code", "code": "int main ( ) { double x = 9 ; int n = 10 ; printf ( \" % .4f \" , Series ( x , n ) ) ; return 0 ; }"}
{"text": "C Program to find largest prime factor of number", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "A function to find largest prime factor", "code": "long long maxPrimeFactors ( long long n ) {"}
{"text": "Initialize the maximum prime factor variable with the lowest one", "code": "long long maxPrime = -1 ;"}
{"text": "Print the number of 2 s that divide n", "code": "while ( n % 2 == 0 ) { maxPrime = 2 ;"}
{"text": "n >>= 1 ; equivalent to n /= 2", "code": "}"}
{"text": "n must be odd at this point", "code": "while ( n % 3 == 0 ) { maxPrime = 3 ; n = n / 3 ; }"}
{"text": "now we have to iterate only for integers who does not have prime factor 2 and 3", "code": "for ( int i = 5 ; i <= sqrt ( n ) ; i += 6 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } while ( n % ( i + 2 ) == 0 ) { maxPrime = i + 2 ; n = n / ( i + 2 ) ; } }"}
{"text": "This condition is to handle the case when n is a prime number greater than 4", "code": "if ( n > 4 ) maxPrime = n ; return maxPrime ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { long long n = 15 ; printf ( \" % lld STRNEWLINE \" , maxPrimeFactors ( n ) ) ; n = 25698751364526 ; printf ( \" % lld \" , maxPrimeFactors ( n ) ) ; return 0 ; }"}
{"text": "C program to find sum of series 1 + x ^ 2 / 2 + x ^ 3 / 3 + ... . + x ^ n / n", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "C code to print the sum of the series", "code": "double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }"}
{"text": "Driver code", "code": "int main ( ) { int x = 2 ; int n = 5 ; printf ( \" % .2f \" , sum ( x , n ) ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the nth chiliagon Number", "code": "int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ chiliagon ▁ Number ▁ is ▁ = ▁ % d \" , chiliagonNum ( n ) ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the nth pentacontagon Number", "code": "int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ pentacontagon ▁ Number ▁ is ▁ = ▁ % d \" , pentacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "C ++ program to find the array value by repeatedly replacing max 2 elements with their absolute difference", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "function that return last value of array", "code": "int lastElement ( vector < int > & arr ) {"}
{"text": "Build a binary max_heap .", "code": "priority_queue < int > pq ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { pq . push ( arr [ i ] ) ; }"}
{"text": "For max 2 elements", "code": "int m1 , m2 ;"}
{"text": "Iterate until queue is not empty", "code": "while ( ! pq . empty ( ) ) {"}
{"text": "if only 1 element is left", "code": "if ( pq . size ( ) == 1 )"}
{"text": "return the last remaining value", "code": "return pq . top ( ) ; m1 = pq . top ( ) ; pq . pop ( ) ; m2 = pq . top ( ) ; pq . pop ( ) ;"}
{"text": "check that difference is non zero", "code": "if ( m1 != m2 ) pq . push ( m1 - m2 ) ; }"}
{"text": "finally return 0", "code": "return 0 ; }"}
{"text": "Driver Code", "code": "int main ( ) { vector < int > arr = { 2 , 7 , 4 , 1 , 8 , 1 , 1 } ; cout << lastElement ( arr ) << endl ; return 0 ; }"}
{"text": "C implementation count the number of digits in a number", "code": "#include <stdio.h> NEW_LINE #include <math.h>"}
{"text": "Function to count the number of digits in a number", "code": "int countDigit ( long long n ) { return ( floor ( log10 ( n ) + 1 ) ) ; }"}
{"text": "Driver Code", "code": "int main ( ) { double N = 80 ; printf ( \" % d \" , countDigit ( N ) ) ; return 0 ; }"}
{"text": "C implementation to find the sum of series 1 + x ^ 2 + x ^ 3 + ... . + x ^ n", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Function to print the sum of the series", "code": "double sum ( int x , int n ) { double i , total = 1.0 , multi = x ;"}
{"text": "First Term of series", "code": "printf ( \"1 ▁ \" ) ;"}
{"text": "Loop to find the N terms of the series", "code": "for ( i = 1 ; i < n ; i ++ ) { total = total + multi ; printf ( \" % .1f ▁ \" , multi ) ; multi = multi * x ; } printf ( \" STRNEWLINE \" ) ; return total ; }"}
{"text": "Driver Code", "code": "int main ( ) { int x = 2 ; int n = 5 ; printf ( \" % .2f \" , sum ( x , n ) ) ; return 0 ; }"}
{"text": "C implementation to find N modulo 4 using Bitwise AND operator", "code": "#include <stdio.h>"}
{"text": "Function to find the remainder", "code": "int findRemainder ( int n ) {"}
{"text": "Bitwise AND with 3", "code": "int x = n & 3 ;"}
{"text": "return x", "code": "return x ; }"}
{"text": "Driver code", "code": "int main ( ) { int N = 43 ; int ans = findRemainder ( N ) ; printf ( \" % d \" , ans ) ; return 0 ; }"}
{"text": "C Program to find Triangular Number Series", "code": "#include <stdio.h>"}
{"text": "Function to find triangular number", "code": "void triangular_series ( int n ) { int i , j = 1 , k = 1 ;"}
{"text": "For each iteration increase j by 1 and add it into k", "code": "for ( i = 1 ; i <= n ; i ++ ) { printf ( \" ▁ % d ▁ \" , k ) ;"}
{"text": "Increasing j by 1", "code": "j = j + 1 ;"}
{"text": "Add value of j into k and update k", "code": "k = k + j ; } }"}
{"text": "Driven Function", "code": "int main ( ) { int n = 5 ; triangular_series ( n ) ; return 0 ; }"}
{"text": "Recursive C program to count number of digits in a number", "code": "#include <stdio.h> NEW_LINE int countDigit ( long long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; }"}
{"text": "Driver code", "code": "int main ( void ) { long long n = 345289467 ; printf ( \" Number ▁ of ▁ digits ▁ : ▁ % d \" , countDigit ( n ) ) ; return 0 ; }"}
{"text": "C program to check Whether the number is Magic or not .", "code": "#include <stdio.h> NEW_LINE int main ( ) {"}
{"text": "Accepting sample input", "code": "int x = 1234 ;"}
{"text": "Condition to check Magic number", "code": "if ( x % 9 == 1 ) printf ( \" Magic ▁ Number \" ) ; else printf ( \" Not ▁ a ▁ Magic ▁ Number \" ) ; return 0 ; }"}
{"text": "C program to demonstrate that Fibonacci numbers that are divisible by their indexes have indexes as either power of 5 or multiple of 12.", "code": "#include <stdio.h> NEW_LINE #define MAX  100 NEW_LINE int main ( ) {"}
{"text": "storing Fibonacci numbers", "code": "long long int arr [ MAX ] ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] ; printf ( \" Fibonacci ▁ numbers ▁ divisible ▁ by ▁ \" \" their ▁ indexes ▁ are ▁ : STRNEWLINE \" ) ; for ( int i = 1 ; i < MAX ; i ++ ) if ( arr [ i ] % i == 0 ) printf ( \" % d ▁ \" , i ) ; }"}
{"text": "C program to find maximum value of an integer for which factorial can be calculated on your system", "code": "#include <stdio.h> NEW_LINE int findMaxValue ( ) { int res = 2 ; long long int fact = 2 ; while ( 1 ) {"}
{"text": "when fact crosses its size , it gives negative value", "code": "if ( fact < 0 ) break ; res ++ ; fact = fact * res ; } return res - 1 ; }"}
{"text": "Driver Code", "code": "int main ( ) { printf ( \" Maximum ▁ value ▁ of ▁ integer ▁ : ▁ % d STRNEWLINE \" , findMaxValue ( ) ) ; return 0 ; }"}
{"text": "C ++ program to generate first k digits of n ^ n", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ;"}
{"text": "function to calculate first k digits of n ^ n", "code": "long long firstkdigits ( int n , int k ) {"}
{"text": "take log10 of n ^ n . log10 ( n ^ n ) = n * log10 ( n )", "code": "long double product = n * log10 ( n ) ;"}
{"text": "We now try to separate the decimal and integral part of the / product . The floor function returns the smallest integer less than or equal to the argument . So in this case , product - floor ( product ) will give us the decimal part of product", "code": "long double decimal_part = product - floor ( product ) ;"}
{"text": "we now exponentiate this back by raising 10 to the power of decimal part", "code": "decimal_part = pow ( 10 , decimal_part ) ;"}
{"text": "We now try to find the power of 10 by which we will have to multiply the decimal part to obtain our final answer", "code": "long long digits = pow ( 10 , k - 1 ) , i = 0 ; return decimal_part * digits ; }"}
{"text": "driver function", "code": "int main ( ) { int n = 1450 ; int k = 6 ; cout << firstkdigits ( n , k ) ; return 0 ; }"}
{"text": "C program of finding modulo multiplication", "code": "#include <stdio.h>"}
{"text": "Returns ( a * b ) % mod", "code": "long long moduloMultiplication ( long long a , long long b , long long mod ) {"}
{"text": "Update a if it is more than or equal to mod", "code": "a %= mod ; while ( b ) {"}
{"text": "If b is odd , add a with result", "code": "if ( b & 1 ) res = ( res + a ) % mod ;"}
{"text": "Here we assume that doing 2 * a doesn 't cause overflow", "code": "a = ( 2 * a ) % mod ;"}
{"text": "b >>= 1 ; b = b / 2", "code": "} return res ; }"}
{"text": "Driver program", "code": "int main ( ) { long long a = 10123465234878998 ; long long b = 65746311545646431 ; long long m = 10005412336548794 ; printf ( \" % lld \" , moduloMultiplication ( a , b , m ) ) ; return 0 ; }"}
{"text": "Updating n with 2 n", "code": "n = 2 * n ;"}
{"text": "( n & ( n - 1 ) ) = > Checking whether we can write 2 n as 2 ^ k if yes ( can 't represent 2n as 2^k) then answer 1  if no (can represent 2n as 2^k) then answer 0", "code": "return ( ( n & ( n - 1 ) ) != 0 ) ; } int main ( ) { long long int n = 10 ; printf ( \" % lld \" , canBeSumofConsec ( n ) ) ; }"}
{"text": "A C program to implement Game of Nim . The program assumes that both players are playing optimally", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE #define COMPUTER  1 NEW_LINE #define HUMAN  2"}
{"text": "A Structure to hold the two parameters of a move A move has two parameters - 1 ) pile_index = The index of pile from which stone is going to be removed 2 ) stones_removed = Number of stones removed from the pile indexed = pile_index", "code": "struct move { int pile_index ; int stones_removed ; } ;"}
{"text": "A C function to output the current game state .", "code": "void showPiles ( int piles [ ] , int n ) { int i ; printf ( \" Current ▁ Game ▁ Status ▁ - > ▁ \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , piles [ i ] ) ; printf ( \" STRNEWLINE \" ) ; return ; }"}
{"text": "A C function that returns True if game has ended and False if game is not yet over", "code": "bool gameOver ( int piles [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( piles [ i ] != 0 ) return ( false ) ; return ( true ) ; }"}
{"text": "A C function to declare the winner of the game", "code": "void declareWinner ( int whoseTurn ) { if ( whoseTurn == COMPUTER ) printf ( \" HUMAN won \" else printf ( \" COMPUTER won \" return ; }"}
{"text": "A C function to calculate the Nim - Sum at any point of the game .", "code": "int calculateNimSum ( int piles [ ] , int n ) { int i , nimsum = piles [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) nimsum = nimsum ^ piles [ i ] ; return ( nimsum ) ; }"}
{"text": "A C function to make moves of the Nim Game", "code": "void makeMove ( int piles [ ] , int n , struct move * moves ) { int i , nim_sum = calculateNimSum ( piles , n ) ;"}
{"text": "The player having the current turn is on a winning position . So he / she / it play optimally and tries to make Nim - Sum as 0", "code": "if ( nim_sum != 0 ) { for ( i = 0 ; i < n ; i ++ ) {"}
{"text": "If this is not an illegal move then make this move .", "code": "if ( ( piles [ i ] ^ nim_sum ) < piles [ i ] ) { ( * moves ) . pile_index = i ; ( * moves ) . stones_removed = piles [ i ] - ( piles [ i ] ^ nim_sum ) ; piles [ i ] = ( piles [ i ] ^ nim_sum ) ; break ; } } }"}
{"text": "If you want to input yourself then remove the rand ( ) functions and modify the code to take inputs . But remember , you still won 't be able to change your  fate/prediction.", "code": "else {"}
{"text": "Create an array to hold indices of non - empty piles", "code": "int non_zero_indices [ n ] , count ; for ( i = 0 , count = 0 ; i < n ; i ++ ) if ( piles [ i ] > 0 ) non_zero_indices [ count ++ ] = i ; ( * moves ) . pile_index = ( rand ( ) % ( count ) ) ; ( * moves ) . stones_removed = 1 + ( rand ( ) % ( piles [ ( * moves ) . pile_index ] ) ) ; piles [ ( * moves ) . pile_index ] = piles [ ( * moves ) . pile_index ] - ( * moves ) . stones_removed ; if ( piles [ ( * moves ) . pile_index ] < 0 ) piles [ ( * moves ) . pile_index ] = 0 ; } return ; }"}
{"text": "A C function to play the Game of Nim", "code": "void playGame ( int piles [ ] , int n , int whoseTurn ) { printf ( \" GAME STARTS \" struct move moves ; while ( gameOver ( piles , n ) == false ) { showPiles ( piles , n ) ; makeMove ( piles , n , & moves ) ; if ( whoseTurn == COMPUTER ) { printf ( \" COMPUTER ▁ removes ▁ % d ▁ stones ▁ from ▁ pile ▁ \" \" at ▁ index ▁ % d STRNEWLINE \" , moves . stones_removed , moves . pile_index ) ; whoseTurn = HUMAN ; } else { printf ( \" HUMAN ▁ removes ▁ % d ▁ stones ▁ from ▁ pile ▁ at ▁ \" \" index ▁ % d STRNEWLINE \" , moves . stones_removed , moves . pile_index ) ; whoseTurn = COMPUTER ; } } showPiles ( piles , n ) ; declareWinner ( whoseTurn ) ; return ; } void knowWinnerBeforePlaying ( int piles [ ] , int n , int whoseTurn ) { printf ( \" Prediction ▁ before ▁ playing ▁ the ▁ game ▁ - > ▁ \" ) ; if ( calculateNimSum ( piles , n ) != 0 ) { if ( whoseTurn == COMPUTER ) printf ( \" COMPUTER ▁ will ▁ win STRNEWLINE \" ) ; else printf ( \" HUMAN ▁ will ▁ win STRNEWLINE \" ) ; } else { if ( whoseTurn == COMPUTER ) printf ( \" HUMAN ▁ will ▁ win STRNEWLINE \" ) ; else printf ( \" COMPUTER ▁ will ▁ win STRNEWLINE \" ) ; } return ; }"}
{"text": "Driver program to test above functions", "code": "int main ( ) {"}
{"text": "Test Case 1", "code": "int piles [ ] = { 3 , 4 , 5 } ; int n = sizeof ( piles ) / sizeof ( piles [ 0 ] ) ;"}
{"text": "We will predict the results before playing The COMPUTER starts first", "code": "knowWinnerBeforePlaying ( piles , n , COMPUTER ) ;"}
{"text": "Let us play the game with COMPUTER starting first and check whether our prediction was right or not", "code": "playGame ( piles , n , COMPUTER ) ;"}
{"text": "Test Case 2 int piles [ ] = { 3 , 4 , 7 } ; int n = sizeof ( piles ) / sizeof ( piles [ 0 ] ) ; We will predict the results before playing The HUMAN ( You ) starts first", "code": "knowWinnerBeforePlaying ( piles , n , COMPUTER ) ;"}
{"text": "Let us play the game with COMPUTER starting first and check whether our prediction was right or not playGame ( piles , n , HUMAN ) ;", "code": "return ( 0 ) ; }"}
{"text": "C program to find roots of a quadratic equation", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Prints roots of quadratic equation ax * 2 + bx + x", "code": "void findRoots ( int a , int b , int c ) {"}
{"text": "If a is 0 , then equation is not quadratic , but linear", "code": "if ( a == 0 ) { printf ( \" Invalid \" ) ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { printf ( \" Roots ▁ are ▁ real ▁ and ▁ different ▁ STRNEWLINE \" ) ; printf ( \" % f % f \" , ( double ) ( - b + sqrt_val ) / ( 2 * a ) , ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ; } else if ( d == 0 ) { printf ( \" Roots ▁ are ▁ real ▁ and ▁ same ▁ STRNEWLINE \" ) ; printf ( \" % f \" , - ( double ) b / ( 2 * a ) ) ; }"}
{"text": "else d < 0", "code": "{ printf ( \" Roots ▁ are ▁ complex ▁ STRNEWLINE \" ) ; printf ( \" % f ▁ + ▁ i % f % f - i % f \" , - ( double ) b / ( 2 * a ) , sqrt_val / ( 2 * a ) , - ( double ) b / ( 2 * a ) , sqrt_val / ( 2 * a ) ; } }"}
{"text": "Driver code", "code": "int main ( ) { int a = 1 , b = -7 , c = 12 ;"}
{"text": "Function call", "code": "findRoots ( a , b , c ) ; return 0 ; }"}
{"text": "C program to convert a number from any base to decimal", "code": "#include <stdio.h> NEW_LINE #include <string.h>"}
{"text": "To return value of a char . For example , 2 is returned for '2' . 10 is returned for ' A ' , 11 for ' B '", "code": "int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; }"}
{"text": "Function to convert a number from given base ' b ' to decimal", "code": "int toDeci ( char * str , int base ) { int len = strlen ( str ) ;"}
{"text": "Initialize power of base", "code": "int power = 1 ;"}
{"text": "Initialize result", "code": "int num = 0 ; int i ;"}
{"text": "Decimal equivalent is str [ len - 1 ] * 1 + str [ len - 2 ] * base + str [ len - 3 ] * ( base ^ 2 ) + ...", "code": "for ( i = len - 1 ; i >= 0 ; i -- ) {"}
{"text": "A digit in input number must be less than number 's base", "code": "if ( val ( str [ i ] ) >= base ) { printf ( \" Invalid ▁ Number \" ) ; return -1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; }"}
{"text": "Driver code", "code": "int main ( ) { char str [ ] = \"11A \" ; int base = 16 ; printf ( \" Decimal ▁ equivalent ▁ of ▁ % s ▁ in ▁ base ▁ % d ▁ is ▁ \" \" ▁ % d STRNEWLINE \" , str , base , toDeci ( str , base ) ) ; return 0 ; }"}
{"text": "C Program to print the solution of the series f ( n ) = ( 1 ) + ( 2 * 3 ) + ( 4 * 5 * 6 ) . . . n using recursion", "code": "#include <stdio.h>"}
{"text": "Recursive function for finding sum of series calculated - number of terms till which sum of terms has been calculated current - number of terms for which sum has to becalculated N - Number of terms in the function to be calculated", "code": "int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ;"}
{"text": "checking termination condition", "code": "if ( current == N + 1 ) return 0 ;"}
{"text": "product of terms till current", "code": "for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ;"}
{"text": "recursive call for adding terms next in the series", "code": "return cur + seriesSum ( i , current + 1 , N ) ; }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "input number of terms in the series", "code": "int N = 5 ;"}
{"text": "invoking the function to calculate the sum", "code": "printf ( \" % d STRNEWLINE \" , seriesSum ( 1 , 1 , N ) ) ; return 0 ; }"}
{"text": "C program for Fibonacci Encoding of a positive integer n", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "To limit on the largest Fibonacci number to be used", "code": "#define N  30"}
{"text": "Array to store fibonacci numbers . fib [ i ] is going to store ( i + 2 ) 'th Fibonacci number", "code": "int fib [ N ] ;"}
{"text": "Stores values in fib and returns index of the largest fibonacci number smaller than n .", "code": "int largestFiboLessOrEqual ( int n ) {"}
{"text": "Fib [ 0 ] stores 2 nd Fibonacci No .", "code": "fib [ 0 ] = 1 ;"}
{"text": "Fib [ 1 ] stores 3 rd Fibonacci No .", "code": "fib [ 1 ] = 2 ;"}
{"text": "Keep Generating remaining numbers while previously generated number is smaller", "code": "int i ; for ( i = 2 ; fib [ i - 1 ] <= n ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ;"}
{"text": "Return index of the largest fibonacci number smaller than or equal to n . Note that the above loop stopped when fib [ i - 1 ] became larger .", "code": "return ( i - 2 ) ; }"}
{"text": "Returns pointer to the char string which corresponds to code for n", "code": "char * fibonacciEncoding ( int n ) { int index = largestFiboLessOrEqual ( n ) ;"}
{"text": "allocate memory for codeword", "code": "char * codeword = ( char * ) malloc ( sizeof ( char ) * ( index + 3 ) ) ;"}
{"text": "index of the largest Fibonacci f <= n", "code": "int i = index ; while ( n ) {"}
{"text": "Mark usage of Fibonacci f ( 1 bit )", "code": "codeword [ i ] = '1' ;"}
{"text": "Subtract f from n", "code": "n = n - fib [ i ] ;"}
{"text": "Move to Fibonacci just smaller than f", "code": "i = i - 1 ;"}
{"text": "Mark all Fibonacci > n as not used ( 0 bit ) , progress backwards", "code": "while ( i >= 0 && fib [ i ] > n ) { codeword [ i ] = '0' ; i = i - 1 ; } }"}
{"text": "additional '1' bit", "code": "codeword [ index + 1 ] = '1' ; codeword [ index + 2 ] = ' \\0' ;"}
{"text": "return pointer to codeword", "code": "return codeword ; }"}
{"text": "driver function", "code": "int main ( ) { int n = 143 ; printf ( \" Fibonacci ▁ code ▁ word ▁ for ▁ % d ▁ is ▁ % s STRNEWLINE \" , n , fibonacciEncoding ( n ) ) ; return 0 ; }"}
{"text": "C program to count squares in a rectangle of size m x n", "code": "#include <stdio.h>"}
{"text": "Returns count of all squares in a rectangle of size m x n", "code": "int countSquares ( int m , int n ) {"}
{"text": "If n is smaller , swap m and n", "code": "if ( n < m ) { int temp = m ; m = n ; n = temp ; }"}
{"text": "Now n is greater dimension , apply formula", "code": "return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }"}
{"text": "Driver Code", "code": "int main ( ) { int m = 4 , n = 3 ; printf ( \" Count ▁ of ▁ squares ▁ is ▁ % d \" , countSquares ( m , n ) ) ; }"}
{"text": "This functions finds all primes smaller than ' limit ' using simple sieve of eratosthenes .", "code": "void simpleSieve ( int limit ) {"}
{"text": "Create a boolean array \" mark [ 0 . . limit - 1 ] \" and initialize all entries of it as true . A value in mark [ p ] will finally be false if ' p ' is Not a prime , else true .", "code": "bool mark [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) { mark [ i ] = true ; }"}
{"text": "One by one traverse all numbers so that their multiples can be marked as composite .", "code": "for ( int p = 2 ; p * p < limit ; p ++ ) {"}
{"text": "If p is not changed , then it is a prime", "code": "if ( mark [ p ] == true ) {"}
{"text": "Update all multiples of p", "code": "for ( int i = p * p ; i < limit ; i += p ) mark [ i ] = false ; } }"}
{"text": "Print all prime numbers and store them in prime", "code": "for ( int p = 2 ; p < limit ; p ++ ) if ( mark [ p ] == true ) cout << p << \" ▁ \" ; }"}
{"text": "Iterative C program to find modular inverse using extended Euclid algorithm", "code": "#include <stdio.h>"}
{"text": "Returns modulo inverse of a with respect to m using extended Euclid Algorithm Assumption : a and m are coprimes , i . e . , gcd ( a , m ) = 1", "code": "int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) {"}
{"text": "q is quotient", "code": "int q = a / m ; int t = m ;"}
{"text": "m is remainder now , process same as Euclid 's algo", "code": "m = a % m , a = t ; t = y ;"}
{"text": "Update y and x", "code": "y = x - q * y ; x = t ; }"}
{"text": "Make x positive", "code": "if ( x < 0 ) x += m0 ; return x ; }"}
{"text": "Driver Code", "code": "int main ( ) { int a = 3 , m = 11 ;"}
{"text": "Function call", "code": "printf ( \" Modular ▁ multiplicative ▁ inverse ▁ is ▁ % d STRNEWLINE \" , modInverse ( a , m ) ) ; return 0 ; }"}
{"text": "A simple C program to calculate Euler 's Totient Function", "code": "#include <stdio.h>"}
{"text": "Function to return gcd of a and b", "code": "int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }"}
{"text": "A simple method to evaluate Euler Totient Function", "code": "int phi ( unsigned int n ) { unsigned int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) printf ( \" phi ( % d ) ▁ = ▁ % d STRNEWLINE \" , n , phi ( n ) ) ; return 0 ; }"}
{"text": "C program to calculate Euler ' s ▁ Totient ▁ Function ▁ using ▁ Euler ' s product formula", "code": "#include <stdio.h> NEW_LINE int phi ( int n ) {"}
{"text": "Consider all prime factors of n and for every prime factor p , multiply result with ( 1 - 1 / p )", "code": "for ( int p = 2 ; p * p <= n ; ++ p ) {"}
{"text": "Check if p is a prime factor .", "code": "if ( n % p == 0 ) {"}
{"text": "If yes , then update n and result", "code": "while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } }"}
{"text": "If n has a prime factor greater than sqrt ( n ) ( There can be at - most one such prime factor )", "code": "if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) printf ( \" phi ( % d ) ▁ = ▁ % d STRNEWLINE \" , n , phi ( n ) ) ; return 0 ; }"}
{"text": "C program to print first n Fibonacci numbers", "code": "#include <stdio.h>"}
{"text": "Function to print first n Fibonacci Numbers", "code": "void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; printf ( \" % d ▁ \" , f1 ) ; for ( i = 1 ; i < n ; i ++ ) { printf ( \" % d ▁ \" , f2 ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }"}
{"text": "Driver Code", "code": "int main ( ) { printFibonacciNumbers ( 7 ) ; return 0 ; }"}
{"text": "C program to find LCM of two numbers", "code": "#include <stdio.h>"}
{"text": "Recursive function to return gcd of a and b", "code": "int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }"}
{"text": "Function to return LCM of two numbers", "code": "int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int a = 15 , b = 20 ; printf ( \" LCM ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ \" , a , b , lcm ( a , b ) ) ; return 0 ; }"}
{"text": "C program to print a given number in words . The program handles numbers from 0 to 9999", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h>"}
{"text": "A function that prints given number in words", "code": "void convert_to_words ( char * num ) { int len = strlen ("}
{"text": "Base cases", "code": "if ( len == 0 ) { fprintf ( stderr , \" empty ▁ string STRNEWLINE \" ) ; return ; } if ( len > 4 ) { fprintf ( stderr , \" Length ▁ more ▁ than ▁ 4 ▁ is ▁ not ▁ supported STRNEWLINE \" ) ; return ; }"}
{"text": "The first string is not used , it is to make array indexing simple", "code": "char * single_digits [ ] = { \" zero \" , \" one \" , \" two \" , \" three \" , \" four \" , \" five \" , \" six \" , \" seven \" , \" eight \" , \" nine \" } ;"}
{"text": "The first string is not used , it is to make array indexing simple", "code": "char * two_digits [ ] = { \" \" , \" ten \" , \" eleven \" , \" twelve \" , \" thirteen \" , \" fourteen \" , \" fifteen \" , \" sixteen \" , \" seventeen \" , \" eighteen \" , \" nineteen \" } ;"}
{"text": "The first two string are not used , they are to make array indexing simple", "code": "char * tens_multiple [ ] = { \" \" , \" \" , \" twenty \" , \" thirty \" , \" forty \" , \" fifty \" , \" sixty \" , \" seventy \" , \" eighty \" , \" ninety \" } ; char * tens_power [ ] = { \" hundred \" , \" thousand \" } ;"}
{"text": "Used for debugging purpose only", "code": "printf ( \" % s : \" , num ) ;"}
{"text": "For single digit number", "code": "if ( len == 1 ) { printf ( \" % s STRNEWLINE \" , single_digits [ * num - '0' ] ) ; return ; }"}
{"text": "Iterate while num is not ' \\0'", "code": "while ( * num != ' \\0' ) {"}
{"text": "Code path for first 2 digits", "code": "if ( len >= 3 ) { if ( * num - '0' != 0 ) { printf ( \" % s ▁ \" , single_digits [ * num - '0' ] ) ; printf ( \" % s ▁ \" ,"}
{"text": "tens_power [ len - 3 ] ) ; here len can be 3 or 4", "code": "} -- len ; }"}
{"text": "Code path for last 2 digits", "code": "else {"}
{"text": "Need to explicitly handle 10 - 19. Sum of the two digits is used as index of \" two _ digits \" array of strings", "code": "if ( * num == '1' ) { int sum = * num - '0' + * ( num + 1 ) - '0' ; printf ( \" % s STRNEWLINE \" , two_digits [ sum ] ) ; return ; }"}
{"text": "Need to explicitely handle 20", "code": "else if ( * num = = '2' && * ( num + 1 ) == '0' ) { printf ( \" twenty STRNEWLINE \" ) ; return ; }"}
{"text": "Rest of the two digit numbers i . e . , 21 to 99", "code": "else { int i = * num - '0' ; printf ( \" % s ▁ \" , i ? tens_multiple [ i ] : \" \" ) ; ++ num ; if ( * num != '0' ) printf ( \" % s ▁ \" , single_digits [ * num - '0' ] ) ; } } ++ num ; } }"}
{"text": "Driver program to test above function", "code": "int main ( void ) { convert_to_words ( \"9923\" ) ; convert_to_words ( \"523\" ) ; convert_to_words ( \"89\" ) ; convert_to_words ( \"8\" ) ; return 0 ; }"}
{"text": "Driver code", "code": "int main ( ) { printf ( \" Sum ▁ = ▁ % d \" , add ( 3 , 4 ) ) ; return 0 ; }"}
{"text": "Assuming that integer takes 4 bytes , there can be maximum 10 digits in a integer", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE # define MAX  11 NEW_LINE bool isMultipleof5 ( int n ) { char str [ MAX ] ; int len = strlen ( str ) ;"}
{"text": "Check the last character of string", "code": "if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; }"}
{"text": "Driver Code", "code": "int main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) printf ( \" % d ▁ is ▁ multiple ▁ of ▁ 5 STRNEWLINE \" , n ) ; else printf ( \" % d ▁ is ▁ not ▁ a ▁ multiple ▁ of ▁ 5 STRNEWLINE \" , n ) ; return 0 ; }"}
{"text": "C program to implement the above approach", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Structure of a node in XOR linked list", "code": "struct Node {"}
{"text": "Stores data value of a node", "code": "int data ;"}
{"text": "Stores XOR of previous pointer and next pointer", "code": "struct Node * nxp ; } ;"}
{"text": "Function to find the XOR of address of two nodes", "code": "struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; }"}
{"text": "Function to insert a node with given value at given position", "code": "struct Node * insert ( struct Node * * head , int value ) {"}
{"text": "If XOR linked list is empty", "code": "if ( * head == NULL ) {"}
{"text": "Initialize a new Node", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Stores data value in the node", "code": "node -> data = value ;"}
{"text": "Stores XOR of previous and next pointer", "code": "node -> nxp = XOR ( NULL , NULL ) ;"}
{"text": "Update pointer of head node", "code": "* head = node ; }"}
{"text": "If the XOR linked list is not empty", "code": "else {"}
{"text": "Stores the address of current node", "code": "struct Node * curr = * head ;"}
{"text": "Stores the address of previous node", "code": "struct Node * prev = NULL ;"}
{"text": "Initialize a new Node", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Update curr node address", "code": "curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ;"}
{"text": "Update new node address", "code": "node -> nxp = XOR ( NULL , curr ) ;"}
{"text": "Update head", "code": "* head = node ;"}
{"text": "Update data value of current node", "code": "node -> data = value ; } return * head ; }"}
{"text": "Function to print elements of the XOR Linked List", "code": "void printList ( struct Node * * head ) {"}
{"text": "Stores XOR pointer in current node", "code": "struct Node * curr = * head ;"}
{"text": "Stores XOR pointer of in previous Node", "code": "struct Node * prev = NULL ;"}
{"text": "Stores XOR pointer of in next node", "code": "struct Node * next ;"}
{"text": "Traverse XOR linked list", "code": "while ( curr != NULL ) {"}
{"text": "Print current node", "code": "printf ( \" % d ▁ \" , curr -> data ) ;"}
{"text": "Forward traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Update prev", "code": "prev = curr ;"}
{"text": "Update curr", "code": "curr = next ; } }"}
{"text": "Reverse the linked list in group of K", "code": "struct Node * RevInGrp ( struct Node * * head , int K , int len ) {"}
{"text": "Stores head node", "code": "struct Node * curr = * head ;"}
{"text": "If the XOR linked list is empty", "code": "if ( curr == NULL ) return NULL ;"}
{"text": "Stores count of nodes reversed in current group", "code": "int count = 0 ;"}
{"text": "Stores XOR pointer of in previous Node", "code": "struct Node * prev = NULL ;"}
{"text": "Stores XOR pointer of in next node", "code": "struct Node * next ;"}
{"text": "Reverse nodes in current group", "code": "while ( count < K && count < len ) {"}
{"text": "Forward traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Update prev", "code": "prev = curr ;"}
{"text": "Update curr", "code": "curr = next ;"}
{"text": "Update count", "code": "count ++ ; }"}
{"text": "Disconnect prev node from the next node", "code": "prev -> nxp = XOR ( NULL , XOR ( prev -> nxp , curr ) ) ;"}
{"text": "Disconnect curr from previous node", "code": "if ( curr != NULL ) curr -> nxp = XOR ( XOR ( curr -> nxp , prev ) , NULL ) ;"}
{"text": "If the count of remaining nodes is less than K", "code": "if ( len < K ) { return prev ; } else {"}
{"text": "Update len", "code": "len -= K ;"}
{"text": "Recursively process the next nodes", "code": "struct Node * dummy = RevInGrp ( & curr , K , len ) ;"}
{"text": "Connect the head pointer with the prev", "code": "( * head ) -> nxp = XOR ( XOR ( NULL , ( * head ) -> nxp ) , dummy ) ;"}
{"text": "Connect prev with the head", "code": "if ( dummy != NULL ) dummy -> nxp = XOR ( XOR ( dummy -> nxp , NULL ) , * head ) ; return prev ; } }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Create following XOR Linked List head -- > 7 < a > 6 < a > 8 < a > 11 < a > 3 < a > 1 < a > 2 < a > 0", "code": "struct Node * head = NULL ; insert ( & head , 0 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; insert ( & head , 3 ) ; insert ( & head , 11 ) ; insert ( & head , 8 ) ; insert ( & head , 6 ) ; insert ( & head , 7 ) ;"}
{"text": "Function Call", "code": "head = RevInGrp ( & head , 3 , 8 ) ;"}
{"text": "Print the reversed list", "code": "printList ( & head ) ; return ( 0 ) ; }"}
{"text": "C program for the above approach", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Structure of a node in XOR linked list", "code": "struct Node {"}
{"text": "Stores data value of a node", "code": "int data ;"}
{"text": "Stores XOR of previous pointer and next pointer", "code": "struct Node * nxp ; } ;"}
{"text": "Function to find the XOR of two nodes", "code": "struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; }"}
{"text": "Function to insert a node with given value at beginning position", "code": "struct Node * insert ( struct Node * * head , int value ) {"}
{"text": "If XOR linked list is empty", "code": "if ( * head == NULL ) {"}
{"text": "Initialize a new Node", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Stores data value in the node", "code": "node -> data = value ;"}
{"text": "Stores XOR of previous and next pointer", "code": "node -> nxp = XOR ( NULL , NULL ) ;"}
{"text": "Update pointer of head node", "code": "* head = node ; }"}
{"text": "If the XOR linked list is not empty", "code": "else {"}
{"text": "Stores the address of current node", "code": "struct Node * curr = * head ;"}
{"text": "Stores the address of previous node", "code": "struct Node * prev = NULL ;"}
{"text": "Initialize a new Node", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Update curr node address", "code": "curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ;"}
{"text": "Update new node address", "code": "node -> nxp = XOR ( NULL , curr ) ;"}
{"text": "Update head", "code": "* head = node ;"}
{"text": "Update data value of current node", "code": "node -> data = value ; } return * head ; }"}
{"text": "Function to print elements of the XOR Linked List", "code": "void printList ( struct Node * * head ) {"}
{"text": "Stores XOR pointer in current node", "code": "struct Node * curr = * head ;"}
{"text": "Stores XOR pointer of in previous Node", "code": "struct Node * prev = NULL ;"}
{"text": "Stores XOR pointer of in next node", "code": "struct Node * next ;"}
{"text": "Traverse XOR linked list", "code": "while ( curr != NULL ) {"}
{"text": "Print current node", "code": "printf ( \" % d ▁ \" , curr -> data ) ;"}
{"text": "Forward traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Update prev", "code": "prev = curr ;"}
{"text": "Update curr", "code": "curr = next ; } printf ( \" STRNEWLINE \" ) ; }"}
{"text": "Function to reverse the XOR linked list", "code": "struct Node * reverse ( struct Node * * head ) {"}
{"text": "Stores XOR pointer in current node", "code": "struct Node * curr = * head ; if ( curr == NULL ) return NULL ; else {"}
{"text": "Stores XOR pointer of in previous Node", "code": "struct Node * prev = NULL ;"}
{"text": "Stores XOR pointer of in next node", "code": "struct Node * next ; while ( XOR ( prev , curr -> nxp ) != NULL ) {"}
{"text": "Forward traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Update prev", "code": "prev = curr ;"}
{"text": "Update curr", "code": "curr = next ; }"}
{"text": "Update the head pointer", "code": "* head = curr ; return * head ; } }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Create following XOR Linked List head -- > 40 < -- > 30 < -- > 20 < -- > 10", "code": "struct Node * head = NULL ; insert ( & head , 10 ) ; insert ( & head , 20 ) ; insert ( & head , 30 ) ; insert ( & head , 40 ) ;"}
{"text": "Reverse the XOR Linked List to give head -- > 10 < -- > 20 < -- > 30 < -- > 40", "code": "printf ( \" XOR ▁ linked ▁ list : ▁ \" ) ; printList ( & head ) ; reverse ( & head ) ; printf ( \" Reversed ▁ XOR ▁ linked ▁ list : ▁ \" ) ; printList ( & head ) ; return ( 0 ) ; }"}
{"text": "C program to implement the above approach", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Structure of a node in XOR linked list", "code": "struct Node {"}
{"text": "Stores data value of a node", "code": "int data ;"}
{"text": "Stores XOR of previous pointer and next pointer", "code": "struct Node * nxp ; } ;"}
{"text": "Function to find the XOR of two nodes", "code": "struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; }"}
{"text": "Function to insert a node with given value at given position", "code": "struct Node * insert ( struct Node * * head , int value ) {"}
{"text": "If XOR linked list is empty", "code": "if ( * head == NULL ) {"}
{"text": "Initialize a new Node", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Stores data value in the node", "code": "node -> data = value ;"}
{"text": "Stores XOR of previous and next pointer", "code": "node -> nxp = XOR ( NULL , NULL ) ;"}
{"text": "Update pointer of head node", "code": "* head = node ; }"}
{"text": "If the XOR linked list is not empty", "code": "else {"}
{"text": "Stores the address of current node", "code": "struct Node * curr = * head ;"}
{"text": "Stores the address of previous node", "code": "struct Node * prev = NULL ;"}
{"text": "Initialize a new Node", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Update curr node address", "code": "curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ;"}
{"text": "Update new node address", "code": "node -> nxp = XOR ( NULL , curr ) ;"}
{"text": "Update head", "code": "* head = node ;"}
{"text": "Update data value of current node", "code": "node -> data = value ; } return * head ; }"}
{"text": "Function to print elements of the XOR Linked List", "code": "void printList ( struct Node * * head ) {"}
{"text": "Stores XOR pointer in current node", "code": "struct Node * curr = * head ;"}
{"text": "Stores XOR pointer of in previous Node", "code": "struct Node * prev = NULL ;"}
{"text": "Stores XOR pointer of in next node", "code": "struct Node * next ;"}
{"text": "Traverse XOR linked list", "code": "while ( curr != NULL ) {"}
{"text": "Print current node", "code": "printf ( \" % d ▁ \" , curr -> data ) ;"}
{"text": "Forward traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Update prev", "code": "prev = curr ;"}
{"text": "Update curr", "code": "curr = next ; } } struct Node * NthNode ( struct Node * * head , int N ) { int count = 0 ;"}
{"text": "Stores XOR pointer in current node", "code": "struct Node * curr = * head ; struct Node * curr1 = * head ;"}
{"text": "Stores XOR pointer of in previous Node", "code": "struct Node * prev = NULL ; struct Node * prev1 = NULL ;"}
{"text": "Stores XOR pointer of in next node", "code": "struct Node * next ; struct Node * next1 ; while ( count < N && curr != NULL ) {"}
{"text": "Forward traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Update prev", "code": "prev = curr ;"}
{"text": "Update curr", "code": "curr = next ; count ++ ; } if ( curr == NULL && count < N ) { printf ( \" Wrong ▁ Input \" ) ; return ( uintptr_t ) 0 ; } else { while ( curr != NULL ) {"}
{"text": "Forward traversal", "code": "next = XOR ( prev , curr -> nxp ) ; next1 = XOR ( prev1 , curr1 -> nxp ) ;"}
{"text": "Update prev", "code": "prev = curr ; prev1 = curr1 ;"}
{"text": "Update curr", "code": "curr = next ; curr1 = next1 ; } printf ( \" % d \" , curr1 -> data ) ; } }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Create following XOR Linked List head -- > 7 a > 6 a > 8 a > 11 a > 3 a > 1 a > 2 a > 0", "code": "struct Node * head = NULL ; insert ( & head , 0 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; insert ( & head , 3 ) ; insert ( & head , 11 ) ; insert ( & head , 8 ) ; insert ( & head , 6 ) ; insert ( & head , 7 ) ; NthNode ( & head , 3 ) ; return ( 0 ) ; }"}
{"text": "C program to implement the above approach", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Structure of a node in XOR linked list", "code": "struct Node {"}
{"text": "Stores data value of a node", "code": "int data ;"}
{"text": "Stores XOR of previous pointer and next pointer", "code": "struct Node * nxp ; } ;"}
{"text": "Function to find the XOR of two nodes", "code": "struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; }"}
{"text": "Function to insert a node with given value at given position", "code": "struct Node * insert ( struct Node * * head , int value ) {"}
{"text": "If XOR linked list is empty", "code": "if ( * head == NULL ) {"}
{"text": "Initialize a new Node", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Stores data value in the node", "code": "node -> data = value ;"}
{"text": "Stores XOR of previous and next pointer", "code": "node -> nxp = XOR ( NULL , NULL ) ;"}
{"text": "Update pointer of head node", "code": "* head = node ; }"}
{"text": "If the XOR linked list is not empty", "code": "else {"}
{"text": "Stores the address of current node", "code": "struct Node * curr = * head ;"}
{"text": "Stores the address of previous node", "code": "struct Node * prev = NULL ;"}
{"text": "Initialize a new Node", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Update curr node address", "code": "curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ;"}
{"text": "Update new node address", "code": "node -> nxp = XOR ( NULL , curr ) ;"}
{"text": "Update head", "code": "* head = node ;"}
{"text": "Update data value of current node", "code": "node -> data = value ; } return * head ; }"}
{"text": "Function to print the middle node", "code": "int printMiddle ( struct Node * * head , int len ) { int count = 0 ;"}
{"text": "Stores XOR pointer in current node", "code": "struct Node * curr = * head ;"}
{"text": "Stores XOR pointer of in previous Node", "code": "struct Node * prev = NULL ;"}
{"text": "Stores XOR pointer of in next node", "code": "struct Node * next ; int middle = ( int ) len / 2 ;"}
{"text": "Traverse XOR linked list", "code": "while ( count != middle ) {"}
{"text": "Forward traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Update prev", "code": "prev = curr ;"}
{"text": "Update curr", "code": "curr = next ; count ++ ; }"}
{"text": "If the length of the linked list is odd", "code": "if ( len & 1 ) { printf ( \" % d \" , curr -> data ) ; }"}
{"text": "If the length of the linked list is even", "code": "else { printf ( \" % d ▁ % d \" , prev -> data , curr -> data ) ; } }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Create following XOR Linked List head -- > 4 a > 7 a > 5", "code": "struct Node * head = NULL ; insert ( & head , 4 ) ; insert ( & head , 7 ) ; insert ( & head , 5 ) ; printMiddle ( & head , 3 ) ; return ( 0 ) ; }"}
{"text": "C ++ program to implement the above approach", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Structure of a node in XOR linked list", "code": "struct Node {"}
{"text": "Stores data value of a node", "code": "int data ;"}
{"text": "Stores XOR of previous pointer and next pointer", "code": "struct Node * nxp ; } ;"}
{"text": "Function to find the XOR of two nodes", "code": "struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; }"}
{"text": "Function to insert a node with given value at given position", "code": "struct Node * insert ( struct Node * * head , int value , int position ) {"}
{"text": "If XOR linked list is empty", "code": "if ( * head == NULL ) {"}
{"text": "If given position is equal to 1", "code": "if ( position == 1 ) {"}
{"text": "Initialize a new Node", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Stores data value in the node", "code": "node -> data = value ;"}
{"text": "Stores XOR of previous and next pointer", "code": "node -> nxp = XOR ( NULL , NULL ) ;"}
{"text": "Update pointer of head node", "code": "* head = node ; }"}
{"text": "If required position was not found", "code": "else { printf ( \" Invalid ▁ Position STRNEWLINE \" ) ; } }"}
{"text": "If the XOR linked list is not empty", "code": "else {"}
{"text": "Stores position of a node in the XOR linked list", "code": "int Pos = 1 ;"}
{"text": "Stores the address of current node", "code": "struct Node * curr = * head ;"}
{"text": "Stores the address of previous node", "code": "struct Node * prev = NULL ;"}
{"text": "Stores the XOR of next node and previous node", "code": "struct Node * next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Traverse the XOR linked list", "code": "while ( next != NULL && Pos < position - 1 ) {"}
{"text": "Update prev", "code": "prev = curr ;"}
{"text": "Update curr", "code": "curr = next ;"}
{"text": "Update next", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Update Pos", "code": "Pos ++ ; }"}
{"text": "If the position of the current node is equal to the given position", "code": "if ( Pos == position - 1 ) {"}
{"text": "Initialize a new Node", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Stores pointer to previous Node as ( prev ^ next ^ next ) = prev", "code": "struct Node * temp = XOR ( curr -> nxp , next ) ;"}
{"text": "Stores XOR of prev and new node", "code": "curr -> nxp = XOR ( temp , node ) ;"}
{"text": "Connecting new node with next", "code": "if ( next != NULL ) {"}
{"text": "Update pointer of next", "code": "next -> nxp = XOR ( node , XOR ( next -> nxp , curr ) ) ; }"}
{"text": "Connect node with curr and next curr < -- node -- > next", "code": "node -> nxp = XOR ( curr , next ) ; node -> data = value ; }"}
{"text": "Insertion node at beginning", "code": "else if ( position == 1 ) {"}
{"text": "Initialize a new Node", "code": "struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ;"}
{"text": "Update curr node address", "code": "curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ;"}
{"text": "Update new node address", "code": "node -> nxp = XOR ( NULL , curr ) ;"}
{"text": "Update head", "code": "* head = node ;"}
{"text": "Update data value of current node", "code": "node -> data = value ; } else { printf ( \" Invalid ▁ Position STRNEWLINE \" ) ; } } return * head ; }"}
{"text": "Function to print elements of the XOR Linked List", "code": "void printList ( struct Node * * head ) {"}
{"text": "Stores XOR pointer in current node", "code": "struct Node * curr = * head ;"}
{"text": "Stores XOR pointer of in previous Node", "code": "struct Node * prev = NULL ;"}
{"text": "Stores XOR pointer of in next node", "code": "struct Node * next ;"}
{"text": "Traverse XOR linked list", "code": "while ( curr != NULL ) {"}
{"text": "Print current node", "code": "printf ( \" % d ▁ \" , curr -> data ) ;"}
{"text": "Forward traversal", "code": "next = XOR ( prev , curr -> nxp ) ;"}
{"text": "Update prev", "code": "prev = curr ;"}
{"text": "Update curr", "code": "curr = next ; } }"}
{"text": "Driver Code", "code": "int main ( ) {"}
{"text": "Create following XOR Linked List head -- > 20 < -- > 40 < -- > 10 < -- > 30", "code": "struct Node * head = NULL ; insert ( & head , 10 , 1 ) ; insert ( & head , 20 , 1 ) ; insert ( & head , 30 , 3 ) ; insert ( & head , 40 , 2 ) ;"}
{"text": "Print the new list", "code": "printList ( & head ) ; return ( 0 ) ; }"}
{"text": "C program to toggle K - th bit of a number N", "code": "#include <stdio.h>"}
{"text": "Function to toggle the kth bit of n", "code": "int toggleBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 5 , k = 2 ; printf ( \" % d STRNEWLINE \" , toggleBit ( n , k ) ) ; return 0 ; }"}
{"text": "C program to clear K - th bit of a number N", "code": "#include <stdio.h>"}
{"text": "Function to clear the kth bit of n", "code": "int clearBit ( int n , int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 5 , k = 1 ; printf ( \" % d STRNEWLINE \" , clearBit ( n , k ) ) ; return 0 ; }"}
{"text": "C ++ Program to demonstrate use of right shift operator", "code": "#include <stdio.h> NEW_LINE using namespace std ; int main ( ) {"}
{"text": "a = 5 ( 00000101 ) , b = 9 ( 00001001 )", "code": "unsigned char a = 5 , b = 9 ;"}
{"text": "The result is 00000010", "code": "printf ( \" a > > 1 ▁ = ▁ % d STRNEWLINE \" , a >> 1 ) ;"}
{"text": "The result is 00000100", "code": "printf ( \" b > > 1 ▁ = ▁ % d STRNEWLINE \" , b >> 1 ) ; return 0 ; }"}
{"text": "shift y by 61 bits left", "code": "printf ( \" y ▁ < < ▁ 61 ▁ = ▁ % lld STRNEWLINE \" , y << 61 ) ; return 0 ; }"}
{"text": "C program to do recursive addition of two integers", "code": "#include <stdio.h> NEW_LINE int add ( int x , int y ) { int keep = ( x & y ) << 1 ; int res = x ^ y ;"}
{"text": "If bitwise & is 0 , then there is not going to be any carry . Hence result of XOR is addition .", "code": "if ( keep == 0 ) return res ; add ( keep , res ) ; }"}
{"text": "Driver code", "code": "int main ( ) { printf ( \" % d \" , add ( 15 , 38 ) ) ; return 0 ; }"}
{"text": "C program to find total bit in given number", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE unsigned countBits ( unsigned int number ) {"}
{"text": "log function in base 2 take only integer part", "code": "return ( int ) log2 ( number ) + 1 ; }"}
{"text": "Driven program", "code": "int main ( ) { unsigned int num = 65 ; printf ( \" % d STRNEWLINE \" , countBits ( num ) ) ; return 0 ; }"}
{"text": "Efficient C program to find n - th palindrome", "code": "#include <stdio.h> NEW_LINE #define INT_SIZE  32"}
{"text": "Construct the nth binary palindrome with the given group number , aux_number and operation type", "code": "int constructNthNumber ( int group_no , int aux_num , int op ) { int a [ INT_SIZE ] = { 0 } ; int num = 0 , len_f ; int i = 0 ;"}
{"text": "No need to insert any bit in the middle", "code": "if ( op == 2 ) {"}
{"text": "Length of the final binary representation", "code": "len_f = 2 * group_no ;"}
{"text": "Fill first and last bit as 1", "code": "a [ len_f - 1 ] = a [ 0 ] = 1 ;"}
{"text": "Start filling the a [ ] from middle , with the aux_num binary representation", "code": "while ( aux_num ) {"}
{"text": "Get the auxiliary number 's ith bit and  fill around middle", "code": "a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } }"}
{"text": "Insert bit 0 in the middle", "code": "else if ( op == 0 ) {"}
{"text": "Length of the final binary representation", "code": "len_f = 2 * group_no + 1 ;"}
{"text": "Fill first and last bit as 1", "code": "a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ;"}
{"text": "Start filling the a [ ] from middle , with the aux_num binary representation", "code": "while ( aux_num ) {"}
{"text": "Get the auxiliary number 's ith bit and fill  around middle", "code": "a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } }"}
{"text": "else Insert bit 1 in the middle", "code": "{"}
{"text": "Length of the final binary representation", "code": "len_f = 2 * group_no + 1 ;"}
{"text": "Fill first and last bit as 1", "code": "a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ;"}
{"text": "Start filling the a [ ] from middle , with the aux_num binary representation", "code": "while ( aux_num ) {"}
{"text": "Get the auxiliary number 's ith bit and fill  around middle", "code": "a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } }"}
{"text": "Convert the number to decimal from binary", "code": "for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; }"}
{"text": "Will return the nth binary palindrome number", "code": "int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ;"}
{"text": "Add number of elements in all the groups , until the group of the nth number is found", "code": "while ( count_temp < n ) { group_no ++ ;"}
{"text": "Total number of elements until this group", "code": "count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; }"}
{"text": "Element 's offset position in the group", "code": "group_offset = n - count_upto_group - 1 ;"}
{"text": "Finding which bit to be placed in the middle and finding the number , which we will fill from the middle in both directions", "code": "if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) {"}
{"text": "We need to fill this auxiliary number in binary form the middle in both directions", "code": "aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 )"}
{"text": "op = 0 ; Need to Insert 0 at middle", "code": "else"}
{"text": "op = 1 ; Need to Insert 1 at middle", "code": "aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; }"}
{"text": "Driver code", "code": "int main ( ) { int n = 9 ;"}
{"text": "Function Call", "code": "printf ( \" % d \" , getNthNumber ( n ) ) ; return 0 ; }"}
{"text": "C program to toggle all bits except kth bit", "code": "#include <stdio.h>"}
{"text": "Returns a number with all bit toggled in n except k - th bit", "code": "unsigned int toggleAllExceptK ( unsigned int n , unsigned int k ) {"}
{"text": "1 ) Toggle k - th bit by doing n ^ ( 1 << k ) 2 ) Toggle all bits of the modified number", "code": "return ~ ( n ^ ( 1 << k ) ) ; }"}
{"text": "Driver code", "code": "int main ( ) { unsigned int n = 4294967295 ; unsigned int k = 0 ; printf ( \" % u \" , toggleAllExceptK ( n , k ) ) ; return 0 ; }"}
{"text": "C program to demonstrate working of relational operators", "code": "#include <stdio.h> NEW_LINE int main ( ) { int a = 10 , b = 4 ;"}
{"text": "greater than example", "code": "if ( a > b ) printf ( \" a ▁ is ▁ greater ▁ than ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ less ▁ than ▁ or ▁ equal ▁ to ▁ b STRNEWLINE \" ) ;"}
{"text": "greater than equal to", "code": "if ( a >= b ) printf ( \" a ▁ is ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ lesser ▁ than ▁ b STRNEWLINE \" ) ;"}
{"text": "less than example", "code": "if ( a < b ) printf ( \" a ▁ is ▁ less ▁ than ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ b STRNEWLINE \" ) ;"}
{"text": "lesser than equal to", "code": "if ( a <= b ) printf ( \" a ▁ is ▁ lesser ▁ than ▁ or ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ greater ▁ than ▁ b STRNEWLINE \" ) ;"}
{"text": "equal to", "code": "if ( a == b ) printf ( \" a ▁ is ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ and ▁ b ▁ are ▁ not ▁ equal STRNEWLINE \" ) ;"}
{"text": "not equal to", "code": "if ( a != b ) printf ( \" a ▁ is ▁ not ▁ equal ▁ to ▁ b STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ equal ▁ b STRNEWLINE \" ) ; return 0 ; }"}
{"text": "C program to demonstrate working of logical operators", "code": "#include <stdio.h> NEW_LINE int main ( ) { int a = 10 , b = 4 , c = 10 , d = 20 ;"}
{"text": "logical AND example", "code": "if ( a > b && c == d ) printf ( \" a ▁ is ▁ greater ▁ than ▁ b ▁ AND ▁ c ▁ is ▁ equal ▁ to ▁ d STRNEWLINE \" ) ; else printf ( \" AND ▁ condition ▁ not ▁ satisfied STRNEWLINE \" ) ;"}
{"text": "logical OR example", "code": "if ( a > b c == d ) printf ( \" a ▁ is ▁ greater ▁ than ▁ b ▁ OR ▁ c ▁ is ▁ equal ▁ to ▁ d STRNEWLINE \" ) ; else printf ( \" Neither ▁ a ▁ is ▁ greater ▁ than ▁ b ▁ nor ▁ c ▁ is ▁ equal ▁ \" \" ▁ to ▁ d STRNEWLINE \" ) ;"}
{"text": "logical NOT example", "code": "if ( ! a ) printf ( \" a ▁ is ▁ zero STRNEWLINE \" ) ; else printf ( \" a ▁ is ▁ not ▁ zero \" ) ; return 0 ; }"}
{"text": "C program to swap bits in an integer", "code": "#include <stdio.h>"}
{"text": "This function swaps bit at positions p1 and p2 in an integer n", "code": "int swapBits ( unsigned int n , unsigned int p1 , unsigned int p2 ) {"}
{"text": "Move p1 'th to rightmost side", "code": "unsigned int bit1 = ( n >> p1 ) & 1 ;"}
{"text": "Move p2 'th to rightmost side", "code": "unsigned int bit2 = ( n >> p2 ) & 1 ;"}
{"text": "XOR the two bits", "code": "unsigned int x = ( bit1 ^ bit2 ) ;"}
{"text": "Put the xor bit back to their original positions", "code": "x = ( x << p1 ) | ( x << p2 ) ;"}
{"text": "XOR ' x ' with the original number so that the two sets are swapped", "code": "unsigned int result = n ^ x ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int res = swapBits ( 28 , 0 , 3 ) ; printf ( \" Result ▁ = ▁ % d ▁ \" , res ) ; return 0 ; }"}
{"text": "Function to return the only odd occurring element", "code": "int findOdd ( int arr [ ] , int n ) { int res = 0 , i ; for ( i = 0 ; i < n ; i ++ ) res ^= arr [ i ] ; return res ; }"}
{"text": "Driver Method", "code": "int main ( void ) { int arr [ ] = { 12 , 12 , 14 , 90 , 14 , 14 , 14 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The ▁ odd ▁ occurring ▁ element ▁ is ▁ % d ▁ \" , findOdd ( arr , n ) ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <math.h> NEW_LINE #include <stdio.h>"}
{"text": "Store input bits", "code": "int input [ 32 ] ;"}
{"text": "Store hamming code", "code": "int code [ 32 ] ; int ham_calc ( int , int ) ; void solve ( int input [ ] , int ) ;"}
{"text": "Function to calculate bit for ith position", "code": "int ham_calc ( int position , int c_l ) { int count = 0 , i , j ; i = position - 1 ;"}
{"text": "Traverse to store Hamming Code", "code": "while ( i < c_l ) { for ( j = i ; j < i + position ; j ++ ) {"}
{"text": "If current boit is 1", "code": "if ( code [ j ] == 1 ) count ++ ; }"}
{"text": "Update i", "code": "i = i + 2 * position ; } if ( count % 2 == 0 ) return 0 ; else return 1 ; }"}
{"text": "Function to calculate hamming code", "code": "void solve ( int input [ ] , int n ) { int i , p_n = 0 , c_l , j , k ; i = 0 ;"}
{"text": "Find msg bits having set bit at x 'th position of number", "code": "while ( n > ( int ) pow ( 2 , i ) - ( i + 1 ) ) { p_n ++ ; i ++ ; } c_l = p_n + n ; j = k = 0 ;"}
{"text": "Traverse the msgBits", "code": "for ( i = 0 ; i < c_l ; i ++ ) {"}
{"text": "Update the code", "code": "if ( i == ( ( int ) pow ( 2 , k ) - 1 ) ) { code [ i ] = 0 ; k ++ ; }"}
{"text": "Update the code [ i ] to the input character at index j", "code": "else { code [ i ] = input [ j ] ; j ++ ; } }"}
{"text": "Traverse and update the hamming code", "code": "for ( i = 0 ; i < p_n ; i ++ ) {"}
{"text": "Find current position", "code": "int position = ( int ) pow ( 2 , i ) ;"}
{"text": "Find value at current position", "code": "int value = ham_calc ( position , c_l ) ;"}
{"text": "Update the code", "code": "code [ position - 1 ] = value ; }"}
{"text": "Print the Hamming Code", "code": "printf ( \" The generated Code Word is : \" for ( i = 0 ; i < c_l ; i ++ ) { printf ( \" % d \" , code [ i ] ) ; } }"}
{"text": "Driver Code", "code": "void main ( ) {"}
{"text": "Given input message Bit", "code": "input [ 0 ] = 0 ; input [ 1 ] = 1 ; input [ 2 ] = 1 ; input [ 3 ] = 1 ; int N = 4 ;"}
{"text": "Function Call", "code": "solve ( input , N ) ; }"}
{"text": "CPP program to find first non - repeating character using 1D array and one traversal .", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <math.h> NEW_LINE #define NO_OF_CHARS  256"}
{"text": "The function returns index of the first non - repeating character in a string . If all characters are repeating then returns INT_MAX", "code": "int firstNonRepeating ( char * str ) {"}
{"text": "Initialize all characters as absent .", "code": "int arr [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = -1 ;"}
{"text": "After below loop , the value of arr [ x ] is going to be index of of x if x appears only once . Else the value is going to be either - 1 or - 2.", "code": "for ( int i = 0 ; str [ i ] ; i ++ ) { if ( arr [ str [ i ] ] == -1 ) arr [ str [ i ] ] = i ; else arr [ str [ i ] ] = -2 ; } int res = INT_MAX ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ )"}
{"text": "If this character occurs only once and appears before the current result , then update the result", "code": "if ( arr [ i ] >= 0 ) res = min ( res , arr [ i ] ) ; return res ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { char str [ ] = \" geeksforgeeks \" ; int index = firstNonRepeating ( str ) ; if ( index == INT_MAX ) printf ( \" Either ▁ all ▁ characters ▁ are ▁ \" \" repeating ▁ or ▁ string ▁ is ▁ empty \" ) ; else printf ( \" First ▁ non - repeating ▁ character \" \" ▁ is ▁ % c \" , str [ index ] ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the nth triacontagonal Number", "code": "int triacontagonalNum ( int n ) { return ( 28 * n * n - 26 * n ) / 2 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ triacontagonal ▁ Number ▁ is ▁ = ▁ % d \" , triacontagonalNum ( n ) ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the nth hexacontagon Number", "code": "int hexacontagonNum ( int n ) { return ( 58 * n * n - 56 * n ) / 2 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ hexacontagon ▁ Number ▁ is ▁ = ▁ % d \" , hexacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the nth enneacontagon Number", "code": "int enneacontagonNum ( int n ) { return ( 88 * n * n - 86 * n ) / 2 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ enneacontagon ▁ Number ▁ is ▁ = ▁ % d \" , enneacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the nth triacontakaidigon Number", "code": "int triacontakaidigonNum ( int n ) { return ( 30 * n * n - 28 * n ) / 2 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ triacontakaidigon ▁ Number ▁ is ▁ = ▁ % d \" , triacontakaidigonNum ( n ) ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the nth Icosihexagonal Number", "code": "int IcosihexagonalNum ( int n ) { return ( 24 * n * n - 22 * n ) / 2 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ Icosihexagonal ▁ Number ▁ is ▁ = ▁ % d \" , IcosihexagonalNum ( n ) ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the nth icosikaioctagonal Number", "code": "int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ icosikaioctagonal ▁ Number ▁ is ▁ = ▁ % d \" , icosikaioctagonalNum ( n ) ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the nth octacontagon Number", "code": "int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ octacontagon ▁ Number ▁ is ▁ = ▁ % d \" , octacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the nth hectagon Number", "code": "int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ hectagon ▁ Number ▁ is ▁ = ▁ % d \" , hectagonNum ( n ) ) ; return 0 ; }"}
{"text": "C program for above approach", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Finding the nth tetracontagon Number", "code": "int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int n = 3 ; printf ( \"3rd ▁ tetracontagon ▁ Number ▁ is ▁ = ▁ % d \" , tetracontagonNum ( n ) ) ; return 0 ; }"}
{"text": "C program for the above approach", "code": "#include <stdio.h>"}
{"text": "Function to search if element X is present in reverse sorted array", "code": "int binarySearch ( int arr [ ] , int N , int X ) {"}
{"text": "Store the first index of the subarray in which X lies", "code": "int start = 0 ;"}
{"text": "Store the last index of the subarray in which X lies", "code": "int end = N ; while ( start <= end ) {"}
{"text": "Store the middle index of the subarray", "code": "int mid = start + ( end - start ) / 2 ;"}
{"text": "Check if value at middle index of the subarray equal to X", "code": "if ( X == arr [ mid ] ) {"}
{"text": "Element is found", "code": "return mid ; }"}
{"text": "If X is smaller than the value at middle index of the subarray", "code": "else if ( X < arr [ mid ] ) {"}
{"text": "Search in right half of subarray", "code": "start = mid + 1 ; } else {"}
{"text": "Search in left half of subarray", "code": "end = mid - 1 ; } }"}
{"text": "If X not found", "code": "return -1 ; }"}
{"text": "Driver Code", "code": "int main ( ) { int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 4 ; int res = binarySearch ( arr , N , X ) ; printf ( \" ▁ % d ▁ \" , res ) ; return 0 ; }"}
{"text": "C program to sort array using pancake sort", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h>"}
{"text": "Reverses arr [ 0. . i ]", "code": "void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } }"}
{"text": "Returns index of the maximum element in arr [ 0. . n - 1 ]", "code": "int findMax ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; }"}
{"text": "The main function that sorts given array using flip operations", "code": "void pancakeSort ( int * arr , int n ) {"}
{"text": "Start from the complete array and one by one reduce current size by one", "code": "for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) {"}
{"text": "Find index of the maximum element in arr [ 0. . curr_size - 1 ]", "code": "int mi = findMax ( arr , curr_size ) ;"}
{"text": "Move the maximum element to end of current array if it 's not already  at the end", "code": "if ( mi != curr_size - 1 ) {"}
{"text": "To move at the end , first move maximum number to beginning", "code": "flip ( arr , mi ) ;"}
{"text": "Now move the maximum number to end by reversing current array", "code": "flip ( arr , curr_size - 1 ) ; } } }"}
{"text": "A utility function to print n array of size n", "code": "void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) printf ( \" % d ▁ \" , arr [ i ] ) ; }"}
{"text": "Driver program to test above function", "code": "int main ( ) { int arr [ ] = { 23 , 10 , 20 , 11 , 12 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pancakeSort ( arr , n ) ; puts ( \" Sorted ▁ Array ▁ \" ) ; printArray ( arr , n ) ; return 0 ; }"}
